{"sha": "546c8f955804ad74b0382b012f64e621a02eebde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ2YzhmOTU1ODA0YWQ3NGIwMzgyYjAxMmY2NGU2MjFhMDJlZWJkZQ==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-11-13T15:35:47Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-11-13T15:36:30Z"}, "message": "MSP430: Add defaulting to the insn length attribute\n\nThe length of MSP430 instructions is mostly just a function of the type\nand number of operands. Setting the \"type\" attribute on all insns\ndescribes the number of operands, and the position of the source and\ndestination operands.\n\nIn most cases, defaulting in the \"length\" and \"extension\" attribute\ndefinitions can then be used to calculate the total length of the\ninstruction by using the value of the \"type\" attribute to examine the\noperands.\n\ngcc/ChangeLog:\n\n\t* config/msp430/msp430-protos.h (msp430x_extendhisi): Return int\n\tinstead of char *.\n\t(msp430_output_asm_shift_insns): Likewise.\n\tAdd new return_length argument.\n\t(msp430x_insn_required): Add prototype.\n\t* config/msp430/msp430.c (msp430_output_asm_shift_insns): Return the\n\ttotal length, in bytes, of the emitted instructions.\n\t(msp430x_insn_required): New function.\n\t(msp430x_extendhisi): Return the total length, in bytes, of the\n\temitted instructions.\n\t* config/msp430/msp430.h (ADJUST_INSN_LENGTH): Define.\n\t* config/msp430/msp430.md: New define_attr \"type\".\n\tNew define_attr \"extension\".\n\tNew define_attr \"length_multiplier\".\n\tNew define_attr \"extra_length\".\n\tRewrite define_attr \"length\".\n\tSet type, extension, length, length_multiplier or extra_length insn\n\tattributes on all insns, as appropriate.\n\t(andneghi3): Rewrite using constraints instead of C code to decide\n\toutput insns.\n\t* config/msp430/predicates.md (msp430_cheap_operand): New predicate.\n\t(msp430_high_memory_operand): New predicate.", "tree": {"sha": "53ade7d1dd5544885a644fe2a30923907e8baafc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53ade7d1dd5544885a644fe2a30923907e8baafc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/546c8f955804ad74b0382b012f64e621a02eebde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546c8f955804ad74b0382b012f64e621a02eebde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546c8f955804ad74b0382b012f64e621a02eebde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546c8f955804ad74b0382b012f64e621a02eebde/comments", "author": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f62dd3982398d031bc26c853522c5f4e20ef08fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62dd3982398d031bc26c853522c5f4e20ef08fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f62dd3982398d031bc26c853522c5f4e20ef08fc"}], "stats": {"total": 627, "additions": 506, "deletions": 121}, "files": [{"sha": "33ad1adc61f65711374dac65f1020f9262fb833a", "filename": "gcc/config/msp430/msp430-protos.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546c8f955804ad74b0382b012f64e621a02eebde/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546c8f955804ad74b0382b012f64e621a02eebde/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=546c8f955804ad74b0382b012f64e621a02eebde", "patch": "@@ -26,7 +26,7 @@ void\tmsp430_expand_eh_return (rtx);\n void\tmsp430_expand_epilogue (int);\n void\tmsp430_expand_helper (rtx *operands, const char *, bool);\n void\tmsp430_expand_prologue (void);\n-const char * msp430x_extendhisi (rtx *);\n+int msp430x_extendhisi (rtx *, bool);\n void\tmsp430_fixup_compare_operands (machine_mode, rtx *);\n int\tmsp430_hard_regno_nregs_has_padding (int, machine_mode);\n int\tmsp430_hard_regno_nregs_with_padding (int, machine_mode);\n@@ -49,10 +49,11 @@ rtx\tmsp430_subreg (machine_mode, rtx, machine_mode, int);\n bool    msp430_use_f5_series_hwmult (void);\n bool\tmsp430_has_hwmult (void);\n bool msp430_op_not_in_high_mem (rtx op);\n+bool msp430x_insn_required (rtx op);\n \n #ifdef RTX_CODE\n int msp430_expand_shift (enum rtx_code code, machine_mode mode, rtx *operands);\n-const char * msp430_output_asm_shift_insns (enum rtx_code code, machine_mode mode, rtx *operands);\n+int msp430_output_asm_shift_insns (enum rtx_code code, machine_mode mode, rtx *operands, bool);\n #endif\n \n #endif /* GCC_MSP430_PROTOS_H */"}, {"sha": "cc3472e853dc7509c1beb31bd22ec2413155db3a", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 118, "deletions": 44, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546c8f955804ad74b0382b012f64e621a02eebde/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546c8f955804ad74b0382b012f64e621a02eebde/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=546c8f955804ad74b0382b012f64e621a02eebde", "patch": "@@ -3520,18 +3520,22 @@ msp430_expand_shift (enum rtx_code code, machine_mode mode, rtx *operands)\n    For 430X it is inneficient to do so for any modes except SI and DI, since we\n    can make use of R*M insns or RPT with 430X insns, so this function is only\n    used for SImode in that case.  */\n-const char *\n+int\n msp430_output_asm_shift_insns (enum rtx_code code, machine_mode mode,\n-\t\t\t       rtx *operands)\n+\t\t\t       rtx *operands, bool return_length)\n {\n   int i;\n   int amt;\n   int max_shift = GET_MODE_BITSIZE (mode) - 1;\n+  int length = 0;\n+\n   gcc_assert (CONST_INT_P (operands[2]));\n   amt = INTVAL (operands[2]);\n \n   if (amt == 0 || amt > max_shift)\n     {\n+      if (return_length)\n+\treturn 0;\n       switch (code)\n \t{\n \tcase ASHIFT:\n@@ -3549,51 +3553,90 @@ msp430_output_asm_shift_insns (enum rtx_code code, machine_mode mode,\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      return \"\";\n+      return 0;\n     }\n \n   if (code == ASHIFT)\n     {\n       if (!msp430x && mode == HImode)\n-\tfor (i = 0; i < amt; i++)\n-\t  output_asm_insn (\"RLA.W\\t%0\", operands);\n+\t{\n+\t  if (return_length)\n+\t    length = 2 + (MEM_P (operands[0]) ? 2 : 0);\n+\t  else\n+\t    for (i = 0; i < amt; i++)\n+\t      output_asm_insn (\"RLA.W\\t%0\", operands);\n+\t}\n       else if (mode == SImode)\n-\tfor (i = 0; i < amt; i++)\n-\t  output_asm_insn (\"RLA%X0.W\\t%L0 { RLC%X0.W\\t%H0\", operands);\n+\t{\n+\t  if (return_length)\n+\t    length = 4 + (MEM_P (operands[0]) ? 4 : 0)\n+\t      + (4 * msp430x_insn_required (operands[0]));\n+\t  else\n+\t    for (i = 0; i < amt; i++)\n+\t      output_asm_insn (\"RLA%X0.W\\t%L0 { RLC%X0.W\\t%H0\", operands);\n+\t}\n       else\n \t/* Catch unhandled cases.  */\n \tgcc_unreachable ();\n     }\n   else if (code == ASHIFTRT)\n     {\n       if (!msp430x && mode == HImode)\n-\tfor (i = 0; i < amt; i++)\n-\t  output_asm_insn (\"RRA.W\\t%0\", operands);\n+\t{\n+\t  if (return_length)\n+\t    length = 2 + (MEM_P (operands[0]) ? 2 : 0);\n+\t  else\n+\t    for (i = 0; i < amt; i++)\n+\t      output_asm_insn (\"RRA.W\\t%0\", operands);\n+\t}\n       else if (mode == SImode)\n-\tfor (i = 0; i < amt; i++)\n-\t  output_asm_insn (\"RRA%X0.W\\t%H0 { RRC%X0.W\\t%L0\", operands);\n+\t{\n+\t  if (return_length)\n+\t    length = 4 + (MEM_P (operands[0]) ? 4 : 0)\n+\t      + (4 * msp430x_insn_required (operands[0]));\n+\t  else\n+\t    for (i = 0; i < amt; i++)\n+\t      output_asm_insn (\"RRA%X0.W\\t%H0 { RRC%X0.W\\t%L0\", operands);\n+\t}\n       else\n \tgcc_unreachable ();\n     }\n   else if (code == LSHIFTRT)\n     {\n       if (!msp430x && mode == HImode)\n-\tfor (i = 0; i < amt; i++)\n-\t  output_asm_insn (\"CLRC { RRC.W\\t%0\", operands);\n+\t{\n+\t  if (return_length)\n+\t    length = 4 + (MEM_P (operands[0]) ? 2 : 0);\n+\t  else\n+\t    for (i = 0; i < amt; i++)\n+\t      output_asm_insn (\"CLRC { RRC.W\\t%0\", operands);\n+\t}\n       else if (mode == SImode)\n-\tfor (i = 0; i < amt; i++)\n-\t  output_asm_insn (\"CLRC { RRC%X0.W\\t%H0 { RRC%X0.W\\t%L0\", operands);\n+\t{\n+\t  if (return_length)\n+\t    length = 6 + (MEM_P (operands[0]) ? 4 : 0)\n+\t      + (4 * msp430x_insn_required (operands[0]));\n+\t  else\n+\t    for (i = 0; i < amt; i++)\n+\t      output_asm_insn (\"CLRC { RRC%X0.W\\t%H0 { RRC%X0.W\\t%L0\",\n+\t\t\t       operands);\n+\t}\n       /* FIXME: Why doesn't \"RRUX.W\\t%H0 { RRC%X0.W\\t%L0\" work for msp430x?\n \t It causes execution timeouts e.g. pr41963.c.  */\n #if 0\n       else if (msp430x && mode == SImode)\n-\tfor (i = 0; i < amt; i++)\n-\t  output_asm_insn (\"RRUX.W\\t%H0 { RRC%X0.W\\t%L0\", operands);\n+\t{\n+\t  if (return_length)\n+\t    length = 2;\n+\t  else\n+\t    for (i = 0; i < amt; i++)\n+\t      output_asm_insn (\"RRUX.W\\t%H0 { RRC%X0.W\\t%L0\", operands);\n+\t}\n #endif\n       else\n \tgcc_unreachable ();\n     }\n-  return \"\";\n+  return length * amt;\n }\n \n /* Called by cbranch<mode>4 to coerce operands into usable forms.  */\n@@ -4115,6 +4158,20 @@ msp430_op_not_in_high_mem (rtx op)\n   return false;\n }\n \n+/* Based on the operand OP, is a 430X insn required to handle it?\n+   There are only 3 conditions for which a 430X insn is required:\n+   - PSImode operand\n+   - memory reference to a symbol which could be in upper memory\n+     (so its address is > 0xFFFF)\n+   - absolute address which has VOIDmode, i.e. (mem:HI (const_int))\n+   Use a 430 insn if none of these conditions are true.  */\n+bool\n+msp430x_insn_required (rtx op)\n+{\n+  return (GET_MODE (op) == PSImode\n+\t  || !msp430_op_not_in_high_mem (op));\n+}\n+\n #undef  TARGET_PRINT_OPERAND\n #define TARGET_PRINT_OPERAND\t\tmsp430_print_operand\n \n@@ -4455,35 +4512,52 @@ msp430_register_pre_includes (const char *sysroot ATTRIBUTE_UNUSED,\n \n /* Generate a sequence of instructions to sign-extend an HI\n    value into an SI value.  Handles the tricky case where\n-   we are overwriting the destination.  */\n-\n-const char *\n-msp430x_extendhisi (rtx * operands)\n+   we are overwriting the destination.\n+   Return the number of bytes used by the emitted instructions.\n+   If RETURN_LENGTH is true then do not emit the assembly instruction\n+   sequence.  */\n+int\n+msp430x_extendhisi (rtx * operands, bool return_length)\n {\n   if (REGNO (operands[0]) == REGNO (operands[1]))\n-    /* Low word of dest == source word.  8-byte sequence.  */\n-    return \"BIT.W\\t#0x8000, %L0 { SUBC.W\\t%H0, %H0 { INV.W\\t%H0, %H0\";\n-\n-  if (! msp430x)\n-    /* Note: This sequence is approximately the same length as invoking a helper\n-       function to perform the sign-extension, as in:\n-\n-       MOV.W  %1, %L0\n-       MOV.W  %1, r12\n-       CALL   __mspabi_srai_15\n-       MOV.W  r12, %H0\n-\n-       but this version does not involve any function calls or using argument\n-       registers, so it reduces register pressure.  10-byte sequence.  */\n-    return \"MOV.W\\t%1, %L0 { BIT.W\\t#0x8000, %L0 { SUBC.W\\t%H0, %H0 \"\n-      \"{ INV.W\\t%H0, %H0\";\n-\n-  if (REGNO (operands[0]) + 1 == REGNO (operands[1]))\n-    /* High word of dest == source word.  6-byte sequence.  */\n-    return \"MOV.W\\t%1, %L0 { RPT\\t#15 { RRAX.W\\t%H0\";\n+    {\n+      /* Low word of dest == source word.  */\n+      if (!return_length)\n+\toutput_asm_insn (\"BIT.W\\t#0x8000, %L0 { SUBC.W\\t%H0, %H0 { INV.W\\t%H0, %H0\",\n+\t\t\t operands);\n+      return 8;\n+    }\n+  else if (! msp430x)\n+    {\n+      /* Note: This sequence is approximately the same length as invoking a\n+\t helper function to perform the sign-extension, as in:\n+\n+\t MOV.W  %1, %L0\n+\t MOV.W  %1, r12\n+\t CALL   __mspabi_srai_15\n+\t MOV.W  r12, %H0\n+\n+\t but this version does not involve any function calls or using argument\n+\t registers, so it reduces register pressure.  */\n+      if (!return_length)\n+\toutput_asm_insn (\"MOV.W\\t%1, %L0 { BIT.W\\t#0x8000, %L0 { SUBC.W\\t%H0, %H0 { INV.W\\t%H0, %H0\",\n+\t\t\t operands);\n+      return 10;\n+    }\n+  else if (REGNO (operands[0]) + 1 == REGNO (operands[1]))\n+    {\n+      /* High word of dest == source word.  */\n+      if (!return_length)\n+\toutput_asm_insn (\"MOV.W\\t%1, %L0 { RPT\\t#15 { RRAX.W\\t%H0\",\n+\t\t\t operands);\n+      return 6;\n+    }\n \n-  /* No overlap between dest and source.  8-byte sequence.  */\n-  return \"MOV.W\\t%1, %L0 { MOV.W\\t%1, %H0 { RPT\\t#15 { RRAX.W\\t%H0\";\n+  /* No overlap between dest and source.  */\n+  if (!return_length)\n+    output_asm_insn (\"MOV.W\\t%1, %L0 { MOV.W\\t%1, %H0 { RPT\\t#15 { RRAX.W\\t%H0\",\n+\t\t     operands);\n+  return 8;\n }\n \n /* Stop GCC from thinking that it can eliminate (SUBREG:PSI (SI)).  */"}, {"sha": "c2fcaef6c5045810bd0beacc7f1e98217103a817", "filename": "gcc/config/msp430/msp430.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546c8f955804ad74b0382b012f64e621a02eebde/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546c8f955804ad74b0382b012f64e621a02eebde/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.h?ref=546c8f955804ad74b0382b012f64e621a02eebde", "patch": "@@ -530,3 +530,13 @@ void msp430_register_pre_includes (const char *sysroot ATTRIBUTE_UNUSED,\n \n \n #define SYMBOL_FLAG_LOW_MEM (SYMBOL_FLAG_MACH_DEP << 0)\n+\n+#define ADJUST_INSN_LENGTH(insn, length) \\\n+  do\t\\\n+    {\t\\\n+      if (recog_memoized (insn) >= 0)\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  length += get_attr_extra_length (insn);\t\\\n+\t  length *= get_attr_length_multiplier (insn);\t\\\n+\t}\t\t\t\t\t\t\\\n+    } while (0)"}, {"sha": "65e951774b16a395762bb1ad44d4751ae2f80b24", "filename": "gcc/config/msp430/msp430.md", "status": "modified", "additions": 362, "deletions": 75, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546c8f955804ad74b0382b012f64e621a02eebde/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546c8f955804ad74b0382b012f64e621a02eebde/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.md?ref=546c8f955804ad74b0382b012f64e621a02eebde", "patch": "@@ -58,8 +58,100 @@\n    UNS_DELAY_END\n   ])\n \n-;; This is an approximation.\n-(define_attr \"length\" \"\" (const_int 4))\n+;; Instruction length is calculated by examining the type and number of\n+;; operands.\n+;; Whether the insn uses the 430X extension word, or is a 430X address\n+;; instruction also has an effect.\n+;; \"Cheap\" source operands do not contribute to the overall length of the insn\n+;; and are register (Rn), indirect post-increment (@Rn+) and indirect register\n+;; (@Rn).\n+;; The lengths of instructions in bytes are:\n+;; Single-op 430: Cheap op == 2\n+;; (also CALLA)   Other op == 4\n+;; Double-op 430: Source is not cheap == 2\n+;;  (also MOVA,   Dest is register == 2\n+;;   CMPA, ADDA,  Dest is not a register == 4\n+;;   SUBA)\t  (sum the source and dest cost)\n+;; Single-op 430X: For insn names ending in 'X' add 2 to single-op 430 cost.\n+;; Double-op 430X: Insn name ends in 'M' == 2\n+;;\t\t   Others have the same cost as double-op 430 but add 2.\n+;;\n+;; The insn type describes whether it is a single or double operand MSP430\n+;; instruction (some single-operand GCC instructions are actually\n+;; double-operand on the target).\n+;; \"triple\" and \"cmp\" types use the costs of a double operand type but\n+;; instead assume that the src operand is in op2, and also cmp types assume the\n+;; dst operand is in op1.\n+;; This attribute also describes which operands are safe to examine\n+;; when calculating the length or extension.  GCC will segfault trying to\n+;; examine a non-existant operand of an insn.\n+(define_attr \"type\" \"none,single,double,triple,cmp\" (const_string \"none\"))\n+\n+;; The M extension is for instructions like RRAM - they always\n+;; only, and the operand must be a register.\n+(define_attr \"extension\" \"none,x,a,m\"\n+ (cond [(eq_attr \"type\" \"none\")\n+\t(const_string \"none\")\n+\t(match_operand 0 \"msp430_high_memory_operand\" \"\")\n+\t(const_string \"x\")\n+\t(and (eq_attr \"type\" \"double\")\n+\t     (match_operand 1 \"msp430_high_memory_operand\" \"\"))\n+\t(const_string \"x\")\n+\t(and (ior (eq_attr \"type\" \"triple\") (eq_attr \"type\" \"cmp\"))\n+\t     (ior (match_operand 1 \"msp430_high_memory_operand\" \"\")\n+\t\t  (match_operand 2 \"msp430_high_memory_operand\" \"\")))\n+\t(const_string \"x\")]\n+\t(const_string \"none\")))\n+\n+;; Multiply the default length by this constant value.\n+(define_attr \"length_multiplier\" \"\" (const_int 1))\n+\n+;; Add an additional amount to the total length of the insn.\n+(define_attr \"extra_length\" \"\" (const_int 0))\n+\n+;; FIXME for some reason if we move the addition of 2 for extension == x to\n+;; ADJUST_INSN_LENGTH, codesize gets much worse.\n+(define_attr \"length\" \"\"\n+ (cond [(eq_attr \"extension\" \"m\")\n+\t(const_int 2)\n+\t(eq_attr \"type\" \"single\")\n+\t(plus (if_then_else (match_operand 0 \"msp430_cheap_operand\" \"\")\n+\t\t\t    (const_int 2)\n+\t\t\t    (const_int 4))\n+\t      (if_then_else (eq_attr \"extension\" \"x\")\n+\t\t\t    (const_int 2)\n+\t\t\t    (const_int 0)))\n+\t(eq_attr \"type\" \"double\")\n+\t(plus (plus (if_then_else (match_operand 0 \"register_operand\" \"\")\n+\t\t\t\t   (const_int 2)\n+\t\t\t\t   (const_int 4))\n+\t\t    (if_then_else (match_operand 1 \"msp430_cheap_operand\" \"\")\n+\t\t\t\t  (const_int 0)\n+\t\t\t\t  (const_int 2)))\n+\t      (if_then_else (eq_attr \"extension\" \"x\")\n+\t\t\t    (const_int 2)\n+\t\t\t    (const_int 0)))\n+\t(eq_attr \"type\" \"triple\")\n+\t(plus (plus (if_then_else (match_operand 0 \"register_operand\" \"\")\n+\t\t\t\t   (const_int 2)\n+\t\t\t\t   (const_int 4))\n+\t\t    (if_then_else (match_operand 2 \"msp430_cheap_operand\" \"\")\n+\t\t\t\t  (const_int 0)\n+\t\t\t\t  (const_int 2)))\n+\t      (if_then_else (eq_attr \"extension\" \"x\")\n+\t\t\t    (const_int 2)\n+\t\t\t    (const_int 0)))\n+\t(eq_attr \"type\" \"cmp\")\n+\t(plus (plus (if_then_else (match_operand 1 \"register_operand\" \"\")\n+\t\t\t\t   (const_int 2)\n+\t\t\t\t   (const_int 4))\n+\t\t    (if_then_else (match_operand 2 \"msp430_cheap_operand\" \"\")\n+\t\t\t\t  (const_int 0)\n+\t\t\t\t  (const_int 2)))\n+\t      (if_then_else (eq_attr \"extension\" \"x\")\n+\t\t\t    (const_int 2)\n+\t\t\t    (const_int 0)))]\n+  (const_int 2)))\n \n (include \"predicates.md\")\n (include \"constraints.md\")\n@@ -97,35 +189,43 @@\n \t(match_operand:HI 0 \"register_operand\" \"r\"))]\n   \"\"\n   \"PUSH\\t%0\"\n-  )\n+  [(set_attr \"type\" \"single\")]\n+)\n \n (define_insn \"pusha\"\n   [(set (mem:PSI (pre_dec:PSI (reg:PSI SP_REGNO)))\n \t(match_operand:PSI 0 \"register_operand\" \"r\"))]\n   \"TARGET_LARGE\"\n   \"PUSHX.A\\t%0\"\n-  )\n+  [(set_attr \"type\" \"single\")\n+   (set_attr \"extension\" \"x\")]\n+)\n \n (define_insn \"pushm\"\n   [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")\n \t\t     (match_operand 1 \"immediate_operand\" \"n\")] UNS_PUSHM)]\n   \"\"\n   \"PUSHM%b0\\t%1, %0\"\n-  )\n+  [(set_attr \"type\" \"single\")\n+   (set_attr \"extension\" \"m\")]\n+)\n \n (define_insn \"pop\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mem:HI (post_inc:HI (reg:HI SP_REGNO))))]\n   \"\"\n   \"POP\\t%0\"\n-  )\n+  [(set_attr \"type\" \"single\")]\n+)\n \n (define_insn \"popa\"\n   [(set (match_operand:PSI 0 \"register_operand\" \"=r\")\n \t(mem:PSI (post_inc:PSI (reg:PSI SP_REGNO))))]\n   \"TARGET_LARGE\"\n   \"POPX.A\\t%0\"\n-  )\n+  [(set_attr \"type\" \"single\")\n+   (set_attr \"extension\" \"x\")]\n+)\n \n ;; This is nasty.  Operand0 is bogus.  It is only there so that we can get a\n ;; mode for the %b0 to work.  We should use operand1 for this, but that does\n@@ -144,7 +244,9 @@\n \t\t     (match_operand 2 \"immediate_operand\" \"i\")] UNS_POPM)]\n   \"\"\n   \"POPM%b0\\t%2, r%J1\"\n-  )\n+  [(set_attr \"type\" \"single\")\n+   (set_attr \"extension\" \"m\")]\n+)\n \n ;; The next two patterns are here to support a \"feature\" of how GCC implements\n ;; varargs.  When a function uses varargs and the *second* to last named\n@@ -170,6 +272,10 @@\n       return \\\"SUBA\\t#2, r1 { MOVX.A\\t2(r1), 0(r1)\\\";\n     return \\\"SUB\\t#2, r1 { MOV.W\\t2(r1), 0(r1)\\\";\n   \"\n+  [(set (attr \"length\")\n+\t(if_then_else (match_test \"TARGET_LARGE\")\n+\t\t      (const_int 8)\n+\t\t      (const_int 6)))]\n )\n \n (define_insn \"swap_and_shrink\"\n@@ -178,7 +284,12 @@\n   \"* return TARGET_LARGE\n \t   ? \\\"MOVX.A\\t0(r1), 2(r1) { ADDA\\t#2, SP\\\"\n \t   : \\\"MOV.W\\t0(r1), 2(r1) { ADD\\t#2, SP\\\";\n-  \")\n+  \"\n+  [(set (attr \"length\")\n+\t(if_then_else (match_test \"TARGET_LARGE\")\n+\t\t      (const_int 10)\n+\t\t      (const_int 8)))]\n+)\n \n ; I set LOAD_EXTEND_OP and WORD_REGISTER_OPERATIONS, but gcc puts in a\n ; zero_extend anyway.  Catch it here.\n@@ -189,13 +300,16 @@\n   \"@\n    MOV.B\\t%1, %0\n    MOV%X1.B\\t%1, %0\"\n+  [(set_attr \"type\" \"double\")]\n )\n \n (define_insn \"movqi_topbyte\"\n   [(set (match_operand:QI 0 \"msp430_general_dst_operand\" \"=r\")\n \t(subreg:QI (match_operand:PSI 1 \"msp430_general_operand\" \"r\") 2))]\n   \"msp430x\"\n   \"PUSHM.A\\t#1,%1 { POPM.W\\t#1,%0 { POPM.W\\t#1,%0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"type\" \"double\")]\n )\n \n (define_insn \"movqi\"\n@@ -205,6 +319,7 @@\n   \"@\n   MOV.B\\t%1, %0\n   MOVX.B\\t%1, %0\"\n+  [(set_attr \"type\" \"double\")]\n )\n \n (define_insn \"movhi\"\n@@ -215,14 +330,15 @@\n   MOV.B\\t%1, %0\n   MOV.W\\t%1, %0\n   MOVX.W\\t%1, %0\"\n+  [(set_attr \"type\" \"double\")]\n )\n \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"msp430_general_dst_nonv_operand\")\n \t(match_operand:SI 1 \"general_operand\"))]\n   \"\"\n   \"\"\n-  )\n+)\n \n (define_insn_and_split \"movsi_s\"\n   [(set (match_operand:SI 0 \"msp430_general_dst_nonv_operand\" \"=rm\")\n@@ -235,7 +351,8 @@\n    (set (match_operand:HI 3 \"msp430_general_dst_nonv_operand\")\n \t(match_operand:HI 5 \"general_operand\"))]\n   \"msp430_split_movsi (operands);\"\n-  )\n+  [(set_attr \"type\" \"double\")]\n+)\n \n (define_insn_and_split \"movsi_x\"\n   [(set (match_operand:SI 0 \"msp430_general_dst_nonv_operand\" \"=rm\")\n@@ -248,6 +365,7 @@\n    (set (match_operand:HI 3 \"msp430_general_dst_nonv_operand\")\n \t(match_operand:HI 5 \"general_operand\"))]\n   \"msp430_split_movsi (operands);\"\n+  [(set_attr \"type\" \"double\")]\n )\n \n ;; FIXME: Some MOVX.A cases can be done with MOVA, this is only a few of them.\n@@ -260,7 +378,10 @@\n   MOV.W\\t%1, %0\n   MOVA\\t%1, %0\n   MOVA\\t%1, %0\n-  MOVX.A\\t%1, %0\")\n+  MOVX.A\\t%1, %0\"\n+  [(set_attr \"extension\" \"none,none,a,a,x\")\n+   (set_attr \"type\" \"double\")]\n+)\n \n ; This pattern is identical to the truncsipsi2 pattern except\n ; that it uses a SUBREG instead of a TRUNC.  It is needed in\n@@ -274,6 +395,8 @@\n \t(subreg:PSI (match_operand:SI 1 \"register_operand\" \"r\") 0))]\n   \"msp430x\"\n   \"PUSH.W\\t%H1 { PUSH.W\\t%L1 { POPM.A #1, %0 ; Move reg-pair %L1:%H1 into pointer %0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"type\" \"double\")]\n )\n \n ;; Produced when converting a pointer to an integer via a union, eg gcc.dg/pr47201.c.\n@@ -282,6 +405,8 @@\n \t(subreg:HI (match_operand:PSI 1 \"msp430_symbol_operand\" \"i\") 0))]\n   \"msp430x\"\n   \"MOVA\\t%1, %0\"\n+  [(set_attr \"extension\" \"a\")\n+   (set_attr \"type\" \"double\")]\n )\n \n ;;------------------------------------------------------------\n@@ -295,6 +420,8 @@\n   \"@\n   ADDA\\t%2, %0\n   ADDX.A\\t%2, %0\"\n+  [(set_attr \"extension\" \"a,x\")\n+   (set_attr \"type\" \"triple\")]\n )\n \n (define_insn \"addqi3\"\n@@ -305,6 +432,7 @@\n   \"@\n    ADD.B\\t%2, %0\n    ADDX.B\\t%2, %0\"\n+  [(set_attr \"type\" \"triple\")]\n )\n \n (define_insn \"addhi3\"\n@@ -315,6 +443,7 @@\n   \"@\n    ADD.W\\t%2, %0\n    ADDX.W\\t%2, %0\"\n+  [(set_attr \"type\" \"triple\")]\n )\n \n ; This pattern is needed in order to avoid reload problems.\n@@ -327,6 +456,13 @@\n \t\t (match_operand       2 \"general_operand\" \"rmi\")))]\n   \"\"\n   \"ADD%X2.W\\t%L2, %L0 { ADDC%X2.W\\t%H2, %H0 { PUSH.W\\t%H0 { PUSH.W\\t%L0 { POPM.A\\t#1, %0\"\n+  [(set (attr \"length\")\n+\t(if_then_else (match_operand 2 \"register_operand\" \"\")\n+\t\t      (const_int 10)\n+\t\t      (if_then_else (match_operand 2 \"msp430_high_memory_operand\" \"\")\n+\t\t\t\t    (const_int 18)\n+\t\t\t\t    (const_int 14))))\n+   (set_attr \"type\" \"triple\")]\n )\n \n (define_insn \"addsi3\"\n@@ -337,6 +473,8 @@\n   \"@\n    ADD\\t%L2, %L0 { ADDC\\t%H2, %H0\n    ADDX\\t%L2, %L0 { ADDCX\\t%H2, %H0\"\n+  [(set_attr \"length_multiplier\" \"2\")\n+   (set_attr \"type\" \"triple\")]\n )\n \n ; Version of addhi that exposes the carry operations, for SImode adds.\n@@ -382,7 +520,8 @@\n   \"@\n    ADD\\t%2, %1 ; cy\n    ADDX\\t%2, %1 ; cy\"\n-  )\n+  [(set_attr \"type\" \"triple\")]\n+)\n \n (define_insn \"addhi3_cy_i\"\n   [(set (match_operand:HI\t   0 \"msp430_general_dst_nonv_operand\" \"=r,rm\")\n@@ -397,7 +536,8 @@\n   \"@\n    ADD\\t%2, %1 ; cy\n    ADD%X0\\t%2, %1 ; cy\"\n-  )\n+  [(set_attr \"type\" \"triple\")]\n+)\n \n ; Version of addhi that adds the carry, for SImode adds.\n (define_insn \"addchi4_cy\"\n@@ -410,7 +550,8 @@\n   \"@\n    ADDC\\t%2, %1\n    ADDCX\\t%2, %1\"\n-  )\n+  [(set_attr \"type\" \"triple\")]\n+)\n \n ; Split an SImode add into two HImode adds, keeping track of the carry\n ; so that gcc knows when it can and can't optimize away the two\n@@ -440,7 +581,7 @@\n   if (msp430_split_addsi (operands))\n     FAIL;\n   \"\n-  )\n+)\n \n \n ;; Alternatives 2 and 3 are to handle cases generated by reload.\n@@ -454,6 +595,9 @@\n   SUBX.A\\t%2, %0\n   MOVX.A\\t%1, %0 { SUBX.A\\t%2, %0\n   MOVX.A\\t%1, %0 { SUBA\\t%2, %0\"\n+  [(set_attr \"type\" \"triple\")\n+   (set_attr \"extension\" \"a,x,x,x\")\n+   (set_attr \"length_multiplier\" \"1,1,2,2\")]\n )\n \n ;; Alternatives 2 and 3 are to handle cases generated by reload.\n@@ -467,6 +611,8 @@\n   SUBX.B\\t%2, %0\n   MOV%X2.B\\t%1, %0 { SUB%X2.B\\t%2, %0\n   MOV%X0.B\\t%1, %0 { SUB%X0.B\\t%2, %0\"\n+  [(set_attr \"length_multiplier\" \"1,1,2,2\")\n+   (set_attr \"type\" \"triple\")]\n )\n \n ;; Alternatives 2 and 3 are to handle cases generated by reload.\n@@ -480,6 +626,8 @@\n   SUBX.W\\t%2, %0\n   MOV%X2.W\\t%1, %0 { SUB%X2.W\\t%2, %0\n   MOV%X0.W\\t%1, %0 { SUB%X0.W\\t%2, %0\"\n+  [(set_attr \"length_multiplier\" \"1,1,2,2\")\n+   (set_attr \"type\" \"triple\")]\n )\n \n (define_insn \"subsi3\"\n@@ -490,6 +638,8 @@\n   \"@\n   SUB\\t%L2, %L0 { SUBC\\t%H2, %H0\n   SUBX\\t%L2, %L0 { SUBCX\\t%H2, %H0\"\n+  [(set_attr \"length_multiplier\" \"2\")\n+   (set_attr \"type\" \"triple\")]\n )\n \n (define_insn \"*bic<mode>_cg\"\n@@ -500,6 +650,8 @@\n   \"@\n    BIC%x0%b0\\t#%I2, %0\n    BIC%X0%b0\\t#%I2, %0\"\n+  [(set_attr \"length\" \"2\")\t; Smaller length achieved by using constant generator\n+   (set_attr \"type\" \"double\")]\n )\n \n (define_insn \"bic<mode>3\"\n@@ -510,6 +662,7 @@\n   \"@\n    BIC%x0%b0\\t%1, %0\n    BICX%b0\\t%1, %0\"\n+  [(set_attr \"type\" \"double\")]\n )\n \n (define_insn \"and<mode>3\"\n@@ -521,6 +674,7 @@\n    AND%x0.B\\t%2, %0\n    AND%x0%b0\\t%2, %0\n    ANDX%b0\\t%2, %0\"\n+  [(set_attr \"type\" \"triple\")]\n )\n \n (define_insn \"ior<mode>3\"\n@@ -531,6 +685,7 @@\n   \"@\n    BIS%x0%b0\\t%2, %0\n    BISX%b0\\t%2, %0\"\n+  [(set_attr \"type\" \"triple\")]\n )\n \n (define_insn \"xor<mode>3\"\n@@ -541,6 +696,7 @@\n   \"@\n    XOR%x0%b0\\t%2, %0\n    XORX%b0\\t%2, %0\"\n+  [(set_attr \"type\" \"triple\")]\n )\n \n ;; Macro : XOR #~0, %0\n@@ -551,6 +707,7 @@\n   \"@\n    INV%x0%b0\\t%0\n    INV%X0%b0\\t%0\"\n+  [(set_attr \"type\" \"double\")]\n )\n \n (define_insn \"extendqihi2\"\n@@ -560,6 +717,7 @@\n   \"@\n    SXT%X0\\t%0\n    SXT%X0\\t%0\"\n+  [(set_attr \"type\" \"single\")]\n )\n \n (define_insn \"extendqipsi2\"\n@@ -569,6 +727,8 @@\n   \"@\n   SXT\\t%0\n   SXTX.A\\t%0\"\n+  [(set_attr \"type\" \"single\")\n+   (set_attr \"extension\" \"none,x\")]\n )\n \n ;; ------------------------\n@@ -590,6 +750,7 @@\n    MOV.B\\t%1, %0\n    MOV%X1.B\\t%1, %0\n    AND%X0\\t#0xff, %0\"\n+  [(set_attr \"type\" \"double\")]\n )\n \n (define_insn \"zero_extendqipsi2\"\n@@ -599,6 +760,7 @@\n   \"@\n    MOV.B\\t%1, %0\n    MOV%X1.B\\t%1, %0\"\n+  [(set_attr \"type\" \"double\")]\n )\n \n (define_insn \"zero_extendqisi2\"\n@@ -608,6 +770,9 @@\n   \"@\n   CLR\\t%H0\n   MOV%X1.B\\t%1,%L0 { CLR\\t%H0\"\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"length_multiplier\" \"1,2\")\n+   (set_attr \"type\" \"double\")]\n )\n \n (define_insn \"zero_extendhipsi2\"\n@@ -618,6 +783,7 @@\n   MOV.W\\t%1, %0\n   MOV%X1\\t%1, %0\n   MOVX.A\\t%1, %0\"\n+  [(set_attr \"type\" \"double\")]\n )\n \n (define_insn \"zero_extendhisi2\"\n@@ -627,6 +793,8 @@\n   \"@\n   MOV%X0.W\\t#0,%H0\n   MOV.W\\t%1,%L0 { MOV.W\\t#0,%H0\"\n+  [(set_attr \"length_multiplier\" \"1,2\")\n+   (set_attr \"type\" \"double\")]\n )\n \n (define_insn \"zero_extendhisipsi2\"\n@@ -636,6 +804,8 @@\n   \"@\n    AND.W\\t#-1,%0\n    MOV.W\\t%1,%0\"\n+  [(set_attr \"length\" \"4,2\")\n+   (set_attr \"type\" \"double\")]\n )\n \n ; Nasty - we are sign-extending a 20-bit PSI value in one register into\n@@ -671,6 +841,13 @@\n     else \\\n       return \\\"PUSHM.A\\t#1, %1 { POPX.W\\t%L0 { POPX.W\\t%H0 ; move pointer in %1 into reg-pair %L0:%H0\\\";\n   MOVX.A %1, %0\"\n+  [(set (attr \"length\")\n+    (cond [(match_test \"REGNO (operands[1]) == SP_REGNO\")\n+\t   (const_int 18)\n+\t   (eq_attr \"alternative\" \"1\")\n+\t   (const_int 6)]\n+\t   (const_int 10)))\n+   (set_attr \"type\" \"double\")]\n )\n \n ;; Below are unnamed insn patterns to catch pointer manipulation insns\n@@ -687,6 +864,7 @@\n \t(sign_extend:PSI (subreg:HI (match_operand:QI 1 \"general_operand\" \"rm\") 0)))]\n   \"msp430x\"\n   \"MOV%X1.B\\t%1, %0\"\n+  [(set_attr \"type\" \"double\")]\n )\n \n (define_insn \"\"\n@@ -696,6 +874,7 @@\n   \"@\n    MOV.B\\t%1, %0\n    MOV%X1.B\\t%1, %0\"\n+  [(set_attr \"type\" \"double\")]\n )\n \n ;; The next three insns emit identical assembly code.\n@@ -711,6 +890,9 @@\n   RLAM.W %2, %L0 { CLR %H0\n   MOV%X1.B %1, %L0 { RLAM.W %2, %L0 { CLR %H0\n   MOV%X1.B %1, %L0 { RPT %2 { RLAX.W %L0 { CLR %H0\"\n+  [(set_attr \"length\" \"4,*,*\")\n+   (set_attr \"extra_length\" \"0,4,6\")\n+   (set_attr \"type\" \"double\")]\n )\n \n (define_insn \"\"\n@@ -722,6 +904,9 @@\n   RLAM.W %2, %L0 { CLR %H0\n   MOV%X1.B %1, %L0 { RLAM.W %2, %L0 { CLR %H0\n   MOV%X1.B %1, %L0 { RPT %2 { RLAX.W %L0 { CLR %H0\"\n+  [(set_attr \"length\" \"4,*,*\")\n+   (set_attr \"extra_length\" \"0,4,6\")\n+   (set_attr \"type\" \"double\")]\n )\n \n ;; Same as above but with a NOP sign_extend round the subreg\n@@ -734,13 +919,18 @@\n   RLAM.W %2, %L0 { CLR %H0\n   MOV%X1.B %1, %L0 { RLAM.W %2, %L0 { CLR %H0\n   MOV%X1.B %1, %L0 { RPT %2 { RLAX.W %L0 { CLR %H0\"\n+  [(set_attr \"length\" \"4,*,*\")\n+   (set_attr \"extra_length\" \"0,4,6\")\n+   (set_attr \"type\" \"double\")]\n )\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extend:SI (sign_extend:PSI (subreg:HI (match_operand:QI 1 \"general_operand\" \"rm\") 0))))]\n   \"msp430x\"\n   \"MOV%X1.B %1, %L0 { CLR %H0\"\n+  [(set_attr \"extra_length\" \"4\")\n+   (set_attr \"type\" \"double\")]\n )\n \n (define_insn \"\"\n@@ -752,6 +942,9 @@\n   RLAM.W %2, %0\n   MOV%X1.B %1, %0 { RLAM.W %2, %0\n   MOV%X1.B %1, %0 { RPT %2 { RLAX.A %0\"\n+  [(set_attr \"length\" \"2,*,*\")\n+   (set_attr \"extra_length\" \"0,2,4\")\n+   (set_attr \"type\" \"double\")]\n )\n ;; END msp430 pointer manipulation combine insn patterns\n \n@@ -771,20 +964,28 @@\n \t(truncate:HI (match_operand:PSI 1 \"register_operand\"      \"r\")))]\n   \"\"\n   \"MOVX\\t%1, %0\"\n+  [(set_attr \"extension\" \"m\")\n+   (set_attr \"type\" \"double\")]\n )\n \n (define_insn \"extendhisi2\"\n   [(set (match_operand:SI 0 \"msp430_general_dst_nonv_operand\" \"=r\")\n \t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r\")))]\n   \"\"\n-  { return msp430x_extendhisi (operands); }\n+  { msp430x_extendhisi (operands, 0); return \"\"; }\n+  [(set (attr \"length\")\n+\t(symbol_ref \"msp430x_extendhisi (operands, 1)\"))\n+   (set_attr \"type\" \"double\")]\n )\n \n (define_insn \"extendhipsi2\"\n   [(set (match_operand:PSI 0 \"msp430_general_dst_nonv_operand\" \"=r\")\n \t(subreg:PSI (sign_extend:SI (match_operand:HI 1 \"general_operand\" \"0\")) 0))]\n   \"msp430x\"\n   \"RLAM.A #4, %0 { RRAM.A #4, %0\"\n+  [(set_attr \"length_multiplier\" \"2\")\n+   (set_attr \"extension\" \"m\")\n+   (set_attr \"type\" \"double\")]\n )\n \n ;; Look for cases where integer/pointer conversions are suboptimal due\n@@ -798,6 +999,9 @@\n \t\t   (const_int 1)))]\n   \"msp430x\"\n   \"RLAM.A #4, %0 { RRAM.A #3, %0\"\n+  [(set_attr \"length_multiplier\" \"2\")\n+   (set_attr \"extension\" \"m\")\n+   (set_attr \"type\" \"double\")]\n )\n \n (define_insn \"extend_and_shift2_hipsi2\"\n@@ -806,6 +1010,9 @@\n \t\t   (const_int 2)))]\n   \"msp430x\"\n   \"RLAM.A #4, %0 { RRAM.A #2, %0\"\n+  [(set_attr \"length_multiplier\" \"2\")\n+   (set_attr \"extension\" \"m\")\n+   (set_attr \"type\" \"double\")]\n )\n \n ;; We also need to be able to sign-extend pointer types (eg ptrdiff_t).\n@@ -827,6 +1034,8 @@\n     else\n       return \\\"MOV.W\\t%1, %L0 { MOVX.A\\t%1, %H0 { RPT\\t#16 { RRAX.A\\t%H0 ; sign extend pointer in %1 into %L0:%H0\\\";\n   \"\n+  [(set_attr \"length\" \"10\")\n+   (set_attr \"type\" \"double\")]\n )\n \n ; See the movsipsi2 pattern above for another way that GCC performs this\n@@ -836,6 +1045,8 @@\n \t(truncate:PSI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"PUSH.W\\t%H1 { PUSH.W\\t%L1 { POPM.A\\t#1, %L0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"type\" \"single\")]\n )\n \n ;;------------------------------------------------------------\n@@ -886,7 +1097,10 @@\n \t(any_shift:HI (match_operand:HI 1 \"general_operand\"       \"0\")\n \t\t      (match_operand:HI 2 \"const_int_operand\"     \"n\")))]\n   \"!msp430x\"\n-  \"* return msp430_output_asm_shift_insns (<CODE>, HImode, operands);\"\n+  \"* msp430_output_asm_shift_insns (<CODE>, HImode, operands, false); return \\\"\\\";\"\n+  [(set (attr \"length\")\n+\t(symbol_ref \"msp430_output_asm_shift_insns (<CODE>, HImode, operands, true)\"))\n+   (set_attr \"type\" \"single\")]\n )\n \n ;; All 430 and 430X SImode constant shifts\n@@ -895,7 +1109,10 @@\n \t(any_shift:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n \t\t      (match_operand:SI 2 \"const_int_operand\"     \"n\")))]\n   \"\"\n-  \"* return msp430_output_asm_shift_insns (<CODE>, SImode, operands);\"\n+  \"* msp430_output_asm_shift_insns (<CODE>, SImode, operands, false); return \\\"\\\";\"\n+  [(set (attr \"length\")\n+\t(symbol_ref \"msp430_output_asm_shift_insns (<CODE>, SImode, operands, true)\"))\n+   (set_attr \"type\" \"single\")]\n )\n \n (define_insn \"ashl<mode>3_430x\"\n@@ -908,6 +1125,8 @@\n   RPT\\t%2 { RLAX%b0\\t%0\n   RPT\\t#16 { RLAX%b0\\t%0 { RPT\\t%W2 { RLAX%b0\\t%0\n   # undefined behavior left shift of %1 by %2\"\n+  [(set_attr \"length\" \"2,4,8,0\")\n+   (set_attr \"type\" \"single\")]\n )\n \n (define_insn \"ashr<mode>3_430x\"\n@@ -920,6 +1139,8 @@\n   RPT\\t%2 { RRAX%b0\\t%0\n   RPT\\t#16 { RRAX%b0\\t%0 { RPT\\t%W2 { RRAX%b0\\t%0\n   # undefined behavior arithmetic right shift of %1 by %2\"\n+  [(set_attr \"length\" \"2,4,8,0\")\n+   (set_attr \"type\" \"single\")]\n )\n \n (define_insn \"lshr<mode>3_430x\"\n@@ -932,6 +1153,8 @@\n   RPT\\t%2 { RRUX%b0\\t%0\n   RPT\\t#16 { RRUX%b0\\t%0 { RPT\\t%W2 { RRUX%b0\\t%0\n   # undefined behavior logical right shift of %1 by %2\"\n+  [(set_attr \"length\" \"2,4,8,0\")\n+   (set_attr \"type\" \"single\")]\n )\n \n ;;------------------------------------------------------------\n@@ -941,47 +1164,52 @@\n   [(const_int 0)]\n   \"\"\n   \"msp430_expand_prologue (); DONE;\"\n-  )\n+)\n \n (define_expand \"epilogue\"\n   [(const_int 0)]\n   \"\"\n   \"msp430_expand_epilogue (0); DONE;\"\n-  )\n+)\n \n (define_insn \"epilogue_helper\"\n   [(set (pc)\n-        (unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")] UNS_EPILOGUE_HELPER))\n+\t(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")] UNS_EPILOGUE_HELPER))\n    (return)]\n-  \"\"\n+  \"!msp430x\"\n   \"BR%Q0\\t#__mspabi_func_epilog_%J0\"\n-  )\n+  [(set_attr \"length\" \"2\")]\n+)\n \n (define_insn \"prologue_start_marker\"\n   [(unspec_volatile [(const_int 0)] UNS_PROLOGUE_START_MARKER)]\n   \"\"\n   \"; start of prologue\"\n-  )\n+  [(set_attr \"length\" \"0\")]\n+)\n \n (define_insn \"prologue_end_marker\"\n   [(unspec_volatile [(const_int 0)] UNS_PROLOGUE_END_MARKER)]\n   \"\"\n   \"; end of prologue\"\n-  )\n+  [(set_attr \"length\" \"0\")]\n+)\n \n (define_insn \"epilogue_start_marker\"\n   [(unspec_volatile [(const_int 0)] UNS_EPILOGUE_START_MARKER)]\n   \"\"\n   \"; start of epilogue\"\n-  )\n+  [(set_attr \"length\" \"0\")]\n+)\n \n ;; This makes the linker add a call to exit() after the call to main()\n ;; in crt0\n (define_insn \"msp430_refsym_need_exit\"\n   [(unspec_volatile [(const_int 0)] UNS_REFSYM_NEED_EXIT)]\n   \"\"\n   \".refsym\\t__crt0_call_exit\"\n-  )\n+  [(set_attr \"length\" \"0\")]\n+)\n \n ;;------------------------------------------------------------\n ;; Jumps\n@@ -998,6 +1226,8 @@\n \t (match_operand 1 \"\"))]\n   \"\"\n   \"CALL%Q0\\t%0\"\n+  [(set_attr \"extension\" \"none\")\n+   (set_attr \"type\" \"single\")]\n )\n \n (define_expand \"call_value\"\n@@ -1014,12 +1244,15 @@\n \t      (match_operand 2 \"\")))]\n   \"\"\n   \"CALL%Q0\\t%1\"\n+  [(set_attr \"extension\" \"none\")\n+   (set_attr \"type\" \"single\")]\n )\n \n (define_insn \"msp430_return\"\n   [(return)]\n   \"\"\n   { return msp430_is_interrupt_func () ? \"RETI\" : (TARGET_LARGE ? \"RETA\" : \"RET\"); }\n+  [(set_attr \"length\" \"2\")]\n )\n \n ;; This pattern is NOT, as expected, a return pattern.  It's called\n@@ -1045,13 +1278,15 @@\n   \"reload_completed\"\n   [(const_int 0)]\n   \"msp430_expand_epilogue (1); DONE;\"\n-  )\n+  [(set_attr \"length\" \"40\")]\n+)\n \n (define_insn \"jump\"\n   [(set (pc)\n \t(label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n   \"BR%Q0\\t#%l0\"\n+  [(set_attr \"length\" \"4\")]\n )\n \n ;; FIXME: GCC currently (8/feb/2013) cannot handle symbol_refs\n@@ -1061,6 +1296,10 @@\n \t(match_operand 0 \"nonimmediate_operand\" \"rYl\"))]\n   \"\"\n   \"BR%Q0\\t%0\"\n+  [(set (attr \"length\")\n+\t(if_then_else (match_operand 0 \"register_operand\" \"\")\n+\t\t      (const_int 2)\n+\t\t      (const_int 4)))]\n )\n \n ;;------------------------------------------------------------\n@@ -1077,14 +1316,14 @@\n   )]\n   \"\"\n   \"msp430_fixup_compare_operands (<MODE>mode, operands);\"\n-  )\n+)\n \n (define_insn \"cbranchpsi4_real\"\n   [(set (pc) (if_then_else\n \t      (match_operator                     0 \"msp430_cmp_operator\"\n \t\t\t      [(match_operand:PSI 1 \"msp430_general_dst_nonv_operand\" \"r,rYs,rm\")\n \t\t\t       (match_operand:PSI 2 \"general_operand\"      \"rLs,rYsi,rmi\")])\n-              (label_ref (match_operand           3 \"\" \"\"))\n+\t      (label_ref (match_operand\t\t  3 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:BI CARRY))\n    ]\n@@ -1093,7 +1332,9 @@\n   CMP%Q0\\t%2, %1 { J%0\\t%l3\n   CMPX.A\\t%2, %1 { J%0\\t%l3\n   CMPX.A\\t%2, %1 { J%0\\t%l3\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"cmp\")]\n+)\n \n (define_insn \"cbranchqi4_real\"\n   [(set (pc) (if_then_else\n@@ -1108,7 +1349,9 @@\n   \"@\n    CMP.B\\t%2, %1 { J%0\\t%l3\n    CMPX.B\\t%2, %1 { J%0\\t%l3\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"cmp\")]\n+)\n \n (define_insn \"cbranchhi4_real\"\n   [(set (pc) (if_then_else\n@@ -1123,6 +1366,8 @@\n   \"@\n    CMP.W\\t%2, %1 { J%0\\t%l3\n    CMPX.W\\t%2, %1 { J%0\\t%l3\"\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"cmp\")]\n )\n \n (define_insn \"cbranchpsi4_reversed\"\n@@ -1139,7 +1384,9 @@\n   CMP%Q0\\t%1, %2 { J%R0\\t%l3\n   CMPX.A\\t%1, %2 { J%R0\\t%l3\n   CMPX.A\\t%1, %2 { J%R0\\t%l3\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"cmp\")]\n+)\n \n (define_insn \"cbranchqi4_reversed\"\n   [(set (pc) (if_then_else\n@@ -1154,7 +1401,9 @@\n   \"@\n    CMP.B\\t%1, %2 { J%R0\\t%l3\n    CMPX.B\\t%1, %2 { J%R0\\t%l3\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"cmp\")]\n+)\n \n (define_insn \"cbranchhi4_reversed\"\n   [(set (pc) (if_then_else\n@@ -1169,67 +1418,77 @@\n   \"@\n    CMP.W\\t%1, %2 { J%R0\\t%l3\n    CMPX.W\\t%1, %2 { J%R0\\t%l3\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"cmp\")]\n+)\n \n (define_insn \"*bitbranch<mode>4\"\n   [(set (pc) (if_then_else\n \t      (ne (and:QHI (match_operand:QHI 0 \"msp430_general_dst_operand\" \"rYsYx,rm\")\n \t\t\t   (match_operand:QHI 1 \"msp430_general_operand\" \"rYsYxi,rmi\"))\n \t\t  (const_int 0))\n-              (label_ref (match_operand 2 \"\" \"\"))\n+\t      (label_ref (match_operand 2 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n   \"@\n    BIT%x0%b0\\t%1, %0 { JNE\\t%l2\n    BITX%b0\\t%1, %0 { JNE\\t%l2\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"double\")]\n+)\n \n (define_insn \"*bitbranch<mode>4\"\n   [(set (pc) (if_then_else\n \t      (eq (and:QHI (match_operand:QHI 0 \"msp430_general_dst_operand\" \"rYsYx,rm\")\n \t\t\t   (match_operand:QHI 1 \"msp430_general_operand\" \"rYsYxi,rmi\"))\n \t\t  (const_int 0))\n-              (label_ref (match_operand 2 \"\" \"\"))\n+\t      (label_ref (match_operand 2 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n   \"@\n    BIT%x0%b0\\t%1, %0 { JEQ\\t%l2\n    BITX%b0\\t%1, %0 { JEQ\\t%l2\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"double\")]\n+)\n \n (define_insn \"*bitbranch<mode>4\"\n   [(set (pc) (if_then_else\n \t      (eq (and:QHI (match_operand:QHI 0 \"msp430_general_dst_operand\" \"rYsYx,rm\")\n \t\t\t   (match_operand:QHI 1 \"msp430_general_operand\" \"rYsYxi,rmi\"))\n \t\t  (const_int 0))\n-              (pc)\n+\t      (pc)\n \t      (label_ref (match_operand 2 \"\" \"\"))))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n   \"@\n   BIT%x0%b0\\t%1, %0 { JNE\\t%l2\n   BITX%b0\\t%1, %0 { JNE\\t%l2\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"double\")]\n+)\n \n (define_insn \"*bitbranch<mode>4\"\n   [(set (pc) (if_then_else\n \t      (ne (and:QHI (match_operand:QHI 0 \"msp430_general_dst_operand\" \"rYsYx,rm\")\n \t\t\t   (match_operand:QHI 1 \"msp430_general_operand\" \"rYsYxi,rmi\"))\n \t\t  (const_int 0))\n-              (pc)\n+\t      (pc)\n \t      (label_ref (match_operand 2 \"\" \"\"))))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n   \"@\n   BIT%x0%b0\\t%1, %0 { JEQ\\t%l2\n   BITX%b0\\t%1, %0 { JEQ\\t%l2\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"double\")]\n+)\n \n ;;------------------------------------------------------------\n ;; zero-extract versions of the above\n@@ -1240,57 +1499,65 @@\n \t\t\t\t    (const_int 1)\n \t\t\t\t    (match_operand 1 \"const_0_to_15_operand\" \"i,i\"))\n \t\t  (const_int 0))\n-              (label_ref (match_operand 2 \"\" \"\"))\n+\t      (label_ref (match_operand 2 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n   \"@\n    BIT%x0%b0\\t%p1, %0 { JNE\\t%l2\n    BIT%X0%b0\\t%p1, %0 { JNE\\t%l2\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"double\")]\n+)\n \n (define_insn \"*bitbranch<mode>4_z\"\n   [(set (pc) (if_then_else\n \t      (eq (zero_extract:HI (match_operand:QHI 0 \"msp430_general_dst_operand\" \"rm\")\n \t\t\t\t   (const_int 1)\n \t\t\t\t   (match_operand 1 \"const_0_to_15_operand\" \"i\"))\n \t\t  (const_int 0))\n-              (label_ref (match_operand 2 \"\" \"\"))\n+\t      (label_ref (match_operand 2 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n   \"BIT%X0%b0\\t%p1, %0 { JEQ\\t%l2\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"double\")]\n+)\n \n (define_insn \"*bitbranch<mode>4_z\"\n   [(set (pc) (if_then_else\n \t      (eq (zero_extract:HI (match_operand:QHI 0 \"msp430_general_dst_operand\" \"rm\")\n \t\t\t\t   (const_int 1)\n \t\t\t\t   (match_operand 1 \"const_0_to_15_operand\" \"i\"))\n \t\t  (const_int 0))\n-              (pc)\n+\t      (pc)\n \t      (label_ref (match_operand 2 \"\" \"\"))))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n   \"BIT%X0%b0\\t%p1, %0 { JNE\\t%l2\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"double\")]\n+)\n \n (define_insn \"*bitbranch<mode>4_z\"\n   [(set (pc) (if_then_else\n \t      (ne (zero_extract:HI (match_operand:QHI 0 \"msp430_general_dst_operand\" \"rm\")\n \t\t\t\t   (const_int 1)\n \t\t\t\t   (match_operand 1 \"const_0_to_15_operand\" \"i\"))\n \t\t  (const_int 0))\n-              (pc)\n+\t      (pc)\n \t      (label_ref (match_operand 2 \"\" \"\"))))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n   \"BIT%X0%b0\\t%p1, %0 { JEQ\\t%l2\"\n-  )\n+  [(set_attr \"extra_length\" \"2\")\n+   (set_attr \"type\" \"double\")]\n+)\n \n ;;------------------------------------------------------------\n ;; Misc\n@@ -1299,70 +1566,80 @@\n   [(const_int 0)]\n   \"1\"\n   \"NOP\"\n+  [(set_attr \"length\" \"2\")]\n )\n \n (define_insn \"disable_interrupts\"\n   [(unspec_volatile [(const_int 0)] UNS_DINT)]\n   \"\"\n   \"DINT \\; NOP\"\n-  )\n+  [(set_attr \"length\" \"2\")]\n+)\n \n (define_insn \"enable_interrupts\"\n   [(unspec_volatile [(const_int 0)] UNS_EINT)]\n   \"\"\n   \"EINT\"\n-  )\n+  [(set_attr \"length\" \"2\")]\n+)\n \n (define_insn \"push_intr_state\"\n   [(unspec_volatile [(const_int 0)] UNS_PUSH_INTR)]\n   \"\"\n   \"PUSH\\tSR\"\n-  )\n+  [(set_attr \"length\" \"2\")]\n+)\n \n (define_insn \"pop_intr_state\"\n   [(unspec_volatile [(const_int 0)] UNS_POP_INTR)]\n   \"\"\n   \"POP\\tSR\"\n-  )\n+  [(set_attr \"length\" \"2\")]\n+)\n \n ;; Clear bits in the copy of the status register that is currently\n ;; saved on the stack at the top of the interrupt handler.\n (define_insn \"bic_SR\"\n   [(unspec_volatile [(match_operand 0 \"nonmemory_operand\" \"ir\")] UNS_BIC_SR)]\n   \"\"\n   \"BIC.W\\t%0, %O0(SP)\"\n-  )\n+  [(set_attr \"type\" \"single\")\n+   (set_attr \"extra_length\" \"2\")]\n+)\n \n ;; Set bits in the copy of the status register that is currently\n ;; saved on the stack at the top of the interrupt handler.\n (define_insn \"bis_SR\"\n   [(unspec_volatile [(match_operand 0 \"nonmemory_operand\" \"ir\")] UNS_BIS_SR)]\n   \"\"\n   \"BIS.W\\t%0, %O0(SP)\"\n-  )\n+  [(set_attr \"type\" \"single\")\n+   (set_attr \"extra_length\" \"2\")]\n+)\n \n ;; For some reason GCC is generating (set (reg) (and (neg (reg)) (int)))\n ;; very late on in the compilation and not splitting it into separate\n ;; instructions, so we provide a pattern to support it here.\n (define_insn \"andneghi3\"\n-  [(set (match_operand:HI                 0 \"register_operand\" \"=r\")\n-\t(and:HI (neg:HI (match_operand:HI 1 \"general_operand\"  \"rm\"))\n-\t\t(match_operand            2 \"immediate_operand\" \"n\")))]\n+  [(set (match_operand:HI\t\t  0 \"register_operand\" \"=r,r\")\n+\t(and:HI (neg:HI (match_operand:HI 1 \"general_operand\"  \"0,rm\"))\n+\t\t(match_operand\t\t  2 \"immediate_operand\" \"n,n\")))]\n   \"\"\n-  \"*\n-    if (REGNO (operands[0]) != REGNO (operands[1]))\n-      return \\\"MOV%X1.W\\t%1, %0 { INV.W\\t%0 { INC.W\\t%0 { AND.W\\t%2, %0\\\";\n-    else\n-      return \\\"INV.W\\t%0 { INC.W\\t%0 { AND.W\\t%2, %0\\\";\n-  \"\n-  )\n+  \"@\n+  INV.W\\t%0 { INC.W\\t%0 { AND.W\\t%2, %0\n+  MOV%X1.W\\t%1, %0 { INV.W\\t%0 { INC.W\\t%0 { AND.W\\t%2, %0\"\n+  [(set_attr \"length\" \"12,14\")\n+   (set_attr \"type\" \"double\")]\n+)\n+\n \n (define_insn \"delay_cycles_start\"\n   [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")]\n \t\t    UNS_DELAY_START)]\n   \"\"\n   \"; Begin %J0 cycle delay\"\n-  )\n+  [(set_attr \"length\" \"0\")]\n+)\n \n (define_insn \"delay_cycles_end\"\n   [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")]\n@@ -1387,7 +1664,8 @@\n \tJNE\t1b\n \tPOP\tr14\n \tPOP\tr13\"\n-  )\n+  [(set_attr \"length\" \"32\")]\n+)\n \n (define_insn \"delay_cycles_32x\"\n   [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")\n@@ -1403,7 +1681,8 @@\n \tTST.W\tr13\n \tJNE\t1b\n \tPOPM.A\t#2,r14\"\n-  )\n+  [(set_attr \"length\" \"28\")]\n+)\n \n (define_insn \"delay_cycles_16\"\n   [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")\n@@ -1415,7 +1694,8 @@\n 1:\tSUB.W\t#1, r13\n \tJNE\t1b\n \tPOP\tr13\"\n-  )\n+  [(set_attr \"length\" \"14\")]\n+)\n \n (define_insn \"delay_cycles_16x\"\n   [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")\n@@ -1427,19 +1707,22 @@\n 1:\tSUB.W\t#1, r13\n \tJNE\t1b\n \tPOPM.A\t#1,r13\"\n-  )\n+  [(set_attr \"length\" \"14\")]\n+)\n \n (define_insn \"delay_cycles_2\"\n   [(unspec_volatile [(const_int 0) ] UNS_DELAY_2)]\n   \"\"\n   \"JMP\t.+2\"\n-  )\n+  [(set_attr \"length\" \"2\")]\n+)\n \n (define_insn \"delay_cycles_1\"\n   [(unspec_volatile [(const_int 0) ] UNS_DELAY_1)]\n   \"\"\n   \"NOP\"\n-  )\n+  [(set_attr \"length\" \"2\")]\n+)\n \n ; libgcc helper functions for widening multiplication aren't currently\n ; generated by gcc, so we can't catch them later and map them to the mspabi\n@@ -1494,6 +1777,7 @@\n     else\n       return \\\"PUSH.W sr { DINT { NOP { MOV.W %1, &0x0132 { MOV.W %2, &0x0138 { MOV.W &0x013A, %L0 { MOV.W &0x013C, %H0 { POP.W sr\\\";\n   \"\n+  [(set_attr \"length\" \"24\")]\n )\n \n (define_insn \"*umulhisi3_inline\"\n@@ -1507,6 +1791,7 @@\n     else\n       return \\\"PUSH.W sr { DINT { NOP { MOV.W %1, &0x0130 { MOV.W %2, &0x0138 { MOV.W &0x013A, %L0 { MOV.W &0x013C, %H0 { POP.W sr\\\";\n   \"\n+  [(set_attr \"length\" \"24\")]\n )\n \n (define_insn \"mulsidi3\"\n@@ -1520,6 +1805,7 @@\n     else\n       return \\\"PUSH.W sr { DINT { NOP { MOV.W %L1, &0x0144 { MOV.W %H1, &0x0146 { MOV.W %L2, &0x0150 { MOV.W %H2, &0x0152 { MOV.W &0x0154, %A0 { MOV.W &0x0156, %B0 { MOV.W &0x0158, %C0 { MOV.W &0x015A, %D0 { POP.W sr\\\";\n   \"\n+  [(set_attr \"length\" \"40\")]\n )\n \n (define_insn \"umulsidi3\"\n@@ -1533,4 +1819,5 @@\n     else\n       return \\\"PUSH.W sr { DINT { NOP { MOV.W %L1, &0x0140 { MOV.W %H1, &0x0142 { MOV.W %L2, &0x0150 { MOV.W %H2, &0x0152 { MOV.W &0x0154, %A0 { MOV.W &0x0156, %B0 { MOV.W &0x0158, %C0 { MOV.W &0x015A, %D0 { POP.W sr\\\";\n   \"\n+  [(set_attr \"length\" \"40\")]\n )"}, {"sha": "eb1f61df780bb742685b709b78a82ef6857fda54", "filename": "gcc/config/msp430/predicates.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546c8f955804ad74b0382b012f64e621a02eebde/gcc%2Fconfig%2Fmsp430%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546c8f955804ad74b0382b012f64e621a02eebde/gcc%2Fconfig%2Fmsp430%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fpredicates.md?ref=546c8f955804ad74b0382b012f64e621a02eebde", "patch": "@@ -131,3 +131,16 @@\n (define_predicate \"msp430_symbol_operand\"\n   (match_code \"symbol_ref\")\n )\n+\n+; Used in length attribute tests - if a source operand is a reg,\n+; (mem (post_inc)), or (mem (reg)) then it is cheap compared to other operand\n+; types.\n+(define_predicate \"msp430_cheap_operand\"\n+  (ior (match_code \"reg\")\n+       (and (match_code \"mem\")\n+\t    (ior (match_code \"reg\" \"0\")\n+\t    (match_code \"post_inc\" \"0\")))))\n+\n+; Used for insn attributes only.  For insn patterns themselves, use constraints.\n+(define_predicate \"msp430_high_memory_operand\"\n+  (match_test \"msp430x_insn_required (op)\"))"}]}