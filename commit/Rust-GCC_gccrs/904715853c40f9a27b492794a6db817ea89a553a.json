{"sha": "904715853c40f9a27b492794a6db817ea89a553a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA0NzE1ODUzYzQwZjlhMjdiNDkyNzk0YTZkYjgxN2VhODlhNTUzYQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2003-10-24T09:29:43Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2003-10-24T09:29:43Z"}, "message": "lang.c (LANG_HOOKS_GET_CALLEE_FNDECL): New.\n\n2003-10-22  Andrew Haley  <aph@redhat.com>\n\n        * lang.c (LANG_HOOKS_GET_CALLEE_FNDECL): New.\n        (java_get_callee_fndecl): New.\n\n        * jcf-parse.c (java_parse_file): Call emit_catch_table().\n\n        * java-tree.h (ctable_decl): New.\n        (catch_classes):  New.\n        (java_tree_index): Add JTI_CTABLE_DECL, JTI_CATCH_CLASSES.\n\n        * decl.c (java_init_decl_processing): Add catch_class_type.\n        Add ctable_decl.\n        Add catch_classes field.\n\n        * class.c (build_indirect_class_ref): Break out from\n        build_class_ref.\n        (make_field_value): Check flag_indirect_dispatch.\n        (make_class_data): Ditto.\n        Tidy uses of PUSH_FIELD_VALUE.\n        Add field catch_classes.\n        (make_catch_class_record): New.\n\n        * java-tree.h (PUSH_FIELD_VALUE): Tidy.\n\n2003-10-22  Andrew Haley  <aph@redhat.com>\n\n        * java/lang/natClass.cc (initializeClass): Call\n        _Jv_linkExceptionClassTable.\n        (_Jv_LinkSymbolTable): Call )_Jv_ThrowNoSuchMethodError.  Call\n        _Jv_Defer_Resolution on a method whose ncode is NULL.\n        (_Jv_linkExceptionClassTable): New function.\n        (_Jv_LayoutVTableMethods): If superclass looks like a constant pool\n        entry, look it up.\n        * java/lang/Class.h (struct _Jv_CatchClass): New.\n        (_Jv_linkExceptionClassTable): New friend.\n        (_Jv_Defer_Resolution): New friend.\n        (class Class.catch_classes): New field.\n        * include/java-interp.h (Jv_Defer_Resolution): New method.\n        (_Jv_PrepareClass): Make a friend of _Jv_MethodBase.\n        (_Jv_MethodBase.deferred): New field.\n        (_Jv_Defer_Resolution): New function.\n        * resolve.cc (_Jv_PrepareClass): Resolve deferred handlers.\n        * exception.cc (get_ttype_entry): Change return type to void**.\n        (PERSONALITY_FUNCTION): Remove all code related to using a\n        Utf8Const* for a match type.  Change match type to be a pointer to\n        a pointer, rather than a pointer to a Class.\n        * defineclass.cc (handleCodeAttribute): Initialize\n        method->deferred.\n        (handleMethodsEnd): Likewise.\n\nFrom-SVN: r72886", "tree": {"sha": "8c726fb42c811bb6652ba1a759bae78c2c8d9378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c726fb42c811bb6652ba1a759bae78c2c8d9378"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/904715853c40f9a27b492794a6db817ea89a553a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/904715853c40f9a27b492794a6db817ea89a553a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/904715853c40f9a27b492794a6db817ea89a553a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/904715853c40f9a27b492794a6db817ea89a553a/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c769a35d59f282465c1a344617bf04d595e8c477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c769a35d59f282465c1a344617bf04d595e8c477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c769a35d59f282465c1a344617bf04d595e8c477"}], "stats": {"total": 420, "additions": 357, "deletions": 63}, "files": [{"sha": "1458560aad1fb71c97f92aecccfe099b6f23d304", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -1,3 +1,28 @@\n+2003-10-22  Andrew Haley  <aph@redhat.com>\n+\n+\t* lang.c (LANG_HOOKS_GET_CALLEE_FNDECL): New.\n+\t(java_get_callee_fndecl): New.\n+\n+\t* jcf-parse.c (java_parse_file): Call emit_catch_table().\n+\n+\t* java-tree.h (ctable_decl): New.\n+\t(catch_classes):  New.\n+\t(java_tree_index): Add JTI_CTABLE_DECL, JTI_CATCH_CLASSES.\n+\n+\t* decl.c (java_init_decl_processing): Add catch_class_type.\n+\tAdd ctable_decl.\n+\tAdd catch_classes field.\n+\n+\t* class.c (build_indirect_class_ref): Break out from\n+\tbuild_class_ref.\n+\t(make_field_value): Check flag_indirect_dispatch.\n+\t(make_class_data): Ditto.\n+\tTidy uses of PUSH_FIELD_VALUE.\n+\tAdd field catch_classes.\n+\t(make_catch_class_record): New.\n+\n+\t* java-tree.h (PUSH_FIELD_VALUE): Tidy.\n+\n 2003-10-22  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* jcf-write.c: Follow spelling conventions."}, {"sha": "2aacbd42e041461f2814b208a9a83d5614b44f96", "filename": "gcc/java/class.c", "status": "modified", "additions": 70, "deletions": 13, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -808,6 +808,20 @@ build_utf8_ref (tree name)\n   return ref;\n }\n \n+/* Like build_class_ref, but instead of a direct reference generate a\n+   pointer into the constant pool.  */\n+\n+static tree\n+build_indirect_class_ref (tree type)\n+{\n+  int index;\n+  tree cl;\n+  index = alloc_class_constant (type);\n+  cl = build_ref_from_constant_pool (index); \n+  TREE_TYPE (cl) = promote_type (class_ptr_type);\n+  return cl;\n+}\n+\n /* Build a reference to the class TYPE.\n    Also handles primitive types and array types. */\n \n@@ -820,6 +834,12 @@ build_class_ref (tree type)\n       tree ref, decl_name, decl;\n       if (TREE_CODE (type) == POINTER_TYPE)\n \ttype = TREE_TYPE (type);\n+\n+      if  (flag_indirect_dispatch \n+\t   && type != current_class\n+\t   && TREE_CODE (type) == RECORD_TYPE)\n+\treturn build_indirect_class_ref (type);\n+\n       if (TREE_CODE (type) == RECORD_TYPE)\n \t{\n \t  if (TYPE_SIZE (type) == error_mark_node)\n@@ -902,14 +922,7 @@ build_class_ref (tree type)\n       return ref;\n     }\n   else\n-    {\n-      int index;\n-      tree cl;\n-      index = alloc_class_constant (type);\n-      cl = build_ref_from_constant_pool (index); \n-      TREE_TYPE (cl) = promote_type (class_ptr_type);\n-      return cl;\n-    }\n+    return build_indirect_class_ref (type);\n }\n \n tree\n@@ -1061,7 +1074,7 @@ make_field_value (tree fdecl)\n   tree finit;\n   int flags;\n   tree type = TREE_TYPE (fdecl);\n-  int resolved = is_compiled_class (type);\n+  int resolved = is_compiled_class (type) && ! flag_indirect_dispatch;\n \n   START_RECORD_CONSTRUCTOR (finit, field_type_node);\n   PUSH_FIELD_VALUE (finit, \"name\", build_utf8_ref (DECL_NAME (fdecl)));\n@@ -1422,7 +1435,8 @@ make_class_data (tree type)\n   super = CLASSTYPE_SUPER (type);\n   if (super == NULL_TREE)\n     super = null_pointer_node;\n-  else if (assume_compiled (IDENTIFIER_POINTER (DECL_NAME (type_decl)))\n+  else if (! flag_indirect_dispatch\n+\t   && assume_compiled (IDENTIFIER_POINTER (DECL_NAME (type_decl)))\n \t   && assume_compiled (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (super)))))\n     super = build_class_ref (super);\n   else\n@@ -1492,7 +1506,7 @@ make_class_data (tree type)\n   PUSH_FIELD_VALUE (cons, \"method_count\",  build_int_2 (method_count, 0));\n \n   if (flag_indirect_dispatch)\n-    PUSH_FIELD_VALUE (cons, \"vtable_method_count\", integer_minus_one_node)\n+    PUSH_FIELD_VALUE (cons, \"vtable_method_count\", integer_minus_one_node);\n   else\n     PUSH_FIELD_VALUE (cons, \"vtable_method_count\", TYPE_NVIRTUALS (type));\n     \n@@ -1505,7 +1519,7 @@ make_class_data (tree type)\n \t\t    build_int_2 (static_field_count, 0));\n \n   if (flag_indirect_dispatch)\n-    PUSH_FIELD_VALUE (cons, \"vtable\", null_pointer_node)\n+    PUSH_FIELD_VALUE (cons, \"vtable\", null_pointer_node);\n   else\n     PUSH_FIELD_VALUE (cons, \"vtable\",\n \t\t      dtable_decl == NULL_TREE ? null_pointer_node\n@@ -1540,7 +1554,9 @@ make_class_data (tree type)\n \t\t\t\tatable_syms_decl));\n       TREE_CONSTANT (atable_decl) = 1;\n     }\n-\n+ \n+  PUSH_FIELD_VALUE (cons, \"catch_classes\",\n+\t\t    build1 (ADDR_EXPR, ptr_type_node, ctable_decl)); \n   PUSH_FIELD_VALUE (cons, \"interfaces\", interfaces);\n   PUSH_FIELD_VALUE (cons, \"loader\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"interface_count\", build_int_2 (interface_len, 0));\n@@ -2210,6 +2226,47 @@ emit_symbol_table (tree name, tree the_table, tree decl_list, tree the_syms_decl\n   return the_table;\n }\n \n+/* make an entry for the catch_classes list.  */\n+tree\n+make_catch_class_record (tree catch_class, tree classname)\n+{\n+  tree entry;\n+  tree type = TREE_TYPE (TREE_TYPE (ctable_decl));\n+  START_RECORD_CONSTRUCTOR (entry, type);\n+  PUSH_FIELD_VALUE (entry, \"address\", catch_class);\n+  PUSH_FIELD_VALUE (entry, \"classname\", classname);\n+  FINISH_RECORD_CONSTRUCTOR (entry);\n+  return entry;\n+}\n+\n+\n+/* Generate the list of Throwable classes that are caught by exception\n+   handlers in this compilation.  */\n+void \n+emit_catch_table (void)\n+{\n+  tree table, table_size, array_type;\n+  catch_classes \n+    = tree_cons (NULL, \n+\t\t make_catch_class_record (null_pointer_node, null_pointer_node),\n+\t\t catch_classes);\n+  catch_classes = nreverse (catch_classes);\n+  catch_classes \n+    = tree_cons (NULL, \n+\t\t make_catch_class_record (null_pointer_node, null_pointer_node),\n+\t\t catch_classes);\n+  table_size = build_index_type (build_int_2 (list_length (catch_classes), 0));\n+  array_type \n+    = build_array_type (TREE_TYPE (TREE_TYPE (ctable_decl)), table_size);\n+  table = build_decl (VAR_DECL, DECL_NAME (ctable_decl), array_type);\n+  DECL_INITIAL (table) = build_constructor (array_type, catch_classes);\n+  TREE_STATIC (table) = 1;\n+  TREE_READONLY (table) = 1;  \n+  rest_of_decl_compilation (table, NULL, 1, 0);\n+  ctable_decl = table;\n+}\n+ \n+\n void\n init_class_processing (void)\n {"}, {"sha": "e23cb120c3a86613e63ba4ea8a3cb92cf1d0b120", "filename": "gcc/java/decl.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -663,6 +663,23 @@ java_init_decl_processing (void)\n       pushdecl (atable_syms_decl);\n     }\n   \n+  {  \n+    tree catch_class_type = make_node (RECORD_TYPE);\n+    PUSH_FIELD (catch_class_type, field, \"address\", utf8const_ptr_type);\n+    PUSH_FIELD (catch_class_type, field, \"classname\", ptr_type_node);\n+    FINISH_RECORD (catch_class_type);\n+    \n+    ctable_decl \n+      = build_decl (VAR_DECL, get_identifier (\"catch_classes\"), \n+\t\t    build_array_type \n+\t\t    (catch_class_type, 0));\n+    DECL_EXTERNAL (ctable_decl) = 1;\n+    TREE_STATIC (ctable_decl) = 1;\n+    TREE_READONLY (ctable_decl) = 1;\n+    TREE_CONSTANT (ctable_decl) = 1;\n+    pushdecl (ctable_decl);  \n+  }\n+\n   PUSH_FIELD (object_type_node, field, \"vtable\", dtable_ptr_type);\n   /* This isn't exactly true, but it is what we have in the source.\n      There is an unresolved issue here, which is whether the vtable\n@@ -702,6 +719,7 @@ java_init_decl_processing (void)\n   PUSH_FIELD (class_type_node, field, \"atable\", atable_ptr_type);\n   PUSH_FIELD (class_type_node, field, \"atable_syms\", \n   \t      symbols_array_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"catch_classes\", ptr_type_node);\n   PUSH_FIELD (class_type_node, field, \"interfaces\",\n \t      build_pointer_type (class_ptr_type));\n   PUSH_FIELD (class_type_node, field, \"loader\", ptr_type_node);"}, {"sha": "dc97b42fabff5003d509e780ffa06b4f2fd502ae", "filename": "gcc/java/except.c", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -313,46 +313,52 @@ prepare_eh_table_type (tree type)\n {\n   tree exp;\n \n-  /* The \"type\" (metch_info) in a (Java) exception table is one:\n+  /* The \"type\" (match_info) in a (Java) exception table is a pointer to:\n    * a) NULL - meaning match any type in a try-finally.\n-   * b) a pointer to a (compiled) class (low-order bit 0).\n-   * c) a pointer to the Utf8Const name of the class, plus one\n-   * (which yields a value with low-order bit 1). */\n+   * b) a pointer to a pointer to a class.\n+   * c) a pointer to a pointer to a utf8_ref.  The pointer is\n+   * rewritten to point to the appropriate class.  */\n \n   if (type == NULL_TREE)\n     exp = NULL_TREE;\n-  else if (is_compiled_class (type))\n-    exp = build_class_ref (type);\n+  else if (is_compiled_class (type) && !flag_indirect_dispatch)\n+    {\n+      char buf[64];\n+      tree decl;\n+      sprintf (buf, \"%s_ref\", \n+\t       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n+      decl = build_decl (VAR_DECL, get_identifier (buf), ptr_type_node);\n+      TREE_STATIC (decl) = 1;\n+      DECL_ARTIFICIAL (decl) = 1;\n+      DECL_IGNORED_P (decl) = 1;\n+      TREE_READONLY (decl) = 1;\n+      TREE_THIS_VOLATILE (decl) = 0;\n+      DECL_INITIAL (decl) = build_class_ref (type);\n+      layout_decl (decl, 0);\n+      pushdecl (decl);\n+      rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n+      make_decl_rtl (decl, (char*) 0);\n+      exp = build1 (ADDR_EXPR, ptr_type_node, decl);\n+    }\n   else\n     {\n-      tree ctype = make_node (RECORD_TYPE);\n-      tree field = NULL_TREE;\n-      tree cinit, decl;\n+      tree decl;\n       tree utf8_ref = build_utf8_ref (DECL_NAME (TYPE_NAME (type)));\n       char buf[64];\n       sprintf (buf, \"%s_ref\", \n \t       IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (utf8_ref, 0))));\n-      PUSH_FIELD (ctype, field, \"dummy\", ptr_type_node);\n-      PUSH_FIELD (ctype, field, \"utf8\",  utf8const_ptr_type);\n-      FINISH_RECORD (ctype);\n-      START_RECORD_CONSTRUCTOR (cinit, ctype);\n-      PUSH_FIELD_VALUE (cinit, \"dummy\", \n-\t\t\tconvert (ptr_type_node, integer_minus_one_node));\n-      PUSH_FIELD_VALUE (cinit, \"utf8\", utf8_ref);\n-      FINISH_RECORD_CONSTRUCTOR (cinit);\n-      TREE_CONSTANT (cinit) = 1;\n-      decl = build_decl (VAR_DECL, get_identifier (buf), ctype);\n+      decl = build_decl (VAR_DECL, get_identifier (buf), utf8const_ptr_type);\n       TREE_STATIC (decl) = 1;\n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_IGNORED_P (decl) = 1;\n       TREE_READONLY (decl) = 1;\n       TREE_THIS_VOLATILE (decl) = 0;\n-      DECL_INITIAL (decl) = cinit;\n       layout_decl (decl, 0);\n       pushdecl (decl);\n       rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n       make_decl_rtl (decl, (char*) 0);\n-      exp = build1 (ADDR_EXPR, build_pointer_type (ctype), decl);\n+      exp = build1 (ADDR_EXPR, build_pointer_type (utf8const_ptr_type), decl);\n+      catch_classes = tree_cons (NULL, make_catch_class_record (exp, utf8_ref), catch_classes);\n     }\n   return exp;\n }"}, {"sha": "7b5a397ecdbbd5bab909d8200b03b5687c095b2b", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -167,6 +167,9 @@ extern int compiling_from_source;\n    otable. */\n #define atable_syms_decl java_global_trees [JTI_ATABLE_SYMS_DECL]\n \n+#define ctable_decl java_global_trees [JTI_CTABLE_DECL]\n+#define catch_classes java_global_trees [JTI_CATCH_CLASSES]\n+\n extern int flag_emit_class_files;\n \n extern int flag_filelist_file;\n@@ -424,6 +427,9 @@ enum java_tree_index\n   JTI_ATABLE_DECL,\n   JTI_ATABLE_SYMS_DECL,\n \n+  JTI_CTABLE_DECL,\n+  JTI_CATCH_CLASSES,\n+\n   JTI_PREDEF_FILENAMES,\n \n   JTI_MAX\n@@ -629,6 +635,8 @@ extern GTY(()) tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_SYMBOLS_ARRAY_TYPE]\n #define symbols_array_ptr_type \\\n   java_global_trees[JTI_SYMBOLS_ARRAY_PTR_TYPE]\n+#define class_refs_decl \\\n+  Jjava_global_trees[TI_CLASS_REFS_DECL]\n \n #define end_params_node \\\n   java_global_trees[JTI_END_PARAMS_NODE]\n@@ -1320,6 +1328,9 @@ extern void java_expand_body (tree);\n \n extern int get_symbol_table_index (tree, tree *);\n \n+extern tree make_catch_class_record (tree, tree);\n+extern void emit_catch_table (void);\n+\n #define DECL_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n \n /* Access flags etc for a method (a FUNCTION_DECL): */\n@@ -1678,11 +1689,16 @@ extern tree *type_map;\n /* Append a field initializer to CONS for a field with the given VALUE.\n    NAME is a char* string used for error checking;\n    the initializer must be specified in order. */\n-  #define PUSH_FIELD_VALUE(CONS, NAME, VALUE) {\\\n-    tree field = TREE_CHAIN(CONS);\\\n-    if (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)), NAME) != 0) abort();\\\n-    CONSTRUCTOR_ELTS(CONS) = tree_cons (field, VALUE, CONSTRUCTOR_ELTS(CONS));\\\n-    TREE_CHAIN(CONS) = TREE_CHAIN (field); }\n+#define PUSH_FIELD_VALUE(CONS, NAME, VALUE) \t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\t\\\n+  tree field = TREE_CHAIN(CONS);\t\t\t\t\t\t\\\n+  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)), NAME) != 0) \t\t\\\n+    abort();\t\t\t\t\t\t\t\t\t\\\n+  CONSTRUCTOR_ELTS(CONS) = tree_cons (field, VALUE, CONSTRUCTOR_ELTS(CONS));\t\\\n+  TREE_CHAIN(CONS) = TREE_CHAIN (field); \t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\t\\\n+while (0)\n \n /* Finish creating a record CONSTRUCTOR CONS. */\n #define FINISH_RECORD_CONSTRUCTOR(CONS) \\"}, {"sha": "7570f8612485e883b4c89b6d2a6f0aa2c022b531", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -632,7 +632,7 @@ jcf_parse (JCF* jcf)\n   if (CLASS_PARSED_P (current_class))\n     {\n       /* FIXME - where was first time */\n-      fatal_error (\"reading class %s for the second time from %s\",\n+      fatal_error (stderr, \"READING CLASS %s for the second time from %s\",\n \t\t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))),\n \t\t   jcf->filename);\n     }\n@@ -1137,6 +1137,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \t    (get_identifier (\"atable\"), \n \t     atable_decl, atable_methods, atable_syms_decl, ptr_type_node);\n \t}\n+      emit_catch_table ();\n     }\n \n   write_resource_constructor ();"}, {"sha": "615d250c0187c1722f59ff2f813fd7419e98c44e", "filename": "gcc/java/lang.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -68,6 +68,7 @@ static void dump_compound_expr (dump_info_p, tree);\n static bool java_decl_ok_for_sibcall (tree);\n static int java_estimate_num_insns (tree);\n static int java_start_inlining (tree);\n+static tree java_get_callee_fndecl (tree);\n \n #ifndef TARGET_OBJECT_SUFFIX\n # define TARGET_OBJECT_SUFFIX \".o\"\n@@ -263,6 +264,9 @@ struct language_function GTY(())\n #undef LANG_HOOKS_DECL_OK_FOR_SIBCALL\n #define LANG_HOOKS_DECL_OK_FOR_SIBCALL java_decl_ok_for_sibcall\n \n+#undef LANG_HOOKS_GET_CALLEE_FNDECL\n+#define LANG_HOOKS_GET_CALLEE_FNDECL java_get_callee_fndecl\n+\n #undef LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n #define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION java_expand_body\n \n@@ -1205,4 +1209,45 @@ java_start_inlining (tree fn)\n   return TREE_ASM_WRITTEN (fn) ? 1 : 0;\n }\n \n+/* Given a call_expr, try to figure out what its target might be.  In\n+   the case of an indirection via the atable, search for the decl.  If\n+   the decl is external, we return NULL.  If we don't, the optimizer\n+   will replace the indirection with a direct call, which undoes the\n+   purpose of the atable indirection.  */\n+static tree\n+java_get_callee_fndecl (tree call_expr)\n+{\n+  tree method, table, element;\n+\n+  HOST_WIDE_INT index;\n+\n+  if (TREE_CODE (call_expr) != CALL_EXPR)\n+    return NULL;\n+  method = TREE_OPERAND (call_expr, 0);\n+  STRIP_NOPS (method);\n+  if (TREE_CODE (method) != ARRAY_REF)\n+    return NULL;\n+  table = TREE_OPERAND (method, 0);\n+  if (table != atable_decl)\n+    return NULL;\n+  index = TREE_INT_CST_LOW (TREE_OPERAND (method, 1));\n+\n+  /* FIXME: Replace this for loop with a hash table lookup.  */\n+  for (element = atable_methods; element; element = TREE_CHAIN (element))\n+    {\n+      if (index == 1)\n+\t{\n+\t  tree purpose = TREE_PURPOSE (element);\n+\t  if (TREE_CODE (purpose) == FUNCTION_DECL\n+\t      && ! DECL_EXTERNAL (purpose))\n+\t    return purpose;\n+\t  else\n+\t    return NULL;\n+\t}\n+      --index;\n+    }\n+  \n+  return NULL;\n+}\n+\n #include \"gt-java-lang.h\""}, {"sha": "72b4d6cb6476651d9304270b671dd49895ac44a7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -1,3 +1,29 @@\n+2003-10-22  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/natClass.cc (initializeClass): Call\n+\t_Jv_linkExceptionClassTable.\n+\t(_Jv_LinkSymbolTable): Call )_Jv_ThrowNoSuchMethodError.  Call\n+\t_Jv_Defer_Resolution on a method whose ncode is NULL.\n+\t(_Jv_linkExceptionClassTable): New function.\n+\t(_Jv_LayoutVTableMethods): If superclass looks like a constant pool\n+\tentry, look it up.\n+\t* java/lang/Class.h (struct _Jv_CatchClass): New.\n+\t(_Jv_linkExceptionClassTable): New friend.\n+\t(_Jv_Defer_Resolution): New friend.\n+\t(class Class.catch_classes): New field.\n+\t* include/java-interp.h (Jv_Defer_Resolution): New method.\n+\t(_Jv_PrepareClass): Make a friend of _Jv_MethodBase.\n+\t(_Jv_MethodBase.deferred): New field.\n+\t(_Jv_Defer_Resolution): New function.\n+\t* resolve.cc (_Jv_PrepareClass): Resolve deferred handlers.\n+\t* exception.cc (get_ttype_entry): Change return type to void**.\n+\t(PERSONALITY_FUNCTION): Remove all code related to using a\n+\tUtf8Const* for a match type.  Change match type to be a pointer to\n+\ta pointer, rather than a pointer to a Class.\n+\t* defineclass.cc (handleCodeAttribute): Initialize\n+\tmethod->deferred.\n+\t(handleMethodsEnd): Likewise.\n+\n 2003-10-23  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* java/lang/natObject.cc (_Jv_ObjectCheckMonitor): Use"}, {"sha": "2e8b4d974346d70810888359267de59454ca821b", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -1270,6 +1270,7 @@ void _Jv_ClassReader::handleCodeAttribute\n   _Jv_InterpMethod *method = \n     (_Jv_InterpMethod*) (_Jv_AllocBytes (size));\n \n+  method->deferred\t = NULL;\n   method->max_stack      = max_stack;\n   method->max_locals     = max_locals;\n   method->code_length    = code_length;\n@@ -1328,6 +1329,7 @@ void _Jv_ClassReader::handleMethodsEnd ()\n \t      m->self = method;\n \t      m->function = NULL;\n \t      def->interpreted_methods[i] = m;\n+\t      m->deferred = NULL;\n \n \t      if ((method->accflags & Modifier::STATIC))\n \t\t{"}, {"sha": "088d48268e3da54e7749bce020f9e95379e11f2d", "filename": "libjava/exception.cc", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fexception.cc?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -161,15 +161,15 @@ parse_lsda_header (_Unwind_Context *context, const unsigned char *p,\n   return p;\n }\n \n-static jclass\n+static void **\n get_ttype_entry (_Unwind_Context *context, lsda_header_info *info, long i)\n {\n   _Unwind_Ptr ptr;\n \n   i *= size_of_encoded_value (info->ttype_encoding);\n   read_encoded_value (context, info->ttype_encoding, info->TType - i, &ptr);\n \n-  return reinterpret_cast<jclass>(ptr);\n+  return reinterpret_cast<void **>(ptr);\n }\n \n \n@@ -336,23 +336,15 @@ PERSONALITY_FUNCTION (int version,\n \t    {\n \t      // Positive filter values are handlers.\n \n-\t      jclass catch_type = get_ttype_entry (context, &info, ar_filter);\n+\t      void **catch_word = get_ttype_entry (context, &info, ar_filter);\n+\t      jclass catch_type = (jclass)*catch_word;\n+\n+\t      // FIXME: This line is a kludge to work around exception\n+\t      // handlers written in C++, which don't yet use indirect\n+\t      // dispatch.\n+\t      if (catch_type == *(void **)&java::lang::Class::class$)\n+\t\tcatch_type = (jclass)catch_word;\n \n-\t      typedef struct {\n-\t\tint __attribute__ ((mode (pointer))) dummy; \n-\t\tUtf8Const *utf8;\n-\t      } utf8_hdr;\n-\t      utf8_hdr *p = (utf8_hdr *)catch_type;\n-\t      if (p->dummy == -1)\n-\t\t{\n-\t\t  using namespace gnu::gcj::runtime;\n-\t\t  java::lang::Class *klass \n-\t\t    = StackTrace::getClass ((gnu::gcj::RawData *)ip);\n-\t\t  java::lang::ClassLoader *loader \n-\t\t    = klass ? klass->getClassLoaderInternal () : NULL;\n-\t\t  catch_type = _Jv_FindClass (p->utf8, loader);\n-\t\t}\n-\t      \n \t      if (_Jv_IsInstanceOf (xh->value, catch_type))\n \t\t{\n \t\t  handler_switch_value = ar_filter;"}, {"sha": "94acfae281f40facb02abd13a34b871f07695791", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -88,6 +88,12 @@ class _Jv_MethodBase\n   // Size of raw arguments.\n   _Jv_ushort args_raw_size;\n \n+  // Chain of addresses to fill in.  See _Jv_Defer_Resolution.\n+  void *deferred;\n+\n+  friend void _Jv_Defer_Resolution (void *cl, _Jv_Method *meth, void **);\n+  friend void _Jv_PrepareClass(jclass);\n+\n public:\n   _Jv_Method *get_method ()\n   {\n@@ -167,8 +173,33 @@ class _Jv_InterpClass : public java::lang::Class\n #endif\n \n   friend _Jv_MethodBase ** _Jv_GetFirstMethod (_Jv_InterpClass *klass);\n+  friend void _Jv_Defer_Resolution (void *cl, _Jv_Method *meth, void **);\n };\n \n+// We have an interpreted class CL and we're trying to find the\n+// address of the ncode of a method METH.  That interpreted class\n+// hasn't yet been prepared, so we defer fixups until they are ready.\n+// To do this, we create a chain of fixups that will be resolved by\n+// _Jv_PrepareClass.\n+extern inline void \n+_Jv_Defer_Resolution (void *cl, _Jv_Method *meth, void **address)\n+{\n+  int i;\n+  _Jv_InterpClass *self = (_Jv_InterpClass *)cl;\n+  for (i = 0; i < self->method_count; i++)\n+    {\n+      _Jv_Method *m = &self->methods[i];\n+      if (m == meth)\n+\t{\n+\t  _Jv_MethodBase *imeth = self->interpreted_methods[i];\n+\t  *address = imeth->deferred;\n+\t  imeth->deferred = address;\n+\t  return;\n+\t}\n+    }\n+  return;\n+}    \n+\n extern inline _Jv_MethodBase **\n _Jv_GetFirstMethod (_Jv_InterpClass *klass)\n {"}, {"sha": "01761af5cec06dd2c1b4ac25d68ed47bc9594dde", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -131,6 +131,12 @@ struct _Jv_AddressTable\n   void *addresses[];\n };\n \n+struct _Jv_CatchClass\n+{\n+  java::lang::Class **address;\n+  _Jv_Utf8Const *classname;\n+};\n+\n #define JV_PRIMITIVE_VTABLE ((_Jv_VTable *) -1)\n \n #define JV_CLASS(Obj) ((jclass) (*(_Jv_VTable **) Obj)->clas)\n@@ -336,6 +342,7 @@ class java::lang::Class : public java::lang::Object\n   friend void _Jv_LayoutVTableMethods (jclass klass);\n   friend void _Jv_SetVTableEntries (jclass, _Jv_VTable *, jboolean *);\n   friend void _Jv_MakeVTable (jclass);\n+  friend void _Jv_linkExceptionClassTable (jclass);\n \n   friend jboolean _Jv_CheckAccess (jclass self_klass, jclass other_klass,\n \t\t\t\t   jint flags);\n@@ -365,6 +372,8 @@ class java::lang::Class : public java::lang::Object\n   friend void _Jv_PrepareClass (jclass);\n   friend void _Jv_PrepareMissingMethods (jclass base, jclass iface_class);\n \n+  friend void _Jv_Defer_Resolution (void *cl, _Jv_Method *meth, void **);\n+  \n   friend class _Jv_ClassReader;\t\n   friend class _Jv_InterpClass;\n   friend class _Jv_InterpMethod;\n@@ -414,6 +423,7 @@ class java::lang::Class : public java::lang::Object\n   _Jv_MethodSymbol *otable_syms;\n   _Jv_AddressTable *atable;\n   _Jv_MethodSymbol *atable_syms;\n+  _Jv_CatchClass *catch_classes;\n   // Interfaces implemented by this class.\n   jclass *interfaces;\n   // The class loader for this class."}, {"sha": "2d80ce2133b49a9cd4392a18bef95d38488b6a51", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -12,6 +12,7 @@ details.  */\n \n #include <limits.h>\n #include <string.h>\n+#include <stddef.h>\n \n #pragma implementation \"Class.h\"\n \n@@ -56,7 +57,7 @@ details.  */\n #include <gnu/gcj/RawData.h>\n \n #include <java-cpool.h>\n-\n+#include <java-interp.h>\n \f\n \n using namespace gcj;\n@@ -796,6 +797,8 @@ java::lang::Class::initializeClass (void)\n   if (otable || atable)\n     _Jv_LinkSymbolTable(this);\n \n+  _Jv_linkExceptionClassTable (this);\n+\n   // Steps 8, 9, 10, 11.\n   try\n     {\n@@ -1541,14 +1544,18 @@ _Jv_LinkSymbolTable(jclass klass)\n \n   for (index = 0; sym = klass->otable_syms[index], sym.name != NULL; index++)\n     {\n+      // FIXME: Why are we passing NULL as the class loader?\n       jclass target_class = _Jv_FindClass (sym.class_name, NULL);\n       _Jv_Method *meth = NULL;            \n \n       const _Jv_Utf8Const *signature = sym.signature;\n \n-      // FIXME: This should be special index for ThrowNoSuchMethod().\n-      klass->otable->offsets[index] = -1;\n-      \n+      {\n+\tstatic char *bounce = (char *)_Jv_ThrowNoSuchMethodError;\n+\tptrdiff_t offset = (char *)(klass->vtable) - bounce;\n+\tklass->otable->offsets[index] = offset;\n+      }\n+\n       if (target_class == NULL)\n \tcontinue;\n \n@@ -1658,6 +1665,7 @@ _Jv_LinkSymbolTable(jclass klass)\n \n   for (index = 0; sym = klass->atable_syms[index], sym.name != NULL; index++)\n     {\n+      // FIXME: Why are we passing NULL as the class loader?\n       jclass target_class = _Jv_FindClass (sym.class_name, NULL);\n       _Jv_Method *meth = NULL;            \n       const _Jv_Utf8Const *signature = sym.signature;\n@@ -1687,7 +1695,13 @@ _Jv_LinkSymbolTable(jclass klass)\n \t\t\t\t\t  sym.signature);\n \t  \n \t  if (meth != NULL)\n-\t    klass->atable->addresses[index] = meth->ncode;\n+\t    {\n+\t      if (meth->ncode) // Maybe abstract?\n+\t\tklass->atable->addresses[index] = meth->ncode;\n+\t      else if (_Jv_IsInterpretedClass (target_class))\n+\t\t_Jv_Defer_Resolution (target_class, meth, \n+\t\t\t\t      &klass->atable->addresses[index]);\n+\t    }\n \t  else\n \t    klass->atable->addresses[index] = (void *)_Jv_ThrowNoSuchMethodError;\n \n@@ -1743,6 +1757,27 @@ _Jv_LinkSymbolTable(jclass klass)\n     }\n }\n \n+\n+// For each catch_record in the list of caught classes, fill in the\n+// address field.\n+void \n+_Jv_linkExceptionClassTable (jclass self)\n+{\n+  struct _Jv_CatchClass *catch_record = self->catch_classes;\n+  if (!catch_record || catch_record->classname)\n+    return;  \n+  catch_record++;\n+  while (catch_record->classname)\n+    {\n+      jclass target_class = _Jv_FindClass (catch_record->classname,  \n+\t\t\t\t\t   self->getClassLoaderInternal ());\n+      *catch_record->address = target_class;\n+      catch_record++;\n+    }\n+  self->catch_classes->classname = (_Jv_Utf8Const *)-1;\n+}\n+  \n+\n // Returns true if METH should get an entry in a VTable.\n static jboolean\n isVirtualMethod (_Jv_Method *meth)\n@@ -1772,6 +1807,26 @@ _Jv_LayoutVTableMethods (jclass klass)\n \n   jclass superclass = klass->superclass;\n \n+  typedef unsigned int uaddr __attribute__ ((mode (pointer)));\n+\n+  // If superclass looks like a constant pool entry,\n+  // resolve it now.\n+  if ((uaddr)superclass < (uaddr)klass->constants.size)\n+    {\n+      if (klass->state < JV_STATE_LINKED)\n+\t{\n+\t  _Jv_Utf8Const *name = klass->constants.data[(int)superclass].utf8;\n+\t  superclass = _Jv_FindClass (name, klass->loader);\n+\t  if (! superclass)\n+\t    {\n+\t      jstring str = _Jv_NewStringUTF (name->data);\n+\t      throw new java::lang::NoClassDefFoundError (str);\n+\t    }\n+\t}\n+      else\n+\tsuperclass = klass->constants.data[(int)superclass].clazz;\n+    }\n+\n   if (superclass != NULL && superclass->vtable_method_count == -1)\n     {\n       JvSynchronize sync (superclass);"}, {"sha": "d71e1251ff0946a7ad5aac730819f77816cb7b4f", "filename": "libjava/resolve.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904715853c40f9a27b492794a6db817ea89a553a/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=904715853c40f9a27b492794a6db817ea89a553a", "patch": "@@ -575,6 +575,16 @@ _Jv_PrepareClass(jclass klass)\n \t  _Jv_InterpMethod *im = reinterpret_cast<_Jv_InterpMethod *> (imeth);\n \t  _Jv_VerifyMethod (im);\n \t  clz->methods[i].ncode = im->ncode ();\n+\n+\t  // Resolve ctable entries pointing to this method.  See\n+\t  // _Jv_Defer_Resolution.\n+\t  void **code = (void **)imeth->deferred;\n+\t  while (code)\n+\t    {\n+\t      void **target = (void **)*code;\n+\t      *code = clz->methods[i].ncode;\n+\t      code = target;\n+\t    }\n \t}\n     }\n "}]}