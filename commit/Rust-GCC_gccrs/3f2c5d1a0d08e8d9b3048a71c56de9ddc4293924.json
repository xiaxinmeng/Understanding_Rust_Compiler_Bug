{"sha": "3f2c5d1a0d08e8d9b3048a71c56de9ddc4293924", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YyYzVkMWEwZDA4ZThkOWIzMDQ4YTcxYzU2ZGU5ZGRjNDI5MzkyNA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2001-12-12T08:27:29Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-12-12T08:27:29Z"}, "message": "except.c (reachable_next_level): Handle ERT_UNKNOWN to avoid compiler warning about enumeration values not being...\n\n2001-12-11  Roger Sayle <roger@eyesopen.com>\n\n\t* except.c (reachable_next_level): Handle ERT_UNKNOWN to avoid\n\tcompiler warning about enumeration values not being handled.\n\nFrom-SVN: r47926", "tree": {"sha": "96ae3b93d4e7fd86497e53989cec0fa7a0dd26e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96ae3b93d4e7fd86497e53989cec0fa7a0dd26e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f2c5d1a0d08e8d9b3048a71c56de9ddc4293924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f2c5d1a0d08e8d9b3048a71c56de9ddc4293924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f2c5d1a0d08e8d9b3048a71c56de9ddc4293924", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f2c5d1a0d08e8d9b3048a71c56de9ddc4293924/comments", "author": null, "committer": null, "parents": [{"sha": "41d2bbe765cf21c0150d0cb2ce7312125679cceb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41d2bbe765cf21c0150d0cb2ce7312125679cceb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41d2bbe765cf21c0150d0cb2ce7312125679cceb"}], "stats": {"total": 78, "additions": 42, "deletions": 36}, "files": [{"sha": "430f628b36d90fb37d3bb8894592ecef76fe0b46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f2c5d1a0d08e8d9b3048a71c56de9ddc4293924/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f2c5d1a0d08e8d9b3048a71c56de9ddc4293924/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f2c5d1a0d08e8d9b3048a71c56de9ddc4293924", "patch": "@@ -1,5 +1,10 @@\n+2001-12-11  Roger Sayle <roger@eyesopen.com>\n+\n+\t* except.c (reachable_next_level): Handle ERT_UNKNOWN to avoid\n+\tcompiler warning about enumeration values not being handled.\n+\n 2001-12-11  Momchil Velikov  <velco@fadata.bg>\n-  \n+\n \t* config/fp-bit.c (pack_d): Cast to ``fractype'' for long long\n \tshifts.\n \n@@ -26,7 +31,7 @@ Tue Dec 11 23:54:27 EST 2001  John Wehle  (john@feith.com)\n \n 2001-11-30 Alan Matsuoka <alanm@redhat.com>\n \n-\t* combine.c (combine_simplify_rtx) : Can't simplify \n+\t* combine.c (combine_simplify_rtx) : Can't simplify\n \tcases that use mode class MODE_CC.\n \n 2001-12-11  Richard Henderson  <rth@redhat.com>\n@@ -93,7 +98,7 @@ Tue Dec 11 23:54:27 EST 2001  John Wehle  (john@feith.com)\n \t(copy_blkmode_from_reg): Ditto.\n \t* stmt.c (expand_return): Ditto.\n \t* stor-layout.c (compute_record_mode): If\n-\tFUNCTION_ARG_REG_LITTLE_ENDIAN is set then check \n+\tFUNCTION_ARG_REG_LITTLE_ENDIAN is set then check\n \tMEMBER_TYPE_FORCES_BLK even if mode == VOIDmode.\n \t* config/ia64/hpux.h (MEMBER_TYPE_FORCES_BLK): Set to true\n \tso that Structures of one field are still treated as structures."}, {"sha": "db4e25a0cb8b589851555485ae62879c6e6fb2a8", "filename": "gcc/except.c", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f2c5d1a0d08e8d9b3048a71c56de9ddc4293924/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f2c5d1a0d08e8d9b3048a71c56de9ddc4293924/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=3f2c5d1a0d08e8d9b3048a71c56de9ddc4293924", "patch": "@@ -1,5 +1,5 @@\n /* Implements exception handling.\n-   Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, \n+   Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Mike Stump <mrs@cygnus.com>.\n \n@@ -164,7 +164,7 @@ struct eh_region\n       int filter;\n     } allowed;\n \n-    /* The type given by a call to \"throw foo();\", or discovered \n+    /* The type given by a call to \"throw foo();\", or discovered\n        for a throw.  */\n     struct {\n       tree type;\n@@ -342,7 +342,7 @@ static void sjlj_output_call_site_table\t\tPARAMS ((void));\n \f\n /* Routine to see if exception handling is turned on.\n    DO_WARN is non-zero if we want to inform the user that exception\n-   handling is turned off. \n+   handling is turned off.\n \n    This is used to ensure that -fexceptions has been specified if the\n    compiler tries to use any exception-specific functions.  */\n@@ -716,9 +716,9 @@ expand_eh_region_end_cleanup (handler)\n \n   /* Give the language a chance to specify an action to be taken if an\n      exception is thrown that would propagate out of the HANDLER.  */\n-  protect_cleanup_actions \n-    = (lang_protect_cleanup_actions \n-       ? (*lang_protect_cleanup_actions) () \n+  protect_cleanup_actions\n+    = (lang_protect_cleanup_actions\n+       ? (*lang_protect_cleanup_actions) ()\n        : NULL_TREE);\n \n   if (protect_cleanup_actions)\n@@ -1039,7 +1039,7 @@ add_partial_entry (handler)\n     begin_protect_partials ();\n \n   /* Add this entry to the front of the list.  */\n-  TREE_VALUE (cfun->eh->protect_list) \n+  TREE_VALUE (cfun->eh->protect_list)\n     = tree_cons (NULL_TREE, handler, TREE_VALUE (cfun->eh->protect_list));\n }\n \n@@ -1381,7 +1381,7 @@ duplicate_eh_region_1 (o, map)\n \n     case ERT_THROW:\n       n->u.throw.type = o->u.throw.type;\n-      \n+\n     default:\n       abort ();\n     }\n@@ -1429,7 +1429,7 @@ duplicate_eh_region_2 (o, n_array)\n     n->inner = n_array[o->inner->region_number];\n   if (o->next_peer)\n     n->next_peer = n_array[o->next_peer->region_number];\n-}    \n+}\n \n int\n duplicate_eh_regions (ifun, map)\n@@ -1549,7 +1549,7 @@ add_type_for_runtime (type)\n       *slot = tree_cons (type, runtime, NULL_TREE);\n     }\n }\n-  \n+\n static tree\n lookup_type_for_runtime (type)\n      tree type;\n@@ -1681,7 +1681,7 @@ add_ehspec_entry (ehspec_hash, ttypes_hash, list)\n       /* Look up each type in the list and encode its filter\n \t value as a uleb128.  Terminate the list with 0.  */\n       for (; list ; list = TREE_CHAIN (list))\n-\tpush_uleb128 (&cfun->eh->ehspec_data, \n+\tpush_uleb128 (&cfun->eh->ehspec_data,\n \t\t      add_ttypes_entry (ttypes_hash, TREE_VALUE (list)));\n       VARRAY_PUSH_UCHAR (cfun->eh->ehspec_data, 0);\n     }\n@@ -1731,8 +1731,8 @@ assign_filter_values ()\n \t\t{\n \t\t  int flt = add_ttypes_entry (ttypes, TREE_VALUE (tp_node));\n \t\t  tree flt_node = build_int_2 (flt, 0);\n-\t\t  \n-\t\t  r->u.catch.filter_list \n+\n+\t\t  r->u.catch.filter_list\n \t\t    = tree_cons (NULL_TREE, flt_node, r->u.catch.filter_list);\n \t\t}\n \t    }\n@@ -1742,11 +1742,11 @@ assign_filter_values ()\n \t\t an action record anyway.  */\n \t      int flt = add_ttypes_entry (ttypes, NULL);\n \t      tree flt_node = build_int_2 (flt, 0);\n-\t      \n-\t      r->u.catch.filter_list \n+\n+\t      r->u.catch.filter_list\n \t\t= tree_cons (NULL_TREE, flt_node, r->u.catch.filter_list);\n \t    }\n-\t      \n+\n \t  break;\n \n \tcase ERT_ALLOWED_EXCEPTIONS:\n@@ -2208,7 +2208,7 @@ sjlj_emit_function_enter (dispatch_label)\n     }\n   else\n     emit_move_insn (mem, const0_rtx);\n-  \n+\n #ifdef DONT_USE_BUILTIN_SETJMP\n   {\n     rtx x, note;\n@@ -2288,7 +2288,7 @@ sjlj_emit_dispatch_table (dispatch_label, lp_info)\n   start_sequence ();\n \n   emit_label (dispatch_label);\n-  \n+\n #ifndef DONT_USE_BUILTIN_SETJMP\n   expand_builtin_setjmp_receiver (dispatch_label);\n #endif\n@@ -2584,7 +2584,7 @@ check_handled (handled, type)\n /* A subroutine of reachable_next_level.  If we are collecting a list\n    of handlers, add one.  After landing pad generation, reference\n    it instead of the handlers themselves.  Further, the handlers are\n-   all wired together, so by referencing one, we've got them all. \n+   all wired together, so by referencing one, we've got them all.\n    Before landing pad generation we reference each handler individually.\n \n    LP_REGION contains the landing pad; REGION is the handler.  */\n@@ -2607,7 +2607,7 @@ add_reachable_handler (info, lp_region, region)\n     info->handlers = alloc_INSN_LIST (region->label, info->handlers);\n }\n \n-/* Process one level of exception regions for reachability.  \n+/* Process one level of exception regions for reachability.\n    If TYPE_THROWN is non-null, then it is the *exact* type being\n    propagated.  If INFO is non-null, then collect handler labels\n    and caught/allowed type information between invocations.  */\n@@ -2647,7 +2647,7 @@ reachable_next_level (region, type_thrown, info)\n \t      {\n \t\t/* If we have a at least one type match, end the search.  */\n \t\ttree tp_node = c->u.catch.type_list;\n-\t\t\n+\n \t\tfor (; tp_node; tp_node = TREE_CHAIN (tp_node))\n \t\t  {\n \t\t    tree type = TREE_VALUE (tp_node);\n@@ -2670,11 +2670,11 @@ reachable_next_level (region, type_thrown, info)\n \t    /* At this point, we either don't know what type is thrown or\n \t       don't have front-end assistance to help deciding if it is\n \t       covered by one of the types in the list for this region.\n-\t    \n+\n \t       We'd then like to add this region to the list of reachable\n \t       handlers since it is indeed potentially reachable based on the\n-\t       information we have. \n-\t       \n+\t       information we have.\n+\n \t       Actually, this handler is for sure not reachable if all the\n \t       types it matches have already been caught. That is, it is only\n \t       potentially reachable if at least one of the types it catches\n@@ -2697,15 +2697,15 @@ reachable_next_level (region, type_thrown, info)\n \t\t      {\n \t\t\tinfo->types_caught\n \t\t\t  = tree_cons (NULL, type, info->types_caught);\n-\t\t\t\n+\n \t\t\tmaybe_reachable = true;\n \t\t      }\n \t\t  }\n-\t\t\n+\n \t\tif (maybe_reachable)\n \t\t  {\n \t\t    add_reachable_handler (info, region, c);\n-\t\t\n+\n \t\t    /* ??? If the catch type is a base class of every allowed\n \t\t       type, then we know we can stop the search.  */\n \t\t    ret = RNL_MAYBE_CAUGHT;\n@@ -2730,7 +2730,7 @@ reachable_next_level (region, type_thrown, info)\n \tinfo->types_allowed = tree_cons (NULL_TREE,\n \t\t\t\t\t region->u.allowed.type_list,\n \t\t\t\t\t info->types_allowed);\n-\t    \n+\n       /* If we have definitive information about the type hierarchy,\n \t then we can tell if the thrown type will pass through the\n \t filter.  */\n@@ -2767,6 +2767,7 @@ reachable_next_level (region, type_thrown, info)\n \n     case ERT_THROW:\n     case ERT_FIXUP:\n+    case ERT_UNKNOWN:\n       /* Shouldn't see these here.  */\n       break;\n     }\n@@ -3013,7 +3014,7 @@ expand_builtin_eh_return_data_regno (arglist)\n   iwhich = DBX_REGISTER_NUMBER (iwhich);\n #endif\n \n-  return GEN_INT (iwhich);      \n+  return GEN_INT (iwhich);\n }\n \n /* Given a value extracted from the return address register or stack slot,\n@@ -3253,7 +3254,7 @@ collect_one_action_chain (ar_hash, region)\n \t    {\n \t      /* Retrieve the filter from the head of the filter list\n \t\t where we have stored it (see assign_filter_values).  */\n-\t      int filter \n+\t      int filter\n \t\t= TREE_INT_CST_LOW (TREE_VALUE (c->u.catch.filter_list));\n \n \t      next = add_action_record (ar_hash, filter, 0);\n@@ -3278,7 +3279,7 @@ collect_one_action_chain (ar_hash, region)\n \t\t  else if (next <= 0)\n \t\t    next = add_action_record (ar_hash, 0, 0);\n \t\t}\n-\t      \n+\n \t      flt_node = c->u.catch.filter_list;\n \t      for (; flt_node; flt_node = TREE_CHAIN (flt_node))\n \t\t{\n@@ -3446,7 +3447,7 @@ convert_to_eh_region_ranges ()\n \t       are created.  */\n \t    if (this_action >= -1)\n \t      {\n-\t\tcall_site = add_call_site (this_landing_pad, \n+\t\tcall_site = add_call_site (this_landing_pad,\n \t\t\t\t\t   this_action < 0 ? 0 : this_action);\n \t\tnote = emit_note_before (NOTE_INSN_EH_REGION_BEG, iter);\n \t\tNOTE_EH_HANDLER (note) = call_site;\n@@ -3692,7 +3693,7 @@ output_function_exception_table ()\n     {\n #ifdef HAVE_AS_LEB128\n       char ttype_after_disp_label[32];\n-      ASM_GENERATE_INTERNAL_LABEL (ttype_after_disp_label, \"LLSDATTD\", \n+      ASM_GENERATE_INTERNAL_LABEL (ttype_after_disp_label, \"LLSDATTD\",\n \t\t\t\t   funcdef_number);\n       dw2_asm_output_delta_uleb128 (ttype_label, ttype_after_disp_label,\n \t\t\t\t    \"@TType base offset\");"}]}