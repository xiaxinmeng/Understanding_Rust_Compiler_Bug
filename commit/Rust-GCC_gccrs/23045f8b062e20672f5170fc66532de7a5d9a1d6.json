{"sha": "23045f8b062e20672f5170fc66532de7a5d9a1d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMwNDVmOGIwNjJlMjA2NzJmNTE3MGZjNjY1MzJkZTdhNWQ5YTFkNg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-11-22T13:29:54Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-11-22T18:39:26Z"}, "message": "d: Fix OutOfMemoryError thrown when appending to an array with a side effect\n\nWhen appending a character to an array, the result of that concat\nassignment was not the new value of the array, similarly, when appending\nan array to another array, side effects were evaluated in reverse to the\nexpected order of evaluation.\n\nAs of this change, the address of the left-hand side expression is\nsaved and re-used as the result.  Its evaluation is now also forced to\noccur before the concat operation itself is called.\n\ngcc/d/ChangeLog:\n\n\tPR d/97889\n\t* expr.cc (ExprVisitor::visit (CatAssignExp *)): Enforce LTR order of\n\tevaluation on left and right hand side expressions.\n\ngcc/testsuite/ChangeLog:\n\n\tPR d/97889\n\t* gdc.dg/torture/pr97889.d: New test.", "tree": {"sha": "1e2a2b9df94c72efa445409d083af872edc578df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e2a2b9df94c72efa445409d083af872edc578df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23045f8b062e20672f5170fc66532de7a5d9a1d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23045f8b062e20672f5170fc66532de7a5d9a1d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23045f8b062e20672f5170fc66532de7a5d9a1d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23045f8b062e20672f5170fc66532de7a5d9a1d6/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1fb592f2c3c6b5a6616cf882ce24d30e167a646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1fb592f2c3c6b5a6616cf882ce24d30e167a646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1fb592f2c3c6b5a6616cf882ce24d30e167a646"}], "stats": {"total": 96, "additions": 72, "deletions": 24}, "files": [{"sha": "2a1818ab4e5dac151658c28e912a09345c3b2e79", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23045f8b062e20672f5170fc66532de7a5d9a1d6/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23045f8b062e20672f5170fc66532de7a5d9a1d6/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=23045f8b062e20672f5170fc66532de7a5d9a1d6", "patch": "@@ -838,62 +838,81 @@ class ExprVisitor : public Visitor\n     Type *tb2 = e->e2->type->toBasetype ();\n     Type *etype = tb1->nextOf ()->toBasetype ();\n \n+    /* Save the address of `e1', so it can be evaluated first.\n+       As all D run-time library functions for concat assignments update `e1'\n+       in-place and then return its value, the saved address can also be used as\n+       the result of this expression as well.  */\n+    tree lhs = build_expr (e->e1);\n+    tree lexpr = stabilize_expr (&lhs);\n+    tree ptr = d_save_expr (build_address (lhs));\n+    tree result = NULL_TREE;\n+\n     if (tb1->ty == Tarray && tb2->ty == Tdchar\n \t&& (etype->ty == Tchar || etype->ty == Twchar))\n       {\n-\t/* Append a dchar to a char[] or wchar[]  */\n+\t/* Append a dchar to a char[] or wchar[]:\n+\t   The assignment is handled by the D run-time library, so only\n+\t   need to call `_d_arrayappend[cw]d(&e1, e2)'  */\n \tlibcall_fn libcall = (etype->ty == Tchar)\n \t  ? LIBCALL_ARRAYAPPENDCD : LIBCALL_ARRAYAPPENDWD;\n \n-\tthis->result_ = build_libcall (libcall, e->type, 2,\n-\t\t\t\t       build_address (build_expr (e->e1)),\n-\t\t\t\t       build_expr (e->e2));\n+\tresult = build_libcall (libcall, e->type, 2,\n+\t\t\t\tptr, build_expr (e->e2));\n       }\n     else\n       {\n \tgcc_assert (tb1->ty == Tarray || tb2->ty == Tsarray);\n \n-\ttree tinfo = build_typeinfo (e->loc, e->type);\n-\ttree ptr = build_address (build_expr (e->e1));\n-\n \tif ((tb2->ty == Tarray || tb2->ty == Tsarray)\n \t    && same_type_p (etype, tb2->nextOf ()->toBasetype ()))\n \t  {\n-\t    /* Append an array.  */\n-\t    this->result_ = build_libcall (LIBCALL_ARRAYAPPENDT, e->type, 3,\n-\t\t\t\t\t   tinfo, ptr, d_array_convert (e->e2));\n-\n+\t    /* Append an array to another array:\n+\t       The assignment is handled by the D run-time library, so only\n+\t       need to call `_d_arrayappendT(ti, &e1, e2)'  */\n+\t    result = build_libcall (LIBCALL_ARRAYAPPENDT, e->type, 3,\n+\t\t\t\t    build_typeinfo (e->loc, e->type),\n+\t\t\t\t    ptr, d_array_convert (e->e2));\n \t  }\n \telse if (same_type_p (etype, tb2))\n \t  {\n-\t    /* Append an element.  */\n-\t    tree result = build_libcall (LIBCALL_ARRAYAPPENDCTX, e->type, 3,\n-\t\t\t\t\t tinfo, ptr, size_one_node);\n-\t    result = d_save_expr (result);\n+\t    /* Append an element to an array:\n+\t       The assignment is generated inline, so need to handle temporaries\n+\t       here, and ensure that they are evaluated in the correct order.\n+\n+\t       The generated code should end up being equivalent to:\n+\t\t    _d_arrayappendcTX(ti, &e1, 1)[e1.length - 1] = e2\n+\t     */\n+\t    tree callexp = build_libcall (LIBCALL_ARRAYAPPENDCTX, e->type, 3,\n+\t\t\t\t\t  build_typeinfo (e->loc, e->type),\n+\t\t\t\t\t  ptr, size_one_node);\n+\t    callexp = d_save_expr (callexp);\n \n \t    /* Assign e2 to last element.  */\n-\t    tree offexp = d_array_length (result);\n+\t    tree offexp = d_array_length (callexp);\n \t    offexp = build2 (MINUS_EXPR, TREE_TYPE (offexp),\n \t\t\t     offexp, size_one_node);\n \n-\t    tree ptrexp = d_array_ptr (result);\n+\t    tree ptrexp = d_array_ptr (callexp);\n \t    ptrexp = void_okay_p (ptrexp);\n \t    ptrexp = build_array_index (ptrexp, offexp);\n \n \t    /* Evaluate expression before appending.  */\n-\t    tree t2 = build_expr (e->e2);\n-\t    tree expr = stabilize_expr (&t2);\n+\t    tree rhs = build_expr (e->e2);\n+\t    tree rexpr = stabilize_expr (&rhs);\n \n-\t    if (TREE_CODE (t2) == CALL_EXPR)\n-\t      t2 = force_target_expr (t2);\n+\t    if (TREE_CODE (rhs) == CALL_EXPR)\n+\t      rhs = force_target_expr (rhs);\n \n-\t    result = modify_expr (build_deref (ptrexp), t2);\n-\n-\t    this->result_ = compound_expr (expr, result);\n+\t    result = modify_expr (build_deref (ptrexp), rhs);\n+\t    result = compound_expr (rexpr, result);\n \t  }\n \telse\n \t  gcc_unreachable ();\n       }\n+\n+    /* Construct in order: ptr = &e1, _d_arrayappend(ptr, e2), *ptr;  */\n+    result = compound_expr (compound_expr (lexpr, ptr), result);\n+    this->result_ = compound_expr (result, build_deref (ptr));\n   }\n \n   /* Build an assignment expression.  The right operand is implicitly"}, {"sha": "9135c8fa5cfeecb3345681efecc1c98ab1c115c0", "filename": "gcc/testsuite/gdc.dg/torture/pr97889.d", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23045f8b062e20672f5170fc66532de7a5d9a1d6/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fpr97889.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23045f8b062e20672f5170fc66532de7a5d9a1d6/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fpr97889.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fpr97889.d?ref=23045f8b062e20672f5170fc66532de7a5d9a1d6", "patch": "@@ -0,0 +1,29 @@\n+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=97889\n+// { dg-additional-options \"-fmain -funittest\" }\n+// { dg-do run }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+\n+auto cat11ret3(T)(ref T s)\n+{\n+    s ~= 11;\n+    return [3];\n+}\n+\n+unittest\n+{\n+    static auto test1(int[] val) { val ~= cat11ret3(val); return val; }\n+    assert(test1([1]) == [1, 11, 3]);\n+    static assert(test1([1]) == [1, 11, 3]);\n+\n+    static auto test2(int[] val) { val = val ~ cat11ret3(val); return val; }\n+    // FIXME: assert(test2([1]) == [1, 3]);\n+    static assert(test2([1]) == [1, 3]);\n+\n+    static auto test3(int[] val) { (val ~= 7) ~= cat11ret3(val); return val; }\n+    assert(test3([2]) == [2, 7, 11, 3]);\n+    static assert(test3([2]) == [2, 7, 11, 3]);\n+\n+    static auto test4(int[] val) { (val ~= cat11ret3(val)) ~= 7; return val; }\n+    assert(test4([2]) == [2, 11, 3, 7]);\n+    static assert(test4([2]) == [2, 11, 3, 7]);\n+}"}]}