{"sha": "bb14e19c2be54dd10f40d705364e08524ec8310c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIxNGUxOWMyYmU1NGRkMTBmNDBkNzA1MzY0ZTA4NTI0ZWM4MzEwYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-12-22T15:55:10Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-12-22T15:55:10Z"}, "message": "compiler: bring escape analysis mostly in line with gc compiler\n    \n    This CL ports the latest (~Go 1.10) escape analysis code from\n    the gc compiler. Changes include:\n    \n    - In the gc compiler, the variable expression is represented\n      with the variable node itself (ONAME). It is the same node\n      used in the AST for multiple var expressions for the same\n      variable. In our case, the var expressions nodes are distinct\n      nodes. We need to propagate the escape state from/to the\n      underlying variable in getter and setter. We already do it in\n      the setter. Do it in the getter as well.\n    \n    - At the point of escape analysis, some AST constructs have not\n      been lowered to runtime calls, for example, map literal\n      construction and some builtin calls. Change the analysis to\n      work on the non-lowered AST constructs instead of call\n      expressions for them. For this to work, the analysis needs to\n      look into Builtin_call_expression. Move its class definition\n      from expressions.cc to expressions.h, and add necessary\n      accessors. Also fix bugs in other runtime call handlings\n      (selectsend, ifaceX2Y2, etc.).\n    \n    - Handle closures properly. The analysis tracks the function\n      reference expression, and the escape state is propagated to\n      the underlying heap expression for get_backend to do stack\n      allocation for non-escaping closures.\n    \n    - Fix add_dereference. Before, this was doing expr->deref(),\n      which undoes an indirection instead of add one. In the gc\n      compiler, it adds a level of indirection, which is modeled as\n      an OIND node regardless of the type of the expression. We\n      can't do this for non-pointer typed expression, otherwise it\n      will result in a type error. Instead, we model it with a\n      special flavor of Node, \"indirect\". The flood phase handles\n      this by incrementing its level.\n    \n    - Slicing of an array was not handled correctly. The gc compiler\n      has an implicit (compiler inserted) OADDR node for the array,\n      so the analysis is actually performed on the address of the\n      array. We don't have this implicit address-of expression in\n      the AST. Instead, we model this by adding an implicit child to\n      the Node of the Array_index_expression representing slicing of\n      an array.\n    \n    - Array_index_expression may represent indexing or slicing. The\n      code distinguishes them by looking at whether the type of the\n      expression is a slice. This does not work if the slice element\n      is a slice. Instead, check whether its end() is NULL.\n    \n    - Temporary references was handled only in a limited case, as\n      part of address-of expression. This CL handles it in general.\n      The analysis uses the Temporary_statement as the point of\n      tracking, and forwards Temporary_reference_expression to the\n      underlying statement when needed.\n    \n    - Handle call return value flows, escpecially multiple return\n      values. This includes porting part of CL 8202, CL 20102, and\n      other fixes.\n    \n    - Support go:noescape pragma.\n    \n    - Add special handling for self assignment like\n      b.buf = b.buf[m:n]. (CL 3162)\n    \n    - Remove ESCAPE_SCOPE, which was treated essentially the same as\n      ESCAPE_HEAP, and was removed from the gc compiler. (CL 32130)\n    \n    - Run flood phase until fix point. (CL 30693)\n    \n    - Unnamed parameters do not escape. (CL 38600)\n    \n    - Various small bug fixes and improvements.\n    \n    \"make check-go\" passes except the one test in math/big, when the\n    escape analysis is on. The escape analysis is still not run by\n    default.\n    \n    Reviewed-on: https://go-review.googlesource.com/83876\n\nFrom-SVN: r255976", "tree": {"sha": "7efb527f7a7ce27ccda83182efded7baed05aec5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7efb527f7a7ce27ccda83182efded7baed05aec5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb14e19c2be54dd10f40d705364e08524ec8310c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb14e19c2be54dd10f40d705364e08524ec8310c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb14e19c2be54dd10f40d705364e08524ec8310c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb14e19c2be54dd10f40d705364e08524ec8310c/comments", "author": null, "committer": null, "parents": [{"sha": "e2a29465e91c75b337aabd5886af982653faf00e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a29465e91c75b337aabd5886af982653faf00e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2a29465e91c75b337aabd5886af982653faf00e"}], "stats": {"total": 1404, "additions": 888, "deletions": 516}, "files": [{"sha": "b81922efe5941ca9069a7af19961d68ecb694a54", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=bb14e19c2be54dd10f40d705364e08524ec8310c", "patch": "@@ -1,4 +1,4 @@\n-66de779004bdaafefc27e4132324a47d86a0f122\n+83fc0e440b8c151edc5b1c67006257aad522ca04\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "870680860d5e72546459832a3bd6d3dd433e3cb9", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 690, "deletions": 372, "changes": 1062, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=bb14e19c2be54dd10f40d705364e08524ec8310c", "patch": "@@ -15,6 +15,7 @@\n #include \"expressions.h\"\n #include \"statements.h\"\n #include \"escape.h\"\n+#include \"lex.h\"\n #include \"ast-dump.h\"\n #include \"go-optimize.h\"\n #include \"go-diagnostics.h\"\n@@ -34,6 +35,19 @@ Node::type() const\n     return this->object()->func_value()->type();\n   else if (this->expr() != NULL)\n     return this->expr()->type();\n+  else if (this->is_indirect())\n+    {\n+      if (this->child()->type()->deref()->is_void_type())\n+        // This is a void*. The referred type can be actually any type,\n+        // which may also be pointer. We model it as another void*, so\n+        // we don't lose pointer-ness.\n+        return this->child()->type();\n+      else\n+        return this->child()->type()->deref();\n+    }\n+  else if (this->statement() != NULL\n+           && this->statement()->temporary_statement() != NULL)\n+    return this->statement()->temporary_statement()->type();\n   else\n     return NULL;\n }\n@@ -49,6 +63,8 @@ Node::location() const\n     return this->expr()->location();\n   else if (this->statement() != NULL)\n     return this->statement()->location();\n+  else if (this->is_indirect())\n+    return this->child()->location();\n   else\n     return Linemap::unknown_location();\n }\n@@ -133,7 +149,7 @@ Node::ast_format(Gogo* gogo) const\n \t}\n       Ast_dump_context::dump_to_stream(this->expr(), &ss);\n     }\n-  else\n+  else if (this->statement() != NULL)\n     {\n       Statement* s = this->statement();\n       Goto_unnamed_statement* unnamed = s->goto_unnamed_statement();\n@@ -162,8 +178,25 @@ Node::ast_format(Gogo* gogo) const\n \t\t}\n \t    }\n \t}\n-      Ast_dump_context::dump_to_stream(s, &ss);\n+      Temporary_statement* tmp = s->temporary_statement();\n+      if (tmp != NULL)\n+        {\n+          // Temporary's format can never match gc's output, and\n+          // temporaries are inserted differently anyway. We just\n+          // print something convenient.\n+          ss << \"tmp.\" << (uintptr_t) tmp;\n+          if (tmp->init() != NULL)\n+            {\n+              ss << \" [ = \";\n+              Ast_dump_context::dump_to_stream(tmp->init(), &ss);\n+              ss << \" ]\";\n+            }\n+        }\n+      else\n+        Ast_dump_context::dump_to_stream(s, &ss);\n     }\n+  else if (this->is_indirect())\n+    return \"*(\" + this->child()->ast_format(gogo) + \")\";\n \n   std::string s = strip_packed_prefix(gogo, ss.str());\n \n@@ -175,7 +208,7 @@ Node::ast_format(Gogo* gogo) const\n // This is an implementation of gc's Jconv with obj.FmtShort.\n \n std::string\n-Node::details() const\n+Node::details()\n {\n   std::stringstream details;\n \n@@ -258,10 +291,6 @@ Node::details() const\n       details << \" esc(h)\";\n       break;\n \n-    case Node::ESCAPE_SCOPE:\n-      details << \" esc(s)\";\n-      break;\n-\n     case Node::ESCAPE_NONE:\n       details << \" esc(no)\";\n       break;\n@@ -383,6 +412,8 @@ Node::op_format() const\n \t  break;\n \t}\n     }\n+  if (this->is_indirect())\n+    op << \"*\";\n   return op.str();\n }\n \n@@ -413,16 +444,40 @@ Node::state(Escape_context* context, Named_object* fn)\n   return this->state_;\n }\n \n-void\n-Node::set_encoding(int enc)\n+int\n+Node::encoding()\n {\n-  this->encoding_ = enc;\n   if (this->expr() != NULL\n       && this->expr()->var_expression() != NULL)\n     {\n-      // Set underlying object as well.\n+      // Get the underlying object's encoding.\n       Named_object* no = this->expr()->var_expression()->named_object();\n-      Node::make_node(no)->set_encoding(enc);\n+      int enc = Node::make_node(no)->encoding();\n+      this->encoding_ = enc;\n+    }\n+  return this->encoding_;\n+}\n+\n+void\n+Node::set_encoding(int enc)\n+{\n+  this->encoding_ = enc;\n+  if (this->expr() != NULL)\n+    {\n+      if (this->expr()->var_expression() != NULL)\n+        {\n+          // Set underlying object as well.\n+          Named_object* no = this->expr()->var_expression()->named_object();\n+          Node::make_node(no)->set_encoding(enc);\n+        }\n+      else if (this->expr()->func_expression() != NULL)\n+        {\n+          // Propagate the escape state to the underlying\n+          // closure (heap expression).\n+          Expression* closure = this->expr()->func_expression()->closure();\n+          if (closure != NULL)\n+            Node::make_node(closure)->set_encoding(enc);\n+        }\n     }\n }\n \n@@ -461,9 +516,17 @@ Node::is_big(Escape_context* context) const\n \t      Expression_list::iterator p = call->args()->begin();\n \t      ++p;\n \n+              Expression* e = *p;\n+              if (e->temporary_reference_expression() != NULL)\n+                {\n+                  Temporary_reference_expression* tre = e->temporary_reference_expression();\n+                  if (tre->statement() != NULL && tre->statement()->init() != NULL)\n+                    e = tre->statement()->init();\n+                }\n+\n \t      Numeric_constant nc;\n \t      unsigned long v;\n-\t      if ((*p)->numeric_constant_value(&nc)\n+\t      if (e->numeric_constant_value(&nc)\n \t\t  && nc.to_unsigned_long(&v) == Numeric_constant::NC_UL_VALID)\n \t\tbig = big || v >= (1 << 16);\n \t    }\n@@ -531,13 +594,22 @@ Node::make_node(Statement* s)\n   return n;\n }\n \n+// Make an indirect node with given child.\n+\n+Node*\n+Node::make_indirect_node(Node* child)\n+{\n+  Node* n = new Node(child);\n+  return n;\n+}\n+\n // Returns the maximum of an exisiting escape value\n // (and its additional parameter flow flags) and a new escape type.\n \n int\n Node::max_encoding(int e, int etype)\n {\n-  if ((e & ESCAPE_MASK) >= etype)\n+  if ((e & ESCAPE_MASK) > etype)\n     return e;\n   if (etype == Node::ESCAPE_NONE || etype == Node::ESCAPE_RETURN)\n     return (e & ~ESCAPE_MASK) | etype;\n@@ -587,7 +659,6 @@ Escape_context::Escape_context(Gogo* gogo, bool recursive)\n {\n   // The sink always escapes to heap and strictly lives outside of the\n   // current function i.e. loop_depth == -1.\n-  this->sink_->set_encoding(Node::ESCAPE_HEAP);\n   Node::Escape_state* state = this->sink_->state(this, NULL);\n   state->loop_depth = -1;\n }\n@@ -656,6 +727,7 @@ Escape_context::init_retvals(Node* n, Function_type* fntype)\n     return;\n \n   Node::Escape_state* state = n->state(this, NULL);\n+  state->retvals.clear();\n   Location loc = n->location();\n \n   int i = 0;\n@@ -672,7 +744,8 @@ Escape_context::init_retvals(Node* n, Function_type* fntype)\n \tNamed_object::make_variable(buf, NULL, dummy_var);\n       Node* dummy_node = Node::make_node(dummy_no);\n       // Initialize the state of the dummy output node.\n-      dummy_node->state(this, NULL);\n+      Node::Escape_state* dummy_node_state = dummy_node->state(this, NULL);\n+      dummy_node_state->loop_depth = this->loop_depth_;\n \n       // Add dummy node to the retvals of n.\n       state->retvals.push_back(dummy_node);\n@@ -681,20 +754,30 @@ Escape_context::init_retvals(Node* n, Function_type* fntype)\n \n \n // Apply an indirection to N and return the result.\n-// This really only works if N is an expression node; it essentially becomes\n-// Node::make_node(n->expr()->deref()).  We need the escape context to set the\n-// correct loop depth, however.\n \n Node*\n Escape_context::add_dereference(Node* n)\n {\n-  // Just return the original node if we can't add an indirection.\n-  if (n->object() != NULL || n->statement() != NULL)\n-    return n;\n-\n-  Node* ind = Node::make_node(n->expr()->deref());\n-  // Initialize the state if this node doesn't already exist.\n-  ind->state(this, NULL);\n+  Expression* e = n->expr();\n+  Location loc = n->location();\n+  Node* ind;\n+  if (e != NULL\n+      && e->type()->points_to() != NULL\n+      && !e->type()->points_to()->is_void_type())\n+    {\n+      // We don't dereference void*, which can be actually any pointer type.\n+      Expression* deref_expr = Expression::make_unary(OPERATOR_MULT, e, loc);\n+      ind = Node::make_node(deref_expr);\n+    }\n+  else\n+    // The gc compiler simply makes an OIND node. We can't do it\n+    // for non-pointer type because that will result in a type error.\n+    // Instead, we model this by making a node with a special flavor.\n+    ind = Node::make_indirect_node(n);\n+\n+  // Initialize the state.\n+  Node::Escape_state* state = ind->state(this, NULL);\n+  state->loop_depth = n->state(this, NULL)->loop_depth;\n   return ind;\n }\n \n@@ -775,10 +858,43 @@ Gogo::analyze_escape()\n \n       // Propagate levels across each dst.  This is the flood phase.\n       std::set<Node*> dsts = context->dsts();\n+      std::unordered_map<Node*, int> escapes;\n       for (std::set<Node*>::iterator n = dsts.begin();\n            n != dsts.end();\n            ++n)\n-        this->propagate_escape(context, *n);\n+        {\n+          escapes[*n] = (*n)->encoding();\n+          this->propagate_escape(context, *n);\n+        }\n+      for (;;)\n+        {\n+          // Reflood if the roots' escape states increase. Run until fix point.\n+          // This is rare.\n+          bool done = true;\n+          for (std::set<Node*>::iterator n = dsts.begin();\n+               n != dsts.end();\n+               ++n)\n+            {\n+              if ((*n)->object() == NULL\n+                  && ((*n)->expr() == NULL\n+                      || ((*n)->expr()->var_expression() == NULL\n+                          && (*n)->expr()->enclosed_var_expression() == NULL\n+                          && (*n)->expr()->func_expression() == NULL)))\n+                continue;\n+              if (escapes[*n] != (*n)->encoding())\n+                {\n+                  done = false;\n+                  if (this->debug_escape_level() > 2)\n+                    go_inform((*n)->location(), \"Reflooding %s %s\",\n+                              debug_function_name((*n)->state(context, NULL)->fn).c_str(),\n+                              (*n)->ast_format(this).c_str());\n+                  escapes[*n] = (*n)->encoding();\n+                  this->propagate_escape(context, *n);\n+                }\n+            }\n+          if (done)\n+            break;\n+        }\n \n       // Tag each exported function's parameters with escape information.\n       for (std::vector<Named_object*>::iterator fn = stack.begin();\n@@ -799,7 +915,6 @@ Gogo::analyze_escape()\n \t\t\t  strip_packed_prefix(this, debug_function_name(state->fn)).c_str(),\n \t\t\t  (*n)->ast_format(this).c_str());\n \t    }\n-\t  // TODO(cmang): Which objects in context->noesc actually don't escape.\n \t}\n       delete context;\n     }\n@@ -893,8 +1008,8 @@ Escape_analysis_discover::visit(Named_object* fn)\n   this->stack_.push(fn);\n   min = this->visit_code(fn, min);\n   if ((min == id || min == id + 1)\n-      && fn->is_function()\n-      && fn->func_value()->enclosing() == NULL)\n+      && ((fn->is_function() && fn->func_value()->enclosing() == NULL)\n+          || fn->is_function_declaration()))\n     {\n       bool recursive = min == id;\n       std::vector<Named_object*> group;\n@@ -1072,6 +1187,38 @@ class Escape_analysis_assign : public Traverse\n   Named_object* fn_;\n };\n \n+// Helper function to detect self assignment like the following.\n+//\n+// func (b *Buffer) Foo() {\n+//   n, m := ...\n+//   b.buf = b.buf[n:m]\n+// }\n+\n+static bool\n+is_self_assignment(Expression* lhs, Expression* rhs)\n+{\n+  Unary_expression* lue =\n+    (lhs->field_reference_expression() != NULL\n+     ? lhs->field_reference_expression()->expr()->unary_expression()\n+     : lhs->unary_expression());\n+  Var_expression* lve =\n+    (lue != NULL && lue->op() == OPERATOR_MULT ? lue->operand()->var_expression() : NULL);\n+  Array_index_expression* raie = rhs->array_index_expression();\n+  String_index_expression* rsie = rhs->string_index_expression();\n+  Expression* rarray =\n+    (raie != NULL && raie->end() != NULL && raie->array()->type()->is_slice_type()\n+     ? raie->array()\n+     : (rsie != NULL && rsie->type()->is_string_type() ? rsie->string() : NULL));\n+  Unary_expression* rue =\n+    (rarray != NULL && rarray->field_reference_expression() != NULL\n+     ? rarray->field_reference_expression()->expr()->unary_expression()\n+     : (rarray != NULL ? rarray->unary_expression() : NULL));\n+  Var_expression* rve =\n+    (rue != NULL && rue->op() == OPERATOR_MULT ? rue->operand()->var_expression() : NULL);\n+  return lve != NULL && rve != NULL\n+         && lve->named_object() == rve->named_object();\n+}\n+\n // Model statements within a function as assignments and flows between nodes.\n \n int\n@@ -1121,6 +1268,14 @@ Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n       }\n       break;\n \n+    case Statement::STATEMENT_TEMPORARY:\n+      {\n+        Expression* init = s->temporary_statement()->init();\n+        if (init != NULL)\n+          this->assign(Node::make_node(s), Node::make_node(init));\n+      }\n+      break;\n+\n     case Statement::STATEMENT_LABEL:\n       {\n \tLabel_statement* label_stmt = s->label_statement();\n@@ -1144,22 +1299,36 @@ Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n       // Want to model the assignment of each case variable to the switched upon\n       // variable.  This should be lowered into assignment statements; nothing\n       // to here if that's the case.\n-      // TODO(cmang): Verify.\n       break;\n \n     case Statement::STATEMENT_ASSIGNMENT:\n       {\n \tAssignment_statement* assn = s->assignment_statement();\n-\tNode* lhs = Node::make_node(assn->lhs());\n-\tNode* rhs = Node::make_node(assn->rhs());\n-\n-\t// TODO(cmang): Add special case for escape analysis no-op:\n-\t// func (b *Buffer) Foo() {\n-\t// \tn, m := ...\n-\t//\tb.buf = b.buf[n:m]\n-\t// }\n-\t// This is okay for now, it just means b escapes; it is conservative.\n-\tthis->assign(lhs, rhs);\n+        Expression* lhs = assn->lhs();\n+        Expression* rhs = assn->rhs();\n+        Node* lhs_node = Node::make_node(lhs);\n+        Node* rhs_node = Node::make_node(rhs);\n+\n+        // Filter out the following special case.\n+        //\n+        // func (b *Buffer) Foo() {\n+        //   n, m := ...\n+        //   b.buf = b.buf[n:m]\n+        // }\n+        //\n+        // This assignment is a no-op for escape analysis,\n+        // it does not store any new pointers into b that were not already there.\n+        // However, without this special case b will escape.\n+        if (is_self_assignment(lhs, rhs))\n+          {\n+            if (debug_level != 0)\n+              go_inform(s->location(), \"%s ignoring self-assignment to %s\",\n+                        strip_packed_prefix(gogo, this->context_->current_function_name()).c_str(),\n+                        lhs_node->ast_format(gogo).c_str());\n+            break;\n+          }\n+\n+        this->assign(lhs_node, rhs_node);\n       }\n       break;\n \n@@ -1199,8 +1368,6 @@ Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n       }\n       break;\n \n-      // TODO(cmang): Associate returned values with dummy return nodes.\n-\n     default:\n       break;\n     }\n@@ -1221,7 +1388,15 @@ Escape_analysis_assign::expression(Expression** pexpr)\n       && n->is_big(this->context_))\n     {\n       if (debug_level > 1)\n-\tgo_inform((*pexpr)->location(), \"too large for stack\");\n+\tgo_inform((*pexpr)->location(), \"%s too large for stack\",\n+                  n->ast_format(gogo).c_str());\n+      if (debug_level != 0\n+          && ((*pexpr)->var_expression() != NULL\n+              || (*pexpr)->enclosed_var_expression() != NULL))\n+        go_inform(n->definition_location(),\n+                  \"moved to heap: %s\",\n+                  n->ast_format(gogo).c_str());\n+\n       n->set_encoding(Node::ESCAPE_HEAP);\n       (*pexpr)->address_taken(true);\n       this->assign(this->context_->sink(), n);\n@@ -1244,100 +1419,158 @@ Escape_analysis_assign::expression(Expression** pexpr)\n     case Expression::EXPRESSION_CALL:\n       {\n \tCall_expression* call = (*pexpr)->call_expression();\n-\tthis->call(call);\n+        if (call->is_builtin())\n+          {\n+            Builtin_call_expression* bce = call->builtin_call_expression();\n+            switch (bce->code())\n+              {\n+              case Builtin_call_expression::BUILTIN_PANIC:\n+                {\n+                  // Argument could leak through recover.\n+                  Node* panic_arg = Node::make_node(call->args()->front());\n+                  this->assign(this->context_->sink(), panic_arg);\n+                }\n+                break;\n+\n+              case Builtin_call_expression::BUILTIN_APPEND:\n+                {\n+                  // The contents being appended leak.\n+                  if (call->is_varargs())\n+                    {\n+                      // append(slice1, slice2...) -- slice2 itself does not escape, but contents do\n+                      Node* appended = Node::make_node(call->args()->back());\n+                      this->assign_deref(this->context_->sink(), appended);\n+                      if (debug_level > 2)\n+                        go_inform((*pexpr)->location(),\n+                                  \"special treatment of append(slice1, slice2...)\");\n+                    }\n+                  else\n+                    {\n+                      for (Expression_list::const_iterator pa =\n+                             call->args()->begin() + 1;\n+                           pa != call->args()->end();\n+                           ++pa)\n+                        {\n+                          Node* arg = Node::make_node(*pa);\n+                          this->assign(this->context_->sink(), arg);\n+                        }\n+                    }\n+\n+                  // The content of the original slice leaks as well.\n+                  Node* appendee = Node::make_node(call->args()->front());\n+                  this->assign_deref(this->context_->sink(), appendee);\n+                }\n+                break;\n \n+              case Builtin_call_expression::BUILTIN_COPY:\n+                {\n+                  // Lose track of the copied content.\n+                  Node* copied = Node::make_node(call->args()->back());\n+                  this->assign_deref(this->context_->sink(), copied);\n+                }\n+                break;\n+\n+              default:\n+                break;\n+              }\n+            break;\n+          }\n \tFunc_expression* fe = call->fn()->func_expression();\n \tif (fe != NULL && fe->is_runtime_function())\n \t  {\n \t    switch (fe->runtime_code())\n \t      {\n-\t      case Runtime::GOPANIC:\n-\t\t{\n-\t\t  // Argument could leak through recover.\n-\t\t  Node* panic_arg = Node::make_node(call->args()->front());\n-\t\t  this->assign(this->context_->sink(), panic_arg);\n-\t\t}\n-\t\tbreak;\n-\n-\t      case Runtime::GROWSLICE:\n-\t\t{\n-\t\t  // The contents being appended leak.\n-\t\t  if (call->is_varargs())\n-\t\t    {\n-\t\t      Node* appended = Node::make_node(call->args()->back());\n-\t\t      this->assign_deref(this->context_->sink(), appended);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      for (Expression_list::const_iterator pa =\n-\t\t\t     call->args()->begin();\n-\t\t\t   pa != call->args()->end();\n-\t\t\t   ++pa)\n-\t\t\t{\n-\t\t\t  Node* arg = Node::make_node(*pa);\n-\t\t\t  this->assign(this->context_->sink(), arg);\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  if (debug_level > 2)\n-\t\t    go_error_at((*pexpr)->location(),\n-\t\t\t     \"special treatment of append(slice1, slice2...)\");\n-\n-\t\t  // The content of the original slice leaks as well.\n-\t\t  Node* appendee = Node::make_node(call->args()->front());\n-\t\t  this->assign_deref(this->context_->sink(), appendee);\n-\t\t}\n-\t\tbreak;\n-\n-\t      case Runtime::SLICECOPY:\n-\t      case Runtime::SLICESTRINGCOPY:\n-\t      case Runtime::TYPEDSLICECOPY:\n-\t\t{\n-\t\t  // Lose track of the copied content.\n-\t\t  Node* copied = Node::make_node(call->args()->back());\n-\t\t  this->assign_deref(this->context_->sink(), copied);\n-\t\t}\n-\t\tbreak;\n-\n \t      case Runtime::MAKECHAN:\n \t      case Runtime::MAKEMAP:\n \t      case Runtime::MAKESLICE:\n \t      case Runtime::MAKESLICE64:\n-\t      case Runtime::SLICEBYTETOSTRING:\n-\t      case Runtime::SLICERUNETOSTRING:\n-\t      case Runtime::STRINGTOSLICEBYTE:\n-\t      case Runtime::STRINGTOSLICERUNE:\n-\t      case Runtime::CONCATSTRINGS:\n-\t      case Runtime::CONCATSTRING2:\n-\t      case Runtime::CONCATSTRING3:\n-\t      case Runtime::CONCATSTRING4:\n-\t      case Runtime::CONCATSTRING5:\n-\t      case Runtime::CONSTRUCT_MAP:\n-\t      case Runtime::INTSTRING:\n-\t\t{\n-\t\t  Node* runtime_node = Node::make_node(fe);\n-\t\t  this->context_->track(runtime_node);\n-\t\t}\n+                this->context_->track(n);\n \t\tbreak;\n \n+              case Runtime::MAPASSIGN:\n+                {\n+                  // Map key escapes. The last argument is the address\n+                  // of the key.\n+                  Node* key_node = Node::make_node(call->args()->back());\n+                  this->assign_deref(this->context_->sink(), key_node);\n+                }\n+                break;\n+\n+              case Runtime::SELECTSEND:\n+                {\n+                  // Send to a channel, lose track. The last argument is\n+                  // the address of the value to send.\n+                  Node* arg_node = Node::make_node(call->args()->back());\n+                  this->assign_deref(this->context_->sink(), arg_node);\n+                }\n+                break;\n+\n+              case Runtime::IFACEE2T2:\n+              case Runtime::IFACEI2T2:\n+                {\n+                  // x, ok = v.(T), where T is non-pointer non-interface,\n+                  // is lowered to\n+                  // ok = IFACEI2T2(type, v, (void*)&tmp_x)\n+                  // Here v flows to tmp_x.\n+                  // Note: other IFACEX2Y2 returns the conversion result.\n+                  // Those are handled in ::assign.\n+                  Node* src_node = Node::make_node(call->args()->at(1));\n+                  Node* dst_node;\n+                  Expression* arg2 = call->args()->at(2);\n+                  // Try to pull tmp_x out of the arg2 expression, and let v\n+                  // flows into it, instead of simply dereference arg2,\n+                  // which looks like dereference of an arbitrary pointer\n+                  // and causes v immediately escape.\n+                  // The expression form matches statement.cc,\n+                  // Tuple_type_guard_assignment_statement::lower_to_object_type.\n+                  Unary_expression* ue =\n+                    (arg2->conversion_expression() != NULL\n+                     ? arg2->conversion_expression()->expr()->unary_expression()\n+                     : arg2->unary_expression());\n+                  if (ue != NULL && ue->op() == OPERATOR_AND)\n+                    {\n+                      if (!ue->operand()->type()->has_pointer())\n+                        // Don't bother flowing non-pointer.\n+                        break;\n+                      dst_node = Node::make_node(ue->operand());\n+                    }\n+                  else\n+                    dst_node = this->context_->add_dereference(Node::make_node(arg2));\n+                  this->assign(dst_node, src_node);\n+                }\n+                break;\n+\n \t      default:\n \t\tbreak;\n \t      }\n \t  }\n+        else\n+          this->call(call);\n       }\n       break;\n \n     case Expression::EXPRESSION_ALLOCATION:\n-      {\n-\t// Same as above; this is Runtime::NEW.\n-\tNode* alloc_node = Node::make_node(*pexpr);\n-\tthis->context_->track(alloc_node);\n-      }\n+      // This is Runtime::NEW.\n+      this->context_->track(n);\n+      break;\n+\n+    case Expression::EXPRESSION_STRING_CONCAT:\n+      this->context_->track(n);\n       break;\n \n     case Expression::EXPRESSION_CONVERSION:\n       {\n \tType_conversion_expression* tce = (*pexpr)->conversion_expression();\n+        Type* ft = tce->expr()->type();\n+        Type* tt = tce->type();\n+        if ((ft->is_string_type() && tt->is_slice_type())\n+            || (ft->is_slice_type() && tt->is_string_type())\n+            || (ft->integer_type() != NULL && tt->is_string_type()))\n+          {\n+            // string([]byte), string([]rune), []byte(string), []rune(string), string(rune)\n+            this->context_->track(n);\n+            break;\n+          }\n \tNode* tce_node = Node::make_node(tce);\n \tNode* converted = Node::make_node(tce->expr());\n \tthis->context_->track(tce_node);\n@@ -1478,26 +1711,6 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \t  var = operand->var_expression()->named_object();\n \telse if (operand->enclosed_var_expression() != NULL)\n \t  var = operand->enclosed_var_expression()->variable();\n-\telse if (operand->temporary_reference_expression() != NULL)\n-\t  {\n-\t    // Found in runtime/chanbarrier_test.go.  The address of a struct\n-\t    // reference is usually a heap expression, except when it is a part\n-\t    // of a case statement.  In that case, it is lowered into a\n-\t    // temporary reference and never linked to the heap expression that\n-\t    // initializes it.  In general, when taking the address of some\n-\t    // temporary, the analysis should really be looking at the initial\n-\t    // value of that temporary.\n-\t    Temporary_reference_expression* tre =\n-\t      operand->temporary_reference_expression();\n-\t    if (tre->statement() != NULL\n-\t\t&& tre->statement()->temporary_statement()->init() != NULL)\n-\t      {\n-\t\tExpression* init =\n-\t\t  tre->statement()->temporary_statement()->init();\n-\t\tNode* init_node = Node::make_node(init);\n-\t\tthis->assign(addr_node, init_node);\n-\t      }\n-\t  }\n \n \tif (var == NULL)\n \t  break;\n@@ -1525,6 +1738,21 @@ Escape_analysis_assign::expression(Expression** pexpr)\n       }\n       break;\n \n+    case Expression::EXPRESSION_ARRAY_INDEX:\n+      {\n+        Array_index_expression* aie = (*pexpr)->array_index_expression();\n+        if (aie->end() != NULL && !aie->array()->type()->is_slice_type())\n+          {\n+            // Slicing an array.\n+            Expression* addr = Expression::make_unary(OPERATOR_AND, aie->array(),\n+                                                      aie->location());\n+            Node* addr_node = Node::make_node(addr);\n+            n->set_child(addr_node);\n+            this->context_->track(addr_node);\n+          }\n+      }\n+      break;\n+\n     default:\n       break;\n     }\n@@ -1587,6 +1815,17 @@ Escape_analysis_assign::call(Call_expression* call)\n \t}\n \n       this->context_->init_retvals(call_node, fntype);\n+\n+      // It could be a closure call that returns captured variable.\n+      // Model this by flowing the func expression to result.\n+      // See issue #14409.\n+      Node* fn_node = Node::make_node(call->fn());\n+      std::vector<Node*> retvals = call_node->state(this->context_, NULL)->retvals;\n+      for (std::vector<Node*>::const_iterator p = retvals.begin();\n+           p != retvals.end();\n+           ++p)\n+        this->assign_deref(*p, fn_node);\n+\n       return;\n     }\n \n@@ -1601,41 +1840,44 @@ Escape_analysis_assign::call(Call_expression* call)\n \n       Function* f = fn->named_object()->func_value();\n       const Bindings* callee_bindings = f->block()->bindings();\n-\n-      const Typed_identifier_list* results = fntype->results();\n+      Function::Results* results = f->result_variables();\n       if (results != NULL)\n \t{\n \t  // Setup output list on this call node.\n \t  Node::Escape_state* state = call_node->state(this->context_, NULL);\n-\t  for (Typed_identifier_list::const_iterator p1 = results->begin();\n+\t  for (Function::Results::const_iterator p1 = results->begin();\n \t       p1 != results->end();\n \t       ++p1)\n \t    {\n-\t      if (p1->name().empty() || Gogo::is_sink_name(p1->name()))\n-\t\tcontinue;\n-\n-\t      Named_object* result_no =\n-\t\tcallee_bindings->lookup_local(p1->name());\n-\t      go_assert(result_no != NULL);\n-\t      Node* result_node = Node::make_node(result_no);\n+\t      Node* result_node = Node::make_node(*p1);\n \t      state->retvals.push_back(result_node);\n \t    }\n \t}\n \n       std::vector<Node*>::iterator p = arg_nodes.begin();\n-      if (fntype->is_method()\n-\t  && fntype->receiver()->type()->has_pointer())\n+      if (fntype->is_method())\n \t{\n \t  std::string rcvr_name = fntype->receiver()->name();\n-\t  if (rcvr_name.empty() || Gogo::is_sink_name(rcvr_name))\n+\t  if (rcvr_name.empty() || Gogo::is_sink_name(rcvr_name)\n+              || !fntype->receiver()->type()->has_pointer())\n \t    ;\n \t  else\n \t    {\n \t      Named_object* rcvr_no =\n \t\tcallee_bindings->lookup_local(fntype->receiver()->name());\n \t      go_assert(rcvr_no != NULL);\n \t      Node* rcvr_node = Node::make_node(rcvr_no);\n-\t      this->assign(rcvr_node, *p);\n+              if (fntype->receiver()->type()->points_to() == NULL\n+                  && (*p)->expr()->type()->points_to() != NULL)\n+                // This is a call to a value method that has been lowered into a call\n+                // to a pointer method.  Gccgo generates a pointer method for all\n+                // method calls and takes the address of the value passed as the\n+                // receiver then immediately dereferences it within the function.\n+                // In this case, the receiver address does not escape; its content\n+                // flows to the call.\n+                this->assign_deref(rcvr_node, *p);\n+              else\n+                this->assign(rcvr_node, *p);\n \t    }\n \t  ++p;\n \t}\n@@ -1688,21 +1930,20 @@ Escape_analysis_assign::call(Call_expression* call)\n   // Receiver.\n   std::vector<Node*>::iterator p = arg_nodes.begin();\n   if (fntype->is_method()\n-      && fntype->receiver()->type()->has_pointer()\n       && p != arg_nodes.end())\n     {\n       // First argument to call will be the receiver.\n       std::string* note = fntype->receiver()->note();\n       if (fntype->receiver()->type()->points_to() == NULL\n-\t  && (*p)->expr()->unary_expression() != NULL\n-\t  && (*p)->expr()->unary_expression()->op() == OPERATOR_AND)\n-\t{\n-\t  // This is a call to a value method that has been lowered into a call\n-\t  // to a pointer method.  Gccgo generates a pointer method for all\n-\t  // method calls and takes the address of the value passed as the\n-\t  // receiver then immediately dereferences it within the function.\n-\t  // In this case, the receiver does not escape.\n-\t}\n+          && (*p)->expr()->type()->points_to() != NULL)\n+        // This is a call to a value method that has been lowered into a call\n+        // to a pointer method.  Gccgo generates a pointer method for all\n+        // method calls and takes the address of the value passed as the\n+        // receiver then immediately dereferences it within the function.\n+        // In this case, the receiver address does not escape; its content\n+        // flows to the call.\n+        this->assign_from_note(note, call_state->retvals,\n+                               this->context_->add_dereference(*p));\n       else\n \t{\n \t  if (!Type::are_identical(fntype->receiver()->type(),\n@@ -1732,18 +1973,19 @@ Escape_analysis_assign::call(Call_expression* call)\n \t      this->context_->track(*p);\n \t    }\n \n-\t  // TODO(cmang): Special care for varargs parameter?\n \t  Type* t = pn->type();\n \t  if (t != NULL\n \t      && t->has_pointer())\n \t    {\n \t      std::string* note = pn->note();\n \t      int enc = this->assign_from_note(note, call_state->retvals, *p);\n \t      if (enc == Node::ESCAPE_NONE\n-\t\t  && (call->is_deferred()\n-\t\t      || call->is_concurrent()))\n+\t\t  && !call->is_deferred()\n+\t\t  && !call->is_concurrent())\n \t\t{\n-\t\t  // TODO(cmang): Mark the argument as strictly non-escaping.\n+                  // TODO(cmang): Mark the argument as strictly non-escaping?\n+                  // In the gc compiler this is for limiting the lifetime of\n+                  // temporaries. We probably don't need this?\n \t\t}\n \t    }\n \t}\n@@ -1778,7 +2020,10 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t      src->ast_format(gogo).c_str(), src->details().c_str(),\n \t      src->op_format().c_str());\n \n-  if (dst->expr() != NULL)\n+  if (dst->is_indirect())\n+    // Lose track of the dereference.\n+    dst = this->context_->sink();\n+  else if (dst->expr() != NULL)\n     {\n       // Analyze the lhs of the assignment.\n       // Replace DST with this->context_->sink() if we can't track it.\n@@ -1845,19 +2090,32 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t  }\n \t  break;\n \n+        case Expression::EXPRESSION_TEMPORARY_REFERENCE:\n+          {\n+            // Temporary is tracked through the underlying Temporary_statement.\n+            Statement* t = dst->expr()->temporary_reference_expression()->statement();\n+            dst = Node::make_node(t);\n+          }\n+          break;\n+\n \tdefault:\n \t  // TODO(cmang): Add debugging info here: only a few expressions\n \t  // should leave DST unmodified.\n \t  break;\n         }\n     }\n \n-  if (src->expr() != NULL)\n+  if (src->object() != NULL)\n+    this->flows(dst, src);\n+  else if (src->is_indirect())\n+    this->flows(dst, src);\n+  else if (src->expr() != NULL)\n     {\n       Expression* e = src->expr();\n       switch (e->classification())\n         {\n \tcase Expression::EXPRESSION_VAR_REFERENCE:\n+        case Expression::EXPRESSION_ENCLOSED_VAR_REFERENCE:\n \t  // DST = var\n \tcase Expression::EXPRESSION_HEAP:\n \t  // DST = &T{...}.\n@@ -1872,6 +2130,8 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t  // DST = new(T).\n \tcase Expression::EXPRESSION_BOUND_METHOD:\n \t  // DST = x.M.\n+        case Expression::EXPRESSION_STRING_CONCAT:\n+          // DST = str1 + str2\n \t  this->flows(dst, src);\n \t  break;\n \n@@ -1883,73 +2143,34 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t  }\n \t  break;\n \n-\tcase Expression::EXPRESSION_ENCLOSED_VAR_REFERENCE:\n-\t  {\n-\t    Named_object* var = e->enclosed_var_expression()->variable();\n-\t    Node* var_node = Node::make_node(var);\n-\t    this->flows(dst, var_node);\n-\t  }\n-\t  break;\n-\n \tcase Expression::EXPRESSION_CALL:\n \t  {\n \t    Call_expression* call = e->call_expression();\n+            if (call->is_builtin())\n+              {\n+                Builtin_call_expression* bce = call->builtin_call_expression();\n+                if (bce->code() == Builtin_call_expression::BUILTIN_APPEND)\n+                  {\n+                    // Append returns the first argument.\n+                    // The subsequent arguments are already leaked because\n+                    // they are operands to append.\n+                    Node* appendee = Node::make_node(call->args()->front());\n+                    this->assign(dst, appendee);\n+                  }\n+                break;\n+              }\n \t    Func_expression* fe = call->fn()->func_expression();\n \t    if (fe != NULL && fe->is_runtime_function())\n \t      {\n \t\tswitch (fe->runtime_code())\n \t\t  {\n-\t\t  case Runtime::GROWSLICE:\n-\t\t    {\n-\t\t      // Append returns the first argument.\n-\t\t      // The subsequent arguments are already leaked because\n-\t\t      // they are operands to append.\n-\t\t      Node* appendee = Node::make_node(call->args()->front());\n-\t\t      this->assign(dst, appendee);\n-\t\t      break;\n-\t\t    }\n-\n \t\t  case Runtime::MAKECHAN:\n \t\t  case Runtime::MAKEMAP:\n \t\t  case Runtime::MAKESLICE:\n \t\t  case Runtime::MAKESLICE64:\n \t\t    // DST = make(...).\n-\t\t  case Runtime::SLICEBYTETOSTRING:\n-\t\t    // DST = string([]byte{...}).\n-\t\t  case Runtime::SLICERUNETOSTRING:\n-\t\t    // DST = string([]int{...}).\n-\t\t  case Runtime::STRINGTOSLICEBYTE:\n-\t\t    // DST = []byte(str).\n-\t\t  case Runtime::STRINGTOSLICERUNE:\n-\t\t    // DST = []rune(str).\n-\t\t  case Runtime::CONCATSTRINGS:\n-\t\t  case Runtime::CONCATSTRING2:\n-\t\t  case Runtime::CONCATSTRING3:\n-\t\t  case Runtime::CONCATSTRING4:\n-\t\t  case Runtime::CONCATSTRING5:\n-\t\t    // DST = str1 + str2\n-\t\t  case Runtime::CONSTRUCT_MAP:\n-\t\t    // When building a map literal's backend representation.\n-\t\t    // Likely never seen here and covered in\n-\t\t    // Expression::EXPRESSION_MAP_CONSTRUCTION.\n-\t\t  case Runtime::INTSTRING:\n-\t\t    // DST = string(i).\n-\t\t  case Runtime::IFACEE2E2:\n-\t\t  case Runtime::IFACEI2E2:\n-\t\t  case Runtime::IFACEE2I2:\n-\t\t  case Runtime::IFACEI2I2:\n-\t\t  case Runtime::IFACEE2T2P:\n-\t\t  case Runtime::IFACEI2T2P:\n-\t\t  case Runtime::IFACEE2T2:\n-\t\t  case Runtime::IFACEI2T2:\n-\t\t  case Runtime::REQUIREITAB:\n-\t\t    // All versions of interface conversion that might result\n-\t\t    // from a type assertion.  Some of these are the result of\n-\t\t    // a tuple type assertion statement and may not be covered\n-\t\t    // by the case in Expression::EXPRESSION_CONVERSION or\n-\t\t    // Expression::EXPRESSION_TYPE_GUARD.\n-\t\t    this->flows(dst, src);\n-\t\t    break;\n+                    this->flows(dst, src);\n+                    break;\n \n \t\t  default:\n \t\t    break;\n@@ -1969,28 +2190,85 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t\tbreak;\n \t      }\n \n-\t    // TODO(cmang): Handle case from issue 4529.\n-\t    // Node* call_node = Node::make_node(e);\n-\t    // Node::Escape_state* call_state = call_node->state(this->context_, NULL);\n-\t    // std::vector<Node*> retvals = call_state->retvals;\n-\t    // for (std::vector<Node*>::const_iterator p = retvals.begin();\n-\t    //\t    p != retvals.end();\n-\t    //\t    ++p)\n-\t    //\t this->flows(dst, *p);\n+            // Result flows to dst.\n+            Node* call_node = Node::make_node(e);\n+            Node::Escape_state* call_state = call_node->state(this->context_, NULL);\n+            std::vector<Node*> retvals = call_state->retvals;\n+            for (std::vector<Node*>::const_iterator p = retvals.begin();\n+                 p != retvals.end();\n+                 ++p)\n+              this->flows(dst, *p);\n \t  }\n \t  break;\n \n+        case Expression::EXPRESSION_CALL_RESULT:\n+          {\n+            Call_result_expression* cre = e->call_result_expression();\n+            Call_expression* call = cre->call()->call_expression();\n+            if (call->is_builtin())\n+              break;\n+            if (call->fn()->func_expression() != NULL\n+                && call->fn()->func_expression()->is_runtime_function())\n+              {\n+                switch (call->fn()->func_expression()->runtime_code())\n+                  {\n+                  case Runtime::IFACEE2E2:\n+                  case Runtime::IFACEI2E2:\n+                  case Runtime::IFACEE2I2:\n+                  case Runtime::IFACEI2I2:\n+                  case Runtime::IFACEE2T2P:\n+                  case Runtime::IFACEI2T2P:\n+                    {\n+                      // x, ok = v.(T), where T is a pointer or interface,\n+                      // is lowered to\n+                      // x, ok = IFACEI2E2(v), or\n+                      // x, ok = IFACEI2I2(type, v)\n+                      // The last arg flows to the first result.\n+                      // Note: IFACEX2T2 has different signature, handled by\n+                      // ::expression.\n+                      if (cre->index() != 0)\n+                        break;\n+                      Node* arg_node = Node::make_node(call->args()->back());\n+                      this->assign(dst, arg_node);\n+                    }\n+                    break;\n+\n+                  default:\n+                    break;\n+                  }\n+                break;\n+              }\n+\n+            Node* call_node = Node::make_node(call);\n+            Node* ret_node = call_node->state(context_, NULL)->retvals[cre->index()];\n+            this->assign(dst, ret_node);\n+          }\n+          break;\n+\n \tcase Expression::EXPRESSION_FUNC_REFERENCE:\n \t  if (e->func_expression()->closure() != NULL)\n-\t    {\n-\t      // If SRC is a reference to a function closure, DST flows into\n-\t      // the underyling closure variable.\n-\t      Expression* closure = e->func_expression()->closure();\n-\t      Node* closure_node = Node::make_node(closure);\n-\t      this->flows(dst, closure_node);\n-\t    }\n+            this->flows(dst, src);\n \t  break;\n \n+        case Expression::EXPRESSION_CONVERSION:\n+          {\n+            Type_conversion_expression* tce = e->conversion_expression();\n+            Type* ft = tce->expr()->type();\n+            Type* tt = tce->type();\n+            if ((ft->is_string_type() && tt->is_slice_type())\n+                || (ft->is_slice_type() && tt->is_string_type())\n+                || (ft->integer_type() != NULL && tt->is_string_type()))\n+              {\n+                // string([]byte), string([]rune), []byte(string), []rune(string), string(rune)\n+                this->flows(dst, src);\n+                break;\n+              }\n+            // Conversion preserves input value.\n+            Expression* underlying = tce->expr();\n+            this->assign(dst, Node::make_node(underlying));\n+          }\n+          break;\n+\n \tcase Expression::EXPRESSION_FIELD_REFERENCE:\n \t  {\n \t    // A non-pointer can't escape from a struct.\n@@ -1999,7 +2277,6 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t  }\n \t  // Fall through.\n \n-\tcase Expression::EXPRESSION_CONVERSION:\n \tcase Expression::EXPRESSION_TYPE_GUARD:\n \tcase Expression::EXPRESSION_ARRAY_INDEX:\n \tcase Expression::EXPRESSION_STRING_INDEX:\n@@ -2016,15 +2293,23 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t\t    break;\n \t\t  }\n \t      }\n-\t    else if (e->conversion_expression() != NULL)\n-\t      left = e->conversion_expression()->expr();\n \t    else if (e->type_guard_expression() != NULL)\n \t      left = e->type_guard_expression()->expr();\n \t    else if (e->array_index_expression() != NULL)\n \t      {\n \t\tArray_index_expression* aie = e->array_index_expression();\n-\t\tif (e->type()->is_slice_type())\n-\t\t  left = aie->array();\n+\t\tif (aie->end() != NULL)\n+                  // slicing\n+                  if (aie->array()->type()->is_slice_type())\n+                    left = aie->array();\n+                  else\n+                    {\n+                      // slicing an array\n+                      // The gc compiler has an implicit address operator.\n+                      go_assert(src->child() != NULL);\n+                      this->assign(dst, src->child());\n+                      break;\n+                    }\n \t\telse if (!aie->array()->type()->is_slice_type())\n \t\t  {\n \t\t    // Indexing an array preserves the input value.\n@@ -2041,15 +2326,9 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t    else if (e->string_index_expression() != NULL)\n \t      {\n \t\tString_index_expression* sie = e->string_index_expression();\n-\t\tif (e->type()->is_slice_type())\n+\t\tif (e->type()->is_string_type())\n+                  // slicing\n \t\t  left = sie->string();\n-\t\telse if (!sie->string()->type()->is_slice_type())\n-\t\t  {\n-\t\t    // Indexing a string preserves the input value.\n-\t\t    Node* string_node = Node::make_node(sie->string());\n-\t\t    this->assign(dst, string_node);\n-\t\t    break;\n-\t\t  }\n \t\telse\n \t\t  {\n \t\t    this->flows(dst, src);\n@@ -2072,6 +2351,7 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t      case OPERATOR_PLUS:\n \t      case OPERATOR_MINUS:\n \t      case OPERATOR_XOR:\n+              case OPERATOR_OR:\n \t      case OPERATOR_MULT:\n \t      case OPERATOR_DIV:\n \t      case OPERATOR_MOD:\n@@ -2123,13 +2403,7 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \tcase Expression::EXPRESSION_TEMPORARY_REFERENCE:\n \t  {\n \t    Statement* temp = e->temporary_reference_expression()->statement();\n-\t    if (temp != NULL\n-\t\t&& temp->temporary_statement()->init() != NULL)\n-\t      {\n-\t\tExpression* init = temp->temporary_statement()->init();\n-\t\tNode* init_node = Node::make_node(init);\n-\t\tthis->assign(dst, init_node);\n-\t      }\n+            this->assign(dst, Node::make_node(temp));\n \t  }\n \t  break;\n \n@@ -2139,6 +2413,8 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t  break;\n \t}\n     }\n+  else if (src->statement() != NULL && src->statement()->temporary_statement() != NULL)\n+    this->flows(dst, src);\n }\n \n // Model the assignment of DST to an indirection of SRC.\n@@ -2161,36 +2437,6 @@ Escape_analysis_assign::assign_deref(Node* dst, Node* src)\n \t  // or numeric constants.\n \t  return;\n \n-\tcase Expression::EXPRESSION_FIXED_ARRAY_CONSTRUCTION:\n-\tcase Expression::EXPRESSION_SLICE_CONSTRUCTION:\n-\tcase Expression::EXPRESSION_STRUCT_CONSTRUCTION:\n-\t  {\n-\t    // Dereferencing an array, slice, or struct is like accessing each\n-\t    // of its values.  In this situation, we model the flow from src to\n-\t    // dst where src is one of the above as a flow from each of src's\n-\t    // values to dst.\n-\t    Expression* e = src->expr();\n-\t    Expression_list* vals = NULL;\n-\t    if (e->slice_literal() != NULL)\n-\t      vals = e->slice_literal()->vals();\n-\t    else if (e->array_literal() != NULL)\n-\t      vals = e->array_literal()->vals();\n-\t    else\n-\t      vals = e->struct_literal()->vals();\n-\n-\t    if (vals != NULL)\n-\t      {\n-\t\tfor (Expression_list::const_iterator p = vals->begin();\n-\t\t     p != vals->end();\n-\t\t     ++p)\n-\t\t  {\n-\t\t    if ((*p) != NULL)\n-\t\t      this->assign(dst, Node::make_node(*p));\n-\t\t  }\n-\t      }\n-\t  }\n-\t  return;\n-\n \tdefault:\n \t  break;\n         }\n@@ -2229,7 +2475,8 @@ Escape_analysis_assign::assign_from_note(std::string* note,\n     }\n \n   if (this->context_->gogo()->debug_escape_level() > 2)\n-    go_inform(src->location(), \"assignfromtag:: src=  em=%s\",\n+    go_inform(src->location(), \"assignfromtag:: src=%s em=%s\",\n+              src->ast_format(context_->gogo()).c_str(),\n \t      Escape_note::make_tag(enc).c_str());\n \n   if (enc == Node::ESCAPE_UNKNOWN)\n@@ -2282,8 +2529,7 @@ void\n Escape_analysis_assign::flows(Node* dst, Node* src)\n {\n   // Don't bother capturing the flow from scalars.\n-  if (src->expr() != NULL\n-      && !src->expr()->type()->has_pointer())\n+  if (src->type() != NULL && !src->type()->has_pointer())\n     return;\n \n   // Don't confuse a blank identifier with the sink.\n@@ -2294,8 +2540,7 @@ Escape_analysis_assign::flows(Node* dst, Node* src)\n   Node::Escape_state* src_state = src->state(this->context_, NULL);\n   if (dst == src\n       || dst_state == src_state\n-      || dst_state->flows.find(src) != dst_state->flows.end()\n-      || src_state->flows.find(dst) != src_state->flows.end())\n+      || dst_state->flows.find(src) != dst_state->flows.end())\n     return;\n \n   Gogo* gogo = this->context_->gogo();\n@@ -2331,6 +2576,7 @@ Gogo::assign_connectivity(Escape_context* context, Named_object* fn)\n \t{\n \t  Node* res_node = Node::make_node(*p);\n \t  Node::Escape_state* res_state = res_node->state(context, fn);\n+          res_state->fn = fn;\n \t  res_state->loop_depth = 0;\n \n \t  // If this set of functions is recursive, we lose track of the return values.\n@@ -2359,6 +2605,7 @@ Gogo::assign_connectivity(Escape_context* context, Named_object* fn)\n       go_assert(param_no != NULL);\n       Node* param_node = Node::make_node(param_no);\n       Node::Escape_state* param_state = param_node->state(context, fn);\n+      param_state->fn = fn;\n       param_state->loop_depth = 1;\n \n       if (!p->type()->has_pointer())\n@@ -2493,10 +2740,12 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n   else\n     dst_no = dst->object();\n   bool dst_is_result = dst_no != NULL && dst_no->is_result_variable();\n+  Node::Escape_state* dst_state = dst->state(this->context_, NULL);\n \n   if (src_is_param\n       && dst_is_result\n-      && (src->encoding() & ESCAPE_MASK) < int(Node::ESCAPE_SCOPE)\n+      && src_state->fn == dst_state->fn\n+      && (src->encoding() & ESCAPE_MASK) < int(Node::ESCAPE_HEAP)\n       && dst->encoding() != Node::ESCAPE_HEAP)\n     {\n       // This case handles:\n@@ -2547,7 +2796,7 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n   // escape from struct.\n   if (src_is_param\n       && dst->encoding() == Node::ESCAPE_HEAP\n-      && (src->encoding() & ESCAPE_MASK) < int(Node::ESCAPE_SCOPE)\n+      && (src->encoding() & ESCAPE_MASK) < int(Node::ESCAPE_HEAP)\n       && level.value() > 0)\n     {\n       int enc =\n@@ -2561,16 +2810,17 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \n   // A src object leaks if its value or address is assigned to a dst object\n   // in a different scope (at a different loop depth).\n-  Node::Escape_state* dst_state = dst->state(this->context_, NULL);\n   bool src_leaks = (level.value() <= 0\n \t\t    && level.suffix_value() <= 0\n \t\t    && dst_state->loop_depth < mod_loop_depth);\n+  src_leaks = src_leaks || (level.value() <= 0\n+              && (dst->encoding() & ESCAPE_MASK) == Node::ESCAPE_HEAP);\n   // old src encoding, used to prevent duplicate error messages\n   int osrcesc = src->encoding();\n \n   if (src_is_param\n       && (src_leaks || dst_state->loop_depth < 0)\n-      && (src->encoding() & ESCAPE_MASK) < int(Node::ESCAPE_SCOPE))\n+      && (src->encoding() & ESCAPE_MASK) < int(Node::ESCAPE_HEAP))\n     {\n       if (level.suffix_value() > 0)\n \t{\n@@ -2587,7 +2837,7 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t  if (debug_level != 0)\n \t    go_inform(src->definition_location(), \"leaking param: %s\",\n                       src->ast_format(gogo).c_str());\n-\t  src->set_encoding(Node::ESCAPE_SCOPE);\n+\t  src->set_encoding(Node::ESCAPE_HEAP);\n \t}\n     }\n   else if (src->expr() != NULL)\n@@ -2623,7 +2873,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t      src->set_encoding(Node::ESCAPE_HEAP);\n \t      if (debug_level != 0 && osrcesc != src->encoding())\n \t\t{\n-                  if (underlying->var_expression() != NULL)\n+                  if (underlying->var_expression() != NULL\n+                      || underlying->enclosed_var_expression() != NULL)\n                     go_inform(underlying_node->definition_location(),\n                               \"moved to heap: %s\",\n                               underlying_node->ast_format(gogo).c_str());\n@@ -2675,66 +2926,56 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n       else if (e->call_expression() != NULL)\n \t{\n \t  Call_expression* call = e->call_expression();\n-\t  if (call->fn()->func_expression() != NULL)\n-\t    {\n-\t      Func_expression* func = call->fn()->func_expression();\n-\t      if (func->is_runtime_function())\n-\t\t{\n-\t\t  switch (func->runtime_code())\n-\t\t    {\n-\t\t    case Runtime::GROWSLICE:\n-\t\t      {\n-\t\t\t// Propagate escape information to appendee.\n-\t\t\tExpression* appendee = call->args()->front();\n-\t\t\tthis->flood(level, dst, Node::make_node(appendee), -1);\n-\t\t      }\n-\t\t      break;\n-\n-\t\t    case Runtime::MAKECHAN:\n-\t\t    case Runtime::MAKEMAP:\n-\t\t    case Runtime::MAKESLICE:\n-\t\t    case Runtime::MAKESLICE64:\n-\t\t    case Runtime::SLICEBYTETOSTRING:\n-\t\t    case Runtime::SLICERUNETOSTRING:\n-\t\t    case Runtime::STRINGTOSLICEBYTE:\n-\t\t    case Runtime::STRINGTOSLICERUNE:\n-\t\t    case Runtime::CONCATSTRINGS:\n-\t\t    case Runtime::CONCATSTRING2:\n-\t\t    case Runtime::CONCATSTRING3:\n-\t\t    case Runtime::CONCATSTRING4:\n-\t\t    case Runtime::CONCATSTRING5:\n-\t\t    case Runtime::CONSTRUCT_MAP:\n-\t\t    case Runtime::INTSTRING:\n-\t\t    case Runtime::REQUIREITAB:\n-\t\t      // All runtime calls that involve allocation of memory\n-\t\t      // except new.  Runtime::NEW gets lowered into an\n-\t\t      // allocation expression.\n-\t\t      if (src_leaks)\n-\t\t\t{\n-\t\t\t  src->set_encoding(Node::ESCAPE_HEAP);\n-\t\t\t  if (debug_level != 0 && osrcesc != src->encoding())\n-\t\t\t    go_inform(src->location(), \"%s escapes to heap\",\n-\t\t\t\t      src->ast_format(gogo).c_str());\n-\t\t\t  extra_loop_depth = mod_loop_depth;\n-\t\t\t}\n-\t\t      break;\n-\n-\t\t    default:\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      else if (src_leaks\n-\t\t       && (func->closure() != NULL\n-\t\t\t   || func->bound_method_expression() != NULL))\n-\t\t{\n-\t\t  // A closure or bound method; we lost track of actual function\n-\t\t  // so if this leaks, this call must be done on the heap.\n-\t\t  src->set_encoding(Node::ESCAPE_HEAP);\n-\t\t  if (debug_level != 0)\n-\t\t    go_inform(src->location(), \"%s escapes to heap\",\n-\t\t\t      src->ast_format(gogo).c_str());\n-\t\t}\n-\t    }\n+          if (call->is_builtin())\n+            {\n+              Builtin_call_expression* bce = call->builtin_call_expression();\n+              if (bce->code() == Builtin_call_expression::BUILTIN_APPEND)\n+                {\n+                  // Propagate escape information to appendee.\n+                  Expression* appendee = call->args()->front();\n+                  this->flood(level, dst, Node::make_node(appendee), -1);\n+                }\n+            }\n+          else if (call->fn()->func_expression() != NULL\n+                   && call->fn()->func_expression()->is_runtime_function())\n+            {\n+              switch (call->fn()->func_expression()->runtime_code())\n+                {\n+                case Runtime::MAKECHAN:\n+                case Runtime::MAKEMAP:\n+                case Runtime::MAKESLICE:\n+                case Runtime::MAKESLICE64:\n+                  if (src_leaks)\n+                    {\n+                      src->set_encoding(Node::ESCAPE_HEAP);\n+                      if (debug_level != 0 && osrcesc != src->encoding())\n+                        go_inform(src->location(), \"%s escapes to heap\",\n+                                  src->ast_format(gogo).c_str());\n+                      extra_loop_depth = mod_loop_depth;\n+                    }\n+                  break;\n+\n+                default:\n+                  break;\n+                }\n+            }\n+          else if (src_state->retvals.size() > 0)\n+            {\n+              // In this case a link went directly to a call, but should really go\n+              // to the dummy .outN outputs that were created for the call that\n+              // themselves link to the inputs with levels adjusted.\n+              // See e.g. #10466.\n+              // This can only happen with functions returning a single result.\n+              go_assert(src_state->retvals.size() == 1);\n+              if (debug_level > 2)\n+                go_inform(src->location(), \"[%d] dst %s escwalk replace src: %s with %s\",\n+                          this->context_->loop_depth(),\n+                          dst->ast_format(gogo).c_str(),\n+                          src->ast_format(gogo).c_str(),\n+                          src_state->retvals[0]->ast_format(gogo).c_str());\n+              src = src_state->retvals[0];\n+              src_state = src->state(this->context_, NULL);\n+            }\n \t}\n       else if (e->allocation_expression() != NULL && src_leaks)\n \t{\n@@ -2743,14 +2984,64 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t  if (debug_level != 0 && osrcesc != src->encoding())\n \t    go_inform(src->location(), \"%s escapes to heap\",\n                       src->ast_format(gogo).c_str());\n+          extra_loop_depth = mod_loop_depth;\n \t}\n+      else if ((e->map_literal() != NULL\n+               || e->string_concat_expression() != NULL\n+               || (e->func_expression() != NULL && e->func_expression()->closure() != NULL)\n+               || e->bound_method_expression() != NULL)\n+               && src_leaks)\n+        {\n+          src->set_encoding(Node::ESCAPE_HEAP);\n+          if (debug_level != 0 && osrcesc != src->encoding())\n+            go_inform(src->location(), \"%s escapes to heap\",\n+                      src->ast_format(gogo).c_str());\n+          extra_loop_depth = mod_loop_depth;\n+        }\n+      else if (e->conversion_expression() != NULL && src_leaks)\n+        {\n+          Type_conversion_expression* tce = e->conversion_expression();\n+          Type* ft = tce->expr()->type();\n+          Type* tt = tce->type();\n+          if ((ft->is_string_type() && tt->is_slice_type())\n+              || (ft->is_slice_type() && tt->is_string_type())\n+              || (ft->integer_type() != NULL && tt->is_string_type()))\n+            {\n+              // string([]byte), string([]rune), []byte(string), []rune(string), string(rune)\n+              src->set_encoding(Node::ESCAPE_HEAP);\n+              if (debug_level != 0 && osrcesc != src->encoding())\n+                go_inform(src->location(), \"%s escapes to heap\",\n+                          src->ast_format(gogo).c_str());\n+              extra_loop_depth = mod_loop_depth;\n+            }\n+        }\n+      else if (e->array_index_expression() != NULL\n+               && !e->array_index_expression()->array()->type()->is_slice_type())\n+        {\n+          Array_index_expression* aie = e->array_index_expression();\n+          if (aie->end() != NULL)\n+            {\n+              // Slicing an array.\n+              // Flow its implicit address-of node to DST.\n+              this->flood(level, dst, src->child(), -1);\n+            }\n+          else\n+            {\n+              // Indexing an array.\n+              // An array element flowing to DST behaves like the array\n+              // flowing to DST.\n+              Expression* underlying = e->array_index_expression()->array();\n+              Node* underlying_node = Node::make_node(underlying);\n+              this->flood(level, dst, underlying_node, -1);\n+            }\n+        }\n       else if ((e->field_reference_expression() != NULL\n \t\t&& e->field_reference_expression()->expr()->unary_expression() == NULL)\n \t       || e->type_guard_expression() != NULL\n \t       || (e->array_index_expression() != NULL\n-\t\t   && e->type()->is_slice_type())\n+\t\t   && e->array_index_expression()->end() != NULL)\n \t       || (e->string_index_expression() != NULL\n-\t\t   && e->type()->is_slice_type()))\n+\t\t   && e->type()->is_string_type()))\n \t{\n \t  Expression* underlying;\n \t  if (e->field_reference_expression() != NULL)\n@@ -2779,14 +3070,7 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t      underlying = underlying->unary_expression()->operand();\n \t    }\n \t  else if (e->array_index_expression() != NULL)\n-\t    {\n-\t      underlying = e->array_index_expression()->array();\n-\t      if (!underlying->type()->is_slice_type())\n-\t\t{\n-\t\t  Node* underlying_node = Node::make_node(underlying);\n-\t\t  this->flood(level, dst, underlying_node, 1);\n-\t\t}\n-\t    }\n+\t    underlying = e->array_index_expression()->array();\n \t  else if (e->map_index_expression() != NULL)\n \t    underlying = e->map_index_expression()->map();\n \t  else\n@@ -2796,9 +3080,15 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t  Node* underlying_node = Node::make_node(underlying);\n \t  this->flood(level.increase(), dst, underlying_node, -1);\n \t}\n-\n-      // TODO(cmang): Add case for Issue #10466.\n+      else if (e->temporary_reference_expression() != NULL)\n+        {\n+          Statement* t = e->temporary_reference_expression()->statement();\n+          this->flood(level, dst, Node::make_node(t), -1);\n+        }\n     }\n+  else if (src->is_indirect())\n+    // Increase the level for a dereference.\n+    this->flood(level.increase(), dst, src->child(), -1);\n \n   level = level.copy();\n   for (std::set<Node*>::const_iterator p = src_state->flows.begin();\n@@ -2815,6 +3105,13 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n void\n Gogo::propagate_escape(Escape_context* context, Node* dst)\n {\n+  if (dst->object() == NULL\n+      && (dst->expr() == NULL\n+          || (dst->expr()->var_expression() == NULL\n+              && dst->expr()->enclosed_var_expression() == NULL\n+              && dst->expr()->func_expression() == NULL)))\n+    return;\n+\n   Node::Escape_state* state = dst->state(context, NULL);\n   Gogo* gogo = context->gogo();\n   if (gogo->debug_escape_level() > 1)\n@@ -2854,13 +3151,31 @@ Escape_analysis_tag::tag(Named_object* fn)\n {\n   // External functions are assumed unsafe\n   // unless //go:noescape is given before the declaration.\n-  if (fn->package() != NULL || !fn->is_function())\n+  if (fn->package() != NULL)\n+    return;\n+\n+  if (fn->is_function_declaration())\n     {\n-      // TODO(cmang): Implement //go:noescape directive for external functions;\n-      // mark input parameters as not escaping.\n-      return;\n+      Function_declaration* fdcl = fn->func_declaration_value();\n+      if ((fdcl->pragmas() & GOPRAGMA_NOESCAPE) != 0)\n+        {\n+          Function_type* fntype = fdcl->type();\n+          if (fntype->parameters() != NULL)\n+            {\n+              const Typed_identifier_list* til = fntype->parameters();\n+              int i = 0;\n+              for (Typed_identifier_list::const_iterator p = til->begin();\n+                   p != til->end();\n+                   ++p, ++i)\n+                if (p->type()->has_pointer())\n+                  fntype->add_parameter_note(i, Node::ESCAPE_NONE);\n+            }\n+        }\n     }\n \n+  if (!fn->is_function())\n+    return;\n+\n   Function_type* fntype = fn->func_value()->type();\n   Bindings* bindings = fn->func_value()->block()->bindings();\n \n@@ -2881,7 +3196,6 @@ Escape_analysis_tag::tag(Named_object* fn)\n \t  break;\n \n \tcase Node::ESCAPE_HEAP: // flooded, moved to heap.\n-\tcase Node::ESCAPE_SCOPE: // flooded, value leaves scope.\n \t  break;\n \n \tdefault:\n@@ -2898,7 +3212,12 @@ Escape_analysis_tag::tag(Named_object* fn)\n \t   ++p, ++i)\n \t{\n \t  if (p->name().empty() || Gogo::is_sink_name(p->name()))\n-\t    continue;\n+            {\n+              // Parameter not used in the function body, does not escape.\n+              if (p->type()->has_pointer())\n+                fntype->add_parameter_note(i, Node::ESCAPE_NONE);\n+              continue;\n+            }\n \n \t  Named_object* param_no = bindings->lookup(p->name());\n \t  go_assert(param_no != NULL);\n@@ -2913,7 +3232,6 @@ Escape_analysis_tag::tag(Named_object* fn)\n \t      break;\n \n \t    case Node::ESCAPE_HEAP: // flooded, moved to heap.\n-\t    case Node::ESCAPE_SCOPE: // flooded, value leaves scope.\n \t      break;\n \n \t    default:"}, {"sha": "ac72b19a2a361707615df57e199a38b30483c41a", "filename": "gcc/go/gofrontend/escape.h", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fescape.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fescape.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.h?ref=bb14e19c2be54dd10f40d705364e08524ec8310c", "patch": "@@ -51,7 +51,7 @@ class Level\n   suffix_value() const\n   { return this->suffix_value_; }\n \n-  // Increase the level because a node is referenced.\n+  // Increase the level because a node is dereferenced.\n   Level\n   increase() const\n   {\n@@ -61,7 +61,7 @@ class Level\n     return Level(this->value_ + 1, this->suffix_value_ + 1);\n   }\n \n-  // Decrease the level because a node is dereferenced.\n+  // Decrease the level because a node is referenced.\n   Level\n   decrease() const\n   {\n@@ -104,9 +104,9 @@ class Level\n   }\n \n private:\n-  // The sum of all indirects (-1) and references (+1) applied to a Node.\n+  // The sum of all references (-1) and indirects (+1) applied to a Node.\n   int value_;\n-  // The sum of all indirects (-1) abd references (+1) applied to a copied Node.\n+  // The sum of all references (-1) abd indirects (+1) applied to a copied Node.\n   int suffix_value_;\n };\n \n@@ -123,7 +123,10 @@ class Node\n     {\n       NODE_OBJECT,\n       NODE_EXPRESSION,\n-      NODE_STATEMENT\n+      NODE_STATEMENT,\n+      // A \"fake\" node that models the indirection of its child node.\n+      // This node does not correspond to an AST node.\n+      NODE_INDIRECT\n     };\n \n   // The state necessary to keep track of how a node escapes.\n@@ -161,11 +164,6 @@ class Node\n     ESCAPE_NONE,\n     // Is returned or reachable from a return statement.\n     ESCAPE_RETURN,\n-    // Allocated in an inner loop, assigned to an outer loop,\n-    // which allows construction of non-escaping but arbitrarily large linked\n-    // data structures (i.e., not eligible for allocation in a fixed-size stack\n-    // stack frame).\n-    ESCAPE_SCOPE,\n     // Reachable from the heap.\n     ESCAPE_HEAP,\n     // By construction will not escape.\n@@ -174,17 +172,25 @@ class Node\n \n   // Multiple constructors for each classification.\n   Node(Named_object* no)\n-    : classification_(NODE_OBJECT), state_(NULL), encoding_(ESCAPE_UNKNOWN)\n+    : classification_(NODE_OBJECT), state_(NULL), encoding_(ESCAPE_UNKNOWN),\n+      child_(NULL)\n   { this->u_.object_val = no; }\n \n   Node(Expression* e)\n-    : classification_(NODE_EXPRESSION), state_(NULL), encoding_(ESCAPE_UNKNOWN)\n+    : classification_(NODE_EXPRESSION), state_(NULL), encoding_(ESCAPE_UNKNOWN),\n+      child_(NULL)\n   { this->u_.expression_val = e; }\n \n   Node(Statement* s)\n-    : classification_(NODE_STATEMENT), state_(NULL), encoding_(ESCAPE_UNKNOWN)\n+    : classification_(NODE_STATEMENT), state_(NULL), encoding_(ESCAPE_UNKNOWN),\n+      child_(NULL)\n   { this->u_.statement_val = s; }\n \n+  Node(Node *n)\n+    : classification_(NODE_INDIRECT), state_(NULL), encoding_(ESCAPE_UNKNOWN),\n+      child_(n)\n+  {}\n+\n   // Return this node's type.\n   Type*\n   type() const;\n@@ -203,7 +209,7 @@ class Node\n \n   // Return this node's detailed format string.\n   std::string\n-  details() const;\n+  details();\n \n   std::string\n   op_format() const;\n@@ -214,8 +220,7 @@ class Node\n \n   // Return this node's escape encoding.\n   int\n-  encoding() const\n-  { return this->encoding_; }\n+  encoding();\n \n   // Set the node's escape encoding.\n   void\n@@ -252,6 +257,22 @@ class Node\n             : NULL);\n   }\n \n+  bool\n+  is_indirect() const\n+  { return this->classification_ == NODE_INDIRECT; }\n+\n+  // Return its child node.\n+  // Child node is used only in indirect node, and in expression node\n+  // representing slicing an array.\n+  Node*\n+  child() const\n+  { return this->child_; }\n+\n+  // Set the child node.\n+  void\n+  set_child(Node* n)\n+  { this->child_ = n; }\n+\n   // Static creation methods for each value supported in the union.\n   static Node*\n   make_node(Named_object*);\n@@ -262,6 +283,9 @@ class Node\n   static Node*\n   make_node(Statement*);\n \n+  static Node*\n+  make_indirect_node(Node*);\n+\n   // Return the maximum of an existing escape encoding E and a new\n   // escape type.\n   static int\n@@ -294,6 +318,10 @@ class Node\n   // | Escapement_encoding: ESCAPE_BITS |\n   int encoding_;\n \n+  // Child node, used only in indirect node, and expression node representing\n+  // slicing an array.\n+  Node* child_;\n+\n   // Cache all the Nodes created via Node::make_node to make the API simpler.\n   static std::map<Named_object*, Node*> objects;\n   static std::map<Expression*, Node*> expressions;"}, {"sha": "8ae1013a6a9d5dcfbbef4c554adf3b19342ebed1", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=bb14e19c2be54dd10f40d705364e08524ec8310c", "patch": "@@ -7113,114 +7113,6 @@ Expression::make_bound_method(Expression* expr, const Method* method,\n // Class Builtin_call_expression.  This is used for a call to a\n // builtin function.\n \n-class Builtin_call_expression : public Call_expression\n-{\n- public:\n-  Builtin_call_expression(Gogo* gogo, Expression* fn, Expression_list* args,\n-\t\t\t  bool is_varargs, Location location);\n-\n- protected:\n-  // This overrides Call_expression::do_lower.\n-  Expression*\n-  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n-\n-  Expression*\n-  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n-\n-  bool\n-  do_is_constant() const;\n-\n-  bool\n-  do_numeric_constant_value(Numeric_constant*) const;\n-\n-  bool\n-  do_discarding_value();\n-\n-  Type*\n-  do_type();\n-\n-  void\n-  do_determine_type(const Type_context*);\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  Expression*\n-  do_copy();\n-\n-  Bexpression*\n-  do_get_backend(Translate_context*);\n-\n-  void\n-  do_export(Export*) const;\n-\n-  virtual bool\n-  do_is_recover_call() const;\n-\n-  virtual void\n-  do_set_recover_arg(Expression*);\n-\n- private:\n-  // The builtin functions.\n-  enum Builtin_function_code\n-    {\n-      BUILTIN_INVALID,\n-\n-      // Predeclared builtin functions.\n-      BUILTIN_APPEND,\n-      BUILTIN_CAP,\n-      BUILTIN_CLOSE,\n-      BUILTIN_COMPLEX,\n-      BUILTIN_COPY,\n-      BUILTIN_DELETE,\n-      BUILTIN_IMAG,\n-      BUILTIN_LEN,\n-      BUILTIN_MAKE,\n-      BUILTIN_NEW,\n-      BUILTIN_PANIC,\n-      BUILTIN_PRINT,\n-      BUILTIN_PRINTLN,\n-      BUILTIN_REAL,\n-      BUILTIN_RECOVER,\n-\n-      // Builtin functions from the unsafe package.\n-      BUILTIN_ALIGNOF,\n-      BUILTIN_OFFSETOF,\n-      BUILTIN_SIZEOF\n-    };\n-\n-  Expression*\n-  one_arg() const;\n-\n-  bool\n-  check_one_arg();\n-\n-  static Type*\n-  real_imag_type(Type*);\n-\n-  static Type*\n-  complex_type(Type*);\n-\n-  Expression*\n-  lower_make(Statement_inserter*);\n-\n-  Expression* flatten_append(Gogo*, Named_object*, Statement_inserter*);\n-\n-  bool\n-  check_int_value(Expression*, bool is_length, bool* small);\n-\n-  // A pointer back to the general IR structure.  This avoids a global\n-  // variable, or passing it around everywhere.\n-  Gogo* gogo_;\n-  // The builtin function being called.\n-  Builtin_function_code code_;\n-  // Used to stop endless loops when the length of an array uses len\n-  // or cap of the array itself.\n-  mutable bool seen_;\n-  // Whether the argument is set for calls to BUILTIN_RECOVER.\n-  bool recover_arg_is_set_;\n-};\n-\n Builtin_call_expression::Builtin_call_expression(Gogo* gogo,\n \t\t\t\t\t\t Expression* fn,\n \t\t\t\t\t\t Expression_list* args,"}, {"sha": "a4f655828a53c54b7650e36894fe2c340fddaf5e", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=bb14e19c2be54dd10f40d705364e08524ec8310c", "patch": "@@ -39,6 +39,7 @@ class Unary_expression;\n class Binary_expression;\n class String_concat_expression;\n class Call_expression;\n+class Builtin_call_expression;\n class Call_result_expression;\n class Func_expression;\n class Func_descriptor_expression;\n@@ -2246,6 +2247,15 @@ class Call_expression : public Expression\n   set_is_multi_value_arg()\n   { this->is_multi_value_arg_ = true; }\n \n+  // Whether this is a call to builtin function.\n+  virtual bool\n+  is_builtin()\n+  { return false; }\n+\n+  // Convert to a Builtin_call_expression, or return NULL.\n+  inline Builtin_call_expression*\n+  builtin_call_expression();\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -2351,6 +2361,133 @@ class Call_expression : public Expression\n   bool is_flattened_;\n };\n \n+// A call expression to a builtin function.\n+\n+class Builtin_call_expression : public Call_expression\n+{\n+ public:\n+  Builtin_call_expression(Gogo* gogo, Expression* fn, Expression_list* args,\n+\t\t\t  bool is_varargs, Location location);\n+\n+  // The builtin functions.\n+  enum Builtin_function_code\n+    {\n+      BUILTIN_INVALID,\n+\n+      // Predeclared builtin functions.\n+      BUILTIN_APPEND,\n+      BUILTIN_CAP,\n+      BUILTIN_CLOSE,\n+      BUILTIN_COMPLEX,\n+      BUILTIN_COPY,\n+      BUILTIN_DELETE,\n+      BUILTIN_IMAG,\n+      BUILTIN_LEN,\n+      BUILTIN_MAKE,\n+      BUILTIN_NEW,\n+      BUILTIN_PANIC,\n+      BUILTIN_PRINT,\n+      BUILTIN_PRINTLN,\n+      BUILTIN_REAL,\n+      BUILTIN_RECOVER,\n+\n+      // Builtin functions from the unsafe package.\n+      BUILTIN_ALIGNOF,\n+      BUILTIN_OFFSETOF,\n+      BUILTIN_SIZEOF\n+    };\n+\n+  Builtin_function_code\n+  code()\n+  { return this->code_; }\n+\n+  // This overrides Call_expression::is_builtin.\n+  bool\n+  is_builtin()\n+  { return true; }\n+\n+ protected:\n+  // This overrides Call_expression::do_lower.\n+  Expression*\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n+\n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n+  bool\n+  do_is_constant() const;\n+\n+  bool\n+  do_numeric_constant_value(Numeric_constant*) const;\n+\n+  bool\n+  do_discarding_value();\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy();\n+\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n+\n+  void\n+  do_export(Export*) const;\n+\n+  virtual bool\n+  do_is_recover_call() const;\n+\n+  virtual void\n+  do_set_recover_arg(Expression*);\n+\n+ private:\n+  Expression*\n+  one_arg() const;\n+\n+  bool\n+  check_one_arg();\n+\n+  static Type*\n+  real_imag_type(Type*);\n+\n+  static Type*\n+  complex_type(Type*);\n+\n+  Expression*\n+  lower_make(Statement_inserter*);\n+\n+  Expression* flatten_append(Gogo*, Named_object*, Statement_inserter*);\n+\n+  bool\n+  check_int_value(Expression*, bool is_length, bool* small);\n+\n+  // A pointer back to the general IR structure.  This avoids a global\n+  // variable, or passing it around everywhere.\n+  Gogo* gogo_;\n+  // The builtin function being called.\n+  Builtin_function_code code_;\n+  // Used to stop endless loops when the length of an array uses len\n+  // or cap of the array itself.\n+  mutable bool seen_;\n+  // Whether the argument is set for calls to BUILTIN_RECOVER.\n+  bool recover_arg_is_set_;\n+};\n+\n+inline Builtin_call_expression*\n+Call_expression::builtin_call_expression()\n+{\n+  return (this->is_builtin()\n+          ? static_cast<Builtin_call_expression*>(this)\n+          : NULL);\n+}\n+\n // A single result from a call which returns multiple results.\n \n class Call_result_expression : public Expression"}, {"sha": "58d873230ea6bb0a852a7d0ab7a2dcaaa3478403", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=bb14e19c2be54dd10f40d705364e08524ec8310c", "patch": "@@ -1577,6 +1577,11 @@ class Function_declaration\n   set_asm_name(const std::string& asm_name)\n   { this->asm_name_ = asm_name; }\n \n+  // Return the pragmas for this function.\n+  unsigned int\n+  pragmas() const\n+  { return this->pragmas_; }\n+\n   // Set the pragmas for this function.\n   void\n   set_pragmas(unsigned int pragmas)"}, {"sha": "bb30cc15aad029d3e848e78cbbe0e129f3c74609", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb14e19c2be54dd10f40d705364e08524ec8310c/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=bb14e19c2be54dd10f40d705364e08524ec8310c", "patch": "@@ -438,26 +438,18 @@ Runtime::name_to_code(const std::string& name)\n {\n   Function code = Runtime::NUMBER_OF_FUNCTIONS;\n \n-  // Aliases seen in function declaration code.\n-  // TODO(cmang): Add other aliases.\n-  if (name == \"new\")\n-    code = Runtime::NEW;\n-  else if (name == \"close\")\n-    code = Runtime::CLOSE;\n-  else if (name == \"copy\")\n-    code = Runtime::SLICECOPY;\n-  else if (name == \"append\")\n-    code = Runtime::GROWSLICE;\n-  else if (name == \"delete\")\n-    code = Runtime::MAPDELETE;\n-  else\n+  // Look through the known names for a match.\n+  for (size_t i = 0; i < Runtime::NUMBER_OF_FUNCTIONS; i++)\n     {\n-      // Look through the known names for a match.\n-      for (size_t i = 0; i < Runtime::NUMBER_OF_FUNCTIONS; i++)\n-\t{\n-\t  if (strcmp(runtime_functions[i].name, name.c_str()) == 0)\n-\t    code = static_cast<Runtime::Function>(i);\n-\t}\n+      const char* runtime_function_name = runtime_functions[i].name;\n+      if (strcmp(runtime_function_name, name.c_str()) == 0)\n+        code = static_cast<Runtime::Function>(i);\n+      // The names in the table have \"runtime.\" prefix. We may be\n+      // called with a name without the prefix. Try matching\n+      // without the prefix as well.\n+      if (strncmp(runtime_function_name, \"runtime.\", 8) == 0\n+          && strcmp(runtime_function_name + 8, name.c_str()) == 0)\n+        code = static_cast<Runtime::Function>(i);\n     }\n   return code;\n }"}]}