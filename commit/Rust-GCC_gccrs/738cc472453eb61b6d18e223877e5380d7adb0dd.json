{"sha": "738cc472453eb61b6d18e223877e5380d7adb0dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM4Y2M0NzI0NTNlYjYxYjZkMThlMjIzODc3ZTUzODBkN2FkYjBkZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-10-17T09:31:36Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-17T09:31:36Z"}, "message": "Makefile.in (print-rtl.o): Depend on TREE_H.\n\n\t* Makefile.in (print-rtl.o): Depend on TREE_H.\n\t* alias.c (get_alias_set): Make two passes over objects to first\n\tsee if inner object is access via restricted pointer.\n\tDefer allocating alias set for restricted pointer until here.\n\tCall find_placeholder with second arg nonzero.\n\tMinor cleanups.\n\t* emit-rtl.c (set_mem_attributes): Set more attributes.\n\t(set_mem_align, change_address, adjust_address_1): New functions.\n\t(change_address_1): Now static.\n\t(adjust_address, adjust_address_nv): Deleted.\n\t(replace_equiv_address): Call change_address_1.\n\t* expr.c (get_inner_reference): Handle PLACEHOLDER_EXPR.\n\t(find_placeholder): Get starting point from PLIST arg.\n\t(expand_expr, case PLACEHOLDER_EXPR): Initialize find_placeholder arg.\n\t* expr.h (set_mem_align, change_address, adjust_address_1): New decls.\n\t(adjust_address, adjust_address_nv): New macros.\n\t* print-rtl.c (tree.h): New include.\n\t(print_rtx, case MEM): Print all memory attributes.\n\nFrom-SVN: r46313", "tree": {"sha": "3f3a09b804dc2ad899529714f44003c6933712ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f3a09b804dc2ad899529714f44003c6933712ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/738cc472453eb61b6d18e223877e5380d7adb0dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/738cc472453eb61b6d18e223877e5380d7adb0dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/738cc472453eb61b6d18e223877e5380d7adb0dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/738cc472453eb61b6d18e223877e5380d7adb0dd/comments", "author": null, "committer": null, "parents": [{"sha": "4d8f669f9481e4154eea13098cb6def6b64bcb1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d8f669f9481e4154eea13098cb6def6b64bcb1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d8f669f9481e4154eea13098cb6def6b64bcb1f"}], "stats": {"total": 377, "additions": 260, "deletions": 117}, "files": [{"sha": "751e583ae397c991f6626a1e9c80047a2eb0cacc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=738cc472453eb61b6d18e223877e5380d7adb0dd", "patch": "@@ -1,3 +1,24 @@\n+Wed Oct 17 05:26:39 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Makefile.in (print-rtl.o): Depend on TREE_H.\n+\t* alias.c (get_alias_set): Make two passes over objects to first\n+\tsee if inner object is access via restricted pointer.\n+\tDefer allocating alias set for restricted pointer until here.\n+\tCall find_placeholder with second arg nonzero.\n+\tMinor cleanups.\n+\t* emit-rtl.c (set_mem_attributes): Set more attributes.\n+\t(set_mem_align, change_address, adjust_address_1): New functions.\n+\t(change_address_1): Now static.\n+\t(adjust_address, adjust_address_nv): Deleted.\n+\t(replace_equiv_address): Call change_address_1.\n+\t* expr.c (get_inner_reference): Handle PLACEHOLDER_EXPR.\n+\t(find_placeholder): Get starting point from PLIST arg.\n+\t(expand_expr, case PLACEHOLDER_EXPR): Initialize find_placeholder arg.\n+\t* expr.h (set_mem_align, change_address, adjust_address_1): New decls.\n+\t(adjust_address, adjust_address_nv): New macros.\n+\t* print-rtl.c (tree.h): New include.\n+\t(print_rtx, case MEM): Print all memory attributes.\n+\n 2001-10-17  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (direct_call_operand): Don't fall off end."}, {"sha": "27a3111b1133cc6878e5ce8ee4e5115cbd838ae7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=738cc472453eb61b6d18e223877e5380d7adb0dd", "patch": "@@ -1381,8 +1381,8 @@ rtl-error.o: rtl-error.c system.h $(RTL_H) $(INSN_ATTR_H) insn-config.h \\\n rtl.o : rtl.c $(GCONFIG_H) $(SYSTEM_H) $(RTL_H) real.h $(GGC_H) errors.h\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n-print-rtl.o : print-rtl.c $(GCONFIG_H) $(SYSTEM_H) $(RTL_H) hard-reg-set.h \\\n-    $(BASIC_BLOCK_H)\n+print-rtl.o : print-rtl.c $(GCONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n+    hard-reg-set.h $(BASIC_BLOCK_H)\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) toplev.h $(RTL_H) hard-reg-set.h"}, {"sha": "af0141f8cb3dd2d2115c31a943441c5cc3475fd2", "filename": "gcc/alias.c", "status": "modified", "additions": 75, "deletions": 40, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=738cc472453eb61b6d18e223877e5380d7adb0dd", "patch": "@@ -99,7 +99,7 @@ static int can_address_p\t\tPARAMS ((tree));\n static rtx find_base_value\t\tPARAMS ((rtx));\n static int mems_in_disjoint_alias_sets_p PARAMS ((rtx, rtx));\n static int insert_subset_children       PARAMS ((splay_tree_node, void*));\n-static tree find_base_decl            PARAMS ((tree));\n+static tree find_base_decl\t\tPARAMS ((tree));\n static alias_set_entry get_alias_set_entry PARAMS ((HOST_WIDE_INT));\n static rtx fixed_scalar_and_varying_struct_p PARAMS ((rtx, rtx, rtx, rtx,\n \t\t\t\t\t\t      int (*) (rtx, int)));\n@@ -458,7 +458,6 @@ HOST_WIDE_INT\n get_alias_set (t)\n      tree t;\n {\n-  tree orig_t;\n   HOST_WIDE_INT set;\n \n   /* If we're not doing any alias analysis, just assume everything\n@@ -473,14 +472,76 @@ get_alias_set (t)\n      language-specific routine may make mutually-recursive calls to each other\n      to figure out what to do.  At each juncture, we see if this is a tree\n      that the language may need to handle specially.  First handle things that\n-     aren't types and start by removing nops since we care only about the\n-     actual object.  Also replace PLACEHOLDER_EXPRs and pick up the outermost\n-     object that we could have a pointer to.  */\n+     aren't types.  */\n   if (! TYPE_P (t))\n     {\n-      /* Remove any NOPs and see what any PLACEHOLD_EXPRs will expand to.  */\n+      tree inner = t;\n+      tree placeholder_ptr = 0;\n+\n+      /* First see if the actual object referenced is an INDIRECT_REF from a\n+\t restrict-qualified pointer or a \"void *\".  Start by removing nops\n+\t since we care only about the actual object.  Also replace\n+\t PLACEHOLDER_EXPRs.  */\n+      while (((TREE_CODE (inner) == NOP_EXPR\n+\t       || TREE_CODE (inner) == CONVERT_EXPR)\n+\t      && (TYPE_MODE (TREE_TYPE (inner))\n+\t\t  == TYPE_MODE (TREE_TYPE (TREE_OPERAND (inner, 0)))))\n+\t     || TREE_CODE (inner) == NON_LVALUE_EXPR\n+\t     || TREE_CODE (inner) == PLACEHOLDER_EXPR\n+\t     || handled_component_p (inner))\n+\t{\n+\t  if (TREE_CODE (inner) == PLACEHOLDER_EXPR)\n+\t    inner = find_placeholder (inner, &placeholder_ptr);\n+\t  else\n+\t    inner = TREE_OPERAND (inner, 0);\n+\t}\n+\n+      /* Check for accesses through restrict-qualified pointers.  */\n+      if (TREE_CODE (inner) == INDIRECT_REF)\n+\t{\n+\t  tree decl = find_base_decl (TREE_OPERAND (inner, 0));\n+\n+\t  if (decl && DECL_POINTER_ALIAS_SET_KNOWN_P (decl))\n+\t    {\n+\t      /* If we haven't computed the actual alias set, do it now. */\n+\t      if (DECL_POINTER_ALIAS_SET (decl) == -2)\n+\t\t{\n+\t\t  /* No two restricted pointers can point at the same thing.\n+\t\t     However, a restricted pointer can point at the same thing\n+\t\t     as an unrestricted pointer, if that unrestricted pointer\n+\t\t     is based on the restricted pointer.  So, we make the\n+\t\t     alias set for the restricted pointer a subset of the\n+\t\t     alias set for the type pointed to by the type of the\n+\t\t     decl.  */\n+\t\t  HOST_WIDE_INT pointed_to_alias_set\n+\t\t    = get_alias_set (TREE_TYPE (TREE_TYPE (decl)));\n+\n+\t\t  if (pointed_to_alias_set == 0)\n+\t\t    /* It's not legal to make a subset of alias set zero.  */\n+\t\t    ;\n+\t\t  else\n+\t\t    {\n+\t\t      DECL_POINTER_ALIAS_SET (decl) = new_alias_set ();\n+\t\t      record_alias_subset  (pointed_to_alias_set,\n+\t\t\t\t\t    DECL_POINTER_ALIAS_SET (decl));\n+\t\t    }\n+\t\t}\n+\n+\t      /* We use the alias set indicated in the declaration.  */\n+\t      return DECL_POINTER_ALIAS_SET (decl);\n+\t    }\n+\n+\t  /* If we have an INDIRECT_REF via a void pointer, we don't\n+\t     know anything about what that might alias.  */\n+\t  else if (TREE_CODE (TREE_TYPE (inner)) == VOID_TYPE)\n+\t    return 0;\n+\t}\n+\n+      /* Otherwise, pick up the outermost object that we could have a pointer\n+\t to, processing conversion and PLACEHOLDER_EXPR as above.  */\n+      placeholder_ptr = 0;\n       while (((TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR)\n-\t      && (TYPE_MODE (TREE_TYPE (t))\n+ \t      && (TYPE_MODE (TREE_TYPE (t))\n \t\t  == TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 0)))))\n \t     || TREE_CODE (t) == NON_LVALUE_EXPR\n \t     || TREE_CODE (t) == PLACEHOLDER_EXPR\n@@ -492,61 +553,35 @@ get_alias_set (t)\n \t    return set;\n \n \t  if (TREE_CODE (t) == PLACEHOLDER_EXPR)\n-\t    t = find_placeholder (t, 0);\n+\t    t = find_placeholder (t, &placeholder_ptr);\n \t  else\n \t    t = TREE_OPERAND (t, 0);\n \t}\n \n-      /* Now give the language a chance to do something but record what we\n-\t gave it this time.  */\n-      orig_t = t;\n+      /* Give the language another chance to do something.  */\n       if ((set = lang_get_alias_set (t)) != -1)\n \treturn set;\n \n-      /* Check for accesses through restrict-qualified pointers.  */\n-      if (TREE_CODE (t) == INDIRECT_REF)\n-\t{\n-\t  tree decl = find_base_decl (TREE_OPERAND (t, 0));\n-\n-\t  if (decl && DECL_POINTER_ALIAS_SET_KNOWN_P (decl))\n-\t    /* We use the alias set indicated in the declaration.  */\n-\t    return DECL_POINTER_ALIAS_SET (decl);\n-\n-\t  /* If we have an INDIRECT_REF via a void pointer, we don't\n-\t     know anything about what that might alias.  */\n-\t  if (TREE_CODE (TREE_TYPE (t)) == VOID_TYPE)\n-\t    return 0;\n-\t}\n-\n-      /* If we've already determined the alias set for this decl, just\n-\t return it.  This is necessary for C++ anonymous unions, whose\n-\t component variables don't look like union members (boo!).  */\n+      /* If we've already determined the alias set for a decl, just return\n+\t it.  This is necessary for C++ anonymous unions, whose component\n+\t variables don't look like union members (boo!).  */\n       if (TREE_CODE (t) == VAR_DECL\n \t  && DECL_RTL_SET_P (t) && GET_CODE (DECL_RTL (t)) == MEM)\n \treturn MEM_ALIAS_SET (DECL_RTL (t));\n \n-      /* Give the language another chance to do something special.  */\n-      if (orig_t != t\n-\t  && (set = lang_get_alias_set (t)) != -1)\n-\treturn set;\n-\n       /* Now all we care about is the type.  */\n       t = TREE_TYPE (t);\n     }\n \n   /* Variant qualifiers don't affect the alias set, so get the main\n      variant. If this is a type with a known alias set, return it.  */\n   t = TYPE_MAIN_VARIANT (t);\n-  if (TYPE_P (t) && TYPE_ALIAS_SET_KNOWN_P (t))\n+  if (TYPE_ALIAS_SET_KNOWN_P (t))\n     return TYPE_ALIAS_SET (t);\n \n   /* See if the language has special handling for this type.  */\n   if ((set = lang_get_alias_set (t)) != -1)\n-    {\n-      /* If the alias set is now known, we are done.  */\n-      if (TYPE_ALIAS_SET_KNOWN_P (t))\n-\treturn TYPE_ALIAS_SET (t);\n-    }\n+    return set;\n \n   /* There are no objects of FUNCTION_TYPE, so there's no point in\n      using up an alias set for them.  (There are, of course, pointers"}, {"sha": "50819c6840ca79f82e72da0f0f228b23b5baaad1", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 102, "deletions": 55, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=738cc472453eb61b6d18e223877e5380d7adb0dd", "patch": "@@ -178,6 +178,8 @@ static rtx make_jump_insn_raw\t\tPARAMS ((rtx));\n static rtx make_call_insn_raw\t\tPARAMS ((rtx));\n static rtx find_line_note\t\tPARAMS ((rtx));\n static void mark_sequence_stack         PARAMS ((struct sequence_stack *));\n+static rtx change_address_1\t\tPARAMS ((rtx, enum machine_mode, rtx,\n+\t\t\t\t\t\t int));\n static void unshare_all_rtl_1\t\tPARAMS ((rtx));\n static void unshare_all_decls\t\tPARAMS ((tree));\n static void reset_used_decls\t\tPARAMS ((tree));\n@@ -1652,23 +1654,22 @@ set_mem_attributes (ref, t, objectp)\n \n   type = TYPE_P (t) ? t : TREE_TYPE (t);\n \n-  /* Get the alias set from the expression or type (perhaps using a\n-     front-end routine) and then copy bits from the type.  */\n-\n-  /* It is incorrect to set RTX_UNCHANGING_P from TREE_READONLY (type)\n-     here, because, in C and C++, the fact that a location is accessed\n-     through a const expression does not mean that the value there can\n-     never change.  */\n-\n   /* If we have already set DECL_RTL = ref, get_alias_set will get the\n      wrong answer, as it assumes that DECL_RTL already has the right alias\n      info.  Callers should not set DECL_RTL until after the call to\n      set_mem_attributes.  */\n   if (DECL_P (t) && ref == DECL_RTL_IF_SET (t))\n     abort ();\n \n+  /* Get the alias set from the expression or type (perhaps using a\n+     front-end routine).  */\n   set_mem_alias_set (ref, get_alias_set (t));\n \n+  /* It is incorrect to set RTX_UNCHANGING_P from TREE_READONLY (type)\n+     here, because, in C and C++, the fact that a location is accessed\n+     through a const expression does not mean that the value there can\n+     never change.  */\n+\n   MEM_VOLATILE_P (ref) = TYPE_VOLATILE (type);\n   MEM_IN_STRUCT_P (ref) = AGGREGATE_TYPE_P (type);\n \n@@ -1677,7 +1678,14 @@ set_mem_attributes (ref, t, objectp)\n   if (objectp && ! AGGREGATE_TYPE_P (type))\n     MEM_SCALAR_P (ref) = 1;\n \n-  /* If T is a type, this is all we can do.  Otherwise, we may be able\n+  /* If the size is known, we can set that.  */\n+  if (TYPE_SIZE_UNIT (type) && host_integerp (TYPE_SIZE_UNIT (type), 1))\n+    MEM_ATTRS (ref)\n+      = get_mem_attrs (MEM_ALIAS_SET (ref), MEM_DECL (ref), MEM_OFFSET (ref),\n+\t\t       GEN_INT (tree_low_cst (TYPE_SIZE_UNIT (type), 1)),\n+\t\t       MEM_ALIGN (ref));\n+\n+  /* If T is a type, there's nothing more we can do.  Otherwise, we may be able\n      to deduce some more information about the expression.  */\n   if (TYPE_P (t))\n     return;\n@@ -1686,17 +1694,27 @@ set_mem_attributes (ref, t, objectp)\n   if (TREE_THIS_VOLATILE (t))\n     MEM_VOLATILE_P (ref) = 1;\n \n-  /* Now see if we can say more about whether it's an aggregate or\n-     scalar.  If we already know it's an aggregate, don't bother.  */\n-  if (MEM_IN_STRUCT_P (ref))\n-    return;\n-\n   /* Now remove any NOPs: they don't change what the underlying object is.\n      Likewise for SAVE_EXPR.  */\n   while (TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR\n \t || TREE_CODE (t) == NON_LVALUE_EXPR || TREE_CODE (t) == SAVE_EXPR)\n     t = TREE_OPERAND (t, 0);\n \n+  /* If this is a decl, set the attributes of the MEM from it.  */\n+  if (DECL_P (t))\n+    MEM_ATTRS (ref)\n+      = get_mem_attrs\n+\t(MEM_ALIAS_SET (ref), t, GEN_INT (0),\n+\t (TYPE_SIZE_UNIT (TREE_TYPE (t))\n+\t  && host_integerp (TYPE_SIZE_UNIT (TREE_TYPE (t)), 1))\n+\t ? GEN_INT (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (t)), 1))\n+\t : 0, DECL_ALIGN (t) / BITS_PER_UNIT);\n+\n+  /* Now see if we can say more about whether it's an aggregate or\n+     scalar.  If we already know it's an aggregate, don't bother.  */\n+  if (MEM_IN_STRUCT_P (ref))\n+    return;\n+\n   /* Since we already know the type isn't an aggregate, if this is a decl,\n      it must be a scalar.  Or if it is a reference into an aggregate,\n      this is part of an aggregate.   Otherwise we don't know.  */\n@@ -1715,7 +1733,6 @@ set_mem_alias_set (mem, set)\n      rtx mem;\n      HOST_WIDE_INT set;\n {\n-  /* It would be nice to enable this check, but we can't quite yet.  */\n #ifdef ENABLE_CHECKING\t\n   /* If the new and old alias sets don't conflict, something is wrong.  */\n   if (!alias_sets_conflict_p (set, MEM_ALIAS_SET (mem)))\n@@ -1725,15 +1742,25 @@ set_mem_alias_set (mem, set)\n   MEM_ATTRS (mem) = get_mem_attrs (set, MEM_DECL (mem), MEM_OFFSET (mem),\n \t\t\t\t   MEM_SIZE (mem), MEM_ALIGN (mem));\n }\n+\n+/* Set the alignment of MEM to ALIGN.  */\n+\n+void\n+set_mem_align (mem, align)\n+     rtx mem;\n+     unsigned int align;\n+{\n+  MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_DECL (mem),\n+\t\t\t\t   MEM_OFFSET (mem), MEM_SIZE (mem), align);\n+}\n \f\n-/* Return a memory reference like MEMREF, but with its mode changed\n-   to MODE and its address changed to ADDR.\n-   (VOIDmode means don't change the mode.\n-   NULL for ADDR means don't change the address.)\n-   VALIDATE is nonzero if the returned memory location is required to be\n-   valid.  */\n+/* Return a memory reference like MEMREF, but with its mode changed to MODE\n+   and its address changed to ADDR.  (VOIDmode means don't change the mode.\n+   NULL for ADDR means don't change the address.)  VALIDATE is nonzero if the\n+   returned memory location is required to be valid.  The memory\n+   attributes are not changed.  */\n \n-rtx\n+static rtx\n change_address_1 (memref, mode, addr, validate)\n      rtx memref;\n      enum machine_mode mode;\n@@ -1768,60 +1795,81 @@ change_address_1 (memref, mode, addr, validate)\n   return new;\n }\n \n-/* Return a memory reference like MEMREF, but with its mode changed\n-   to MODE and its address offset by OFFSET bytes.  */\n+/* Like change_address_1 with VALIDATE nonzero, but we are not saying in what\n+   way we are changing MEMREF, so we only preserve the alias set.  */\n \n rtx\n-adjust_address (memref, mode, offset)\n+change_address (memref, mode, addr)\n      rtx memref;\n      enum machine_mode mode;\n-     HOST_WIDE_INT offset;\n+     rtx addr;\n {\n-  /* For now, this is just a wrapper for change_address, but eventually\n-     will do memref tracking.  */\n-  rtx addr = XEXP (memref, 0);\n-\n-  /* ??? Prefer to create garbage instead of creating shared rtl.  */\n-  addr = copy_rtx (addr);\n+  rtx new = change_address_1 (memref, mode, addr, 1);\n+  enum machine_mode mmode = GET_MODE (new);\n \n-  /* If MEMREF is a LO_SUM and the offset is within the alignment of the\n-     object, we can merge it into the LO_SUM.  */\n-  if (GET_MODE (memref) != BLKmode && GET_CODE (addr) == LO_SUM\n-      && offset >= 0\n-      && (unsigned HOST_WIDE_INT) offset\n-         < GET_MODE_ALIGNMENT (GET_MODE (memref)) / BITS_PER_UNIT)\n-    addr = gen_rtx_LO_SUM (Pmode, XEXP (addr, 0),\n-\t\t\t   plus_constant (XEXP (addr, 1), offset));\n-  else\n-    addr = plus_constant (addr, offset);\n+  MEM_ATTRS (new)\n+    = get_mem_attrs (MEM_ALIAS_SET (memref), 0, 0,\n+\t\t     mmode == BLKmode ? 0 : GEN_INT (GET_MODE_SIZE (mmode)),\n+\t\t     (mmode == BLKmode ? 1\n+\t\t      : GET_MODE_ALIGNMENT (mmode) / BITS_PER_UNIT));\n \n-  return change_address (memref, mode, addr);\n+  return new;\n }\n \n-/* Likewise, but the reference is not required to be valid.  */\n+/* Return a memory reference like MEMREF, but with its mode changed\n+   to MODE and its address offset by OFFSET bytes.  If VALIDATE is\n+   nonzero, the memory address is forced to be valid.  */\n \n rtx\n-adjust_address_nv (memref, mode, offset)\n+adjust_address_1 (memref, mode, offset, validate)\n      rtx memref;\n      enum machine_mode mode;\n      HOST_WIDE_INT offset;\n+     int validate;\n {\n-  /* For now, this is just a wrapper for change_address, but eventually\n-     will do memref tracking.  */\n   rtx addr = XEXP (memref, 0);\n+  rtx new;\n+  rtx memoffset = MEM_OFFSET (memref);\n+  unsigned int memalign = MEM_ALIGN (memref);\n \n-  /* If MEMREF is a LO_SUM and the offset is within the size of the\n+  /* If MEMREF is a LO_SUM and the offset is within the alignment of the\n      object, we can merge it into the LO_SUM.  */\n   if (GET_MODE (memref) != BLKmode && GET_CODE (addr) == LO_SUM\n       && offset >= 0\n       && (unsigned HOST_WIDE_INT) offset\n          < GET_MODE_ALIGNMENT (GET_MODE (memref)) / BITS_PER_UNIT)\n-    addr = gen_rtx_LO_SUM (mode, XEXP (addr, 0),\n+    addr = gen_rtx_LO_SUM (Pmode, XEXP (addr, 0),\n \t\t\t   plus_constant (XEXP (addr, 1), offset));\n+  else if (offset == 0)\n+    /* ??? Prefer to create garbage instead of creating shared rtl.  */\n+    addr = copy_rtx (addr);\n   else\n     addr = plus_constant (addr, offset);\n \n-  return change_address_1 (memref, mode, addr, 0);\n+  new = change_address_1 (memref, mode, addr, validate);\n+\n+  /* Compute the new values of the memory attributes due to this adjustment.\n+     We add the offsets and update the alignment.  */\n+  if (memoffset)\n+    memoffset = GEN_INT (offset + INTVAL (memoffset));\n+\n+  /* If the offset is negative, don't try to update the alignment.  If it's\n+     zero, the alignment hasn't changed.  Otherwise, the known alignment may\n+     be less strict.  */\n+  if (offset < 0)\n+    memalign = 1;\n+\n+  while (offset > 0 && (offset % memalign) != 0)\n+    memalign >>= 1;\n+\n+  MEM_ATTRS (new)\n+    = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_DECL (memref), memoffset,\n+\t\t     mode == BLKmode\n+\t\t     ? 0 : GEN_INT (GET_MODE_SIZE (mode)), memalign);\n+\n+  /* At some point, we should validate that this offset is within the object,\n+     if all the appropriate values are known.  */\n+  return new;\n }\n \n /* Return a memory reference like MEMREF, but with its address changed to\n@@ -1834,19 +1882,18 @@ replace_equiv_address (memref, addr)\n      rtx memref;\n      rtx addr;\n {\n-  /* For now, this is just a wrapper for change_address, but eventually\n-     will do memref tracking.  */\n-  return change_address (memref, VOIDmode, addr);\n+  /* change_address_1 copies the memory attribute structure without change\n+     and that's exactly what we want here.  */\n+  return change_address_1 (memref, VOIDmode, addr, 1);\n }\n+\n /* Likewise, but the reference is not required to be valid.  */\n \n rtx\n replace_equiv_address_nv (memref, addr)\n      rtx memref;\n      rtx addr;\n {\n-  /* For now, this is just a wrapper for change_address, but eventually\n-     will do memref tracking.  */\n   return change_address_1 (memref, VOIDmode, addr, 0);\n }\n \f"}, {"sha": "e06d4b10974659f9060703608d6f912c9d1408b7", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=738cc472453eb61b6d18e223877e5380d7adb0dd", "patch": "@@ -5403,6 +5403,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n   tree offset = size_zero_node;\n   tree bit_offset = bitsize_zero_node;\n   unsigned int alignment = BIGGEST_ALIGNMENT;\n+  tree placeholder_ptr = 0;\n   tree tem;\n \n   /* First get the mode, signedness, and size.  We do this from just the\n@@ -5500,6 +5501,11 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t\t\t\t\t   unit_size));\n \t}\n \n+      else if (TREE_CODE (exp) == PLACEHOLDER_EXPR)\n+\t{\n+\t  exp = find_placeholder (exp, &placeholder_ptr);\n+\t  continue;\n+\t}\n       else if (TREE_CODE (exp) != NON_LVALUE_EXPR\n \t       && ! ((TREE_CODE (exp) == NOP_EXPR\n \t\t      || TREE_CODE (exp) == CONVERT_EXPR)\n@@ -5961,10 +5967,11 @@ check_max_integer_computation_mode (exp)\n \f\n /* Return an object on the placeholder list that matches EXP, a\n    PLACEHOLDER_EXPR.  An object \"matches\" if it is of the type of the\n-   PLACEHOLDER_EXPR or a pointer type to it.  For further information,\n-   see tree.def.  If no such object is found, abort.  If PLIST is nonzero,\n-   it is a location into which a pointer into the placeholder list at\n-   which the object is found is placed.  */\n+   PLACEHOLDER_EXPR or a pointer type to it.  For further information, see\n+   tree.def.  If no such object is found, abort.  If PLIST is nonzero, it is\n+   a location which initially points to a starting location in the\n+   placeholder list (zero means start of the list) and where a pointer into\n+   the placeholder list at which the object is found is placed.  */\n \n tree\n find_placeholder (exp, plist)\n@@ -5974,7 +5981,9 @@ find_placeholder (exp, plist)\n   tree type = TREE_TYPE (exp);\n   tree placeholder_expr;\n \n-  for (placeholder_expr = placeholder_list; placeholder_expr != 0;\n+  for (placeholder_expr\n+       = plist && *plist ? TREE_CHAIN (*plist) : placeholder_list;\n+       placeholder_expr != 0;\n        placeholder_expr = TREE_CHAIN (placeholder_expr))\n     {\n       tree need_type = TYPE_MAIN_VARIANT (type);\n@@ -6550,7 +6559,7 @@ expand_expr (exp, target, tmode, modifier)\n     case PLACEHOLDER_EXPR:\n       {\n \ttree old_list = placeholder_list;\n-\ttree placeholder_expr;\n+\ttree placeholder_expr = 0;\n \n \texp = find_placeholder (exp, &placeholder_expr);\n \tplaceholder_list = TREE_CHAIN (placeholder_expr);"}, {"sha": "af79fd581bee1cbc4d676a1afe2e9c88fdea572a", "filename": "gcc/expr.h", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=738cc472453eb61b6d18e223877e5380d7adb0dd", "patch": "@@ -500,10 +500,11 @@ extern rtx force_operand PARAMS ((rtx, rtx));\n \n /* Return an object on the placeholder list that matches EXP, a\n    PLACEHOLDER_EXPR.  An object \"matches\" if it is of the type of the\n-   PLACEHOLDER_EXPR or a pointer type to it.  For further information,\n-   see tree.def.  If no such object is found, abort.  If PLIST is nonzero,\n-   it is a location into which a pointer into the placeholder list at\n-   which the object is found is placed.  */\n+   PLACEHOLDER_EXPR or a pointer type to it.  For further information, see\n+   tree.def.  If no such object is found, abort.  If PLIST is nonzero, it is\n+   a location which initially points to a starting location in the\n+   placeholder list (zero means start of the list) and where a pointer into\n+   the placeholder list at which the object is found is placed.  */\n extern tree find_placeholder PARAMS ((tree, tree *));\n \n /* Generate code for computing expression EXP.\n@@ -611,23 +612,26 @@ extern rtx memory_address_noforce PARAMS ((enum machine_mode, rtx));\n /* Set the alias set of MEM to SET.  */\n extern void set_mem_alias_set PARAMS ((rtx, HOST_WIDE_INT));\n \n+/* Set the alignment of MEM to ALIGN.  */\n+extern void set_mem_align PARAMS ((rtx, unsigned int));\n+\n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR.\n    (VOIDmode means don't change the mode.\n-   NULL for ADDR means don't change the address.)\n-   VALIDATE is nonzero if the returned memory location is required to be\n-   valid.  */\n-extern rtx change_address_1 PARAMS ((rtx, enum machine_mode, rtx, int));\n-\n-#define change_address(MEMREF, MODE, ADDR) \\\n-  change_address_1 (MEMREF, MODE, ADDR, 1)\n+   NULL for ADDR means don't change the address.)  */\n+extern rtx change_address PARAMS ((rtx, enum machine_mode, rtx));\n \n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address offset by OFFSET bytes.  */\n-extern rtx adjust_address PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT));\n+#define adjust_address(MEMREF, MODE, OFFSET) \\\n+  adjust_address_1 (MEMREF, MODE, OFFSET, 1)\n \n /* Likewise, but the reference is not required to be valid.  */\n-extern rtx adjust_address_nv PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT));\n+#define adjust_address_nv(MEMREF, MODE, OFFSET) \\\n+  adjust_address_1 (MEMREF, MODE, OFFSET, 0)\n+\n+extern rtx adjust_address_1 PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT,\n+\t\t\t\t     int));\n \n /* Return a memory reference like MEMREF, but with its address changed to\n    ADDR.  The caller is asserting that the actual piece of memory pointed"}, {"sha": "3d78dd392f0391aa945b9ecddf6715e1fca91e85", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/738cc472453eb61b6d18e223877e5380d7adb0dd/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=738cc472453eb61b6d18e223877e5380d7adb0dd", "patch": "@@ -23,6 +23,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"config.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n+\n+/* We don't want the tree code checking code for the access to the\n+   DECL_NAME to be included in the gen* programs.  */\n+#undef ENABLE_TREE_CHECKING\n+#include \"tree.h\"\n #include \"real.h\"\n #include \"flags.h\"\n #include \"hard-reg-set.h\"\n@@ -446,8 +451,30 @@ print_rtx (in_rtx)\n   switch (GET_CODE (in_rtx))\n     {\n     case MEM:\n-      fputc (' ', outfile);\n+      fputs (\" [\", outfile);\n       fprintf (outfile, HOST_WIDE_INT_PRINT_DEC, MEM_ALIAS_SET (in_rtx));\n+      if (MEM_DECL (in_rtx) && DECL_NAME (MEM_DECL (in_rtx)))\n+\tfprintf (outfile, \" %s\",\n+\t\t IDENTIFIER_POINTER (DECL_NAME (MEM_DECL (in_rtx))));\n+\n+      if (MEM_OFFSET (in_rtx))\n+\t{\n+\t  fputc ('+', outfile);\n+\t  fprintf (outfile, HOST_WIDE_INT_PRINT_DEC,\n+\t\t   INTVAL (MEM_OFFSET (in_rtx)));\n+\t}\n+\n+      if (MEM_SIZE (in_rtx))\n+\t{\n+\t  fputs (\" S\", outfile);\n+\t  fprintf (outfile, HOST_WIDE_INT_PRINT_DEC,\n+\t\t   INTVAL (MEM_SIZE (in_rtx)));\n+\t}\n+\n+      if (MEM_ALIGN (in_rtx) != 1)\n+\tfprintf (outfile, \" A%u\", MEM_ALIGN (in_rtx));\n+\n+      fputc (']', outfile);\n       break;\n \n #if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT && MAX_LONG_DOUBLE_TYPE_SIZE == 64"}]}