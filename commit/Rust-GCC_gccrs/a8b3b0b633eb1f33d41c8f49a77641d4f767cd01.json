{"sha": "a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThiM2IwYjYzM2ViMWYzM2Q0MWM4ZjQ5YTc3NjQxZDRmNzY3Y2QwMQ==", "commit": {"author": {"name": "Christopher D. Rickett", "email": "crickett@lanl.gov", "date": "2007-07-02T02:47:21Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-07-02T02:47:21Z"}, "message": "[multiple changes]\n\n2007-07-01  Christopher D. Rickett  <crickett@lanl.gov>\n\n\t* interface.c (gfc_compare_derived_types): Special case for comparing\n\tderived types across namespaces.\n\t(gfc_compare_types): Deal with BT_VOID.\n\t(compare_parameter): Use BT_VOID to accept ISO C Binding pointers.\n\t* trans-expr.c (gfc_conv_function_call): Remove setting parm_kind\n\tto SCALAR\n\t(gfc_conv_initializer): Deal with ISO C Binding NULL_PTR and \n\tNULL_FUNPTR.\n\t(gfc_conv_expr): Convert expressions for ISO C Binding derived types.\n\t* symbol.c (gfc_set_default_type): BIND(C) variables should not be\n\timplicitly declared.\n\t(check_conflict): Add BIND(C) and check for conflicts.\n\t(gfc_add_explicit_interface): Whitespace.\t\n\t(gfc_add_is_bind_c): New function.  \n\t(gfc_copy_attr): Use it.\n\t(gfc_new_symbol): Initialize ISO C Binding objects.\n\t(get_iso_c_binding_dt):  New function.\n\t(verify_bind_c_derived_type): Ditto.\n\t(gen_special_c_interop_ptr): Ditto.\n\t(add_formal_arg): Ditto.\n\t(gen_cptr_param): Ditto.\n\t(gen_fptr_param): Ditto.\n\t(gen_shape_param): Ditto.\n\t(add_proc_interface): Ditto.\n\t(build_formal_args): Ditto.\n\t(generate_isocbinding_symbol):  Ditto.\n\t(get_iso_c_sym):  Ditto.\n\t* decl.c (num_idents_on_line, has_name_equals): New variables.\n\t(verify_c_interop_param): New function.\n\t(build_sym): Finish binding labels and deal with COMMON blocks.\n\t(add_init_expr_to_sym): Check if the initialized expression is\n\tan iso_c_binding named constants\n\t(variable_decl): Set ISO C Binding type_spec components.\n\t(gfc_match_kind_spec): Check match for C interoperable kind.\n\t(match_char_spec): Fix comment. Chnage gfc_match_small_int\n\tto gfc_match_small_int_expr.  Check for C interoperable kind.\n\t(match_type_spec): Clear the current binding label.\n\t(match_attr_spec): Add DECL_IS_BIND_C.  If BIND(C) is found, use it\n\tto set attributes.\n\t(set_binding_label): New function.\n\t(set_com_block_bind_c): Ditto.\n\t(verify_c_interop): Ditto.\n\t(verify_com_block_vars_c_interop): Ditto.\n\t(verify_bind_c_sym): Ditto.\n\t(set_verify_bind_c_sym): Ditto.\n\t(set_verify_bind_c_com_block): Ditto.\n\t(get_bind_c_idents): Ditto.\n\t(gfc_match_bind_c_stmt): Ditto.\n\t(gfc_match_data_decl): Use num_idents_on_line.\n\t(match_result): Deal with right paren in BIND(C).\n\t(gfc_match_suffix): New function.\n\t(gfc_match_function_decl): Use it.  Code is re-arranged to deal with\n\tISO C Binding result clauses.\n\t(gfc_match_subroutine):  Deal with BIND(C).\n \t(gfc_match_bind_c): New function.\n\t(gfc_get_type_attr_spec): New function.  Code is re-arranged in and\n\ttaken from gfc_match_derived_decl.\n\t(gfc_match_derived_decl): Add check for BIND(C).\n\t* trans-common.c: Forward declare gfc_get_common.\n\t(gfc_sym_mangled_common_id): Change arg from 'const char *name' to\n\t'gfc_common_head *com'.  Check for ISO C Binding of the common block.\n\t(build_common_decl): 'com->name' to 'com in SET_DECL_ASSEMBLER_NAME.\n\t* gfortran.h: Add GFC_MAX_BINDING_LABEL_LEN\n\t(bt): Add BT_VOID\n\t(sym_flavor): Add FL_VOID.\n \t(iso_fortran_env_symbol, iso_c_binding_symbol, intmod_id): New enum\n\t(CInteropKind_t): New struct.\n\t(c_interop_kinds_table): Use it.  Declare an array of structs.\n\t(symbol_attribute): Add is_bind_c, is_c_interop, and is_iso_c\n\tbitfields.\n\t(gfc_typespec): Add is_c_interop; is_iso_c, and f90_type members.\n\t(gfc_symbol): Add from_intmod, intmod_sym_id, binding_label, and\n\tcommon_block members.\n\t(gfc_common_head): Add binding_label and is_bind_c members.\n\t(gfc_gsymbol): Add sym_name, mod_name, and binding_label members.\n\tAdd prototypes for get_c_kind, gfc_validate_c_kind, \n\tgfc_check_any_c_kind, gfc_add_is_bind_c, gfc_add_value,\n\tverify_c_interop, verify_c_interop_param, verify_bind_c_sym,\n\tverify_bind_c_derived_type, verify_com_block_vars_c_interop,\n\tgenerate_isocbinding_symbol, get_iso_c_sym, gfc_iso_c_sub_interface\n\t* iso-c-binding.def: New file. This file contains the definitions\n\tof the types provided by the Fortran 2003 ISO_C_BINDING intrinsic\n\tmodule.\n\t* trans-const.c (gfc_conv_constant_to_tree): Deal with C_NULL_PTR\n\t or C_NULL_FUNPTR expressions.\n\t* expr.c (gfc_copy_expr): Add BT_VOID case.  For BT_CHARACTER, the\n\tISO C Binding requires a minimum string length of 1 for '\\0'.  \n\t* module.c (intmod_sym): New struct.\n\t(pointer_info): Add binding_label member.\n\t(write_atom): Set len to 0 for NULL pointers. Check for NULL p and *p.\n\t(ab_attribute): Add AB_IS_BIND_C, AB_IS_C_INTEROP and AB_IS_ISO_C.\n\t(attr_bits): Add \"IS_BIND_C\", \"IS_C_INTEROP\", and \"IS_ISO_C\".\n\t(mio_symbol_attribute): Deal with ISO C Binding attributes.\n\t(bt_types): Add \"VOID\".\n\t(mio_typespec): Deal with ISO C Binding components.\n\t(mio_namespace_ref): Add intmod variable. \n\t(mio_symbol): Check for symbols from an intrinsic module.\n\t(load_commons): Check for BIND(C) common block.\n\t(read_module): Read binding_label and use it.\n\t(write_common): Add label.  Write BIND(C) info.\n\t(write_blank_common): Blank commons are not BIND(C).  Explicitly\n\tset is_bind_c=0.\n\t(write_symbol): Deal with binding_label.\n\t(sort_iso_c_rename_list): New function.\n\t(import_iso_c_binding_module): Ditto.\n\t(create_int_parameter): Add to args.\n\t(use_iso_fortran_env_module): Adjust to deal with iso_c_binding\n\tintrinsic module.\n\t* trans-types.c (c_interop_kinds_table): new array of structs. \n\t(gfc_validate_c_kind): New function.\n\t(gfc_check_any_c_kind): Ditto.\n\t(get_real_kind_from_node): Ditto.\n\t(get_int_kind_from_node): Ditto.\n\t(get_int_kind_from_width): Ditto.\n\t(get_int_kind_from_minimal_width): Ditto.\n\t(init_c_interop_kinds): Ditto.\n\t(gfc_init_kinds): call init_c_interop_kinds.\n\t(gfc_typenode_for_spec): Adjust for BT_VOID and ISO C Binding pointers.\n\tAdjust handling of BT_DERIVED.\n\t(gfc_sym_type): Whitespace.\n\t(gfc_get_derived_type):  Account for iso_c_binding derived types\n\t* resolve.c (is_scalar_expr_ptr): New function.\n\t(gfc_iso_c_func_interface): Ditto.\n\t(resolve_function): Use gfc_iso_c_func_interface. \n\t(set_name_and_label): New function.\n\t(gfc_iso_c_sub_interface): Ditto.\n\t(resolve_specific_s0): Use gfc_iso_c_sub_interface.\n\t(resolve_bind_c_comms): New function.\n\t(resolve_bind_c_derived_types): Ditto.\n\t(gfc_verify_binding_labels): Ditto.\n\t(resolve_fl_procedure): Check for ISO C interoperability.\n\t(resolve_symbol): Check C interoperability.\n\t(resolve_types): Walk the namespace.  Check COMMON blocks.\n\t* trans-decl.c (gfc_sym_mangled_identifier):  Prevent the mangling\n\tof identifiers that have an assigned binding label.\n\t(gfc_sym_mangled_function_id): Use the binding label rather than\n\tthe mangled name.\n\t(gfc_finish_var_decl): Put variables that are BIND(C) into a common\n\tsegment of the object file, because this is what C would do.\n\t(gfc_create_module_variable): Conver to proper types\n\t(set_tree_decl_type_code): New function.\n\t(generate_local_decl): Check dummy variables and derived types for\n\tISO C Binding attributes.\n\t* match.c (gfc_match_small_int_expr): New function.\n\t(gfc_match_name_C): Ditto.\n\t(match_common_name): Deal with ISO C Binding in COMMON blocks\n\t* trans-io.c (transfer_expr):  Deal with C_NULL_PTR or C_NULL_FUNPTR\n\texpressions\n\t* match.h: Add prototypes for gfc_match_small_int_expr,\n\tgfc_match_name_C, match_common_name, set_com_block_bind_c,\n\tset_binding_label, set_verify_bind_c_sym,\n\tset_verify_bind_c_com_block, get_bind_c_idents,\n\tgfc_match_bind_c_stmt, gfc_match_suffix, gfc_match_bind_c,\n\tgfc_get_type_attr_spec\n\t* parse.c (decode_statement): Use gfc_match_bind_c_stmt\n\t(parse_derived): Init *derived_sym = NULL, and gfc_current_block\n\tlater for valiadation.\n\t* primary.c (got_delim): Set ISO C Binding components of ts.\n\t(match_logical_constant): Ditto.\n\t(match_complex_constant): Ditto.\n\t(match_complex_constant): Ditto.\n\t(gfc_match_rvalue): Check for existence of at least one arg for\n\tC_LOC, C_FUNLOC, and C_ASSOCIATED.\n\t* misc.c (gfc_clear_ts): Clear ISO C Bindoing components in ts.\n\t(get_c_kind): New function.\n\n2007-07-01  Christopher D. Rickett  <crickett@lanl.gov>\n\n\t* Makefile.in: Add support for iso_c_generated_procs.c and\n\tiso_c_binding.c.\n\t* Makefile.am: Ditto.\n\t* intrinsics/iso_c_generated_procs.c: New file containing helper\n\tfunctions.\n\t* intrinsics/iso_c_binding.c: Ditto.\n\t* intrinsics/iso_c_binding.h: New file\n\t* gfortran.map: Include the __iso_c_binding_c_* functions.\n\t* libgfortran.h: define GFC_NUM_RANK_BITS.\n\n2007-06-23  Christopher D. Rickett  <crickett@lanl.gov>\n\n\t* bind_c_array_params.f03: New files for Fortran 2003 ISO C Binding.\n\t* bind_c_coms.f90: Ditto.\n\t* bind_c_coms_driver.c: Ditto.\n\t* bind_c_dts.f90: Ditto.\n\t* bind_c_dts_2.f03: Ditto.\n\t* bind_c_dts_2_driver.c: Ditto.\n\t* bind_c_dts_3.f03: Ditto.\n\t* bind_c_dts_4.f03: Ditto.\n\t* bind_c_dts_driver.c: Ditto.\n\t* bind_c_implicit_vars.f03: Ditto.\n\t* bind_c_procs.f03: Ditto.\n\t* bind_c_usage_2.f03: Ditto.\n\t* bind_c_usage_3.f03: Ditto.\n\t* bind_c_usage_5.f03: Ditto.\n\t* bind_c_usage_6.f03: Ditto.\n\t* bind_c_usage_7.f03: Ditto.\n\t* bind_c_vars.f90: Ditto.\n\t* bind_c_vars_driver.c: Ditto.\n\t* binding_c_table_15_1.f03: Ditto.\n\t* binding_label_tests.f03: Ditto.\n\t* binding_label_tests_10.f03: Ditto.\n\t* binding_label_tests_10_main.f03: Ditto.\n\t* binding_label_tests_11.f03: Ditto.\n\t* binding_label_tests_11_main.f03: Ditto.\n\t* binding_label_tests_12.f03: Ditto.\n\t* binding_label_tests_13.f03: Ditto.\n\t* binding_label_tests_13_main.f03: Ditto.\n\t* binding_label_tests_14.f03: Ditto.\n\t* binding_label_tests_2.f03: Ditto.\n\t* binding_label_tests_3.f03: Ditto.\n\t* binding_label_tests_4.f03: Ditto.\n\t* binding_label_tests_5.f03: Ditto.\n\t* binding_label_tests_6.f03: Ditto.\n\t* binding_label_tests_7.f03: Ditto.\n\t* binding_label_tests_8.f03: Ditto.\n\t* binding_label_tests_9.f03: Ditto.\n\t* c_assoc.f90: Ditto.\n\t* c_assoc_2.f03: Ditto.\n\t* c_f_pointer_shape_test.f90: Ditto.\n\t* c_f_pointer_tests.f90: Ditto.\n\t* c_f_tests_driver.c: Ditto.\n\t* c_funloc_tests.f03: Ditto.\n\t* c_funloc_tests_2.f03: Ditto.\n\t* c_funloc_tests_3.f03: Ditto.\n\t* c_funloc_tests_3_funcs.c: Ditto.\n\t* c_kind_params.f90: Ditto.\n\t* c_kind_tests_2.f03: Ditto.\n\t* c_kinds.c: Ditto.\n\t* c_loc_driver.c: Ditto.\n\t* c_loc_test.f90: Ditto.\n\t* c_loc_tests_2.f03: Ditto.\n\t* c_loc_tests_2_funcs.c: Ditto.\n\t* c_loc_tests_3.f03: Ditto.\n\t* c_loc_tests_4.f03: Ditto.\n\t* c_loc_tests_5.f03: Ditto.\n\t* c_loc_tests_6.f03: Ditto.\n\t* c_loc_tests_7.f03: Ditto.\n\t* c_loc_tests_8.f03: Ditto.\n\t* c_ptr_tests.f03: Ditto.\n\t* c_ptr_tests_10.f03: Ditto.\n\t* c_ptr_tests_5.f03: Ditto.\n\t* c_ptr_tests_7.f03: Ditto.\n\t* c_ptr_tests_7_driver.c: Ditto.\n\t* c_ptr_tests_8.f03: Ditto.\n\t* c_ptr_tests_8_funcs.c: Ditto.\n\t* c_ptr_tests_9.f03: Ditto.\n\t* c_ptr_tests_driver.c: Ditto.\n\t* c_size_t_driver.c: Ditto.\n\t* c_size_t_test.f03: Ditto.\n\t* com_block_driver.f90: Ditto.\n\t* global_vars_c_init.f90: Ditto.\n\t* global_vars_c_init_driver.c: Ditto.\n\t* global_vars_f90_init.f90: Ditto.\n\t* global_vars_f90_init_driver.c: Ditto.\n\t* interop_params.f03: Ditto.\n\t* iso_c_binding_only.f03: Ditto.\n\t* iso_c_binding_rename_1.f03: Ditto.\n\t* iso_c_binding_rename_1_driver.c: Ditto.\n\t* iso_c_binding_rename_2.f03: Ditto.\n\t* iso_c_binding_rename_2_driver.c: Ditto.\n\t* kind_tests_2.f03: Ditto.\n\t* kind_tests_3.f03: Ditto.\n\t* module_md5_1.f90: Ditto.\n\t* only_clause_main.c: Ditto.\n\t* print_c_kinds.f90: Ditto.\n\t* test_bind_c_parens.f03: Ditto.\n\t* test_c_assoc.c: Ditto.\n\t* test_com_block.f90: Ditto.\n\t* test_common_binding_labels.f03: Ditto.\n\t* test_common_binding_labels_2.f03: Ditto.\n\t* test_common_binding_labels_2_main.f03: Ditto.\n\t* test_common_binding_labels_3.f03: Ditto.\n\t* test_common_binding_labels_3_main.f03: Ditto.\n\t* test_only_clause.f90: Ditto.\n\t* use_iso_c_binding.f90: Ditto.\n\t* value_5.f90: Ditto.\n\t* value_test.f90: Ditto.\n\t* value_tests_f03.f90: Ditto.\n\nFrom-SVN: r126185", "tree": {"sha": "ac4b8eff52a0e3e3d04868300cc36392b6ca3faa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac4b8eff52a0e3e3d04868300cc36392b6ca3faa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/comments", "author": null, "committer": null, "parents": [{"sha": "5edfe9e86fb349a11ad604074fcbdfc917f3c04a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5edfe9e86fb349a11ad604074fcbdfc917f3c04a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5edfe9e86fb349a11ad604074fcbdfc917f3c04a"}], "stats": {"total": 7738, "additions": 7581, "deletions": 157}, "files": [{"sha": "02060eef179f8af19177977a115aff12df461910", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -1,3 +1,171 @@\n+2007-07-01  Christopher D. Rickett  <crickett@lanl.gov>\n+\n+\t* interface.c (gfc_compare_derived_types): Special case for comparing\n+\tderived types across namespaces.\n+\t(gfc_compare_types): Deal with BT_VOID.\n+\t(compare_parameter): Use BT_VOID to accept ISO C Binding pointers.\n+\t* trans-expr.c (gfc_conv_function_call): Remove setting parm_kind\n+\tto SCALAR\n+\t(gfc_conv_initializer): Deal with ISO C Binding NULL_PTR and \n+\tNULL_FUNPTR.\n+\t(gfc_conv_expr): Convert expressions for ISO C Binding derived types.\n+\t* symbol.c (gfc_set_default_type): BIND(C) variables should not be\n+\timplicitly declared.\n+\t(check_conflict): Add BIND(C) and check for conflicts.\n+\t(gfc_add_explicit_interface): Whitespace.\t\n+\t(gfc_add_is_bind_c): New function.  \n+\t(gfc_copy_attr): Use it.\n+\t(gfc_new_symbol): Initialize ISO C Binding objects.\n+\t(get_iso_c_binding_dt):  New function.\n+\t(verify_bind_c_derived_type): Ditto.\n+\t(gen_special_c_interop_ptr): Ditto.\n+\t(add_formal_arg): Ditto.\n+\t(gen_cptr_param): Ditto.\n+\t(gen_fptr_param): Ditto.\n+\t(gen_shape_param): Ditto.\n+\t(add_proc_interface): Ditto.\n+\t(build_formal_args): Ditto.\n+\t(generate_isocbinding_symbol):  Ditto.\n+\t(get_iso_c_sym):  Ditto.\n+\t* decl.c (num_idents_on_line, has_name_equals): New variables.\n+\t(verify_c_interop_param): New function.\n+\t(build_sym): Finish binding labels and deal with COMMON blocks.\n+\t(add_init_expr_to_sym): Check if the initialized expression is\n+\tan iso_c_binding named constants\n+\t(variable_decl): Set ISO C Binding type_spec components.\n+\t(gfc_match_kind_spec): Check match for C interoperable kind.\n+\t(match_char_spec): Fix comment. Chnage gfc_match_small_int\n+\tto gfc_match_small_int_expr.  Check for C interoperable kind.\n+\t(match_type_spec): Clear the current binding label.\n+\t(match_attr_spec): Add DECL_IS_BIND_C.  If BIND(C) is found, use it\n+\tto set attributes.\n+\t(set_binding_label): New function.\n+\t(set_com_block_bind_c): Ditto.\n+\t(verify_c_interop): Ditto.\n+\t(verify_com_block_vars_c_interop): Ditto.\n+\t(verify_bind_c_sym): Ditto.\n+\t(set_verify_bind_c_sym): Ditto.\n+\t(set_verify_bind_c_com_block): Ditto.\n+\t(get_bind_c_idents): Ditto.\n+\t(gfc_match_bind_c_stmt): Ditto.\n+\t(gfc_match_data_decl): Use num_idents_on_line.\n+\t(match_result): Deal with right paren in BIND(C).\n+\t(gfc_match_suffix): New function.\n+\t(gfc_match_function_decl): Use it.  Code is re-arranged to deal with\n+\tISO C Binding result clauses.\n+\t(gfc_match_subroutine):  Deal with BIND(C).\n+ \t(gfc_match_bind_c): New function.\n+\t(gfc_get_type_attr_spec): New function.  Code is re-arranged in and\n+\ttaken from gfc_match_derived_decl.\n+\t(gfc_match_derived_decl): Add check for BIND(C).\n+\t* trans-common.c: Forward declare gfc_get_common.\n+\t(gfc_sym_mangled_common_id): Change arg from 'const char *name' to\n+\t'gfc_common_head *com'.  Check for ISO C Binding of the common block.\n+\t(build_common_decl): 'com->name' to 'com in SET_DECL_ASSEMBLER_NAME.\n+\t* gfortran.h: Add GFC_MAX_BINDING_LABEL_LEN\n+\t(bt): Add BT_VOID\n+\t(sym_flavor): Add FL_VOID.\n+ \t(iso_fortran_env_symbol, iso_c_binding_symbol, intmod_id): New enum\n+\t(CInteropKind_t): New struct.\n+\t(c_interop_kinds_table): Use it.  Declare an array of structs.\n+\t(symbol_attribute): Add is_bind_c, is_c_interop, and is_iso_c\n+\tbitfields.\n+\t(gfc_typespec): Add is_c_interop; is_iso_c, and f90_type members.\n+\t(gfc_symbol): Add from_intmod, intmod_sym_id, binding_label, and\n+\tcommon_block members.\n+\t(gfc_common_head): Add binding_label and is_bind_c members.\n+\t(gfc_gsymbol): Add sym_name, mod_name, and binding_label members.\n+\tAdd prototypes for get_c_kind, gfc_validate_c_kind, \n+\tgfc_check_any_c_kind, gfc_add_is_bind_c, gfc_add_value,\n+\tverify_c_interop, verify_c_interop_param, verify_bind_c_sym,\n+\tverify_bind_c_derived_type, verify_com_block_vars_c_interop,\n+\tgenerate_isocbinding_symbol, get_iso_c_sym, gfc_iso_c_sub_interface\n+\t* iso-c-binding.def: New file. This file contains the definitions\n+\tof the types provided by the Fortran 2003 ISO_C_BINDING intrinsic\n+\tmodule.\n+\t* trans-const.c (gfc_conv_constant_to_tree): Deal with C_NULL_PTR\n+\t or C_NULL_FUNPTR expressions.\n+\t* expr.c (gfc_copy_expr): Add BT_VOID case.  For BT_CHARACTER, the\n+\tISO C Binding requires a minimum string length of 1 for '\\0'.  \n+\t* module.c (intmod_sym): New struct.\n+\t(pointer_info): Add binding_label member.\n+\t(write_atom): Set len to 0 for NULL pointers. Check for NULL p and *p.\n+\t(ab_attribute): Add AB_IS_BIND_C, AB_IS_C_INTEROP and AB_IS_ISO_C.\n+\t(attr_bits): Add \"IS_BIND_C\", \"IS_C_INTEROP\", and \"IS_ISO_C\".\n+\t(mio_symbol_attribute): Deal with ISO C Binding attributes.\n+\t(bt_types): Add \"VOID\".\n+\t(mio_typespec): Deal with ISO C Binding components.\n+\t(mio_namespace_ref): Add intmod variable. \n+\t(mio_symbol): Check for symbols from an intrinsic module.\n+\t(load_commons): Check for BIND(C) common block.\n+\t(read_module): Read binding_label and use it.\n+\t(write_common): Add label.  Write BIND(C) info.\n+\t(write_blank_common): Blank commons are not BIND(C).  Explicitly\n+\tset is_bind_c=0.\n+\t(write_symbol): Deal with binding_label.\n+\t(sort_iso_c_rename_list): New function.\n+\t(import_iso_c_binding_module): Ditto.\n+\t(create_int_parameter): Add to args.\n+\t(use_iso_fortran_env_module): Adjust to deal with iso_c_binding\n+\tintrinsic module.\n+\t* trans-types.c (c_interop_kinds_table): new array of structs. \n+\t(gfc_validate_c_kind): New function.\n+\t(gfc_check_any_c_kind): Ditto.\n+\t(get_real_kind_from_node): Ditto.\n+\t(get_int_kind_from_node): Ditto.\n+\t(get_int_kind_from_width): Ditto.\n+\t(get_int_kind_from_minimal_width): Ditto.\n+\t(init_c_interop_kinds): Ditto.\n+\t(gfc_init_kinds): call init_c_interop_kinds.\n+\t(gfc_typenode_for_spec): Adjust for BT_VOID and ISO C Binding pointers.\n+\tAdjust handling of BT_DERIVED.\n+\t(gfc_sym_type): Whitespace.\n+\t(gfc_get_derived_type):  Account for iso_c_binding derived types\n+\t* resolve.c (is_scalar_expr_ptr): New function.\n+\t(gfc_iso_c_func_interface): Ditto.\n+\t(resolve_function): Use gfc_iso_c_func_interface. \n+\t(set_name_and_label): New function.\n+\t(gfc_iso_c_sub_interface): Ditto.\n+\t(resolve_specific_s0): Use gfc_iso_c_sub_interface.\n+\t(resolve_bind_c_comms): New function.\n+\t(resolve_bind_c_derived_types): Ditto.\n+\t(gfc_verify_binding_labels): Ditto.\n+\t(resolve_fl_procedure): Check for ISO C interoperability.\n+\t(resolve_symbol): Check C interoperability.\n+\t(resolve_types): Walk the namespace.  Check COMMON blocks.\n+\t* trans-decl.c (gfc_sym_mangled_identifier):  Prevent the mangling\n+\tof identifiers that have an assigned binding label.\n+\t(gfc_sym_mangled_function_id): Use the binding label rather than\n+\tthe mangled name.\n+\t(gfc_finish_var_decl): Put variables that are BIND(C) into a common\n+\tsegment of the object file, because this is what C would do.\n+\t(gfc_create_module_variable): Conver to proper types\n+\t(set_tree_decl_type_code): New function.\n+\t(generate_local_decl): Check dummy variables and derived types for\n+\tISO C Binding attributes.\n+\t* match.c (gfc_match_small_int_expr): New function.\n+\t(gfc_match_name_C): Ditto.\n+\t(match_common_name): Deal with ISO C Binding in COMMON blocks\n+\t* trans-io.c (transfer_expr):  Deal with C_NULL_PTR or C_NULL_FUNPTR\n+\texpressions\n+\t* match.h: Add prototypes for gfc_match_small_int_expr,\n+\tgfc_match_name_C, match_common_name, set_com_block_bind_c,\n+\tset_binding_label, set_verify_bind_c_sym,\n+\tset_verify_bind_c_com_block, get_bind_c_idents,\n+\tgfc_match_bind_c_stmt, gfc_match_suffix, gfc_match_bind_c,\n+\tgfc_get_type_attr_spec\n+\t* parse.c (decode_statement): Use gfc_match_bind_c_stmt\n+\t(parse_derived): Init *derived_sym = NULL, and gfc_current_block\n+\tlater for valiadation.\n+\t* primary.c (got_delim): Set ISO C Binding components of ts.\n+\t(match_logical_constant): Ditto.\n+\t(match_complex_constant): Ditto.\n+\t(match_complex_constant): Ditto.\n+\t(gfc_match_rvalue): Check for existence of at least one arg for\n+\tC_LOC, C_FUNLOC, and C_ASSOCIATED.\n+\t* misc.c (gfc_clear_ts): Clear ISO C Bindoing components in ts.\n+\t(get_c_kind): New function.\n+\n 2007-07-01  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/32239"}, {"sha": "24f1a3d1b59521b4b45b9fc405339dcecc4b41f8", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 1048, "deletions": 78, "changes": 1126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -42,6 +42,15 @@ static symbol_attribute current_attr;\n static gfc_array_spec *current_as;\n static int colon_seen;\n \n+/* The current binding label (if any).  */\n+static char curr_binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n+/* Need to know how many identifiers are on the current data declaration\n+   line in case we're given the BIND(C) attribute with a NAME= specifier.  */\n+static int num_idents_on_line;\n+/* Need to know if a NAME= specifier was found during gfc_match_bind_c so we\n+   can supply a name if the curr_binding_label is nil and NAME= was not.  */\n+static int has_name_equals = 0;\n+\n /* Initializer of the previous enumerator.  */\n \n static gfc_expr *last_initializer;\n@@ -750,8 +759,147 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n }\n \n \n-/* Function called by variable_decl() that adds a name to the symbol\n-   table.  */\n+/* Verify that the given symbol representing a parameter is C\n+   interoperable, by checking to see if it was marked as such after\n+   its declaration.  If the given symbol is not interoperable, a\n+   warning is reported, thus removing the need to return the status to\n+   the calling function.  The standard does not require the user use\n+   one of the iso_c_binding named constants to declare an\n+   interoperable parameter, but we can't be sure if the param is C\n+   interop or not if the user doesn't.  For example, integer(4) may be\n+   legal Fortran, but doesn't have meaning in C.  It may interop with\n+   a number of the C types, which causes a problem because the\n+   compiler can't know which one.  This code is almost certainly not\n+   portable, and the user will get what they deserve if the C type\n+   across platforms isn't always interoperable with integer(4).  If\n+   the user had used something like integer(c_int) or integer(c_long),\n+   the compiler could have automatically handled the varying sizes\n+   across platforms.  */\n+\n+try\n+verify_c_interop_param (gfc_symbol *sym)\n+{\n+  int is_c_interop = 0;\n+  try retval = SUCCESS;\n+\n+  /* We check implicitly typed variables in symbol.c:gfc_set_default_type().\n+     Don't repeat the checks here.  */\n+  if (sym->attr.implicit_type)\n+    return SUCCESS;\n+  \n+  /* For subroutines or functions that are passed to a BIND(C) procedure,\n+     they're interoperable if they're BIND(C) and their params are all\n+     interoperable.  */\n+  if (sym->attr.flavor == FL_PROCEDURE)\n+    {\n+      if (sym->attr.is_bind_c == 0)\n+        {\n+          gfc_error_now (\"Procedure '%s' at %L must have the BIND(C) \"\n+                         \"attribute to be C interoperable\", sym->name,\n+                         &(sym->declared_at));\n+                         \n+          return FAILURE;\n+        }\n+      else\n+        {\n+          if (sym->attr.is_c_interop == 1)\n+            /* We've already checked this procedure; don't check it again.  */\n+            return SUCCESS;\n+          else\n+            return verify_bind_c_sym (sym, &(sym->ts), sym->attr.in_common,\n+                                      sym->common_block);\n+        }\n+    }\n+  \n+  /* See if we've stored a reference to a procedure that owns sym.  */\n+  if (sym->ns != NULL && sym->ns->proc_name != NULL)\n+    {\n+      if (sym->ns->proc_name->attr.is_bind_c == 1)\n+\t{\n+\t  is_c_interop =\n+\t    (verify_c_interop (&(sym->ts), sym->name, &(sym->declared_at))\n+\t     == SUCCESS ? 1 : 0);\n+\n+\t  if (is_c_interop != 1)\n+\t    {\n+\t      /* Make personalized messages to give better feedback.  */\n+\t      if (sym->ts.type == BT_DERIVED)\n+\t\tgfc_error (\"Type '%s' at %L is a parameter to the BIND(C) \"\n+\t\t\t   \" procedure '%s' but is not C interoperable \"\n+\t\t\t   \"because derived type '%s' is not C interoperable\",\n+\t\t\t   sym->name, &(sym->declared_at),\n+\t\t\t   sym->ns->proc_name->name, \n+\t\t\t   sym->ts.derived->name);\n+\t      else\n+\t\tgfc_warning (\"Variable '%s' at %L is a parameter to the \"\n+\t\t\t     \"BIND(C) procedure '%s' but may not be C \"\n+\t\t\t     \"interoperable\",\n+\t\t\t     sym->name, &(sym->declared_at),\n+\t\t\t     sym->ns->proc_name->name);\n+\t    }\n+ \n+\t  /* We have to make sure that any param to a bind(c) routine does\n+\t     not have the allocatable, pointer, or optional attributes,\n+\t     according to J3/04-007, section 5.1.  */\n+\t  if (sym->attr.allocatable == 1)\n+\t    {\n+\t      gfc_error (\"Variable '%s' at %L cannot have the \"\n+\t\t\t \"ALLOCATABLE attribute because procedure '%s'\"\n+\t\t\t \" is BIND(C)\", sym->name, &(sym->declared_at),\n+\t\t\t sym->ns->proc_name->name);\n+\t      retval = FAILURE;\n+\t    }\n+\n+\t  if (sym->attr.pointer == 1)\n+\t    {\n+\t      gfc_error (\"Variable '%s' at %L cannot have the \"\n+\t\t\t \"POINTER attribute because procedure '%s'\"\n+\t\t\t \" is BIND(C)\", sym->name, &(sym->declared_at),\n+\t\t\t sym->ns->proc_name->name);\n+\t      retval = FAILURE;\n+\t    }\n+\n+\t  if (sym->attr.optional == 1)\n+\t    {\n+\t      gfc_error (\"Variable '%s' at %L cannot have the \"\n+\t\t\t \"OPTIONAL attribute because procedure '%s'\"\n+\t\t\t \" is BIND(C)\", sym->name, &(sym->declared_at),\n+\t\t\t sym->ns->proc_name->name);\n+\t      retval = FAILURE;\n+\t    }\n+\n+          /* Make sure that if it has the dimension attribute, that it is\n+\t     either assumed size or explicit shape.  */\n+\t  if (sym->as != NULL)\n+\t    {\n+\t      if (sym->as->type == AS_ASSUMED_SHAPE)\n+\t\t{\n+\t\t  gfc_error (\"Assumed-shape array '%s' at %L cannot be an \"\n+\t\t\t     \"argument to the procedure '%s' at %L because \"\n+\t\t\t     \"the procedure is BIND(C)\", sym->name,\n+\t\t\t     &(sym->declared_at), sym->ns->proc_name->name,\n+\t\t\t     &(sym->ns->proc_name->declared_at));\n+\t\t  retval = FAILURE;\n+\t\t}\n+\n+\t      if (sym->as->type == AS_DEFERRED)\n+\t\t{\n+\t\t  gfc_error (\"Deferred-shape array '%s' at %L cannot be an \"\n+\t\t\t     \"argument to the procedure '%s' at %L because \"\n+\t\t\t     \"the procedure is BIND(C)\", sym->name,\n+\t\t\t     &(sym->declared_at), sym->ns->proc_name->name,\n+ \t\t\t     &(sym->ns->proc_name->declared_at));\n+\t\t  retval = FAILURE;\n+\t\t}\n+\t  }\n+\t}\n+    }\n+\n+  return retval;\n+}\n+\n+\n+/* Function called by variable_decl() that adds a name to the symbol table.  */\n \n static try\n build_sym (const char *name, gfc_charlen *cl,\n@@ -786,6 +934,40 @@ build_sym (const char *name, gfc_charlen *cl,\n   if (gfc_copy_attr (&sym->attr, &attr, var_locus) == FAILURE)\n     return FAILURE;\n \n+  /* Finish any work that may need to be done for the binding label,\n+     if it's a bind(c).  The bind(c) attr is found before the symbol\n+     is made, and before the symbol name (for data decls), so the\n+     current_ts is holding the binding label, or nothing if the\n+     name= attr wasn't given.  Therefore, test here if we're dealing\n+     with a bind(c) and make sure the binding label is set correctly.  */\n+  if (sym->attr.is_bind_c == 1)\n+    {\n+      if (sym->binding_label[0] == '\\0')\n+        {\n+          /* Here, we're not checking the numIdents (the last param).\n+             This could be an error we're letting slip through!  */\n+          if (set_binding_label (sym->binding_label, sym->name, 1) == FAILURE)\n+            return FAILURE;\n+        }\n+    }\n+\n+  /* See if we know we're in a common block, and if it's a bind(c)\n+     common then we need to make sure we're an interoperable type.  */\n+  if (sym->attr.in_common == 1)\n+    {\n+      /* Test the common block object.  */\n+      if (sym->common_block != NULL && sym->common_block->is_bind_c == 1\n+          && sym->ts.is_c_interop != 1)\n+        {\n+          gfc_error_now (\"Variable '%s' in common block '%s' at %C \"\n+                         \"must be declared with a C interoperable \"\n+                         \"kind since common block '%s' is BIND(C)\",\n+                         sym->name, sym->common_block->name,\n+                         sym->common_block->name);\n+          gfc_clear_error ();\n+        }\n+    }\n+\n   sym->attr.implied_index = 0;\n \n   return SUCCESS;\n@@ -987,6 +1169,26 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t    }\n \t}\n \n+      /* Need to check if the expression we initialized this\n+\t to was one of the iso_c_binding named constants.  If so,\n+\t and we're a parameter (constant), let it be iso_c.\n+\t For example:\n+\t integer(c_int), parameter :: my_int = c_int\n+\t integer(my_int) :: my_int_2\n+\t If we mark my_int as iso_c (since we can see it's value\n+\t is equal to one of the named constants), then my_int_2\n+\t will be considered C interoperable.  */\n+      if (sym->ts.type != BT_CHARACTER && sym->ts.type != BT_DERIVED)\n+\t{\n+\t  sym->ts.is_iso_c |= init->ts.is_iso_c;\n+\t  sym->ts.is_c_interop |= init->ts.is_c_interop;\n+\t  /* attr bits needed for module files.  */\n+\t  sym->attr.is_iso_c |= init->ts.is_iso_c;\n+\t  sym->attr.is_c_interop |= init->ts.is_c_interop;\n+\t  if (init->ts.is_iso_c)\n+\t    sym->ts.f90_type = init->ts.f90_type;\n+\t}\n+      \n       /* Add initializer.  Make sure we keep the ranks sane.  */\n       if (sym->attr.dimension && init->rank == 0)\n \t{\n@@ -1253,6 +1455,8 @@ variable_decl (int elem)\n \t  sym->ts.kind = current_ts.kind;\n \t  sym->ts.cl = cl;\n \t  sym->ts.derived = current_ts.derived;\n+\t  sym->ts.is_c_interop = current_ts.is_c_interop;\n+\t  sym->ts.is_iso_c = current_ts.is_iso_c;\n \t  m = MATCH_YES;\n \t\n \t  /* Check to see if we have an array specification.  */\n@@ -1536,25 +1740,41 @@ gfc_match_kind_spec (gfc_typespec *ts)\n       goto no_match;\n     }\n \n+  /* Before throwing away the expression, let's see if we had a\n+     C interoperable kind (and store the fact).\t */\n+  if (e->ts.is_c_interop == 1)\n+    {\n+      /* Mark this as c interoperable if being declared with one\n+\t of the named constants from iso_c_binding.  */\n+      ts->is_c_interop = e->ts.is_iso_c;\n+      ts->f90_type = e->ts.f90_type;\n+    }\n+  \n   gfc_free_expr (e);\n   e = NULL;\n \n+  /* Ignore errors to this point, if we've gotten here.  This means\n+     we ignore the m=MATCH_ERROR from above.  */\n   if (gfc_validate_kind (ts->type, ts->kind, true) < 0)\n     {\n       gfc_error (\"Kind %d not supported for type %s at %C\", ts->kind,\n \t\t gfc_basic_typename (ts->type));\n-\n       m = MATCH_ERROR;\n-      goto no_match;\n     }\n-\n-  if (gfc_match_char (')') != MATCH_YES)\n+  else if (gfc_match_char (')') != MATCH_YES)\n     {\n       gfc_error (\"Missing right parenthesis at %C\");\n-      goto no_match;\n+     m = MATCH_ERROR;\n     }\n+  else\n+     /* All tests passed.  */\n+     m = MATCH_YES;\n \n-  return MATCH_YES;\n+  if(m == MATCH_ERROR)\n+     gfc_current_locus = where;\n+  \n+  /* Return what we know from the test(s).  */\n+  return m;\n \n no_match:\n   gfc_free_expr (e);\n@@ -1573,7 +1793,7 @@ match_char_spec (gfc_typespec *ts)\n   gfc_charlen *cl;\n   gfc_expr *len;\n   match m;\n-\n+  gfc_expr *kind_expr = NULL;\n   kind = gfc_default_character_kind;\n   len = NULL;\n   seen_length = 0;\n@@ -1593,14 +1813,15 @@ match_char_spec (gfc_typespec *ts)\n   m = gfc_match_char ('(');\n   if (m != MATCH_YES)\n     {\n-      m = MATCH_YES;\t/* character without length is a single char */\n+      m = MATCH_YES;\t/* Character without length is a single char.  */\n       goto done;\n     }\n \n-  /* Try the weird case:  ( KIND = <int> [ , LEN = <len-param> ] )   */\n+  /* Try the weird case:  ( KIND = <int> [ , LEN = <len-param> ] ).  */\n   if (gfc_match (\" kind =\") == MATCH_YES)\n     {\n-      m = gfc_match_small_int (&kind);\n+      m = gfc_match_small_int_expr(&kind, &kind_expr);\n+       \n       if (m == MATCH_ERROR)\n \tgoto done;\n       if (m == MATCH_NO)\n@@ -1635,7 +1856,7 @@ match_char_spec (gfc_typespec *ts)\n       if (gfc_match (\" , kind =\") != MATCH_YES)\n \tgoto syntax;\n \n-      gfc_match_small_int (&kind);\n+      gfc_match_small_int_expr(&kind, &kind_expr);\n \n       if (gfc_validate_kind (BT_CHARACTER, kind, true) < 0)\n \t{\n@@ -1661,9 +1882,9 @@ match_char_spec (gfc_typespec *ts)\n   if (gfc_match_char (',') != MATCH_YES)\n     goto syntax;\n \n-  gfc_match (\" kind =\");\t/* Gobble optional text */\n+  gfc_match (\" kind =\");\t/* Gobble optional text.  */\n \n-  m = gfc_match_small_int (&kind);\n+  m = gfc_match_small_int_expr(&kind, &kind_expr);\n   if (m == MATCH_ERROR)\n     goto done;\n   if (m == MATCH_NO)\n@@ -1698,6 +1919,7 @@ match_char_spec (gfc_typespec *ts)\n   if (m != MATCH_YES)\n     {\n       gfc_free_expr (len);\n+      gfc_free_expr (kind_expr);\n       return m;\n     }\n \n@@ -1714,6 +1936,29 @@ match_char_spec (gfc_typespec *ts)\n   ts->cl = cl;\n   ts->kind = kind;\n \n+  /* We have to know if it was a c interoperable kind so we can\n+     do accurate type checking of bind(c) procs, etc.  */\n+  if (kind_expr != NULL)\n+    {\n+      /* Mark this as c interoperable if being declared with one\n+\t of the named constants from iso_c_binding.  */\n+      ts->is_c_interop = kind_expr->ts.is_iso_c;\n+      gfc_free_expr (kind_expr);\n+    }\n+  else if (len != NULL)\n+    {\n+      /* Here, we might have parsed something such as:\n+\t character(c_char)\n+\t In this case, the parsing code above grabs the c_char when\n+\t looking for the length (line 1690, roughly).  it's the last\n+\t testcase for parsing the kind params of a character variable.\n+\t However, it's not actually the length.\t this seems like it\n+\t could be an error.  \n+\t To see if the user used a C interop kind, test the expr\n+\t of the so called length, and see if it's C interoperable.  */\n+      ts->is_c_interop = len->ts.is_iso_c;\n+    }\n+  \n   return MATCH_YES;\n }\n \n@@ -1736,6 +1981,9 @@ match_type_spec (gfc_typespec *ts, int implicit_flag)\n \n   gfc_clear_ts (ts);\n \n+  /* Clear the current binding label, in case one is given.  */\n+  curr_binding_label[0] = '\\0';\n+\n   if (gfc_match (\" byte\") == MATCH_YES)\n     {\n       if (gfc_notify_std(GFC_STD_GNU, \"Extension: BYTE type at %C\")\n@@ -2193,7 +2441,7 @@ match_attr_spec (void)\n     DECL_IN, DECL_OUT, DECL_INOUT, DECL_INTRINSIC, DECL_OPTIONAL,\n     DECL_PARAMETER, DECL_POINTER, DECL_PROTECTED, DECL_PRIVATE,\n     DECL_PUBLIC, DECL_SAVE, DECL_TARGET, DECL_VALUE, DECL_VOLATILE,\n-    DECL_COLON, DECL_NONE,\n+    DECL_IS_BIND_C, DECL_COLON, DECL_NONE,\n     GFC_DECL_END /* Sentinel */\n   }\n   decl_types;\n@@ -2229,6 +2477,7 @@ match_attr_spec (void)\n   const char *attr;\n   match m;\n   try t;\n+  char peek_char;\n \n   gfc_clear_attr (&current_attr);\n   start = gfc_current_locus;\n@@ -2243,6 +2492,27 @@ match_attr_spec (void)\n   for (;;)\n     {\n       d = (decl_types) gfc_match_strings (decls);\n+\n+      if (d == DECL_NONE)\n+\t{\n+\t  /* See if we can find the bind(c) since all else failed. \n+\t     We need to skip over any whitespace and stop on the ','.  */\n+\t  gfc_gobble_whitespace ();\n+\t  peek_char = gfc_peek_char ();\n+\t  if (peek_char == ',')\n+\t    {\n+\t      /* Chomp the comma.  */\n+\t      peek_char = gfc_next_char ();\n+\t      /* Try and match the bind(c).  */\n+\t      if (gfc_match_bind_c (NULL) == MATCH_YES)\t\t \n+\t\td = DECL_IS_BIND_C;\n+\t      else\n+\t\t{\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t    }\n+\t}\n+       \n       if (d == DECL_NONE || d == DECL_COLON)\n \tbreak;\n \n@@ -2324,9 +2594,12 @@ match_attr_spec (void)\n \t  case DECL_TARGET:\n \t    attr = \"TARGET\";\n \t    break;\n-\t  case DECL_VALUE:\n-\t    attr = \"VALUE\";\n-\t    break;\n+          case DECL_IS_BIND_C:\n+            attr = \"IS_BIND_C\";\n+            break;\n+          case DECL_VALUE:\n+            attr = \"VALUE\";\n+            break;\n \t  case DECL_VOLATILE:\n \t    attr = \"VOLATILE\";\n \t    break;\n@@ -2476,6 +2749,10 @@ match_attr_spec (void)\n \t  t = gfc_add_target (&current_attr, &seen_at[d]);\n \t  break;\n \n+        case DECL_IS_BIND_C:\n+           t = gfc_add_is_bind_c(&current_attr, NULL, &seen_at[d], 0);\n+           break;\n+           \n \tcase DECL_VALUE:\n \t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: VALUE attribute \"\n \t\t\t      \"at %C\")\n@@ -2516,6 +2793,389 @@ match_attr_spec (void)\n }\n \n \n+/* Set the binding label, dest_label, either with the binding label\n+   stored in the given gfc_typespec, ts, or if none was provided, it\n+   will be the symbol name in all lower case, as required by the draft\n+   (J3/04-007, section 15.4.1).  If a binding label was given and\n+   there is more than one argument (num_idents), it is an error.  */\n+\n+try\n+set_binding_label (char *dest_label, const char *sym_name, int num_idents)\n+{\n+  if (curr_binding_label[0] != '\\0')\n+    {\n+      if (num_idents > 1 || num_idents_on_line > 1)\n+        {\n+          gfc_error (\"Multiple identifiers provided with \"\n+                     \"single NAME= specifier at %C\");\n+          return FAILURE;\n+        }\n+\n+      /* Binding label given; store in temp holder til have sym.  */\n+      strncpy (dest_label, curr_binding_label,\n+               strlen (curr_binding_label) + 1);\n+    }\n+  else\n+    {\n+      /* No binding label given, and the NAME= specifier did not exist,\n+         which means there was no NAME=\"\".  */\n+      if (sym_name != NULL && has_name_equals == 0)\n+        strncpy (dest_label, sym_name, strlen (sym_name) + 1);\n+    }\n+   \n+  return SUCCESS;\n+}\n+\n+\n+/* Set the status of the given common block as being BIND(C) or not,\n+   depending on the given parameter, is_bind_c.  */\n+\n+void\n+set_com_block_bind_c (gfc_common_head *com_block, int is_bind_c)\n+{\n+  com_block->is_bind_c = is_bind_c;\n+  return;\n+}\n+\n+\n+/* Verify that the given gfc_typespec is for a C interoperable type.  */\n+\n+try\n+verify_c_interop (gfc_typespec *ts, const char *name, locus *where)\n+{\n+  try t;\n+\n+  /* Make sure the kind used is appropriate for the type.\n+     The f90_type is unknown if an integer constant was\n+     used (e.g., real(4), bind(c) :: myFloat).  */\n+  if (ts->f90_type != BT_UNKNOWN)\n+    {\n+      t = gfc_validate_c_kind (ts);\n+      if (t != SUCCESS)\n+        {\n+          /* Print an error, but continue parsing line.  */\n+          gfc_error_now (\"C kind parameter is for type %s but \"\n+                         \"symbol '%s' at %L is of type %s\",\n+                         gfc_basic_typename (ts->f90_type),\n+                         name, where, \n+                         gfc_basic_typename (ts->type));\n+        }\n+    }\n+\n+  /* Make sure the kind is C interoperable.  This does not care about the\n+     possible error above.  */\n+  if (ts->type == BT_DERIVED && ts->derived != NULL)\n+    return (ts->derived->ts.is_c_interop ? SUCCESS : FAILURE);\n+  else if (ts->is_c_interop != 1)\n+    return FAILURE;\n+  \n+  return SUCCESS;\n+}\n+\n+\n+/* Verify that the variables of a given common block, which has been\n+   defined with the attribute specifier bind(c), to be of a C\n+   interoperable type.  Errors will be reported here, if\n+   encountered.  */\n+\n+try\n+verify_com_block_vars_c_interop (gfc_common_head *com_block)\n+{\n+  gfc_symbol *curr_sym = NULL;\n+  try retval = SUCCESS;\n+\n+  curr_sym = com_block->head;\n+  \n+  /* Make sure we have at least one symbol.  */\n+  if (curr_sym == NULL)\n+    return retval;\n+\n+  /* Here we know we have a symbol, so we'll execute this loop\n+     at least once.  */\n+  do\n+    {\n+      /* The second to last param, 1, says this is in a common block.  */\n+      retval = verify_bind_c_sym (curr_sym, &(curr_sym->ts), 1, com_block);\n+      curr_sym = curr_sym->common_next;\n+    } while (curr_sym != NULL); \n+\n+  return retval;\n+}\n+\n+\n+/* Verify that a given BIND(C) symbol is C interoperable.  If it is not,\n+   an appropriate error message is reported.  */\n+\n+try\n+verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n+                   int is_in_common, gfc_common_head *com_block)\n+{\n+  try retval = SUCCESS;\n+  \n+  /* Here, we know we have the bind(c) attribute, so if we have\n+     enough type info, then verify that it's a C interop kind.\n+     The info could be in the symbol already, or possibly still in\n+     the given ts (current_ts), so look in both.  */\n+  if (tmp_sym->ts.type != BT_UNKNOWN || ts->type != BT_UNKNOWN) \n+    {\n+      if (verify_c_interop (&(tmp_sym->ts), tmp_sym->name,\n+                            &(tmp_sym->declared_at)) != SUCCESS)\n+\t{\n+\t  /* See if we're dealing with a sym in a common block or not.\t*/\n+\t  if (is_in_common == 1)\n+\t    {\n+\t      gfc_warning (\"Variable '%s' in common block '%s' at %L \"\n+                           \"may not be a C interoperable \"\n+                           \"kind though common block '%s' is BIND(C)\",\n+                           tmp_sym->name, com_block->name,\n+                           &(tmp_sym->declared_at), com_block->name);\n+\t    }\n+\t  else\n+\t    {\n+              if (tmp_sym->ts.type == BT_DERIVED || ts->type == BT_DERIVED)\n+                gfc_error (\"Type declaration '%s' at %L is not C \"\n+                           \"interoperable but it is BIND(C)\",\n+                           tmp_sym->name, &(tmp_sym->declared_at));\n+              else\n+                gfc_warning (\"Variable '%s' at %L \"\n+                             \"may not be a C interoperable \"\n+                             \"kind but it is bind(c)\",\n+                             tmp_sym->name, &(tmp_sym->declared_at));\n+\t    }\n+\t}\n+      \n+      /* Variables declared w/in a common block can't be bind(c)\n+\t since there's no way for C to see these variables, so there's\n+\t semantically no reason for the attribute.  */\n+      if (is_in_common == 1 && tmp_sym->attr.is_bind_c == 1)\n+\t{\n+\t  gfc_error (\"Variable '%s' in common block '%s' at \"\n+\t\t     \"%L cannot be declared with BIND(C) \"\n+\t\t     \"since it is not a global\",\n+\t\t     tmp_sym->name, com_block->name,\n+\t\t     &(tmp_sym->declared_at));\n+\t  retval = FAILURE;\n+\t}\n+      \n+      /* Scalar variables that are bind(c) can not have the pointer\n+\t or allocatable attributes.  */\n+      if (tmp_sym->attr.is_bind_c == 1)\n+\t{\n+\t  if (tmp_sym->attr.pointer == 1)\n+\t    {\n+\t      gfc_error (\"Variable '%s' at %L cannot have both the \"\n+\t\t\t \"POINTER and BIND(C) attributes\",\n+\t\t\t tmp_sym->name, &(tmp_sym->declared_at));\n+\t      retval = FAILURE;\n+\t    }\n+\n+\t  if (tmp_sym->attr.allocatable == 1)\n+\t    {\n+\t      gfc_error (\"Variable '%s' at %L cannot have both the \"\n+\t\t\t \"ALLOCATABLE and BIND(C) attributes\",\n+\t\t\t tmp_sym->name, &(tmp_sym->declared_at));\n+\t      retval = FAILURE;\n+\t    }\n+\n+\t  /* If it is a BIND(C) function, make sure the return value is a\n+\t     scalar value.  The previous tests in this function made sure\n+\t     the type is interoperable.  */\n+\t  if (tmp_sym->attr.function == 1 && tmp_sym->as != NULL)\n+\t    gfc_error (\"Return type of BIND(C) function '%s' at %L cannot \"\n+\t\t       \"be an array\", tmp_sym->name, &(tmp_sym->declared_at));\n+\n+\t  /* BIND(C) functions can not return a character string.  */\n+\t  if (tmp_sym->attr.function == 1 && tmp_sym->ts.type == BT_CHARACTER)\n+\t    if (tmp_sym->ts.cl == NULL || tmp_sym->ts.cl->length == NULL\n+\t\t|| tmp_sym->ts.cl->length->expr_type != EXPR_CONSTANT\n+\t\t|| mpz_cmp_si (tmp_sym->ts.cl->length->value.integer, 1) != 0)\n+\t      gfc_error (\"Return type of BIND(C) function '%s' at %L cannot \"\n+\t\t\t \"be a character string\", tmp_sym->name,\n+\t\t\t &(tmp_sym->declared_at));\n+\t}\n+    }\n+\n+  /* See if the symbol has been marked as private.  If it has, make sure\n+     there is no binding label and warn the user if there is one.  */\n+  if (tmp_sym->attr.access == ACCESS_PRIVATE\n+      && tmp_sym->binding_label[0] != '\\0')\n+      /* Use gfc_warning_now because we won't say that the symbol fails\n+\t just because of this.\t*/\n+      gfc_warning_now (\"Symbol '%s' at %L is marked PRIVATE but has been \"\n+\t\t       \"given the binding label '%s'\", tmp_sym->name,\n+\t\t       &(tmp_sym->declared_at), tmp_sym->binding_label);\n+\n+  return retval;\n+}\n+\n+\n+/* Set the appropriate fields for a symbol that's been declared as\n+   BIND(C) (the is_bind_c flag and the binding label), and verify that\n+   the type is C interoperable.  Errors are reported by the functions\n+   used to set/test these fields.  */\n+\n+try\n+set_verify_bind_c_sym (gfc_symbol *tmp_sym, int num_idents)\n+{\n+  try retval = SUCCESS;\n+  \n+  /* TODO: Do we need to make sure the vars aren't marked private?  */\n+\n+  /* Set the is_bind_c bit in symbol_attribute.  */\n+  gfc_add_is_bind_c (&(tmp_sym->attr), tmp_sym->name, &gfc_current_locus, 0);\n+\n+  if (set_binding_label (tmp_sym->binding_label, tmp_sym->name, \n+\t\t\t num_idents) != SUCCESS)\n+    return FAILURE;\n+\n+  return retval;\n+}\n+\n+\n+/* Set the fields marking the given common block as BIND(C), including\n+   a binding label, and report any errors encountered.  */\n+\n+try\n+set_verify_bind_c_com_block (gfc_common_head *com_block, int num_idents)\n+{\n+  try retval = SUCCESS;\n+  \n+  /* destLabel, common name, typespec (which may have binding label).  */\n+  if (set_binding_label (com_block->binding_label, com_block->name, num_idents)\n+      != SUCCESS)\n+    return FAILURE;\n+\n+  /* Set the given common block (com_block) to being bind(c) (1).  */\n+  set_com_block_bind_c (com_block, 1);\n+\n+  return retval;\n+}\n+\n+\n+/* Retrieve the list of one or more identifiers that the given bind(c)\n+   attribute applies to.  */\n+\n+try\n+get_bind_c_idents (void)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  int num_idents = 0;\n+  gfc_symbol *tmp_sym = NULL;\n+  match found_id;\n+  gfc_common_head *com_block = NULL;\n+  \n+  if (gfc_match_name (name) == MATCH_YES)\n+    {\n+      found_id = MATCH_YES;\n+      gfc_get_ha_symbol (name, &tmp_sym);\n+    }\n+  else if (match_common_name (name) == MATCH_YES)\n+    {\n+      found_id = MATCH_YES;\n+      com_block = gfc_get_common (name, 0);\n+    }\n+  else\n+    {\n+      gfc_error (\"Need either entity or common block name for \"\n+\t\t \"attribute specification statement at %C\");\n+      return FAILURE;\n+    }\n+   \n+  /* Save the current identifier and look for more.  */\n+  do\n+    {\n+      /* Increment the number of identifiers found for this spec stmt.  */\n+      num_idents++;\n+\n+      /* Make sure we have a sym or com block, and verify that it can\n+\t be bind(c).  Set the appropriate field(s) and look for more\n+\t identifiers.  */\n+      if (tmp_sym != NULL || com_block != NULL)\t\t\n+        {\n+\t  if (tmp_sym != NULL)\n+\t    {\n+\t      if (set_verify_bind_c_sym (tmp_sym, num_idents)\n+\t\t  != SUCCESS)\n+\t\treturn FAILURE;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (set_verify_bind_c_com_block(com_block, num_idents)\n+\t\t  != SUCCESS)\n+\t\treturn FAILURE;\n+\t    }\n+\t \n+\t  /* Look to see if we have another identifier.  */\n+\t  tmp_sym = NULL;\n+\t  if (gfc_match_eos () == MATCH_YES)\n+\t    found_id = MATCH_NO;\n+\t  else if (gfc_match_char (',') != MATCH_YES)\n+\t    found_id = MATCH_NO;\n+\t  else if (gfc_match_name (name) == MATCH_YES)\n+\t    {\n+\t      found_id = MATCH_YES;\n+\t      gfc_get_ha_symbol (name, &tmp_sym);\n+\t    }\n+\t  else if (match_common_name (name) == MATCH_YES)\n+\t    {\n+\t      found_id = MATCH_YES;\n+\t      com_block = gfc_get_common (name, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      gfc_error (\"Missing entity or common block name for \"\n+\t\t\t \"attribute specification statement at %C\");\n+\t      return FAILURE;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gfc_internal_error (\"Missing symbol\");\n+\t}\n+    } while (found_id == MATCH_YES);\n+\n+  /* if we get here we were successful */\n+  return SUCCESS;\n+}\n+\n+\n+/* Try and match a BIND(C) attribute specification statement.  */\n+   \n+match\n+gfc_match_bind_c_stmt (void)\n+{\n+  match found_match = MATCH_NO;\n+  gfc_typespec *ts;\n+\n+  ts = &current_ts;\n+  \n+  /* This may not be necessary.  */\n+  gfc_clear_ts (ts);\n+  /* Clear the temporary binding label holder.  */\n+  curr_binding_label[0] = '\\0';\n+\n+  /* Look for the bind(c).  */\n+  found_match = gfc_match_bind_c (NULL);\n+\n+  if (found_match == MATCH_YES)\n+    {\n+      /* Look for the :: now, but it is not required.  */\n+      gfc_match (\" :: \");\n+\n+      /* Get the identifier(s) that needs to be updated.  This may need to\n+\t change to hand the flag(s) for the attr specified so all identifiers\n+\t found can have all appropriate parts updated (assuming that the same\n+\t spec stmt can have multiple attrs, such as both bind(c) and\n+\t allocatable...).  */\n+      if (get_bind_c_idents () != SUCCESS)\n+\t/* Error message should have printed already.  */\n+\treturn MATCH_ERROR;\n+    }\n+\n+  return found_match;\n+}\n+\n+\n /* Match a data declaration statement.  */\n \n match\n@@ -2525,6 +3185,8 @@ gfc_match_data_decl (void)\n   match m;\n   int elem;\n \n+  num_idents_on_line = 0;\n+  \n   m = match_type_spec (&current_ts, 0);\n   if (m != MATCH_YES)\n     return m;\n@@ -2584,6 +3246,7 @@ gfc_match_data_decl (void)\n   elem = 1;\n   for (;;)\n     {\n+      num_idents_on_line++;\n       m = variable_decl (elem++);\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n@@ -2814,9 +3477,11 @@ match_result (gfc_symbol *function, gfc_symbol **result)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_match (\" )%t\") != MATCH_YES)\n+  /* Get the right paren, and that's it because there could be the\n+     bind(c) attribute after the result clause.  */\n+  if (gfc_match_char(')') != MATCH_YES)\n     {\n-      gfc_error (\"Unexpected junk following RESULT variable at %C\");\n+     /* TODO: should report the missing right paren here.  */\n       return MATCH_ERROR;\n     }\n \n@@ -2839,6 +3504,79 @@ match_result (gfc_symbol *function, gfc_symbol **result)\n }\n \n \n+/* Match a function suffix, which could be a combination of a result\n+   clause and BIND(C), either one, or neither.  The draft does not\n+   require them to come in a specific order.  */\n+\n+match\n+gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n+{\n+  match is_bind_c;   /* Found bind(c).  */\n+  match is_result;   /* Found result clause.  */\n+  match found_match; /* Status of whether we've found a good match.  */\n+  int peek_char;     /* Character we're going to peek at.  */\n+\n+  /* Initialize to having found nothing.  */\n+  found_match = MATCH_NO;\n+  is_bind_c = MATCH_NO; \n+  is_result = MATCH_NO;\n+\n+  /* Get the next char to narrow between result and bind(c).  */\n+  gfc_gobble_whitespace ();\n+  peek_char = gfc_peek_char ();\n+\n+  switch (peek_char)\n+    {\n+    case 'r':\n+      /* Look for result clause.  */\n+      is_result = match_result (sym, result);\n+      if (is_result == MATCH_YES)\n+\t{\n+\t  /* Now see if there is a bind(c) after it.  */\n+\t  is_bind_c = gfc_match_bind_c (sym);\n+\t  /* We've found the result clause and possibly bind(c).  */\n+\t  found_match = MATCH_YES;\n+\t}\n+      else\n+\t/* This should only be MATCH_ERROR.  */\n+\tfound_match = is_result; \n+      break;\n+    case 'b':\n+      /* Look for bind(c) first.  */\n+      is_bind_c = gfc_match_bind_c (sym);\n+      if (is_bind_c == MATCH_YES)\n+\t{\n+\t  /* Now see if a result clause followed it.  */\n+\t  is_result = match_result (sym, result);\n+\t  found_match = MATCH_YES;\n+\t}\n+      else\n+\t{\n+\t  /* Should only be a MATCH_ERROR if we get here after seeing 'b'.  */\n+\t  found_match = MATCH_ERROR;\n+\t}\n+      break;\n+    default:\n+      gfc_error (\"Unexpected junk after function declaration at %C\");\n+      found_match = MATCH_ERROR;\n+      break;\n+    }\n+\n+  if (is_result == MATCH_ERROR || is_bind_c == MATCH_ERROR)\n+    {\n+      gfc_error (\"Error in function suffix at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (is_bind_c == MATCH_YES)\n+    if (gfc_add_is_bind_c (&(sym->attr), sym->name, &gfc_current_locus, 1)\n+        == FAILURE)\n+      return MATCH_ERROR;\n+  \n+  return found_match;\n+}\n+\n+\n /* Match a function declaration.  */\n \n match\n@@ -2848,6 +3586,8 @@ gfc_match_function_decl (void)\n   gfc_symbol *sym, *result;\n   locus old_loc;\n   match m;\n+  match suffix_match;\n+  match found_match; /* Status returned by match func.  */  \n \n   if (gfc_current_state () != COMP_NONE\n       && gfc_current_state () != COMP_INTERFACE\n@@ -2887,50 +3627,74 @@ gfc_match_function_decl (void)\n \n   result = NULL;\n \n-  if (gfc_match_eos () != MATCH_YES)\n-    {\n-      /* See if a result variable is present.  */\n-      m = match_result (sym, &result);\n-      if (m == MATCH_NO)\n-\tgfc_error (\"Unexpected junk after function declaration at %C\");\n-\n-      if (m != MATCH_YES)\n-\t{\n-\t  m = MATCH_ERROR;\n-\t  goto cleanup;\n-\t}\n+  /* According to the draft, the bind(c) and result clause can\n+     come in either order after the formal_arg_list (i.e., either\n+     can be first, both can exist together or by themselves or neither\n+     one).  Therefore, the match_result can't match the end of the\n+     string, and check for the bind(c) or result clause in either order.  */\n+  found_match = gfc_match_eos ();\n+\n+  /* Make sure that it isn't already declared as BIND(C).  If it is, it\n+     must have been marked BIND(C) with a BIND(C) attribute and that is\n+     not allowed for procedures.  */\n+  if (sym->attr.is_bind_c == 1)\n+    {\n+      sym->attr.is_bind_c = 0;\n+      if (sym->old_symbol != NULL)\n+        gfc_error_now (\"BIND(C) attribute at %L can only be used for \"\n+                       \"variables or common blocks\",\n+                       &(sym->old_symbol->declared_at));\n+      else\n+        gfc_error_now (\"BIND(C) attribute at %L can only be used for \"\n+                       \"variables or common blocks\", &gfc_current_locus);\n     }\n \n-  /* Make changes to the symbol.  */\n-  m = MATCH_ERROR;\n-\n-  if (gfc_add_function (&sym->attr, sym->name, NULL) == FAILURE)\n-    goto cleanup;\n-\n-  if (gfc_missing_attr (&sym->attr, NULL) == FAILURE\n-      || copy_prefix (&sym->attr, &sym->declared_at) == FAILURE)\n-    goto cleanup;\n-\n-  if (current_ts.type != BT_UNKNOWN && sym->ts.type != BT_UNKNOWN\n-      && !sym->attr.implicit_type)\n+  if (found_match != MATCH_YES)\n     {\n-      gfc_error (\"Function '%s' at %C already has a type of %s\", name,\n-\t\t gfc_basic_typename (sym->ts.type));\n-      goto cleanup;\n+      /* If we haven't found the end-of-statement, look for a suffix.  */\n+      suffix_match = gfc_match_suffix (sym, &result);\n+      if (suffix_match == MATCH_YES)\n+        /* Need to get the eos now.  */\n+        found_match = gfc_match_eos ();\n+      else\n+\tfound_match = suffix_match;\n     }\n \n-  if (result == NULL)\n-    {\n-      sym->ts = current_ts;\n-      sym->result = sym;\n-    }\n+  if(found_match != MATCH_YES)\n+    m = MATCH_ERROR;\n   else\n     {\n-      result->ts = current_ts;\n-      sym->result = result;\n-    }\n+      /* Make changes to the symbol.  */\n+      m = MATCH_ERROR;\n+      \n+      if (gfc_add_function (&sym->attr, sym->name, NULL) == FAILURE)\n+\tgoto cleanup;\n+      \n+      if (gfc_missing_attr (&sym->attr, NULL) == FAILURE\n+\t  || copy_prefix (&sym->attr, &sym->declared_at) == FAILURE)\n+\tgoto cleanup;\n \n-  return MATCH_YES;\n+      if (current_ts.type != BT_UNKNOWN && sym->ts.type != BT_UNKNOWN\n+\t  && !sym->attr.implicit_type)\n+\t{\n+\t  gfc_error (\"Function '%s' at %C already has a type of %s\", name,\n+\t\t     gfc_basic_typename (sym->ts.type));\n+\t  goto cleanup;\n+\t}\n+\n+      if (result == NULL)\n+\t{\n+\t  sym->ts = current_ts;\n+\t  sym->result = sym;\n+\t}\n+      else\n+\t{\n+\t  result->ts = current_ts;\n+\t  sym->result = result;\n+\t}\n+\n+      return MATCH_YES;\n+    }\n \n cleanup:\n   gfc_current_locus = old_loc;\n@@ -3165,6 +3929,8 @@ gfc_match_subroutine (void)\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n   match m;\n+  match is_bind_c;\n+  char peek_char;\n \n   if (gfc_current_state () != COMP_NONE\n       && gfc_current_state () != COMP_INTERFACE\n@@ -3183,12 +3949,56 @@ gfc_match_subroutine (void)\n     return MATCH_ERROR;\n   gfc_new_block = sym;\n \n+  /* Check what next non-whitespace character is so we can tell if there\n+     where the required parens if we have a BIND(C).  */\n+  gfc_gobble_whitespace ();\n+  peek_char = gfc_peek_char ();\n+  \n   if (gfc_add_subroutine (&sym->attr, sym->name, NULL) == FAILURE)\n     return MATCH_ERROR;\n \n   if (gfc_match_formal_arglist (sym, 0, 1) != MATCH_YES)\n     return MATCH_ERROR;\n \n+  /* Make sure that it isn't already declared as BIND(C).  If it is, it\n+     must have been marked BIND(C) with a BIND(C) attribute and that is\n+     not allowed for procedures.  */\n+  if (sym->attr.is_bind_c == 1)\n+    {\n+      sym->attr.is_bind_c = 0;\n+      if (sym->old_symbol != NULL)\n+        gfc_error_now (\"BIND(C) attribute at %L can only be used for \"\n+                       \"variables or common blocks\",\n+                       &(sym->old_symbol->declared_at));\n+      else\n+        gfc_error_now (\"BIND(C) attribute at %L can only be used for \"\n+                       \"variables or common blocks\", &gfc_current_locus);\n+    }\n+  \n+  /* Here, we are just checking if it has the bind(c) attribute, and if\n+     so, then we need to make sure it's all correct.  If it doesn't,\n+     we still need to continue matching the rest of the subroutine line.  */\n+  is_bind_c = gfc_match_bind_c (sym);\n+  if (is_bind_c == MATCH_ERROR)\n+    {\n+      /* There was an attempt at the bind(c), but it was wrong.\t An\n+\t error message should have been printed w/in the gfc_match_bind_c\n+\t so here we'll just return the MATCH_ERROR.  */\n+      return MATCH_ERROR;\n+    }\n+\n+  if (is_bind_c == MATCH_YES)\n+    {\n+      if (peek_char != '(')\n+        {\n+          gfc_error (\"Missing required parentheses before BIND(C) at %C\");\n+          return MATCH_ERROR;\n+        }\n+      if (gfc_add_is_bind_c (&(sym->attr), sym->name, &(sym->declared_at), 1)\n+\t  == FAILURE)\n+        return MATCH_ERROR;\n+    }\n+  \n   if (gfc_match_eos () != MATCH_YES)\n     {\n       gfc_syntax_error (ST_SUBROUTINE);\n@@ -3202,6 +4012,130 @@ gfc_match_subroutine (void)\n }\n \n \n+/* Match a BIND(C) specifier, with the optional 'name=' specifier if\n+   given, and set the binding label in either the given symbol (if not\n+   NULL), or in the current_ts.  The symbol may be NULL becuase we may\n+   encounter the BIND(C) before the declaration itself.  Return\n+   MATCH_NO if what we're looking at isn't a BIND(C) specifier,\n+   MATCH_ERROR if it is a BIND(C) clause but an error was encountered,\n+   or MATCH_YES if the specifier was correct and the binding label and\n+   bind(c) fields were set correctly for the given symbol or the\n+   current_ts.  */\n+\n+match\n+gfc_match_bind_c (gfc_symbol *sym)\n+{\n+  /* binding label, if exists */   \n+  char binding_label[GFC_MAX_SYMBOL_LEN + 1];\n+  match double_quote;\n+  match single_quote;\n+  int has_name_equals = 0;\n+\n+  /* Initialize the flag that specifies whether we encountered a NAME= \n+     specifier or not.  */\n+  has_name_equals = 0;\n+\n+  /* Init the first char to nil so we can catch if we don't have\n+     the label (name attr) or the symbol name yet.  */\n+  binding_label[0] = '\\0';\n+   \n+  /* This much we have to be able to match, in this order, if\n+     there is a bind(c) label.\t*/\n+  if (gfc_match (\" bind ( c \") != MATCH_YES)\n+    return MATCH_NO;\n+\n+  /* Now see if there is a binding label, or if we've reached the\n+     end of the bind(c) attribute without one.\t*/\n+  if (gfc_match_char (',') == MATCH_YES)\n+    {\n+      if (gfc_match (\" name = \") != MATCH_YES)\n+        {\n+          gfc_error (\"Syntax error in NAME= specifier for binding label \"\n+                     \"at %C\");\n+          /* should give an error message here */\n+          return MATCH_ERROR;\n+        }\n+\n+      has_name_equals = 1;\n+\n+      /* Get the opening quote.  */\n+      double_quote = MATCH_YES;\n+      single_quote = MATCH_YES;\n+      double_quote = gfc_match_char ('\"');\n+      if (double_quote != MATCH_YES)\n+\tsingle_quote = gfc_match_char ('\\'');\n+      if (double_quote != MATCH_YES && single_quote != MATCH_YES)\n+        {\n+          gfc_error (\"Syntax error in NAME= specifier for binding label \"\n+                     \"at %C\");\n+          return MATCH_ERROR;\n+        }\n+      \n+      /* Grab the binding label, using functions that will not lower\n+\t case the names automatically.\t*/\n+      if (gfc_match_name_C (binding_label) != MATCH_YES)\n+\t return MATCH_ERROR;\n+      \n+      /* Get the closing quotation.  */\n+      if (double_quote == MATCH_YES)\n+\t{\n+\t  if (gfc_match_char ('\"') != MATCH_YES)\n+            {\n+              gfc_error (\"Missing closing quote '\\\"' for binding label at %C\");\n+              /* User started string with '\"' so looked to match it.  */\n+              return MATCH_ERROR;\n+            }\n+\t}\n+      else\n+\t{\n+\t  if (gfc_match_char ('\\'') != MATCH_YES)\n+            {\n+              gfc_error (\"Missing closing quote '\\'' for binding label at %C\");\n+              /* User started string with \"'\" char.  */\n+              return MATCH_ERROR;\n+            }\n+\t}\n+   }\n+\n+  /* Get the required right paren.  */\n+  if (gfc_match_char (')') != MATCH_YES)\n+    {\n+      gfc_error (\"Missing closing paren for binding label at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Save the binding label to the symbol.  If sym is null, we're\n+     probably matching the typespec attributes of a declaration and\n+     haven't gotten the name yet, and therefore, no symbol yet.\t */\n+  if (binding_label[0] != '\\0')\n+    {\n+      if (sym != NULL)\n+      {\n+\tstrncpy (sym->binding_label, binding_label,\n+\t\t strlen (binding_label)+1);\n+      }\n+      else\n+\tstrncpy (curr_binding_label, binding_label,\n+\t\t strlen (binding_label) + 1);\n+    }\n+  else\n+    {\n+      /* No binding label, but if symbol isn't null, we\n+\t can set the label for it here.\t */\n+      /* TODO: If the name= was given and no binding label (name=\"\"), we simply\n+         will let fortran mangle the symbol name as it usually would.\n+         However, this could still let C call it if the user looked up the\n+         symbol in the object file.  Should the name set during mangling in\n+         trans-decl.c be marked with characters that are invalid for C to\n+         prevent this?  */\n+      if (sym != NULL && sym->name != NULL && has_name_equals == 0)\n+\tstrncpy (sym->binding_label, sym->name, strlen (sym->name) + 1);\n+    }\n+\t      \n+  return MATCH_YES;\n+}\n+\n+\n /* Return nonzero if we're currently compiling a contained procedure.  */\n \n static int\n@@ -4385,24 +5319,16 @@ gfc_match_modproc (void)\n }\n \n \n-/* Match the beginning of a derived type declaration.  If a type name\n-   was the result of a function, then it is possible to have a symbol\n-   already to be known as a derived type yet have no components.  */\n+/* Match the optional attribute specifiers for a type declaration.\n+   Return MATCH_ERROR if an error is encountered in one of the handled\n+   attributes (public, private, bind(c)), MATCH_NO if what's found is\n+   not a handled attribute, and MATCH_YES otherwise.  TODO: More error\n+   checking on attribute conflicts needs to be done.  */\n \n match\n-gfc_match_derived_decl (void)\n+gfc_get_type_attr_spec (symbol_attribute *attr)\n {\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\n-  symbol_attribute attr;\n-  gfc_symbol *sym;\n-  match m;\n-\n-  if (gfc_current_state () == COMP_DERIVED)\n-    return MATCH_NO;\n-\n-  gfc_clear_attr (&attr);\n-\n-loop:\n+  /* See if the derived type is marked as private.  */\n   if (gfc_match (\" , private\") == MATCH_YES)\n     {\n       if (gfc_current_state () != COMP_MODULE)\n@@ -4412,12 +5338,10 @@ gfc_match_derived_decl (void)\n \t  return MATCH_ERROR;\n \t}\n \n-      if (gfc_add_access (&attr, ACCESS_PRIVATE, NULL, NULL) == FAILURE)\n+      if (gfc_add_access (attr, ACCESS_PRIVATE, NULL, NULL) == FAILURE)\n \treturn MATCH_ERROR;\n-      goto loop;\n     }\n-\n-  if (gfc_match (\" , public\") == MATCH_YES)\n+  else if (gfc_match (\" , public\") == MATCH_YES)\n     {\n       if (gfc_current_state () != COMP_MODULE)\n \t{\n@@ -4426,10 +5350,52 @@ gfc_match_derived_decl (void)\n \t  return MATCH_ERROR;\n \t}\n \n-      if (gfc_add_access (&attr, ACCESS_PUBLIC, NULL, NULL) == FAILURE)\n+      if (gfc_add_access (attr, ACCESS_PUBLIC, NULL, NULL) == FAILURE)\n \treturn MATCH_ERROR;\n-      goto loop;\n     }\n+  else if(gfc_match(\" , bind ( c )\") == MATCH_YES)\n+    {\n+      /* If the type is defined to be bind(c) it then needs to make\n+\t sure that all fields are interoperable.  This will\n+\t need to be a semantic check on the finished derived type.\n+\t See 15.2.3 (lines 9-12) of F2003 draft.  */\n+      if (gfc_add_is_bind_c (attr, NULL, &gfc_current_locus, 0) != SUCCESS)\n+\treturn MATCH_ERROR;\n+\n+      /* TODO: attr conflicts need to be checked, probably in symbol.c.  */\n+    }\n+  else\n+    return MATCH_NO;\n+\n+  /* If we get here, something matched.  */\n+  return MATCH_YES;\n+}\n+\n+\n+/* Match the beginning of a derived type declaration.  If a type name\n+   was the result of a function, then it is possible to have a symbol\n+   already to be known as a derived type yet have no components.  */\n+\n+match\n+gfc_match_derived_decl (void)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  symbol_attribute attr;\n+  gfc_symbol *sym;\n+  match m;\n+  match is_type_attr_spec = MATCH_NO;\n+\n+  if (gfc_current_state () == COMP_DERIVED)\n+    return MATCH_NO;\n+\n+  gfc_clear_attr (&attr);\n+\n+  do\n+    {\n+      is_type_attr_spec = gfc_get_type_attr_spec (&attr);\n+      if (is_type_attr_spec == MATCH_ERROR)\n+\treturn MATCH_ERROR;\n+    } while (is_type_attr_spec == MATCH_YES);\n \n   if (gfc_match (\" ::\") != MATCH_YES && attr.access != ACCESS_UNKNOWN)\n     {\n@@ -4488,6 +5454,10 @@ gfc_match_derived_decl (void)\n       && gfc_add_access (&sym->attr, attr.access, sym->name, NULL) == FAILURE)\n     return MATCH_ERROR;\n \n+  /* See if the derived type was labeled as bind(c).  */\n+  if (attr.is_bind_c != 0)\n+    sym->attr.is_bind_c = attr.is_bind_c;\n+\n   gfc_new_block = sym;\n \n   return MATCH_YES;"}, {"sha": "0ca7dbfcae283ce63438ca4cdb10bad8f85f8b1b", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -449,19 +449,32 @@ gfc_copy_expr (gfc_expr *p)\n \t      s = gfc_getmem (p->value.character.length + 1);\n \t      q->value.character.string = s;\n \n-\t      memcpy (s, p->value.character.string, p->value.character.length + 1);\n+\t      /* This is the case for the C_NULL_CHAR named constant.  */\n+\t      if (p->value.character.length == 0\n+\t\t  && (p->ts.is_c_interop || p->ts.is_iso_c))\n+\t\t{\n+\t\t  *s = '\\0';\n+\t\t  /* Need to set the length to 1 to make sure the NUL\n+\t\t     terminator is copied.  */\n+\t\t  q->value.character.length = 1;\n+\t\t}\n+\t      else\n+\t\tmemcpy (s, p->value.character.string,\n+\t\t\tp->value.character.length + 1);\n \t    }\n \t  break;\n \n \tcase BT_HOLLERITH:\n \tcase BT_LOGICAL:\n \tcase BT_DERIVED:\n-\t  break;\t\t/* Already done */\n+\t  break;\t\t/* Already done.  */\n \n \tcase BT_PROCEDURE:\n+        case BT_VOID:\n+           /* Should never be reached.  */\n \tcase BT_UNKNOWN:\n \t  gfc_internal_error (\"gfc_copy_expr(): Bad expr node\");\n-\t  /* Not reached */\n+\t  /* Not reached.  */\n \t}\n \n       break;"}, {"sha": "8419118e2fe64a192c0c3177799020e87499adab", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 109, "deletions": 4, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -56,6 +56,8 @@ char *alloca ();\n /* Major control parameters.  */\n \n #define GFC_MAX_SYMBOL_LEN 63   /* Must be at least 63 for F2003.  */\n+#define GFC_MAX_BINDING_LABEL_LEN 126 /* (2 * GFC_MAX_SYMBOL_LEN) */\n+#define GFC_MAX_LINE 132\t/* Characters beyond this are not seen.  */\n #define GFC_MAX_DIMENSIONS 7\t/* Maximum dimensions in an array.  */\n #define GFC_LETTERS 26\t\t/* Number of letters in the alphabet.  */\n \n@@ -155,9 +157,12 @@ typedef enum\n { FORM_FREE, FORM_FIXED, FORM_UNKNOWN }\n gfc_source_form;\n \n+/* Basic types.  BT_VOID is used by ISO C BInding so funcs like c_f_pointer\n+   can take any arg with the pointer attribute as a param.  */\n typedef enum\n { BT_UNKNOWN = 1, BT_INTEGER, BT_REAL, BT_COMPLEX,\n-  BT_LOGICAL, BT_CHARACTER, BT_DERIVED, BT_PROCEDURE, BT_HOLLERITH\n+  BT_LOGICAL, BT_CHARACTER, BT_DERIVED, BT_PROCEDURE, BT_HOLLERITH,\n+  BT_VOID\n }\n bt;\n \n@@ -261,7 +266,8 @@ interface_type;\n typedef enum sym_flavor\n {\n   FL_UNKNOWN = 0, FL_PROGRAM, FL_BLOCK_DATA, FL_MODULE, FL_VARIABLE,\n-  FL_PARAMETER, FL_LABEL, FL_PROCEDURE, FL_DERIVED, FL_NAMELIST\n+  FL_PARAMETER, FL_LABEL, FL_PROCEDURE, FL_DERIVED, FL_NAMELIST,\n+  FL_VOID\n }\n sym_flavor;\n \n@@ -553,6 +559,62 @@ ioerror_codes;\n /* Used for keeping things in balanced binary trees.  */\n #define BBT_HEADER(self) int priority; struct self *left, *right\n \n+#define NAMED_INTCST(a,b,c) a,\n+typedef enum\n+{\n+  ISOFORTRANENV_INVALID = -1,\n+#include \"iso-fortran-env.def\"\n+  ISOFORTRANENV_LAST, ISOFORTRANENV_NUMBER = ISOFORTRANENV_LAST\n+}\n+iso_fortran_env_symbol;\n+#undef NAMED_INTCST\n+\n+#define NAMED_INTCST(a,b,c) a,\n+#define NAMED_REALCST(a,b,c) a,\n+#define NAMED_CMPXCST(a,b,c) a,\n+#define NAMED_LOGCST(a,b,c) a,\n+#define NAMED_CHARKNDCST(a,b,c) a,\n+#define NAMED_CHARCST(a,b,c) a,\n+#define DERIVED_TYPE(a,b,c) a,\n+#define PROCEDURE(a,b) a,\n+typedef enum\n+{\n+  ISOCBINDING_INVALID = -1, \n+#include \"iso-c-binding.def\"\n+  ISOCBINDING_LAST,\n+  ISOCBINDING_NUMBER = ISOCBINDING_LAST\n+}\n+iso_c_binding_symbol;\n+#undef NAMED_INTCST\n+#undef NAMED_REALCST\n+#undef NAMED_CMPXCST\n+#undef NAMED_LOGCST\n+#undef NAMED_CHARKNDCST\n+#undef NAMED_CHARCST\n+#undef DERIVED_TYPE\n+#undef PROCEDURE\n+\n+typedef enum\n+{\n+  INTMOD_NONE = 0, INTMOD_ISO_FORTRAN_ENV, INTMOD_ISO_C_BINDING\n+}\n+intmod_id;\n+\n+typedef struct\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  int value;  /* Used for both integer and character values.  */\n+  bt f90_type;\n+}\n+CInteropKind_t;\n+\n+/* Array of structs, where the structs represent the C interop kinds.\n+   The list will be implemented based on a hash of the kind name since\n+   these could be accessed multiple times.\n+   Declared in trans-types.c as a global, since it's in that file\n+   that the list is initialized.  */\n+extern CInteropKind_t c_interop_kinds_table[];\n+\n /* Symbol attribute structure.  */\n typedef struct\n {\n@@ -572,6 +634,14 @@ typedef struct\n   unsigned implicit_type:1;\t/* Type defined via implicit rules.  */\n   unsigned untyped:1;           /* No implicit type could be found.  */\n \n+  unsigned is_bind_c:1;\t\t/* say if is bound to C */\n+\n+  /* These flags are both in the typespec and attribute.  The attribute\n+     list is what gets read from/written to a module file.  The typespec\n+     is created from a decl being processed.  */\n+  unsigned is_c_interop:1;\t/* It's c interoperable.  */\n+  unsigned is_iso_c:1;\t\t/* Symbol is from iso_c_binding.  */\n+\n   /* Function/subroutine attributes */\n   unsigned sequence:1, elemental:1, pure:1, recursive:1;\n   unsigned unmaskable:1, masked:1, contained:1, mod_proc:1;\n@@ -714,6 +784,9 @@ typedef struct\n   int kind;\n   struct gfc_symbol *derived;\n   gfc_charlen *cl;\t/* For character types only.  */\n+  int is_c_interop;\n+  int is_iso_c;\n+  bt f90_type; \n }\n gfc_typespec;\n \n@@ -964,18 +1037,33 @@ typedef struct gfc_symbol\n   struct gfc_namespace *ns;\t/* namespace containing this symbol */\n \n   tree backend_decl;\n+   \n+  /* Identity of the intrinsic module the symbol comes from, or\n+     INTMOD_NONE if it's not imported from a intrinsic module.  */\n+  intmod_id from_intmod;\n+  /* Identity of the symbol from intrinsic modules, from enums maintained\n+     separately by each intrinsic module.  Used together with from_intmod,\n+     it uniquely identifies a symbol from an intrinsic module.  */\n+  int intmod_sym_id;\n+\n+  /* This may be repetitive, since the typespec now has a binding\n+     label field.  */\n+  char binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n+  /* Store a reference to the common_block, if this symbol is in one.  */\n+  struct gfc_common_head *common_block;\n }\n gfc_symbol;\n \n \n /* This structure is used to keep track of symbols in common blocks.  */\n-\n typedef struct gfc_common_head\n {\n   locus where;\n   char use_assoc, saved, threadprivate;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   struct gfc_symbol *head;\n+  char binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n+  int is_bind_c;\n }\n gfc_common_head;\n \n@@ -1115,6 +1203,9 @@ typedef struct gfc_gsymbol\n   BBT_HEADER(gfc_gsymbol);\n \n   const char *name;\n+  const char *sym_name;\n+  const char *mod_name;\n+  const char *binding_label;\n   enum { GSYM_UNKNOWN=1, GSYM_PROGRAM, GSYM_FUNCTION, GSYM_SUBROUTINE,\n         GSYM_MODULE, GSYM_COMMON, GSYM_BLOCK_DATA } type;\n \n@@ -1865,6 +1956,8 @@ void gfc_init_2 (void);\n void gfc_done_1 (void);\n void gfc_done_2 (void);\n \n+int get_c_kind (const char *, CInteropKind_t *);\n+\n /* options.c */\n unsigned int gfc_init_options (unsigned int, const char **);\n int gfc_handle_option (size_t, const char *, int);\n@@ -1921,6 +2014,8 @@ gfc_expr *gfc_enum_initializer (gfc_expr *, locus);\n arith gfc_check_integer_range (mpz_t p, int kind);\n \n /* trans-types.c */\n+try gfc_validate_c_kind (gfc_typespec *);\n+try gfc_check_any_c_kind (gfc_typespec *);\n int gfc_validate_kind (bt, int, bool);\n extern int gfc_index_integer_kind;\n extern int gfc_default_integer_kind;\n@@ -1980,10 +2075,11 @@ try gfc_add_pure (symbol_attribute *, locus *);\n try gfc_add_recursive (symbol_attribute *, locus *);\n try gfc_add_function (symbol_attribute *, const char *, locus *);\n try gfc_add_subroutine (symbol_attribute *, const char *, locus *);\n-try gfc_add_value (symbol_attribute *, const char *, locus *);\n try gfc_add_volatile (symbol_attribute *, const char *, locus *);\n \n try gfc_add_access (symbol_attribute *, gfc_access, const char *, locus *);\n+try gfc_add_is_bind_c(symbol_attribute *, const char *, locus *, int);\n+try gfc_add_value (symbol_attribute *, const char *, locus *);\n try gfc_add_flavor (symbol_attribute *, sym_flavor, const char *, locus *);\n try gfc_add_entry (symbol_attribute *, const char *, locus *);\n try gfc_add_procedure (symbol_attribute *, procedure_type,\n@@ -2017,6 +2113,13 @@ gfc_symbol *gfc_new_symbol (const char *, gfc_namespace *);\n int gfc_find_symbol (const char *, gfc_namespace *, int, gfc_symbol **);\n int gfc_find_sym_tree (const char *, gfc_namespace *, int, gfc_symtree **);\n int gfc_get_symbol (const char *, gfc_namespace *, gfc_symbol **);\n+try verify_c_interop (gfc_typespec *, const char *name, locus *where);\n+try verify_c_interop_param (gfc_symbol *);\n+try verify_bind_c_sym (gfc_symbol *, gfc_typespec *, int, gfc_common_head *);\n+try verify_bind_c_derived_type (gfc_symbol *);\n+try verify_com_block_vars_c_interop (gfc_common_head *);\n+void generate_isocbinding_symbol (const char *, iso_c_binding_symbol, char *);\n+gfc_symbol *get_iso_c_sym (gfc_symbol *, char *, char *, int);\n int gfc_get_sym_tree (const char *, gfc_namespace *, gfc_symtree **);\n int gfc_get_ha_symbol (const char *, gfc_symbol **);\n int gfc_get_ha_sym_tree (const char *, gfc_symtree **);\n@@ -2143,6 +2246,8 @@ try gfc_resolve_iterator (gfc_iterator *, bool);\n try gfc_resolve_index (gfc_expr *, int);\n try gfc_resolve_dim_arg (gfc_expr *);\n int gfc_is_formal_arg (void);\n+match gfc_iso_c_sub_interface(gfc_code *, gfc_symbol *);\n+\n \n /* array.c */\n void gfc_free_array_spec (gfc_array_spec *);"}, {"sha": "69ab3269d87bc1876cc37b7ee78262450f36d866", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -334,8 +334,8 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n   /* Special case for comparing derived types across namespaces.  If the\n      true names and module names are the same and the module name is\n      nonnull, then they are equal.  */\n-  if (strcmp (derived1->name, derived2->name) == 0\n-      && derived1 != NULL && derived2 != NULL\n+  if (derived1 != NULL && derived2 != NULL\n+      && strcmp (derived1->name, derived2->name) == 0\n       && derived1->module != NULL && derived2->module != NULL\n       && strcmp (derived1->module, derived2->module) == 0)\n     return 1;\n@@ -400,6 +400,13 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n int\n gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)\n {\n+  /* See if one of the typespecs is a BT_VOID, which is what is being used\n+     to allow the funcs like c_f_pointer to accept any pointer type.\n+     TODO: Possibly should narrow this to just the one typespec coming in\n+     that is for the formal arg, but oh well.  */\n+  if (ts1->type == BT_VOID || ts2->type == BT_VOID)\n+    return 1;\n+   \n   if (ts1->type != ts2->type)\n     return 0;\n   if (ts1->type != BT_DERIVED)\n@@ -1184,6 +1191,18 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n {\n   gfc_ref *ref;\n \n+  /* If the formal arg has type BT_VOID, it's to one of the iso_c_binding\n+     procs c_f_pointer or c_f_procpointer, and we need to accept most\n+     pointers the user could give us.  This should allow that.  */\n+  if (formal->ts.type == BT_VOID)\n+    return 1;\n+\n+  if (formal->ts.type == BT_DERIVED\n+      && formal->ts.derived && formal->ts.derived->ts.is_iso_c\n+      && actual->ts.type == BT_DERIVED\n+      && actual->ts.derived && actual->ts.derived->ts.is_iso_c)\n+    return 1;\n+\n   if (actual->ts.type == BT_PROCEDURE)\n     {\n       if (formal->attr.flavor != FL_PROCEDURE)"}, {"sha": "664c43a398c42a62c38ec004fca1e261b36783a4", "filename": "gcc/fortran/iso-c-binding.def", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fiso-c-binding.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fiso-c-binding.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-c-binding.def?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,158 @@\n+/* Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* This file contains the definition of the types provided by the\n+   Fortran 2003 ISO_C_BINDING intrinsic module.  */\n+\n+#ifndef NAMED_INTCST\n+# define NAMED_INTCST(a,b,c) \n+#endif\n+\n+#ifndef NAMED_REALCST\n+# define NAMED_REALCST(a,b,c) \n+#endif\n+\n+#ifndef NAMED_CMPXCST\n+# define NAMED_CMPXCST(a,b,c) \n+#endif\n+\n+#ifndef NAMED_LOGCST\n+# define NAMED_LOGCST(a,b,c) \n+#endif\n+\n+#ifndef NAMED_CHARKNDCST\n+# define NAMED_CHARKNDCST(a,b,c) \n+#endif\n+\n+/* The arguments to NAMED_*CST are:\n+     -- an internal name\n+     -- the symbol name in the module, as seen by Fortran code\n+     -- the value it has, for use in trans-types.c  */\n+\n+NAMED_INTCST (ISOCBINDING_INT, \"c_int\", gfc_c_int_kind)\n+NAMED_INTCST (ISOCBINDING_SHORT, \"c_short\", \\\n+              get_int_kind_from_node (short_integer_type_node))\n+NAMED_INTCST (ISOCBINDING_LONG, \"c_long\", \\\n+              get_int_kind_from_node (long_integer_type_node))\n+NAMED_INTCST (ISOCBINDING_LONG_LONG, \"c_long_long\", \\\n+              get_int_kind_from_node (long_long_integer_type_node))\n+\n+NAMED_INTCST (ISOCBINDING_INTMAX_T, \"c_intmax_t\", \\\n+              get_int_kind_from_node (intmax_type_node))\n+NAMED_INTCST (ISOCBINDING_INTPTR_T, \"c_intptr_t\", \\\n+              get_int_kind_from_node (ptr_type_node))\n+NAMED_INTCST (ISOCBINDING_SIZE_T, \"c_size_t\", \\\n+              gfc_index_integer_kind)\n+NAMED_INTCST (ISOCBINDING_SIGNED_CHAR, \"c_signed_char\", \\\n+              get_int_kind_from_node (signed_char_type_node))\n+\n+NAMED_INTCST (ISOCBINDING_INT8_T, \"c_int8_t\", get_int_kind_from_width (8))\n+NAMED_INTCST (ISOCBINDING_INT16_T, \"c_int16_t\", get_int_kind_from_width (16))\n+NAMED_INTCST (ISOCBINDING_INT32_T, \"c_int32_t\", get_int_kind_from_width (32))\n+NAMED_INTCST (ISOCBINDING_INT64_T, \"c_int64_t\", get_int_kind_from_width (64))\n+\n+NAMED_INTCST (ISOCBINDING_INT_LEAST8_T, \"c_int_least8_t\", \\\n+              get_int_kind_from_minimal_width (8))\n+NAMED_INTCST (ISOCBINDING_INT_LEAST16_T, \"c_int_least16_t\", \\\n+              get_int_kind_from_minimal_width (16))\n+NAMED_INTCST (ISOCBINDING_INT_LEAST32_T, \"c_int_least32_t\", \\\n+              get_int_kind_from_minimal_width (32))\n+NAMED_INTCST (ISOCBINDING_INT_LEAST64_T, \"c_int_least64_t\", \\\n+              get_int_kind_from_minimal_width (64))\n+\n+/* TODO: Implement c_int_fast*_t. Depends on PR 448.  */ \n+NAMED_INTCST (ISOCBINDING_INT_FAST8_T, \"c_int_fast8_t\", -2)\n+NAMED_INTCST (ISOCBINDING_INT_FAST16_T, \"c_int_fast16_t\", -2)\n+NAMED_INTCST (ISOCBINDING_INT_FAST32_T, \"c_int_fast32_t\", -2)\n+NAMED_INTCST (ISOCBINDING_INT_FAST64_T, \"c_int_fast64_t\", -2)\n+\n+NAMED_REALCST (ISOCBINDING_FLOAT, \"c_float\", \\\n+               get_real_kind_from_node (float_type_node))\n+NAMED_REALCST (ISOCBINDING_DOUBLE, \"c_double\", \\\n+               get_real_kind_from_node (double_type_node))\n+NAMED_REALCST (ISOCBINDING_LONG_DOUBLE, \"c_long_double\", \\\n+               get_real_kind_from_node (long_double_type_node))\n+NAMED_CMPXCST (ISOCBINDING_FLOAT_COMPLEX, \"c_float_complex\", \\\n+               get_real_kind_from_node (float_type_node))\n+NAMED_CMPXCST (ISOCBINDING_DOUBLE_COMPLEX, \"c_double_complex\", \\\n+               get_real_kind_from_node (double_type_node))\n+NAMED_CMPXCST (ISOCBINDING_LONG_DOUBLE_COMPLEX, \"c_long_double_complex\", \\\n+               get_real_kind_from_node (long_double_type_node))\n+\n+NAMED_LOGCST (ISOCBINDING_BOOL, \"c_bool\", \\\n+              get_int_kind_from_width (BOOL_TYPE_SIZE))\n+\n+NAMED_CHARKNDCST (ISOCBINDING_CHAR, \"c_char\", gfc_default_character_kind)\n+\n+#ifndef NAMED_CHARCST\n+# define NAMED_CHARCST(a,b,c) \n+#endif\n+\n+/* Use langhooks to deal with host to target translations.  */ \n+NAMED_CHARCST (ISOCBINDING_NULL_CHAR, \"c_null_char\", \\\n+\t       lang_hooks.to_target_charset ('\\0'))\n+NAMED_CHARCST (ISOCBINDING_ALERT, \"c_alert\", \\\n+\t       lang_hooks.to_target_charset ('\\a'))\n+NAMED_CHARCST (ISOCBINDING_BACKSPACE, \"c_backspace\", \\\n+\t       lang_hooks.to_target_charset ('\\b'))\n+NAMED_CHARCST (ISOCBINDING_FORM_FEED, \"c_form_feed\", \\\n+\t       lang_hooks.to_target_charset ('\\f'))\n+NAMED_CHARCST (ISOCBINDING_NEW_LINE, \"c_new_line\", \\\n+\t       lang_hooks.to_target_charset ('\\n'))\n+NAMED_CHARCST (ISOCBINDING_CARRIAGE_RETURN, \"c_carriage_return\", \\\n+\t       lang_hooks.to_target_charset ('\\r'))\n+NAMED_CHARCST (ISOCBINDING_HORIZONTAL_TAB, \"c_horizontal_tab\", \\\n+\t       lang_hooks.to_target_charset ('\\t'))\n+NAMED_CHARCST (ISOCBINDING_VERTICAL_TAB, \"c_vertical_tab\", \\\n+\t       lang_hooks.to_target_charset ('\\v'))\n+\n+#ifndef DERIVED_TYPE\n+# define DERIVED_TYPE(a,b,c) \n+#endif\n+\n+DERIVED_TYPE (ISOCBINDING_PTR, \"c_ptr\", \\\n+              get_int_kind_from_node (ptr_type_node))\n+DERIVED_TYPE (ISOCBINDING_NULL_PTR, \"c_null_ptr\", \\\n+              get_int_kind_from_node (ptr_type_node))\n+DERIVED_TYPE (ISOCBINDING_FUNPTR, \"c_funptr\", \\\n+              get_int_kind_from_node (ptr_type_node))\n+DERIVED_TYPE (ISOCBINDING_NULL_FUNPTR, \"c_null_funptr\", \\\n+              get_int_kind_from_node (ptr_type_node))\n+\n+  \n+#ifndef PROCEDURE\n+# define PROCEDURE(a,b) \n+#endif\n+\n+PROCEDURE (ISOCBINDING_F_POINTER, \"c_f_pointer\")\n+PROCEDURE (ISOCBINDING_ASSOCIATED, \"c_associated\")\n+PROCEDURE (ISOCBINDING_LOC, \"c_loc\")\n+PROCEDURE (ISOCBINDING_FUNLOC, \"c_funloc\")\n+\n+/* Insert c_f_procpointer, though unsupported for now.  */\n+PROCEDURE (ISOCBINDING_F_PROCPOINTER, \"c_f_procpointer\")\n+\n+#undef NAMED_INTCST\n+#undef NAMED_REALCST\n+#undef NAMED_CMPXCST\n+#undef NAMED_LOGCST\n+#undef NAMED_CHARCST\n+#undef NAMED_CHARKNDCST\n+#undef DERIVED_TYPE\n+#undef PROCEDURE"}, {"sha": "8db0b63b249790a637cc357065e6549eb3ab27fe", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 155, "deletions": 2, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -270,6 +270,38 @@ gfc_match_small_int (int *value)\n }\n \n \n+/* This function is the same as the gfc_match_small_int, except that\n+   we're keeping the pointer to the expr.  This function could just be\n+   removed and the previously mentioned one modified, though all calls\n+   to it would have to be modified then (and there were a number of\n+   them).  Return MATCH_ERROR if fail to extract the int; otherwise,\n+   return the result of gfc_match_expr().  The expr (if any) that was\n+   matched is returned in the parameter expr.  */\n+\n+match\n+gfc_match_small_int_expr (int *value, gfc_expr **expr)\n+{\n+  const char *p;\n+  match m;\n+  int i;\n+\n+  m = gfc_match_expr (expr);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  p = gfc_extract_int (*expr, &i);\n+\n+  if (p != NULL)\n+    {\n+      gfc_error (p);\n+      m = MATCH_ERROR;\n+    }\n+\n+  *value = i;\n+  return m;\n+}\n+\n+\n /* Matches a statement label.  Uses gfc_match_small_literal_int() to\n    do most of the work.  */\n \n@@ -476,6 +508,99 @@ gfc_match_name (char *buffer)\n }\n \n \n+/* Match a valid name for C, which is almost the same as for Fortran,\n+   except that you can start with an underscore, etc..  It could have\n+   been done by modifying the gfc_match_name, but this way other\n+   things C allows can be added, such as no limits on the length.\n+   Right now, the length is limited to the same thing as Fortran..\n+   Also, by rewriting it, we use the gfc_next_char_C() to prevent the\n+   input characters from being automatically lower cased, since C is\n+   case sensitive.  The parameter, buffer, is used to return the name\n+   that is matched.  Return MATCH_ERROR if the name is too long\n+   (though this is a self-imposed limit), MATCH_NO if what we're\n+   seeing isn't a name, and MATCH_YES if we successfully match a C\n+   name.  */\n+\n+match\n+gfc_match_name_C (char *buffer)\n+{\n+  locus old_loc;\n+  int i = 0;\n+  int c;\n+\n+  old_loc = gfc_current_locus;\n+  gfc_gobble_whitespace ();\n+\n+  /* Get the next char (first possible char of name) and see if\n+     it's valid for C (either a letter or an underscore).  */\n+  c = gfc_next_char_literal (1);\n+\n+  /* If the user put nothing expect spaces between the quotes, it is valid\n+     and simply means there is no name= specifier and the name is the fortran\n+     symbol name, all lowercase.  */\n+  if (c == '\"' || c == '\\'')\n+    {\n+      buffer[0] = '\\0';\n+      gfc_current_locus = old_loc;\n+      return MATCH_YES;\n+    }\n+  \n+  if (!ISALPHA (c) && c != '_')\n+    {\n+      gfc_error (\"Invalid C name in NAME= specifier at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Continue to read valid variable name characters.  */\n+  do\n+    {\n+      buffer[i++] = c;\n+      \n+    /* C does not define a maximum length of variable names, to my\n+       knowledge, but the compiler typically places a limit on them.\n+       For now, i'll use the same as the fortran limit for simplicity,\n+       but this may need to be changed to a dynamic buffer that can\n+       be realloc'ed here if necessary, or more likely, a larger\n+       upper-bound set.  */\n+      if (i > gfc_option.max_identifier_length)\n+        {\n+          gfc_error (\"Name at %C is too long\");\n+          return MATCH_ERROR;\n+        }\n+      \n+      old_loc = gfc_current_locus;\n+      \n+      /* Get next char; param means we're in a string.  */\n+      c = gfc_next_char_literal (1);\n+    } while (ISALNUM (c) || c == '_');\n+\n+  buffer[i] = '\\0';\n+  gfc_current_locus = old_loc;\n+\n+  /* See if we stopped because of whitespace.  */\n+  if (c == ' ')\n+    {\n+      gfc_gobble_whitespace ();\n+      c = gfc_peek_char ();\n+      if (c != '\"' && c != '\\'')\n+        {\n+          gfc_error (\"Embedded space in NAME= specifier at %C\");\n+          return MATCH_ERROR;\n+        }\n+    }\n+  \n+  /* If we stopped because we had an invalid character for a C name, report\n+     that to the user by returning MATCH_NO.  */\n+  if (c != '\"' && c != '\\'')\n+    {\n+      gfc_error (\"Invalid C name in NAME= specifier at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  return MATCH_YES;\n+}\n+\n+\n /* Match a symbol on the input.  Modifies the pointer to the symbol\n    pointer if successful.  */\n \n@@ -2306,8 +2431,7 @@ gfc_get_common (const char *name, int from_module)\n \n /* Match a common block name.  */\n \n-static match\n-match_common_name (char *name)\n+match match_common_name (char *name)\n {\n   match m;\n \n@@ -2415,6 +2539,35 @@ gfc_match_common (void)\n \t  if (m == MATCH_NO)\n \t    goto syntax;\n \n+          /* Store a ref to the common block for error checking.  */\n+          sym->common_block = t;\n+          \n+          /* See if we know the current common block is bind(c), and if\n+             so, then see if we can check if the symbol is (which it'll\n+             need to be).  This can happen if the bind(c) attr stmt was\n+             applied to the common block, and the variable(s) already\n+             defined, before declaring the common block.  */\n+          if (t->is_bind_c == 1)\n+            {\n+              if (sym->ts.type != BT_UNKNOWN && sym->ts.is_c_interop != 1)\n+                {\n+                  /* If we find an error, just print it and continue,\n+                     cause it's just semantic, and we can see if there\n+                     are more errors.  */\n+                  gfc_error_now (\"Variable '%s' at %L in common block '%s' \"\n+                                 \"at %C must be declared with a C \"\n+                                 \"interoperable kind since common block \"\n+                                 \"'%s' is bind(c)\",\n+                                 sym->name, &(sym->declared_at), t->name,\n+                                 t->name);\n+                }\n+              \n+              if (sym->attr.is_bind_c == 1)\n+                gfc_error_now (\"Variable '%s' in common block \"\n+                               \"'%s' at %C can not be bind(c) since \"\n+                               \"it is not global\", sym->name, t->name);\n+            }\n+          \n \t  if (sym->attr.in_common)\n \t    {\n \t      gfc_error (\"Symbol '%s' at %C is already in a COMMON block\","}, {"sha": "8bcc5b14b92f5a23cd484ed7f5a6587481be56fa", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -46,8 +46,10 @@ match gfc_match_small_literal_int (int *, int *);\n match gfc_match_st_label (gfc_st_label **);\n match gfc_match_label (void);\n match gfc_match_small_int (int *);\n+match gfc_match_small_int_expr (int *, gfc_expr **);\n int gfc_match_strings (mstring *);\n match gfc_match_name (char *);\n+match gfc_match_name_C (char *buffer);\n match gfc_match_symbol (gfc_symbol **, int);\n match gfc_match_sym_tree (gfc_symtree **, int);\n match gfc_match_intrinsic_op (gfc_intrinsic_op *);\n@@ -76,6 +78,15 @@ match gfc_match_nullify (void);\n match gfc_match_deallocate (void);\n match gfc_match_return (void);\n match gfc_match_call (void);\n+\n+/* We want to use this function to check for a common-block-name\n+   that can exist in a bind statement, so removed the \"static\"\n+   declaration of the function in match.c.\n+ \n+   TODO: should probably rename this now that it'll be globally seen to\n+   gfc_match_common_name.  */\n+match match_common_name (char *name);\n+\n match gfc_match_common (void);\n match gfc_match_block_data (void);\n match gfc_match_namelist (void);\n@@ -153,7 +164,21 @@ match gfc_match_target (void);\n match gfc_match_value (void);\n match gfc_match_volatile (void);\n \n-/* primary.c */\n+/* decl.c.  */\n+\n+/* Fortran 2003 c interop.\n+   TODO: some of these should be moved to another file rather than decl.c */\n+void set_com_block_bind_c (gfc_common_head *, int);\n+try set_binding_label (char *, const char *, int);\n+try set_verify_bind_c_sym (gfc_symbol *, int);\n+try set_verify_bind_c_com_block (gfc_common_head *, int);\n+try get_bind_c_idents (void);\n+match gfc_match_bind_c_stmt (void);\n+match gfc_match_suffix (gfc_symbol *, gfc_symbol **);\n+match gfc_match_bind_c (gfc_symbol *);\n+match gfc_get_type_attr_spec (symbol_attribute *);\n+\n+/* primary.c.  */\n match gfc_match_structure_constructor (gfc_symbol *, gfc_expr **);\n match gfc_match_variable (gfc_expr **, int);\n match gfc_match_equiv_variable (gfc_expr **);"}, {"sha": "bf0eca88664b3848b31837e28a1c94b0c2e7cc47", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -78,6 +78,12 @@ gfc_clear_ts (gfc_typespec *ts)\n   ts->kind = 0;\n   ts->derived = NULL;\n   ts->cl = NULL;\n+  /* flag that says if the type is C interoperable */\n+  ts->is_c_interop = 0;\n+  /* says what f90 type the C kind interops with */\n+  ts->f90_type = BT_UNKNOWN;\n+  /* flag that says whether it's from iso_c_binding or not */\n+  ts->is_iso_c = 0;\n }\n \n \n@@ -285,3 +291,18 @@ gfc_done_2 (void)\n   gfc_module_done_2 ();\n }\n \n+\n+/* Returns the index into the table of C interoperable kinds where the\n+   kind with the given name (c_kind_name) was found.  */\n+\n+int\n+get_c_kind(const char *c_kind_name, CInteropKind_t kinds_table[])\n+{\n+  int index = 0;\n+\n+  for (index = 0; index < ISOCBINDING_LAST; index++)\n+    if (strcmp (kinds_table[index].name, c_kind_name) == 0)\n+      return index;\n+\n+  return ISOCBINDING_INVALID;\n+}"}, {"sha": "665f6a11088d888ce1255cd3437711d98063a399", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 285, "deletions": 25, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -86,6 +86,15 @@ typedef struct\n }\n module_locus;\n \n+/* Structure for list of symbols of intrinsic modules.  */\n+typedef struct\n+{\n+  int id;\n+  const char *name;\n+  int value;\n+}\n+intmod_sym;\n+\n \n typedef enum\n {\n@@ -132,6 +141,7 @@ typedef struct pointer_info\n       module_locus where;\n       fixup_t *stfixup;\n       gfc_symtree *symtree;\n+      char binding_label[GFC_MAX_SYMBOL_LEN + 1];\n     }\n     rsym;\n \n@@ -1333,6 +1343,9 @@ write_atom (atom_type atom, const void *v)\n \n     }\n \n+  if(p == NULL || *p == '\\0') \n+     len = 0;\n+  else\n   len = strlen (p);\n \n   if (atom != ATOM_RPAREN)\n@@ -1350,7 +1363,7 @@ write_atom (atom_type atom, const void *v)\n   if (atom == ATOM_STRING)\n     write_char ('\\'');\n \n-  while (*p)\n+  while (p != NULL && *p)\n     {\n       if (atom == ATOM_STRING && *p == '\\'')\n \twrite_char ('\\'');\n@@ -1503,7 +1516,8 @@ typedef enum\n   AB_IN_NAMELIST, AB_IN_COMMON, AB_FUNCTION, AB_SUBROUTINE, AB_SEQUENCE,\n   AB_ELEMENTAL, AB_PURE, AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT,\n   AB_CRAY_POINTER, AB_CRAY_POINTEE, AB_THREADPRIVATE, AB_ALLOC_COMP,\n-  AB_VALUE, AB_VOLATILE, AB_PROTECTED\n+  AB_VALUE, AB_VOLATILE, AB_PROTECTED, AB_IS_BIND_C, AB_IS_C_INTEROP,\n+  AB_IS_ISO_C\n }\n ab_attribute;\n \n@@ -1516,7 +1530,6 @@ static const mstring attr_bits[] =\n     minit (\"OPTIONAL\", AB_OPTIONAL),\n     minit (\"POINTER\", AB_POINTER),\n     minit (\"SAVE\", AB_SAVE),\n-    minit (\"VALUE\", AB_VALUE),\n     minit (\"VOLATILE\", AB_VOLATILE),\n     minit (\"TARGET\", AB_TARGET),\n     minit (\"THREADPRIVATE\", AB_THREADPRIVATE),\n@@ -1535,11 +1548,16 @@ static const mstring attr_bits[] =\n     minit (\"ALWAYS_EXPLICIT\", AB_ALWAYS_EXPLICIT),\n     minit (\"CRAY_POINTER\", AB_CRAY_POINTER),\n     minit (\"CRAY_POINTEE\", AB_CRAY_POINTEE),\n+    minit (\"IS_BIND_C\", AB_IS_BIND_C),\n+    minit (\"IS_C_INTEROP\", AB_IS_C_INTEROP),\n+    minit (\"IS_ISO_C\", AB_IS_ISO_C),\n+    minit (\"VALUE\", AB_VALUE),\n     minit (\"ALLOC_COMP\", AB_ALLOC_COMP),\n     minit (\"PROTECTED\", AB_PROTECTED),\n     minit (NULL, -1)\n };\n \n+\n /* Specialization of mio_name.  */\n DECL_MIO_NAME (ab_attribute)\n DECL_MIO_NAME (ar_type)\n@@ -1633,6 +1651,12 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_CRAY_POINTER, attr_bits);\n       if (attr->cray_pointee)\n \tMIO_NAME (ab_attribute) (AB_CRAY_POINTEE, attr_bits);\n+      if (attr->is_bind_c)\n+\tMIO_NAME(ab_attribute) (AB_IS_BIND_C, attr_bits);\n+      if (attr->is_c_interop)\n+\tMIO_NAME(ab_attribute) (AB_IS_C_INTEROP, attr_bits);\n+      if (attr->is_iso_c)\n+\tMIO_NAME(ab_attribute) (AB_IS_ISO_C, attr_bits);\n       if (attr->alloc_comp)\n \tMIO_NAME (ab_attribute) (AB_ALLOC_COMP, attr_bits);\n \n@@ -1732,6 +1756,15 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_CRAY_POINTEE:\n \t      attr->cray_pointee = 1;\n \t      break;\n+\t    case AB_IS_BIND_C:\n+\t      attr->is_bind_c = 1;\n+\t      break;\n+\t    case AB_IS_C_INTEROP:\n+\t      attr->is_c_interop = 1;\n+\t      break;\n+\t    case AB_IS_ISO_C:\n+\t      attr->is_iso_c = 1;\n+\t      break;\n \t    case AB_ALLOC_COMP:\n \t      attr->alloc_comp = 1;\n \t      break;\n@@ -1750,6 +1783,7 @@ static const mstring bt_types[] = {\n     minit (\"DERIVED\", BT_DERIVED),\n     minit (\"PROCEDURE\", BT_PROCEDURE),\n     minit (\"UNKNOWN\", BT_UNKNOWN),\n+    minit (\"VOID\", BT_VOID),\n     minit (NULL, -1)\n };\n \n@@ -1820,6 +1854,18 @@ mio_typespec (gfc_typespec *ts)\n   else\n     mio_symbol_ref (&ts->derived);\n \n+  /* Add info for C interop and is_iso_c.  */\n+  mio_integer (&ts->is_c_interop);\n+  mio_integer (&ts->is_iso_c);\n+  \n+  /* If the typespec is for an identifier either from iso_c_binding, or\n+     a constant that was initialized to an identifier from it, use the\n+     f90_type.  Otherwise, use the ts->type, since it shouldn't matter.  */\n+  if (ts->is_iso_c)\n+    ts->f90_type = MIO_NAME (bt) (ts->f90_type, bt_types);\n+  else\n+    ts->f90_type = MIO_NAME (bt) (ts->type, bt_types);\n+\n   if (ts->type != BT_CHARACTER)\n     {\n       /* ts->cl is only valid for BT_CHARACTER.  */\n@@ -2951,6 +2997,8 @@ mio_namespace_ref (gfc_namespace **nsp)\n static void\n mio_symbol (gfc_symbol *sym)\n {\n+  int intmod = INTMOD_NONE;\n+  \n   gfc_formal_arglist *formal;\n \n   mio_lparen ();\n@@ -3006,6 +3054,23 @@ mio_symbol (gfc_symbol *sym)\n       = MIO_NAME (gfc_access) (sym->component_access, access_types);\n \n   mio_namelist (sym);\n+\n+  /* Add the fields that say whether this is from an intrinsic module,\n+     and if so, what symbol it is within the module.  */\n+/*   mio_integer (&(sym->from_intmod)); */\n+  if (iomode == IO_OUTPUT)\n+    {\n+      intmod = sym->from_intmod;\n+      mio_integer (&intmod);\n+    }\n+  else\n+    {\n+      mio_integer (&intmod);\n+      sym->from_intmod = intmod;\n+    }\n+  \n+  mio_integer (&(sym->intmod_sym_id));\n+  \n   mio_rparen ();\n }\n \n@@ -3179,6 +3244,11 @@ load_commons (void)\n \tp->threadprivate = 1;\n       p->use_assoc = 1;\n \n+      /* Get whether this was a bind(c) common or not.  */\n+      mio_integer (&p->is_bind_c);\n+      /* Get the binding label.  */\n+      mio_internal_string (p->binding_label);\n+      \n       mio_rparen ();\n     }\n \n@@ -3415,7 +3485,9 @@ read_module (void)\n \n       mio_internal_string (info->u.rsym.true_name);\n       mio_internal_string (info->u.rsym.module);\n+      mio_internal_string (info->u.rsym.binding_label);\n \n+      \n       require_atom (ATOM_INTEGER);\n       info->u.rsym.ns = atom_int;\n \n@@ -3525,6 +3597,11 @@ read_module (void)\n \t\t\t\t\t\t     gfc_current_ns);\n \t\t  sym = info->u.rsym.sym;\n \t\t  sym->module = gfc_get_string (info->u.rsym.module);\n+\n+\t\t  /* TODO: hmm, can we test this?  Do we know it will be\n+\t\t     initialized to zeros?  */\n+\t\t  if (info->u.rsym.binding_label[0] != '\\0')\n+\t\t    strcpy (sym->binding_label, info->u.rsym.binding_label);\n \t\t}\n \n \t      st->n.sym = sym;\n@@ -3648,7 +3725,8 @@ write_common (gfc_symtree *st)\n   gfc_common_head *p;\n   const char * name;\n   int flags;\n-\n+  const char *label;\n+\t      \n   if (st == NULL)\n     return;\n \n@@ -3668,16 +3746,35 @@ write_common (gfc_symtree *st)\n   if (p->threadprivate) flags |= 2;\n   mio_integer (&flags);\n \n+  /* Write out whether the common block is bind(c) or not.  */\n+  mio_integer (&(p->is_bind_c));\n+\n+  /* Write out the binding label, or the com name if no label given.  */\n+  if (p->is_bind_c)\n+    {\n+      label = p->binding_label;\n+      mio_pool_string (&label);\n+    }\n+  else\n+    {\n+      label = p->name;\n+      mio_pool_string (&label);\n+    }\n+\n   mio_rparen ();\n }\n \n-/* Write the blank common block to the module */\n+\n+/* Write the blank common block to the module.  */\n \n static void\n write_blank_common (void)\n {\n   const char * name = BLANK_COMMON_NAME;\n   int saved;\n+  /* TODO: Blank commons are not bind(c).  The F2003 standard probably says\n+     this, but it hasn't been checked.  Just making it so for now.  */  \n+  int is_bind_c = 0;  \n \n   if (gfc_current_ns->blank_common.head == NULL)\n     return;\n@@ -3690,6 +3787,13 @@ write_blank_common (void)\n   saved = gfc_current_ns->blank_common.saved;\n   mio_integer (&saved);\n \n+  /* Write out whether the common block is bind(c) or not.  */\n+  mio_integer (&is_bind_c);\n+\n+  /* Write out the binding label, which is BLANK_COMMON_NAME, though\n+     it doesn't matter because the label isn't used.  */\n+  mio_pool_string (&name);\n+\n   mio_rparen ();\n }\n \n@@ -3726,6 +3830,7 @@ write_equiv (void)\n static void\n write_symbol (int n, gfc_symbol *sym)\n {\n+   const char *label;\n \n   if (sym->attr.flavor == FL_UNKNOWN || sym->attr.flavor == FL_LABEL)\n     gfc_internal_error (\"write_symbol(): bad module symbol '%s'\", sym->name);\n@@ -3734,6 +3839,14 @@ write_symbol (int n, gfc_symbol *sym)\n   mio_pool_string (&sym->name);\n \n   mio_pool_string (&sym->module);\n+  if (sym->attr.is_bind_c || sym->attr.is_iso_c)\n+    {\n+      label = sym->binding_label;\n+      mio_pool_string (&label);\n+    }\n+  else\n+    mio_pool_string (&sym->name);\n+\n   mio_pointer_ref (&sym->ns);\n \n   mio_symbol (sym);\n@@ -3777,8 +3890,6 @@ write_symbol0 (gfc_symtree *st)\n \n   write_symbol (p->integer, sym);\n   p->u.wsym.state = WRITTEN;\n-\n-  return;\n }\n \n \n@@ -4080,9 +4191,145 @@ gfc_dump_module (const char *name, int dump_flag)\n }\n \n \n+static void\n+sort_iso_c_rename_list (void)\n+{\n+  gfc_use_rename *tmp_list = NULL;\n+  gfc_use_rename *curr;\n+  gfc_use_rename *kinds_used[ISOCBINDING_NUMBER] = {NULL};\n+  int c_kind;\n+  int i;\n+\n+  for (curr = gfc_rename_list; curr; curr = curr->next)\n+    {\n+      c_kind = get_c_kind (curr->use_name, c_interop_kinds_table);\n+      if (c_kind == ISOCBINDING_INVALID || c_kind == ISOCBINDING_LAST)\n+\t{\n+\t  gfc_error (\"Symbol '%s' referenced at %L does not exist in \"\n+\t\t     \"intrinsic module ISO_C_BINDING.\", curr->use_name,\n+\t\t     &curr->where);\n+\t}\n+      else\n+\t/* Put it in the list.  */\n+\tkinds_used[c_kind] = curr;\n+    }\n+\n+  /* Make a new (sorted) rename list.  */\n+  i = 0;\n+  while (i < ISOCBINDING_NUMBER && kinds_used[i] == NULL)\n+    i++;\n+\n+  if (i < ISOCBINDING_NUMBER)\n+    {\n+      tmp_list = kinds_used[i];\n+\n+      i++;\n+      curr = tmp_list;\n+      for (; i < ISOCBINDING_NUMBER; i++)\n+\tif (kinds_used[i] != NULL)\n+\t  {\n+\t    curr->next = kinds_used[i];\n+\t    curr = curr->next;\n+\t    curr->next = NULL;\n+\t  }\n+    }\n+\n+  gfc_rename_list = tmp_list;\n+}\n+\n+\n+/* Import the instrinsic ISO_C_BINDING module, generating symbols in\n+   the current namespace for all named constants, pointer types, and\n+   procedures in the module unless the only clause was used or a rename\n+   list was provided.  */\n+\n+static void\n+import_iso_c_binding_module (void)\n+{\n+  gfc_symbol *mod_sym = NULL;\n+  gfc_symtree *mod_symtree = NULL;\n+  const char *iso_c_module_name = \"__iso_c_binding\";\n+  gfc_use_rename *u;\n+  int i;\n+  char *local_name;\n+\n+  /* Look only in the current namespace.  */\n+  mod_symtree = gfc_find_symtree (gfc_current_ns->sym_root, iso_c_module_name);\n+\n+  if (mod_symtree == NULL)\n+    {\n+      /* symtree doesn't already exist in current namespace.  */\n+      gfc_get_sym_tree (iso_c_module_name, gfc_current_ns, &mod_symtree);\n+      \n+      if (mod_symtree != NULL)\n+\tmod_sym = mod_symtree->n.sym;\n+      else\n+\tgfc_internal_error (\"import_iso_c_binding_module(): Unable to \"\n+\t\t\t    \"create symbol for %s\", iso_c_module_name);\n+\n+      mod_sym->attr.flavor = FL_MODULE;\n+      mod_sym->attr.intrinsic = 1;\n+      mod_sym->module = gfc_get_string (iso_c_module_name);\n+      mod_sym->from_intmod = INTMOD_ISO_C_BINDING;\n+    }\n+\n+  /* Generate the symbols for the named constants representing\n+     the kinds for intrinsic data types.  */\n+  if (only_flag)\n+    {\n+      /* Sort the rename list because there are dependencies between types\n+\t and procedures (e.g., c_loc needs c_ptr).  */\n+      sort_iso_c_rename_list ();\n+      \n+      for (u = gfc_rename_list; u; u = u->next)\n+\t{\n+\t  i = get_c_kind (u->use_name, c_interop_kinds_table);\n+\n+\t  if (i == ISOCBINDING_INVALID || i == ISOCBINDING_LAST)\n+\t    {\n+\t      gfc_error (\"Symbol '%s' referenced at %L does not exist in \"\n+\t\t\t \"intrinsic module ISO_C_BINDING.\", u->use_name,\n+\t\t\t &u->where);\n+\t      continue;\n+\t    }\n+\t  \n+\t  generate_isocbinding_symbol (iso_c_module_name, i, u->local_name);\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 0; i < ISOCBINDING_NUMBER; i++)\n+\t{\n+\t  local_name = NULL;\n+\t  for (u = gfc_rename_list; u; u = u->next)\n+\t    {\n+\t      if (strcmp (c_interop_kinds_table[i].name, u->use_name) == 0)\n+\t\t{\n+\t\t  local_name = u->local_name;\n+\t\t  u->found = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  generate_isocbinding_symbol (iso_c_module_name, i, local_name);\n+\t}\n+\n+      for (u = gfc_rename_list; u; u = u->next)\n+\t{\n+\t  if (u->found)\n+\t    continue;\n+\n+\t  gfc_error (\"Symbol '%s' referenced at %L not found in intrinsic \"\n+\t\t     \"module ISO_C_BINDING\", u->use_name, &u->where);\n+\t}\n+    }\n+}\n+\n+\n /* Add an integer named constant from a given module.  */\n+\n static void\n-create_int_parameter (const char *name, int value, const char *modname)\n+create_int_parameter (const char *name, int value, const char *modname,\n+\t\t      intmod_id module, int id)\n {\n   gfc_symtree *tmp_symtree;\n   gfc_symbol *sym;\n@@ -4105,6 +4352,8 @@ create_int_parameter (const char *name, int value, const char *modname)\n   sym->ts.kind = gfc_default_integer_kind;\n   sym->value = gfc_int_expr (value);\n   sym->attr.use_assoc = 1;\n+  sym->from_intmod = module;\n+  sym->intmod_sym_id = id;\n }\n \n \n@@ -4120,14 +4369,14 @@ use_iso_fortran_env_module (void)\n   gfc_symtree *mod_symtree;\n   int i;\n \n-  mstring symbol[] = {\n-#define NAMED_INTCST(a,b,c) minit(b,0),\n+  intmod_sym symbol[] = {\n+#define NAMED_INTCST(a,b,c) { a, b, 0 },\n #include \"iso-fortran-env.def\"\n #undef NAMED_INTCST\n-    minit (NULL, -1234) };\n+    { ISOFORTRANENV_INVALID, NULL, -1234 } };\n \n   i = 0;\n-#define NAMED_INTCST(a,b,c) symbol[i++].tag = c;\n+#define NAMED_INTCST(a,b,c) symbol[i++].value = c;\n #include \"iso-fortran-env.def\"\n #undef NAMED_INTCST\n \n@@ -4142,6 +4391,7 @@ use_iso_fortran_env_module (void)\n       mod_sym->attr.flavor = FL_MODULE;\n       mod_sym->attr.intrinsic = 1;\n       mod_sym->module = gfc_get_string (mod);\n+      mod_sym->from_intmod = INTMOD_ISO_FORTRAN_ENV;\n     }\n   else\n     if (!mod_symtree->n.sym->attr.intrinsic)\n@@ -4152,11 +4402,11 @@ use_iso_fortran_env_module (void)\n   if (only_flag)\n     for (u = gfc_rename_list; u; u = u->next)\n       {\n-\tfor (i = 0; symbol[i].string; i++)\n-\t  if (strcmp (symbol[i].string, u->use_name) == 0)\n+\tfor (i = 0; symbol[i].name; i++)\n+\t  if (strcmp (symbol[i].name, u->use_name) == 0)\n \t    break;\n \n-\tif (symbol[i].string == NULL)\n+\tif (symbol[i].name == NULL)\n \t  {\n \t    gfc_error (\"Symbol '%s' referenced at %L does not exist in \"\n \t\t       \"intrinsic module ISO_FORTRAN_ENV\", u->use_name,\n@@ -4165,25 +4415,26 @@ use_iso_fortran_env_module (void)\n \t  }\n \n \tif ((gfc_option.flag_default_integer || gfc_option.flag_default_real)\n-\t    && strcmp (symbol[i].string, \"numeric_storage_size\") == 0)\n+\t    && symbol[i].id == ISOFORTRANENV_NUMERIC_STORAGE_SIZE)\n \t  gfc_warning_now (\"Use of the NUMERIC_STORAGE_SIZE named constant \"\n \t\t\t   \"from intrinsic module ISO_FORTRAN_ENV at %L is \"\n \t\t\t   \"incompatible with option %s\", &u->where,\n \t\t\t   gfc_option.flag_default_integer\n \t\t\t     ? \"-fdefault-integer-8\" : \"-fdefault-real-8\");\n \n \tcreate_int_parameter (u->local_name[0] ? u->local_name\n-\t\t\t\t\t       : symbol[i].string,\n-\t\t\t      symbol[i].tag, mod);\n+\t\t\t\t\t       : symbol[i].name,\n+\t\t\t      symbol[i].value, mod, INTMOD_ISO_FORTRAN_ENV,\n+\t\t\t      symbol[i].id);\n       }\n   else\n     {\n-      for (i = 0; symbol[i].string; i++)\n+      for (i = 0; symbol[i].name; i++)\n \t{\n \t  local_name = NULL;\n \t  for (u = gfc_rename_list; u; u = u->next)\n \t    {\n-\t      if (strcmp (symbol[i].string, u->use_name) == 0)\n+\t      if (strcmp (symbol[i].name, u->use_name) == 0)\n \t\t{\n \t\t  local_name = u->local_name;\n \t\t  u->found = 1;\n@@ -4192,15 +4443,16 @@ use_iso_fortran_env_module (void)\n \t    }\n \n \t  if ((gfc_option.flag_default_integer || gfc_option.flag_default_real)\n-\t      && strcmp (symbol[i].string, \"numeric_storage_size\") == 0)\n+\t      && symbol[i].id == ISOFORTRANENV_NUMERIC_STORAGE_SIZE)\n \t    gfc_warning_now (\"Use of the NUMERIC_STORAGE_SIZE named constant \"\n \t\t\t     \"from intrinsic module ISO_FORTRAN_ENV at %C is \"\n \t\t\t     \"incompatible with option %s\",\n \t\t\t     gfc_option.flag_default_integer\n \t\t\t\t? \"-fdefault-integer-8\" : \"-fdefault-real-8\");\n \n-\t  create_int_parameter (local_name ? local_name : symbol[i].string,\n-\t\t\t\tsymbol[i].tag, mod);\n+\t  create_int_parameter (local_name ? local_name : symbol[i].name,\n+\t\t\t\tsymbol[i].value, mod, INTMOD_ISO_FORTRAN_ENV,\n+\t\t\t\tsymbol[i].id);\n \t}\n \n       for (u = gfc_rename_list; u; u = u->next)\n@@ -4248,11 +4500,19 @@ gfc_use_module (void)\n \t return;\n        }\n \n+      if (strcmp (module_name, \"iso_c_binding\") == 0\n+\t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: \"\n+\t\t\t     \"ISO_C_BINDING module at %C\") != FAILURE)\n+\t{\n+\t  import_iso_c_binding_module();\n+\t  return;\n+\t}\n+\n       module_fp = gfc_open_intrinsic_module (filename);\n \n       if (module_fp == NULL && specified_int)\n-       gfc_fatal_error (\"Can't find an intrinsic module named '%s' at %C\",\n-\t\t\tmodule_name);\n+\tgfc_fatal_error (\"Can't find an intrinsic module named '%s' at %C\",\n+\t\t\t module_name);\n     }\n \n   if (module_fp == NULL)"}, {"sha": "f1f9028605afda401d7761c59d63f045eeadf4de", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -181,6 +181,7 @@ decode_statement (void)\n     case 'b':\n       match (\"backspace\", gfc_match_backspace, ST_BACKSPACE);\n       match (\"block data\", gfc_match_block_data, ST_BLOCK_DATA);\n+      match (NULL, gfc_match_bind_c_stmt, ST_ATTR_DECL);\n       break;\n \n     case 'c':\n@@ -1510,6 +1511,7 @@ parse_derived (void)\n   int compiling_type, seen_private, seen_sequence, seen_component, error_flag;\n   gfc_statement st;\n   gfc_state_data s;\n+  gfc_symbol *derived_sym = NULL;\n   gfc_symbol *sym;\n   gfc_component *c;\n \n@@ -1608,6 +1610,11 @@ parse_derived (void)\n \t}\n     }\n \n+  /* need to verify that all fields of the derived type are\n+   * interoperable with C if the type is declared to be bind(c)\n+   */\n+  derived_sym = gfc_current_block();\n+\n   /* Look for allocatable components.  */\n   sym = gfc_current_block ();\n   for (c = sym->components; c; c = c->next)"}, {"sha": "0e3b6c0a13945f687a151664ed87d586b521e8d8", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -941,6 +941,8 @@ match_string_constant (gfc_expr **result)\n   e->ref = NULL;\n   e->ts.type = BT_CHARACTER;\n   e->ts.kind = kind;\n+  e->ts.is_c_interop = 0;\n+  e->ts.is_iso_c = 0;\n   e->where = start_locus;\n \n   e->value.character.string = p = gfc_getmem (length + 1);\n@@ -1012,6 +1014,8 @@ match_logical_constant (gfc_expr **result)\n   e->value.logical = i;\n   e->ts.type = BT_LOGICAL;\n   e->ts.kind = kind;\n+  e->ts.is_c_interop = 0;\n+  e->ts.is_iso_c = 0;\n   e->where = gfc_current_locus;\n \n   *result = e;\n@@ -1196,6 +1200,8 @@ match_complex_constant (gfc_expr **result)\n     }\n   target.type = BT_REAL;\n   target.kind = kind;\n+  target.is_c_interop = 0;\n+  target.is_iso_c = 0;\n \n   if (real->ts.type != BT_REAL || kind != real->ts.kind)\n     gfc_convert_type (real, &target, 2);\n@@ -2190,6 +2196,25 @@ gfc_match_rvalue (gfc_expr **result)\n \t  break;\n \t}\n \n+      /* Check here for the existence of at least one argument for the\n+         iso_c_binding functions C_LOC, C_FUNLOC, and C_ASSOCIATED.  The\n+         argument(s) given will be checked in gfc_iso_c_func_interface,\n+         during resolution of the function call.  */\n+      if (sym->attr.is_iso_c == 1\n+\t  && (sym->from_intmod == INTMOD_ISO_C_BINDING\n+\t      && (sym->intmod_sym_id == ISOCBINDING_LOC\n+\t\t  || sym->intmod_sym_id == ISOCBINDING_FUNLOC\n+\t\t  || sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)))\n+        {\n+          /* make sure we were given a param */\n+          if (actual_arglist == NULL)\n+            {\n+              gfc_error (\"Missing argument to '%s' at %C\", sym->name);\n+              m = MATCH_ERROR;\n+              break;\n+            }\n+        }\n+\n       if (sym->result == NULL)\n \tsym->result = sym;\n "}, {"sha": "fde5043403c416b9f6e03bebf9ae3415c3761f3b", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 772, "deletions": 1, "changes": 773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -1540,6 +1540,284 @@ pure_function (gfc_expr *e, const char **name)\n }\n \n \n+static try\n+is_scalar_expr_ptr (gfc_expr *expr)\n+{\n+  try retval = SUCCESS;\n+  gfc_ref *ref;\n+  int start;\n+  int end;\n+\n+  /* See if we have a gfc_ref, which means we have a substring, array\n+     reference, or a component.  */\n+  if (expr->ref != NULL)\n+    {\n+      ref = expr->ref;\n+      while (ref->next != NULL)\n+        ref = ref->next;\n+\n+      switch (ref->type)\n+        {\n+        case REF_SUBSTRING:\n+          if (ref->u.ss.length != NULL \n+              && ref->u.ss.length->length != NULL\n+              && ref->u.ss.start\n+              && ref->u.ss.start->expr_type == EXPR_CONSTANT \n+              && ref->u.ss.end\n+              && ref->u.ss.end->expr_type == EXPR_CONSTANT)\n+            {\n+              start = (int) mpz_get_si (ref->u.ss.start->value.integer);\n+              end = (int) mpz_get_si (ref->u.ss.end->value.integer);\n+              if (end - start + 1 != 1)\n+                retval = FAILURE;\n+            }\n+          else\n+            retval = FAILURE;\n+          break;\n+        case REF_ARRAY:\n+          if (ref->u.ar.type == AR_ELEMENT)\n+            retval = SUCCESS;\n+          else if (ref->u.ar.type == AR_FULL)\n+            {\n+              /* The user can give a full array if the array is of size 1.  */\n+              if (ref->u.ar.as != NULL\n+                  && ref->u.ar.as->rank == 1\n+                  && ref->u.ar.as->type == AS_EXPLICIT\n+                  && ref->u.ar.as->lower[0] != NULL\n+                  && ref->u.ar.as->lower[0]->expr_type == EXPR_CONSTANT\n+                  && ref->u.ar.as->upper[0] != NULL\n+                  && ref->u.ar.as->upper[0]->expr_type == EXPR_CONSTANT)\n+                {\n+\t\t  /* If we have a character string, we need to check if\n+\t\t     its length is one.\t */\n+\t\t  if (expr->ts.type == BT_CHARACTER)\n+\t\t    {\n+\t\t      if (expr->ts.cl == NULL\n+\t\t\t  || expr->ts.cl->length == NULL\n+\t\t\t  || mpz_cmp_si (expr->ts.cl->length->value.integer, 1)\n+\t\t\t  != 0)\n+                        retval = FAILURE;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+                  /* We have constant lower and upper bounds.  If the\n+                     difference between is 1, it can be considered a\n+                     scalar.  */\n+                  start = (int) mpz_get_si\n+                                (ref->u.ar.as->lower[0]->value.integer);\n+                  end = (int) mpz_get_si\n+                              (ref->u.ar.as->upper[0]->value.integer);\n+                  if (end - start + 1 != 1)\n+                    retval = FAILURE;\n+                }\n+                }\n+              else\n+                retval = FAILURE;\n+            }\n+          else\n+            retval = FAILURE;\n+          break;\n+        default:\n+          retval = SUCCESS;\n+          break;\n+        }\n+    }\n+  else if (expr->ts.type == BT_CHARACTER && expr->rank == 0)\n+    {\n+      /* Character string.  Make sure it's of length 1.  */\n+      if (expr->ts.cl == NULL\n+          || expr->ts.cl->length == NULL\n+          || mpz_cmp_si (expr->ts.cl->length->value.integer, 1) != 0)\n+        retval = FAILURE;\n+    }\n+  else if (expr->rank != 0)\n+    retval = FAILURE;\n+\n+  return retval;\n+}\n+\n+\n+/* Match one of the iso_c_binding functions (c_associated or c_loc)\n+   and, in the case of c_associated, set the binding label based on\n+   the arguments.  */\n+\n+static try\n+gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n+                          gfc_symbol **new_sym)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  char binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n+  int optional_arg = 0;\n+  try retval = SUCCESS;\n+  gfc_symbol *args_sym;\n+\n+  args_sym = args->expr->symtree->n.sym;\n+   \n+  if (sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n+    {\n+      /* If the user gave two args then they are providing something for\n+\t the optional arg (the second cptr).  Therefore, set the name and\n+\t binding label to the c_associated for two cptrs.  Otherwise,\n+\t set c_associated to expect one cptr.  */\n+      if (args->next)\n+\t{\n+\t  /* two args.  */\n+\t  sprintf (name, \"%s_2\", sym->name);\n+\t  sprintf (binding_label, \"%s_2\", sym->binding_label);\n+\t  optional_arg = 1;\n+\t}\n+      else\n+\t{\n+\t  /* one arg.  */\n+\t  sprintf (name, \"%s_1\", sym->name);\n+\t  sprintf (binding_label, \"%s_1\", sym->binding_label);\n+\t  optional_arg = 0;\n+\t}\n+\n+      /* Get a new symbol for the version of c_associated that\n+\t will get called.  */\n+      *new_sym = get_iso_c_sym (sym, name, binding_label, optional_arg);\n+    }\n+  else if (sym->intmod_sym_id == ISOCBINDING_LOC\n+\t   || sym->intmod_sym_id == ISOCBINDING_FUNLOC)\n+    {\n+      sprintf (name, \"%s\", sym->name);\n+      sprintf (binding_label, \"%s\", sym->binding_label);\n+\n+      /* Error check the call.  */\n+      if (args->next != NULL)\n+        {\n+          gfc_error_now (\"More actual than formal arguments in '%s' \"\n+                         \"call at %L\", name, &(args->expr->where));\n+          retval = FAILURE;\n+        }\n+      else if (sym->intmod_sym_id == ISOCBINDING_LOC)\n+        {\n+          /* Make sure we have either the target or pointer attribute.  */\n+          if (!(args->expr->symtree->n.sym->attr.target)\n+\t      && !(args->expr->symtree->n.sym->attr.pointer))\n+            {\n+              gfc_error_now (\"Parameter '%s' to '%s' at %L must be either \"\n+                             \"a TARGET or an associated pointer\",\n+                             args->expr->symtree->n.sym->name,\n+                             sym->name, &(args->expr->where));\n+              retval = FAILURE;\n+            }\n+\n+          /* See if we have interoperable type and type param.  */\n+          if (verify_c_interop (&(args->expr->symtree->n.sym->ts),\n+                                args->expr->symtree->n.sym->name,\n+                                &(args->expr->where)) == SUCCESS\n+              || gfc_check_any_c_kind (&(args_sym->ts)) == SUCCESS)\n+            {\n+              if (args_sym->attr.target == 1)\n+                {\n+                  /* Case 1a, section 15.1.2.5, J3/04-007: variable that\n+                     has the target attribute and is interoperable.  */\n+                  /* Case 1b, section 15.1.2.5, J3/04-007: allocated\n+                     allocatable variable that has the TARGET attribute and\n+                     is not an array of zero size.  */\n+                  if (args_sym->attr.allocatable == 1)\n+                    {\n+                      if (args_sym->attr.dimension != 0 \n+                          && (args_sym->as && args_sym->as->rank == 0))\n+                        {\n+                          gfc_error_now (\"Allocatable variable '%s' used as a \"\n+                                         \"parameter to '%s' at %L must not be \"\n+                                         \"an array of zero size\",\n+                                         args_sym->name, sym->name,\n+                                         &(args->expr->where));\n+                          retval = FAILURE;\n+                        }\n+                    }\n+                  else\n+                    {\n+                      /* Make sure it's not a character string.  Arrays of\n+                         any type should be ok if the variable is of a C\n+                         interoperable type.  */\n+                      if (args_sym->ts.type == BT_CHARACTER \n+                          && is_scalar_expr_ptr (args->expr) != SUCCESS)\n+                        {\n+                          gfc_error_now (\"CHARACTER argument '%s' to '%s' at \"\n+                                         \"%L must have a length of 1\",\n+                                         args_sym->name, sym->name,\n+                                         &(args->expr->where));\n+                          retval = FAILURE;\n+                        }\n+                    }\n+                }\n+              else if (args_sym->attr.pointer == 1\n+                       && is_scalar_expr_ptr (args->expr) != SUCCESS)\n+                {\n+                  /* Case 1c, section 15.1.2.5, J3/04-007: an associated\n+                     scalar pointer.  */\n+                  gfc_error_now (\"Argument '%s' to '%s' at %L must be an \"\n+                                 \"associated scalar POINTER\", args_sym->name,\n+                                 sym->name, &(args->expr->where));\n+                  retval = FAILURE;\n+                }\n+            }\n+          else\n+            {\n+              /* The parameter is not required to be C interoperable.  If it\n+                 is not C interoperable, it must be a nonpolymorphic scalar\n+                 with no length type parameters.  It still must have either\n+                 the pointer or target attribute, and it can be\n+                 allocatable (but must be allocated when c_loc is called).  */\n+              if (args_sym->attr.dimension != 0\n+                  && is_scalar_expr_ptr (args->expr) != SUCCESS)\n+                {\n+                  gfc_error_now (\"Parameter '%s' to '%s' at %L must be a \"\n+                                 \"scalar\", args_sym->name, sym->name,\n+                                 &(args->expr->where));\n+                  retval = FAILURE;\n+                }\n+              else if (args_sym->ts.type == BT_CHARACTER \n+                       && args_sym->ts.cl != NULL)\n+                {\n+                  gfc_error_now (\"CHARACTER parameter '%s' to '%s' at %L \"\n+                                 \"cannot have a length type parameter\",\n+                                 args_sym->name, sym->name,\n+                                 &(args->expr->where));\n+                  retval = FAILURE;\n+                }\n+            }\n+        }\n+      else if (sym->intmod_sym_id == ISOCBINDING_FUNLOC)\n+        {\n+          if (args->expr->symtree->n.sym->attr.flavor != FL_PROCEDURE)\n+            {\n+              /* TODO: Update this error message to allow for procedure\n+                 pointers once they are implemented.  */\n+              gfc_error_now (\"Parameter '%s' to '%s' at %L must be a \"\n+                             \"procedure\",\n+                             args->expr->symtree->n.sym->name, sym->name,\n+                             &(args->expr->where));\n+              retval = FAILURE;\n+            }\n+          else if (args->expr->symtree->n.sym->attr.is_c_interop != 1)\n+            {\n+              gfc_error_now (\"Parameter '%s' to '%s' at %L must be C \"\n+                             \"interoperable\",\n+                             args->expr->symtree->n.sym->name, sym->name,\n+                             &(args->expr->where));\n+              retval = FAILURE;\n+            }\n+        }\n+      \n+      /* for c_loc/c_funloc, the new symbol is the same as the old one */\n+      *new_sym = sym;\n+    }\n+  else\n+    {\n+      gfc_internal_error (\"gfc_iso_c_func_interface(): Unhandled \"\n+\t\t\t  \"iso_c_binding function: '%s'!\\n\", sym->name);\n+    }\n+\n+  return retval;\n+}\n+\n+\n /* Resolve a function call, which means resolving the arguments, then figuring\n    out which entity the name refers to.  */\n /* TODO: Check procedure arguments so that an INTENT(IN) isn't passed\n@@ -1583,7 +1861,20 @@ resolve_function (gfc_expr *expr)\n   if (resolve_actual_arglist (expr->value.function.actual, p) == FAILURE)\n       return FAILURE;\n \n-  /* Resume assumed_size checking. */\n+  /* Need to setup the call to the correct c_associated, depending on\n+     the number of cptrs to user gives to compare.  */\n+  if (sym && sym->attr.is_iso_c == 1)\n+    {\n+      if (gfc_iso_c_func_interface (sym, expr->value.function.actual, &sym)\n+          == FAILURE)\n+        return FAILURE;\n+      \n+      /* Get the symtree for the new symbol (resolved func).\n+         the old one will be freed later, when it's no longer used.  */\n+      gfc_find_sym_tree (sym->name, sym->ns, 1, &(expr->symtree));\n+    }\n+  \n+  /* Resume assumed_size checking.  */\n   need_full_assumed_size--;\n \n   if (sym && sym->ts.type == BT_CHARACTER\n@@ -1850,13 +2141,177 @@ resolve_generic_s (gfc_code *c)\n }\n \n \n+/* Set the name and binding label of the subroutine symbol in the call\n+   expression represented by 'c' to include the type and kind of the\n+   second parameter.  This function is for resolving the appropriate\n+   version of c_f_pointer() and c_f_procpointer().  For example, a\n+   call to c_f_pointer() for a default integer pointer could have a\n+   name of c_f_pointer_i4.  If no second arg exists, which is an error\n+   for these two functions, it defaults to the generic symbol's name\n+   and binding label.  */\n+\n+static void\n+set_name_and_label (gfc_code *c, gfc_symbol *sym,\n+                    char *name, char *binding_label)\n+{\n+  gfc_expr *arg = NULL;\n+  char type;\n+  int kind;\n+\n+  /* The second arg of c_f_pointer and c_f_procpointer determines\n+     the type and kind for the procedure name.  */\n+  arg = c->ext.actual->next->expr;\n+\n+  if (arg != NULL)\n+    {\n+      /* Set up the name to have the given symbol's name,\n+         plus the type and kind.  */\n+      /* a derived type is marked with the type letter 'u' */\n+      if (arg->ts.type == BT_DERIVED)\n+        {\n+          type = 'd';\n+          kind = 0; /* set the kind as 0 for now */\n+        }\n+      else\n+        {\n+          type = gfc_type_letter (arg->ts.type);\n+          kind = arg->ts.kind;\n+        }\n+      sprintf (name, \"%s_%c%d\", sym->name, type, kind);\n+      /* Set up the binding label as the given symbol's label plus\n+         the type and kind.  */\n+      sprintf (binding_label, \"%s_%c%d\", sym->binding_label, type, kind);\n+    }\n+  else\n+    {\n+      /* If the second arg is missing, set the name and label as\n+         was, cause it should at least be found, and the missing\n+         arg error will be caught by compare_parameters().  */\n+      sprintf (name, \"%s\", sym->name);\n+      sprintf (binding_label, \"%s\", sym->binding_label);\n+    }\n+   \n+  return;\n+}\n+\n+\n+/* Resolve a generic version of the iso_c_binding procedure given\n+   (sym) to the specific one based on the type and kind of the\n+   argument(s).  Currently, this function resolves c_f_pointer() and\n+   c_f_procpointer based on the type and kind of the second argument\n+   (FPTR).  Other iso_c_binding procedures aren't specially handled.\n+   Upon successfully exiting, c->resolved_sym will hold the resolved\n+   symbol.  Returns MATCH_ERROR if an error occurred; MATCH_YES\n+   otherwise.  */\n+\n+match\n+gfc_iso_c_sub_interface (gfc_code *c, gfc_symbol *sym)\n+{\n+  gfc_symbol *new_sym;\n+  /* this is fine, since we know the names won't use the max */\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  char binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n+  /* default to success; will override if find error */\n+  match m = MATCH_YES;\n+  gfc_symbol *tmp_sym;\n+\n+  if ((sym->intmod_sym_id == ISOCBINDING_F_POINTER) ||\n+      (sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER))\n+    {\n+      set_name_and_label (c, sym, name, binding_label);\n+      \n+      if (sym->intmod_sym_id == ISOCBINDING_F_POINTER)\n+\t{\n+\t  if (c->ext.actual != NULL && c->ext.actual->next != NULL)\n+\t    {\n+\t      /* Make sure we got a third arg.\tThe type/rank of it will\n+\t\t be checked later if it's there (gfc_procedure_use()).\t*/\n+\t      if (c->ext.actual->next->expr->rank != 0 &&\n+\t\t  c->ext.actual->next->next == NULL)\n+\t\t{\n+\t\t  m = MATCH_ERROR;\n+\t\t  gfc_error (\"Missing SHAPE parameter for call to %s \"\n+\t\t\t     \"at %L\", sym->name, &(c->loc));\n+\t\t}\n+              /* Make sure the param is a POINTER.  No need to make sure\n+                 it does not have INTENT(IN) since it is a POINTER.  */\n+              tmp_sym = c->ext.actual->next->expr->symtree->n.sym;\n+              if (tmp_sym != NULL && tmp_sym->attr.pointer != 1)\n+                {\n+                  gfc_error (\"Argument '%s' to '%s' at %L \"\n+                             \"must have the POINTER attribute\",\n+                             tmp_sym->name, sym->name, &(c->loc));\n+                  m = MATCH_ERROR;\n+                }\n+\t    }\n+\t}\n+      \n+      if (m != MATCH_ERROR)\n+\t{\n+\t  /* the 1 means to add the optional arg to formal list */\n+\t  new_sym = get_iso_c_sym (sym, name, binding_label, 1);\n+\t \n+\t  /* for error reporting, say it's declared where the original was */\n+\t  new_sym->declared_at = sym->declared_at;\n+\t}\n+    }\n+  else if (sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n+    {\n+      /* TODO: Figure out if this is even reacable; this part of the\n+         conditional may not be necessary.  */\n+      int num_args = 0;\n+      if (c->ext.actual->next == NULL)\n+\t{\n+\t  /* The user did not give two args, so resolve to the version\n+\t     of c_associated expecting one arg.\t */\n+\t  num_args = 1;\n+\t  /* get rid of the second arg */\n+\t  /* TODO!! Should free up the memory here!  */\n+\t  sym->formal->next = NULL;\n+\t}\n+      else\n+\t{\n+\t  num_args = 2;\n+\t}\n+\n+      new_sym = sym;\n+      sprintf (name, \"%s_%d\", sym->name, num_args);\n+      sprintf (binding_label, \"%s_%d\", sym->binding_label, num_args);\n+      sym->name = gfc_get_string (name);\n+      strcpy (sym->binding_label, binding_label);\n+    }\n+  else\n+    {\n+      /* no differences for c_loc or c_funloc */\n+      new_sym = sym;\n+    }\n+\n+  /* set the resolved symbol */\n+  if (m != MATCH_ERROR)\n+    {\n+      gfc_procedure_use (new_sym, &c->ext.actual, &c->loc);\n+      c->resolved_sym = new_sym;\n+    }\n+  else\n+    c->resolved_sym = sym;\n+  \n+  return m;\n+}\n+\n+\n /* Resolve a subroutine call known to be specific.  */\n \n static match\n resolve_specific_s0 (gfc_code *c, gfc_symbol *sym)\n {\n   match m;\n \n+  if(sym->attr.is_iso_c)\n+    {\n+      m = gfc_iso_c_sub_interface (c,sym);\n+      return m;\n+    }\n+  \n   if (sym->attr.external || sym->attr.if_source == IFSRC_IFBODY)\n     {\n       if (sym->attr.dummy)\n@@ -5498,6 +5953,206 @@ resolve_values (gfc_symbol *sym)\n }\n \n \n+/* Verify the binding labels for common blocks that are BIND(C).  The label\n+   for a BIND(C) common block must be identical in all scoping units in which\n+   the common block is declared.  Further, the binding label can not collide\n+   with any other global entity in the program.  */\n+\n+static void\n+resolve_bind_c_comms (gfc_symtree *comm_block_tree)\n+{\n+  if (comm_block_tree->n.common->is_bind_c == 1)\n+    {\n+      gfc_gsymbol *binding_label_gsym;\n+      gfc_gsymbol *comm_name_gsym;\n+\n+      /* See if a global symbol exists by the common block's name.  It may\n+         be NULL if the common block is use-associated.  */\n+      comm_name_gsym = gfc_find_gsymbol (gfc_gsym_root,\n+                                         comm_block_tree->n.common->name);\n+      if (comm_name_gsym != NULL && comm_name_gsym->type != GSYM_COMMON)\n+        gfc_error (\"Binding label '%s' for common block '%s' at %L collides \"\n+                   \"with the global entity '%s' at %L\",\n+                   comm_block_tree->n.common->binding_label,\n+                   comm_block_tree->n.common->name,\n+                   &(comm_block_tree->n.common->where),\n+                   comm_name_gsym->name, &(comm_name_gsym->where));\n+      else if (comm_name_gsym != NULL\n+\t       && strcmp (comm_name_gsym->name,\n+\t\t\t  comm_block_tree->n.common->name) == 0)\n+        {\n+          /* TODO: Need to make sure the fields of gfc_gsymbol are initialized\n+             as expected.  */\n+          if (comm_name_gsym->binding_label == NULL)\n+            /* No binding label for common block stored yet; save this one.  */\n+            comm_name_gsym->binding_label =\n+              comm_block_tree->n.common->binding_label;\n+          else\n+            if (strcmp (comm_name_gsym->binding_label,\n+                        comm_block_tree->n.common->binding_label) != 0)\n+              {\n+                /* Common block names match but binding labels do not.  */\n+                gfc_error (\"Binding label '%s' for common block '%s' at %L \"\n+                           \"does not match the binding label '%s' for common \"\n+                           \"block '%s' at %L\",\n+                           comm_block_tree->n.common->binding_label,\n+                           comm_block_tree->n.common->name,\n+                           &(comm_block_tree->n.common->where),\n+                           comm_name_gsym->binding_label,\n+                           comm_name_gsym->name,\n+                           &(comm_name_gsym->where));\n+                return;\n+              }\n+        }\n+\n+      /* There is no binding label (NAME=\"\") so we have nothing further to\n+         check and nothing to add as a global symbol for the label.  */\n+      if (comm_block_tree->n.common->binding_label[0] == '\\0' )\n+        return;\n+      \n+      binding_label_gsym =\n+        gfc_find_gsymbol (gfc_gsym_root,\n+                          comm_block_tree->n.common->binding_label);\n+      if (binding_label_gsym == NULL)\n+        {\n+          /* Need to make a global symbol for the binding label to prevent\n+             it from colliding with another.  */\n+          binding_label_gsym =\n+            gfc_get_gsymbol (comm_block_tree->n.common->binding_label);\n+          binding_label_gsym->sym_name = comm_block_tree->n.common->name;\n+          binding_label_gsym->type = GSYM_COMMON;\n+        }\n+      else\n+        {\n+          /* If comm_name_gsym is NULL, the name common block is use\n+             associated and the name could be colliding.  */\n+          if (binding_label_gsym->type != GSYM_COMMON)\n+            gfc_error (\"Binding label '%s' for common block '%s' at %L \"\n+                       \"collides with the global entity '%s' at %L\",\n+                       comm_block_tree->n.common->binding_label,\n+                       comm_block_tree->n.common->name,\n+                       &(comm_block_tree->n.common->where),\n+                       binding_label_gsym->name,\n+                       &(binding_label_gsym->where));\n+          else if (comm_name_gsym != NULL\n+\t\t   && (strcmp (binding_label_gsym->name,\n+\t\t\t       comm_name_gsym->binding_label) != 0)\n+\t\t   && (strcmp (binding_label_gsym->sym_name,\n+\t\t\t       comm_name_gsym->name) != 0))\n+            gfc_error (\"Binding label '%s' for common block '%s' at %L \"\n+                       \"collides with global entity '%s' at %L\",\n+                       binding_label_gsym->name, binding_label_gsym->sym_name,\n+                       &(comm_block_tree->n.common->where),\n+                       comm_name_gsym->name, &(comm_name_gsym->where));\n+        }\n+    }\n+  \n+  return;\n+}\n+\n+\n+/* Verify any BIND(C) derived types in the namespace so we can report errors\n+   for them once, rather than for each variable declared of that type.  */\n+\n+static void\n+resolve_bind_c_derived_types (gfc_symbol *derived_sym)\n+{\n+  if (derived_sym != NULL && derived_sym->attr.flavor == FL_DERIVED\n+      && derived_sym->attr.is_bind_c == 1)\n+    verify_bind_c_derived_type (derived_sym);\n+  \n+  return;\n+}\n+\n+\n+/* Verify that any binding labels used in a given namespace do not collide \n+   with the names or binding labels of any global symbols.  */\n+\n+static void\n+gfc_verify_binding_labels (gfc_symbol *sym)\n+{\n+  int has_error = 0;\n+  \n+  if (sym != NULL && sym->attr.is_bind_c && sym->attr.is_iso_c == 0 \n+      && sym->attr.flavor != FL_DERIVED && sym->binding_label[0] != '\\0')\n+    {\n+      gfc_gsymbol *bind_c_sym;\n+\n+      bind_c_sym = gfc_find_gsymbol (gfc_gsym_root, sym->binding_label);\n+      if (bind_c_sym != NULL \n+          && strcmp (bind_c_sym->name, sym->binding_label) == 0)\n+        {\n+          if (sym->attr.if_source == IFSRC_DECL \n+              && (bind_c_sym->type != GSYM_SUBROUTINE \n+                  && bind_c_sym->type != GSYM_FUNCTION) \n+              && ((sym->attr.contained == 1 \n+                   && strcmp (bind_c_sym->sym_name, sym->name) != 0) \n+                  || (sym->attr.use_assoc == 1 \n+                      && (strcmp (bind_c_sym->mod_name, sym->module) != 0))))\n+            {\n+              /* Make sure global procedures don't collide with anything.  */\n+              gfc_error (\"Binding label '%s' at %L collides with the global \"\n+                         \"entity '%s' at %L\", sym->binding_label,\n+                         &(sym->declared_at), bind_c_sym->name,\n+                         &(bind_c_sym->where));\n+              has_error = 1;\n+            }\n+          else if (sym->attr.contained == 0 \n+                   && (sym->attr.if_source == IFSRC_IFBODY \n+                       && sym->attr.flavor == FL_PROCEDURE) \n+                   && (bind_c_sym->sym_name != NULL \n+                       && strcmp (bind_c_sym->sym_name, sym->name) != 0))\n+            {\n+              /* Make sure procedures in interface bodies don't collide.  */\n+              gfc_error (\"Binding label '%s' in interface body at %L collides \"\n+                         \"with the global entity '%s' at %L\",\n+                         sym->binding_label,\n+                         &(sym->declared_at), bind_c_sym->name,\n+                         &(bind_c_sym->where));\n+              has_error = 1;\n+            }\n+          else if (sym->attr.contained == 0 \n+                   && (sym->attr.if_source == IFSRC_UNKNOWN))\n+            if ((sym->attr.use_assoc \n+                 && (strcmp (bind_c_sym->mod_name, sym->module) != 0)) \n+                || sym->attr.use_assoc == 0)\n+              {\n+                gfc_error (\"Binding label '%s' at %L collides with global \"\n+                           \"entity '%s' at %L\", sym->binding_label,\n+                           &(sym->declared_at), bind_c_sym->name,\n+                           &(bind_c_sym->where));\n+                has_error = 1;\n+              }\n+\n+          if (has_error != 0)\n+            /* Clear the binding label to prevent checking multiple times.  */\n+            sym->binding_label[0] = '\\0';\n+        }\n+      else if (bind_c_sym == NULL)\n+\t{\n+\t  bind_c_sym = gfc_get_gsymbol (sym->binding_label);\n+\t  bind_c_sym->where = sym->declared_at;\n+\t  bind_c_sym->sym_name = sym->name;\n+\n+          if (sym->attr.use_assoc == 1)\n+            bind_c_sym->mod_name = sym->module;\n+          else\n+            if (sym->ns->proc_name != NULL)\n+              bind_c_sym->mod_name = sym->ns->proc_name->name;\n+\n+          if (sym->attr.contained == 0)\n+            {\n+              if (sym->attr.subroutine)\n+                bind_c_sym->type = GSYM_SUBROUTINE;\n+              else if (sym->attr.function)\n+                bind_c_sym->type = GSYM_FUNCTION;\n+            }\n+        }\n+    }\n+  return;\n+}\n+\n+\n /* Resolve an index expression.  */\n \n static try\n@@ -6013,6 +6668,45 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t\t\t\"'%s' at %L is obsolescent in fortran 95\",\n \t\t\tsym->name, &sym->declared_at);\n     }\n+\n+  if (sym->attr.is_bind_c && sym->attr.is_c_interop != 1)\n+    {\n+      gfc_formal_arglist *curr_arg;\n+\n+      if (verify_bind_c_sym (sym, &(sym->ts), sym->attr.in_common,\n+                             sym->common_block) == FAILURE)\n+        {\n+          /* Clear these to prevent looking at them again if there was an\n+             error.  */\n+          sym->attr.is_bind_c = 0;\n+          sym->attr.is_c_interop = 0;\n+          sym->ts.is_c_interop = 0;\n+        }\n+      else\n+        {\n+          /* So far, no errors have been found.  */\n+          sym->attr.is_c_interop = 1;\n+          sym->ts.is_c_interop = 1;\n+        }\n+      \n+      curr_arg = sym->formal;\n+      while (curr_arg != NULL)\n+        {\n+          /* Skip implicitly typed dummy args here.  */\n+          if (curr_arg->sym->attr.implicit_type == 0\n+\t      && verify_c_interop_param (curr_arg->sym) == FAILURE)\n+            {\n+              /* If something is found to fail, mark the symbol for the\n+                 procedure as not being BIND(C) to try and prevent multiple\n+                 errors being reported.  */\n+              sym->attr.is_c_interop = 0;\n+              sym->ts.is_c_interop = 0;\n+              sym->attr.is_bind_c = 0;\n+            }\n+          curr_arg = curr_arg->next;\n+        }\n+    }\n+  \n   return SUCCESS;\n }\n \n@@ -6381,6 +7075,76 @@ resolve_symbol (gfc_symbol *sym)\n \t\t     sym->name, &sym->declared_at);\n \t  return;\n \t}\n+\n+      if (sym->ts.is_c_interop\n+\t  && mpz_cmp_si (cl->length->value.integer, 1) != 0)\n+\t{\n+\t  gfc_error (\"C interoperable character dummy variable '%s' at %L \"\n+\t\t     \"with VALUE attribute must have length one\",\n+\t\t     sym->name, &sym->declared_at);\n+\t  return;\n+\t}\n+    }\n+\n+  /* If the symbol is marked as bind(c), verify it's type and kind.  Do not\n+     do this for something that was implicitly typed because that is handled\n+     in gfc_set_default_type.  Handle dummy arguments and procedure\n+     definitions separately.  Also, anything that is use associated is not\n+     handled here but instead is handled in the module it is declared in.\n+     Finally, derived type definitions are allowed to be BIND(C) since that\n+     only implies that they're interoperable, and they are checked fully for\n+     interoperability when a variable is declared of that type.  */\n+  if (sym->attr.is_bind_c && sym->attr.implicit_type == 0 &&\n+      sym->attr.use_assoc == 0 && sym->attr.dummy == 0 &&\n+      sym->attr.flavor != FL_PROCEDURE && sym->attr.flavor != FL_DERIVED)\n+    {\n+      try t = SUCCESS;\n+      \n+      /* First, make sure the variable is declared at the\n+\t module-level scope (J3/04-007, Section 15.3).\t*/\n+      if (sym->ns->proc_name->attr.flavor != FL_MODULE &&\n+          sym->attr.in_common == 0)\n+\t{\n+\t  gfc_error (\"Variable '%s' at %L cannot be BIND(C) because it \"\n+\t\t     \"is neither a COMMON block nor declared at the \"\n+\t\t     \"module level scope\", sym->name, &(sym->declared_at));\n+\t  t = FAILURE;\n+\t}\n+      else if (sym->common_head != NULL)\n+        {\n+          t = verify_com_block_vars_c_interop (sym->common_head);\n+        }\n+      else\n+\t{\n+\t  /* If type() declaration, we need to verify that the components\n+\t     of the given type are all C interoperable, etc.  */\n+\t  if (sym->ts.type == BT_DERIVED &&\n+              sym->ts.derived->attr.is_c_interop != 1)\n+            {\n+              /* Make sure the user marked the derived type as BIND(C).  If\n+                 not, call the verify routine.  This could print an error\n+                 for the derived type more than once if multiple variables\n+                 of that type are declared.  */\n+              if (sym->ts.derived->attr.is_bind_c != 1)\n+                verify_bind_c_derived_type (sym->ts.derived);\n+              t = FAILURE;\n+            }\n+\t  \n+\t  /* Verify the variable itself as C interoperable if it\n+             is BIND(C).  It is not possible for this to succeed if\n+             the verify_bind_c_derived_type failed, so don't have to handle\n+             any error returned by verify_bind_c_derived_type.  */\n+          t = verify_bind_c_sym (sym, &(sym->ts), sym->attr.in_common,\n+                                 sym->common_block);\n+\t}\n+\n+      if (t == FAILURE)\n+        {\n+          /* clear the is_bind_c flag to prevent reporting errors more than\n+             once if something failed.  */\n+          sym->attr.is_bind_c = 0;\n+          return;\n+        }\n     }\n \n   /* If a derived type symbol has reached this point, without its\n@@ -7428,6 +8192,8 @@ resolve_types (gfc_namespace *ns)\n \n   resolve_contained_functions (ns);\n \n+  gfc_traverse_ns (ns, resolve_bind_c_derived_types);\n+\n   for (cl = ns->cl_list; cl; cl = cl->next)\n     resolve_charlen (cl);\n \n@@ -7460,6 +8226,11 @@ resolve_types (gfc_namespace *ns)\n   iter_stack = NULL;\n   gfc_traverse_ns (ns, gfc_formalize_init_value);\n \n+  gfc_traverse_ns (ns, gfc_verify_binding_labels);\n+\n+  if (ns->common_root != NULL)\n+    gfc_traverse_symtree (ns->common_root, resolve_bind_c_comms);\n+\n   for (eq = ns->equiv; eq; eq = eq->next)\n     resolve_equivalence (eq);\n "}, {"sha": "867c6ef802680ca2aaa8a3632c2967a984193fec", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 954, "deletions": 10, "changes": 964, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -27,6 +27,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"gfortran.h\"\n #include \"parse.h\"\n \n+\n /* Strings for all symbol attributes.  We use these for dumping the\n    parse tree, in error messages, and also when reading and writing\n    modules.  */\n@@ -249,6 +250,32 @@ gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n   sym->ts = *ts;\n   sym->attr.implicit_type = 1;\n \n+  if (sym->attr.is_bind_c == 1)\n+    {\n+      /* BIND(C) variables should not be implicitly declared.  */\n+      gfc_warning_now (\"Implicitly declared BIND(C) variable '%s' at %L may \"\n+                       \"not be C interoperable\", sym->name, &sym->declared_at);\n+      sym->ts.f90_type = sym->ts.type;\n+    }\n+\n+  if (sym->attr.dummy != 0)\n+    {\n+      if (sym->ns->proc_name != NULL\n+\t  && (sym->ns->proc_name->attr.subroutine != 0\n+\t      || sym->ns->proc_name->attr.function != 0)\n+\t  && sym->ns->proc_name->attr.is_bind_c != 0)\n+        {\n+          /* Dummy args to a BIND(C) routine may not be interoperable if\n+             they are implicitly typed.  */\n+          gfc_warning_now (\"Implicity declared variable '%s' at %L may not \"\n+                           \"be C interoperable but it is a dummy argument to \"\n+                           \"the BIND(C) procedure '%s' at %L\", sym->name,\n+                           &(sym->declared_at), sym->ns->proc_name->name,\n+                           &(sym->ns->proc_name->declared_at));\n+          sym->ts.f90_type = sym->ts.type;\n+        }\n+    }\n+  \n   return SUCCESS;\n }\n \n@@ -319,7 +346,8 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n     *dimension = \"DIMENSION\", *in_equivalence = \"EQUIVALENCE\",\n     *use_assoc = \"USE ASSOCIATED\", *cray_pointer = \"CRAY POINTER\",\n     *cray_pointee = \"CRAY POINTEE\", *data = \"DATA\", *value = \"VALUE\",\n-    *volatile_ = \"VOLATILE\", *protected = \"PROTECTED\";\n+    *volatile_ = \"VOLATILE\", *protected = \"PROTECTED\",\n+    *is_bind_c = \"BIND(C)\";\n   static const char *threadprivate = \"THREADPRIVATE\";\n \n   const char *a1, *a2;\n@@ -370,7 +398,6 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (dummy, save);\n   conf (dummy, threadprivate);\n   conf (pointer, target);\n-  conf (pointer, external);\n   conf (pointer, intrinsic);\n   conf (pointer, elemental);\n   conf (allocatable, elemental);\n@@ -418,6 +445,17 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \n   conf (function, subroutine);\n \n+  if (!function && !subroutine)\n+    conf (is_bind_c, dummy);\n+\n+  conf (is_bind_c, cray_pointer);\n+  conf (is_bind_c, cray_pointee);\n+  conf (is_bind_c, allocatable);\n+\n+  /* Need to also get volatile attr, according to 5.1 of F2003 draft.\n+     Parameter conflict caught below.  Also, value cannot be specified\n+     for a dummy procedure.  */\n+\n   /* Cray pointer/pointee conflicts.  */\n   conf (cray_pointer, cray_pointee);\n   conf (cray_pointer, dimension);\n@@ -449,10 +487,6 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (data, allocatable);\n   conf (data, use_assoc);\n \n-  conf (protected, intrinsic)\n-  conf (protected, external)\n-  conf (protected, in_common)\n-\n   conf (value, pointer)\n   conf (value, allocatable)\n   conf (value, subroutine)\n@@ -469,6 +503,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       goto conflict;\n     }\n \n+  conf (protected, intrinsic)\n+  conf (protected, external)\n+  conf (protected, in_common)\n+\n   conf (volatile_, intrinsic)\n   conf (volatile_, external)\n \n@@ -596,6 +634,8 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       conf2 (value);\n       conf2 (volatile_);\n       conf2 (threadprivate);\n+      /* TODO: hmm, double check this.  */\n+      conf2 (value);\n       break;\n \n     default:\n@@ -1269,9 +1309,35 @@ gfc_add_access (symbol_attribute *attr, gfc_access access,\n }\n \n \n+/* Set the is_bind_c field for the given symbol_attribute.  */\n+\n+try\n+gfc_add_is_bind_c (symbol_attribute *attr, const char *name, locus *where,\n+                   int is_proc_lang_bind_spec)\n+{\n+\n+  if (is_proc_lang_bind_spec == 0 && attr->flavor == FL_PROCEDURE)\n+    gfc_error_now (\"BIND(C) attribute at %L can only be used for \"\n+\t\t   \"variables or common blocks\", where);\n+  else if (attr->is_bind_c)\n+    gfc_error_now (\"Duplicate BIND attribute specified at %L\", where);\n+  else\n+    attr->is_bind_c = 1;\n+  \n+  if (where == NULL)\n+    where = &gfc_current_locus;\n+   \n+  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: BIND(C) at %L\", where)\n+      == FAILURE)\n+    return FAILURE;\n+\n+  return check_conflict (attr, name, where);\n+}\n+\n+\n try\n-gfc_add_explicit_interface (gfc_symbol * sym, ifsrc source,\n-\t\t\t    gfc_formal_arglist * formal, locus * where)\n+gfc_add_explicit_interface (gfc_symbol *sym, ifsrc source,\n+\t\t\t    gfc_formal_arglist * formal, locus *where)\n {\n \n   if (check_used (&sym->attr, sym->name, where))\n@@ -1363,9 +1429,10 @@ gfc_missing_attr (symbol_attribute *attr ATTRIBUTE_UNUSED,\n    where we are called from, so we ignore some bits.  */\n \n try\n-gfc_copy_attr (symbol_attribute * dest, symbol_attribute * src, locus * where)\n+gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n {\n-\n+  int is_proc_lang_bind_spec;\n+  \n   if (src->allocatable && gfc_add_allocatable (dest, where) == FAILURE)\n     goto fail;\n \n@@ -1437,6 +1504,17 @@ gfc_copy_attr (symbol_attribute * dest, symbol_attribute * src, locus * where)\n   if (src->cray_pointee && gfc_add_cray_pointee (dest, where) == FAILURE)\n     goto fail;    \n \n+  is_proc_lang_bind_spec = (src->flavor == FL_PROCEDURE ? 1 : 0);\n+  if (src->is_bind_c\n+      && gfc_add_is_bind_c (dest, NULL, where, is_proc_lang_bind_spec)\n+\t != SUCCESS)\n+    return FAILURE;\n+\n+  if (src->is_c_interop)\n+    dest->is_c_interop = 1;\n+  if (src->is_iso_c)\n+    dest->is_iso_c = 1;\n+  \n   if (src->external && gfc_add_external (dest, where) == FAILURE)\n     goto fail;\n   if (src->intrinsic && gfc_add_intrinsic (dest, where) == FAILURE)\n@@ -2087,6 +2165,16 @@ gfc_new_symbol (const char *name, gfc_namespace *ns)\n     gfc_internal_error (\"new_symbol(): Symbol name too long\");\n \n   p->name = gfc_get_string (name);\n+\n+  /* Make sure flags for symbol being C bound are clear initially.  */\n+  p->attr.is_bind_c = 0;\n+  p->attr.is_iso_c = 0;\n+  /* Make sure the binding label field has a Nul char to start.  */\n+  p->binding_label[0] = '\\0';\n+\n+  /* Clear the ptrs we may need.  */\n+  p->common_block = NULL;\n+  \n   return p;\n }\n \n@@ -2872,3 +2960,859 @@ gfc_get_gsymbol (const char *name)\n \n   return s;\n }\n+\n+\n+static gfc_symbol *\n+get_iso_c_binding_dt (int sym_id)\n+{\n+  gfc_dt_list *dt_list;\n+\n+  dt_list = gfc_derived_types;\n+\n+  /* Loop through the derived types in the name list, searching for\n+     the desired symbol from iso_c_binding.  Search the parent namespaces\n+     if necessary and requested to (parent_flag).  */\n+  while (dt_list != NULL)\n+    {\n+      if (dt_list->derived->from_intmod != INTMOD_NONE\n+\t  && dt_list->derived->intmod_sym_id == sym_id)\n+        return dt_list->derived;\n+\n+      dt_list = dt_list->next;\n+    }\n+\n+  return NULL;\n+}\n+\n+\n+/* Verifies that the given derived type symbol, derived_sym, is interoperable\n+   with C.  This is necessary for any derived type that is BIND(C) and for\n+   derived types that are parameters to functions that are BIND(C).  All\n+   fields of the derived type are required to be interoperable, and are tested\n+   for such.  If an error occurs, the errors are reported here, allowing for\n+   multiple errors to be handled for a single derived type.  */\n+\n+try\n+verify_bind_c_derived_type (gfc_symbol *derived_sym)\n+{\n+  gfc_component *curr_comp = NULL;\n+  try is_c_interop = FAILURE;\n+  try retval = SUCCESS;\n+   \n+  if (derived_sym == NULL)\n+    gfc_internal_error (\"verify_bind_c_derived_type(): Given symbol is \"\n+                        \"unexpectedly NULL\");\n+\n+  /* If we've already looked at this derived symbol, do not look at it again\n+     so we don't repeat warnings/errors.  */\n+  if (derived_sym->ts.is_c_interop)\n+    return SUCCESS;\n+  \n+  /* The derived type must have the BIND attribute to be interoperable\n+     J3/04-007, Section 15.2.3.  */\n+  if (derived_sym->attr.is_bind_c != 1)\n+    {\n+      derived_sym->ts.is_c_interop = 0;\n+      gfc_error_now (\"Derived type '%s' declared at %L must have the BIND \"\n+                     \"attribute to be C interoperable\", derived_sym->name,\n+                     &(derived_sym->declared_at));\n+      retval = FAILURE;\n+    }\n+  \n+  curr_comp = derived_sym->components;\n+\n+  /* TODO: is this really an error?  */\n+  if (curr_comp == NULL)\n+    {\n+      gfc_error (\"Derived type '%s' at %L is empty\",\n+\t\t derived_sym->name, &(derived_sym->declared_at));\n+      return FAILURE;\n+    }\n+\n+  /* Initialize the derived type as being C interoperable.\n+     If we find an error in the components, this will be set false.  */\n+  derived_sym->ts.is_c_interop = 1;\n+  \n+  /* Loop through the list of components to verify that the kind of\n+     each is a C interoperable type.  */\n+  do\n+    {\n+      /* The components cannot be pointers (fortran sense).  \n+         J3/04-007, Section 15.2.3, C1505.\t*/\n+      if (curr_comp->pointer != 0)\n+        {\n+          gfc_error (\"Component '%s' at %L cannot have the \"\n+                     \"POINTER attribute because it is a member \"\n+                     \"of the BIND(C) derived type '%s' at %L\",\n+                     curr_comp->name, &(curr_comp->loc),\n+                     derived_sym->name, &(derived_sym->declared_at));\n+          retval = FAILURE;\n+        }\n+\n+      /* The components cannot be allocatable.\n+         J3/04-007, Section 15.2.3, C1505.\t*/\n+      if (curr_comp->allocatable != 0)\n+        {\n+          gfc_error (\"Component '%s' at %L cannot have the \"\n+                     \"ALLOCATABLE attribute because it is a member \"\n+                     \"of the BIND(C) derived type '%s' at %L\",\n+                     curr_comp->name, &(curr_comp->loc),\n+                     derived_sym->name, &(derived_sym->declared_at));\n+          retval = FAILURE;\n+        }\n+      \n+      /* BIND(C) derived types must have interoperable components.  */\n+      if (curr_comp->ts.type == BT_DERIVED\n+\t  && curr_comp->ts.derived->ts.is_iso_c != 1 \n+          && curr_comp->ts.derived != derived_sym)\n+        {\n+          /* This should be allowed; the draft says a derived-type can not\n+             have type parameters if it is has the BIND attribute.  Type\n+             parameters seem to be for making parameterized derived types.\n+             There's no need to verify the type if it is c_ptr/c_funptr.  */\n+          retval = verify_bind_c_derived_type (curr_comp->ts.derived);\n+\t}\n+      else\n+\t{\n+\t  /* Grab the typespec for the given component and test the kind.  */ \n+\t  is_c_interop = verify_c_interop (&(curr_comp->ts), curr_comp->name,\n+                                           &(curr_comp->loc));\n+\t  \n+\t  if (is_c_interop != SUCCESS)\n+\t    {\n+\t      /* Report warning and continue since not fatal.  The\n+\t\t draft does specify a constraint that requires all fields\n+\t\t to interoperate, but if the user says real(4), etc., it\n+\t\t may interoperate with *something* in C, but the compiler\n+\t\t most likely won't know exactly what.  Further, it may not\n+\t\t interoperate with the same data type(s) in C if the user\n+\t\t recompiles with different flags (e.g., -m32 and -m64 on\n+\t\t x86_64 and using integer(4) to claim interop with a\n+\t\t C_LONG).  */\n+\t      if (derived_sym->attr.is_bind_c == 1)\n+\t\t/* If the derived type is bind(c), all fields must be\n+\t\t   interop.  */\n+\t\tgfc_warning (\"Component '%s' in derived type '%s' at %L \"\n+                             \"may not be C interoperable, even though \"\n+                             \"derived type '%s' is BIND(C)\",\n+                             curr_comp->name, derived_sym->name,\n+                             &(curr_comp->loc), derived_sym->name);\n+\t      else\n+\t\t/* If derived type is param to bind(c) routine, or to one\n+\t\t   of the iso_c_binding procs, it must be interoperable, so\n+\t\t   all fields must interop too.\t */\n+\t\tgfc_warning (\"Component '%s' in derived type '%s' at %L \"\n+                             \"may not be C interoperable\",\n+                             curr_comp->name, derived_sym->name,\n+                             &(curr_comp->loc));\n+\t    }\n+\t}\n+      \n+      curr_comp = curr_comp->next;\n+    } while (curr_comp != NULL); \n+\n+\n+  /* Make sure we don't have conflicts with the attributes.  */\n+  if (derived_sym->attr.access == ACCESS_PRIVATE)\n+    {\n+      gfc_error (\"Derived type '%s' at %L cannot be declared with both \"\n+                 \"PRIVATE and BIND(C) attributes\", derived_sym->name,\n+                 &(derived_sym->declared_at));\n+      retval = FAILURE;\n+    }\n+\n+  if (derived_sym->attr.sequence != 0)\n+    {\n+      gfc_error (\"Derived type '%s' at %L cannot have the SEQUENCE \"\n+                 \"attribute because it is BIND(C)\", derived_sym->name,\n+                 &(derived_sym->declared_at));\n+      retval = FAILURE;\n+    }\n+\n+  /* Mark the derived type as not being C interoperable if we found an\n+     error.  If there were only warnings, proceed with the assumption\n+     it's interoperable.  */\n+  if (retval == FAILURE)\n+    derived_sym->ts.is_c_interop = 0;\n+  \n+  return retval;\n+}\n+\n+\n+/* Generate symbols for the named constants c_null_ptr and c_null_funptr.  */\n+\n+static try\n+gen_special_c_interop_ptr (int ptr_id, const char *ptr_name,\n+                           const char *module_name)\n+{\n+  gfc_symtree *tmp_symtree;\n+  gfc_symbol *tmp_sym;\n+\n+  tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root, ptr_name);\n+\t \n+  if (tmp_symtree != NULL)\n+    tmp_sym = tmp_symtree->n.sym;\n+  else\n+    {\n+      tmp_sym = NULL;\n+      gfc_internal_error (\"gen_special_c_interop_ptr(): Unable to \"\n+                          \"create symbol for %s\", ptr_name);\n+    }\n+\n+  /* Set up the symbol's important fields.  Save attr required so we can\n+     initialize the ptr to NULL.  */\n+  tmp_sym->attr.save = 1;\n+  tmp_sym->ts.is_c_interop = 1;\n+  tmp_sym->attr.is_c_interop = 1;\n+  tmp_sym->ts.is_iso_c = 1;\n+  tmp_sym->ts.type = BT_DERIVED;\n+\n+  /* The c_ptr and c_funptr derived types will provide the\n+     definition for c_null_ptr and c_null_funptr, respectively.  */\n+  if (ptr_id == ISOCBINDING_NULL_PTR)\n+    tmp_sym->ts.derived = get_iso_c_binding_dt (ISOCBINDING_PTR);\n+  else\n+    tmp_sym->ts.derived = get_iso_c_binding_dt (ISOCBINDING_FUNPTR);\n+  if (tmp_sym->ts.derived == NULL)\n+    {\n+      /* This can occur if the user forgot to declare c_ptr or\n+         c_funptr and they're trying to use one of the procedures\n+         that has arg(s) of the missing type.  In this case, a\n+         regular version of the thing should have been put in the\n+         current ns.  */\n+      generate_isocbinding_symbol (module_name, ptr_id == ISOCBINDING_NULL_PTR \n+                                   ? ISOCBINDING_PTR : ISOCBINDING_FUNPTR,\n+                                   (char *) (ptr_id == ISOCBINDING_NULL_PTR \n+\t\t\t\t   ? \"_gfortran_iso_c_binding_c_ptr\"\n+\t\t\t\t   : \"_gfortran_iso_c_binding_c_funptr\"));\n+\n+      tmp_sym->ts.derived =\n+        get_iso_c_binding_dt (ptr_id == ISOCBINDING_NULL_PTR\n+                              ? ISOCBINDING_PTR : ISOCBINDING_FUNPTR);\n+    }\n+\n+  /* Module name is some mangled version of iso_c_binding.  */\n+  tmp_sym->module = gfc_get_string (module_name);\n+  \n+  /* Say it's from the iso_c_binding module.  */\n+  tmp_sym->attr.is_iso_c = 1;\n+  \n+  tmp_sym->attr.use_assoc = 1;\n+  tmp_sym->attr.is_bind_c = 1;\n+  /* Set the binding_label.  */\n+  sprintf (tmp_sym->binding_label, \"%s_%s\", module_name, tmp_sym->name);\n+  \n+  /* Set the c_address field of c_null_ptr and c_null_funptr to\n+     the value of NULL.\t */\n+  tmp_sym->value = gfc_get_expr ();\n+  tmp_sym->value->expr_type = EXPR_STRUCTURE;\n+  tmp_sym->value->ts.type = BT_DERIVED;\n+  tmp_sym->value->ts.derived = tmp_sym->ts.derived;\n+  tmp_sym->value->value.constructor = gfc_get_constructor ();\n+  /* This line will initialize the c_null_ptr/c_null_funptr\n+     c_address field to NULL.  */\n+  tmp_sym->value->value.constructor->expr = gfc_int_expr (0);\n+  /* Must declare c_null_ptr and c_null_funptr as having the\n+     PARAMETER attribute so they can be used in init expressions.  */\n+  tmp_sym->attr.flavor = FL_PARAMETER;\n+\n+  return SUCCESS;\n+}\n+\n+\n+/* Add a formal argument, gfc_formal_arglist, to the\n+   end of the given list of arguments.\tSet the reference to the\n+   provided symbol, param_sym, in the argument.  */\n+\n+static void\n+add_formal_arg (gfc_formal_arglist **head,\n+                gfc_formal_arglist **tail,\n+                gfc_formal_arglist *formal_arg,\n+                gfc_symbol *param_sym)\n+{\n+  /* Put in list, either as first arg or at the tail (curr arg).  */\n+  if (*head == NULL)\n+    *head = *tail = formal_arg;\n+  else\n+    {\n+      (*tail)->next = formal_arg;\n+      (*tail) = formal_arg;\n+    }\n+   \n+  (*tail)->sym = param_sym;\n+  (*tail)->next = NULL;\n+   \n+  return;\n+}\n+\n+\n+/* Generates a symbol representing the CPTR argument to an\n+   iso_c_binding procedure.  Also, create a gfc_formal_arglist for the\n+   CPTR and add it to the provided argument list.  */\n+\n+static void\n+gen_cptr_param (gfc_formal_arglist **head,\n+                gfc_formal_arglist **tail,\n+                const char *module_name,\n+                gfc_namespace *ns, const char *c_ptr_name)\n+{\n+  gfc_symbol *param_sym = NULL;\n+  gfc_symbol *c_ptr_sym = NULL;\n+  gfc_symtree *param_symtree = NULL;\n+  gfc_formal_arglist *formal_arg = NULL;\n+  const char *c_ptr_in;\n+  const char *c_ptr_type = \"c_ptr\";\n+\n+  if(c_ptr_name == NULL)\n+    c_ptr_in = \"gfc_cptr__\";\n+  else\n+    c_ptr_in = c_ptr_name;\n+  gfc_get_sym_tree (c_ptr_in, ns, &param_symtree);\n+  if (param_symtree != NULL)\n+    param_sym = param_symtree->n.sym;\n+  else\n+    gfc_internal_error (\"gen_cptr_param(): Unable to \"\n+\t\t\t\"create symbol for %s\", c_ptr_in);\n+\n+  /* Set up the appropriate fields for the new c_ptr param sym.  */\n+  param_sym->refs++;\n+  param_sym->attr.flavor = FL_DERIVED;\n+  param_sym->ts.type = BT_DERIVED;\n+  param_sym->attr.intent = INTENT_IN;\n+  param_sym->attr.dummy = 1;\n+\n+  /* This will pass the ptr to the iso_c routines as a (void *).  */\n+  param_sym->attr.value = 1;\n+  param_sym->attr.use_assoc = 1;\n+\n+  /* Get the symbol for c_ptr, no matter what it's name is (user renamed).  */\n+  c_ptr_sym = get_iso_c_binding_dt (ISOCBINDING_PTR);\n+  if (c_ptr_sym == NULL)\n+    {\n+      /* This can happen if the user did not define c_ptr but they are\n+         trying to use one of the iso_c_binding functions that need it.  */\n+      gfc_error_now (\"Type 'C_PTR' required for ISO_C_BINDING function at %C\");\n+      generate_isocbinding_symbol (module_name, ISOCBINDING_PTR,\n+                                   (char *) \"_gfortran_iso_c_binding_c_ptr\");\n+\n+      gfc_get_ha_symbol (c_ptr_type, &(c_ptr_sym));\n+    }\n+\n+  param_sym->ts.derived = c_ptr_sym;\n+  param_sym->module = gfc_get_string (module_name);\n+\n+  /* Make new formal arg.  */\n+  formal_arg = gfc_get_formal_arglist ();\n+  /* Add arg to list of formal args (the CPTR arg).  */\n+  add_formal_arg (head, tail, formal_arg, param_sym);\n+}\n+\n+\n+/* Generates a symbol representing the FPTR argument to an\n+   iso_c_binding procedure.  Also, create a gfc_formal_arglist for the\n+   FPTR and add it to the provided argument list.  */\n+\n+static void\n+gen_fptr_param (gfc_formal_arglist **head,\n+                gfc_formal_arglist **tail,\n+                const char *module_name,\n+                gfc_namespace *ns, const char *f_ptr_name)\n+{\n+  gfc_symbol *param_sym = NULL;\n+  gfc_symtree *param_symtree = NULL;\n+  gfc_formal_arglist *formal_arg = NULL;\n+  const char *f_ptr_out = \"gfc_fptr__\";\n+\n+  if (f_ptr_name != NULL)\n+    f_ptr_out = f_ptr_name;\n+\n+  gfc_get_sym_tree (f_ptr_out, ns, &param_symtree);\n+  if (param_symtree != NULL)\n+    param_sym = param_symtree->n.sym;\n+  else\n+    gfc_internal_error (\"generateFPtrParam(): Unable to \"\n+\t\t\t\"create symbol for %s\", f_ptr_out);\n+\n+  /* Set up the necessary fields for the fptr output param sym.  */\n+  param_sym->refs++;\n+  param_sym->attr.pointer = 1;\n+  param_sym->attr.dummy = 1;\n+  param_sym->attr.use_assoc = 1;\n+\n+  /* ISO C Binding type to allow any pointer type as actual param.  */\n+  param_sym->ts.type = BT_VOID;\n+  param_sym->module = gfc_get_string (module_name);\n+   \n+  /* Make the arg.  */\n+  formal_arg = gfc_get_formal_arglist ();\n+  /* Add arg to list of formal args.  */\n+  add_formal_arg (head, tail, formal_arg, param_sym);\n+}\n+\n+\n+/* Generates a symbol representing the optional SHAPE argument for the\n+   iso_c_binding c_f_pointer() procedure.  Also, create a\n+   gfc_formal_arglist for the SHAPE and add it to the provided\n+   argument list.  */\n+\n+static void\n+gen_shape_param (gfc_formal_arglist **head,\n+                 gfc_formal_arglist **tail,\n+                 const char *module_name,\n+                 gfc_namespace *ns, const char *shape_param_name)\n+{\n+  gfc_symbol *param_sym = NULL;\n+  gfc_symtree *param_symtree = NULL;\n+  gfc_formal_arglist *formal_arg = NULL;\n+  const char *shape_param = \"gfc_shape_array__\";\n+  int i;\n+\n+  if (shape_param_name != NULL)\n+    shape_param = shape_param_name;\n+\n+  gfc_get_sym_tree (shape_param, ns, &param_symtree);\n+  if (param_symtree != NULL)\n+    param_sym = param_symtree->n.sym;\n+  else\n+    gfc_internal_error (\"generateShapeParam(): Unable to \"\n+\t\t\t\"create symbol for %s\", shape_param);\n+   \n+  /* Set up the necessary fields for the shape input param sym.  */\n+  param_sym->refs++;\n+  param_sym->attr.dummy = 1;\n+  param_sym->attr.use_assoc = 1;\n+\n+  /* Integer array, rank 1, describing the shape of the object.  */\n+  param_sym->ts.type = BT_INTEGER;\n+  param_sym->ts.kind = gfc_default_integer_kind;   \n+  param_sym->as = gfc_get_array_spec ();\n+\n+  /* Clear out the dimension info for the array.  */\n+  for (i = 0; i < GFC_MAX_DIMENSIONS; i++)\n+    {\n+      param_sym->as->lower[i] = NULL;\n+      param_sym->as->upper[i] = NULL;\n+    }\n+  param_sym->as->rank = 1;\n+  param_sym->as->lower[0] = gfc_int_expr (1);\n+\n+  /* The extent is unknown until we get it.  The length give us\n+     the rank the incoming pointer.  */\n+  param_sym->as->type = AS_ASSUMED_SHAPE;\n+\n+  /* The arg is also optional; it is required iff the second arg\n+     (fptr) is to an array, otherwise, it's ignored.  */\n+  param_sym->attr.optional = 1;\n+  param_sym->attr.intent = INTENT_IN;\n+  param_sym->attr.dimension = 1;\n+  param_sym->module = gfc_get_string (module_name);\n+   \n+  /* Make the arg.  */\n+  formal_arg = gfc_get_formal_arglist ();\n+  /* Add arg to list of formal args.  */\n+  add_formal_arg (head, tail, formal_arg, param_sym);\n+}\n+\n+/* Add a procedure interface to the given symbol (i.e., store a\n+   reference to the list of formal arguments).  */\n+\n+static void\n+add_proc_interface (gfc_symbol *sym, ifsrc source,\n+                    gfc_formal_arglist *formal)\n+{\n+\n+  sym->formal = formal;\n+  sym->attr.if_source = source;\n+}\n+\n+\n+/* Builds the parameter list for the iso_c_binding procedure\n+   c_f_pointer or c_f_procpointer.  The old_sym typically refers to a\n+   generic version of either the c_f_pointer or c_f_procpointer\n+   functions.  The new_proc_sym represents a \"resolved\" version of the\n+   symbol.  The functions are resolved to match the types of their\n+   parameters; for example, c_f_pointer(cptr, fptr) would resolve to\n+   something similar to c_f_pointer_i4 if the type of data object fptr\n+   pointed to was a default integer.  The actual name of the resolved\n+   procedure symbol is further mangled with the module name, etc., but\n+   the idea holds true.  */\n+\n+static void\n+build_formal_args (gfc_symbol *new_proc_sym,\n+                   gfc_symbol *old_sym, int add_optional_arg)\n+{\n+  gfc_formal_arglist *head = NULL, *tail = NULL;\n+  gfc_namespace *parent_ns = NULL;\n+\n+  parent_ns = gfc_current_ns;\n+  /* Create a new namespace, which will be the formal ns (namespace\n+     of the formal args).  */\n+  gfc_current_ns = gfc_get_namespace(parent_ns, 0);\n+  gfc_current_ns->proc_name = new_proc_sym;\n+\n+  /* Generate the params.  */\n+  if ((old_sym->intmod_sym_id == ISOCBINDING_F_POINTER) ||\n+      (old_sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER))\n+    {\n+      gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n+\t\t      gfc_current_ns, \"cptr\");\n+      gen_fptr_param (&head, &tail, (const char *) new_proc_sym->module,\n+\t\t      gfc_current_ns, \"fptr\");\n+\n+      /* If we're dealing with c_f_pointer, it has an optional third arg.  */\n+      if (old_sym->intmod_sym_id == ISOCBINDING_F_POINTER)\n+\t{\n+\t  gen_shape_param (&head, &tail,\n+\t\t\t   (const char *) new_proc_sym->module,\n+\t\t\t   gfc_current_ns, \"shape\");\n+\t}\n+    }\n+  else if (old_sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n+    {\n+      /* c_associated has one required arg and one optional; both\n+\t are c_ptrs.  */\n+      gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n+\t\t      gfc_current_ns, \"c_ptr_1\");\n+      if (add_optional_arg)\n+\t{\n+\t  gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n+\t\t\t  gfc_current_ns, \"c_ptr_2\");\n+\t  /* The last param is optional so mark it as such.  */\n+\t  tail->sym->attr.optional = 1;\n+\t}\n+    }\n+\n+  /* Add the interface (store formal args to new_proc_sym).  */\n+  add_proc_interface (new_proc_sym, IFSRC_DECL, head);\n+\n+  /* Set up the formal_ns pointer to the one created for the\n+     new procedure so it'll get cleaned up during gfc_free_symbol().  */\n+  new_proc_sym->formal_ns = gfc_current_ns;\n+\n+  gfc_current_ns = parent_ns;\n+}\n+\n+\n+/* Generate the given set of C interoperable kind objects, or all\n+   interoperable kinds.  This function will only be given kind objects\n+   for valid iso_c_binding defined types because this is verified when\n+   the 'use' statement is parsed.  If the user gives an 'only' clause,\n+   the specific kinds are looked up; if they don't exist, an error is\n+   reported.  If the user does not give an 'only' clause, all\n+   iso_c_binding symbols are generated.  If a list of specific kinds\n+   is given, it must have a NULL in the first empty spot to mark the\n+   end of the list.  */\n+\n+\n+void\n+generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n+\t\t\t     char *local_name)\n+{\n+  char *name = (local_name && local_name[0]) ? local_name\n+\t\t\t\t\t     : c_interop_kinds_table[s].name;\n+  gfc_symtree *tmp_symtree = NULL;\n+  gfc_symbol *tmp_sym = NULL;\n+  gfc_dt_list **dt_list_ptr = NULL;\n+  gfc_component *tmp_comp = NULL;\n+  char comp_name[(GFC_MAX_SYMBOL_LEN * 2) + 1];\n+  int index;\n+\n+  tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root, name);\n+\n+  /* Already exists in this scope so don't re-add it.\n+     TODO: we should probably check that it's really the same symbol.  */\n+  if (tmp_symtree != NULL)\n+    return;\n+\n+  /* Create the sym tree in the current ns.  */\n+  gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree);\n+  if (tmp_symtree)\n+    tmp_sym = tmp_symtree->n.sym;\n+  else\n+    gfc_internal_error (\"generate_isocbinding_symbol(): Unable to \"\n+\t\t\t\"create symbol\");\n+\n+  /* Say what module this symbol belongs to.  */\n+  tmp_sym->module = gfc_get_string (mod_name);\n+  tmp_sym->from_intmod = INTMOD_ISO_C_BINDING;\n+  tmp_sym->intmod_sym_id = s;\n+\n+  switch (s)\n+    {\n+\n+#define NAMED_INTCST(a,b,c) case a :\n+#define NAMED_REALCST(a,b,c) case a :\n+#define NAMED_CMPXCST(a,b,c) case a :\n+#define NAMED_LOGCST(a,b,c) case a :\n+#define NAMED_CHARKNDCST(a,b,c) case a :\n+#include \"iso-c-binding.def\"\n+\n+\ttmp_sym->value = gfc_int_expr (c_interop_kinds_table[s].value);\n+\n+\t/* Initialize an integer constant expression node.  */\n+\ttmp_sym->attr.flavor = FL_PARAMETER;\n+\ttmp_sym->ts.type = BT_INTEGER;\n+\ttmp_sym->ts.kind = gfc_default_integer_kind;\n+\n+\t/* Mark this type as a C interoperable one.  */\n+\ttmp_sym->ts.is_c_interop = 1;\n+\ttmp_sym->ts.is_iso_c = 1;\n+\ttmp_sym->value->ts.is_c_interop = 1;\n+\ttmp_sym->value->ts.is_iso_c = 1;\n+\ttmp_sym->attr.is_c_interop = 1;\n+\n+\t/* Tell what f90 type this c interop kind is valid.  */\n+\ttmp_sym->ts.f90_type = c_interop_kinds_table[s].f90_type;\n+\n+\t/* Say it's from the iso_c_binding module.  */\n+\ttmp_sym->attr.is_iso_c = 1;\n+\n+\t/* Make it use associated.  */\n+\ttmp_sym->attr.use_assoc = 1;\n+\tbreak;\n+\n+\n+#define NAMED_CHARCST(a,b,c) case a :\n+#include \"iso-c-binding.def\"\n+\n+\t/* Initialize an integer constant expression node for the\n+\t   length of the character.  */\n+\ttmp_sym->value = gfc_get_expr (); \n+\ttmp_sym->value->expr_type = EXPR_CONSTANT;\n+\ttmp_sym->value->ts.type = BT_CHARACTER;\n+\ttmp_sym->value->ts.kind = gfc_default_character_kind;\n+\ttmp_sym->value->where = gfc_current_locus;\n+\ttmp_sym->value->ts.is_c_interop = 1;\n+\ttmp_sym->value->ts.is_iso_c = 1;\n+\ttmp_sym->value->value.character.length = 1;\n+\ttmp_sym->value->value.character.string = gfc_getmem (2);\n+\ttmp_sym->value->value.character.string[0]\n+\t  = (char) c_interop_kinds_table[s].value;\n+\ttmp_sym->value->value.character.string[1] = '\\0';\n+\n+\t/* May not need this in both attr and ts, but do need in\n+\t   attr for writing module file.  */\n+\ttmp_sym->attr.is_c_interop = 1;\n+\n+\ttmp_sym->attr.flavor = FL_PARAMETER;\n+\ttmp_sym->ts.type = BT_CHARACTER;\n+\n+\t/* Need to set it to the C_CHAR kind.  */\n+\ttmp_sym->ts.kind = gfc_default_character_kind;\n+\n+\t/* Mark this type as a C interoperable one.  */\n+\ttmp_sym->ts.is_c_interop = 1;\n+\ttmp_sym->ts.is_iso_c = 1;\n+\n+\t/* Tell what f90 type this c interop kind is valid.  */\n+\ttmp_sym->ts.f90_type = BT_CHARACTER;\n+\n+\t/* Say it's from the iso_c_binding module.  */\n+\ttmp_sym->attr.is_iso_c = 1;\n+\n+\t/* Make it use associated.  */\n+\ttmp_sym->attr.use_assoc = 1;\n+\tbreak;\n+\n+      case ISOCBINDING_PTR:\n+      case ISOCBINDING_FUNPTR:\n+\n+\t/* Initialize an integer constant expression node.  */\n+\ttmp_sym->attr.flavor = FL_DERIVED;\n+\ttmp_sym->ts.is_c_interop = 1;\n+\ttmp_sym->attr.is_c_interop = 1;\n+\ttmp_sym->attr.is_iso_c = 1;\n+\ttmp_sym->ts.is_iso_c = 1;\n+\ttmp_sym->ts.type = BT_DERIVED;\n+\n+\t/* A derived type must have the bind attribute to be\n+\t   interoperable (J3/04-007, Section 15.2.3), even though\n+\t   the binding label is not used.  */\n+\ttmp_sym->attr.is_bind_c = 1;\n+\n+\ttmp_sym->attr.referenced = 1;\n+\n+\ttmp_sym->ts.derived = tmp_sym;\n+\n+        /* Add the symbol created for the derived type to the current ns.  */\n+        dt_list_ptr = &(gfc_derived_types);\n+        while (*dt_list_ptr != NULL && (*dt_list_ptr)->next != NULL)\n+          dt_list_ptr = &((*dt_list_ptr)->next);\n+\n+        /* There is already at least one derived type in the list, so append\n+           the one we're currently building for c_ptr or c_funptr.  */\n+        if (*dt_list_ptr != NULL)\n+          dt_list_ptr = &((*dt_list_ptr)->next);\n+        (*dt_list_ptr) = gfc_get_dt_list ();\n+        (*dt_list_ptr)->derived = tmp_sym;\n+        (*dt_list_ptr)->next = NULL;\n+\n+        /* Set up the component of the derived type, which will be\n+           an integer with kind equal to c_ptr_size.  Mangle the name of\n+           the field for the c_address to prevent the curious user from\n+           trying to access it from Fortran.  */\n+        sprintf (comp_name, \"__%s_%s\", tmp_sym->name, \"c_address\");\n+        gfc_add_component (tmp_sym, comp_name, &tmp_comp);\n+        if (tmp_comp == NULL)\n+          gfc_internal_error (\"generate_isocbinding_symbol(): Unable to \"\n+\t\t\t      \"create component for c_address\");\n+\n+        tmp_comp->ts.type = BT_INTEGER;\n+\n+        /* Set this because the module will need to read/write this field.  */\n+        tmp_comp->ts.f90_type = BT_INTEGER;\n+\n+        /* The kinds for c_ptr and c_funptr are the same.  */\n+        index = get_c_kind (\"c_ptr\", c_interop_kinds_table);\n+        tmp_comp->ts.kind = c_interop_kinds_table[index].value;\n+\n+        tmp_comp->pointer = 0;\n+        tmp_comp->dimension = 0;\n+\n+        /* Mark the component as C interoperable.  */\n+        tmp_comp->ts.is_c_interop = 1;\n+\n+        /* Make it use associated (iso_c_binding module).  */\n+        tmp_sym->attr.use_assoc = 1;\n+\tbreak;\n+\n+      case ISOCBINDING_NULL_PTR:\n+      case ISOCBINDING_NULL_FUNPTR:\n+        gen_special_c_interop_ptr (s, name, mod_name);\n+        break;\n+\n+      case ISOCBINDING_F_POINTER:\n+      case ISOCBINDING_ASSOCIATED:\n+      case ISOCBINDING_LOC:\n+      case ISOCBINDING_FUNLOC:\n+      case ISOCBINDING_F_PROCPOINTER:\n+\n+\ttmp_sym->attr.proc = PROC_MODULE;\n+\n+        /* Use the procedure's name as it is in the iso_c_binding module for\n+           setting the binding label in case the user renamed the symbol.  */\n+\tsprintf (tmp_sym->binding_label, \"%s_%s\", mod_name,\n+                 c_interop_kinds_table[s].name);\n+\ttmp_sym->attr.is_iso_c = 1;\n+\tif (s == ISOCBINDING_F_POINTER || s == ISOCBINDING_F_PROCPOINTER)\n+\t  tmp_sym->attr.subroutine = 1;\n+\telse\n+\t  {\n+            /* TODO!  This needs to be finished more for the expr of the\n+               function or something!\n+               This may not need to be here, because trying to do c_loc\n+               as an external.  */\n+\t    if (s == ISOCBINDING_ASSOCIATED)\n+\t      {\n+\t\ttmp_sym->attr.function = 1;\n+\t\ttmp_sym->ts.type = BT_LOGICAL;\n+\t\ttmp_sym->ts.kind = gfc_default_logical_kind;\n+\t\ttmp_sym->result = tmp_sym;\n+\t      }\n+\t    else\n+\t      {\n+               /* Here, we're taking the simple approach.  We're defining\n+                  c_loc as an external identifier so the compiler will put\n+                  what we expect on the stack for the address we want the\n+                  C address of.  */\n+\t\ttmp_sym->ts.type = BT_DERIVED;\n+                if (s == ISOCBINDING_LOC)\n+                  tmp_sym->ts.derived =\n+                    get_iso_c_binding_dt (ISOCBINDING_PTR);\n+                else\n+                  tmp_sym->ts.derived =\n+                    get_iso_c_binding_dt (ISOCBINDING_FUNPTR);\n+\n+                if (tmp_sym->ts.derived == NULL)\n+                  {\n+                    /* Create the necessary derived type so we can continue\n+                       processing the file.  */\n+                    generate_isocbinding_symbol\n+                      (mod_name, s == ISOCBINDING_FUNLOC\n+                       ? ISOCBINDING_FUNPTR : ISOCBINDING_FUNPTR,\n+                       (char *)(s == ISOCBINDING_FUNLOC \n+                                ? \"_gfortran_iso_c_binding_c_funptr\"\n+\t\t\t\t: \"_gfortran_iso_c_binding_c_ptr\"));\n+                    tmp_sym->ts.derived =\n+                      get_iso_c_binding_dt (s == ISOCBINDING_FUNLOC\n+                                            ? ISOCBINDING_FUNPTR\n+                                            : ISOCBINDING_PTR);\n+                  }\n+\n+\t\t/* The function result is itself (no result clause).  */\n+\t\ttmp_sym->result = tmp_sym;\n+\t\ttmp_sym->attr.external = 1;\n+\t\ttmp_sym->attr.use_assoc = 0;\n+\t\ttmp_sym->attr.if_source = IFSRC_UNKNOWN;\n+\t\ttmp_sym->attr.proc = PROC_UNKNOWN;\n+\t      }\n+\t  }\n+\n+\ttmp_sym->attr.flavor = FL_PROCEDURE;\n+\ttmp_sym->attr.contained = 0;\n+\t\n+       /* Try using this builder routine, with the new and old symbols\n+          both being the generic iso_c proc sym being created.  This\n+          will create the formal args (and the new namespace for them).\n+          Don't build an arg list for c_loc because we're going to treat\n+          c_loc as an external procedure.  */\n+\tif (s != ISOCBINDING_LOC && s != ISOCBINDING_FUNLOC)\n+          /* The 1 says to add any optional args, if applicable.  */\n+\t  build_formal_args (tmp_sym, tmp_sym, 1);\n+\n+        /* Set this after setting up the symbol, to prevent error messages.  */\n+\ttmp_sym->attr.use_assoc = 1;\n+\n+        /* This symbol will not be referenced directly.  It will be\n+           resolved to the implementation for the given f90 kind.  */\n+\ttmp_sym->attr.referenced = 0;\n+\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+\n+/* Creates a new symbol based off of an old iso_c symbol, with a new\n+   binding label.  This function can be used to create a new,\n+   resolved, version of a procedure symbol for c_f_pointer or\n+   c_f_procpointer that is based on the generic symbols.  A new\n+   parameter list is created for the new symbol using\n+   build_formal_args().  The add_optional_flag specifies whether the\n+   to add the optional SHAPE argument.  The new symbol is\n+   returned.  */\n+\n+gfc_symbol *\n+get_iso_c_sym (gfc_symbol *old_sym, char *new_name,\n+               char *new_binding_label, int add_optional_arg)\n+{\n+  gfc_symtree *new_symtree = NULL;\n+\n+  /* See if we have a symbol by that name already available, looking\n+     through any parent namespaces.  */\n+  gfc_find_sym_tree (new_name, gfc_current_ns, 1, &new_symtree);\n+  if (new_symtree != NULL)\n+    /* Return the existing symbol.  */\n+    return new_symtree->n.sym;\n+\n+  /* Create the symtree/symbol, with attempted host association.  */\n+  gfc_get_ha_sym_tree (new_name, &new_symtree);\n+  if (new_symtree == NULL)\n+    gfc_internal_error (\"get_iso_c_sym(): Unable to create \"\n+\t\t\t\"symtree for '%s'\", new_name);\n+\n+  /* Now fill in the fields of the resolved symbol with the old sym.  */\n+  strcpy (new_symtree->n.sym->binding_label, new_binding_label);\n+  new_symtree->n.sym->attr = old_sym->attr;\n+  new_symtree->n.sym->ts = old_sym->ts;\n+  new_symtree->n.sym->module = gfc_get_string (old_sym->module);\n+  /* Build the formal arg list.  */\n+  build_formal_args (new_symtree->n.sym, old_sym, add_optional_arg);\n+\n+  gfc_commit_symbol (new_symtree->n.sym);\n+\n+  return new_symtree->n.sym;\n+}\n+"}, {"sha": "7b862c7f88c58efa4345d0629fdfab1dcea8de5c", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -109,6 +109,12 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target-memory.h\"\n \n \n+/* TODO: This is defined in match.h, and probably shouldn't be here also,\n+   but we need it for now at least and don't want to include the whole\n+   match.h.  */\n+gfc_common_head *gfc_get_common (const char *, int);\n+\n+\n /* Holds a single variable in an equivalence set.  */\n typedef struct segment_info\n {\n@@ -217,13 +223,37 @@ add_segments (segment_info *list, segment_info *v)\n   return list;\n }\n \n+\n /* Construct mangled common block name from symbol name.  */\n \n+/* We need the bind(c) flag to tell us how/if we should mangle the symbol\n+   name.  There are few calls to this function, so few places that this\n+   would need to be added.  At the moment, there is only one call, in\n+   build_common_decl().  We can't attempt to look up the common block\n+   because we may be building it for the first time and therefore, it won't\n+   be in the common_root.  We also need the binding label, if it's bind(c).\n+   Therefore, send in the pointer to the common block, so whatever info we\n+   have so far can be used.  All of the necessary info should be available\n+   in the gfc_common_head by now, so it should be accurate to test the\n+   isBindC flag and use the binding label given if it is bind(c).\n+\n+   We may NOT know yet if it's bind(c) or not, but we can try at least.\n+   Will have to figure out what to do later if it's labeled bind(c)\n+   after this is called.  */\n+\n static tree\n-gfc_sym_mangled_common_id (const char *name)\n+gfc_sym_mangled_common_id (gfc_common_head *com)\n {\n   int has_underscore;\n   char mangled_name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+\n+  /* Get the name out of the common block pointer.  */\n+  strcpy (name, com->name);\n+\n+  /* If we're suppose to do a bind(c).  */\n+  if (com->is_bind_c == 1 && com->binding_label[0] != '\\0')\n+    return get_identifier (com->binding_label);\n \n   if (strcmp (name, BLANK_COMMON_NAME) == 0)\n     return get_identifier (name);\n@@ -381,7 +411,7 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n   if (decl == NULL_TREE)\n     {\n       decl = build_decl (VAR_DECL, get_identifier (com->name), union_type);\n-      SET_DECL_ASSEMBLER_NAME (decl, gfc_sym_mangled_common_id (com->name));\n+      SET_DECL_ASSEMBLER_NAME (decl, gfc_sym_mangled_common_id (com));\n       TREE_PUBLIC (decl) = 1;\n       TREE_STATIC (decl) = 1;\n       DECL_ALIGN (decl) = BIGGEST_ALIGNMENT;"}, {"sha": "7aaed0bd29e15df7f6d8d9c391be0b56c772a4bd", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -280,6 +280,20 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n void\n gfc_conv_constant (gfc_se * se, gfc_expr * expr)\n {\n+  /* We may be receiving an expression for C_NULL_PTR or C_NULL_FUNPTR.  If\n+     so, they expr_type will not yet be an EXPR_CONSTANT.  We need to make\n+     it so here.  */\n+  if (expr->ts.type == BT_DERIVED && expr->ts.derived\n+      && expr->ts.derived->attr.is_iso_c)\n+    {\n+      if (expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_PTR \n+          || expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_FUNPTR)\n+        {\n+          /* Create a new EXPR_CONSTANT expression for our local uses.  */\n+          expr = gfc_int_expr (0);\n+        }\n+    }\n+\n   gcc_assert (expr->expr_type == EXPR_CONSTANT);\n \n   if (se->ss != NULL)"}, {"sha": "1a949826cf1cd8bd1c994516ed442c654a7a5289", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -292,6 +292,12 @@ gfc_sym_mangled_identifier (gfc_symbol * sym)\n {\n   char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];\n \n+  /* Prevent the mangling of identifiers that have an assigned\n+     binding label (mainly those that are bind(c)).  */\n+  if (sym->attr.is_bind_c == 1\n+      && sym->binding_label[0] != '\\0')\n+    return get_identifier(sym->binding_label);\n+  \n   if (sym->module == NULL)\n     return gfc_sym_identifier (sym);\n   else\n@@ -310,6 +316,14 @@ gfc_sym_mangled_function_id (gfc_symbol * sym)\n   int has_underscore;\n   char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];\n \n+  /* It may be possible to simply use the binding label if it's\n+     provided, and remove the other checks.  Then we could use it\n+     for other things if we wished.  */\n+  if ((sym->attr.is_bind_c == 1 || sym->attr.is_iso_c == 1) &&\n+      sym->binding_label[0] != '\\0')\n+    /* use the binding label rather than the mangled name */\n+    return get_identifier (sym->binding_label);\n+\n   if (sym->module == NULL || sym->attr.proc == PROC_EXTERNAL\n       || (sym->module != NULL && (sym->attr.external\n \t    || sym->attr.if_source == IFSRC_IFBODY)))\n@@ -473,6 +487,21 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n   if (sym->attr.cray_pointee)\n     return;\n \n+  if(sym->attr.is_bind_c == 1)\n+    {\n+      /* We need to put variables that are bind(c) into the common\n+\t segment of the object file, because this is what C would do.\n+\t gfortran would typically put them in either the BSS or\n+\t initialized data segments, and only mark them as common if\n+\t they were part of common blocks.  However, if they are not put\n+\t into common space, then C cannot initialize global fortran\n+\t variables that it interoperates with and the draft says that\n+\t either Fortran or C should be able to initialize it (but not\n+\t both, of course.) (J3/04-007, section 15.3).  */\n+      TREE_PUBLIC(decl) = 1;\n+      DECL_COMMON(decl) = 1;\n+    }\n+  \n   /* If a variable is USE associated, it's always external.  */\n   if (sym->attr.use_assoc)\n     {\n@@ -2718,6 +2747,12 @@ gfc_create_module_variable (gfc_symbol * sym)\n   if (sym->attr.entry)\n     return;\n \n+  /* Make sure we convert the types of the derived types from iso_c_binding\n+     into (void *).  */\n+  if (sym->attr.flavor != FL_PROCEDURE && sym->attr.is_iso_c\n+      && sym->ts.type == BT_DERIVED)\n+    sym->backend_decl = gfc_typenode_for_spec (&(sym->ts));\n+\n   /* Only output variables and array valued parameters.  */\n   if (sym->attr.flavor != FL_VARIABLE\n       && (sym->attr.flavor != FL_PARAMETER || sym->attr.dimension == 0))\n@@ -2804,6 +2839,41 @@ gfc_generate_contained_functions (gfc_namespace * parent)\n }\n \n \n+/* Set up the tree type for the given symbol to allow the dummy\n+   variable (parameter) to be passed by-value.  To do this, the main\n+   idea is to simply remove the extra layer added by Fortran\n+   automatically (the POINTER_TYPE node).  This pointer type node\n+   would normally just contain the real type underneath, but we remove\n+   it here and later we change the way the argument is converted for a\n+   function call (trans-expr.c:gfc_conv_function_call).  This is the\n+   approach the C compiler takes (or it appears to be this way).  When\n+   the middle-end is given the typed node rather than the POINTER_TYPE\n+   node, it knows to pass the value.  */\n+\n+static void\n+set_tree_decl_type_code (gfc_symbol *sym)\n+{\n+   /* This should not happen.  during the gfc_sym_type function,\n+      when the backend_decl is being built for a dummy arg, if the arg\n+      is pass-by-value then no reference type is wrapped around the\n+      true type (e.g., REAL_TYPE).  */\n+  if (TREE_CODE (TREE_TYPE (sym->backend_decl)) == POINTER_TYPE ||\n+      TREE_CODE (TREE_TYPE (sym->backend_decl)) == REFERENCE_TYPE)\n+    TREE_TYPE (sym->backend_decl) = gfc_typenode_for_spec (&sym->ts);\n+  DECL_BY_REFERENCE (sym->backend_decl) = 0;\n+  \n+   /* the tree can't be addressable if it's pass-by-value..?  x*/\n+/*    TREE_TYPE(sym->backend_decl)->common.addressable_flag = 0; */\n+\n+   DECL_ARG_TYPE (sym->backend_decl) = TREE_TYPE (sym->backend_decl);\n+\n+   DECL_MODE (sym->backend_decl) =\n+      TYPE_MODE (TREE_TYPE (sym->backend_decl));\n+\n+   return;\n+}\n+\n+\n /* Drill down through expressions for the array specification bounds and\n    character length calling generate_local_decl for all those variables\n    that have not already been declared.  */\n@@ -2952,6 +3022,21 @@ generate_local_decl (gfc_symbol * sym)\n \t  gfc_get_symbol_decl (sym);\n \t}\n     }\n+\n+  if (sym->attr.dummy == 1)\n+    {\n+      /* The sym->backend_decl can be NULL if this is one of the\n+\t intrinsic types, such as the symbol of type c_ptr for the\n+\t c_f_pointer function, so don't set up the tree code for it.  */\n+      if (sym->attr.value == 1 && sym->backend_decl != NULL)\n+\tset_tree_decl_type_code (sym);\n+    }\n+\n+  /* Make sure we convert the types of the derived types from iso_c_binding\n+     into (void *).  */\n+  if (sym->attr.flavor != FL_PROCEDURE && sym->attr.is_iso_c\n+      && sym->ts.type == BT_DERIVED)\n+    sym->backend_decl = gfc_typenode_for_spec (&(sym->ts));\n }\n \n static void"}, {"sha": "c9cee1cad34d493a8dc38d228bf0c16e11421bab", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -2127,8 +2127,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  argss = gfc_walk_expr (e);\n \n \t  if (argss == gfc_ss_terminator)\n-\t    {\n-\t      parm_kind = SCALAR;\n+            {\n \t      if (fsym && fsym->attr.value)\n \t\t{\n \t\t  gfc_conv_expr (&parmse, e);\n@@ -2778,6 +2777,12 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n   if (!(expr || pointer))\n     return NULL_TREE;\n \n+  if (expr != NULL && expr->ts.type == BT_DERIVED\n+      && expr->ts.is_iso_c && expr->ts.derived\n+      && (expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_PTR\n+\t  || expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_FUNPTR))\n+      expr = gfc_int_expr (0);\n+  \n   if (array)\n     {\n       /* Arrays need special handling.  */\n@@ -3166,6 +3171,31 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n       return;\n     }\n \n+  /* We need to convert the expressions for the iso_c_binding derived types.\n+     C_NULL_PTR and C_NULL_FUNPTR will be made EXPR_NULL, which evaluates to\n+     null_pointer_node.  C_PTR and C_FUNPTR are converted to match the\n+     typespec for the C_PTR and C_FUNPTR symbols, which has already been\n+     updated to be an integer with a kind equal to the size of a (void *).  */\n+  if (expr->ts.type == BT_DERIVED && expr->ts.derived\n+      && expr->ts.derived->attr.is_iso_c)\n+    {\n+      if (expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_PTR\n+          || expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_FUNPTR)\n+        {\n+\t  /* Set expr_type to EXPR_NULL, which will result in\n+\t     null_pointer_node being used below.  */\n+          expr->expr_type = EXPR_NULL;\n+        }\n+      else\n+        {\n+          /* Update the type/kind of the expression to be what the new\n+             type/kind are for the updated symbols of C_PTR/C_FUNPTR.  */\n+          expr->ts.type = expr->ts.derived->ts.type;\n+          expr->ts.f90_type = expr->ts.derived->ts.f90_type;\n+          expr->ts.kind = expr->ts.derived->ts.kind;\n+        }\n+    }\n+  \n   switch (expr->expr_type)\n     {\n     case EXPR_OP:"}, {"sha": "00d0ebdfb5b2a95e091affeba4cf1c6963f8a639", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -1810,6 +1810,17 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n   gfc_component *c;\n   int kind;\n \n+  /* It is possible to get a C_NULL_PTR or C_NULL_FUNPTR expression here if\n+     the user says something like: print *, 'c_null_ptr: ', c_null_ptr\n+     We need to translate the expression to a constant if it's either\n+     C_NULL_PTR or C_NULL_FUNPTR.  */\n+  if (ts->type == BT_DERIVED && ts->is_iso_c == 1 && ts->derived != NULL)\n+    {\n+      ts->type = ts->derived->ts.type;\n+      ts->kind = ts->derived->ts.kind;\n+      ts->f90_type = ts->derived->ts.f90_type;\n+    }\n+  \n   kind = ts->kind;\n   function = NULL;\n   arg2 = NULL;"}, {"sha": "dace23a5bdeed11305574144e9057b9947aa6af5", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 200, "deletions": 3, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -27,6 +27,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n+#include \"langhooks.h\"\n #include \"tm.h\"\n #include \"target.h\"\n #include \"ggc.h\"\n@@ -48,6 +49,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #error If you really need >99 dimensions, continue the sequence above...\n #endif\n \n+/* array of structs so we don't have to worry about xmalloc or free */\n+CInteropKind_t c_interop_kinds_table[ISOCBINDING_NUMBER];\n+\n static tree gfc_get_derived_type (gfc_symbol * derived);\n \n tree gfc_array_index_type;\n@@ -105,6 +109,150 @@ int gfc_charlen_int_kind;\n int gfc_numeric_storage_size;\n int gfc_character_storage_size;\n \n+\n+/* Validate that the f90_type of the given gfc_typespec is valid for\n+   the type it represents.  The f90_type represents the Fortran types\n+   this C kind can be used with.  For example, c_int has a f90_type of\n+   BT_INTEGER and c_float has a f90_type of BT_REAL.  Returns FAILURE\n+   if a mismatch occurs between ts->f90_type and ts->type; SUCCESS if\n+   they match.  */\n+\n+try\n+gfc_validate_c_kind (gfc_typespec *ts)\n+{\n+   return ((ts->type == ts->f90_type) ? SUCCESS : FAILURE);\n+}\n+\n+\n+try\n+gfc_check_any_c_kind (gfc_typespec *ts)\n+{\n+  int i;\n+  \n+  for (i = 0; i < ISOCBINDING_NUMBER; i++)\n+    {\n+      /* Check for any C interoperable kind for the given type/kind in ts.\n+         This can be used after verify_c_interop to make sure that the\n+         Fortran kind being used exists in at least some form for C.  */\n+      if (c_interop_kinds_table[i].f90_type == ts->type &&\n+          c_interop_kinds_table[i].value == ts->kind)\n+        return SUCCESS;\n+    }\n+\n+  return FAILURE;\n+}\n+\n+\n+static int\n+get_real_kind_from_node (tree type)\n+{\n+  int i;\n+\n+  for (i = 0; gfc_real_kinds[i].kind != 0; i++)\n+    if (gfc_real_kinds[i].mode_precision == TYPE_PRECISION (type))\n+      return gfc_real_kinds[i].kind;\n+\n+  return -4;\n+}\n+\n+static int\n+get_int_kind_from_node (tree type)\n+{\n+  int i;\n+\n+  if (!type)\n+    return -2;\n+\n+  for (i = 0; gfc_integer_kinds[i].kind != 0; i++)\n+    if (gfc_integer_kinds[i].bit_size == TYPE_PRECISION (type))\n+      return gfc_integer_kinds[i].kind;\n+\n+  return -1;\n+}\n+\n+static int\n+get_int_kind_from_width (int size)\n+{\n+  int i;\n+\n+  for (i = 0; gfc_integer_kinds[i].kind != 0; i++)\n+    if (gfc_integer_kinds[i].bit_size == size)\n+      return gfc_integer_kinds[i].kind;\n+\n+  return -2;\n+}\n+\n+static int\n+get_int_kind_from_minimal_width (int size)\n+{\n+  int i;\n+\n+  for (i = 0; gfc_integer_kinds[i].kind != 0; i++)\n+    if (gfc_integer_kinds[i].bit_size >= size)\n+      return gfc_integer_kinds[i].kind;\n+\n+  return -2;\n+}\n+\n+\n+/* Generate the CInteropKind_t objects for the C interoperable\n+   kinds.  */\n+\n+static\n+void init_c_interop_kinds (void)\n+{\n+  int i;\n+  tree intmax_type_node = INT_TYPE_SIZE == LONG_LONG_TYPE_SIZE ?\n+\t\t\t  integer_type_node :\n+\t\t\t  (LONG_TYPE_SIZE == LONG_LONG_TYPE_SIZE ?\n+\t\t\t   long_integer_type_node :\n+\t\t\t   long_long_integer_type_node);\n+\n+  /* init all pointers in the list to NULL */\n+  for (i = 0; i < ISOCBINDING_NUMBER; i++)\n+    {\n+      /* Initialize the name and value fields.  */\n+      c_interop_kinds_table[i].name[0] = '\\0';\n+      c_interop_kinds_table[i].value = -100;\n+      c_interop_kinds_table[i].f90_type = BT_UNKNOWN;\n+    }\n+\n+#define NAMED_INTCST(a,b,c) \\\n+  strncpy (c_interop_kinds_table[a].name, b, strlen(b) + 1); \\\n+  c_interop_kinds_table[a].f90_type = BT_INTEGER; \\\n+  c_interop_kinds_table[a].value = c;\n+#define NAMED_REALCST(a,b,c) \\\n+  strncpy (c_interop_kinds_table[a].name, b, strlen(b) + 1); \\\n+  c_interop_kinds_table[a].f90_type = BT_REAL; \\\n+  c_interop_kinds_table[a].value = c;\n+#define NAMED_CMPXCST(a,b,c) \\\n+  strncpy (c_interop_kinds_table[a].name, b, strlen(b) + 1); \\\n+  c_interop_kinds_table[a].f90_type = BT_COMPLEX; \\\n+  c_interop_kinds_table[a].value = c;\n+#define NAMED_LOGCST(a,b,c) \\\n+  strncpy (c_interop_kinds_table[a].name, b, strlen(b) + 1); \\\n+  c_interop_kinds_table[a].f90_type = BT_LOGICAL; \\\n+  c_interop_kinds_table[a].value = c;\n+#define NAMED_CHARKNDCST(a,b,c) \\\n+  strncpy (c_interop_kinds_table[a].name, b, strlen(b) + 1); \\\n+  c_interop_kinds_table[a].f90_type = BT_CHARACTER; \\\n+  c_interop_kinds_table[a].value = c;\n+#define NAMED_CHARCST(a,b,c) \\\n+  strncpy (c_interop_kinds_table[a].name, b, strlen(b) + 1); \\\n+  c_interop_kinds_table[a].f90_type = BT_CHARACTER; \\\n+  c_interop_kinds_table[a].value = c;\n+#define DERIVED_TYPE(a,b,c) \\\n+  strncpy (c_interop_kinds_table[a].name, b, strlen(b) + 1); \\\n+  c_interop_kinds_table[a].f90_type = BT_DERIVED; \\\n+  c_interop_kinds_table[a].value = c;\n+#define PROCEDURE(a,b) \\\n+  strncpy (c_interop_kinds_table[a].name, b, strlen(b) + 1); \\\n+  c_interop_kinds_table[a].f90_type = BT_PROCEDURE; \\\n+  c_interop_kinds_table[a].value = 0;\n+#include \"iso-c-binding.def\"\n+}\n+\n+\n /* Query the target to determine which machine modes are available for\n    computation.  Choose KIND numbers for them.  */\n \n@@ -308,6 +456,9 @@ gfc_init_kinds (void)\n   gfc_index_integer_kind = POINTER_SIZE / 8;\n   /* Pick a kind the same size as the C \"int\" type.  */\n   gfc_c_int_kind = INT_TYPE_SIZE / 8;\n+\n+  /* initialize the C interoperable kinds  */\n+  init_c_interop_kinds();\n }\n \n /* Make sure that a valid kind is present.  Returns an index into the\n@@ -687,7 +838,13 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n       gcc_unreachable ();\n \n     case BT_INTEGER:\n-      basetype = gfc_get_int_type (spec->kind);\n+      /* We use INTEGER(c_intptr_t) for C_PTR and C_FUNPTR once the symbol\n+         has been resolved.  This is done so we can convert C_PTR and\n+         C_FUNPTR to simple variables that get translated to (void *).  */\n+      if (spec->f90_type == BT_VOID)\n+        basetype = ptr_type_node;\n+      else\n+        basetype = gfc_get_int_type (spec->kind);\n       break;\n \n     case BT_REAL:\n@@ -708,8 +865,23 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n \n     case BT_DERIVED:\n       basetype = gfc_get_derived_type (spec->derived);\n-      break;\n \n+      /* If we're dealing with either C_PTR or C_FUNPTR, we modified the\n+         type and kind to fit a (void *) and the basetype returned was a\n+         ptr_type_node.  We need to pass up this new information to the\n+         symbol that was declared of type C_PTR or C_FUNPTR.  */\n+      if (spec->derived->attr.is_iso_c)\n+        {\n+          spec->type = spec->derived->ts.type;\n+          spec->kind = spec->derived->ts.kind;\n+          spec->f90_type = spec->derived->ts.f90_type;\n+        }\n+      break;\n+    case BT_VOID:\n+       /* This is for the second arg to c_f_pointer and c_f_procpointer\n+          of the iso_c_binding module, to accept any ptr type.  */\n+       basetype = ptr_type_node;\n+       break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -1358,8 +1530,10 @@ gfc_sym_type (gfc_symbol * sym)\n \t    }\n         }\n       else\n+      {\n \ttype = gfc_build_array_type (type, sym->as);\n     }\n+    }\n   else\n     {\n       if (sym->attr.allocatable || sym->attr.pointer)\n@@ -1468,12 +1642,25 @@ copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to)\n static tree\n gfc_get_derived_type (gfc_symbol * derived)\n {\n-  tree typenode, field, field_type, fieldlist;\n+  tree typenode = NULL, field = NULL, field_type = NULL, fieldlist = NULL;\n   gfc_component *c;\n   gfc_dt_list *dt;\n \n   gcc_assert (derived && derived->attr.flavor == FL_DERIVED);\n \n+  /* See if it's one of the iso_c_binding derived types.  */\n+  if (derived->attr.is_iso_c == 1)\n+    {\n+      derived->backend_decl = ptr_type_node;\n+      derived->ts.kind = gfc_index_integer_kind;\n+      derived->ts.type = BT_INTEGER;\n+      /* Set the f90_type to BT_VOID as a way to recognize something of type\n+         BT_INTEGER that needs to fit a void * for the purpose of the\n+         iso_c_binding derived types.  */\n+      derived->ts.f90_type = BT_VOID;\n+      return derived->backend_decl;\n+    }\n+  \n   /* derived->backend_decl != 0 means we saw it before, but its\n      components' backend_decl may have not been built.  */\n   if (derived->backend_decl)\n@@ -1506,6 +1693,16 @@ gfc_get_derived_type (gfc_symbol * derived)\n \n       if (!c->pointer || c->ts.derived->backend_decl == NULL)\n \tc->ts.derived->backend_decl = gfc_get_derived_type (c->ts.derived);\n+\n+      if (c->ts.derived && c->ts.derived->attr.is_iso_c)\n+        {\n+          /* Need to copy the modified ts from the derived type.  The\n+             typespec was modified because C_PTR/C_FUNPTR are translated\n+             into (void *) from derived types.  */\n+          c->ts.type = c->ts.derived->ts.type;\n+          c->ts.kind = c->ts.derived->ts.kind;\n+          c->ts.f90_type = c->ts.derived->ts.f90_type;\n+        }\n     }\n \n   if (TYPE_FIELDS (derived->backend_decl))"}, {"sha": "c08ccd90d3d766eb2b00e6209059b58c770f1825", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -1,3 +1,104 @@\n+2007-07-01  Christopher D. Rickett  <crickett@lanl.gov>\n+\n+\t* bind_c_array_params.f03: New files for Fortran 2003 ISO C Binding.\n+\t* bind_c_coms.f90: Ditto.\n+\t* bind_c_coms_driver.c: Ditto.\n+\t* bind_c_dts.f90: Ditto.\n+\t* bind_c_dts_2.f03: Ditto.\n+\t* bind_c_dts_2_driver.c: Ditto.\n+\t* bind_c_dts_3.f03: Ditto.\n+\t* bind_c_dts_4.f03: Ditto.\n+\t* bind_c_dts_driver.c: Ditto.\n+\t* bind_c_implicit_vars.f03: Ditto.\n+\t* bind_c_procs.f03: Ditto.\n+\t* bind_c_usage_2.f03: Ditto.\n+\t* bind_c_usage_3.f03: Ditto.\n+\t* bind_c_usage_5.f03: Ditto.\n+\t* bind_c_usage_6.f03: Ditto.\n+\t* bind_c_usage_7.f03: Ditto.\n+\t* bind_c_vars.f90: Ditto.\n+\t* bind_c_vars_driver.c: Ditto.\n+\t* binding_c_table_15_1.f03: Ditto.\n+\t* binding_label_tests.f03: Ditto.\n+\t* binding_label_tests_10.f03: Ditto.\n+\t* binding_label_tests_10_main.f03: Ditto.\n+\t* binding_label_tests_11.f03: Ditto.\n+\t* binding_label_tests_11_main.f03: Ditto.\n+\t* binding_label_tests_12.f03: Ditto.\n+\t* binding_label_tests_13.f03: Ditto.\n+\t* binding_label_tests_13_main.f03: Ditto.\n+\t* binding_label_tests_14.f03: Ditto.\n+\t* binding_label_tests_2.f03: Ditto.\n+\t* binding_label_tests_3.f03: Ditto.\n+\t* binding_label_tests_4.f03: Ditto.\n+\t* binding_label_tests_5.f03: Ditto.\n+\t* binding_label_tests_6.f03: Ditto.\n+\t* binding_label_tests_7.f03: Ditto.\n+\t* binding_label_tests_8.f03: Ditto.\n+\t* binding_label_tests_9.f03: Ditto.\n+\t* c_assoc.f90: Ditto.\n+\t* c_assoc_2.f03: Ditto.\n+\t* c_f_pointer_shape_test.f90: Ditto.\n+\t* c_f_pointer_tests.f90: Ditto.\n+\t* c_f_tests_driver.c: Ditto.\n+\t* c_funloc_tests.f03: Ditto.\n+\t* c_funloc_tests_2.f03: Ditto.\n+\t* c_funloc_tests_3.f03: Ditto.\n+\t* c_funloc_tests_3_funcs.c: Ditto.\n+\t* c_kind_params.f90: Ditto.\n+\t* c_kind_tests_2.f03: Ditto.\n+\t* c_kinds.c: Ditto.\n+\t* c_loc_driver.c: Ditto.\n+\t* c_loc_test.f90: Ditto.\n+\t* c_loc_tests_2.f03: Ditto.\n+\t* c_loc_tests_2_funcs.c: Ditto.\n+\t* c_loc_tests_3.f03: Ditto.\n+\t* c_loc_tests_4.f03: Ditto.\n+\t* c_loc_tests_5.f03: Ditto.\n+\t* c_loc_tests_6.f03: Ditto.\n+\t* c_loc_tests_7.f03: Ditto.\n+\t* c_loc_tests_8.f03: Ditto.\n+\t* c_ptr_tests.f03: Ditto.\n+\t* c_ptr_tests_10.f03: Ditto.\n+\t* c_ptr_tests_5.f03: Ditto.\n+\t* c_ptr_tests_7.f03: Ditto.\n+\t* c_ptr_tests_7_driver.c: Ditto.\n+\t* c_ptr_tests_8.f03: Ditto.\n+\t* c_ptr_tests_8_funcs.c: Ditto.\n+\t* c_ptr_tests_9.f03: Ditto.\n+\t* c_ptr_tests_driver.c: Ditto.\n+\t* c_size_t_driver.c: Ditto.\n+\t* c_size_t_test.f03: Ditto.\n+\t* com_block_driver.f90: Ditto.\n+\t* global_vars_c_init.f90: Ditto.\n+\t* global_vars_c_init_driver.c: Ditto.\n+\t* global_vars_f90_init.f90: Ditto.\n+\t* global_vars_f90_init_driver.c: Ditto.\n+\t* interop_params.f03: Ditto.\n+\t* iso_c_binding_only.f03: Ditto.\n+\t* iso_c_binding_rename_1.f03: Ditto.\n+\t* iso_c_binding_rename_1_driver.c: Ditto.\n+\t* iso_c_binding_rename_2.f03: Ditto.\n+\t* iso_c_binding_rename_2_driver.c: Ditto.\n+\t* kind_tests_2.f03: Ditto.\n+\t* kind_tests_3.f03: Ditto.\n+\t* module_md5_1.f90: Ditto.\n+\t* only_clause_main.c: Ditto.\n+\t* print_c_kinds.f90: Ditto.\n+\t* test_bind_c_parens.f03: Ditto.\n+\t* test_c_assoc.c: Ditto.\n+\t* test_com_block.f90: Ditto.\n+\t* test_common_binding_labels.f03: Ditto.\n+\t* test_common_binding_labels_2.f03: Ditto.\n+\t* test_common_binding_labels_2_main.f03: Ditto.\n+\t* test_common_binding_labels_3.f03: Ditto.\n+\t* test_common_binding_labels_3_main.f03: Ditto.\n+\t* test_only_clause.f90: Ditto.\n+\t* use_iso_c_binding.f90: Ditto.\n+\t* value_5.f90: Ditto.\n+\t* value_test.f90: Ditto.\n+\t* value_tests_f03.f90: Ditto.\n+\n 2007-07-01  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* gcc.dg/tls/opt-14.c: New."}, {"sha": "6590db1d1d69341f2a5b489d169fda6fe7c09ea6", "filename": "gcc/testsuite/gfortran.dg/bind_c_array_params.f03", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+module bind_c_array_params\n+use, intrinsic :: iso_c_binding\n+implicit none\n+\n+contains\n+  subroutine sub0(assumed_array) bind(c) ! { dg-error \"cannot be an argument\" }\n+    integer(c_int), dimension(:) :: assumed_array\n+  end subroutine sub0\n+\n+  subroutine sub1(deferred_array) bind(c) ! { dg-error \"cannot\" } \n+    integer(c_int), pointer :: deferred_array(:)\n+  end subroutine sub1\n+end module bind_c_array_params"}, {"sha": "e88d56d182ca8dbcb5a754e005f4b7909d99abfb", "filename": "gcc/testsuite/gfortran.dg/bind_c_coms.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_coms.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_coms.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_coms.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+! { dg-additional-sources bind_c_coms_driver.c }\n+! { dg-options \"-w\" }\n+! the -w option is to prevent the warning about long long ints\n+module bind_c_coms\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+  common /COM/ R, S\n+  real(c_double) :: r\n+  real(c_double) :: t \n+  real(c_double) :: s \n+  bind(c) :: /COM/, /SINGLE/, /MYCOM/\n+  common /SINGLE/ T\n+  common /MYCOM/ LONG_INTS\n+  integer(c_long) :: LONG_INTS\n+  common /MYCOM2/ LONG_LONG_INTS\n+  integer(c_long_long) :: long_long_ints\n+  bind(c) :: /mycom2/\n+\n+  common /com2/ i, j\n+  integer(c_int) :: i, j\n+  bind(c, name=\"f03_com2\") /com2/\n+\n+  common /com3/ m, n\n+  integer(c_int) :: m, n\n+  bind(c, name=\"\") /com3/\n+\n+contains\n+  subroutine test_coms() bind(c)\n+    r = r + .1d0;\n+    s = s + .1d0;\n+    t = t + .1d0;\n+    long_ints = long_ints + 1\n+    long_long_ints = long_long_ints + 1\n+    i = i + 1\n+    j = j + 1\n+\n+    m = 1\n+    n = 1\n+  end subroutine test_coms\n+end module bind_c_coms\n+\n+module bind_c_coms_2\n+  use, intrinsic :: iso_c_binding, only: c_int\n+  common /com3/ m, n\n+  integer(c_int) :: m, n\n+  bind(c, name=\"\") /com3/\n+end module bind_c_coms_2\n+\n+! { dg-final { cleanup-modules \"bind_c_coms bind_c_coms_2\" } }"}, {"sha": "c83f22d836f1012e6877d70f0024109416e00431", "filename": "gcc/testsuite/gfortran.dg/bind_c_coms_driver.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_coms_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_coms_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_coms_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,42 @@\n+double fabs(double);\n+\n+void test_coms(void);\n+\n+extern void abort(void);\n+\n+struct {double r, s; } com;     /* refers to the common block \"com\" */\n+double single;                  /* refers to the common block \"single\" */\n+long int mycom;                 /* refers to the common block \"MYCOM\" */\n+long long int mycom2;           /* refers to the common block \"MYCOM2\" */\n+struct {int i, j; } f03_com2;   /* refers to the common block \"com2\" */\n+\n+int main(int argc, char **argv)\n+{\n+  com.r = 1.0;\n+  com.s = 2.0;\n+  single = 1.0;\n+  mycom = 1;\n+  mycom2 = 2;\n+  f03_com2.i = 1;\n+  f03_com2.j = 2;\n+\n+  /* change the common block variables in F90 */\n+  test_coms();\n+\n+  if(fabs(com.r - 1.1) > 0.00000000)\n+    abort();\n+  if(fabs(com.s - 2.1) > 0.00000000)\n+    abort();\n+  if(fabs(single - 1.1) > 0.00000000)\n+    abort();\n+  if(mycom != 2)\n+    abort();\n+  if(mycom2 != 3)\n+    abort();\n+  if(f03_com2.i != 2)\n+    abort();\n+  if(f03_com2.j != 3)\n+    abort();\n+  \n+  return 0;\n+}/* end main() */"}, {"sha": "f78630ba5604b6644db978ce34260d1c6dbe4134", "filename": "gcc/testsuite/gfortran.dg/bind_c_dts.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+! { dg-additional-sources bind_c_dts_driver.c }\n+module bind_c_dts\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+  type, bind(c) :: MYFTYPE_1\n+     integer(c_int) :: i, j\n+     real(c_float) :: s\n+  end type MYFTYPE_1\n+\n+  TYPE, BIND(C) :: particle\n+     REAL(C_DOUBLE) :: x,vx\n+     REAL(C_DOUBLE) :: y,vy\n+     REAL(C_DOUBLE) :: z,vz\n+     REAL(C_DOUBLE) :: m\n+  END TYPE particle\n+\n+  type(myftype_1), bind(c, name=\"myDerived\") :: myDerived\n+\n+contains\n+  subroutine types_test(my_particles, num_particles) bind(c)\n+    integer(c_int), value :: num_particles\n+    type(particle), dimension(num_particles) :: my_particles\n+    integer :: i\n+\n+    ! going to set the particle in the middle of the list\n+    i = num_particles / 2;\n+    my_particles(i)%x = my_particles(i)%x + .2d0\n+    my_particles(i)%vx = my_particles(i)%vx + .2d0\n+    my_particles(i)%y = my_particles(i)%y + .2d0\n+    my_particles(i)%vy = my_particles(i)%vy + .2d0\n+    my_particles(i)%z = my_particles(i)%z + .2d0\n+    my_particles(i)%vz = my_particles(i)%vz + .2d0\n+    my_particles(i)%m = my_particles(i)%m + .2d0\n+\n+    myDerived%i = myDerived%i + 1\n+    myDerived%j = myDerived%j + 1\n+    myDerived%s = myDerived%s + 1.0;\n+  end subroutine types_test\n+end module bind_c_dts"}, {"sha": "4e5e61b4ee8ae8d6b5691286c12d2d30c08849a3", "filename": "gcc/testsuite/gfortran.dg/bind_c_dts_2.f03", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_2.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do run }\n+! { dg-additional-sources bind_c_dts_2_driver.c }\n+module bind_c_dts_2\n+use, intrinsic :: iso_c_binding\n+implicit none\n+\n+type, bind(c) :: my_c_type_0\n+   integer(c_int) :: i\n+   type(c_ptr) :: nested_c_address\n+   integer(c_int) :: array(3)\n+end type my_c_type_0\n+\n+type, bind(c) :: my_c_type_1\n+   type(my_c_type_0) :: my_nested_type\n+   type(c_ptr) :: c_address\n+   integer(c_int) :: j\n+end type my_c_type_1\n+\n+contains\n+  subroutine sub0(my_type, expected_i, expected_nested_c_address, &\n+       expected_array_1, expected_array_2, expected_array_3, &\n+       expected_c_address, expected_j) bind(c)\n+    type(my_c_type_1) :: my_type\n+    integer(c_int), value :: expected_i\n+    type(c_ptr), value :: expected_nested_c_address\n+    integer(c_int), value :: expected_array_1\n+    integer(c_int), value :: expected_array_2\n+    integer(c_int), value :: expected_array_3\n+    type(c_ptr), value :: expected_c_address\n+    integer(c_int), value :: expected_j\n+\n+    if (my_type%my_nested_type%i .ne. expected_i) then\n+       call abort ()\n+    end if\n+\n+    if (.not. c_associated(my_type%my_nested_type%nested_c_address, &\n+         expected_nested_c_address)) then\n+       call abort ()\n+    end if\n+\n+    if (my_type%my_nested_type%array(1) .ne. expected_array_1) then\n+       call abort ()\n+    end if\n+\n+    if (my_type%my_nested_type%array(2) .ne. expected_array_2) then\n+       call abort ()\n+    end if\n+\n+    if (my_type%my_nested_type%array(3) .ne. expected_array_3) then\n+       call abort ()\n+    end if\n+\n+    if (.not. c_associated(my_type%c_address, expected_c_address)) then\n+       call abort ()\n+    end if\n+\n+    if (my_type%j .ne. expected_j) then\n+       call abort ()\n+    end if\n+  end subroutine sub0\n+end module bind_c_dts_2"}, {"sha": "53d26794e3f62a006c2fb47ac5679ffa38fa59eb", "filename": "gcc/testsuite/gfortran.dg/bind_c_dts_2_driver.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_2_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_2_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_2_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,37 @@\n+typedef struct c_type_0\n+{\n+  int i;\n+  int *ptr;\n+  int array[3];\n+}c_type_0_t;\n+\n+typedef struct c_type_1\n+{\n+  c_type_0_t nested_type;\n+  int *ptr;\n+  int j;\n+}c_type_1_t;\n+\n+void sub0(c_type_1_t *c_type, int expected_i, int *expected_nested_ptr,\n+          int array_0, int array_1, int array_2, \n+          int *expected_ptr, int expected_j);\n+\n+int main(int argc, char **argv)\n+{\n+  c_type_1_t c_type;\n+\n+  c_type.nested_type.i = 10;\n+  c_type.nested_type.ptr = &(c_type.nested_type.i);\n+  c_type.nested_type.array[0] = 1;\n+  c_type.nested_type.array[1] = 2;\n+  c_type.nested_type.array[2] = 3;\n+  c_type.ptr = &(c_type.j);\n+  c_type.j = 11;\n+  \n+  sub0(&c_type, c_type.nested_type.i, c_type.nested_type.ptr, \n+       c_type.nested_type.array[0],\n+       c_type.nested_type.array[1], c_type.nested_type.array[2], \n+       c_type.ptr, c_type.j);\n+  \n+  return 0;\n+}"}, {"sha": "6c6da9f5785ff7d3b434cec78c4e3f97a7a7d9f2", "filename": "gcc/testsuite/gfortran.dg/bind_c_dts_3.f03", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_3.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+module bind_c_dts_3\n+use, intrinsic :: iso_c_binding\n+implicit none\n+\n+TYPE, bind(c) :: t\n+  integer(c_int) :: i\n+end type t\n+\n+type :: my_c_type_0 ! { dg-error \"must have the BIND attribute\" }\n+   integer(c_int) :: i\n+end type my_c_type_0\n+\n+type, bind(c) :: my_c_type_1 ! { dg-error \"BIND.C. derived type\" }\n+   type(my_c_type_0) :: my_nested_type\n+   type(c_ptr) :: c_address\n+   integer(c_int), pointer :: j ! { dg-error \"cannot have the POINTER\" }\n+end type my_c_type_1\n+\n+type, bind(c) :: t2 ! { dg-error \"BIND.C. derived type\" }\n+   type (t2), pointer :: next ! { dg-error \"cannot have the POINTER\" }\n+end type t2\n+\n+type, bind(c):: t3 ! { dg-error \"BIND.C. derived type\" }\n+  type(t), allocatable :: c(:) ! { dg-error \"cannot have the ALLOCATABLE\" }\n+end type t3\n+\n+contains\n+  subroutine sub0(my_type, expected_value) bind(c) ! { dg-error \"is not C interoperable\" }\n+    type(my_c_type_1) :: my_type\n+    integer(c_int), value :: expected_value\n+\n+    if (my_type%my_nested_type%i .ne. expected_value) then\n+       call abort ()\n+    end if\n+  end subroutine sub0\n+end module bind_c_dts_3\n+\n+! { dg-final { cleanup-modules \"bind_c_dts_3\" } }"}, {"sha": "b2eb5694f1c477a4fce797dfb946c219676d5df3", "filename": "gcc/testsuite/gfortran.dg/bind_c_dts_4.f03", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_4.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+module test\n+use iso_c_binding, only: c_int\n+    type, bind(c) ::  foo\n+      integer :: p ! { dg-warning \"may not be C interoperable\" }\n+    end type\n+    type(foo), bind(c) :: cp\n+end module test\n+\n+! { dg-final { cleanup-modules \"test\" } }"}, {"sha": "bf076ce4a40650c81394bfed85230258d6a9833e", "filename": "gcc/testsuite/gfortran.dg/bind_c_dts_driver.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_dts_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,66 @@\n+double fabs (double);\n+\n+/* interops with myftype_1 */\n+typedef struct {\n+   int m, n;\n+   float r;\n+} myctype_t;\n+\n+/* interops with particle in f90 */\n+typedef struct particle\n+{\n+   double x;  /* x position */\n+   double vx; /* velocity in x direction */\n+   double y;  /* y position */\n+   double vy; /* velocity in y direction */\n+   double z;  /* z position */\n+   double vz; /* velocity in z direction */\n+   double m;  /* mass */\n+}particle_t;\n+\n+extern void abort(void);\n+void types_test(particle_t *my_particles, int num_particles);\n+/* declared in the fortran module bind_c_dts */\n+extern myctype_t myDerived;\n+\n+int main(int argc, char **argv)\n+{\n+   particle_t my_particles[100];\n+\n+   /* the fortran code will modify the middle particle */\n+   my_particles[49].x = 1.0;\n+   my_particles[49].vx = 1.0;\n+   my_particles[49].y = 1.0;\n+   my_particles[49].vy = 1.0;\n+   my_particles[49].z = 1.0;\n+   my_particles[49].vz = 1.0;\n+   my_particles[49].m = 1.0;\n+\n+   myDerived.m = 1;\n+   myDerived.n = 2;\n+   myDerived.r = 3.0;\n+\n+   types_test(&(my_particles[0]), 100);\n+\n+   if(fabs(my_particles[49].x - 1.2) > 0.00000000)\n+      abort();\n+   if(fabs(my_particles[49].vx - 1.2) > 0.00000000)\n+      abort();\n+   if(fabs(my_particles[49].y - 1.2) > 0.00000000)\n+      abort();\n+   if(fabs(my_particles[49].vy - 1.2) > 0.00000000)\n+      abort();\n+   if(fabs(my_particles[49].z - 1.2) > 0.00000000)\n+      abort();\n+   if(fabs(my_particles[49].vz - 1.2) > 0.00000000)\n+      abort();\n+   if(fabs(my_particles[49].m - 1.2) > 0.00000000)\n+      abort();\n+   if(myDerived.m != 2)\n+      abort();\n+   if(myDerived.n != 3)\n+      abort();\n+   if(fabs(myDerived.r - 4.0) > 0.00000000)\n+      abort();\n+   return 0;\n+}/* end main() */"}, {"sha": "ff284ce33466f4d8f00f376cabae3b7e32c8af06", "filename": "gcc/testsuite/gfortran.dg/bind_c_implicit_vars.f03", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_implicit_vars.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_implicit_vars.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_implicit_vars.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+module bind_c_implicit_vars\n+\n+bind(c) :: j ! { dg-warning \"may not be C interoperable\" }\n+\n+contains\n+  subroutine sub0(i) bind(c) ! { dg-warning \"may not be C interoperable\" }\n+    i = 0\n+  end subroutine sub0\n+end module bind_c_implicit_vars"}, {"sha": "718042bafcbe5640210456a31a99c2cc8dd91f7b", "filename": "gcc/testsuite/gfortran.dg/bind_c_procs.f03", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_procs.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_procs.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_procs.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+module bind_c_procs\n+  use, intrinsic :: iso_c_binding, only: c_int\n+\n+  interface\n+     ! warning for my_param possibly not being C interoperable\n+     subroutine my_c_sub(my_param) bind(c) ! { dg-warning \"may not be C interoperable\" }\n+       integer, value :: my_param\n+     end subroutine my_c_sub\n+\n+     ! warning for my_c_func possibly not being a C interoperable kind\n+     ! warning for my_param possibly not being C interoperable\n+     ! error message truncated to provide an expression that both warnings\n+     ! should match.\n+     function my_c_func(my_param) bind(c) ! { dg-warning \"may not be\" }\n+       integer, value :: my_param\n+       integer :: my_c_func\n+     end function my_c_func\n+  end interface\n+\n+contains\n+  ! warning for my_param possibly not being C interoperable\n+  subroutine my_f03_sub(my_param) bind(c) ! { dg-warning \"may not be\" }\n+    integer, value :: my_param\n+  end subroutine my_f03_sub\n+\n+  ! warning for my_f03_func possibly not being a C interoperable kind\n+  ! warning for my_param possibly not being C interoperable\n+  ! error message truncated to provide an expression that both warnings\n+  ! should match.\n+  function my_f03_func(my_param) bind(c) ! { dg-warning \"may not be\" }\n+    integer, value :: my_param\n+    integer :: my_f03_func\n+    my_f03_func = 1\n+  end function my_f03_func\n+\n+end module bind_c_procs\n+\n+! { dg-final { cleanup-modules \"bind_c_procs\" } }"}, {"sha": "e76215e7f2b1ba70ab0096822a8275a29dc841e6", "filename": "gcc/testsuite/gfortran.dg/bind_c_usage_2.f03", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_2.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+use, intrinsic :: iso_c_binding\n+type, bind(c) :: mytype\n+  integer(c_int) :: j\n+end type mytype\n+\n+type(mytype), bind(c) :: mytype_var ! { dg-error \"cannot be BIND.C.\" }\n+\n+integer(c_int), bind(c) :: i ! { dg-error \"cannot be declared with BIND.C.\" }\n+integer(c_int), bind(c), dimension(10) :: my_array ! { dg-error \"cannot be BIND.C.\" }\n+\n+common /COM/ i\n+bind(c) :: /com/\n+\n+end"}, {"sha": "47f9d9a921839519dce67e77da10d463767d41c0", "filename": "gcc/testsuite/gfortran.dg/bind_c_usage_3.f03", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_3.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+module test\n+  use, intrinsic :: iso_c_binding\n+\n+  type, bind(c) :: my_c_type ! { dg-error \"BIND.C. derived type\" }\n+     integer(c_int), pointer :: ptr ! { dg-error \"cannot have the POINTER attribute\" }\n+  end type my_c_type \n+  \n+  type, bind(c) :: my_type ! { dg-error \"BIND.C. derived type\" }\n+     integer(c_int), allocatable :: ptr(:) ! { dg-error \"cannot have the ALLOCATABLE attribute\" }\n+  end type my_type\n+\n+  type foo ! { dg-error \"must have the BIND attribute\" }\n+    integer(c_int) :: p \n+  end type foo \n+\n+  type(foo), bind(c) :: cp ! { dg-error \"is not C interoperable\" }\n+  real(c_double), pointer,bind(c) :: p ! { dg-error \"cannot have both the POINTER and BIND.C.\" }\n+end module test"}, {"sha": "95afa010fb1dd6133e761fdd7648471e1da06268", "filename": "gcc/testsuite/gfortran.dg/bind_c_usage_5.f03", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_5.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,8 @@\n+! { dg-do compile }\n+module bind_c_usage_5\n+use, intrinsic :: iso_c_binding\n+\n+bind(c) c3, c4 \n+integer(c_int), bind(c) :: c3 ! { dg-error \"Duplicate BIND attribute\" }\n+integer(c_int) :: c4\n+end module bind_c_usage_5"}, {"sha": "924dd40bc69578be8b84857e18bdae2d5912f1a8", "filename": "gcc/testsuite/gfortran.dg/bind_c_usage_6.f03", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_6.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do compile }\n+module x\n+  use iso_c_binding\n+  bind(c) :: test, sub1 ! { dg-error \"only be used for variables or common blocks\" }\n+  bind(c) :: sub2 ! { dg-error \"only be used for variables or common blocks\" }\n+contains\n+  function foo() bind(c,name=\"xx\")\n+    integer(c_int),bind(c,name=\"xy\") :: foo ! { dg-error \"only be used for variables or common blocks\" }\n+    ! NAG f95: \"BIND(C) for non-variable FOO\"  \n+    ! g95: \"Duplicate BIND attribute specified\"\n+    ! gfortran: Accepted\n+    foo = 5_c_int\n+  end function foo\n+\n+  function test()\n+    integer(c_int) :: test\n+    bind(c,name=\"kk\") :: test ! { dg-error \"only be used for variables or common blocks\" }\n+    ! NAG f95: \"BIND(C) for non-variable TEST\"\n+    ! gfortran, g95: Accepted\n+    test = 5_c_int\n+  end function test\n+\n+  function bar() bind(c)\n+    integer(c_int) :: bar \n+    bind(c,name=\"zx\") :: bar ! { dg-error \"only be used for variables or common blocks\" }\n+    bar = 5_c_int\n+  end function bar\n+\n+  subroutine sub0() bind(c)\n+    bind(c) :: sub0 ! { dg-error \"only be used for variables or common blocks\" }\n+  end subroutine sub0\n+\n+  subroutine sub1(i) bind(c)\n+    use, intrinsic :: iso_c_binding, only: c_int\n+    integer(c_int), value :: i\n+  end subroutine sub1\n+\n+  subroutine sub2(i) \n+    use, intrinsic :: iso_c_binding, only: c_int\n+    integer(c_int), value :: i\n+  end subroutine sub2\n+\n+  subroutine sub3(i) \n+    use, intrinsic :: iso_c_binding, only: c_int\n+    integer(c_int), value :: i\n+    bind(c) :: sub3 ! { dg-error \"only be used for variables or common blocks\" }\n+  end subroutine sub3\n+end module x"}, {"sha": "845aab95322236b569a3f80b27e847fcbd2610e2", "filename": "gcc/testsuite/gfortran.dg/bind_c_usage_7.f03", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_usage_7.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+module x\n+  use iso_c_binding\n+  implicit none\n+contains\n+  function bar() bind(c) ! { dg-error \"cannot be an array\" }\n+    integer(c_int) :: bar(5)\n+  end function bar\n+\n+  function my_string_func() bind(c) ! { dg-error \"cannot be a character string\" }\n+    character(kind=c_char, len=10) :: my_string_func\n+    my_string_func = 'my_string' // C_NULL_CHAR\n+  end function my_string_func\n+end module x\n+\n+! { dg-final { cleanup-modules \"x\" } }"}, {"sha": "4f4a0cfd795ba6fa0eb8fa653e3ee290a8b0d885", "filename": "gcc/testsuite/gfortran.dg/bind_c_vars.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_vars.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_vars.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_vars.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+! { dg-additional-sources bind_c_vars_driver.c }\n+module bind_c_vars\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+  integer(c_int), bind(c) :: myF90Int\n+  real(c_float), bind(c, name=\"myF90Real\") :: f90_real\n+  integer(c_int) :: c2\n+  integer(c_int) :: c3\n+  integer(c_int) :: c4\n+  bind(c, name=\"myVariable\") :: c2\n+  bind(c) c3, c4 \n+\n+  integer(c_int), bind(c, name=\"myF90Array3D\") :: A(18, 3:7, 10)\n+  integer(c_int), bind(c, name=\"myF90Array2D\") :: B(3, 2)\n+\n+contains\n+  \n+  subroutine changeF90Globals() bind(c, name='changeF90Globals')\n+    implicit none\n+    ! should make it 2\n+    myF90Int = myF90Int + 1\n+    ! should make it 3.0\n+    f90_real = f90_real * 3.0;\n+    ! should make it 4\n+    c2 = c2 * 2;\n+    ! should make it 6\n+    c3 = c3 + 3;\n+    ! should make it 2\n+    c4 = c4 / 2;\n+    ! should make it 2\n+    A(5, 6, 3) = A(5, 6, 3) + 1\n+    ! should make it 3\n+    B(3, 2) = B(3, 2) + 1\n+  end subroutine changeF90Globals\n+\n+end module bind_c_vars"}, {"sha": "2af800a15c2446e5974b2dc7b02fa44d19291a58", "filename": "gcc/testsuite/gfortran.dg/bind_c_vars_driver.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_vars_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_vars_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_vars_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,46 @@\n+double fabs (double);\n+\n+/* defined in fortran module bind_c_vars */\n+void changeF90Globals(void);\n+\n+extern void abort(void);\n+\n+/* module level scope in bind_c_vars */\n+extern int myf90int;         /* myf90int in bind_c_vars */\n+float myF90Real;             /* f90_real in bind_c_vars */\n+int myF90Array3D[10][5][18]; /* A in bind_c_vars */\n+int myF90Array2D[2][3];      /* B in bind_c_vars */\n+int myVariable;              /* c2 in bind_c_vars */\n+int c3;                      /* c3 in bind_c_vars */\n+int c4;                      /* c4 in bind_c_vars */\n+\n+int main(int argc, char **argv)\n+{\n+   myf90int = 1;\n+   myF90Real = 1.0;\n+   myVariable = 2;\n+   c3 = 3;\n+   c4 = 4;\n+   myF90Array3D[2][3][4] = 1;\n+   myF90Array2D[1][2] = 2;\n+\n+   /* will change the global vars initialized above */\n+   changeF90Globals();\n+\n+   if(myf90int != 2)\n+      abort();\n+   if(fabs(myF90Real-3.0) > 0.00000000)\n+      abort();\n+   if(myVariable != 4)\n+      abort();\n+   if(c3 != 6)\n+      abort();\n+   if(c4 != 2)\n+      abort();\n+   if(myF90Array3D[2][3][4] != 2)\n+      abort();\n+   if(myF90Array2D[1][2] != 3)\n+      abort();\n+   \n+   return 0;\n+}/* end main() */"}, {"sha": "a5573092d8502984c8cd6848d8241a5e6cab5a4d", "filename": "gcc/testsuite/gfortran.dg/binding_c_table_15_1.f03", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_c_table_15_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_c_table_15_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_c_table_15_1.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! Test the named constants in Table 15.1.\n+program a\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+  if (C_NULL_CHAR       /=  CHAR(0) ) call abort\n+  if (C_ALERT           /= ACHAR(7) ) call abort\n+  if (C_BACKSPACE       /= ACHAR(8) ) call abort\n+  if (C_FORM_FEED       /= ACHAR(12)) call abort\n+  if (C_NEW_LINE        /= ACHAR(10)) call abort\n+  if (C_CARRIAGE_RETURN /= ACHAR(13)) call abort\n+  if (C_HORIZONTAL_TAB  /= ACHAR(9) ) call abort\n+  if (C_VERTICAL_TAB    /= ACHAR(11)) call abort\n+end program a"}, {"sha": "34986501e2965f1cb71ca36538f8916ed135e552", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests.f03", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,77 @@\n+! { dg-do compile }\n+module binding_label_tests\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+  contains\n+\n+  subroutine c_sub() BIND(c, name = \"C_Sub\")\n+    print *, 'hello from c_sub'\n+  end subroutine c_sub\n+\n+  integer(c_int) function c_func() bind(C, name=\"__C_funC\")\n+    print *, 'hello from c_func'\n+    c_func = 1\n+  end function c_func\n+\n+  real(c_float) function f90_func() \n+    print *, 'hello from f90_func'\n+    f90_func = 1.0\n+  end function f90_func\n+\n+  real(c_float) function c_real_func() bind(c)\n+    print *, 'hello from c_real_func'\n+    c_real_func = 1.5\n+  end function c_real_func\n+\n+  integer function f90_func_0() result ( f90_func_0_result ) \n+    print *, 'hello from f90_func_0'\n+    f90_func_0_result = 0\n+  end function f90_func_0\n+\n+  integer(c_int) function f90_func_1() result ( f90_func_1_result ) bind(c, name=\"__F90_Func_1__\")\n+    print *, 'hello from f90_func_1'\n+    f90_func_1_result = 1\n+  end function f90_func_1\n+\n+  integer(c_int) function f90_func_3() result ( f90_func_3_result ) bind(c)\n+    print *, 'hello from f90_func_3'\n+    f90_func_3_result = 3\n+  end function f90_func_3\n+\n+  integer(c_int) function F90_func_2() bind(c) result ( f90_func_2_result ) \n+    print *, 'hello from f90_func_2'\n+    f90_func_2_result = 2\n+  end function f90_func_2\n+\n+  integer(c_int) function F90_func_4() bind(c, name=\"F90_func_4\") result ( f90_func_4_result ) \n+    print *, 'hello from f90_func_4'\n+    f90_func_4_result = 4\n+  end function f90_func_4\n+\n+  integer(c_int) function F90_func_5() bind(c, name=\"F90_func_5\") result ( f90_func_5_result ) \n+    print *, 'hello from f90_func_5'\n+    f90_func_5_result = 5\n+  end function f90_func_5\n+\n+  subroutine c_sub_2() bind(c, name='c_sub_2')\n+    print *, 'hello from c_sub_2'\n+  end subroutine c_sub_2\n+\n+  subroutine c_sub_3() BIND(c, name = \"  C_Sub_3  \")\n+    print *, 'hello from c_sub_3'\n+  end subroutine c_sub_3\n+\n+  subroutine c_sub_5() BIND(c, name = \"C_Sub_5        \")\n+    print *, 'hello from c_sub_5'\n+  end subroutine c_sub_5\n+\n+  ! nothing between the quotes except spaces, so name=\"\".\n+  ! the name will get set to the regularly mangled version of the name.  \n+  ! perhaps it should be marked with some characters that are invalid for \n+  ! C names so C can not call it?\n+  subroutine sub4() BIND(c, name = \"        \") \n+  end subroutine sub4 \n+end module binding_label_tests\n+\n+! { dg-final { cleanup-modules \"binding_label_tests\" } }"}, {"sha": "99c9c527624f65bce6be426a803c193066410c4e", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_10.f03", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_10.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_10.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_10.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+! This file must be compiled BEFORE binding_label_tests_10_main.f03, which it \n+! should be because dejagnu will sort the files.\n+module binding_label_tests_10\n+  use iso_c_binding\n+  implicit none\n+  integer(c_int), bind(c,name=\"c_one\") :: one\n+end module binding_label_tests_10\n+\n+! Do not use dg-final to cleanup-modules"}, {"sha": "aa24a6ac1d67c2871660cbfb304ce68d9ba53cf5", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_10_main.f03", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_10_main.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_10_main.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_10_main.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! This file must be compiled AFTER binding_label_tests_10.f03, which it \n+! should be because dejagnu will sort the files.\n+module binding_label_tests_10_main\n+  use iso_c_binding\n+  implicit none\n+  integer(c_int), bind(c,name=\"c_one\") :: one ! { dg-error \"collides\" }\n+end module binding_label_tests_10_main\n+\n+program main\n+  use binding_label_tests_10 ! { dg-error \"collides\" }\n+  use binding_label_tests_10_main\n+end program main\n+\n+! { dg-final { cleanup-modules \"binding_label_tests_10_main binding_label_tests_10\" } }"}, {"sha": "5e889a7886eb0e4279a71e6f63f974d387acc207", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_11.f03", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_11.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_11.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_11.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+! This file must be compiled BEFORE binding_label_tests_11_main.f03, which it \n+! should be because dejagnu will sort the files.\n+module binding_label_tests_11\n+  use iso_c_binding, only: c_int\n+  implicit none\n+contains\n+  function one() bind(c, name=\"c_one\")\n+    integer(c_int) one\n+    one = 1\n+  end function one\n+end module binding_label_tests_11\n+\n+! Do not use dg-final to cleanup-modules"}, {"sha": "53eac7cf5466d18b7094c01598567f8943abbca9", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_11_main.f03", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_11_main.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_11_main.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_11_main.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! This file must be compiled AFTER binding_label_tests_11.f03, which it \n+! should be because dejagnu will sort the files.\n+module binding_label_tests_11_main\n+  use iso_c_binding, only: c_int\n+  implicit none\n+contains\n+  function one() bind(c, name=\"c_one\") ! { dg-error \"collides\" }\n+    integer(c_int) one\n+    one = 1\n+  end function one\n+end module binding_label_tests_11_main\n+\n+program main\n+  use binding_label_tests_11 ! { dg-error \"collides\" }\n+  use binding_label_tests_11_main\n+end program main\n+\n+! { dg-final { cleanup-modules \"binding_label_tests_11_main binding_label_tests_11\" } }"}, {"sha": "0a0006681154943fc5989104295f738e73b9ce45", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_12.f03", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_12.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_12.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_12.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+! This verifies that the compiler will correctly accpet the name=\"\", write out\n+! an empty string for the binding label to the module file, and then read it\n+! back in.  Also, during gfc_verify_binding_labels, the name=\"\" will prevent\n+! any verification (since there is no label to verify).\n+module one\n+contains\n+  subroutine foo() bind(c)\n+  end subroutine foo\n+end module one\n+\n+module two\n+contains\n+  ! This procedure is only used accessed in C\n+  ! as procedural pointer\n+  subroutine foo() bind(c, name=\"\")\n+  end subroutine foo\n+end module two\n+\n+use one, only: foo_one => foo\n+use two, only: foo_two => foo\n+end\n+\n+! { dg-final { cleanup-modules \"one two\" } }"}, {"sha": "786945d3af751eb266c367f53903f24f147485ae", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_13.f03", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_13.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_13.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_13.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,8 @@\n+! { dg-do compile }\n+! This file must be compiled BEFORE binding_label_tests_13_main.f03, which it \n+! should be because dejagnu will sort the files.  \n+module binding_label_tests_13\n+ use, intrinsic :: iso_c_binding, only: c_int\n+  integer(c_int) :: c3\n+  bind(c) c3\n+end module binding_label_tests_13"}, {"sha": "1addc9c495c27f86dc0ab9504853ce99571bd2a0", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_13_main.f03", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_13_main.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_13_main.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_13_main.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+! This file must be compiled AFTER binding_label_tests_13.f03, which it \n+! should be because dejagnu will sort the files.  The module file \n+! binding_label_tests_13.mod can not be removed until after this test is done.\n+module binding_label_tests_13_main\n+  use, intrinsic :: iso_c_binding, only: c_int\n+  integer(c_int) :: c3 ! { dg-error \"collides\" }\n+  bind(c) c3\n+\n+contains\n+  subroutine c_sub() BIND(c, name = \"C_Sub\")\n+    use binding_label_tests_13 ! { dg-error \"collides\" }\n+  end subroutine c_sub\n+end module binding_label_tests_13_main\n+! { dg-final { cleanup-modules \"binding_label_tests_13 binding_label_tests_13_main\" } }\n+"}, {"sha": "041237bbee5d1f6ea02ba42feb052c5322aab904", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_14.f03", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_14.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_14.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_14.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+subroutine display() bind(c)\n+  implicit none\n+end subroutine display\n+\n+program main\n+  implicit none\n+  interface\n+     subroutine display() bind(c)\n+     end subroutine display\n+  end interface\n+end program main"}, {"sha": "bf9da112ab4f80eca030b9d2ca9bc30b2c66eca0", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_2.f03", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_2.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+module binding_label_tests_2\n+\n+contains\n+  ! this is just here so at least one of the subroutines will be accepted so\n+  ! gfortran doesn't give an Extension warning when using -pedantic-errors\n+  subroutine ok() \n+  end subroutine ok\n+\n+  subroutine sub0() bind(c, name=\"   1\") ! { dg-error \"Invalid C name\" }\n+  end subroutine sub0 ! { dg-error \"Expecting END MODULE\" }\n+\n+  subroutine sub1() bind(c, name=\"$\") ! { dg-error \"Invalid C name\" }\n+  end subroutine sub1 ! { dg-error \"Expecting END MODULE\" }\n+\n+  subroutine sub2() bind(c, name=\"abc$\") ! { dg-error \"Invalid C name\" }\n+  end subroutine sub2 ! { dg-error \"Expecting END MODULE\" }\n+\n+  subroutine sub3() bind(c, name=\"abc d\") ! { dg-error \"Embedded space\" }\n+  end subroutine sub3 ! { dg-error \"Expecting END MODULE\" }\n+\n+  subroutine sub5() BIND(C, name=\" myvar 2 \") ! { dg-error \"Embedded space\" }\n+  end subroutine sub5 ! { dg-error \"Expecting END MODULE\" }\n+\n+  subroutine sub6() bind(c, name=\"         ) ! { dg-error \"Invalid C name\" }\n+  end subroutine sub6 ! { dg-error \"Expecting END MODULE\" }\n+\n+  subroutine sub7() bind(c, name=) ! { dg-error \"Syntax error\" }\n+  end subroutine sub7 ! { dg-error \"Expecting END MODULE\" }\n+\n+  subroutine sub8() bind(c, name) ! { dg-error \"Syntax error\" }\n+  end subroutine sub8 ! { dg-error \"Expecting END MODULE\" }\n+end module binding_label_tests_2 \n+\n+! { dg-final { cleanup-modules \"binding_label_tests_2\" } }"}, {"sha": "6e124470251350742522e8596de138bbbcbff5ec", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_3.f03", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_3.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile }\n+program main\n+use iso_c_binding\n+  interface\n+     subroutine p1(f, a1, a2, a3, a4) bind(c, name='printf') ! { dg-error \"collides\" }\n+       import :: c_ptr, c_int, c_double\n+       type(c_ptr), value :: f\n+       integer(c_int), value :: a1, a3\n+       real(c_double), value :: a2, a4\n+     end subroutine p1\n+\n+     subroutine p2(f, a1, a2, a3, a4) bind(c, name='printf') ! { dg-error \"collides\" }\n+       import :: c_ptr, c_int, c_double\n+       type(c_ptr), value :: f\n+       real(c_double), value :: a1, a3\n+       integer(c_int), value :: a2, a4\n+     end subroutine p2\n+  end interface\n+\n+  type(c_ptr) :: f_ptr\n+  character(len=20), target :: format\n+\n+  f_ptr = c_loc(format(1:1))\n+\n+  format = 'Hello %d %f %d %f\\n' // char(0)\n+  call p1(f_ptr, 10, 1.23d0, 20, 2.46d0)\n+\n+  format = 'World %f %d %f %d\\n' // char(0)\n+  call p2(f_ptr, 1.23d0, 10, 2.46d0, 20)\n+end program main"}, {"sha": "5a0767d878555d43fdf57aec0c45f118463d03be", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_4.f03", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_4.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+module A\n+  use, intrinsic :: iso_c_binding\n+contains\n+  subroutine pA() bind(c, name='printf') ! { dg-error \"collides\" }\n+    print *, 'hello from pA'\n+  end subroutine pA\n+end module A\n+\n+module B\n+  use, intrinsic :: iso_c_binding\n+\n+contains\n+  subroutine pB() bind(c, name='printf') ! { dg-error \"collides\" }\n+    print *, 'hello from pB'\n+  end subroutine pB\n+end module B\n+\n+module C\n+use A\n+use B ! { dg-error \"Can't open module file\" }\n+end module C\n+\n+"}, {"sha": "c8aa4e86218d8e1a91e5839d7061e6e0ac4b8760", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_5.f03", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_5.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+module binding_label_tests_5\n+  use, intrinsic :: iso_c_binding\n+  \n+  interface\n+     subroutine sub0() bind(c, name='c_sub') ! { dg-error \"collides\" }\n+     end subroutine sub0\n+     \n+     subroutine sub1() bind(c, name='c_sub') ! { dg-error \"collides\" }\n+     end subroutine sub1\n+  end interface\n+end module binding_label_tests_5"}, {"sha": "0784de12e29316efa8aeca91b031d9de7e5cb44c", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_6.f03", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_6.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,6 @@\n+! { dg-do compile }\n+module binding_label_tests_6\n+  use, intrinsic :: iso_c_binding\n+  integer(c_int), bind(c, name='my_int') :: my_f90_int_1 ! { dg-error \"collides\" }\n+  integer(c_int), bind(c, name='my_int') :: my_f90_int_2 ! { dg-error \"collides\" }\n+end module binding_label_tests_6"}, {"sha": "1234bb535387223b844a29ba5c806f19f57e3f74", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_7.f03", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_7.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+module A\n+  use, intrinsic :: iso_c_binding, only: c_int\n+  integer(c_int), bind(c, name='my_c_print') :: my_int ! { dg-error \"collides\" }\n+end module A\n+\n+program main\n+use A\n+interface\n+   subroutine my_c_print() bind(c) ! { dg-error \"collides\" }\n+   end subroutine my_c_print\n+end interface\n+\n+call my_c_print()\n+end program main"}, {"sha": "c49ee625458236ef03cb590f098f6d6be84b9243", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_8.f03", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_8.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+module binding_label_tests_8\n+  use, intrinsic :: iso_c_binding, only: c_int\n+  integer(c_int), bind(c, name='my_f90_sub') :: my_c_int ! { dg-error \"collides\" }\n+\n+contains\n+  subroutine my_f90_sub() bind(c) ! { dg-error \"collides\" }\n+  end subroutine my_f90_sub\n+end module binding_label_tests_8"}, {"sha": "0f50a08b7e0e37476357eae0dcfe451034a51dbe", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_9.f03", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_9.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+module x\n+  use iso_c_binding\n+  implicit none\n+  private :: bar ! { dg-warning \"PRIVATE but has been given the binding label\" }\n+  private :: my_private_sub\n+  private :: my_private_sub_2 ! { dg-warning \"PRIVATE but has been given the binding label\" }\n+  public :: my_public_sub\n+contains\n+  subroutine bar() bind(c,name=\"foo\") \n+  end subroutine bar\n+  \n+  subroutine my_private_sub() bind(c, name=\"\")\n+  end subroutine my_private_sub\n+\n+  subroutine my_private_sub_2() bind(c) \n+  end subroutine my_private_sub_2\n+\n+  subroutine my_public_sub() bind(c, name=\"my_sub\")\n+  end subroutine my_public_sub\n+end module x\n+\n+! { dg-final { cleanup-modules \"x\" } }"}, {"sha": "9b2af24f984808973f4399349016e00bc8572f03", "filename": "gcc/testsuite/gfortran.dg/c_assoc.f90", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,68 @@\n+! { dg-do run }\n+! { dg-additional-sources test_c_assoc.c }\n+module c_assoc\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+contains\n+\n+  function test_c_assoc_0(my_c_ptr) bind(c)\n+    use, intrinsic :: iso_c_binding, only: c_ptr, c_int, c_associated\n+    integer(c_int) :: test_c_assoc_0\n+    type(c_ptr), value :: my_c_ptr\n+\n+    if(c_associated(my_c_ptr)) then\n+       test_c_assoc_0 = 1\n+    else\n+       test_c_assoc_0 = 0\n+    endif\n+  end function test_c_assoc_0\n+\n+  function test_c_assoc_1(my_c_ptr_1, my_c_ptr_2) bind(c)\n+    use, intrinsic :: iso_c_binding, only: c_ptr, c_int, c_associated\n+    integer(c_int) :: test_c_assoc_1\n+    type(c_ptr), value :: my_c_ptr_1\n+    type(c_ptr), value :: my_c_ptr_2\n+\n+    if(c_associated(my_c_ptr_1, my_c_ptr_2)) then\n+       test_c_assoc_1 = 1\n+    else\n+       test_c_assoc_1 = 0\n+    endif\n+  end function test_c_assoc_1\n+\n+  function test_c_assoc_2(my_c_ptr_1, my_c_ptr_2, num_ptrs) bind(c)\n+    integer(c_int) :: test_c_assoc_2\n+    type(c_ptr), value :: my_c_ptr_1\n+    type(c_ptr), value :: my_c_ptr_2\n+    integer(c_int), value :: num_ptrs\n+    \n+    if(num_ptrs .eq. 1) then\n+       if(c_associated(my_c_ptr_1)) then\n+          test_c_assoc_2 = 1\n+       else\n+          test_c_assoc_2 = 0\n+       endif\n+    else\n+       if(c_associated(my_c_ptr_1, my_c_ptr_2)) then\n+          test_c_assoc_2 = 1\n+       else\n+          test_c_assoc_2 = 0\n+       endif\n+    endif\n+  end function test_c_assoc_2\n+\n+  subroutine verify_assoc(my_c_ptr_1, my_c_ptr_2) bind(c)\n+    type(c_ptr), value :: my_c_ptr_1\n+    type(c_ptr), value :: my_c_ptr_2\n+\n+    if(.not. c_associated(my_c_ptr_1)) then\n+       call abort()\n+    else if(.not. c_associated(my_c_ptr_2)) then\n+       call abort()\n+    else if(.not. c_associated(my_c_ptr_1, my_c_ptr_2)) then\n+       call abort()\n+    endif\n+  end subroutine verify_assoc\n+  \n+end module c_assoc"}, {"sha": "9bb2f1b6abceb4ac160e8967bce75c92c9e1c314", "filename": "gcc/testsuite/gfortran.dg/c_assoc_2.f03", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_assoc_2.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+module c_assoc_2\n+  use, intrinsic :: iso_c_binding, only: c_ptr, c_associated\n+\n+contains\n+  subroutine sub0(my_c_ptr) bind(c)\n+    type(c_ptr), value :: my_c_ptr\n+    type(c_ptr), pointer :: my_c_ptr_2\n+    integer :: my_integer\n+    \n+    if(.not. c_associated(my_c_ptr)) then\n+       call abort()\n+    end if\n+    \n+    if(.not. c_associated(my_c_ptr, my_c_ptr)) then\n+       call abort()\n+    end if\n+\n+    if(.not. c_associated(my_c_ptr, my_c_ptr, my_c_ptr)) then ! { dg-error \"More actual than formal arguments\" }\n+       call abort()\n+    end if\n+\n+    if(.not. c_associated()) then ! { dg-error \"Missing argument\" }\n+       call abort()\n+    end if ! { dg-error \"Expecting END SUBROUTINE\" }\n+\n+    if(.not. c_associated(my_c_ptr_2)) then\n+       call abort()\n+    end if\n+\n+    if(.not. c_associated(my_integer)) then ! { dg-error \"Type/rank mismatch\" }\n+       call abort()\n+    end if\n+  end subroutine sub0\n+\n+end module c_assoc_2"}, {"sha": "c6204bdac7f688870ec99c8f3958b85dde2999ae", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_shape_test.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_test.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_test.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_test.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! verify that the compiler catches the error in the call to c_f_pointer \n+! because it is missing the required SHAPE parameter.  the SHAPE parameter \n+! is optional, in general, but must exist if given a fortran pointer \n+! to a non-zero rank object.  --Rickett, 09.26.06\n+module c_f_pointer_shape_test\n+contains\n+  subroutine test_0(myAssumedArray, cPtr)\n+    use, intrinsic :: iso_c_binding\n+    integer, dimension(*) :: myAssumedArray\n+    integer, dimension(:), pointer :: myArrayPtr\n+    integer, dimension(1:2), target :: myArray\n+    type(c_ptr), value :: cPtr\n+    \n+    myArrayPtr => myArray\n+    call c_f_pointer(cPtr, myArrayPtr) ! { dg-error \"Missing SHAPE parameter\" }\n+  end subroutine test_0\n+end module c_f_pointer_shape_test\n+"}, {"sha": "1e4dbc0201fdcedc94176a3acd249698a9c2be04", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_tests.f90", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,68 @@\n+! { dg-do run }\n+! { dg-additional-sources c_f_tests_driver.c }\n+module c_f_pointer_tests\n+  use, intrinsic :: iso_c_binding\n+\n+  type myF90Derived\n+     integer(c_int) :: cInt\n+     real(c_double) :: cDouble\n+     real(c_float) :: cFloat\n+     integer(c_short) :: cShort\n+     type(c_funptr) :: myFunPtr\n+  end type myF90Derived\n+\n+  type dummyDerived\n+     integer(c_int) :: myInt\n+  end type dummyDerived\n+\n+  contains\n+\n+  subroutine testDerivedPtrs(myCDerived, derivedArray, arrayLen, &\n+       derived2DArray, dim1, dim2) &\n+       bind(c, name=\"testDerivedPtrs\")\n+    implicit none\n+    type(c_ptr), value :: myCDerived\n+    type(c_ptr), value :: derivedArray\n+    integer(c_int), value :: arrayLen\n+    type(c_ptr), value :: derived2DArray\n+    integer(c_int), value :: dim1\n+    integer(c_int), value :: dim2\n+    type(myF90Derived), pointer :: myF90Type\n+    type(myF90Derived), dimension(:), pointer :: myF90DerivedArray\n+    type(myF90Derived), dimension(:,:), pointer :: derivedArray2D\n+    ! one dimensional array coming in (derivedArray)\n+    integer(c_int), dimension(1:1) :: shapeArray\n+    integer(c_int), dimension(1:2) :: shapeArray2\n+    type(myF90Derived), dimension(1:10), target :: tmpArray\n+\n+    call c_f_pointer(myCDerived, myF90Type)\n+    ! make sure numbers are ok.  initialized in c_f_tests_driver.c\n+    if(myF90Type%cInt .ne. 1) then\n+       call abort()\n+    endif\n+    if(myF90Type%cDouble .ne. 2.0d0) then\n+       call abort()\n+    endif\n+    if(myF90Type%cFloat .ne. 3.0) then\n+       call abort()\n+    endif\n+    if(myF90Type%cShort .ne. 4) then\n+       call abort()\n+    endif\n+\n+    shapeArray(1) = arrayLen\n+    call c_f_pointer(derivedArray, myF90DerivedArray, shapeArray)\n+\n+    ! upper bound of each dim is arrayLen2\n+    shapeArray2(1) = dim1\n+    shapeArray2(2) = dim2\n+    call c_f_pointer(derived2DArray, derivedArray2D, shapeArray2)\n+    ! make sure the last element is ok\n+    if((derivedArray2D(dim1, dim2)%cInt .ne. 4) .or. &\n+         (derivedArray2D(dim1, dim2)%cDouble .ne. 4.0d0) .or. &\n+         (derivedArray2D(dim1, dim2)%cFloat .ne. 4.0) .or. &\n+         (derivedArray2D(dim1, dim2)%cShort .ne. 4)) then\n+       call abort()\n+    endif\n+  end subroutine testDerivedPtrs\n+end module c_f_pointer_tests"}, {"sha": "5079cf7990024b9f02a9e06ffad0c7c979bb5aa5", "filename": "gcc/testsuite/gfortran.dg/c_f_tests_driver.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_tests_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_tests_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_tests_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,66 @@\n+extern void abort(void);\n+\n+typedef struct myCDerived\n+{\n+   int cInt;\n+   double cDouble;\n+   float cFloat;\n+   short cShort;\n+   void *ptr;\n+}myCDerived_t;\n+\n+#define DERIVED_ARRAY_LEN 10\n+#define ARRAY_LEN_2 3\n+#define DIM1 2\n+#define DIM2 3\n+\n+void testDerivedPtrs(myCDerived_t *cDerivedPtr,\n+                     myCDerived_t *derivedArray, int arrayLen,\n+                     myCDerived_t *derived2d, int dim1, int dim2);\n+\n+int main(int argc, char **argv)\n+{\n+   myCDerived_t cDerived;\n+   myCDerived_t derivedArray[DERIVED_ARRAY_LEN];\n+   myCDerived_t derived2DArray[DIM1][DIM2];\n+   int i = 0;\n+   int j = 0;\n+\n+   cDerived.cInt = 1;\n+   cDerived.cDouble = 2.0;\n+   cDerived.cFloat = 3.0;\n+   cDerived.cShort = 4;\n+/*    cDerived.ptr = NULL; */\n+   /* nullify the ptr */\n+   cDerived.ptr = 0;\n+\n+   for(i = 0; i < DERIVED_ARRAY_LEN; i++)\n+   {\n+      derivedArray[i].cInt = (i+1) * 1;\n+      derivedArray[i].cDouble = (i+1) * 1.0; /* 2.0; */\n+      derivedArray[i].cFloat = (i+1) * 1.0; /* 3.0; */\n+      derivedArray[i].cShort = (i+1) * 1; /* 4; */\n+/*       derivedArray[i].ptr = NULL; */\n+      derivedArray[i].ptr = 0;\n+   }\n+\n+   for(i = 0; i < DIM1; i++)\n+   {\n+      for(j = 0; j < DIM2; j++)\n+      {\n+         derived2DArray[i][j].cInt = ((i*DIM1) * 1) + j;\n+         derived2DArray[i][j].cDouble = ((i*DIM1) * 1.0) + j;\n+         derived2DArray[i][j].cFloat = ((i*DIM1) * 1.0) + j;\n+         derived2DArray[i][j].cShort = ((i*DIM1) * 1) + j;\n+/*          derived2DArray[i][j].ptr = NULL; */\n+         derived2DArray[i][j].ptr = 0;\n+      }\n+   }\n+\n+   /* send in the transpose size (dim2 is dim1, dim1 is dim2) */\n+   testDerivedPtrs(&cDerived, derivedArray, DERIVED_ARRAY_LEN,\n+                   derived2DArray[0], DIM2, DIM1);\n+   \n+   return 0;\n+}/* end main() */\n+"}, {"sha": "c34ef2b6f4948311985e9944a01437ff2af80818", "filename": "gcc/testsuite/gfortran.dg/c_funloc_tests.f03", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! This test case simply checks that c_funloc exists, accepts arguments of \n+! flavor FL_PROCEDURE, and returns the type c_funptr\n+module c_funloc_tests\n+  use, intrinsic :: iso_c_binding, only: c_funptr, c_funloc\n+\n+contains\n+  subroutine sub0() bind(c)\n+    type(c_funptr) :: my_c_funptr\n+\n+    my_c_funptr = c_funloc(sub0)\n+  end subroutine sub0\n+end module c_funloc_tests\n+\n+program driver\n+  use c_funloc_tests\n+  \n+  call sub0()\n+end program driver\n+\n+! { dg-final { cleanup-modules \"c_funloc_tests\" } }"}, {"sha": "afaf29fc896aeb99319d2f08d9dd773d42364602", "filename": "gcc/testsuite/gfortran.dg/c_funloc_tests_2.f03", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_2.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+module c_funloc_tests_2\n+  use, intrinsic :: iso_c_binding, only: c_funptr, c_funloc\n+  implicit none\n+\n+contains\n+  subroutine sub0() bind(c)\n+    type(c_funptr) :: my_c_funptr\n+    integer :: my_local_variable\n+    \n+    my_c_funptr = c_funloc() ! { dg-error \"Missing argument\" }\n+    my_c_funptr = c_funloc(sub0)\n+    my_c_funptr = c_funloc(sub0, sub0) ! { dg-error \"More actual than formal\" }\n+    my_c_funptr = c_funloc(my_local_variable) ! { dg-error \"must be a procedure\" }\n+  end subroutine sub0\n+end module c_funloc_tests_2"}, {"sha": "2d23efb243a9fbca7e1adf27a79a3371824b2035", "filename": "gcc/testsuite/gfortran.dg/c_funloc_tests_3.f03", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_3.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+! { dg-additional-sources c_funloc_tests_3_funcs.c }\n+! This testcase tests c_funloc and c_funptr from iso_c_binding.  It uses \n+! functions defined in c_funloc_tests_3_funcs.c.\n+module c_funloc_tests_3\n+ implicit none\n+contains\n+  function ffunc(j) bind(c)\n+    use iso_c_binding, only: c_funptr, c_int\n+    integer(c_int)        :: ffunc\n+    integer(c_int), value :: j\n+    ffunc = -17*j\n+  end function ffunc\n+end module c_funloc_tests_3\n+program main\n+  use iso_c_binding, only: c_funptr, c_funloc\n+  use c_funloc_tests_3, only: ffunc\n+  implicit none\n+  interface\n+    function returnFunc() bind(c,name=\"returnFunc\")\n+       use iso_c_binding, only: c_funptr\n+       type(c_funptr) :: returnFunc\n+    end function returnFunc\n+    subroutine callFunc(func,pass,compare) bind(c,name=\"callFunc\")\n+       use iso_c_binding, only: c_funptr, c_int\n+       type(c_funptr), value :: func\n+       integer(c_int), value :: pass,compare\n+    end subroutine callFunc\n+  end interface\n+  type(c_funptr) :: p\n+  p = returnFunc()\n+  call callFunc(p, 13,3*13)\n+  p = c_funloc(ffunc)\n+  call callFunc(p, 21,-17*21)\n+end program main\n+! { dg-final { cleanup-modules \"c_funloc_tests_3\" } }"}, {"sha": "994da0a505d15e53acb63c1907279b44f2c70937", "filename": "gcc/testsuite/gfortran.dg/c_funloc_tests_3_funcs.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_3_funcs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_3_funcs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_funloc_tests_3_funcs.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,25 @@\n+/* These functions support the test case c_funloc_tests_3.  */\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+int printIntC(int i)\n+{\n+  return 3*i;\n+}\n+\n+int (*returnFunc(void))(int)\n+{\n+  return &printIntC;\n+}\n+\n+void callFunc(int(*func)(int), int pass, int compare)\n+{\n+  int result = (*func)(pass);\n+  if(result != compare)\n+    {\n+       printf(\"FAILED: Got %d, expected %d\\n\", result, compare);\n+       abort();\n+    }\n+  else\n+    printf(\"SUCCESS: Got %d, expected %d\\n\", result, compare);\n+}"}, {"sha": "a7e577a9e17323cc971f419b6743d1543e481666", "filename": "gcc/testsuite/gfortran.dg/c_kind_params.f90", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_kind_params.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_kind_params.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_kind_params.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,76 @@\n+! { dg-do run }\n+! { dg-additional-sources c_kinds.c }\n+! { dg-options \"-w -std=c99\" }\n+! the -w option is needed to make f951 not report a warning for \n+! the -std=c99 option that the C file needs.\n+!\n+! Note: int_fast*_t currently not supported, cf. PR 448.\n+module c_kind_params\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+contains\n+  subroutine param_test(my_short, my_int, my_long, my_long_long, &\n+       my_int8_t, my_int_least8_t, my_int16_t, &\n+       my_int_least16_t, my_int32_t, my_int_least32_t, &\n+       my_int64_t, my_int_least64_t, &\n+       my_intmax_t, my_intptr_t, my_float, my_double, my_long_double, &\n+       my_char, my_bool) bind(c)\n+    integer(c_short), value :: my_short\n+    integer(c_int), value :: my_int\n+    integer(c_long), value :: my_long\n+    integer(c_long_long), value :: my_long_long\n+    integer(c_int8_t), value :: my_int8_t\n+    integer(c_int_least8_t), value :: my_int_least8_t\n+!   integer(c_int_fast8_t), value :: my_int_fast8_t\n+    integer(c_int16_t), value :: my_int16_t\n+    integer(c_int_least16_t), value :: my_int_least16_t\n+!   integer(c_int_fast16_t), value :: my_int_fast16_t\n+    integer(c_int32_t), value :: my_int32_t\n+    integer(c_int_least32_t), value :: my_int_least32_t\n+!   integer(c_int_fast32_t), value :: my_int_fast32_t\n+    integer(c_int64_t), value :: my_int64_t\n+    integer(c_int_least64_t), value :: my_int_least64_t\n+!   integer(c_int_fast64_t), value :: my_int_fast64_t\n+    integer(c_intmax_t), value :: my_intmax_t\n+    integer(c_intptr_t), value :: my_intptr_t\n+    real(c_float), value :: my_float\n+    real(c_double), value :: my_double\n+    real(c_long_double), value :: my_long_double\n+    character(c_char), value :: my_char\n+    logical(c_bool), value :: my_bool\n+\n+    if(my_short     /= 1_c_short)     call abort()\n+    if(my_int       /= 2_c_int)       call abort()\n+    if(my_long      /= 3_c_long)      call abort()\n+    if(my_long_long /= 4_c_long_long) call abort()\n+\n+    if(my_int8_t      /= 1_c_int8_t)        call abort()\n+    if(my_int_least8_t  /= 2_c_int_least8_t ) call abort()\n+    print *, 'c_int_fast8_t is:        ', c_int_fast8_t\n+\n+    if(my_int16_t     /= 1_c_int16_t)       call abort()\n+    if(my_int_least16_t /= 2_c_int_least16_t) call abort()\n+    print *, 'c_int_fast16_t is:       ', c_int_fast16_t\n+\n+    if(my_int32_t     /= 1_c_int32_t)       call abort()\n+    if(my_int_least32_t /= 2_c_int_least32_t) call abort()\n+    print *, 'c_int_fast32_t is:       ', c_int_fast32_t\n+\n+    if(my_int64_t     /= 1_c_int64_t)       call abort()\n+    if(my_int_least64_t /= 2_c_int_least64_t) call abort()\n+    print *, 'c_int_fast64_t is:       ', c_int_fast64_t\n+\n+    if(my_intmax_t /= 1_c_intmax_t) call abort()\n+    if(my_intptr_t /= 0_c_intptr_t) call abort()\n+\n+    if(my_float       /= 1.0_c_float) call abort()\n+    if(my_double      /= 2.0_c_double) call abort()\n+    if(my_long_double /= 3.0_c_long_double) call abort()\n+\n+    if(my_char        /= c_char_'y') call abort()\n+    if(my_bool      .neqv. .true._c_bool) call abort()\n+  end subroutine param_test\n+    \n+end module c_kind_params\n+! { dg-final { cleanup-modules \"c_kind_params\" } }"}, {"sha": "dcac65dec43b28e1de048f45dbe78325f955c7fb", "filename": "gcc/testsuite/gfortran.dg/c_kind_tests_2.f03", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_kind_tests_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_kind_tests_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_kind_tests_2.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+module c_kind_tests_2\n+  use, intrinsic :: iso_c_binding\n+\n+  integer, parameter :: myF = c_float\n+  real(myF), bind(c) :: myCFloat\n+  integer(myF), bind(c) :: myCInt ! { dg-error \"is for type REAL\" }\n+  integer(c_double), bind(c) :: myCInt2 ! { dg-error \"is for type REAL\" }\n+\n+  integer, parameter :: myI = c_int\n+  real(myI) :: myReal\n+  real(myI), bind(c) :: myCFloat2 ! { dg-error \"is for type INTEGER\" }\n+  real(4), bind(c) :: myFloat ! { dg-warning \"may not be a C interoperable\" }\n+end module c_kind_tests_2"}, {"sha": "f79a70f7532f27663d87068c5651fcb8406fb5f8", "filename": "gcc/testsuite/gfortran.dg/c_kinds.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_kinds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_kinds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_kinds.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99\" } */\n+\n+#include <stdint.h>\n+\n+/* Note: int_fast*_t is currently not supported, cf. PR 448 */\n+void param_test(short int my_short, int my_int, long int my_long,\n+                long long int my_long_long, int8_t my_int8_t,\n+                int_least8_t my_int_least8_t, /*int_fast8_t my_int_fast8_t,*/\n+                int16_t my_int16_t, int_least16_t my_int_least16_t,\n+                /*int_fast16_t my_int_fast16_t,*/ int32_t my_int32_t,\n+                int_least32_t my_int_least32_t, /*int_fast32_t my_int_fast32_t,*/\n+                int64_t my_int64_t, int_least64_t my_int_least64_t,\n+                /*int_fast64_t my_int_fast64_t,*/ intmax_t my_intmax_t,\n+                intptr_t my_intptr_t, float my_float, double my_double,\n+                long double my_long_double, char my_char, _Bool my_bool);\n+   \n+\n+int main(int argc, char **argv)\n+{\n+   short int my_short = 1;\n+   int my_int = 2;\n+   long int my_long = 3;\n+   long long int my_long_long = 4;\n+   int8_t my_int8_t = 1;\n+   int_least8_t my_int_least8_t = 2;\n+   int_fast8_t my_int_fast8_t = 3;\n+   int16_t my_int16_t = 1;\n+   int_least16_t my_int_least16_t = 2;\n+   int_fast16_t my_int_fast16_t = 3;\n+   int32_t my_int32_t = 1;\n+   int_least32_t my_int_least32_t = 2;\n+   int_fast32_t my_int_fast32_t = 3;\n+   int64_t my_int64_t = 1;\n+   int_least64_t my_int_least64_t = 2;\n+   int_fast64_t my_int_fast64_t = 3;\n+   intmax_t my_intmax_t = 1;\n+   intptr_t my_intptr_t = 0;  \n+   float my_float = 1.0;\n+   double my_double = 2.0;\n+   long double my_long_double = 3.0;\n+   char my_char = 'y';\n+   _Bool my_bool = 1;\n+\n+   param_test(my_short, my_int, my_long, my_long_long, my_int8_t,\n+              my_int_least8_t, /*my_int_fast8_t,  */ my_int16_t,\n+              my_int_least16_t,/* my_int_fast16_t,*/ my_int32_t,\n+              my_int_least32_t,/* my_int_fast32_t,*/ my_int64_t,\n+              my_int_least64_t,/* my_int_fast64_t,*/ my_intmax_t,\n+              my_intptr_t, my_float, my_double, my_long_double, my_char,\n+              my_bool);\n+\n+   return 0;\n+}/* end main() */"}, {"sha": "9e010439600280c2a874e7f76b180b762f8ea0f3", "filename": "gcc/testsuite/gfortran.dg/c_loc_driver.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,17 @@\n+/* in fortran module */\n+void test0(void);\n+\n+extern void abort(void);\n+\n+int main(int argc, char **argv)\n+{\n+   test0();\n+   return 0;\n+}/* end main() */\n+\n+void test_address(void *c_ptr, int expected_value)\n+{\n+   if((*(int *)(c_ptr)) != expected_value)\n+      abort();\n+   return;\n+}/* end test_address() */"}, {"sha": "178a5164cef4e0ec3f2b3d647ee000ef13b727b4", "filename": "gcc/testsuite/gfortran.dg/c_loc_test.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+! { dg-additional-sources c_loc_driver.c }\n+module c_loc_test\n+implicit none\n+\n+contains\n+  subroutine test0() bind(c)\n+    use, intrinsic :: iso_c_binding\n+    implicit none\n+    integer, target :: x\n+    type(c_ptr) :: my_c_ptr\n+    interface\n+       subroutine test_address(x, expected_value) bind(c)\n+         use, intrinsic :: iso_c_binding\n+         type(c_ptr), value :: x\n+         integer(c_int), value :: expected_value\n+       end subroutine test_address\n+    end interface\n+    x = 100\n+    my_c_ptr = c_loc(x)\n+    call test_address(my_c_ptr, 100)\n+  end subroutine test0\n+end module c_loc_test\n+! { dg-final { cleanup-modules \"c_loc_test.mod\" } }"}, {"sha": "ae4449574fed92b58989e072c6fdde3b5b6ff196", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_2.f03", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_2.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,88 @@\n+! { dg-do run }\n+! { dg-additional-sources c_loc_tests_2_funcs.c }\n+module c_loc_tests_2\n+use, intrinsic :: iso_c_binding\n+implicit none\n+\n+interface \n+   function test_scalar_address(cptr) bind(c)\n+     use, intrinsic :: iso_c_binding, only: c_ptr, c_int\n+     type(c_ptr), value :: cptr\n+     integer(c_int) :: test_scalar_address\n+   end function test_scalar_address\n+\n+   function test_array_address(cptr, num_elements) bind(c)\n+     use, intrinsic :: iso_c_binding, only: c_ptr, c_int\n+     type(c_ptr), value :: cptr\n+     integer(c_int), value :: num_elements\n+     integer(c_int) :: test_array_address\n+   end function test_array_address\n+\n+   function test_type_address(cptr) bind(c)\n+     use, intrinsic :: iso_c_binding, only: c_ptr, c_int\n+     type(c_ptr), value :: cptr\n+     integer(c_int) :: test_type_address\n+   end function test_type_address\n+end interface\n+\n+contains\n+  subroutine test0() bind(c)\n+    integer, target :: xtar\n+    integer, pointer :: xptr\n+    type(c_ptr) :: my_c_ptr_1 = c_null_ptr\n+    type(c_ptr) :: my_c_ptr_2 = c_null_ptr\n+    xtar = 100\n+    xptr => xtar\n+    my_c_ptr_1 = c_loc(xtar)\n+    my_c_ptr_2 = c_loc(xptr)\n+    if(test_scalar_address(my_c_ptr_1) .ne. 1) then\n+       call abort()\n+    end if\n+    if(test_scalar_address(my_c_ptr_2) .ne. 1) then\n+       call abort()\n+    end if\n+  end subroutine test0\n+\n+  subroutine test1() bind(c)\n+    integer, target, dimension(100) :: int_array_tar\n+    type(c_ptr) :: my_c_ptr_1 = c_null_ptr\n+    type(c_ptr) :: my_c_ptr_2 = c_null_ptr\n+    \n+    int_array_tar = 100\n+    my_c_ptr_1 = c_loc(int_array_tar)\n+    if(test_array_address(my_c_ptr_1, 100) .ne. 1) then\n+       call abort()\n+    end if\n+  end subroutine test1\n+\n+  subroutine test2() bind(c)\n+    type, bind(c) f90type\n+       integer(c_int) :: i\n+       real(c_double) :: x\n+    end type f90type\n+    type(f90type), target :: type_tar\n+    type(f90type), pointer :: type_ptr\n+    type(c_ptr) :: my_c_ptr_1 = c_null_ptr\n+    type(c_ptr) :: my_c_ptr_2 = c_null_ptr\n+    \n+    type_ptr => type_tar\n+    type_tar%i = 100\n+    type_tar%x = 1.0d0\n+    my_c_ptr_1 = c_loc(type_tar)\n+    my_c_ptr_2 = c_loc(type_ptr)\n+    if(test_type_address(my_c_ptr_1) .ne. 1) then\n+       call abort()\n+    end if\n+    if(test_type_address(my_c_ptr_2) .ne. 1) then\n+       call abort()\n+    end if\n+  end subroutine test2\n+end module c_loc_tests_2\n+\n+program driver\n+  use c_loc_tests_2\n+  call test0()\n+  call test1()\n+  call test2()\n+end program driver\n+! { dg-final { cleanup-modules \"c_loc_tests_2\" } }"}, {"sha": "d47ac81aeaa7a31e2230e6f5d695e9a3186b11a2", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_2_funcs.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_2_funcs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_2_funcs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_2_funcs.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,42 @@\n+double fabs (double);\n+\n+typedef struct ctype\n+{\n+  int i;\n+  double x;\n+}ctype_t;\n+\n+int test_scalar_address(int *ptr)\n+{\n+  /* The value in Fortran should be initialized to 100. */\n+  if(*ptr != 100)\n+    return 0;\n+  else\n+    return 1;\n+}\n+\n+int test_array_address(int *int_array, int num_elements)\n+{\n+  int i = 0;\n+\n+  for(i = 0; i < num_elements; i++)\n+    /* Fortran will init all of the elements to 100; verify that here. */\n+    if(int_array[i] != 100)\n+      return 0;\n+\n+  /* all elements were equal to 100 */\n+  return 1;\n+}\n+\n+int test_type_address(ctype_t *type_ptr)\n+{\n+  /* i was set to 100 by Fortran */\n+  if(type_ptr->i != 100)\n+    return 0;\n+  \n+  /* x was set to 1.0d0 by Fortran */\n+  if(fabs(type_ptr->x - 1.0) > 0.00000000)\n+    return 0;\n+  \n+  return 1;\n+}"}, {"sha": "95eac4af380275ef417a310353e76c1ffdeb80d5", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_3.f03", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_3.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,8 @@\n+! { dg-do compile }\n+use iso_c_binding\n+implicit none\n+character(kind=c_char,len=256),target :: arg\n+type(c_ptr),pointer :: c\n+c = c_loc(arg) ! { dg-error \"must have a length of 1\" }\n+\n+end"}, {"sha": "8453ec77272e1afdb957d5b19b3476317ad5f787", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_4.f03", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_4.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+module c_loc_tests_4\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+contains\n+  subroutine sub0() bind(c)\n+    integer(c_int), target, dimension(10) :: my_array\n+    integer(c_int), pointer, dimension(:) :: my_array_ptr\n+    type(c_ptr) :: my_c_ptr\n+\n+    my_array_ptr => my_array\n+    my_c_ptr = c_loc(my_array_ptr) ! { dg-error \"must be an associated scalar POINTER\" }\n+  end subroutine sub0\n+end module c_loc_tests_4"}, {"sha": "a389437ce10926dcec1d6c6ffb6c59a871d2cf2b", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_5.f03", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_5.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+module c_loc_tests_5\n+  use, intrinsic :: iso_c_binding, only: c_char, c_ptr, c_loc, c_int\n+\n+contains\n+  subroutine sub0() bind(c)\n+    type(c_ptr) :: f_ptr, my_c_ptr\n+    character(kind=c_char, len=20), target :: format\n+    integer(c_int), dimension(:), pointer :: int_ptr\n+    integer(c_int), dimension(10), target :: int_array\n+\n+    f_ptr = c_loc(format(1:1))\n+\n+    int_ptr => int_array\n+    my_c_ptr = c_loc(int_ptr(0))\n+\n+  end subroutine sub0\n+end module c_loc_tests_5\n+! { dg-final { cleanup-modules \"c_loc_tests_5\" } }"}, {"sha": "c82a2adbf7889f0a9b4e0b4f1f241452836abd04", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_6.f03", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_6.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! Verifies that the c_loc scalar pointer tests recognize the string of length\n+! one as being allowable for the parameter to c_loc.\n+module x\n+use iso_c_binding\n+contains\n+SUBROUTINE glutInit_f03()\n+  TYPE(C_PTR), DIMENSION(1), TARGET :: argv=C_NULL_PTR\n+  CHARACTER(C_CHAR), DIMENSION(10), TARGET :: empty_string=C_NULL_CHAR\n+  argv(1)=C_LOC(empty_string)\n+END SUBROUTINE\n+end module x\n+! { dg-final { cleanup-modules \"x\" } }  "}, {"sha": "78f5276bdefc2d85a9e6c3df9cb81e2892659369", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_7.f03", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_7.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+module c_loc_tests_7\n+use iso_c_binding\n+contains\n+SUBROUTINE glutInit_f03()\n+  TYPE(C_PTR), DIMENSION(1), TARGET :: argv=C_NULL_PTR\n+  CHARACTER(C_CHAR), DIMENSION(1), TARGET :: empty_string=C_NULL_CHAR\n+  argv(1)=C_LOC(empty_string)\n+END SUBROUTINE\n+end module c_loc_tests_7\n+! { dg-final { cleanup-modules \"c_loc_tests_7\" } }"}, {"sha": "a094d690bdd1c856b6fd89d77256bfe60065bc86", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_8.f03", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_8.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! Verifies that the c_loc scalar pointer tests recognize the string of length\n+! greater than one as not being allowable for the parameter to c_loc.\n+module x\n+use iso_c_binding\n+contains\n+SUBROUTINE glutInit_f03()\n+  TYPE(C_PTR), DIMENSION(1), TARGET :: argv=C_NULL_PTR\n+  character(kind=c_char, len=5), target :: string=\"hello\"\n+  argv(1)=C_LOC(string) ! { dg-error \"must have a length of 1\" }\n+END SUBROUTINE\n+end module x\n+"}, {"sha": "0b7c98be714ad46d088d0a2b99a9d9500786aa58", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests.f03", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+! { dg-additional-sources c_ptr_tests_driver.c }\n+module c_ptr_tests\n+  use, intrinsic :: iso_c_binding\n+\n+  ! TODO::\n+  ! in order to be associated with a C address, \n+  ! the derived type needs to be C interoperable, \n+  ! which requires bind(c) and all fields interoperable.\n+  type, bind(c) :: myType\n+     type(c_ptr) :: myServices\n+     type(c_funptr) :: mySetServices\n+     type(c_ptr) :: myPort\n+  end type myType\n+\n+  type, bind(c) :: f90Services\n+     integer(c_int) :: compId\n+     type(c_ptr) :: globalServices = c_null_ptr\n+  end type f90Services\n+\n+  contains\n+    \n+    subroutine sub0(c_self, services) bind(c)\n+      use, intrinsic :: iso_c_binding\n+      implicit none\n+      type(c_ptr), value :: c_self, services\n+      type(myType), pointer :: self\n+      type(f90Services), pointer :: localServices\n+!      type(c_ptr) :: my_cptr \n+      type(c_ptr), save :: my_cptr = c_null_ptr\n+\n+      call c_f_pointer(c_self, self)\n+      if(.not. associated(self)) then\n+         print *, 'self is not associated'\n+      end if\n+      self%myServices = services\n+\n+      ! c_null_ptr is defined in iso_c_binding\n+      my_cptr = c_null_ptr\n+\n+      ! get access to the local services obj from C\n+      call c_f_pointer(self%myServices, localServices)\n+    end subroutine sub0\n+end module c_ptr_tests"}, {"sha": "d04786c7c74a8af91c23e8f24915ca0e5a5147db", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_10.f03", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_10.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_10.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_10.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,18 @@\n+! { dg-run }\n+! This test case exists because gfortran had an error in converting the \n+! expressions for the derived types from iso_c_binding in some cases.\n+module c_ptr_tests_10\n+  use, intrinsic :: iso_c_binding, only: c_ptr, c_null_ptr\n+\n+contains\n+  subroutine sub0() bind(c)\n+    print *, 'c_null_ptr is: ', c_null_ptr\n+  end subroutine sub0\n+end module c_ptr_tests_10\n+\n+program main\n+  use c_ptr_tests_10\n+  call sub0()\n+end program main\n+\n+! { dg-final { cleanup-modules \"c_ptr_tests_10\" } }"}, {"sha": "437e346912764fe4551a75542a95fab7aadd28f8", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_5.f03", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_5.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+module c_ptr_tests_5\n+use, intrinsic :: iso_c_binding\n+\n+type, bind(c) :: my_f90_type\n+   integer(c_int) :: i\n+end type my_f90_type\n+\n+contains\n+  subroutine sub0(c_struct) bind(c)\n+    type(c_ptr), value :: c_struct\n+    type(my_f90_type) :: f90_type\n+\n+    call c_f_pointer(c_struct, f90_type) ! { dg-error \"must have the POINTER\" }\n+  end subroutine sub0\n+end module c_ptr_tests_5"}, {"sha": "04cb8b22ab85952a421b1ae3c854a4a9d04ced49", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_7.f03", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_7.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+! { dg-additional-sources c_ptr_tests_7_driver.c }\n+module c_ptr_tests_7\n+  use, intrinsic :: iso_c_binding, only: c_ptr, c_null_ptr\n+\n+contains\n+  function func0() bind(c)\n+    type(c_ptr) :: func0\n+    func0 = c_null_ptr\n+  end function func0\n+end module c_ptr_tests_7\n+! { dg-final { cleanup-modules \"c_ptr_tests_7\" } }"}, {"sha": "7d8b1e328c8fa4adfce567c1b6ad536997ed9b27", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_7_driver.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_7_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_7_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_7_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,14 @@\n+/* This is the driver for c_ptr_test_7.  */\n+extern void abort(void);\n+\n+void *func0();\n+\n+int main(int argc, char **argv)\n+{\n+  /* The Fortran module c_ptr_tests_7 contains function func0, which has\n+     return type of c_ptr, and should set the return value to c_null_ptr.  */\n+  if (func0() != 0)\n+    abort();\n+\n+  return 0;\n+}"}, {"sha": "3b99ee8bb0f40998d439197fbdd098384827e7e3", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_8.f03", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_8.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+! { dg-additional-sources c_ptr_tests_8_funcs.c }\n+program main\n+use iso_c_binding, only: c_ptr\n+implicit none\n+interface\n+  function create() bind(c)\n+    use iso_c_binding, only: c_ptr\n+    type(c_ptr) :: create\n+  end function create\n+  subroutine show(a) bind(c)\n+    import :: c_ptr\n+    type(c_ptr), VALUE :: a\n+  end subroutine show\n+end interface\n+\n+type(c_ptr) :: ptr\n+ptr = create()\n+call show(ptr)\n+end program main"}, {"sha": "2ad01211658cc1463924bdad6a619778236c659f", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_8_funcs.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_8_funcs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_8_funcs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_8_funcs.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,26 @@\n+/* This file provides auxilliary functions for c_ptr_tests_8.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+extern void abort (void);\n+\n+void *create (void)\n+{\n+  int *a;\n+  a = malloc (sizeof (a));\n+  *a = 444;\n+  return a;\n+\n+}\n+\n+void show (int *a)\n+{\n+  if (*a == 444)\n+    printf (\"SUCCESS (%d)\\n\", *a);\n+  else\n+  {\n+    printf (\"FAILED: Expected 444, received %d\\n\", *a);\n+    abort ();\n+  }\n+}"}, {"sha": "db5985908254a447a64a607432e99b3c1b5f9675", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_9.f03", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_9.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+! This test is pretty simple but is here just to make sure that the changes \n+! done to c_ptr and c_funptr (translating them to void *) works in the case \n+! where a component of a type is of type c_ptr or c_funptr.  \n+module c_ptr_tests_9\n+  use, intrinsic :: iso_c_binding, only: c_ptr, c_null_ptr\n+\n+  type myF90Derived\n+     type(c_ptr) :: my_c_ptr\n+  end type myF90Derived\n+\n+contains\n+  subroutine sub0() bind(c)\n+    type(myF90Derived), target :: my_f90_type\n+    type(myF90Derived), pointer :: my_f90_type_ptr\n+\n+    my_f90_type%my_c_ptr = c_null_ptr\n+    print *, 'my_f90_type is: ', my_f90_type\n+    my_f90_type_ptr => my_f90_type\n+    print *, 'my_f90_type_ptr is: ', my_f90_type_ptr\n+  end subroutine sub0\n+end module c_ptr_tests_9\n+\n+\n+program main\n+  use c_ptr_tests_9\n+\n+  call sub0()\n+end program main\n+\n+! { dg-final { cleanup-modules \"c_ptr_tests_9\" } }"}, {"sha": "cd81c7bccec7b09226b9975e72a74fdb187ae01b", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_driver.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,34 @@\n+/* this is the driver for c_ptr_test.f03 */\n+\n+typedef struct services\n+{\n+   int compId;\n+   void *globalServices;\n+}services_t;\n+\n+typedef struct comp\n+{\n+   void *myServices;\n+   void (*setServices)(struct comp *self, services_t *myServices);\n+   void *myPort;\n+}comp_t;\n+\n+/* prototypes for f90 functions */\n+void sub0(comp_t *self, services_t *myServices);\n+\n+int main(int argc, char **argv)\n+{\n+   services_t servicesObj;\n+   comp_t myComp;\n+\n+   servicesObj.compId = 17;\n+   servicesObj.globalServices = 0; /* NULL; */\n+   myComp.myServices = &servicesObj;\n+   myComp.setServices = 0; /* NULL; */\n+   myComp.myPort = 0; /* NULL; */\n+   \n+   sub0(&myComp, &servicesObj);\n+   \n+   return 0;\n+}/* end main() */\n+"}, {"sha": "b2d49917142d59a56f071356a693ded818e61347", "filename": "gcc/testsuite/gfortran.dg/c_size_t_driver.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_size_t_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_size_t_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_size_t_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,12 @@\n+#include <stdlib.h>\n+void sub0(int my_c_size);\n+\n+int main(int argc, char **argv)\n+{\n+  int my_c_size;\n+\n+  my_c_size = (int)sizeof(size_t);\n+  sub0(my_c_size);\n+\n+  return 0;\n+}"}, {"sha": "91d7aa57b0537192e51e296c19e348c2f1800d58", "filename": "gcc/testsuite/gfortran.dg/c_size_t_test.f03", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_size_t_test.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_size_t_test.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_size_t_test.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-additional-sources c_size_t_driver.c }\n+module c_size_t_test\n+  use, intrinsic :: iso_c_binding\n+\n+contains\n+  subroutine sub0(my_c_size) bind(c)\n+    integer(c_int), value :: my_c_size ! value of C's sizeof(size_t)\n+\n+    ! if the value of c_size_t isn't equal to the value of C's sizeof(size_t) \n+    ! we call abort.\n+    if(c_size_t .ne. my_c_size) then\n+       call abort ()\n+    end if\n+  end subroutine sub0\n+end module c_size_t_test"}, {"sha": "0445635c881623858ceba0697bac272794c1a5f6", "filename": "gcc/testsuite/gfortran.dg/com_block_driver.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fcom_block_driver.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fcom_block_driver.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcom_block_driver.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+module myComModule\n+  use, intrinsic :: iso_c_binding\n+\n+  common /COM2/ R2, S2\n+  real(c_double) :: r2\n+  real(c_double) :: s2 \n+  bind(c) :: /COM2/\n+\n+end module myComModule\n+\n+module comBlockTests\n+  use, intrinsic :: iso_c_binding\n+  use myComModule\n+\n+  implicit none\n+\n+  common /COM/ R, S\n+  real(c_double) :: r\n+  real(c_double) :: s \n+  bind(c) :: /COM/\n+\n+  contains\n+\n+  subroutine testTypes()\n+    implicit none\n+  end subroutine testTypes\n+end module comBlockTests\n+\n+program comBlockDriver\n+  use comBlockTests\n+  \n+  call testTypes()\n+end program comBlockDriver"}, {"sha": "abcdccd3fb2538f4aedd3f892b008f872a4b3260", "filename": "gcc/testsuite/gfortran.dg/global_vars_c_init.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_c_init.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_c_init.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_c_init.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! { dg-additional-sources global_vars_c_init_driver.c }\n+module global_vars_c_init\n+  use, intrinsic :: iso_c_binding, only: c_int\n+  implicit none\n+\n+  integer(c_int), bind(c, name='i') :: I\n+\n+contains\n+  subroutine test_globals() bind(c)\n+    ! the value of I is initialized above\n+    if(I .ne. 2) then\n+       call abort()\n+    endif\n+  end subroutine test_globals\n+end module global_vars_c_init\n+\n+"}, {"sha": "b58c2c966614a486ad1ea2e16aedf4fabccc22af", "filename": "gcc/testsuite/gfortran.dg/global_vars_c_init_driver.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_c_init_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_c_init_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_c_init_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,13 @@\n+int i = 2;\n+void test_globals(void);\n+\n+extern void abort(void);\n+\n+int main(int argc, char **argv)\n+{\n+   /* verify that i has been initialized by f90 */\n+   if(i != 2)\n+      abort();\n+   test_globals();\n+   return 0;\n+}/* end main() */"}, {"sha": "2ff3c52fb17e3f1f4e034bcd035a3fd34817d6ed", "filename": "gcc/testsuite/gfortran.dg/global_vars_f90_init.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_f90_init.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_f90_init.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_f90_init.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! { dg-additional-sources global_vars_f90_init_driver.c }\n+module global_vars_f90_init\n+  use, intrinsic :: iso_c_binding, only: c_int\n+  implicit none\n+\n+  integer(c_int), bind(c, name='i') :: I = 2\n+\n+contains\n+  subroutine test_globals() bind(c)\n+    ! the value of I is initialized above\n+    if(I .ne. 2) then\n+       call abort()\n+    endif\n+  end subroutine test_globals\n+end module global_vars_f90_init\n+\n+"}, {"sha": "7869c83f71254d3269404331aac56c38abbc7521", "filename": "gcc/testsuite/gfortran.dg/global_vars_f90_init_driver.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_f90_init_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_f90_init_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_vars_f90_init_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,14 @@\n+/* initialized by fortran */\n+int i;\n+void test_globals(void);\n+\n+extern void abort(void);\n+\n+int main(int argc, char **argv)\n+{\n+   /* verify that i has been initialized by f90 */\n+   if(i != 2)\n+      abort();\n+   test_globals();\n+   return 0;\n+}/* end main() */"}, {"sha": "8163b4a5040735e8896dfecd341932827f8d7819", "filename": "gcc/testsuite/gfortran.dg/interop_params.f03", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Finterop_params.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Finterop_params.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterop_params.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+module interop_params\n+use, intrinsic :: iso_c_binding\n+\n+type my_f90_type\n+   integer :: i\n+   real :: x\n+end type my_f90_type\n+\n+contains\n+  subroutine test_0(my_f90_int) bind(c) ! { dg-warning \"may not be C interoperable\" }\n+    use, intrinsic :: iso_c_binding\n+    integer, value :: my_f90_int \n+  end subroutine test_0\n+\n+  subroutine test_1(my_f90_real) bind(c) ! { dg-error \"is for type INTEGER\" } \n+    real(c_int), value :: my_f90_real \n+  end subroutine test_1\n+\n+  subroutine test_2(my_type) bind(c) ! { dg-error \"is not C interoperable\" }\n+    use, intrinsic :: iso_c_binding\n+    type(my_f90_type) :: my_type \n+  end subroutine test_2\n+end module interop_params"}, {"sha": "40c45a467264ae27df375814575442c6119424f5", "filename": "gcc/testsuite/gfortran.dg/iso_c_binding_only.f03", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_only.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_only.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_only.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+module iso_c_binding_only\n+  use, intrinsic :: iso_c_binding, only: c_null_ptr\n+  ! This should be allowed since the C_PTR that the C_NULL_PTR needs will use\n+  ! a mangled name to prevent collisions.\n+  integer :: c_ptr\n+end module iso_c_binding_only\n+! { dg-final { cleanup-modules \"iso_c_binding_only\" } }  \n+"}, {"sha": "215e487ada478038b3629fbe2ce78515c121a42a", "filename": "gcc/testsuite/gfortran.dg/iso_c_binding_rename_1.f03", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_1.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,83 @@\n+! { dg-do run }\n+! { dg-additional-sources iso_c_binding_rename_1_driver.c }\n+module iso_c_binding_rename_0\n+  use, intrinsic :: iso_c_binding, only: my_c_ptr_0 => c_ptr, &\n+       c_associated\n+end module iso_c_binding_rename_0\n+\n+\n+module iso_c_binding_rename_1\n+  ! rename a couple of the symbols from iso_c_binding.  the compiler \n+  ! needs to be able to recognize the derived types with names different\n+  ! from the one in iso_c_binding because it will look up the derived types\n+  ! to define the args and return values of some of the procedures in \n+  ! iso_c_binding.  this should verify that this functionality works.\n+  use, intrinsic :: iso_c_binding, my_c_int => c_int, my_c_ptr => c_ptr, &\n+       my_c_associated => c_associated, my_c_f_pointer => c_f_pointer\n+\n+contains\n+  subroutine sub0(my_int) bind(c)\n+    integer(my_c_int), value :: my_int\n+    if(my_int .ne. 1) then\n+       call abort()\n+    end if\n+  end subroutine sub0\n+\n+  subroutine sub1(my_ptr) bind(c)\n+    type(my_c_ptr), value :: my_ptr\n+\n+    if(.not. my_c_associated(my_ptr)) then\n+       call abort()\n+    end if\n+  end subroutine sub1\n+\n+  subroutine sub2(my_int, my_long) bind(c)\n+    use, intrinsic :: iso_c_binding, my_c_int_2 => c_int, &\n+         my_c_long_2 => c_long\n+    integer(my_c_int_2), value :: my_int\n+    integer(my_c_long_2), value :: my_long\n+\n+    if(my_int .ne. 1) then\n+       call abort()\n+    end if\n+    if(my_long .ne. 1) then\n+       call abort()\n+    end if\n+  end subroutine sub2\n+\n+  subroutine sub3(cptr1, cptr2) bind(c)\n+    type(my_c_ptr), value :: cptr1\n+    type(my_c_ptr), value :: cptr2\n+    integer(my_c_int), pointer :: my_f90_c_ptr\n+\n+    if(.not. my_c_associated(cptr1)) then\n+       call abort()\n+    end if\n+\n+    if(.not. my_c_associated(cptr1, cptr2)) then\n+       call abort()\n+    end if\n+\n+    call my_c_f_pointer(cptr1, my_f90_c_ptr)\n+  end subroutine sub3\n+\n+  subroutine sub4(cptr1, cptr2) bind(c)\n+    ! rename the my_c_ptr_0 from iso_c_binding_rename_0 just to further test\n+    ! both are actually aliases to c_ptr\n+    use iso_c_binding_rename_0, my_c_ptr_local => my_c_ptr_0, &\n+         my_c_associated_2 => c_associated\n+\n+    implicit none\n+    type(my_c_ptr_local), value :: cptr1\n+    type(my_c_ptr_local), value :: cptr2\n+\n+    if(.not. my_c_associated_2(cptr1)) then\n+       call abort()\n+    end if\n+    \n+    if(.not. my_c_associated_2(cptr2)) then\n+       call abort()\n+    end if\n+  end subroutine sub4\n+end module iso_c_binding_rename_1\n+"}, {"sha": "26c21d912e58051650f1a57cde36ea15b09f69fc", "filename": "gcc/testsuite/gfortran.dg/iso_c_binding_rename_1_driver.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_1_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_1_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_1_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,19 @@\n+void sub0(int);\n+void sub1(int *);\n+void sub2(int, long);\n+void sub3(int *, int *);\n+void sub4(int *, int *);\n+\n+int main(int argc, char **argv)\n+{\n+  int i = 1;\n+  long j = 1;\n+\n+  sub0(i);\n+  sub1(&i);\n+  sub2(i, j);\n+  sub3(&i, &i);\n+  sub4(&i, &i);\n+\n+  return 0;\n+}"}, {"sha": "75797e78f7347f89cd55d5f849383fe4535873de", "filename": "gcc/testsuite/gfortran.dg/iso_c_binding_rename_2.f03", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_2.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+! { dg-additional-sources iso_c_binding_rename_2_driver.c }\n+module mod0\n+  use, intrinsic :: iso_c_binding, only: c_ptr, c_associated\n+end module mod0\n+\n+module mod1\n+  use mod0, my_c_ptr => c_ptr, my_c_associated => c_associated\n+end module mod1\n+\n+module mod2\n+contains\n+  subroutine sub2(my_ptr1) bind(c)\n+    use mod1, my_c_ptr_2 => my_c_ptr, my_c_associated_2 => my_c_associated\n+    implicit none\n+    type(my_c_ptr_2) :: my_ptr1\n+    if( .not. my_c_associated_2(my_ptr1)) then\n+       call abort()\n+    end if\n+  end subroutine sub2\n+\n+  subroutine sub3(my_ptr1) bind(c)\n+    use mod1, my_c_ptr_2 => my_c_ptr\n+    implicit none\n+    type(my_c_ptr_2) :: my_ptr1\n+    if( .not. my_c_associated(my_ptr1)) then\n+       call abort()\n+    end if\n+  end subroutine sub3\n+\n+  subroutine sub4(my_ptr1) bind(c)\n+    use mod1, my_c_associated_3 => my_c_associated\n+    implicit none\n+    type(my_c_ptr) :: my_ptr1\n+    if( .not. my_c_associated_3(my_ptr1)) then\n+       call abort()\n+    end if\n+  end subroutine sub4\n+\n+end module mod2"}, {"sha": "8be704c341b64d9f7c285d6125009e830a19a195", "filename": "gcc/testsuite/gfortran.dg/iso_c_binding_rename_2_driver.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_2_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_2_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_rename_2_driver.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,16 @@\n+void sub2(int **);\n+void sub3(int **);\n+void sub4(int **);\n+\n+int main(int argc, char **argv)\n+{\n+  int i = 1; \n+  int *ptr;\n+\n+  ptr = &i;\n+  sub2(&ptr);\n+  sub3(&ptr);\n+  sub4(&ptr);\n+\n+  return 0;\n+}"}, {"sha": "d740657a262fee2c761bee16f29cbc8db0b03a90", "filename": "gcc/testsuite/gfortran.dg/kind_tests_2.f03", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fkind_tests_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fkind_tests_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fkind_tests_2.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,7 @@\n+! { dg-do compile }\n+module kind_tests_2\n+  use, intrinsic :: iso_c_binding\n+\n+  integer, parameter :: myFKind = c_float\n+  real(myFKind), bind(c) :: myF\n+end module kind_tests_2"}, {"sha": "83cb91e95d6de4c9aa87544b9cf3d4e2bbe1fa43", "filename": "gcc/testsuite/gfortran.dg/kind_tests_3.f03", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fkind_tests_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fkind_tests_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fkind_tests_3.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+module my_kinds\n+  use, intrinsic :: iso_c_binding\n+  integer, parameter :: myFKind = c_float\n+end module my_kinds\n+\n+module my_module\n+  use my_kinds\n+  real(myFKind), bind(c) :: myF  \n+end module my_module"}, {"sha": "45792bda38997a497a882823c246776b6b7d2854", "filename": "gcc/testsuite/gfortran.dg/module_md5_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -10,5 +10,5 @@ program test\n   use foo\n   print *, pi\n end program test\n-! { dg-final { scan-module \"foo\" \"MD5:18a257e13c90e3872b7b9400c2fc6e4b\" } }\n+! { dg-final { scan-module \"foo\" \"MD5:10e58dd12566bfc60412da6f8f8f7a07\" } }\n ! { dg-final { cleanup-modules \"foo\" } }"}, {"sha": "2cc6c8dd317ee62afebfef768b19060fda4a5934", "filename": "gcc/testsuite/gfortran.dg/only_clause_main.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fonly_clause_main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fonly_clause_main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fonly_clause_main.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,12 @@\n+/* this is an f90 function */\n+void testOnly(int *cIntPtr);\n+\n+int main(int argc, char **argv)\n+{\n+   int myCInt;\n+\n+   myCInt = -11;\n+   testOnly(&myCInt);\n+   \n+   return 0;\n+}/* end main() */"}, {"sha": "a66323316b21c5795650bc58d6142128b28708ff", "filename": "gcc/testsuite/gfortran.dg/print_c_kinds.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fprint_c_kinds.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fprint_c_kinds.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprint_c_kinds.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do run }\n+program print_c_kinds\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+  print *, 'c_short is:              ', c_short\n+  print *, 'c_int is:                ', c_int\n+  print *, 'c_long is:               ', c_long\n+  print *, 'c_long_long is:          ', c_long_long\n+  print *\n+  print *, 'c_int8_t is:             ', c_int8_t\n+  print *, 'c_int_least8_t is:       ', c_int_least8_t\n+  print *, 'c_int_fast8_t is:        ', c_int_fast8_t\n+  print *\n+  print *, 'c_int16_t is:            ', c_int16_t\n+  print *, 'c_int_least16_t is:      ', c_int_least16_t\n+  print *, 'c_int_fast16_t is:       ', c_int_fast16_t\n+  print *\n+  print *, 'c_int32_t is:            ', c_int32_t\n+  print *, 'c_int_least32_t is:      ', c_int_least32_t\n+  print *, 'c_int_fast32_t is:       ', c_int_fast32_t\n+  print *\n+  print *, 'c_int64_t is:            ', c_int64_t\n+  print *, 'c_int_least64_t is:      ', c_int_least64_t\n+  print *, 'c_int_fast64_t is:       ', c_int_fast64_t\n+  print *\n+  print *, 'c_intmax_t is:           ', c_intmax_t\n+  print *, 'c_intptr_t is:           ', c_intptr_t\n+  print *\n+  print *, 'c_float is:              ', c_float\n+  print *, 'c_double is:             ', c_double\n+  print *, 'c_long_double is:        ', c_long_double\n+  print *\n+  print *, 'c_char is:               ', c_char\n+end program print_c_kinds"}, {"sha": "ee7b6a8ac632132987a07b2e3e4d673a364869d8", "filename": "gcc/testsuite/gfortran.dg/test_bind_c_parens.f03", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_bind_c_parens.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_bind_c_parens.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_bind_c_parens.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,7 @@\n+! { dg-do compile }\n+module test_bind_c_parens\n+  interface\n+     subroutine sub bind(c) ! { dg-error \"Missing required parentheses\" }\n+     end subroutine sub ! { dg-error \"Expecting END INTERFACE\" }\n+  end interface\n+end module test_bind_c_parens "}, {"sha": "aa6571874aeb528530d24c71da4b4f971d82cb5b", "filename": "gcc/testsuite/gfortran.dg/test_c_assoc.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_c_assoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_c_assoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_c_assoc.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,55 @@\n+/* use 0 for NULL so no need for system header */\n+\n+int test_c_assoc_0(void *my_c_ptr);\n+int test_c_assoc_1(void *my_c_ptr_1, void *my_c_ptr_2);\n+int test_c_assoc_2(void *my_c_ptr_1, void *my_c_ptr_2, int num_ptrs);\n+void verify_assoc(void *my_c_ptr_1, void *my_c_ptr_2);\n+\n+extern void abort(void);\n+\n+int main(int argc, char **argv)\n+{\n+   int i;\n+   int j;\n+   \n+   if(test_c_assoc_0(0) != 0)\n+      abort();\n+\n+   if(test_c_assoc_0(&i) != 1)\n+      abort();\n+\n+   if(test_c_assoc_1(0, 0) != 0)\n+      abort();\n+\n+   if(test_c_assoc_1(0, &i) != 0)\n+      abort();\n+   \n+   if(test_c_assoc_1(&i, &i) != 1)\n+      abort();\n+\n+   if(test_c_assoc_1(&i, 0) != 0)\n+      abort();\n+\n+   if(test_c_assoc_1(&i, &j) != 0)\n+      abort();\n+\n+   /* this should be associated, cause only testing 1 ptr (i) */\n+   if(test_c_assoc_2(&i, 0, 1) != 1)\n+      abort();\n+\n+   /* this should be associated */\n+   if(test_c_assoc_2(&i, &i, 2) != 1)\n+      abort();\n+\n+   /* this should not be associated (i) */\n+   if(test_c_assoc_2(&i, &j, 2) != 0)\n+      abort();\n+\n+   /* this should be associated, cause only testing 1 ptr (i) */\n+   if(test_c_assoc_2(&i, &j, 1) != 1)\n+      abort();\n+\n+   verify_assoc(&i, &i);\n+   \n+   return 0;\n+}/* end main() */"}, {"sha": "df3f643e72d57ced7380005e9f08f49c6d17e4e2", "filename": "gcc/testsuite/gfortran.dg/test_com_block.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_com_block.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_com_block.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_com_block.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+module nonF03ComBlock\n+  common /NONF03COM/ r, s\n+  real :: r\n+  real :: s\n+  \n+  contains\n+    \n+    subroutine hello(myArray)\n+      integer, dimension(:) :: myArray\n+\n+      r = 1.0\n+      s = 2.0\n+    end subroutine hello\n+end module nonF03ComBlock\n+\n+program testComBlock\n+  use nonF03ComBlock\n+  integer, dimension(1:10) :: myArray\n+\n+  call hello(myArray)\n+\n+  ! these are set in the call to hello() above\n+  ! r and s are reals (default size) in com block, set to \n+  ! 1.0 and 2.0, respectively, in hello()\n+  if(r .ne. 1.0) then \n+     call abort()\n+  endif\n+  if(s .ne. 2.0) then\n+     call abort()\n+  endif\n+end program testComBlock"}, {"sha": "ea9a59a35e4cb8ab55a233d2fe94dc0123084af9", "filename": "gcc/testsuite/gfortran.dg/test_common_binding_labels.f03", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do compile }\n+module x\n+  use, intrinsic :: iso_c_binding, only: c_double\n+  implicit none\n+\n+  common /mycom/ r, s ! { dg-error \"does not match\" }\n+  real(c_double) :: r\n+  real(c_double) :: s\n+  bind(c, name=\"my_common_block\") :: /mycom/\n+end module x\n+\n+module y\n+  use, intrinsic :: iso_c_binding, only: c_double, c_int\n+  implicit none\n+  \n+  common /mycom/ r, s\n+  real(c_double) :: r\n+  real(c_double) :: s\n+  bind(c, name=\"my_common_block\") :: /mycom/\n+\n+  common /com2/ i ! { dg-error \"does not match\" }\n+  integer(c_int) :: i\n+  bind(c, name=\"\") /com2/\n+end module y\n+\n+module z\n+  use, intrinsic :: iso_c_binding, only: c_double, c_int\n+  implicit none\n+  \n+  common /mycom/ r, s ! { dg-error \"does not match\" }\n+  real(c_double) :: r\n+  real(c_double) :: s\n+  ! this next line is an error; if a common block is bind(c), the binding label\n+  ! for it must match across all scoping units that declare it.\n+  bind(c, name=\"my_common_block_2\") :: /mycom/ \n+\n+  common /com2/ i ! { dg-error \"does not match\" }\n+  integer(c_int) :: i\n+  bind(c, name=\"mycom2\") /com2/\n+end module z\n+\n+! { dg-final { cleanup-modules \"x y\" } }"}, {"sha": "d14c9b1168f7651fe5a9fbbea6330e1306313387", "filename": "gcc/testsuite/gfortran.dg/test_common_binding_labels_2.f03", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_2.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+module test_common_binding_labels_2\n+  use, intrinsic :: iso_c_binding, only: c_double, c_int\n+  implicit none\n+  \n+  common /mycom/ r, s\n+  real(c_double) :: r\n+  real(c_double) :: s\n+  bind(c, name=\"my_common_block\") :: /mycom/\n+\n+  common /com2/ i \n+  integer(c_int) :: i\n+  bind(c, name=\"\") /com2/\n+end module test_common_binding_labels_2\n+"}, {"sha": "1b4103ef4cc8f8f290caa2cd13859e3d478f9ea2", "filename": "gcc/testsuite/gfortran.dg/test_common_binding_labels_2_main.f03", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_2_main.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_2_main.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_2_main.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+! This file depends on the module test_common_binding_labels_2.  That module\n+! must be compiled first and not be removed until after this test.\n+module test_common_binding_labels_2_main\n+  use, intrinsic :: iso_c_binding, only: c_double, c_int\n+  implicit none\n+  \n+  common /mycom/ r, s ! { dg-error \"does not match\" }\n+  real(c_double) :: r\n+  real(c_double) :: s\n+  ! this next line is an error; if a common block is bind(c), the binding label\n+  ! for it must match across all scoping units that declare it.\n+  bind(c, name=\"my_common_block_2\") :: /mycom/ \n+\n+  common /com2/ i ! { dg-error \"does not match\" }\n+  integer(c_int) :: i\n+  bind(c, name=\"mycom2\") /com2/\n+end module test_common_binding_labels_2_main\n+\n+program main\n+  use test_common_binding_labels_2 ! { dg-error \"does not match\" }\n+  use test_common_binding_labels_2_main\n+end program main\n+\n+! { dg-final { cleanup-modules \"test_common_binding_labels_2_main test_common_binding_labels_2\" } }"}, {"sha": "87d6c6b78f972d7718d231063f2b76288dbb41d7", "filename": "gcc/testsuite/gfortran.dg/test_common_binding_labels_3.f03", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_3.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+module test_common_binding_labels_3\n+  use, intrinsic :: iso_c_binding, only: c_double\n+  implicit none\n+  \n+  common /mycom/ r, s\n+  real(c_double) :: r\n+  real(c_double) :: s\n+  bind(c, name=\"my_common_block\") :: /mycom/\n+end module test_common_binding_labels_3"}, {"sha": "d2c67f65170ccbeb729c6371976f83c867366cbc", "filename": "gcc/testsuite/gfortran.dg/test_common_binding_labels_3_main.f03", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_3_main.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_3_main.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_common_binding_labels_3_main.f03?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+! This file depends on the module test_common_binding_labels_3.  That module\n+! must be compiled first and not be removed until after this test.\n+module test_common_binding_labels_3_main\n+  use, intrinsic :: iso_c_binding, only: c_int\n+  integer(c_int), bind(c, name=\"my_common_block\") :: my_int ! { dg-error \"collides\" }\n+end module test_common_binding_labels_3_main\n+\n+program main\n+  use test_common_binding_labels_3_main\n+  use test_common_binding_labels_3 ! { dg-error \"collides\" }\n+end program main\n+\n+! { dg-final { cleanup-modules \"test_common_binding_labels_3_main test_common_binding_labels_3\" } }"}, {"sha": "7c63e2be1679f337bf5f423a6440803ea6dab044", "filename": "gcc/testsuite/gfortran.dg/test_only_clause.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_only_clause.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_only_clause.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftest_only_clause.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+! { dg-additional-sources only_clause_main.c }\n+module testOnlyClause\n+\n+  contains\n+    subroutine testOnly(cIntPtr) bind(c, name=\"testOnly\")\n+      use, intrinsic :: iso_c_binding, only: c_ptr, c_int, c_f_pointer\n+      implicit none\n+      type(c_ptr), value :: cIntPtr\n+      integer(c_int), pointer :: f90IntPtr\n+      \n+      call c_f_pointer(cIntPtr, f90IntPtr)\n+\n+      ! f90IntPtr coming in has value of -11; this will make it -12\n+      f90IntPtr = f90IntPtr - 1\n+      if(f90IntPtr .ne. -12) then\n+         call abort()\n+      endif\n+    end subroutine testOnly\n+end module testOnlyClause"}, {"sha": "6e6a023bcfba8fd29a3870d15655cde93c2d5db4", "filename": "gcc/testsuite/gfortran.dg/use_iso_c_binding.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_iso_c_binding.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_iso_c_binding.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_iso_c_binding.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do compile }\n+! this is to simply test that the various ways the use statement can \n+! appear are handled by the compiler, since i did a special treatment \n+! of the intrinsic iso_c_binding module.  note: if the user doesn't \n+! provide the 'intrinsic' keyword, the compiler will check for a user \n+! provided module by the name of iso_c_binding before using the \n+! intrinsic one.  --Rickett, 09.26.06\n+module use_stmt_0\n+  ! this is an error because c_ptr_2 does not exist \n+  use, intrinsic :: iso_c_binding, only: c_ptr_2 ! { dg-error \"Symbol 'c_ptr_2' referenced at \\\\(1\\\\) does not exist\" }\n+end module use_stmt_0\n+\n+module use_stmt_1\n+  ! this is an error because c_ptr_2 does not exist \n+  use iso_c_binding, only: c_ptr_2 ! { dg-error \"Symbol 'c_ptr_2' referenced at \\\\(1\\\\) does not exist\" }\n+end module use_stmt_1\n+\n+module use_stmt_2\n+  ! works fine\n+  use, intrinsic :: iso_c_binding, only: c_ptr\n+end module use_stmt_2\n+\n+module use_stmt_3\n+  ! works fine\n+  use iso_c_binding, only: c_ptr\n+end module use_stmt_3\n+\n+module use_stmt_4\n+  ! works fine\n+  use, intrinsic :: iso_c_binding\n+end module use_stmt_4\n+\n+module use_stmt_5\n+  ! works fine\n+  use iso_c_binding\n+end module use_stmt_5\n+\n+module use_stmt_6\n+  ! hmm, is this an error?  if so, it's not being caught...\n+  ! --Rickett, 09.13.06\n+  use, intrinsic :: iso_c_binding, only: c_int, c_int\n+end module use_stmt_6\n+\n+module use_stmt_7\n+  ! hmm, is this an error?  if so, it's not being caught...\n+  ! --Rickett, 09.13.06\n+  use iso_c_binding, only: c_int, c_int\n+end module use_stmt_7\n+"}, {"sha": "4b0dcefb3409aaee312b84a0db8ab291cb7361f3", "filename": "gcc/testsuite/gfortran.dg/value_5.f90", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_5.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,68 @@\n+! { dg-do compile }\n+! Length of character dummy variable with VALUE attribute:\n+! - must be initialization expression or omitted\n+! - C interoperable: must be initialization expression of length one\n+!   or omitted\n+!\n+! Contributed by Tobias Burnus\n+program x\n+  implicit none\n+  character(10) :: c1,c10\n+  c1  = 'H'\n+  c10 = 'Main'\n+  call foo1(c1)\n+  call foo2(c1)\n+  call foo3(c10)\n+  call foo4(c10)\n+  call bar1(c1)\n+  call bar2(c1)\n+  call bar3(c10)\n+  call bar4(c10)\n+\n+contains\n+\n+  subroutine foo1(a)\n+    character :: a\n+    value :: a\n+  end subroutine foo1\n+\n+  subroutine foo2(a)\n+    character(1) :: a\n+    value :: a\n+  end subroutine foo2\n+\n+  subroutine foo3(a)\n+    character(10) :: a\n+    value :: a\n+  end subroutine foo3\n+\n+  subroutine foo4(a) ! { dg-error \"VALUE attribute must have constant length\" }\n+    character(*) :: a\n+    value :: a\n+  end subroutine foo4\n+\n+  subroutine bar1(a)\n+    use iso_c_binding, only: c_char\n+    character(kind=c_char) :: a\n+    value :: a\n+  end subroutine bar1\n+\n+  subroutine bar2(a)\n+    use iso_c_binding, only: c_char\n+    !character(kind=c_char,len=1) :: a\n+    character(1,kind=c_char) :: a\n+    value :: a\n+  end subroutine bar2\n+\n+  subroutine bar3(a) ! { dg-error \"VALUE attribute must have length one\" }\n+    use iso_c_binding, only: c_char\n+    character(kind=c_char,len=10) :: a\n+    value :: a\n+  end subroutine bar3\n+\n+  subroutine bar4(a) ! { dg-error \"VALUE attribute must have constant length\" }\n+    use iso_c_binding, only: c_char\n+    character(kind=c_char,len=*) :: a\n+    value :: a\n+  end subroutine bar4\n+end program x"}, {"sha": "12313324c4de72f965d156a85e39653b7e7e292a", "filename": "gcc/testsuite/gfortran.dg/value_test.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_test.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_test.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_test.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+program valueTests\n+  integer :: myInt\n+  interface\n+     subroutine mySub(myInt)\n+       integer, value :: myInt\n+     end subroutine mySub\n+  end interface\n+\n+  myInt = 10\n+\n+  call mySub(myInt)\n+  ! myInt should be unchanged since pass-by-value\n+  if(myInt .ne. 10) then\n+     call abort ()\n+  endif\n+end program valueTests\n+\n+subroutine mySub(myInt)\n+  integer, value :: myInt\n+  myInt = 11\n+end subroutine mySub\n+  "}, {"sha": "652517361222126b4e2e74ef69cbfe1a399f625a", "filename": "gcc/testsuite/gfortran.dg/value_tests_f03.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_tests_f03.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_tests_f03.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_tests_f03.f90?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do run }\n+program value_tests_f03\n+  use, intrinsic :: iso_c_binding\n+  real(c_double) :: myDouble\n+  interface\n+     subroutine value_test(myDouble) bind(c)\n+       use, intrinsic :: iso_c_binding\n+       real(c_double), value :: myDouble\n+     end subroutine value_test\n+  end interface\n+\n+  myDouble = 9.0d0\n+  call value_test(myDouble)\n+end program value_tests_f03\n+\n+subroutine value_test(myDouble) bind(c)\n+  use, intrinsic :: iso_c_binding\n+  real(c_double), value :: myDouble\n+  interface\n+     subroutine mySub(myDouble)\n+       use, intrinsic :: iso_c_binding\n+       real(c_double), value :: myDouble\n+     end subroutine mySub\n+  end interface\n+\n+  myDouble = 10.0d0\n+\n+  call mySub(myDouble)\n+end subroutine value_test\n+\n+subroutine mySub(myDouble)\n+  use, intrinsic :: iso_c_binding\n+  real(c_double), value :: myDouble\n+  \n+  myDouble = 11.0d0\n+end subroutine mySub\n+  "}, {"sha": "2b880c531d835b67fcf06ae0d1d39f1355abeb93", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -1,3 +1,15 @@\n+2007-07-01  Christopher D. Rickett  <crickett@lanl.gov>\n+\n+\t* Makefile.in: Add support for iso_c_generated_procs.c and\n+\tiso_c_binding.c.\n+\t* Makefile.am: Ditto.\n+\t* intrinsics/iso_c_generated_procs.c: New file containing helper\n+\tfunctions.\n+\t* intrinsics/iso_c_binding.c: Ditto.\n+\t* intrinsics/iso_c_binding.h: New file\n+\t* gfortran.map: Include the __iso_c_binding_c_* functions.\n+\t* libgfortran.h: define GFC_NUM_RANK_BITS.\n+\n 2007-07-01  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/32239"}, {"sha": "ba81c75f2382c1cc152906afd7e0adfd2828f679", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -71,9 +71,11 @@ intrinsics/getcwd.c \\\n intrinsics/getlog.c \\\n intrinsics/getXid.c \\\n intrinsics/hostnm.c \\\n-intrinsics/kill.c \\\n intrinsics/ierrno.c \\\n intrinsics/ishftc.c \\\n+intrinsics/iso_c_generated_procs.c \\\n+intrinsics/iso_c_binding.c \\\n+intrinsics/kill.c \\\n intrinsics/link.c \\\n intrinsics/malloc.c \\\n intrinsics/mvbits.c \\"}, {"sha": "5d97b903ddcde9709bed1ca19ace1f6fa281a901", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -194,7 +194,8 @@ am__objects_32 = associated.lo abort.lo access.lo args.lo \\\n \treshape_generic.lo reshape_packed.lo selected_int_kind.lo \\\n \tselected_real_kind.lo stat.lo symlnk.lo system_clock.lo \\\n \ttime.lo transpose_generic.lo umask.lo unlink.lo \\\n-\tunpack_generic.lo in_pack_generic.lo in_unpack_generic.lo\n+\tunpack_generic.lo in_pack_generic.lo in_unpack_generic.lo \\\n+\tiso_c_generated_procs.lo iso_c_binding.lo\n am__objects_33 =\n am__objects_34 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n@@ -456,9 +457,11 @@ intrinsics/getcwd.c \\\n intrinsics/getlog.c \\\n intrinsics/getXid.c \\\n intrinsics/hostnm.c \\\n-intrinsics/kill.c \\\n intrinsics/ierrno.c \\\n intrinsics/ishftc.c \\\n+intrinsics/iso_c_generated_procs.c \\\n+intrinsics/iso_c_binding.c \\\n+intrinsics/kill.c \\\n intrinsics/link.c \\\n intrinsics/malloc.c \\\n intrinsics/mvbits.c \\\n@@ -4295,6 +4298,15 @@ ishftc.lo: intrinsics/ishftc.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ishftc.lo `test -f 'intrinsics/ishftc.c' || echo '$(srcdir)/'`intrinsics/ishftc.c\n \n+iso_c_generated_procs.lo: intrinsics/iso_c_generated_procs.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iso_c_generated_procs.lo `test -f 'intrinsics/iso_c_generated_procs.c' || echo '$(srcdir)/'`intrinsics/iso_c_generated_procs.c\n+\n+iso_c_binding.lo: intrinsics/iso_c_binding.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iso_c_binding.lo `test -f 'intrinsics/iso_c_binding.c' || echo '$(srcdir)/'`intrinsics/iso_c_binding.c\n+\n+kill.lo: intrinsics/kill.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o kill.lo `test -f 'intrinsics/kill.c' || echo '$(srcdir)/'`intrinsics/kill.c\n+\n link.lo: intrinsics/link.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT link.lo -MD -MP -MF \"$(DEPDIR)/link.Tpo\" -c -o link.lo `test -f 'intrinsics/link.c' || echo '$(srcdir)/'`intrinsics/link.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/link.Tpo\" \"$(DEPDIR)/link.Plo\"; else rm -f \"$(DEPDIR)/link.Tpo\"; exit 1; fi"}, {"sha": "71c809a11f5edc8e14bb4202cd4f9b3ae0be0784", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -1003,6 +1003,23 @@ GFORTRAN_1.0 {\n     _gfortran_unpack0_char;\n     _gfortran_unpack1;\n     _gfortran_unpack1_char;\n+    __iso_c_binding_c_associated_1;\n+    __iso_c_binding_c_associated_2;\n+    __iso_c_binding_c_f_pointer;\n+    __iso_c_binding_c_f_pointer_d0;\n+    __iso_c_binding_c_f_pointer_i1;\n+    __iso_c_binding_c_f_pointer_i2;\n+    __iso_c_binding_c_f_pointer_i4;\n+    __iso_c_binding_c_f_pointer_i8;\n+    __iso_c_binding_c_f_pointer_i16;\n+    __iso_c_binding_c_f_pointer_r4;\n+    __iso_c_binding_c_f_pointer_r8;\n+    __iso_c_binding_c_f_pointer_r10;\n+    __iso_c_binding_c_f_pointer_r16;\n+    __iso_c_binding_c_f_pointer_u0;\n+    __iso_c_binding_c_f_procpointer;\n+    __iso_c_binding_c_funloc;\n+    __iso_c_binding_c_loc;\n   local:\n     *;\n };"}, {"sha": "33575475aa61d956e81cdb8a2394de4142aa63ed", "filename": "libgfortran/intrinsics/iso_c_binding.c", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Fintrinsics%2Fiso_c_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Fintrinsics%2Fiso_c_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fiso_c_binding.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,249 @@\n+/* Implementation of the ISO_C_BINDING library helper functions.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Christopher Rickett.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+\n+/* Implement the functions and subroutines provided by the intrinsic\n+   iso_c_binding module.  */\n+\n+#include <stdlib.h>\n+\n+#include \"libgfortran.h\"\n+#include \"iso_c_binding.h\"\n+\n+\n+/* Set the fields of a Fortran pointer descriptor to point to the\n+   given C address.  It uses c_f_pointer_u0 for the common\n+   fields, and will set up the information necessary if this C address\n+   is to an array (i.e., offset, type, element size).  The parameter\n+   c_ptr_in represents the C address to have Fortran point to.  The\n+   parameter f_ptr_out is the Fortran pointer to associate with the C\n+   address.  The parameter shape is a one-dimensional array of integers\n+   specifying the upper bound(s) of the array pointed to by the given C\n+   address, if applicable.  The shape parameter is optional in Fortran,\n+   which will cause it to come in here as NULL.  The parameter type is\n+   the type of the data being pointed to (i.e.,libgfortran.h). The\n+   elem_size parameter is the size, in bytes, of the data element being\n+   pointed to.  If the address is for an array, then the size needs to\n+   be the size of a single element (i.e., for an array of doubles, it\n+   needs to be the number of bytes for the size of one double).  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer) (void *c_ptr_in,\n+                                    gfc_array_void *f_ptr_out,\n+                                    const array_t *shape,\n+                                    int type, int elemSize)\n+{\n+  if (shape != NULL)\n+    {\n+      f_ptr_out->offset = 0;\n+\n+      /* Set the necessary dtype field for all pointers.  */\n+      f_ptr_out->dtype = 0;\n+\n+      /* Put in the element size.  */\n+      f_ptr_out->dtype = f_ptr_out->dtype | (elemSize << GFC_DTYPE_SIZE_SHIFT);\n+\n+      /* Set the data type (e.g., GFC_DTYPE_INTEGER).  */\n+      f_ptr_out->dtype = f_ptr_out->dtype | (type << GFC_DTYPE_TYPE_SHIFT);\n+    }\n+  \n+  /* Use the generic version of c_f_pointer to set common fields.  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer_u0) (c_ptr_in, f_ptr_out, shape);\n+}\n+\n+\n+/* A generic function to set the common fields of all descriptors, no\n+   matter whether it's to a scalar or an array.  Fields set are: data,\n+   and if appropriate, rank, offset, dim[*].lbound, dim[*].ubound, and\n+   dim[*].stride.  Parameter shape is a rank 1 array of integers\n+   containing the upper bound of each dimension of what f_ptr_out\n+   points to.  The length of this array must be EXACTLY the rank of\n+   what f_ptr_out points to, as required by the draft (J3/04-007).  If\n+   f_ptr_out points to a scalar, then this parameter will be NULL.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_u0) (void *c_ptr_in,\n+                                       gfc_array_void *f_ptr_out,\n+                                       const array_t *shape)\n+{\n+  int i = 0;\n+  int shapeSize = 0;\n+\n+  GFC_DESCRIPTOR_DATA (f_ptr_out) = c_ptr_in;\n+\n+  if (shape != NULL)\n+    {\n+      f_ptr_out->offset = 0;\n+      shapeSize = 0;\n+      \n+      /* shape's length (rank of the output array) */\n+      shapeSize = shape->dim[0].ubound + 1 - shape->dim[0].lbound;\n+      for (i = 0; i < shapeSize; i++)\n+        {\n+          /* Lower bound is 1, as specified by the draft.  */\n+          f_ptr_out->dim[i].lbound = 1;\n+          f_ptr_out->dim[i].ubound = ((int *) (shape->data))[i];\n+        }\n+\n+      /* Set the offset and strides.\n+         offset is (sum of (dim[i].lbound * dim[i].stride) for all\n+         dims) the -1 means we'll back the data pointer up that much\n+         perhaps we could just realign the data pointer and not change\n+         the offset?  */\n+      f_ptr_out->dim[0].stride = 1;\n+      f_ptr_out->offset = f_ptr_out->dim[0].lbound * f_ptr_out->dim[0].stride;\n+      for (i = 1; i < shapeSize; i++)\n+        {\n+          f_ptr_out->dim[i].stride = (f_ptr_out->dim[i-1].ubound + 1)\n+            - f_ptr_out->dim[i-1].lbound;\n+          f_ptr_out->offset += f_ptr_out->dim[i].lbound\n+            * f_ptr_out->dim[i].stride;\n+        }\n+\n+      f_ptr_out->offset *= -1;\n+\n+      /* All we know is the rank, so set it, leaving the rest alone.\n+         Make NO assumptions about the state of dtype coming in!  If we\n+         shift right by TYPE_SHIFT bits we'll throw away the existing\n+         rank.  Then, shift left by the same number to shift in zeros\n+         and or with the new rank.  */\n+      f_ptr_out->dtype = ((f_ptr_out->dtype >> GFC_DTYPE_TYPE_SHIFT)\n+                           << GFC_DTYPE_TYPE_SHIFT) | shapeSize;\n+    }\n+}\n+\n+\n+/* Sets the descriptor fields for a Fortran pointer to a derived type,\n+   using c_f_pointer_u0 for the majority of the work.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_d0) (void *c_ptr_in,\n+                                       gfc_array_void *f_ptr_out,\n+                                       const array_t *shape)\n+{\n+  /* Set the common fields.  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer_u0) (c_ptr_in, f_ptr_out, shape);\n+\n+  /* Preserve the size and rank bits, but reset the type.  */\n+  if (shape != NULL)\n+    {\n+      f_ptr_out->dtype = f_ptr_out->dtype & (~GFC_DTYPE_TYPE_MASK);\n+      f_ptr_out->dtype = f_ptr_out->dtype\n+\t\t\t | (GFC_DTYPE_DERIVED << GFC_DTYPE_TYPE_SHIFT);\n+    }\n+}\n+\n+\n+/* This function will change, once there is an actual f90 type for the\n+   procedure pointer.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_procpointer) (void *c_ptr_in,\n+                                        gfc_array_void *f_ptr_out)\n+{\n+  GFC_DESCRIPTOR_DATA(f_ptr_out) = c_ptr_in;\n+}\n+\n+\n+/* Test if the given c_ptr is associated or not.  This function is\n+   called if the user only supplied one c_ptr parameter to the\n+   c_associated function.  The second argument is optional, and the\n+   Fortran compiler will resolve the function to this version if only\n+   one arg was given.  Associated here simply means whether or not the\n+   c_ptr is NULL or not.  */\n+\n+GFC_LOGICAL_4\n+ISO_C_BINDING_PREFIX (c_associated_1) (void *c_ptr_in_1)\n+{\n+  if (c_ptr_in_1 != NULL)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+\n+/* Test if the two c_ptr arguments are associated with one another.\n+   This version of the c_associated function is called if the user\n+   supplied two c_ptr args in the Fortran source.  According to the\n+   draft standard (J3/04-007), if c_ptr_in_1 is NULL, the two pointers\n+   are NOT associated.  If c_ptr_in_1 is non-NULL and it is not equal\n+   to c_ptr_in_2, then either c_ptr_in_2 is NULL or is associated with\n+   another address; either way, the two pointers are not associated\n+   with each other then.  */\n+\n+GFC_LOGICAL_4\n+ISO_C_BINDING_PREFIX (c_associated_2) (void *c_ptr_in_1, void *c_ptr_in_2)\n+{\n+  /* Since we have the second arg, if it doesn't equal the first,\n+     return false; true otherwise.  However, if the first one is null,\n+     then return false; otherwise compare the two ptrs for equality.  */\n+  if (c_ptr_in_1 == NULL)\n+    return 0;\n+  else if (c_ptr_in_1 != c_ptr_in_2)\n+    return 0;\n+  else\n+    return 1;\n+}\n+\n+\n+/* Return the C address of the given Fortran allocatable object.  */\n+\n+void *\n+ISO_C_BINDING_PREFIX (c_loc) (void *f90_obj)\n+{\n+  if (f90_obj == NULL)\n+    {\n+      runtime_error (\"C_LOC: Attempt to get C address for Fortran object\"\n+                     \" that has not been allocated or associated\");\n+      abort ();\n+    }\n+   \n+  /* The \"C\" address should be the address of the object in Fortran.  */\n+  return f90_obj;\n+}\n+\n+\n+/*  Return the C address of the given Fortran procedure.  This\n+    routine is expected to return a derived type of type C_FUNPTR,\n+    which represents the C address of the given Fortran object.  */\n+\n+void *\n+ISO_C_BINDING_PREFIX (c_funloc) (void *f90_obj)\n+{\n+  if (f90_obj == NULL)\n+    {\n+      runtime_error (\"C_LOC: Attempt to get C address for Fortran object\"\n+                     \" that has not been allocated or associated\");\n+      abort ();\n+    }\n+\n+  /* The \"C\" address should be the address of the object in Fortran.  */\n+  return f90_obj;\n+}"}, {"sha": "afd85529e9df052d28a8b47e2628e5b0baed0c8c", "filename": "libgfortran/intrinsics/iso_c_binding.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Fintrinsics%2Fiso_c_binding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Fintrinsics%2Fiso_c_binding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fiso_c_binding.h?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,70 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Christopher Rickett.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with Libgfortran; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+\n+/* Declarations for ISO_C_BINDING library helper functions.  */\n+\n+#ifndef GFOR_ISO_C_BINDING_H\n+#define GFOR_ISO_C_BINDING_H\n+\n+#include \"libgfortran.h\"\n+\n+typedef struct c_ptr\n+{\n+  void *c_address;\n+}\n+c_ptr_t;\n+\n+typedef struct c_funptr\n+{\n+  void *c_address;\n+}\n+c_funptr_t;\n+\n+#define ISO_C_BINDING_PREFIX(a) __iso_c_binding_##a\n+\n+void ISO_C_BINDING_PREFIX(c_f_pointer)(void *, gfc_array_void *,\n+\t\t\t\t       const array_t *, int, int);\n+\n+/* The second param here may change, once procedure pointers are\n+   implemented.  */\n+void ISO_C_BINDING_PREFIX(c_f_procpointer) (void *, gfc_array_void *);\n+\n+GFC_LOGICAL_4 ISO_C_BINDING_PREFIX(c_associated_1) (void *);\n+GFC_LOGICAL_4 ISO_C_BINDING_PREFIX(c_associated_2) (void *, void *);\n+\n+void ISO_C_BINDING_PREFIX(c_f_pointer_u0) (void *, gfc_array_void *,\n+\t\t\t\t\t   const array_t *);\n+void ISO_C_BINDING_PREFIX(c_f_pointer_d0) (void *, gfc_array_void *,\n+\t\t\t\t\t   const array_t *);\n+\n+void *ISO_C_BINDING_PREFIX(c_loc) (void *);\n+void *ISO_C_BINDING_PREFIX(c_funloc) (void *);\n+\n+#endif"}, {"sha": "f60b264dba6e0d610b1603f4a75e4b3ab30b7915", "filename": "libgfortran/intrinsics/iso_c_generated_procs.c", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Fintrinsics%2Fiso_c_generated_procs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Fintrinsics%2Fiso_c_generated_procs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fiso_c_generated_procs.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -0,0 +1,264 @@\n+/* Implementation of the ISO_C_BINDING library helper generated functions.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Christopher Rickett.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+\n+#include \"libgfortran.h\"\n+#include \"iso_c_binding.h\"\n+\n+\n+/* TODO: This file needs to be finished so that a function is provided\n+   for all possible type/kind combinations!  */\n+\n+#ifdef HAVE_GFC_INTEGER_1\n+void ISO_C_BINDING_PREFIX (c_f_pointer_i1) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_INTEGER_2\n+void ISO_C_BINDING_PREFIX (c_f_pointer_i2) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_INTEGER_4\n+void ISO_C_BINDING_PREFIX (c_f_pointer_i4) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_INTEGER_8\n+void ISO_C_BINDING_PREFIX (c_f_pointer_i8) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+void ISO_C_BINDING_PREFIX (c_f_pointer_i16) (void *, gfc_array_void *,\n+\t\t\t\t\t     const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_4\n+void ISO_C_BINDING_PREFIX (c_f_pointer_r4) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_8\n+void ISO_C_BINDING_PREFIX (c_f_pointer_r8) (void *, gfc_array_void *,\n+\t\t\t\t\t    const array_t *);\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_10\n+void ISO_C_BINDING_PREFIX (c_f_pointer_r10) (void *, gfc_array_void *,\n+\t\t\t\t\t     const array_t *);\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+void ISO_C_BINDING_PREFIX (c_f_pointer_r16) (void *, gfc_array_void *,\n+\t\t\t\t\t     const array_t *);\n+#endif\n+\n+\n+#ifdef HAVE_GFC_INTEGER_1\n+/* Set the given Fortran pointer, 'f_ptr_out', to point to the given C\n+   address, 'c_ptr_in'.  The Fortran pointer is of type integer and\n+   kind=1.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  shape is a one-dimensional array of integers\n+   specifying the upper bounds of the array pointed to by the given C\n+   address, if applicable.  'shape' is an optional parameter in\n+   Fortran, so if the user does not provide it, it will come in here\n+   as NULL.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_i1) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have an integer(kind=1).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_INTEGER,\n+\t\t\t\t      (int) sizeof (GFC_INTEGER_1));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_INTEGER_2\n+/* Set the given Fortran pointer, 'f_ptr_out', to point to the given C\n+   address, 'c_ptr_in'.  The Fortran pointer is of type integer and\n+   kind=2.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  shape is a one-dimensional array of integers\n+   specifying the upper bounds of the array pointed to by the given C\n+   address, if applicable.  'shape' is an optional parameter in\n+   Fortran, so if the user does not provide it, it will come in here\n+   as NULL.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_i2) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have an integer(kind=2).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_INTEGER,\n+\t\t\t\t      (int) sizeof (GFC_INTEGER_2));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_INTEGER_4\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type integer and\n+   kind=4.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_i4) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have an integer(kind=4).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_INTEGER,\n+\t\t\t\t      (int) sizeof (GFC_INTEGER_4));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_INTEGER_8\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type integer and\n+   kind=8.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_i8) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have an integer(kind=8).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_INTEGER,\n+\t\t\t\t      (int) sizeof (GFC_INTEGER_8));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+/* Set the given Fortran pointer, 'f_ptr_out', to point to the given C\n+   address, 'c_ptr_in'.  The Fortran pointer is of type integer and\n+   kind=16.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  shape is a one-dimensional array of integers\n+   specifying the upper bounds of the array pointed to by the given C\n+   address, if applicable.  'shape' is an optional parameter in\n+   Fortran, so if the user does not provide it, it will come in here\n+   as NULL.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_i16) (void *c_ptr_in,\n+\t\t\t\t\tgfc_array_void *f_ptr_out,\n+\t\t\t\t\tconst array_t *shape)\n+{\n+  /* Here we have an integer(kind=16).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_INTEGER,\n+\t\t\t\t      (int) sizeof (GFC_INTEGER_16));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_REAL_4\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type real and\n+   kind=4.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_r4) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have an real(kind=4).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_REAL,\n+\t\t\t\t      (int) sizeof (GFC_REAL_4));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_REAL_8\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type real and\n+   kind=8.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_r8) (void *c_ptr_in,\n+\t\t\t\t       gfc_array_void *f_ptr_out,\n+\t\t\t\t       const array_t *shape)\n+{\n+  /* Here we have an real(kind=8).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_REAL,\n+\t\t\t\t      (int) sizeof (GFC_REAL_8));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_REAL_10\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type real and\n+   kind=10.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_r10) (void *c_ptr_in,\n+\t\t\t\t\tgfc_array_void *f_ptr_out,\n+\t\t\t\t\tconst array_t *shape)\n+{\n+  /* Here we have an real(kind=10).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_REAL,\n+\t\t\t\t      (int) sizeof (GFC_REAL_10));\n+}\n+#endif\n+\n+\n+#ifdef HAVE_GFC_REAL_16\n+/* Set the given Fortran pointer, f_ptr_out, to point to the given C\n+   address, c_ptr_in.  The Fortran pointer is of type real and\n+   kind=16.  The function c_f_pointer is used to set up the pointer\n+   descriptor.  */\n+\n+void\n+ISO_C_BINDING_PREFIX (c_f_pointer_r16) (void *c_ptr_in,\n+\t\t\t\t\tgfc_array_void *f_ptr_out,\n+\t\t\t\t\tconst array_t *shape)\n+{\n+  /* Here we have an real(kind=16).  */\n+  ISO_C_BINDING_PREFIX (c_f_pointer) (c_ptr_in, f_ptr_out, shape,\n+\t\t\t\t      (int) GFC_DTYPE_REAL,\n+\t\t\t\t      (int) sizeof (GFC_REAL_16));\n+}\n+#endif"}, {"sha": "9297af0852138650755542c828e43f96fdf65e58", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -690,26 +690,11 @@ update_position (gfc_unit *u)\n    must free memory allocated for the filename string.  */\n \n char *\n-filename_from_unit (int n)\n+filename_from_unit (int unit_number)\n {\n   char *filename;\n-  gfc_unit *u;\n-  int c;\n-\n-  /* Find the unit.  */\n-  u = unit_root;\n-  while (u != NULL)\n-    {\n-      c = compare (n, u->unit_number);\n-      if (c < 0)\n-\tu = u->left;\n-      if (c > 0)\n-\tu = u->right;\n-      if (c == 0)\n-\tbreak;\n-    }\n-\n-  /* Get the filename.  */\n+  gfc_unit *u = NULL;\n+  u = find_unit (unit_number);\n   if (u != NULL)\n     {\n       filename = (char *) get_mem (u->file_len + 1);\n@@ -718,5 +703,4 @@ filename_from_unit (int n)\n     }\n   else\n     return (char *) NULL;\n-}\n-\n+}\n\\ No newline at end of file"}, {"sha": "f73594dc4d7558e75958725aa6e9a99e415aa751", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b3b0b633eb1f33d41c8f49a77641d4f767cd01/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=a8b3b0b633eb1f33d41c8f49a77641d4f767cd01", "patch": "@@ -321,6 +321,9 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_16) gfc_array_l16;\n #define GFC_DTYPE_TYPE_MASK 0x38\n #define GFC_DTYPE_SIZE_SHIFT 6\n \n+/* added for f03.  --Rickett, 02.28.06 */\n+#define GFC_NUM_RANK_BITS 3\n+\n enum\n {\n   GFC_DTYPE_UNKNOWN = 0,"}]}