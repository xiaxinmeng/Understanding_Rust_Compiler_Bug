{"sha": "be677dc12a6e687d24d375089ae2025fcfad4c9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU2NzdkYzEyYTZlNjg3ZDI0ZDM3NTA4OWFlMjAyNWZjZmFkNGM5Yw==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2007-09-05T22:16:33Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2007-09-05T22:16:33Z"}, "message": "optabs.c (expand_float): Convert unsigned integer as signed only if it provides sufficient accuracy...\n\ngcc/\n\t* optabs.c (expand_float): Convert unsigned integer as signed only\n\tif it provides sufficient accuracy; add mode argument to real_2expN.\n\t(expand_fix): Fix comment typos; extend binary float into mode\n\twider than destination for converion to unsigned integer; add mode\n\targument to real_2expN.\n\t* real.c (real_2expN): Add mode argument to special-case decimal\n\tfloat values.\n\t* real.h (real_2expN): Ditto.\n\t* fixed-value.c (check_real_for_fixed_mode): Add mode argument to\n\treal_2expN.\n\t(fixed_from_string): Ditto.\n\t(fixed_to_decimal): Ditto.\n\t(fixed_convert_from_real): Ditto.\n\t(real_convert_from_fixed): Ditto.\n\t* config/rs6000/rs6000.md (FP): Include DD and TD modes.\n\t* config/rs6000/dfp.md (extendddtd2, adddd3, addtd3, subdd3, subtd3,\n\tmuldd3, multd3, divdd3, divtd3, cmpdd_internal1, cmptd_internal1,\n\tfloatditd2, ftruncdd2, fixdddi2, ftrunctd2, fixddi2): New.\n\ngcc/testsuite/\n\t* gcc.target/powerpc/dfp-dd.c: New test.\n\t* gcc.target/powerpc/dfp-td.c: New test.\n\nFrom-SVN: r128156", "tree": {"sha": "72280026eaa73c9852ddb3c7c02af486aa283ed6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72280026eaa73c9852ddb3c7c02af486aa283ed6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be677dc12a6e687d24d375089ae2025fcfad4c9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be677dc12a6e687d24d375089ae2025fcfad4c9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be677dc12a6e687d24d375089ae2025fcfad4c9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be677dc12a6e687d24d375089ae2025fcfad4c9c/comments", "author": null, "committer": null, "parents": [{"sha": "7336815f6fa8c43e6883a46ef3e32f2bee920ebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7336815f6fa8c43e6883a46ef3e32f2bee920ebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7336815f6fa8c43e6883a46ef3e32f2bee920ebc"}], "stats": {"total": 287, "additions": 268, "deletions": 19}, "files": [{"sha": "92a2ebda6ae1ef8034ad04749117584b634c3dff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be677dc12a6e687d24d375089ae2025fcfad4c9c", "patch": "@@ -1,3 +1,24 @@\n+2007-09-05  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* optabs.c (expand_float): Convert unsigned integer as signed only\n+\tif it provides sufficient accuracy; add mode argument to real_2expN.\n+\t(expand_fix): Fix comment typos; extend binary float into mode\n+\twider than destination for converion to unsigned integer; add mode\n+\targument to real_2expN.\n+\t* real.c (real_2expN): Add mode argument to special-case decimal\n+\tfloat values.\n+\t* real.h (real_2expN): Ditto.\n+\t* fixed-value.c (check_real_for_fixed_mode): Add mode argument to\n+\treal_2expN.\n+\t(fixed_from_string): Ditto.\n+\t(fixed_to_decimal): Ditto.\n+\t(fixed_convert_from_real): Ditto.\n+\t(real_convert_from_fixed): Ditto.\n+\t* config/rs6000/rs6000.md (FP): Include DD and TD modes.\n+\t* config/rs6000/dfp.md (extendddtd2, adddd3, addtd3, subdd3, subtd3,\n+\tmuldd3, multd3, divdd3, divtd3, cmpdd_internal1, cmptd_internal1,\n+\tfloatditd2, ftruncdd2, fixdddi2, ftrunctd2, fixddi2): New.\n+\n 2007-09-05  Ian Lance Taylor  <iant@google.com>\n \n \t* init-regs.c (initialize_uninitialized_regs): Call"}, {"sha": "fa20f7d0652d7b57fc86d15712fb24cbb7787f99", "filename": "gcc/config/rs6000/dfp.md", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Fconfig%2Frs6000%2Fdfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Fconfig%2Frs6000%2Fdfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdfp.md?ref=be677dc12a6e687d24d375089ae2025fcfad4c9c", "patch": "@@ -405,3 +405,151 @@\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n   [(set_attr \"length\" \"8,8,8,20,20,16\")])\n \n+;; Hardware support for decimal floating point operations.\n+\n+(define_insn \"extendddtd2\"\n+  [(set (match_operand:TD 0 \"gpc_reg_operand\" \"=f\")\n+\t(float_extend:TD (match_operand:DD 1 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dctqpq %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; The result of drdpq is an even/odd register pair with the converted\n+;; value in the even register and zero in the odd register.\n+;; FIXME: Avoid the register move by using a reload constraint to ensure\n+;; that the result is the first of the pair receiving the result of drdpq.\n+\n+(define_insn \"trunctddd2\"\n+  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"=f\")\n+\t(float_truncate:DD (match_operand:TD 1 \"gpc_reg_operand\" \"f\")))\n+   (clobber (match_scratch:TD 2 \"=f\"))]\n+  \"TARGET_DFP\"\n+  \"drdpq %2,%1\\;fmr %0,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"adddd3\"\n+  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"=f\")\n+\t(plus:DD (match_operand:DD 1 \"gpc_reg_operand\" \"%f\")\n+\t\t (match_operand:DD 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dadd %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"addtd3\"\n+  [(set (match_operand:TD 0 \"gpc_reg_operand\" \"=f\")\n+\t(plus:TD (match_operand:TD 1 \"gpc_reg_operand\" \"%f\")\n+\t\t (match_operand:TD 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"daddq %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"subdd3\"\n+  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"=f\")\n+\t(minus:DD (match_operand:DD 1 \"gpc_reg_operand\" \"f\")\n+\t\t  (match_operand:DD 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dsub %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"subtd3\"\n+  [(set (match_operand:TD 0 \"gpc_reg_operand\" \"=f\")\n+\t(minus:TD (match_operand:TD 1 \"gpc_reg_operand\" \"f\")\n+\t\t  (match_operand:TD 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dsubq %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"muldd3\"\n+  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"=f\")\n+\t(mult:DD (match_operand:DD 1 \"gpc_reg_operand\" \"%f\")\n+\t\t (match_operand:DD 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dmul %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"multd3\"\n+  [(set (match_operand:TD 0 \"gpc_reg_operand\" \"=f\")\n+\t(mult:TD (match_operand:TD 1 \"gpc_reg_operand\" \"%f\")\n+\t\t (match_operand:TD 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dmulq %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"divdd3\"\n+  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"=f\")\n+\t(div:DD (match_operand:DD 1 \"gpc_reg_operand\" \"f\")\n+\t\t(match_operand:DD 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"ddiv %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"divtd3\"\n+  [(set (match_operand:TD 0 \"gpc_reg_operand\" \"=f\")\n+\t(div:TD (match_operand:TD 1 \"gpc_reg_operand\" \"f\")\n+\t\t(match_operand:TD 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"ddivq %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"*cmpdd_internal1\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(compare:CCFP (match_operand:DD 1 \"gpc_reg_operand\" \"f\")\n+\t\t      (match_operand:DD 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dcmpu %0,%1,%2\"\n+  [(set_attr \"type\" \"fpcompare\")])\n+\n+(define_insn \"*cmptd_internal1\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(compare:CCFP (match_operand:TD 1 \"gpc_reg_operand\" \"f\")\n+\t\t      (match_operand:TD 2 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dcmpuq %0,%1,%2\"\n+  [(set_attr \"type\" \"fpcompare\")])\n+\n+(define_insn \"floatditd2\"\n+  [(set (match_operand:TD 0 \"gpc_reg_operand\" \"=f\")\n+\t(float:TD (match_operand:DI 1 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dcffixq %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; Convert a decimal64 to a decimal64 whose value is an integer.\n+;; This is the first stage of converting it to an integer type.\n+\n+(define_insn \"ftruncdd2\"\n+  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"=f\")\n+\t(fix:DD (match_operand:DD 1 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"drintn. 0,%0,%1,1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; Convert a decimal64 whose value is an integer to an actual integer.\n+;; This is the second stage of converting decimal float to integer type.\n+\n+(define_insn \"fixdddi2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=f\")\n+\t(fix:DI (match_operand:DD 1 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dctfix %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; Convert a decimal128 to a decimal128 whose value is an integer.\n+;; This is the first stage of converting it to an integer type.\n+\n+(define_insn \"ftrunctd2\"\n+  [(set (match_operand:TD 0 \"gpc_reg_operand\" \"=f\")\n+\t(fix:TD (match_operand:TD 1 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"drintnq. 0,%0,%1,1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; Convert a decimal128 whose value is an integer to an actual integer.\n+;; This is the second stage of converting decimal float to integer type.\n+\n+(define_insn \"fixtddi2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=f\")\n+\t(fix:DI (match_operand:TD 1 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dctfixq %0,%1\"\n+  [(set_attr \"type\" \"fp\")])"}, {"sha": "debacdc74b4e913984928a4df6fdc8ceee2ce4bc", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=be677dc12a6e687d24d375089ae2025fcfad4c9c", "patch": "@@ -204,7 +204,9 @@\n   (TF \"!TARGET_IEEEQUAD\n    && TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n-   && TARGET_LONG_DOUBLE_128\")])\n+   && TARGET_LONG_DOUBLE_128\")\n+  (DD \"TARGET_DFP\")\n+  (TD \"TARGET_DFP\")])\n \n ; Various instructions that come in SI and DI forms.\n ; A generic w/d attribute, for things like cmpw/cmpd."}, {"sha": "8c8d37190441bf3d3b8629e97f401c3c26958e49", "filename": "gcc/fixed-value.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Ffixed-value.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Ffixed-value.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.c?ref=be677dc12a6e687d24d375089ae2025fcfad4c9c", "patch": "@@ -64,8 +64,8 @@ check_real_for_fixed_mode (REAL_VALUE_TYPE *real_value, enum machine_mode mode)\n {\n   REAL_VALUE_TYPE max_value, min_value, epsilon_value;\n \n-  real_2expN (&max_value, GET_MODE_IBIT (mode));\n-  real_2expN (&epsilon_value, -GET_MODE_FBIT (mode));\n+  real_2expN (&max_value, GET_MODE_IBIT (mode), mode);\n+  real_2expN (&epsilon_value, -GET_MODE_FBIT (mode), mode);\n \n   if (SIGNED_FIXED_POINT_MODE_P (mode))\n     min_value = REAL_VALUE_NEGATE (max_value);\n@@ -102,7 +102,7 @@ fixed_from_string (FIXED_VALUE_TYPE *f, const char *str, enum machine_mode mode)\n       || (temp == FIXED_MAX_EPS && ALL_ACCUM_MODE_P (f->mode)))\n     warning (OPT_Woverflow,\n \t     \"large fixed-point constant implicitly truncated to fixed-point type\");\n-  real_2expN (&base_value, fbit);\n+  real_2expN (&base_value, fbit, mode);\n   real_arithmetic (&fixed_value, MULT_EXPR, &real_value, &base_value);\n   real_to_integer2 ((HOST_WIDE_INT *)&f->data.low, &f->data.high,\n \t\t    &fixed_value);\n@@ -132,7 +132,7 @@ fixed_to_decimal (char *str, const FIXED_VALUE_TYPE *f_orig,\n {\n   REAL_VALUE_TYPE real_value, base_value, fixed_value;\n \n-  real_2expN (&base_value, GET_MODE_FBIT (f_orig->mode));\n+  real_2expN (&base_value, GET_MODE_FBIT (f_orig->mode), f_orig->mode);\n   real_from_integer (&real_value, VOIDmode, f_orig->data.low, f_orig->data.high,\n \t\t     UNSIGNED_FIXED_POINT_MODE_P (f_orig->mode));\n   real_arithmetic (&fixed_value, RDIV_EXPR, &real_value, &base_value);\n@@ -1067,7 +1067,7 @@ fixed_convert_from_real (FIXED_VALUE_TYPE *f, enum machine_mode mode,\n \n   real_value = *a;\n   f->mode = mode;\n-  real_2expN (&base_value, fbit);\n+  real_2expN (&base_value, fbit, mode);\n   real_arithmetic (&fixed_value, MULT_EXPR, &real_value, &base_value);\n   real_to_integer2 ((HOST_WIDE_INT *)&f->data.low, &f->data.high, &fixed_value);\n   temp = check_real_for_fixed_mode (&real_value, mode);\n@@ -1116,7 +1116,7 @@ real_convert_from_fixed (REAL_VALUE_TYPE *r, enum machine_mode mode,\n {\n   REAL_VALUE_TYPE base_value, fixed_value, real_value;\n \n-  real_2expN (&base_value, GET_MODE_FBIT (f->mode));\n+  real_2expN (&base_value, GET_MODE_FBIT (f->mode), f->mode);\n   real_from_integer (&fixed_value, VOIDmode, f->data.low, f->data.high,\n \t\t     UNSIGNED_FIXED_POINT_MODE_P (f->mode));\n   real_arithmetic (&real_value, RDIV_EXPR, &fixed_value, &base_value);"}, {"sha": "5ed810176e13eb08f9762721826351ae3e567498", "filename": "gcc/optabs.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=be677dc12a6e687d24d375089ae2025fcfad4c9c", "patch": "@@ -5120,10 +5120,11 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t  }\n       }\n \n-  /* Unsigned integer, and no way to convert directly.  For binary\n-     floating point modes, convert as signed, then conditionally adjust\n-     the result.  */\n-  if (unsignedp && can_do_signed && !DECIMAL_FLOAT_MODE_P (GET_MODE (to)))\n+  /* Unsigned integer, and no way to convert directly.  Convert as signed,\n+     then unconditionally adjust the result.  For decimal float values we\n+     do this only if we have already determined that a signed conversion\n+     provides sufficient accuracy.  */\n+  if (unsignedp && (can_do_signed || !DECIMAL_FLOAT_MODE_P (GET_MODE (to))))\n     {\n       rtx label = gen_label_rtx ();\n       rtx temp;\n@@ -5214,7 +5215,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t\t\t       0, label);\n \n \n-      real_2expN (&offset, GET_MODE_BITSIZE (GET_MODE (from)));\n+      real_2expN (&offset, GET_MODE_BITSIZE (GET_MODE (from)), fmode);\n       temp = expand_binop (fmode, add_optab, target,\n \t\t\t   CONST_DOUBLE_FROM_REAL_VALUE (offset, fmode),\n \t\t\t   target, 0, OPTAB_LIB_WIDEN);\n@@ -5325,30 +5326,33 @@ expand_fix (rtx to, rtx from, int unsignedp)\n      anything with a wider integer mode.\n \n      This code used to extend FP value into mode wider than the destination.\n-     This is not needed.  Consider, for instance conversion from SFmode\n+     This is needed for decimal float modes which cannot accurately\n+     represent one plus the highest signed number of the same size, but\n+     not for binary modes.  Consider, for instance conversion from SFmode\n      into DImode.\n \n      The hot path through the code is dealing with inputs smaller than 2^63\n      and doing just the conversion, so there is no bits to lose.\n \n      In the other path we know the value is positive in the range 2^63..2^64-1\n-     inclusive.  (as for other imput overflow happens and result is undefined)\n+     inclusive.  (as for other input overflow happens and result is undefined)\n      So we know that the most important bit set in mantissa corresponds to\n      2^63.  The subtraction of 2^63 should not generate any rounding as it\n      simply clears out that bit.  The rest is trivial.  */\n \n   if (unsignedp && GET_MODE_BITSIZE (GET_MODE (to)) <= HOST_BITS_PER_WIDE_INT)\n     for (fmode = GET_MODE (from); fmode != VOIDmode;\n \t fmode = GET_MODE_WIDER_MODE (fmode))\n-      if (CODE_FOR_nothing != can_fix_p (GET_MODE (to), fmode, 0,\n-\t\t\t\t\t &must_trunc))\n+      if (CODE_FOR_nothing != can_fix_p (GET_MODE (to), fmode, 0, &must_trunc)\n+\t  && (!DECIMAL_FLOAT_MODE_P (fmode)\n+\t      || GET_MODE_BITSIZE (fmode) > GET_MODE_BITSIZE (GET_MODE (to))))\n \t{\n \t  int bitsize;\n \t  REAL_VALUE_TYPE offset;\n \t  rtx limit, lab1, lab2, insn;\n \n \t  bitsize = GET_MODE_BITSIZE (GET_MODE (to));\n-\t  real_2expN (&offset, bitsize - 1);\n+\t  real_2expN (&offset, bitsize - 1, fmode);\n \t  limit = CONST_DOUBLE_FROM_REAL_VALUE (offset, fmode);\n \t  lab1 = gen_label_rtx ();\n \t  lab2 = gen_label_rtx ();"}, {"sha": "8e623f6b9ad4a2a66517244077c73ec7fd27a5ca", "filename": "gcc/real.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=be677dc12a6e687d24d375089ae2025fcfad4c9c", "patch": "@@ -2304,7 +2304,7 @@ real_maxval (REAL_VALUE_TYPE *r, int sign, enum machine_mode mode)\n /* Fills R with 2**N.  */\n \n void\n-real_2expN (REAL_VALUE_TYPE *r, int n)\n+real_2expN (REAL_VALUE_TYPE *r, int n, enum machine_mode fmode)\n {\n   memset (r, 0, sizeof (*r));\n \n@@ -2319,6 +2319,9 @@ real_2expN (REAL_VALUE_TYPE *r, int n)\n       SET_REAL_EXP (r, n);\n       r->sig[SIGSZ-1] = SIG_MSB;\n     }\n+\n+  if (DECIMAL_FLOAT_MODE_P (fmode))\n+    decimal_real_convert (r, fmode, r);\n }\n \n \f"}, {"sha": "1eaabed28c0199549e73ed0ca1f5a158f95621e2", "filename": "gcc/real.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=be677dc12a6e687d24d375089ae2025fcfad4c9c", "patch": "@@ -248,7 +248,7 @@ extern bool real_nan (REAL_VALUE_TYPE *, const char *, int, enum machine_mode);\n \n extern void real_maxval (REAL_VALUE_TYPE *, int, enum machine_mode);\n \n-extern void real_2expN (REAL_VALUE_TYPE *, int);\n+extern void real_2expN (REAL_VALUE_TYPE *, int, enum machine_mode);\n \n extern unsigned int real_hash (const REAL_VALUE_TYPE *);\n "}, {"sha": "b0e24c0a34f90f07506e04bcebdf513104507daf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=be677dc12a6e687d24d375089ae2025fcfad4c9c", "patch": "@@ -1,3 +1,8 @@\n+2007-09-05  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* gcc.target/powerpc/dfp-dd.c: New test.\n+\t* gcc.target/powerpc/dfp-td.c: New test.\n+\n 2007-09-05  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/execute/va-arg-pack-1.c: New test."}, {"sha": "b329318754454c6f0123b6a08f01c990f7e9eefc", "filename": "gcc/testsuite/gcc.target/powerpc/dfp-dd.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-dd.c?ref=be677dc12a6e687d24d375089ae2025fcfad4c9c", "patch": "@@ -0,0 +1,33 @@\n+/* Test generation of DFP instructions for POWER6.  */\n+/* Origin: Janis Johnson <janis187@us.ibm.com> */\n+/* { dg-do compile { target powerpc*-*-linux* } } */\n+/* { dg-options \"-std=gnu99 -mcpu=power6\" } */\n+\n+/* { dg-final { scan-assembler \"dadd\" } } */\n+/* { dg-final { scan-assembler \"ddiv\" } } */\n+/* { dg-final { scan-assembler \"dmul\" } } */\n+/* { dg-final { scan-assembler \"dsub\" } } */\n+/* { dg-final { scan-assembler-times \"dcmpu\" 6 } } */\n+/* { dg-final { scan-assembler-times \"dctfix\" 2 } } */\n+/* { dg-final { scan-assembler-times \"drintn\" 2 } } */\n+/* { dg-final { scan-assembler-times \"dcffixq\" 2 } } */\n+\n+extern _Decimal64 a, b, c;\n+extern int result;\n+extern int si;\n+extern long long di;\n+\n+void add (void) { a = b + c; }\n+void div (void) { a = b / c; }\n+void mul (void) { a = b * c; }\n+void sub (void) { a = b - c; }\n+void eq (void) { result = a == b; }\n+void ne (void) { result = a != b; }\n+void lt (void) { result = a < b; }\n+void le (void) { result = a <= b; }\n+void gt (void) { result = a > b; }\n+void ge (void) { result = a >= b; }\n+void ddsi (void) { si = a; }\n+void dddi (void) { di = a; }\n+void sidd (void) { a = si; }\n+void didd (void) { a = di; }"}, {"sha": "f66bbd86c8721d37a585862b0aaafba67047fc57", "filename": "gcc/testsuite/gcc.target/powerpc/dfp-td.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be677dc12a6e687d24d375089ae2025fcfad4c9c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdfp-td.c?ref=be677dc12a6e687d24d375089ae2025fcfad4c9c", "patch": "@@ -0,0 +1,33 @@\n+/* Test generation of DFP instructions for POWER6.  */\n+/* Origin: Janis Johnson <janis187@us.ibm.com> */\n+/* { dg-do compile { target powerpc*-*-linux* } } */\n+/* { dg-options \"-std=gnu99 -mcpu=power6\" } */\n+\n+/* { dg-final { scan-assembler \"daddq\" } } */\n+/* { dg-final { scan-assembler \"ddivq\" } } */\n+/* { dg-final { scan-assembler \"dmulq\" } } */\n+/* { dg-final { scan-assembler \"dsubq\" } } */\n+/* { dg-final { scan-assembler-times \"dcmpuq\" 6 } } */\n+/* { dg-final { scan-assembler-times \"dctfixq\" 2 } } */\n+/* { dg-final { scan-assembler-times \"drintnq\" 2 } } */\n+/* { dg-final { scan-assembler-times \"dcffixq\" 2 } } */\n+\n+extern _Decimal128 a, b, c;\n+extern int result;\n+extern int si;\n+extern long long di;\n+\n+void add (void) { a = b + c; }\n+void div (void) { a = b / c; }\n+void mul (void) { a = b * c; }\n+void sub (void) { a = b - c; }\n+void eq (void) { result = a == b; }\n+void ne (void) { result = a != b; }\n+void lt (void) { result = a < b; }\n+void le (void) { result = a <= b; }\n+void gt (void) { result = a > b; }\n+void ge (void) { result = a >= b; }\n+void tdsi (void) { si = a; }\n+void tddi (void) { di = a; }\n+void sitd (void) { a = si; }\n+void ditd (void) { a = di; }"}]}