{"sha": "0f5afb626381d19bfced30bc19cf3b03867fa6f5", "node_id": "C_kwDOANBUbNoAKDBmNWFmYjYyNjM4MWQxOWJmY2VkMzBiYzE5Y2YzYjAzODY3ZmE2ZjU", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-21T15:15:41Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-21T15:15:41Z"}, "message": "Improve base tracking in ipa-modref\n\non exchange2 benchamrk we miss some useful propagation because modref gives\nup very early on analyzing accesses through pointers.  For example in\nint test (int *a)\n{\n  int i;\n  for (i=0; a[i];i++);\n  return i+a[i];\n}\n\nWe are not able to determine that a[i] accesses are relative to a.\nThis is because get_access requires the SSA name that is in MEM_REF to be\nPARM_DECL while on other places we use ipa-prop helper to work out the proper\nbase pointers.\n\nThis patch commonizes the code in get_access and parm_map_for_arg so both\nuse the check properly and extends it to also figure out that newly allocated\nmemory is not a side effect to caller.\n\ngcc/ChangeLog:\n\n2021-11-21  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR ipa/103227\n\t* ipa-modref.c (parm_map_for_arg): Rename to ...\n\t(parm_map_for_ptr): .. this one; handle static chain and calls to\n\tmalloc functions.\n\t(modref_access_analysis::get_access): Use parm_map_for_ptr.\n\t(modref_access_analysis::process_fnspec): Update.\n\t(modref_access_analysis::analyze_load): Update.\n\t(modref_access_analysis::analyze_store): Update.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-21  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR ipa/103227\n\t* gcc.dg/tree-ssa/modref-15.c: New test.", "tree": {"sha": "354565fa4803798181e80caca51286efae952d2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/354565fa4803798181e80caca51286efae952d2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f5afb626381d19bfced30bc19cf3b03867fa6f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f5afb626381d19bfced30bc19cf3b03867fa6f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f5afb626381d19bfced30bc19cf3b03867fa6f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f5afb626381d19bfced30bc19cf3b03867fa6f5/comments", "author": null, "committer": null, "parents": [{"sha": "c8260767aa3b41017b075d8fde3a4065fa637db7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8260767aa3b41017b075d8fde3a4065fa637db7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8260767aa3b41017b075d8fde3a4065fa637db7"}], "stats": {"total": 80, "additions": 44, "deletions": 36}, "files": [{"sha": "4f9323165ea0bf6750a4464ef808f234ddd3464b", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f5afb626381d19bfced30bc19cf3b03867fa6f5/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f5afb626381d19bfced30bc19cf3b03867fa6f5/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=0f5afb626381d19bfced30bc19cf3b03867fa6f5", "patch": "@@ -812,14 +812,15 @@ ignore_stores_p (tree caller, int flags)\n   return false;\n }\n \n-/* Determine parm_map for argument OP.  */\n+/* Determine parm_map for PTR which is supposed to be a pointer.  */\n \n modref_parm_map\n-parm_map_for_arg (tree op)\n+parm_map_for_ptr (tree op)\n {\n   bool offset_known;\n   poly_int64 offset;\n   struct modref_parm_map parm_map;\n+  gcall *call;\n \n   parm_map.parm_offset_known = false;\n   parm_map.parm_offset = 0;\n@@ -830,22 +831,26 @@ parm_map_for_arg (tree op)\n       && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)\n     {\n       int index = 0;\n-      for (tree t = DECL_ARGUMENTS (current_function_decl);\n-\t   t != SSA_NAME_VAR (op); t = DECL_CHAIN (t))\n-\t{\n-\t  if (!t)\n-\t    {\n-\t      index = MODREF_UNKNOWN_PARM;\n-\t      break;\n-\t    }\n+\n+      if (cfun->static_chain_decl\n+\t  && op == ssa_default_def (cfun, cfun->static_chain_decl))\n+\tindex = MODREF_STATIC_CHAIN_PARM;\n+      else\n+\tfor (tree t = DECL_ARGUMENTS (current_function_decl);\n+\t     t != SSA_NAME_VAR (op); t = DECL_CHAIN (t))\n \t  index++;\n-\t}\n       parm_map.parm_index = index;\n       parm_map.parm_offset_known = offset_known;\n       parm_map.parm_offset = offset;\n     }\n   else if (points_to_local_or_readonly_memory_p (op))\n     parm_map.parm_index = MODREF_LOCAL_MEMORY_PARM;\n+  /* Memory allocated in the function is not visible to caller before the\n+     call and thus we do not need to record it as load/stores/kills.  */\n+  else if (TREE_CODE (op) == SSA_NAME\n+\t   && (call = dyn_cast<gcall *>(SSA_NAME_DEF_STMT (op))) != NULL\n+\t   && gimple_call_flags (call) & ECF_MALLOC)\n+    parm_map.parm_index = MODREF_LOCAL_MEMORY_PARM;\n   else\n     parm_map.parm_index = MODREF_UNKNOWN_PARM;\n   return parm_map;\n@@ -955,33 +960,19 @@ modref_access_analysis::get_access (ao_ref *ref)\n   if (TREE_CODE (base) == MEM_REF || TREE_CODE (base) == TARGET_MEM_REF)\n     {\n       tree memref = base;\n-      base = TREE_OPERAND (base, 0);\n-\n-      if (TREE_CODE (base) == SSA_NAME\n-\t  && SSA_NAME_IS_DEFAULT_DEF (base)\n-\t  && TREE_CODE (SSA_NAME_VAR (base)) == PARM_DECL)\n-\t{\n-\t  a.parm_index = 0;\n-\t  if (cfun->static_chain_decl\n-\t      && base == ssa_default_def (cfun, cfun->static_chain_decl))\n-\t    a.parm_index = MODREF_STATIC_CHAIN_PARM;\n-\t  else\n-\t    for (tree t = DECL_ARGUMENTS (current_function_decl);\n-\t\t t != SSA_NAME_VAR (base); t = DECL_CHAIN (t))\n-\t      a.parm_index++;\n-\t}\n-      else\n-\ta.parm_index = MODREF_UNKNOWN_PARM;\n+      modref_parm_map m = parm_map_for_ptr (TREE_OPERAND (base, 0));\n \n-      if (a.parm_index != MODREF_UNKNOWN_PARM\n-\t  && TREE_CODE (memref) == MEM_REF)\n+      a.parm_index = m.parm_index;\n+      if (a.parm_index != MODREF_UNKNOWN_PARM && TREE_CODE (memref) == MEM_REF)\n \t{\n \t  a.parm_offset_known\n \t     = wi::to_poly_wide (TREE_OPERAND\n \t\t\t\t     (memref, 1)).to_shwi (&a.parm_offset);\n+\t  if (a.parm_offset_known && m.parm_offset_known)\n+\t    a.parm_offset += m.parm_offset;\n+\t  else\n+\t    a.parm_offset_known = false;\n \t}\n-      else\n-\ta.parm_offset_known = false;\n     }\n   else\n     a.parm_index = MODREF_UNKNOWN_PARM;\n@@ -1220,7 +1211,7 @@ modref_access_analysis::merge_call_side_effects\n   parm_map.safe_grow_cleared (gimple_call_num_args (stmt), true);\n   for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n     {\n-      parm_map[i] = parm_map_for_arg (gimple_call_arg (stmt, i));\n+      parm_map[i] = parm_map_for_ptr (gimple_call_arg (stmt, i));\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \" %i\", parm_map[i].parm_index);\n@@ -1236,7 +1227,7 @@ modref_access_analysis::merge_call_side_effects\n   modref_parm_map chain_map;\n   if (gimple_call_chain (stmt))\n     {\n-      chain_map = parm_map_for_arg (gimple_call_chain (stmt));\n+      chain_map = parm_map_for_ptr (gimple_call_chain (stmt));\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"static chain %i\", chain_map.parm_index);\n@@ -1390,7 +1381,7 @@ modref_access_analysis::process_fnspec (gcall *call)\n \telse if (!fnspec.arg_specified_p (i)\n \t\t || fnspec.arg_maybe_read_p (i))\n \t  {\n-\t    modref_parm_map map = parm_map_for_arg\n+\t    modref_parm_map map = parm_map_for_ptr\n \t\t\t\t\t(gimple_call_arg (call, i));\n \n \t    if (map.parm_index == MODREF_LOCAL_MEMORY_PARM)\n@@ -1401,6 +1392,8 @@ modref_access_analysis::process_fnspec (gcall *call)\n \t\tbreak;\n \t      }\n \t    modref_access_node a = get_access_for_fnspec (call, fnspec, i, map);\n+\t    if (a.parm_index == MODREF_LOCAL_MEMORY_PARM)\n+\t      continue;\n \t    if (m_summary)\n \t      m_summary->loads->insert (0, 0, a, false);\n \t    if (m_summary_lto)\n@@ -1419,7 +1412,7 @@ modref_access_analysis::process_fnspec (gcall *call)\n \telse if (!fnspec.arg_specified_p (i)\n \t\t || fnspec.arg_maybe_written_p (i))\n \t  {\n-\t    modref_parm_map map = parm_map_for_arg\n+\t    modref_parm_map map = parm_map_for_ptr\n \t\t\t\t\t (gimple_call_arg (call, i));\n \n \t    if (map.parm_index == MODREF_LOCAL_MEMORY_PARM)\n@@ -1430,6 +1423,8 @@ modref_access_analysis::process_fnspec (gcall *call)\n \t\tbreak;\n \t      }\n \t    modref_access_node a = get_access_for_fnspec (call, fnspec, i, map);\n+\t    if (a.parm_index == MODREF_LOCAL_MEMORY_PARM)\n+\t      continue;\n \t    if (m_summary)\n \t      m_summary->stores->insert (0, 0, a, false);\n \t    if (m_summary_lto)\n@@ -1553,6 +1548,8 @@ modref_access_analysis::analyze_load (gimple *, tree, tree op, void *data)\n   ao_ref r;\n   ao_ref_init (&r, op);\n   modref_access_node a = get_access (&r);\n+  if (a.parm_index == MODREF_LOCAL_MEMORY_PARM)\n+    return false;\n \n   if (t->m_summary)\n     t->record_access (t->m_summary->loads, &r, a);\n@@ -1581,6 +1578,8 @@ modref_access_analysis::analyze_store (gimple *stmt, tree, tree op, void *data)\n   ao_ref r;\n   ao_ref_init (&r, op);\n   modref_access_node a = get_access (&r);\n+  if (a.parm_index == MODREF_LOCAL_MEMORY_PARM)\n+    return false;\n \n   if (t->m_summary)\n     t->record_access (t->m_summary->stores, &r, a);"}, {"sha": "06881f2a76001d6645bcddb80655cf27893072c0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-15.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f5afb626381d19bfced30bc19cf3b03867fa6f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f5afb626381d19bfced30bc19cf3b03867fa6f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-15.c?ref=0f5afb626381d19bfced30bc19cf3b03867fa6f5", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-modref1\"  } */\n+int test (int *a)\n+{\n+  int i;\n+  for (i=0; a[i];i++);\n+  return i+a[i];\n+}\n+/* { dg-final { scan-tree-dump \"access: Parm 0\" \"modref1\"} } */"}]}