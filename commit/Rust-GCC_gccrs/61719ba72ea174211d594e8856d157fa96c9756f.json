{"sha": "61719ba72ea174211d594e8856d157fa96c9756f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE3MTliYTcyZWExNzQyMTFkNTk0ZTg4NTZkMTU3ZmE5NmM5NzU2Zg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-22T23:08:26Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-22T23:08:26Z"}, "message": "regclass.c (regclass): Break out some code into new function scan_one_insn, and into regclass_init.\n\n        * regclass.c (regclass): Break out some code into new function\n        scan_one_insn, and into regclass_init.\n        (init_cost): New static variable, moved out of regclass.\n        (regclass_init): Initialize it here, not in .\n        (scan_one_insn): New static function, broken out of regclass.\n        * recog.c (apply_change_group): Break out some code into new\n        function insn_invalid_p.\n        (insn_invalid_p): New static fn, broken out of apply_change_group.\n\nFrom-SVN: r23236", "tree": {"sha": "f33d6ad0bb1c8108c5fa289f5f24460c5ec2ec3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f33d6ad0bb1c8108c5fa289f5f24460c5ec2ec3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61719ba72ea174211d594e8856d157fa96c9756f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61719ba72ea174211d594e8856d157fa96c9756f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61719ba72ea174211d594e8856d157fa96c9756f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61719ba72ea174211d594e8856d157fa96c9756f/comments", "author": null, "committer": null, "parents": [{"sha": "04bbb0c54c7907baf626fb576536d82a78f7f43d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04bbb0c54c7907baf626fb576536d82a78f7f43d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04bbb0c54c7907baf626fb576536d82a78f7f43d"}], "stats": {"total": 494, "additions": 283, "deletions": 211}, "files": [{"sha": "3c5452f519bd7bcc69f03aec25a1f7dbacdf23a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61719ba72ea174211d594e8856d157fa96c9756f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61719ba72ea174211d594e8856d157fa96c9756f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61719ba72ea174211d594e8856d157fa96c9756f", "patch": "@@ -1,3 +1,14 @@\n+Fri Oct 23 00:07:01 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n+\n+\t* regclass.c (regclass): Break out some code into new function\n+\tscan_one_insn, and into regclass_init.\n+\t(init_cost): New static variable, moved out of regclass.\n+\t(regclass_init): Initialize it here, not in .\n+\t(scan_one_insn): New static function, broken out of regclass.\n+\t* recog.c (apply_change_group): Break out some code into new\n+\tfunction insn_invalid_p.\n+\t(insn_invalid_p): New static fn, broken out of apply_change_group.\n+\n Thu Oct 22 22:34:42 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* reload1.c (reload_as_needed): When rewrite POST_INC, verify"}, {"sha": "d525d47a051d90101f65e96ad3e40b491b942d7c", "filename": "gcc/recog.c", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61719ba72ea174211d594e8856d157fa96c9756f/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61719ba72ea174211d594e8856d157fa96c9756f/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=61719ba72ea174211d594e8856d157fa96c9756f", "patch": "@@ -40,9 +40,10 @@ Boston, MA 02111-1307, USA.  */\n #endif\n #endif\n \n-static void validate_replace_rtx_1 PROTO((rtx *, rtx, rtx, rtx));\n-static rtx *find_single_use_1 PROTO((rtx, rtx *));\n-static rtx *find_constant_term_loc PROTO((rtx *));\n+static void validate_replace_rtx_1\tPROTO((rtx *, rtx, rtx, rtx));\n+static rtx *find_single_use_1\t\tPROTO((rtx, rtx *));\n+static rtx *find_constant_term_loc\tPROTO((rtx *));\n+static int insn_invalid_p\t\tPROTO((rtx));\n \n /* Nonzero means allow operands to be volatile.\n    This should be 0 if you are generating rtl, such as if you are calling\n@@ -252,6 +253,41 @@ validate_change (object, loc, new, in_group)\n     return apply_change_group ();\n }\n \n+/* This subroutine of apply_change_group verifies whether the changes to INSN\n+   were valid; i.e. whether INSN can still be recognized.  */\n+\n+static int\n+insn_invalid_p (insn)\n+     rtx insn;\n+{\n+  int icode = recog_memoized (insn);\n+  int is_asm = icode < 0 && asm_noperands (PATTERN (insn)) >= 0;\n+\n+  if (is_asm)\n+    {\n+      if (! check_asm_operands (PATTERN (insn)))\n+\treturn 1;\n+\n+      /* Disallow modification of ASM_OPERANDS after reload; verifying the\n+\t constraints is too difficult.  */\n+      if (reload_completed)\n+\treturn 1;\n+    }\n+  else if (icode < 0)\n+    return 1;\n+\n+  /* After reload, verify that all constraints are satisfied.  */\n+  if (reload_completed)\n+    {\n+      insn_extract (insn);\n+\n+      if (! constrain_operands (INSN_CODE (insn), 1))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n /* Apply a group of changes previously issued with `validate_change'.\n    Return 1 if all changes are valid, zero otherwise.  */\n \n@@ -282,13 +318,7 @@ apply_change_group ()\n \t  if (! memory_address_p (GET_MODE (object), XEXP (object, 0)))\n \t    break;\n \t}\n-      else if ((recog_memoized (object) < 0\n-\t\t&& (asm_noperands (PATTERN (object)) < 0\n-\t\t    || ! check_asm_operands (PATTERN (object))\n-\t\t    || reload_completed))\n-\t       || (reload_completed\n-\t\t   && (insn_extract (object),\n-\t\t       ! constrain_operands (INSN_CODE (object), 1))))\n+      else if (insn_invalid_p (object))\n \t{\n \t  rtx pat = PATTERN (object);\n "}, {"sha": "75d730248859601b8f49d00785e03e2f49cf4479", "filename": "gcc/regclass.c", "status": "modified", "additions": 232, "deletions": 201, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61719ba72ea174211d594e8856d157fa96c9756f/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61719ba72ea174211d594e8856d157fa96c9756f/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=61719ba72ea174211d594e8856d157fa96c9756f", "patch": "@@ -648,6 +648,10 @@ struct costs\n \n static struct costs *costs;\n \n+/* Initialized once, and used to initialize cost values for each insn.  */\n+\n+static struct costs init_cost;\n+\n /* Record the same data by operand number, accumulated for each alternative\n    in an insn.  The contribution to a pseudo is that of the minimum-cost\n    alternative.  */\n@@ -685,6 +689,7 @@ static int loop_depth;\n static int loop_cost;\n \n static int n_occurrences\tPROTO((int, char *));\n+static rtx scan_one_insn\tPROTO((rtx, int));\n static void record_reg_classes\tPROTO((int, int, rtx *, enum machine_mode *,\n \t\t\t\t       char **, rtx));\n static int copy_cost\t\tPROTO((rtx, enum machine_mode, \n@@ -718,12 +723,19 @@ reg_alternate_class (regno)\n   return (enum reg_class) altclass[regno];\n }\n \n-/* This prevents dump_flow_info from losing if called\n-   before regclass is run.  */\n+/* Initialize some global data for this pass.  */\n \n void\n regclass_init ()\n {\n+  int i;\n+\n+  init_cost.mem_cost = 10000;\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    init_cost.cost[i] = 10000;\n+\n+  /* This prevents dump_flow_info from losing if called\n+     before regclass is run.  */\n   prefclass = 0;\n }\n \f\n@@ -739,6 +751,221 @@ n_occurrences (c, s)\n   return n;\n }\n \n+/* Subroutine of regclass, processes one insn INSN.  Scan it and record each\n+   time it would save code to put a certain register in a certain class.\n+   PASS, when nonzero, inhibits some optimizations which need only be done\n+   once.\n+   Return the last insn processed, so that the scan can be continued from\n+   there.  */\n+\n+static rtx\n+scan_one_insn (insn, pass)\n+     rtx insn;\n+     int pass;\n+{\n+  enum rtx_code code = GET_CODE (insn);\n+  enum rtx_code pat_code;\n+\n+  char *constraints[MAX_RECOG_OPERANDS];\n+  enum machine_mode modes[MAX_RECOG_OPERANDS];\n+  int nalternatives;\n+  int noperands;\n+  rtx set;\n+  int i, j;\n+\n+  /* Show that an insn inside a loop is likely to be executed three\n+     times more than insns outside a loop.  This is much more aggressive\n+     than the assumptions made elsewhere and is being tried as an\n+     experiment.  */\n+\n+  if (code == NOTE)\n+    {\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\tloop_depth++, loop_cost = 1 << (2 * MIN (loop_depth, 5));\n+      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\tloop_depth--, loop_cost = 1 << (2 * MIN (loop_depth, 5));\n+\n+      return insn;\n+    }\n+\n+  if (GET_RTX_CLASS (code) != 'i')\n+    return insn;\n+\n+  pat_code = GET_CODE (PATTERN (insn));\n+  if (pat_code == USE\n+      || pat_code == CLOBBER\n+      || pat_code == ASM_INPUT\n+      || pat_code == ADDR_VEC\n+      || pat_code == ADDR_DIFF_VEC)\n+    return insn;\n+\n+  if (code == INSN\n+      && (noperands = asm_noperands (PATTERN (insn))) >= 0)\n+    {\n+      decode_asm_operands (PATTERN (insn), recog_operand, NULL_PTR,\n+\t\t\t   constraints, modes);\n+      nalternatives = (noperands == 0 ? 0\n+\t\t       : n_occurrences (',', constraints[0]) + 1);\n+    }\n+  else\n+    {\n+      int insn_code_number = recog_memoized (insn);\n+      rtx note;\n+\n+      set = single_set (insn);\n+      insn_extract (insn);\n+\n+      nalternatives = insn_n_alternatives[insn_code_number];\n+      noperands = insn_n_operands[insn_code_number];\n+\n+      /* If this insn loads a parameter from its stack slot, then\n+\t it represents a savings, rather than a cost, if the\n+\t parameter is stored in memory.  Record this fact.  */\n+\n+      if (set != 0 && GET_CODE (SET_DEST (set)) == REG\n+\t  && GET_CODE (SET_SRC (set)) == MEM\n+\t  && (note = find_reg_note (insn, REG_EQUIV,\n+\t\t\t\t    NULL_RTX)) != 0\n+\t  && GET_CODE (XEXP (note, 0)) == MEM)\n+\t{\n+\t  costs[REGNO (SET_DEST (set))].mem_cost\n+\t    -= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)),\n+\t\t\t\t  GENERAL_REGS, 1)\n+\t\t* loop_cost);\n+\t  record_address_regs (XEXP (SET_SRC (set), 0),\n+\t\t\t       BASE_REG_CLASS, loop_cost * 2);\n+\t  return insn;\n+\t}\n+\n+      /* Improve handling of two-address insns such as\n+\t (set X (ashift CONST Y)) where CONST must be made to\n+\t match X. Change it into two insns: (set X CONST)\n+\t (set X (ashift X Y)).  If we left this for reloading, it\n+\t would probably get three insns because X and Y might go\n+\t in the same place. This prevents X and Y from receiving\n+\t the same hard reg.\n+\n+\t We can only do this if the modes of operands 0 and 1\n+\t (which might not be the same) are tieable and we only need\n+\t do this during our first pass.  */\n+\n+      if (pass == 0 && optimize\n+\t  && noperands >= 3\n+\t  && insn_operand_constraint[insn_code_number][1][0] == '0'\n+\t  && insn_operand_constraint[insn_code_number][1][1] == 0\n+\t  && CONSTANT_P (recog_operand[1])\n+\t  && ! rtx_equal_p (recog_operand[0], recog_operand[1])\n+\t  && ! rtx_equal_p (recog_operand[0], recog_operand[2])\n+\t  && GET_CODE (recog_operand[0]) == REG\n+\t  && MODES_TIEABLE_P (GET_MODE (recog_operand[0]),\n+\t\t\t      insn_operand_mode[insn_code_number][1]))\n+\t{\n+\t  rtx previnsn = prev_real_insn (insn);\n+\t  rtx dest\n+\t    = gen_lowpart (insn_operand_mode[insn_code_number][1],\n+\t\t\t   recog_operand[0]);\n+\t  rtx newinsn\n+\t    = emit_insn_before (gen_move_insn (dest,\n+\t\t\t\t\t       recog_operand[1]),\n+\t\t\t\tinsn);\n+\n+\t  /* If this insn was the start of a basic block,\n+\t     include the new insn in that block.\n+\t     We need not check for code_label here;\n+\t     while a basic block can start with a code_label,\n+\t     INSN could not be at the beginning of that block.  */\n+\t  if (previnsn == 0 || GET_CODE (previnsn) == JUMP_INSN)\n+\t    {\n+\t      int b;\n+\t      for (b = 0; b < n_basic_blocks; b++)\n+\t\tif (insn == basic_block_head[b])\n+\t\t  basic_block_head[b] = newinsn;\n+\t    }\n+\n+\t  /* This makes one more setting of new insns's dest.  */\n+\t  REG_N_SETS (REGNO (recog_operand[0]))++;\n+\n+\t  *recog_operand_loc[1] = recog_operand[0];\n+\t  for (i = insn_n_dups[insn_code_number] - 1; i >= 0; i--)\n+\t    if (recog_dup_num[i] == 1)\n+\t      *recog_dup_loc[i] = recog_operand[0];\n+\n+\t  return PREV_INSN (newinsn);\n+\t}\n+\n+      for (i = 0; i < noperands; i++)\n+\t{\n+\t  constraints[i]\n+\t    = insn_operand_constraint[insn_code_number][i];\n+\t  modes[i] = insn_operand_mode[insn_code_number][i];\n+\t}\n+    }\n+\n+  /* If we get here, we are set up to record the costs of all the\n+     operands for this insn.  Start by initializing the costs.\n+     Then handle any address registers.  Finally record the desired\n+     classes for any pseudos, doing it twice if some pair of\n+     operands are commutative.  */\n+\t     \n+  for (i = 0; i < noperands; i++)\n+    {\n+      op_costs[i] = init_cost;\n+\n+      if (GET_CODE (recog_operand[i]) == SUBREG)\n+\trecog_operand[i] = SUBREG_REG (recog_operand[i]);\n+\n+      if (GET_CODE (recog_operand[i]) == MEM)\n+\trecord_address_regs (XEXP (recog_operand[i], 0),\n+\t\t\t     BASE_REG_CLASS, loop_cost * 2);\n+      else if (constraints[i][0] == 'p')\n+\trecord_address_regs (recog_operand[i],\n+\t\t\t     BASE_REG_CLASS, loop_cost * 2);\n+    }\n+\n+  /* Check for commutative in a separate loop so everything will\n+     have been initialized.  We must do this even if one operand\n+     is a constant--see addsi3 in m68k.md.  */\n+\n+  for (i = 0; i < noperands - 1; i++)\n+    if (constraints[i][0] == '%')\n+      {\n+\tchar *xconstraints[MAX_RECOG_OPERANDS];\n+\tint j;\n+\n+\t/* Handle commutative operands by swapping the constraints.\n+\t   We assume the modes are the same.  */\n+\n+\tfor (j = 0; j < noperands; j++)\n+\t  xconstraints[j] = constraints[j];\n+\n+\txconstraints[i] = constraints[i+1];\n+\txconstraints[i+1] = constraints[i];\n+\trecord_reg_classes (nalternatives, noperands,\n+\t\t\t    recog_operand, modes, xconstraints,\n+\t\t\t    insn);\n+      }\n+\n+  record_reg_classes (nalternatives, noperands, recog_operand,\n+\t\t      modes, constraints, insn);\n+\n+  /* Now add the cost for each operand to the total costs for\n+     its register.  */\n+\n+  for (i = 0; i < noperands; i++)\n+    if (GET_CODE (recog_operand[i]) == REG\n+\t&& REGNO (recog_operand[i]) >= FIRST_PSEUDO_REGISTER)\n+      {\n+\tint regno = REGNO (recog_operand[i]);\n+\tstruct costs *p = &costs[regno], *q = &op_costs[i];\n+\n+\tp->mem_cost += q->mem_cost * loop_cost;\n+\tfor (j = 0; j < N_REG_CLASSES; j++)\n+\t  p->cost[j] += q->cost[j] * loop_cost;\n+      }\n+\n+  return insn;\n+}\n+\n /* This is a pass of the compiler that scans all instructions\n    and calculates the preferred class for each pseudo-register.\n    This information can be accessed later by calling `reg_preferred_class'.\n@@ -751,9 +978,7 @@ regclass (f, nregs)\n {\n #ifdef REGISTER_CONSTRAINTS\n   register rtx insn;\n-  register int i, j;\n-  struct costs init_cost;\n-  rtx set;\n+  register int i;\n   int pass;\n \n   init_recog ();\n@@ -812,10 +1037,6 @@ regclass (f, nregs)\n     }\n #endif /* FORBIDDEN_INC_DEC_CLASSES */\n \n-  init_cost.mem_cost = 10000;\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    init_cost.cost[i] = 10000;\n-\n   /* Normally we scan the insns once and determine the best class to use for\n      each register.  However, if -fexpensive_optimizations are on, we do so\n      twice, the second time using the tentative best classes to guide the\n@@ -838,199 +1059,9 @@ regclass (f, nregs)\n \n       for (insn = f; insn; insn = NEXT_INSN (insn))\n \t{\n-\t  char *constraints[MAX_RECOG_OPERANDS];\n-\t  enum machine_mode modes[MAX_RECOG_OPERANDS];\n-\t  int nalternatives;\n-\t  int noperands;\n-\n-\t  /* Show that an insn inside a loop is likely to be executed three\n-\t     times more than insns outside a loop.  This is much more aggressive\n-\t     than the assumptions made elsewhere and is being tried as an\n-\t     experiment.  */\n-\n-\t  if (GET_CODE (insn) == NOTE\n-\t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t    loop_depth++, loop_cost = 1 << (2 * MIN (loop_depth, 5));\n-\t  else if (GET_CODE (insn) == NOTE\n-\t\t   && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t    loop_depth--, loop_cost = 1 << (2 * MIN (loop_depth, 5));\n-\n-\t  else if ((GET_CODE (insn) == INSN\n-\t\t    && GET_CODE (PATTERN (insn)) != USE\n-\t\t    && GET_CODE (PATTERN (insn)) != CLOBBER\n-\t\t    && GET_CODE (PATTERN (insn)) != ASM_INPUT)\n-\t\t   || (GET_CODE (insn) == JUMP_INSN\n-\t\t       && GET_CODE (PATTERN (insn)) != ADDR_VEC\n-\t\t       && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n-\t\t   || GET_CODE (insn) == CALL_INSN)\n-\t    {\n-\t      if (GET_CODE (insn) == INSN\n-\t\t  && (noperands = asm_noperands (PATTERN (insn))) >= 0)\n-\t\t{\n-\t\t  decode_asm_operands (PATTERN (insn), recog_operand, NULL_PTR,\n-\t\t\t\t       constraints, modes);\n-\t\t  nalternatives = (noperands == 0 ? 0\n-\t\t\t\t   : n_occurrences (',', constraints[0]) + 1);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  int insn_code_number = recog_memoized (insn);\n-\t\t  rtx note;\n-\n-\t\t  set = single_set (insn);\n-\t\t  insn_extract (insn);\n-\n-\t\t  nalternatives = insn_n_alternatives[insn_code_number];\n-\t\t  noperands = insn_n_operands[insn_code_number];\n-\n-\t\t  /* If this insn loads a parameter from its stack slot, then\n-\t\t     it represents a savings, rather than a cost, if the\n-\t\t     parameter is stored in memory.  Record this fact.  */\n-\n-\t\t  if (set != 0 && GET_CODE (SET_DEST (set)) == REG\n-\t\t      && GET_CODE (SET_SRC (set)) == MEM\n-\t\t      && (note = find_reg_note (insn, REG_EQUIV,\n-\t\t\t\t\t\tNULL_RTX)) != 0\n-\t\t      && GET_CODE (XEXP (note, 0)) == MEM)\n-\t\t    {\n-\t\t      costs[REGNO (SET_DEST (set))].mem_cost\n-\t\t\t-= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)),\n-\t\t\t\t\t      GENERAL_REGS, 1)\n-\t\t\t    * loop_cost);\n-\t\t      record_address_regs (XEXP (SET_SRC (set), 0),\n-\t\t\t\t\t   BASE_REG_CLASS, loop_cost * 2);\n-\t\t      continue;\n-\t\t    }\n-\t      \n-\t\t  /* Improve handling of two-address insns such as\n-\t\t     (set X (ashift CONST Y)) where CONST must be made to\n-\t\t     match X. Change it into two insns: (set X CONST)\n-\t\t     (set X (ashift X Y)).  If we left this for reloading, it\n-\t\t     would probably get three insns because X and Y might go\n-\t\t     in the same place. This prevents X and Y from receiving\n-\t\t     the same hard reg.\n-\n-\t\t     We can only do this if the modes of operands 0 and 1\n-\t\t     (which might not be the same) are tieable and we only need\n-\t\t     do this during our first pass.  */\n-\n-\t\t  if (pass == 0 && optimize\n-\t\t      && noperands >= 3\n-\t\t      && insn_operand_constraint[insn_code_number][1][0] == '0'\n-\t\t      && insn_operand_constraint[insn_code_number][1][1] == 0\n-\t\t      && CONSTANT_P (recog_operand[1])\n-\t\t      && ! rtx_equal_p (recog_operand[0], recog_operand[1])\n-\t\t      && ! rtx_equal_p (recog_operand[0], recog_operand[2])\n-\t\t      && GET_CODE (recog_operand[0]) == REG\n-\t\t      && MODES_TIEABLE_P (GET_MODE (recog_operand[0]),\n-\t\t\t\t\t  insn_operand_mode[insn_code_number][1]))\n-\t\t    {\n-\t\t      rtx previnsn = prev_real_insn (insn);\n-\t\t      rtx dest\n-\t\t\t= gen_lowpart (insn_operand_mode[insn_code_number][1],\n-\t\t\t\t       recog_operand[0]);\n-\t\t      rtx newinsn\n-\t\t\t= emit_insn_before (gen_move_insn (dest,\n-\t\t\t\t\t\t\t   recog_operand[1]),\n-\t\t\t\t\t    insn);\n-\n-\t\t      /* If this insn was the start of a basic block,\n-\t\t\t include the new insn in that block.\n-\t\t\t We need not check for code_label here;\n-\t\t\t while a basic block can start with a code_label,\n-\t\t\t INSN could not be at the beginning of that block.  */\n-\t\t      if (previnsn == 0 || GET_CODE (previnsn) == JUMP_INSN)\n-\t\t\t{\n-\t\t\t  int b;\n-\t\t\t  for (b = 0; b < n_basic_blocks; b++)\n-\t\t\t    if (insn == basic_block_head[b])\n-\t\t\t      basic_block_head[b] = newinsn;\n-\t\t\t}\n-\n-\t\t      /* This makes one more setting of new insns's dest.  */\n-\t\t      REG_N_SETS (REGNO (recog_operand[0]))++;\n-\n-\t\t      *recog_operand_loc[1] = recog_operand[0];\n-\t\t      for (i = insn_n_dups[insn_code_number] - 1; i >= 0; i--)\n-\t\t\tif (recog_dup_num[i] == 1)\n-\t\t\t  *recog_dup_loc[i] = recog_operand[0];\n-\n-\t\t      insn = PREV_INSN (newinsn);\n-\t\t      continue;\n-\t\t    }\n-\n-\t\t  for (i = 0; i < noperands; i++)\n-\t\t    {\n-\t\t      constraints[i]\n-\t\t\t= insn_operand_constraint[insn_code_number][i];\n-\t\t      modes[i] = insn_operand_mode[insn_code_number][i];\n-\t\t    }\n-\t\t}\n-\n-\t      /* If we get here, we are set up to record the costs of all the\n-\t\t operands for this insn.  Start by initializing the costs.\n-\t\t Then handle any address registers.  Finally record the desired\n-\t\t classes for any pseudos, doing it twice if some pair of\n-\t\t operands are commutative.  */\n-\t     \n-\t      for (i = 0; i < noperands; i++)\n-\t\t{\n-\t\t  op_costs[i] = init_cost;\n-\n-\t\t  if (GET_CODE (recog_operand[i]) == SUBREG)\n-\t\t    recog_operand[i] = SUBREG_REG (recog_operand[i]);\n-\n-\t\t  if (GET_CODE (recog_operand[i]) == MEM)\n-\t\t    record_address_regs (XEXP (recog_operand[i], 0),\n-\t\t\t\t\t BASE_REG_CLASS, loop_cost * 2);\n-\t\t  else if (constraints[i][0] == 'p')\n-\t\t    record_address_regs (recog_operand[i],\n-\t\t\t\t\t BASE_REG_CLASS, loop_cost * 2);\n-\t\t}\n-\n-\t      /* Check for commutative in a separate loop so everything will\n-\t\t have been initialized.  We must do this even if one operand\n-\t\t is a constant--see addsi3 in m68k.md.  */\n-\t      \n-\t      for (i = 0; i < noperands - 1; i++)\n-\t\tif (constraints[i][0] == '%')\n-\t\t  {\n-\t\t    char *xconstraints[MAX_RECOG_OPERANDS];\n-\t\t    int j;\n-\n-\t\t    /* Handle commutative operands by swapping the constraints.\n-\t\t       We assume the modes are the same.  */\n-\n-\t\t    for (j = 0; j < noperands; j++)\n-\t\t      xconstraints[j] = constraints[j];\n-\n-\t\t    xconstraints[i] = constraints[i+1];\n-\t\t    xconstraints[i+1] = constraints[i];\n-\t\t    record_reg_classes (nalternatives, noperands,\n-\t\t\t\t\trecog_operand, modes, xconstraints,\n-\t\t\t\t\tinsn);\n-\t\t  }\n-\n-\t      record_reg_classes (nalternatives, noperands, recog_operand,\n-\t\t\t\t  modes, constraints, insn);\n-\n-\t      /* Now add the cost for each operand to the total costs for\n-\t\t its register.  */\n-\n-\t      for (i = 0; i < noperands; i++)\n-\t\tif (GET_CODE (recog_operand[i]) == REG\n-\t\t    && REGNO (recog_operand[i]) >= FIRST_PSEUDO_REGISTER)\n-\t\t  {\n-\t\t    int regno = REGNO (recog_operand[i]);\n-\t\t    struct costs *p = &costs[regno], *q = &op_costs[i];\n-\n-\t\t    p->mem_cost += q->mem_cost * loop_cost;\n-\t\t    for (j = 0; j < N_REG_CLASSES; j++)\n-\t\t      p->cost[j] += q->cost[j] * loop_cost;\n-\t\t  }\n-\t    }\n+\t  insn = scan_one_insn (insn, pass);\n \t}\n-\n+      \n       /* Now for each register look at how desirable each class is\n \t and find which class is preferred.  Store that in\n \t `prefclass[REGNO]'.  Record in `altclass[REGNO]' the largest register"}]}