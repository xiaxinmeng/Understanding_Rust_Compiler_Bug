{"sha": "9e32d2be984b4cdebf289aaa70fb08a4704b7b2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUzMmQyYmU5ODRiNGNkZWJmMjg5YWFhNzBmYjA4YTQ3MDRiN2IyYg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-03-14T15:19:56Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-03-14T15:19:56Z"}, "message": "basic-block.h (BB_VISITED): Removed.\n\n\t* basic-block.h (BB_VISITED): Removed.\n\t* cfganal.c (dfs_enumerate_from): Do not use BB_VISITED flag.\n\nFrom-SVN: r96434", "tree": {"sha": "0105e3fc15029ade7ad64a0debaf9cb88b54c34e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0105e3fc15029ade7ad64a0debaf9cb88b54c34e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e32d2be984b4cdebf289aaa70fb08a4704b7b2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e32d2be984b4cdebf289aaa70fb08a4704b7b2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e32d2be984b4cdebf289aaa70fb08a4704b7b2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e32d2be984b4cdebf289aaa70fb08a4704b7b2b/comments", "author": null, "committer": null, "parents": [{"sha": "ae83e8ae54a962fe7ed9dfe060f2e3af06978999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae83e8ae54a962fe7ed9dfe060f2e3af06978999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae83e8ae54a962fe7ed9dfe060f2e3af06978999"}], "stats": {"total": 99, "additions": 70, "deletions": 29}, "files": [{"sha": "abce9f293cdb81be1c6e7ff5f77b863be8186c1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e32d2be984b4cdebf289aaa70fb08a4704b7b2b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e32d2be984b4cdebf289aaa70fb08a4704b7b2b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e32d2be984b4cdebf289aaa70fb08a4704b7b2b", "patch": "@@ -1,3 +1,8 @@\n+2005-03-14  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* basic-block.h (BB_VISITED): Removed.\n+\t* cfganal.c (dfs_enumerate_from): Do not use BB_VISITED flag.\n+\n 2005-03-14  Falk Hueffner  <falk@debian.org>\n \n \tPR bootstrap/20424"}, {"sha": "bc5f448319c71c526135fca20f427644d0927645", "filename": "gcc/basic-block.h", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e32d2be984b4cdebf289aaa70fb08a4704b7b2b/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e32d2be984b4cdebf289aaa70fb08a4704b7b2b/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=9e32d2be984b4cdebf289aaa70fb08a4704b7b2b", "patch": "@@ -287,43 +287,41 @@ typedef struct reorder_block_def\n \n /* Masks for basic_block.flags.\n \n-   BB_VISITED should not be used by passes, it is used internally by\n-   dfs_enumerate_from.\n-\n    BB_HOT_PARTITION and BB_COLD_PARTITION should be preserved throughout\n    the compilation, so they are never cleared.\n \n    All other flags may be cleared by clear_bb_flags().  It is generally\n    a bad idea to rely on any flags being up-to-date.  */\n \n-/* Set if insns in BB have are modified.  Used for updating liveness info.  */\n-#define BB_DIRTY\t\t1\n+enum\n+{\n \n-/* Only set on blocks that have just been created by create_bb.  */\n-#define BB_NEW\t\t\t2\n+  /* Set if insns in BB have are modified.  Used for updating liveness info.  */\n+  BB_DIRTY = 1,\n \n-/* Set by find_unreachable_blocks.  Do not rely on this being set in any\n-   pass.  */\n-#define BB_REACHABLE\t\t4\n+  /* Only set on blocks that have just been created by create_bb.  */\n+  BB_NEW = 2,\n \n-/* Used by dfs_enumerate_from to keep track of visited basic blocks.  */\n-#define BB_VISITED\t\t8\n+  /* Set by find_unreachable_blocks.  Do not rely on this being set in any\n+     pass.  */\n+  BB_REACHABLE = 4,\n \n-/* Set for blocks in an irreducible loop by loop analysis.  */\n-#define BB_IRREDUCIBLE_LOOP\t16\n+  /* Set for blocks in an irreducible loop by loop analysis.  */\n+  BB_IRREDUCIBLE_LOOP = 8,\n \n-/* Set on blocks that may actually not be single-entry single-exit block.  */\n-#define BB_SUPERBLOCK\t\t32\n+  /* Set on blocks that may actually not be single-entry single-exit block.  */\n+  BB_SUPERBLOCK = 16,\n \n-/* Set on basic blocks that the scheduler should not touch.  This is used\n-   by SMS to prevent other schedulers from messing with the loop schedule.  */\n-#define BB_DISABLE_SCHEDULE\t64\n+  /* Set on basic blocks that the scheduler should not touch.  This is used\n+     by SMS to prevent other schedulers from messing with the loop schedule.  */\n+  BB_DISABLE_SCHEDULE = 32,\n \n-/* Set on blocks that should be put in a hot section.  */\n-#define BB_HOT_PARTITION\t128\n+  /* Set on blocks that should be put in a hot section.  */\n+  BB_HOT_PARTITION = 64,\n \n-/* Set on blocks that should be put in a cold section.  */\n-#define BB_COLD_PARTITION\t256\n+  /* Set on blocks that should be put in a cold section.  */\n+  BB_COLD_PARTITION = 128\n+};\n \n /* Dummy flag for convenience in the hot/cold partitioning code.  */\n #define BB_UNPARTITIONED\t0"}, {"sha": "5afbabc19e001bcad5ef4497cc9bb6341c8d87ba", "filename": "gcc/cfganal.c", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e32d2be984b4cdebf289aaa70fb08a4704b7b2b/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e32d2be984b4cdebf289aaa70fb08a4704b7b2b/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=9e32d2be984b4cdebf289aaa70fb08a4704b7b2b", "patch": "@@ -900,10 +900,45 @@ dfs_enumerate_from (basic_block bb, int reverse,\n {\n   basic_block *st, lbb;\n   int sp = 0, tv = 0;\n+  unsigned size;\n+\n+  /* A bitmap to keep track of visited blocks.  Allocating it each time\n+     this function is called is not possible, since dfs_enumerate_from\n+     is often used on small (almost) disjoint parts of cfg (bodies of\n+     loops), and allocating a large sbitmap would lead to quadratic\n+     behavior.  */\n+  static sbitmap visited;\n+  static unsigned v_size;\n+\n+#define MARK_VISITED(BB) (SET_BIT (visited, (BB)->index + 2))\n+#define UNMARK_VISITED(BB) (RESET_BIT (visited, (BB)->index + 2))\n+#define VISITED_P(BB) (TEST_BIT (visited, (BB)->index + 2))\n+\n+  /* Resize the VISITED sbitmap if necessary.  */\n+  size = last_basic_block + 2;\n+  if (size < 10)\n+    size = 10;\n+\n+  if (!visited)\n+    {\n+\n+      visited = sbitmap_alloc (size);\n+      sbitmap_zero (visited);\n+      v_size = size;\n+    }\n+  else if (v_size < size)\n+    {\n+      /* Ensure that we increase the size of the sbitmap exponentially.  */\n+      if (2 * v_size > size)\n+\tsize = 2 * v_size;\n+\n+      visited = sbitmap_resize (visited, size, 0);\n+      v_size = size;\n+    }\n \n   st = xcalloc (rslt_max, sizeof (basic_block));\n   rslt[tv++] = st[sp++] = bb;\n-  bb->flags |= BB_VISITED;\n+  MARK_VISITED (bb);\n   while (sp)\n     {\n       edge e;\n@@ -912,28 +947,31 @@ dfs_enumerate_from (basic_block bb, int reverse,\n       if (reverse)\n         {\n \t  FOR_EACH_EDGE (e, ei, lbb->preds)\n-\t    if (!(e->src->flags & BB_VISITED) && predicate (e->src, data))\n+\t    if (!VISITED_P (e->src) && predicate (e->src, data))\n \t      {\n \t        gcc_assert (tv != rslt_max);\n \t        rslt[tv++] = st[sp++] = e->src;\n-\t        e->src->flags |= BB_VISITED;\n+\t        MARK_VISITED (e->src);\n \t      }\n         }\n       else\n         {\n \t  FOR_EACH_EDGE (e, ei, lbb->succs)\n-\t    if (!(e->dest->flags & BB_VISITED) && predicate (e->dest, data))\n+\t    if (!VISITED_P (e->dest) && predicate (e->dest, data))\n \t      {\n \t        gcc_assert (tv != rslt_max);\n \t        rslt[tv++] = st[sp++] = e->dest;\n-\t        e->dest->flags |= BB_VISITED;\n+\t        MARK_VISITED (e->dest);\n \t      }\n \t}\n     }\n   free (st);\n   for (sp = 0; sp < tv; sp++)\n-    rslt[sp]->flags &= ~BB_VISITED;\n+    UNMARK_VISITED (rslt[sp]);\n   return tv;\n+#undef MARK_VISITED\n+#undef UNMARK_VISITED\n+#undef VISITED_P\n }\n \n "}]}