{"sha": "ab94bc48842d18b6e44546303904656fa37777f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI5NGJjNDg4NDJkMThiNmU0NDU0NjMwMzkwNDY1NmZhMzc3NzdmMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-01-07T18:39:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-01-07T18:39:19Z"}, "message": "jump.c (reversed_comparison_code_parts, [...]): New.\n\n\t* jump.c (reversed_comparison_code_parts, reversed_comparison_code):\n\tNew.\n\t(can_reverse_comparison_p): Rewrite to use reversed_comparison_code.\n\t(reverse_condition_maybe_unordered): Abort on unsigned comparisons.\n\t* rtl.h (reversed_comparison_code_parts, reversed_comparison_code):\n\tDeclare.\n\nFrom-SVN: r38779", "tree": {"sha": "6257660a69c432d217093b6d999d5392a89e6f7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6257660a69c432d217093b6d999d5392a89e6f7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab94bc48842d18b6e44546303904656fa37777f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab94bc48842d18b6e44546303904656fa37777f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab94bc48842d18b6e44546303904656fa37777f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab94bc48842d18b6e44546303904656fa37777f2/comments", "author": null, "committer": null, "parents": [{"sha": "f6a13bffbbae0b5cf9e74b8ee169c892d25faf0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6a13bffbbae0b5cf9e74b8ee169c892d25faf0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6a13bffbbae0b5cf9e74b8ee169c892d25faf0e"}], "stats": {"total": 224, "additions": 161, "deletions": 63}, "files": [{"sha": "f76676620a2e7712992704c1db6e41710490c2c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab94bc48842d18b6e44546303904656fa37777f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab94bc48842d18b6e44546303904656fa37777f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab94bc48842d18b6e44546303904656fa37777f2", "patch": "@@ -1,3 +1,12 @@\n+Sun Jan  7 19:37:48 MET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* jump.c (reversed_comparison_code_parts, reversed_comparison_code):\n+\tNew.\n+\t(can_reverse_comparison_p): Rewrite to use reversed_comparison_code.\n+\t(reverse_condition_maybe_unordered): Abort on unsigned comparisons.\n+\t* rtl.h (reversed_comparison_code_parts, reversed_comparison_code):\n+\tDeclare.\n+\n 2001-01-07  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n         * fix-header.c (read_scan_file): s/pfile/scan_in/."}, {"sha": "6fa1f339187274cc025ba03883be6646001a5dc9", "filename": "gcc/jump.c", "status": "modified", "additions": 149, "deletions": 63, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab94bc48842d18b6e44546303904656fa37777f2/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab94bc48842d18b6e44546303904656fa37777f2/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=ab94bc48842d18b6e44546303904656fa37777f2", "patch": "@@ -1699,80 +1699,174 @@ jump_back_p (insn, target)\n \t  && rtx_renumbered_equal_p (XEXP (cinsn, 1), XEXP (ctarget, 1)));\n }\n \f\n-/* Given a comparison, COMPARISON, inside a conditional jump insn, INSN,\n-   return non-zero if it is safe to reverse this comparison.  It is if our\n-   floating-point is not IEEE, if this is an NE or EQ comparison, or if\n-   this is known to be an integer comparison.  */\n-\n-int\n-can_reverse_comparison_p (comparison, insn)\n-     rtx comparison;\n-     rtx insn;\n+/* Given a comparison (CODE ARG0 ARG1), inside a insn, INSN, return an code\n+   of reversed comparison if it is possible to do so.  Otherwise return UNKNOWN.\n+   UNKNOWN may be returned in case we are having CC_MODE compare and we don't\n+   know whether it's source is floating point or integer comparison.  Machine\n+   description should define REVERSIBLE_CC_MODE and REVERSE_CONDITION macros\n+   to help this function avoid overhead in these cases.  */\n+enum rtx_code\n+reversed_comparison_code_parts (code, arg0, arg1, insn)\n+     rtx insn, arg0, arg1;\n+     enum rtx_code code;\n {\n-  rtx arg0;\n+  enum machine_mode mode;\n \n   /* If this is not actually a comparison, we can't reverse it.  */\n-  if (GET_RTX_CLASS (GET_CODE (comparison)) != '<')\n-    return 0;\n+  if (GET_RTX_CLASS (code) != '<')\n+    return UNKNOWN;\n \n-  if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-      /* If this is an NE comparison, it is safe to reverse it to an EQ\n-\t comparison and vice versa, even for floating point.  If no operands\n-\t are NaNs, the reversal is valid.  If some operand is a NaN, EQ is\n-\t always false and NE is always true, so the reversal is also valid.  */\n-      || flag_fast_math\n-      || GET_CODE (comparison) == NE\n-      || GET_CODE (comparison) == EQ)\n-    return 1;\n+  mode = GET_MODE (arg0);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (arg1);\n \n-  arg0 = XEXP (comparison, 0);\n+  /* First see if machine description supply us way to reverse the comparison.\n+     Give it priority over everything else to allow machine description to do\n+     tricks.  */\n+#ifdef REVERSIBLE_CC_MODE\n+  if (GET_MODE_CLASS (mode) == MODE_CC)\n+      && REVERSIBLE_CC_MODE (mode))\n+    {\n+#ifdef REVERSE_CONDITION\n+\t   return REVERSE_CONDITION (code, mode);\n+#endif\n+\t   return reverse_condition (code);\n+\t}\n+#endif\n \n-  /* Make sure ARG0 is one of the actual objects being compared.  If we\n-     can't do this, we can't be sure the comparison can be reversed.\n+  /* Try few special cases based on the comparison code.  */\n+  switch (code)\n+    {\n+      case GEU:\n+      case GTU:\n+      case LEU:\n+      case LTU:\n+      case NE:\n+      case EQ:\n+        /* It is always safe to reverse EQ and NE, even for the floating\n+\t   point.  Similary the unsigned comparisons are never used for\n+\t   floating point so we can reverse them in the default way.  */\n+\treturn reverse_condition (code);\n+      case ORDERED:\n+      case UNORDERED:\n+      case LTGT:\n+      case UNEQ:\n+\t/* In case we already see unordered comparison, we can be sure to\n+\t   be dealing with floating point so we don't need any more tests.  */\n+\treturn reverse_condition_maybe_unordered (code);\n+      case UNLT:\n+      case UNLE:\n+      case UNGT:\n+      case UNGE:\n+\t/* We don't have safe way to reverse these yet.  */\n+\treturn UNKNOWN;\n+      default:\n+\tbreak;\n+    }\n+\n+  /* In case we give up IEEE compatibility, all comparisons are reversible.  */\n+  if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n+      || flag_fast_math)\n+    return reverse_condition (code);\n \n-     Handle cc0 and a MODE_CC register.  */\n-  if ((GET_CODE (arg0) == REG && GET_MODE_CLASS (GET_MODE (arg0)) == MODE_CC)\n+  if (GET_MODE_CLASS (mode) == MODE_CC\n #ifdef HAVE_cc0\n       || arg0 == cc0_rtx\n #endif\n       )\n     {\n-      rtx prev, set;\n-\n-      /* First see if the condition code mode alone if enough to say we can\n-\t reverse the condition.  If not, then search backwards for a set of\n-\t ARG0. We do not need to check for an insn clobbering it since valid\n-\t code will contain set a set with no intervening clobber.  But\n-\t stop when we reach a label.  */\n-#ifdef REVERSIBLE_CC_MODE\n-      if (GET_MODE_CLASS (GET_MODE (arg0)) == MODE_CC\n-\t  && REVERSIBLE_CC_MODE (GET_MODE (arg0)))\n-\treturn 1;\n-#endif\n-\n+      rtx prev;\n+      /* Try to search for the comparison to determine the real mode.\n+         This code is expensive, but with sane machine description it\n+         will be never used, since REVERSIBLE_CC_MODE will return true\n+         in all cases.  */\n       if (! insn)\n-\treturn 0;\n+\treturn UNKNOWN;\n \n       for (prev = prev_nonnote_insn (insn);\n \t   prev != 0 && GET_CODE (prev) != CODE_LABEL;\n \t   prev = prev_nonnote_insn (prev))\n-\tif ((set = single_set (prev)) != 0\n-\t    && rtx_equal_p (SET_DEST (set), arg0))\n-\t  {\n-\t    arg0 = SET_SRC (set);\n+\t{\n+\t  rtx set = set_of (arg0, prev);\n+\t  if (set && GET_CODE (set) == SET\n+\t      && rtx_equal_p (SET_DEST (set), arg0))\n+\t    {\n+\t      rtx src = SET_SRC (set);\n \n-\t    if (GET_CODE (arg0) == COMPARE)\n-\t      arg0 = XEXP (arg0, 0);\n-\t    break;\n-\t  }\n+\t      if (GET_CODE (src) == COMPARE)\n+\t\t{\n+\t\t  rtx comparison = src;\n+\t\t  arg0 = XEXP (src, 0);\n+\t\t  mode = GET_MODE (arg0);\n+\t\t  if (mode == VOIDmode)\n+\t\t    mode = GET_MODE (XEXP (comparison, 1));\n+\t\t  break;\n+\t\t}\n+\t      /* We can get past reg-reg moves.  This may be usefull for model\n+\t         of i387 comparisons that first move flag registers around.  */\n+\t      if (REG_P (src))\n+\t\t{\n+\t\t  arg0 = src;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  /* If register is clobbered in some ununderstandable way,\n+\t     give up.  */\n+\t  if (set)\n+\t    return UNKNOWN;\n+\t}\n     }\n \n-  /* We can reverse this if ARG0 is a CONST_INT or if its mode is\n-     not VOIDmode and neither a MODE_CC nor MODE_FLOAT type.  */\n-  return (GET_CODE (arg0) == CONST_INT\n-\t  || (GET_MODE (arg0) != VOIDmode\n-\t      && GET_MODE_CLASS (GET_MODE (arg0)) != MODE_CC\n-\t      && GET_MODE_CLASS (GET_MODE (arg0)) != MODE_FLOAT));\n+  /* An integer condition.  */\n+  if (GET_CODE (arg0) == CONST_INT\n+      || (GET_MODE (arg0) != VOIDmode\n+\t  && GET_MODE_CLASS (mode) != MODE_CC\n+\t  && ! FLOAT_MODE_P (mode)))\n+    return reverse_condition (code);\n+\n+  return UNKNOWN;\n+}\n+\n+/* An wrapper around the previous function to take COMPARISON as rtx\n+   expression.  This simplifies many callers.  */\n+enum rtx_code\n+reversed_comparison_code (comparison, insn)\n+     rtx comparison, insn;\n+{\n+  if (GET_RTX_CLASS (GET_CODE (comparison)) != '<')\n+    return UNKNOWN;\n+  return reversed_comparison_code_parts (GET_CODE (comparison),\n+\t\t\t\t\t XEXP (comparison, 0),\n+\t\t\t\t\t XEXP (comparison, 1), insn);\n+}\n+\f\n+/* Given a comparison, COMPARISON, inside a conditional jump insn, INSN,\n+   return non-zero if it is safe to reverse this comparison.  It is if our\n+   floating-point is not IEEE, if this is an NE or EQ comparison, or if\n+   this is known to be an integer comparison.  \n+ \n+   Use of this function is depreached and you should use\n+   REVERSED_COMPARISON_CODE bits instead.\n+ */\n+\n+int\n+can_reverse_comparison_p (comparison, insn)\n+     rtx comparison;\n+     rtx insn;\n+{\n+  enum rtx_code code;\n+\n+  /* If this is not actually a comparison, we can't reverse it.  */\n+  if (GET_RTX_CLASS (GET_CODE (comparison)) != '<')\n+    return 0;\n+\n+  code = reversed_comparison_code (comparison, insn);\n+  if (code == UNKNOWN)\n+    return 0;\n+\n+  /* The code will follow can_reverse_comparison_p with reverse_condition,\n+     so see if it will get proper result.  */\n+  return (code == reverse_condition (GET_CODE (comparison)));\n }\n \n /* Given an rtx-code for a comparison, return the code for the negated\n@@ -1781,7 +1875,7 @@ can_reverse_comparison_p (comparison, insn)\n    WATCH OUT!  reverse_condition is not safe to use on a jump that might\n    be acting on the results of an IEEE floating point comparison, because\n    of the special treatment of non-signaling nans in comparisons.\n-   Use can_reverse_comparison_p to be sure.  */\n+   Use reversed_comparison_code instead.  */\n \n enum rtx_code\n reverse_condition (code)\n@@ -1855,14 +1949,6 @@ reverse_condition_maybe_unordered (code)\n       return UNGT;\n     case LTGT:\n       return UNEQ;\n-    case GTU:\n-      return LEU;\n-    case GEU:\n-      return LTU;\n-    case LTU:\n-      return GEU;\n-    case LEU:\n-      return GTU;\n     case UNORDERED:\n       return ORDERED;\n     case ORDERED:"}, {"sha": "9db7a37183c915dbeb7f8f463858aec8e50a6cb1", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab94bc48842d18b6e44546303904656fa37777f2/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab94bc48842d18b6e44546303904656fa37777f2/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ab94bc48842d18b6e44546303904656fa37777f2", "patch": "@@ -1701,6 +1701,9 @@ extern void rebuild_jump_labels\t\tPARAMS ((rtx));\n extern void thread_jumps\t\tPARAMS ((rtx, int, int));\n extern int rtx_equal_for_thread_p\tPARAMS ((rtx, rtx, rtx));\n extern int can_reverse_comparison_p\tPARAMS ((rtx, rtx));\n+extern enum rtx_code reversed_comparison_code PARAMS ((rtx, rtx));\n+extern enum rtx_code reversed_comparison_code_parts PARAMS ((enum rtx_code,\n+\t\t\t\t\t\t\t     rtx, rtx, rtx));\n extern void delete_for_peephole\t\tPARAMS ((rtx, rtx));\n extern int condjump_in_parallel_p\tPARAMS ((rtx));\n extern void never_reached_warning\tPARAMS ((rtx));"}]}