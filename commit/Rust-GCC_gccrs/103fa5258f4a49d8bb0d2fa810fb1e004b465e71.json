{"sha": "103fa5258f4a49d8bb0d2fa810fb1e004b465e71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAzZmE1MjU4ZjRhNDlkOGJiMGQyZmE4MTBmYjFlMDA0YjQ2NWU3MQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-09-25T20:46:52Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-09-25T20:46:52Z"}, "message": "sparc.c (print_operand): Handle new codes H/L.\n\n\t* sparc.c (print_operand): Handle new codes H/L.\n\t* sparc.md (lo_sum_di_sp32,adddi3_sp32,subdi3_sp32,\n\tmulsidi3_sp32,const_mulsidi3,umulsidi3_sp32,const_umulsidi3,\n\tsmacdi,umacdi,anddi3_sp32,iordi3_sp32,xordi3_sp32,negdi2_sp32):\n\tAdd little endian support.\n\nFrom-SVN: r12846", "tree": {"sha": "2c88f96019d1fc482df6141a6c6e3f648f476e52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c88f96019d1fc482df6141a6c6e3f648f476e52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/103fa5258f4a49d8bb0d2fa810fb1e004b465e71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/103fa5258f4a49d8bb0d2fa810fb1e004b465e71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/103fa5258f4a49d8bb0d2fa810fb1e004b465e71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/103fa5258f4a49d8bb0d2fa810fb1e004b465e71/comments", "author": null, "committer": null, "parents": [{"sha": "0f39a9aa8b5eb478f5ad3082c7f5bb17b146efef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f39a9aa8b5eb478f5ad3082c7f5bb17b146efef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f39a9aa8b5eb478f5ad3082c7f5bb17b146efef"}], "stats": {"total": 139, "additions": 49, "deletions": 90}, "files": [{"sha": "196b2f1078fdd5f6b3e7c324230bee4c99ad7895", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 49, "deletions": 90, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/103fa5258f4a49d8bb0d2fa810fb1e004b465e71/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/103fa5258f4a49d8bb0d2fa810fb1e004b465e71/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=103fa5258f4a49d8bb0d2fa810fb1e004b465e71", "patch": "@@ -1605,7 +1605,7 @@\n      handle it correctly.  */\n   if (GET_CODE (operands[2]) == CONST_DOUBLE)\n     operands[2] = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (operands[2]));\n-  return \\\"or %R1,%%lo(%a2),%R0\\\";\n+  return \\\"or %L1,%%lo(%a2),%L0\\\";\n }\"\n   ;; Need to set length for this arith insn because operand2\n   ;; is not an \"arith_operand\".\n@@ -3538,29 +3538,23 @@\n {\n   rtx op2 = operands[2];\n \n-  /* If constant is positive, upper bits zeroed, otherwise unchanged.\n-     Give the assembler a chance to pick the move instruction. */\n-  if (GET_CODE (op2) == CONST_INT)\n-    {\n-      int sign = INTVAL (op2);\n-      if (sign < 0)\n-\treturn \\\"addcc %R1,%2,%R0\\;addx %1,-1,%0\\\";\n-      return \\\"addcc %R1,%2,%R0\\;addx %1,0,%0\\\";\n-    }\n-  else if (GET_CODE (op2) == CONST_DOUBLE)\n+  if (GET_CODE (op2) == CONST_INT\n+      || GET_CODE (op2) == CONST_DOUBLE)\n     {\n       rtx xoperands[4];\n       xoperands[0] = operands[0];\n       xoperands[1] = operands[1];\n-      xoperands[2] = GEN_INT (CONST_DOUBLE_LOW (op2));\n-      xoperands[3] = GEN_INT (CONST_DOUBLE_HIGH (op2));\n-      if (xoperands[2] == const0_rtx && xoperands[0] == xoperands[1])\n-\toutput_asm_insn (\\\"add %1,%3,%0\\\", xoperands);\n+      if (WORDS_BIG_ENDIAN)\n+\tsplit_double (op2, &xoperands[2], &xoperands[3]);\n+      else\n+\tsplit_double (op2, &xoperands[3], &xoperands[2]);\n+      if (xoperands[3] == const0_rtx && xoperands[0] == xoperands[1])\n+\toutput_asm_insn (\\\"add %H1,%2,%H0\\\", xoperands);\n       else\n-\toutput_asm_insn (\\\"addcc %R1,%2,%R0\\;addx %1,%3,%0\\\", xoperands);\n+\toutput_asm_insn (\\\"addcc %L1,%3,%L0\\;addx %H1,%2,%H0\\\", xoperands);\n       return \\\"\\\";\n     }\n-  return \\\"addcc %R1,%R2,%R0\\;addx %1,%2,%0\\\";\n+  return \\\"addcc %L1,%L2,%L0\\;addx %H1,%H2,%H0\\\";\n }\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3646,29 +3640,23 @@\n {\n   rtx op2 = operands[2];\n \n-  /* If constant is positive, upper bits zeroed, otherwise unchanged.\n-     Give the assembler a chance to pick the move instruction. */\n-  if (GET_CODE (op2) == CONST_INT)\n-    {\n-      int sign = INTVAL (op2);\n-      if (sign < 0)\n-\treturn \\\"subcc %R1,%2,%R0\\;subx %1,-1,%0\\\";\n-      return \\\"subcc %R1,%2,%R0\\;subx %1,0,%0\\\";\n-    }\n-  else if (GET_CODE (op2) == CONST_DOUBLE)\n+  if (GET_CODE (op2) == CONST_INT\n+      || GET_CODE (op2) == CONST_DOUBLE)\n     {\n       rtx xoperands[4];\n       xoperands[0] = operands[0];\n       xoperands[1] = operands[1];\n-      xoperands[2] = GEN_INT (CONST_DOUBLE_LOW (op2));\n-      xoperands[3] = GEN_INT (CONST_DOUBLE_HIGH (op2));\n-      if (xoperands[2] == const0_rtx && xoperands[0] == xoperands[1])\n-\toutput_asm_insn (\\\"sub %1,%3,%0\\\", xoperands);\n+      if (WORDS_BIG_ENDIAN)\n+\tsplit_double (op2, &xoperands[2], &xoperands[3]);\n       else\n-\toutput_asm_insn (\\\"subcc %R1,%2,%R0\\;subx %1,%3,%0\\\", xoperands);\n+\tsplit_double (op2, &xoperands[3], &xoperands[2]);\n+      if (xoperands[3] == const0_rtx && xoperands[0] == xoperands[1])\n+\toutput_asm_insn (\\\"sub %H1,%2,%H0\\\", xoperands);\n+      else\n+\toutput_asm_insn (\\\"subcc %L1,%3,%L0\\;subx %H1,%2,%H0\\\", xoperands);\n       return \\\"\\\";\n     }\n-  return \\\"subcc %R1,%R2,%R0\\;subx %1,%2,%0\\\";\n+  return \\\"subcc %L1,%L2,%L0\\;subx %H1,%H2,%H0\\\";\n }\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3780,7 +3768,7 @@\n   \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n   \"*\n {\n-  return TARGET_SPARCLET ? \\\"smuld %1,%2,%R0\\\" : \\\"smul %1,%2,%R0\\;rd %%y,%0\\\";\n+  return TARGET_SPARCLET ? \\\"smuld %1,%2,%L0\\\" : \\\"smul %1,%2,%L0\\;rd %%y,%H0\\\";\n }\"\n   [(set (attr \"length\")\n \t(if_then_else (eq_attr \"isa\" \"sparclet\")\n@@ -3795,7 +3783,7 @@\n   \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n   \"*\n {\n-  return TARGET_SPARCLET ? \\\"smuld %1,%2,%R0\\\" : \\\"smul %1,%2,%R0\\;rd %%y,%0\\\";\n+  return TARGET_SPARCLET ? \\\"smuld %1,%2,%L0\\\" : \\\"smul %1,%2,%L0\\;rd %%y,%H0\\\";\n }\"\n   [(set (attr \"length\")\n \t(if_then_else (eq_attr \"isa\" \"sparclet\")\n@@ -3858,7 +3846,7 @@\n   \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n   \"*\n {\n-  return TARGET_SPARCLET ? \\\"umuld %1,%2,%R0\\\" : \\\"umul %1,%2,%R0\\;rd %%y,%0\\\";\n+  return TARGET_SPARCLET ? \\\"umuld %1,%2,%L0\\\" : \\\"umul %1,%2,%L0\\;rd %%y,%H0\\\";\n }\"\n   [(set (attr \"length\")\n \t(if_then_else (eq_attr \"isa\" \"sparclet\")\n@@ -3873,7 +3861,7 @@\n   \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n   \"*\n {\n-  return TARGET_SPARCLET ? \\\"umuld %1,%2,%R0\\\" : \\\"umul %1,%2,%R0\\;rd %%y,%0\\\";\n+  return TARGET_SPARCLET ? \\\"umuld %1,%2,%L0\\\" : \\\"umul %1,%2,%L0\\;rd %%y,%H0\\\";\n }\"\n   [(set (attr \"length\")\n \t(if_then_else (eq_attr \"isa\" \"sparclet\")\n@@ -4027,7 +4015,7 @@\n \t\t\t   (match_operand:SI 2 \"register_operand\" \"r\")))\n \t\t (match_operand:DI 3 \"register_operand\" \"0\")))]\n   \"TARGET_SPARCLET\"\n-  \"smacd %1,%2,%R0\"\n+  \"smacd %1,%2,%L0\"\n   [(set_attr \"type\" \"imul\")])\n \n (define_insn \"*umacdi\"\n@@ -4038,7 +4026,7 @@\n \t\t\t   (match_operand:SI 2 \"register_operand\" \"r\")))\n \t\t (match_operand:DI 3 \"register_operand\" \"0\")))]\n   \"TARGET_SPARCLET\"\n-  \"umacd %1,%2,%R0\"\n+  \"umacd %1,%2,%L0\"\n   [(set_attr \"type\" \"imul\")])\n \f\n ;;- Boolean instructions\n@@ -4061,25 +4049,17 @@\n {\n   rtx op2 = operands[2];\n \n-  /* If constant is positive, upper bits zeroed, otherwise unchanged.\n-     Give the assembler a chance to pick the move instruction. */\n-  if (GET_CODE (op2) == CONST_INT)\n-    {\n-      int sign = INTVAL (op2);\n-      if (sign < 0)\n-\treturn \\\"mov %1,%0\\;and %R1,%2,%R0\\\";\n-      return \\\"mov 0,%0\\;and %R1,%2,%R0\\\";\n-    }\n-  else if (GET_CODE (op2) == CONST_DOUBLE)\n+  if (GET_CODE (op2) == CONST_INT\n+      || GET_CODE (op2) == CONST_DOUBLE)\n     {\n       rtx xoperands[4];\n       xoperands[0] = operands[0];\n       xoperands[1] = operands[1];\n-      xoperands[2] = GEN_INT (CONST_DOUBLE_LOW (op2));\n-      xoperands[3] = GEN_INT (CONST_DOUBLE_HIGH (op2));\n-      /* We could optimize then operands[1] == operands[0]\n-\t and either half of the constant is -1.  */\n-      output_asm_insn (\\\"and %R1,%2,%R0\\;and %1,%3,%0\\\", xoperands);\n+      if (WORDS_BIG_ENDIAN)\n+\tsplit_double (op2, &xoperands[2], &xoperands[3]);\n+      else\n+\tsplit_double (op2, &xoperands[3], &xoperands[2]);\n+      output_asm_insn (\\\"and %L1,%3,%L0\\;and %H1,%2,%H0\\\", xoperands);\n       return \\\"\\\";\n     }\n   return \\\"and %1,%2,%0\\;and %R1,%R2,%R0\\\";\n@@ -4155,30 +4135,17 @@\n {\n   rtx op2 = operands[2];\n \n-  /* If constant is positive, upper bits zeroed, otherwise unchanged.\n-     Give the assembler a chance to pick the move instruction. */\n-  if (GET_CODE (op2) == CONST_INT)\n-    {\n-      int sign = INTVAL (op2);\n-      if (sign < 0)\n-\t{\n-\t  if (TARGET_LIVE_G0)\n-\t    return \\\"and %0,0,%0\\;add %0,-1,%0\\;or %R1,%2,%R0\\\";\n-\t  else\n-\t    return \\\"mov -1,%0\\;or %R1,%2,%R0\\\";\n-\t}\n-      return \\\"mov %1,%0\\;or %R1,%2,%R0\\\";\n-    }\n-  else if (GET_CODE (op2) == CONST_DOUBLE)\n+  if (GET_CODE (op2) == CONST_INT\n+      || GET_CODE (op2) == CONST_DOUBLE)\n     {\n       rtx xoperands[4];\n       xoperands[0] = operands[0];\n       xoperands[1] = operands[1];\n-      xoperands[2] = GEN_INT (CONST_DOUBLE_LOW (op2));\n-      xoperands[3] = GEN_INT (CONST_DOUBLE_HIGH (op2));\n-      /* We could optimize then operands[1] == operands[0]\n-\t and either half of the constant is 0.  */\n-      output_asm_insn (\\\"or %R1,%2,%R0\\;or %1,%3,%0\\\", xoperands);\n+      if (WORDS_BIG_ENDIAN)\n+\tsplit_double (op2, &xoperands[2], &xoperands[3]);\n+      else\n+\tsplit_double (op2, &xoperands[3], &xoperands[2]);\n+      output_asm_insn (\\\"or %L1,%3,%L0\\;or %H1,%2,%H0\\\", xoperands);\n       return \\\"\\\";\n     }\n   return \\\"or %1,%2,%0\\;or %R1,%R2,%R0\\\";\n@@ -4254,25 +4221,17 @@\n {\n   rtx op2 = operands[2];\n \n-  /* If constant is positive, upper bits zeroed, otherwise unchanged.\n-     Give the assembler a chance to pick the move instruction. */\n-  if (GET_CODE (op2) == CONST_INT)\n-    {\n-      int sign = INTVAL (op2);\n-      if (sign < 0)\n-\treturn \\\"xor %1,-1,%0\\;xor %R1,%2,%R0\\\";\n-      return \\\"mov %1,%0\\;xor %R1,%2,%R0\\\";\n-    }\n-  else if (GET_CODE (op2) == CONST_DOUBLE)\n+  if (GET_CODE (op2) == CONST_INT\n+      || GET_CODE (op2) == CONST_DOUBLE)\n     {\n       rtx xoperands[4];\n       xoperands[0] = operands[0];\n       xoperands[1] = operands[1];\n-      xoperands[2] = GEN_INT (CONST_DOUBLE_LOW (op2));\n-      xoperands[3] = GEN_INT (CONST_DOUBLE_HIGH (op2));\n-      /* We could optimize then operands[1] == operands[0]\n-\t and either half of the constant is 0.  */\n-      output_asm_insn (\\\"xor %R1,%2,%R0\\;xor %1,%3,%0\\\", xoperands);\n+      if (WORDS_BIG_ENDIAN)\n+\tsplit_double (op2, &xoperands[2], &xoperands[3]);\n+      else\n+\tsplit_double (op2, &xoperands[3], &xoperands[2]);\n+      output_asm_insn (\\\"xor %L1,%3,%L0\\;xor %H1,%2,%H0\\\", xoperands);\n       return \\\"\\\";\n     }\n   return \\\"xor %1,%2,%0\\;xor %R1,%R2,%R0\\\";\n@@ -4515,7 +4474,7 @@\n {\n   if (TARGET_LIVE_G0)\n     output_asm_insn (\\\"and %%g0,0,%%g0\\\", operands);\n-  return \\\"subcc %%g0,%R1,%R0\\;subx %%g0,%1,%0\\\";\n+  return \\\"subcc %%g0,%L1,%L0\\;subx %%g0,%H1,%H0\\\";\n }\"\n   [(set_attr \"type\" \"unary\")\n    ;; ??? This is wrong for TARGET_LIVE_G0 but it's not critical."}]}