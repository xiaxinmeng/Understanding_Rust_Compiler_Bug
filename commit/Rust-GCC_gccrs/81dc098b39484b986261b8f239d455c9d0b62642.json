{"sha": "81dc098b39484b986261b8f239d455c9d0b62642", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFkYzA5OGIzOTQ4NGI5ODYyNjFiOGYyMzlkNDU1YzlkMGI2MjY0Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@wasabisystems.com", "date": "2003-11-26T23:33:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2003-11-26T23:33:05Z"}, "message": "cp-demangle.c (struct d_print_mod): Add templates field.\n\n\t* cp-demangle.c (struct d_print_mod): Add templates field.\n\t(d_make_builtin_type): Check for NULL type.\n\t(d_make_extended_operator): Check for NULL name.\n\t(d_make_ctor, d_make_dtor): Likewise.\n\t(d_mangled_name): Add top_level parameter.  Change all callers.\n\t(d_encoding): If DMGL_PARAMS is not set, strip off initial\n\tCV-qualifiers.\n\t(d_type): Check some return values we rely on.\n\t(d_bare_function_type, d_array_type): Likewise.\n\t(d_pointer_to_member_type, d_template_args): Likewise.\n\t(d_add_substitution): Fail if argument is NULL.\n\t(d_print_resize): Check whether buf is NULL.\n\t(d_print_comp): Save current templates list with each modifier.\n\tDon't pass the modifier list down when printing a template.\n\t(d_print_cast): Don't pass the modifier list down when printing a\n\ttemplate.\n\t(d_print_mod_list): Temporarily set templates list while printing\n\ta modifier.\n\t(d_print_mod): Check that buf is not NULL before using it.\n\t(d_print_function_type): Print parens if there is no modifier.\n\t(d_init_info): Permit as many substitutions as there are\n\tcharacters in the mangled name.\n\t* testsuite/demangle-expected: Add two new test cases.\n\nFrom-SVN: r73970", "tree": {"sha": "95205da54408be1cfef383f01ef800b7b65396ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95205da54408be1cfef383f01ef800b7b65396ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81dc098b39484b986261b8f239d455c9d0b62642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81dc098b39484b986261b8f239d455c9d0b62642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81dc098b39484b986261b8f239d455c9d0b62642", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81dc098b39484b986261b8f239d455c9d0b62642/comments", "author": null, "committer": null, "parents": [{"sha": "48f499cf81387cc10cc5045519b1bab9ccf40d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f499cf81387cc10cc5045519b1bab9ccf40d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48f499cf81387cc10cc5045519b1bab9ccf40d83"}], "stats": {"total": 247, "additions": 176, "deletions": 71}, "files": [{"sha": "2f5f7b5297307a1129191bf0c973a84aa83f041f", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81dc098b39484b986261b8f239d455c9d0b62642/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81dc098b39484b986261b8f239d455c9d0b62642/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=81dc098b39484b986261b8f239d455c9d0b62642", "patch": "@@ -1,3 +1,29 @@\n+2003-11-26  Ian Lance Taylor  <ian@wasabisystems.com>\n+\n+\t* cp-demangle.c (struct d_print_mod): Add templates field.\n+\t(d_make_builtin_type): Check for NULL type.\n+\t(d_make_extended_operator): Check for NULL name.\n+\t(d_make_ctor, d_make_dtor): Likewise.\n+\t(d_mangled_name): Add top_level parameter.  Change all callers.\n+\t(d_encoding): If DMGL_PARAMS is not set, strip off initial\n+\tCV-qualifiers.\n+\t(d_type): Check some return values we rely on.\n+\t(d_bare_function_type, d_array_type): Likewise.\n+\t(d_pointer_to_member_type, d_template_args): Likewise.\n+\t(d_add_substitution): Fail if argument is NULL.\n+\t(d_print_resize): Check whether buf is NULL.\n+\t(d_print_comp): Save current templates list with each modifier.\n+\tDon't pass the modifier list down when printing a template.\n+\t(d_print_cast): Don't pass the modifier list down when printing a\n+\ttemplate.\n+\t(d_print_mod_list): Temporarily set templates list while printing\n+\ta modifier.\n+\t(d_print_mod): Check that buf is not NULL before using it.\n+\t(d_print_function_type): Print parens if there is no modifier.\n+\t(d_init_info): Permit as many substitutions as there are\n+\tcharacters in the mangled name.\n+\t* testsuite/demangle-expected: Add two new test cases.\n+\n 2003-11-25  Ian Lance Taylor  <ian@wasabisystems.com>\n \n \t* cp-demangle.c (java_demangle_v3): Pass DMGL_PARAMS to"}, {"sha": "bd67958410b517e3bd8235a834bb6a117c9cbe81", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 142, "deletions": 71, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81dc098b39484b986261b8f239d455c9d0b62642/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81dc098b39484b986261b8f239d455c9d0b62642/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=81dc098b39484b986261b8f239d455c9d0b62642", "patch": "@@ -331,6 +331,8 @@ struct d_print_mod\n   const struct d_comp *mod;\n   /* Whether this modifier was printed.  */\n   int printed;\n+  /* The list of templates which applies to this modifier.  */\n+  struct d_print_template *templates;\n };\n \n /* We use this structure to hold information during printing.  */\n@@ -411,7 +413,7 @@ static struct d_comp *d_make_dtor PARAMS ((struct d_info *,\n \t\t\t\t\t   struct d_comp *));\n static struct d_comp *d_make_template_param PARAMS ((struct d_info *, long));\n static struct d_comp *d_make_sub PARAMS ((struct d_info *, const char *));\n-static struct d_comp *d_mangled_name PARAMS ((struct d_info *));\n+static struct d_comp *d_mangled_name PARAMS ((struct d_info *, int));\n static int has_return_type PARAMS ((struct d_comp *));\n static int is_ctor_dtor_or_conversion PARAMS ((struct d_comp *));\n static struct d_comp *d_encoding PARAMS ((struct d_info *, int));\n@@ -664,7 +666,8 @@ d_make_comp (di, type, left, right)\n   struct d_comp *p;\n \n   /* We check for errors here.  A typical error would be a NULL return\n-     from a subroutine.  We catch here, and return NULL on upward.  */\n+     from a subroutine.  We catch those here, and return NULL\n+     upward.  */\n   switch (type)\n     {\n       /* These types require two parameters.  */\n@@ -766,6 +769,8 @@ d_make_builtin_type (di, type)\n {\n   struct d_comp *p;\n \n+  if (type == NULL)\n+    return NULL;\n   p = d_make_empty (di, D_COMP_BUILTIN_TYPE);\n   if (p != NULL)\n     p->u.s_builtin.type = type;\n@@ -797,6 +802,8 @@ d_make_extended_operator (di, args, name)\n {\n   struct d_comp *p;\n \n+  if (name == NULL)\n+    return NULL;\n   p = d_make_empty (di, D_COMP_EXTENDED_OPERATOR);\n   if (p != NULL)\n     {\n@@ -816,6 +823,8 @@ d_make_ctor (di, kind,  name)\n {\n   struct d_comp *p;\n \n+  if (name == NULL)\n+    return NULL;\n   p = d_make_empty (di, D_COMP_CTOR);\n   if (p != NULL)\n     {\n@@ -835,6 +844,8 @@ d_make_dtor (di, kind, name)\n {\n   struct d_comp *p;\n \n+  if (name == NULL)\n+    return NULL;\n   p = d_make_empty (di, D_COMP_DTOR);\n   if (p != NULL)\n     {\n@@ -874,17 +885,20 @@ d_make_sub (di, name)\n   return p;\n }\n \n-/* <mangled-name> ::= _Z <encoding> */\n+/* <mangled-name> ::= _Z <encoding>\n+\n+   TOP_LEVEL is non-zero when called at the top level.  */\n \n static struct d_comp *\n-d_mangled_name (di)\n+d_mangled_name (di, top_level)\n      struct d_info *di;\n+     int top_level;\n {\n   if (d_next_char (di) != '_')\n     return NULL;\n   if (d_next_char (di) != 'Z')\n     return NULL;\n-  return d_encoding (di, 1);\n+  return d_encoding (di, top_level);\n }\n \n /* Return whether a function should have a return type.  The argument\n@@ -961,10 +975,21 @@ d_encoding (di, top_level)\n       struct d_comp *dc;\n \n       dc = d_name (di);\n+\n+      if (dc != NULL && top_level && (di->options & DMGL_PARAMS) == 0)\n+\t{\n+\t  /* Strip off any initial CV-qualifiers, as they really apply\n+\t     to the `this' parameter, and they were not output by the\n+\t     v2 demangler without DMGL_PARAMS.  */\n+\t  while (dc->type == D_COMP_RESTRICT\n+\t\t || dc->type == D_COMP_VOLATILE\n+\t\t || dc->type == D_COMP_CONST)\n+\t    dc = d_left (dc);\n+\t  return dc;\n+\t}\n+\n       peek = d_peek_char (di);\n-      if (peek == '\\0'\n-\t  || peek == 'E'\n-\t  || (top_level && (di->options & DMGL_PARAMS) == 0))\n+      if (peek == '\\0' || peek == 'E')\n \treturn dc;\n       return d_make_comp (di, D_COMP_TYPED_NAME, dc,\n \t\t\t  d_bare_function_type (di, has_return_type (dc)));\n@@ -1610,16 +1635,22 @@ d_type (di)\n      CV-qualifiers would cause subsets to be substitutable, so instead\n      we pull them all off now.\n \n-     FIXME: The ABI specifies that vendor qualifiers are handled just\n-     like the standard CV-qualifiers with respect to subsetting and\n-     substitution, but g++ does not appear to work this way.  */\n+     FIXME: The ABI says that order-insensitive vendor qualifiers\n+     should be handled in the same way, but we have no way to tell\n+     which vendor qualifiers are order-insensitive and which are\n+     order-sensitive.  So we just assume that they are all\n+     order-sensitive.  g++ 3.4 supports only one vendor qualifier,\n+     __vector, and it treats it as order-sensitive when mangling\n+     names.  */\n \n   peek = d_peek_char (di);\n   if (peek == 'r' || peek == 'V' || peek == 'K')\n     {\n       struct d_comp **pret;\n \n       pret = d_cv_qualifiers (di, &ret);\n+      if (pret == NULL)\n+\treturn NULL;\n       *pret = d_type (di);\n       if (! d_add_substitution (di, ret))\n \treturn NULL;\n@@ -1703,7 +1734,7 @@ d_type (di)\n \t       a new substitution candidate.  However, if the\n \t       substitution was followed by template arguments, then\n \t       the whole thing is a substitution candidate.  */\n-\t    if (ret->type == D_COMP_SUB_STD)\n+\t    if (ret != NULL && ret->type == D_COMP_SUB_STD)\n \t      can_subst = 0;\n \t  }\n       }\n@@ -1836,6 +1867,8 @@ d_bare_function_type (di, has_return_type)\n       else\n \t{\n \t  *ptl = d_make_comp (di, D_COMP_ARGLIST, type, NULL);\n+\t  if (*ptl == NULL)\n+\t    return NULL;\n \t  ptl = &d_right (*ptl);\n \t}\n     }\n@@ -1893,6 +1926,8 @@ d_array_type (di)\n \t}\n       while (IS_DIGIT (peek));\n       dim = d_make_name (di, s, d_str (di) - s);\n+      if (dim == NULL)\n+\treturn NULL;\n     }\n   else\n     {\n@@ -1936,6 +1971,8 @@ d_pointer_to_member_type (di)\n      avoid calling add_substitution() in d_type().  */\n \n   pmem = d_cv_qualifiers (di, &mem);\n+  if (pmem == NULL)\n+    return NULL;\n   *pmem = d_type (di);\n \n   return d_make_comp (di, D_COMP_PTRMEM_TYPE, cl, mem);\n@@ -1999,6 +2036,8 @@ d_template_args (di)\n \treturn NULL;\n \n       *pal = d_make_comp (di, D_COMP_TEMPLATE_ARGLIST, a, NULL);\n+      if (*pal == NULL)\n+\treturn NULL;\n       pal = &d_right (*pal);\n \n       if (d_peek_char (di) == 'E')\n@@ -2152,7 +2191,7 @@ d_expr_primary (di)\n   if (d_next_char (di) != 'L')\n     return NULL;\n   if (d_peek_char (di) == '_')\n-    ret = d_mangled_name (di);\n+    ret = d_mangled_name (di, 0);\n   else\n     {\n       struct d_comp *type;\n@@ -2247,6 +2286,8 @@ d_add_substitution (di, dc)\n      struct d_info *di;\n      struct d_comp *dc;\n {\n+  if (dc == NULL)\n+    return 0;\n   if (di->next_sub >= di->num_subs)\n     return 0;\n   di->subs[di->next_sub] = dc;\n@@ -2341,6 +2382,8 @@ d_print_resize (dpi, add)\n {\n   size_t need;\n \n+  if (dpi->buf == NULL)\n+    return;\n   need = dpi->len + add;\n   while (need > dpi->alc)\n     {\n@@ -2505,6 +2548,7 @@ d_print_comp (dpi, dc)\n \tdpi->modifiers = &dpm;\n \tdpm.mod = typed_name;\n \tdpm.printed = 0;\n+\tdpm.templates = dpi->templates;\n \n \t/* If typed_name is a template, then it applies to the\n \t   function type as well.  */\n@@ -2545,15 +2589,29 @@ d_print_comp (dpi, dc)\n       }\n \n     case D_COMP_TEMPLATE:\n-      d_print_comp (dpi, d_left (dc));\n-      d_append_char (dpi, '<');\n-      d_print_comp (dpi, d_right (dc));\n-      /* Avoid generating two consecutive '>' characters, to avoid the\n-\t C++ syntactic ambiguity.  */\n-      if (dpi->buf[dpi->len - 1] == '>')\n-\td_append_char (dpi, ' ');\n-      d_append_char (dpi, '>');\n-      return;\n+      {\n+\tstruct d_print_mod *hold_dpm;\n+\n+\t/* Don't push modifiers into a template definition.  Doing so\n+\t   could give the wrong definition for a template argument.\n+\t   Instead, treat the template essentially as a name.  */\n+\n+\thold_dpm = dpi->modifiers;\n+\tdpi->modifiers = NULL;\n+\n+\td_print_comp (dpi, d_left (dc));\n+\td_append_char (dpi, '<');\n+\td_print_comp (dpi, d_right (dc));\n+\t/* Avoid generating two consecutive '>' characters, to avoid\n+\t   the C++ syntactic ambiguity.  */\n+\tif (dpi->buf != NULL && dpi->buf[dpi->len - 1] == '>')\n+\t  d_append_char (dpi, ' ');\n+\td_append_char (dpi, '>');\n+\n+\tdpi->modifiers = hold_dpm;\n+\n+\treturn;\n+      }\n \n     case D_COMP_TEMPLATE_PARAM:\n       {\n@@ -2692,6 +2750,7 @@ d_print_comp (dpi, dc)\n \tdpi->modifiers = &dpm;\n \tdpm.mod = dc;\n \tdpm.printed = 0;\n+\tdpm.templates = dpi->templates;\n \n \td_print_comp (dpi, d_left (dc));\n \n@@ -2729,6 +2788,7 @@ d_print_comp (dpi, dc)\n \t    dpi->modifiers = &dpm;\n \t    dpm.mod = dc;\n \t    dpm.printed = 0;\n+\t    dpm.templates = dpi->templates;\n \n \t    d_print_comp (dpi, d_left (dc));\n \n@@ -2756,6 +2816,7 @@ d_print_comp (dpi, dc)\n \tdpi->modifiers = &dpm;\n \tdpm.mod = dc;\n \tdpm.printed = 0;\n+\tdpm.templates = dpi->templates;\n \n \td_print_comp (dpi, d_right (dc));\n \n@@ -2789,6 +2850,7 @@ d_print_comp (dpi, dc)\n \tdpi->modifiers = &dpm;\n \tdpm.mod = dc;\n \tdpm.printed = 0;\n+\tdpm.templates = dpi->templates;\n \n \td_print_comp (dpi, target_type);\n \n@@ -3035,29 +3097,36 @@ d_print_mod_list (dpi, mods)\n      struct d_print_info *dpi;\n      struct d_print_mod *mods;\n {\n+  struct d_print_template *hold_dpt;\n+\n   if (mods == NULL || mods->printed || d_print_saw_error (dpi))\n     return;\n \n+  mods->printed = 1;\n+\n+  hold_dpt = dpi->templates;\n+  dpi->templates = mods->templates;\n+\n   if (mods->mod->type == D_COMP_FUNCTION_TYPE)\n     {\n-      mods->printed = 1;\n       d_print_function_type (dpi, mods->mod, mods->next);\n+      dpi->templates = hold_dpt;\n       return;\n     }\n   else if (mods->mod->type == D_COMP_ARRAY_TYPE)\n     {\n-      mods->printed = 1;\n       d_print_array_type (dpi, mods->mod, mods->next);\n+      dpi->templates = hold_dpt;\n       return;\n     }\n \n-  mods->printed = 1;\n-\n   d_print_mod (dpi, mods->mod);\n \n+  dpi->templates = hold_dpt;\n+\n   d_print_mod_list (dpi, mods->next);\n }\n- \n+\n /* Print a modifier.  */\n \n static void\n@@ -3095,7 +3164,7 @@ d_print_mod (dpi, mod)\n       d_append_string (dpi, \"imaginary \");\n       return;\n     case D_COMP_PTRMEM_TYPE:\n-      if (dpi->buf[dpi->len - 1] != '(')\n+      if (dpi->buf != NULL && dpi->buf[dpi->len - 1] != '(')\n \td_append_char (dpi, ' ');\n       d_print_comp (dpi, d_left (mod));\n       d_append_string (dpi, \"::*\");\n@@ -3119,51 +3188,48 @@ d_print_function_type (dpi, dc, mods)\n      const struct d_comp *dc;\n      struct d_print_mod *mods;\n {\n-  if (mods != NULL)\n+  int need_paren;\n+  int saw_mod;\n+  struct d_print_mod *p;\n+\n+  need_paren = 0;\n+  saw_mod = 0;\n+  for (p = mods; p != NULL; p = p->next)\n     {\n-      int need_paren;\n-      int saw_mod;\n-      struct d_print_mod *p;\n+      if (p->printed)\n+\tbreak;\n \n-      need_paren = 0;\n-      saw_mod = 0;\n-      for (p = mods; p != NULL; p = p->next)\n+      saw_mod = 1;\n+      switch (p->mod->type)\n \t{\n-\t  if (p->printed)\n-\t    break;\n-\n-\t  saw_mod = 1;\n-\t  switch (p->mod->type)\n-\t    {\n-\t    case D_COMP_RESTRICT:\n-\t    case D_COMP_VOLATILE:\n-\t    case D_COMP_CONST:\n-\t    case D_COMP_VENDOR_TYPE_QUAL:\n-\t    case D_COMP_POINTER:\n-\t    case D_COMP_REFERENCE:\n-\t    case D_COMP_COMPLEX:\n-\t    case D_COMP_IMAGINARY:\n-\t    case D_COMP_PTRMEM_TYPE:\n-\t      need_paren = 1;\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t  if (need_paren)\n-\t    break;\n+\tcase D_COMP_RESTRICT:\n+\tcase D_COMP_VOLATILE:\n+\tcase D_COMP_CONST:\n+\tcase D_COMP_VENDOR_TYPE_QUAL:\n+\tcase D_COMP_POINTER:\n+\tcase D_COMP_REFERENCE:\n+\tcase D_COMP_COMPLEX:\n+\tcase D_COMP_IMAGINARY:\n+\tcase D_COMP_PTRMEM_TYPE:\n+\t  need_paren = 1;\n+\t  break;\n+\tdefault:\n+\t  break;\n \t}\n+      if (need_paren)\n+\tbreak;\n+    }\n \n-      if (d_left (dc) != NULL && ! saw_mod)\n-\tneed_paren = 1;\n+  if (d_left (dc) != NULL && ! saw_mod)\n+    need_paren = 1;\n \n-      if (need_paren)\n-\td_append_char (dpi, '(');\n+  if (need_paren)\n+    d_append_char (dpi, '(');\n \n-      d_print_mod_list (dpi, mods);\n+  d_print_mod_list (dpi, mods);\n \n-      if (need_paren)\n-\td_append_char (dpi, ')');\n-    }\n+  if (need_paren)\n+    d_append_char (dpi, ')');\n \n   d_append_char (dpi, '(');\n \n@@ -3252,13 +3318,17 @@ d_print_cast (dpi, dc)\n     d_print_comp (dpi, d_left (dc));\n   else\n     {\n+      struct d_print_mod *hold_dpm;\n       struct d_print_template dpt;\n \n       /* It appears that for a templated cast operator, we need to put\n \t the template parameters in scope for the operator name, but\n \t not for the parameters.  The effect is that we need to handle\n \t the template printing here.  FIXME: Verify this.  */\n \n+      hold_dpm = dpi->modifiers;\n+      dpi->modifiers = NULL;\n+\n       dpt.next = dpi->templates;\n       dpi->templates = &dpt;\n       dpt.template = d_left (dc);\n@@ -3271,9 +3341,11 @@ d_print_cast (dpi, dc)\n       d_print_comp (dpi, d_right (d_left (dc)));\n       /* Avoid generating two consecutive '>' characters, to avoid\n \t the C++ syntactic ambiguity.  */\n-      if (dpi->buf[dpi->len - 1] == '>')\n+      if (dpi->buf != NULL && dpi->buf[dpi->len - 1] == '>')\n \td_append_char (dpi, ' ');\n       d_append_char (dpi, '>');\n+\n+      dpi->modifiers = hold_dpm;\n     }\n }\n \n@@ -3301,9 +3373,8 @@ d_init_info (mangled, options, len, di)\n   di->next_comp = 0;\n \n   /* Similarly, we can not need more substitutions than there are\n-     chars in the mangled string divided by 2, since it takes at least\n-     two chars to refer to a substitution.  */\n-  di->num_subs = (len + 1) / 2;\n+     chars in the mangled string.  */\n+  di->num_subs = len;\n   di->subs = (struct d_comp **) malloc (di->num_subs\n \t\t\t\t\t* sizeof (struct d_comp *));\n   di->next_sub = 0;\n@@ -3381,7 +3452,7 @@ d_demangle (mangled, options, palc)\n     }\n \n   if (! type)\n-    dc = d_mangled_name (&di);\n+    dc = d_mangled_name (&di, 1);\n   else\n     dc = d_type (&di);\n \n@@ -3584,7 +3655,7 @@ is_ctor_or_dtor (mangled, ctor_kind, dtor_kind)\n   if (! d_init_info (mangled, DMGL_GNU_V3, strlen (mangled), &di))\n     return 0;\n \n-  dc = d_mangled_name (&di);\n+  dc = d_mangled_name (&di, 1);\n \n   if (dc == NULL)\n     return 0;"}, {"sha": "bfe9253b054a9efa233d42f573fba4fcba2fb01f", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81dc098b39484b986261b8f239d455c9d0b62642/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81dc098b39484b986261b8f239d455c9d0b62642/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=81dc098b39484b986261b8f239d455c9d0b62642", "patch": "@@ -2879,6 +2879,14 @@ void f<1>(A<(1) + (((int)(-((float)3f800000))))>)\n _ZNK11__gnu_debug16_Error_formatter14_M_format_wordImEEvPciPKcT_\n void __gnu_debug::_Error_formatter::_M_format_word<unsigned long>(char*, int, char const*, unsigned long) const\n #\n+# The new demangler used to core dump on this.\n+--format=gnu-v3\n+_ZSt18uninitialized_copyIN9__gnu_cxx17__normal_iteratorIPSt4pairISsPFbP6sqlitePPcEESt6vectorIS9_SaIS9_EEEESE_ET0_T_SG_SF_\n+__gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > > std::uninitialized_copy<__gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > >, __gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > > >(__gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > >, __gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > >, __gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > >)\n+# The new demangler used to fail on this.\n+--format=gnu-v3\n+_Z1fP1cIPFiiEE\n+f(c<int (*)(int)>*)\n # \n # This caused an infinite loop.\n # We still don't demangle this correctly, but at least we don't hang."}]}