{"sha": "3c2df916689b1c1d7a336451355fde085123b6d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MyZGY5MTY2ODliMWMxZDdhMzM2NDUxMzU1ZmRlMDg1MTIzYjZkNQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2019-02-01T02:39:52Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2019-02-01T02:39:52Z"}, "message": "re PR tree-optimization/88932 (ICE: verify_ssa failed (Error: definition in block 29 does not dominate use in block 25))\n\n\tPR tree-optimization/88932\n\t* tree-predcom.c (try_combine_chains): Get loop bbs in dom order.\n\n\tgcc/testsuite\n\t* gfortran.dg/pr88932.f90: New test.\n\nFrom-SVN: r268439", "tree": {"sha": "2a9c8be2feb3ee652f14a28c5f0ca5a28c550e15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a9c8be2feb3ee652f14a28c5f0ca5a28c550e15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c2df916689b1c1d7a336451355fde085123b6d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2df916689b1c1d7a336451355fde085123b6d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2df916689b1c1d7a336451355fde085123b6d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2df916689b1c1d7a336451355fde085123b6d5/comments", "author": null, "committer": null, "parents": [{"sha": "e9fa2f6ded6a0d7aeb43a0818930d73704626cc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9fa2f6ded6a0d7aeb43a0818930d73704626cc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9fa2f6ded6a0d7aeb43a0818930d73704626cc7"}], "stats": {"total": 155, "additions": 154, "deletions": 1}, "files": [{"sha": "d4ee2a2754c644387bb935381331d43bd5240a11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2df916689b1c1d7a336451355fde085123b6d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2df916689b1c1d7a336451355fde085123b6d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c2df916689b1c1d7a336451355fde085123b6d5", "patch": "@@ -1,3 +1,8 @@\n+2019-02-01  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\tPR tree-optimization/88932\n+\t* tree-predcom.c (try_combine_chains): Get loop bbs in dom order.\n+\n 2019-01-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/89137"}, {"sha": "2bf2433529c7351119365d85039dfa3257a45906", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2df916689b1c1d7a336451355fde085123b6d5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2df916689b1c1d7a336451355fde085123b6d5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c2df916689b1c1d7a336451355fde085123b6d5", "patch": "@@ -1,3 +1,8 @@\n+2018-02-01  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\tPR tree-optimization/88932\n+\t* gfortran.dg/pr88932.f90: New test.\n+\n 2019-01-31  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/88983 - ICE with switch in constexpr function."}, {"sha": "dc3a51b710a2625beb09003767466c141f8364cc", "filename": "gcc/testsuite/gfortran.dg/pr88932.f90", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2df916689b1c1d7a336451355fde085123b6d5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr88932.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2df916689b1c1d7a336451355fde085123b6d5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr88932.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr88932.f90?ref=3c2df916689b1c1d7a336451355fde085123b6d5", "patch": "@@ -0,0 +1,143 @@\n+! { dg-do compile }\n+! { dg-options \"-O1 -fpredictive-commoning -fno-tree-ch -fno-tree-dominator-opts -fno-tree-fre\" }\n+!\n+! PR tree-optimization/88932\n+!\n+\n+implicit none\n+\n+interface\n+  subroutine check_value(b, n, val)\n+    integer :: b(..)\n+    integer, value :: n\n+    integer :: val(n)\n+  end subroutine\n+end interface\n+\n+integer, target :: x(2:5,4:7), y(-4:4)\n+integer, allocatable, target :: z(:,:,:,:)\n+integer, allocatable :: val(:)\n+integer :: i\n+\n+allocate(z(1:4, -2:5, 4, 10:11))\n+\n+if (rank(x) /= 2) STOP 1\n+val = [(2*i+3, i = 1, size(x))]\n+x = reshape (val, shape(x))\n+call foo(x, rank(x), lbound(x), ubound(x), val)\n+call foo2(x, rank(x), lbound(x), ubound(x), val)\n+call bar(x,x,.true.)\n+call bar(x,prsnt=.false.)\n+\n+if (rank(y) /= 1) STOP 2\n+val = [(2*i+7, i = 1, size(y))]\n+y = reshape (val, shape(y))\n+call foo(y, rank(y), lbound(y), ubound(y), val)\n+call foo2(y, rank(y), lbound(y), ubound(y), val)\n+call bar(y,y,.true.)\n+call bar(y,prsnt=.false.)\n+\n+if (rank(z) /= 4) STOP 3\n+val = [(2*i+5, i = 1, size(z))]\n+z(:,:,:,:) = reshape (val, shape(z))\n+call foo(z, rank(z), lbound(z), ubound(z), val)\n+call foo(z, rank(z), lbound(z), ubound(z), val)\n+call foo2(z, rank(z), lbound(z), ubound(z), val)\n+call bar(z,z,.true.)\n+call bar(z,prsnt=.false.)\n+\n+contains\n+  subroutine bar(a,b, prsnt)\n+    integer, pointer, optional, intent(in) :: a(..),b(..)\n+    logical, value :: prsnt\n+    if (.not. associated(a)) STOP 4\n+    if (present(b)) then\n+       ! The following is not valid.\n+       ! Technically, it could be allowed and might be in Fortran 2015:\n+       ! if (.not. associated(a,b)) STOP 5\n+    else\n+      if (.not. associated(a)) STOP 6\n+    end if\n+    if (.not. present(a)) STOP 7\n+    if (prsnt .neqv. present(b)) STOP 8\n+  end subroutine\n+\n+  ! POINTER argument - bounds as specified before\n+  subroutine foo(a, rnk, low, high, val)\n+    integer,pointer, intent(in) :: a(..)\n+    integer, value :: rnk\n+    integer, intent(in) :: low(:), high(:), val(:)\n+    integer :: i\n+\n+\n+\n+    if (rank(a) /= rnk) STOP 9\n+    if (size(low) /= rnk .or. size(high) /= rnk) STOP 10\n+    if (size(a) /= product (high - low +1)) STOP 11\n+\n+    if (rnk > 0) then\n+      if (low(1) /= lbound(a,1)) STOP 12\n+      if (high(1) /= ubound(a,1)) STOP 13\n+      if (size (a,1) /= high(1)-low(1)+1) STOP 14\n+    end if\n+\n+    do i = 1, rnk\n+      if (low(i) /= lbound(a,i)) STOP 15\n+      if (high(i) /= ubound(a,i)) STOP 16\n+      if (size (a,i) /= high(i)-low(i)+1) STOP 17\n+    end do\n+    call check_value (a, rnk, val)\n+    call foo2(a, rnk, low, high, val)\n+  end subroutine\n+\n+  ! Non-pointer, non-allocatable bounds. lbound == 1\n+  subroutine foo2(a, rnk, low, high, val)\n+    integer, intent(in) :: a(..)\n+    integer, value :: rnk\n+    integer, intent(in) :: low(:), high(:), val(:)\n+    integer :: i\n+\n+    if (rank(a) /= rnk) STOP 18\n+    if (size(low) /= rnk .or. size(high) /= rnk) STOP 19\n+    if (size(a) /= product (high - low +1)) STOP 20\n+\n+    if (rnk > 0) then\n+      if (1 /= lbound(a,1)) STOP 21\n+      if (high(1)-low(1)+1 /= ubound(a,1)) STOP 22\n+      if (size (a,1) /= high(1)-low(1)+1) STOP 23\n+    end if\n+\n+    do i = 1, rnk\n+      if (1 /= lbound(a,i)) STOP 24\n+      if (high(i)-low(i)+1 /= ubound(a,i)) STOP 25\n+      if (size (a,i) /= high(i)-low(i)+1) STOP 26\n+    end do\n+    call check_value (a, rnk, val)\n+  end subroutine foo2\n+\n+  ! ALLOCATABLE argument - bounds as specified before\n+  subroutine foo3 (a, rnk, low, high, val)\n+    integer, allocatable, intent(in), target :: a(..)\n+    integer, value :: rnk\n+    integer, intent(in) :: low(:), high(:), val(:)\n+    integer :: i\n+\n+    if (rank(a) /= rnk) STOP 27\n+    if (size(low) /= rnk .or. size(high) /= rnk) STOP 28\n+    if (size(a) /= product (high - low +1)) STOP 29\n+\n+    if (rnk > 0) then\n+      if (low(1) /= lbound(a,1)) STOP 30\n+      if (high(1) /= ubound(a,1)) STOP 31\n+      if (size (a,1) /= high(1)-low(1)+1) STOP 32\n+    end if\n+\n+    do i = 1, rnk\n+      if (low(i) /= lbound(a,i)) STOP 33\n+      if (high(i) /= ubound(a,i)) STOP 34\n+      if (size (a,i) /= high(i)-low(i)+1) STOP 35\n+    end do\n+    call check_value (a, rnk, val)\n+    call foo(a, rnk, low, high, val)\n+  end subroutine\n+end"}, {"sha": "1870645d66da5e8b5bdea79dba1b2aca7928e0fa", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2df916689b1c1d7a336451355fde085123b6d5/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2df916689b1c1d7a336451355fde085123b6d5/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=3c2df916689b1c1d7a336451355fde085123b6d5", "patch": "@@ -2836,7 +2836,7 @@ try_combine_chains (struct loop *loop, vec<chain_p> *chains)\n     return;\n \n   /* Setup UID for all statements in dominance order.  */\n-  basic_block *bbs = get_loop_body (loop);\n+  basic_block *bbs = get_loop_body_in_dom_order (loop);\n   renumber_gimple_stmt_uids_in_blocks (bbs, loop->num_nodes);\n   free (bbs);\n "}]}