{"sha": "ceddf62caf3e2cb2feb0abc6005016d3bb4b1362", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VkZGY2MmNhZjNlMmNiMmZlYjBhYmM2MDA1MDE2ZDNiYjRiMTM2Mg==", "commit": {"author": {"name": "Sofiane Naci", "email": "sofiane.naci@arm.com", "date": "2010-08-10T13:37:25Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2010-08-10T13:37:25Z"}, "message": "iterators.md: New file.\n\n2010-08-09  Sofiane Naci  <sofiane.naci@arm.com>\n\n    * config/arm/iterators.md: New file.\n    * config/arm/arm.md: Include iterators.md.\n    (QHSI): Move to new file.\n    (LTUGEU, cnb, optab, ior_xor): Likewise.\n    * config/arm/iwmmxt.md (VMMX): Move to new file.\n    (VSHFT, MMX_char): Likewise.\n    * config/arm/neon.md (VD): Move to new file.\n    (VDX, VDI, VQ, VQX, VQI, VQXMOV, VSTRUCT, VTAB, V_TAB_n, VW): Likewise.\n    (VN, VDQ, VDQW, VDQIW, VCVTF, VCVTI, VMD, VMQ, VMDQ, VMDI): Likewise.\n    (VMDQI, VX, VE, V64, V32, V_CVTTO, V_elem, V_ext, V_two_elem): Likewise.\n    (V_three_elem, V_four_elem, V_req, V_widen, V_narrow, V_HALF): Likewise.\n    (V_half,V_DOUBLE, V_double, V_double_width, V_cmp_result): Likewise.\n    (V_if_elem, V_s_elem, V_u_elem, V_uf_sclr, V_sz_elem, VD_dup): Likewise.\n    (V_PAIR, vqh_ops, vqhs_ops, VQH_mnem, VQH_sign, V_suf64): Likewise.\n    (scalar_mul_constraint,Is_float_mode, Scalar_mul_8_16): Likewise.\n    (Is_d_reg, V_mode_nunits): Likewise.\n    * config/arm/vec-common.md (VALL): Move to new file.\n    (VALLW, VINT, VINTW): Likewise.\n\nFrom-SVN: r163058", "tree": {"sha": "ddf6c8bcc7ebd07f4878c25fe98b26fc45afff43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddf6c8bcc7ebd07f4878c25fe98b26fc45afff43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/comments", "author": null, "committer": null, "parents": [{"sha": "5466d63d2d89ccb46fbe2c0cd62d82c91c5d907b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5466d63d2d89ccb46fbe2c0cd62d82c91c5d907b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5466d63d2d89ccb46fbe2c0cd62d82c91c5d907b"}], "stats": {"total": 724, "additions": 399, "deletions": 325}, "files": [{"sha": "49d377b722d630006adac63e68aa4cbc797c937d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ceddf62caf3e2cb2feb0abc6005016d3bb4b1362", "patch": "@@ -1,3 +1,24 @@\n+2010-08-09  Sofiane Naci  <sofiane.naci@arm.com>\n+\n+    * config/arm/iterators.md: New file.\n+    * config/arm/arm.md: Include iterators.md.\n+    (QHSI): Move to new file.\n+    (LTUGEU, cnb, optab, ior_xor): Likewise.\n+    * config/arm/iwmmxt.md (VMMX): Move to new file.\n+    (VSHFT, MMX_char): Likewise.\n+    * config/arm/neon.md (VD): Move to new file.\n+    (VDX, VDI, VQ, VQX, VQI, VQXMOV, VSTRUCT, VTAB, V_TAB_n, VW): Likewise.\n+    (VN, VDQ, VDQW, VDQIW, VCVTF, VCVTI, VMD, VMQ, VMDQ, VMDI): Likewise.\n+    (VMDQI, VX, VE, V64, V32, V_CVTTO, V_elem, V_ext, V_two_elem): Likewise.\n+    (V_three_elem, V_four_elem, V_req, V_widen, V_narrow, V_HALF): Likewise.\n+    (V_half,V_DOUBLE, V_double, V_double_width, V_cmp_result): Likewise.\n+    (V_if_elem, V_s_elem, V_u_elem, V_uf_sclr, V_sz_elem, VD_dup): Likewise.\n+    (V_PAIR, vqh_ops, vqhs_ops, VQH_mnem, VQH_sign, V_suf64): Likewise.\n+    (scalar_mul_constraint,Is_float_mode, Scalar_mul_8_16): Likewise.\n+    (Is_d_reg, V_mode_nunits): Likewise.\n+    * config/arm/vec-common.md (VALL): Move to new file.\n+    (VALLW, VINT, VINTW): Likewise.\n+\n 2010-08-10  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR middle-end/45182"}, {"sha": "78b1710f8c8a31a814309419b74750d97284d281", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=ceddf62caf3e2cb2feb0abc6005016d3bb4b1362", "patch": "@@ -399,13 +399,7 @@\n ;;---------------------------------------------------------------------------\n ;; Mode iterators\n \n-; A list of modes that are exactly 64 bits in size.  We use this to expand\n-; some splits that are the same for all modes when operating on ARM \n-; registers.\n-(define_mode_iterator ANY64 [DI DF V8QI V4HI V2SI V2SF])\n-\n-;; The integer modes up to word size\n-(define_mode_iterator QHSI [QI HI SI])\n+(include \"iterators.md\")\n \n ;;---------------------------------------------------------------------------\n ;; Predicates\n@@ -866,10 +860,6 @@\n   [(set_attr \"conds\" \"set\")]\n )\n \n-(define_code_iterator LTUGEU [ltu geu])\n-(define_code_attr cnb [(ltu \"CC_C\") (geu \"CC\")])\n-(define_code_attr optab [(ltu \"ltu\") (geu \"geu\")])\n-\n (define_insn \"*addsi3_carryin_<optab>\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(plus:SI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"%r\")\n@@ -4258,7 +4248,6 @@\n   \"\"\n )\n \n-(define_code_iterator ior_xor [ior xor])\n \n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")"}, {"sha": "ee04aabebf2c6f4826f73861ec2e53dc7b9187dc", "filename": "gcc/config/arm/iterators.md", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=ceddf62caf3e2cb2feb0abc6005016d3bb4b1362", "patch": "@@ -0,0 +1,377 @@\n+;; Code and mode itertator and attribute definitions for the ARM backend\n+;; Copyright (C) 2010 Free Software Foundation, Inc.\n+;; Contributed by ARM Ltd.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+\n+;;----------------------------------------------------------------------------\n+;; Mode iterators\n+;;----------------------------------------------------------------------------\n+\n+;; A list of modes that are exactly 64 bits in size. This is used to expand\n+;; some splits that are the same for all modes when operating on ARM \n+;; registers.\n+(define_mode_iterator ANY64 [DI DF V8QI V4HI V2SI V2SF])\n+\n+;; A list of integer modes that are up to one word long\n+(define_mode_iterator QHSI [QI HI SI])\n+\n+;; Integer element sizes implemented by IWMMXT.\n+(define_mode_iterator VMMX [V2SI V4HI V8QI])\n+\n+;; Integer element sizes for shifts.\n+(define_mode_iterator VSHFT [V4HI V2SI DI])\n+\n+;; Integer and float modes supported by Neon and IWMMXT.\n+(define_mode_iterator VALL [V2DI V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n+\n+;; Integer and float modes supported by Neon and IWMMXT, except V2DI.\n+(define_mode_iterator VALLW [V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n+\n+;; Integer modes supported by Neon and IWMMXT\n+(define_mode_iterator VINT [V2DI V2SI V4HI V8QI V4SI V8HI V16QI])\n+\n+;; Integer modes supported by Neon and IWMMXT, except V2DI\n+(define_mode_iterator VINTW [V2SI V4HI V8QI V4SI V8HI V16QI])\n+\n+;; Double-width vector modes.\n+(define_mode_iterator VD [V8QI V4HI V2SI V2SF])\n+\n+;; Double-width vector modes plus 64-bit elements.\n+(define_mode_iterator VDX [V8QI V4HI V2SI V2SF DI])\n+\n+;; Double-width vector modes without floating-point elements.\n+(define_mode_iterator VDI [V8QI V4HI V2SI])\n+\n+;; Quad-width vector modes.\n+(define_mode_iterator VQ [V16QI V8HI V4SI V4SF])\n+\n+;; Quad-width vector modes plus 64-bit elements.\n+(define_mode_iterator VQX [V16QI V8HI V4SI V4SF V2DI])\n+\n+;; Quad-width vector modes without floating-point elements.\n+(define_mode_iterator VQI [V16QI V8HI V4SI])\n+\n+;; Quad-width vector modes, with TImode added, for moves.\n+(define_mode_iterator VQXMOV [V16QI V8HI V4SI V4SF V2DI TI])\n+\n+;; Opaque structure types wider than TImode.\n+(define_mode_iterator VSTRUCT [EI OI CI XI])\n+\n+;; Opaque structure types used in table lookups (except vtbl1/vtbx1).\n+(define_mode_iterator VTAB [TI EI OI])\n+\n+;; Widenable modes.\n+(define_mode_iterator VW [V8QI V4HI V2SI])\n+\n+;; Narrowable modes.\n+(define_mode_iterator VN [V8HI V4SI V2DI])\n+\n+;; All supported vector modes (except singleton DImode).\n+(define_mode_iterator VDQ [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF V2DI])\n+\n+;; All supported vector modes (except those with 64-bit integer elements).\n+(define_mode_iterator VDQW [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF])\n+\n+;; Supported integer vector modes (not 64 bit elements).\n+(define_mode_iterator VDQIW [V8QI V16QI V4HI V8HI V2SI V4SI])\n+\n+;; Supported integer vector modes (not singleton DI)\n+(define_mode_iterator VDQI [V8QI V16QI V4HI V8HI V2SI V4SI V2DI])\n+\n+;; Vector modes, including 64-bit integer elements.\n+(define_mode_iterator VDQX [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF DI V2DI])\n+\n+;; Vector modes including 64-bit integer elements, but no floats.\n+(define_mode_iterator VDQIX [V8QI V16QI V4HI V8HI V2SI V4SI DI V2DI])\n+\n+;; Vector modes for float->int conversions.\n+(define_mode_iterator VCVTF [V2SF V4SF])\n+\n+;; Vector modes form int->float conversions.\n+(define_mode_iterator VCVTI [V2SI V4SI])\n+\n+;; Vector modes for doubleword multiply-accumulate, etc. insns.\n+(define_mode_iterator VMD [V4HI V2SI V2SF])\n+\n+;; Vector modes for quadword multiply-accumulate, etc. insns.\n+(define_mode_iterator VMQ [V8HI V4SI V4SF])\n+\n+;; Above modes combined.\n+(define_mode_iterator VMDQ [V4HI V2SI V2SF V8HI V4SI V4SF])\n+\n+;; As VMD, but integer modes only.\n+(define_mode_iterator VMDI [V4HI V2SI])\n+\n+;; As VMQ, but integer modes only.\n+(define_mode_iterator VMQI [V8HI V4SI])\n+\n+;; Above modes combined.\n+(define_mode_iterator VMDQI [V4HI V2SI V8HI V4SI])\n+\n+;; Modes with 8-bit and 16-bit elements.\n+(define_mode_iterator VX [V8QI V4HI V16QI V8HI])\n+\n+;; Modes with 8-bit elements.\n+(define_mode_iterator VE [V8QI V16QI])\n+\n+;; Modes with 64-bit elements only.\n+(define_mode_iterator V64 [DI V2DI])\n+\n+;; Modes with 32-bit elements only.\n+(define_mode_iterator V32 [V2SI V2SF V4SI V4SF])\n+\n+\n+;;----------------------------------------------------------------------------\n+;; Code iterators\n+;;----------------------------------------------------------------------------\n+\n+;; A list of condition codes used in compare instructions where \n+;; the carry flag from the addition is used instead of doing the \n+;; compare a second time.\n+(define_code_iterator LTUGEU [ltu geu])\n+\n+;; A list of ...\n+(define_code_iterator ior_xor [ior xor])\n+\n+;; Operations on two halves of a quadword vector.\n+(define_code_iterator vqh_ops [plus smin smax umin umax])\n+\n+;; Operations on two halves of a quadword vector,\n+;; without unsigned variants (for use with *SFmode pattern).\n+(define_code_iterator vqhs_ops [plus smin smax])\n+\n+\n+;;----------------------------------------------------------------------------\n+;; Mode attributes\n+;;----------------------------------------------------------------------------\n+\n+;; Determine element size suffix from vector mode.\n+(define_mode_attr MMX_char [(V8QI \"b\") (V4HI \"h\") (V2SI \"w\") (DI \"d\")])\n+\n+;; vtbl<n> suffix for NEON vector modes.\n+(define_mode_attr VTAB_n [(TI \"2\") (EI \"3\") (OI \"4\")])\n+\n+;; (Opposite) mode to convert to/from for NEON mode conversions.\n+(define_mode_attr V_CVTTO [(V2SI \"V2SF\") (V2SF \"V2SI\")\n+               (V4SI \"V4SF\") (V4SF \"V4SI\")])\n+\n+;; Define element mode for each vector mode.\n+(define_mode_attr V_elem [(V8QI \"QI\") (V16QI \"QI\")\n+              (V4HI \"HI\") (V8HI \"HI\")\n+                          (V2SI \"SI\") (V4SI \"SI\")\n+                          (V2SF \"SF\") (V4SF \"SF\")\n+                          (DI \"DI\")   (V2DI \"DI\")])\n+\n+;; Element modes for vector extraction, padded up to register size.\n+\n+(define_mode_attr V_ext [(V8QI \"SI\") (V16QI \"SI\")\n+             (V4HI \"SI\") (V8HI \"SI\")\n+             (V2SI \"SI\") (V4SI \"SI\")\n+             (V2SF \"SF\") (V4SF \"SF\")\n+             (DI \"DI\") (V2DI \"DI\")])\n+\n+;; Mode of pair of elements for each vector mode, to define transfer\n+;; size for structure lane/dup loads and stores.\n+(define_mode_attr V_two_elem [(V8QI \"HI\") (V16QI \"HI\")\n+                  (V4HI \"SI\") (V8HI \"SI\")\n+                              (V2SI \"V2SI\") (V4SI \"V2SI\")\n+                              (V2SF \"V2SF\") (V4SF \"V2SF\")\n+                              (DI \"V2DI\")   (V2DI \"V2DI\")])\n+\n+;; Similar, for three elements.\n+;; ??? Should we define extra modes so that sizes of all three-element\n+;; accesses can be accurately represented?\n+(define_mode_attr V_three_elem [(V8QI \"SI\")   (V16QI \"SI\")\n+                    (V4HI \"V4HI\") (V8HI \"V4HI\")\n+                                (V2SI \"V4SI\") (V4SI \"V4SI\")\n+                                (V2SF \"V4SF\") (V4SF \"V4SF\")\n+                                (DI \"EI\")     (V2DI \"EI\")])\n+\n+;; Similar, for four elements.\n+(define_mode_attr V_four_elem [(V8QI \"SI\")   (V16QI \"SI\")\n+                   (V4HI \"V4HI\") (V8HI \"V4HI\")\n+                               (V2SI \"V4SI\") (V4SI \"V4SI\")\n+                               (V2SF \"V4SF\") (V4SF \"V4SF\")\n+                               (DI \"OI\")     (V2DI \"OI\")])\n+\n+;; Register width from element mode\n+(define_mode_attr V_reg [(V8QI \"P\") (V16QI \"q\")\n+                         (V4HI \"P\") (V8HI  \"q\")\n+                         (V2SI \"P\") (V4SI  \"q\")\n+                         (V2SF \"P\") (V4SF  \"q\")\n+                         (DI   \"P\") (V2DI  \"q\")])\n+\n+;; Wider modes with the same number of elements.\n+(define_mode_attr V_widen [(V8QI \"V8HI\") (V4HI \"V4SI\") (V2SI \"V2DI\")])\n+\n+;; Narrower modes with the same number of elements.\n+(define_mode_attr V_narrow [(V8HI \"V8QI\") (V4SI \"V4HI\") (V2DI \"V2SI\")])\n+\n+;; Modes with half the number of equal-sized elements.\n+(define_mode_attr V_HALF [(V16QI \"V8QI\") (V8HI \"V4HI\")\n+              (V4SI  \"V2SI\") (V4SF \"V2SF\")\n+                          (V2DI \"DI\")])\n+\n+;; Same, but lower-case.\n+(define_mode_attr V_half [(V16QI \"v8qi\") (V8HI \"v4hi\")\n+              (V4SI  \"v2si\") (V4SF \"v2sf\")\n+                          (V2DI \"di\")])\n+\n+;; Modes with twice the number of equal-sized elements.\n+(define_mode_attr V_DOUBLE [(V8QI \"V16QI\") (V4HI \"V8HI\")\n+                (V2SI \"V4SI\") (V2SF \"V4SF\")\n+                            (DI \"V2DI\")])\n+\n+;; Same, but lower-case.\n+(define_mode_attr V_double [(V8QI \"v16qi\") (V4HI \"v8hi\")\n+                (V2SI \"v4si\") (V2SF \"v4sf\")\n+                            (DI \"v2di\")])\n+\n+;; Modes with double-width elements.\n+(define_mode_attr V_double_width [(V8QI \"V4HI\") (V16QI \"V8HI\")\n+                  (V4HI \"V2SI\") (V8HI \"V4SI\")\n+                  (V2SI \"DI\")   (V4SI \"V2DI\")])\n+\n+;; Double-sized modes with the same element size.\n+;; Used for neon_vdup_lane, where the second operand is double-sized\n+;; even when the first one is quad.\n+(define_mode_attr V_double_vector_mode [(V16QI \"V8QI\") (V8HI \"V4HI\")\n+                                        (V4SI \"V2SI\") (V4SF \"V2SF\")\n+                                        (V8QI \"V8QI\") (V4HI \"V4HI\")\n+                                        (V2SI \"V2SI\") (V2SF \"V2SF\")])\n+\n+;; Mode of result of comparison operations (and bit-select operand 1).\n+(define_mode_attr V_cmp_result [(V8QI \"V8QI\") (V16QI \"V16QI\")\n+                    (V4HI \"V4HI\") (V8HI  \"V8HI\")\n+                                (V2SI \"V2SI\") (V4SI  \"V4SI\")\n+                                (V2SF \"V2SI\") (V4SF  \"V4SI\")\n+                                (DI   \"DI\")   (V2DI  \"V2DI\")])\n+\n+;; Get element type from double-width mode, for operations where we \n+;; don't care about signedness.\n+(define_mode_attr V_if_elem [(V8QI \"i8\")  (V16QI \"i8\")\n+                 (V4HI \"i16\") (V8HI  \"i16\")\n+                             (V2SI \"i32\") (V4SI  \"i32\")\n+                             (DI   \"i64\") (V2DI  \"i64\")\n+                 (V2SF \"f32\") (V4SF  \"f32\")])\n+\n+;; Same, but for operations which work on signed values.\n+(define_mode_attr V_s_elem [(V8QI \"s8\")  (V16QI \"s8\")\n+                (V4HI \"s16\") (V8HI  \"s16\")\n+                            (V2SI \"s32\") (V4SI  \"s32\")\n+                            (DI   \"s64\") (V2DI  \"s64\")\n+                (V2SF \"f32\") (V4SF  \"f32\")])\n+\n+;; Same, but for operations which work on unsigned values.\n+(define_mode_attr V_u_elem [(V8QI \"u8\")  (V16QI \"u8\")\n+                (V4HI \"u16\") (V8HI  \"u16\")\n+                            (V2SI \"u32\") (V4SI  \"u32\")\n+                            (DI   \"u64\") (V2DI  \"u64\")\n+                            (V2SF \"f32\") (V4SF  \"f32\")])\n+\n+;; Element types for extraction of unsigned scalars.\n+(define_mode_attr V_uf_sclr [(V8QI \"u8\")  (V16QI \"u8\")\n+                 (V4HI \"u16\") (V8HI \"u16\")\n+                             (V2SI \"32\") (V4SI \"32\")\n+                             (V2SF \"32\") (V4SF \"32\")])\n+\n+(define_mode_attr V_sz_elem [(V8QI \"8\")  (V16QI \"8\")\n+                 (V4HI \"16\") (V8HI  \"16\")\n+                             (V2SI \"32\") (V4SI  \"32\")\n+                             (DI   \"64\") (V2DI  \"64\")\n+                 (V2SF \"32\") (V4SF  \"32\")])\n+\n+;; Element sizes for duplicating ARM registers to all elements of a vector.\n+(define_mode_attr VD_dup [(V8QI \"8\") (V4HI \"16\") (V2SI \"32\") (V2SF \"32\")])\n+\n+;; Opaque integer types for results of pair-forming intrinsics (vtrn, etc.)\n+(define_mode_attr V_PAIR [(V8QI \"TI\") (V16QI \"OI\")\n+              (V4HI \"TI\") (V8HI  \"OI\")\n+                          (V2SI \"TI\") (V4SI  \"OI\")\n+                          (V2SF \"TI\") (V4SF  \"OI\")\n+                          (DI   \"TI\") (V2DI  \"OI\")])\n+\n+;; Same, but lower-case.\n+(define_mode_attr V_pair [(V8QI \"ti\") (V16QI \"oi\")\n+              (V4HI \"ti\") (V8HI  \"oi\")\n+                          (V2SI \"ti\") (V4SI  \"oi\")\n+                          (V2SF \"ti\") (V4SF  \"oi\")\n+                          (DI   \"ti\") (V2DI  \"oi\")])\n+\n+;; Extra suffix on some 64-bit insn names (to avoid collision with standard\n+;; names which we don't want to define).\n+(define_mode_attr V_suf64 [(V8QI \"\") (V16QI \"\")\n+                           (V4HI \"\") (V8HI \"\")\n+                           (V2SI \"\") (V4SI \"\")\n+                           (V2SF \"\") (V4SF \"\")\n+                           (DI \"_neon\") (V2DI \"\")])\n+\n+\n+;; Scalars to be presented to scalar multiplication instructions\n+;; must satisfy the following constraints.\n+;; 1. If the mode specifies 16-bit elements, the scalar must be in D0-D7.\n+;; 2. If the mode specifies 32-bit elements, the scalar must be in D0-D15.\n+\n+;; This mode attribute is used to obtain the correct register constraints.\n+\n+(define_mode_attr scalar_mul_constraint [(V4HI \"x\") (V2SI \"t\") (V2SF \"t\")\n+                                         (V8HI \"x\") (V4SI \"t\") (V4SF \"t\")])\n+\n+;; Predicates used for setting neon_type\n+\n+(define_mode_attr Is_float_mode [(V8QI \"false\") (V16QI \"false\")\n+                 (V4HI \"false\") (V8HI \"false\")\n+                 (V2SI \"false\") (V4SI \"false\")\n+                 (V2SF \"true\") (V4SF \"true\")\n+                 (DI \"false\") (V2DI \"false\")])\n+\n+(define_mode_attr Scalar_mul_8_16 [(V8QI \"true\") (V16QI \"true\")\n+                   (V4HI \"true\") (V8HI \"true\")\n+                   (V2SI \"false\") (V4SI \"false\")\n+                   (V2SF \"false\") (V4SF \"false\")\n+                   (DI \"false\") (V2DI \"false\")])\n+\n+\n+(define_mode_attr Is_d_reg [(V8QI \"true\") (V16QI \"false\")\n+                            (V4HI \"true\") (V8HI  \"false\")\n+                            (V2SI \"true\") (V4SI  \"false\")\n+                            (V2SF \"true\") (V4SF  \"false\")\n+                            (DI   \"true\") (V2DI  \"false\")])\n+\n+(define_mode_attr V_mode_nunits [(V8QI \"8\") (V16QI \"16\")\n+                                 (V4HI \"4\") (V8HI \"8\")\n+                                 (V2SI \"2\") (V4SI \"4\")\n+                                 (V2SF \"2\") (V4SF \"4\")\n+                                 (DI \"1\")   (V2DI \"2\")])\n+\n+\n+;;----------------------------------------------------------------------------\n+;; Code attributes\n+;;----------------------------------------------------------------------------\n+\n+;; Assembler mnemonics for vqh_ops and vqhs_ops iterators.\n+(define_code_attr VQH_mnem [(plus \"vadd\") (smin \"vmin\") (smax \"vmax\")\n+                (umin \"vmin\") (umax \"vmax\")])\n+\n+;; Signs of above, where relevant.\n+(define_code_attr VQH_sign [(plus \"i\") (smin \"s\") (smax \"s\") (umin \"u\")\n+                (umax \"u\")])\n+\n+(define_code_attr cnb [(ltu \"CC_C\") (geu \"CC\")])\n+(define_code_attr optab [(ltu \"ltu\") (geu \"geu\")])"}, {"sha": "9bfad728a2de352b7d20b60ae27be1e9e12f8e0b", "filename": "gcc/config/arm/iwmmxt.md", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiwmmxt.md?ref=ceddf62caf3e2cb2feb0abc6005016d3bb4b1362", "patch": "@@ -19,14 +19,6 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-;; Integer element sizes implemented by IWMMXT.\n-(define_mode_iterator VMMX [V2SI V4HI V8QI])\n-\n-;; Integer element sizes for shifts.\n-(define_mode_iterator VSHFT [V4HI V2SI DI])\n-\n-;; Determine element size suffix from vector mode.\n-(define_mode_attr MMX_char [(V8QI \"b\") (V4HI \"h\") (V2SI \"w\") (DI \"d\")])\n \n (define_insn \"iwmmxt_iordi3\"\n   [(set (match_operand:DI         0 \"register_operand\" \"=y,?&r,?&r\")"}, {"sha": "bdc279a92a50ad3718a20b69d857cc9c24d1c3c6", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 0, "deletions": 293, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=ceddf62caf3e2cb2feb0abc6005016d3bb4b1362", "patch": "@@ -142,304 +142,11 @@\n    (UNSPEC_VZIP1\t\t203)\n    (UNSPEC_VZIP2\t\t204)])\n \n-;; Double-width vector modes.\n-(define_mode_iterator VD [V8QI V4HI V2SI V2SF])\n-\n-;; Double-width vector modes plus 64-bit elements.\n-(define_mode_iterator VDX [V8QI V4HI V2SI V2SF DI])\n-\n-;; Same, without floating-point elements.\n-(define_mode_iterator VDI [V8QI V4HI V2SI])\n-\n-;; Quad-width vector modes.\n-(define_mode_iterator VQ [V16QI V8HI V4SI V4SF])\n-\n-;; Quad-width vector modes plus 64-bit elements.\n-(define_mode_iterator VQX [V16QI V8HI V4SI V4SF V2DI])\n-\n-;; Same, without floating-point elements.\n-(define_mode_iterator VQI [V16QI V8HI V4SI])\n-\n-;; Same, with TImode added, for moves.\n-(define_mode_iterator VQXMOV [V16QI V8HI V4SI V4SF V2DI TI])\n-\n-;; Opaque structure types wider than TImode.\n-(define_mode_iterator VSTRUCT [EI OI CI XI])\n-\n-;; Opaque structure types used in table lookups (except vtbl1/vtbx1).\n-(define_mode_iterator VTAB [TI EI OI])\n-\n-;; vtbl<n> suffix for above modes.\n-(define_mode_attr VTAB_n [(TI \"2\") (EI \"3\") (OI \"4\")])\n-\n-;; Widenable modes.\n-(define_mode_iterator VW [V8QI V4HI V2SI])\n-\n-;; Narrowable modes.\n-(define_mode_iterator VN [V8HI V4SI V2DI])\n-\n-;; All supported vector modes (except singleton DImode).\n-(define_mode_iterator VDQ [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF V2DI])\n-\n-;; All supported vector modes (except those with 64-bit integer elements).\n-(define_mode_iterator VDQW [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF])\n-\n-;; Supported integer vector modes (not 64 bit elements).\n-(define_mode_iterator VDQIW [V8QI V16QI V4HI V8HI V2SI V4SI])\n-\n-;; Supported integer vector modes (not singleton DI)\n-(define_mode_iterator VDQI [V8QI V16QI V4HI V8HI V2SI V4SI V2DI])\n-\n-;; Vector modes, including 64-bit integer elements.\n-(define_mode_iterator VDQX [V8QI V16QI V4HI V8HI V2SI V4SI V2SF V4SF DI V2DI])\n-\n-;; Vector modes including 64-bit integer elements, but no floats.\n-(define_mode_iterator VDQIX [V8QI V16QI V4HI V8HI V2SI V4SI DI V2DI])\n-\n-;; Vector modes for float->int conversions.\n-(define_mode_iterator VCVTF [V2SF V4SF])\n-\n-;; Vector modes form int->float conversions.\n-(define_mode_iterator VCVTI [V2SI V4SI])\n-\n-;; Vector modes for doubleword multiply-accumulate, etc. insns.\n-(define_mode_iterator VMD [V4HI V2SI V2SF])\n-\n-;; Vector modes for quadword multiply-accumulate, etc. insns.\n-(define_mode_iterator VMQ [V8HI V4SI V4SF])\n-\n-;; Above modes combined.\n-(define_mode_iterator VMDQ [V4HI V2SI V2SF V8HI V4SI V4SF])\n-\n-;; As VMD, but integer modes only.\n-(define_mode_iterator VMDI [V4HI V2SI])\n-\n-;; As VMQ, but integer modes only.\n-(define_mode_iterator VMQI [V8HI V4SI])\n-\n-;; Above modes combined.\n-(define_mode_iterator VMDQI [V4HI V2SI V8HI V4SI])\n-\n-;; Modes with 8-bit and 16-bit elements.\n-(define_mode_iterator VX [V8QI V4HI V16QI V8HI])\n-\n-;; Modes with 8-bit elements.\n-(define_mode_iterator VE [V8QI V16QI])\n-\n-;; Modes with 64-bit elements only.\n-(define_mode_iterator V64 [DI V2DI])\n-\n-;; Modes with 32-bit elements only.\n-(define_mode_iterator V32 [V2SI V2SF V4SI V4SF])\n-\n-;; (Opposite) mode to convert to/from for above conversions.\n-(define_mode_attr V_CVTTO [(V2SI \"V2SF\") (V2SF \"V2SI\")\n-\t\t\t   (V4SI \"V4SF\") (V4SF \"V4SI\")])\n-\n-;; Define element mode for each vector mode.\n-(define_mode_attr V_elem [(V8QI \"QI\") (V16QI \"QI\")\n-\t\t\t  (V4HI \"HI\") (V8HI \"HI\")\n-                          (V2SI \"SI\") (V4SI \"SI\")\n-                          (V2SF \"SF\") (V4SF \"SF\")\n-                          (DI \"DI\")   (V2DI \"DI\")])\n-\n-;; Element modes for vector extraction, padded up to register size.\n-\n-(define_mode_attr V_ext [(V8QI \"SI\") (V16QI \"SI\")\n-\t\t\t (V4HI \"SI\") (V8HI \"SI\")\n-\t\t\t (V2SI \"SI\") (V4SI \"SI\")\n-\t\t\t (V2SF \"SF\") (V4SF \"SF\")\n-\t\t\t (DI \"DI\") (V2DI \"DI\")])\n-\n-;; Mode of pair of elements for each vector mode, to define transfer\n-;; size for structure lane/dup loads and stores.\n-(define_mode_attr V_two_elem [(V8QI \"HI\") (V16QI \"HI\")\n-\t\t\t      (V4HI \"SI\") (V8HI \"SI\")\n-                              (V2SI \"V2SI\") (V4SI \"V2SI\")\n-                              (V2SF \"V2SF\") (V4SF \"V2SF\")\n-                              (DI \"V2DI\")   (V2DI \"V2DI\")])\n-\n-;; Similar, for three elements.\n-;; ??? Should we define extra modes so that sizes of all three-element\n-;; accesses can be accurately represented?\n-(define_mode_attr V_three_elem [(V8QI \"SI\")   (V16QI \"SI\")\n-\t\t\t        (V4HI \"V4HI\") (V8HI \"V4HI\")\n-                                (V2SI \"V4SI\") (V4SI \"V4SI\")\n-                                (V2SF \"V4SF\") (V4SF \"V4SF\")\n-                                (DI \"EI\")     (V2DI \"EI\")])\n-\n-;; Similar, for four elements.\n-(define_mode_attr V_four_elem [(V8QI \"SI\")   (V16QI \"SI\")\n-\t\t\t       (V4HI \"V4HI\") (V8HI \"V4HI\")\n-                               (V2SI \"V4SI\") (V4SI \"V4SI\")\n-                               (V2SF \"V4SF\") (V4SF \"V4SF\")\n-                               (DI \"OI\")     (V2DI \"OI\")])\n-\n-;; Register width from element mode\n-(define_mode_attr V_reg [(V8QI \"P\") (V16QI \"q\")\n-                         (V4HI \"P\") (V8HI  \"q\")\n-                         (V2SI \"P\") (V4SI  \"q\")\n-                         (V2SF \"P\") (V4SF  \"q\")\n-                         (DI   \"P\") (V2DI  \"q\")])\n-\n-;; Wider modes with the same number of elements.\n-(define_mode_attr V_widen [(V8QI \"V8HI\") (V4HI \"V4SI\") (V2SI \"V2DI\")])\n-\n-;; Narrower modes with the same number of elements.\n-(define_mode_attr V_narrow [(V8HI \"V8QI\") (V4SI \"V4HI\") (V2DI \"V2SI\")])\n-\n-;; Modes with half the number of equal-sized elements.\n-(define_mode_attr V_HALF [(V16QI \"V8QI\") (V8HI \"V4HI\")\n-\t\t\t  (V4SI  \"V2SI\") (V4SF \"V2SF\")\n-                          (V2DI \"DI\")])\n-\n-;; Same, but lower-case.\n-(define_mode_attr V_half [(V16QI \"v8qi\") (V8HI \"v4hi\")\n-\t\t\t  (V4SI  \"v2si\") (V4SF \"v2sf\")\n-                          (V2DI \"di\")])\n-\n-;; Modes with twice the number of equal-sized elements.\n-(define_mode_attr V_DOUBLE [(V8QI \"V16QI\") (V4HI \"V8HI\")\n-\t\t\t    (V2SI \"V4SI\") (V2SF \"V4SF\")\n-                            (DI \"V2DI\")])\n-\n-;; Same, but lower-case.\n-(define_mode_attr V_double [(V8QI \"v16qi\") (V4HI \"v8hi\")\n-\t\t\t    (V2SI \"v4si\") (V2SF \"v4sf\")\n-                            (DI \"v2di\")])\n-\n-;; Modes with double-width elements.\n-(define_mode_attr V_double_width [(V8QI \"V4HI\") (V16QI \"V8HI\")\n-\t\t\t\t  (V4HI \"V2SI\") (V8HI \"V4SI\")\n-\t\t\t\t  (V2SI \"DI\")   (V4SI \"V2DI\")])\n-\n-;; Double-sized modes with the same element size.\n-;; Used for neon_vdup_lane, where the second operand is double-sized\n-;; even when the first one is quad.\n-(define_mode_attr V_double_vector_mode [(V16QI \"V8QI\") (V8HI \"V4HI\")\n-                                        (V4SI \"V2SI\") (V4SF \"V2SF\")\n-                                        (V8QI \"V8QI\") (V4HI \"V4HI\")\n-                                        (V2SI \"V2SI\") (V2SF \"V2SF\")])\n-\n-;; Mode of result of comparison operations (and bit-select operand 1).\n-(define_mode_attr V_cmp_result [(V8QI \"V8QI\") (V16QI \"V16QI\")\n-\t\t\t        (V4HI \"V4HI\") (V8HI  \"V8HI\")\n-                                (V2SI \"V2SI\") (V4SI  \"V4SI\")\n-                                (V2SF \"V2SI\") (V4SF  \"V4SI\")\n-                                (DI   \"DI\")   (V2DI  \"V2DI\")])\n-\n-;; Get element type from double-width mode, for operations where we don't care\n-;; about signedness.\n-(define_mode_attr V_if_elem [(V8QI \"i8\")  (V16QI \"i8\")\n-\t\t\t     (V4HI \"i16\") (V8HI  \"i16\")\n-                             (V2SI \"i32\") (V4SI  \"i32\")\n-                             (DI   \"i64\") (V2DI  \"i64\")\n-\t\t\t     (V2SF \"f32\") (V4SF  \"f32\")])\n-\n-;; Same, but for operations which work on signed values.\n-(define_mode_attr V_s_elem [(V8QI \"s8\")  (V16QI \"s8\")\n-\t\t\t    (V4HI \"s16\") (V8HI  \"s16\")\n-                            (V2SI \"s32\") (V4SI  \"s32\")\n-                            (DI   \"s64\") (V2DI  \"s64\")\n-\t\t\t    (V2SF \"f32\") (V4SF  \"f32\")])\n-\n-;; Same, but for operations which work on unsigned values.\n-(define_mode_attr V_u_elem [(V8QI \"u8\")  (V16QI \"u8\")\n-\t\t\t    (V4HI \"u16\") (V8HI  \"u16\")\n-                            (V2SI \"u32\") (V4SI  \"u32\")\n-                            (DI   \"u64\") (V2DI  \"u64\")\n-                            (V2SF \"f32\") (V4SF  \"f32\")])\n-\n-;; Element types for extraction of unsigned scalars.\n-(define_mode_attr V_uf_sclr [(V8QI \"u8\")  (V16QI \"u8\")\n-\t\t\t     (V4HI \"u16\") (V8HI \"u16\")\n-                             (V2SI \"32\") (V4SI \"32\")\n-                             (V2SF \"32\") (V4SF \"32\")])\n-\n-(define_mode_attr V_sz_elem [(V8QI \"8\")  (V16QI \"8\")\n-\t\t\t     (V4HI \"16\") (V8HI  \"16\")\n-                             (V2SI \"32\") (V4SI  \"32\")\n-                             (DI   \"64\") (V2DI  \"64\")\n-\t\t\t     (V2SF \"32\") (V4SF  \"32\")])\n-\n-;; Element sizes for duplicating ARM registers to all elements of a vector.\n-(define_mode_attr VD_dup [(V8QI \"8\") (V4HI \"16\") (V2SI \"32\") (V2SF \"32\")])\n-\n-;; Opaque integer types for results of pair-forming intrinsics (vtrn, etc.)\n-(define_mode_attr V_PAIR [(V8QI \"TI\") (V16QI \"OI\")\n-\t\t\t  (V4HI \"TI\") (V8HI  \"OI\")\n-                          (V2SI \"TI\") (V4SI  \"OI\")\n-                          (V2SF \"TI\") (V4SF  \"OI\")\n-                          (DI   \"TI\") (V2DI  \"OI\")])\n-\n-;; Same, but lower-case.\n-(define_mode_attr V_pair [(V8QI \"ti\") (V16QI \"oi\")\n-\t\t\t  (V4HI \"ti\") (V8HI  \"oi\")\n-                          (V2SI \"ti\") (V4SI  \"oi\")\n-                          (V2SF \"ti\") (V4SF  \"oi\")\n-                          (DI   \"ti\") (V2DI  \"oi\")])\n-\n-;; Operations on two halves of a quadword vector.\n-(define_code_iterator vqh_ops [plus smin smax umin umax])\n-\n-;; Same, without unsigned variants (for use with *SFmode pattern).\n-(define_code_iterator vqhs_ops [plus smin smax])\n-\n-;; Assembler mnemonics for above codes.\n-(define_code_attr VQH_mnem [(plus \"vadd\") (smin \"vmin\") (smax \"vmax\")\n-\t\t\t    (umin \"vmin\") (umax \"vmax\")])\n-\n-;; Signs of above, where relevant.\n-(define_code_attr VQH_sign [(plus \"i\") (smin \"s\") (smax \"s\") (umin \"u\")\n-\t\t\t    (umax \"u\")])\n-\n-;; Extra suffix on some 64-bit insn names (to avoid collision with standard\n-;; names which we don't want to define).\n-(define_mode_attr V_suf64 [(V8QI \"\") (V16QI \"\")\n-\t\t\t   (V4HI \"\") (V8HI \"\")\n-                           (V2SI \"\") (V4SI \"\")\n-                           (V2SF \"\") (V4SF \"\")\n-                           (DI \"_neon\") (V2DI \"\")])\n-\n-;; Scalars to be presented to scalar multiplication instructions\n-;; must satisfy the following constraints.\n-;; 1. If the mode specifies 16-bit elements, the scalar must be in D0-D7.\n-;; 2. If the mode specifies 32-bit elements, the scalar must be in D0-D15.\n-;; This mode attribute is used to obtain the correct register constraints.\n-(define_mode_attr scalar_mul_constraint [(V4HI \"x\") (V2SI \"t\") (V2SF \"t\")\n-                                         (V8HI \"x\") (V4SI \"t\") (V4SF \"t\")])\n \n ;; Attribute used to permit string comparisons against <VQH_mnem> in\n ;; neon_type attribute definitions.\n (define_attr \"vqh_mnem\" \"vadd,vmin,vmax\" (const_string \"vadd\"))\n \n-;; Predicates used for setting neon_type\n-\n-(define_mode_attr Is_float_mode [(V8QI \"false\") (V16QI \"false\")\n-\t\t\t\t (V4HI \"false\") (V8HI \"false\")\n-\t\t\t\t (V2SI \"false\") (V4SI \"false\")\n-\t\t\t\t (V2SF \"true\") (V4SF \"true\")\n-\t\t\t\t (DI \"false\") (V2DI \"false\")])\n-\n-(define_mode_attr Scalar_mul_8_16 [(V8QI \"true\") (V16QI \"true\")\n-\t\t\t\t   (V4HI \"true\") (V8HI \"true\")\n-\t\t\t\t   (V2SI \"false\") (V4SI \"false\")\n-\t\t\t\t   (V2SF \"false\") (V4SF \"false\")\n-\t\t\t\t   (DI \"false\") (V2DI \"false\")])\n-\n-\n-(define_mode_attr Is_d_reg [(V8QI \"true\") (V16QI \"false\")\n-                            (V4HI \"true\") (V8HI  \"false\")\n-                            (V2SI \"true\") (V4SI  \"false\")\n-                            (V2SF \"true\") (V4SF  \"false\")\n-                            (DI   \"true\") (V2DI  \"false\")])\n-\n-(define_mode_attr V_mode_nunits [(V8QI \"8\") (V16QI \"16\")\n-                                 (V4HI \"4\") (V8HI \"8\")\n-                                 (V2SI \"2\") (V4SI \"4\")\n-                                 (V2SF \"2\") (V4SF \"4\")\n-                                 (DI \"1\")   (V2DI \"2\")])\n-\n (define_insn \"*neon_mov<mode>\"\n   [(set (match_operand:VD 0 \"nonimmediate_operand\"\n \t  \"=w,Uv,w, w,  ?r,?w,?r,?r, ?Us\")"}, {"sha": "58b40f65dce68caf9433a3539fa8d4c42a33fbbd", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceddf62caf3e2cb2feb0abc6005016d3bb4b1362/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=ceddf62caf3e2cb2feb0abc6005016d3bb4b1362", "patch": "@@ -20,18 +20,6 @@\n \n ;; Vector Moves\n \n-;; All integer and float modes supported by Neon and IWMMXT.\n-(define_mode_iterator VALL [V2DI V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n-\n-;; All integer and float modes supported by Neon and IWMMXT, except V2DI.\n-(define_mode_iterator VALLW [V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n-\n-;; All integer modes supported by Neon and IWMMXT\n-(define_mode_iterator VINT [V2DI V2SI V4HI V8QI V4SI V8HI V16QI])\n-\n-;; All integer modes supported by Neon and IWMMXT, except V2DI\n-(define_mode_iterator VINTW [V2SI V4HI V8QI V4SI V8HI V16QI])\n-\n (define_expand \"mov<mode>\"\n   [(set (match_operand:VALL 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:VALL 1 \"general_operand\" \"\"))]"}]}