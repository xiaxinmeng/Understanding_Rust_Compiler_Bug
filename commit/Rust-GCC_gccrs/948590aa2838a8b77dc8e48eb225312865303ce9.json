{"sha": "948590aa2838a8b77dc8e48eb225312865303ce9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ4NTkwYWEyODM4YThiNzdkYzhlNDhlYjIyNTMxMjg2NTMwM2NlOQ==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2020-03-04T10:32:57Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-10T13:34:56Z"}, "message": "[Ada] Incorrect accessibility checks on functions calls\n\n2020-06-10  Justin Squirek  <squirek@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Add condition to\n\thandle processing of objects initialized by a call to a function\n\treturn an anonymous access type.\n\t* exp_ch6.adb, exp_ch6.ads\n\t(Has_Unconstrained_Access_Discriminants): Moved to sem_util.adb\n\t(Needs_Result_Accessibility_Level): Moved to sem_util.adb\n\t* sem_util.adb, sem_util.ads\n\t(Has_Unconstrained_Access_Discriminants): Moved from exp_ch6.adb\n\t(Needs_Result_Accessibility_Level): Moved from exp_ch6.adb\n\t* sem_res.adb (Valid_Conversion): Add condition for the special\n\tcase where the operand of a conversion is the result of an\n\tanonymous access type", "tree": {"sha": "e600055d883a50880014f59af2140cbfd9d83c45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e600055d883a50880014f59af2140cbfd9d83c45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/948590aa2838a8b77dc8e48eb225312865303ce9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948590aa2838a8b77dc8e48eb225312865303ce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/948590aa2838a8b77dc8e48eb225312865303ce9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948590aa2838a8b77dc8e48eb225312865303ce9/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71c4a2b35600a1177542b293cf075d6cf6d4dae4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71c4a2b35600a1177542b293cf075d6cf6d4dae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71c4a2b35600a1177542b293cf075d6cf6d4dae4"}], "stats": {"total": 387, "additions": 203, "deletions": 184}, "files": [{"sha": "cf53100b0782dbe16d5347547f0395012a9439f1", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=948590aa2838a8b77dc8e48eb225312865303ce9", "patch": "@@ -7178,21 +7178,32 @@ package body Exp_Ch3 is\n                         Chars =>\n                           New_External_Name (Chars (Def_Id), Suffix => \"L\"));\n \n-            Level_Expr : Node_Id;\n             Level_Decl : Node_Id;\n+            Level_Expr : Node_Id;\n \n          begin\n             Set_Ekind (Level, Ekind (Def_Id));\n             Set_Etype (Level, Standard_Natural);\n             Set_Scope (Level, Scope (Def_Id));\n \n-            if No (Expr) then\n-\n-               --  Set accessibility level of null\n+            --  Set accessibility level of null\n \n+            if No (Expr) then\n                Level_Expr :=\n                  Make_Integer_Literal (Loc, Scope_Depth (Standard_Standard));\n \n+            --  When the expression of the object is a function which returns\n+            --  an anonymous access type the master of the call is the object\n+            --  being initialized instead of the type.\n+\n+            elsif Nkind (Expr) = N_Function_Call\n+              and then Ekind (Etype (Name (Expr))) = E_Anonymous_Access_Type\n+            then\n+               Level_Expr := Make_Integer_Literal (Loc,\n+                               Object_Access_Level (Def_Id));\n+\n+            --  General case\n+\n             else\n                Level_Expr := Dynamic_Accessibility_Level (Expr);\n             end if;"}, {"sha": "7e6f77ada5762031f733ce9c124bf036c4cdacb5", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=948590aa2838a8b77dc8e48eb225312865303ce9", "patch": "@@ -244,11 +244,6 @@ package body Exp_Ch6 is\n    --  Expand simple return from function. In the case where we are returning\n    --  from a function body this is called by Expand_N_Simple_Return_Statement.\n \n-   function Has_Unconstrained_Access_Discriminants\n-     (Subtyp : Entity_Id) return Boolean;\n-   --  Returns True if the given subtype is unconstrained and has one or more\n-   --  access discriminants.\n-\n    procedure Insert_Post_Call_Actions (N : Node_Id; Post_Call : List_Id);\n    --  Insert the Post_Call list previously produced by routine Expand_Actuals\n    --  or Expand_Call_Helper into the tree.\n@@ -7772,32 +7767,6 @@ package body Exp_Ch6 is\n       end if;\n    end Freeze_Subprogram;\n \n-   --------------------------------------------\n-   -- Has_Unconstrained_Access_Discriminants --\n-   --------------------------------------------\n-\n-   function Has_Unconstrained_Access_Discriminants\n-     (Subtyp : Entity_Id) return Boolean\n-   is\n-      Discr : Entity_Id;\n-\n-   begin\n-      if Has_Discriminants (Subtyp)\n-        and then not Is_Constrained (Subtyp)\n-      then\n-         Discr := First_Discriminant (Subtyp);\n-         while Present (Discr) loop\n-            if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n-               return True;\n-            end if;\n-\n-            Next_Discriminant (Discr);\n-         end loop;\n-      end if;\n-\n-      return False;\n-   end Has_Unconstrained_Access_Discriminants;\n-\n    ------------------------------\n    -- Insert_Post_Call_Actions --\n    ------------------------------\n@@ -9431,144 +9400,6 @@ package body Exp_Ch6 is\n       return Requires_Transient_Scope (Func_Typ);\n    end Needs_BIP_Alloc_Form;\n \n-   --------------------------------------\n-   -- Needs_Result_Accessibility_Level --\n-   --------------------------------------\n-\n-   function Needs_Result_Accessibility_Level\n-     (Func_Id : Entity_Id) return Boolean\n-   is\n-      Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n-\n-      function Has_Unconstrained_Access_Discriminant_Component\n-        (Comp_Typ : Entity_Id) return Boolean;\n-      --  Returns True if any component of the type has an unconstrained access\n-      --  discriminant.\n-\n-      -----------------------------------------------------\n-      -- Has_Unconstrained_Access_Discriminant_Component --\n-      -----------------------------------------------------\n-\n-      function Has_Unconstrained_Access_Discriminant_Component\n-        (Comp_Typ :  Entity_Id) return Boolean\n-      is\n-      begin\n-         if not Is_Limited_Type (Comp_Typ) then\n-            return False;\n-\n-            --  Only limited types can have access discriminants with\n-            --  defaults.\n-\n-         elsif Has_Unconstrained_Access_Discriminants (Comp_Typ) then\n-            return True;\n-\n-         elsif Is_Array_Type (Comp_Typ) then\n-            return Has_Unconstrained_Access_Discriminant_Component\n-                     (Underlying_Type (Component_Type (Comp_Typ)));\n-\n-         elsif Is_Record_Type (Comp_Typ) then\n-            declare\n-               Comp : Entity_Id;\n-\n-            begin\n-               Comp := First_Component (Comp_Typ);\n-               while Present (Comp) loop\n-                  if Has_Unconstrained_Access_Discriminant_Component\n-                       (Underlying_Type (Etype (Comp)))\n-                  then\n-                     return True;\n-                  end if;\n-\n-                  Next_Component (Comp);\n-               end loop;\n-            end;\n-         end if;\n-\n-         return False;\n-      end Has_Unconstrained_Access_Discriminant_Component;\n-\n-      Disable_Coextension_Cases : constant Boolean := True;\n-      --  Flag used to temporarily disable a \"True\" result for types with\n-      --  access discriminants and related coextension cases.\n-\n-   --  Start of processing for Needs_Result_Accessibility_Level\n-\n-   begin\n-      --  False if completion unavailable (how does this happen???)\n-\n-      if not Present (Func_Typ) then\n-         return False;\n-\n-      --  False if not a function, also handle enum-lit renames case\n-\n-      elsif Func_Typ = Standard_Void_Type\n-        or else Is_Scalar_Type (Func_Typ)\n-      then\n-         return False;\n-\n-      --  Handle a corner case, a cross-dialect subp renaming. For example,\n-      --  an Ada 2012 renaming of an Ada 2005 subprogram. This can occur when\n-      --  an Ada 2005 (or earlier) unit references predefined run-time units.\n-\n-      elsif Present (Alias (Func_Id)) then\n-\n-         --  Unimplemented: a cross-dialect subp renaming which does not set\n-         --  the Alias attribute (e.g., a rename of a dereference of an access\n-         --  to subprogram value). ???\n-\n-         return Present (Extra_Accessibility_Of_Result (Alias (Func_Id)));\n-\n-      --  Remaining cases require Ada 2012 mode\n-\n-      elsif Ada_Version < Ada_2012 then\n-         return False;\n-\n-      --  Handle the situation where a result is an anonymous access type\n-      --  RM 3.10.2 (10.3/3).\n-\n-      elsif Ekind (Func_Typ) = E_Anonymous_Access_Type then\n-         return True;\n-\n-      --  The following cases are related to coextensions and do not fully\n-      --  cover everything mentioned in RM 3.10.2 (12) ???\n-\n-      --  Temporarily disabled ???\n-\n-      elsif Disable_Coextension_Cases then\n-         return False;\n-\n-      --  In the case of, say, a null tagged record result type, the need for\n-      --  this extra parameter might not be obvious so this function returns\n-      --  True for all tagged types for compatibility reasons.\n-\n-      --  A function with, say, a tagged null controlling result type might\n-      --  be overridden by a primitive of an extension having an access\n-      --  discriminant and the overrider and overridden must have compatible\n-      --  calling conventions (including implicitly declared parameters).\n-\n-      --  Similarly, values of one access-to-subprogram type might designate\n-      --  both a primitive subprogram of a given type and a function which is,\n-      --  for example, not a primitive subprogram of any type. Again, this\n-      --  requires calling convention compatibility. It might be possible to\n-      --  solve these issues by introducing wrappers, but that is not the\n-      --  approach that was chosen.\n-\n-      elsif Is_Tagged_Type (Func_Typ) then\n-         return True;\n-\n-      elsif Has_Unconstrained_Access_Discriminants (Func_Typ) then\n-         return True;\n-\n-      elsif Has_Unconstrained_Access_Discriminant_Component (Func_Typ) then\n-         return True;\n-\n-      --  False for all other cases\n-\n-      else\n-         return False;\n-      end if;\n-   end Needs_Result_Accessibility_Level;\n-\n    -------------------------------------\n    -- Replace_Renaming_Declaration_Id --\n    -------------------------------------"}, {"sha": "b3dae148a557385e2a981dc1749367d2547d7cf5", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=948590aa2838a8b77dc8e48eb225312865303ce9", "patch": "@@ -247,12 +247,6 @@ package Exp_Ch6 is\n    function Needs_BIP_Task_Actuals (Func_Id : Entity_Id) return Boolean;\n    --  Return True if the function returns an object of a type that has tasks.\n \n-   function Needs_Result_Accessibility_Level\n-     (Func_Id : Entity_Id) return Boolean;\n-   --  Ada 2012 (AI05-0234): Return True if the function needs an implicit\n-   --  parameter to identify the accessibility level of the function result\n-   --  \"determined by the point of call\".\n-\n    function Unqual_BIP_Iface_Function_Call (Expr : Node_Id) return Node_Id;\n    --  Return the inner BIP function call removing any qualification from Expr\n    --  including qualified expressions, type conversions, references, unchecked"}, {"sha": "fdcef214a7c7c959ffd52f1beffe4b2a030b3256", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=948590aa2838a8b77dc8e48eb225312865303ce9", "patch": "@@ -13086,8 +13086,16 @@ package body Sem_Res is\n                   end if;\n                end if;\n \n+            --  Check if the operand is deeper than the target type, taking\n+            --  care to avoid the case where we are converting a result of a\n+            --  function returning an anonymous access type since the \"master\n+            --  of the call\" would be target type of the conversion in all\n+            --  cases - see RM 10.3/3.\n+\n             elsif Type_Access_Level (Opnd_Type) >\n                     Deepest_Type_Access_Level (Target_Type)\n+              and then not (Nkind (Associated_Node_For_Itype (Opnd_Type)) =\n+                                     N_Function_Specification)\n             then\n                --  In an instance, this is a run-time check, but one we know\n                --  will fail, so generate an appropriate warning. The raise"}, {"sha": "5f3dc9e2ba81a5c0fd0c22a6baab433467981f5f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 165, "deletions": 1, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=948590aa2838a8b77dc8e48eb225312865303ce9", "patch": "@@ -12326,6 +12326,32 @@ package body Sem_Util is\n       end if;\n    end Has_Tagged_Component;\n \n+   --------------------------------------------\n+   -- Has_Unconstrained_Access_Discriminants --\n+   --------------------------------------------\n+\n+   function Has_Unconstrained_Access_Discriminants\n+     (Subtyp : Entity_Id) return Boolean\n+   is\n+      Discr : Entity_Id;\n+\n+   begin\n+      if Has_Discriminants (Subtyp)\n+        and then not Is_Constrained (Subtyp)\n+      then\n+         Discr := First_Discriminant (Subtyp);\n+         while Present (Discr) loop\n+            if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n+               return True;\n+            end if;\n+\n+            Next_Discriminant (Discr);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Has_Unconstrained_Access_Discriminants;\n+\n    -----------------------------\n    -- Has_Undefined_Reference --\n    -----------------------------\n@@ -17804,7 +17830,7 @@ package body Sem_Util is\n            and then Ekind_In (Scop, E_Function,\n                                     E_Operator,\n                                     E_Subprogram_Type)\n-           and then Present (Extra_Accessibility_Of_Result (Scop));\n+           and then Needs_Result_Accessibility_Level (Scop);\n       end;\n    end Is_Special_Aliased_Formal_Access;\n \n@@ -19903,6 +19929,144 @@ package body Sem_Util is\n       end if;\n    end Needs_One_Actual;\n \n+   --------------------------------------\n+   -- Needs_Result_Accessibility_Level --\n+   --------------------------------------\n+\n+   function Needs_Result_Accessibility_Level\n+     (Func_Id : Entity_Id) return Boolean\n+   is\n+      Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n+\n+      function Has_Unconstrained_Access_Discriminant_Component\n+        (Comp_Typ : Entity_Id) return Boolean;\n+      --  Returns True if any component of the type has an unconstrained access\n+      --  discriminant.\n+\n+      -----------------------------------------------------\n+      -- Has_Unconstrained_Access_Discriminant_Component --\n+      -----------------------------------------------------\n+\n+      function Has_Unconstrained_Access_Discriminant_Component\n+        (Comp_Typ :  Entity_Id) return Boolean\n+      is\n+      begin\n+         if not Is_Limited_Type (Comp_Typ) then\n+            return False;\n+\n+            --  Only limited types can have access discriminants with\n+            --  defaults.\n+\n+         elsif Has_Unconstrained_Access_Discriminants (Comp_Typ) then\n+            return True;\n+\n+         elsif Is_Array_Type (Comp_Typ) then\n+            return Has_Unconstrained_Access_Discriminant_Component\n+                     (Underlying_Type (Component_Type (Comp_Typ)));\n+\n+         elsif Is_Record_Type (Comp_Typ) then\n+            declare\n+               Comp : Entity_Id;\n+\n+            begin\n+               Comp := First_Component (Comp_Typ);\n+               while Present (Comp) loop\n+                  if Has_Unconstrained_Access_Discriminant_Component\n+                       (Underlying_Type (Etype (Comp)))\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  Next_Component (Comp);\n+               end loop;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Has_Unconstrained_Access_Discriminant_Component;\n+\n+      Disable_Coextension_Cases : constant Boolean := True;\n+      --  Flag used to temporarily disable a \"True\" result for types with\n+      --  access discriminants and related coextension cases.\n+\n+   --  Start of processing for Needs_Result_Accessibility_Level\n+\n+   begin\n+      --  False if completion unavailable (how does this happen???)\n+\n+      if not Present (Func_Typ) then\n+         return False;\n+\n+      --  False if not a function, also handle enum-lit renames case\n+\n+      elsif Func_Typ = Standard_Void_Type\n+        or else Is_Scalar_Type (Func_Typ)\n+      then\n+         return False;\n+\n+      --  Handle a corner case, a cross-dialect subp renaming. For example,\n+      --  an Ada 2012 renaming of an Ada 2005 subprogram. This can occur when\n+      --  an Ada 2005 (or earlier) unit references predefined run-time units.\n+\n+      elsif Present (Alias (Func_Id)) then\n+\n+         --  Unimplemented: a cross-dialect subp renaming which does not set\n+         --  the Alias attribute (e.g., a rename of a dereference of an access\n+         --  to subprogram value). ???\n+\n+         return Present (Extra_Accessibility_Of_Result (Alias (Func_Id)));\n+\n+      --  Remaining cases require Ada 2012 mode\n+\n+      elsif Ada_Version < Ada_2012 then\n+         return False;\n+\n+      --  Handle the situation where a result is an anonymous access type\n+      --  RM 3.10.2 (10.3/3).\n+\n+      elsif Ekind (Func_Typ) = E_Anonymous_Access_Type then\n+         return True;\n+\n+      --  The following cases are related to coextensions and do not fully\n+      --  cover everything mentioned in RM 3.10.2 (12) ???\n+\n+      --  Temporarily disabled ???\n+\n+      elsif Disable_Coextension_Cases then\n+         return False;\n+\n+      --  In the case of, say, a null tagged record result type, the need for\n+      --  this extra parameter might not be obvious so this function returns\n+      --  True for all tagged types for compatibility reasons.\n+\n+      --  A function with, say, a tagged null controlling result type might\n+      --  be overridden by a primitive of an extension having an access\n+      --  discriminant and the overrider and overridden must have compatible\n+      --  calling conventions (including implicitly declared parameters).\n+\n+      --  Similarly, values of one access-to-subprogram type might designate\n+      --  both a primitive subprogram of a given type and a function which is,\n+      --  for example, not a primitive subprogram of any type. Again, this\n+      --  requires calling convention compatibility. It might be possible to\n+      --  solve these issues by introducing wrappers, but that is not the\n+      --  approach that was chosen.\n+\n+      elsif Is_Tagged_Type (Func_Typ) then\n+         return True;\n+\n+      elsif Has_Unconstrained_Access_Discriminants (Func_Typ) then\n+         return True;\n+\n+      elsif Has_Unconstrained_Access_Discriminant_Component (Func_Typ) then\n+         return True;\n+\n+      --  False for all other cases\n+\n+      else\n+         return False;\n+      end if;\n+   end Needs_Result_Accessibility_Level;\n+\n    ---------------------------------\n    -- Needs_Simple_Initialization --\n    ---------------------------------"}, {"sha": "6be77dd6e9747a9b9aa1d5db23af6cdde5568554", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948590aa2838a8b77dc8e48eb225312865303ce9/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=948590aa2838a8b77dc8e48eb225312865303ce9", "patch": "@@ -1367,6 +1367,11 @@ package Sem_Util is\n    --  function is used to check if \"=\" has to be expanded into a bunch\n    --  component comparisons.\n \n+   function Has_Unconstrained_Access_Discriminants\n+     (Subtyp : Entity_Id) return Boolean;\n+   --  Returns True if the given subtype is unconstrained and has one or more\n+   --  access discriminants.\n+\n    function Has_Undefined_Reference (Expr : Node_Id) return Boolean;\n    --  Given arbitrary expression Expr, determine whether it contains at\n    --  least one name whose entity is Any_Id.\n@@ -2251,6 +2256,12 @@ package Sem_Util is\n    --  syntactic ambiguity that results from an indexing of a function call\n    --  that returns an array, so that Obj.F (X, Y) may mean F (Ob) (X, Y).\n \n+   function Needs_Result_Accessibility_Level\n+     (Func_Id : Entity_Id) return Boolean;\n+   --  Ada 2012 (AI05-0234): Return True if the function needs an implicit\n+   --  parameter to identify the accessibility level of the function result\n+   --  \"determined by the point of call\".\n+\n    function Needs_Simple_Initialization\n      (Typ         : Entity_Id;\n       Consider_IS : Boolean := True) return Boolean;\n@@ -2713,6 +2724,10 @@ package Sem_Util is\n    --  Establish the entity E as the currently visible definition of its\n    --  associated name (i.e. the Node_Id associated with its name).\n \n+   procedure Set_Debug_Info_Defining_Id (N : Node_Id);\n+   --  Call Set_Debug_Info_Needed on Defining_Identifier (N) if it comes\n+   --  from source.\n+\n    procedure Set_Debug_Info_Needed (T : Entity_Id);\n    --  Sets the Debug_Info_Needed flag on entity T , and also on any entities\n    --  that are needed by T (for an object, the type of the object is needed,\n@@ -2721,10 +2736,6 @@ package Sem_Util is\n    --  This routine should always be used instead of Set_Needs_Debug_Info to\n    --  ensure that subsidiary entities are properly handled.\n \n-   procedure Set_Debug_Info_Defining_Id (N : Node_Id);\n-   --  Call Set_Debug_Info_Needed on Defining_Identifier (N) if it comes\n-   --  from source.\n-\n    procedure Set_Entity_With_Checks (N : Node_Id; Val : Entity_Id);\n    --  This procedure has the same calling sequence as Set_Entity, but it\n    --  performs additional checks as follows:"}]}