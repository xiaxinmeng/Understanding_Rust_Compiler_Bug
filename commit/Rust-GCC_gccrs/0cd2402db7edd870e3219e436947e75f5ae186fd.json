{"sha": "0cd2402db7edd870e3219e436947e75f5ae186fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNkMjQwMmRiN2VkZDg3MGUzMjE5ZTQzNjk0N2U3NWY1YWUxODZmZA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-04-18T18:27:51Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-04-18T18:27:51Z"}, "message": "targhooks.c (default_case_values_threshold): Fix code style nit.\n\ngcc/\n\t* targhooks.c (default_case_values_threshold): Fix code style nit.\n\n\t* stmt.c (add_case_node, expand_case): Move logic to remove/reduce\n\tcase range and type folding from here...\n\t* gimplify.c (gimplify_switch_expr): ... to here.  Expect NULL_TREE\n\ttype, as documented in tree.def\n\nfortran/\n\t* trans-decl.c (gfc_trans_entry_master_switch): Build SWITCH_EXPR\n\twith NULL_TREE type instead of void_type_node.\n\t* trans-io.c (io_result): Likewise.\n\t* trans-stmt.c (gfc_trans_integer_select,\n\tgfc_trans_character_select): Likewise.\n\ngo/\n\t* go-gcc.cc (Gcc_backend::switch_statement): Build SWITCH_EXPR\n\twith NULL_TREE type instead of void_type_node.\n\nFrom-SVN: r186579", "tree": {"sha": "4f4b399e94dc6b7d86f56ab58f0145e056fbe1dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f4b399e94dc6b7d86f56ab58f0145e056fbe1dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cd2402db7edd870e3219e436947e75f5ae186fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cd2402db7edd870e3219e436947e75f5ae186fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cd2402db7edd870e3219e436947e75f5ae186fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cd2402db7edd870e3219e436947e75f5ae186fd/comments", "author": null, "committer": null, "parents": [{"sha": "474ffc723e5888c328b33f3cefe972fbeda4548c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/474ffc723e5888c328b33f3cefe972fbeda4548c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/474ffc723e5888c328b33f3cefe972fbeda4548c"}], "stats": {"total": 218, "additions": 133, "deletions": 85}, "files": [{"sha": "f2d9dc0cf3cf721bb404fde7591f83b3e70ceb54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0cd2402db7edd870e3219e436947e75f5ae186fd", "patch": "@@ -1,3 +1,12 @@\n+2012-04-18  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* targhooks.c (default_case_values_threshold): Fix code style nit.\n+\n+\t* stmt.c (add_case_node, expand_case): Move logic to remove/reduce\n+\tcase range and type folding from here...\n+\t* gimplify.c (gimplify_switch_expr): ... to here.  Expect NULL_TREE\n+\ttype, as documented in tree.def\n+\n 2012-04-18  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.h (verify_symtab, verify_symtab_node, verify_symtab_base):"}, {"sha": "cfe1192b6ef198926007745f7aafe11f50467647", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0cd2402db7edd870e3219e436947e75f5ae186fd", "patch": "@@ -1,3 +1,11 @@\n+2012-04-18  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* trans-decl.c (gfc_trans_entry_master_switch): Build SWITCH_EXPR\n+\twith NULL_TREE type instead of void_type_node.\n+\t* trans-io.c (io_result): Likewise.\n+\t* trans-stmt.c (gfc_trans_integer_select,\n+\tgfc_trans_character_select): Likewise.\n+\n 2012-04-16  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/52864"}, {"sha": "d6c090e86062cad913d640f0ae123e0ca9eba1ae", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=0cd2402db7edd870e3219e436947e75f5ae186fd", "patch": "@@ -4749,7 +4749,8 @@ gfc_trans_entry_master_switch (gfc_entry_list * el)\n   tmp = gfc_finish_block (&block);\n   /* The first argument selects the entry point.  */\n   val = DECL_ARGUMENTS (current_function_decl);\n-  tmp = build3_v (SWITCH_EXPR, val, tmp, NULL_TREE);\n+  tmp = fold_build3_loc (input_location, SWITCH_EXPR, NULL_TREE,\n+\t\t\t val, tmp, NULL_TREE);\n   return tmp;\n }\n "}, {"sha": "8218f85a98daeb242face9c16affe9b3066094ae", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=0cd2402db7edd870e3219e436947e75f5ae186fd", "patch": "@@ -882,7 +882,8 @@ io_result (stmtblock_t * block, tree var, gfc_st_label * err_label,\n \t\t\trc, build_int_cst (TREE_TYPE (rc),\n \t\t\t\t\t   IOPARM_common_libreturn_mask));\n \n-  tmp = build3_v (SWITCH_EXPR, rc, tmp, NULL_TREE);\n+  tmp = fold_build3_loc (input_location, SWITCH_EXPR, NULL_TREE,\n+\t\t\t rc, tmp, NULL_TREE);\n \n   gfc_add_expr_to_block (block, tmp);\n }"}, {"sha": "12a1390e2aaa18318e5205eab3a59f763919db93", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=0cd2402db7edd870e3219e436947e75f5ae186fd", "patch": "@@ -1918,7 +1918,8 @@ gfc_trans_integer_select (gfc_code * code)\n     }\n \n   tmp = gfc_finish_block (&body);\n-  tmp = build3_v (SWITCH_EXPR, se.expr, tmp, NULL_TREE);\n+  tmp = fold_build3_loc (input_location, SWITCH_EXPR, NULL_TREE,\n+\t\t\t se.expr, tmp, NULL_TREE);\n   gfc_add_expr_to_block (&block, tmp);\n \n   tmp = build1_v (LABEL_EXPR, end_label);\n@@ -2203,7 +2204,8 @@ gfc_trans_character_select (gfc_code *code)\n \t  gfc_add_block_to_block (&block, &expr1se.post);\n \n \t  tmp = gfc_finish_block (&body);\n-\t  tmp = build3_v (SWITCH_EXPR, case_num, tmp, NULL_TREE);\n+\t  tmp = fold_build3_loc (input_location, SWITCH_EXPR, NULL_TREE,\n+\t\t\t\t case_num, tmp, NULL_TREE);\n \t  gfc_add_expr_to_block (&block, tmp);\n \n \t  tmp = build1_v (LABEL_EXPR, end_label);\n@@ -2349,7 +2351,8 @@ gfc_trans_character_select (gfc_code *code)\n   gfc_add_block_to_block (&block, &expr1se.post);\n \n   tmp = gfc_finish_block (&body);\n-  tmp = build3_v (SWITCH_EXPR, case_num, tmp, NULL_TREE);\n+  tmp = fold_build3_loc (input_location, SWITCH_EXPR, NULL_TREE,\n+\t\t\t case_num, tmp, NULL_TREE);\n   gfc_add_expr_to_block (&block, tmp);\n \n   tmp = build1_v (LABEL_EXPR, end_label);"}, {"sha": "9e7b8461cc8f3713675ab30ec5da66f86e64653a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 80, "deletions": 16, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0cd2402db7edd870e3219e436947e75f5ae186fd", "patch": "@@ -1575,6 +1575,10 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n   tree switch_expr = *expr_p;\n   gimple_seq switch_body_seq = NULL;\n   enum gimplify_status ret;\n+  tree index_type = TREE_TYPE (switch_expr);\n+  if (index_type == NULL_TREE)\n+    index_type = TREE_TYPE (SWITCH_COND (switch_expr));\n+  gcc_assert (INTEGRAL_TYPE_P (index_type));\n \n   ret = gimplify_expr (&SWITCH_COND (switch_expr), pre_p, NULL, is_gimple_val,\n                        fb_rvalue);\n@@ -1585,6 +1589,7 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n     {\n       VEC (tree,heap) *labels;\n       VEC (tree,heap) *saved_labels;\n+      tree min_value, max_value;\n       tree default_case = NULL_TREE;\n       size_t i, len;\n       gimple gimple_switch;\n@@ -1593,7 +1598,7 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n \t be bothered to null out the body too.  */\n       gcc_assert (!SWITCH_LABELS (switch_expr));\n \n-      /* save old labels, get new ones from body, then restore the old\n+      /* Save old labels, get new ones from body, then restore the old\n          labels.  Save all the things from the switch body to append after.  */\n       saved_labels = gimplify_ctxp->case_labels;\n       gimplify_ctxp->case_labels = VEC_alloc (tree, heap, 8);\n@@ -1603,18 +1608,82 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n       gimplify_ctxp->case_labels = saved_labels;\n \n       i = 0;\n+      min_value = TYPE_MIN_VALUE (index_type);\n+      max_value = TYPE_MAX_VALUE (index_type);\n       while (i < VEC_length (tree, labels))\n \t{\n \t  tree elt = VEC_index (tree, labels, i);\n \t  tree low = CASE_LOW (elt);\n+\t  tree high = CASE_HIGH (elt);\n \t  bool remove_element = FALSE;\n \n+\n \t  if (low)\n \t    {\n-\t      /* Discard empty ranges.  */\n-\t      tree high = CASE_HIGH (elt);\n-\t      if (high && tree_int_cst_lt (high, low))\n-\t        remove_element = TRUE;\n+\t      gcc_checking_assert (TREE_CODE (low) == INTEGER_CST);\n+\t      gcc_checking_assert (!high || TREE_CODE (high) == INTEGER_CST);\n+\n+\t      /* This is a non-default case label, i.e. it has a value.\n+\n+\t\t See if the case label is reachable within the range of\n+\t\t the index type.  Remove out-of-range case values.  Turn\n+\t\t case ranges into a canonical form (high > low strictly)\n+\t\t and convert the case label values to the index type.\n+\n+\t\t NB: The type of gimple_switch_index() may be the promoted\n+\t\t type, but the case labels retain the original type.  */\n+\n+\t      if (high)\n+\t\t{\n+\t\t  /* This is a case range.  Discard empty ranges.\n+\t\t     If the bounds or the range are equal, turn this\n+\t\t     into a simple (one-value) case.  */\n+\t\t  int cmp = tree_int_cst_compare (high, low);\n+\t\t  if (cmp < 0)\n+\t\t    remove_element = TRUE;\n+\t\t  else if (cmp == 0)\n+\t\t    high = NULL_TREE;\n+\t\t}\n+\n+\t      if (! high)\n+\t\t{\n+\t\t  /* If the simple case value is unreachable, ignore it.  */\n+\t\t  if ((TREE_CODE (min_value) == INTEGER_CST\n+\t\t       && tree_int_cst_compare (low, min_value) < 0)\n+\t\t      || (TREE_CODE (max_value) == INTEGER_CST\n+\t\t\t  && tree_int_cst_compare (low, max_value) > 0))\n+\t\t    remove_element = TRUE;\n+\t\t  else\n+\t\t    low = fold_convert (index_type, low);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* If the entire case range is unreachable, ignore it.  */\n+\t\t  if ((TREE_CODE (min_value) == INTEGER_CST\n+\t\t       && tree_int_cst_compare (high, min_value) < 0)\n+\t\t      || (TREE_CODE (max_value) == INTEGER_CST\n+\t\t\t  && tree_int_cst_compare (low, max_value) > 0))\n+\t\t    remove_element = TRUE;\n+\t\t  else\n+\t\t    {\n+\t\t      /* If the lower bound is less than the index type's\n+\t\t\t minimum value, truncate the range bounds.  */\n+\t\t      if (TREE_CODE (min_value) == INTEGER_CST\n+\t\t\t  && tree_int_cst_compare (low, min_value) < 0)\n+\t\t\tlow = min_value;\n+\t\t      low = fold_convert (index_type, low);\n+\n+\t\t      /* If the upper bound is greater than the index type's\n+\t\t\t maximum value, truncate the range bounds.  */\n+\t\t      if (TREE_CODE (max_value) == INTEGER_CST\n+\t\t\t  && tree_int_cst_compare (high, max_value) > 0)\n+\t\t\thigh = max_value;\n+\t\t      high = fold_convert (index_type, high);\n+\t\t    }\n+\t\t}\n+\n+\t      CASE_LOW (elt) = low;\n+\t      CASE_HIGH (elt) = high;\n \t    }\n \t  else\n \t    {\n@@ -1636,25 +1705,20 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n \n       if (!default_case)\n \t{\n-\t  tree type = TREE_TYPE (switch_expr);\n-\n \t  /* If the switch has no default label, add one, so that we jump\n \t     around the switch body.  If the labels already cover the whole\n-\t     range of type, add the default label pointing to one of the\n-\t     existing labels.  */\n-\t  if (type == void_type_node)\n-\t    type = TREE_TYPE (SWITCH_COND (switch_expr));\n+\t     range of the switch index_type, add the default label pointing\n+\t     to one of the existing labels.  */\n \t  if (len\n-\t      && INTEGRAL_TYPE_P (type)\n-\t      && TYPE_MIN_VALUE (type)\n-\t      && TYPE_MAX_VALUE (type)\n+\t      && TYPE_MIN_VALUE (index_type)\n+\t      && TYPE_MAX_VALUE (index_type)\n \t      && tree_int_cst_equal (CASE_LOW (VEC_index (tree, labels, 0)),\n-\t\t\t\t     TYPE_MIN_VALUE (type)))\n+\t\t\t\t     TYPE_MIN_VALUE (index_type)))\n \t    {\n \t      tree low, high = CASE_HIGH (VEC_index (tree, labels, len - 1));\n \t      if (!high)\n \t\thigh = CASE_LOW (VEC_index (tree, labels, len - 1));\n-\t      if (tree_int_cst_equal (high, TYPE_MAX_VALUE (type)))\n+\t      if (tree_int_cst_equal (high, TYPE_MAX_VALUE (index_type)))\n \t\t{\n \t\t  for (i = 1; i < len; i++)\n \t\t    {"}, {"sha": "2991cb957b610e63cdf601a3f35e542737ef4004", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=0cd2402db7edd870e3219e436947e75f5ae186fd", "patch": "@@ -1,3 +1,8 @@\n+2012-04-18  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* go-gcc.cc (Gcc_backend::switch_statement): Build SWITCH_EXPR\n+\twith NULL_TREE type instead of void_type_node.\n+\n 2012-03-09  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc (Gcc_backend::assignment_statement): Convert the rhs"}, {"sha": "08950b8e1d997ab022fbdb320e420111f41d3679", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=0cd2402db7edd870e3219e436947e75f5ae186fd", "patch": "@@ -1087,7 +1087,7 @@ Gcc_backend::switch_statement(\n   if (tv == error_mark_node)\n     return this->error_statement();\n   tree t = build3_loc(switch_location.gcc_location(), SWITCH_EXPR,\n-                      void_type_node, tv, stmt_list, NULL_TREE);\n+                      NULL_TREE, tv, stmt_list, NULL_TREE);\n   return this->make_statement(t);\n }\n "}, {"sha": "8f7b1506eef168a701185360ea92a3d7c36d717d", "filename": "gcc/stmt.c", "status": "modified", "additions": 18, "deletions": 62, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=0cd2402db7edd870e3219e436947e75f5ae186fd", "patch": "@@ -1822,66 +1822,25 @@ expand_stack_restore (tree var)\n    fed to us in descending order from the sorted vector of case labels used\n    in the tree part of the middle end.  So the list we construct is\n    sorted in ascending order.  The bounds on the case range, LOW and HIGH,\n-   are converted to case's index type TYPE.  */\n+   are converted to case's index type TYPE.  Note that the original type\n+   of the case index in the source code is usually \"lost\" during\n+   gimplification due to type promotion, but the case labels retain the\n+   original type.  */\n \n static struct case_node *\n add_case_node (struct case_node *head, tree type, tree low, tree high,\n                tree label, alloc_pool case_node_pool)\n {\n-  tree min_value, max_value;\n   struct case_node *r;\n \n-  gcc_assert (TREE_CODE (low) == INTEGER_CST);\n-  gcc_assert (!high || TREE_CODE (high) == INTEGER_CST);\n-\n-  min_value = TYPE_MIN_VALUE (type);\n-  max_value = TYPE_MAX_VALUE (type);\n-\n-  /* If there's no HIGH value, then this is not a case range; it's\n-     just a simple case label.  But that's just a degenerate case\n-     range.\n-     If the bounds are equal, turn this into the one-value case.  */\n-  if (!high || tree_int_cst_equal (low, high))\n-    {\n-      /* If the simple case value is unreachable, ignore it.  */\n-      if ((TREE_CODE (min_value) == INTEGER_CST\n-            && tree_int_cst_compare (low, min_value) < 0)\n-\t  || (TREE_CODE (max_value) == INTEGER_CST\n-\t      && tree_int_cst_compare (low, max_value) > 0))\n-\treturn head;\n-      low = fold_convert (type, low);\n-      high = low;\n-    }\n-  else\n-    {\n-      /* If the entire case range is unreachable, ignore it.  */\n-      if ((TREE_CODE (min_value) == INTEGER_CST\n-            && tree_int_cst_compare (high, min_value) < 0)\n-\t  || (TREE_CODE (max_value) == INTEGER_CST\n-\t      && tree_int_cst_compare (low, max_value) > 0))\n-\treturn head;\n-\n-      /* If the lower bound is less than the index type's minimum\n-\t value, truncate the range bounds.  */\n-      if (TREE_CODE (min_value) == INTEGER_CST\n-            && tree_int_cst_compare (low, min_value) < 0)\n-\tlow = min_value;\n-      low = fold_convert (type, low);\n-\n-      /* If the upper bound is greater than the index type's maximum\n-\t value, truncate the range bounds.  */\n-      if (TREE_CODE (max_value) == INTEGER_CST\n-\t  && tree_int_cst_compare (high, max_value) > 0)\n-\thigh = max_value;\n-      high = fold_convert (type, high);\n-    }\n-\n+  gcc_checking_assert (low);\n+  gcc_checking_assert (! high || (TREE_TYPE (low) == TREE_TYPE (high)));\n \n   /* Add this label to the chain.  Make sure to drop overflow flags.  */\n   r = (struct case_node *) pool_alloc (case_node_pool);\n-  r->low = build_int_cst_wide (TREE_TYPE (low), TREE_INT_CST_LOW (low),\n+  r->low = build_int_cst_wide (type, TREE_INT_CST_LOW (low),\n \t\t\t       TREE_INT_CST_HIGH (low));\n-  r->high = build_int_cst_wide (TREE_TYPE (high), TREE_INT_CST_LOW (high),\n+  r->high = build_int_cst_wide (type, TREE_INT_CST_LOW (high),\n \t\t\t\tTREE_INT_CST_HIGH (high));\n   r->code_label = label;\n   r->parent = r->left = NULL;\n@@ -2151,9 +2110,12 @@ expand_case (gimple stmt)\n \t  gcc_assert (low);\n \t  high = CASE_HIGH (elt);\n \n-\t  /* Discard empty ranges.  */\n-\t  if (high && tree_int_cst_lt (high, low))\n-\t    continue;\n+\t  /* The canonical from of a case label in GIMPLE is that a simple case\n+\t     has an empty CASE_HIGH.  For the casesi and tablejump expanders,\n+\t     the back ends want simple cases to have high == low.  */\n+\t  gcc_assert (! high || tree_int_cst_lt (low, high));\n+\t  if (! high)\n+\t    high = low;\n \n \t  case_list = add_case_node (case_list, index_type, low, high,\n                                      CASE_LABEL (elt), case_node_pool);\n@@ -2199,16 +2161,10 @@ expand_case (gimple stmt)\n       BITMAP_FREE (label_bitmap);\n \n       /* cleanup_tree_cfg removes all SWITCH_EXPR with a single\n-\t destination, such as one with a default case only.  However,\n-\t it doesn't remove cases that are out of range for the switch\n-\t type, so we may still get a zero here.  */\n-      if (count == 0)\n-\t{\n-\t  if (default_label)\n-\t    emit_jump (default_label);\n-          free_alloc_pool (case_node_pool);\n-\t  return;\n-\t}\n+\t destination, such as one with a default case only.\n+\t It also removes cases that are out of range for the switch\n+\t type, so we should never get a zero here.  */\n+      gcc_assert (count > 0);\n \n       /* Compute span of values.  */\n       range = fold_build2 (MINUS_EXPR, index_type, maxval, minval);"}, {"sha": "da0b029cdbe64022a69f3dde60e17500376f5b94", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd2402db7edd870e3219e436947e75f5ae186fd/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=0cd2402db7edd870e3219e436947e75f5ae186fd", "patch": "@@ -1200,7 +1200,8 @@ default_target_can_inline_p (tree caller, tree callee)\n    this means extra overhead for dispatch tables, which raises the\n    threshold for using them.  */\n \n-unsigned int default_case_values_threshold (void)\n+unsigned int\n+default_case_values_threshold (void)\n {\n   return (HAVE_casesi ? 4 : 5);\n }"}]}