{"sha": "b28b621ac67beee81a47adb50b954bcf751570fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI4YjYyMWFjNjdiZWVlODFhNDdhZGI1MGI5NTRiY2Y3NTE1NzBmZA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-17T13:16:02Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-17T13:16:02Z"}, "message": "c++: requires-expressions and partial instantiation [PR96410]\n\nThis patch makes tsubst_requires_expr avoid substituting into a\nrequires-expression when partially instantiating a generic lambda.\nThis is necessary in general to ensure that we always check requirements\nin lexical order (as in the first testcase below).  A mechanism similar\nto PACK_EXPANSION_EXTRA_ARGS is added to remember template arguments and\ndefer substitution of requires-expressions.\n\nIncidentally, this change also fixes the two mentioned PRs -- the\nproblem there is that tsubst_requires_expr was performing semantic\nchecks on template trees, and some of the checks are not prepared to\nhandle such trees.  With this patch, tsubst_requires_expr no longer\ndoes any semantic checking at all when processing_template_decl.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/96409\n\tPR c++/96410\n\t* constraint.cc (tsubst_requires_expr): Use REQUIRES_EXPR_PARMS\n\tand REQUIRES_EXPR_REQS.  Use REQUIRES_EXPR_EXTRA_ARGS,\n\tadd_extra_args and build_extra_args to defer substitution until\n\twe have all the template arguments.\n\t(finish_requires_expr): Adjust the call to build_min so that\n\tREQUIRES_EXPR_EXTRA_ARGS gets set to NULL_TREE.\n\t* cp-tree.def (REQUIRES_EXPR): Give it a third operand.\n\t* cp-tree.h (REQUIRES_EXPR_PARMS, REQUIRES_EXPR_REQS,\n\tREQUIRES_EXPR_EXTRA_ARGS): Define.\n\t(add_extra_args, build_extra_args): Declare.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/96409\n\tPR c++/96410\n\t* g++.dg/cpp2a/concepts-lambda13.C: New test.\n\t* g++.dg/cpp2a/concepts-lambda14.C: New test.", "tree": {"sha": "8fa20ad6c88d0c2bf9f95239a059df843e92bad2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fa20ad6c88d0c2bf9f95239a059df843e92bad2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b28b621ac67beee81a47adb50b954bcf751570fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b28b621ac67beee81a47adb50b954bcf751570fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b28b621ac67beee81a47adb50b954bcf751570fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b28b621ac67beee81a47adb50b954bcf751570fd/comments", "author": null, "committer": null, "parents": [{"sha": "9fcedcc39153cb3cfa08ebab20aef6cdfb9ed609", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fcedcc39153cb3cfa08ebab20aef6cdfb9ed609", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fcedcc39153cb3cfa08ebab20aef6cdfb9ed609"}], "stats": {"total": 89, "additions": 80, "deletions": 9}, "files": [{"sha": "0aab3073cc1f4c5e164b7944d4aeb34f445fdac6", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28b621ac67beee81a47adb50b954bcf751570fd/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28b621ac67beee81a47adb50b954bcf751570fd/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=b28b621ac67beee81a47adb50b954bcf751570fd", "patch": "@@ -2175,22 +2175,31 @@ tsubst_requires_expr (tree t, tree args,\n   /* A requires-expression is an unevaluated context.  */\n   cp_unevaluated u;\n \n-  tree parms = TREE_OPERAND (t, 0);\n+  args = add_extra_args (REQUIRES_EXPR_EXTRA_ARGS (t), args);\n+  if (processing_template_decl)\n+    {\n+      /* We're partially instantiating a generic lambda.  Substituting into\n+\t this requires-expression now may cause its requirements to get\n+\t checked out of order, so instead just remember the template\n+\t arguments and wait until we can substitute them all at once.  */\n+      t = copy_node (t);\n+      REQUIRES_EXPR_EXTRA_ARGS (t) = build_extra_args (t, args, complain);\n+      return t;\n+    }\n+\n+  tree parms = REQUIRES_EXPR_PARMS (t);\n   if (parms)\n     {\n       parms = tsubst_constraint_variables (parms, args, info);\n       if (parms == error_mark_node)\n \treturn boolean_false_node;\n     }\n \n-  tree reqs = TREE_OPERAND (t, 1);\n+  tree reqs = REQUIRES_EXPR_REQS (t);\n   reqs = tsubst_requirement_body (reqs, args, info);\n   if (reqs == error_mark_node)\n     return boolean_false_node;\n \n-  if (processing_template_decl)\n-    return finish_requires_expr (cp_expr_location (t), parms, reqs);\n-\n   return boolean_true_node;\n }\n \n@@ -2933,7 +2942,7 @@ finish_requires_expr (location_t loc, tree parms, tree reqs)\n     }\n \n   /* Build the node. */\n-  tree r = build_min (REQUIRES_EXPR, boolean_type_node, parms, reqs);\n+  tree r = build_min (REQUIRES_EXPR, boolean_type_node, parms, reqs, NULL_TREE);\n   TREE_SIDE_EFFECTS (r) = false;\n   TREE_CONSTANT (r) = true;\n   SET_EXPR_LOCATION (r, loc);"}, {"sha": "6eabe0d6d8f1ffbc063812bf2c256fe3bd0c0495", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28b621ac67beee81a47adb50b954bcf751570fd/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28b621ac67beee81a47adb50b954bcf751570fd/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=b28b621ac67beee81a47adb50b954bcf751570fd", "patch": "@@ -524,11 +524,13 @@ DEFTREECODE (CONSTRAINT_INFO, \"constraint_info\", tcc_exceptional, 0)\n    of the wildcard.  */\n DEFTREECODE (WILDCARD_DECL, \"wildcard_decl\", tcc_declaration, 0)\n \n-/* A requires-expr is a binary expression. The first operand is\n+/* A requires-expr has three operands. The first operand is\n    its parameter list (possibly NULL). The second is a list of\n    requirements, which are denoted by the _REQ* tree codes\n-   below. */\n-DEFTREECODE (REQUIRES_EXPR,   \"requires_expr\", tcc_expression, 2)\n+   below.  The third is a TREE_VEC of template arguments to\n+   be applied when substituting into the parameter list and\n+   requirements, set by tsubst_requires_expr for partial instantiations.  */\n+DEFTREECODE (REQUIRES_EXPR,   \"requires_expr\", tcc_expression, 3)\n \n /* A requirement for an expression. */\n DEFTREECODE (SIMPLE_REQ, \"simple_req\", tcc_expression, 1)"}, {"sha": "08976d8527c4b09d7c2307db0c494fdc1229416f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28b621ac67beee81a47adb50b954bcf751570fd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28b621ac67beee81a47adb50b954bcf751570fd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b28b621ac67beee81a47adb50b954bcf751570fd", "patch": "@@ -1618,6 +1618,21 @@ check_constraint_info (tree t)\n #define CONSTRAINED_PARM_PROTOTYPE(NODE) \\\n   DECL_INITIAL (TYPE_DECL_CHECK (NODE))\n \n+/* The list of local parameters introduced by this requires-expression,\n+   in the form of a chain of PARM_DECLs.  */\n+#define REQUIRES_EXPR_PARMS(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, REQUIRES_EXPR), 0)\n+\n+/* A TREE_LIST of the requirements for this requires-expression.\n+   The requirements are stored in lexical order within the TREE_VALUE\n+   of each TREE_LIST node.  The TREE_PURPOSE of each node is unused.  */\n+#define REQUIRES_EXPR_REQS(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, REQUIRES_EXPR), 1)\n+\n+/* Like PACK_EXPANSION_EXTRA_ARGS, for requires-expressions.  */\n+#define REQUIRES_EXPR_EXTRA_ARGS(NODE) \\\n+  TREE_OPERAND (TREE_CHECK (NODE, REQUIRES_EXPR), 2)\n+\n enum cp_tree_node_structure_enum {\n   TS_CP_GENERIC,\n   TS_CP_IDENTIFIER,\n@@ -7013,6 +7028,8 @@ extern bool template_guide_p\t\t\t(const_tree);\n extern bool builtin_guide_p\t\t\t(const_tree);\n extern void store_explicit_specifier\t\t(tree, tree);\n extern tree add_outermost_template_args\t\t(tree, tree);\n+extern tree add_extra_args\t\t\t(tree, tree);\n+extern tree build_extra_args\t\t\t(tree, tree, tsubst_flags_t);\n \n /* in rtti.c */\n /* A vector of all tinfo decls that haven't been emitted yet.  */"}, {"sha": "d4bed30a9001d7727e0efeb752c3cbed476670b9", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda13.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28b621ac67beee81a47adb50b954bcf751570fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28b621ac67beee81a47adb50b954bcf751570fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda13.C?ref=b28b621ac67beee81a47adb50b954bcf751570fd", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile { target c++20 } }\n+\n+template<typename T>\n+struct S {\n+  using type = T::type; // { dg-bogus \"\" }\n+};\n+\n+template<typename T>\n+auto f() {\n+  return [] <typename U> (U) {\n+    // Verify that partial instantiation of this generic lambda doesn't cause\n+    // these requirements to get checked out of order.\n+    static_assert(!requires { typename U::type; typename S<T>::type; });\n+    return 0;\n+  };\n+}\n+\n+int a = f<int>()(0);"}, {"sha": "bdc893da857727357687b0e9c9386175746155c3", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda14.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28b621ac67beee81a47adb50b954bcf751570fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28b621ac67beee81a47adb50b954bcf751570fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda14.C?ref=b28b621ac67beee81a47adb50b954bcf751570fd", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/96410\n+// { dg-do compile { target c++20 } }\n+\n+struct S { using blah = void; };\n+\n+template <typename T> constexpr bool trait = !__is_same(T, S);\n+template <typename T> concept C = trait<T>;\n+\n+template<typename T>\n+void foo() noexcept(!__is_same(T, void)) { }\n+\n+template<typename U>\n+auto f() {\n+  return []<typename T>(T, bool a = requires { C<T>; }){\n+    static_assert(requires { requires C<U> && (C<T> || C<T>); }); // { dg-error \"assert\" }\n+    static_assert(requires { C<T>; });\n+    static_assert(requires { { foo<T>() } noexcept -> C; });\n+    static_assert(!requires { typename T::blah; }); // { dg-error \"assert\" }\n+    return 0;\n+  };\n+}\n+\n+auto g = f<int>(); // { dg-bogus \"\" }\n+int n = g(0); // { dg-bogus \"\" }\n+int m = g(S{}); // { dg-message \"required from here\" }"}]}