{"sha": "55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVkMGU1ZTAyMjNiYWUyYjY0ZmFmNGI4NThiNTllYjQ4NmVmYmU0Yg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2003-01-24T20:02:11Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-01-24T20:02:11Z"}, "message": "Makefile.in (CFILES): Add pex-*.c.\n\n\t* Makefile.in (CFILES): Add pex-*.c.\n\t(REQUIRED_OFILES): Change pexecute.o to @pexecute@\n\t(CONFIGURED_OFILES): Add pex-*.o.\n\t(TEXIFILES): Add pexecute.txh.\n\t(pexecute.o): Delete rule.\n\t(pex-cygwin.o, pex-djgpp.o, pex-mpw.o, pex-msdos.o, pex-os2.o,\n\tpex-unix.o, pex-win32.o): New rules.\n\t* configure.in: Change AC_INIT argument to xmalloc.c.\n\tCompute appropriate pexecute implementation and substitute it\n\tas @pexecute@.\n\n\t* pexecute.c: Split up into...\n\t* pex-cygwin.c, pex-djgpp.c, pex-mpw.c, pex-msdos.c, pex-os2.c,\n\tpex-unix.c, pex-win32.c, pex-common.h, pexecute.txh: ... these\n\tnew files.\n\n\t* functions.texi: Regenerate.\n\t* configure: Regenerate.\n\nFrom-SVN: r61728", "tree": {"sha": "a5a1f317d0d5eb9f7466940f45f70923df577e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5a1f317d0d5eb9f7466940f45f70923df577e59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/comments", "author": null, "committer": null, "parents": [{"sha": "4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566"}], "stats": {"total": 2068, "additions": 1225, "deletions": 843}, "files": [{"sha": "6563cfe4210d7996ad82b887afacb0a5dc6d334b", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -1,3 +1,24 @@\n+2003-01-24  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* Makefile.in (CFILES): Add pex-*.c.\n+\t(REQUIRED_OFILES): Change pexecute.o to @pexecute@\n+\t(CONFIGURED_OFILES): Add pex-*.o.\n+\t(TEXIFILES): Add pexecute.txh.\n+\t(pexecute.o): Delete rule.\n+\t(pex-cygwin.o, pex-djgpp.o, pex-mpw.o, pex-msdos.o, pex-os2.o,\n+\tpex-unix.o, pex-win32.o): New rules.\n+\t* configure.in: Change AC_INIT argument to xmalloc.c.\n+\tCompute appropriate pexecute implementation and substitute it\n+\tas @pexecute@.\n+\n+\t* pexecute.c: Split up into...\n+\t* pex-cygwin.c, pex-djgpp.c, pex-mpw.c, pex-msdos.c, pex-os2.c,\n+\tpex-unix.c, pex-win32.c, pex-common.h, pexecute.txh: ... these\n+\tnew files.\n+\n+\t* functions.texi: Regenerate.\n+\t* configure: Regenerate.\n+\n 2003-01-20  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* hashtab.c (htab_expand): Fix allocation of new entries."}, {"sha": "18c49a13df83f5b8dcb976fef6ac2ad5602dcde3", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -140,7 +140,10 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \tmake-temp-file.c md5.c memchr.c memcmp.c memcpy.c memmove.c\t\\\n \t memset.c mkstemps.c\t\t\t\t\t\t\\\n \tobjalloc.c obstack.c\t\t\t\t\t\t\\\n-\tpartition.c pexecute.c putenv.c\t\t\t\t\t\\\n+\tpartition.c\t\t\t\t\t\t\t\\\n+\t pex-cygwin.c pex-djgpp.c pex-mpw.c pex-msdos.c pex-os2.c\t\\\n+\t pex-unix.c pex-win32.c\t\t\t\t\t\t\\\n+         putenv.c\t\t\t\t\t\t\t\\\n \trandom.c regex.c rename.c rindex.c\t\t\t\t\\\n \tsafe-ctype.c setenv.c sigsetmask.c sort.c spaces.c\t\t\\\n \t splay-tree.c strcasecmp.c strchr.c strdup.c strerror.c\t\t\\\n@@ -164,7 +167,7 @@ REQUIRED_OFILES = regex.o cplus-dem.o cp-demangle.o md5.o\t\t\\\n \tmake-relative-prefix.o\t\t\t\t\t\t\\\n \tmake-temp-file.o\t\t\t\t\t\t\\\n \tobjalloc.o obstack.o\t\t\t\t\t\t\\\n-\tpartition.o pexecute.o\t\t\t\t\t\t\\\n+\tpartition.o @pexecute@\t\t\t\t\t\t\\\n \tsafe-ctype.o sort.o spaces.o splay-tree.o strerror.o\t\t\\\n \t strsignal.o\t\t\t\t\t\t\t\\\n \tternary.o\t\t\t\t\t\t\t\\\n@@ -181,7 +184,9 @@ CONFIGURED_OFILES = asprintf.o atexit.o\t\t\t\t\t\\\n \tgetcwd.o getpagesize.o\t\t\t\t\t\t\\\n \tindex.o insque.o\t\t\t\t\t\t\\\n \tmemchr.o memcmp.o memcpy.o memmove.o memset.o mkstemps.o\t\\\n-\tputenv.o\t\t\t\t\t\t\t\\\n+\tpex-cygwin.o pex-djgpp.o pex-mpw.o pex-msdos.o pex-os2.o\t\\\n+\t pex-unix.o pex-win32.o\t\t\t\t\t\t\\\n+\t putenv.o\t\t\t\t\t\t\t\\\n \trandom.o rename.o rindex.o\t\t\t\t\t\\\n \tsetenv.o sigsetmask.o strcasecmp.o strchr.o strdup.o\t\t\\\n \t strncasecmp.o strncmp.o strrchr.o strstr.o strtod.o strtol.o\t\\\n@@ -240,7 +245,7 @@ TEXISRC = \\\n # Additional files that have texi snippets that need to be collected\n # and sorted.  Some are here because the sources are imported from\n # elsewhere.  Others represent headers in ../include.\n-TEXIFILES = fnmatch.txh\n+TEXIFILES = fnmatch.txh pexecute.txh\n \n libiberty.info : $(srcdir)/libiberty.texi $(TEXISRC)\n \t$(MAKEINFO) -I$(srcdir) $(srcdir)/libiberty.texi\n@@ -450,8 +455,14 @@ objalloc.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/objalloc.h\n obstack.o: config.h $(INCDIR)/obstack.h\n partition.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n \t$(INCDIR)/partition.h\n-pexecute.o: config.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n+pex-cygwin.o: config.h pex-common.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n+pex-djgpp.o: config.h pex-common.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n+pex-mpw.o: config.h pex-common.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n+pex-msdos.o: config.h pex-common.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n \t$(INCDIR)/safe-ctype.h\n+pex-os2.o: config.h pex-common.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n+pex-unix.o: config.h pex-common.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n+pex-win32.o: config.h pex-common.h $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h\n putenv.o: config.h $(INCDIR)/ansidecl.h\n random.o: $(INCDIR)/ansidecl.h\n regex.o: config.h $(INCDIR)/xregex.h $(INCDIR)/xregex2.h"}, {"sha": "06ec934e27a2ff619a398c357192b14822c8c362", "filename": "libiberty/configure", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -465,7 +465,7 @@ echo > confdefs.h\n \n # A filename unique to this package, relative to the directory that\n # configure is in, which we can look for to find out if srcdir is correct.\n-ac_unique_file=pexecute.c\n+ac_unique_file=xmalloc.c\n \n # Find the source files, if location was not specified.\n if test -z \"$srcdir\"; then\n@@ -2993,21 +2993,32 @@ done\n \n fi\n \n-for ac_hdr in stdlib.h unistd.h sys/stat.h sys/types.h\n+# Figure out which version of pexecute to use.\n+case \"${host}\" in\n+     *-*-cygwin*)\t\tpexecute=pex-cygwin.o ;;\n+     *-*-mingw* | *-*-winnt*)\tpexecute=pex-win32.o  ;;\n+     *-*-msdosdjgpp*)\t\tpexecute=pex-djgpp.o  ;;\n+     *-*-msdos*)\t\tpexecute=pex-msdos.o  ;;\n+     *-*-os2-emx*)\t\tpexecute=pex-os2.o    ;;\n+     *)\t\t\t\tpexecute=pex-unix.o   ;;\n+esac\n+\n+\n+for ac_hdr in unistd.h\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:3001: checking for $ac_hdr\" >&5\n+echo \"configure:3012: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3006 \"configure\"\n+#line 3017 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:3011: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:3022: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -3036,12 +3047,12 @@ done\n for ac_func in getpagesize\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3040: checking for $ac_func\" >&5\n+echo \"configure:3051: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3045 \"configure\"\n+#line 3056 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3064,7 +3075,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3068: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3079: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3089,15 +3100,15 @@ fi\n done\n \n echo $ac_n \"checking for working mmap\"\"... $ac_c\" 1>&6\n-echo \"configure:3093: checking for working mmap\" >&5\n+echo \"configure:3104: checking for working mmap\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_mmap_fixed_mapped'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_func_mmap_fixed_mapped=no\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3101 \"configure\"\n+#line 3112 \"configure\"\n #include \"confdefs.h\"\n \n /* Thanks to Mike Haertel and Jim Avera for this test.\n@@ -3125,24 +3136,11 @@ else\n #include <fcntl.h>\n #include <sys/mman.h>\n \n-#if HAVE_SYS_TYPES_H\n-# include <sys/types.h>\n-#endif\n-\n-#if HAVE_STDLIB_H\n-# include <stdlib.h>\n-#endif\n-\n-#if HAVE_SYS_STAT_H\n-# include <sys/stat.h>\n-#endif\n-\n-#if HAVE_UNISTD_H\n-# include <unistd.h>\n-#endif\n-\n /* This mess was copied from the GNU getpagesize.h.  */\n #ifndef HAVE_GETPAGESIZE\n+# ifdef HAVE_UNISTD_H\n+#  include <unistd.h>\n+# endif\n \n /* Assume that all systems that can run configure have sys/param.h.  */\n # ifndef HAVE_SYS_PARAM_H\n@@ -3250,7 +3248,7 @@ main()\n }\n \n EOF\n-if { (eval echo configure:3254: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:3252: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_func_mmap_fixed_mapped=yes\n else\n@@ -3274,15 +3272,15 @@ fi\n \n \n echo $ac_n \"checking for working strncmp\"\"... $ac_c\" 1>&6\n-echo \"configure:3278: checking for working strncmp\" >&5\n+echo \"configure:3276: checking for working strncmp\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_strncmp_works'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_func_strncmp_works=no\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3286 \"configure\"\n+#line 3284 \"configure\"\n #include \"confdefs.h\"\n \n /* Test by Jim Wilson and Kaveh Ghazi.\n@@ -3346,7 +3344,7 @@ main ()\n }\n \n EOF\n-if { (eval echo configure:3350: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:3348: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_func_strncmp_works=yes\n else\n@@ -3541,6 +3539,7 @@ s%@CPP@%$CPP%g\n s%@CHECK@%$CHECK%g\n s%@target_header_dir@%$target_header_dir%g\n s%@LIBOBJS@%$LIBOBJS%g\n+s%@pexecute@%$pexecute%g\n s%@INSTALL_DEST@%$INSTALL_DEST%g\n \n CEOF"}, {"sha": "5b58ddb8a1cdad8ed39af6ccac8fafd07a493588", "filename": "libiberty/configure.in", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure.in?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -1,7 +1,7 @@\n dnl Process this file with autoconf to produce a configure script\n \n AC_PREREQ(2.13)\n-AC_INIT(pexecute.c)\n+AC_INIT(xmalloc.c)\n \n # This works around the fact that libtool configuration may change LD\n # for this particular configuration, but some shells, instead of\n@@ -425,6 +425,17 @@ if test -z \"${setobjs}\"; then\n   AC_CHECK_FUNCS($checkfuncs)\n fi\n \n+# Figure out which version of pexecute to use.\n+case \"${host}\" in\n+     *-*-cygwin*)\t\tpexecute=pex-cygwin.o ;;\n+     *-*-mingw* | *-*-winnt*)\tpexecute=pex-win32.o  ;;\n+     *-*-msdosdjgpp*)\t\tpexecute=pex-djgpp.o  ;;\n+     *-*-msdos*)\t\tpexecute=pex-msdos.o  ;;\n+     *-*-os2-emx*)\t\tpexecute=pex-os2.o    ;;\n+     *)\t\t\t\tpexecute=pex-unix.o   ;;\n+esac\n+AC_SUBST(pexecute)\n+\n libiberty_AC_FUNC_STRNCMP\n \n # Install a library built with a cross compiler in $(tooldir) rather"}, {"sha": "18b2480a78157486f90404ca1553b339694cb44b", "filename": "libiberty/functions.texi", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Ffunctions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Ffunctions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffunctions.texi?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -483,7 +483,7 @@ reading and writing.\n \n @end deftypefn\n \n-@c pexecute.c:67\n+@c pexecute.txh:1\n @deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)\n \n Executes a program.\n@@ -498,14 +498,15 @@ use if needed.  This is currently only needed for MS-DOS ports that\n don't use @code{go32} (do any still exist?).  Ports that don't need it\n can pass @code{NULL}.\n \n-(@code{@var{flags} & PEXECUTE_SEARCH}) is non-zero if @env{PATH} should be searched\n-(??? It's not clear that GCC passes this flag correctly).  (@code{@var{flags} &\n-PEXECUTE_FIRST}) is nonzero for the first process in chain.\n-(@code{@var{flags} & PEXECUTE_FIRST}) is nonzero for the last process\n-in chain.  The first/last flags could be simplified to only mark the\n-last of a chain of processes but that requires the caller to always\n-mark the last one (and not give up early if some error occurs).\n-It's more robust to require the caller to mark both ends of the chain.\n+(@code{@var{flags} & PEXECUTE_SEARCH}) is non-zero if @env{PATH}\n+should be searched (??? It's not clear that GCC passes this flag\n+correctly).  (@code{@var{flags} & PEXECUTE_FIRST}) is nonzero for the\n+first process in chain.  (@code{@var{flags} & PEXECUTE_FIRST}) is\n+nonzero for the last process in chain.  The first/last flags could be\n+simplified to only mark the last of a chain of processes but that\n+requires the caller to always mark the last one (and not give up\n+early if some error occurs).  It's more robust to require the caller\n+to mark both ends of the chain.\n \n The result is the pid on systems like Unix where we\n @code{fork}/@code{exec} and on systems like WIN32 and OS/2 where we\n@@ -540,21 +541,23 @@ name is unset/removed.\n \n @end deftypefn\n \n-@c pexecute.c:104\n+@c pexecute.txh:39\n @deftypefn Extension int pwait (int @var{pid}, int *@var{status}, int @var{flags})\n \n Waits for a program started by @code{pexecute} to finish.\n \n @var{pid} is the process id of the task to wait for. @var{status} is\n-the `status' argument to wait. @var{flags} is currently unused (allows\n-future enhancement without breaking upward compatibility).  Pass 0 for now.\n+the `status' argument to wait. @var{flags} is currently unused\n+(allows future enhancement without breaking upward compatibility).\n+Pass 0 for now.\n \n The result is the pid of the child reaped, or -1 for failure\n (@code{errno} says why).\n \n-On systems that don't support waiting for a particular child, @var{pid} is\n-ignored.  On systems like MS-DOS that don't really multitask @code{pwait}\n-is just a mechanism to provide a consistent interface for the caller.\n+On systems that don't support waiting for a particular child,\n+@var{pid} is ignored.  On systems like MS-DOS that don't really\n+multitask @code{pwait} is just a mechanism to provide a consistent\n+interface for the caller.\n \n @end deftypefn\n "}, {"sha": "da2f71e1247aa1bf5f0fbc013033678c7d7c2e75", "filename": "libiberty/pex-common.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-common.h?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -0,0 +1,42 @@\n+/* Utilities to execute a program in a subprocess (possibly linked by pipes\n+   with other subprocesses), and wait for it.  Shared logic.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef PEX_COMMON_H\n+#define PEX_COMMON_H\n+\n+#include \"config.h\"\n+#include \"libiberty.h\"\n+\n+#define install_error_msg \"installation problem, cannot exec `%s'\"\n+\n+/* stdin file number.  */\n+#define STDIN_FILE_NO 0\n+\n+/* stdout file number.  */\n+#define STDOUT_FILE_NO 1\n+\n+/* value of `pipe': port index for reading.  */\n+#define READ_PORT 0\n+\n+/* value of `pipe': port index for writing.  */\n+#define WRITE_PORT 1\n+\n+#endif"}, {"sha": "f5d18db3424380ff896632d0239bf500e0e12b01", "filename": "libiberty/pex-cygwin.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-cygwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-cygwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-cygwin.c?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -0,0 +1,132 @@\n+/* Utilities to execute a program in a subprocess (possibly linked by pipes\n+   with other subprocesses), and wait for it.  Cygwin specialization.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"pex-common.h\"\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#ifdef HAVE_SYS_WAIT_H\n+#include <sys/wait.h>\n+#endif\n+\n+#include <process.h>\n+#include <io.h>\n+#include <fcntl.h>\n+#include <signal.h>\n+\n+extern int _spawnv ();\n+extern int _spawnvp ();\n+\n+/* Win32 supports pipes, and Cygwin provides waitpid.  */\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  int pid;\n+  int pdes[2], org_stdin, org_stdout;\n+  int input_desc, output_desc;\n+  int retries, sleep_interval;\n+\n+  /* Pipe waiting from last process, to be used as input for the next one.\n+     Value is STDIN_FILE_NO if no pipe is waiting\n+     (i.e. the next command is the first of a group).  */\n+  static int last_pipe_input;\n+\n+  /* If this is the first process, initialize.  */\n+  if (flags & PEXECUTE_FIRST)\n+    last_pipe_input = STDIN_FILE_NO;\n+\n+  input_desc = last_pipe_input;\n+\n+  /* If this isn't the last process, make a pipe for its output,\n+     and record it as waiting to be the input to the next process.  */\n+  if (! (flags & PEXECUTE_LAST))\n+    {\n+      if (_pipe (pdes, 256, O_BINARY) < 0)\n+\t{\n+\t  *errmsg_fmt = \"pipe\";\n+\t  *errmsg_arg = NULL;\n+\t  return -1;\n+\t}\n+      output_desc = pdes[WRITE_PORT];\n+      last_pipe_input = pdes[READ_PORT];\n+    }\n+  else\n+    {\n+      /* Last process.  */\n+      output_desc = STDOUT_FILE_NO;\n+      last_pipe_input = STDIN_FILE_NO;\n+    }\n+\n+  if (input_desc != STDIN_FILE_NO)\n+    {\n+      org_stdin = dup (STDIN_FILE_NO);\n+      dup2 (input_desc, STDIN_FILE_NO);\n+      close (input_desc); \n+    }\n+\n+  if (output_desc != STDOUT_FILE_NO)\n+    {\n+      org_stdout = dup (STDOUT_FILE_NO);\n+      dup2 (output_desc, STDOUT_FILE_NO);\n+      close (output_desc);\n+    }\n+\n+  pid = (flags & PEXECUTE_SEARCH ? _spawnvp : _spawnv)\n+    (_P_NOWAIT, program, argv);\n+\n+  if (input_desc != STDIN_FILE_NO)\n+    {\n+      dup2 (org_stdin, STDIN_FILE_NO);\n+      close (org_stdin);\n+    }\n+\n+  if (output_desc != STDOUT_FILE_NO)\n+    {\n+      dup2 (org_stdout, STDOUT_FILE_NO);\n+      close (org_stdout);\n+    }\n+\n+  if (pid == -1)\n+    {\n+      *errmsg_fmt = install_error_msg;\n+      *errmsg_arg = program;\n+      return -1;\n+    }\n+\n+  return pid;\n+}\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags ATTRIBUTE_UNUSED;\n+{\n+  return waitpid (pid, status, 0);\n+}"}, {"sha": "968e784121515f35140244efc7c122f1e41c0e9b", "filename": "libiberty/pex-djgpp.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-djgpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-djgpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-djgpp.c?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -0,0 +1,103 @@\n+/* Utilities to execute a program in a subprocess (possibly linked by pipes\n+   with other subprocesses), and wait for it.  DJGPP specialization.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"pex-common.h\"\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#ifdef NEED_DECLARATION_ERRNO\n+extern int errno;\n+#endif\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#include <process.h>\n+\n+/* Use ECHILD if available, otherwise use EINVAL.  */\n+#ifdef ECHILD\n+#define PWAIT_ERROR ECHILD\n+#else\n+#define PWAIT_ERROR EINVAL\n+#endif\n+\n+/* MSDOS doesn't multitask, but for the sake of a consistent interface\n+   the code behaves like it does.  pexecute runs the program, tucks the\n+   exit code away, and returns a \"pid\".  pwait must be called to fetch the\n+   exit code.  */\n+\n+/* For communicating information from pexecute to pwait.  */\n+static int last_pid = 0;\n+static int last_status = 0;\n+static int last_reaped = 0;\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  int rc;\n+\n+  last_pid++;\n+  if (last_pid < 0)\n+    last_pid = 1;\n+\n+  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n+    abort ();\n+\n+  /* ??? What are the possible return values from spawnv?  */\n+  rc = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (P_WAIT, program, argv);\n+\n+  if (rc == -1)\n+    {\n+      *errmsg_fmt = install_error_msg;\n+      *errmsg_arg = (char *)program;\n+      return -1;\n+    }\n+\n+  /* Tuck the status away for pwait, and return a \"pid\".  */\n+  last_status = rc << 8;\n+  return last_pid;\n+}\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags;\n+{\n+  /* On MSDOS each pexecute must be followed by its associated pwait.  */\n+  if (pid != last_pid\n+      /* Called twice for the same child?  */\n+      || pid == last_reaped)\n+    {\n+      errno = PWAIT_ERROR;\n+      return -1;\n+    }\n+  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n+     Needed?  */\n+  *status = (last_status >> 8);\n+  last_reaped = last_pid;\n+  return last_pid;\n+}"}, {"sha": "9a8879c9b271e30201e698abe5e75104bf2453a9", "filename": "libiberty/pex-mpw.c", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-mpw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-mpw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-mpw.c?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -0,0 +1,161 @@\n+/* Utilities to execute a program in a subprocess (possibly linked by pipes\n+   with other subprocesses), and wait for it.  MPW specialization.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"pex-common.h\"\n+\n+#include <stdio.h>\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+\n+/* MPW pexecute doesn't actually run anything; instead, it writes out\n+   script commands that, when run, will do the actual executing.\n+\n+   For example, in GCC's case, GCC will write out several script commands:\n+\n+   cpp ...\n+   cc1 ...\n+   as ...\n+   ld ...\n+\n+   and then exit.  None of the above programs will have run yet.  The task\n+   that called GCC will then execute the script and cause cpp,etc. to run.\n+   The caller must invoke pfinish before calling exit.  This adds\n+   the finishing touches to the generated script.  */\n+\n+static int first_time = 1;\n+\n+extern void mpwify_filename PARAMS ((const char *, char *));\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  char tmpprogram[255];\n+  char *cp, *tmpname;\n+  int i;\n+\n+  mpwify_filename (program, tmpprogram);\n+  if (first_time)\n+    {\n+      printf (\"Set Failed 0\\n\");\n+      first_time = 0;\n+    }\n+\n+  fputs (\"If {Failed} == 0\\n\", stdout);\n+  /* If being verbose, output a copy of the command.  It should be\n+     accurate enough and escaped enough to be \"clickable\".  */\n+  if (flags & PEXECUTE_VERBOSE)\n+    {\n+      fputs (\"\\tEcho \", stdout);\n+      fputc ('\\'', stdout);\n+      fputs (tmpprogram, stdout);\n+      fputc ('\\'', stdout);\n+      fputc (' ', stdout);\n+      for (i=1; argv[i]; i++)\n+\t{\n+\t  fputc ('\\'', stdout);\n+\t  /* See if we have an argument that needs fixing.  */\n+\t  if (strchr(argv[i], '/'))\n+\t    {\n+\t      tmpname = (char *) xmalloc (256);\n+\t      mpwify_filename (argv[i], tmpname);\n+\t      argv[i] = tmpname;\n+\t    }\n+\t  for (cp = argv[i]; *cp; cp++)\n+\t    {\n+\t      /* Write an Option-d escape char in front of special chars.  */\n+\t      if (strchr(\"'+\", *cp))\n+\t\tfputc ('\\266', stdout);\n+\t      fputc (*cp, stdout);\n+\t    }\n+\t  fputc ('\\'', stdout);\n+\t  fputc (' ', stdout);\n+\t}\n+      fputs (\"\\n\", stdout);\n+    }\n+  fputs (\"\\t\", stdout);\n+  fputs (tmpprogram, stdout);\n+  fputc (' ', stdout);\n+\n+  for (i=1; argv[i]; i++)\n+    {\n+      /* See if we have an argument that needs fixing.  */\n+      if (strchr(argv[i], '/'))\n+\t{\n+\t  tmpname = (char *) xmalloc (256);\n+\t  mpwify_filename (argv[i], tmpname);\n+\t  argv[i] = tmpname;\n+\t}\n+      if (strchr (argv[i], ' '))\n+\tfputc ('\\'', stdout);\n+      for (cp = argv[i]; *cp; cp++)\n+\t{\n+\t  /* Write an Option-d escape char in front of special chars.  */\n+\t  if (strchr(\"'+\", *cp))\n+\t    fputc ('\\266', stdout);\n+\t  fputc (*cp, stdout);\n+\t}\n+      if (strchr (argv[i], ' '))\n+\tfputc ('\\'', stdout);\n+      fputc (' ', stdout);\n+    }\n+\n+  fputs (\"\\n\", stdout);\n+\n+  /* Output commands that arrange to clean up and exit if a failure occurs.\n+     We have to be careful to collect the status from the program that was\n+     run, rather than some other script command.  Also, we don't exit\n+     immediately, since necessary cleanups are at the end of the script.  */\n+  fputs (\"\\tSet TmpStatus {Status}\\n\", stdout);\n+  fputs (\"\\tIf {TmpStatus} != 0\\n\", stdout);\n+  fputs (\"\\t\\tSet Failed {TmpStatus}\\n\", stdout);\n+  fputs (\"\\tEnd\\n\", stdout);\n+  fputs (\"End\\n\", stdout);\n+\n+  /* We're just composing a script, can't fail here.  */\n+  return 0;\n+}\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags;\n+{\n+  *status = 0;\n+  return 0;\n+}\n+\n+/* Write out commands that will exit with the correct error code\n+   if something in the script failed.  */\n+\n+void\n+pfinish ()\n+{\n+  printf (\"\\tExit \\\"{Failed}\\\"\\n\");\n+}\n+"}, {"sha": "d61c129b97f53fb8a21d98282257990735f74a41", "filename": "libiberty/pex-msdos.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-msdos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-msdos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-msdos.c?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -0,0 +1,147 @@\n+/* Utilities to execute a program in a subprocess (possibly linked by pipes\n+   with other subprocesses), and wait for it.  Generic MSDOS specialization.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"pex-common.h\"\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#ifdef NEED_DECLARATION_ERRNO\n+extern int errno;\n+#endif\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#include \"safe-ctype.h\"\n+#include <process.h>\n+\n+/* MSDOS doesn't multitask, but for the sake of a consistent interface\n+   the code behaves like it does.  pexecute runs the program, tucks the\n+   exit code away, and returns a \"pid\".  pwait must be called to fetch the\n+   exit code.  */\n+\n+/* For communicating information from pexecute to pwait.  */\n+static int last_pid = 0;\n+static int last_status = 0;\n+static int last_reaped = 0;\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  int rc;\n+  char *scmd, *rf;\n+  FILE *argfile;\n+  int i, el = flags & PEXECUTE_SEARCH ? 4 : 0;\n+\n+  last_pid++;\n+  if (last_pid < 0)\n+    last_pid = 1;\n+\n+  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n+    abort ();\n+\n+  if (temp_base == 0)\n+    temp_base = choose_temp_base ();\n+  scmd = (char *) xmalloc (strlen (program) + strlen (temp_base) + 6 + el);\n+  rf = scmd + strlen(program) + 2 + el;\n+  sprintf (scmd, \"%s%s @%s.gp\", program,\n+\t   (flags & PEXECUTE_SEARCH ? \".exe\" : \"\"), temp_base);\n+  argfile = fopen (rf, \"w\");\n+  if (argfile == 0)\n+    {\n+      int errno_save = errno;\n+      free (scmd);\n+      errno = errno_save;\n+      *errmsg_fmt = \"cannot open `%s.gp'\";\n+      *errmsg_arg = temp_base;\n+      return -1;\n+    }\n+\n+  for (i=1; argv[i]; i++)\n+    {\n+      char *cp;\n+      for (cp = argv[i]; *cp; cp++)\n+\t{\n+\t  if (*cp == '\"' || *cp == '\\'' || *cp == '\\\\' || ISSPACE (*cp))\n+\t    fputc ('\\\\', argfile);\n+\t  fputc (*cp, argfile);\n+\t}\n+      fputc ('\\n', argfile);\n+    }\n+  fclose (argfile);\n+\n+  rc = system (scmd);\n+\n+  {\n+    int errno_save = errno;\n+    remove (rf);\n+    free (scmd);\n+    errno = errno_save;\n+  }\n+\n+  if (rc == -1)\n+    {\n+      *errmsg_fmt = install_error_msg;\n+      *errmsg_arg = (char *)program;\n+      return -1;\n+    }\n+\n+  /* Tuck the status away for pwait, and return a \"pid\".  */\n+  last_status = rc << 8;\n+  return last_pid;\n+}\n+\n+/* Use ECHILD if available, otherwise use EINVAL.  */\n+#ifdef ECHILD\n+#define PWAIT_ERROR ECHILD\n+#else\n+#define PWAIT_ERROR EINVAL\n+#endif\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags;\n+{\n+  /* On MSDOS each pexecute must be followed by its associated pwait.  */\n+  if (pid != last_pid\n+      /* Called twice for the same child?  */\n+      || pid == last_reaped)\n+    {\n+      errno = PWAIT_ERROR;\n+      return -1;\n+    }\n+  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n+     Needed?  */\n+  *status = last_status;\n+  last_reaped = last_pid;\n+  return last_pid;\n+}"}, {"sha": "d9eacf1f8f3463744b64a23dfe344e203f8a7f2e", "filename": "libiberty/pex-os2.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-os2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-os2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-os2.c?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -0,0 +1,72 @@\n+/* Utilities to execute a program in a subprocess (possibly linked by pipes\n+   with other subprocesses), and wait for it.  OS/2 specialization.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"pex-common.h\"\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_SYS_WAIT_H\n+#include <sys/wait.h>\n+#endif\n+\n+/* ??? Does OS2 have process.h?  */\n+extern int spawnv ();\n+extern int spawnvp ();\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  int pid;\n+\n+  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n+    abort ();\n+  /* ??? Presumably 1 == _P_NOWAIT.  */\n+  pid = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (1, program, argv);\n+  if (pid == -1)\n+    {\n+      *errmsg_fmt = install_error_msg;\n+      *errmsg_arg = program;\n+      return -1;\n+    }\n+  return pid;\n+}\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags;\n+{\n+  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n+     Needed?  */\n+  int pid = wait (status);\n+  return pid;\n+}"}, {"sha": "14fe71ed09c0f1e46bcb93e6df3e80eb3ed3e00c", "filename": "libiberty/pex-unix.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-unix.c?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -0,0 +1,166 @@\n+/* Utilities to execute a program in a subprocess (possibly linked by pipes\n+   with other subprocesses), and wait for it.  Generic Unix version\n+   (also used for UWIN and VMS).\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"pex-common.h\"\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#ifdef NEED_DECLARATION_ERRNO\n+extern int errno;\n+#endif\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_SYS_WAIT_H\n+#include <sys/wait.h>\n+#endif\n+\n+#ifndef HAVE_WAITPID\n+#define waitpid(pid, status, flags) wait(status)\n+#endif\n+\n+extern int execv ();\n+extern int execvp ();\n+\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base ATTRIBUTE_UNUSED;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  int (*func)() = (flags & PEXECUTE_SEARCH ? execvp : execv);\n+  int pid;\n+  int pdes[2];\n+  int input_desc, output_desc;\n+  int retries, sleep_interval;\n+  /* Pipe waiting from last process, to be used as input for the next one.\n+     Value is STDIN_FILE_NO if no pipe is waiting\n+     (i.e. the next command is the first of a group).  */\n+  static int last_pipe_input;\n+\n+  /* If this is the first process, initialize.  */\n+  if (flags & PEXECUTE_FIRST)\n+    last_pipe_input = STDIN_FILE_NO;\n+\n+  input_desc = last_pipe_input;\n+\n+  /* If this isn't the last process, make a pipe for its output,\n+     and record it as waiting to be the input to the next process.  */\n+  if (! (flags & PEXECUTE_LAST))\n+    {\n+      if (pipe (pdes) < 0)\n+\t{\n+\t  *errmsg_fmt = \"pipe\";\n+\t  *errmsg_arg = NULL;\n+\t  return -1;\n+\t}\n+      output_desc = pdes[WRITE_PORT];\n+      last_pipe_input = pdes[READ_PORT];\n+    }\n+  else\n+    {\n+      /* Last process.  */\n+      output_desc = STDOUT_FILE_NO;\n+      last_pipe_input = STDIN_FILE_NO;\n+    }\n+\n+  /* Fork a subprocess; wait and retry if it fails.  */\n+  sleep_interval = 1;\n+  pid = -1;\n+  for (retries = 0; retries < 4; retries++)\n+    {\n+      pid = fork ();\n+      if (pid >= 0)\n+\tbreak;\n+      sleep (sleep_interval);\n+      sleep_interval *= 2;\n+    }\n+\n+  switch (pid)\n+    {\n+    case -1:\n+      *errmsg_fmt = \"fork\";\n+      *errmsg_arg = NULL;\n+      return -1;\n+\n+    case 0: /* child */\n+      /* Move the input and output pipes into place, if necessary.  */\n+      if (input_desc != STDIN_FILE_NO)\n+\t{\n+\t  close (STDIN_FILE_NO);\n+\t  dup (input_desc);\n+\t  close (input_desc);\n+\t}\n+      if (output_desc != STDOUT_FILE_NO)\n+\t{\n+\t  close (STDOUT_FILE_NO);\n+\t  dup (output_desc);\n+\t  close (output_desc);\n+\t}\n+\n+      /* Close the parent's descs that aren't wanted here.  */\n+      if (last_pipe_input != STDIN_FILE_NO)\n+\tclose (last_pipe_input);\n+\n+      /* Exec the program.  */\n+      (*func) (program, argv);\n+\n+      fprintf (stderr, \"%s: \", this_pname);\n+      fprintf (stderr, install_error_msg, program);\n+      fprintf (stderr, \": %s\\n\", xstrerror (errno));\n+      exit (-1);\n+      /* NOTREACHED */\n+      return 0;\n+\n+    default:\n+      /* In the parent, after forking.\n+\t Close the descriptors that we made for this child.  */\n+      if (input_desc != STDIN_FILE_NO)\n+\tclose (input_desc);\n+      if (output_desc != STDOUT_FILE_NO)\n+\tclose (output_desc);\n+\n+      /* Return child's process number.  */\n+      return pid;\n+    }\n+}\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags ATTRIBUTE_UNUSED;\n+{\n+  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n+     Needed?  */\n+  pid = waitpid (pid, status, 0);\n+  return pid;\n+}"}, {"sha": "bd097a4bb052600dea352169aabfe5cc2c6c6140", "filename": "libiberty/pex-win32.c", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpex-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-win32.c?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -0,0 +1,243 @@\n+/* Utilities to execute a program in a subprocess (possibly linked by pipes\n+   with other subprocesses), and wait for it.  Generic Win32 specialization.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"pex-common.h\"\n+\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#ifdef HAVE_SYS_WAIT_H\n+#include <sys/wait.h>\n+#endif\n+\n+#include <process.h>\n+#include <io.h>\n+#include <fcntl.h>\n+#include <signal.h>\n+\n+/* mingw32 headers may not define the following.  */\n+\n+#ifndef _P_WAIT\n+#  define _P_WAIT\t0\n+#  define _P_NOWAIT\t1\n+#  define _P_OVERLAY\t2\n+#  define _P_NOWAITO\t3\n+#  define _P_DETACH\t4\n+\n+#  define WAIT_CHILD\t\t0\n+#  define WAIT_GRANDCHILD\t1\n+#endif\n+\n+/* This is a kludge to get around the Microsoft C spawn functions' propensity\n+   to remove the outermost set of double quotes from all arguments.  */\n+\n+static const char * const *\n+fix_argv (argvec)\n+     char **argvec;\n+{\n+  int i;\n+\n+  for (i = 1; argvec[i] != 0; i++)\n+    {\n+      int len, j;\n+      char *temp, *newtemp;\n+\n+      temp = argvec[i];\n+      len = strlen (temp);\n+      for (j = 0; j < len; j++)\n+        {\n+          if (temp[j] == '\"')\n+            {\n+              newtemp = xmalloc (len + 2);\n+              strncpy (newtemp, temp, j);\n+              newtemp [j] = '\\\\';\n+              strncpy (&newtemp [j+1], &temp [j], len-j);\n+              newtemp [len+1] = 0;\n+              temp = newtemp;\n+              len++;\n+              j++;\n+            }\n+        }\n+\n+        argvec[i] = temp;\n+      }\n+\n+  for (i = 0; argvec[i] != 0; i++)\n+    {\n+      if (strpbrk (argvec[i], \" \\t\"))\n+        {\n+\t  int len, trailing_backslash;\n+\t  char *temp;\n+\n+\t  len = strlen (argvec[i]);\n+\t  trailing_backslash = 0;\n+\n+\t  /* There is an added complication when an arg with embedded white\n+\t     space ends in a backslash (such as in the case of -iprefix arg\n+\t     passed to cpp). The resulting quoted strings gets misinterpreted\n+\t     by the command interpreter -- it thinks that the ending quote\n+\t     is escaped by the trailing backslash and things get confused. \n+\t     We handle this case by escaping the trailing backslash, provided\n+\t     it was not escaped in the first place.  */\n+\t  if (len > 1 \n+\t      && argvec[i][len-1] == '\\\\' \n+\t      && argvec[i][len-2] != '\\\\')\n+\t    {\n+\t      trailing_backslash = 1;\n+\t      ++len;\t\t\t/* to escape the final backslash. */\n+\t    }\n+\n+\t  len += 2;\t\t\t/* and for the enclosing quotes. */\n+\n+\t  temp = xmalloc (len + 1);\n+\t  temp[0] = '\"';\n+\t  strcpy (temp + 1, argvec[i]);\n+\t  if (trailing_backslash)\n+\t    temp[len-2] = '\\\\';\n+\t  temp[len-1] = '\"';\n+\t  temp[len] = '\\0';\n+\n+\t  argvec[i] = temp;\n+\t}\n+    }\n+\n+  return (const char * const *) argvec;\n+}\n+\n+/* Win32 supports pipes */\n+int\n+pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n+     const char *program;\n+     char * const *argv;\n+     const char *this_pname;\n+     const char *temp_base;\n+     char **errmsg_fmt, **errmsg_arg;\n+     int flags;\n+{\n+  int pid;\n+  int pdes[2], org_stdin, org_stdout;\n+  int input_desc, output_desc;\n+  int retries, sleep_interval;\n+\n+  /* Pipe waiting from last process, to be used as input for the next one.\n+     Value is STDIN_FILE_NO if no pipe is waiting\n+     (i.e. the next command is the first of a group).  */\n+  static int last_pipe_input;\n+\n+  /* If this is the first process, initialize.  */\n+  if (flags & PEXECUTE_FIRST)\n+    last_pipe_input = STDIN_FILE_NO;\n+\n+  input_desc = last_pipe_input;\n+\n+  /* If this isn't the last process, make a pipe for its output,\n+     and record it as waiting to be the input to the next process.  */\n+  if (! (flags & PEXECUTE_LAST))\n+    {\n+      if (_pipe (pdes, 256, O_BINARY) < 0)\n+\t{\n+\t  *errmsg_fmt = \"pipe\";\n+\t  *errmsg_arg = NULL;\n+\t  return -1;\n+\t}\n+      output_desc = pdes[WRITE_PORT];\n+      last_pipe_input = pdes[READ_PORT];\n+    }\n+  else\n+    {\n+      /* Last process.  */\n+      output_desc = STDOUT_FILE_NO;\n+      last_pipe_input = STDIN_FILE_NO;\n+    }\n+\n+  if (input_desc != STDIN_FILE_NO)\n+    {\n+      org_stdin = dup (STDIN_FILE_NO);\n+      dup2 (input_desc, STDIN_FILE_NO);\n+      close (input_desc); \n+    }\n+\n+  if (output_desc != STDOUT_FILE_NO)\n+    {\n+      org_stdout = dup (STDOUT_FILE_NO);\n+      dup2 (output_desc, STDOUT_FILE_NO);\n+      close (output_desc);\n+    }\n+\n+  pid = (flags & PEXECUTE_SEARCH ? _spawnvp : _spawnv)\n+    (_P_NOWAIT, program, fix_argv(argv));\n+\n+  if (input_desc != STDIN_FILE_NO)\n+    {\n+      dup2 (org_stdin, STDIN_FILE_NO);\n+      close (org_stdin);\n+    }\n+\n+  if (output_desc != STDOUT_FILE_NO)\n+    {\n+      dup2 (org_stdout, STDOUT_FILE_NO);\n+      close (org_stdout);\n+    }\n+\n+  if (pid == -1)\n+    {\n+      *errmsg_fmt = install_error_msg;\n+      *errmsg_arg = program;\n+      return -1;\n+    }\n+\n+  return pid;\n+}\n+\n+/* MS CRTDLL doesn't return enough information in status to decide if the\n+   child exited due to a signal or not, rather it simply returns an\n+   integer with the exit code of the child; eg., if the child exited with \n+   an abort() call and didn't have a handler for SIGABRT, it simply returns\n+   with status = 3. We fix the status code to conform to the usual WIF*\n+   macros. Note that WIFSIGNALED will never be true under CRTDLL. */\n+\n+int\n+pwait (pid, status, flags)\n+     int pid;\n+     int *status;\n+     int flags;\n+{\n+  int termstat;\n+\n+  pid = _cwait (&termstat, pid, WAIT_CHILD);\n+\n+  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n+     Needed?  */\n+\n+  /* cwait returns the child process exit code in termstat.\n+     A value of 3 indicates that the child caught a signal, but not\n+     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we\n+     report SIGABRT.  */\n+  if (termstat == 3)\n+    *status = SIGABRT;\n+  else\n+    *status = (((termstat) & 0xff) << 8);\n+\n+  return pid;\n+}"}, {"sha": "347c4db10924737cfebd0cd52c6c37982be4b4d4", "filename": "libiberty/pexecute.c", "status": "removed", "additions": 0, "deletions": 792, "changes": 792, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libiberty%2Fpexecute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libiberty%2Fpexecute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpexecute.c?ref=4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "patch": "@@ -1,792 +0,0 @@\n-/* Utilities to execute a program in a subprocess (possibly linked by pipes\n-   with other subprocesses), and wait for it.\n-   Copyright (C) 1996-2000 Free Software Foundation, Inc.\n-\n-This file is part of the libiberty library.\n-Libiberty is free software; you can redistribute it and/or\n-modify it under the terms of the GNU Library General Public\n-License as published by the Free Software Foundation; either\n-version 2 of the License, or (at your option) any later version.\n-\n-Libiberty is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-Library General Public License for more details.\n-\n-You should have received a copy of the GNU Library General Public\n-License along with libiberty; see the file COPYING.LIB.  If not,\n-write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* This file exports two functions: pexecute and pwait.  */\n-\n-/* This file lives in at least two places: libiberty and gcc.\n-   Don't change one without the other.  */\n-\n-#ifdef HAVE_CONFIG_H\n-#include \"config.h\"\n-#endif\n-\n-#include <stdio.h>\n-#include <errno.h>\n-#ifdef NEED_DECLARATION_ERRNO\n-extern int errno;\n-#endif\n-#ifdef HAVE_STRING_H\n-#include <string.h>\n-#endif\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-#ifdef HAVE_STDLIB_H\n-#include <stdlib.h>\n-#endif\n-#ifdef HAVE_SYS_WAIT_H\n-#include <sys/wait.h>\n-#endif\n-\n-#include \"libiberty.h\"\n-#include \"safe-ctype.h\"\n-\n-/* stdin file number.  */\n-#define STDIN_FILE_NO 0\n-\n-/* stdout file number.  */\n-#define STDOUT_FILE_NO 1\n-\n-/* value of `pipe': port index for reading.  */\n-#define READ_PORT 0\n-\n-/* value of `pipe': port index for writing.  */\n-#define WRITE_PORT 1\n-\n-static char *install_error_msg = \"installation problem, cannot exec `%s'\";\n-\n-/* pexecute: execute a program.\n-\n-@deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)\n-\n-Executes a program.\n-\n-@var{program} and @var{argv} are the arguments to\n-@code{execv}/@code{execvp}.\n-\n-@var{this_pname} is name of the calling program (i.e., @code{argv[0]}).\n-\n-@var{temp_base} is the path name, sans suffix, of a temporary file to\n-use if needed.  This is currently only needed for MS-DOS ports that\n-don't use @code{go32} (do any still exist?).  Ports that don't need it\n-can pass @code{NULL}.\n-\n-(@code{@var{flags} & PEXECUTE_SEARCH}) is non-zero if @env{PATH} should be searched\n-(??? It's not clear that GCC passes this flag correctly).  (@code{@var{flags} &\n-PEXECUTE_FIRST}) is nonzero for the first process in chain.\n-(@code{@var{flags} & PEXECUTE_FIRST}) is nonzero for the last process\n-in chain.  The first/last flags could be simplified to only mark the\n-last of a chain of processes but that requires the caller to always\n-mark the last one (and not give up early if some error occurs).\n-It's more robust to require the caller to mark both ends of the chain.\n-\n-The result is the pid on systems like Unix where we\n-@code{fork}/@code{exec} and on systems like WIN32 and OS/2 where we\n-use @code{spawn}.  It is up to the caller to wait for the child.\n-\n-The result is the @code{WEXITSTATUS} on systems like MS-DOS where we\n-@code{spawn} and wait for the child here.\n-\n-Upon failure, @var{errmsg_fmt} and @var{errmsg_arg} are set to the\n-text of the error message with an optional argument (if not needed,\n-@var{errmsg_arg} is set to @code{NULL}), and @minus{}1 is returned.\n-@code{errno} is available to the caller to use.\n-\n-@end deftypefn\n-\n-@deftypefn Extension int pwait (int @var{pid}, int *@var{status}, int @var{flags})\n-\n-Waits for a program started by @code{pexecute} to finish.\n-\n-@var{pid} is the process id of the task to wait for. @var{status} is\n-the `status' argument to wait. @var{flags} is currently unused (allows\n-future enhancement without breaking upward compatibility).  Pass 0 for now.\n-\n-The result is the pid of the child reaped, or -1 for failure\n-(@code{errno} says why).\n-\n-On systems that don't support waiting for a particular child, @var{pid} is\n-ignored.  On systems like MS-DOS that don't really multitask @code{pwait}\n-is just a mechanism to provide a consistent interface for the caller.\n-\n-@end deftypefn\n-\n-@undocumented pfinish\n-\n-   pfinish: finish generation of script\n-\n-   pfinish is necessary for systems like MPW where a script is generated that\n-   runs the requested programs.  */\n-\n-#ifdef __MSDOS__\n-\n-/* MSDOS doesn't multitask, but for the sake of a consistent interface\n-   the code behaves like it does.  pexecute runs the program, tucks the\n-   exit code away, and returns a \"pid\".  pwait must be called to fetch the\n-   exit code.  */\n-\n-#include <process.h>\n-\n-/* For communicating information from pexecute to pwait.  */\n-static int last_pid = 0;\n-static int last_status = 0;\n-static int last_reaped = 0;\n-\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  int rc;\n-\n-  last_pid++;\n-  if (last_pid < 0)\n-    last_pid = 1;\n-\n-  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n-    abort ();\n-\n-#ifdef __DJGPP__\n-  /* ??? What are the possible return values from spawnv?  */\n-  rc = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (P_WAIT, program, argv);\n-#else\n-  char *scmd, *rf;\n-  FILE *argfile;\n-  int i, el = flags & PEXECUTE_SEARCH ? 4 : 0;\n-\n-  if (temp_base == 0)\n-    temp_base = choose_temp_base ();\n-  scmd = (char *) xmalloc (strlen (program) + strlen (temp_base) + 6 + el);\n-  rf = scmd + strlen(program) + 2 + el;\n-  sprintf (scmd, \"%s%s @%s.gp\", program,\n-\t   (flags & PEXECUTE_SEARCH ? \".exe\" : \"\"), temp_base);\n-  argfile = fopen (rf, \"w\");\n-  if (argfile == 0)\n-    {\n-      int errno_save = errno;\n-      free (scmd);\n-      errno = errno_save;\n-      *errmsg_fmt = \"cannot open `%s.gp'\";\n-      *errmsg_arg = temp_base;\n-      return -1;\n-    }\n-\n-  for (i=1; argv[i]; i++)\n-    {\n-      char *cp;\n-      for (cp = argv[i]; *cp; cp++)\n-\t{\n-\t  if (*cp == '\"' || *cp == '\\'' || *cp == '\\\\' || ISSPACE (*cp))\n-\t    fputc ('\\\\', argfile);\n-\t  fputc (*cp, argfile);\n-\t}\n-      fputc ('\\n', argfile);\n-    }\n-  fclose (argfile);\n-\n-  rc = system (scmd);\n-\n-  {\n-    int errno_save = errno;\n-    remove (rf);\n-    free (scmd);\n-    errno = errno_save;\n-  }\n-#endif\n-\n-  if (rc == -1)\n-    {\n-      *errmsg_fmt = install_error_msg;\n-      *errmsg_arg = (char *)program;\n-      return -1;\n-    }\n-\n-  /* Tuck the status away for pwait, and return a \"pid\".  */\n-  last_status = rc << 8;\n-  return last_pid;\n-}\n-\n-/* Use ECHILD if available, otherwise use EINVAL.  */\n-#ifdef ECHILD\n-#define PWAIT_ERROR ECHILD\n-#else\n-#define PWAIT_ERROR EINVAL\n-#endif\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n-{\n-  /* On MSDOS each pexecute must be followed by it's associated pwait.  */\n-  if (pid != last_pid\n-      /* Called twice for the same child?  */\n-      || pid == last_reaped)\n-    {\n-      errno = PWAIT_ERROR;\n-      return -1;\n-    }\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-#ifdef __DJGPP__\n-  *status = (last_status >> 8);\n-#else\n-  *status = last_status;\n-#endif\n-  last_reaped = last_pid;\n-  return last_pid;\n-}\n-\n-#endif /* MSDOS */\n-\n-#if defined (_WIN32) && ! defined (_UWIN)\n-\n-#include <process.h>\n-\n-#ifdef __CYGWIN__\n-\n-#define fix_argv(argvec) (argvec)\n-\n-extern int _spawnv ();\n-extern int _spawnvp ();\n-\n-#else /* ! __CYGWIN__ */\n-\n-/* This is a kludge to get around the Microsoft C spawn functions' propensity\n-   to remove the outermost set of double quotes from all arguments.  */\n-\n-static const char * const *\n-fix_argv (argvec)\n-     char **argvec;\n-{\n-  int i;\n-\n-  for (i = 1; argvec[i] != 0; i++)\n-    {\n-      int len, j;\n-      char *temp, *newtemp;\n-\n-      temp = argvec[i];\n-      len = strlen (temp);\n-      for (j = 0; j < len; j++)\n-        {\n-          if (temp[j] == '\"')\n-            {\n-              newtemp = xmalloc (len + 2);\n-              strncpy (newtemp, temp, j);\n-              newtemp [j] = '\\\\';\n-              strncpy (&newtemp [j+1], &temp [j], len-j);\n-              newtemp [len+1] = 0;\n-              temp = newtemp;\n-              len++;\n-              j++;\n-            }\n-        }\n-\n-        argvec[i] = temp;\n-      }\n-\n-  for (i = 0; argvec[i] != 0; i++)\n-    {\n-      if (strpbrk (argvec[i], \" \\t\"))\n-        {\n-\t  int len, trailing_backslash;\n-\t  char *temp;\n-\n-\t  len = strlen (argvec[i]);\n-\t  trailing_backslash = 0;\n-\n-\t  /* There is an added complication when an arg with embedded white\n-\t     space ends in a backslash (such as in the case of -iprefix arg\n-\t     passed to cpp). The resulting quoted strings gets misinterpreted\n-\t     by the command interpreter -- it thinks that the ending quote\n-\t     is escaped by the trailing backslash and things get confused. \n-\t     We handle this case by escaping the trailing backslash, provided\n-\t     it was not escaped in the first place.  */\n-\t  if (len > 1 \n-\t      && argvec[i][len-1] == '\\\\' \n-\t      && argvec[i][len-2] != '\\\\')\n-\t    {\n-\t      trailing_backslash = 1;\n-\t      ++len;\t\t\t/* to escape the final backslash. */\n-\t    }\n-\n-\t  len += 2;\t\t\t/* and for the enclosing quotes. */\n-\n-\t  temp = xmalloc (len + 1);\n-\t  temp[0] = '\"';\n-\t  strcpy (temp + 1, argvec[i]);\n-\t  if (trailing_backslash)\n-\t    temp[len-2] = '\\\\';\n-\t  temp[len-1] = '\"';\n-\t  temp[len] = '\\0';\n-\n-\t  argvec[i] = temp;\n-\t}\n-    }\n-\n-  return (const char * const *) argvec;\n-}\n-#endif /* __CYGWIN__ */\n-\n-#include <io.h>\n-#include <fcntl.h>\n-#include <signal.h>\n-\n-/* mingw32 headers may not define the following.  */\n-\n-#ifndef _P_WAIT\n-#  define _P_WAIT\t0\n-#  define _P_NOWAIT\t1\n-#  define _P_OVERLAY\t2\n-#  define _P_NOWAITO\t3\n-#  define _P_DETACH\t4\n-\n-#  define WAIT_CHILD\t0\n-#  define WAIT_GRANDCHILD\t1\n-#endif\n-\n-/* Win32 supports pipes */\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  int pid;\n-  int pdes[2], org_stdin, org_stdout;\n-  int input_desc, output_desc;\n-  int retries, sleep_interval;\n-\n-  /* Pipe waiting from last process, to be used as input for the next one.\n-     Value is STDIN_FILE_NO if no pipe is waiting\n-     (i.e. the next command is the first of a group).  */\n-  static int last_pipe_input;\n-\n-  /* If this is the first process, initialize.  */\n-  if (flags & PEXECUTE_FIRST)\n-    last_pipe_input = STDIN_FILE_NO;\n-\n-  input_desc = last_pipe_input;\n-\n-  /* If this isn't the last process, make a pipe for its output,\n-     and record it as waiting to be the input to the next process.  */\n-  if (! (flags & PEXECUTE_LAST))\n-    {\n-      if (_pipe (pdes, 256, O_BINARY) < 0)\n-\t{\n-\t  *errmsg_fmt = \"pipe\";\n-\t  *errmsg_arg = NULL;\n-\t  return -1;\n-\t}\n-      output_desc = pdes[WRITE_PORT];\n-      last_pipe_input = pdes[READ_PORT];\n-    }\n-  else\n-    {\n-      /* Last process.  */\n-      output_desc = STDOUT_FILE_NO;\n-      last_pipe_input = STDIN_FILE_NO;\n-    }\n-\n-  if (input_desc != STDIN_FILE_NO)\n-    {\n-      org_stdin = dup (STDIN_FILE_NO);\n-      dup2 (input_desc, STDIN_FILE_NO);\n-      close (input_desc); \n-    }\n-\n-  if (output_desc != STDOUT_FILE_NO)\n-    {\n-      org_stdout = dup (STDOUT_FILE_NO);\n-      dup2 (output_desc, STDOUT_FILE_NO);\n-      close (output_desc);\n-    }\n-\n-  pid = (flags & PEXECUTE_SEARCH ? _spawnvp : _spawnv)\n-    (_P_NOWAIT, program, fix_argv(argv));\n-\n-  if (input_desc != STDIN_FILE_NO)\n-    {\n-      dup2 (org_stdin, STDIN_FILE_NO);\n-      close (org_stdin);\n-    }\n-\n-  if (output_desc != STDOUT_FILE_NO)\n-    {\n-      dup2 (org_stdout, STDOUT_FILE_NO);\n-      close (org_stdout);\n-    }\n-\n-  if (pid == -1)\n-    {\n-      *errmsg_fmt = install_error_msg;\n-      *errmsg_arg = program;\n-      return -1;\n-    }\n-\n-  return pid;\n-}\n-\n-/* MS CRTDLL doesn't return enough information in status to decide if the\n-   child exited due to a signal or not, rather it simply returns an\n-   integer with the exit code of the child; eg., if the child exited with \n-   an abort() call and didn't have a handler for SIGABRT, it simply returns\n-   with status = 3. We fix the status code to conform to the usual WIF*\n-   macros. Note that WIFSIGNALED will never be true under CRTDLL. */\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n-{\n-#ifdef __CYGWIN__\n-  return wait (status);\n-#else\n-  int termstat;\n-\n-  pid = _cwait (&termstat, pid, WAIT_CHILD);\n-\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-\n-  /* cwait returns the child process exit code in termstat.\n-     A value of 3 indicates that the child caught a signal, but not\n-     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we\n-     report SIGABRT.  */\n-  if (termstat == 3)\n-    *status = SIGABRT;\n-  else\n-    *status = (((termstat) & 0xff) << 8);\n-\n-  return pid;\n-#endif /* __CYGWIN__ */\n-}\n-\n-#endif /* _WIN32 && ! _UWIN */\n-\n-#ifdef OS2\n-\n-/* ??? Does OS2 have process.h?  */\n-extern int spawnv ();\n-extern int spawnvp ();\n-\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  int pid;\n-\n-  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n-    abort ();\n-  /* ??? Presumably 1 == _P_NOWAIT.  */\n-  pid = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (1, program, argv);\n-  if (pid == -1)\n-    {\n-      *errmsg_fmt = install_error_msg;\n-      *errmsg_arg = program;\n-      return -1;\n-    }\n-  return pid;\n-}\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n-{\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-  int pid = wait (status);\n-  return pid;\n-}\n-\n-#endif /* OS2 */\n-\n-#ifdef MPW\n-\n-/* MPW pexecute doesn't actually run anything; instead, it writes out\n-   script commands that, when run, will do the actual executing.\n-\n-   For example, in GCC's case, GCC will write out several script commands:\n-\n-   cpp ...\n-   cc1 ...\n-   as ...\n-   ld ...\n-\n-   and then exit.  None of the above programs will have run yet.  The task\n-   that called GCC will then execute the script and cause cpp,etc. to run.\n-   The caller must invoke pfinish before calling exit.  This adds\n-   the finishing touches to the generated script.  */\n-\n-static int first_time = 1;\n-\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  char tmpprogram[255];\n-  char *cp, *tmpname;\n-  int i;\n-\n-  mpwify_filename (program, tmpprogram);\n-  if (first_time)\n-    {\n-      printf (\"Set Failed 0\\n\");\n-      first_time = 0;\n-    }\n-\n-  fputs (\"If {Failed} == 0\\n\", stdout);\n-  /* If being verbose, output a copy of the command.  It should be\n-     accurate enough and escaped enough to be \"clickable\".  */\n-  if (flags & PEXECUTE_VERBOSE)\n-    {\n-      fputs (\"\\tEcho \", stdout);\n-      fputc ('\\'', stdout);\n-      fputs (tmpprogram, stdout);\n-      fputc ('\\'', stdout);\n-      fputc (' ', stdout);\n-      for (i=1; argv[i]; i++)\n-\t{\n-\t  fputc ('\\'', stdout);\n-\t  /* See if we have an argument that needs fixing.  */\n-\t  if (strchr(argv[i], '/'))\n-\t    {\n-\t      tmpname = (char *) xmalloc (256);\n-\t      mpwify_filename (argv[i], tmpname);\n-\t      argv[i] = tmpname;\n-\t    }\n-\t  for (cp = argv[i]; *cp; cp++)\n-\t    {\n-\t      /* Write an Option-d escape char in front of special chars.  */\n-\t      if (strchr(\"'+\", *cp))\n-\t\tfputc ('\\266', stdout);\n-\t      fputc (*cp, stdout);\n-\t    }\n-\t  fputc ('\\'', stdout);\n-\t  fputc (' ', stdout);\n-\t}\n-      fputs (\"\\n\", stdout);\n-    }\n-  fputs (\"\\t\", stdout);\n-  fputs (tmpprogram, stdout);\n-  fputc (' ', stdout);\n-\n-  for (i=1; argv[i]; i++)\n-    {\n-      /* See if we have an argument that needs fixing.  */\n-      if (strchr(argv[i], '/'))\n-\t{\n-\t  tmpname = (char *) xmalloc (256);\n-\t  mpwify_filename (argv[i], tmpname);\n-\t  argv[i] = tmpname;\n-\t}\n-      if (strchr (argv[i], ' '))\n-\tfputc ('\\'', stdout);\n-      for (cp = argv[i]; *cp; cp++)\n-\t{\n-\t  /* Write an Option-d escape char in front of special chars.  */\n-\t  if (strchr(\"'+\", *cp))\n-\t    fputc ('\\266', stdout);\n-\t  fputc (*cp, stdout);\n-\t}\n-      if (strchr (argv[i], ' '))\n-\tfputc ('\\'', stdout);\n-      fputc (' ', stdout);\n-    }\n-\n-  fputs (\"\\n\", stdout);\n-\n-  /* Output commands that arrange to clean up and exit if a failure occurs.\n-     We have to be careful to collect the status from the program that was\n-     run, rather than some other script command.  Also, we don't exit\n-     immediately, since necessary cleanups are at the end of the script.  */\n-  fputs (\"\\tSet TmpStatus {Status}\\n\", stdout);\n-  fputs (\"\\tIf {TmpStatus} != 0\\n\", stdout);\n-  fputs (\"\\t\\tSet Failed {TmpStatus}\\n\", stdout);\n-  fputs (\"\\tEnd\\n\", stdout);\n-  fputs (\"End\\n\", stdout);\n-\n-  /* We're just composing a script, can't fail here.  */\n-  return 0;\n-}\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n-{\n-  *status = 0;\n-  return 0;\n-}\n-\n-/* Write out commands that will exit with the correct error code\n-   if something in the script failed.  */\n-\n-void\n-pfinish ()\n-{\n-  printf (\"\\tExit \\\"{Failed}\\\"\\n\");\n-}\n-\n-#endif /* MPW */\n-\n-/* include for Unix-like environments but not for Dos-like environments */\n-#if ! defined (__MSDOS__) && ! defined (OS2) && ! defined (MPW) \\\n-    && ! (defined (_WIN32) && ! defined (_UWIN))\n-\n-extern int execv ();\n-extern int execvp ();\n-\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base ATTRIBUTE_UNUSED;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  int (*func)() = (flags & PEXECUTE_SEARCH ? execvp : execv);\n-  int pid;\n-  int pdes[2];\n-  int input_desc, output_desc;\n-  int retries, sleep_interval;\n-  /* Pipe waiting from last process, to be used as input for the next one.\n-     Value is STDIN_FILE_NO if no pipe is waiting\n-     (i.e. the next command is the first of a group).  */\n-  static int last_pipe_input;\n-\n-  /* If this is the first process, initialize.  */\n-  if (flags & PEXECUTE_FIRST)\n-    last_pipe_input = STDIN_FILE_NO;\n-\n-  input_desc = last_pipe_input;\n-\n-  /* If this isn't the last process, make a pipe for its output,\n-     and record it as waiting to be the input to the next process.  */\n-  if (! (flags & PEXECUTE_LAST))\n-    {\n-      if (pipe (pdes) < 0)\n-\t{\n-\t  *errmsg_fmt = \"pipe\";\n-\t  *errmsg_arg = NULL;\n-\t  return -1;\n-\t}\n-      output_desc = pdes[WRITE_PORT];\n-      last_pipe_input = pdes[READ_PORT];\n-    }\n-  else\n-    {\n-      /* Last process.  */\n-      output_desc = STDOUT_FILE_NO;\n-      last_pipe_input = STDIN_FILE_NO;\n-    }\n-\n-  /* Fork a subprocess; wait and retry if it fails.  */\n-  sleep_interval = 1;\n-  pid = -1;\n-  for (retries = 0; retries < 4; retries++)\n-    {\n-      pid = fork ();\n-      if (pid >= 0)\n-\tbreak;\n-      sleep (sleep_interval);\n-      sleep_interval *= 2;\n-    }\n-\n-  switch (pid)\n-    {\n-    case -1:\n-      *errmsg_fmt = \"fork\";\n-      *errmsg_arg = NULL;\n-      return -1;\n-\n-    case 0: /* child */\n-      /* Move the input and output pipes into place, if necessary.  */\n-      if (input_desc != STDIN_FILE_NO)\n-\t{\n-\t  close (STDIN_FILE_NO);\n-\t  dup (input_desc);\n-\t  close (input_desc);\n-\t}\n-      if (output_desc != STDOUT_FILE_NO)\n-\t{\n-\t  close (STDOUT_FILE_NO);\n-\t  dup (output_desc);\n-\t  close (output_desc);\n-\t}\n-\n-      /* Close the parent's descs that aren't wanted here.  */\n-      if (last_pipe_input != STDIN_FILE_NO)\n-\tclose (last_pipe_input);\n-\n-      /* Exec the program.  */\n-      (*func) (program, argv);\n-\n-      fprintf (stderr, \"%s: \", this_pname);\n-      fprintf (stderr, install_error_msg, program);\n-      fprintf (stderr, \": %s\\n\", xstrerror (errno));\n-      exit (-1);\n-      /* NOTREACHED */\n-      return 0;\n-\n-    default:\n-      /* In the parent, after forking.\n-\t Close the descriptors that we made for this child.  */\n-      if (input_desc != STDIN_FILE_NO)\n-\tclose (input_desc);\n-      if (output_desc != STDOUT_FILE_NO)\n-\tclose (output_desc);\n-\n-      /* Return child's process number.  */\n-      return pid;\n-    }\n-}\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags ATTRIBUTE_UNUSED;\n-{\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-#ifdef VMS\n-  pid = waitpid (-1, status, 0);\n-#else\n-  pid = wait (status);\n-#endif\n-  return pid;\n-}\n-\n-#endif /* ! __MSDOS__ && ! OS2 && ! MPW && ! (_WIN32 && ! _UWIN) */"}, {"sha": "269f031cc727c292055345ecb7547ebd92b6cf97", "filename": "libiberty/pexecute.txh", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpexecute.txh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d0e5e0223bae2b64faf4b858b59eb486efbe4b/libiberty%2Fpexecute.txh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpexecute.txh?ref=55d0e5e0223bae2b64faf4b858b59eb486efbe4b", "patch": "@@ -0,0 +1,63 @@\n+@deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)\n+\n+Executes a program.\n+\n+@var{program} and @var{argv} are the arguments to\n+@code{execv}/@code{execvp}.\n+\n+@var{this_pname} is name of the calling program (i.e., @code{argv[0]}).\n+\n+@var{temp_base} is the path name, sans suffix, of a temporary file to\n+use if needed.  This is currently only needed for MS-DOS ports that\n+don't use @code{go32} (do any still exist?).  Ports that don't need it\n+can pass @code{NULL}.\n+\n+(@code{@var{flags} & PEXECUTE_SEARCH}) is non-zero if @env{PATH}\n+should be searched (??? It's not clear that GCC passes this flag\n+correctly).  (@code{@var{flags} & PEXECUTE_FIRST}) is nonzero for the\n+first process in chain.  (@code{@var{flags} & PEXECUTE_FIRST}) is\n+nonzero for the last process in chain.  The first/last flags could be\n+simplified to only mark the last of a chain of processes but that\n+requires the caller to always mark the last one (and not give up\n+early if some error occurs).  It's more robust to require the caller\n+to mark both ends of the chain.\n+\n+The result is the pid on systems like Unix where we\n+@code{fork}/@code{exec} and on systems like WIN32 and OS/2 where we\n+use @code{spawn}.  It is up to the caller to wait for the child.\n+\n+The result is the @code{WEXITSTATUS} on systems like MS-DOS where we\n+@code{spawn} and wait for the child here.\n+\n+Upon failure, @var{errmsg_fmt} and @var{errmsg_arg} are set to the\n+text of the error message with an optional argument (if not needed,\n+@var{errmsg_arg} is set to @code{NULL}), and @minus{}1 is returned.\n+@code{errno} is available to the caller to use.\n+\n+@end deftypefn\n+\n+@deftypefn Extension int pwait (int @var{pid}, int *@var{status}, int @var{flags})\n+\n+Waits for a program started by @code{pexecute} to finish.\n+\n+@var{pid} is the process id of the task to wait for. @var{status} is\n+the `status' argument to wait. @var{flags} is currently unused\n+(allows future enhancement without breaking upward compatibility).\n+Pass 0 for now.\n+\n+The result is the pid of the child reaped, or -1 for failure\n+(@code{errno} says why).\n+\n+On systems that don't support waiting for a particular child,\n+@var{pid} is ignored.  On systems like MS-DOS that don't really\n+multitask @code{pwait} is just a mechanism to provide a consistent\n+interface for the caller.\n+\n+@end deftypefn\n+\n+@undocumented pfinish\n+\n+pfinish: finish generation of script\n+\n+pfinish is necessary for systems like MPW where a script is generated\n+that runs the requested programs."}]}