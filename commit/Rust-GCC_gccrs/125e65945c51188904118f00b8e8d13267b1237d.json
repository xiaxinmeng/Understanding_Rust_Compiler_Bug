{"sha": "125e65945c51188904118f00b8e8d13267b1237d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI1ZTY1OTQ1YzUxMTg4OTA0MTE4ZjAwYjhlOGQxMzI2N2IxMjM3ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-03-11T02:37:17Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-03-11T02:37:17Z"}, "message": "16077.C: Adjust warnings.\n\n\t* g++.old-deja/g++.benjamin/16077.C: Adjust warnings.\n\t* g++.old-deja/g++.warn/impint2.C: Likewise.\n\n\t* call.c (perform_overload_resolution): New function.\n\t(build_new_function_call): Use it.\n\t(build_operator_new_call): Likewise.\n\t(add_candidates): Add explicit_targs and template_only parameters.\n\t(build_new_op): Adjust accordingly.\n\t* cp-tree.h (build_operator_new_call): New function.\n\t(build_function_call_real): Remove.\n\t(build_function_call_maybe): Likewise.\n\t* init.c (build_new_1): Use build_operator_new_call.\n\t* typeck.c (build_function_call_real): Rename to ...\n\t(build_function_call): ... this.\n\nFrom-SVN: r64159", "tree": {"sha": "8c8dcae3e7521a708a6694ea65fcb7be091800de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c8dcae3e7521a708a6694ea65fcb7be091800de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/125e65945c51188904118f00b8e8d13267b1237d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/125e65945c51188904118f00b8e8d13267b1237d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/125e65945c51188904118f00b8e8d13267b1237d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/125e65945c51188904118f00b8e8d13267b1237d/comments", "author": null, "committer": null, "parents": [{"sha": "31ca36354cc71e3fd29f94c1c981bf162e4de711", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31ca36354cc71e3fd29f94c1c981bf162e4de711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31ca36354cc71e3fd29f94c1c981bf162e4de711"}], "stats": {"total": 345, "additions": 199, "deletions": 146}, "files": [{"sha": "459520361720c2017ec81f0840cf42b19fe69b71", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=125e65945c51188904118f00b8e8d13267b1237d", "patch": "@@ -1,7 +1,22 @@\n+2003-03-10  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (perform_overload_resolution): New function.\n+\t(build_new_function_call): Use it.\n+\t(build_operator_new_call): Likewise.\n+\t(add_candidates): Add explicit_targs and template_only parameters.\n+\t(build_new_op): Adjust accordingly.\n+\t* cp-tree.h (build_operator_new_call): New function.\n+\t(build_function_call_real): Remove.\n+\t(build_function_call_maybe): Likewise.\n+\t* init.c (build_new_1): Use build_operator_new_call.\n+\t* typeck.c (build_function_call_real): Rename to ...\n+\t(build_function_call): ... this.\n+\n 2003-03-10  Devang Patel  <dpatel@apple.com>\n \t\n \tPR c++/9394\n \t* g++spec.c (lang_specific_driver): Use DEFAULT_WORD_SWTCH_TAKES_ARG.\n+\n 2003-03-10  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/9798"}, {"sha": "ed9227f2309a0c4e883250684a6ad725da671a06", "filename": "gcc/cp/call.c", "status": "modified", "additions": 161, "deletions": 59, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=125e65945c51188904118f00b8e8d13267b1237d", "patch": "@@ -104,7 +104,7 @@ static tree conditional_conversion (tree, tree);\n static char *name_as_c_string (tree, tree, bool *);\n static tree call_builtin_trap (void);\n static tree prep_operand (tree);\n-static void add_candidates (tree, tree, tree, tree,\n+static void add_candidates (tree, tree, tree, bool, tree, tree,\n \t\t\t    int, struct z_candidate **);\n static tree merge_conversion_sequences (tree, tree);\n \n@@ -2754,16 +2754,31 @@ resolve_args (tree args)\n   return args;\n }\n \n-/* Return an expression for a call to FN (a namespace-scope function,\n-   or a static member function) with the ARGS.  */\n-      \n-tree\n-build_new_function_call (tree fn, tree args)\n+/* Perform overload resolution on FN, which is called with the ARGS.\n+\n+   Return the candidate function selected by overload resolution, or\n+   NULL if the event that overload resolution failed.  In the case\n+   that overload resolution fails, *CANDIDATES will be the set of\n+   candidates considered, and ANY_VIABLE_P will be set to true or\n+   false to indicate whether or not any of the candidates were\n+   viable.  \n+\n+   The ARGS should already have gone through RESOLVE_ARGS before this\n+   function is called.  */\n+\n+static struct z_candidate *\n+perform_overload_resolution (tree fn, \n+\t\t\t     tree args, \n+\t\t\t     struct z_candidate **candidates,\n+\t\t\t     bool *any_viable_p)\n {\n-  struct z_candidate *candidates = 0, *cand;\n+  struct z_candidate *cand;\n   tree explicit_targs = NULL_TREE;\n   int template_only = 0;\n \n+  *candidates = NULL;\n+  *any_viable_p = true;\n+\n   /* Check FN and ARGS.  */\n   my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL \n \t\t      || TREE_CODE (fn) == TEMPLATE_DECL\n@@ -2780,63 +2795,146 @@ build_new_function_call (tree fn, tree args)\n       template_only = 1;\n     }\n \n-  if (really_overloaded_fn (fn) \n-      || TREE_CODE (fn) == TEMPLATE_DECL)\n+  /* Add the various candidate functions.  */\n+  add_candidates (fn, args, explicit_targs, template_only,\n+\t\t  /*conversion_path=*/NULL_TREE,\n+\t\t  /*access_path=*/NULL_TREE,\n+\t\t  LOOKUP_NORMAL,\n+\t\t  candidates);\n+\n+  if (! any_viable (*candidates))\n     {\n-      tree t1;\n+      *any_viable_p = false;\n+      return NULL;\n+    }\n \n-      args = resolve_args (args);\n+  *candidates = splice_viable (*candidates);\n+  cand = tourney (*candidates);\n \n-      if (args == error_mark_node)\n-\treturn error_mark_node;\n+  return cand;\n+}\n \n-      for (t1 = fn; t1; t1 = OVL_NEXT (t1))\n-\t{\n-\t  tree t = OVL_CURRENT (t1);\n+/* Return an expression for a call to FN (a namespace-scope function,\n+   or a static member function) with the ARGS.  */\n+      \n+tree\n+build_new_function_call (tree fn, tree args)\n+{\n+  struct z_candidate *candidates, *cand;\n+  bool any_viable_p;\n \n-\t  my_friendly_assert (!DECL_FUNCTION_MEMBER_P (t), 20020913);\n+  args = resolve_args (args);\n+  if (args == error_mark_node)\n+    return error_mark_node;\n \n-\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t    add_template_candidate\n-\t      (&candidates, t, NULL_TREE, explicit_targs, args, \n-\t       NULL_TREE, /*access_path=*/NULL_TREE, \n-\t       /*conversion_path=*/NULL_TREE,\n-\t       LOOKUP_NORMAL, DEDUCE_CALL);  \n-\t  else if (! template_only)\n-\t    add_function_candidate\n-\t      (&candidates, t, NULL_TREE, args, \n-\t       /*access_path=*/NULL_TREE,\n-\t       /*conversion_path=*/NULL_TREE, LOOKUP_NORMAL);\n-\t}\n+  cand = perform_overload_resolution (fn, args, &candidates, &any_viable_p);\n \n-      if (! any_viable (candidates))\n-\t{\n-\t  if (candidates && ! candidates->next)\n-\t    return build_function_call (candidates->fn, args);\n-\t  error (\"no matching function for call to `%D(%A)'\",\n-\t\t    DECL_NAME (OVL_CURRENT (fn)), args);\n-\t  if (candidates)\n-\t    print_z_candidates (candidates);\n-\t  return error_mark_node;\n-\t}\n-      candidates = splice_viable (candidates);\n-      cand = tourney (candidates);\n+  if (!cand)\n+    {\n+      if (!any_viable_p && candidates && ! candidates->next)\n+\treturn build_function_call (candidates->fn, args);\n+      if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n+\tfn = TREE_OPERAND (fn, 0);\n+      if (!any_viable_p)\n+\terror (\"no matching function for call to `%D(%A)'\",\n+\t       DECL_NAME (OVL_CURRENT (fn)), args);\n+      else\n+\terror (\"call of overloaded `%D(%A)' is ambiguous\",\n+\t       DECL_NAME (OVL_FUNCTION (fn)), args);\n+      if (candidates)\n+\tprint_z_candidates (candidates);\n+      return error_mark_node;\n+    }\n \n-      if (cand == 0)\n-\t{\n-\t  error (\"call of overloaded `%D(%A)' is ambiguous\",\n-\t\t    DECL_NAME (OVL_FUNCTION (fn)), args);\n-\t  print_z_candidates (candidates);\n-\t  return error_mark_node;\n-\t}\n+  return build_over_call (cand, LOOKUP_NORMAL);\n+}\n \n-      return build_over_call (cand, LOOKUP_NORMAL);\n-    }\n+/* Build a call to a global operator new.  FNNAME is the name of the\n+   operator (either \"operator new\" or \"operator new[]\") and ARGS are\n+   the arguments provided.  *SIZE points to the total number of bytes\n+   required by the allocation, and is updated if that is changed here.\n+   *COOKIE_SIZE is non-NULL if a cookie should be used.  If this\n+   function determins that no cookie should be used, after all,\n+   *COOKIE_SIZE is set to NULL_TREE. */\n \n-  /* This is not really overloaded.  */\n-  fn = OVL_CURRENT (fn);\n+tree\n+build_operator_new_call (tree fnname, tree args, tree *size, tree *cookie_size)\n+{\n+  tree fns;\n+  struct z_candidate *candidates;\n+  struct z_candidate *cand;\n+  bool any_viable_p;\n+\n+  args = tree_cons (NULL_TREE, *size, args);\n+  args = resolve_args (args);\n+  if (args == error_mark_node)\n+    return args;\n+\n+  fns = lookup_function_nonclass (fnname, args);\n+\n+  /* Figure out what function is being called.  */\n+  cand = perform_overload_resolution (fns, args, &candidates, &any_viable_p);\n+  \n+  /* If no suitable function could be found, issue an error message\n+     and give up.  */\n+  if (!cand)\n+    {\n+      if (!any_viable_p)\n+\terror (\"no matching function for call to `%D(%A)'\",\n+\t       DECL_NAME (OVL_CURRENT (fns)), args);\n+      else\n+\terror (\"call of overlopaded `%D(%A)' is ambiguous\",\n+\t       DECL_NAME (OVL_FUNCTION (fns)), args);\n+      if (candidates)\n+\tprint_z_candidates (candidates);\n+      return error_mark_node;\n+    }\n \n-  return build_function_call (fn, args);\n+   /* If a cookie is required, add some extra space.  Whether\n+      or not a cookie is required cannot be determined until\n+      after we know which function was called.  */\n+   if (*cookie_size)\n+     {\n+       bool use_cookie = true;\n+       if (!abi_version_at_least (2))\n+\t {\n+\t   tree placement = TREE_CHAIN (args);\n+\t   /* In G++ 3.2, the check was implemented incorrectly; it\n+\t      looked at the placement expression, rather than the\n+\t      type of the function.  */\n+\t   if (placement && !TREE_CHAIN (placement)\n+\t       && same_type_p (TREE_TYPE (TREE_VALUE (placement)),\n+\t\t\t       ptr_type_node))\n+\t     use_cookie = false;\n+\t }\n+       else\n+\t {\n+\t   tree arg_types;\n+\n+\t   arg_types = TYPE_ARG_TYPES (TREE_TYPE (cand->fn));\n+\t   /* Skip the size_t parameter.  */\n+\t   arg_types = TREE_CHAIN (arg_types);\n+\t   /* Check the remaining parameters (if any).  */\n+\t   if (arg_types \n+\t       && TREE_CHAIN (arg_types) == void_list_node\n+\t       && same_type_p (TREE_VALUE (arg_types),\n+\t\t\t       ptr_type_node))\n+\t     use_cookie = false;\n+\t }\n+       /* If we need a cookie, adjust the number of bytes allocated.  */\n+       if (use_cookie)\n+\t {\n+\t   /* Update the total size.  */\n+\t   *size = size_binop (PLUS_EXPR, *size, *cookie_size);\n+\t   /* Update the argument list to reflect the adjusted size.  */\n+\t   TREE_VALUE (args) = *size;\n+\t }\n+       else\n+\t *cookie_size = NULL_TREE;\n+     }\n+\n+   /* Build the CALL_EXPR.  */\n+   return build_over_call (cand, LOOKUP_NORMAL);\n }\n \n static tree\n@@ -3396,11 +3494,14 @@ prep_operand (tree operand)\n /* Add each of the viable functions in FNS (a FUNCTION_DECL or\n    OVERLOAD) to the CANDIDATES, returning an updated list of\n    CANDIDATES.  The ARGS are the arguments provided to the call,\n-   without any implicit object parameter.  CONVERSION_PATH,\n+   without any implicit object parameter.  The EXPLICIT_TARGS are\n+   explicit template arguments provided.  TEMPLATE_ONLY is true if\n+   only template fucntions should be considered.  CONVERSION_PATH,\n    ACCESS_PATH, and FLAGS are as for add_function_candidate.  */\n \n static void\n-add_candidates (tree fns, tree args,\n+add_candidates (tree fns, tree args, \n+\t\ttree explicit_targs, bool template_only,\n \t\ttree conversion_path, tree access_path,\n \t\tint flags,\n \t\tstruct z_candidate **candidates)\n@@ -3419,7 +3520,7 @@ add_candidates (tree fns, tree args,\n \n       fn = OVL_CURRENT (fns);\n       /* Figure out which set of arguments to use.  */\n-      if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n+      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n \t{\n \t  /* If this function is a non-static member, prepend the implicit\n \t     object parameter.  */\n@@ -3437,14 +3538,14 @@ add_candidates (tree fns, tree args,\n \tadd_template_candidate (candidates, \n \t\t\t\tfn, \n \t\t\t\tctype,\n-\t\t\t\tNULL_TREE,\n+\t\t\t\texplicit_targs,\n \t\t\t\tfn_args,\n \t\t\t\tNULL_TREE,\n \t\t\t\taccess_path,\n \t\t\t\tconversion_path,\n \t\t\t\tflags,\n \t\t\t\tDEDUCE_CALL);\n-      else\n+      else if (!template_only)\n \tadd_function_candidate (candidates,\n \t\t\t\tfn,\n \t\t\t\tctype,\n@@ -3527,7 +3628,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n   /* Add namespace-scope operators to the list of functions to\n      consider.  */\n   add_candidates (lookup_function_nonclass (fnname, arglist),\n-\t\t  arglist, NULL_TREE, NULL_TREE,\n+\t\t  arglist, NULL_TREE, false, NULL_TREE, NULL_TREE,\n \t\t  flags, &candidates);\n   /* Add class-member operators to the candidate set.  */\n   if (CLASS_TYPE_P (TREE_TYPE (arg1)))\n@@ -3539,6 +3640,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n \treturn fns;\n       if (fns)\n \tadd_candidates (BASELINK_FUNCTIONS (fns), arglist, \n+\t\t\tNULL_TREE, false,\n \t\t\tBASELINK_BINFO (fns),\n \t\t\tTYPE_BINFO (TREE_TYPE (arg1)),\n \t\t\tflags, &candidates);"}, {"sha": "a45e546f5bb63f93b635cd5033a4f91cc55dc81c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=125e65945c51188904118f00b8e8d13267b1237d", "patch": "@@ -3564,6 +3564,7 @@ extern tree type_decays_to (tree);\n extern tree resolve_scoped_fn_name (tree, tree);\n extern tree build_user_type_conversion (tree, tree, int);\n extern tree build_new_function_call (tree, tree);\n+extern tree build_operator_new_call (tree, tree, tree *, tree *);\n extern tree build_new_method_call (tree, tree, tree, tree, int);\n extern tree build_special_member_call (tree, tree, tree, tree, int);\n extern tree build_new_op (enum tree_code, int, tree, tree, tree);\n@@ -4324,8 +4325,6 @@ extern tree build_x_indirect_ref\t\t(tree, const char *);\n extern tree build_indirect_ref\t\t\t(tree, const char *);\n extern tree build_array_ref\t\t\t(tree, tree);\n extern tree get_member_function_from_ptrfunc\t(tree *, tree);\n-extern tree build_function_call_real\t\t(tree, tree, int, int);\n-extern tree build_function_call_maybe\t\t(tree, tree);\n extern tree convert_arguments\t\t\t(tree, tree, tree, int);\n extern tree build_x_binary_op\t\t\t(enum tree_code, tree, tree);\n extern tree build_x_unary_op\t\t\t(enum tree_code, tree);"}, {"sha": "99812c6fbc6cdb8d76c16c322bb27325e5d01d89", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 55, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=125e65945c51188904118f00b8e8d13267b1237d", "patch": "@@ -2167,7 +2167,6 @@ build_new_1 (exp)\n   /* Nonzero if the user wrote `::new' rather than just `new'.  */\n   int globally_qualified_p;\n   int use_java_new = 0;\n-  bool check_cookie = false;\n   /* If non-NULL, the number of extra bytes to allocate at the\n      beginning of the storage allocated for an array-new expression in\n      order to store the number of elements.  */\n@@ -2272,14 +2271,14 @@ build_new_1 (exp)\n       else\n \t{\n \t  /* Use a global operator new.  */\n-\t  /* Create the argument list.  */\n-\t  args = tree_cons (NULL_TREE, size, placement);\n-\t  /* Call the function.  */\n-\t  alloc_call \n-\t    = build_new_function_call (lookup_function_nonclass (fnname, args),\n-\t\t\t\t       args);\n-\t  /* We may need to add a cookie.  */\n-\t  check_cookie = true;\n+\t  /* See if a cookie might be required.  */\n+\t  if (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type))\n+\t    cookie_size = get_cookie_size (true_type);\n+\t  else\n+\t    cookie_size = NULL_TREE;\n+\n+\t  alloc_call = build_operator_new_call (fnname, placement, \n+\t\t\t\t\t\t&size, &cookie_size);\n \t}\n     }\n \n@@ -2295,52 +2294,6 @@ build_new_1 (exp)\n   alloc_fn = get_callee_fndecl (t);\n   my_friendly_assert (alloc_fn != NULL_TREE, 20020325);\n \n-  /* If we postponed deciding whether or not to use a cookie until\n-     after we knew what function was being called, that time is\n-     now.  */\n-  if (check_cookie)\n-    {\n-      /* If a cookie is required, add some extra space.  Whether\n-\t or not a cookie is required cannot be determined until\n-\t after we know which function was called.  */\n-      if (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type))\n-\t{\n-\t  bool use_cookie = true;\n-\t  if (!abi_version_at_least (2))\n-\t    {\n-\t      /* In G++ 3.2, the check was implemented incorrectly; it\n-\t\t looked at the placement expression, rather than the\n-\t\t type of the function.  */\n-\t      if (placement && !TREE_CHAIN (placement)\n-\t\t  && same_type_p (TREE_TYPE (TREE_VALUE (placement)),\n-\t\t\t\t  ptr_type_node))\n-\t\tuse_cookie = false;\n-\t    }\n-\t  else\n-\t    {\n-\t      tree arg_types;\n-\n-\t      arg_types = TYPE_ARG_TYPES (TREE_TYPE (alloc_fn));\n-\t      /* Skip the size_t parameter.  */\n-\t      arg_types = TREE_CHAIN (arg_types);\n-\t      /* Check the remaining parameters (if any).  */\n-\t      if (arg_types \n-\t\t  && !TREE_CHAIN (arg_types)\n-\t\t  && same_type_p (TREE_TYPE (TREE_VALUE (arg_types)),\n-\t\t\t\t  ptr_type_node))\n-\t\tuse_cookie = false;\n-\t    }\n-\t  /* If we need a cookie, adjust the number of bytes allocated.  */\n-\t  if (use_cookie)\n-\t    {\n-\t      cookie_size = get_cookie_size (true_type);\n-\t      size = size_binop (PLUS_EXPR, size, cookie_size);\n-\t      /* Update the argument list to reflect the adjusted size.  */\n-\t      TREE_VALUE (args) = cookie_size;\n-\t    }\n-\t}\n-    }\n-\n   /* Now, check to see if this function is actually a placement\n      allocation function.  This can happen even when PLACEMENT is NULL\n      because we might have something like:"}, {"sha": "0cbff77777eedd476783a417fac4f0d9d5b8b490", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=125e65945c51188904118f00b8e8d13267b1237d", "patch": "@@ -2655,9 +2655,8 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n }\n \n tree\n-build_function_call_real (function, params, require_complete, flags)\n+build_function_call (function, params)\n      tree function, params;\n-     int require_complete, flags;\n {\n   register tree fntype, fndecl;\n   register tree value_type;\n@@ -2731,20 +2730,10 @@ build_function_call_real (function, params, require_complete, flags)\n   /* Convert the parameters to the types declared in the\n      function prototype, or apply default promotions.  */\n \n-  if (flags & LOOKUP_COMPLAIN)\n-    coerced_params = convert_arguments (TYPE_ARG_TYPES (fntype),\n-\t\t\t\t\tparams, fndecl, LOOKUP_NORMAL);\n-  else\n-    coerced_params = convert_arguments (TYPE_ARG_TYPES (fntype),\n-\t\t\t\t\tparams, fndecl, 0);\n-\n+  coerced_params = convert_arguments (TYPE_ARG_TYPES (fntype),\n+\t\t\t\t      params, fndecl, LOOKUP_NORMAL);\n   if (coerced_params == error_mark_node)\n-    {\n-      if (flags & LOOKUP_SPECULATIVELY)\n-\treturn NULL_TREE;\n-      else\n-\treturn error_mark_node;\n-    }\n+    return error_mark_node;\n \n   /* Check for errors in format strings.  */\n \n@@ -2770,23 +2759,13 @@ build_function_call_real (function, params, require_complete, flags)\n   result = fold (build_call (function, coerced_params));\n   value_type = TREE_TYPE (result);\n \n-  if (require_complete)\n-    {\n-      if (TREE_CODE (value_type) == VOID_TYPE)\n-\treturn result;\n-      result = require_complete_type (result);\n-    }\n+  if (TREE_CODE (value_type) == VOID_TYPE)\n+    return result;\n+  result = require_complete_type (result);\n   if (IS_AGGR_TYPE (value_type))\n     result = build_cplus_new (value_type, result);\n   return convert_from_reference (result);\n }\n-\n-tree\n-build_function_call (function, params)\n-     tree function, params;\n-{\n-  return build_function_call_real (function, params, 1, LOOKUP_NORMAL);\n-}\n \f\n /* Convert the actual parameter expressions in the list VALUES\n    to the types in the list TYPELIST."}, {"sha": "705abb781712d7e8e86ff08f92ab891fb204e4cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=125e65945c51188904118f00b8e8d13267b1237d", "patch": "@@ -1,3 +1,8 @@\n+2003-03-10  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.old-deja/g++.benjamin/16077.C: Adjust warnings.\n+\t* g++.old-deja/g++.warn/impint2.C: Likewise.\n+\n 2003-03-10  Devang Patel  <dpatel@apple.com>\n \n \t* g++.dg/cpp/c++_cmd_1.C: New test."}, {"sha": "3bed73666c1b892683f8ff7542fc6184f8885125", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/16077.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2F16077.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2F16077.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2F16077.C?ref=125e65945c51188904118f00b8e8d13267b1237d", "patch": "@@ -17,7 +17,7 @@ public:\n    operator colombia();\n };\n \n-void peace(const colombia&); // WARNING - // WARNING -\n+void peace(const colombia&);\n \n void foo(nicaragua& b) {\n   peace(b); // WARNING - // WARNING -"}, {"sha": "a522ffc34fa77ac3ad2c0a78374e251cc62c48fa", "filename": "gcc/testsuite/g++.old-deja/g++.warn/impint2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.warn%2Fimpint2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e65945c51188904118f00b8e8d13267b1237d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.warn%2Fimpint2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.warn%2Fimpint2.C?ref=125e65945c51188904118f00b8e8d13267b1237d", "patch": "@@ -13,7 +13,7 @@ struct X\n   X (int const &, int const &);\n };\n \n-void foo (int const &);       // WARNING - in passing\n+void foo (int const &);\n void wibble (int const &);\n void wibble (int const &, int const &);\n void punk (int const & = 3.5f);        // WARNING - in passing"}]}