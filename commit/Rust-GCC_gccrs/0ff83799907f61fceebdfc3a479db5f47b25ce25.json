{"sha": "0ff83799907f61fceebdfc3a479db5f47b25ce25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZmODM3OTk5MDdmNjFmY2VlYmRmYzNhNDc5ZGI1ZjQ3YjI1Y2UyNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-06-05T11:12:58Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-06-05T11:12:58Z"}, "message": "mips.h (mips_output_conditional_branch): New function.\n\n\t* mips.h (mips_output_conditional_branch): New function.\n\t(mips_adjust_insn_length): Likewise.\n\t(ASSEMBLER_SCRATCH_REGNUM): New macro.\n\t(ADJUST_INSN_LENGTH): Likewise.\n\t* mips.c (print_operand): Add `F' and `W' for floating-point\n\tcomparison opcodes.\n\t(machine_dependent_reorg): Adjust MIPS16 code; instruction-lengths\n\tare now in bytes.\n\t(mips_adjust_insn_length): New function.\n\t(mips_output_conditional_branch): New function.\n\t* mips.md (length): Adjust attribute definition to handle\n\tconditional branches.  \tChange lengths to bytes, rather than\n\tinstructions throughout.  Remove length attribute from\n\tinstructions whose length is four bytes, and rely on the default\n\tinstead.\n\t(dslot): Fix typo in comment.\n\tReword conditional branch patterns to use\n\tmips_output_conditional_branch.\n\nFrom-SVN: r27369", "tree": {"sha": "cc552410e26e7260282cb51a701a77be9d5e308e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc552410e26e7260282cb51a701a77be9d5e308e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ff83799907f61fceebdfc3a479db5f47b25ce25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff83799907f61fceebdfc3a479db5f47b25ce25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff83799907f61fceebdfc3a479db5f47b25ce25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff83799907f61fceebdfc3a479db5f47b25ce25/comments", "author": null, "committer": null, "parents": [{"sha": "29bbeb1c2b0c53cc4dc32a6e2f80306cef6dcfc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29bbeb1c2b0c53cc4dc32a6e2f80306cef6dcfc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29bbeb1c2b0c53cc4dc32a6e2f80306cef6dcfc6"}], "stats": {"total": 1721, "additions": 997, "deletions": 724}, "files": [{"sha": "477f7032869231faed66ef641ffeabb1c5f8de2d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff83799907f61fceebdfc3a479db5f47b25ce25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff83799907f61fceebdfc3a479db5f47b25ce25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ff83799907f61fceebdfc3a479db5f47b25ce25", "patch": "@@ -1,3 +1,24 @@\n+Sat Jun  5 12:11:24 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* mips.h (mips_output_conditional_branch): New function.\n+\t(mips_adjust_insn_length): Likewise.\n+\t(ASSEMBLER_SCRATCH_REGNUM): New macro.\n+\t(ADJUST_INSN_LENGTH): Likewise.\n+\t* mips.c (print_operand): Add `F' and `W' for floating-point\n+\tcomparison opcodes.\n+\t(machine_dependent_reorg): Adjust MIPS16 code; instruction-lengths\n+\tare now in bytes.\n+\t(mips_adjust_insn_length): New function.\n+\t(mips_output_conditional_branch): New function.\n+\t* mips.md (length): Adjust attribute definition to handle\n+\tconditional branches.  \tChange lengths to bytes, rather than\n+\tinstructions throughout.  Remove length attribute from\n+\tinstructions whose length is four bytes, and rely on the default\n+\tinstead.\n+\t(dslot): Fix typo in comment.\n+\tReword conditional branch patterns to use\n+\tmips_output_conditional_branch.\n+\n Fri Jun  4 13:30:27 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* alpha/osf.h (CPP_SUBTARGET_SPEC): Handle -threads."}, {"sha": "3433052d677350a88888a877bb35a438f56d9fce", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 315, "deletions": 2, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff83799907f61fceebdfc3a479db5f47b25ce25/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff83799907f61fceebdfc3a479db5f47b25ce25/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0ff83799907f61fceebdfc3a479db5f47b25ce25", "patch": "@@ -4594,7 +4594,9 @@ mips_debugger_offset (addr, offset)\n    'L'  print low-order register of double-word register operand.\n    'M'  print high-order register of double-word register operand.\n    'C'  print part of opcode for a branch condition.\n+   'F'  print part of opcode for a floating-point branch condition.\n    'N'  print part of opcode for a branch condition, inverted.\n+   'W'  print part of opcode for a floating-point branch condition, inverted.\n    'S'  X is CODE_LABEL, print with prefix of \"LS\" (for embedded switch).\n    'B'  print 'z' for EQ, 'n' for NE\n    'b'  print 'n' for EQ, 'z' for NE\n@@ -4792,6 +4794,24 @@ print_operand (file, op, letter)\n \tabort_with_insn (op, \"PRINT_OPERAND, invalid insn for %%N\");\n       }\n \n+  else if (letter == 'F')\n+    switch (code)\n+      {\n+      case EQ: fputs (\"c1f\", file); break;\n+      case NE: fputs (\"c1t\", file); break;\n+      default:\n+\tabort_with_insn (op, \"PRINT_OPERAND, invalid insn for %%F\");\n+      }\n+\n+  else if (letter == 'W')\n+    switch (code)\n+      {\n+      case EQ: fputs (\"c1t\", file); break;\n+      case NE: fputs (\"c1f\", file); break;\n+      default:\n+\tabort_with_insn (op, \"PRINT_OPERAND, invalid insn for %%W\");\n+      }\n+\n   else if (letter == 'S')\n     {\n       char buffer[100];\n@@ -8332,7 +8352,7 @@ machine_dependent_reorg (first)\n   insns_len = 0;\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n-      insns_len += get_attr_length (insn) * 2;\n+      insns_len += get_attr_length (insn);\n \n       /* ??? We put switch tables in .text, but we don't define\n          JUMP_TABLES_IN_TEXT_SECTION, so get_attr_length will not\n@@ -8440,7 +8460,7 @@ machine_dependent_reorg (first)\n \t    }\n \t}\n \n-      addr += get_attr_length (insn) * 2;\n+      addr += get_attr_length (insn);\n \n       /* ??? We put switch tables in .text, but we don't define\n          JUMP_TABLES_IN_TEXT_SECTION, so get_attr_length will not\n@@ -8520,3 +8540,296 @@ highpart_shift_operator (x, mode)\n \t  || code == ROTATERT\n \t  || code == ROTATE);\n }\n+\n+/* Return the length of INSN.  LENGTH is the initial length computed by \n+   attributes in the machine-description file.  */\n+\n+int\n+mips_adjust_insn_length (insn, length)\n+     rtx insn;\n+     int length;\n+{\n+  /* A unconditional jump has an unfilled delay slot if it is not part\n+     of a sequence.  A conditional jump normally has a delay slot, but\n+     does not on MIPS16.  */\n+  if (simplejump_p (insn)\n+      || (!TARGET_MIPS16  && (GET_CODE (insn) == JUMP_INSN \n+\t\t\t      || GET_CODE (insn) == CALL_INSN)))\n+    length += 4;\n+\n+  /* All MIPS16 instructions are a measly two bytes.  */\n+  if (TARGET_MIPS16)\n+    length /= 2;\n+\n+  return length;\n+}\n+\n+/* Output assembly instructions to peform a conditional branch.  \n+\n+   INSN is the branch instruction.  OPERANDS[0] is the condition.\n+   OPERANDS[1] is the target of the branch.  OPERANDS[2] is the target\n+   of the first operand to the condition.  If TWO_OPERANDS_P is\n+   non-zero the comparison takes two operands; OPERANDS[3] will be the\n+   second operand.\n+\n+   If INVERTED_P is non-zero we are to branch if the condition does\n+   not hold.  If FLOAT_P is non-zero this is a floating-point comparison.\n+\n+   LENGTH is the length (in bytes) of the sequence we are to generate.\n+   That tells us whether to generate a simple conditional branch, or a\n+   reversed conditional branch around a `jr' instruction.  */\n+char *\n+mips_output_conditional_branch (insn, \n+\t\t\t\toperands, \n+\t\t\t\ttwo_operands_p,\n+\t\t\t\tfloat_p,\n+\t\t\t\tinverted_p,\n+\t\t\t\tlength)\n+     rtx insn;\n+     rtx *operands;\n+     int two_operands_p;\n+     int float_p;\n+     int inverted_p;\n+     int length;\n+{\n+  static char buffer[200];\n+  /* The kind of comparison we are doing.  */\n+  enum rtx_code code = GET_CODE (operands[0]);\n+  /* Non-zero if the opcode for the comparison needs a `z' indicating\n+     that it is a comparision against zero.  */\n+  int need_z_p;\n+  /* A string to use in the assembly output to represent the first\n+     operand.  */\n+  char *op1 = \"%z2\";\n+  /* A string to use in the assembly output to represent the second\n+     operand.  Use the hard-wired zero register if there's no second\n+     operand.  */\n+  char *op2 = (two_operands_p ? \",%z3\" : \",%.\");\n+  /* The operand-printing string for the comparison.  */\n+  char *comp = (float_p ? \"%F0\" : \"%C0\");\n+  /* The operand-printing string for the inverted comparison.  */\n+  char *inverted_comp = (float_p ? \"%W0\" : \"%N0\");\n+\n+  /* The MIPS processors (for levels of the ISA at least two), have\n+     \"likely\" variants of each branch instruction.  These instructions\n+     annul the instruction in the delay slot if the branch is not\n+     taken.  */\n+  mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n+\n+  if (!two_operands_p)\n+    {\n+      /* To compute whether than A > B, for example, we normally\n+\t subtract B from A and then look at the sign bit.  But, if we\n+\t are doing an unsigned comparison, and B is zero, we don't\n+\t have to do the subtraction.  Instead, we can just check to\n+\t see if A is non-zero.  Thus, we change the CODE here to\n+\t reflect the simpler comparison operation.  */\n+      switch (code)\n+\t{\n+\tcase GTU:\n+\t  code = NE;\n+\t  break;\n+\n+\tcase LEU:\n+\t  code = EQ;\n+\t  break;\n+\n+\tcase GEU:\n+\t  /* A condition which will always be true.  */\n+\t  code = EQ;\n+\t  op1 = \"%.\";\n+\t  break;\n+\n+\tcase LTU:\n+\t  /* A condition which will always be false. */\n+\t  code = NE;\n+\t  op1 = \"%.\";\n+\t  break;\n+\n+\tdefault:\n+\t  /* Not a special case.  */\n+\t}\n+    }\n+\n+  /* Relative comparisons are always done against zero.  But\n+     equality comparisons are done between two operands, and therefore\n+     do not require a `z' in the assembly language output.  */\n+  need_z_p = (!float_p && code != EQ && code != NE);\n+  /* For comparisons against zero, the zero is not provided \n+     explicitly.  */\n+  if (need_z_p)\n+    op2 = \"\";\n+\n+  /* Begin by terminating the buffer.  That way we can always use\n+     strcat to add to it.  */\n+  buffer[0] = '\\0';\n+\n+  switch (length) \n+    {\n+    case 4:\n+    case 8:\n+      /* Just a simple conditional branch.  */\n+      if (float_p)\n+\tsprintf (buffer, \"%%*b%s%%?\\t%%Z2%%1\",\n+\t\t inverted_p ? inverted_comp : comp);\n+      else\n+\tsprintf (buffer, \"%%*b%s%s%%?\\t%s%s,%%1\",\n+\t\t inverted_p ? inverted_comp : comp,\n+\t\t need_z_p ? \"z\" : \"\",\n+\t\t op1,\n+\t\t op2);\n+      return buffer;\n+\n+    case 12:\n+    case 16:\n+      {\n+\t/* Generate a reversed conditional branch around ` j'\n+\t   instruction:\n+\n+\t\t.set noreorder\n+\t\t.set nomacro\n+\t\tbc    l\n+\t\tnop\n+\t\tj     target\n+\t\t.set macro\n+\t\t.set reorder\n+\t     l:\n+\n+\t   Because we have to jump four bytes *past* the following\n+\t   instruction if this branch was annulled, we can't just use\n+\t   a label, as in the picture above; there's no way to put the\n+\t   label after the next instruction, as the assembler does not\n+\t   accept `.L+4' as the target of a branch.  (We can't just\n+\t   wait until the next instruction is output; it might be a\n+\t   macro and take up more than four bytes.  Once again, we see\n+\t   why we want to eliminate macros.)\n+\t   \n+\t   If the branch is annulled, we jump four more bytes that we\n+\t   would otherwise; that way we skip the annulled instruction\n+\t   in the delay slot.  */\n+\n+\tchar *target \n+\t  = ((mips_branch_likely || length == 16) ? \".+16\" : \".+12\");\n+\tchar *c;\n+\n+\tstrcpy (buffer, \"%(%<\");\n+\tc = strchr (buffer, '\\0');\n+\t/* Generate the reversed comparision.  This takes four \n+\t   bytes.  */\n+\tif (float_p)\n+\t  sprintf (c, \"%%*b%s\\t%%Z2%s\",\n+\t\t   inverted_p ? comp : inverted_comp,\n+\t\t   target);\n+\telse\n+\t  sprintf (c, \"%%*b%s%s\\t%s%s,%s\",\n+\t\t   inverted_p ? comp : inverted_comp,\n+\t\t   need_z_p ? \"z\" : \"\",\n+\t\t   op1,\n+\t\t   op2,\n+\t\t   target);\n+\tstrcat (c, \"\\n\\tnop\\n\\tj\\t%1\");\n+\tif (length == 16)\n+\t  /* The delay slot was unfilled.  Since we're inside\n+\t     .noreorder, the assembler will not fill in the NOP for\n+\t     us, so we must do it ourselves.  */\n+\t  strcat (buffer, \"\\n\\tnop\");\n+\tstrcat (buffer, \"%>%)\");\n+\treturn buffer;\n+      }\n+\n+    /* We do not currently use this code.  It handles jumps to\n+       arbitrary locations, using `jr', even across a 256MB boundary.\n+       We could add a -mhuge switch, and then use this code instead of\n+       the `j' alternative above when -mhuge was used.  */\n+#if 0\n+    case 16:\n+    case 20:\n+      {\n+\t/* Generate a reversed conditional branch around a `jr'\n+\t   instruction:\n+\n+\t\t .set noreorder\n+\t\t .set nomacro\n+\t\t .set noat\n+\t\t bc    l\n+\t\t la    $at, target\n+\t\t jr    $at\n+\t\t .set at\n+\t\t .set macro\n+\t\t .set reorder\n+\t      l:\n+\n+\t   Not pretty, but allows a conditional branch anywhere in the\n+\t   32-bit address space.  If the original branch is annulled,\n+\t   then the instruction in the delay slot should be executed\n+\t   only if the branch is taken.  The la instruction is really\n+\t   a macro which will usually take eight bytes, but sometimes\n+\t   takes only four, if the instruction to which we're jumping\n+\t   gets its own entry in the global pointer table, which will\n+\t   happen if its a case label.  The assembler will then\n+\t   generate only a four-byte sequence, rather than eight, and\n+\t   there seems to be no way to tell it not to.  Thus, we can't\n+\t   just use a `.+x' addressing form; we don't know what value\n+\t   to give for `x'.  \n+\n+\t   So, we resort to using the explicit relocation syntax\n+\t   available in the assembler and do:\n+\n+\t      lw $at,%got_page(target)($gp)\n+\t      daddiu $at,$at,%got_ofst(target)\n+\n+\t   That way, this always takes up eight bytes, and we can use\n+\t   the `.+x' form.  Of course, these explicit machinations\n+\t   with relocation will not work with old assemblers.  Then\n+\t   again, neither do out-of-range branches, so we haven't lost\n+\t   anything.  */\n+\n+\t/* The target of the reversed branch.  */\n+\tchar *target \n+\t  = ((mips_branch_likely || length == 20) ? \".+20\" : \".+16\");\n+\tchar *at_register = mips_reg_names[ASSEMBLER_SCRATCH_REGNUM];\n+\tchar *gp_register = mips_reg_names[PIC_OFFSET_TABLE_REGNUM];\n+\tchar *c;\n+\n+\tstrcpy (buffer, \"%(%<%[\");\n+\tc = strchr (buffer, '\\0');\n+\t/* Generate the reversed comparision.  This takes four \n+\t   bytes.  */\n+\tif (float_p)\n+\t  sprintf (c, \"%%*b%s\\t%%Z2%s\",\n+\t\t   inverted_p ? comp : inverted_comp,\n+\t\t   target);\n+\telse\n+\t  sprintf (c, \"%%*b%s%s\\t%s%s,%s\",\n+\t\t   inverted_p ? comp : inverted_comp,\n+\t\t   need_z_p ? \"z\" : \"\",\n+\t\t   op1,\n+\t\t   op2,\n+\t\t   target);\n+\tc = strchr (buffer, '\\0');\n+\t/* Generate the load-address, and jump.  This takes twelve\n+\t   bytes, for a total of 16.  */\n+\tsprintf (c,\n+\t\t \"\\n\\tlw\\t%s,%%%%got_page(%%1)(%s)\\n\\tdaddiu\\t%s,%s,%%%%got_ofst(%%1)\\n\\tjr\\t%s\",\n+\t\t at_register,\n+\t\t gp_register,\n+\t\t at_register,\n+\t\t at_register,\n+\t\t at_register);\n+\tif (length == 20)\n+\t  /* The delay slot was unfilled.  Since we're inside\n+\t     .noreorder, the assembler will not fill in the NOP for\n+\t     us, so we must do it ourselves.  */\n+\t  strcat (buffer, \"\\n\\tnop\");\n+\tstrcat (buffer, \"%]%>%)\");\n+\treturn buffer;\n+      }\n+#endif\n+\n+    default:\n+      abort ();\n+    }\n+\n+  /* NOTREACHED */\n+  return 0;\n+}"}, {"sha": "3c104a59fe75fa9b62760edc9bc582f7f58af20d", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff83799907f61fceebdfc3a479db5f47b25ce25/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff83799907f61fceebdfc3a479db5f47b25ce25/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0ff83799907f61fceebdfc3a479db5f47b25ce25", "patch": "@@ -233,6 +233,8 @@ extern int\t\tmips16_gp_offset_p ();\n extern int\t\tmips16_constant ();\n extern int\t\tmips16_constant_after_function_p ();\n extern int\t\tbuild_mips16_call_stub ();\n+extern char  \t       *mips_output_conditional_branch ();\n+extern int              mips_adjust_insn_length ();\n \n /* Recognition functions that return if a condition is true.  */\n extern int\t\taddress_operand ();\n@@ -1686,6 +1688,9 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n    a fixed register, and will not be used for anything else.  */\n #define FRAME_POINTER_REGNUM (GP_REG_FIRST + 1)\n \n+/* Temporary scratch register for use by the assembler.  */\n+#define ASSEMBLER_SCRATCH_REGNUM (GP_REG_FIRST + 1)\n+\n /* $30 is not available on the mips16, so we use $17 as the frame\n    pointer.  */\n #define HARD_FRAME_POINTER_REGNUM \\\n@@ -3769,6 +3774,14 @@ while (0)\n #define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n   if (REG_NOTE_KIND (LINK) != 0)\t\t\t\t\t\\\n     (COST) = 0; /* Anti or output dependence.  */\n+\n+/* If defined, modifies the length assigned to instruction INSN as a\n+   function of the context in which it is used.  LENGTH is an lvalue\n+   that contains the initially computed length of the insn and should\n+   be updated with the correct length of the insn.  */\n+#define ADJUST_INSN_LENGTH(INSN, LENGTH) \\\n+  ((LENGTH) = mips_adjust_insn_length ((INSN), (LENGTH)))\n+\n \f\n /* Optionally define this if you have added predicates to\n    `MACHINE.c'.  This macro is called within an initializer of an"}, {"sha": "4e0a5b45ec6af6e9ce8e49de77d406c62525f84e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 648, "deletions": 722, "changes": 1370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff83799907f61fceebdfc3a479db5f47b25ce25/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff83799907f61fceebdfc3a479db5f47b25ce25/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=0ff83799907f61fceebdfc3a479db5f47b25ce25"}]}