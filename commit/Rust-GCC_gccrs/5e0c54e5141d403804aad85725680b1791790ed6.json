{"sha": "5e0c54e5141d403804aad85725680b1791790ed6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUwYzU0ZTUxNDFkNDAzODA0YWFkODU3MjU2ODBiMTc5MTc5MGVkNg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-05-18T13:40:54Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-05-18T13:40:54Z"}, "message": "hashtable.h (struct ht_identifier): Add data member \"hash_value\".\n\n\n\t* hashtable.h (struct ht_identifier): Add data member \"hash_value\".\n\t* hashtable.c (ht_lookup): Use it when searching, remember.\n\t(ht_expand): Do not recompute.\n\t* tree.h (IDENTIFIER_HASH_VALUE): New macro.\n\ncp/\n\t* cp-tree.h (struct lang_type_class): Replace data member tags\n\twith hash-table nested_udts.\n\t(CLASSTYPE_NESTED_UTDS): Rename from CLASSTYPE_TAGS.\n\t* class.c (unreverse_member_declarations): Don't touch\n\tCLASSTYPE_TAGS.\n\t(pushclass): Use cxx_remember_type_decls.\n\t* decl.c (struct cp_binding_level): Replace data member tags with\n\thash-table type_decls.\n\t(pop_binding_level): Handle level->type_decls.\n\t(kept_level_p): Adjust.\n\t(poplevel): Remove unused local variable.\n\t(bt_print_entry): New function.\n\t(print_binding_level): Use it.\n\t(push_namespace): Build current_binding_level->type_decls.\n\t(maybe_process_template_type_declaration): Adjust.\n\t(pushtag): Likewise.\n\t(clear_anon_tags): Use binding_table_remove_anonymous_types.\n\t(gettags): Remove.\n\t(cxx_remember_type_decls):  Rename from storetags.  Adjust.\n\t(lookup_tag): Use binding_table_find_anon_type.  Tidy.\n\t(lookup_tag_reverse): Use binding_table_reverse_maybe_remap.\n\t(cxx_init_decl_processing): Build global_binding_level->type_decls.\n\t(store_parm_decls): Remove pointless code.\n\t* name-lookup.c (free_binding_entry): New variable.\n\t(ENTRY_INDEX): New macro.\n\t(struct binding_table_s): New datatype.\n\t(binding_entry_make): New function.\n\t(binding_entry_free): Likewise.\n\t(binding_table_construct): Likewise.\n\t(binding_table_free): Likewise.\n\t(binding_table_new): Likewise.\n\t(binding_table_expand): Likewise.\n\t(binding_table_insert): Likewise.\n\t(binding_table_find): Likewise.\n\t(binding_table_find_anon_type): Likewise.\n\t(binding_table_reverse_maybe_remap): Likewise.\n\t(binding_table_remove_anonymous_types): Likewise.\n\t(binding_table_foreach): Likewise.\n\t* name-lookup.h (binding_table): New type.\n\t(binding_entry): Likewise.\n\t(bt_foreach_proc): Likewise.\n\t(struct binding_entry_s): New datatype.\n\t(SCOPE_DEFAULT_HT_SIZE): New macro.\n\t(CLASS_SCOPE_HT_SIZE): Likewise.\n\t(NAMESPACE_ORDINARY_HT_SIZE): Likewise.\n\t(NAMESPACE_STD_HT_SIZE): Likewise.\n\t(GLOBAL_SCOPE_HT_SIZE): Likewise.\n\t(binding_table_new): Declare.\n\t(binding_table_free): Likewise.\n\t(binding_table_insert): Likewise.\n\t(binding_table_find_anon_type): Likewise.\n\t(binding_table_reverse_maybe_remap): Likewise.\n\t(binding_table_remove_anonymous_types): Likewise.\n\t(binding_table_foreach): Likewise.\n\t(binding_table_find): Likewise.\n\t(cxx_remember_type_decls): Likewise.\n\t* pt.c (bt_instantiate_type_proc): New function.\n\t(do_type_instantiation): Use it.\n\t* search.c (lookup_field_r): Use binding_table_find.\n\nFrom-SVN: r66930", "tree": {"sha": "48d321513a6f0b49445946dd5e60ead3215660ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48d321513a6f0b49445946dd5e60ead3215660ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e0c54e5141d403804aad85725680b1791790ed6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e0c54e5141d403804aad85725680b1791790ed6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e0c54e5141d403804aad85725680b1791790ed6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e0c54e5141d403804aad85725680b1791790ed6/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c9acdf71aa42826ff7cd5d54f11214102949ae9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c9acdf71aa42826ff7cd5d54f11214102949ae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c9acdf71aa42826ff7cd5d54f11214102949ae9"}], "stats": {"total": 600, "additions": 474, "deletions": 126}, "files": [{"sha": "54b23920327ce81c6dae9b5ac16b793c9c23e6ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -1,3 +1,10 @@\n+2003-05-18  Gabriel Dos Reis <gdr@integrable-solutions.net>\n+\n+\t* hashtable.h (struct ht_identifier): Add data member \"hash_value\".\n+\t* hashtable.c (ht_lookup): Use it when searching, remember. \n+\t(ht_expand): Do not recompute.\n+\t* tree.h (IDENTIFIER_HASH_VALUE): New macro.\n+\n 2003-05-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gcov-io.c (gcov_read_bytes): Fix fread thinko."}, {"sha": "52267566d6cf1ea00b28bfeb45f470c868001926", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -1,3 +1,65 @@\n+2003-05-18  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* cp-tree.h (struct lang_type_class): Replace data member tags\n+\twith hash-table nested_udts.\n+\t(CLASSTYPE_NESTED_UTDS): Rename from CLASSTYPE_TAGS.\n+\t* class.c (unreverse_member_declarations): Don't touch\n+\tCLASSTYPE_TAGS. \n+\t(pushclass): Use cxx_remember_type_decls.\n+\t* decl.c (struct cp_binding_level): Replace data member tags with\n+\thash-table type_decls.\n+\t(pop_binding_level): Handle level->type_decls.\n+\t(kept_level_p): Adjust.\n+\t(poplevel): Remove unused local variable.\n+\t(bt_print_entry): New function.\n+\t(print_binding_level): Use it.\n+\t(push_namespace): Build current_binding_level->type_decls.\n+\t(maybe_process_template_type_declaration): Adjust.\n+\t(pushtag): Likewise.\n+\t(clear_anon_tags): Use binding_table_remove_anonymous_types.\n+\t(gettags): Remove.\n+\t(cxx_remember_type_decls):  Rename from storetags.  Adjust.\n+\t(lookup_tag): Use binding_table_find_anon_type.  Tidy.\n+\t(lookup_tag_reverse): Use binding_table_reverse_maybe_remap.\n+\t(cxx_init_decl_processing): Build global_binding_level->type_decls.\n+\t(store_parm_decls): Remove pointless code.\n+\t* name-lookup.c (free_binding_entry): New variable.\n+\t(ENTRY_INDEX): New macro.\n+\t(struct binding_table_s): New datatype.\n+\t(binding_entry_make): New function.\n+\t(binding_entry_free): Likewise.\n+\t(binding_table_construct): Likewise.\n+\t(binding_table_free): Likewise.\n+\t(binding_table_new): Likewise.\n+\t(binding_table_expand): Likewise.\n+\t(binding_table_insert): Likewise.\n+\t(binding_table_find): Likewise.\n+\t(binding_table_find_anon_type): Likewise.\n+\t(binding_table_reverse_maybe_remap): Likewise.\n+\t(binding_table_remove_anonymous_types): Likewise.\n+\t(binding_table_foreach): Likewise.\n+\t* name-lookup.h (binding_table): New type.\n+\t(binding_entry): Likewise.\n+\t(bt_foreach_proc): Likewise.\n+\t(struct binding_entry_s): New datatype.\n+\t(SCOPE_DEFAULT_HT_SIZE): New macro.\n+\t(CLASS_SCOPE_HT_SIZE): Likewise.\n+\t(NAMESPACE_ORDINARY_HT_SIZE): Likewise.\n+\t(NAMESPACE_STD_HT_SIZE): Likewise.\n+\t(GLOBAL_SCOPE_HT_SIZE): Likewise.\n+\t(binding_table_new): Declare.\n+\t(binding_table_free): Likewise.\n+\t(binding_table_insert): Likewise.\n+\t(binding_table_find_anon_type): Likewise.\n+\t(binding_table_reverse_maybe_remap): Likewise.\n+\t(binding_table_remove_anonymous_types): Likewise.\n+\t(binding_table_foreach): Likewise.\n+\t(binding_table_find): Likewise.\n+\t(cxx_remember_type_decls): Likewise.\n+\t* pt.c (bt_instantiate_type_proc): New function.\n+\t(do_type_instantiation): Use it.\n+\t* search.c (lookup_field_r): Use binding_table_find.\n+\n 2003-05-18  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \t* semantics.c (perform_deferred_access_checks): Don't discard"}, {"sha": "a8a01886f88a37eda5b5f285521c333d6a42e6f4", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -5226,7 +5226,6 @@ unreverse_member_declarations (tree t)\n   /* The following lists are all in reverse order.  Put them in\n      declaration order now.  */\n   TYPE_METHODS (t) = nreverse (TYPE_METHODS (t));\n-  CLASSTYPE_TAGS (t) = nreverse (CLASSTYPE_TAGS (t));\n   CLASSTYPE_DECL_LIST (t) = nreverse (CLASSTYPE_DECL_LIST (t));\n \n   /* Actually, for the TYPE_FIELDS, only the non TYPE_DECLs are in\n@@ -5561,7 +5560,7 @@ pushclass (tree type, bool modify)\n \t  unuse_fields (type);\n \t}\n \n-      storetags (CLASSTYPE_TAGS (type));\n+      cxx_remember_type_decls (CLASSTYPE_NESTED_UTDS (type));\n     }\n }\n "}, {"sha": "0fecbea9929c5231a6e494ea5f1bb5ef67f1f1fe", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -1098,7 +1098,7 @@ struct lang_type_class GTY(())\n   tree vtables;\n   tree typeinfo_var;\n   tree vbases;\n-  tree tags;\n+  binding_table nested_udts;\n   tree as_base;\n   tree pure_virtuals;\n   tree friend_classes;\n@@ -1310,11 +1310,11 @@ struct lang_type GTY(())\n #define SET_CLASSTYPE_MARKED6(NODE)   SET_CLASSTYPE_MARKED_N (NODE, 5)\n #define CLEAR_CLASSTYPE_MARKED6(NODE) CLEAR_CLASSTYPE_MARKED_N (NODE, 5)\n \n-/* A list of the nested tag-types (class, struct, union, or enum)\n-   found within this class.  The TREE_PURPOSE of each node is the name\n-   of the type; the TREE_VALUE is the type itself.  This list includes\n-   nested member class templates.  */\n-#define CLASSTYPE_TAGS(NODE)\t\t(LANG_TYPE_CLASS_CHECK (NODE)->tags)\n+/* A dictionary of the nested user-defined-types (class-types, or enums)\n+   found within this class.  This table includes nested member class\n+   templates.  */\n+#define CLASSTYPE_NESTED_UTDS(NODE) \\\n+   (LANG_TYPE_CLASS_CHECK (NODE)->nested_udts)\n \n /* Nonzero if NODE has a primary base class, i.e., a base class with\n    which it shares the virtual function table pointer.  */"}, {"sha": "48f4a8cf58ea8e56f852214dbfb6cb518f1d6f1b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 101, "deletions": 106, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -331,15 +331,8 @@ struct cp_binding_level GTY(())\n     /* A chain of VTABLE_DECL nodes.  */\n     tree vtables; \n \n-    /* A list of structure, union and enum definitions, for looking up\n-       tag names.\n-       It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,\n-       or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,\n-       or ENUMERAL_TYPE node.\n-\n-       C++: the TREE_VALUE nodes can be simple types for\n-       component_bindings.  */\n-    tree tags;\n+    /* A dictionary for looking up user-defined-types.  */\n+    binding_table type_decls;\n \n     /* A list of USING_DECL nodes.  */\n     tree usings;\n@@ -544,6 +537,10 @@ pop_binding_level (void)\n     register struct cp_binding_level *level = current_binding_level;\n     current_binding_level = current_binding_level->level_chain;\n     level->level_chain = free_binding_level;\n+    if (level->parm_flag == 2)\n+      level->type_decls = NULL;\n+    else\n+      binding_table_free (level->type_decls);\n #if 0 /* defined(DEBUG_BINDING_LEVELS) */\n     if (level->binding_depth != binding_depth)\n       abort ();\n@@ -678,7 +675,7 @@ kept_level_p (void)\n   return (current_binding_level->blocks != NULL_TREE\n \t  || current_binding_level->keep\n \t  || current_binding_level->names != NULL_TREE\n-\t  || (current_binding_level->tags != NULL_TREE\n+\t  || (current_binding_level->type_decls != NULL\n \t      && !current_binding_level->tag_transparent));\n }\n \n@@ -1215,7 +1212,6 @@ poplevel (int keep, int reverse, int functionbody)\n   tree decls;\n   int tmp = functionbody;\n   int real_functionbody;\n-  tree tags;\n   tree subblocks;\n   tree block = NULL_TREE;\n   tree decl;\n@@ -1230,7 +1226,6 @@ poplevel (int keep, int reverse, int functionbody)\n \n   real_functionbody = (current_binding_level->keep == 2\n \t\t       ? ((functionbody = 0), tmp) : functionbody);\n-  tags = functionbody >= 0 ? current_binding_level->tags : 0;\n   subblocks = functionbody >= 0 ? current_binding_level->blocks : 0;\n \n   my_friendly_assert (!current_binding_level->class_shadowed,\n@@ -1853,6 +1848,45 @@ wrapup_globals_for_namespace (tree namespace, void* data)\n static int no_print_functions = 0;\n static int no_print_builtins = 0;\n \n+/* Called from print_binding_level through binding_table_foreach to\n+   print the content of binding ENTRY.  DATA is a pointer to line offset\n+   marker.  */\n+static void\n+bt_print_entry (binding_entry entry, void *data)\n+{\n+  int *p = (int *) data;\n+  int len;\n+\n+  if (entry->name == NULL)\n+    len = 3;\n+  else if (entry->name == TYPE_IDENTIFIER (entry->type))\n+    len = 2;\n+  else\n+    len = 4;\n+    len = 4;\n+\n+  *p += len;\n+\n+  if (*p > 5)\n+    {\n+      fprintf (stderr, \"\\n\\t\");\n+      *p = len;\n+    }\n+  if (entry->name == NULL)\n+    {\n+      print_node_brief (stderr, \"<unnamed-typedef\", entry->type, 0);\n+      fprintf (stderr, \">\");\n+    }\n+  else if (entry->name == TYPE_IDENTIFIER (entry->type))\n+    print_node_brief (stderr, \"\", entry->type, 0);\n+  else\n+    {\n+      print_node_brief (stderr, \"<typedef\", entry->name, 0);\n+      print_node_brief (stderr, \"\", entry->type, 0);\n+      fprintf (stderr, \">\");\n+    }\n+}\n+\n void\n print_binding_level (struct cp_binding_level* lvl)\n {\n@@ -1898,38 +1932,11 @@ print_binding_level (struct cp_binding_level* lvl)\n       if (i)\n         fprintf (stderr, \"\\n\");\n     }\n-  if (lvl->tags)\n+  if (lvl->type_decls)\n     {\n       fprintf (stderr, \" tags:\\t\");\n       i = 0;\n-      for (t = lvl->tags; t; t = TREE_CHAIN (t))\n-\t{\n-\t  if (TREE_PURPOSE (t) == NULL_TREE)\n-\t    len = 3;\n-\t  else if (TREE_PURPOSE (t) == TYPE_IDENTIFIER (TREE_VALUE (t)))\n-\t    len = 2;\n-\t  else\n-\t    len = 4;\n-\t  i += len;\n-\t  if (i > 5)\n-\t    {\n-\t      fprintf (stderr, \"\\n\\t\");\n-\t      i = len;\n-\t    }\n-\t  if (TREE_PURPOSE (t) == NULL_TREE)\n-\t    {\n-\t      print_node_brief (stderr, \"<unnamed-typedef\", TREE_VALUE (t), 0);\n-\t      fprintf (stderr, \">\");\n-\t    }\n-\t  else if (TREE_PURPOSE (t) == TYPE_IDENTIFIER (TREE_VALUE (t)))\n-\t    print_node_brief (stderr, \"\", TREE_VALUE (t), 0);\n-\t  else\n-\t    {\n-\t      print_node_brief (stderr, \"<typedef\", TREE_PURPOSE (t), 0);\n-\t      print_node_brief (stderr, \"\", TREE_VALUE (t), 0);\n-\t      fprintf (stderr, \">\");\n-\t    }\n-\t}\n+      binding_table_foreach (lvl->type_decls, bt_print_entry, &i);\n       if (i)\n \tfprintf (stderr, \"\\n\");\n     }\n@@ -2059,6 +2066,10 @@ push_namespace (tree name)\n \t  pushlevel (0);\n \t  declare_namespace_level ();\n \t  NAMESPACE_LEVEL (d) = current_binding_level;\n+          current_binding_level->type_decls =\n+            binding_table_new (name == std_identifier\n+                               ? NAMESPACE_STD_HT_SIZE\n+                               : NAMESPACE_ORDINARY_HT_SIZE);\n \t  VARRAY_TREE_INIT (current_binding_level->static_decls,\n \t\t\t    name != std_identifier ? 10 : 200,\n \t\t\t    \"Static declarations\");\n@@ -2427,16 +2438,19 @@ maybe_process_template_type_declaration (tree type,\n \t      && b->level_chain->parm_flag == 2)\n \t    {\n \t      finish_member_declaration (CLASSTYPE_TI_TEMPLATE (type));\n-\t      /* Put this tag on the list of tags for the class, since\n+\t      /* Put this UDT in the table of UDTs for the class, since\n \t\t that won't happen below because B is not the class\n \t\t binding level, but is instead the pseudo-global level.  */\n-\t      b->level_chain->tags =\n-\t\ttree_cons (name, type, b->level_chain->tags);\n+              if (b->level_chain->type_decls == NULL)\n+                b->level_chain->type_decls =\n+                  binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n+              binding_table_insert (b->level_chain->type_decls, name, type);\n \t      if (!COMPLETE_TYPE_P (current_class_type))\n \t\t{\n \t\t  maybe_add_class_template_decl_list (current_class_type,\n \t\t\t\t\t\t      type, /*friend_p=*/0);\n-\t\t  CLASSTYPE_TAGS (current_class_type) = b->level_chain->tags;\n+\t\t  CLASSTYPE_NESTED_UTDS (current_class_type) =\n+                    b->level_chain->type_decls;\n \t\t}\n \t    }\n \t}\n@@ -2526,7 +2540,9 @@ pushtag (tree name, tree type, int globalize)\n \t\t || COMPLETE_TYPE_P (b->this_class))))\n     b = b->level_chain;\n \n-  b->tags = tree_cons (name, type, b->tags);\n+  if (b->type_decls == NULL)\n+    b->type_decls = binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n+  binding_table_insert (b->type_decls, name, type);\n \n   if (name)\n     {\n@@ -2603,7 +2619,7 @@ pushtag (tree name, tree type, int globalize)\n \t    {\n \t      maybe_add_class_template_decl_list (current_class_type,\n \t\t\t\t\t\t  type, /*friend_p=*/0);\n-\t      CLASSTYPE_TAGS (current_class_type) = b->tags;\n+\t      CLASSTYPE_NESTED_UTDS (current_class_type) = b->type_decls;\n \t    }\n \t}\n     }\n@@ -2643,14 +2659,13 @@ make_anon_name (void)\n   return get_identifier (buf);\n }\n \n-/* Clear the TREE_PURPOSE slot of tags which have anonymous typenames.\n+/* Clear the TREE_PURPOSE slot of UTDs which have anonymous typenames.\n    This keeps dbxout from getting confused.  */\n \n void\n clear_anon_tags (void)\n {\n   register struct cp_binding_level *b;\n-  register tree tags;\n   static int last_cnt = 0;\n \n   /* Fast out if no new anon names were declared.  */\n@@ -2660,17 +2675,8 @@ clear_anon_tags (void)\n   b = current_binding_level;\n   while (b->tag_transparent)\n     b = b->level_chain;\n-  tags = b->tags;\n-  while (tags)\n-    {\n-      /* A NULL purpose means we have already processed all tags\n-\t from here to the end of the list.  */\n-      if (TREE_PURPOSE (tags) == NULL_TREE)\n-\tbreak;\n-      if (ANON_AGGRNAME_P (TREE_PURPOSE (tags)))\n-\tTREE_PURPOSE (tags) = NULL_TREE;\n-      tags = TREE_CHAIN (tags);\n-    }\n+  if (b->type_decls != NULL)\n+    binding_table_remove_anonymous_types (b->type_decls);\n   last_cnt = anon_cnt;\n }\n \f\n@@ -5032,14 +5038,6 @@ getdecls (void)\n   return current_binding_level->names;\n }\n \n-/* Return the list of type-tags (for structs, etc) of the current level.  */\n-\n-tree\n-gettags (void)\n-{\n-  return current_binding_level->tags;\n-}\n-\n /* Store the list of declarations of the current level.\n    This is done for the parameter declarations of a function being defined,\n    after they are modified in the light of any missing parameters.  */\n@@ -5050,12 +5048,13 @@ storedecls (tree decls)\n   current_binding_level->names = decls;\n }\n \n-/* Similarly, store the list of tags of the current level.  */\n-\n+/* Set the current binding TABLE for type declarations..  This is a\n+   temporary workaround of the fact that the data structure classtypes\n+   does not currently carry its allocated cxx_scope structure.  */\n void\n-storetags (tree tags)\n+cxx_remember_type_decls (binding_table table)\n {\n-  current_binding_level->tags = tags;\n+  current_binding_level->type_decls = table;\n }\n \f\n /* Return the type that should be used when TYPE's name is preceded\n@@ -5117,19 +5116,20 @@ lookup_tag (enum tree_code form, tree name,\n   /* Nonzero if, we should look past a template parameter level, even\n      if THISLEVEL_ONLY.  */\n   int allow_template_parms_p = 1;\n+  bool type_is_anonymous = ANON_AGGRNAME_P (name);\n \n   timevar_push (TV_NAME_LOOKUP);\n   for (level = binding_level; level; level = level->level_chain)\n     {\n       register tree tail;\n-      if (ANON_AGGRNAME_P (name))\n-\tfor (tail = level->tags; tail; tail = TREE_CHAIN (tail))\n-\t  {\n-\t    /* There's no need for error checking here, because\n-\t       anon names are unique throughout the compilation.  */\n-\t    if (TYPE_IDENTIFIER (TREE_VALUE (tail)) == name)\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_VALUE (tail));\n-\t  }\n+      if (type_is_anonymous && level->type_decls != NULL)\n+        {\n+          tree type = binding_table_find_anon_type (level->type_decls, name);\n+          /* There is no need for error checking here, because\n+           anon names are unique throughout the compilation.  */\n+          if (type != NULL)\n+            POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, type);\n+        }\n       else if (level->namespace_p)\n \t/* Do namespace lookup.  */\n \tfor (tail = current_namespace; 1; tail = CP_DECL_CONTEXT (tail))\n@@ -5171,22 +5171,22 @@ lookup_tag (enum tree_code form, tree name,\n \t    if (thislevel_only || tail == global_namespace)\n \t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n \t  }\n-      else\n-\tfor (tail = level->tags; tail; tail = TREE_CHAIN (tail))\n-\t  {\n-\t    if (TREE_PURPOSE (tail) == name)\n-\t      {\n-\t\tenum tree_code code = TREE_CODE (TREE_VALUE (tail));\n+      else if (level->type_decls != NULL)\n+        {\n+          binding_entry entry = binding_table_find (level->type_decls, name);\n+          if (entry != NULL)\n+            {\n+              enum tree_code code = TREE_CODE (entry->type);\n \t\t\n-\t\tif (code != form\n-\t\t    && (form == ENUMERAL_TYPE || code == ENUMERAL_TYPE))\n-\t\t  {\n-\t\t    /* Definition isn't the kind we were looking for.  */\n-\t\t    error (\"`%#D' redeclared as %C\", TREE_VALUE (tail), form);\n-\t\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-\t\t  }\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_VALUE (tail));\n-\t      }\n+              if (code != form\n+                  && (form == ENUMERAL_TYPE || code == ENUMERAL_TYPE))\n+                {\n+                  /* Definition isn't the kind we were looking for.  */\n+                  error (\"`%#D' redeclared as %C\", entry->type, form);\n+                  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+                }\n+              POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->type);\n+            }\n \t  }\n       if (thislevel_only && ! level->tag_transparent)\n \t{\n@@ -5228,16 +5228,11 @@ lookup_tag_reverse (tree type, tree name)\n   timevar_push (TV_NAME_LOOKUP);\n   for (level = current_binding_level; level; level = level->level_chain)\n     {\n-      register tree tail;\n-      for (tail = level->tags; tail; tail = TREE_CHAIN (tail))\n-\t{\n-\t  if (TREE_VALUE (tail) == type)\n-\t    {\n-\t      if (name)\n-\t\tTREE_PURPOSE (tail) = name;\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_PURPOSE (tail));\n-\t    }\n-\t}\n+      binding_entry entry = level->type_decls == NULL\n+        ? NULL\n+        : binding_table_reverse_maybe_remap (level->type_decls, type, name);\n+      if (entry)\n+        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->name);\n     }\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n }\n@@ -6193,6 +6188,7 @@ cxx_init_decl_processing (void)\n   /* Make the binding_level structure for global names.  */\n   pushlevel (0);\n   global_binding_level = current_binding_level;\n+  global_binding_level->type_decls = binding_table_new (GLOBAL_SCOPE_HT_SIZE);\n   /* The global level is the namespace level of ::.  */\n   NAMESPACE_LEVEL (global_namespace) = global_binding_level;\n   declare_namespace_level ();\n@@ -13700,7 +13696,6 @@ store_parm_decls (tree current_function_parms)\n \t function.  This is all and only the PARM_DECLs that were\n \t pushed into scope by the loop above.  */\n       DECL_ARGUMENTS (fndecl) = getdecls ();\n-      storetags (gettags ());\n     }\n   else\n     DECL_ARGUMENTS (fndecl) = NULL_TREE;"}, {"sha": "bead072a7e2f489b2041e8598d009e31abb96ecf", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -28,6 +28,241 @@ Boston, MA 02111-1307, USA.  */\n #include \"name-lookup.h\"\n #include \"timevar.h\"\n \n+/* Compute the chain index of a binding_entry given the HASH value of its\n+   name and the total COUNT of chains.  COUNT is assumed to be a power\n+   of 2.  */\n+#define ENTRY_INDEX(HASH, COUNT) (((HASH) >> 3) & ((COUNT) - 1))\n+\n+/* A free list of \"binding_entry\"s awaiting for re-use.  */\n+static binding_entry GTY((deletable(\"\"))) free_binding_entry;\n+\n+/* Create a binding_entry object for (NAME, TYPE).  */\n+static inline binding_entry\n+binding_entry_make (tree name, tree type)\n+{\n+  binding_entry entry;\n+\n+  if (free_binding_entry)\n+    {\n+      entry = free_binding_entry;\n+      free_binding_entry = entry->chain;\n+    }\n+  else\n+    entry = ggc_alloc (sizeof (struct binding_entry_s));\n+\n+  entry->name = name;\n+  entry->type = type;\n+\n+  return entry;\n+}\n+\n+/* Put ENTRY back on the free list.  */\n+static inline void\n+binding_entry_free (binding_entry entry)\n+{\n+  entry->chain = free_binding_entry;\n+  free_binding_entry = entry;\n+}\n+\n+/* The datatype used to implement the mapping from names to types at\n+   a given scope.  */\n+struct binding_table_s GTY(())\n+{\n+  /* Array of chains of \"binding_entry\"s  */\n+  binding_entry * GTY((length (\"%h.chain_count\"))) chain;\n+\n+  /* The number of chains in this table.  This is the length of the\n+     the member \"chaiin\" considered as an array.  */\n+  size_t chain_count;\n+\n+  /* Number of \"binding_entry\"s in this table.  */\n+  size_t entry_count;\n+};\n+\n+/* Construct TABLE with an initial CHAIN_COUNT.  */\n+static inline void\n+binding_table_construct (binding_table table, size_t chain_count)\n+{\n+  table->chain_count = chain_count;\n+  table->entry_count = 0;\n+  table->chain = ggc_alloc_cleared\n+    (table->chain_count * sizeof (binding_entry));\n+}\n+\n+/* Free TABLE by making its entries ready for reuse. */\n+void\n+binding_table_free (binding_table table)\n+{\n+  size_t i;\n+  if (table == NULL)\n+    return;\n+\n+  for (i = 0; i < table->chain_count; ++i)\n+    {\n+      while (table->chain[i] != NULL)\n+        {\n+          binding_entry entry = table->chain[i];\n+          table->chain[i] = entry->chain;\n+          binding_entry_free (entry);\n+        }\n+    }\n+  table->entry_count = 0;\n+}\n+\n+/* Allocate a table with CHAIN_COUNT, assumed to be a power of two.  */\n+binding_table\n+binding_table_new (size_t chain_count)\n+{\n+  binding_table table = ggc_alloc (sizeof (struct binding_table_s));\n+  binding_table_construct (table, chain_count);\n+  return table;\n+}\n+\n+/* Expand TABLE to twice its current chain_count.  */\n+static void\n+binding_table_expand (binding_table table)\n+{\n+  const size_t old_chain_count = table->chain_count;\n+  const size_t old_entry_count = table->entry_count;\n+  const size_t new_chain_count = 2 * old_chain_count;\n+  binding_entry *old_chains = table->chain;\n+  size_t i;\n+\n+  binding_table_construct (table, new_chain_count);\n+  for (i = 0; i < old_chain_count; ++i)\n+    {\n+      binding_entry entry = old_chains[i];\n+      for (; entry != NULL; entry = old_chains[i])\n+        {\n+          const unsigned int hash = IDENTIFIER_HASH_VALUE (entry->name);\n+          const size_t j = ENTRY_INDEX (hash, new_chain_count);\n+\n+          old_chains[i] = entry->chain;\n+          entry->chain = table->chain[j];\n+          table->chain[j] = entry;\n+        }\n+    }\n+  table->entry_count = old_entry_count;\n+}\n+\n+/* Insert a binding for NAME to TYPe into TABLE.  */\n+void\n+binding_table_insert (binding_table table, tree name, tree type)\n+{\n+  const unsigned int hash = IDENTIFIER_HASH_VALUE (name);\n+  const size_t i = ENTRY_INDEX (hash, table->chain_count);\n+  binding_entry entry = binding_entry_make (name, type);\n+\n+  entry->chain = table->chain[i];\n+  table->chain[i] = entry;\n+  ++table->entry_count;\n+\n+  if (3 * table->chain_count < 5 * table->entry_count)\n+    binding_table_expand (table);\n+}\n+\n+/* Return the binding_entry, if any, that maps NAME.  */\n+binding_entry\n+binding_table_find (binding_table table, tree name)\n+{\n+  const unsigned int hash = IDENTIFIER_HASH_VALUE (name);\n+  binding_entry entry = table->chain[ENTRY_INDEX (hash, table->chain_count)];\n+\n+  while (entry != NULL && entry->name != name)\n+    entry = entry->chain;\n+\n+  return entry;\n+}\n+\n+/* Return the binding_entry, if any, that maps name to an anonymous type.  */\n+tree\n+binding_table_find_anon_type (binding_table table, tree name)\n+{\n+  const unsigned int hash = IDENTIFIER_HASH_VALUE (name);\n+  binding_entry entry = table->chain[ENTRY_INDEX (hash, table->chain_count)];\n+\n+  while (entry != NULL && TYPE_IDENTIFIER (entry->type) != name)\n+    entry = entry->chain;\n+\n+  return entry ? entry->type : NULL;\n+}\n+\n+/* Return the binding_entry, if any, that has TYPE as target.  If NAME\n+   is non-null, then set the domain and rehash that entry.  */\n+binding_entry\n+binding_table_reverse_maybe_remap (binding_table table, tree type, tree name)\n+{\n+  const size_t chain_count = table->chain_count;\n+  binding_entry entry = NULL;\n+  binding_entry *p = NULL;\n+  size_t i;\n+\n+  for (i = 0; i < chain_count && entry == NULL; ++i)\n+    {\n+      p = &table->chain[i];\n+      while (*p != NULL && entry == NULL)\n+        if ((*p)->type == type)\n+          entry = *p;\n+        else\n+          p = &(*p)->chain;\n+    }\n+\n+  if (entry != NULL && name != NULL && entry->name != name)\n+    {\n+      /* Remove the bucket from the previous chain.  */\n+      *p = (*p)->chain;\n+\n+      /* Remap the name type to type.  */\n+      i = ENTRY_INDEX (IDENTIFIER_HASH_VALUE (name), chain_count);\n+      entry->chain = table->chain[i];\n+      entry->name = name;\n+      table->chain[i] = entry;\n+    }\n+\n+  return entry;\n+}\n+\n+/* Remove from TABLE all entries that map to anonymous enums or\n+   class-types.  */\n+void\n+binding_table_remove_anonymous_types (binding_table table)\n+{\n+  const size_t chain_count = table->chain_count;\n+  size_t i;\n+\n+  for (i = 0; i < chain_count; ++i)\n+    {\n+      binding_entry *p = &table->chain[i];\n+\n+      while (*p != NULL)\n+        if (ANON_AGGRNAME_P ((*p)->name))\n+          {\n+            binding_entry e = *p;\n+            *p = (*p)->chain;\n+            --table->entry_count;\n+            binding_entry_free (e);\n+          }\n+        else\n+          p = &(*p)->chain;\n+    }\n+}\n+\n+/* Apply PROC -- with DATA -- to all entries in TABLE.  */\n+void\n+binding_table_foreach (binding_table table, bt_foreach_proc proc, void *data)\n+{\n+  const size_t chain_count = table->chain_count;\n+  size_t i;\n+\n+  for (i = 0; i < chain_count; ++i)\n+    {\n+      binding_entry entry = table->chain[i];\n+      for (; entry != NULL; entry = entry->chain)\n+        proc (entry, data);\n+    }\n+}\n+\f\n+\n /* A free list of \"cxx_binding\"s, connected by their PREVIOUS.  */\n static GTY((deletable (\"\"))) cxx_binding *free_bindings;\n "}, {"sha": "1222f5e4a612cd9ebf9a4adb42482b56a3e5360f", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -24,6 +24,39 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"c-common.h\"\n \n+/* The type of dictionary used to map names to types declared at\n+   a given scope.  */\n+typedef struct binding_table_s *binding_table;\n+typedef struct binding_entry_s *binding_entry;\n+\n+/* The type of a routine repeatedly called by binding_table_foreach.  */\n+typedef void (*bt_foreach_proc) (binding_entry, void *);\n+\n+struct binding_entry_s GTY(())\n+{\n+  binding_entry chain;\n+  tree name;\n+  tree type;\n+};\n+\n+/* These macros indicate the initial chains count for binding_table.  */\n+#define SCOPE_DEFAULT_HT_SIZE                        (1 << 3)\n+#define CLASS_SCOPE_HT_SIZE                          (1 << 3)\n+#define NAMESPACE_ORDINARY_HT_SIZE                   (1 << 5)\n+#define NAMESPACE_STD_HT_SIZE                        (1 << 8)\n+#define GLOBAL_SCOPE_HT_SIZE                         (1 << 8)\n+\n+extern binding_table binding_table_new (size_t);\n+extern void binding_table_free (binding_table);\n+extern void binding_table_insert (binding_table, tree, tree);\n+extern tree binding_table_find_anon_type (binding_table, tree);\n+extern binding_entry binding_table_reverse_maybe_remap (binding_table,\n+                                                        tree, tree);\n+extern void binding_table_remove_anonymous_types (binding_table);\n+extern void binding_table_foreach (binding_table, bt_foreach_proc, void *);\n+extern binding_entry binding_table_find (binding_table, tree);\n+extern void cxx_remember_type_decls (binding_table);\n+\f\n /* Datatype used to temporarily save C++ bindings (for implicit\n    instantiations purposes and like).  Implemented in decl.c.  */\n typedef struct cxx_saved_binding cxx_saved_binding;"}, {"sha": "e7feab6de05cd00993307abde5fc2bd111d6e6a6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -5393,7 +5393,7 @@ instantiate_class_template (type)\n \t{\n \t  if (TYPE_P (t))\n \t    {\n-\t      /* Build new CLASSTYPE_TAGS.  */\n+\t      /* Build new CLASSTYPE_NESTED_UTDS.  */\n \n \t      tree tag = t;\n \t      tree name = TYPE_IDENTIFIER (tag);\n@@ -5486,7 +5486,7 @@ instantiate_class_template (type)\n \t\t  /* If it is a TYPE_DECL for a class-scoped ENUMERAL_TYPE,\n \t\t     such a thing will already have been added to the field\n \t\t     list by tsubst_enum in finish_member_declaration in the\n-\t\t     CLASSTYPE_TAGS case above.  */\n+\t\t     CLASSTYPE_NESTED_UTDS case above.  */\n \t\t  if (!(TREE_CODE (r) == TYPE_DECL\n \t\t\t&& TREE_CODE (TREE_TYPE (r)) == ENUMERAL_TYPE\n \t\t\t&& TYPE_CONTEXT (TREE_TYPE (r)) == type))\n@@ -10470,6 +10470,18 @@ mark_class_instantiated (t, extern_p)\n     }\n }     \n \n+/* Called from do_type_instantiation through binding_table_foreach to\n+   do recursive instantiation for the type bound in ENTRY.   */\n+static void\n+bt_instantiate_type_proc (binding_entry entry, void *data)\n+{\n+  tree storage = *(tree *) data;\n+\n+  if (IS_AGGR_TYPE (entry->type)\n+      && !uses_template_parms (CLASSTYPE_TI_ARGS (entry->type)))\n+    do_type_instantiation (TYPE_MAIN_DECL (entry->type), storage, 0);\n+}\n+\n /* Perform an explicit instantiation of template class T.  STORAGE, if\n    non-null, is the RID for extern, inline or static.  COMPLAIN is\n    nonzero if this is called from the parser, zero if called recursively,\n@@ -10610,10 +10622,9 @@ do_type_instantiation (t, storage, complain)\n \t    instantiate_decl (tmp, /*defer_ok=*/1);\n \t}\n \n-    for (tmp = CLASSTYPE_TAGS (t); tmp; tmp = TREE_CHAIN (tmp))\n-      if (IS_AGGR_TYPE (TREE_VALUE (tmp))\n-\t  && !uses_template_parms (CLASSTYPE_TI_ARGS (TREE_VALUE (tmp))))\n-\tdo_type_instantiation (TYPE_MAIN_DECL (TREE_VALUE (tmp)), storage, 0);\n+    if (CLASSTYPE_NESTED_UTDS (t))\n+      binding_table_foreach (CLASSTYPE_NESTED_UTDS (t),\n+                             bt_instantiate_type_proc, &storage);\n   }\n }\n "}, {"sha": "7bab0b1e0ba2c857af9d752b5492097214026c52", "filename": "gcc/cp/search.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -1117,11 +1117,12 @@ lookup_field_r (tree binfo, void *data)\n \t}\n       else\n \tnval = NULL_TREE;\n-      if (!nval)\n+      if (!nval && CLASSTYPE_NESTED_UTDS (type) != NULL)\n \t{\n-\t  nval = purpose_member (lfi->name, CLASSTYPE_TAGS (type));\n-\t  if (nval)\n-\t    nval = TYPE_MAIN_DECL (TREE_VALUE (nval));\n+          binding_entry e = binding_table_find (CLASSTYPE_NESTED_UTDS (type),\n+                                                lfi->name);\n+\t  if (e != NULL)\n+\t    nval = TYPE_MAIN_DECL (e->type);\n \t  else \n \t    return NULL_TREE;\n \t}"}, {"sha": "b3f6404ba33a5414119313c1d93af171f286f381", "filename": "gcc/hashtable.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fhashtable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fhashtable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhashtable.c?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -121,7 +121,8 @@ ht_lookup (table, str, len, insert)\n       if (node == NULL)\n \tbreak;\n \n-      if (HT_LEN (node) == len && !memcmp (HT_STR (node), str, len))\n+      if (node->hash_value == hash && HT_LEN (node) == len\n+          && !memcmp (HT_STR (node), str, len))\n \t{\n \t  if (insert == HT_ALLOCED)\n \t    /* The string we search for was placed at the end of the\n@@ -141,6 +142,7 @@ ht_lookup (table, str, len, insert)\n   table->entries[index] = node;\n \n   HT_LEN (node) = len;\n+  node->hash_value = hash;\n   if (insert == HT_ALLOC)\n     HT_STR (node) = obstack_copy0 (&table->stack, str, len);\n   else\n@@ -173,7 +175,7 @@ ht_expand (table)\n       {\n \tunsigned int index, hash, hash2;\n \n-\thash = calc_hash (HT_STR (*p), HT_LEN (*p));\n+\thash = (*p)->hash_value;\n \thash2 = ((hash * 17) & sizemask) | 1;\n \tindex = hash & sizemask;\n "}, {"sha": "11e9893287dbf95cf45b509b3bdd9160f77c930e", "filename": "gcc/hashtable.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhashtable.h?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -27,6 +27,7 @@ struct ht_identifier GTY(())\n {\n   const unsigned char *str;\n   unsigned int len;\n+  unsigned int hash_value;\n };\n \n #define HT_LEN(NODE) ((NODE)->len)"}, {"sha": "9b18558753db405226a84354db0d0425878401f3", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0c54e5141d403804aad85725680b1791790ed6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5e0c54e5141d403804aad85725680b1791790ed6", "patch": "@@ -813,6 +813,8 @@ struct tree_vector GTY(())\n   (IDENTIFIER_NODE_CHECK (NODE)->identifier.id.len)\n #define IDENTIFIER_POINTER(NODE) \\\n   ((const char *) IDENTIFIER_NODE_CHECK (NODE)->identifier.id.str)\n+#define IDENTIFIER_HASH_VALUE(NODE) \\\n+  (IDENTIFIER_NODE_CHECK (NODE)->identifier.id.hash_value)\n \n /* Translate a hash table identifier pointer to a tree_identifier\n    pointer, and vice versa.  */"}]}