{"sha": "adb84b4254d23c4ff58f53c4f48971b6cd8395d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRiODRiNDI1NGQyM2M0ZmY1OGY1M2M0ZjQ4OTcxYjZjZDgzOTVkMQ==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-11-08T23:08:07Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-08T23:08:07Z"}, "message": "Move directive handling into the lexer itself.\n\n        * cpplex.c (_cpp_lex_token): Handle directives directly.\n        In the case of a directive interrupting a function-like\n        macro invocation, use extra_char since read_ahead is\n        used to store the '#'.  Return a CPP_EOF in this case.\n        * cppmacro.c (parse_arg): No need to handle CPP_DHASH any more.\n        (cpp_get_token): Don't handle directives here.\n        * cpplib.h: Remove CPP_DHASH token type.\n\nFrom-SVN: r37329", "tree": {"sha": "2829d58899280886dce9cbba61c7c88422fd36e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2829d58899280886dce9cbba61c7c88422fd36e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adb84b4254d23c4ff58f53c4f48971b6cd8395d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb84b4254d23c4ff58f53c4f48971b6cd8395d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adb84b4254d23c4ff58f53c4f48971b6cd8395d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb84b4254d23c4ff58f53c4f48971b6cd8395d1/comments", "author": null, "committer": null, "parents": [{"sha": "09ff8283a84ea06073df34b17baad67126f5b68e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09ff8283a84ea06073df34b17baad67126f5b68e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09ff8283a84ea06073df34b17baad67126f5b68e"}], "stats": {"total": 81, "additions": 50, "deletions": 31}, "files": [{"sha": "ef955ac66f8a77c622b403b0af3edcdade9c00f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb84b4254d23c4ff58f53c4f48971b6cd8395d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb84b4254d23c4ff58f53c4f48971b6cd8395d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=adb84b4254d23c4ff58f53c4f48971b6cd8395d1", "patch": "@@ -1,3 +1,15 @@\n+2000-11-08  Neil Booth  <neilb@earthling.net>\n+\n+        Move directive handling into the lexer itself.\n+\t  \n+        * cpplex.c (_cpp_lex_token): Handle directives directly.\n+        In the case of a directive interrupting a function-like\n+        macro invocation, use extra_char since read_ahead is\n+        used to store the '#'.  Return a CPP_EOF in this case.\n+        * cppmacro.c (parse_arg): No need to handle CPP_DHASH any more.\n+        (cpp_get_token): Don't handle directives here.\n+        * cpplib.h: Remove CPP_DHASH token type.\n+\n Wed Nov  8 21:53:41 MET 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* regmove.c (combine_stack_adjustments_for_blocks): Recognize pushes"}, {"sha": "fb5eec55929e568b70569cfbb28101b518a450e4", "filename": "gcc/cpplex.c", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb84b4254d23c4ff58f53c4f48971b6cd8395d1/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb84b4254d23c4ff58f53c4f48971b6cd8395d1/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=adb84b4254d23c4ff58f53c4f48971b6cd8395d1", "patch": "@@ -844,11 +844,13 @@ _cpp_lex_token (pfile, result)\n      cpp_token *result;\n {\n   cppchar_t c;\n-  cpp_buffer *buffer = pfile->buffer;\n+  cpp_buffer *buffer;\n   const unsigned char *comment_start;\n   unsigned char was_skip_newlines = pfile->state.skip_newlines;\n   unsigned char newline_in_args = 0;\n \n+ done_directive:\n+  buffer = pfile->buffer;\n   pfile->state.skip_newlines = 0;\n   result->flags = 0;\n  next_char:\n@@ -1160,20 +1162,51 @@ _cpp_lex_token (pfile, result)\n       break;\n \t  \n     case '#':\n-      if (get_effective_char (buffer) == '#')\n+      c = buffer->extra_char;\t/* Can be set by error condition below.  */\n+      if (c != EOF)\n+\t{\n+\t  buffer->read_ahead = c;\n+\t  buffer->extra_char = EOF;\n+\t}\n+      else\n+\tc = get_effective_char (buffer);\n+\n+      if (c == '#')\n \tACCEPT_CHAR (CPP_PASTE);\n       else\n \t{\n \t  result->type = CPP_HASH;\n \tdo_hash:\n-\t  /* CPP_DHASH is the hash introducing a directive.  */\n-\t  if (was_skip_newlines || newline_in_args)\n+\t  if (newline_in_args)\n \t    {\n-\t      result->type = CPP_DHASH;\n+\t      /* 6.10.3 paragraph 11: If there are sequences of\n+\t\t preprocessing tokens within the list of arguments that\n+\t\t would otherwise act as preprocessing directives, the\n+\t\t behavior is undefined.\n+\n+\t\t This implementation will report a hard error, terminate\n+\t\t the macro invocation, and proceed to process the\n+\t\t directive.  */\n+\t      cpp_error (pfile,\n+\t\t\t \"directives may not be used inside a macro argument\");\n+\n+\t      /* Put a '#' in lookahead, return CPP_EOF for parse_arg.  */\n+\t      buffer->extra_char = buffer->read_ahead;\n+\t      buffer->read_ahead = '#';\n+\t      pfile->state.skip_newlines = 1;\n+\t      result->type = CPP_EOF;\n+\n \t      /* Get whitespace right - newline_in_args sets it.  */\n \t      if (pfile->lexer_pos.col == 1)\n \t\tresult->flags &= ~PREV_WHITE;\n \t    }\n+\t  else if (was_skip_newlines)\n+\t    {\n+\t      /* This is the hash introducing a directive.  */\n+\t      if (_cpp_handle_directive (pfile, result->flags & PREV_WHITE))\n+\t\tgoto done_directive; /* was_skip_newlines still 1.  */\n+\t      /* This is in fact an assembler #.  */\n+\t    }\n \t}\n       break;\n "}, {"sha": "742e1a9dd88986bf600cd05c1c4627555a532711", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb84b4254d23c4ff58f53c4f48971b6cd8395d1/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb84b4254d23c4ff58f53c4f48971b6cd8395d1/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=adb84b4254d23c4ff58f53c4f48971b6cd8395d1", "patch": "@@ -139,7 +139,6 @@ struct htab;\n   TK(CPP_HEADER_NAME,\tSPELL_STRING)\t/* <stdio.h> in #include */\t\\\n \\\n   TK(CPP_COMMENT,\tSPELL_STRING)\t/* Only if output comments.  */ \\\n-  TK(CPP_DHASH,\t\tSPELL_NONE)\t/* The # of a directive.  */\t\\\n   TK(CPP_MACRO_ARG,\tSPELL_NONE)\t/* Macro argument.  */\t\t\\\n   TK(CPP_PLACEMARKER,\tSPELL_NONE)\t/* Placemarker token.  */\t\\\n   OP(CPP_EOF,\t\t\"EOL\")\t\t/* End of line or file.  */"}, {"sha": "766a71971564c61238be0941fa9b8a72e363b2d1", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb84b4254d23c4ff58f53c4f48971b6cd8395d1/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb84b4254d23c4ff58f53c4f48971b6cd8395d1/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=adb84b4254d23c4ff58f53c4f48971b6cd8395d1", "patch": "@@ -534,21 +534,6 @@ parse_arg (pfile, arg, var_args)\n \tbreak;\n       else if (result == CPP_EOF)\n \tbreak;\t\t/* Error reported by caller.  */\n-      else if (result == CPP_DHASH)\n-\t{\n-\t  /* 6.10.3 paragraph 11: If there are sequences of\n-\t     preprocessing tokens within the list of arguments that\n-\t     would otherwise act as preprocessing directives, the\n-\t     behavior is undefined.\n-\n-\t     This implementation will report a hard error, terminate\n-\t     the macro invocation, and proceed to process the\n-\t     directive.  */\n-\t  cpp_error (pfile, \"directives may not be used inside a macro argument\");\n-\t  _cpp_push_token (pfile, token, &pfile->lexer_pos);\n-\t  result = CPP_EOF;\n-\t  break;\n-\t}\n     }\n \n   /* Empty arguments become a single placemarker token.  */\n@@ -1019,16 +1004,6 @@ cpp_get_token (pfile, token)\n \t    break;\n \t  continue;\n \t}\n-      else if (token->type == CPP_DHASH)\n-\t{\n-\t  /* Handle directives.  */\n-\t  if (_cpp_handle_directive (pfile, token->flags & PREV_WHITE))\n-\t    continue;\n-\t  /* This is in fact an assembler #.  */\n-\t  if (pfile->skipping)\n-\t    continue;\n-\t  token->type = CPP_HASH;\n-\t}\n       /* We are not merging the PREV_WHITE of CPP_PLACEMARKERS.  I\n          don't think it really matters.  */\n       else if (pfile->skipping || token->type == CPP_PLACEMARKER)"}]}