{"sha": "fc2241eb94b9b29bd2613ea02224a78fdb242a95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMyMjQxZWI5NGI5YjI5YmQyNjEzZWEwMjIyNGE3OGZkYjI0MmE5NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-03-06T08:54:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-03-06T08:54:31Z"}, "message": "re PR target/23482 ([ColdFire] ICE in in final_scan_insn)\n\ngcc/\n\tPR target/23482\n\tPR target/17114\n\t* config/m68k/m68k-protos.h (m68k_legitimate_base_reg_p): Declare.\n\t(m68k_legitimate_index_reg_p, m68k_legitimate_address_p): Likewise.\n\t(m68k_matches_q_p, m68k_matches_u_p): Likewise.\n\t* config/m68k/m68k.h (EXTRA_CONSTRAINT): Use m68k_matches_q_p\n\tand m68k_matches_u_p.\n\t(PCREL_GENERAL_OPERAND_OK, LEGITIMATE_BASE_REG_P): Delete.\n\t(INDIRECTABLE_1_ADDRESS_P, GO_IF_NONINDEXED_ADDRESS): Delete.\n\t(GO_IF_INDEXABLE_BASE, GO_IF_INDEXING, GO_IF_INDEXED_ADDRESS): Delete.\n\t(LEGITIMATE_INDEX_REG_P, LEGITIMATE_INDEX_P): Delete.\n\t(GO_IF_COLDFIRE_FPU_LEGITIMATE_ADDRESS): Delete.\n\t(REG_STRICT_P): New macro.\n\t(LEGITIMATE_PIC_OPERAND_P): Use REG_STRICT_P rather than\n\tPCREL_GENERAL_OPERAND_OK.\n\t(REG_OK_FOR_BASE_P): Merge definitions.  Use REG_STRICT_P and\n\tm68k_legitimate_base_reg_p.\n\t(REG_MODE_OK_FOR_INDEX_P): Likewise m68k_legitimate_index_reg_p.\n\t(GO_IF_LEGITIMATE_ADDRESS): Likewise m68k_legitimate_address_p.\n\t(PIC_CASE_VECTOR_ADDRESS): Update comment.\n\t* config/m68k/m68k.c (m68k_address): New structure.\n\t(m68k_legitimate_base_reg_p, m68k_legitimate_index_reg_p)\n\t(m68k_decompose_index, m68k_legitimate_constant_address_p)\n\t(m68k_jump_table_ref_p, m68k_decompose_address)\n\t(m68k_legitimate_address_p, m68k_legitimate_mem_p, m68k_matches_q_p)\n\t(m68k_matches_u_p): New functions.\n\t(print_operand_address): Rewrite to use m68k_decompose_index.\n\nFrom-SVN: r122604", "tree": {"sha": "0544b8bd7f9f6730bbcc3fc4fcde1021d7aec1e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0544b8bd7f9f6730bbcc3fc4fcde1021d7aec1e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc2241eb94b9b29bd2613ea02224a78fdb242a95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc2241eb94b9b29bd2613ea02224a78fdb242a95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc2241eb94b9b29bd2613ea02224a78fdb242a95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc2241eb94b9b29bd2613ea02224a78fdb242a95/comments", "author": null, "committer": null, "parents": [{"sha": "4b4eb6480d273e302d5f4addee13b49e584bead4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4eb6480d273e302d5f4addee13b49e584bead4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b4eb6480d273e302d5f4addee13b49e584bead4"}], "stats": {"total": 858, "additions": 490, "deletions": 368}, "files": [{"sha": "c22df6859604b3041ce1cd52a3a6031661053c52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2241eb94b9b29bd2613ea02224a78fdb242a95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2241eb94b9b29bd2613ea02224a78fdb242a95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc2241eb94b9b29bd2613ea02224a78fdb242a95", "patch": "@@ -1,3 +1,33 @@\n+2007-03-06  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR target/23482\n+\tPR target/17114\n+\t* config/m68k/m68k-protos.h (m68k_legitimate_base_reg_p): Declare.\n+\t(m68k_legitimate_index_reg_p, m68k_legitimate_address_p): Likewise.\n+\t(m68k_matches_q_p, m68k_matches_u_p): Likewise.\n+\t* config/m68k/m68k.h (EXTRA_CONSTRAINT): Use m68k_matches_q_p\n+\tand m68k_matches_u_p.\n+\t(PCREL_GENERAL_OPERAND_OK, LEGITIMATE_BASE_REG_P): Delete.\n+\t(INDIRECTABLE_1_ADDRESS_P, GO_IF_NONINDEXED_ADDRESS): Delete.\n+\t(GO_IF_INDEXABLE_BASE, GO_IF_INDEXING, GO_IF_INDEXED_ADDRESS): Delete.\n+\t(LEGITIMATE_INDEX_REG_P, LEGITIMATE_INDEX_P): Delete.\n+\t(GO_IF_COLDFIRE_FPU_LEGITIMATE_ADDRESS): Delete.\n+\t(REG_STRICT_P): New macro.\n+\t(LEGITIMATE_PIC_OPERAND_P): Use REG_STRICT_P rather than\n+\tPCREL_GENERAL_OPERAND_OK.\n+\t(REG_OK_FOR_BASE_P): Merge definitions.  Use REG_STRICT_P and\n+\tm68k_legitimate_base_reg_p.\n+\t(REG_MODE_OK_FOR_INDEX_P): Likewise m68k_legitimate_index_reg_p.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Likewise m68k_legitimate_address_p.\n+\t(PIC_CASE_VECTOR_ADDRESS): Update comment.\n+\t* config/m68k/m68k.c (m68k_address): New structure.\n+\t(m68k_legitimate_base_reg_p, m68k_legitimate_index_reg_p)\n+\t(m68k_decompose_index, m68k_legitimate_constant_address_p)\n+\t(m68k_jump_table_ref_p, m68k_decompose_address)\n+\t(m68k_legitimate_address_p, m68k_legitimate_mem_p, m68k_matches_q_p)\n+\t(m68k_matches_u_p): New functions.\n+\t(print_operand_address): Rewrite to use m68k_decompose_index.\n+\n 2007/03/05  David Taylor  <dtaylor@emc.com>\n \n \t* gcc.c: Correct copyright date in --version output."}, {"sha": "ba137d6848c869df0e5bfadd289a10fef3a8ec8f", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2241eb94b9b29bd2613ea02224a78fdb242a95/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2241eb94b9b29bd2613ea02224a78fdb242a95/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=fc2241eb94b9b29bd2613ea02224a78fdb242a95", "patch": "@@ -50,7 +50,12 @@ extern int standard_68881_constant_p (rtx);\n extern void print_operand_address (FILE *, rtx);\n extern void print_operand (FILE *, rtx, int);\n extern void notice_update_cc (rtx, rtx);\n+extern bool m68k_legitimate_base_reg_p (rtx, bool);\n+extern bool m68k_legitimate_index_reg_p (rtx, bool);\n extern bool m68k_illegitimate_symbolic_constant_p (rtx);\n+extern bool m68k_legitimate_address_p (enum machine_mode, rtx, bool);\n+extern bool m68k_matches_q_p (rtx);\n+extern bool m68k_matches_u_p (rtx);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern int valid_dbcc_comparison_p_2 (rtx, enum machine_mode);\n extern rtx m68k_libcall_value (enum machine_mode);"}, {"sha": "57e15c82de41a9c838362a71b4df1eb43bf4533d", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 440, "deletions": 227, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2241eb94b9b29bd2613ea02224a78fdb242a95/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2241eb94b9b29bd2613ea02224a78fdb242a95/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=fc2241eb94b9b29bd2613ea02224a78fdb242a95", "patch": "@@ -103,6 +103,27 @@ struct m68k_frame\n /* Current frame information calculated by m68k_compute_frame_layout().  */\n static struct m68k_frame current_frame;\n \n+/* Structure describing an m68k address.\n+\n+   If CODE is UNKNOWN, the address is BASE + INDEX * SCALE + OFFSET,\n+   with null fields evaluating to 0.  Here:\n+\n+   - BASE satisfies m68k_legitimate_base_reg_p\n+   - INDEX satisfies m68k_legitimate_index_reg_p\n+   - OFFSET satisfies m68k_legitimate_constant_address_p\n+\n+   INDEX is either HImode or SImode.  The other fields are SImode.\n+\n+   If CODE is PRE_DEC, the address is -(BASE).  If CODE is POST_INC,\n+   the address is (BASE)+.  */\n+struct m68k_address {\n+  enum rtx_code code;\n+  rtx base;\n+  rtx index;\n+  rtx offset;\n+  int scale;\n+};\n+\n static bool m68k_handle_option (size_t, const char *, int);\n static rtx find_addr_reg (rtx);\n static const char *singlemove_string (rtx *);\n@@ -1666,6 +1687,76 @@ output_btst (rtx *operands, rtx countop, rtx dataop, rtx insn, int signpos)\n   return \"btst %0,%1\";\n }\n \f\n+/* Return true if X is a legitimate base register.  STRICT_P says\n+   whether we need strict checking.  */\n+\n+bool\n+m68k_legitimate_base_reg_p (rtx x, bool strict_p)\n+{\n+  /* Allow SUBREG everywhere we allow REG.  This results in better code.  */\n+  if (!strict_p && GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+\n+  return (REG_P (x)\n+\t  && (strict_p\n+\t      ? REGNO_OK_FOR_BASE_P (REGNO (x))\n+\t      : !DATA_REGNO_P (REGNO (x)) && !FP_REGNO_P (REGNO (x))));\n+}\n+\n+/* Return true if X is a legitimate index register.  STRICT_P says\n+   whether we need strict checking.  */\n+\n+bool\n+m68k_legitimate_index_reg_p (rtx x, bool strict_p)\n+{\n+  if (!strict_p && GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+\n+  return (REG_P (x)\n+\t  && (strict_p\n+\t      ? REGNO_OK_FOR_INDEX_P (REGNO (x))\n+\t      : !FP_REGNO_P (REGNO (x))));\n+}\n+\n+/* Return true if X is a legitimate index expression for a (d8,An,Xn) or\n+   (bd,An,Xn) addressing mode.  Fill in the INDEX and SCALE fields of\n+   ADDRESS if so.  STRICT_P says whether we need strict checking.  */\n+\n+static bool\n+m68k_decompose_index (rtx x, bool strict_p, struct m68k_address *address)\n+{\n+  int scale;\n+\n+  /* Check for a scale factor.  */\n+  scale = 1;\n+  if ((TARGET_68020 || TARGET_COLDFIRE)\n+      && GET_CODE (x) == MULT\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && (INTVAL (XEXP (x, 1)) == 2\n+\t  || INTVAL (XEXP (x, 1)) == 4\n+\t  || (INTVAL (XEXP (x, 1)) == 8\n+\t      && (TARGET_COLDFIRE_FPU || !TARGET_COLDFIRE))))\n+    {\n+      scale = INTVAL (XEXP (x, 1));\n+      x = XEXP (x, 0);\n+    }\n+\n+  /* Check for a word extension.  */\n+  if (!TARGET_COLDFIRE\n+      && GET_CODE (x) == SIGN_EXTEND\n+      && GET_MODE (XEXP (x, 0)) == HImode)\n+    x = XEXP (x, 0);\n+\n+  if (m68k_legitimate_index_reg_p (x, strict_p))\n+    {\n+      address->scale = scale;\n+      address->index = x;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Return true if X is an illegitimate symbolic constant.  */\n \n bool\n@@ -1683,6 +1774,251 @@ m68k_illegitimate_symbolic_constant_p (rtx x)\n   return false;\n }\n \n+/* Return true if X is a legitimate constant address that can reach\n+   bytes in the range [X, X + REACH).  STRICT_P says whether we need\n+   strict checking.  */\n+\n+static bool\n+m68k_legitimate_constant_address_p (rtx x, unsigned int reach, bool strict_p)\n+{\n+  rtx base, offset;\n+\n+  if (!CONSTANT_ADDRESS_P (x))\n+    return false;\n+\n+  if (flag_pic\n+      && !(strict_p && TARGET_PCREL)\n+      && symbolic_operand (x, VOIDmode))\n+    return false;\n+\n+  if (M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P && reach > 1)\n+    {\n+      split_const (x, &base, &offset);\n+      if (GET_CODE (base) == SYMBOL_REF\n+\t  && !offset_within_block_p (base, INTVAL (offset) + reach - 1))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Return true if X is a LABEL_REF for a jump table.  Assume that unplaced\n+   labels will become jump tables.  */\n+\n+static bool\n+m68k_jump_table_ref_p (rtx x)\n+{\n+  if (GET_CODE (x) != LABEL_REF)\n+    return false;\n+\n+  x = XEXP (x, 0);\n+  if (!NEXT_INSN (x) && !PREV_INSN (x))\n+    return true;\n+\n+  x = next_nonnote_insn (x);\n+  return x && JUMP_TABLE_DATA_P (x);\n+}\n+\n+/* Return true if X is a legitimate address for values of mode MODE.\n+   STRICT_P says whether strict checking is needed.  If the address\n+   is valid, describe its components in *ADDRESS.  */\n+\n+static bool\n+m68k_decompose_address (enum machine_mode mode, rtx x,\n+\t\t\tbool strict_p, struct m68k_address *address)\n+{\n+  unsigned int reach;\n+\n+  memset (address, 0, sizeof (*address));\n+\n+  if (mode == BLKmode)\n+    reach = 1;\n+  else\n+    reach = GET_MODE_SIZE (mode);\n+\n+  /* Check for (An) (mode 2).  */\n+  if (m68k_legitimate_base_reg_p (x, strict_p))\n+    {\n+      address->base = x;\n+      return true;\n+    }\n+\n+  /* Check for -(An) and (An)+ (modes 3 and 4).  */\n+  if ((GET_CODE (x) == PRE_DEC || GET_CODE (x) == POST_INC)\n+      && m68k_legitimate_base_reg_p (XEXP (x, 0), strict_p))\n+    {\n+      address->code = GET_CODE (x);\n+      address->base = XEXP (x, 0);\n+      return true;\n+    }\n+\n+  /* Check for (d16,An) (mode 5).  */\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && IN_RANGE (INTVAL (XEXP (x, 1)), -0x8000, 0x8000 - reach)\n+      && m68k_legitimate_base_reg_p (XEXP (x, 0), strict_p))\n+    {\n+      address->base = XEXP (x, 0);\n+      address->offset = XEXP (x, 1);\n+      return true;\n+    }\n+\n+  /* Check for GOT loads.  These are (bd,An,Xn) addresses if\n+     TARGET_68020 && flag_pic == 2, otherwise they are (d16,An)\n+     addresses.  */\n+  if (flag_pic\n+      && GET_CODE (x) == PLUS\n+      && XEXP (x, 0) == pic_offset_table_rtx\n+      && (GET_CODE (XEXP (x, 1)) == SYMBOL_REF\n+\t  || GET_CODE (XEXP (x, 1)) == LABEL_REF))\n+    {\n+      address->base = XEXP (x, 0);\n+      address->offset = XEXP (x, 1);\n+      return true;\n+    }\n+\n+  /* The ColdFire FPU only accepts addressing modes 2-5.  */\n+  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    return false;\n+\n+  /* Check for (xxx).w and (xxx).l.  Also, in the TARGET_PCREL case,\n+     check for (d16,PC) or (bd,PC,Xn) with a suppressed index register.\n+     All these modes are variations of mode 7.  */\n+  if (m68k_legitimate_constant_address_p (x, reach, strict_p))\n+    {\n+      address->offset = x;\n+      return true;\n+    }\n+\n+  /* Check for (d8,PC,Xn), a mode 7 form.  This case is needed for\n+     tablejumps.\n+\n+     ??? do_tablejump creates these addresses before placing the target\n+     label, so we have to assume that unplaced labels are jump table\n+     references.  It seems unlikely that we would ever generate indexed\n+     accesses to unplaced labels in other cases.  */\n+  if (GET_CODE (x) == PLUS\n+      && m68k_jump_table_ref_p (XEXP (x, 1))\n+      && m68k_decompose_index (XEXP (x, 0), strict_p, address))\n+    {\n+      address->offset = XEXP (x, 1);\n+      return true;\n+    }\n+\n+  /* Everything hereafter deals with (d8,An,Xn.SIZE*SCALE) or\n+     (bd,An,Xn.SIZE*SCALE) addresses.  */\n+\n+  if (TARGET_68020)\n+    {\n+      /* Check for a nonzero base displacement.  */\n+      if (GET_CODE (x) == PLUS\n+\t  && m68k_legitimate_constant_address_p (XEXP (x, 1), reach, strict_p))\n+\t{\n+\t  address->offset = XEXP (x, 1);\n+\t  x = XEXP (x, 0);\n+\t}\n+\n+      /* Check for a suppressed index register.  */\n+      if (m68k_legitimate_base_reg_p (x, strict_p))\n+\t{\n+\t  address->base = x;\n+\t  return true;\n+\t}\n+\n+      /* Check for a suppressed base register.  Do not allow this case\n+\t for non-symbolic offsets as it effectively gives gcc freedom\n+\t to treat data registers as base registers, which can generate\n+\t worse code.  */\n+      if (address->offset\n+\t  && symbolic_operand (address->offset, VOIDmode)\n+\t  && m68k_decompose_index (x, strict_p, address))\n+\treturn true;\n+    }\n+  else\n+    {\n+      /* Check for a nonzero base displacement.  */\n+      if (GET_CODE (x) == PLUS\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && IN_RANGE (INTVAL (XEXP (x, 1)), -0x80, 0x80 - reach))\n+\t{\n+\t  address->offset = XEXP (x, 1);\n+\t  x = XEXP (x, 0);\n+\t}\n+    }\n+\n+  /* We now expect the sum of a base and an index.  */\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      if (m68k_legitimate_base_reg_p (XEXP (x, 0), strict_p)\n+\t  && m68k_decompose_index (XEXP (x, 1), strict_p, address))\n+\t{\n+\t  address->base = XEXP (x, 0);\n+\t  return true;\n+\t}\n+\n+      if (m68k_legitimate_base_reg_p (XEXP (x, 1), strict_p)\n+\t  && m68k_decompose_index (XEXP (x, 0), strict_p, address))\n+\t{\n+\t  address->base = XEXP (x, 1);\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Return true if X is a legitimate address for values of mode MODE.\n+   STRICT_P says whether strict checking is needed.  */\n+\n+bool\n+m68k_legitimate_address_p (enum machine_mode mode, rtx x, bool strict_p)\n+{\n+  struct m68k_address address;\n+\n+  return m68k_decompose_address (mode, x, strict_p, &address);\n+}\n+\n+/* Return true if X is a memory, describing its address in ADDRESS if so.\n+   Apply strict checking if called during or after reload.  */\n+\n+static bool\n+m68k_legitimate_mem_p (rtx x, struct m68k_address *address)\n+{\n+  return (MEM_P (x)\n+\t  && m68k_decompose_address (GET_MODE (x), XEXP (x, 0),\n+\t\t\t\t     reload_in_progress || reload_completed,\n+\t\t\t\t     address));\n+}\n+\n+/* Return true if X matches the 'Q' constraint.  It must be a memory\n+   with a base address and no constant offset or index.  */\n+\n+bool\n+m68k_matches_q_p (rtx x)\n+{\n+  struct m68k_address address;\n+\n+  return (m68k_legitimate_mem_p (x, &address)\n+\t  && address.code == UNKNOWN\n+\t  && address.base\n+\t  && !address.offset\n+\t  && !address.index);\n+}\n+\n+/* Return true if X matches the 'U' constraint.  It must be a base address\n+   with a constant offset and no index.  */\n+\n+bool\n+m68k_matches_u_p (rtx x)\n+{\n+  struct m68k_address address;\n+\n+  return (m68k_legitimate_mem_p (x, &address)\n+\t  && address.code == UNKNOWN\n+\t  && address.base\n+\t  && address.offset\n+\t  && !address.index);\n+}\n+\n /* Legitimize PIC addresses.  If the address is already\n    position-independent, we return ORIG.  Newly generated\n    position-independent addresses go to REG.  If we need more\n@@ -3271,265 +3607,142 @@ print_operand (FILE *file, rtx op, int letter)\n    offset is output in word mode (e.g. movel a5@(_foo:w), a0).  When generating\n    -fPIC code the offset is output in long mode (e.g. movel a5@(_foo:l), a0) */\n \n-#if MOTOROLA\n-#  define ASM_OUTPUT_CASE_FETCH(file, labelno, regname) \\\n-  asm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,%s.\", labelno, labelno, regname)\n-#else /* !MOTOROLA */\n-# define ASM_OUTPUT_CASE_FETCH(file, labelno, regname) \\\n-  asm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:\", labelno, labelno, regname)\n-#endif /* !MOTOROLA */\n-\n void\n print_operand_address (FILE *file, rtx addr)\n {\n-  register rtx reg1, reg2, breg, ireg;\n-  rtx offset;\n-\n-  switch (GET_CODE (addr))\n-    {\n-    case REG:\n-      fprintf (file, MOTOROLA ? \"(%s)\" : \"%s@\", M68K_REGNAME (REGNO (addr)));\n-      break;\n-    case PRE_DEC:\n-      fprintf (file, MOTOROLA ? \"-(%s)\" : \"%s@-\",\n-\t       M68K_REGNAME (REGNO (XEXP (addr, 0))));\n-      break;\n-    case POST_INC:\n-      fprintf (file, MOTOROLA ? \"(%s)+\" : \"%s@+\",\n-\t       M68K_REGNAME (REGNO (XEXP (addr, 0))));\n-      break;\n-    case PLUS:\n-      reg1 = reg2 = ireg = breg = offset = 0;\n-      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\n-\t{\n-\t  offset = XEXP (addr, 0);\n-\t  addr = XEXP (addr, 1);\n-\t}\n-      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\n-\t{\n-\t  offset = XEXP (addr, 1);\n-\t  addr = XEXP (addr, 0);\n-\t}\n-      if (GET_CODE (addr) != PLUS)\n-\t{\n-\t  ;\n-\t}\n-      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\n-\t{\n-\t  reg1 = XEXP (addr, 0);\n-\t  addr = XEXP (addr, 1);\n-\t}\n-      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\n-\t{\n-\t  reg1 = XEXP (addr, 1);\n-\t  addr = XEXP (addr, 0);\n-\t}\n-      else if (GET_CODE (XEXP (addr, 0)) == MULT)\n-\t{\n-\t  reg1 = XEXP (addr, 0);\n-\t  addr = XEXP (addr, 1);\n-\t}\n-      else if (GET_CODE (XEXP (addr, 1)) == MULT)\n-\t{\n-\t  reg1 = XEXP (addr, 1);\n-\t  addr = XEXP (addr, 0);\n-\t}\n-      else if (GET_CODE (XEXP (addr, 0)) == REG)\n-\t{\n-\t  reg1 = XEXP (addr, 0);\n-\t  addr = XEXP (addr, 1);\n-\t}\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\n-\t{\n-\t  reg1 = XEXP (addr, 1);\n-\t  addr = XEXP (addr, 0);\n-\t}\n-      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\n-\t  || GET_CODE (addr) == SIGN_EXTEND)\n+  struct m68k_address address;\n+\n+  if (!m68k_decompose_address (QImode, addr, true, &address))\n+    gcc_unreachable ();\n+\n+  if (address.code == PRE_DEC)\n+    fprintf (file, MOTOROLA ? \"-(%s)\" : \"%s@-\",\n+\t     M68K_REGNAME (REGNO (address.base)));\n+  else if (address.code == POST_INC)\n+    fprintf (file, MOTOROLA ? \"(%s)+\" : \"%s@+\",\n+\t     M68K_REGNAME (REGNO (address.base)));\n+  else if (!address.base && !address.index)\n+    {\n+      /* A constant address.  */\n+      gcc_assert (address.offset == addr);\n+      if (GET_CODE (addr) == CONST_INT)\n \t{\n-\t  if (reg1 == 0)\n-\t    reg1 = addr;\n+\t  /* (xxx).w or (xxx).l.  */\n+\t  if (IN_RANGE (INTVAL (addr), -0x8000, 0x7fff))\n+\t    fprintf (file, MOTOROLA ? \"%d.w\" : \"%d:w\", (int) INTVAL (addr));\n \t  else\n-\t    reg2 = addr;\n-\t  addr = 0;\n-\t}\n-#if 0\t/* for OLD_INDEXING */\n-      else if (GET_CODE (addr) == PLUS)\n-\t{\n-\t  if (GET_CODE (XEXP (addr, 0)) == REG)\n-\t    {\n-\t      reg2 = XEXP (addr, 0);\n-\t      addr = XEXP (addr, 1);\n-\t    }\n-\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\n-\t    {\n-\t      reg2 = XEXP (addr, 1);\n-\t      addr = XEXP (addr, 0);\n-\t    }\n-\t}\n-#endif\n-      if (offset != 0)\n-\t{\n-\t  gcc_assert (!addr);\n-\t  addr = offset;\n+\t    fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (addr));\n \t}\n-      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\n-\t\t    || GET_CODE (reg1) == MULT))\n-\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\n-\t{\n-\t  breg = reg2;\n-\t  ireg = reg1;\n-\t}\n-      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\n+      else if (TARGET_PCREL)\n \t{\n-\t  breg = reg1;\n-\t  ireg = reg2;\n+\t  /* (d16,PC) or (bd,PC,Xn) (with suppressed index register).  */\n+\t  fputc ('(', file);\n+\t  output_addr_const (file, addr);\n+\t  asm_fprintf (file, flag_pic == 1 ? \":w,%Rpc)\" : \":l,%Rpc)\");\n \t}\n-      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF\n-\t  && ! (flag_pic && ireg == pic_offset_table_rtx))\n+      else\n \t{\n-\t  int scale = 1;\n-\t  if (GET_CODE (ireg) == MULT)\n-\t    {\n-\t      scale = INTVAL (XEXP (ireg, 1));\n-\t      ireg = XEXP (ireg, 0);\n-\t    }\n-\t  if (GET_CODE (ireg) == SIGN_EXTEND)\n+\t  /* (xxx).l.  We need a special case for SYMBOL_REF if the symbol\n+\t     name ends in `.<letter>', as the last 2 characters can be\n+\t     mistaken as a size suffix.  Put the name in parentheses.  */\n+\t  if (GET_CODE (addr) == SYMBOL_REF\n+\t      && strlen (XSTR (addr, 0)) > 2\n+\t      && XSTR (addr, 0)[strlen (XSTR (addr, 0)) - 2] == '.')\n \t    {\n-\t      ASM_OUTPUT_CASE_FETCH (file,\n-\t\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t\t     M68K_REGNAME (REGNO (XEXP (ireg, 0))));\n-\t      fprintf (file, \"w\");\n+\t      putc ('(', file);\n+\t      output_addr_const (file, addr);\n+\t      putc (')', file);\n \t    }\n \t  else\n-\t    {\n-\t      ASM_OUTPUT_CASE_FETCH (file,\n-\t\t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t\t     M68K_REGNAME (REGNO (ireg)));\n-\t      fprintf (file, \"l\");\n-\t    }\n-\t  if (scale != 1)\n-\t    fprintf (file, MOTOROLA ? \"*%d\" : \":%d\", scale);\n-\t  putc (')', file);\n-\t  break;\n-\t}\n-      if (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF\n-\t  && ! (flag_pic && breg == pic_offset_table_rtx))\n-\t{\n-\t  ASM_OUTPUT_CASE_FETCH (file,\n-\t\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t\t M68K_REGNAME (REGNO (breg)));\n-\t  fprintf (file, \"l)\");\n-\t  break;\n+\t    output_addr_const (file, addr);\n \t}\n-      if (ireg != 0 || breg != 0)\n+    }\n+  else\n+    {\n+      int labelno;\n+\n+      /* If ADDR is a (d8,pc,Xn) address, this is the number of the\n+\t label being acceesed, otherwise it is -1.  */\n+      labelno = (address.offset\n+\t\t && !address.base\n+\t\t && GET_CODE (address.offset) == LABEL_REF\n+\t\t ? CODE_LABEL_NUMBER (XEXP (address.offset, 0))\n+\t\t : -1);\n+      if (MOTOROLA)\n \t{\n-\t  int scale = 1;\n-\t    \n-\t  gcc_assert (breg);\n-\t  gcc_assert (flag_pic || !addr || GET_CODE (addr) != LABEL_REF);\n-\t    \n-\t  if (MOTOROLA)\n+\t  /* Print the \"offset(base\" component.  */\n+\t  if (labelno >= 0)\n+\t    asm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,\", labelno, labelno);\n+\t  else\n \t    {\n-\t      if (addr != 0)\n+\t      if (address.offset)\n \t\t{\n-\t\t  output_addr_const (file, addr);\n-\t\t  if (flag_pic && (breg == pic_offset_table_rtx))\n+\t\t  output_addr_const (file, address.offset);\n+\t\t  if (flag_pic && address.base == pic_offset_table_rtx)\n \t\t    {\n \t\t      fprintf (file, \"@GOT\");\n-\t\t      if (flag_pic == 1)\n+\t\t      if (flag_pic == 1 && TARGET_68020)\n \t\t\tfprintf (file, \".w\");\n \t\t    }\n \t\t}\n-\t      fprintf (file, \"(%s\", M68K_REGNAME (REGNO (breg)));\n-\t      if (ireg != 0)\n-\t\tputc (',', file);\n+\t      putc ('(', file);\n+\t      if (address.base)\n+\t\tfputs (M68K_REGNAME (REGNO (address.base)), file);\n \t    }\n-\t  else /* !MOTOROLA */\n+\t  /* Print the \",index\" component, if any.  */\n+\t  if (address.index)\n \t    {\n-\t      fprintf (file, \"%s@(\", M68K_REGNAME (REGNO (breg)));\n-\t      if (addr != 0)\n-\t\t{\n-\t\t  output_addr_const (file, addr);\n-\t\t  if (breg == pic_offset_table_rtx)\n-\t\t    switch (flag_pic)\n-\t\t      {\n-\t\t      case 1:\n-\t\t\tfprintf (file, \":w\");\n-\t\t\tbreak;\n-\t\t      case 2:\n-\t\t\tfprintf (file, \":l\");\n-\t\t\tbreak;\n-\t\t      default:\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  if (ireg != 0)\n-\t\t    putc (',', file);\n-\t\t}\n-\t    } /* !MOTOROLA */\n-\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\n-\t    {\n-\t      scale = INTVAL (XEXP (ireg, 1));\n-\t      ireg = XEXP (ireg, 0);\n+\t      if (address.base)\n+\t\tputc (',', file);\n+\t      fprintf (file, \"%s.%c\",\n+\t\t       M68K_REGNAME (REGNO (address.index)),\n+\t\t       GET_MODE (address.index) == HImode ? 'w' : 'l');\n+\t      if (address.scale != 1)\n+\t\tfprintf (file, \"*%d\", address.scale);\n \t    }\n-\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\n-\t    fprintf (file, MOTOROLA ? \"%s.w\" : \"%s:w\",\n-\t\t     M68K_REGNAME (REGNO (XEXP (ireg, 0))));\n-\t  else if (ireg != 0)\n-\t    fprintf (file, MOTOROLA ? \"%s.l\" : \"%s:l\",\n-\t\t     M68K_REGNAME (REGNO (ireg)));\n-\t  if (scale != 1)\n-\t    fprintf (file, MOTOROLA ? \"*%d\" : \":%d\", scale);\n \t  putc (')', file);\n-\t  break;\n-\t}\n-      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF\n-\t       && ! (flag_pic && reg1 == pic_offset_table_rtx))\n-\t{\n-\t  ASM_OUTPUT_CASE_FETCH (file,\n-\t\t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t\t M68K_REGNAME (REGNO (reg1)));\n-\t  fprintf (file, \"l)\");\n-\t  break;\n \t}\n-      /* FALL-THROUGH (is this really what we want?)  */\n-    default:\n-      if (GET_CODE (addr) == CONST_INT\n-\t  && INTVAL (addr) < 0x8000\n-\t  && INTVAL (addr) >= -0x8000)\n-\t{\n-\t  fprintf (file, MOTOROLA ? \"%d.w\" : \"%d:w\", (int) INTVAL (addr));\n-\t}\n-      else if (GET_CODE (addr) == CONST_INT)\n+      else /* !MOTOROLA */\n \t{\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (addr));\n-\t}\n-      else if (TARGET_PCREL)\n-\t{\n-\t  fputc ('(', file);\n-\t  output_addr_const (file, addr);\n-\t  if (flag_pic == 1)\n-\t    asm_fprintf (file, \":w,%Rpc)\");\n+\t  if (!address.offset && !address.index)\n+\t    fprintf (file, \"%s@\", M68K_REGNAME (REGNO (address.base)));\n \t  else\n-\t    asm_fprintf (file, \":l,%Rpc)\");\n-\t}\n-      else\n-\t{\n-\t  /* Special case for SYMBOL_REF if the symbol name ends in\n-\t     `.<letter>', this can be mistaken as a size suffix.  Put\n-\t     the name in parentheses.  */\n-\t  if (GET_CODE (addr) == SYMBOL_REF\n-\t      && strlen (XSTR (addr, 0)) > 2\n-\t      && XSTR (addr, 0)[strlen (XSTR (addr, 0)) - 2] == '.')\n \t    {\n-\t      putc ('(', file);\n-\t      output_addr_const (file, addr);\n+\t      /* Print the \"base@(offset\" component.  */\n+\t      if (labelno >= 0)\n+\t\tasm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b\", labelno, labelno);\n+\t      else\n+\t\t{\n+\t\t  if (address.base)\n+\t\t    fputs (M68K_REGNAME (REGNO (address.base)), file);\n+\t\t  fprintf (file, \"@(\");\n+\t\t  if (address.offset)\n+\t\t    {\n+\t\t      output_addr_const (file, address.offset);\n+\t\t      if (address.base == pic_offset_table_rtx && TARGET_68020)\n+\t\t\tswitch (flag_pic)\n+\t\t\t  {\n+\t\t\t  case 1:\n+\t\t\t    fprintf (file, \":w\"); break;\n+\t\t\t  case 2:\n+\t\t\t    fprintf (file, \":l\"); break;\n+\t\t\t  default:\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t    }\n+\t\t}\n+\t      /* Print the \",index\" component, if any.  */\n+\t      if (address.index)\n+\t\t{\n+\t\t  fprintf (file, \",%s:%c\",\n+\t\t\t   M68K_REGNAME (REGNO (address.index)),\n+\t\t\t   GET_MODE (address.index) == HImode ? 'w' : 'l');\n+\t\t  if (address.scale != 1)\n+\t\t    fprintf (file, \":%d\", address.scale);\n+\t\t}\n \t      putc (')', file);\n \t    }\n-\t  else\n-\t    output_addr_const (file, addr);\n \t}\n-      break;\n     }\n }\n \f"}, {"sha": "04656885a49f9c1e1f1b4e1eee8835ce314e1fcb", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 15, "deletions": 141, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2241eb94b9b29bd2613ea02224a78fdb242a95/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2241eb94b9b29bd2613ea02224a78fdb242a95/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=fc2241eb94b9b29bd2613ea02224a78fdb242a95", "patch": "@@ -535,14 +535,10 @@ extern enum reg_class regno_reg_class[];\n \t  || GET_CODE (OP) == CONST))\t\t\t\\\n    :\t\t\t\t\t\t\t\\\n    (CODE) == 'Q'\t\t\t\t\t\\\n-   ? (GET_CODE (OP) == MEM \t\t\t\t\\\n-      && GET_CODE (XEXP (OP, 0)) == REG)\t\t\\\n+   ? m68k_matches_q_p (OP)\t\t\t\t\\\n    :\t\t\t\t\t\t\t\\\n    (CODE) == 'U'\t\t\t\t\t\\\n-   ? (GET_CODE (OP) == MEM \t\t\t\t\\\n-      && GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n-      && GET_CODE (XEXP (XEXP (OP, 0), 0)) == REG\t\\\n-      && GET_CODE (XEXP (XEXP (OP, 0), 1)) == CONST_INT) \\\n+   ? m68k_matches_u_p (OP)\t\t\t\t\\\n    :\t\t\t\t\t\t\t\\\n    (CODE) == 'W'\t\t\t\t\t\\\n    ? const_call_operand (OP, VOIDmode)\t\t\t\\\n@@ -807,153 +803,31 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n    && !m68k_illegitimate_symbolic_constant_p (X))\n \n #ifndef REG_OK_STRICT\n-#define PCREL_GENERAL_OPERAND_OK 0\n+#define REG_STRICT_P 0\n #else\n-#define PCREL_GENERAL_OPERAND_OK (TARGET_PCREL)\n+#define REG_STRICT_P 1\n #endif\n \n-#define LEGITIMATE_PIC_OPERAND_P(X)\t\\\n-  (! symbolic_operand (X, VOIDmode)\t\t\t\t\\\n-   || PCREL_GENERAL_OPERAND_OK)\n+#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\\\n+  (!symbolic_operand (X, VOIDmode)\t\t\t\t\\\n+   || (TARGET_PCREL && REG_STRICT_P))\n \n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) !FP_REGNO_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) \\\n-  (!DATA_REGNO_P (REGNO (X)) && !FP_REGNO_P (REGNO (X)))\n+  m68k_legitimate_base_reg_p (X, REG_STRICT_P)\n \n-#else\n+#define REG_OK_FOR_INDEX_P(X) \\\n+  m68k_legitimate_index_reg_p (X, REG_STRICT_P)\n \n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   When generating PIC, an address involving a SYMBOL_REF is legitimate\n-   if and only if it is the sum of pic_offset_table_rtx and the SYMBOL_REF.\n-   We use LEGITIMATE_PIC_OPERAND_P to throw out the illegitimate addresses,\n-   and we explicitly check for the sum of pic_offset_table_rtx and a SYMBOL_REF.\n-\n-   Likewise for a LABEL_REF when generating PIC.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n-\n-/* Allow SUBREG everywhere we allow REG.  This results in better code.  It\n-   also makes function inlining work when inline functions are called with\n-   arguments that are SUBREGs.  */\n-\n-#define LEGITIMATE_BASE_REG_P(X)   \\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\\\n-   || (GET_CODE (X) == SUBREG\t\t\t\t\\\n-       && GET_CODE (SUBREG_REG (X)) == REG\t\t\\\n-       && REG_OK_FOR_BASE_P (SUBREG_REG (X))))\n-\n-#define INDIRECTABLE_1_ADDRESS_P(X)  \\\n-  ((CONSTANT_ADDRESS_P (X) && (!flag_pic || LEGITIMATE_PIC_OPERAND_P (X))) \\\n-   || LEGITIMATE_BASE_REG_P (X)\t\t\t\t\t\t\\\n-   || ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\t\\\n-       && LEGITIMATE_BASE_REG_P (XEXP (X, 0)))\t\t\t\t\\\n-   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-       && LEGITIMATE_BASE_REG_P (XEXP (X, 0))\t\t\t\t\\\n-       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-       && (TARGET_68020\t\t\t\t\t\t\t\\\n-\t   || ((unsigned) INTVAL (XEXP (X, 1)) + 0x8000) < 0x10000))\t\\\n-   || (GET_CODE (X) == PLUS && XEXP (X, 0) == pic_offset_table_rtx \t\\\n-       && flag_pic && GET_CODE (XEXP (X, 1)) == SYMBOL_REF)\t\t\\\n-   || (GET_CODE (X) == PLUS && XEXP (X, 0) == pic_offset_table_rtx \t\\\n-       && flag_pic && GET_CODE (XEXP (X, 1)) == LABEL_REF))\n-\n-#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n-{ if (INDIRECTABLE_1_ADDRESS_P (X)) goto ADDR; }\n-\n-/* Only labels on dispatch tables are valid for indexing from.  */\n-#define GO_IF_INDEXABLE_BASE(X, ADDR)\t\t\t\t\\\n-{ rtx temp;\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n-      && (temp = next_nonnote_insn (XEXP (X, 0))) != 0\t\t\\\n-      && GET_CODE (temp) == JUMP_INSN\t\t\t\t\\\n-      && (GET_CODE (PATTERN (temp)) == ADDR_VEC\t\t\t\\\n-\t  || GET_CODE (PATTERN (temp)) == ADDR_DIFF_VEC))\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\\\n-  if (LEGITIMATE_BASE_REG_P (X)) goto ADDR; }\n-\n-#define GO_IF_INDEXING(X, ADDR)\t\\\n-{ if (GET_CODE (X) == PLUS && LEGITIMATE_INDEX_P (XEXP (X, 0)))\t\t\\\n-    { GO_IF_INDEXABLE_BASE (XEXP (X, 1), ADDR); }\t\t\t\\\n-  if (GET_CODE (X) == PLUS && LEGITIMATE_INDEX_P (XEXP (X, 1)))\t\t\\\n-    { GO_IF_INDEXABLE_BASE (XEXP (X, 0), ADDR); } }\n-\n-#define GO_IF_INDEXED_ADDRESS(X, ADDR)\t \\\n-{ GO_IF_INDEXING (X, ADDR);\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    { if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-\t  && (TARGET_68020 || (unsigned) INTVAL (XEXP (X, 1)) + 0x80 < 0x100))\t\t\\\n-\t{ rtx go_temp = XEXP (X, 0); GO_IF_INDEXING (go_temp, ADDR); }\t\\\n-      if (GET_CODE (XEXP (X, 0)) == CONST_INT\t\t\t\t\\\n-\t  && (TARGET_68020 || (unsigned) INTVAL (XEXP (X, 0)) + 0x80 < 0x100))\t\t\\\n-\t{ rtx go_temp = XEXP (X, 1); GO_IF_INDEXING (go_temp, ADDR); } } }\n-\n-/* ColdFire/5200 does not allow HImode index registers.  */\n-#define LEGITIMATE_INDEX_REG_P(X)   \\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\t\\\n-   || (! TARGET_COLDFIRE\t\t\t\t\t\\\n-       && GET_CODE (X) == SIGN_EXTEND\t\t\t\\\n-       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n-       && GET_MODE (XEXP (X, 0)) == HImode\t\t\\\n-       && REG_OK_FOR_INDEX_P (XEXP (X, 0)))\t\t\\\n-   || (GET_CODE (X) == SUBREG\t\t\t\t\\\n-       && GET_CODE (SUBREG_REG (X)) == REG\t\t\\\n-       && REG_OK_FOR_INDEX_P (SUBREG_REG (X))))\n-\n-#define LEGITIMATE_INDEX_P(X)   \\\n-   (LEGITIMATE_INDEX_REG_P (X)\t\t\t\t\\\n-    || ((TARGET_68020 || TARGET_COLDFIRE) && GET_CODE (X) == MULT \\\n-\t&& LEGITIMATE_INDEX_REG_P (XEXP (X, 0))\t\t\\\n-\t&& GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n-\t&& (INTVAL (XEXP (X, 1)) == 2\t\t\t\\\n-\t    || INTVAL (XEXP (X, 1)) == 4\t\t\\\n-\t    || (INTVAL (XEXP (X, 1)) == 8\t\t\\\n-\t\t&& (TARGET_COLDFIRE_FPU || !TARGET_COLDFIRE)))))\n-\n-/* ColdFire FPU only accepts addressing modes 2-5.  */\n-#define GO_IF_COLDFIRE_FPU_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n-{ if (LEGITIMATE_BASE_REG_P (X)\t\t\t\t\t\t\\\n-      || ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\t\\\n-          && LEGITIMATE_BASE_REG_P (XEXP (X, 0)))\t\t\t\\\n-      || ((GET_CODE (X) == PLUS) && LEGITIMATE_BASE_REG_P (XEXP (X, 0))\t\\\n-          && (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n-          && ((((unsigned) INTVAL (XEXP (X, 1)) + 0x8000) < 0x10000))))\t\\\n-  goto ADDR;}\n-\n-/* If pic, we accept INDEX+LABEL, which is what do_tablejump makes.  */\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{ if (TARGET_COLDFIRE_FPU && (GET_MODE_CLASS (MODE) == MODE_FLOAT))\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      GO_IF_COLDFIRE_FPU_LEGITIMATE_ADDRESS (MODE, X, ADDR);\t\t\\\n+      if (m68k_legitimate_address_p (MODE, X, REG_STRICT_P))\t\t\\\n+        goto ADDR;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\t\\\n-      GO_IF_INDEXED_ADDRESS (X, ADDR);\t\t\t\t\t\\\n-      if (flag_pic && MODE == CASE_VECTOR_MODE && GET_CODE (X) == PLUS\t\\\n-\t  && LEGITIMATE_INDEX_P (XEXP (X, 0))\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 1)) == LABEL_REF)\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-    }}\n+  while (0)\n \n /* Don't call memory_address_noforce for the address to fetch\n-   the switch offset.  This address is ok as it stands (see above),\n+   the switch offset.  This address is ok as it stands,\n    but memory_address_noforce would alter it.  */\n #define PIC_CASE_VECTOR_ADDRESS(index) index\n \f"}]}