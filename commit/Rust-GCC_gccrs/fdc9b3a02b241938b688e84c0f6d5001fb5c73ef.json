{"sha": "fdc9b3a02b241938b688e84c0f6d5001fb5c73ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRjOWIzYTAyYjI0MTkzOGI2ODhlODRjMGY2ZDUwMDFmYjVjNzNlZg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2005-02-22T03:45:18Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2005-02-22T03:45:18Z"}, "message": "Check in missed file from last commit.\n\nFrom-SVN: r95381", "tree": {"sha": "0e26a4fc3de64de1f241eaa41901954d23bc97a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e26a4fc3de64de1f241eaa41901954d23bc97a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdc9b3a02b241938b688e84c0f6d5001fb5c73ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdc9b3a02b241938b688e84c0f6d5001fb5c73ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdc9b3a02b241938b688e84c0f6d5001fb5c73ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdc9b3a02b241938b688e84c0f6d5001fb5c73ef/comments", "author": null, "committer": null, "parents": [{"sha": "ec88bf8bb7285cad65bda54ce3bd83b70e928fd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec88bf8bb7285cad65bda54ce3bd83b70e928fd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec88bf8bb7285cad65bda54ce3bd83b70e928fd6"}], "stats": {"total": 102, "additions": 51, "deletions": 51}, "files": [{"sha": "a5f6ea0be5e510358cb40495dab8757f63b33ce5", "filename": "libjava/java/io/ObjectStreamClass.java", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc9b3a02b241938b688e84c0f6d5001fb5c73ef/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc9b3a02b241938b688e84c0f6d5001fb5c73ef/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamClass.java?ref=fdc9b3a02b241938b688e84c0f6d5001fb5c73ef", "patch": "@@ -452,27 +452,33 @@ void calculateOffsets()\n   }\n \n   private Method findMethod(Method[] methods, String name, Class[] params,\n-\t\t\t    Class returnType)\n+\t\t\t    Class returnType, boolean mustBePrivate)\n   {\n outer:\n-    for(int i = 0; i < methods.length; i++)\n+    for (int i = 0; i < methods.length; i++)\n     {\n-\tif(methods[i].getName().equals(name) &&\n-\t   methods[i].getReturnType() == returnType)\n+\tfinal Method m = methods[i];\n+        int mods = m.getModifiers();\n+        if (Modifier.isStatic(mods)\n+            || (mustBePrivate && !Modifier.isPrivate(mods)))\n+        {\n+            continue;\n+        }\n+\n+\tif (m.getName().equals(name)\n+\t   && m.getReturnType() == returnType)\n \t{\n-\t    Class[] mp = methods[i].getParameterTypes();\n-\t    if(mp.length == params.length)\n+\t    Class[] mp = m.getParameterTypes();\n+\t    if (mp.length == params.length)\n \t    {\n-\t\tfor(int j = 0; j < mp.length; j++)\n+\t\tfor (int j = 0; j < mp.length; j++)\n \t\t{\n-\t\t    if(mp[j] != params[j])\n+\t\t    if (mp[j] != params[j])\n \t\t    {\n \t\t\tcontinue outer;\n \t\t    }\n \t\t}\n-\t\tfinal Method m = methods[i];\n-\t\tSetAccessibleAction setAccessible = new SetAccessibleAction(m);\n-\t\tAccessController.doPrivileged(setAccessible);\n+\t\tAccessController.doPrivileged(new SetAccessibleAction(m));\n \t\treturn m;\n \t    }\n \t}\n@@ -485,9 +491,14 @@ private void cacheMethods()\n     Method[] methods = forClass().getDeclaredMethods();\n     readObjectMethod = findMethod(methods, \"readObject\",\n \t\t\t\t  new Class[] { ObjectInputStream.class },\n-\t\t\t\t  Void.TYPE);\n+\t\t\t\t  Void.TYPE, true);\n+    writeObjectMethod = findMethod(methods, \"writeObject\",\n+                                   new Class[] { ObjectOutputStream.class },\n+                                   Void.TYPE, true);\n     readResolveMethod = findMethod(methods, \"readResolve\",\n-\t\t\t\t   new Class[0], Object.class);\n+\t\t\t\t   new Class[0], Object.class, false);\n+    writeReplaceMethod = findMethod(methods, \"writeReplace\",\n+                                    new Class[0], Object.class, false);\n   }\n \n   private ObjectStreamClass(Class cl)\n@@ -517,20 +528,8 @@ else if ((java.io.Serializable.class).isAssignableFrom(cl))\n       // only set this bit if CL is NOT Externalizable\n       flags |= ObjectStreamConstants.SC_SERIALIZABLE;\n \n-    try\n-      {\n-\tMethod writeMethod = cl.getDeclaredMethod(\"writeObject\",\n-\t\t\t\t\t\t  writeMethodArgTypes);\n-\tint modifiers = writeMethod.getModifiers();\n-\n-\tif (writeMethod.getReturnType() == Void.TYPE\n-\t    && Modifier.isPrivate(modifiers)\n-\t    && !Modifier.isStatic(modifiers))\n-\t  flags |= ObjectStreamConstants.SC_WRITE_METHOD;\n-      }\n-    catch(NoSuchMethodException oh_well)\n-      {\n-      }\n+    if (writeObjectMethod != null)\n+      flags |= ObjectStreamConstants.SC_WRITE_METHOD;\n   }\n \n \n@@ -851,11 +850,11 @@ public Object run()\n     {\n \treturn (Externalizable)constructor.newInstance(null);\n     }\n-    catch(Throwable t)\n+    catch(Exception x)\n     {\n \tthrow (InvalidClassException)\n \t    new InvalidClassException(clazz.getName(),\n-\t\t     \"Unable to instantiate\").initCause(t);\n+\t\t     \"Unable to instantiate\").initCause(x);\n     }\n   }\n \n@@ -884,10 +883,12 @@ public Object run()\n \n   Method readObjectMethod;\n   Method readResolveMethod;\n+  Method writeReplaceMethod;\n+  Method writeObjectMethod;\n   boolean realClassIsSerializable;\n   boolean realClassIsExternalizable;\n   ObjectStreamField[] fieldMapping;\n-  Class firstNonSerializableParent;\n+  Constructor firstNonSerializableParentConstructor;\n   private Constructor constructor;  // default constructor for Externalizable\n \n   boolean isProxyClass = false;\n@@ -896,34 +897,33 @@ public Object run()\n   // but it will avoid showing up as a discrepancy when comparing SUIDs.\n   private static final long serialVersionUID = -6120832682080437368L;\n \n-}\n-\n \n-// interfaces are compared only by name\n-class InterfaceComparator implements Comparator\n-{\n-  public int compare(Object o1, Object o2)\n+  // interfaces are compared only by name\n+  private static final class InterfaceComparator implements Comparator\n   {\n-    return ((Class) o1).getName().compareTo(((Class) o2).getName());\n+    public int compare(Object o1, Object o2)\n+    {\n+      return ((Class) o1).getName().compareTo(((Class) o2).getName());\n+    }\n   }\n-}\n \n \n-// Members (Methods and Constructors) are compared first by name,\n-// conflicts are resolved by comparing type signatures\n-class MemberComparator implements Comparator\n-{\n-  public int compare(Object o1, Object o2)\n+  // Members (Methods and Constructors) are compared first by name,\n+  // conflicts are resolved by comparing type signatures\n+  private static final class MemberComparator implements Comparator\n   {\n-    Member m1 = (Member) o1;\n-    Member m2 = (Member) o2;\n+    public int compare(Object o1, Object o2)\n+    {\n+      Member m1 = (Member) o1;\n+      Member m2 = (Member) o2;\n \n-    int comp = m1.getName().compareTo(m2.getName());\n+      int comp = m1.getName().compareTo(m2.getName());\n \n-    if (comp == 0)\n-      return TypeSignature.getEncodingOfMember(m1).\n-\tcompareTo(TypeSignature.getEncodingOfMember(m2));\n-    else\n-      return comp;\n+      if (comp == 0)\n+        return TypeSignature.getEncodingOfMember(m1).\n+\t  compareTo(TypeSignature.getEncodingOfMember(m2));\n+      else\n+        return comp;\n+    }\n   }\n }"}]}