{"sha": "2bf6230de9fe946ecc286c4d2543266a412d02b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJmNjIzMGRlOWZlOTQ2ZWNjMjg2YzRkMjU0MzI2NmE0MTJkMDJiNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-17T00:32:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-17T00:32:17Z"}, "message": "(CPP_SPEC): Added -mieee and -mieee-with-inexact.\n\n(alpha_trap_precision, alpha_fp_rounding_mode, alpha_fp_trap_mode):\nNew enum types.\n(target_flags, alpha_tp, alpha_fprm, alpha_fptm): New external vars.\n(alpha_fprm_string, alpha_fptm_string, alpha_tp_string): Likewise.\n(TARGET_IEEE{,_WITH_INEXACT,_CONFORMANT}): New macros.\n(MASK_IEEE{,_WITH_INEXACT,_CONFORMANT}): Likewise.\n(MASK_FP, MASK_FPREGS,\n(TARGET_SWITCHES): Added \"ieee-conformant\", \"ieee\", and\n\"ieee-with-inexact\"; use MASK symbols.\n(TARGET_OPTIONS): New macro.\n(OVERRIDE_OPTIONS, FINAL_PRESCAN_{INSN,LABEL}): New macros.\n(PRINT_OPERAND_PUNCT_VALID_P): Allow operand codes for FP insns.\n(CC1_SPEC): New macro.\n\nFrom-SVN: r11549", "tree": {"sha": "77e0ffd3c194e93f1653c616ecd7545281d56839", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77e0ffd3c194e93f1653c616ecd7545281d56839"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bf6230de9fe946ecc286c4d2543266a412d02b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf6230de9fe946ecc286c4d2543266a412d02b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf6230de9fe946ecc286c4d2543266a412d02b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf6230de9fe946ecc286c4d2543266a412d02b5/comments", "author": null, "committer": null, "parents": [{"sha": "03ffa1710321b66ea6901d5aae9dd33728bd4124", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03ffa1710321b66ea6901d5aae9dd33728bd4124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03ffa1710321b66ea6901d5aae9dd33728bd4124"}], "stats": {"total": 139, "additions": 126, "deletions": 13}, "files": [{"sha": "3fd2fb7de37cdb21508599d73bda3a2313a546c5", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 126, "deletions": 13, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf6230de9fe946ecc286c4d2543266a412d02b5/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf6230de9fe946ecc286c4d2543266a412d02b5/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=2bf6230de9fe946ecc286c4d2543266a412d02b5", "patch": "@@ -34,7 +34,9 @@ Boston, MA 02111-1307, USA.  */\n %{.cc:\t-D__LANGUAGE_C_PLUS_PLUS__ -D__LANGUAGE_C_PLUS_PLUS -D__cplusplus} \\\n %{.cxx:\t-D__LANGUAGE_C_PLUS_PLUS__ -D__LANGUAGE_C_PLUS_PLUS -D__cplusplus} \\\n %{.C:\t-D__LANGUAGE_C_PLUS_PLUS__ -D__LANGUAGE_C_PLUS_PLUS -D__cplusplus} \\\n-%{.m:\t-D__LANGUAGE_OBJECTIVE_C__ -D__LANGUAGE_OBJECTIVE_C}\"\n+%{.m:\t-D__LANGUAGE_OBJECTIVE_C__ -D__LANGUAGE_OBJECTIVE_C} \\\n+%{mieee:-D_IEEE_FP} \\\n+%{mieee-with-inexact:-D_IEEE_FP -D_IEEE_FP_INEXACT}\"\n \n /* Set the spec to use for signed char.  The default tests the above macro\n    but DEC's compiler can't handle the conditional in a \"constant\"\n@@ -78,37 +80,84 @@ Boston, MA 02111-1307, USA.  */\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n+enum alpha_trap_precision\n+{\n+  ALPHA_TP_PROG,\t/* No precision (default).  */\n+  ALPHA_TP_FUNC,      \t/* Trap contained within originating function.  */\n+  ALPHA_TP_INSN\t\t/* Instruction accuracy and code is resumption safe. */\n+};\n+\n+enum alpha_fp_rounding_mode\n+{\n+  ALPHA_FPRM_NORM,\t/* Normal rounding mode.  */\n+  ALPHA_FPRM_MINF,\t/* Round towards minus-infinity.  */\n+  ALPHA_FPRM_CHOP,\t/* Chopped rounding mode (towards 0). */\n+  ALPHA_FPRM_DYN\t/* Dynamic rounding mode.  */\n+};\n+\n+enum alpha_fp_trap_mode\n+{\n+  ALPHA_FPTM_N,\t\t/* Normal trap mode. */\n+  ALPHA_FPTM_U,\t\t/* Underflow traps enabled.  */\n+  ALPHA_FPTM_SU,\t/* Software completion, w/underflow traps */\n+  ALPHA_FPTM_SUI\t/* Software completion, w/underflow & inexact traps */\n+};\n+\n extern int target_flags;\n \n+extern enum alpha_trap_precision alpha_tp;\n+extern enum alpha_fp_rounding_mode alpha_fprm;\n+extern enum alpha_fp_trap_mode alpha_fptm;\n+\n /* This means that floating-point support exists in the target implementation\n    of the Alpha architecture.  This is usually the default.  */\n \n-#define TARGET_FP\t(target_flags & 1)\n+#define MASK_FP\t\t1\n+#define TARGET_FP\t(target_flags & MASK_FP)\n \n /* This means that floating-point registers are allowed to be used.  Note\n    that Alpha implementations without FP operations are required to\n    provide the FP registers.  */\n \n-#define TARGET_FPREGS\t(target_flags & 2)\n+#define MASK_FPREGS\t2\n+#define TARGET_FPREGS\t(target_flags & MASK_FPREGS)\n \n /* This means that gas is used to process the assembler file.  */\n \n #define MASK_GAS 4\n #define TARGET_GAS\t(target_flags & MASK_GAS)\n \n+/* This means that we should mark procedures as IEEE conformant. */\n+\n+#define MASK_IEEE_CONFORMANT 8\n+#define TARGET_IEEE_CONFORMANT\t(target_flags & MASK_IEEE_CONFORMANT)\n+\n+/* This means we should be IEEE-compliant except for inexact.  */\n+\n+#define MASK_IEEE\t16\n+#define TARGET_IEEE\t(target_flags & MASK_IEEE)\n+\n+/* This means we should be fully IEEE-compliant.  */\n+\n+#define MASK_IEEE_WITH_INEXACT 32\n+#define TARGET_IEEE_WITH_INEXACT (target_flags & MASK_IEEE_WITH_INEXACT)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n    where VALUE is the bits to set or minus the bits to clear.\n    An empty string NAME is used to identify the default VALUE.  */\n \n-#define TARGET_SWITCHES\t\t\t\\\n-  { {\"no-soft-float\", 1},\t\t\\\n-    {\"soft-float\", -1},\t\t\t\\\n-    {\"fp-regs\", 2},\t\t\t\\\n-    {\"no-fp-regs\", -3},\t\t\t\\\n-    {\"alpha-as\", -MASK_GAS},\t\t\\\n-    {\"gas\", MASK_GAS},\t\t\t\\\n+#define TARGET_SWITCHES\t\t\t\t\\\n+  { {\"no-soft-float\", MASK_FP},\t\t\t\\\n+    {\"soft-float\", - MASK_FP},\t\t\t\\\n+    {\"fp-regs\", MASK_FPREGS},\t\t\t\\\n+    {\"no-fp-regs\", - (MASK_FP|MASK_FPREGS)},\t\\\n+    {\"alpha-as\", -MASK_GAS},\t\t\t\\\n+    {\"gas\", MASK_GAS},\t\t\t\t\\\n+    {\"ieee-conformant\", MASK_IEEE_CONFORMANT},\t\\\n+    {\"ieee\", MASK_IEEE},\t\t\t\\\n+    {\"ieee-with-inexact\", MASK_IEEE_WITH_INEXACT}, \\\n     {\"\", TARGET_DEFAULT | TARGET_CPU_DEFAULT} }\n \n #define TARGET_DEFAULT 3\n@@ -117,6 +166,47 @@ extern int target_flags;\n #define TARGET_CPU_DEFAULT 0\n #endif\n \n+/* This macro is similar to `TARGET_SWITCHES' but defines names of\n+   command options that have values.  Its definition is an initializer\n+   with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the fixed\n+   part of the option name, and the address of a variable.  The\n+   variable, type `char *', is set to the variable part of the given\n+   option if the fixed part matches.  The actual option name is made\n+   by appending `-m' to the specified name.\n+\n+   Here is an example which defines `-mshort-data-NUMBER'.  If the\n+   given option is `-mshort-data-512', the variable `m88k_short_data'\n+   will be set to the string `\"512\"'.\n+\n+\textern char *m88k_short_data;\n+\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n+\n+extern char *alpha_fprm_string;\t/* For -mfp-rounding-mode=[n|m|c|d] */\n+extern char *alpha_fptm_string;\t/* For -mfp-trap-mode=[n|u|su|sui]  */\n+extern char *alpha_tp_string;\t/* For -mtrap-precision=[p|f|i] */\n+\n+#define TARGET_OPTIONS\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  {\"fp-rounding-mode=\",\t&alpha_fprm_string},\t\\\n+  {\"fp-trap-mode=\",\t&alpha_fptm_string},\t\\\n+  {\"trap-precision=\",\t&alpha_tp_string},\t\\\n+}\n+\n+/* Sometimes certain combinations of command options do not make sense\n+   on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+\n+   On the Alpha, it is used to translate target-option strings into\n+   numeric values.  */\n+\n+extern void override_options ();\n+#define OVERRIDE_OPTIONS override_options ()\n+\n+\n /* Define this macro to change register usage conditional on target flags.\n \n    On the Alpha, we use this to disable the floating-point registers when\n@@ -1294,7 +1384,12 @@ __enable_execute_stack (addr)\t\t\t\t\t\t\\\n /* Define this if some processing needs to be done immediately before\n    emitting code for an insn.  */\n \n-/* #define FINAL_PRESCAN_INSN(INSN,OPERANDS,NOPERANDS) */\n+extern void final_prescan_insn ();\n+#define FINAL_PRESCAN_INSN(INSN,OPERANDS,NOPERANDS) \\\n+  final_prescan_insn ((INSN), (OPERANDS), (NOPERANDS))\n+\n+/* Define this if FINAL_PRESCAN_INSN should be called for a CODE_LABEL.  */\n+#define FINAL_PRESCAN_LABEL\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n@@ -1826,9 +1921,27 @@ literal_section ()\t\t\t\t\t\t\\\n #define PRINT_OPERAND(FILE, X, CODE)  print_operand (FILE, X, CODE)\n \n /* Determine which codes are valid without a following integer.  These must\n-   not be alphabetic.  */\n+   not be alphabetic (the characters are chosen so that\n+   PRINT_OPERAND_PUNCT_VALID_P translates into a simple range change when\n+   using ASCII).\n+\n+   &\tGenerates fp-rounding mode suffix: nothing for normal, 'c' for\n+   \tchopped, 'm' for minus-infinity, and 'd' for dynamic rounding\n+\tmode.  alpha_fprm controls which suffix is generated.\n+\n+   '\tGenerates trap-mode suffix for instructions that accept the\n+        su suffix only (cmpt et al).\n+\n+   )    Generates trap-mode suffix for instructions that accept the\n+\tu, su, and sui suffix.  This is the bulk of the IEEE floating\n+\tpoint instructions (addt et al).\n+\n+   +    Generates trap-mode suffix for instructions that accept the\n+\tsui suffix (cvtqt and cvtqs).\n+   */\n \n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE) 0\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n+  ((CODE) == '&' || (CODE) == '\\'' || (CODE) == ')' || (CODE) == '+')\n \f\n /* Print a memory address as an operand to reference that memory location.  */\n "}]}