{"sha": "99400eed8df62083577063d7e0eea248013f6277", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk0MDBlZWQ4ZGY2MjA4MzU3NzA2M2Q3ZTBlZWEyNDgwMTNmNjI3Nw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2015-09-30T14:58:49Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2015-09-30T14:58:49Z"}, "message": "spu-protos.h (spu_expand_atomic_op): Add prototype.\n\ngcc/\n\t* config/spu/spu-protos.h (spu_expand_atomic_op): Add prototype.\n\t* config/spu/spu.c (spu_expand_atomic_op): New function.\n\t* config/spu/spu.md (AINT): New mode iterator.\n\t(ATOMIC): New code iterator.\n\t(atomic_name, atomic_pred): New code predicates.\n\t(\"atomic_load<mode>\", \"atomic_store<mode>\"): New expanders.\n\t(\"atomic_compare_and_swap<mode>\", \"atomic_exchange<mode>\"): Likewise.\n\t(\"\"atomic_<atomic_name><mode>\", \"atomic_fetch_<atomic_name><mode>\",\n\t\"atomic_<atomic_name>_fetch<mode>\"): Likewise.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_sync_int_128):\n\tReturn 1 on spu-*-* targets.\n\t(check_effective_target_sync_int_128_runtime): Likewise.\n\t(check_effective_target_sync_long_long): Likewise.\n\t(check_effective_target_sync_long_long_runtime): Likewise.\n\t(check_effective_target_sync_int_long): Likewise.\n\t(check_effective_target_sync_char_short): Likewise.\n\nFrom-SVN: r228297", "tree": {"sha": "6a1cff82e7f979c35b646844cc28625a5f340e27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a1cff82e7f979c35b646844cc28625a5f340e27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99400eed8df62083577063d7e0eea248013f6277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99400eed8df62083577063d7e0eea248013f6277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99400eed8df62083577063d7e0eea248013f6277", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99400eed8df62083577063d7e0eea248013f6277/comments", "author": null, "committer": null, "parents": [{"sha": "21b820644d11c7a320421c532ed96cf3454ee16e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b820644d11c7a320421c532ed96cf3454ee16e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21b820644d11c7a320421c532ed96cf3454ee16e"}], "stats": {"total": 217, "additions": 216, "deletions": 1}, "files": [{"sha": "86f81d6e46e3e6e2a2929f58e9b4bc4905b74747", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99400eed8df62083577063d7e0eea248013f6277/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99400eed8df62083577063d7e0eea248013f6277/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99400eed8df62083577063d7e0eea248013f6277", "patch": "@@ -1,3 +1,15 @@\n+2015-09-30  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/spu/spu-protos.h (spu_expand_atomic_op): Add prototype.\n+\t* config/spu/spu.c (spu_expand_atomic_op): New function.\n+\t* config/spu/spu.md (AINT): New mode iterator.\n+\t(ATOMIC): New code iterator.\n+\t(atomic_name, atomic_pred): New code predicates.\n+\t(\"atomic_load<mode>\", \"atomic_store<mode>\"): New expanders.\n+\t(\"atomic_compare_and_swap<mode>\", \"atomic_exchange<mode>\"): Likewise.\n+\t(\"\"atomic_<atomic_name><mode>\", \"atomic_fetch_<atomic_name><mode>\",\n+\t\"atomic_<atomic_name>_fetch<mode>\"): Likewise.\n+\n 2015-09-30  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* config/i386/i386.c (scalar_chain::analyze_register_chain): Ignore"}, {"sha": "0b6ea4b53ea4c27a5e7a5c07020a4fca947c5a3a", "filename": "gcc/config/spu/spu-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99400eed8df62083577063d7e0eea248013f6277/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99400eed8df62083577063d7e0eea248013f6277/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=99400eed8df62083577063d7e0eea248013f6277", "patch": "@@ -76,6 +76,8 @@ extern void spu_builtin_promote (rtx ops[]);\n extern void spu_expand_sign_extend (rtx ops[]);\n extern void spu_expand_vector_init (rtx target, rtx vals);\n extern rtx spu_legitimize_reload_address (rtx, machine_mode, int, int);\n+extern void spu_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n+\t\t\t\t  rtx orig_before, rtx orig_after);\n #endif /* RTX_CODE  */\n \n extern void spu_init_expanders (void);"}, {"sha": "bdedecc7ad90f1cd412001245c795232aa0bd418", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99400eed8df62083577063d7e0eea248013f6277/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99400eed8df62083577063d7e0eea248013f6277/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=99400eed8df62083577063d7e0eea248013f6277", "patch": "@@ -7121,6 +7121,41 @@ spu_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n       *code = (int)swap_condition ((enum rtx_code)*code);\n     }\n }\n+\n+/* Expand an atomic fetch-and-operate pattern.  CODE is the binary operation\n+   to perform.  MEM is the memory on which to operate.  VAL is the second\n+   operand of the binary operator.  BEFORE and AFTER are optional locations to\n+   return the value of MEM either before of after the operation.  */\n+void\n+spu_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n+\t\t      rtx orig_before, rtx orig_after)\n+{\n+  machine_mode mode = GET_MODE (mem);\n+  rtx before = orig_before, after = orig_after;\n+\n+  if (before == NULL_RTX)\n+    before = gen_reg_rtx (mode);\n+\n+  emit_move_insn (before, mem);\n+\n+  if (code == MULT)  /* NAND operation */\n+    {\n+      rtx x = expand_simple_binop (mode, AND, before, val,\n+\t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      after = expand_simple_unop (mode, NOT, x, after, 1);\n+    }\n+  else\n+    {\n+      after = expand_simple_binop (mode, code, before, val,\n+\t\t\t\t   after, 1, OPTAB_LIB_WIDEN);\n+    }\n+\n+  emit_move_insn (mem, after);\n+\n+  if (orig_after && after != orig_after)\n+    emit_move_insn (orig_after, after);\n+}\n+\n \f\n /*  Table of machine attributes.  */\n static const struct attribute_spec spu_attribute_table[] ="}, {"sha": "14167063636fa7f3749c7ed4e044b25b61b2e1c5", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99400eed8df62083577063d7e0eea248013f6277/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99400eed8df62083577063d7e0eea248013f6277/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=99400eed8df62083577063d7e0eea248013f6277", "patch": "@@ -5097,3 +5097,150 @@ DONE;\n    (set_attr \"type\" \"multi1\")]\n )\n \n+; Atomic operations\n+;\n+; SPU execution is always single-threaded, so there is no need for real\n+; atomic operations.  We provide the atomic primitives anyway so that\n+; code expecting the builtins to be present (like libgfortran) will work.\n+\n+;; Types that we should provide atomic instructions for.\n+(define_mode_iterator AINT [QI HI SI DI TI])\n+\n+(define_code_iterator ATOMIC [plus minus ior xor and mult])\n+(define_code_attr atomic_name\n+  [(plus \"add\") (minus \"sub\")\n+   (ior \"or\") (xor \"xor\") (and \"and\") (mult \"nand\")])\n+(define_code_attr atomic_pred\n+  [(plus \"spu_arith_operand\") (minus \"spu_reg_operand\")\n+   (ior \"spu_logical_operand\") (xor \"spu_logical_operand\")\n+   (and \"spu_logical_operand\") (mult \"spu_logical_operand\")])\n+\n+(define_expand \"atomic_load<mode>\"\n+  [(set (match_operand:AINT 0 \"spu_reg_operand\" \"\")\t\t;; output\n+\t(match_operand:AINT 1 \"memory_operand\" \"\"))\t\t;; memory\n+   (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\t\t;; model\n+  \"\"\n+{\n+  if (MEM_ADDR_SPACE (operands[1]))\n+    FAIL;\n+\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_store<mode>\"\n+  [(set (match_operand:AINT 0 \"memory_operand\" \"\")\t\t;; memory\n+\t(match_operand:AINT 1 \"spu_reg_operand\" \"\"))\t\t;; input\n+   (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\t\t;; model\n+  \"\"\n+{\n+  if (MEM_ADDR_SPACE (operands[0]))\n+    FAIL;\n+\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:SI 0 \"spu_reg_operand\" \"\")\t\t;; bool out\n+   (match_operand:AINT 1 \"spu_reg_operand\" \"\")\t\t;; val out\n+   (match_operand:AINT 2 \"memory_operand\" \"\")\t\t;; memory\n+   (match_operand:AINT 3 \"spu_nonmem_operand\" \"\")\t;; expected\n+   (match_operand:AINT 4 \"spu_nonmem_operand\" \"\")\t;; desired\n+   (match_operand:SI 5 \"const_int_operand\" \"\")\t\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; model succ\n+   (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t;; model fail\n+  \"\"\n+{\n+  rtx boolval, retval, label;\n+\n+  if (MEM_ADDR_SPACE (operands[2]))\n+    FAIL;\n+\n+  boolval = gen_reg_rtx (SImode);\n+  retval = gen_reg_rtx (<MODE>mode);\n+  label = gen_label_rtx ();\n+\n+  emit_move_insn (retval, operands[2]);\n+  emit_move_insn (boolval, const0_rtx);\n+\n+  emit_cmp_and_jump_insns (retval, operands[3], NE, NULL_RTX,\n+                           <MODE>mode, 1, label);\n+\n+  emit_move_insn (operands[2], operands[4]);\n+  emit_move_insn (boolval, const1_rtx);\n+\n+  emit_label (label);\n+\n+  emit_move_insn (operands[0], boolval);\n+  emit_move_insn (operands[1], retval);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_exchange<mode>\"\n+  [(match_operand:AINT 0 \"spu_reg_operand\" \"\")\t\t;; output\n+   (match_operand:AINT 1 \"memory_operand\" \"\")\t\t;; memory\n+   (match_operand:AINT 2 \"spu_nonmem_operand\" \"\")\t;; input\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n+  \"\"\n+{\n+  rtx retval;\n+\n+  if (MEM_ADDR_SPACE (operands[1]))\n+    FAIL;\n+\n+  retval = gen_reg_rtx (<MODE>mode);\n+\n+  emit_move_insn (retval, operands[1]);\n+  emit_move_insn (operands[1], operands[2]);\n+  emit_move_insn (operands[0], retval);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_<atomic_name><mode>\"\n+  [(ATOMIC:AINT\n+     (match_operand:AINT 0 \"memory_operand\" \"\")\t\t;; memory\n+     (match_operand:AINT 1 \"<atomic_pred>\" \"\"))\t\t;; operand\n+   (match_operand:SI 2 \"const_int_operand\" \"\")]\t\t;; model\n+  \"\"\n+{\n+  if (MEM_ADDR_SPACE (operands[0]))\n+    FAIL;\n+\n+  spu_expand_atomic_op (<CODE>, operands[0], operands[1],\n+\t\t\tNULL_RTX, NULL_RTX);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_<atomic_name><mode>\"\n+  [(match_operand:AINT 0 \"spu_reg_operand\" \"\")\t\t;; output\n+   (ATOMIC:AINT\n+     (match_operand:AINT 1 \"memory_operand\" \"\")\t\t;; memory\n+     (match_operand:AINT 2 \"<atomic_pred>\" \"\"))\t\t;; operand\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n+  \"\"\n+{ \n+  if (MEM_ADDR_SPACE (operands[1]))\n+    FAIL;\n+\n+  spu_expand_atomic_op (<CODE>, operands[1], operands[2],\n+\t\t\toperands[0], NULL_RTX);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_<atomic_name>_fetch<mode>\"\n+  [(match_operand:AINT 0 \"spu_reg_operand\" \"\")\t\t;; output\n+   (ATOMIC:AINT\n+     (match_operand:AINT 1 \"memory_operand\" \"\")\t\t;; memory\n+     (match_operand:AINT 2 \"<atomic_pred>\" \"\"))\t\t;; operand\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; model\n+  \"\"\n+{\n+  if (MEM_ADDR_SPACE (operands[1]))\n+    FAIL;\n+\n+  spu_expand_atomic_op (<CODE>, operands[1], operands[2],\n+\t\t\tNULL_RTX, operands[0]);\n+  DONE;\n+})\n+"}, {"sha": "9cddbefdb8160607cc820822f79b71d0a32e7c23", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99400eed8df62083577063d7e0eea248013f6277/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99400eed8df62083577063d7e0eea248013f6277/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=99400eed8df62083577063d7e0eea248013f6277", "patch": "@@ -1,3 +1,13 @@\n+2015-09-30  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_sync_int_128):\n+\tReturn 1 on spu-*-* targets.\n+\t(check_effective_target_sync_int_128_runtime): Likewise.\n+\t(check_effective_target_sync_long_long): Likewise.\n+\t(check_effective_target_sync_long_long_runtime): Likewise.\n+\t(check_effective_target_sync_int_long): Likewise.\n+\t(check_effective_target_sync_char_short): Likewise.\n+\n 2015-09-30  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* gcc.target/i386/pr67761.c: New test."}, {"sha": "9057a27c6b4390c62e2699d00e46d5fb5d7f8bbc", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99400eed8df62083577063d7e0eea248013f6277/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99400eed8df62083577063d7e0eea248013f6277/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=99400eed8df62083577063d7e0eea248013f6277", "patch": "@@ -5092,6 +5092,8 @@ proc check_effective_target_sync_int_128 { } {\n     if { ([istarget x86_64-*-*] || [istarget i?86-*-*])\n \t && ![is-effective-target ia32] } {\n \treturn 1\n+    } elseif { [istarget spu-*-*] } {\n+\treturn 1\n     } else {\n \treturn 0\n     }\n@@ -5115,6 +5117,8 @@ proc check_effective_target_sync_int_128_runtime { } {\n \t\t}\n \t    } \"\"\n \t}]\n+    } elseif { [istarget spu-*-*] } {\n+\treturn 1\n     } else {\n \treturn 0\n     }\n@@ -5129,7 +5133,8 @@ proc check_effective_target_sync_long_long { } {\n \t || [istarget aarch64*-*-*]\n \t || [istarget arm*-*-*]\n \t || [istarget alpha*-*-*]\n-\t || ([istarget sparc*-*-*] && [check_effective_target_lp64]) } {\n+\t || ([istarget sparc*-*-*] && [check_effective_target_lp64])\n+\t || [istarget spu-*-*] } {\n \treturn 1\n     } else {\n \treturn 0\n@@ -5179,6 +5184,8 @@ proc check_effective_target_sync_long_long_runtime { } {\n \t\t && [check_effective_target_lp64]\n \t\t && [check_effective_target_ultrasparc_hw]) } {\n \treturn 1\n+    } elseif { [istarget spu-*-*] } {\n+\treturn 1\n     } elseif { [istarget powerpc*-*-*] && [check_effective_target_lp64] } {\n \treturn 1\n     } else {\n@@ -5292,6 +5299,7 @@ proc check_effective_target_sync_int_long { } {\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget crisv32-*-*] || [istarget cris-*-*]\n \t     || ([istarget sparc*-*-*] && [check_effective_target_sparc_v9])\n+\t     || [istarget spu-*-*]\n \t     || [check_effective_target_mips_llsc] } {\n            set et_sync_int_long_saved 1\n         }\n@@ -5322,6 +5330,7 @@ proc check_effective_target_sync_char_short { } {\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget crisv32-*-*] || [istarget cris-*-*]\n \t     || ([istarget sparc*-*-*] && [check_effective_target_sparc_v9])\n+\t     || [istarget spu-*-*]\n \t     || [check_effective_target_mips_llsc] } {\n            set et_sync_char_short_saved 1\n         }"}]}