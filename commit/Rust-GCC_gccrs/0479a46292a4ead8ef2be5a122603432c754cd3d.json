{"sha": "0479a46292a4ead8ef2be5a122603432c754cd3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ3OWE0NjI5MmE0ZWFkOGVmMmJlNWExMjI2MDM0MzJjNzU0Y2QzZA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@cygnus.com", "date": "2000-09-01T08:58:07Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-09-01T08:58:07Z"}, "message": "locale_facets.tcc (_S_build_float_format): Move ...\n\n\n\n2000-08-31  Benjamin Kosnik  <bkoz@cygnus.com>\n\n\t* bits/locale_facets.tcc (_S_build_float_format): Move ...\n\t* src/locale.cc: Here.\n\t* bits/locale_facets.tcc (num_get::_M_extract): Clean up generic\n\tdefinition. Move specialization to ...\n\t* src/locale.cc: Here.\n\t* bits/locale_facets.tcc: Move _Format_cache specializations to ...\n\t* src/locale.cc: Here.\n\t* bits/locale_facets.tcc: Move use_facet<ctype> specializations to ...\n\t* src/locale.cc: Here.\n\n\t* bits/std_locale.h: Note that locale_facets.tcc should be\n\tincluded here, for standards conformance. It may increase\n\tcompile times though. For the time being, enable.\n\t* testsuite/22_locale/facet.cc: New file, some parts commented out\n\tfor the time being.\n\n\t* mkcheck.in: Append total time to test summary file.\n\n\t* bits/sbuf_iter.h : Formatting tweaks.\n\n\tClean up static const data member definitions.\n\t* src/locale.cc: Add definitions for all missing locale,\n\tlocale::_Imp, and locale::id static data members.\n\t(ctype<char>): Add table_size define.\n\t(money_base): Add _S_default_pattern, uglify.\n\t* bits/localefwd.h: Add definitions for static members of _Count_ones.\n\t* bits/locale_facets.h: Tweaks.\n\t* bits/locale_facets.tcc: Tweaks.\n\t* bits/string.tcc: Add definition for npos.\n\t* bits/ios_base.h: Tweaks.\n\t* bits/ios_base.h (ios_base::Init::_M_ios_base_init): Change to\n\t_S_ios_base_init.\n\t* src/ios.cc: And here. Add _S_local_words definition.\n\tAdd definitions for __ios_flags const static data.\n\t* src/codecvt.cc: Same for __enc_traits.\n\t* src/locale-inst.cc: Remove money_base data member definition\n\there.\n\nFrom-SVN: r36093", "tree": {"sha": "e4ed0d31f3384d6e2b1b7df55f3613fa7d2c99f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4ed0d31f3384d6e2b1b7df55f3613fa7d2c99f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0479a46292a4ead8ef2be5a122603432c754cd3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0479a46292a4ead8ef2be5a122603432c754cd3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0479a46292a4ead8ef2be5a122603432c754cd3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0479a46292a4ead8ef2be5a122603432c754cd3d/comments", "author": null, "committer": null, "parents": [{"sha": "b3e45cb1dfc9d47a7d95c1b1dfc9daf9d5132b06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3e45cb1dfc9d47a7d95c1b1dfc9daf9d5132b06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3e45cb1dfc9d47a7d95c1b1dfc9daf9d5132b06"}], "stats": {"total": 1477, "additions": 941, "deletions": 536}, "files": [{"sha": "ce442724195f49ce1bd1f7b562030849213d96e8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -1,3 +1,43 @@\n+2000-08-31  Benjamin Kosnik  <bkoz@cygnus.com>\n+\n+\t* bits/locale_facets.tcc (_S_build_float_format): Move ...\t\n+\t* src/locale.cc: Here.\t\t\n+\t* bits/locale_facets.tcc (num_get::_M_extract): Clean up generic\n+\tdefinition. Move specialization to ...\n+\t* src/locale.cc: Here.\t\n+\t* bits/locale_facets.tcc: Move _Format_cache specializations to ...\n+\t* src/locale.cc: Here.\n+\t* bits/locale_facets.tcc: Move use_facet<ctype> specializations to ...\n+\t* src/locale.cc: Here.\n+\n+\t* bits/std_locale.h: Note that locale_facets.tcc should be\n+\tincluded here, for standards conformance. It may increase\n+\tcompile times though. For the time being, enable.\n+\t* testsuite/22_locale/facet.cc: New file, some parts commented out\n+\tfor the time being.\n+\n+\t* mkcheck.in: Append total time to test summary file.\n+\n+\t* bits/sbuf_iter.h : Formatting tweaks.\n+\n+\tClean up static const data member definitions.\n+\t* src/locale.cc: Add definitions for all missing locale,\n+\tlocale::_Imp, and locale::id static data members.\n+\t(ctype<char>): Add table_size define.\n+\t(money_base): Add _S_default_pattern, uglify.\n+\t* bits/localefwd.h: Add definitions for static members of _Count_ones.\n+\t* bits/locale_facets.h: Tweaks.\n+\t* bits/locale_facets.tcc: Tweaks.\t\n+\t* bits/string.tcc: Add definition for npos.\n+\t* bits/ios_base.h: Tweaks.\n+\t* bits/ios_base.h (ios_base::Init::_M_ios_base_init): Change to\n+\t_S_ios_base_init.\n+\t* src/ios.cc: And here. Add _S_local_words definition.\n+\tAdd definitions for __ios_flags const static data.\n+\t* src/codecvt.cc: Same for __enc_traits.\n+\t* src/locale-inst.cc: Remove money_base data member definition\n+\there.\n+\n 2000-08-30  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/22_locale/ctype_wchar_t_members.cc (test01): New file."}, {"sha": "594621455220bbbf6b33adf89cb39260f871e75c", "filename": "libstdc++-v3/bits/ios_base.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Fios_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Fios_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fios_base.h?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -294,7 +294,7 @@ namespace std {\n       Init();\n       ~Init();\n     private:\n-      static int \t_M_ios_base_init;\n+      static int \t_S_ios_base_init;\n       filebuf* \t\t_M_cout;\n       filebuf* \t\t_M_cin;\n       filebuf* \t\t_M_cerr;"}, {"sha": "13def7d60538074a7d7c8c2b0094b9bc6f1dfb6a", "filename": "libstdc++-v3/bits/locale_facets.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -755,14 +755,16 @@ namespace std\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, void*& __v) const\n       { return do_get(__in, __end, __io, __err, __v); }      \n+\n       static locale::id id;\n \n     protected:\n       virtual ~num_get() { }\n \n       // This consolidates the extraction, storage and\n       // error-processing parts of the do_get(...) overloaded member\n-      // functions. NB: this is specialized for char.\n+      // functions. \n+      // NB: This is specialized for char.\n       void \n       _M_extract(iter_type __beg, iter_type __end, ios_base& __io, \n \t\t ios_base::iostate& __err, char* __xtrc, \n@@ -1454,7 +1456,7 @@ namespace std\n     enum part { none, space, symbol, sign, value };\n     struct pattern { char field[4]; };\n \n-    static const pattern __default_pattern;\n+    static const pattern _S_default_pattern;\n   };\n \n   template<typename _CharT>\n@@ -1513,16 +1515,11 @@ namespace std\n \n       virtual pattern      \n       do_pos_format() const\n-      {\n-\treturn money_base::__default_pattern;\n-      }\n+      { return money_base::_S_default_pattern; }\n \n       virtual pattern      \n       do_neg_format() const\n-      {\n-\treturn money_base::__default_pattern;\n-      }\n-\n+      { return money_base::_S_default_pattern; }\n     };\n \n   template<typename _CharT, bool _Intl>"}, {"sha": "199aa16fdace48d88c38e0c6f020e944b4ae4b9a", "filename": "libstdc++-v3/bits/locale_facets.tcc", "status": "modified", "additions": 53, "deletions": 386, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -173,20 +173,10 @@ namespace std\n     { }\n \n   template<>\n-    _Format_cache<char>::_Format_cache()\n-    : _M_valid(true),\n-    _M_decimal_point('.'), _M_thousands_sep(','),\n-    _M_truename(\"true\"), _M_falsename(\"false\"), _M_use_grouping(false)\n-    { }\n+    _Format_cache<char>::_Format_cache();\n \n-#ifdef _GLIBCPP_USE_WCHAR_T\n   template<>\n-    _Format_cache<wchar_t>::_Format_cache()\n-    : _M_valid(true),\n-    _M_decimal_point(L'.'), _M_thousands_sep(L','),\n-    _M_truename(L\"true\"), _M_falsename(L\"false\"), _M_use_grouping(false)\n-    { }\n-#endif\n+    _Format_cache<wchar_t>::_Format_cache();\n \n   template<typename _CharT>\n     void\n@@ -278,7 +268,7 @@ namespace std\n   template<typename _CharT, typename _InIter>\n     void\n     num_get<_CharT, _InIter>::\n-    _M_extract(iter_type /*__beg*/, iter_type /*__end*/, ios_base& /*__io*/,\n+    _M_extract(_InIter /*__beg*/, _InIter /*__end*/, ios_base& /*__io*/,\n                ios_base::iostate& /*__err*/, char* /*__xtrc*/,\n                int& /*__base*/, bool /*__fp*/) const\n     {\n@@ -288,305 +278,13 @@ namespace std\n   template<>\n     void\n     num_get<char, istreambuf_iterator<char> >::\n-    _M_extract(istreambuf_iterator<char> __beg,\n-               istreambuf_iterator<char> __end, ios_base& __io,\n-               ios_base::iostate& __err, char* __xtrc,\n-               int& __base, bool __fp) const\n-    {\n-      typedef _Format_cache<char> __cache_type;\t\n-\n-      // Prepare for possible failure\n-      __xtrc[0] = '\\0';\n-\n-      // Stage 1: determine a conversion specifier.\n-      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n-      if (__basefield == ios_base::dec)\n-        __base = 10;\n-      else if (__basefield == ios_base::oct)\n-        __base = 8;\n-      else if (__basefield == ios_base::hex)\n-        __base = 16;\n-      else\n-        __base = 0;\n-      // As far as I can tell, bases other than 10 are not available for\n-      // floating point types\n-      if (__fp)\n-        __base = 10;\n-\n-      // Stage 2: extract characters.\n-      __cache_type const* __fmt = __cache_type::_S_get(__io);\n-      bool __valid = __beg != __end;\n-      // Fail quickly if !__valid\n-      if (!__valid)\n-        {\n-          __err |= (ios_base::eofbit | ios_base::failbit);\n-          return;\n-        }\n-\n-      // Acceptable formats for numbers here are based on 22.2.3.1\n-      string __grp;\n-      int __sep_pos = 0;\n-      int __pos = 0;\n-      const char* __lits = __fmt->_S_literals;\n-      char __c = *__beg;\n-\n-      // Check first for sign\n-      bool __testsign = false;\n-      if ((__c == __lits[__cache_type::_S_minus])\n-          || (__c == __lits[__cache_type::_S_plus]))\n-        {\n-          __xtrc[__pos++] = __c;\n-          ++__beg;\n-          __testsign = true;\n-          // whitespace may follow a sign\n-          while ((__beg != __end) && (isspace(*__beg)))\n-            ++__beg;\n-\n-          // There had better be more to come...\n-          if (__beg == __end)\n-            {\n-              __xtrc[__pos] = '\\0';\n-              __err |= (ios_base::eofbit | ios_base::failbit);\n-              return;\n-            }\n-        }\n-\n-      bool __testzero = false;    // Has there been a leading zero?\n-\n-      // Now check if first character is a zero\n-      __c = *__beg;\n-      if (__c == __lits[__cache_type::_S_digits])\n-        {\n-           __testzero = true;\n-           ++__beg;\n-\n-           // We have to check for __beg == __end here. If so,\n-           // a plain '0' (possibly with a sign) can be got rid of now\n-           if (__beg == __end)\n-             {\n-               __xtrc[__pos++] = __c;\n-               __xtrc[__pos] = '\\0';\n-               __err |= ios_base::eofbit;\n-               return;\n-             }\n-\n-          // Figure out base for integer types only\n-          // Based on Table 55 of 22.2.2.1.2\n-          if (!__fp && __base != 10 && __base != 8)\n-            {\n-              // Here, __base == 0 or 16\n-              __c = *__beg;\n-              if ((__c == __lits[__cache_type::_S_x])\n-                 || (__c == __lits[__cache_type::_S_X]))\n-                {\n-                  ++__beg;\n-                  __base = 16;\n-                  __testzero = false; // \"0x\" is not a leading zero\n-                }\n-              else if (__base == 0)\n-                __base = 8;\n-            }\n-\n-          // Remove any more leading zeros\n-          while (__beg != __end)\n-            {\n-              if (*__beg == __lits[__cache_type::_S_digits])\n-                {\n-                  ++__beg;\n-                  __testzero = true;\n-                }\n-              else\n-                break;\n-            }\n-        }\n-      else if (__base == 0) // 1st character is not zero\n-        __base = 10;\n-\n-      // We now seek \"units\", i.e. digits and thousands separators.\n-      // We may need to know if anything is found here. A leading zero\n-      // (removed by now) would count.\n-      bool __testunits = __testzero;\n-      while (__valid && __beg != __end)\n-        {\n-          __valid = false;\n-          __c = *__beg;\n-          const char* __p = strchr(__fmt->_S_literals, __c);\n-\n-          // NB: strchr returns true for __c == 0x0\n-          if (__p && __c)\n-            {\n-              // Try first for acceptable digit; record it if found\n-              if ((__p >= &__lits[__cache_type::_S_digits]\n-                    && __p < &__lits[__cache_type::_S_digits + __base])\n-                   || (__p >= &__lits[__cache_type::_S_udigits]\n-                       && __p < &__lits[__cache_type::_S_udigits + __base]))\n-                {\n-                  __xtrc[__pos++] = __c;\n-                  ++__sep_pos;\n-                  __valid = true;\n-                  __testunits = true;\n-                }\n-            }\n-          else if (__c == __fmt->_M_thousands_sep\n-                   && __fmt->_M_use_grouping)\n-            {\n-              // NB: Thousands separator at the beginning of a string\n-              // is a no-no, as is two consecutive thousands\n-              // separators\n-              if (__sep_pos)\n-                {\n-                  __grp += static_cast<char>(__sep_pos);\n-                  __sep_pos = 0;\n-                  __valid = true;\n-                }\n-              else\n-                __err |= ios_base::failbit;\n-            }\n-          if (__valid)\n-            ++__beg;\n-        }\n-\n-      // Digit grouping is checked. If _M_groupings() doesn't\n-      // match, then get very very upset, and set failbit.\n-      if (__fmt->_M_use_grouping && !__grp.empty())\n-        {\n-          // Add the ending grouping\n-          __grp += static_cast<char>(__sep_pos);\n-\n-          // __grp is parsed L to R\n-          // 1,222,444 == __grp of \"/1/3/3\"\n-          // __fmt->_M_grouping is parsed R to L\n-          // 1,222,444 == __fmt->_M_grouping of \"/3\" == \"/3/3/3\"\n-          int __i = 0;\n-          int __j = 0;\n-          const int __len = __fmt->_M_grouping.size();\n-          int __n = __grp.size();\n-          bool __test = true;\n-\n-          // Parsed number groupings have to match the\n-          // numpunct::grouping string exactly, starting at the\n-          // right-most point of the parsed sequence of elements ...\n-          while (__test && __i < __n - 1)\n-            for (__j = 0; __test && __j < __len && __i < __n - 1; ++__j,++__i)\n-              __test &= __fmt->_M_grouping[__j] == __grp[__n - __i - 1];\n-          // ... but the last parsed grouping can be <= numpunct\n-          // grouping.\n-          __j == __len ? __j = 0 : __j;\n-          __test &= __fmt->_M_grouping[__j] >= __grp[__n - __i - 1];\n-\n-          if (!__test)\n-            {\n-              __err |= ios_base::failbit;\n-              __xtrc[__pos] = '\\0';\n-              if (__beg == __end)\n-                __err |= ios_base::eofbit;\n-              return;\n-            }\n-        }\n-\n-      // If there was nothing but zeros, put one in the output string\n-      if (__testzero && (__pos == 0 || (__pos == 1 && __testsign)))\n-        __xtrc[__pos++] = __lits[__cache_type::_S_digits];\n-\n-      // That's it for integer types. Remaining code is for floating point\n-      if (__fp && __beg != __end)\n-        {\n-          __c = *__beg;\n-          // Check first for decimal point. There MUST be one if\n-          // __testunits is false.\n-          bool __testdec = false;    // Is there a decimal point\n-                                     // with digits following it?\n-          if (__c == __fmt->_M_decimal_point)\n-            {\n-              __xtrc[__pos++] = '.';\n-              ++__beg;\n-              // Now we get any digits after the decimal point\n-              // There MUST be some if __testunits is false.\n-              while (__beg != __end)\n-                {\n-                  __c = *__beg;\n-                  const char* __p = strchr(__fmt->_S_literals, __c);\n-                  if ((__p >= &__lits[__cache_type::_S_digits]\n-                        && __p < &__lits[__cache_type::_S_digits + __base])\n-                       || (__p >= &__lits[__cache_type::_S_udigits]\n-                           && __p < &__lits[__cache_type::_S_udigits + __base]))\n-                    {\n-                      __xtrc[__pos++] = __c;\n-                      ++__beg;\n-                      __testdec = true;\n-                    }\n-                  else\n-                    break;\n-                }\n-            }\n-          if (!__testunits && !__testdec) // Ill formed\n-            {\n-              __err |= ios_base::failbit;\n-              __xtrc[__pos] = '\\0';\n-              if (__beg == __end)\n-                __err |= ios_base::eofbit;\n-              return;\n-            }\n-\n-          // Now we may find an exponent\n-          if (__beg != __end)\n-            {\n-              __c = *__beg;\n-              if ((__c == __lits[__cache_type::_S_ee])\n-                   || (__c == __lits[__cache_type::_S_Ee]))\n-                {\n-                  __xtrc[__pos++] = __c;\n-                  ++__beg;\n-                  // Now there may be a sign\n-                  if (__beg != __end)\n-                    {\n-                      __c = *__beg;\n-                      if ((__c == __lits[__cache_type::_S_minus])\n-                          || (__c == __lits[__cache_type::_S_plus]))\n-                        {\n-                          __xtrc[__pos++] = __c;\n-                          ++__beg;\n-                          // whitespace may follow a sign\n-                          while ((__beg != __end) && (isspace(*__beg)))\n-                            ++__beg;\n-\n-                        }\n-                    }\n-                  // And now there must be some digits\n-                  if (__beg == __end)\n-                    {\n-                      __xtrc[__pos] = '\\0';\n-                      __err |= (ios_base::eofbit | ios_base::failbit);\n-                      return;\n-                    }\n-                  while (__beg != __end)\n-                    {\n-                      __c = *__beg;\n-                      const char* __p = strchr(__fmt->_S_literals, __c);\n-                      if ((__p >= &__lits[__cache_type::_S_digits]\n-                            && __p < &__lits[__cache_type::_S_digits + __base])\n-                           || (__p >= &__lits[__cache_type::_S_udigits]\n-                               && __p < &__lits[__cache_type::_S_udigits + __base]))\n-                        {\n-                          __xtrc[__pos++] = __c;\n-                          ++__beg;\n-                        }\n-                      else\n-                        break;\n-                    }\n-                }\n-            }\n-          // Finally, that's it for floating point\n-        }\n-\n-      // Finish up\n-      __xtrc[__pos] = '\\0';\n-      if (__beg == __end)\n-        __err |= ios_base::eofbit;\n-    }\n+    _M_extract(istreambuf_iterator<char> __beg, \n+\t       istreambuf_iterator<char> __end, ios_base& __io, \n+\t       ios_base::iostate& __err, char* __xtrc, int& __base, \n+\t       bool __fp) const;\n \n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n   // NB: This is an unresolved library defect #17\n-  // _GLIBCPP_RESOLVE_LIB_DEFECTS\n   template<typename _CharT, typename _InIter>\n     _InIter\n     num_get<_CharT, _InIter>::\n@@ -655,6 +353,7 @@ namespace std\n \n       return __beg;\n     }\n+#endif\n \n #ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n   template<typename _CharT, typename _InIter>\n@@ -1063,10 +762,23 @@ namespace std\n \n   template <typename _CharT, typename _OutIter>\n     _OutIter\n-    _S_pad_numeric(_OutIter __s, ios_base::fmtflags __flags,\n+    _S_pad_numeric(_OutIter __s, ios_base::fmtflags /*__flags*/,\n+                   _CharT /*__fill*/, int /*__width*/, \n+\t\t   _CharT const* /*__first*/, _CharT const* /*__middle*/, \n+\t\t   _CharT const* /*__last*/)\n+    {\n+      // XXX Not currently done: non streambuf_iterator\n+      return __s;\n+    }\n+\n+  // Partial specialization for ostreambuf_iterator.\n+  template <typename _CharT>   \n+    ostreambuf_iterator<_CharT>\n+    _S_pad_numeric(ostreambuf_iterator<_CharT> __s, ios_base::fmtflags __flags,\n                    _CharT __fill, int __width, _CharT const* __first,\n                    _CharT const* __middle, _CharT const* __last)\n     {\n+      typedef ostreambuf_iterator<_CharT> \t__out_iter;\n       int __padding = __width - (__last - __first);\n       if (__padding < 0)\n         __padding = 0;\n@@ -1084,14 +796,14 @@ namespace std\n             }\n           copy(__first, __middle, __s);\n         }\n-      _OutIter __s2 = __s;\n+      __out_iter __s2 = __s;\n \n       if (__padding && __aflags != ios_base::left)\n         {\n           _S_fill(__s2, __fill, __padding);\n           __padding = 0;\n         }\n-      _OutIter __s3 = copy(__middle, __last, __s2);\n+      __out_iter __s3 = copy(__middle, __last, __s2);\n       if (__padding)\n         _S_fill(__s3, __fill, __padding);\n       return __s3;\n@@ -1271,55 +983,21 @@ namespace std\n     { return _S_format(__s, __io, __fill, false, __v); }\n #endif\n \n-  // The following code uses sprintf() to convert floating point\n-  // values for insertion into a stream. The current implementation\n-  // replicates the code in _S_pad_numeric() (in _S_output_float()) in\n-  // order to prevent having to create a \"wide\" buffer in addition to\n-  // the \"narrow\" buffer passed to sprintf(). An optimization would be\n-  // to replace sprintf() with code that works directly on a wide\n-  // buffer and then use _S_pad_numeric() to do the padding. It would\n-  // be good to replace sprintf() anyway to avoid accidental buffer\n-  // overruns and to gain back the efficiency that C++ provides by\n-  // knowing up front the type of the values to insert. This\n-  // implementation follows the C++ standard fairly directly as\n-  // outlined in 22.2.2.2 [lib.locale.num.put]\n-  bool\n-  _S_build_float_format(ios_base& __io, char* __fptr, char __modifier,\n-                        streamsize __prec)\n-  {\n-    bool __incl_prec = false;\n-    ios_base::fmtflags __flags = __io.flags();\n-    *__fptr++ = '%';\n-    // [22.2.2.2.2] Table 60\n-    if (__flags & ios_base::showpos)\n-      *__fptr++ = '+';\n-    if (__flags & ios_base::showpoint)\n-      *__fptr++ = '#';\n-    // As per [22.2.2.2.2.11]\n-    if (__flags & ios_base::fixed || __prec > 0)\n-      {\n-        *__fptr++ = '.';\n-        *__fptr++ = '*';\n-        __incl_prec = true;\n-      }\n-    if (__modifier)\n-      *__fptr++ = __modifier;\n-    ios_base::fmtflags __fltfield = __flags & ios_base::floatfield;\n-    // [22.2.2.2.2] Table 58\n-    if (__fltfield == ios_base::fixed)\n-      *__fptr++ = 'f';\n-    else if (__fltfield == ios_base::scientific)\n-      *__fptr++ = (__flags & ios_base::uppercase) ? 'E' : 'e';\n-    else\n-      *__fptr++ = (__flags & ios_base::uppercase) ? 'G' : 'g';\n-    *__fptr = '\\0';\n-    return __incl_prec;\n-  }\n-\n-  template<typename _CharT,typename _OutIter>\n-    _OutIter\n-    _S_output_float(_OutIter __s, ios_base& __io,_CharT __fill,\n+  // Generic helper function\n+  template<typename _CharT, typename _OutIter>\n+    static _OutIter\n+    _S_output_float(_OutIter __s, ios_base& __io, _CharT __fill,\n                     const char* __sptr, size_t __slen)\n+    {\n+      // XXX Not currently done: non streambuf_iterator\n+      return __s;\n+    }\n+\n+  // Partial specialization for ostreambuf_iterator.\n+  template<typename _CharT>\n+    static ostreambuf_iterator<_CharT>\n+    _S_output_float(ostreambuf_iterator<_CharT> __s, ios_base& __io, \n+\t\t    _CharT __fill, const char* __sptr, size_t __slen)\n     {\n       size_t __padding = __io.width() > streamsize(__slen) ?\n                          __io.width() -__slen : 0;\n@@ -1364,6 +1042,10 @@ namespace std\n       return __s;\n     }\n \n+  bool\n+  _S_build_float_format(ios_base& __io, char* __fptr, char __modifier,\n+                        streamsize __prec);\n+\n   template <typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n@@ -1454,7 +1136,7 @@ namespace std\n \n   template<typename _Dummy>\n     const char* const\n-    _Weekdaynames<char,_Dummy>::_S_names[14] =\n+    _Weekdaynames<char, _Dummy>::_S_names[14] =\n     {\n       \"Sun\", \"Sunday\",\n       \"Mon\", \"Monday\",   \"Tue\", \"Tuesday\", \"Wed\", \"Wednesday\",\n@@ -1463,12 +1145,12 @@ namespace std\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n   template<typename _Dummy>\n-    struct _Weekdaynames<wchar_t,_Dummy>\n+    struct _Weekdaynames<wchar_t, _Dummy>\n     { static const wchar_t* const _S_names[14]; };\n \n   template<typename _Dummy>\n     const wchar_t* const\n-    _Weekdaynames<wchar_t,_Dummy>::_S_names[14] =\n+    _Weekdaynames<wchar_t, _Dummy>::_S_names[14] =\n     {\n       L\"Sun\", L\"Sunday\",\n       L\"Mon\", L\"Monday\",   L\"Tue\", L\"Tuesday\", L\"Wed\", L\"Wednesday\",\n@@ -1576,31 +1258,16 @@ namespace std\n     locale::id money_put<_CharT, _OutIter>::id;\n \n   template<typename _CharT, bool _Intl>\n-    locale::id moneypunct<_CharT,_Intl>::id;\n-\n-  template<typename _CharT>\n-    locale::id messages<_CharT>::id;\n+    locale::id moneypunct<_CharT, _Intl>::id;\n \n-  template<>\n-    const ctype<char>&\n-    use_facet<const ctype<char> > (const locale& __loc)\n-    {\n-      size_t __i = ctype<char>::id._M_index;\n-      const locale::_Impl* __tmp = __loc._M_impl;\n-      return static_cast<const ctype<char>&>(* (*(__tmp->_M_facets))[__i]);\n-    }\n+  template<typename _CharT, bool _Intl>\n+    const bool moneypunct<_CharT, _Intl>::intl;\n \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template<>\n-    const ctype<wchar_t>&\n-    use_facet< const ctype<wchar_t> > (const locale& __loc)\n-    {\n-      size_t __i = ctype<wchar_t>::id._M_index;\n-      const locale::_Impl* __tmp = __loc._M_impl;\n-      return static_cast<const ctype<wchar_t>&>(* (*(__tmp->_M_facets))[__i]);\n-    }\n-#endif\n+  template<typename _CharT, bool _Intl>\n+    const bool moneypunct_byname<_CharT, _Intl>::intl;\n \n+  template<typename _CharT>\n+    locale::id messages<_CharT>::id;\n } // std::\n \n #endif /* _CPP_BITS_LOCFACETS_TCC */"}, {"sha": "e7cbd1dedaf61c2654c117230993d985f77be646", "filename": "libstdc++-v3/bits/localefwd.h", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocalefwd.h?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -45,23 +45,32 @@ namespace std\n   // _Count_ones: compile-time computation of number of 1-bits in a value N\n   // This takes only 5 (or 6) instantiations, doing recursive descent\n   // in parallel -- ncm\n-  template<unsigned _Num, int _Shift = (sizeof(unsigned) * CHAR_BIT)/2,\n-           unsigned _Mask = (~0u >> _Shift) >\n+  template<unsigned int _Num, int _Shift = (sizeof(unsigned) * CHAR_BIT)/2,\n+           unsigned int _Mask = (~0u >> _Shift) >\n     struct _Count_ones;\n \n-  template<unsigned _Num, unsigned _Mask>\n-    struct _Count_ones<_Num,0,_Mask> \n-    { static const unsigned _S_count = _Num; };\n+  template<unsigned int _Num, unsigned int _Mask>\n+    struct _Count_ones<_Num, 0, _Mask> \n+    { static const unsigned int _S_count = _Num; };\n \n-  template<unsigned _Num, int _Shift, unsigned _Mask>\n+  template<unsigned int _Num, unsigned int _Mask>\n+    const unsigned int _Count_ones<_Num, 0, _Mask>::_S_count;\n+\n+  template<unsigned int _Num, int _Shift, unsigned int _Mask>\n     struct _Count_ones \n     {\n-      static const unsigned _S_halfcount =\n+      static const unsigned int _S_halfcount =\n         _Count_ones<_Num, _Shift/2, (_Mask^((~_Mask)>>(_Shift/2))) >::_S_count;\n-      static const unsigned _S_count\n+      static const unsigned int _S_count\n       = (_S_halfcount&_Mask) + ((_S_halfcount>>_Shift)&_Mask);\n     };\n \n+  template<unsigned int _Num, int _Shift, unsigned int _Mask>\n+    const unsigned int _Count_ones<_Num, _Shift, _Mask>::_S_count;\n+\n+  template<unsigned int _Num, int _Shift, unsigned int _Mask>\n+    const unsigned int _Count_ones<_Num, _Shift, _Mask>::_S_halfcount;\n+\n   // 22.1.1 Locale\n   template<typename _Tp> class allocator;\n   template<typename _Tp, typename _Alloc> class vector;"}, {"sha": "7a0e1d5db22a577ac2a38b6d852958e39a4aac44", "filename": "libstdc++-v3/bits/sbuf_iter.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Fsbuf_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Fsbuf_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fsbuf_iter.h?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -38,7 +38,7 @@ namespace std\n   template<typename _CharT, typename _Traits>\n     class ostreambuf_iterator\n #if 0      // XXX this is standard:\n-    : public iterator<output_iterator_tag,_CharT,void,void,void>\n+    : public iterator<output_iterator_tag, _CharT, void, void, void>\n #else\n     : public output_iterator\n #endif"}, {"sha": "7eaba90e7eab884139cd67bd74a7d3f2a7b943a0", "filename": "libstdc++-v3/bits/std_locale.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Fstd_locale.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Fstd_locale.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_locale.h?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -36,6 +36,7 @@\n \n #include <bits/localefwd.h>\n #include <bits/locale_facets.h>\n+#include <bits/locale_facets.tcc>\n #include <bits/codecvt.h>\n \n #endif"}, {"sha": "c8857f6891d3d521a21a83096f5c2108646791fb", "filename": "libstdc++-v3/bits/string.tcc", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Fstring.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fbits%2Fstring.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstring.tcc?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -53,6 +53,17 @@ namespace std\n     basic_string<_CharT, _Traits, _Alloc>::\n     _Rep::_S_max_size = (((npos - sizeof(_Rep))/sizeof(_CharT)) - 1) / 4;\n \n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    const basic_string<_CharT, _Traits, _Alloc>::size_type\n+    basic_string<_CharT, _Traits, _Alloc>::npos;\n+\n+  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)\n+  // at static init time (before static ctors are run).\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_string<_CharT, _Traits, _Alloc>::size_type\n+    basic_string<_CharT, _Traits, _Alloc>::_S_empty_rep_storage[\n+    (sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];\n+\n   // NB: This is the special case for Input Iterators, used in\n   // istreambuf_iterators, etc.\n   // Input Iterators have a cost structure very different from\n@@ -396,13 +407,6 @@ namespace std\n       return 2 * (__s <= 16 ? 16 : __s) < __r;\n     }\n   \n-  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)\n-  // at static init time (before static ctors are run).\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    basic_string<_CharT, _Traits, _Alloc>::size_type\n-    basic_string<_CharT, _Traits, _Alloc>::_S_empty_rep_storage[\n-    (sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];\n-\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void\n     basic_string<_CharT, _Traits, _Alloc>::resize(size_type __n, _CharT __c)"}, {"sha": "839a9763167e16340b68a6dbbab775559db5e8cb", "filename": "libstdc++-v3/src/codecvt.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -31,6 +31,9 @@\n \n namespace std {\n \n+  // Definitions for static const data members of __enc_traits.\n+  const int __enc_traits::_S_max_size;\n+\n   // codecvt<char, char, mbstate_t> required specialization\n   locale::id codecvt<char, char, mbstate_t>::id;\n "}, {"sha": "ea8fecdc63145dcb943e4773926420ebfd2d3d8f", "filename": "libstdc++-v3/src/ios.cc", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios.cc?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -1,6 +1,6 @@\n // Iostreams base classes -*- C++ -*-\n \n-// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -37,7 +37,38 @@\n \n namespace std {\n \n-  // Out-of-line definitions for static const ios_base members.\n+  // Definitions for static const data members of __ios_flags.\n+  const __ios_flags::__int_type __ios_flags::_S_boolalpha;\n+  const __ios_flags::__int_type __ios_flags::_S_dec;\n+  const __ios_flags::__int_type __ios_flags::_S_fixed;\n+  const __ios_flags::__int_type __ios_flags::_S_hex;\n+  const __ios_flags::__int_type __ios_flags::_S_internal;\n+  const __ios_flags::__int_type __ios_flags::_S_left;\n+  const __ios_flags::__int_type __ios_flags::_S_oct;\n+  const __ios_flags::__int_type __ios_flags::_S_right;\n+  const __ios_flags::__int_type __ios_flags::_S_scientific;\n+  const __ios_flags::__int_type __ios_flags::_S_showbase;\n+  const __ios_flags::__int_type __ios_flags::_S_showpoint;\n+  const __ios_flags::__int_type __ios_flags::_S_showpos;\n+  const __ios_flags::__int_type __ios_flags::_S_skipws;\n+  const __ios_flags::__int_type __ios_flags::_S_unitbuf;\n+  const __ios_flags::__int_type __ios_flags::_S_uppercase;\n+  const __ios_flags::__int_type __ios_flags::_S_adjustfield;\n+  const __ios_flags::__int_type __ios_flags::_S_basefield;\n+  const __ios_flags::__int_type __ios_flags::_S_floatfield;\n+\n+  const __ios_flags::__int_type __ios_flags::_S_badbit;\n+  const __ios_flags::__int_type __ios_flags::_S_eofbit;\n+  const __ios_flags::__int_type __ios_flags::_S_failbit;\n+\n+  const __ios_flags::__int_type __ios_flags::_S_app;\n+  const __ios_flags::__int_type __ios_flags::_S_ate;\n+  const __ios_flags::__int_type __ios_flags::_S_bin;\n+  const __ios_flags::__int_type __ios_flags::_S_in;\n+  const __ios_flags::__int_type __ios_flags::_S_out;\n+  const __ios_flags::__int_type __ios_flags::_S_trunc;\n+\n+  // Definitions for static const members of ios_base.\n   const ios_base::fmtflags ios_base::boolalpha;\n   const ios_base::fmtflags ios_base::dec;\n   const ios_base::fmtflags ios_base::fixed;\n@@ -73,17 +104,19 @@ namespace std {\n   const ios_base::seekdir ios_base::cur;\n   const ios_base::seekdir ios_base::end;\n \n+  int ios_base::Init::_S_ios_base_init = 0;\n+\n+  const int ios_base::_S_local_words;\n+\n   ios_base::failure::failure(const string& __str)\n   {\n     strncpy(_M_name, __str.c_str(), _M_bufsize);\n     _M_name[_M_bufsize - 1] = '\\0';\n   }\n \n-  int ios_base::Init::_M_ios_base_init = 0;\n-\n   ios_base::Init::Init()\n   {\n-    if (++_M_ios_base_init == 1)\n+    if (++_S_ios_base_init == 1)\n       {\n \t// NB: std_iostream.h creates the four standard files with\n \t// default buffers. At this point, we swap out the default\n@@ -124,7 +157,7 @@ namespace std {\n \n   ios_base::Init::~Init()\n   {\n-    if (--_M_ios_base_init == 0)\n+    if (--_S_ios_base_init == 0)\n       {\n \tcout.flush();\n \tcerr.flush();"}, {"sha": "20ff88d584ff163ef9ceb0dfb693928f36d3a6ff", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -50,10 +50,6 @@ namespace std {\n   typedef istreambuf_iterator<wchar_t, char_traits<wchar_t> > wibuf_iterator;\n \n   // moneypunct, money_get, and money_put\n-\n-  const money_base::pattern\n-    money_base::__default_pattern = {{symbol, sign, none, value}};\n-\n   template class moneypunct<char, false>;\n   template class moneypunct<char, true>;\n   template class moneypunct_byname<char, false>;"}, {"sha": "2359de8a4cf947b0c8f68c4e5554b33ac58f635d", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 511, "deletions": 114, "changes": 625, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -42,6 +42,514 @@\n #endif\n namespace std {\n \n+  // Definitions for static const data members of locale.\n+  const locale::category locale::none;\n+  const locale::category locale::collate;\n+  const locale::category locale::ctype;\n+  const locale::category locale::monetary;\n+  const locale::category locale::numeric;\n+  const locale::category locale::time;\n+  const locale::category locale::messages;\n+  const locale::category locale::all;\n+\n+  locale::_Impl* locale::_S_global;  // init'd to 0 before static ctors run\n+  locale::_Impl* locale::_S_classic; // init'd to 0 before static ctors run\n+  const int locale::_S_num_categories;\n+\n+  // Definitions for static const data members of locale::_Impl\n+  const locale::id* const\n+  locale::_Impl::_S_id_collate[] =\n+  {\n+    &std::collate<char>::id,\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::collate<wchar_t>::id,\n+#endif\n+    0\n+  };\n+  \n+  const locale::id* const\n+  locale::_Impl::_S_id_ctype[] =\n+  {\n+    &std::ctype<char>::id, \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::ctype<wchar_t>::id,\n+#endif\n+    &std::codecvt<char, char, mbstate_t>::id,\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::codecvt<wchar_t, char, mbstate_t>::id,\n+#endif\n+    0\n+  };\n+\n+  const locale::id* const\n+  locale::_Impl::_S_id_monetary[] =\n+  {\n+    &std::moneypunct<char, false>::id, \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::moneypunct<wchar_t, false>::id,\n+#endif\n+    &std::moneypunct<char,true >::id, \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::moneypunct<wchar_t,true >::id,\n+#endif\n+    &std::money_get<char>::id,        \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::money_get<wchar_t>::id,\n+#endif\n+    &std::money_put<char>::id,        \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::money_put<wchar_t>::id,\n+#endif\n+    0\n+  };\n+\n+  const locale::id* const\n+  locale::_Impl::_S_id_numeric[] =\n+  {\n+    &std::numpunct<char>::id, \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::numpunct<wchar_t>::id,\n+#endif\n+    &std::num_get<char>::id,  \n+ #ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::num_get<wchar_t>::id,\n+#endif\n+    &std::num_put<char>::id,  \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::num_put<wchar_t>::id,\n+#endif\n+    0\n+  };\n+  \n+  const locale::id* const\n+  locale::_Impl::_S_id_time[] =\n+  {\n+    &std::time_get<char>::id, \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::time_get<wchar_t>::id,\n+#endif\n+    &std::time_put<char>::id, \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::time_put<wchar_t>::id,\n+#endif\n+    0\n+  };\n+  \n+  const locale::id* const\n+  locale::_Impl::_S_id_messages[] =\n+  {\n+    &std::time_get<char>::id, \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::time_get<wchar_t>::id,\n+#endif\n+    &std::time_put<char>::id, \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+    &std::time_put<wchar_t>::id,\n+#endif\n+    0\n+  };\n+  \n+  const locale::id* const* const\n+  locale::_Impl::_S_facet_categories[] =\n+  {\n+    //  order must match the decl order in class locale.\n+    locale::_Impl::_S_id_collate,\n+    locale::_Impl::_S_id_ctype,\n+    locale::_Impl::_S_id_monetary,\n+    locale::_Impl::_S_id_numeric,\n+    locale::_Impl::_S_id_time,\n+    locale::_Impl::_S_id_messages,\n+    0\n+  };\n+\n+  // Definitions for static const data members of locale::id\n+  size_t locale::id::_S_highwater;  // init'd to 0 by linker\n+\n+  // Definitions for static const data members of money_base\n+  const money_base::pattern \n+  money_base::_S_default_pattern =  {{symbol, sign, none, value}};;\n+\n+  template<>\n+    _Format_cache<char>::_Format_cache()\n+    : _M_valid(true),\n+    _M_decimal_point('.'), _M_thousands_sep(','),\n+    _M_truename(\"true\"), _M_falsename(\"false\"), _M_use_grouping(false)\n+    { }\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    _Format_cache<wchar_t>::_Format_cache()\n+    : _M_valid(true),\n+    _M_decimal_point(L'.'), _M_thousands_sep(L','),\n+    _M_truename(L\"true\"), _M_falsename(L\"false\"), _M_use_grouping(false)\n+    { }\n+#endif\n+\n+  template<>\n+    const ctype<char>&\n+    use_facet<const ctype<char> > (const locale& __loc)\n+    {\n+      size_t __i = ctype<char>::id._M_index;\n+      const locale::_Impl* __tmp = __loc._M_impl;\n+      return static_cast<const ctype<char>&>(* (*(__tmp->_M_facets))[__i]);\n+    }\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    const ctype<wchar_t>&\n+    use_facet< const ctype<wchar_t> > (const locale& __loc)\n+    {\n+      size_t __i = ctype<wchar_t>::id._M_index;\n+      const locale::_Impl* __tmp = __loc._M_impl;\n+      return static_cast<const ctype<wchar_t>&>(* (*(__tmp->_M_facets))[__i]);\n+    }\n+#endif\n+\n+  template<>\n+    void\n+    num_get<char, istreambuf_iterator<char> >::\n+    _M_extract(istreambuf_iterator<char> __beg, \n+\t       istreambuf_iterator<char> __end, ios_base& __io, \n+\t       ios_base::iostate& __err, char* __xtrc, int& __base, \n+\t       bool __fp) const\n+    {\n+      typedef _Format_cache<char> __cache_type;\t\n+\n+      // Prepare for possible failure\n+      __xtrc[0] = '\\0';\n+\n+      // Stage 1: determine a conversion specifier.\n+      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n+      if (__basefield == ios_base::dec)\n+        __base = 10;\n+      else if (__basefield == ios_base::oct)\n+        __base = 8;\n+      else if (__basefield == ios_base::hex)\n+        __base = 16;\n+      else\n+        __base = 0;\n+      // As far as I can tell, bases other than 10 are not available for\n+      // floating point types\n+      if (__fp)\n+        __base = 10;\n+\n+      // Stage 2: extract characters.\n+      __cache_type const* __fmt = __cache_type::_S_get(__io);\n+      bool __valid = __beg != __end;\n+      // Fail quickly if !__valid\n+      if (!__valid)\n+        {\n+          __err |= (ios_base::eofbit | ios_base::failbit);\n+          return;\n+        }\n+\n+      // Acceptable formats for numbers here are based on 22.2.3.1\n+      string __grp;\n+      int __sep_pos = 0;\n+      int __pos = 0;\n+      const char* __lits = __fmt->_S_literals;\n+      char __c = *__beg;\n+\n+      // Check first for sign\n+      bool __testsign = false;\n+      if ((__c == __lits[__cache_type::_S_minus])\n+          || (__c == __lits[__cache_type::_S_plus]))\n+        {\n+          __xtrc[__pos++] = __c;\n+          ++__beg;\n+          __testsign = true;\n+          // whitespace may follow a sign\n+          while ((__beg != __end) && (isspace(*__beg)))\n+            ++__beg;\n+\n+          // There had better be more to come...\n+          if (__beg == __end)\n+            {\n+              __xtrc[__pos] = '\\0';\n+              __err |= (ios_base::eofbit | ios_base::failbit);\n+              return;\n+            }\n+        }\n+\n+      bool __testzero = false;    // Has there been a leading zero?\n+\n+      // Now check if first character is a zero\n+      __c = *__beg;\n+      if (__c == __lits[__cache_type::_S_digits])\n+        {\n+           __testzero = true;\n+           ++__beg;\n+\n+           // We have to check for __beg == __end here. If so,\n+           // a plain '0' (possibly with a sign) can be got rid of now\n+           if (__beg == __end)\n+             {\n+               __xtrc[__pos++] = __c;\n+               __xtrc[__pos] = '\\0';\n+               __err |= ios_base::eofbit;\n+               return;\n+             }\n+\n+          // Figure out base for integer types only\n+          // Based on Table 55 of 22.2.2.1.2\n+          if (!__fp && __base != 10 && __base != 8)\n+            {\n+              // Here, __base == 0 or 16\n+              __c = *__beg;\n+              if ((__c == __lits[__cache_type::_S_x])\n+                 || (__c == __lits[__cache_type::_S_X]))\n+                {\n+                  ++__beg;\n+                  __base = 16;\n+                  __testzero = false; // \"0x\" is not a leading zero\n+                }\n+              else if (__base == 0)\n+                __base = 8;\n+            }\n+\n+          // Remove any more leading zeros\n+          while (__beg != __end)\n+            {\n+              if (*__beg == __lits[__cache_type::_S_digits])\n+                {\n+                  ++__beg;\n+                  __testzero = true;\n+                }\n+              else\n+                break;\n+            }\n+        }\n+      else if (__base == 0) // 1st character is not zero\n+        __base = 10;\n+\n+      // We now seek \"units\", i.e. digits and thousands separators.\n+      // We may need to know if anything is found here. A leading zero\n+      // (removed by now) would count.\n+      bool __testunits = __testzero;\n+      while (__valid && __beg != __end)\n+        {\n+          __valid = false;\n+          __c = *__beg;\n+          const char* __p = strchr(__fmt->_S_literals, __c);\n+\n+          // NB: strchr returns true for __c == 0x0\n+          if (__p && __c)\n+            {\n+              // Try first for acceptable digit; record it if found\n+              if ((__p >= &__lits[__cache_type::_S_digits]\n+                    && __p < &__lits[__cache_type::_S_digits + __base])\n+                   || (__p >= &__lits[__cache_type::_S_udigits]\n+                       && __p < &__lits[__cache_type::_S_udigits + __base]))\n+                {\n+                  __xtrc[__pos++] = __c;\n+                  ++__sep_pos;\n+                  __valid = true;\n+                  __testunits = true;\n+                }\n+            }\n+          else if (__c == __fmt->_M_thousands_sep\n+                   && __fmt->_M_use_grouping)\n+            {\n+              // NB: Thousands separator at the beginning of a string\n+              // is a no-no, as is two consecutive thousands\n+              // separators\n+              if (__sep_pos)\n+                {\n+                  __grp += static_cast<char>(__sep_pos);\n+                  __sep_pos = 0;\n+                  __valid = true;\n+                }\n+              else\n+                __err |= ios_base::failbit;\n+            }\n+          if (__valid)\n+            ++__beg;\n+        }\n+\n+      // Digit grouping is checked. If _M_groupings() doesn't\n+      // match, then get very very upset, and set failbit.\n+      if (__fmt->_M_use_grouping && !__grp.empty())\n+        {\n+          // Add the ending grouping\n+          __grp += static_cast<char>(__sep_pos);\n+\n+          // __grp is parsed L to R\n+          // 1,222,444 == __grp of \"/1/3/3\"\n+          // __fmt->_M_grouping is parsed R to L\n+          // 1,222,444 == __fmt->_M_grouping of \"/3\" == \"/3/3/3\"\n+          int __i = 0;\n+          int __j = 0;\n+          const int __len = __fmt->_M_grouping.size();\n+          int __n = __grp.size();\n+          bool __test = true;\n+\n+          // Parsed number groupings have to match the\n+          // numpunct::grouping string exactly, starting at the\n+          // right-most point of the parsed sequence of elements ...\n+          while (__test && __i < __n - 1)\n+            for (__j = 0; __test && __j < __len && __i < __n - 1; ++__j,++__i)\n+              __test &= __fmt->_M_grouping[__j] == __grp[__n - __i - 1];\n+          // ... but the last parsed grouping can be <= numpunct\n+          // grouping.\n+          __j == __len ? __j = 0 : __j;\n+          __test &= __fmt->_M_grouping[__j] >= __grp[__n - __i - 1];\n+\n+          if (!__test)\n+            {\n+              __err |= ios_base::failbit;\n+              __xtrc[__pos] = '\\0';\n+              if (__beg == __end)\n+                __err |= ios_base::eofbit;\n+              return;\n+            }\n+        }\n+\n+      // If there was nothing but zeros, put one in the output string\n+      if (__testzero && (__pos == 0 || (__pos == 1 && __testsign)))\n+        __xtrc[__pos++] = __lits[__cache_type::_S_digits];\n+\n+      // That's it for integer types. Remaining code is for floating point\n+      if (__fp && __beg != __end)\n+        {\n+          __c = *__beg;\n+          // Check first for decimal point. There MUST be one if\n+          // __testunits is false.\n+          bool __testdec = false;    // Is there a decimal point\n+                                     // with digits following it?\n+          if (__c == __fmt->_M_decimal_point)\n+            {\n+              __xtrc[__pos++] = '.';\n+              ++__beg;\n+              // Now we get any digits after the decimal point\n+              // There MUST be some if __testunits is false.\n+              while (__beg != __end)\n+                {\n+                  __c = *__beg;\n+                  const char* __p = strchr(__fmt->_S_literals, __c);\n+                  if ((__p >= &__lits[__cache_type::_S_digits]\n+                        && __p < &__lits[__cache_type::_S_digits + __base])\n+                       || (__p >= &__lits[__cache_type::_S_udigits]\n+                           && __p < &__lits[__cache_type::_S_udigits + __base]))\n+                    {\n+                      __xtrc[__pos++] = __c;\n+                      ++__beg;\n+                      __testdec = true;\n+                    }\n+                  else\n+                    break;\n+                }\n+            }\n+          if (!__testunits && !__testdec) // Ill formed\n+            {\n+              __err |= ios_base::failbit;\n+              __xtrc[__pos] = '\\0';\n+              if (__beg == __end)\n+                __err |= ios_base::eofbit;\n+              return;\n+            }\n+\n+          // Now we may find an exponent\n+          if (__beg != __end)\n+            {\n+              __c = *__beg;\n+              if ((__c == __lits[__cache_type::_S_ee])\n+                   || (__c == __lits[__cache_type::_S_Ee]))\n+                {\n+                  __xtrc[__pos++] = __c;\n+                  ++__beg;\n+                  // Now there may be a sign\n+                  if (__beg != __end)\n+                    {\n+                      __c = *__beg;\n+                      if ((__c == __lits[__cache_type::_S_minus])\n+                          || (__c == __lits[__cache_type::_S_plus]))\n+                        {\n+                          __xtrc[__pos++] = __c;\n+                          ++__beg;\n+                          // whitespace may follow a sign\n+                          while ((__beg != __end) && (isspace(*__beg)))\n+                            ++__beg;\n+\n+                        }\n+                    }\n+                  // And now there must be some digits\n+                  if (__beg == __end)\n+                    {\n+                      __xtrc[__pos] = '\\0';\n+                      __err |= (ios_base::eofbit | ios_base::failbit);\n+                      return;\n+                    }\n+                  while (__beg != __end)\n+                    {\n+                      __c = *__beg;\n+                      const char* __p = strchr(__fmt->_S_literals, __c);\n+                      if ((__p >= &__lits[__cache_type::_S_digits]\n+                            && __p < &__lits[__cache_type::_S_digits + __base])\n+                           || (__p >= &__lits[__cache_type::_S_udigits]\n+                               && __p < &__lits[__cache_type::_S_udigits + __base]))\n+                        {\n+                          __xtrc[__pos++] = __c;\n+                          ++__beg;\n+                        }\n+                      else\n+                        break;\n+                    }\n+                }\n+            }\n+          // Finally, that's it for floating point\n+        }\n+\n+      // Finish up\n+      __xtrc[__pos] = '\\0';\n+      if (__beg == __end)\n+        __err |= ios_base::eofbit;\n+    }\n+\n+  // The following code uses sprintf() to convert floating point\n+  // values for insertion into a stream. The current implementation\n+  // replicates the code in _S_pad_numeric() (in _S_output_float()) in\n+  // order to prevent having to create a \"wide\" buffer in addition to\n+  // the \"narrow\" buffer passed to sprintf(). An optimization would be\n+  // to replace sprintf() with code that works directly on a wide\n+  // buffer and then use _S_pad_numeric() to do the padding. It would\n+  // be good to replace sprintf() anyway to avoid accidental buffer\n+  // overruns and to gain back the efficiency that C++ provides by\n+  // knowing up front the type of the values to insert. This\n+  // implementation follows the C++ standard fairly directly as\n+  // outlined in 22.2.2.2 [lib.locale.num.put]\n+  bool\n+  _S_build_float_format(ios_base& __io, char* __fptr, char __modifier,\n+                        streamsize __prec)\n+  {\n+    bool __incl_prec = false;\n+    ios_base::fmtflags __flags = __io.flags();\n+    *__fptr++ = '%';\n+    // [22.2.2.2.2] Table 60\n+    if (__flags & ios_base::showpos)\n+      *__fptr++ = '+';\n+    if (__flags & ios_base::showpoint)\n+      *__fptr++ = '#';\n+    // As per [22.2.2.2.2.11]\n+    if (__flags & ios_base::fixed || __prec > 0)\n+      {\n+        *__fptr++ = '.';\n+        *__fptr++ = '*';\n+        __incl_prec = true;\n+      }\n+    if (__modifier)\n+      *__fptr++ = __modifier;\n+    ios_base::fmtflags __fltfield = __flags & ios_base::floatfield;\n+    // [22.2.2.2.2] Table 58\n+    if (__fltfield == ios_base::fixed)\n+      *__fptr++ = 'f';\n+    else if (__fltfield == ios_base::scientific)\n+      *__fptr++ = (__flags & ios_base::uppercase) ? 'E' : 'e';\n+    else\n+      *__fptr++ = (__flags & ios_base::uppercase) ? 'G' : 'g';\n+    *__fptr = '\\0';\n+    return __incl_prec;\n+  }\n+\n   // locale::_Impl\n   locale::_Impl::\n   ~_Impl() throw()\n@@ -157,116 +665,7 @@ namespace std {\n       __fpr->_M_remove_reference();\n     __fpr = __fp;\n   }\n-\n-  // locale facet category descriptions\n-  const locale::id* const\n-  locale::_Impl::_S_id_collate[] =\n-  {\n-    &std::collate<char>::id,\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::collate<wchar_t>::id,\n-#endif\n-    0\n-  };\n-  \n-  const locale::id* const\n-  locale::_Impl::_S_id_ctype[] =\n-  {\n-    &std::ctype<char>::id, \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::ctype<wchar_t>::id,\n-#endif\n-    &std::codecvt<char, char, mbstate_t>::id,\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::codecvt<wchar_t, char, mbstate_t>::id,\n-#endif\n-    0\n-  };\n-\n-  const locale::id* const\n-  locale::_Impl::_S_id_monetary[] =\n-  {\n-    &std::moneypunct<char, false>::id, \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::moneypunct<wchar_t, false>::id,\n-#endif\n-    &std::moneypunct<char,true >::id, \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::moneypunct<wchar_t,true >::id,\n-#endif\n-    &std::money_get<char>::id,        \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::money_get<wchar_t>::id,\n-#endif\n-    &std::money_put<char>::id,        \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::money_put<wchar_t>::id,\n-#endif\n-    0\n-  };\n-\n-  const locale::id* const\n-  locale::_Impl::_S_id_numeric[] =\n-  {\n-    &std::numpunct<char>::id, \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::numpunct<wchar_t>::id,\n-#endif\n-    &std::num_get<char>::id,  \n- #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::num_get<wchar_t>::id,\n-#endif\n-    &std::num_put<char>::id,  \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::num_put<wchar_t>::id,\n-#endif\n-    0\n-  };\n-  \n-  const locale::id* const\n-  locale::_Impl::_S_id_time[] =\n-  {\n-    &std::time_get<char>::id, \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::time_get<wchar_t>::id,\n-#endif\n-    &std::time_put<char>::id, \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::time_put<wchar_t>::id,\n-#endif\n-    0\n-  };\n-  \n-  const locale::id* const\n-  locale::_Impl::_S_id_messages[] =\n-  {\n-    &std::time_get<char>::id, \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::time_get<wchar_t>::id,\n-#endif\n-    &std::time_put<char>::id, \n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::time_put<wchar_t>::id,\n-#endif\n-    0\n-  };\n-  \n-  const locale::id* const* const\n-  locale::_Impl::_S_facet_categories[] =\n-  {\n-    //  order must match the decl order in class locale.\n-    locale::_Impl::_S_id_collate,\n-    locale::_Impl::_S_id_ctype,\n-    locale::_Impl::_S_id_monetary,\n-    locale::_Impl::_S_id_numeric,\n-    locale::_Impl::_S_id_time,\n-    locale::_Impl::_S_id_messages,\n-    0\n-  };\n-  \n-  locale::_Impl* locale::_S_global;  // init'd to 0 before static ctors run\n-  locale::_Impl* locale::_S_classic; // init'd to 0 before static ctors run\n-\n+ \n   locale::\n   locale(_Impl* __ip) throw()\n   : _M_impl(__ip)\n@@ -457,14 +856,13 @@ namespace std {\n   _Bad_use_facet::\n   ~_Bad_use_facet() throw() { }\n   \n-  size_t locale::id::_S_highwater;  // init'd to 0 by linker\n-\n-\n   // Platform-specific initialization code for ctype tables.\n   #include <ctype.cc>\n \n   locale::id ctype<char>::id;\n \n+  const size_t ctype<char>::table_size;\n+\n   ctype<char>::\n   ~ctype()\n   { if (_M_del) delete[] this->table(); }\n@@ -501,7 +899,6 @@ namespace std {\n   : ctype<char>(new mask[table_size], true, __refs)\n   { }\n \n-\n   locale::id collate<char>::id;\n \n   collate<char>::collate(size_t __refs)"}, {"sha": "1930c50e6fc8f5d6191781122039b971895b02ad", "filename": "libstdc++-v3/testsuite/22_locale/facet.cc", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ffacet.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0479a46292a4ead8ef2be5a122603432c754cd3d/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ffacet.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ffacet.cc?ref=0479a46292a4ead8ef2be5a122603432c754cd3d", "patch": "@@ -0,0 +1,258 @@\n+// 2000-08-31 Benjamin Kosnik <bkoz@redhat.com>\n+\n+// Copyright (C) 2000 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.1.1.1.2 - class locale::facet [lib.locale.facet]\n+\n+#include <locale>\n+#include <iterator>\n+#include <debug_assert.h>\n+\n+// 1 a class if a facet if it is publicly derived from another facet\n+class gnu_input_iterator: public std::iterator<std::input_iterator_tag, char>\n+{\n+  value_type it;\n+public:\n+  gnu_input_iterator(value_type orig): it(orig) { }\n+\n+  value_type \n+  operator*() const { return it; }\n+\n+  reference\n+  operator++(){ return ++it; }\n+\n+  reference\n+  operator++(int){ ++it; return it; }\n+};\n+\n+bool\n+operator==(const gnu_input_iterator& lhs, const gnu_input_iterator& rhs)\n+{ return true; }\n+\n+bool\n+operator!=(const gnu_input_iterator& lhs, const gnu_input_iterator& rhs)\n+{ return true; }\n+\n+class gnu_output_iterator: public std::iterator<std::output_iterator_tag, char>\n+{ \n+  value_type it;\n+public:\n+  gnu_output_iterator(value_type orig): it(orig) { }\n+\n+  value_type\n+  operator*(){ return it; }\n+\n+  gnu_output_iterator&\n+  operator=(value_type obj){ it = obj; return *this; }\n+\n+  reference \n+  operator++(){ return ++it; }\n+\n+  reference \n+  operator++(int){ ++it; return it; }\n+\n+};\n+\n+class gnu_collate: public std::collate<char> { }; \n+class gnu_ctype: public std::ctype<char> { }; \n+class gnu_codecvt: public std::codecvt<char, char, mbstate_t> { }; \n+class gnu_moneypunct: public std::moneypunct<char> { }; \n+class gnu_moneypunct_true: public std::moneypunct<char, true> { }; \n+class gnu_money_get: public std::money_get<char> { }; \n+class gnu_money_put: public std::money_put<char> { }; \n+class gnu_numpunct: public std::numpunct<char> { }; \n+class gnu_num_get: public std::num_get<char> { }; \n+class gnu_num_put: public std::num_put<char> { }; \n+class gnu_time_get: public std::time_get<char> { }; \n+class gnu_time_put: public std::time_put<char> { }; \n+class gnu_messages: public std::messages<char> { }; \n+\n+class gnu_collate_byname: public std::collate_byname<char> \n+{\n+public:\n+  explicit\n+  gnu_collate_byname(const char* c, size_t refs = 0)\n+  : std::collate_byname<char>(c, refs) { }\n+}; \n+\n+class gnu_ctype_byname: public std::ctype_byname<char> \n+{\n+public:\n+  explicit\n+  gnu_ctype_byname(const char* c, size_t refs = 0)\n+  : std::ctype_byname<char>(c, refs) { }\n+}; \n+\n+class gnu_moneypunct_byname_true: public std::moneypunct_byname<char, true> \n+{\n+public:\n+  explicit\n+  gnu_moneypunct_byname_true(const char* c, size_t refs = 0)\n+  : std::moneypunct_byname<char, true>(c, refs) { }\n+}; \n+\n+class gnu_moneypunct_byname_false: public std::moneypunct_byname<char, false> \n+{\n+public:\n+  explicit\n+  gnu_moneypunct_byname_false(const char* c, size_t refs = 0)\n+  : std::moneypunct_byname<char, false>(c, refs) { }\n+}; \n+\n+\n+class gnu_money_get_in: public std::money_get<char, gnu_input_iterator>\n+{\n+public:\n+  explicit\n+  gnu_money_get_in(size_t refs = 0)\n+  : std::money_get<char, gnu_input_iterator>(refs) { }\n+};\n+\n+class gnu_money_put_out: public std::money_put<char, gnu_output_iterator>\n+{\n+public:\n+  explicit\n+  gnu_money_put_out(size_t refs = 0)\n+  : std::money_put<char, gnu_output_iterator>(refs) { }\n+};\n+\n+class gnu_numpunct_byname: public std::numpunct_byname<char>\n+{\n+public:\n+  explicit\n+  gnu_numpunct_byname(const char* c, size_t refs = 0)\n+  : std::numpunct_byname<char>(c, refs) { }\n+};\n+\n+class gnu_num_get_in: public std::num_get<char, gnu_input_iterator> \n+{\n+public:\n+  explicit\n+  gnu_num_get_in(size_t refs = 0)\n+  : std::num_get<char, gnu_input_iterator>(refs) { }\n+};\n+\n+class gnu_num_put_out: public std::num_put<char, gnu_output_iterator> \n+{\n+public:\n+  explicit\n+  gnu_num_put_out(size_t refs = 0)\n+  : std::num_put<char, gnu_output_iterator>(refs) { }\n+};\n+\n+class gnu_time_get_byname: public std::time_get_byname<char>\n+{\n+public:\n+  explicit\n+  gnu_time_get_byname(const char* c, size_t refs = 0)\n+  : std::time_get_byname<char>(c, refs) { }\n+};\n+\n+class gnu_time_get_in: public std::time_get<char, gnu_input_iterator>\n+{\n+public:\n+  explicit\n+  gnu_time_get_in(size_t refs = 0)\n+  : std::time_get<char, gnu_input_iterator>(refs) { }\n+};\n+\n+class gnu_time_put_byname: public std::time_put_byname<char> \n+{\n+public:\n+  explicit\n+  gnu_time_put_byname(const char* c, size_t refs = 0)\n+  : std::time_put_byname<char>(c, refs) { }\n+};\n+\n+class gnu_time_put_out: public std::time_put<char, gnu_output_iterator> \n+{\n+public:\n+  explicit\n+  gnu_time_put_out(size_t refs = 0)\n+  : std::time_put<char, gnu_output_iterator>(refs) { }\n+};\n+\n+class gnu_messages_byname: public std::messages_byname<char> \n+{\n+public:\n+  explicit\n+  gnu_messages_byname(const char* c, size_t refs = 0)\n+  : std::messages_byname<char>(c, refs) { }\n+};\n+\n+\n+// 2 or if it is a class deerived from locale:;facet and containing a\n+// publicly-accessible declaration as follows:\n+class gnu_facet: public std::locale::facet\n+{\n+public:\n+  static std::locale::id id;\n+};\n+\n+std::locale::id gnu_facet::id;\n+\n+void test01()\n+{\n+  // 1\n+  gnu_collate \t\t\tobj01;\n+  gnu_ctype \t\t\tobj02;\n+  gnu_codecvt \t\t\tobj03;\n+  gnu_moneypunct\t\tobj04;\n+  gnu_moneypunct_true\t\tobj05;\n+  gnu_money_get\t\t\tobj06;\n+  gnu_money_put\t\t\tobj07;\n+  gnu_numpunct\t\t\tobj08;\n+  gnu_num_get\t\t\tobj09;\n+  gnu_num_put\t\t\tobj10;\n+  gnu_time_get\t\t\tobj11;\n+  gnu_time_put\t\t\tobj12;\n+  gnu_messages\t\t\tobj13;\n+  gnu_time_put_out\t\tobj14(0);\n+  gnu_time_put_byname\t\tobj15(\"gnu_message_byname\", 0);\n+  gnu_time_get_in\t\tobj16(0);\n+  gnu_time_get_byname\t\tobj17(\"gnu_message_byname\", 0);\n+  // gnu_num_put_out\t\tobj18(0);\n+  // gnu_num_get_in\t\tobj19(0);\n+  gnu_numpunct_byname\t\tobj20(\"gnu_message_byname\", 0);\n+  gnu_money_put_out\t\tobj21(0);\n+  gnu_money_get_in\t\tobj22(0);\n+  gnu_moneypunct_byname_false\tobj23(\"gnu_message_byname\", 0);\n+  gnu_moneypunct_byname_true\tobj24(\"gnu_message_byname\", 0);\n+  gnu_ctype_byname\t\tobj25(\"gnu_message_byname\", 0);\n+  gnu_collate_byname\t\tobj26(\"gnu_message_byname\", 0);\n+  gnu_messages_byname\t\tobj27(\"gnu_message_byname\", 0);\n+\n+  // 2\n+  gnu_facet \t\t\tobj28;\n+}\n+\n+int main ()\n+{\n+  test01();\n+\n+  return 0;\n+}\n+\n+\n+\n+\n+\n+\n+\n+"}]}