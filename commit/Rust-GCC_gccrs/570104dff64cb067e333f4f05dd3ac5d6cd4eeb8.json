{"sha": "570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcwMTA0ZGZmNjRjYjA2N2UzMzNmNGYwNWRkM2FjNWQ2Y2Q0ZWViOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-12-05T10:38:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-12-05T10:38:36Z"}, "message": "[multiple changes]\n\n2012-12-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_eval.adb: Remove spurious warnings.\n\n2012-12-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Build_Explicit_Dereference): Set properly\n\tthe type of the prefix prior to rewriting, because subsequent\n\tlegality checks examine the original node.\n\n2012-12-05  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb: Add Contract_Cases to the canonical aspects map.\n\t* aspects.ads: Add aspect Contract_Cases in the various aspect\n\ttables.\n\t* par-prag.adb: The parser does not need to perform special\n\tactions for pragma Contract_Cases.\n\t* sem_ch6.adb (Expand_Contract_Cases): New routine.\n\t(Process_Contract_Cases): Convert pragma Contract_Cases into pre-\n\tand post- condition checks that verify the runtime state of all\n\tcase guards and their corresponding consequences.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Perform\n\tvarious legality checks on aspect Contract_Cases. The aspect is\n\ttransformed into a pragma.\n\t* sem_prag.adb: Add an entry in table Sig_Flags for pragma\n\tContract_Cases.\n\t(Analyze_Pragma): Perform various legality\n\tchecks on pragma Contract_Cases.  The pragma is associated with\n\tthe contract of the related subprogram.\n\t(Chain_CTC): Omit pragma\n\tContract_Cases because it does not introduce a unique case name\n\tand does not follow the syntax of Contract_Case and Test_Case.\n\t* snames.ads-tmpl: Add new name Name_Contract_Cases. Add a\n\tPragma_Id for Contract_Cases.\n\n2012-12-05  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch5.adb: Minor reformatting.\n\n2012-12-05  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_attr.ads: Add an entry for attribute Loop_Entry in the\n\tAttribute_Impl_Def table.\n\n2012-12-05  Bob Duff  <duff@adacore.com>\n\n\t* gnatchop.adb (Read_File): Avoid storage leak, and in most cases avoid\n\tan extra copy of the string.\n\nFrom-SVN: r194199", "tree": {"sha": "2de998890738052a18d601918218650475cb0b05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2de998890738052a18d601918218650475cb0b05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/comments", "author": null, "committer": null, "parents": [{"sha": "e8e581cd1971c7e86a7f06ac84e562e3d278f5e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e581cd1971c7e86a7f06ac84e562e3d278f5e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8e581cd1971c7e86a7f06ac84e562e3d278f5e4"}], "stats": {"total": 833, "additions": 815, "deletions": 18}, "files": [{"sha": "0443c11260fdc845bff92c8b666ffb72b2c036cd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -1,3 +1,52 @@\n+2012-12-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_eval.adb: Remove spurious warnings.\n+\n+2012-12-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Build_Explicit_Dereference): Set properly\n+\tthe type of the prefix prior to rewriting, because subsequent\n+\tlegality checks examine the original node.\n+\n+2012-12-05  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb: Add Contract_Cases to the canonical aspects map.\n+\t* aspects.ads: Add aspect Contract_Cases in the various aspect\n+\ttables.\n+\t* par-prag.adb: The parser does not need to perform special\n+\tactions for pragma Contract_Cases.\n+\t* sem_ch6.adb (Expand_Contract_Cases): New routine.\n+\t(Process_Contract_Cases): Convert pragma Contract_Cases into pre-\n+\tand post- condition checks that verify the runtime state of all\n+\tcase guards and their corresponding consequences.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Perform\n+\tvarious legality checks on aspect Contract_Cases. The aspect is\n+\ttransformed into a pragma.\n+\t* sem_prag.adb: Add an entry in table Sig_Flags for pragma\n+\tContract_Cases.\n+\t(Analyze_Pragma): Perform various legality\n+\tchecks on pragma Contract_Cases.  The pragma is associated with\n+\tthe contract of the related subprogram.\n+\t(Chain_CTC): Omit pragma\n+\tContract_Cases because it does not introduce a unique case name\n+\tand does not follow the syntax of Contract_Case and Test_Case.\n+\t* snames.ads-tmpl: Add new name Name_Contract_Cases. Add a\n+\tPragma_Id for Contract_Cases.\n+\n+2012-12-05  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch5.adb: Minor reformatting.\n+\n+2012-12-05  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_attr.ads: Add an entry for attribute Loop_Entry in the\n+\tAttribute_Impl_Def table.\n+\n+2012-12-05  Bob Duff  <duff@adacore.com>\n+\n+\t* gnatchop.adb (Read_File): Avoid storage leak, and in most cases avoid\n+\tan extra copy of the string.\n+\n 2012-12-05  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch5.adb (Preanalyze_Range): If the expression, which"}, {"sha": "e3e7571758012f1f2091d5c39a7c0ac58c5969ec", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -252,6 +252,7 @@ package body Aspects is\n     Aspect_Component_Size               => Aspect_Component_Size,\n     Aspect_Constant_Indexing            => Aspect_Constant_Indexing,\n     Aspect_Contract_Case                => Aspect_Contract_Case,\n+    Aspect_Contract_Cases               => Aspect_Contract_Cases,\n     Aspect_Convention                   => Aspect_Convention,\n     Aspect_CPU                          => Aspect_CPU,\n     Aspect_Default_Component_Value      => Aspect_Default_Component_Value,"}, {"sha": "d79252baebf244949cf57575a5d57a43dc650968", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -81,6 +81,7 @@ package Aspects is\n       Aspect_Component_Size,\n       Aspect_Constant_Indexing,\n       Aspect_Contract_Case,                 -- GNAT\n+      Aspect_Contract_Cases,                -- GNAT\n       Aspect_Convention,\n       Aspect_CPU,\n       Aspect_Default_Component_Value,\n@@ -223,6 +224,7 @@ package Aspects is\n                              Aspect_Ada_2012                 => True,\n                              Aspect_Compiler_Unit            => True,\n                              Aspect_Contract_Case            => True,\n+                             Aspect_Contract_Cases           => True,\n                              Aspect_Dimension                => True,\n                              Aspect_Dimension_System         => True,\n                              Aspect_Favor_Top_Level          => True,\n@@ -254,9 +256,10 @@ package Aspects is\n    --  the same aspect attached to the same declaration are allowed.\n \n    No_Duplicates_Allowed : constant array (Aspect_Id) of Boolean :=\n-                             (Aspect_Contract_Case => False,\n-                              Aspect_Test_Case     => False,\n-                              others               => True);\n+                             (Aspect_Contract_Case  => False,\n+                              Aspect_Contract_Cases => False,\n+                              Aspect_Test_Case      => False,\n+                              others                => True);\n \n    --  The following array indicates type aspects that are inherited and apply\n    --  to the class-wide type as well.\n@@ -309,6 +312,7 @@ package Aspects is\n                         Aspect_Component_Size          => Expression,\n                         Aspect_Constant_Indexing       => Name,\n                         Aspect_Contract_Case           => Expression,\n+                        Aspect_Contract_Cases          => Expression,\n                         Aspect_Convention              => Name,\n                         Aspect_CPU                     => Expression,\n                         Aspect_Default_Component_Value => Expression,\n@@ -379,6 +383,7 @@ package Aspects is\n      Aspect_Component_Size               => Name_Component_Size,\n      Aspect_Constant_Indexing            => Name_Constant_Indexing,\n      Aspect_Contract_Case                => Name_Contract_Case,\n+     Aspect_Contract_Cases               => Name_Contract_Cases,\n      Aspect_Convention                   => Name_Convention,\n      Aspect_CPU                          => Name_CPU,\n      Aspect_Default_Iterator             => Name_Default_Iterator,"}, {"sha": "0969c53135c9f8f2793f2683b698d1cc90967573", "filename": "gcc/ada/gnatchop.adb", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fgnatchop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fgnatchop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatchop.adb?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1004,7 +1004,7 @@ procedure Gnatchop is\n    is\n       Length      : constant File_Offset := File_Offset (File_Length (FD));\n       --  Include room for EOF char\n-      Buffer      : constant String_Access := new String (1 .. Length + 1);\n+      Buffer      : String_Access := new String (1 .. Length + 1);\n \n       This_Read   : Integer;\n       Read_Ptr    : File_Offset := 1;\n@@ -1020,8 +1020,15 @@ procedure Gnatchop is\n       end loop;\n \n       Buffer (Read_Ptr) := EOF;\n-      Contents := new String (1 .. Read_Ptr);\n-      Contents.all := Buffer (1 .. Read_Ptr);\n+\n+      if Read_Ptr = Length then\n+         Contents := Buffer;\n+\n+      else\n+         Contents := new String (1 .. Read_Ptr);\n+         Contents.all := Buffer (1 .. Read_Ptr);\n+         Free (Buffer);\n+      end if;\n \n       --  Things aren't simple on VMS due to the plethora of file types and\n       --  organizations. It seems clear that there shouldn't be more bytes"}, {"sha": "73a2fe40a261319d4f913a87f7f1b283227267d3", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -1112,6 +1112,7 @@ begin\n            Pragma_Compile_Time_Warning           |\n            Pragma_Compiler_Unit                  |\n            Pragma_Contract_Case                  |\n+           Pragma_Contract_Cases                 |\n            Pragma_Convention_Identifier          |\n            Pragma_CPP_Class                      |\n            Pragma_CPP_Constructor                |"}, {"sha": "b993b9bab82638486de27382fa09ad06171bc738", "filename": "gcc/ada/sem_attr.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.ads?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -312,6 +312,11 @@ package Sem_Attr is\n       --  the coding standards in use), but logically no initialization is\n       --  needed, and the value should never be accessed.\n \n+      Attribute_Loop_Entry => True,\n+      --  For every object of a non-limited type, S'Loop_Entry { (Loop_Name) }\n+      --  denotes the constant value of prefix S at the point of entry into the\n+      --  related loop. The type of the attribute is the type of the prefix.\n+\n       ------------------\n       -- Machine_Size --\n       ------------------"}, {"sha": "b5acf08e073032124c9968a1700f4970a9c2b632", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 80, "deletions": 4, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -1629,14 +1629,89 @@ package body Sem_Ch13 is\n \n                      Aitem :=\n                        Make_Pragma (Loc,\n-                                    Pragma_Identifier            =>\n-                                      Make_Identifier (Sloc (Id), Nam),\n-                                    Pragma_Argument_Associations =>\n-                                      Args);\n+                         Pragma_Identifier            =>\n+                           Make_Identifier (Sloc (Id), Nam),\n+                         Pragma_Argument_Associations => Args);\n \n                      Delay_Required := False;\n                   end;\n \n+               when Aspect_Contract_Cases => Contract_Cases : declare\n+                  Case_Guard  : Node_Id;\n+                  Extra       : Node_Id;\n+                  Others_Seen : Boolean := False;\n+                  Post_Case   : Node_Id;\n+\n+               begin\n+                  if Nkind (Parent (N)) = N_Compilation_Unit then\n+                     Error_Msg_Name_1 := Nam;\n+                     Error_Msg_N (\"incorrect placement of aspect `%`\", E);\n+                     goto Continue;\n+                  end if;\n+\n+                  if Nkind (Expr) /= N_Aggregate then\n+                     Error_Msg_Name_1 := Nam;\n+                     Error_Msg_NE\n+                       (\"wrong syntax for aspect `%` for &\", Id, E);\n+                     goto Continue;\n+                  end if;\n+\n+                  --  Verify the legality of individual post cases\n+\n+                  Post_Case := First (Component_Associations (Expr));\n+                  while Present (Post_Case) loop\n+                     if Nkind (Post_Case) /= N_Component_Association then\n+                        Error_Msg_N (\"wrong syntax in post case\", Post_Case);\n+                        goto Continue;\n+                     end if;\n+\n+                     --  Each post case must have exactly one case guard\n+\n+                     Case_Guard := First (Choices (Post_Case));\n+                     Extra      := Next (Case_Guard);\n+\n+                     if Present (Extra) then\n+                        Error_Msg_N\n+                          (\"post case may have only one case guard\", Extra);\n+                        goto Continue;\n+                     end if;\n+\n+                     --  Check the placement of \"others\" (if available)\n+\n+                     if Nkind (Case_Guard) = N_Others_Choice then\n+                        if Others_Seen then\n+                           Error_Msg_Name_1 := Nam;\n+                           Error_Msg_N\n+                             (\"only one others choice allowed in aspect %\",\n+                              Case_Guard);\n+                           goto Continue;\n+                        else\n+                           Others_Seen := True;\n+                        end if;\n+\n+                     elsif Others_Seen then\n+                        Error_Msg_Name_1 := Nam;\n+                        Error_Msg_N\n+                          (\"others must be the last choice in aspect %\", N);\n+                        goto Continue;\n+                     end if;\n+\n+                     Next (Post_Case);\n+                  end loop;\n+\n+                  --  Transform the aspect into a pragma\n+\n+                  Aitem :=\n+                    Make_Pragma (Loc,\n+                      Pragma_Identifier            =>\n+                        Make_Identifier (Loc, Nam),\n+                      Pragma_Argument_Associations => New_List (\n+                        Make_Pragma_Argument_Association (Loc,\n+                          Expression => Relocate_Node (Expr))));\n+\n+                  Delay_Required := False;\n+               end Contract_Cases;\n+\n                --  Case 5: Special handling for aspects with an optional\n                --  boolean argument.\n \n@@ -6764,6 +6839,7 @@ package body Sem_Ch13 is\n          --  Here is the list of aspects that don't require delay analysis.\n \n          when Aspect_Contract_Case        |\n+              Aspect_Contract_Cases       |\n               Aspect_Dimension            |\n               Aspect_Dimension_System     |\n               Aspect_Implicit_Dereference |"}, {"sha": "a16e01e2be85aa72737d21c919c9b9d926baff17", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -3049,15 +3049,15 @@ package body Sem_Ch5 is\n          if Is_Discrete_Type (Typ) then\n             null;\n \n-         --  Check that the resulting object is an iterable container.\n+         --  Check that the resulting object is an iterable container\n \n          elsif Present (Find_Aspect (Typ, Aspect_Iterator_Element))\n            or else Present (Find_Aspect (Typ, Aspect_Constant_Indexing))\n            or else Present (Find_Aspect (Typ, Aspect_Variable_Indexing))\n          then\n             null;\n \n-         --  The expression may yield an implcit reference to an iterable\n+         --  The expression may yield an implicit reference to an iterable\n          --  container. Insert explicit dereference so that proper type is\n          --  visible in the loop.\n "}, {"sha": "22feaebedc4e67ddb124e497d1712a5d6f8e6f42", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 462, "deletions": 1, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -11139,6 +11139,11 @@ package body Sem_Ch6 is\n       --  under the same visibility conditions as for other invariant checks,\n       --  the type invariant must be applied to the returned value.\n \n+      procedure Expand_Contract_Cases (CCs : Node_Id; Subp_Id : Entity_Id);\n+      --  Given pragma Contract_Cases CCs, create the circuitry needed to\n+      --  evaluate case guards and trigger consequence expressions. Subp_Id\n+      --  denotes the related subprogram.\n+\n       function Grab_CC return Node_Id;\n       --  Prag contains an analyzed contract case pragma. This function copies\n       --  relevant components of the pragma, creates the corresponding Check\n@@ -11206,6 +11211,459 @@ package body Sem_Ch6 is\n          end if;\n       end Check_Access_Invariants;\n \n+      ---------------------------\n+      -- Expand_Contract_Cases --\n+      ---------------------------\n+\n+      --  Pragma Contract_Cases is expanded in the following manner:\n+\n+      --    subprogram S is\n+      --       Flag_1   : Boolean := False;\n+      --       . . .\n+      --       Flag_N   : Boolean := False;\n+      --       Flag_N+1 : Boolean := False;  --  when \"others\" present\n+      --       Count    : Natural := 0;\n+\n+      --       <preconditions (if any)>\n+\n+      --       if Case_Guard_1 then\n+      --          Flag_1 := True;\n+      --          Count  := Count + 1;\n+      --       end if;\n+      --       . . .\n+      --       if Case_Guard_N then\n+      --          Flag_N := True;\n+      --          Count  := Count + 1;\n+      --       end if;\n+\n+      --       if Count = 0 then\n+      --          raise Assertion_Error with \"contract cases incomplete\";\n+      --            <or>\n+      --          Flag_N+1 := True;  --  when \"others\" present\n+\n+      --       elsif Count > 1 then\n+      --          declare\n+      --             Str0 : constant String :=\n+      --                      \"contract cases overlap for subprogram ABC\";\n+      --             Str1 : constant String :=\n+      --                      (if Flag_1 then\n+      --                         Str0 & \"case guard at xxx evaluates to True\"\n+      --                       else Str0);\n+      --             StrN : constant String :=\n+      --                      (if Flag_N then\n+      --                         StrN-1 & \"case guard at xxx evaluates to True\"\n+      --                       else StrN-1);\n+      --          begin\n+      --             raise Assertion_Error with StrN;\n+      --          end;\n+      --       end if;\n+\n+      --       procedure _Postconditions is\n+      --       begin\n+      --          <postconditions (if any)>\n+\n+      --          if Flag_1 and then not Consequence_1 then\n+      --             raise Assertion_Error with \"failed contract case at xxx\";\n+      --          end if;\n+      --          . . .\n+      --          if Flag_N[+1] and then not Consequence_N[+1] then\n+      --             raise Assertion_Error with \"failed contract case at xxx\";\n+      --          end if;\n+      --       end _Postconditions;\n+      --    begin\n+      --       . . .\n+      --    end S;\n+\n+      procedure Expand_Contract_Cases (CCs : Node_Id; Subp_Id : Entity_Id) is\n+         Loc : constant Source_Ptr := Sloc (CCs);\n+\n+         procedure Case_Guard_Error\n+           (Decls     : List_Id;\n+            Flag      : Entity_Id;\n+            Error_Loc : Source_Ptr;\n+            Msg       : in out Entity_Id);\n+         --  Given a declarative list Decls, status flag Flag, the location of\n+         --  the error and a string Msg, construct the following check:\n+         --    Msg : constant String :=\n+         --            (if Flag then\n+         --                Msg & \"case guard at Error_Loc evaluates to True\"\n+         --             else Msg);\n+         --  The resulting code is added to Decls\n+\n+         procedure Consequence_Error\n+           (Checks : in out Node_Id;\n+            Flag   : Entity_Id;\n+            Conseq : Node_Id);\n+         --  Given an if statement Checks, status flag Flag and a consequence\n+         --  Conseq, construct the following check:\n+         --    [els]if Flag and then not Conseq then\n+         --       raise Assertion_Error\n+         --         with \"failed contract case at Sloc (Conseq)\";\n+         --    [end if;]\n+         --  The resulting code is added to Checks\n+\n+         function Declaration_Of (Id : Entity_Id) return Node_Id;\n+         --  Given the entity Id of a boolean flag, generate:\n+         --    Id : Boolean := False;\n+\n+         function Increment (Id : Entity_Id) return Node_Id;\n+         --  Given the entity Id of a numerical variable, generate:\n+         --    Id := Id + 1;\n+\n+         function Set (Id : Entity_Id) return Node_Id;\n+         --  Given the entity Id of a boolean variable, generate:\n+         --    Id := True;\n+\n+         ----------------------\n+         -- Case_Guard_Error --\n+         ----------------------\n+\n+         procedure Case_Guard_Error\n+           (Decls     : List_Id;\n+            Flag      : Entity_Id;\n+            Error_Loc : Source_Ptr;\n+            Msg       : in out Entity_Id)\n+         is\n+            New_Line : constant Character := Character'Val (10);\n+            New_Msg  : constant Entity_Id := Make_Temporary (Loc, 'S');\n+\n+         begin\n+            Start_String;\n+            Store_String_Char  (New_Line);\n+            Store_String_Chars (\"  case guard at \");\n+            Store_String_Chars (Build_Location_String (Error_Loc));\n+            Store_String_Chars (\" evaluates to True\");\n+\n+            --  Generate:\n+            --    New_Msg : constant String :=\n+            --      (if Flag then\n+            --          Msg & \"case guard at Error_Loc evaluates to True\"\n+            --       else Msg);\n+\n+            Append_To (Decls,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => New_Msg,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Reference_To (Standard_String, Loc),\n+                Expression          =>\n+                  Make_If_Expression (Loc,\n+                    Expressions => New_List (\n+                      New_Reference_To (Flag, Loc),\n+\n+                      Make_Op_Concat (Loc,\n+                        Left_Opnd  => New_Reference_To (Msg, Loc),\n+                        Right_Opnd => Make_String_Literal (Loc, End_String)),\n+\n+                      New_Reference_To (Msg, Loc)))));\n+\n+            Msg := New_Msg;\n+         end Case_Guard_Error;\n+\n+         -----------------------\n+         -- Consequence_Error --\n+         -----------------------\n+\n+         procedure Consequence_Error\n+           (Checks : in out Node_Id;\n+            Flag   : Entity_Id;\n+            Conseq : Node_Id)\n+         is\n+            Cond  : Node_Id;\n+            Error : Node_Id;\n+\n+         begin\n+            --  Generate:\n+            --    Flag and then not Conseq\n+\n+            Cond :=\n+              Make_And_Then (Loc,\n+                Left_Opnd  => New_Reference_To (Flag, Loc),\n+                Right_Opnd =>\n+                  Make_Op_Not (Loc,\n+                    Right_Opnd => Relocate_Node (Conseq)));\n+\n+            --  Generate:\n+            --    raise Assertion_Error\n+            --      with \"failed contract case at Sloc (Conseq)\";\n+\n+            Start_String;\n+            Store_String_Chars (\"failed contract case at \");\n+            Store_String_Chars (Build_Location_String (Sloc (Conseq)));\n+\n+            Error :=\n+              Make_Procedure_Call_Statement (Loc,\n+                Name                   =>\n+                  New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n+                Parameter_Associations => New_List (\n+                  Make_String_Literal (Loc, End_String)));\n+\n+            if No (Checks) then\n+               Checks :=\n+                 Make_If_Statement (Loc,\n+                   Condition       => Cond,\n+                   Then_Statements => New_List (Error));\n+\n+            else\n+               if No (Elsif_Parts (Checks)) then\n+                  Set_Elsif_Parts (Checks, New_List);\n+               end if;\n+\n+               Append_To (Elsif_Parts (Checks),\n+                 Make_Elsif_Part (Loc,\n+                   Condition       => Cond,\n+                   Then_Statements => New_List (Error)));\n+            end if;\n+         end Consequence_Error;\n+\n+         --------------------\n+         -- Declaration_Of --\n+         --------------------\n+\n+         function Declaration_Of (Id : Entity_Id) return Node_Id is\n+         begin\n+            return\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Id,\n+                Object_Definition   =>\n+                  New_Reference_To (Standard_Boolean, Loc),\n+                Expression          =>\n+                  New_Reference_To (Standard_False, Loc));\n+         end Declaration_Of;\n+\n+         ---------------\n+         -- Increment --\n+         ---------------\n+\n+         function Increment (Id : Entity_Id) return Node_Id is\n+         begin\n+            return\n+              Make_Assignment_Statement (Loc,\n+                Name       => New_Reference_To (Id, Loc),\n+                Expression =>\n+                  Make_Op_Add (Loc,\n+                    Left_Opnd  => New_Reference_To (Id, Loc),\n+                    Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+         end Increment;\n+\n+         ---------\n+         -- Set --\n+         ---------\n+\n+         function Set (Id : Entity_Id) return Node_Id is\n+         begin\n+            return\n+              Make_Assignment_Statement (Loc,\n+                Name       => New_Reference_To (Id, Loc),\n+                Expression => New_Reference_To (Standard_True, Loc));\n+         end Set;\n+\n+         --  Local variables\n+\n+         Aggr          : constant Node_Id :=\n+                           Expression (First\n+                             (Pragma_Argument_Associations (CCs)));\n+         Decls         : constant List_Id := Declarations (N);\n+         Multiple_PCs  : constant Boolean :=\n+                           List_Length (Component_Associations (Aggr)) > 1;\n+         Case_Guard    : Node_Id;\n+         CG_Checks     : Node_Id;\n+         CG_Stmts      : List_Id;\n+         Conseq        : Node_Id;\n+         Conseq_Checks : Node_Id := Empty;\n+         Count         : Entity_Id;\n+         Error_Decls   : List_Id;\n+         Flag          : Entity_Id;\n+         Msg_Str       : Entity_Id;\n+         Others_Flag   : Entity_Id := Empty;\n+         Post_Case     : Node_Id;\n+\n+      --  Start of processing for Expand_Contract_Cases\n+\n+      begin\n+         --  Create the counter which tracks the number of case guards that\n+         --  evaluate to True.\n+\n+         --    Count : Natural := 0;\n+\n+         Count := Make_Temporary (Loc, 'C');\n+\n+         Prepend_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Count,\n+             Object_Definition   => New_Reference_To (Standard_Natural, Loc),\n+             Expression          => Make_Integer_Literal (Loc, 0)));\n+\n+         --  Create the base error message for multiple overlapping case\n+         --  guards.\n+\n+         --    Msg_Str : constant String :=\n+         --                \"contract cases overlap for subprogram Subp_Id\";\n+\n+         if Multiple_PCs then\n+            Msg_Str := Make_Temporary (Loc, 'S');\n+\n+            Start_String;\n+            Store_String_Chars (\"contract cases overlap for subprogram \");\n+            Store_String_Chars (Get_Name_String (Chars (Subp_Id)));\n+\n+            Error_Decls := New_List (\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Msg_Str,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Reference_To (Standard_String, Loc),\n+                Expression          => Make_String_Literal (Loc, End_String)));\n+         end if;\n+\n+         --  Process individual post cases\n+\n+         Post_Case := First (Component_Associations (Aggr));\n+         while Present (Post_Case) loop\n+            Case_Guard := First (Choices (Post_Case));\n+            Conseq     := Expression (Post_Case);\n+\n+            --  The \"others\" choice requires special processing\n+\n+            if Nkind (Case_Guard) = N_Others_Choice then\n+               Others_Flag := Make_Temporary (Loc, 'F');\n+               Prepend_To (Decls, Declaration_Of (Others_Flag));\n+\n+               --  Check possible overlap between a case guard and \"others\"\n+\n+               if Multiple_PCs then\n+                  Case_Guard_Error\n+                    (Decls     => Error_Decls,\n+                     Flag      => Others_Flag,\n+                     Error_Loc => Sloc (Case_Guard),\n+                     Msg       => Msg_Str);\n+               end if;\n+\n+               --  Check the corresponding consequence of \"others\"\n+\n+               Consequence_Error\n+                 (Checks => Conseq_Checks,\n+                  Flag   => Others_Flag,\n+                  Conseq => Conseq);\n+\n+            --  Regular post case\n+\n+            else\n+               --  Create the flag which tracks the state of its associated\n+               --  case guard.\n+\n+               Flag := Make_Temporary (Loc, 'F');\n+               Prepend_To (Decls, Declaration_Of (Flag));\n+\n+               --  The flag is set when the case guard is evaluated to True\n+               --    if Case_Guard then\n+               --       Flag  := True;\n+               --       Count := Count + 1;\n+               --    end if;\n+\n+               Append_To (Decls,\n+                 Make_If_Statement (Loc,\n+                   Condition       => Relocate_Node (Case_Guard),\n+                   Then_Statements => New_List (\n+                     Set (Flag),\n+                     Increment (Count))));\n+\n+               --  Check whether this case guard overlaps with another case\n+               --  guard.\n+\n+               if Multiple_PCs then\n+                  Case_Guard_Error\n+                    (Decls     => Error_Decls,\n+                     Flag      => Flag,\n+                     Error_Loc => Sloc (Case_Guard),\n+                     Msg       => Msg_Str);\n+               end if;\n+\n+               --  The corresponding consequence of the case guard which\n+               --  evaluated to True must hold on exit from the subprogram.\n+\n+               Consequence_Error (Conseq_Checks, Flag, Conseq);\n+            end if;\n+\n+            Next (Post_Case);\n+         end loop;\n+\n+         --  Raise Assertion_Error when none of the case guards evaluate to\n+         --  True. The only exception is when we have \"others\", in which case\n+         --  there is no error because \"others\" acts as a default True.\n+\n+         --  Generate:\n+         --    Flag := True;\n+\n+         if Present (Others_Flag) then\n+            CG_Stmts := New_List (Set (Others_Flag));\n+\n+         --  Generate:\n+         --    raise Assetion_Error with \"contract cases incomplete\";\n+\n+         else\n+            Start_String;\n+            Store_String_Chars (\"contract cases incomplete\");\n+\n+            CG_Stmts := New_List (\n+              Make_Procedure_Call_Statement (Loc,\n+                Name                   =>\n+                  New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n+                Parameter_Associations => New_List (\n+                  Make_String_Literal (Loc, End_String))));\n+         end if;\n+\n+         CG_Checks :=\n+           Make_If_Statement (Loc,\n+             Condition       =>\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd  => New_Reference_To (Count, Loc),\n+                 Right_Opnd => Make_Integer_Literal (Loc, 0)),\n+             Then_Statements => CG_Stmts);\n+\n+         --  Detect a possible failure due to several case guards evaluating to\n+         --  True.\n+\n+         --  Generate:\n+         --    elsif Count > 0 then\n+         --       declare\n+         --          <Error_Decls>\n+         --       begin\n+         --          raise Assertion_Error with <Msg_Str>;\n+         --    end if;\n+\n+         if Multiple_PCs then\n+            Set_Elsif_Parts (CG_Checks, New_List (\n+              Make_Elsif_Part (Loc,\n+                Condition       =>\n+                  Make_Op_Gt (Loc,\n+                    Left_Opnd  => New_Reference_To (Count, Loc),\n+                    Right_Opnd => Make_Integer_Literal (Loc, 1)),\n+\n+                Then_Statements => New_List (\n+                  Make_Block_Statement (Loc,\n+                    Declarations               => Error_Decls,\n+                    Handled_Statement_Sequence =>\n+                      Make_Handled_Sequence_Of_Statements (Loc,\n+                        Statements => New_List (\n+                          Make_Procedure_Call_Statement (Loc,\n+                            Name                   =>\n+                              New_Reference_To\n+                                (RTE (RE_Raise_Assert_Failure), Loc),\n+                            Parameter_Associations => New_List (\n+                              New_Reference_To (Msg_Str, Loc))))))))));\n+         end if;\n+\n+         Append_To (Decls, CG_Checks);\n+\n+         --  Raise Assertion_Error when the corresponding consequence of a case\n+         --  guard that evaluated to True fails.\n+\n+         if No (Plist) then\n+            Plist := New_List;\n+         end if;\n+\n+         Append_To (Plist, Conseq_Checks);\n+      end Expand_Contract_Cases;\n+\n       -------------\n       -- Grab_CC --\n       -------------\n@@ -11736,6 +12194,9 @@ package body Sem_Ch6 is\n                      else\n                         Append (Grab_CC, Plist);\n                      end if;\n+\n+                  elsif Pragma_Name (Prag) = Name_Contract_Cases then\n+                     Expand_Contract_Cases (Prag, Spec_Id);\n                   end if;\n \n                   Prag := Next_Pragma (Prag);\n@@ -11850,7 +12311,7 @@ package body Sem_Ch6 is\n                     Make_Invariant_Call (New_Occurrence_Of (Rent, Loc)));\n                end if;\n \n-               --  Same if return value is an access to type with invariants.\n+               --  Same if return value is an access to type with invariants\n \n                Check_Access_Invariants (Rent);\n             end;"}, {"sha": "4a8fa2c627f8d4f33ef98af185adab6889f48150", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -1314,11 +1314,22 @@ package body Sem_Eval is\n       --  is at optimizing and knowing that things are constant when they are\n       --  nonstatic.\n \n+      --  We make an exception for expressions that evaluate to True/False, to\n+      --  suppress spurious checks in ZFP mode.\n+\n       if Configurable_Run_Time_Mode\n         and then K /= N_Null\n         and then not Is_Static_Expression (Op)\n       then\n-         return False;\n+         if Is_Entity_Name (Op)\n+           and then Ekind (Entity (Op)) = E_Enumeration_Literal\n+           and then Etype (Entity (Op)) = Standard_Boolean\n+         then\n+            null;\n+\n+         else\n+            return False;\n+         end if;\n       end if;\n \n       --  If we have an entity name, then see if it is the name of a constant"}, {"sha": "e4ee1f6409a80b7dabebadefa03c21b89a4aa219", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 172, "deletions": 1, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -1499,7 +1499,17 @@ package body Sem_Prag is\n             begin\n                CTC := Spec_CTC_List (Contract (S));\n                while Present (CTC) loop\n-                  if String_Equal (Name, Get_Name_From_CTC_Pragma (CTC)) then\n+\n+                  --  Omit pragma Contract_Cases because it does not introduce\n+                  --  a unique case name and it does not follow the syntax of\n+                  --  Contract_Case and Test_Case.\n+\n+                  if Pragma_Name (CTC) = Name_Contract_Cases then\n+                     null;\n+\n+                  elsif String_Equal\n+                          (Name, Get_Name_From_CTC_Pragma (CTC))\n+                  then\n                      Error_Msg_Sloc := Sloc (CTC);\n                      Error_Pragma (\"name for pragma% is already used#\");\n                   end if;\n@@ -7705,6 +7715,166 @@ package body Sem_Prag is\n          when Pragma_Contract_Case =>\n             Check_Contract_Or_Test_Case;\n \n+         --------------------\n+         -- Contract_Cases --\n+         --------------------\n+\n+         --  pragma Contract_Cases (POST_CASE_LIST);\n+\n+         --  POST_CASE_LIST ::= POST_CASE {, POST_CASE}\n+\n+         --  POST_CASE ::= CASE_GUARD => CONSEQUENCE\n+\n+         --  CASE_GUARD ::= boolean_EXPRESSION | others\n+\n+         --  CONSEQUENCE ::= boolean_EXPRESSION\n+\n+         when Pragma_Contract_Cases => Contract_Cases : declare\n+            procedure Chain_Contract_Cases (Subp_Decl : Node_Id);\n+            --  Chain pragma Contract_Cases to the contract of a subprogram.\n+            --  Subp_Decl is the declaration of the subprogram.\n+\n+            --------------------------\n+            -- Chain_Contract_Cases --\n+            --------------------------\n+\n+            procedure Chain_Contract_Cases (Subp_Decl : Node_Id) is\n+               Subp : constant Entity_Id :=\n+                        Defining_Unit_Name (Specification (Subp_Decl));\n+               CTC  : Node_Id;\n+\n+            begin\n+               CTC := Spec_CTC_List (Contract (Subp));\n+               while Present (CTC) loop\n+                  if Chars (Pragma_Identifier (CTC)) = Pname then\n+                     Error_Pragma (\"pragma % already in use\");\n+                     return;\n+                  end if;\n+\n+                  CTC := Next_Pragma (CTC);\n+               end loop;\n+\n+               --  Prepend pragma Contract_Cases to the contract\n+\n+               Set_Next_Pragma (N, Spec_CTC_List (Contract (Subp)));\n+               Set_Spec_CTC_List (Contract (Subp), N);\n+            end Chain_Contract_Cases;\n+\n+            --  Local variables\n+\n+            Case_Guard  : Node_Id;\n+            Decl        : Node_Id;\n+            Extra       : Node_Id;\n+            Others_Seen : Boolean := False;\n+            Post_Case   : Node_Id;\n+            Subp_Decl   : Node_Id;\n+\n+         --  Start of processing for Contract_Cases\n+\n+         begin\n+            GNAT_Pragma;\n+            S14_Pragma;\n+            Check_Arg_Count (1);\n+\n+            --  Completely ignore if disabled\n+\n+            if Check_Disabled (Pname) then\n+               Rewrite (N, Make_Null_Statement (Loc));\n+               Analyze (N);\n+               return;\n+            end if;\n+\n+            --  Check the placement of the pragma\n+\n+            if not Is_List_Member (N) then\n+               Pragma_Misplaced;\n+            end if;\n+\n+            --  Pragma Contract_Cases must be associated with a subprogram\n+\n+            Decl := N;\n+            while Present (Prev (Decl)) loop\n+               Decl := Prev (Decl);\n+\n+               if Nkind (Decl) in N_Generic_Declaration then\n+                  Subp_Decl := Decl;\n+               else\n+                  Subp_Decl := Original_Node (Decl);\n+               end if;\n+\n+               --  Skip prior pragmas\n+\n+               if Nkind (Subp_Decl) = N_Pragma then\n+                  null;\n+\n+               --  Skip internally generated code\n+\n+               elsif not Comes_From_Source (Subp_Decl) then\n+                  null;\n+\n+               --  We have found the related subprogram\n+\n+               elsif Nkind_In (Subp_Decl, N_Generic_Subprogram_Declaration,\n+                                          N_Subprogram_Declaration)\n+               then\n+                  exit;\n+\n+               else\n+                  Pragma_Misplaced;\n+               end if;\n+            end loop;\n+\n+            --  All post cases must appear as an aggregate\n+\n+            if Nkind (Expression (Arg1)) /= N_Aggregate then\n+               Error_Pragma (\"wrong syntax for pragma %\");\n+               return;\n+            end if;\n+\n+            --  Verify the legality of individual post cases\n+\n+            Post_Case := First (Component_Associations (Expression (Arg1)));\n+            while Present (Post_Case) loop\n+               if Nkind (Post_Case) /= N_Component_Association then\n+                  Error_Pragma_Arg (\"wrong syntax in post case\", Post_Case);\n+                  return;\n+               end if;\n+\n+               Case_Guard := First (Choices (Post_Case));\n+\n+               --  Each post case must have exactly on case guard\n+\n+               Extra := Next (Case_Guard);\n+               if Present (Extra) then\n+                  Error_Pragma_Arg\n+                    (\"post case may have only one case guard\", Extra);\n+                  return;\n+               end if;\n+\n+               --  Check the placement of \"others\" (if available)\n+\n+               if Nkind (Case_Guard) = N_Others_Choice then\n+                  if Others_Seen then\n+                     Error_Pragma_Arg\n+                       (\"only one others choice allowed in pragma %\",\n+                        Case_Guard);\n+                     return;\n+                  else\n+                     Others_Seen := True;\n+                  end if;\n+\n+               elsif Others_Seen then\n+                  Error_Pragma_Arg\n+                    (\"others must be the last choice in pragma %\", N);\n+                  return;\n+               end if;\n+\n+               Next (Post_Case);\n+            end loop;\n+\n+            Chain_Contract_Cases (Subp_Decl);\n+         end Contract_Cases;\n+\n          ----------------\n          -- Controlled --\n          ----------------\n@@ -15468,6 +15638,7 @@ package body Sem_Prag is\n       Pragma_Complex_Representation         =>  0,\n       Pragma_Component_Alignment            => -1,\n       Pragma_Contract_Case                  => -1,\n+      Pragma_Contract_Cases                 => -1,\n       Pragma_Controlled                     =>  0,\n       Pragma_Convention                     =>  0,\n       Pragma_Convention_Identifier          =>  0,"}, {"sha": "7d3215e59c36d2d1004328151c7d91f27aec8073", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -1100,13 +1100,17 @@ package body Sem_Util is\n       Loc : constant Source_Ptr := Sloc (Expr);\n    begin\n \n-      --  An entity of a type with implicit dereference is overloaded with\n+      --  An entity of a type with a reference aspect is overloaded with\n       --  both interpretations: with and without the dereference. Now that\n       --  the dereference is made explicit, set the type of the node properly,\n-      --  to prevent anomalies in the backend.\n+      --  to prevent anomalies in the backend. Same if the expression is an\n+      --  overloaded function call whose return type has a reference aspect.\n \n       if Is_Entity_Name (Expr) then\n          Set_Etype (Expr, Etype (Entity (Expr)));\n+\n+      elsif Nkind (Expr) = N_Function_Call then\n+         Set_Etype (Expr, Etype (Name (Expr)));\n       end if;\n \n       Set_Is_Overloaded (Expr, False);\n@@ -9335,6 +9339,8 @@ package body Sem_Util is\n                loop\n                   --  If no matching formal, that's peculiar, some kind of\n                   --  previous error, so return False to be conservative.\n+                  --  Actually this also happens in legal code in the case\n+                  --  where P is a parameter association for an Extra_Formal???\n \n                   if No (Form) then\n                      return False;\n@@ -9640,6 +9646,8 @@ package body Sem_Util is\n                loop\n                   --  If no matching formal, that's peculiar, some kind of\n                   --  previous error, so return True to be conservative.\n+                  --  Actually happens with legal code for an unresolved call\n+                  --  where we may get the wrong homonym???\n \n                   if No (Form) then\n                      return True;"}, {"sha": "3b3f8dbfa04631c16fba8eac9936d0ad12149e47", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570104dff64cb067e333f4f05dd3ac5d6cd4eeb8/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=570104dff64cb067e333f4f05dd3ac5d6cd4eeb8", "patch": "@@ -463,6 +463,7 @@ package Snames is\n    Name_Complete_Representation        : constant Name_Id := N + $; -- GNAT\n    Name_Complex_Representation         : constant Name_Id := N + $; -- GNAT\n    Name_Contract_Case                  : constant Name_Id := N + $; -- GNAT\n+   Name_Contract_Cases                 : constant Name_Id := N + $; -- GNAT\n    Name_Controlled                     : constant Name_Id := N + $;\n    Name_Convention                     : constant Name_Id := N + $;\n    Name_CPP_Class                      : constant Name_Id := N + $; -- GNAT\n@@ -1736,6 +1737,7 @@ package Snames is\n       Pragma_Complete_Representation,\n       Pragma_Complex_Representation,\n       Pragma_Contract_Case,\n+      Pragma_Contract_Cases,\n       Pragma_Controlled,\n       Pragma_Convention,\n       Pragma_CPP_Class,"}]}