{"sha": "c94c353225cfa30a351399064ea3f3dc9326e472", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk0YzM1MzIyNWNmYTMwYTM1MTM5OTA2NGVhM2YzZGM5MzI2ZTQ3Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-06-01T21:56:17Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-06-01T21:56:17Z"}, "message": "gimple-ssa-store-merging.c: Include gimple-fold.h.\n\n\t* gimple-ssa-store-merging.c: Include gimple-fold.h.\n\t(struct store_immediate_info): Document BIT_INSERT_EXPR stores.\n\t(struct merged_store_group): Add bit_insertion field.\n\t(dump_char_array): Use standard hexadecimal format.\n\t(merged_store_group::merged_store_group): Set bit_insertion to false.\n\t(merged_store_group::apply_stores): Use optimal buffer size.  Deal\n\twith BIT_INSERT_EXPR stores.  Move up code updating the mask and\n\talso print the mask in the dump file.\n\t(pass_store_merging::gate): Minor tweak.\n\t(imm_store_chain_info::coalesce_immediate): Fix wrong association\n\tof stores with groups in dump.  Allow coalescing of BIT_INSERT_EXPR\n\tstores with INTEGER_CST stores.\n\t(count_multiple_uses) <BIT_INSERT_EXPR>: New case.\n\t(imm_store_chain_info::output_merged_store): Add try_bitpos variable\n\tand use it throughout.  Generate bit insertion sequences if need be.\n\t(pass_store_merging::process_store): Remove redundant condition.\n\tRecord stores from a SSA name to a bit-field with BIT_INSERT_EXPR.\n\nFrom-SVN: r261089", "tree": {"sha": "74f52c0467c0cc3dc782bd91574a854e7c6fec82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74f52c0467c0cc3dc782bd91574a854e7c6fec82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c94c353225cfa30a351399064ea3f3dc9326e472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94c353225cfa30a351399064ea3f3dc9326e472", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c94c353225cfa30a351399064ea3f3dc9326e472", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94c353225cfa30a351399064ea3f3dc9326e472/comments", "author": null, "committer": null, "parents": [{"sha": "3827838d31a149f18fabf8bc5225239a2668b23d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3827838d31a149f18fabf8bc5225239a2668b23d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3827838d31a149f18fabf8bc5225239a2668b23d"}], "stats": {"total": 359, "additions": 286, "deletions": 73}, "files": [{"sha": "427945d5fff3372a8f39f0dec35a716cf1092e80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c94c353225cfa30a351399064ea3f3dc9326e472", "patch": "@@ -1,3 +1,23 @@\n+2018-06-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gimple-ssa-store-merging.c: Include gimple-fold.h.\n+\t(struct store_immediate_info): Document BIT_INSERT_EXPR stores.\n+\t(struct merged_store_group): Add bit_insertion field.\n+\t(dump_char_array): Use standard hexadecimal format.\n+\t(merged_store_group::merged_store_group): Set bit_insertion to false.\n+\t(merged_store_group::apply_stores): Use optimal buffer size.  Deal\n+\twith BIT_INSERT_EXPR stores.  Move up code updating the mask and\n+\talso print the mask in the dump file.\n+\t(pass_store_merging::gate): Minor tweak.\n+\t(imm_store_chain_info::coalesce_immediate): Fix wrong association\n+\tof stores with groups in dump.  Allow coalescing of BIT_INSERT_EXPR\n+\tstores with INTEGER_CST stores.\n+\t(count_multiple_uses) <BIT_INSERT_EXPR>: New case.\n+\t(imm_store_chain_info::output_merged_store): Add try_bitpos variable\n+\tand use it throughout.  Generate bit insertion sequences if need be.\n+\t(pass_store_merging::process_store): Remove redundant condition.\n+\tRecord stores from a SSA name to a bit-field with BIT_INSERT_EXPR.\n+\n 2018-06-01  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.c (rs6000_mangle_type): Change the mangling of"}, {"sha": "3c63e75fcf6ccf3ea6d8d8d3d4f27e3c104e05ae", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 170, "deletions": 73, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=c94c353225cfa30a351399064ea3f3dc9326e472", "patch": "@@ -18,17 +18,18 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n-/* The purpose of the store merging pass is to combine multiple memory\n-   stores of constant values, values loaded from memory or bitwise operations\n-   on those to consecutive memory locations into fewer wider stores.\n+/* The purpose of the store merging pass is to combine multiple memory stores\n+   of constant values, values loaded from memory, bitwise operations on those,\n+   or bit-field values, to consecutive locations, into fewer wider stores.\n+\n    For example, if we have a sequence peforming four byte stores to\n    consecutive memory locations:\n    [p     ] := imm1;\n    [p + 1B] := imm2;\n    [p + 2B] := imm3;\n    [p + 3B] := imm4;\n    we can transform this into a single 4-byte store if the target supports it:\n-  [p] := imm1:imm2:imm3:imm4 //concatenated immediates according to endianness.\n+   [p] := imm1:imm2:imm3:imm4 concatenated according to endianness.\n \n    Or:\n    [p     ] := [q     ];\n@@ -46,12 +47,18 @@\n    if there is no overlap can be transformed into a single 4-byte\n    load, xored with imm1:imm2:imm3:imm4 and stored using a single 4-byte store.\n \n+   Or:\n+   [p:1 ] := imm;\n+   [p:31] := val & 0x7FFFFFFF;\n+   we can transform this into a single 4-byte store if the target supports it:\n+   [p] := imm:(val & 0x7FFFFFFF) concatenated according to endianness.\n+\n    The algorithm is applied to each basic block in three phases:\n \n-   1) Scan through the basic block recording assignments to\n-   destinations that can be expressed as a store to memory of a certain size\n-   at a certain bit offset from expressions we can handle.  For bit-fields\n-   we also note the surrounding bit region, bits that could be stored in\n+   1) Scan through the basic block and record assignments to destinations\n+   that can be expressed as a store to memory of a certain size at a certain\n+   bit offset from base expressions we can handle.  For bit-fields we also\n+   record the surrounding bit region, i.e. bits that could be stored in\n    a read-modify-write operation when storing the bit-field.  Record store\n    chains to different bases in a hash_map (m_stores) and make sure to\n    terminate such chains when appropriate (for example when when the stored\n@@ -60,14 +67,14 @@\n    etc.  A store_immediate_info object is recorded for every such store.\n    Record as many such assignments to a single base as possible until a\n    statement that interferes with the store sequence is encountered.\n-   Each store has up to 2 operands, which can be an immediate constant\n-   or a memory load, from which the value to be stored can be computed.\n+   Each store has up to 2 operands, which can be a either constant, a memory\n+   load or an SSA name, from which the value to be stored can be computed.\n    At most one of the operands can be a constant.  The operands are recorded\n    in store_operand_info struct.\n \n-   2) Analyze the chain of stores recorded in phase 1) (i.e. the vector of\n+   2) Analyze the chains of stores recorded in phase 1) (i.e. the vector of\n    store_immediate_info objects) and coalesce contiguous stores into\n-   merged_store_group objects.  For bit-fields stores, we don't need to\n+   merged_store_group objects.  For bit-field stores, we don't need to\n    require the stores to be contiguous, just their surrounding bit regions\n    have to be contiguous.  If the expression being stored is different\n    between adjacent stores, such as one store storing a constant and\n@@ -91,8 +98,8 @@\n    multiple stores per store group to handle contiguous stores that are not\n    of a size that is a power of 2.  For example it can try to emit a 40-bit\n    store as a 32-bit store followed by an 8-bit store.\n-   We try to emit as wide stores as we can while respecting STRICT_ALIGNMENT or\n-   TARGET_SLOW_UNALIGNED_ACCESS rules.\n+   We try to emit as wide stores as we can while respecting STRICT_ALIGNMENT\n+   or TARGET_SLOW_UNALIGNED_ACCESS settings.\n \n    Note on endianness and example:\n    Consider 2 contiguous 16-bit stores followed by 2 contiguous 8-bit stores:\n@@ -149,6 +156,7 @@\n #include \"tree-hash-traits.h\"\n #include \"gimple-iterator.h\"\n #include \"gimplify.h\"\n+#include \"gimple-fold.h\"\n #include \"stor-layout.h\"\n #include \"timevar.h\"\n #include \"tree-cfg.h\"\n@@ -1309,9 +1317,10 @@ make_pass_optimize_bswap (gcc::context *ctxt)\n namespace {\n \n /* Struct recording one operand for the store, which is either a constant,\n-   then VAL represents the constant and all the other fields are zero,\n-   or a memory load, then VAL represents the reference, BASE_ADDR is non-NULL\n-   and the other fields also reflect the memory load.  */\n+   then VAL represents the constant and all the other fields are zero, or\n+   a memory load, then VAL represents the reference, BASE_ADDR is non-NULL\n+   and the other fields also reflect the memory load, or an SSA name, then\n+   VAL represents the SSA name and all the other fields are zero,  */\n \n struct store_operand_info\n {\n@@ -1345,8 +1354,9 @@ struct store_immediate_info\n   unsigned HOST_WIDE_INT bitregion_end;\n   gimple *stmt;\n   unsigned int order;\n-  /* INTEGER_CST for constant stores, MEM_REF for memory copy or\n-     BIT_*_EXPR for logical bitwise operation.\n+  /* INTEGER_CST for constant stores, MEM_REF for memory copy,\n+     BIT_*_EXPR for logical bitwise operation, BIT_INSERT_EXPR\n+     for bit insertion.\n      LROTATE_EXPR if it can be only bswap optimized and\n      ops are not really meaningful.\n      NOP_EXPR if bswap optimization detected identity, ops\n@@ -1425,6 +1435,7 @@ struct merged_store_group\n   gimple *first_stmt;\n   unsigned char *val;\n   unsigned char *mask;\n+  bool bit_insertion;\n \n   merged_store_group (store_immediate_info *);\n   ~merged_store_group ();\n@@ -1444,7 +1455,7 @@ dump_char_array (FILE *fd, unsigned char *ptr, unsigned int len)\n     return;\n \n   for (unsigned int i = 0; i < len; i++)\n-    fprintf (fd, \"%x \", ptr[i]);\n+    fprintf (fd, \"%02x \", ptr[i]);\n   fprintf (fd, \"\\n\");\n }\n \n@@ -1806,6 +1817,7 @@ merged_store_group::merged_store_group (store_immediate_info *info)\n      width has been finalized.  */\n   val = NULL;\n   mask = NULL;\n+  bit_insertion = false;\n   unsigned HOST_WIDE_INT align_bitpos = 0;\n   get_object_alignment_1 (gimple_assign_lhs (info->stmt),\n \t\t\t  &align, &align_bitpos);\n@@ -1930,10 +1942,8 @@ merged_store_group::apply_stores ()\n   stores.qsort (sort_by_order);\n   store_immediate_info *info;\n   unsigned int i;\n-  /* Create a buffer of a size that is 2 times the number of bytes we're\n-     storing.  That way native_encode_expr can write power-of-2-sized\n-     chunks without overrunning.  */\n-  buf_size = 2 * ((bitregion_end - bitregion_start) / BITS_PER_UNIT);\n+  /* Create a power-of-2-sized buffer for native_encode_expr.  */\n+  buf_size = 1 << ceil_log2 ((bitregion_end - bitregion_start) / BITS_PER_UNIT);\n   val = XNEWVEC (unsigned char, 2 * buf_size);\n   mask = val + buf_size;\n   memset (val, 0, buf_size);\n@@ -1942,38 +1952,49 @@ merged_store_group::apply_stores ()\n   FOR_EACH_VEC_ELT (stores, i, info)\n     {\n       unsigned int pos_in_buffer = info->bitpos - bitregion_start;\n-      tree cst = NULL_TREE;\n+      tree cst;\n       if (info->ops[0].val && info->ops[0].base_addr == NULL_TREE)\n \tcst = info->ops[0].val;\n       else if (info->ops[1].val && info->ops[1].base_addr == NULL_TREE)\n \tcst = info->ops[1].val;\n+      else\n+\tcst = NULL_TREE;\n       bool ret = true;\n       if (cst)\n-\tret = encode_tree_to_bitpos (cst, val, info->bitsize,\n-\t\t\t\t     pos_in_buffer, buf_size);\n+\t{\n+\t  if (info->rhs_code == BIT_INSERT_EXPR)\n+\t    bit_insertion = true;\n+\t  else\n+\t    ret = encode_tree_to_bitpos (cst, val, info->bitsize,\n+\t\t\t\t\t pos_in_buffer, buf_size);\n+\t}\n+      unsigned char *m = mask + (pos_in_buffer / BITS_PER_UNIT);\n+      if (BYTES_BIG_ENDIAN)\n+\tclear_bit_region_be (m, (BITS_PER_UNIT - 1\n+\t\t\t\t - (pos_in_buffer % BITS_PER_UNIT)),\n+\t\t\t     info->bitsize);\n+      else\n+\tclear_bit_region (m, pos_in_buffer % BITS_PER_UNIT, info->bitsize);\n       if (cst && dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  if (ret)\n \t    {\n-\t      fprintf (dump_file, \"After writing \");\n+\t      fputs (\"After writing \", dump_file);\n \t      print_generic_expr (dump_file, cst, 0);\n \t      fprintf (dump_file, \" of size \" HOST_WIDE_INT_PRINT_DEC\n-\t\t       \" at position %d the merged region contains:\\n\",\n-\t\t       info->bitsize, pos_in_buffer);\n+\t\t       \" at position %d\\n\", info->bitsize, pos_in_buffer);\n+\t      fputs (\"  the merged value contains \", dump_file);\n \t      dump_char_array (dump_file, val, buf_size);\n+\t      fputs (\"  the merged mask contains  \", dump_file);\n+\t      dump_char_array (dump_file, mask, buf_size);\n+\t      if (bit_insertion)\n+\t\tfputs (\"  bit insertion is required\\n\", dump_file);\n \t    }\n \t  else\n \t    fprintf (dump_file, \"Failed to merge stores\\n\");\n \t}\n       if (!ret)\n \treturn false;\n-      unsigned char *m = mask + (pos_in_buffer / BITS_PER_UNIT);\n-      if (BYTES_BIG_ENDIAN)\n-\tclear_bit_region_be (m, (BITS_PER_UNIT - 1\n-\t\t\t\t - (pos_in_buffer % BITS_PER_UNIT)),\n-\t\t\t     info->bitsize);\n-      else\n-\tclear_bit_region (m, pos_in_buffer % BITS_PER_UNIT, info->bitsize);\n     }\n   stores.qsort (sort_by_bitpos);\n   return true;\n@@ -2038,14 +2059,14 @@ class pass_store_merging : public gimple_opt_pass\n   {\n   }\n \n-  /* Pass not supported for PDP-endianness, nor for insane hosts\n-     or target character sizes where native_{encode,interpret}_expr\n+  /* Pass not supported for PDP-endian, nor for insane hosts or\n+     target character sizes where native_{encode,interpret}_expr\n      doesn't work properly.  */\n   virtual bool\n   gate (function *)\n   {\n     return flag_store_merging\n-\t   && WORDS_BIG_ENDIAN == BYTES_BIG_ENDIAN\n+\t   && BYTES_BIG_ENDIAN == WORDS_BIG_ENDIAN\n \t   && CHAR_BIT == 8\n \t   && BITS_PER_UNIT == 8;\n   }\n@@ -2586,7 +2607,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n     return false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Attempting to coalesce %u stores in chain.\\n\",\n+    fprintf (dump_file, \"Attempting to coalesce %u stores in chain\\n\",\n \t     m_store_info.length ());\n \n   store_immediate_info *info;\n@@ -2597,20 +2618,13 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \n   info = m_store_info[0];\n   merged_store_group *merged_store = new merged_store_group (info);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fputs (\"New store group\\n\", dump_file);\n \n   FOR_EACH_VEC_ELT (m_store_info, i, info)\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Store %u:\\nbitsize:\" HOST_WIDE_INT_PRINT_DEC\n-\t\t\t      \" bitpos:\" HOST_WIDE_INT_PRINT_DEC \" val:\\n\",\n-\t\t   i, info->bitsize, info->bitpos);\n-\t  print_generic_expr (dump_file, gimple_assign_rhs1 (info->stmt));\n-\t  fprintf (dump_file, \"\\n------------\\n\");\n-\t}\n-\n       if (i <= ignore)\n-\tcontinue;\n+\tgoto done;\n \n       /* First try to handle group of stores like:\n \t p[0] = data >> 24;\n@@ -2636,7 +2650,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t\tmerged_store = new merged_store_group (m_store_info[ignore]);\n \t      else\n \t\tmerged_store = NULL;\n-\t      continue;\n+\t      goto done;\n \t    }\n \t}\n \n@@ -2651,16 +2665,20 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t      && merged_store->stores[0]->rhs_code == INTEGER_CST)\n \t    {\n \t      merged_store->merge_overlapping (info);\n-\t      continue;\n+\t      goto done;\n \t    }\n \t}\n       /* |---store 1---||---store 2---|\n \t This store is consecutive to the previous one.\n \t Merge it into the current store group.  There can be gaps in between\n \t the stores, but there can't be gaps in between bitregions.  */\n-      else if (info->rhs_code != LROTATE_EXPR\n-\t       && info->bitregion_start <= merged_store->bitregion_end\n-\t       && info->rhs_code == merged_store->stores[0]->rhs_code)\n+      else if (info->bitregion_start <= merged_store->bitregion_end\n+\t       && info->rhs_code != LROTATE_EXPR\n+\t       && (info->rhs_code == merged_store->stores[0]->rhs_code\n+\t\t   || (info->rhs_code == INTEGER_CST\n+\t\t       && merged_store->stores[0]->rhs_code == BIT_INSERT_EXPR)\n+\t\t   || (info->rhs_code == BIT_INSERT_EXPR\n+\t\t       && merged_store->stores[0]->rhs_code == INTEGER_CST)))\n \t{\n \t  store_immediate_info *infof = merged_store->stores[0];\n \n@@ -2692,7 +2710,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t\t\t\t\tinfo->bitpos + info->bitsize)))\n \t    {\n \t      merged_store->merge_into (info);\n-\t      continue;\n+\t      goto done;\n \t    }\n \t}\n \n@@ -2702,31 +2720,43 @@ imm_store_chain_info::coalesce_immediate_stores ()\n       /* Try to apply all the stores recorded for the group to determine\n \t the bitpattern they write and discard it if that fails.\n \t This will also reject single-store groups.  */\n-      if (!merged_store->apply_stores ())\n-\tdelete merged_store;\n-      else\n+      if (merged_store->apply_stores ())\n \tm_merged_store_groups.safe_push (merged_store);\n+      else\n+\tdelete merged_store;\n \n       merged_store = new merged_store_group (info);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfputs (\"New store group\\n\", dump_file);\n+\n+    done:\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Store %u:\\nbitsize:\" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t      \" bitpos:\" HOST_WIDE_INT_PRINT_DEC \" val:\",\n+\t\t   i, info->bitsize, info->bitpos);\n+\t  print_generic_expr (dump_file, gimple_assign_rhs1 (info->stmt));\n+\t  fputc ('\\n', dump_file);\n+\t}\n     }\n \n   /* Record or discard the last store group.  */\n   if (merged_store)\n     {\n-      if (!merged_store->apply_stores ())\n-\tdelete merged_store;\n-      else\n+      if (merged_store->apply_stores ())\n \tm_merged_store_groups.safe_push (merged_store);\n+      else\n+\tdelete merged_store;\n     }\n \n   gcc_assert (m_merged_store_groups.length () <= m_store_info.length ());\n+\n   bool success\n     = !m_merged_store_groups.is_empty ()\n       && m_merged_store_groups.length () < m_store_info.length ();\n \n   if (success && dump_file)\n-    fprintf (dump_file, \"Coalescing successful!\\n\"\n-\t\t\t\"Merged into %u stores\\n\",\n+    fprintf (dump_file, \"Coalescing successful!\\nMerged into %u stores\\n\",\n \t     m_merged_store_groups.length ());\n \n   return success;\n@@ -2943,6 +2973,8 @@ count_multiple_uses (store_immediate_info *info)\n \t    return 1;\n \t}\n       return 0;\n+    case BIT_INSERT_EXPR:\n+      return has_single_use (gimple_assign_rhs1 (stmt)) ? 0 : 1;\n     default:\n       gcc_unreachable ();\n     }\n@@ -3521,6 +3553,7 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n     {\n       unsigned HOST_WIDE_INT try_size = split_store->size;\n       unsigned HOST_WIDE_INT try_pos = split_store->bytepos;\n+      unsigned HOST_WIDE_INT try_bitpos = try_pos * BITS_PER_UNIT;\n       unsigned HOST_WIDE_INT align = split_store->align;\n       tree dest, src;\n       location_t loc;\n@@ -3555,8 +3588,10 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t      MR_DEPENDENCE_BASE (dest) = base;\n \t    }\n \n-\t  tree mask = integer_zero_node;\n-\t  if (!bswap_res)\n+\t  tree mask;\n+\t  if (bswap_res)\n+\t    mask = integer_zero_node;\n+\t  else\n \t    mask = native_interpret_expr (int_type,\n \t\t\t\t\t  group->mask + try_pos\n \t\t\t\t\t  - start_byte_pos,\n@@ -3582,7 +3617,7 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \n \t\t  unsigned HOST_WIDE_INT load_align = group->load_align[j];\n \t\t  unsigned HOST_WIDE_INT align_bitpos\n-\t\t    = known_alignment (try_pos * BITS_PER_UNIT\n+\t\t    = known_alignment (try_bitpos\n \t\t\t\t       - split_store->orig_stores[0]->bitpos\n \t\t\t\t       + op.bitpos);\n \t\t  if (align_bitpos & (load_align - 1))\n@@ -3594,7 +3629,7 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t\t    = build_aligned_type (load_int_type, load_align);\n \n \t\t  poly_uint64 load_pos\n-\t\t    = exact_div (try_pos * BITS_PER_UNIT\n+\t\t    = exact_div (try_bitpos\n \t\t\t\t - split_store->orig_stores[0]->bitpos\n \t\t\t\t + op.bitpos,\n \t\t\t\t BITS_PER_UNIT);\n@@ -3728,6 +3763,45 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t      break;\n \t    }\n \n+\t  /* If bit insertion is required, we use the source as an accumulator\n+\t     into which the successive bit-field values are manually inserted.\n+\t     FIXME: perhaps use BIT_INSERT_EXPR instead in some cases?  */\n+\t  if (group->bit_insertion)\n+\t    FOR_EACH_VEC_ELT (split_store->orig_stores, k, info)\n+\t      if (info->rhs_code == BIT_INSERT_EXPR\n+\t\t  && info->bitpos < try_bitpos + try_size\n+\t\t  && info->bitpos + info->bitsize > try_bitpos)\n+\t\t{\n+\t\t  /* Mask, truncate, convert to final type, shift and ior into\n+\t\t     the accumulator.  Note that every step can be a no-op.  */\n+\t\t  const HOST_WIDE_INT start_gap = info->bitpos - try_bitpos;\n+\t\t  const HOST_WIDE_INT end_gap\n+\t\t    = (try_bitpos + try_size) - (info->bitpos + info->bitsize);\n+\t\t  tree tem = info->ops[0].val;\n+\t\t  if ((BYTES_BIG_ENDIAN ? start_gap : end_gap) > 0)\n+\t\t    {\n+\t\t      const unsigned HOST_WIDE_INT imask\n+\t\t\t= (HOST_WIDE_INT_1U << info->bitsize) - 1;\n+\t\t      tem = gimple_build (&seq, loc,\n+\t\t\t\t\t  BIT_AND_EXPR, TREE_TYPE (tem), tem,\n+\t\t\t\t\t  build_int_cst (TREE_TYPE (tem),\n+\t\t\t\t\t\t\t imask));\n+\t\t    }\n+\t\t  const HOST_WIDE_INT shift\n+\t\t    = (BYTES_BIG_ENDIAN ? end_gap : start_gap);\n+\t\t  if (shift < 0)\n+\t\t    tem = gimple_build (&seq, loc,\n+\t\t\t\t\tRSHIFT_EXPR, TREE_TYPE (tem), tem,\n+\t\t\t\t\tbuild_int_cst (NULL_TREE, -shift));\n+\t\t  tem = gimple_convert (&seq, loc, int_type, tem);\n+\t\t  if (shift > 0)\n+\t\t    tem = gimple_build (&seq, loc,\n+\t\t\t\t\tLSHIFT_EXPR, int_type, tem,\n+\t\t\t\t\tbuild_int_cst (NULL_TREE, shift));\n+\t\t  src = gimple_build (&seq, loc,\n+\t\t\t\t      BIT_IOR_EXPR, int_type, tem, src);\n+\t\t}\n+\n \t  if (!integer_zerop (mask))\n \t    {\n \t      tree tem = make_ssa_name (int_type);\n@@ -3798,7 +3872,7 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n   if (dump_file)\n     {\n       fprintf (dump_file,\n-\t       \"New sequence of %u stmts to replace old one of %u stmts\\n\",\n+\t       \"New sequence of %u stores to replace old one of %u stores\\n\",\n \t       split_stores.length (), orig_num_stmts);\n       if (dump_flags & TDF_DETAILS)\n \tprint_gimple_seq (dump_file, seq, 0, TDF_VOPS | TDF_MEMSYMS);\n@@ -4120,6 +4194,7 @@ pass_store_merging::process_store (gimple *stmt)\n \t      def_stmt = SSA_NAME_DEF_STMT (rhs1);\n \t    }\n \t}\n+\n       if (rhs_code == ERROR_MARK && !invalid)\n \tswitch ((rhs_code = gimple_assign_rhs_code (def_stmt)))\n \t  {\n@@ -4156,12 +4231,12 @@ pass_store_merging::process_store (gimple *stmt)\n \t    invalid = true;\n \t    break;\n \t  }\n+\n       unsigned HOST_WIDE_INT const_bitsize;\n       if (bitsize.is_constant (&const_bitsize)\n-\t  && multiple_p (const_bitsize, BITS_PER_UNIT)\n-\t  && multiple_p (bitpos, BITS_PER_UNIT)\n+\t  && (const_bitsize % BITS_PER_UNIT) == 0\n \t  && const_bitsize <= 64\n-\t  && BYTES_BIG_ENDIAN == WORDS_BIG_ENDIAN)\n+\t  && multiple_p (bitpos, BITS_PER_UNIT))\n \t{\n \t  ins_stmt = find_bswap_or_nop_1 (def_stmt, &n, 12);\n \t  if (ins_stmt)\n@@ -4188,6 +4263,28 @@ pass_store_merging::process_store (gimple *stmt)\n \t\t}\n \t    }\n \t}\n+\n+      if (invalid\n+\t  && bitsize.is_constant (&const_bitsize)\n+\t  && ((const_bitsize % BITS_PER_UNIT) != 0\n+\t      || !multiple_p (bitpos, BITS_PER_UNIT))\n+\t  && const_bitsize <= 64)\n+\t{\n+\t  /* Bypass a truncating conversion to the bit-field type.  */\n+\t  if (is_gimple_assign (def_stmt) && CONVERT_EXPR_CODE_P (rhs_code))\n+\t    {\n+\t      tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t      if (TREE_CODE (rhs1) == SSA_NAME\n+\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (rhs1))\n+\t\t  && const_bitsize <= TYPE_PRECISION (TREE_TYPE (rhs1)))\n+\t\trhs = rhs1;\n+\t    }\n+\t  rhs_code = BIT_INSERT_EXPR;\n+\t  ops[0].val = rhs;\n+\t  ops[0].base_addr = NULL_TREE;\n+\t  ops[1].base_addr = NULL_TREE;\n+\t  invalid = false;\n+\t}\n     }\n \n   unsigned HOST_WIDE_INT const_bitsize, const_bitpos;"}, {"sha": "b8a5a8b3ad4de15ce3f6de5dc76da40bb664a649", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c94c353225cfa30a351399064ea3f3dc9326e472", "patch": "@@ -1,4 +1,11 @@\n+2018-06-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/store_merging_20.c: New test.\n+\t* gnat.dg/opt71.adb: Likewise.\n+\t* gnat.dg/opt71_pkg.ads: New helper.\n+\n 2018-06-01  Carl Love  <cel@us.ibm.com>\n+\n \t* gcc.target/powerpc/altivec-35.c (foo): Add builtin test vec_madds.\n \t* gcc.target/powerpc/builtins-6-runnable.c (main): Fix typo for output.\n \tAdd vec_xst_be for signed and unsigned arguments."}, {"sha": "b15582aa1626a4be109c6b145412d838b1ee365e", "filename": "gcc/testsuite/gcc.dg/store_merging_20.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_20.c?ref=c94c353225cfa30a351399064ea3f3dc9326e472", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target store_merge } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+extern void abort (void);\n+\n+struct S1 {\n+  unsigned int flag : 1;\n+  unsigned int size : 31;\n+};\n+\n+__attribute__((noipa))\n+void foo1 (struct S1 *s, unsigned int size)\n+{\n+  s->flag = 1;\n+  s->size = size & 0x7FFFFFFF;\n+}\n+\n+struct S2 {\n+  unsigned int flag : 1;\n+  unsigned int size : 15;\n+  unsigned short count;\n+};\n+\n+__attribute__((noipa))\n+void foo2 (struct S2 *s, unsigned short size)\n+{\n+  s->flag = 1;\n+  s->size = size;\n+  s->count = 0xABCD;\n+}\n+\n+struct S3 {\n+  unsigned int n1 : 4;\n+  unsigned int c  : 8;\n+  unsigned int n2 : 4;\n+};\n+\n+__attribute__((noipa))\n+void foo3 (struct S3 *s, unsigned char n1, unsigned char c, unsigned char n2)\n+{\n+  s->n1 = n1 & 0xF;\n+  s->n2 = n2 & 0xF;\n+  s->c = c;\n+}\n+\n+int main (void)\n+{\n+  struct S1 s1;\n+  struct S2 s2;\n+  struct S3 s3;\n+\n+  foo1 (&s1, 0x12345678);\n+  if (s1.flag != 1 || s1.size != 0x12345678)\n+    abort ();\n+\n+  foo2 (&s2, 0x1234);\n+  if (s2.flag != 1 || s2.size != 0x1234 || s2.count != 0xABCD)\n+    abort ();\n+\n+  foo3 (&s3, 0x12, 0x34, 0x56);\n+  if (s3.n1 != 0x2 || s3.c != 0x34 || s3.n2 != 0x6)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 3 \"store-merging\" } } */"}, {"sha": "d7ddee6e6c798dafee030c9f373ef0759f382e56", "filename": "gcc/testsuite/gnat.dg/opt71.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71.adb?ref=c94c353225cfa30a351399064ea3f3dc9326e472", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+-- { dg-require-effective-target store_merge }\n+-- { dg-options \"-O2 -fdump-tree-store-merging\" }\n+\n+with Opt71_Pkg; use Opt71_Pkg;\n+\n+procedure Opt71 (X : not null access Rec; Size : Positive) is\n+begin\n+   X.all := (Flag => True, Size => Size);\n+end;\n+\n+-- { dg-final { scan-tree-dump \"Merging successful\" \"store-merging\" } }"}, {"sha": "f78e0027e31cc51682367fbac1e034fbcb8af0a2", "filename": "gcc/testsuite/gnat.dg/opt71_pkg.ads", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94c353225cfa30a351399064ea3f3dc9326e472/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt71_pkg.ads?ref=c94c353225cfa30a351399064ea3f3dc9326e472", "patch": "@@ -0,0 +1,9 @@\n+package Opt71_Pkg is\n+\n+   type Rec is record\n+      Flag : Boolean;\n+      Size : Positive;\n+   end record;\n+   pragma Pack (Rec);\n+\n+end Opt71_Pkg;"}]}