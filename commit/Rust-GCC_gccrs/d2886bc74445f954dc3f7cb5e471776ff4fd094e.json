{"sha": "d2886bc74445f954dc3f7cb5e471776ff4fd094e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI4ODZiYzc0NDQ1Zjk1NGRjM2Y3Y2I1ZTQ3MTc3NmZmNGZkMDk0ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-07-15T16:09:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-07-15T16:09:48Z"}, "message": "trans.h (gfc_string_to_single_character): New prototype.\n\n\t* trans.h (gfc_string_to_single_character): New prototype.\n\t* trans-expr.c (string_to_single_character): Renamed to ...\n\t(gfc_string_to_single_character): ... this.  No longer static.\n\t(gfc_conv_scalar_char_value, gfc_build_compare_string,\n\tgfc_trans_string_copy): Adjust callers.\n\t* config-lang.in (gtfiles): Add fortran/trans-stmt.c.\n\t* trans-stmt.c: Include ggc.h and gt-fortran-trans-stmt.h.\n\t(select_struct): Move to toplevel, add GTY(()).\n\t(gfc_trans_character_select): Optimize SELECT CASE\n\twith character length 1.\n\n\t* gfortran.dg/select_char_2.f90: New test.\n\nFrom-SVN: r162226", "tree": {"sha": "bfad22965ecaea510a0bd421b64f01317b1783c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfad22965ecaea510a0bd421b64f01317b1783c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2886bc74445f954dc3f7cb5e471776ff4fd094e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2886bc74445f954dc3f7cb5e471776ff4fd094e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2886bc74445f954dc3f7cb5e471776ff4fd094e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2886bc74445f954dc3f7cb5e471776ff4fd094e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef8fc6c2eff4060e5acf59d7592837d352c706ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef8fc6c2eff4060e5acf59d7592837d352c706ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef8fc6c2eff4060e5acf59d7592837d352c706ce"}], "stats": {"total": 267, "additions": 237, "deletions": 30}, "files": [{"sha": "5660e30adb393b0926b101bb0adefd483909e177", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d2886bc74445f954dc3f7cb5e471776ff4fd094e", "patch": "@@ -1,3 +1,16 @@\n+2010-07-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* trans.h (gfc_string_to_single_character): New prototype.\n+\t* trans-expr.c (string_to_single_character): Renamed to ...\n+\t(gfc_string_to_single_character): ... this.  No longer static.\n+\t(gfc_conv_scalar_char_value, gfc_build_compare_string,\n+\tgfc_trans_string_copy): Adjust callers.\n+\t* config-lang.in (gtfiles): Add fortran/trans-stmt.c.\n+\t* trans-stmt.c: Include ggc.h and gt-fortran-trans-stmt.h.\n+\t(select_struct): Move to toplevel, add GTY(()).\n+\t(gfc_trans_character_select): Optimize SELECT CASE\n+\twith character length 1.\n+\n 2010-07-15  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* f95-lang.c: Carefully replace TREE_CHAIN with DECL_CHAIN."}, {"sha": "b7ace71fee4231acd249f4678625bf5d48551aeb", "filename": "gcc/fortran/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ffortran%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ffortran%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconfig-lang.in?ref=d2886bc74445f954dc3f7cb5e471776ff4fd094e", "patch": "@@ -29,5 +29,5 @@ compilers=\"f951\\$(exeext)\"\n \n target_libs=target-libgfortran\n \n-gtfiles=\"\\$(srcdir)/fortran/f95-lang.c \\$(srcdir)/fortran/trans-decl.c \\$(srcdir)/fortran/trans-intrinsic.c \\$(srcdir)/fortran/trans-io.c \\$(srcdir)/fortran/trans-types.c \\$(srcdir)/fortran/trans-types.h \\$(srcdir)/fortran/trans.h \\$(srcdir)/fortran/trans-const.h\"\n+gtfiles=\"\\$(srcdir)/fortran/f95-lang.c \\$(srcdir)/fortran/trans-decl.c \\$(srcdir)/fortran/trans-intrinsic.c \\$(srcdir)/fortran/trans-io.c \\$(srcdir)/fortran/trans-stmt.c \\$(srcdir)/fortran/trans-types.c \\$(srcdir)/fortran/trans-types.h \\$(srcdir)/fortran/trans.h \\$(srcdir)/fortran/trans-const.h\"\n "}, {"sha": "09ad110ff48c1d2dd24b0103fa5c787a70716cc4", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=d2886bc74445f954dc3f7cb5e471776ff4fd094e", "patch": "@@ -1389,8 +1389,8 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n \n /* If a string's length is one, we convert it to a single character.  */\n \n-static tree\n-string_to_single_character (tree len, tree str, int kind)\n+tree\n+gfc_string_to_single_character (tree len, tree str, int kind)\n {\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (str)));\n \n@@ -1475,7 +1475,7 @@ gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr)\n         {\n \t  if ((*expr)->ref == NULL)\n \t    {\n-\t      se->expr = string_to_single_character\n+\t      se->expr = gfc_string_to_single_character\n \t\t(build_int_cst (integer_type_node, 1),\n \t\t gfc_build_addr_expr (gfc_get_pchar_type ((*expr)->ts.kind),\n \t\t\t\t      gfc_get_symbol_decl\n@@ -1485,7 +1485,7 @@ gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr)\n \t  else\n \t    {\n \t      gfc_conv_variable (se, *expr);\n-\t      se->expr = string_to_single_character\n+\t      se->expr = gfc_string_to_single_character\n \t\t(build_int_cst (integer_type_node, 1),\n \t\t gfc_build_addr_expr (gfc_get_pchar_type ((*expr)->ts.kind),\n \t\t\t\t      se->expr),\n@@ -1544,8 +1544,8 @@ gfc_build_compare_string (tree len1, tree str1, tree len2, tree str2, int kind,\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (str1)));\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (str2)));\n \n-  sc1 = string_to_single_character (len1, str1, kind);\n-  sc2 = string_to_single_character (len2, str2, kind);\n+  sc1 = gfc_string_to_single_character (len1, str1, kind);\n+  sc2 = gfc_string_to_single_character (len2, str2, kind);\n \n   if (sc1 != NULL_TREE && sc2 != NULL_TREE)\n     {\n@@ -3618,7 +3618,7 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   if (slength != NULL_TREE)\n     {\n       slen = fold_convert (size_type_node, gfc_evaluate_now (slength, block));\n-      ssc = string_to_single_character (slen, src, skind);\n+      ssc = gfc_string_to_single_character (slen, src, skind);\n     }\n   else\n     {\n@@ -3629,7 +3629,7 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   if (dlength != NULL_TREE)\n     {\n       dlen = fold_convert (size_type_node, gfc_evaluate_now (dlength, block));\n-      dsc = string_to_single_character (dlen, dest, dkind);\n+      dsc = gfc_string_to_single_character (dlen, dest, dkind);\n     }\n   else\n     {"}, {"sha": "0f34e617dffb53bd316dd13970e344b828aab66c", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 165, "deletions": 21, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=d2886bc74445f954dc3f7cb5e471776ff4fd094e", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-const.h\"\n #include \"arith.h\"\n #include \"dependency.h\"\n+#include \"ggc.h\"\n \n typedef struct iter_info\n {\n@@ -1594,6 +1595,10 @@ gfc_trans_logical_select (gfc_code * code)\n }\n \n \n+/* The jump table types are stored in static variables to avoid\n+   constructing them from scratch every single time.  */\n+static GTY(()) tree select_struct[2];\n+\n /* Translate the SELECT CASE construct for CHARACTER case expressions.\n    Instead of generating compares and jumps, it is far simpler to\n    generate a data structure describing the cases in order and call a\n@@ -1610,18 +1615,171 @@ gfc_trans_character_select (gfc_code *code)\n   stmtblock_t block, body;\n   gfc_case *cp, *d;\n   gfc_code *c;\n-  gfc_se se;\n+  gfc_se se, expr1se;\n   int n, k;\n   VEC(constructor_elt,gc) *inits = NULL;\n \n+  tree pchartype = gfc_get_pchar_type (code->expr1->ts.kind);\n+\n   /* The jump table types are stored in static variables to avoid\n      constructing them from scratch every single time.  */\n-  static tree select_struct[2];\n   static tree ss_string1[2], ss_string1_len[2];\n   static tree ss_string2[2], ss_string2_len[2];\n   static tree ss_target[2];\n \n-  tree pchartype = gfc_get_pchar_type (code->expr1->ts.kind);\n+  cp = code->block->ext.case_list;\n+  while (cp->left != NULL)\n+    cp = cp->left;\n+\n+  /* Generate the body */\n+  gfc_start_block (&block);\n+  gfc_init_se (&expr1se, NULL);\n+  gfc_conv_expr_reference (&expr1se, code->expr1);\n+\n+  gfc_add_block_to_block (&block, &expr1se.pre);\n+\n+  end_label = gfc_build_label_decl (NULL_TREE);\n+\n+  gfc_init_block (&body);\n+\n+  /* Attempt to optimize length 1 selects.  */\n+  if (expr1se.string_length == integer_one_node)\n+    {\n+      for (d = cp; d; d = d->right)\n+\t{\n+\t  int i;\n+\t  if (d->low)\n+\t    {\n+\t      gcc_assert (d->low->expr_type == EXPR_CONSTANT\n+\t\t\t  && d->low->ts.type == BT_CHARACTER);\n+\t      if (d->low->value.character.length > 1)\n+\t\t{\n+\t\t  for (i = 1; i < d->low->value.character.length; i++)\n+\t\t    if (d->low->value.character.string[i] != ' ')\n+\t\t      break;\n+\t\t  if (i != d->low->value.character.length)\n+\t\t    {\n+\t\t      if (optimize && d->high && i == 1)\n+\t\t\t{\n+\t\t\t  gcc_assert (d->high->expr_type == EXPR_CONSTANT\n+\t\t\t\t      && d->high->ts.type == BT_CHARACTER);\n+\t\t\t  if (d->high->value.character.length > 1\n+\t\t\t      && (d->low->value.character.string[0]\n+\t\t\t\t  == d->high->value.character.string[0])\n+\t\t\t      && d->high->value.character.string[1] != ' '\n+\t\t\t      && ((d->low->value.character.string[1] < ' ')\n+\t\t\t\t  == (d->high->value.character.string[1]\n+\t\t\t\t      < ' ')))\n+\t\t\t    continue;\n+\t\t\t}\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (d->high)\n+\t    {\n+\t      gcc_assert (d->high->expr_type == EXPR_CONSTANT\n+\t\t\t  && d->high->ts.type == BT_CHARACTER);\n+\t      if (d->high->value.character.length > 1)\n+\t\t{\n+\t\t  for (i = 1; i < d->high->value.character.length; i++)\n+\t\t    if (d->high->value.character.string[i] != ' ')\n+\t\t      break;\n+\t\t  if (i != d->high->value.character.length)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+      if (d == NULL)\n+\t{\n+\t  tree ctype = gfc_get_char_type (code->expr1->ts.kind);\n+\n+\t  for (c = code->block; c; c = c->block)\n+\t    {\n+\t      for (cp = c->ext.case_list; cp; cp = cp->next)\n+\t\t{\n+\t\t  tree low, high;\n+\t\t  tree label;\n+\t\t  gfc_char_t r;\n+\n+\t\t  /* Assume it's the default case.  */\n+\t\t  low = high = NULL_TREE;\n+\n+\t\t  if (cp->low)\n+\t\t    {\n+\t\t      /* CASE ('ab') or CASE ('ab':'az') will never match\n+\t\t\t any length 1 character.  */\n+\t\t      if (cp->low->value.character.length > 1\n+\t\t\t  && cp->low->value.character.string[1] != ' ')\n+\t\t\tcontinue;\n+\n+\t\t      if (cp->low->value.character.length > 0)\n+\t\t\tr = cp->low->value.character.string[0];\n+\t\t      else\n+\t\t\tr = ' ';\n+\t\t      low = build_int_cst (ctype, r);\n+\n+\t\t      /* If there's only a lower bound, set the high bound\n+\t\t\t to the maximum value of the case expression.  */\n+\t\t      if (!cp->high)\n+\t\t\thigh = TYPE_MAX_VALUE (ctype);\n+\t\t    }\n+\n+\t\t  if (cp->high)\n+\t\t    {\n+\t\t      if (!cp->low\n+\t\t\t  || (cp->low->value.character.string[0]\n+\t\t\t      != cp->high->value.character.string[0]))\n+\t\t\t{\n+\t\t\t  if (cp->high->value.character.length > 0)\n+\t\t\t    r = cp->high->value.character.string[0];\n+\t\t\t  else\n+\t\t\t    r = ' ';\n+\t\t\t  high = build_int_cst (ctype, r);\n+\t\t\t}\n+\n+\t\t      /* Unbounded case.  */\n+\t\t      if (!cp->low)\n+\t\t\tlow = TYPE_MIN_VALUE (ctype);\n+\t\t    }\n+\n+\t\t  /* Build a label.  */\n+\t\t  label = gfc_build_label_decl (NULL_TREE);\n+\n+\t\t  /* Add this case label.\n+\t\t     Add parameter 'label', make it match GCC backend.  */\n+\t\t  tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n+\t\t\t\t     low, high, label);\n+\t\t  gfc_add_expr_to_block (&body, tmp);\n+\t\t}\n+\n+\t      /* Add the statements for this case.  */\n+\t      tmp = gfc_trans_code (c->next);\n+\t      gfc_add_expr_to_block (&body, tmp);\n+\n+\t      /* Break to the end of the construct.  */\n+\t      tmp = build1_v (GOTO_EXPR, end_label);\n+\t      gfc_add_expr_to_block (&body, tmp);\n+\t    }\n+\n+\t  tmp = gfc_string_to_single_character (expr1se.string_length,\n+\t\t\t\t\t\texpr1se.expr,\n+\t\t\t\t\t\tcode->expr1->ts.kind);\n+\t  case_num = gfc_create_var (ctype, \"case_num\");\n+\t  gfc_add_modify (&block, case_num, tmp);\n+\n+\t  gfc_add_block_to_block (&block, &expr1se.post);\n+\n+\t  tmp = gfc_finish_block (&body);\n+\t  tmp = build3_v (SWITCH_EXPR, case_num, tmp, NULL_TREE);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\n+\t  tmp = build1_v (LABEL_EXPR, end_label);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\n+\t  return gfc_finish_block (&block);\n+\t}\n+    }\n \n   if (code->expr1->ts.kind == 1)\n     k = 0;\n@@ -1661,20 +1819,10 @@ gfc_trans_character_select (gfc_code *code)\n       gfc_finish_type (select_struct[k]);\n     }\n \n-  cp = code->block->ext.case_list;\n-  while (cp->left != NULL)\n-    cp = cp->left;\n-\n   n = 0;\n   for (d = cp; d; d = d->right)\n     d->n = n++;\n \n-  end_label = gfc_build_label_decl (NULL_TREE);\n-\n-  /* Generate the body */\n-  gfc_start_block (&block);\n-  gfc_init_block (&body);\n-\n   for (c = code->block; c; c = c->block)\n     {\n       for (d = c->ext.case_list; d; d = d->next)\n@@ -1695,7 +1843,7 @@ gfc_trans_character_select (gfc_code *code)\n     }\n \n   /* Generate the structure describing the branches */\n-  for(d = cp; d; d = d->right)\n+  for (d = cp; d; d = d->right)\n     {\n       VEC(constructor_elt,gc) *node = NULL;\n \n@@ -1752,11 +1900,6 @@ gfc_trans_character_select (gfc_code *code)\n   /* Build the library call */\n   init = gfc_build_addr_expr (pvoid_type_node, init);\n \n-  gfc_init_se (&se, NULL);\n-  gfc_conv_expr_reference (&se, code->expr1);\n-\n-  gfc_add_block_to_block (&block, &se.pre);\n-\n   if (code->expr1->ts.kind == 1)\n     fndecl = gfor_fndecl_select_string;\n   else if (code->expr1->ts.kind == 4)\n@@ -1766,11 +1909,11 @@ gfc_trans_character_select (gfc_code *code)\n \n   tmp = build_call_expr_loc (input_location,\n \t\t\t fndecl, 4, init, build_int_cst (NULL_TREE, n),\n-\t\t\t se.expr, se.string_length);\n+\t\t\t expr1se.expr, expr1se.string_length);\n   case_num = gfc_create_var (integer_type_node, \"case_num\");\n   gfc_add_modify (&block, case_num, tmp);\n \n-  gfc_add_block_to_block (&block, &se.post);\n+  gfc_add_block_to_block (&block, &expr1se.post);\n \n   tmp = gfc_finish_block (&body);\n   tmp = build3_v (SWITCH_EXPR, case_num, tmp, NULL_TREE);\n@@ -4494,3 +4637,4 @@ gfc_trans_deallocate (gfc_code *code)\n   return gfc_finish_block (&block);\n }\n \n+#include \"gt-fortran-trans-stmt.h\""}, {"sha": "7afd831cd510de2e0611dc32559092ed1d99ec3e", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=d2886bc74445f954dc3f7cb5e471776ff4fd094e", "patch": "@@ -322,6 +322,7 @@ void gfc_conv_expr_type (gfc_se * se, gfc_expr *, tree);\n \n /* trans-expr.c */\n void gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr);\n+tree gfc_string_to_single_character (tree len, tree str, int kind);\n \n /* Find the decl containing the auxiliary variables for assigned variables.  */\n void gfc_conv_label_variable (gfc_se * se, gfc_expr * expr);"}, {"sha": "99793c52da6c428078acda9a1cf0113d099035ce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d2886bc74445f954dc3f7cb5e471776ff4fd094e", "patch": "@@ -1,3 +1,7 @@\n+2010-07-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gfortran.dg/select_char_2.f90: New test.\n+\n 2010-07-15  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* g++.dg/plugin/attribute_plugin.c: Carefully replace TREE_CHAIN"}, {"sha": "22af1c76dfc7f0b0870bd08dadf11666e6f0be0e", "filename": "gcc/testsuite/gfortran.dg/select_char_2.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_char_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2886bc74445f954dc3f7cb5e471776ff4fd094e/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_char_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_char_2.f90?ref=d2886bc74445f954dc3f7cb5e471776ff4fd094e", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+! { dg-options \"-O -fdump-tree-original\" }\n+\n+  if (foo ('E') .ne. 1) call abort\n+  if (foo ('e') .ne. 1) call abort\n+  if (foo ('f') .ne. 2) call abort\n+  if (foo ('g') .ne. 2) call abort\n+  if (foo ('h') .ne. 2) call abort\n+  if (foo ('Q') .ne. 3) call abort\n+  if (foo (' ') .ne. 4) call abort\n+  if (bar ('e') .ne. 1) call abort\n+  if (bar ('f') .ne. 3) call abort\n+contains\n+  function foo (c)\n+    character :: c\n+    integer :: foo\n+    select case (c)\n+      case ('E','e')\n+        foo = 1\n+      case ('f':'h  ')\n+        foo = 2\n+      case default\n+        foo = 3\n+      case ('')\n+        foo = 4\n+    end select\n+  end function\n+  function bar (c)\n+    character :: c\n+    integer :: bar\n+    select case (c)\n+      case ('ea':'ez')\n+        bar = 2\n+      case ('e')\n+        bar = 1\n+      case default\n+        bar = 3\n+      case ('fd')\n+        bar = 4\n+    end select\n+  end function\n+end\n+\n+! { dg-final { scan-tree-dump-not \"_gfortran_select_string\" \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}