{"sha": "9f38dde2306d9a482c03eeaa59688a30d566c8ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYzOGRkZTIzMDZkOWE0ODJjMDNlZWFhNTk2ODhhMzBkNTY2YzhmZg==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2016-09-23T20:34:26Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2016-09-23T20:34:26Z"}, "message": "rs6000.md (cmpmemsi): New define_expand.\n\n\t* config/rs6000/rs6000.md (cmpmemsi): New define_expand.\n\t* config/rs6000/rs6000.c (expand_block_compare): New function used by\n\tcmpmemsi pattern to do builtin expansion of memcmp ().\n\t(compute_current_alignment): Add helper function for\n\texpand_block_compare used to compute alignment as the compare proceeds.\n\t(select_block_compare_mode): Used by expand_block_compare to select\n\tthe mode used for reading the next chunk of bytes in the compare.\n\t(do_load_for_compare): Used by expand_block_compare to emit the load\n\tinsns for the compare.\n\t(rs6000_emit_dot_insn): Moved this function to avoid a forward\n\treference from expand_block_compare ().\n\t* config/rs6000/rs6000-protos.h (expand_block_compare): Add a\n\tprototype for this function.\n\t* config/rs6000/rs6000.opt (mblock-compare-inline-limit): Add a new\n\ttarget option for controlling how much code inline expansion of\n\tmemcmp() will be allowed to generate.\n\nFrom-SVN: r240455", "tree": {"sha": "4514af28159ac075418201ffbb487eabd38c5dc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4514af28159ac075418201ffbb487eabd38c5dc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f38dde2306d9a482c03eeaa59688a30d566c8ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f38dde2306d9a482c03eeaa59688a30d566c8ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f38dde2306d9a482c03eeaa59688a30d566c8ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f38dde2306d9a482c03eeaa59688a30d566c8ff/comments", "author": null, "committer": null, "parents": [{"sha": "90ef45cb310be06c0cdb1a0e36ee73a2db96a6e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90ef45cb310be06c0cdb1a0e36ee73a2db96a6e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90ef45cb310be06c0cdb1a0e36ee73a2db96a6e2"}], "stats": {"total": 517, "additions": 481, "deletions": 36}, "files": [{"sha": "8f07450d72ba5cb136c322d4265ea86e4e70bae8", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f38dde2306d9a482c03eeaa59688a30d566c8ff/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f38dde2306d9a482c03eeaa59688a30d566c8ff/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=9f38dde2306d9a482c03eeaa59688a30d566c8ff", "patch": "@@ -77,6 +77,7 @@ extern void rs6000_expand_interleave (rtx, rtx, rtx, bool);\n extern void rs6000_scale_v2df (rtx, rtx, int);\n extern int expand_block_clear (rtx[]);\n extern int expand_block_move (rtx[]);\n+extern bool expand_block_compare (rtx[]);\n extern const char * rs6000_output_load_multiple (rtx[]);\n extern bool rs6000_is_valid_mask (rtx, int *, int *, machine_mode);\n extern bool rs6000_is_valid_and_mask (rtx, machine_mode);"}, {"sha": "7c8a82f25786ea3b334433ae0314831737eb5949", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 455, "deletions": 36, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f38dde2306d9a482c03eeaa59688a30d566c8ff/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f38dde2306d9a482c03eeaa59688a30d566c8ff/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9f38dde2306d9a482c03eeaa59688a30d566c8ff", "patch": "@@ -18423,6 +18423,461 @@ expand_block_clear (rtx operands[])\n   return 1;\n }\n \n+/* Emit a potentially record-form instruction, setting DST from SRC.\n+   If DOT is 0, that is all; otherwise, set CCREG to the result of the\n+   signed comparison of DST with zero.  If DOT is 1, the generated RTL\n+   doesn't care about the DST result; if DOT is 2, it does.  If CCREG\n+   is CR0 do a single dot insn (as a PARALLEL); otherwise, do a SET and\n+   a separate COMPARE.  */\n+\n+static void\n+rs6000_emit_dot_insn (rtx dst, rtx src, int dot, rtx ccreg)\n+{\n+  if (dot == 0)\n+    {\n+      emit_move_insn (dst, src);\n+      return;\n+    }\n+\n+  if (cc_reg_not_cr0_operand (ccreg, CCmode))\n+    {\n+      emit_move_insn (dst, src);\n+      emit_move_insn (ccreg, gen_rtx_COMPARE (CCmode, dst, const0_rtx));\n+      return;\n+    }\n+\n+  rtx ccset = gen_rtx_SET (ccreg, gen_rtx_COMPARE (CCmode, src, const0_rtx));\n+  if (dot == 1)\n+    {\n+      rtx clobber = gen_rtx_CLOBBER (VOIDmode, dst);\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, ccset, clobber)));\n+    }\n+  else\n+    {\n+      rtx set = gen_rtx_SET (dst, src);\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, ccset, set)));\n+    }\n+}\n+\n+\f\n+/* Figure out the correct instructions to generate to load data for\n+   block compare.  MODE is used for the read from memory, and\n+   data is zero extended if REG is wider than MODE.  If LE code\n+   is being generated, bswap loads are used.\n+\n+   REG is the destination register to move the data into.\n+   MEM is the memory block being read.\n+   MODE is the mode of memory to use for the read.  */\n+static void\n+do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n+{\n+  switch (GET_MODE (reg))\n+    {\n+    case DImode:\n+      switch (mode)\n+\t{\n+\tcase QImode:\n+\t  emit_insn (gen_zero_extendqidi2 (reg, mem));\n+\t  break;\n+\tcase HImode:\n+\t  {\n+\t    rtx src = mem;\n+\t    if (TARGET_LITTLE_ENDIAN)\n+\t      {\n+\t\tsrc = gen_reg_rtx (HImode);\n+\t\temit_insn (gen_bswaphi2 (src, mem));\n+\t      }\n+\t    emit_insn (gen_zero_extendhidi2 (reg, src));\n+\t    break;\n+\t  }\n+\tcase SImode:\n+\t  {\n+\t    rtx src = mem;\n+\t    if (TARGET_LITTLE_ENDIAN)\n+\t      {\n+\t\tsrc = gen_reg_rtx (SImode);\n+\t\temit_insn (gen_bswapsi2 (src, mem));\n+\t      }\n+\t    emit_insn (gen_zero_extendsidi2 (reg, src));\n+\t  }\n+\t  break;\n+\tcase DImode:\n+\t  if (TARGET_LITTLE_ENDIAN)\n+\t    emit_insn (gen_bswapdi2 (reg, mem));\n+\t  else\n+\t    emit_insn (gen_movdi (reg, mem));\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+\n+    case SImode:\n+      switch (mode)\n+\t{\n+\tcase QImode:\n+\t  emit_insn (gen_zero_extendqisi2 (reg, mem));\n+\t  break;\n+\tcase HImode:\n+\t  {\n+\t    rtx src = mem;\n+\t    if (TARGET_LITTLE_ENDIAN)\n+\t      {\n+\t\tsrc = gen_reg_rtx (HImode);\n+\t\temit_insn (gen_bswaphi2 (src, mem));\n+\t      }\n+\t    emit_insn (gen_zero_extendhisi2 (reg, src));\n+\t    break;\n+\t  }\n+\tcase SImode:\n+\t  if (TARGET_LITTLE_ENDIAN)\n+\t    emit_insn (gen_bswapsi2 (reg, mem));\n+\t  else\n+\t    emit_insn (gen_movsi (reg, mem));\n+\t  break;\n+\tcase DImode:\n+\t  /* DImode is larger than the destination reg so is not expected.  */\n+\t  gcc_unreachable ();\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+}\n+\n+/* Select the mode to be used for reading the next chunk of bytes\n+   in the compare.\n+\n+   OFFSET is the current read offset from the beginning of the block.\n+   BYTES is the number of bytes remaining to be read.\n+   ALIGN is the minimum alignment of the memory blocks being compared in bytes.\n+   WORD_MODE_OK indicates using WORD_MODE is allowed, else SImode is\n+   the largest allowable mode.  */\n+static machine_mode\n+select_block_compare_mode (HOST_WIDE_INT offset, HOST_WIDE_INT bytes,\n+\t\t\t   HOST_WIDE_INT align, bool word_mode_ok)\n+{\n+  /* First see if we can do a whole load unit\n+     as that will be more efficient than a larger load + shift.  */\n+\n+  /* If big, use biggest chunk.\n+     If exactly chunk size, use that size.\n+     If remainder can be done in one piece with shifting, do that.\n+     Do largest chunk possible without violating alignment rules.  */\n+\n+  /* The most we can read without potential page crossing.  */\n+  HOST_WIDE_INT maxread = ROUND_UP (bytes, align);\n+\n+  if (word_mode_ok && bytes >= UNITS_PER_WORD)\n+    return word_mode;\n+  else if (bytes == GET_MODE_SIZE (SImode))\n+    return SImode;\n+  else if (bytes == GET_MODE_SIZE (HImode))\n+    return HImode;\n+  else if (bytes == GET_MODE_SIZE (QImode))\n+    return QImode;\n+  else if (bytes < GET_MODE_SIZE (SImode)\n+\t   && offset >= GET_MODE_SIZE (SImode) - bytes)\n+    /* This matches the case were we have SImode and 3 bytes\n+       and offset >= 1 and permits us to move back one and overlap\n+       with the previous read, thus avoiding having to shift\n+       unwanted bytes off of the input.  */\n+    return SImode;\n+  else if (word_mode_ok && bytes < UNITS_PER_WORD\n+\t   && offset >= UNITS_PER_WORD-bytes)\n+    /* Similarly, if we can use DImode it will get matched here and\n+       can do an overlapping read that ends at the end of the block.  */\n+    return word_mode;\n+  else if (word_mode_ok && maxread >= UNITS_PER_WORD)\n+    /* It is safe to do all remaining in one load of largest size,\n+       possibly with a shift to get rid of unwanted bytes.  */\n+    return word_mode;\n+  else if (maxread >= GET_MODE_SIZE (SImode))\n+    /* It is safe to do all remaining in one SImode load,\n+       possibly with a shift to get rid of unwanted bytes.  */\n+    return SImode;\n+  else if (bytes > GET_MODE_SIZE (SImode))\n+    return SImode;\n+  else if (bytes > GET_MODE_SIZE (HImode))\n+    return HImode;\n+\n+  /* final fallback is do one byte */\n+  return QImode;\n+}\n+\n+/* Compute the alignment of pointer+OFFSET where the original alignment\n+   of pointer was BASE_ALIGN.  */\n+static HOST_WIDE_INT\n+compute_current_alignment (HOST_WIDE_INT base_align, HOST_WIDE_INT offset)\n+{\n+  if (offset == 0)\n+    return base_align;\n+  return min (base_align, offset & -offset);\n+}\n+\n+/* Expand a block compare operation, and return true if successful.\n+   Return false if we should let the compiler generate normal code,\n+   probably a memcmp call.\n+\n+   OPERANDS[0] is the target (result).\n+   OPERANDS[1] is the first source.\n+   OPERANDS[2] is the second source.\n+   OPERANDS[3] is the length.\n+   OPERANDS[4] is the alignment.  */\n+bool\n+expand_block_compare (rtx operands[])\n+{\n+  rtx target = operands[0];\n+  rtx orig_src1 = operands[1];\n+  rtx orig_src2 = operands[2];\n+  rtx bytes_rtx = operands[3];\n+  rtx align_rtx = operands[4];\n+  HOST_WIDE_INT cmp_bytes = 0;\n+  rtx src1 = orig_src1;\n+  rtx src2 = orig_src2;\n+\n+  /* If this is not a fixed size compare, just call memcmp */\n+  if (!CONST_INT_P (bytes_rtx))\n+    return false;\n+\n+  /* This must be a fixed size alignment */\n+  if (!CONST_INT_P (align_rtx))\n+    return false;\n+\n+  int base_align = INTVAL (align_rtx) / BITS_PER_UNIT;\n+\n+  /* SLOW_UNALIGNED_ACCESS -- don't do unaligned stuff */\n+  if (SLOW_UNALIGNED_ACCESS (word_mode, MEM_ALIGN (orig_src1))\n+      || SLOW_UNALIGNED_ACCESS (word_mode, MEM_ALIGN (orig_src2)))\n+    return false;\n+\n+  gcc_assert (GET_MODE (target) == SImode);\n+\n+  /* Anything to move? */\n+  HOST_WIDE_INT bytes = INTVAL (bytes_rtx);\n+  if (bytes <= 0)\n+    return true;\n+\n+  rtx tmp_reg_src1 = gen_reg_rtx (word_mode);\n+  rtx tmp_reg_src2 = gen_reg_rtx (word_mode);\n+\n+  /* If we have an LE target without ldbrx and word_mode is DImode,\n+     then we must avoid using word_mode.  */\n+  int word_mode_ok = !(TARGET_LITTLE_ENDIAN && !TARGET_LDBRX\n+\t\t       && word_mode == DImode);\n+\n+  /* Strategy phase.  How many ops will this take and should we expand it?  */\n+\n+  int offset = 0;\n+  machine_mode load_mode =\n+    select_block_compare_mode (offset, bytes, base_align, word_mode_ok);\n+  int load_mode_size = GET_MODE_SIZE (load_mode);\n+\n+  /* We don't want to generate too much code.  */\n+  if (ROUND_UP (bytes, load_mode_size) / load_mode_size\n+      > rs6000_block_compare_inline_limit)\n+    return false;\n+\n+  bool generate_6432_conversion = false;\n+  rtx convert_label = NULL;\n+  rtx final_label = NULL;\n+\n+  /* Example of generated code for 11 bytes aligned 1 byte:\n+     .L10:\n+             ldbrx 10,6,9\n+             ldbrx 9,7,9\n+             subf. 9,9,10\n+             bne 0,.L8\n+             addi 9,4,7\n+             lwbrx 10,0,9\n+             addi 9,5,7\n+             lwbrx 9,0,9\n+             subf 9,9,10\n+             b .L9\n+     .L8: # convert_label\n+             cntlzd 9,9\n+             addi 9,9,-1\n+             xori 9,9,0x3f\n+     .L9: # final_label\n+\n+     We start off with DImode and have a compare/branch to something\n+     with a smaller mode then we will need a block with the DI->SI conversion\n+     that may or may not be executed.  */\n+\n+  while (bytes > 0)\n+    {\n+      int align = compute_current_alignment (base_align, offset);\n+      load_mode = select_block_compare_mode(offset, bytes, align, word_mode_ok);\n+      load_mode_size = GET_MODE_SIZE (load_mode);\n+      if (bytes >= load_mode_size)\n+\tcmp_bytes = load_mode_size;\n+      else\n+\t{\n+\t  /* Move this load back so it doesn't go past the end.  */\n+\t  int extra_bytes = load_mode_size - bytes;\n+\t  cmp_bytes = bytes;\n+\t  if (extra_bytes < offset)\n+\t    {\n+\t      offset -= extra_bytes;\n+\t      cmp_bytes = load_mode_size;\n+\t      bytes = cmp_bytes;\n+\t    }\n+\t}\n+\n+      src1 = adjust_address (orig_src1, load_mode, offset);\n+      src2 = adjust_address (orig_src2, load_mode, offset);\n+\n+      if (!REG_P (XEXP (src1, 0)))\n+\t{\n+\t  rtx src1_reg = copy_addr_to_reg (XEXP (src1, 0));\n+\t  src1 = replace_equiv_address (src1, src1_reg);\n+\t}\n+      set_mem_size (src1, cmp_bytes);\n+\n+      if (!REG_P (XEXP (src2, 0)))\n+\t{\n+\t  rtx src2_reg = copy_addr_to_reg (XEXP (src2, 0));\n+\t  src2 = replace_equiv_address (src2, src2_reg);\n+\t}\n+      set_mem_size (src2, cmp_bytes);\n+\n+      do_load_for_compare (tmp_reg_src1, src1, load_mode);\n+      do_load_for_compare (tmp_reg_src2, src2, load_mode);\n+\n+      if (cmp_bytes < load_mode_size)\n+\t{\n+\t  /* Shift unneeded bytes off.  */\n+\t  rtx sh = GEN_INT (BITS_PER_UNIT * (load_mode_size - cmp_bytes));\n+\t  if (word_mode == DImode)\n+\t    {\n+\t      emit_insn (gen_lshrdi3 (tmp_reg_src1, tmp_reg_src1, sh));\n+\t      emit_insn (gen_lshrdi3 (tmp_reg_src2, tmp_reg_src2, sh));\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_lshrsi3 (tmp_reg_src1, tmp_reg_src1, sh));\n+\t      emit_insn (gen_lshrsi3 (tmp_reg_src2, tmp_reg_src2, sh));\n+\t    }\n+\t}\n+\n+      /* We previously did a block that need 64->32 conversion but\n+\t the current block does not, so a label is needed to jump\n+\t to the end.  */\n+      if (generate_6432_conversion && !final_label\n+\t  && GET_MODE_SIZE (GET_MODE (target)) >= load_mode_size)\n+\tfinal_label = gen_label_rtx ();\n+\n+      /* Do we need a 64->32 conversion block?  */\n+      int remain = bytes - cmp_bytes;\n+      if (GET_MODE_SIZE (GET_MODE (target)) < GET_MODE_SIZE (load_mode))\n+\t{\n+\t  generate_6432_conversion = true;\n+\t  if (remain > 0 && !convert_label)\n+\t    convert_label = gen_label_rtx ();\n+\t}\n+\n+      if (GET_MODE_SIZE (GET_MODE (target)) >= GET_MODE_SIZE (load_mode))\n+\t{\n+\t  /* Target is larger than load size so we don't need to\n+\t     reduce result size.  */\n+\t  if (remain > 0)\n+\t    {\n+\t      /* This is not the last block, branch to the end if the result\n+\t\t of this subtract is not zero.  */\n+\t      if (!final_label)\n+\t\tfinal_label = gen_label_rtx ();\n+\t      rtx fin_ref = gen_rtx_LABEL_REF (VOIDmode, final_label);\n+\t      rtx cond = gen_reg_rtx (CCmode);\n+\t      rtx tmp = gen_rtx_MINUS (word_mode, tmp_reg_src1, tmp_reg_src2);\n+\t      rs6000_emit_dot_insn (tmp_reg_src2, tmp, 2, cond);\n+\t      emit_insn (gen_movsi (target, gen_lowpart (SImode, tmp_reg_src2)));\n+\t      rtx ne_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n+\t      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, ne_rtx,\n+\t\t\t\t\t\t fin_ref, pc_rtx);\n+\t      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t      JUMP_LABEL (j) = final_label;\n+\t      LABEL_NUSES (final_label) += 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (word_mode == DImode)\n+\t\t{\n+\t\t  emit_insn (gen_subdi3 (tmp_reg_src2, tmp_reg_src1,\n+\t\t\t\t\t tmp_reg_src2));\n+\t\t  emit_insn (gen_movsi (target,\n+\t\t\t\t\tgen_lowpart (SImode, tmp_reg_src2)));\n+\t\t}\n+\t      else\n+\t\temit_insn (gen_subsi3 (target, tmp_reg_src1, tmp_reg_src2));\n+\n+\t      if (final_label)\n+\t\t{\n+\t\t  rtx fin_ref = gen_rtx_LABEL_REF (VOIDmode, final_label);\n+\t\t  rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, fin_ref));\n+\t\t  JUMP_LABEL(j) = final_label;\n+\t\t  LABEL_NUSES (final_label) += 1;\n+\t\t  emit_barrier ();\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  generate_6432_conversion = true;\n+\t  if (remain > 0)\n+\t    {\n+\t      if (!convert_label)\n+\t\tconvert_label = gen_label_rtx ();\n+\n+\t      /* Compare to zero and branch to convert_label if not zero.  */\n+\t      rtx cvt_ref = gen_rtx_LABEL_REF (VOIDmode, convert_label);\n+\t      rtx cond = gen_reg_rtx (CCmode);\n+\t      rtx tmp = gen_rtx_MINUS (DImode, tmp_reg_src1, tmp_reg_src2);\n+\t      rs6000_emit_dot_insn (tmp_reg_src2, tmp, 2, cond);\n+\t      rtx ne_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n+\t      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, ne_rtx,\n+\t\t\t\t\t\t cvt_ref, pc_rtx);\n+\t      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t      JUMP_LABEL(j) = convert_label;\n+\t      LABEL_NUSES (convert_label) += 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Just do the subtract.  Since this is the last block the\n+\t\t convert code will be generated immediately following.  */\n+\t      emit_insn (gen_subdi3 (tmp_reg_src2, tmp_reg_src1,\n+\t\t\t\t     tmp_reg_src2));\n+\t    }\n+\t}\n+\n+      offset += cmp_bytes;\n+      bytes -= cmp_bytes;\n+    }\n+\n+  if (generate_6432_conversion)\n+    {\n+      if (convert_label)\n+\temit_label (convert_label);\n+\n+      /* We need to produce DI result from sub, then convert to target SI\n+\t while maintaining <0 / ==0 / >0 properties.\n+\t Segher's sequence: cntlzd 3,3 ; addi 3,3,-1 ; xori 3,3,63 */\n+      emit_insn (gen_clzdi2 (tmp_reg_src2, tmp_reg_src2));\n+      emit_insn (gen_adddi3 (tmp_reg_src2, tmp_reg_src2, GEN_INT (-1)));\n+      emit_insn (gen_xordi3 (tmp_reg_src2, tmp_reg_src2, GEN_INT (63)));\n+      emit_insn (gen_movsi (target, gen_lowpart (SImode, tmp_reg_src2)));\n+    }\n+\n+  if (final_label)\n+    emit_label (final_label);\n+\n+  gcc_assert (bytes == 0);\n+  return true;\n+}\n+\n \f\n /* Expand a block move operation, and return 1 if successful.  Return 0\n    if we should let the compiler generate normal code.\n@@ -19104,42 +19559,6 @@ rs6000_is_valid_2insn_and (rtx c, machine_mode mode)\n   return rs6000_is_valid_and_mask (GEN_INT (val + bit3 - bit2), mode);\n }\n \n-/* Emit a potentially record-form instruction, setting DST from SRC.\n-   If DOT is 0, that is all; otherwise, set CCREG to the result of the\n-   signed comparison of DST with zero.  If DOT is 1, the generated RTL\n-   doesn't care about the DST result; if DOT is 2, it does.  If CCREG\n-   is CR0 do a single dot insn (as a PARALLEL); otherwise, do a SET and\n-   a separate COMPARE.  */\n-\n-static void\n-rs6000_emit_dot_insn (rtx dst, rtx src, int dot, rtx ccreg)\n-{\n-  if (dot == 0)\n-    {\n-      emit_move_insn (dst, src);\n-      return;\n-    }\n-\n-  if (cc_reg_not_cr0_operand (ccreg, CCmode))\n-    {\n-      emit_move_insn (dst, src);\n-      emit_move_insn (ccreg, gen_rtx_COMPARE (CCmode, dst, const0_rtx));\n-      return;\n-    }\n-\n-  rtx ccset = gen_rtx_SET (ccreg, gen_rtx_COMPARE (CCmode, src, const0_rtx));\n-  if (dot == 1)\n-    {\n-      rtx clobber = gen_rtx_CLOBBER (VOIDmode, dst);\n-      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, ccset, clobber)));\n-    }\n-  else\n-    {\n-      rtx set = gen_rtx_SET (dst, src);\n-      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, ccset, set)));\n-    }\n-}\n-\n /* Emit the two insns to do an AND in mode MODE, with operands OPERANDS.\n    If EXPAND is true, split rotate-and-mask instructions we generate to\n    their constituent parts as well (this is used during expand); if DOT"}, {"sha": "7b995ac0f259c57c091ac7b3f1a718c1fecbc6b9", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f38dde2306d9a482c03eeaa59688a30d566c8ff/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f38dde2306d9a482c03eeaa59688a30d566c8ff/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=9f38dde2306d9a482c03eeaa59688a30d566c8ff", "patch": "@@ -8614,6 +8614,27 @@\n     FAIL;\n }\")\n \n+;; String/block compare insn.\n+;; Argument 0 is the target (result)\n+;; Argument 1 is the destination\n+;; Argument 2 is the source\n+;; Argument 3 is the length\n+;; Argument 4 is the alignment\n+\n+(define_expand \"cmpmemsi\"\n+  [(parallel [(set (match_operand:SI 0)\n+               (compare:SI (match_operand:BLK 1)\n+                           (match_operand:BLK 2)))\n+\t      (use (match_operand:SI 3))\n+\t      (use (match_operand:SI 4))])]\n+  \"\"\n+{\n+  if (expand_block_compare (operands))\n+    DONE;\n+  else\t\n+    FAIL;\n+})\n+\n ;; String/block move insn.\n ;; Argument 0 is the destination\n ;; Argument 1 is the source"}, {"sha": "c79a439803c1b37c5e7858d960545aed1e9060fc", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f38dde2306d9a482c03eeaa59688a30d566c8ff/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f38dde2306d9a482c03eeaa59688a30d566c8ff/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=9f38dde2306d9a482c03eeaa59688a30d566c8ff", "patch": "@@ -333,6 +333,10 @@ mblock-move-inline-limit=\n Target Report Var(rs6000_block_move_inline_limit) Init(0) RejectNegative Joined UInteger Save\n Specify how many bytes should be moved inline before calling out to memcpy/memmove.\n \n+mblock-compare-inline-limit=\n+Target Report Var(rs6000_block_compare_inline_limit) Init(5) RejectNegative Joined UInteger Save\n+Specify the maximum number pairs of load instructions that should be generated inline for the compare.  If the number needed exceeds the limit, a call to memcmp will be generated instead.\n+\n misel\n Target Report Mask(ISEL) Var(rs6000_isa_flags)\n Generate isel instructions."}]}