{"sha": "87c06c0d81aa4bf96a83d1bb8ea4946a25ac318f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdjMDZjMGQ4MWFhNGJmOTZhODNkMWJiOGVhNDk0NmEyNWFjMzE4Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-27T21:26:27Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-27T21:26:27Z"}, "message": "Initial revision\n\nFrom-SVN: r597", "tree": {"sha": "7bc2aed63e2330743e24db8e6cef898faa3939b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bc2aed63e2330743e24db8e6cef898faa3939b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87c06c0d81aa4bf96a83d1bb8ea4946a25ac318f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c06c0d81aa4bf96a83d1bb8ea4946a25ac318f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87c06c0d81aa4bf96a83d1bb8ea4946a25ac318f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c06c0d81aa4bf96a83d1bb8ea4946a25ac318f/comments", "author": null, "committer": null, "parents": [{"sha": "e2f088306fb40c833a9cda9ec288f9f8984f2854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2f088306fb40c833a9cda9ec288f9f8984f2854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2f088306fb40c833a9cda9ec288f9f8984f2854"}], "stats": {"total": 161, "additions": 161, "deletions": 0}, "files": [{"sha": "4943823401360b2e63b2b0806f3d34b68373ca50", "filename": "gcc/config/m68k/dpx2.h", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c06c0d81aa4bf96a83d1bb8ea4946a25ac318f/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c06c0d81aa4bf96a83d1bb8ea4946a25ac318f/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fdpx2.h?ref=87c06c0d81aa4bf96a83d1bb8ea4946a25ac318f", "patch": "@@ -0,0 +1,161 @@\n+/*\n+ * dpx2.h - Bull DPX/2 200 and 300 systems (m68k, SysVr3)\n+ *\n+ * $Id: dpx2.h,v 1.1 1992/03/11 04:21:30 sjg Exp sjg $\n+ */\n+\n+#include \"m68k.h\"\n+#undef SELECT_RTX_SECTION\n+#include \"svr3.h\"\n+\n+/* See m68k.h.  7 means 68020 with 68881. \n+ * We really have 68030, but this will get us going.  \n+ */\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 7\n+#endif\n+\n+#define OBJECT_FORMAT_COFF\n+#define NO_SYS_SIGLIST\n+\n+#ifdef CPP_PREDEFINES\n+#undef CPP_PREDEFINES\n+#endif\n+/*\n+ * define all the things the compiler should\n+ */\n+#ifdef ncl_mr\n+# define CPP_PREDEFINES \"-Dunix -Dbull -DDPX2 -DSVR3 -Dmc68000 -Dmc68020 -Dncl_mr=1\"\n+#else\n+# ifdef ncl_el\n+# define CPP_PREDEFINES \"-Dunix -Dbull -DDPX2 -DSVR3 -Dmc68000 -Dmc68020 -Dncl_el\"\n+# else\n+#   define CPP_PREDEFINES \"-Dunix -Dbull -DDPX2 -DSVR3 -Dmc68000 -Dmc68020\"\n+# endif\n+#endif\n+\n+#undef\tCPP_SPEC\n+/*\n+ * use -ansi to imply POSIX and XOPEN and BULL source\n+ * no -ansi implies _SYSV\n+ */\n+# define CPP_SPEC \"%{ansi:-D_POSIX_SOURCE -D_XOPEN_SOURCE -D_BULL_SOURCE}\\\n+ %{!ansi:-D_SYSV}\"\n+\n+#undef ASM_LONG\n+#define ASM_LONG \"\\t.long\"\n+\n+#define HAVE_ATEXIT\n+#undef DO_GLOBAL_CTORS_BODY\t\t/* don't use svr3.h version */\n+#undef DO_GLOBAL_DTORS_BODY\n+  \n+#if 0 /* def DEBUG */\n+/*\n+ * find out where cc1 aborts\n+ */\n+#define abort() do { fprintf(stderr, \"%s: aborting at line %d\\n\", \\\n+\t\t\t     __FILE__, __LINE__); \\\n+ kill(getpid(), 6); } while (0)\n+#endif\n+\n+/* \n+ * svr3.h says to use BSS_SECTION_FUNCTION\n+ * but no one appears to, and there is\n+ * no definition for m68k.\n+ */\n+#ifndef BSS_SECTION_FUNCTION\n+# undef EXTRA_SECTION_FUNCTIONS\n+# define EXTRA_SECTION_FUNCTIONS\t\\\n+  CONST_SECTION_FUNCTION\t\t\\\n+  INIT_SECTION_FUNCTION\t\t\t\\\n+  FINI_SECTION_FUNCTION\n+#endif\n+\n+#ifndef USE_GAS\n+/*\n+ * handle the native assembler.\n+ * this does NOT yet work, there is much left to do.\n+ * use GAS for now...\n+ */\n+#undef ASM_OUTPUT_SOURCE_FILENAME\n+#define ASM_OUTPUT_SOURCE_FILENAME(FILE, NA)\t\\\n+  do { fprintf ((FILE), \"\\t.file\\t'%s'\\n\", (NA)); } while (0)\n+\n+#undef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX \".\"\n+/* \n+ * we don't seem to support any of:\n+ * .globl\n+ * .even\n+ * .align\n+ * .ascii\n+ */\n+#undef ASM_GLOBALIZE_LABEL\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME) while (0)\n+#undef ASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(asm_out_file, align) while (0)\n+#define STRING_LIMIT\t(0)\n+#undef ASM_APP_ON\n+#define ASM_APP_ON \"\"\n+#undef ASM_APP_OFF\n+#define ASM_APP_OFF \"\"\n+/*\n+ * dc.b 'hello, world!'\n+ * dc.b 10,0\n+ * is how we have to output \"hello, world!\\n\"\n+ */\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(asm_out_file, p, thissize)\t\\\n+  do { register int i, c, f=0;\t\t\t\\\n+  for (i = 0; i < thissize; i++) { \t\t\\\n+    c = p[i];\t\t\t\t\t\\\n+    if (c == '\\'' || c < ' ' || c > 127) {\t\\\n+      switch(f) {\t\t\t\t\\\n+      case 0: /* need to output dc.b etc */\t\\\n+\tfprintf(asm_out_file, \"\\tdc.b %d\", c);\t\\\n+\tf=1;\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\\\n+      case 1:\t\t\t\t\t\\\n+\tfprintf(asm_out_file, \",%d\", c);\t\\\n+\tbreak;\t\t\t\t\t\\\n+      default:\t\t\t\t\t\\\n+\t/* close a string */\t\t\t\\\n+\tfprintf(asm_out_file, \"'\\n\\tdc.b %d\", c); \\\n+\tf=1;\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+    } else {\t\t\t\t\t\\\n+      switch(f) {\t\t\t\t\\\n+      case 0:\t\t\t\t\t\\\n+\tfprintf(asm_out_file, \"\\tdc.b '%c\", c);\t\\\n+\tf=2;\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\\\n+      case 2:\t\t\t\t\t\\\n+\tfprintf(asm_out_file, \"%c\", c);\t\t\\\n+\tbreak;\t\t\t\t\t\\\n+      default:\t\t\t\t\t\\\n+\tfprintf(asm_out_file, \"\\n\\tdc.b '%c\", c); \\\n+\tf=2;\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\\\n+  if (f==2)\t\t\t\t\t\\\n+    putc('\\'', asm_out_file);\t\t\t\\\n+  putc('\\n', asm_out_file); } while (0)\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#undef ASM_OUTPUT_REG_PUSH\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmove.l %s,-(sp)\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#undef ASM_OUTPUT_REG_POP\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmove.l (sp)+,%s\\n\", reg_names[REGNO])\n+\t\t\t\n+#endif /* ! use gas */\t\t\t"}]}