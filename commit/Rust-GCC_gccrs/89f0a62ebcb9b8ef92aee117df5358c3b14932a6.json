{"sha": "89f0a62ebcb9b8ef92aee117df5358c3b14932a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlmMGE2MmViY2I5YjhlZjkyYWVlMTE3ZGY1MzU4YzNiMTQ5MzJhNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2016-01-18T20:56:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2016-01-18T20:56:13Z"}, "message": "re PR target/69176 (ICE in in final_scan_insn, at final.c:2981 on aarch64-linux-gnu)\n\nPR target/69176\n\n  * config/aarch64/aarch64.md (add<GPI>3): Move long immediate\n  operands to pseudo only if CSE is expected.  Split long immediate\n  operands only after reload, and for the stack pointer.\n  (*add<GPI>3_pluslong): Remove.\n  (*addsi3_aarch64, *adddi3_aarch64): Merge into...\n  (*add<GPI>3_aarch64): ... here.  Add r/rk/Upl alternative.\n  (*addsi3_aarch64_uxtw): Add r/rk/Upl alternative.\n  (*add<GPI>3 peepholes): New.\n  (*add<GPI>3 splitters): New.\n  * config/aarch64/constraints.md (Upl): New.\n  * config/aarch64/predicates.md (aarch64_pluslong_strict_immedate): New.\n\nFrom-SVN: r232540", "tree": {"sha": "1da60c532e5dcdeb190b255ef1840a7547b0cf7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1da60c532e5dcdeb190b255ef1840a7547b0cf7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89f0a62ebcb9b8ef92aee117df5358c3b14932a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89f0a62ebcb9b8ef92aee117df5358c3b14932a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89f0a62ebcb9b8ef92aee117df5358c3b14932a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89f0a62ebcb9b8ef92aee117df5358c3b14932a6/comments", "author": null, "committer": null, "parents": [{"sha": "9585381acd709663a97f2c7b208a674a3ed4f4a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9585381acd709663a97f2c7b208a674a3ed4f4a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9585381acd709663a97f2c7b208a674a3ed4f4a9"}], "stats": {"total": 188, "additions": 118, "deletions": 70}, "files": [{"sha": "ffb8c2a2bbf91b7af318e99a512d1c0fa355555d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0a62ebcb9b8ef92aee117df5358c3b14932a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0a62ebcb9b8ef92aee117df5358c3b14932a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89f0a62ebcb9b8ef92aee117df5358c3b14932a6", "patch": "@@ -1,3 +1,18 @@\n+2016-01-18  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/69176\n+\t* config/aarch64/aarch64.md (add<GPI>3): Move long immediate\n+\toperands to pseudo only if CSE is expected.  Split long immediate\n+\toperands only after reload, and for the stack pointer.\n+\t(*add<GPI>3_pluslong): Remove.\n+\t(*addsi3_aarch64, *adddi3_aarch64): Merge into...\n+\t(*add<GPI>3_aarch64): ... here.  Add r/rk/Upl alternative.\n+\t(*addsi3_aarch64_uxtw): Add r/rk/Upl alternative.\n+\t(*add<GPI>3 peepholes): New.\n+\t(*add<GPI>3 splitters): New.\n+\t* config/aarch64/constraints.md (Upl): New.\n+\t* config/aarch64/predicates.md (aarch64_pluslong_strict_immedate): New.\n+\n 2016-01-18  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/69297\n@@ -408,7 +423,7 @@\n \n 2016-01-14  Nicklas Bo Jensen  <nbjensen@gmail.com>\n \n-        * doc/loop.texi (Loop Analysis and Representation): Document\n+\t* doc/loop.texi (Loop Analysis and Representation): Document\n \tloop_depth function.\n \n 2016-01-14  Tom de Vries  <tom@codesourcery.com>"}, {"sha": "bde231be69d13bd762a2da3eebc11bcfa6201913", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 93, "deletions": 69, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0a62ebcb9b8ef92aee117df5358c3b14932a6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0a62ebcb9b8ef92aee117df5358c3b14932a6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=89f0a62ebcb9b8ef92aee117df5358c3b14932a6", "patch": "@@ -1590,96 +1590,120 @@\n     (plus:GPI (match_operand:GPI 1 \"register_operand\" \"\")\n \t      (match_operand:GPI 2 \"aarch64_pluslong_operand\" \"\")))]\n   \"\"\n-  \"\n-  if (!aarch64_plus_operand (operands[2], VOIDmode))\n+{\n+  if (aarch64_pluslong_strict_immedate (operands[2], <MODE>mode))\n     {\n-      if (can_create_pseudo_p ())\n-\t{\n-\t  rtx tmp = gen_reg_rtx (<MODE>mode);\n-\t  emit_move_insn (tmp, operands[2]);\n-\t  operands[2] = tmp;\n-\t}\n-      else\n+      /* Give CSE the opportunity to share this constant across additions.  */\n+      if (!cse_not_expected && can_create_pseudo_p ())\n+        operands[2] = force_reg (<MODE>mode, operands[2]);\n+\n+      /* Split will refuse to operate on a modification to the stack pointer.\n+\t Aid the prologue and epilogue expanders by splitting this now.  */\n+      else if (reload_completed && operands[0] == stack_pointer_rtx)\n \t{\n-\t  HOST_WIDE_INT imm = INTVAL (operands[2]);\n-\t  imm = imm >= 0 ? imm & 0xfff : -(-imm & 0xfff);\n-\t  emit_insn (gen_add<mode>3 (operands[0], operands[1],\n-\t\t\t\t     GEN_INT (INTVAL (operands[2]) - imm)));\n+\t  HOST_WIDE_INT i = INTVAL (operands[2]);\n+\t  HOST_WIDE_INT s = (i >= 0 ? i & 0xfff : -(-i & 0xfff));\n+\t  emit_insn (gen_rtx_SET (operands[0],\n+\t\t\t\t  gen_rtx_PLUS (<MODE>mode, operands[1],\n+\t\t\t\t\t\tGEN_INT (i - s))));\n \t  operands[1] = operands[0];\n-\t  operands[2] = GEN_INT (imm);\n+\t  operands[2] = GEN_INT (s);\n \t}\n     }\n-  \"\n-)\n-\n-;; Find add with a 2-instruction immediate and merge into 2 add instructions.\n-\n-(define_insn_and_split \"*add<mode>3_pluslong\"\n-  [(set\n-    (match_operand:GPI 0 \"register_operand\" \"=r\")\n-    (plus:GPI (match_operand:GPI 1 \"register_operand\" \"r\")\n-\t      (match_operand:GPI 2 \"aarch64_pluslong_immediate\" \"i\")))]\n-  \"!aarch64_plus_operand (operands[2], VOIDmode)\n-   && !aarch64_move_imm (INTVAL (operands[2]), <MODE>mode)\"\n-  \"#\"\n-  \"&& true\"\n-  [(set (match_dup 0) (plus:GPI (match_dup 1) (match_dup 3)))\n-   (set (match_dup 0) (plus:GPI (match_dup 0) (match_dup 4)))]\n-  \"\n-    {\n-      HOST_WIDE_INT imm = INTVAL (operands[2]);\n-      imm = imm >= 0 ? imm & 0xfff : -(-imm & 0xfff);\n-      operands[3] = GEN_INT (INTVAL (operands[2]) - imm);\n-      operands[4] = GEN_INT (imm);\n-    }\n-  \"\n-)\n+})\n \n-(define_insn \"*addsi3_aarch64\"\n+(define_insn \"*add<mode>3_aarch64\"\n   [(set\n-    (match_operand:SI 0 \"register_operand\" \"=rk,rk,w,rk\")\n-    (plus:SI\n-     (match_operand:SI 1 \"register_operand\" \"%rk,rk,w,rk\")\n-     (match_operand:SI 2 \"aarch64_plus_operand\" \"I,r,w,J\")))]\n+    (match_operand:GPI 0 \"register_operand\" \"=rk,rk,w,rk,r\")\n+    (plus:GPI\n+     (match_operand:GPI 1 \"register_operand\" \"%rk,rk,w,rk,rk\")\n+     (match_operand:GPI 2 \"aarch64_pluslong_operand\" \"I,r,w,J,Upl\")))]\n   \"\"\n   \"@\n-  add\\\\t%w0, %w1, %2\n-  add\\\\t%w0, %w1, %w2\n-  add\\\\t%0.2s, %1.2s, %2.2s\n-  sub\\\\t%w0, %w1, #%n2\"\n-  [(set_attr \"type\" \"alu_imm,alu_sreg,neon_add,alu_imm\")\n-   (set_attr \"simd\" \"*,*,yes,*\")]\n+  add\\\\t%<w>0, %<w>1, %2\n+  add\\\\t%<w>0, %<w>1, %<w>2\n+  add\\\\t%<rtn>0<vas>, %<rtn>1<vas>, %<rtn>2<vas>\n+  sub\\\\t%<w>0, %<w>1, #%n2\n+  #\"\n+  [(set_attr \"type\" \"alu_imm,alu_sreg,neon_add,alu_imm,multiple\")\n+   (set_attr \"simd\" \"*,*,yes,*,*\")]\n )\n \n ;; zero_extend version of above\n (define_insn \"*addsi3_aarch64_uxtw\"\n   [(set\n-    (match_operand:DI 0 \"register_operand\" \"=rk,rk,rk\")\n+    (match_operand:DI 0 \"register_operand\" \"=rk,rk,rk,r\")\n     (zero_extend:DI\n-     (plus:SI (match_operand:SI 1 \"register_operand\" \"%rk,rk,rk\")\n-              (match_operand:SI 2 \"aarch64_plus_operand\" \"I,r,J\"))))]\n+     (plus:SI (match_operand:SI 1 \"register_operand\" \"%rk,rk,rk,rk\")\n+              (match_operand:SI 2 \"aarch64_pluslong_operand\" \"I,r,J,Upl\"))))]\n   \"\"\n   \"@\n   add\\\\t%w0, %w1, %2\n   add\\\\t%w0, %w1, %w2\n-  sub\\\\t%w0, %w1, #%n2\"\n-  [(set_attr \"type\" \"alu_imm,alu_sreg,alu_imm\")]\n+  sub\\\\t%w0, %w1, #%n2\n+  #\"\n+  [(set_attr \"type\" \"alu_imm,alu_sreg,alu_imm,multiple\")]\n )\n \n-(define_insn \"*adddi3_aarch64\"\n-  [(set\n-    (match_operand:DI 0 \"register_operand\" \"=rk,rk,rk,w\")\n-    (plus:DI\n-     (match_operand:DI 1 \"register_operand\" \"%rk,rk,rk,w\")\n-     (match_operand:DI 2 \"aarch64_plus_operand\" \"I,r,J,w\")))]\n-  \"\"\n-  \"@\n-  add\\\\t%x0, %x1, %2\n-  add\\\\t%x0, %x1, %x2\n-  sub\\\\t%x0, %x1, #%n2\n-  add\\\\t%d0, %d1, %d2\"\n-  [(set_attr \"type\" \"alu_imm,alu_sreg,alu_imm,neon_add\")\n-   (set_attr \"simd\" \"*,*,*,yes\")]\n+;; If there's a free register, and we can load the constant with a\n+;; single instruction, do so.  This has a chance to improve scheduling.\n+(define_peephole2\n+  [(match_scratch:GPI 3 \"r\")\n+   (set (match_operand:GPI 0 \"register_operand\")\n+\t(plus:GPI\n+\t  (match_operand:GPI 1 \"register_operand\")\n+\t  (match_operand:GPI 2 \"aarch64_pluslong_strict_immedate\")))]\n+  \"aarch64_move_imm (INTVAL (operands[2]), <MODE>mode)\"\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (match_dup 0) (plus:GPI (match_dup 1) (match_dup 3)))]\n+)\n+\n+(define_peephole2\n+  [(match_scratch:SI 3 \"r\")\n+   (set (match_operand:DI 0 \"register_operand\")\n+\t(zero_extend:DI\n+\t  (plus:SI\n+\t    (match_operand:SI 1 \"register_operand\")\n+\t    (match_operand:SI 2 \"aarch64_pluslong_strict_immedate\"))))]\n+  \"aarch64_move_imm (INTVAL (operands[2]), SImode)\"\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (match_dup 0) (zero_extend:DI (plus:SI (match_dup 1) (match_dup 3))))]\n+)\n+\n+;; After peephole2 has had a chance to run, split any remaining long\n+;; additions into two add immediates.\n+(define_split\n+  [(set (match_operand:GPI 0 \"register_operand\")\n+\t(plus:GPI\n+\t  (match_operand:GPI 1 \"register_operand\")\n+\t  (match_operand:GPI 2 \"aarch64_pluslong_strict_immedate\")))]\n+  \"epilogue_completed\"\n+  [(set (match_dup 0) (plus:GPI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (plus:GPI (match_dup 0) (match_dup 4)))]\n+  {\n+    HOST_WIDE_INT i = INTVAL (operands[2]);\n+    HOST_WIDE_INT s = (i >= 0 ? i & 0xfff : -(-i & 0xfff));\n+    operands[3] = GEN_INT (i - s);\n+    operands[4] = GEN_INT (s);\n+  }\n+)\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(zero_extend:DI\n+\t  (plus:SI\n+\t    (match_operand:SI 1 \"register_operand\")\n+\t    (match_operand:SI 2 \"aarch64_pluslong_strict_immedate\"))))]\n+  \"epilogue_completed\"\n+  [(set (match_dup 5) (plus:SI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (zero_extend:DI (plus:SI (match_dup 5) (match_dup 4))))]\n+  {\n+    HOST_WIDE_INT i = INTVAL (operands[2]);\n+    HOST_WIDE_INT s = (i >= 0 ? i & 0xfff : -(-i & 0xfff));\n+    operands[3] = GEN_INT (i - s);\n+    operands[4] = GEN_INT (s);\n+    operands[5] = gen_lowpart (SImode, operands[0]);\n+  }\n )\n \n (define_expand \"addti3\""}, {"sha": "d64a7ebe36fcc7e022441392d81d07cec07fd08b", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0a62ebcb9b8ef92aee117df5358c3b14932a6/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0a62ebcb9b8ef92aee117df5358c3b14932a6/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=89f0a62ebcb9b8ef92aee117df5358c3b14932a6", "patch": "@@ -35,6 +35,11 @@\n  (and (match_code \"const_int\")\n       (match_test \"aarch64_uimm12_shift (ival)\")))\n \n+(define_constraint \"Upl\"\n+  \"@internal A constant that matches two uses of add instructions.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"aarch64_pluslong_strict_immedate (op, VOIDmode)\")))\n+\n (define_constraint \"J\"\n  \"A constant that can be used with a SUB operation (once negated).\"\n  (and (match_code \"const_int\")"}, {"sha": "f3b514b7318bcd6463de3d7418c188a7b2a2ecd0", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0a62ebcb9b8ef92aee117df5358c3b14932a6/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0a62ebcb9b8ef92aee117df5358c3b14932a6/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=89f0a62ebcb9b8ef92aee117df5358c3b14932a6", "patch": "@@ -107,6 +107,10 @@\n   (and (match_code \"const_int\")\n        (match_test \"(INTVAL (op) < 0xffffff && INTVAL (op) > -0xffffff)\")))\n \n+(define_predicate \"aarch64_pluslong_strict_immedate\"\n+  (and (match_operand 0 \"aarch64_pluslong_immediate\")\n+       (not (match_operand 0 \"aarch64_plus_immediate\"))))\n+\n (define_predicate \"aarch64_pluslong_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"aarch64_pluslong_immediate\")))"}]}