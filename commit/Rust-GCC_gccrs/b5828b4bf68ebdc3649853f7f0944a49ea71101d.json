{"sha": "b5828b4bf68ebdc3649853f7f0944a49ea71101d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU4MjhiNGJmNjhlYmRjMzY0OTg1M2Y3ZjA5NDRhNDllYTcxMTAxZA==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2013-11-20T09:19:25Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2013-11-20T09:19:25Z"}, "message": "[AArch64] AArch64 SIMD Builtins Better Type Correctness.\n\ngcc/\n\t* gcc/config/aarch64/aarch64-builtins.c\n\t(aarch64_simd_itype): Remove.\n\t(aarch64_simd_builtin_datum): Remove itype, add\n\tqualifiers pointer.\n\t(VAR1): Use qualifiers.\n\t(aarch64_build_scalar_type): New.\n\t(aarch64_build_vector_type): Likewise.\n\t(aarch64_build_type): Likewise.\n\t(aarch64_init_simd_builtins): Refactor, remove special cases,\n\tconsolidate main loop.\n\t(aarch64_simd_expand_args): Likewise.\n\nFrom-SVN: r205092", "tree": {"sha": "7545d09d75eaaf3297b9f994f69b0d9630f28f35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7545d09d75eaaf3297b9f994f69b0d9630f28f35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5828b4bf68ebdc3649853f7f0944a49ea71101d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5828b4bf68ebdc3649853f7f0944a49ea71101d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5828b4bf68ebdc3649853f7f0944a49ea71101d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5828b4bf68ebdc3649853f7f0944a49ea71101d/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc6ebdca92e3a84397ea1d0b38a729ab5cbf933c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc6ebdca92e3a84397ea1d0b38a729ab5cbf933c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc6ebdca92e3a84397ea1d0b38a729ab5cbf933c"}], "stats": {"total": 1131, "additions": 407, "deletions": 724}, "files": [{"sha": "e323a391ff5b16fda9e97f40d5f7d8f7f71b0791", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5828b4bf68ebdc3649853f7f0944a49ea71101d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5828b4bf68ebdc3649853f7f0944a49ea71101d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5828b4bf68ebdc3649853f7f0944a49ea71101d", "patch": "@@ -1,3 +1,17 @@\n+2013-11-20  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* gcc/config/aarch64/aarch64-builtins.c\n+\t(aarch64_simd_itype): Remove.\n+\t(aarch64_simd_builtin_datum): Remove itype, add\n+\tqualifiers pointer.\n+\t(VAR1): Use qualifiers.\n+\t(aarch64_build_scalar_type): New.\n+\t(aarch64_build_vector_type): Likewise.\n+\t(aarch64_build_type): Likewise.\n+\t(aarch64_init_simd_builtins): Refactor, remove special cases,\n+\tconsolidate main loop.\n+\t(aarch64_simd_expand_args): Likewise.\n+\n 2013-11-19  Joshua J Cogliati  <jrincayc@yahoo.com>\n \n \tPR c/53001"}, {"sha": "fec7b22252986948952dc1c54e6e79da1b2d0e16", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 393, "deletions": 724, "changes": 1117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5828b4bf68ebdc3649853f7f0944a49ea71101d/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5828b4bf68ebdc3649853f7f0944a49ea71101d/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=b5828b4bf68ebdc3649853f7f0944a49ea71101d", "patch": "@@ -84,57 +84,101 @@ enum aarch64_simd_builtin_type_mode\n \n #define UP(X) X##_UP\n \n-typedef enum\n+#define SIMD_MAX_BUILTIN_ARGS 5\n+\n+enum aarch64_type_qualifiers\n {\n-  AARCH64_SIMD_BINOP,\n-  AARCH64_SIMD_TERNOP,\n-  AARCH64_SIMD_QUADOP,\n-  AARCH64_SIMD_UNOP,\n-  AARCH64_SIMD_GETLANE,\n-  AARCH64_SIMD_SETLANE,\n-  AARCH64_SIMD_CREATE,\n-  AARCH64_SIMD_DUP,\n-  AARCH64_SIMD_DUPLANE,\n-  AARCH64_SIMD_COMBINE,\n-  AARCH64_SIMD_SPLIT,\n-  AARCH64_SIMD_LANEMUL,\n-  AARCH64_SIMD_LANEMULL,\n-  AARCH64_SIMD_LANEMULH,\n-  AARCH64_SIMD_LANEMAC,\n-  AARCH64_SIMD_SCALARMUL,\n-  AARCH64_SIMD_SCALARMULL,\n-  AARCH64_SIMD_SCALARMULH,\n-  AARCH64_SIMD_SCALARMAC,\n-  AARCH64_SIMD_CONVERT,\n-  AARCH64_SIMD_FIXCONV,\n-  AARCH64_SIMD_SELECT,\n-  AARCH64_SIMD_RESULTPAIR,\n-  AARCH64_SIMD_REINTERP,\n-  AARCH64_SIMD_VTBL,\n-  AARCH64_SIMD_VTBX,\n-  AARCH64_SIMD_LOAD1,\n-  AARCH64_SIMD_LOAD1LANE,\n-  AARCH64_SIMD_STORE1,\n-  AARCH64_SIMD_STORE1LANE,\n-  AARCH64_SIMD_LOADSTRUCT,\n-  AARCH64_SIMD_LOADSTRUCTLANE,\n-  AARCH64_SIMD_STORESTRUCT,\n-  AARCH64_SIMD_STORESTRUCTLANE,\n-  AARCH64_SIMD_LOGICBINOP,\n-  AARCH64_SIMD_SHIFTINSERT,\n-  AARCH64_SIMD_SHIFTIMM,\n-  AARCH64_SIMD_SHIFTACC\n-} aarch64_simd_itype;\n+  /* T foo.  */\n+  qualifier_none = 0x0,\n+  /* unsigned T foo.  */\n+  qualifier_unsigned = 0x1, /* 1 << 0  */\n+  /* const T foo.  */\n+  qualifier_const = 0x2, /* 1 << 1  */\n+  /* T *foo.  */\n+  qualifier_pointer = 0x4, /* 1 << 2  */\n+  /* const T *foo.  */\n+  qualifier_const_pointer = 0x6, /* qualifier_const | qualifier_pointer  */\n+  /* Used when expanding arguments if an operand could\n+     be an immediate.  */\n+  qualifier_immediate = 0x8, /* 1 << 3  */\n+  qualifier_maybe_immediate = 0x10, /* 1 << 4  */\n+  /* void foo (...).  */\n+  qualifier_void = 0x20, /* 1 << 5  */\n+  /* Some patterns may have internal operands, this qualifier is an\n+     instruction to the initialisation code to skip this operand.  */\n+  qualifier_internal = 0x40, /* 1 << 6  */\n+  /* Some builtins should use the T_*mode* encoded in a simd_builtin_datum\n+     rather than using the type of the operand.  */\n+  qualifier_map_mode = 0x80, /* 1 << 7  */\n+  /* qualifier_pointer | qualifier_map_mode  */\n+  qualifier_pointer_map_mode = 0x84,\n+  /* qualifier_const_pointer | qualifier_map_mode  */\n+  qualifier_const_pointer_map_mode = 0x86\n+};\n \n typedef struct\n {\n   const char *name;\n-  const aarch64_simd_itype itype;\n   enum aarch64_simd_builtin_type_mode mode;\n   const enum insn_code code;\n   unsigned int fcode;\n+  enum aarch64_type_qualifiers *qualifiers;\n } aarch64_simd_builtin_datum;\n \n+static enum aarch64_type_qualifiers\n+aarch64_types_unop_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_none, qualifier_none };\n+#define TYPES_UNOP (aarch64_types_unop_qualifiers)\n+#define TYPES_CREATE (aarch64_types_unop_qualifiers)\n+#define TYPES_REINTERP (aarch64_types_unop_qualifiers)\n+static enum aarch64_type_qualifiers\n+aarch64_types_binop_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_none, qualifier_none, qualifier_maybe_immediate };\n+#define TYPES_BINOP (aarch64_types_binop_qualifiers)\n+static enum aarch64_type_qualifiers\n+aarch64_types_ternop_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_none, qualifier_none, qualifier_none, qualifier_none };\n+#define TYPES_TERNOP (aarch64_types_ternop_qualifiers)\n+static enum aarch64_type_qualifiers\n+aarch64_types_quadop_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_none, qualifier_none, qualifier_none,\n+      qualifier_none, qualifier_none };\n+#define TYPES_QUADOP (aarch64_types_quadop_qualifiers)\n+\n+static enum aarch64_type_qualifiers\n+aarch64_types_getlane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_none, qualifier_none, qualifier_immediate };\n+#define TYPES_GETLANE (aarch64_types_getlane_qualifiers)\n+#define TYPES_SHIFTIMM (aarch64_types_getlane_qualifiers)\n+static enum aarch64_type_qualifiers\n+aarch64_types_setlane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_none, qualifier_none, qualifier_none, qualifier_immediate };\n+#define TYPES_SETLANE (aarch64_types_setlane_qualifiers)\n+#define TYPES_SHIFTINSERT (aarch64_types_setlane_qualifiers)\n+#define TYPES_SHIFTACC (aarch64_types_setlane_qualifiers)\n+\n+static enum aarch64_type_qualifiers\n+aarch64_types_combine_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_none, qualifier_none, qualifier_none };\n+#define TYPES_COMBINE (aarch64_types_combine_qualifiers)\n+\n+static enum aarch64_type_qualifiers\n+aarch64_types_load1_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_none, qualifier_const_pointer_map_mode };\n+#define TYPES_LOAD1 (aarch64_types_load1_qualifiers)\n+#define TYPES_LOADSTRUCT (aarch64_types_load1_qualifiers)\n+\n+/* The first argument (return type) of a store should be void type,\n+   which we represent with qualifier_void.  Their first operand will be\n+   a DImode pointer to the location to store to, so we must use\n+   qualifier_map_mode | qualifier_pointer to build a pointer to the\n+   element type of the vector.  */\n+static enum aarch64_type_qualifiers\n+aarch64_types_store1_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_void, qualifier_pointer_map_mode, qualifier_none };\n+#define TYPES_STORE1 (aarch64_types_store1_qualifiers)\n+#define TYPES_STORESTRUCT (aarch64_types_store1_qualifiers)\n+\n #define CF0(N, X) CODE_FOR_aarch64_##N##X\n #define CF1(N, X) CODE_FOR_##N##X##1\n #define CF2(N, X) CODE_FOR_##N##X##2\n@@ -143,7 +187,7 @@ typedef struct\n #define CF10(N, X) CODE_FOR_##N##X\n \n #define VAR1(T, N, MAP, A) \\\n-  {#N, AARCH64_SIMD_##T, UP (A), CF##MAP (N, A), 0},\n+  {#N, UP (A), CF##MAP (N, A), 0, TYPES_##T},\n #define VAR2(T, N, MAP, A, B) \\\n   VAR1 (T, N, MAP, A) \\\n   VAR1 (T, N, MAP, B)\n@@ -282,118 +326,175 @@ static GTY(()) tree aarch64_builtin_decls[AARCH64_BUILTIN_MAX];\n #define NUM_DREG_TYPES 6\n #define NUM_QREG_TYPES 6\n \n+/* Return a tree for a signed or unsigned argument of either\n+   the mode specified by MODE, or the inner mode of MODE.  */\n+tree\n+aarch64_build_scalar_type (enum machine_mode mode, bool unsigned_p)\n+{\n+#undef INT_TYPES\n+#define INT_TYPES \\\n+  AARCH64_TYPE_BUILDER (QI) \\\n+  AARCH64_TYPE_BUILDER (HI) \\\n+  AARCH64_TYPE_BUILDER (SI) \\\n+  AARCH64_TYPE_BUILDER (DI) \\\n+  AARCH64_TYPE_BUILDER (EI) \\\n+  AARCH64_TYPE_BUILDER (OI) \\\n+  AARCH64_TYPE_BUILDER (CI) \\\n+  AARCH64_TYPE_BUILDER (XI) \\\n+  AARCH64_TYPE_BUILDER (TI) \\\n+\n+/* Statically declare all the possible types we might need.  */\n+#undef AARCH64_TYPE_BUILDER\n+#define AARCH64_TYPE_BUILDER(X) \\\n+  static tree X##_aarch64_type_node_s = NULL; \\\n+  static tree X##_aarch64_type_node_u = NULL;\n+\n+  INT_TYPES\n+\n+  static tree float_aarch64_type_node = NULL;\n+  static tree double_aarch64_type_node = NULL;\n+\n+  gcc_assert (!VECTOR_MODE_P (mode));\n+\n+/* If we've already initialised this type, don't initialise it again,\n+   otherwise ask for a new type of the correct size.  */\n+#undef AARCH64_TYPE_BUILDER\n+#define AARCH64_TYPE_BUILDER(X) \\\n+  case X##mode: \\\n+    if (unsigned_p) \\\n+      return (X##_aarch64_type_node_u \\\n+\t      ? X##_aarch64_type_node_u \\\n+\t      : X##_aarch64_type_node_u \\\n+\t\t  = make_unsigned_type (GET_MODE_PRECISION (mode))); \\\n+    else \\\n+       return (X##_aarch64_type_node_s \\\n+\t      ? X##_aarch64_type_node_s \\\n+\t      : X##_aarch64_type_node_s \\\n+\t\t  = make_signed_type (GET_MODE_PRECISION (mode))); \\\n+    break;\n+\n+  switch (mode)\n+    {\n+      INT_TYPES\n+      case SFmode:\n+\tif (!float_aarch64_type_node)\n+\t  {\n+\t    float_aarch64_type_node = make_node (REAL_TYPE);\n+\t    TYPE_PRECISION (float_aarch64_type_node) = FLOAT_TYPE_SIZE;\n+\t    layout_type (float_aarch64_type_node);\n+\t  }\n+\treturn float_aarch64_type_node;\n+\tbreak;\n+      case DFmode:\n+\tif (!double_aarch64_type_node)\n+\t  {\n+\t    double_aarch64_type_node = make_node (REAL_TYPE);\n+\t    TYPE_PRECISION (double_aarch64_type_node) = DOUBLE_TYPE_SIZE;\n+\t    layout_type (double_aarch64_type_node);\n+\t  }\n+\treturn double_aarch64_type_node;\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+tree\n+aarch64_build_vector_type (enum machine_mode mode, bool unsigned_p)\n+{\n+  tree eltype;\n+\n+#define VECTOR_TYPES \\\n+  AARCH64_TYPE_BUILDER (V16QI) \\\n+  AARCH64_TYPE_BUILDER (V8HI) \\\n+  AARCH64_TYPE_BUILDER (V4SI) \\\n+  AARCH64_TYPE_BUILDER (V2DI) \\\n+  AARCH64_TYPE_BUILDER (V8QI) \\\n+  AARCH64_TYPE_BUILDER (V4HI) \\\n+  AARCH64_TYPE_BUILDER (V2SI) \\\n+  \\\n+  AARCH64_TYPE_BUILDER (V4SF) \\\n+  AARCH64_TYPE_BUILDER (V2DF) \\\n+  AARCH64_TYPE_BUILDER (V2SF) \\\n+/* Declare our \"cache\" of values.  */\n+#undef AARCH64_TYPE_BUILDER\n+#define AARCH64_TYPE_BUILDER(X) \\\n+  static tree X##_aarch64_type_node_s = NULL; \\\n+  static tree X##_aarch64_type_node_u = NULL;\n+\n+  VECTOR_TYPES\n+\n+  gcc_assert (VECTOR_MODE_P (mode));\n+\n+#undef AARCH64_TYPE_BUILDER\n+#define AARCH64_TYPE_BUILDER(X) \\\n+  case X##mode: \\\n+    if (unsigned_p) \\\n+      return X##_aarch64_type_node_u \\\n+\t     ? X##_aarch64_type_node_u \\\n+\t     : X##_aarch64_type_node_u \\\n+\t\t= build_vector_type_for_mode (aarch64_build_scalar_type \\\n+\t\t\t\t\t\t(GET_MODE_INNER (mode), \\\n+\t\t\t\t\t\t unsigned_p), mode); \\\n+    else \\\n+       return X##_aarch64_type_node_s \\\n+\t      ? X##_aarch64_type_node_s \\\n+\t      : X##_aarch64_type_node_s \\\n+\t\t= build_vector_type_for_mode (aarch64_build_scalar_type \\\n+\t\t\t\t\t\t(GET_MODE_INNER (mode), \\\n+\t\t\t\t\t\t unsigned_p), mode); \\\n+    break;\n+\n+  switch (mode)\n+    {\n+      default:\n+\teltype = aarch64_build_scalar_type (GET_MODE_INNER (mode), unsigned_p);\n+\treturn build_vector_type_for_mode (eltype, mode);\n+\tbreak;\n+      VECTOR_TYPES\n+   }\n+}\n+\n+tree\n+aarch64_build_type (enum machine_mode mode, bool unsigned_p)\n+{\n+  if (VECTOR_MODE_P (mode))\n+    return aarch64_build_vector_type (mode, unsigned_p);\n+  else\n+    return aarch64_build_scalar_type (mode, unsigned_p);\n+}\n+\n static void\n aarch64_init_simd_builtins (void)\n {\n   unsigned int i, fcode = AARCH64_SIMD_BUILTIN_BASE + 1;\n \n-  /* Scalar type nodes.  */\n-  tree aarch64_simd_intQI_type_node;\n-  tree aarch64_simd_intHI_type_node;\n-  tree aarch64_simd_polyQI_type_node;\n-  tree aarch64_simd_polyHI_type_node;\n-  tree aarch64_simd_intSI_type_node;\n-  tree aarch64_simd_intDI_type_node;\n-  tree aarch64_simd_float_type_node;\n-  tree aarch64_simd_double_type_node;\n-\n-  /* Pointer to scalar type nodes.  */\n-  tree intQI_pointer_node;\n-  tree intHI_pointer_node;\n-  tree intSI_pointer_node;\n-  tree intDI_pointer_node;\n-  tree float_pointer_node;\n-  tree double_pointer_node;\n-\n-  /* Const scalar type nodes.  */\n-  tree const_intQI_node;\n-  tree const_intHI_node;\n-  tree const_intSI_node;\n-  tree const_intDI_node;\n-  tree const_float_node;\n-  tree const_double_node;\n-\n-  /* Pointer to const scalar type nodes.  */\n-  tree const_intQI_pointer_node;\n-  tree const_intHI_pointer_node;\n-  tree const_intSI_pointer_node;\n-  tree const_intDI_pointer_node;\n-  tree const_float_pointer_node;\n-  tree const_double_pointer_node;\n-\n-  /* Vector type nodes.  */\n-  tree V8QI_type_node;\n-  tree V4HI_type_node;\n-  tree V2SI_type_node;\n-  tree V2SF_type_node;\n-  tree V16QI_type_node;\n-  tree V8HI_type_node;\n-  tree V4SI_type_node;\n-  tree V4SF_type_node;\n-  tree V2DI_type_node;\n-  tree V2DF_type_node;\n-\n-  /* Scalar unsigned type nodes.  */\n-  tree intUQI_type_node;\n-  tree intUHI_type_node;\n-  tree intUSI_type_node;\n-  tree intUDI_type_node;\n-\n-  /* Opaque integer types for structures of vectors.  */\n-  tree intEI_type_node;\n-  tree intOI_type_node;\n-  tree intCI_type_node;\n-  tree intXI_type_node;\n-\n-  /* Pointer to vector type nodes.  */\n-  tree V8QI_pointer_node;\n-  tree V4HI_pointer_node;\n-  tree V2SI_pointer_node;\n-  tree V2SF_pointer_node;\n-  tree V16QI_pointer_node;\n-  tree V8HI_pointer_node;\n-  tree V4SI_pointer_node;\n-  tree V4SF_pointer_node;\n-  tree V2DI_pointer_node;\n-  tree V2DF_pointer_node;\n-\n-  /* Operations which return results as pairs.  */\n-  tree void_ftype_pv8qi_v8qi_v8qi;\n-  tree void_ftype_pv4hi_v4hi_v4hi;\n-  tree void_ftype_pv2si_v2si_v2si;\n-  tree void_ftype_pv2sf_v2sf_v2sf;\n-  tree void_ftype_pdi_di_di;\n-  tree void_ftype_pv16qi_v16qi_v16qi;\n-  tree void_ftype_pv8hi_v8hi_v8hi;\n-  tree void_ftype_pv4si_v4si_v4si;\n-  tree void_ftype_pv4sf_v4sf_v4sf;\n-  tree void_ftype_pv2di_v2di_v2di;\n-  tree void_ftype_pv2df_v2df_v2df;\n-\n-  tree reinterp_ftype_dreg[NUM_DREG_TYPES][NUM_DREG_TYPES];\n-  tree reinterp_ftype_qreg[NUM_QREG_TYPES][NUM_QREG_TYPES];\n-  tree dreg_types[NUM_DREG_TYPES], qreg_types[NUM_QREG_TYPES];\n-\n-  /* Create distinguished type nodes for AARCH64_SIMD vector element types,\n-     and pointers to values of such types, so we can detect them later.  */\n-  aarch64_simd_intQI_type_node =\n-    make_signed_type (GET_MODE_PRECISION (QImode));\n-  aarch64_simd_intHI_type_node =\n-    make_signed_type (GET_MODE_PRECISION (HImode));\n-  aarch64_simd_polyQI_type_node =\n+  /* In order that 'poly' types mangle correctly they must not share\n+     a base tree with the other scalar types, thus we must generate them\n+     as a special case.  */\n+  tree aarch64_simd_polyQI_type_node =\n     make_signed_type (GET_MODE_PRECISION (QImode));\n-  aarch64_simd_polyHI_type_node =\n+  tree aarch64_simd_polyHI_type_node =\n     make_signed_type (GET_MODE_PRECISION (HImode));\n-  aarch64_simd_intSI_type_node =\n-    make_signed_type (GET_MODE_PRECISION (SImode));\n-  aarch64_simd_intDI_type_node =\n-    make_signed_type (GET_MODE_PRECISION (DImode));\n-  aarch64_simd_float_type_node = make_node (REAL_TYPE);\n-  aarch64_simd_double_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (aarch64_simd_float_type_node) = FLOAT_TYPE_SIZE;\n-  TYPE_PRECISION (aarch64_simd_double_type_node) = DOUBLE_TYPE_SIZE;\n-  layout_type (aarch64_simd_float_type_node);\n-  layout_type (aarch64_simd_double_type_node);\n+\n+  /* Scalar type nodes.  */\n+  tree aarch64_simd_intQI_type_node = aarch64_build_type (QImode, false);\n+  tree aarch64_simd_intHI_type_node = aarch64_build_type (HImode, false);\n+  tree aarch64_simd_intSI_type_node = aarch64_build_type (SImode, false);\n+  tree aarch64_simd_intDI_type_node = aarch64_build_type (DImode, false);\n+  tree aarch64_simd_intTI_type_node = aarch64_build_type (TImode, false);\n+  tree aarch64_simd_intEI_type_node = aarch64_build_type (EImode, false);\n+  tree aarch64_simd_intOI_type_node = aarch64_build_type (OImode, false);\n+  tree aarch64_simd_intCI_type_node = aarch64_build_type (CImode, false);\n+  tree aarch64_simd_intXI_type_node = aarch64_build_type (XImode, false);\n+  tree aarch64_simd_intUQI_type_node = aarch64_build_type (QImode, true);\n+  tree aarch64_simd_intUHI_type_node = aarch64_build_type (HImode, true);\n+  tree aarch64_simd_intUSI_type_node = aarch64_build_type (SImode, true);\n+  tree aarch64_simd_intUDI_type_node = aarch64_build_type (DImode, true);\n+\n+  /* Float type nodes.  */\n+  tree aarch64_simd_float_type_node = aarch64_build_type (SFmode, false);\n+  tree aarch64_simd_double_type_node = aarch64_build_type (DFmode, false);\n \n   /* Define typedefs which exactly correspond to the modes we are basing vector\n      types on.  If you change these names you'll need to change\n@@ -414,518 +515,129 @@ aarch64_init_simd_builtins (void)\n \t\t\t\t\t     \"__builtin_aarch64_simd_poly8\");\n   (*lang_hooks.types.register_builtin_type) (aarch64_simd_polyHI_type_node,\n \t\t\t\t\t     \"__builtin_aarch64_simd_poly16\");\n-\n-  intQI_pointer_node = build_pointer_type (aarch64_simd_intQI_type_node);\n-  intHI_pointer_node = build_pointer_type (aarch64_simd_intHI_type_node);\n-  intSI_pointer_node = build_pointer_type (aarch64_simd_intSI_type_node);\n-  intDI_pointer_node = build_pointer_type (aarch64_simd_intDI_type_node);\n-  float_pointer_node = build_pointer_type (aarch64_simd_float_type_node);\n-  double_pointer_node = build_pointer_type (aarch64_simd_double_type_node);\n-\n-  /* Next create constant-qualified versions of the above types.  */\n-  const_intQI_node = build_qualified_type (aarch64_simd_intQI_type_node,\n-\t\t\t\t\t   TYPE_QUAL_CONST);\n-  const_intHI_node = build_qualified_type (aarch64_simd_intHI_type_node,\n-\t\t\t\t\t   TYPE_QUAL_CONST);\n-  const_intSI_node = build_qualified_type (aarch64_simd_intSI_type_node,\n-\t\t\t\t\t   TYPE_QUAL_CONST);\n-  const_intDI_node = build_qualified_type (aarch64_simd_intDI_type_node,\n-\t\t\t\t\t   TYPE_QUAL_CONST);\n-  const_float_node = build_qualified_type (aarch64_simd_float_type_node,\n-\t\t\t\t\t   TYPE_QUAL_CONST);\n-  const_double_node = build_qualified_type (aarch64_simd_double_type_node,\n-\t\t\t\t\t    TYPE_QUAL_CONST);\n-\n-  const_intQI_pointer_node = build_pointer_type (const_intQI_node);\n-  const_intHI_pointer_node = build_pointer_type (const_intHI_node);\n-  const_intSI_pointer_node = build_pointer_type (const_intSI_node);\n-  const_intDI_pointer_node = build_pointer_type (const_intDI_node);\n-  const_float_pointer_node = build_pointer_type (const_float_node);\n-  const_double_pointer_node = build_pointer_type (const_double_node);\n-\n-  /* Now create vector types based on our AARCH64 SIMD element types.  */\n-  /* 64-bit vectors.  */\n-  V8QI_type_node =\n-    build_vector_type_for_mode (aarch64_simd_intQI_type_node, V8QImode);\n-  V4HI_type_node =\n-    build_vector_type_for_mode (aarch64_simd_intHI_type_node, V4HImode);\n-  V2SI_type_node =\n-    build_vector_type_for_mode (aarch64_simd_intSI_type_node, V2SImode);\n-  V2SF_type_node =\n-    build_vector_type_for_mode (aarch64_simd_float_type_node, V2SFmode);\n-  /* 128-bit vectors.  */\n-  V16QI_type_node =\n-    build_vector_type_for_mode (aarch64_simd_intQI_type_node, V16QImode);\n-  V8HI_type_node =\n-    build_vector_type_for_mode (aarch64_simd_intHI_type_node, V8HImode);\n-  V4SI_type_node =\n-    build_vector_type_for_mode (aarch64_simd_intSI_type_node, V4SImode);\n-  V4SF_type_node =\n-    build_vector_type_for_mode (aarch64_simd_float_type_node, V4SFmode);\n-  V2DI_type_node =\n-    build_vector_type_for_mode (aarch64_simd_intDI_type_node, V2DImode);\n-  V2DF_type_node =\n-    build_vector_type_for_mode (aarch64_simd_double_type_node, V2DFmode);\n-\n-  /* Unsigned integer types for various mode sizes.  */\n-  intUQI_type_node = make_unsigned_type (GET_MODE_PRECISION (QImode));\n-  intUHI_type_node = make_unsigned_type (GET_MODE_PRECISION (HImode));\n-  intUSI_type_node = make_unsigned_type (GET_MODE_PRECISION (SImode));\n-  intUDI_type_node = make_unsigned_type (GET_MODE_PRECISION (DImode));\n-\n-  (*lang_hooks.types.register_builtin_type) (intUQI_type_node,\n-\t\t\t\t\t     \"__builtin_aarch64_simd_uqi\");\n-  (*lang_hooks.types.register_builtin_type) (intUHI_type_node,\n-\t\t\t\t\t     \"__builtin_aarch64_simd_uhi\");\n-  (*lang_hooks.types.register_builtin_type) (intUSI_type_node,\n-\t\t\t\t\t     \"__builtin_aarch64_simd_usi\");\n-  (*lang_hooks.types.register_builtin_type) (intUDI_type_node,\n-\t\t\t\t\t     \"__builtin_aarch64_simd_udi\");\n-\n-  /* Opaque integer types for structures of vectors.  */\n-  intEI_type_node = make_signed_type (GET_MODE_PRECISION (EImode));\n-  intOI_type_node = make_signed_type (GET_MODE_PRECISION (OImode));\n-  intCI_type_node = make_signed_type (GET_MODE_PRECISION (CImode));\n-  intXI_type_node = make_signed_type (GET_MODE_PRECISION (XImode));\n-\n-  (*lang_hooks.types.register_builtin_type) (intTI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (aarch64_simd_intTI_type_node,\n \t\t\t\t\t     \"__builtin_aarch64_simd_ti\");\n-  (*lang_hooks.types.register_builtin_type) (intEI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (aarch64_simd_intEI_type_node,\n \t\t\t\t\t     \"__builtin_aarch64_simd_ei\");\n-  (*lang_hooks.types.register_builtin_type) (intOI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (aarch64_simd_intOI_type_node,\n \t\t\t\t\t     \"__builtin_aarch64_simd_oi\");\n-  (*lang_hooks.types.register_builtin_type) (intCI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (aarch64_simd_intCI_type_node,\n \t\t\t\t\t     \"__builtin_aarch64_simd_ci\");\n-  (*lang_hooks.types.register_builtin_type) (intXI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (aarch64_simd_intXI_type_node,\n \t\t\t\t\t     \"__builtin_aarch64_simd_xi\");\n \n-  /* Pointers to vector types.  */\n-  V8QI_pointer_node = build_pointer_type (V8QI_type_node);\n-  V4HI_pointer_node = build_pointer_type (V4HI_type_node);\n-  V2SI_pointer_node = build_pointer_type (V2SI_type_node);\n-  V2SF_pointer_node = build_pointer_type (V2SF_type_node);\n-  V16QI_pointer_node = build_pointer_type (V16QI_type_node);\n-  V8HI_pointer_node = build_pointer_type (V8HI_type_node);\n-  V4SI_pointer_node = build_pointer_type (V4SI_type_node);\n-  V4SF_pointer_node = build_pointer_type (V4SF_type_node);\n-  V2DI_pointer_node = build_pointer_type (V2DI_type_node);\n-  V2DF_pointer_node = build_pointer_type (V2DF_type_node);\n-\n-  /* Operations which return results as pairs.  */\n-  void_ftype_pv8qi_v8qi_v8qi =\n-    build_function_type_list (void_type_node, V8QI_pointer_node,\n-\t\t\t      V8QI_type_node, V8QI_type_node, NULL);\n-  void_ftype_pv4hi_v4hi_v4hi =\n-    build_function_type_list (void_type_node, V4HI_pointer_node,\n-\t\t\t      V4HI_type_node, V4HI_type_node, NULL);\n-  void_ftype_pv2si_v2si_v2si =\n-    build_function_type_list (void_type_node, V2SI_pointer_node,\n-\t\t\t      V2SI_type_node, V2SI_type_node, NULL);\n-  void_ftype_pv2sf_v2sf_v2sf =\n-    build_function_type_list (void_type_node, V2SF_pointer_node,\n-\t\t\t      V2SF_type_node, V2SF_type_node, NULL);\n-  void_ftype_pdi_di_di =\n-    build_function_type_list (void_type_node, intDI_pointer_node,\n-\t\t\t      aarch64_simd_intDI_type_node,\n-\t\t\t      aarch64_simd_intDI_type_node, NULL);\n-  void_ftype_pv16qi_v16qi_v16qi =\n-    build_function_type_list (void_type_node, V16QI_pointer_node,\n-\t\t\t      V16QI_type_node, V16QI_type_node, NULL);\n-  void_ftype_pv8hi_v8hi_v8hi =\n-    build_function_type_list (void_type_node, V8HI_pointer_node,\n-\t\t\t      V8HI_type_node, V8HI_type_node, NULL);\n-  void_ftype_pv4si_v4si_v4si =\n-    build_function_type_list (void_type_node, V4SI_pointer_node,\n-\t\t\t      V4SI_type_node, V4SI_type_node, NULL);\n-  void_ftype_pv4sf_v4sf_v4sf =\n-    build_function_type_list (void_type_node, V4SF_pointer_node,\n-\t\t\t      V4SF_type_node, V4SF_type_node, NULL);\n-  void_ftype_pv2di_v2di_v2di =\n-    build_function_type_list (void_type_node, V2DI_pointer_node,\n-\t\t\t      V2DI_type_node, V2DI_type_node, NULL);\n-  void_ftype_pv2df_v2df_v2df =\n-    build_function_type_list (void_type_node, V2DF_pointer_node,\n-\t\t\t      V2DF_type_node, V2DF_type_node, NULL);\n-\n-  dreg_types[0] = V8QI_type_node;\n-  dreg_types[1] = V4HI_type_node;\n-  dreg_types[2] = V2SI_type_node;\n-  dreg_types[3] = V2SF_type_node;\n-  dreg_types[4] = aarch64_simd_intDI_type_node;\n-  dreg_types[5] = aarch64_simd_double_type_node;\n-\n-  qreg_types[0] = V16QI_type_node;\n-  qreg_types[1] = V8HI_type_node;\n-  qreg_types[2] = V4SI_type_node;\n-  qreg_types[3] = V4SF_type_node;\n-  qreg_types[4] = V2DI_type_node;\n-  qreg_types[5] = V2DF_type_node;\n-\n-  /* If NUM_DREG_TYPES != NUM_QREG_TYPES, we will need separate nested loops\n-     for qreg and dreg reinterp inits.  */\n-  for (i = 0; i < NUM_DREG_TYPES; i++)\n-    {\n-      int j;\n-      for (j = 0; j < NUM_DREG_TYPES; j++)\n-\t{\n-\t  reinterp_ftype_dreg[i][j]\n-\t    = build_function_type_list (dreg_types[i], dreg_types[j], NULL);\n-\t  reinterp_ftype_qreg[i][j]\n-\t    = build_function_type_list (qreg_types[i], qreg_types[j], NULL);\n-\t}\n-    }\n+  /* Unsigned integer types for various mode sizes.  */\n+  (*lang_hooks.types.register_builtin_type) (aarch64_simd_intUQI_type_node,\n+\t\t\t\t\t     \"__builtin_aarch64_simd_uqi\");\n+  (*lang_hooks.types.register_builtin_type) (aarch64_simd_intUHI_type_node,\n+\t\t\t\t\t     \"__builtin_aarch64_simd_uhi\");\n+  (*lang_hooks.types.register_builtin_type) (aarch64_simd_intUSI_type_node,\n+\t\t\t\t\t     \"__builtin_aarch64_simd_usi\");\n+  (*lang_hooks.types.register_builtin_type) (aarch64_simd_intUDI_type_node,\n+\t\t\t\t\t     \"__builtin_aarch64_simd_udi\");\n \n   for (i = 0; i < ARRAY_SIZE (aarch64_simd_builtin_data); i++, fcode++)\n     {\n+      bool print_type_signature_p = false;\n+      char type_signature[SIMD_MAX_BUILTIN_ARGS] = { 0 };\n       aarch64_simd_builtin_datum *d = &aarch64_simd_builtin_data[i];\n       const char *const modenames[] =\n-      {\n-\t\"v8qi\", \"v4hi\", \"v2si\", \"v2sf\", \"di\", \"df\",\n-\t\"v16qi\", \"v8hi\", \"v4si\", \"v4sf\", \"v2di\", \"v2df\",\n-\t\"ti\", \"ei\", \"oi\", \"xi\", \"si\", \"sf\", \"hi\", \"qi\"\n-      };\n+\t{\n+\t  \"v8qi\", \"v4hi\", \"v2si\", \"v2sf\", \"di\", \"df\",\n+\t  \"v16qi\", \"v8hi\", \"v4si\", \"v4sf\", \"v2di\", \"v2df\",\n+\t  \"ti\", \"ei\", \"oi\", \"xi\", \"si\", \"sf\", \"hi\", \"qi\"\n+\t};\n+      const enum machine_mode modes[] =\n+\t{\n+\t  V8QImode, V4HImode, V2SImode, V2SFmode, DImode, DFmode,\n+\t  V16QImode, V8HImode, V4SImode, V4SFmode, V2DImode,\n+\t  V2DFmode, TImode, EImode, OImode, XImode, SImode,\n+\t  SFmode, HImode, QImode\n+\t};\n       char namebuf[60];\n       tree ftype = NULL;\n       tree fndecl = NULL;\n-      int is_load = 0;\n-      int is_store = 0;\n \n       gcc_assert (ARRAY_SIZE (modenames) == T_MAX);\n \n       d->fcode = fcode;\n \n-      switch (d->itype)\n+      /* We must track two variables here.  op_num is\n+\t the operand number as in the RTL pattern.  This is\n+\t required to access the mode (e.g. V4SF mode) of the\n+\t argument, from which the base type can be derived.\n+\t arg_num is an index in to the qualifiers data, which\n+\t gives qualifiers to the type (e.g. const unsigned).\n+\t The reason these two variables may differ by one is the\n+\t void return type.  While all return types take the 0th entry\n+\t in the qualifiers array, there is no operand for them in the\n+\t RTL pattern.  */\n+      int op_num = insn_data[d->code].n_operands - 1;\n+      int arg_num = d->qualifiers[0] & qualifier_void\n+\t\t      ? op_num + 1\n+\t\t      : op_num;\n+      tree return_type = void_type_node, args = void_list_node;\n+      tree eltype;\n+\n+      /* Build a function type directly from the insn_data for this\n+\t builtin.  The build_function_type () function takes care of\n+\t removing duplicates for us.  */\n+      for (; op_num >= 0; arg_num--, op_num--)\n \t{\n-\tcase AARCH64_SIMD_LOAD1:\n-\tcase AARCH64_SIMD_LOAD1LANE:\n-\tcase AARCH64_SIMD_LOADSTRUCT:\n-\tcase AARCH64_SIMD_LOADSTRUCTLANE:\n-\t    is_load = 1;\n-\t  /* Fall through.  */\n-\tcase AARCH64_SIMD_STORE1:\n-\tcase AARCH64_SIMD_STORE1LANE:\n-\tcase AARCH64_SIMD_STORESTRUCT:\n-\tcase AARCH64_SIMD_STORESTRUCTLANE:\n-\t    if (!is_load)\n-\t      is_store = 1;\n-\t  /* Fall through.  */\n-\tcase AARCH64_SIMD_UNOP:\n-\tcase AARCH64_SIMD_BINOP:\n-\tcase AARCH64_SIMD_TERNOP:\n-\tcase AARCH64_SIMD_QUADOP:\n-\tcase AARCH64_SIMD_COMBINE:\n-\tcase AARCH64_SIMD_CONVERT:\n-\tcase AARCH64_SIMD_CREATE:\n-\tcase AARCH64_SIMD_DUP:\n-\tcase AARCH64_SIMD_DUPLANE:\n-\tcase AARCH64_SIMD_FIXCONV:\n-\tcase AARCH64_SIMD_GETLANE:\n-\tcase AARCH64_SIMD_LANEMAC:\n-\tcase AARCH64_SIMD_LANEMUL:\n-\tcase AARCH64_SIMD_LANEMULH:\n-\tcase AARCH64_SIMD_LANEMULL:\n-\tcase AARCH64_SIMD_LOGICBINOP:\n-\tcase AARCH64_SIMD_SCALARMAC:\n-\tcase AARCH64_SIMD_SCALARMUL:\n-\tcase AARCH64_SIMD_SCALARMULH:\n-\tcase AARCH64_SIMD_SCALARMULL:\n-\tcase AARCH64_SIMD_SELECT:\n-\tcase AARCH64_SIMD_SETLANE:\n-\tcase AARCH64_SIMD_SHIFTACC:\n-\tcase AARCH64_SIMD_SHIFTIMM:\n-\tcase AARCH64_SIMD_SHIFTINSERT:\n-\tcase AARCH64_SIMD_SPLIT:\n-\tcase AARCH64_SIMD_VTBL:\n-\tcase AARCH64_SIMD_VTBX:\n-\t  {\n-\t    int k;\n-\t    tree return_type = void_type_node, args = void_list_node;\n-\t    tree eltype;\n-\t    /* Build a function type directly from the insn_data for this\n-\t       builtin.  The build_function_type () function takes care of\n-\t       removing duplicates for us.  */\n-\n-\t    for (k = insn_data[d->code].n_operands -1; k >= 0; k--)\n-\t      {\n-\t\t/* Skip an internal operand for vget_{low, high}.  */\n-\t\tif (k == 2 && d->itype == AARCH64_SIMD_SPLIT)\n-\t\t  continue;\n-\n-\t\tif (is_load && k == 1)\n-\t\t  {\n-\t\t    /* AdvSIMD load patterns always have the memory operand\n-\t\t       (a DImode pointer) in the operand 1 position.  We\n-\t\t       want a const pointer to the element type in that\n-\t\t       position.  */\n-\t\t    gcc_assert (insn_data[d->code].operand[k].mode == DImode);\n-\n-\t\t    switch (d->mode)\n-\t\t      {\n-\t\t      case T_V8QI:\n-\t\t      case T_V16QI:\n-\t\t\teltype = const_intQI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V4HI:\n-\t\t      case T_V8HI:\n-\t\t\teltype = const_intHI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V2SI:\n-\t\t      case T_V4SI:\n-\t\t\teltype = const_intSI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V2SF:\n-\t\t      case T_V4SF:\n-\t\t\teltype = const_float_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_DI:\n-\t\t      case T_V2DI:\n-\t\t\teltype = const_intDI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_DF:\n-\t\t      case T_V2DF:\n-\t\t\teltype = const_double_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      default:\n-\t\t\tgcc_unreachable ();\n-\t\t      }\n-\t\t  }\n-\t\telse if (is_store && k == 0)\n-\t\t  {\n-\t\t    /* Similarly, AdvSIMD store patterns use operand 0 as\n-\t\t       the memory location to store to (a DImode pointer).\n-\t\t       Use a pointer to the element type of the store in\n-\t\t       that position.  */\n-\t\t    gcc_assert (insn_data[d->code].operand[k].mode == DImode);\n-\n-\t\t    switch (d->mode)\n-\t\t      {\n-\t\t      case T_V8QI:\n-\t\t      case T_V16QI:\n-\t\t\teltype = intQI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V4HI:\n-\t\t      case T_V8HI:\n-\t\t\teltype = intHI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V2SI:\n-\t\t      case T_V4SI:\n-\t\t\teltype = intSI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V2SF:\n-\t\t      case T_V4SF:\n-\t\t\teltype = float_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_DI:\n-\t\t      case T_V2DI:\n-\t\t\teltype = intDI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_DF:\n-\t\t      case T_V2DF:\n-\t\t\teltype = double_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      default:\n-\t\t\tgcc_unreachable ();\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    switch (insn_data[d->code].operand[k].mode)\n-\t\t      {\n-\t\t      case VOIDmode:\n-\t\t\teltype = void_type_node;\n-\t\t\tbreak;\n-\t\t\t/* Scalars.  */\n-\t\t      case QImode:\n-\t\t\teltype = aarch64_simd_intQI_type_node;\n-\t\t\tbreak;\n-\t\t      case HImode:\n-\t\t\teltype = aarch64_simd_intHI_type_node;\n-\t\t\tbreak;\n-\t\t      case SImode:\n-\t\t\teltype = aarch64_simd_intSI_type_node;\n-\t\t\tbreak;\n-\t\t      case SFmode:\n-\t\t\teltype = aarch64_simd_float_type_node;\n-\t\t\tbreak;\n-\t\t      case DFmode:\n-\t\t\teltype = aarch64_simd_double_type_node;\n-\t\t\tbreak;\n-\t\t      case DImode:\n-\t\t\teltype = aarch64_simd_intDI_type_node;\n-\t\t\tbreak;\n-\t\t      case TImode:\n-\t\t\teltype = intTI_type_node;\n-\t\t\tbreak;\n-\t\t      case EImode:\n-\t\t\teltype = intEI_type_node;\n-\t\t\tbreak;\n-\t\t      case OImode:\n-\t\t\teltype = intOI_type_node;\n-\t\t\tbreak;\n-\t\t      case CImode:\n-\t\t\teltype = intCI_type_node;\n-\t\t\tbreak;\n-\t\t      case XImode:\n-\t\t\teltype = intXI_type_node;\n-\t\t\tbreak;\n-\t\t\t/* 64-bit vectors.  */\n-\t\t      case V8QImode:\n-\t\t\teltype = V8QI_type_node;\n-\t\t\tbreak;\n-\t\t      case V4HImode:\n-\t\t\teltype = V4HI_type_node;\n-\t\t\tbreak;\n-\t\t      case V2SImode:\n-\t\t\teltype = V2SI_type_node;\n-\t\t\tbreak;\n-\t\t      case V2SFmode:\n-\t\t\teltype = V2SF_type_node;\n-\t\t\tbreak;\n-\t\t\t/* 128-bit vectors.  */\n-\t\t      case V16QImode:\n-\t\t\teltype = V16QI_type_node;\n-\t\t\tbreak;\n-\t\t      case V8HImode:\n-\t\t\teltype = V8HI_type_node;\n-\t\t\tbreak;\n-\t\t      case V4SImode:\n-\t\t\teltype = V4SI_type_node;\n-\t\t\tbreak;\n-\t\t      case V4SFmode:\n-\t\t\teltype = V4SF_type_node;\n-\t\t\tbreak;\n-\t\t      case V2DImode:\n-\t\t\teltype = V2DI_type_node;\n-\t\t\tbreak;\n-\t\t      case V2DFmode:\n-\t\t\teltype = V2DF_type_node;\n-\t\t\tbreak;\n-\t\t      default:\n-\t\t\tgcc_unreachable ();\n-\t\t      }\n-\t\t  }\n-\n-\t\tif (k == 0 && !is_store)\n-\t\t  return_type = eltype;\n-\t\telse\n-\t\t  args = tree_cons (NULL_TREE, eltype, args);\n-\t      }\n-\t    ftype = build_function_type (return_type, args);\n-\t  }\n-\t  break;\n+\t  enum machine_mode op_mode = insn_data[d->code].operand[op_num].mode;\n+\t  enum aarch64_type_qualifiers qualifiers = d->qualifiers[arg_num];\n \n-\tcase AARCH64_SIMD_RESULTPAIR:\n-\t  {\n-\t    switch (insn_data[d->code].operand[1].mode)\n-\t      {\n-\t      case V8QImode:\n-\t\tftype = void_ftype_pv8qi_v8qi_v8qi;\n-\t\tbreak;\n-\t      case V4HImode:\n-\t\tftype = void_ftype_pv4hi_v4hi_v4hi;\n-\t\tbreak;\n-\t      case V2SImode:\n-\t\tftype = void_ftype_pv2si_v2si_v2si;\n-\t\tbreak;\n-\t      case V2SFmode:\n-\t\tftype = void_ftype_pv2sf_v2sf_v2sf;\n-\t\tbreak;\n-\t      case DImode:\n-\t\tftype = void_ftype_pdi_di_di;\n-\t\tbreak;\n-\t      case V16QImode:\n-\t\tftype = void_ftype_pv16qi_v16qi_v16qi;\n-\t\tbreak;\n-\t      case V8HImode:\n-\t\tftype = void_ftype_pv8hi_v8hi_v8hi;\n-\t\tbreak;\n-\t      case V4SImode:\n-\t\tftype = void_ftype_pv4si_v4si_v4si;\n-\t\tbreak;\n-\t      case V4SFmode:\n-\t\tftype = void_ftype_pv4sf_v4sf_v4sf;\n-\t\tbreak;\n-\t      case V2DImode:\n-\t\tftype = void_ftype_pv2di_v2di_v2di;\n-\t\tbreak;\n-\t      case V2DFmode:\n-\t\tftype = void_ftype_pv2df_v2df_v2df;\n-\t\tbreak;\n-\t      default:\n-\t\tgcc_unreachable ();\n-\t      }\n-\t  }\n-\t  break;\n+\t  if (qualifiers & qualifier_unsigned)\n+\t    {\n+\t      type_signature[arg_num] = 'u';\n+\t      print_type_signature_p = true;\n+\t    }\n+\t  else\n+\t    type_signature[arg_num] = 's';\n+\n+\t  /* Skip an internal operand for vget_{low, high}.  */\n+\t  if (qualifiers & qualifier_internal)\n+\t    continue;\n+\n+\t  /* Some builtins have different user-facing types\n+\t     for certain arguments, encoded in d->mode.  */\n+\t  if (qualifiers & qualifier_map_mode)\n+\t      op_mode = modes[d->mode];\n+\n+\t  /* For pointers, we want a pointer to the basic type\n+\t     of the vector.  */\n+\t  if (qualifiers & qualifier_pointer && VECTOR_MODE_P (op_mode))\n+\t    op_mode = GET_MODE_INNER (op_mode);\n+\n+\t  eltype = aarch64_build_type (op_mode,\n+\t\t\t\t       qualifiers & qualifier_unsigned);\n+\n+\t  /* Add qualifiers.  */\n+\t  if (qualifiers & qualifier_const)\n+\t    eltype = build_qualified_type (eltype, TYPE_QUAL_CONST);\n+\n+\t  if (qualifiers & qualifier_pointer)\n+\t      eltype = build_pointer_type (eltype);\n+\n+\t  /* If we have reached arg_num == 0, we are at a non-void\n+\t     return type.  Otherwise, we are still processing\n+\t     arguments.  */\n+\t  if (arg_num == 0)\n+\t    return_type = eltype;\n+\t  else\n+\t    args = tree_cons (NULL_TREE, eltype, args);\n+\t}\n \n-\tcase AARCH64_SIMD_REINTERP:\n-\t  {\n-\t    /* We iterate over 6 doubleword types, then 6 quadword\n-\t       types.  */\n-\t    int rhs_d = d->mode % NUM_DREG_TYPES;\n-\t    int rhs_q = (d->mode - NUM_DREG_TYPES) % NUM_QREG_TYPES;\n-\t    switch (insn_data[d->code].operand[0].mode)\n-\t      {\n-\t      case V8QImode:\n-\t\tftype = reinterp_ftype_dreg[0][rhs_d];\n-\t\tbreak;\n-\t      case V4HImode:\n-\t\tftype = reinterp_ftype_dreg[1][rhs_d];\n-\t\tbreak;\n-\t      case V2SImode:\n-\t\tftype = reinterp_ftype_dreg[2][rhs_d];\n-\t\tbreak;\n-\t      case V2SFmode:\n-\t\tftype = reinterp_ftype_dreg[3][rhs_d];\n-\t\tbreak;\n-\t      case DImode:\n-\t\tftype = reinterp_ftype_dreg[4][rhs_d];\n-\t\tbreak;\n-\t      case DFmode:\n-\t\tftype = reinterp_ftype_dreg[5][rhs_d];\n-\t\tbreak;\n-\t      case V16QImode:\n-\t\tftype = reinterp_ftype_qreg[0][rhs_q];\n-\t\tbreak;\n-\t      case V8HImode:\n-\t\tftype = reinterp_ftype_qreg[1][rhs_q];\n-\t\tbreak;\n-\t      case V4SImode:\n-\t\tftype = reinterp_ftype_qreg[2][rhs_q];\n-\t\tbreak;\n-\t      case V4SFmode:\n-\t\tftype = reinterp_ftype_qreg[3][rhs_q];\n-\t\tbreak;\n-\t      case V2DImode:\n-\t\tftype = reinterp_ftype_qreg[4][rhs_q];\n-\t\tbreak;\n-\t      case V2DFmode:\n-\t\tftype = reinterp_ftype_qreg[5][rhs_q];\n-\t\tbreak;\n-\t      default:\n-\t\tgcc_unreachable ();\n-\t      }\n-\t  }\n-\t  break;\n+      ftype = build_function_type (return_type, args);\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n       gcc_assert (ftype != NULL);\n \n-      snprintf (namebuf, sizeof (namebuf), \"__builtin_aarch64_%s%s\",\n-\t\td->name, modenames[d->mode]);\n+      if (print_type_signature_p)\n+\tsnprintf (namebuf, sizeof (namebuf), \"__builtin_aarch64_%s%s_%s\",\n+\t\t  d->name, modenames[d->mode], type_signature);\n+      else\n+\tsnprintf (namebuf, sizeof (namebuf), \"__builtin_aarch64_%s%s\",\n+\t\t  d->name, modenames[d->mode]);\n \n       fndecl = add_builtin_function (namebuf, ftype, fcode, BUILT_IN_MD,\n \t\t\t\t     NULL, NULL_TREE);\n@@ -956,8 +668,6 @@ typedef enum\n   SIMD_ARG_STOP\n } builtin_simd_arg;\n \n-#define SIMD_MAX_BUILTIN_ARGS 5\n-\n static rtx\n aarch64_simd_expand_args (rtx target, int icode, int have_retval,\n \t\t\t  tree exp, ...)\n@@ -1085,99 +795,58 @@ aarch64_simd_expand_builtin (int fcode, tree exp, rtx target)\n {\n   aarch64_simd_builtin_datum *d =\n \t\t&aarch64_simd_builtin_data[fcode - (AARCH64_SIMD_BUILTIN_BASE + 1)];\n-  aarch64_simd_itype itype = d->itype;\n   enum insn_code icode = d->code;\n+  builtin_simd_arg args[SIMD_MAX_BUILTIN_ARGS];\n+  int num_args = insn_data[d->code].n_operands;\n+  int is_void = 0;\n+  int k;\n \n-  switch (itype)\n-    {\n-    case AARCH64_SIMD_UNOP:\n-      return aarch64_simd_expand_args (target, icode, 1, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_STOP);\n+  is_void = !!(d->qualifiers[0] & qualifier_void);\n \n-    case AARCH64_SIMD_BINOP:\n-      {\n-        rtx arg2 = expand_normal (CALL_EXPR_ARG (exp, 1));\n-        /* Handle constants only if the predicate allows it.  */\n-\tbool op1_const_int_p =\n-\t  (CONST_INT_P (arg2)\n-\t   && (*insn_data[icode].operand[2].predicate)\n-\t\t(arg2, insn_data[icode].operand[2].mode));\n-\treturn aarch64_simd_expand_args\n-\t  (target, icode, 1, exp,\n-\t   SIMD_ARG_COPY_TO_REG,\n-\t   op1_const_int_p ? SIMD_ARG_CONSTANT : SIMD_ARG_COPY_TO_REG,\n-\t   SIMD_ARG_STOP);\n-      }\n+  num_args += is_void;\n+\n+  for (k = 1; k < num_args; k++)\n+    {\n+      /* We have four arrays of data, each indexed in a different fashion.\n+\t qualifiers - element 0 always describes the function return type.\n+\t operands - element 0 is either the operand for return value (if\n+\t   the function has a non-void return type) or the operand for the\n+\t   first argument.\n+\t expr_args - element 0 always holds the first argument.\n+\t args - element 0 is always used for the return type.  */\n+      int qualifiers_k = k;\n+      int operands_k = k - is_void;\n+      int expr_args_k = k - 1;\n+\n+      if (d->qualifiers[qualifiers_k] & qualifier_immediate)\n+\targs[k] = SIMD_ARG_CONSTANT;\n+      else if (d->qualifiers[qualifiers_k] & qualifier_maybe_immediate)\n+\t{\n+\t  rtx arg\n+\t    = expand_normal (CALL_EXPR_ARG (exp,\n+\t\t\t\t\t    (expr_args_k)));\n+\t  /* Handle constants only if the predicate allows it.  */\n+\t  bool op_const_int_p =\n+\t    (CONST_INT_P (arg)\n+\t     && (*insn_data[icode].operand[operands_k].predicate)\n+\t\t(arg, insn_data[icode].operand[operands_k].mode));\n+\t  args[k] = op_const_int_p ? SIMD_ARG_CONSTANT : SIMD_ARG_COPY_TO_REG;\n+\t}\n+      else\n+\targs[k] = SIMD_ARG_COPY_TO_REG;\n \n-    case AARCH64_SIMD_TERNOP:\n-      return aarch64_simd_expand_args (target, icode, 1, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_STOP);\n-\n-    case AARCH64_SIMD_QUADOP:\n-      return aarch64_simd_expand_args (target, icode, 1, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_STOP);\n-    case AARCH64_SIMD_LOAD1:\n-    case AARCH64_SIMD_LOADSTRUCT:\n-      return aarch64_simd_expand_args (target, icode, 1, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG, SIMD_ARG_STOP);\n-\n-    case AARCH64_SIMD_STORE1:\n-    case AARCH64_SIMD_STORESTRUCT:\n-      return aarch64_simd_expand_args (target, icode, 0, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG, SIMD_ARG_STOP);\n-\n-    case AARCH64_SIMD_REINTERP:\n-      return aarch64_simd_expand_args (target, icode, 1, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG, SIMD_ARG_STOP);\n-\n-    case AARCH64_SIMD_CREATE:\n-      return aarch64_simd_expand_args (target, icode, 1, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG, SIMD_ARG_STOP);\n-\n-    case AARCH64_SIMD_COMBINE:\n-      return aarch64_simd_expand_args (target, icode, 1, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG, SIMD_ARG_STOP);\n-\n-    case AARCH64_SIMD_GETLANE:\n-      return aarch64_simd_expand_args (target, icode, 1, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_CONSTANT,\n-\t\t\t\t       SIMD_ARG_STOP);\n-\n-    case AARCH64_SIMD_SETLANE:\n-      return aarch64_simd_expand_args (target, icode, 1, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_CONSTANT,\n-\t\t\t\t       SIMD_ARG_STOP);\n-\n-    case AARCH64_SIMD_SHIFTIMM:\n-      return aarch64_simd_expand_args (target, icode, 1, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_CONSTANT,\n-\t\t\t\t       SIMD_ARG_STOP);\n-\n-    case AARCH64_SIMD_SHIFTACC:\n-    case AARCH64_SIMD_SHIFTINSERT:\n-      return aarch64_simd_expand_args (target, icode, 1, exp,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_COPY_TO_REG,\n-\t\t\t\t       SIMD_ARG_CONSTANT,\n-\t\t\t\t       SIMD_ARG_STOP);\n-\n-    default:\n-      gcc_unreachable ();\n     }\n+  args[k] = SIMD_ARG_STOP;\n+\n+  /* The interface to aarch64_simd_expand_args expects a 0 if\n+     the function is void, and a 1 if it is not.  */\n+  return aarch64_simd_expand_args\n+\t  (target, icode, !is_void, exp,\n+\t   args[1],\n+\t   args[2],\n+\t   args[3],\n+\t   args[4],\n+\t   SIMD_ARG_STOP);\n }\n \n /* Expand an expression EXP that calls a built-in function,"}]}