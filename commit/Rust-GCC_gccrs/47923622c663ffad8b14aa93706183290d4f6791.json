{"sha": "47923622c663ffad8b14aa93706183290d4f6791", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc5MjM2MjJjNjYzZmZhZDhiMTRhYTkzNzA2MTgzMjkwZDRmNjc5MQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-12T16:53:52Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-13T14:36:20Z"}, "message": "Cleanup range of address calculations.\n\nAlign EVRP and ranger for how ranges of ADDR_EXPR are calculated.\n\n\tgcc/\n\t* gimple-range.cc: (gimple_ranger::range_of_range_op): Check for\n\tADDR_EXPR and call range_of_address.\n\t(gimple_ranger::range_of_address): Rename from\n\trange_of_non_trivial_assignment and match vrp_stmt_computes_nonzero.\n\t* gimple-range.h: (range_of_address): Renamed.\n\t* range-op.cc: (pointer_table): Add INTEGER_CST handler.\n\tgcc/testsuite/\n\t* gcc.dg/tree-ssa/pr78655.c: New.", "tree": {"sha": "640a99535f2c668fbee54205870cd5f00deec8c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/640a99535f2c668fbee54205870cd5f00deec8c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47923622c663ffad8b14aa93706183290d4f6791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47923622c663ffad8b14aa93706183290d4f6791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47923622c663ffad8b14aa93706183290d4f6791", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47923622c663ffad8b14aa93706183290d4f6791/comments", "author": null, "committer": null, "parents": [{"sha": "ac91af71c93462cbc701bbd104fa21894bb15e86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac91af71c93462cbc701bbd104fa21894bb15e86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac91af71c93462cbc701bbd104fa21894bb15e86"}], "stats": {"total": 139, "additions": 107, "deletions": 32}, "files": [{"sha": "4f5d5024fa9fe0169987bb59930e429370db07b6", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 68, "deletions": 31, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47923622c663ffad8b14aa93706183290d4f6791/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47923622c663ffad8b14aa93706183290d4f6791/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=47923622c663ffad8b14aa93706183290d4f6791", "patch": "@@ -431,8 +431,9 @@ gimple_ranger::range_of_range_op (irange &r, gimple *s)\n       m_cache.register_dependency (lhs, op2);\n     }\n \n-  if (range_of_non_trivial_assignment (r, s))\n-    return true;\n+  if (gimple_code (s) == GIMPLE_ASSIGN\n+      && gimple_assign_rhs_code (s) == ADDR_EXPR)\n+    return range_of_address (r, s);\n \n   if (range_of_expr (range1, op1, s))\n     {\n@@ -446,48 +447,84 @@ gimple_ranger::range_of_range_op (irange &r, gimple *s)\n   return true;\n }\n \n-// Calculate the range of a non-trivial assignment.  That is, is one\n-// inolving arithmetic on an SSA name (for example, an ADDR_EXPR).\n+// Calculate the range of an assignment containing an ADDR_EXPR.\n // Return the range in R.\n-//\n-// If a range cannot be calculated, return false.\n+// If a range cannot be calculated, set it to VARYING and return true.\n \n bool\n-gimple_ranger::range_of_non_trivial_assignment (irange &r, gimple *stmt)\n+gimple_ranger::range_of_address (irange &r, gimple *stmt)\n {\n-  if (gimple_code (stmt) != GIMPLE_ASSIGN)\n-    return false;\n+  gcc_checking_assert (gimple_code (stmt) == GIMPLE_ASSIGN);\n+  gcc_checking_assert (gimple_assign_rhs_code (stmt) == ADDR_EXPR);\n \n-  tree base = gimple_range_base_of_assignment (stmt);\n-  if (base)\n+  bool strict_overflow_p;\n+  tree expr = gimple_assign_rhs1 (stmt);\n+  poly_int64 bitsize, bitpos;\n+  tree offset;\n+  machine_mode mode;\n+  int unsignedp, reversep, volatilep;\n+  tree base = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize,\n+\t\t\t\t   &bitpos, &offset, &mode, &unsignedp,\n+\t\t\t\t   &reversep, &volatilep);\n+\n+\n+  if (base != NULL_TREE\n+      && TREE_CODE (base) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n     {\n-      if (TREE_CODE (base) == MEM_REF)\n+      tree ssa = TREE_OPERAND (base, 0);\n+      gcc_checking_assert (irange::supports_type_p (TREE_TYPE (ssa)));\n+      range_of_expr (r, ssa, stmt);\n+      range_cast (r, TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+\n+      poly_offset_int off = 0;\n+      bool off_cst = false;\n+      if (offset == NULL_TREE || TREE_CODE (offset) == INTEGER_CST)\n \t{\n-\t  if (TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n-\t    {\n-\t      int_range_max range1;\n-\t      tree ssa = TREE_OPERAND (base, 0);\n-\t      if (range_of_expr (range1, ssa, stmt))\n-\t\t{\n-\t\t  tree type = TREE_TYPE (ssa);\n-\t\t  range_operator *op = range_op_handler (POINTER_PLUS_EXPR,\n-\t\t\t\t\t\t\t type);\n-\t\t  int_range<2> offset (TREE_OPERAND (base, 1),\n-\t\t\t\t       TREE_OPERAND (base, 1));\n-\t\t  op->fold_range (r, type, range1, offset);\n-\t\t  return true;\n-\t\t}\n-\t    }\n-\t  return false;\n+\t  off = mem_ref_offset (base);\n+\t  if (offset)\n+\t    off += poly_offset_int::from (wi::to_poly_wide (offset),\n+\t\t\t\t\t  SIGNED);\n+\t  off <<= LOG2_BITS_PER_UNIT;\n+\t  off += bitpos;\n+\t  off_cst = true;\n \t}\n-      if (gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n+      /* If &X->a is equal to X, the range of X is the result.  */\n+      if (off_cst && known_eq (off, 0))\n+\t  return true;\n+      else if (flag_delete_null_pointer_checks\n+\t       && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr)))\n+\t{\n+\t /* For -fdelete-null-pointer-checks -fno-wrapv-pointer we don't\n+\t allow going from non-NULL pointer to NULL.  */\n+\t   if(!range_includes_zero_p (&r))\n+\t    return true;\n+\t}\n+      /* If MEM_REF has a \"positive\" offset, consider it non-NULL\n+\t always, for -fdelete-null-pointer-checks also \"negative\"\n+\t ones.  Punt for unknown offsets (e.g. variable ones).  */\n+      if (!TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))\n+\t  && off_cst\n+\t  && known_ne (off, 0)\n+\t  && (flag_delete_null_pointer_checks || known_gt (off, 0)))\n \t{\n-\t  // Handle \"= &a\"  and return non-zero.\n \t  r = range_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n \t  return true;\n \t}\n+      r = int_range<2> (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+      return true;\n     }\n-  return false;\n+\n+  // Handle \"= &a\".\n+  if (tree_single_nonzero_warnv_p (expr, &strict_overflow_p))\n+    {\n+      r = range_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+      return true;\n+    }\n+\n+  // Otherwise return varying.\n+  r = int_range<2> (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+  return true;\n }\n \n // Calculate a range for phi statement S and return it in R."}, {"sha": "dde41e9e743769fc1432701b7a3f7a133883e395", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47923622c663ffad8b14aa93706183290d4f6791/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47923622c663ffad8b14aa93706183290d4f6791/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=47923622c663ffad8b14aa93706183290d4f6791", "patch": "@@ -62,7 +62,7 @@ class gimple_ranger : public range_query\n   ranger_cache m_cache;\n private:\n   bool range_of_phi (irange &r, gphi *phi);\n-  bool range_of_non_trivial_assignment (irange &r, gimple *s);\n+  bool range_of_address (irange &r, gimple *s);\n   bool range_of_builtin_call (irange &r, gcall *call);\n   bool range_with_loop_info (irange &r, tree name);\n   void range_of_ssa_name_with_loop_info (irange &, tree, class loop *,"}, {"sha": "b746aadb603172159cbeb2a35c14c2e98066f05e", "filename": "gcc/range-op.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47923622c663ffad8b14aa93706183290d4f6791/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47923622c663ffad8b14aa93706183290d4f6791/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=47923622c663ffad8b14aa93706183290d4f6791", "patch": "@@ -3328,6 +3328,7 @@ pointer_table::pointer_table ()\n   set (GT_EXPR, op_gt);\n   set (GE_EXPR, op_ge);\n   set (SSA_NAME, op_identity);\n+  set (INTEGER_CST, op_integer_cst);\n   set (ADDR_EXPR, op_addr);\n   set (NOP_EXPR, op_convert);\n   set (CONVERT_EXPR, op_convert);"}, {"sha": "e9158e072688e3dc741ac238f206ae3537f0d764", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr78655.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47923622c663ffad8b14aa93706183290d4f6791/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr78655.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47923622c663ffad8b14aa93706183290d4f6791/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr78655.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr78655.c?ref=47923622c663ffad8b14aa93706183290d4f6791", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-ccp -fno-tree-forwprop -fno-tree-fre -fdump-tree-evrp\" } */\n+\n+struct A{int a,b;};\n+inline int*f1(struct A*p){return&p->a;}   /* offset of 0.  */\n+inline int*f2(struct A*p){return&p->b;}   /* Offset of non-zero.  */\n+inline int*g(struct A*p){return(int*)p+1;} /* Always non-zero offet.  */\n+\n+/* Should be able to eliminate all calls to bad().  */\n+ \n+void bad(void);\n+\n+int\n+main() \n+{\n+  struct A* ptr = 0;\n+  struct A addr;\n+\n+  if (f1 (ptr) != 0)\n+    bad();\n+  if (f1 (&addr) == 0)\n+    bad();\n+\n+  if (f2 (ptr) == 0)\n+    bad();\n+  if (f2 (&addr) == 0)\n+    bad();\n+    \n+  if (g (ptr) == 0)\n+    bad();\n+  if (g (&addr) == 0)\n+    bad();\n+  \n+}\n+\n+/* { dg-final { scan-tree-dump-not \"bad\" \"evrp\"} } */\n+"}]}