{"sha": "22fa926f19ae0ebbeec9598592b0cecc9e3fcd87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJmYTkyNmYxOWFlMGViYmVlYzk1OTg1OTJiMGNlY2M5ZTNmY2Q4Nw==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2015-05-10T13:56:47Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2015-05-10T13:56:47Z"}, "message": "bound simplification refactoring\n\ngcc/fortran/\n\t* simplify.c (simplify_bound_dim): Don't check for emptyness\n\tin the case of cobound simplification.  Factor lower/upper\n\tbound differenciation before the actual simplification.\n\t(simplify_bound): Remove assumed shape specific simplification.  \n\tDon't give up early for the lbound of an assumed shape.\ngcc/testsuite/\n\t* gfortran.dg/bound_simplification_5.f90: New.\n\nFrom-SVN: r222979", "tree": {"sha": "2cb82e13799733c3035f9753c2df8ecb70db73b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cb82e13799733c3035f9753c2df8ecb70db73b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87/comments", "author": null, "committer": null, "parents": [{"sha": "edff0c0662c428774cdccdab4d1998e64ce8acf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edff0c0662c428774cdccdab4d1998e64ce8acf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edff0c0662c428774cdccdab4d1998e64ce8acf5"}], "stats": {"total": 172, "additions": 123, "deletions": 49}, "files": [{"sha": "b91f503d20a8c27ad89d73cf94e7f8ecc5062301", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=22fa926f19ae0ebbeec9598592b0cecc9e3fcd87", "patch": "@@ -1,3 +1,11 @@\n+2015-05-10  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* simplify.c (simplify_bound_dim): Don't check for emptyness\n+\tin the case of cobound simplification.  Factor lower/upper\n+\tbound differenciation before the actual simplification.\n+\t(simplify_bound): Remove assumed shape specific simplification.  \n+\tDon't give up early for the lbound of an assumed shape.\n+\n 2015-05-09  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/65894"}, {"sha": "f8d55fdcd06071d30b7018642877ba433a38a4c6", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 36, "deletions": 49, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=22fa926f19ae0ebbeec9598592b0cecc9e3fcd87", "patch": "@@ -3340,29 +3340,43 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n   /* Then, we need to know the extent of the given dimension.  */\n   if (coarray || (ref->u.ar.type == AR_FULL && !ref->next))\n     {\n+      gfc_expr *declared_bound;\n+      int empty_bound;\n+      bool constant_lbound, constant_ubound;\n+\n       l = as->lower[d-1];\n       u = as->upper[d-1];\n \n-      if (l->expr_type != EXPR_CONSTANT || u == NULL\n-\t  || u->expr_type != EXPR_CONSTANT)\n+      gcc_assert (l != NULL);\n+\n+      constant_lbound = l->expr_type == EXPR_CONSTANT;\n+      constant_ubound = u && u->expr_type == EXPR_CONSTANT;\n+\n+      empty_bound = upper ? 0 : 1;\n+      declared_bound = upper ? u : l;\n+\n+      if ((!upper && !constant_lbound)\n+\t  || (upper && !constant_ubound))\n \tgoto returnNull;\n \n-      if (mpz_cmp (l->value.integer, u->value.integer) > 0)\n+      if (!coarray)\n \t{\n-\t  /* Zero extent.  */\n-\t  if (upper)\n-\t    mpz_set_si (result->value.integer, 0);\n+\t  /* For {L,U}BOUND, the value depends on whether the array\n+\t     is empty.  We can nevertheless simplify if the declared bound\n+\t     has the same value as that of an empty array, in which case\n+\t     the result isn't dependent on the array emptyness.  */\n+\t  if (mpz_cmp_si (declared_bound->value.integer, empty_bound) == 0)\n+\t    mpz_set_si (result->value.integer, empty_bound);\n+\t  else if (!constant_lbound || !constant_ubound)\n+\t    /* Array emptyness can't be determined, we can't simplify.  */\n+\t    goto returnNull;\n+\t  else if (mpz_cmp (l->value.integer, u->value.integer) > 0)\n+\t    mpz_set_si (result->value.integer, empty_bound);\n \t  else\n-\t    mpz_set_si (result->value.integer, 1);\n+\t    mpz_set (result->value.integer, declared_bound->value.integer);\n \t}\n       else\n-\t{\n-\t  /* Nonzero extent.  */\n-\t  if (upper)\n-\t    mpz_set (result->value.integer, u->value.integer);\n-\t  else\n-\t    mpz_set (result->value.integer, l->value.integer);\n-\t}\n+\tmpz_set (result->value.integer, declared_bound->value.integer);\n     }\n   else\n     {\n@@ -3442,43 +3456,16 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \n  done:\n \n-  /* If the array shape is assumed shape or explicit, we can simplify lbound\n-     to 1 if the given lower bound is one because this matches what lbound\n-     should return for an empty array.  */\n-\n-  if (!upper && as && dim && dim->expr_type == EXPR_CONSTANT\n-      && (as->type == AS_ASSUMED_SHAPE || as->type == AS_EXPLICIT) \n-      && ref->u.ar.type != AR_SECTION)\n-    {\n-      /* Watch out for allocatable or pointer dummy arrays, they can have\n-\t lower bounds that are not equal to one.  */\n-      if (!(array->symtree && array->symtree->n.sym\n-\t    && (array->symtree->n.sym->attr.allocatable\n-\t\t|| array->symtree->n.sym->attr.pointer)))\n-\t{\n-\t  unsigned long int ndim;\n-\t  gfc_expr *lower, *res;\n-\n-\t  ndim = mpz_get_si (dim->value.integer) - 1;\n-\t  lower = as->lower[ndim];\n-\t  if (lower->expr_type == EXPR_CONSTANT\n-\t      && mpz_cmp_si (lower->value.integer, 1) == 0)\n-\t    {\n-\t      res = gfc_copy_expr (lower);\n-\t      if (kind)\n-\t\t{\n-\t\t  int nkind = mpz_get_si (kind->value.integer);\n-\t\t  res->ts.kind = nkind;\n-\t\t}\n-\t      return res;\n-\t    }\n-\t}\n-    }\n-\n-  if (as && (as->type == AS_DEFERRED || as->type == AS_ASSUMED_SHAPE\n-\t     || as->type == AS_ASSUMED_RANK))\n+  if (as && (as->type == AS_DEFERRED || as->type == AS_ASSUMED_RANK\n+\t     || (as->type == AS_ASSUMED_SHAPE && upper)))\n     return NULL;\n \n+  gcc_assert (!as\n+\t      || (as->type != AS_DEFERRED\n+\t\t  && array->expr_type == EXPR_VARIABLE\n+\t\t  && !array->symtree->n.sym->attr.allocatable\n+\t\t  && !array->symtree->n.sym->attr.pointer));\n+\n   if (dim == NULL)\n     {\n       /* Multi-dimensional bounds.  */"}, {"sha": "63ee9cc27f00e3dc79cb74907190595dea2184e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=22fa926f19ae0ebbeec9598592b0cecc9e3fcd87", "patch": "@@ -1,3 +1,7 @@\n+2015-05-10  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* gfortran.dg/bound_simplification_5.f90: New.\n+\n 2015-05-09  Jason Merrill  <jason@redhat.com>\n \n \t* lib/target-supports.exp (cxx_default): New global."}, {"sha": "7c9f040b84291a49a44d19764a0bd52727adc890", "filename": "gcc/testsuite/gfortran.dg/bound_simplification_5.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_simplification_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fa926f19ae0ebbeec9598592b0cecc9e3fcd87/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_simplification_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_simplification_5.f90?ref=22fa926f19ae0ebbeec9598592b0cecc9e3fcd87", "patch": "@@ -0,0 +1,75 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fcoarray=single -fdump-tree-original\" }\n+!\n+! Check that {L,U}{,CO}BOUND intrinsics are properly simplified.\n+!\n+  implicit none\n+\n+  type :: t\n+    integer :: c\n+  end type t\n+\n+  type(t) :: d(3:8) = t(7)\n+  type(t) :: e[5:9,-1:*]\n+  type(t) :: h(3), j(4), k(0)\n+\n+  !Test full arrays vs subarrays\n+  if (lbound(d,      1) /= 3) call abort\n+  if (lbound(d(3:5), 1) /= 1) call abort\n+  if (lbound(d%c,    1) /= 1) call abort\n+  if (ubound(d,      1) /= 8) call abort\n+  if (ubound(d(3:5), 1) /= 3) call abort\n+  if (ubound(d%c,    1) /= 6) call abort  \n+\n+  if (lcobound(e,   1) /=  5) call abort\n+  if (lcobound(e%c, 1) /=  5) call abort\n+  if (lcobound(e,   2) /= -1) call abort\n+  if (lcobound(e%c, 2) /= -1) call abort\n+  if (ucobound(e,   1) /=  9) call abort\n+  if (ucobound(e%c, 1) /=  9) call abort\n+  ! no simplification for ucobound(e{,%c}, dim=2)\n+\n+  if (any(lbound(d     ) /= [3])) call abort\n+  if (any(lbound(d(3:5)) /= [1])) call abort\n+  if (any(lbound(d%c   ) /= [1])) call abort\n+  if (any(ubound(d     ) /= [8])) call abort\n+  if (any(ubound(d(3:5)) /= [3])) call abort\n+  if (any(ubound(d%c   ) /= [6])) call abort  \n+\n+  if (any(lcobound(e  ) /=  [5, -1])) call abort\n+  if (any(lcobound(e%c) /=  [5, -1])) call abort\n+  ! no simplification for ucobound(e{,%c})\n+\n+  call test_empty_arrays(h, j, k)\n+\n+contains\n+  subroutine test_empty_arrays(a, c, d)\n+    type(t) :: a(:), c(-3:0), d(3:1)\n+    type(t) :: f(4:2), g(0:6)\n+\n+    if (lbound(a, 1) /=  1) call abort\n+    if (lbound(c, 1) /= -3) call abort\n+    if (lbound(d, 1) /=  1) call abort\n+    if (lbound(f, 1) /=  1) call abort\n+    if (lbound(g, 1) /=  0) call abort\n+\n+    if (ubound(c, 1) /=  0) call abort\n+    if (ubound(d, 1) /=  0) call abort\n+    if (ubound(f, 1) /=  0) call abort\n+    if (ubound(g, 1) /=  6) call abort\n+\n+    if (any(lbound(a) /= [ 1])) call abort\n+    if (any(lbound(c) /= [-3])) call abort\n+    if (any(lbound(d) /= [ 1])) call abort\n+    if (any(lbound(f) /= [ 1])) call abort\n+    if (any(lbound(g) /= [ 0])) call abort\n+\n+    if (any(ubound(c) /= [0])) call abort\n+    if (any(ubound(d) /= [0])) call abort\n+    if (any(ubound(f) /= [0])) call abort\n+    if (any(ubound(g) /= [6])) call abort\n+\n+  end subroutine\n+end\n+! { dg-final { scan-tree-dump-not \"abort\" \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}