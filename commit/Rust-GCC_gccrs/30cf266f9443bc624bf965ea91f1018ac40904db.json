{"sha": "30cf266f9443bc624bf965ea91f1018ac40904db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBjZjI2NmY5NDQzYmM2MjRiZjk2NWVhOTFmMTAxOGFjNDA5MDRkYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-05-19T08:24:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-05-19T08:24:50Z"}, "message": "recog.c (general_operand): Prohibit nonzero subreg bytes on subregs containing mem.\n\n\t* recog.c (general_operand): Prohibit nonzero subreg bytes on\n\tsubregs containing mem.\n\nFrom-SVN: r42308", "tree": {"sha": "b711abd409a64c86838850b5fb440217ba3be86c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b711abd409a64c86838850b5fb440217ba3be86c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30cf266f9443bc624bf965ea91f1018ac40904db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30cf266f9443bc624bf965ea91f1018ac40904db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30cf266f9443bc624bf965ea91f1018ac40904db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30cf266f9443bc624bf965ea91f1018ac40904db/comments", "author": null, "committer": null, "parents": [{"sha": "4ab7a7db6f7082c082e8909a1f10435f6514f298", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab7a7db6f7082c082e8909a1f10435f6514f298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ab7a7db6f7082c082e8909a1f10435f6514f298"}], "stats": {"total": 240, "additions": 90, "deletions": 150}, "files": [{"sha": "a086e993ef484ad18d6dbcca8a7171abbcca73fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30cf266f9443bc624bf965ea91f1018ac40904db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30cf266f9443bc624bf965ea91f1018ac40904db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30cf266f9443bc624bf965ea91f1018ac40904db", "patch": "@@ -1,3 +1,8 @@\n+Sat May 19 10:23:54 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* recog.c (general_operand): Prohibit nonzero subreg bytes on\n+\tsubregs containing mem.\n+\n Sat May 19 09:40:45 2001  Denis Chertykov  <denisc@overta.ru>\n \n \t* regrename.c (regrename_optimize): frame pointer register can"}, {"sha": "5e78336ea02c83072bd986404b5b86bf54f9ed58", "filename": "gcc/recog.c", "status": "modified", "additions": 85, "deletions": 150, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30cf266f9443bc624bf965ea91f1018ac40904db/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30cf266f9443bc624bf965ea91f1018ac40904db/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=30cf266f9443bc624bf965ea91f1018ac40904db", "patch": "@@ -440,10 +440,18 @@ validate_replace_rtx_1 (loc, from, to, object)\n   register const char *fmt;\n   register rtx x = *loc;\n   enum rtx_code code;\n+  enum machine_mode op0_mode = VOIDmode;\n+  int prev_changes = num_changes;\n+  rtx new;\n \n   if (!x)\n     return;\n+\n   code = GET_CODE (x);\n+  fmt = GET_RTX_FORMAT (code);\n+  if (fmt[0] == 'e')\n+    op0_mode = GET_MODE (XEXP (x, 0));\n+\n   /* X matches FROM if it is the same rtx or they are both referring to the\n      same register in the same mode.  Avoid calling rtx_equal_p unless the\n      operands look similar.  */\n@@ -459,166 +467,101 @@ validate_replace_rtx_1 (loc, from, to, object)\n       return;\n     }\n \n-  /* For commutative or comparison operations, try replacing each argument\n-     separately and seeing if we made any changes.  If so, put a constant\n-     argument last.*/\n-  if (GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == 'c')\n-    {\n-      int prev_changes = num_changes;\n+  /* Call ourseves recursivly to perform the replacements.  */\n \n-      validate_replace_rtx_1 (&XEXP (x, 0), from, to, object);\n-      validate_replace_rtx_1 (&XEXP (x, 1), from, to, object);\n-      if (prev_changes != num_changes && CONSTANT_P (XEXP (x, 0)))\n-\t{\n-\t  validate_change (object, loc,\n-\t\t\t   gen_rtx_fmt_ee (GET_RTX_CLASS (code) == 'c' ? code\n-\t\t\t\t\t   : swap_condition (code),\n-\t\t\t\t\t   GET_MODE (x), XEXP (x, 1),\n-\t\t\t\t\t   XEXP (x, 0)),\n-\t\t\t   1);\n-\t  x = *loc;\n-\t  code = GET_CODE (x);\n-\t}\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tvalidate_replace_rtx_1 (&XEXP (x, i), from, to, object);\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  validate_replace_rtx_1 (&XVECEXP (x, i, j), from, to, object);\n     }\n \n-  /* Note that if CODE's RTX_CLASS is \"c\" or \"<\" we will have already\n-     done the substitution, otherwise we won't.  */\n+  /* In case we didn't substituted, there is nothing to do.  */\n+  if (num_changes == prev_changes)\n+    return;\n+\n+  /* Allow substituted expression to have different mode.  This is used by\n+     regmove to change mode of pseudo register.  */\n+  if (fmt[0] == 'e' && GET_MODE (XEXP (x, 0)) != VOIDmode)\n+    op0_mode = GET_MODE (XEXP (x, 0));\n+\n+  /* Do changes needed to keep rtx consistent.  Don't do any other\n+     simplifications, as it is not our job.  */\n+\n+  if ((GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == 'c')\n+      && swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n+    {\n+      validate_change (object, loc,\n+\t\t       gen_rtx_fmt_ee (GET_RTX_CLASS (code) == 'c' ? code\n+\t\t\t\t       : swap_condition (code),\n+\t\t\t\t       GET_MODE (x), XEXP (x, 1),\n+\t\t\t\t       XEXP (x, 0)), 1);\n+      x = *loc;\n+      code = GET_CODE (x);\n+    }\n \n   switch (code)\n     {\n     case PLUS:\n       /* If we have a PLUS whose second operand is now a CONST_INT, use\n-\t plus_constant to try to simplify it.  */\n+         plus_constant to try to simplify it.\n+         ??? We may want later to remove this, once simplification is\n+         separated from this function.  */\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT && XEXP (x, 1) == to)\n-\tvalidate_change (object, loc, plus_constant (XEXP (x, 0), INTVAL (to)),\n-\t\t\t 1);\n-      return;\n-\n+\tvalidate_change (object, loc,\n+\t\t\t plus_constant (XEXP (x, 0), INTVAL (to)), 1);\n+      break;\n     case MINUS:\n-      if (GET_CODE (to) == CONST_INT && XEXP (x, 1) == from)\n-\t{\n-\t  validate_change (object, loc,\n-\t\t\t   plus_constant (XEXP (x, 0), - INTVAL (to)),\n-\t\t\t   1);\n-\t  return;\n-\t}\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  || GET_CODE (XEXP (x, 1)) == CONST_DOUBLE)\n+\tvalidate_change (object, loc,\n+\t\t\t simplify_gen_binary\n+\t\t\t (PLUS, GET_MODE (x), XEXP (x, 0),\n+\t\t\t  simplify_gen_unary (NEG,\n+\t\t\t\t\t      op0_mode, XEXP (x, 1),\n+\t\t\t\t\t      op0_mode)), 1);\n       break;\n-      \n     case ZERO_EXTEND:\n     case SIGN_EXTEND:\n-      /* In these cases, the operation to be performed depends on the mode\n-\t of the operand.  If we are replacing the operand with a VOIDmode\n-\t constant, we lose the information.  So try to simplify the operation\n-\t in that case.  */\n-      if (GET_MODE (to) == VOIDmode\n-\t  && (rtx_equal_p (XEXP (x, 0), from)\n-\t      || (GET_CODE (XEXP (x, 0)) == SUBREG\n-\t\t  && rtx_equal_p (SUBREG_REG (XEXP (x, 0)), from))))\n+      if (GET_MODE (XEXP (x, 0)) == VOIDmode)\n \t{\n-\t  rtx new = NULL_RTX;\n-\n-\t  /* If there is a subreg involved, crop to the portion of the\n-\t     constant that we are interested in.  */\n-\t  if (GET_CODE (XEXP (x, 0)) == SUBREG)\n-\t    {\n-\t      if (GET_MODE_SIZE (GET_MODE (XEXP (x, 0))) <= UNITS_PER_WORD)\n-\t\tto = operand_subword (to, \n-\t\t\t\t      (SUBREG_BYTE (XEXP (x, 0)) \n-\t\t\t\t       / UNITS_PER_WORD),\n-\t\t\t\t      0, GET_MODE (from));\n-\t      else if (GET_MODE_CLASS (GET_MODE (from)) == MODE_INT\n-\t\t       && (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n-\t\t\t   <= HOST_BITS_PER_WIDE_INT))\n-\t\t{\n-\t\t  int i = SUBREG_BYTE (XEXP (x, 0)) * BITS_PER_UNIT;\n-\t\t  HOST_WIDE_INT valh;\n-\t\t  unsigned HOST_WIDE_INT vall;\n-\n-\t\t  if (GET_CODE (to) == CONST_INT)\n-\t\t    {\n-\t\t      vall = INTVAL (to);\n-\t\t      valh = (HOST_WIDE_INT) vall < 0 ? ~0 : 0;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      vall = CONST_DOUBLE_LOW (to);\n-\t\t      valh = CONST_DOUBLE_HIGH (to);\n-\t\t    }\n-\n-\t\t  if (WORDS_BIG_ENDIAN)\n-\t\t    i = (GET_MODE_BITSIZE (GET_MODE (from))\n-\t\t\t - GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - i);\n-\t\t  if (i > 0 && i < HOST_BITS_PER_WIDE_INT)\n-\t\t    vall = vall >> i | valh << (HOST_BITS_PER_WIDE_INT - i);\n-\t\t  else if (i >= HOST_BITS_PER_WIDE_INT)\n-\t\t    vall = valh >> (i - HOST_BITS_PER_WIDE_INT);\n-\t\t  to = GEN_INT (trunc_int_for_mode (vall,\n-\t\t\t\t\t\t    GET_MODE (XEXP (x, 0))));\n-\t\t}\n-\t      else\n-\t\tto = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n-\t    }\n-\n-\t  /* If the above didn't fail, perform the extension from the\n-\t     mode of the operand (and not the mode of FROM).  */\n-\t  if (to)\n-\t    new = simplify_unary_operation (code, GET_MODE (x), to,\n-\t\t\t\t\t    GET_MODE (XEXP (x, 0)));\n-\n+\t  new = simplify_gen_unary (code, GET_MODE (x), XEXP (x, 0),\n+\t\t\t\t    op0_mode);\n \t  /* If any of the above failed, substitute in something that\n \t     we know won't be recognized.  */\n \t  if (!new)\n \t    new = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n-\n \t  validate_change (object, loc, new, 1);\n-\t  return;\n \t}\n       break;\n-\t\n     case SUBREG:\n-      /* In case we are replacing by constant, attempt to simplify it to\n-\t non-SUBREG expression.  We can't do this later, since the information\n-\t about inner mode may be lost.  */\n-      if (rtx_equal_p (SUBREG_REG (x), from))\n-        {\n-\t  rtx temp;\n-\t  temp = simplify_subreg (GET_MODE (x), to,\n-\t\t\t \t  GET_MODE (to) != VOIDmode\n-\t\t\t\t  ? GET_MODE (to) : GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t  SUBREG_BYTE (x));\n-\t  if (temp)\n-\t    {\n-\t      validate_change (object, loc, temp, 1);\n-\t      return;\n-\t    }\n-\t  /* Avoid creating of invalid SUBREGS.  */\n-\t  if (GET_MODE (from) == VOIDmode)\n-\t    {\n-\t      /* Substitute in something that we know won't be\n-\t\t recognized.  */\n-\t      to = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n-\t      validate_change (object, loc, to, 1);\n-\t      return;\n-\t    }\n-        }\n+      /* All subregs possible to simplify should be simplified.  */\n+      new = simplify_subreg (GET_MODE (x), SUBREG_REG (x), op0_mode,\n+\t\t\t     SUBREG_BYTE (x));\n+\n+      /* Subregs of VOIDmode operands are incorect.  */\n+      if (!new && GET_MODE (SUBREG_REG (x)) == VOIDmode)\n+\tnew = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n+      if (new)\n+\tvalidate_change (object, loc, new, 1);\n       break;\n-\n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n       /* If we are replacing a register with memory, try to change the memory\n-\t to be the mode required for memory in extract operations (this isn't\n-\t likely to be an insertion operation; if it was, nothing bad will\n-\t happen, we might just fail in some cases).  */\n+         to be the mode required for memory in extract operations (this isn't\n+         likely to be an insertion operation; if it was, nothing bad will\n+         happen, we might just fail in some cases).  */\n \n-      if (GET_CODE (from) == REG && GET_CODE (to) == MEM\n-\t  && rtx_equal_p (XEXP (x, 0), from)\n+      if (GET_CODE (XEXP (x, 0)) == MEM\n \t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && GET_CODE (XEXP (x, 2)) == CONST_INT\n-\t  && ! mode_dependent_address_p (XEXP (to, 0))\n-\t  && ! MEM_VOLATILE_P (to))\n+\t  && !mode_dependent_address_p (XEXP (XEXP (x, 0), 0))\n+\t  && !MEM_VOLATILE_P (XEXP (x, 0)))\n \t{\n \t  enum machine_mode wanted_mode = VOIDmode;\n-\t  enum machine_mode is_mode = GET_MODE (to);\n+\t  enum machine_mode is_mode = GET_MODE (XEXP (x, 0));\n \t  int pos = INTVAL (XEXP (x, 2));\n \n #ifdef HAVE_extzv\n@@ -646,42 +589,29 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t      rtx newmem;\n \n \t      /* If the bytes and bits are counted differently, we\n-\t\t must adjust the offset.  */\n+\t         must adjust the offset.  */\n \t      if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN)\n-\t\toffset = (GET_MODE_SIZE (is_mode) - GET_MODE_SIZE (wanted_mode)\n-\t\t\t  - offset);\n+\t\toffset =\n+\t\t  (GET_MODE_SIZE (is_mode) - GET_MODE_SIZE (wanted_mode) -\n+\t\t   offset);\n \n \t      pos %= GET_MODE_BITSIZE (wanted_mode);\n \n \t      newmem = gen_rtx_MEM (wanted_mode,\n-\t\t\t\t    plus_constant (XEXP (to, 0), offset));\n-\t      MEM_COPY_ATTRIBUTES (newmem, to);\n+\t\t\t\t    plus_constant (XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t\t   offset));\n+\t      MEM_COPY_ATTRIBUTES (newmem, XEXP (x, 0));\n \n \t      validate_change (object, &XEXP (x, 2), GEN_INT (pos), 1);\n \t      validate_change (object, &XEXP (x, 0), newmem, 1);\n \t    }\n \t}\n \n       break;\n-      \n+\n     default:\n       break;\n     }\n-      \n-  /* For commutative or comparison operations we've already performed\n-     replacements.  Don't try to perform them again.  */\n-  if (GET_RTX_CLASS (code) != '<' && GET_RTX_CLASS (code) != 'c')\n-    {\n-      fmt = GET_RTX_FORMAT (code);\n-      for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-        {\n-          if (fmt[i] == 'e')\n-            validate_replace_rtx_1 (&XEXP (x, i), from, to, object);\n-          else if (fmt[i] == 'E')\n-            for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-              validate_replace_rtx_1 (&XVECEXP (x, i, j), from, to, object);\n-        }\n-    }\n }\n \n /* Try replacing every occurrence of FROM in subexpression LOC of INSN\n@@ -1029,6 +959,11 @@ general_operand (op, mode)\n \t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))))\n \treturn 0;\n #endif\n+      /* Avoid memories with nonzero SUBREG_BYTE, as offsetting the memory\n+         may result in incorrect reference.  We should simplify all valid\n+         subregs of MEM anyway.  */\n+      if (SUBREG_BYTE (op) && GET_CODE (SUBREG_REG (op)) == MEM)\n+        return 0;\n \n       op = SUBREG_REG (op);\n       code = GET_CODE (op);"}]}