{"sha": "b29402f047f87d2f2a536b5d8af6b2d4e7f2c867", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI5NDAyZjA0N2Y4N2QyZjJhNTM2YjVkOGFmNmIyZDRlN2YyYzg2Nw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-09-11T13:39:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-09-11T13:39:11Z"}, "message": "lto.c (enum gtc_mode): Remove.\n\n2012-09-11  Richard Guenther  <rguenther@suse.de>\n\n\t* lto.c (enum gtc_mode): Remove.\n\t(struct type_pair_d): Adjust.\n\t(lookup_type_pair): Likewise.\n\t(gimple_type_leader): Do not mark as deletable.\n\t(gimple_lookup_type_leader): Adjust.\n\t(gtc_visit): Likewise.\n\t(gimple_types_compatible_p_1): Likewise.\n\t(gimple_types_compatible_p): Likewise.\n\t(gimple_type_hash): Likewise.\n\t(gimple_register_type): Likewise.\n\t(read_cgraph_and_symbols): Manage lifetime of tables\n\there.\n\nFrom-SVN: r191184", "tree": {"sha": "7388f102cb91ec8502f08ce3ff5007db8f5a9891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7388f102cb91ec8502f08ce3ff5007db8f5a9891"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b29402f047f87d2f2a536b5d8af6b2d4e7f2c867", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b29402f047f87d2f2a536b5d8af6b2d4e7f2c867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b29402f047f87d2f2a536b5d8af6b2d4e7f2c867", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b29402f047f87d2f2a536b5d8af6b2d4e7f2c867/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "178a71a9ad5a018315720e58dac692f943a761df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/178a71a9ad5a018315720e58dac692f943a761df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/178a71a9ad5a018315720e58dac692f943a761df"}], "stats": {"total": 92, "additions": 40, "deletions": 52}, "files": [{"sha": "fdbf896b1cb8dc3db103258734e0f81c86467df4", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b29402f047f87d2f2a536b5d8af6b2d4e7f2c867/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b29402f047f87d2f2a536b5d8af6b2d4e7f2c867/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=b29402f047f87d2f2a536b5d8af6b2d4e7f2c867", "patch": "@@ -1,3 +1,18 @@\n+2012-09-11  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto.c (enum gtc_mode): Remove.\n+\t(struct type_pair_d): Adjust.\n+\t(lookup_type_pair): Likewise.\n+\t(gimple_type_leader): Do not mark as deletable.\n+\t(gimple_lookup_type_leader): Adjust.\n+\t(gtc_visit): Likewise.\n+\t(gimple_types_compatible_p_1): Likewise.\n+\t(gimple_types_compatible_p): Likewise.\n+\t(gimple_type_hash): Likewise.\n+\t(gimple_register_type): Likewise.\n+\t(read_cgraph_and_symbols): Manage lifetime of tables\n+\there.\n+\n 2012-09-11  Richard Guenther  <rguenther@suse.de>\n \n \t* lto.c (gimple_types, type_hash_cache, enum gtc_mode,"}, {"sha": "e6b63550ff7fce3e8e497a067c9152b8428813ff", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 25, "deletions": 52, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b29402f047f87d2f2a536b5d8af6b2d4e7f2c867/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b29402f047f87d2f2a536b5d8af6b2d4e7f2c867/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b29402f047f87d2f2a536b5d8af6b2d4e7f2c867", "patch": "@@ -276,6 +276,8 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n   return data;\n }\n \n+\n+\n /* Global type table.  FIXME, it should be possible to re-use some\n    of the type hashing routines in tree.c (type_hash_canon, type_hash_lookup,\n    etc), but those assume that types were built with the various\n@@ -285,8 +287,6 @@ static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n   htab_t type_hash_cache;\n \n-enum gtc_mode { GTC_MERGE = 0, GTC_DIAG = 1 };\n-\n static hashval_t gimple_type_hash (const void *);\n \n /* Structure used to maintain a cache of some type pairs compared by\n@@ -295,16 +295,13 @@ static hashval_t gimple_type_hash (const void *);\n \n    \t-2: The pair (T1, T2) has just been inserted in the table.\n \t 0: T1 and T2 are different types.\n-\t 1: T1 and T2 are the same type.\n-\n-   The two elements in the SAME_P array are indexed by the comparison\n-   mode gtc_mode.  */\n+\t 1: T1 and T2 are the same type.  */\n \n struct type_pair_d\n {\n   unsigned int uid1;\n   unsigned int uid2;\n-  signed char same_p[2];\n+  signed char same_p;\n };\n typedef struct type_pair_d *type_pair_t;\n DEF_VEC_P(type_pair_t);\n@@ -323,9 +320,6 @@ lookup_type_pair (tree t1, tree t2)\n   unsigned int index;\n   unsigned int uid1, uid2;\n \n-  if (type_pair_cache == NULL)\n-    type_pair_cache = XCNEWVEC (struct type_pair_d, GIMPLE_TYPE_PAIR_SIZE);\n-\n   if (TYPE_UID (t1) < TYPE_UID (t2))\n     {\n       uid1 = TYPE_UID (t1);\n@@ -348,8 +342,7 @@ lookup_type_pair (tree t1, tree t2)\n \n   type_pair_cache [index].uid1 = uid1;\n   type_pair_cache [index].uid2 = uid2;\n-  type_pair_cache [index].same_p[0] = -2;\n-  type_pair_cache [index].same_p[1] = -2;\n+  type_pair_cache [index].same_p = -2;\n \n   return &type_pair_cache[index];\n }\n@@ -381,7 +374,7 @@ typedef struct GTY(()) gimple_type_leader_entry_s {\n } gimple_type_leader_entry;\n \n #define GIMPLE_TYPE_LEADER_SIZE 16381\n-static GTY((deletable, length(\"GIMPLE_TYPE_LEADER_SIZE\")))\n+static GTY((length(\"GIMPLE_TYPE_LEADER_SIZE\")))\n   gimple_type_leader_entry *gimple_type_leader;\n \n /* Lookup an existing leader for T and return it or NULL_TREE, if\n@@ -392,9 +385,6 @@ gimple_lookup_type_leader (tree t)\n {\n   gimple_type_leader_entry *leader;\n \n-  if (!gimple_type_leader)\n-    return NULL_TREE;\n-\n   leader = &gimple_type_leader[TYPE_UID (t) % GIMPLE_TYPE_LEADER_SIZE];\n   if (leader->type != t)\n     return NULL_TREE;\n@@ -403,7 +393,6 @@ gimple_lookup_type_leader (tree t)\n }\n \n \n-\n /* Return true if T1 and T2 have the same name.  If FOR_COMPLETION_P is\n    true then if any type has no name return false, otherwise return\n    true if both types have no names.  */\n@@ -535,11 +524,11 @@ gtc_visit (tree t1, tree t2,\n \n   /* Allocate a new cache entry for this comparison.  */\n   p = lookup_type_pair (t1, t2);\n-  if (p->same_p[GTC_MERGE] == 0 || p->same_p[GTC_MERGE] == 1)\n+  if (p->same_p == 0 || p->same_p == 1)\n     {\n       /* We have already decided whether T1 and T2 are the\n \t same, return the cached result.  */\n-      return p->same_p[GTC_MERGE] == 1;\n+      return p->same_p == 1;\n     }\n \n   if ((slot = pointer_map_contains (sccstate, p)) != NULL)\n@@ -574,7 +563,7 @@ gimple_types_compatible_p_1 (tree t1, tree t2, type_pair_t p,\n {\n   struct sccs *state;\n \n-  gcc_assert (p->same_p[GTC_MERGE] == -2);\n+  gcc_assert (p->same_p == -2);\n \n   state = XOBNEW (sccstate_obstack, struct sccs);\n   *pointer_map_insert (sccstate, p) = state;\n@@ -861,7 +850,7 @@ gimple_types_compatible_p_1 (tree t1, tree t2, type_pair_t p,\n \t  x = VEC_pop (type_pair_t, *sccstack);\n \t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n \t  cstate->on_sccstack = false;\n-\t  x->same_p[GTC_MERGE] = state->u.same_p;\n+\t  x->same_p = state->u.same_p;\n \t}\n       while (x != p);\n     }\n@@ -958,11 +947,11 @@ gimple_types_compatible_p (tree t1, tree t2)\n   /* If we've visited this type pair before (in the case of aggregates\n      with self-referential types), and we made a decision, return it.  */\n   p = lookup_type_pair (t1, t2);\n-  if (p->same_p[GTC_MERGE] == 0 || p->same_p[GTC_MERGE] == 1)\n+  if (p->same_p == 0 || p->same_p == 1)\n     {\n       /* We have already decided whether T1 and T2 are the\n \t same, return the cached result.  */\n-      return p->same_p[GTC_MERGE] == 1;\n+      return p->same_p == 1;\n     }\n \n   /* Now set up the SCC machinery for the comparison.  */\n@@ -1031,8 +1020,6 @@ visit (tree t, struct sccs *state, hashval_t v,\n   return v;\n }\n \n-\n-\n /* Hash NAME with the previous hash value V and return it.  */\n \n static hashval_t\n@@ -1304,10 +1291,6 @@ gimple_type_hash (const void *p)\n   void **slot;\n   struct tree_int_map m;\n \n-  if (type_hash_cache == NULL)\n-    type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n-\t\t\t\t       tree_int_map_eq, NULL);\n-\n   m.base.from = CONST_CAST_TREE (t);\n   if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n       && *slot)\n@@ -1325,6 +1308,7 @@ gimple_type_hash (const void *p)\n \n   return val;\n }\n+\n /* Returns nonzero if P1 and P2 are equal.  */\n \n static int\n@@ -1393,14 +1377,6 @@ static tree\n gimple_register_type (tree t)\n {\n   gcc_assert (TYPE_P (t));\n-\n-  if (!gimple_type_leader)\n-    gimple_type_leader = ggc_alloc_cleared_vec_gimple_type_leader_entry_s\n-\t\t\t\t(GIMPLE_TYPE_LEADER_SIZE);\n-\n-  if (gimple_types == NULL)\n-    gimple_types = htab_create_ggc (16381, gimple_type_hash, gimple_type_eq, 0);\n-\n   return gimple_register_type_1 (t, false);\n }\n \n@@ -2895,6 +2871,12 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \n   tree_with_vars = htab_create_ggc (101, htab_hash_pointer, htab_eq_pointer,\n \t\t\t\t    NULL);\n+  type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n+\t\t\t\t     tree_int_map_eq, NULL);\n+  type_pair_cache = XCNEWVEC (struct type_pair_d, GIMPLE_TYPE_PAIR_SIZE);\n+  gimple_type_leader = ggc_alloc_cleared_vec_gimple_type_leader_entry_s\n+\t\t        (GIMPLE_TYPE_LEADER_SIZE);\n+  gimple_types = htab_create_ggc (16381, gimple_type_hash, gimple_type_eq, 0);\n \n   if (!quiet_flag)\n     fprintf (stderr, \"Reading object files:\");\n@@ -2965,21 +2947,12 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   lto_fixup_decls (all_file_decl_data);\n   htab_delete (tree_with_vars);\n   tree_with_vars = NULL;\n-  if (gimple_types)\n-    {\n-      htab_delete (gimple_types);\n-      gimple_types = NULL;\n-    }\n-  if (type_hash_cache)\n-    {\n-      htab_delete (type_hash_cache);\n-      type_hash_cache = NULL;\n-    }\n-  if (type_pair_cache)\n-    {\n-      free (type_pair_cache);\n-      type_pair_cache = NULL;\n-    }\n+  htab_delete (gimple_types);\n+  gimple_types = NULL;\n+  htab_delete (type_hash_cache);\n+  type_hash_cache = NULL;\n+  free (type_pair_cache);\n+  type_pair_cache = NULL;\n   gimple_type_leader = NULL;\n   free_gimple_type_tables ();\n   ggc_collect ();"}]}