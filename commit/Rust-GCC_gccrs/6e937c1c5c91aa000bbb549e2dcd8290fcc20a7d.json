{"sha": "6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU5MzdjMWM1YzkxYWEwMDBiYmI1NDllMmRjZDgyOTBmY2MyMGE3ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-02-02T12:32:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-02-02T12:32:01Z"}, "message": "[multiple changes]\n\n2004-02-02  Vincent Celier  <celier@gnat.com>\n\n\t* gprcmd.adb (Check_Args): If condition is false, print the invoked\n\tcomment before the usage.\n\tGprcmd: Fail when command is not recognized.\n\t(Usage): Document command \"prefix\"\n\n\t* g-md5.adb (Digest): Process last block.\n\t(Update): Do not process last block. Store remaining characters and\n\tlength in Context.\n\n\t* g-md5.ads (Update): Document that several call to update are\n\tequivalent to one call with the concatenated string.\n\t(Context): Add fields to allow new Update behaviour.\n\n\t* fname-uf.ads/adb (Get_File_Name): New Boolean parameter May_Fail,\n\tdefaulted to False.\n\tWhen May_Fail is True and no existing file can be found, return No_File.\n\n\t* 6vcstrea.adb: Inlined functions are now wrappers to implementation\n\tfunctions.\n\n\t* lib-writ.adb (Write_With_Lines): When body file does not exist, use\n\tspec file name instead on the W line.\n\n2004-02-02  Robert Dewar  <dewar@gnat.com>\n\n\t* ali.adb: Read and acquire info from new format restrictions lines\n\n\t* bcheck.adb: Add circuits for checking restrictions with parameters\n\n\t* bindgen.adb: Output dummy restrictions data\n\tTo be changed later\n\n\t* ali.ads, checks.adb, exp_aggr.adb, exp_attr.adb, exp_ch11.adb,\n\texp_ch3.adb, exp_ch5.adb, exp_ch6.adb, exp_ch7.adb, exp_util.adb,\n\tfreeze.adb, gnat1drv.adb, sem_attr.adb, sem_ch10.adb, sem_ch11.adb,\n\tsem_ch12.adb, targparm.adb, targparm.ads, tbuild.adb, sem_ch2.adb,\n\tsem_elab.adb, sem_res.adb: Minor changes for new restrictions handling.\n\n\t* exp_ch9.adb (Build_Master_Entity): Cleanup the code (also suppresses\n\tthe warning message on access to possibly uninitialized variable S)\n\tMinor changes for new restrictions handling.\n\n\t* gnatbind.adb: Minor reformatting\n\tMinor changes for new restrictions handling\n\tMove circuit for -r processing here from bcheck (cleaner)\n\n\t* gnatcmd.adb, gnatlink.adb: Minor reformatting\n\n\t* lib-writ.adb: Output new format restrictions lines\n\n\t* lib-writ.ads: Document new R format lines for new restrictions\n\thandling.\n\n\t* s-restri.ads/adb: New files\n\n\t* Makefile.rtl: Add entry for s-restri.ads/adb\n\n\t* par-ch3.adb: Fix bad error messages starting with upper case letter\n\tMinor reformatting\n\n\t* restrict.adb: Major rewrite throughout for new restrictions handling\n\tMajor point is to handle restrictions with parameters\n\n\t* restrict.ads: Major changes in interface to handle restrictions with\n\tparameters. Also generally simplifies setting of restrictions.\n\n\t* snames.ads/adb: New entry for proper handling of No_Requeue\n\n\t* sem_ch3.adb (Count_Tasks): New circuitry for implementing Max_Tasks\n\trestriction counting.\n\tOther minor changes for new restrictions handling\n\n\t* sem_prag.adb: No_Requeue is a synonym for No_Requeue_Statements.\n\tRestriction_Warnings now allows full parameter notation\n\tMajor rewrite of Restrictions for new restrictions handling\n\n2004-02-02  Javier Miranda  <miranda@gnat.com>\n\n\t* par-ch3.adb (P_Identifier_Declarations): Give support to the Ada 0Y\n\tsyntax rule for object renaming declarations.\n\t(P_Array_Type_Definition): Give support for the Ada 0Y syntax rule for\n\tcomponent definitions.\n\n\t* sem_ch3.adb (Analyze_Component_Declaration): Give support to access\n\tcomponents.\n\t(Array_Type_Declaration): Give support to access components. In addition\n\tit was also modified to reflect the name of the object in anonymous\n\tarray types. The old code did not take into account that it is possible\n\tto have an unconstrained anonymous array with an initial value.\n\t(Check_Or_Process_Discriminants): Allow access discriminant in\n\tnon-limited types.\n\t(Process_Discriminants): Allow access discriminant in non-limited types\n\tInitialize the new Access_Definition field in N_Object_Renaming_Decl\n\tnode.  Change Ada0Y to Ada 0Y in comments\n\n\t* sem_ch4.adb (Find_Equality_Types): Allow anonymous access types in\n\tequality operators.\n\tChange Ada0Y to Ada 0Y in comments\n\n\t* sem_ch8.adb (Analyze_Object_Renaming): Give support to access\n\trenamings Change Ada0Y to Ada 0Y in comments\n\n\t* sem_type.adb (Find_Unique_Type): Give support to the equality\n\toperators for universal access types\n\tChange Ada0Y to Ada 0Y in comments\n\n\t* sinfo.adb (Access_Definition, Set_Access_Definition): New subprograms\n\n\t* sinfo.ads (N_Component_Definition): Addition of Access_Definition\n\tfield.\n\t(N_Object_Renaming_Declaration): Addition of Access_Definition field\n\tChange Ada0Y to Ada 0Y in comments\n\n\t* sprint.adb (Sprint_Node_Actual): Give support to the new syntax for\n\tcomponent definition and object renaming nodes\n\tChange Ada0Y to Ada 0Y in comments\n\n2004-02-02  Jose Ruiz  <ruiz@act-europe.fr>\n\n\t* restrict.adb: Use the new restriction identifier\n\tNo_Requeue_Statements instead of the old No_Requeue for defining the\n\trestricted profile.\n\n\t* sem_ch9.adb (Analyze_Requeue): Check the new restriction\n\tNo_Requeue_Statements.\n\n\t* s-rident.ads: Adding restriction No_Requeue_Statements (AI-00249)\n\tthat supersedes the GNAT specific restriction No_Requeue. The later is\n\tkept for backward compatibility.\n\n2004-02-02  Ed Schonberg  <schonberg@gnat.com>\n\n\t* lib.ads, i-cobol.ads, * s-stoele.ads, s-thread.ads, style.ads,\n\t5staprop.adb, atree.adb, atree.ads, g-crc32.ads: Remove redundant\n\tpragma and fix incorrect ones.\n\n\t* sem_prag.adb For pragma Inline and pragma Pure_Function, emit a\n\twarning if the pragma is redundant.\n\n2004-02-02  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* 5staprop.adb: Add missing 'constant' keywords.\n\n\t* Makefile.in: use consistent value for SYMLIB on\n\tplatforms where libaddr2line is supported.\n\n2004-02-02  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* utils.c (end_subprog_body): Do not call rest_of_compilation if just\n\tannotating types.\n\n2004-02-02  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* init.c (__gnat_install_handler): Setup an alternate stack for signal\n\thandlers in the environment thread. This allows proper propagation of\n\tan exception on stack overflows in this thread even when the builtin\n\tABI stack-checking scheme is used without support for a stack reserve\n\tregion.\n\n\t* utils.c (create_field_decl): Augment the head comment about bitfield\n\tcreation, and don't account for DECL_BIT_FIELD in DECL_NONADDRESSABLE_P\n\there, because the former is not accurate enough at this point.\n\tLet finish_record_type decide instead.\n\tDon't make a bitfield if the field is to be addressable.\n\tAlways set a size for the field if the record is packed, to ensure the\n\tchecks for bitfield creation are triggered.\n\t(finish_record_type): During last pass over the fields, clear\n\tDECL_BIT_FIELD when possible in the !STRICT_ALIGNMENT case, as this is\n\tnot covered by the calls to layout_decl.  Adjust DECL_NONADDRESSABLE_P\n\tfrom DECL_BIT_FIELD.\n\nFrom-SVN: r77110", "tree": {"sha": "30150d4eda55a02c6bc00f9262c17b795a63423d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30150d4eda55a02c6bc00f9262c17b795a63423d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/comments", "author": null, "committer": null, "parents": [{"sha": "d560b0aa2ab4f07365674f3a7d2e4a4626c363c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d560b0aa2ab4f07365674f3a7d2e4a4626c363c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d560b0aa2ab4f07365674f3a7d2e4a4626c363c5"}], "stats": {"total": 4284, "additions": 2720, "deletions": 1564}, "files": [{"sha": "69f0b220ae022f5403c854f1dd03df53868df103", "filename": "gcc/ada/5staprop.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2F5staprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2F5staprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5staprop.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2003, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -228,7 +228,7 @@ package body System.Task_Primitives.Operations is\n    pragma Inline (Check_Wakeup);\n \n    function Check_Unlock (L : Lock_Ptr) return Boolean;\n-   pragma Inline (Check_Lock);\n+   pragma Inline (Check_Unlock);\n \n    function Check_Finalize_Lock (L : Lock_Ptr) return Boolean;\n    pragma Inline (Check_Finalize_Lock);\n@@ -296,7 +296,7 @@ package body System.Task_Primitives.Operations is\n       pragma Unreferenced (Code);\n       pragma Unreferenced (Context);\n \n-      Self_ID : Task_ID := Self;\n+      Self_ID : constant Task_ID := Self;\n       Old_Set : aliased sigset_t;\n \n       Result : Interfaces.C.int;\n@@ -1443,7 +1443,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Record_Lock (L : Lock_Ptr) return Boolean is\n-      Self_ID : Task_ID := Self;\n+      Self_ID : constant Task_ID := Self;\n       P       : Lock_Ptr;\n \n    begin\n@@ -1529,7 +1529,7 @@ package body System.Task_Primitives.Operations is\n    is\n       pragma Unreferenced (Reason);\n \n-      Self_ID : Task_ID := Self;\n+      Self_ID : constant Task_ID := Self;\n       P       : Lock_Ptr;\n \n    begin\n@@ -1586,7 +1586,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Check_Unlock (L : Lock_Ptr) return Boolean is\n-      Self_ID : Task_ID := Self;\n+      Self_ID : constant Task_ID := Self;\n       P       : Lock_Ptr;\n \n    begin"}, {"sha": "75b3596602122e9cd16c996545e553f373ef2012", "filename": "gcc/ada/6vcstrea.adb", "status": "modified", "additions": 72, "deletions": 15, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2F6vcstrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2F6vcstrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F6vcstrea.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -38,19 +38,39 @@ package body Interfaces.C_Streams is\n \n    use type System.CRTL.size_t;\n \n-   --  Substantial rewriting is needed here. These functions are far too\n-   --  long to be inlined. They should be rewritten to be small helper\n-   --  functions that are inlined, and then call the real routines.???\n+   --  As the functions fread, fwrite and setvbuf are too big to be inlined,\n+   --  they are just wrappers to the following implementation functions.\n \n-   --  Alternatively, provide a separate spec for VMS, in which case we\n-   --  could reduce the amount of junk bodies in the other cases by\n-   --  interfacing directly in the spec.???\n+   function fread_impl\n+     (buffer : voids;\n+      size   : size_t;\n+      count  : size_t;\n+      stream : FILEs) return size_t;\n+\n+   function fread_impl\n+     (buffer : voids;\n+      index  : size_t;\n+      size   : size_t;\n+      count  : size_t;\n+      stream : FILEs) return size_t;\n+\n+   function fwrite_impl\n+     (buffer : voids;\n+      size   : size_t;\n+      count  : size_t;\n+      stream : FILEs) return size_t;\n+\n+   function setvbuf_impl\n+     (stream : FILEs;\n+      buffer : chars;\n+      mode   : int;\n+      size   : size_t) return int;\n \n    ------------\n    -- fread --\n    ------------\n \n-   function fread\n+   function fread_impl\n      (buffer : voids;\n       size   : size_t;\n       count  : size_t;\n@@ -85,13 +105,9 @@ package body Interfaces.C_Streams is\n       end loop;\n \n       return Get_Count;\n-   end fread;\n-\n-   ------------\n-   -- fread --\n-   ------------\n+   end fread_impl;\n \n-   function fread\n+   function fread_impl\n      (buffer : voids;\n       index  : size_t;\n       size   : size_t;\n@@ -127,13 +143,34 @@ package body Interfaces.C_Streams is\n       end loop;\n \n       return Get_Count;\n+   end fread_impl;\n+\n+   function fread\n+     (buffer : voids;\n+      size   : size_t;\n+      count  : size_t;\n+      stream : FILEs) return size_t\n+   is\n+   begin\n+      return fread_impl (buffer, size, count, stream);\n+   end fread;\n+\n+   function fread\n+     (buffer : voids;\n+      index  : size_t;\n+      size   : size_t;\n+      count  : size_t;\n+      stream : FILEs) return size_t\n+   is\n+   begin\n+      return fread_impl (buffer, index, size, count, stream);\n    end fread;\n \n    ------------\n    -- fwrite --\n    ------------\n \n-   function fwrite\n+   function fwrite_impl\n      (buffer : voids;\n       size   : size_t;\n       count  : size_t;\n@@ -164,13 +201,23 @@ package body Interfaces.C_Streams is\n       end loop;\n \n       return Put_Count;\n+   end fwrite_impl;\n+\n+   function fwrite\n+     (buffer : voids;\n+      size   : size_t;\n+      count  : size_t;\n+      stream : FILEs) return size_t\n+   is\n+   begin\n+      return fwrite_impl (buffer, size, count, stream);\n    end fwrite;\n \n    -------------\n    -- setvbuf --\n    -------------\n \n-   function setvbuf\n+   function setvbuf_impl\n      (stream : FILEs;\n       buffer : chars;\n       mode   : int;\n@@ -193,6 +240,16 @@ package body Interfaces.C_Streams is\n          return System.CRTL.setvbuf\n            (stream, buffer, mode, System.CRTL.size_t (size));\n       end if;\n+   end setvbuf_impl;\n+\n+   function setvbuf\n+     (stream : FILEs;\n+      buffer : chars;\n+      mode   : int;\n+      size   : size_t) return int\n+   is\n+   begin\n+      return setvbuf_impl (stream, buffer, mode, size);\n    end setvbuf;\n \n end Interfaces.C_Streams;"}, {"sha": "5ea08ff2f0c618b2ef23ef2ffe0ed4aaf8fbbdbb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -1,3 +1,176 @@\n+2004-02-02  Vincent Celier  <celier@gnat.com>\n+\n+\t* gprcmd.adb (Check_Args): If condition is false, print the invoked\n+\tcomment before the usage.\n+\tGprcmd: Fail when command is not recognized.\n+\t(Usage): Document command \"prefix\"\n+\n+\t* g-md5.adb (Digest): Process last block.\n+\t(Update): Do not process last block. Store remaining characters and\n+\tlength in Context.\n+\n+\t* g-md5.ads (Update): Document that several call to update are\n+\tequivalent to one call with the concatenated string.\n+\t(Context): Add fields to allow new Update behaviour.\n+\n+\t* fname-uf.ads/adb (Get_File_Name): New Boolean parameter May_Fail,\n+\tdefaulted to False.\n+\tWhen May_Fail is True and no existing file can be found, return No_File.\n+\n+\t* 6vcstrea.adb: Inlined functions are now wrappers to implementation\n+\tfunctions.\n+\n+\t* lib-writ.adb (Write_With_Lines): When body file does not exist, use\n+\tspec file name instead on the W line.\n+\n+2004-02-02  Robert Dewar  <dewar@gnat.com>\n+\n+\t* ali.adb: Read and acquire info from new format restrictions lines\n+\n+\t* bcheck.adb: Add circuits for checking restrictions with parameters\n+\n+\t* bindgen.adb: Output dummy restrictions data\n+\tTo be changed later\n+\n+\t* ali.ads, checks.adb, exp_aggr.adb, exp_attr.adb, exp_ch11.adb,\n+\texp_ch3.adb, exp_ch5.adb, exp_ch6.adb, exp_ch7.adb, exp_util.adb,\n+\tfreeze.adb, gnat1drv.adb, sem_attr.adb, sem_ch10.adb, sem_ch11.adb,\n+\tsem_ch12.adb, targparm.adb, targparm.ads, tbuild.adb, sem_ch2.adb,\n+\tsem_elab.adb, sem_res.adb: Minor changes for new restrictions handling.\n+\n+\t* exp_ch9.adb (Build_Master_Entity): Cleanup the code (also suppresses\n+\tthe warning message on access to possibly uninitialized variable S)\n+\tMinor changes for new restrictions handling.\n+\n+\t* gnatbind.adb: Minor reformatting\n+\tMinor changes for new restrictions handling\n+\tMove circuit for -r processing here from bcheck (cleaner)\n+\n+\t* gnatcmd.adb, gnatlink.adb: Minor reformatting\n+\n+\t* lib-writ.adb: Output new format restrictions lines\n+\n+\t* lib-writ.ads: Document new R format lines for new restrictions\n+\thandling.\n+\n+\t* s-restri.ads/adb: New files\n+\n+\t* Makefile.rtl: Add entry for s-restri.ads/adb\n+\n+\t* par-ch3.adb: Fix bad error messages starting with upper case letter\n+\tMinor reformatting\n+\n+\t* restrict.adb: Major rewrite throughout for new restrictions handling\n+\tMajor point is to handle restrictions with parameters\n+\n+\t* restrict.ads: Major changes in interface to handle restrictions with\n+\tparameters. Also generally simplifies setting of restrictions.\n+\n+\t* snames.ads/adb: New entry for proper handling of No_Requeue\n+\n+\t* sem_ch3.adb (Count_Tasks): New circuitry for implementing Max_Tasks\n+\trestriction counting.\n+\tOther minor changes for new restrictions handling\n+\n+\t* sem_prag.adb: No_Requeue is a synonym for No_Requeue_Statements.\n+\tRestriction_Warnings now allows full parameter notation\n+\tMajor rewrite of Restrictions for new restrictions handling\n+\n+2004-02-02  Javier Miranda  <miranda@gnat.com>\n+\n+\t* par-ch3.adb (P_Identifier_Declarations): Give support to the Ada 0Y\n+\tsyntax rule for object renaming declarations.\n+\t(P_Array_Type_Definition): Give support for the Ada 0Y syntax rule for\n+\tcomponent definitions.\n+\n+\t* sem_ch3.adb (Analyze_Component_Declaration): Give support to access\n+\tcomponents.\n+\t(Array_Type_Declaration): Give support to access components. In addition\n+\tit was also modified to reflect the name of the object in anonymous\n+\tarray types. The old code did not take into account that it is possible\n+\tto have an unconstrained anonymous array with an initial value.\n+\t(Check_Or_Process_Discriminants): Allow access discriminant in\n+\tnon-limited types.\n+\t(Process_Discriminants): Allow access discriminant in non-limited types\n+\tInitialize the new Access_Definition field in N_Object_Renaming_Decl\n+\tnode.  Change Ada0Y to Ada 0Y in comments\n+\n+\t* sem_ch4.adb (Find_Equality_Types): Allow anonymous access types in\n+\tequality operators.\n+\tChange Ada0Y to Ada 0Y in comments\n+\n+\t* sem_ch8.adb (Analyze_Object_Renaming): Give support to access\n+\trenamings Change Ada0Y to Ada 0Y in comments\n+\n+\t* sem_type.adb (Find_Unique_Type): Give support to the equality\n+\toperators for universal access types\n+\tChange Ada0Y to Ada 0Y in comments\n+\n+\t* sinfo.adb (Access_Definition, Set_Access_Definition): New subprograms\n+\n+\t* sinfo.ads (N_Component_Definition): Addition of Access_Definition\n+\tfield.\n+\t(N_Object_Renaming_Declaration): Addition of Access_Definition field\n+\tChange Ada0Y to Ada 0Y in comments\n+\n+\t* sprint.adb (Sprint_Node_Actual): Give support to the new syntax for\n+\tcomponent definition and object renaming nodes\n+\tChange Ada0Y to Ada 0Y in comments\n+\n+2004-02-02  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* restrict.adb: Use the new restriction identifier\n+\tNo_Requeue_Statements instead of the old No_Requeue for defining the\n+\trestricted profile.\n+\n+\t* sem_ch9.adb (Analyze_Requeue): Check the new restriction\n+\tNo_Requeue_Statements.\n+\n+\t* s-rident.ads: Adding restriction No_Requeue_Statements (AI-00249)\n+\tthat supersedes the GNAT specific restriction No_Requeue. The later is\n+\tkept for backward compatibility.\n+\n+2004-02-02  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* lib.ads, i-cobol.ads, * s-stoele.ads, s-thread.ads, style.ads,\n+\t5staprop.adb, atree.adb, atree.ads, g-crc32.ads: Remove redundant\n+\tpragma and fix incorrect ones.\n+\n+\t* sem_prag.adb For pragma Inline and pragma Pure_Function, emit a\n+\twarning if the pragma is redundant.\n+\n+2004-02-02  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* 5staprop.adb: Add missing 'constant' keywords.\n+\n+\t* Makefile.in: use consistent value for SYMLIB on\n+\tplatforms where libaddr2line is supported.\n+\n+2004-02-02  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* utils.c (end_subprog_body): Do not call rest_of_compilation if just\n+\tannotating types.\n+\n+2004-02-02  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* init.c (__gnat_install_handler): Setup an alternate stack for signal\n+\thandlers in the environment thread. This allows proper propagation of\n+\tan exception on stack overflows in this thread even when the builtin\n+\tABI stack-checking scheme is used without support for a stack reserve\n+\tregion.\n+\n+\t* utils.c (create_field_decl): Augment the head comment about bitfield\n+\tcreation, and don't account for DECL_BIT_FIELD in DECL_NONADDRESSABLE_P\n+\there, because the former is not accurate enough at this point.\n+\tLet finish_record_type decide instead.\n+\tDon't make a bitfield if the field is to be addressable.\n+\tAlways set a size for the field if the record is packed, to ensure the\n+\tchecks for bitfield creation are triggered.\n+\t(finish_record_type): During last pass over the fields, clear\n+\tDECL_BIT_FIELD when possible in the !STRICT_ALIGNMENT case, as this is\n+\tnot covered by the calls to layout_decl.  Adjust DECL_NONADDRESSABLE_P\n+\tfrom DECL_BIT_FIELD.\n+\n 2004-01-30  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* Make-lang.in (doc/gnat_ug_unx.dvi): Use $(abs_docdir). "}, {"sha": "91f122008625f76ca2abccb73ae058419f289973", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -136,6 +136,7 @@ THREADSLIB =\n GMEM_LIB =\n MISCLIB =\n SYMLIB =\n+ADDR2LINE_SYMLIB = -laddr2line -lbfd -liberty $(LIBINTL)\n SYMDEPS = $(LIBINTL_DEP)\n OUTPUT_OPTION = @OUTPUT_OPTION@\n \n@@ -715,7 +716,7 @@ ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n \n   THREADSLIB = -lposix4 -lthread\n   MISCLIB = -lposix4 -lnsl -lsocket\n-  SYMLIB = -laddr2line -lbfd $(LIBINTL)\n+  SYMLIB = $(ADDR2LINE_SYMLIB)\n   SO_OPTS = -Wl,-h,\n   GNATLIB_SHARED = gnatlib-shared-dual\n   GMEM_LIB = gmemlib\n@@ -824,8 +825,10 @@ ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n   s-parame.adb<5lparame.adb \\\n   system.ads<5lsystem.ads\n \n-  TOOLS_TARGET_PAIRS = mlib-tgt.adb<5lml-tgt.adb\n-  SYMLIB = -laddr2line -lbfd -liberty $(LIBINTL)\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt.adb<5lml-tgt.adb\n+\n+  SYMLIB = $(ADDR2LINE_SYMLIB)\n   THREADSLIB = -lpthread\n   GNATLIB_SHARED = gnatlib-shared-dual\n   GMEM_LIB = gmemlib\n@@ -964,7 +967,7 @@ ifeq ($(strip $(filter-out hppa% hp hpux11%,$(targ))),)\n   TOOLS_TARGET_PAIRS = mlib-tgt.adb<5hml-tgt.adb\n   TGT_LIB = /usr/lib/libcl.a\n   THREADSLIB = -lpthread\n-  SYMLIB = -laddr2line -lbfd $(LIBINTL)\n+  SYMLIB = $(ADDR2LINE_SYMLIB)\n   GMEM_LIB = gmemlib\n   soext = .sl\n   SO_OPTS = -Wl,+h,\n@@ -1030,7 +1033,7 @@ ifeq ($(strip $(filter-out ibm aix%,$(manu) $(osys))),)\n \n   TOOLS_TARGET_PAIRS = mlib-tgt.adb<5bml-tgt.adb\n   GMEM_LIB = gmemlib\n-  SYMLIB = -laddr2line -lbfd -liberty $(LIBINTL)\n+  SYMLIB = $(ADDR2LINE_SYMLIB)\n \n endif\n \n@@ -1117,7 +1120,7 @@ ifeq ($(strip $(filter-out alpha% dec osf%,$(targ))),)\n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<5aml-tgt.adb\n \n   GMEM_LIB=gmemlib\n-  SYMLIB = -laddr2line -lbfd $(LIBINTL)\n+  SYMLIB = $(ADDR2LINE_SYMLIB)\n   THREADSLIB = -lpthread -lmach -lexc -lrt\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n   GNATLIB_SHARED = gnatlib-shared-default\n@@ -1237,7 +1240,7 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<5wml-tgt.adb\n   MISCLIB = -lwsock32\n-  SYMLIB = -laddr2line -lbfd -liberty $(LIBINTL)\n+  SYMLIB = $(ADDR2LINE_SYMLIB)\n   GMEM_LIB = gmemlib\n   PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n   EXTRA_GNATTOOLS = ../../gnatdll$(exeext)\n@@ -1287,7 +1290,7 @@ ifeq ($(strip $(filter-out %x86_64 linux%,$(arch) $(osys))),)\n   system.ads<5nsystem.ads\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<5lml-tgt.adb\n-  SYMLIB = -laddr2line -lbfd -liberty $(LIBINTL)\n+  SYMLIB = $(ADDR2LINE_SYMLIB)\n   THREADSLIB=-lpthread\n   GNATLIB_SHARED=gnatlib-shared-dual\n   GMEM_LIB = gmemlib"}, {"sha": "512310aa88fe1fffdc5bbdbffcfb665896a88e0f", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -395,8 +395,9 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-poosiz$(objext) \\\n   s-powtab$(objext) \\\n   s-purexc$(objext) \\\n+  s-restri$(objext) \\\n   s-rident$(objext) \\\n-  s-rpc$(objext) \\\n+  s-rpc$(objext)    \\\n   s-scaval$(objext) \\\n   s-secsta$(objext) \\\n   s-sequio$(objext) \\"}, {"sha": "8f340e8c958f0dd20e073b30c4614705cefdd2d0", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 119, "deletions": 11, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -120,6 +120,13 @@ package body ALI is\n       --  be ignored by Scan_ALI and skipped, and False if the lines\n       --  are to be read and processed.\n \n+      Restrictions_Initial : Rident.Restrictions_Info;\n+      pragma Warnings (Off, Restrictions_Initial);\n+      --  This variable, which should really be a constant (but that's not\n+      --  allowed by the language) is used only for initialization, and the\n+      --  reason we are declaring it is to get the default initialization\n+      --  set for the object.\n+\n       Bad_ALI_Format : exception;\n       --  Exception raised by Fatal_Error if Err is True\n \n@@ -371,7 +378,6 @@ package body ALI is\n          Skip_Space;\n \n          V := 0;\n-\n          loop\n             V := V * 10 + (Character'Pos (Getc) - Character'Pos ('0'));\n             exit when At_End_Of_Field;\n@@ -546,7 +552,7 @@ package body ALI is\n         Normalize_Scalars          => False,\n         Ofile_Full_Name            => Full_Object_File_Name,\n         Queuing_Policy             => ' ',\n-        Restrictions               => (others => ' '),\n+        Restrictions               => Restrictions_Initial,\n         Sfile                      => No_Name,\n         Task_Dispatching_Policy    => ' ',\n         Time_Slice_Value           => -1,\n@@ -733,7 +739,7 @@ package body ALI is\n                Queuing_Policy_Specified := Getc;\n                ALIs.Table (Id).Queuing_Policy := Queuing_Policy_Specified;\n \n-            --  Processing fir flags starting with S\n+            --  Processing for flags starting with S\n \n             elsif C = 'S' then\n                C := Getc;\n@@ -803,7 +809,7 @@ package body ALI is\n \n       C := Getc;\n \n-      --  Acquire restrictions line\n+      --  Acquire first restrictions line\n \n       if C /= 'R' then\n          Fatal_Error;\n@@ -815,18 +821,17 @@ package body ALI is\n          Checkc (' ');\n          Skip_Space;\n \n-         for J in All_Restrictions loop\n+         for R in All_Boolean_Restrictions loop\n             C := Getc;\n-            ALIs.Table (Id).Restrictions (J) := C;\n \n             case C is\n                when 'v' =>\n-                  Restrictions (J) := 'v';\n+                  ALIs.Table (Id).Restrictions.Violated (R) := True;\n+                  Cumulative_Restrictions.Violated (R) := True;\n \n                when 'r' =>\n-                  if Restrictions (J) = 'n' then\n-                     Restrictions (J) := 'r';\n-                  end if;\n+                  ALIs.Table (Id).Restrictions.Set (R) := True;\n+                  Cumulative_Restrictions.Set (R) := True;\n \n                when 'n' =>\n                   null;\n@@ -841,6 +846,109 @@ package body ALI is\n \n       C := Getc;\n \n+      --  See if we have a second R line\n+\n+      if C /= 'R' then\n+\n+         --  If not, just ignore, and leave the restrictions variables\n+         --  unchanged. This is useful for dealing with old format ALI\n+         --  files with only one R line (this can be removed later on,\n+         --  but is useful for transitional purposes).\n+\n+         null;\n+\n+         --  Here we have a second R line, ignore it if ignore flag set\n+\n+      elsif Ignore ('R') then\n+         Skip_Line;\n+         C := Getc;\n+\n+      --  Otherwise acquire second R line\n+\n+      else\n+         Checkc (' ');\n+         Skip_Space;\n+\n+         for RP in All_Parameter_Restrictions loop\n+\n+            --  Acquire restrictions pragma information\n+\n+            case Getc is\n+               when 'n' =>\n+                  null;\n+\n+               when 'r' =>\n+                  ALIs.Table (Id).Restrictions.Set (RP) := True;\n+\n+                  declare\n+                     N : constant Integer := Integer (Get_Nat);\n+                  begin\n+                     ALIs.Table (Id).Restrictions.Value (RP) := N;\n+\n+                     if Cumulative_Restrictions.Set (RP) then\n+                        Cumulative_Restrictions.Value (RP) :=\n+                          Integer'Min (Cumulative_Restrictions.Value (RP), N);\n+                     else\n+                        Cumulative_Restrictions.Set (RP) := True;\n+                        Cumulative_Restrictions.Value (RP) := N;\n+                     end if;\n+                  end;\n+\n+               when others =>\n+                  Fatal_Error;\n+            end case;\n+\n+            --  Acquire restrictions violations information\n+\n+            case Getc is\n+               when 'n' =>\n+                  null;\n+\n+               when 'v' =>\n+                  ALIs.Table (Id).Restrictions.Violated (RP) := True;\n+                  Cumulative_Restrictions.Violated (RP) := True;\n+\n+                  declare\n+                     N : constant Integer := Integer (Get_Nat);\n+                     pragma Unsuppress (Overflow_Check);\n+\n+                  begin\n+                     ALIs.Table (Id).Restrictions.Count (RP) := N;\n+\n+                     if RP in Checked_Max_Parameter_Restrictions then\n+                        Cumulative_Restrictions.Count (RP) :=\n+                          Integer'Max (Cumulative_Restrictions.Count (RP), N);\n+                     else\n+                        Cumulative_Restrictions.Count (RP) :=\n+                          Cumulative_Restrictions.Count (RP) + N;\n+                     end if;\n+\n+                  exception\n+                     when Constraint_Error =>\n+\n+                        --  A constraint error comes from the addition in\n+                        --  the else branch. We reset to the maximum and\n+                        --  indicate that the real value is now unknown.\n+\n+                        Cumulative_Restrictions.Value (RP) := Integer'Last;\n+                        Cumulative_Restrictions.Unknown (RP) := True;\n+                  end;\n+\n+                  if Nextc = '+' then\n+                     Skipc;\n+                     ALIs.Table (Id).Restrictions.Unknown (RP) := True;\n+                     Cumulative_Restrictions.Unknown (RP) := True;\n+                  end if;\n+\n+               when others =>\n+                  Fatal_Error;\n+            end case;\n+         end loop;\n+\n+         Skip_Eol;\n+         C := Getc;\n+      end if;\n+\n       --  Acquire 'I' lines if present\n \n       while C = 'I' loop"}, {"sha": "c5fa093b5653c608d2e85b0c02b8aabb48fe2167", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -82,9 +82,6 @@ package ALI is\n    type Main_Program_Type is (None, Proc, Func);\n    --  Indicator of whether unit can be used as main program\n \n-   type Restrictions_String is array (All_Restrictions) of Character;\n-   --  Type used to hold string from R line\n-\n    type ALIs_Record is record\n \n       Afile : File_Name_Type;\n@@ -187,9 +184,8 @@ package ALI is\n       --  Set to True if file was compiled with zero cost exceptions.\n       --  Not set if 'P' appears in Ignore_Lines.\n \n-      Restrictions : Restrictions_String;\n-      --  Copy of restrictions letters from R line.\n-      --  Not set if 'R' appears in Ignore_Lines.\n+      Restrictions : Restrictions_Info;\n+      --  Restrictions information reconstructed from R lines\n \n       First_Interrupt_State : Interrupt_State_Id;\n       Last_Interrupt_State  : Interrupt_State_Id'Base;\n@@ -422,11 +418,10 @@ package ALI is\n    --  Set to blank by Initialize_ALI. Set to the appropriate queuing policy\n    --  character if an ali file contains a P line setting the queuing policy.\n \n-   Restrictions : Restrictions_String := (others => 'n');\n-   --  This array records the cumulative contributions of R lines in all\n-   --  ali files. An entry is changed will be set to v if any ali file\n-   --  indicates that the restriction is violated, and otherwise will be\n-   --  set to r if the restriction is specified by some unit.\n+   Cumulative_Restrictions : Restrictions_Info;\n+   --  This variable records the cumulative contributions of R lines in all\n+   --  ali files, showing whether a restriction pragma exists anywhere, and\n+   --  accumulating the aggregate knowledge of violations.\n \n    Static_Elaboration_Model_Used : Boolean := False;\n    --  Set to False by Initialize_ALI. Set to True if any ALI file for a"}, {"sha": "906b3af8aaba526b8f107f40a3be7669fd2492f1", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1836,6 +1836,7 @@ package body Atree is\n \n       procedure New_Entity_Debugging_Output;\n       --  Debugging routine for debug flag N\n+      pragma Inline (New_Entity_Debugging_Output);\n \n       ---------------------------------\n       -- New_Entity_Debugging_Output --\n@@ -1854,8 +1855,6 @@ package body Atree is\n          end if;\n       end New_Entity_Debugging_Output;\n \n-      pragma Inline (New_Entity_Debugging_Output);\n-\n    --  Start of processing for New_Entity\n \n    begin\n@@ -1908,6 +1907,7 @@ package body Atree is\n \n       procedure New_Node_Debugging_Output;\n       --  Debugging routine for debug flag N\n+      pragma Inline (New_Node_Debugging_Output);\n \n       --------------------------\n       -- New_Debugging_Output --\n@@ -1926,8 +1926,6 @@ package body Atree is\n          end if;\n       end New_Node_Debugging_Output;\n \n-      pragma Inline (New_Node_Debugging_Output);\n-\n    --  Start of processing for New_Node\n \n    begin"}, {"sha": "4bb8a66c52e71ff8499815bce01b1234de21b79c", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1473,25 +1473,25 @@ package Atree is\n       pragma Inline (Flag151);\n \n       function Flag152 (N : Node_Id) return Boolean;\n-      pragma Inline (Flag151);\n+      pragma Inline (Flag152);\n \n       function Flag153 (N : Node_Id) return Boolean;\n-      pragma Inline (Flag151);\n+      pragma Inline (Flag153);\n \n       function Flag154 (N : Node_Id) return Boolean;\n-      pragma Inline (Flag151);\n+      pragma Inline (Flag154);\n \n       function Flag155 (N : Node_Id) return Boolean;\n-      pragma Inline (Flag151);\n+      pragma Inline (Flag155);\n \n       function Flag156 (N : Node_Id) return Boolean;\n-      pragma Inline (Flag151);\n+      pragma Inline (Flag156);\n \n       function Flag157 (N : Node_Id) return Boolean;\n-      pragma Inline (Flag151);\n+      pragma Inline (Flag157);\n \n       function Flag158 (N : Node_Id) return Boolean;\n-      pragma Inline (Flag151);\n+      pragma Inline (Flag158);\n \n       function Flag159 (N : Node_Id) return Boolean;\n       pragma Inline (Flag159);"}, {"sha": "ff534ba8d13296e8308ba2ba172b107a127feed1", "filename": "gcc/ada/bcheck.adb", "status": "modified", "additions": 128, "deletions": 141, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fbcheck.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fbcheck.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbcheck.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -51,8 +51,8 @@ package body Bcheck is\n    procedure Check_Consistent_Interrupt_States;\n    procedure Check_Consistent_Locking_Policy;\n    procedure Check_Consistent_Normalize_Scalars;\n-   procedure Check_Consistent_Partition_Restrictions;\n    procedure Check_Consistent_Queuing_Policy;\n+   procedure Check_Consistent_Restrictions;\n    procedure Check_Consistent_Zero_Cost_Exception_Handling;\n \n    procedure Consistency_Error_Msg (Msg : String);\n@@ -84,7 +84,7 @@ package body Bcheck is\n       Check_Consistent_Normalize_Scalars;\n       Check_Consistent_Dynamic_Elaboration_Checking;\n \n-      Check_Consistent_Partition_Restrictions;\n+      Check_Consistent_Restrictions;\n       Check_Consistent_Interrupt_States;\n    end Check_Configuration_Consistency;\n \n@@ -362,184 +362,171 @@ package body Bcheck is\n       end if;\n    end Check_Consistent_Normalize_Scalars;\n \n-   ---------------------------------------------\n-   -- Check_Consistent_Partition_Restrictions --\n-   ---------------------------------------------\n-\n-   --  The rule is that if a restriction is specified in any unit,\n-   --  then all units must obey the restriction. The check applies\n-   --  only to restrictions which require partition wide consistency,\n-   --  and not to internal units.\n-\n-   --  The check is done in two steps. First for every restriction\n-   --  a unit specifying that restriction is found, if any.\n-   --  Second, all units are verified against the specified restrictions.\n-\n-   procedure Check_Consistent_Partition_Restrictions is\n-      No_Restriction_List : constant array (All_Restrictions) of Boolean :=\n-        (No_Implicit_Conditionals => True,\n-         --  This could modify and pessimize generated code\n-\n-         No_Implicit_Dynamic_Code => True,\n-         --  This could modify and pessimize generated code\n-\n-         No_Implicit_Loops        => True,\n-         --  This could modify and pessimize generated code\n+   -------------------------------------\n+   -- Check_Consistent_Queuing_Policy --\n+   -------------------------------------\n \n-         No_Recursion             => True,\n-         --  Not checkable at compile time\n+   --  The rule is that all files for which the queuing policy is\n+   --  significant must be compiled with the same setting.\n \n-         No_Reentrancy            => True,\n-         --  Not checkable at compile time\n+   procedure Check_Consistent_Queuing_Policy is\n+   begin\n+      --  First search for a unit specifying a policy and then\n+      --  check all remaining units against it.\n \n-         others                   => False);\n-      --  Define those restrictions that should be output if the gnatbind -r\n-      --  switch is used. Not all restrictions are output for the reasons given\n-      --  above in the list, and this array is used to test whether the\n-      --  corresponding pragma should be listed. True means that it should not\n-      --  be listed.\n+      Find_Policy : for A1 in ALIs.First .. ALIs.Last loop\n+         if ALIs.Table (A1).Queuing_Policy /= ' ' then\n+            Check_Policy : declare\n+               Policy : constant Character := ALIs.Table (A1).Queuing_Policy;\n+            begin\n+               for A2 in A1 + 1 .. ALIs.Last loop\n+                  if ALIs.Table (A2).Queuing_Policy /= ' '\n+                       and then\n+                     ALIs.Table (A2).Queuing_Policy /= Policy\n+                  then\n+                     Error_Msg_Name_1 := ALIs.Table (A1).Sfile;\n+                     Error_Msg_Name_2 := ALIs.Table (A2).Sfile;\n \n-      R : array (All_Restrictions) of ALI_Id := (others => No_ALI_Id);\n-      --  Record the first unit specifying each compilation unit restriction\n+                     Consistency_Error_Msg\n+                       (\"% and % compiled with different queuing policies\");\n+                     exit Find_Policy;\n+                  end if;\n+               end loop;\n+            end Check_Policy;\n \n-      V : array (All_Restrictions) of ALI_Id := (others => No_ALI_Id);\n-      --  Record the last unit violating each partition restriction. Note\n-      --  that entries in this array that do not correspond to partition\n-      --  restrictions can never be modified.\n+            exit Find_Policy;\n+         end if;\n+      end loop Find_Policy;\n+   end Check_Consistent_Queuing_Policy;\n \n-      Additional_Restrictions_Listed : Boolean := False;\n-      --  Set True if we have listed header for restrictions\n+   -----------------------------------\n+   -- Check_Consistent_Restrictions --\n+   -----------------------------------\n \n-   begin\n-      --  Loop to find restrictions\n+   --  The rule is that if a restriction is specified in any unit,\n+   --  then all units must obey the restriction. The check applies\n+   --  only to restrictions which require partition wide consistency,\n+   --  and not to internal units.\n \n-      for A in ALIs.First .. ALIs.Last loop\n-         for J in All_Restrictions loop\n-            if R (J) = No_ALI_Id and ALIs.Table (A).Restrictions (J) = 'r' then\n-               R (J) := A;\n-            end if;\n-         end loop;\n-      end loop;\n+   procedure Check_Consistent_Restrictions is\n+      Restriction_File_Output : Boolean;\n+      --  Shows if we have output header messages for restriction violation\n \n-      --  Loop to find violations\n+      procedure Print_Restriction_File (R : All_Restrictions);\n+      --  Print header line for R if not printed yet\n \n-      for A in ALIs.First .. ALIs.Last loop\n-         for J in All_Restrictions loop\n-            if ALIs.Table (A).Restrictions (J) = 'v'\n-               and then not Is_Internal_File_Name (ALIs.Table (A).Sfile)\n-            then\n-               --  A violation of a restriction was found\n+      ----------------------------\n+      -- Print_Restriction_File --\n+      ----------------------------\n \n-               V (J) := A;\n+      procedure Print_Restriction_File (R : All_Restrictions) is\n+      begin\n+         if not Restriction_File_Output then\n+            Restriction_File_Output := True;\n \n-               --  If this is a paritition restriction, and the restriction\n-               --  was specified in some unit in the partition, then this\n-               --  is a violation of the consistency requirement, so we\n-               --  generate an appropriate error message.\n+            --  Find the ali file specifying the restriction\n \n-               if R (J) /= No_ALI_Id\n-                 and then J in Partition_Restrictions\n+            for A in ALIs.First .. ALIs.Last loop\n+               if ALIs.Table (A).Restrictions.Set (R)\n+                 and then (R in All_Boolean_Restrictions\n+                             or else ALIs.Table (A).Restrictions.Value (R) =\n+                                     Cumulative_Restrictions.Value (R))\n                then\n+                  --  We have found that ALI file A specifies the restriction\n+                  --  that is being violated (the minimum value is specified\n+                  --  in the case of a parameter restriction).\n+\n                   declare\n-                     M1 : constant String := \"% has Restriction (\";\n-                     S  : constant String := Restriction_Id'Image (J);\n-                     M2 : String (1 .. M1'Length + S'Length + 1);\n+                     M1 : constant String := \"% has restriction \";\n+                     S  : constant String := Restriction_Id'Image (R);\n+                     M2 : String (1 .. 200); -- big enough!\n+                     P  : Integer;\n \n                   begin\n                      Name_Buffer (1 .. S'Length) := S;\n                      Name_Len := S'Length;\n-                     Set_Casing\n-                       (Units.Table (ALIs.Table (R (J)).First_Unit).Icasing);\n+                     Set_Casing (Mixed_Case);\n \n                      M2 (M1'Range) := M1;\n-                     M2 (M1'Length + 1 .. M2'Last - 1) :=\n-                                                   Name_Buffer (1 .. S'Length);\n-                     M2 (M2'Last) := ')';\n+                     P := M1'Length + 1;\n+                     M2 (P .. P + S'Length - 1) := Name_Buffer (1 .. S'Length);\n+                     P := P + S'Length;\n+\n+                     if R in All_Parameter_Restrictions then\n+                        M2 (P .. P + 4) := \" => #\";\n+                        Error_Msg_Nat_1 :=\n+                          Int (Cumulative_Restrictions.Value (R));\n+                        P := P + 5;\n+                     end if;\n \n-                     Error_Msg_Name_1 := ALIs.Table (R (J)).Sfile;\n-                     Consistency_Error_Msg (M2);\n                      Error_Msg_Name_1 := ALIs.Table (A).Sfile;\n+                     Consistency_Error_Msg (M2 (1 .. P - 1));\n                      Consistency_Error_Msg\n-                       (\"but file % violates this restriction\");\n+                       (\"but the following files violate this restriction:\");\n                   end;\n                end if;\n-            end if;\n-         end loop;\n-      end loop;\n+            end loop;\n+         end if;\n+      end Print_Restriction_File;\n \n-      --  List applicable restrictions if option set\n+   --  Start of processing for Check_Consistent_Restrictions\n \n-      if List_Restrictions then\n+   begin\n+      --  Loop through all restriction violations\n \n-         --  List any restrictions which were not violated and not specified\n+      for R in All_Restrictions loop\n \n-         for J in All_Restrictions loop\n-            if V (J) = No_ALI_Id\n-              and then R (J) = No_ALI_Id\n-              and then not No_Restriction_List (J)\n-            then\n-               if not Additional_Restrictions_Listed then\n-                  Write_Eol;\n-                  Write_Line\n-                    (\"The following additional restrictions may be\" &\n-                     \" applied to this partition:\");\n-                  Additional_Restrictions_Listed := True;\n-               end if;\n+         --  Check for violation of this restriction\n \n-               Write_Str (\"pragma Restrictions (\");\n+         if Cumulative_Restrictions.Set (R)\n+           and then Cumulative_Restrictions.Violated (R)\n+           and then (R in Partition_Boolean_Restrictions\n+                       or else (R in All_Parameter_Restrictions\n+                                   and then\n+                                     Cumulative_Restrictions.Count (R) >\n+                                     Cumulative_Restrictions.Value (R)))\n+         then\n+            Restriction_File_Output := False;\n \n-               declare\n-                  S : constant String := Restriction_Id'Image (J);\n-               begin\n-                  Name_Len := S'Length;\n-                  Name_Buffer (1 .. Name_Len) := S;\n-               end;\n+            --  Loop through files looking for violators\n \n-               Set_Casing (Mixed_Case);\n-               Write_Str (Name_Buffer (1 .. Name_Len));\n-               Write_Str (\");\");\n-               Write_Eol;\n-            end if;\n-         end loop;\n-      end if;\n-   end Check_Consistent_Partition_Restrictions;\n+            for A2 in ALIs.First .. ALIs.Last loop\n+               if ALIs.Table (A2).Restrictions.Violated (R) then\n \n-   -------------------------------------\n-   -- Check_Consistent_Queuing_Policy --\n-   -------------------------------------\n+                  --  We exclude predefined files from the list of\n+                  --  violators. This should be rethought. It is not\n+                  --  clear that this is the right thing to do, that\n+                  --  is particularly the case for restricted runtimes.\n \n-   --  The rule is that all files for which the queuing policy is\n-   --  significant must be compiled with the same setting.\n+                  if not Is_Internal_File_Name (ALIs.Table (A2).Sfile) then\n+                     Print_Restriction_File (R);\n \n-   procedure Check_Consistent_Queuing_Policy is\n-   begin\n-      --  First search for a unit specifying a policy and then\n-      --  check all remaining units against it.\n+                     Error_Msg_Name_1 := ALIs.Table (A2).Sfile;\n \n-      Find_Policy : for A1 in ALIs.First .. ALIs.Last loop\n-         if ALIs.Table (A1).Queuing_Policy /= ' ' then\n-            Check_Policy : declare\n-               Policy : constant Character := ALIs.Table (A1).Queuing_Policy;\n-            begin\n-               for A2 in A1 + 1 .. ALIs.Last loop\n-                  if ALIs.Table (A2).Queuing_Policy /= ' '\n-                       and then\n-                     ALIs.Table (A2).Queuing_Policy /= Policy\n-                  then\n-                     Error_Msg_Name_1 := ALIs.Table (A1).Sfile;\n-                     Error_Msg_Name_2 := ALIs.Table (A2).Sfile;\n+                     if R in All_Boolean_Restrictions then\n+                        Consistency_Error_Msg (\"  %\");\n \n-                     Consistency_Error_Msg\n-                       (\"% and % compiled with different queuing policies\");\n-                     exit Find_Policy;\n-                  end if;\n-               end loop;\n-            end Check_Policy;\n+                     elsif R in Checked_Add_Parameter_Restrictions\n+                       or else ALIs.Table (A2).Restrictions.Count (R) >\n+                       Cumulative_Restrictions.Value (R)\n+                     then\n+                        Error_Msg_Nat_1 :=\n+                          Int (ALIs.Table (A2).Restrictions.Count (R));\n \n-            exit Find_Policy;\n+                        if ALIs.Table (A2).Restrictions.Unknown (R) then\n+                           Consistency_Error_Msg\n+                             (\"  % (count = at least #)\");\n+                        else\n+                           Consistency_Error_Msg\n+                             (\"  % (count = #)\");\n+                        end if;\n+                     end if;\n+                  end if;\n+               end if;\n+            end loop;\n          end if;\n-      end loop Find_Policy;\n-   end Check_Consistent_Queuing_Policy;\n+      end loop;\n+   end Check_Consistent_Restrictions;\n \n    ---------------------------------------------------\n    -- Check_Consistent_Zero_Cost_Exception_Handling --"}, {"sha": "834186239e5c7ddf4da53f256bc296e04511deeb", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -360,8 +360,8 @@ package body Bindgen is\n          Write_Statement_Buffer;\n          Set_String (\"        \"\"\");\n \n-         for J in Restrictions'Range loop\n-            Set_Char (Restrictions (J));\n+         for J in All_Restrictions loop\n+            null;\n          end loop;\n \n          Set_String (\"\"\";\");\n@@ -607,8 +607,8 @@ package body Bindgen is\n \n          Set_String (\"   const char *restrictions = \"\"\");\n \n-         for J in Restrictions'Range loop\n-            Set_Char (Restrictions (J));\n+         for J in All_Restrictions loop\n+            null;\n          end loop;\n \n          Set_String (\"\"\";\");\n@@ -1171,7 +1171,7 @@ package body Bindgen is\n       --  If compiling for the JVM, we directly reference Adafinal because\n       --  we don't import it via Do_Finalize (see Gen_Output_File_Ada).\n \n-      if not Restrictions_On_Target (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n          if Hostparm.Java_VM then\n             Set_String\n               (\"        System.Standard_Library.Adafinal'Code_Address\");\n@@ -1337,7 +1337,7 @@ package body Bindgen is\n \n       WBI (\"     \" & Ada_Init_Name.all & \",\");\n \n-      if not Restrictions_On_Target (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n          Set_String (\"     system__standard_library__adafinal\");\n       end if;\n \n@@ -1410,7 +1410,7 @@ package body Bindgen is\n \n       --  Initialize and Finalize\n \n-      if not Restrictions_On_Target (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n          WBI (\"      procedure initialize;\");\n          WBI (\"      pragma Import (C, initialize, \"\"__gnat_initialize\"\");\");\n          WBI (\"\");\n@@ -1494,7 +1494,7 @@ package body Bindgen is\n          WBI (\"      gnat_envp := System.Null_Address;\");\n       end if;\n \n-      if not Restrictions_On_Target (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n          WBI (\"      Initialize;\");\n       end if;\n \n@@ -1512,7 +1512,7 @@ package body Bindgen is\n \n       --  Adafinal call is skipped if no finalization\n \n-      if not Restrictions_On_Target (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n \n          --  If compiling for the JVM, we directly call Adafinal because\n          --  we don't import it via Do_Finalize (see Gen_Output_File_Ada).\n@@ -1526,7 +1526,7 @@ package body Bindgen is\n \n       --  Finalize is only called if we have a run time\n \n-      if not Restrictions_On_Target (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n          WBI (\"      Finalize;\");\n       end if;\n \n@@ -1652,7 +1652,7 @@ package body Bindgen is\n \n       --  Call adafinal if finalization active\n \n-      if not Restrictions_On_Target (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n          WBI (\" \");\n          WBI (\"   system__standard_library__adafinal ();\");\n       end if;\n@@ -2011,7 +2011,7 @@ package body Bindgen is\n       --  then we need to make sure that the binder program is compiled with\n       --  the same restriction, so that no exception tables are generated.\n \n-      if Restrictions_On_Target (No_Exception_Handlers) then\n+      if Cumulative_Restrictions.Set (No_Exception_Handlers) then\n          WBI (\"pragma Restrictions (No_Exception_Handlers);\");\n       end if;\n \n@@ -2116,7 +2116,7 @@ package body Bindgen is\n       --  No need to generate a finalization routine if finalization\n       --  is restricted, since there is nothing to do in this case.\n \n-      if not Restrictions_On_Target (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n          WBI (\"\");\n          WBI (\"   procedure \" & Ada_Final_Name.all & \";\");\n          WBI (\"   pragma Export (C, \" & Ada_Final_Name.all & \", \"\"\" &\n@@ -2223,7 +2223,7 @@ package body Bindgen is\n \n       --  Import the finalization procedure only if finalization active\n \n-      if not Restrictions_On_Target (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n \n          --  In the Java case, pragma Import C cannot be used, so the\n          --  standard Ada constructs will be used instead.\n@@ -2242,7 +2242,7 @@ package body Bindgen is\n \n       --  No need to generate a finalization routine if no finalization\n \n-      if not Restrictions_On_Target (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n          Gen_Adafinal_Ada;\n       end if;\n \n@@ -2430,7 +2430,7 @@ package body Bindgen is\n       --  Generate the adafinal routine. In no runtime mode, this is\n       --  not needed, since there is no finalization to do.\n \n-      if not Restrictions_On_Target (No_Finalization) then\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n          Gen_Adafinal_C;\n       end if;\n "}, {"sha": "327ddb665094100d0f9689abc09e3f5a2d740ccb", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,6 +38,7 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Output;   use Output;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Eval; use Sem_Eval;\n@@ -514,7 +515,7 @@ package body Checks is\n       else\n          --  Skip generation of this code if we don't want elab code\n \n-         if not Restrictions (No_Elaboration_Code) then\n+         if not Restriction_Active (No_Elaboration_Code) then\n             Insert_After_And_Analyze (N,\n               Make_Raise_Program_Error (Loc,\n                 Condition =>"}, {"sha": "83e892fad80c15c503400959e8538a0d0abaec12", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -565,6 +565,7 @@ package body CStand is\n       begin\n          CompDef_Node := New_Node (N_Component_Definition, Stloc);\n          Set_Aliased_Present    (CompDef_Node, False);\n+         Set_Access_Definition  (CompDef_Node, Empty);\n          Set_Subtype_Indication (CompDef_Node, Identifier_For (S_Character));\n          Set_Component_Definition (Tdef_Node, CompDef_Node);\n       end;\n@@ -595,6 +596,7 @@ package body CStand is\n       begin\n          CompDef_Node := New_Node (N_Component_Definition, Stloc);\n          Set_Aliased_Present    (CompDef_Node, False);\n+         Set_Access_Definition  (CompDef_Node, Empty);\n          Set_Subtype_Indication (CompDef_Node,\n                                  Identifier_For (S_Wide_Character));\n          Set_Component_Definition (Tdef_Node, CompDef_Node);\n@@ -1504,7 +1506,6 @@ package body CStand is\n             Write_Str (\" .. \");\n             Write_Str (IEEES_Last'Universal_Literal_String);\n \n-\n          elsif Digs = IEEEL_Digits then\n             Write_Str (IEEEL_First'Universal_Literal_String);\n             Write_Str (\" .. \");"}, {"sha": "623ee73c89813b6c4eedfb395e4c9e7aa257ed41", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -1315,6 +1315,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       layout_type (gnu_type);\n \n+      /* If the type we are dealing with is to represent a packed array,\n+\t we need to have the bits left justified on big-endian targets\n+\t (see exp_packd.ads).  We build a record with a bitfield of the\n+\t appropriate size to achieve this.  */\n       if (Is_Packed_Array_Type (gnat_entity) && BYTES_BIG_ENDIAN)\n \t{\n \t  tree gnu_field_type = gnu_type;\n@@ -1326,8 +1330,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"LJM\");\n \t  TYPE_ALIGN (gnu_type) = TYPE_ALIGN (gnu_field_type);\n \t  TYPE_PACKED (gnu_type) = 1;\n+\n+\t  /* Don't notify the field as \"addressable\", since we won't be taking\n+\t     it's address and it would prevent create_field_decl from making a\n+\t     bitfield.  */\n \t  gnu_field = create_field_decl (get_identifier (\"OBJECT\"),\n-\t\t\t\t\t gnu_field_type, gnu_type, 1, 0, 0, 1),\n+\t\t\t\t\t gnu_field_type, gnu_type, 1, 0, 0, 0);\n+\n \t  finish_record_type (gnu_type, gnu_field, 0, 0);\n \t  TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n \t  SET_TYPE_ADA_SIZE (gnu_type, bitsize_int (esize));"}, {"sha": "7b9e48254b99c1e823329d6acbc1e8457aea373f", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -41,6 +41,7 @@ with Lib;      use Lib;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Ttypes;   use Ttypes;\n with Sem;      use Sem;\n@@ -73,7 +74,7 @@ package body Exp_Aggr is\n \n    function Has_Default_Init_Comps (N : Node_Id) return Boolean;\n    --  N is an aggregate (record or array). Checks the presence of default\n-   --  initialization (<>) in any component (Ada0Y: AI-287)\n+   --  initialization (<>) in any component (Ada 0Y: AI-287)\n \n    ------------------------------------------------------\n    -- Local subprograms for Record Aggregate Expansion --\n@@ -442,7 +443,7 @@ package body Exp_Aggr is\n       --\n       --  Otherwise we call Build_Code recursively.\n       --\n-      --  Ada0Y (AI-287): In case of default initialized component, Expr is\n+      --  Ada 0Y (AI-287): In case of default initialized component, Expr is\n       --  empty and we generate a call to the corresponding IP subprogram.\n \n       function Gen_Loop (L, H : Node_Id; Expr : Node_Id) return List_Id;\n@@ -670,8 +671,8 @@ package body Exp_Aggr is\n             Res : List_Id;\n \n          begin\n-            --  Ada0Y (AI-287): Do nothing else in case of default initialized\n-            --  component\n+            --  Ada 0Y (AI-287): Do nothing else in case of default\n+            --  initialized component.\n \n             if not Present (Expr) then\n                return Lis;\n@@ -738,8 +739,8 @@ package body Exp_Aggr is\n \n          Set_Assignment_OK (Indexed_Comp);\n \n-         --  Ada0Y (AI-287): In case of default initialized component, Expr\n-         --  is not present (and therefore we also initialize Expr_Q to empty)\n+         --  Ada 0Y (AI-287): In case of default initialized component, Expr\n+         --  is not present (and therefore we also initialize Expr_Q to empty).\n \n          if not Present (Expr) then\n             Expr_Q := Empty;\n@@ -757,10 +758,11 @@ package body Exp_Aggr is\n \n          elsif Present (Next (First (New_Indices))) then\n \n-            --  Ada0Y (AI-287): Do nothing in case of default initialized\n+            --  Ada 0Y (AI-287): Do nothing in case of default initialized\n             --  component because we have received the component type in\n             --  the formal parameter Ctype.\n-            --  ??? I have added some assert pragmas to check if this new\n+\n+            --  ??? Some assert pragmas have been added to check if this new\n             --      formal can be used to replace this code in all cases.\n \n             if Present (Expr) then\n@@ -774,7 +776,6 @@ package body Exp_Aggr is\n \n                begin\n                   while Present (P) loop\n-\n                      if Nkind (P) = N_Aggregate\n                        and then Present (Etype (P))\n                      then\n@@ -785,13 +786,14 @@ package body Exp_Aggr is\n                         P := Parent (P);\n                      end if;\n                   end loop;\n+\n                   pragma Assert (Comp_Type = Ctype); --  AI-287\n                end;\n             end if;\n          end if;\n \n-         --  Ada0Y (AI-287): We only analyze the expression in case of non\n-         --  default initialized components (otherwise Expr_Q is not present)\n+         --  Ada 0Y (AI-287): We only analyze the expression in case of non\n+         --  default initialized components (otherwise Expr_Q is not present).\n \n          if Present (Expr_Q)\n            and then (Nkind (Expr_Q) = N_Aggregate\n@@ -801,7 +803,7 @@ package body Exp_Aggr is\n             --  analyzed yet because the array aggregate code has not\n             --  been updated to use the Expansion_Delayed flag and\n             --  avoid analysis altogether to solve the same problem\n-            --  (see Resolve_Aggr_Expr) so let's do the analysis of\n+            --  (see Resolve_Aggr_Expr). So let us do the analysis of\n             --  non-array aggregates now in order to get the value of\n             --  Expansion_Delayed flag for the inner aggregate ???\n \n@@ -816,8 +818,8 @@ package body Exp_Aggr is\n             end if;\n          end if;\n \n-         --  Ada0Y (AI-287): In case of default initialized component, call\n-         --  the initialization subprogram associated with the component type\n+         --  Ada 0Y (AI-287): In case of default initialized component, call\n+         --  the initialization subprogram associated with the component type.\n \n          if not Present (Expr) then\n \n@@ -916,8 +918,8 @@ package body Exp_Aggr is\n          if Empty_Range (L, H) then\n             Append_To (S, Make_Null_Statement (Loc));\n \n-            --  Ada0Y (AI-287): Nothing else need to be done in case of\n-            --  default initialized component\n+            --  Ada 0Y (AI-287): Nothing else need to be done in case of\n+            --  default initialized component.\n \n             if not Present (Expr) then\n                null;\n@@ -1335,7 +1337,8 @@ package body Exp_Aggr is\n          if Present (Component_Associations (N)) then\n             Assoc := Last (Component_Associations (N));\n \n-            --  Ada0Y (AI-287)\n+            --  Ada 0Y (AI-287)\n+\n             if Box_Present (Assoc) then\n                Append_List (Gen_While (Add (Nb_Elements, To => Aggr_L),\n                                        Aggr_High,\n@@ -1629,25 +1632,26 @@ package body Exp_Aggr is\n              Selector_Name => Make_Identifier (Loc, Name_uController));\n          Set_Assignment_OK (Ref);\n \n-         --  Ada0Y (AI-287): Give support to default initialization of limited\n-         --  types and components\n+         --  Ada 0Y (AI-287): Give support to default initialization of limited\n+         --  types and components.\n \n          if (Nkind (Target) = N_Identifier\n-             and then Present (Etype (Target))\n-             and then Is_Limited_Type (Etype (Target)))\n-           or else (Nkind (Target) = N_Selected_Component\n-                    and then Present (Etype (Selector_Name (Target)))\n-                    and then Is_Limited_Type (Etype (Selector_Name (Target))))\n-           or else (Nkind (Target) = N_Unchecked_Type_Conversion\n-                    and then Present (Etype (Target))\n-                    and then Is_Limited_Type (Etype (Target)))\n-           or else (Nkind (Target) = N_Unchecked_Expression\n-                    and then Nkind (Expression (Target)) = N_Indexed_Component\n-                    and then Present (Etype (Prefix (Expression (Target))))\n-                    and then Is_Limited_Type\n-                               (Etype (Prefix (Expression (Target)))))\n+              and then Present (Etype (Target))\n+              and then Is_Limited_Type (Etype (Target)))\n+           or else\n+            (Nkind (Target) = N_Selected_Component\n+              and then Present (Etype (Selector_Name (Target)))\n+              and then Is_Limited_Type (Etype (Selector_Name (Target))))\n+           or else\n+            (Nkind (Target) = N_Unchecked_Type_Conversion\n+              and then Present (Etype (Target))\n+              and then Is_Limited_Type (Etype (Target)))\n+           or else\n+            (Nkind (Target) = N_Unchecked_Expression\n+              and then Nkind (Expression (Target)) = N_Indexed_Component\n+              and then Present (Etype (Prefix (Expression (Target))))\n+              and then Is_Limited_Type (Etype (Prefix (Expression (Target)))))\n          then\n-\n             if Init_Pr then\n                Append_List_To (L,\n                  Build_Initialization_Call (Loc,\n@@ -1786,8 +1790,8 @@ package body Exp_Aggr is\n                   Check_Ancestor_Discriminants (Entity (A));\n                end if;\n \n-            --  Ada0Y (AI-287): If the ancestor part is a limited type, a\n-            --  recursive call expands the ancestor.\n+            --  Ada 0Y (AI-287): If the ancestor part is a limited type,\n+            --  a recursive call expands the ancestor.\n \n             elsif Is_Limited_Type (Etype (A)) then\n                Ancestor_Is_Expression := True;\n@@ -1920,15 +1924,15 @@ package body Exp_Aggr is\n       while Present (Comp) loop\n          Selector := Entity (First (Choices (Comp)));\n \n-         --  Ada0Y (AI-287): Default initialization of a limited component\n+         --  Ada 0Y (AI-287): Default initialization of a limited component\n \n          if Box_Present (Comp)\n             and then Is_Limited_Type (Etype (Selector))\n          then\n-            --  Ada0Y (AI-287): If the component type has tasks then generate\n+            --  Ada 0Y (AI-287): If the component type has tasks then generate\n             --  the activation chain and master entities (except in case of an\n             --  allocator because in that case these entities are generated\n-            --  by Build_Task_Allocate_Block_With_Init_Stmts)\n+            --  by Build_Task_Allocate_Block_With_Init_Stmts).\n \n             declare\n                Ctype            : constant Entity_Id := Etype (Selector);\n@@ -2616,12 +2620,13 @@ package body Exp_Aggr is\n          --  because of this limit.\n \n          Max_Aggr_Size : constant Nat :=\n-            5000 + (2 ** 24 - 5000) * Boolean'Pos\n-                              (Restrictions (No_Elaboration_Code)\n-                                 or else\n-                               Restrictions (No_Implicit_Loops));\n-      begin\n+                           5000 + (2 ** 24 - 5000) *\n+                             Boolean'Pos\n+                               (Restriction_Active (No_Elaboration_Code)\n+                                  or else\n+                                Restriction_Active (No_Implicit_Loops));\n \n+      begin\n          if Nkind (Original_Node (N)) = N_String_Literal then\n             return True;\n          end if;\n@@ -2741,14 +2746,15 @@ package body Exp_Aggr is\n                                     Cunit_Entity (Current_Sem_Unit);\n \n                            begin\n-                              if Restrictions (No_Elaboration_Code)\n-                                or else Restrictions (No_Implicit_Loops)\n+                              if Restriction_Active (No_Elaboration_Code)\n+                                or else Restriction_Active (No_Implicit_Loops)\n                                 or else Is_Preelaborated (P)\n                                 or else (Ekind (P) = E_Package_Body\n                                           and then\n                                             Is_Preelaborated (Spec_Entity (P)))\n                               then\n                                  null;\n+\n                               elsif Rep_Count > Max_Others_Replicate then\n                                  return False;\n                               end if;\n@@ -2862,7 +2868,7 @@ package body Exp_Aggr is\n    --  Start of processing for Convert_To_Positional\n \n    begin\n-      --  Ada0Y (AI-287): Do not convert in case of default initialized\n+      --  Ada 0Y (AI-287): Do not convert in case of default initialized\n       --  components because in this case will need to call the corresponding\n       --  IP procedure.\n \n@@ -4114,7 +4120,7 @@ package body Exp_Aggr is\n \n             if Has_Default_Init_Comps (N) then\n \n-               --  Ada0Y (AI-287): This case has not been analyzed???\n+               --  Ada 0Y (AI-287): This case has not been analyzed???\n \n                pragma Assert (False);\n                null;\n@@ -4328,7 +4334,7 @@ package body Exp_Aggr is\n       then\n          Convert_To_Assignments (N, Typ);\n \n-      --  Ada0Y (AI-287): In case of default initialized components we convert\n+      --  Ada 0Y (AI-287): In case of default initialized components we convert\n       --  the aggregate into assignments.\n \n       elsif Has_Default_Init_Comps (N) then"}, {"sha": "28ece6855574b4ee73fb24f122eb158c18817588", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,6 +42,7 @@ with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch7;  use Sem_Ch7;\n@@ -1023,7 +1024,7 @@ package body Exp_Attr is\n \n          if Is_Protected_Type (Conctype) then\n             if Abort_Allowed\n-              or else Restrictions (No_Entry_Queue) = False\n+              or else Restriction_Active (No_Entry_Queue) = False\n               or else Number_Entries (Conctype) > 1\n             then\n                Name :=\n@@ -1259,7 +1260,7 @@ package body Exp_Attr is\n          if Is_Protected_Type (Conctyp) then\n \n             if Abort_Allowed\n-              or else Restrictions (No_Entry_Queue) = False\n+              or else Restriction_Active (No_Entry_Queue) = False\n               or else Number_Entries (Conctyp) > 1\n             then\n                Name := New_Reference_To (RTE (RE_Protected_Count), Loc);"}, {"sha": "80ac70db61a2665b05a92c079bdfef08bfdf8d0a", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,6 +40,7 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Sem;      use Sem;\n with Sem_Ch5;  use Sem_Ch5;\n with Sem_Ch8;  use Sem_Ch8;\n@@ -141,7 +142,7 @@ package body Exp_Ch11 is\n          return;\n       end if;\n \n-      if Restrictions (No_Exception_Handlers) then\n+      if Restriction_Active (No_Exception_Handlers) then\n          return;\n       end if;\n \n@@ -953,8 +954,8 @@ package body Exp_Ch11 is\n \n       --  Register_Exception (except'Unchecked_Access);\n \n-      if not Restrictions (No_Exception_Handlers)\n-        and then not Restrictions (No_Exception_Registration)\n+      if not Restriction_Active (No_Exception_Handlers)\n+        and then not Restriction_Active (No_Exception_Registration)\n       then\n          L := New_List (\n                 Make_Procedure_Call_Statement (Loc,\n@@ -1005,7 +1006,7 @@ package body Exp_Ch11 is\n    procedure Expand_N_Handled_Sequence_Of_Statements (N : Node_Id) is\n    begin\n       if Present (Exception_Handlers (N))\n-        and then not Restrictions (No_Exception_Handlers)\n+        and then not Restriction_Active (No_Exception_Handlers)\n       then\n          Expand_Exception_Handlers (N);\n       end if;\n@@ -1135,7 +1136,7 @@ package body Exp_Ch11 is\n             --  Build a C-compatible string in case of no exception handlers,\n             --  since this is what the last chance handler is expecting.\n \n-            if Restrictions (No_Exception_Handlers) then\n+            if Restriction_Active (No_Exception_Handlers) then\n \n                --  Generate an empty message if configuration pragma\n                --  Suppress_Exception_Locations is set for this unit.\n@@ -1330,7 +1331,7 @@ package body Exp_Ch11 is\n          return;\n       end if;\n \n-      if Restrictions (No_Exception_Handlers) then\n+      if Restriction_Active (No_Exception_Handlers) then\n          return;\n       end if;\n \n@@ -1347,8 +1348,8 @@ package body Exp_Ch11 is\n       --  The same consideration applies for No_Exception_Handlers (which\n       --  is also set in High_Integrity_Mode).\n \n-      if Restrictions (No_Exceptions)\n-        or Restrictions (No_Exception_Handlers)\n+      if Restriction_Active (No_Exceptions)\n+        or Restriction_Active (No_Exception_Handlers)\n       then\n          return;\n       end if;\n@@ -1684,7 +1685,7 @@ package body Exp_Ch11 is\n \n       --  Do not generate if no exceptions\n \n-      if Restrictions (No_Exception_Handlers) then\n+      if Restriction_Active (No_Exception_Handlers) then\n          return;\n       end if;\n \n@@ -1716,7 +1717,7 @@ package body Exp_Ch11 is\n \n       --  Do not generate if no exceptions\n \n-      if Restrictions (No_Exception_Handlers) then\n+      if Restriction_Active (No_Exception_Handlers) then\n          return;\n       end if;\n \n@@ -1762,7 +1763,7 @@ package body Exp_Ch11 is\n \n       --  Nothing to do if no exceptions\n \n-      if Restrictions (No_Exception_Handlers) then\n+      if Restriction_Active (No_Exception_Handlers) then\n          return;\n       end if;\n "}, {"sha": "8982343b8d94ec26507a42f498c549cfa7929da7", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -46,6 +46,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch3;  use Sem_Ch3;\n@@ -570,7 +571,7 @@ package body Exp_Ch3 is\n       if Has_Non_Null_Base_Init_Proc (Comp_Type)\n         or else Needs_Simple_Initialization (Comp_Type)\n         or else Has_Task (Comp_Type)\n-        or else (not Restrictions (No_Initialize_Scalars)\n+        or else (not Restriction_Active (No_Initialize_Scalars)\n                    and then Is_Public (A_Type)\n                    and then Root_Type (A_Type) /= Standard_String\n                    and then Root_Type (A_Type) /= Standard_Wide_String)\n@@ -641,7 +642,7 @@ package body Exp_Ch3 is\n    begin\n       --  Nothing to do if there is no task hierarchy.\n \n-      if Restrictions (No_Task_Hierarchy) then\n+      if Restriction_Active (No_Task_Hierarchy) then\n          return;\n       end if;\n \n@@ -1105,7 +1106,7 @@ package body Exp_Ch3 is\n       --  through the outer routines.\n \n       if Has_Task (Full_Type) then\n-         if Restrictions (No_Task_Hierarchy) then\n+         if Restriction_Active (No_Task_Hierarchy) then\n \n             --  See comments in System.Tasking.Initialization.Init_RTS\n             --  for the value 3 (should be rtsfindable constant ???)\n@@ -1117,7 +1118,7 @@ package body Exp_Ch3 is\n \n          Append_To (Args, Make_Identifier (Loc, Name_uChain));\n \n-         --  Ada0Y (AI-287): In case of default initialized components\n+         --  Ada 0Y (AI-287): In case of default initialized components\n          --  with tasks, we generate a null string actual parameter.\n          --  This is just a workaround that must be improved later???\n \n@@ -1225,7 +1226,7 @@ package body Exp_Ch3 is\n                end if;\n             end if;\n \n-            --  Ada0Y (AI-287) In case of default initialized components, we\n+            --  Ada 0Y (AI-287) In case of default initialized components, we\n             --  need to generate the corresponding selected component node\n             --  to access the discriminant value. In other cases this is not\n             --  required because we are inside the init proc and we use the\n@@ -1322,7 +1323,7 @@ package body Exp_Ch3 is\n    begin\n       --  Nothing to do if there is no task hierarchy.\n \n-      if Restrictions (No_Task_Hierarchy) then\n+      if Restriction_Active (No_Task_Hierarchy) then\n          return;\n       end if;\n \n@@ -1642,7 +1643,7 @@ package body Exp_Ch3 is\n          First_Discr_Param := Next (First (Parameters));\n \n          if Has_Task (Rec_Type) then\n-            if Restrictions (No_Task_Hierarchy) then\n+            if Restriction_Active (No_Task_Hierarchy) then\n \n                --  See comments in System.Tasking.Initialization.Init_RTS\n                --  for the value 3.\n@@ -2366,7 +2367,7 @@ package body Exp_Ch3 is\n          if Is_CPP_Class (Rec_Id) then\n             return False;\n \n-         elsif not Restrictions (No_Initialize_Scalars)\n+         elsif not Restriction_Active (No_Initialize_Scalars)\n            and then Is_Public (Rec_Id)\n          then\n             return True;\n@@ -2485,13 +2486,15 @@ package body Exp_Ch3 is\n    ----------------------------\n \n    --  Generates the following subprogram:\n+\n    --    procedure Assign\n    --     (Source,   Target   : Array_Type,\n    --      Left_Lo,  Left_Hi, Right_Lo, Right_Hi : Index;\n    --      Rev :     Boolean)\n    --    is\n    --       Li1 : Index;\n    --       Ri1 : Index;\n+\n    --    begin\n    --       if Rev  then\n    --          Li1 := Left_Hi;\n@@ -2500,9 +2503,10 @@ package body Exp_Ch3 is\n    --          Li1 := Left_Lo;\n    --          Ri1 := Right_Lo;\n    --       end if;\n-   --\n+\n    --       loop\n    --             Target (Li1) := Source (Ri1);\n+\n    --             if Rev then\n    --                exit when Li2 = Left_Lo;\n    --                Li2 := Index'pred (Li2);\n@@ -2546,19 +2550,19 @@ package body Exp_Ch3 is\n                     Make_Defining_Identifier (Loc,\n                       Chars => Make_TSS_Name (Typ, TSS_Slice_Assign));\n \n-      Lnn :  constant Entity_Id :=\n-               Make_Defining_Identifier (Loc, New_Internal_Name ('L'));\n-      Rnn :  constant Entity_Id :=\n-               Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n-      --  subscripts for left and right sides\n+      Lnn : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc, New_Internal_Name ('L'));\n+      Rnn : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n+      --  Subscripts for left and right sides\n \n-      Decls  : List_Id;\n-      Loops  : Node_Id;\n-      Stats  : List_Id;\n+      Decls : List_Id;\n+      Loops : Node_Id;\n+      Stats : List_Id;\n \n    begin\n \n-      --  Build declarations for indices.\n+      --  Build declarations for indices\n \n       Decls := New_List;\n \n@@ -2576,7 +2580,7 @@ package body Exp_Ch3 is\n \n       Stats := New_List;\n \n-      --  Build initializations for indices.\n+      --  Build initializations for indices\n \n       declare\n          F_Init : constant List_Id := New_List;\n@@ -2626,7 +2630,7 @@ package body Exp_Ch3 is\n                   Expressions => New_List (New_Occurrence_Of (Rnn, Loc))))),\n           End_Label  => Empty);\n \n-      --  Build the increment/decrement statements.\n+      --  Build the increment/decrement statements\n \n       declare\n          F_Ass : constant List_Id := New_List;\n@@ -2701,8 +2705,8 @@ package body Exp_Ch3 is\n       Append_To (Stats, Loops);\n \n       declare\n-         Spec      : Node_Id;\n-         Formals   : List_Id := New_List;\n+         Spec    : Node_Id;\n+         Formals : List_Id := New_List;\n \n       begin\n          Formals := New_List (\n@@ -2766,7 +2770,7 @@ package body Exp_Ch3 is\n    ------------------------------------\n \n    --  Generates:\n-   --\n+\n    --    function _Equality (X, Y : T) return Boolean is\n    --    begin\n    --       --  Compare discriminants\n@@ -3136,9 +3140,8 @@ package body Exp_Ch3 is\n                Next_Elmt (Elmt);\n             end loop;\n \n-            --  If the derived type itself is private with a full view,\n-            --  then associate the full view with the inherited TSS_Elist\n-            --  as well.\n+            --  If the derived type itself is private with a full view, then\n+            --  associate the full view with the inherited TSS_Elist as well.\n \n             if Ekind (B_Id) in Private_Kind\n               and then Present (Full_View (B_Id))\n@@ -4013,7 +4016,7 @@ package body Exp_Ch3 is\n \n       --  In normal mode, add the others clause with the test\n \n-      if not Restrictions (No_Exception_Handlers) then\n+      if not Restriction_Active (No_Exception_Handlers) then\n          Append_To (Lst,\n            Make_Case_Statement_Alternative (Loc,\n              Discrete_Choices => New_List (Make_Others_Choice (Loc)),\n@@ -4657,17 +4660,17 @@ package body Exp_Ch3 is\n                 (Is_Incomplete_Or_Private_Type (Desig_Type)\n                    and then No (Full_View (Desig_Type))\n \n-               --  An exception is made for types defined in the run-time\n-               --  because Ada.Tags.Tag itself is such a type and cannot\n-               --  afford this unnecessary overhead that would generates a\n-               --  loop in the expansion scheme...\n+                  --  An exception is made for types defined in the run-time\n+                  --  because Ada.Tags.Tag itself is such a type and cannot\n+                  --  afford this unnecessary overhead that would generates a\n+                  --  loop in the expansion scheme...\n \n-                   and then not In_Runtime (Def_Id)\n+                  and then not In_Runtime (Def_Id)\n \n-               --  Another exception is if Restrictions (No_Finalization)\n-               --  is active, since then we know nothing is controlled.\n+                  --  Another exception is if Restrictions (No_Finalization)\n+                  --  is active, since then we know nothing is controlled.\n \n-                   and then not Restrictions (No_Finalization))\n+                  and then not Restriction_Active (No_Finalization))\n \n                --  If the designated type is not frozen yet, its controlled\n                --  status must be retrieved explicitly.\n@@ -5382,7 +5385,7 @@ package body Exp_Ch3 is\n \n       --  We also skip these if finalization is not available\n \n-      elsif Restrictions (No_Finalization) then\n+      elsif Restriction_Active (No_Finalization) then\n          null;\n \n       elsif Etype (Tag_Typ) = Tag_Typ or else Controlled_Type (Tag_Typ) then\n@@ -5696,7 +5699,7 @@ package body Exp_Ch3 is\n       --  We also skip them if dispatching is not available.\n \n       if not Is_Limited_Type (Tag_Typ)\n-        and then not Restrictions (No_Finalization)\n+        and then not Restriction_Active (No_Finalization)\n       then\n          if No (TSS (Tag_Typ, TSS_Stream_Read)) then\n             Build_Record_Read_Procedure (Loc, Tag_Typ, Decl, Ent);\n@@ -5831,7 +5834,7 @@ package body Exp_Ch3 is\n \n       --  Skip this if finalization is not available\n \n-      elsif Restrictions (No_Finalization) then\n+      elsif Restriction_Active (No_Finalization) then\n          null;\n \n       elsif (Etype (Tag_Typ) = Tag_Typ or else Is_Controlled (Tag_Typ))"}, {"sha": "3ecb496b08c0eec43a3f84e14d6924eac4a700d6", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -39,6 +39,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sinfo;    use Sinfo;\n with Sem;      use Sem;\n@@ -767,7 +768,7 @@ package body Exp_Ch5 is\n \n          --  Case of both are false with No_Implicit_Conditionals\n \n-         elsif Restrictions (No_Implicit_Conditionals) then\n+         elsif Restriction_Active (No_Implicit_Conditionals) then\n             declare\n                   T : constant Entity_Id :=\n                         Make_Defining_Identifier (Loc, Chars => Name_T);\n@@ -1710,7 +1711,7 @@ package body Exp_Ch5 is\n                --  This is skipped if we have no finalization\n \n                if Expand_Ctrl_Actions\n-                 and then not Restrictions (No_Finalization)\n+                 and then not Restriction_Active (No_Finalization)\n                then\n                   L := New_List (\n                     Make_Block_Statement (Loc,"}, {"sha": "49893a516ee94ecf23afee8586c4aa18bbaafb86", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -51,6 +51,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch6;  use Sem_Ch6;\n@@ -358,7 +359,7 @@ package body Exp_Ch6 is\n       --  since we won't be able to generate the code to handle the\n       --  recursion in any case.\n \n-      if Restrictions (No_Implicit_Conditionals) then\n+      if Restriction_Active (No_Implicit_Conditionals) then\n          return;\n       end if;\n \n@@ -1265,7 +1266,7 @@ package body Exp_Ch6 is\n          --  if we can tell that the first parameter cannot possibly be null.\n          --  This helps optimization and also generation of warnings.\n \n-         if not Restrictions (No_Exception_Handlers)\n+         if not Restriction_Active (No_Exception_Handlers)\n            and then Is_RTE (Subp, RE_Raise_Exception)\n          then\n             declare\n@@ -3004,7 +3005,7 @@ package body Exp_Ch6 is\n \n          --  Create new exception handler\n \n-         if Restrictions (No_Exception_Handlers) then\n+         if Restriction_Active (No_Exception_Handlers) then\n             Excep_Handlers := No_List;\n \n          else"}, {"sha": "2a683a27d55cdc97d0167a6599fe0dd6526d28f2", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,6 +46,7 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Output;   use Output;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Targparm; use Targparm;\n with Sinfo;    use Sinfo;\n@@ -914,7 +915,7 @@ package body Exp_Ch7 is\n \n       return (Is_Class_Wide_Type (T)\n                 and then not In_Finalization_Root (T)\n-                and then not Restrictions (No_Finalization))\n+                and then not Restriction_Active (No_Finalization))\n         or else Is_Controlled (T)\n         or else Has_Some_Controlled_Component (T)\n         or else (Is_Concurrent_Type (T)\n@@ -2207,7 +2208,7 @@ package body Exp_Ch7 is\n          end if;\n \n       elsif Is_Master then\n-         if Restrictions (No_Task_Hierarchy) = False then\n+         if Restriction_Active (No_Task_Hierarchy) = False then\n             Append_To (Stmt, Build_Runtime_Call (Loc, RE_Complete_Master));\n          end if;\n \n@@ -2253,7 +2254,7 @@ package body Exp_Ch7 is\n            and then Has_Entries (Pid)\n          then\n             if Abort_Allowed\n-              or else Restrictions (No_Entry_Queue) = False\n+              or else Restriction_Active (No_Entry_Queue) = False\n               or else Number_Entries (Pid) > 1\n             then\n                Name := New_Reference_To (RTE (RE_Service_Entries), Loc);\n@@ -2291,7 +2292,7 @@ package body Exp_Ch7 is\n            or else (Has_Attach_Handler (Pid) and then not Restricted_Profile)\n          then\n             if Abort_Allowed\n-              or else Restrictions (No_Entry_Queue) = False\n+              or else Restriction_Active (No_Entry_Queue) = False\n               or else Number_Entries (Pid) > 1\n             then\n                Unlock := New_Reference_To (RTE (RE_Unlock_Entries), Loc);"}, {"sha": "8e2f2a3e1f706f92ab1d6a828a7d071651ca99c9", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -43,6 +43,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch6;\n@@ -557,7 +558,7 @@ package body Exp_Ch9 is\n \n          elsif Has_Entries (Typ) then\n             if Abort_Allowed\n-              or else Restrictions (No_Entry_Queue) = False\n+              or else Restriction_Active (No_Entry_Queue) = False\n               or else Number_Entries (Typ) > 1\n             then\n                Protection_Type := RE_Protection_Entries;\n@@ -1201,35 +1202,24 @@ package body Exp_Ch9 is\n       S    : Entity_Id;\n \n    begin\n-      --  Ada0Y (AI-287): Do not set/get the has_master_entity reminder in\n-      --  internal scopes. Required for nested limited aggregates.\n-\n-      if not Extensions_Allowed then\n-\n-         --  Nothing to do if we already built a master entity for this scope\n-         --  or if there is no task hierarchy.\n-\n-         if Has_Master_Entity (Scope (E))\n-           or else Restrictions (No_Task_Hierarchy)\n-         then\n-            return;\n-         end if;\n+      S := Scope (E);\n \n-      else\n-         --  Ada0Y (AI-287): Similar to the previous case but skipping\n-         --  internal scopes. If we are not inside an internal scope this\n-         --  code is equivalent to the previous code.\n+      --  Ada 0Y (AI-287): Do not set/get the has_master_entity reminder in\n+      --  internal scopes. Required for nested limited aggregates.\n \n-         S := Scope (E);\n+      if Extensions_Allowed then\n          while Is_Internal (S) loop\n             S := Scope (S);\n          end loop;\n+      end if;\n \n-         if Has_Master_Entity (S)\n-           or else Restrictions (No_Task_Hierarchy)\n-         then\n-            return;\n-         end if;\n+      --  Nothing to do if we already built a master entity for this scope\n+      --  or if there is no task hierarchy.\n+\n+      if Has_Master_Entity (S)\n+        or else Restriction_Active (No_Task_Hierarchy)\n+      then\n+         return;\n       end if;\n \n       --  Otherwise first build the master entity\n@@ -1250,7 +1240,7 @@ package body Exp_Ch9 is\n       Insert_Before (P, Decl);\n       Analyze (Decl);\n \n-      --  Ada0Y (AI-287): Set the has_marter_entity reminder in the\n+      --  Ada 0Y (AI-287): Set the has_master_entity reminder in the\n       --  non-internal scope selected above.\n \n       if not Extensions_Allowed then\n@@ -1311,7 +1301,7 @@ package body Exp_Ch9 is\n       Add_Object_Pointer (Op_Decls, Pid, Loc);\n \n       if Abort_Allowed\n-        or else Restrictions (No_Entry_Queue) = False\n+        or else Restriction_Active (No_Entry_Queue) = False\n         or else Number_Entries (Pid) > 1\n       then\n          Complete := New_Reference_To (RTE (RE_Complete_Entry_Body), Loc);\n@@ -1339,7 +1329,7 @@ package body Exp_Ch9 is\n                      Make_Identifier (Loc, Name_uObject)),\n                  Attribute_Name => Name_Unchecked_Access))));\n \n-      if Restrictions (No_Exception_Handlers) then\n+      if Restriction_Active (No_Exception_Handlers) then\n          return\n            Make_Subprogram_Body (Loc,\n              Specification => Espec,\n@@ -1352,7 +1342,7 @@ package body Exp_Ch9 is\n          Set_All_Others (Ohandle);\n \n          if Abort_Allowed\n-           or else Restrictions (No_Entry_Queue) = False\n+           or else Restriction_Active (No_Entry_Queue) = False\n            or else Number_Entries (Pid) > 1\n          then\n             Complete :=\n@@ -1746,7 +1736,7 @@ package body Exp_Ch9 is\n         or else (Has_Attach_Handler (Pid) and then not Restricted_Profile)\n       then\n          if Abort_Allowed\n-           or else Restrictions (No_Entry_Queue) = False\n+           or else Restriction_Active (No_Entry_Queue) = False\n            or else Number_Entries (Pid) > 1\n          then\n             Lock_Name := New_Reference_To (RTE (RE_Lock_Entries), Loc);\n@@ -2070,7 +2060,7 @@ package body Exp_Ch9 is\n          --  parameters.\n \n          if Abort_Allowed\n-           or else Restrictions (No_Entry_Queue) = False\n+           or else Restriction_Active (No_Entry_Queue) = False\n            or else not Is_Protected_Type (Conctyp)\n            or else Number_Entries (Conctyp) > 1\n          then\n@@ -2182,7 +2172,7 @@ package body Exp_Ch9 is\n \n          if Is_Protected_Type (Conctyp) then\n             if Abort_Allowed\n-              or else Restrictions (No_Entry_Queue) = False\n+              or else Restriction_Active (No_Entry_Queue) = False\n               or else Number_Entries (Conctyp) > 1\n             then\n                --  Change the type of the index declaration\n@@ -2660,7 +2650,6 @@ package body Exp_Ch9 is\n                 Component_Definition =>\n                   Make_Component_Definition (Loc,\n                     Aliased_Present    => False,\n-\n                     Subtype_Indication =>\n                       Make_Subtype_Indication (Loc,\n                         Subtype_Mark =>\n@@ -2673,7 +2662,6 @@ package body Exp_Ch9 is\n                                 (Etype (Discrete_Subtype_Definition\n                                   (Parent (Efam))), Loc)))))));\n \n-\n          end if;\n \n          Next_Entity (Efam);\n@@ -2973,7 +2961,7 @@ package body Exp_Ch9 is\n       Call : Node_Id;\n \n    begin\n-      if Restrictions (No_Task_Hierarchy) = False then\n+      if Restriction_Active (No_Task_Hierarchy) = False then\n          Call := Build_Runtime_Call (Sloc (N), RE_Enter_Master);\n          Prepend_To (Declarations (N), Call);\n          Analyze (Call);\n@@ -4994,7 +4982,7 @@ package body Exp_Ch9 is\n \n       if Has_Entries\n         and then (Abort_Allowed\n-                    or else Restrictions (No_Entry_Queue) = False\n+                    or else Restriction_Active (No_Entry_Queue) = False\n                     or else Num_Entries > 1)\n       then\n          New_Op_Body := Build_Find_Body_Index (Pid);\n@@ -5249,7 +5237,7 @@ package body Exp_Ch9 is\n \n          elsif Has_Entries (Prottyp) then\n             if Abort_Allowed\n-              or else Restrictions (No_Entry_Queue) = False\n+              or else Restriction_Active (No_Entry_Queue) = False\n               or else Number_Entries (Prottyp) > 1\n             then\n                Protection_Subtype :=\n@@ -5572,7 +5560,7 @@ package body Exp_Ch9 is\n            New_External_Name (Chars (Prottyp), 'A'));\n \n          if Abort_Allowed\n-           or else Restrictions (No_Entry_Queue) = False\n+           or else Restriction_Active (No_Entry_Queue) = False\n            or else E_Count > 1\n          then\n             Body_Arr := Make_Object_Declaration (Loc,\n@@ -5622,7 +5610,7 @@ package body Exp_Ch9 is\n          --  no entry queue, 1 entry)\n \n          if Abort_Allowed\n-           or else Restrictions (No_Entry_Queue) = False\n+           or else Restriction_Active (No_Entry_Queue) = False\n            or else E_Count > 1\n          then\n             Sub :=\n@@ -7593,7 +7581,7 @@ package body Exp_Ch9 is\n          Append_To (Parms, New_Reference_To (B, Loc));\n \n          if Abort_Allowed\n-           or else Restrictions (No_Entry_Queue) = False\n+           or else Restriction_Active (No_Entry_Queue) = False\n            or else Number_Entries (Etype (Concval)) > 1\n          then\n             Rewrite (Call,\n@@ -8195,7 +8183,7 @@ package body Exp_Ch9 is\n                 Attribute_Name => Name_Unrestricted_Access));\n \n             if Abort_Allowed\n-              or else Restrictions (No_Entry_Queue) = False\n+              or else Restriction_Active (No_Entry_Queue) = False\n               or else Number_Entries (Ptyp) > 1\n             then\n                --  Find index mapping function (clumsy but ok for now).\n@@ -8217,7 +8205,7 @@ package body Exp_Ch9 is\n          end if;\n \n          if Abort_Allowed\n-           or else Restrictions (No_Entry_Queue) = False\n+           or else Restriction_Active (No_Entry_Queue) = False\n            or else Number_Entries (Ptyp) > 1\n          then\n             Append_To (L,\n@@ -8439,7 +8427,7 @@ package body Exp_Ch9 is\n          --  See comments in System.Tasking.Initialization.Init_RTS for the\n          --  value 3.\n \n-         if Restrictions (No_Task_Hierarchy) = False then\n+         if Restriction_Active (No_Task_Hierarchy) = False then\n             Append_To (Args, Make_Identifier (Loc, Name_uMaster));\n          else\n             Append_To (Args, Make_Integer_Literal (Loc, 3));"}, {"sha": "56c25f19ad8e093892f3a42edddef102e5030401", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -41,6 +41,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Sem;      use Sem;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n@@ -604,7 +605,7 @@ package body Exp_Util is\n       --  If Discard_Names or No_Implicit_Heap_Allocations are in effect,\n       --  generate a dummy declaration only.\n \n-      if Restrictions (No_Implicit_Heap_Allocations)\n+      if Restriction_Active (No_Implicit_Heap_Allocations)\n         or else Global_Discard_Names\n       then\n          T_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('J'));"}, {"sha": "067e019ea95f3a66dec38b4f4beb46a1dc98b28d", "filename": "gcc/ada/fname-uf.adb", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ffname-uf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ffname-uf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-uf.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -124,7 +124,8 @@ package body Fname.UF is\n \n    function Get_File_Name\n      (Uname   : Unit_Name_Type;\n-      Subunit : Boolean) return File_Name_Type\n+      Subunit : Boolean;\n+      May_Fail : Boolean := False) return File_Name_Type\n    is\n       Unit_Char : Character;\n       --  Set to 's' or 'b' for spec or body or to 'u' for a subunit\n@@ -389,7 +390,12 @@ package body Fname.UF is\n                   --  the file does not exist.\n \n                   if No_File_Check then\n-                     return Fnam;\n+                     if May_Fail then\n+                        return No_File;\n+\n+                     else\n+                        return Fnam;\n+                     end if;\n \n                   --  Otherwise we check if the file exists\n "}, {"sha": "24966bb441ed05e9aeee1c0c79a908dcf6a2dcb4", "filename": "gcc/ada/fname-uf.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ffname-uf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ffname-uf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-uf.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,7 +45,8 @@ package Fname.UF is\n \n    function Get_File_Name\n      (Uname   : Unit_Name_Type;\n-      Subunit : Boolean) return File_Name_Type;\n+      Subunit : Boolean;\n+      May_Fail : Boolean := False) return File_Name_Type;\n    --  This function returns the file name that corresponds to a given unit\n    --  name, Uname. The Subunit parameter is set True for subunits, and\n    --  false for all other kinds of units. The caller is responsible for"}, {"sha": "90f4e64b15fd66defb177ed4e1f2e11258495c0b", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -40,6 +40,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch6;  use Sem_Ch6;"}, {"sha": "cf57b02b3ac4a2809f96ebecfdefcac82171444e", "filename": "gcc/ada/g-crc32.ads", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fg-crc32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fg-crc32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-crc32.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---              Copyright (C) 2001 Ada Core Technologies, Inc.              --\n+--              Copyright (C) 2004 Ada Core Technologies, Inc.              --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,32 +78,27 @@ package GNAT.CRC32 is\n    procedure Update\n      (C     : in out CRC32;\n       Value : String);\n-   pragma Inline (Update);\n    --  For each character in the Value string call above routine\n \n    procedure Wide_Update\n      (C     : in out CRC32;\n       Value : Wide_Character);\n-   pragma Inline (Update);\n    --  Evolve CRC by including the contribution from Wide_Character'Pos (Value)\n    --  with the bytes being included in the natural memory order.\n \n    procedure Wide_Update\n      (C     : in out CRC32;\n       Value : Wide_String);\n-   pragma Inline (Update);\n    --  For each character in the Value string call above routine\n \n    procedure Update\n      (C     : in out CRC32;\n       Value : Ada.Streams.Stream_Element);\n-   pragma Inline (Update);\n    --  Evolve CRC by including the contribution from Value\n \n    procedure Update\n      (C     : in out CRC32;\n       Value : Ada.Streams.Stream_Element_Array);\n-   pragma Inline (Update);\n    --  For each element in the Value array call above routine\n \n    function Get_Value (C : CRC32) return Interfaces.Unsigned_32\n@@ -113,4 +108,6 @@ package GNAT.CRC32 is\n    --  change the value of C, so it may be used to retrieve intermediate\n    --  values of the CRC32 value during a sequence of Update calls.\n \n+   pragma Inline (Update);\n+   pragma Inline (Wide_Update);\n end GNAT.CRC32;"}, {"sha": "31cc1ad9bba23cf4ecd2027c0774123bfa9434b0", "filename": "gcc/ada/g-md5.adb", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fg-md5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fg-md5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-md5.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                B o d y                                   --\n --                                                                          --\n---              Copyright (C) 2002 Ada Core Technologies, Inc.              --\n+--            Copyright (C) 2002-2004 Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -173,6 +173,10 @@ package body GNAT.MD5 is\n       Cur : Natural := 1;\n       --  Index in Result where the next character will be placed.\n \n+      Last_Block : String (1 .. 64);\n+\n+      C1 : Context := C;\n+\n       procedure Convert (X : Unsigned_32);\n       --  Put the contribution of one of the four words (A, B, C, D) of the\n       --  Context in Result. Increments Cur.\n@@ -197,27 +201,55 @@ package body GNAT.MD5 is\n    --  Start of processing for Digest\n \n    begin\n-      Convert (C.A);\n-      Convert (C.B);\n-      Convert (C.C);\n-      Convert (C.D);\n+      --  Process characters in the context buffer, if any\n+\n+      Last_Block (1 .. C.Last) := C.Buffer (1 .. C.Last);\n+\n+      if C.Last > 56 then\n+         Last_Block (C.Last + 1 .. 64) := Padding (1 .. 64 - C.Last);\n+         Transform (C1, Last_Block);\n+         Last_Block := (others => ASCII.NUL);\n+\n+      else\n+         Last_Block (C.Last + 1 .. 56) := Padding (1 .. 56 - C.Last);\n+      end if;\n+\n+      --  Add the input length (as stored in the context) as 8 characters\n+\n+      Last_Block (57 .. 64) := (others => ASCII.NUL);\n+\n+      declare\n+         L : Unsigned_64 := Unsigned_64 (C.Length) * 8;\n+         Idx : Positive := 57;\n+\n+      begin\n+         while L > 0 loop\n+            Last_Block (Idx) := Character'Val (L and 16#Ff#);\n+            L := Shift_Right (L, 8);\n+            Idx := Idx + 1;\n+         end loop;\n+      end;\n+\n+      Transform (C1, Last_Block);\n+\n+      Convert (C1.A);\n+      Convert (C1.B);\n+      Convert (C1.C);\n+      Convert (C1.D);\n       return Result;\n    end Digest;\n \n    function Digest (S : String) return Message_Digest is\n       C : Context;\n-\n    begin\n       Update (C, S);\n       return Digest (C);\n    end Digest;\n \n    function Digest\n-     (A    : Ada.Streams.Stream_Element_Array)\n-      return Message_Digest\n+     (A : Ada.Streams.Stream_Element_Array) return Message_Digest\n    is\n       C : Context;\n-\n    begin\n       Update (C, A);\n       return Digest (C);\n@@ -450,45 +482,19 @@ package body GNAT.MD5 is\n      (C     : in out Context;\n       Input : String)\n    is\n-      Cur        : Positive := Input'First;\n-      Last_Block : String (1 .. 64);\n+      Inp : constant String := C.Buffer (1 .. C.Last) & Input;\n+      Cur        : Positive := Inp'First;\n \n    begin\n-      while Cur + 63 <= Input'Last loop\n-         Transform (C, Input (Cur .. Cur + 63));\n+      C.Length := C.Length + Input'Length;\n+\n+      while Cur + 63 <= Inp'Last loop\n+         Transform (C, Inp (Cur .. Cur + 63));\n          Cur := Cur + 64;\n       end loop;\n \n-      Last_Block (1 .. Input'Last - Cur + 1) := Input (Cur .. Input'Last);\n-\n-      if Input'Last - Cur + 1 > 56 then\n-         Cur := Input'Last - Cur + 2;\n-         Last_Block (Cur .. 64) := Padding (1 .. 64 - Cur + 1);\n-         Transform (C, Last_Block);\n-         Last_Block := (others => ASCII.NUL);\n-\n-      else\n-         Cur := Input'Last - Cur + 2;\n-         Last_Block (Cur .. 56) := Padding (1 .. 56 - Cur + 1);\n-      end if;\n-\n-      --  Add the input length as 8 characters\n-\n-      Last_Block (57 .. 64) := (others => ASCII.NUL);\n-\n-      declare\n-         L : Unsigned_64 := Unsigned_64 (Input'Length) * 8;\n-\n-      begin\n-         Cur := 57;\n-         while L > 0 loop\n-            Last_Block (Cur) := Character'Val (L and 16#Ff#);\n-            L := Shift_Right (L, 8);\n-            Cur := Cur + 1;\n-         end loop;\n-      end;\n-\n-      Transform (C, Last_Block);\n+      C.Last := Inp'Last - Cur + 1;\n+      C.Buffer (1 .. C.Last) := Inp (Cur .. Inp'Last);\n    end Update;\n \n    procedure Update"}, {"sha": "2ebd027dd652bc46d43dd6d7bf0258f24771258c", "filename": "gcc/ada/g-md5.ads", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fg-md5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fg-md5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-md5.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---           Copyright (C) 2002-2003 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 2002-2004 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -66,7 +66,7 @@ package GNAT.MD5 is\n    --  the Message-Digest of Input.\n    --\n    --  These procedures may be called successively with the same context and\n-   --  different inputs. However, several successive calls will not produce\n+   --  different inputs, and these several successive calls will produce\n    --  the same final context as a call with the concatenation of the inputs.\n \n    subtype Message_Digest is String (1 .. 32);\n@@ -98,9 +98,13 @@ private\n       B : Interfaces.Unsigned_32 := Initial_B;\n       C : Interfaces.Unsigned_32 := Initial_C;\n       D : Interfaces.Unsigned_32 := Initial_D;\n+      Buffer : String (1 .. 64)  := (others => ASCII.NUL);\n+      Last   : Natural := 0;\n+      Length : Natural := 0;\n    end record;\n \n    Initial_Context : constant Context :=\n-     (A => Initial_A, B => Initial_B, C => Initial_C, D => Initial_D);\n+     (A => Initial_A, B => Initial_B, C => Initial_C, D => Initial_D,\n+      Buffer => (others => ASCII.NUL), Last => 0, Length => 0);\n \n end GNAT.MD5;"}, {"sha": "45a2c5a0f3e94e71165e87c1833395008f47dff9", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -49,7 +49,6 @@ with Output;   use Output;\n with Prepcomp;\n with Repinfo;  use Repinfo;\n with Restrict;\n-with Rident;\n with Sem;\n with Sem_Ch8;\n with Sem_Ch12;\n@@ -127,8 +126,6 @@ begin\n \n          S : Source_File_Index;\n          N : Name_Id;\n-         R : Restrict.Restriction_Id;\n-         P : Restrict.Restriction_Parameter_Id;\n \n       begin\n          Name_Buffer (1 .. 10) := \"system.ads\";\n@@ -156,24 +153,7 @@ begin\n \n          --  Acquire configuration pragma information from Targparm\n \n-         for J in Rident.Partition_Restrictions loop\n-            R := Restrict.Partition_Restrictions (J);\n-\n-            if Targparm.Restrictions_On_Target (J) then\n-               Restrict.Restrictions (R)     := True;\n-               Restrict.Restrictions_Loc (R) := System_Location;\n-            end if;\n-         end loop;\n-\n-         for K in Rident.Restriction_Parameter_Id loop\n-            P := Restrict.Restriction_Parameter_Id (K);\n-\n-            if Targparm.Restriction_Parameters_On_Target (K) /= No_Uint then\n-               Restrict.Restriction_Parameters (P) :=\n-                 Targparm.Restriction_Parameters_On_Target (K);\n-               Restrict.Restriction_Parameters_Loc (P) := System_Location;\n-            end if;\n-         end loop;\n+         Restrict.Restrictions := Targparm.Restrictions_On_Target;\n       end;\n \n       --  Set Configurable_Run_Time mode if system.ads flag set"}, {"sha": "9dcb9f672787ba32d72e95f9977049a1f7c3fe84", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 98, "deletions": 18, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -32,6 +32,7 @@ with Binderr;  use Binderr;\n with Bindgen;  use Bindgen;\n with Bindusg;\n with Butil;    use Butil;\n+with Casing;   use Casing;\n with Csets;\n with Fmap;\n with Gnatvsn;  use Gnatvsn;\n@@ -45,7 +46,6 @@ with Switch;   use Switch;\n with Switch.B; use Switch.B;\n with Targparm; use Targparm;\n with Types;    use Types;\n-with Uintp;    use Uintp;\n \n with System.Case_Util; use System.Case_Util;\n \n@@ -69,15 +69,106 @@ procedure Gnatbind is\n    Output_File_Name_Seen : Boolean := False;\n    Output_File_Name      : String_Ptr := new String'(\"\");\n \n-   L_Switch_Seen         : Boolean := False;\n+   L_Switch_Seen : Boolean := False;\n \n-   Mapping_File          : String_Ptr := null;\n+   Mapping_File : String_Ptr := null;\n+\n+   procedure List_Applicable_Restrictions;\n+   --  List restrictions that apply to this partition if option taken\n \n    procedure Scan_Bind_Arg (Argv : String);\n    --  Scan and process binder specific arguments. Argv is a single argument.\n    --  All the one character arguments are still handled by Switch. This\n    --  routine handles -aO -aI and -I-.\n \n+   ----------------------------------\n+   -- List_Applicable_Restrictions --\n+   ----------------------------------\n+\n+   procedure List_Applicable_Restrictions is\n+\n+      --  Define those restrictions that should be output if the gnatbind\n+      --  -r switch is used. Not all restrictions are output for the reasons\n+      --  given above in the list, and this array is used to test whether\n+      --  the corresponding pragma should be listed. True means that it\n+      --  should not be listed.\n+\n+      No_Restriction_List : constant array (All_Restrictions) of Boolean :=\n+        (No_Exceptions            => True,\n+         --  Has unexpected Suppress (All_Checks) effect\n+\n+         No_Implicit_Conditionals => True,\n+         --  This could modify and pessimize generated code\n+\n+         No_Implicit_Dynamic_Code => True,\n+         --  This could modify and pessimize generated code\n+\n+         No_Implicit_Loops        => True,\n+         --  This could modify and pessimize generated code\n+\n+         No_Recursion             => True,\n+         --  Not checkable at compile time\n+\n+         No_Reentrancy            => True,\n+         --  Not checkable at compile time\n+\n+         Max_Entry_Queue_Depth    => True,\n+         --  Not checkable at compile time\n+\n+         Max_Storage_At_Blocking  => True,\n+         --  Not checkable at compile time\n+\n+         others                   => False);\n+\n+      Additional_Restrictions_Listed : Boolean := False;\n+      --  Set True if we have listed header for restrictions\n+\n+   begin\n+      --  Loop through restrictions\n+\n+      for R in All_Restrictions loop\n+         if not No_Restriction_List (R) then\n+\n+            --  We list a restriction if it is not violated, or if\n+            --  it is violated but the violation count is exactly known.\n+\n+            if Cumulative_Restrictions.Violated (R) = False\n+              or else (R in All_Parameter_Restrictions\n+                       and then\n+                         Cumulative_Restrictions.Unknown (R) = False)\n+            then\n+               if not Additional_Restrictions_Listed then\n+                  Write_Eol;\n+                  Write_Line\n+                    (\"The following additional restrictions may be\" &\n+                     \" applied to this partition:\");\n+                  Additional_Restrictions_Listed := True;\n+               end if;\n+\n+               Write_Str (\"pragma Restrictions (\");\n+\n+               declare\n+                  S : constant String := Restriction_Id'Image (R);\n+               begin\n+                  Name_Len := S'Length;\n+                  Name_Buffer (1 .. Name_Len) := S;\n+               end;\n+\n+               Set_Casing (Mixed_Case);\n+               Write_Str (Name_Buffer (1 .. Name_Len));\n+\n+               if R in All_Parameter_Restrictions then\n+                  Write_Str (\" => \");\n+                  Write_Int (Int (Cumulative_Restrictions.Count (R)));\n+               end if;\n+\n+               Write_Str (\");\");\n+               Write_Eol;\n+            end if;\n+         end if;\n+      end loop;\n+   end List_Applicable_Restrictions;\n+\n    -------------------\n    -- Scan_Bind_Arg --\n    -------------------\n@@ -448,13 +539,6 @@ begin\n \n       if No_Run_Time_Mode then\n \n-         --  Set standard restrictions\n-\n-         Restrictions_On_Target (No_Finalization)       := True;\n-         Restrictions_On_Target (No_Exception_Handlers) := True;\n-         Restrictions_On_Target (No_Tasking)            := True;\n-         Restriction_Parameters_On_Target (Max_Tasks)   := Uint_0;\n-\n          --  Set standard configuration parameters\n \n          Suppress_Standard_Library_On_Target            := True;\n@@ -539,15 +623,11 @@ begin\n       Check_Consistency;\n       Check_Configuration_Consistency;\n \n-      --  Acquire restrictions and add them to target restrictions. After\n-      --  this loop, Restrictions_On_Target entries will be set True for\n-      --  all partition-wide restrictions specified in the partition.\n+      --  List restrictions that could be applied to this partition\n \n-      for J in Partition_Restrictions loop\n-         if Restrictions (J) = 'r' then\n-            Restrictions_On_Target (J) := True;\n-         end if;\n-      end loop;\n+      if List_Restrictions then\n+         List_Applicable_Restrictions;\n+      end if;\n \n       --  Complete bind if no errors\n "}, {"sha": "313da2b06e0a8c4013b4e6a2ac1e2b48e259ca3a", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -499,6 +499,7 @@ begin\n          for Arg in Command_Arg + 1 .. Argument_Count loop\n             declare\n                The_Arg : constant String := Argument (Arg);\n+\n             begin\n                --  Check if an argument file is specified\n \n@@ -509,7 +510,7 @@ begin\n                      Last     : Natural;\n \n                   begin\n-                     --  Open the file. Fail if the file cannot be found.\n+                     --  Open the file and fail if the file cannot be found\n \n                      begin\n                         Open\n@@ -707,6 +708,7 @@ begin\n                         Fail (\"-p and -P cannot be used together\");\n \n                      elsif Argv'Length = 2 then\n+\n                         --  There is space between -P and the project file\n                         --  name. -P cannot be the last option.\n \n@@ -794,10 +796,10 @@ begin\n             Data : constant Prj.Project_Data :=\n                      Prj.Projects.Table (Project);\n \n-            Pkg  : constant Prj.Package_Id :=\n-                              Prj.Util.Value_Of\n-                                (Name        => Tool_Package_Name,\n-                                 In_Packages => Data.Decl.Packages);\n+            Pkg : constant Prj.Package_Id :=\n+                    Prj.Util.Value_Of\n+                      (Name        => Tool_Package_Name,\n+                       In_Packages => Data.Decl.Packages);\n \n             Element : Package_Element;\n \n@@ -825,6 +827,7 @@ begin\n                --  Pretty_Printer (for gnatpp) and Eliminate (for gnatelim)\n                --  have an attributed Switches, an associative array, indexed\n                --  by the name of the file.\n+\n                --  They also have an attribute Default_Switches, indexed\n                --  by the name of the programming language.\n \n@@ -1394,5 +1397,4 @@ exception\n       else\n          Set_Exit_Status (My_Exit_Status);\n       end if;\n-\n end GNATCmd;"}, {"sha": "9388fe4a82e636d5c25748859e84d877fcf4b05d", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -902,7 +902,9 @@ procedure Gnatlink is\n          end if;\n \n          for J in Objs_Begin .. Objs_End loop\n+\n             --  Opening quote for GNU linker\n+\n             if Using_GNU_Linker then\n                Status := Write (Tname_FD, Opening'Address, 1);\n             end if;\n@@ -924,7 +926,7 @@ procedure Gnatlink is\n               Linker_Objects.Table (J);\n          end loop;\n \n-         --  handle GNU linker response file footer.\n+         --  Handle GNU linker response file footer\n \n          if Using_GNU_Linker then\n             declare\n@@ -1458,8 +1460,7 @@ begin\n    --  on Unix. On non-Unix systems executables have a suffix, so the warning\n    --  will not appear. However, do not warn in the case of a cross compiler.\n \n-   --  Assume that if the executable name is not gnatlink, this is a cross\n-   --  tool.\n+   --  Assume this is a cross tool if the executable name is not gnatlink\n \n    if Base_Name (Command_Name) = \"gnatlink\"\n      and then Output_File_Name.all = \"test\"\n@@ -1470,7 +1471,7 @@ begin\n \n    --  Perform consistency checks\n \n-   --  Transform the .ali file name into the binder output file name.\n+   --  Transform the .ali file name into the binder output file name\n \n    Make_Binder_File_Names : declare\n       Fname     : constant String  := Base_Name (Ali_File_Name.all);"}, {"sha": "08ea8bf62c79317d7005da87c1c7dd5fcc625ec5", "filename": "gcc/ada/gprcmd.adb", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fgprcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fgprcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgprcmd.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -61,7 +61,8 @@ procedure Gprcmd is\n    --  If the file cannot be read, exit the process with an error code.\n \n    procedure Check_Args (Condition : Boolean);\n-   --  If Condition is false, print the usage, and exit the process.\n+   --  If Condition is false, print command invoked, then the usage,\n+   --  and exit the process.\n \n    procedure Deps (Objext : String; File : String; GCC : Boolean);\n    --  Process $(CC) dependency file. If GCC is True, add a rule so that make\n@@ -109,6 +110,15 @@ procedure Gprcmd is\n    procedure Check_Args (Condition : Boolean) is\n    begin\n       if not Condition then\n+         Put_Line\n+           (Standard_Error,\n+            \"bad call to gprcmd with\" & Argument_Count'Img & \" arguments.\");\n+         for J in 0 .. Argument_Count loop\n+            Put (Standard_Error, Argument (J) & \" \");\n+         end loop;\n+\n+         New_Line (Standard_Error);\n+\n          Usage;\n       end if;\n    end Check_Args;\n@@ -336,6 +346,8 @@ procedure Gprcmd is\n                                 \"post process dependency makefiles\");\n       Put_Line (Standard_Error, \"  stamp       \" &\n                                 \"copy file time stamp from file1 to file2\");\n+      Put_Line (Standard_Error, \"  prefix      \" &\n+                                \"get the prefix of the GNAT installation\");\n       OS_Exit (1);\n    end Usage;\n \n@@ -460,6 +472,11 @@ begin\n                end if;\n             end if;\n          end;\n+\n+      else\n+         --  Uknown command\n+\n+         Check_Args (False);\n       end if;\n    end;\n end Gprcmd;"}, {"sha": "a7aff1b9d0b522de5e28ab57c76e85dfa5733e8d", "filename": "gcc/ada/i-cobol.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fi-cobol.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fi-cobol.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cobol.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                             (ASCII Version)                              --\n --                                                                          --\n---          Copyright (C) 1993-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1993-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -457,7 +457,6 @@ package Interfaces.COBOL is\n       pragma Inline (To_Binary);\n       pragma Inline (To_Decimal);\n       pragma Inline (To_Display);\n-      pragma Inline (To_Decimal);\n       pragma Inline (To_Long_Binary);\n       pragma Inline (Valid);\n "}, {"sha": "4e4400f63b72f333873b1eac81028fee50d8fca2", "filename": "gcc/ada/init.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2004 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -448,6 +448,29 @@ __gnat_install_handler (void)\n {\n   struct sigaction act;\n \n+  /* stack-checking on this platform is performed by the back-end and conforms\n+     to what the ABI *mandates* (DEC OSF/1 Calling standard for AXP systems,\n+     chapter 6: Stack Limits in Multihtreaded Execution Environments).  This\n+     does not include a \"stack reserve\" region, so nothing guarantees that\n+     enough room remains on the current stack to propagate an exception when\n+     a stack-overflow is signaled.  We deal with this by requesting the use of\n+     an alternate stack region for signal handlers.\n+\n+     ??? The actual use of this alternate region depends on the act.sa_flags\n+     including SA_ONSTACK below.  Care should be taken to update s-intman if\n+     we want this to happen for tasks also.  */\n+\n+  static char sig_stack [8*1024];\n+  /* 8K allocated here because 4K is not enough for the GCC/ZCX scheme.  */\n+\n+  struct sigaltstack ss;\n+\n+  ss.ss_sp = (void *) & sig_stack;\n+  ss.ss_size = sizeof (sig_stack);\n+  ss.ss_flags = 0;\n+\n+  sigaltstack (&ss, 0);\n+\n   /* Setup signal handler to map synchronous signals to appropriate\n      exceptions. Make sure that the handler isn't interrupted by another\n      signal that might cause a scheduling event! */"}, {"sha": "8cf1e1ee8b4c618f1dade52a228daefc0312a9f7", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,6 +41,7 @@ with Osint;    use Osint;\n with Osint.C;  use Osint.C;\n with Par;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Scn;      use Scn;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n@@ -645,7 +646,14 @@ package body Lib.Writ is\n \n                if Is_Spec_Name (Uname) then\n                   Body_Fname :=\n-                    Get_File_Name (Get_Body_Name (Uname), Subunit => False);\n+                    Get_File_Name\n+                      (Get_Body_Name (Uname),\n+                       Subunit => False, May_Fail => True);\n+\n+                  if Body_Fname = No_File then\n+                     Body_Fname := Get_File_Name (Uname, Subunit => False);\n+                  end if;\n+\n                else\n                   Body_Fname := Get_File_Name (Uname, Subunit => False);\n                end if;\n@@ -910,20 +918,21 @@ package body Lib.Writ is\n            or else Unit = Main_Unit\n          then\n             if not Has_No_Elaboration_Code (Cunit (Unit)) then\n-               Violations (No_ELaboration_Code) := True;\n+               Main_Restrictions.Violated (No_Elaboration_Code) := True;\n+               Main_Restrictions.Count    (No_Elaboration_Code) := -1;\n             end if;\n          end if;\n       end loop;\n \n-      --  Output restrictions line\n+      --  Output first restrictions line\n \n       Write_Info_Initiate ('R');\n       Write_Info_Char (' ');\n \n-      for J in All_Restrictions loop\n-         if Main_Restrictions (J) then\n+      for R in All_Boolean_Restrictions loop\n+         if Main_Restrictions.Set (R) then\n             Write_Info_Char ('r');\n-         elsif Violations (J) then\n+         elsif Main_Restrictions.Violated (R) then\n             Write_Info_Char ('v');\n          else\n             Write_Info_Char ('n');\n@@ -932,6 +941,35 @@ package body Lib.Writ is\n \n       Write_Info_EOL;\n \n+      --  Output second restrictions line\n+\n+      Write_Info_Initiate ('R');\n+      Write_Info_Char (' ');\n+\n+      for RP in All_Parameter_Restrictions loop\n+         if Main_Restrictions.Set (RP) then\n+            Write_Info_Char ('r');\n+            Write_Info_Nat (Nat (Main_Restrictions.Value (RP)));\n+         else\n+            Write_Info_Char ('n');\n+         end if;\n+\n+         if not Main_Restrictions.Violated (RP)\n+           or else RP not in Checked_Parameter_Restrictions\n+         then\n+            Write_Info_Char ('n');\n+         else\n+            Write_Info_Char ('v');\n+            Write_Info_Nat (Nat (Main_Restrictions.Count (RP)));\n+\n+            if Main_Restrictions.Unknown (RP) then\n+               Write_Info_Char ('+');\n+            end if;\n+         end if;\n+      end loop;\n+\n+      Write_Info_EOL;\n+\n       --  Output interrupt state lines\n \n       for J in Interrupt_States.First .. Interrupt_States.Last loop"}, {"sha": "cdd456bfade25e7f1cb2a3891c0f41affabb0dd5", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -205,12 +205,17 @@ package Lib.Writ is\n    --  -- R  Restrictions --\n    --  ---------------------\n \n+   --  Two lines are generated to record the status of restrictions that can\n+   --  be specified by pragma Restrictions. The first of these lines refers\n+   --  to Restriction_Id values:\n+\n    --    R <<restriction-characters>>\n \n-   --      This line records information regarding restrictions. The\n-   --      parameter is a string of characters, one for each entry in\n-   --      Restrict.Compilation_Unit_Restrictions, in order. There are\n-   --      three settings possible settings for each restriction:\n+   --      This line records information regarding restrictions that do\n+   --      not take parameter values. Here \"restriction-characters is a\n+   --      string of characters, one for each value (in order) defined\n+   --      in Restrict.All_Boolean_Restrictions. There are three possible\n+   --      settings for each restriction:\n \n    --        r   Restricted. Unit was compiled under control of a pragma\n    --            Restrictions for the corresponding restriction. In\n@@ -231,6 +236,58 @@ package Lib.Writ is\n    --      has \"v\", which is not permitted, since these restrictions\n    --      are partition-wide.\n \n+   --  The second R line refers to parameter restrictions:\n+\n+   --    R <<restriction-parameter-id-entries>>\n+\n+   --      The parameter is a string of entries, one for each value in\n+   --      Restrict.All_Parameter_Restrictions. Each entry has two\n+   --      components in sequence, the first indicating whether or not\n+   --      there is a restriction, and the second indicating whether\n+   --      or not the compiler detected violations. In the boolean case\n+   --      it is not necessary to separate these, since if a restriction\n+   --      is set, and violated, that is an error. But in the parameter\n+   --      case, this is not true. For example, we can have a unit with\n+   --      a pragma Restrictions (Max_Tasks => 4), where the compiler\n+   --      can detect that there are exactly three tasks declared. Both\n+   --      of these pieces of information must be passed to the binder.\n+   --      The parameter of 4 is important in case the total number of\n+   --      tasks in the partition is greater than 4. The parameter of\n+   --      3 is important in case some other unit has a restrictions\n+   --      pragma with Max_Tasks=>2.\n+\n+   --      The component for the presence of restriction has one of two\n+   --      possible forms:\n+\n+   --         n   No pragma for this restriction is present in the\n+   --             set of units for this ali file.\n+\n+   --         rN  At least one pragma for this restriction is present\n+   --             in the set of units for this ali file. The value N\n+   --             is the minimum parameter value encountered in any\n+   --             such pragma. N is in the range of Integer (a value\n+   --             larger than N'Last causes the pragma to be ignored).\n+\n+   --      The component for the violation detection has one of three\n+   --      possible forms:\n+\n+   --         n   No violations were detected by the compiler\n+\n+   --         vN  A violation was detected. N is either the maximum or total\n+   --             count of violations (depending on the checking type) in\n+   --             all the units represented by the ali file). Note that\n+   --             this setting is only allowed for restrictions that are\n+   --             in Checked_[Max|Sum]_Parameter_Restrictions. The value\n+   --             here is known to be exact by the compiler and is in the\n+   --             range of Natural.\n+\n+   --         vN+ A violation was detected. The compiler cannot determine\n+   --             the exact count of violations, but it is at least N.\n+\n+   --      There are no spaces in the line, so the entry for the example\n+   --      in the header of this section for Max_Tasks would appear as\n+   --      the string r4v3.\n+\n    --  ------------------------\n    --  -- I Interrupt States --\n    --  ------------------------"}, {"sha": "5dae5819ab6b51935f4da923588e8ceacad4b8f1", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -453,7 +453,7 @@ package Lib is\n    --  same value for each argument.\n \n    function In_Same_Code_Unit (N1, N2 : Node_Or_Entity_Id) return Boolean;\n-   pragma Inline (In_Same_Source_Unit);\n+   pragma Inline (In_Same_Code_Unit);\n    --  Determines if the two nodes or entities N1 and N2 are in the same\n    --  code unit, the criterion being that Get_Code_Unit yields the same\n    --  value for each argument."}, {"sha": "720f6b642668522d292c7a9ba5c384a6b94558fd", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 111, "deletions": 18, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -28,6 +28,7 @@ pragma Style_Checks (All_Checks);\n --  Turn off subprogram body ordering check. Subprograms are in order\n --  by RM section rather than alphabetical\n \n+with Hostparm; use Hostparm;\n with Sinfo.CN; use Sinfo.CN;\n \n separate (Par)\n@@ -988,6 +989,7 @@ package body Ch3 is\n \n    --  OBJECT_RENAMING_DECLARATION ::=\n    --    DEFINING_IDENTIFIER : SUBTYPE_MARK renames object_NAME;\n+   --  | DEFINING_IDENTIFIER : ACCESS_DEFINITION renames object_NAME;\n \n    --  EXCEPTION_RENAMING_DECLARATION ::=\n    --    DEFINING_IDENTIFIER : exception renames exception_NAME;\n@@ -1016,6 +1018,7 @@ package body Ch3 is\n       Done    : out Boolean;\n       In_Spec : Boolean)\n    is\n+      Acc_Node   : Node_Id;\n       Decl_Node  : Node_Id;\n       Type_Node  : Node_Id;\n       Ident_Sloc : Source_Ptr;\n@@ -1315,6 +1318,38 @@ package body Ch3 is\n             Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n             Set_Object_Definition (Decl_Node, P_Array_Type_Definition);\n \n+         --  Ada 0Y (AI-230): Access Definition case\n+\n+         elsif Token = Tok_Access then\n+            if not Extensions_Allowed then\n+               Error_Msg_SP\n+                 (\"generalized use of anonymous access types \" &\n+                  \"is an Ada 0Y extension\");\n+\n+               if OpenVMS then\n+                  Error_Msg_SP\n+                    (\"\\unit must be compiled with \" &\n+                     \"'/'E'X'T'E'N'S'I'O'N'S'_'A'L'L'O'W'E'D qualifier\");\n+               else\n+                  Error_Msg_SP\n+                    (\"\\unit must be compiled with -gnatX switch\");\n+               end if;\n+            end if;\n+\n+            Acc_Node := P_Access_Definition;\n+\n+            if Token /= Tok_Renames then\n+               Error_Msg_SC (\"'RENAMES' expected\");\n+               raise Error_Resync;\n+            end if;\n+\n+            Scan; --  past renames\n+            No_List;\n+            Decl_Node :=\n+              New_Node (N_Object_Renaming_Declaration, Ident_Sloc);\n+            Set_Access_Definition (Decl_Node, Acc_Node);\n+            Set_Name (Decl_Node, P_Name);\n+\n          --  Subtype indication case\n \n          else\n@@ -2011,7 +2046,8 @@ package body Ch3 is\n    --  DISCRETE_SUBTYPE_DEFINITION ::=\n    --    DISCRETE_SUBTYPE_INDICATION | RANGE\n \n-   --  COMPONENT_DEFINITION ::= [aliased] SUBTYPE_INDICATION\n+   --  COMPONENT_DEFINITION ::=\n+   --    [aliased] SUBTYPE_INDICATION | ACCESS_DEFINITION\n \n    --  The caller has checked that the initial token is ARRAY\n \n@@ -2082,12 +2118,42 @@ package body Ch3 is\n \n       CompDef_Node := New_Node (N_Component_Definition, Token_Ptr);\n \n-      if Token = Tok_Aliased then\n-         Set_Aliased_Present (CompDef_Node, True);\n-         Scan; -- past ALIASED\n+      --  Ada 0Y (AI-230): Access Definition case\n+\n+      if Token = Tok_Access then\n+         if not Extensions_Allowed then\n+            Error_Msg_SP\n+              (\"generalized use of anonymous access types \" &\n+               \"is an Ada 0Y extension\");\n+\n+            if OpenVMS then\n+               Error_Msg_SP\n+                 (\"\\unit must be compiled with \" &\n+                  \"'/'E'X'T'E'N'S'I'O'N'S'_'A'L'L'O'W'E'D qualifier\");\n+            else\n+               Error_Msg_SP\n+                 (\"\\unit must be compiled with -gnatX switch\");\n+            end if;\n+         end if;\n+\n+         Set_Subtype_Indication (CompDef_Node, Empty);\n+         Set_Aliased_Present    (CompDef_Node, False);\n+         Set_Access_Definition  (CompDef_Node, P_Access_Definition);\n+      else\n+         Set_Access_Definition  (CompDef_Node, Empty);\n+\n+         if Token_Name = Name_Aliased then\n+            Check_95_Keyword (Tok_Aliased, Tok_Identifier);\n+         end if;\n+\n+         if Token = Tok_Aliased then\n+            Set_Aliased_Present (CompDef_Node, True);\n+            Scan; -- past ALIASED\n+         end if;\n+\n+         Set_Subtype_Indication (CompDef_Node, P_Subtype_Indication);\n       end if;\n \n-      Set_Subtype_Indication (CompDef_Node, P_Subtype_Indication);\n       Set_Component_Definition (Def_Node, CompDef_Node);\n \n       return Def_Node;\n@@ -2228,7 +2294,6 @@ package body Ch3 is\n          Scan; -- past the left paren\n \n          if Token = Tok_Box then\n-\n             if Ada_83 then\n                Error_Msg_SC (\"(Ada 83) unknown discriminant not allowed!\");\n             end if;\n@@ -2724,7 +2789,8 @@ package body Ch3 is\n    --    DEFINING_IDENTIFIER_LIST : COMPONENT_DEFINITION\n    --      [:= DEFAULT_EXPRESSION];\n \n-   --  COMPONENT_DEFINITION ::= [aliased] SUBTYPE_INDICATION\n+   --  COMPONENT_DEFINITION ::=\n+   --    [aliased] SUBTYPE_INDICATION | ACCESS_DEFINITION\n \n    --  Error recovery: cannot raise Error_Resync, if an error occurs,\n    --  the scan is positioned past the following semicolon.\n@@ -2791,21 +2857,47 @@ package body Ch3 is\n \n             CompDef_Node := New_Node (N_Component_Definition, Token_Ptr);\n \n-            if Token_Name = Name_Aliased then\n-               Check_95_Keyword (Tok_Aliased, Tok_Identifier);\n-            end if;\n+            if Token = Tok_Access then\n+               if not Extensions_Allowed then\n+                  Error_Msg_SP\n+                    (\"Generalized use of anonymous access types \" &\n+                     \"is an Ada0X extension\");\n \n-            if Token = Tok_Aliased then\n-               Scan; -- past ALIASED\n-               Set_Aliased_Present (CompDef_Node, True);\n-            end if;\n+                  if OpenVMS then\n+                     Error_Msg_SP\n+                       (\"\\unit must be compiled with \" &\n+                        \"'/'E'X'T'E'N'S'I'O'N'S'_'A'L'L'O'W'E'D qualifier\");\n+                  else\n+                     Error_Msg_SP\n+                       (\"\\unit must be compiled with -gnatX switch\");\n+                  end if;\n+               end if;\n \n-            if Token = Tok_Array then\n-               Error_Msg_SC (\"anonymous arrays not allowed as components\");\n-               raise Error_Resync;\n+               Set_Subtype_Indication (CompDef_Node, Empty);\n+               Set_Aliased_Present    (CompDef_Node, False);\n+               Set_Access_Definition  (CompDef_Node, P_Access_Definition);\n+            else\n+\n+               Set_Access_Definition (CompDef_Node, Empty);\n+\n+               if Token_Name = Name_Aliased then\n+                  Check_95_Keyword (Tok_Aliased, Tok_Identifier);\n+               end if;\n+\n+               if Token = Tok_Aliased then\n+                  Scan; -- past ALIASED\n+                  Set_Aliased_Present (CompDef_Node, True);\n+               end if;\n+\n+               if Token = Tok_Array then\n+                  Error_Msg_SC\n+                    (\"anonymous arrays not allowed as components\");\n+                  raise Error_Resync;\n+               end if;\n+\n+               Set_Subtype_Indication (CompDef_Node, P_Subtype_Indication);\n             end if;\n \n-            Set_Subtype_Indication   (CompDef_Node, P_Subtype_Indication);\n             Set_Component_Definition (Decl_Node, CompDef_Node);\n             Set_Expression           (Decl_Node, Init_Expr_Opt);\n \n@@ -3108,6 +3200,7 @@ package body Ch3 is\n \n       if Prot_Flag then\n          Scan; -- past PROTECTED\n+\n          if Token /= Tok_Procedure and then Token /= Tok_Function then\n             Error_Msg_SC (\"FUNCTION or PROCEDURE expected\");\n          end if;"}, {"sha": "2f2f15309dfdde842e1bc63444563e15703d0635", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 290, "deletions": 225, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,11 +59,11 @@ package body Restrict is\n \n    function Abort_Allowed return Boolean is\n    begin\n-      if Restrictions (No_Abort_Statements)\n-        and then Restriction_Parameters (Max_Asynchronous_Select_Nesting) = 0\n+      if Restrictions.Set (No_Abort_Statements)\n+        and then Restrictions.Set (Max_Asynchronous_Select_Nesting)\n+        and then Restrictions.Value (Max_Asynchronous_Select_Nesting) = 0\n       then\n          return False;\n-\n       else\n          return True;\n       end if;\n@@ -79,7 +79,7 @@ package body Restrict is\n       --  Even in the error case it is a bit dubious, either gigi needs\n       --  the table locked or it does not! ???\n \n-      if Restrictions (No_Elaboration_Code)\n+      if Restrictions.Set (No_Elaboration_Code)\n         and then not Suppress_Restriction_Message (N)\n       then\n          Namet.Unlock;\n@@ -110,13 +110,12 @@ package body Restrict is\n          declare\n             Fnam : constant File_Name_Type :=\n                      Get_File_Name (U, Subunit => False);\n-            R_Id : Restriction_Id;\n \n          begin\n             if not Is_Predefined_File_Name (Fnam) then\n                return;\n \n-            --  Ada child unit spec, needs checking against list\n+            --  Predefined spec, needs checking against list\n \n             else\n                --  Pad name to 8 characters with blanks\n@@ -133,30 +132,7 @@ package body Restrict is\n                   if Name_Len = 8\n                     and then Name_Buffer (1 .. 8) = Unit_Array (J).Filenm\n                   then\n-                     R_Id := Unit_Array (J).Res_Id;\n-                     Violations (R_Id) := True;\n-\n-                     if Restrictions (R_Id) then\n-                        declare\n-                           S : constant String := Restriction_Id'Image (R_Id);\n-\n-                        begin\n-                           Error_Msg_Unit_1 := U;\n-\n-                           Error_Msg_N\n-                             (\"|dependence on $ not allowed,\", N);\n-\n-                           Name_Buffer (1 .. S'Last) := S;\n-                           Name_Len := S'Length;\n-                           Set_Casing (All_Lower_Case);\n-                           Error_Msg_Name_1 := Name_Enter;\n-                           Error_Msg_Sloc := Restrictions_Loc (R_Id);\n-\n-                           Error_Msg_N\n-                             (\"\\|violates pragma Restriction (%) #\", N);\n-                           return;\n-                        end;\n-                     end if;\n+                     Check_Restriction (Unit_Array (J).Res_Id, N);\n                   end if;\n                end loop;\n             end if;\n@@ -168,192 +144,213 @@ package body Restrict is\n    -- Check_Restriction --\n    -----------------------\n \n-   --  Case of simple identifier (no parameter)\n-\n-   procedure Check_Restriction (R : Restriction_Id; N : Node_Id) is\n+   procedure Check_Restriction\n+     (R : Restriction_Id;\n+      N : Node_Id;\n+      V : Uint := Uint_Minus_1)\n+   is\n       Rimage : constant String := Restriction_Id'Image (R);\n \n-   begin\n-      Violations (R) := True;\n+      VV : Integer;\n+      --  V converted to integer form. If V is greater than Integer'Last,\n+      --  it is reset to minus 1 (unknown value).\n \n-      if (Restrictions (R) or Restriction_Warnings (R))\n-        and then not Suppress_Restriction_Message (N)\n-      then\n-         --  Output proper message. If this is just a case of\n-         --  a restriction warning, then we output a warning msg\n+      procedure Update_Restrictions (Info : in out Restrictions_Info);\n+      --  Update violation information in Info.Violated and Info.Count\n \n-         if not Restrictions (R) then\n-            Restriction_Msg\n-              (\"?violation of restriction %\", Rimage, N);\n+      -------------------------\n+      -- Update_Restrictions --\n+      -------------------------\n \n-         --  If this is a real restriction violation, then generate\n-         --  a non-serious message with appropriate location.\n+      procedure Update_Restrictions (Info : in out Restrictions_Info) is\n+      begin\n+         --  If not violated, set as violated now\n \n-         else\n-            Error_Msg_Sloc := Restrictions_Loc (R);\n+         if not Info.Violated (R) then\n+            Info.Violated (R) := True;\n+\n+            if R in All_Parameter_Restrictions then\n+               if VV < 0 then\n+                  Info.Unknown (R) := True;\n+                  Info.Count (R) := 1;\n+               else\n+                  Info.Count (R) := VV;\n+               end if;\n+            end if;\n+\n+         --  Otherwise if violated already and a parameter restriction,\n+         --  update count by maximizing or summing depending on restriction.\n+\n+         elsif R in All_Parameter_Restrictions then\n+\n+            --  If new value is unknown, result is unknown\n+\n+            if VV < 0 then\n+               Info.Unknown (R) := True;\n \n-            --  If we have a location for the Restrictions pragma, output it\n+            --  If checked by maximization, do maximization\n \n-            if Error_Msg_Sloc > No_Location\n-              or else Error_Msg_Sloc = System_Location\n-            then\n-               Restriction_Msg\n-                 (\"|violation of restriction %#\", Rimage, N);\n+            elsif R in Checked_Max_Parameter_Restrictions then\n+               Info.Count (R) := Integer'Max (Info.Count (R), VV);\n \n-            --  Otherwise restriction was implicit (e.g. set by another pragma)\n+            --  If checked by adding, do add, checking for overflow\n+\n+            elsif R in Checked_Add_Parameter_Restrictions then\n+               declare\n+                  pragma Unsuppress (Overflow_Check);\n+               begin\n+                  Info.Count (R) := Info.Count (R) + VV;\n+               exception\n+                  when Constraint_Error =>\n+                     Info.Count (R) := Integer'Last;\n+                     Info.Unknown (R) := True;\n+               end;\n+\n+            --  Should not be able to come here, known counts should only\n+            --  occur for restrictions that are Checked_max or Checked_Sum.\n \n             else\n-               Restriction_Msg\n-                 (\"|violation of implicit restriction %\", Rimage, N);\n+               raise Program_Error;\n             end if;\n          end if;\n-      end if;\n-   end Check_Restriction;\n+      end Update_Restrictions;\n \n-   --  Case where a parameter is present, with a count\n+   --  Start of processing for Check_Restriction\n \n-   procedure Check_Restriction\n-     (R : Restriction_Parameter_Id;\n-      V : Uint;\n-      N : Node_Id)\n-   is\n    begin\n-      if Restriction_Parameters (R) /= No_Uint\n-        and then V > Restriction_Parameters (R)\n-        and then not Suppress_Restriction_Message (N)\n+      if UI_Is_In_Int_Range (V) then\n+         VV := Integer (UI_To_Int (V));\n+      else\n+         VV := -1;\n+      end if;\n+\n+      --  Count can only be specified in the checked val parameter case\n+\n+      pragma Assert (VV < 0 or else R in Checked_Val_Parameter_Restrictions);\n+\n+      --  Nothing to do if value of zero specified for parameter restriction\n+\n+      if VV = 0 then\n+         return;\n+      end if;\n+\n+      --  Update current restrictions\n+\n+      Update_Restrictions (Restrictions);\n+\n+      --  If in main extended unit, update main restrictions as well\n+\n+      if Current_Sem_Unit = Main_Unit\n+        or else In_Extended_Main_Source_Unit (N)\n       then\n-         declare\n-            S : constant String := Restriction_Parameter_Id'Image (R);\n-         begin\n-            Name_Buffer (1 .. S'Last) := S;\n-            Name_Len := S'Length;\n-            Set_Casing (All_Lower_Case);\n-            Error_Msg_Name_1 := Name_Enter;\n-            Error_Msg_Sloc := Restriction_Parameters_Loc (R);\n-            Error_Msg_N (\"|maximum value exceeded for restriction %#\", N);\n-         end;\n+         Update_Restrictions (Main_Restrictions);\n       end if;\n-   end Check_Restriction;\n \n-   --  Case where a parameter is present, no count given\n+      --  Nothing to do if restriction message suppressed\n \n-   procedure Check_Restriction\n-     (R : Restriction_Parameter_Id;\n-      N : Node_Id)\n-   is\n-   begin\n-      if Restriction_Parameters (R) = Uint_0\n-        and then not Suppress_Restriction_Message (N)\n+      if Suppress_Restriction_Message (N) then\n+         null;\n+\n+      --  If restriction not set, nothing to do\n+\n+      elsif not Restrictions.Set (R) then\n+         null;\n+\n+      --  Here if restriction set, check for violation (either this is a\n+      --  Boolean restriction, or a parameter restriction with a value of\n+      --  zero and an unknown count, or a parameter restriction with a\n+      --  known value that exceeds the restriction count).\n+\n+      elsif R in All_Boolean_Restrictions\n+        or else (Restrictions.Unknown (R)\n+                   and then Restrictions.Value (R) = 0)\n+        or else Restrictions.Count (R) > Restrictions.Value (R)\n       then\n-         declare\n-            S : constant String := Restriction_Parameter_Id'Image (R);\n-         begin\n-            Name_Buffer (1 .. S'Last) := S;\n-            Name_Len := S'Length;\n-            Set_Casing (All_Lower_Case);\n-            Error_Msg_Name_1 := Name_Enter;\n-            Error_Msg_Sloc := Restriction_Parameters_Loc (R);\n-            Error_Msg_N (\"|maximum value exceeded for restriction %#\", N);\n-         end;\n+         Error_Msg_Sloc := Restrictions_Loc (R);\n+\n+         --  If we have a location for the Restrictions pragma, output it\n+\n+         if Error_Msg_Sloc > No_Location\n+           or else Error_Msg_Sloc = System_Location\n+         then\n+            if Restriction_Warnings (R) then\n+               Restriction_Msg (\"|violation of restriction %#?\", Rimage, N);\n+            else\n+               Restriction_Msg (\"|violation of restriction %#\", Rimage, N);\n+            end if;\n+\n+         --  Otherwise we have the case of an implicit restriction\n+         --  (e.g. a restriction implicitly set by another pragma)\n+\n+         else\n+            Restriction_Msg\n+              (\"|violation of implicit restriction %\", Rimage, N);\n+         end if;\n       end if;\n    end Check_Restriction;\n \n-   -------------------------------------------\n-   -- Compilation_Unit_Restrictions_Restore --\n-   -------------------------------------------\n+   ----------------------------------------\n+   -- Cunit_Boolean_Restrictions_Restore --\n+   ----------------------------------------\n \n-   procedure Compilation_Unit_Restrictions_Restore\n-     (R : Save_Compilation_Unit_Restrictions)\n+   procedure Cunit_Boolean_Restrictions_Restore\n+     (R : Save_Cunit_Boolean_Restrictions)\n    is\n    begin\n-      for J in Compilation_Unit_Restrictions loop\n-         Restrictions (J) := R (J);\n+      for J in Cunit_Boolean_Restrictions loop\n+         Restrictions.Set (J) := R (J);\n       end loop;\n-   end Compilation_Unit_Restrictions_Restore;\n+   end Cunit_Boolean_Restrictions_Restore;\n \n-   ----------------------------------------\n-   -- Compilation_Unit_Restrictions_Save --\n-   ----------------------------------------\n+   -------------------------------------\n+   -- Cunit_Boolean_Restrictions_Save --\n+   -------------------------------------\n \n-   function Compilation_Unit_Restrictions_Save\n-     return Save_Compilation_Unit_Restrictions\n+   function Cunit_Boolean_Restrictions_Save\n+     return Save_Cunit_Boolean_Restrictions\n    is\n-      R : Save_Compilation_Unit_Restrictions;\n+      R : Save_Cunit_Boolean_Restrictions;\n \n    begin\n-      for J in Compilation_Unit_Restrictions loop\n-         R (J) := Restrictions (J);\n-         Restrictions (J) := False;\n+      for J in Cunit_Boolean_Restrictions loop\n+         R (J) := Restrictions.Set (J);\n+         Restrictions.Set (J) := False;\n       end loop;\n \n       return R;\n-   end Compilation_Unit_Restrictions_Save;\n+   end Cunit_Boolean_Restrictions_Save;\n \n    ------------------------\n    -- Get_Restriction_Id --\n    ------------------------\n \n    function Get_Restriction_Id\n-     (N    : Name_Id)\n-      return Restriction_Id\n+     (N : Name_Id) return Restriction_Id\n    is\n-      J : Restriction_Id;\n-\n    begin\n       Get_Name_String (N);\n       Set_Casing (All_Upper_Case);\n \n-      J := Restriction_Id'First;\n-      while J /= Not_A_Restriction_Id loop\n+      for J in All_Restrictions loop\n          declare\n             S : constant String := Restriction_Id'Image (J);\n-\n          begin\n-            exit when S = Name_Buffer (1 .. Name_Len);\n+            if S = Name_Buffer (1 .. Name_Len) then\n+               return J;\n+            end if;\n          end;\n-\n-         J := Restriction_Id'Succ (J);\n       end loop;\n \n-      return J;\n+      return Not_A_Restriction_Id;\n    end Get_Restriction_Id;\n \n-   ----------------------------------\n-   -- Get_Restriction_Parameter_Id --\n-   ----------------------------------\n-\n-   function Get_Restriction_Parameter_Id\n-     (N    : Name_Id)\n-      return Restriction_Parameter_Id\n-   is\n-      J : Restriction_Parameter_Id;\n-\n-   begin\n-      Get_Name_String (N);\n-      Set_Casing (All_Upper_Case);\n-\n-      J := Restriction_Parameter_Id'First;\n-      while J /= Not_A_Restriction_Parameter_Id loop\n-         declare\n-            S : constant String := Restriction_Parameter_Id'Image (J);\n-\n-         begin\n-            exit when S = Name_Buffer (1 .. Name_Len);\n-         end;\n-\n-         J := Restriction_Parameter_Id'Succ (J);\n-      end loop;\n-\n-      return J;\n-   end Get_Restriction_Parameter_Id;\n-\n    -------------------------------\n    -- No_Exception_Handlers_Set --\n    -------------------------------\n \n    function No_Exception_Handlers_Set return Boolean is\n    begin\n-      return Restrictions (No_Exception_Handlers);\n+      return Restrictions.Set (No_Exception_Handlers);\n    end No_Exception_Handlers_Set;\n \n    ------------------------\n@@ -364,24 +361,37 @@ package body Restrict is\n \n    function Restricted_Profile return Boolean is\n    begin\n-      return     Restrictions (No_Abort_Statements)\n-        and then Restrictions (No_Asynchronous_Control)\n-        and then Restrictions (No_Entry_Queue)\n-        and then Restrictions (No_Task_Hierarchy)\n-        and then Restrictions (No_Task_Allocators)\n-        and then Restrictions (No_Dynamic_Priorities)\n-        and then Restrictions (No_Terminate_Alternatives)\n-        and then Restrictions (No_Dynamic_Interrupts)\n-        and then Restrictions (No_Protected_Type_Allocators)\n-        and then Restrictions (No_Local_Protected_Objects)\n-        and then Restrictions (No_Requeue)\n-        and then Restrictions (No_Task_Attributes)\n-        and then Restriction_Parameters (Max_Asynchronous_Select_Nesting) =  0\n-        and then Restriction_Parameters (Max_Task_Entries)                =  0\n-        and then Restriction_Parameters (Max_Protected_Entries)           <= 1\n-        and then Restriction_Parameters (Max_Select_Alternatives)         =  0;\n+      return     Restrictions.Set (No_Abort_Statements)\n+        and then Restrictions.Set (No_Asynchronous_Control)\n+        and then Restrictions.Set (No_Entry_Queue)\n+        and then Restrictions.Set (No_Task_Hierarchy)\n+        and then Restrictions.Set (No_Task_Allocators)\n+        and then Restrictions.Set (No_Dynamic_Priorities)\n+        and then Restrictions.Set (No_Terminate_Alternatives)\n+        and then Restrictions.Set (No_Dynamic_Interrupts)\n+        and then Restrictions.Set (No_Protected_Type_Allocators)\n+        and then Restrictions.Set (No_Local_Protected_Objects)\n+        and then Restrictions.Set (No_Requeue_Statements)\n+        and then Restrictions.Set (No_Task_Attributes)\n+        and then Restrictions.Set (Max_Asynchronous_Select_Nesting)\n+        and then Restrictions.Set (Max_Task_Entries)\n+        and then Restrictions.Set (Max_Protected_Entries)\n+        and then Restrictions.Set (Max_Select_Alternatives)\n+        and then Restrictions.Value (Max_Asynchronous_Select_Nesting) =  0\n+        and then Restrictions.Value (Max_Task_Entries)                =  0\n+        and then Restrictions.Value (Max_Protected_Entries)           <= 1\n+        and then Restrictions.Value (Max_Select_Alternatives)         =  0;\n    end Restricted_Profile;\n \n+   ------------------------\n+   -- Restriction_Active --\n+   ------------------------\n+\n+   function Restriction_Active (R : All_Restrictions) return Boolean is\n+   begin\n+      return Restrictions.Set (R);\n+   end Restriction_Active;\n+\n    ---------------------\n    -- Restriction_Msg --\n    ---------------------\n@@ -430,25 +440,15 @@ package body Restrict is\n    -------------------\n \n    procedure Set_Ravenscar (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n-\n    begin\n       Set_Restricted_Profile (N);\n-      Restrictions (Boolean_Entry_Barriers)       := True;\n-      Restrictions (No_Select_Statements)         := True;\n-      Restrictions (No_Calendar)                  := True;\n-      Restrictions (No_Entry_Queue)               := True;\n-      Restrictions (No_Relative_Delay)            := True;\n-      Restrictions (No_Task_Termination)          := True;\n-      Restrictions (No_Implicit_Heap_Allocations) := True;\n-\n-      Restrictions_Loc (Boolean_Entry_Barriers)       := Loc;\n-      Restrictions_Loc (No_Select_Statements)         := Loc;\n-      Restrictions_Loc (No_Calendar)                  := Loc;\n-      Restrictions_Loc (No_Entry_Queue)               := Loc;\n-      Restrictions_Loc (No_Relative_Delay)            := Loc;\n-      Restrictions_Loc (No_Task_Termination)          := Loc;\n-      Restrictions_Loc (No_Implicit_Heap_Allocations) := Loc;\n+      Set_Restriction (Boolean_Entry_Barriers,       N);\n+      Set_Restriction (No_Select_Statements,         N);\n+      Set_Restriction (No_Calendar,                  N);\n+      Set_Restriction (No_Entry_Queue,               N);\n+      Set_Restriction (No_Relative_Delay,            N);\n+      Set_Restriction (No_Task_Termination,          N);\n+      Set_Restriction (No_Implicit_Heap_Allocations, N);\n    end Set_Ravenscar;\n \n    ----------------------------\n@@ -458,43 +458,107 @@ package body Restrict is\n    --  This must be coordinated with Restricted_Profile\n \n    procedure Set_Restricted_Profile (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n+   begin\n+      --  Set Boolean restrictions for Restricted Profile\n+\n+      Set_Restriction (No_Abort_Statements,          N);\n+      Set_Restriction (No_Asynchronous_Control,      N);\n+      Set_Restriction (No_Entry_Queue,               N);\n+      Set_Restriction (No_Task_Hierarchy,            N);\n+      Set_Restriction (No_Task_Allocators,           N);\n+      Set_Restriction (No_Dynamic_Priorities,        N);\n+      Set_Restriction (No_Terminate_Alternatives,    N);\n+      Set_Restriction (No_Dynamic_Interrupts,        N);\n+      Set_Restriction (No_Protected_Type_Allocators, N);\n+      Set_Restriction (No_Local_Protected_Objects,   N);\n+      Set_Restriction (No_Requeue_Statements,        N);\n+      Set_Restriction (No_Task_Attributes,           N);\n+\n+      --  Set parameter restrictions\n+\n+      Set_Restriction (Max_Asynchronous_Select_Nesting, N, 0);\n+      Set_Restriction (Max_Task_Entries,                N, 0);\n+      Set_Restriction (Max_Select_Alternatives,         N, 0);\n+      Set_Restriction (Max_Protected_Entries,           N, 1);\n+   end Set_Restricted_Profile;\n+\n+   ---------------------\n+   -- Set_Restriction --\n+   ---------------------\n+\n+   --  Case of Boolean restriction\n \n+   procedure Set_Restriction\n+     (R : All_Boolean_Restrictions;\n+      N : Node_Id)\n+   is\n    begin\n-      Restrictions (No_Abort_Statements)          := True;\n-      Restrictions (No_Asynchronous_Control)      := True;\n-      Restrictions (No_Entry_Queue)               := True;\n-      Restrictions (No_Task_Hierarchy)            := True;\n-      Restrictions (No_Task_Allocators)           := True;\n-      Restrictions (No_Dynamic_Priorities)        := True;\n-      Restrictions (No_Terminate_Alternatives)    := True;\n-      Restrictions (No_Dynamic_Interrupts)        := True;\n-      Restrictions (No_Protected_Type_Allocators) := True;\n-      Restrictions (No_Local_Protected_Objects)   := True;\n-      Restrictions (No_Requeue)                   := True;\n-      Restrictions (No_Task_Attributes)           := True;\n-\n-      Restrictions_Loc (No_Abort_Statements)          := Loc;\n-      Restrictions_Loc (No_Asynchronous_Control)      := Loc;\n-      Restrictions_Loc (No_Entry_Queue)               := Loc;\n-      Restrictions_Loc (No_Task_Hierarchy)            := Loc;\n-      Restrictions_Loc (No_Task_Allocators)           := Loc;\n-      Restrictions_Loc (No_Dynamic_Priorities)        := Loc;\n-      Restrictions_Loc (No_Terminate_Alternatives)    := Loc;\n-      Restrictions_Loc (No_Dynamic_Interrupts)        := Loc;\n-      Restrictions_Loc (No_Protected_Type_Allocators) := Loc;\n-      Restrictions_Loc (No_Local_Protected_Objects)   := Loc;\n-      Restrictions_Loc (No_Requeue)                   := Loc;\n-      Restrictions_Loc (No_Task_Attributes)           := Loc;\n-\n-      Restriction_Parameters (Max_Asynchronous_Select_Nesting) := Uint_0;\n-      Restriction_Parameters (Max_Task_Entries)                := Uint_0;\n-      Restriction_Parameters (Max_Select_Alternatives)         := Uint_0;\n-\n-      if Restriction_Parameters (Max_Protected_Entries) /= Uint_0 then\n-         Restriction_Parameters (Max_Protected_Entries) := Uint_1;\n+      Restrictions.Set (R) := True;\n+\n+      --  Set location, but preserve location of system\n+      --  restriction for nice error msg with run time name\n+\n+      if Restrictions_Loc (R) /= System_Location then\n+         Restrictions_Loc (R) := Sloc (N);\n       end if;\n-   end Set_Restricted_Profile;\n+\n+      --  Record the restriction if we are in the main unit,\n+      --  or in the extended main unit. The reason that we\n+      --  test separately for Main_Unit is that gnat.adc is\n+      --  processed with Current_Sem_Unit = Main_Unit, but\n+      --  nodes in gnat.adc do not appear to be the extended\n+      --  main source unit (they probably should do ???)\n+\n+      if Current_Sem_Unit = Main_Unit\n+        or else In_Extended_Main_Source_Unit (N)\n+      then\n+         if not Restriction_Warnings (R) then\n+            Main_Restrictions.Set (R) := True;\n+         end if;\n+      end if;\n+   end Set_Restriction;\n+\n+   --  Case of parameter restriction\n+\n+   procedure Set_Restriction\n+     (R : All_Parameter_Restrictions;\n+      N : Node_Id;\n+      V : Integer)\n+   is\n+   begin\n+      if Restrictions.Set (R) then\n+         if V < Restrictions.Value (R) then\n+            Restrictions.Value (R) := V;\n+            Restrictions_Loc (R) := Sloc (N);\n+         end if;\n+\n+      else\n+         Restrictions.Set (R) := True;\n+         Restrictions.Value (R) := V;\n+         Restrictions_Loc (R) := Sloc (N);\n+      end if;\n+\n+      --  Record the restriction if we are in the main unit,\n+      --  or in the extended main unit. The reason that we\n+      --  test separately for Main_Unit is that gnat.adc is\n+      --  processed with Current_Sem_Unit = Main_Unit, but\n+      --  nodes in gnat.adc do not appear to be the extended\n+      --  main source unit (they probably should do ???)\n+\n+      if Current_Sem_Unit = Main_Unit\n+        or else In_Extended_Main_Source_Unit (N)\n+      then\n+         if Main_Restrictions.Set (R) then\n+            if V < Main_Restrictions.Value (R) then\n+               Main_Restrictions.Value (R) := V;\n+            end if;\n+\n+         elsif not Restriction_Warnings (R) then\n+            Main_Restrictions.Set (R) := True;\n+            Main_Restrictions.Value (R) := V;\n+         end if;\n+      end if;\n+   end Set_Restriction;\n \n    ----------------------------------\n    -- Suppress_Restriction_Message --\n@@ -525,8 +589,9 @@ package body Restrict is\n \n    function Tasking_Allowed return Boolean is\n    begin\n-      return Restriction_Parameters (Max_Tasks) /= 0\n-        and then not Restrictions (No_Tasking);\n+      return not Restrictions.Set (No_Tasking)\n+        and then (not Restrictions.Set (Max_Tasks)\n+                    or else Restrictions.Value (Max_Tasks) > 0);\n    end Tasking_Allowed;\n \n end Restrict;"}, {"sha": "f29cb228f5d82d9c5f1ad5cdd450b059a34507f0", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 70, "deletions": 127, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,105 +26,57 @@\n \n --  This package deals with the implementation of the Restrictions pragma\n \n-with Rident;\n+with Rident; use Rident;\n with Types;  use Types;\n with Uintp;  use Uintp;\n \n package Restrict is\n \n-   type Restriction_Id is new Rident.Restriction_Id;\n-   --  The type Restriction_Id defines the set of restriction identifiers,\n-   --  which take no parameter (i.e. they are either present or not present).\n-   --  The actual definition is in the separate package Rident, so that\n-   --  it can easily be accessed by the binder without dragging in lots\n-   --  of stuff.\n-\n-   subtype All_Restrictions is\n-     Restriction_Id range\n-       Restriction_Id (Rident.All_Restrictions'First) ..\n-       Restriction_Id (Rident.All_Restrictions'Last);\n-   --  All restriction identifiers\n-\n-   subtype Partition_Restrictions is\n-     Restriction_Id range\n-       Restriction_Id (Rident.Partition_Restrictions'First) ..\n-       Restriction_Id (Rident.Partition_Restrictions'Last);\n-   --  Range of restriction identifiers that are checked by the binder\n-\n-   subtype Compilation_Unit_Restrictions is\n-     Restriction_Id range\n-       Restriction_Id (Rident.Compilation_Unit_Restrictions'First) ..\n-       Restriction_Id (Rident.Compilation_Unit_Restrictions'Last);\n-   --  Range of restriction identifiers not checked by binder\n-\n-   type Restriction_Parameter_Id is new Rident.Restriction_Parameter_Id;\n-   --  The type Restriction_Parameter_Id records cases where a parameter is\n-   --  present in the corresponding pragma. The actual definition is in the\n-   --  separate package Rident for consistency.\n-\n-   type Restrictions_Flags is array (Restriction_Id) of Boolean;\n-   --  Type used for arrays indexed by Restriction_Id.\n-\n-   Restrictions : Restrictions_Flags := (others => False);\n-   --  Corresponding entry is False if restriction is not active, and\n-   --  True if the restriction is active, i.e. if a pragma Restrictions\n-   --  has been seen anywhere. Note that we are happy to pick up any\n-   --  restrictions pragmas in with'ed units, since we are required to\n-   --  be consistent at link time, and we might as well find the error\n-   --  at compile time. Clients must NOT use this array for checking to\n-   --  see if a restriction is violated, instead it is required that the\n-   --  Check_Restriction subprograms be used for this purpose. The only\n-   --  legitimate direct use of this array is when the code is modified\n-   --  as a result of the restriction in some way.\n-\n-   Restrictions_Loc : array (Restriction_Id) of Source_Ptr :=\n+   Restrictions : Restrictions_Info;\n+   --  This variable records restrictions found in any units in the main\n+   --  extended unit, and in the case of restrictions checked for partition\n+   --  consistency, restrictions found in any with'ed units, parent specs\n+   --  etc, since we may as well check as much as we can at compile time.\n+   --  These variables should not be referenced directly by clients. Instead\n+   --  use Check_Restrictions to record a violation of a restriction, and\n+   --  Restriction_Active to test if a given restriction is active.\n+\n+   Restrictions_Loc : array (All_Restrictions) of Source_Ptr :=\n                        (others => No_Location);\n    --  Locations of Restrictions pragmas for error message purposes.\n    --  Valid only if corresponding entry in Restrictions is set. A value\n    --  of No_Location is used for implicit restrictions set by another\n    --  pragma, and a value of System_Location is used for restrictions\n    --  set from package Standard by the processing in Targparm.\n \n-   Main_Restrictions : Restrictions_Flags := (others => False);\n-   --  This variable saves the cumulative restrictions in effect compiling\n-   --  any unit that is part of the extended main unit (i.e. the compiled\n-   --  unit, its spec if any, and its subunits if any). The reason we keep\n-   --  track of this is for the information that goes to the binder about\n-   --  restrictions that are set. The binder will identify a unit that has\n-   --  a restrictions pragma for error message purposes, and we do not want\n-   --  to pick up a restrictions pragma in a with'ed unit for this purpose.\n-\n-   Violations : Restrictions_Flags := (others => False);\n-   --  Corresponding entry is False if the restriction has not been\n-   --  violated in the current main unit, and True if it has been violated.\n+   Main_Restrictions : Restrictions_Info;\n+   --  This variable records only restrictions found in any units of the\n+   --  main extended unit. These are the variables used for ali file output,\n+   --  since we want the binder to be able to accurately diagnose inter-unit\n+   --  restriction violations.\n \n-   Restriction_Warnings : Restrictions_Flags := (others => False);\n+   Restriction_Warnings : Rident.Restriction_Flags;\n    --  If one of these flags is set, then it means that violation of the\n    --  corresponding restriction results only in a warning message, not\n    --  in an error message, and the restriction is not otherwise enforced.\n+   --  Note that the flags in Restrictions are set to indicate that the\n+   --  restriction is set in this case, but Main_Restrictions is never\n+   --  set if Restriction_Warnings is set, so this does not look like a\n+   --  restriction to the binder.\n \n-   Restriction_Parameters :\n-     array (Restriction_Parameter_Id) of Uint := (others => No_Uint);\n-   --  This array indicates the setting of restriction parameter identifier\n-   --  values. All values are initially set to No_Uint indicating that the\n-   --  parameter is not set, and are set to the appropriate non-negative\n-   --  value if a Restrictions pragma specifies the corresponding\n-   --  restriction parameter identifier with an appropriate value.\n+   type Save_Cunit_Boolean_Restrictions is private;\n+   --  Type used for saving and restoring compilation unit restrictions.\n+   --  See Cunit_Boolean_Restrictions_[Save|Restore] subprograms.\n \n-   Restriction_Parameters_Loc :\n-     array (Restriction_Parameter_Id) of Source_Ptr;\n-   --  Locations of Restrictions pragmas for error message purposes.\n-   --  Valid only if corresponding entry in Restriction_Parameters is\n-   --  set to a value other than No_Uint.\n+   --  The following declarations establish a mapping between restriction\n+   --  identifiers, and the names of corresponding restriction library units.\n \n    type Unit_Entry is record\n       Res_Id : Restriction_Id;\n       Filenm : String (1 .. 8);\n    end record;\n \n-   type Unit_Array_Type is array (Positive range <>) of Unit_Entry;\n-\n-   Unit_Array : constant Unit_Array_Type := (\n+   Unit_Array : constant array (Positive range <>) of Unit_Entry := (\n      (No_Asynchronous_Control,    \"a-astaco\"),\n      (No_Calendar,                \"a-calend\"),\n      (No_Calendar,                \"calendar\"),\n@@ -146,19 +98,12 @@ package Restrict is\n      (No_Unchecked_Conversion,    \"unchconv\"),\n      (No_Unchecked_Deallocation,  \"a-uncdea\"),\n      (No_Unchecked_Deallocation,  \"unchdeal\"));\n-   --  This array defines the mapping between restriction identifiers and\n-   --  predefined language files containing units for which the identifier\n-   --  forbids semantic dependence.\n-\n-   type Save_Compilation_Unit_Restrictions is private;\n-   --  Type used for saving and restoring compilation unit restrictions.\n-   --  See Compilation_Unit_Restrictions_[Save|Restore] subprograms.\n \n    --  The following map has True for all GNAT pragmas. It is used to\n    --  implement pragma Restrictions (No_Implementation_Restrictions)\n    --  (which is why this restriction itself is excluded from the list).\n \n-   Implementation_Restriction : Restrictions_Flags :=\n+   Implementation_Restriction : array (All_Restrictions) of Boolean :=\n      (Boolean_Entry_Barriers             => True,\n       No_Calendar                        => True,\n       No_Dynamic_Interrupts              => True,\n@@ -173,7 +118,7 @@ package Restrict is\n       No_Local_Protected_Objects         => True,\n       No_Protected_Type_Allocators       => True,\n       No_Relative_Delay                  => True,\n-      No_Requeue                         => True,\n+      No_Requeue_Statements              => True,\n       No_Secondary_Stack                 => True,\n       No_Select_Statements               => True,\n       No_Standard_Storage_Pools          => True,\n@@ -203,33 +148,20 @@ package Restrict is\n    --  restriction (e.g. No_IO restricts the loading of unit Ada.Text_IO).\n    --  If a restriction exists post error message at the given node.\n \n-   procedure Check_Restriction (R : Restriction_Id; N : Node_Id);\n+   procedure Check_Restriction\n+     (R : Restriction_Id;\n+      N : Node_Id;\n+      V : Uint := Uint_Minus_1);\n    --  Checks that the given restriction is not set, and if it is set, an\n    --  appropriate message is posted on the given node. Also records the\n-   --  violation in the violations array. Note that it is mandatory to\n-   --  always use this routine to check if a restriction is violated. Such\n-   --  checks must never be done directly by the caller, since otherwise\n-   --  they are not properly recorded in the violations array.\n-\n-   procedure Check_Restriction\n-     (R : Restriction_Parameter_Id;\n-      V : Uint;\n-      N : Node_Id);\n-   --  Checks that the count in V does not exceed the maximum value of the\n-   --  restriction parameter value corresponding to the given restriction\n-   --  parameter identifier (if it has been set). If the count in V exceeds\n-   --  the maximum, then post an error message on node N. We use this call\n-   --  when we can tell the maximum usage at compile time. In other words,\n-   --  we guarantee that if a call is made to this routine, then the front\n-   --  end will make all necessary calls for the restriction parameter R\n-   --  to ensure that we really know the maximum value used anywhere.\n-\n-   procedure Check_Restriction (R : Restriction_Parameter_Id; N : Node_Id);\n-   --  Check that the maximum value of the restriction parameter corresponding\n-   --  to the given restriction parameter identifier is not set to zero. If\n-   --  it has been set to zero, post an error message on node N. We use this\n-   --  call in cases where we can tell at compile time that the count must be\n-   --  at least one, but we can't tell anything more.\n+   --  violation in the appropriate internal arrays. Note that it is\n+   --  mandatory to always use this routine to check if a restriction\n+   --  is violated. Such checks must never be done directly by the caller,\n+   --  since otherwise violations in the absence of restrictions are not\n+   --  properly recorded. The value of V is relevant only for parameter\n+   --  restrictions, and in this case indicates the exact count for the\n+   --  violation. If the exact count is not known, V is left at its\n+   --  default value of -1 which indicates an unknown count.\n \n    procedure Check_Elaboration_Code_Allowed (N : Node_Id);\n    --  Tests to see if elaboration code is allowed by the current restrictions\n@@ -241,8 +173,8 @@ package Restrict is\n    --  Equivalent to Check_Restriction (No_Implicit_Heap_Allocations, N).\n    --  Provided for easy use by back end, which has to check this restriction.\n \n-   function Compilation_Unit_Restrictions_Save\n-     return Save_Compilation_Unit_Restrictions;\n+   function Cunit_Boolean_Restrictions_Save\n+     return Save_Cunit_Boolean_Restrictions;\n    --  This function saves the compilation unit restriction settings, and\n    --  resets them to False. This is used e.g. when compiling a with'ed\n    --  unit to avoid incorrectly propagating restrictions. Note that it\n@@ -252,31 +184,28 @@ package Restrict is\n    --  required to be partition wide, because it allows the restriction\n    --  violation message to be given at compile time instead of link time.\n \n-   procedure Compilation_Unit_Restrictions_Restore\n-     (R : Save_Compilation_Unit_Restrictions);\n+   procedure Cunit_Boolean_Restrictions_Restore\n+     (R : Save_Cunit_Boolean_Restrictions);\n    --  This is the corresponding restore procedure to restore restrictions\n-   --  previously saved by Compilation_Unit_Restrictions_Save.\n+   --  previously saved by Cunit_Boolean_Restrictions_Save.\n \n    function Get_Restriction_Id\n-     (N    : Name_Id)\n-      return Restriction_Id;\n+     (N : Name_Id) return Restriction_Id;\n    --  Given an identifier name, determines if it is a valid restriction\n    --  identifier, and if so returns the corresponding Restriction_Id\n    --  value, otherwise returns Not_A_Restriction_Id.\n \n-   function Get_Restriction_Parameter_Id\n-     (N    : Name_Id)\n-      return Restriction_Parameter_Id;\n-   --  Given an identifier name, determines if it is a valid restriction\n-   --  parameter identifier, and if so returns the corresponding\n-   --  Restriction_Parameter_Id value, otherwise returns\n-   --  Not_A_Restriction_Parameter_Id.\n-\n    function No_Exception_Handlers_Set return Boolean;\n    --  Test to see if current restrictions settings specify that no exception\n    --  handlers are present. This function is called by Gigi when it needs to\n    --  expand an AT END clean up identifier with no exception handler.\n \n+   function Restriction_Active (R : All_Restrictions) return Boolean;\n+   pragma Inline (Restriction_Active);\n+   --  Determines if a given restriction is active. This call should only be\n+   --  used where the compiled code depends on whether the restriction is\n+   --  active. Always use Check_Restriction to record a violation.\n+\n    function Restricted_Profile return Boolean;\n    --  Tests to see if tasking operations follow the GNAT restricted run time\n    --  profile.\n@@ -286,6 +215,20 @@ package Restrict is\n    --  pragma node, which is used for error messages on any constructs that\n    --  violate the profile.\n \n+   procedure Set_Restriction\n+     (R : All_Boolean_Restrictions;\n+      N : Node_Id);\n+   --  N is a node (typically a pragma node) that has the effect of setting\n+   --  Boolean restriction R. The restriction is set in Restrictions, and\n+   --  also in Main_Restrictions if this is the main unit.\n+\n+   procedure Set_Restriction\n+     (R : All_Parameter_Restrictions;\n+      N : Node_Id;\n+      V : Integer);\n+   --  Similar to the above, except that this is used for the case of a\n+   --  parameter restriction, and the corresponding value V is given.\n+\n    procedure Set_Restricted_Profile (N : Node_Id);\n    --  Enables the set of restrictions for pragma Restricted_Run_Time. N is\n    --  the corresponding pragma node, which is used for error messages on\n@@ -298,8 +241,8 @@ package Restrict is\n    --  be non-zero.\n \n private\n-   type Save_Compilation_Unit_Restrictions is\n-     array (Compilation_Unit_Restrictions) of Boolean;\n+   type Save_Cunit_Boolean_Restrictions is\n+     array (Cunit_Boolean_Restrictions) of Boolean;\n    --  Type used for saving and restoring compilation unit restrictions.\n    --  See Compilation_Unit_Restrictions_[Save|Restore] subprograms.\n "}, {"sha": "e258e5e6755b7724aa156c4a6d027932fb84ba52", "filename": "gcc/ada/s-restri.adb", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fs-restri.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fs-restri.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-restri.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -0,0 +1,62 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . R E S T R I C T I O N S                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the GNU Public License.                                       --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Restrictions is\n+   use Rident;\n+\n+   -------------------\n+   -- Abort_Allowed --\n+   -------------------\n+\n+   function Abort_Allowed return Boolean is\n+   begin\n+      return Restrictions.Violated (No_Abort_Statements)\n+               or else\n+             Restrictions.Violated (Max_Asynchronous_Select_Nesting);\n+   end Abort_Allowed;\n+\n+   ---------------------\n+   -- Tasking_Allowed --\n+   ---------------------\n+\n+   function Tasking_Allowed return Boolean is\n+   begin\n+      return Restrictions.Violated (Max_Tasks)\n+               or else\n+             Restrictions.Violated (No_Tasking);\n+   end Tasking_Allowed;\n+\n+begin\n+   null;\n+end System.Restrictions;\n+"}, {"sha": "202428fc73f16fd88673a0dabbaed28bbcb9f7c8", "filename": "gcc/ada/s-restri.ads", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fs-restri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fs-restri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-restri.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . R E S T R I C T I O N S                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a run-time interface for checking the set of\n+--  restrictions that applies to the current partition. The information\n+--  comes both from explicit restriction pragmas present, and also from\n+--  compile time checking.\n+\n+--  The package simply contains an instantiation of System.Rident, but\n+--  with names discarded, so that we do not have image tables for the\n+--  large restriction enumeration types at run time.\n+\n+with System.Rident;\n+\n+package System.Restrictions is\n+   pragma Discard_Names;\n+   package Rident is new System.Rident;\n+\n+   Restrictions : Rident.Restrictions_Info;\n+\n+   ------------------\n+   -- Subprograms --\n+   -----------------\n+\n+   function Abort_Allowed return Boolean;\n+   pragma Inline (Abort_Allowed);\n+   --  Tests to see if abort is allowed by the current restrictions settings.\n+   --  For abort to be allowed, either No_Abort_Statements must be False,\n+   --  or Max_Asynchronous_Select_Nesting must be non-zero.\n+\n+   function Tasking_Allowed return Boolean;\n+   pragma Inline (Tasking_Allowed);\n+   --  Tests to see if tasking operations are allowed by the current\n+   --  restrictions settings. For tasking to be allowed Max_Tasks must\n+\n+end System.Restrictions;\n+\n+"}, {"sha": "37bef819f16ee4dfe18e7a67dc1609051397a20e", "filename": "gcc/ada/s-rident.ads", "status": "modified", "additions": 165, "deletions": 40, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fs-rident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fs-rident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rident.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -19,6 +19,13 @@\n -- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n -- MA 02111-1307, USA.                                                      --\n --                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the GNU Public License.                                       --\n+--                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --\n@@ -40,16 +47,17 @@ generic\n package System.Rident is\n \n    --  The following enumeration type defines the set of restriction\n-   --  identifiers not taking a parameter that are implemented in GNAT.\n+   --  identifiers that are implemented in GNAT.\n+\n    --  To add a new restriction identifier, add an entry with the name\n    --  to be used in the pragma, and add appropriate calls to the\n    --  Restrict.Check_Restriction routine.\n \n-   type Restriction_Id is (\n+   type Restriction_Id is\n \n       --  The following cases are checked for consistency in the binder\n \n-      Boolean_Entry_Barriers,                  -- GNAT (Ravenscar)\n+     (Boolean_Entry_Barriers,                  -- GNAT (Ravenscar)\n       No_Abort_Statements,                     -- (RM D.7(5), H.4(3))\n       No_Access_Subprograms,                   -- (RM H.4(17))\n       No_Allocators,                           -- (RM H.4(7))\n@@ -83,7 +91,7 @@ package System.Rident is\n       No_Recursion,                            -- (RM H.4(22))\n       No_Reentrancy,                           -- (RM H.4(23))\n       No_Relative_Delay,                       -- GNAT (Ravenscar)\n-      No_Requeue,                              -- GNAT\n+      No_Requeue_Statements,                   -- GNAT\n       No_Secondary_Stack,                      -- GNAT\n       No_Select_Statements,                    -- GNAT (Ravenscar)\n       No_Standard_Storage_Pools,               -- GNAT\n@@ -109,49 +117,166 @@ package System.Rident is\n       No_Implementation_Restrictions,          -- GNAT\n       No_Elaboration_Code,                     -- GNAT\n \n+      --  The following cases require a parameter value\n+\n+      --  The following entries are fully checked at compile/bind time,\n+      --  which means that the compiler can in general tell the minimum\n+      --  value which could be used with a restrictions pragma. The binder\n+      --  can deduce the appropriate minimum value for the partition by\n+      --  taking the maximum value required by any unit.\n+\n+      Max_Protected_Entries,                   -- (RM D.7(14))\n+      Max_Select_Alternatives,                 -- (RM D.7(12))\n+      Max_Task_Entries,                        -- (RM D.7(13), H.4(3))\n+\n+      --  The following entries are also fully checked at compile/bind\n+      --  time, and the compiler can also at least in some cases tell\n+      --  the minimum value which could be used with a restriction pragma.\n+      --  The difference is that the contributions are additive, so the\n+      --  binder deduces this value by adding the unit contributions.\n+\n+      Max_Tasks,                               -- (RM D.7(19), H.4(3))\n+\n+      --  The following entries are checked at compile time only for\n+      --  zero/nonzero entries. This means that the compiler can tell\n+      --  at compile time if a restriction value of zero is (would be)\n+      --  violated, but that is all. The compiler cannot distinguish\n+      --  between different non-zero values.\n+\n+      Max_Asynchronous_Select_Nesting,         -- (RM D.7(18), H.4(3))\n+      Max_Entry_Queue_Depth,                   -- GNAT\n+\n+      --  The remaining entries are not checked at compile/bind time\n+\n+      Max_Storage_At_Blocking,                 -- (RM D.7(17))\n+\n       Not_A_Restriction_Id);\n \n+   --  Synonyms permitted for historical purposes of compatibility\n+\n+   --   No_Requeue   synonym for No_Requeue_Statements\n+   --   No_Tasking   synonym for Max_Tasks => 0\n+\n    subtype All_Restrictions is Restriction_Id range\n-     Boolean_Entry_Barriers .. No_Elaboration_Code;\n-   --  All restrictions except Not_A_Restriction_Id\n+     Boolean_Entry_Barriers .. Max_Storage_At_Blocking;\n+   --  All restrictions (excluding only Not_A_Restriction_Id)\n \n-   --  The following range of Restriction identifiers is checked for\n-   --  consistency across a partition. The generated ali file is marked\n-   --  for each entry to show one of three possibilities:\n-   --\n-   --    Corresponding restriction is set (so unit does not violate it)\n-   --    Corresponding restriction is not violated\n-   --    Corresponding restriction is violated\n+   subtype All_Boolean_Restrictions is Restriction_Id range\n+     Boolean_Entry_Barriers .. No_Elaboration_Code;\n+   --  All restrictions which do not take a parameter\n \n-   subtype Partition_Restrictions is Restriction_Id range\n+   subtype Partition_Boolean_Restrictions is All_Boolean_Restrictions range\n      Boolean_Entry_Barriers .. Static_Storage_Size;\n+   --  Boolean restrictions that are checked for partition consistency.\n+   --  Note that all parameter restrictions are checked for partition\n+   --  consistency by default, so this distinction is only needed in the\n+   --  case of Boolean restrictions.\n \n-   --  The following set of Restriction identifiers is not checked for\n-   --  consistency across a partition. The generated ali file still\n-   --  contains indications of the above three possibilities for the\n-   --  purposes of listing applicable restrictions.\n-\n-   subtype Compilation_Unit_Restrictions is Restriction_Id range\n+   subtype Cunit_Boolean_Restrictions is All_Boolean_Restrictions range\n      Immediate_Reclamation .. No_Elaboration_Code;\n+   --  Boolean restrictions that are not checked for partition consistency\n+   --  and that thus apply only to the current unit. Note that for these\n+   --  restrictions, the compiler does not apply restrictions found in\n+   --  with'ed units, parent specs etc to the main unit.\n \n-   --  The following enumeration type defines the set of restriction\n-   --  parameter identifiers taking a parameter that are implemented in\n-   --  GNAT. To add a new restriction parameter identifier, add an entry\n-   --  with the name to be used in the pragma, and add appropriate\n-   --  calls to Restrict.Check_Restriction.\n-\n-   --  Note: the GNAT implementation currently only accomodates restriction\n-   --  parameter identifiers whose expression value is a non-negative\n-   --  integer. This is true for all language defined parameters.\n-\n-   type Restriction_Parameter_Id is (\n-     Max_Asynchronous_Select_Nesting,         -- (RM D.7(18), H.4(3))\n-     Max_Entry_Queue_Depth,                   -- GNAT\n-     Max_Protected_Entries,                   -- (RM D.7(14))\n-     Max_Select_Alternatives,                 -- (RM D.7(12))\n-     Max_Storage_At_Blocking,                 -- (RM D.7(17))\n-     Max_Task_Entries,                        -- (RM D.7(13), H.4(3))\n-     Max_Tasks,                               -- (RM D.7(19), H.4(3))\n-     Not_A_Restriction_Parameter_Id);\n+   subtype All_Parameter_Restrictions is\n+     Restriction_Id range\n+       Max_Protected_Entries .. Max_Storage_At_Blocking;\n+   --  All restrictions that are take a parameter\n+\n+   subtype Checked_Parameter_Restrictions is\n+     All_Parameter_Restrictions range\n+       Max_Protected_Entries .. Max_Entry_Queue_Depth;\n+   --  These are the parameter restrictions that can be at least partially\n+   --  checked at compile/binder time. Minimally, the compiler can detect\n+   --  violations of a restriction pragma with a value of zero reliably.\n+\n+   subtype Checked_Max_Parameter_Restrictions is\n+     Checked_Parameter_Restrictions range\n+       Max_Protected_Entries .. Max_Task_Entries;\n+   --  Restrictions with parameters that can be checked in some cases by\n+   --  maximizing among statically detected instances where the compiler\n+   --  can determine the count.\n+\n+   subtype Checked_Add_Parameter_Restrictions is\n+     Checked_Parameter_Restrictions range\n+       Max_Tasks .. Max_Tasks;\n+   --  Restrictions with parameters that can be checked in some cases by\n+   --  summing the statically detected instances where the compiler can\n+   --  determine the count.\n+\n+   subtype Checked_Val_Parameter_Restrictions is\n+     Checked_Parameter_Restrictions range\n+       Max_Protected_Entries .. Max_Tasks;\n+   --  Restrictions with parameter where the count is known at least in\n+   --  some cases by the compiler/binder.\n+\n+   subtype Checked_Zero_Parameter_Restrictions is\n+     Checked_Parameter_Restrictions range\n+       Max_Asynchronous_Select_Nesting .. Max_Entry_Queue_Depth;\n+   --  Restrictions with parameters where the compiler can detect the use of\n+   --  the feature, and hence violations of a restriction specifying a value\n+   --  of zero, but cannot detect specific values other than zero/nonzero.\n+\n+   subtype Unchecked_Parameter_Restrictions is\n+     All_Parameter_Restrictions range\n+       Max_Storage_At_Blocking .. Max_Storage_At_Blocking;\n+   --  Restrictions with parameters where the compiler cannot ever detect\n+   --  corresponding compile time usage, so the binder and compiler never\n+   --  detect violations of any restriction.\n+\n+   -------------------------------------\n+   -- Restriction Status Declarations --\n+   -------------------------------------\n+\n+   --  The following declarations are used to record the current status\n+   --  or restrictions (for the current unit, or related units, at compile\n+   --  time, and for all units in a partition at bind time or run time).\n+\n+   type Restriction_Flags  is array (All_Restrictions)           of Boolean;\n+   type Restriction_Values is array (All_Parameter_Restrictions) of Natural;\n+   type Parameter_Flags    is array (All_Parameter_Restrictions) of Boolean;\n+\n+   type Restrictions_Info is record\n+      Set : Restriction_Flags := (others => False);\n+      --  An entry is True in the Set array if a restrictions pragma has\n+      --  been encountered for the given restriction. If the value is\n+      --  True for a parameter restriction, then the corresponding entry\n+      --  in the Value array gives the minimum value encountered for any\n+      --  such restriction.\n+\n+      Value : Restriction_Values;\n+      --  If the entry for a parameter restriction in Set is True (i.e. a\n+      --  restrictions pragma for the restriction has been encountered), then\n+      --  the corresponding entry in the Value array is the minimum value\n+      --  specified by any such restrictions pragma. Note that a restrictions\n+      --  pragma specifying a value greater than Int'Last is simply ignored.\n+\n+      Violated : Restriction_Flags := (others => False);\n+      --  An entry is True in the violations array if the compiler has\n+      --  detected a violation of the restriction. For a parameter\n+      --  restriction, the Count and Unknown arrays have additional\n+      --  information.\n+\n+      Count : Restriction_Values := (others => 0);\n+      --  If an entry for a parameter restriction is True in Violated,\n+      --  the corresponding entry in the Count array may record additional\n+      --  information. If the actual minimum count is known (by taking\n+      --  maximums, or sums, depending on the restriction), it will be\n+      --  recorded in this array. If not, then the value will remain zero.\n+\n+      Unknown : Parameter_Flags := (others => False);\n+      --  If an entry for a parameter restriction is True in Violated,\n+      --  the corresponding entry in the Unknown array may record additional\n+      --  information. If the actual count is not known by the compiler (but\n+      --  is known to be non-zero), then the entry in Unknown will be True.\n+      --  This indicates that the value in Count is not known to be exact,\n+      --  and the actual violation count may be higher.\n+\n+      --  Note: If Violated (K) is True, then either Count (K) > 0 or\n+      --  Unknown (K) = True. It is possible for both these to be set.\n+      --  For example, if Count (K) = 3 and Unknown (K) is True, it means\n+      --  that the actual violation count is at least 3 but might be higher.\n+   end record;\n \n end System.Rident;"}, {"sha": "30eff082bf7acd3eb6d3a85869b241e01c0006e9", "filename": "gcc/ada/s-stoele.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fs-stoele.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fs-stoele.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stoele.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2002-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -82,7 +82,7 @@ pragma Pure (Storage_Elements);\n    function \"-\" (Left : Address; Right : Storage_Offset) return Address;\n    pragma Convention (Intrinsic, \"-\");\n    pragma Inline_Always (\"-\");\n-   pragma Pure_Function (\"+\");\n+   pragma Pure_Function (\"-\");\n \n    function \"-\" (Left, Right : Address) return Storage_Offset;\n    pragma Convention (Intrinsic, \"-\");"}, {"sha": "29f0b3643f234719116ce40116e1fa74ec5ab17b", "filename": "gcc/ada/s-thread.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fs-thread.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fs-thread.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-thread.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -61,7 +61,7 @@ package System.Threads is\n    pragma Inline (Get_Jmpbuf_Address);\n \n    procedure Set_Jmpbuf_Address (Addr : Address);\n-   pragma Inline (Get_Jmpbuf_Address);\n+   pragma Inline (Set_Jmpbuf_Address);\n \n    function  Get_Sec_Stack_Addr return  Address;\n    pragma Inline (Get_Sec_Stack_Addr);"}, {"sha": "d49be42b4c9af2dbf861ac70ac82961f4907e91a", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -42,6 +42,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sdefault; use Sdefault;\n with Sem;      use Sem;"}, {"sha": "64fcd743df09358d44fa4b16e99f48f8388e389d", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -443,8 +443,8 @@ package body Sem_Ch10 is\n \n          declare\n             Save_Style_Check : constant Boolean := Style_Check;\n-            Save_C_Restrict  : constant Save_Compilation_Unit_Restrictions :=\n-                                 Compilation_Unit_Restrictions_Save;\n+            Save_C_Restrict  : constant Save_Cunit_Boolean_Restrictions :=\n+                                 Cunit_Boolean_Restrictions_Save;\n \n          begin\n             if not GNAT_Mode then\n@@ -454,7 +454,7 @@ package body Sem_Ch10 is\n             Semantics (Parent_Spec (Unit_Node));\n             Version_Update (N, Parent_Spec (Unit_Node));\n             Style_Check := Save_Style_Check;\n-            Compilation_Unit_Restrictions_Restore (Save_C_Restrict);\n+            Cunit_Boolean_Restrictions_Restore (Save_C_Restrict);\n          end;\n       end if;\n \n@@ -607,8 +607,8 @@ package body Sem_Ch10 is\n             Un    : Unit_Number_Type;\n \n             Save_Style_Check : constant Boolean := Style_Check;\n-            Save_C_Restrict  : constant Save_Compilation_Unit_Restrictions :=\n-                                 Compilation_Unit_Restrictions_Save;\n+            Save_C_Restrict  : constant Save_Cunit_Boolean_Restrictions :=\n+                                 Cunit_Boolean_Restrictions_Save;\n \n          begin\n             Item := First (Context_Items (N));\n@@ -670,7 +670,7 @@ package body Sem_Ch10 is\n             end loop;\n \n             Style_Check := Save_Style_Check;\n-            Compilation_Unit_Restrictions_Restore (Save_C_Restrict);\n+            Cunit_Boolean_Restrictions_Restore (Save_C_Restrict);\n          end;\n       end if;\n \n@@ -1590,8 +1590,8 @@ package body Sem_Ch10 is\n       --  Set True if the unit currently being compiled is an internal unit\n \n       Save_Style_Check : constant Boolean := Opt.Style_Check;\n-      Save_C_Restrict  : constant Save_Compilation_Unit_Restrictions :=\n-                           Compilation_Unit_Restrictions_Save;\n+      Save_C_Restrict  : constant Save_Cunit_Boolean_Restrictions :=\n+                           Cunit_Boolean_Restrictions_Save;\n \n    begin\n       if Limited_Present (N) then\n@@ -1735,7 +1735,7 @@ package body Sem_Ch10 is\n       --  Restore style checks and restrictions\n \n       Style_Check := Save_Style_Check;\n-      Compilation_Unit_Restrictions_Restore (Save_C_Restrict);\n+      Cunit_Boolean_Restrictions_Restore (Save_C_Restrict);\n \n       --  Record the reference, but do NOT set the unit as referenced, we\n       --  want to consider the unit as unreferenced if this is the only"}, {"sha": "2cd1ef589ebd849a770bc54be04b302ea382bb79", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,6 +34,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch5;  use Sem_Ch5;"}, {"sha": "4b233df88b387a4170d6a103096dd3ff435a38b8", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -40,6 +40,7 @@ with Lib.Xref; use Lib.Xref;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n+with Rident;   use Rident;\n with Restrict; use Restrict;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n@@ -1468,7 +1469,7 @@ package body Sem_Ch12 is\n \n       if K = E_Generic_In_Parameter then\n \n-         --  Ada0Y (AI-287): Limited aggregates allowed in generic formals\n+         --  Ada 0Y (AI-287): Limited aggregates allowed in generic formals\n \n          if not Extensions_Allowed and then Is_Limited_Type (T) then\n             Error_Msg_N\n@@ -2377,7 +2378,7 @@ package body Sem_Ch12 is\n \n       elsif Ekind (Gen_Unit) /= E_Generic_Package then\n \n-         --  Ada0Y (AI-50217): Instance can not be used in limited with_clause\n+         --  Ada 0Y (AI-50217): Instance can not be used in limited with_clause\n \n          if From_With_Type (Gen_Unit) then\n             Error_Msg_N"}, {"sha": "ebfc834b84c8022c6956a11da3797db70c53c42a", "filename": "gcc/ada/sem_ch2.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch2.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,6 +28,7 @@ with Atree;    use Atree;\n with Errout;   use Errout;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Sem_Ch8;  use Sem_Ch8;\n with Sinfo;    use Sinfo;\n with Stand;    use Stand;"}, {"sha": "b675cc1f50a6453b9aeb68e91a921ef9513e9c34", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 132, "deletions": 28, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -43,6 +43,7 @@ with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Case; use Sem_Case;\n@@ -691,7 +692,7 @@ package body Sem_Ch3 is\n \n       Set_Is_Public          (Anon_Type, Is_Public (Scope (Anon_Type)));\n \n-      --  Ada0Y (AI-50217): Propagate the attribute that indicates that the\n+      --  Ada 0Y (AI-50217): Propagate the attribute that indicates that the\n       --  designated type comes from the limited view (for back-end purposes).\n \n       Set_From_With_Type     (Anon_Type, From_With_Type (Desig_Type));\n@@ -861,7 +862,7 @@ package body Sem_Ch3 is\n       --  access type is also imported, and therefore restricted in its use.\n       --  The access type may already be imported, so keep setting otherwise.\n \n-      --  Ada0Y (AI-50217): If the non-limited view of the designated type is\n+      --  Ada 0Y (AI-50217): If the non-limited view of the designated type is\n       --  available, use it as the designated type of the access type, so that\n       --  the back-end gets a usable entity.\n \n@@ -906,8 +907,22 @@ package body Sem_Ch3 is\n    begin\n       Generate_Definition (Id);\n       Enter_Name (Id);\n-      T := Find_Type_Of_Object (Subtype_Indication (Component_Definition (N)),\n-                                N);\n+\n+      if Present (Subtype_Indication (Component_Definition (N))) then\n+         T := Find_Type_Of_Object\n+                (Subtype_Indication (Component_Definition (N)), N);\n+\n+      --  Ada 0Y (AI-230): Access Definition case\n+\n+      elsif Present (Access_Definition (Component_Definition (N))) then\n+         T := Access_Definition\n+                (Related_Nod => N,\n+                 N => Access_Definition (Component_Definition (N)));\n+\n+      else\n+         pragma Assert (False);\n+         null;\n+      end if;\n \n       --  If the subtype is a constrained subtype of the enclosing record,\n       --  (which must have a partial view) the back-end does not handle\n@@ -1341,6 +1356,14 @@ package body Sem_Ch3 is\n       --  the subtype of the object is constrained by the defaults, so it is\n       --  worthile building the corresponding subtype.\n \n+      function Count_Tasks (T : Entity_Id) return Uint;\n+      --  This function is called when a library level object of type T\n+      --  is declared. It's function is to count the static number of\n+      --  tasks declared within the type (it is only called if Has_Tasks\n+      --  is set for T). As a side effect, if an array of tasks with\n+      --  non-static bounds or a variant record type is encountered,\n+      --  Check_Restrictions is called indicating the count is unknown.\n+\n       ---------------------------\n       -- Build_Default_Subtype --\n       ---------------------------\n@@ -1381,6 +1404,60 @@ package body Sem_Ch3 is\n          return Act;\n       end Build_Default_Subtype;\n \n+      -----------------\n+      -- Count_Tasks --\n+      -----------------\n+\n+      function Count_Tasks (T : Entity_Id) return Uint is\n+         C : Entity_Id;\n+         X : Node_Id;\n+         V : Uint;\n+\n+      begin\n+         if Is_Task_Type (T) then\n+            return Uint_1;\n+\n+         elsif Is_Record_Type (T) then\n+            if Has_Discriminants (T) then\n+               Check_Restriction (Max_Tasks, N);\n+               return Uint_0;\n+\n+            else\n+               V := Uint_0;\n+               C := First_Component (T);\n+               while Present (C) loop\n+                  V := V + Count_Tasks (Etype (C));\n+                  Next_Component (C);\n+               end loop;\n+\n+               return V;\n+            end if;\n+\n+         elsif Is_Array_Type (T) then\n+            X := First_Index (T);\n+            V := Count_Tasks (Component_Type (T));\n+            while Present (X) loop\n+               C := Etype (X);\n+\n+               if not Is_Static_Subtype (C) then\n+                  Check_Restriction (Max_Tasks, N);\n+                  return Uint_0;\n+               else\n+                  V := V * (UI_Max (Uint_0,\n+                                    Expr_Value (Type_High_Bound (C)) -\n+                                    Expr_Value (Type_Low_Bound (C)) + Uint_1));\n+               end if;\n+\n+               Next_Index (X);\n+            end loop;\n+\n+            return V;\n+\n+         else\n+            return Uint_0;\n+         end if;\n+      end Count_Tasks;\n+\n    --  Start of processing for Analyze_Object_Declaration\n \n    begin\n@@ -1851,9 +1928,13 @@ package body Sem_Ch3 is\n       end if;\n \n       if Has_Task (Etype (Id)) then\n-         Check_Restriction (Max_Tasks, N);\n+         Check_Restriction (No_Tasking, N);\n \n-         if not Is_Library_Level_Entity (Id) then\n+         if Is_Library_Level_Entity (Id) then\n+            Check_Restriction (Max_Tasks, N, Count_Tasks (Etype (Id)));\n+\n+         else\n+            Check_Restriction (Max_Tasks, N);\n             Check_Restriction (No_Task_Hierarchy, N);\n             Check_Potentially_Blocking_Operation (N);\n          end if;\n@@ -1935,6 +2016,7 @@ package body Sem_Ch3 is\n          Rewrite (N,\n            Make_Object_Renaming_Declaration (Loc,\n              Defining_Identifier => Id,\n+             Access_Definition   => Empty,\n              Subtype_Mark        => New_Occurrence_Of\n                                       (Base_Type (Etype (Id)), Loc),\n              Name                => E));\n@@ -2451,7 +2533,7 @@ package body Sem_Ch3 is\n \n       --  The full view, if present, now points to the current type\n \n-      --  Ada0Y (AI-50217): If the type was previously decorated when imported\n+      --  Ada 0Y (AI-50217): If the type was previously decorated when imported\n       --  through a LIMITED WITH clause, it appears as incomplete but has no\n       --  full view.\n \n@@ -2735,21 +2817,19 @@ package body Sem_Ch3 is\n \n    begin\n       if Nkind (Def) = N_Constrained_Array_Definition then\n-\n          Index := First (Discrete_Subtype_Definitions (Def));\n+      else\n+         Index := First (Subtype_Marks (Def));\n+      end if;\n \n-         --  Find proper names for the implicit types which may be public.\n-         --  in case of anonymous arrays we use the name of the first object\n-         --  of that type as prefix.\n-\n-         if No (T) then\n-            Related_Id :=  Defining_Identifier (P);\n-         else\n-            Related_Id := T;\n-         end if;\n+      --  Find proper names for the implicit types which may be public.\n+      --  in case of anonymous arrays we use the name of the first object\n+      --  of that type as prefix.\n \n+      if No (T) then\n+         Related_Id :=  Defining_Identifier (P);\n       else\n-         Index := First (Subtype_Marks (Def));\n+         Related_Id := T;\n       end if;\n \n       Nb_Index := 1;\n@@ -2761,8 +2841,21 @@ package body Sem_Ch3 is\n          Nb_Index := Nb_Index + 1;\n       end loop;\n \n-      Element_Type := Process_Subtype (Subtype_Indication (Component_Def),\n-                                       P, Related_Id, 'C');\n+      if Present (Subtype_Indication (Component_Def)) then\n+         Element_Type := Process_Subtype (Subtype_Indication (Component_Def),\n+                                          P, Related_Id, 'C');\n+\n+      --  Ada 0Y (AI-230): Access Definition case\n+\n+      elsif Present (Access_Definition (Component_Def)) then\n+         Element_Type := Access_Definition\n+                           (Related_Nod => Related_Id,\n+                            N           => Access_Definition (Component_Def));\n+\n+      else\n+         pragma Assert (False);\n+         null;\n+      end if;\n \n       --  Constrained array case\n \n@@ -2898,8 +2991,7 @@ package body Sem_Ch3 is\n       Discr           : Entity_Id;\n       Discr_Con_Elist : Elist_Id;\n       Discr_Con_El    : Elmt_Id;\n-\n-      Subt : Entity_Id;\n+      Subt            : Entity_Id;\n \n    begin\n       --  Set the designated type so it is available in case this is\n@@ -6247,7 +6339,7 @@ package body Sem_Ch3 is\n         and then not In_Instance\n         and then not In_Inlined_Body\n       then\n-         --  Ada0Y (AI-287): Relax the strictness of the front-end in case of\n+         --  Ada 0Y (AI-287): Relax the strictness of the front-end in case of\n          --  limited aggregates and extension aggregates.\n \n          if Extensions_Allowed\n@@ -6293,10 +6385,16 @@ package body Sem_Ch3 is\n                Set_Is_Immediately_Visible (D);\n                Set_Homonym (D, Prev);\n \n-               --  This restriction gets applied to the full type here; it\n-               --  has already been applied earlier to the partial view\n+               --  Ada 0Y (AI-230): Access discriminant allowed in non-limited\n+               --  record types\n+\n+               if not Extensions_Allowed then\n \n-               Check_Access_Discriminant_Requires_Limited (Parent (D), N);\n+                  --  This restriction gets applied to the full type here; it\n+                  --  has already been applied earlier to the partial view\n+\n+                  Check_Access_Discriminant_Requires_Limited (Parent (D), N);\n+               end if;\n \n                Next_Discriminant (D);\n             end loop;\n@@ -11223,8 +11321,14 @@ package body Sem_Ch3 is\n          end if;\n \n          if Is_Access_Type (Discr_Type) then\n-            Check_Access_Discriminant_Requires_Limited\n-              (Discr, Discriminant_Type (Discr));\n+\n+            --  Ada 0Y (AI-230): Access discriminant allowed in non-limited\n+            --  record types\n+\n+            if not Extensions_Allowed then\n+               Check_Access_Discriminant_Requires_Limited\n+                 (Discr, Discriminant_Type (Discr));\n+            end if;\n \n             if Ada_83 and then Comes_From_Source (Discr) then\n                Error_Msg_N"}, {"sha": "dad301aa2d5cbc463757802a2b86b2bfb8282de2", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,6 +38,7 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Output;   use Output;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n@@ -336,9 +337,10 @@ package body Sem_Ch4 is\n            and then Comes_From_Source (N)\n            and then not In_Instance_Body\n          then\n-            --  Ada0Y (AI-287): Do not post an error if the expression corres-\n-            --  ponds to a limited aggregate. Limited aggregates are checked in\n-            --  sem_aggr in a per-component manner (cf. Get_Value subprogram).\n+            --  Ada 0Y (AI-287): Do not post an error if the expression\n+            --  corresponds to a limited aggregate. Limited aggregates\n+            --  are checked in sem_aggr in a per-component manner\n+            --  (compare with handling of Get_Value subprogram).\n \n             if Extensions_Allowed\n               and then Nkind (Expression (E)) = N_Aggregate\n@@ -475,6 +477,7 @@ package body Sem_Ch4 is\n       end if;\n \n       if Has_Task (Designated_Type (Acc_Type)) then\n+         Check_Restriction (No_Tasking, N);\n          Check_Restriction (Max_Tasks, N);\n          Check_Restriction (No_Task_Allocators, N);\n       end if;\n@@ -3449,7 +3452,7 @@ package body Sem_Ch4 is\n          Actual := First_Actual (N);\n \n          while Present (Actual) loop\n-            --  Ada0Y (AI-50217): Post an error in case of premature usage of\n+            --  Ada 0Y (AI-50217): Post an error in case of premature usage of\n             --  an entity from the limited view.\n \n             if not Analyzed (Etype (Actual))\n@@ -3869,10 +3872,18 @@ package body Sem_Ch4 is\n             return;\n          end if;\n \n+         --  Ada 0Y (AI-230): Keep restriction imposed by Ada 83 and 95: Do not\n+         --  allow anonymous access types in equality operators.\n+\n+         if not Extensions_Allowed\n+           and then Ekind (T1) = E_Anonymous_Access_Type\n+         then\n+            return;\n+         end if;\n+\n          if T1 /= Standard_Void_Type\n            and then not Is_Limited_Type (T1)\n            and then not Is_Limited_Composite (T1)\n-           and then Ekind (T1) /= E_Anonymous_Access_Type\n            and then Has_Compatible_Type (R, T1)\n          then\n             if Found"}, {"sha": "0a44a2da090f22b08562488dfaff93aac5f82d80", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -41,6 +41,7 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Output;   use Output;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n@@ -648,7 +649,6 @@ package body Sem_Ch8 is\n       Id  : constant Entity_Id := Defining_Identifier (N);\n       Dec : Node_Id;\n       Nam : constant Node_Id   := Name (N);\n-      S   : constant Entity_Id := Subtype_Mark (N);\n       T   : Entity_Id;\n       T2  : Entity_Id;\n \n@@ -678,10 +678,23 @@ package body Sem_Ch8 is\n             Set_Etype (Nam, T);\n          end if;\n \n-      else\n-         Find_Type (S);\n-         T := Entity (S);\n+      elsif Present (Subtype_Mark (N)) then\n+         Find_Type (Subtype_Mark (N));\n+         T := Entity (Subtype_Mark (N));\n+         Analyze_And_Resolve (Nam, T);\n+\n+      --  Ada 0Y (AI-230): Access renaming\n+\n+      elsif Present (Access_Definition (N)) then\n+         Find_Type (Subtype_Mark (Access_Definition (N)));\n+         T := Access_Definition\n+                (Related_Nod => N,\n+                 N           => Access_Definition (N));\n          Analyze_And_Resolve (Nam, T);\n+\n+      else\n+         pragma Assert (False);\n+         null;\n       end if;\n \n       --  An object renaming requires an exact match of the type;\n@@ -792,7 +805,7 @@ package body Sem_Ch8 is\n          Error_Msg_N\n            (\"expect package name in renaming\", Name (N));\n \n-      --  Ada0Y (AI-50217): Limited withed packages can not be renamed\n+      --  Ada 0Y (AI-50217): Limited withed packages can not be renamed\n \n       elsif Ekind (Old_P) = E_Package\n         and then From_With_Type (Old_P)\n@@ -3392,7 +3405,7 @@ package body Sem_Ch8 is\n          Set_Chars (Selector, Chars (Id));\n       end if;\n \n-      --  Ada0Y (AI-50217): Check usage of entities in limited withed units\n+      --  Ada 0Y (AI-50217): Check usage of entities in limited withed units\n \n       if Ekind (P_Name) = E_Package\n         and then From_With_Type (P_Name)\n@@ -5299,7 +5312,7 @@ package body Sem_Ch8 is\n \n       Set_In_Use (P);\n \n-      --  Ada0Y (AI-50217): Check restriction.\n+      --  Ada 0Y (AI-50217): Check restriction.\n \n       if From_With_Type (P) then\n          Error_Msg_N (\"limited withed package cannot appear in use clause\", N);"}, {"sha": "5dba0ae3f85af156cb9a969658760030b901d591", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -36,6 +36,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch3;  use Sem_Ch3;\n@@ -60,8 +61,8 @@ package body Sem_Ch9 is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Check_Max_Entries (Def : Node_Id; R : Restriction_Parameter_Id);\n-   --  Given either a protected definition or a task definition in Def, check\n+   procedure Check_Max_Entries (D : Node_Id; R : All_Parameter_Restrictions);\n+   --  Given either a protected definition or a task definition in D, check\n    --  the corresponding restriction parameter identifier R, and if it is set,\n    --  count the entries (checking the static requirement), and compare with\n    --  the given maximum.\n@@ -1071,7 +1072,7 @@ package body Sem_Ch9 is\n       --  with interrupt handlers. Note that we need to analyze the protected\n       --  definition to set Has_Entries and such.\n \n-      if (Abort_Allowed or else Restrictions (No_Entry_Queue) = False\n+      if (Abort_Allowed or else Restriction_Active (No_Entry_Queue) = False\n            or else Number_Entries (T) > 1)\n         and then\n           (Has_Entries (T)\n@@ -1123,7 +1124,7 @@ package body Sem_Ch9 is\n       Outer_Ent  : Entity_Id;\n \n    begin\n-      Check_Restriction (No_Requeue, N);\n+      Check_Restriction (No_Requeue_Statements, N);\n       Check_Unreachable_Code (N);\n       Tasking_Used := True;\n \n@@ -1327,7 +1328,6 @@ package body Sem_Ch9 is\n \n    begin\n       Check_Restriction (No_Select_Statements, N);\n-      Check_Restriction (Max_Select_Alternatives, N);\n       Tasking_Used := True;\n \n       Alt := First (Alts);\n@@ -1410,7 +1410,7 @@ package body Sem_Ch9 is\n          Next (Alt);\n       end loop;\n \n-      Check_Restriction (Max_Select_Alternatives, Alt_Count, N);\n+      Check_Restriction (Max_Select_Alternatives, N, Alt_Count);\n       Check_Potentially_Blocking_Operation (N);\n \n       if Terminate_Present and Delay_Present then\n@@ -1539,7 +1539,6 @@ package body Sem_Ch9 is\n       --  expanded twice, with disastrous result.\n \n       Analyze_Task_Type (N);\n-\n    end Analyze_Single_Task;\n \n    -----------------------\n@@ -1696,8 +1695,8 @@ package body Sem_Ch9 is\n       Def_Id : constant Entity_Id := Defining_Identifier (N);\n \n    begin\n-      Tasking_Used := True;\n       Check_Restriction (No_Tasking, N);\n+      Tasking_Used := True;\n       T := Find_Type_Name (N);\n       Generate_Definition (T);\n \n@@ -1813,7 +1812,7 @@ package body Sem_Ch9 is\n    -- Check_Max_Entries --\n    -----------------------\n \n-   procedure Check_Max_Entries (Def : Node_Id; R : Restriction_Parameter_Id) is\n+   procedure Check_Max_Entries (D : Node_Id; R : All_Parameter_Restrictions) is\n       Ecount : Uint;\n \n       procedure Count (L : List_Id);\n@@ -1861,11 +1860,21 @@ package body Sem_Ch9 is\n                         end if;\n                      end;\n \n-                  --  If entry family with non-static bounds, give error msg\n+                  --  Entry family with non-static bounds\n+\n+                  else\n+                     --  If restriction is set, then this is an error\n \n-                  elsif Restriction_Parameters (R) /= No_Uint then\n-                     Error_Msg_N\n-                       (\"static subtype required by Restriction pragma\", DSD);\n+                     if Restrictions.Set (R) then\n+                        Error_Msg_N\n+                          (\"static subtype required by Restriction pragma\",\n+                           DSD);\n+\n+                     --  Otherwise we record an unknown count restriction\n+\n+                     else\n+                        Check_Restriction (R, D);\n+                     end if;\n                   end if;\n                end;\n             end if;\n@@ -1878,11 +1887,11 @@ package body Sem_Ch9 is\n \n    begin\n       Ecount := Uint_0;\n-      Count (Visible_Declarations (Def));\n-      Count (Private_Declarations (Def));\n+      Count (Visible_Declarations (D));\n+      Count (Private_Declarations (D));\n \n       if Ecount > 0 then\n-         Check_Restriction (R, Ecount, Def);\n+         Check_Restriction (R, D, Ecount);\n       end if;\n    end Check_Max_Entries;\n "}, {"sha": "13cf050faec6226d5fb857856f36f44eb9de2df2", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -42,6 +42,7 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Output;   use Output;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch7;  use Sem_Ch7;\n@@ -1489,7 +1490,7 @@ package body Sem_Elab is\n \n          if (Nkind (Original_Node (N)) = N_Accept_Statement\n               or else Nkind (Original_Node (N)) = N_Selective_Accept)\n-           and then Restrictions (No_Entry_Calls_In_Elaboration_Code)\n+           and then Restriction_Active (No_Entry_Calls_In_Elaboration_Code)\n          then\n             return Abandon;\n \n@@ -1929,7 +1930,8 @@ package body Sem_Elab is\n          elsif Dynamic_Elaboration_Checks then\n             if not Elaboration_Checks_Suppressed (Ent)\n               and then not Cunit_SC\n-              and then not Restrictions (No_Entry_Calls_In_Elaboration_Code)\n+              and then\n+                not Restriction_Active (No_Entry_Calls_In_Elaboration_Code)\n             then\n                --  Runtime elaboration check required. generate check of the\n                --  elaboration Boolean for the unit containing the entity."}, {"sha": "b09df0b25e6282595e21c2879dac5e05b300f186", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 174, "deletions": 174, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -50,6 +50,7 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Output;   use Output;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch3;  use Sem_Ch3;\n@@ -522,7 +523,10 @@ package body Sem_Prag is\n       --  is set to the default from the subprogram name.\n \n       procedure Process_Interrupt_Or_Attach_Handler;\n-      --  Attach the pragmas to the rep item chain.\n+      --  Common processing for Interrupt and Attach_Handler pragmas\n+\n+      procedure Process_Restrictions_Or_Restriction_Warnings;\n+      --  Common processing for Restrictions and Restriction_Warnings pragmas\n \n       procedure Process_Suppress_Unsuppress (Suppress_Case : Boolean);\n       --  Common processing for Suppress and Unsuppress. The boolean parameter\n@@ -2802,9 +2806,10 @@ package body Sem_Prag is\n          --  for packages, exceptions, and record components.\n \n          elsif C = Convention_Java\n-           and then (Ekind (Def_Id) = E_Package\n-                     or else Ekind (Def_Id) = E_Exception\n-                     or else Nkind (Parent (Def_Id)) = N_Component_Declaration)\n+           and then\n+             (Ekind (Def_Id) = E_Package\n+                or else Ekind (Def_Id) = E_Exception\n+                or else Nkind (Parent (Def_Id)) = N_Component_Declaration)\n          then\n             Set_Imported (Def_Id);\n             Set_Is_Public (Def_Id);\n@@ -2834,11 +2839,12 @@ package body Sem_Prag is\n       --------------------\n \n       procedure Process_Inline (Active : Boolean) is\n-         Assoc   : Node_Id;\n-         Decl    : Node_Id;\n-         Subp_Id : Node_Id;\n-         Subp    : Entity_Id;\n-         Applies : Boolean;\n+         Assoc     : Node_Id;\n+         Decl      : Node_Id;\n+         Subp_Id   : Node_Id;\n+         Subp      : Entity_Id;\n+         Applies   : Boolean;\n+         Effective : Boolean := False;\n \n          procedure Make_Inline (Subp : Entity_Id);\n          --  Subp is the defining unit name of the subprogram\n@@ -2995,6 +3001,7 @@ package body Sem_Prag is\n                Set_Has_Pragma_Inline (Subp);\n                Set_Next_Rep_Item (N, First_Rep_Item (Subp));\n                Set_First_Rep_Item (Subp, N);\n+               Effective := True;\n             end if;\n          end Set_Inline_Flags;\n \n@@ -3035,6 +3042,12 @@ package body Sem_Prag is\n             if not Applies then\n                Error_Pragma_Arg\n                  (\"inappropriate argument for pragma%\", Assoc);\n+\n+            elsif not Effective\n+              and then Warn_On_Redundant_Constructs\n+            then\n+               Error_Msg_NE (\"pragma inline on& is redundant?\",\n+                 N, Entity (Subp_Id));\n             end if;\n \n             Next (Assoc);\n@@ -3210,13 +3223,136 @@ package body Sem_Prag is\n \n          if Ekind (Proc_Scope) = E_Protected_Type then\n             if Prag_Id = Pragma_Interrupt_Handler\n-              or Prag_Id = Pragma_Attach_Handler\n+                 or else\n+               Prag_Id = Pragma_Attach_Handler\n             then\n                Record_Rep_Item (Proc_Scope, N);\n             end if;\n          end if;\n       end Process_Interrupt_Or_Attach_Handler;\n \n+      --------------------------------------------------\n+      -- Process_Restrictions_Or_Restriction_Warnings --\n+      --------------------------------------------------\n+\n+      procedure Process_Restrictions_Or_Restriction_Warnings is\n+         Arg   : Node_Id;\n+         R_Id  : Restriction_Id;\n+         Id    : Name_Id;\n+         Expr  : Node_Id;\n+         Val   : Uint;\n+\n+         procedure Set_Warning (R : All_Restrictions);\n+         --  If this is a Restriction_Warnings pragma, set warning flag\n+\n+         procedure Set_Warning (R : All_Restrictions) is\n+         begin\n+            if Prag_Id = Pragma_Restriction_Warnings then\n+               Restriction_Warnings (R) := True;\n+            end if;\n+         end Set_Warning;\n+\n+      --  Start of processing for Process_Restrictions_Or_Restriction_Warnings\n+\n+      begin\n+         Check_Ada_83_Warning;\n+         Check_At_Least_N_Arguments (1);\n+         Check_Valid_Configuration_Pragma;\n+\n+         Arg := Arg1;\n+         while Present (Arg) loop\n+            Id := Chars (Arg);\n+            Expr := Expression (Arg);\n+\n+            --  Case of no restriction identifier\n+\n+            if Id = No_Name then\n+               if Nkind (Expr) /= N_Identifier then\n+                  Error_Pragma_Arg\n+                    (\"invalid form for restriction\", Arg);\n+\n+               else\n+                  --  No_Requeue is a synonym for No_Requeue_Statements\n+\n+                  if Chars (Expr) = Name_No_Requeue then\n+                     Check_Restriction\n+                       (No_Implementation_Restrictions, Arg);\n+                     Set_Restriction (No_Requeue_Statements, N);\n+                     Set_Warning (No_Requeue_Statements);\n+\n+                  --  Normal processing for all other cases\n+\n+                  else\n+                     R_Id := Get_Restriction_Id (Chars (Expr));\n+\n+                     if R_Id not in All_Boolean_Restrictions then\n+                        Error_Pragma_Arg\n+                          (\"invalid restriction identifier\", Arg);\n+\n+                     --  Restriction is active\n+\n+                     else\n+                        if Implementation_Restriction (R_Id) then\n+                           Check_Restriction\n+                             (No_Implementation_Restrictions, Arg);\n+                        end if;\n+\n+                        Set_Restriction (R_Id, N);\n+                        Set_Warning (R_Id);\n+\n+                        --  A very special case that must be processed here:\n+                        --  pragma Restrictions (No_Exceptions) turns off\n+                        --  all run-time checking. This is a bit dubious in\n+                        --  terms of the formal language definition, but it\n+                        --  is what is intended by RM H.4(12).\n+\n+                        if R_Id = No_Exceptions then\n+                           Scope_Suppress := (others => True);\n+                        end if;\n+                     end if;\n+                  end if;\n+               end if;\n+\n+               --  Case of restriction identifier present\n+\n+            else\n+               R_Id := Get_Restriction_Id (Id);\n+               Analyze_And_Resolve (Expr, Any_Integer);\n+\n+               if R_Id not in All_Parameter_Restrictions then\n+                  Error_Pragma_Arg\n+                    (\"invalid restriction parameter identifier\", Arg);\n+\n+               elsif not Is_OK_Static_Expression (Expr) then\n+                  Flag_Non_Static_Expr\n+                    (\"value must be static expression!\", Expr);\n+                  raise Pragma_Exit;\n+\n+               elsif not Is_Integer_Type (Etype (Expr))\n+                 or else Expr_Value (Expr) < 0\n+               then\n+                  Error_Pragma_Arg\n+                    (\"value must be non-negative integer\", Arg);\n+\n+                  --  Restriction pragma is active\n+\n+               else\n+                  Val := Expr_Value (Expr);\n+\n+                  if not UI_Is_In_Int_Range (Val) then\n+                     Error_Pragma_Arg\n+                       (\"pragma ignored, value too large?\", Arg);\n+                  else\n+                     Set_Restriction (R_Id, N, Integer (UI_To_Int (Val)));\n+                     Set_Warning (R_Id);\n+                  end if;\n+               end if;\n+            end if;\n+\n+            Next (Arg);\n+         end loop;\n+      end Process_Restrictions_Or_Restriction_Warnings;\n+\n       ---------------------------------\n       -- Process_Suppress_Unsuppress --\n       ---------------------------------\n@@ -6319,7 +6455,7 @@ package body Sem_Prag is\n             Check_Valid_Configuration_Pragma;\n             Check_Restriction (No_Initialize_Scalars, N);\n \n-            if not Restrictions (No_Initialize_Scalars) then\n+            if not Restriction_Active (No_Initialize_Scalars) then\n                Init_Or_Norm_Scalars := True;\n                Initialize_Scalars := True;\n             end if;\n@@ -7389,9 +7525,10 @@ package body Sem_Prag is\n                end if;\n             end;\n \n-            Restrictions (No_Finalization)       := True;\n-            Restrictions (No_Exception_Handlers) := True;\n-            Restriction_Parameters (Max_Tasks)   := Uint_0;\n+            Set_Restriction (No_Finalization, N);\n+            Set_Restriction (No_Exception_Handlers, N);\n+            Set_Restriction (Max_Tasks, N, 0);\n+            Set_Restriction (No_Tasking, N);\n \n          -----------------------\n          -- Normalize_Scalars --\n@@ -8082,9 +8219,10 @@ package body Sem_Prag is\n          --  pragma Pure_Function ([Entity =>] function_LOCAL_NAME);\n \n          when Pragma_Pure_Function => Pure_Function : declare\n-            E_Id   : Node_Id;\n-            E      : Entity_Id;\n-            Def_Id : Entity_Id;\n+            E_Id      : Node_Id;\n+            E         : Entity_Id;\n+            Def_Id    : Entity_Id;\n+            Effective : Boolean := False;\n \n          begin\n             GNAT_Pragma;\n@@ -8114,11 +8252,22 @@ package body Sem_Prag is\n                   end if;\n \n                   Set_Is_Pure (Def_Id);\n-                  Set_Has_Pragma_Pure_Function (Def_Id);\n+\n+                  if not Has_Pragma_Pure_Function (Def_Id) then\n+                     Set_Has_Pragma_Pure_Function (Def_Id);\n+                     Effective := True;\n+                  end if;\n \n                   E := Homonym (E);\n                   exit when No (E) or else Scope (E) /= Current_Scope;\n                end loop;\n+\n+               if not Effective\n+                 and then Warn_On_Redundant_Constructs\n+               then\n+                  Error_Msg_NE (\"pragma Pure_Function on& is redundant?\",\n+                    N, Entity (E_Id));\n+               end if;\n             end if;\n          end Pure_Function;\n \n@@ -8263,170 +8412,21 @@ package body Sem_Prag is\n          --    restriction_IDENTIFIER\n          --  | restriction_parameter_IDENTIFIER => EXPRESSION\n \n-         when Pragma_Restrictions => Restrictions_Pragma : declare\n-            Arg   : Node_Id;\n-            R_Id  : Restriction_Id;\n-            RP_Id : Restriction_Parameter_Id;\n-            Id    : Name_Id;\n-            Expr  : Node_Id;\n-            Val   : Uint;\n-\n-         begin\n-            Check_Ada_83_Warning;\n-            Check_At_Least_N_Arguments (1);\n-            Check_Valid_Configuration_Pragma;\n-\n-            Arg := Arg1;\n-            while Present (Arg) loop\n-               Id := Chars (Arg);\n-               Expr := Expression (Arg);\n-\n-               --  Case of no restriction identifier\n-\n-               if Id = No_Name then\n-                  if Nkind (Expr) /= N_Identifier then\n-                     Error_Pragma_Arg\n-                       (\"invalid form for restriction\", Arg);\n-\n-                  else\n-                     R_Id := Get_Restriction_Id (Chars (Expr));\n-\n-                     if R_Id = Not_A_Restriction_Id then\n-                        Error_Pragma_Arg\n-                          (\"invalid restriction identifier\", Arg);\n-\n-                     --  Restriction is active\n-\n-                     else\n-                        if Implementation_Restriction (R_Id) then\n-                           Check_Restriction\n-                             (No_Implementation_Restrictions, Arg);\n-                        end if;\n-\n-                        Restrictions (R_Id) := True;\n-\n-                        --  Set location, but preserve location of system\n-                        --  restriction for nice error msg with run time name\n-\n-                        if Restrictions_Loc (R_Id) /= System_Location then\n-                           Restrictions_Loc (R_Id) := Sloc (N);\n-                        end if;\n-\n-                        --  Record the restriction if we are in the main unit,\n-                        --  or in the extended main unit. The reason that we\n-                        --  test separately for Main_Unit is that gnat.adc is\n-                        --  processed with Current_Sem_Unit = Main_Unit, but\n-                        --  nodes in gnat.adc do not appear to be the extended\n-                        --  main source unit (they probably should do ???)\n-\n-                        if Current_Sem_Unit = Main_Unit\n-                          or else In_Extended_Main_Source_Unit (N)\n-                        then\n-                           Main_Restrictions (R_Id) := True;\n-                        end if;\n-\n-                        --  A very special case that must be processed here:\n-                        --  pragma Restrictions (No_Exceptions) turns off all\n-                        --  run-time checking. This is a bit dubious in terms\n-                        --  of the formal language definition, but it is what\n-                        --  is intended by the wording of RM H.4(12).\n-\n-                        if R_Id = No_Exceptions then\n-                           Scope_Suppress := (others => True);\n-                        end if;\n-                     end if;\n-                  end if;\n-\n-               --  Case of restriction identifier present\n-\n-               else\n-                  RP_Id := Get_Restriction_Parameter_Id (Id);\n-                  Analyze_And_Resolve (Expr, Any_Integer);\n-\n-                  if RP_Id = Not_A_Restriction_Parameter_Id then\n-                     Error_Pragma_Arg\n-                       (\"invalid restriction parameter identifier\", Arg);\n-\n-                  elsif not Is_OK_Static_Expression (Expr) then\n-                     Flag_Non_Static_Expr\n-                       (\"value must be static expression!\", Expr);\n-                     raise Pragma_Exit;\n-\n-                  elsif not Is_Integer_Type (Etype (Expr))\n-                    or else Expr_Value (Expr) < 0\n-                  then\n-                     Error_Pragma_Arg\n-                       (\"value must be non-negative integer\", Arg);\n-\n-                  --  Restriction pragma is active\n-\n-                  else\n-                     Val := Expr_Value (Expr);\n-\n-                     --  Record pragma if most restrictive so far\n-\n-                     if Restriction_Parameters (RP_Id) = No_Uint\n-                       or else Val < Restriction_Parameters (RP_Id)\n-                     then\n-                        Restriction_Parameters (RP_Id) := Val;\n-                        Restriction_Parameters_Loc (RP_Id) := Sloc (N);\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               Next (Arg);\n-            end loop;\n-         end Restrictions_Pragma;\n+         when Pragma_Restrictions =>\n+            Process_Restrictions_Or_Restriction_Warnings;\n \n          --------------------------\n          -- Restriction_Warnings --\n          --------------------------\n \n          --  pragma Restriction_Warnings (RESTRICTION {, RESTRICTION});\n \n-         --  RESTRICTION ::= restriction_IDENTIFIER\n-\n-         when Pragma_Restriction_Warnings => Restriction_Warn : declare\n-            Arg   : Node_Id;\n-            R_Id  : Restriction_Id;\n-            Expr  : Node_Id;\n-\n-         begin\n-            GNAT_Pragma;\n-            Check_At_Least_N_Arguments (1);\n-            Check_Valid_Configuration_Pragma;\n-            Check_No_Identifiers;\n-\n-            Arg := Arg1;\n-            while Present (Arg) loop\n-               Expr := Expression (Arg);\n-\n-               if Nkind (Expr) /= N_Identifier then\n-                  Error_Pragma_Arg\n-                    (\"invalid form for restriction\", Arg);\n-\n-               else\n-                  R_Id := Get_Restriction_Id (Chars (Expr));\n-\n-                  if R_Id = Not_A_Restriction_Id then\n-                     Error_Pragma_Arg\n-                       (\"invalid restriction identifier\", Arg);\n-\n-                  --  Restriction is active\n-\n-                  else\n-                     if Implementation_Restriction (R_Id) then\n-                        Check_Restriction\n-                          (No_Implementation_Restrictions, Arg);\n-                     end if;\n-\n-                     Restriction_Warnings (R_Id) := True;\n-                  end if;\n-               end if;\n+         --  RESTRICTION ::=\n+         --    restriction_IDENTIFIER\n+         --  | restriction_parameter_IDENTIFIER => EXPRESSION\n \n-               Next (Arg);\n-            end loop;\n-         end Restriction_Warn;\n+         when Pragma_Restriction_Warnings =>\n+            Process_Restrictions_Or_Restriction_Warnings;\n \n          ----------------\n          -- Reviewable --"}, {"sha": "aeca86fb6f139cba7d0c195987071206c701ca23", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -44,6 +44,7 @@ with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Output;   use Output;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Aggr; use Sem_Aggr;\n@@ -3659,7 +3660,7 @@ package body Sem_Res is\n       Scop := Current_Scope;\n \n       if Nam = Scop\n-        and then not Restrictions (No_Recursion)\n+        and then not Restriction_Active (No_Recursion)\n         and then Check_Infinite_Recursion (N)\n       then\n          --  Here we detected and flagged an infinite recursion, so we do"}, {"sha": "0ac96860a28235cfe0a2df852bfd914792a41fe7", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -824,7 +824,7 @@ package body Sem_Type is\n       then\n          return True;\n \n-      --  Ada0Y (AI-50217): Additional branches to make the shadow entity\n+      --  Ada 0Y (AI-50217): Additional branches to make the shadow entity\n       --  compatible with its real entity.\n \n       elsif From_With_Type (T1) then\n@@ -1470,6 +1470,23 @@ package body Sem_Type is\n       elsif T = Universal_Fixed then\n          return Etype (R);\n \n+      --  Ada 0Y (AI-230): Support the following operators:\n+\n+      --    function \"=\"  (L, R : universal_access) return Boolean;\n+      --    function \"/=\" (L, R : universal_access) return Boolean;\n+\n+      elsif Extensions_Allowed\n+        and then Ekind (Etype (L)) = E_Anonymous_Access_Type\n+        and then Is_Access_Type (Etype (R))\n+      then\n+         return Etype (L);\n+\n+      elsif Extensions_Allowed\n+        and then Ekind (Etype (R)) = E_Anonymous_Access_Type\n+        and then Is_Access_Type (Etype (L))\n+      then\n+         return Etype (R);\n+\n       else\n          return Specific_Type (T, Etype (R));\n       end if;"}, {"sha": "37fcc4d85f1472c489f2ccc4ae270559a4cd0599", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -117,6 +117,15 @@ package body Sinfo is\n       return Node2 (N);\n    end Accept_Statement;\n \n+   function Access_Definition\n+     (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Component_Definition\n+        or else NT (N).Nkind = N_Object_Renaming_Declaration);\n+      return Node3 (N);\n+   end Access_Definition;\n+\n    function Access_Types_To_Process\n       (N : Node_Id) return Elist_Id is\n    begin\n@@ -2565,6 +2574,15 @@ package body Sinfo is\n       Set_Node2_With_Parent (N, Val);\n    end Set_Accept_Statement;\n \n+   procedure Set_Access_Definition\n+     (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Component_Definition\n+        or else NT (N).Nkind = N_Object_Renaming_Declaration);\n+      Set_Node3_With_Parent (N, Val);\n+   end Set_Access_Definition;\n+\n    procedure Set_Access_Types_To_Process\n       (N : Node_Id; Val : Elist_Id) is\n    begin"}, {"sha": "90929a3d34317a1391ae881503329d693223ca19", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -2316,18 +2316,23 @@ package Sinfo is\n       -- 3.6  Component Definition --\n       -------------------------------\n \n-      --  COMPONENT_DEFINITION ::= [aliased] SUBTYPE_INDICATION\n+      --  COMPONENT_DEFINITION ::=\n+      --    [aliased] SUBTYPE_INDICATION | ACCESS_DEFINITION\n \n       --  Note: although the syntax does not permit a component definition to\n       --  be an anonymous array (and the parser will diagnose such an attempt\n       --  with an appropriate message), it is possible for anonymous arrays\n       --  to appear as component definitions. The semantics and back end handle\n       --  this case properly, and the expander in fact generates such cases.\n+      --  Access_Definition is an optional field that gives support to Ada 0Y\n+      --  (AI-230). The parser generates nodes that have either the\n+      --  Subtype_Indication field or else the Access_Definition field.\n \n       --  N_Component_Definition\n-      --  Sloc points to ALIASED or to first token of subtype mark\n+      --  Sloc points to ALIASED, ACCESS or to first token of subtype mark\n       --  Aliased_Present (Flag4)\n-      --  Subtype_Indication (Node5)\n+      --  Subtype_Indication (Node5) (set to Empty if not present)\n+      --  Access_Definition (Node3) (set to Empty if not present)\n \n       -----------------------------\n       -- 3.6.1  Index Constraint --\n@@ -3021,7 +3026,7 @@ package Sinfo is\n       --  list of selector names in the record aggregate case, or a list of\n       --  discrete choices in the array aggregate case or an N_Others_Choice\n       --  node (which appears as a singleton list). Box_Present gives support\n-      --  to Ada0Y (AI-287).\n+      --  to Ada 0Y (AI-287).\n \n       ------------------------------------\n       --  4.3.1  Commponent Choice List --\n@@ -4284,11 +4289,17 @@ package Sinfo is\n \n       --  OBJECT_RENAMING_DECLARATION ::=\n       --    DEFINING_IDENTIFIER : SUBTYPE_MARK renames object_NAME;\n+      --  | DEFINING_IDENTIFIER : ACCESS_DEFINITION renames object_NAME;\n+\n+      --  Note: Access_Definition is an optional field that gives support to\n+      --  Ada 0Y (AI-230). The parser generates nodes that have either the\n+      --  Subtype_Indication field or else the Access_Definition field.\n \n       --  N_Object_Renaming_Declaration\n       --  Sloc points to first identifier\n       --  Defining_Identifier (Node1)\n-      --  Subtype_Mark (Node4)\n+      --  Subtype_Mark (Node4) (set to Empty if not present)\n+      --  Access_Definition (Node3) (set to Empty if not present)\n       --  Name (Node2)\n       --  Corresponding_Generic_Association (Node5-Sem)\n \n@@ -5099,7 +5110,7 @@ package Sinfo is\n       --  No_Entities_Ref_In_Spec (Flag8-Sem)\n \n       --  Note: Limited_Present and Limited_View_Installed give support to\n-      --        Ada0Y (AI-50217).\n+      --        Ada 0Y (AI-50217).\n \n       ----------------------\n       -- With_Type clause --\n@@ -6877,6 +6888,9 @@ package Sinfo is\n    function Accept_Statement\n      (N : Node_Id) return Node_Id;    -- Node2\n \n+   function Access_Definition\n+     (N : Node_Id) return Node_Id;    -- Node3\n+\n    function Access_Types_To_Process\n      (N : Node_Id) return Elist_Id;   -- Elist2\n \n@@ -7660,6 +7674,9 @@ package Sinfo is\n    procedure Set_Accept_Statement\n      (N : Node_Id; Val : Node_Id);            -- Node2\n \n+   procedure Set_Access_Definition\n+     (N : Node_Id; Val : Node_Id);            -- Node3\n+\n    procedure Set_Access_Types_To_Process\n      (N : Node_Id; Val : Elist_Id);           -- Elist2\n \n@@ -8446,6 +8463,7 @@ package Sinfo is\n    pragma Inline (Abstract_Present);\n    pragma Inline (Accept_Handler_Records);\n    pragma Inline (Accept_Statement);\n+   pragma Inline (Access_Definition);\n    pragma Inline (Access_Types_To_Process);\n    pragma Inline (Actions);\n    pragma Inline (Activation_Chain_Entity);\n@@ -8704,6 +8722,7 @@ package Sinfo is\n    pragma Inline (Set_Abstract_Present);\n    pragma Inline (Set_Accept_Handler_Records);\n    pragma Inline (Set_Accept_Statement);\n+   pragma Inline (Set_Access_Definition);\n    pragma Inline (Set_Access_Types_To_Process);\n    pragma Inline (Set_Actions);\n    pragma Inline (Set_Activation_Chain_Entity);"}, {"sha": "769da8e79d70e7a889e8d175622d85e1dd0e1327", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -334,6 +334,7 @@ package body Snames is\n      \"on#\" &\n      \"parameter_types#\" &\n      \"reference#\" &\n+     \"no_requeue#\" &\n      \"restricted#\" &\n      \"result_mechanism#\" &\n      \"result_type#\" &"}, {"sha": "164a29d38b153c1595a48180ca9ab0d2e968ebe5", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 333, "deletions": 332, "changes": 665, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -487,7 +487,7 @@ package Snames is\n    Name_DLL                            : constant Name_Id := N + 241;\n    Name_Win32                          : constant Name_Id := N + 242;\n \n-   --  Other special names used in processing pragma arguments\n+   --  Other special names used in processing pragmas\n \n    Name_As_Is                          : constant Name_Id := N + 243;\n    Name_Body_File_Name                 : constant Name_Id := N + 244;\n@@ -523,33 +523,34 @@ package Snames is\n    Name_On                             : constant Name_Id := N + 274;\n    Name_Parameter_Types                : constant Name_Id := N + 275;\n    Name_Reference                      : constant Name_Id := N + 276;\n-   Name_Restricted                     : constant Name_Id := N + 277;\n-   Name_Result_Mechanism               : constant Name_Id := N + 278;\n-   Name_Result_Type                    : constant Name_Id := N + 279;\n-   Name_Runtime                        : constant Name_Id := N + 280;\n-   Name_SB                             : constant Name_Id := N + 281;\n-   Name_Secondary_Stack_Size           : constant Name_Id := N + 282;\n-   Name_Section                        : constant Name_Id := N + 283;\n-   Name_Semaphore                      : constant Name_Id := N + 284;\n-   Name_Spec_File_Name                 : constant Name_Id := N + 285;\n-   Name_Static                         : constant Name_Id := N + 286;\n-   Name_Stack_Size                     : constant Name_Id := N + 287;\n-   Name_Subunit_File_Name              : constant Name_Id := N + 288;\n-   Name_Task_Stack_Size_Default        : constant Name_Id := N + 289;\n-   Name_Task_Type                      : constant Name_Id := N + 290;\n-   Name_Time_Slicing_Enabled           : constant Name_Id := N + 291;\n-   Name_Top_Guard                      : constant Name_Id := N + 292;\n-   Name_UBA                            : constant Name_Id := N + 293;\n-   Name_UBS                            : constant Name_Id := N + 294;\n-   Name_UBSB                           : constant Name_Id := N + 295;\n-   Name_Unit_Name                      : constant Name_Id := N + 296;\n-   Name_Unknown                        : constant Name_Id := N + 297;\n-   Name_Unrestricted                   : constant Name_Id := N + 298;\n-   Name_Uppercase                      : constant Name_Id := N + 299;\n-   Name_User                           : constant Name_Id := N + 300;\n-   Name_VAX_Float                      : constant Name_Id := N + 301;\n-   Name_VMS                            : constant Name_Id := N + 302;\n-   Name_Working_Storage                : constant Name_Id := N + 303;\n+   Name_No_Requeue                     : constant Name_Id := N + 277;\n+   Name_Restricted                     : constant Name_Id := N + 278;\n+   Name_Result_Mechanism               : constant Name_Id := N + 279;\n+   Name_Result_Type                    : constant Name_Id := N + 280;\n+   Name_Runtime                        : constant Name_Id := N + 281;\n+   Name_SB                             : constant Name_Id := N + 282;\n+   Name_Secondary_Stack_Size           : constant Name_Id := N + 283;\n+   Name_Section                        : constant Name_Id := N + 284;\n+   Name_Semaphore                      : constant Name_Id := N + 285;\n+   Name_Spec_File_Name                 : constant Name_Id := N + 286;\n+   Name_Static                         : constant Name_Id := N + 287;\n+   Name_Stack_Size                     : constant Name_Id := N + 288;\n+   Name_Subunit_File_Name              : constant Name_Id := N + 289;\n+   Name_Task_Stack_Size_Default        : constant Name_Id := N + 290;\n+   Name_Task_Type                      : constant Name_Id := N + 291;\n+   Name_Time_Slicing_Enabled           : constant Name_Id := N + 292;\n+   Name_Top_Guard                      : constant Name_Id := N + 293;\n+   Name_UBA                            : constant Name_Id := N + 294;\n+   Name_UBS                            : constant Name_Id := N + 295;\n+   Name_UBSB                           : constant Name_Id := N + 296;\n+   Name_Unit_Name                      : constant Name_Id := N + 297;\n+   Name_Unknown                        : constant Name_Id := N + 298;\n+   Name_Unrestricted                   : constant Name_Id := N + 299;\n+   Name_Uppercase                      : constant Name_Id := N + 300;\n+   Name_User                           : constant Name_Id := N + 301;\n+   Name_VAX_Float                      : constant Name_Id := N + 302;\n+   Name_VMS                            : constant Name_Id := N + 303;\n+   Name_Working_Storage                : constant Name_Id := N + 304;\n \n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These\n@@ -563,374 +564,374 @@ package Snames is\n    --  The entries marked VMS are recognized only in OpenVMS implementations\n    --  of GNAT, and are treated as illegal in all other contexts.\n \n-   First_Attribute_Name                : constant Name_Id := N + 304;\n-   Name_Abort_Signal                   : constant Name_Id := N + 304;  -- GNAT\n-   Name_Access                         : constant Name_Id := N + 305;\n-   Name_Address                        : constant Name_Id := N + 306;\n-   Name_Address_Size                   : constant Name_Id := N + 307;  -- GNAT\n-   Name_Aft                            : constant Name_Id := N + 308;\n-   Name_Alignment                      : constant Name_Id := N + 309;\n-   Name_Asm_Input                      : constant Name_Id := N + 310;  -- GNAT\n-   Name_Asm_Output                     : constant Name_Id := N + 311;  -- GNAT\n-   Name_AST_Entry                      : constant Name_Id := N + 312;  -- VMS\n-   Name_Bit                            : constant Name_Id := N + 313;  -- GNAT\n-   Name_Bit_Order                      : constant Name_Id := N + 314;\n-   Name_Bit_Position                   : constant Name_Id := N + 315;  -- GNAT\n-   Name_Body_Version                   : constant Name_Id := N + 316;\n-   Name_Callable                       : constant Name_Id := N + 317;\n-   Name_Caller                         : constant Name_Id := N + 318;\n-   Name_Code_Address                   : constant Name_Id := N + 319;  -- GNAT\n-   Name_Component_Size                 : constant Name_Id := N + 320;\n-   Name_Compose                        : constant Name_Id := N + 321;\n-   Name_Constrained                    : constant Name_Id := N + 322;\n-   Name_Count                          : constant Name_Id := N + 323;\n-   Name_Default_Bit_Order              : constant Name_Id := N + 324; -- GNAT\n-   Name_Definite                       : constant Name_Id := N + 325;\n-   Name_Delta                          : constant Name_Id := N + 326;\n-   Name_Denorm                         : constant Name_Id := N + 327;\n-   Name_Digits                         : constant Name_Id := N + 328;\n-   Name_Elaborated                     : constant Name_Id := N + 329; -- GNAT\n-   Name_Emax                           : constant Name_Id := N + 330; -- Ada 83\n-   Name_Enum_Rep                       : constant Name_Id := N + 331; -- GNAT\n-   Name_Epsilon                        : constant Name_Id := N + 332; -- Ada 83\n-   Name_Exponent                       : constant Name_Id := N + 333;\n-   Name_External_Tag                   : constant Name_Id := N + 334;\n-   Name_First                          : constant Name_Id := N + 335;\n-   Name_First_Bit                      : constant Name_Id := N + 336;\n-   Name_Fixed_Value                    : constant Name_Id := N + 337; -- GNAT\n-   Name_Fore                           : constant Name_Id := N + 338;\n-   Name_Has_Discriminants              : constant Name_Id := N + 339; -- GNAT\n-   Name_Identity                       : constant Name_Id := N + 340;\n-   Name_Img                            : constant Name_Id := N + 341; -- GNAT\n-   Name_Integer_Value                  : constant Name_Id := N + 342; -- GNAT\n-   Name_Large                          : constant Name_Id := N + 343; -- Ada 83\n-   Name_Last                           : constant Name_Id := N + 344;\n-   Name_Last_Bit                       : constant Name_Id := N + 345;\n-   Name_Leading_Part                   : constant Name_Id := N + 346;\n-   Name_Length                         : constant Name_Id := N + 347;\n-   Name_Machine_Emax                   : constant Name_Id := N + 348;\n-   Name_Machine_Emin                   : constant Name_Id := N + 349;\n-   Name_Machine_Mantissa               : constant Name_Id := N + 350;\n-   Name_Machine_Overflows              : constant Name_Id := N + 351;\n-   Name_Machine_Radix                  : constant Name_Id := N + 352;\n-   Name_Machine_Rounds                 : constant Name_Id := N + 353;\n-   Name_Machine_Size                   : constant Name_Id := N + 354; -- GNAT\n-   Name_Mantissa                       : constant Name_Id := N + 355; -- Ada 83\n-   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 356;\n-   Name_Maximum_Alignment              : constant Name_Id := N + 357; -- GNAT\n-   Name_Mechanism_Code                 : constant Name_Id := N + 358; -- GNAT\n-   Name_Model_Emin                     : constant Name_Id := N + 359;\n-   Name_Model_Epsilon                  : constant Name_Id := N + 360;\n-   Name_Model_Mantissa                 : constant Name_Id := N + 361;\n-   Name_Model_Small                    : constant Name_Id := N + 362;\n-   Name_Modulus                        : constant Name_Id := N + 363;\n-   Name_Null_Parameter                 : constant Name_Id := N + 364; -- GNAT\n-   Name_Object_Size                    : constant Name_Id := N + 365; -- GNAT\n-   Name_Partition_ID                   : constant Name_Id := N + 366;\n-   Name_Passed_By_Reference            : constant Name_Id := N + 367; -- GNAT\n-   Name_Pool_Address                   : constant Name_Id := N + 368;\n-   Name_Pos                            : constant Name_Id := N + 369;\n-   Name_Position                       : constant Name_Id := N + 370;\n-   Name_Range                          : constant Name_Id := N + 371;\n-   Name_Range_Length                   : constant Name_Id := N + 372; -- GNAT\n-   Name_Round                          : constant Name_Id := N + 373;\n-   Name_Safe_Emax                      : constant Name_Id := N + 374; -- Ada 83\n-   Name_Safe_First                     : constant Name_Id := N + 375;\n-   Name_Safe_Large                     : constant Name_Id := N + 376; -- Ada 83\n-   Name_Safe_Last                      : constant Name_Id := N + 377;\n-   Name_Safe_Small                     : constant Name_Id := N + 378; -- Ada 83\n-   Name_Scale                          : constant Name_Id := N + 379;\n-   Name_Scaling                        : constant Name_Id := N + 380;\n-   Name_Signed_Zeros                   : constant Name_Id := N + 381;\n-   Name_Size                           : constant Name_Id := N + 382;\n-   Name_Small                          : constant Name_Id := N + 383;\n-   Name_Storage_Size                   : constant Name_Id := N + 384;\n-   Name_Storage_Unit                   : constant Name_Id := N + 385; -- GNAT\n-   Name_Tag                            : constant Name_Id := N + 386;\n-   Name_Target_Name                    : constant Name_Id := N + 387; -- GNAT\n-   Name_Terminated                     : constant Name_Id := N + 388;\n-   Name_To_Address                     : constant Name_Id := N + 389; -- GNAT\n-   Name_Type_Class                     : constant Name_Id := N + 390; -- GNAT\n-   Name_UET_Address                    : constant Name_Id := N + 391; -- GNAT\n-   Name_Unbiased_Rounding              : constant Name_Id := N + 392;\n-   Name_Unchecked_Access               : constant Name_Id := N + 393;\n-   Name_Unconstrained_Array            : constant Name_Id := N + 394;\n-   Name_Universal_Literal_String       : constant Name_Id := N + 395; -- GNAT\n-   Name_Unrestricted_Access            : constant Name_Id := N + 396; -- GNAT\n-   Name_VADS_Size                      : constant Name_Id := N + 397; -- GNAT\n-   Name_Val                            : constant Name_Id := N + 398;\n-   Name_Valid                          : constant Name_Id := N + 399;\n-   Name_Value_Size                     : constant Name_Id := N + 400; -- GNAT\n-   Name_Version                        : constant Name_Id := N + 401;\n-   Name_Wchar_T_Size                   : constant Name_Id := N + 402; -- GNAT\n-   Name_Wide_Width                     : constant Name_Id := N + 403;\n-   Name_Width                          : constant Name_Id := N + 404;\n-   Name_Word_Size                      : constant Name_Id := N + 405; -- GNAT\n+   First_Attribute_Name                : constant Name_Id := N + 305;\n+   Name_Abort_Signal                   : constant Name_Id := N + 305;  -- GNAT\n+   Name_Access                         : constant Name_Id := N + 306;\n+   Name_Address                        : constant Name_Id := N + 307;\n+   Name_Address_Size                   : constant Name_Id := N + 308;  -- GNAT\n+   Name_Aft                            : constant Name_Id := N + 309;\n+   Name_Alignment                      : constant Name_Id := N + 310;\n+   Name_Asm_Input                      : constant Name_Id := N + 311;  -- GNAT\n+   Name_Asm_Output                     : constant Name_Id := N + 312;  -- GNAT\n+   Name_AST_Entry                      : constant Name_Id := N + 313;  -- VMS\n+   Name_Bit                            : constant Name_Id := N + 314;  -- GNAT\n+   Name_Bit_Order                      : constant Name_Id := N + 315;\n+   Name_Bit_Position                   : constant Name_Id := N + 316;  -- GNAT\n+   Name_Body_Version                   : constant Name_Id := N + 317;\n+   Name_Callable                       : constant Name_Id := N + 318;\n+   Name_Caller                         : constant Name_Id := N + 319;\n+   Name_Code_Address                   : constant Name_Id := N + 320;  -- GNAT\n+   Name_Component_Size                 : constant Name_Id := N + 321;\n+   Name_Compose                        : constant Name_Id := N + 322;\n+   Name_Constrained                    : constant Name_Id := N + 323;\n+   Name_Count                          : constant Name_Id := N + 324;\n+   Name_Default_Bit_Order              : constant Name_Id := N + 325; -- GNAT\n+   Name_Definite                       : constant Name_Id := N + 326;\n+   Name_Delta                          : constant Name_Id := N + 327;\n+   Name_Denorm                         : constant Name_Id := N + 328;\n+   Name_Digits                         : constant Name_Id := N + 329;\n+   Name_Elaborated                     : constant Name_Id := N + 330; -- GNAT\n+   Name_Emax                           : constant Name_Id := N + 331; -- Ada 83\n+   Name_Enum_Rep                       : constant Name_Id := N + 332; -- GNAT\n+   Name_Epsilon                        : constant Name_Id := N + 333; -- Ada 83\n+   Name_Exponent                       : constant Name_Id := N + 334;\n+   Name_External_Tag                   : constant Name_Id := N + 335;\n+   Name_First                          : constant Name_Id := N + 336;\n+   Name_First_Bit                      : constant Name_Id := N + 337;\n+   Name_Fixed_Value                    : constant Name_Id := N + 338; -- GNAT\n+   Name_Fore                           : constant Name_Id := N + 339;\n+   Name_Has_Discriminants              : constant Name_Id := N + 340; -- GNAT\n+   Name_Identity                       : constant Name_Id := N + 341;\n+   Name_Img                            : constant Name_Id := N + 342; -- GNAT\n+   Name_Integer_Value                  : constant Name_Id := N + 343; -- GNAT\n+   Name_Large                          : constant Name_Id := N + 344; -- Ada 83\n+   Name_Last                           : constant Name_Id := N + 345;\n+   Name_Last_Bit                       : constant Name_Id := N + 346;\n+   Name_Leading_Part                   : constant Name_Id := N + 347;\n+   Name_Length                         : constant Name_Id := N + 348;\n+   Name_Machine_Emax                   : constant Name_Id := N + 349;\n+   Name_Machine_Emin                   : constant Name_Id := N + 350;\n+   Name_Machine_Mantissa               : constant Name_Id := N + 351;\n+   Name_Machine_Overflows              : constant Name_Id := N + 352;\n+   Name_Machine_Radix                  : constant Name_Id := N + 353;\n+   Name_Machine_Rounds                 : constant Name_Id := N + 354;\n+   Name_Machine_Size                   : constant Name_Id := N + 355; -- GNAT\n+   Name_Mantissa                       : constant Name_Id := N + 356; -- Ada 83\n+   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 357;\n+   Name_Maximum_Alignment              : constant Name_Id := N + 358; -- GNAT\n+   Name_Mechanism_Code                 : constant Name_Id := N + 359; -- GNAT\n+   Name_Model_Emin                     : constant Name_Id := N + 360;\n+   Name_Model_Epsilon                  : constant Name_Id := N + 361;\n+   Name_Model_Mantissa                 : constant Name_Id := N + 362;\n+   Name_Model_Small                    : constant Name_Id := N + 363;\n+   Name_Modulus                        : constant Name_Id := N + 364;\n+   Name_Null_Parameter                 : constant Name_Id := N + 365; -- GNAT\n+   Name_Object_Size                    : constant Name_Id := N + 366; -- GNAT\n+   Name_Partition_ID                   : constant Name_Id := N + 367;\n+   Name_Passed_By_Reference            : constant Name_Id := N + 368; -- GNAT\n+   Name_Pool_Address                   : constant Name_Id := N + 369;\n+   Name_Pos                            : constant Name_Id := N + 370;\n+   Name_Position                       : constant Name_Id := N + 371;\n+   Name_Range                          : constant Name_Id := N + 372;\n+   Name_Range_Length                   : constant Name_Id := N + 373; -- GNAT\n+   Name_Round                          : constant Name_Id := N + 374;\n+   Name_Safe_Emax                      : constant Name_Id := N + 375; -- Ada 83\n+   Name_Safe_First                     : constant Name_Id := N + 376;\n+   Name_Safe_Large                     : constant Name_Id := N + 377; -- Ada 83\n+   Name_Safe_Last                      : constant Name_Id := N + 378;\n+   Name_Safe_Small                     : constant Name_Id := N + 379; -- Ada 83\n+   Name_Scale                          : constant Name_Id := N + 380;\n+   Name_Scaling                        : constant Name_Id := N + 381;\n+   Name_Signed_Zeros                   : constant Name_Id := N + 382;\n+   Name_Size                           : constant Name_Id := N + 383;\n+   Name_Small                          : constant Name_Id := N + 384;\n+   Name_Storage_Size                   : constant Name_Id := N + 385;\n+   Name_Storage_Unit                   : constant Name_Id := N + 386; -- GNAT\n+   Name_Tag                            : constant Name_Id := N + 387;\n+   Name_Target_Name                    : constant Name_Id := N + 388; -- GNAT\n+   Name_Terminated                     : constant Name_Id := N + 389;\n+   Name_To_Address                     : constant Name_Id := N + 390; -- GNAT\n+   Name_Type_Class                     : constant Name_Id := N + 391; -- GNAT\n+   Name_UET_Address                    : constant Name_Id := N + 392; -- GNAT\n+   Name_Unbiased_Rounding              : constant Name_Id := N + 393;\n+   Name_Unchecked_Access               : constant Name_Id := N + 394;\n+   Name_Unconstrained_Array            : constant Name_Id := N + 395;\n+   Name_Universal_Literal_String       : constant Name_Id := N + 396; -- GNAT\n+   Name_Unrestricted_Access            : constant Name_Id := N + 397; -- GNAT\n+   Name_VADS_Size                      : constant Name_Id := N + 398; -- GNAT\n+   Name_Val                            : constant Name_Id := N + 399;\n+   Name_Valid                          : constant Name_Id := N + 400;\n+   Name_Value_Size                     : constant Name_Id := N + 401; -- GNAT\n+   Name_Version                        : constant Name_Id := N + 402;\n+   Name_Wchar_T_Size                   : constant Name_Id := N + 403; -- GNAT\n+   Name_Wide_Width                     : constant Name_Id := N + 404;\n+   Name_Width                          : constant Name_Id := N + 405;\n+   Name_Word_Size                      : constant Name_Id := N + 406; -- GNAT\n \n    --  Attributes that designate attributes returning renamable functions,\n    --  i.e. functions that return other than a universal value.\n \n-   First_Renamable_Function_Attribute  : constant Name_Id := N + 406;\n-   Name_Adjacent                       : constant Name_Id := N + 406;\n-   Name_Ceiling                        : constant Name_Id := N + 407;\n-   Name_Copy_Sign                      : constant Name_Id := N + 408;\n-   Name_Floor                          : constant Name_Id := N + 409;\n-   Name_Fraction                       : constant Name_Id := N + 410;\n-   Name_Image                          : constant Name_Id := N + 411;\n-   Name_Input                          : constant Name_Id := N + 412;\n-   Name_Machine                        : constant Name_Id := N + 413;\n-   Name_Max                            : constant Name_Id := N + 414;\n-   Name_Min                            : constant Name_Id := N + 415;\n-   Name_Model                          : constant Name_Id := N + 416;\n-   Name_Pred                           : constant Name_Id := N + 417;\n-   Name_Remainder                      : constant Name_Id := N + 418;\n-   Name_Rounding                       : constant Name_Id := N + 419;\n-   Name_Succ                           : constant Name_Id := N + 420;\n-   Name_Truncation                     : constant Name_Id := N + 421;\n-   Name_Value                          : constant Name_Id := N + 422;\n-   Name_Wide_Image                     : constant Name_Id := N + 423;\n-   Name_Wide_Value                     : constant Name_Id := N + 424;\n-   Last_Renamable_Function_Attribute   : constant Name_Id := N + 424;\n+   First_Renamable_Function_Attribute  : constant Name_Id := N + 407;\n+   Name_Adjacent                       : constant Name_Id := N + 407;\n+   Name_Ceiling                        : constant Name_Id := N + 408;\n+   Name_Copy_Sign                      : constant Name_Id := N + 409;\n+   Name_Floor                          : constant Name_Id := N + 410;\n+   Name_Fraction                       : constant Name_Id := N + 411;\n+   Name_Image                          : constant Name_Id := N + 412;\n+   Name_Input                          : constant Name_Id := N + 413;\n+   Name_Machine                        : constant Name_Id := N + 414;\n+   Name_Max                            : constant Name_Id := N + 415;\n+   Name_Min                            : constant Name_Id := N + 416;\n+   Name_Model                          : constant Name_Id := N + 417;\n+   Name_Pred                           : constant Name_Id := N + 418;\n+   Name_Remainder                      : constant Name_Id := N + 419;\n+   Name_Rounding                       : constant Name_Id := N + 420;\n+   Name_Succ                           : constant Name_Id := N + 421;\n+   Name_Truncation                     : constant Name_Id := N + 422;\n+   Name_Value                          : constant Name_Id := N + 423;\n+   Name_Wide_Image                     : constant Name_Id := N + 424;\n+   Name_Wide_Value                     : constant Name_Id := N + 425;\n+   Last_Renamable_Function_Attribute   : constant Name_Id := N + 425;\n \n    --  Attributes that designate procedures\n \n-   First_Procedure_Attribute           : constant Name_Id := N + 425;\n-   Name_Output                         : constant Name_Id := N + 425;\n-   Name_Read                           : constant Name_Id := N + 426;\n-   Name_Write                          : constant Name_Id := N + 427;\n-   Last_Procedure_Attribute            : constant Name_Id := N + 427;\n+   First_Procedure_Attribute           : constant Name_Id := N + 426;\n+   Name_Output                         : constant Name_Id := N + 426;\n+   Name_Read                           : constant Name_Id := N + 427;\n+   Name_Write                          : constant Name_Id := N + 428;\n+   Last_Procedure_Attribute            : constant Name_Id := N + 428;\n \n    --  Remaining attributes are ones that return entities\n \n-   First_Entity_Attribute_Name         : constant Name_Id := N + 428;\n-   Name_Elab_Body                      : constant Name_Id := N + 428; -- GNAT\n-   Name_Elab_Spec                      : constant Name_Id := N + 429; -- GNAT\n-   Name_Storage_Pool                   : constant Name_Id := N + 430;\n+   First_Entity_Attribute_Name         : constant Name_Id := N + 429;\n+   Name_Elab_Body                      : constant Name_Id := N + 429; -- GNAT\n+   Name_Elab_Spec                      : constant Name_Id := N + 430; -- GNAT\n+   Name_Storage_Pool                   : constant Name_Id := N + 431;\n \n    --  These attributes are the ones that return types\n \n-   First_Type_Attribute_Name           : constant Name_Id := N + 431;\n-   Name_Base                           : constant Name_Id := N + 431;\n-   Name_Class                          : constant Name_Id := N + 432;\n-   Last_Type_Attribute_Name            : constant Name_Id := N + 432;\n-   Last_Entity_Attribute_Name          : constant Name_Id := N + 432;\n-   Last_Attribute_Name                 : constant Name_Id := N + 432;\n+   First_Type_Attribute_Name           : constant Name_Id := N + 432;\n+   Name_Base                           : constant Name_Id := N + 432;\n+   Name_Class                          : constant Name_Id := N + 433;\n+   Last_Type_Attribute_Name            : constant Name_Id := N + 433;\n+   Last_Entity_Attribute_Name          : constant Name_Id := N + 433;\n+   Last_Attribute_Name                 : constant Name_Id := N + 433;\n \n    --  Names of recognized locking policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. C for Ceiling_Locking). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Locking_Policy_Name           : constant Name_Id := N + 433;\n-   Name_Ceiling_Locking                : constant Name_Id := N + 433;\n-   Name_Inheritance_Locking            : constant Name_Id := N + 434;\n-   Last_Locking_Policy_Name            : constant Name_Id := N + 434;\n+   First_Locking_Policy_Name           : constant Name_Id := N + 434;\n+   Name_Ceiling_Locking                : constant Name_Id := N + 434;\n+   Name_Inheritance_Locking            : constant Name_Id := N + 435;\n+   Last_Locking_Policy_Name            : constant Name_Id := N + 435;\n \n    --  Names of recognized queuing policy identifiers.\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_Queuing). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Queuing_Policy_Name           : constant Name_Id := N + 435;\n-   Name_FIFO_Queuing                   : constant Name_Id := N + 435;\n-   Name_Priority_Queuing               : constant Name_Id := N + 436;\n-   Last_Queuing_Policy_Name            : constant Name_Id := N + 436;\n+   First_Queuing_Policy_Name           : constant Name_Id := N + 436;\n+   Name_FIFO_Queuing                   : constant Name_Id := N + 436;\n+   Name_Priority_Queuing               : constant Name_Id := N + 437;\n+   Last_Queuing_Policy_Name            : constant Name_Id := N + 437;\n \n    --  Names of recognized task dispatching policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_WIthinn_Priorities). If new policy names\n    --  are added, the first character must be distinct.\n \n-   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 437;\n-   Name_Fifo_Within_Priorities         : constant Name_Id := N + 437;\n-   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 437;\n+   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 438;\n+   Name_Fifo_Within_Priorities         : constant Name_Id := N + 438;\n+   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 438;\n \n    --  Names of recognized checks for pragma Suppress\n \n-   First_Check_Name                    : constant Name_Id := N + 438;\n-   Name_Access_Check                   : constant Name_Id := N + 438;\n-   Name_Accessibility_Check            : constant Name_Id := N + 439;\n-   Name_Discriminant_Check             : constant Name_Id := N + 440;\n-   Name_Division_Check                 : constant Name_Id := N + 441;\n-   Name_Elaboration_Check              : constant Name_Id := N + 442;\n-   Name_Index_Check                    : constant Name_Id := N + 443;\n-   Name_Length_Check                   : constant Name_Id := N + 444;\n-   Name_Overflow_Check                 : constant Name_Id := N + 445;\n-   Name_Range_Check                    : constant Name_Id := N + 446;\n-   Name_Storage_Check                  : constant Name_Id := N + 447;\n-   Name_Tag_Check                      : constant Name_Id := N + 448;\n-   Name_All_Checks                     : constant Name_Id := N + 449;\n-   Last_Check_Name                     : constant Name_Id := N + 449;\n+   First_Check_Name                    : constant Name_Id := N + 439;\n+   Name_Access_Check                   : constant Name_Id := N + 439;\n+   Name_Accessibility_Check            : constant Name_Id := N + 440;\n+   Name_Discriminant_Check             : constant Name_Id := N + 441;\n+   Name_Division_Check                 : constant Name_Id := N + 442;\n+   Name_Elaboration_Check              : constant Name_Id := N + 443;\n+   Name_Index_Check                    : constant Name_Id := N + 444;\n+   Name_Length_Check                   : constant Name_Id := N + 445;\n+   Name_Overflow_Check                 : constant Name_Id := N + 446;\n+   Name_Range_Check                    : constant Name_Id := N + 447;\n+   Name_Storage_Check                  : constant Name_Id := N + 448;\n+   Name_Tag_Check                      : constant Name_Id := N + 449;\n+   Name_All_Checks                     : constant Name_Id := N + 450;\n+   Last_Check_Name                     : constant Name_Id := N + 450;\n \n    --  Names corresponding to reserved keywords, excluding those already\n    --  declared in the attribute list (Access, Delta, Digits, Range).\n \n-   Name_Abort                          : constant Name_Id := N + 450;\n-   Name_Abs                            : constant Name_Id := N + 451;\n-   Name_Accept                         : constant Name_Id := N + 452;\n-   Name_And                            : constant Name_Id := N + 453;\n-   Name_All                            : constant Name_Id := N + 454;\n-   Name_Array                          : constant Name_Id := N + 455;\n-   Name_At                             : constant Name_Id := N + 456;\n-   Name_Begin                          : constant Name_Id := N + 457;\n-   Name_Body                           : constant Name_Id := N + 458;\n-   Name_Case                           : constant Name_Id := N + 459;\n-   Name_Constant                       : constant Name_Id := N + 460;\n-   Name_Declare                        : constant Name_Id := N + 461;\n-   Name_Delay                          : constant Name_Id := N + 462;\n-   Name_Do                             : constant Name_Id := N + 463;\n-   Name_Else                           : constant Name_Id := N + 464;\n-   Name_Elsif                          : constant Name_Id := N + 465;\n-   Name_End                            : constant Name_Id := N + 466;\n-   Name_Entry                          : constant Name_Id := N + 467;\n-   Name_Exception                      : constant Name_Id := N + 468;\n-   Name_Exit                           : constant Name_Id := N + 469;\n-   Name_For                            : constant Name_Id := N + 470;\n-   Name_Function                       : constant Name_Id := N + 471;\n-   Name_Generic                        : constant Name_Id := N + 472;\n-   Name_Goto                           : constant Name_Id := N + 473;\n-   Name_If                             : constant Name_Id := N + 474;\n-   Name_In                             : constant Name_Id := N + 475;\n-   Name_Is                             : constant Name_Id := N + 476;\n-   Name_Limited                        : constant Name_Id := N + 477;\n-   Name_Loop                           : constant Name_Id := N + 478;\n-   Name_Mod                            : constant Name_Id := N + 479;\n-   Name_New                            : constant Name_Id := N + 480;\n-   Name_Not                            : constant Name_Id := N + 481;\n-   Name_Null                           : constant Name_Id := N + 482;\n-   Name_Of                             : constant Name_Id := N + 483;\n-   Name_Or                             : constant Name_Id := N + 484;\n-   Name_Others                         : constant Name_Id := N + 485;\n-   Name_Out                            : constant Name_Id := N + 486;\n-   Name_Package                        : constant Name_Id := N + 487;\n-   Name_Pragma                         : constant Name_Id := N + 488;\n-   Name_Private                        : constant Name_Id := N + 489;\n-   Name_Procedure                      : constant Name_Id := N + 490;\n-   Name_Raise                          : constant Name_Id := N + 491;\n-   Name_Record                         : constant Name_Id := N + 492;\n-   Name_Rem                            : constant Name_Id := N + 493;\n-   Name_Renames                        : constant Name_Id := N + 494;\n-   Name_Return                         : constant Name_Id := N + 495;\n-   Name_Reverse                        : constant Name_Id := N + 496;\n-   Name_Select                         : constant Name_Id := N + 497;\n-   Name_Separate                       : constant Name_Id := N + 498;\n-   Name_Subtype                        : constant Name_Id := N + 499;\n-   Name_Task                           : constant Name_Id := N + 500;\n-   Name_Terminate                      : constant Name_Id := N + 501;\n-   Name_Then                           : constant Name_Id := N + 502;\n-   Name_Type                           : constant Name_Id := N + 503;\n-   Name_Use                            : constant Name_Id := N + 504;\n-   Name_When                           : constant Name_Id := N + 505;\n-   Name_While                          : constant Name_Id := N + 506;\n-   Name_With                           : constant Name_Id := N + 507;\n-   Name_Xor                            : constant Name_Id := N + 508;\n+   Name_Abort                          : constant Name_Id := N + 451;\n+   Name_Abs                            : constant Name_Id := N + 452;\n+   Name_Accept                         : constant Name_Id := N + 453;\n+   Name_And                            : constant Name_Id := N + 454;\n+   Name_All                            : constant Name_Id := N + 455;\n+   Name_Array                          : constant Name_Id := N + 456;\n+   Name_At                             : constant Name_Id := N + 457;\n+   Name_Begin                          : constant Name_Id := N + 458;\n+   Name_Body                           : constant Name_Id := N + 459;\n+   Name_Case                           : constant Name_Id := N + 460;\n+   Name_Constant                       : constant Name_Id := N + 461;\n+   Name_Declare                        : constant Name_Id := N + 462;\n+   Name_Delay                          : constant Name_Id := N + 463;\n+   Name_Do                             : constant Name_Id := N + 464;\n+   Name_Else                           : constant Name_Id := N + 465;\n+   Name_Elsif                          : constant Name_Id := N + 466;\n+   Name_End                            : constant Name_Id := N + 467;\n+   Name_Entry                          : constant Name_Id := N + 468;\n+   Name_Exception                      : constant Name_Id := N + 469;\n+   Name_Exit                           : constant Name_Id := N + 470;\n+   Name_For                            : constant Name_Id := N + 471;\n+   Name_Function                       : constant Name_Id := N + 472;\n+   Name_Generic                        : constant Name_Id := N + 473;\n+   Name_Goto                           : constant Name_Id := N + 474;\n+   Name_If                             : constant Name_Id := N + 475;\n+   Name_In                             : constant Name_Id := N + 476;\n+   Name_Is                             : constant Name_Id := N + 477;\n+   Name_Limited                        : constant Name_Id := N + 478;\n+   Name_Loop                           : constant Name_Id := N + 479;\n+   Name_Mod                            : constant Name_Id := N + 480;\n+   Name_New                            : constant Name_Id := N + 481;\n+   Name_Not                            : constant Name_Id := N + 482;\n+   Name_Null                           : constant Name_Id := N + 483;\n+   Name_Of                             : constant Name_Id := N + 484;\n+   Name_Or                             : constant Name_Id := N + 485;\n+   Name_Others                         : constant Name_Id := N + 486;\n+   Name_Out                            : constant Name_Id := N + 487;\n+   Name_Package                        : constant Name_Id := N + 488;\n+   Name_Pragma                         : constant Name_Id := N + 489;\n+   Name_Private                        : constant Name_Id := N + 490;\n+   Name_Procedure                      : constant Name_Id := N + 491;\n+   Name_Raise                          : constant Name_Id := N + 492;\n+   Name_Record                         : constant Name_Id := N + 493;\n+   Name_Rem                            : constant Name_Id := N + 494;\n+   Name_Renames                        : constant Name_Id := N + 495;\n+   Name_Return                         : constant Name_Id := N + 496;\n+   Name_Reverse                        : constant Name_Id := N + 497;\n+   Name_Select                         : constant Name_Id := N + 498;\n+   Name_Separate                       : constant Name_Id := N + 499;\n+   Name_Subtype                        : constant Name_Id := N + 500;\n+   Name_Task                           : constant Name_Id := N + 501;\n+   Name_Terminate                      : constant Name_Id := N + 502;\n+   Name_Then                           : constant Name_Id := N + 503;\n+   Name_Type                           : constant Name_Id := N + 504;\n+   Name_Use                            : constant Name_Id := N + 505;\n+   Name_When                           : constant Name_Id := N + 506;\n+   Name_While                          : constant Name_Id := N + 507;\n+   Name_With                           : constant Name_Id := N + 508;\n+   Name_Xor                            : constant Name_Id := N + 509;\n \n    --  Names of intrinsic subprograms\n \n    --  Note: Asm is missing from this list, since Asm is a legitimate\n    --  convention name. So is To_Adress, which is a GNAT attribute.\n \n-   First_Intrinsic_Name                : constant Name_Id := N + 509;\n-   Name_Divide                         : constant Name_Id := N + 509;\n-   Name_Enclosing_Entity               : constant Name_Id := N + 510;\n-   Name_Exception_Information          : constant Name_Id := N + 511;\n-   Name_Exception_Message              : constant Name_Id := N + 512;\n-   Name_Exception_Name                 : constant Name_Id := N + 513;\n-   Name_File                           : constant Name_Id := N + 514;\n-   Name_Import_Address                 : constant Name_Id := N + 515;\n-   Name_Import_Largest_Value           : constant Name_Id := N + 516;\n-   Name_Import_Value                   : constant Name_Id := N + 517;\n-   Name_Is_Negative                    : constant Name_Id := N + 518;\n-   Name_Line                           : constant Name_Id := N + 519;\n-   Name_Rotate_Left                    : constant Name_Id := N + 520;\n-   Name_Rotate_Right                   : constant Name_Id := N + 521;\n-   Name_Shift_Left                     : constant Name_Id := N + 522;\n-   Name_Shift_Right                    : constant Name_Id := N + 523;\n-   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 524;\n-   Name_Source_Location                : constant Name_Id := N + 525;\n-   Name_Unchecked_Conversion           : constant Name_Id := N + 526;\n-   Name_Unchecked_Deallocation         : constant Name_Id := N + 527;\n-   Name_To_Pointer                     : constant Name_Id := N + 528;\n-   Last_Intrinsic_Name                 : constant Name_Id := N + 528;\n+   First_Intrinsic_Name                : constant Name_Id := N + 510;\n+   Name_Divide                         : constant Name_Id := N + 510;\n+   Name_Enclosing_Entity               : constant Name_Id := N + 511;\n+   Name_Exception_Information          : constant Name_Id := N + 512;\n+   Name_Exception_Message              : constant Name_Id := N + 513;\n+   Name_Exception_Name                 : constant Name_Id := N + 514;\n+   Name_File                           : constant Name_Id := N + 515;\n+   Name_Import_Address                 : constant Name_Id := N + 516;\n+   Name_Import_Largest_Value           : constant Name_Id := N + 517;\n+   Name_Import_Value                   : constant Name_Id := N + 518;\n+   Name_Is_Negative                    : constant Name_Id := N + 519;\n+   Name_Line                           : constant Name_Id := N + 520;\n+   Name_Rotate_Left                    : constant Name_Id := N + 521;\n+   Name_Rotate_Right                   : constant Name_Id := N + 522;\n+   Name_Shift_Left                     : constant Name_Id := N + 523;\n+   Name_Shift_Right                    : constant Name_Id := N + 524;\n+   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 525;\n+   Name_Source_Location                : constant Name_Id := N + 526;\n+   Name_Unchecked_Conversion           : constant Name_Id := N + 527;\n+   Name_Unchecked_Deallocation         : constant Name_Id := N + 528;\n+   Name_To_Pointer                     : constant Name_Id := N + 529;\n+   Last_Intrinsic_Name                 : constant Name_Id := N + 529;\n \n    --  Reserved words used only in Ada 95\n \n-   First_95_Reserved_Word              : constant Name_Id := N + 529;\n-   Name_Abstract                       : constant Name_Id := N + 529;\n-   Name_Aliased                        : constant Name_Id := N + 530;\n-   Name_Protected                      : constant Name_Id := N + 531;\n-   Name_Until                          : constant Name_Id := N + 532;\n-   Name_Requeue                        : constant Name_Id := N + 533;\n-   Name_Tagged                         : constant Name_Id := N + 534;\n-   Last_95_Reserved_Word               : constant Name_Id := N + 534;\n+   First_95_Reserved_Word              : constant Name_Id := N + 530;\n+   Name_Abstract                       : constant Name_Id := N + 530;\n+   Name_Aliased                        : constant Name_Id := N + 531;\n+   Name_Protected                      : constant Name_Id := N + 532;\n+   Name_Until                          : constant Name_Id := N + 533;\n+   Name_Requeue                        : constant Name_Id := N + 534;\n+   Name_Tagged                         : constant Name_Id := N + 535;\n+   Last_95_Reserved_Word               : constant Name_Id := N + 535;\n \n    subtype Ada_95_Reserved_Words is\n      Name_Id range First_95_Reserved_Word .. Last_95_Reserved_Word;\n \n    --  Miscellaneous names used in semantic checking\n \n-   Name_Raise_Exception                : constant Name_Id := N + 535;\n+   Name_Raise_Exception                : constant Name_Id := N + 536;\n \n    --  Additional reserved words in GNAT Project Files\n    --  Note that Name_External is already previously declared\n \n-   Name_Binder                         : constant Name_Id := N + 536;\n-   Name_Body_Suffix                    : constant Name_Id := N + 537;\n-   Name_Builder                        : constant Name_Id := N + 538;\n-   Name_Compiler                       : constant Name_Id := N + 539;\n-   Name_Cross_Reference                : constant Name_Id := N + 540;\n-   Name_Default_Switches               : constant Name_Id := N + 541;\n-   Name_Exec_Dir                       : constant Name_Id := N + 542;\n-   Name_Executable                     : constant Name_Id := N + 543;\n-   Name_Executable_Suffix              : constant Name_Id := N + 544;\n-   Name_Extends                        : constant Name_Id := N + 545;\n-   Name_Finder                         : constant Name_Id := N + 546;\n-   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 547;\n-   Name_Gnatls                         : constant Name_Id := N + 548;\n-   Name_Gnatstub                       : constant Name_Id := N + 549;\n-   Name_Implementation                 : constant Name_Id := N + 550;\n-   Name_Implementation_Exceptions      : constant Name_Id := N + 551;\n-   Name_Implementation_Suffix          : constant Name_Id := N + 552;\n-   Name_Languages                      : constant Name_Id := N + 553;\n-   Name_Library_Dir                    : constant Name_Id := N + 554;\n-   Name_Library_Auto_Init              : constant Name_Id := N + 555;\n-   Name_Library_GCC                    : constant Name_Id := N + 556;\n-   Name_Library_Interface              : constant Name_Id := N + 557;\n-   Name_Library_Kind                   : constant Name_Id := N + 558;\n-   Name_Library_Name                   : constant Name_Id := N + 559;\n-   Name_Library_Options                : constant Name_Id := N + 560;\n-   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 561;\n-   Name_Library_Src_Dir                : constant Name_Id := N + 562;\n-   Name_Library_Symbol_File            : constant Name_Id := N + 563;\n-   Name_Library_Symbol_Policy          : constant Name_Id := N + 564;\n-   Name_Library_Version                : constant Name_Id := N + 565;\n-   Name_Linker                         : constant Name_Id := N + 566;\n-   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 567;\n-   Name_Locally_Removed_Files          : constant Name_Id := N + 568;\n-   Name_Naming                         : constant Name_Id := N + 569;\n-   Name_Object_Dir                     : constant Name_Id := N + 570;\n-   Name_Pretty_Printer                 : constant Name_Id := N + 571;\n-   Name_Project                        : constant Name_Id := N + 572;\n-   Name_Separate_Suffix                : constant Name_Id := N + 573;\n-   Name_Source_Dirs                    : constant Name_Id := N + 574;\n-   Name_Source_Files                   : constant Name_Id := N + 575;\n-   Name_Source_List_File               : constant Name_Id := N + 576;\n-   Name_Spec                           : constant Name_Id := N + 577;\n-   Name_Spec_Suffix                    : constant Name_Id := N + 578;\n-   Name_Specification                  : constant Name_Id := N + 579;\n-   Name_Specification_Exceptions       : constant Name_Id := N + 580;\n-   Name_Specification_Suffix           : constant Name_Id := N + 581;\n-   Name_Switches                       : constant Name_Id := N + 582;\n+   Name_Binder                         : constant Name_Id := N + 537;\n+   Name_Body_Suffix                    : constant Name_Id := N + 538;\n+   Name_Builder                        : constant Name_Id := N + 539;\n+   Name_Compiler                       : constant Name_Id := N + 540;\n+   Name_Cross_Reference                : constant Name_Id := N + 541;\n+   Name_Default_Switches               : constant Name_Id := N + 542;\n+   Name_Exec_Dir                       : constant Name_Id := N + 543;\n+   Name_Executable                     : constant Name_Id := N + 544;\n+   Name_Executable_Suffix              : constant Name_Id := N + 545;\n+   Name_Extends                        : constant Name_Id := N + 546;\n+   Name_Finder                         : constant Name_Id := N + 547;\n+   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 548;\n+   Name_Gnatls                         : constant Name_Id := N + 549;\n+   Name_Gnatstub                       : constant Name_Id := N + 550;\n+   Name_Implementation                 : constant Name_Id := N + 551;\n+   Name_Implementation_Exceptions      : constant Name_Id := N + 552;\n+   Name_Implementation_Suffix          : constant Name_Id := N + 553;\n+   Name_Languages                      : constant Name_Id := N + 554;\n+   Name_Library_Dir                    : constant Name_Id := N + 555;\n+   Name_Library_Auto_Init              : constant Name_Id := N + 556;\n+   Name_Library_GCC                    : constant Name_Id := N + 557;\n+   Name_Library_Interface              : constant Name_Id := N + 558;\n+   Name_Library_Kind                   : constant Name_Id := N + 559;\n+   Name_Library_Name                   : constant Name_Id := N + 560;\n+   Name_Library_Options                : constant Name_Id := N + 561;\n+   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 562;\n+   Name_Library_Src_Dir                : constant Name_Id := N + 563;\n+   Name_Library_Symbol_File            : constant Name_Id := N + 564;\n+   Name_Library_Symbol_Policy          : constant Name_Id := N + 565;\n+   Name_Library_Version                : constant Name_Id := N + 566;\n+   Name_Linker                         : constant Name_Id := N + 567;\n+   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 568;\n+   Name_Locally_Removed_Files          : constant Name_Id := N + 569;\n+   Name_Naming                         : constant Name_Id := N + 570;\n+   Name_Object_Dir                     : constant Name_Id := N + 571;\n+   Name_Pretty_Printer                 : constant Name_Id := N + 572;\n+   Name_Project                        : constant Name_Id := N + 573;\n+   Name_Separate_Suffix                : constant Name_Id := N + 574;\n+   Name_Source_Dirs                    : constant Name_Id := N + 575;\n+   Name_Source_Files                   : constant Name_Id := N + 576;\n+   Name_Source_List_File               : constant Name_Id := N + 577;\n+   Name_Spec                           : constant Name_Id := N + 578;\n+   Name_Spec_Suffix                    : constant Name_Id := N + 579;\n+   Name_Specification                  : constant Name_Id := N + 580;\n+   Name_Specification_Exceptions       : constant Name_Id := N + 581;\n+   Name_Specification_Suffix           : constant Name_Id := N + 582;\n+   Name_Switches                       : constant Name_Id := N + 583;\n    --  Other miscellaneous names used in front end\n \n-   Name_Unaligned_Valid                : constant Name_Id := N + 583;\n+   Name_Unaligned_Valid                : constant Name_Id := N + 584;\n \n    --  Mark last defined name for consistency check in Snames body\n \n-   Last_Predefined_Name                : constant Name_Id := N + 583;\n+   Last_Predefined_Name                : constant Name_Id := N + 584;\n \n    subtype Any_Operator_Name is Name_Id range\n      First_Operator_Name .. Last_Operator_Name;"}, {"sha": "2b584bb27797a84bd7814f176b062130862d5aaf", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -929,7 +929,7 @@ package body Sprint is\n             Sprint_Bar_List (Choices (Node));\n             Write_Str (\" => \");\n \n-            --  Ada0Y (AI-287): Print the mbox if present\n+            --  Ada 0Y (AI-287): Print the mbox if present\n \n             if Box_Present (Node) then\n                Write_Str_With_Col_Check (\"<>\");\n@@ -952,11 +952,21 @@ package body Sprint is\n          when N_Component_Definition =>\n             Set_Debug_Sloc;\n \n-            if Aliased_Present (Node) then\n-               Write_Str_With_Col_Check (\"aliased \");\n-            end if;\n+            --  Ada 0Y (AI-230): Access definition components\n \n-            Sprint_Node (Subtype_Indication (Node));\n+            if Present (Access_Definition (Node)) then\n+               Sprint_Node (Access_Definition (Node));\n+\n+            elsif Present (Subtype_Indication (Node)) then\n+               if Aliased_Present (Node) then\n+                  Write_Str_With_Col_Check (\"aliased \");\n+               end if;\n+\n+               Sprint_Node (Subtype_Indication (Node));\n+            else\n+               pragma Assert (False);\n+               null;\n+            end if;\n \n          when N_Component_Declaration =>\n             if Write_Indent_Identifiers_Sloc (Node) then\n@@ -1693,7 +1703,20 @@ package body Sprint is\n             Set_Debug_Sloc;\n             Sprint_Node (Defining_Identifier (Node));\n             Write_Str (\" : \");\n-            Sprint_Node (Subtype_Mark (Node));\n+\n+            --  Ada 0Y (AI-230): Access renamings\n+\n+            if Present (Access_Definition (Node)) then\n+               Sprint_Node (Access_Definition (Node));\n+\n+            elsif Present (Subtype_Mark (Node)) then\n+               Sprint_Node (Subtype_Mark (Node));\n+\n+            else\n+               pragma Assert (False);\n+               null;\n+            end if;\n+\n             Write_Str_With_Col_Check (\" renames \");\n             Sprint_Node (Name (Node));\n             Write_Char (';');\n@@ -2349,6 +2372,7 @@ package body Sprint is\n             Write_Indent_Str_Sloc (\"task type \");\n             Write_Id (Defining_Identifier (Node));\n             Write_Discr_Specs (Node);\n+\n             if Present (Task_Definition (Node)) then\n                Write_Str (\" is\");\n                Sprint_Node (Task_Definition (Node));\n@@ -2493,7 +2517,7 @@ package body Sprint is\n             else\n                if First_Name (Node) or else not Dump_Original_Only then\n \n-                  --  Ada0Y (AI-50217): Print limited with_clauses\n+                  --  Ada 0Y (AI-50217): Print limited with_clauses\n \n                   if Limited_Present (Node) then\n                      Write_Indent_Str (\"limited with \");"}, {"sha": "ac2d6296938ca137d1316f0117509c8a56fbd92e", "filename": "gcc/ada/style.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fstyle.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Fstyle.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyle.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -193,7 +193,6 @@ package Style is\n \n    function RM_Column_Check return Boolean\n      renames Style_Inst.RM_Column_Check;\n-   pragma Inline (RM_Column_Check);\n    --  Determines whether style checking is active and the RM column check\n    --  mode is set requiring checking of RM format layout.\n "}, {"sha": "65842b425db3068e491c84db74832d9203461109", "filename": "gcc/ada/targparm.adb", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ftargparm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ftargparm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -29,6 +29,7 @@ with Namet;  use Namet;\n with Opt;    use Opt;\n with Osint;  use Osint;\n with Output; use Output;\n+with Uintp;  use Uintp;\n \n package body Targparm is\n    use ASCII;\n@@ -220,7 +221,7 @@ package body Targparm is\n          elsif System_Text (P .. P + 20) = \"pragma Restrictions (\" then\n             P := P + 21;\n \n-            Rloop : for K in Partition_Restrictions loop\n+            Rloop : for K in Partition_Boolean_Restrictions loop\n                declare\n                   Rname : constant String := Restriction_Id'Image (K);\n \n@@ -234,7 +235,7 @@ package body Targparm is\n                   end loop;\n \n                   if System_Text (P + Rname'Length) = ')' then\n-                     Restrictions_On_Target (K) := True;\n+                     Restrictions_On_Target.Set (K) := True;\n                      goto Line_Loop_Continue;\n                   end if;\n                end;\n@@ -243,10 +244,10 @@ package body Targparm is\n                null;\n             end loop Rloop;\n \n-            Ploop : for K in Restriction_Parameter_Id loop\n+            Ploop : for K in All_Parameter_Restrictions loop\n                declare\n                   Rname : constant String :=\n-                            Restriction_Parameter_Id'Image (K);\n+                            All_Parameter_Restrictions'Image (K);\n \n                begin\n                   for J in Rname'Range loop\n@@ -269,14 +270,23 @@ package body Targparm is\n                         elsif System_Text (P) = '_' then\n                            null;\n                         elsif System_Text (P) = ')' then\n-                           Restriction_Parameters_On_Target (K) := V;\n-                           goto  Line_Loop_Continue;\n+                           if UI_Is_In_Int_Range (V) then\n+                              Restrictions_On_Target.Value (K) :=\n+                                Integer (UI_To_Int (V));\n+                              Restrictions_On_Target.Set (K) := True;\n+                              goto Line_Loop_Continue;\n+                           else\n+                              exit Ploop;\n+                           end if;\n                         else\n-                           goto Ploop_Continue;\n+                           exit Ploop;\n                         end if;\n \n                         P := P + 1;\n                      end loop;\n+\n+                  else\n+                     exit Ploop;\n                   end if;\n                end;\n \n@@ -287,7 +297,7 @@ package body Targparm is\n             Set_Standard_Error;\n             Write_Line\n                (\"fatal error: system.ads is incorrectly formatted\");\n-            Write_Str (\"unrecognized restrictions pragma: \");\n+            Write_Str (\"unrecognized or incorrect restrictions pragma: \");\n \n             while System_Text (P) /= ')'\n                     and then"}, {"sha": "75251d2ff0d1c7fc81586a9985900d1be3e66271", "filename": "gcc/ada/targparm.ads", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ftargparm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ftargparm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.ads?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1999-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1999-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -68,7 +68,6 @@\n \n with Rident; use Rident;\n with Types;  use Types;\n-with Uintp;  use Uintp;\n \n package Targparm is\n \n@@ -107,19 +106,11 @@ package Targparm is\n \n    --  The only other pragma allowed is a pragma Restrictions that gives the\n    --  simple name of a restriction for which partition consistency is always\n-   --  required (see definition of Rident.Partition_Restrictions).\n-\n-   Restrictions_On_Target :\n-     array (Partition_Restrictions) of Boolean := (others => False);\n-   --  Element is set True if a pragma Restrictions for the corresponding\n-   --  identifier appears in system.ads. Note that only partition restriction\n-   --  identifiers are permitted as arguments for pragma Restrictions for\n-   --  pragmas appearing at the start of system.ads.\n-\n-   Restriction_Parameters_On_Target :\n-     array (Restriction_Parameter_Id) of Uint := (others => No_Uint);\n-   --  Element is set to specified value if a pragma Restrictions for the\n-   --  corresponding restriction parameter value is set.\n+   --  required (see definition of Rident.Restriction_Info).\n+\n+   Restrictions_On_Target : Restrictions_Info;\n+   --  Records restrictions specified by system.ads. Only the Set and Value\n+   --  members are modified. The Violated and Count fields are never modified.\n \n    -------------------\n    -- Run Time Name --"}, {"sha": "00131e7c06b39d865e95df85e7ec68c49e517c09", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,7 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;"}, {"sha": "dbc71a44e08a7fb9d4ac200523f596eef5443049", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 58, "deletions": 24, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=6e937c1c5c91aa000bbb549e2dcd8290fcc20a7d", "patch": "@@ -748,17 +748,21 @@ finish_record_type (tree record_type,\n     }\n \n   /* At this point, the position and size of each field is known.  It was\n-     either set before entry by a rep clause, or by laying out the type\n-     above.  We now make a pass through the fields (in reverse order for\n-     QUAL_UNION_TYPEs) to compute the Ada size; the GCC size and alignment\n-     (for rep'ed records that are not padding types); and the mode (for\n-     rep'ed records).  */\n+     either set before entry by a rep clause, or by laying out the type above.\n+\n+     We now run a pass over the fields (in reverse order for QUAL_UNION_TYPEs)\n+     to compute the Ada size; the GCC size and alignment (for rep'ed records\n+     that are not padding types); and the mode (for rep'ed records).  We also\n+     clear the DECL_BIT_FIELD indication for the cases we know have not been\n+     handled yet, and adjust DECL_NONADDRESSABLE_P accordingly.  */\n \n   if (code == QUAL_UNION_TYPE)\n     fieldlist = nreverse (fieldlist);\n \n   for (field = fieldlist; field; field = TREE_CHAIN (field))\n     {\n+      tree pos = bit_position (field);\n+\n       tree type = TREE_TYPE (field);\n       tree this_size = DECL_SIZE (field);\n       tree this_size_unit = DECL_SIZE_UNIT (field);\n@@ -780,6 +784,16 @@ finish_record_type (tree record_type,\n \t  && TYPE_ADA_SIZE (type) != 0)\n \tthis_ada_size = TYPE_ADA_SIZE (type);\n \n+      /* Clear DECL_BIT_FIELD for the cases layout_decl does not handle.  */\n+      if (DECL_BIT_FIELD (field) && !STRICT_ALIGNMENT\n+\t  && value_factor_p (pos, BITS_PER_UNIT)\n+\t  && operand_equal_p (this_size, TYPE_SIZE (type), 0))\n+\tDECL_BIT_FIELD (field) = 0;\n+\n+      /* If we still have DECL_BIT_FIELD set at this point, we know the field\n+\t is technically not addressable.  */\n+      DECL_NONADDRESSABLE_P (field) |= DECL_BIT_FIELD (field);\n+\n       if (has_rep && ! DECL_BIT_FIELD (field))\n \tTYPE_ALIGN (record_type)\n \t  = MAX (TYPE_ALIGN (record_type), DECL_ALIGN (field));\n@@ -812,9 +826,9 @@ finish_record_type (tree record_type,\n \t     QUAL_UNION_TYPE, we need to take into account the previous size in\n \t     the case of empty variants.  */\n \t  ada_size\n-\t    = merge_sizes (ada_size, bit_position (field), this_ada_size,\n+\t    = merge_sizes (ada_size, pos, this_ada_size,\n \t\t\t   TREE_CODE (type) == QUAL_UNION_TYPE, has_rep);\n-\t  size = merge_sizes (size, bit_position (field), this_size,\n+\t  size = merge_sizes (size, pos, this_size,\n \t\t\t      TREE_CODE (type) == QUAL_UNION_TYPE, has_rep);\n \t  size_unit\n \t    = merge_sizes (size_unit, byte_position (field), this_size_unit,\n@@ -1392,30 +1406,42 @@ create_field_decl (tree field_name,\n   if (packed && TYPE_MODE (field_type) == BLKmode)\n     DECL_ALIGN (field_decl) = BITS_PER_UNIT;\n \n-  /* If a size is specified, use it.  Otherwise, see if we have a size\n-     to use that may differ from the natural size of the object.  */\n+  /* If a size is specified, use it.  Otherwise, if the record type is packed\n+     compute a size to use, which may differ from the object's natural size.\n+     We always set a size in this case to trigger the checks for bitfield\n+     creation below, which is typically required when no position has been\n+     specified.  */\n   if (size != 0)\n     size = convert (bitsizetype, size);\n-  else if (packed)\n+  else if (packed == 1)\n     {\n-      if (packed == 1 && ! operand_equal_p (rm_size (field_type),\n-\t\t\t\t\t    TYPE_SIZE (field_type), 0))\n-\tsize = rm_size (field_type);\n+      size = rm_size (field_type);\n \n       /* For a constant size larger than MAX_FIXED_MODE_SIZE, round up to\n-\t byte.  */\n-      if (size != 0 && TREE_CODE (size) == INTEGER_CST\n-\t  && compare_tree_int (size, MAX_FIXED_MODE_SIZE) > 0)\n-\tsize = round_up (size, BITS_PER_UNIT);\n+         byte.  */\n+      if (TREE_CODE (size) == INTEGER_CST\n+          && compare_tree_int (size, MAX_FIXED_MODE_SIZE) > 0)\n+        size = round_up (size, BITS_PER_UNIT);\n     }\n \n   /* Make a bitfield if a size is specified for two reasons: first if the size\n      differs from the natural size.  Second, if the alignment is insufficient.\n-     There are a number of ways the latter can be true.  But never make a\n-     bitfield if the type of the field has a nonconstant size.  */\n+     There are a number of ways the latter can be true.\n \n+     We never make a bitfield if the type of the field has a nonconstant size,\n+     or if it is claimed to be addressable, because no such entity requiring\n+     bitfield operations should reach here.\n+\n+     We do *preventively* make a bitfield when there might be the need for it\n+     but we don't have all the necessary information to decide, as is the case\n+     of a field with no specified position in a packed record.\n+\n+     We also don't look at STRICT_ALIGNMENT here, and rely on later processing\n+     in layout_decl or finish_record_type to clear the bit_field indication if\n+     it is in fact not needed. */\n   if (size != 0 && TREE_CODE (size) == INTEGER_CST\n       && TREE_CODE (TYPE_SIZE (field_type)) == INTEGER_CST\n+      && ! addressable\n       && (! operand_equal_p (TYPE_SIZE (field_type), size, 0)\n \t  || (pos != 0\n \t      && ! value_zerop (size_binop (TRUNC_MOD_EXPR, pos,\n@@ -1479,10 +1505,15 @@ create_field_decl (tree field_name,\n   if (AGGREGATE_TYPE_P (field_type))\n     addressable = 1;\n \n-  /* Mark the decl as nonaddressable if it either is indicated so semantically\n-     or if it is a bit field.  */\n-  DECL_NONADDRESSABLE_P (field_decl)\n-    = ! addressable || DECL_BIT_FIELD (field_decl);\n+  /* Mark the decl as nonaddressable if it is indicated so semantically,\n+     meaning we won't ever attempt to take the address of the field.\n+\n+     It may also be \"technically\" nonaddressable, meaning that even if we\n+     attempt to take the field's address we will actually get the address of a\n+     copy. This is the case for true bitfields, but the DECL_BIT_FIELD value\n+     we have at this point is not accurate enough, so we don't account for\n+     this here and let finish_record_type decide.  */\n+  DECL_NONADDRESSABLE_P (field_decl) = ! addressable;\n \n   return field_decl;\n }\n@@ -1884,7 +1915,10 @@ end_subprog_body (void)\n   if (function_nesting_depth > 1)\n     ggc_push_context ();\n \n-  rest_of_compilation (current_function_decl);\n+  /* If we're only annotating types, don't actually compile this\n+     function.  */\n+  if (!type_annotate_only)\n+    rest_of_compilation (current_function_decl);\n \n   if (function_nesting_depth > 1)\n     ggc_pop_context ();"}]}