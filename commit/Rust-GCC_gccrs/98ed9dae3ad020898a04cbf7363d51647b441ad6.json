{"sha": "98ed9dae3ad020898a04cbf7363d51647b441ad6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThlZDlkYWUzYWQwMjA4OThhMDRjYmY3MzYzZDUxNjQ3YjQ0MWFkNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-06-08T11:49:23Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-06-08T11:49:23Z"}, "message": "re PR c++/19497 (Invalid declaration in template diagnosed too late)\n\ncp:\n\tPR c++/19497\n\t* cp-tree.def (USING_DECL): Update documentation.\n\t* cp-tree.h (DECL_DEPENDENT_P): New.\n\t(USING_DECL_DECLS, USING_DECL_SCOPE): New.\n\t* class.c (handle_using_decl): Move most of the processing to ...\n\t* name-lookup.c (do_class_using_decl): ... here.  Make stricter.\n\t(push_using_decl): Use USING_DECL_SCOPE.\n\t(cp_emit_debug_info_for_using): Make extern.\n\t* cxx-pretty-print.c (pp_cxx_statement) <USING_DECL case>: Adjust.\n\t* name-lookup.h (cp_emit_debug_info_for_using): Declare.\n\t* pt.c (tsubst_decl) <USING_DECL case>: Use do_class_using_decl\n\twhen tsubsting.\n\t(tsubst_expr): Use USING_DECL_SCOPE.\n\t* search.c (lookup_field_1): Use DECL_DEPENDENT_P.\n\t* semantics.c (finish_member_declaration): Likewise.\ntestsuite:\n\tPR c++/19497\n\t* g++.dg/inherit/using5.C: New.\n\t* g++.dg/inherit/using6.C: New.\n\nFrom-SVN: r100757", "tree": {"sha": "33d1230b127cd93152bb163e84c576691088bbac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33d1230b127cd93152bb163e84c576691088bbac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98ed9dae3ad020898a04cbf7363d51647b441ad6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ed9dae3ad020898a04cbf7363d51647b441ad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98ed9dae3ad020898a04cbf7363d51647b441ad6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ed9dae3ad020898a04cbf7363d51647b441ad6/comments", "author": null, "committer": null, "parents": [{"sha": "cb6d4a9fce89e5bea9476338870125bac9b83e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb6d4a9fce89e5bea9476338870125bac9b83e96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb6d4a9fce89e5bea9476338870125bac9b83e96"}], "stats": {"total": 246, "additions": 163, "deletions": 83}, "files": [{"sha": "f08a2c65803f0b2a66d4bb30fe16e16119fec8af", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -1,3 +1,21 @@\n+2005-06-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/19497\n+\t* cp-tree.def (USING_DECL): Update documentation.\n+\t* cp-tree.h (DECL_DEPENDENT_P): New.\n+\t(USING_DECL_DECLS, USING_DECL_SCOPE): New.\n+\t* class.c (handle_using_decl): Move most of the processing to ...\n+\t* name-lookup.c (do_class_using_decl): ... here.  Make stricter.\n+\t(push_using_decl): Use USING_DECL_SCOPE.\n+\t(cp_emit_debug_info_for_using): Make extern.\n+\t* cxx-pretty-print.c (pp_cxx_statement) <USING_DECL case>: Adjust.\n+\t* name-lookup.h (cp_emit_debug_info_for_using): Declare.\n+\t* pt.c (tsubst_decl) <USING_DECL case>: Use do_class_using_decl\n+\twhen tsubsting.\n+\t(tsubst_expr): Use USING_DECL_SCOPE.\n+\t* search.c (lookup_field_1): Use DECL_DEPENDENT_P.\n+\t* semantics.c (finish_member_declaration): Likewise.\n+\n 2005-06-08  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/19894"}, {"sha": "a790b561316505c18247bcbffc626be293902ef0", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 42, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -1119,53 +1119,17 @@ alter_access (tree t, tree fdecl, tree access)\n static void\n handle_using_decl (tree using_decl, tree t)\n {\n-  tree ctype = DECL_INITIAL (using_decl);\n+  tree decl = USING_DECL_DECLS (using_decl);\n   tree name = DECL_NAME (using_decl);\n   tree access\n     = TREE_PRIVATE (using_decl) ? access_private_node\n     : TREE_PROTECTED (using_decl) ? access_protected_node\n     : access_public_node;\n-  tree fdecl, binfo;\n   tree flist = NULL_TREE;\n   tree old_value;\n \n-  if (ctype == error_mark_node)\n-    return;\n-\n-  binfo = lookup_base (t, ctype, ba_any, NULL);\n-  if (! binfo)\n-    {\n-      location_t saved_loc = input_location;\n-\n-      input_location = DECL_SOURCE_LOCATION (using_decl);\n-      error_not_base_type (ctype, t);\n-      input_location = saved_loc;\n-      return;\n-    }\n-  \n-  if (constructor_name_p (name, ctype))\n-    {\n-      cp_error_at (\"%qD names constructor\", using_decl);\n-      return;\n-    }\n-  if (constructor_name_p (name, t))\n-    {\n-      cp_error_at (\"%qD invalid in %qT\", using_decl, t);\n-      return;\n-    }\n-\n-  fdecl = lookup_member (binfo, name, 0, false);\n+  gcc_assert (!processing_template_decl && decl);\n   \n-  if (!fdecl)\n-    {\n-      cp_error_at (\"no members matching %qD in %q#T\", using_decl, ctype);\n-      return;\n-    }\n-\n-  if (BASELINK_P (fdecl))\n-    /* Ignore base type this came from.  */\n-    fdecl = BASELINK_FUNCTIONS (fdecl);\n-\n   old_value = lookup_member (t, name, /*protect=*/0, /*want_type=*/false);\n   if (old_value)\n     {\n@@ -1177,9 +1141,11 @@ handle_using_decl (tree using_decl, tree t)\n       else\n \told_value = NULL_TREE;\n     }\n-\n-  if (is_overloaded_fn (fdecl))\n-    flist = fdecl;\n+  \n+  cp_emit_debug_info_for_using (decl, current_class_type);\n+  \n+  if (is_overloaded_fn (decl))\n+    flist = decl;\n \n   if (! old_value)\n     ;\n@@ -1211,7 +1177,7 @@ handle_using_decl (tree using_decl, tree t)\n \talter_access (t, OVL_CURRENT (flist), access);\n       }\n   else\n-    alter_access (t, fdecl, access);\n+    alter_access (t, decl, access);\n }\n \f\n /* Run through the base classes of T, updating CANT_HAVE_CONST_CTOR_P,"}, {"sha": "894b62db45c42ba06692525d141bbb091d458a1f", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -197,10 +197,10 @@ DEFTREECODE (BOUND_TEMPLATE_TEMPLATE_PARM, \"bound_template_template_parm\",\n    TYPE_NAME is an IDENTIFIER_NODE for `C', the member class template.  */\n DEFTREECODE (UNBOUND_CLASS_TEMPLATE, \"unbound_class_template\", tcc_type, 0)\n \n-/* A using declaration.  DECL_INITIAL contains the specified scope.  \n-   This is not an alias, but is later expanded into multiple aliases.\n-   The decl will have a NULL_TYPE iff the scope is a dependent scope,\n-   otherwise it will have a void type.  */\n+/* A using declaration.  USING_DECL_SCOPE contains the specified\n+   scope.  In a member using decl, unless DECL_DEPENDENT_P is true,\n+   USING_DECL_DECLS contains the _DECL or OVERLOAD so named.  This is\n+   not an alias, but is later expanded into multiple aliases.  */\n DEFTREECODE (USING_DECL, \"using_decl\", tcc_declaration, 0)\n \n /* A using directive. The operand is USING_STMT_NAMESPACE.  */     "}, {"sha": "bb234bb5e135baf93dd5de91a2ba0986779a9c03", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -93,6 +93,7 @@ struct diagnostic_context;\n       DECL_TEMPLATE_PARM_P (in PARM_DECL, CONST_DECL, TYPE_DECL, or TEMPLATE_DECL)\n       DECL_LOCAL_FUNCTION_P (in FUNCTION_DECL)\n       DECL_MUTABLE_P (in FIELD_DECL)\n+      DECL_DEPENDENT_P (in USING_DECL)\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n       DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n       DECL_MEMBER_TEMPLATE_P (in TEMPLATE_DECL)\n@@ -2039,6 +2040,15 @@ struct lang_decl GTY(())\n    directives  */\n #define TREE_INDIRECT_USING(NODE) (TREE_LIST_CHECK (NODE)->common.lang_flag_0)\n \n+/* Non zero if this is a using decl for a dependent scope. */\n+#define DECL_DEPENDENT_P(NODE) DECL_LANG_FLAG_0 (USING_DECL_CHECK (NODE))\n+\n+/* The scope named in a using decl.  */\n+#define USING_DECL_SCOPE(NODE) TREE_TYPE (USING_DECL_CHECK (NODE))\n+\n+/* The decls named by a using decl.  */\n+#define USING_DECL_DECLS(NODE) DECL_INITIAL (USING_DECL_CHECK (NODE))\n+\n /* In a VAR_DECL for a variable declared in a for statement,\n    this is the shadowed (local) variable.  */\n #define DECL_SHADOWED_FOR_VAR(NODE) DECL_RESULT_FLD(VAR_DECL_CHECK (NODE))"}, {"sha": "42435d026bcdc077951680aa51094ff038c1c4e0", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -1519,7 +1519,7 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n \n     case USING_DECL:\n       pp_cxx_identifier (pp, \"using\");\n-      pp_cxx_nested_name_specifier (pp, DECL_INITIAL (t));\n+      pp_cxx_nested_name_specifier (pp, USING_DECL_SCOPE (t));\n       pp_cxx_unqualified_id (pp, DECL_NAME (t));\n       break;\n "}, {"sha": "7a878f68ec48f4ea3d21390b55c3986c07fa37e0", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 65, "deletions": 21, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -51,7 +51,6 @@ static bool qualified_lookup_using_namespace (tree, tree,\n \t\t\t\t\t      struct scope_binding *, int);\n static tree lookup_type_current_level (tree);\n static tree push_using_directive (tree);\n-static void cp_emit_debug_info_for_using (tree, tree);\n \n /* The :: namespace.  */\n \n@@ -1779,13 +1778,13 @@ push_using_decl (tree scope, tree name)\n   gcc_assert (TREE_CODE (scope) == NAMESPACE_DECL);\n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n   for (decl = current_binding_level->usings; decl; decl = TREE_CHAIN (decl))\n-    if (DECL_INITIAL (decl) == scope && DECL_NAME (decl) == name)\n+    if (USING_DECL_SCOPE (decl) == scope && DECL_NAME (decl) == name)\n       break;\n   if (decl)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n                             namespace_bindings_p () ? decl : NULL_TREE);\n-  decl = build_lang_decl (USING_DECL, name, void_type_node);\n-  DECL_INITIAL (decl) = scope;\n+  decl = build_lang_decl (USING_DECL, name, NULL_TREE);\n+  USING_DECL_SCOPE (decl) = scope;\n   TREE_CHAIN (decl) = current_binding_level->usings;\n   current_binding_level->usings = decl;\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n@@ -2691,35 +2690,80 @@ push_class_level_binding (tree name, tree x)\n tree\n do_class_using_decl (tree scope, tree name)\n {\n-  tree value, type;\n+  tree value, decl, binfo;\n+  base_kind b_kind;\n+  bool dependent_p;\n   \n   if (!scope || !TYPE_P (scope))\n     {\n       error (\"using-declaration for non-member at class scope\");\n       return NULL_TREE;\n     }\n+\n+  /* Make sure the scope is a base.  */\n+  dependent_p = dependent_type_p (scope);\n+  if (!dependent_p)\n+    binfo = lookup_base (current_class_type, scope, ba_any, &b_kind);\n+  else\n+    {\n+      binfo = NULL;\n+      if (same_type_p (current_class_type, scope))\n+\tb_kind = bk_same_type;\n+      else\n+\tb_kind = bk_proper_base;\n+    }\n+  \n+  if (b_kind < bk_proper_base)\n+    {\n+      error_not_base_type (scope, current_class_type);\n+      return NULL_TREE;\n+    }\n+  \n+  /* Make sure the name is not invalid */\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n-      error (\"using-declaration cannot name destructor\");\n+      error (\"%<%T::%D%> names destructor\", scope, name);\n+      return NULL_TREE;\n+    }\n+  if (constructor_name_p (name, scope))\n+    {\n+      error (\"%<%T::%D%> names constructor\", scope, name);\n+      return NULL_TREE;\n+    }\n+  if (constructor_name_p (name, current_class_type))\n+    {\n+      error (\"%<%T::%D%> names constructor in %qT\",\n+\t     scope, name, current_class_type);\n       return NULL_TREE;\n     }\n \n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n-\n-  /* Dependent using decls have a NULL type, non-dependent ones have a\n-     void type.  */\n-  type = dependent_type_p (scope) ? NULL_TREE : void_type_node;\n-  value = build_lang_decl (USING_DECL, name, type);\n-  DECL_INITIAL (value) = scope;\n+  if (!dependent_p\n+      && IDENTIFIER_OPNAME_P (name) && dependent_type_p (TREE_TYPE (name)))\n+    dependent_p = 1;\n \n-  if (scope && !processing_template_decl)\n+  /* See if there are any members of the base. */\n+  if (!dependent_p)\n     {\n-      tree r;\n+      decl = lookup_member (binfo, name, 0, false);\n+  \n+      if (!decl)\n+\t{\n+\t  error (\"no members matching %<%T::%D%> in %q#T\", scope, name, scope);\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (BASELINK_P (decl))\n+\t/* Ignore base type this came from.  */\n+\tdecl = BASELINK_FUNCTIONS (decl);\n+   }\n+  else\n+    decl = NULL_TREE;\n+\n+  value = build_lang_decl (USING_DECL, name, NULL_TREE);\n+  USING_DECL_DECLS (value) = decl;\n+  USING_DECL_SCOPE (value) = scope;\n+  DECL_DEPENDENT_P (value) = dependent_p;\n \n-      r = lookup_qualified_name (scope, name, false, false);\n-      if (r && (DECL_P (r) || TREE_CODE (r) == OVERLOAD))\n-\tcp_emit_debug_info_for_using (r, scope);\n-    }\n   return value;\n }\n \n@@ -4923,7 +4967,7 @@ pop_everything (void)\n    If input tree is overloaded fn then emit debug info for all \n    candidates.  */\n \n-static void\n+void\n cp_emit_debug_info_for_using (tree t, tree context)\n {\n   /* Ignore this FUNCTION_DECL if it refers to a builtin declaration \n@@ -4945,6 +4989,6 @@ cp_emit_debug_info_for_using (tree t, tree context)\n   for (t = OVL_CURRENT (t); t; t = OVL_NEXT (t))\n     if (TREE_CODE (t) != TEMPLATE_DECL)\n       (*debug_hooks->imported_module_or_decl) (t, context);\n-  }\n+}\n \n #include \"gt-cp-name-lookup.h\""}, {"sha": "70c12a219f55ba4b75a7675d289051748483b3a0", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -341,6 +341,7 @@ extern bool is_associated_namespace (tree, tree);\n extern void parse_using_directive (tree, tree);\n extern tree innermost_non_namespace_value (tree);\n extern cxx_binding *outer_binding (tree, cxx_binding *, bool);\n+extern void cp_emit_debug_info_for_using (tree, tree);\n \n /* Set *DECL to the (non-hidden) declaration for ID at global scope,\n    if present and return true; otherwise return false.  */"}, {"sha": "8af0234f618294f6b21948d321d828ffc6c56623", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -6557,16 +6557,20 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n       break;\n \n     case USING_DECL:\n-      {\n-\tr = copy_node (t);\n-\t/* It is not a dependent using decl any more.  */\n-\tTREE_TYPE (r) = void_type_node;\n-\tDECL_INITIAL (r)\n-\t  = tsubst_copy (DECL_INITIAL (t), args, complain, in_decl);\n-\tDECL_NAME (r)\n-\t  = tsubst_copy (DECL_NAME (t), args, complain, in_decl);\n-\tTREE_CHAIN (r) = NULL_TREE;\n-      }\n+      /* We reach here only for member using decls.  */\n+      if (DECL_DEPENDENT_P (t))\n+\t{\n+\t  r = do_class_using_decl\n+\t    (tsubst_copy (USING_DECL_SCOPE (t), args, complain, in_decl),\n+\t     tsubst_copy (DECL_NAME (t), args, complain, in_decl));\n+\t  if (!r)\n+\t    r = error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  r = copy_node (t);\n+\t  TREE_CHAIN (r) = NULL_TREE;\n+\t}\n       break;\n \n     case TYPE_DECL:\n@@ -8085,7 +8089,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  finish_label_decl (DECL_NAME (decl));\n \telse if (TREE_CODE (decl) == USING_DECL)\n \t  {\n-\t    tree scope = DECL_INITIAL (decl);\n+\t    tree scope = USING_DECL_SCOPE (decl);\n \t    tree name = DECL_NAME (decl);\n \t    tree decl;\n \t    "}, {"sha": "8dec18e7743419dd9618f57daf35658be8354fdc", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -471,9 +471,8 @@ lookup_field_1 (tree type, tree name, bool want_type)\n \t     defined, USING_DECLs are purged from TYPE_FIELDS; see\n \t     handle_using_decl.  However, we make special efforts to\n \t     make using-declarations in class templates and class\n-\t     template partial specializations work correctly noticing\n-\t     that dependent USING_DECL's do not have TREE_TYPE set.  */\n-\t  if (TREE_TYPE (field))\n+\t     template partial specializations work correctly.  */\n+\t  if (!DECL_DEPENDENT_P (field))\n \t    continue;\n \t}\n "}, {"sha": "298979b38e3148e9e1e100fb5a1b4cec0294700b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -2259,7 +2259,7 @@ finish_member_declaration (tree decl)\n \t\t\t\t\t  /*friend_p=*/0);\n     }\n   /* Enter the DECL into the scope of the class.  */\n-  else if ((TREE_CODE (decl) == USING_DECL && TREE_TYPE (decl))\n+  else if ((TREE_CODE (decl) == USING_DECL && !DECL_DEPENDENT_P (decl))\n \t   || pushdecl_class_level (decl))\n     {\n       /* All TYPE_DECLs go at the end of TYPE_FIELDS.  Ordinary fields"}, {"sha": "8ac9bf504a23839cbc3ea505f4b2f9398ad1a1ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -1,3 +1,9 @@\n+2005-06-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/19497\n+\t* g++.dg/inherit/using5.C: New.\n+\t* g++.dg/inherit/using6.C: New.\n+\n 2005-06-08  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/19894"}, {"sha": "896c2d461de3632273a76e30d527dd8c5e50bd23", "filename": "gcc/testsuite/g++.dg/inherit/using5.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fusing5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fusing5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fusing5.C?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -0,0 +1,17 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 8 Jun 2005 <nathan@codesourcery.com>\n+\n+// PR 19496: Missing error during parsing.\n+// Origin:  Volker Reichelt <reichelt@gcc.gnu.org>\n+\n+template<int> struct A\n+{\n+  A::A; // { dg-error \"not a base\" }\n+};\n+\n+struct B\n+{\n+  void f ();\n+  using B::f; // { dg-error \"not a base\" }\n+};\n+"}, {"sha": "46c23ce582e17079dd6dec714ca741ca4fa8b9a2", "filename": "gcc/testsuite/g++.dg/inherit/using6.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fusing6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ed9dae3ad020898a04cbf7363d51647b441ad6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fusing6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fusing6.C?ref=98ed9dae3ad020898a04cbf7363d51647b441ad6", "patch": "@@ -0,0 +1,15 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 8 Jun 2005 <nathan@codesourcery.com>\n+\n+struct A\n+{\n+  operator int ();\n+};\n+\n+template <typename T> struct TPL : A\n+{\n+  using A::operator T; // { dg-error \"operator float\" }\n+};\n+\n+TPL<int> i;\n+TPL<float> j; // { dg-error \"instantiated\" }"}]}