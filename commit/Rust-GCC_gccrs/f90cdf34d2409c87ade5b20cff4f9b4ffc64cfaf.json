{"sha": "f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkwY2RmMzRkMjQwOWM4N2FkZTViMjBjZmY0ZjliNGZmYzY0Y2ZhZg==", "commit": {"author": {"name": "Michael Tiemann", "email": "tiemann@happy.cygnus.com", "date": "1999-07-09T16:15:04Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-07-09T16:15:04Z"}, "message": "cp-tree.h (struct lang_decl): Added field for storing sorted FIELD_DECLs (used in TYPE_DECLs).\n\n\t* cp-tree.h (struct lang_decl): Added field for storing sorted\n\tFIELD_DECLs (used in TYPE_DECLs).\n\t(DECL_PENDING_INLINE_INFO): Adjusted to use 'u' union.\n\t(DECL_SORTED_FIELDS): New macro.\n\t* class.c (method_name_cmp): New function.\n\t(finish_struct_methods): Modified to support sorting and searching\n\tmethods.\n\t(finish_struct_anon): Changed code in inner loop to use ELT rather\n\tthan UELT (which required an extra indirection for every reference).\n\t(field_decl_cmp): New function to support sorting FIELD_DECLs.\n\t(finish_struct_1): Sort fields.\n\t* search.c (lookup_field_1): Use DECL_SORTED_FIELDS if we have them.\n\t(lookup_fnfields_1): Search sorted methods in METHOD_VEC.\n\tAlso, switch to using array indexing rather than a changing pointer.\n\t* ptree.c (print_lang_decl): Handle TYPE_DECLs that have\n\tDECL_SORTED_FIELDS.\n\nCo-Authored-By: Jason Merrill <jason@yorick.cygnus.com>\n\nFrom-SVN: r28046", "tree": {"sha": "fe4da5c0be7eb3c448a6b274d4e1907f06e7d1e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe4da5c0be7eb3c448a6b274d4e1907f06e7d1e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf/comments", "author": null, "committer": null, "parents": [{"sha": "1d02ac8371b1d3b31ed029c29fa23fadeca48787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d02ac8371b1d3b31ed029c29fa23fadeca48787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d02ac8371b1d3b31ed029c29fa23fadeca48787"}], "stats": {"total": 292, "additions": 248, "deletions": 44}, "files": [{"sha": "6edfa5f2a773afc75b6058ca1b8f74d4bdd36353", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf", "patch": "@@ -1,3 +1,23 @@\n+1999-07-09  Michael Tiemann  <tiemann@happy.cygnus.com>\n+\t    Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h (struct lang_decl): Added field for storing sorted\n+\tFIELD_DECLs (used in TYPE_DECLs).\n+\t(DECL_PENDING_INLINE_INFO): Adjusted to use 'u' union.\n+\t(DECL_SORTED_FIELDS): New macro.\n+\t* class.c (method_name_cmp): New function.\n+\t(finish_struct_methods): Modified to support sorting and searching\n+\tmethods.\n+\t(finish_struct_anon): Changed code in inner loop to use ELT rather \n+\tthan UELT (which required an extra indirection for every reference).\n+\t(field_decl_cmp): New function to support sorting FIELD_DECLs.\n+\t(finish_struct_1): Sort fields.\n+\t* search.c (lookup_field_1): Use DECL_SORTED_FIELDS if we have them.\n+\t(lookup_fnfields_1): Search sorted methods in METHOD_VEC.\n+\tAlso, switch to using array indexing rather than a changing pointer.\n+\t* ptree.c (print_lang_decl): Handle TYPE_DECLs that have\n+\tDECL_SORTED_FIELDS.\n+\n 1999-07-09  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (reparse_absdcl_as_casts): Don't warn about old-style"}, {"sha": "6a25b5915ed8dfde9f1f70a65e0e666063d89fc1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 138, "deletions": 18, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf", "patch": "@@ -130,6 +130,8 @@ static void modify_all_indirect_vtables PROTO((tree, int, int, tree,\n static int finish_base_struct PROTO((tree, struct base_info *));\n static void finish_struct_methods PROTO((tree));\n static void maybe_warn_about_overly_private_class PROTO ((tree));\n+static int field_decl_cmp PROTO ((const tree *, const tree *));\n+static int method_name_cmp PROTO ((const tree *, const tree *));\n static tree make_method_vec PROTO((int));\n static void free_method_vec PROTO((tree));\n static tree add_implicitly_declared_members PROTO((tree, int, int, int));\n@@ -2004,6 +2006,39 @@ maybe_warn_about_overly_private_class (t)\n     }\n }\n \n+/* Function to help qsort sort FIELD_DECLs by name order.  */\n+\n+static int\n+field_decl_cmp (x, y)\n+     const tree *x, *y;\n+{\n+  if (DECL_NAME (*x) == DECL_NAME (*y))\n+    return 0;\n+  if (DECL_NAME (*x) == NULL_TREE)\n+    return -1;\n+  if (DECL_NAME (*y) == NULL_TREE)\n+    return 1;\n+  if (DECL_NAME (*x) < DECL_NAME (*y))\n+    return -1;\n+  return 1;\n+}\n+\n+/* Comparison function to compare two TYPE_METHOD_VEC entries by name.  */\n+\n+static int\n+method_name_cmp (m1, m2)\n+     const tree *m1, *m2;\n+{\n+  if (*m1 == NULL_TREE && *m2 == NULL_TREE)\n+    return 0;\n+  if (*m1 == NULL_TREE)\n+    return -1;\n+  if (*m2 == NULL_TREE)\n+    return 1;\n+  if (DECL_NAME (OVL_CURRENT (*m1)) < DECL_NAME (OVL_CURRENT (*m2)))\n+    return -1;\n+  return 1;\n+}\n \n /* Warn about duplicate methods in fn_fields.  Also compact method\n    lists so that lookup can be made faster.\n@@ -2020,10 +2055,11 @@ maybe_warn_about_overly_private_class (t)\n    If there are any constructors/destructors, they are moved to the\n    front of the list.  This makes pushclass more efficient.\n \n-   We also link each field which has shares a name with its baseclass\n-   to the head of the list of fields for that base class.  This allows\n-   us to reduce search time in places like `build_method_call' to\n-   consider only reasonably likely functions.   */\n+   @@ The above comment is obsolete.  It mostly describes what add_method\n+   @@ and add_implicitly_declared_members do.\n+\n+   Sort methods that are not special (i.e., constructors, destructors, and\n+   type conversion operators) so that we can find them faster in search.  */\n \n static void\n finish_struct_methods (t)\n@@ -2032,6 +2068,7 @@ finish_struct_methods (t)\n   tree fn_fields;\n   tree method_vec = CLASSTYPE_METHOD_VEC (t);\n   tree ctor_name = constructor_name (t);\n+  int slot, len = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n \n   /* First fill in entry 0 with the constructors, entry 1 with destructors,\n      and the next few with type conversion operators (if any).  */\n@@ -2089,7 +2126,28 @@ finish_struct_methods (t)\n     \n   /* Issue warnings about private constructors and such.  If there are\n      no methods, then some public defaults are generated.  */\n-  maybe_warn_about_overly_private_class (t); \n+  maybe_warn_about_overly_private_class (t);\n+\n+  if (method_vec == NULL_TREE)\n+    return;\n+\n+  /* Now sort the methods.  */\n+  while (len > 2 && TREE_VEC_ELT (method_vec, len-1) == NULL_TREE)\n+    len--;\n+  TREE_VEC_LENGTH (method_vec) = len;\n+\n+  /* The type conversion ops have to live at the front of the vec, so we\n+     can't sort them.  */\n+  for (slot = 2; slot < len; ++slot)\n+    {\n+      tree fn = TREE_VEC_ELT (method_vec, slot);\n+  \n+      if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n+\tbreak;\n+    }\n+  if (len - slot > 1)\n+    qsort (&TREE_VEC_ELT (method_vec, slot), len-slot, sizeof (tree),\n+\t   (int (*)(const void *, const void *))method_name_cmp);\n }\n \n /* Emit error when a duplicate definition of a type is seen.  Patch up.  */\n@@ -2950,6 +3008,7 @@ finish_struct_anon (t)\n      tree t;\n {\n   tree field;\n+\n   for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n     {\n       if (TREE_STATIC (field))\n@@ -2960,32 +3019,32 @@ finish_struct_anon (t)\n       if (DECL_NAME (field) == NULL_TREE\n \t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n \t{\n-\t  tree* uelt = &TYPE_FIELDS (TREE_TYPE (field));\n-\t  for (; *uelt; uelt = &TREE_CHAIN (*uelt))\n+\t  tree elt = TYPE_FIELDS (TREE_TYPE (field));\n+\t  for (; elt; elt = TREE_CHAIN (elt))\n \t    {\n-\t      if (DECL_ARTIFICIAL (*uelt))\n+\t      if (DECL_ARTIFICIAL (elt))\n \t\tcontinue;\n \n-\t      if (DECL_NAME (*uelt) == constructor_name (t))\n+\t      if (DECL_NAME (elt) == constructor_name (t))\n \t\tcp_pedwarn_at (\"ANSI C++ forbids member `%D' with same name as enclosing class\",\n-\t\t\t       *uelt);\n+\t\t\t       elt);\n \n-\t      if (TREE_CODE (*uelt) != FIELD_DECL)\n+\t      if (TREE_CODE (elt) != FIELD_DECL)\n \t\t{\n \t\t  cp_pedwarn_at (\"`%#D' invalid; an anonymous union can only have non-static data members\",\n-\t\t\t\t *uelt);\n+\t\t\t\t elt);\n \t\t  continue;\n \t\t}\n \n-\t      if (TREE_PRIVATE (*uelt))\n+\t      if (TREE_PRIVATE (elt))\n \t\tcp_pedwarn_at (\"private member `%#D' in anonymous union\",\n-\t\t\t       *uelt);\n-\t      else if (TREE_PROTECTED (*uelt))\n+\t\t\t       elt);\n+\t      else if (TREE_PROTECTED (elt))\n \t\tcp_pedwarn_at (\"protected member `%#D' in anonymous union\",\n-\t\t\t       *uelt);\n+\t\t\t       elt);\n \n-\t      TREE_PRIVATE (*uelt) = TREE_PRIVATE (field);\n-\t      TREE_PROTECTED (*uelt) = TREE_PROTECTED (field);\n+\t      TREE_PRIVATE (elt) = TREE_PRIVATE (field);\n+\t      TREE_PROTECTED (elt) = TREE_PROTECTED (field);\n \t    }\n \t}\n     }\n@@ -3077,6 +3136,44 @@ add_implicitly_declared_members (t, cant_have_default_ctor,\n   return virtual_dtor;\n }\n \n+/* Subroutine of finish_struct_1.  Recursively count the number of fields\n+   in TYPE, including anonymous union members.  */\n+\n+static int\n+count_fields (fields)\n+     tree fields;\n+{\n+  tree x;\n+  int n_fields = 0;\n+  for (x = fields; x; x = TREE_CHAIN (x))\n+    {\n+      if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n+\tn_fields += count_fields (TYPE_FIELDS (TREE_TYPE (x)));\n+      else\n+\tn_fields += 1;\n+    }\n+  return n_fields;\n+}\n+\n+/* Subroutine of finish_struct_1.  Recursively add all the fields in the\n+   TREE_LIST FIELDS to the TREE_VEC FIELD_VEC, starting at offset IDX.  */\n+\n+static int\n+add_fields_to_vec (fields, field_vec, idx)\n+     tree fields, field_vec;\n+     int idx;\n+{\n+  tree x;\n+  for (x = fields; x; x = TREE_CHAIN (x))\n+    {\n+      if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n+\tidx = add_fields_to_vec (TYPE_FIELDS (TREE_TYPE (x)), field_vec, idx);\n+      else\n+\tTREE_VEC_ELT (field_vec, idx++) = x;\n+    }\n+  return idx;\n+}\n+\n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n    (or C++ class declaration).\n \n@@ -3125,6 +3222,7 @@ finish_struct_1 (t, warn_anon)\n   int cant_have_const_ctor;\n   int no_const_asn_ref;\n   int has_mutable = 0;\n+  int n_fields = 0;\n \n   /* The index of the first base class which has virtual\n      functions.  Only applied to non-virtual baseclasses.  */\n@@ -4008,6 +4106,28 @@ finish_struct_1 (t, warn_anon)\n \t}\n     }\n \n+  /* Done with FIELDS...now decide whether to sort these for\n+     faster lookups later.  Don't worry about optimizing\n+     for structs only declared in inline functions...they're\n+     not going to be referenced anywhere else.\n+\n+     The C front-end only does this when n_fields > 15.  We use\n+     a smaller number because most searches fail (succeeding\n+     ultimately as the search bores through the inheritance\n+     hierarchy), and we want this failure to occur quickly.  */\n+\n+  n_fields = count_fields (fields);\n+  if (n_fields > 7 && !allocation_temporary_p ())\n+    {\n+      tree field_vec = make_tree_vec (n_fields);\n+      add_fields_to_vec (fields, field_vec, 0);\n+      qsort (&TREE_VEC_ELT (field_vec, 0), n_fields, sizeof (tree),\n+\t     (int (*)(const void *, const void *))field_decl_cmp);\n+      if (! DECL_LANG_SPECIFIC (TYPE_MAIN_DECL (t)))\n+\tretrofit_lang_decl (TYPE_MAIN_DECL (t));\n+      DECL_SORTED_FIELDS (TYPE_MAIN_DECL (t)) = field_vec;\n+    }\n+\n   if (TYPE_HAS_CONSTRUCTOR (t))\n     {\n       tree vfields = CLASSTYPE_VFIELDS (t);"}, {"sha": "f32eea899ac8e318e1c92e7cfeae1804904072e0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf", "patch": "@@ -1194,7 +1194,11 @@ struct lang_decl\n \n   tree main_decl_variant;\n   tree befriending_classes;\n-  struct pending_inline *pending_inline_info;\n+  union\n+  {\n+    tree sorted_fields;\n+    struct pending_inline *pending_inline_info;\n+  } u;\n };\n \n /* Non-zero if NODE is a _DECL with TREE_READONLY set.  */\n@@ -1379,7 +1383,11 @@ struct lang_decl\n /* For a FUNCTION_DECL: if this function was declared inline inside of\n    a class declaration, this is where the text for the function is\n    squirreled away.  */\n-#define DECL_PENDING_INLINE_INFO(NODE) (DECL_LANG_SPECIFIC(NODE)->pending_inline_info)\n+#define DECL_PENDING_INLINE_INFO(NODE) (DECL_LANG_SPECIFIC(NODE)->u.pending_inline_info)\n+\n+/* For a TYPE_DECL: if this function has many fields, we'll sort them\n+   and put them into a TREE_VEC. */\n+#define DECL_SORTED_FIELDS(NODE) (DECL_LANG_SPECIFIC(NODE)->u.sorted_fields)\n \n /* True if on the saved_inlines (see decl2.c) list.  */\n #define DECL_SAVED_INLINE(DECL) \\"}, {"sha": "3c8486425fd8fa0ddd1a8ee93186e7bfb63bedde", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf", "patch": "@@ -48,11 +48,18 @@ print_lang_decl (file, node, indent)\n       fprintf (file, \" decl-main-variant \");\n       fprintf (file, HOST_PTR_PRINTF, DECL_MAIN_VARIANT (node));\n     }\n-  if (DECL_PENDING_INLINE_INFO (node))\n+  if (TREE_CODE (node) == FUNCTION_DECL\n+      && DECL_PENDING_INLINE_INFO (node))\n     {\n       fprintf (file, \" pending-inline-info \");\n       fprintf (file, HOST_PTR_PRINTF, DECL_PENDING_INLINE_INFO (node));\n     }\n+  if (TREE_CODE (node) == TYPE_DECL\n+      && DECL_SORTED_FIELDS (node))\n+    {\n+      fprintf (file, \" sorted-fields \");\n+      fprintf (file, HOST_PTR_PRINTF, DECL_SORTED_FIELDS (node));\n+    }\n   if (DECL_TEMPLATE_INFO (node))\n     {\n       fprintf (file, \" template-info \");"}, {"sha": "0fe5cf44691e3fcb666b366b5693059d93e2c55c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 72, "deletions": 23, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=f90cdf34d2409c87ade5b20cff4f9b4ffc64cfaf", "patch": "@@ -522,6 +522,32 @@ lookup_field_1 (type, name)\n        of fields!)  */\n     return NULL_TREE;\n \n+  if (TYPE_NAME (type)\n+      && DECL_LANG_SPECIFIC (TYPE_NAME (type))\n+      && DECL_SORTED_FIELDS (TYPE_NAME (type)))\n+    {\n+      tree *fields = &TREE_VEC_ELT (DECL_SORTED_FIELDS (TYPE_NAME (type)), 0);\n+      int lo = 0, hi = TREE_VEC_LENGTH (DECL_SORTED_FIELDS (TYPE_NAME (type)));\n+      int i;\n+\n+      while (lo < hi)\n+\t{\n+\t  i = (lo + hi) / 2;\n+\n+#ifdef GATHER_STATISTICS\n+\t  n_fields_searched++;\n+#endif /* GATHER_STATISTICS */\n+\n+\t  if (DECL_NAME (fields[i]) > name)\n+\t    hi = i;\n+\t  else if (DECL_NAME (fields[i]) < name)\n+\t    lo = i + 1;\n+\t  else\n+\t    return fields[i];\n+\t}\n+      return NULL_TREE;\n+    }\n+\n   field = TYPE_FIELDS (type);\n \n #ifdef GATHER_STATISTICS\n@@ -1502,61 +1528,84 @@ int\n lookup_fnfields_1 (type, name)\n      tree type, name;\n {\n-  register tree method_vec \n+  tree method_vec \n     = CLASS_TYPE_P (type) ? CLASSTYPE_METHOD_VEC (type) : NULL_TREE;\n \n   if (method_vec != 0)\n     {\n+      register int i;\n       register tree *methods = &TREE_VEC_ELT (method_vec, 0);\n-      register tree *end = TREE_VEC_END (method_vec);\n+      int len = TREE_VEC_LENGTH (method_vec);\n+      tree tmp;\n \n #ifdef GATHER_STATISTICS\n       n_calls_lookup_fnfields_1++;\n #endif /* GATHER_STATISTICS */\n \n       /* Constructors are first...  */\n-      if (*methods && name == ctor_identifier)\n-\treturn 0;\n+      if (name == ctor_identifier)\n+\treturn methods[0] ? 0 : -1;\n \n       /* and destructors are second.  */\n-      if (*++methods && name == dtor_identifier)\n-\treturn 1;\n+      if (name == dtor_identifier)\n+\treturn methods[1] ? 1 : -1;\n \n-      while (++methods != end && *methods)\n+      for (i = 2; i < len && methods[i]; ++i)\n \t{\n #ifdef GATHER_STATISTICS\n \t  n_outer_fields_searched++;\n #endif /* GATHER_STATISTICS */\n-\t  if (DECL_NAME (OVL_CURRENT (*methods)) == name)\n-\t    break;\n+\n+\t  tmp = OVL_CURRENT (methods[i]);\n+\t  if (DECL_NAME (tmp) == name)\n+\t    return i;\n+\n+\t  /* If the type is complete and we're past the conversion ops,\n+\t     switch to binary search.  */\n+\t  if (! DECL_CONV_FN_P (tmp)\n+\t      && TYPE_SIZE (type))\n+\t    {\n+\t      int lo = i + 1, hi = len;\n+\n+\t      while (lo < hi)\n+\t\t{\n+\t\t  i = (lo + hi) / 2;\n+\n+#ifdef GATHER_STATISTICS\n+\t\t  n_outer_fields_searched++;\n+#endif /* GATHER_STATISTICS */\n+\n+\t\t  tmp = DECL_NAME (OVL_CURRENT (methods[i]));\n+\n+\t\t  if (tmp > name)\n+\t\t    hi = i;\n+\t\t  else if (tmp < name)\n+\t\t    lo = i + 1;\n+\t\t  else\n+\t\t    return i;\n+\t\t}\n+\t      break;\n+\t    }\n \t}\n \n       /* If we didn't find it, it might have been a template\n \t conversion operator.  (Note that we don't look for this case\n \t above so that we will always find specializations first.)  */\n-      if ((methods == end || !*methods)\n-\t  && IDENTIFIER_TYPENAME_P (name)) \n+      if (IDENTIFIER_TYPENAME_P (name)) \n \t{\n-\t  methods = &TREE_VEC_ELT (method_vec, 0) + 1;\n-\t  \n-\t  while (++methods != end && *methods)\n+\t  for (i = 2; i < len && methods[i]; ++i)\n \t    {\n-\t      tree method_name = DECL_NAME (OVL_CURRENT (*methods));\n-\n-\t      if (!IDENTIFIER_TYPENAME_P (method_name))\n+\t      tmp = OVL_CURRENT (methods[i]);\n+\t      if (! DECL_CONV_FN_P (tmp))\n \t\t{\n \t\t  /* Since all conversion operators come first, we know\n \t\t     there is no such operator.  */\n-\t\t  methods = end;\n \t\t  break;\n \t\t}\n-\t      else if (TREE_CODE (OVL_CURRENT (*methods)) == TEMPLATE_DECL)\n-\t\tbreak;\n+\t      else if (TREE_CODE (tmp) == TEMPLATE_DECL)\n+\t\treturn i;\n \t    }\n \t}\n-\n-      if (methods != end && *methods)\n-\treturn methods - &TREE_VEC_ELT (method_vec, 0);\n     }\n \n   return -1;"}]}