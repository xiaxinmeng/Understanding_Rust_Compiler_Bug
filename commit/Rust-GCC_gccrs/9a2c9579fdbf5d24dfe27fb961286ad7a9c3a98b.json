{"sha": "9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEyYzk1NzlmZGJmNWQyNGRmZTI3ZmI5NjEyODZhZDdhOWMzYTk4Yg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-06-15T13:31:26Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-06-15T13:31:26Z"}, "message": "analyzer: track dynamic extents of regions\n\nThis patch extends region_model to add tracking of the sizes of\ndynamically-allocated regions, both on the heap (via malloc etc) and\nstack (via alloca).  It adds enough purging of this state to avoid\nblowing up any existing analyzer test cases.\n\nThe state can be queried via a new \"__analyzer_dump_capacity\" for use\nin DejaGnu tests but other than that doesn't do anything - I have\nvarious followup experiments that make use of this.\n\ngcc/analyzer/ChangeLog:\n\t* engine.cc (exploded_node::on_stmt): Handle __analyzer_dump_capacity.\n\t(exploded_node::on_stmt): Drop m_sm_changes from on_stmt_flags.\n\t(state_change_requires_new_enode_p): New function...\n\t(exploded_graph::process_node): Call it, rather than querying\n\tflags.m_sm_changes, so that dynamic-extent differences can also\n\ttrigger the splitting of nodes.\n\t* exploded-graph.h (struct on_stmt_flags): Drop field m_sm_changes.\n\t* program-state.cc (program_state::detect_leaks): Purge dead\n\theap-allocated regions from dynamic extents.\n\t(selftest::test_program_state_1): Fix type of \"size_in_bytes\".\n\t(selftest::test_program_state_merging): Likewise.\n\t* region-model-impl-calls.cc\n\t(region_model::impl_call_analyzer_dump_capacity): New.\n\t(region_model::impl_call_free): Remove dynamic extents from the\n\tfreed region.\n\t* region-model-reachability.h\n\t(reachable_regions::begin_mutable_base_regs): New.\n\t(reachable_regions::end_mutable_base_regs): New.\n\t* region-model.cc: Include \"tree-object-size.h\".\n\t(region_model::region_model): Support new field m_dynamic_extents.\n\t(region_model::operator=): Likewise.\n\t(region_model::operator==): Likewise.\n\t(region_model::dump_to_pp): Dump sizes of dynamic regions.\n\t(region_model::handle_unrecognized_call): Purge dynamic extents\n\tfrom any regions that have escaped mutably:.\n\t(region_model::get_capacity): New function.\n\t(region_model::add_constraint): Unset dynamic extents when a\n\theap-allocated region's address is NULL.\n\t(region_model::unbind_region_and_descendents): Purge dynamic\n\textents of unbound regions.\n\t(region_model::can_merge_with_p): Call\n\tm_dynamic_extents.can_merge_with_p.\n\t(region_model::create_region_for_heap_alloc): Assert that\n\tsize_in_bytes's type is compatible with size_type_node.  Update\n\tfor renaming of record_dynamic_extents to set_dynamic_extents.\n\t(region_model::create_region_for_alloca): Likewise.\n\t(region_model::record_dynamic_extents): Rename to...\n\t(region_model::set_dynamic_extents): ...this.  Assert that\n\tsize_in_bytes's type is compatible with size_type_node.  Add it\n\tto the m_dynamic_extents map.\n\t(region_model::get_dynamic_extents): New.\n\t(region_model::unset_dynamic_extents): New.\n\t(selftest::test_state_merging): Fix type of \"size\".\n\t(selftest::test_malloc_constraints): Likewise.\n\t(selftest::test_malloc): Verify dynamic extents.\n\t(selftest::test_alloca): Likewise.\n\t* region-model.h (region_to_value_map::is_empty): New.\n\t(region_model::dynamic_extents_t): New typedef.\n\t(region_model::impl_call_analyzer_dump_capacity): New decl.\n\t(region_model::get_dynamic_extents): New function.\n\t(region_model::get_dynamic_extents): New decl.\n\t(region_model::set_dynamic_extents): New decl.\n\t(region_model::unset_dynamic_extents): New decl.\n\t(region_model::get_capacity): New decl.\n\t(region_model::record_dynamic_extents): Rename to set_dynamic_extents.\n\t(region_model::m_dynamic_extents): New field.\n\ngcc/ChangeLog:\n\t* doc/analyzer.texi\n\t(Special Functions for Debugging the Analyzer): Add\n\t__analyzer_dump_capacity.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/analyzer-decls.h (__analyzer_dump_capacity): New decl.\n\t* gcc.dg/analyzer/capacity-1.c: New test.\n\t* gcc.dg/analyzer/capacity-2.c: New test.\n\t* gcc.dg/analyzer/capacity-3.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "9a6b2703fcebdff4e75e0e043f90f0bb4933cdf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a6b2703fcebdff4e75e0e043f90f0bb4933cdf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d726a57b993e00294891e2a05d5868c89bb75b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d726a57b993e00294891e2a05d5868c89bb75b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d726a57b993e00294891e2a05d5868c89bb75b76"}], "stats": {"total": 515, "additions": 473, "deletions": 42}, "files": [{"sha": "df04b0ba5d6343025d056b4cf24204b1df03d107", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -1185,6 +1185,8 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t       to stderr.  */\n \t    state->dump (eg.get_ext_state (), true);\n \t  }\n+\telse if (is_special_named_call_p (call, \"__analyzer_dump_capacity\", 1))\n+\t  state->m_region_model->impl_call_analyzer_dump_capacity (call, &ctxt);\n \telse if (is_special_named_call_p (call, \"__analyzer_dump_path\", 0))\n \t  {\n \t    /* Handle the builtin \"__analyzer_dump_path\" by queuing a\n@@ -1237,7 +1239,6 @@ exploded_node::on_stmt (exploded_graph &eg,\n   if (terminate_path)\n     return on_stmt_flags::terminate_path ();\n \n-  bool any_sm_changes = false;\n   int sm_idx;\n   sm_state_map *smap;\n   FOR_EACH_VEC_ELT (old_state.m_checker_states, sm_idx, smap)\n@@ -1276,14 +1277,12 @@ exploded_node::on_stmt (exploded_graph &eg,\n       /* Allow the state_machine to handle the stmt.  */\n       if (sm.on_stmt (&sm_ctxt, snode, stmt))\n \tunknown_side_effects = false;\n-      if (*old_smap != *new_smap)\n-\tany_sm_changes = true;\n     }\n \n   if (const gcall *call = dyn_cast <const gcall *> (stmt))\n     state->m_region_model->on_call_post (call, unknown_side_effects, &ctxt);\n \n-  return on_stmt_flags (any_sm_changes);\n+  return on_stmt_flags ();\n }\n \n /* Consider the effect of following superedge SUCC from this node.\n@@ -2925,6 +2924,36 @@ stmt_requires_new_enode_p (const gimple *stmt,\n   return false;\n }\n \n+/* Return true if OLD_STATE and NEW_STATE are sufficiently different that\n+   we should split enodes and create an exploded_edge separating them\n+   (which makes it easier to identify state changes of intereset when\n+   constructing checker_paths).  */\n+\n+static bool\n+state_change_requires_new_enode_p (const program_state &old_state,\n+\t\t\t\t   const program_state &new_state)\n+{\n+  /* Changes in dynamic extents signify creations of heap/alloca regions\n+     and resizings of heap regions; likely to be of interest in\n+     diagnostic paths.  */\n+  if (old_state.m_region_model->get_dynamic_extents ()\n+      != new_state.m_region_model->get_dynamic_extents ())\n+    return true;\n+\n+  /* Changes in sm-state are of interest.  */\n+  int sm_idx;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (old_state.m_checker_states, sm_idx, smap)\n+    {\n+      const sm_state_map *old_smap = old_state.m_checker_states[sm_idx];\n+      const sm_state_map *new_smap = new_state.m_checker_states[sm_idx];\n+      if (*old_smap != *new_smap)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* The core of exploded_graph::process_worklist (the main analysis loop),\n    handling one node in the worklist.\n \n@@ -3067,7 +3096,8 @@ exploded_graph::process_node (exploded_node *node)\n \t    next_state = next_state.prune_for_point (*this, next_point, node,\n \t\t\t\t\t\t     &uncertainty);\n \n-\t    if (flags.m_sm_changes || flag_analyzer_fine_grained)\n+\t    if (flag_analyzer_fine_grained\n+\t\t|| state_change_requires_new_enode_p (old_state, next_state))\n \t      {\n \t\tprogram_point split_point\n \t\t  = program_point::before_stmt (point.get_supernode (),"}, {"sha": "eb1baefad692972b011a32cc8cba34fbb653a7df", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -198,33 +198,21 @@ class exploded_node : public dnode<eg_traits>\n   /* The result of on_stmt.  */\n   struct on_stmt_flags\n   {\n-    on_stmt_flags (bool sm_changes)\n-    : m_sm_changes (sm_changes),\n-      m_terminate_path (false)\n+    on_stmt_flags () : m_terminate_path (false)\n     {}\n \n     static on_stmt_flags terminate_path ()\n     {\n-      return on_stmt_flags (true, true);\n+      return on_stmt_flags (true);\n     }\n \n-    static on_stmt_flags state_change (bool any_sm_changes)\n-    {\n-      return on_stmt_flags (any_sm_changes, false);\n-    }\n-\n-    /* Did any sm-changes occur handling the stmt.  */\n-    bool m_sm_changes : 1;\n-\n     /* Should we stop analyzing this path (on_stmt may have already\n        added nodes/edges, e.g. when handling longjmp).  */\n     bool m_terminate_path : 1;\n \n   private:\n-    on_stmt_flags (bool sm_changes,\n-\t\t   bool terminate_path)\n-    : m_sm_changes (sm_changes),\n-      m_terminate_path (terminate_path)\n+    on_stmt_flags (bool terminate_path)\n+    : m_terminate_path (terminate_path)\n     {}\n   };\n "}, {"sha": "67dd785297ef1d48930a56e096c66513cd7e47f6", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -1270,6 +1270,15 @@ program_state::detect_leaks (const program_state &src_state,\n   /* Purge dead svals from constraints.  */\n   dest_state.m_region_model->get_constraints ()->on_liveness_change\n     (maybe_dest_svalues, dest_state.m_region_model);\n+\n+  /* Purge dead heap-allocated regions from dynamic extents.  */\n+  for (const svalue *sval : dead_svals)\n+    if (const region_svalue *region_sval = sval->dyn_cast_region_svalue ())\n+      {\n+\tconst region *reg = region_sval->get_pointee ();\n+\tif (reg->get_kind () == RK_HEAP_ALLOCATED)\n+\t  dest_state.m_region_model->unset_dynamic_extents (reg);\n+      }\n }\n \n #if CHECKING_P\n@@ -1426,7 +1435,7 @@ test_program_state_1 ()\n   program_state s (ext_state);\n   region_model *model = s.m_region_model;\n   const svalue *size_in_bytes\n-    = mgr->get_or_create_unknown_svalue (integer_type_node);\n+    = mgr->get_or_create_unknown_svalue (size_type_node);\n   const region *new_reg = model->create_region_for_heap_alloc (size_in_bytes);\n   const svalue *ptr_sval = mgr->get_ptr_svalue (ptr_type_node, new_reg);\n   model->set_value (model->get_lvalue (p, NULL),\n@@ -1482,7 +1491,7 @@ test_program_state_merging ()\n \n   region_model *model0 = s0.m_region_model;\n   const svalue *size_in_bytes\n-    = mgr->get_or_create_unknown_svalue (integer_type_node);\n+    = mgr->get_or_create_unknown_svalue (size_type_node);\n   const region *new_reg = model0->create_region_for_heap_alloc (size_in_bytes);\n   const svalue *ptr_sval = mgr->get_ptr_svalue (ptr_type_node, new_reg);\n   model0->set_value (model0->get_lvalue (p, &ctxt),"}, {"sha": "099520a95b0da7c6ae6d9a16a89ef124aa0d768e", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -206,6 +206,25 @@ region_model::impl_call_analyzer_describe (const gcall *call,\n   warning_at (call->location, 0, \"svalue: %qs\", desc.m_buffer);\n }\n \n+/* Handle a call to \"__analyzer_dump_capacity\".\n+\n+   Emit a warning describing the capacity of the base region of\n+   the region pointed to by the 1st argument.\n+   This is for use when debugging, and may be of use in DejaGnu tests.  */\n+\n+void\n+region_model::impl_call_analyzer_dump_capacity (const gcall *call,\n+\t\t\t\t\t\tregion_model_context *ctxt)\n+{\n+  tree t_ptr = gimple_call_arg (call, 0);\n+  const svalue *sval_ptr = get_rvalue (t_ptr, ctxt);\n+  const region *reg = deref_rvalue (sval_ptr, t_ptr, ctxt);\n+  const region *base_reg = reg->get_base_region ();\n+  const svalue *capacity = get_capacity (base_reg);\n+  label_text desc = capacity->get_desc (true);\n+  warning_at (call->location, 0, \"capacity: %qs\", desc.m_buffer);\n+}\n+\n /* Handle a call to \"__analyzer_eval\" by evaluating the input\n    and dumping as a dummy warning, so that test cases can use\n    dg-warning to validate the result (and so unexpected warnings will\n@@ -312,6 +331,7 @@ region_model::impl_call_free (const call_details &cd)\n \t poisoning pointers.  */\n       const region *freed_reg = ptr_to_region_sval->get_pointee ();\n       unbind_region_and_descendents (freed_reg, POISON_KIND_FREED);\n+      m_dynamic_extents.remove (freed_reg);\n     }\n }\n "}, {"sha": "57daf7255fbd8579cd923bc47f0c60b099b3d84d", "filename": "gcc/analyzer/region-model-reachability.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fregion-model-reachability.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fregion-model-reachability.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-reachability.h?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -89,6 +89,14 @@ class reachable_regions\n   {\n     return m_mutable_svals.end ();\n   }\n+  hash_set<const region *>::iterator begin_mutable_base_regs ()\n+  {\n+    return m_mutable_base_regs.begin ();\n+  }\n+  hash_set<const region *>::iterator end_mutable_base_regs ()\n+  {\n+    return m_mutable_base_regs.end ();\n+  }\n \n   void dump_to_pp (pretty_printer *pp) const;\n "}, {"sha": "e02a89765f0c79104e8aadb6f6332c9a8df336a2", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 116, "deletions": 14, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -66,6 +66,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/analyzer-selftests.h\"\n #include \"stor-layout.h\"\n #include \"attribs.h\"\n+#include \"tree-object-size.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -225,7 +226,8 @@ region_to_value_map::can_merge_with_p (const region_to_value_map &other,\n /* Ctor for region_model: construct an \"empty\" model.  */\n \n region_model::region_model (region_model_manager *mgr)\n-: m_mgr (mgr), m_store (), m_current_frame (NULL)\n+: m_mgr (mgr), m_store (), m_current_frame (NULL),\n+  m_dynamic_extents ()\n {\n   m_constraints = new constraint_manager (mgr);\n }\n@@ -235,7 +237,8 @@ region_model::region_model (region_model_manager *mgr)\n region_model::region_model (const region_model &other)\n : m_mgr (other.m_mgr), m_store (other.m_store),\n   m_constraints (new constraint_manager (*other.m_constraints)),\n-  m_current_frame (other.m_current_frame)\n+  m_current_frame (other.m_current_frame),\n+  m_dynamic_extents (other.m_dynamic_extents)\n {\n }\n \n@@ -261,6 +264,8 @@ region_model::operator= (const region_model &other)\n \n   m_current_frame = other.m_current_frame;\n \n+  m_dynamic_extents = other.m_dynamic_extents;\n+\n   return *this;\n }\n \n@@ -285,6 +290,9 @@ region_model::operator== (const region_model &other) const\n   if (m_current_frame != other.m_current_frame)\n     return false;\n \n+  if (m_dynamic_extents != other.m_dynamic_extents)\n+    return false;\n+\n   gcc_checking_assert (hash () == other.hash ());\n \n   return true;\n@@ -346,6 +354,13 @@ region_model::dump_to_pp (pretty_printer *pp, bool simple,\n   m_constraints->dump_to_pp (pp, multiline);\n   if (!multiline)\n     pp_string (pp, \"}\");\n+\n+  /* Dump sizes of dynamic regions, if any are known.  */\n+  if (!m_dynamic_extents.is_empty ())\n+    {\n+      pp_string (pp, \"dynamic_extents:\");\n+      m_dynamic_extents.dump_to_pp (pp, simple, multiline);\n+    }\n }\n \n /* Dump a representation of this model to FILE.  */\n@@ -1140,6 +1155,17 @@ region_model::handle_unrecognized_call (const gcall *call,\n   /* Update bindings for all clusters that have escaped, whether above,\n      or previously.  */\n   m_store.on_unknown_fncall (call, m_mgr->get_store_manager ());\n+\n+  /* Purge dynamic extents from any regions that have escaped mutably:\n+     realloc could have been called on them.  */\n+  for (hash_set<const region *>::iterator\n+\t iter = reachable_regs.begin_mutable_base_regs ();\n+       iter != reachable_regs.end_mutable_base_regs ();\n+       ++iter)\n+    {\n+      const region *base_reg = (*iter);\n+      unset_dynamic_extents (base_reg);\n+    }\n }\n \n /* Traverse the regions in this model, determining what regions are\n@@ -1972,6 +1998,41 @@ region_model::check_for_writable_region (const region* dest_reg,\n     }\n }\n \n+/* Get the capacity of REG in bytes.  */\n+\n+const svalue *\n+region_model::get_capacity (const region *reg) const\n+{\n+  switch (reg->get_kind ())\n+    {\n+    default:\n+      break;\n+    case RK_DECL:\n+      {\n+\tconst decl_region *decl_reg = as_a <const decl_region *> (reg);\n+\ttree decl = decl_reg->get_decl ();\n+\tif (TREE_CODE (decl) == SSA_NAME)\n+\t  {\n+\t    tree type = TREE_TYPE (decl);\n+\t    tree size = TYPE_SIZE (type);\n+\t    return get_rvalue (size, NULL);\n+\t  }\n+\telse\n+\t  {\n+\t    tree size = decl_init_size (decl, false);\n+\t    if (size)\n+\t      return get_rvalue (size, NULL);\n+\t  }\n+      }\n+      break;\n+    }\n+\n+  if (const svalue *recorded = get_dynamic_extents (reg))\n+    return recorded;\n+\n+  return m_mgr->get_or_create_unknown_svalue (sizetype);\n+}\n+\n /* Set the value of the region given by LHS_REG to the value given\n    by RHS_SVAL.  */\n \n@@ -2241,6 +2302,12 @@ region_model::add_constraint (tree lhs, enum tree_code op, tree rhs,\n   if (ctxt)\n     ctxt->on_condition (lhs, op, rhs);\n \n+  /* If we have &REGION == NULL, then drop dynamic extents for REGION (for\n+     the case where REGION is heap-allocated and thus could be NULL).  */\n+  if (op == EQ_EXPR && zerop (rhs))\n+    if (const region_svalue *region_sval = lhs_sval->dyn_cast_region_svalue ())\n+      unset_dynamic_extents (region_sval->get_pointee ());\n+\n   return true;\n }\n \n@@ -3146,7 +3213,8 @@ region_model::get_frame_at_index (int index) const\n \n /* Unbind svalues for any regions in REG and below.\n    Find any pointers to such regions; convert them to\n-   poisoned values of kind PKIND.  */\n+   poisoned values of kind PKIND.\n+   Also purge any dynamic extents.  */\n \n void\n region_model::unbind_region_and_descendents (const region *reg,\n@@ -3167,6 +3235,15 @@ region_model::unbind_region_and_descendents (const region *reg,\n \n   /* Find any pointers to REG or its descendents; convert to poisoned.  */\n   poison_any_pointers_to_descendents (reg, pkind);\n+\n+  /* Purge dynamic extents of any base regions in REG and below\n+     (e.g. VLAs and alloca stack regions).  */\n+  for (auto iter : m_dynamic_extents)\n+    {\n+      const region *iter_reg = iter.first;\n+      if (iter_reg->descendent_of_p (reg))\n+\tunset_dynamic_extents (iter_reg);\n+    }\n }\n \n /* Implementation of BindingVisitor.\n@@ -3241,6 +3318,10 @@ region_model::can_merge_with_p (const region_model &other_model,\n \t\t\t   &m))\n     return false;\n \n+  if (!m_dynamic_extents.can_merge_with_p (other_model.m_dynamic_extents,\n+\t\t\t\t\t   &out_model->m_dynamic_extents))\n+    return false;\n+\n   /* Merge constraints.  */\n   constraint_manager::merge (*m_constraints,\n \t\t\t      *other_model.m_constraints,\n@@ -3322,7 +3403,8 @@ const region *\n region_model::create_region_for_heap_alloc (const svalue *size_in_bytes)\n {\n   const region *reg = m_mgr->create_region_for_heap_alloc ();\n-  record_dynamic_extents (reg, size_in_bytes);\n+  assert_compat_types (size_in_bytes->get_type (), size_type_node);\n+  set_dynamic_extents (reg, size_in_bytes);\n   return reg;\n }\n \n@@ -3333,18 +3415,38 @@ const region *\n region_model::create_region_for_alloca (const svalue *size_in_bytes)\n {\n   const region *reg = m_mgr->create_region_for_alloca (m_current_frame);\n-  record_dynamic_extents (reg, size_in_bytes);\n+  assert_compat_types (size_in_bytes->get_type (), size_type_node);\n+  set_dynamic_extents (reg, size_in_bytes);\n   return reg;\n }\n \n-/* Placeholder hook for recording that the size of REG is SIZE_IN_BYTES.\n-   Currently does nothing.  */\n+/* Record that the size of REG is SIZE_IN_BYTES.  */\n \n void\n-region_model::\n-record_dynamic_extents (const region *reg ATTRIBUTE_UNUSED,\n-\t\t\tconst svalue *size_in_bytes ATTRIBUTE_UNUSED)\n+region_model::set_dynamic_extents (const region *reg,\n+\t\t\t\t   const svalue *size_in_bytes)\n+{\n+  assert_compat_types (size_in_bytes->get_type (), size_type_node);\n+  m_dynamic_extents.put (reg, size_in_bytes);\n+}\n+\n+/* Get the recording of REG in bytes, or NULL if no dynamic size was\n+   recorded.  */\n+\n+const svalue *\n+region_model::get_dynamic_extents (const region *reg) const\n {\n+  if (const svalue * const *slot = m_dynamic_extents.get (reg))\n+    return *slot;\n+  return NULL;\n+}\n+\n+/* Unset any recorded dynamic size of REG.  */\n+\n+void\n+region_model::unset_dynamic_extents (const region *reg)\n+{\n+  m_dynamic_extents.remove (reg);\n }\n \n /* struct model_merger.  */\n@@ -4644,7 +4746,7 @@ test_state_merging ()\n   {\n     test_region_model_context ctxt;\n     region_model model0 (&mgr);\n-    tree size = build_int_cst (integer_type_node, 1024);\n+    tree size = build_int_cst (size_type_node, 1024);\n     const svalue *size_sval = mgr.get_or_create_constant_svalue (size);\n     const region *new_reg = model0.create_region_for_heap_alloc (size_sval);\n     const svalue *ptr_sval = mgr.get_ptr_svalue (ptr_type_node, new_reg);\n@@ -5034,7 +5136,7 @@ test_malloc_constraints ()\n   tree null_ptr = build_int_cst (ptr_type_node, 0);\n \n   const svalue *size_in_bytes\n-    = mgr.get_or_create_unknown_svalue (integer_type_node);\n+    = mgr.get_or_create_unknown_svalue (size_type_node);\n   const region *reg = model.create_region_for_heap_alloc (size_in_bytes);\n   const svalue *sval = mgr.get_ptr_svalue (ptr_type_node, reg);\n   model.set_value (model.get_lvalue (p, NULL), sval, NULL);\n@@ -5259,7 +5361,7 @@ test_malloc ()\n   const region *reg = model.create_region_for_heap_alloc (size_sval);\n   const svalue *ptr = mgr.get_ptr_svalue (int_star, reg);\n   model.set_value (model.get_lvalue (p, &ctxt), ptr, &ctxt);\n-  // TODO: verify dynamic extents\n+  ASSERT_EQ (model.get_capacity (reg), size_sval);\n }\n \n /* Verify that alloca works.  */\n@@ -5294,7 +5396,7 @@ test_alloca ()\n   ASSERT_EQ (reg->get_parent_region (), frame_reg);\n   const svalue *ptr = mgr.get_ptr_svalue (int_star, reg);\n   model.set_value (model.get_lvalue (p, &ctxt), ptr, &ctxt);\n-  // TODO: verify dynamic extents\n+  ASSERT_EQ (model.get_capacity (reg), size_sval);\n \n   /* Verify that the pointers to the alloca region are replaced by\n      poisoned values when the frame is popped.  */"}, {"sha": "8b669df00beffbba6848ef7a8961c991b5398908", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -163,6 +163,8 @@ class region_to_value_map\n     m_hash_map.remove (reg);\n   }\n \n+  bool is_empty () const { return m_hash_map.is_empty (); }\n+\n   void dump_to_pp (pretty_printer *pp, bool simple, bool multiline) const;\n   void dump (bool simple) const;\n \n@@ -450,12 +452,16 @@ class call_details\n    a tree of regions, along with their associated values.\n    The representation is graph-like because values can be pointers to\n    regions.\n-   It also stores a constraint_manager, capturing relationships between\n-   the values.  */\n+   It also stores:\n+   - a constraint_manager, capturing relationships between the values, and\n+   - dynamic extents, mapping dynamically-allocated regions to svalues (their\n+   capacities).  */\n \n class region_model\n {\n  public:\n+  typedef region_to_value_map dynamic_extents_t;\n+\n   region_model (region_model_manager *mgr);\n   region_model (const region_model &other);\n   ~region_model ();\n@@ -495,6 +501,8 @@ class region_model\n   bool impl_call_alloca (const call_details &cd);\n   void impl_call_analyzer_describe (const gcall *call,\n \t\t\t\t    region_model_context *ctxt);\n+  void impl_call_analyzer_dump_capacity (const gcall *call,\n+\t\t\t\t\t region_model_context *ctxt);\n   void impl_call_analyzer_eval (const gcall *call,\n \t\t\t\tregion_model_context *ctxt);\n   bool impl_call_builtin_expect (const call_details &cd);\n@@ -606,6 +614,16 @@ class region_model\n   store *get_store () { return &m_store; }\n   const store *get_store () const { return &m_store; }\n \n+  const dynamic_extents_t &\n+  get_dynamic_extents () const\n+  {\n+    return m_dynamic_extents;\n+  }\n+  const svalue *get_dynamic_extents (const region *reg) const;\n+  void set_dynamic_extents (const region *reg,\n+\t\t\t    const svalue *size_in_bytes);\n+  void unset_dynamic_extents (const region *reg);\n+\n   region_model_manager *get_manager () const { return m_mgr; }\n \n   void unbind_region_and_descendents (const region *reg,\n@@ -629,6 +647,8 @@ class region_model\n \n   void loop_replay_fixup (const region_model *dst_state);\n \n+  const svalue *get_capacity (const region *reg) const;\n+\n  private:\n   const region *get_lvalue_1 (path_var pv, region_model_context *ctxt) const;\n   const svalue *get_rvalue_1 (path_var pv, region_model_context *ctxt) const;\n@@ -676,9 +696,6 @@ class region_model\n \n   void on_top_level_param (tree param, region_model_context *ctxt);\n \n-  void record_dynamic_extents (const region *reg,\n-\t\t\t       const svalue *size_in_bytes);\n-\n   bool called_from_main_p () const;\n   const svalue *get_initial_value_for_global (const region *reg) const;\n \n@@ -693,6 +710,12 @@ class region_model\n   constraint_manager *m_constraints; // TODO: embed, rather than dynalloc?\n \n   const frame_region *m_current_frame;\n+\n+  /* Map from base region to size in bytes, for tracking the sizes of\n+     dynamically-allocated regions.\n+     This is part of the region_model rather than the region to allow for\n+     memory regions to be resized (e.g. by realloc).  */\n+  dynamic_extents_t m_dynamic_extents;\n };\n \n /* Some region_model activity could lead to warnings (e.g. attempts to use an"}, {"sha": "2ca4bf61352fd03a399e042ae7f19c8eef7658cb", "filename": "gcc/doc/analyzer.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fdoc%2Fanalyzer.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Fdoc%2Fanalyzer.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fanalyzer.texi?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -479,6 +479,13 @@ __analyzer_dump ();\n will dump the copious information about the analyzer's state each time it\n reaches the call in its traversal of the source.\n \n+@smallexample\n+extern void __analyzer_dump_capacity (const void *ptr);\n+@end smallexample\n+\n+will emit a warning describing the capacity of the base region of\n+the region pointed to by the 1st argument.\n+\n @smallexample\n __analyzer_dump_path ();\n @end smallexample"}, {"sha": "24466939882a5a2e89262fc32287f22c02bc9908", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer-decls.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -15,6 +15,9 @@ extern void __analyzer_describe (int verbosity, ...);\n /* Dump copious information about the analyzer\u2019s state when reached.  */\n extern void __analyzer_dump (void);\n \n+/* Emit a warning describing the size of the base region of (*ptr).  */\n+extern void __analyzer_dump_capacity (const void *ptr);\n+\n /* Dump information after analysis on all of the exploded nodes at this\n    program point.\n "}, {"sha": "9ea41f72e1d286f0bb46bd8cff869e0ede92e094", "filename": "gcc/testsuite/gcc.dg/analyzer/capacity-1.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-1.c?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -0,0 +1,106 @@\n+#include <stdlib.h>\n+#include \"analyzer-decls.h\"\n+\n+typedef unsigned __INT32_TYPE__ u32;\n+\n+void\n+test_1 (void)\n+{\n+  char buf[16];\n+  __analyzer_dump_capacity (buf); /* { dg-warning \"capacity: '\\\\(sizetype\\\\)16'\" } */\n+}\n+\n+void\n+test_2 (void)\n+{\n+  char ch;\n+  __analyzer_dump_capacity (&ch); /* { dg-warning \"capacity: '\\\\(sizetype\\\\)1'\" } */\n+}\n+\n+struct s3 { char buf[100]; };\n+\n+void\n+test_3 (void)\n+{\n+  struct s3 s;\n+  __analyzer_dump_capacity (&s); /* { dg-warning \"capacity: '\\\\(sizetype\\\\)100'\" } */\n+}\n+\n+/* Capacity refers to the base region, not any offset within it.  */\n+\n+void\n+test_4 (void)\n+{\n+  char buf[1024];\n+  __analyzer_dump_capacity (buf + 100); /* { dg-warning \"capacity: '\\\\(sizetype\\\\)1024'\" } */\n+}\n+\n+void\n+test_5 (void *p)\n+{\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" } */\n+}\n+\n+void\n+test_malloc (void)\n+{\n+  void *p = malloc (1024);\n+\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: '\\\\(size_t\\\\)1024'\" } */\n+  free (p);\n+}\n+\n+void\n+test_alloca (size_t sz)\n+{\n+  void *p = alloca (sz);\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'INIT_VAL\\\\(sz_\\[^\\n\\r\\]*\\\\)'\" } */\n+}\n+\n+void\n+test_vla (size_t sz)\n+{\n+  char buf[sz];\n+  __analyzer_dump_capacity (buf);  /* { dg-warning \"capacity: 'INIT_VAL\\\\(sz_\\[^\\n\\r\\]*\\\\)'\" } */\n+}\n+\n+static void * __attribute__((noinline))\n+called_by_test_interproc_malloc (size_t a)\n+{\n+  return malloc (a);\n+}\n+\n+void *\n+test_interproc_malloc (size_t sz)\n+{\n+  void *p = called_by_test_interproc_malloc (sz);\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'INIT_VAL\\\\(sz_\\[^\\n\\r\\]*\\\\)'\" } */\n+  return p;\n+}\n+\n+struct s\n+{\n+  u32 f1;\n+  char arr[];\n+};\n+\n+static struct s * __attribute__((noinline))\n+alloc_s (size_t num)\n+{\n+  struct s *p = malloc (sizeof(struct s) + num);\n+  return p;\n+}\n+\n+struct s *\n+test_trailing_array (void)\n+{\n+  struct s *p = alloc_s (5);\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: '\\\\(\\[^\\n\\r\\]*\\\\)9'\" } */\n+  return p;\n+}\n+\n+void\n+test_unknown_arr (int p[])\n+{\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" } */\n+}"}, {"sha": "9f92bcfc0a4cafe58e1206e6b010338e7febdada", "filename": "gcc/testsuite/gcc.dg/analyzer/capacity-2.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-2.c?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -0,0 +1,53 @@\n+#include <stdlib.h>\n+#include \"analyzer-decls.h\"\n+\n+extern void might_realloc (void *);\n+extern void cant_realloc (const void *);\n+\n+void *\n+test_realloc_1 (void *p, size_t new_sz)\n+{\n+  void *q = realloc (p, new_sz);\n+  __analyzer_dump_capacity (q); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" } */\n+  return q;\n+}\n+\n+void *\n+test_realloc_2 (size_t sz_a, size_t sz_b)\n+{\n+  void *p = malloc (sz_a);\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'INIT_VAL\\\\(sz_a_\\[^\\n\\r\\]*\\\\)'\" } */\n+  void *q = realloc (p, sz_b);\n+  __analyzer_dump_capacity (q); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" } */\n+  return p;  \n+}\n+\n+void *\n+test_might_realloc (void)\n+{\n+  void *p = malloc (1024);\n+\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: '\\\\(size_t\\\\)1024'\" } */\n+\n+  might_realloc (p);\n+\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" } */\n+\n+  return p;\n+}\n+\n+void *\n+test_cant_realloc (void)\n+{\n+  void *p = malloc (1024);\n+\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: '\\\\(size_t\\\\)1024'\" } */\n+\n+  cant_realloc (p);\n+\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: '\\\\(size_t\\\\)1024'\" } */\n+\n+  return p;\n+}\n+\n+"}, {"sha": "41e282cee92deb35b99d450e04c63c3f451800f2", "filename": "gcc/testsuite/gcc.dg/analyzer/capacity-3.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcapacity-3.c?ref=9a2c9579fdbf5d24dfe27fb961286ad7a9c3a98b", "patch": "@@ -0,0 +1,82 @@\n+#include <stdlib.h>\n+#include \"analyzer-decls.h\"\n+\n+static void __attribute__((noinline))\n+__analyzer_callee_1 (size_t inner_sz)\n+{\n+  void *p = alloca (inner_sz);\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'INIT_VAL\\\\(outer_sz_\\[^\\n\\r\\]*\\\\)'\" } */\n+}\n+\n+void\n+test_1 (int flag, size_t outer_sz)\n+{\n+  if (flag)\n+    __analyzer_callee_1 (outer_sz);\n+\n+  /* Verify that we merge state; in particular, the dynamic size of \"p\"\n+     in the called frame should have been purged.  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}\n+\n+void\n+test_2 (int flag, size_t sz)\n+{\n+  if (flag)\n+    {\n+      void *p = malloc (sz);\n+      __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'INIT_VAL\\\\(sz_\\[^\\n\\r\\]*\\\\)'\" } */\n+      free (p);\n+      /* The dynamic size of \"p\" should have been purged.  */\n+      __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" } */\n+    }\n+\n+  /* Verify that we merge state.  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}\n+/* Verify that we purge state on the NULL branch when a malloc result is\n+   tested against NULL.  */\n+\n+void\n+test_3 (size_t sz)\n+{\n+  void *p = malloc (sz);\n+\n+  if (p)\n+    {\n+      __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'INIT_VAL\\\\(sz_\\[^\\n\\r\\]*\\\\)'\" } */\n+    }\n+  else\n+    {\n+      /* The dynamic size of \"p\" should have been purged\n+\t due to \"p\" being equal to NULL.  */\n+      __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" } */\n+    }\n+\n+  free (p);\n+  \n+  /* The dynamic size of \"p\" should have been purged.  */\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'UNKNOWN\\\\(sizetype\\\\)'\" } */\n+\n+    /* Verify that we merge state.  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}\n+\n+/* Verify that we purge dynamic extent of a pointer when it leaks.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_callee_4 (size_t inner_sz)\n+{\n+  void *p = malloc (inner_sz);\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: 'INIT_VAL\\\\(outer_sz_\\[^\\n\\r\\]*\\\\)'\" } */\n+} /* { dg-warning \"leak of 'p'\" } */\n+\n+void\n+test_4 (int flag, size_t outer_sz)\n+{\n+  if (flag)\n+    __analyzer_callee_4 (outer_sz);\n+\n+  /* Verify that we merge state.  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}]}