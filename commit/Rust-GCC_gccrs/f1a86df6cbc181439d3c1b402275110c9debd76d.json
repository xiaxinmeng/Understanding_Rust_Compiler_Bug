{"sha": "f1a86df6cbc181439d3c1b402275110c9debd76d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFhODZkZjZjYmMxODE0MzlkM2MxYjQwMjI3NTExMGM5ZGViZDc2ZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.phys.columbia.edu", "date": "1998-12-07T13:35:20Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1998-12-07T13:35:20Z"}, "message": "cpplib.h (struct cpp_buffer): Replace dir and dlen members with a struct file_name_list pointer.\n\n1998-11-26 01:17 -0500  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n\t* cpplib.h (struct cpp_buffer): Replace dir and dlen members\n\twith a struct file_name_list pointer.\n\t(struct cpp_reader): Add pointer to chain of `actual\n\tdirectory' include searchpath entries.\n\t(struct file_name_list): Add *alloc pointer for the sake of\n\tthe actual-directory chain.\n\tMove definition of HOST_WIDE_INT here.\n\t(cpp_parse_escape): Change prototype to match changes in\n\tcppexp.c.\n\t* cppfiles.c (actual_directory): New function.\n\t(finclude): Use it to initialize the buffer's actual_dir\n\tentry.\n\t(find_include_file): We don't need to fix up max_include_len\n\there.\n\t* cpplib.c (do_include): Don't allocate a file_name_list on\n\tthe fly for current directory \"\" includes, use the one that's\n\tbeen preallocated in pfile->buffer->actual_dir.  Hoist out\n\tduplicate code from the search_start selection logic.\n\t(cpp_reader_init): Initialize pfile->actual_dirs.\n\tRemove definition of HOST_WIDE_INT.  Change calls\n\tto cpp_parse_escape to match changes in cppexp.c (note\n\thardcoded MASK, which is safe since this is the source\n\tcharacter set).\n\t* cppexp.c: Bring over changes to cpp_parse_escape from cccp.c\n\tto handle wide character constants in #if directives.  The\n\tfunction now returns a HOST_WIDE_INT, and takes a third\n\targument which is a binary mask for all legal values (0x00ff\n\tfor 8-bit `char', 0xffff for 16-bit `wchar_t', etc.)  Define\n\tMAX_CHAR_TYPE_MASK and MAX_WCHAR_TYPE_MASK.  Change callers of\n\tcpp_parse_escape to match.  [Fixes c-torture/execute/widechar-1.c]\n\nFrom-SVN: r24153", "tree": {"sha": "8639ccd7c1c382473eaf051751bf1a983dde27b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8639ccd7c1c382473eaf051751bf1a983dde27b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1a86df6cbc181439d3c1b402275110c9debd76d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1a86df6cbc181439d3c1b402275110c9debd76d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1a86df6cbc181439d3c1b402275110c9debd76d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1a86df6cbc181439d3c1b402275110c9debd76d/comments", "author": null, "committer": null, "parents": [{"sha": "93447205e549088d1d5208e82462b5f681030632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93447205e549088d1d5208e82462b5f681030632", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93447205e549088d1d5208e82462b5f681030632"}], "stats": {"total": 315, "additions": 181, "deletions": 134}, "files": [{"sha": "f2f0aaf2bd6d28cc5651072b086d39775d3f45ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a86df6cbc181439d3c1b402275110c9debd76d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a86df6cbc181439d3c1b402275110c9debd76d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1a86df6cbc181439d3c1b402275110c9debd76d", "patch": "@@ -1,3 +1,41 @@\n+1998-11-26 01:17 -0500  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n+\n+\t* cpplib.h (struct cpp_buffer): Replace dir and dlen members\n+\twith a struct file_name_list pointer.\n+\t(struct cpp_reader): Add pointer to chain of `actual\n+\tdirectory' include searchpath entries.\n+\t(struct file_name_list): Add *alloc pointer for the sake of\n+\tthe actual-directory chain.\n+\n+\tMove definition of HOST_WIDE_INT here.\n+\t(cpp_parse_escape): Change prototype to match changes in\n+\tcppexp.c.\n+\n+\t* cppfiles.c (actual_directory): New function.\n+\t(finclude): Use it to initialize the buffer's actual_dir\n+\tentry.\n+\t(find_include_file): We don't need to fix up max_include_len\n+\there.\n+\n+\t* cpplib.c (do_include): Don't allocate a file_name_list on\n+\tthe fly for current directory \"\" includes, use the one that's\n+\tbeen preallocated in pfile->buffer->actual_dir.  Hoist out\n+\tduplicate code from the search_start selection logic.\n+\t(cpp_reader_init): Initialize pfile->actual_dirs.\n+\n+\tRemove definition of HOST_WIDE_INT.  Change calls\n+\tto cpp_parse_escape to match changes in cppexp.c (note\n+\thardcoded MASK, which is safe since this is the source\n+\tcharacter set).\n+\n+\t* cppexp.c: Bring over changes to cpp_parse_escape from cccp.c\n+\tto handle wide character constants in #if directives.  The\n+\tfunction now returns a HOST_WIDE_INT, and takes a third\n+\targument which is a binary mask for all legal values (0x00ff\n+\tfor 8-bit `char', 0xffff for 16-bit `wchar_t', etc.)  Define\n+\tMAX_CHAR_TYPE_MASK and MAX_WCHAR_TYPE_MASK.  Change callers of\n+\tcpp_parse_escape to match.  [Fixes c-torture/execute/widechar-1.c]\n+\n Mon Dec  7 15:38:25 1998  Dave Brolley  <brolley@cygnus.com>\n \n \t* gcc.c (default_compilers): Fix typo in USE_CPPLIB spec for cc1."}, {"sha": "87b84a624fccddab3bf17b80559e24d108e0b5e3", "filename": "gcc/cppexp.c", "status": "modified", "additions": 25, "deletions": 37, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a86df6cbc181439d3c1b402275110c9debd76d/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a86df6cbc181439d3c1b402275110c9debd76d/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=f1a86df6cbc181439d3c1b402275110c9debd76d", "patch": "@@ -72,6 +72,14 @@ struct arglist {\n #define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE\n #endif\n \n+#define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \\\n+\t\t\t    ? (~ (~ (HOST_WIDE_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n+\t\t\t    : ~ (HOST_WIDE_INT) 0)\n+\n+#define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \\\n+\t\t\t     ? ~ (~ (HOST_WIDE_INT) 0 << MAX_WCHAR_TYPE_SIZE) \\\n+\t\t\t     : ~ (HOST_WIDE_INT) 0)\n+\n /* Yield nonzero if adding two numbers with A's and B's signs can yield a\n    number with SUM's sign, where A, B, and SUM are all C integers.  */\n #define possible_sum_sign(a, b, sum) ((((a) ^ (b)) | ~ ((a) ^ (sum))) < 0)\n@@ -101,28 +109,6 @@ static long right_shift PARAMS ((cpp_reader *, long, int, unsigned long));\n #define SKIP_OPERAND 8\n /*#define UNSIGNEDP 16*/\n \n-/* Find the largest host integer type and set its size and type.\n-   Watch out: on some crazy hosts `long' is shorter than `int'.  */\n-\n-#ifndef HOST_WIDE_INT\n-# if HAVE_INTTYPES_H\n-#  include <inttypes.h>\n-#  define HOST_WIDE_INT intmax_t\n-# else\n-#  if (HOST_BITS_PER_LONG <= HOST_BITS_PER_INT \\\n-       && HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_INT)\n-#   define HOST_WIDE_INT int\n-#  else\n-#  if (HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_LONG \\\n-       || ! (defined LONG_LONG_MAX || defined LLONG_MAX))\n-#   define HOST_WIDE_INT long\n-#  else\n-#   define HOST_WIDE_INT long long\n-#  endif\n-#  endif\n-# endif\n-#endif\n-\n #ifndef CHAR_BIT\n #define CHAR_BIT 8\n #endif\n@@ -275,7 +261,7 @@ cpp_lex (pfile, skip_evaluation)\n      cpp_reader *pfile;\n      int skip_evaluation;\n {\n-  register int c;\n+  register HOST_WIDE_INT c;\n   register struct token *toktab;\n   enum cpp_token token;\n   struct operation op;\n@@ -359,7 +345,9 @@ cpp_lex (pfile, skip_evaluation)\n \t  {\n \t    if (c == '\\\\')\n \t      {\n-\t\tc = cpp_parse_escape (pfile, (char **) &ptr);\n+\t\tc = cpp_parse_escape (pfile, (char **) &ptr,\n+\t\t\t\t      wide_flag ? MAX_WCHAR_TYPE_MASK\n+\t\t\t\t      \t\t: MAX_CHAR_TYPE_MASK);\n \t\tif (width < HOST_BITS_PER_INT\n \t\t  && (unsigned) c >= (unsigned)(1 << width))\n \t\t    cpp_pedwarn (pfile,\n@@ -480,10 +468,11 @@ cpp_lex (pfile, skip_evaluation)\n    If \\ is followed by 000, we return 0 and leave the string pointer\n    after the zeros.  A value of 0 does not mean end of string.  */\n \n-int\n-cpp_parse_escape (pfile, string_ptr)\n+HOST_WIDE_INT\n+cpp_parse_escape (pfile, string_ptr, result_mask)\n      cpp_reader *pfile;\n      char **string_ptr;\n+     HOST_WIDE_INT result_mask;\n {\n   register int c = *(*string_ptr)++;\n   switch (c)\n@@ -494,7 +483,7 @@ cpp_parse_escape (pfile, string_ptr)\n       return TARGET_BS;\n     case 'e':\n     case 'E':\n-      if (CPP_PEDANTIC (pfile))\n+      if (CPP_OPTIONS (pfile)->pedantic)\n \tcpp_pedwarn (pfile, \"non-ANSI-standard escape sequence, `\\\\%c'\", c);\n       return 033;\n     case 'f':\n@@ -522,7 +511,7 @@ cpp_parse_escape (pfile, string_ptr)\n     case '6':\n     case '7':\n       {\n-\tregister int i = c - '0';\n+\tregister HOST_WIDE_INT i = c - '0';\n \tregister int count = 0;\n \twhile (++count < 3)\n \t  {\n@@ -535,17 +524,17 @@ cpp_parse_escape (pfile, string_ptr)\n \t\tbreak;\n \t      }\n \t  }\n-\tif ((i & ~((1 << MAX_CHAR_TYPE_SIZE) - 1)) != 0)\n+\tif (i != (i & result_mask))\n \t  {\n-\t    i &= (1 << MAX_CHAR_TYPE_SIZE) - 1;\n-\t    cpp_pedwarn (pfile,\n-\t\t\t  \"octal character constant does not fit in a byte\");\n+\t    i &= result_mask;\n+\t    cpp_pedwarn (pfile, \"octal escape sequence out of range\");\n \t  }\n \treturn i;\n       }\n     case 'x':\n       {\n-\tregister unsigned i = 0, overflow = 0, digits_found = 0, digit;\n+\tregister unsigned HOST_WIDE_INT i = 0, overflow = 0;\n+\tregister int digits_found = 0, digit;\n \tfor (;;)\n \t  {\n \t    c = *(*string_ptr)++;\n@@ -566,11 +555,10 @@ cpp_parse_escape (pfile, string_ptr)\n \t  }\n \tif (!digits_found)\n \t  cpp_error (pfile, \"\\\\x used with no following hex digits\");\n-\tif (overflow | (i & ~((1 << BITS_PER_UNIT) - 1)))\n+\tif (overflow | (i != (i & result_mask)))\n \t  {\n-\t    i &= (1 << BITS_PER_UNIT) - 1;\n-\t    cpp_pedwarn (pfile,\n-\t\t\t \"hex character constant does not fit in a byte\");\n+\t    i &= result_mask;\n+\t    cpp_pedwarn (pfile, \"hex escape sequence out of range\");\n \t  }\n \treturn i;\n       }"}, {"sha": "8c01cddc787ba3c6c7698d4dc440f7d8ebdac433", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 58, "deletions": 31, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a86df6cbc181439d3c1b402275110c9debd76d/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a86df6cbc181439d3c1b402275110c9debd76d/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=f1a86df6cbc181439d3c1b402275110c9debd76d", "patch": "@@ -42,6 +42,7 @@ static char *remap_filename \t\tPROTO ((cpp_reader *, char *,\n \t\t\t\t\t\tstruct file_name_list *));\n static long safe_read\t\t\tPROTO ((int, char *, int));\n static void simplify_pathname\t\tPROTO ((char *));\n+static struct file_name_list *actual_directory PROTO ((cpp_reader *, char *));\n \n #if 0\n static void hack_vms_include_specification PROTO ((char *));\n@@ -422,11 +423,6 @@ find_include_file (pfile, fname, search_start, ihash, before)\n \n   /* Search directory path, trying to open the file. */\n \n-  /* The first entry in the search list may be a buffer-specific entry,\n-     and its directory name may be longer than max_include_len.  Adjust\n-     as appropriate. */\n- if (pfile->max_include_len < search_start->nlen)\n-    pfile->max_include_len = search_start->nlen;\n   len = strlen (fname);\n   name = xmalloc (len + pfile->max_include_len + 2 + INCLUDE_LEN_FUDGE);\n \n@@ -690,34 +686,11 @@ finclude (pfile, fd, ihash)\n   fp->colno = 1;\n   fp->cleanup = file_cleanup;\n \n-  /* The ->dir field is only used when ignore_srcdir is not in effect;\n+  /* The ->actual_dir field is only used when ignore_srcdir is not in effect;\n      see do_include */\n   if (!CPP_OPTIONS (pfile)->ignore_srcdir)\n-    {\n-      char *last_slash;\n-      fp->dir = savestring (fp->fname);\n-      last_slash = rindex (fp->dir, '/');\n-      if (last_slash)\n-        {\n-\t  if (last_slash == fp->dir)\n-\t    {\n-\t      fp->dlen = 1;\n-\t      last_slash[1] = '\\0';\n-\t    }\n-\t  else\n-\t    {\n-\t      fp->dlen = last_slash - fp->dir;\n-\t      *last_slash = '\\0';\n-\t    }\n-\t}\n-      else\n-        {\n-\t  fp->dir[0] = '.';\n-\t  fp->dir[1] = '\\0';\n-\t  fp->dlen = 1;\n-\t}\n-    }\n-\n+    fp->actual_dir = actual_directory (pfile, fp->fname);\n+\t\n   if (S_ISREG (st.st_mode))\n     {\n       st_size = (size_t) st.st_size;\n@@ -790,6 +763,60 @@ finclude (pfile, fd, ihash)\n   return 0;\n }\n \n+static struct file_name_list *\n+actual_directory (pfile, fname)\n+     cpp_reader *pfile;\n+     char *fname;\n+{\n+  char *last_slash, *dir;\n+  size_t dlen;\n+  struct file_name_list *x;\n+  \n+  dir = savestring (fname);\n+  last_slash = rindex (dir, '/');\n+  if (last_slash)\n+    {\n+      if (last_slash == dir)\n+        {\n+\t  dlen = 1;\n+\t  last_slash[1] = '\\0';\n+\t}\n+      else\n+\t{\n+\t  dlen = last_slash - dir;\n+\t  *last_slash = '\\0';\n+\t}\n+    }\n+  else\n+    {\n+      dir[0] = '.';\n+      dir[1] = '\\0';\n+      dlen = 1;\n+    }\n+\n+  if (dlen > pfile->max_include_len)\n+    pfile->max_include_len = dlen;\n+\n+  for (x = pfile->actual_dirs; x; x = x->alloc)\n+    if (!strcmp (x->name, dir))\n+      {\n+\tfree (dir);\n+\treturn x;\n+      }\n+\n+  /* Not found, make a new one. */\n+  x = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n+  x->name = dir;\n+  x->nlen = dlen;\n+  x->next = CPP_OPTIONS (pfile)->quote_include;\n+  x->alloc = pfile->actual_dirs;\n+  x->sysp = 0;\n+  x->name_map = NULL;\n+\n+  pfile->actual_dirs = x;\n+  return x;\n+}\n+\n /* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,\n    retrying if necessary.  If MAX_READ_LEN is defined, read at most\n    that bytes at a time.  Return a negative value if an error occurs,"}, {"sha": "dbdf2f45c08320eaffd5d775ae04b810a3824239", "filename": "gcc/cpplib.c", "status": "modified", "additions": 30, "deletions": 63, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a86df6cbc181439d3c1b402275110c9debd76d/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a86df6cbc181439d3c1b402275110c9debd76d/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=f1a86df6cbc181439d3c1b402275110c9debd76d", "patch": "@@ -50,27 +50,6 @@ extern char *update_path PARAMS ((char *, char *));\n #define MIN(X,Y) ((X) < (Y) ? (X) : (Y))\n #define MAX(X,Y) ((X) > (Y) ? (X) : (Y))\n \n-/* Find the largest host integer type and set its size and type.\n-   Watch out: on some crazy hosts `long' is shorter than `int'.  */\n-\n-#ifndef HOST_WIDE_INT\n-# if HAVE_INTTYPES_H\n-#  include <inttypes.h>\n-#  define HOST_WIDE_INT intmax_t\n-# else\n-#  if (HOST_BITS_PER_LONG <= HOST_BITS_PER_INT \\\n-       && HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_INT)\n-#   define HOST_WIDE_INT int\n-#  else\n-#  if (HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_LONG \\\n-       || ! (defined LONG_LONG_MAX || defined LLONG_MAX))\n-#   define HOST_WIDE_INT long\n-#  else\n-#   define HOST_WIDE_INT long long\n-#  endif\n-#  endif\n-# endif\n-#endif\n \n /* By default, colon separates directories in a path.  */\n #ifndef PATH_SEPARATOR\n@@ -2932,7 +2911,7 @@ do_include (pfile, keyword, unused1, unused2)\n   int before;  /* included before? */\n   long flen;\n   char *fbeg, *fend;\n-  struct file_name_list *srcdir = 0;  /* for \"\" includes */\n+  cpp_buffer *fp;\n \n   enum cpp_token token;\n \n@@ -3015,48 +2994,39 @@ do_include (pfile, keyword, unused1, unused2)\n       cpp_error (pfile, \"empty file name in `#%s'\", keyword->name);\n       return 0;\n     }\n+\n+  search_start = 0;\n+\n+  for (fp = CPP_BUFFER (pfile);\n+       fp != CPP_NULL_BUFFER (pfile);\n+       fp = CPP_PREV_BUFFER (fp))\n+    if (fp->fname != NULL)\n+      break;\n+\n+  if (fp == CPP_NULL_BUFFER (pfile))\n+    fp = NULL;\n   \n   /* For #include_next, skip in the search path\n      past the dir in which the containing file was found.  */\n   if (skip_dirs)\n     {\n-      cpp_buffer *fp = CPP_BUFFER (pfile);\n-      for (; fp != CPP_NULL_BUFFER (pfile); fp = CPP_PREV_BUFFER (fp))\n-\tif (fp->fname != NULL)\n-\t  {\n-\t    /* Don't skip anything if the containing file was found\n-\t       by an absolute path. */\n-\t    if (fp->ihash->foundhere == ABSOLUTE_PATH)\n-\t      search_start = angle_brackets\n-\t\t  ? CPP_OPTIONS (pfile)->bracket_include\n-\t\t  : CPP_OPTIONS (pfile)->quote_include;\n-\t    else\n-\t      search_start = fp->ihash->foundhere->next;\n-\t    break;\n-\t  }\n+      if (fp)\n+\tsearch_start = fp->ihash->foundhere->next;\n     }\n   else\n-    search_start = angle_brackets\n-\t? CPP_OPTIONS (pfile)->bracket_include\n-\t: CPP_OPTIONS (pfile)->quote_include;\n-\n-  /* For \"\" includes when ignore_srcdir is off, tack the actual directory\n-     of the current file onto the beginning of the search path.\n-     The block must be permanently allocated since it may wind up\n-     in the include hash. */\n-  if (!angle_brackets \n-      && search_start == CPP_OPTIONS (pfile)->quote_include\n-      && !CPP_OPTIONS (pfile)->ignore_srcdir)\n     {\n-      srcdir = (struct file_name_list *)\n-\t  xmalloc (sizeof (struct file_name_list));\n-      srcdir->next = CPP_OPTIONS (pfile)->quote_include;\n-      srcdir->name = CPP_BUFFER (pfile)->dir;\n-      srcdir->nlen = CPP_BUFFER (pfile)->dlen;\n-      srcdir->sysp = 0;\n-      srcdir->name_map = NULL;\n-\n-      search_start = srcdir;\n+      if (angle_brackets)\n+\tsearch_start = CPP_OPTIONS (pfile)->bracket_include;\n+      else\n+        {\n+\t  if (!CPP_OPTIONS (pfile)->ignore_srcdir)\n+\t    {\n+\t      if (fp)\n+\t\tsearch_start = fp->actual_dir;\n+\t    }\n+\t  else\n+\t    search_start = CPP_OPTIONS (pfile)->quote_include;\n+\t}\n     }\n \n   if (!search_start)\n@@ -3067,10 +3037,6 @@ do_include (pfile, keyword, unused1, unused2)\n \n   fd = find_include_file (pfile, fbeg, search_start, &ihash, &before);\n \n-  if (srcdir\n-      && (ihash == (struct include_hash *)-1 || srcdir != ihash->foundhere))\n-    free (srcdir);\n-  \n   if (fd == -2)\n     return 0;\n   \n@@ -3128,8 +3094,8 @@ do_include (pfile, keyword, unused1, unused2)\n   /* Handle -H option.  */\n   if (CPP_OPTIONS(pfile)->print_include_names)\n     {\n-      cpp_buffer *buf = CPP_BUFFER (pfile);\n-      while ((buf = CPP_PREV_BUFFER (buf)) != CPP_NULL_BUFFER (pfile))\n+      fp = CPP_BUFFER (pfile);\n+      while ((fp = CPP_PREV_BUFFER (fp)) != CPP_NULL_BUFFER (pfile))\n \tputc ('.', stderr);\n       fprintf (stderr, \" %s\\n\", ihash->name);\n     }\n@@ -3282,7 +3248,7 @@ convert_string (pfile, result, in, limit, handle_escapes)\n \t  if (handle_escapes)\n \t    {\n \t      char *bpc = (char *) in;\n-\t      int i = (U_CHAR) cpp_parse_escape (pfile, &bpc);\n+\t      int i = (U_CHAR) cpp_parse_escape (pfile, &bpc, 0x00ffU);\n \t      in = (U_CHAR *) bpc;\n \t      if (i >= 0)\n \t\t*result++ = (U_CHAR)c;\n@@ -5380,6 +5346,7 @@ cpp_reader_init (pfile)\n   pfile->timebuf = NULL;\n   pfile->only_seen_white = 1;\n   pfile->buffer = CPP_NULL_BUFFER(pfile);\n+  pfile->actual_dirs = NULL;\n }\n \n static struct cpp_pending *"}, {"sha": "3cb275327ded9da86db515f2b65e3700114a6f59", "filename": "gcc/cpplib.h", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a86df6cbc181439d3c1b402275110c9debd76d/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a86df6cbc181439d3c1b402275110c9debd76d/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=f1a86df6cbc181439d3c1b402275110c9debd76d", "patch": "@@ -110,8 +110,7 @@ struct cpp_buffer {\n   /* Filename specified with #line command.  */\n   char *nominal_fname;\n   /* Actual directory of this file, used only for \"\" includes */\n-  char *dir;\n-  size_t dlen;\n+  struct file_name_list *actual_dir;\n \n   /* Pointer into the include hash table.  Used for include_next and\n      to record control macros.\n@@ -182,6 +181,10 @@ struct cpp_reader {\n #define ALL_INCLUDE_HASHSIZE 71\n   struct include_hash *all_include_files[ALL_INCLUDE_HASHSIZE];\n \n+  /* Chain of `actual directory' file_name_list entries,\n+     for \"\" inclusion. */\n+  struct file_name_list *actual_dirs;\n+\n   /* Current maximum length of directory names in the search path\n      for include files.  (Altered as we get more of them.)  */\n   unsigned int max_include_len;\n@@ -485,6 +488,8 @@ struct cpp_options {\n struct file_name_list\n {\n   struct file_name_list *next;\n+  struct file_name_list *alloc; /* for the cache of\n+\t\t\t\t   current directory entries */\n   char *name;\n   unsigned int nlen;\n   /* We use these to tell if the directory mentioned here is a duplicate\n@@ -656,6 +661,28 @@ struct if_stack {\n };\n typedef struct if_stack IF_STACK_FRAME;\n \n+/* Find the largest host integer type and set its size and type.\n+   Watch out: on some crazy hosts `long' is shorter than `int'.  */\n+\n+#ifndef HOST_WIDE_INT\n+# if HAVE_INTTYPES_H\n+#  include <inttypes.h>\n+#  define HOST_WIDE_INT intmax_t\n+# else\n+#  if (HOST_BITS_PER_LONG <= HOST_BITS_PER_INT \\\n+       && HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_INT)\n+#   define HOST_WIDE_INT int\n+#  else\n+#  if (HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_LONG \\\n+       || ! (defined LONG_LONG_MAX || defined LLONG_MAX))\n+#   define HOST_WIDE_INT long\n+#  else\n+#   define HOST_WIDE_INT long long\n+#  endif\n+#  endif\n+# endif\n+#endif\n+\n extern void cpp_buf_line_and_col PARAMS((cpp_buffer *, long *, long *));\n extern cpp_buffer* cpp_file_buffer PARAMS((cpp_reader *));\n extern void cpp_define PARAMS ((cpp_reader*, unsigned char *));\n@@ -678,7 +705,7 @@ extern void cpp_perror_with_name PROTO ((cpp_reader *, const char *));\n extern void v_cpp_message PROTO ((cpp_reader *, int, const char *, va_list));\n \n extern void cpp_grow_buffer PARAMS ((cpp_reader *, long));\n-extern int cpp_parse_escape PARAMS ((cpp_reader *, char **));\n+extern HOST_WIDE_INT cpp_parse_escape PARAMS ((cpp_reader *, char **, HOST_WIDE_INT));\n extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n \t\t\t\t\t    unsigned char *, long));\n extern cpp_buffer *cpp_pop_buffer PARAMS ((cpp_reader *));"}]}