{"sha": "4adfcea0a1b0c6dcaefddca3d5f45dd5403b1a80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFkZmNlYTBhMWIwYzZkY2FlZmRkY2EzZDVmNDVkZDU0MDNiMWE4MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-24T09:44:32Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-24T09:44:32Z"}, "message": "middle-end: Prefer no RMW in __builtin_clear_padding implementation where possible\n\nCurrently the __builtin_clear_padding expansion code emits no code for\nfull words that don't have any padding bits, and most of the time if\nthe only padding bytes are from the start of the word it attempts to merge\nthem with previous padding store (via {}) or if the only padding bytes are\nfrom the end of the word, it attempts to merge it with following padding\nbytes.  For everything else it was using a RMW, except when it found\nan aligned char/short/int covering all the padding bytes and all those\npadding bytes were all ones in that store.\n\nThe following patch changes it, such that we only use RMW if the padding has\nany bytes which have some padding and some non-padding bits (i.e. bitfields\nare involved), often it is the same amount of instructions in the end and\navoids being thread-unsafe unless necessary (and avoids having to wait for\nthe reads to make it into the CPU).  So, if there are no bitfields,\nthe function will just store some zero bytes, shorts, ints, long longs etc.\nwhere needed.\n\n2020-11-24  Jakub Jelinek  <jakub@redhat.com>\n\n\t* gimple-fold.c (clear_padding_flush): If a word contains only 0\n\tor 0xff bytes of padding other than all set, all clear, all set\n\tfollowed by all clear or all clear followed by all set, don't emit\n\ta RMW operation on the whole word or parts of it, but instead\n\tclear the individual bytes of padding.  For paddings of one byte\n\tsize, don't use char[1] and {}, but instead just char and 0.", "tree": {"sha": "a74f5bfb28e51da8128aacd76ee1476a68f9944d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a74f5bfb28e51da8128aacd76ee1476a68f9944d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4adfcea0a1b0c6dcaefddca3d5f45dd5403b1a80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4adfcea0a1b0c6dcaefddca3d5f45dd5403b1a80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4adfcea0a1b0c6dcaefddca3d5f45dd5403b1a80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4adfcea0a1b0c6dcaefddca3d5f45dd5403b1a80/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a40d5772ff12a3a4f4830b7db27bedf54b617e8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a40d5772ff12a3a4f4830b7db27bedf54b617e8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a40d5772ff12a3a4f4830b7db27bedf54b617e8e"}], "stats": {"total": 88, "additions": 81, "deletions": 7}, "files": [{"sha": "905c0a057cb821fd92d31f5785ffcb3e29573080", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 81, "deletions": 7, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4adfcea0a1b0c6dcaefddca3d5f45dd5403b1a80/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4adfcea0a1b0c6dcaefddca3d5f45dd5403b1a80/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=4adfcea0a1b0c6dcaefddca3d5f45dd5403b1a80", "patch": "@@ -4033,7 +4033,9 @@ clear_padding_flush (clear_padding_struct *buf, bool full)\n     {\n       size_t nonzero_first = wordsize;\n       size_t nonzero_last = 0;\n-      bool all_ones = true;\n+      size_t zero_first = wordsize;\n+      size_t zero_last = 0;\n+      bool all_ones = true, bytes_only = true;\n       if ((unsigned HOST_WIDE_INT) (buf->off + i + wordsize)\n \t  > (unsigned HOST_WIDE_INT) buf->sz)\n \t{\n@@ -4055,9 +4057,19 @@ clear_padding_flush (clear_padding_struct *buf, bool full)\n \t\tall_ones = false;\n \t      nonzero_last = j + 1 - i;\n \t    }\n+\t  else\n+\t    {\n+\t      if (zero_first == wordsize)\n+\t\tzero_first = j - i;\n+\t      zero_last = j + 1 - i;\n+\t    }\n \t  if (buf->buf[j] != 0 && buf->buf[j] != (unsigned char) ~0)\n-\t    all_ones = false;\n+\t    {\n+\t      all_ones = false;\n+\t      bytes_only = false;\n+\t    }\n \t}\n+      size_t padding_end = i;\n       if (padding_bytes)\n \t{\n \t  if (nonzero_first == 0\n@@ -4069,20 +4081,34 @@ clear_padding_flush (clear_padding_struct *buf, bool full)\n \t      padding_bytes += wordsize;\n \t      continue;\n \t    }\n-\t  size_t padding_end = i;\n \t  if (all_ones && nonzero_first == 0)\n \t    {\n \t      padding_bytes += nonzero_last;\n \t      padding_end += nonzero_last;\n \t      nonzero_first = wordsize;\n \t      nonzero_last = 0;\n \t    }\n-\t  tree atype = build_array_type_nelts (char_type_node, padding_bytes);\n+\t  else if (bytes_only && nonzero_first == 0)\n+\t    {\n+\t      gcc_assert (zero_first && zero_first != wordsize);\n+\t      padding_bytes += zero_first;\n+\t      padding_end += zero_first;\n+\t    }\n+\t  tree atype, src;\n+\t  if (padding_bytes == 1)\n+\t    {\n+\t      atype = char_type_node;\n+\t      src = build_zero_cst (char_type_node);\n+\t    }\n+\t  else\n+\t    {\n+\t      atype = build_array_type_nelts (char_type_node, padding_bytes);\n+\t      src = build_constructor (atype, NULL);\n+\t    }\n \t  tree dst = build2_loc (buf->loc, MEM_REF, atype, buf->base,\n \t\t\t\t build_int_cst (buf->alias_type,\n \t\t\t\t\t\tbuf->off + padding_end\n \t\t\t\t\t\t- padding_bytes));\n-\t  tree src = build_constructor (atype, NULL);\n \t  gimple *g = gimple_build_assign (dst, src);\n \t  gimple_set_location (g, buf->loc);\n \t  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n@@ -4099,6 +4125,45 @@ clear_padding_flush (clear_padding_struct *buf, bool full)\n \t  padding_bytes = nonzero_last - nonzero_first;\n \t  continue;\n \t}\n+      if (bytes_only)\n+\t{\n+\t  /* If bitfields aren't involved in this word, prefer storing\n+\t     individual bytes or groups of them over performing a RMW\n+\t     operation on the whole word.  */\n+\t  gcc_assert (i + zero_last <= end);\n+\t  for (size_t j = padding_end; j < i + zero_last; j++)\n+\t    {\n+\t      if (buf->buf[j])\n+\t\t{\n+\t\t  size_t k;\n+\t\t  for (k = j; k < i + zero_last; k++)\n+\t\t    if (buf->buf[k] == 0)\n+\t\t      break;\n+\t\t  HOST_WIDE_INT off = buf->off + j;\n+\t\t  tree atype, src;\n+\t\t  if (k - j == 1)\n+\t\t    {\n+\t\t      atype = char_type_node;\n+\t\t      src = build_zero_cst (char_type_node);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      atype = build_array_type_nelts (char_type_node, k - j);\n+\t\t      src = build_constructor (atype, NULL);\n+\t\t    }\n+\t\t  tree dst = build2_loc (buf->loc, MEM_REF, atype,\n+\t\t\t\t\t buf->base,\n+\t\t\t\t\t build_int_cst (buf->alias_type, off));\n+\t\t  gimple *g = gimple_build_assign (dst, src);\n+\t\t  gimple_set_location (g, buf->loc);\n+\t\t  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);\n+\t\t  j = k;\n+\t\t}\n+\t    }\n+\t  if (nonzero_last == wordsize)\n+\t    padding_bytes = nonzero_last - zero_last;\n+\t  continue;\n+\t}\n       for (size_t eltsz = 1; eltsz <= wordsize; eltsz <<= 1)\n \t{\n \t  if (nonzero_last - nonzero_first <= eltsz\n@@ -4153,12 +4218,21 @@ clear_padding_flush (clear_padding_struct *buf, bool full)\n     {\n       if (padding_bytes)\n \t{\n-\t  tree atype = build_array_type_nelts (char_type_node, padding_bytes);\n+\t  tree atype, src;\n+\t  if (padding_bytes == 1)\n+\t    {\n+\t      atype = char_type_node;\n+\t      src = build_zero_cst (char_type_node);\n+\t    }\n+\t  else\n+\t    {\n+\t      atype = build_array_type_nelts (char_type_node, padding_bytes);\n+\t      src = build_constructor (atype, NULL);\n+\t    }\n \t  tree dst = build2_loc (buf->loc, MEM_REF, atype, buf->base,\n \t\t\t\t build_int_cst (buf->alias_type,\n \t\t\t\t\t\tbuf->off + end\n \t\t\t\t\t\t- padding_bytes));\n-\t  tree src = build_constructor (atype, NULL);\n \t  gimple *g = gimple_build_assign (dst, src);\n \t  gimple_set_location (g, buf->loc);\n \t  gsi_insert_before (buf->gsi, g, GSI_SAME_STMT);"}]}