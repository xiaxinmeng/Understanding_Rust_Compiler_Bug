{"sha": "4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNhODJmYzlmODZmYzExODdlZTExMmUzYTYzN2NiM2NhNWQyZWYyYQ==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2019-02-25T17:57:01Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2019-02-25T17:57:01Z"}, "message": "AArch64: Fix command line options canonicalization version #2. (PR target/88530)\n\nCommandline options on AArch64 don't get canonicalized into the smallest\npossible set before output to the assembler. This means that overlapping feature\nsets are emitted with superfluous parts.\n\nNormally this isn't an issue, but in the case of crypto we have retro-actively\nsplit it into aes and sha2. We need to emit only +crypto to the assembler\nso old assemblers continue to work.\n\nBecause of how -mcpu=native and -march=native work they end up enabling all\nfeature bits. Instead we need to get the smallest possible set, which would also\nfix the problem with older the assemblers and the retro-active split.\n\nThe function that handles this is called quite often.  It is called for any\npush/pop options or attribute that changes arch, cpu etc.  In order to not make\nthis search for the smallest set too expensive we sort the options based on the\nnumber of features (bits) they enable.  This allows us to process the list\nlinearly instead of quadratically (Once we have enabled a feature, we know that\nanything else that enables it can be ignored.  By sorting we'll get the biggest\ngroups first and thus the smallest combination of commandline flags).\n\nThe Option handling structures have been extended to have a boolean to indicate\nwhether the option is synthetic, with that I mean if the option flag itself\nenables a new feature.\n\ne.g. +crypto isn't an actual feature, it just enables other features, but others\nlike +rdma enable multiple dependent features but is itself also a feature.\n\nThere are two ways to solve this.\n\n1) Either have the options that are feature bits also turn themselves on, e.g.\n   change rdma to turn on FP, SIMD and RDMA as dependency bits.\n\n2) Make a distinction between these two different type of features and have the\n   framework handle it correctly.\n\nEven though it's more code I went for the second approach, as it's the one\nthat'll be less fragile (people can't forget it) and gives the least surprises.\n\nEffectively this patch changes the following:\n\nThe values before the => are the old compiler and after the => the new code.\n\n-march=armv8.2-a+crypto+sha2 => -march=armv8.2-a+crypto\n-march=armv8.2-a+sha2+aes => -march=armv8.2-a+crypto\n\nThe remaining behaviors stay the same.\n\ngcc/ChangeLog:\n\n\tPR target/88530\n\t* common/config/aarch64/aarch64-common.c\n\t(struct aarch64_option_extension): Add is_synthetic.\n\t(all_extensions): Use it.\n\t(TARGET_OPTION_INIT_STRUCT): Define hook.\n\t(struct gcc_targetm_common): Moved to end.\n\t(all_extensions_by_on): New.\n\t(opt_ext_cmp, typedef opt_ext): New.\n\t(aarch64_option_init_struct): New.\n\t(aarch64_contains_opt): New.\n\t(aarch64_get_extension_string_for_isa_flags): Output smallest set.\n\t* config/aarch64/aarch64-option-extensions.def\n\t(AARCH64_OPT_EXTENSION): Explicitly include AES and SHA2 in crypto.\n\t(fp, simd, crc, lse, fp16, rcpc, rdma, dotprod, aes, sha2, sha3,\n\tsm4, fp16fml, sve, profile, rng, memtag, sb, ssbs, predres):\n\tSet is_synthetic to false.\n\t(crypto): Set is_synthetic to true.\n\t* config/aarch64/driver-aarch64.c (AARCH64_OPT_EXTENSION): Add\n\tSYNTHETIC.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/88530\n\t* gcc.target/aarch64/options_set_1.c: New test.\n\t* gcc.target/aarch64/options_set_2.c: New test.\n\t* gcc.target/aarch64/options_set_3.c: New test.\n\t* gcc.target/aarch64/options_set_4.c: New test.\n\t* gcc.target/aarch64/options_set_5.c: New test.\n\t* gcc.target/aarch64/options_set_6.c: New test.\n\t* gcc.target/aarch64/options_set_7.c: New test.\n\t* gcc.target/aarch64/options_set_8.c: New test.\n\t* gcc.target/aarch64/options_set_9.c: New test.\n\nFrom-SVN: r269193", "tree": {"sha": "c3d2f00a2efc08a8e1816d941283ed33a2dff10b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3d2f00a2efc08a8e1816d941283ed33a2dff10b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99cf78cf2e2c84bf60f8eeba1403465fb414691e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99cf78cf2e2c84bf60f8eeba1403465fb414691e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99cf78cf2e2c84bf60f8eeba1403465fb414691e"}], "stats": {"total": 441, "additions": 379, "deletions": 62}, "files": [{"sha": "997c3307284064c2b09c110556f3eeaf07072df4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -1,3 +1,25 @@\n+2019-02-25  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/88530\n+\t* common/config/aarch64/aarch64-common.c\n+\t(struct aarch64_option_extension): Add is_synthetic.\n+\t(all_extensions): Use it.\n+\t(TARGET_OPTION_INIT_STRUCT): Define hook.\n+\t(struct gcc_targetm_common): Moved to end.\n+\t(all_extensions_by_on): New.\n+\t(opt_ext_cmp, typedef opt_ext): New.\n+\t(aarch64_option_init_struct): New.\n+\t(aarch64_contains_opt): New.\n+\t(aarch64_get_extension_string_for_isa_flags): Output smallest set.\n+\t* config/aarch64/aarch64-option-extensions.def\n+\t(AARCH64_OPT_EXTENSION): Explicitly include AES and SHA2 in crypto.\n+\t(fp, simd, crc, lse, fp16, rcpc, rdma, dotprod, aes, sha2, sha3,\n+\tsm4, fp16fml, sve, profile, rng, memtag, sb, ssbs, predres):\n+\tSet is_synthetic to false.\n+\t(crypto): Set is_synthetic to true.\n+\t* config/aarch64/driver-aarch64.c (AARCH64_OPT_EXTENSION): Add\n+\tSYNTHETIC.\n+\n 2019-02-25  Tamar Christina  <tamar.christina@arm.com>\n \n \t* config/arm/arm_neon.h (vfmlal_low_u32, vfmlsl_low_u32,"}, {"sha": "5329471dc574b745c50c5a9b1000e749157b87f4", "filename": "gcc/common/config/aarch64/aarch64-common.c", "status": "modified", "additions": 178, "deletions": 22, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -46,6 +46,8 @@\n #define TARGET_OPTION_DEFAULT_PARAMS aarch64_option_default_params\n #undef TARGET_OPTION_VALIDATE_PARAM\n #define TARGET_OPTION_VALIDATE_PARAM aarch64_option_validate_param\n+#undef TARGET_OPTION_INIT_STRUCT\n+#define TARGET_OPTION_INIT_STRUCT aarch64_option_init_struct\n \n /* Set default optimization options.  */\n static const struct default_options aarch_option_optimization_table[] =\n@@ -164,24 +166,35 @@ aarch64_handle_option (struct gcc_options *opts,\n     }\n }\n \n-struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;\n-\n /* An ISA extension in the co-processor and main instruction set space.  */\n struct aarch64_option_extension\n {\n   const char *const name;\n   const unsigned long flag_canonical;\n   const unsigned long flags_on;\n   const unsigned long flags_off;\n+  const bool is_synthetic;\n };\n \n /* ISA extensions in AArch64.  */\n static const struct aarch64_option_extension all_extensions[] =\n {\n-#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, Z) \\\n-  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF},\n+#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \\\n+\t\t\t      SYNTHETIC, Z) \\\n+  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, SYNTHETIC},\n+#include \"config/aarch64/aarch64-option-extensions.def\"\n+  {NULL, 0, 0, 0, false}\n+};\n+\n+/* A copy of the ISA extensions list for AArch64 sorted by the popcount of\n+   bits and extension turned on.  Cached for efficiency.  */\n+static struct aarch64_option_extension all_extensions_by_on[] =\n+{\n+#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \\\n+\t\t\t      SYNTHETIC, Z) \\\n+  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, SYNTHETIC},\n #include \"config/aarch64/aarch64-option-extensions.def\"\n-  {NULL, 0, 0, 0}\n+  {NULL, 0, 0, 0, false}\n };\n \n struct processor_name_to_arch\n@@ -298,6 +311,76 @@ aarch64_get_all_extension_candidates (auto_vec<const char *> *candidates)\n     candidates->safe_push (opt->name);\n }\n \n+/* Comparer to sort aarch64's feature extensions by population count. Largest\n+   first.  */\n+\n+typedef const struct aarch64_option_extension opt_ext;\n+\n+int opt_ext_cmp (const void* a, const void* b)\n+{\n+  opt_ext *opt_a = (opt_ext *)a;\n+  opt_ext *opt_b = (opt_ext *)b;\n+\n+  /* We consider the total set of bits an options turns on to be the union of\n+     the singleton set containing the option itself and the set of options it\n+     turns on as a dependency.  As an example +dotprod turns on FL_DOTPROD and\n+     FL_SIMD.  As such the set of bits represented by this option is\n+     {FL_DOTPROD, FL_SIMD}. */\n+  unsigned long total_flags_a = opt_a->flag_canonical & opt_a->flags_on;\n+  unsigned long total_flags_b = opt_b->flag_canonical & opt_b->flags_on;\n+  int popcnt_a = popcount_hwi ((HOST_WIDE_INT)total_flags_a);\n+  int popcnt_b = popcount_hwi ((HOST_WIDE_INT)total_flags_b);\n+  int order = popcnt_b - popcnt_a;\n+\n+  /* If they have the same amount of bits set, give it a more\n+     deterministic ordering by using the value of the bits themselves.  */\n+  if (order == 0)\n+    return total_flags_b - total_flags_a;\n+\n+  return order;\n+}\n+\n+/* Implement TARGET_OPTION_INIT_STRUCT.  */\n+\n+static void\n+aarch64_option_init_struct (struct gcc_options *opts ATTRIBUTE_UNUSED)\n+{\n+    /* Sort the extensions based on how many bits they set, order the larger\n+       counts first.  We sort the list because this makes processing the\n+       feature bits O(n) instead of O(n^2).  While n is small, the function\n+       to calculate the feature strings is called on every options push,\n+       pop and attribute change (arm_neon headers, lto etc all cause this to\n+       happen quite frequently).  It is a trade-off between time and space and\n+       so time won.  */\n+    int n_extensions\n+      = sizeof (all_extensions) / sizeof (struct aarch64_option_extension);\n+    qsort (&all_extensions_by_on, n_extensions,\n+\t   sizeof (struct aarch64_option_extension), opt_ext_cmp);\n+}\n+\n+/* Checks to see if enough bits from the option OPT are enabled in\n+   ISA_FLAG_BITS to be able to replace the individual options with the\n+   canonicalized version of the option.  This is done based on two rules:\n+\n+   1) Synthetic groups, such as +crypto we only care about the bits that are\n+      turned on. e.g. +aes+sha2 can be replaced with +crypto.\n+\n+   2) Options that themselves have a bit, such as +rdma, in this case, all the\n+      feature bits they turn on must be available and the bit for the option\n+      itself must be.  In this case it's effectively a reduction rather than a\n+      grouping. e.g. +fp+simd is not enough to turn on +rdma, for that you would\n+      need +rdma+fp+simd which is reduced down to +rdma.\n+*/\n+\n+static bool\n+aarch64_contains_opt (unsigned long isa_flag_bits, opt_ext *opt)\n+{\n+  unsigned long flags_check\n+    = opt->is_synthetic ? opt->flags_on : opt->flag_canonical;\n+\n+  return (isa_flag_bits & flags_check) == flags_check;\n+}\n+\n /* Return a string representation of ISA_FLAGS.  DEFAULT_ARCH_FLAGS\n    gives the default set of flags which are implied by whatever -march\n    we'd put out.  Our job is to figure out the minimal set of \"+\" and\n@@ -311,26 +394,97 @@ aarch64_get_extension_string_for_isa_flags (unsigned long isa_flags,\n   const struct aarch64_option_extension *opt = NULL;\n   std::string outstr = \"\";\n \n-  /* Pass one: Find all the things we need to turn on.  As a special case,\n-     we always want to put out +crc if it is enabled.  */\n-  for (opt = all_extensions; opt->name != NULL; opt++)\n-    if ((isa_flags & opt->flag_canonical\n-\t && !(default_arch_flags & opt->flag_canonical))\n-\t|| (default_arch_flags & opt->flag_canonical\n-            && opt->flag_canonical == AARCH64_ISA_CRC))\n-      {\n-\toutstr += \"+\";\n-\toutstr += opt->name;\n-      }\n+  unsigned long isa_flag_bits = isa_flags;\n \n-  /* Pass two: Find all the things we need to turn off.  */\n-  for (opt = all_extensions; opt->name != NULL; opt++)\n-    if ((~isa_flags) & opt->flag_canonical\n-\t&& !((~default_arch_flags) & opt->flag_canonical))\n+  /* Pass one: Minimize the search space by reducing the set of options\n+     to the smallest set that still turns on the same features as before in\n+     conjunction with the bits that are turned on by default for the selected\n+     architecture.  */\n+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)\n+    {\n+      /* If the bit is on by default, then all the options it turns on are also\n+\t on by default due to the transitive dependencies.\n+\n+         If the option is enabled explicitly in the set then we need to emit\n+\t an option for it.  Since this list is sorted by extensions setting the\n+\t largest number of featers first, we can be sure that nothing else will\n+\t ever need to set the bits we already set.  Consider the following\n+\t situation:\n+\n+\t  Feat1 = A + B + C\n+\t  Feat2 = A + B\n+\t  Feat3 = A + D\n+\t  Feat4 = B + C\n+\t  Feat5 = C\n+\n+\tThe following results are expected:\n+\n+\t  A + C = A + Feat5\n+\t  B + C = Feat4\n+\t  Feat4 + A = Feat1\n+\t  Feat2 + Feat5 = Feat1\n+\t  Feat1 + C = Feat1\n+          Feat3 + Feat4 = Feat1 + D\n+\n+\tThis search assumes that all invidual feature bits are use visible,\n+\tin other words the user must be able to do +A, +B, +C and +D.  */\n+      if (aarch64_contains_opt (isa_flag_bits | default_arch_flags, opt))\n       {\n-\toutstr += \"+no\";\n-\toutstr += opt->name;\n+\t/* We remove all the dependent bits, to prevent them from being turned\n+\t   on twice.  This only works because we assume that all there are\n+\t   individual options to set all bits standalone.  */\n+\tisa_flag_bits &= ~opt->flags_on;\n+\tisa_flag_bits |= opt->flag_canonical;\n       }\n+    }\n+\n+   /* By toggling bits on and off, we may have set bits on that are already\n+      enabled by default.  So we mask the default set out so we don't emit an\n+      option for them.  Instead of checking for this each time during Pass One\n+      we just mask all default bits away at the end.  */\n+   isa_flag_bits &= ~default_arch_flags;\n+\n+   /* We now have the smallest set of features we need to process.  A subsequent\n+      linear scan of the bits in isa_flag_bits will allow us to print the ext\n+      names.  However as a special case if CRC was enabled before, always print\n+      it.  This is required because some CPUs have an incorrect specification\n+      in older assemblers.  Even though CRC should be the default for these\n+      cases the -mcpu values won't turn it on.  */\n+  if (isa_flags & AARCH64_ISA_CRC)\n+    isa_flag_bits |= AARCH64_ISA_CRC;\n+\n+  /* Pass Two:\n+     Print the option names that we're sure we must turn on.  These are only\n+     optional extension names.  Mandatory ones have already been removed and\n+     ones we explicitly want off have been too.  */\n+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)\n+    {\n+      if (isa_flag_bits & opt->flag_canonical)\n+\t{\n+\t  outstr += \"+\";\n+\t  outstr += opt->name;\n+\t}\n+    }\n+\n+  /* Pass Three:\n+     Print out a +no for any mandatory extension that we are\n+     turning off.  By this point aarch64_parse_extension would have ensured\n+     that any optional extensions are turned off.  The only things left are\n+     things that can't be turned off usually, e.g. something that is on by\n+     default because it's mandatory and we want it off.  For turning off bits\n+     we don't guarantee the smallest set of flags, but instead just emit all\n+     options the user has specified.\n+\n+     The assembler requires all +<opts> to be printed before +no<opts>.  */\n+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)\n+    {\n+      if ((~isa_flags) & opt->flag_canonical\n+\t\t&& !((~default_arch_flags) & opt->flag_canonical))\n+\t{\n+\t  outstr += \"+no\";\n+\t  outstr += opt->name;\n+\t}\n+    }\n \n   return outstr;\n }\n@@ -411,5 +565,7 @@ aarch64_rewrite_mcpu (int argc, const char **argv)\n   return aarch64_rewrite_selected_cpu (argv[argc - 1]);\n }\n \n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;\n+\n #undef AARCH64_CPU_NAME_LENGTH\n "}, {"sha": "1b2f4abbd5b850135af2cb7010921b45c03516a9", "filename": "gcc/config/aarch64/aarch64-option-extensions.def", "status": "modified", "additions": 58, "deletions": 39, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -21,106 +21,125 @@\n \n    Before using #include to read this file, define a macro:\n \n-      AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, FEATURE_STRING)\n-\n-   EXT_NAME is the name of the extension, represented as a string constant.\n-   FLAGS_CANONICAL is the canonical internal name for this flag.\n-   FLAGS_ON are the bitwise-or of the features that enabling the extension\n-   adds, or zero if enabling this extension has no effect on other features.\n-   FLAGS_OFF are the bitwise-or of the features that disabling the extension\n-   removes, or zero if disabling this extension has no effect on other\n-   features.\n-   FEAT_STRING is a string containing the entries in the 'Features' field of\n-   /proc/cpuinfo on a GNU/Linux system that correspond to this architecture\n-   extension being available.  Sometimes multiple entries are needed to enable\n-   the extension (for example, the 'crypto' extension depends on four\n-   entries: aes, pmull, sha1, sha2 being present).  In that case this field\n-   should contain a space (\" \") separated list of the strings in 'Features'\n-   that are required.  Their order is not important.  */\n+      AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF,\n+\t\t\t    SYNTHETIC, FEATURE_STRING)\n+\n+   - EXT_NAME is the name of the extension, represented as a string constant.\n+   - FLAGS_CANONICAL is the canonical internal name for this flag.\n+   - FLAGS_ON are the bitwise-or of the features that enabling the extension\n+     adds, or zero if enabling this extension has no effect on other features.\n+   - FLAGS_OFF are the bitwise-or of the features that disabling the extension\n+     removes, or zero if disabling this extension has no effect on other\n+     features.\n+   - SYNTHETIC is a boolean to indicate whether the option is a purely synthetic\n+     grouping of options and that the option itself has no feature bit (e.g.\n+     crypto).  This is used to determine when sum of the individual options in\n+     FLAGS_ON can be replaced by FLAG_CANONICAL in options minimization.  If the\n+     group is synthetic then they can be replaced when all options in FLAGS_ON\n+     are enabled, otherwise they can only be replaced when\n+     FLAGS_ON | FLAG_CANONICAL are enabled.\n+   - FEAT_STRING is a string containing the entries in the 'Features' field of\n+     /proc/cpuinfo on a GNU/Linux system that correspond to this architecture\n+     extension being available.  Sometimes multiple entries are needed to enable\n+     the extension (for example, the 'crypto' extension depends on four\n+     entries: aes, pmull, sha1, sha2 being present).  In that case this field\n+     should contain a space (\" \") separated list of the strings in 'Features'\n+     that are required.  Their order is not important.  */\n \n /* Enabling \"fp\" just enables \"fp\".\n    Disabling \"fp\" also disables \"simd\", \"crypto\", \"fp16\", \"aes\", \"sha2\",\n    \"sha3\", sm3/sm4 and \"sve\".  */\n AARCH64_OPT_EXTENSION(\"fp\", AARCH64_FL_FP, 0, AARCH64_FL_SIMD | AARCH64_FL_CRYPTO |\\\n \t\t      AARCH64_FL_F16 | AARCH64_FL_AES | AARCH64_FL_SHA2 |\\\n-\t\t      AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE, \"fp\")\n+\t\t      AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE, \\\n+\t\t      false, \"fp\")\n \n /* Enabling \"simd\" also enables \"fp\".\n    Disabling \"simd\" also disables \"crypto\", \"dotprod\", \"aes\", \"sha2\", \"sha3\",\n    \"sm3/sm4\" and \"sve\".  */\n AARCH64_OPT_EXTENSION(\"simd\", AARCH64_FL_SIMD, AARCH64_FL_FP, AARCH64_FL_CRYPTO |\\\n \t\t      AARCH64_FL_DOTPROD | AARCH64_FL_AES | AARCH64_FL_SHA2 |\\\n \t\t      AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE,\n-\t\t      \"asimd\")\n+\t\t      false, \"asimd\")\n \n-/* Enabling \"crypto\" also enables \"fp\" and \"simd\".\n+/* Enabling \"crypto\" also enables \"fp\", \"simd\", \"aes\" and \"sha2\".\n    Disabling \"crypto\" disables \"crypto\", \"aes\", \"sha2\", \"sha3\" and \"sm3/sm4\".  */\n-AARCH64_OPT_EXTENSION(\"crypto\", AARCH64_FL_CRYPTO, AARCH64_FL_FP | AARCH64_FL_SIMD,\\\n+AARCH64_OPT_EXTENSION(\"crypto\", AARCH64_FL_CRYPTO,\n+\t\t      AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_AES |\\\n+\t\t      AARCH64_FL_SHA2,\\\n \t\t      AARCH64_FL_AES | AARCH64_FL_SHA2 |AARCH64_FL_SHA3 | AARCH64_FL_SM4,\\\n-\t\t      \"aes pmull sha1 sha2\")\n+\t\t      true, \"aes pmull sha1 sha2\")\n \n /* Enabling or disabling \"crc\" only changes \"crc\".  */\n-AARCH64_OPT_EXTENSION(\"crc\", AARCH64_FL_CRC, 0, 0, \"crc32\")\n+AARCH64_OPT_EXTENSION(\"crc\", AARCH64_FL_CRC, 0, 0, false, \"crc32\")\n \n /* Enabling or disabling \"lse\" only changes \"lse\".  */\n-AARCH64_OPT_EXTENSION(\"lse\", AARCH64_FL_LSE, 0, 0, \"atomics\")\n+AARCH64_OPT_EXTENSION(\"lse\", AARCH64_FL_LSE, 0, 0, false, \"atomics\")\n \n /* Enabling \"fp16\" also enables \"fp\".\n    Disabling \"fp16\" disables \"fp16\", \"fp16fml\" and \"sve\".  */\n AARCH64_OPT_EXTENSION(\"fp16\", AARCH64_FL_F16, AARCH64_FL_FP,\n-\t\t      AARCH64_FL_F16FML | AARCH64_FL_SVE, \"fphp asimdhp\")\n+\t\t      AARCH64_FL_F16FML | AARCH64_FL_SVE, false, \"fphp asimdhp\")\n \n /* Enabling or disabling \"rcpc\" only changes \"rcpc\".  */\n-AARCH64_OPT_EXTENSION(\"rcpc\", AARCH64_FL_RCPC, 0, 0, \"lrcpc\")\n+AARCH64_OPT_EXTENSION(\"rcpc\", AARCH64_FL_RCPC, 0, 0, false, \"lrcpc\")\n \n /* Enabling \"rdma\" also enables \"fp\", \"simd\".\n    Disabling \"rdma\" just disables \"rdma\".  */\n-AARCH64_OPT_EXTENSION(\"rdma\", AARCH64_FL_RDMA, AARCH64_FL_FP | AARCH64_FL_SIMD, 0, \"asimdrdm\")\n+AARCH64_OPT_EXTENSION(\"rdma\", AARCH64_FL_RDMA, \\\n+\t\t      AARCH64_FL_FP | AARCH64_FL_SIMD, 0, false, \"asimdrdm\")\n \n /* Enabling \"dotprod\" also enables \"simd\".\n    Disabling \"dotprod\" only disables \"dotprod\".  */\n-AARCH64_OPT_EXTENSION(\"dotprod\", AARCH64_FL_DOTPROD, AARCH64_FL_SIMD, 0, \"asimddp\")\n+AARCH64_OPT_EXTENSION(\"dotprod\", AARCH64_FL_DOTPROD, AARCH64_FL_SIMD, 0, \\\n+\t\t      false, \"asimddp\")\n \n /* Enabling \"aes\" also enables \"simd\".\n    Disabling \"aes\" just disables \"aes\".  */\n-AARCH64_OPT_EXTENSION(\"aes\", AARCH64_FL_AES, AARCH64_FL_SIMD, 0, \"aes\")\n+AARCH64_OPT_EXTENSION(\"aes\", AARCH64_FL_AES, AARCH64_FL_SIMD, 0, false, \"aes\")\n \n /* Enabling \"sha2\" also enables \"simd\".\n    Disabling \"sha2\" just disables \"sha2\".  */\n-AARCH64_OPT_EXTENSION(\"sha2\", AARCH64_FL_SHA2, AARCH64_FL_SIMD, 0, \"sha1 sha2\")\n+AARCH64_OPT_EXTENSION(\"sha2\", AARCH64_FL_SHA2, AARCH64_FL_SIMD, 0, false, \\\n+\t\t      \"sha1 sha2\")\n \n /* Enabling \"sha3\" enables \"simd\" and \"sha2\".\n    Disabling \"sha3\" just disables \"sha3\".  */\n-AARCH64_OPT_EXTENSION(\"sha3\", AARCH64_FL_SHA3, AARCH64_FL_SIMD | AARCH64_FL_SHA2, 0, \"sha3 sha512\")\n+AARCH64_OPT_EXTENSION(\"sha3\", AARCH64_FL_SHA3, \\\n+\t\t      AARCH64_FL_SIMD | AARCH64_FL_SHA2, 0, false, \\\n+\t\t      \"sha3 sha512\")\n \n /* Enabling \"sm4\" also enables \"simd\".\n    Disabling \"sm4\" just disables \"sm4\".  */\n-AARCH64_OPT_EXTENSION(\"sm4\", AARCH64_FL_SM4, AARCH64_FL_SIMD, 0, \"sm3 sm4\")\n+AARCH64_OPT_EXTENSION(\"sm4\", AARCH64_FL_SM4, AARCH64_FL_SIMD, 0, false, \\\n+\t\t      \"sm3 sm4\")\n \n /* Enabling \"fp16fml\" also enables \"fp\" and \"fp16\".\n    Disabling \"fp16fml\" just disables \"fp16fml\".  */\n-AARCH64_OPT_EXTENSION(\"fp16fml\", AARCH64_FL_F16FML, AARCH64_FL_FP | AARCH64_FL_F16, 0, \"asimdfml\")\n+AARCH64_OPT_EXTENSION(\"fp16fml\", AARCH64_FL_F16FML, \\\n+\t\t      AARCH64_FL_FP | AARCH64_FL_F16, 0, false, \"asimdfml\")\n \n /* Enabling \"sve\" also enables \"fp16\", \"fp\" and \"simd\".\n    Disabling \"sve\" just disables \"sve\".  */\n-AARCH64_OPT_EXTENSION(\"sve\", AARCH64_FL_SVE, AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_F16, 0, \"sve\")\n+AARCH64_OPT_EXTENSION(\"sve\", AARCH64_FL_SVE, AARCH64_FL_FP | AARCH64_FL_SIMD | \\\n+\t\t      AARCH64_FL_F16, 0, false, \"sve\")\n \n /* Enabling/Disabling \"profile\" does not enable/disable any other feature.  */\n-AARCH64_OPT_EXTENSION(\"profile\", AARCH64_FL_PROFILE, 0, 0, \"\")\n+AARCH64_OPT_EXTENSION(\"profile\", AARCH64_FL_PROFILE, 0, 0, false, \"\")\n \n /* Enabling/Disabling \"rng\" only changes \"rng\".  */\n-AARCH64_OPT_EXTENSION(\"rng\", AARCH64_FL_RNG, 0, 0, \"\")\n+AARCH64_OPT_EXTENSION(\"rng\", AARCH64_FL_RNG, 0, 0, false, \"\")\n \n /* Enabling/Disabling \"memtag\" only changes \"memtag\".  */\n-AARCH64_OPT_EXTENSION(\"memtag\", AARCH64_FL_MEMTAG, 0, 0, \"\")\n+AARCH64_OPT_EXTENSION(\"memtag\", AARCH64_FL_MEMTAG, 0, 0, false, \"\")\n \n /* Enabling/Disabling \"sb\" only changes \"sb\".  */\n-AARCH64_OPT_EXTENSION(\"sb\", AARCH64_FL_SB, 0, 0, \"\")\n+AARCH64_OPT_EXTENSION(\"sb\", AARCH64_FL_SB, 0, 0, false, \"\")\n \n /* Enabling/Disabling \"ssbs\" only changes \"ssbs\".  */\n-AARCH64_OPT_EXTENSION(\"ssbs\", AARCH64_FL_SSBS, 0, 0, \"\")\n+AARCH64_OPT_EXTENSION(\"ssbs\", AARCH64_FL_SSBS, 0, 0, false, \"\")\n \n /* Enabling/Disabling \"predres\" only changes \"predres\".  */\n-AARCH64_OPT_EXTENSION(\"predres\", AARCH64_FL_PREDRES, 0, 0, \"\")\n+AARCH64_OPT_EXTENSION(\"predres\", AARCH64_FL_PREDRES, 0, 0, false, \"\")\n \n #undef AARCH64_OPT_EXTENSION"}, {"sha": "6051443d9268c0d1d4c024be8ba0731c03340e59", "filename": "gcc/config/aarch64/driver-aarch64.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -36,7 +36,8 @@ struct aarch64_arch_extension\n   const char *feat_string;\n };\n \n-#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, FEATURE_STRING) \\\n+#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \\\n+\t\t\t      SYNTHETIC, FEATURE_STRING) \\\n   { EXT_NAME, FLAG_CANONICAL, FEATURE_STRING },\n static struct aarch64_arch_extension aarch64_extensions[] =\n {"}, {"sha": "3e89a7d09cb77279c99148d0b9cad4b9fc172a57", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -1,3 +1,16 @@\n+2019-02-25  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/88530\n+\t* gcc.target/aarch64/options_set_1.c: New test.\n+\t* gcc.target/aarch64/options_set_2.c: New test.\n+\t* gcc.target/aarch64/options_set_3.c: New test.\n+\t* gcc.target/aarch64/options_set_4.c: New test.\n+\t* gcc.target/aarch64/options_set_5.c: New test.\n+\t* gcc.target/aarch64/options_set_6.c: New test.\n+\t* gcc.target/aarch64/options_set_7.c: New test.\n+\t* gcc.target/aarch64/options_set_8.c: New test.\n+\t* gcc.target/aarch64/options_set_9.c: New test.\n+\n 2019-02-25  Tamar Christina  <tamar.christina@arm.com>\n \n \t* gcc.target/arm/simd/fp16fml_high.c (test_vfmlal_high_u32,"}, {"sha": "40d9a05c905eb07103d3b437b5c1351e8620ab33", "filename": "gcc/testsuite/gcc.target/aarch64/options_set_1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_1.c?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-march=armv8.2-a\" } */\n+\n+int main ()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\.arch armv8\\.2\\-a\\+crc} 1 } } */\n+\n+/* Check to see if crc is output by default.  */"}, {"sha": "3476febce706b34430682e879a4aa3aac8f752db", "filename": "gcc/testsuite/gcc.target/aarch64/options_set_2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_2.c?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-march=armv8.2-a+crypto\" } */\n+\n+int main ()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\.arch armv8\\.2\\-a\\+crypto\\+crc} 1 } } */\n+\n+/* Check to see if crc and crypto are maintained if crypto specified.  */"}, {"sha": "4558339f16c19555801899c357c50cedb23c28b0", "filename": "gcc/testsuite/gcc.target/aarch64/options_set_3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_3.c?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-march=armv8.2-a+aes+sha2+crypto\" } */\n+\n+int main ()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\.arch armv8\\.2\\-a\\+crypto\\+crc} 1 } } */\n+\n+/* Check if smallest set is maintained when outputting. */"}, {"sha": "15514bfe93e61e63cbce1262ee951358cd22d6ce", "filename": "gcc/testsuite/gcc.target/aarch64/options_set_4.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_4.c?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-march=armv8.2-a+aes+sha2\" } */\n+\n+int main ()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\.arch armv8\\.2\\-a\\+crypto\\+crc} 1 } } */\n+\n+/* Check if individual bits that make up a grouping is specified that only the\n+   grouping is kept. */\n\\ No newline at end of file"}, {"sha": "b4c0901195ede4fe0dd71fbe02a47c35e9dedbbd", "filename": "gcc/testsuite/gcc.target/aarch64/options_set_5.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_5.c?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-march=armv8.2-a+aes+sha2+nosha2\" } */\n+\n+int main ()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\.arch armv8\\.2\\-a\\+crc\\+aes} 1 } } */\n+\n+/* Check if turning off feature bits works correctly and grouping is no\n+   longer valid.   */"}, {"sha": "90a055928a273f06e08124a250e3107ad0704e47", "filename": "gcc/testsuite/gcc.target/aarch64/options_set_6.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_6.c?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-march=armv8.2-a+crypto+nosha2\" } */\n+\n+int main ()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\.arch armv8\\.2\\-a\\+crypto\\+crc} 1 } } */\n+\n+/* Group as a whole was requested to be turned on, crypto itself is a bit and so\n+   just turning off one feature can't turn it off.   */"}, {"sha": "71a2c8a19058c0ec25546085076503d206129e10", "filename": "gcc/testsuite/gcc.target/aarch64/options_set_7.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_7.c?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-march=armv8.4-a+dotprod\" } */\n+\n+int main ()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\.arch armv8\\.4\\-a} 1 } } */\n+\n+/* Checking if enabling default features drops the superfluous bits.   */"}, {"sha": "83be1bd7a5c3f2bc8d11a14f2c16415c6a7056f2", "filename": "gcc/testsuite/gcc.target/aarch64/options_set_8.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_8.c?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-march=armv8.4-a+nodotprod\" } */\n+\n+int main ()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\.arch armv8\\.4\\-a} 1 } } */\n+\n+/* Checking if trying to turn off default features propagates the commandline\n+   option.  */"}, {"sha": "e3c7cdc54ffb0616877260c562354496cfdcb688", "filename": "gcc/testsuite/gcc.target/aarch64/options_set_9.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Foptions_set_9.c?ref=4ca82fc9f86fc1187ee112e3a637cb3ca5d2ef2a", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-march=armv8-a+simd+fp\" } */\n+\n+int main ()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\.arch armv8\\-a} 1 } } */\n+\n+ /* Check that grouping of bits that don't form a synthetic group don't turn\n+    on the parent. e.g. rdma turns on simd+fp, but simd+fp does not turn on\n+    rdma since rdma is it's own group.  crypto however turns on aes and sha2\n+    and turning on sha2 and eas should turn on crypto!.  */"}]}