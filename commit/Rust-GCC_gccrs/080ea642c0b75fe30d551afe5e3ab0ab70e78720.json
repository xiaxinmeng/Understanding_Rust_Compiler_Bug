{"sha": "080ea642c0b75fe30d551afe5e3ab0ab70e78720", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgwZWE2NDJjMGI3NWZlMzBkNTUxYWZlNWUzYWIwYWI3MGU3ODcyMA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-02-18T19:37:01Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-02-18T19:37:01Z"}, "message": "fold-const.c (negate_expr_p): New function to determine whether an expression can be negated cheaply.\n\n\n\t* fold-const.c (negate_expr_p): New function to determine whether\n\tan expression can be negated cheaply.\n\t(fold) [MINUS_EXPR]: Use it to determine whether to transform\n\t-A - B into -B - A for floating point types.\n\nFrom-SVN: r63059", "tree": {"sha": "0ee4094bf8509462d5d0eb24bc8180303c0134d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ee4094bf8509462d5d0eb24bc8180303c0134d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/080ea642c0b75fe30d551afe5e3ab0ab70e78720", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/080ea642c0b75fe30d551afe5e3ab0ab70e78720", "html_url": "https://github.com/Rust-GCC/gccrs/commit/080ea642c0b75fe30d551afe5e3ab0ab70e78720", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/080ea642c0b75fe30d551afe5e3ab0ab70e78720/comments", "author": null, "committer": null, "parents": [{"sha": "e360ab394f9e67d79095b9d01fc1d68af0007bbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e360ab394f9e67d79095b9d01fc1d68af0007bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e360ab394f9e67d79095b9d01fc1d68af0007bbc"}], "stats": {"total": 76, "additions": 67, "deletions": 9}, "files": [{"sha": "42b21cf4d32188d18c75247cbd8744bc811e9df5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080ea642c0b75fe30d551afe5e3ab0ab70e78720/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080ea642c0b75fe30d551afe5e3ab0ab70e78720/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=080ea642c0b75fe30d551afe5e3ab0ab70e78720", "patch": "@@ -1,3 +1,10 @@\n+2003-02-18  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (negate_expr_p): New function to determine whether\n+\tan expression can be negated cheaply.\n+\t(fold) [MINUS_EXPR]: Use it to determine whether to transform\n+\t-A - B into -B - A for floating point types.\n+\n 2003-02-18  Roger Sayle  <roger@eyesopen.com>\n \n \t* sbitmap.c (sbitmap_resize): New function."}, {"sha": "5dfa1e413ec74d2eb421eba0967b5682714fe485", "filename": "gcc/fold-const.c", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080ea642c0b75fe30d551afe5e3ab0ab70e78720/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080ea642c0b75fe30d551afe5e3ab0ab70e78720/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=080ea642c0b75fe30d551afe5e3ab0ab70e78720", "patch": "@@ -1,6 +1,6 @@\n /* Fold a constant sub-tree into a single node for C-compiler\n-   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2002,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+   2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -63,6 +63,7 @@ static void encode\t\tPARAMS ((HOST_WIDE_INT *,\n static void decode\t\tPARAMS ((HOST_WIDE_INT *,\n \t\t\t\t\t unsigned HOST_WIDE_INT *,\n \t\t\t\t\t HOST_WIDE_INT *));\n+static bool negate_expr_p\tPARAMS ((tree));\n static tree negate_expr\t\tPARAMS ((tree));\n static tree split_tree\t\tPARAMS ((tree, enum tree_code, tree *, tree *,\n \t\t\t\t\t tree *, int));\n@@ -835,6 +836,55 @@ div_and_round_double (code, uns,\n   return overflow;\n }\n \f\n+/* Determine whether an expression T can be cheaply negated using\n+   the function negate_expr.  */\n+\n+static bool\n+negate_expr_p (t)\n+     tree t;\n+{\n+  unsigned HOST_WIDE_INT val;\n+  unsigned int prec;\n+  tree type;\n+\n+  if (t == 0)\n+    return false;\n+\n+  type = TREE_TYPE (t);\n+\n+  STRIP_SIGN_NOPS (t);\n+  switch (TREE_CODE (t))\n+    {\n+    case INTEGER_CST:\n+      if (TREE_UNSIGNED (type))\n+\treturn false;\n+\n+      /* Check that -CST will not overflow type.  */\n+      prec = TYPE_PRECISION (type);\n+      if (prec > HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  if (TREE_INT_CST_LOW (t) != 0)\n+\t    return true;\n+\t  prec -= HOST_BITS_PER_WIDE_INT;\n+\t  val = TREE_INT_CST_HIGH (t);\n+\t}\n+      else\n+\tval = TREE_INT_CST_LOW (t);\n+      if (prec < HOST_BITS_PER_WIDE_INT)\n+\tval &= ((unsigned HOST_WIDE_INT) 1 << prec) - 1;\n+      return val != ((unsigned HOST_WIDE_INT) 1 << (prec - 1));\n+\n+    case REAL_CST:\n+    case NEGATE_EXPR:\n+    case MINUS_EXPR:\n+      return true;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n /* Given T, an expression, return the negation of T.  Allow for T to be\n    null, in which case return null.  */\n \n@@ -5479,13 +5529,14 @@ fold (expr)\n       /* A - (-B) -> A + B */\n       if (TREE_CODE (arg1) == NEGATE_EXPR)\n \treturn fold (build (PLUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n-      /* (-A) - CST -> (-CST) - A   for floating point (what about ints ?)  */\n-      if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == REAL_CST)\n-\treturn\n-\t  fold (build (MINUS_EXPR, type,\n-\t\t       build_real (TREE_TYPE (arg1),\n-\t\t\t\t   REAL_VALUE_NEGATE (TREE_REAL_CST (arg1))),\n-\t\t       TREE_OPERAND (arg0, 0)));\n+      /* (-A) - B -> (-B) - A  where B is easily negated and we can swap.  */\n+      if (TREE_CODE (arg0) == NEGATE_EXPR\n+\t  && FLOAT_TYPE_P (type)\n+\t  && negate_expr_p (arg1)\n+\t  && (! TREE_SIDE_EFFECTS (arg0) || TREE_CONSTANT (arg1))\n+\t  && (! TREE_SIDE_EFFECTS (arg1) || TREE_CONSTANT (arg0)))\n+\treturn fold (build (MINUS_EXPR, type, negate_expr (arg1),\n+\t\t\t    TREE_OPERAND (arg0, 0)));\n \n       if (! FLOAT_TYPE_P (type))\n \t{"}]}