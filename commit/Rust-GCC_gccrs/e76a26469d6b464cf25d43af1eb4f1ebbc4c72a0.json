{"sha": "e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc2YTI2NDY5ZDZiNDY0Y2YyNWQ0M2FmMWViNGYxZWJiYzRjNzJhMA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-03-08T00:38:10Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-03-08T00:38:10Z"}, "message": "85th Cygnus<->FSF merge\n\nFrom-SVN: r11497", "tree": {"sha": "938d65a89cf25e2714899dccc47ec5021d7a0de1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/938d65a89cf25e2714899dccc47ec5021d7a0de1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/comments", "author": null, "committer": null, "parents": [{"sha": "838b5ca862aea53720a1a3b788a2e9f80226aa25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/838b5ca862aea53720a1a3b788a2e9f80226aa25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/838b5ca862aea53720a1a3b788a2e9f80226aa25"}], "stats": {"total": 443, "additions": 340, "deletions": 103}, "files": [{"sha": "42ac898b2373e21d046a8a9f467bc2942ed99dbb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -1,3 +1,117 @@\n+Thu Mar  7 14:11:49 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.def: Add RETURN_INIT.\n+\t* pt.c (instantiate_decl): Handle RETURN_INIT.\n+\t* decl.c (store_return_init): Handle minimal_parse_mode.\n+\n+\t* tree.c (cp_build_type_variant): Just return an error_mark_node.\n+\t* decl.c (make_typename_type): Don't try to get the file and line\n+ \tof an identifier.\n+\t* typeck.c (comptypes): Handle TYPENAME_TYPE.\n+\n+Wed Mar  6 18:47:50 1996  Per Bothner  <bothner@kalessin.cygnus.com>\n+\n+\t* decl.c (poplevel): Make sure we clear out and restore old local\n+\tnon-VAR_DECL values by default when they go out of scope.\n+\n+Wed Mar  6 09:57:36 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (build_overload_value): Use DECL_ASSEMBLER_NAME in\n+ \treferring to addresses of variables and functions.\n+\n+\t* error.c (dump_expr): Support SIZEOF_EXPR.\n+\n+\t* init.c (do_friend): Use the return value of check_classfn.\n+\n+\t* typeck.c (convert_arguments): Call complete_type.\n+\n+\t* method.c (hack_identifier): After giving an error, set value to\n+ \terror_mark_node.\n+\n+Tue Mar  5 16:00:15 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (hack_decl_function_context): Kludge around DECL_CONTEXT\n+ \tlossage for local classes.\n+\t* cp-tree.h: Declare it.\n+\t* decl.c (lookup_name_real): Evil, painful hack for local classes.\n+\t(grokfndecl): Set DECL_CLASS_CONTEXT and DECL_NO_STATIC_CHAIN here.\n+\tUse hack_decl_function_context.\n+\t(grokdeclarator): Don't set DECL_NO_STATIC_CHAIN here.\n+\t(start_function): Use hack_decl_function_context.\n+\t(finish_function): Ditto.\n+\t* method.c (synthesize_method): Ditto.\n+\t* lex.c (process_next_inline): Ditto.\n+\t(do_pending_inlines): Ditto.\n+\t* decl2.c (finish_file): Unset DECL_STATIC_FUNCTION_P when we're\n+ \tdone with it.\n+\n+Mon Mar  4 22:38:39 1996  Gerald Baumgartner  <gb@alexander.cs.purdue.edu>\n+\n+\t* sig.c (build_signature_pointer_or_reference_type): Align\n+\tsignature pointers/references on 8-byte boundaries so they can be\n+\tgrabbed 2 words at a time on a Sparc.\n+\n+Tue Mar  5 10:21:01 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (hack_identifier): Requiring a static chain is now a\n+ \thard error.\n+\t* decl.c (grokdeclarator): Set DECL_NO_STATIC_CHAIN on nested\n+ \tfunctions.\n+\n+Mon Mar  4 20:03:33 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (build_offset_ref): Call complete_type.\n+\n+\t* decl.c (pop_from_top_level): Always pop previous_class_type.\n+\n+\t* parse.y: Handle multiple decls in a for-init-statement.\n+\t* pt.c (tsubst_expr): Ditto.\n+\n+\t* pt.c (tsubst): Use tsubst_expr for the second operand of an\n+ \tARRAY_REF.\n+\n+\t* decl.c (maybe_push_to_top_level): Don't save previous_class_type.\n+\t(poplevel_class): Set it here.\n+\t(pop_from_top_level): Pop it here if we're returning to class scope.\n+\t* class.c (pushclass): Don't set it here.\n+\n+\t* decl.c (maybe_push_to_top_level): Save current_template_parms,\n+ \tand clear it if !pseudo.\n+\t(pop_from_top_level): Restore it.\n+\n+\t* decl2.c (finish_file): Push the dummy each time we walk the list\n+ \tof vtables.\n+\n+\t* error.c (dump_expr): Support LOOKUP_EXPR and actually do\n+ \tsomething for CAST_EXPR.\n+\t\n+Mon Feb 19 14:49:18 1996  Rusty Russell  <rusty@adelaide.maptek.com.au>\n+\n+\t* cvt.c (cp_convert): Warn about implicit conversion of the\n+\taddress of a function to bool, as it is always true.\n+\n+Fri Feb 23 23:06:01 1996  Rusty Russell  <rusty@adelaide.maptek.com.au>\n+\n+\t* typeck.c (c_expand_return): Fix warning for local externs returned.\n+\n+Mon Mar  4 15:03:11 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (mapcar): Propagate const and volatile properly.\n+\n+\t* typeck.c (complete_type): Be sure to instantiate the\n+ \tMAIN_VARIANT of the type.\n+\n+\t* method.c (synthesize_method): Class interface hackery does not\n+\tapply to synthesized methods.\n+\n+Mon Mar  4 14:05:23 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (comp_template_args): Use comptypes rather than just\n+ \tchecking for TEMPLATE_TYPE_PARM equivalence.\n+\n+\t* typeck.c (build_x_function_call): Call complete_type before\n+ \tchecking TYPE_OVERLOADS_CALL_EXPR.\n+\n Mon Mar  4 18:48:30 1996  Manfred Hollstein   <manfred@lts.sel.alcatel.de>\n \n \t* g++.c (main): Check also for new define ALT_LIBM."}, {"sha": "beb333076a3e59a38771856f1358f5cf410a4a34", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -4660,8 +4660,6 @@ pushclass (type, modify)\n \t  build_mi_matrix (type);\n \t  push_class_decls (type);\n \t  free_mi_matrix ();\n-\t  if (current_class_depth == 1)\n-\t    previous_class_type = type;\n \t}\n       else\n \t{"}, {"sha": "2a07e2ef6b7768d4e330348039919be4f307bb8e", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -137,3 +137,4 @@ DEFTREECODE (GOTO_STMT, \"goto_stmt\", \"e\", 1)\n \n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", \"e\", 2)\n DEFTREECODE (CASE_LABEL, \"case_label\", \"e\", 2)\n+DEFTREECODE (RETURN_INIT, \"return_init\", \"e\", 2)"}, {"sha": "49443387267d6b8a00b913b8da3932ce58589d30", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -2402,6 +2402,7 @@ extern tree build_unsave_expr\t\t\tPROTO((tree));\n extern tree unsave_expr\t\t\t\tPROTO((tree));\n extern int cp_expand_decl_cleanup\t\tPROTO((tree, tree));\n extern tree get_type_decl\t\t\tPROTO((tree));\n+extern tree hack_decl_function_context \t\tPROTO((tree));\n \n /* in typeck.c */\n extern tree condition_conversion\t\tPROTO((tree));"}, {"sha": "bd9399c79a7d26f81bf4ea6167c59624187435f7", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -1257,7 +1257,13 @@ cp_convert (type, expr, convtype, flags)\n \t  return error_mark_node;\n \t}\n       if (code == BOOLEAN_TYPE)\n-\treturn truthvalue_conversion (e);\n+\t{\n+\t  /* Common Ada/Pascal programmer's mistake.  We always warn\n+             about this since it is so bad.  */\n+\t  if (TREE_CODE (expr) == FUNCTION_DECL)\n+\t    cp_warning (\"the address of `%D', will always be `true'\", expr);\n+\t  return truthvalue_conversion (e);\n+\t}\n       return fold (convert_to_integer (type, e));\n     }\n   if (code == POINTER_TYPE || code == REFERENCE_TYPE"}, {"sha": "c9d5c42286ce1b8de9c327ae0a5f829e9b68b5ab", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 82, "deletions": 37, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -1074,6 +1074,8 @@ poplevel (keep, reverse, functionbody)\n \t{\n \t  if (TREE_CODE (link) == VAR_DECL)\n \t    DECL_DEAD_FOR_LOCAL (link) = 1;\n+\t  else\n+\t    IDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = NULL_TREE;\n \t}\n \n       /* Save declarations made in a 'for' statement so we can support pre-ANSI\n@@ -1084,11 +1086,16 @@ poplevel (keep, reverse, functionbody)\n \t  tree id = TREE_PURPOSE (link);\n \t  tree decl = IDENTIFIER_LOCAL_VALUE (id);\n \n-\t  /* In this case keep the dead for-decl visible,\n-\t     but remember what (if anything) it shadowed. */\n-\t  DECL_SHADOWED_FOR_VAR (decl) = TREE_VALUE (link);\n-\t  TREE_CHAIN (decl) = outer->dead_vars_from_for;\n-\t  outer->dead_vars_from_for = decl;\n+\t  if (decl && DECL_DEAD_FOR_LOCAL (decl))\n+\t    {\n+\t      /* In this case keep the dead for-decl visible,\n+\t\t but remember what (if anything) it shadowed. */\n+\t      DECL_SHADOWED_FOR_VAR (decl) = TREE_VALUE (link);\n+\t      TREE_CHAIN (decl) = outer->dead_vars_from_for;\n+\t      outer->dead_vars_from_for = decl;\n+\t    }\n+\t  else\n+\t    IDENTIFIER_LOCAL_VALUE (id) = TREE_VALUE (link);\n \t}\n     }\n   else /* Not special for scope. */\n@@ -1399,7 +1406,10 @@ poplevel_class (force)\n   else\n     /* Remember to save what IDENTIFIER's were bound in this scope so we\n        can recover from cache misses.  */\n-    previous_class_values = class_binding_level->class_shadowed;\n+    {\n+      previous_class_type = current_class_type;\n+      previous_class_values = class_binding_level->class_shadowed;\n+    }\n   for (shadowed = level->type_shadowed;\n        shadowed;\n        shadowed = TREE_CHAIN (shadowed))\n@@ -1730,12 +1740,12 @@ struct saved_scope {\n   tree class_name, class_type, function_decl;\n   tree base_init_list, member_init_list;\n   struct binding_level *class_bindings;\n-  tree previous_class_type, previous_class_values;\n   tree *lang_base, *lang_stack, lang_name;\n   int lang_stacksize;\n   tree named_labels;\n   int minimal_parse_mode;\n   tree last_function_parms;\n+  tree template_parms;\n };\n static struct saved_scope *current_saved_scope;\n extern tree prev_class_type;\n@@ -1811,13 +1821,6 @@ maybe_push_to_top_level (pseudo)\n       for (t = b->type_shadowed; t; t = TREE_CHAIN (t))\n \tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (t), TREE_VALUE (t));\n     }\n-  /* Clear out class-level bindings cache.  */\n-  if (current_binding_level == global_binding_level\n-      && previous_class_type != NULL_TREE)\n-    {\n-      popclass (-1);\n-      previous_class_type = NULL_TREE;\n-    }\n \n   s->old_binding_level = current_binding_level;\n   current_binding_level = b;\n@@ -1828,26 +1831,26 @@ maybe_push_to_top_level (pseudo)\n   s->base_init_list = current_base_init_list;\n   s->member_init_list = current_member_init_list;\n   s->class_bindings = class_binding_level;\n-  s->previous_class_type = previous_class_type;\n-  s->previous_class_values = previous_class_values;\n   s->lang_stack = current_lang_stack;\n   s->lang_base = current_lang_base;\n   s->lang_stacksize = current_lang_stacksize;\n   s->lang_name = current_lang_name;\n   s->named_labels = named_labels;\n   s->minimal_parse_mode = minimal_parse_mode;\n   s->last_function_parms = last_function_parms;\n+  s->template_parms = current_template_parms;\n   current_class_name = current_class_type = NULL_TREE;\n   current_function_decl = NULL_TREE;\n   class_binding_level = (struct binding_level *)0;\n-  previous_class_type = NULL_TREE;\n   current_lang_stacksize = 10;\n   current_lang_stack = current_lang_base\n     = (tree *) xmalloc (current_lang_stacksize * sizeof (tree));\n   current_lang_name = lang_name_cplusplus;\n   strict_prototype = strict_prototypes_lang_cplusplus;\n   named_labels = NULL_TREE;\n   minimal_parse_mode = 0;\n+  if (!pseudo)\n+    current_template_parms = NULL_TREE;\n \n   s->prev = current_saved_scope;\n   s->old_bindings = old_bindings;\n@@ -1869,8 +1872,12 @@ pop_from_top_level ()\n   struct saved_scope *s = current_saved_scope;\n   tree t;\n \n+  /* Clear out class-level bindings cache.  */\n   if (previous_class_type)\n-    previous_class_type = NULL_TREE;\n+    {\n+      popclass (-1);\n+      previous_class_type = NULL_TREE;\n+    }\n \n   pop_obstacks ();\n \n@@ -1892,8 +1899,6 @@ pop_from_top_level ()\n   current_member_init_list = s->member_init_list;\n   current_function_decl = s->function_decl;\n   class_binding_level = s->class_bindings;\n-  previous_class_type = s->previous_class_type;\n-  previous_class_values = s->previous_class_values;\n   free (current_lang_base);\n   current_lang_base = s->lang_base;\n   current_lang_stack = s->lang_stack;\n@@ -1906,6 +1911,7 @@ pop_from_top_level ()\n   named_labels = s->named_labels;\n   minimal_parse_mode = s->minimal_parse_mode;\n   last_function_parms = s->last_function_parms;\n+  current_template_parms = s->template_parms;\n \n   free (s);\n }\n@@ -4317,7 +4323,7 @@ make_typename_type (context, name)\n       t = lookup_field (context, name, 0, 1);\n       if (t == NULL_TREE)\n \t{\n-\t  cp_error_at (\"no type matching `%#T' in `%#T'\", name, context);\n+\t  cp_error (\"no type named `%#T' in `%#T'\", name, context);\n \t  return error_mark_node;\n \t}\n       return TREE_TYPE (t);\n@@ -4359,6 +4365,7 @@ lookup_name_real (name, prefer_type, nonclass)\n   register tree val;\n   int yylex = 0;\n   tree from_obj = NULL_TREE;\n+  tree locval, classval;\n \n   if (prefer_type == -2)\n     {\n@@ -4425,30 +4432,59 @@ lookup_name_real (name, prefer_type, nonclass)\n       else if (got_object && val && TREE_CODE (val) == TYPE_DECL)\n \tfrom_obj = val;\n     }\n-    \n+\n+  locval = classval = NULL_TREE;\n+\n   if (current_binding_level != global_binding_level\n       && IDENTIFIER_LOCAL_VALUE (name))\n-    val = IDENTIFIER_LOCAL_VALUE (name);\n+    locval = IDENTIFIER_LOCAL_VALUE (name);\n+\n   /* In C++ class fields are between local and global scope,\n      just before the global scope.  */\n-  else if (current_class_type && ! nonclass)\n+  if (current_class_type && ! nonclass)\n     {\n-      val = IDENTIFIER_CLASS_VALUE (name);\n-      if (val == NULL_TREE && TYPE_BEING_DEFINED (current_class_type))\n+      classval = IDENTIFIER_CLASS_VALUE (name);\n+      if (classval == NULL_TREE && TYPE_BEING_DEFINED (current_class_type))\n \t/* Try to find values from base classes if we are presently\n \t   defining a type.  We are presently only interested in\n \t   TYPE_DECLs.  */\n-\tval = lookup_field (current_class_type, name, 0, 1);\n+\tclassval = lookup_field (current_class_type, name, 0, 1);\n \n       /* yylex() calls this with -2, since we should never start digging for\n \t the nested name at the point where we haven't even, for example,\n \t created the COMPONENT_REF or anything like that.  */\n-      if (val == NULL_TREE)\n-\tval = lookup_nested_field (name, ! yylex);\n+      if (classval == NULL_TREE)\n+\tclassval = lookup_nested_field (name, ! yylex);\n+    }\n \n-      if (val == NULL_TREE)\n-\tval = IDENTIFIER_GLOBAL_VALUE (name);\n+  if (locval && classval)\n+    {\n+      if (current_scope () == current_function_decl\n+\t  && ! hack_decl_function_context (current_function_decl))\n+\t/* Not in a nested function.  */\n+\tval = locval;\n+      else\n+\t{\n+\t  /* This is incredibly horrible.  The whole concept of\n+\t     IDENTIFIER_LOCAL_VALUE / IDENTIFIER_CLASS_VALUE /\n+\t     IDENTIFIER_GLOBAL_VALUE needs to be scrapped for local\n+\t     classes.  */\n+\t  tree lctx = hack_decl_function_context (locval);\n+\t  tree cctx = hack_decl_function_context (classval);\n+\n+\t  if (lctx == current_scope ())\n+\t    val = locval;\n+\t  else if (lctx == cctx)\n+\t    val = classval;\n+\t  else\n+\t    /* I don't know which is right; let's just guess for now.  */\n+\t    val = locval;\n+\t}\n     }\n+  else if (locval)\n+    val = locval;\n+  else if (classval)\n+    val = classval;\n   else\n     val = IDENTIFIER_GLOBAL_VALUE (name);\n \n@@ -7085,9 +7121,11 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n     {\n       DECL_STATIC_FUNCTION_P (decl) = 1;\n       DECL_CONTEXT (decl) = ctype;\n-      DECL_CLASS_CONTEXT (decl) = ctype;\n     }\n \n+  if (ctype)\n+    DECL_CLASS_CONTEXT (decl) = ctype;\n+\n   /* All function decls start out public; we'll fix their linkage later (at\n      definition or EOF) if appropriate.  */\n   TREE_PUBLIC (decl) = 1;\n@@ -7119,6 +7157,9 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n   if (IDENTIFIER_OPNAME_P (DECL_NAME (decl)))\n     grok_op_properties (decl, virtualp, check < 0);\n \n+  if (ctype && hack_decl_function_context (decl))\n+      DECL_NO_STATIC_CHAIN (decl) = 1;\n+\n   /* Caller will do the rest of this.  */\n   if (check < 0)\n     return decl;\n@@ -11092,7 +11133,7 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n       if ((DECL_THIS_INLINE (decl1) || DECL_TEMPLATE_INSTANTIATION (decl1))\n \t  && ! DECL_INTERFACE_KNOWN (decl1)\n \t  /* Don't try to defer nested functions for now.  */\n-\t  && ! decl_function_context (decl1))\n+\t  && ! hack_decl_function_context (decl1))\n \tDECL_DEFER_OUTPUT (decl1) = 1;\n       else\n \t{\n@@ -11425,8 +11466,7 @@ store_return_init (return_id, init)\n \t  DECL_ASSEMBLER_NAME (decl) = return_id;\n \t}\n       else\n-\terror (\"return identifier `%s' already in place\",\n-\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\tcp_error (\"return identifier `%D' already in place\", decl);\n     }\n \n   /* Can't let this happen for constructors.  */\n@@ -11450,7 +11490,12 @@ store_return_init (return_id, init)\n       /* Let `cp_finish_decl' know that this initializer is ok.  */\n       DECL_INITIAL (decl) = init;\n       pushdecl (decl);\n-      cp_finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n+\n+      if (minimal_parse_mode)\n+\tadd_tree (build_min_nt (RETURN_INIT, return_id,\n+\t\t\t\tcopy_to_permanent (init)));\n+      else\n+\tcp_finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n }\n \n@@ -11485,7 +11530,7 @@ finish_function (lineno, call_poplevel, nested)\n   if (fndecl == NULL_TREE)\n     return;\n \n-  if (! nested && decl_function_context (fndecl) != NULL_TREE)\n+  if (! nested && hack_decl_function_context (fndecl) != NULL_TREE)\n     nested = 1;\n \n   fntype = TREE_TYPE (fndecl);"}, {"sha": "23926d62cd260d409e6ddbeb96fe222a4d636b03", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -2991,6 +2991,7 @@ finish_file ()\n \t\texpand_assignment (decl, init, 0, 0);\n \n \t      DECL_CLASS_CONTEXT (current_function_decl) = NULL_TREE;\n+\t      DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n \t    }\n \t  else if (TREE_CODE (decl) == SAVE_EXPR)\n \t    {\n@@ -3099,6 +3100,13 @@ finish_file ()\n \ttree *p = &saved_inlines;\n \treconsider = 0;\n \n+\t/* We need to do this each time so that newly completed template\n+           types don't wind up at the front of the list.  Sigh.  */\n+\tvars = build_decl (TYPE_DECL, make_anon_name (), integer_type_node);\n+\tDECL_IGNORED_P (vars) = 1;\n+\tSET_DECL_ARTIFICIAL (vars);\n+\tpushdecl (vars);\n+\n \twalk_vtables ((void (*)())0, finish_vtable_vardecl);\n \n \twhile (*p)"}, {"sha": "7931ede3d9d551f83410804a80ad4cb72e00d6de", "filename": "gcc/cp/error.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -1285,7 +1285,36 @@ dump_expr (t, nop)\n       break;\n \n     case CAST_EXPR:\n-      break;\t\t\t/* XXX */\n+      if (TREE_CHAIN (TREE_OPERAND (t, 0)))\n+\t{\n+\t  dump_type (TREE_TYPE (t), 0);\n+\t  OB_PUTC ('(');\n+\t  dump_expr_list (TREE_OPERAND (t, 0), 0);\n+\t  OB_PUTC (')');\n+\t}\n+      else\n+\t{\n+\t  OB_PUTC ('(');\n+\t  dump_type (TREE_TYPE (t), 0);\n+\t  OB_PUTC (')');\n+\t  OB_PUTC ('(');\n+\t  dump_expr_list (TREE_OPERAND (t, 0));\n+\t  OB_PUTC (')');\n+\t}\n+      break;\n+\n+    case LOOKUP_EXPR:\n+      OB_PUTID (TREE_OPERAND (t, 0));\n+      break;\n+\n+    case SIZEOF_EXPR:\n+      OB_PUTS (\"sizeof (\");\n+      if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t, 0))) == 't')\n+\tdump_type (TREE_OPERAND (t, 0), 0);\n+      else\n+\tdump_unary_op (\"*\", t, 0);\n+      OB_PUTC (')');\n+      break;\n \n     case TREE_LIST:\n       if (TREE_VALUE (t) && TREE_CODE (TREE_VALUE (t)) == FUNCTION_DECL)"}, {"sha": "64ffb84068ae5fde1f9a3c7c665adb3f2e979771", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -1169,9 +1169,10 @@ thrown is used instead.  All code that originates exceptions, even code\n that throws exceptions as a side effect, like dynamic casting, and all\n code that catches exceptions must be compiled with either -frtti, or\n -fno-rtti.  It is not possible to mix rtti base exception handling\n-objects with code that doesn't use rtti.  The exceptions to this, are\n-code that doesn't catch or throw exceptions, catch (...), and code that\n-just rethrows an exception.\n+objects with code that doesn't use rtti.  Also, -frtti can alter the\n+binary layout of classes, so mixing -frtti code and -fno-rtti code can\n+be dangerous.  The exceptions to this, are code that doesn't catch or\n+throw exceptions, catch (...), and code that just rethrows an exception.\n \n Currently we use the normal mangling used in building functions names\n (int's are \"i\", const char * is PCc) to build the non-rtti base type\n@@ -1225,9 +1226,14 @@ stands.\n \n Only exact type matching or reference matching of throw types works when\n -fno-rtti is used.  Only works on a SPARC (like Suns), i386, arm,\n-rs6000, Alpha and mips machines.  Partial support is in for all other\n-machines, but a stack unwinder called __unwind_function has to be\n-written, and added to libgcc2 for them.  See below for details on\n+rs6000, PowerPC, Alpha, mips and VAX machines.  Partial support is in\n+for all other machines, but a stack unwinder called __unwind_function\n+has to be written, and added to libgcc2 for them.  The new EH code\n+doesn't rely upon the __unwind_function for C++ code, instead it creates\n+per function unwinders right inside the function, unfortunately, on many\n+platforms the definition of RETURN_ADDR_RTX in the tm.h file for the\n+machine port is wrong.  The HPPA has a brain dead abi that prevents\n+exception handling from just working.  See below for details on\n __unwind_function.  Don't expect exception handling to work right if you\n optimize, in fact the compiler will probably core dump.  RTL_EXPRs for\n EH cond variables for && and || exprs should probably be wrapped in"}, {"sha": "863b2ccd55a358b8049da615e3df8507d3539446", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -1815,7 +1815,7 @@ build_offset_ref (type, name)\n   if (name == constructor_name_full (type))\n     name = constructor_name (type);\n \n-  if (TYPE_SIZE (type) == 0)\n+  if (TYPE_SIZE (complete_type (type)) == 0)\n     {\n       if (type == current_class_type)\n \tt = IDENTIFIER_CLASS_VALUE (name);\n@@ -2432,25 +2432,16 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \t  /* This will set up DECL_ARGUMENTS for us.  */\n \t  grokclassfn (ctype, cname, decl, flags, quals);\n \t  if (TYPE_SIZE (ctype) != 0)\n-\t    check_classfn (ctype, decl);\n+\t    decl = check_classfn (ctype, decl);\n \n \t  if (TREE_TYPE (decl) != error_mark_node)\n \t    {\n \t      if (TYPE_SIZE (ctype))\n-\t\t{\n-\t\t  /* We don't call pushdecl here yet, or ever on this\n-\t\t     actual FUNCTION_DECL.  We must preserve its TREE_CHAIN\n-\t\t     until the end.  */\n-\t\t  make_decl_rtl (decl, NULL_PTR, 1);\n-\t\t  add_friend (current_class_type, decl);\n-\t\t}\n+\t\tadd_friend (current_class_type, decl);\n \t      else\n \t\t{\n-\t\t  register char *classname\n-\t\t    = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (ctype)));\n-\n-\t\t  error (\"member declared as friend before type `%s' defined\",\n-\t\t\t classname);\n+\t\t  cp_error (\"member `%D' declared as friend before type `%T' defined\",\n+\t\t\t    decl, ctype);\n \t\t}\n \t    }\n \t}"}, {"sha": "b42be21db33374e7a1fa67701aa1e68627283996", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -1128,7 +1128,7 @@ do_pending_inlines ()\n     return;\n \t    \n   /* Now start processing the first inline function.  */\n-  context = decl_function_context (t->fndecl);\n+  context = hack_decl_function_context (t->fndecl);\n   if (context)\n     push_cp_function_context (context);\n   if (t->len > 0)\n@@ -1167,7 +1167,7 @@ process_next_inline (t)\n {\n   tree context;\n   struct pending_inline *i = (struct pending_inline *) TREE_PURPOSE (t);\n-  context = decl_function_context (i->fndecl);\n+  context = hack_decl_function_context (i->fndecl);\n   if (context)\n     pop_cp_function_context (context);\n   i = i->next;\n@@ -1191,7 +1191,7 @@ process_next_inline (t)\n   to_be_restored = 0;\n   if (i && i->fndecl != NULL_TREE)\n     {\n-      context = decl_function_context (i->fndecl);\n+      context = hack_decl_function_context (i->fndecl);\n       if (context)\n \tpush_cp_function_context (context);\n       feed_input (i->buf, i->len, i->can_free ? &inline_text_obstack : 0);"}, {"sha": "68addefd1b3a0f2bed8e5eb44ba4c71597e0cc33", "filename": "gcc/cp/method.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -539,13 +539,13 @@ build_overload_value (type, value)\n       if (TREE_CODE (value) == VAR_DECL)\n \t{\n \t  my_friendly_assert (DECL_NAME (value) != 0, 245);\n-\t  build_overload_identifier (DECL_NAME (value));\n+\t  build_overload_identifier (DECL_ASSEMBLER_NAME (value));\n \t  return;\n \t}\n       else if (TREE_CODE (value) == FUNCTION_DECL)\n \t{\n \t  my_friendly_assert (DECL_NAME (value) != 0, 246);\n-\t  build_overload_identifier (DECL_NAME (value));\n+\t  build_overload_identifier (DECL_ASSEMBLER_NAME (value));\n \t  return;\n \t}\n       else\n@@ -1591,17 +1591,17 @@ hack_identifier (value, name)\n   else\n     mark_used (value);\n \n-  if (pedantic\n-      && (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == PARM_DECL))\n+  if (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == PARM_DECL)\n     {\n       tree context = decl_function_context (value);\n       if (context != NULL_TREE && context != current_function_decl\n \t  && ! TREE_STATIC (value))\n \t{\n-\t  cp_pedwarn (\"use of %s from containing function\",\n+\t  cp_error (\"use of %s from containing function\",\n \t\t      (TREE_CODE (value) == VAR_DECL\n \t\t       ? \"`auto' variable\" : \"parameter\"));\n-\t  cp_pedwarn_at (\"  `%#D' declared here\", value);\n+\t  cp_error_at (\"  `%#D' declared here\", value);\n+\t  value = error_mark_node;\n \t}\n     }\n \n@@ -2265,16 +2265,13 @@ synthesize_method (fndecl)\n      tree fndecl;\n {\n   int nested = (current_function_decl != NULL_TREE);\n-  tree context = decl_function_context (fndecl);\n-  char *f = input_filename;\n+  tree context = hack_decl_function_context (fndecl);\n   tree base = DECL_CLASS_CONTEXT (fndecl);\n \n   if (nested)\n     push_cp_function_context (context);\n \n-  input_filename = DECL_SOURCE_FILE (fndecl);\n-  interface_unknown = CLASSTYPE_INTERFACE_UNKNOWN (base);\n-  interface_only = CLASSTYPE_INTERFACE_ONLY (base);\n+  interface_unknown = 1;\n   start_function (NULL_TREE, fndecl, NULL_TREE, NULL_TREE, 1);\n   store_parm_decls ();\n \n@@ -2305,7 +2302,6 @@ synthesize_method (fndecl)\n \tDECL_INLINE (fndecl) = 1;\n     }\n \n-  input_filename = f;\n   extract_interface_info ();\n   if (nested)\n     pop_cp_function_context (context);"}, {"sha": "1c11f283905eabaf1a3c37ec1918b9e6689d76be", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -3318,7 +3318,7 @@ simple_stmt:\n \t\t    {\n \t\t      if (last_tree != $<ttype>2)\n \t\t\t{\n-\t\t\t  TREE_OPERAND ($<ttype>2, 0) = last_tree;\n+\t\t\t  TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n \t\t\t  TREE_CHAIN ($<ttype>2) = NULL_TREE;\n \t\t\t  last_tree = $<ttype>2;\n \t\t\t}"}, {"sha": "13fd6ba1fda99bd99bfa43beccd644f8798d35b1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -453,8 +453,7 @@ comp_template_args (oldargs, newargs)\n \tcontinue;\n       if (TREE_CODE (nt) != TREE_CODE (ot))\n \treturn 0;\n-      if (TREE_CODE (ot) == TEMPLATE_TYPE_PARM\n-\t  && comptypes (ot, nt, 1))\n+      if (TREE_CODE_CLASS (TREE_CODE (ot)) == 't' && comptypes (ot, nt, 1))\n \tcontinue;\n       if (TREE_CODE (ot) == TEMPLATE_CONST_PARM\n \t  && TEMPLATE_CONST_IDX (nt) == TEMPLATE_CONST_IDX (ot))\n@@ -1775,7 +1774,7 @@ tsubst (t, args, nargs, in_decl)\n     case ARRAY_REF:\n       return build_parse_node\n \t(ARRAY_REF, tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl));\n+\t tsubst_expr (TREE_OPERAND (t, 1), args, nargs, in_decl));\n \n     case CALL_EXPR:\n       return build_parse_node\n@@ -2085,7 +2084,8 @@ tsubst_expr (t, args, nargs, in_decl)\n \temit_line_note (input_filename, lineno);\n \tif (init_scope)\n \t  do_pushlevel ();\n-\ttsubst_expr (TREE_OPERAND (t, 0), args, nargs, in_decl);\n+\tfor (tmp = TREE_OPERAND (t, 0); tmp; tmp = TREE_CHAIN (tmp))\n+\t  tsubst_expr (tmp, args, nargs, in_decl);\n \temit_nop ();\n \temit_line_note (input_filename, lineno);\n \texpand_start_loop_continue_elsewhere (1); \n@@ -2972,6 +2972,15 @@ instantiate_decl (d)\n       start_function (NULL_TREE, d, NULL_TREE, NULL_TREE, 1);\n       store_parm_decls ();\n \n+      if (t && TREE_CODE (t) == RETURN_INIT)\n+\t{\n+\t  store_return_init\n+\t    (TREE_OPERAND (t, 0),\n+\t     tsubst_expr (TREE_OPERAND (t, 1), &TREE_VEC_ELT (args, 0),\n+\t\t\t  TREE_VEC_LENGTH (args), tmpl));\n+\t  t = TREE_CHAIN (t);\n+\t}\n+\n       if (t && TREE_CODE (t) == CTOR_INITIALIZER)\n \t{\n \t  current_member_init_list"}, {"sha": "295e3dc3aa5106a4a6221b10820be5978d728503", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -185,7 +185,10 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n \n     TREE_CHAIN (optr) = sptr;\n     TYPE_FIELDS (t) = optr;\n-    TYPE_ALIGN (t) = TYPE_ALIGN (optr_type);\n+    /* Allow signature pointers/references to be grabbed 2 words at a time.\n+       For this to work on a Sparc, we need 8-byte alignment.  */\n+    TYPE_ALIGN (t) = MAX (TYPE_ALIGN (double_type_node),\n+\t\t\t  TYPE_ALIGN (optr_type));\n \n     /* A signature pointer/reference type isn't a `real' class type.  */\n     IS_AGGR_TYPE (t) = 0;"}, {"sha": "6334f3de4cbcc423448ba12fdd3f083599a74b76", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -442,6 +442,9 @@ cp_build_type_variant (type, constp, volatilep)\n      tree type;\n      int constp, volatilep;\n {\n+  if (type == error_mark_node)\n+    return type;\n+  \n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree real_main_variant = TYPE_MAIN_VARIANT (type);\n@@ -1578,27 +1581,32 @@ mapcar (t, func)\n       return t;\n \n     case POINTER_TYPE:\n-      return build_pointer_type (mapcar (TREE_TYPE (t), func));\n+      tmp = build_pointer_type (mapcar (TREE_TYPE (t), func));\n+      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n     case REFERENCE_TYPE:\n-      return build_reference_type (mapcar (TREE_TYPE (t), func));\n+      tmp = build_reference_type (mapcar (TREE_TYPE (t), func));\n+      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n     case FUNCTION_TYPE:\n-      return build_function_type (mapcar (TREE_TYPE (t), func),\n-\t\t\t\t  mapcar (TYPE_ARG_TYPES (t), func));\n+      tmp = build_function_type (mapcar (TREE_TYPE (t), func),\n+\t\t\t\t mapcar (TYPE_ARG_TYPES (t), func));\n+      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n     case ARRAY_TYPE:\n-      return build_array_type (mapcar (TREE_TYPE (t), func),\n-\t\t\t       mapcar (TYPE_DOMAIN (t), func));\n+      tmp = build_array_type (mapcar (TREE_TYPE (t), func),\n+\t\t\t      mapcar (TYPE_DOMAIN (t), func));\n+      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n     case INTEGER_TYPE:\n-      return build_index_type (mapcar (TYPE_MAX_VALUE (t), func));\n-\n+      tmp = build_index_type (mapcar (TYPE_MAX_VALUE (t), func));\n+      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n     case OFFSET_TYPE:\n-      return build_offset_type (mapcar (TYPE_OFFSET_BASETYPE (t), func),\n-\t\t\t\tmapcar (TREE_TYPE (t), func));\n+      tmp = build_offset_type (mapcar (TYPE_OFFSET_BASETYPE (t), func),\n+\t\t\t       mapcar (TREE_TYPE (t), func));\n+      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n     case METHOD_TYPE:\n-      return build_method_type\n-\t(mapcar (TYPE_METHOD_BASETYPE (t), func),\n-\t build_function_type\n-\t (mapcar (TREE_TYPE (t), func),\n-\t  mapcar (TREE_CHAIN (TYPE_ARG_TYPES (t)), func)));\n+      tmp = build_cplus_method_type\n+\t(mapcar (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))), func),\n+\t mapcar (TREE_TYPE (t), func),\n+\t mapcar (TREE_CHAIN (TYPE_ARG_TYPES (t)), func));\n+      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n \n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n@@ -1607,7 +1615,7 @@ mapcar (t, func)\n       /* else fall through */\n       \n       /*  This list is incomplete, but should suffice for now.\n-\t  It is very important that `sorry' does not call\n+\t  It is very important that `sorry' not call\n \t  `report_error_function'.  That could cause an infinite loop.  */\n     default:\n       sorry (\"initializer contains unrecognized tree code\");\n@@ -1988,3 +1996,17 @@ vec_binfo_member (elem, vec)\n       return TREE_VEC_ELT (vec, i);\n   return NULL_TREE;\n }\n+\n+/* Kludge around the fact that DECL_CONTEXT for virtual functions returns\n+   the wrong thing for decl_function_context.  Hopefully the uses in the\n+   backend won't matter, since we don't need a static chain for local class\n+   methods.  FIXME!  */\n+\n+tree\n+hack_decl_function_context (decl)\n+     tree decl;\n+{\n+  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_FUNCTION_MEMBER_P (decl))\n+    return decl_function_context (TYPE_MAIN_DECL (DECL_CLASS_CONTEXT (decl)));\n+  return decl_function_context (decl);\n+}"}, {"sha": "c3fdb798d6bd136a1fec6d76697f45967918175f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e76a26469d6b464cf25d43af1eb4f1ebbc4c72a0", "patch": "@@ -134,7 +134,7 @@ complete_type (type)\n \ttype = build_cplus_array_type (t, TYPE_DOMAIN (type));\n     }\n   else if (IS_AGGR_TYPE (type) && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n-    instantiate_class_template (type);\n+    instantiate_class_template (TYPE_MAIN_VARIANT (type));\n \n   return type;\n }\n@@ -796,6 +796,11 @@ comptypes (type1, type2, strict)\n \n     case TEMPLATE_TYPE_PARM:\n       return TEMPLATE_TYPE_IDX (t1) == TEMPLATE_TYPE_IDX (t2);\n+\n+    case TYPENAME_TYPE:\n+      if (TYPE_IDENTIFIER (t1) != TYPE_IDENTIFIER (t2))\n+\treturn 0;\n+      return comptypes (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2), 1);\n     }\n   return attrval == 2 && val == 1 ? 2 : val;\n }\n@@ -2350,7 +2355,8 @@ build_x_function_call (function, params, decl)\n       if (TREE_CODE (type) == REFERENCE_TYPE)\n \ttype = TREE_TYPE (type);\n \n-      if (TYPE_LANG_SPECIFIC (type) && TYPE_OVERLOADS_CALL_EXPR (type))\n+      if (TYPE_LANG_SPECIFIC (type)\n+\t  && TYPE_OVERLOADS_CALL_EXPR (complete_type (type)))\n \treturn build_opfncall (CALL_EXPR, LOOKUP_NORMAL, function, params, NULL_TREE);\n     }\n \n@@ -2778,7 +2784,7 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t  /* Formal parm type is specified by a function prototype.  */\n \t  tree parmval;\n \n-\t  if (TYPE_SIZE (type) == 0)\n+\t  if (TYPE_SIZE (complete_type (type)) == 0)\n \t    {\n \t      error (\"parameter type of called function is incomplete\");\n \t      parmval = val;\n@@ -6920,7 +6926,8 @@ c_expand_return (retval)\n \t  if (TEMP_NAME_P (DECL_NAME (whats_returned)))\n \t    warning (\"reference to non-lvalue returned\");\n \t  else if (! TREE_STATIC (whats_returned)\n-\t\t   && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned)))\n+\t\t   && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned))\n+\t\t   && !TREE_PUBLIC (whats_returned))\n \t    cp_warning_at (\"reference to local variable `%D' returned\", whats_returned);\n \t}\n     }\n@@ -6931,7 +6938,8 @@ c_expand_return (retval)\n       if (TREE_CODE (whats_returned) == VAR_DECL\n \t  && DECL_NAME (whats_returned)\n \t  && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned))\n-\t  && !TREE_STATIC (whats_returned))\n+\t  && !TREE_STATIC (whats_returned)\n+\t  && !TREE_PUBLIC (whats_returned))\n \tcp_warning_at (\"address of local variable `%D' returned\", whats_returned);\n     }\n   "}]}