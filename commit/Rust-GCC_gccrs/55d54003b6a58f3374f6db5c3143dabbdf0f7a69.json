{"sha": "55d54003b6a58f3374f6db5c3143dabbdf0f7a69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVkNTQwMDNiNmE1OGYzMzc0ZjZkYjVjMzE0M2RhYmJkZjBmN2E2OQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-29T23:58:08Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-29T23:58:08Z"}, "message": "c-decl.c (last_function_parm_vars, [...]): New static variables.\n\n\t* c-decl.c (last_function_parm_vars, current_function_parm_vars):\n\tNew static variables.\n\t(struct c_scope): Add parms and warned_forward_parm_decls\n\tfields; remove parm_order.\n\t(storedecls, storetags): Delete.\n\t(poplevel): Also clear bindings on the parms chain.\n\t(pushdecl): Handle forward declarations of parameters, and\n\tchain PARM_DECLs on the parms list, not the names list.\n\t(lookup_name_current_level): Check for PARM_DECLs on the parms\n\tlist too.\n\t(push_parm_decl): Don't update parm_order.\n\t(clear_parm_order): Rename mark_forward_parm_decls.  Issue the\n\twarning, only once per parameter list, and set TREE_ASM_WRITTEN\n\ton the decls here.  Then move the forward decls to the names list.\n\t(grokparms): Set last_function_parm_vars.\n\t(get_parm_info): Don't use gettags or getdecls.  No need to\n\textract non-parms from the parms list, or reorganize the parms\n\tlist.  Feed nonparms back in the TREE_TYPE of the list node\n\treturned.  Issue only one error per parameter list for \"void\"\n\tappearing more than once in said parameter list.  Collapse\n\tparmlist_tags_warning into this function to avoid double scan\n\tof tags list.\n\t(start_function): Set current_function_parm_vars.\n\t(store_parm_decls_newstyle): Bypass pushdecl, manipulate scope\n\tdirectly.  Get non-parms from current_function_parm_vars; no\n\tneed to extract them from the parms chain.  Properly bind tags\n\tin the new scope.\n\t(store_parm_decls_oldstyle): No need to extract non-parameters\n\tfrom the parms chain, nor to store them back afterward.  Move\n\tdeclaration to top of function, restructure code reordering\n\tDECL_ARGUMENTS.\n\t(store_parm_decls): No need to save and restore warn_shadow.\n\t* c-parse.in: Don't call parmlist_tags_warning nor\n\tclear_parm_order.  Call mark_forward_parm_decls when forward\n\tparm decls are encountered.\n\t* c-tree.h: Prototype mark_forward_parm_decls; not\n\tclear_parm_order or parmlist_tags_warning.\n\ntestsuite:\n\t* gcc.dg/struct-in-proto-1.c: New test.\n\nFrom-SVN: r69945", "tree": {"sha": "fc99c4938074bab89837359b94d5e2bac42be0ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc99c4938074bab89837359b94d5e2bac42be0ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55d54003b6a58f3374f6db5c3143dabbdf0f7a69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d54003b6a58f3374f6db5c3143dabbdf0f7a69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d54003b6a58f3374f6db5c3143dabbdf0f7a69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/comments", "author": null, "committer": null, "parents": [{"sha": "18c8152070f9939739b297a4f133db1ca2387b6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c8152070f9939739b297a4f133db1ca2387b6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c8152070f9939739b297a4f133db1ca2387b6d"}], "stats": {"total": 550, "additions": 301, "deletions": 249}, "files": [{"sha": "419fba7e80d0c5ecfb0cafef97cd6c07d214da65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55d54003b6a58f3374f6db5c3143dabbdf0f7a69", "patch": "@@ -1,3 +1,43 @@\n+2003-07-29  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-decl.c (last_function_parm_vars, current_function_parm_vars):\n+\tNew static variables.\n+\t(struct c_scope): Add parms and warned_forward_parm_decls\n+\tfields; remove parm_order.\n+\t(storedecls, storetags): Delete.\n+\t(poplevel): Also clear bindings on the parms chain.\n+\t(pushdecl): Handle forward declarations of parameters, and\n+\tchain PARM_DECLs on the parms list, not the names list.\n+\t(lookup_name_current_level): Check for PARM_DECLs on the parms\n+\tlist too.\n+\t(push_parm_decl): Don't update parm_order.\n+\t(clear_parm_order): Rename mark_forward_parm_decls.  Issue the\n+\twarning, only once per parameter list, and set TREE_ASM_WRITTEN\n+\ton the decls here.  Then move the forward decls to the names list.\n+\t(grokparms): Set last_function_parm_vars.\n+\t(get_parm_info): Don't use gettags or getdecls.  No need to\n+\textract non-parms from the parms list, or reorganize the parms\n+\tlist.  Feed nonparms back in the TREE_TYPE of the list node\n+\treturned.  Issue only one error per parameter list for \"void\"\n+\tappearing more than once in said parameter list.  Collapse\n+\tparmlist_tags_warning into this function to avoid double scan\n+\tof tags list.\n+\t(start_function): Set current_function_parm_vars.\n+\t(store_parm_decls_newstyle): Bypass pushdecl, manipulate scope\n+\tdirectly.  Get non-parms from current_function_parm_vars; no\n+\tneed to extract them from the parms chain.  Properly bind tags\n+\tin the new scope.\n+\t(store_parm_decls_oldstyle): No need to extract non-parameters\n+\tfrom the parms chain, nor to store them back afterward.  Move\n+\tdeclaration to top of function, restructure code reordering\n+\tDECL_ARGUMENTS.\n+\t(store_parm_decls): No need to save and restore warn_shadow.\n+\t* c-parse.in: Don't call parmlist_tags_warning nor\n+\tclear_parm_order.  Call mark_forward_parm_decls when forward\n+\tparm decls are encountered.\n+\t* c-tree.h: Prototype mark_forward_parm_decls; not\n+\tclear_parm_order or parmlist_tags_warning.\n+\n 2003-07-29  Geoffrey Keating  <geoffk@apple.com>\n \n \t* c-common.c (allow_pch): Remove."}, {"sha": "8259fb9ff559131aa5c073ca4a55edba04491131", "filename": "gcc/c-decl.c", "status": "modified", "additions": 243, "deletions": 232, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=55d54003b6a58f3374f6db5c3143dabbdf0f7a69", "patch": "@@ -93,6 +93,11 @@ static tree last_function_parms;\n \n static tree last_function_parm_tags;\n \n+/* ... and a chain of all non-parameter declarations (such as\n+   CONST_DECLs from enumerations) here.  */\n+\n+static tree last_function_parm_vars;\n+\n /* After parsing the declarator that starts a function definition,\n    `start_function' puts the list of parameter names or chain of decls here\n    for `store_parm_decls' to find.  */\n@@ -103,6 +108,10 @@ static tree current_function_parms;\n \n static tree current_function_parm_tags;\n \n+/* And for last_function_parm_vars.  */\n+\n+static tree current_function_parm_vars;\n+\n /* Similar, for the file and line that the prototype came from if this is\n    an old-style definition.  */\n \n@@ -177,6 +186,10 @@ struct c_scope GTY(())\n      They are in the reverse of the order supplied.  */\n   tree names;\n \n+  /* All parameter declarations.  Used only in the outermost scope of\n+     a function.  Again, in the reverse of the order supplied.  */\n+  tree parms;\n+\n   /* All structure, union, and enum type tags.  */\n   tree tags;\n \n@@ -199,15 +212,15 @@ struct c_scope GTY(())\n   /* Variable declarations with incomplete type in this scope.  */\n   tree incomplete_list;\n \n-  /* A list of decls giving the (reversed) specified order of parms,\n-     not including any forward-decls in the parmlist.\n-     This is so we can put the parms in proper order for assign_parms.  */\n-  tree parm_order;\n-\n   /* True if we are currently filling this scope with parameter\n      declarations.  */\n   bool parm_flag : 1;\n \n+  /* True if we already complained about forward parameter decls\n+     in this scope.  This prevents double warnings on\n+     foo (int a; int b; ...)  */\n+  bool warned_forward_parm_decls : 1;\n+\n   /* True if this is the outermost block scope of a function body.\n      This scope contains the parameters, the local variables declared\n      in the outermost block, and all the labels (except those in\n@@ -261,8 +274,6 @@ static int redeclaration_error_message (tree, tree);\n static tree make_label (tree, location_t);\n static void bind_label (tree, tree, struct c_scope *);\n static void implicit_decl_warning (tree);\n-static void storedecls (tree);\n-static void storetags (tree);\n static tree lookup_tag (enum tree_code, tree, int);\n static tree lookup_name_current_level (tree);\n static tree grokdeclarator (tree, tree, enum decl_context, int);\n@@ -525,6 +536,12 @@ poplevel (int keep, int reverse, int functionbody)\n \tTREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (link)) = 1;\n     }\n \n+  /* Clear out the parameter bindings declared in this scope.\n+     Unused-parameter warnings are handled by function.c.  */\n+  for (link = current_scope->parms; link; link = TREE_CHAIN (link))\n+    if (DECL_NAME (link))\n+      IDENTIFIER_SYMBOL_VALUE (DECL_NAME (link)) = 0;\n+\n   /* Clear out the tag-meanings declared in this scope.  */\n   for (link = tags; link; link = TREE_CHAIN (link))\n     if (TREE_PURPOSE (link))\n@@ -1657,7 +1674,24 @@ pushdecl (tree x)\n \n       old = lookup_name_current_level (name);\n       if (old && duplicate_decls (x, old, 0, false))\n-\treturn old;\n+\t{\n+\t  /* For PARM_DECLs, old may be a forward declaration.\n+\t     If so, we want to remove it from its old location\n+\t     (in the variables chain) and rechain it in the\n+\t     location given by the new declaration.  */\n+\t  if (TREE_CODE (x) == PARM_DECL)\n+\t    {\n+\t      tree *p;\n+\t      for (p = &scope->names; *p; p = &TREE_CHAIN (*p))\n+\t\tif (*p == old)\n+\t\t  {\n+\t\t    *p = TREE_CHAIN (old);\n+\t\t    TREE_CHAIN (old) = scope->parms;\n+\t\t    scope->parms = old;\n+\t\t  }\n+\t    }\n+\t  return old;\n+\t}\n       if (DECL_EXTERNAL (x) || scope == global_scope)\n \t{\n \t  /* Find and check against a previous, not-in-scope, external\n@@ -1720,8 +1754,16 @@ pushdecl (tree x)\n \n   /* Put decls on list in reverse order.\n      We will reverse them later if necessary.  */\n-  TREE_CHAIN (x) = scope->names;\n-  scope->names = x;\n+  if (TREE_CODE (x) == PARM_DECL)\n+    {\n+      TREE_CHAIN (x) = scope->parms;\n+      scope->parms = x;\n+    }\n+  else\n+    {\n+      TREE_CHAIN (x) = scope->names;\n+      scope->names = x;\n+    }\n \n   return x;\n }\n@@ -2125,24 +2167,6 @@ gettags (void)\n {\n   return current_scope->tags;\n }\n-\n-/* Store the list of declarations of the current scope.\n-   This is done for the parameter declarations of a function being defined,\n-   after they are modified in the light of any missing parameters.  */\n-\n-static void\n-storedecls (tree decls)\n-{\n-  current_scope->names = decls;\n-}\n-\n-/* Similarly, store the list of tags of the current scope.  */\n-\n-static void\n-storetags (tree tags)\n-{\n-  current_scope->tags = tags;\n-}\n \f\n /* Given NAME, an IDENTIFIER_NODE,\n    return the structure (or union or enum) definition for that name.\n@@ -2233,7 +2257,12 @@ lookup_name_current_level (tree name)\n   if (current_scope == global_scope)\n     return decl;\n \n-  /* Scan the current scope for a decl with name NAME.  */\n+  /* Scan the current scope for a decl with name NAME.\n+     For PARM_DECLs, we have to look at both ->parms and ->names, since\n+     forward parameter declarations wind up on the ->names list.  */\n+  if (TREE_CODE (decl) == PARM_DECL\n+      && chain_member (decl, current_scope->parms))\n+    return decl;\n   if (chain_member (decl, current_scope->names))\n     return decl;\n \n@@ -2987,10 +3016,8 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n     }\n }\n \n-/* Given a parsed parameter declaration,\n-   decode it into a PARM_DECL and push that on the current scope.\n-   Also, for the sake of forward parm decls,\n-   record the given order of parms in `parm_order'.  */\n+/* Given a parsed parameter declaration, decode it into a PARM_DECL\n+   and push that on the current scope.  */\n \n void\n push_parm_decl (tree parm)\n@@ -3008,22 +3035,34 @@ push_parm_decl (tree parm)\n \n   decl = pushdecl (decl);\n \n-  current_scope->parm_order\n-    = tree_cons (NULL_TREE, decl, current_scope->parm_order);\n-\n   finish_decl (decl, NULL_TREE, NULL_TREE);\n \n   immediate_size_expand = save_immediate_size_expand;\n }\n \n-/* Clear the given order of parms in `parm_order'.\n-   Used at start of parm list,\n-   and also at semicolon terminating forward decls.  */\n+/* Shift all the existing parameter decls to the variables list,\n+   and reset the parameters list.  Used when a ; terminating\n+   forward parameter decls is encountered.  */\n \n void\n-clear_parm_order (void)\n+mark_forward_parm_decls (void)\n {\n-  current_scope->parm_order = NULL_TREE;\n+  tree parm, last;\n+\n+  if (pedantic && !current_scope->warned_forward_parm_decls)\n+    {\n+      pedwarn (\"ISO C forbids forward parameter declarations\");\n+      current_scope->warned_forward_parm_decls = true;\n+    }\n+\n+  for (last = 0, parm = current_scope->parms;\n+       parm;\n+       last = parm, parm = TREE_CHAIN (parm))\n+    TREE_ASM_WRITTEN (parm) = 1;\n+\n+  TREE_CHAIN (last)    = current_scope->names;\n+  current_scope->names = current_scope->parms;\n+  current_scope->parms = 0;\n }\n \f\n static GTY(()) int compound_literal_number;\n@@ -4476,6 +4515,7 @@ grokparms (tree parms_info, int funcdef_flag)\n \n   last_function_parms = TREE_PURPOSE (parms_info);\n   last_function_parm_tags = TREE_VALUE (parms_info);\n+  last_function_parm_vars = TREE_TYPE (parms_info);\n \n   if (warn_strict_prototypes && first_parm == 0 && !funcdef_flag\n       && !in_system_header)\n@@ -4534,6 +4574,8 @@ grokparms (tree parms_info, int funcdef_flag)\n    The TREE_PURPOSE is a list of decls of those parms.\n    The TREE_VALUE is a list of structure, union and enum tags defined.\n    The TREE_CHAIN is a list of argument types to go in the FUNCTION_TYPE.\n+   The TREE_TYPE is a list of non-parameter decls which appeared with the\n+   parameters.\n    This tree_list node is later fed to `grokparms'.\n \n    VOID_AT_END nonzero means append `void' to the end of the type-list.\n@@ -4542,144 +4584,124 @@ grokparms (tree parms_info, int funcdef_flag)\n tree\n get_parm_info (int void_at_end)\n {\n-  tree decl, t;\n+  tree decl, type, list;\n   tree types = 0;\n-  int erred = 0;\n-  tree tags = gettags ();\n-  tree parms = getdecls ();\n-  tree new_parms = 0;\n-  tree order = current_scope->parm_order;\n-\n-  /* Just `void' (and no ellipsis) is special.  There are really no parms.\n-     But if the `void' is qualified (by `const' or `volatile') or has a\n-     storage class specifier (`register'), then the behavior is undefined;\n-     by not counting it as the special case of `void' we will cause an\n-     error later.  Typedefs for `void' are OK (see DR#157).  */\n+  tree *last_type = &types;\n+  tree tags = current_scope->tags;\n+  tree parms = current_scope->parms;\n+  tree others = current_scope->names;\n+  static bool explained_incomplete_types = false;\n+  bool gave_void_only_once_err = false;\n+\n+  /* Just \"void\" (and no ellipsis) is special.  There are really no parms.\n+     But if the \"void\" is qualified (by \"const\" or \"volatile\"), or has a\n+     storage class specifier (\"register\"), then the behavior is undefined;\n+     issue an error.  Typedefs for \"void\" are OK (see DR#157).  */\n   if (void_at_end && parms != 0\n       && TREE_CHAIN (parms) == 0\n       && VOID_TYPE_P (TREE_TYPE (parms))\n-      && ! TREE_THIS_VOLATILE (parms)\n-      && ! TREE_READONLY (parms)\n-      && ! DECL_REGISTER (parms)\n-      && DECL_NAME (parms) == 0)\n+      && !DECL_NAME (parms))\n     {\n-      parms = NULL_TREE;\n-      storedecls (NULL_TREE);\n-      return tree_cons (NULL_TREE, NULL_TREE,\n-\t\t\ttree_cons (NULL_TREE, void_type_node, NULL_TREE));\n+      if (TREE_THIS_VOLATILE (parms)\n+\t  || TREE_READONLY (parms)\n+\t  || DECL_REGISTER (parms))\n+\terror (\"\\\"void\\\" as only parameter may not be qualified\");\n+\n+      return tree_cons (0, 0, tree_cons (0, void_type_node, 0));\n     }\n \n-  /* Extract enumerator values and other non-parms declared with the parms.\n-     Likewise any forward parm decls that didn't have real parm decls.  */\n-  for (decl = parms; decl;)\n-    {\n-      tree next = TREE_CHAIN (decl);\n+  if (parms)\n+    current_scope->parms = parms = nreverse (parms);\n \n+  /* Sanity check all of the parameter declarations.  */\n+  for (decl = parms; decl; decl = TREE_CHAIN (decl))\n+    {\n       if (TREE_CODE (decl) != PARM_DECL)\n+\tabort ();\n+      if (TREE_ASM_WRITTEN (decl))\n+\tabort ();\n+\n+      /* Since there is a prototype, args are passed in their\n+\t declared types.  The back end may override this.  */\n+      type = TREE_TYPE (decl);\n+      DECL_ARG_TYPE (decl) = type;\n+      if (PROMOTE_PROTOTYPES\n+\t  && INTEGRAL_TYPE_P (type)\n+\t  && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n+\tDECL_ARG_TYPE (decl) = integer_type_node;\n+\n+      /* Check for (..., void, ...) and issue an error.  */\n+      if (VOID_TYPE_P (type) && !DECL_NAME (decl) && !gave_void_only_once_err)\n \t{\n-\t  TREE_CHAIN (decl) = new_parms;\n-\t  new_parms = decl;\n-\t}\n-      else if (TREE_ASM_WRITTEN (decl))\n-\t{\n-\t  error (\"%Hparameter '%D' has just a forward declaration\",\n-                 &DECL_SOURCE_LOCATION (decl), decl);\n-\t  TREE_CHAIN (decl) = new_parms;\n-\t  new_parms = decl;\n+\t  error (\"\\\"void\\\" must be the only parameter\");\n+\t  gave_void_only_once_err = true;\n \t}\n-      decl = next;\n-    }\n \n-  /* Put the parm decls back in the order they were in in the parm list.  */\n-  for (t = order; t; t = TREE_CHAIN (t))\n-    {\n-      if (TREE_CHAIN (t))\n-\tTREE_CHAIN (TREE_VALUE (t)) = TREE_VALUE (TREE_CHAIN (t));\n-      else\n-\tTREE_CHAIN (TREE_VALUE (t)) = 0;\n+      type = build_tree_list (0, type);\n+      *last_type = type;\n+      last_type = &TREE_CHAIN (type);\n     }\n \n-  new_parms = chainon (order ? nreverse (TREE_VALUE (order)) : 0,\n-\t\t       new_parms);\n-\n-  /* Store the parmlist in the scope structure since the old one\n-     is no longer a valid list.  (We have changed the chain pointers.)  */\n-  storedecls (new_parms);\n-\n-  for (decl = new_parms; decl; decl = TREE_CHAIN (decl))\n-    /* There may also be declarations for enumerators if an enumeration\n-       type is declared among the parms.  Ignore them here.  */\n+  /* Check the list of non-parameter decls for any forward parm decls\n+     that never got real decls.  */\n+  for (decl = others; decl; decl = TREE_CHAIN (decl))\n     if (TREE_CODE (decl) == PARM_DECL)\n       {\n-\t/* Since there is a prototype,\n-\t   args are passed in their declared types.  */\n-\ttree type = TREE_TYPE (decl);\n-\tDECL_ARG_TYPE (decl) = type;\n-\tif (PROMOTE_PROTOTYPES\n-\t    && INTEGRAL_TYPE_P (type)\n-\t    && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n-\t  DECL_ARG_TYPE (decl) = integer_type_node;\n-\n-\ttypes = tree_cons (NULL_TREE, TREE_TYPE (decl), types);\n-\tif (VOID_TYPE_P (TREE_VALUE (types)) && ! erred\n-\t    && DECL_NAME (decl) == 0)\n-\t  {\n-\t    error (\"`void' in parameter list must be the entire list\");\n-\t    erred = 1;\n-\t  }\n-      }\n-\n-  if (void_at_end)\n-    return tree_cons (new_parms, tags,\n-\t\t      nreverse (tree_cons (NULL_TREE, void_type_node, types)));\n-\n-  return tree_cons (new_parms, tags, nreverse (types));\n-}\n-\n-/* At end of parameter list, warn about any struct, union or enum tags\n-   defined within.  Do so because these types cannot ever become complete.  */\n+\tif (!TREE_ASM_WRITTEN (decl))\n+\t  abort ();\n \n-void\n-parmlist_tags_warning (void)\n-{\n-  tree elt;\n-  static int already;\n+\t  error (\"%Hparameter \\\"%D\\\" has just a forward declaration\",\n+\t\t &DECL_SOURCE_LOCATION (decl), decl);\n+      }\n \n-  for (elt = current_scope->tags; elt; elt = TREE_CHAIN (elt))\n+  /* Warn about any struct, union or enum tags defined within this\n+     list.  The scope of such types is limited to this declaration,\n+     which is rarely if ever desirable (it's impossible to call such\n+     a function with type-correct arguments).  */\n+  for (decl = tags; decl; decl = TREE_CHAIN (decl))\n     {\n-      enum tree_code code = TREE_CODE (TREE_VALUE (elt));\n+      enum tree_code code = TREE_CODE (TREE_VALUE (decl));\n+      const char *keyword;\n       /* An anonymous union parm type is meaningful as a GNU extension.\n \t So don't warn for that.  */\n-      if (code == UNION_TYPE && TREE_PURPOSE (elt) == 0 && !pedantic)\n+      if (code == UNION_TYPE && TREE_PURPOSE (decl) == 0 && !pedantic)\n \tcontinue;\n-      if (TREE_PURPOSE (elt) != 0)\n-        {\n-          if (code == RECORD_TYPE)\n-            warning (\"`struct %s' declared inside parameter list\",\n-                     IDENTIFIER_POINTER (TREE_PURPOSE (elt)));\n-          else if (code == UNION_TYPE)\n-            warning (\"`union %s' declared inside parameter list\",\n-                     IDENTIFIER_POINTER (TREE_PURPOSE (elt)));\n-          else\n-            warning (\"`enum %s' declared inside parameter list\",\n-                     IDENTIFIER_POINTER (TREE_PURPOSE (elt)));\n-        }\n-      else\n+\n+      /* The keyword should not be translated.  */\n+      switch (code)\n \t{\n-\t  /* For translation these need to be separate warnings */\n-\t  if (code == RECORD_TYPE)\n-\t    warning (\"anonymous struct declared inside parameter list\");\n-\t  else if (code == UNION_TYPE)\n-\t    warning (\"anonymous union declared inside parameter list\");\n-\t  else\n-\t    warning (\"anonymous enum declared inside parameter list\");\n+\tcase RECORD_TYPE:   keyword = \"struct\"; break;\n+\tcase UNION_TYPE:    keyword = \"union\";  break;\n+\tcase ENUMERAL_TYPE: keyword = \"enum\";   break;\n+\tdefault: abort ();\n \t}\n-      if (! already)\n+\n+      if (TREE_PURPOSE (decl)) \n+\t/* The first %s will be one of 'struct', 'union', or 'enum'.  */\n+\twarning (\"\\\"%s %s\\\" declared inside parameter list\",\n+\t\t keyword, IDENTIFIER_POINTER (TREE_PURPOSE (decl)));\n+      else\n+\t/* The %s will be one of 'struct', 'union', or 'enum'.  */\n+\twarning (\"anonymous %s declared inside parameter list\", keyword);\n+\n+      if (! explained_incomplete_types)\n \t{\n-\t  warning (\"its scope is only this definition or declaration, which is probably not what you want\");\n-\t  already = 1;\n+\t  warning (\"its scope is only this definition or declaration,\"\n+\t\t   \" which is probably not what you want\");\n+\t  explained_incomplete_types = true;\n \t}\n     }\n+\n+\n+  if (void_at_end)\n+    {\n+      type = build_tree_list (0, void_type_node);\n+      *last_type = type;\n+    }\n+\n+  list = tree_cons (parms, tags, types);\n+  TREE_TYPE (list) = others;\n+  return list;\n }\n \f\n /* Get the struct, enum or union (CODE says which) with tag NAME.\n@@ -5544,6 +5566,7 @@ start_function (tree declspecs, tree declarator, tree attributes)\n      where store_parm_decls will find them.  */\n   current_function_parms = last_function_parms;\n   current_function_parm_tags = last_function_parm_tags;\n+  current_function_parm_vars = last_function_parm_vars;\n \n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n      error_mark_node is replaced below (in poplevel) with the BLOCK.  */\n@@ -5725,16 +5748,13 @@ start_function (tree declspecs, tree declarator, tree attributes)\n static void\n store_parm_decls_newstyle (void)\n {\n-  tree decl, next;\n+  tree decl;\n   tree fndecl = current_function_decl;\n   tree parms = current_function_parms;\n   tree tags = current_function_parm_tags;\n+  tree vars = current_function_parm_vars;\n \n-  /* This is anything which appeared in current_function_parms that\n-     wasn't a PARM_DECL.  */\n-  tree nonparms = 0;\n-\n-  if (current_scope->names || current_scope->tags)\n+  if (current_scope->parms || current_scope->names || current_scope->tags)\n     {\n       error (\"%Hold-style parameter declarations in prototyped \"\n \t     \"function definition\", &DECL_SOURCE_LOCATION (fndecl));\n@@ -5744,37 +5764,58 @@ store_parm_decls_newstyle (void)\n       pushlevel (0);\n     }\n \n-  /* Now make all the parameter declarations visible in the function body.  */\n-  parms = nreverse (parms);\n-  for (decl = parms; decl; decl = next)\n+  /* Now make all the parameter declarations visible in the function body.\n+     We can bypass most of the grunt work of pushdecl.  */\n+  for (decl = parms; decl; decl = TREE_CHAIN (decl))\n     {\n-      next = TREE_CHAIN (decl);\n-      if (TREE_CODE (decl) != PARM_DECL)\n-\t{\n-\t  /* If we find an enum constant or a type tag,\n-\t     put it aside for the moment.  */\n-\t  TREE_CHAIN (decl) = 0;\n-\t  nonparms = chainon (nonparms, decl);\n-\t  continue;\n-\t}\n+      DECL_CONTEXT (decl) = current_function_decl;\n \n       if (DECL_NAME (decl) == 0)\n \terror (\"%Hparameter name omitted\", &DECL_SOURCE_LOCATION (decl));\n       else\n-\tpushdecl (decl);\n+\t{\n+\t  if (IDENTIFIER_SYMBOL_VALUE (DECL_NAME (decl)))\n+\t    current_scope->shadowed\n+\t      = tree_cons (DECL_NAME (decl),\n+\t\t\t   IDENTIFIER_SYMBOL_VALUE (DECL_NAME (decl)),\n+\t\t\t   current_scope->shadowed);\n+\t  IDENTIFIER_SYMBOL_VALUE (DECL_NAME (decl)) = decl;\n+\t}\n     }\n+  current_scope->parms = parms;\n \n   /* Record the parameter list in the function declaration.  */\n-  DECL_ARGUMENTS (fndecl) = getdecls ();\n+  DECL_ARGUMENTS (fndecl) = parms;\n \n   /* Now make all the ancillary declarations visible, likewise.  */\n-  for (decl = nonparms; decl; decl = TREE_CHAIN (decl))\n-    if (DECL_NAME (decl) != 0\n-\t&& TYPE_MAIN_VARIANT (TREE_TYPE (decl)) != void_type_node)\n-      pushdecl (decl);\n+  for (decl = vars; decl; decl = TREE_CHAIN (decl))\n+    {\n+      DECL_CONTEXT (decl) = current_function_decl;\n+      if (DECL_NAME (decl)\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (decl)) != void_type_node)\n+\t{\n+\t  if (IDENTIFIER_SYMBOL_VALUE (DECL_NAME (decl)))\n+\t    current_scope->shadowed\n+\t      = tree_cons (DECL_NAME (decl),\n+\t\t\t   IDENTIFIER_SYMBOL_VALUE (DECL_NAME (decl)),\n+\t\t\t   current_scope->shadowed);\n+\t  IDENTIFIER_SYMBOL_VALUE (DECL_NAME (decl)) = decl;\n+\t}\n+    }\n+  current_scope->names = vars;\n \n   /* And all the tag declarations.  */\n-  storetags (tags);\n+  for (decl = tags; decl; decl = TREE_CHAIN (decl))\n+    if (TREE_PURPOSE (decl))\n+      {\n+\tif (IDENTIFIER_TAG_VALUE (TREE_PURPOSE (decl)))\n+\t  current_scope->shadowed_tags\n+\t    = tree_cons (TREE_PURPOSE (decl),\n+\t\t\t IDENTIFIER_SYMBOL_VALUE (TREE_PURPOSE (decl)),\n+\t\t\t current_scope->shadowed_tags);\n+\tIDENTIFIER_TAG_VALUE (TREE_PURPOSE (decl)) = TREE_VALUE (decl);\n+      }\n+  current_scope->tags = tags;\n }\n \n /* Subroutine of store_parm_decls which handles old-style function\n@@ -5783,19 +5824,15 @@ store_parm_decls_newstyle (void)\n static void\n store_parm_decls_oldstyle (void)\n {\n-  tree parm, decl, next;\n+  tree parm, decl, last;\n   tree fndecl = current_function_decl;\n \n   /* This is the identifier list from the function declarator.  */\n   tree parmids = current_function_parms;\n \n-  /* This is anything which appeared in current_scope->names that\n-     wasn't a PARM_DECL.  */\n-  tree nonparms;\n-  \n   /* We use DECL_WEAK as a flag to show which parameters have been\n      seen already, since it is not used on PARM_DECL or CONST_DECL.  */\n-  for (parm = current_scope->names; parm; parm = TREE_CHAIN (parm))\n+  for (parm = current_scope->parms; parm; parm = TREE_CHAIN (parm))\n     DECL_WEAK (parm) = 0;\n \n   /* Match each formal parameter name with its declaration.  Save each\n@@ -5854,24 +5891,12 @@ store_parm_decls_oldstyle (void)\n       DECL_WEAK (decl) = 1;\n     }\n \n-  /* Put anything which is in current_scope->names and which is\n-     not a PARM_DECL onto the list NONPARMS.  (The types of\n-     non-parm things which might appear on the list include\n-     enumerators and NULL-named TYPE_DECL nodes.) Complain about\n-     any actual PARM_DECLs not matched with any names.  */\n+  /* Now examine the parms chain for incomplete declarations\n+     and declarations with no corresponding names.  */\n \n-  nonparms = 0;\n-  for (parm = current_scope->names; parm; parm = next)\n+  for (parm = current_scope->parms; parm; parm = TREE_CHAIN (parm))\n     {\n       const location_t *locus = &DECL_SOURCE_LOCATION (parm);\n-      next = TREE_CHAIN (parm);\n-      TREE_CHAIN (parm) = 0;\n-\n-      if (TREE_CODE (parm) != PARM_DECL)\n-\t{\n-\t  nonparms = chainon (nonparms, parm);\n-\t  continue;\n-\t}\n \n       if (!COMPLETE_TYPE_P (TREE_TYPE (parm)))\n \t{\n@@ -5893,29 +5918,28 @@ store_parm_decls_oldstyle (void)\n \n   /* Chain the declarations together in the order of the list of\n      names.  Store that chain in the function decl, replacing the\n-     list of names.  */\n+     list of names.  Update the current scope to match.  */\n   DECL_ARGUMENTS (fndecl) = 0;\n-  {\n-    tree last;\n-    for (parm = parmids; parm; parm = TREE_CHAIN (parm))\n-      if (TREE_PURPOSE (parm))\n-\tbreak;\n-    if (parm && TREE_PURPOSE (parm))\n-      {\n-\tlast = TREE_PURPOSE (parm);\n-\tDECL_ARGUMENTS (fndecl) = last;\n-\tDECL_WEAK (last) = 0;\n \n-\tfor (parm = TREE_CHAIN (parm); parm; parm = TREE_CHAIN (parm))\n-\t  if (TREE_PURPOSE (parm))\n-\t    {\n-\t      TREE_CHAIN (last) = TREE_PURPOSE (parm);\n-\t      last = TREE_PURPOSE (parm);\n-\t      DECL_WEAK (last) = 0;\n-\t    }\n-\tTREE_CHAIN (last) = 0;\n-      }\n-  }\n+  for (parm = parmids; parm; parm = TREE_CHAIN (parm))\n+    if (TREE_PURPOSE (parm))\n+      break;\n+  if (parm && TREE_PURPOSE (parm))\n+    {\n+      last = TREE_PURPOSE (parm);\n+      DECL_ARGUMENTS (fndecl) = last;\n+      current_scope->parms = last;\n+      DECL_WEAK (last) = 0;\n+\n+      for (parm = TREE_CHAIN (parm); parm; parm = TREE_CHAIN (parm))\n+\tif (TREE_PURPOSE (parm))\n+\t  {\n+\t    TREE_CHAIN (last) = TREE_PURPOSE (parm);\n+\t    last = TREE_PURPOSE (parm);\n+\t    DECL_WEAK (last) = 0;\n+\t  }\n+      TREE_CHAIN (last) = 0;\n+    }\n \n   /* If there was a previous prototype,\n      set the DECL_ARG_TYPE of each argument according to\n@@ -6013,13 +6037,6 @@ store_parm_decls_oldstyle (void)\n \n       TYPE_ACTUAL_ARG_TYPES (TREE_TYPE (fndecl)) = actual;\n     }\n-\n-  /* Now store the final chain of decls for the arguments\n-     as the decl-chain of the current lexical scope.\n-     Put the enumerators in as well, at the front so that\n-     DECL_ARGUMENTS is not modified.  */\n-\n-  storedecls (chainon (nonparms, DECL_ARGUMENTS (fndecl)));\n }\n \n /* Store the parameter declarations into the current function declaration.\n@@ -6041,10 +6058,6 @@ store_parm_decls (void)\n   bool prototype = (current_function_parms\n \t\t    && TREE_CODE (current_function_parms) != TREE_LIST);\n \n-  /* Don't re-emit shadow warnings.  */\n-  bool saved_warn_shadow = warn_shadow;\n-  warn_shadow = false;\n-\n   if (prototype)\n     store_parm_decls_newstyle ();\n   else\n@@ -6089,8 +6102,6 @@ store_parm_decls (void)\n      not safe to try to expand expressions involving them.  */\n   immediate_size_expand = 0;\n   cfun->x_dont_save_pending_sizes_p = 1;\n-\n-  warn_shadow = saved_warn_shadow;\n }\n \f\n /* Finish up a function declaration and compile that function"}, {"sha": "dfdd9abd22b2b995c506d804ca7d889438c239b4", "filename": "gcc/c-parse.in", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=55d54003b6a58f3374f6db5c3143dabbdf0f7a69", "patch": "@@ -2478,24 +2478,16 @@ asm_clobbers:\n parmlist:\n \t  maybe_attribute\n \t\t{ pushlevel (0);\n-\t\t  clear_parm_order ();\n \t\t  declare_parm_level (); }\n \t  parmlist_1\n \t\t{ $$ = $3;\n-\t\t  parmlist_tags_warning ();\n \t\t  poplevel (0, 0, 0); }\n \t;\n \n parmlist_1:\n \t  parmlist_2 ')'\n \t| parms ';'\n-\t\t{ tree parm;\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ISO C forbids forward parameter declarations\");\n-\t\t  /* Mark the forward decls as such.  */\n-\t\t  for (parm = getdecls (); parm; parm = TREE_CHAIN (parm))\n-\t\t    TREE_ASM_WRITTEN (parm) = 1;\n-\t\t  clear_parm_order (); }\n+\t\t{ mark_forward_parm_decls (); }\n \t  maybe_attribute\n \t\t{ /* Dummy action so attributes are in known place\n \t\t     on parser stack.  */ }\n@@ -2600,11 +2592,9 @@ setspecs_fp:\n parmlist_or_identifiers:\n \t  maybe_attribute\n \t\t{ pushlevel (0);\n-\t\t  clear_parm_order ();\n \t\t  declare_parm_level (); }\n \t  parmlist_or_identifiers_1\n \t\t{ $$ = $3;\n-\t\t  parmlist_tags_warning ();\n \t\t  poplevel (0, 0, 0); }\n \t;\n "}, {"sha": "f2f27de6ac3da53a2dcdb7cb8bf859549e636ebd", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=55d54003b6a58f3374f6db5c3143dabbdf0f7a69", "patch": "@@ -193,7 +193,7 @@ extern void c_print_identifier (FILE *, tree, int);\n extern tree build_array_declarator (tree, tree, int, int);\n extern tree build_enumerator (tree, tree);\n extern void check_for_loop_decls (void);\n-extern void clear_parm_order (void);\n+extern void mark_forward_parm_decls (void);\n extern int  complete_array_type (tree, tree, int);\n extern void declare_parm_level (void);\n extern void undeclared_variable (tree);\n@@ -211,7 +211,6 @@ extern tree implicitly_declare (tree);\n extern int  in_parm_level_p (void);\n extern void keep_next_level (void);\n extern tree lookup_name (tree);\n-extern void parmlist_tags_warning (void);\n extern void pending_xref_error (void);\n extern void c_push_function_context (struct function *);\n extern void c_pop_function_context (struct function *);"}, {"sha": "ce13803348cecaf7f4e2bfc6d168389e76e8c079", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=55d54003b6a58f3374f6db5c3143dabbdf0f7a69", "patch": "@@ -1,3 +1,7 @@\n+2003-07-29  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gcc.dg/struct-in-proto-1.c: New test.\n+\n 2003-07-29  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* gcc.dg/cpp/include2.c: Only expect one message.\n@@ -25,7 +29,7 @@\n \tPR c++/11667\n \t* g++.dg/init/enum2.C: New test.\n \t* g++.dg/template/overload1.C: Add \"-w\" option.\n-\t\n+\n 2003-07-28    <hp@bitrange.com>\n \n \t* gcc.dg/Wdeclaration-after-statement-1.c,\n@@ -85,7 +89,7 @@\n \n \tPR c++/11517\n \t* g++.dg/expr/cond2.C: New test.\n-\t\n+\n \tPR optimization/10679\n \t* g++.dg/opt/inline4.C: New test.\n \n@@ -96,7 +100,7 @@\n 2003-07-22  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/ext/flexary1.C: New test.\n-\t\n+\n 2003-07-22  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/10793\n@@ -166,7 +170,7 @@\n \n 2003-07-21  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n-        PR optimization/11536\n+\tPR optimization/11536\n \t* gcc.dg/20030721-1.c: New test.\n \n 2003-07-19  Mark Mitchell  <mark@codesourcery.com>"}, {"sha": "162ba914aa93144bc919d4ca66fdf989169c2586", "filename": "gcc/testsuite/gcc.dg/struct-in-proto-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct-in-proto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d54003b6a58f3374f6db5c3143dabbdf0f7a69/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct-in-proto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct-in-proto-1.c?ref=55d54003b6a58f3374f6db5c3143dabbdf0f7a69", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-w\" } */\n+int foo(struct S { int i; } s) {\n+  return sizeof(struct S); /* { dg-bogus \"incomplete type\" \"S visible here\" } */\n+}\n+int bar(void) {\n+  return sizeof(struct S); /* { dg-error \"incomplete type\" \"not here\" } */\n+}"}]}