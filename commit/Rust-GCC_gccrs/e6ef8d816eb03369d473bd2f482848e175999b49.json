{"sha": "e6ef8d816eb03369d473bd2f482848e175999b49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZlZjhkODE2ZWIwMzM2OWQ0NzNiZDJmNDgyODQ4ZTE3NTk5OWI0OQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-22T14:17:07Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-22T14:17:07Z"}, "message": "lambda-code.c: Define VEC(int,heap), VEC(lambda_loop,heap).\n\n\t* lambda-code.c: Define VEC(int,heap), VEC(lambda_loop,heap).\n\t(gcc_tree_to_linear_expression): Convert to heap allocated\n\tvectors.\n\t(gcc_loop_to_lambda_loop, gcc_loopnest_to_lambda_loopnest,\n\tlbv_to_gcc_expression, lle_to_gcc_expression,\n\tlambda_loopnest_to_gcc_loopnest, can_convert_to_perfect_nest,\n\tperfect_nestify): Likewise.\n\tlambda.h (gcc_loopnest_to_lambda_loopnest,\n\tlambda_loopnest_to_gcc_loopnest): Likewise.\n\ttree-loop-linear.c (linear_transform_loops): Likewise.\n\nFrom-SVN: r98561", "tree": {"sha": "a4ade7f681dcdb7f8021ebae6de9da8575b84070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4ade7f681dcdb7f8021ebae6de9da8575b84070"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6ef8d816eb03369d473bd2f482848e175999b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ef8d816eb03369d473bd2f482848e175999b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6ef8d816eb03369d473bd2f482848e175999b49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ef8d816eb03369d473bd2f482848e175999b49/comments", "author": null, "committer": null, "parents": [{"sha": "8ca864d2a8cfd66dadfce83846651504c0975e3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca864d2a8cfd66dadfce83846651504c0975e3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ca864d2a8cfd66dadfce83846651504c0975e3c"}], "stats": {"total": 194, "additions": 102, "deletions": 92}, "files": [{"sha": "0dda76280fd290f129dbe634e5fb964a761b1560", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6ef8d816eb03369d473bd2f482848e175999b49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6ef8d816eb03369d473bd2f482848e175999b49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6ef8d816eb03369d473bd2f482848e175999b49", "patch": "@@ -1,3 +1,16 @@\n+2005-04-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* lambda-code.c: Define VEC(int,heap), VEC(lambda_loop,heap).\n+\t(gcc_tree_to_linear_expression): Convert to heap allocated\n+\tvectors.\n+\t(gcc_loop_to_lambda_loop, gcc_loopnest_to_lambda_loopnest,\n+\tlbv_to_gcc_expression, lle_to_gcc_expression,\n+\tlambda_loopnest_to_gcc_loopnest, can_convert_to_perfect_nest, \n+\tperfect_nestify): Likewise.\n+\tlambda.h (gcc_loopnest_to_lambda_loopnest,\n+\tlambda_loopnest_to_gcc_loopnest): Likewise.\n+\ttree-loop-linear.c (linear_transform_loops): Likewise.\n+\n 2005-04-22  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* config/sparc/predicates.md (arith_double_operand): Use"}, {"sha": "35a5a43f6826175a0e27aa56b133f4cd097a6863", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 80, "deletions": 81, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6ef8d816eb03369d473bd2f482848e175999b49/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6ef8d816eb03369d473bd2f482848e175999b49/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=e6ef8d816eb03369d473bd2f482848e175999b49", "patch": "@@ -115,16 +115,13 @@\n  Fourier-Motzkin elimination is used to compute the bounds of the base space\n  of the lattice.  */\n \n-/* FIXME: I'm sure the vectors used here could be heap allocated.\n-   There certainly should be explicit VEC_frees, either way.  (nathan\n-   2005/04/14) */\n-\n DEF_VEC_P(int);\n-DEF_VEC_ALLOC_P(int,gc);\n+DEF_VEC_ALLOC_P(int,heap);\n \n static bool perfect_nestify (struct loops *, \n-\t\t\t     struct loop *, VEC(tree,gc) *, \n-\t\t\t     VEC(tree,gc) *, VEC(int,gc) *, VEC(tree,gc) *);\n+\t\t\t     struct loop *, VEC(tree,heap) *, \n+\t\t\t     VEC(tree,heap) *, VEC(int,heap) *,\n+\t\t\t     VEC(tree,heap) *);\n /* Lattice stuff that is internal to the code generation algorithm.  */\n \n typedef struct\n@@ -1156,8 +1153,8 @@ lambda_loopnest_transform (lambda_loopnest nest, lambda_trans_matrix trans)\n \n static lambda_linear_expression\n gcc_tree_to_linear_expression (int depth, tree expr,\n-\t\t\t       VEC(tree,gc) *outerinductionvars,\n-\t\t\t       VEC(tree,gc) *invariants, int extra)\n+\t\t\t       VEC(tree,heap) *outerinductionvars,\n+\t\t\t       VEC(tree,heap) *invariants, int extra)\n {\n   lambda_linear_expression lle = NULL;\n   switch (TREE_CODE (expr))\n@@ -1252,12 +1249,12 @@ invariant_in_loop_and_outer_loops (struct loop *loop, tree op)\n \n static lambda_loop\n gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n-\t\t\t VEC(tree,gc) ** invariants,\n+\t\t\t VEC(tree,heap) ** invariants,\n \t\t\t tree * ourinductionvar,\n-\t\t\t VEC(tree,gc) * outerinductionvars,\n-\t\t\t VEC(tree,gc) ** lboundvars,\n-\t\t\t VEC(tree,gc) ** uboundvars,\n-\t\t\t VEC(int,gc) ** steps)\n+\t\t\t VEC(tree,heap) * outerinductionvars,\n+\t\t\t VEC(tree,heap) ** lboundvars,\n+\t\t\t VEC(tree,heap) ** uboundvars,\n+\t\t\t VEC(int,heap) ** steps)\n {\n   tree phi;\n   tree exit_cond;\n@@ -1405,12 +1402,13 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n       return NULL;\n     }\n   /* One part of the test may be a loop invariant tree.  */\n+  VEC_reserve (tree, heap, *invariants, 1);\n   if (TREE_CODE (TREE_OPERAND (test, 1)) == SSA_NAME\n       && invariant_in_loop_and_outer_loops (loop, TREE_OPERAND (test, 1)))\n-    VEC_safe_push (tree, gc, *invariants, TREE_OPERAND (test, 1));\n+    VEC_quick_push (tree, *invariants, TREE_OPERAND (test, 1));\n   else if (TREE_CODE (TREE_OPERAND (test, 0)) == SSA_NAME\n \t   && invariant_in_loop_and_outer_loops (loop, TREE_OPERAND (test, 0)))\n-    VEC_safe_push (tree, gc, *invariants, TREE_OPERAND (test, 0));\n+    VEC_quick_push (tree, *invariants, TREE_OPERAND (test, 0));\n   \n   /* The non-induction variable part of the test is the upper bound variable.\n    */\n@@ -1442,9 +1440,9 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \t\t\t\t\t  *invariants, extra);\n   uboundresult = build (PLUS_EXPR, TREE_TYPE (uboundvar), uboundvar,\n \t\t\tbuild_int_cst (TREE_TYPE (uboundvar), extra));\n-  VEC_safe_push (tree, gc, *uboundvars, uboundresult);\n-  VEC_safe_push (tree, gc, *lboundvars, lboundvar);\n-  VEC_safe_push (int, gc, *steps, stepint);\n+  VEC_safe_push (tree, heap, *uboundvars, uboundresult);\n+  VEC_safe_push (tree, heap, *lboundvars, lboundvar);\n+  VEC_safe_push (int, heap, *steps, stepint);\n   if (!ubound)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1493,7 +1491,7 @@ find_induction_var_from_exit_cond (struct loop *loop)\n }\n \n DEF_VEC_P(lambda_loop);\n-DEF_VEC_ALLOC_P(lambda_loop,gc);\n+DEF_VEC_ALLOC_P(lambda_loop,heap);\n \n /* Generate a lambda loopnest from a gcc loopnest LOOP_NEST.\n    Return the new loop nest.  \n@@ -1505,18 +1503,18 @@ DEF_VEC_ALLOC_P(lambda_loop,gc);\n lambda_loopnest\n gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n \t\t\t\t struct loop * loop_nest,\n-\t\t\t\t VEC(tree,gc) **inductionvars,\n-\t\t\t\t VEC(tree,gc) **invariants,\n+\t\t\t\t VEC(tree,heap) **inductionvars,\n+\t\t\t\t VEC(tree,heap) **invariants,\n \t\t\t\t bool need_perfect_nest)\n {\n-  lambda_loopnest ret;\n+  lambda_loopnest ret = NULL;\n   struct loop *temp;\n   int depth = 0;\n   size_t i;\n-  VEC(lambda_loop,gc) *loops = NULL;\n-  VEC(tree,gc) *uboundvars = NULL;\n-  VEC(tree,gc) *lboundvars  = NULL;\n-  VEC(int,gc) *steps = NULL;\n+  VEC(lambda_loop,heap) *loops = NULL;\n+  VEC(tree,heap) *uboundvars = NULL;\n+  VEC(tree,heap) *lboundvars  = NULL;\n+  VEC(int,heap) *steps = NULL;\n   lambda_loop newloop;\n   tree inductionvar = NULL;\n   \n@@ -1530,8 +1528,8 @@ gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n \t\t\t\t\t &steps);\n       if (!newloop)\n \treturn NULL;\n-      VEC_safe_push (tree, gc, *inductionvars, inductionvar);\n-      VEC_safe_push (lambda_loop, gc, loops, newloop);\n+      VEC_safe_push (tree, heap, *inductionvars, inductionvar);\n+      VEC_safe_push (lambda_loop, heap, loops, newloop);\n       temp = temp->inner;\n     }\n   if (need_perfect_nest)\n@@ -1540,23 +1538,26 @@ gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n \t\t\t    lboundvars, uboundvars, steps, *inductionvars))\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"Not a perfect loop nest and couldn't convert to one.\\n\");    \n-\t  return NULL;\n+\t    fprintf (dump_file,\n+\t\t     \"Not a perfect loop nest and couldn't convert to one.\\n\");    \n+\t  goto fail;\n \t}\n       else if (dump_file)\n-\tfprintf (dump_file, \"Successfully converted loop nest to perfect loop nest.\\n\");\n-\n-      \n+\tfprintf (dump_file,\n+\t\t \"Successfully converted loop nest to perfect loop nest.\\n\");\n     }\n   ret = lambda_loopnest_new (depth, 2 * depth);\n   for (i = 0; VEC_iterate (lambda_loop, loops, i, newloop); i++)\n     LN_LOOPS (ret)[i] = newloop;\n-\n+ fail:\n+  VEC_free (lambda_loop, heap, loops);\n+  VEC_free (tree, heap, uboundvars);\n+  VEC_free (tree, heap, lboundvars);\n+  VEC_free (int, heap, steps);\n+  \n   return ret;\n-\n }\n \n-\n /* Convert a lambda body vector LBV to a gcc tree, and return the new tree. \n    STMTS_TO_INSERT is a pointer to a tree where the statements we need to be\n    inserted for us are stored.  INDUCTION_VARS is the array of induction\n@@ -1565,8 +1566,8 @@ gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n \n static tree\n lbv_to_gcc_expression (lambda_body_vector lbv, \n-\t\t       tree type, VEC(tree,gc) *induction_vars, \n-\t\t       tree * stmts_to_insert)\n+\t\t       tree type, VEC(tree,heap) *induction_vars, \n+\t\t       tree *stmts_to_insert)\n {\n   tree stmts, stmt, resvar, name;\n   tree iv;\n@@ -1648,16 +1649,17 @@ static tree\n lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t       lambda_linear_expression offset,\n \t\t       tree type,\n-\t\t       VEC(tree,gc) *induction_vars,\n-\t\t       VEC(tree,gc) *invariants,\n-\t\t       enum tree_code wrap, tree * stmts_to_insert)\n+\t\t       VEC(tree,heap) *induction_vars,\n+\t\t       VEC(tree,heap) *invariants,\n+\t\t       enum tree_code wrap, tree *stmts_to_insert)\n {\n   tree stmts, stmt, resvar, name;\n   size_t i;\n   tree_stmt_iterator tsi;\n   tree iv, invar;\n-  VEC(tree,gc) *results = NULL;\n+  VEC(tree,heap) *results = NULL;\n \n+  gcc_assert (wrap == MAX_EXPR || wrap == MIN_EXPR);\n   name = NULL_TREE;\n   /* Create a statement list and a linear expression temporary.  */\n   stmts = alloc_stmt_list ();\n@@ -1790,24 +1792,18 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n       /* Handle any denominator that occurs.  */\n       if (LLE_DENOMINATOR (lle) != 1)\n \t{\n-\t  if (wrap == MAX_EXPR)\n-\t    stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\t  build (CEIL_DIV_EXPR, type, name, \n-\t\t\t\t build_int_cst (type, LLE_DENOMINATOR (lle))));\n-\t  else if (wrap == MIN_EXPR)\n-\t    stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\t  build (FLOOR_DIV_EXPR, type, name, \n-\t\t\t\t build_int_cst (type, LLE_DENOMINATOR (lle))));\n-\t  else\n-\t    gcc_unreachable();\n+\t  stmt = build_int_cst (type, LLE_DENOMINATOR (lle));\n+\t  stmt = build (wrap == MAX_EXPR ? CEIL_DIV_EXPR : FLOOR_DIV_EXPR,\n+\t\t\ttype, name, stmt);\n+\t  stmt = build (MODIFY_EXPR, void_type_node, resvar, stmt);\n \n \t  /* name = {ceil, floor}(name/denominator) */\n \t  name = make_ssa_name (resvar, stmt);\n \t  TREE_OPERAND (stmt, 0) = name;\n \t  tsi = tsi_last (stmts);\n \t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n \t}\n-      VEC_safe_push (tree, gc, results, name);\n+      VEC_safe_push (tree, heap, results, name);\n     }\n \n   /* Again, out of laziness, we don't handle this case yet.  It's not\n@@ -1827,6 +1823,8 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n       tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n     }\n \n+  VEC_free (tree, heap, results);\n+  \n   *stmts_to_insert = stmts;\n   return name;\n }\n@@ -1845,16 +1843,15 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \n void\n lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n-\t\t\t\t VEC(tree,gc) *old_ivs,\n-\t\t\t\t VEC(tree,gc) *invariants,\n+\t\t\t\t VEC(tree,heap) *old_ivs,\n+\t\t\t\t VEC(tree,heap) *invariants,\n \t\t\t\t lambda_loopnest new_loopnest,\n \t\t\t\t lambda_trans_matrix transform)\n {\n-\n   struct loop *temp;\n   size_t i = 0;\n   size_t depth = 0;\n-  VEC(tree,gc) *new_ivs = NULL;\n+  VEC(tree,heap) *new_ivs = NULL;\n   tree oldiv;\n   \n   block_stmt_iterator bsi;\n@@ -1889,7 +1886,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       ivvar = create_tmp_var (type, \"lnivtmp\");\n       add_referenced_tmp_var (ivvar);\n \n-      VEC_safe_push (tree, gc, new_ivs, ivvar);\n+      VEC_safe_push (tree, heap, new_ivs, ivvar);\n \n       newloop = LN_LOOPS (new_loopnest)[i];\n \n@@ -2015,9 +2012,9 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t    }\n \t}\n     }\n+  VEC_free (tree, heap, new_ivs);\n }\n \n-\n /* Returns true when the vector V is lexicographically positive, in\n    other words, when the first nonzero element is positive.  */\n \n@@ -2213,7 +2210,7 @@ stmt_uses_op (tree stmt, tree op)\n \n static bool\n can_convert_to_perfect_nest (struct loop *loop,\n-\t\t\t     VEC(tree,gc) *loopivs)\n+\t\t\t     VEC(tree,heap) *loopivs)\n {\n   basic_block *bbs;\n   tree exit_condition, phi;\n@@ -2237,30 +2234,26 @@ can_convert_to_perfect_nest (struct loop *loop,\n \t    { \n \t      size_t j;\n \t      tree stmt = bsi_stmt (bsi);\n+\t      tree iv;\n+\t      \n \t      if (stmt == exit_condition\n \t\t  || not_interesting_stmt (stmt)\n \t\t  || stmt_is_bumper_for_loop (loop, stmt))\n \t\tcontinue;\n \t      /* If the statement uses inner loop ivs, we == screwed.  */\n-\t      for (j = 1; j < VEC_length (tree, loopivs); j++)\n-\t\tif (stmt_uses_op (stmt, VEC_index (tree, loopivs, j)))\n-\t\t  {\n-\t\t    free (bbs);\n-\t\t    return false;\n-\t\t  }\n+\t      for (j = 1; VEC_iterate (tree, loopivs, j, iv); j++)\n+\t\tif (stmt_uses_op (stmt, iv))\n+\t\t  goto fail;\n \t      \n \t      /* If the bb of a statement we care about isn't dominated by \n \t\t the header of the inner loop, then we are also screwed.  */\n \t      if (!dominated_by_p (CDI_DOMINATORS,\n \t\t\t\t   bb_for_stmt (stmt), \n \t\t\t\t   loop->inner->header))\n-\t\t{\n-\t\t  free (bbs);\n-\t\t  return false;\n-\t\t}\n+\t\tgoto fail;\n \t    }\n \t}\n-    }  \n+    }\n \n   /* We also need to make sure the loop exit only has simple copy phis in it,\n      otherwise we don't know how to transform it into a perfect nest right\n@@ -2269,9 +2262,14 @@ can_convert_to_perfect_nest (struct loop *loop,\n   \n   for (phi = phi_nodes (exitdest); phi; phi = PHI_CHAIN (phi))\n     if (PHI_NUM_ARGS (phi) != 1)\n-      return false;\n-\n+      goto fail;\n+  \n+  free (bbs);\n   return true;\n+  \n+ fail:\n+  free (bbs);\n+  return false;\n }\n \n /* Transform the loop nest into a perfect nest, if possible.\n@@ -2313,10 +2311,10 @@ can_convert_to_perfect_nest (struct loop *loop,\n static bool\n perfect_nestify (struct loops *loops,\n \t\t struct loop *loop,\n-\t\t VEC(tree,gc) *lbounds,\n-\t\t VEC(tree,gc) *ubounds,\n-\t\t VEC(int,gc) *steps,\n-\t\t VEC(tree,gc) *loopivs)\n+\t\t VEC(tree,heap) *lbounds,\n+\t\t VEC(tree,heap) *ubounds,\n+\t\t VEC(int,heap) *steps,\n+\t\t VEC(tree,heap) *loopivs)\n {\n   basic_block *bbs;\n   tree exit_condition;\n@@ -2331,7 +2329,7 @@ perfect_nestify (struct loops *loops,\n   tree uboundvar;\n   tree stmt;\n   tree oldivvar, ivvar, ivvarinced;\n-  VEC(tree,gc) *phis = NULL;\n+  VEC(tree,heap) *phis = NULL;\n \n   if (!can_convert_to_perfect_nest (loop, loopivs))\n     return false;\n@@ -2345,7 +2343,7 @@ perfect_nestify (struct loops *loops,\n   /* Push the exit phi nodes that we are moving.  */\n   for (phi = phi_nodes (olddest); phi; phi = PHI_CHAIN (phi))\n     {\n-      VEC_reserve (tree, gc, phis, 2);\n+      VEC_reserve (tree, heap, phis, 2);\n       VEC_quick_push (tree, phis, PHI_RESULT (phi));\n       VEC_quick_push (tree, phis, PHI_ARG_DEF (phi, 0));\n     }\n@@ -2368,8 +2366,9 @@ perfect_nestify (struct loops *loops,\n       phiname = VEC_pop (tree, phis);      \n       phi = create_phi_node (phiname, preheaderbb);\n       add_phi_arg (phi, def, single_pred_edge (preheaderbb));\n-    }       \n+    }\n   flush_pending_stmts (e);\n+  VEC_free (tree, heap, phis);\n \n   bodybb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n   latchbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);"}, {"sha": "d3fdc99687ce55833e9f4710feeceb424b763801", "filename": "gcc/lambda.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6ef8d816eb03369d473bd2f482848e175999b49/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6ef8d816eb03369d473bd2f482848e175999b49/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=e6ef8d816eb03369d473bd2f482848e175999b49", "patch": "@@ -196,13 +196,12 @@ lambda_body_vector lambda_body_vector_compute_new (lambda_trans_matrix,\n void print_lambda_body_vector (FILE *, lambda_body_vector);\n lambda_loopnest gcc_loopnest_to_lambda_loopnest (struct loops *,\n \t\t\t\t\t\t struct loop *,\n-\t\t\t\t\t\t VEC(tree,gc) **,\n-\t\t\t\t\t\t VEC(tree,gc) **,\n+\t\t\t\t\t\t VEC(tree,heap) **,\n+\t\t\t\t\t\t VEC(tree,heap) **,\n \t\t\t\t\t\t bool);\n-void lambda_loopnest_to_gcc_loopnest (struct loop *, VEC(tree,gc) *,\n-\t\t\t\t      VEC(tree,gc) *,\n-\t\t\t\t      lambda_loopnest, \n-\t\t\t\t      lambda_trans_matrix);\n+void lambda_loopnest_to_gcc_loopnest (struct loop *,\n+\t\t\t\t      VEC(tree,heap) *, VEC(tree,heap) *,\n+\t\t\t\t      lambda_loopnest, lambda_trans_matrix);\n \n \n static inline void lambda_vector_negate (lambda_vector, lambda_vector, int);"}, {"sha": "de75de4e531384bcab3704694fbf105c836c2cda", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6ef8d816eb03369d473bd2f482848e175999b49/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6ef8d816eb03369d473bd2f482848e175999b49/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=e6ef8d816eb03369d473bd2f482848e175999b49", "patch": "@@ -243,9 +243,8 @@ void\n linear_transform_loops (struct loops *loops)\n {\n   unsigned int i;\n-  VEC(tree,gc) *oldivs = NULL;  /* FIXME:These should really be on the\n-\t\t\t\t   heap.  (nathan 2005/04/15)*/\n-  VEC(tree,gc) *invariants = NULL;  /* FIXME:Likewise. */\n+  VEC(tree,heap) *oldivs = NULL;\n+  VEC(tree,heap) *invariants = NULL;\n   \n   for (i = 1; i < loops->num; i++)\n     {\n@@ -371,8 +370,8 @@ linear_transform_loops (struct loops *loops)\n       free_dependence_relations (dependence_relations);\n       free_data_refs (datarefs);\n     }\n-  VEC_free (tree, gc, oldivs);\n-  VEC_free (tree, gc, invariants);\n+  VEC_free (tree, heap, oldivs);\n+  VEC_free (tree, heap, invariants);\n   scev_reset ();\n   update_ssa (TODO_update_ssa);\n   rewrite_into_loop_closed_ssa (NULL);"}]}