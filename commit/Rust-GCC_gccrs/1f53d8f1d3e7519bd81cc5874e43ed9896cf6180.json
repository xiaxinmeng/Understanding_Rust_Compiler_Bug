{"sha": "1f53d8f1d3e7519bd81cc5874e43ed9896cf6180", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY1M2Q4ZjFkM2U3NTE5YmQ4MWNjNTg3NGU0M2VkOTg5NmNmNjE4MA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-08-25T19:35:07Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-08-26T12:26:53Z"}, "message": "c++: template operator lookup caching\n\nJason's fix to retain operator lookups inside dependent lambda\nfunctions turns out to be needed on the modules branch for all\ntemplate functions.  Because the context for that lookup no longer\nexists in imports.  There were also a couple of shortcomings, which\nthis patch fixes.\n\n(a) we conflate 'we found nothing' and 'we can redo this at\ninstantiation time'.  Fixed by making the former produce\nerror_mark_node.  That needs a fix in name-lookup to know that finding\na binding containing error_mark_node, means 'stop looking' you found\nnothing.\n\n(b) we'd continually do lookups for every operator, if nothing needed\nto be retained.  Fixed by always caching that information, and then\ndealing with it when pushing the bindings.\n\n(c) if what we found was that find by a global namespace lookup, we'd\nnot cache that.  But that'd cause us to either find decls declared\nafter the template, potentially hiding those we expected to find.  So\ndon't do that check.\n\nThis still retains only recording on lambdas.  As the comment says, we\ncould enable for all templates.\n\n\tgcc/cp/\n\t* decl.c (poplevel): A local-binding tree list holds the name in\n\tTREE_PURPOSE.\n\t* name-lookup.c (update_local_overload): Add id to TREE_PURPOSE.\n\t(lookup_name_1): Deal with local-binding error_mark_node marker.\n\t(op_unqualified_lookup): Return error_mark_node for 'nothing\n\tfound'.  Retain global binding, check class binding here.\n\t(maybe_save_operator_binding): Reimplement to always cache a\n\tresult.\n\t(push_operator_bindings): Deal with 'ignore' marker.\n\tgcc/testsuite/\n\t* g++.dg/lookup/operator-1.C: New.\n\t* g++.dg/lookup/operator-2.C: New.", "tree": {"sha": "ee5325815140f2b204394594cd5c7e108279958a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee5325815140f2b204394594cd5c7e108279958a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f523aaa039cc0ab59791045a840e4e35f1b1eb24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f523aaa039cc0ab59791045a840e4e35f1b1eb24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f523aaa039cc0ab59791045a840e4e35f1b1eb24"}], "stats": {"total": 148, "additions": 108, "deletions": 40}, "files": [{"sha": "5e17e4dc4b1626201cf90a259aa93c159ad953d9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1f53d8f1d3e7519bd81cc5874e43ed9896cf6180", "patch": "@@ -692,8 +692,18 @@ poplevel (int keep, int reverse, int functionbody)\n   /* Remove declarations for all the DECLs in this level.  */\n   for (link = decls; link; link = TREE_CHAIN (link))\n     {\n-      decl = TREE_CODE (link) == TREE_LIST ? TREE_VALUE (link) : link;\n-      tree name = OVL_NAME (decl);\n+      tree name;\n+      if (TREE_CODE (link) == TREE_LIST)\n+\t{\n+\t  decl = TREE_VALUE (link);\n+\t  name = TREE_PURPOSE (link);\n+\t  gcc_checking_assert (name);\n+\t}\n+      else\n+\t{\n+\t  decl = link;\n+\t  name = DECL_NAME (decl);\n+\t}\n \n       /* Remove the binding.  */\n       if (TREE_CODE (decl) == LABEL_DECL)"}, {"sha": "3c2ddc197e6c8472085412e3bc9ff218a81ce288", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 53, "deletions": 38, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=1f53d8f1d3e7519bd81cc5874e43ed9896cf6180", "patch": "@@ -2305,7 +2305,7 @@ update_local_overload (cxx_binding *binding, tree newval)\n     if (*d == binding->value)\n       {\n \t/* Stitch new list node in.  */\n-\t*d = tree_cons (NULL_TREE, NULL_TREE, TREE_CHAIN (*d));\n+\t*d = tree_cons (DECL_NAME (*d), NULL_TREE, TREE_CHAIN (*d));\n \tbreak;\n       }\n     else if (TREE_CODE (*d) == TREE_LIST && TREE_VALUE (*d) == binding->value)\n@@ -3239,7 +3239,7 @@ push_local_binding (tree id, tree decl, bool is_using)\n   if (TREE_CODE (decl) == OVERLOAD || is_using)\n     /* We must put the OVERLOAD or using into a TREE_LIST since we\n        cannot use the decl's chain itself.  */\n-    decl = build_tree_list (NULL_TREE, decl);\n+    decl = build_tree_list (id, decl);\n \n   /* And put DECL on the list of things declared by the current\n      binding level.  */\n@@ -6539,20 +6539,29 @@ lookup_name_1 (tree name, LOOK_where where, LOOK_want want)\n \t\tgcc_assert (TREE_CODE (binding) == TYPE_DECL);\n \t\tcontinue;\n \t      }\n+\n+\t    /* The saved lookups for an operator record 'nothing\n+\t       found' as error_mark_node.  We need to stop the search\n+\t       here, but not return the error mark node.  */\n+\t    if (binding == error_mark_node)\n+\t      binding = NULL_TREE;\n+\n \t    val = binding;\n-\t    break;\n+\t    goto found;\n \t  }\n       }\n \n   /* Now lookup in namespace scopes.  */\n-  if (!val && bool (where & LOOK_where::NAMESPACE))\n+  if (bool (where & LOOK_where::NAMESPACE))\n     {\n       name_lookup lookup (name, want);\n       if (lookup.search_unqualified\n \t  (current_decl_namespace (), current_binding_level))\n \tval = lookup.value;\n     }\n \n+ found:;\n+\n   /* If we have a single function from a using decl, pull it out.  */\n   if (val && TREE_CODE (val) == OVERLOAD && !really_overloaded_fn (val))\n     val = OVL_FUNCTION (val);\n@@ -7598,70 +7607,76 @@ op_unqualified_lookup (tree fnname)\n       cp_binding_level *l = binding->scope;\n       while (l && !l->this_entity)\n \tl = l->level_chain;\n+\n       if (l && uses_template_parms (l->this_entity))\n \t/* Don't preserve decls from an uninstantiated template,\n \t   wait until that template is instantiated.  */\n \treturn NULL_TREE;\n     }\n+\n   tree fns = lookup_name (fnname);\n-  if (fns && fns == get_global_binding (fnname))\n-    /* The instantiation can find these.  */\n-    return NULL_TREE;\n+  if (!fns)\n+    /* Remember we found nothing!  */\n+    return error_mark_node;\n+\n+  tree d = is_overloaded_fn (fns) ? get_first_fn (fns) : fns;\n+  if (DECL_CLASS_SCOPE_P (d))\n+    /* We don't need to remember class-scope functions or declarations,\n+       normal unqualified lookup will find them again.  */\n+    fns = NULL_TREE;\n+\n   return fns;\n }\n \n /* E is an expression representing an operation with dependent type, so we\n    don't know yet whether it will use the built-in meaning of the operator or a\n-   function.  Remember declarations of that operator in scope.  */\n+   function.  Remember declarations of that operator in scope.\n+\n+   We then inject a fake binding of that lookup into the\n+   instantiation's parameter scope.  This approach fails if the user\n+   has different using declarations or directives in different local\n+   binding of the current function from whence we need to do lookups\n+   (we'll cache what we see on the first lookup).  */\n \n-const char *const op_bind_attrname = \"operator bindings\";\n+static const char *const op_bind_attrname = \"operator bindings\";\n \n void\n maybe_save_operator_binding (tree e)\n {\n   /* This is only useful in a generic lambda.  */\n   if (!processing_template_decl)\n     return;\n+\n   tree cfn = current_function_decl;\n   if (!cfn)\n     return;\n \n-  /* Let's only do this for generic lambdas for now, we could do it for all\n-     function templates if we wanted to.  */\n-  if (!current_lambda_expr())\n+  /* Do this for lambdas and code that will emit a CMI.  In a module's\n+     GMF we don't yet know whether there will be a CMI.  */\n+  if (!current_lambda_expr ())\n     return;\n \n   tree fnname = ovl_op_identifier (false, TREE_CODE (e));\n   if (!fnname)\n     return;\n \n   tree attributes = DECL_ATTRIBUTES (cfn);\n-  tree attr = lookup_attribute (op_bind_attrname, attributes);\n-  tree bindings = NULL_TREE;\n-  tree fns = NULL_TREE;\n-  if (attr)\n+  tree op_attr = lookup_attribute (op_bind_attrname, attributes);\n+  if (!op_attr)\n     {\n-      bindings = TREE_VALUE (attr);\n-      if (tree elt = purpose_member (fnname, bindings))\n-\tfns = TREE_VALUE (elt);\n+      op_attr = tree_cons (get_identifier (op_bind_attrname),\n+\t\t\t   NULL_TREE, attributes);\n+      DECL_ATTRIBUTES (cfn) = op_attr;\n     }\n \n-  if (!fns && (fns = op_unqualified_lookup (fnname)))\n+  tree op_bind = purpose_member (fnname, TREE_VALUE (op_attr));\n+  if (!op_bind)\n     {\n-      tree d = is_overloaded_fn (fns) ? get_first_fn (fns) : fns;\n-      if (DECL_P (d) && DECL_CLASS_SCOPE_P (d))\n-\t/* We don't need to remember class-scope functions or declarations,\n-\t   normal unqualified lookup will find them again.  */\n-\treturn;\n+      tree fns = op_unqualified_lookup (fnname);\n \n-      bindings = tree_cons (fnname, fns, bindings);\n-      if (attr)\n-\tTREE_VALUE (attr) = bindings;\n-      else\n-\tDECL_ATTRIBUTES (cfn)\n-\t  = tree_cons (get_identifier (op_bind_attrname),\n-\t\t       bindings,\n-\t\t       attributes);\n+      /* Always record, so we don't keep looking for this\n+\t operator.  */\n+      TREE_VALUE (op_attr) = tree_cons (fnname, fns, TREE_VALUE (op_attr));\n     }\n }\n \n@@ -7684,11 +7699,11 @@ push_operator_bindings ()\n   if (tree attr = lookup_attribute (op_bind_attrname,\n \t\t\t\t    DECL_ATTRIBUTES (decl1)))\n     for (tree binds = TREE_VALUE (attr); binds; binds = TREE_CHAIN (binds))\n-      {\n-\ttree name = TREE_PURPOSE (binds);\n-\ttree val = TREE_VALUE (binds);\n-\tpush_local_binding (name, val, /*using*/true);\n-      }\n+      if (tree val = TREE_VALUE (binds))\n+\t{\n+\t  tree name = TREE_PURPOSE (binds);\n+\t  push_local_binding (name, val, /*using*/true);\n+\t}\n }\n \n #include \"gt-cp-name-lookup.h\""}, {"sha": "98ef376fef58e0327abb439992f79ca6e2422c7d", "filename": "gcc/testsuite/g++.dg/lookup/operator-1.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-1.C?ref=1f53d8f1d3e7519bd81cc5874e43ed9896cf6180", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile { target c++11 } }\n+\n+template <typename T> bool Foo (T x)\n+{\n+  return [](T x) \n+\t { return !x; }(x); // { dg-error \"no match for 'operator!'\" }\n+}\n+\n+namespace X \n+{\n+struct S {};\n+}\n+\n+// not found by adl :)\n+bool operator! (X::S);\n+\n+int main ()\n+{\n+  Foo (X::S{});\n+}"}, {"sha": "46d1d19daf22831fc2a9a6fe128b7824fbefd5d4", "filename": "gcc/testsuite/g++.dg/lookup/operator-2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f53d8f1d3e7519bd81cc5874e43ed9896cf6180/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Foperator-2.C?ref=1f53d8f1d3e7519bd81cc5874e43ed9896cf6180", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct R{};\n+bool operator! (R); // { dg-message \"candidate:\" }\n+\n+template <typename T> bool Foo (T x)\n+{\n+  return [](T x) \n+\t { return !x; }(x); // { dg-error \"no match for 'operator!'\" }\n+}\n+\n+namespace X \n+{\n+struct S {};\n+}\n+\n+// not found by adl :)\n+bool operator! (X::S);\n+\n+int main ()\n+{\n+  Foo (X::S{});\n+}"}]}