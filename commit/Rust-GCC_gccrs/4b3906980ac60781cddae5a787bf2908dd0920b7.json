{"sha": "4b3906980ac60781cddae5a787bf2908dd0920b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIzOTA2OTgwYWM2MDc4MWNkZGFlNWE3ODdiZjI5MDhkZDA5MjBiNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-09-28T19:21:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-09-28T19:21:47Z"}, "message": "re PR c++/77467 (Segmentation fault with switch statement in constexpr function)\n\n\tPR c++/77467\n\t* constexpr.c (enum constexpr_switch_state): New.\n\t(struct constexpr_ctx): Add css_state field.\n\t(label_matches): Add CTX and STMT arguments, remove I and\n\tDEFAULT_LABEL.  For CASE_LABEL_EXPR assert ctx->css_state != NULL,\n\thandle default labels according to css_state.\n\t(cxx_eval_statement_list): Remove statement skipping, label_matches\n\tand default_label handling code.\n\t(cxx_eval_loop_expr): Exit after first iteration even if\n\tswitches (jump_target).\n\t(cxx_eval_switch_expr): Set up css_state field in ctx, if default\n\tlabel has been seen in the body, but no cases matched, evaluate\n\tthe body second time.\n\t(cxx_eval_constant_expression): Handle stmt skipping and label_matches\n\there.  Handle PREDICT_EXPR.  For MODIFY_EXPR or INIT_EXPR, assert\n\tstatement is not skipped.  For COND_EXPR during skipping, don't\n\tevaluate condition, just the then block and if still skipping at the\n\tend also the else block.\n\t(cxx_eval_outermost_constant_expr): Adjust constexpr_ctx initializer.\n\t(is_sub_constant_expr): Likewise.\n\n\t* g++.dg/cpp1y/constexpr-77467.C: New test.\n\nFrom-SVN: r240591", "tree": {"sha": "87190ab17a07d003e50e369e06ccb1875e978e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87190ab17a07d003e50e369e06ccb1875e978e4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b3906980ac60781cddae5a787bf2908dd0920b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b3906980ac60781cddae5a787bf2908dd0920b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b3906980ac60781cddae5a787bf2908dd0920b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b3906980ac60781cddae5a787bf2908dd0920b7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e0ab375340dc9a651e00e62e79e45152ff3f8bad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0ab375340dc9a651e00e62e79e45152ff3f8bad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0ab375340dc9a651e00e62e79e45152ff3f8bad"}], "stats": {"total": 272, "additions": 243, "deletions": 29}, "files": [{"sha": "0e18eb7fd171888ded0000fa93ca7784da8357b9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b3906980ac60781cddae5a787bf2908dd0920b7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b3906980ac60781cddae5a787bf2908dd0920b7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4b3906980ac60781cddae5a787bf2908dd0920b7", "patch": "@@ -1,3 +1,26 @@\n+2016-09-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/77467\n+\t* constexpr.c (enum constexpr_switch_state): New.\n+\t(struct constexpr_ctx): Add css_state field.\n+\t(label_matches): Add CTX and STMT arguments, remove I and\n+\tDEFAULT_LABEL.  For CASE_LABEL_EXPR assert ctx->css_state != NULL,\n+\thandle default labels according to css_state.\n+\t(cxx_eval_statement_list): Remove statement skipping, label_matches\n+\tand default_label handling code.\n+\t(cxx_eval_loop_expr): Exit after first iteration even if\n+\tswitches (jump_target).\n+\t(cxx_eval_switch_expr): Set up css_state field in ctx, if default\n+\tlabel has been seen in the body, but no cases matched, evaluate\n+\tthe body second time.\n+\t(cxx_eval_constant_expression): Handle stmt skipping and label_matches\n+\there.  Handle PREDICT_EXPR.  For MODIFY_EXPR or INIT_EXPR, assert\n+\tstatement is not skipped.  For COND_EXPR during skipping, don't\n+\tevaluate condition, just the then block and if still skipping at the\n+\tend also the else block.\n+\t(cxx_eval_outermost_constant_expr): Adjust constexpr_ctx initializer.\n+\t(is_sub_constant_expr): Likewise.\n+\n 2016-09-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tImplement P0018R3, C++17 lambda capture of *this by value as [=,*this]"}, {"sha": "2db13d2e1877a18535a2d838ed1a93624619b68a", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 87, "deletions": 29, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b3906980ac60781cddae5a787bf2908dd0920b7/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b3906980ac60781cddae5a787bf2908dd0920b7/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=4b3906980ac60781cddae5a787bf2908dd0920b7", "patch": "@@ -900,6 +900,18 @@ struct constexpr_call_hasher : ggc_ptr_hash<constexpr_call>\n   static bool equal (constexpr_call *, constexpr_call *);\n };\n \n+enum constexpr_switch_state {\n+  /* Used when processing a switch for the first time by cxx_eval_switch_expr\n+     and default: label for that switch has not been seen yet.  */\n+  css_default_not_seen,\n+  /* Used when processing a switch for the first time by cxx_eval_switch_expr\n+     and default: label for that switch has been seen already.  */\n+  css_default_seen,\n+  /* Used when processing a switch for the second time by\n+     cxx_eval_switch_expr, where default: label should match.  */\n+  css_default_processing\n+};\n+\n /* The constexpr expansion context.  CALL is the current function\n    expansion, CTOR is the current aggregate initializer, OBJECT is the\n    object being initialized by CTOR, either a VAR_DECL or a _REF.  VALUES\n@@ -919,6 +931,8 @@ struct constexpr_ctx {\n   tree ctor;\n   /* The object we're building the CONSTRUCTOR for.  */\n   tree object;\n+  /* If inside SWITCH_EXPR.  */\n+  constexpr_switch_state *css_state;\n   /* Whether we should error on a non-constant expression or fail quietly.  */\n   bool quiet;\n   /* Whether we are strictly conforming to constant expression rules or\n@@ -3484,14 +3498,12 @@ switches (tree *jump_target)\n }\n \n /* Subroutine of cxx_eval_statement_list.  Determine whether the statement\n-   at I matches *jump_target.  If we're looking for a case label and we see\n-   the default label, copy I into DEFAULT_LABEL.  */\n+   STMT matches *jump_target.  If we're looking for a case label and we see\n+   the default label, note it in ctx->css_state.  */\n \n static bool\n-label_matches (tree *jump_target, tree_stmt_iterator i,\n-\t       tree_stmt_iterator& default_label)\n+label_matches (const constexpr_ctx *ctx, tree *jump_target, tree stmt)\n {\n-  tree stmt = tsi_stmt (i);\n   switch (TREE_CODE (*jump_target))\n     {\n     case LABEL_DECL:\n@@ -3503,8 +3515,18 @@ label_matches (tree *jump_target, tree_stmt_iterator i,\n     case INTEGER_CST:\n       if (TREE_CODE (stmt) == CASE_LABEL_EXPR)\n \t{\n+\t  gcc_assert (ctx->css_state != NULL);\n \t  if (!CASE_LOW (stmt))\n-\t    default_label = i;\n+\t    {\n+\t      /* default: should appear just once in a SWITCH_EXPR\n+\t\t body (excluding nested SWITCH_EXPR).  */\n+\t      gcc_assert (*ctx->css_state != css_default_seen);\n+\t      /* When evaluating SWITCH_EXPR body for the second time,\n+\t\t return true for the default: label.  */\n+\t      if (*ctx->css_state == css_default_processing)\n+\t\treturn true;\n+\t      *ctx->css_state = css_default_seen;\n+\t    }\n \t  else if (CASE_HIGH (stmt))\n \t    {\n \t      if (tree_int_cst_le (CASE_LOW (stmt), *jump_target)\n@@ -3531,7 +3553,6 @@ cxx_eval_statement_list (const constexpr_ctx *ctx, tree t,\n \t\t\t tree *jump_target)\n {\n   tree_stmt_iterator i;\n-  tree_stmt_iterator default_label = tree_stmt_iterator();\n   tree local_target;\n   /* In a statement-expression we want to return the last value.  */\n   tree r = NULL_TREE;\n@@ -3542,18 +3563,7 @@ cxx_eval_statement_list (const constexpr_ctx *ctx, tree t,\n     }\n   for (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n     {\n-    reenter:\n       tree stmt = tsi_stmt (i);\n-      if (*jump_target)\n-\t{\n-\t  if (TREE_CODE (stmt) == STATEMENT_LIST)\n-\t    /* The label we want might be inside.  */;\n-\t  else if (label_matches (jump_target, i, default_label))\n-\t    /* Found it.  */\n-\t    *jump_target = NULL_TREE;\n-\t  else\n-\t    continue;\n-\t}\n       r = cxx_eval_constant_expression (ctx, stmt, false,\n \t\t\t\t\tnon_constant_p, overflow_p,\n \t\t\t\t\tjump_target);\n@@ -3562,12 +3572,6 @@ cxx_eval_statement_list (const constexpr_ctx *ctx, tree t,\n       if (returns (jump_target) || breaks (jump_target))\n \tbreak;\n     }\n-  if (switches (jump_target) && !tsi_end_p (default_label))\n-    {\n-      i = default_label;\n-      *jump_target = NULL_TREE;\n-      goto reenter;\n-    }\n   return r;\n }\n \n@@ -3606,7 +3610,10 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n \t  break;\n \t}\n     }\n-  while (!returns (jump_target) && !breaks (jump_target) && !*non_constant_p);\n+  while (!returns (jump_target)\n+\t && !breaks (jump_target)\n+\t && !switches (jump_target)\n+\t && !*non_constant_p);\n \n   if (breaks (jump_target))\n     *jump_target = NULL_TREE;\n@@ -3629,8 +3636,20 @@ cxx_eval_switch_expr (const constexpr_ctx *ctx, tree t,\n   *jump_target = cond;\n \n   tree body = TREE_OPERAND (t, 1);\n-  cxx_eval_statement_list (ctx, body,\n-\t\t\t   non_constant_p, overflow_p, jump_target);\n+  constexpr_ctx new_ctx = *ctx;\n+  constexpr_switch_state css = css_default_not_seen;\n+  new_ctx.css_state = &css;\n+  cxx_eval_constant_expression (&new_ctx, body, false,\n+\t\t\t\tnon_constant_p, overflow_p, jump_target);\n+  if (switches (jump_target) && css == css_default_seen)\n+    {\n+      /* If the SWITCH_EXPR body has default: label, process it once again,\n+\t this time instructing label_matches to return true for default:\n+\t label on switches (jump_target).  */\n+      css = css_default_processing;\n+      cxx_eval_constant_expression (&new_ctx, body, false,\n+\t\t\t\t    non_constant_p, overflow_p, jump_target);\n+    }\n   if (breaks (jump_target) || switches (jump_target))\n     *jump_target = NULL_TREE;\n   return NULL_TREE;\n@@ -3650,6 +3669,27 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n   constexpr_ctx new_ctx;\n   tree r = t;\n \n+  if (jump_target && *jump_target)\n+    {\n+      /* If we are jumping, ignore all statements/expressions except those\n+\t that could have LABEL_EXPR or CASE_LABEL_EXPR in their bodies.  */\n+      switch (TREE_CODE (t))\n+\t{\n+\tcase BIND_EXPR:\n+\tcase STATEMENT_LIST:\n+\tcase LOOP_EXPR:\n+\tcase COND_EXPR:\n+\t  break;\n+\tcase LABEL_EXPR:\n+\tcase CASE_LABEL_EXPR:\n+\t  if (label_matches (ctx, jump_target, t))\n+\t    /* Found it.  */\n+\t    *jump_target = NULL_TREE;\n+\t  return NULL_TREE;\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+    }\n   if (t == error_mark_node)\n     {\n       *non_constant_p = true;\n@@ -3730,6 +3770,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case LABEL_DECL:\n     case LABEL_EXPR:\n     case CASE_LABEL_EXPR:\n+    case PREDICT_EXPR:\n       return t;\n \n     case PARM_DECL:\n@@ -3835,6 +3876,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \n     case INIT_EXPR:\n     case MODIFY_EXPR:\n+      gcc_assert (jump_target == NULL || *jump_target == NULL_TREE);\n       r = cxx_eval_store_expression (ctx, t, lval,\n \t\t\t\t     non_constant_p, overflow_p);\n       break;\n@@ -4065,6 +4107,22 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       break;\n \n     case COND_EXPR:\n+      if (jump_target && *jump_target)\n+\t{\n+\t  /* When jumping to a label, the label might be either in the\n+\t     then or else blocks, so process then block first in skipping\n+\t     mode first, and if we are still in the skipping mode at its end,\n+\t     process the else block too.  */\n+\t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n+\t\t\t\t\t    lval, non_constant_p, overflow_p,\n+\t\t\t\t\t    jump_target);\n+\t  if (*jump_target)\n+\t    r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 2),\n+\t\t\t\t\t      lval, non_constant_p, overflow_p,\n+\t\t\t\t\t      jump_target);\n+\t  break;\n+\t}\n+      /* FALLTHRU */\n     case VEC_COND_EXPR:\n       r = cxx_eval_conditional_expression (ctx, t, lval,\n \t\t\t\t\t   non_constant_p, overflow_p,\n@@ -4340,7 +4398,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   bool overflow_p = false;\n   hash_map<tree,tree> map;\n \n-  constexpr_ctx ctx = { NULL, &map, NULL, NULL, NULL,\n+  constexpr_ctx ctx = { NULL, &map, NULL, NULL, NULL, NULL,\n \t\t\tallow_non_constant, strict };\n \n   tree type = initialized_type (t);\n@@ -4460,7 +4518,7 @@ is_sub_constant_expr (tree t)\n   bool overflow_p = false;\n   hash_map <tree, tree> map;\n \n-  constexpr_ctx ctx = { NULL, &map, NULL, NULL, NULL, true, true };\n+  constexpr_ctx ctx = { NULL, &map, NULL, NULL, NULL, NULL, true, true };\n \n   cxx_eval_constant_expression (&ctx, t, false, &non_constant_p,\n \t\t\t\t&overflow_p);"}, {"sha": "22a001b14459568ff3843fd9b3997b2eb03ca6e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b3906980ac60781cddae5a787bf2908dd0920b7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b3906980ac60781cddae5a787bf2908dd0920b7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b3906980ac60781cddae5a787bf2908dd0920b7", "patch": "@@ -1,3 +1,8 @@\n+2016-09-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/77467\n+\t* g++.dg/cpp1y/constexpr-77467.C: New test.\n+\n 2016-09-28  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/77762"}, {"sha": "fd94e78a03bc5b21fe544f90b762d5c5b4149238", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-77467.C", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b3906980ac60781cddae5a787bf2908dd0920b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-77467.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b3906980ac60781cddae5a787bf2908dd0920b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-77467.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-77467.C?ref=4b3906980ac60781cddae5a787bf2908dd0920b7", "patch": "@@ -0,0 +1,128 @@\n+// PR c++/77467\n+// { dg-do compile { target c++14 } }\n+\n+constexpr int\n+foo (const int x, const unsigned n) noexcept\n+{\n+  switch (n)\n+    {\n+    case 0:\n+      return 1;\n+    case 1:\n+      return x;\n+    default:\n+      const auto m = (n >> 1);\n+      const auto y = foo (x, m);\n+      return ((m << 1) == n) ? y * y : x * y * y;\n+    }\n+}\n+\n+static_assert (foo (3, 2) == 9, \"\");\n+static_assert (foo (2, 3) == 8, \"\");\n+\n+constexpr int\n+bar (int x)\n+{\n+  int a = x;\n+  switch (x)\n+    a = x + 1;\n+  return a;\n+}\n+\n+static_assert (bar (0) == 0, \"\");\n+static_assert (bar (1) == 1, \"\");\n+\n+constexpr int\n+baz (const int x, int y) noexcept\n+{\n+  switch (x)\n+    {\n+    case 0:\n+      return 1;\n+    case 1:\n+      return x;\n+    case 2:\n+      if ((y += 2) == 0)\n+\t{\n+\tcase 3:\n+\t  y += 4;\n+\t  break;\n+\t}\n+      else\n+\t{\n+\tcase 4:\n+\t  y += 8;\n+\t  break;\n+\t}\n+      break;\n+    case 5:\n+      for (y = 0; y < 3; y++)\n+\t{\n+\tcase 7:\n+\t  if (y == -4)\n+\t    y += 3;\n+\t  if (y == -3)\n+\t    continue;\n+\t  if (y == -2)\n+\t    {\n+\t      y += 18;\n+\t      break;\n+\t    }\n+\t  if (y == 2)\n+\t    {\n+\t    case 6:\n+\t      y += 12;\n+\t    default:\n+\t      y++;\n+\t      break;\n+\t    }\n+\t}\n+      break;\n+    case -1:\n+    case -2:\n+      switch (y)\n+\t{\n+\tcase 19:\n+\t  y += 2;\n+\t  break;\n+\tcase 20:\n+\t  y += 3;\n+\t  if (x == 2)\n+\t    case 21:;\n+\t  y += 2;\n+\t  if (x == 3)\n+\t    default:;\n+\t  y += 4;\n+\t  break;\n+\t}\n+      return x + y + 1;\n+    }\n+  return x + y;\n+}\n+\n+static_assert (baz (0, 7) == 1, \"\");\n+static_assert (baz (1, 7) == 1, \"\");\n+static_assert (baz (2, -2) == 6, \"\");\n+static_assert (baz (2, 0) == 12, \"\");\n+static_assert (baz (3, 1) == 8, \"\");\n+static_assert (baz (4, 2) == 14, \"\");\n+static_assert (baz (5, -20) == 20, \"\");\n+static_assert (baz (6, 5) == 24, \"\");\n+static_assert (baz (7, -5) == 22, \"\");\n+static_assert (baz (7, -4) == 22, \"\");\n+static_assert (baz (7, -3) == 23, \"\");\n+static_assert (baz (7, -2) == 23, \"\");\n+static_assert (baz (7, -1) == 22, \"\");\n+static_assert (baz (7, 0) == 22, \"\");\n+static_assert (baz (7, 2) == 22, \"\");\n+static_assert (baz (7, 6) == 14, \"\");\n+static_assert (baz (8, 9) == 18, \"\");\n+static_assert (baz (8, -2) == 7, \"\");\n+static_assert (baz (-1, 19) == 21, \"\");\n+static_assert (baz (-1, 20) == 29, \"\");\n+static_assert (baz (-1, 21) == 27, \"\");\n+static_assert (baz (-1, 5) == 9, \"\");\n+static_assert (baz (-2, 19) == 20, \"\");\n+static_assert (baz (-2, 20) == 28, \"\");\n+static_assert (baz (-2, 21) == 26, \"\");\n+static_assert (baz (-2, 5) == 8, \"\");"}]}