{"sha": "9ac1403ca2c65ba4f28cf051b5326617fa9298d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFjMTQwM2NhMmM2NWJhNGYyOGNmMDUxYjUzMjY2MTdmYTkyOThkMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-08-16T13:23:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-08-16T13:23:01Z"}, "message": "tree-scalar-evolution.c (follow_ssa_edge_expr): Declare.\n\n2019-08-16  Richard Biener  <rguenther@suse.de>\n\n\t* tree-scalar-evolution.c (follow_ssa_edge_expr): Declare.\n\t(follow_ssa_edge_binary): Call follow_ssa_edge_expr instead of\n\tfollow_ssa_edge.\n\t(follow_ssa_edge_in_condition_phi_branch): Likewise.\n\t(analyze_evolution_in_loop): Likewise.\n\t(follow_ssa_edge, follow_ssa_edge_in_rhs): Inline into ...\n\t(follow_ssa_edge_expr): ... here.  Refactor code.\n\nFrom-SVN: r274571", "tree": {"sha": "a3b12a03f8a923fc1578d885e8cadcf93ebbf3cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3b12a03f8a923fc1578d885e8cadcf93ebbf3cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ac1403ca2c65ba4f28cf051b5326617fa9298d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ac1403ca2c65ba4f28cf051b5326617fa9298d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ac1403ca2c65ba4f28cf051b5326617fa9298d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ac1403ca2c65ba4f28cf051b5326617fa9298d1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "772a1b15d57f0c035188f85cf42641b217eef9eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/772a1b15d57f0c035188f85cf42641b217eef9eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/772a1b15d57f0c035188f85cf42641b217eef9eb"}], "stats": {"total": 359, "additions": 163, "deletions": 196}, "files": [{"sha": "45691b4c90056215d6a0d1d9a6a0753d2a4ccc6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac1403ca2c65ba4f28cf051b5326617fa9298d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac1403ca2c65ba4f28cf051b5326617fa9298d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ac1403ca2c65ba4f28cf051b5326617fa9298d1", "patch": "@@ -1,3 +1,13 @@\n+2019-08-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-scalar-evolution.c (follow_ssa_edge_expr): Declare.\n+\t(follow_ssa_edge_binary): Call follow_ssa_edge_expr instead of\n+\tfollow_ssa_edge.\n+\t(follow_ssa_edge_in_condition_phi_branch): Likewise.\n+\t(analyze_evolution_in_loop): Likewise.\n+\t(follow_ssa_edge, follow_ssa_edge_in_rhs): Inline into ...\n+\t(follow_ssa_edge_expr): ... here.  Refactor code.\n+\n 2019-08-16  Richard Biener  <rguenther@suse.de>\n \n \tPR target/91469"}, {"sha": "82c4c5b931b59606f7de493d05c80952fc0d494d", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 153, "deletions": 196, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac1403ca2c65ba4f28cf051b5326617fa9298d1/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac1403ca2c65ba4f28cf051b5326617fa9298d1/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=9ac1403ca2c65ba4f28cf051b5326617fa9298d1", "patch": "@@ -876,8 +876,8 @@ enum t_bool {\n };\n \n \n-static t_bool follow_ssa_edge (class loop *loop, gimple *, gphi *,\n-\t\t\t       tree *, int);\n+static t_bool follow_ssa_edge_expr (class loop *loop, gimple *, tree, gphi *,\n+\t\t\t\t    tree *, int);\n \n /* Follow the ssa edge into the binary expression RHS0 CODE RHS1.\n    Return true if the strongly connected component has been found.  */\n@@ -912,8 +912,8 @@ follow_ssa_edge_binary (class loop *loop, gimple *at_stmt,\n \t\t  (loop->num,\n \t\t   chrec_convert (type, evol, at_stmt),\n \t\t   code, rhs1, at_stmt);\n-\t      res = follow_ssa_edge\n-\t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, &evol, limit);\n+\t      res = follow_ssa_edge_expr\n+\t\t(loop, at_stmt, rhs0, halting_phi, &evol, limit);\n \t      if (res == t_true)\n \t\t*evolution_of_loop = evol;\n \t      else if (res == t_false)\n@@ -922,8 +922,8 @@ follow_ssa_edge_binary (class loop *loop, gimple *at_stmt,\n \t\t      (loop->num,\n \t\t       chrec_convert (type, *evolution_of_loop, at_stmt),\n \t\t       code, rhs0, at_stmt);\n-\t\t  res = follow_ssa_edge\n-\t\t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi,\n+\t\t  res = follow_ssa_edge_expr\n+\t\t    (loop, at_stmt, rhs1, halting_phi,\n \t\t     evolution_of_loop, limit);\n \t\t  if (res == t_true)\n \t\t    ;\n@@ -943,8 +943,8 @@ follow_ssa_edge_binary (class loop *loop, gimple *at_stmt,\n \t\t  (loop->num, chrec_convert (type, *evolution_of_loop,\n \t\t\t\t\t     at_stmt),\n \t\t   code, rhs1, at_stmt);\n-\t      res = follow_ssa_edge\n-\t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi,\n+\t      res = follow_ssa_edge_expr\n+\t\t(loop, at_stmt, rhs0, halting_phi,\n \t\t evolution_of_loop, limit);\n \t      if (res == t_true)\n \t\t;\t\n@@ -961,8 +961,8 @@ follow_ssa_edge_binary (class loop *loop, gimple *at_stmt,\n \t      (loop->num, chrec_convert (type, *evolution_of_loop,\n \t\t\t\t\t at_stmt),\n \t       code, rhs0, at_stmt);\n-\t  res = follow_ssa_edge\n-\t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi,\n+\t  res = follow_ssa_edge_expr\n+\t    (loop, at_stmt, rhs1, halting_phi,\n \t     evolution_of_loop, limit);\n \t  if (res == t_true)\n \t    ;\n@@ -993,8 +993,8 @@ follow_ssa_edge_binary (class loop *loop, gimple *at_stmt,\n \t  *evolution_of_loop = add_to_evolution\n \t      (loop->num, chrec_convert (type, *evolution_of_loop, at_stmt),\n \t       MINUS_EXPR, rhs1, at_stmt);\n-\t  res = follow_ssa_edge (loop, SSA_NAME_DEF_STMT (rhs0), halting_phi,\n-\t\t\t\t evolution_of_loop, limit);\n+\t  res = follow_ssa_edge_expr (loop, at_stmt, rhs0, halting_phi,\n+\t\t\t\t      evolution_of_loop, limit);\n \t  if (res == t_true)\n \t    ;\n \t  else if (res == t_dont_know)\n@@ -1014,140 +1014,6 @@ follow_ssa_edge_binary (class loop *loop, gimple *at_stmt,\n   return res;\n }\n \n-/* Follow the ssa edge into the expression EXPR.\n-   Return true if the strongly connected component has been found.  */\n-\n-static t_bool\n-follow_ssa_edge_expr (class loop *loop, gimple *at_stmt, tree expr,\n-\t\t      gphi *halting_phi, tree *evolution_of_loop,\n-\t\t      int limit)\n-{\n-  enum tree_code code = TREE_CODE (expr);\n-  tree type = TREE_TYPE (expr), rhs0, rhs1;\n-  t_bool res;\n-\n-  /* The EXPR is one of the following cases:\n-     - an SSA_NAME,\n-     - an INTEGER_CST,\n-     - a PLUS_EXPR,\n-     - a POINTER_PLUS_EXPR,\n-     - a MINUS_EXPR,\n-     - an ASSERT_EXPR,\n-     - other cases are not yet handled.  */\n-\n-  switch (code)\n-    {\n-    CASE_CONVERT:\n-      /* This assignment is under the form \"a_1 = (cast) rhs.  */\n-      res = follow_ssa_edge_expr (loop, at_stmt, TREE_OPERAND (expr, 0),\n-\t\t\t\t  halting_phi, evolution_of_loop, limit);\n-      *evolution_of_loop = chrec_convert (type, *evolution_of_loop, at_stmt);\n-      break;\n-\n-    case INTEGER_CST:\n-      /* This assignment is under the form \"a_1 = 7\".  */\n-      res = t_false;\n-      break;\n-\n-    case SSA_NAME:\n-      /* This assignment is under the form: \"a_1 = b_2\".  */\n-      res = follow_ssa_edge\n-\t(loop, SSA_NAME_DEF_STMT (expr), halting_phi, evolution_of_loop, limit);\n-      break;\n-\n-    case POINTER_PLUS_EXPR:\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-      /* This case is under the form \"rhs0 +- rhs1\".  */\n-      rhs0 = TREE_OPERAND (expr, 0);\n-      rhs1 = TREE_OPERAND (expr, 1);\n-      type = TREE_TYPE (rhs0);\n-      STRIP_USELESS_TYPE_CONVERSION (rhs0);\n-      STRIP_USELESS_TYPE_CONVERSION (rhs1);\n-      res = follow_ssa_edge_binary (loop, at_stmt, type, rhs0, code, rhs1,\n-\t\t\t\t    halting_phi, evolution_of_loop, limit);\n-      break;\n-\n-    case ADDR_EXPR:\n-      /* Handle &MEM[ptr + CST] which is equivalent to POINTER_PLUS_EXPR.  */\n-      if (TREE_CODE (TREE_OPERAND (expr, 0)) == MEM_REF)\n-\t{\n-\t  expr = TREE_OPERAND (expr, 0);\n-\t  rhs0 = TREE_OPERAND (expr, 0);\n-\t  rhs1 = TREE_OPERAND (expr, 1);\n-\t  type = TREE_TYPE (rhs0);\n-\t  STRIP_USELESS_TYPE_CONVERSION (rhs0);\n-\t  STRIP_USELESS_TYPE_CONVERSION (rhs1);\n-\t  res = follow_ssa_edge_binary (loop, at_stmt, type,\n-\t\t\t\t\trhs0, POINTER_PLUS_EXPR, rhs1,\n-\t\t\t\t\thalting_phi, evolution_of_loop, limit);\n-\t}\n-      else\n-\tres = t_false;\n-      break;\n-\n-    case ASSERT_EXPR:\n-      /* This assignment is of the form: \"a_1 = ASSERT_EXPR <a_2, ...>\"\n-\t It must be handled as a copy assignment of the form a_1 = a_2.  */\n-      rhs0 = ASSERT_EXPR_VAR (expr);\n-      if (TREE_CODE (rhs0) == SSA_NAME)\n-\tres = follow_ssa_edge (loop, SSA_NAME_DEF_STMT (rhs0),\n-\t\t\t       halting_phi, evolution_of_loop, limit);\n-      else\n-\tres = t_false;\n-      break;\n-\n-    default:\n-      res = t_false;\n-      break;\n-    }\n-\n-  return res;\n-}\n-\n-/* Follow the ssa edge into the right hand side of an assignment STMT.\n-   Return true if the strongly connected component has been found.  */\n-\n-static t_bool\n-follow_ssa_edge_in_rhs (class loop *loop, gimple *stmt,\n-\t\t\tgphi *halting_phi, tree *evolution_of_loop,\n-\t\t\tint limit)\n-{\n-  enum tree_code code = gimple_assign_rhs_code (stmt);\n-  tree type = gimple_expr_type (stmt), rhs1, rhs2;\n-  t_bool res;\n-\n-  switch (code)\n-    {\n-    CASE_CONVERT:\n-      /* This assignment is under the form \"a_1 = (cast) rhs.  */\n-      res = follow_ssa_edge_expr (loop, stmt, gimple_assign_rhs1 (stmt),\n-\t\t\t\t  halting_phi, evolution_of_loop, limit);\n-      *evolution_of_loop = chrec_convert (type, *evolution_of_loop, stmt);\n-      break;\n-\n-    case POINTER_PLUS_EXPR:\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-      rhs1 = gimple_assign_rhs1 (stmt);\n-      rhs2 = gimple_assign_rhs2 (stmt);\n-      type = TREE_TYPE (rhs1);\n-      res = follow_ssa_edge_binary (loop, stmt, type, rhs1, code, rhs2,\n-\t\t\t\t    halting_phi, evolution_of_loop, limit);\n-      break;\n-\n-    default:\n-      if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS)\n-\tres = follow_ssa_edge_expr (loop, stmt, gimple_assign_rhs1 (stmt),\n-\t\t\t\t    halting_phi, evolution_of_loop, limit);\n-      else\n-\tres = t_false;\n-      break;\n-    }\n-\n-  return res;\n-}\n-\n /* Checks whether the I-th argument of a PHI comes from a backedge.  */\n \n static bool\n@@ -1187,8 +1053,8 @@ follow_ssa_edge_in_condition_phi_branch (int i,\n   if (TREE_CODE (branch) == SSA_NAME)\n     {\n       *evolution_of_branch = init_cond;\n-      return follow_ssa_edge (loop, SSA_NAME_DEF_STMT (branch), halting_phi,\n-\t\t\t      evolution_of_branch, limit);\n+      return follow_ssa_edge_expr (loop, condition_phi, branch, halting_phi,\n+\t\t\t\t   evolution_of_branch, limit);\n     }\n \n   /* This case occurs when one of the condition branches sets\n@@ -1295,65 +1161,158 @@ follow_ssa_edge_inner_loop_phi (class loop *outer_loop,\n \t\t\t       evolution_of_loop, limit);\n }\n \n-/* Follow an SSA edge from a loop-phi-node to itself, constructing a\n-   path that is analyzed on the return walk.  */\n+/* Follow the ssa edge into the expression EXPR.\n+   Return true if the strongly connected component has been found.  */\n \n static t_bool\n-follow_ssa_edge (class loop *loop, gimple *def, gphi *halting_phi,\n-\t\t tree *evolution_of_loop, int limit)\n+follow_ssa_edge_expr (class loop *loop, gimple *at_stmt, tree expr,\n+\t\t      gphi *halting_phi, tree *evolution_of_loop,\n+\t\t      int limit)\n {\n-  class loop *def_loop;\n+  enum tree_code code;\n+  tree type, rhs0, rhs1 = NULL_TREE;\n \n-  if (gimple_nop_p (def))\n-    return t_false;\n+  /* The EXPR is one of the following cases:\n+     - an SSA_NAME,\n+     - an INTEGER_CST,\n+     - a PLUS_EXPR,\n+     - a POINTER_PLUS_EXPR,\n+     - a MINUS_EXPR,\n+     - an ASSERT_EXPR,\n+     - other cases are not yet handled.  */\n \n-  /* Give up if the path is longer than the MAX that we allow.  */\n-  if (limit > PARAM_VALUE (PARAM_SCEV_MAX_EXPR_COMPLEXITY))\n-    return t_dont_know;\n+  /* For SSA_NAME look at the definition statement, handling\n+     PHI nodes and otherwise expand appropriately for the expression\n+     handling below.  */\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (expr);\n \n-  def_loop = loop_containing_stmt (def);\n+      if (gimple_nop_p (def))\n+\treturn t_false;\n \n-  switch (gimple_code (def))\n-    {\n-    case GIMPLE_PHI:\n-      if (!loop_phi_node_p (def))\n-\t/* DEF is a condition-phi-node.  Follow the branches, and\n-\t   record their evolutions.  Finally, merge the collected\n-\t   information and set the approximation to the main\n-\t   variable.  */\n-\treturn follow_ssa_edge_in_condition_phi\n-\t  (loop, as_a <gphi *> (def), halting_phi, evolution_of_loop,\n-\t   limit);\n-\n-      /* When the analyzed phi is the halting_phi, the\n-\t depth-first search is over: we have found a path from\n-\t the halting_phi to itself in the loop.  */\n-      if (def == halting_phi)\n-\treturn t_true;\n+      /* Give up if the path is longer than the MAX that we allow.  */\n+      if (limit > PARAM_VALUE (PARAM_SCEV_MAX_EXPR_COMPLEXITY))\n+\treturn t_dont_know;\n \n-      /* Otherwise, the evolution of the HALTING_PHI depends\n-\t on the evolution of another loop-phi-node, i.e. the\n-\t evolution function is a higher degree polynomial.  */\n-      if (def_loop == loop)\n+      if (gphi *phi = dyn_cast <gphi *>(def))\n+\t{\n+\t  if (!loop_phi_node_p (phi))\n+\t    /* DEF is a condition-phi-node.  Follow the branches, and\n+\t       record their evolutions.  Finally, merge the collected\n+\t       information and set the approximation to the main\n+\t       variable.  */\n+\t    return follow_ssa_edge_in_condition_phi\n+\t\t(loop, phi, halting_phi, evolution_of_loop, limit);\n+\n+\t  /* When the analyzed phi is the halting_phi, the\n+\t     depth-first search is over: we have found a path from\n+\t     the halting_phi to itself in the loop.  */\n+\t  if (phi == halting_phi)\n+\t    return t_true;\n+\n+\t  /* Otherwise, the evolution of the HALTING_PHI depends\n+\t     on the evolution of another loop-phi-node, i.e. the\n+\t     evolution function is a higher degree polynomial.  */\n+\t  class loop *def_loop = loop_containing_stmt (def);\n+\t  if (def_loop == loop)\n+\t    return t_false;\n+\n+\t  /* Inner loop.  */\n+\t  if (flow_loop_nested_p (loop, def_loop))\n+\t    return follow_ssa_edge_inner_loop_phi\n+\t\t(loop, phi, halting_phi, evolution_of_loop,\n+\t\t limit + 1);\n+\n+\t  /* Outer loop.  */\n+\t  return t_false;\n+\t}\n+\n+      /* At this level of abstraction, the program is just a set\n+\t of GIMPLE_ASSIGNs and PHI_NODEs.  In principle there is no\n+\t other def to be handled.  */\n+      if (!is_gimple_assign (def))\n \treturn t_false;\n \n-      /* Inner loop.  */\n-      if (flow_loop_nested_p (loop, def_loop))\n-\treturn follow_ssa_edge_inner_loop_phi\n-\t  (loop, as_a <gphi *> (def), halting_phi, evolution_of_loop,\n-\t   limit + 1);\n+      code = gimple_assign_rhs_code (def);\n+      switch (get_gimple_rhs_class (code))\n+\t{\n+\tcase GIMPLE_BINARY_RHS:\n+\t  rhs0 = gimple_assign_rhs1 (def);\n+\t  rhs1 = gimple_assign_rhs2 (def);\n+\t  break;\n+\tcase GIMPLE_UNARY_RHS:\n+\tcase GIMPLE_SINGLE_RHS:\n+\t  rhs0 = gimple_assign_rhs1 (def);\n+\t  break;\n+\tdefault:\n+\t  return t_false;\n+\t}\n+      type = TREE_TYPE (gimple_assign_lhs (def));\n+      at_stmt = def;\n+    }\n+  else\n+    {\n+      code = TREE_CODE (expr);\n+      type = TREE_TYPE (expr);\n+      switch (code)\n+\t{\n+\tCASE_CONVERT:\n+\t  rhs0 = TREE_OPERAND (expr, 0);\n+\t  break;\n+\tcase POINTER_PLUS_EXPR:\n+\tcase PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\t  rhs0 = TREE_OPERAND (expr, 0);\n+\t  rhs1 = TREE_OPERAND (expr, 1);\n+\t  break;\n+\tdefault:\n+\t  rhs0 = expr;\n+\t}\n+    }\n+\n+  switch (code)\n+    {\n+    CASE_CONVERT:\n+      {\n+\t/* This assignment is under the form \"a_1 = (cast) rhs.  */\n+\tt_bool res = follow_ssa_edge_expr (loop, at_stmt, rhs0, halting_phi,\n+\t\t\t\t\t   evolution_of_loop, limit);\n+\t*evolution_of_loop = chrec_convert (type, *evolution_of_loop, at_stmt);\n+\treturn res;\n+      }\n \n-      /* Outer loop.  */\n+    case INTEGER_CST:\n+      /* This assignment is under the form \"a_1 = 7\".  */\n       return t_false;\n \n-    case GIMPLE_ASSIGN:\n-      return follow_ssa_edge_in_rhs (loop, def, halting_phi,\n-\t\t\t\t     evolution_of_loop, limit);\n+    case ADDR_EXPR:\n+      {\n+\t/* Handle &MEM[ptr + CST] which is equivalent to POINTER_PLUS_EXPR.  */\n+\tif (TREE_CODE (TREE_OPERAND (rhs0, 0)) != MEM_REF)\n+\t  return t_false;\n+\ttree mem = TREE_OPERAND (rhs0, 0);\n+\trhs0 = TREE_OPERAND (mem, 0);\n+\trhs1 = TREE_OPERAND (mem, 1);\n+\tcode = POINTER_PLUS_EXPR;\n+      }\n+      /* Fallthru.  */\n+    case POINTER_PLUS_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      /* This case is under the form \"rhs0 +- rhs1\".  */\n+      STRIP_USELESS_TYPE_CONVERSION (rhs0);\n+      STRIP_USELESS_TYPE_CONVERSION (rhs1);\n+      return follow_ssa_edge_binary (loop, at_stmt, type, rhs0, code, rhs1,\n+\t\t\t\t     halting_phi, evolution_of_loop, limit);\n+\n+    case ASSERT_EXPR:\n+      /* This assignment is of the form: \"a_1 = ASSERT_EXPR <a_2, ...>\"\n+\t It must be handled as a copy assignment of the form a_1 = a_2.  */\n+      return follow_ssa_edge_expr (loop, at_stmt, ASSERT_EXPR_VAR (rhs0),\n+\t\t\t\t   halting_phi, evolution_of_loop, limit);\n \n     default:\n-      /* At this level of abstraction, the program is just a set\n-\t of GIMPLE_ASSIGNs and PHI_NODEs.  In principle there is no\n-\t other node to be handled.  */\n       return t_false;\n     }\n }\n@@ -1447,7 +1406,6 @@ analyze_evolution_in_loop (gphi *loop_phi_node,\n   for (i = 0; i < n; i++)\n     {\n       tree arg = PHI_ARG_DEF (loop_phi_node, i);\n-      gimple *ssa_chain;\n       tree ev_fn;\n       t_bool res;\n \n@@ -1460,11 +1418,10 @@ analyze_evolution_in_loop (gphi *loop_phi_node,\n \t{\n \t  bool val = false;\n \n-\t  ssa_chain = SSA_NAME_DEF_STMT (arg);\n-\n \t  /* Pass in the initial condition to the follow edge function.  */\n \t  ev_fn = init_cond;\n-\t  res = follow_ssa_edge (loop, ssa_chain, loop_phi_node, &ev_fn, 0);\n+\t  res = follow_ssa_edge_expr (loop, loop_phi_node, arg,\n+\t\t\t\t      loop_phi_node, &ev_fn, 0);\n \n \t  /* If ev_fn has no evolution in the inner loop, and the\n \t     init_cond is not equal to ev_fn, then we have an"}]}