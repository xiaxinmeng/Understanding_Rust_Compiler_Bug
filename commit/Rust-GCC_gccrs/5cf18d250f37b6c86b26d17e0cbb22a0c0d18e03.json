{"sha": "5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNmMThkMjUwZjM3YjZjODZiMjZkMTdlMGNiYjIyYTBjMGQxOGUwMw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-10-29T15:17:42Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-10-29T15:17:42Z"}, "message": "re PR ipa/63587 (ICE : tree check: expected var_decl, have result_decl in add_local_variables, at tree-inline.c:4112)\n\nPR ipa/63587\n\n\t* g++.dg/ipa/pr63587-1.C: New test\n\t* g++.dg/ipa/pr63587-2.C: New test.\n\n\t* cgraphunit.c (cgraph_node::expand_thunk): Only VAR_DECLs are put\n\tto local declarations.\n\t* function.c (add_local_decl): Implementation moved from header\n\tfile, assert introduced for tree type.\n\t* function.h: Likewise.\n\nFrom-SVN: r216841", "tree": {"sha": "987eee494277d54edfb3a37f24a7b598c944ae9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/987eee494277d54edfb3a37f24a7b598c944ae9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b310e901c5b7ad8ad54771b2d69459a496da472", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b310e901c5b7ad8ad54771b2d69459a496da472", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b310e901c5b7ad8ad54771b2d69459a496da472"}], "stats": {"total": 376, "additions": 370, "deletions": 6}, "files": [{"sha": "59e562c111b890146440e04c7a9dfb03621cc31d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03", "patch": "@@ -1,3 +1,12 @@\n+2014-10-29  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/63587\n+\t* cgraphunit.c (cgraph_node::expand_thunk): Only VAR_DECLs are put\n+\tto local declarations.\n+\t* function.c (add_local_decl): Implementation moved from header\n+\tfile, assert introduced for tree type.\n+\t* function.h: Likewise.\n+\n 2014-10-29  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* godump.c (go_format_type): Represent \"float _Complex\" and"}, {"sha": "6f61f5c339ff203fe00c50835c00d96626391b7f", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03", "patch": "@@ -1550,7 +1550,9 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t  else if (!is_gimple_reg_type (restype))\n \t    {\n \t      restmp = resdecl;\n-\t      add_local_decl (cfun, restmp);\n+\n+\t      if (TREE_CODE (restmp) == VAR_DECL)\n+\t\tadd_local_decl (cfun, restmp);\n \t      BLOCK_VARS (DECL_INITIAL (current_function_decl)) = restmp;\n \t    }\n \t  else"}, {"sha": "1ef43c4dea7d4913eb7b9ba0bd7cf916f31cf992", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03", "patch": "@@ -6441,6 +6441,15 @@ match_asm_constraints_1 (rtx_insn *insn, rtx *p_sets, int noutputs)\n     df_insn_rescan (insn);\n }\n \n+/* Add the decl D to the local_decls list of FUN.  */\n+\n+void\n+add_local_decl (struct function *fun, tree d)\n+{\n+  gcc_assert (TREE_CODE (d) == VAR_DECL);\n+  vec_safe_push (fun->local_decls, d);\n+}\n+\n namespace {\n \n const pass_data pass_data_match_asm_constraints ="}, {"sha": "08ab761ae76f087df2c3542118ae25279b19bc60", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03", "patch": "@@ -668,11 +668,7 @@ struct GTY(()) function {\n \n /* Add the decl D to the local_decls list of FUN.  */\n \n-static inline void\n-add_local_decl (struct function *fun, tree d)\n-{\n-  vec_safe_push (fun->local_decls, d);\n-}\n+void add_local_decl (struct function *fun, tree d);\n \n #define FOR_EACH_LOCAL_DECL(FUN, I, D)\t\t\\\n   FOR_EACH_VEC_SAFE_ELT_REVERSE ((FUN)->local_decls, I, D)"}, {"sha": "2e4073fa08c2c6b87afb6994cd245f2615021a9b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03", "patch": "@@ -1,3 +1,9 @@\n+2014-10-29  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/63587\n+\t* g++.dg/ipa/pr63587-1.C: New test.\n+\t* g++.dg/ipa/pr63587-2.C: New test.\n+\n 2014-10-29  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* gcc.misc-tests/godump-1.c: Add tests for complex types."}, {"sha": "cbf872e2969bcc0d4e42e3a9790ceab76cd809ca", "filename": "gcc/testsuite/g++.dg/ipa/pr63587-1.C", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr63587-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr63587-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr63587-1.C?ref=5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03", "patch": "@@ -0,0 +1,92 @@\n+// PR ipa/63587\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2 -fno-strict-aliasing\" }\n+\n+template <class> struct A\n+{\n+};\n+template <typename> struct B\n+{\n+  template <typename> struct C;\n+};\n+class D;\n+template <typename> class F;\n+struct G\n+{\n+  void operator()(const D &, D);\n+};\n+class D\n+{\n+public:\n+  D (int);\n+};\n+struct H\n+{\n+  H (int);\n+};\n+template <typename _Key, typename, typename, typename _Compare, typename>\n+class I\n+{\n+  typedef _Key key_type;\n+  template <typename _Key_compare> struct J\n+  {\n+    _Key_compare _M_key_compare;\n+  };\n+  J<_Compare> _M_impl;\n+\n+public:\n+  A<int> _M_get_insert_unique_pos (const key_type &);\n+  A<int> _M_get_insert_hint_unique_pos (H &);\n+  template <typename... _Args> int _M_emplace_hint_unique (H, _Args &&...);\n+};\n+template <typename _Key, typename _Tp, typename _Compare = G,\n+\t  typename _Alloc = F<A<_Tp> > >\n+class K\n+{\n+  typedef _Key key_type;\n+  typedef _Key value_type;\n+  typedef typename B<_Alloc>::template C<value_type> _Pair_alloc_type;\n+  I<key_type, value_type, int, _Compare, _Pair_alloc_type> _M_t;\n+\n+public:\n+  void operator[](key_type)\n+  {\n+    _M_t._M_emplace_hint_unique (0);\n+  }\n+};\n+template <typename _Key, typename _Val, typename _KeyOfValue,\n+\t  typename _Compare, typename _Alloc>\n+A<int>\n+I<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_unique_pos (\n+  const key_type &p1)\n+{\n+  _M_impl._M_key_compare (p1, 0);\n+}\n+template <typename _Key, typename _Val, typename _KeyOfValue,\n+\t  typename _Compare, typename _Alloc>\n+A<int>\n+I<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_hint_unique_pos (\n+  H &)\n+{\n+  _M_get_insert_unique_pos (0);\n+}\n+template <typename _Key, typename _Val, typename _KeyOfValue,\n+\t  typename _Compare, typename _Alloc>\n+template <typename... _Args>\n+int\n+I<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_emplace_hint_unique (\n+  H p1, _Args &&...)\n+{\n+  _M_get_insert_hint_unique_pos (p1);\n+}\n+namespace {\n+struct L;\n+}\n+void\n+fn1 ()\n+{\n+  K<D, L> a;\n+  a[0];\n+  K<D, int> b;\n+  b[0];\n+}"}, {"sha": "f31c5bdee44623ac69843daa718c30c1d46d1b52", "filename": "gcc/testsuite/g++.dg/ipa/pr63587-2.C", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr63587-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr63587-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr63587-2.C?ref=5cf18d250f37b6c86b26d17e0cbb22a0c0d18e03", "patch": "@@ -0,0 +1,250 @@\n+// PR ipa/63587\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2\" }\n+\n+namespace boost {\n+class basic_cstring\n+{\n+public:\n+  basic_cstring (char *);\n+};\n+template <typename> struct identity\n+{\n+};\n+struct make_identity;\n+struct function_buffer\n+{\n+};\n+template <typename FunctionObj> struct function_obj_invoker0\n+{\n+  static int\n+  invoke (function_buffer &)\n+  {\n+    FunctionObj f;\n+    f ();\n+  }\n+};\n+template <typename FunctionObj> struct get_function_obj_invoker0\n+{\n+  typedef function_obj_invoker0<FunctionObj> type;\n+};\n+template <typename FunctionObj> struct apply\n+{\n+  typedef typename get_function_obj_invoker0<FunctionObj>::type invoker_type;\n+};\n+struct basic_vtable0\n+{\n+  typedef int (*invoker_type)(function_buffer &);\n+  template <typename F> void assign_to (F, function_buffer);\n+  invoker_type invoker;\n+};\n+class function0\n+{\n+public:\n+  template <typename Functor> function0 (Functor)\n+  {\n+    typedef typename apply<Functor>::invoker_type invoker_type;\n+    basic_vtable0 stored_vtable { invoker_type::invoke };\n+    stored_vtable.assign_to (0, functor);\n+  }\n+  function_buffer functor;\n+};\n+class function : function0\n+{\n+public:\n+  template <typename Functor> function (Functor f) : function0 (f) {}\n+};\n+class test_unit_generator\n+{\n+};\n+class test_case\n+{\n+public:\n+  test_case (basic_cstring, basic_cstring, int, function);\n+};\n+struct auto_test_unit_registrar\n+{\n+  auto_test_unit_registrar (test_unit_generator);\n+};\n+template <typename F> F unwrap (F, int);\n+struct for_each_impl\n+{\n+  template <typename Iterator, typename LastIterator, typename TransformFunc,\n+\t    typename F>\n+  static void\n+  execute (Iterator, LastIterator, TransformFunc, F f)\n+  {\n+    identity<char> __trans_tmp_1;\n+    unwrap (f, 0)(__trans_tmp_1);\n+  }\n+};\n+template <typename, typename, typename F>\n+void\n+for_each (F f)\n+{\n+  for_each_impl::execute (0, 0, 0, f);\n+}\n+template <typename TestCaseTemplate> class test_case_template_invoker\n+{\n+public:\n+  void operator()()\n+  {\n+    TestCaseTemplate::run (0);\n+  }\n+};\n+template <typename Generator, typename TestCaseTemplate>\n+struct generate_test_case_4_type\n+{\n+  generate_test_case_4_type (basic_cstring, basic_cstring, int, Generator G)\n+    : m_test_case_name (0), m_test_case_file (0), m_holder (G)\n+  {\n+  }\n+  template <typename TestType> void operator()(identity<TestType>)\n+  {\n+    test_case (0, 0, 0, test_case_template_invoker<TestCaseTemplate> ());\n+  }\n+  basic_cstring m_test_case_name;\n+  basic_cstring m_test_case_file;\n+  Generator m_holder;\n+};\n+template <typename TestCaseTemplate>\n+class template_test_case_gen : public test_unit_generator\n+{\n+public:\n+  template_test_case_gen (basic_cstring, basic_cstring, int)\n+  {\n+    for_each<int, make_identity> (\n+      generate_test_case_4_type<template_test_case_gen, TestCaseTemplate> (\n+\t0, 0, 0, *this));\n+  }\n+};\n+class attribute_name\n+{\n+  int m_id;\n+\n+public:\n+  attribute_name (char);\n+};\n+template <typename> struct term;\n+namespace exprns_ {\n+template <typename> struct expr;\n+}\n+using exprns_::expr;\n+template <typename T> struct Trans_NS_proto_terminal\n+{\n+  typedef expr<term<T> > type;\n+};\n+namespace exprns_ {\n+template <typename Arg0> struct expr<term<Arg0> >\n+{\n+  Arg0 child0;\n+};\n+}\n+template <typename Expr> struct actor\n+{\n+  typename Trans_NS_proto_terminal<Expr>::type proto_expr_;\n+};\n+template <template <typename> class Actor = actor> struct terminal\n+{\n+  typedef Actor<int> type;\n+};\n+namespace log {\n+struct to_log_fun\n+{\n+};\n+class value_extractor;\n+template <typename, typename = value_extractor, typename = void,\n+\t  template <typename> class = actor>\n+class attribute_actor;\n+class attribute_terminal\n+{\n+public:\n+  attribute_name m_name;\n+  attribute_name\n+  get_name ()\n+  {\n+    return m_name;\n+  }\n+};\n+template <typename, typename, typename, template <typename> class ActorT>\n+class attribute_actor : ActorT<attribute_terminal>\n+{\n+public:\n+  typedef int value_type;\n+  attribute_name\n+  get_name ()\n+  {\n+    return this->proto_expr_.child0.get_name ();\n+  }\n+};\n+template <typename AttributeValueT>\n+attribute_actor<AttributeValueT> attr (attribute_name);\n+terminal<>::type stream;\n+template <typename LeftT, typename ImplT> class attribute_output_terminal\n+{\n+public:\n+  template <typename U>\n+  attribute_output_terminal (LeftT, attribute_name, ImplT, U);\n+};\n+template <typename LeftT> struct make_output_expression\n+{\n+  typedef attribute_output_terminal<LeftT, to_log_fun> type;\n+  template <typename RightT>\n+  static type\n+  make (LeftT left, RightT &right)\n+  {\n+    type (left, right.get_name (), to_log_fun (), 0);\n+  }\n+};\n+template <typename, typename RightT, typename = typename RightT::value_type>\n+struct make_output_actor;\n+template <template <typename> class ActorT, typename LeftExprT,\n+\t  typename RightT, typename ValueT>\n+struct make_output_actor<ActorT<LeftExprT>, RightT, ValueT>\n+{\n+  typedef make_output_expression<ActorT<LeftExprT> > make_expression;\n+  typedef ActorT<typename make_expression::type> type;\n+  static type\n+  make (ActorT<LeftExprT> left, RightT &right)\n+  {\n+    type { make_expression::make (left, right) };\n+  }\n+};\n+template <typename LeftExprT, typename T, typename FallbackPolicyT,\n+\t  typename TagT>\n+typename make_output_actor<actor<LeftExprT>, attribute_actor<TagT> >::type\n+operator<<(actor<LeftExprT> left,\n+\t   attribute_actor<T, FallbackPolicyT, TagT> right)\n+{\n+  make_output_actor<actor<LeftExprT>, attribute_actor<T> >::make (left, right);\n+}\n+}\n+}\n+namespace logging = boost::log;\n+namespace expr = logging;\n+namespace {\n+class my_class;\n+}\n+template <typename> struct default_formatting\n+{\n+  void test_method ();\n+};\n+struct default_formatting_invoker\n+{\n+  static void\n+  run (void *)\n+  {\n+    default_formatting<int> t;\n+    t.test_method ();\n+  }\n+};\n+boost::auto_test_unit_registrar default_formatting_registrar56 (\n+  boost::template_test_case_gen<default_formatting_invoker> (0, 0, 0));\n+template <typename CharT>\n+void\n+default_formatting<CharT>::test_method ()\n+{\n+  expr::stream << expr::attr<my_class> (0);\n+  expr::stream << expr::attr<int> (0) << expr::attr<int> (0)\n+\t       << expr::attr<int> (0);\n+}"}]}