{"sha": "4af29981ab57ad7ef4467e371e4145cce9c16eaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFmMjk5ODFhYjU3YWQ3ZWY0NDY3ZTM3MWU0MTQ1Y2NlOWMxNmVhYQ==", "commit": {"author": {"name": "Joel Hutton", "email": "joel.hutton@arm.com", "date": "2021-02-11T14:59:26Z"}, "committer": {"name": "Joel Hutton", "email": "joel.hutton@arm.com", "date": "2021-02-11T15:04:59Z"}, "message": "[aarch64][vect] Support V8QI->V8HI WIDEN_ patterns\n\nIn the case where 8 out of every 16 elements are widened using a\nwidening pattern and the next 8 are skipped, the patterns are not\nrecognized. This is because they are normally used in a pair, such  as\nVEC_WIDEN_MINUS_HI/LO, to achieve a v16qi->v16hi conversion for example.\nThis patch adds support for V8QI->V8HI patterns.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/98772\n\t* optabs-tree.c (supportable_half_widening_operation): New function\n\tto check for supportable V8QI->V8HI widening patterns.\n\t* optabs-tree.h (supportable_half_widening_operation): New function.\n\t* tree-vect-stmts.c (vect_create_half_widening_stmts): New function\n\tto create promotion stmts for V8QI->V8HI widening patterns.\n\t(vectorizable_conversion): Add case for V8QI->V8HI.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/98772\n\t* gcc.target/aarch64/pr98772.c: New test.", "tree": {"sha": "a462a2e43e923cb3cab8caa4694f51e53dff6519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a462a2e43e923cb3cab8caa4694f51e53dff6519"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4af29981ab57ad7ef4467e371e4145cce9c16eaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af29981ab57ad7ef4467e371e4145cce9c16eaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4af29981ab57ad7ef4467e371e4145cce9c16eaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af29981ab57ad7ef4467e371e4145cce9c16eaa/comments", "author": {"login": "JoelHutton", "id": 4455754, "node_id": "MDQ6VXNlcjQ0NTU3NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4455754?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoelHutton", "html_url": "https://github.com/JoelHutton", "followers_url": "https://api.github.com/users/JoelHutton/followers", "following_url": "https://api.github.com/users/JoelHutton/following{/other_user}", "gists_url": "https://api.github.com/users/JoelHutton/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoelHutton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoelHutton/subscriptions", "organizations_url": "https://api.github.com/users/JoelHutton/orgs", "repos_url": "https://api.github.com/users/JoelHutton/repos", "events_url": "https://api.github.com/users/JoelHutton/events{/privacy}", "received_events_url": "https://api.github.com/users/JoelHutton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoelHutton", "id": 4455754, "node_id": "MDQ6VXNlcjQ0NTU3NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4455754?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoelHutton", "html_url": "https://github.com/JoelHutton", "followers_url": "https://api.github.com/users/JoelHutton/followers", "following_url": "https://api.github.com/users/JoelHutton/following{/other_user}", "gists_url": "https://api.github.com/users/JoelHutton/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoelHutton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoelHutton/subscriptions", "organizations_url": "https://api.github.com/users/JoelHutton/orgs", "repos_url": "https://api.github.com/users/JoelHutton/repos", "events_url": "https://api.github.com/users/JoelHutton/events{/privacy}", "received_events_url": "https://api.github.com/users/JoelHutton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff6903288d96aa1d28ae4912b1270985475f3ba8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6903288d96aa1d28ae4912b1270985475f3ba8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff6903288d96aa1d28ae4912b1270985475f3ba8"}], "stats": {"total": 322, "additions": 314, "deletions": 8}, "files": [{"sha": "95ffe397c23e80c105afea52e9d47216bf52f55a", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af29981ab57ad7ef4467e371e4145cce9c16eaa/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af29981ab57ad7ef4467e371e4145cce9c16eaa/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=4af29981ab57ad7ef4467e371e4145cce9c16eaa", "patch": "@@ -277,6 +277,75 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n     }\n }\n \n+/* Check whether an operation represented by CODE is a 'half' widening operation\n+   in which the input vector type has half the number of bits of the output\n+   vector type e.g. V8QI->V8HI.\n+\n+   This is handled by widening the inputs using NOP_EXPRs then using a\n+   non-widening stmt e.g. MINUS_EXPR.  RTL fusing converts these to the widening\n+   hardware instructions if supported.\n+\n+   The more typical case (handled in supportable_widening_operation) is where\n+   the input vector type has the same number of bits as the output vector type.\n+   In this case half the elements of the input vectors must be processed at a\n+   time into respective vector outputs with elements twice as wide i.e. a\n+   'hi'/'lo' pair using codes such as VEC_WIDEN_MINUS_HI/LO.\n+\n+   Supported widening operations:\n+    WIDEN_MINUS_EXPR\n+    WIDEN_PLUS_EXPR\n+    WIDEN_MULT_EXPR\n+    WIDEN_LSHIFT_EXPR\n+\n+   Output:\n+   - CODE1 - The non-widened code, which will be used after the inputs are\n+     converted to the wide type.  */\n+bool\n+supportable_half_widening_operation (enum tree_code code, tree vectype_out,\n+\t\t\t\t     tree vectype_in, enum tree_code *code1)\n+{\n+  machine_mode m1,m2;\n+  enum tree_code dummy_code;\n+  optab op;\n+\n+  gcc_assert (VECTOR_TYPE_P (vectype_out) && VECTOR_TYPE_P (vectype_in));\n+\n+  m1 = TYPE_MODE (vectype_out);\n+  m2 = TYPE_MODE (vectype_in);\n+\n+  if (!VECTOR_MODE_P (m1) || !VECTOR_MODE_P (m2))\n+    return false;\n+\n+  if (maybe_ne (TYPE_VECTOR_SUBPARTS (vectype_in),\n+\t\t  TYPE_VECTOR_SUBPARTS (vectype_out)))\n+    return false;\n+\n+  switch (code)\n+    {\n+    case WIDEN_LSHIFT_EXPR:\n+      *code1 = LSHIFT_EXPR;\n+      break;\n+    case WIDEN_MINUS_EXPR:\n+      *code1 = MINUS_EXPR;\n+      break;\n+    case WIDEN_PLUS_EXPR:\n+      *code1 = PLUS_EXPR;\n+      break;\n+    case WIDEN_MULT_EXPR:\n+      *code1 = MULT_EXPR;\n+      break;\n+    default:\n+      return false;\n+    }\n+\n+  if (!supportable_convert_operation (NOP_EXPR, vectype_out, vectype_in,\n+\t\t\t\t     &dummy_code))\n+    return false;\n+\n+  op = optab_for_tree_code (*code1, vectype_out, optab_vector);\n+  return (optab_handler (op, TYPE_MODE (vectype_out)) != CODE_FOR_nothing);\n+}\n+\n /* Function supportable_convert_operation\n \n    Check whether an operation represented by the code CODE is a"}, {"sha": "c3aaa1a416991e856d3e24da45968a92ebada82c", "filename": "gcc/optabs-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af29981ab57ad7ef4467e371e4145cce9c16eaa/gcc%2Foptabs-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af29981ab57ad7ef4467e371e4145cce9c16eaa/gcc%2Foptabs-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.h?ref=4af29981ab57ad7ef4467e371e4145cce9c16eaa", "patch": "@@ -36,6 +36,9 @@ enum optab_subtype\n    the second argument.  The third argument distinguishes between the types of\n    vector shifts and rotates.  */\n optab optab_for_tree_code (enum tree_code, const_tree, enum optab_subtype);\n+bool\n+supportable_half_widening_operation (enum tree_code, tree, tree,\n+\t\t\t\t    enum tree_code *);\n bool supportable_convert_operation (enum tree_code, tree, tree,\n \t\t\t\t    enum tree_code *);\n bool expand_vec_cmp_expr_p (tree, tree, enum tree_code);"}, {"sha": "663221514e9555f607231835c8c8435f956c7757", "filename": "gcc/testsuite/gcc.target/aarch64/pr98772.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af29981ab57ad7ef4467e371e4145cce9c16eaa/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr98772.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af29981ab57ad7ef4467e371e4145cce9c16eaa/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr98772.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr98772.c?ref=4af29981ab57ad7ef4467e371e4145cce9c16eaa", "patch": "@@ -0,0 +1,155 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -save-temps\" } */\n+#include <stdint.h>\n+#include <string.h>\n+\n+#define DSIZE 16\n+#define PIXSIZE 64\n+\n+extern void\n+wplus (uint16_t *d, uint8_t *restrict pix1, uint8_t *restrict pix2 )\n+{\n+    for (int y = 0; y < 4; y++ )\n+    {\n+\tfor (int x = 0; x < 4; x++ )\n+\t    d[x + y*4] = pix1[x] + pix2[x];\n+\tpix1 += 16;\n+\tpix2 += 16;\n+    }\n+}\n+extern void __attribute__((optimize (0)))\n+wplus_no_opt (uint16_t *d, uint8_t *restrict pix1, uint8_t *restrict pix2 )\n+{\n+    for (int y = 0; y < 4; y++ )\n+    {\n+\tfor (int x = 0; x < 4; x++ )\n+\t    d[x + y*4] = pix1[x] + pix2[x];\n+\tpix1 += 16;\n+\tpix2 += 16;\n+    }\n+}\n+\n+extern void\n+wminus (uint16_t *d, uint8_t *restrict pix1, uint8_t *restrict pix2 )\n+{\n+    for (int y = 0; y < 4; y++ )\n+    {\n+\tfor (int x = 0; x < 4; x++ )\n+\t    d[x + y*4] = pix1[x] - pix2[x];\n+\tpix1 += 16;\n+\tpix2 += 16;\n+    }\n+}\n+extern void __attribute__((optimize (0)))\n+wminus_no_opt (uint16_t *d, uint8_t *restrict pix1, uint8_t *restrict pix2 )\n+{\n+    for (int y = 0; y < 4; y++ )\n+    {\n+\tfor (int x = 0; x < 4; x++ )\n+\t    d[x + y*4] = pix1[x] - pix2[x];\n+\tpix1 += 16;\n+\tpix2 += 16;\n+    }\n+}\n+\n+extern void\n+wmult (uint16_t *d, uint8_t *restrict pix1, uint8_t *restrict pix2 )\n+{\n+    for (int y = 0; y < 4; y++ )\n+    {\n+\tfor (int x = 0; x < 4; x++ )\n+\t    d[x + y*4] = pix1[x] * pix2[x];\n+\tpix1 += 16;\n+\tpix2 += 16;\n+    }\n+}\n+extern void __attribute__((optimize (0)))\n+wmult_no_opt (uint16_t *d, uint8_t *restrict pix1, uint8_t *restrict pix2 )\n+{\n+    for (int y = 0; y < 4; y++ )\n+    {\n+\tfor (int x = 0; x < 4; x++ )\n+\t    d[x + y*4] = pix1[x] * pix2[x];\n+\tpix1 += 16;\n+\tpix2 += 16;\n+    }\n+}\n+\n+extern void\n+wlshift (uint16_t *d, uint8_t *restrict pix1)\n+\n+{\n+    for (int y = 0; y < 4; y++ )\n+    {\n+\tfor (int x = 0; x < 4; x++ )\n+\t    d[x + y*4] = pix1[x] << 8;\n+\tpix1 += 16;\n+    }\n+}\n+extern void __attribute__((optimize (0)))\n+wlshift_no_opt (uint16_t *d, uint8_t *restrict pix1)\n+\n+{\n+    for (int y = 0; y < 4; y++ )\n+    {\n+\tfor (int x = 0; x < 4; x++ )\n+\t    d[x + y*4] = pix1[x] << 8;\n+\tpix1 += 16;\n+    }\n+}\n+\n+void __attribute__((optimize (0)))\n+init_arrays (uint16_t *d_a, uint16_t *d_b, uint8_t *pix1, uint8_t *pix2)\n+{\n+  for (int i = 0; i < DSIZE; i++)\n+  {\n+    d_a[i] = (1074 * i)%17;\n+    d_b[i] = (1074 * i)%17;\n+  }\n+  for (int i = 0; i < PIXSIZE; i++)\n+  {\n+    pix1[i] = (1024 * i)%17;\n+    pix2[i] = (1024 * i)%17;\n+  }\n+}\n+\n+/* Don't optimize main so we don't get confused over where the vector\n+   instructions are generated. */\n+__attribute__((optimize (0)))\n+int main ()\n+{\n+  uint16_t d_a[DSIZE];\n+  uint16_t d_b[DSIZE];\n+  uint8_t pix1[PIXSIZE];\n+  uint8_t pix2[PIXSIZE];\n+\n+  init_arrays (d_a, d_b, pix1, pix2);\n+  wplus (d_a, pix1, pix2);\n+  wplus_no_opt (d_b, pix1, pix2);\n+  if (memcmp (d_a,d_b, DSIZE) != 0)\n+    return 1;\n+\n+  init_arrays (d_a, d_b, pix1, pix2);\n+  wminus (d_a, pix1, pix2);\n+  wminus_no_opt (d_b, pix1, pix2);\n+  if (memcmp (d_a,d_b, DSIZE) != 0)\n+    return 2;\n+\n+  init_arrays (d_a, d_b, pix1, pix2);\n+  wmult (d_a, pix1, pix2);\n+  wmult_no_opt (d_b, pix1, pix2);\n+  if (memcmp (d_a,d_b, DSIZE) != 0)\n+    return 3;\n+\n+  init_arrays (d_a, d_b, pix1, pix2);\n+  wlshift (d_a, pix1);\n+  wlshift_no_opt (d_b, pix1);\n+  if (memcmp (d_a,d_b, DSIZE) != 0)\n+    return 4;\n+\n+}\n+\n+/* { dg-final { scan-assembler-times \"uaddl\\\\tv\" 2 } } */\n+/* { dg-final { scan-assembler-times \"usubl\\\\tv\" 2 } } */\n+/* { dg-final { scan-assembler-times \"umull\\\\tv\" 2 } } */\n+/* { dg-final { scan-assembler-times \"shl\\\\tv\" 2 } } */"}, {"sha": "083f38bab143b3728e4e1667ad8e6182f3c63545", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 87, "deletions": 8, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af29981ab57ad7ef4467e371e4145cce9c16eaa/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af29981ab57ad7ef4467e371e4145cce9c16eaa/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=4af29981ab57ad7ef4467e371e4145cce9c16eaa", "patch": "@@ -4544,6 +4544,64 @@ vect_create_vectorized_promotion_stmts (vec_info *vinfo,\n   *vec_oprnds0 = vec_tmp;\n }\n \n+/* Create vectorized promotion stmts for widening stmts using only half the\n+   potential vector size for input.  */\n+static void\n+vect_create_half_widening_stmts (vec_info *vinfo,\n+\t\t\t\t\tvec<tree> *vec_oprnds0,\n+\t\t\t\t\tvec<tree> *vec_oprnds1,\n+\t\t\t\t\tstmt_vec_info stmt_info, tree vec_dest,\n+\t\t\t\t\tgimple_stmt_iterator *gsi,\n+\t\t\t\t\tenum tree_code code1,\n+\t\t\t\t\tint op_type)\n+{\n+  int i;\n+  tree vop0, vop1;\n+  gimple *new_stmt1;\n+  gimple *new_stmt2;\n+  gimple *new_stmt3;\n+  vec<tree> vec_tmp = vNULL;\n+\n+  vec_tmp.create (vec_oprnds0->length ());\n+  FOR_EACH_VEC_ELT (*vec_oprnds0, i, vop0)\n+    {\n+      tree new_tmp1, new_tmp2, new_tmp3, out_type;\n+\n+      gcc_assert (op_type == binary_op);\n+      vop1 = (*vec_oprnds1)[i];\n+\n+      /* Widen the first vector input.  */\n+      out_type = TREE_TYPE (vec_dest);\n+      new_tmp1 = make_ssa_name (out_type);\n+      new_stmt1 = gimple_build_assign (new_tmp1, NOP_EXPR, vop0);\n+      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt1, gsi);\n+      if (VECTOR_TYPE_P (TREE_TYPE (vop1)))\n+\t{\n+\t  /* Widen the second vector input.  */\n+\t  new_tmp2 = make_ssa_name (out_type);\n+\t  new_stmt2 = gimple_build_assign (new_tmp2, NOP_EXPR, vop1);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt2, gsi);\n+\t  /* Perform the operation.  With both vector inputs widened.  */\n+\t  new_stmt3 = gimple_build_assign (vec_dest, code1, new_tmp1, new_tmp2);\n+\t}\n+      else\n+\t{\n+\t  /* Perform the operation.  With the single vector input widened.  */\n+\t  new_stmt3 = gimple_build_assign (vec_dest, code1, new_tmp1, vop1);\n+      }\n+\n+      new_tmp3 = make_ssa_name (vec_dest, new_stmt3);\n+      gimple_assign_set_lhs (new_stmt3, new_tmp3);\n+      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt3, gsi);\n+\n+      /* Store the results for the next step.  */\n+      vec_tmp.quick_push (new_tmp3);\n+    }\n+\n+  vec_oprnds0->release ();\n+  *vec_oprnds0 = vec_tmp;\n+}\n+\n \n /* Check if STMT_INFO performs a conversion operation that can be vectorized.\n    If VEC_STMT is also passed, vectorize STMT_INFO: create a vectorized\n@@ -4696,7 +4754,13 @@ vectorizable_conversion (vec_info *vinfo,\n   nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n   if (known_eq (nunits_out, nunits_in))\n-    modifier = NONE;\n+    if (code == WIDEN_MINUS_EXPR\n+\t|| code == WIDEN_PLUS_EXPR\n+\t|| code == WIDEN_LSHIFT_EXPR\n+\t|| code == WIDEN_MULT_EXPR)\n+      modifier = WIDEN;\n+    else\n+      modifier = NONE;\n   else if (multiple_p (nunits_out, nunits_in))\n     modifier = NARROW;\n   else\n@@ -4742,9 +4806,18 @@ vectorizable_conversion (vec_info *vinfo,\n       return false;\n \n     case WIDEN:\n-      if (supportable_widening_operation (vinfo, code, stmt_info, vectype_out,\n-\t\t\t\t\t  vectype_in, &code1, &code2,\n-\t\t\t\t\t  &multi_step_cvt, &interm_types))\n+      if (known_eq (nunits_in, nunits_out))\n+\t{\n+\t  if (!supportable_half_widening_operation (code, vectype_out,\n+\t\t\t\t\t\t   vectype_in, &code1))\n+\t    goto unsupported;\n+\t  gcc_assert (!(multi_step_cvt && op_type == binary_op));\n+\t  break;\n+\t}\n+      if (supportable_widening_operation (vinfo, code, stmt_info,\n+\t\t\t\t\t       vectype_out, vectype_in, &code1,\n+\t\t\t\t\t       &code2, &multi_step_cvt,\n+\t\t\t\t\t       &interm_types))\n \t{\n \t  /* Binary widening operation can only be supported directly by the\n \t     architecture.  */\n@@ -4980,10 +5053,16 @@ vectorizable_conversion (vec_info *vinfo,\n \t      c1 = codecvt1;\n \t      c2 = codecvt2;\n \t    }\n-\t  vect_create_vectorized_promotion_stmts (vinfo, &vec_oprnds0,\n-\t\t\t\t\t\t  &vec_oprnds1, stmt_info,\n-\t\t\t\t\t\t  this_dest, gsi,\n-\t\t\t\t\t\t  c1, c2, op_type);\n+\t  if (known_eq (nunits_out, nunits_in))\n+\t    vect_create_half_widening_stmts (vinfo, &vec_oprnds0,\n+\t\t\t\t\t\t    &vec_oprnds1, stmt_info,\n+\t\t\t\t\t\t    this_dest, gsi,\n+\t\t\t\t\t\t    c1, op_type);\n+\t  else\n+\t    vect_create_vectorized_promotion_stmts (vinfo, &vec_oprnds0,\n+\t\t\t\t\t\t    &vec_oprnds1, stmt_info,\n+\t\t\t\t\t\t    this_dest, gsi,\n+\t\t\t\t\t\t    c1, c2, op_type);\n \t}\n \n       FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)"}]}