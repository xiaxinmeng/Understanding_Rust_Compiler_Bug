{"sha": "0fbdb0c08856e9c37373cf04faef3213c3903531", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZiZGIwYzA4ODU2ZTljMzczNzNjZjA0ZmFlZjMyMTNjMzkwMzUzMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-07-31T09:46:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-07-31T09:46:18Z"}, "message": "re PR tree-optimization/91178 (Infinite recursion in split_constant_offset in slp after r260289)\n\n2019-07-31  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/91178\n\t* tree-ssa-sccvn.c (vn_reference_maybe_forwprop_address):\n\tUse tail-recursion.\n\n\t* gcc.dg/torture/pr91178-2.c: New testcase.\n\nFrom-SVN: r273928", "tree": {"sha": "6b6a711293c01257c59e73102c96bf15dad0a945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b6a711293c01257c59e73102c96bf15dad0a945"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fbdb0c08856e9c37373cf04faef3213c3903531", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fbdb0c08856e9c37373cf04faef3213c3903531", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fbdb0c08856e9c37373cf04faef3213c3903531", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fbdb0c08856e9c37373cf04faef3213c3903531/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1104467f3933078a019df1fb89149f5da39f7953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1104467f3933078a019df1fb89149f5da39f7953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1104467f3933078a019df1fb89149f5da39f7953"}], "stats": {"total": 226, "additions": 129, "deletions": 97}, "files": [{"sha": "c7b99f2ef26655e9473897fae8733e22b475ea14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fbdb0c08856e9c37373cf04faef3213c3903531/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fbdb0c08856e9c37373cf04faef3213c3903531/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fbdb0c08856e9c37373cf04faef3213c3903531", "patch": "@@ -1,3 +1,9 @@\n+2019-07-31  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91178\n+\t* tree-ssa-sccvn.c (vn_reference_maybe_forwprop_address):\n+\tUse tail-recursion.\n+\n 2019-07-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/91201"}, {"sha": "44166d1385eff280e33c47636818fbb57e548a6e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fbdb0c08856e9c37373cf04faef3213c3903531/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fbdb0c08856e9c37373cf04faef3213c3903531/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0fbdb0c08856e9c37373cf04faef3213c3903531", "patch": "@@ -1,3 +1,8 @@\n+2019-07-31  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91178\n+\t* gcc.dg/torture/pr91178-2.c: New testcase.\n+\n 2019-07-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/91201"}, {"sha": "0ebb4700b2afb068038645c53efa7aa31e5c8377", "filename": "gcc/testsuite/gcc.dg/torture/pr91178-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fbdb0c08856e9c37373cf04faef3213c3903531/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr91178-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fbdb0c08856e9c37373cf04faef3213c3903531/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr91178-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr91178-2.c?ref=0fbdb0c08856e9c37373cf04faef3213c3903531", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+\n+int a[100][70304];\n+int b[100];\n+void c()\n+{\n+  for (int d = 2; d < 4; d++)\n+    for (int e = 2; e <= 50; e++)\n+      for (int f = 32; f <= 38; f++)\n+\tb[d + f] -= a[e][5];\n+}"}, {"sha": "eb7e4be09e699783173f37b0504dbc733a05ea9c", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 107, "deletions": 97, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fbdb0c08856e9c37373cf04faef3213c3903531/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fbdb0c08856e9c37373cf04faef3213c3903531/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=0fbdb0c08856e9c37373cf04faef3213c3903531", "patch": "@@ -1249,113 +1249,123 @@ static bool\n vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n \t\t\t\t     unsigned int *i_p)\n {\n-  unsigned int i = *i_p;\n-  vn_reference_op_t op = &(*ops)[i];\n-  vn_reference_op_t mem_op = &(*ops)[i - 1];\n-  gimple *def_stmt;\n-  enum tree_code code;\n-  poly_offset_int off;\n-\n-  def_stmt = SSA_NAME_DEF_STMT (op->op0);\n-  if (!is_gimple_assign (def_stmt))\n-    return false;\n-\n-  code = gimple_assign_rhs_code (def_stmt);\n-  if (code != ADDR_EXPR\n-      && code != POINTER_PLUS_EXPR)\n-    return false;\n-\n-  off = poly_offset_int::from (wi::to_poly_wide (mem_op->op0), SIGNED);\n+  bool changed = false;\n+  vn_reference_op_t op;\n \n-  /* The only thing we have to do is from &OBJ.foo.bar add the offset\n-     from .foo.bar to the preceding MEM_REF offset and replace the\n-     address with &OBJ.  */\n-  if (code == ADDR_EXPR)\n+  do\n     {\n-      tree addr, addr_base;\n-      poly_int64 addr_offset;\n-\n-      addr = gimple_assign_rhs1 (def_stmt);\n-      addr_base = get_addr_base_and_unit_offset (TREE_OPERAND (addr, 0),\n-\t\t\t\t\t\t &addr_offset);\n-      /* If that didn't work because the address isn't invariant propagate\n-         the reference tree from the address operation in case the current\n-\t dereference isn't offsetted.  */\n-      if (!addr_base\n-\t  && *i_p == ops->length () - 1\n-\t  && known_eq (off, 0)\n-\t  /* This makes us disable this transform for PRE where the\n-\t     reference ops might be also used for code insertion which\n-\t     is invalid.  */\n-\t  && default_vn_walk_kind == VN_WALKREWRITE)\n+      unsigned int i = *i_p;\n+      op = &(*ops)[i];\n+      vn_reference_op_t mem_op = &(*ops)[i - 1];\n+      gimple *def_stmt;\n+      enum tree_code code;\n+      poly_offset_int off;\n+\n+      def_stmt = SSA_NAME_DEF_STMT (op->op0);\n+      if (!is_gimple_assign (def_stmt))\n+\treturn changed;\n+\n+      code = gimple_assign_rhs_code (def_stmt);\n+      if (code != ADDR_EXPR\n+\t  && code != POINTER_PLUS_EXPR)\n+\treturn changed;\n+\n+      off = poly_offset_int::from (wi::to_poly_wide (mem_op->op0), SIGNED);\n+\n+      /* The only thing we have to do is from &OBJ.foo.bar add the offset\n+\t from .foo.bar to the preceding MEM_REF offset and replace the\n+\t address with &OBJ.  */\n+      if (code == ADDR_EXPR)\n \t{\n-\t  auto_vec<vn_reference_op_s, 32> tem;\n-\t  copy_reference_ops_from_ref (TREE_OPERAND (addr, 0), &tem);\n-\t  /* Make sure to preserve TBAA info.  The only objects not\n-\t     wrapped in MEM_REFs that can have their address taken are\n-\t     STRING_CSTs.  */\n-\t  if (tem.length () >= 2\n-\t      && tem[tem.length () - 2].opcode == MEM_REF)\n+\t  tree addr, addr_base;\n+\t  poly_int64 addr_offset;\n+\n+\t  addr = gimple_assign_rhs1 (def_stmt);\n+\t  addr_base = get_addr_base_and_unit_offset (TREE_OPERAND (addr, 0),\n+\t\t\t\t\t\t     &addr_offset);\n+\t  /* If that didn't work because the address isn't invariant propagate\n+\t     the reference tree from the address operation in case the current\n+\t     dereference isn't offsetted.  */\n+\t  if (!addr_base\n+\t      && *i_p == ops->length () - 1\n+\t      && known_eq (off, 0)\n+\t      /* This makes us disable this transform for PRE where the\n+\t\t reference ops might be also used for code insertion which\n+\t\t is invalid.  */\n+\t      && default_vn_walk_kind == VN_WALKREWRITE)\n \t    {\n-\t      vn_reference_op_t new_mem_op = &tem[tem.length () - 2];\n-\t      new_mem_op->op0\n-\t\t= wide_int_to_tree (TREE_TYPE (mem_op->op0),\n-\t\t\t\t    wi::to_poly_wide (new_mem_op->op0));\n+\t      auto_vec<vn_reference_op_s, 32> tem;\n+\t      copy_reference_ops_from_ref (TREE_OPERAND (addr, 0), &tem);\n+\t      /* Make sure to preserve TBAA info.  The only objects not\n+\t\t wrapped in MEM_REFs that can have their address taken are\n+\t\t STRING_CSTs.  */\n+\t      if (tem.length () >= 2\n+\t\t  && tem[tem.length () - 2].opcode == MEM_REF)\n+\t\t{\n+\t\t  vn_reference_op_t new_mem_op = &tem[tem.length () - 2];\n+\t\t  new_mem_op->op0\n+\t\t      = wide_int_to_tree (TREE_TYPE (mem_op->op0),\n+\t\t\t\t\t  wi::to_poly_wide (new_mem_op->op0));\n+\t\t}\n+\t      else\n+\t\tgcc_assert (tem.last ().opcode == STRING_CST);\n+\t      ops->pop ();\n+\t      ops->pop ();\n+\t      ops->safe_splice (tem);\n+\t      --*i_p;\n+\t      return true;\n \t    }\n-\t  else\n-\t    gcc_assert (tem.last ().opcode == STRING_CST);\n-\t  ops->pop ();\n-\t  ops->pop ();\n-\t  ops->safe_splice (tem);\n-\t  --*i_p;\n-\t  return true;\n+\t  if (!addr_base\n+\t      || TREE_CODE (addr_base) != MEM_REF\n+\t      || (TREE_CODE (TREE_OPERAND (addr_base, 0)) == SSA_NAME\n+\t\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (addr_base,\n+\t\t\t\t\t\t\t\t    0))))\n+\t    return changed;\n+\n+\t  off += addr_offset;\n+\t  off += mem_ref_offset (addr_base);\n+\t  op->op0 = TREE_OPERAND (addr_base, 0);\n+\t}\n+      else\n+\t{\n+\t  tree ptr, ptroff;\n+\t  ptr = gimple_assign_rhs1 (def_stmt);\n+\t  ptroff = gimple_assign_rhs2 (def_stmt);\n+\t  if (TREE_CODE (ptr) != SSA_NAME\n+\t      || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ptr)\n+\t      /* Make sure to not endlessly recurse.\n+\t\t See gcc.dg/tree-ssa/20040408-1.c for an example.  Can easily\n+\t\t happen when we value-number a PHI to its backedge value.  */\n+\t      || SSA_VAL (ptr) == op->op0\n+\t      || !poly_int_tree_p (ptroff))\n+\t    return changed;\n+\n+\t  off += wi::to_poly_offset (ptroff);\n+\t  op->op0 = ptr;\n \t}\n-      if (!addr_base\n-\t  || TREE_CODE (addr_base) != MEM_REF\n-\t  || (TREE_CODE (TREE_OPERAND (addr_base, 0)) == SSA_NAME\n-\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (addr_base, 0))))\n-\treturn false;\n-\n-      off += addr_offset;\n-      off += mem_ref_offset (addr_base);\n-      op->op0 = TREE_OPERAND (addr_base, 0);\n-    }\n-  else\n-    {\n-      tree ptr, ptroff;\n-      ptr = gimple_assign_rhs1 (def_stmt);\n-      ptroff = gimple_assign_rhs2 (def_stmt);\n-      if (TREE_CODE (ptr) != SSA_NAME\n-\t  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ptr)\n-\t  /* Make sure to not endlessly recurse.\n-\t     See gcc.dg/tree-ssa/20040408-1.c for an example.  Can easily\n-\t     happen when we value-number a PHI to its backedge value.  */\n-\t  || SSA_VAL (ptr) == op->op0\n-\t  || !poly_int_tree_p (ptroff))\n-\treturn false;\n \n-      off += wi::to_poly_offset (ptroff);\n-      op->op0 = ptr;\n+      mem_op->op0 = wide_int_to_tree (TREE_TYPE (mem_op->op0), off);\n+      if (tree_fits_shwi_p (mem_op->op0))\n+\tmem_op->off = tree_to_shwi (mem_op->op0);\n+      else\n+\tmem_op->off = -1;\n+      /* ???  Can end up with endless recursion here!?\n+\t gcc.c-torture/execute/strcmp-1.c  */\n+      if (TREE_CODE (op->op0) == SSA_NAME)\n+\top->op0 = SSA_VAL (op->op0);\n+      if (TREE_CODE (op->op0) != SSA_NAME)\n+\top->opcode = TREE_CODE (op->op0);\n+\n+      changed = true;\n     }\n+  /* Tail-recurse.  */\n+  while (TREE_CODE (op->op0) == SSA_NAME);\n \n-  mem_op->op0 = wide_int_to_tree (TREE_TYPE (mem_op->op0), off);\n-  if (tree_fits_shwi_p (mem_op->op0))\n-    mem_op->off = tree_to_shwi (mem_op->op0);\n-  else\n-    mem_op->off = -1;\n-  /* ???  Can end up with endless recursion here!?\n-     gcc.c-torture/execute/strcmp-1.c  */\n-  if (TREE_CODE (op->op0) == SSA_NAME)\n-    op->op0 = SSA_VAL (op->op0);\n-  if (TREE_CODE (op->op0) != SSA_NAME)\n-    op->opcode = TREE_CODE (op->op0);\n-\n-  /* And recurse.  */\n-  if (TREE_CODE (op->op0) == SSA_NAME)\n-    vn_reference_maybe_forwprop_address (ops, i_p);\n-  else if (TREE_CODE (op->op0) == ADDR_EXPR)\n+  /* Fold a remaining *&.  */\n+  if (TREE_CODE (op->op0) == ADDR_EXPR)\n     vn_reference_fold_indirect (ops, i_p);\n-  return true;\n+\n+  return changed;\n }\n \n /* Optimize the reference REF to a constant if possible or return"}]}