{"sha": "b40c4f68160a4b556135185e8b5e013ab77ba2ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQwYzRmNjgxNjBhNGI1NTYxMzUxODVlOGI1ZTAxM2FiNzdiYTJlYw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2007-06-29T10:30:06Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-06-29T10:30:06Z"}, "message": "re PR tree-optimization/24659 (Conversions are not vectorized)\n\n\tPR tree-optimization/24659\n\t* tree-vect-transform.c (vectorizable_call): Handle\n\t(nunits_in == nunits_out / 2) and (nunits_out == nunits_in / 2) cases.\n\n\t* config/i386/sse.md (vec_pack_sfix_v2df): New expander.\n\t* config/i386/i386.c (enum ix86_builtins)\n\t[IX86_BUILTIN_VEC_PACK_SFIX]: New constant.\n\t(struct bdesc_2arg) [__builtin_ia32_vec_pack_sfix]: New builtin\n\tdescription.\n\t(ix86_init_mmx_sse_builtins): Define all builtins with 2 arguments as\n\tconst using def_builtin_const.\n\t(ix86_expand_binop_builtin): Remove bogus assert() that insn wants\n\tinput operands in the same modes as the result.\n\t(ix86_builtin_vectorized_function): Handle BUILT_IN_LRINT.\n\ntestsuite/ChangeLog:\n\n\tPR tree-optimization/24659\n\t* gcc.target/i386/vectorize2.c: New test.\n\t* gcc.target/i386/sse2-lrint-vec.c: New runtime test.\n\t* gcc.target/i386/sse2-lrintf-vec.c: Ditto.\n\nFrom-SVN: r126111", "tree": {"sha": "332c2a8a980e60c5f65e31276d3aa5472059f7e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/332c2a8a980e60c5f65e31276d3aa5472059f7e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b40c4f68160a4b556135185e8b5e013ab77ba2ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40c4f68160a4b556135185e8b5e013ab77ba2ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b40c4f68160a4b556135185e8b5e013ab77ba2ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40c4f68160a4b556135185e8b5e013ab77ba2ec/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "690f48b1b48b5626cb9b78944f1da201d11e00ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/690f48b1b48b5626cb9b78944f1da201d11e00ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/690f48b1b48b5626cb9b78944f1da201d11e00ec"}], "stats": {"total": 358, "additions": 307, "deletions": 51}, "files": [{"sha": "082dfa8b5f18283c3cc31e050c4182d4f72bca55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b40c4f68160a4b556135185e8b5e013ab77ba2ec", "patch": "@@ -1,3 +1,20 @@\n+2007-06-29  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR tree-optimization/24659\n+\t* tree-vect-transform.c (vectorizable_call): Handle\n+\t(nunits_in == nunits_out / 2) and (nunits_out == nunits_in / 2) cases.\n+\n+\t* config/i386/sse.md (vec_pack_sfix_v2df): New expander.\n+\t* config/i386/i386.c (enum ix86_builtins)\n+\t[IX86_BUILTIN_VEC_PACK_SFIX]: New constant.\n+\t(struct bdesc_2arg) [__builtin_ia32_vec_pack_sfix]: New builtin\n+\tdescription.\n+\t(ix86_init_mmx_sse_builtins): Define all builtins with 2 arguments as\n+\tconst using def_builtin_const.\n+\t(ix86_expand_binop_builtin): Remove bogus assert() that insn wants\n+\tinput operands in the same modes as the result.\n+\t(ix86_builtin_vectorized_function): Handle BUILT_IN_LRINT.\n+\n 2007-06-29  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* df-problems.c (df_set_unused_notes_for_mw): Fix formatting.\n@@ -264,7 +281,7 @@\n \t* gimplify.c (mark_addressable): New function.\n \t(gimplify_modify_expr_rhs, gimplify_addr_expr, gimplify_expr): Use it.\n \n-2007-06-19  Uros Bizjak  <ubizjak@gmail.com>\n+2007-06-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR middle-end/32374\n \t* expr.c (store_constructor): Do not clobber non-zeroed memory. "}, {"sha": "96c948f6dea8ac1b49726561a63ae2b130eac3d5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b40c4f68160a4b556135185e8b5e013ab77ba2ec", "patch": "@@ -16820,6 +16820,8 @@ enum ix86_builtins\n   IX86_BUILTIN_VEC_SET_V4HI,\n   IX86_BUILTIN_VEC_SET_V16QI,\n \n+  IX86_BUILTIN_VEC_PACK_SFIX,\n+\n   /* SSE4.2.  */\n   IX86_BUILTIN_CRC32QI,\n   IX86_BUILTIN_CRC32HI,\n@@ -17167,6 +17169,8 @@ static const struct builtin_description bdesc_2arg[] =\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_sse2_unpckhpd, \"__builtin_ia32_unpckhpd\", IX86_BUILTIN_UNPCKHPD, UNKNOWN, 0 },\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_sse2_unpcklpd, \"__builtin_ia32_unpcklpd\", IX86_BUILTIN_UNPCKLPD, UNKNOWN, 0 },\n \n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_vec_pack_sfix_v2df, \"__builtin_ia32_vec_pack_sfix\", IX86_BUILTIN_VEC_PACK_SFIX, UNKNOWN, 0 },\n+\n   /* SSE2 MMX */\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_addv16qi3, \"__builtin_ia32_paddb128\", IX86_BUILTIN_PADDB128, UNKNOWN, 0 },\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_addv8hi3, \"__builtin_ia32_paddw128\", IX86_BUILTIN_PADDW128, UNKNOWN, 0 },\n@@ -17563,6 +17567,9 @@ ix86_init_mmx_sse_builtins (void)\n     = build_function_type_list (V2DF_type_node, V4SI_type_node, NULL_TREE);\n   tree v4si_ftype_v2df\n     = build_function_type_list (V4SI_type_node, V2DF_type_node, NULL_TREE);\n+  tree v4si_ftype_v2df_v2df\n+    = build_function_type_list (V4SI_type_node,\n+\t\t\t\tV2DF_type_node, V2DF_type_node, NULL_TREE);\n   tree v2si_ftype_v2df\n     = build_function_type_list (V2SI_type_node, V2DF_type_node, NULL_TREE);\n   tree v4sf_ftype_v2df\n@@ -17906,7 +17913,10 @@ ix86_init_mmx_sse_builtins (void)\n \t  || d->icode == CODE_FOR_sse2_vmmaskcmpv2df3)\n \ttype = v2di_ftype_v2df_v2df;\n \n-      def_builtin (d->mask, d->name, type, d->code);\n+      if (d->icode == CODE_FOR_vec_pack_sfix_v2df)\n+\ttype = v4si_ftype_v2df_v2df;\n+\n+      def_builtin_const (d->mask, d->name, type, d->code);\n     }\n \n   /* Add all builtins that are more or less simple operations on 1 operand.  */\n@@ -18457,11 +18467,6 @@ ix86_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n       op1 = gen_lowpart (TImode, x);\n     }\n \n-  /* The insn must want input operands in the same modes as the\n-     result.  */\n-  gcc_assert ((GET_MODE (op0) == mode0 || GET_MODE (op0) == VOIDmode)\n-\t      && (GET_MODE (op1) == mode1 || GET_MODE (op1) == VOIDmode));\n-\n   if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n   if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n@@ -19863,6 +19868,12 @@ ix86_builtin_vectorized_function (unsigned int fn, tree type_out,\n \treturn ix86_builtins[IX86_BUILTIN_SQRTPS];\n       return NULL_TREE;\n \n+    case BUILT_IN_LRINT:\n+      if (out_mode == SImode && out_n == 4\n+\t  && in_mode == DFmode && in_n == 2)\n+\treturn ix86_builtins[IX86_BUILTIN_VEC_PACK_SFIX];\n+      return NULL_TREE;\n+\n     case BUILT_IN_LRINTF:\n       if (out_mode == SImode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)"}, {"sha": "12b8cc832c87344ce94b9ea0e3f32b622a883fdd", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=b40c4f68160a4b556135185e8b5e013ab77ba2ec", "patch": "@@ -2421,6 +2421,26 @@\n   DONE;\n })\n \n+(define_expand \"vec_pack_sfix_v2df\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:V2DF 1 \"nonimmediate_operand\" \"\")\n+   (match_operand:V2DF 2 \"nonimmediate_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx r1, r2;\n+\n+  r1 = gen_reg_rtx (V4SImode);\n+  r2 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_sse2_cvtpd2dq (r1, operands[1]));\n+  emit_insn (gen_sse2_cvtpd2dq (r2, operands[2]));\n+  emit_insn (gen_sse2_punpcklqdq (gen_lowpart (V2DImode, operands[0]),\n+\t\t\t\t  gen_lowpart (V2DImode, r1),\n+\t\t\t\t  gen_lowpart (V2DImode, r2)));\n+  DONE;\n+})\n+\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel double-precision floating point element swizzling"}, {"sha": "2ac00bf8914b607c225cb98b51d628f87ba102b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b40c4f68160a4b556135185e8b5e013ab77ba2ec", "patch": "@@ -1,3 +1,10 @@\n+2007-06-29  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR tree-optimization/24659\n+\t* gcc.target/i386/vectorize2.c: New test.\n+\t* gcc.target/i386/sse2-lrint-vec.c: New runtime test.\n+\t* gcc.target/i386/sse2-lrintf-vec.c: Ditto.\n+\n 2007-06-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/pointer-arith-9.c: New test."}, {"sha": "35a7ac8dbb04298d4f52977708e36b7409103bbe", "filename": "gcc/testsuite/gcc.target/i386/sse2-lrint-vec.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-lrint-vec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-lrint-vec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-lrint-vec.c?ref=b40c4f68160a4b556135185e8b5e013ab77ba2ec", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ffast-math -ftree-vectorize -msse2\" } */\n+\n+#include \"../../gcc.dg/i386-cpuid.h\"\n+\n+extern long lrint (double);\n+extern void abort (void);\n+\n+#define N 32\n+\n+int __attribute__((noinline))\n+main1 ()\n+{\n+  double a[N] = {0.4,3.5,6.6,9.4,12.5,15.6,18.4,21.5,24.6,27.4,30.5,33.6,36.4,39.5,42.6,45.4,0.5,3.6,6.4,9.5,12.6,15.4,18.5,21.6,24.4,27.5,30.6,33.4,36.5,39.6,42.4,45.5};\n+  long r[N];\n+\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      r[i] = lrint (a[i]);\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (r[i] != lrint (a[i]))\n+\tabort();\n+    }   \n+\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  unsigned long cpu_facilities;\n+\n+  cpu_facilities = i386_cpuid ();\n+\n+  if ((cpu_facilities & (bit_MMX | bit_SSE | bit_SSE2 | bit_CMOV))\n+      != (bit_MMX | bit_SSE | bit_SSE2 | bit_CMOV))\n+    /* If host has no vector support, pass.  */\n+    return 0;\n+\n+  main1 ();\n+  return 0;\n+}"}, {"sha": "dc4ae93b7a22ec1c83e6074f1b827e4b95586afe", "filename": "gcc/testsuite/gcc.target/i386/sse2-lrintf-vec.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-lrintf-vec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-lrintf-vec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-lrintf-vec.c?ref=b40c4f68160a4b556135185e8b5e013ab77ba2ec", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ffast-math -ftree-vectorize -msse2\" } */\n+\n+#include \"../../gcc.dg/i386-cpuid.h\"\n+\n+extern long lrintf (float);\n+extern void abort (void);\n+\n+#define N 32\n+\n+int __attribute__((noinline))\n+main1 ()\n+{\n+  float a[N] = {0.4,3.5,6.6,9.4,12.5,15.6,18.4,21.5,24.6,27.4,30.5,33.6,36.4,39.5,42.6,45.4,0.5,3.6,6.4,9.5,12.6,15.4,18.5,21.6,24.4,27.5,30.6,33.4,36.5,39.6,42.4,45.5};\n+  long r[N];\n+\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      r[i] = lrintf (a[i]);\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (r[i] != lrintf (a[i]))\n+\tabort();\n+    }   \n+\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  unsigned long cpu_facilities;\n+\n+  cpu_facilities = i386_cpuid ();\n+\n+  if ((cpu_facilities & (bit_MMX | bit_SSE | bit_SSE2 | bit_CMOV))\n+      != (bit_MMX | bit_SSE | bit_SSE2 | bit_CMOV))\n+    /* If host has no vector support, pass.  */\n+    return 0;\n+\n+  main1 ();\n+  return 0;\n+}"}, {"sha": "4196487195971cabd70d3175f09a38f0619dffcb", "filename": "gcc/testsuite/gcc.target/i386/vectorize2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvectorize2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvectorize2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvectorize2.c?ref=b40c4f68160a4b556135185e8b5e013ab77ba2ec", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -ffast-math -ftree-vectorize -msse2 -mfpmath=sse\" } */\n+\n+double a[256];\n+int b[256];\n+unsigned short c[256];\n+\n+extern long lrint (double);\n+\n+void foo(void)\n+{\n+  int i;\n+\n+  for (i=0; i<256; ++i)\n+    b[i] = lrint (a[i]);\n+}\n+\n+void bar(void)\n+{\n+  int i;\n+\n+  for (i=0; i<256; ++i)\n+    {\n+      b[i] = lrint (a[i]);\n+      c[i] += c[i];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler \"cvtpd2dq\" } } */"}, {"sha": "5fdbbe122be422fcdb7d6a34e694fc04ddcf4055", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 119, "deletions": 44, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40c4f68160a4b556135185e8b5e013ab77ba2ec/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=b40c4f68160a4b556135185e8b5e013ab77ba2ec", "patch": "@@ -2253,13 +2253,19 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree scalar_dest;\n   tree operation;\n   tree op, type;\n+  tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt), prev_stmt_info;\n   tree vectype_out, vectype_in;\n+  int nunits_in;\n+  int nunits_out;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree fndecl, rhs, new_temp, def, def_stmt, rhs_type, lhs_type;\n   enum vect_def_type dt[2];\n+  tree new_stmt;\n   int ncopies, j, nargs;\n   call_expr_arg_iterator iter;\n+  tree vargs;\n+  enum { NARROW, NONE, WIDEN } modifier;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n@@ -2291,12 +2297,10 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   nargs = 0;\n   FOR_EACH_CALL_EXPR_ARG (op, iter, operation)\n     {\n-      ++nargs;\n-\n       /* Bail out if the function has more than two arguments, we\n \t do not have interesting builtin functions to vectorize with\n \t more than two arguments.  */\n-      if (nargs > 2)\n+      if (nargs >= 2)\n \treturn false;\n \n       /* We can only handle calls with arguments of the same type.  */\n@@ -2309,28 +2313,35 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t}\n       rhs_type = TREE_TYPE (op);\n \n-      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt[nargs-1]))\n+      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt[nargs]))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"use not simple.\");\n \t  return false;\n \t}\n+\n+      ++nargs;\n     }\n \n   /* No arguments is also not good.  */\n   if (nargs == 0)\n     return false;\n \n   vectype_in = get_vectype_for_scalar_type (rhs_type);\n+  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n \n   lhs_type = TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 0));\n   vectype_out = get_vectype_for_scalar_type (lhs_type);\n+  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n \n-  /* Only handle the case of vectors with the same number of elements.\n-     FIXME: We need a way to handle for example the SSE2 cvtpd2dq\n-\t    instruction which converts V2DFmode to V4SImode but only\n-\t    using the lower half of the V4SImode result.  */\n-  if (TYPE_VECTOR_SUBPARTS (vectype_in) != TYPE_VECTOR_SUBPARTS (vectype_out))\n+  /* FORNOW */\n+  if (nunits_in == nunits_out / 2)\n+    modifier = NARROW;\n+  else if (nunits_out == nunits_in)\n+    modifier = NONE;\n+  else if (nunits_out == nunits_in / 2)\n+    modifier = WIDEN;\n+  else\n     return false;\n \n   /* For now, we only vectorize functions if a target specific builtin\n@@ -2348,8 +2359,14 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   gcc_assert (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS));\n \n-  ncopies = (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t     / TYPE_VECTOR_SUBPARTS (vectype_out));\n+  if (modifier == NARROW)\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+\n+  /* Sanity check: make sure that at least one copy of the vectorized stmt\n+     needs to be generated.  */\n+  gcc_assert (ncopies >= 1);\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n@@ -2365,55 +2382,113 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform operation.\");\n \n-  gcc_assert (ncopies >= 1);\n-\n   /* Handle def.  */\n   scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n \n   prev_stmt_info = NULL;\n-  for (j = 0; j < ncopies; ++j)\n-    {\n-      tree new_stmt, vargs;\n-      tree vec_oprnd[2];\n-      int n;\n-\n-      /* Build argument list for the vectorized call.  */\n-      /* FIXME: Rewrite this so that it doesn't construct a temporary\n-\t  list.  */\n-      vargs = NULL_TREE;\n-      n = -1;\n-      FOR_EACH_CALL_EXPR_ARG (op, iter, operation)\n+  switch (modifier)\n+    {\n+    case NONE:\n+      for (j = 0; j < ncopies; ++j)\n+\t{\n+\t  /* Build argument list for the vectorized call.  */\n+\t  /* FIXME: Rewrite this so that it doesn't\n+\t     construct a temporary list.  */\n+\t  vargs = NULL_TREE;\n+\t  nargs = 0;\n+\t  FOR_EACH_CALL_EXPR_ARG (op, iter, operation)\n+\t    {\n+\t      if (j == 0)\n+\t\tvec_oprnd0\n+\t\t  = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t      else\n+\t\tvec_oprnd0\n+\t\t  = vect_get_vec_def_for_stmt_copy (dt[nargs], vec_oprnd0);\n+\n+\t      vargs = tree_cons (NULL_TREE, vec_oprnd0, vargs);\n+\n+\t      ++nargs;\n+\t    }\n+\t  vargs = nreverse (vargs);\n+\n+\t  rhs = build_function_call_expr (fndecl, vargs);\n+\t  new_stmt = build_gimple_modify_stmt (vec_dest, rhs);\n+\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+\n+\t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+\n+\t  if (j == 0)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t  else\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\n+\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t}\n+\n+      break;\n+\n+    case NARROW:\n+      for (j = 0; j < ncopies; ++j)\n \t{\n-\t  ++n;\n+\t  /* Build argument list for the vectorized call.  */\n+\t  /* FIXME: Rewrite this so that it doesn't\n+\t     construct a temporary list.  */\n+\t  vargs = NULL_TREE;\n+\t  nargs = 0;\n+\t  FOR_EACH_CALL_EXPR_ARG (op, iter, operation)\n+\t    {\n+\t      if (j == 0)\n+\t\t{\n+\t\t  vec_oprnd0\n+\t\t    = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t\t  vec_oprnd1\n+\t\t    = vect_get_vec_def_for_stmt_copy (dt[nargs], vec_oprnd0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  vec_oprnd0\n+\t\t    = vect_get_vec_def_for_stmt_copy (dt[nargs], vec_oprnd1);\n+\t\t  vec_oprnd1\n+\t\t    = vect_get_vec_def_for_stmt_copy (dt[nargs], vec_oprnd0);\n+\t\t}\n+\n+\t      vargs = tree_cons (NULL_TREE, vec_oprnd0, vargs);\n+\t      vargs = tree_cons (NULL_TREE, vec_oprnd1, vargs);\n+\n+\t      ++nargs;\n+\t    }\n+\t  vargs = nreverse (vargs);\n+\n+\t  rhs = build_function_call_expr (fndecl, vargs);\n+\t  new_stmt = build_gimple_modify_stmt (vec_dest, rhs);\n+\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+\n+\t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n \n \t  if (j == 0)\n-\t    vec_oprnd[n] = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n \t  else\n-\t    vec_oprnd[n] = vect_get_vec_def_for_stmt_copy (dt[n], vec_oprnd[n]);\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n \n-\t  vargs = tree_cons (NULL_TREE, vec_oprnd[n], vargs);\n+\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n \t}\n-      vargs = nreverse (vargs);\n \n-      rhs = build_function_call_expr (fndecl, vargs);\n-      new_stmt = build_gimple_modify_stmt (vec_dest, rhs);\n-      new_temp = make_ssa_name (vec_dest, new_stmt);\n-      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+      *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n \n-      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+      break;\n \n-      if (j == 0)\n-\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n-      else\n-\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+    case WIDEN:\n+      /* No current target implements this case.  */\n+      return false;\n     }\n \n-  /* The call in STMT might prevent it from being removed in dce.  We however\n-     cannot remove it here, due to the way the ssa name it defines is mapped\n-     to the new definition.  So just replace rhs of the statement with something\n-     harmless.  */\n+  /* The call in STMT might prevent it from being removed in dce.\n+     We however cannot remove it here, due to the way the ssa name\n+     it defines is mapped to the new definition.  So just replace\n+     rhs of the statement with something harmless.  */\n   type = TREE_TYPE (scalar_dest);\n   GIMPLE_STMT_OPERAND (stmt, 1) = fold_convert (type, integer_zero_node);\n   update_stmt (stmt);"}]}