{"sha": "23b9463ba60a1b5cc3a5262ee384e41622a70b26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNiOTQ2M2JhNjBhMWI1Y2MzYTUyNjJlZTM4NGU0MTYyMmE3MGIyNg==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-03-09T23:09:10Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-03-09T23:09:10Z"}, "message": "fold-const.c (fold_comparison): Remove compile-time evaluation of complex constant equality/inequality...\n\n\n\t* fold-const.c (fold_comparison): Remove compile-time evaluation of\n\tcomplex constant equality/inequality comparisons for here.\n\t(fold_binary) <EQ_EXPR>: Simplify complex comparisons that are\n\tknown at compile-time or can be simplified to a scalar comparison.\n\t(fold_relational_const): Move compile-time evaluation of complex\n\tconstant equality/inequality comparisons to here.\n\n\t* gcc.dg/fold-eqcmplx-1.c: New test case.\n\nFrom-SVN: r122767", "tree": {"sha": "1851abe5b6ab31a79b9123eb587ce0d579e400ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1851abe5b6ab31a79b9123eb587ce0d579e400ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23b9463ba60a1b5cc3a5262ee384e41622a70b26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b9463ba60a1b5cc3a5262ee384e41622a70b26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23b9463ba60a1b5cc3a5262ee384e41622a70b26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b9463ba60a1b5cc3a5262ee384e41622a70b26/comments", "author": null, "committer": null, "parents": [{"sha": "99b12b201d721d6d4706bea08f742ab0020e4704", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99b12b201d721d6d4706bea08f742ab0020e4704", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99b12b201d721d6d4706bea08f742ab0020e4704"}], "stats": {"total": 139, "additions": 115, "deletions": 24}, "files": [{"sha": "1cfe8e3dafa9af79e8b2badfba7df90ac13ed7c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b9463ba60a1b5cc3a5262ee384e41622a70b26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b9463ba60a1b5cc3a5262ee384e41622a70b26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23b9463ba60a1b5cc3a5262ee384e41622a70b26", "patch": "@@ -1,3 +1,12 @@\n+2007-03-09  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold_comparison): Remove compile-time evaluation of\n+\tcomplex constant equality/inequality comparisons for here.\n+\t(fold_binary) <EQ_EXPR>: Simplify complex comparisons that are\n+\tknown at compile-time or can be simplified to a scalar comparison.\n+\t(fold_relational_const): Move compile-time evaluation of complex\n+\tconstant equality/inequality comparisons to here.\n+\n 2007-03-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR rtl-optimization/30643\n@@ -7,7 +16,8 @@\n \n 2007-03-09  DJ Delorie  <dj@redhat.com>\n \n-\t* config/m32c/t-m32c (m32c-pragma.o): Add TM_H dependency to m32c-pragma.o\n+\t* config/m32c/t-m32c (m32c-pragma.o): Add TM_H dependency to\n+\tm32c-pragma.o.\n \n 2007-03-09  Aldy Hernandez  <aldyh@redhat.com>\n "}, {"sha": "74831a4f40f5c14e7f4fb10c21e4ca90f803c5e0", "filename": "gcc/fold-const.c", "status": "modified", "additions": 90, "deletions": 23, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b9463ba60a1b5cc3a5262ee384e41622a70b26/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b9463ba60a1b5cc3a5262ee384e41622a70b26/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=23b9463ba60a1b5cc3a5262ee384e41622a70b26", "patch": "@@ -8859,29 +8859,6 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t}\n     }\n \n-  /* If this is a comparison of complex values and both sides\n-     are COMPLEX_CST, do the comparison by parts to fold the\n-     comparison.  */\n-  if ((code == EQ_EXPR || code == NE_EXPR)\n-      && TREE_CODE (TREE_TYPE (arg0)) == COMPLEX_TYPE\n-      && TREE_CODE (arg0) == COMPLEX_CST\n-      && TREE_CODE (arg1) == COMPLEX_CST)\n-    {\n-      tree real0, imag0, real1, imag1;\n-      enum tree_code outercode;\n-\n-      real0 = TREE_REALPART (arg0);\n-      imag0 = TREE_IMAGPART (arg0);\n-      real1 = TREE_REALPART (arg1);\n-      imag1 = TREE_IMAGPART (arg1);\n-      outercode = code == EQ_EXPR ? TRUTH_ANDIF_EXPR : TRUTH_ORIF_EXPR;\n-\n-      return fold_build2 (outercode, type,\n-\t\t\t  fold_build2 (code, type, real0, real1),\n-\t\t\t  fold_build2 (code, type, imag0, imag1));\n-    }\n-\n-\n   /* Fold a comparison of the address of COMPONENT_REFs with the same\n      type and component to a comparison of the address of the base\n      object.  In short, &x->a OP &y->a to x OP y and\n@@ -11621,6 +11598,79 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t\t\t\t  arg01, arg11)),\n \t\t\t\targ10);\n \t}\n+\n+      /* Attempt to simplify equality/inequality comparisons of complex\n+\t values.  Only lower the comparison if the result is known or\n+\t can be simplified to a single scalar comparison.  */\n+      if ((TREE_CODE (arg0) == COMPLEX_EXPR\n+\t   || TREE_CODE (arg0) == COMPLEX_CST)\n+\t  && (TREE_CODE (arg1) == COMPLEX_EXPR\n+\t      || TREE_CODE (arg1) == COMPLEX_CST))\n+\t{\n+\t  tree real0, imag0, real1, imag1;\n+\t  tree rcond, icond;\n+\n+\t  if (TREE_CODE (arg0) == COMPLEX_EXPR)\n+\t    {\n+\t      real0 = TREE_OPERAND (arg0, 0);\n+\t      imag0 = TREE_OPERAND (arg0, 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      real0 = TREE_REALPART (arg0);\n+\t      imag0 = TREE_IMAGPART (arg0);\n+\t    }\n+\n+\t  if (TREE_CODE (arg1) == COMPLEX_EXPR)\n+\t    {\n+\t      real1 = TREE_OPERAND (arg1, 0);\n+\t      imag1 = TREE_OPERAND (arg1, 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      real1 = TREE_REALPART (arg1);\n+\t      imag1 = TREE_IMAGPART (arg1);\n+\t    }\n+\n+\t  rcond = fold_binary (code, type, real0, real1);\n+\t  if (rcond && TREE_CODE (rcond) == INTEGER_CST)\n+\t    {\n+\t      if (integer_zerop (rcond))\n+\t\t{\n+\t\t  if (code == EQ_EXPR)\n+\t\t    return omit_two_operands (type, boolean_false_node,\n+\t\t\t\t\t      imag0, imag1);\n+\t\t  return fold_build2 (NE_EXPR, type, imag0, imag1);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (code == NE_EXPR)\n+\t\t    return omit_two_operands (type, boolean_true_node,\n+\t\t\t\t\t      imag0, imag1);\n+\t\t  return fold_build2 (EQ_EXPR, type, imag0, imag1);\n+\t\t}\n+\t    }\n+\n+\t  icond = fold_binary (code, type, imag0, imag1);\n+\t  if (icond && TREE_CODE (icond) == INTEGER_CST)\n+\t    {\n+\t      if (integer_zerop (icond))\n+\t\t{\n+\t\t  if (code == EQ_EXPR)\n+\t\t    return omit_two_operands (type, boolean_false_node,\n+\t\t\t\t\t      real0, real1);\n+\t\t  return fold_build2 (NE_EXPR, type, real0, real1);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (code == NE_EXPR)\n+\t\t    return omit_two_operands (type, boolean_true_node,\n+\t\t\t\t\t      real0, real1);\n+\t\t  return fold_build2 (EQ_EXPR, type, real0, real1);\n+\t\t}\n+\t    }\n+\t}\n+\n       return NULL_TREE;\n \n     case LT_EXPR:\n@@ -13931,6 +13981,23 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n       return constant_boolean_node (real_compare (code, c0, c1), type);\n     }\n \n+  /* Handle equality/inequality of complex constants.  */\n+  if (TREE_CODE (op0) == COMPLEX_CST && TREE_CODE (op1) == COMPLEX_CST)\n+    {\n+      tree rcond = fold_relational_const (code, type,\n+\t\t\t\t\t  TREE_REALPART (op0),\n+\t\t\t\t\t  TREE_REALPART (op1));\n+      tree icond = fold_relational_const (code, type,\n+\t\t\t\t\t  TREE_IMAGPART (op0),\n+\t\t\t\t\t  TREE_IMAGPART (op1));\n+      if (code == EQ_EXPR)\n+\treturn fold_build2 (TRUTH_ANDIF_EXPR, type, rcond, icond);\n+      else if (code == NE_EXPR)\n+\treturn fold_build2 (TRUTH_ORIF_EXPR, type, rcond, icond);\n+      else\n+\treturn NULL_TREE;\n+    }\n+\n   /* From here on we only handle LT, LE, GT, GE, EQ and NE.\n \n      To compute GT, swap the arguments and do LT."}, {"sha": "023af848803558b935221871708976d27028b1bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b9463ba60a1b5cc3a5262ee384e41622a70b26/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b9463ba60a1b5cc3a5262ee384e41622a70b26/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=23b9463ba60a1b5cc3a5262ee384e41622a70b26", "patch": "@@ -1,3 +1,7 @@\n+2007-03-09  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/fold-eqcmplx-1.c: New test case.\n+\n 2007-03-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR rtl-optimization/30643"}, {"sha": "32f4396ba908886a48e9af3634567f08da7a37dc", "filename": "gcc/testsuite/gcc.dg/fold-eqcmplx-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b9463ba60a1b5cc3a5262ee384e41622a70b26/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqcmplx-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b9463ba60a1b5cc3a5262ee384e41622a70b26/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqcmplx-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-eqcmplx-1.c?ref=23b9463ba60a1b5cc3a5262ee384e41622a70b26", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-original\" } */\n+\n+int foo(float x, float y)\n+{\n+  return (_Complex float)x == (_Complex float)y;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"x == y\" 1 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}]}