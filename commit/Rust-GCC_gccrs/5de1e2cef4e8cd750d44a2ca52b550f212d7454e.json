{"sha": "5de1e2cef4e8cd750d44a2ca52b550f212d7454e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRlMWUyY2VmNGU4Y2Q3NTBkNDRhMmNhNTJiNTUwZjIxMmQ3NDU0ZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-03-23T00:03:04Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-03-23T00:03:04Z"}, "message": "(GO_IF_LEGITIMATE_ADDRESS): Also pretend that we have REG plus CONST_INT addresses by deleting an else.\n\n(GO_IF_LEGITIMATE_ADDRESS): Also pretend that we have REG\nplus CONST_INT addresses by deleting an else.\n(CONSTANT_ADDRESS_P): When pic, don't accept addresses which are\nsymbol_ref plus a large integer.\n(LEGITIMATE_PIC_OPERAND_P): Likewise.\n(LEGITIMIZE_ADDRESS): When pic, convert addresses which are\nsymbol_reg plus a large integer, to reg plus a large integer.\n(ASM_OUTPUT_ADDR_DIFF_ELT): Use .gpword instead of subtracting\nlabels.\n\nFrom-SVN: r6849", "tree": {"sha": "deb48b299d1dc5b5a113c9a1d4ee85ef92c739dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/deb48b299d1dc5b5a113c9a1d4ee85ef92c739dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5de1e2cef4e8cd750d44a2ca52b550f212d7454e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de1e2cef4e8cd750d44a2ca52b550f212d7454e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5de1e2cef4e8cd750d44a2ca52b550f212d7454e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de1e2cef4e8cd750d44a2ca52b550f212d7454e/comments", "author": null, "committer": null, "parents": [{"sha": "508a48d1f460d14cbe808ec9932a747fcedfce5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508a48d1f460d14cbe808ec9932a747fcedfce5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/508a48d1f460d14cbe808ec9932a747fcedfce5d"}], "stats": {"total": 46, "additions": 36, "deletions": 10}, "files": [{"sha": "d46ac656801be0ef55522d424190285456ffb693", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5de1e2cef4e8cd750d44a2ca52b550f212d7454e/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5de1e2cef4e8cd750d44a2ca52b550f212d7454e/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=5de1e2cef4e8cd750d44a2ca52b550f212d7454e", "patch": "@@ -2236,8 +2236,9 @@ typedef struct mips_args {\n \t     MIPS assembler does not have syntax to generate the\t\\\n \t     appropriate relocation.  */\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\t  else if (!TARGET_DEBUG_A_MODE\t\t\t\t\t\\\n-\t\t   && CONSTANT_ADDRESS_P (xplus1))\t\t\t\\\n+\t  /* Also accept CONST_INT addresses here, so no else.  */\t\\\n+\t  if (!TARGET_DEBUG_A_MODE\t\t\t\t\t\\\n+\t      && CONSTANT_ADDRESS_P (xplus1))\t\t\t\t\\\n \t    goto ADDR;\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -2250,11 +2251,23 @@ typedef struct mips_args {\n /* A C expression that is 1 if the RTX X is a constant which is a\n    valid address.  This is defined to be the same as `CONSTANT_P (X)',\n    but rejecting CONST_DOUBLE.  */\n+/* When pic, we must reject addresses of the form symbol+large int.\n+   This is because an instruction `sw $4,s+70000' needs to be converted\n+   by the assembler to `lw $at,s($gp);sw $4,70000($at)'.  Normally the\n+   assembler would use $at as a temp to load in the large offset.  In this\n+   case $at is already in use.  We convert such problem addresses to\n+   `la $5,s;sw $4,70000($5)' via LEGITIMIZE_ADDRESS.  */\n #define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n   ((GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH) && (!HALF_PIC_P () || !HALF_PIC_ADDRESS_P (X)))\n+    || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH\t\t\\\n+    || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n+\t&& ! (flag_pic && pic_address_needs_scratch (X))))\t\t\\\n+   && (!HALF_PIC_P () || !HALF_PIC_ADDRESS_P (X)))\n \n+/* Define this, so that when PIC, reload won't try to reload invalid\n+   addresses which require two reload registers.  */\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X)  (! pic_address_needs_scratch (X))\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n@@ -2300,7 +2313,11 @@ typedef struct mips_args {\n \tZ = X + Y\n \tmemory (Z + (<large int> & 0x7fff));\n \n-   This is for CSE to find several similar references, and only use one Z.  */\n+   This is for CSE to find several similar references, and only use one Z.\n+\n+   When PIC, convert addresses of the form memory (symbol+large int) to\n+   memory (reg+large int).  */\n+   \n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -2346,6 +2363,16 @@ typedef struct mips_args {\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  if (flag_pic && pic_address_needs_scratch (xinsn))\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx ptr_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      emit_move_insn (ptr_reg, XEXP (XEXP (xinsn, 0), 0));\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      X = gen_rtx (PLUS, Pmode, ptr_reg, XEXP (XEXP (xinsn, 0), 1));\t\\\n+      goto WIN;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n     GO_PRINTF (\"LEGITIMIZE_ADDRESS could not fix.\\n\");\t\t\t\\\n }\n@@ -3333,13 +3360,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t   VALUE)\n \n /* This is how to output an element of a case-vector that is relative.\n-   (We  do not use such vectors,\n-   but we must define this macro anyway.)  */\n+   This is used for pc-relative code (e.g. when TARGET_ABICALLS).  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, VALUE, REL)\t\t\t\\\n-  fprintf (STREAM, \"\\t%s\\t$L%d-$L%d\\n\",\t\t\t\t\t\\\n-\t   TARGET_LONG64 ? \".dword\" : \".word\",\t\t\t\t\\\n-\t   VALUE, REL)\n+  fprintf (STREAM, \"\\t%s\\t$L%d\\n\",\t\t\t\t\t\\\n+\t   TARGET_LONG64 ? \".gpdword\" : \".gpword\",\t\t\t\\\n+\t   VALUE)\n \n /* This is how to output an assembler line\n    that says to advance the location counter"}]}