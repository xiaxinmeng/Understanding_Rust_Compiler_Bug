{"sha": "0c578db6dd12d39618ad2500a80bae4ba38cf260", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM1NzhkYjZkZDEyZDM5NjE4YWQyNTAwYTgwYmFlNGJhMzhjZjI2MA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-02-15T11:07:13Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-02-15T11:07:13Z"}, "message": "builtin_insert_bits-1.c: New test.\n\ngcc/testsuite/\n\t* gcc.target/avr/torture/builtin_insert_bits-1.c: New test.\n\t* gcc.target/avr/torture/builtin_insert_bits-2.c: New test.\n\ngcc/\n\t* doc/extend.texi (AVR Built-in Functions): Remove doc for\n\t__builtin_avr_map8, __builtin_avr_map16.\n\tDocument __builtin_avr_insert_bits.\n\t* config/avr/avr.md (map_bitsqi, map_bitshi): Remove.\n\t(insert_bits): New insn.\n\t(adjust_len.map_bits): Rename to insert_bits.\n\t(UNSPEC_MAP_BITS): Rename to UNSPEC_INSERT_BITS.\n\t* avr-protos.h (avr_out_map_bits): Remove.\n\t(avr_out_insert_bits, avr_has_nibble_0xf): New.\n\t* config/avr/constraints.md (Cxf,C0f): New.\n\t* config/avr/avr.c (avr_cpu_cpp_builtins): Remove built-in\n\tdefines __BUILTIN_AVR_MAP8, __BUILTIN_AVR_MAP16.\n\tNew built-in define __BUILTIN_AVR_INSERT_BITS.\n\t* config/avr/avr.c (TARGET_FOLD_BUILTIN): New define.\n\t(enum avr_builtin_id): Add AVR_BUILTIN_INSERT_BITS.\n\t(avr_move_bits): Rewrite.\n\t(avr_fold_builtin, avr_map_metric, avr_map_decompose): New static\n\tfunctions.\n\t(avr_map_op_t): New typedef.\n\t(avr_map_op): New static variable.\n\t(avr_out_insert_bits, avr_has_nibble_0xf): New functions.\n\t(adjust_insn_length): Handle ADJUST_LEN_INSERT_BITS.\n\t(avr_init_builtins): Add definition for __builtin_avr_insert_bits.\n\t(bdesc_3arg, avr_expand_triop_builtin): New.\n\t(avr_expand_builtin): Use them. And handle AVR_BUILTIN_INSERT_BITS.\n\t(avr_revert_map, avr_swap_map, avr_id_map, avr_sig_map): Remove.\n\t(avr_map_hamming_byte, avr_map_hamming_nonstrict): Remove.\n\t(avr_map_equal_p, avr_map_sig_p): Remove.\n\t(avr_out_swap_bits, avr_out_revert_bits, avr_out_map_bits): Remove.\n\t(bdesc_2arg): Remove AVR_BUILTIN_MAP8, AVR_BUILTIN_MAP16.\n\t(adjust_insn_length): Remove handling for ADJUST_LEN_MAP_BITS.\n\t(enum avr_builtin_id): Remove AVR_BUILTIN_MAP8, AVR_BUILTIN_MAP16.\n\t(avr_init_builtins): Remove __builtin_avr_map8, __builtin_avr_map16.\n\t(avr_expand_builtin): Remove AVR_BUILTIN_MAP8, AVR_BUILTIN_MAP16.\n\nFrom-SVN: r184264", "tree": {"sha": "d0f461ea25e3c5aa9869284994ea04eb6955c835", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0f461ea25e3c5aa9869284994ea04eb6955c835"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c578db6dd12d39618ad2500a80bae4ba38cf260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c578db6dd12d39618ad2500a80bae4ba38cf260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c578db6dd12d39618ad2500a80bae4ba38cf260", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c578db6dd12d39618ad2500a80bae4ba38cf260/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c4ae4e58752c06aaa99bae702aa0ae2e2123548", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c4ae4e58752c06aaa99bae702aa0ae2e2123548", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c4ae4e58752c06aaa99bae702aa0ae2e2123548"}], "stats": {"total": 1050, "additions": 760, "deletions": 290}, "files": [{"sha": "1d88845e56e7e2f2307286ed1d574674a092587d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c578db6dd12d39618ad2500a80bae4ba38cf260", "patch": "@@ -1,3 +1,41 @@\n+2012-02-15  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* doc/extend.texi (AVR Built-in Functions): Remove doc for\n+\t__builtin_avr_map8, __builtin_avr_map16.\n+\tDocument __builtin_avr_insert_bits.\n+\n+\t* config/avr/avr.md (map_bitsqi, map_bitshi): Remove.\n+\t(insert_bits): New insn.\n+\t(adjust_len.map_bits): Rename to insert_bits.\n+\t(UNSPEC_MAP_BITS): Rename to UNSPEC_INSERT_BITS.\n+\t* avr-protos.h (avr_out_map_bits): Remove.\n+\t(avr_out_insert_bits, avr_has_nibble_0xf): New.\n+\t* config/avr/constraints.md (Cxf,C0f): New.\n+\t* config/avr/avr.c (avr_cpu_cpp_builtins): Remove built-in\n+\tdefines __BUILTIN_AVR_MAP8, __BUILTIN_AVR_MAP16.\n+\tNew built-in define __BUILTIN_AVR_INSERT_BITS.\n+\t* config/avr/avr.c (TARGET_FOLD_BUILTIN): New define.\n+\t(enum avr_builtin_id): Add AVR_BUILTIN_INSERT_BITS.\n+\t(avr_move_bits): Rewrite.\n+\t(avr_fold_builtin, avr_map_metric, avr_map_decompose): New static\n+\tfunctions.\n+\t(avr_map_op_t): New typedef.\n+\t(avr_map_op): New static variable.\n+\t(avr_out_insert_bits, avr_has_nibble_0xf): New functions.\n+\t(adjust_insn_length): Handle ADJUST_LEN_INSERT_BITS.\n+\t(avr_init_builtins): Add definition for __builtin_avr_insert_bits.\n+\t(bdesc_3arg, avr_expand_triop_builtin): New.\n+\t(avr_expand_builtin): Use them. And handle AVR_BUILTIN_INSERT_BITS.\n+\t(avr_revert_map, avr_swap_map, avr_id_map, avr_sig_map): Remove.\n+\t(avr_map_hamming_byte, avr_map_hamming_nonstrict): Remove.\n+\t(avr_map_equal_p, avr_map_sig_p): Remove.\n+\t(avr_out_swap_bits, avr_out_revert_bits, avr_out_map_bits): Remove.\n+\t(bdesc_2arg): Remove AVR_BUILTIN_MAP8, AVR_BUILTIN_MAP16.\n+\t(adjust_insn_length): Remove handling for ADJUST_LEN_MAP_BITS.\n+\t(enum avr_builtin_id): Remove AVR_BUILTIN_MAP8, AVR_BUILTIN_MAP16.\n+\t(avr_init_builtins): Remove __builtin_avr_map8, __builtin_avr_map16.\n+\t(avr_expand_builtin): Remove AVR_BUILTIN_MAP8, AVR_BUILTIN_MAP16.\n+\n 2012-02-14  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* config/c6x/c6x.md (reserve_cycles): New attribute."}, {"sha": "55aed30412ab993f82532815f0469d3320bb566f", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=0c578db6dd12d39618ad2500a80bae4ba38cf260", "patch": "@@ -163,8 +163,7 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   cpp_define (pfile, \"__BUILTIN_AVR_WDR\");\n   cpp_define (pfile, \"__BUILTIN_AVR_SLEEP\");\n   cpp_define (pfile, \"__BUILTIN_AVR_SWAP\");\n-  cpp_define (pfile, \"__BUILTIN_AVR_MAP8\");\n-  cpp_define (pfile, \"__BUILTIN_AVR_MAP16\");\n+  cpp_define (pfile, \"__BUILTIN_AVR_INSERT_BITS\");\n   cpp_define (pfile, \"__BUILTIN_AVR_DELAY_CYCLES\");\n \n   cpp_define (pfile, \"__BUILTIN_AVR_FMUL\");"}, {"sha": "fa8c421addc9648060d9b715c901f0cd16a0c3f6", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=0c578db6dd12d39618ad2500a80bae4ba38cf260", "patch": "@@ -94,8 +94,9 @@ extern const char* avr_out_plus64 (rtx, int*);\n extern const char* avr_out_addto_sp (rtx*, int*);\n extern const char* avr_out_xload (rtx, rtx*, int*);\n extern const char* avr_out_movmem (rtx, rtx*, int*);\n-extern const char* avr_out_map_bits (rtx, rtx*, int*);\n+extern const char* avr_out_insert_bits (rtx*, int*);\n extern bool avr_popcount_each_byte (rtx, int, int);\n+extern bool avr_has_nibble_0xf (rtx);\n \n extern int extra_constraint_Q (rtx x);\n extern int adjust_insn_length (rtx insn, int len);"}, {"sha": "f564db7985621b85e4a3d001980334e55e08ffc3", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 463, "deletions": 249, "changes": 712, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=0c578db6dd12d39618ad2500a80bae4ba38cf260", "patch": "@@ -305,6 +305,9 @@ bool avr_need_copy_data_p = false;\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN avr_expand_builtin\n \n+#undef  TARGET_FOLD_BUILTIN\n+#define TARGET_FOLD_BUILTIN avr_fold_builtin\n+\n #undef TARGET_ASM_FUNCTION_RODATA_SECTION\n #define TARGET_ASM_FUNCTION_RODATA_SECTION avr_asm_function_rodata_section\n \n@@ -6465,12 +6468,12 @@ adjust_insn_length (rtx insn, int len)\n \n     case ADJUST_LEN_CALL: len = AVR_HAVE_JMP_CALL ? 2 : 1; break;\n \n-    case ADJUST_LEN_MAP_BITS: avr_out_map_bits (insn, op, &len); break;\n+    case ADJUST_LEN_INSERT_BITS: avr_out_insert_bits (op, &len); break;\n \n     default:\n       gcc_unreachable();\n     }\n-  \n+\n   return len;\n }\n \n@@ -9945,193 +9948,220 @@ avr_map (double_int f, int x)\n }\n \n \n-/* Return the map R that reverses the bits of byte B.\n+/* Return some metrics of map A.  */\n \n-   R(0)  =  (0  7)  o  (1  6)  o   (2  5)  o   (3  4)\n-   R(1)  =  (8 15)  o  (9 14)  o  (10 13)  o  (11 12)\n-            \n-   Notice that R o R = id.  */\n+enum\n+  {\n+    /* Number of fixed points in { 0 ... 7 } */\n+    MAP_FIXED_0_7,\n \n-static double_int\n-avr_revert_map (int b)\n+    /* Size of preimage of non-fixed points in { 0 ... 7 } */\n+    MAP_NONFIXED_0_7,\n+    \n+    /* Mask representing the fixed points in { 0 ... 7 } */\n+    MAP_MASK_FIXED_0_7,\n+    \n+    /* Size of the preimage of { 0 ... 7 } */\n+    MAP_PREIMAGE_0_7,\n+    \n+    /* Mask that represents the preimage of { f } */\n+    MAP_MASK_PREIMAGE_F\n+  };\n+\n+static unsigned\n+avr_map_metric (double_int a, int mode)\n {\n-  int i;\n-  double_int r = double_int_zero;\n+  unsigned i, metric = 0;\n \n-  for (i = 16-1; i >= 0; i--)\n-    r = avr_double_int_push_digit (r, 16, i >> 3 == b ? i ^ 7 : i);\n+  for (i = 0; i < 8; i++)\n+    {\n+      unsigned ai = avr_map (a, i);\n \n-  return r;\n+      if (mode == MAP_FIXED_0_7)\n+        metric += ai == i;\n+      else if (mode == MAP_NONFIXED_0_7)\n+        metric += ai < 8 && ai != i;\n+      else if (mode == MAP_MASK_FIXED_0_7)\n+        metric |= ((unsigned) (ai == i)) << i;\n+      else if (mode == MAP_PREIMAGE_0_7)\n+        metric += ai < 8;\n+      else if (mode == MAP_MASK_PREIMAGE_F)\n+        metric |= ((unsigned) (ai == 0xf)) << i;\n+      else\n+        gcc_unreachable();\n+    }\n+  \n+  return metric;\n }\n \n \n-/* Return the map R that swaps bit-chunks of size SIZE in byte B.\n+/* Return true if IVAL has a 0xf in its hexadecimal representation\n+   and false, otherwise.  Only nibbles 0..7 are taken into account.\n+   Used as constraint helper for C0f and Cxf.  */\n \n-   R(1,0)  =  (0 1)  o   (2  3)  o   (4  5)  o   (6  7)\n-   R(1,1)  =  (8 9)  o  (10 11)  o  (12 13)  o  (14 15)\n+bool\n+avr_has_nibble_0xf (rtx ival)\n+{\n+  return 0 != avr_map_metric (rtx_to_double_int (ival), MAP_MASK_PREIMAGE_F);\n+}\n \n-   R(4,0)  =  (0  4)  o  (1  5)  o   (2  6)  o   (3  7)\n-   R(4,1)  =  (8 12)  o  (9 13)  o  (10 14)  o  (11 15)\n \n-   Notice that R o R = id.  */\n+/* We have a set of bits that are mapped by a function F.\n+   Try to decompose F by means of a second function G so that\n \n-static double_int\n-avr_swap_map (int size, int b)\n-{\n-  int i;\n-  double_int r = double_int_zero;\n+      F = F o G^-1 o G\n \n-  for (i = 16-1; i >= 0; i--)\n-    r = avr_double_int_push_digit (r, 16, i ^ (i >> 3 == b ? size : 0));\n+   and\n \n-  return r;\n-}\n+      cost (F o G^-1) + cost (G)  <  cost (F)\n \n+   Example:  Suppose builtin insert_bits supplies us with the map\n+   F = 0x3210ffff.  Instead of doing 4 bit insertions to get the high\n+   nibble of the result, we can just as well rotate the bits before inserting\n+   them and use the map 0x7654ffff which is cheaper than the original map.\n+   For this example G = G^-1 = 0x32107654 and F o G^-1 = 0x7654ffff.  */\n+   \n+typedef struct\n+{\n+  /* tree code of binary function G */\n+  enum tree_code code;\n \n-/* Return Identity.  */\n+  /* The constant second argument of G */\n+  int arg;\n \n-static double_int\n-avr_id_map (void)\n-{\n-  int i;\n-  double_int r = double_int_zero;\n+  /* G^-1, the inverse of G (*, arg) */\n+  unsigned ginv;\n \n-  for (i = 16-1; i >= 0; i--)\n-    r = avr_double_int_push_digit (r, 16, i);\n+  /* The cost of appplying G (*, arg) */\n+  int cost;\n \n-  return r;\n-}\n+  /* The composition F o G^-1 (*, arg) for some function F */\n+  double_int map;\n \n+  /* For debug purpose only */\n+  const char *str;\n+} avr_map_op_t;\n \n-enum\n+static const avr_map_op_t avr_map_op[] =\n   {\n-    SIG_ID        = 0,\n-    /* for QI and HI */\n-    SIG_ROL       = 0xf,\n-    SIG_REVERT_0  = 1 << 4,\n-    SIG_SWAP1_0   = 1 << 5,\n-    /* HI only */\n-    SIG_REVERT_1  = 1 << 6,\n-    SIG_SWAP1_1   = 1 << 7,\n-    SIG_SWAP4_0   = 1 << 8,\n-    SIG_SWAP4_1   = 1 << 9\n+    { LROTATE_EXPR, 0, 0x76543210, 0, { 0, 0 }, \"id\" },\n+    { LROTATE_EXPR, 1, 0x07654321, 2, { 0, 0 }, \"<<<\" },\n+    { LROTATE_EXPR, 2, 0x10765432, 4, { 0, 0 }, \"<<<\" },\n+    { LROTATE_EXPR, 3, 0x21076543, 4, { 0, 0 }, \"<<<\" },\n+    { LROTATE_EXPR, 4, 0x32107654, 1, { 0, 0 }, \"<<<\" },\n+    { LROTATE_EXPR, 5, 0x43210765, 3, { 0, 0 }, \"<<<\" },\n+    { LROTATE_EXPR, 6, 0x54321076, 5, { 0, 0 }, \"<<<\" },\n+    { LROTATE_EXPR, 7, 0x65432107, 3, { 0, 0 }, \"<<<\" },\n+    { RSHIFT_EXPR, 1, 0x6543210c, 1, { 0, 0 }, \">>\" },\n+    { RSHIFT_EXPR, 1, 0x7543210c, 1, { 0, 0 }, \">>\" },\n+    { RSHIFT_EXPR, 2, 0x543210cc, 2, { 0, 0 }, \">>\" },\n+    { RSHIFT_EXPR, 2, 0x643210cc, 2, { 0, 0 }, \">>\" },\n+    { RSHIFT_EXPR, 2, 0x743210cc, 2, { 0, 0 }, \">>\" },\n+    { LSHIFT_EXPR, 1, 0xc7654321, 1, { 0, 0 }, \"<<\" },\n+    { LSHIFT_EXPR, 2, 0xcc765432, 2, { 0, 0 }, \"<<\" }\n   };\n \n \n-/* Return basic map with signature SIG.  */\n-\n-static double_int\n-avr_sig_map (int n ATTRIBUTE_UNUSED, int sig)\n-{\n-  if (sig == SIG_ID)            return avr_id_map ();\n-  else if (sig == SIG_REVERT_0) return avr_revert_map (0);\n-  else if (sig == SIG_REVERT_1) return avr_revert_map (1);\n-  else if (sig == SIG_SWAP1_0)  return avr_swap_map (1, 0);\n-  else if (sig == SIG_SWAP1_1)  return avr_swap_map (1, 1);\n-  else if (sig == SIG_SWAP4_0)  return avr_swap_map (4, 0);\n-  else if (sig == SIG_SWAP4_1)  return avr_swap_map (4, 1);\n-  else\n-    gcc_unreachable();\n-}\n-\n-\n-/* Return the Hamming distance between the B-th byte of A and C.  */\n-\n-static bool\n-avr_map_hamming_byte (int n, int b, double_int a, double_int c, bool strict)\n+/* Try to decompose F as F = (F o G^-1) o G as described above.\n+   The result is a struct representing F o G^-1 and G.\n+   If result.cost < 0 then such a decomposition does not exist.  */\n+   \n+static avr_map_op_t\n+avr_map_decompose (double_int f, const avr_map_op_t *g, bool val_const_p)\n {\n-  int i, hamming = 0;\n-\n-  for (i = 8*b; i < n && i < 8*b + 8; i++)\n-    {\n-      int ai = avr_map (a, i);\n-      int ci = avr_map (c, i);\n+  int i;\n+  bool val_used_p = 0 != avr_map_metric (f, MAP_MASK_PREIMAGE_F);\n+  avr_map_op_t f_ginv = *g;\n+  double_int ginv = uhwi_to_double_int (g->ginv);\n \n-      hamming += ai != ci && (strict || (ai < n && ci < n));\n-    }\n+  f_ginv.cost = -1;\n   \n-  return hamming;\n-}\n-\n-\n-/* Return the non-strict Hamming distance between A and B.  */\n-\n-#define avr_map_hamming_nonstrict(N,A,B)              \\\n-  (+ avr_map_hamming_byte (N, 0, A, B, false)         \\\n-   + avr_map_hamming_byte (N, 1, A, B, false))\n+  /* Step 1:  Computing F o G^-1  */\n \n+  for (i = 7; i >= 0; i--)\n+    {\n+      int x = avr_map (f, i);\n+      \n+      if (x <= 7)\n+        {\n+          x = avr_map (ginv, x);\n \n-/* Return TRUE iff A and B represent the same mapping.  */\n-\n-#define avr_map_equal_p(N,A,B) (0 == avr_map_hamming_nonstrict (N, A, B))\n+          /* The bit is no element of the image of G: no avail (cost = -1)  */\n+          \n+          if (x > 7)\n+            return f_ginv;\n+        }\n+      \n+      f_ginv.map = avr_double_int_push_digit (f_ginv.map, 16, x);\n+    }\n \n+  /* Step 2:  Compute the cost of the operations.\n+     The overall cost of doing an operation prior to the insertion is\n+      the cost of the insertion plus the cost of the operation.  */\n \n-/* Return TRUE iff A is a map of signature S.  Notice that there is no\n-   1:1 correspondance between maps and signatures and thus this is\n-   only supported for basic signatures recognized by avr_sig_map().  */\n+  /* Step 2a:  Compute cost of F o G^-1  */\n \n-#define avr_map_sig_p(N,A,S) avr_map_equal_p (N, A, avr_sig_map (N, S))\n+  if (0 == avr_map_metric (f_ginv.map, MAP_NONFIXED_0_7))\n+    {\n+      /* The mapping consists only of fixed points and can be folded\n+         to AND/OR logic in the remainder.  Reasonable cost is 3. */\n \n+      f_ginv.cost = 2 + (val_used_p && !val_const_p);\n+    }\n+  else\n+    {\n+      rtx xop[4];\n \n-/* Swap odd/even bits of ld-reg %0:  %0 = bit-swap (%0)  */\n+      /* Get the cost of the insn by calling the output worker with some\n+         fake values.  Mimic effect of reloading xop[3]: Unused operands\n+         are mapped to 0 and used operands are reloaded to xop[0].  */\n \n-static const char*\n-avr_out_swap_bits (rtx *xop, int *plen)\n-{\n-  xop[1] = tmp_reg_rtx;\n+      xop[0] = all_regs_rtx[24];\n+      xop[1] = gen_int_mode (double_int_to_uhwi (f_ginv.map), SImode);\n+      xop[2] = all_regs_rtx[25];\n+      xop[3] = val_used_p ? xop[0] : const0_rtx;\n   \n-  return avr_asm_len (\"mov %1,%0\"    CR_TAB\n-                      \"andi %0,0xaa\" CR_TAB\n-                      \"eor %1,%0\"    CR_TAB\n-                      \"lsr %0\"       CR_TAB\n-                      \"lsl %1\"       CR_TAB\n-                      \"or %0,%1\", xop, plen, 6);\n-}\n+      avr_out_insert_bits (xop, &f_ginv.cost);\n+      \n+      f_ginv.cost += val_const_p && val_used_p ? 1 : 0;\n+    }\n+  \n+  /* Step 2b:  Add cost of G  */\n \n-/* Revert bit order:  %0 = Revert (%1) with %0 != %1 and clobber %1  */\n+  f_ginv.cost += g->cost;\n \n-static const char*\n-avr_out_revert_bits (rtx *xop, int *plen)\n-{\n-  return avr_asm_len (\"inc __zero_reg__\" \"\\n\"\n-                      \"0:\\tror %1\"       CR_TAB\n-                      \"rol %0\"           CR_TAB\n-                      \"lsl __zero_reg__\" CR_TAB\n-                      \"brne 0b\", xop, plen, 5);\n+  if (avr_log.builtin)\n+    avr_edump (\" %s%d=%d\", g->str, g->arg, f_ginv.cost);\n+\n+  return f_ginv;\n }\n \n \n-/* If OUT_P = true:  Output BST/BLD instruction according to MAP.\n-   If OUT_P = false: Just dry-run and fix XOP[1] to resolve\n-                     early-clobber conflicts if XOP[0] = XOP[1].  */\n+/* Insert bits from XOP[1] into XOP[0] according to MAP.\n+   XOP[0] and XOP[1] don't overlap.\n+   If FIXP_P = true:  Move all bits according to MAP using BLD/BST sequences.\n+   If FIXP_P = false: Just move the bit if its position in the destination\n+   is different to its source position.  */\n \n static void\n-avr_move_bits (rtx *xop, double_int map, int n_bits, bool out_p, int *plen)\n+avr_move_bits (rtx *xop, double_int map, bool fixp_p, int *plen)\n {\n-  int bit_dest, b, clobber = 0;\n+  int bit_dest, b;\n \n   /* T-flag contains this bit of the source, i.e. of XOP[1]  */\n   int t_bit_src = -1;\n \n-  if (!optimize && !out_p)\n-    {\n-      avr_asm_len (\"mov __tmp_reg__,%1\", xop, plen, 1);\n-      xop[1] = tmp_reg_rtx;\n-      return;\n-    }\n-  \n   /* We order the operations according to the requested source bit b.  */\n   \n-  for (b = 0; b < n_bits; b++)\n-    for (bit_dest = 0; bit_dest < n_bits; bit_dest++)\n+  for (b = 0; b < 8; b++)\n+    for (bit_dest = 0; bit_dest < 8; bit_dest++)\n       {\n         int bit_src = avr_map (map, bit_dest);\n         \n         if (b != bit_src\n-            /* Same position: No need to copy as the caller did MOV.  */\n-            || bit_dest == bit_src\n-            /* Accessing bits 8..f for 8-bit version is void. */\n-            || bit_src >= n_bits)\n+            || bit_src >= 8\n+            /* Same position: No need to copy as requested by FIXP_P.  */\n+            || (bit_dest == bit_src && !fixp_p))\n           continue;\n \n         if (t_bit_src != bit_src)\n@@ -10140,121 +10170,103 @@ avr_move_bits (rtx *xop, double_int map, int n_bits, bool out_p, int *plen)\n               \n             t_bit_src = bit_src;\n \n-            if (out_p)\n-              {\n-                xop[2] = GEN_INT (bit_src);\n-                avr_asm_len (\"bst %T1%T2\", xop, plen, 1);\n-              }\n-            else if (clobber & (1 << bit_src))\n-              {\n-                /* Bit to be read was written already: Backup input\n-                   to resolve early-clobber conflict.  */\n-               \n-                avr_asm_len (\"mov __tmp_reg__,%1\", xop, plen, 1);\n-                xop[1] = tmp_reg_rtx;\n-                return;\n-              }\n+            xop[3] = GEN_INT (bit_src);\n+            avr_asm_len (\"bst %T1%T3\", xop, plen, 1);\n           }\n \n         /* Load destination bit with T.  */\n         \n-        if (out_p)\n-          {\n-            xop[2] = GEN_INT (bit_dest);\n-            avr_asm_len (\"bld %T0%T2\", xop, plen, 1);\n-          }\n-        \n-        clobber |= 1 << bit_dest;\n+        xop[3] = GEN_INT (bit_dest);\n+        avr_asm_len (\"bld %T0%T3\", xop, plen, 1);\n       }\n }\n \n \n-/* Print assembler code for `map_bitsqi' and `map_bitshi'.  */\n+/* PLEN == 0: Print assembler code for `insert_bits'.\n+   PLEN != 0: Compute code length in bytes.\n+   \n+   OP[0]:  Result\n+   OP[1]:  The mapping composed of nibbles. If nibble no. N is\n+           0:   Bit N of result is copied from bit OP[2].0\n+           ...  ...\n+           7:   Bit N of result is copied from bit OP[2].7\n+           0xf: Bit N of result is copied from bit OP[3].N\n+   OP[2]:  Bits to be inserted\n+   OP[3]:  Target value  */\n \n const char*\n-avr_out_map_bits (rtx insn, rtx *operands, int *plen)\n+avr_out_insert_bits (rtx *op, int *plen)\n {\n-  bool copy_0, copy_1;\n-  int n_bits = GET_MODE_BITSIZE (GET_MODE (operands[0]));\n-  double_int map = rtx_to_double_int (operands[1]);\n-  rtx xop[3];\n+  double_int map = rtx_to_double_int (op[1]);\n+  unsigned mask_fixed;\n+  bool fixp_p = true;\n+  rtx xop[4];\n \n-  xop[0] = operands[0];\n-  xop[1] = operands[2];\n+  xop[0] = op[0];\n+  xop[1] = op[2];\n+  xop[2] = op[3];\n \n+  gcc_assert (REG_P (xop[2]) || CONST_INT_P (xop[2]));\n+          \n   if (plen)\n     *plen = 0;\n   else if (flag_print_asm_name)\n-    avr_fdump (asm_out_file, ASM_COMMENT_START \"%X\\n\", map);\n+    fprintf (asm_out_file,\n+             ASM_COMMENT_START \"map = 0x%08\" HOST_LONG_FORMAT \"x\\n\",\n+             double_int_to_uhwi (map) & GET_MODE_MASK (SImode));\n \n-  switch (n_bits)\n-    {\n-    default:\n-      gcc_unreachable();\n+  /* If MAP has fixed points it might be better to initialize the result\n+     with the bits to be inserted instead of moving all bits by hand.  */\n       \n-    case 8:\n-      if (avr_map_sig_p (n_bits, map, SIG_SWAP1_0))\n-        {\n-          return avr_out_swap_bits (xop, plen);\n-        }\n-      else if (avr_map_sig_p (n_bits, map, SIG_REVERT_0))\n-        {\n-          if (REGNO (xop[0]) == REGNO (xop[1])\n-              || !reg_unused_after (insn, xop[1]))\n-            {\n-              avr_asm_len (\"mov __tmp_reg__,%1\", xop, plen, 1);\n-              xop[1] = tmp_reg_rtx;\n-            }\n-          \n-          return avr_out_revert_bits (xop, plen);\n-        }\n-      \n-      break; /* 8 */\n+  mask_fixed = avr_map_metric (map, MAP_MASK_FIXED_0_7);\n \n-    case 16:\n+  if (REGNO (xop[0]) == REGNO (xop[1]))\n+    {\n+      /* Avoid early-clobber conflicts */\n       \n-      break; /* 16 */\n+      avr_asm_len (\"mov __tmp_reg__,%1\", xop, plen, 1);\n+      xop[1] = tmp_reg_rtx;\n+      fixp_p = false;\n     }\n \n-  /* Copy whole byte is cheaper than moving bits that stay at the same\n-     position.  Some bits in a byte stay at the same position iff the\n-     strict Hamming distance to Identity is not 8.  */\n-\n-  copy_0 = 8 != avr_map_hamming_byte (n_bits, 0, map, avr_id_map(), true);\n-  copy_1 = 8 != avr_map_hamming_byte (n_bits, 1, map, avr_id_map(), true);\n-     \n-  /* Perform the move(s) just worked out.  */\n-\n-  if (n_bits == 8)\n+  if (avr_map_metric (map, MAP_MASK_PREIMAGE_F))\n     {\n-      if (REGNO (xop[0]) == REGNO (xop[1]))\n-        {\n-          /* Fix early-clobber clashes.\n-             Notice XOP[0] hat no eary-clobber in its constraint.  */\n-          \n-          avr_move_bits (xop, map, n_bits, false, plen);\n-        }\n-      else if (copy_0)\n+      /* XOP[2] is used and reloaded to XOP[0] already */\n+      \n+      int n_fix = 0, n_nofix = 0;\n+      \n+      gcc_assert (REG_P (xop[2]));\n+      \n+      /* Get the code size of the bit insertions; once with all bits\n+         moved and once with fixed points omitted.  */\n+  \n+      avr_move_bits (xop, map, true, &n_fix);\n+      avr_move_bits (xop, map, false, &n_nofix);\n+\n+      if (fixp_p && n_fix - n_nofix > 3)\n         {\n-          avr_asm_len (\"mov %0,%1\", xop, plen, 1);\n+          xop[3] = gen_int_mode (~mask_fixed, QImode);\n+        \n+          avr_asm_len (\"eor %0,%1\"   CR_TAB\n+                       \"andi %0,%3\"  CR_TAB\n+                       \"eor %0,%1\", xop, plen, 3);\n+          fixp_p = false;\n         }\n     }\n-  else if (AVR_HAVE_MOVW && copy_0 && copy_1)\n-    {\n-      avr_asm_len (\"movw %A0,%A1\", xop, plen, 1);\n-    }\n   else\n     {\n-      if (copy_0)\n-        avr_asm_len (\"mov %A0,%A1\", xop, plen, 1);\n-\n-      if (copy_1)\n-        avr_asm_len (\"mov %B0,%B1\", xop, plen, 1);\n+      /* XOP[2] is unused */\n+      \n+      if (fixp_p && mask_fixed)\n+        {\n+          avr_asm_len (\"mov %0,%1\", xop, plen, 1);\n+          fixp_p = false;\n+        }\n     }\n+  \n+  /* Move/insert remaining bits.  */\n \n-  /* Move individual bits.  */\n-\n-  avr_move_bits (xop, map, n_bits, true, plen);\n+  avr_move_bits (xop, map, fixp_p, plen);\n   \n   return \"\";\n }\n@@ -10270,8 +10282,7 @@ enum avr_builtin_id\n     AVR_BUILTIN_WDR,\n     AVR_BUILTIN_SLEEP,\n     AVR_BUILTIN_SWAP,\n-    AVR_BUILTIN_MAP8,\n-    AVR_BUILTIN_MAP16,\n+    AVR_BUILTIN_INSERT_BITS,\n     AVR_BUILTIN_FMUL,\n     AVR_BUILTIN_FMULS,\n     AVR_BUILTIN_FMULSU,\n@@ -10328,16 +10339,11 @@ avr_init_builtins (void)\n                                 long_unsigned_type_node,\n                                 NULL_TREE);\n \n-  tree uchar_ftype_ulong_uchar\n+  tree uchar_ftype_ulong_uchar_uchar\n     = build_function_type_list (unsigned_char_type_node,\n                                 long_unsigned_type_node,\n                                 unsigned_char_type_node,\n-                                NULL_TREE);\n-\n-  tree uint_ftype_ullong_uint\n-    = build_function_type_list (unsigned_type_node,\n-                                long_long_unsigned_type_node,\n-                                unsigned_type_node,\n+                                unsigned_char_type_node,\n                                 NULL_TREE);\n \n   DEF_BUILTIN (\"__builtin_avr_nop\", void_ftype_void, AVR_BUILTIN_NOP);\n@@ -10356,10 +10362,8 @@ avr_init_builtins (void)\n   DEF_BUILTIN (\"__builtin_avr_fmulsu\", int_ftype_char_uchar, \n                AVR_BUILTIN_FMULSU);\n \n-  DEF_BUILTIN (\"__builtin_avr_map8\", uchar_ftype_ulong_uchar, \n-               AVR_BUILTIN_MAP8);\n-  DEF_BUILTIN (\"__builtin_avr_map16\", uint_ftype_ullong_uint, \n-               AVR_BUILTIN_MAP16);\n+  DEF_BUILTIN (\"__builtin_avr_insert_bits\", uchar_ftype_ulong_uchar_uchar,\n+               AVR_BUILTIN_INSERT_BITS);\n \n   avr_init_builtin_int24 ();\n }\n@@ -10384,9 +10388,14 @@ bdesc_2arg[] =\n   {\n     { CODE_FOR_fmul, \"__builtin_avr_fmul\", AVR_BUILTIN_FMUL },\n     { CODE_FOR_fmuls, \"__builtin_avr_fmuls\", AVR_BUILTIN_FMULS },\n-    { CODE_FOR_fmulsu, \"__builtin_avr_fmulsu\", AVR_BUILTIN_FMULSU },\n-    { CODE_FOR_map_bitsqi, \"__builtin_avr_map8\", AVR_BUILTIN_MAP8 },\n-    { CODE_FOR_map_bitshi, \"__builtin_avr_map16\", AVR_BUILTIN_MAP16 }\n+    { CODE_FOR_fmulsu, \"__builtin_avr_fmulsu\", AVR_BUILTIN_FMULSU }\n+  };\n+\n+static const struct avr_builtin_description\n+bdesc_3arg[] =\n+  {\n+    { CODE_FOR_insert_bits, \"__builtin_avr_insert_bits\",\n+      AVR_BUILTIN_INSERT_BITS }\n   };\n \n /* Subroutine of avr_expand_builtin to take care of unop insns.  */\n@@ -10486,6 +10495,76 @@ avr_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n   return target;\n }\n \n+/* Subroutine of avr_expand_builtin to take care of 3-operand insns.  */\n+\n+static rtx\n+avr_expand_triop_builtin (enum insn_code icode, tree exp, rtx target)\n+{\n+  rtx pat;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+  tree arg2 = CALL_EXPR_ARG (exp, 2);\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+  rtx op2 = expand_expr (arg2, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+  enum machine_mode op0mode = GET_MODE (op0);\n+  enum machine_mode op1mode = GET_MODE (op1);\n+  enum machine_mode op2mode = GET_MODE (op2);\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+  enum machine_mode mode2 = insn_data[icode].operand[3].mode;\n+\n+  if (! target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    {\n+      target = gen_reg_rtx (tmode);\n+    }\n+\n+  if ((op0mode == SImode || op0mode == VOIDmode) && mode0 == HImode)\n+    {\n+      op0mode = HImode;\n+      op0 = gen_lowpart (HImode, op0);\n+    }\n+  \n+  if ((op1mode == SImode || op1mode == VOIDmode) && mode1 == HImode)\n+    {\n+      op1mode = HImode;\n+      op1 = gen_lowpart (HImode, op1);\n+    }\n+  \n+  if ((op2mode == SImode || op2mode == VOIDmode) && mode2 == HImode)\n+    {\n+      op2mode = HImode;\n+      op2 = gen_lowpart (HImode, op2);\n+    }\n+  \n+  /* In case the insn wants input operands in modes different from\n+     the result, abort.  */\n+  \n+  gcc_assert ((op0mode == mode0 || op0mode == VOIDmode)\n+              && (op1mode == mode1 || op1mode == VOIDmode)\n+              && (op2mode == mode2 || op2mode == VOIDmode));\n+\n+  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+  \n+  if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+    op1 = copy_to_mode_reg (mode1, op1);\n+\n+  if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))\n+    op2 = copy_to_mode_reg (mode2, op2);\n+\n+  pat = GEN_FCN (icode) (target, op0, op1, op2);\n+  \n+  if (! pat)\n+    return 0;\n+\n+  emit_insn (pat);\n+  return target;\n+}\n+\n \n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n@@ -10541,7 +10620,7 @@ avr_expand_builtin (tree exp, rtx target,\n         return 0;\n       }\n \n-    case AVR_BUILTIN_MAP8:\n+    case AVR_BUILTIN_INSERT_BITS:\n       {\n         arg0 = CALL_EXPR_ARG (exp, 0);\n         op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n@@ -10553,19 +10632,6 @@ avr_expand_builtin (tree exp, rtx target,\n             return target;\n           }\n       }\n-\n-    case AVR_BUILTIN_MAP16:\n-      {\n-        arg0 = CALL_EXPR_ARG (exp, 0);\n-        op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-\n-        if (!const_double_operand (op0, VOIDmode))\n-          {\n-            error (\"%s expects a compile time long long integer constant\"\n-                   \" as first argument\", bname);\n-            return target;\n-          }\n-      }\n     }\n \n   for (i = 0, d = bdesc_1arg; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n@@ -10576,9 +10642,157 @@ avr_expand_builtin (tree exp, rtx target,\n     if (d->id == id)\n       return avr_expand_binop_builtin (d->icode, exp, target);\n \n+  for (i = 0, d = bdesc_3arg; i < ARRAY_SIZE (bdesc_3arg); i++, d++)\n+    if (d->id == id)\n+      return avr_expand_triop_builtin (d->icode, exp, target);\n+\n   gcc_unreachable ();\n }\n \n+\n+/* Implement `TARGET_FOLD_BUILTIN'.  */\n+\n+static tree\n+avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n+                  bool ignore ATTRIBUTE_UNUSED)\n+{\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree val_type = TREE_TYPE (TREE_TYPE (fndecl));\n+\n+  if (!optimize)\n+    return NULL_TREE;\n+  \n+  switch (fcode)\n+    {\n+    default:\n+      break;\n+\n+    case AVR_BUILTIN_INSERT_BITS:\n+      {\n+        tree tbits = arg[1];\n+        tree tval = arg[2];\n+        tree tmap;\n+        tree map_type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n+        double_int map = tree_to_double_int (arg[0]);\n+        bool changed = false;\n+        unsigned i;\n+        avr_map_op_t best_g;\n+        \n+        tmap = double_int_to_tree (map_type, map);\n+\n+        if (TREE_CODE (tval) != INTEGER_CST\n+            && 0 == avr_map_metric (map, MAP_MASK_PREIMAGE_F))\n+          {\n+            /* There are no F in the map, i.e. 3rd operand is unused.\n+               Replace that argument with some constant to render\n+               respective input unused.  */\n+            \n+            tval = build_int_cst (val_type, 0);\n+            changed = true;\n+          }\n+\n+        if (TREE_CODE (tbits) != INTEGER_CST\n+            && 0 == avr_map_metric (map, MAP_PREIMAGE_0_7))\n+          {\n+            /* Similar for the bits to be inserted. If they are unused,\n+               we can just as well pass 0.  */\n+            \n+            tbits = build_int_cst (val_type, 0);\n+          }\n+\n+        if (TREE_CODE (tbits) == INTEGER_CST)\n+          {\n+            /* Inserting bits known at compile time is easy and can be\n+               performed by AND and OR with appropriate masks.  */\n+\n+            int bits = TREE_INT_CST_LOW (tbits);\n+            int mask_ior = 0, mask_and = 0xff;\n+\n+            for (i = 0; i < 8; i++)\n+              {\n+                int mi = avr_map (map, i);\n+\n+                if (mi < 8)\n+                  {\n+                    if (bits & (1 << mi))     mask_ior |=  (1 << i);\n+                    else                      mask_and &= ~(1 << i);\n+                  }\n+              }\n+\n+            tval = fold_build2 (BIT_IOR_EXPR, val_type, tval,\n+                                build_int_cst (val_type, mask_ior));\n+            return fold_build2 (BIT_AND_EXPR, val_type, tval,\n+                                build_int_cst (val_type, mask_and));\n+          }\n+\n+        if (changed)\n+          return build_call_expr (fndecl, 3, tmap, tbits, tval);\n+\n+        /* If bits don't change their position we can use vanilla logic\n+           to merge the two arguments.  */\n+\n+        if (0 == avr_map_metric (map, MAP_NONFIXED_0_7))\n+          {\n+            int mask_f = avr_map_metric (map, MAP_MASK_PREIMAGE_F);\n+            tree tres, tmask = build_int_cst (val_type, mask_f ^ 0xff);\n+\n+            tres = fold_build2 (BIT_XOR_EXPR, val_type, tbits, tval);\n+            tres = fold_build2 (BIT_AND_EXPR, val_type, tres, tmask);\n+            return fold_build2 (BIT_XOR_EXPR, val_type, tres, tval);\n+          }\n+\n+        /* Try to decomposing map to reduce overall cost.  */\n+\n+        if (avr_log.builtin)\n+          avr_edump (\"\\n%?: %X\\n%?: ROL cost: \", map);\n+        \n+        best_g = avr_map_op[0];\n+        best_g.cost = 1000;\n+        \n+        for (i = 0; i < sizeof (avr_map_op) / sizeof (*avr_map_op); i++)\n+          {\n+            avr_map_op_t g\n+              = avr_map_decompose (map, avr_map_op + i,\n+                                   TREE_CODE (tval) == INTEGER_CST);\n+\n+            if (g.cost >= 0 && g.cost < best_g.cost)\n+              best_g = g;\n+          }\n+\n+        if (avr_log.builtin)\n+          avr_edump (\"\\n\");\n+                     \n+        if (best_g.arg == 0)\n+          /* No optimization found */\n+          break;\n+        \n+        /* Apply operation G to the 2nd argument.  */\n+              \n+        if (avr_log.builtin)\n+          avr_edump (\"%?: using OP(%s%d, %X) cost %d\\n\",\n+                     best_g.str, best_g.arg, best_g.map, best_g.cost);\n+\n+        /* Do right-shifts arithmetically: They copy the MSB instead of\n+           shifting in a non-usable value (0) as with logic right-shift.  */\n+        \n+        tbits = fold_convert (signed_char_type_node, tbits);\n+        tbits = fold_build2 (best_g.code, signed_char_type_node, tbits,\n+                             build_int_cst (val_type, best_g.arg));\n+        tbits = fold_convert (val_type, tbits);\n+\n+        /* Use map o G^-1 instead of original map to undo the effect of G.  */\n+        \n+        tmap = double_int_to_tree (map_type, best_g.map);\n+        \n+        return build_call_expr (fndecl, 3, tmap, tbits, tval);\n+      } /* AVR_BUILTIN_INSERT_BITS */\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+\f\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-avr.h\""}, {"sha": "da2b8bc2d361772916aec6486894f9f1f8eccfae", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=0c578db6dd12d39618ad2500a80bae4ba38cf260", "patch": "@@ -68,7 +68,7 @@\n    UNSPEC_FMULSU\n    UNSPEC_COPYSIGN\n    UNSPEC_IDENTITY\n-   UNSPEC_MAP_BITS\n+   UNSPEC_INSERT_BITS\n    ])\n \n (define_c_enum \"unspecv\"\n@@ -144,7 +144,7 @@\n    ashlhi, ashrhi, lshrhi,\n    ashlsi, ashrsi, lshrsi,\n    ashlpsi, ashrpsi, lshrpsi,\n-   map_bits,\n+   insert_bits,\n    no\"\n   (const_string \"no\"))\n \n@@ -5264,28 +5264,20 @@\n   [(set_attr \"length\" \"9\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"map_bitsqi\"\n-  [(set (match_operand:QI 0 \"register_operand\"             \"=d\")\n-        (unspec:QI [(match_operand:SI 1 \"const_int_operand\" \"n\")\n-                    (match_operand:QI 2 \"register_operand\"  \"r\")]\n-                   UNSPEC_MAP_BITS))]\n-  \"\"\n-  {\n-    return avr_out_map_bits (insn, operands, NULL);\n-  }\n-  [(set_attr \"adjust_len\" \"map_bits\")\n-   (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"map_bitshi\"\n-  [(set (match_operand:HI 0 \"register_operand\"               \"=&r\")\n-        (unspec:HI [(match_operand:DI 1 \"const_double_operand\" \"n\")\n-                    (match_operand:HI 2 \"register_operand\"     \"r\")]\n-                   UNSPEC_MAP_BITS))]\n+;; __builtin_avr_insert_bits\n+\n+(define_insn \"insert_bits\"\n+  [(set (match_operand:QI 0 \"register_operand\"              \"=r  ,d  ,r\")\n+        (unspec:QI [(match_operand:SI 1 \"const_int_operand\"  \"C0f,Cxf,C0f\")\n+                    (match_operand:QI 2 \"register_operand\"   \"r  ,r  ,r\")\n+                    (match_operand:QI 3 \"nonmemory_operand\"  \"n  ,0  ,0\")]\n+                   UNSPEC_INSERT_BITS))]\n   \"\"\n   {\n-    return avr_out_map_bits (insn, operands, NULL);\n+    return avr_out_insert_bits (operands, NULL);\n   }\n-  [(set_attr \"adjust_len\" \"map_bits\")\n+  [(set_attr \"adjust_len\" \"insert_bits\")\n    (set_attr \"cc\" \"clobber\")])\n \n "}, {"sha": "57e259db6d1aa25d6cb6a35e16dfa8337ec4e57a", "filename": "gcc/config/avr/constraints.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fconfig%2Favr%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fconfig%2Favr%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fconstraints.md?ref=0c578db6dd12d39618ad2500a80bae4ba38cf260", "patch": "@@ -182,3 +182,13 @@\n   \"Integer constant in the range -6 @dots{} 6.\"\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (ival, -6, 6)\")))\n+\n+(define_constraint \"Cxf\"\n+  \"32-bit integer constant where at least one nibble is 0xf.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"avr_has_nibble_0xf (op)\")))\n+\n+(define_constraint \"C0f\"\n+  \"32-bit integer constant where no nibble equals 0xf.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"!avr_has_nibble_0xf (op)\")))"}, {"sha": "b666a2ef1c4deaca1db9fc9fbb0993495c639f68", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0c578db6dd12d39618ad2500a80bae4ba38cf260", "patch": "@@ -8812,33 +8812,53 @@ might increase delay time. @code{ticks} must be a compile time\n integer constant; delays with a variable number of cycles are not supported.\n \n @smallexample\n-     unsigned char __builtin_avr_map8 (unsigned long map, unsigned char val)\n+     unsigned char __builtin_avr_insert_bits (unsigned long map, unsigned char bits, unsigned char val)\n @end smallexample\n \n @noindent\n-Each bit of the result is copied from a specific bit of @code{val}.\n-@code{map} is a compile time constant that represents a map composed\n-of 8 nibbles (4-bit groups):\n-The @var{n}-th nibble of @code{map} specifies which bit of @code{val}\n-is to be moved to the @var{n}-th bit of the result.\n-For example, @code{map = 0x76543210} represents identity: The MSB of\n-the result is read from the 7-th bit of @code{val}, the LSB is\n-read from the 0-th bit to @code{val}, etc.\n-Two more examples: @code{0x01234567} reverses the bit order and\n-@code{0x32107654} is equivalent to a @code{swap} instruction.\n+Insert bits from @var{bits} into @var{val} and return the resulting\n+value. The nibbles of @var{map} determine how the insertion is\n+performed: Let @var{X} be the @var{n}-th nibble of @var{map}\n+@enumerate\n+@item If @var{X} is @code{0xf},\n+then the @var{n}-th bit of @var{val} is returned unaltered.\n+\n+@item If X is in the range 0@dots{}7,\n+then the @var{n}-th result bit is set to the @var{X}-th bit of @var{bits}\n+\n+@item If X is in the range 8@dots{}@code{0xe},\n+then the @var{n}-th result bit is undefined.\n+@end enumerate\n \n @noindent\n-One typical use case for this and the following built-in is adjusting input and\n-output values to non-contiguous port layouts.\n+One typical use case for this built-in is adjusting input and\n+output values to non-contiguous port layouts. Some examples:\n \n @smallexample\n-     unsigned int __builtin_avr_map16 (unsigned long long map, unsigned int val)\n+// same as val, bits is unused\n+__builtin_avr_insert_bits (0xffffffff, bits, val)\n @end smallexample\n \n-@noindent\n-Similar to the previous built-in except that it operates on @code{int}\n-and thus 16 bits are involved.  Again, @code{map} must be a compile\n-time constant.\n+@smallexample\n+// same as bits, val is unused\n+__builtin_avr_insert_bits (0x76543210, bits, val)\n+@end smallexample\n+\n+@smallexample\n+// same as rotating bits by 4\n+__builtin_avr_insert_bits (0x32107654, bits, 0)\n+@end smallexample\n+\n+@smallexample\n+// high-nibble of result is the high-nibble of val\n+// low-nibble of result is the low-nibble of bits\n+__builtin_avr_insert_bits (0xffff3210, bits, val)\n+@end smallexample\n+\n+@smallexample\n+// reverse the bit order of bits\n+__builtin_avr_insert_bits (0x01234567, bits, 0)\n+@end smallexample\n \n @node Blackfin Built-in Functions\n @subsection Blackfin Built-in Functions"}, {"sha": "b0e7c456f883bd9c2522fb4e1c42eb60f38e94ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0c578db6dd12d39618ad2500a80bae4ba38cf260", "patch": "@@ -1,3 +1,8 @@\n+2012-02-15  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* gcc.target/avr/torture/builtin_insert_bits-1.c: New test.\n+\t* gcc.target/avr/torture/builtin_insert_bits-2.c: New test.\n+\n 2012-02-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/discr35.ad[sb]: New test."}, {"sha": "fe20c916315d5071a15addff7ad549ba2ad9a645", "filename": "gcc/testsuite/gcc.target/avr/torture/builtin_insert_bits-1.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltin_insert_bits-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltin_insert_bits-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltin_insert_bits-1.c?ref=0c578db6dd12d39618ad2500a80bae4ba38cf260", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define MASK_F(M)                                       \\\n+  (0                                                    \\\n+   | ((0xf == (0xf & ((M) >> (4*0)))) ? (1 << 0) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*1)))) ? (1 << 1) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*2)))) ? (1 << 2) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*3)))) ? (1 << 3) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*4)))) ? (1 << 4) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*5)))) ? (1 << 5) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*6)))) ? (1 << 6) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*7)))) ? (1 << 7) : 0)   \\\n+   | 0)\n+\n+#define MASK_0_7(M)                                     \\\n+  (0                                                    \\\n+   | ((8 > (0xf & ((M) >> (4*0)))) ? (1 << 0) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*1)))) ? (1 << 1) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*2)))) ? (1 << 2) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*3)))) ? (1 << 3) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*4)))) ? (1 << 4) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*5)))) ? (1 << 5) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*6)))) ? (1 << 6) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*7)))) ? (1 << 7) : 0)      \\\n+   | 0)\n+\n+#define INSERT_BITS(M,B,V)                                              \\\n+  (__extension__({                                                      \\\n+      unsigned char _n, _r = 0;                                         \\\n+      _n = 0xf & (M >> (4*0)); if (_n<8) _r |= (!!(B & (1 << _n))) << 0; \\\n+      _n = 0xf & (M >> (4*1)); if (_n<8) _r |= (!!(B & (1 << _n))) << 1; \\\n+      _n = 0xf & (M >> (4*2)); if (_n<8) _r |= (!!(B & (1 << _n))) << 2; \\\n+      _n = 0xf & (M >> (4*3)); if (_n<8) _r |= (!!(B & (1 << _n))) << 3; \\\n+      _n = 0xf & (M >> (4*4)); if (_n<8) _r |= (!!(B & (1 << _n))) << 4; \\\n+      _n = 0xf & (M >> (4*5)); if (_n<8) _r |= (!!(B & (1 << _n))) << 5; \\\n+      _n = 0xf & (M >> (4*6)); if (_n<8) _r |= (!!(B & (1 << _n))) << 6; \\\n+      _n = 0xf & (M >> (4*7)); if (_n<8) _r |= (!!(B & (1 << _n))) << 7; \\\n+      (unsigned char) ((V) & MASK_F(M)) | _r;                           \\\n+    }))\n+\n+#define MASK_USED(M) (MASK_F(M) | MASK_0_7(M))\n+\n+#define TEST2(M,B,V)                                    \\\n+  do {                                                  \\\n+    __asm volatile (\";\" #M);                            \\\n+    r1 = MASK_USED (M)                                  \\\n+      & __builtin_avr_insert_bits (M,B,V);              \\\n+    r2 = INSERT_BITS (M,B,V);                           \\\n+    if (r1 != r2)                                       \\\n+      abort ();                                         \\\n+  } while(0)\n+\n+#define TEST1(M,X)                                      \\\n+  do {                                                  \\\n+    TEST2 (M,X,0x00); TEST2 (M,0x00,X);                 \\\n+    TEST2 (M,X,0xff); TEST2 (M,0xff,X);                 \\\n+    TEST2 (M,X,0xaa); TEST2 (M,0xaa,X);                 \\\n+    TEST2 (M,X,0xcc); TEST2 (M,0xcc,X);                 \\\n+    TEST2 (M,X,0x96); TEST2 (M,0x96,X);                 \\\n+  } while(0)\n+\n+\n+\n+void test8 (void)\n+{\n+  unsigned char r1, r2;\n+  unsigned char ib;\n+\n+  static const unsigned char V[] =\n+    {\n+      0, 0xaa, 0xcc, 0xf0, 0xff, 0x5b, 0x4d\n+    };\n+\n+  for (ib = 0; ib < sizeof (V) / sizeof (*V); ib++)\n+    {\n+      unsigned char b = V[ib];\n+      \n+      TEST1 (0x76543210, b);\n+      TEST1 (0x3210ffff, b);\n+      TEST1 (0x67452301, b);\n+      TEST1 (0xf0f1f2f3, b);\n+      TEST1 (0xff10ff54, b);\n+      TEST1 (0x01234567, b);\n+      TEST1 (0xff765f32, b);\n+    }\n+}\n+\n+/****************************************************************/\n+\n+int main()\n+{\n+  test8();\n+  \n+  exit(0);\n+}"}, {"sha": "06cafd6afa8b0d7d7d0dbf542cd3344e0c306560", "filename": "gcc/testsuite/gcc.target/avr/torture/builtin_insert_bits-2.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltin_insert_bits-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c578db6dd12d39618ad2500a80bae4ba38cf260/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltin_insert_bits-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltin_insert_bits-2.c?ref=0c578db6dd12d39618ad2500a80bae4ba38cf260", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define MASK_F(M)                                       \\\n+  (0                                                    \\\n+   | ((0xf == (0xf & ((M) >> (4*0)))) ? (1 << 0) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*1)))) ? (1 << 1) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*2)))) ? (1 << 2) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*3)))) ? (1 << 3) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*4)))) ? (1 << 4) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*5)))) ? (1 << 5) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*6)))) ? (1 << 6) : 0)   \\\n+   | ((0xf == (0xf & ((M) >> (4*7)))) ? (1 << 7) : 0)   \\\n+   | 0)\n+\n+#define MASK_0_7(M)                                     \\\n+  (0                                                    \\\n+   | ((8 > (0xf & ((M) >> (4*0)))) ? (1 << 0) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*1)))) ? (1 << 1) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*2)))) ? (1 << 2) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*3)))) ? (1 << 3) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*4)))) ? (1 << 4) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*5)))) ? (1 << 5) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*6)))) ? (1 << 6) : 0)      \\\n+   | ((8 > (0xf & ((M) >> (4*7)))) ? (1 << 7) : 0)      \\\n+   | 0)\n+\n+#define INSERT_BITS(M,B,V)                                              \\\n+  (__extension__({                                                      \\\n+      unsigned char _n, _r = 0;                                         \\\n+      _n = 0xf & (M >> (4*0)); if (_n<8) _r |= (!!(B & (1 << _n))) << 0; \\\n+      _n = 0xf & (M >> (4*1)); if (_n<8) _r |= (!!(B & (1 << _n))) << 1; \\\n+      _n = 0xf & (M >> (4*2)); if (_n<8) _r |= (!!(B & (1 << _n))) << 2; \\\n+      _n = 0xf & (M >> (4*3)); if (_n<8) _r |= (!!(B & (1 << _n))) << 3; \\\n+      _n = 0xf & (M >> (4*4)); if (_n<8) _r |= (!!(B & (1 << _n))) << 4; \\\n+      _n = 0xf & (M >> (4*5)); if (_n<8) _r |= (!!(B & (1 << _n))) << 5; \\\n+      _n = 0xf & (M >> (4*6)); if (_n<8) _r |= (!!(B & (1 << _n))) << 6; \\\n+      _n = 0xf & (M >> (4*7)); if (_n<8) _r |= (!!(B & (1 << _n))) << 7; \\\n+      (unsigned char) ((V) & MASK_F(M)) | _r;                           \\\n+    }))\n+\n+#define MASK_USED(M) (MASK_F(M) | MASK_0_7(M))\n+\n+#define TEST2(M,B,V)                                    \\\n+  do {                                                  \\\n+    __asm volatile (\";\" #M);                            \\\n+    r1 = MASK_USED (M)                                  \\\n+      & __builtin_avr_insert_bits (M,B,V);              \\\n+    r2 = INSERT_BITS (M,B,V);                           \\\n+    if (r1 != r2)                                       \\\n+      abort ();                                         \\\n+  } while(0)\n+\n+void test8 (void)\n+{\n+  unsigned char r1, r2;\n+  unsigned char ib, iv;\n+\n+  static const unsigned char V[] =\n+    {\n+      0, 0xaa, 0xcc, 0xf0, 0xff, 0x5b, 0x4d\n+    };\n+\n+  for (ib = 0; ib < sizeof (V) / sizeof (*V); ib++)\n+    {\n+      unsigned char b = V[ib];\n+      \n+      for (iv = 0; iv < sizeof (V) / sizeof (*V); iv++)\n+        {\n+          unsigned char v = V[iv];\n+          \n+          TEST2 (0x76543210, b, v);\n+          TEST2 (0xffffffff, b, v);\n+          TEST2 (0x3210ffff, b, v);\n+          TEST2 (0x67452301, b, v);\n+          TEST2 (0xf0f1f2f3, b, v);\n+          TEST2 (0xff10ff54, b, v);\n+          TEST2 (0x0765f321, b, v);\n+          TEST2 (0x11223344, b, v);\n+          TEST2 (0x01234567, b, v);\n+          TEST2 (0xff7765f3, b, v);\n+        }\n+    }\n+}\n+\n+/****************************************************************/\n+\n+int main()\n+{\n+  test8();\n+  \n+  exit(0);\n+}"}]}