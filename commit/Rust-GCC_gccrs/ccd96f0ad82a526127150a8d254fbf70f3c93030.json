{"sha": "ccd96f0ad82a526127150a8d254fbf70f3c93030", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NkOTZmMGFkODJhNTI2MTI3MTUwYThkMjU0ZmJmNzBmM2M5MzAzMA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-01-13T16:59:42Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-01-13T16:59:42Z"}, "message": "* extend.texi: Update for CPP.\n\nFrom-SVN: r38986", "tree": {"sha": "e4584e7a6137c94efdf4f9d85277b637206b0f34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4584e7a6137c94efdf4f9d85277b637206b0f34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccd96f0ad82a526127150a8d254fbf70f3c93030", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd96f0ad82a526127150a8d254fbf70f3c93030", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccd96f0ad82a526127150a8d254fbf70f3c93030", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd96f0ad82a526127150a8d254fbf70f3c93030/comments", "author": null, "committer": null, "parents": [{"sha": "174fa2c48b770cd4ffa273407bc0aed1f8f16034", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174fa2c48b770cd4ffa273407bc0aed1f8f16034", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174fa2c48b770cd4ffa273407bc0aed1f8f16034"}], "stats": {"total": 122, "additions": 81, "deletions": 41}, "files": [{"sha": "6f3787dcef6dcbfd3ced577eb58285e72a0361cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd96f0ad82a526127150a8d254fbf70f3c93030/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd96f0ad82a526127150a8d254fbf70f3c93030/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccd96f0ad82a526127150a8d254fbf70f3c93030", "patch": "@@ -1,3 +1,7 @@\n+2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* extend.texi: Udate for CPP.\n+\n 2001-01-13  Andreas Jaeger  <aj@suse.de>\n \n \t* reload1.c: Add prototype for replace_pseudos_in_call_usage."}, {"sha": "51a8ff040e5b4b646e298457e83df3a644931e02", "filename": "gcc/extend.texi", "status": "modified", "additions": 77, "deletions": 41, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd96f0ad82a526127150a8d254fbf70f3c93030/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd96f0ad82a526127150a8d254fbf70f3c93030/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=ccd96f0ad82a526127150a8d254fbf70f3c93030", "patch": "@@ -43,7 +43,9 @@ C++ Language}, for extensions that apply @emph{only} to C++.\n * Hex Floats::          Hexadecimal floating-point constants.\n * Zero Length::         Zero-length arrays.\n * Variable Length::     Arrays whose length is computed at run time.\n-* Macro Varargs::\tMacros with variable number of arguments.\n+* Variadic Macros::\tMacros with a variable number of arguments.\n+* Escaped Newlines::    Slightly looser rules for escaped newlines.\n+* Multi-line Strings::  String literals with embedded newlines.\n * Subscripting::        Any array can be subscripted, even if not an lvalue.\n * Pointer Arith::       Arithmetic on @code{void}-pointers and function pointers.\n * Initializers::        Non-constant initializers.\n@@ -90,7 +92,9 @@ C++ Language}, for extensions that apply @emph{only} to C++.\n * Hex Floats::          Hexadecimal floating-point constants.\n * Zero Length::         Zero-length arrays.\n * Variable Length::     Arrays whose length is computed at run time.\n-* Macro Varargs::\tMacros with variable number of arguments.\n+* Variadic Macros::\tMacros with a variable number of arguments.\n+* Escaped Newlines::    Slightly looser rules for escaped newlines.\n+* Multi-line Strings::  String literals with embedded newlines.\n * Subscripting::        Any array can be subscripted, even if not an lvalue.\n * Pointer Arith::       Arithmetic on @code{void}-pointers and function pointers.\n * Initializers::        Non-constant initializers.\n@@ -1036,66 +1040,98 @@ last one must end with a semicolon, which is followed by the ``real''\n parameter declarations.  Each forward declaration must match a ``real''\n declaration in parameter name and data type.\n \n-@node Macro Varargs\n-@section Macros with Variable Numbers of Arguments\n+@node Variadic Macros\n+@section Macros with a Variable Number of Arguments.\n @cindex variable number of arguments\n @cindex macro with variable arguments\n @cindex rest argument (in macro)\n+@cindex variadic macros\n \n-In GNU C, a macro can accept a variable number of arguments, much as a\n-function can.  The syntax for defining the macro looks much like that\n-used for a function.  Here is an example:\n+In the ISO C standard of 1999, a macro can be declared to accept a\n+variable number of arguments much as a function can.  The syntax for\n+defining the macro is similar to that of a function.  Here is an\n+example:\n \n @example\n-#define eprintf(format, args...)  \\\n- fprintf (stderr, format , ## args)\n+#define debug(format, ...) fprintf (stderr, format, __VA_ARGS__)\n @end example\n \n-Here @code{args} is a @dfn{rest argument}: it takes in zero or more\n-arguments, as many as the call contains.  All of them plus the commas\n-between them form the value of @code{args}, which is substituted into\n-the macro body where @code{args} is used.  Thus, we have this expansion:\n+Here @samp{@dots{}} is a @dfn{variable argument}.  In the invocation of\n+such a macro, it represents the zero or more tokens until the closing\n+parenthesis that ends the invocation, including any commas.  This set of\n+tokens replaces the identifier @code{__VA_ARGS__} in the macro body\n+wherever it appears.  See the CPP manual for more information.\n+\n+GCC has long supported variadic macros, and used a different syntax that\n+allowed you to give a name to the variable arguments just like any other\n+argument.  Here is an example:\n \n @example\n-eprintf (\"%s:%d: \", input_file_name, line_number)\n-@expansion{}\n-fprintf (stderr, \"%s:%d: \" , input_file_name, line_number)\n+#define debug(format, args...) fprintf (stderr, format, args)\n @end example\n \n-@noindent\n-Note that the comma after the string constant comes from the definition\n-of @code{eprintf}, whereas the last comma comes from the value of\n-@code{args}.\n+This is in all ways equivalent to the ISO C example above, but arguably\n+more readable and descriptive.\n \n-The reason for using @samp{##} is to handle the case when @code{args}\n-matches no arguments at all.  In this case, @code{args} has an empty\n-value.  In this case, the second comma in the definition becomes an\n-embarrassment: if it got through to the expansion of the macro, we would\n-get something like this:\n+GNU CPP has two further variadic macro extensions, and permits them to\n+be used with either of the above forms of macro definition.\n+\n+In standard C, you are not allowed to leave the variable argument out\n+entirely; but you are allowed to pass an empty argument.  For example,\n+this invocation is invalid in ISO C, because there is no comma after\n+the string:\n \n @example\n-fprintf (stderr, \"success!\\n\" , )\n+debug (\"A message\")\n @end example\n \n-@noindent\n-which is invalid C syntax.  @samp{##} gets rid of the comma, so we get\n-the following instead:\n+GNU CPP permits you to completely omit the variable arguments in this\n+way.  In the above examples, the compiler would complain, though since\n+the expansion of the macro still has the extra comma after the format\n+string.\n+\n+To help solve this problem, CPP behaves specially for variable arguments\n+used with the token paste operator, @samp{##}.  If instead you write\n \n @example\n-fprintf (stderr, \"success!\\n\")\n+#define debug(format, ...) fprintf (stderr, format, ## __VA_ARGS__)\n @end example\n \n-This is a special feature of the GNU C preprocessor: @samp{##} before a\n-rest argument that is empty discards the preceding sequence of\n-non-whitespace characters from the macro definition.  (If another macro\n-argument precedes, none of it is discarded.)\n-\n-It might be better to discard the last preprocessor token instead of the\n-last preceding sequence of non-whitespace characters; in fact, we may\n-someday change this feature to do so.  We advise you to write the macro\n-definition so that the preceding sequence of non-whitespace characters\n-is just a single token, so that the meaning will not change if we change\n-the definition of this feature.\n+and if the variable arguments are omitted or empty, the @samp{##}\n+operator causes the preprocessor to remove the comma before it.  If you\n+do provide some variable arguments in your macro invocation, GNU CPP\n+does not complain about the paste operation and instead places the\n+variable arguments after the comma.  Just like any other pasted macro\n+argument, these arguments are not macro expanded.\n+\n+@node Escaped Newlines\n+@section Slightly Looser Rules for Escaped Newlines\n+@cindex escaped newlines\n+@cindex newlines (escaped)\n+\n+Recently, the non-traditional preprocessor has relaxed its treatment of\n+escaped newlines.  Previously, the newline had to immediately follow a\n+backslash.  The current implementation allows whitespace in the form of\n+spaces, horizontal and vertical tabs, and form feeds between the\n+backslash and the subsequent newline.  The preprocessor issues a\n+warning, but treats it as a valid escaped newline and combines the two\n+lines to form a single logical line.  This works within comments and\n+tokens, including multi-line strings, as well as between tokens.\n+Comments are @emph{not} treated as whitespace for the purposes of this\n+relaxation, since they have not yet been replaced with spaces.\n+\n+@node Multi-line Strings\n+@section String Literals with Embedded Newlines\n+@cindex multi-line string literals\n+\n+As an extension, GNU CPP permits string literals to cross multiple lines\n+without escaping the embedded newlines.  Each embedded newline is\n+replaced with a single @samp{\\n} character in the resulting string\n+literal, regardless of what form the newline took originally.\n+\n+CPP currently allows such strings in directives as well (other than the\n+@samp{#include} family).  This is deprecated and will eventually be\n+removed.\n \n @node Subscripting\n @section Non-Lvalue Arrays May Have Subscripts"}]}