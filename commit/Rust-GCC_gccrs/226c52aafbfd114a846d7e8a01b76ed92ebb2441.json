{"sha": "226c52aafbfd114a846d7e8a01b76ed92ebb2441", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI2YzUyYWFmYmZkMTE0YTg0NmQ3ZThhMDFiNzZlZDkyZWJiMjQ0MQ==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2011-05-30T04:38:42Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2011-05-30T04:38:42Z"}, "message": "New option to disable/enable optimization passes.\n\nFrom-SVN: r174423", "tree": {"sha": "c675ad7ddeb009e2d055e547eb38270b557653cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c675ad7ddeb009e2d055e547eb38270b557653cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/226c52aafbfd114a846d7e8a01b76ed92ebb2441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/226c52aafbfd114a846d7e8a01b76ed92ebb2441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/226c52aafbfd114a846d7e8a01b76ed92ebb2441", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/226c52aafbfd114a846d7e8a01b76ed92ebb2441/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d84ab7d2d484b3ba8fc8d0e1194c65cdcaf3ba0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d84ab7d2d484b3ba8fc8d0e1194c65cdcaf3ba0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d84ab7d2d484b3ba8fc8d0e1194c65cdcaf3ba0d"}], "stats": {"total": 454, "additions": 452, "deletions": 2}, "files": [{"sha": "ad6be6da202facd25f350db31a9428898d394f0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=226c52aafbfd114a846d7e8a01b76ed92ebb2441", "patch": "@@ -1,3 +1,18 @@\n+2011-05-29  Xinliang David Li  <davidxl@google.com>\n+\n+\t* opts-global.c (handle_common_deferred_options): Handle new options.\n+\t* passes.c (register_one_dump_file): Call register_pass_name.\n+\t(execute_one_pass): Check explicit enable/disable flag.\n+\t(passr_hash): New function.\n+\t(passr_eq): Ditto.\n+\t(register_pass_name): Ditto.\n+\t(get_pass_by_name): Ditto.\n+\t(pass_hash): Ditto.\n+\t(pass_eq): Ditto.\n+\t(enable_pass): Ditto.\n+\t(disable_pass): Ditto.\n+\t(is_pass_explicitly_enabled_or_disabled): Ditto.\n+\n 2011-05-29  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*movoi_internal_avx): Use"}, {"sha": "5a5360785bd9f69dec016a9d1e6ef82fa354dae5", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=226c52aafbfd114a846d7e8a01b76ed92ebb2441", "patch": "@@ -985,6 +985,14 @@ fdiagnostics-show-option\n Common Var(flag_diagnostics_show_option) Init(1)\n Amend appropriate diagnostic messages with the command line option that controls them\n \n+fdisable-\n+Common Joined RejectNegative Var(common_deferred_options) Defer\n+-fdisable-[tree|rtl|ipa]-<pass>=range1+range2 disables an optimization pass\n+\n+fenable-\n+Common Joined RejectNegative Var(common_deferred_options) Defer\n+-fenable-[tree|rtl|ipa]-<pass>=range1+range2 enables an optimization pass\n+\n fdump-\n Common Joined RejectNegative Var(common_deferred_options) Defer\n -fdump-<type>\tDump various compiler internals to a file"}, {"sha": "4b54c4abdaeb2d293bab1039a3e3515c22b59a00", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=226c52aafbfd114a846d7e8a01b76ed92ebb2441", "patch": "@@ -282,6 +282,11 @@ Objective-C and Objective-C++ Dialects}.\n @xref{Debugging Options,,Options for Debugging Your Program or GCC}.\n @gccoptlist{-d@var{letters}  -dumpspecs  -dumpmachine  -dumpversion @gol\n -fdbg-cnt-list -fdbg-cnt=@var{counter-value-list} @gol\n+-fdisable-ipa-@var{pass_name} @gol\n+-fdisable-rtl-@var{pass_name} @gol\n+-fdisable-rtl-@var{pass-name}=@var{range-list} @gol\n+-fdisable-tree-@var{pass_name} @gol\n+-fdisable-tree-@var{pass-name}=@var{range-list} @gol\n -fdump-noaddr -fdump-unnumbered -fdump-unnumbered-links @gol\n -fdump-translation-unit@r{[}-@var{n}@r{]} @gol\n -fdump-class-hierarchy@r{[}-@var{n}@r{]} @gol\n@@ -313,6 +318,8 @@ Objective-C and Objective-C++ Dialects}.\n -fcompare-debug@r{[}=@var{opts}@r{]}  -fcompare-debug-second @gol\n -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol\n -feliminate-unused-debug-symbols -femit-class-debug-always @gol\n+-fenable-@var{kind}-@var{pass} @gol\n+-fenable-@var{kind}-@var{pass}=@var{range-list} @gol\n -fdebug-types-section @gol\n -fmem-report -fpre-ipa-mem-report -fpost-ipa-mem-report -fprofile-arcs @gol\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n@@ -5017,6 +5024,7 @@ more closely, if you do not optimize.\n @opindex fdbg-cnt-list\n Print the name and the counter upper bound for all debug counters.\n \n+\n @item -fdbg-cnt=@var{counter-value-list}\n @opindex fdbg-cnt\n Set the internal debug counter upper bound.  @var{counter-value-list}\n@@ -5026,7 +5034,73 @@ All debug counters have the initial upper bound of @var{UINT_MAX},\n thus dbg_cnt() returns true always unless the upper bound is set by this option.\n e.g. With -fdbg-cnt=dce:10,tail_call:0\n dbg_cnt(dce) will return true only for first 10 invocations\n-and dbg_cnt(tail_call) will return false always.\n+\n+@itemx -fenable-@var{kind}-@var{pass}\n+@itemx -fdisable-@var{kind}-@var{pass}=@var{range-list}\n+@opindex fdisable-\n+@opindex fenable-\n+\n+This is a set of debugging options that are used to explicitly disable/enable\n+optimization passes. For compiler users, regular options for enabling/disabling\n+passes should be used instead.\n+\n+@itemize\n+\n+@item -fdisable-ipa-@var{pass}\n+Disable ipa pass @var{pass}. @var{pass} is the pass name.  If the same pass is\n+statically invoked in the compiler multiple times, the pass name should be\n+appended with a sequential number starting from 1.\n+\n+@item -fdisable-rtl-@var{pass}\n+@item -fdisable-rtl-@var{pass}=@var{range-list}\n+Disable rtl pass @var{pass}.  @var{pass} is the pass name.  If the same pass is\n+statically invoked in the compiler multiple times, the pass name should be\n+appended with a sequential number starting from 1.  @var{range-list} is a comma\n+seperated list of function ranges.  Each range is a number pair seperated by a colon.\n+The range is inclusive in both ends.  If the range is trivial, the number pair can be\n+simplified a a single number.  If the function's cgraph node's @var{uid} is falling\n+within one of the specified ranges, the @var{pass} is disabled for that function.\n+The @var{uid} is shown in the function header of a dump file.\n+\n+@item -fdisable-tree-@var{pass}\n+@item -fdisable-tree-@var{pass}=@var{range-list}\n+Disable tree pass @var{pass}.  See @option{-fdisable-rtl} for the description of\n+option arguments.\n+\n+@item -fenable-ipa-@var{pass}\n+Enable ipa pass @var{pass}.  @var{pass} is the pass name.  If the same pass is\n+statically invoked in the compiler multiple times, the pass name should be\n+appended with a sequential number starting from 1.\n+\n+@item -fenable-rtl-@var{pass}\n+@item -fenable-rtl-@var{pass}=@var{range-list}\n+Enable rtl pass @var{pass}.  See @option{-fdisable-rtl} for option argument\n+description and examples.\n+\n+@item -fenable-tree-@var{pass}\n+@item -fenable-tree-@var{pass}=@var{range-list}\n+Enable tree pass @var{pass}.  See @option{-fdisable-rtl} for the description\n+of option arguments.\n+\n+@smallexample\n+\n+# disable ccp1 for all functions\n+   -fdisable-tree-ccp1\n+# disable complete unroll for function whose cgraph node uid is 1\n+   -fenable-tree-cunroll=1\n+# disable gcse2 for functions at the following ranges [1,1],\n+# [300,400], and [400,1000]\n+   -fdisable-rtl-gcse2=1:100,300,400:1000\n+# disable early inlining\n+   -fdisable-tree-einline\n+# disable ipa inlining\n+   -fdisable-ipa-inline\n+# enable tree full unroll\n+   -fenable-tree-unroll\n+\n+@end smallexample\n+\n+@end itemize\n \n @item -d@var{letters}\n @itemx -fdump-rtl-@var{pass}"}, {"sha": "6fdc9519ca9bdb8079077bba5340ab3504e1c976", "filename": "gcc/opts-global.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Fopts-global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Fopts-global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-global.c?ref=226c52aafbfd114a846d7e8a01b76ed92ebb2441", "patch": "@@ -370,6 +370,14 @@ handle_common_deferred_options (void)\n \t    error (\"unrecognized command line option %<-fdump-%s%>\", opt->arg);\n \t  break;\n \n+\tcase OPT_fenable_:\n+\tcase OPT_fdisable_:\n+\t  if (opt->opt_index == OPT_fenable_)\n+\t    enable_pass (opt->arg);\n+          else\n+\t    disable_pass (opt->arg);\n+          break;\n+\n \tcase OPT_ffixed_:\n \t  /* Deferred.  */\n \t  fix_register (opt->arg, 1, 1);"}, {"sha": "4cfc4d37ee6783f5eb7e1b1ae3f615f1c4734bc7", "filename": "gcc/passes.c", "status": "modified", "additions": 321, "deletions": 1, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=226c52aafbfd114a846d7e8a01b76ed92ebb2441", "patch": "@@ -97,6 +97,8 @@ along with GCC; see the file COPYING3.  If not see\n    The variable current_pass is also used for statistics and plugins.  */\n struct opt_pass *current_pass;\n \n+static void register_pass_name (struct opt_pass *, const char *);\n+\n /* Call from anywhere to find out what pass this is.  Useful for\n    printing out debugging information deep inside an service\n    routine.  */\n@@ -375,7 +377,7 @@ void\n register_one_dump_file (struct opt_pass *pass)\n {\n   char *dot_name, *flag_name, *glob_name;\n-  const char *name, *prefix;\n+  const char *name, *full_name, *prefix;\n   char num[10];\n   int flags, id;\n \n@@ -404,6 +406,8 @@ register_one_dump_file (struct opt_pass *pass)\n   glob_name = concat (prefix, name, NULL);\n   id = dump_register (dot_name, flag_name, glob_name, flags);\n   set_pass_for_id (id, pass);\n+  full_name = concat (prefix, pass->name, num, NULL);\n+  register_pass_name (pass, full_name);\n }\n \n /* Recursive worker function for register_dump_files.  */\n@@ -447,6 +451,297 @@ register_dump_files (struct opt_pass *pass,int properties)\n   register_dump_files_1 (pass, properties);\n }\n \n+struct pass_registry\n+{\n+  const char* unique_name;\n+  struct opt_pass *pass;\n+};\n+\n+/* Pass registry hash function.  */\n+\n+static hashval_t\n+passr_hash (const void *p)\n+{\n+  const struct pass_registry *const s = (const struct pass_registry *const) p;\n+  return htab_hash_string (s->unique_name);\n+}\n+\n+/* Hash equal function  */\n+\n+static int\n+passr_eq (const void *p1, const void *p2)\n+{\n+  const struct pass_registry *const s1 = (const struct pass_registry *const) p1;\n+  const struct pass_registry *const s2 = (const struct pass_registry *const) p2;\n+\n+  return !strcmp (s1->unique_name, s2->unique_name);\n+}\n+\n+static htab_t pass_name_tab = NULL;\n+\n+/* Register PASS with NAME.  */\n+\n+static void\n+register_pass_name (struct opt_pass *pass, const char *name)\n+{\n+  struct pass_registry **slot;\n+  struct pass_registry pr;\n+\n+  if (!pass_name_tab)\n+    pass_name_tab = htab_create (256, passr_hash, passr_eq, NULL);\n+\n+  pr.unique_name = name;\n+  slot = (struct pass_registry **) htab_find_slot (pass_name_tab, &pr, INSERT);\n+  if (!*slot)\n+    {\n+      struct pass_registry *new_pr;\n+\n+      new_pr = XCNEW (struct pass_registry);\n+      new_pr->unique_name = xstrdup (name);\n+      new_pr->pass = pass;\n+      *slot = new_pr;\n+    }\n+  else\n+    return; /* Ignore plugin passes.  */\n+}\n+\n+/* Returns the pass with NAME.  */\n+\n+static struct opt_pass *\n+get_pass_by_name (const char *name)\n+{\n+  struct pass_registry **slot, pr;\n+\n+  gcc_assert (pass_name_tab);\n+  pr.unique_name = name;\n+  slot = (struct pass_registry **) htab_find_slot (pass_name_tab,\n+                                                   &pr, NO_INSERT);\n+\n+  if (!slot || !*slot)\n+    return NULL;\n+\n+  return (*slot)->pass;\n+}\n+\n+\n+/* Range [start, last].  */\n+\n+struct uid_range\n+{\n+  unsigned int start;\n+  unsigned int last;\n+  struct uid_range *next;\n+};\n+\n+typedef struct uid_range *uid_range_p;\n+\n+DEF_VEC_P(uid_range_p);\n+DEF_VEC_ALLOC_P(uid_range_p, heap);\n+\n+static VEC(uid_range_p, heap) *enabled_pass_uid_range_tab = NULL;\n+static VEC(uid_range_p, heap) *disabled_pass_uid_range_tab = NULL;\n+\n+/* Parse option string for -fdisable- and -fenable-\n+   The syntax of the options:\n+\n+   -fenable-<pass_name>\n+   -fdisable-<pass_name>\n+\n+   -fenable-<pass_name>=s1:e1,s2:e2,...\n+   -fdisable-<pass_name>=s1:e1,s2:e2,...\n+*/\n+\n+static void\n+enable_disable_pass (const char *arg, bool is_enable)\n+{\n+  struct opt_pass *pass;\n+  char *range_str, *phase_name;\n+  char *argstr = xstrdup (arg);\n+  VEC(uid_range_p, heap) **tab = 0;\n+\n+  range_str = strchr (argstr,'=');\n+  if (range_str)\n+    {\n+      *range_str = '\\0';\n+      range_str++;\n+    }\n+\n+  phase_name = argstr;\n+  if (!*phase_name)\n+    {\n+      if (is_enable)\n+        error (\"unrecognized option -fenable\");\n+      else\n+        error (\"unrecognized option -fdisable\");\n+      free (argstr);\n+      return;\n+    }\n+  pass = get_pass_by_name (phase_name);\n+  if (!pass || pass->static_pass_number == -1)\n+    {\n+      if (is_enable)\n+        error (\"unknown pass %s specified in -fenable\", phase_name);\n+      else\n+        error (\"unknown pass %s specified in -fdisble\", phase_name);\n+      free (argstr);\n+      return;\n+    }\n+\n+  if (is_enable)\n+    tab = &enabled_pass_uid_range_tab;\n+  else\n+    tab = &disabled_pass_uid_range_tab;\n+\n+  if ((unsigned) pass->static_pass_number >= VEC_length (uid_range_p, *tab))\n+    VEC_safe_grow_cleared (uid_range_p, heap,\n+                           *tab, pass->static_pass_number + 1);\n+\n+  if (!range_str)\n+    {\n+      uid_range_p slot;\n+      uid_range_p new_range = XCNEW (struct uid_range);\n+\n+      new_range->start = 0;\n+      new_range->last = (unsigned)-1;\n+\n+      slot = VEC_index (uid_range_p, *tab, pass->static_pass_number);\n+      new_range->next = slot;\n+      VEC_replace (uid_range_p, *tab, pass->static_pass_number,\n+                   new_range);\n+      if (is_enable)\n+        inform (UNKNOWN_LOCATION, \"enable pass %s for functions in the range \"\n+                \"of [%u, %u]\", phase_name, new_range->start, new_range->last);\n+      else\n+        inform (UNKNOWN_LOCATION, \"disable pass %s for functions in the range \"\n+                \"of [%u, %u]\", phase_name, new_range->start, new_range->last);\n+    }\n+  else\n+    {\n+      char *next_range = NULL;\n+      char *one_range = range_str;\n+      char *end_val = NULL;\n+\n+      do\n+\t{\n+\t  uid_range_p slot;\n+\t  uid_range_p new_range;\n+\t  char *invalid = NULL;\n+\t  long start;\n+\n+\t  next_range = strchr (one_range, ',');\n+\t  if (next_range)\n+\t    {\n+\t      *next_range = '\\0';\n+\t      next_range++;\n+\t    }\n+\n+\t  end_val = strchr (one_range, ':');\n+\t  if (end_val)\n+\t    {\n+\t      *end_val = '\\0';\n+\t      end_val++;\n+\t    }\n+\t  start = strtol (one_range, &invalid, 10);\n+\t  if (*invalid || start < 0)\n+\t    {\n+\t      error (\"Invalid range %s in option %s\",\n+\t\t     one_range,\n+\t\t     is_enable ? \"-fenable\" : \"-fdisable\");\n+\t      free (argstr);\n+\t      return;\n+\t    }\n+\t  if (!end_val)\n+\t    {\n+\t      new_range = XCNEW (struct uid_range);\n+\t      new_range->start = (unsigned) start;\n+\t      new_range->last = (unsigned) start;\n+\t    }\n+\t  else\n+\t    {\n+\t      long last = strtol (end_val, &invalid, 10);\n+\t      if (*invalid || last < start)\n+\t\t{\n+\t\t  error (\"Invalid range %s in option %s\",\n+\t\t\t end_val,\n+\t\t\t is_enable ? \"-fenable\" : \"-fdisable\");\n+\t\t  free (argstr);\n+\t\t  return;\n+\t\t}\n+\t      new_range = XCNEW (struct uid_range);\n+\t      new_range->start = (unsigned) start;\n+\t      new_range->last = (unsigned) last;\n+\t    }\n+\n+          slot = VEC_index (uid_range_p, *tab, pass->static_pass_number);\n+          new_range->next = slot;\n+          VEC_replace (uid_range_p, *tab, pass->static_pass_number,\n+                       new_range);\n+\n+          if (is_enable)\n+            inform (UNKNOWN_LOCATION,\n+                    \"enable pass %s for functions in the range of [%u, %u]\",\n+                    phase_name, new_range->start, new_range->last);\n+          else\n+            inform (UNKNOWN_LOCATION,\n+                    \"disable pass %s for functions in the range of [%u, %u]\",\n+                    phase_name, new_range->start, new_range->last);\n+\n+\t  one_range = next_range;\n+\t} while (next_range);\n+    }\n+\n+  free (argstr);\n+}\n+\n+/* Enable pass specified by ARG.  */\n+\n+void\n+enable_pass (const char *arg)\n+{\n+  enable_disable_pass (arg, true);\n+}\n+\n+/* Disable pass specified by ARG.  */\n+\n+void\n+disable_pass (const char *arg)\n+{\n+  enable_disable_pass (arg, false);\n+}\n+\n+/* Returns true if PASS is explicitly enabled/disabled for FUNC.  */\n+\n+static bool\n+is_pass_explicitly_enabled_or_disabled (struct opt_pass *pass,\n+\t\t\t\t\ttree func,\n+\t\t\t\t\tVEC(uid_range_p, heap) *tab)\n+{\n+  uid_range_p slot, range;\n+  int cgraph_uid;\n+\n+  if (!tab\n+      || (unsigned) pass->static_pass_number >= VEC_length (uid_range_p, tab)\n+      || pass->static_pass_number == -1)\n+    return false;\n+\n+  slot = VEC_index (uid_range_p, tab, pass->static_pass_number);\n+  if (!slot)\n+    return false;\n+\n+  cgraph_uid = func ? cgraph_get_node (func)->uid : 0;\n+\n+  range = slot;\n+  while (range)\n+    {\n+      if ((unsigned) cgraph_uid >= range->start\n+\t  && (unsigned) cgraph_uid <= range->last)\n+\treturn true;\n+      range = range->next;\n+    }\n+\n+  return false;\n+}\n+\n /* Look at the static_pass_number and duplicate the pass\n    if it is already added to a list. */\n \n@@ -1493,6 +1788,30 @@ execute_all_ipa_transforms (void)\n     }\n }\n \n+/* Check if PASS is explicitly disabled or enabled and return\n+   the gate status.  FUNC is the function to be processed, and\n+   GATE_STATUS is the gate status determined by pass manager by\n+   default.  */\n+\n+static bool\n+override_gate_status (struct opt_pass *pass, tree func, bool gate_status)\n+{\n+  bool explicitly_enabled = false;\n+  bool explicitly_disabled = false;\n+\n+  explicitly_enabled\n+   = is_pass_explicitly_enabled_or_disabled (pass, func,\n+                                             enabled_pass_uid_range_tab);\n+  explicitly_disabled\n+   = is_pass_explicitly_enabled_or_disabled (pass, func,\n+                                             disabled_pass_uid_range_tab);\n+\n+  gate_status = !explicitly_disabled && (gate_status || explicitly_enabled);\n+\n+  return gate_status;\n+}\n+\n+\n /* Execute PASS. */\n \n bool\n@@ -1515,6 +1834,7 @@ execute_one_pass (struct opt_pass *pass)\n   /* Check whether gate check should be avoided.\n      User controls the value of the gate through the parameter \"gate_status\". */\n   gate_status = (pass->gate == NULL) ? true : pass->gate();\n+  gate_status = override_gate_status (pass, current_function_decl, gate_status);\n \n   /* Override gate with plugin.  */\n   invoke_plugin_callbacks (PLUGIN_OVERRIDE_GATE, &gate_status);"}, {"sha": "daf7202f4f6f7f3e33bc77bd511d9c5795b1d834", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=226c52aafbfd114a846d7e8a01b76ed92ebb2441", "patch": "@@ -637,4 +637,7 @@ extern bool first_pass_instance;\n /* Declare for plugins.  */\n extern void do_per_function_toporder (void (*) (void *), void *);\n \n+extern void disable_pass (const char *);\n+extern void enable_pass (const char *);\n+\n #endif /* GCC_TREE_PASS_H */"}, {"sha": "b62417a779766bd3344456d11cbe6a3d1205c97d", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/226c52aafbfd114a846d7e8a01b76ed92ebb2441/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=226c52aafbfd114a846d7e8a01b76ed92ebb2441", "patch": "@@ -3013,3 +3013,25 @@ pp_base_tree_identifier (pretty_printer *pp, tree id)\n     pp_append_text (pp, IDENTIFIER_POINTER (id),\n \t\t    IDENTIFIER_POINTER (id) + IDENTIFIER_LENGTH (id));\n }\n+\n+#if 0\n+void\n+pass_dump_function_header (FILE *dump_file, tree fdecl, struct function *fun)\n+{\n+  const char *dname, *aname;\n+  struct cgraph_node *node = cgraph_get_node (fdecl);\n+  dname = lang_hooks.decl_printable_name (fdecl, 2);\n+  aname = (IDENTIFIER_POINTER\n+\t   (DECL_ASSEMBLER_NAME (fdecl)));\n+  fprintf (dump_file, \"\\n;; Function %s (%s)[fundef_no:%d][uid=%d]\",\n+           dname, aname, fun->funcdef_no, node->uid);\n+  fprintf (dump_file, \"%s\\n\\n\",\n+           node->frequency == NODE_FREQUENCY_HOT\n+           ? \" (hot)\"\n+           : node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED\n+           ? \" (unlikely executed)\"\n+           : node->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n+           ? \" (executed once)\"\n+           : \"\");\n+}\n+#endif"}]}