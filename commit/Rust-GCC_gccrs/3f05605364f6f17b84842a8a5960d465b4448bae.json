{"sha": "3f05605364f6f17b84842a8a5960d465b4448bae", "node_id": "C_kwDOANBUbNoAKDNmMDU2MDUzNjRmNmYxN2I4NDg0MmE4YTU5NjBkNDY1YjQ0NDhiYWU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-31T11:43:36Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-01T06:16:03Z"}, "message": "Cleanups to frange.\n\nThese are some assorted cleanups to the frange class to make it easier\nto drop in an implementation with FP endpoints:\n\n* frange::set() had some asserts limiting the type of arguments\n  passed.  There's no reason why we can't handle all the variants.\n  Worse comes to worse, we can always return a VARYING which is\n  conservative and correct.\n\n* frange::normalize_kind() now returns a boolean that can be used in\n  union and intersection to indicate that the range changed.\n\n* Implement vrp_val_max and vrp_val_min for floats.  Also, move them\n  earlier in the header file so frange can use them.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* value-range.cc (tree_compare): New.\n\t(frange::set): Make more general.\n\t(frange::normalize_kind): Cleanup and return bool.\n\t(frange::union_): Use normalize_kind return value.\n\t(frange::intersect): Same.\n\t(frange::verify_range): Remove unnecessary else.\n\t* value-range.h (vrp_val_max): Move before frange class.\n\t(vrp_val_min): Same.\n\t(frange::frange): Remove set to m_type.", "tree": {"sha": "f74fe9fd71c1f3bf256bd602b38066909f26ba26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f74fe9fd71c1f3bf256bd602b38066909f26ba26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f05605364f6f17b84842a8a5960d465b4448bae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f05605364f6f17b84842a8a5960d465b4448bae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f05605364f6f17b84842a8a5960d465b4448bae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f05605364f6f17b84842a8a5960d465b4448bae/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e029e067d81f714419cd196fdd506b06881e0c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e029e067d81f714419cd196fdd506b06881e0c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e029e067d81f714419cd196fdd506b06881e0c9"}], "stats": {"total": 172, "additions": 105, "deletions": 67}, "files": [{"sha": "dc06f8b00782706b2c65345a18a41cbdde50c93a", "filename": "gcc/value-range.cc", "status": "modified", "additions": 65, "deletions": 37, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f05605364f6f17b84842a8a5960d465b4448bae/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f05605364f6f17b84842a8a5960d465b4448bae/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=3f05605364f6f17b84842a8a5960d465b4448bae", "patch": "@@ -260,84 +260,113 @@ frange::accept (const vrange_visitor &v) const\n   v.visit (*this);\n }\n \n-// Setter for franges.  Currently only singletons are supported.\n+// Helper function to compare floats.  Returns TRUE if op1 .CODE. op2\n+// is nonzero.\n+\n+static inline bool\n+tree_compare (tree_code code, tree op1, tree op2)\n+{\n+  return !integer_zerop (fold_build2 (code, integer_type_node, op1, op2));\n+}\n+\n+// Setter for franges.\n \n void\n frange::set (tree min, tree max, value_range_kind kind)\n {\n-  gcc_checking_assert (kind == VR_RANGE);\n-  gcc_checking_assert (operand_equal_p (min, max));\n   gcc_checking_assert (TREE_CODE (min) == REAL_CST);\n+  gcc_checking_assert (TREE_CODE (max) == REAL_CST);\n+\n+  if (kind == VR_UNDEFINED)\n+    {\n+      set_undefined ();\n+      return;\n+    }\n+\n+  // Treat VR_ANTI_RANGE and VR_VARYING as varying.\n+  if (kind != VR_RANGE)\n+    {\n+      set_varying (TREE_TYPE (min));\n+      return;\n+    }\n \n   m_kind = kind;\n   m_type = TREE_TYPE (min);\n \n-  REAL_VALUE_TYPE *const cst = TREE_REAL_CST_PTR (min);\n-  if (real_isnan (cst))\n-    m_props.nan_set_yes ();\n-  else\n-    m_props.nan_set_no ();\n-\n-  if (real_isinf (cst))\n+  // Mark NANness.\n+  if (real_isnan (TREE_REAL_CST_PTR (min))\n+      || real_isnan (TREE_REAL_CST_PTR (max)))\n     {\n-      if (real_isneg (cst))\n-\t{\n-\t  m_props.inf_set_no ();\n-\t  m_props.ninf_set_yes ();\n-\t}\n-      else\n-\t{\n-\t  m_props.inf_set_yes ();\n-\t  m_props.ninf_set_no ();\n-\t}\n+      gcc_checking_assert (operand_equal_p (min, max));\n+      m_props.nan_set_yes ();\n     }\n   else\n+    m_props.nan_set_no ();\n+\n+  bool is_min = vrp_val_is_min (min);\n+  bool is_max = vrp_val_is_max (max);\n+\n+  // Mark when the endpoints can't be INF.\n+  if (!is_min)\n+    m_props.ninf_set_no ();\n+  if (!is_max)\n+    m_props.inf_set_no ();\n+\n+  // Mark when the endpoints are definitely INF.\n+  if (operand_equal_p (min, max))\n     {\n-      m_props.inf_set_no ();\n-      m_props.ninf_set_no ();\n+      if (is_min)\n+\tm_props.ninf_set_yes ();\n+      else if (is_max)\n+\tm_props.inf_set_yes ();\n     }\n \n+  // Check for swapped ranges.\n+  gcc_checking_assert (m_props.nan_yes_p ()\n+\t\t       || tree_compare (LE_EXPR, min, max));\n+\n   if (flag_checking)\n     verify_range ();\n }\n \n-// Normalize range to VARYING or UNDEFINED, or vice versa.\n+// Normalize range to VARYING or UNDEFINED, or vice versa.  Return\n+// TRUE if anything changed.\n //\n // A range with no known properties can be dropped to VARYING.\n // Similarly, a VARYING with any properties should be dropped to a\n // VR_RANGE.  Normalizing ranges upon changing them ensures there is\n // only one representation for a given range.\n \n-void\n+bool\n frange::normalize_kind ()\n {\n   if (m_kind == VR_RANGE)\n     {\n       // No FP properties set means varying.\n-      if (m_props.nan_varying_p ()\n-\t  && m_props.inf_varying_p ()\n-\t  && m_props.ninf_varying_p ())\n+      if (m_props.varying_p ())\n \t{\n \t  set_varying (m_type);\n-\t  return;\n+\t  return true;\n \t}\n       // Undefined is viral.\n       if (m_props.nan_undefined_p ()\n \t  || m_props.inf_undefined_p ()\n \t  || m_props.ninf_undefined_p ())\n \t{\n \t  set_undefined ();\n-\t  return;\n+\t  return true;\n \t}\n     }\n   else if (m_kind == VR_VARYING)\n     {\n       // If a VARYING has any FP properties, it's no longer VARYING.\n-      if (!m_props.nan_varying_p ()\n-\t  || !m_props.inf_varying_p ()\n-\t  || !m_props.ninf_varying_p ())\n-\tm_kind = VR_RANGE;\n+      if (!m_props.varying_p ())\n+\t{\n+\t  m_kind = VR_RANGE;\n+\t  return true;\n+\t}\n     }\n+  return false;\n }\n \n bool\n@@ -354,7 +383,7 @@ frange::union_ (const vrange &v)\n     }\n \n   bool ret = m_props.union_ (r.m_props);\n-  normalize_kind ();\n+  ret |= normalize_kind ();\n \n   if (flag_checking)\n     verify_range ();\n@@ -380,7 +409,7 @@ frange::intersect (const vrange &v)\n     }\n \n   bool ret = m_props.intersect (r.m_props);\n-  normalize_kind ();\n+  ret |= normalize_kind ();\n \n   if (flag_checking)\n     verify_range ();\n@@ -429,12 +458,11 @@ frange::verify_range ()\n       gcc_checking_assert (m_props.undefined_p ());\n       return;\n     }\n-  else if (varying_p ())\n+  if (varying_p ())\n     {\n       gcc_checking_assert (m_props.varying_p ());\n       return;\n     }\n-\n   gcc_checking_assert (m_kind == VR_RANGE);\n   gcc_checking_assert (!m_props.varying_p () && !m_props.undefined_p ());\n }"}, {"sha": "390fcb8fd9901516ea7f5989cdc884918b170f58", "filename": "gcc/value-range.h", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f05605364f6f17b84842a8a5960d465b4448bae/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f05605364f6f17b84842a8a5960d465b4448bae/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=3f05605364f6f17b84842a8a5960d465b4448bae", "patch": "@@ -359,7 +359,7 @@ class frange : public vrange\n   FRANGE_PROP_ACCESSOR(ninf)\n private:\n   void verify_range ();\n-  void normalize_kind ();\n+  bool normalize_kind ();\n \n   frange_props m_props;\n   tree m_type;\n@@ -1010,6 +1010,45 @@ irange::normalize_kind ()\n     }\n }\n \n+// Return the maximum value for TYPE.\n+\n+inline tree\n+vrp_val_max (const_tree type)\n+{\n+  if (INTEGRAL_TYPE_P (type))\n+    return TYPE_MAX_VALUE (type);\n+  if (POINTER_TYPE_P (type))\n+    {\n+      wide_int max = wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n+      return wide_int_to_tree (const_cast<tree> (type), max);\n+    }\n+  if (frange::supports_p (type))\n+    {\n+      REAL_VALUE_TYPE real;\n+      real_inf (&real);\n+      return build_real (const_cast <tree> (type), real);\n+    }\n+  return NULL_TREE;\n+}\n+\n+// Return the minimum value for TYPE.\n+\n+inline tree\n+vrp_val_min (const_tree type)\n+{\n+  if (INTEGRAL_TYPE_P (type))\n+    return TYPE_MIN_VALUE (type);\n+  if (POINTER_TYPE_P (type))\n+    return build_zero_cst (const_cast<tree> (type));\n+  if (frange::supports_p (type))\n+    {\n+      REAL_VALUE_TYPE real, real_ninf;\n+      real_inf (&real);\n+      real_ninf = real_value_negate (&real);\n+      return build_real (const_cast <tree> (type), real_ninf);\n+    }\n+  return NULL_TREE;\n+}\n \n // Supporting methods for frange.\n \n@@ -1039,7 +1078,6 @@ inline\n frange::frange ()\n {\n   m_discriminator = VR_FRANGE;\n-  m_type = nullptr;\n   set_undefined ();\n }\n \n@@ -1072,32 +1110,4 @@ frange::set_undefined ()\n   m_props.set_undefined ();\n }\n \n-\n-// Return the maximum value for TYPE.\n-\n-inline tree\n-vrp_val_max (const_tree type)\n-{\n-  if (INTEGRAL_TYPE_P (type))\n-    return TYPE_MAX_VALUE (type);\n-  if (POINTER_TYPE_P (type))\n-    {\n-      wide_int max = wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n-      return wide_int_to_tree (const_cast<tree> (type), max);\n-    }\n-  return NULL_TREE;\n-}\n-\n-// Return the minimum value for TYPE.\n-\n-inline tree\n-vrp_val_min (const_tree type)\n-{\n-  if (INTEGRAL_TYPE_P (type))\n-    return TYPE_MIN_VALUE (type);\n-  if (POINTER_TYPE_P (type))\n-    return build_zero_cst (const_cast<tree> (type));\n-  return NULL_TREE;\n-}\n-\n #endif // GCC_VALUE_RANGE_H"}]}