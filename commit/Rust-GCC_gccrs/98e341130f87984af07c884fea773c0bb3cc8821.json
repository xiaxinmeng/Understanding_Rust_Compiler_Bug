{"sha": "98e341130f87984af07c884fea773c0bb3cc8821", "node_id": "C_kwDOANBUbNoAKDk4ZTM0MTEzMGY4Nzk4NGFmMDdjODg0ZmVhNzczYzBiYjNjYzg4MjE", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-14T07:28:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-14T07:28:57Z"}, "message": "c++: Implement excess precision support for C++ [PR107097, PR323]\n\nThe following patch implements excess precision support for C++.\nLike for C, it uses EXCESS_PRECISION_EXPR tree to say that its operand\nis evaluated in excess precision and what the semantic type of the\nexpression is.\nIn most places I've followed what the C FE does in similar spots, so\ne.g. for binary ops if one or both operands are already\nEXCESS_PRECISION_EXPR, strip those away or for operations that might need\nexcess precision (+, -, *, /) check if the operands should use excess\nprecision and convert to that type and at the end wrap into\nEXCESS_PRECISION_EXPR with the common semantic type.\nThis patch follows the C99 handling where it differs from C11 handling.\n\nThere are some cases which needed to be handled differently, the C FE can\njust strip EXCESS_PRECISION_EXPR (replace it with its operand) when handling\nexplicit cast, but that IMHO isn't right for C++ - the discovery what exact\nconversion should be used (e.g. if user conversion or standard or their\nsequence) should be decided based on the semantic type (i.e. type of\nEXCESS_PRECISION_EXPR), and that decision continues in convert_like* where\nwe pick the right user conversion, again, if say some class has ctor\nfrom double and long double and we are on ia32 with standard excess\nprecision promoting float/double to long double, then we should pick the\nctor from double.  Or when some other class has ctor from just double,\nand EXCESS_PRECISION_EXPR semantic type is float, we should choose the\nuser ctor from double, but actually just convert the long double excess\nprecision to double and not to float first.  We need to make sure\neven identity conversion converts from excess precision to the semantic one\nthough, but if identity is chained with other conversions, we don't want\nthe identity next_conversion to drop to semantic precision only to widen\nafterwards.\n\nThe existing testcases tweaks were for cases on i686-linux where excess\nprecision breaks those tests, e.g. if we have\n  double d = 4.2;\n  if (d == 4.2)\nthen it does the expected thing only with -fexcess-precision=fast,\nbecause with -fexcess-precision=standard it is actually\n  double d = 4.2;\n  if ((long double) d == 4.2L)\nwhere 4.2L is different from 4.2.  I've added -fexcess-precision=fast\nto some tests and changed other tests to use constants that are exactly\nrepresentable and don't suffer from these excess precision issues.\n\nThere is one exception, pr68180.C looks like a bug in the patch which is\nalso present in the C FE (so I'd like to get it resolved incrementally\nin both).  Reduced testcase:\ntypedef float __attribute__((vector_size (16))) float32x4_t;\nfloat32x4_t foo(float32x4_t x, float y) { return x + y; }\nwith -m32 -std=c11 -Wno-psabi or -m32 -std=c++17 -Wno-psabi\nit is rejected with:\npr68180.c:2:52: error: conversion of scalar \u2018long double\u2019 to vector \u2018float32x4_t\u2019 {aka \u2018__vector(4) float\u2019} involves truncation\nbut without excess precision (say just -std=c11 -Wno-psabi or -std=c++17 -Wno-psabi)\nit is accepted.  Perhaps we should pass down the semantic type to\nscalar_to_vector and use the semantic type rather than excess precision type\nin the diagnostics.\n\n2022-10-14  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/323\n\tPR c++/107097\ngcc/\n\t* doc/invoke.texi (-fexcess-precision=standard): Mention that the\n\toption now also works in C++.\ngcc/c-family/\n\t* c-common.def (EXCESS_PRECISION_EXPR): Remove comment part about\n\tthe tree being specific to C/ObjC.\n\t* c-opts.cc (c_common_post_options): Handle flag_excess_precision\n\tin C++ the same as in C.\n\t* c-lex.cc (interpret_float): Set const_type to excess_precision ()\n\teven for C++.\ngcc/cp/\n\t* parser.cc (cp_parser_primary_expression): Handle\n\tEXCESS_PRECISION_EXPR with REAL_CST operand the same as REAL_CST.\n\t* cvt.cc (cp_ep_convert_and_check): New function.\n\t* call.cc (build_conditional_expr): Add excess precision support.\n\tWhen type_after_usual_arithmetic_conversions returns error_mark_node,\n\tuse gcc_checking_assert that it is because of uncomparable floating\n\tpoint ranks instead of checking all those conditions and make it\n\twork also with complex types.\n\t(convert_like_internal): Likewise.  Add NESTED_P argument, pass true\n\tto recursive calls to convert_like.\n\t(convert_like): Add NESTED_P argument, pass it through to\n\tconvert_like_internal.  For other overload pass false to it.\n\t(convert_like_with_context): Pass false to NESTED_P.\n\t(convert_arg_to_ellipsis): Add excess precision support.\n\t(magic_varargs_p): For __builtin_is{finite,inf,inf_sign,nan,normal}\n\tand __builtin_fpclassify return 2 instead of 1, document what it\n\tmeans.\n\t(build_over_call): Don't handle former magic 2 which is no longer\n\tused, instead for magic 1 remove EXCESS_PRECISION_EXPR.\n\t(perform_direct_initialization_if_possible): Pass false to NESTED_P\n\tconvert_like argument.\n\t* constexpr.cc (cxx_eval_constant_expression): Handle\n\tEXCESS_PRECISION_EXPR.\n\t(potential_constant_expression_1): Likewise.\n\t* pt.cc (tsubst_copy, tsubst_copy_and_build): Likewise.\n\t* cp-tree.h (cp_ep_convert_and_check): Declare.\n\t* cp-gimplify.cc (cp_fold): Handle EXCESS_PRECISION_EXPR.\n\t* typeck.cc (cp_common_type): For COMPLEX_TYPEs, return error_mark_node\n\tif recursive call returned it.\n\t(convert_arguments): For magic 1 remove EXCESS_PRECISION_EXPR.\n\t(cp_build_binary_op): Add excess precision support.  When\n\tcp_common_type returns error_mark_node, use gcc_checking_assert that\n\tit is because of uncomparable floating point ranks instead of checking\n\tall those conditions and make it work also with complex types.\n\t(cp_build_unary_op): Likewise.\n\t(cp_build_compound_expr): Likewise.\n\t(build_static_cast_1): Remove EXCESS_PRECISION_EXPR.\ngcc/testsuite/\n\t* gcc.target/i386/excess-precision-1.c: For C++ wrap abort and\n\texit declarations into extern \"C\" block.\n\t* gcc.target/i386/excess-precision-2.c: Likewise.\n\t* gcc.target/i386/excess-precision-3.c: Likewise.  Remove\n\tcheck_float_nonproto and check_double_nonproto tests for C++.\n\t* gcc.target/i386/excess-precision-7.c: For C++ wrap abort and\n\texit declarations into extern \"C\" block.\n\t* gcc.target/i386/excess-precision-9.c: Likewise.\n\t* g++.target/i386/excess-precision-1.C: New test.\n\t* g++.target/i386/excess-precision-2.C: New test.\n\t* g++.target/i386/excess-precision-3.C: New test.\n\t* g++.target/i386/excess-precision-4.C: New test.\n\t* g++.target/i386/excess-precision-5.C: New test.\n\t* g++.target/i386/excess-precision-6.C: New test.\n\t* g++.target/i386/excess-precision-7.C: New test.\n\t* g++.target/i386/excess-precision-9.C: New test.\n\t* g++.target/i386/excess-precision-11.C: New test.\n\t* c-c++-common/dfp/convert-bfp-10.c: Add -fexcess-precision=fast\n\tas dg-additional-options.\n\t* c-c++-common/dfp/compare-eq-const.c: Likewise.\n\t* g++.dg/cpp1z/constexpr-96862.C: Likewise.\n\t* g++.dg/cpp1z/decomp12.C (main): Use 2.25 instead of 2.3 to\n\tavoid excess precision differences.\n\t* g++.dg/other/thunk1.C: Add -fexcess-precision=fast\n\tas dg-additional-options.\n\t* g++.dg/vect/pr64410.cc: Likewise.\n\t* g++.dg/cpp1y/pr68180.C: Likewise.\n\t* g++.dg/vect/pr89653.cc: Likewise.\n\t* g++.dg/cpp0x/variadic-tuple.C: Likewise.\n\t* g++.dg/cpp0x/nsdmi-union1.C: Use 4.25 instead of 4.2 to\n\tavoid excess precision differences.\n\t* g++.old-deja/g++.brendan/copy9.C: Add -fexcess-precision=fast\n\tas dg-additional-options.\n\t* g++.old-deja/g++.brendan/overload7.C: Likewise.", "tree": {"sha": "2517b1b2ca58af9d2c34a5aaa25ea3e3cc568366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2517b1b2ca58af9d2c34a5aaa25ea3e3cc568366"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98e341130f87984af07c884fea773c0bb3cc8821", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e341130f87984af07c884fea773c0bb3cc8821", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e341130f87984af07c884fea773c0bb3cc8821", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e341130f87984af07c884fea773c0bb3cc8821/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18981635127c6701733dc052aa054e569271b733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18981635127c6701733dc052aa054e569271b733", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18981635127c6701733dc052aa054e569271b733"}], "stats": {"total": 699, "additions": 613, "deletions": 86}, "files": [{"sha": "dd8be7fdd3dea936ec4e5ba1ad40a0ab2ec9728e", "filename": "gcc/c-family/c-common.def", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fc-family%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fc-family%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.def?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -38,10 +38,9 @@ along with GCC; see the file COPYING3.  If not see\n    not.  */\n DEFTREECODE (C_MAYBE_CONST_EXPR, \"c_maybe_const_expr\", tcc_expression, 2)\n \n-/* An EXCESS_PRECISION_EXPR, currently only used for C and Objective\n-   C, represents an expression evaluated in greater range or precision\n-   than its type.  The type of the EXCESS_PRECISION_EXPR is the\n-   semantic type while the operand represents what is actually being\n+/* An EXCESS_PRECISION_EXPR represents an expression evaluated in greater\n+   range or precision than its type.  The type of the EXCESS_PRECISION_EXPR\n+   is the semantic type while the operand represents what is actually being\n    evaluated.  */\n DEFTREECODE (EXCESS_PRECISION_EXPR, \"excess_precision_expr\", tcc_expression, 1)\n "}, {"sha": "11f2b7847383a761055d1f33adf69fe87a61edd9", "filename": "gcc/c-family/c-lex.cc", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fc-family%2Fc-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fc-family%2Fc-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.cc?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -1008,10 +1008,7 @@ interpret_float (const cpp_token *token, unsigned int flags,\n     else\n       type = double_type_node;\n \n-  if (c_dialect_cxx ())\n-    const_type = NULL_TREE;\n-  else\n-    const_type = excess_precision_type (type);\n+  const_type = excess_precision_type (type);\n   if (!const_type)\n     const_type = type;\n "}, {"sha": "32b929e3ece489afa9f94ee29461e37df8a0f228", "filename": "gcc/c-family/c-opts.cc", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fc-family%2Fc-opts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fc-family%2Fc-opts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.cc?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -812,17 +812,9 @@ c_common_post_options (const char **pfilename)\n   C_COMMON_OVERRIDE_OPTIONS;\n #endif\n \n-  /* Excess precision other than \"fast\" requires front-end\n-     support.  */\n-  if (c_dialect_cxx ())\n-    {\n-      if (flag_excess_precision == EXCESS_PRECISION_STANDARD)\n-\tsorry (\"%<-fexcess-precision=standard%> for C++\");\n-      flag_excess_precision = EXCESS_PRECISION_FAST;\n-    }\n-  else if (flag_excess_precision == EXCESS_PRECISION_DEFAULT)\n+  if (flag_excess_precision == EXCESS_PRECISION_DEFAULT)\n     flag_excess_precision = (flag_iso ? EXCESS_PRECISION_STANDARD\n-\t\t\t\t      : EXCESS_PRECISION_FAST);\n+\t\t\t     : EXCESS_PRECISION_FAST);\n \n   /* ISO C restricts floating-point expression contraction to within\n      source-language expressions (-ffp-contract=on, currently an alias"}, {"sha": "709afc63eb7598d24f89ff87d0f20d62be38a461", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 124, "deletions": 30, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -5359,6 +5359,7 @@ build_conditional_expr (const op_location_t &loc,\n   tree arg3_type;\n   tree result = NULL_TREE;\n   tree result_type = NULL_TREE;\n+  tree semantic_result_type = NULL_TREE;\n   bool is_glvalue = true;\n   struct z_candidate *candidates = 0;\n   struct z_candidate *cand;\n@@ -5392,6 +5393,9 @@ build_conditional_expr (const op_location_t &loc,\n \t   expression, since it needs to be materialized for the\n \t   conversion to bool, so treat it as an xvalue in arg2.  */\n \targ2 = move (TARGET_EXPR_SLOT (arg1));\n+      else if (TREE_CODE (arg1) == EXCESS_PRECISION_EXPR)\n+\targ2 = arg1 = build1 (EXCESS_PRECISION_EXPR, TREE_TYPE (arg1),\n+\t\t\t      cp_save_expr (TREE_OPERAND (arg1, 0)));\n       else\n \targ2 = arg1 = cp_save_expr (arg1);\n     }\n@@ -5550,15 +5554,59 @@ build_conditional_expr (const op_location_t &loc,\n   if (error_operand_p (arg1))\n     return error_mark_node;\n \n+  arg2_type = unlowered_expr_type (arg2);\n+  arg3_type = unlowered_expr_type (arg3);\n+\n+  if ((TREE_CODE (arg2) == EXCESS_PRECISION_EXPR\n+       || TREE_CODE (arg3) == EXCESS_PRECISION_EXPR)\n+      && (TREE_CODE (arg2_type) == INTEGER_TYPE\n+\t  || TREE_CODE (arg2_type) == REAL_TYPE\n+\t  || TREE_CODE (arg2_type) == COMPLEX_TYPE)\n+      && (TREE_CODE (arg3_type) == INTEGER_TYPE\n+\t  || TREE_CODE (arg3_type) == REAL_TYPE\n+\t  || TREE_CODE (arg3_type) == COMPLEX_TYPE))\n+    {\n+      semantic_result_type\n+\t= type_after_usual_arithmetic_conversions (arg2_type, arg3_type);\n+      if (semantic_result_type == error_mark_node)\n+\t{\n+\t  tree t1 = arg2_type;\n+\t  tree t2 = arg3_type;\n+\t  if (TREE_CODE (t1) == COMPLEX_TYPE)\n+\t    t1 = TREE_TYPE (t1);\n+\t  if (TREE_CODE (t2) == COMPLEX_TYPE)\n+\t    t2 = TREE_TYPE (t2);\n+\t  gcc_checking_assert (TREE_CODE (t1) == REAL_TYPE\n+\t\t\t       && TREE_CODE (t2) == REAL_TYPE\n+\t\t\t       && (extended_float_type_p (t1)\n+\t\t\t\t   || extended_float_type_p (t2))\n+\t\t\t       && cp_compare_floating_point_conversion_ranks\n+\t\t\t\t    (t1, t2) == 3);\n+\t  if (complain & tf_error)\n+\t    error_at (loc, \"operands to %<?:%> of types %qT and %qT \"\n+\t\t\t   \"have unordered conversion rank\",\n+\t\t      arg2_type, arg3_type);\n+\t  return error_mark_node;\n+\t}\n+      if (TREE_CODE (arg2) == EXCESS_PRECISION_EXPR)\n+\t{\n+\t  arg2 = TREE_OPERAND (arg2, 0);\n+\t  arg2_type = TREE_TYPE (arg2);\n+\t}\n+      if (TREE_CODE (arg3) == EXCESS_PRECISION_EXPR)\n+\t{\n+\t  arg3 = TREE_OPERAND (arg3, 0);\n+\t  arg3_type = TREE_TYPE (arg3);\n+\t}\n+    }\n+\n   /* [expr.cond]\n \n      If either the second or the third operand has type (possibly\n      cv-qualified) void, then the lvalue-to-rvalue (_conv.lval_),\n      array-to-pointer (_conv.array_), and function-to-pointer\n      (_conv.func_) standard conversions are performed on the second\n      and third operands.  */\n-  arg2_type = unlowered_expr_type (arg2);\n-  arg3_type = unlowered_expr_type (arg3);\n   if (VOID_TYPE_P (arg2_type) || VOID_TYPE_P (arg3_type))\n     {\n       /* 'void' won't help in resolving an overloaded expression on the\n@@ -5850,14 +5898,20 @@ build_conditional_expr (const op_location_t &loc,\n       /* In this case, there is always a common type.  */\n       result_type = type_after_usual_arithmetic_conversions (arg2_type,\n \t\t\t\t\t\t\t     arg3_type);\n-      if (result_type == error_mark_node\n-\t  && TREE_CODE (arg2_type) == REAL_TYPE\n-\t  && TREE_CODE (arg3_type) == REAL_TYPE\n-\t  && (extended_float_type_p (arg2_type)\n-\t      || extended_float_type_p (arg3_type))\n-\t  && cp_compare_floating_point_conversion_ranks (arg2_type,\n-\t\t\t\t\t\t\t arg3_type) == 3)\n+      if (result_type == error_mark_node)\n \t{\n+\t  tree t1 = arg2_type;\n+\t  tree t2 = arg3_type;\n+\t  if (TREE_CODE (t1) == COMPLEX_TYPE)\n+\t    t1 = TREE_TYPE (t1);\n+\t  if (TREE_CODE (t2) == COMPLEX_TYPE)\n+\t    t2 = TREE_TYPE (t2);\n+\t  gcc_checking_assert (TREE_CODE (t1) == REAL_TYPE\n+\t\t\t       && TREE_CODE (t2) == REAL_TYPE\n+\t\t\t       && (extended_float_type_p (t1)\n+\t\t\t\t   || extended_float_type_p (t2))\n+\t\t\t       && cp_compare_floating_point_conversion_ranks\n+\t\t\t\t    (t1, t2) == 3);\n \t  if (complain & tf_error)\n \t    error_at (loc, \"operands to %<?:%> of types %qT and %qT \"\n \t\t\t   \"have unordered conversion rank\",\n@@ -5922,6 +5976,10 @@ build_conditional_expr (const op_location_t &loc,\n \t    }\n \t}\n \n+      if (semantic_result_type && INTEGRAL_TYPE_P (arg2_type))\n+\targ2 = perform_implicit_conversion (semantic_result_type, arg2, complain);\n+      else if (semantic_result_type && INTEGRAL_TYPE_P (arg3_type))\n+\targ3 = perform_implicit_conversion (semantic_result_type, arg3, complain);\n       arg2 = perform_implicit_conversion (result_type, arg2, complain);\n       arg3 = perform_implicit_conversion (result_type, arg3, complain);\n     }\n@@ -6009,9 +6067,15 @@ build_conditional_expr (const op_location_t &loc,\n       /* If this expression is an rvalue, but might be mistaken for an\n \t lvalue, we must add a NON_LVALUE_EXPR.  */\n       result = rvalue (result);\n+      if (semantic_result_type)\n+\tresult = build1 (EXCESS_PRECISION_EXPR, semantic_result_type,\n+\t\t\t result);\n     }\n   else\n-    result = force_paren_expr (result);\n+    {\n+      result = force_paren_expr (result);\n+      gcc_assert (semantic_result_type == NULL_TREE);\n+    }\n \n   return result;\n }\n@@ -7875,7 +7939,7 @@ maybe_warn_array_conv (location_t loc, conversion *c, tree expr)\n }\n \n /* We call this recursively in convert_like_internal.  */\n-static tree convert_like (conversion *, tree, tree, int, bool, bool,\n+static tree convert_like (conversion *, tree, tree, int, bool, bool, bool,\n \t\t\t  tsubst_flags_t);\n \n /* Perform the conversions in CONVS on the expression EXPR.  FN and\n@@ -7891,7 +7955,7 @@ static tree convert_like (conversion *, tree, tree, int, bool, bool,\n static tree\n convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \t\t       bool issue_conversion_warnings, bool c_cast_p,\n-\t\t       tsubst_flags_t complain)\n+\t\t       bool nested_p, tsubst_flags_t complain)\n {\n   tree totype = convs->type;\n   diagnostic_t diag_kind;\n@@ -7968,7 +8032,8 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \t\tprint_z_candidate (loc, N_(\"candidate is:\"), t->cand);\n \t      expr = convert_like (t, expr, fn, argnum,\n \t\t\t\t   /*issue_conversion_warnings=*/false,\n-\t\t\t\t   /*c_cast_p=*/false, complain);\n+\t\t\t\t   /*c_cast_p=*/false, /*nested_p=*/true,\n+\t\t\t\t   complain);\n \t      if (convs->kind == ck_ref_bind)\n \t\texpr = convert_to_reference (totype, expr, CONV_IMPLICIT,\n \t\t\t\t\t     LOOKUP_NORMAL, NULL_TREE,\n@@ -7983,13 +8048,15 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \t    {\n \t      expr = convert_like (t, expr, fn, argnum,\n \t\t\t\t   /*issue_conversion_warnings=*/false,\n-\t\t\t\t   /*c_cast_p=*/false, complain);\n+\t\t\t\t   /*c_cast_p=*/false, /*nested_p=*/true,\n+\t\t\t\t   complain);\n \t      break;\n \t    }\n \t  else if (t->kind == ck_ambig)\n \t    return convert_like (t, expr, fn, argnum,\n \t\t\t\t /*issue_conversion_warnings=*/false,\n-\t\t\t\t /*c_cast_p=*/false, complain);\n+\t\t\t\t /*c_cast_p=*/false, /*nested_p=*/true,\n+\t\t\t\t complain);\n \t  else if (t->kind == ck_identity)\n \t    break;\n \t}\n@@ -8109,6 +8176,8 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \n       if (type_unknown_p (expr))\n \texpr = instantiate_type (totype, expr, complain);\n+      if (!nested_p && TREE_CODE (expr) == EXCESS_PRECISION_EXPR)\n+\texpr = cp_convert (totype, TREE_OPERAND (expr, 0), complain);\n       if (expr == null_node\n \t  && INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (totype))\n \t/* If __null has been converted to an integer type, we do not want to\n@@ -8148,7 +8217,8 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \t    FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (expr), ix, val)\n \t      {\n \t\ttree sub = convert_like (convs->u.list[ix], val, fn,\n-\t\t\t\t\t argnum, false, false, complain);\n+\t\t\t\t\t argnum, false, false,\n+\t\t\t\t\t /*nested_p=*/true, complain);\n \t\tif (sub == error_mark_node)\n \t\t  return sub;\n \t\tif (!BRACE_ENCLOSED_INITIALIZER_P (val)\n@@ -8216,7 +8286,7 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n   expr = convert_like (next_conversion (convs), expr, fn, argnum,\n \t\t       convs->kind == ck_ref_bind\n \t\t       ? issue_conversion_warnings : false,\n-\t\t       c_cast_p, complain & ~tf_no_cleanup);\n+\t\t       c_cast_p, /*nested_p=*/true, complain & ~tf_no_cleanup);\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n@@ -8475,7 +8545,15 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n     return error_mark_node;\n \n   warning_sentinel w (warn_zero_as_null_pointer_constant);\n-  if (issue_conversion_warnings)\n+  if (TREE_CODE (expr) == EXCESS_PRECISION_EXPR)\n+    {\n+      if (issue_conversion_warnings)\n+\texpr = cp_ep_convert_and_check (totype, TREE_OPERAND (expr, 0),\n+\t\t\t\t\tTREE_TYPE (expr), complain);\n+      else\n+\texpr = cp_convert (totype, TREE_OPERAND (expr, 0), complain);\n+    }\n+  else if (issue_conversion_warnings)\n     expr = cp_convert_and_check (totype, expr, complain);\n   else\n     expr = cp_convert (totype, expr, complain);\n@@ -8509,7 +8587,7 @@ conv_unsafe_in_template_p (tree to, tree from)\n \n static tree\n convert_like (conversion *convs, tree expr, tree fn, int argnum,\n-\t      bool issue_conversion_warnings, bool c_cast_p,\n+\t      bool issue_conversion_warnings, bool c_cast_p, bool nested_p,\n \t      tsubst_flags_t complain)\n {\n   /* Creating &TARGET_EXPR<> in a template breaks when substituting,\n@@ -8532,7 +8610,8 @@ convert_like (conversion *convs, tree expr, tree fn, int argnum,\n \t error_mark_node.  */\n     }\n   expr = convert_like_internal (convs, expr, fn, argnum,\n-\t\t\t\tissue_conversion_warnings, c_cast_p, complain);\n+\t\t\t\tissue_conversion_warnings, c_cast_p,\n+\t\t\t\tnested_p, complain);\n   if (expr == error_mark_node)\n     return error_mark_node;\n   return conv_expr ? conv_expr : expr;\n@@ -8545,7 +8624,7 @@ convert_like (conversion *convs, tree expr, tsubst_flags_t complain)\n {\n   return convert_like (convs, expr, NULL_TREE, 0,\n \t\t       /*issue_conversion_warnings=*/true,\n-\t\t       /*c_cast_p=*/false, complain);\n+\t\t       /*c_cast_p=*/false, /*nested_p=*/false, complain);\n }\n \n /* Convenience wrapper for convert_like.  */\n@@ -8556,7 +8635,7 @@ convert_like_with_context (conversion *convs, tree expr, tree fn, int argnum,\n {\n   return convert_like (convs, expr, fn, argnum,\n \t\t       /*issue_conversion_warnings=*/true,\n-\t\t       /*c_cast_p=*/false, complain);\n+\t\t       /*c_cast_p=*/false, /*nested_p=*/false, complain);\n }\n \n /* ARG is being passed to a varargs function.  Perform any conversions\n@@ -8587,6 +8666,8 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n \t\t    \"implicit conversion from %qH to %qI when passing \"\n \t\t    \"argument to function\",\n \t\t    arg_type, double_type_node);\n+      if (TREE_CODE (arg) == EXCESS_PRECISION_EXPR)\n+\targ = TREE_OPERAND (arg, 0);\n       arg = mark_rvalue_use (arg);\n       arg = convert_to_real_nofold (double_type_node, arg);\n     }\n@@ -8893,9 +8974,9 @@ convert_for_arg_passing (tree type, tree val, tsubst_flags_t complain)\n /* Returns non-zero iff FN is a function with magic varargs, i.e. ones for\n    which just decay_conversion or no conversions at all should be done.\n    This is true for some builtins which don't act like normal functions.\n-   Return 2 if no conversions at all should be done, 1 if just\n-   decay_conversion.  Return 3 for special treatment of the 3rd argument\n-   for __builtin_*_overflow_p.  */\n+   Return 2 if just decay_conversion and removal of excess precision should\n+   be done, 1 if just decay_conversion.  Return 3 for special treatment of\n+   the 3rd argument for __builtin_*_overflow_p.  */\n \n int\n magic_varargs_p (tree fn)\n@@ -8914,7 +8995,15 @@ magic_varargs_p (tree fn)\n       case BUILT_IN_MUL_OVERFLOW_P:\n \treturn 3;\n \n-      default:;\n+      case BUILT_IN_ISFINITE:\n+      case BUILT_IN_ISINF:\n+      case BUILT_IN_ISINF_SIGN:\n+      case BUILT_IN_ISNAN:\n+      case BUILT_IN_ISNORMAL:\n+      case BUILT_IN_FPCLASSIFY:\n+\treturn 2;\n+\n+      default:\n \treturn lookup_attribute (\"type generic\",\n \t\t\t\t TYPE_ATTRIBUTES (TREE_TYPE (fn))) != 0;\n       }\n@@ -9717,16 +9806,21 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   for (; arg_index < vec_safe_length (args); ++arg_index)\n     {\n       tree a = (*args)[arg_index];\n-      if ((magic == 3 && arg_index == 2) || magic == 2)\n+      if (magic == 3 && arg_index == 2)\n \t{\n \t  /* Do no conversions for certain magic varargs.  */\n \t  a = mark_type_use (a);\n \t  if (TREE_CODE (a) == FUNCTION_DECL && reject_gcc_builtin (a))\n \t    return error_mark_node;\n \t}\n       else if (magic != 0)\n-\t/* For other magic varargs only do decay_conversion.  */\n-\ta = decay_conversion (a, complain);\n+\t{\n+\t  /* Don't truncate excess precision to the semantic type.  */\n+\t  if (magic == 1 && TREE_CODE (a) == EXCESS_PRECISION_EXPR)\n+\t    a = TREE_OPERAND (a, 0);\n+\t  /* For other magic varargs only do decay_conversion.  */\n+\t  a = decay_conversion (a, complain);\n+\t}\n       else if (DECL_CONSTRUCTOR_P (fn)\n \t       && same_type_ignoring_top_level_qualifiers_p (DECL_CONTEXT (fn),\n \t\t\t\t\t\t\t     TREE_TYPE (a)))\n@@ -13004,7 +13098,7 @@ perform_direct_initialization_if_possible (tree type,\n   else\n     expr = convert_like (conv, expr, NULL_TREE, 0,\n \t\t\t /*issue_conversion_warnings=*/false,\n-\t\t\t c_cast_p, complain);\n+\t\t\t c_cast_p, /*nested_p=*/false, complain);\n \n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);"}, {"sha": "fb171a2784fed48ee3cc2f3e00ffce15a9505684", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -7598,6 +7598,19 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       }\n       break;\n \n+    case EXCESS_PRECISION_EXPR:\n+      {\n+\ttree oldop = TREE_OPERAND (t, 0);\n+\n+\ttree op = cxx_eval_constant_expression (ctx, oldop,\n+\t\t\t\t\t\tlval,\n+\t\t\t\t\t\tnon_constant_p, overflow_p);\n+\tif (*non_constant_p)\n+\t  return t;\n+\tr = fold_convert (TREE_TYPE (t), op);\n+\tbreak;\n+      }\n+\n     case EMPTY_CLASS_EXPR:\n       /* Handle EMPTY_CLASS_EXPR produced by build_call_a by lowering\n \t it to an appropriate CONSTRUCTOR.  */\n@@ -8898,6 +8911,9 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n                sub-object of such an object;  */\n       return RECUR (TREE_OPERAND (t, 0), rval);\n \n+    case EXCESS_PRECISION_EXPR:\n+      return RECUR (TREE_OPERAND (t, 0), rval);\n+\n     case VAR_DECL:\n       if (DECL_HAS_VALUE_EXPR_P (t))\n \t{"}, {"sha": "2608475897cdd49703055f5de5f6fc9de40bb76e", "filename": "gcc/cp/cp-gimplify.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fcp-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fcp-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.cc?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -2515,6 +2515,11 @@ cp_fold (tree x)\n \n       break;\n \n+    case EXCESS_PRECISION_EXPR:\n+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);\n+      x = fold_convert_loc (EXPR_LOCATION (x), TREE_TYPE (x), op0);\n+      break;\n+\n     case INDIRECT_REF:\n       /* We don't need the decltype(auto) obfuscation anymore.  */\n       if (REF_PARENTHESIZED_P (x))"}, {"sha": "ceaadba33fa52d04b73a1f346f6336ca3efad019", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -6793,6 +6793,8 @@ extern tree ocp_convert\t\t\t\t(tree, tree, int, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree cp_convert\t\t\t\t(tree, tree, tsubst_flags_t);\n extern tree cp_convert_and_check                (tree, tree, tsubst_flags_t);\n+extern tree cp_ep_convert_and_check             (tree, tree, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree cp_fold_convert\t\t\t(tree, tree);\n extern tree cp_get_callee\t\t\t(tree);\n extern tree cp_get_callee_fndecl\t\t(tree);"}, {"sha": "4da04e1cad7b5ebd8cbd38985cb695806021271d", "filename": "gcc/cp/cvt.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.cc?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -684,6 +684,33 @@ cp_convert_and_check (tree type, tree expr, tsubst_flags_t complain)\n   return result;\n }\n \n+/* Similarly, but deal with excess precision.  SEMANTIC_TYPE is the type this\n+   conversion would use without excess precision.  If SEMANTIC_TYPE is NULL,\n+   this function is equivalent to cp_convert_and_check.  This function is\n+   a wrapper that handles conversions that may be different than the usual\n+   ones because of excess precision.  */\n+\n+tree\n+cp_ep_convert_and_check (tree type, tree expr, tree semantic_type,\n+\t\t\t tsubst_flags_t complain)\n+{\n+  if (TREE_TYPE (expr) == type)\n+    return expr;\n+  if (expr == error_mark_node)\n+    return expr;\n+  if (!semantic_type)\n+    return cp_convert_and_check (type, expr, complain);\n+\n+  if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n+      && TREE_TYPE (expr) != semantic_type)\n+    /* For integers, we need to check the real conversion, not\n+       the conversion to the excess precision type.  */\n+    expr = cp_convert_and_check (semantic_type, expr, complain);\n+  /* Result type is the excess precision type, which should be\n+     large enough, so do not check.  */\n+  return cp_convert (type, expr, complain);\n+}\n+\n /* Conversion...\n \n    FLAGS indicates how we should behave.  */"}, {"sha": "9ddfb027ff9ced7c7651b399dfb88104b3ae8ba4", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -5583,7 +5583,9 @@ cp_parser_primary_expression (cp_parser *parser,\n       /* Floating-point literals are only allowed in an integral\n \t constant expression if they are cast to an integral or\n \t enumeration type.  */\n-      if (TREE_CODE (token->u.value) == REAL_CST\n+      if ((TREE_CODE (token->u.value) == REAL_CST\n+\t   || (TREE_CODE (token->u.value) == EXCESS_PRECISION_EXPR\n+\t       && TREE_CODE (TREE_OPERAND (token->u.value, 0)) == REAL_CST))\n \t  && parser->integral_constant_expression_p\n \t  && pedantic)\n \t{"}, {"sha": "e4dca9d4f9dabeeac4cbefb8eb0112a13b8bad66", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -17414,6 +17414,18 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \treturn r;\n       }\n \n+    case EXCESS_PRECISION_EXPR:\n+      {\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\tif (TREE_CODE (op0) == EXCESS_PRECISION_EXPR)\n+\t  {\n+\t    gcc_checking_assert (same_type_p (type, TREE_TYPE (op0)));\n+\t    return op0;\n+\t  }\n+\treturn build1_loc (EXPR_LOCATION (t), code, type, op0);\n+      }\n+\n     case COMPONENT_REF:\n       {\n \ttree object;\n@@ -20442,6 +20454,16 @@ tsubst_copy_and_build (tree t,\n \t\t\t\ttemplated_operator_saved_lookups (t),\n \t\t\t\tcomplain|decltype_flag));\n \n+    case EXCESS_PRECISION_EXPR:\n+      {\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\ttree op0 = RECUR (TREE_OPERAND (t, 0));\n+\tif (TREE_CODE (op0) == EXCESS_PRECISION_EXPR)\n+\t  RETURN (op0);\n+\tRETURN (build1_loc (EXPR_LOCATION (t), EXCESS_PRECISION_EXPR,\n+\t\t\t    type, op0));\n+      }\n+\n     case FIX_TRUNC_EXPR:\n       /* convert_like should have created an IMPLICIT_CONV_EXPR.  */\n       gcc_unreachable ();"}, {"sha": "c3503b69f77c4f2bccb48f13fae5220a3ec4bf5f", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 162, "deletions": 26, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -439,6 +439,8 @@ cp_common_type (tree t1, tree t2)\n       tree subtype\n \t= type_after_usual_arithmetic_conversions (subtype1, subtype2);\n \n+      if (subtype == error_mark_node)\n+\treturn subtype;\n       if (code1 == COMPLEX_TYPE && TREE_TYPE (t1) == subtype)\n \treturn build_type_attribute_variant (t1, attributes);\n       else if (code2 == COMPLEX_TYPE && TREE_TYPE (t2) == subtype)\n@@ -4603,11 +4605,17 @@ convert_arguments (tree typelist, vec<tree, va_gc> **values, tree fndecl,\n \t}\n       else\n \t{\n-\t  if (fndecl && magic_varargs_p (fndecl))\n-\t    /* Don't do ellipsis conversion for __built_in_constant_p\n-\t       as this will result in spurious errors for non-trivial\n-\t       types.  */\n-\t    val = require_complete_type (val, complain);\n+\t  int magic = fndecl ? magic_varargs_p (fndecl) : 0;\n+\t  if (magic)\n+\t    {\n+\t      /* Don't truncate excess precision to the semantic type.  */\n+\t      if (magic == 1 && TREE_CODE (val) == EXCESS_PRECISION_EXPR)\n+\t\tval = TREE_OPERAND (val, 0);\n+\t      /* Don't do ellipsis conversion for __built_in_constant_p\n+\t\t as this will result in spurious errors for non-trivial\n+\t\t types.  */\n+\t      val = require_complete_type (val, complain);\n+\t    }\n \t  else\n \t    val = convert_arg_to_ellipsis (val, complain);\n \n@@ -5057,7 +5065,7 @@ cp_build_binary_op (const op_location_t &location,\n {\n   tree op0, op1;\n   enum tree_code code0, code1;\n-  tree type0, type1;\n+  tree type0, type1, orig_type0, orig_type1;\n   const char *invalid_op_diag;\n \n   /* Expression code to give to the expression when it is built.\n@@ -5069,6 +5077,10 @@ cp_build_binary_op (const op_location_t &location,\n      In the simplest cases this is the common type of the arguments.  */\n   tree result_type = NULL_TREE;\n \n+  /* When the computation is in excess precision, the type of the\n+     final EXCESS_PRECISION_EXPR.  */\n+  tree semantic_result_type = NULL;\n+\n   /* Nonzero means operands have already been type-converted\n      in whatever way is necessary.\n      Zero means they need to be converted to RESULT_TYPE.  */\n@@ -5116,6 +5128,10 @@ cp_build_binary_op (const op_location_t &location,\n   /* Tree holding instrumentation expression.  */\n   tree instrument_expr = NULL_TREE;\n \n+  /* True means this is an arithmetic operation that may need excess\n+     precision.  */\n+  bool may_need_excess_precision;\n+\n   /* Apply default conversions.  */\n   op0 = resolve_nondeduced_context (orig_op0, complain);\n   op1 = resolve_nondeduced_context (orig_op1, complain);\n@@ -5167,8 +5183,8 @@ cp_build_binary_op (const op_location_t &location,\n \t}\n     }\n \n-  type0 = TREE_TYPE (op0); \n-  type1 = TREE_TYPE (op1);\n+  orig_type0 = type0 = TREE_TYPE (op0);\n+  orig_type1 = type1 = TREE_TYPE (op1);\n \n   /* The expression codes of the data types of the arguments tell us\n      whether the arguments are integers, floating, pointers, etc.  */\n@@ -5201,6 +5217,47 @@ cp_build_binary_op (const op_location_t &location,\n       return error_mark_node;\n     }\n \n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+      may_need_excess_precision = true;\n+      break;\n+    default:\n+      may_need_excess_precision = false;\n+      break;\n+    }\n+  if (TREE_CODE (op0) == EXCESS_PRECISION_EXPR)\n+    {\n+      op0 = TREE_OPERAND (op0, 0);\n+      type0 = TREE_TYPE (op0);\n+    }\n+  else if (may_need_excess_precision\n+\t   && (code0 == REAL_TYPE || code0 == COMPLEX_TYPE))\n+    if (tree eptype = excess_precision_type (type0))\n+      {\n+\ttype0 = eptype;\n+\top0 = convert (eptype, op0);\n+      }\n+  if (TREE_CODE (op1) == EXCESS_PRECISION_EXPR)\n+    {\n+      op1 = TREE_OPERAND (op1, 0);\n+      type1 = TREE_TYPE (op1);\n+    }\n+  else if (may_need_excess_precision\n+\t   && (code1 == REAL_TYPE || code1 == COMPLEX_TYPE))\n+    if (tree eptype = excess_precision_type (type1))\n+      {\n+\ttype1 = eptype;\n+\top1 = convert (eptype, op1);\n+      }\n+\n   /* Issue warnings about peculiar, but valid, uses of NULL.  */\n   if ((null_node_p (orig_op0) || null_node_p (orig_op1))\n       /* It's reasonable to use pointer values as operands of &&\n@@ -5240,7 +5297,7 @@ cp_build_binary_op (const op_location_t &location,\n               op0 = convert (TREE_TYPE (type1), op0);\n \t      op0 = save_expr (op0);\n               op0 = build_vector_from_val (type1, op0);\n-              type0 = TREE_TYPE (op0);\n+\t      orig_type0 = type0 = TREE_TYPE (op0);\n               code0 = TREE_CODE (type0);\n               converted = 1;\n               break;\n@@ -5250,7 +5307,7 @@ cp_build_binary_op (const op_location_t &location,\n               op1 = convert (TREE_TYPE (type0), op1);\n \t      op1 = save_expr (op1);\n               op1 = build_vector_from_val (type0, op1);\n-              type1 = TREE_TYPE (op1);\n+\t      orig_type1 = type1 = TREE_TYPE (op1);\n               code1 = TREE_CODE (type1);\n               converted = 1;\n               break;\n@@ -6067,12 +6124,20 @@ cp_build_binary_op (const op_location_t &location,\n       && (shorten || common || short_compare))\n     {\n       result_type = cp_common_type (type0, type1);\n-      if (result_type == error_mark_node\n-\t  && code0 == REAL_TYPE\n-\t  && code1 == REAL_TYPE\n-\t  && (extended_float_type_p (type0) || extended_float_type_p (type1))\n-\t  && cp_compare_floating_point_conversion_ranks (type0, type1) == 3)\n+      if (result_type == error_mark_node)\n \t{\n+\t  tree t1 = type0;\n+\t  tree t2 = type1;\n+\t  if (TREE_CODE (t1) == COMPLEX_TYPE)\n+\t    t1 = TREE_TYPE (t1);\n+\t  if (TREE_CODE (t2) == COMPLEX_TYPE)\n+\t    t2 = TREE_TYPE (t2);\n+\t  gcc_checking_assert (TREE_CODE (t1) == REAL_TYPE\n+\t\t\t       && TREE_CODE (t2) == REAL_TYPE\n+\t\t\t       && (extended_float_type_p (t1)\n+\t\t\t\t   || extended_float_type_p (t2))\n+\t\t\t       && cp_compare_floating_point_conversion_ranks\n+\t\t\t\t    (t1, t2) == 3);\n \t  if (complain & tf_error)\n \t    {\n \t      rich_location richloc (line_table, location);\n@@ -6091,6 +6156,33 @@ cp_build_binary_op (const op_location_t &location,\n \t\t\t\t    TREE_TYPE (orig_op1));\n \t}\n     }\n+  if (may_need_excess_precision\n+      && (orig_type0 != type0 || orig_type1 != type1))\n+    {\n+      gcc_assert (common);\n+      semantic_result_type = cp_common_type (orig_type0, orig_type1);\n+      if (semantic_result_type == error_mark_node)\n+\t{\n+\t  tree t1 = orig_type0;\n+\t  tree t2 = orig_type1;\n+\t  if (TREE_CODE (t1) == COMPLEX_TYPE)\n+\t    t1 = TREE_TYPE (t1);\n+\t  if (TREE_CODE (t2) == COMPLEX_TYPE)\n+\t    t2 = TREE_TYPE (t2);\n+\t  gcc_checking_assert (TREE_CODE (t1) == REAL_TYPE\n+\t\t\t       && TREE_CODE (t2) == REAL_TYPE\n+\t\t\t       && (extended_float_type_p (t1)\n+\t\t\t\t   || extended_float_type_p (t2))\n+\t\t\t       && cp_compare_floating_point_conversion_ranks\n+\t\t\t\t    (t1, t2) == 3);\n+\t  if (complain & tf_error)\n+\t    {\n+\t      rich_location richloc (line_table, location);\n+\t      binary_op_error (&richloc, code, type0, type1);\n+\t    }\n+\t  return error_mark_node;\n+\t}\n+    }\n \n   if (code == SPACESHIP_EXPR)\n     {\n@@ -6181,6 +6273,8 @@ cp_build_binary_op (const op_location_t &location,\n \t\t\t build_type ? build_type : result_type,\n \t\t\t NULL_TREE, op1);\n       TREE_OPERAND (tmp, 0) = op0;\n+      if (semantic_result_type)\n+\ttmp = build1 (EXCESS_PRECISION_EXPR, semantic_result_type, tmp);\n       return tmp;\n     }\n \n@@ -6268,6 +6362,9 @@ cp_build_binary_op (const op_location_t &location,\n \t\t}\n \t    }\n \t  result = build2 (COMPLEX_EXPR, result_type, real, imag);\n+\t  if (semantic_result_type)\n+\t    result = build1 (EXCESS_PRECISION_EXPR, semantic_result_type,\n+\t\t\t     result);\n \t  return result;\n \t}\n \n@@ -6363,9 +6460,11 @@ cp_build_binary_op (const op_location_t &location,\n     {\n       warning_sentinel w (warn_sign_conversion, short_compare);\n       if (!same_type_p (TREE_TYPE (op0), result_type))\n-\top0 = cp_convert_and_check (result_type, op0, complain);\n+\top0 = cp_ep_convert_and_check (result_type, op0,\n+\t\t\t\t       semantic_result_type, complain);\n       if (!same_type_p (TREE_TYPE (op1), result_type))\n-\top1 = cp_convert_and_check (result_type, op1, complain);\n+\top1 = cp_ep_convert_and_check (result_type, op1,\n+\t\t\t\t       semantic_result_type, complain);\n \n       if (op0 == error_mark_node || op1 == error_mark_node)\n \treturn error_mark_node;\n@@ -6435,6 +6534,9 @@ cp_build_binary_op (const op_location_t &location,\n   if (resultcode == SPACESHIP_EXPR && !processing_template_decl)\n     result = get_target_expr (result, complain);\n \n+  if (semantic_result_type)\n+    result = build1 (EXCESS_PRECISION_EXPR, semantic_result_type, result);\n+\n   if (!c_inhibit_evaluation_warnings)\n     {\n       if (!processing_template_decl)\n@@ -7161,6 +7263,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n   tree arg = xarg;\n   location_t location = cp_expr_loc_or_input_loc (arg);\n   tree argtype = 0;\n+  tree eptype = NULL_TREE;\n   const char *errstring = NULL;\n   tree val;\n   const char *invalid_op_diag;\n@@ -7181,6 +7284,12 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n       return error_mark_node;\n     }\n \n+  if (TREE_CODE (arg) == EXCESS_PRECISION_EXPR)\n+    {\n+      eptype = TREE_TYPE (arg);\n+      arg = TREE_OPERAND (arg, 0);\n+    }\n+\n   switch (code)\n     {\n     case UNARY_PLUS_EXPR:\n@@ -7276,8 +7385,11 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      arg = build_real_imag_expr (input_location, code, arg);\n-      return arg;\n+      val = build_real_imag_expr (input_location, code, arg);\n+      if (eptype && TREE_CODE (eptype) == COMPLEX_EXPR)\n+\tval = build1_loc (input_location, EXCESS_PRECISION_EXPR,\n+\t\t\t  TREE_TYPE (eptype), val);\n+      return val;\n \n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n@@ -7288,7 +7400,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n \n       val = unary_complex_lvalue (code, arg);\n       if (val != 0)\n-\treturn val;\n+\tgoto return_build_unary_op;\n \n       arg = mark_lvalue_use (arg);\n \n@@ -7304,8 +7416,8 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n \t  real = cp_build_unary_op (code, real, true, complain);\n \t  if (real == error_mark_node || imag == error_mark_node)\n \t    return error_mark_node;\n-\t  return build2 (COMPLEX_EXPR, TREE_TYPE (arg),\n-\t\t\t real, imag);\n+\t  val = build2 (COMPLEX_EXPR, TREE_TYPE (arg), real, imag);\n+\t  goto return_build_unary_op;\n \t}\n \n       /* Report invalid types.  */\n@@ -7468,7 +7580,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n \t  val = build2 (code, TREE_TYPE (arg), arg, inc);\n \n \tTREE_SIDE_EFFECTS (val) = 1;\n-\treturn val;\n+\tgoto return_build_unary_op;\n       }\n \n     case ADDR_EXPR:\n@@ -7484,7 +7596,11 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n     {\n       if (argtype == 0)\n \targtype = TREE_TYPE (arg);\n-      return build1 (code, argtype, arg);\n+      val = build1 (code, argtype, arg);\n+    return_build_unary_op:\n+      if (eptype)\n+\tval = build1 (EXCESS_PRECISION_EXPR, eptype, val);\n+      return val;\n     }\n \n   if (complain & tf_error)\n@@ -7875,6 +7991,15 @@ cp_build_compound_expr (tree lhs, tree rhs, tsubst_flags_t complain)\n   if (lhs == error_mark_node || rhs == error_mark_node)\n     return error_mark_node;\n \n+  if (TREE_CODE (lhs) == EXCESS_PRECISION_EXPR)\n+    lhs = TREE_OPERAND (lhs, 0);\n+  tree eptype = NULL_TREE;\n+  if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n+    {\n+      eptype = TREE_TYPE (rhs);\n+      rhs = TREE_OPERAND (rhs, 0);\n+    }\n+\n   if (TREE_CODE (rhs) == TARGET_EXPR)\n     {\n       /* If the rhs is a TARGET_EXPR, then build the compound\n@@ -7885,6 +8010,8 @@ cp_build_compound_expr (tree lhs, tree rhs, tsubst_flags_t complain)\n       init = build2 (COMPOUND_EXPR, TREE_TYPE (init), lhs, init);\n       TREE_OPERAND (rhs, 1) = init;\n \n+      if (eptype)\n+\trhs = build1 (EXCESS_PRECISION_EXPR, eptype, rhs);\n       return rhs;\n     }\n \n@@ -7896,7 +8023,10 @@ cp_build_compound_expr (tree lhs, tree rhs, tsubst_flags_t complain)\n       return error_mark_node;\n     }\n   \n-  return build2 (COMPOUND_EXPR, TREE_TYPE (rhs), lhs, rhs);\n+  tree ret = build2 (COMPOUND_EXPR, TREE_TYPE (rhs), lhs, rhs);\n+  if (eptype)\n+    ret = build1 (EXCESS_PRECISION_EXPR, eptype, ret);\n+  return ret;\n }\n \n /* Issue a diagnostic message if casting from SRC_TYPE to DEST_TYPE\n@@ -8180,7 +8310,11 @@ build_static_cast_1 (location_t loc, tree type, tree expr, bool c_cast_p,\n \n      Any expression can be explicitly converted to type cv void.  */\n   if (VOID_TYPE_P (type))\n-    return convert_to_void (expr, ICV_CAST, complain);\n+    {\n+      if (TREE_CODE (expr) == EXCESS_PRECISION_EXPR)\n+\texpr = TREE_OPERAND (expr, 0);\n+      return convert_to_void (expr, ICV_CAST, complain);\n+    }\n \n   /* [class.abstract]\n      An abstract class shall not be used ... as the type of an explicit\n@@ -8259,6 +8393,8 @@ build_static_cast_1 (location_t loc, tree type, tree expr, bool c_cast_p,\n     {\n       if (processing_template_decl)\n \treturn expr;\n+      if (TREE_CODE (expr) == EXCESS_PRECISION_EXPR)\n+\texpr = TREE_OPERAND (expr, 0);\n       return ocp_convert (type, expr, CONV_C_CAST, LOOKUP_NORMAL, complain);\n     }\n "}, {"sha": "c176e2dc646761e25d7e430daa57b648cf88e5ba", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -13785,18 +13785,18 @@ default, @option{-fexcess-precision=fast} is in effect; this means that\n operations may be carried out in a wider precision than the types specified\n in the source if that would result in faster code, and it is unpredictable\n when rounding to the types specified in the source code takes place.\n-When compiling C, if @option{-fexcess-precision=standard} is specified then\n-excess precision follows the rules specified in ISO C99; in particular,\n+When compiling C or C++, if @option{-fexcess-precision=standard} is specified\n+then excess precision follows the rules specified in ISO C99 or C++; in particular,\n both casts and assignments cause values to be rounded to their\n semantic types (whereas @option{-ffloat-store} only affects\n-assignments).  This option is enabled by default for C if a strict\n-conformance option such as @option{-std=c99} is used.\n+assignments).  This option is enabled by default for C or C++ if a strict\n+conformance option such as @option{-std=c99} or @option{-std=c++17} is used.\n @option{-ffast-math} enables @option{-fexcess-precision=fast} by default\n regardless of whether a strict conformance option is used.\n \n @opindex mfpmath\n @option{-fexcess-precision=standard} is not implemented for languages\n-other than C.  On the x86, it has no effect if @option{-mfpmath=sse}\n+other than C or C++.  On the x86, it has no effect if @option{-mfpmath=sse}\n or @option{-mfpmath=sse+387} is specified; in the former case, IEEE\n semantics apply without excess precision, and in the latter, rounding\n is unpredictable."}, {"sha": "4bc2189f53ca2afd60a415bef1ca2bf929512906", "filename": "gcc/testsuite/c-c++-common/dfp/compare-eq-const.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fcompare-eq-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fcompare-eq-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fcompare-eq-const.c?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -1,5 +1,6 @@\n /* C99 6.5.9 Equality operators.\n    Compare decimal float constants against each other. */\n+/* { dg-additional-options \"-fexcess-precision=fast\" } */\n \n #include \"dfp-dbg.h\"\n "}, {"sha": "2cce3e6a4e72f618269774c1379d15cbcfd41a83", "filename": "gcc/testsuite/c-c++-common/dfp/convert-bfp-10.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fconvert-bfp-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fconvert-bfp-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fconvert-bfp-10.c?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -1,4 +1,5 @@\n /* This test assumes IEEE float and double.  */\n+/* { dg-additional-options \"-fexcess-precision=fast\" } */\n \n #include \"convert.h\"\n "}, {"sha": "c5acc4a789abd6307dc7446199ff84daa7128eb8", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi-union1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-union1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-union1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-union1.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -18,8 +18,8 @@ int main()\n {\n   Test t;\n   B b;\n-  B b2(4.2);\n+  B b2(4.25);\n \n-  if (t.a != 4 || b.i != 42 || b2.d != 4.2)\n+  if (t.a != 4 || b.i != 42 || b2.d != 4.25)\n     __builtin_abort();\n }"}, {"sha": "5164598439b3c169fd55b89f89ca20136fe913c5", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-tuple.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-tuple.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-tuple.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-tuple.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -1,4 +1,5 @@\n // { dg-do run { target c++11 } }\n+// { dg-additional-options \"-fexcess-precision=fast\" }\n // An implementation of TR1's <tuple> using variadic teplates\n // Contributed by Douglas Gregor <doug.gregor@gmail.com>\n "}, {"sha": "64d613ee5a7f9880b7eb15d466aec9739f2ae33d", "filename": "gcc/testsuite/g++.dg/cpp1y/pr68180.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr68180.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr68180.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr68180.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -1,6 +1,6 @@\n // PR c++/68180\n // { dg-do compile { target c++14 } }\n-// { dg-additional-options \"-Wno-psabi\" }\n+// { dg-additional-options \"-Wno-psabi -fexcess-precision=fast\" }\n \n typedef float __attribute__( ( vector_size( 16 ) ) ) float32x4_t;\n constexpr float32x4_t fill(float x) {"}, {"sha": "daefca94a63ac0429068e44fa1a4f1d504ef13f7", "filename": "gcc/testsuite/g++.dg/cpp1z/constexpr-96862.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-96862.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-96862.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-96862.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -1,6 +1,6 @@\n // PR c++/96862\n // { dg-do compile { target c++17 } }\n-// { dg-additional-options \"-frounding-math\" }\n+// { dg-additional-options \"-frounding-math -fexcess-precision=fast\" }\n \n constexpr double a = 0x1.0p+100 + 0x1.0p-100;\n const double b = 0x1.0p+100 + 0x1.0p-100;"}, {"sha": "a65aaf903a2d031a232974129726483b4668488e", "filename": "gcc/testsuite/g++.dg/cpp1z/decomp12.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fdecomp12.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -7,13 +7,13 @@ template <typename, typename> struct same_type;\n template <typename T> struct same_type<T, T> {};\n \n int main() {\n-  std::tuple tuple = { 1, 'a', 2.3, true };\n+  std::tuple tuple = { 1, 'a', 2.25, true };\n   auto[i, c, d, b] = tuple;\n   same_type<std::tuple_element<0, decltype(tuple)>::type, decltype(i)>{};\n   same_type<decltype(i), int>{};\n   same_type<decltype(c), char>{};\n   same_type<decltype(d), double>{};\n   same_type<decltype(b), bool>{};\n-  if (i != 1 || c != 'a' || d != 2.3 || b != true)\n+  if (i != 1 || c != 'a' || d != 2.25 || b != true)\n     __builtin_abort ();\n }"}, {"sha": "77581116291b68ab7bd1a041328fbc3107f03c0e", "filename": "gcc/testsuite/g++.dg/other/thunk1.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fthunk1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fthunk1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fthunk1.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -1,5 +1,6 @@\n // PR c++/12007 Multiple inheritance float pass by value fails\n // { dg-do run }\n+// { dg-additional-options \"-fexcess-precision=fast\" }\n \n extern \"C\" void abort (void);\n "}, {"sha": "ad4b085b5e050e884a5352dbee09438d44f7443a", "filename": "gcc/testsuite/g++.dg/vect/pr64410.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr64410.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr64410.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr64410.cc?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -1,5 +1,6 @@\n // { dg-do compile }\n // { dg-require-effective-target vect_double }\n+// { dg-additional-options \"-fexcess-precision=fast\" }\n \n #include <vector>\n #include <complex>"}, {"sha": "f5a071fb9e829709f791e667b6691cbb8a6297ad", "filename": "gcc/testsuite/g++.dg/vect/pr89653.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr89653.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr89653.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr89653.cc?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -1,5 +1,6 @@\n // { dg-do compile }\n // { dg-require-effective-target vect_double }\n+// { dg-additional-options \"-fexcess-precision=fast\" }\n \n #include <algorithm>\n "}, {"sha": "79339c13de9d7afd679f0179ae60ea7f30b8a1a8", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/copy9.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcopy9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcopy9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcopy9.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -1,4 +1,5 @@\n // { dg-do run  }\n+// { dg-additional-options \"-fexcess-precision=fast\" }\n // GROUPS passed copy-ctors\n #include <iostream>\n "}, {"sha": "08f220c644703306deed719324dc9db0887dcb34", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/overload7.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Foverload7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Foverload7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Foverload7.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -1,4 +1,5 @@\n // { dg-do run  }\n+// { dg-additional-options \"-fexcess-precision=fast\" }\n // GROUPS passed overloading\n extern \"C\" int printf (const char *, ...);\n "}, {"sha": "0519d6305421f7ffc190ddca40cac88b2b9ac899", "filename": "gcc/testsuite/g++.target/i386/excess-precision-1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-1.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -0,0 +1,6 @@\n+// Excess precision tests.  Test that excess precision is carried\n+// through various operations.\n+// { dg-do run }\n+// { dg-options \"-O2 -mfpmath=387 -fexcess-precision=standard\" }\n+\n+#include \"../../gcc.target/i386/excess-precision-1.c\""}, {"sha": "119b6667f291b5794b156cce0cf5b993fe8c0ceb", "filename": "gcc/testsuite/g++.target/i386/excess-precision-11.C", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-11.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -0,0 +1,105 @@\n+// Excess precision tests.  Test excess precision is removed when\n+// necessary.\n+// { dg-do run }\n+// { dg-options \"-O2 -mfpmath=387 -fexcess-precision=standard\" }\n+\n+#include <float.h>\n+#include <stdarg.h>\n+\n+extern \"C\" void abort ();\n+\n+volatile float f1 = 1.0f;\n+volatile float f2 = 0x1.0p-30f;\n+volatile float f3 = 0x1.0p-60f;\n+volatile double d1 = 1.0;\n+volatile double d2 = 0x1.0p-30;\n+volatile double d3 = 0x1.0p-60;\n+volatile double d3d = 0x1.0p-52;\n+volatile float fadd1 = 1.0f + 0x1.0p-30f;\n+volatile double dadd2 = 1.0 + 0x1.0p-30 + 0x1.0p-60;\n+volatile double dh = 0x1.0p-24;\n+volatile float fha = 1.0f + 0x1.0p-23f;\n+\n+static inline void\n+check_float (float f)\n+{\n+  if (f != fadd1)\n+    abort ();\n+}\n+\n+static inline void\n+check_float (double)\n+{\n+  abort ();\n+}\n+\n+static inline void\n+check_float (long double)\n+{\n+  abort ();\n+}\n+\n+static inline void\n+check_double (double d)\n+{\n+  if (d != dadd2)\n+    abort ();\n+}\n+\n+static inline void\n+check_double (long double)\n+{\n+  abort ();\n+}\n+\n+static inline void\n+check_float2 (float f)\n+{\n+  if (f != fha)\n+    abort ();\n+}\n+\n+struct S {\n+  S () {}\n+  S (float f) { if (f != fadd1) abort (); }\n+};\n+\n+struct T {\n+  T () {}\n+  T (double d) { if (d != dadd2) abort (); }\n+};\n+\n+static inline void\n+check_float3 (S)\n+{\n+}\n+\n+static inline void\n+check_double2 (T)\n+{\n+}\n+\n+void\n+test_call ()\n+{\n+  check_float (f1 + f2);\n+  check_double (f1 + f2);\n+  check_double (d1 + d2 + d3);\n+  /* Verify rounding direct to float without double rounding.  */\n+  if (sizeof (long double) > sizeof (double))\n+    check_float2 (d1 + dh + d3);\n+  else\n+    check_float2 (d1 + dh + d3d);\n+  check_float3 (f1 + f2);\n+  check_double2 (f1 + f2);\n+  check_double2 (d1 + d2 + d3);\n+  S s1 = static_cast<S> (f1 + f2);\n+  T t2 = static_cast<T> (f1 + f2);\n+  T t3 = static_cast<T> (d1 + d2 + d3);\n+}\n+\n+int\n+main ()\n+{\n+  test_call ();\n+}"}, {"sha": "afb21976589c7c21b369481da8f5a865c9d0dbc7", "filename": "gcc/testsuite/g++.target/i386/excess-precision-2.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-2.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -0,0 +1,5 @@\n+// Excess precision tests.  Test excess precision of constants.\n+// { dg-do run }\n+// { dg-options \"-O2 -mfpmath=387 -fexcess-precision=standard\" }\n+\n+#include \"../../gcc.target/i386/excess-precision-2.c\""}, {"sha": "be8cc423019fe3b2a2916f5d1a0b2917dd2e8c07", "filename": "gcc/testsuite/g++.target/i386/excess-precision-3.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-3.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -0,0 +1,6 @@\n+// Excess precision tests.  Test excess precision is removed when\n+// necessary.\n+// { dg-do run }\n+// { dg-options \"-O2 -mfpmath=387 -fexcess-precision=standard\" }\n+\n+#include \"../../gcc.target/i386/excess-precision-3.c\""}, {"sha": "30606b1d65568597270bc678145721c744fdd307", "filename": "gcc/testsuite/g++.target/i386/excess-precision-4.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-4.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -0,0 +1,7 @@\n+// Excess precision tests.  Test diagnostics for excess precision of\n+// constants.\n+// { dg-do compile }\n+// { dg-options \"-mfpmath=387 -fexcess-precision=standard\" }\n+\n+float f = 0.0f * 1e50f; // { dg-warning \"floating constant exceeds range of 'float'\" }\n+double d = 0.0 * 1e400; // { dg-warning \"floating constant exceeds range of 'double'\" }"}, {"sha": "fa15753e45111833d92cb415c1c8b27c4ca873ef", "filename": "gcc/testsuite/g++.target/i386/excess-precision-5.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-5.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -0,0 +1,32 @@\n+// Excess precision tests.  Verify excess precision doesn't affect\n+// actual types.\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-mfpmath=387 -fexcess-precision=standard\" }\n+\n+namespace std {\n+  template<typename T, T v> struct integral_constant {\n+    static constexpr T value = v;\n+  };\n+  typedef integral_constant<bool, false> false_type;\n+  typedef integral_constant<bool, true> true_type;\n+  template<class T, class U>\n+  struct is_same : std::false_type {};\n+  template <class T>\n+  struct is_same<T, T> : std::true_type {};\n+}\n+\n+float f;\n+double d;\n+\n+void\n+test_types (void)\n+{\n+#define CHECK_FLOAT(E) static_assert (std::is_same <float, decltype (E)>::value, \"\")\n+#define CHECK_DOUBLE(E) static_assert (std::is_same <double, decltype (E)>::value, \"\")\n+  CHECK_FLOAT (f + f);\n+  CHECK_DOUBLE (d + d);\n+  CHECK_FLOAT (f * f / f);\n+  CHECK_DOUBLE (d * d / d);\n+  CHECK_FLOAT (f ? f - f : f);\n+  CHECK_DOUBLE (d ? d - d : d);\n+}"}, {"sha": "06e9a93058b631b4a66434e10b589322c1718fbb", "filename": "gcc/testsuite/g++.target/i386/excess-precision-6.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-6.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -0,0 +1,19 @@\n+// Excess precision tests.  Make sure sqrt is not inlined for float or\n+// double.\n+// { dg-do compile }\n+// { dg-options \"-mfpmath=387 -O2 -fno-math-errno -fexcess-precision=standard\" }\n+\n+float f;\n+double d;\n+\n+float fr;\n+double dr;\n+\n+void\n+test_builtins (void)\n+{\n+  fr = __builtin_sqrtf (f);\n+  dr = __builtin_sqrt (d);\n+}\n+\n+// { dg-final { scan-assembler-not \"fsqrt\" } }"}, {"sha": "5df0d9d8c1f7bce1b0dedc6716dd79daab1b83dc", "filename": "gcc/testsuite/g++.target/i386/excess-precision-7.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-7.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -0,0 +1,7 @@\n+// Excess precision tests.  Test C99 semantics for conversions from\n+// integers to floating point: no excess precision for either explicit\n+// or implicit conversions.\n+// { dg-do run }\n+// { dg-options \"-mfpmath=387 -fexcess-precision=standard\" }\n+\n+#include \"../../gcc.target/i386/excess-precision-7.c\""}, {"sha": "1fcadb94c1f6eb9541c199c198cf516b693ad003", "filename": "gcc/testsuite/g++.target/i386/excess-precision-9.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fexcess-precision-9.C?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -0,0 +1,6 @@\n+// Excess precision tests.  Test implicit conversions in comparisons:\n+// no excess precision in C++.\n+// { dg-do run }\n+// { dg-options \"-mfpmath=387 -fexcess-precision=standard\" }\n+\n+#include \"../../gcc.target/i386/excess-precision-9.c\""}, {"sha": "388cee72c13d28e08eb07654baf11c01c611ed2b", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-1.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-1.c?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -5,8 +5,14 @@\n \n #include <float.h>\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n extern void abort (void);\n extern void exit (int);\n+#ifdef __cplusplus\n+}\n+#endif\n \n volatile float f1 = 1.0f;\n volatile float f2 = 0x1.0p-30f;"}, {"sha": "c14784e0af9b4df3d95311115a0757acf00a8b7a", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-2.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-2.c?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -4,8 +4,14 @@\n \n #include <float.h>\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n extern void abort (void);\n extern void exit (int);\n+#ifdef __cplusplus\n+}\n+#endif\n \n volatile long double ldadd1 = 1.0l + 0x1.0p-30l;\n volatile long double ld11f = 1.1f;"}, {"sha": "e8e9abc69571e91f0cd00a2de8732c6029219e40", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-3.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-3.c?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -6,8 +6,14 @@\n #include <float.h>\n #include <stdarg.h>\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n extern void abort (void);\n extern void exit (int);\n+#ifdef __cplusplus\n+}\n+#endif\n \n volatile float f1 = 1.0f;\n volatile float f2 = 0x1.0p-30f;\n@@ -100,6 +106,7 @@ check_double (double d)\n     abort ();\n }\n \n+#ifndef __cplusplus\n static inline void\n check_float_nonproto (f)\n      float f;\n@@ -115,6 +122,7 @@ check_double_nonproto (d)\n   if (d != dadd2)\n     abort ();\n }\n+#endif\n \n static void\n check_double_va (int i, ...)\n@@ -132,9 +140,11 @@ test_call (void)\n   check_float (f1 + f2);\n   check_double (d1 + d2 + d3);\n   check_double (f1 + f2 + f3);\n+#ifndef __cplusplus\n   check_float_nonproto (f1 + f2);\n   check_double_nonproto (d1 + d2 + d3);\n   check_double_nonproto (f1 + f2 + f3);\n+#endif\n   check_double_va (0, d1 + d2 + d3);\n   check_double_va (0, f1 + f2 + f3);\n }"}, {"sha": "4c3b950f1059461c94e7f31e2e3608035fcf31b7", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-7.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-7.c?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -4,8 +4,14 @@\n /* { dg-do run } */\n /* { dg-options \"-std=c99 -mfpmath=387 -fexcess-precision=standard\" } */\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n extern void abort (void);\n extern void exit (int);\n+#ifdef __cplusplus\n+}\n+#endif\n \n int\n main (void)"}, {"sha": "5008164261503f9ac9c0f8d3fb665a6165d6bab0", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-9.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e341130f87984af07c884fea773c0bb3cc8821/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-9.c?ref=98e341130f87984af07c884fea773c0bb3cc8821", "patch": "@@ -3,8 +3,14 @@\n /* { dg-do run } */\n /* { dg-options \"-std=c99 -mfpmath=387 -fexcess-precision=standard\" } */\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n extern void abort (void);\n extern void exit (int);\n+#ifdef __cplusplus\n+}\n+#endif\n \n int\n main (void)"}]}