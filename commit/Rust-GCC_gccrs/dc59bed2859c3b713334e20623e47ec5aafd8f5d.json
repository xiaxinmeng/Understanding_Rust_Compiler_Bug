{"sha": "dc59bed2859c3b713334e20623e47ec5aafd8f5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM1OWJlZDI4NTljM2I3MTMzMzRlMjA2MjNlNDdlYzVhYWZkOGY1ZA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-05-24T13:06:05Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-24T13:06:05Z"}, "message": "[Ada] Spurious error due to lingering limited view\n\nThis patch modifies the mechanism which manages [private] with clauses to\nuninstall a limited with clause if a non-limited with clause is given for\nthe same package.\n\nThe management of with clauses already prevents the installation of a limited\nwith clause if the related package is already withed though a non-limited with\nclause. The timing of parent unit with clause processing is such that the non-\nlimited clauses of the child unit are first installed, followed by the clauses\nof the parent. This order prevents a limited with clause from \"overriding\" a\nnon-limited with clause.\n\nPrivate with clauses however break this model because they are processed when\nthe private part of a package is entered. Since private with clauses are non-\nlimited with clauses, they must \"override\" the effects of any limited clauses\nwhich import the same packages. This effect is now correctly achieved by\nuninstalling the limited with clauses when private with clauses are activated.\n\n------------\n-- Source --\n------------\n\n--  server.ads\n\npackage Server is\n   type Root is tagged private;\nprivate\n   type Root is tagged null record;\nend Server;\n\n--  parent.ads\n\nlimited with Server;\n\npackage Parent is end Parent;\n\n--  parent-client.ads\n\nprivate with Server;\n\npackage Parent.Client is\n   type Deriv is tagged private;\nprivate\n   type Deriv is new Server.Root with null record;\nend Parent.Client;\n\n-----------------\n-- Compilation --\n-----------------\n\n$ gcc -c parent-client.ads\n\n2018-05-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch10.adb (Expand_Limited_With_Clause): Update the call to\n\tInstall_Limited_Withed_Unit.\n\t(Expand_With_Clause): Update the call to Install_Withed_Unit.\n\t(Implicit_With_On_Parent): Update the call to Install_Withed_Unit.\n\t(Install_Context_Clauses): Update the call to Install_Withed_Unit.\n\t(Install_Limited_Context_Clauses): Update the calls to\n\t Install_Limited_Withed_Unit.\n\t(Install_Limited_Withed_Unit): Renamed to better illustrate its\n\tpurpose.\n\t(Install_Private_With_Clauses): Update the calls to Install_Withed_Unit\n\tand Install_Limited_Withed_Unit.\n\t(Install_With_Clause): Uninstall a limited with clause if a [private]\n\twith clause is given for the same package.\n\t(Install_Withed_Unit): Renamed to better illustrate its purpose.\n\t(Remove_Limited_With_Unit): New routine.\n\nFrom-SVN: r260660", "tree": {"sha": "cc48b3130b914979bcc18f1c1005dac30ac11612", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc48b3130b914979bcc18f1c1005dac30ac11612"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc59bed2859c3b713334e20623e47ec5aafd8f5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc59bed2859c3b713334e20623e47ec5aafd8f5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc59bed2859c3b713334e20623e47ec5aafd8f5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc59bed2859c3b713334e20623e47ec5aafd8f5d/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e"}], "stats": {"total": 455, "additions": 306, "deletions": 149}, "files": [{"sha": "30f5cd6f933aeb9b1227d74e112688c4225f8fc3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc59bed2859c3b713334e20623e47ec5aafd8f5d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc59bed2859c3b713334e20623e47ec5aafd8f5d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dc59bed2859c3b713334e20623e47ec5aafd8f5d", "patch": "@@ -1,3 +1,21 @@\n+2018-05-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch10.adb (Expand_Limited_With_Clause): Update the call to\n+\tInstall_Limited_Withed_Unit.\n+\t(Expand_With_Clause): Update the call to Install_Withed_Unit.\n+\t(Implicit_With_On_Parent): Update the call to Install_Withed_Unit.\n+\t(Install_Context_Clauses): Update the call to Install_Withed_Unit.\n+\t(Install_Limited_Context_Clauses): Update the calls to\n+\t Install_Limited_Withed_Unit.\n+\t(Install_Limited_Withed_Unit): Renamed to better illustrate its\n+\tpurpose.\n+\t(Install_Private_With_Clauses): Update the calls to Install_Withed_Unit\n+\tand Install_Limited_Withed_Unit.\n+\t(Install_With_Clause): Uninstall a limited with clause if a [private]\n+\twith clause is given for the same package.\n+\t(Install_Withed_Unit): Renamed to better illustrate its purpose.\n+\t(Remove_Limited_With_Unit): New routine.\n+\n 2018-05-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* raise-gcc.c (__gnat_SEH_error_handler): Remove prototype."}, {"sha": "357fbde27b159dbbc754ce673ec60c6e546a554f", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 288, "deletions": 149, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc59bed2859c3b713334e20623e47ec5aafd8f5d/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc59bed2859c3b713334e20623e47ec5aafd8f5d/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=dc59bed2859c3b713334e20623e47ec5aafd8f5d", "patch": "@@ -150,19 +150,10 @@ package body Sem_Ch10 is\n    --  Subsidiary to Install_Context. Process only limited with_clauses for\n    --  current unit. Implements Ada 2005 (AI-50217).\n \n-   procedure Install_Limited_Withed_Unit (N : Node_Id);\n+   procedure Install_Limited_With_Clause (N : Node_Id);\n    --  Place shadow entities for a limited_with package in the visibility\n    --  structures for the current compilation. Implements Ada 2005 (AI-50217).\n \n-   procedure Install_Withed_Unit\n-     (With_Clause     : Node_Id;\n-      Private_With_OK : Boolean := False);\n-   --  If the unit is not a child unit, make unit immediately visible. The\n-   --  caller ensures that the unit is not already currently installed. The\n-   --  flag Private_With_OK is set true in Install_Private_With_Clauses, which\n-   --  is called when compiling the private part of a package, or installing\n-   --  the private declarations of a parent unit.\n-\n    procedure Install_Parents\n      (Lib_Unit   : Node_Id;\n       Is_Private : Boolean;\n@@ -185,6 +176,15 @@ package body Sem_Ch10 is\n    --  an enclosing scope. Iterate over context to find child units of U_Name\n    --  or of some ancestor of it.\n \n+   procedure Install_With_Clause\n+     (With_Clause     : Node_Id;\n+      Private_With_OK : Boolean := False);\n+   --  If the unit is not a child unit, make unit immediately visible. The\n+   --  caller ensures that the unit is not already currently installed. The\n+   --  flag Private_With_OK is set true in Install_Private_With_Clauses, which\n+   --  is called when compiling the private part of a package, or installing\n+   --  the private declarations of a parent unit.\n+\n    function Is_Ancestor_Unit (U1 : Node_Id; U2 : Node_Id) return Boolean;\n    --  When compiling a unit Q descended from some parent unit P, a limited\n    --  with_clause in the context of P that names some other ancestor of Q\n@@ -204,8 +204,15 @@ package body Sem_Ch10 is\n    --  Subsidiary of previous one. Remove use_ and with_clauses\n \n    procedure Remove_Limited_With_Clause (N : Node_Id);\n-   --  Remove from visibility the shadow entities introduced for a package\n-   --  mentioned in a limited_with clause. Implements Ada 2005 (AI-50217).\n+   --  Remove the shadow entities from visibility introduced for a package\n+   --  mentioned in limited with clause N. Implements Ada 2005 (AI-50217).\n+\n+   procedure Remove_Limited_With_Unit\n+     (Pack_Decl  : Node_Id;\n+      Lim_Clause : Node_Id := Empty);\n+   --  Remove the shadow entities from visibility introduced for a package\n+   --  denoted by declaration Pack_Decl. Lim_Clause is the related limited\n+   --  with clause, if any. Implements Ada 2005 (AI-50217).\n \n    procedure Remove_Parents (Lib_Unit : Node_Id);\n    --  Remove_Parents checks if Lib_Unit is a child spec. If so then the parent\n@@ -248,7 +255,7 @@ package body Sem_Ch10 is\n    --  of the package. Links between corresponding entities in both chains\n    --  allow the compiler to select the proper view of a given type, depending\n    --  on the context. Note that in contrast with the handling of private\n-   --  types, the limited view and the non-limited view of a type are treated\n+   --  types, the limited view and the nonlimited view of a type are treated\n    --  as separate entities, and no entity exchange needs to take place, which\n    --  makes the implementation much simpler than could be feared.\n \n@@ -1387,7 +1394,7 @@ package body Sem_Ch10 is\n \n       --  Loop through actual context items. This is done in two passes:\n \n-      --  a) The first pass analyzes non-limited with-clauses and also any\n+      --  a) The first pass analyzes nonlimited with clauses and also any\n       --     configuration pragmas (we need to get the latter analyzed right\n       --     away, since they can affect processing of subsequent items).\n \n@@ -3182,7 +3189,8 @@ package body Sem_Ch10 is\n \n       Prepend (Withn, Context_Items (N));\n       Mark_Rewrite_Insertion (Withn);\n-      Install_Withed_Unit (Withn);\n+\n+      Install_With_Clause (Withn);\n \n       --  If we have \"with X.Y;\", we want to recurse on \"X\", except in the\n       --  unusual case where X.Y is a renaming of X. In that case, the scope\n@@ -3395,7 +3403,8 @@ package body Sem_Ch10 is\n \n       Prepend (Withn, Context_Items (N));\n       Mark_Rewrite_Insertion (Withn);\n-      Install_Withed_Unit (Withn);\n+\n+      Install_With_Clause (Withn);\n \n       if Is_Child_Spec (P_Unit) then\n          Implicit_With_On_Parent (P_Unit, N);\n@@ -3501,7 +3510,7 @@ package body Sem_Ch10 is\n                Check_Private := True;\n             end if;\n \n-            Install_Withed_Unit (Item);\n+            Install_With_Clause (Item);\n \n             Decl_Node := Unit_Declaration_Node (Uname_Node);\n \n@@ -3905,7 +3914,7 @@ package body Sem_Ch10 is\n \n          function Previous_Withed_Unit (W : Node_Id) return Boolean;\n          --  Returns true if the context already includes a with_clause for\n-         --  this unit. If the with_clause is non-limited, the unit is fully\n+         --  this unit. If the with_clause is nonlimited, the unit is fully\n          --  visible and an implicit limited_with should not be created. If\n          --  there is already a limited_with clause for W, a second one is\n          --  simply redundant.\n@@ -3992,7 +4001,7 @@ package body Sem_Ch10 is\n             Analyze (Withn);\n \n             if not Limited_View_Installed (Withn) then\n-               Install_Limited_Withed_Unit (Withn);\n+               Install_Limited_With_Clause (Withn);\n             end if;\n          end if;\n       end Expand_Limited_With_Clause;\n@@ -4039,7 +4048,7 @@ package body Sem_Ch10 is\n                                              N_Subprogram_Body,\n                                              N_Subunit)\n                then\n-                  Install_Limited_Withed_Unit (Item);\n+                  Install_Limited_With_Clause (Item);\n                end if;\n             end if;\n          end if;\n@@ -4075,12 +4084,12 @@ package body Sem_Ch10 is\n                   if not Is_Incomplete_Type (Non_Lim_View) then\n \n                      --  Convert an incomplete subtype declaration into a\n-                     --  corresponding non-limited view subtype declaration.\n+                     --  corresponding nonlimited view subtype declaration.\n                      --  This is usually the case when analyzing a body that\n                      --  has regular with clauses,  when the spec has limited\n                      --  ones.\n \n-                     --  If the non-limited view is still incomplete, it is\n+                     --  If the nonlimited view is still incomplete, it is\n                      --  the dummy entry already created, and the declaration\n                      --  cannot be reanalyzed. This is the case when installing\n                      --  a parent unit that has limited with-clauses.\n@@ -4262,10 +4271,10 @@ package body Sem_Ch10 is\n                       not Is_Ancestor_Unit (Library_Unit (Item),\n                                             Cunit (Current_Sem_Unit))\n                   then\n-                     Install_Limited_Withed_Unit (Item);\n+                     Install_Limited_With_Clause (Item);\n                   end if;\n                else\n-                  Install_Withed_Unit (Item, Private_With_OK => True);\n+                  Install_With_Clause (Item, Private_With_OK => True);\n                end if;\n             end if;\n \n@@ -4430,10 +4439,10 @@ package body Sem_Ch10 is\n    end Install_Siblings;\n \n    ---------------------------------\n-   -- Install_Limited_Withed_Unit --\n+   -- Install_Limited_With_Clause --\n    ---------------------------------\n \n-   procedure Install_Limited_Withed_Unit (N : Node_Id) is\n+   procedure Install_Limited_With_Clause (N : Node_Id) is\n       P_Unit           : constant Entity_Id := Unit (Library_Unit (N));\n       E                : Entity_Id;\n       P                : Entity_Id;\n@@ -4890,7 +4899,7 @@ package body Sem_Ch10 is\n          return False;\n       end Is_Visible_Through_Renamings;\n \n-   --  Start of processing for Install_Limited_Withed_Unit\n+   --  Start of processing for Install_Limited_With_Clause\n \n    begin\n       pragma Assert (not Limited_View_Installed (N));\n@@ -4951,7 +4960,7 @@ package body Sem_Ch10 is\n       --  compilation of sibling Par.Sib forces the load of parent Par which\n       --  tries to install the limited view of Lim_Pack [1]. However Par.Sib\n       --  has a with clause for Lim_Pack [2] in its body, and thus needs the\n-      --  non-limited views of all entities from Lim_Pack.\n+      --  nonlimited views of all entities from Lim_Pack.\n \n       --     limited with Lim_Pack;   --  [1]\n       --     package Par is ...           package Lim_Pack is ...\n@@ -5157,7 +5166,7 @@ package body Sem_Ch10 is\n                   --  Replace E in the homonyms list, so that the limited view\n                   --  becomes available.\n \n-                  --  If the non-limited view is a record with an anonymous\n+                  --  If the nonlimited view is a record with an anonymous\n                   --  self-referential component, the analysis of the record\n                   --  declaration creates an incomplete type with the same name\n                   --  in order to define an internal access type. The visible\n@@ -5259,13 +5268,13 @@ package body Sem_Ch10 is\n \n       Set_Entity (Name (N), P);\n       Set_From_Limited_With (P);\n-   end Install_Limited_Withed_Unit;\n+   end Install_Limited_With_Clause;\n \n    -------------------------\n-   -- Install_Withed_Unit --\n+   -- Install_With_Clause --\n    -------------------------\n \n-   procedure Install_Withed_Unit\n+   procedure Install_With_Clause\n      (With_Clause     : Node_Id;\n       Private_With_OK : Boolean := False)\n    is\n@@ -5378,11 +5387,21 @@ package body Sem_Ch10 is\n          Set_Context_Installed (With_Clause);\n       end if;\n \n-      --   A with-clause overrides a with-type clause: there are no restric-\n-      --   tions on the use of package entities.\n-\n-      if Ekind (Uname) = E_Package then\n-         Set_From_Limited_With (Uname, False);\n+      --  A [private] with clause overrides a limited with clause. Restore the\n+      --  proper view of the package by performing the following actions:\n+      --\n+      --    * Remove all shadow entities which hide their corresponding\n+      --      entities from direct visibility by updating the entity and\n+      --      homonym chains.\n+      --\n+      --    * Enter the corresponding entities back in direct visibility\n+      --\n+      --  Note that the original limited with clause which installed its view\n+      --  is still marked as \"active\". This effect is undone when the clause\n+      --  itself is removed, see Remove_Limited_With_Clause.\n+\n+      if Ekind (Uname) = E_Package and then From_Limited_With (Uname) then\n+         Remove_Limited_With_Unit (Unit_Declaration_Node (Uname));\n       end if;\n \n       --  Ada 2005 (AI-377): it is illegal for a with_clause to name a child\n@@ -5454,7 +5473,7 @@ package body Sem_Ch10 is\n             end loop;\n          end;\n       end if;\n-   end Install_Withed_Unit;\n+   end Install_With_Clause;\n \n    -------------------\n    -- Is_Child_Spec --\n@@ -5994,9 +6013,10 @@ package body Sem_Ch10 is\n                Build_Shadow_Entity (Def_Id, Scop, Shadow);\n \n                Process_Declarations_And_States\n-                 (Pack  => Def_Id,\n-                  Decls => Visible_Declarations (Specification (Decl)),\n-                  Scop  => Shadow,\n+                 (Pack                  => Def_Id,\n+                  Decls                 =>\n+                    Visible_Declarations (Specification (Decl)),\n+                  Scop                  => Shadow,\n                   Create_Abstract_Views => Create_Abstract_Views);\n \n             --  Types\n@@ -6166,9 +6186,9 @@ package body Sem_Ch10 is\n       --  variables and types.\n \n       Process_Declarations_And_States\n-        (Pack  => Pack,\n-         Decls => Visible_Declarations (Spec),\n-         Scop  => Pack,\n+        (Pack                  => Pack,\n+         Decls                 => Visible_Declarations (Spec),\n+         Scop                  => Pack,\n          Create_Abstract_Views => True);\n \n       Last_Public_Shadow := Last_Shadow;\n@@ -6177,9 +6197,9 @@ package body Sem_Ch10 is\n       --  to accommodate limited private with clauses.\n \n       Process_Declarations_And_States\n-        (Pack  => Pack,\n-         Decls => Private_Declarations (Spec),\n-         Scop  => Pack,\n+        (Pack                  => Pack,\n+         Decls                 => Private_Declarations (Spec),\n+         Scop                  => Pack,\n          Create_Abstract_Views => False);\n \n       if Present (Last_Public_Shadow) then\n@@ -6423,149 +6443,268 @@ package body Sem_Ch10 is\n    --------------------------------\n \n    procedure Remove_Limited_With_Clause (N : Node_Id) is\n-      P_Unit     : constant Entity_Id := Unit (Library_Unit (N));\n-      E          : Entity_Id;\n-      P          : Entity_Id;\n-      Lim_Header : Entity_Id;\n-      Lim_Typ    : Entity_Id;\n-      Prev       : Entity_Id;\n+      Pack_Decl : constant Entity_Id := Unit (Library_Unit (N));\n \n    begin\n       pragma Assert (Limited_View_Installed (N));\n \n-      --  In case of limited with_clause on subprograms, generics, instances,\n-      --  or renamings, the corresponding error was previously posted and we\n-      --  have nothing to do here.\n+      --  Limited with clauses that designate units other than packages are\n+      --  illegal and are never installed.\n \n-      if Nkind (P_Unit) /= N_Package_Declaration then\n-         return;\n+      if Nkind (Pack_Decl) = N_Package_Declaration then\n+         Remove_Limited_With_Unit (Pack_Decl, N);\n       end if;\n \n-      P := Defining_Unit_Name (Specification (P_Unit));\n+      --  Indicate that the limited views of the clause have been removed\n \n-      --  Handle child packages\n+      Set_Limited_View_Installed (N, False);\n+   end Remove_Limited_With_Clause;\n \n-      if Nkind (P) = N_Defining_Program_Unit_Name then\n-         P := Defining_Identifier (P);\n-      end if;\n+   ------------------------------\n+   -- Remove_Limited_With_Unit --\n+   ------------------------------\n \n-      if Debug_Flag_I then\n-         Write_Str (\"remove limited view of \");\n-         Write_Name (Chars (P));\n-         Write_Str (\" from visibility\");\n-         Write_Eol;\n-      end if;\n+   procedure Remove_Limited_With_Unit\n+     (Pack_Decl  : Node_Id;\n+      Lim_Clause : Node_Id := Empty)\n+   is\n+      procedure Remove_Shadow_Entities_From_Visibility (Pack_Id : Entity_Id);\n+      --  Remove the shadow entities of package Pack_Id from direct visibility\n \n-      --  Prepare the removal of the shadow entities from visibility. The first\n-      --  element of the limited view is a header (an E_Package entity) that is\n-      --  used to reference the first shadow entity in the private part of the\n-      --  package\n+      procedure Remove_Shadow_Entities_With_Restore (Pack_Id : Entity_Id);\n+      --  Remove the shadow entities of package Pack_Id from direct visibility,\n+      --  restore the corresponding entities they hide into direct visibility,\n+      --  and update the entity and homonym chains.\n \n-      Lim_Header := Limited_View (P);\n-      Lim_Typ    := First_Entity (Lim_Header);\n+      --------------------------------------------\n+      -- Remove_Shadow_Entities_From_Visibility --\n+      --------------------------------------------\n \n-      --  Remove package and shadow entities from visibility if it has not\n-      --  been analyzed\n+      procedure Remove_Shadow_Entities_From_Visibility (Pack_Id : Entity_Id) is\n+         Lim_Header : constant Entity_Id := Limited_View (Pack_Id);\n+         Upto       : constant Entity_Id := First_Private_Entity (Lim_Header);\n \n-      if not Analyzed (P_Unit) then\n-         Unchain (P);\n-         Set_Is_Immediately_Visible (P, False);\n+         Shadow : Entity_Id;\n \n-         while Present (Lim_Typ) loop\n-            Unchain (Lim_Typ);\n-            Next_Entity (Lim_Typ);\n+      begin\n+         --  Remove the package from direct visibility\n+\n+         Unchain (Pack_Id);\n+         Set_Is_Immediately_Visible (Pack_Id, False);\n+\n+         --  Remove all shadow entities from direct visibility\n+\n+         Shadow := First_Entity (Lim_Header);\n+         while Present (Shadow) and then Shadow /= Upto loop\n+            Unchain (Shadow);\n+            Next_Entity (Shadow);\n          end loop;\n+      end Remove_Shadow_Entities_From_Visibility;\n \n-      --  Otherwise this package has already appeared in the closure and its\n-      --  shadow entities must be replaced by its real entities. This code\n-      --  must be kept synchronized with the complementary code in Install\n-      --  Limited_Withed_Unit.\n+      -----------------------------------------\n+      -- Remove_Shadow_Entities_With_Restore --\n+      -----------------------------------------\n \n-      else\n-         --  If the limited_with_clause is in some other unit in the context\n-         --  then it is not visible in the main unit.\n+      procedure Remove_Shadow_Entities_With_Restore (Pack_Id : Entity_Id) is\n+         procedure Restore_Chain_For_Shadow (Shadow : Entity_Id);\n+         --  Remove shadow entity Shadow by updating the entity and homonym\n+         --  chains.\n \n-         if not In_Extended_Main_Source_Unit (N) then\n-            Set_Is_Immediately_Visible (P, False);\n-         end if;\n+         procedure Restore_Chains\n+           (From : Entity_Id;\n+            Upto : Entity_Id);\n+         --  Remove a sequence of shadow entities starting from From and ending\n+         --  prior to Upto by updating the entity and homonym chains.\n \n-         --  Real entities that are type or subtype declarations were hidden\n-         --  from visibility at the point of installation of the limited-view.\n-         --  Now we recover the previous value of the hidden attribute.\n+         procedure Restore_Type_Visibility\n+           (From : Entity_Id;\n+            Upto : Entity_Id);\n+         --  Restore a sequence of types starting from From and ending prior to\n+         --  Upto back in direct visibility.\n \n-         E := First_Entity (P);\n-         while Present (E) and then E /= First_Private_Entity (P) loop\n-            if Is_Type (E) then\n-               Set_Is_Hidden (E, Was_Hidden (E));\n+         ------------------------------\n+         -- Restore_Chain_For_Shadow --\n+         ------------------------------\n+\n+         procedure Restore_Chain_For_Shadow (Shadow : Entity_Id) is\n+            Prev : Entity_Id;\n+            Typ  : Entity_Id;\n+\n+         begin\n+            --  If the package has incomplete types, the limited view of the\n+            --  incomplete type is in fact never visible (AI05-129) but we\n+            --  have created a shadow entity E1 for it, that points to E2,\n+            --  a nonlimited incomplete type. This in turn has a full view\n+            --  E3 that is the full declaration. There is a corresponding\n+            --  shadow entity E4. When reinstalling the nonlimited view,\n+            --  E2 must become the current entity and E3 must be ignored.\n+\n+            Typ := Non_Limited_View (Shadow);\n+\n+            --  Shadow is the limited view of a full type declaration that has\n+            --  a previous incomplete declaration, i.e. E3 from the previous\n+            --  description. Nothing to insert.\n+\n+            if Present (Current_Entity (Typ))\n+              and then Ekind (Current_Entity (Typ)) = E_Incomplete_Type\n+              and then Full_View (Current_Entity (Typ)) = Typ\n+            then\n+               return;\n             end if;\n \n-            Next_Entity (E);\n-         end loop;\n+            pragma Assert (not In_Chain (Typ));\n \n-         while Present (Lim_Typ)\n-           and then Lim_Typ /= First_Private_Entity (Lim_Header)\n-         loop\n-            --  Nested packages and child units were not unchained\n+            Prev := Current_Entity (Shadow);\n \n-            if Ekind (Lim_Typ) /= E_Package\n-              and then not Is_Child_Unit (Non_Limited_View (Lim_Typ))\n-            then\n-               --  If the package has incomplete types, the limited view of the\n-               --  incomplete type is in fact never visible (AI05-129) but we\n-               --  have created a shadow entity E1 for it, that points to E2,\n-               --  a non-limited incomplete type. This in turn has a full view\n-               --  E3 that is the full declaration. There is a corresponding\n-               --  shadow entity E4. When reinstalling the non-limited view,\n-               --  E2 must become the current entity and E3 must be ignored.\n-\n-               E := Non_Limited_View (Lim_Typ);\n-\n-               if Present (Current_Entity (E))\n-                 and then Ekind (Current_Entity (E)) = E_Incomplete_Type\n-                 and then Full_View (Current_Entity (E)) = E\n-               then\n+            if Prev = Shadow then\n+               Set_Current_Entity (Typ);\n+\n+            else\n+               while Present (Prev) and then Homonym (Prev) /= Shadow loop\n+                  Prev := Homonym (Prev);\n+               end loop;\n+\n+               if Present (Prev) then\n+                  Set_Homonym (Prev, Typ);\n+               end if;\n+            end if;\n+\n+            Set_Homonym (Typ, Homonym (Shadow));\n+         end Restore_Chain_For_Shadow;\n+\n+         --------------------\n+         -- Restore_Chains --\n+         --------------------\n+\n+         procedure Restore_Chains\n+           (From : Entity_Id;\n+            Upto : Entity_Id)\n+         is\n+            Shadow : Entity_Id;\n+\n+         begin\n+            Shadow := From;\n+            while Present (Shadow) and then Shadow /= Upto loop\n \n-                  --  Lim_Typ is the limited view of a full type declaration\n-                  --  that has a previous incomplete declaration, i.e. E3 from\n-                  --  the previous description. Nothing to insert.\n+               --  Do not unchain nested packages and child units\n \n+               if Ekind (Shadow) = E_Package then\n+                  null;\n+\n+               elsif Is_Child_Unit (Non_Limited_View (Shadow)) then\n                   null;\n \n                else\n-                  pragma Assert (not In_Chain (E));\n+                  Restore_Chain_For_Shadow (Shadow);\n+               end if;\n \n-                  Prev := Current_Entity (Lim_Typ);\n+               Next_Entity (Shadow);\n+            end loop;\n+         end Restore_Chains;\n \n-                  if Prev = Lim_Typ then\n-                     Set_Current_Entity (E);\n+         -----------------------------\n+         -- Restore_Type_Visibility --\n+         -----------------------------\n \n-                  else\n-                     while Present (Prev)\n-                       and then Homonym (Prev) /= Lim_Typ\n-                     loop\n-                        Prev := Homonym (Prev);\n-                     end loop;\n+         procedure Restore_Type_Visibility\n+           (From : Entity_Id;\n+            Upto : Entity_Id)\n+         is\n+            Typ : Entity_Id;\n \n-                     if Present (Prev) then\n-                        Set_Homonym (Prev, E);\n-                     end if;\n-                  end if;\n+         begin\n+            Typ := From;\n+            while Present (Typ) and then Typ /= Upto loop\n+               if Is_Type (Typ) then\n+                  Set_Is_Hidden (Typ, Was_Hidden (Typ));\n+               end if;\n \n-                  --  Preserve structure of homonym chain\n+               Next_Entity (Typ);\n+            end loop;\n+         end Restore_Type_Visibility;\n \n-                  Set_Homonym (E, Homonym (Lim_Typ));\n-               end if;\n-            end if;\n+         --  Local variables\n \n-            Next_Entity (Lim_Typ);\n-         end loop;\n+         Lim_Header : constant Entity_Id := Limited_View (Pack_Id);\n+\n+      --  Start of processing Remove_Shadow_Entities_With_Restore\n+\n+      begin\n+         --  The limited view of a package is being uninstalled by removing\n+         --  the effects of a limited with clause. If the clause appears in a\n+         --  unit which is not part of the main unit closure, then the related\n+         --  package must not be visible.\n+\n+         if Present (Lim_Clause)\n+           and then not In_Extended_Main_Source_Unit (Lim_Clause)\n+         then\n+            Set_Is_Immediately_Visible (Pack_Id, False);\n+\n+         --  Otherwise a limited view is being overridden by a nonlimited view.\n+         --  Leave the visibility of the package as is because the unit must be\n+         --  visible when the nonlimited view is installed.\n+\n+         else\n+            null;\n+         end if;\n+\n+         --  Remove the shadow entities from visibility by updating the entity\n+         --  and homonym chains.\n+\n+         Restore_Chains\n+           (From => First_Entity (Lim_Header),\n+            Upto => First_Private_Entity (Lim_Header));\n+\n+         --  Reinstate the types that were hidden by the shadow entities back\n+         --  into direct visibility.\n+\n+         Restore_Type_Visibility\n+           (From => First_Entity (Pack_Id),\n+            Upto => First_Private_Entity (Pack_Id));\n+      end Remove_Shadow_Entities_With_Restore;\n+\n+      --  Local variables\n+\n+      Pack_Id : constant Entity_Id := Defining_Entity (Pack_Decl);\n+\n+   --  Start of processing for Remove_Limited_With_Unit\n+\n+   begin\n+      --  Nothing to do when the limited view of the package is not installed\n+\n+      if not From_Limited_With (Pack_Id) then\n+         return;\n+      end if;\n+\n+      if Debug_Flag_I then\n+         Write_Str (\"remove limited view of \");\n+         Write_Name (Chars (Pack_Id));\n+         Write_Str (\" from visibility\");\n+         Write_Eol;\n+      end if;\n+\n+      --  The package already appears in the compilation closure. As a result,\n+      --  its shadow entities must be replaced by the real entities they hide\n+      --  and the previously hidden entities must be entered back into direct\n+      --  visibility.\n+\n+      --  WARNING: This code must be kept synchronized with that of routine\n+      --  Install_Limited_Withed_Clause.\n+\n+      if Analyzed (Pack_Decl) then\n+         Remove_Shadow_Entities_With_Restore (Pack_Id);\n+\n+      --  Otherwise the package is not analyzed and its shadow entities must be\n+      --  removed from direct visibility.\n+\n+      else\n+         Remove_Shadow_Entities_From_Visibility (Pack_Id);\n       end if;\n \n       --  Indicate that the limited view of the package is not installed\n \n-      Set_From_Limited_With      (P, False);\n-      Set_Limited_View_Installed (N, False);\n-   end Remove_Limited_With_Clause;\n+      Set_From_Limited_With (Pack_Id, False);\n+   end Remove_Limited_With_Unit;\n \n    --------------------\n    -- Remove_Parents --"}]}