{"sha": "25fdd0d6df44044a8b505e6fcd07270e2e279b06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVmZGQwZDZkZjQ0MDQ0YThiNTA1ZTZmY2QwNzI3MGUyZTI3OWIwNg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2021-02-02T04:30:05Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2021-02-03T14:44:18Z"}, "message": "c++: ICE with late parsing of noexcept in nested class [PR98899]\n\nHere we crash with a noexcept-specifier in a nested template class,\nbecause my handling of such deferred-parse noexcept-specifiers was\ngronked when we need to instantiate a DEFERRED_PARSE before it was\nactually parsed at the end of the outermost class.\n\nIn\n\n  struct S {\n    template<class> struct B {\n      B() noexcept(noexcept(x));\n      int x;\n    };\n    struct A : B<int> {\n      A() : B() {}\n    };\n  };\n\nwe call complete_type for B<int> which triggers tsubsting S::B<int>::B()\nwhose noexcept-specifier still contains a DEFERRED_PARSE.  The trick is\nto stash such noexcept-specifiers into DEFPARSE_INSTANTIATIONS so that\nwe can replace it later when we've finally parsed all deferred\nnoexcept-specifiers.\n\nIn passing, fix missing usage of UNPARSED_NOEXCEPT_SPEC_P.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/98899\n\t* parser.c (cp_parser_class_specifier_1): Use any possible\n\tDEFPARSE_INSTANTIATIONS to update DEFERRED_NOEXCEPT_PATTERN.\n\t(cp_parser_save_noexcept): Initialize DEFPARSE_INSTANTIATIONS.\n\t* pt.c (tsubst_exception_specification): Stash new_specs into\n\tDEFPARSE_INSTANTIATIONS.\n\t* tree.c (fixup_deferred_exception_variants): Use\n\tUNPARSED_NOEXCEPT_SPEC_P.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/98899\n\t* g++.dg/cpp0x/noexcept65.C: New test.", "tree": {"sha": "511091a93cedd89ec505cbc85a5ec6213e00eec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/511091a93cedd89ec505cbc85a5ec6213e00eec8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25fdd0d6df44044a8b505e6fcd07270e2e279b06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25fdd0d6df44044a8b505e6fcd07270e2e279b06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25fdd0d6df44044a8b505e6fcd07270e2e279b06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25fdd0d6df44044a8b505e6fcd07270e2e279b06/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3535402e20118655b2ad4085a6e1d4f1b9c46e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3535402e20118655b2ad4085a6e1d4f1b9c46e92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3535402e20118655b2ad4085a6e1d4f1b9c46e92"}], "stats": {"total": 67, "additions": 62, "deletions": 5}, "files": [{"sha": "5da8670f0e22fc5a4efd417373ec95efe5b660ea", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25fdd0d6df44044a8b505e6fcd07270e2e279b06/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25fdd0d6df44044a8b505e6fcd07270e2e279b06/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=25fdd0d6df44044a8b505e6fcd07270e2e279b06", "patch": "@@ -25026,8 +25026,8 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n \t      pushed_scope = push_scope (class_type);\n \t    }\n \n-\t  tree spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl));\n-\t  spec = TREE_PURPOSE (spec);\n+\t  tree def_parse = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl));\n+\t  def_parse = TREE_PURPOSE (def_parse);\n \n \t  /* Make sure that any template parameters are in scope.  */\n \t  maybe_begin_member_template_processing (decl);\n@@ -25044,14 +25044,20 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n \t    parser->local_variables_forbidden_p |= THIS_FORBIDDEN;\n \n \t  /* Now we can parse the noexcept-specifier.  */\n-\t  spec = cp_parser_late_noexcept_specifier (parser, spec);\n+\t  tree spec = cp_parser_late_noexcept_specifier (parser, def_parse);\n \n \t  if (spec == error_mark_node)\n \t    spec = NULL_TREE;\n \n \t  /* Update the fn's type directly -- it might have escaped\n \t     beyond this decl :(  */\n \t  fixup_deferred_exception_variants (TREE_TYPE (decl), spec);\n+\t  /* Update any instantiations we've already created.  We must\n+\t     keep the new noexcept-specifier wrapped in a DEFERRED_NOEXCEPT\n+\t     so that maybe_instantiate_noexcept can tsubst the NOEXCEPT_EXPR\n+\t     in the pattern.  */\n+\t  for (tree i : DEFPARSE_INSTANTIATIONS (def_parse))\n+\t    DEFERRED_NOEXCEPT_PATTERN (TREE_PURPOSE (i)) = TREE_PURPOSE (spec);\n \n \t  /* Restore the state of local_variables_forbidden_p.  */\n \t  parser->local_variables_forbidden_p = local_variables_forbidden_p;\n@@ -26695,6 +26701,7 @@ cp_parser_save_noexcept (cp_parser *parser)\n   /* Save away the noexcept-specifier; we will process it when the\n      class is complete.  */\n   DEFPARSE_TOKENS (expr) = cp_token_cache_new (first, last);\n+  DEFPARSE_INSTANTIATIONS (expr) = nullptr;\n   expr = build_tree_list (expr, NULL_TREE);\n   return expr;\n }"}, {"sha": "4781519d00fe068b12dc64fae468ddfa602443f3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25fdd0d6df44044a8b505e6fcd07270e2e279b06/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25fdd0d6df44044a8b505e6fcd07270e2e279b06/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=25fdd0d6df44044a8b505e6fcd07270e2e279b06", "patch": "@@ -15189,6 +15189,22 @@ tsubst_exception_specification (tree fntype,\n \t     /*integral_constant_expression_p=*/true);\n \t}\n       new_specs = build_noexcept_spec (new_specs, complain);\n+      /* We've instantiated a template before a noexcept-specifier\n+\t contained therein has been parsed.  This can happen for\n+\t a nested template class:\n+\n+\t  struct S {\n+\t    template<typename> struct B { B() noexcept(...); };\n+\t    struct A : B<int> { ... use B() ... };\n+\t  };\n+\n+\t where completing B<int> will trigger instantiating the\n+\t noexcept, even though we only parse it at the end of S.  */\n+      if (UNPARSED_NOEXCEPT_SPEC_P (specs))\n+\t{\n+\t  gcc_checking_assert (defer_ok);\n+\t  vec_safe_push (DEFPARSE_INSTANTIATIONS (expr), new_specs);\n+\t}\n     }\n   else if (specs)\n     {"}, {"sha": "e6ced274959525ea6987b923bd11a6b44a867e1d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25fdd0d6df44044a8b505e6fcd07270e2e279b06/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25fdd0d6df44044a8b505e6fcd07270e2e279b06/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=25fdd0d6df44044a8b505e6fcd07270e2e279b06", "patch": "@@ -2738,8 +2738,7 @@ fixup_deferred_exception_variants (tree type, tree raises)\n   tree original = TYPE_RAISES_EXCEPTIONS (type);\n   tree cr = flag_noexcept_type ? canonical_eh_spec (raises) : NULL_TREE;\n \n-  gcc_checking_assert (TREE_CODE (TREE_PURPOSE (original))\n-\t\t       == DEFERRED_PARSE);\n+  gcc_checking_assert (UNPARSED_NOEXCEPT_SPEC_P (original));\n \n   /* Though sucky, this walk will process the canonical variants\n      first.  */"}, {"sha": "f59337777de18e1cb3030fd32afff03f512b9733", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept65.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25fdd0d6df44044a8b505e6fcd07270e2e279b06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept65.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25fdd0d6df44044a8b505e6fcd07270e2e279b06/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept65.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept65.C?ref=25fdd0d6df44044a8b505e6fcd07270e2e279b06", "patch": "@@ -0,0 +1,35 @@\n+// PR c++/98899\n+// { dg-do compile { target c++11 } }\n+\n+template <int __v> struct integral_constant {\n+  static constexpr int value = __v;\n+};\n+\n+struct S {\n+  template<class> struct B {\n+    B() noexcept(noexcept(x));\n+    int x;\n+  };\n+  struct A : B<int> {\n+    A() : B() {}\n+  };\n+};\n+\n+struct S2 {\n+  template<class> struct B {\n+    B() noexcept(integral_constant<false>::value);\n+  };\n+  struct A : B<int> {\n+    A() : B() {}\n+  };\n+};\n+\n+struct S3 {\n+  template<class> struct B {\n+    B() noexcept(b);\n+  };\n+  struct A : B<int> {\n+    A() : B() {}\n+  };\n+  static constexpr bool b = false;\n+};"}]}