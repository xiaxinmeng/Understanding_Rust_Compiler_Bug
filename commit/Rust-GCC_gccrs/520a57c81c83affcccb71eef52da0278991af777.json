{"sha": "520a57c81c83affcccb71eef52da0278991af777", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIwYTU3YzgxYzgzYWZmY2NjYjcxZWVmNTJkYTAyNzg5OTFhZjc3Nw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.stanford.edu", "date": "2000-11-17T06:05:31Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-11-17T06:05:31Z"}, "message": "stringpool.c: New file.\n\n\t* stringpool.c: New file.\n\t* ggc-common.c (ggc_mark_string_ptr, ggc_add_string_root): Delete.\n\t(ggc_alloc_string): Now in stringpool.o.\n\t* ggc-page.c, ggc-simple.c: Do not define or allocate empty_string.\n\t* ggc.h: Delete prototype of ggc_add_string_root.  #define\n\tggc_add_string_root and ggc_mark_string to nothing.  Prototype\n\tinit_stringpool and stringpool_statistics.\n\t(ggc_alloc_string): Returns a const char *.\n\t* tree.c (hash_table, do_identifier_warnings): Delete.\n\t(init_obstacks): Don't initialize the identifier hash table.\n\t(get_identifier, maybe_get_identifier, start_identifier_warnings,\n\tset_identifier_size): Now in stringpool.c.\n\t* tree.h (struct tree_string): Constify pointer field.\n\t(approx_sqrt): Prototype.\n\n\t* Makefile.in (stringpool.o): Add rule, mention in OBJS.\n\n\t* toplev.c (approx_sqrt): New function.\n\t(compile_file): Call stringpool_statistics if mem_report is on.\n\t(main): Call init_stringpool.\n\n\t* builtins.c (c_strlen), c-decl.c (finish_decl), c-lex.c\n\t(process_directive), c-typeck.c (constructor_asmspec, struct\n\tinitializer_stack, start_init), except.c (create_rethrow_ref),\n\tstmt.c (digit_strings), toplev.c (decode_f_option), tree.c\n\t(built_in_filename), varasm,c (in_named_name,\n\tassemble_static_space, struct constant_descriptor, struct\n\tdeferred_string, struct pool_constant, force_const_mem),\n\ti386.c (pic_label_name, global_offset_table_name), rs6000.c\n\t(rs6000_emit_prologue, rs6000_emit_epilogue) : Constify a char *.\n\n\t* c-common.c (combine_strings): Combine strings in scratch\n\tbuffer, then pass to build_string.\n\t* optabs.c (init_libfuncs), profile.c (init_edge_profiler,\n\toutput_func_start_profiler), stmt.c (init_stmt), alpha.c\n\t(alpha_need_linkage), arm.c (arm_encode_call_attribute),\n\ti386.c (load_pic_register), ia64.c (ia64_encode_section_info),\n\trs6000.c (rs6000_encode_section_info): Create string in\n\tscratch buffer, then pass to ggc_alloc_string.\n\n\t* stmt.c (expand_asm_operands): If we must adjust the\n\tconstraint strings, do so by creating a new one, not by\n\tmodifying the old one in place.  Constify some char *s.\n\t* config/pa/pa.c (hppa_encode_label): Drop unnecessary second\n\targument.  Create string in scratch buffer, then pass to\n\tggc_alloc_string.\n\t* config/pa/pa-protos.h: Update prototype.\n\t* config/pa/elf.h, config/pa/pa.h, config/pa/som.h:\n\thppa_encode_label takes only one argument.\n\n\t* c-parse.in (if_prefix): Find the filename and line number at\n\t$-2 and $-1 respectively.\n\t* diagnostic.c (error_recursion): Add missing newline, use\n\tfputs, translate string.\n\ncp:\n\t* lex.c (struct impl_files, internal_filename): Constify a char *.\njava:\n\t* jcf-parse.c (get_constant), parse.y (do_merge_string_cste):\n\tCreate string in scratch buffer, then pass to build_string.\n\nFrom-SVN: r37514", "tree": {"sha": "925528b7b20608d2eac0acf5e939480048b49271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/925528b7b20608d2eac0acf5e939480048b49271"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/520a57c81c83affcccb71eef52da0278991af777", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520a57c81c83affcccb71eef52da0278991af777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/520a57c81c83affcccb71eef52da0278991af777", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520a57c81c83affcccb71eef52da0278991af777/comments", "author": null, "committer": null, "parents": [{"sha": "5af655cceef2b8b61a323734a6f9c250b4f420ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af655cceef2b8b61a323734a6f9c250b4f420ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5af655cceef2b8b61a323734a6f9c250b4f420ca"}], "stats": {"total": 977, "additions": 643, "deletions": 334}, "files": [{"sha": "bbb7eeec1ce33919af70140c9b5433603228b105", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -1,3 +1,62 @@\n+2000-11-16  Zack Weinberg  <zack@wolery.stanford.edu>\n+\n+\t* c-parse.in (if_prefix): Find the filename and line number at\n+\t$-2 and $-1 respectively.\n+\t* diagnostic.c (error_recursion): Add missing newline, use\n+\tfputs, translate string.\n+\n+2000-11-16  Zack Weinberg  <zack@wolery.stanford.edu>\n+\n+\t* stringpool.c: New file.\n+\t* ggc-common.c (ggc_mark_string_ptr, ggc_add_string_root): Delete.\n+\t(ggc_alloc_string): Now in stringpool.o.\n+\t* ggc-page.c, ggc-simple.c: Do not define or allocate empty_string.\n+\t* ggc.h: Delete prototype of ggc_add_string_root.  #define\n+\tggc_add_string_root and ggc_mark_string to nothing.  Prototype\n+\tinit_stringpool and stringpool_statistics.\n+\t(ggc_alloc_string): Returns a const char *.\n+\t* tree.c (hash_table, do_identifier_warnings): Delete.\n+\t(init_obstacks): Don't initialize the identifier hash table.\n+\t(get_identifier, maybe_get_identifier, start_identifier_warnings,\n+\tset_identifier_size): Now in stringpool.c.\n+\t* tree.h (struct tree_string): Constify pointer field.\n+\t(approx_sqrt): Prototype.\n+\n+\t* Makefile.in (stringpool.o): Add rule, mention in OBJS.\n+\n+\t* toplev.c (approx_sqrt): New function.\n+\t(compile_file): Call stringpool_statistics if mem_report is on.\n+\t(main): Call init_stringpool.\n+\n+\t* builtins.c (c_strlen), c-decl.c (finish_decl), c-lex.c\n+\t(process_directive), c-typeck.c (constructor_asmspec, struct\n+\tinitializer_stack, start_init), except.c (create_rethrow_ref),\n+\tstmt.c (digit_strings), toplev.c (decode_f_option), tree.c\n+\t(built_in_filename), varasm,c (in_named_name,\n+\tassemble_static_space, struct constant_descriptor, struct\n+\tdeferred_string, struct pool_constant, force_const_mem),\n+\ti386.c (pic_label_name, global_offset_table_name), rs6000.c\n+\t(rs6000_emit_prologue, rs6000_emit_epilogue) : Constify a char *.\n+\n+\t* c-common.c (combine_strings): Combine strings in scratch\n+\tbuffer, then pass to build_string.\n+\t* optabs.c (init_libfuncs), profile.c (init_edge_profiler,\n+\toutput_func_start_profiler), stmt.c (init_stmt), alpha.c\n+\t(alpha_need_linkage), arm.c (arm_encode_call_attribute),\n+\ti386.c (load_pic_register), ia64.c (ia64_encode_section_info),\n+\trs6000.c (rs6000_encode_section_info): Create string in\n+\tscratch buffer, then pass to ggc_alloc_string.\n+\n+\t* stmt.c (expand_asm_operands): If we must adjust the\n+\tconstraint strings, do so by creating a new one, not by\n+\tmodifying the old one in place.  Constify some char *s.\n+\t* config/pa/pa.c (hppa_encode_label): Drop unnecessary second\n+\targument.  Create string in scratch buffer, then pass to\n+\tggc_alloc_string.\n+\t* config/pa/pa-protos.h: Update prototype.\n+\t* config/pa/elf.h, config/pa/pa.h, config/pa/som.h:\n+\thppa_encode_label takes only one argument.\n+\n 2000-11-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* mcore.c (mcore_expand_prolog): Call xmalloc/xrealloc, not"}, {"sha": "d07357e31f6e4cffee6bd9df59a4f4509250bb11", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -734,7 +734,7 @@ OBJS = diagnostic.o version.o tree.o print-tree.o stor-layout.o fold-const.o  \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o    \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o\t      \\\n  mbchar.o splay-tree.o graph.o sbitmap.o resource.o hash.o predict.o\t      \\\n- lists.o ggc-common.o $(GGC) simplify-rtx.o ssa.o bb-reorder.o\t\t      \\\n+ lists.o ggc-common.o $(GGC) stringpool.o simplify-rtx.o ssa.o bb-reorder.o   \\\n  sibcall.o conflict.o timevar.o ifcvt.o dominance.o dependence.o dce.o\n \n BACKEND = toplev.o libbackend.a\n@@ -1268,6 +1268,9 @@ ggc-simple.o: ggc-simple.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h \\\n ggc-page.o: ggc-page.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h toplev.h \\\n \t$(GGC_H) varray.h $(TIMEVAR_H)\n \n+stringpool.o: stringpool.c $(CONFIG_H) system.h $(TREE_H) $(OBSTACK_H) \\\n+\tflags.h toplev.h\n+\n ggc-none.o: ggc-none.c $(CONFIG_H) $(RTL_H) $(GGC_H)\n \n obstack.o: $(srcdir)/../libiberty/obstack.c $(CONFIG_H)"}, {"sha": "ec12cae98ce2667d3d98bbf1ade1b3124ea13550", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -210,7 +210,7 @@ c_strlen (src)\n {\n   tree offset_node;\n   int offset, max;\n-  char *ptr;\n+  const char *ptr;\n \n   src = string_constant (src, &offset_node);\n   if (src == 0)"}, {"sha": "05b7b8a5df0076e2b84a4d6c295ac9c52df8a0c9", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -377,7 +377,7 @@ combine_strings (strings)\n       if (wide_flag)\n \tlength = length * wchar_bytes + wide_length;\n \n-      p = ggc_alloc_string (NULL, length);\n+      p = alloca (length);\n \n       /* Copy the individual strings into the new combined string.\n \t If the combined string is wide, convert the chars to ints\n@@ -416,9 +416,7 @@ combine_strings (strings)\n       else\n \t*q = 0;\n \n-      value = make_node (STRING_CST);\n-      TREE_STRING_POINTER (value) = p;\n-      TREE_STRING_LENGTH (value) = length;\n+      value = build_string (length, p);\n     }\n   else\n     {"}, {"sha": "8d66b4ef26053478d7d657dab2c69a5898b3cb4c", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -3634,7 +3634,7 @@ finish_decl (decl, init, asmspec_tree)\n {\n   register tree type = TREE_TYPE (decl);\n   int was_incomplete = (DECL_SIZE (decl) == 0);\n-  char *asmspec = 0;\n+  const char *asmspec = 0;\n \n   /* If a name was specified, get the string.   */\n   if (asmspec_tree)"}, {"sha": "61ff1553cdbe279ebe8e682b1f147f3d33ddfebc", "filename": "gcc/c-lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -443,7 +443,7 @@ process_directive ()\n   int saw_line;\n   enum { act_none, act_push, act_pop } action;\n   int action_number, l;\n-  char *new_file;\n+  const char *new_file;\n #ifndef NO_IMPLICIT_EXTERN_C\n   int entering_c_header = 0;\n #endif"}, {"sha": "ae474667ff633e9b27a90b867d2436eec8fdc095", "filename": "gcc/c-parse.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -1765,8 +1765,8 @@ if_prefix:\n \t\t{ c_expand_start_cond (truthvalue_conversion ($3), \n \t\t\t\t       compstmt_count);\n \t\t  $<itype>$ = stmt_count;\n-\t\t  if_stmt_file = $<filename>-1;\n-\t\t  if_stmt_line = $<lineno>0; }\n+\t\t  if_stmt_file = $<filename>-2;\n+\t\t  if_stmt_line = $<lineno>-1; }\n \t;\n \n /* This is a subroutine of stmt."}, {"sha": "edf73ea00bef1f86b0faf3c7cec3094fb838e22b", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -4944,7 +4944,7 @@ static int require_constant_elements;\n static tree constructor_decl;\n \n /* start_init saves the ASMSPEC arg here for really_start_incremental_init.  */\n-static char *constructor_asmspec;\n+static const char *constructor_asmspec;\n \n /* Nonzero if this is an initializer for a top-level decl.  */\n static int constructor_top_level;\n@@ -4989,7 +4989,7 @@ struct initializer_stack\n {\n   struct initializer_stack *next;\n   tree decl;\n-  char *asmspec;\n+  const char *asmspec;\n   struct constructor_stack *constructor_stack;\n   tree elements;\n   struct spelling *spelling;\n@@ -5014,7 +5014,7 @@ start_init (decl, asmspec_tree, top_level)\n   const char *locus;\n   struct initializer_stack *p\n     = (struct initializer_stack *) xmalloc (sizeof (struct initializer_stack));\n-  char *asmspec = 0;\n+  const char *asmspec = 0;\n \n   if (asmspec_tree)\n     asmspec = TREE_STRING_POINTER (asmspec_tree);"}, {"sha": "b4707f22925d31b2cd6be52ba42b3132b42bfd7c", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -6232,12 +6232,12 @@ alpha_need_linkage (name, is_local)\n   /* Construct a SYMBOL_REF for us to call.  */\n   {\n     size_t name_len = strlen (name);\n-    char *linksym = ggc_alloc_string (NULL, name_len + 6);\n-\n+    char *linksym = alloca (name_len + 6);\n     linksym[0] = '$';\n     memcpy (linksym + 1, name, name_len);\n     memcpy (linksym + 1 + name_len, \"..lk\", 5);\n-    al->linkage = gen_rtx_SYMBOL_REF (Pmode, linksym);\n+    al->linkage = gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t      ggc_alloc_string (linksym, name_len + 5));\n   }\n \n   splay_tree_insert (alpha_links, (splay_tree_key) name,"}, {"sha": "3d7121e0f573db87f7f8f52b6a0a61254d572c1d", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -1726,11 +1726,12 @@ arm_encode_call_attribute (decl, flag)\n   /* Do not allow weak functions to be treated as short call.  */\n   if (DECL_WEAK (decl) && flag == SHORT_CALL_FLAG_CHAR)\n     return;\n-  \n-  newstr = ggc_alloc_string (NULL, len + 2);\n \n-  sprintf (newstr, \"%c%s\", flag, str);\n+  newstr = alloca (len + 2);\n+  newstr[0] = flag;\n+  strcpy (newstr + 1, str);\n \n+  newstr = ggc_alloc_string (newstr, len + 1);\n   XSTR (XEXP (DECL_RTL (decl), 0), 0) = newstr;\n }\n "}, {"sha": "f5aee19ec04bf8572a666f3fed77dda930326359", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -1675,9 +1675,9 @@ ix86_can_use_return_insn_p ()\n   return tsize == 0 && nregs == 0;\n }\n \f\n-static char *pic_label_name;\n+static const char *pic_label_name;\n static int pic_label_output;\n-static char *global_offset_table_name;\n+static const char *global_offset_table_name;\n \n /* This function generates code for -fpic that loads %ebx with\n    the return address of the caller and then returns.  */\n@@ -1733,9 +1733,10 @@ load_pic_register ()\n     {\n       if (pic_label_name == NULL)\n \t{\n-\t  pic_label_name = ggc_alloc_string (NULL, 32);\n+\t  char buf[32];\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LPR\", 0);\n+\t  pic_label_name = ggc_alloc_string (buf, -1);\n \t  ggc_add_string_root (&pic_label_name, 1);\n-\t  ASM_GENERATE_INTERNAL_LABEL (pic_label_name, \"LPR\", 0);\n \t}\n       pclab = gen_rtx_MEM (QImode, gen_rtx_SYMBOL_REF (Pmode, pic_label_name));\n     }"}, {"sha": "0f6657a2adc11d577c6f57093d032e9a5cd05a84", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -4801,12 +4801,12 @@ ia64_encode_section_info (decl)\n \t       && symbol_str[0] != SDATA_NAME_FLAG_CHAR)\n \t{\n \t  size_t len = strlen (symbol_str);\n-\t  char *newstr;\n+\t  char *newstr = alloca (len + 1);\n \n-\t  newstr = ggc_alloc_string (NULL, len + 1);\n \t  *newstr = SDATA_NAME_FLAG_CHAR;\n \t  memcpy (newstr + 1, symbol_str, len + 1);\n-\n+\t  \n+\t  newstr = ggc_alloc_string (newstr, len + 1);\n \t  XSTR (XEXP (DECL_RTL (decl), 0), 0) = newstr;\n \t}\n     }"}, {"sha": "1fda8ad57080b1559cc041b78c6f901b1797ba42", "filename": "gcc/config/pa/elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fpa%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fpa%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Felf.h?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -84,7 +84,7 @@ do {  \\\n #define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, RTL) \\\n   do { fputs (\"\\t.IMPORT \", FILE);\t\t\t\t\t\\\n        if (!function_label_operand (RTL, VOIDmode))\t\t\t\\\n-\t hppa_encode_label (RTL, 1);\t\t\t\t\t\\\n+\t hppa_encode_label (RTL);\t\t\t\t\t\\\n        assemble_name (FILE, XSTR ((RTL), 0));\t\t       \t\t\\\n        fputs (\",ENTRY\\n\", FILE);\t\t\t\t\t\\\n      } while (0)"}, {"sha": "4f15aa72367f1ad2e40d0d40c94a33637993ccb2", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -61,7 +61,7 @@ extern void output_global_address PARAMS ((FILE *, rtx, int));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern rtx legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));\n extern struct rtx_def *gen_cmp_fp PARAMS ((enum rtx_code, rtx, rtx));\n-extern void hppa_encode_label PARAMS ((rtx, int));\n+extern void hppa_encode_label PARAMS ((rtx));\n extern int arith11_operand PARAMS ((rtx, enum machine_mode));\n extern int symbolic_expression_p PARAMS ((rtx));\n extern int hppa_address_cost PARAMS ((rtx));"}, {"sha": "540f8a7e4c880831f293bde76854e25afab08620", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -5939,29 +5939,22 @@ output_call (insn, call_dest, sibcall)\n /* In HPUX 8.0's shared library scheme, special relocations are needed\n    for function labels if they might be passed to a function\n    in a shared library (because shared libraries don't live in code\n-   space), and special magic is needed to construct their address.\n-\n-   For reasons too disgusting to describe storage for the new name\n-   is allocated as a ggc string, or as a string on the saveable_obstack\n-   (released at function exit) or on the permanent_obstack for things\n-   that can never change (libcall names for example). */\n+   space), and special magic is needed to construct their address.  */\n \n void\n-hppa_encode_label (sym, permanent)\n+hppa_encode_label (sym)\n      rtx sym;\n-     int permanent;\n {\n   const char *str = XSTR (sym, 0);\n   int len = strlen (str);\n-  char *newstr;\n-\n-  newstr = ggc_alloc_string (NULL, len + 1);\n+  char *newstr = alloca (len + 1);\n \n   if (str[0] == '*')\n     *newstr++ = *str++;\n   strcpy (newstr + 1, str);\n   *newstr = '@';\n-  XSTR (sym,0) = newstr;\n+\n+  XSTR (sym,0) = ggc_alloc_string (newstr, len);\n }\n \n int"}, {"sha": "536692b54054991eda02419412fd3243a8bf4164", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -1494,7 +1494,7 @@ do\t\t\t\t\t\t\t\\\n \t  _rtl = TREE_CST_RTL (DECL);\t\t\t\\\n \tSYMBOL_REF_FLAG (XEXP (_rtl, 0)) = 1;\t\t\\\n \tif (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n-\t  hppa_encode_label (XEXP (DECL_RTL (DECL), 0), 0);\\\n+\t  hppa_encode_label (XEXP (DECL_RTL (DECL), 0));\\\n       }\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\\\n while (0)"}, {"sha": "06ee54b107b3288fda38a9ec569496cdc7887e9a", "filename": "gcc/config/pa/som.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fpa%2Fsom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Fpa%2Fsom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fsom.h?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -352,7 +352,7 @@ DTORS_SECTION_FUNCTION\n #define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, RTL) \\\n   do { fputs (\"\\t.IMPORT \", FILE);\t\t\t\t\t\\\n        if (!function_label_operand (RTL, VOIDmode))\t\t\t\\\n-\t hppa_encode_label (RTL, 1);\t\t\t\t\t\\\n+\t hppa_encode_label (RTL);\t\t\t\t\t\\\n        assemble_name (FILE, XSTR ((RTL), 0));\t\t       \t\t\\\n        fputs (\",CODE\\n\", FILE);\t\t\t\t\t\t\\\n      } while (0)"}, {"sha": "98fb376704f8110af581a7f67562530983dd5096", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -5604,7 +5604,7 @@ rs6000_emit_prologue()\n     {\n       int i;\n       char rname[30];\n-      char *alloc_rname;\n+      const char *alloc_rname;\n       rtvec p;\n       p = rtvec_alloc (2 + 64 - info->first_fp_reg_save);\n       \n@@ -6057,7 +6057,7 @@ rs6000_emit_epilogue(sibcall)\n \t{\n \t  int i;\n \t  char rname[30];\n-\t  char *alloc_rname;\n+\t  const char *alloc_rname;\n \n \t  sprintf (rname, \"%s%d%s\", RESTORE_FP_PREFIX, \n \t\t   info->first_fp_reg_save - 32, RESTORE_FP_SUFFIX);\n@@ -7578,14 +7578,12 @@ rs6000_encode_section_info (decl)\n \t{\n \t  size_t len1 = (DEFAULT_ABI == ABI_AIX) ? 1 : 2;\n \t  size_t len2 = strlen (XSTR (sym_ref, 0));\n-\t  char *str;\n-\n-\t  str = ggc_alloc_string (NULL, len1 + len2);\n+\t  char *str = alloca (len1 + len2 + 1);\n \t  str[0] = '.';\n \t  str[1] = '.';\n \t  memcpy (str + len1, XSTR (sym_ref, 0), len2 + 1);\n \n-\t  XSTR (sym_ref, 0) = str;\n+\t  XSTR (sym_ref, 0) = ggc_alloc_string (str, len1 + len2);\n \t}\n     }\n   else if (rs6000_sdata != SDATA_NONE\n@@ -7625,13 +7623,11 @@ rs6000_encode_section_info (decl)\n \t{\n \t  rtx sym_ref = XEXP (DECL_RTL (decl), 0);\n \t  size_t len = strlen (XSTR (sym_ref, 0));\n-\t  char *str;\n+\t  char *str = alloca (len + 1);\n \n-\t  str = ggc_alloc_string (NULL, len + 1);\n \t  str[0] = '@';\n \t  memcpy (str + 1, XSTR (sym_ref, 0), len + 1);\n-\n-\t  XSTR (sym_ref, 0) = str;\n+\t  XSTR (sym_ref, 0) = ggc_alloc_string (str, len);\n \t}\n     }\n }"}, {"sha": "a9930eedd647ac1515ff1629eae8b351c4b20c8f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -1,3 +1,7 @@\n+2000-11-16  Zack Weinberg  <zack@wolery.stanford.edu>\n+\n+\t* lex.c (struct impl_files, internal_filename): Constify a char *.\n+\n 2000-11-16  Mark Mitchell  <mark@codesourcery.com>\n \n \t* mangle.c (write_special_name_constructor): Don't generate"}, {"sha": "d1511f663eb082e593b60fc436f11350be0d4fc5", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -131,7 +131,7 @@ extern int *token_count;\n \n struct impl_files\n {\n-  char *filename;\n+  const char *filename;\n   struct impl_files *next;\n };\n \n@@ -140,7 +140,7 @@ static struct impl_files *impl_file_chain;\n /* The string used to represent the filename of internally generated\n    tree nodes.  The variable, which is dynamically allocated, should\n    be used; the macro is only used to initialize it.  */\n-static char *internal_filename;\n+static const char *internal_filename;\n #define INTERNAL_FILENAME (\"<internal>\")\n \f\n /* Return something to represent absolute declarators containing a *."}, {"sha": "85e3650164b0289269ababd769cecc1c871c019d", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -1637,8 +1637,8 @@ error_recursion ()\n   if (diagnostic_lock < 3)\n     finish_diagnostic ();\n \n-  fprintf (stderr,\n-\t   \"Internal compiler error: Error reporting routines re-entered.\");\n+  fputs (_(\"Internal compiler error: Error reporting routines re-entered.\\n\"),\n+\t stderr);\n   finish_abort ();\n }\n "}, {"sha": "e7c5f7d2273d9637695db533d00ec2ee493720cb", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -500,7 +500,7 @@ create_rethrow_ref (region_num)\n      int region_num;\n {\n   rtx def;\n-  char *ptr;\n+  const char *ptr;\n   char buf[60];\n \n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LRTH\", region_num);"}, {"sha": "1b083818b151055dac4f1ac7bfb4aa1a032c5599", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -47,7 +47,6 @@ static void ggc_mark_tree_ptr PARAMS ((void *));\n static void ggc_mark_rtx_varray_ptr PARAMS ((void *));\n static void ggc_mark_tree_varray_ptr PARAMS ((void *));\n static void ggc_mark_tree_hash_table_ptr PARAMS ((void *));\n-static void ggc_mark_string_ptr PARAMS ((void *));\n static void ggc_mark_trees PARAMS ((void));\n static boolean ggc_mark_tree_hash_table_entry PARAMS ((struct hash_entry *,\n \t\t\t\t\t\t       hash_table_key));\n@@ -143,16 +142,6 @@ ggc_add_tree_hash_table_root (base, nelt)\n \t\tggc_mark_tree_hash_table_ptr);\n }\n \n-/* Register an array of strings as a GC root.  */\n-\n-void\n-ggc_add_string_root (base, nelt)\n-     char **base;\n-     int nelt;\n-{\n-  ggc_add_root (base, nelt, sizeof (char *), ggc_mark_string_ptr);\n-}\n-\n /* Remove the previously registered GC root at BASE.  */\n \n void\n@@ -557,43 +546,6 @@ ggc_mark_tree_hash_table_ptr (elt)\n   ggc_mark_tree_hash_table (*(struct hash_table **) elt);\n }\n \n-/* Type-correct function to pass to ggc_add_root.  It just forwards\n-   ELT (which is really a char **) to ggc_mark_string.  */\n-\n-static void\n-ggc_mark_string_ptr (elt)\n-     void *elt;\n-{\n-  ggc_mark_string (*(char **) elt);\n-}\n-\n-/* Allocate a gc-able string.  If CONTENTS is null, then the memory will\n-   be uninitialized.  If LENGTH is -1, then CONTENTS is assumed to be a\n-   null-terminated string and the memory sized accordingly.  Otherwise,\n-   the memory is filled with LENGTH bytes from CONTENTS.  */\n-\n-char *\n-ggc_alloc_string (contents, length)\n-     const char *contents;\n-     int length;\n-{\n-  char *string;\n-\n-  if (length < 0)\n-    {\n-      if (contents == NULL)\n-\treturn NULL;\n-      length = strlen (contents);\n-    }\n-\n-  string = (char *) ggc_alloc (length + 1);\n-  if (contents != NULL)\n-    memcpy (string, contents, length);\n-  string[length] = 0;\n-\n-  return string;\n-}\n-\n /* Allocate a block of memory, then clear it.  */\n void *\n ggc_alloc_cleared (size)"}, {"sha": "2b64f45db53e88a6dc12df2427cf312013bdc67a", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -99,8 +99,6 @@ Boston, MA 02111-1307, USA.  */\n #define HOST_BITS_PER_PTR  HOST_BITS_PER_LONG\n #endif\n \n-/* The \"\" allocated string.  */\n-char *empty_string;\n \f\n /* A two-level tree is used to look up the page-entry for a given\n    pointer.  Two chunks of the pointer's bits are extracted to index\n@@ -839,9 +837,6 @@ init_ggc ()\n     munmap (p, G.pagesize);\n   }\n #endif\n-\n-  empty_string = ggc_alloc_string (\"\", 0);\n-  ggc_add_string_root (&empty_string, 1);\n }\n \n /* Increment the `GC context'.  Objects allocated in an outer context"}, {"sha": "b5cab1bcb23b355f91df98199523ae5818354e51", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -52,10 +52,6 @@\n #define GGC_ALWAYS_COLLECT\n #endif\n \n-/* Constants for general use.  */\n-\n-char *empty_string;\n-\n #ifndef HOST_BITS_PER_PTR\n #define HOST_BITS_PER_PTR  HOST_BITS_PER_LONG\n #endif\n@@ -374,9 +370,6 @@ void\n init_ggc ()\n {\n   G.allocated_last_gc = GGC_MIN_LAST_ALLOCATED;\n-\n-  empty_string = ggc_alloc_string (\"\", 0);\n-  ggc_add_string_root (&empty_string, 1);\n }\n \n /* Start a new GGC context.  Memory allocated in previous contexts"}, {"sha": "596c49b49895d8bd9a2b840f5e5dcf2656d73d3f", "filename": "gcc/ggc.h", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -40,7 +40,7 @@ union  tree_node;\n struct varasm_status;\n \n /* Constants for general use.  */\n-extern char *empty_string;\n+extern const char empty_string[];\n \n /* Trees that have been marked, but whose children still need marking.  */\n extern varray_type ggc_pending_trees;\n@@ -49,12 +49,14 @@ extern varray_type ggc_pending_trees;\n void ggc_add_root PARAMS ((void *base, int nelt, int size, void (*)(void *)));\n void ggc_add_rtx_root PARAMS ((struct rtx_def **, int nelt));\n void ggc_add_tree_root PARAMS ((union tree_node **, int nelt));\n-void ggc_add_string_root PARAMS ((char **, int nelt));\n void ggc_add_rtx_varray_root PARAMS ((struct varray_head_tag **, int nelt));\n void ggc_add_tree_varray_root PARAMS ((struct varray_head_tag **, int nelt));\n void ggc_add_tree_hash_table_root PARAMS ((struct hash_table **, int nelt));\n void ggc_del_root PARAMS ((void *base));\n \n+/* Temporary */\n+#define ggc_add_string_root(ptr, nelt)  /* nothing */\n+\n /* Mark nodes from the gc_add_root callback.  These functions follow\n    pointers to mark other objects too.  */\n extern void ggc_mark_rtx_varray PARAMS ((struct varray_head_tag *));\n@@ -91,12 +93,8 @@ extern void ggc_mark_rtvec_children PARAMS ((struct rtvec_def *));\n       ggc_mark_rtvec_children (v__);            \\\n   } while (0)\n \n-#define ggc_mark_string(EXPR)\t\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    const char *s__ = (EXPR);\t\t\t\\\n-    if (s__ != NULL)\t\t\t\t\\\n-      ggc_set_mark (s__);\t\t\t\\\n-  } while (0)\n+/* Temporary */\n+#define ggc_mark_string(EXPR)  /* nothing */\n \n #define ggc_mark(EXPR)\t\t\t\t\\\n   do {\t\t\t\t\t\t\\\n@@ -112,6 +110,7 @@ extern void ggc_mark_if_gcable PARAMS ((const void *));\n \n /* Initialize the garbage collector.   */\n extern void init_ggc PARAMS ((void));\n+extern void init_stringpool PARAMS ((void));\n \n /* Start a new GGC context.  Memory allocated in previous contexts\n    will not be collected while the new context is active.  */\n@@ -138,11 +137,10 @@ void *ggc_alloc_cleared PARAMS ((size_t));\n \n #define ggc_alloc_tree(LENGTH) ((union tree_node *) ggc_alloc (LENGTH))\n \n-/* Allocate a gc-able string.  If CONTENTS is null, then the memory will\n-   be uninitialized.  If LENGTH is -1, then CONTENTS is assumed to be a\n-   null-terminated string and the memory sized accordingly.  Otherwise,\n-   the memory is filled with LENGTH bytes from CONTENTS.  */\n-char *ggc_alloc_string PARAMS ((const char *contents, int length));\n+/* Allocate a gc-able string, and fill it with LENGTH bytes from CONTENTS.\n+   If LENGTH is -1, then CONTENTS is assumed to be a\n+   null-terminated string and the memory sized accordingly.  */\n+const char *ggc_alloc_string PARAMS ((const char *contents, int length));\n \n /* Make a copy of S, in GC-able memory.  */\n #define ggc_strdup(S) ggc_alloc_string((S), -1)\n@@ -214,3 +212,4 @@ void ggc_print_common_statistics PARAMS ((FILE *, ggc_statistics *));\n \n /* Print allocation statistics.  */\n extern void ggc_print_statistics PARAMS ((void));\n+void stringpool_statistics PARAMS ((void));"}, {"sha": "5fb49c0a9e73199c7907cdbc00df81595c482e7b", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -1,3 +1,8 @@\n+2000-11-16  Zack Weinberg  <zack@wolery.stanford.edu>\n+\n+\t* jcf-parse.c (get_constant), parse.y (do_merge_string_cste):\n+\tCreate string in scratch buffer, then pass to build_string.\n+\n 2000-11-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* parse.y (issue_warning_error_from_context): Add"}, {"sha": "aa56811a630b1e32fd311a1c6616693b4cb19b5b", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -328,61 +328,67 @@ get_constant (jcf, index)\n       {\n \ttree name = get_name_constant (jcf, JPOOL_USHORT1 (jcf, index));\n \tconst char *utf8_ptr = IDENTIFIER_POINTER (name);\n-\tunsigned char *str_ptr;\n \tint utf8_len = IDENTIFIER_LENGTH (name);\n-\tconst unsigned char *str = (const unsigned char *)utf8_ptr;\n-\tint i = utf8_len;\n-\tint str_len;\n+\tunsigned char *str_ptr;\n+\tunsigned char *str;\n+\tconst unsigned char *utf8;\n+\tint i, str_len;\n \n \t/* Count the number of Unicode characters in the string,\n \t   while checking for a malformed Utf8 string. */\n-\tfor (str_len = 0; i > 0; str_len++)\n+\tutf8 = (const unsigned char *) utf8_ptr;\n+\ti = utf8_len;\n+\tstr_len = 0;\n+\twhile (i > 0)\n \t  {\n-\t    int char_len = UT8_CHAR_LENGTH (*str);\n+\t    int char_len = UT8_CHAR_LENGTH (*utf8);\n \t    if (char_len < 0 || char_len > 3 || char_len > i)\n  \t      fatal (\"bad string constant\");\n-\t    str += char_len;\n+\t    utf8 += char_len;\n \t    i -= char_len;\n+\t    str_len++;\n \t  }\n \n-\tvalue = make_node (STRING_CST);\n-\tTREE_TYPE (value) = build_pointer_type (string_type_node);\n-\tTREE_STRING_LENGTH (value) = 2 * str_len;\n-\tTREE_STRING_POINTER (value) = ggc_alloc (2 * str_len);\n-\tstr_ptr = (unsigned char *) TREE_STRING_POINTER (value);\n-\tstr = (const unsigned char *)utf8_ptr;\n+\t/* Allocate a scratch buffer, convert the string to UCS2, and copy it\n+\t   into the new space.  */\n+\tstr_ptr = (unsigned char *) alloca (2 * str_len);\n+\tstr = str_ptr;\n+\tutf8 = (const unsigned char *)utf8_ptr;\n+\n \tfor (i = 0; i < str_len; i++)\n \t  {\n \t    int char_value;\n \t    int char_len = UT8_CHAR_LENGTH (*str);\n \t    switch (char_len)\n \t      {\n \t      case 1:\n-\t\tchar_value = *str++;\n+\t\tchar_value = *utf8++;\n \t\tbreak;\n \t      case 2:\n-\t\tchar_value = *str++ & 0x1F;\n-\t\tchar_value = (char_value << 6) | (*str++ & 0x3F);\n+\t\tchar_value = *utf8++ & 0x1F;\n+\t\tchar_value = (char_value << 6) | (*utf8++ & 0x3F);\n \t\tbreak;\n \t      case 3:\n-\t\tchar_value = *str++ & 0x0F;\n-\t\tchar_value = (char_value << 6) | (*str++ & 0x3F);\n-\t\tchar_value = (char_value << 6) | (*str++ & 0x3F);\n+\t\tchar_value = *utf8++ & 0x0F;\n+\t\tchar_value = (char_value << 6) | (*utf8++ & 0x3F);\n+\t\tchar_value = (char_value << 6) | (*utf8++ & 0x3F);\n \t\tbreak;\n \t      default:\n \t\tgoto bad;\n \t      }\n \t    if (BYTES_BIG_ENDIAN)\n \t      {\n-\t\t*str_ptr++ = char_value >> 8;\n-\t\t*str_ptr++ = char_value & 0xFF;\n+\t\t*str++ = char_value >> 8;\n+\t\t*str++ = char_value & 0xFF;\n \t      }\n \t    else\n \t      {\n-\t\t*str_ptr++ = char_value & 0xFF;\n-\t\t*str_ptr++ = char_value >> 8;\n+\t\t*str++ = char_value & 0xFF;\n+\t\t*str++ = char_value >> 8;\n \t      }\n \t  }\n+\tvalue = build_string (str - str_ptr, str_ptr);\n+\tTREE_TYPE (value) = build_pointer_type (string_type_node);\n       }\n       break;\n     default:"}, {"sha": "a35e6dc22ec6b7df77279c404a10bae27fd90778", "filename": "gcc/java/parse.y", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -13070,11 +13070,7 @@ do_merge_string_cste (cste, string, string_len, after)\n   const char *old = TREE_STRING_POINTER (cste);\n   int old_len = TREE_STRING_LENGTH (cste);\n   int len = old_len + string_len;\n-  char *new;\n-  \n-  cste = make_node (STRING_CST);\n-  TREE_STRING_LENGTH (cste) = len;\n-  new = TREE_STRING_POINTER (cste) = ggc_alloc (len+1);\n+  char *new = alloca (len+1);\n \n   if (after)\n     {\n@@ -13087,7 +13083,7 @@ do_merge_string_cste (cste, string, string_len, after)\n       memcpy (&new [old_len], string, string_len);\n     }\n   new [len] = '\\0';\n-  return cste;\n+  return build_string (len, new);\n }\n \n /* Tries to merge OP1 (a STRING_CST) and OP2 (if suitable). Return a"}, {"sha": "5ee436d7bf7d4e3c7657c21a8005cbda3fbd2add", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -4466,8 +4466,7 @@ init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n     {\n       register const char *mname = GET_MODE_NAME(mode);\n       register unsigned mname_len = strlen (mname);\n-      register char *libfunc_name\n-\t= ggc_alloc_string (NULL, 2 + opname_len + mname_len + 1 + 1);\n+      register char *libfunc_name = alloca (2 + opname_len + mname_len + 1 + 1);\n       register char *p;\n       register const char *q;\n \n@@ -4479,10 +4478,11 @@ init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n       for (q = mname; *q; q++)\n \t*p++ = TOLOWER (*q);\n       *p++ = suffix;\n-      *p++ = '\\0';\n+      *p = '\\0';\n \n       optable->handlers[(int) mode].libfunc\n-\t= gen_rtx_SYMBOL_REF (Pmode, libfunc_name);\n+\t= gen_rtx_SYMBOL_REF (Pmode, ggc_alloc_string (libfunc_name,\n+\t\t\t\t\t\t       p - libfunc_name));\n     }\n }\n "}, {"sha": "d60b2b2227c597257f9f10d7fa47b918e8881ff0", "filename": "gcc/profile.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -1025,9 +1025,9 @@ static void\n init_edge_profiler ()\n {\n   /* Generate and save a copy of this so it can be shared.  */\n-  char *name = ggc_alloc_string (NULL, 20);\n-  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n-  profiler_label = gen_rtx_SYMBOL_REF (Pmode, name);\n+  char buf[20];\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", 2);\n+  profiler_label = gen_rtx_SYMBOL_REF (Pmode, ggc_alloc_string (buf, -1));\n   ggc_add_rtx_root (&profiler_label, 1);\n }\n \n@@ -1066,6 +1066,7 @@ output_func_start_profiler ()\n {\n   tree fnname, fndecl;\n   char *name;\n+  char buf[20];\n   const char *cfnname;\n   rtx table_address;\n   enum machine_mode mode = mode_for_size (LONG_TYPE_SIZE, MODE_INT, 0);\n@@ -1121,9 +1122,10 @@ output_func_start_profiler ()\n   expand_function_start (fndecl, 0);\n \n   /* Actually generate the code to call __bb_init_func. */\n-  name = ggc_alloc_string (NULL, 20);\n-  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 0);\n-  table_address = force_reg (Pmode, gen_rtx_SYMBOL_REF (Pmode, name));\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", 0);\n+  table_address = force_reg (Pmode,\n+\t\t\t     gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t\t ggc_alloc_string (buf, -1)));\n   emit_library_call (gen_rtx_SYMBOL_REF \n \t\t     (Pmode, ggc_alloc_string (\"__bb_init_func\", 14)), 0,\n \t\t     mode, 1, table_address, Pmode);"}, {"sha": "4ec3fd52c89920957c88ea905bd00cceb1e37e04", "filename": "gcc/stmt.c", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -394,7 +394,7 @@ struct stmt_status\n static int using_eh_for_cleanups_p = 0;\n \n /* Character strings, each containing a single decimal digit.  */\n-static char *digit_strings[10];\n+static const char *digit_strings[10];\n \n static int n_occurrences\t\tPARAMS ((int, const char *));\n static void expand_goto_internal\tPARAMS ((tree, rtx, rtx));\n@@ -598,13 +598,15 @@ void\n init_stmt ()\n {\n   int i;\n+  char buf[2];\n \n   gcc_obstack_init (&stmt_obstack);\n \n+  buf[1] = 0;\n   for (i = 0; i < 10; i++)\n     {\n-      digit_strings[i] = ggc_alloc_string (NULL, 1);\n-      digit_strings[i][0] = '0' + i;\n+      buf[0] = '0' + i;\n+      digit_strings[i] = ggc_alloc_string (buf, 1);\n     }\n   ggc_add_string_root (digit_strings, 10);\n }\n@@ -1408,7 +1410,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n     {\n       tree val = TREE_VALUE (tail);\n       tree type = TREE_TYPE (val);\n-      char *constraint;\n+      const char *constraint;\n       char *p;\n       int c_len;\n       int j;\n@@ -1425,8 +1427,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t the worst that happens if we get it wrong is we issue an error\n \t message.  */\n \n-      c_len = strlen (TREE_STRING_POINTER (TREE_PURPOSE (tail)));\n       constraint = TREE_STRING_POINTER (TREE_PURPOSE (tail));\n+      c_len = strlen (constraint);\n \n       /* Allow the `=' or `+' to not be at the beginning of the string,\n \t since it wasn't explicitly documented that way, and there is a\n@@ -1443,19 +1445,25 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  error (\"output operand constraint lacks `='\");\n \t  return;\n \t}\n+      j = p - constraint;\n+      is_inout = *p == '+';\n \n-      if (p != constraint)\n+      if (j || is_inout)\n \t{\n-\t  j = *p;\n-\t  bcopy (constraint, constraint+1, p-constraint);\n-\t  *constraint = j;\n-\n-\t  warning (\"output constraint `%c' for operand %d is not at the beginning\", j, i);\n+\t  /* Have to throw away this constraint string and get a new one.  */\n+\t  char *buf = alloca (c_len + 1);\n+\t  buf[0] = '=';\n+\t  if (j)\n+\t    memcpy (buf + 1, constraint, j);\n+\t  memcpy (buf + 1 + j, p + 1, c_len - j);  /* not -j-1 - copy null */\n+\t  constraint = ggc_alloc_string (buf, c_len);\n+\n+\t  if (j)\n+\t    warning (\n+\t\t\"output constraint `%c' for operand %d is not at the beginning\",\n+\t\t*p, i);\n \t}\n \n-      is_inout = constraint[0] == '+';\n-      /* Replace '+' with '='.  */\n-      constraint[0] = '=';\n       /* Make sure we can specify the matching operand.  */\n       if (is_inout && i > 9)\n \t{\n@@ -1611,7 +1619,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n     {\n       int j;\n       int allows_reg = 0, allows_mem = 0;\n-      char *constraint, *orig_constraint;\n+      const char *constraint, *orig_constraint;\n       int c_len;\n       rtx op;\n \n@@ -1629,8 +1637,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  return;\n \t}\n \n-      c_len = strlen (TREE_STRING_POINTER (TREE_PURPOSE (tail)));\n       constraint = TREE_STRING_POINTER (TREE_PURPOSE (tail));\n+      c_len = strlen (constraint);\n       orig_constraint = constraint;\n \n       /* Make sure constraint has neither `=', `+', nor '&'.  */\n@@ -1691,8 +1699,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t\tfor (j = constraint[j] - '0'; j > 0; --j)\n \t\t  o = TREE_CHAIN (o);\n \n-\t\tc_len = strlen (TREE_STRING_POINTER (TREE_PURPOSE (o)));\n \t\tconstraint = TREE_STRING_POINTER (TREE_PURPOSE (o));\n+\t\tc_len = strlen (constraint);\n \t\tj = 0;\n \t\tbreak;\n \t      }"}, {"sha": "32381e01ebb99a051656ac46fda1de546eebbbfa", "filename": "gcc/stringpool.c", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -0,0 +1,405 @@\n+/* String pool for GCC.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* String pool allocator.  All strings allocated by ggc_alloc_string are\n+   uniquified and stored in an obstack which is never shrunk.  You can\n+   associate a tree with a string if you wish; this is used to implement\n+   get_identifier.\n+\n+   We have our own private hash table implementation which is similar\n+   to the one in cpphash.c (actually, it's a further refinement of\n+   that code).  libiberty's hashtab.c is not used because it requires\n+   100% average space overhead per string, which is unacceptable.\n+   Also, this algorithm is faster.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"obstack.h\"\n+#include \"flags.h\"\n+#include \"toplev.h\"\n+\n+/* The \"\" allocated string.  */\n+const char empty_string[] = \"\";\n+\n+static struct obstack string_stack;\n+\n+/* This is the hash entry associated with each string.  It lives in\n+   the hash table; only the string lives in the obstack.  Note that\n+   the string is not necessarily NUL terminated.  */\n+\n+struct str_header\n+{\n+  const char *ptr;\n+  tree data;\t/* for get_identifier */\n+  unsigned int len;\n+};\n+\n+/* This is the hash table structure.  There's only one.  */\n+struct str_hash\n+{\n+  struct str_header *entries;\n+  size_t nslots;\t/* total slots in the entries array */\n+  size_t nelements;\t/* number of live elements */\n+\n+  /* table usage statistics */\n+  unsigned int searches;\n+  unsigned int collisions;\n+};\n+#define INITIAL_HASHSIZE (16*1024)\n+\n+static struct str_hash string_hash = { 0, INITIAL_HASHSIZE, 0, 0, 0 };\n+\n+enum insert_option { INSERT, NO_INSERT };\n+\n+static struct str_header *alloc_string PARAMS ((const char *, size_t,\n+\t\t\t\t\t\tenum insert_option));\n+static inline unsigned int calc_hash PARAMS ((const unsigned char *, size_t));\n+static void mark_string_hash PARAMS ((void *));\n+static struct str_header *expand_string_table PARAMS ((struct str_header *));\n+\n+/* Convenience macro for iterating over the hash table.  E is set to\n+   each live entry in turn.  */\n+#define FORALL_STRINGS(E) \\\n+for (E = string_hash.entries; E < string_hash.entries+string_hash.nslots; E++) \\\n+  if (E->ptr != NULL)\n+    /* block here */\n+\n+/* Likewise, but tests ->data instead of ->ptr (for cases where we only\n+   care about entries with ->data set)  */\n+#define FORALL_IDS(E) \\\n+for (E = string_hash.entries; E < string_hash.entries+string_hash.nslots; E++) \\\n+  if (E->data != NULL)\n+\n+/* 0 while creating built-in identifiers.  */\n+static int do_identifier_warnings;\n+\n+/* Initialize the string pool.  */\n+void\n+init_stringpool ()\n+{\n+  gcc_obstack_init (&string_stack);\n+  ggc_add_root (&string_hash, 1, sizeof string_hash, mark_string_hash);\n+\n+  /* Strings need no alignment.  */\n+  obstack_alignment_mask (&string_stack) = 0;\n+\n+  string_hash.entries = (struct str_header *)\n+    xcalloc (string_hash.nslots, sizeof (struct str_header));\n+}\n+\n+/* Enable warnings on similar identifiers (if requested).\n+   Done after the built-in identifiers are created.  */\n+void\n+start_identifier_warnings ()\n+{\n+  do_identifier_warnings = 1;\n+}\n+\n+/* Record the size of an identifier node for the language in use.\n+   SIZE is the total size in bytes.\n+   This is called by the language-specific files.  This must be\n+   called before allocating any identifiers.  */\n+void\n+set_identifier_size (size)\n+     int size;\n+{\n+  tree_code_length[(int) IDENTIFIER_NODE]\n+    = (size - sizeof (struct tree_common)) / sizeof (tree);\n+}\n+\n+/* Calculate the hash of the string STR, which is of length LEN.  */\n+static inline unsigned int\n+calc_hash (str, len)\n+     const unsigned char *str;\n+     size_t len;\n+{\n+  size_t n = len;\n+  unsigned int r = 0;\n+#define HASHSTEP(r, c) ((r) * 67 + (c - 113));\n+\n+  while (n--)\n+    r = HASHSTEP (r, *str++);\n+\n+  return r + len;\n+#undef HASHSTEP\n+}\n+\n+/* Internal primitive: returns the header structure for the string of\n+   length LENGTH, containing CONTENTS.  If that string already exists\n+   in the table, returns the existing entry.  If the string hasn't\n+   been seen before and the last argument is INSERT, inserts and returns\n+   a new entry. Otherwise returns NULL.  */\n+static struct str_header *\n+alloc_string (contents, length, insert)\n+     const char *contents;\n+     size_t length;\n+     enum insert_option insert;\n+{\n+  unsigned int hash = calc_hash ((const unsigned char *)contents, length);\n+  unsigned int hash2;\n+  unsigned int index;\n+  size_t sizemask;\n+  struct str_header *entry;\n+  struct str_header *entries = string_hash.entries;\n+\n+  sizemask = string_hash.nslots - 1;\n+  index = hash & sizemask;\n+\n+  /* hash2 must be odd, so we're guaranteed to visit every possible\n+     location in the table during rehashing.  */\n+  hash2 = ((hash * 17) & sizemask) | 1;\n+  string_hash.searches++;\n+\n+  for (;;)\n+    {\n+      entry = entries + index;\n+\n+      if (entry->ptr == NULL)\n+\tbreak;\n+\n+      if (entry->len == length\n+\t  && !memcmp (entry->ptr, contents, length))\n+\treturn entry;\n+\n+      index = (index + hash2) & sizemask;\n+      string_hash.collisions++;\n+    }\n+\n+  if (insert == NO_INSERT)\n+    return NULL;\n+\n+  obstack_grow0 (&string_stack, contents, length);\n+  entry->ptr = (const char *) obstack_finish (&string_stack);\n+  entry->len = length;\n+  entry->data = NULL;\n+\n+  if (++string_hash.nelements * 4 < string_hash.nslots * 3)\n+    return entry;\n+\n+  /* Must expand the string table.  */\n+  return expand_string_table (entry);\n+}\n+\n+/* Subroutine of alloc_string which doubles the size of the hash table\n+   and rehashes all the strings into the new table.  Returns the entry\n+   in the new table corresponding to ENTRY.  */\n+static struct str_header *\n+expand_string_table (entry)\n+     struct str_header *entry;\n+{\n+  struct str_header *nentries;\n+  struct str_header *e, *nentry = NULL;\n+  size_t size, sizemask;\n+\n+  size = string_hash.nslots * 2;\n+  nentries = (struct str_header *) xcalloc (size, sizeof (struct str_header));\n+  sizemask = size - 1;\n+\n+  FORALL_STRINGS (e)\n+    {\n+      unsigned int index, hash, hash2;\n+\n+      hash = calc_hash ((const unsigned char *) e->ptr, e->len);\n+      hash2 = ((hash * 17) & sizemask) | 1;\n+      index = hash & sizemask;\n+\n+      for (;;)\n+\t{\n+\t  if (nentries[index].ptr == NULL)\n+\t    {\n+\t      nentries[index].ptr = e->ptr;\n+\t      nentries[index].len = e->len;\n+\t      nentries[index].data = e->data;\n+\t      if (e == entry)\n+\t\tnentry = nentries + index;\n+\t      break;\n+\t    }\n+\n+\t  index = (index + hash2) & sizemask;\n+\t}\n+    }\n+\n+  free (string_hash.entries);\n+  string_hash.entries = nentries;\n+  string_hash.nslots = size;\n+  return nentry;\n+}\n+\n+/* Allocate and return a string constant of length LENGTH, containing\n+   CONTENTS.  If LENGTH is -1, CONTENTS is assumed to be a\n+   nul-terminated string, and the length is calculated using strlen.\n+   If the same string constant has been allocated before, that copy is\n+   returned this time too.  */\n+\n+const char *\n+ggc_alloc_string (contents, length)\n+     const char *contents;\n+     int length;\n+{\n+  struct str_header *str;\n+\n+  if (length == -1)\n+    length = strlen (contents);\n+\n+  if (length == 0)\n+    return empty_string;\n+\n+  str = alloc_string (contents, length, INSERT);\n+  return str->ptr;\n+}\n+\n+/* Return an IDENTIFIER_NODE whose name is TEXT (a null-terminated string).\n+   If an identifier with that name has previously been referred to,\n+   the same node is returned this time.  */\n+tree\n+get_identifier (text)\n+     const char *text;\n+{\n+  tree idp;\n+  struct str_header *str;\n+  size_t length = strlen (text);\n+\n+  str = alloc_string (text, length, INSERT);\n+  idp = str->data;\n+  if (idp == NULL)\n+    {\n+      if (TREE_CODE_LENGTH (IDENTIFIER_NODE) < 0)\n+\tabort ();\t/* set_identifier_size hasn't been called.  */\n+\n+      /* If this identifier is longer than the clash-warning length,\n+\t do a brute force search of the entire table for clashes.  */\n+      if (warn_id_clash && do_identifier_warnings && length >= (size_t) id_clash_len)\n+\t{\n+\t  struct str_header *e;\n+\t  FORALL_IDS (e)\n+\t    {\n+\t      if (e->len >= (size_t)id_clash_len\n+\t\t  && !strncmp (e->ptr, text, id_clash_len))\n+\t\t{\n+\t\t  warning (\"\\\"%s\\\" and \\\"%s\\\" identical in first %d characters\",\n+\t\t\t   text, e->ptr, id_clash_len);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      idp = make_node (IDENTIFIER_NODE);\n+      IDENTIFIER_LENGTH (idp) = length;\n+      IDENTIFIER_POINTER (idp) = str->ptr;\n+#ifdef GATHER_STATISTICS\n+      id_string_size += length;\n+#endif\n+      str->data = idp;\n+    }\n+  return idp;\n+}\n+\n+/* If an identifier with the name TEXT (a null-terminated string) has\n+   previously been referred to, return that node; otherwise return\n+   NULL_TREE.  */\n+\n+tree\n+maybe_get_identifier (text)\n+     const char *text;\n+{\n+  struct str_header *str;\n+  size_t length = strlen (text);\n+\n+  str = alloc_string (text, length, NO_INSERT);\n+  if (str)\n+    return str->data;  /* N.B. str->data might be null here, if the\n+\t\t\t  string has been used but not as an identifier.  */\n+  return NULL_TREE;\n+}\n+\n+/* Report some basic statistics about the string pool.  */\n+\n+void\n+stringpool_statistics ()\n+{\n+  size_t nelts, overhead, headers;\n+  size_t total_bytes, longest, sum_of_squares;\n+  double exp_len, exp_len2, exp2_len;\n+  struct str_header *e;\n+#define SCALE(x) ((unsigned long) ((x) < 1024*10 \\\n+\t\t  ? (x) \\\n+\t\t  : ((x) < 1024*1024*10 \\\n+\t\t     ? (x) / 1024 \\\n+\t\t     : (x) / (1024*1024))))\n+#define LABEL(x) ((x) < 1024*10 ? ' ' : ((x) < 1024*1024*10 ? 'k' : 'M'))\n+\n+  total_bytes = longest = sum_of_squares = 0;\n+  FORALL_STRINGS (e)\n+    {\n+      size_t n = e->len;\n+\n+      total_bytes += n;\n+      sum_of_squares += n*n;\n+      if (n > longest)\n+\tlongest = n;\n+    }\n+      \n+  nelts = string_hash.nelements;\n+  overhead = obstack_memory_used (&string_stack) - total_bytes;\n+  headers = string_hash.nslots * sizeof (struct str_header);\n+\n+  fprintf (stderr,\n+\"\\nString pool\\n\\\n+entries\\t\\t%lu\\n\\\n+slots\\t\\t%lu\\n\\\n+bytes\\t\\t%lu%c (%lu%c overhead)\\n\\\n+table size\\t%lu%c\\n\",\n+\t   (unsigned long) nelts, (unsigned long) string_hash.nslots,\n+\t   SCALE (total_bytes), LABEL (total_bytes),\n+\t   SCALE (overhead), LABEL (overhead),\n+\t   SCALE (headers), LABEL (headers));\n+\n+  exp_len = (double)total_bytes / (double)nelts;\n+  exp2_len = exp_len * exp_len;\n+  exp_len2 = (double)sum_of_squares / (double)nelts;\n+\n+  fprintf (stderr,\n+\"coll/search\\t%.4f\\n\\\n+ins/search\\t%.4f\\n\\\n+avg. entry\\t%.2f bytes (+/- %.2f)\\n\\\n+longest entry\\t%lu\\n\",\n+\t   (double) string_hash.collisions / (double) string_hash.searches,\n+\t   (double) nelts / (double) string_hash.searches,\n+\t   exp_len, approx_sqrt (exp_len2 - exp2_len),\n+\t   (unsigned long) longest);\n+#undef SCALE\n+#undef LABEL\n+}\n+\n+/* Mark the string hash for GC.  */\n+\n+static void\n+mark_string_hash (arg)\n+     void *arg ATTRIBUTE_UNUSED;\n+{\n+  struct str_header *h;\n+\n+  FORALL_IDS (h)\n+    {\n+      ggc_mark_tree (h->data);\n+    }\n+}"}, {"sha": "592d5fc36045eb1b117ddc11cad6ceb5fbb6c14b", "filename": "gcc/toplev.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -1577,6 +1577,29 @@ floor_log2_wide (x)\n   return log;\n }\n \n+/* Return the approximate positive square root of a number N.  This is for\n+   statistical reports, not code generation.  */\n+double\n+approx_sqrt (x)\n+     double x;\n+{\n+  double s, d;\n+\n+  if (x < 0)\n+    abort ();   \n+  if (x == 0)\n+    return 0;\n+\n+  s = x;\n+  do\n+    {\n+      d = (s * s - x) / (2 * s);\n+      s -= d;                   \n+    }        \n+  while (d > .0001);\n+  return s;\n+}\n+\n static int float_handler_set;\n int float_handled;\n jmp_buf float_handler;\n@@ -2516,7 +2539,10 @@ compile_file (name)\n     }\n \n   if (mem_report)\n-    ggc_print_statistics ();\n+    {\n+      ggc_print_statistics ();\n+      stringpool_statistics ();\n+    }\n \n   /* Free up memory for the benefit of leak detectors.  */\n   free_reg_info ();\n@@ -4085,7 +4111,7 @@ decode_f_option (arg)\n   else if ((option_value\n \t    = skip_leading_substring (arg, \"stack-limit-symbol=\")))\n     {\n-      char *nm;\n+      const char *nm;\n       nm = ggc_strdup (option_value);\n       stack_limit_rtx = gen_rtx_SYMBOL_REF (Pmode, nm);\n     }\n@@ -4557,6 +4583,7 @@ main (argc, argv)\n \n   /* Initialize the garbage-collector.  */\n   init_ggc ();\n+  init_stringpool ();\n   ggc_add_root (&input_file_stack, 1, sizeof input_file_stack,\n \t\tmark_file_stack);\n   ggc_add_rtx_root (&stack_limit_rtx, 1);"}, {"sha": "28f791b0eba5d110c33ab3e26a074a966259c8ce", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 139, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -131,14 +131,6 @@ static const char * const tree_node_kind_names[] = {\n   \"lang_type kinds\"\n };\n \n-/* Hash table for uniquizing IDENTIFIER_NODEs by name.  */\n-\n-#define MAX_HASH_TABLE 1009\n-static tree hash_table[MAX_HASH_TABLE];\t/* id hash buckets */\n-\n-/* 0 while creating built-in identifiers.  */\n-static int do_identifier_warnings;\n-\n /* Unique id for next decl created.  */\n static int next_decl_uid;\n /* Unique id for next type created.  */\n@@ -191,7 +183,7 @@ void (*lang_unsave_expr_now) PARAMS ((tree));\n    built-in tree nodes.  The variable, which is dynamically allocated,\n    should be used; the macro is only used to initialize it.  */\n \n-static char *built_in_filename;\n+static const char *built_in_filename;\n #define BUILT_IN_FILENAME (\"<built-in>\")\n \f\n tree global_trees[TI_MAX];\n@@ -204,10 +196,6 @@ init_obstacks ()\n {\n   gcc_obstack_init (&permanent_obstack);\n \n-  /* Init the hash table of identifiers.  */\n-  memset ((char *) hash_table, 0, sizeof hash_table);\n-  ggc_add_tree_root (hash_table, sizeof hash_table / sizeof (tree));\n-\n   /* Initialize the hash table of types.  */\n   type_hash_table = htab_create (TYPE_HASH_INITIAL_SIZE, type_hash_hash,\n \t\t\t\t type_hash_eq, 0);\n@@ -555,133 +543,7 @@ copy_list (list)\n     }\n   return head;\n }\n-\f\n-#define HASHBITS 30\n-\n-/* Return an IDENTIFIER_NODE whose name is TEXT (a null-terminated string).\n-   If an identifier with that name has previously been referred to,\n-   the same node is returned this time.  */\n-\n-tree\n-get_identifier (text)\n-     register const char *text;\n-{\n-  register int hi;\n-  register int i;\n-  register tree idp;\n-  register int len, hash_len;\n-\n-  /* Compute length of text in len.  */\n-  len = strlen (text);\n-\n-  /* Decide how much of that length to hash on */\n-  hash_len = len;\n-  if (warn_id_clash && len > id_clash_len)\n-    hash_len = id_clash_len;\n-\n-  /* Compute hash code */\n-  hi = hash_len * 613 + (unsigned) text[0];\n-  for (i = 1; i < hash_len; i += 2)\n-    hi = ((hi * 613) + (unsigned) (text[i]));\n-\n-  hi &= (1 << HASHBITS) - 1;\n-  hi %= MAX_HASH_TABLE;\n-\n-  /* Search table for identifier.  */\n-  for (idp = hash_table[hi]; idp; idp = TREE_CHAIN (idp))\n-    if (IDENTIFIER_LENGTH (idp) == len\n-\t&& IDENTIFIER_POINTER (idp)[0] == text[0]\n-\t&& !memcmp (IDENTIFIER_POINTER (idp), text, len))\n-      /* Return if found.  */\n-      return idp;\n-\n-  /* Not found; optionally warn about a similar identifier.  */\n-  if (warn_id_clash && do_identifier_warnings && len >= id_clash_len)\n-    for (idp = hash_table[hi]; idp; idp = TREE_CHAIN (idp))\n-      if (!strncmp (IDENTIFIER_POINTER (idp), text, id_clash_len))\n-\t{\n-\t  warning (\"`%s' and `%s' identical in first %d characters\",\n-\t\t   IDENTIFIER_POINTER (idp), text, id_clash_len);\n-\t  break;\n-\t}\n-\n-  if (TREE_CODE_LENGTH (IDENTIFIER_NODE) < 0)\n-    abort ();\t\t\t/* set_identifier_size hasn't been called.  */\n-\n-  /* Not found, create one, add to chain */\n-  idp = make_node (IDENTIFIER_NODE);\n-  IDENTIFIER_LENGTH (idp) = len;\n-#ifdef GATHER_STATISTICS\n-  id_string_size += len;\n-#endif\n-\n-  IDENTIFIER_POINTER (idp) = ggc_alloc_string (text, len);\n-\n-  TREE_CHAIN (idp) = hash_table[hi];\n-  hash_table[hi] = idp;\n-  return idp;\t\t\t/* <-- return if created */\n-}\n \n-/* If an identifier with the name TEXT (a null-terminated string) has\n-   previously been referred to, return that node; otherwise return\n-   NULL_TREE.  */\n-\n-tree\n-maybe_get_identifier (text)\n-     register const char *text;\n-{\n-  register int hi;\n-  register int i;\n-  register tree idp;\n-  register int len, hash_len;\n-\n-  /* Compute length of text in len.  */\n-  len = strlen (text);\n-\n-  /* Decide how much of that length to hash on */\n-  hash_len = len;\n-  if (warn_id_clash && len > id_clash_len)\n-    hash_len = id_clash_len;\n-\n-  /* Compute hash code */\n-  hi = hash_len * 613 + (unsigned) text[0];\n-  for (i = 1; i < hash_len; i += 2)\n-    hi = ((hi * 613) + (unsigned) (text[i]));\n-\n-  hi &= (1 << HASHBITS) - 1;\n-  hi %= MAX_HASH_TABLE;\n-\n-  /* Search table for identifier.  */\n-  for (idp = hash_table[hi]; idp; idp = TREE_CHAIN (idp))\n-    if (IDENTIFIER_LENGTH (idp) == len\n-\t&& IDENTIFIER_POINTER (idp)[0] == text[0]\n-\t&& !memcmp (IDENTIFIER_POINTER (idp), text, len))\n-      return idp;\t\t/* <-- return if found */\n-\n-  return NULL_TREE;\n-}\n-\n-/* Enable warnings on similar identifiers (if requested).\n-   Done after the built-in identifiers are created.  */\n-\n-void\n-start_identifier_warnings ()\n-{\n-  do_identifier_warnings = 1;\n-}\n-\n-/* Record the size of an identifier node for the language in use.\n-   SIZE is the total size in bytes.\n-   This is called by the language-specific files.  This must be\n-   called before allocating any identifiers.  */\n-\n-void\n-set_identifier_size (size)\n-     int size;\n-{\n-  tree_code_length[(int) IDENTIFIER_NODE]\n-    = (size - sizeof (struct tree_common)) / sizeof (tree);\n-}\n \f\n /* Return a newly constructed INTEGER_CST node whose constant value\n    is specified by the two ints LOW and HI."}, {"sha": "8f0737649aa559bdd7901309b10cca9f0fd55419", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -713,7 +713,7 @@ struct tree_string\n   struct rtx_def *rtl;\t/* acts as link to register transfer language\n \t\t\t\t   (rtl) info */\n   int length;\n-  char *pointer;\n+  const char *pointer;\n };\n \n /* In a COMPLEX_CST node.  */\n@@ -1852,6 +1852,10 @@ extern tree integer_types[itk_none];\n extern int exact_log2_wide             PARAMS ((unsigned HOST_WIDE_INT));\n extern int floor_log2_wide             PARAMS ((unsigned HOST_WIDE_INT));\n \n+/* Approximate positive square root of a host double.  This is for\n+   statistical reports, not code generation.  */\n+extern double approx_sqrt\t\tPARAMS ((double));\n+\n extern char *permalloc\t\t\tPARAMS ((int));\n extern char *expralloc\t\t\tPARAMS ((int));\n "}, {"sha": "b7d33b2f2b7ba2e65ffaf2a37094d1b1fa30a72c", "filename": "gcc/varasm.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520a57c81c83affcccb71eef52da0278991af777/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=520a57c81c83affcccb71eef52da0278991af777", "patch": "@@ -213,7 +213,7 @@ static enum in_section { no_section, in_text, in_data, in_named\n #endif\n      \n /* Text of section name when in_section == in_named.  */\n-static char *in_named_name;\n+static const char *in_named_name;\n \n /* Define functions like text_section for any extra sections.  */\n #ifdef EXTRA_SECTION_FUNCTIONS\n@@ -1798,7 +1798,7 @@ assemble_static_space (size)\n      int size;\n {\n   char name[12];\n-  char *namestring;\n+  const char *namestring;\n   rtx x;\n \n #if 0\n@@ -2330,7 +2330,7 @@ struct rtx_const\n struct constant_descriptor\n {\n   struct constant_descriptor *next;\n-  char *label;\n+  const char *label;\n   rtx rtl;\n   /* Make sure the data is reasonably aligned.  */\n   union \n@@ -2352,7 +2352,7 @@ static struct constant_descriptor *const_hash_table[MAX_HASH_TABLE];\n \n struct deferred_string\n {\n-  char *label;\n+  const char *label;\n   tree exp;\n   int labelno;\n };\n@@ -3335,7 +3335,7 @@ struct pool_constant\n {\n   struct constant_descriptor *desc;\n   struct pool_constant *next, *next_sym;\n-  char *label;\n+  const char *label;\n   rtx constant;\n   enum machine_mode mode;\n   int labelno;\n@@ -3613,7 +3613,7 @@ force_const_mem (mode, x)\n   register int hash;\n   register struct constant_descriptor *desc;\n   char label[256];\n-  char *found = 0;\n+  const char *found = 0;\n   rtx def;\n \n   /* If we want this CONST_DOUBLE in the same mode as it is in memory"}]}