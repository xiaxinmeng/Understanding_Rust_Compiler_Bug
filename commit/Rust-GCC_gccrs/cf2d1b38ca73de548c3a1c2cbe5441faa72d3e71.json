{"sha": "cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YyZDFiMzhjYTczZGU1NDhjM2ExYzJjYmU1NDQxZmFhNzJkM2U3MQ==", "commit": {"author": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-10-02T13:19:29Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-10-02T13:19:29Z"}, "message": "tree-flow.h: Include new .h files.\n\n\n\t* tree-flow.h: Include new .h files.  Move prototypes.\n\t* tree-cfgcleanup.h: New file.  Add prototypes from tree-flow.h.\n\t* tree-dfa.h: New File.  Add prototypes from tree-flow.h.\n\t(get_addr_base_and_unit_offset_1) Move from tree-flow-inline.h.\n\t* tree-pretty-print.h: Add prototypes from tree-flow.h.\n\t* tree-into-ssa.h: New File.  Add prototypes from tree-flow.h.\n\t({debug|dump}*): Move debugging prototypes out of tree-into-ssa.c.\n\t* tree-into-ssa.c ({debug|dump}*): Move prototypes to header file.\n\t* tree.h (get_ref_base_and_extent): Move prototype out.\n\t* tree-flow-inline.h (get_addr_base_and_unit_offset_1): Move to \n\ttree-dfa.h.\n\t* gimple-low.h: New File.  Add prototypes from tree-flow.h.\n\t* gimple-low.c (try_catch_may_fallthru, block_may_fallthru): Move to...\n\t* tree.c (try_catch_may_fallthru, block_may_fallthru): Here.\n\t* tree-scalar-evolution.c: Include tree.h.\n\t* sese.c: Include tree.h.\n\t* dumpfile.c: Move gimple-pretty-print.h include after tree.h.\n\t* dwarf2out.c: Include tree-dfa.h.\n\t* tree-chrec.c: Include tree.h.\n\t* tree-data-ref.c: Include tree.h.\n\nFrom-SVN: r203113", "tree": {"sha": "375ad6b99eeeb983ea0bb3b3219f6c281da0b899", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/375ad6b99eeeb983ea0bb3b3219f6c281da0b899"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/comments", "author": null, "committer": null, "parents": [{"sha": "1d2151c67a26096c792c6f6be9d1bac3a8cce703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d2151c67a26096c792c6f6be9d1bac3a8cce703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d2151c67a26096c792c6f6be9d1bac3a8cce703"}], "stats": {"total": 849, "additions": 438, "deletions": 411}, "files": [{"sha": "4a19b6d464881bbd2437e23bf83b2a6d8fa1f5d1", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -22,8 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"diagnostic-core.h\"\n #include \"dumpfile.h\"\n-#include \"gimple-pretty-print.h\"\n #include \"tree.h\"\n+#include \"gimple-pretty-print.h\"\n \n /* If non-NULL, return one past-the-end of the matching SUBPART of\n    the WHOLE string.  */"}, {"sha": "723317b8e6adf46a2bb9d4c73d7a50edf14fdb9d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -92,6 +92,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lra.h\"\n #include \"dumpfile.h\"\n #include \"opts.h\"\n+#include \"tree-dfa.h\"\n \n static void dwarf2out_source_line (unsigned int, const char *, int, bool);\n static rtx last_var_location_insn;"}, {"sha": "8e083aeb4d78ccbf2991be6747db46041f234aaa", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 2, "deletions": 124, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -598,56 +598,9 @@ lower_try_catch (gimple_stmt_iterator *gsi, struct lower_data *data)\n   gsi_next (gsi);\n }\n \n-/* Try to determine whether a TRY_CATCH expression can fall through.\n-   This is a subroutine of block_may_fallthru.  */\n-\n-static bool\n-try_catch_may_fallthru (const_tree stmt)\n-{\n-  tree_stmt_iterator i;\n-\n-  /* If the TRY block can fall through, the whole TRY_CATCH can\n-     fall through.  */\n-  if (block_may_fallthru (TREE_OPERAND (stmt, 0)))\n-    return true;\n-\n-  i = tsi_start (TREE_OPERAND (stmt, 1));\n-  switch (TREE_CODE (tsi_stmt (i)))\n-    {\n-    case CATCH_EXPR:\n-      /* We expect to see a sequence of CATCH_EXPR trees, each with a\n-\t catch expression and a body.  The whole TRY_CATCH may fall\n-\t through iff any of the catch bodies falls through.  */\n-      for (; !tsi_end_p (i); tsi_next (&i))\n-\t{\n-\t  if (block_may_fallthru (CATCH_BODY (tsi_stmt (i))))\n-\t    return true;\n-\t}\n-      return false;\n-\n-    case EH_FILTER_EXPR:\n-      /* The exception filter expression only matters if there is an\n-\t exception.  If the exception does not match EH_FILTER_TYPES,\n-\t we will execute EH_FILTER_FAILURE, and we will fall through\n-\t if that falls through.  If the exception does match\n-\t EH_FILTER_TYPES, the stack unwinder will continue up the\n-\t stack, so we will not fall through.  We don't know whether we\n-\t will throw an exception which matches EH_FILTER_TYPES or not,\n-\t so we just ignore EH_FILTER_TYPES and assume that we might\n-\t throw an exception which doesn't match.  */\n-      return block_may_fallthru (EH_FILTER_FAILURE (tsi_stmt (i)));\n \n-    default:\n-      /* This case represents statements to be executed when an\n-\t exception occurs.  Those statements are implicitly followed\n-\t by a RESX statement to resume execution after the exception.\n-\t So in this case the TRY_CATCH never falls through.  */\n-      return false;\n-    }\n-}\n-\n-\n-/* Same as above, but for a GIMPLE_TRY_CATCH.  */\n+/* Try to determine whether a TRY_CATCH expression can fall through.\n+   This is a subroutine of gimple_stmt_may_fallthru.  */\n \n static bool\n gimple_try_catch_may_fallthru (gimple stmt)\n@@ -698,81 +651,6 @@ gimple_try_catch_may_fallthru (gimple stmt)\n }\n \n \n-/* Try to determine if we can fall out of the bottom of BLOCK.  This guess\n-   need not be 100% accurate; simply be conservative and return true if we\n-   don't know.  This is used only to avoid stupidly generating extra code.\n-   If we're wrong, we'll just delete the extra code later.  */\n-\n-bool\n-block_may_fallthru (const_tree block)\n-{\n-  /* This CONST_CAST is okay because expr_last returns its argument\n-     unmodified and we assign it to a const_tree.  */\n-  const_tree stmt = expr_last (CONST_CAST_TREE (block));\n-\n-  switch (stmt ? TREE_CODE (stmt) : ERROR_MARK)\n-    {\n-    case GOTO_EXPR:\n-    case RETURN_EXPR:\n-      /* Easy cases.  If the last statement of the block implies\n-\t control transfer, then we can't fall through.  */\n-      return false;\n-\n-    case SWITCH_EXPR:\n-      /* If SWITCH_LABELS is set, this is lowered, and represents a\n-\t branch to a selected label and hence can not fall through.\n-\t Otherwise SWITCH_BODY is set, and the switch can fall\n-\t through.  */\n-      return SWITCH_LABELS (stmt) == NULL_TREE;\n-\n-    case COND_EXPR:\n-      if (block_may_fallthru (COND_EXPR_THEN (stmt)))\n-\treturn true;\n-      return block_may_fallthru (COND_EXPR_ELSE (stmt));\n-\n-    case BIND_EXPR:\n-      return block_may_fallthru (BIND_EXPR_BODY (stmt));\n-\n-    case TRY_CATCH_EXPR:\n-      return try_catch_may_fallthru (stmt);\n-\n-    case TRY_FINALLY_EXPR:\n-      /* The finally clause is always executed after the try clause,\n-\t so if it does not fall through, then the try-finally will not\n-\t fall through.  Otherwise, if the try clause does not fall\n-\t through, then when the finally clause falls through it will\n-\t resume execution wherever the try clause was going.  So the\n-\t whole try-finally will only fall through if both the try\n-\t clause and the finally clause fall through.  */\n-      return (block_may_fallthru (TREE_OPERAND (stmt, 0))\n-\t      && block_may_fallthru (TREE_OPERAND (stmt, 1)));\n-\n-    case MODIFY_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR)\n-\tstmt = TREE_OPERAND (stmt, 1);\n-      else\n-\treturn true;\n-      /* FALLTHRU */\n-\n-    case CALL_EXPR:\n-      /* Functions that do not return do not fall through.  */\n-      return (call_expr_flags (stmt) & ECF_NORETURN) == 0;\n-\n-    case CLEANUP_POINT_EXPR:\n-      return block_may_fallthru (TREE_OPERAND (stmt, 0));\n-\n-    case TARGET_EXPR:\n-      return block_may_fallthru (TREE_OPERAND (stmt, 1));\n-\n-    case ERROR_MARK:\n-      return true;\n-\n-    default:\n-      return lang_hooks.block_may_fallthru (stmt);\n-    }\n-}\n-\n-\n /* Try to determine if we can continue executing the statement\n    immediately following STMT.  This guess need not be 100% accurate;\n    simply be conservative and return true if we don't know.  This is"}, {"sha": "b66de2ef2c2cf25a120c90b5be82298461ad0306", "filename": "gcc/gimple-low.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Fgimple-low.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Fgimple-low.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.h?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -0,0 +1,29 @@\n+/* Header file for gimple lowering pass.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_LOW_H\n+#define GCC_GIMPLE_LOW_H\n+\n+extern bool gimple_check_call_matching_types (gimple, tree, bool);\n+extern bool gimple_stmt_may_fallthru (gimple);\n+extern bool gimple_seq_may_fallthru (gimple_seq);\n+extern void record_vars_into (tree, tree);\n+extern void record_vars (tree);\n+\n+#endif /* GCC_GIMPLE_LOW_H */"}, {"sha": "c861b23d9372b3653372aa5a2d92aceb279239f2", "filename": "gcc/sese.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"hash-table.h\"\n+#include \"tree.h\"\n #include \"tree-pretty-print.h\"\n #include \"tree-ssa.h\"\n #include \"cfgloop.h\""}, {"sha": "6bd3c3940ec38370c498e8a46f4f5f2e001b58f4", "filename": "gcc/tree-cfgcleanup.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-cfgcleanup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-cfgcleanup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.h?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -0,0 +1,28 @@\n+/* Header file for CFG cleanup for trees.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_CFGCLEANUP_H\n+#define GCC_TREE_CFGCLEANUP_H\n+\n+/* In tree-cfgcleanup.c  */\n+extern bitmap cfgcleanup_altered_bbs;\n+extern bool cleanup_tree_cfg (void);\n+extern bool fixup_noreturn_call (gimple stmt);\n+\n+#endif /* GCC_TREE_CFGCLEANUP_H */"}, {"sha": "64f2dcb13bfc068598654d1a16ce835221616484", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"tree.h\"\n #include \"tree-pretty-print.h\"\n #include \"cfgloop.h\"\n #include \"tree-ssa.h\""}, {"sha": "9133df4a2b75eac8015d88a36602f326917e661e", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -76,6 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"tree.h\"\n #include \"gimple-pretty-print.h\"\n #include \"tree-ssa.h\"\n #include \"cfgloop.h\""}, {"sha": "7d0a47009f63e9d9f61b0bb2f6772ec8c55d5d72", "filename": "gcc/tree-dfa.h", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-dfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-dfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.h?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -0,0 +1,184 @@\n+/* Header file for tree data flow functions.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_DFA_H\n+#define GCC_TREE_DFA_H\n+\n+extern void renumber_gimple_stmt_uids (void);\n+extern void renumber_gimple_stmt_uids_in_blocks (basic_block *, int);\n+extern void dump_variable (FILE *, tree);\n+extern void debug_variable (tree);\n+extern void dump_dfa_stats (FILE *);\n+extern void debug_dfa_stats (void);\n+extern tree ssa_default_def (struct function *, tree);\n+extern void set_ssa_default_def (struct function *, tree, tree);\n+extern tree get_or_create_ssa_default_def (struct function *, tree);\n+extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n+\t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern tree get_addr_base_and_unit_offset (tree, HOST_WIDE_INT *);\n+extern bool stmt_references_abnormal_ssa_name (gimple);\n+extern void dump_enumerated_decls (FILE *, int);\n+\n+/* Returns the base object and a constant BITS_PER_UNIT offset in *POFFSET that\n+   denotes the starting address of the memory access EXP.\n+   Returns NULL_TREE if the offset is not constant or any component\n+   is not BITS_PER_UNIT-aligned.\n+   VALUEIZE if non-NULL is used to valueize SSA names.  It should return\n+   its argument or a constant if the argument is known to be constant.  */\n+/* ??? This is a static inline here to avoid the overhead of the indirect calls\n+   to VALUEIZE.  But is this overhead really that significant?  And should we\n+   perhaps just rely on WHOPR to specialize the function?  */\n+\n+static inline tree\n+get_addr_base_and_unit_offset_1 (tree exp, HOST_WIDE_INT *poffset,\n+\t\t\t\t tree (*valueize) (tree))\n+{\n+  HOST_WIDE_INT byte_offset = 0;\n+\n+  /* Compute cumulative byte-offset for nested component-refs and array-refs,\n+     and find the ultimate containing object.  */\n+  while (1)\n+    {\n+      switch (TREE_CODE (exp))\n+\t{\n+\tcase BIT_FIELD_REF:\n+\t  {\n+\t    HOST_WIDE_INT this_off = TREE_INT_CST_LOW (TREE_OPERAND (exp, 2));\n+\t    if (this_off % BITS_PER_UNIT)\n+\t      return NULL_TREE;\n+\t    byte_offset += this_off / BITS_PER_UNIT;\n+\t  }\n+\t  break;\n+\n+\tcase COMPONENT_REF:\n+\t  {\n+\t    tree field = TREE_OPERAND (exp, 1);\n+\t    tree this_offset = component_ref_field_offset (exp);\n+\t    HOST_WIDE_INT hthis_offset;\n+\n+\t    if (!this_offset\n+\t\t|| TREE_CODE (this_offset) != INTEGER_CST\n+\t\t|| (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n+\t\t    % BITS_PER_UNIT))\n+\t      return NULL_TREE;\n+\n+\t    hthis_offset = TREE_INT_CST_LOW (this_offset);\n+\t    hthis_offset += (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n+\t\t\t     / BITS_PER_UNIT);\n+\t    byte_offset += hthis_offset;\n+\t  }\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\t  {\n+\t    tree index = TREE_OPERAND (exp, 1);\n+\t    tree low_bound, unit_size;\n+\n+\t    if (valueize\n+\t\t&& TREE_CODE (index) == SSA_NAME)\n+\t      index = (*valueize) (index);\n+\n+\t    /* If the resulting bit-offset is constant, track it.  */\n+\t    if (TREE_CODE (index) == INTEGER_CST\n+\t\t&& (low_bound = array_ref_low_bound (exp),\n+\t\t    TREE_CODE (low_bound) == INTEGER_CST)\n+\t\t&& (unit_size = array_ref_element_size (exp),\n+\t\t    TREE_CODE (unit_size) == INTEGER_CST))\n+\t      {\n+\t\tHOST_WIDE_INT hindex = TREE_INT_CST_LOW (index);\n+\n+\t\thindex -= TREE_INT_CST_LOW (low_bound);\n+\t\thindex *= TREE_INT_CST_LOW (unit_size);\n+\t\tbyte_offset += hindex;\n+\t      }\n+\t    else\n+\t      return NULL_TREE;\n+\t  }\n+\t  break;\n+\n+\tcase REALPART_EXPR:\n+\t  break;\n+\n+\tcase IMAGPART_EXPR:\n+\t  byte_offset += TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (exp)));\n+\t  break;\n+\n+\tcase VIEW_CONVERT_EXPR:\n+\t  break;\n+\n+\tcase MEM_REF:\n+\t  {\n+\t    tree base = TREE_OPERAND (exp, 0);\n+\t    if (valueize\n+\t\t&& TREE_CODE (base) == SSA_NAME)\n+\t      base = (*valueize) (base);\n+\n+\t    /* Hand back the decl for MEM[&decl, off].  */\n+\t    if (TREE_CODE (base) == ADDR_EXPR)\n+\t      {\n+\t\tif (!integer_zerop (TREE_OPERAND (exp, 1)))\n+\t\t  {\n+\t\t    double_int off = mem_ref_offset (exp);\n+\t\t    gcc_assert (off.high == -1 || off.high == 0);\n+\t\t    byte_offset += off.to_shwi ();\n+\t\t  }\n+\t\texp = TREE_OPERAND (base, 0);\n+\t      }\n+\t    goto done;\n+\t  }\n+\n+\tcase TARGET_MEM_REF:\n+\t  {\n+\t    tree base = TREE_OPERAND (exp, 0);\n+\t    if (valueize\n+\t\t&& TREE_CODE (base) == SSA_NAME)\n+\t      base = (*valueize) (base);\n+\n+\t    /* Hand back the decl for MEM[&decl, off].  */\n+\t    if (TREE_CODE (base) == ADDR_EXPR)\n+\t      {\n+\t\tif (TMR_INDEX (exp) || TMR_INDEX2 (exp))\n+\t\t  return NULL_TREE;\n+\t\tif (!integer_zerop (TMR_OFFSET (exp)))\n+\t\t  {\n+\t\t    double_int off = mem_ref_offset (exp);\n+\t\t    gcc_assert (off.high == -1 || off.high == 0);\n+\t\t    byte_offset += off.to_shwi ();\n+\t\t  }\n+\t\texp = TREE_OPERAND (base, 0);\n+\t      }\n+\t    goto done;\n+\t  }\n+\n+\tdefault:\n+\t  goto done;\n+\t}\n+\n+      exp = TREE_OPERAND (exp, 0);\n+    }\n+done:\n+\n+  *poffset = byte_offset;\n+  return exp;\n+}\n+\n+\n+\n+#endif /* GCC_TREE_DFA_H */"}, {"sha": "164df957315e0b380e5e364c000f6e472654d9e7", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -42,52 +42,6 @@ gimple_vop (const struct function *fun)\n   return fun->gimple_df->vop;\n }\n \n-/* Initialize the hashtable iterator HTI to point to hashtable TABLE */\n-\n-static inline void *\n-first_htab_element (htab_iterator *hti, htab_t table)\n-{\n-  hti->htab = table;\n-  hti->slot = table->entries;\n-  hti->limit = hti->slot + htab_size (table);\n-  do\n-    {\n-      PTR x = *(hti->slot);\n-      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n-\tbreak;\n-    } while (++(hti->slot) < hti->limit);\n-\n-  if (hti->slot < hti->limit)\n-    return *(hti->slot);\n-  return NULL;\n-}\n-\n-/* Return current non-empty/deleted slot of the hashtable pointed to by HTI,\n-   or NULL if we have  reached the end.  */\n-\n-static inline bool\n-end_htab_p (const htab_iterator *hti)\n-{\n-  if (hti->slot >= hti->limit)\n-    return true;\n-  return false;\n-}\n-\n-/* Advance the hashtable iterator pointed to by HTI to the next element of the\n-   hashtable.  */\n-\n-static inline void *\n-next_htab_element (htab_iterator *hti)\n-{\n-  while (++(hti->slot) < hti->limit)\n-    {\n-      PTR x = *(hti->slot);\n-      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n-\treturn x;\n-    };\n-  return NULL;\n-}\n-\n /* Get the number of the next statement uid to be allocated.  */\n static inline unsigned int\n gimple_stmt_max_uid (struct function *fn)\n@@ -240,149 +194,4 @@ gimple_ssa_operands (const struct function *fun)\n   return &fun->gimple_df->ssa_operands;\n }\n \n-\n-/* Returns the base object and a constant BITS_PER_UNIT offset in *POFFSET that\n-   denotes the starting address of the memory access EXP.\n-   Returns NULL_TREE if the offset is not constant or any component\n-   is not BITS_PER_UNIT-aligned.\n-   VALUEIZE if non-NULL is used to valueize SSA names.  It should return\n-   its argument or a constant if the argument is known to be constant.  */\n-/* ??? This is a static inline here to avoid the overhead of the indirect calls\n-   to VALUEIZE.  But is this overhead really that significant?  And should we\n-   perhaps just rely on WHOPR to specialize the function?  */\n-\n-static inline tree\n-get_addr_base_and_unit_offset_1 (tree exp, HOST_WIDE_INT *poffset,\n-\t\t\t\t tree (*valueize) (tree))\n-{\n-  HOST_WIDE_INT byte_offset = 0;\n-\n-  /* Compute cumulative byte-offset for nested component-refs and array-refs,\n-     and find the ultimate containing object.  */\n-  while (1)\n-    {\n-      switch (TREE_CODE (exp))\n-\t{\n-\tcase BIT_FIELD_REF:\n-\t  {\n-\t    HOST_WIDE_INT this_off = TREE_INT_CST_LOW (TREE_OPERAND (exp, 2));\n-\t    if (this_off % BITS_PER_UNIT)\n-\t      return NULL_TREE;\n-\t    byte_offset += this_off / BITS_PER_UNIT;\n-\t  }\n-\t  break;\n-\n-\tcase COMPONENT_REF:\n-\t  {\n-\t    tree field = TREE_OPERAND (exp, 1);\n-\t    tree this_offset = component_ref_field_offset (exp);\n-\t    HOST_WIDE_INT hthis_offset;\n-\n-\t    if (!this_offset\n-\t\t|| TREE_CODE (this_offset) != INTEGER_CST\n-\t\t|| (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n-\t\t    % BITS_PER_UNIT))\n-\t      return NULL_TREE;\n-\n-\t    hthis_offset = TREE_INT_CST_LOW (this_offset);\n-\t    hthis_offset += (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n-\t\t\t     / BITS_PER_UNIT);\n-\t    byte_offset += hthis_offset;\n-\t  }\n-\t  break;\n-\n-\tcase ARRAY_REF:\n-\tcase ARRAY_RANGE_REF:\n-\t  {\n-\t    tree index = TREE_OPERAND (exp, 1);\n-\t    tree low_bound, unit_size;\n-\n-\t    if (valueize\n-\t\t&& TREE_CODE (index) == SSA_NAME)\n-\t      index = (*valueize) (index);\n-\n-\t    /* If the resulting bit-offset is constant, track it.  */\n-\t    if (TREE_CODE (index) == INTEGER_CST\n-\t\t&& (low_bound = array_ref_low_bound (exp),\n-\t\t    TREE_CODE (low_bound) == INTEGER_CST)\n-\t\t&& (unit_size = array_ref_element_size (exp),\n-\t\t    TREE_CODE (unit_size) == INTEGER_CST))\n-\t      {\n-\t\tHOST_WIDE_INT hindex = TREE_INT_CST_LOW (index);\n-\n-\t\thindex -= TREE_INT_CST_LOW (low_bound);\n-\t\thindex *= TREE_INT_CST_LOW (unit_size);\n-\t\tbyte_offset += hindex;\n-\t      }\n-\t    else\n-\t      return NULL_TREE;\n-\t  }\n-\t  break;\n-\n-\tcase REALPART_EXPR:\n-\t  break;\n-\n-\tcase IMAGPART_EXPR:\n-\t  byte_offset += TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (exp)));\n-\t  break;\n-\n-\tcase VIEW_CONVERT_EXPR:\n-\t  break;\n-\n-\tcase MEM_REF:\n-\t  {\n-\t    tree base = TREE_OPERAND (exp, 0);\n-\t    if (valueize\n-\t\t&& TREE_CODE (base) == SSA_NAME)\n-\t      base = (*valueize) (base);\n-\n-\t    /* Hand back the decl for MEM[&decl, off].  */\n-\t    if (TREE_CODE (base) == ADDR_EXPR)\n-\t      {\n-\t\tif (!integer_zerop (TREE_OPERAND (exp, 1)))\n-\t\t  {\n-\t\t    double_int off = mem_ref_offset (exp);\n-\t\t    gcc_assert (off.high == -1 || off.high == 0);\n-\t\t    byte_offset += off.to_shwi ();\n-\t\t  }\n-\t\texp = TREE_OPERAND (base, 0);\n-\t      }\n-\t    goto done;\n-\t  }\n-\n-\tcase TARGET_MEM_REF:\n-\t  {\n-\t    tree base = TREE_OPERAND (exp, 0);\n-\t    if (valueize\n-\t\t&& TREE_CODE (base) == SSA_NAME)\n-\t      base = (*valueize) (base);\n-\n-\t    /* Hand back the decl for MEM[&decl, off].  */\n-\t    if (TREE_CODE (base) == ADDR_EXPR)\n-\t      {\n-\t\tif (TMR_INDEX (exp) || TMR_INDEX2 (exp))\n-\t\t  return NULL_TREE;\n-\t\tif (!integer_zerop (TMR_OFFSET (exp)))\n-\t\t  {\n-\t\t    double_int off = mem_ref_offset (exp);\n-\t\t    gcc_assert (off.high == -1 || off.high == 0);\n-\t\t    byte_offset += off.to_shwi ();\n-\t\t  }\n-\t\texp = TREE_OPERAND (base, 0);\n-\t      }\n-\t    goto done;\n-\t  }\n-\n-\tdefault:\n-\t  goto done;\n-\t}\n-\n-      exp = TREE_OPERAND (exp, 0);\n-    }\n-done:\n-\n-  *poffset = byte_offset;\n-  return exp;\n-}\n-\n #endif /* _TREE_FLOW_INLINE_H  */"}, {"sha": "d3a4e33b921a81f122650de7720fd98416d96461", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 59, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -30,7 +30,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"ipa-reference.h\"\n #include \"tree-ssa-alias.h\"\n-\n+#include \"tree-cfgcleanup.h\"\n+#include \"tree-dfa.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"gimple-low.h\"\n+#include \"tree-into-ssa.h\"\n \n /* This structure is used to map a gimple statement to a label,\n    or list of labels to represent transaction restart.  */\n@@ -92,21 +96,6 @@ struct GTY(()) gimple_df {\n   htab_t GTY ((param_is (struct tm_restart_node))) tm_restart;\n };\n \n-\n-typedef struct\n-{\n-  htab_t htab;\n-  PTR *slot;\n-  PTR *limit;\n-} htab_iterator;\n-\n-/* Iterate through the elements of hashtable HTAB, using htab_iterator ITER,\n-   storing each element in RESULT, which is of type TYPE.  */\n-#define FOR_EACH_HTAB_ELEMENT(HTAB, RESULT, TYPE, ITER) \\\n-  for (RESULT = (TYPE) first_htab_element (&(ITER), (HTAB)); \\\n-\t!end_htab_p (&(ITER)); \\\n-\tRESULT = (TYPE) next_htab_element (&(ITER)))\n-\n static inline int get_lineno (const_gimple);\n \n /*---------------------------------------------------------------------------\n@@ -255,48 +244,6 @@ extern basic_block move_sese_region_to_fn (struct function *, basic_block,\n void remove_edge_and_dominated_blocks (edge);\n bool tree_node_can_be_shared (tree);\n \n-/* In tree-cfgcleanup.c  */\n-extern bitmap cfgcleanup_altered_bbs;\n-extern bool cleanup_tree_cfg (void);\n-\n-/* In tree-pretty-print.c.  */\n-extern void dump_generic_bb (FILE *, basic_block, int, int);\n-extern int op_code_prio (enum tree_code);\n-extern int op_prio (const_tree);\n-extern const char *op_symbol_code (enum tree_code);\n-\n-/* In tree-dfa.c  */\n-extern void renumber_gimple_stmt_uids (void);\n-extern void renumber_gimple_stmt_uids_in_blocks (basic_block *, int);\n-extern void dump_dfa_stats (FILE *);\n-extern void debug_dfa_stats (void);\n-extern void dump_variable (FILE *, tree);\n-extern void debug_variable (tree);\n-extern void set_ssa_default_def (struct function *, tree, tree);\n-extern tree ssa_default_def (struct function *, tree);\n-extern tree get_or_create_ssa_default_def (struct function *, tree);\n-extern bool stmt_references_abnormal_ssa_name (gimple);\n-extern tree get_addr_base_and_unit_offset (tree, HOST_WIDE_INT *);\n-extern void dump_enumerated_decls (FILE *, int);\n-\n-/* In gimple-low.c  */\n-extern void record_vars_into (tree, tree);\n-extern void record_vars (tree);\n-extern bool gimple_seq_may_fallthru (gimple_seq);\n-extern bool gimple_stmt_may_fallthru (gimple);\n-extern bool gimple_check_call_matching_types (gimple, tree, bool);\n-\n-/* In tree-into-ssa.c  */\n-void update_ssa (unsigned);\n-void delete_update_ssa (void);\n-tree create_new_def_for (tree, gimple, def_operand_p);\n-bool need_ssa_update_p (struct function *);\n-bool name_registered_for_update_p (tree);\n-void release_ssa_name_after_update_ssa (tree);\n-void mark_virtual_operands_for_renaming (struct function *);\n-tree get_current_def (tree);\n-void set_current_def (tree, tree);\n-\n /* In tree-ssa-ccp.c  */\n tree fold_const_aggregate_ref (tree);\n tree gimple_fold_stmt_to_constant (gimple, tree (*)(tree));\n@@ -539,7 +486,6 @@ void get_address_description (tree, struct mem_address *);\n tree maybe_fold_tmr (tree);\n \n unsigned int execute_fixup_cfg (void);\n-bool fixup_noreturn_call (gimple stmt);\n \n /* In ipa-pure-const.c  */\n void warn_function_noreturn (tree);"}, {"sha": "2f5ac69251ef01c65e8b2d3e783af543f5ebf44b", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"domwalk.h\"\n #include \"params.h\"\n #include \"diagnostic-core.h\"\n+#include \"tree-into-ssa.h\"\n \n \n /* This file builds the SSA form for a function as described in:\n@@ -253,27 +254,6 @@ enum rewrite_mode {\n     REWRITE_UPDATE\n };\n \n-\n-\n-\n-/* Prototypes for debugging functions.  */\n-extern void dump_tree_ssa (FILE *);\n-extern void debug_tree_ssa (void);\n-extern void debug_def_blocks (void);\n-extern void dump_tree_ssa_stats (FILE *);\n-extern void debug_tree_ssa_stats (void);\n-extern void dump_update_ssa (FILE *);\n-extern void debug_update_ssa (void);\n-extern void dump_names_replaced_by (FILE *, tree);\n-extern void debug_names_replaced_by (tree);\n-extern void dump_var_infos (FILE *);\n-extern void debug_var_infos (void);\n-extern void dump_defs_stack (FILE *, int);\n-extern void debug_defs_stack (int);\n-extern void dump_currdefs (FILE *);\n-extern void debug_currdefs (void);\n-\n-\n /* The set of symbols we ought to re-write into SSA form in update_ssa.  */\n static bitmap symbols_to_rename_set;\n static vec<tree> symbols_to_rename;"}, {"sha": "0c44f046697c99e42c2f8f1e163381ebdb61407e", "filename": "gcc/tree-into-ssa.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-into-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-into-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.h?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -0,0 +1,50 @@\n+/* Header file for normal form into SSA.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_INTO_SSA_H\n+#define GCC_TREE_INTO_SSA_H\n+\n+extern tree get_current_def (tree);\n+extern void set_current_def (tree, tree);\n+void delete_update_ssa (void);\n+tree create_new_def_for (tree, gimple, def_operand_p);\n+void mark_virtual_operands_for_renaming (struct function *);\n+bool need_ssa_update_p (struct function *);\n+bool name_registered_for_update_p (tree);\n+void release_ssa_name_after_update_ssa (tree);\n+void update_ssa (unsigned);\n+\n+/* Prototypes for debugging functions.  */\n+extern void debug_decl_set (bitmap set);\n+extern void dump_defs_stack (FILE *, int);\n+extern void debug_defs_stack (int);\n+extern void dump_currdefs (FILE *);\n+extern void debug_currdefs (void);\n+extern void dump_tree_ssa (FILE *);\n+extern void debug_tree_ssa (void);\n+extern void dump_tree_ssa_stats (FILE *);\n+extern void debug_tree_ssa_stats (void);\n+extern void dump_var_infos (FILE *);\n+extern void debug_var_infos (void);\n+extern void dump_names_replaced_by (FILE *, tree);\n+extern void debug_names_replaced_by (tree);\n+extern void dump_update_ssa (FILE *);\n+extern void debug_update_ssa (void);\n+\n+#endif /* GCC_TREE_INTO_SSA_H */"}, {"sha": "f70556db03de7609a6b46ed9335d9d3465329976", "filename": "gcc/tree-pretty-print.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.h?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -31,24 +31,24 @@ along with GCC; see the file COPYING3.  If not see\n \n #define pp_ti_abstract_origin(TI) ((tree *) (TI)->x_data)\n \n-extern void pp_tree_identifier (pretty_printer *, tree);\n \n-/* In tree-pretty-print.c  */\n-extern void print_declaration (pretty_printer *, tree, int, int);\n-extern int dump_generic_node (pretty_printer *, tree, int, int, bool);\n+extern void debug_generic_expr (tree);\n+extern void debug_generic_stmt (tree);\n+extern void debug_tree_chain (tree);\n+extern void print_generic_decl (FILE *, tree, int);\n extern void print_generic_stmt (FILE *, tree, int);\n extern void print_generic_stmt_indented (FILE *, tree, int, int);\n extern void print_generic_expr (FILE *, tree, int);\n-extern void print_generic_decl (FILE *, tree, int);\n extern void dump_omp_clauses (pretty_printer *, tree, int, int);\n+extern int dump_generic_node (pretty_printer *, tree, int, int, bool);\n+extern void print_declaration (pretty_printer *, tree, int, int);\n+extern int op_code_prio (enum tree_code);\n+extern int op_prio (const_tree);\n+extern const char *op_symbol_code (enum tree_code);\n extern void print_call_name (pretty_printer *, tree, int);\n-extern void debug_generic_expr (tree);\n-extern void debug_generic_stmt (tree);\n-extern void debug_tree_chain (tree);\n extern void percent_K_format (text_info *);\n+extern void pp_tree_identifier (pretty_printer *, tree);\n extern void dump_function_header (FILE *, tree, int);\n extern void pp_double_int (pretty_printer *pp, double_int d, bool uns);\n-/* In c-pretty-print.c  */\n-extern void debug_c_tree (tree);\n \n #endif /* ! GCC_TREE_PRETTY_PRINT_H */"}, {"sha": "f85353c22bd8938c3e7ef7143385ca51c4346203", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -256,6 +256,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"tree.h\"\n #include \"hash-table.h\"\n #include \"gimple-pretty-print.h\"\n #include \"tree-ssa.h\""}, {"sha": "705332f878c694ac3ac9c0b42e855d2bc4545129", "filename": "gcc/tree.c", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -12125,4 +12125,126 @@ contains_bitfld_component_ref_p (const_tree ref)\n   return false;\n }\n \n+/* Try to determine whether a TRY_CATCH expression can fall through.\n+   This is a subroutine of block_may_fallthru.  */\n+\n+static bool\n+try_catch_may_fallthru (const_tree stmt)\n+{\n+  tree_stmt_iterator i;\n+\n+  /* If the TRY block can fall through, the whole TRY_CATCH can\n+     fall through.  */\n+  if (block_may_fallthru (TREE_OPERAND (stmt, 0)))\n+    return true;\n+\n+  i = tsi_start (TREE_OPERAND (stmt, 1));\n+  switch (TREE_CODE (tsi_stmt (i)))\n+    {\n+    case CATCH_EXPR:\n+      /* We expect to see a sequence of CATCH_EXPR trees, each with a\n+\t catch expression and a body.  The whole TRY_CATCH may fall\n+\t through iff any of the catch bodies falls through.  */\n+      for (; !tsi_end_p (i); tsi_next (&i))\n+\t{\n+\t  if (block_may_fallthru (CATCH_BODY (tsi_stmt (i))))\n+\t    return true;\n+\t}\n+      return false;\n+\n+    case EH_FILTER_EXPR:\n+      /* The exception filter expression only matters if there is an\n+\t exception.  If the exception does not match EH_FILTER_TYPES,\n+\t we will execute EH_FILTER_FAILURE, and we will fall through\n+\t if that falls through.  If the exception does match\n+\t EH_FILTER_TYPES, the stack unwinder will continue up the\n+\t stack, so we will not fall through.  We don't know whether we\n+\t will throw an exception which matches EH_FILTER_TYPES or not,\n+\t so we just ignore EH_FILTER_TYPES and assume that we might\n+\t throw an exception which doesn't match.  */\n+      return block_may_fallthru (EH_FILTER_FAILURE (tsi_stmt (i)));\n+\n+    default:\n+      /* This case represents statements to be executed when an\n+\t exception occurs.  Those statements are implicitly followed\n+\t by a RESX statement to resume execution after the exception.\n+\t So in this case the TRY_CATCH never falls through.  */\n+      return false;\n+    }\n+}\n+\n+/* Try to determine if we can fall out of the bottom of BLOCK.  This guess\n+   need not be 100% accurate; simply be conservative and return true if we\n+   don't know.  This is used only to avoid stupidly generating extra code.\n+   If we're wrong, we'll just delete the extra code later.  */\n+\n+bool\n+block_may_fallthru (const_tree block)\n+{\n+  /* This CONST_CAST is okay because expr_last returns its argument\n+     unmodified and we assign it to a const_tree.  */\n+  const_tree stmt = expr_last (CONST_CAST_TREE (block));\n+\n+  switch (stmt ? TREE_CODE (stmt) : ERROR_MARK)\n+    {\n+    case GOTO_EXPR:\n+    case RETURN_EXPR:\n+      /* Easy cases.  If the last statement of the block implies\n+\t control transfer, then we can't fall through.  */\n+      return false;\n+\n+    case SWITCH_EXPR:\n+      /* If SWITCH_LABELS is set, this is lowered, and represents a\n+\t branch to a selected label and hence can not fall through.\n+\t Otherwise SWITCH_BODY is set, and the switch can fall\n+\t through.  */\n+      return SWITCH_LABELS (stmt) == NULL_TREE;\n+\n+    case COND_EXPR:\n+      if (block_may_fallthru (COND_EXPR_THEN (stmt)))\n+\treturn true;\n+      return block_may_fallthru (COND_EXPR_ELSE (stmt));\n+\n+    case BIND_EXPR:\n+      return block_may_fallthru (BIND_EXPR_BODY (stmt));\n+\n+    case TRY_CATCH_EXPR:\n+      return try_catch_may_fallthru (stmt);\n+\n+    case TRY_FINALLY_EXPR:\n+      /* The finally clause is always executed after the try clause,\n+\t so if it does not fall through, then the try-finally will not\n+\t fall through.  Otherwise, if the try clause does not fall\n+\t through, then when the finally clause falls through it will\n+\t resume execution wherever the try clause was going.  So the\n+\t whole try-finally will only fall through if both the try\n+\t clause and the finally clause fall through.  */\n+      return (block_may_fallthru (TREE_OPERAND (stmt, 0))\n+\t      && block_may_fallthru (TREE_OPERAND (stmt, 1)));\n+\n+    case MODIFY_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR)\n+\tstmt = TREE_OPERAND (stmt, 1);\n+      else\n+\treturn true;\n+      /* FALLTHRU */\n+\n+    case CALL_EXPR:\n+      /* Functions that do not return do not fall through.  */\n+      return (call_expr_flags (stmt) & ECF_NORETURN) == 0;\n+\n+    case CLEANUP_POINT_EXPR:\n+      return block_may_fallthru (TREE_OPERAND (stmt, 0));\n+\n+    case TARGET_EXPR:\n+      return block_may_fallthru (TREE_OPERAND (stmt, 1));\n+\n+    case ERROR_MARK:\n+      return true;\n+\n+    default:\n+      return lang_hooks.block_may_fallthru (stmt);\n+    }\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "a71cd96414f6d145f623e6014a6521b17251cfda", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=cf2d1b38ca73de548c3a1c2cbe5441faa72d3e71", "patch": "@@ -4528,10 +4528,9 @@ extern tree get_binfo_at_offset (tree, HOST_WIDE_INT, tree);\n extern bool virtual_method_call_p (tree);\n extern tree obj_type_ref_class (tree ref);\n extern bool types_same_for_odr (tree type1, tree type2);\n-extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n-\t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);\n extern bool contains_bitfld_component_ref_p (const_tree);\n extern bool type_in_anonymous_namespace_p (tree);\n+extern bool block_may_fallthru (const_tree);\n \n /* In tree-nested.c */\n extern tree build_addr (tree, tree);\n@@ -4880,9 +4879,6 @@ is_lang_specific (tree t)\n   return TREE_CODE (t) == LANG_TYPE || TREE_CODE (t) >= NUM_TREE_CODES;\n }\n \n-/* In gimple-low.c.  */\n-extern bool block_may_fallthru (const_tree);\n-\n /* In vtable-verify.c.  */\n extern void save_vtable_map_decl (tree);\n "}]}