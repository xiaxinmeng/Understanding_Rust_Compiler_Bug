{"sha": "279e32c924988609c7b48d70b681b492a142b66a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc5ZTMyYzkyNDk4ODYwOWM3YjQ4ZDcwYjY4MWI0OTJhMTQyYjY2YQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2007-08-17T22:08:04Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2007-08-17T22:08:04Z"}, "message": "typeck.c (find_method_in_interfaces): Update.\n\n\t* typeck.c (find_method_in_interfaces): Update.\n\t* jcf-parse.c (load_class): Update.\n\t* java-gimplify.c (java_gimplify_component_ref): Removed.\n\t(java_gimplify_modify_expr): Update.  Removed pre_p and post_p\n\targuments.\n\t(java_gimplify_expr): Update.\n\t* decl.c (java_init_decl_processing): Update.\n\t* class.c (set_constant_value): Update.\n\t(make_class_data): Update.\n\t(finish_class): Update.\n\t(build_static_field_ref): Update.\n\t(is_compiled_class): Update.\n\t(maybe_layout_super_class): Update.\n\t(layout_class): Update.\n\t(layout_class_method): Update.\n\t* java-tree.h (CAN_COMPLETE_NORMALLY): Removed.\n\t(lang_decl_var) <am, final_iud, cif>: Removed fields.\n\t(lang_decl_func) <init_calls_this>: Removed field.\n\t(lang_type) <dot_class, verify_method>: Removed fields.\n\t(FIELD_NESTED_ACCESS): Removed.\n\t(FIELD_NESTED_ACCESS_P): Removed.\n\t(DECL_FIELD_FINAL_IUD): Removed.\n\t(DECL_LOCAL_FINAL_IUD): Removed\n\t(LOCAL_FINAL_P): Removed.\n\t(FINAL_VARIABLE_P): Removed.\n\t(CLASS_FINAL_VARIABLE_P): Removed.\n\t(DECL_BIT_INDEX): Removed.\n\t(DECL_INIT_CALLS_THIS): Removed.\n\t(FIELD_LOCAL_ALIAS): Removed.\n\t(FIELD_LOCAL_ALIAS_USED): Removed.\n\t(FIELD_THISN): Removed.\n\t(DECL_FUNCTION_INIT_TEST_CLASS): Removed.\n\t(LOCAL_CLASS_INITIALIZATION_FLAG): Removed.\n\t(LOCAL_CLASS_INITIALIZATION_FLAG_P): Removed.\n\t(TYPE_DOT_CLASS): Removed.\n\t(TYPE_VERIFY_METHOD): Removed.\n\t(ID_CLASSDOLLAR_P): Removed.\n\t(enum java_tree_index) <JTI_CLASSDOLLAR_IDENTIFIER_NODE>:\n\tRemoved.\n\t(classdollar_identifier_node): Removed.\n\t(TYPE_UNKNOWN): Removed.\n\t(CLASS_FROM_SOURCE_P): Removed.\n\t* expr.c (build_jni_stub): Update.\n\t(force_evaluation_order): Update.\n\t(build_java_empty_stmt): Update.\n\t(build_class_init): Update.\n\t(java_stack_swap): Update.\n\t(build_jni_stub): Update.\n\nFrom-SVN: r127602", "tree": {"sha": "70cc3ddb26fc919cb7189d6ea58e391a6b723fd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70cc3ddb26fc919cb7189d6ea58e391a6b723fd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/279e32c924988609c7b48d70b681b492a142b66a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279e32c924988609c7b48d70b681b492a142b66a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/279e32c924988609c7b48d70b681b492a142b66a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279e32c924988609c7b48d70b681b492a142b66a/comments", "author": null, "committer": null, "parents": [{"sha": "44fd0e80635189f48f24654cb1e9620c39d5314b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fd0e80635189f48f24654cb1e9620c39d5314b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44fd0e80635189f48f24654cb1e9620c39d5314b"}], "stats": {"total": 328, "additions": 77, "deletions": 251}, "files": [{"sha": "cd919b35acb5078984331606fd3cb383b61bbf3a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=279e32c924988609c7b48d70b681b492a142b66a", "patch": "@@ -1,3 +1,54 @@\n+2007-08-17  Tom Tromey  <tromey@redhat.com>\n+\n+\t* typeck.c (find_method_in_interfaces): Update.\n+\t* jcf-parse.c (load_class): Update.\n+\t* java-gimplify.c (java_gimplify_component_ref): Removed.\n+\t(java_gimplify_modify_expr): Update.  Removed pre_p and post_p\n+\targuments.\n+\t(java_gimplify_expr): Update.\n+\t* decl.c (java_init_decl_processing): Update.\n+\t* class.c (set_constant_value): Update.\n+\t(make_class_data): Update.\n+\t(finish_class): Update.\n+\t(build_static_field_ref): Update.\n+\t(is_compiled_class): Update.\n+\t(maybe_layout_super_class): Update.\n+\t(layout_class): Update.\n+\t(layout_class_method): Update.\n+\t* java-tree.h (CAN_COMPLETE_NORMALLY): Removed.\n+\t(lang_decl_var) <am, final_iud, cif>: Removed fields.\n+\t(lang_decl_func) <init_calls_this>: Removed field.\n+\t(lang_type) <dot_class, verify_method>: Removed fields.\n+\t(FIELD_NESTED_ACCESS): Removed.\n+\t(FIELD_NESTED_ACCESS_P): Removed.\n+\t(DECL_FIELD_FINAL_IUD): Removed.\n+\t(DECL_LOCAL_FINAL_IUD): Removed\n+\t(LOCAL_FINAL_P): Removed.\n+\t(FINAL_VARIABLE_P): Removed.\n+\t(CLASS_FINAL_VARIABLE_P): Removed.\n+\t(DECL_BIT_INDEX): Removed.\n+\t(DECL_INIT_CALLS_THIS): Removed.\n+\t(FIELD_LOCAL_ALIAS): Removed.\n+\t(FIELD_LOCAL_ALIAS_USED): Removed.\n+\t(FIELD_THISN): Removed.\n+\t(DECL_FUNCTION_INIT_TEST_CLASS): Removed.\n+\t(LOCAL_CLASS_INITIALIZATION_FLAG): Removed.\n+\t(LOCAL_CLASS_INITIALIZATION_FLAG_P): Removed.\n+\t(TYPE_DOT_CLASS): Removed.\n+\t(TYPE_VERIFY_METHOD): Removed.\n+\t(ID_CLASSDOLLAR_P): Removed.\n+\t(enum java_tree_index) <JTI_CLASSDOLLAR_IDENTIFIER_NODE>:\n+\tRemoved.\n+\t(classdollar_identifier_node): Removed.\n+\t(TYPE_UNKNOWN): Removed.\n+\t(CLASS_FROM_SOURCE_P): Removed.\n+\t* expr.c (build_jni_stub): Update.\n+\t(force_evaluation_order): Update.\n+\t(build_java_empty_stmt): Update.\n+\t(build_class_init): Update.\n+\t(java_stack_swap): Update.\n+\t(build_jni_stub): Update.\n+\n 2007-08-17  Tom Tromey  <tromey@redhat.com>\n \n \t* java-tree.h (LABEL_TYPE_STATE): Removed."}, {"sha": "82b71b4df18253c78febb668719b3e3a91e89d9d", "filename": "gcc/java/class.c", "status": "modified", "additions": 17, "deletions": 42, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=279e32c924988609c7b48d70b681b492a142b66a", "patch": "@@ -851,8 +851,6 @@ set_constant_value (tree field, tree constant)\n \t\t&& TREE_TYPE (field) == string_ptr_type_node))\n \terror (\"ConstantValue attribute of field '%s' has wrong type\",\n \t       IDENTIFIER_POINTER (DECL_NAME (field)));\n-      if (FIELD_FINAL (field))\n-\tDECL_FIELD_FINAL_IUD (field) = 1;\n     }\n }\n \n@@ -1163,13 +1161,12 @@ build_static_field_ref (tree fdecl)\n {\n   tree fclass = DECL_CONTEXT (fdecl);\n   int is_compiled = is_compiled_class (fclass);\n-  int from_class = ! CLASS_FROM_SOURCE_P (current_class);\n \n   /* Allow static final fields to fold to a constant.  When using\n      -findirect-dispatch, we simply never do this folding if compiling\n      from .class; in the .class file constants will be referred to via\n      the constant pool.  */\n-  if ((!flag_indirect_dispatch || !from_class)\n+  if (!flag_indirect_dispatch\n       && (is_compiled\n \t  || (FIELD_FINAL (fdecl) && DECL_INITIAL (fdecl) != NULL_TREE\n \t      && (JSTRING_TYPE_P (TREE_TYPE (fdecl))\n@@ -1853,8 +1850,7 @@ make_class_data (tree type)\n           || DECL_CLINIT_P (method)\n           || DECL_NAME (type_decl) == id_class\n           || DECL_NAME (method) == id_main\n-          || (METHOD_PUBLIC (method) && !METHOD_STATIC (method))\n-          || TYPE_DOT_CLASS (type) == method)\n+          || (METHOD_PUBLIC (method) && !METHOD_STATIC (method)))\n         {\n           init = make_method_value (method);\n           method_count++;\n@@ -2173,17 +2169,6 @@ make_class_data (tree type)\n void\n finish_class (void)\n {\n-  if (TYPE_VERIFY_METHOD (output_class))\n-    {\n-      tree verify_method = TYPE_VERIFY_METHOD (output_class);\n-      DECL_SAVED_TREE (verify_method) \n-\t= add_stmt_to_compound (DECL_SAVED_TREE (verify_method), void_type_node,\n-\t\t\t\tbuild1 (RETURN_EXPR, void_type_node, NULL));\n-      java_genericize (verify_method);\n-      cgraph_finalize_function (verify_method, false);\n-      TYPE_ASSERTIONS (current_class) = NULL;\n-    }\n-\n   java_expand_catch_classes (current_class);\n \n   current_function_decl = NULL_TREE;\n@@ -2228,9 +2213,7 @@ is_compiled_class (tree class)\n     {\n       if (!CLASS_LOADED_P (class))\n \t{\n-\t  if (CLASS_FROM_SOURCE_P (class))\n-\t    safe_layout_class (class);\n-\t  else if (class != current_class)\n+\t  if (class != current_class)\n \t    load_class (class, 1);\n \t}\n       return 1;\n@@ -2327,8 +2310,6 @@ maybe_layout_super_class (tree super_class, tree this_class ATTRIBUTE_UNUSED)\n     return NULL_TREE;\n   else if (TREE_CODE (super_class) == RECORD_TYPE)\n     {\n-      if (!CLASS_LOADED_P (super_class) && CLASS_FROM_SOURCE_P (super_class))\n-\tsafe_layout_class (super_class);\n       if (!CLASS_LOADED_P (super_class))\n \tload_class (super_class, 1);\n     }\n@@ -2366,6 +2347,7 @@ safe_layout_class (tree class)\n void\n layout_class (tree this_class)\n {\n+  int i;\n   tree super_class = CLASSTYPE_SUPER (this_class);\n \n   class_list = tree_cons (this_class, NULL_TREE, class_list);\n@@ -2416,28 +2398,22 @@ layout_class (tree this_class)\n \n   layout_type (this_class);\n \n-  /* Also recursively load/layout any superinterfaces, but only if\n-     class was loaded from bytecode.  The source parser will take care\n-     of this itself.  */\n-  if (!CLASS_FROM_SOURCE_P (this_class))\n+  /* Also recursively load/layout any superinterfaces.  */\n+  if (TYPE_BINFO (this_class))\n     {\n-      int i;\n-            if (TYPE_BINFO (this_class))\n+      for (i = BINFO_N_BASE_BINFOS (TYPE_BINFO (this_class)) - 1; i > 0; i--)\n \t{\n-\t  for (i = BINFO_N_BASE_BINFOS (TYPE_BINFO (this_class)) - 1; i > 0; i--)\n+\t  tree binfo = BINFO_BASE_BINFO (TYPE_BINFO (this_class), i);\n+\t  tree super_interface = BINFO_TYPE (binfo);\n+\t  tree maybe_super_interface \n+\t    = maybe_layout_super_class (super_interface, NULL_TREE);\n+\t  if (maybe_super_interface == NULL\n+\t      || TREE_CODE (TYPE_SIZE (maybe_super_interface)) == ERROR_MARK)\n \t    {\n-\t      tree binfo = BINFO_BASE_BINFO (TYPE_BINFO (this_class), i);\n-\t      tree super_interface = BINFO_TYPE (binfo);\n-\t      tree maybe_super_interface \n-\t\t= maybe_layout_super_class (super_interface, NULL_TREE);\n-\t      if (maybe_super_interface == NULL\n-\t\t  || TREE_CODE (TYPE_SIZE (maybe_super_interface)) == ERROR_MARK)\n-\t\t{\n-\t\t  TYPE_SIZE (this_class) = error_mark_node;\n-\t\t  CLASS_BEING_LAIDOUT (this_class) = 0;\n-\t\t  class_list = TREE_CHAIN (class_list);\n-\t\t  return;\n-\t\t}\n+\t      TYPE_SIZE (this_class) = error_mark_node;\n+\t      CLASS_BEING_LAIDOUT (this_class) = 0;\n+\t      class_list = TREE_CHAIN (class_list);\n+\t      return;\n \t    }\n \t}\n     }\n@@ -2632,7 +2608,6 @@ layout_class_method (tree this_class, tree super_class,\n \t  set_method_index (method_decl, method_index);\n \t  if (method_index == NULL_TREE \n \t      && ! flag_indirect_dispatch\n-\t      && !CLASS_FROM_SOURCE_P (this_class)\n \t      && ! DECL_ARTIFICIAL (super_method))\n \t    error (\"non-static method %q+D overrides static method\",\n                    method_decl);"}, {"sha": "8a6b0149ce5c95e12396cd832f29da5d6b73ebfd", "filename": "gcc/java/decl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=279e32c924988609c7b48d70b681b492a142b66a", "patch": "@@ -737,7 +737,6 @@ java_init_decl_processing (void)\n   void_signature_node = get_identifier (\"()V\");\n   finalize_identifier_node = get_identifier (\"finalize\");\n   this_identifier_node = get_identifier (\"this\");\n-  classdollar_identifier_node = get_identifier (\"class$\");\n \n   java_lang_cloneable_identifier_node = get_identifier (\"java.lang.Cloneable\");\n   java_io_serializable_identifier_node ="}, {"sha": "af49adbe8d69c62dad0cc6e9f69263cb9533c0de", "filename": "gcc/java/expr.c", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=279e32c924988609c7b48d70b681b492a142b66a", "patch": "@@ -638,9 +638,8 @@ java_stack_swap (void)\n   tree decl1, decl2;\n \n   if (stack_pointer < 2\n-      || (type1 = stack_type_map[stack_pointer - 1]) == TYPE_UNKNOWN\n-      || (type2 = stack_type_map[stack_pointer - 2]) == TYPE_UNKNOWN\n-      || type1 == TYPE_SECOND || type2 == TYPE_SECOND\n+      || (type1 = stack_type_map[stack_pointer - 1]) == TYPE_SECOND\n+      || (type2 = stack_type_map[stack_pointer - 2]) == TYPE_SECOND\n       || TYPE_IS_WIDE (type1) || TYPE_IS_WIDE (type2))\n     /* Bad stack swap.  */\n     abort ();\n@@ -1998,13 +1997,7 @@ build_class_init (tree clas, tree expr)\n \t  decl = build_decl (VAR_DECL, NULL_TREE,\n \t\t\t     boolean_type_node);\n \t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n-\t  LOCAL_CLASS_INITIALIZATION_FLAG (decl) = 1;\n \t  DECL_CONTEXT (decl) = current_function_decl;\n-\t  DECL_FUNCTION_INIT_TEST_CLASS (decl) = clas;\n-\t  /* Tell the check-init code to ignore this decl when not\n-             optimizing class initialization. */\n-\t  if (!STATIC_CLASS_INIT_OPT_P ())\n-\t    DECL_BIT_INDEX (decl) = -1;\n \t  DECL_INITIAL (decl) = boolean_false_node;\n \t  /* Don't emit any symbolic debugging info for this decl.  */\n \t  DECL_IGNORED_P (decl) = 1;\t  \n@@ -2621,7 +2614,6 @@ build_jni_stub (tree method)\n   int args_size = 0;\n \n   tree klass = DECL_CONTEXT (method);\n-  int from_class = ! CLASS_FROM_SOURCE_P (klass);\n   klass = build_class_ref (klass);\n \n   gcc_assert (METHOD_NATIVE (method) && flag_jni);\n@@ -2651,25 +2643,16 @@ build_jni_stub (tree method)\n   chainon (env_var, meth_var);\n   build_result_decl (method);\n \n-  /* One strange way that the front ends are different is that they\n-     store arguments differently.  */\n-  if (from_class)\n-    method_args = DECL_ARGUMENTS (method);\n-  else\n-    method_args = BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (method));\n+  method_args = DECL_ARGUMENTS (method);\n   block = build_block (env_var, NULL_TREE, method_args, NULL_TREE);\n   TREE_SIDE_EFFECTS (block) = 1;\n-  /* When compiling from source we don't set the type of the block,\n-     because that will prevent patch_return from ever being run.  */\n-  if (from_class)\n-    TREE_TYPE (block) = TREE_TYPE (TREE_TYPE (method));\n+  TREE_TYPE (block) = TREE_TYPE (TREE_TYPE (method));\n \n   /* Compute the local `env' by calling _Jv_GetJNIEnvNewFrame.  */\n   body = build2 (MODIFY_EXPR, ptr_type_node, env_var,\n \t\t build_call_nary (ptr_type_node,\n \t\t\t\t  build_address_of (soft_getjnienvnewframe_node),\n \t\t\t\t  1, klass));\n-  CAN_COMPLETE_NORMALLY (body) = 1;\n \n   /* All the arguments to this method become arguments to the\n      underlying JNI function.  If we had to wrap object arguments in a\n@@ -2756,7 +2739,6 @@ build_jni_stub (tree method)\n     }\n \n   TREE_SIDE_EFFECTS (call) = 1;\n-  CAN_COMPLETE_NORMALLY (call) = 1;\n \n   body = build2 (COMPOUND_EXPR, void_type_node, body, call);\n   TREE_SIDE_EFFECTS (body) = 1;\n@@ -2766,7 +2748,6 @@ build_jni_stub (tree method)\n \t\t\t  build_address_of (soft_jnipopsystemframe_node),\n \t\t\t  1, env_var);\n   TREE_SIDE_EFFECTS (call) = 1;\n-  CAN_COMPLETE_NORMALLY (call) = 1;\n   body = build2 (COMPOUND_EXPR, void_type_node, body, call);\n   TREE_SIDE_EFFECTS (body) = 1;\n \n@@ -3750,7 +3731,6 @@ force_evaluation_order (tree node)\n \t  cmp = build2 (COMPOUND_EXPR, TREE_TYPE (node), cmp, node);\n \t  if (TREE_TYPE (cmp) != void_type_node)\n \t    cmp = save_expr (cmp);\n-\t  CAN_COMPLETE_NORMALLY (cmp) = CAN_COMPLETE_NORMALLY (node);\n \t  TREE_SIDE_EFFECTS (cmp) = 1;\n \t  node = cmp;\n \t}\n@@ -3764,7 +3744,6 @@ tree\n build_java_empty_stmt (void)\n {\n   tree t = build_empty_stmt ();\n-  CAN_COMPLETE_NORMALLY (t) = 1;\n   return t;\n }\n "}, {"sha": "5358241135310acd664fd4474c47a5cf9ad8c708", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 3, "deletions": 90, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=279e32c924988609c7b48d70b681b492a142b66a", "patch": "@@ -32,8 +32,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"toplev.h\"\n \n static tree java_gimplify_block (tree);\n-static enum gimplify_status java_gimplify_modify_expr (tree*, tree*, tree *);\n-static enum gimplify_status java_gimplify_component_ref (tree*, tree*, tree *);\n+static enum gimplify_status java_gimplify_modify_expr (tree *);\n static enum gimplify_status java_gimplify_self_mod_expr (tree*, tree*, tree *);\n \n static void dump_java_tree (enum tree_dump_index, tree);\n@@ -73,7 +72,7 @@ java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n          semantics should only be generated by the front-end, and never\n          by anything after gimplification.  */\n     case MODIFY_EXPR:\n-      return java_gimplify_modify_expr (expr_p, pre_p, post_p);\n+      return java_gimplify_modify_expr (expr_p);\n \n     case SAVE_EXPR:\n       /* Note that we can see <save_expr NULL> if the save_expr was\n@@ -98,9 +97,6 @@ java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n     case COMPARE_G_EXPR:\n       gcc_unreachable ();\n \n-    case COMPONENT_REF:\n-      return java_gimplify_component_ref (expr_p, pre_p, post_p);\n-\n     default:\n       /* Java insists on strict left-to-right evaluation of expressions.\n \t A problem may arise if a variable used in the LHS of a binary\n@@ -129,96 +125,13 @@ java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n }\n \n static enum gimplify_status\n-java_gimplify_component_ref (tree *expr_p, tree *pre_p, tree *post_p)\n-{\n-  if (CLASS_FROM_SOURCE_P (output_class)\n-      && TREE_THIS_VOLATILE (TREE_OPERAND (*expr_p, 1))\n-      && ! TREE_THIS_VOLATILE (*expr_p))\n-  {\n-    enum gimplify_status stat;\n-    tree sync_expr;\n-\n-    /* Special handling for volatile fields.  \n-\n-    A load has \"acquire\" semantics, implying that you can't move up\n-    later operations.  A store has \"release\" semantics meaning that\n-    earlier operations cannot be delayed past it.  \n-\n-    This logic only handles loads: stores are handled in\n-    java_gimplify_modify_expr().\n-\n-    We gimplify this COMPONENT_REF, put the result in a tmp_var, and then\n-    return a COMPOUND_EXPR of the form {__sync_synchronize(); tmp_var}.  \n-    This forces __sync_synchronize() to be placed immediately after\n-    loading from the volatile field.\n-\n-    */\n-  \n-    TREE_THIS_VOLATILE (*expr_p) = 1;\n-    *expr_p = java_modify_addr_for_volatile (*expr_p);\n-    stat = gimplify_expr (expr_p, pre_p, post_p,\n-\t\t\t  is_gimple_formal_tmp_var, fb_rvalue);\n-    if (stat == GS_ERROR)\n-      return stat;\n-\n-    sync_expr = build_call_expr (built_in_decls[BUILT_IN_SYNCHRONIZE], 0);\n-    TREE_SIDE_EFFECTS (sync_expr) = 1;\n-    *expr_p = build2 (COMPOUND_EXPR, TREE_TYPE (*expr_p),\n-\t\t      sync_expr, *expr_p);\n-    TREE_SIDE_EFFECTS (*expr_p) = 1;\n-  }\n-\n-  return GS_UNHANDLED;\n-}\n-  \n-\n-static enum gimplify_status\n-java_gimplify_modify_expr (tree *modify_expr_p, tree *pre_p, tree *post_p)\n+java_gimplify_modify_expr (tree *modify_expr_p)\n {\n   tree modify_expr = *modify_expr_p;\n   tree lhs = TREE_OPERAND (modify_expr, 0);\n   tree rhs = TREE_OPERAND (modify_expr, 1);\n   tree lhs_type = TREE_TYPE (lhs);\n \n-  if (CLASS_FROM_SOURCE_P (output_class)\n-      && TREE_CODE (lhs) == COMPONENT_REF\n-      && TREE_THIS_VOLATILE (TREE_OPERAND (lhs, 1)))\n-    {\n-      /* Special handling for volatile fields.  \n-\n-      A load has \"acquire\" semantics, implying that you can't move up\n-      later operations.  A store has \"release\" semantics meaning that\n-      earlier operations cannot be delayed past it.  \n-\n-      This logic only handles stores; loads are handled in\n-      java_gimplify_component_ref().\n-\n-      We gimplify the rhs, put the result in a tmp_var, and then return\n-      a MODIFY_EXPR with an rhs of the form {__sync_synchronize(); tmp_var}.\n-      This forces __sync_synchronize() to be placed after evaluating\n-      the rhs and immediately before storing to the volatile field.\n-\n-      */\n-  \n-      enum gimplify_status stat;\n-      tree sync_expr =\n-\tbuild_call_expr (built_in_decls[BUILT_IN_SYNCHRONIZE], 0);\n-      TREE_SIDE_EFFECTS (sync_expr) = 1;\n-\n-      stat = gimplify_expr (&rhs, pre_p, post_p,\n-\t\t\t    is_gimple_formal_tmp_var, fb_rvalue);\n-      if (stat == GS_ERROR)\n-\treturn stat;\n-\n-      rhs = build2 (COMPOUND_EXPR, TREE_TYPE (rhs),\n-\t\t    sync_expr, rhs);\n-      TREE_SIDE_EFFECTS (rhs) = 1;\n-      TREE_THIS_VOLATILE (lhs) = 1;\n-      lhs = java_modify_addr_for_volatile (lhs);\n-      TREE_OPERAND (modify_expr, 0) = lhs;\n-      TREE_OPERAND (modify_expr, 1) = rhs;\n-    }\n-\n   /* This is specific to the bytecode compiler.  If a variable has\n      LOCAL_SLOT_P set, replace an assignment to it with an assignment\n      to the corresponding variable that holds all its aliases.  */"}, {"sha": "95087b785a4300a13a2c0599c7b0df6a9bed2c0a", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 85, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=279e32c924988609c7b48d70b681b492a142b66a", "patch": "@@ -48,12 +48,10 @@ struct JCF;\n    4: IS_A_COMMAND_LINE_FILENAME_P (in IDENTIFIER_NODE)\n       IS_ARRAY_LENGTH_ACCESS (in INDIRECT_REF)\n    5: HAS_BEEN_ALREADY_PARSED_P (in IDENTIFIER_NODE)\n-   6: CAN_COMPLETE_NORMALLY (in statement nodes)\n \n    Usage of TYPE_LANG_FLAG_?:\n    1: TYPE_ARRAY_P (in RECORD_TYPE).\n    2: CLASS_PARSED_P (in RECORD_TYPE).\n-   3: CLASS_FROM_SOURCE_P (in RECORD_TYPE).\n    4: CLASS_P (in RECORD_TYPE).\n    5: CLASS_FROM_CURRENTLY_COMPILED_P (in RECORD_TYPE)\n    6: CLASS_BEING_LAIDOUT (in RECORD_TYPE)\n@@ -80,11 +78,8 @@ struct JCF;\n       CLASS_ABSTRACT (in TYPE_DECL)\n       FIELD_TRANSIENT (in FIELD_DECL)\n    6: CLASS_SUPER (in TYPE_DECL, ACC_SUPER flag)\n-      FIELD_LOCAL_ALIAS (in FIELD_DECL)\n    7: DECL_CONSTRUCTOR_P (in FUNCTION_DECL).\n       CLASS_STATIC (in TYPE_DECL)\n-      FIELD_LOCAL_ALIAS_USED (in FIELD_DECL)\n-      FIELD_THISN (in FIELD_DECL)\n */\n \n #define VAR_OR_FIELD_CHECK(DECL) \\\n@@ -302,7 +297,6 @@ enum java_tree_index\n   JTI_VOID_SIGNATURE_NODE,       \n   JTI_FINALIZE_IDENTIFIER_NODE,\n   JTI_THIS_IDENTIFIER_NODE,  \n-  JTI_CLASSDOLLAR_IDENTIFIER_NODE,\n   JTI_ONE_ELT_ARRAY_DOMAIN_TYPE,\n \n   JTI_RETURN_ADDRESS_TYPE_NODE,\n@@ -497,8 +491,6 @@ extern GTY(()) tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_FINALIZE_IDENTIFIER_NODE]  /* \"finalize\" */\n #define this_identifier_node \\\n   java_global_trees[JTI_THIS_IDENTIFIER_NODE]  /* \"this\" */\n-#define classdollar_identifier_node \\\n-  java_global_trees[JTI_CLASSDOLLAR_IDENTIFIER_NODE] /* \"class$\" */\n #define one_elt_array_domain_type \\\n   java_global_trees[JTI_ONE_ELT_ARRAY_DOMAIN_TYPE]\n /* The type of the return address of a subroutine. */\n@@ -740,9 +732,6 @@ union lang_tree_node\n    class has been initialized in this function, and FALSE otherwise.  */\n #define DECL_FUNCTION_INIT_TEST_TABLE(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->u.f.init_test_table)\n-/* If LOCAL_CLASS_INITIALIZATION_FLAG_P(decl), give class it initializes. */\n-#define DECL_FUNCTION_INIT_TEST_CLASS(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->u.v.slot_chain)\n /* For each static function decl, itc contains a hash table whose\n    entries are keyed on class named that are definitively initialized\n    in DECL.  */\n@@ -752,25 +741,9 @@ union lang_tree_node\n #define DECL_LOCAL_CNI_METHOD_P(NODE) \\\n     (DECL_LANG_SPECIFIC (NODE)->u.f.local_cni)\n \n-/* A constructor that calls this. */\n-#define DECL_INIT_CALLS_THIS(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->u.f.init_calls_this)\n-\n /* True when DECL (a field) is Synthetic.  */\n #define FIELD_SYNTHETIC(DECL) DECL_LANG_FLAG_2 (VAR_OR_FIELD_CHECK (DECL))\n \n-/* True when DECL aliases an outer context local variable.  */\n-#define FIELD_LOCAL_ALIAS(DECL) DECL_LANG_FLAG_6 (VAR_OR_FIELD_CHECK (DECL))\n-\n-/* True when DECL, which aliases an outer context local variable is\n-   used by the inner classes.  */\n-#define FIELD_LOCAL_ALIAS_USED(DECL) DECL_LANG_FLAG_7 (VAR_OR_FIELD_CHECK (DECL))\n-\n-/* True when DECL is a this$<n> field. Note that\n-   FIELD_LOCAL_ALIAS_USED can be differentiated when tested against\n-   FIELD_LOCAL_ALIAS.  */\n-#define FIELD_THISN(DECL) DECL_LANG_FLAG_7 (VAR_OR_FIELD_CHECK (DECL))\n-\n /* The slot number for this local variable. */\n #define DECL_LOCAL_SLOT_NUMBER(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->u.v.slot_number)\n@@ -781,35 +754,10 @@ union lang_tree_node\n /* For a VAR_DECL or PARM_DECL, used to chain decls with the same\n    slot_number in decl_map. */\n #define DECL_LOCAL_SLOT_CHAIN(NODE) (DECL_LANG_SPECIFIC(NODE)->u.v.slot_chain)\n-/* For a FIELD_DECL, holds the name of the access method. Used to\n-   read/write the content of the field across nested class boundaries.  */\n-#define FIELD_NESTED_ACCESS(DECL) \\\n-  (DECL_LANG_SPECIFIC (VAR_OR_FIELD_CHECK (DECL))->u.v.am)\n-/* Safely tests whether FIELD_NESTED_ACCESS exists or not.  */\n-#define FIELD_NESTED_ACCESS_P(DECL) \\\n-  DECL_LANG_SPECIFIC (DECL) && FIELD_NESTED_ACCESS (DECL)\n-/* True if a final field was initialized upon its declaration\n-   or in an initializer.  Set after definite assignment.  */\n-#define DECL_FIELD_FINAL_IUD(NODE)  (DECL_LANG_SPECIFIC (NODE)->u.v.final_iud)\n /* The class that's the owner of a dynamic binding table.  */\n #define DECL_OWNER(NODE)            (DECL_LANG_SPECIFIC(NODE)->u.v.owner)\n-/* True if NODE is a local variable final. */\n-#define LOCAL_FINAL_P(NODE) (DECL_LANG_SPECIFIC (NODE) && DECL_FINAL (NODE))\n-/* True if a final local variable was initialized upon its declaration.  */\n-#define DECL_LOCAL_FINAL_IUD(NODE)  (DECL_LANG_SPECIFIC (NODE)->u.v.final_iud)\n-/* True if NODE is a final field. */\n-#define FINAL_VARIABLE_P(NODE) (FIELD_FINAL (NODE) && !FIELD_STATIC (NODE))\n /* True if NODE is a class final field. */\n #define FIELD_ENUM(DECL)\t    (DECL_LANG_SPECIFIC (DECL)->u.v.field_enum)\n-#define CLASS_FINAL_VARIABLE_P(NODE) \\\n-  (FIELD_FINAL (NODE) && FIELD_STATIC (NODE))\n-/* True if NODE is a class initialization flag. This macro accesses\n-   the flag to read or set it.  */\n-#define LOCAL_CLASS_INITIALIZATION_FLAG(NODE) \\\n-    (DECL_LANG_SPECIFIC (NODE)->u.v.cif)\n-/* True if NODE is a class initialization flag. */\n-#define LOCAL_CLASS_INITIALIZATION_FLAG_P(NODE) \\\n-    (DECL_LANG_SPECIFIC (NODE) && LOCAL_CLASS_INITIALIZATION_FLAG(NODE))\n /* True if NODE is a variable that is out of scope.  */\n #define LOCAL_VAR_OUT_OF_SCOPE_P(NODE) \\\n     (DECL_LANG_SPECIFIC (NODE)->u.v.freed)\n@@ -837,12 +785,6 @@ union lang_tree_node\n        && TREE_CODE (TREE_TYPE (NODE)) != POINTER_TYPE) \\\n    || TREE_CODE (NODE) == REAL_CST)\n \n-/* For a local VAR_DECL or PARM_DECL, holds the index into a words bitstring\n-   that specifies if this decl is definitively assigned.\n-   The value -1 means the variable has been definitely assigned (and not\n-   definitely unassigned).  The value -2 means we already reported an error. */\n-#define DECL_BIT_INDEX(DECL) VAR_OR_FIELD_CHECK (DECL)->decl_common.pointer_alias_set\n-\n /* DECL_LANG_SPECIFIC for FUNCTION_DECLs. */\n struct lang_decl_func GTY(())\n {\n@@ -869,7 +811,6 @@ struct lang_decl_func GTY(())\n \n   unsigned int native : 1;\t/* Nonzero if this is a native method  */\n   unsigned int init_final : 1;\t/* Nonzero all finals are initialized */\n-  unsigned int init_calls_this : 1;\n   unsigned int strictfp : 1;\n   unsigned int invisible : 1;\t/* Set for methods we generate\n \t\t\t\t   internally but which shouldn't be\n@@ -936,10 +877,7 @@ struct lang_decl_var GTY(())\n   int start_pc;\n   int end_pc;\n   tree slot_chain;\n-  tree am;\t\t\t/* Access method for this field (1.1) */\n   tree owner;\n-  unsigned int final_iud : 1;\t/* Final initialized upon declaration */\n-  unsigned int cif : 1;\t\t/* True: decl is a class initialization flag */\n   unsigned int freed : 1;\t\t/* Decl is no longer in scope.  */\n   unsigned int local_slot : 1;\t/* Decl is a temporary in the stack frame.  */\n   unsigned int class_field : 1; /* Decl needs mangle_class_field.  */\n@@ -974,10 +912,6 @@ struct lang_decl GTY(())\n \n #define TYPE_DUMMY(T)\t\t(TYPE_LANG_SPECIFIC(T)->dummy_class)\n \n-/* The decl of the synthetic method `class$' used to handle `.class'\n-   for non primitive types when compiling to bytecode. */\n-\n-#define TYPE_DOT_CLASS(T)        (TYPE_LANG_SPECIFIC (T)->dot_class)\n #define TYPE_PACKAGE_LIST(T)     (TYPE_LANG_SPECIFIC (T)->package_list)\n #define TYPE_PRIVATE_INNER_CLASS(T) (TYPE_LANG_SPECIFIC (T)->pic)\n #define TYPE_PROTECTED_INNER_CLASS(T) (TYPE_LANG_SPECIFIC (T)->poic)\n@@ -1002,7 +936,6 @@ struct lang_decl GTY(())\n \n #define TYPE_CTABLE_DECL(T)      (TYPE_LANG_SPECIFIC (T)->ctable_decl)\n #define TYPE_CATCH_CLASSES(T)    (TYPE_LANG_SPECIFIC (T)->catch_classes)\n-#define TYPE_VERIFY_METHOD(T)    (TYPE_LANG_SPECIFIC (T)->verify_method)\n \n #define TYPE_TO_RUNTIME_MAP(T)   (TYPE_LANG_SPECIFIC (T)->type_to_runtime_map)\n #define TYPE_ASSERTIONS(T)   \t (TYPE_LANG_SPECIFIC (T)->type_assertions)\n@@ -1018,10 +951,6 @@ struct lang_type GTY(())\n   struct JCF *jcf;\n   struct CPool *cpool;\n   tree cpool_data_ref;\t\t/* Cached */\n-  tree dot_class;\t\t/* The decl of the `class$' function that\n-\t\t\t\t   needs to be invoked and generated when\n-\t\t\t\t   compiling to bytecode to implement\n-\t\t\t\t   <non_primitive_type>.class */\n   tree package_list;\t\t/* List of package names, progressive */\n \n   tree otable_methods;          /* List of static decls referred to by this\n@@ -1043,9 +972,6 @@ struct lang_type GTY(())\n \t\t\t\t   type matcher.  */\n   tree catch_classes;\n \n-  tree verify_method;\t\t/* The verify method for this class.\n-\t\t\t\t   Used in split verification.  */\n-\n   htab_t GTY ((param_is (struct treetreehash_entry))) type_to_runtime_map;   \n                                 /* The mapping of classes to exception region\n \t\t\t\t   markers.  */\n@@ -1360,7 +1286,6 @@ extern void rewrite_reflection_indexes (void *);\n    them  */\n #define ID_INIT_P(ID)   ((ID) == init_identifier_node)\n #define ID_CLINIT_P(ID) ((ID) == clinit_identifier_node)\n-#define ID_CLASSDOLLAR_P(ID) ((ID) == classdollar_identifier_node)\n \n /* Access flags etc for variable/field (FIELD_DECL, VAR_DECL, or PARM_DECL): */\n \n@@ -1441,9 +1366,6 @@ extern const unsigned char *linenumber_table;\n /* The length (in items) of the line number table. */\n extern int linenumber_count;\n \n-/* In type_map, means that slot is uninitialized or otherwise unusable. */\n-#define TYPE_UNKNOWN NULL_TREE\n-\n /* In type_map, means the second half of a 64-bit double or long. */\n #define TYPE_SECOND void_type_node\n \n@@ -1455,7 +1377,7 @@ extern int linenumber_count;\n \n /* A array mapping variable/stack slot index to the type current\n    in that variable/stack slot.\n-   TYPE_UNKNOWN, TYPE_SECOND, and TYPE_NULL are special cases. */\n+   TYPE_SECOND and TYPE_NULL are special cases. */\n extern tree *type_map;\n \n /* Map a stack index to the type currently in that slot. */\n@@ -1487,9 +1409,6 @@ extern tree *type_map;\n /* True if class TYPE has been parsed (first pass). */\n #define CLASS_PARSED_P(TYPE) TYPE_LANG_FLAG_2 (TYPE)\n \n-/* True if class TYPE was defined in Java source code. */\n-#define CLASS_FROM_SOURCE_P(TYPE) TYPE_LANG_FLAG_3 (TYPE)\n-\n /* True of a RECORD_TYPE of a class/interface type (not array type) */\n #define CLASS_P(TYPE) TYPE_LANG_FLAG_4 (TYPE)\n \n@@ -1514,9 +1433,6 @@ extern tree *type_map;\n    feature a finalizer method. */\n #define HAS_FINALIZER_P(EXPR) TREE_LANG_FLAG_3 (EXPR)\n \n-/* True if NODE (a statement) can complete normally. */\n-#define CAN_COMPLETE_NORMALLY(NODE) TREE_LANG_FLAG_6 (NODE)\n-\n /* True if NODE belongs to an inner class TYPE_DECL node.\n    Verifies that NODE as the attributes of a decl.  */\n #define INNER_CLASS_DECL_P(NODE) (TYPE_NAME (TREE_TYPE (NODE)) == NODE\t\\"}, {"sha": "08d51364fb386c2240f79bbdaad8e5f815796785", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=279e32c924988609c7b48d70b681b492a142b66a", "patch": "@@ -1365,11 +1365,6 @@ load_class (tree class_or_name, int verbose)\n \t   || CLASS_FROM_CURRENTLY_COMPILED_P (type));\n     }\n \n-  /* If the class is from source code, then it must already be loaded.  */\n-  class_decl = IDENTIFIER_CLASS_VALUE (name);\n-  if (class_decl && CLASS_FROM_SOURCE_P (TREE_TYPE (class_decl)))\n-    return;\n-\n   saved = name;\n   \n   /* If flag_verify_invocations is unset, we don't try to load a class"}, {"sha": "403639dafa6d597ae5a9c95e37ca354d565e555e", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279e32c924988609c7b48d70b681b492a142b66a/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=279e32c924988609c7b48d70b681b492a142b66a", "patch": "@@ -763,9 +763,7 @@ find_method_in_interfaces (tree searched_class, int flags, tree method_name,\n       tree method;\n \t  \n       /* If the superinterface hasn't been loaded yet, do so now.  */\n-      if (CLASS_FROM_SOURCE_P (iclass))\n-\tsafe_layout_class (iclass);\n-      else if (!CLASS_LOADED_P (iclass))\n+      if (!CLASS_LOADED_P (iclass))\n \tload_class (iclass, 1);\n \t  \n       /* First, we look in ICLASS.  If that doesn't work we'll"}]}