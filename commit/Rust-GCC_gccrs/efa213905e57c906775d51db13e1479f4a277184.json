{"sha": "efa213905e57c906775d51db13e1479f4a277184", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZhMjEzOTA1ZTU3YzkwNjc3NWQ1MWRiMTNlMTQ3OWY0YTI3NzE4NA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-12-01T17:25:10Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-12-01T17:25:10Z"}, "message": "Postpone the rewrite out of SSA to the end of the translation to polyhedral representation.\n\n2010-11-22  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR middle-end/45297\n\t* graphite-poly.c (new_poly_bb): Returns a poly_bb_p.  Do not take\n\tthe reduction bool in parameter.  Clear PBB_IS_REDUCTION.  Set GBB_PBB.\n\t* graphite-poly.h (new_poly_bb): Update declaration.\n\t(gbb_from_bb): Moved here...\n\t(pbb_from_bb): New.\n\t* graphite-sese-to-poly.c (var_used_in_not_loop_header_phi_node):\n\tRemoved.\n\t(graphite_stmt_p): Removed.\n\t(try_generate_gimple_bb): Returns a gimple_bb_p.  Do not pass in\n\tsbitmap reductions.  Always build a gimple_bb_p.  Do not call\n\tnew_poly_bb.\n\t(build_scop_bbs_1): Do not pass in sbitmap reductions.\n\t(build_scop_bbs): Same.\n\t(gbb_from_bb): ... from here.\n\t(add_conditions_to_constraints): Moved up.\n\t(analyze_drs): New.\n\t(build_scop_drs): Call analyze_drs.  Remove all the PBBs that do\n\tnot contain data references.\n\t(new_pbb_from_pbb): New.\n\t(insert_out_of_ssa_copy_on_edge): Call new_pbb_from_pbb after a\n\tblock is split.\n\t(rewrite_close_phi_out_of_ssa): Update call to\n\tinsert_out_of_ssa_copy_on_edge.\n\t(rewrite_reductions_out_of_ssa): Now static.\n\t(rewrite_cross_bb_scalar_deps_out_of_ssa): Same.\n\t(split_pbb): New.\n\t(split_reduction_stmt): Call split_pbb.\n\t(translate_scalar_reduction_to_array): Pass in the scop, do not\n\tpass in the sbitmap reductions.\n\t(rewrite_commutative_reductions_out_of_ssa_close_phi): Same.\n\t(rewrite_commutative_reductions_out_of_ssa_loop): Same.\n\t(rewrite_commutative_reductions_out_of_ssa): Same.\n\t(build_poly_scop): Call build_scop_bbs,\n\trewrite_commutative_reductions_out_of_ssa,\n\trewrite_reductions_out_of_ssa, and\n\trewrite_cross_bb_scalar_deps_out_of_ssa.  Move build_scop_drs\n\tbefore scop_to_lst.\n\t* graphite-sese-to-poly.h (rewrite_commutative_reductions_out_of_ssa):\n\tRemoved declaration.\n\t(rewrite_reductions_out_of_ssa): Same.\n\t(rewrite_cross_bb_scalar_deps_out_of_ssa): Same.\n\t(build_scop_bbs): Same.\n\t* graphite.c (graphite_transform_loops): Do not initialize reductions.\n\tDo not call build_scop_bbs,\n\trewrite_commutative_reductions_out_of_ssa,\n\trewrite_reductions_out_of_ssa, and\n\trewrite_cross_bb_scalar_deps_out_of_ssa.\n\t* sese.h (struct gimple_bb): Add field pbb.\n\t(GBB_PBB): New.\n\n\t* gcc.dg/graphite/pr45297.c: New.\n\nFrom-SVN: r167348", "tree": {"sha": "31b829048b2061334b2835044bc650e65ff4bcb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31b829048b2061334b2835044bc650e65ff4bcb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efa213905e57c906775d51db13e1479f4a277184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efa213905e57c906775d51db13e1479f4a277184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efa213905e57c906775d51db13e1479f4a277184", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efa213905e57c906775d51db13e1479f4a277184/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70a2ae0f4570a91c23b554761dc105c899fce4bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70a2ae0f4570a91c23b554761dc105c899fce4bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70a2ae0f4570a91c23b554761dc105c899fce4bb"}], "stats": {"total": 540, "additions": 337, "deletions": 203}, "files": [{"sha": "7540273c999ad77aa0d1e3ce4a694e125f4e383e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa213905e57c906775d51db13e1479f4a277184/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa213905e57c906775d51db13e1479f4a277184/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efa213905e57c906775d51db13e1479f4a277184", "patch": "@@ -1,3 +1,56 @@\n+2010-12-01  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR middle-end/45297\n+\t* graphite-poly.c (new_poly_bb): Returns a poly_bb_p.  Do not take\n+\tthe reduction bool in parameter.  Clear PBB_IS_REDUCTION.  Set GBB_PBB.\n+\t* graphite-poly.h (new_poly_bb): Update declaration.\n+\t(gbb_from_bb): Moved here...\n+\t(pbb_from_bb): New.\n+\t* graphite-sese-to-poly.c (var_used_in_not_loop_header_phi_node):\n+\tRemoved.\n+\t(graphite_stmt_p): Removed.\n+\t(try_generate_gimple_bb): Returns a gimple_bb_p.  Do not pass in\n+\tsbitmap reductions.  Always build a gimple_bb_p.  Do not call\n+\tnew_poly_bb.\n+\t(build_scop_bbs_1): Do not pass in sbitmap reductions.\n+\t(build_scop_bbs): Same.\n+\t(gbb_from_bb): ... from here.\n+\t(add_conditions_to_constraints): Moved up.\n+\t(analyze_drs): New.\n+\t(build_scop_drs): Call analyze_drs.  Remove all the PBBs that do\n+\tnot contain data references.\n+\t(new_pbb_from_pbb): New.\n+\t(insert_out_of_ssa_copy_on_edge): Call new_pbb_from_pbb after a\n+\tblock is split.\n+\t(rewrite_close_phi_out_of_ssa): Update call to\n+\tinsert_out_of_ssa_copy_on_edge.\n+\t(rewrite_reductions_out_of_ssa): Now static.\n+\t(rewrite_cross_bb_scalar_deps_out_of_ssa): Same.\n+\t(split_pbb): New.\n+\t(split_reduction_stmt): Call split_pbb.\n+\t(translate_scalar_reduction_to_array): Pass in the scop, do not\n+\tpass in the sbitmap reductions.\n+\t(rewrite_commutative_reductions_out_of_ssa_close_phi): Same.\n+\t(rewrite_commutative_reductions_out_of_ssa_loop): Same.\n+\t(rewrite_commutative_reductions_out_of_ssa): Same.\n+\t(build_poly_scop): Call build_scop_bbs,\n+\trewrite_commutative_reductions_out_of_ssa,\n+\trewrite_reductions_out_of_ssa, and\n+\trewrite_cross_bb_scalar_deps_out_of_ssa.  Move build_scop_drs\n+\tbefore scop_to_lst.\n+\t* graphite-sese-to-poly.h (rewrite_commutative_reductions_out_of_ssa):\n+\tRemoved declaration.\n+\t(rewrite_reductions_out_of_ssa): Same.\n+\t(rewrite_cross_bb_scalar_deps_out_of_ssa): Same.\n+\t(build_scop_bbs): Same.\n+\t* graphite.c (graphite_transform_loops): Do not initialize reductions.\n+\tDo not call build_scop_bbs,\n+\trewrite_commutative_reductions_out_of_ssa,\n+\trewrite_reductions_out_of_ssa, and\n+\trewrite_cross_bb_scalar_deps_out_of_ssa.\n+\t* sese.h (struct gimple_bb): Add field pbb.\n+\t(GBB_PBB): New.\n+\n 2010-12-01  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-sese-to-poly.c (handle_scalar_deps_crossing_scop_limits):"}, {"sha": "4461ade8893899944706852c2d4117475a077175", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa213905e57c906775d51db13e1479f4a277184/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa213905e57c906775d51db13e1479f4a277184/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=efa213905e57c906775d51db13e1479f4a277184", "patch": "@@ -1,3 +1,58 @@\n+2010-11-22  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR middle-end/45297\n+\t* graphite-poly.c (new_poly_bb): Returns a poly_bb_p.  Do not take\n+\tthe reduction bool in parameter.  Clear PBB_IS_REDUCTION.  Set GBB_PBB.\n+\t* graphite-poly.h (new_poly_bb): Update declaration.\n+\t(gbb_from_bb): Moved here...\n+\t(pbb_from_bb): New.\n+\t* graphite-sese-to-poly.c (var_used_in_not_loop_header_phi_node):\n+\tRemoved.\n+\t(graphite_stmt_p): Removed.\n+\t(try_generate_gimple_bb): Returns a gimple_bb_p.  Do not pass in\n+\tsbitmap reductions.  Always build a gimple_bb_p.  Do not call\n+\tnew_poly_bb.\n+\t(build_scop_bbs_1): Do not pass in sbitmap reductions.\n+\t(build_scop_bbs): Same.\n+\t(gbb_from_bb): ... from here.\n+\t(add_conditions_to_constraints): Moved up.\n+\t(analyze_drs): New.\n+\t(build_scop_drs): Call analyze_drs.  Remove all the PBBs that do\n+\tnot contain data references.\n+\t(new_pbb_from_pbb): New.\n+\t(insert_out_of_ssa_copy_on_edge): Call new_pbb_from_pbb after a\n+\tblock is split.\n+\t(rewrite_close_phi_out_of_ssa): Update call to\n+\tinsert_out_of_ssa_copy_on_edge.\n+\t(rewrite_reductions_out_of_ssa): Now static.\n+\t(rewrite_cross_bb_scalar_deps_out_of_ssa): Same.\n+\t(split_pbb): New.\n+\t(split_reduction_stmt): Call split_pbb.\n+\t(translate_scalar_reduction_to_array): Pass in the scop, do not\n+\tpass in the sbitmap reductions.\n+\t(rewrite_commutative_reductions_out_of_ssa_close_phi): Same.\n+\t(rewrite_commutative_reductions_out_of_ssa_loop): Same.\n+\t(rewrite_commutative_reductions_out_of_ssa): Same.\n+\t(build_poly_scop): Call build_scop_bbs,\n+\trewrite_commutative_reductions_out_of_ssa,\n+\trewrite_reductions_out_of_ssa, and\n+\trewrite_cross_bb_scalar_deps_out_of_ssa.  Move build_scop_drs\n+\tbefore scop_to_lst.\n+\t* graphite-sese-to-poly.h (rewrite_commutative_reductions_out_of_ssa):\n+\tRemoved declaration.\n+\t(rewrite_reductions_out_of_ssa): Same.\n+\t(rewrite_cross_bb_scalar_deps_out_of_ssa): Same.\n+\t(build_scop_bbs): Same.\n+\t* graphite.c (graphite_transform_loops): Do not initialize reductions.\n+\tDo not call build_scop_bbs,\n+\trewrite_commutative_reductions_out_of_ssa,\n+\trewrite_reductions_out_of_ssa, and\n+\trewrite_cross_bb_scalar_deps_out_of_ssa.\n+\t* sese.h (struct gimple_bb): Add field pbb.\n+\t(GBB_PBB): New.\n+\n+\t* gcc.dg/graphite/pr45297.c: New.\n+\n 2010-11-22  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-sese-to-poly.c (handle_scalar_deps_crossing_scop_limits):"}, {"sha": "9416cd754f8f8726bc1a0e2d14a78943b5d71cf3", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=efa213905e57c906775d51db13e1479f4a277184", "patch": "@@ -874,8 +874,8 @@ free_poly_dr (poly_dr_p pdr)\n \n /* Create a new polyhedral black box.  */\n \n-void\n-new_poly_bb (scop_p scop, void *black_box, bool reduction)\n+poly_bb_p\n+new_poly_bb (scop_p scop, void *black_box)\n {\n   poly_bb_p pbb = XNEW (struct poly_bb);\n \n@@ -886,9 +886,11 @@ new_poly_bb (scop_p scop, void *black_box, bool reduction)\n   PBB_SAVED (pbb) = NULL;\n   PBB_ORIGINAL (pbb) = NULL;\n   PBB_DRS (pbb) = VEC_alloc (poly_dr_p, heap, 3);\n-  PBB_IS_REDUCTION (pbb) = reduction;\n+  PBB_IS_REDUCTION (pbb) = false;\n   PBB_PDR_DUPLICATES_REMOVED (pbb) = false;\n-  VEC_safe_push (poly_bb_p, heap, SCOP_BBS (scop), pbb);\n+  GBB_PBB ((gimple_bb_p) black_box) = pbb;\n+\n+  return pbb;\n }\n \n /* Free polyhedral black box.  */"}, {"sha": "8be905ef9217c29201952c115dadd29ad069e27d", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=efa213905e57c906775d51db13e1479f4a277184", "patch": "@@ -389,7 +389,7 @@ struct poly_bb\n #define PBB_PDR_DUPLICATES_REMOVED(PBB) (PBB->pdr_duplicates_removed)\n #define PBB_IS_REDUCTION(PBB) (PBB->is_reduction)\n \n-extern void new_poly_bb (scop_p, void *, bool);\n+extern poly_bb_p new_poly_bb (scop_p, void *);\n extern void free_poly_bb (poly_bb_p);\n extern void debug_loop_vec (poly_bb_p);\n extern void schedule_to_scattering (poly_bb_p, int);\n@@ -434,6 +434,22 @@ number_of_write_pdrs (poly_bb_p pbb)\n   return res;\n }\n \n+/* Returns a gimple_bb from BB.  */\n+\n+static inline gimple_bb_p\n+gbb_from_bb (basic_block bb)\n+{\n+  return (gimple_bb_p) bb->aux;\n+}\n+\n+/* The poly_bb of the BB.  */\n+\n+static inline poly_bb_p\n+pbb_from_bb (basic_block bb)\n+{\n+  return GBB_PBB (gbb_from_bb (bb));\n+}\n+\n /* The basic block of the PBB.  */\n \n static inline basic_block"}, {"sha": "badd25f41f9d20d323e6f2137123cb0de27cd773", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 180, "deletions": 167, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=efa213905e57c906775d51db13e1479f4a277184", "patch": "@@ -49,27 +49,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"graphite-scop-detection.h\"\n #include \"graphite-sese-to-poly.h\"\n \n-/* Check if VAR is used in a phi node, that is no loop header.  */\n-\n-static bool\n-var_used_in_not_loop_header_phi_node (tree var)\n-{\n-  imm_use_iterator imm_iter;\n-  gimple stmt;\n-  bool result = false;\n-\n-  FOR_EACH_IMM_USE_STMT (stmt, imm_iter, var)\n-    {\n-      basic_block bb = gimple_bb (stmt);\n-\n-      if (gimple_code (stmt) == GIMPLE_PHI\n-\t  && bb->loop_father->header != bb)\n-\tresult = true;\n-    }\n-\n-  return result;\n-}\n-\n /* Returns the index of the PHI argument defined in the outermost\n    loop.  */\n \n@@ -196,58 +175,6 @@ reduction_phi_p (sese region, gimple_stmt_iterator *psi)\n   return true;\n }\n \n-/* Returns true when BB will be represented in graphite.  Return false\n-   for the basic blocks that contain code eliminated in the code\n-   generation pass: i.e. induction variables and exit conditions.  */\n-\n-static bool\n-graphite_stmt_p (sese region, basic_block bb,\n-\t\t VEC (data_reference_p, heap) *drs)\n-{\n-  gimple_stmt_iterator gsi;\n-  loop_p loop = bb->loop_father;\n-\n-  if (VEC_length (data_reference_p, drs) > 0)\n-    return true;\n-\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple stmt = gsi_stmt (gsi);\n-\n-      switch (gimple_code (stmt))\n-        {\n-\tcase GIMPLE_DEBUG:\n-          /* Control flow expressions can be ignored, as they are\n-             represented in the iteration domains and will be\n-             regenerated by graphite.  */\n-\tcase GIMPLE_COND:\n-\tcase GIMPLE_GOTO:\n-\tcase GIMPLE_SWITCH:\n-\t  break;\n-\n-\tcase GIMPLE_ASSIGN:\n-\t  {\n-\t    tree var = gimple_assign_lhs (stmt);\n-\n-\t    /* We need these bbs to be able to construct the phi nodes.  */\n-\t    if (var_used_in_not_loop_header_phi_node (var))\n-\t      return true;\n-\n-\t    var = scalar_evolution_in_region (region, loop, var);\n-\t    if (chrec_contains_undetermined (var))\n-\t      return true;\n-\n-\t    break;\n-\t  }\n-\n-\tdefault:\n-\t  return true;\n-        }\n-    }\n-\n-  return false;\n-}\n-\n /* Store the GRAPHITE representation of BB.  */\n \n static gimple_bb_p\n@@ -330,8 +257,8 @@ free_scops (VEC (scop_p, heap) *scops)\n /* Generates a polyhedral black box only if the bb contains interesting\n    information.  */\n \n-static void\n-try_generate_gimple_bb (scop_p scop, basic_block bb, sbitmap reductions)\n+static gimple_bb_p\n+try_generate_gimple_bb (scop_p scop, basic_block bb)\n {\n   VEC (data_reference_p, heap) *drs = VEC_alloc (data_reference_p, heap, 5);\n   loop_p nest = outermost_loop_in_sese (SCOP_REGION (scop), bb);\n@@ -344,11 +271,7 @@ try_generate_gimple_bb (scop_p scop, basic_block bb, sbitmap reductions)\n \tgraphite_find_data_references_in_stmt (nest, stmt, &drs);\n     }\n \n-  if (!graphite_stmt_p (SCOP_REGION (scop), bb, drs))\n-    free_data_refs (drs);\n-  else\n-    new_poly_bb (scop, new_gimple_bb (bb, drs), TEST_BIT (reductions,\n-\t\t\t\t\t\t\t  bb->index));\n+  return new_gimple_bb (bb, drs);\n }\n \n /* Returns true if all predecessors of BB, that are not dominated by BB, are\n@@ -400,16 +323,18 @@ graphite_sort_dominated_info (VEC (basic_block, heap) *dom)\n /* Recursive helper function for build_scops_bbs.  */\n \n static void\n-build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb, sbitmap reductions)\n+build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n {\n   sese region = SCOP_REGION (scop);\n   VEC (basic_block, heap) *dom;\n+  poly_bb_p pbb;\n \n   if (TEST_BIT (visited, bb->index)\n       || !bb_in_sese_p (bb, region))\n     return;\n \n-  try_generate_gimple_bb (scop, bb, reductions);\n+  pbb = new_poly_bb (scop, try_generate_gimple_bb (scop, bb));\n+  VEC_safe_push (poly_bb_p, heap, SCOP_BBS (scop), pbb);\n   SET_BIT (visited, bb->index);\n \n   dom = get_dominated_by (CDI_DOMINATORS, bb);\n@@ -427,7 +352,7 @@ build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb, sbitmap reductio\n       FOR_EACH_VEC_ELT (basic_block, dom, i, dom_bb)\n \tif (all_non_dominated_preds_marked_p (dom_bb, visited))\n \t  {\n-\t    build_scop_bbs_1 (scop, visited, dom_bb, reductions);\n+\t    build_scop_bbs_1 (scop, visited, dom_bb);\n \t    VEC_unordered_remove (basic_block, dom, i);\n \t    break;\n \t  }\n@@ -438,14 +363,14 @@ build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb, sbitmap reductio\n \n /* Gather the basic blocks belonging to the SCOP.  */\n \n-void\n-build_scop_bbs (scop_p scop, sbitmap reductions)\n+static void\n+build_scop_bbs (scop_p scop)\n {\n   sbitmap visited = sbitmap_alloc (last_basic_block);\n   sese region = SCOP_REGION (scop);\n \n   sbitmap_zero (visited);\n-  build_scop_bbs_1 (scop, visited, SESE_ENTRY_BB (region), reductions);\n+  build_scop_bbs_1 (scop, visited, SESE_ENTRY_BB (region));\n   sbitmap_free (visited);\n }\n \n@@ -1004,14 +929,6 @@ find_scop_parameters (scop_p scop)\n     (&SCOP_CONTEXT (scop), scop_nb_params (scop), 0);\n }\n \n-/* Returns a gimple_bb from BB.  */\n-\n-static inline gimple_bb_p\n-gbb_from_bb (basic_block bb)\n-{\n-  return (gimple_bb_p) bb->aux;\n-}\n-\n /* Insert in the SCOP context constraints from the estimation of the\n    number of iterations.  UB_EXPR is a linear expression describing\n    the number of iterations in a loop.  This expression is bounded by\n@@ -1348,6 +1265,19 @@ add_conditions_to_domain (poly_bb_p pbb)\n       }\n }\n \n+/* Traverses all the GBBs of the SCOP and add their constraints to the\n+   iteration domains.  */\n+\n+static void\n+add_conditions_to_constraints (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n+    add_conditions_to_domain (pbb);\n+}\n+\n /* Structure used to pass data to dom_walk.  */\n \n struct bsc\n@@ -1470,19 +1400,6 @@ build_sese_conditions (sese region)\n   VEC_free (gimple, heap, cases);\n }\n \n-/* Traverses all the GBBs of the SCOP and add their constraints to the\n-   iteration domains.  */\n-\n-static void\n-add_conditions_to_constraints (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-\n-  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n-    add_conditions_to_domain (pbb);\n-}\n-\n /* Add constraints on the possible values of parameter P from the type\n    of P.  */\n \n@@ -1950,7 +1867,7 @@ build_alias_set_optimal_p (VEC (data_reference_p, heap) *drs)\n   return all_components_are_cliques;\n }\n \n-/* Group each data reference in DRS with it's base object set num.  */\n+/* Group each data reference in DRS with its base object set num.  */\n \n static void\n build_base_obj_set_for_drs (VEC (data_reference_p, heap) *drs)\n@@ -2039,6 +1956,36 @@ dump_alias_graphs (VEC (data_reference_p, heap) *drs)\n     }\n }\n \n+/* Recompute all the data references of BB and add them to the\n+   GBB_DATA_REFS vector.  */\n+\n+static void\n+analyze_drs (scop_p scop, basic_block bb)\n+{\n+  loop_p nest;\n+  poly_bb_p pbb;\n+  gimple_stmt_iterator gsi;\n+  gimple_bb_p gbb;\n+\n+  if (!bb_in_sese_p (bb, SCOP_REGION (scop)))\n+    return;\n+\n+  nest = outermost_loop_in_sese (SCOP_REGION (scop), bb);\n+  pbb = pbb_from_bb (bb);\n+  gbb = PBB_BLACK_BOX (pbb);\n+\n+  VEC_free (data_reference_p, heap, GBB_DATA_REFS (gbb));\n+  GBB_DATA_REFS (gbb) = VEC_alloc (data_reference_p, heap, 3);\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      if (!is_gimple_debug (stmt))\n+\tgraphite_find_data_references_in_stmt (nest, stmt,\n+\t\t\t\t\t       &GBB_DATA_REFS (gbb));\n+    }\n+}\n+\n /* Build data references in SCOP.  */\n \n static void\n@@ -2049,6 +1996,18 @@ build_scop_drs (scop_p scop)\n   data_reference_p dr;\n   VEC (data_reference_p, heap) *drs = VEC_alloc (data_reference_p, heap, 3);\n \n+  /* Remove all the PBBs that do not have data references: these basic\n+     blocks are not handled in the polyhedral representation.  */\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    {\n+      analyze_drs (scop, GBB_BB (PBB_BLACK_BOX (pbb)));\n+      if (VEC_empty (data_reference_p, GBB_DATA_REFS (PBB_BLACK_BOX (pbb))))\n+\t{\n+\t  VEC_ordered_remove (poly_bb_p, SCOP_BBS (scop), i);\n+\t  i--;\n+\t}\n+    }\n+\n   FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     for (j = 0; VEC_iterate (data_reference_p,\n \t\t\t     GBB_DATA_REFS (PBB_BLACK_BOX (pbb)), j, dr); j++)\n@@ -2092,18 +2051,17 @@ gsi_for_phi_node (gimple stmt)\n   return psi;\n }\n \n-/* Insert the assignment \"RES := VAR\" just after AFTER_STMT.  */\n+/* Insert the assignment \"RES := EXPR\" just after AFTER_STMT.  */\n \n static void\n-insert_out_of_ssa_copy (tree res, tree var, gimple after_stmt)\n+insert_out_of_ssa_copy (tree res, tree expr, gimple after_stmt)\n {\n-  gimple stmt;\n   gimple_seq stmts;\n   gimple_stmt_iterator si;\n   gimple_stmt_iterator gsi;\n+  tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n+  gimple stmt = gimple_build_assign (res, var);\n \n-  var = force_gimple_operand (var, &stmts, true, NULL_TREE);\n-  stmt = gimple_build_assign (res, var);\n   if (!stmts)\n     stmts = gimple_seq_alloc ();\n   si = gsi_last (stmts);\n@@ -2121,15 +2079,40 @@ insert_out_of_ssa_copy (tree res, tree var, gimple after_stmt)\n     }\n }\n \n+/* Creates a poly_bb_p for basic_block BB from the existing PBB.  */\n+\n+static void\n+new_pbb_from_pbb (scop_p scop, poly_bb_p pbb, basic_block bb)\n+{\n+  VEC (data_reference_p, heap) *drs = VEC_alloc (data_reference_p, heap, 3);\n+  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n+  gimple_bb_p gbb1 = new_gimple_bb (bb, drs);\n+  poly_bb_p pbb1 = new_poly_bb (scop, gbb1);\n+  int index, n = VEC_length (poly_bb_p, SCOP_BBS (scop));\n+\n+  /* The INDEX of PBB in SCOP_BBS.  */\n+  for (index = 0; index < n; index++)\n+    if (VEC_index (poly_bb_p, SCOP_BBS (scop), index) == pbb)\n+      break;\n+\n+  GBB_PBB (gbb1) = pbb1;\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+    (&PBB_DOMAIN (pbb1), PBB_DOMAIN (pbb));\n+  GBB_CONDITIONS (gbb1) = VEC_copy (gimple, heap, GBB_CONDITIONS (gbb));\n+  GBB_CONDITION_CASES (gbb1) = VEC_copy (gimple, heap, GBB_CONDITION_CASES (gbb));\n+  VEC_safe_insert (poly_bb_p, heap, SCOP_BBS (scop), index + 1, pbb1);\n+}\n+\n /* Insert on edge E the assignment \"RES := EXPR\".  */\n \n static void\n-insert_out_of_ssa_copy_on_edge (edge e, tree res, tree expr)\n+insert_out_of_ssa_copy_on_edge (scop_p scop, edge e, tree res, tree expr)\n {\n   gimple_stmt_iterator gsi;\n   gimple_seq stmts;\n   tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n   gimple stmt = gimple_build_assign (res, var);\n+  basic_block bb;\n \n   if (!stmts)\n     stmts = gimple_seq_alloc ();\n@@ -2138,6 +2121,13 @@ insert_out_of_ssa_copy_on_edge (edge e, tree res, tree expr)\n   gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n   gsi_insert_seq_on_edge (e, stmts);\n   gsi_commit_edge_inserts ();\n+  bb = gimple_bb (stmt);\n+\n+  if (!bb_in_sese_p (bb, SCOP_REGION (scop)))\n+    return;\n+\n+  if (!gbb_from_bb (bb))\n+    new_pbb_from_pbb (scop, pbb_from_bb (e->src), bb);\n }\n \n /* Creates a zero dimension array of the same type as VAR.  */\n@@ -2213,8 +2203,9 @@ propagate_expr_outside_region (tree def, tree expr, sese region)\n    dimension array for it.  */\n \n static void\n-rewrite_close_phi_out_of_ssa (gimple_stmt_iterator *psi, sese region)\n+rewrite_close_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n {\n+  sese region = SCOP_REGION (scop);\n   gimple phi = gsi_stmt (*psi);\n   tree res = gimple_phi_result (phi);\n   tree var = SSA_NAME_VAR (res);\n@@ -2278,9 +2269,10 @@ rewrite_close_phi_out_of_ssa (gimple_stmt_iterator *psi, sese region)\n       stmt = gimple_build_assign (res, zero_dim_array);\n \n       if (TREE_CODE (arg) == SSA_NAME)\n-\tinsert_out_of_ssa_copy (zero_dim_array, arg, SSA_NAME_DEF_STMT (arg));\n+\tinsert_out_of_ssa_copy (zero_dim_array, arg,\n+\t\t\t\tSSA_NAME_DEF_STMT (arg));\n       else\n-\tinsert_out_of_ssa_copy_on_edge (single_pred_edge (bb),\n+\tinsert_out_of_ssa_copy_on_edge (scop, single_pred_edge (bb),\n \t\t\t\t\tzero_dim_array, arg);\n     }\n \n@@ -2293,7 +2285,7 @@ rewrite_close_phi_out_of_ssa (gimple_stmt_iterator *psi, sese region)\n    dimension array for it.  */\n \n static void\n-rewrite_phi_out_of_ssa (gimple_stmt_iterator *psi)\n+rewrite_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n {\n   size_t i;\n   gimple phi = gsi_stmt (*psi);\n@@ -2314,9 +2306,10 @@ rewrite_phi_out_of_ssa (gimple_stmt_iterator *psi)\n \t pattern matching of the vectorizer.  */\n       if (TREE_CODE (arg) == SSA_NAME\n \t  && e->src == bb->loop_father->latch)\n-\tinsert_out_of_ssa_copy (zero_dim_array, arg, SSA_NAME_DEF_STMT (arg));\n+\tinsert_out_of_ssa_copy (zero_dim_array, arg,\n+\t\t\t\tSSA_NAME_DEF_STMT (arg));\n       else\n-\tinsert_out_of_ssa_copy_on_edge (e, zero_dim_array, arg);\n+\tinsert_out_of_ssa_copy_on_edge (scop, e, zero_dim_array, arg);\n     }\n \n   var = force_gimple_operand (zero_dim_array, &stmts, true, NULL_TREE);\n@@ -2362,7 +2355,7 @@ rewrite_degenerate_phi (gimple_stmt_iterator *psi)\n \n /* Rewrite out of SSA all the reduction phi nodes of SCOP.  */\n \n-void\n+static void\n rewrite_reductions_out_of_ssa (scop_p scop)\n {\n   basic_block bb;\n@@ -2386,10 +2379,10 @@ rewrite_reductions_out_of_ssa (scop_p scop)\n \t    rewrite_degenerate_phi (&psi);\n \n \t  else if (scalar_close_phi_node_p (phi))\n-\t    rewrite_close_phi_out_of_ssa (&psi, region);\n+\t    rewrite_close_phi_out_of_ssa (scop, &psi);\n \n \t  else if (reduction_phi_p (region, &psi))\n-\t    rewrite_phi_out_of_ssa (&psi);\n+\t    rewrite_phi_out_of_ssa (scop, &psi);\n \t}\n \n   update_ssa (TODO_update_ssa);\n@@ -2402,7 +2395,8 @@ rewrite_reductions_out_of_ssa (scop_p scop)\n    read from ZERO_DIM_ARRAY.  */\n \n static void\n-rewrite_cross_bb_scalar_dependence (tree zero_dim_array, tree def, gimple use_stmt)\n+rewrite_cross_bb_scalar_dependence (tree zero_dim_array,\n+\t\t\t\t    tree def, gimple use_stmt)\n {\n   tree var = SSA_NAME_VAR (def);\n   gimple name_stmt = gimple_build_assign (var, zero_dim_array);\n@@ -2525,9 +2519,9 @@ rewrite_cross_bb_scalar_deps (scop_p scop, gimple_stmt_iterator *gsi)\n \tgimple_stmt_iterator psi = gsi_for_stmt (use_stmt);\n \n \tif (scalar_close_phi_node_p (gsi_stmt (psi)))\n-\t  rewrite_close_phi_out_of_ssa (&psi, region);\n+\t  rewrite_close_phi_out_of_ssa (scop, &psi);\n \telse\n-\t  rewrite_phi_out_of_ssa (&psi);\n+\t  rewrite_phi_out_of_ssa (scop, &psi);\n       }\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n@@ -2545,15 +2539,16 @@ rewrite_cross_bb_scalar_deps (scop_p scop, gimple_stmt_iterator *gsi)\n \t    gsi_next (gsi);\n \t  }\n \n-\trewrite_cross_bb_scalar_dependence (zero_dim_array, def, use_stmt);\n+\trewrite_cross_bb_scalar_dependence (zero_dim_array,\n+\t\t\t\t\t    def, use_stmt);\n       }\n \n   return res;\n }\n \n /* Rewrite out of SSA all the reduction phi nodes of SCOP.  */\n \n-void\n+static void\n rewrite_cross_bb_scalar_deps_out_of_ssa (scop_p scop)\n {\n   basic_block bb;\n@@ -2612,30 +2607,44 @@ nb_data_writes_in_bb (basic_block bb)\n   return res;\n }\n \n-/* Splits STMT out of its current BB.  */\n+/* Splits at STMT the basic block BB represented as PBB in the\n+   polyhedral form.  */\n+\n+static edge\n+split_pbb (scop_p scop, poly_bb_p pbb, basic_block bb, gimple stmt)\n+{\n+  edge e1 = split_block (bb, stmt);\n+  new_pbb_from_pbb (scop, pbb, e1->dest);\n+  return e1;\n+}\n+\n+/* Splits STMT out of its current BB.  This is done for reduction\n+   statements for which we want to ignore data dependences.  */\n \n static basic_block\n-split_reduction_stmt (gimple stmt)\n+split_reduction_stmt (scop_p scop, gimple stmt)\n {\n-  gimple_stmt_iterator gsi;\n   basic_block bb = gimple_bb (stmt);\n-  edge e;\n+  poly_bb_p pbb = pbb_from_bb (bb);\n+  edge e1;\n \n   /* Do not split basic blocks with no writes to memory: the reduction\n      will be the only write to memory.  */\n   if (nb_data_writes_in_bb (bb) == 0)\n     return bb;\n \n-  split_block (bb, stmt);\n+  e1 = split_pbb (scop, pbb, bb, stmt);\n \n-  if (gsi_one_before_end_p (gsi_start_nondebug_bb (bb)))\n-    return bb;\n-\n-  gsi = gsi_last_bb (bb);\n-  gsi_prev (&gsi);\n-  e = split_block (bb, gsi_stmt (gsi));\n+  /* Split once more only when the reduction stmt is not the only one\n+     left in the original BB.  */\n+  if (!gsi_one_before_end_p (gsi_start_nondebug_bb (bb)))\n+    {\n+      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+      gsi_prev (&gsi);\n+      e1 = split_pbb (scop, pbb, bb, gsi_stmt (gsi));\n+    }\n \n-  return e->dest;\n+  return e1->dest;\n }\n \n /* Return true when stmt is a reduction operation.  */\n@@ -2864,13 +2873,12 @@ static void\n translate_scalar_reduction_to_array_for_stmt (tree red, gimple stmt,\n \t\t\t\t\t      gimple loop_phi)\n {\n-  gimple_stmt_iterator insert_gsi = gsi_after_labels (gimple_bb (loop_phi));\n   tree res = gimple_phi_result (loop_phi);\n   gimple assign = gimple_build_assign (res, red);\n+  gimple_stmt_iterator insert_gsi = gsi_after_labels (gimple_bb (loop_phi));\n \n   gsi_insert_before (&insert_gsi, assign, GSI_SAME_STMT);\n \n-  insert_gsi = gsi_after_labels (gimple_bb (stmt));\n   assign = gimple_build_assign (red, gimple_assign_lhs (stmt));\n   insert_gsi = gsi_for_stmt (stmt);\n   gsi_insert_after (&insert_gsi, assign, GSI_SAME_STMT);\n@@ -2922,9 +2930,9 @@ remove_phi (gimple phi)\n    are the loop and close phi nodes of each of the outer loops.  */\n \n static void\n-translate_scalar_reduction_to_array (VEC (gimple, heap) *in,\n-\t\t\t\t     VEC (gimple, heap) *out,\n-\t\t\t\t     sbitmap reductions)\n+translate_scalar_reduction_to_array (scop_p scop,\n+\t\t\t\t     VEC (gimple, heap) *in,\n+\t\t\t\t     VEC (gimple, heap) *out)\n {\n   unsigned int i;\n   gimple loop_phi;\n@@ -2937,9 +2945,9 @@ translate_scalar_reduction_to_array (VEC (gimple, heap) *in,\n       if (i == 0)\n \t{\n \t  gimple stmt = loop_phi;\n-\t  basic_block bb = split_reduction_stmt (stmt);\n-\n-\t  SET_BIT (reductions, bb->index);\n+\t  basic_block bb = split_reduction_stmt (scop, stmt);\n+\t  poly_bb_p pbb = pbb_from_bb (bb);\n+\t  PBB_IS_REDUCTION (pbb) = true;\n \t  gcc_assert (close_phi == loop_phi);\n \n \t  red = create_zero_dim_array\n@@ -2954,7 +2962,7 @@ translate_scalar_reduction_to_array (VEC (gimple, heap) *in,\n \t  insert_out_of_ssa_copy (gimple_phi_result (close_phi), red,\n \t\t\t\t  close_phi);\n \t  insert_out_of_ssa_copy_on_edge\n-\t    (edge_initial_value_for_loop_phi (loop_phi),\n+\t    (scop, edge_initial_value_for_loop_phi (loop_phi),\n \t     red, initial_value_for_loop_phi (loop_phi));\n \t}\n \n@@ -2967,8 +2975,8 @@ translate_scalar_reduction_to_array (VEC (gimple, heap) *in,\n    true when something has been changed.  */\n \n static bool\n-rewrite_commutative_reductions_out_of_ssa_close_phi (gimple close_phi,\n-\t\t\t\t\t\t     sbitmap reductions)\n+rewrite_commutative_reductions_out_of_ssa_close_phi (scop_p scop,\n+\t\t\t\t\t\t     gimple close_phi)\n {\n   bool res;\n   VEC (gimple, heap) *in = VEC_alloc (gimple, heap, 10);\n@@ -2977,7 +2985,7 @@ rewrite_commutative_reductions_out_of_ssa_close_phi (gimple close_phi,\n   detect_commutative_reduction (close_phi, &in, &out);\n   res = VEC_length (gimple, in) > 0;\n   if (res)\n-    translate_scalar_reduction_to_array (in, out, reductions);\n+    translate_scalar_reduction_to_array (scop, in, out);\n \n   VEC_free (gimple, heap, in);\n   VEC_free (gimple, heap, out);\n@@ -2988,9 +2996,8 @@ rewrite_commutative_reductions_out_of_ssa_close_phi (gimple close_phi,\n    Returns true when something has been changed.  */\n \n static bool\n-rewrite_commutative_reductions_out_of_ssa_loop (loop_p loop,\n-\t\t\t\t\t\tsbitmap reductions,\n-\t\t\t\t\t\tsese region)\n+rewrite_commutative_reductions_out_of_ssa_loop (scop_p scop,\n+\t\t\t\t\t\tloop_p loop)\n {\n   gimple_stmt_iterator gsi;\n   edge exit = single_exit (loop);\n@@ -3003,30 +3010,26 @@ rewrite_commutative_reductions_out_of_ssa_loop (loop_p loop,\n   for (gsi = gsi_start_phis (exit->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     if ((res = gimple_phi_result (gsi_stmt (gsi)))\n \t&& is_gimple_reg (res)\n-\t&& !scev_analyzable_p (res, region))\n+\t&& !scev_analyzable_p (res, SCOP_REGION (scop)))\n       changed |= rewrite_commutative_reductions_out_of_ssa_close_phi\n-\t(gsi_stmt (gsi), reductions);\n+\t(scop, gsi_stmt (gsi));\n \n   return changed;\n }\n \n /* Rewrites all the commutative reductions from SCOP out of SSA.  */\n \n-void\n-rewrite_commutative_reductions_out_of_ssa (sese region, sbitmap reductions)\n+static void\n+rewrite_commutative_reductions_out_of_ssa (scop_p scop)\n {\n   loop_iterator li;\n   loop_p loop;\n   bool changed = false;\n-\n-  if (!flag_associative_math)\n-    return;\n+  sese region = SCOP_REGION (scop);\n \n   FOR_EACH_LOOP (li, loop, 0)\n     if (loop_in_sese_p (loop, region))\n-      changed |= rewrite_commutative_reductions_out_of_ssa_loop (loop,\n-\t\t\t\t\t\t\t\t reductions,\n-\t\t\t\t\t\t\t\t region);\n+      changed |= rewrite_commutative_reductions_out_of_ssa_loop (scop, loop);\n \n   if (changed)\n     {\n@@ -3084,6 +3087,7 @@ build_poly_scop (scop_p scop)\n   sese region = SCOP_REGION (scop);\n   graphite_dim_t max_dim;\n \n+  build_scop_bbs (scop);\n \n   /* FIXME: This restriction is needed to avoid a problem in CLooG.\n      Once CLooG is fixed, remove this guard.  Anyways, it makes no\n@@ -3105,11 +3109,20 @@ build_poly_scop (scop_p scop)\n \n   build_scop_iteration_domain (scop);\n   build_scop_context (scop);\n-\n   add_conditions_to_constraints (scop);\n+\n+  /* Rewrite out of SSA only after having translated the\n+     representation to the polyhedral representation to avoid scev\n+     analysis failures.  That means that these functions will insert\n+     new data references that they create in the right place.  */\n+  if (flag_associative_math)\n+    rewrite_commutative_reductions_out_of_ssa (scop);\n+  rewrite_reductions_out_of_ssa (scop);\n+  rewrite_cross_bb_scalar_deps_out_of_ssa (scop);\n+\n+  build_scop_drs (scop);\n   scop_to_lst (scop);\n   build_scop_scattering (scop);\n-  build_scop_drs (scop);\n \n   /* This SCoP has been translated to the polyhedral\n      representation.  */"}, {"sha": "d341c0fa4b7b8b02492730e42b4ab4bb705ee3cc", "filename": "gcc/graphite-sese-to-poly.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fgraphite-sese-to-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fgraphite-sese-to-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.h?ref=efa213905e57c906775d51db13e1479f4a277184", "patch": "@@ -29,9 +29,5 @@ struct base_alias_pair\n };\n \n void build_poly_scop (scop_p);\n-void rewrite_commutative_reductions_out_of_ssa (sese, sbitmap);\n-void rewrite_reductions_out_of_ssa (scop_p);\n-void rewrite_cross_bb_scalar_deps_out_of_ssa (scop_p);\n-void build_scop_bbs (scop_p, sbitmap);\n \n #endif"}, {"sha": "4ce484afdad402c35c558884daa63d61789476ed", "filename": "gcc/graphite.c", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=efa213905e57c906775d51db13e1479f4a277184", "patch": "@@ -262,7 +262,6 @@ graphite_transform_loops (void)\n   bool need_cfg_cleanup_p = false;\n   VEC (scop_p, heap) *scops = NULL;\n   htab_t bb_pbb_mapping;\n-  sbitmap reductions;\n \n   if (!graphite_initialize ())\n     return;\n@@ -276,33 +275,17 @@ graphite_transform_loops (void)\n     }\n \n   bb_pbb_mapping = htab_create (10, bb_pbb_map_hash, eq_bb_pbb_map, free);\n-  reductions = sbitmap_alloc (last_basic_block * 2);\n-  sbitmap_zero (reductions);\n-\n-  FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n-    if (dbg_cnt (graphite_scop))\n-      rewrite_commutative_reductions_out_of_ssa (SCOP_REGION (scop),\n-\t\t\t\t\t\t reductions);\n \n   FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n     if (dbg_cnt (graphite_scop))\n       {\n-\trewrite_reductions_out_of_ssa (scop);\n-\trewrite_cross_bb_scalar_deps_out_of_ssa (scop);\n-\tbuild_scop_bbs (scop, reductions);\n-      }\n-\n-  sbitmap_free (reductions);\n+\tbuild_poly_scop (scop);\n \n-  FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n-    if (dbg_cnt (graphite_scop))\n-      build_poly_scop (scop);\n-\n-  FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n-    if (POLY_SCOP_P (scop)\n-\t&& apply_poly_transforms (scop)\n-\t&& gloog (scop, bb_pbb_mapping))\n-      need_cfg_cleanup_p = true;\n+\tif (POLY_SCOP_P (scop)\n+\t    && apply_poly_transforms (scop)\n+\t    && gloog (scop, bb_pbb_mapping))\n+\t  need_cfg_cleanup_p = true;\n+      }\n \n   htab_delete (bb_pbb_mapping);\n   free_scops (scops);"}, {"sha": "10bf874a174175ec9b23399c52c7d5a23a0e754e", "filename": "gcc/sese.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa213905e57c906775d51db13e1479f4a277184/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=efa213905e57c906775d51db13e1479f4a277184", "patch": "@@ -312,6 +312,7 @@ recompute_all_dominators (void)\n typedef struct gimple_bb\n {\n   basic_block bb;\n+  struct poly_bb *pbb;\n \n   /* Lists containing the restrictions of the conditional statements\n      dominating this bb.  This bb can only be executed, if all conditions\n@@ -338,10 +339,11 @@ typedef struct gimple_bb\n   VEC (data_reference_p, heap) *data_refs;\n } *gimple_bb_p;\n \n-#define GBB_BB(GBB) GBB->bb\n-#define GBB_DATA_REFS(GBB) GBB->data_refs\n-#define GBB_CONDITIONS(GBB) GBB->conditions\n-#define GBB_CONDITION_CASES(GBB) GBB->condition_cases\n+#define GBB_BB(GBB) (GBB)->bb\n+#define GBB_PBB(GBB) (GBB)->pbb\n+#define GBB_DATA_REFS(GBB) (GBB)->data_refs\n+#define GBB_CONDITIONS(GBB) (GBB)->conditions\n+#define GBB_CONDITION_CASES(GBB) (GBB)->condition_cases\n \n /* Return the innermost loop that contains the basic block GBB.  */\n "}, {"sha": "08e7788dd202d275ec95df3692f6f7e5708840e8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa213905e57c906775d51db13e1479f4a277184/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa213905e57c906775d51db13e1479f4a277184/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=efa213905e57c906775d51db13e1479f4a277184", "patch": "@@ -1,3 +1,8 @@\n+2010-11-29  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR middle-end/45297\n+\t* gcc.dg/graphite/pr45297.c: New.\n+\n 2010-12-01  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/46730"}, {"sha": "faa653a57792054f2305e58a2857ceef00f519cf", "filename": "gcc/testsuite/gcc.dg/graphite/pr45297.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efa213905e57c906775d51db13e1479f4a277184/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr45297.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efa213905e57c906775d51db13e1479f4a277184/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr45297.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr45297.c?ref=efa213905e57c906775d51db13e1479f4a277184", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-options \"-Os -fgraphite-identity\" } */\n+\n+void\n+foo (int *p)\n+{\n+  int *q = p + 1024;\n+  while (q != p)\n+    *--q = *--q;\n+}"}]}