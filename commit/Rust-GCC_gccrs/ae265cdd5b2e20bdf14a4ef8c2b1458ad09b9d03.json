{"sha": "ae265cdd5b2e20bdf14a4ef8c2b1458ad09b9d03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUyNjVjZGQ1YjJlMjBiZGYxNGE0ZWY4YzJiMTQ1OGFkMDliOWQwMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-06-03T20:14:38Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-15T13:42:52Z"}, "message": "[Ada] Remove doc on obsolete tools\n\ngcc/ada/\n\n\t* doc/gnat_ugn/gnat_utility_programs.rst: Remove doc on obsolete\n\ttools.\n\t* gnat_ugn.texi: Regenerate.", "tree": {"sha": "a62fecc150da26467f33d261d3ad94d78e5c5cc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a62fecc150da26467f33d261d3ad94d78e5c5cc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae265cdd5b2e20bdf14a4ef8c2b1458ad09b9d03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae265cdd5b2e20bdf14a4ef8c2b1458ad09b9d03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae265cdd5b2e20bdf14a4ef8c2b1458ad09b9d03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae265cdd5b2e20bdf14a4ef8c2b1458ad09b9d03/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d15dc6fb72720d3ff499e2da9ba43eceaf4a8b04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15dc6fb72720d3ff499e2da9ba43eceaf4a8b04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d15dc6fb72720d3ff499e2da9ba43eceaf4a8b04"}], "stats": {"total": 2829, "additions": 184, "deletions": 2645}, "files": [{"sha": "883f0121263e1b34e692211313cc8800e9d4bbdb", "filename": "gcc/ada/doc/gnat_ugn/gnat_utility_programs.rst", "status": "modified", "additions": 0, "deletions": 1298, "changes": 1298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae265cdd5b2e20bdf14a4ef8c2b1458ad09b9d03/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae265cdd5b2e20bdf14a4ef8c2b1458ad09b9d03/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst?ref=ae265cdd5b2e20bdf14a4ef8c2b1458ad09b9d03", "patch": "@@ -14,9 +14,6 @@ This chapter describes a number of utility programs:\n \n   * :ref:`The_File_Cleanup_Utility_gnatclean`\n   * :ref:`The_GNAT_Library_Browser_gnatls`\n-  * :ref:`The_Cross-Referencing_Tools_gnatxref_and_gnatfind`\n-  * :ref:`The_Ada_to_HTML_Converter_gnathtml`\n-  * :ref:`The_Ada-to-XML_Converter_gnat2xml`\n   * :ref:`The_Coding_Standard_Verifier_gnatcheck`\n   * :ref:`The_GNAT_Metrics_Tool_gnatmetric`\n   * :ref:`The_GNAT_Pretty_Printer_gnatpp`\n@@ -31,8 +28,6 @@ This chapter describes a number of utility programs:\n \n   * :ref:`The_File_Cleanup_Utility_gnatclean`\n   * :ref:`The_GNAT_Library_Browser_gnatls`\n-  * :ref:`The_Cross-Referencing_Tools_gnatxref_and_gnatfind`\n-  * :ref:`The_Ada_to_HTML_Converter_gnathtml`\n \n Other GNAT utilities are described elsewhere in this manual:\n \n@@ -472,1299 +467,6 @@ building specialized scripts.\n       /home/comar/local/adainclude/unchconv.ads\n \n \n-.. _The_Cross-Referencing_Tools_gnatxref_and_gnatfind:\n-\n-The Cross-Referencing Tools ``gnatxref`` and ``gnatfind``\n-=========================================================\n-\n-.. index:: ! gnatxref\n-.. index:: ! gnatfind\n-\n-The compiler generates cross-referencing information (unless\n-you set the :switch:`-gnatx` switch), which are saved in the :file:`.ali` files.\n-This information indicates where in the source each entity is declared and\n-referenced. Note that entities in package Standard are not included, but\n-entities in all other predefined units are included in the output.\n-\n-Before using any of these two tools, you need to compile successfully your\n-application, so that GNAT gets a chance to generate the cross-referencing\n-information.\n-\n-The two tools ``gnatxref`` and ``gnatfind`` take advantage of this\n-information to provide the user with the capability to easily locate the\n-declaration and references to an entity. These tools are quite similar,\n-the difference being that ``gnatfind`` is intended for locating\n-definitions and/or references to a specified entity or entities, whereas\n-``gnatxref`` is oriented to generating a full report of all\n-cross-references.\n-\n-To use these tools, you must not compile your application using the\n-:switch:`-gnatx` switch on the ``gnatmake`` command line\n-(see :ref:`The_GNAT_Make_Program_gnatmake`). Otherwise, cross-referencing\n-information will not be generated.\n-\n-.. _gnatxref_Switches:\n-\n-``gnatxref`` Switches\n----------------------\n-\n-The command invocation for ``gnatxref`` is:\n-\n-  ::\n-\n-      $ gnatxref [ switches ] sourcefile1 [ sourcefile2 ... ]\n-\n-where\n-\n-``sourcefile1`` [, ``sourcefile2`` ...]\n-  identify the source files for which a report is to be generated. The\n-  ``with``\\ ed units will be processed too. You must provide at least one file.\n-\n-  These file names are considered to be regular expressions, so for instance\n-  specifying :file:`source\\*.adb` is the same as giving every file in the current\n-  directory whose name starts with :file:`source` and whose extension is\n-  :file:`adb`.\n-\n-  You shouldn't specify any directory name, just base names. ``gnatxref``\n-  and ``gnatfind`` will be able to locate these files by themselves using\n-  the source path. If you specify directories, no result is produced.\n-\n-The following switches are available for ``gnatxref``:\n-\n-\n-.. index:: --version (gnatxref)\n-\n-:switch:`--version`\n-  Display copyright and version, then exit disregarding all other options.\n-\n-\n-.. index:: --help (gnatxref)\n-\n-:switch:`--help`\n-  If :switch:`--version` was not used, display usage, then exit disregarding\n-  all other options.\n-\n-\n-.. index:: -a (gnatxref)\n-\n-:switch:`-a`\n-  If this switch is present, ``gnatfind`` and ``gnatxref`` will parse\n-  the read-only files found in the library search path. Otherwise, these files\n-  will be ignored. This option can be used to protect Gnat sources or your own\n-  libraries from being parsed, thus making ``gnatfind`` and ``gnatxref``\n-  much faster, and their output much smaller. Read-only here refers to access\n-  or permissions status in the file system for the current user.\n-\n-\n-.. index:: -aIDIR (gnatxref)\n-\n-:switch:`-aI{DIR}`\n-  When looking for source files also look in directory DIR. The order in which\n-  source file search is undertaken is the same as for ``gnatmake``.\n-\n-\n-.. index:: -aODIR (gnatxref)\n-\n-:switch:`aO{DIR}`\n-  When -searching for library and object files, look in directory\n-  DIR. The order in which library files are searched is the same as for\n-  ``gnatmake``.\n-\n-\n-.. index:: -nostdinc (gnatxref)\n-\n-:switch:`-nostdinc`\n-  Do not look for sources in the system default directory.\n-\n-\n-.. index:: -nostdlib (gnatxref)\n-\n-:switch:`-nostdlib`\n-  Do not look for library files in the system default directory.\n-\n-\n-.. index:: --ext (gnatxref)\n-\n-:switch:`--ext={extension}`\n-  Specify an alternate ali file extension. The default is ``ali`` and other\n-  extensions (e.g. ``gli`` for C/C++ sources) may be specified via this switch.\n-  Note that if this switch overrides the default, only the new extension will\n-  be considered.\n-\n-\n-.. index:: --RTS (gnatxref)\n-\n-:switch:`--RTS={rts-path}`\n-  Specifies the default location of the runtime library. Same meaning as the\n-  equivalent ``gnatmake`` flag (:ref:`Switches_for_gnatmake`).\n-\n-\n-.. index:: -d (gnatxref)\n-\n-:switch:`-d`\n-  If this switch is set ``gnatxref`` will output the parent type\n-  reference for each matching derived types.\n-\n-\n-.. index:: -f (gnatxref)\n-\n-:switch:`-f`\n-  If this switch is set, the output file names will be preceded by their\n-  directory (if the file was found in the search path). If this switch is\n-  not set, the directory will not be printed.\n-\n-\n-.. index:: -g (gnatxref)\n-\n-:switch:`-g`\n-  If this switch is set, information is output only for library-level\n-  entities, ignoring local entities. The use of this switch may accelerate\n-  ``gnatfind`` and ``gnatxref``.\n-\n-\n-.. index:: -IDIR (gnatxref)\n-\n-:switch:`-I{DIR}`\n-  Equivalent to :switch:`-aODIR -aIDIR`.\n-\n-\n-.. index:: -pFILE (gnatxref)\n-\n-:switch:`-p{FILE}`\n-  Specify a configuration file to use to list the source and object directories.\n-\n-  If a file is specified, then the content of the source directory and object\n-  directory lines are added as if they had been specified respectively\n-  by :switch:`-aI` and :switch:`-aO`.\n-\n-  See :ref:`Configuration_Files_for_gnatxref_and_gnatfind` for the syntax\n-  of this configuration file.\n-\n-:switch:`-u`\n-  Output only unused symbols. This may be really useful if you give your\n-  main compilation unit on the command line, as ``gnatxref`` will then\n-  display every unused entity and 'with'ed package.\n-\n-:switch:`-v`\n-  Instead of producing the default output, ``gnatxref`` will generate a\n-  :file:`tags` file that can be used by vi. For examples how to use this\n-  feature, see :ref:`Examples_of_gnatxref_Usage`. The tags file is output\n-  to the standard output, thus you will have to redirect it to a file.\n-\n-All these switches may be in any order on the command line, and may even\n-appear after the file names. They need not be separated by spaces, thus\n-you can say ``gnatxref -ag`` instead of ``gnatxref -a -g``.\n-\n-.. _gnatfind_Switches:\n-\n-``gnatfind`` Switches\n----------------------\n-\n-The command invocation for ``gnatfind`` is:\n-\n-  ::\n-\n-    $ gnatfind [ switches ]  pattern[:sourcefile[:line[:column]]]\n-          [file1 file2 ...]\n-\n-with the following iterpretation of the command arguments:\n-\n-*pattern*\n-  An entity will be output only if it matches the regular expression found\n-  in *pattern*, see :ref:`Regular_Expressions_in_gnatfind_and_gnatxref`.\n-\n-  Omitting the pattern is equivalent to specifying ``*``, which\n-  will match any entity. Note that if you do not provide a pattern, you\n-  have to provide both a sourcefile and a line.\n-\n-  Entity names are given in Latin-1, with uppercase/lowercase equivalence\n-  for matching purposes. At the current time there is no support for\n-  8-bit codes other than Latin-1, or for wide characters in identifiers.\n-\n-*sourcefile*\n-  ``gnatfind`` will look for references, bodies or declarations\n-  of symbols referenced in :file:`sourcefile`, at line ``line``\n-  and column ``column``. See :ref:`Examples_of_gnatfind_Usage`\n-  for syntax examples.\n-\n-*line*\n-  A decimal integer identifying the line number containing\n-  the reference to the entity (or entities) to be located.\n-\n-\n-*column*\n-  A decimal integer identifying the exact location on the\n-  line of the first character of the identifier for the\n-  entity reference. Columns are numbered from 1.\n-\n-\n-*file1 file2 ...*\n-  The search will be restricted to these source files. If none are given, then\n-  the search will be conducted for every library file in the search path.\n-  These files must appear only after the pattern or sourcefile.\n-\n-  These file names are considered to be regular expressions, so for instance\n-  specifying :file:`source\\*.adb` is the same as giving every file in the current\n-  directory whose name starts with :file:`source` and whose extension is\n-  :file:`adb`.\n-\n-  The location of the spec of the entity will always be displayed, even if it\n-  isn't in one of :file:`file1`, :file:`file2`, ... The\n-  occurrences of the entity in the separate units of the ones given on the\n-  command line will also be displayed.\n-\n-  Note that if you specify at least one file in this part, ``gnatfind`` may\n-  sometimes not be able to find the body of the subprograms.\n-\n-At least one of 'sourcefile' or 'pattern' has to be present on\n-the command line.\n-\n-The following switches are available:\n-\n-.. index:: --version (gnatfind)\n-\n-:switch:`--version`\n-  Display copyright and version, then exit disregarding all other options.\n-\n-\n-.. index:: --help (gnatfind)\n-\n-:switch:`--help`\n-  If :switch:`--version` was not used, display usage, then exit disregarding\n-  all other options.\n-\n-\n-.. index:: -a (gnatfind)\n-\n-:switch:`-a`\n-  If this switch is present, ``gnatfind`` and ``gnatxref`` will parse\n-  the read-only files found in the library search path. Otherwise, these files\n-  will be ignored. This option can be used to protect Gnat sources or your own\n-  libraries from being parsed, thus making ``gnatfind`` and ``gnatxref``\n-  much faster, and their output much smaller. Read-only here refers to access\n-  or permission status in the file system for the current user.\n-\n-\n-.. index:: -aIDIR (gnatfind)\n-\n-:switch:`-aI{DIR}`\n-  When looking for source files also look in directory DIR. The order in which\n-  source file search is undertaken is the same as for ``gnatmake``.\n-\n-\n-.. index:: -aODIR (gnatfind)\n-\n-:switch:`-aO{DIR}`\n-  When searching for library and object files, look in directory\n-  DIR. The order in which library files are searched is the same as for\n-  ``gnatmake``.\n-\n-\n-.. index:: -nostdinc (gnatfind)\n-\n-:switch:`-nostdinc`\n-  Do not look for sources in the system default directory.\n-\n-\n-.. index:: -nostdlib (gnatfind)\n-\n-:switch:`-nostdlib`\n-  Do not look for library files in the system default directory.\n-\n-\n-.. index:: --ext (gnatfind)\n-\n-:switch:`--ext={extension}`\n-  Specify an alternate ali file extension. The default is ``ali`` and other\n-  extensions may be specified via this switch. Note that if this switch\n-  overrides the default, only the new extension will be considered.\n-\n-\n-.. index:: --RTS (gnatfind)\n-\n-:switch:`--RTS={rts-path}`\n-  Specifies the default location of the runtime library. Same meaning as the\n-  equivalent ``gnatmake`` flag (:ref:`Switches_for_gnatmake`).\n-\n-\n-.. index:: -d (gnatfind)\n-\n-:switch:`-d`\n-  If this switch is set, then ``gnatfind`` will output the parent type\n-  reference for each matching derived types.\n-\n-\n-.. index:: -e (gnatfind)\n-\n-:switch:`-e`\n-  By default, ``gnatfind`` accept the simple regular expression set for\n-  ``pattern``. If this switch is set, then the pattern will be\n-  considered as full Unix-style regular expression.\n-\n-\n-.. index:: -f (gnatfind)\n-\n-:switch:`-f`\n-  If this switch is set, the output file names will be preceded by their\n-  directory (if the file was found in the search path). If this switch is\n-  not set, the directory will not be printed.\n-\n-\n-.. index:: -g (gnatfind)\n-\n-:switch:`-g`\n-  If this switch is set, information is output only for library-level\n-  entities, ignoring local entities. The use of this switch may accelerate\n-  ``gnatfind`` and ``gnatxref``.\n-\n-\n-.. index:: -IDIR (gnatfind)\n-\n-:switch:`-I{DIR}`\n-  Equivalent to :switch:`-aODIR -aIDIR`.\n-\n-\n-.. index:: -pFILE (gnatfind)\n-\n-:switch:`-p{FILE}`\n-  Specify a configuration file to use to list the source and object directories.\n-\n-  If a file is specified, then the content of the source directory and object\n-  directory lines are added as if they had been specified respectively\n-  by :switch:`-aI` and :switch:`-aO`.\n-\n-  See :ref:`Configuration_Files_for_gnatxref_and_gnatfind` for the syntax\n-  of this configuration file.\n-\n-.. index:: -r (gnatfind)\n-\n-:switch:`-r`\n-  By default, ``gnatfind`` will output only the information about the\n-  declaration, body or type completion of the entities. If this switch is\n-  set, the ``gnatfind`` will locate every reference to the entities in\n-  the files specified on the command line (or in every file in the search\n-  path if no file is given on the command line).\n-\n-\n-.. index:: -s (gnatfind)\n-\n-:switch:`-s`\n-  If this switch is set, then ``gnatfind`` will output the content\n-  of the Ada source file lines were the entity was found.\n-\n-\n-.. index:: -t (gnatfind)\n-\n-:switch:`-t`\n-  If this switch is set, then ``gnatfind`` will output the type hierarchy for\n-  the specified type. It act like -d option but recursively from parent\n-  type to parent type. When this switch is set it is not possible to\n-  specify more than one file.\n-\n-\n-All these switches may be in any order on the command line, and may even\n-appear after the file names. They need not be separated by spaces, thus\n-you can say ``gnatxref -ag`` instead of\n-``gnatxref -a -g``.\n-\n-As stated previously, ``gnatfind`` will search in every directory in the\n-search path. You can force it to look only in the current directory if\n-you specify ``*`` at the end of the command line.\n-\n-.. _Configuration_Files_for_gnatxref_and_gnatfind:\n-\n-Configuration Files for ``gnatxref`` and ``gnatfind``\n------------------------------------------------------\n-\n-Configuration files are used by ``gnatxref`` and ``gnatfind`` to specify\n-the list of source and object directories to consider. They can be\n-specified via the :switch:`-p` switch.\n-\n-The following lines can be included, in any order in the file:\n-\n-* *src_dir=DIR*\n-    [default: ``\"./\"``].\n-    Specifies a directory where to look for source files. Multiple ``src_dir``\n-    lines can be specified and they will be searched in the order they\n-    are specified.\n-\n-* *obj_dir=DIR*\n-    [default: ``\"./\"``].\n-    Specifies a directory where to look for object and library files. Multiple\n-    ``obj_dir`` lines can be specified, and they will be searched in the order\n-    they are specified\n-\n-Any other line will be silently ignored.\n-\n-.. _Regular_Expressions_in_gnatfind_and_gnatxref:\n-\n-Regular Expressions in ``gnatfind`` and ``gnatxref``\n-----------------------------------------------------\n-\n-As specified in the section about ``gnatfind``, the pattern can be a\n-regular expression. Two kinds of regular expressions\n-are recognized:\n-\n-* *Globbing pattern*\n-    These are the most common regular expression. They are the same as are\n-    generally used in a Unix shell command line, or in a DOS session.\n-\n-    Here is a more formal grammar:\n-\n-    ::\n-\n-        regexp ::= term\n-        term   ::= elmt            -- matches elmt\n-        term   ::= elmt elmt       -- concatenation (elmt then elmt)\n-        term   ::= *               -- any string of 0 or more characters\n-        term   ::= ?               -- matches any character\n-        term   ::= [char {char}]   -- matches any character listed\n-        term   ::= [char - char]   -- matches any character in range\n-\n-* *Full regular expression*\n-    The second set of regular expressions is much more powerful. This is the\n-    type of regular expressions recognized by utilities such as ``grep``.\n-\n-    The following is the form of a regular expression, expressed in same BNF\n-    style as is found in the Ada Reference Manual:\n-\n-    ::\n-\n-        regexp ::= term {| term}   -- alternation (term or term ...)\n-\n-        term ::= item {item}       -- concatenation (item then item)\n-\n-        item ::= elmt              -- match elmt\n-        item ::= elmt *            -- zero or more elmt's\n-        item ::= elmt +            -- one or more elmt's\n-        item ::= elmt ?            -- matches elmt or nothing\n-\n-        elmt ::= nschar            -- matches given character\n-        elmt ::= [nschar {nschar}]   -- matches any character listed\n-        elmt ::= [^ nschar {nschar}] -- matches any character not listed\n-        elmt ::= [char - char]     -- matches chars in given range\n-        elmt ::= \\\\ char            -- matches given character\n-        elmt ::= .                 -- matches any single character\n-        elmt ::= ( regexp )        -- parens used for grouping\n-\n-        char ::= any character, including special characters\n-        nschar ::= any character except ()[].*+?^\n-\n-    Here are a few examples:\n-\n-      ``abcde|fghi``\n-          will match any of the two strings ``abcde`` and ``fghi``,\n-\n-      ``abc*d``\n-          will match any string like ``abd``, ``abcd``, ``abccd``,\n-          ``abcccd``, and so on,\n-\n-      ``[a-z]+``\n-          will match any string which has only lowercase characters in it (and at\n-          least one character.\n-\n-\n-.. _Examples_of_gnatxref_Usage:\n-\n-Examples of ``gnatxref`` Usage\n-------------------------------\n-\n-General Usage\n-^^^^^^^^^^^^^\n-\n-For the following examples, we will consider the following units:\n-\n-  .. code-block:: ada\n-\n-     main.ads:\n-     1: with Bar;\n-     2: package Main is\n-     3:     procedure Foo (B : in Integer);\n-     4:     C : Integer;\n-     5: private\n-     6:     D : Integer;\n-     7: end Main;\n-\n-     main.adb:\n-     1: package body Main is\n-     2:     procedure Foo (B : in Integer) is\n-     3:     begin\n-     4:        C := B;\n-     5:        D := B;\n-     6:        Bar.Print (B);\n-     7:        Bar.Print (C);\n-     8:     end Foo;\n-     9: end Main;\n-\n-     bar.ads:\n-     1: package Bar is\n-     2:     procedure Print (B : Integer);\n-     3: end bar;\n-\n-The first thing to do is to recompile your application (for instance, in\n-that case just by doing a ``gnatmake main``, so that GNAT generates\n-the cross-referencing information.\n-You can then issue any of the following commands:\n-\n-  * ``gnatxref main.adb``\n-    ``gnatxref`` generates cross-reference information for main.adb\n-    and every unit 'with'ed by main.adb.\n-\n-    The output would be:\n-\n-      ::\n-\n-          B                                                      Type: Integer\n-            Decl: bar.ads           2:22\n-          B                                                      Type: Integer\n-            Decl: main.ads          3:20\n-            Body: main.adb          2:20\n-            Ref:  main.adb          4:13     5:13     6:19\n-          Bar                                                    Type: Unit\n-            Decl: bar.ads           1:9\n-            Ref:  main.adb          6:8      7:8\n-                 main.ads           1:6\n-          C                                                      Type: Integer\n-            Decl: main.ads          4:5\n-            Modi: main.adb          4:8\n-            Ref:  main.adb          7:19\n-          D                                                      Type: Integer\n-            Decl: main.ads          6:5\n-            Modi: main.adb          5:8\n-          Foo                                                    Type: Unit\n-            Decl: main.ads          3:15\n-            Body: main.adb          2:15\n-          Main                                                    Type: Unit\n-            Decl: main.ads          2:9\n-            Body: main.adb          1:14\n-          Print                                                   Type: Unit\n-            Decl: bar.ads           2:15\n-            Ref:  main.adb          6:12     7:12\n-\n-\n-    This shows that the entity ``Main`` is declared in main.ads, line 2, column 9,\n-    its body is in main.adb, line 1, column 14 and is not referenced any where.\n-\n-    The entity ``Print`` is declared in :file:`bar.ads`, line 2, column 15 and it\n-    is referenced in :file:`main.adb`, line 6 column 12 and line 7 column 12.\n-\n-\n-  * ``gnatxref package1.adb package2.ads``\n-    ``gnatxref`` will generates cross-reference information for\n-    :file:`package1.adb`, :file:`package2.ads` and any other package ``with``\\ ed by any\n-    of these.\n-\n-\n-Using ``gnatxref`` with ``vi``\n-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-``gnatxref`` can generate a tags file output, which can be used\n-directly from ``vi``. Note that the standard version of ``vi``\n-will not work properly with overloaded symbols. Consider using another\n-free implementation of ``vi``, such as ``vim``.\n-\n-  ::\n-\n-     $ gnatxref -v gnatfind.adb > tags\n-\n-\n-The following command will generate the tags file for ``gnatfind`` itself\n-(if the sources are in the search path!):\n-\n-  ::\n-\n-     $ gnatxref -v gnatfind.adb > tags\n-\n-From ``vi``, you can then use the command :samp:`:tag {entity}`\n-(replacing ``entity`` by whatever you are looking for), and vi will\n-display a new file with the corresponding declaration of entity.\n-\n-\n-.. _Examples_of_gnatfind_Usage:\n-\n-Examples of ``gnatfind`` Usage\n-------------------------------\n-\n-* ``gnatfind -f xyz:main.adb``\n-  Find declarations for all entities xyz referenced at least once in\n-  main.adb. The references are search in every library file in the search\n-  path.\n-\n-  The directories will be printed as well (as the ``-f``\n-  switch is set)\n-\n-  The output will look like:\n-\n-    ::\n-\n-       directory/main.ads:106:14: xyz <= declaration\n-       directory/main.adb:24:10: xyz <= body\n-       directory/foo.ads:45:23: xyz <= declaration\n-\n-  I.e., one of the entities xyz found in main.adb is declared at\n-  line 12 of main.ads (and its body is in main.adb), and another one is\n-  declared at line 45 of foo.ads\n-\n-* ``gnatfind -fs xyz:main.adb``\n-  This is the same command as the previous one, but ``gnatfind`` will\n-  display the content of the Ada source file lines.\n-\n-  The output will look like:\n-\n-  ::\n-\n-      directory/main.ads:106:14: xyz <= declaration\n-         procedure xyz;\n-      directory/main.adb:24:10: xyz <= body\n-         procedure xyz is\n-      directory/foo.ads:45:23: xyz <= declaration\n-         xyz : Integer;\n-\n-  This can make it easier to find exactly the location your are looking\n-  for.\n-\n-\n-* ``gnatfind -r \"*x*\":main.ads:123 foo.adb``\n-  Find references to all entities containing an x that are\n-  referenced on line 123 of main.ads.\n-  The references will be searched only in main.ads and foo.adb.\n-\n-\n-* ``gnatfind main.ads:123``\n-  Find declarations and bodies for all entities that are referenced on\n-  line 123 of main.ads.\n-\n-  This is the same as ``gnatfind \"*\":main.adb:123```\n-\n-* ``gnatfind mydir/main.adb:123:45``\n-  Find the declaration for the entity referenced at column 45 in\n-  line 123 of file main.adb in directory mydir. Note that it\n-  is usual to omit the identifier name when the column is given,\n-  since the column position identifies a unique reference.\n-\n-  The column has to be the beginning of the identifier, and should not\n-  point to any character in the middle of the identifier.\n-\n-\n-.. _The_Ada_to_HTML_Converter_gnathtml:\n-\n-The Ada to HTML Converter ``gnathtml``\n-======================================\n-\n-.. index:: ! gnathtml\n-\n-``gnathtml`` is a Perl script that allows Ada source files to be browsed using\n-standard Web browsers. For installation information, see :ref:`Installing_gnathtml`.\n-\n-Ada reserved keywords are highlighted in a bold font and Ada comments in\n-a blue font. Unless your program was compiled with the gcc :switch:`-gnatx`\n-switch to suppress the generation of cross-referencing information, user\n-defined variables and types will appear in a different color; you will\n-be able to click on any identifier and go to its declaration.\n-\n-.. _Invoking_gnathtml:\n-\n-Invoking ``gnathtml``\n----------------------\n-\n-The command line is as follows:\n-\n-  ::\n-\n-      $ perl gnathtml.pl [ switches ] ada-files\n-\n-You can specify as many Ada files as you want. ``gnathtml`` will generate\n-an html file for every ada file, and a global file called :file:`index.htm`.\n-This file is an index of every identifier defined in the files.\n-\n-The following switches are available:\n-\n-.. index:: -83 (gnathtml)\n-\n-:samp:`83`\n-  Only the Ada 83 subset of keywords will be highlighted.\n-\n-.. index:: -cc (gnathtml)\n-\n-:samp:`cc {color}`\n-  This option allows you to change the color used for comments. The default\n-  value is green. The color argument can be any name accepted by html.\n-\n-.. index:: -d (gnathtml)\n-\n-:samp:`d`\n-  If the Ada files depend on some other files (for instance through\n-  ``with`` clauses, the latter files will also be converted to html.\n-  Only the files in the user project will be converted to html, not the files\n-  in the run-time library itself.\n-\n-.. index:: -D (gnathtml)\n-\n-:samp:`D`\n-  This command is the same as :switch:`-d` above, but ``gnathtml`` will\n-  also look for files in the run-time library, and generate html files for them.\n-\n-.. index:: -ext (gnathtml)\n-\n-:samp:`ext {extension}`\n-  This option allows you to change the extension of the generated HTML files.\n-  If you do not specify an extension, it will default to :file:`htm`.\n-\n-.. index:: -f (gnathtml)\n-\n-:samp:`f`\n-  By default, gnathtml will generate html links only for global entities\n-  ('with'ed units, global variables and types,...). If you specify\n-  :switch:`-f` on the command line, then links will be generated for local\n-  entities too.\n-\n-.. index:: -l (gnathtml)\n-\n-:samp:`l {number}`\n-  If this switch is provided and ``number`` is not 0, then\n-  ``gnathtml`` will number the html files every ``number`` line.\n-\n-.. index:: -I (gnathtml)\n-\n-:samp:`I {dir}`\n-  Specify a directory to search for library files (:file:`.ALI` files) and\n-  source files. You can provide several -I switches on the command line,\n-  and the directories will be parsed in the order of the command line.\n-\n-.. index:: -o (gnathtml)\n-\n-:samp:`o {dir}`\n-  Specify the output directory for html files. By default, gnathtml will\n-  saved the generated html files in a subdirectory named :file:`html/`.\n-\n-.. index:: -p (gnathtml)\n-\n-:samp:`p {file}`\n-  If you are using Emacs and the most recent Emacs Ada mode, which provides\n-  a full Integrated Development Environment for compiling, checking,\n-  running and debugging applications, you may use :file:`.gpr` files\n-  to give the directories where Emacs can find sources and object files.\n-\n-  Using this switch, you can tell gnathtml to use these files.\n-  This allows you to get an html version of your application, even if it\n-  is spread over multiple directories.\n-\n-.. index:: -sc (gnathtml)\n-\n-:samp:`sc {color}`\n-  This switch allows you to change the color used for symbol\n-  definitions.\n-  The default value is red. The color argument can be any name accepted by html.\n-\n-.. index:: -t (gnathtml)\n-\n-:samp:`t {file}`\n-  This switch provides the name of a file. This file contains a list of\n-  file names to be converted, and the effect is exactly as though they had\n-  appeared explicitly on the command line. This\n-  is the recommended way to work around the command line length limit on some\n-  systems.\n-\n-.. _Installing_gnathtml:\n-\n-Installing ``gnathtml``\n------------------------\n-\n-``Perl`` needs to be installed on your machine to run this script.\n-``Perl`` is freely available for almost every architecture and\n-operating system via the Internet.\n-\n-On Unix systems, you  may want to modify  the  first line of  the script\n-``gnathtml``,  to explicitly  specify  where Perl\n-is located. The syntax of this line is:\n-\n-  ::\n-\n-     #!full_path_name_to_perl\n-\n-Alternatively, you may run the script using the following command line:\n-\n-  ::\n-\n-     $ perl gnathtml.pl [ switches ] files\n-\n-\n-\n-\n-.. -- +---------------------------------------------------------------------+\n-.. -- | The following sections are present only in the PRO and GPL editions |\n-.. -- +---------------------------------------------------------------------+\n-\n-.. only:: PRO or GPL\n-\n-  .. _The_Ada-to-XML_converter_gnat2xml:\n-\n-  The Ada-to-XML converter ``gnat2xml``\n-  =====================================\n-\n-  .. index:: ! gnat2xml\n-  .. index:: XML generation\n-\n-  The ``gnat2xml`` tool is an ASIS-based utility that converts\n-  Ada source code into XML.\n-\n-  ``gnat2xml`` is a project-aware tool\n-  (see :ref:`Using_Project_Files_with_GNAT_Tools` for a description of\n-  the project-related switches). The project file package that can specify\n-  ``gnat2xml`` switches is named ``gnat2xml``.\n-\n-  .. _Switches_for_``gnat2xml``:\n-\n-  Switches for ``gnat2xml``\n-  -------------------------\n-\n-  ``gnat2xml`` takes Ada source code as input, and produces XML\n-  that conforms to the schema.\n-\n-  Usage:\n-\n-    ::\n-\n-       $ gnat2xml [options] filenames [-files filename] [-cargs gcc_switches]\n-\n-  Options:\n-\n-     :switch:`--help`\n-          Generate usage information and quit, ignoring all other options\n-\n-     :switch:`-h`\n-          Same as ``--help``\n-\n-     :switch:`--version`\n-          Print version and quit, ignoring all other options\n-\n-     :switch:`-P{file}`\n-          indicates the name of the project file that describes\n-          the set of sources to be processed. The exact set of argument\n-          sources depends on other options specified, see below.\n-\n-     :switch:`-U`\n-          If a project file is specified and no argument source is explicitly\n-          specified, process all the units of the closure of the argument project.\n-          Otherwise this option has no effect.\n-\n-     :switch:`-U {main_unit}`\n-          If a project file is specified and no argument source\n-          is explicitly specified (either directly or by means of :switch:`-files`\n-          option), process the closure of units rooted at ``main_unit``.\n-          Otherwise this option has no effect.\n-\n-     :switch:`-X{name}={value}`\n-          Indicates that external variable ``name`` in\n-          the argument project has the value ``value``. Has no effect if no\n-          project is specified.\n-\n-     :switch:`--RTS={rts-path}`\n-          Specifies the default location of the runtime\n-          library. Same meaning as the equivalent ``gnatmake`` flag\n-          (:ref:`Switches_for_gnatmake`).\n-\n-     :switch:`--incremental`\n-          Incremental processing on a per-file basis. Source files are\n-          only processed if they have been modified, or if files they depend\n-          on have been modified. This is similar to the way gnatmake/gprbuild\n-          only compiles files that need to be recompiled. A project file\n-          is required in this mode.\n-\n-     :switch:`-j{n}`\n-           In :switch:`--incremental` mode, use ``n`` ``gnat2xml``\n-           processes to perform XML generation in parallel. If ``n`` is 0, then\n-           the maximum number of parallel tree creations is the number of core\n-           processors on the platform.\n-\n-     :switch:`--output-dir={dir}`\n-          Generate one .xml file for each Ada source file, in\n-          directory :file:`dir`. (Default is to generate the XML to standard\n-          output.)\n-\n-     :switch:`-I{include-dir}`\n-          Directories to search for dependencies.\n-          You can also set the ADA_INCLUDE_PATH environment variable for this.\n-\n-     :switch:`--compact`\n-          Debugging version, with interspersed source, and a more\n-          compact representation of \"sloc\". This version does not conform\n-          to any schema.\n-\n-     :switch:`--rep-clauses`\n-          generate representation clauses (see :ref:`Generating_Representation_Clauses`).\n-\n-     :switch:`-files={filename}`\n-         Take as arguments the files listed in text file ``file``.\n-         Text file ``file`` may contain empty lines that are ignored.\n-         Each nonempty line should contain the name of an existing file.\n-         Several such switches may be specified simultaneously.\n-\n-     :switch:`--ignore={filename}`\n-         Do not process the sources listed in a specified file. This option cannot\n-         be used in incremental mode.\n-\n-     :switch:`-q`\n-         Quiet\n-\n-     :switch:`-v`\n-         Verbose\n-\n-     :switch:`-cargs` ...\n-         Options to pass to gcc\n-\n-  If a project file is specified and no argument source is explicitly\n-  specified, and no :switch:`-U` is specified, then the set of processed\n-  sources is all the immediate units of the argument project.\n-\n-  Example:\n-\n-    ::\n-\n-       $ gnat2xml -v -output-dir=xml-files *.ad[sb]\n-\n-  The above will create \\*.xml files in the :file:`xml-files` subdirectory.\n-  For example, if there is an Ada package Mumble.Dumble, whose spec and\n-  body source code lives in mumble-dumble.ads and mumble-dumble.adb,\n-  the above will produce xml-files/mumble-dumble.ads.xml and\n-  xml-files/mumble-dumble.adb.xml.\n-\n-  .. _Other_Programs:\n-\n-  Other Programs\n-  --------------\n-\n-  The distribution includes two other programs that are related to\n-  ``gnat2xml``:\n-\n-  ``gnat2xsd`` is the schema generator, which generates the schema\n-  to standard output, based on the structure of Ada as encoded by\n-  ASIS. You don't need to run ``gnat2xsd`` in order to use\n-  ``gnat2xml``. To generate the schema, type:\n-\n-\n-    ::\n-\n-        $ gnat2xsd > ada-schema.xsd\n-\n-\n-  ``gnat2xml`` generates XML files that will validate against\n-  :file:`ada-schema.xsd`.\n-\n-  ``xml2gnat`` is a back-translator that translates the XML back into\n-  Ada source code. This is primarily for the purpose of testing\n-  ``gnat2xml``, rather than for users. The Ada generated by ``xml2gnat``\n-  has identical semantics to the original Ada code passed to\n-  ``gnat2xml``. It is not textually identical, however --- for example,\n-  no attempt is made to preserve the original indentation.\n-\n-  The ``xml2gnat`` command line contains a list of the same Ada files\n-  passed to gnat2xml (not the names of xml files). The xml files are\n-  assumed to be in an 'xml' subdirectory of the directory in which the\n-  Ada source files are. So for example, if the Ada source file is\n-  some/dir/mumble.adb, then the xml file is found in\n-  some/dir/xml/mumble.adb.xml. You should use the :switch:`--output-dir`\n-  switch of ``gnat2xml`` to tell it to generate the output in the xml\n-  subdirectory, so ``xml2gnat`` can find it.\n-\n-  Output goes into subdirectories \"generated_ada\" and \"self_rep\" of the\n-  output directory, which is the current directory by default, but can\n-  be overridden with --output-dir=dir on the command line.\n-\n-  .. _Structure_of_the_XML:\n-\n-  Structure of the XML\n-  --------------------\n-\n-  The primary documentation for the structure of the XML generated by\n-  ``gnat2xml`` is the schema (see ``gnat2xsd`` above). The\n-  following documentation gives additional details needed to understand\n-  the schema and therefore the XML.\n-\n-  The elements listed under Defining Occurrences, Usage Occurrences, and\n-  Other Elements represent the syntactic structure of the Ada program.\n-  Element names are given in lower case, with the corresponding element\n-  type Capitalized_Like_This. The element and element type names are\n-  derived directly from the ASIS enumeration type Flat_Element_Kinds,\n-  declared in Asis.Extensions.Flat_Kinds, with the leading ``An_`` or ``A_``\n-  removed. For example, the ASIS enumeration literal\n-  An_Assignment_Statement corresponds to the XML element\n-  assignment_statement of XML type Assignment_Statement.\n-\n-  To understand the details of the schema and the corresponding XML, it is\n-  necessary to understand the ASIS standard, as well as the GNAT-specific\n-  extension to ASIS.\n-\n-  A defining occurrence is an identifier (or character literal or operator\n-  symbol) declared by a declaration. A usage occurrence is an identifier\n-  (or ...) that references such a declared entity. For example, in:\n-\n-\n-    .. code-block:: ada\n-\n-       type T is range 1..10;\n-       X, Y : constant T := 1;\n-\n-\n-  The first 'T' is the defining occurrence of a type. The 'X' is the\n-  defining occurrence of a constant, as is the 'Y', and the second 'T' is\n-  a usage occurrence referring to the defining occurrence of T.\n-\n-  Each element has a 'sloc' (source location), and subelements for each\n-  syntactic subtree, reflecting the Ada grammar as implemented by ASIS.\n-  The types of subelements are as defined in the ASIS standard. For\n-  example, for the right-hand side of an assignment_statement we have\n-  the following comment in asis-statements.ads:\n-\n-    .. code-block:: ada\n-\n-        ------------------------------------------------------------------------------\n-        --  18.3  function Assignment_Expression\n-        ------------------------------------------------------------------------------\n-\n-           function Assignment_Expression\n-             (Statement : Asis.Statement)\n-              return      Asis.Expression;\n-\n-        ------------------------------------------------------------------------------\n-        ...\n-        --  Returns the expression from the right hand side of the assignment.\n-        ...\n-        --  Returns Element_Kinds:\n-        --       An_Expression\n-\n-\n-  The corresponding sub-element of type Assignment_Statement is:\n-\n-    ::\n-\n-        <xsd:element name=\"assignment_expression_q\" type=\"Expression_Class\"/>\n-\n-  where Expression_Class is defined by an xsd:choice of all the\n-  various kinds of expression.\n-\n-  The 'sloc' of each element indicates the starting and ending line and\n-  column numbers. Column numbers are character counts; that is, a tab\n-  counts as 1, not as however many spaces it might expand to.\n-\n-  Subelements of type Element have names ending in '_q' (for ASIS\n-  \"Query\"), and those of type Element_List end in '_ql'\n-  (\"Query returning  List\").\n-\n-  Some subelements are 'Boolean'. For example, Private_Type_Definition\n-  has has_abstract_q and has_limited_q, to indicate whether those\n-  keywords are present, as in ``type T is abstract limited private;``.\n-  False is represented by a Nil_Element. True is represented\n-  by an element type specific to that query (for example, Abstract and\n-  Limited).\n-\n-  The root of the tree is a Compilation_Unit, with attributes:\n-\n-  * unit_kind, unit_class, and unit_origin. These are strings that match the\n-    enumeration literals of types Unit_Kinds, Unit_Classes, and Unit_Origins\n-    in package Asis.\n-\n-  * unit_full_name is the full expanded name of the unit, starting from a\n-    root library unit. So for ``package P.Q.R is ...``,\n-    ``unit_full_name=\"P.Q.R\"``. Same for ``separate (P.Q) package R is ...``.\n-\n-  * def_name is the same as unit_full_name for library units; for subunits,\n-    it is just the simple name.\n-\n-  * source_file is the name of the Ada source file. For example, for\n-    the spec of ``P.Q.R``, ``source_file=\"p-q-r.ads\"``. This allows one to\n-    interpret the source locations --- the 'sloc' of all elements\n-    within this Compilation_Unit refers to line and column numbers\n-    within the named file.\n-\n-  Defining occurrences have these attributes:\n-\n-  * def_name is the simple name of the declared entity, as written in the Ada\n-    source code.\n-\n-  * def is a unique URI of the form:\n-\n-    ::\n-\n-        ada://kind/fully/qualified/name\n-\n-    where:\n-\n-    * kind indicates the kind of Ada entity being declared (see below), and\n-\n-    * fully/qualified/name, is the fully qualified name of the Ada\n-      entity, with each of 'fully', 'qualified', and 'name' being\n-      mangled for uniqueness. We do not document the mangling\n-      algorithm, which is subject to change; we just guarantee that the\n-      names are unique in the face of overloading.\n-\n-    * type is the type of the declared object, or ``null`` for\n-      declarations of things other than objects.\n-\n-  Usage occurrences have these attributes:\n-\n-  * ref_name is the same as the def_name of the corresponding defining\n-    occurrence. This attribute is not of much use, because of\n-    overloading; use ref for lookups, instead.\n-\n-  * ref is the same as the def of the corresponding defining\n-    occurrence.\n-\n-  In summary, ``def_name`` and ``ref_name`` are as in the source\n-  code of the declaration, possibly overloaded, whereas ``def`` and\n-  ``ref`` are unique-ified.\n-\n-  Literal elements have this attribute:\n-\n-  * lit_val is the value of the literal as written in the source text,\n-    appropriately escaped (e.g. ``\"`` |rightarrow| ``&quot;``). This applies\n-    only to numeric and string literals. Enumeration literals in Ada are\n-    not really \"literals\" in the usual sense; they are usage occurrences,\n-    and have ref_name and ref as described above. Note also that string\n-    literals used as operator symbols are treated as defining or usage\n-    occurrences, not as literals.\n-\n-  Elements that can syntactically represent names and expressions (which\n-  includes usage occurrences, plus function calls and so forth) have this\n-  attribute:\n-\n-  * type. If the element represents an expression or the name of an object,\n-    'type' is the 'def' for the defining occurrence of the type of that\n-    expression or name. Names of other kinds of entities, such as package\n-    names and type names, do not have a type in Ada; these have type=\"null\"\n-    in the XML.\n-\n-  Pragma elements have this attribute:\n-\n-  *  pragma_name is the name of the pragma. For language-defined pragmas, the\n-     pragma name is redundant with the element kind (for example, an\n-     assert_pragma element necessarily has pragma_name=\"Assert\"). However, all\n-     implementation-defined pragmas are lumped together in ASIS as a single\n-     element kind (for example, the GNAT-specific pragma Unreferenced is\n-     represented by an implementation_defined_pragma element with\n-     pragma_name=\"Unreferenced\").\n-\n-  Defining occurrences of formal parameters and generic formal objects have this\n-  attribute:\n-\n-  * mode indicates that the parameter is of mode 'in', 'in out', or 'out'.\n-\n-  All elements other than Not_An_Element have this attribute:\n-\n-  * checks is a comma-separated list of run-time checks that are needed\n-    for that element. The possible checks are: do_accessibility_check,\n-    do_discriminant_check,do_division_check,do_length_check,\n-    do_overflow_check,do_range_check,do_storage_check,do_tag_check.\n-\n-  The \"kind\" part of the \"def\" and \"ref\" attributes is taken from the ASIS\n-  enumeration type Flat_Declaration_Kinds, declared in\n-  Asis.Extensions.Flat_Kinds, with the leading ``An_`` or ``A_`` removed, and\n-  any trailing ``_Declaration`` or ``_Specification`` removed. Thus, the\n-  possible kinds are as follows:\n-\n-    ::\n-\n-        ordinary_type\n-        task_type\n-        protected_type\n-        incomplete_type\n-        tagged_incomplete_type\n-        private_type\n-        private_extension\n-        subtype\n-        variable\n-        constant\n-        deferred_constant\n-        single_task\n-        single_protected\n-        integer_number\n-        real_number\n-        enumeration_literal\n-        discriminant\n-        component\n-        loop_parameter\n-        generalized_iterator\n-        element_iterator\n-        procedure\n-        function\n-        parameter\n-        procedure_body\n-        function_body\n-        return_variable\n-        return_constant\n-        null_procedure\n-        expression_function\n-        package\n-        package_body\n-        object_renaming\n-        exception_renaming\n-        package_renaming\n-        procedure_renaming\n-        function_renaming\n-        generic_package_renaming\n-        generic_procedure_renaming\n-        generic_function_renaming\n-        task_body\n-        protected_body\n-        entry\n-        entry_body\n-        entry_index\n-        procedure_body_stub\n-        function_body_stub\n-        package_body_stub\n-        task_body_stub\n-        protected_body_stub\n-        exception\n-        choice_parameter\n-        generic_procedure\n-        generic_function\n-        generic_package\n-        package_instantiation\n-        procedure_instantiation\n-        function_instantiation\n-        formal_object\n-        formal_type\n-        formal_incomplete_type\n-        formal_procedure\n-        formal_function\n-        formal_package\n-        formal_package_declaration_with_box\n-\n-  .. _Generating_Representation_Clauses:\n-\n-  Generating Representation Clauses\n-  ---------------------------------\n-\n-  If the :switch:`--rep-clauses` switch is given, ``gnat2xml`` will\n-  generate representation clauses for certain types showing the\n-  representation chosen by the compiler. The information is produced by\n-  the ASIS 'Data Decomposition' facility --- see the\n-  ``Asis.Data_Decomposition`` package for details.\n-\n-  Not all types are supported. For example, ``Type_Model_Kind`` must\n-  be ``A_Simple_Static_Model``. Types declared within generic units\n-  have no representation. The clauses that are generated include\n-  ``attribute_definition_clauses`` for ``Size`` and\n-  ``Component_Size``, as well as\n-  ``record_representation_clauses``.\n-\n-  There is no guarantee that the generated representation clauses could\n-  have actually come from legal Ada code; Ada has some restrictions that\n-  are not necessarily obeyed by the generated clauses.\n-\n-  The representation clauses are surrounded by comment elements to\n-  indicate that they are automatically generated, something like this:\n-\n-    ::\n-\n-        <comment text=\"--gen+\">\n-        ...\n-        <attribute_definition_clause>\n-        ...\n-        <comment text=\"--gen-\">\n-        ...\n-\n-\n .. only:: PRO or GPL\n \n   .. _The_Coding_Standard_Verifier_gnatcheck:"}, {"sha": "ab4719298b1c2f9578be36147483d97567315687", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 184, "deletions": 1347, "changes": 1531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae265cdd5b2e20bdf14a4ef8c2b1458ad09b9d03/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae265cdd5b2e20bdf14a4ef8c2b1458ad09b9d03/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=ae265cdd5b2e20bdf14a4ef8c2b1458ad09b9d03"}]}