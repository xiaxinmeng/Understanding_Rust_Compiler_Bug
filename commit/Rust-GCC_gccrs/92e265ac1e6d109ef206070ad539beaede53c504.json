{"sha": "92e265ac1e6d109ef206070ad539beaede53c504", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJlMjY1YWMxZTZkMTA5ZWYyMDYwNzBhZDUzOWJlYWVkZTUzYzUwNA==", "commit": {"author": {"name": "Andrey Belevantsev", "email": "abel@ispras.ru", "date": "2014-05-14T12:09:02Z"}, "committer": {"name": "Andrey Belevantsev", "email": "abel@gcc.gnu.org", "date": "2014-05-14T12:09:02Z"}, "message": "re PR rtl-optimization/60866 (ICE: in get_seqno_for_a_jump, at sel-sched-ir.c:4068 with -fselective-scheduling -fno-if-conversion)\n\n        PR rtl-optimization/60866\n        * sel-sched-ir (sel_init_new_insn): New parameter old_seqno.\n        Default it to -1.  Pass it down to init_simplejump_data.\n        (init_simplejump_data): New parameter old_seqno.  Pass it down\n        to get_seqno_for_a_jump.\n        (get_seqno_for_a_jump): New parameter old_seqno.  Use it for\n        initializing new jump seqno as a last resort.  Add comment.\n        (sel_redirect_edge_and_branch): Save old seqno of the conditional\n        jump and pass it down to sel_init_new_insn.\n        (sel_redirect_edge_and_branch_force): Likewise.\n\n\t* gcc.dg/pr60866.c: New test.\n\nFrom-SVN: r210420", "tree": {"sha": "63e01efdd51a5edb84329acfc56e579daf9ac19b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63e01efdd51a5edb84329acfc56e579daf9ac19b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92e265ac1e6d109ef206070ad539beaede53c504", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92e265ac1e6d109ef206070ad539beaede53c504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92e265ac1e6d109ef206070ad539beaede53c504", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92e265ac1e6d109ef206070ad539beaede53c504/comments", "author": {"login": "abonzo", "id": 20396542, "node_id": "MDQ6VXNlcjIwMzk2NTQy", "avatar_url": "https://avatars.githubusercontent.com/u/20396542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abonzo", "html_url": "https://github.com/abonzo", "followers_url": "https://api.github.com/users/abonzo/followers", "following_url": "https://api.github.com/users/abonzo/following{/other_user}", "gists_url": "https://api.github.com/users/abonzo/gists{/gist_id}", "starred_url": "https://api.github.com/users/abonzo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abonzo/subscriptions", "organizations_url": "https://api.github.com/users/abonzo/orgs", "repos_url": "https://api.github.com/users/abonzo/repos", "events_url": "https://api.github.com/users/abonzo/events{/privacy}", "received_events_url": "https://api.github.com/users/abonzo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa96aa45159cef2b78a3ae0e35900a17205a9225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa96aa45159cef2b78a3ae0e35900a17205a9225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa96aa45159cef2b78a3ae0e35900a17205a9225"}], "stats": {"total": 92, "additions": 76, "deletions": 16}, "files": [{"sha": "86f92f0fcf27ff5d6223a8e8a3f7f2ab08650d22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e265ac1e6d109ef206070ad539beaede53c504/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e265ac1e6d109ef206070ad539beaede53c504/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92e265ac1e6d109ef206070ad539beaede53c504", "patch": "@@ -1,3 +1,16 @@\n+2014-05-14  Andrey Belevantsev  <abel@ispras.ru>\n+\n+\tPR rtl-optimization/60866\n+\t* sel-sched-ir (sel_init_new_insn): New parameter old_seqno.\n+\tDefault it to -1.  Pass it down to init_simplejump_data.\n+\t(init_simplejump_data): New parameter old_seqno.  Pass it down\n+\tto get_seqno_for_a_jump.\n+\t(get_seqno_for_a_jump): New parameter old_seqno.  Use it for\n+\tinitializing new jump seqno as a last resort.  Add comment.\n+\t(sel_redirect_edge_and_branch): Save old seqno of the conditional\n+\tjump and pass it down to sel_init_new_insn.\n+\t(sel_redirect_edge_and_branch_force): Likewise.\n+\n 2014-05-14  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/avr.h (REG_CLASS_CONTENTS): Use unsigned suffix for"}, {"sha": "3cba326e89741f28a7ee2643bd9f40022a3f2e09", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e265ac1e6d109ef206070ad539beaede53c504/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e265ac1e6d109ef206070ad539beaede53c504/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=92e265ac1e6d109ef206070ad539beaede53c504", "patch": "@@ -162,7 +162,7 @@ static void create_initial_data_sets (basic_block);\n static void free_av_set (basic_block);\n static void invalidate_av_set (basic_block);\n static void extend_insn_data (void);\n-static void sel_init_new_insn (insn_t, int);\n+static void sel_init_new_insn (insn_t, int, int = -1);\n static void finish_insns (void);\n \f\n /* Various list functions.  */\n@@ -4007,9 +4007,10 @@ get_seqno_by_succs (rtx insn)\n   return seqno;\n }\n \n-/* Compute seqno for INSN by its preds or succs.  */\n+/* Compute seqno for INSN by its preds or succs.  Use OLD_SEQNO to compute\n+   seqno in corner cases.  */\n static int\n-get_seqno_for_a_jump (insn_t insn)\n+get_seqno_for_a_jump (insn_t insn, int old_seqno)\n {\n   int seqno;\n \n@@ -4065,8 +4066,16 @@ get_seqno_for_a_jump (insn_t insn)\n   if (seqno < 0)\n     seqno = get_seqno_by_succs (insn);\n \n-  gcc_assert (seqno >= 0);\n+  if (seqno < 0)\n+    {\n+      /* The only case where this could be here legally is that the only\n+\t unscheduled insn was a conditional jump that got removed and turned\n+\t into this unconditional one.  Initialize from the old seqno\n+\t of that jump passed down to here.  */\n+      seqno = old_seqno;\n+    }\n \n+  gcc_assert (seqno >= 0);\n   return seqno;\n }\n \n@@ -4246,22 +4255,24 @@ init_insn_data (insn_t insn)\n }\n \n /* This is used to initialize spurious jumps generated by\n-   sel_redirect_edge ().  */\n+   sel_redirect_edge ().  OLD_SEQNO is used for initializing seqnos\n+   in corner cases within get_seqno_for_a_jump.  */\n static void\n-init_simplejump_data (insn_t insn)\n+init_simplejump_data (insn_t insn, int old_seqno)\n {\n   init_expr (INSN_EXPR (insn), vinsn_create (insn, false), 0,\n \t     REG_BR_PROB_BASE, 0, 0, 0, 0, 0, 0,\n \t     vNULL, true, false, false,\n \t     false, true);\n-  INSN_SEQNO (insn) = get_seqno_for_a_jump (insn);\n+  INSN_SEQNO (insn) = get_seqno_for_a_jump (insn, old_seqno);\n   init_first_time_insn_data (insn);\n }\n \n /* Perform deferred initialization of insns.  This is used to process\n-   a new jump that may be created by redirect_edge.  */\n-void\n-sel_init_new_insn (insn_t insn, int flags)\n+   a new jump that may be created by redirect_edge.  OLD_SEQNO is used\n+   for initializing simplejumps in init_simplejump_data.  */\n+static void\n+sel_init_new_insn (insn_t insn, int flags, int old_seqno)\n {\n   /* We create data structures for bb when the first insn is emitted in it.  */\n   if (INSN_P (insn)\n@@ -4288,7 +4299,7 @@ sel_init_new_insn (insn_t insn, int flags)\n   if (flags & INSN_INIT_TODO_SIMPLEJUMP)\n     {\n       extend_insn_data ();\n-      init_simplejump_data (insn);\n+      init_simplejump_data (insn, old_seqno);\n     }\n \n   gcc_assert (CONTAINING_RGN (BLOCK_NUM (insn))\n@@ -5575,14 +5586,14 @@ sel_merge_blocks (basic_block a, basic_block b)\n }\n \n /* A wrapper for redirect_edge_and_branch_force, which also initializes\n-   data structures for possibly created bb and insns.  Returns the newly\n-   added bb or NULL, when a bb was not needed.  */\n+   data structures for possibly created bb and insns.  */\n void\n sel_redirect_edge_and_branch_force (edge e, basic_block to)\n {\n   basic_block jump_bb, src, orig_dest = e->dest;\n   int prev_max_uid;\n   rtx jump;\n+  int old_seqno = -1;\n \n   /* This function is now used only for bookkeeping code creation, where\n      we'll never get the single pred of orig_dest block and thus will not\n@@ -5591,8 +5602,13 @@ sel_redirect_edge_and_branch_force (edge e, basic_block to)\n               && !single_pred_p (orig_dest));\n   src = e->src;\n   prev_max_uid = get_max_uid ();\n-  jump_bb = redirect_edge_and_branch_force (e, to);\n+  /* Compute and pass old_seqno down to sel_init_new_insn only for the case\n+     when the conditional jump being redirected may become unconditional.  */\n+  if (any_condjump_p (BB_END (src))\n+      && INSN_SEQNO (BB_END (src)) >= 0)\n+    old_seqno = INSN_SEQNO (BB_END (src));\n \n+  jump_bb = redirect_edge_and_branch_force (e, to);\n   if (jump_bb != NULL)\n     sel_add_bb (jump_bb);\n \n@@ -5604,7 +5620,8 @@ sel_redirect_edge_and_branch_force (edge e, basic_block to)\n \n   jump = find_new_jump (src, jump_bb, prev_max_uid);\n   if (jump)\n-    sel_init_new_insn (jump, INSN_INIT_TODO_LUID | INSN_INIT_TODO_SIMPLEJUMP);\n+    sel_init_new_insn (jump, INSN_INIT_TODO_LUID | INSN_INIT_TODO_SIMPLEJUMP,\n+\t\t       old_seqno);\n   set_immediate_dominator (CDI_DOMINATORS, to,\n \t\t\t   recompute_dominator (CDI_DOMINATORS, to));\n   set_immediate_dominator (CDI_DOMINATORS, orig_dest,\n@@ -5623,6 +5640,7 @@ sel_redirect_edge_and_branch (edge e, basic_block to)\n   edge redirected;\n   bool recompute_toporder_p = false;\n   bool maybe_unreachable = single_pred_p (orig_dest);\n+  int old_seqno = -1;\n \n   latch_edge_p = (pipelining_p\n                   && current_loop_nest\n@@ -5631,6 +5649,12 @@ sel_redirect_edge_and_branch (edge e, basic_block to)\n   src = e->src;\n   prev_max_uid = get_max_uid ();\n \n+  /* Compute and pass old_seqno down to sel_init_new_insn only for the case\n+     when the conditional jump being redirected may become unconditional.  */\n+  if (any_condjump_p (BB_END (src))\n+      && INSN_SEQNO (BB_END (src)) >= 0)\n+    old_seqno = INSN_SEQNO (BB_END (src));\n+\n   redirected = redirect_edge_and_branch (e, to);\n \n   gcc_assert (redirected && !last_added_blocks.exists ());\n@@ -5651,7 +5675,7 @@ sel_redirect_edge_and_branch (edge e, basic_block to)\n \n   jump = find_new_jump (src, NULL, prev_max_uid);\n   if (jump)\n-    sel_init_new_insn (jump, INSN_INIT_TODO_LUID | INSN_INIT_TODO_SIMPLEJUMP);\n+    sel_init_new_insn (jump, INSN_INIT_TODO_LUID | INSN_INIT_TODO_SIMPLEJUMP, old_seqno);\n \n   /* Only update dominator info when we don't have unreachable blocks.\n      Otherwise we'll update in maybe_tidy_empty_bb.  */"}, {"sha": "faa38583ef779634a35c2c0464d11fcb21ea1415", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e265ac1e6d109ef206070ad539beaede53c504/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e265ac1e6d109ef206070ad539beaede53c504/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=92e265ac1e6d109ef206070ad539beaede53c504", "patch": "@@ -1,3 +1,8 @@\n+2014-05-14  Andrey Belevantsev  <abel@ispras.ru>\n+\n+\tPR rtl-optimization/60866\n+\t* gcc.dg/pr60866.c: New test. \n+\n 2014-05-14  Andrey Belevantsev  <abel@ispras.ru>\n \n \tPR rtl-optimization/60901"}, {"sha": "020878d41de02aedd6b43f30af51a8bec1595a0d", "filename": "gcc/testsuite/gcc.dg/pr60866.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e265ac1e6d109ef206070ad539beaede53c504/gcc%2Ftestsuite%2Fgcc.dg%2Fpr60866.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e265ac1e6d109ef206070ad539beaede53c504/gcc%2Ftestsuite%2Fgcc.dg%2Fpr60866.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr60866.c?ref=92e265ac1e6d109ef206070ad539beaede53c504", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target powerpc*-*-* ia64-*-* x86_64-*-* } } */\n+/* { dg-options \"-O -fselective-scheduling -fno-if-conversion -fschedule-insns\"  } */\n+\n+int n;\n+\n+void\n+foo (int w, int **dnroot, int **dn)\n+{\n+  int *child;\n+  int *xchild = xchild;\n+  for (; w < n; w++)\n+    if (!dnroot)\n+      {\n+\tdnroot = dn;\n+\tfor (child = *dn; child; child = xchild)\n+\t  ;\n+      }\n+}"}]}