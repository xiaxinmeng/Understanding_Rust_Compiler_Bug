{"sha": "a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE4ODI4NGM2MWNlZmY1ODcxZGY4OGIyZjRhZDU5NzJiZmQ2ZmIzYQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2011-12-29T17:58:51Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2011-12-29T17:58:51Z"}, "message": "re PR libstdc++/51608 ([C++11] Unordered containers end(size_type) isn't constant time)\n\n2011-12-29  Fran\u00e7ois Dumont <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/51608\n\t* include/bits/hashtable_policy.h (_Equal_helper<>): New, change the\n\tway the _Equal functor is used depending on whether hash code is\n\tcached or not.\n\t(_Ebo_helper<>): New helper type to introduce EBO when possible.\n\t(_Hash_code_base): Use _Ebo_helper to limit memory footprint. Move\n\t_Equal functor management...\n\t(_Hashtable_base): ...here, new, use _Equal_helper.\n\t(_Local_iterator_base<>, _Locale_iterator<>, _Locale_const_iterator<>):\n\tNew, use _Hash_code_base, implementation of...\n\t* include/bits/hashtable.h (_Hashtable<>::local_iterator,\n\t_Hashtable<>::const_local_iterator): ...those. Add static assertions\n\tchecking that some functors are empty depending on whether hash code\n\tis cache or not.\n\t(_Hashtable<>::_M_bucket_index): New overloads using current bucket\n\tcount, use through out the _Hastable<> implementation.\n\t* include/bits/unordered_set.h (__unordered_set<>,\n\t__unordered_multiset<>): Cache hash code iff hash functor is not\n\tempty and not final.\n\t* include/bits/unordered_map.h (__unordered_map<>,\n\t__unordered_multimap<>): Likewise.\n\t* include/debug/unordered_map\n\t(unordered_map<>::_S_to_local, unordered_multimap<>::_S_to_local):\n\tAdapt to match new local iterator implementation.\n\t* include/debug/unordered_set (unordered_set<>::_S_to_local,\n\tunordered_multiset<>::_S_to_local): Likewise.\n\t* include/profile/unordered_map (unordered_map<>::_M_profile_destruct,\n\tunordered_multimap<>::_M_profile_destruct): Enhance thanks to usage of\n\tlocal iterators.\n\t* include/profile/unordered_set (unordered_set<>::_M_profile_destruct,\n\tunordered_multiset<>::_M_profile_destruct): Likewise.\n\t* testsuite_files/23_containers/unordered_set/instantiation_neg.cc:\n\tFix error line.\n\t* testsuite_files/23_containers/unordered_set/final_hash.cc: New.\n\t* testsuite_files/23_containers/unordered_multiset/final_hash.cc: New.\n\t* testsuite_files/23_containers/unordered_map/final_hash.cc: New.\n\t* testsuite_files/23_containers/unordered_multimap/final_hash.cc: New.\n\nFrom-SVN: r182727", "tree": {"sha": "903f20038569d2020a81aba0417a85a922d4b121", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/903f20038569d2020a81aba0417a85a922d4b121"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/comments", "author": null, "committer": null, "parents": [{"sha": "497081e8cf71fed0a409afcb21590856a1f0536d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497081e8cf71fed0a409afcb21590856a1f0536d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/497081e8cf71fed0a409afcb21590856a1f0536d"}], "stats": {"total": 979, "additions": 779, "deletions": 200}, "files": [{"sha": "e697e4b5bb0904ff417a0c8092f3b3d814599006", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -1,3 +1,43 @@\n+2011-12-29  Fran\u00e7ois Dumont <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/51608\n+\t* include/bits/hashtable_policy.h (_Equal_helper<>): New, change the\n+\tway the _Equal functor is used depending on whether hash code is\n+\tcached or not.\n+\t(_Ebo_helper<>): New helper type to introduce EBO when possible.\n+\t(_Hash_code_base): Use _Ebo_helper to limit memory footprint. Move\n+\t_Equal functor management...\n+\t(_Hashtable_base): ...here, new, use _Equal_helper.\n+\t(_Local_iterator_base<>, _Locale_iterator<>, _Locale_const_iterator<>):\n+\tNew, use _Hash_code_base, implementation of...\n+\t* include/bits/hashtable.h (_Hashtable<>::local_iterator,\n+\t_Hashtable<>::const_local_iterator): ...those. Add static assertions\n+\tchecking that some functors are empty depending on whether hash code\n+\tis cache or not.\n+\t(_Hashtable<>::_M_bucket_index): New overloads using current bucket\n+\tcount, use through out the _Hastable<> implementation.\n+\t* include/bits/unordered_set.h (__unordered_set<>,\n+\t__unordered_multiset<>): Cache hash code iff hash functor is not\n+\tempty and not final.\n+\t* include/bits/unordered_map.h (__unordered_map<>,\n+\t__unordered_multimap<>): Likewise.\n+\t* include/debug/unordered_map\n+\t(unordered_map<>::_S_to_local, unordered_multimap<>::_S_to_local):\n+\tAdapt to match new local iterator implementation.\n+\t* include/debug/unordered_set (unordered_set<>::_S_to_local,\n+\tunordered_multiset<>::_S_to_local): Likewise.\n+\t* include/profile/unordered_map (unordered_map<>::_M_profile_destruct,\n+\tunordered_multimap<>::_M_profile_destruct): Enhance thanks to usage of\n+\tlocal iterators.\n+\t* include/profile/unordered_set (unordered_set<>::_M_profile_destruct,\n+\tunordered_multiset<>::_M_profile_destruct): Likewise.\n+\t* testsuite_files/23_containers/unordered_set/instantiation_neg.cc:\n+\tFix error line.\n+\t* testsuite_files/23_containers/unordered_set/final_hash.cc: New.\n+\t* testsuite_files/23_containers/unordered_multiset/final_hash.cc: New.\n+\t* testsuite_files/23_containers/unordered_map/final_hash.cc: New.\n+\t* testsuite_files/23_containers/unordered_multimap/final_hash.cc: New.\n+\n 2011-12-29  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/51701"}, {"sha": "aeb330cef2fbab3f918f6443962a3969268e7cf8", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 111, "deletions": 90, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -155,7 +155,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t       __cache_hash_code,\n \t\t\t\t\t       __constant_iterators,\n \t\t\t\t\t       __unique_keys> >,\n-      public __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+      public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n \t\t\t\t       _H1, _H2, _Hash, __cache_hash_code>,\n       public __detail::_Map_base<_Key, _Value, _ExtractKey, __unique_keys,\n \t\t\t\t _Hashtable<_Key, _Value, _Allocator,\n@@ -174,9 +174,37 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t\t __constant_iterators,\n \t\t\t\t\t\t __unique_keys> >\n     {\n-      static_assert(__or_<integral_constant<bool, __cache_hash_code>,\n-\t\t\t  __detail::__is_noexcept_hash<_Key, _H1>>::value,\n+      template<typename _Cond>\n+\tusing __if_hash_code_cached\n+\t  = __or_<__not_<integral_constant<bool, __cache_hash_code>>, _Cond>;\n+\n+      template<typename _Cond>\n+\tusing __if_hash_code_not_cached\n+\t  = __or_<integral_constant<bool, __cache_hash_code>, _Cond>;\n+\n+      static_assert(__if_hash_code_not_cached<__detail::__is_noexcept_hash<_Key,\n+\t\t\t\t\t\t\t\t_H1>>::value,\n       \t    \"Cache the hash code or qualify your hash functor with noexcept\");\n+\n+      // Following two static assertions are necessary to guarantee that\n+      // swapping two hashtable instances won't invalidate associated local\n+      // iterators.\n+\n+      // When hash codes are cached local iterator only uses H2 which must then\n+      // be empty.\n+      static_assert(__if_hash_code_cached<is_empty<_H2>>::value,\n+\t    \"Functor used to map hash code to bucket index must be empty\");\n+\n+      typedef __detail::_Hash_code_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t_H1, _H2, _Hash,\n+\t\t\t\t       \t__cache_hash_code> _HCBase;\n+\n+      // When hash codes are not cached local iterator is going to use _HCBase\n+      // above to compute node bucket index so it has to be empty.\n+      static_assert(__if_hash_code_not_cached<is_empty<_HCBase>>::value,\n+\t    \"Cache the hash code or make functors involved in hash code\"\n+\t    \" and bucket index computation empty\");\n+\n     public:\n       typedef _Allocator                                  allocator_type;\n       typedef _Value                                      value_type;\n@@ -191,16 +219,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       typedef std::size_t                                 size_type;\n       typedef std::ptrdiff_t                              difference_type;\n+      typedef __detail::_Local_iterator<key_type, value_type, _ExtractKey,\n+\t\t\t\t\t_H1, _H2, _Hash,\n+\t\t\t\t\t__constant_iterators,\n+\t\t\t\t\t__cache_hash_code>\n+\t\t\t\t\t\t\t  local_iterator;\n+      typedef __detail::_Local_const_iterator<key_type, value_type, _ExtractKey,\n+\t\t\t\t\t      _H1, _H2, _Hash,\n+\t\t\t\t\t      __constant_iterators,\n+\t\t\t\t\t      __cache_hash_code>\n+\t\t\t\t\t\t\t  const_local_iterator;\n       typedef __detail::_Node_iterator<value_type, __constant_iterators,\n \t\t\t\t       __cache_hash_code>\n-\t\t\t\t\t\t\t  local_iterator;\n+\t\t\t\t\t\t\t  iterator;\n       typedef __detail::_Node_const_iterator<value_type,\n \t\t\t\t\t     __constant_iterators,\n \t\t\t\t\t     __cache_hash_code>\n-\t\t\t\t\t\t\t  const_local_iterator;\n-\n-      typedef local_iterator iterator;\n-      typedef const_local_iterator const_iterator;\n+\t\t\t\t\t\t\t  const_iterator;\n \n       template<typename _Key2, typename _Value2, typename _Ex2, bool __unique2,\n \t       typename _Hashtable2>\n@@ -212,7 +247,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef typename _Allocator::template rebind<_Node>::other\n \t\t\t\t\t\t\t_Node_allocator_type;\n       typedef _Node* _Bucket;\n-      //typedef __detail::_Bucket<_Value, __cache_hash_code> _Bucket;\n       typedef typename _Allocator::template rebind<_Bucket>::other\n \t\t\t\t\t\t\t_Bucket_allocator_type;\n \n@@ -253,14 +287,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Node*\n       _M_bucket_end(size_type __bkt) const;\n \n-      // Gets the bucket node after the last if any\n-      _Node*\n-      _M_bucket_past_the_end(size_type __bkt) const\n-        {\n-\t  _Node* __end = _M_bucket_end(__bkt);\n-\t  return __end ? __end->_M_next : nullptr;\n-\t}\n-\n     public:\n       // Constructor, destructor, assignment, swap\n       _Hashtable(size_type __bucket_hint,\n@@ -364,35 +390,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       size_type\n       bucket(const key_type& __k) const\n-      {\n-\treturn this->_M_bucket_index(__k, this->_M_hash_code(__k),\n-\t\t\t\t     bucket_count());\n-      }\n+      { return _M_bucket_index(__k, this->_M_hash_code(__k)); }\n \n       local_iterator\n       begin(size_type __n)\n-      { return local_iterator(_M_bucket_begin(__n)); }\n+      { return local_iterator(_M_bucket_begin(__n), __n,\n+\t\t\t      _M_bucket_count); }\n \n       local_iterator\n       end(size_type __n)\n-      { return local_iterator(_M_bucket_past_the_end(__n)); }\n+      { return local_iterator(nullptr, __n, _M_bucket_count); }\n \n       const_local_iterator\n       begin(size_type __n) const\n-      { return const_local_iterator(_M_bucket_begin(__n)); }\n+      { return const_local_iterator(_M_bucket_begin(__n), __n,\n+\t\t\t\t    _M_bucket_count); }\n \n       const_local_iterator\n       end(size_type __n) const\n-      { return const_local_iterator(_M_bucket_past_the_end(__n)); }\n+      { return const_local_iterator(nullptr, __n, _M_bucket_count); }\n \n       // DR 691.\n       const_local_iterator\n       cbegin(size_type __n) const\n-      { return const_local_iterator(_M_bucket_begin(__n)); }\n+      { return const_local_iterator(_M_bucket_begin(__n), __n,\n+\t\t\t\t    _M_bucket_count); }\n \n       const_local_iterator\n       cend(size_type __n) const\n-      { return const_local_iterator(_M_bucket_past_the_end(__n)); }\n+      { return const_local_iterator(nullptr, __n, _M_bucket_count); }\n \n       float\n       load_factor() const noexcept\n@@ -428,6 +454,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       equal_range(const key_type& __k) const;\n \n     private:\n+      size_type\n+      _M_bucket_index(_Node* __n) const\n+      { return _HCBase::_M_bucket_index(__n, _M_bucket_count); }\n+\n+      size_type\n+      _M_bucket_index(const key_type& __k,\n+\t\t      typename _Hashtable::_Hash_code_type __c) const\n+      { return _HCBase::_M_bucket_index(__k, __c, _M_bucket_count); }\n+\n       // Find and insert helper functions and types\n       _Node*\n       _M_find_node(size_type, const key_type&,\n@@ -679,9 +714,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Node* __n = _M_bucket_begin(__bkt);\n       if (__n)\n \tfor (;; __n = __n->_M_next)\n-\t  if (!__n->_M_next \n-\t      || this->_M_bucket_index(__n->_M_next, _M_bucket_count)\n-\t\t != __bkt)\n+\t  if (!__n->_M_next || _M_bucket_index(__n->_M_next) != __bkt)\n \t    break;\n       return __n;\n     }\n@@ -697,9 +730,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       const _Equal& __eq, const _ExtractKey& __exk,\n \t       const allocator_type& __a)\n     : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n-      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t_H1, _H2, _Hash, __chc>(__exk, __eq,\n-\t\t\t\t\t\t\t__h1, __h2, __h),\n+      __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t_H1, _H2, _Hash, __chc>(__exk, __h1, __h2, __h,\n+\t\t\t\t\t\t\t__eq),\n       __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n       _M_node_allocator(__a),\n       _M_bucket_count(0),\n@@ -727,9 +760,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t const _Equal& __eq, const _ExtractKey& __exk,\n \t\t const allocator_type& __a)\n       : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n-\t__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t  _H1, _H2, _Hash, __chc>(__exk, __eq,\n-\t\t\t\t\t\t\t  __h1, __h2, __h),\n+\t__detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t  _H1, _H2, _Hash, __chc>(__exk, __h1, __h2, __h,\n+\t\t\t\t\t\t\t  __eq),\n \t__detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n \t_M_node_allocator(__a),\n \t_M_bucket_count(0),\n@@ -768,7 +801,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n     _Hashtable(const _Hashtable& __ht)\n     : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),\n-      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+      __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n \t\t\t\t_H1, _H2, _Hash, __chc>(__ht),\n       __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n       _M_node_allocator(__ht._M_node_allocator),\n@@ -833,7 +866,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n     _Hashtable(_Hashtable&& __ht)\n     : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),\n-      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+      __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n \t\t\t\t_H1, _H2, _Hash, __chc>(__ht),\n       __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n       _M_node_allocator(std::move(__ht._M_node_allocator)),\n@@ -874,8 +907,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // The only base class with member variables is hash_code_base.  We\n       // define _Hash_code_base::_M_swap because different specializations\n       // have different members.\n-      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n-\t_H1, _H2, _Hash, __chc>::_M_swap(__x);\n+      this->_M_swap(__x);\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 431. Swapping containers with unequal allocators.\n@@ -916,7 +948,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     find(const key_type& __k)\n     {\n       typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      std::size_t __n = _M_bucket_index(__k, __code);\n       _Node* __p = _M_find_node(__n, __k, __code);\n       return __p ? iterator(__p) : this->end();\n     }\n@@ -933,7 +965,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     find(const key_type& __k) const\n     {\n       typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      std::size_t __n = _M_bucket_index(__k, __code);\n       _Node* __p = _M_find_node(__n, __k, __code);\n       return __p ? const_iterator(__p) : this->end();\n     }\n@@ -950,24 +982,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     count(const key_type& __k) const\n     {\n       typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      std::size_t __n = _M_bucket_index(__k, __code);\n       _Node* __p = _M_bucket_begin(__n);\n       if (!__p)\n \treturn 0;\n \n       std::size_t __result = 0;\n       for (;; __p = __p->_M_next)\n \t{\n-\t  if (this->_M_compare(__k, __code, __p))\n+\t  if (this->_M_equals(__k, __code, __p))\n \t    ++__result;\n \t  else if (__result)\n \t    // All equivalent values are next to each other, if we found a not\n \t    // equivalent value after an equivalent one it means that we won't\n \t    // find anymore an equivalent value.\n \t    break;\n-\t  if (!__p->_M_next\n-\t      || this->_M_bucket_index(__p->_M_next, _M_bucket_count)\n-\t\t != __n)\n+\t  if (!__p->_M_next || _M_bucket_index(__p->_M_next) != __n)\n \t    break;\n \t}\n       return __result;\n@@ -990,15 +1020,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     equal_range(const key_type& __k)\n     {\n       typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      std::size_t __n = _M_bucket_index(__k, __code);\n       _Node* __p = _M_find_node(__n, __k, __code);\n \n       if (__p)\n \t{\n \t  _Node* __p1 = __p->_M_next;\n-\t  while (__p1\n-\t\t && this->_M_bucket_index(__p1, _M_bucket_count) == __n\n-\t\t && this->_M_compare(__k, __code, __p1))\n+\t  while (__p1 && _M_bucket_index(__p1) == __n\n+\t\t && this->_M_equals(__k, __code, __p1))\n \t    __p1 = __p1->_M_next;\n \n \t  return std::make_pair(iterator(__p), iterator(__p1));\n@@ -1024,15 +1053,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     equal_range(const key_type& __k) const\n     {\n       typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      std::size_t __n = _M_bucket_index(__k, __code);\n       _Node* __p = _M_find_node(__n, __k, __code);\n \n       if (__p)\n \t{\n \t  _Node* __p1 = __p->_M_next;\n-\t  while (__p1\n-\t\t && this->_M_bucket_index(__p1, _M_bucket_count) == __n\n-\t\t && this->_M_compare(__k, __code, __p1))\n+\t  while (__p1 && _M_bucket_index(__p1) == __n\n+\t\t && this->_M_equals(__k, __code, __p1))\n \t    __p1 = __p1->_M_next;\n \n \t  return std::make_pair(const_iterator(__p), const_iterator(__p1));\n@@ -1060,10 +1088,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn nullptr;\n       for (;; __p = __p->_M_next)\n \t{\n-\t  if (this->_M_compare(__k, __code, __p))\n+\t  if (this->_M_equals(__k, __code, __p))\n \t    return __p;\n-\t  if (!(__p->_M_next)\n-\t      || this->_M_bucket_index(__p->_M_next, _M_bucket_count) != __n)\n+\t  if (!(__p->_M_next) || _M_bucket_index(__p->_M_next) != __n)\n \t    break;\n \t}\n       return nullptr;\n@@ -1119,8 +1146,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       if (__prev_n->_M_next)\n \t{\n-\t  size_type __next_bkt =\n-\t    this->_M_bucket_index(__prev_n->_M_next, _M_bucket_count);\n+\t  size_type __next_bkt = _M_bucket_index(__prev_n->_M_next);\n \t  if (__next_bkt != __bkt)\n \t    _M_buckets[__next_bkt] = __new_n;\n \t}\n@@ -1196,11 +1222,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_Node* __new_node = _M_allocate_node(std::forward<_Args>(__args)...);\n \t__try\n \t  {\n-\t    const key_type& __k = this->_M_extract(__new_node->_M_v);\n+\t    const key_type& __k = this->_M_extract()(__new_node->_M_v);\n \t    typename _Hashtable::_Hash_code_type __code\n \t      = this->_M_hash_code(__k);\n-\t    size_type __bkt\n-\t      = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\t    size_type __bkt = _M_bucket_index(__k, __code);\n \n \t    if (_Node* __p = _M_find_node(__bkt, __k, __code))\n \t      {\n@@ -1220,7 +1245,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    if (__do_rehash.first)\n \t      {\n \t\t_M_rehash(__do_rehash.second, __saved_state);\n-\t\t__bkt = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\t\t__bkt = _M_bucket_index(__k, __code);\n \t      }\n \n \t    if (_M_buckets[__bkt])\n@@ -1258,20 +1283,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_Node* __new_node = _M_allocate_node(std::forward<_Args>(__args)...);\n \t__try\n \t  {\n-\t    const key_type& __k = this->_M_extract(__new_node->_M_v);\n+\t    const key_type& __k = this->_M_extract()(__new_node->_M_v);\n \t    typename _Hashtable::_Hash_code_type __code\n \t      = this->_M_hash_code(__k);\n \t    this->_M_store_code(__new_node, __code);\n-\t    size_type __bkt\n-\t      = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\t    size_type __bkt = _M_bucket_index(__k, __code);\n \n \t    // Second find the node, avoid rehash if compare throws.\n \t    _Node* __prev = _M_find_node(__bkt, __k, __code);\n \t    \n \t    if (__do_rehash.first)\n \t      {\n \t\t_M_rehash(__do_rehash.second, __saved_state);\n-\t\t__bkt = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\t\t__bkt = _M_bucket_index(__k, __code);\n \t\t// __prev is still valid because rehash do not invalidate nodes\n \t      }\n \n@@ -1322,8 +1346,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \tif (__do_rehash.first)\n \t  {\n-\t    const key_type& __k = this->_M_extract(__v);\n-\t    __n = this->_M_bucket_index(__k, __code, __do_rehash.second);\n+\t    const key_type& __k = this->_M_extract()(__v);\n+\t    __n = _HCBase::_M_bucket_index(__k, __code, __do_rehash.second);\n \t  }\n \n \t_Node* __new_node = nullptr;\n@@ -1367,9 +1391,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n       _M_insert(_Arg&& __v, std::true_type)\n       {\n-\tconst key_type& __k = this->_M_extract(__v);\n+\tconst key_type& __k = this->_M_extract()(__v);\n \ttypename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-\tsize_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\tsize_type __n = _M_bucket_index(__k, __code);\n \n \tif (_Node* __p = _M_find_node(__n, __k, __code))\n \t  return std::make_pair(iterator(__p), false);\n@@ -1395,9 +1419,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n \t\t\t\t\t    _M_element_count, 1);\n \n-\tconst key_type& __k = this->_M_extract(__v);\n+\tconst key_type& __k = this->_M_extract()(__v);\n \ttypename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-\tsize_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\tsize_type __n = _M_bucket_index(__k, __code);\n \n \t// First find the node, avoid leaking new_node if compare throws.\n \t_Node* __prev = _M_find_node(__n, __k, __code);\n@@ -1410,7 +1434,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    if (__do_rehash.first)\n \t      {\n \t\t_M_rehash(__do_rehash.second, __saved_state);\n-\t\t__n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\t\t__n = _M_bucket_index(__k, __code);\n \t\t// __prev is still valid because rehash do not invalidate nodes\n \t      }\n \n@@ -1477,20 +1501,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     erase(const_iterator __it)\n     {\n       _Node* __n = __it._M_cur;\n-      std::size_t __bkt = this->_M_bucket_index(__n, _M_bucket_count);\n+      std::size_t __bkt = _M_bucket_index(__n);\n \n       // Look for previous node to unlink it from the erased one, this is why\n       // we need buckets to contain the before begin node of the bucket to make\n       // this research fast.\n       _Node* __prev_n = _M_get_previous_node(__bkt, __n);\n       if (__n == _M_bucket_begin(__bkt))\n \t_M_remove_bucket_begin(__bkt, __n->_M_next,\n-\t   __n->_M_next ? this->_M_bucket_index(__n->_M_next, _M_bucket_count)\n-\t\t\t: 0);\n+\t   __n->_M_next ? _M_bucket_index(__n->_M_next) : 0);\n       else if (__n->_M_next)\n \t{\n-\t  size_type __next_bkt =\n-\t    this->_M_bucket_index(__n->_M_next, _M_bucket_count);\n+\t  size_type __next_bkt = _M_bucket_index(__n->_M_next);\n \t  if (__next_bkt != __bkt)\n \t    _M_buckets[__next_bkt] = __prev_n;\n \t}\n@@ -1516,7 +1538,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     erase(const key_type& __k)\n     {\n       typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __bkt = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      std::size_t __bkt = _M_bucket_index(__k, __code);\n       // Look for the first matching node with its previous node at the same\n       // time\n       _Node* __n = _M_buckets[__bkt];\n@@ -1531,10 +1553,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool __is_bucket_begin = true;\n       for (;; __prev_n = __n, __n = __n->_M_next)\n \t{\n-\t  if (this->_M_compare(__k, __code, __n))\n+\t  if (this->_M_equals(__k, __code, __n))\n \t    break;\n-\t  if (!(__n->_M_next)\n-\t      || this->_M_bucket_index(__n->_M_next, _M_bucket_count) != __bkt)\n+\t  if (!(__n->_M_next) || _M_bucket_index(__n->_M_next) != __bkt)\n \t    return 0;\n \t  __is_bucket_begin = false;\n \t}\n@@ -1551,7 +1572,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t  // 526. Is it undefined if a function in the standard changes\n \t  // in parameters?\n-\t  if (std::__addressof(this->_M_extract(__p->_M_v))\n+\t  if (std::__addressof(this->_M_extract()(__p->_M_v))\n \t      != std::__addressof(__k))\n \t    _M_deallocate_node(__p);\n \t  else\n@@ -1560,9 +1581,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  ++__result;\n \t  if (!__next_n)\n \t    break;\n-\t  __next_bkt = this->_M_bucket_index(__next_n, _M_bucket_count);\n+\t  __next_bkt = _M_bucket_index(__next_n);\n \t}\n-      while (__next_bkt == __bkt && this->_M_compare(__k, __code, __next_n));\n+      while (__next_bkt == __bkt && this->_M_equals(__k, __code, __next_n));\n \n       if (__saved_n)\n \t_M_deallocate_node(__saved_n);\n@@ -1591,7 +1612,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__n == __last_n)\n \treturn iterator(__n);\n \n-      std::size_t __bkt = this->_M_bucket_index(__n, _M_bucket_count);\n+      std::size_t __bkt = _M_bucket_index(__n);\n \n       _Node* __prev_n = _M_get_previous_node(__bkt, __n);\n       bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);\n@@ -1606,7 +1627,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      --_M_element_count;\n \t      if (!__n)\n \t\tbreak;\n-\t      __n_bkt = this->_M_bucket_index(__n, _M_bucket_count);\n+\t      __n_bkt = _M_bucket_index(__n);\n \t    }\n \t  while (__n != __last_n && __n_bkt == __bkt);\n \t  if (__is_bucket_begin)\n@@ -1672,7 +1693,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  while (__p)\n \t    {\n \t      _Node* __next = __p->_M_next;\n-\t      std::size_t __new_index = this->_M_bucket_index(__p, __n);\n+\t      std::size_t __new_index = _HCBase::_M_bucket_index(__p, __n);\n \t      if (!__new_buckets[__new_index])\n \t\t// Store temporarily bucket end node in _M_buckets if possible.\n \t\t// This will boost second loop where we need to access bucket"}, {"sha": "12a9ad9c6e0d39978f0f7a3c1b79b9d38be35795", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 410, "deletions": 85, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -101,8 +101,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_next() { }\n     };\n \n-  // Local iterators, used to iterate within a bucket but not between\n-  // buckets.\n+  // Node iterators, used to iterate through all the hashtable.\n   template<typename _Value, bool __cache>\n     struct _Node_iterator_base\n     {\n@@ -425,8 +424,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       _Hashtable* __h = static_cast<_Hashtable*>(this);\n       typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n-      std::size_t __n = __h->_M_bucket_index(__k, __code,\n-\t\t\t\t\t     __h->_M_bucket_count);\n+      std::size_t __n = __h->_M_bucket_index(__k, __code);\n \n       typename _Hashtable::_Node* __p = __h->_M_find_node(__n, __k, __code);\n       if (!__p)\n@@ -443,8 +441,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       _Hashtable* __h = static_cast<_Hashtable*>(this);\n       typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n-      std::size_t __n = __h->_M_bucket_index(__k, __code,\n-\t\t\t\t\t     __h->_M_bucket_count);\n+      std::size_t __n = __h->_M_bucket_index(__k, __code);\n \n       typename _Hashtable::_Node* __p = __h->_M_find_node(__n, __k, __code);\n       if (!__p)\n@@ -462,8 +459,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       _Hashtable* __h = static_cast<_Hashtable*>(this);\n       typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n-      std::size_t __n = __h->_M_bucket_index(__k, __code,\n-\t\t\t\t\t     __h->_M_bucket_count);\n+      std::size_t __n = __h->_M_bucket_index(__k, __code);\n \n       typename _Hashtable::_Node* __p = __h->_M_find_node(__n, __k, __code);\n       if (!__p)\n@@ -479,8 +475,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       const _Hashtable* __h = static_cast<const _Hashtable*>(this);\n       typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n-      std::size_t __n = __h->_M_bucket_index(__k, __code,\n-\t\t\t\t\t     __h->_M_bucket_count);\n+      std::size_t __n = __h->_M_bucket_index(__k, __code);\n \n       typename _Hashtable::_Node* __p = __h->_M_find_node(__n, __k, __code);\n       if (!__p)\n@@ -518,6 +513,49 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n+  // Helper class using EBO when it is not forbidden, type is not final,\n+  // and when it worth it, type is empty.\n+  template<int _N, typename _Tp,\n+\t   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>\n+    struct _Ebo_helper;\n+\n+  // Specialization using EBO\n+  template<int _N, typename _Tp>\n+    struct _Ebo_helper<_N, _Tp, true> : _Tp\n+    {\n+      _Ebo_helper() = default;\n+      _Ebo_helper(const _Tp& __tp) : _Tp(__tp)\n+      { }\n+\n+      static const _Tp&\n+      _S_cget(const _Ebo_helper<_N, _Tp, true>& __eboh)\n+      { return static_cast<const _Tp&>(__eboh); }\n+\n+      static _Tp&\n+      _S_get(_Ebo_helper<_N, _Tp, true>& __eboh)\n+      { return static_cast<_Tp&>(__eboh); }\n+    };\n+\n+  // Specialization not using EBO\n+  template<int _N, typename _Tp>\n+    struct _Ebo_helper<_N, _Tp, false>\n+    {\n+      _Ebo_helper() = default;\n+      _Ebo_helper(const _Tp& __tp) : m_tp(__tp)\n+      { }\n+\n+      static const _Tp&\n+      _S_cget(const _Ebo_helper<_N, _Tp, false>& __eboh)\n+      { return __eboh.m_tp; }\n+\n+      static _Tp&\n+      _S_get(_Ebo_helper<_N, _Tp, false>& __eboh)\n+      { return __eboh.m_tp; }\n+\n+    private:\n+      _Tp m_tp;\n+    };\n+\n   // Class template _Hash_code_base.  Encapsulates two policy issues that\n   // aren't quite orthogonal.\n   //   (1) the difference between using a ranged hash function and using\n@@ -526,28 +564,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   //       we have a dummy type as placeholder.\n   //   (2) Whether or not we cache hash codes.  Caching hash codes is\n   //       meaningless if we have a ranged hash function.\n-  // We also put the key extraction and equality comparison function\n-  // objects here, for convenience.\n+  // We also put the key extraction objects here, for convenience.\n+  //\n+  // Each specialization derives from one or more of the template parameters to\n+  // benefit from Ebo. This is important as this type is inherited in some cases\n+  // by the _Local_iterator_base type used to implement local_iterator and\n+  // const_local_iterator. As with any iterator type we prefer to make it as\n+  // small as possible.\n \n   // Primary template: unused except as a hook for specializations.\n-  template<typename _Key, typename _Value,\n-\t   typename _ExtractKey, typename _Equal,\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2, typename _Hash,\n \t   bool __cache_hash_code>\n     struct _Hash_code_base;\n \n   // Specialization: ranged hash function, no caching hash codes.  H1\n   // and H2 are provided but ignored.  We define a dummy hash code type.\n-  template<typename _Key, typename _Value,\n-\t   typename _ExtractKey, typename _Equal,\n+  template<typename _Key, typename _Value, typename _ExtractKey, \n \t   typename _H1, typename _H2, typename _Hash>\n-    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n-\t\t\t   _Hash, false>\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>\n+      : _Ebo_helper<0, _ExtractKey>, _Ebo_helper<1, _Hash>\n     {\n+    private:\n+      typedef _Ebo_helper<0, _ExtractKey> _EboExtractKey;\n+      typedef _Ebo_helper<1, _Hash> _EboHash;\n     protected:\n-      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,\n+      // We need the default constructor for the local iterators.\n+      _Hash_code_base() = default;\n+      _Hash_code_base(const _ExtractKey& __ex,\n \t\t      const _H1&, const _H2&, const _Hash& __h)\n-      : _M_extract(__ex), _M_eq(__eq), _M_ranged_hash(__h) { }\n+\t: _EboExtractKey(__ex), _EboHash(__h) { }\n \n       typedef void* _Hash_code_type;\n \n@@ -558,17 +604,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::size_t\n       _M_bucket_index(const _Key& __k, _Hash_code_type,\n \t\t      std::size_t __n) const\n-      { return _M_ranged_hash(__k, __n); }\n+      { return _M_ranged_hash()(__k, __n); }\n \n       std::size_t\n       _M_bucket_index(const _Hash_node<_Value, false>* __p,\n \t\t      std::size_t __n) const\n-      { return _M_ranged_hash(_M_extract(__p->_M_v), __n); }\n-\n-      bool\n-      _M_compare(const _Key& __k, _Hash_code_type,\n-\t\t _Hash_node<_Value, false>* __n) const\n-      { return _M_eq(__k, _M_extract(__n->_M_v)); }\n+      { return _M_ranged_hash()(_M_extract()(__p->_M_v), __n); }\n \n       void\n       _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const\n@@ -582,72 +623,75 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_swap(_Hash_code_base& __x)\n       {\n-\tstd::swap(_M_extract, __x._M_extract);\n-\tstd::swap(_M_eq, __x._M_eq);\n-\tstd::swap(_M_ranged_hash, __x._M_ranged_hash);\n+\tstd::swap(_M_extract(), __x._M_extract());\n+\tstd::swap(_M_ranged_hash(), __x._M_ranged_hash());\n       }\n \n     protected:\n-      _ExtractKey  _M_extract;\n-      _Equal       _M_eq;\n-      _Hash        _M_ranged_hash;\n+      const _ExtractKey&\n+      _M_extract() const { return _EboExtractKey::_S_cget(*this); }\n+      _ExtractKey&\n+      _M_extract() { return _EboExtractKey::_S_get(*this); }\n+      const _Hash&\n+      _M_ranged_hash() const { return _EboHash::_S_cget(*this); }\n+      _Hash&\n+      _M_ranged_hash() { return _EboHash::_S_get(*this); }\n     };\n \n-\n   // No specialization for ranged hash function while caching hash codes.\n   // That combination is meaningless, and trying to do it is an error.\n \n-\n   // Specialization: ranged hash function, cache hash codes.  This\n   // combination is meaningless, so we provide only a declaration\n   // and no definition.\n-  template<typename _Key, typename _Value,\n-\t   typename _ExtractKey, typename _Equal,\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2, typename _Hash>\n-    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n-\t\t\t   _Hash, true>;\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;\n \n   // Specialization: hash function and range-hashing function, no\n-  // caching of hash codes.  H is provided but ignored.  Provides\n-  // typedef and accessor required by TR1.\n-  template<typename _Key, typename _Value,\n-\t   typename _ExtractKey, typename _Equal,\n+  // caching of hash codes.\n+  // Provides typedef and accessor required by TR1.\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2>\n-    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,\n \t\t\t   _Default_ranged_hash, false>\n+      : _Ebo_helper<0, _ExtractKey>, _Ebo_helper<1, _H1>, _Ebo_helper<2, _H2>\n     {\n+    private:\n+      typedef _Ebo_helper<0, _ExtractKey> _EboExtractKey;\n+      typedef _Ebo_helper<1, _H1> _EboH1;\n+      typedef _Ebo_helper<2, _H2> _EboH2;\n+\n+    public:\n       typedef _H1 hasher;\n \n       hasher\n       hash_function() const\n-      { return _M_h1; }\n+      { return _M_h1(); }\n \n     protected:\n-      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,\n+      // We need the default constructor for the local iterators.\n+      _Hash_code_base() = default;\n+      _Hash_code_base(const _ExtractKey& __ex,\n \t\t      const _H1& __h1, const _H2& __h2,\n \t\t      const _Default_ranged_hash&)\n-      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }\n+      : _EboExtractKey(__ex), _EboH1(__h1), _EboH2(__h2) { }\n \n       typedef std::size_t _Hash_code_type;\n \n       _Hash_code_type\n       _M_hash_code(const _Key& __k) const\n-      { return _M_h1(__k); }\n+      { return _M_h1()(__k); }\n \n       std::size_t\n       _M_bucket_index(const _Key&, _Hash_code_type __c,\n \t\t      std::size_t __n) const\n-      { return _M_h2(__c, __n); }\n+      { return _M_h2()(__c, __n); }\n \n       std::size_t\n       _M_bucket_index(const _Hash_node<_Value, false>* __p,\n \t\t      std::size_t __n) const\n-      { return _M_h2(_M_h1(_M_extract(__p->_M_v)), __n); }\n-\n-      bool\n-      _M_compare(const _Key& __k, _Hash_code_type,\n-\t\t _Hash_node<_Value, false>* __n) const\n-      { return _M_eq(__k, _M_extract(__n->_M_v)); }\n+      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v)), __n); }\n \n       void\n       _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const\n@@ -661,60 +705,68 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_swap(_Hash_code_base& __x)\n       {\n-\tstd::swap(_M_extract, __x._M_extract);\n-\tstd::swap(_M_eq, __x._M_eq);\n-\tstd::swap(_M_h1, __x._M_h1);\n-\tstd::swap(_M_h2, __x._M_h2);\n+\tstd::swap(_M_extract(), __x._M_extract());\n+\tstd::swap(_M_h1(), __x._M_h1());\n+\tstd::swap(_M_h2(), __x._M_h2());\n       }\n \n     protected:\n-      _ExtractKey  _M_extract;\n-      _Equal       _M_eq;\n-      _H1          _M_h1;\n-      _H2          _M_h2;\n+      const _ExtractKey&\n+      _M_extract() const { return _EboExtractKey::_S_cget(*this); }\n+      _ExtractKey&\n+      _M_extract() { return _EboExtractKey::_S_get(*this); }\n+      const _H1&\n+      _M_h1() const { return _EboH1::_S_cget(*this); }\n+      _H1&\n+      _M_h1() { return _EboH1::_S_get(*this); }\n+      const _H2&\n+      _M_h2() const { return _EboH2::_S_cget(*this); }\n+      _H2&\n+      _M_h2() { return _EboH2::_S_get(*this); }\n     };\n \n   // Specialization: hash function and range-hashing function,\n   // caching hash codes.  H is provided but ignored.  Provides\n   // typedef and accessor required by TR1.\n-  template<typename _Key, typename _Value,\n-\t   typename _ExtractKey, typename _Equal,\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n \t   typename _H1, typename _H2>\n-    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,\n \t\t\t   _Default_ranged_hash, true>\n+      : _Ebo_helper<0, _ExtractKey>, _Ebo_helper<1, _H1>, _Ebo_helper<2, _H2>\n     {\n+    private:\n+      typedef _Ebo_helper<0, _ExtractKey> _EboExtractKey;\n+      typedef _Ebo_helper<1, _H1> _EboH1;\n+      typedef _Ebo_helper<2, _H2> _EboH2;\n+\n+    public:\n       typedef _H1 hasher;\n \n       hasher\n       hash_function() const\n-      { return _M_h1; }\n+      { return _M_h1(); }\n \n     protected:\n-      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,\n+      _Hash_code_base(const _ExtractKey& __ex,\n \t\t      const _H1& __h1, const _H2& __h2,\n \t\t      const _Default_ranged_hash&)\n-      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }\n+      : _EboExtractKey(__ex), _EboH1(__h1), _EboH2(__h2) { }\n \n       typedef std::size_t _Hash_code_type;\n \n       _Hash_code_type\n       _M_hash_code(const _Key& __k) const\n-      { return _M_h1(__k); }\n+      { return _M_h1()(__k); }\n \n       std::size_t\n       _M_bucket_index(const _Key&, _Hash_code_type __c,\n \t\t      std::size_t __n) const\n-      { return _M_h2(__c, __n); }\n+      { return _M_h2()(__c, __n); }\n \n       std::size_t\n       _M_bucket_index(const _Hash_node<_Value, true>* __p,\n \t\t      std::size_t __n) const\n-      { return _M_h2(__p->_M_hash_code, __n); }\n-\n-      bool\n-      _M_compare(const _Key& __k, _Hash_code_type __c,\n-\t\t _Hash_node<_Value, true>* __n) const\n-      { return __c == __n->_M_hash_code && _M_eq(__k, _M_extract(__n->_M_v)); }\n+      { return _M_h2()(__p->_M_hash_code, __n); }\n \n       void\n       _M_store_code(_Hash_node<_Value, true>* __n, _Hash_code_type __c) const\n@@ -728,17 +780,290 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_swap(_Hash_code_base& __x)\n       {\n-\tstd::swap(_M_extract, __x._M_extract);\n-\tstd::swap(_M_eq, __x._M_eq);\n-\tstd::swap(_M_h1, __x._M_h1);\n-\tstd::swap(_M_h2, __x._M_h2);\n+\tstd::swap(_M_extract(), __x._M_extract());\n+\tstd::swap(_M_h1(), __x._M_h1());\n+\tstd::swap(_M_h2(), __x._M_h2());\n       }\n \n     protected:\n-      _ExtractKey  _M_extract;\n-      _Equal       _M_eq;\n-      _H1          _M_h1;\n-      _H2          _M_h2;\n+      const _ExtractKey&\n+      _M_extract() const { return _EboExtractKey::_S_cget(*this); }\n+      _ExtractKey&\n+      _M_extract() { return _EboExtractKey::_S_get(*this); }\n+      const _H1&\n+      _M_h1() const { return _EboH1::_S_cget(*this); }\n+      _H1&\n+      _M_h1() { return _EboH1::_S_get(*this); }\n+      const _H2&\n+      _M_h2() const { return _EboH2::_S_cget(*this); }\n+      _H2&\n+      _M_h2() { return _EboH2::_S_get(*this); }\n+    };\n+\n+  template <typename _Key, typename _Value, typename _ExtractKey,\n+\t    typename _Equal, typename _HashCodeType,\n+\t    bool __cache_hash_code>\n+  struct _Equal_helper;\n+\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _Equal, typename _HashCodeType>\n+  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>\n+  {\n+    static bool\n+    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,\n+\t      const _Key& __k, _HashCodeType __c,\n+\t      _Hash_node<_Value, true>* __n)\n+    { return __c == __n->_M_hash_code\n+\t     && __eq(__k, __extract(__n->_M_v)); }\n+  };\n+\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _Equal, typename _HashCodeType>\n+  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>\n+  {\n+    static bool\n+    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,\n+\t      const _Key& __k, _HashCodeType,\n+\t      _Hash_node<_Value, false>* __n)\n+    { return __eq(__k, __extract(__n->_M_v)); }\n+  };\n+\n+  // Helper class adding management of _Equal functor to _Hash_code_base\n+  // type.\n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   bool __cache_hash_code>\n+  struct _Hashtable_base\n+    : _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,\n+\t\t      __cache_hash_code>,\n+      _Ebo_helper<0, _Equal>\n+  {\n+  private:\n+    typedef _Ebo_helper<0, _Equal> _EboEqual;\n+\n+  protected:\n+    typedef _Hash_code_base<_Key, _Value, _ExtractKey,\n+\t\t\t    _H1, _H2, _Hash, __cache_hash_code> _HCBase;\n+    typedef typename _HCBase::_Hash_code_type _Hash_code_type;\n+\n+    _Hashtable_base(const _ExtractKey& __ex,\n+\t\t    const _H1& __h1, const _H2& __h2,\n+\t\t    const _Hash& __hash, const _Equal& __eq)\n+      : _HCBase(__ex, __h1, __h2, __hash), _EboEqual(__eq) { }\n+\n+    bool\n+    _M_equals(const _Key& __k, _Hash_code_type __c,\n+\t      _Hash_node<_Value, __cache_hash_code>* __n) const\n+    {\n+      typedef _Equal_helper<_Key, _Value, _ExtractKey,\n+\t\t\t   _Equal, _Hash_code_type,\n+\t\t\t   __cache_hash_code> _EqualHelper;\n+      return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(), __k, __c, __n);\n+    }\n+\n+    void\n+    _M_swap(_Hashtable_base& __x)\n+    {\n+      _HCBase::_M_swap(__x);\n+      std::swap(_M_eq(), __x._M_eq());\n+    }\n+\n+  private:\n+    const _Equal&\n+    _M_eq() const { return _EboEqual::_S_cget(*this); }\n+    _Equal&\n+    _M_eq() { return _EboEqual::_S_get(*this); }\n+  };\n+\n+  // Local iterators, used to iterate within a bucket but not between\n+  // buckets.\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   bool __cache_hash_code>\n+    struct _Local_iterator_base;\n+\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _H1, typename _H2, typename _Hash>\n+    struct _Local_iterator_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t_H1, _H2, _Hash, true>\n+      : _H2\n+    {\n+      _Local_iterator_base() = default;\n+      _Local_iterator_base(_Hash_node<_Value, true>* __p,\n+\t\t\t   std::size_t __bkt, std::size_t __bkt_count)\n+      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }\n+\n+      void\n+      _M_incr()\n+      {\n+\t_M_cur = _M_cur->_M_next;\n+\tif (_M_cur)\n+\t  {\n+\t    std::size_t __bkt = _M_h2()(_M_cur->_M_hash_code, _M_bucket_count);\n+\t    if (__bkt != _M_bucket)\n+\t      _M_cur = nullptr;\n+\t  }\n+      }\n+\n+      const _H2& _M_h2() const\n+      { return *this; }\n+\n+      _Hash_node<_Value, true>*  _M_cur;\n+      std::size_t _M_bucket;\n+      std::size_t _M_bucket_count;\n+    };\n+\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _H1, typename _H2, typename _Hash>\n+    struct _Local_iterator_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t_H1, _H2, _Hash, false>\n+      : _Hash_code_base<_Key, _Value, _ExtractKey,\n+\t\t\t_H1, _H2, _Hash, false>\n+    {\n+      _Local_iterator_base() = default;\n+      _Local_iterator_base(_Hash_node<_Value, false>* __p,\n+\t\t\t   std::size_t __bkt, std::size_t __bkt_count)\n+      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }\n+\n+      void\n+      _M_incr()\n+      {\n+\t_M_cur = _M_cur->_M_next;\n+\tif (_M_cur)\n+\t  {\n+\t    std::size_t __bkt = this->_M_bucket_index(_M_cur, _M_bucket_count);\n+\t    if (__bkt != _M_bucket)\n+\t      _M_cur = nullptr;\n+\t  }\n+      }\n+\n+      _Hash_node<_Value, false>*  _M_cur;\n+      std::size_t _M_bucket;\n+      std::size_t _M_bucket_count;\n+    };\n+\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _H1, typename _H2, typename _Hash, bool __cache>\n+    inline bool\n+    operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t  _H1, _H2, _Hash, __cache>& __x,\n+\t       const _Local_iterator_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t  _H1, _H2, _Hash, __cache>& __y)\n+    { return __x._M_cur == __y._M_cur; }\n+\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _H1, typename _H2, typename _Hash, bool __cache>\n+    inline bool\n+    operator!=(const _Local_iterator_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t  _H1, _H2, _Hash, __cache>& __x,\n+\t       const _Local_iterator_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t  _H1, _H2, _Hash, __cache>& __y)\n+    { return __x._M_cur != __y._M_cur; }\n+\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   bool __constant_iterators, bool __cache>\n+    struct _Local_iterator\n+    : public _Local_iterator_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t  _H1, _H2, _Hash, __cache>\n+    {\n+      typedef _Value                                   value_type;\n+      typedef typename std::conditional<__constant_iterators,\n+\t\t\t\t\tconst _Value*, _Value*>::type\n+\t\t\t\t\t\t       pointer;\n+      typedef typename std::conditional<__constant_iterators,\n+\t\t\t\t\tconst _Value&, _Value&>::type\n+\t\t\t\t\t\t       reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      _Local_iterator() = default;\n+\n+      explicit\n+      _Local_iterator(_Hash_node<_Value, __cache>* __p,\n+\t\t      std::size_t __bkt, std::size_t __bkt_count)\n+      : _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,\n+\t\t\t     __cache>(__p, __bkt, __bkt_count)\n+      { }\n+\n+      reference\n+      operator*() const\n+      { return this->_M_cur->_M_v; }\n+\n+      pointer\n+      operator->() const\n+      { return std::__addressof(this->_M_cur->_M_v); }\n+\n+      _Local_iterator&\n+      operator++()\n+      {\n+\tthis->_M_incr();\n+\treturn *this;\n+      }\n+\n+      _Local_iterator\n+      operator++(int)\n+      {\n+\t_Local_iterator __tmp(*this);\n+\tthis->_M_incr();\n+\treturn __tmp;\n+      }\n+    };\n+\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   bool __constant_iterators, bool __cache>\n+    struct _Local_const_iterator\n+    : public _Local_iterator_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t  _H1, _H2, _Hash, __cache>\n+    {\n+      typedef _Value                                   value_type;\n+      typedef const _Value*                            pointer;\n+      typedef const _Value&                            reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      _Local_const_iterator() = default;\n+\n+      explicit\n+      _Local_const_iterator(_Hash_node<_Value, __cache>* __p,\n+\t\t\t    std::size_t __bkt, std::size_t __bkt_count)\n+      : _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,\n+\t\t\t     __cache>(__p, __bkt, __bkt_count)\n+      { }\n+\n+      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t\t  _H1, _H2, _Hash,\n+\t\t\t\t\t\t  __constant_iterators,\n+\t\t\t\t\t\t  __cache>& __x)\n+      : _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,\n+\t\t\t     __cache>(__x._M_cur, __x._M_bucket,\n+\t\t\t\t      __x._M_bucket_count)\n+      { }\n+\n+      reference\n+      operator*() const\n+      { return this->_M_cur->_M_v; }\n+\n+      pointer\n+      operator->() const\n+      { return std::__addressof(this->_M_cur->_M_v); }\n+\n+      _Local_const_iterator&\n+      operator++()\n+      {\n+\tthis->_M_incr();\n+\treturn *this;\n+      }\n+\n+      _Local_const_iterator\n+      operator++(int)\n+      {\n+\t_Local_const_iterator __tmp(*this);\n+\tthis->_M_incr();\n+\treturn __tmp;\n+      }\n     };\n \n "}, {"sha": "95f5657762a1295bab32eb8101775dea86e987db", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -41,7 +41,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t   class _Pred = std::equal_to<_Key>,\n \t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n \t   bool __cache_hash_code =\n-\t     __not_<__and_<is_integral<_Key>,\n+\t     __not_<__and_<is_integral<_Key>, is_empty<_Hash>,\n+\t\t\t   integral_constant<bool, !__is_final(_Hash)>,\n \t\t\t   __detail::__is_noexcept_hash<_Key, _Hash>>>::value>\n     class __unordered_map\n     : public _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,\n@@ -112,7 +113,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t   class _Pred = std::equal_to<_Key>,\n \t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n \t   bool __cache_hash_code =\n-\t     __not_<__and_<is_integral<_Key>,\n+\t     __not_<__and_<is_integral<_Key>, is_empty<_Hash>,\n+\t\t\t   integral_constant<bool, !__is_final(_Hash)>,\n \t\t\t   __detail::__is_noexcept_hash<_Key, _Hash>>>::value>\n     class __unordered_multimap\n     : public _Hashtable<_Key, std::pair<const _Key, _Tp>,"}, {"sha": "3d5361d42668c9ed867bc04e7177a598dd93892e", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -41,7 +41,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t   class _Pred = std::equal_to<_Value>,\n \t   class _Alloc = std::allocator<_Value>,\n \t   bool __cache_hash_code =\n-\t     __not_<__and_<is_integral<_Value>,\n+\t     __not_<__and_<is_integral<_Value>, is_empty<_Hash>,\n+\t\t\t   integral_constant<bool, !__is_final(_Hash)>,\n \t\t\t   __detail::__is_noexcept_hash<_Value, _Hash>>>::value>\n     class __unordered_set\n     : public _Hashtable<_Value, _Value, _Alloc,\n@@ -124,7 +125,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t   class _Pred = std::equal_to<_Value>,\n \t   class _Alloc = std::allocator<_Value>,\n \t   bool __cache_hash_code =\n-\t     __not_<__and_<is_integral<_Value>,\n+\t     __not_<__and_<is_integral<_Value>, is_empty<_Hash>,\n+\t\t\t   integral_constant<bool, !__is_final(_Hash)>,\n \t\t\t   __detail::__is_noexcept_hash<_Value, _Hash>>>::value>\n     class __unordered_multiset\n     : public _Hashtable<_Value, _Value, _Alloc,"}, {"sha": "37ca3cee7cc12514fea89c140c0f3599ad4bac5a", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -418,11 +418,19 @@ namespace __debug\n \n       static _Base_local_iterator\n       _S_to_local(_Base_iterator __it)\n-      { return _Base_local_iterator(__it._M_cur); }\n+      {\n+        // The returned local iterator will not be incremented so we don't\n+\t// need to compute __it's node bucket\n+\treturn _Base_local_iterator(__it._M_cur, 0, 0);\n+      }\n \n       static _Base_const_local_iterator\n       _S_to_local(_Base_const_iterator __it)\n-      { return _Base_const_local_iterator(__it._M_cur); }\n+      {\n+        // The returned local iterator will not be incremented so we don't\n+\t// need to compute __it's node bucket\n+\treturn _Base_const_local_iterator(__it._M_cur, 0, 0);\n+      }\n     };\n \n   template<typename _Key, typename _Tp, typename _Hash,\n@@ -820,11 +828,19 @@ namespace __debug\n \n       static _Base_local_iterator\n       _S_to_local(_Base_iterator __it)\n-      { return _Base_local_iterator(__it._M_cur); }\n+      {\n+        // The returned local iterator will not be incremented so we don't\n+\t// need to compute __it's node bucket\n+\treturn _Base_local_iterator(__it._M_cur, 0, 0);\n+      }\n \n       static _Base_const_local_iterator\n       _S_to_local(_Base_const_iterator __it)\n-      { return _Base_const_local_iterator(__it._M_cur); }\n+      {\n+        // The returned local iterator will not be incremented so we don't\n+\t// need to compute __it's node bucket\n+\treturn _Base_const_local_iterator(__it._M_cur, 0, 0);\n+      }\n     };\n \n   template<typename _Key, typename _Tp, typename _Hash,"}, {"sha": "7323184d4389f914f447c4ffb2e8c163dc3a1220", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -417,11 +417,19 @@ namespace __debug\n \n       static _Base_local_iterator\n       _S_to_local(_Base_iterator __it)\n-      { return _Base_local_iterator(__it._M_cur); }\n+      {\n+        // The returned local iterator will not be incremented so we don't\n+\t// need to compute __it's node bucket\n+\treturn _Base_local_iterator(__it._M_cur, 0, 0);\n+      }\n \n       static _Base_const_local_iterator\n       _S_to_local(_Base_const_iterator __it)\n-      { return _Base_const_local_iterator(__it._M_cur); }\n+      {\n+        // The returned local iterator will not be incremented so we don't\n+\t// need to compute __it's node bucket\n+\treturn _Base_const_local_iterator(__it._M_cur, 0, 0);\n+      }\n     };\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n@@ -805,11 +813,19 @@ namespace __debug\n \n       static _Base_local_iterator\n       _S_to_local(_Base_iterator __it)\n-      { return _Base_local_iterator(__it._M_cur); }\n+      {\n+        // The returned local iterator will not be incremented so we don't\n+\t// need to compute __it's node bucket\n+\treturn _Base_local_iterator(__it._M_cur, 0, 0);\n+      }\n \n       static _Base_const_local_iterator\n       _S_to_local(_Base_const_iterator __it)\n-      { return _Base_const_local_iterator(__it._M_cur); }\n+      {\n+        // The returned local iterator will not be incremented so we don't\n+\t// need to compute __it's node bucket\n+\treturn _Base_const_local_iterator(__it._M_cur, 0, 0);\n+      }\n     };\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>"}, {"sha": "1d0f0d530640f34fd4fb4676b9b78ba49001b619", "filename": "libstdc++-v3/include/profile/unordered_map", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -308,9 +308,9 @@ namespace __profile\n \twhile (__it != this->end())\n \t  {\n \t    size_type __bkt = this->bucket(__it->first);\n-\t    for (++__it; __it != this->end()\n-\t\t\t && this->bucket(__it->first) == __bkt;\n-\t\t ++__it)\n+\t    auto __lit = this->begin(__bkt);\n+\t    auto __lend = this->end(__bkt);\n+\t    for (++__it, ++__lit; __lit != __lend; ++__it, ++__lit)\n \t      ++__chain;\n \t    if (__chain)\n \t      {\n@@ -577,9 +577,9 @@ namespace __profile\n \twhile (__it != this->end())\n \t  {\n \t    size_type __bkt = this->bucket(__it->first);\n-\t    for (++__it; __it != this->end()\n-\t\t\t && this->bucket(__it->first) == __bkt;\n-\t\t ++__it)\n+\t    auto __lit = this->begin(__bkt);\n+\t    auto __lend = this->end(__bkt);\n+\t    for (++__it, ++__lit; __lit != __lend; ++__it, ++__lit)\n \t      ++__chain;\n \t    if (__chain)\n \t      {"}, {"sha": "7bb10dc45c0d940c65daf7ee9383eec1a9f6a4ef", "filename": "libstdc++-v3/include/profile/unordered_set", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -277,10 +277,10 @@ namespace __profile\n \twhile (__it != this->end())\n \t  {\n \t    size_type __bkt = this->bucket(*__it);\n-\t    for (++__it; __it != this->end() && this->bucket(*__it) == __bkt;\n-\t\t ++__it)\n+\t    auto __lit = this->begin(__bkt);\n+\t    auto __lend = this->end(__bkt);\n+\t    for (++__it, ++__lit; __lit != __lend; ++__it, ++__lit)\n \t      ++__chain;\n-\n \t    if (__chain)\n \t      {\n \t\t++__chain;\n@@ -539,10 +539,10 @@ namespace __profile\n \twhile (__it != this->end())\n \t  {\n \t    size_type __bkt = this->bucket(*__it);\n-\t    for (++__it; __it != this->end() && this->bucket(*__it) == __bkt;\n-\t\t ++__it)\n+\t    auto __lit = this->begin(__bkt);\n+\t    auto __lend = this->end(__bkt);\n+\t    for (++__it, ++__lit; __lit != __lend; ++__it, ++__lit)\n \t      ++__chain;\n-\n \t    if (__chain)\n \t      {\n \t\t++__chain;"}, {"sha": "c509a34afeebb9139ad9f07946bdba562e418167", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/final_hash.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ffinal_hash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ffinal_hash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ffinal_hash.cc?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <string>\n+#include <unordered_map>\n+\n+namespace\n+{\n+  template<typename _Tp>\n+  struct final_hash final\n+  {\n+    std::size_t operator() (const _Tp&) const noexcept\n+    { return 0; }\n+  };\n+}\n+\n+// A non-integral type:\n+template class std::unordered_map<std::string, int, final_hash<std::string>>;\n+\n+// An integral type;\n+template class std::unordered_map<int, int, final_hash<int>>;\n+"}, {"sha": "4e2920c2437fcefda12dd4928553f512b23ed9d9", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/final_hash.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ffinal_hash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ffinal_hash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ffinal_hash.cc?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <string>\n+#include <unordered_map>\n+\n+namespace\n+{\n+  template<typename _Tp>\n+  struct final_hash final\n+  {\n+    std::size_t operator() (const _Tp&) const noexcept\n+    { return 0; }\n+  };\n+}\n+\n+// A non-integral type:\n+template class std::unordered_multimap<std::string, int,\n+\t\t\t\t       final_hash<std::string>>;\n+\n+// An integral type;\n+template class std::unordered_multimap<int, int, final_hash<int>>;\n+"}, {"sha": "242642f2bba49dfbba3bb7dfee21a2f664143659", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/final_hash.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ffinal_hash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ffinal_hash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ffinal_hash.cc?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <string>\n+#include <unordered_set>\n+\n+namespace\n+{\n+  template<typename _Tp>\n+  struct final_hash final\n+  {\n+    std::size_t operator() (const _Tp&) const noexcept\n+    { return 0; }\n+  };\n+}\n+\n+// A non-integral type:\n+template class std::unordered_multiset<std::string, final_hash<std::string>>;\n+\n+// An integral type;\n+template class std::unordered_multiset<int, final_hash<int>>;\n+"}, {"sha": "5dced4cd1a60751fb5092b50bdca6b208990f6fb", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/final_hash.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ffinal_hash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ffinal_hash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ffinal_hash.cc?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <string>\n+#include <unordered_set>\n+\n+namespace\n+{\n+  template<typename _Tp>\n+  struct final_hash final\n+  {\n+    std::size_t operator() (const _Tp&) const noexcept\n+    { return 0; }\n+  };\n+}\n+\n+// A non-integral type:\n+template class std::unordered_set<std::string, final_hash<std::string>>;\n+\n+// An integral type;\n+template class std::unordered_set<int, final_hash<int>>;\n+"}, {"sha": "eb16e81a4d34619f84816db55bdcd17341d5790d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/instantiation_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a188284c61ceff5871df88b2f4ad5972bfd6fb3a/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc?ref=a188284c61ceff5871df88b2f4ad5972bfd6fb3a", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 177 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 185 }\n \n #include <unordered_set>\n "}]}