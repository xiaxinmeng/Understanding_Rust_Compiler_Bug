{"sha": "37811a734e0548dcc1d24e695db5a153ca42c8ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc4MTFhNzM0ZTA1NDhkY2MxZDI0ZTY5NWRiNWExNTNjYTQyYzhlZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-08T23:21:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-08T23:21:13Z"}, "message": "(store_split_bit_field): When adjust arg in BYTES_BIT_ENDIAN case...\n\n(store_split_bit_field): When adjust arg in BYTES_BIT_ENDIAN case, use\nnumber of bits in arg for MEM operands and BITS_PER_WORD for other\noperands.\n(extract_fixed_bit_field): Undo last change.\n\nFrom-SVN: r9911", "tree": {"sha": "4c73a5eb6a8c3d1ad9b25086b65d85d9e1047f50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c73a5eb6a8c3d1ad9b25086b65d85d9e1047f50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37811a734e0548dcc1d24e695db5a153ca42c8ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37811a734e0548dcc1d24e695db5a153ca42c8ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37811a734e0548dcc1d24e695db5a153ca42c8ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37811a734e0548dcc1d24e695db5a153ca42c8ee/comments", "author": null, "committer": null, "parents": [{"sha": "68450062d996673ab34d09c9022947960cd85749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68450062d996673ab34d09c9022947960cd85749", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68450062d996673ab34d09c9022947960cd85749"}], "stats": {"total": 20, "additions": 14, "deletions": 6}, "files": [{"sha": "4da81a7c94db4f5e24062bfc4e56c49e993fdffc", "filename": "gcc/expmed.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37811a734e0548dcc1d24e695db5a153ca42c8ee/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37811a734e0548dcc1d24e695db5a153ca42c8ee/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=37811a734e0548dcc1d24e695db5a153ca42c8ee", "patch": "@@ -770,6 +770,16 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n \n       if (BYTES_BIG_ENDIAN)\n \t{\n+\t  int total_bits;\n+\n+\t  /* We must do an endian conversion exactly the same way as it is\n+\t     done in extract_bit_field, so that the two calls to\n+\t     extract_fixed_bit_field will have comparable arguments.  */\n+\t  if (GET_CODE (value) != MEM)\n+\t    total_bits = BITS_PER_WORD;\n+\t  else\n+\t    total_bits = GET_MODE_BITSIZE (GET_MODE (value));\n+\n \t  /* Fetch successively less significant portions.  */\n \t  if (GET_CODE (value) == CONST_INT)\n \t    part = GEN_INT (((unsigned HOST_WIDE_INT) (INTVAL (value))\n@@ -780,8 +790,7 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n \t       lsb.  Give extract_bit_field the value it needs (with\n \t       endianness compensation) to fetch the piece we want.  */\n \t    part = extract_fixed_bit_field (word_mode, value, 0, thissize,\n-\t\t\t\t\t    GET_MODE_BITSIZE (GET_MODE (value))\n-\t\t\t\t\t    - bitsize + bitsdone,\n+\t\t\t\t\t    total_bits - bitsize + bitsdone,\n \t\t\t\t\t    NULL_RTX, 1, align);\n \t}\n       else\n@@ -1362,7 +1371,7 @@ extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n      int unsignedp;\n      int align;\n {\n-  int total_bits;\n+  int total_bits = BITS_PER_WORD;\n   enum machine_mode mode;\n \n   if (GET_CODE (op0) == SUBREG || GET_CODE (op0) == REG)\n@@ -1371,9 +1380,6 @@ extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n       if (bitsize + bitpos > BITS_PER_WORD)\n \treturn extract_split_bit_field (op0, bitsize, bitpos,\n \t\t\t\t\tunsignedp, align);\n-\n-      mode = GET_MODE (op0);\n-      total_bits = GET_MODE_BITSIZE (mode);\n     }\n   else\n     {\n@@ -1414,6 +1420,8 @@ extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n \t\t\t    plus_constant (XEXP (op0, 0), offset));\n     }\n \n+  mode = GET_MODE (op0);\n+\n   if (BYTES_BIG_ENDIAN)\n     {\n       /* BITPOS is the distance between our msb and that of OP0."}]}