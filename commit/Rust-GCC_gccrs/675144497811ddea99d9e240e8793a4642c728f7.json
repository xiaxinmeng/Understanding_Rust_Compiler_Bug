{"sha": "675144497811ddea99d9e240e8793a4642c728f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc1MTQ0NDk3ODExZGRlYTk5ZDllMjQwZTg3OTNhNDY0MmM3MjhmNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-03-12T12:15:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-03-12T12:15:41Z"}, "message": "Makefile.in (OBJS-common): Add tree-ssa-phiprop.o\n\n2008-03-12  Richard Guenther  <rguenther@suse.de>\n\n\t* Makefile.in (OBJS-common): Add tree-ssa-phiprop.o\n\t(tree-ssa-phiprop.o): Copy dependencies from tree-ssa-forwprop.o.\n\t* timevar.def (TV_TREE_PHIPROP): Add.\n\t* tree-ssa-phiprop.c: Split from tree-ssa-forwprop.c, added\n\tpass description.  Use TV_TREE_PHIPROP.\n\t* tree-ssa-forwprop.c: Remove phiprop code.\n\nFrom-SVN: r133140", "tree": {"sha": "2dd0fc2970e13cae090a907dda3e1bc3f452b300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dd0fc2970e13cae090a907dda3e1bc3f452b300"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/675144497811ddea99d9e240e8793a4642c728f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/675144497811ddea99d9e240e8793a4642c728f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/675144497811ddea99d9e240e8793a4642c728f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/675144497811ddea99d9e240e8793a4642c728f7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb31c4bcc5e8ef33ba4364453f02f3e1ddb557e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb31c4bcc5e8ef33ba4364453f02f3e1ddb557e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb31c4bcc5e8ef33ba4364453f02f3e1ddb557e9"}], "stats": {"total": 703, "additions": 404, "deletions": 299}, "files": [{"sha": "480160854f107c96db16cced64801bab019ab064", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675144497811ddea99d9e240e8793a4642c728f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675144497811ddea99d9e240e8793a4642c728f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=675144497811ddea99d9e240e8793a4642c728f7", "patch": "@@ -1,3 +1,12 @@\n+2008-03-12  Richard Guenther  <rguenther@suse.de>\n+\n+\t* Makefile.in (OBJS-common): Add tree-ssa-phiprop.o\n+\t(tree-ssa-phiprop.o): Copy dependencies from tree-ssa-forwprop.o.\n+\t* timevar.def (TV_TREE_PHIPROP): Add.\n+\t* tree-ssa-phiprop.c: Split from tree-ssa-forwprop.c, added\n+\tpass description.  Use TV_TREE_PHIPROP.\n+\t* tree-ssa-forwprop.c: Remove phiprop code.\n+\n 2008-03-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/35549"}, {"sha": "7e83e5023ac20d14a8267fdeb16ac795deee72a2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675144497811ddea99d9e240e8793a4642c728f7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675144497811ddea99d9e240e8793a4642c728f7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=675144497811ddea99d9e240e8793a4642c728f7", "patch": "@@ -1194,6 +1194,7 @@ OBJS-common = \\\n \ttree-ssa-math-opts.o \\\n \ttree-ssa-operands.o \\\n \ttree-ssa-phiopt.o \\\n+\ttree-ssa-phiprop.o \\\n \ttree-ssa-pre.o \\\n \ttree-ssa-propagate.o \\\n \ttree-ssa-reassoc.o \\\n@@ -2017,6 +2018,10 @@ tree-ssa-forwprop.o : tree-ssa-forwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    langhooks.h $(FLAGS_H)\n+tree-ssa-phiprop.o : tree-ssa-forwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n+   langhooks.h $(FLAGS_H)\n tree-ssa-ifcombine.o : tree-ssa-ifcombine.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H)"}, {"sha": "4cc57b032ec10d56924ef67541a7723d4ea660c2", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675144497811ddea99d9e240e8793a4642c728f7/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675144497811ddea99d9e240e8793a4642c728f7/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=675144497811ddea99d9e240e8793a4642c728f7", "patch": "@@ -109,6 +109,7 @@ DEFTIMEVAR (TV_TREE_FRE\t\t     , \"tree FRE\")\n DEFTIMEVAR (TV_TREE_SINK             , \"tree code sinking\")\n DEFTIMEVAR (TV_TREE_PHIOPT\t     , \"tree linearize phis\")\n DEFTIMEVAR (TV_TREE_FORWPROP\t     , \"tree forward propagate\")\n+DEFTIMEVAR (TV_TREE_PHIPROP\t     , \"tree phiprop\")\n DEFTIMEVAR (TV_TREE_DCE\t\t     , \"tree conservative DCE\")\n DEFTIMEVAR (TV_TREE_CD_DCE\t     , \"tree aggressive DCE\")\n DEFTIMEVAR (TV_TREE_DSE\t\t     , \"tree DSE\")"}, {"sha": "5108cfcd6f20646dbacfcd0c6aab50650a439883", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 299, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675144497811ddea99d9e240e8793a4642c728f7/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675144497811ddea99d9e240e8793a4642c728f7/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=675144497811ddea99d9e240e8793a4642c728f7", "patch": "@@ -1,5 +1,5 @@\n /* Forward propagation of expressions for single use variables.\n-   Copyright (C) 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1082,301 +1082,3 @@ struct tree_opt_pass pass_forwprop = {\n   0\t\t\t\t/* letter */\n };\n \n-\n-/* Structure to keep track of the value of a dereferenced PHI result\n-   and the set of virtual operands used for that dereference.  */\n-\n-struct phiprop_d\n-{\n-  tree value;\n-  tree vop_stmt;\n-};\n-\n-/* Verify if the value recorded for NAME in PHIVN is still valid at\n-   the start of basic block BB.  */\n-\n-static bool\n-phivn_valid_p (struct phiprop_d *phivn, tree name, basic_block bb)\n-{\n-  tree vop_stmt = phivn[SSA_NAME_VERSION (name)].vop_stmt;\n-  ssa_op_iter ui;\n-  tree vuse;\n-\n-  /* The def stmts of all virtual uses need to be post-dominated\n-     by bb.  */\n-  FOR_EACH_SSA_TREE_OPERAND (vuse, vop_stmt, ui, SSA_OP_VUSE)\n-    {\n-      tree use_stmt;\n-      imm_use_iterator ui2;\n-      bool ok = true;\n-\n-      FOR_EACH_IMM_USE_STMT (use_stmt, ui2, vuse)\n-\t{\n-\t  /* If BB does not dominate a VDEF, the value is invalid.  */\n-\t  if (((TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n-\t        && !ZERO_SSA_OPERANDS (use_stmt, SSA_OP_VDEF))\n-\t       || TREE_CODE (use_stmt) == PHI_NODE)\n-\t      && !dominated_by_p (CDI_DOMINATORS, bb_for_stmt (use_stmt), bb))\n-\t    {\n-\t      ok = false;\n-\t      BREAK_FROM_IMM_USE_STMT (ui2);\n-\t    }\n-\t}\n-      if (!ok)\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n-/* Insert a new phi node for the dereference of PHI at basic_block\n-   BB with the virtual operands from USE_STMT.  */\n-\n-static tree\n-phiprop_insert_phi (basic_block bb, tree phi, tree use_stmt,\n-\t\t    struct phiprop_d *phivn, size_t n)\n-{\n-  tree res, new_phi;\n-  edge_iterator ei;\n-  edge e;\n-\n-  /* Build a new PHI node to replace the definition of\n-     the indirect reference lhs.  */\n-  res = GIMPLE_STMT_OPERAND (use_stmt, 0);\n-  SSA_NAME_DEF_STMT (res) = new_phi = create_phi_node (res, bb);\n-\n-  /* Add PHI arguments for each edge inserting loads of the\n-     addressable operands.  */\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    {\n-      tree old_arg, new_var, tmp;\n-\n-      old_arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n-      while (TREE_CODE (old_arg) == SSA_NAME\n-\t     && (SSA_NAME_VERSION (old_arg) >= n\n-\t         || phivn[SSA_NAME_VERSION (old_arg)].value == NULL_TREE))\n-\t{\n-\t  tree def_stmt = SSA_NAME_DEF_STMT (old_arg);\n-\t  old_arg = GIMPLE_STMT_OPERAND (def_stmt, 1);\n-\t}\n-\n-      if (TREE_CODE (old_arg) == SSA_NAME)\n-\t/* Reuse a formerly created dereference.  */\n-\tnew_var = phivn[SSA_NAME_VERSION (old_arg)].value;\n-      else\n-\t{\n-\t  old_arg = TREE_OPERAND (old_arg, 0);\n-\t  new_var = create_tmp_var (TREE_TYPE (old_arg), NULL);\n-\t  tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n-\t\t\tNULL_TREE, unshare_expr (old_arg));\n-\t  if (TREE_CODE (TREE_TYPE (old_arg)) == COMPLEX_TYPE\n-\t      || TREE_CODE (TREE_TYPE (old_arg)) == VECTOR_TYPE)\n-\t    DECL_GIMPLE_REG_P (new_var) = 1;\n-\t  add_referenced_var (new_var);\n-\t  new_var = make_ssa_name (new_var, tmp);\n-\t  GIMPLE_STMT_OPERAND (tmp, 0) = new_var;\n-\n-\t  bsi_insert_on_edge (e, tmp);\n-\n-\t  update_stmt (tmp);\n-\t  mark_symbols_for_renaming (tmp);\n-\t}\n-\n-      add_phi_arg (new_phi, new_var, e);\n-    }\n-\n-  update_stmt (new_phi);\n-\n-  return res;\n-}\n-\n-/* Propagate between the phi node arguments of PHI in BB and phi result\n-   users.  For now this matches\n-        # p_2 = PHI <&x, &y>\n-      <Lx>:;\n-\tp_3 = p_2;\n-\tz_2 = *p_3;\n-   and converts it to\n-\t# z_2 = PHI <x, y>\n-      <Lx>:;\n-   Returns true if a transformation was done and edge insertions\n-   need to be committed.  Global data PHIVN and N is used to track\n-   past transformation results.  We need to be especially careful here\n-   with aliasing issues as we are moving memory reads.  */\n-\n-static bool\n-propagate_with_phi (basic_block bb, tree phi, struct phiprop_d *phivn, size_t n)\n-{\n-  tree ptr = PHI_RESULT (phi);\n-  tree use_stmt, res = NULL_TREE;\n-  block_stmt_iterator bsi;\n-  imm_use_iterator ui;\n-  use_operand_p arg_p, use;\n-  ssa_op_iter i;\n-  bool phi_inserted;\n-\n-  if (MTAG_P (SSA_NAME_VAR (ptr))\n-      || !POINTER_TYPE_P (TREE_TYPE (ptr))\n-      || !is_gimple_reg_type (TREE_TYPE (TREE_TYPE (ptr))))\n-    return false;\n-\n-  /* Check if we can \"cheaply\" dereference all phi arguments.  */\n-  FOR_EACH_PHI_ARG (arg_p, phi, i, SSA_OP_USE)\n-    {\n-      tree arg = USE_FROM_PTR (arg_p);\n-      /* Walk the ssa chain until we reach a ssa name we already\n-\t created a value for or we reach a definition of the form\n-\t ssa_name_n = &var;  */\n-      while (TREE_CODE (arg) == SSA_NAME\n-\t     && !SSA_NAME_IS_DEFAULT_DEF (arg)\n-\t     && (SSA_NAME_VERSION (arg) >= n\n-\t         || phivn[SSA_NAME_VERSION (arg)].value == NULL_TREE))\n-\t{\n-\t  tree def_stmt = SSA_NAME_DEF_STMT (arg);\n-\t  if (TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT)\n-\t    return false;\n-\t  arg = GIMPLE_STMT_OPERAND (def_stmt, 1);\n-\t}\n-      if ((TREE_CODE (arg) != ADDR_EXPR\n-\t   /* Avoid to have to decay *&a to a[0] later.  */\n-\t   || !is_gimple_reg_type (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-\t  && !(TREE_CODE (arg) == SSA_NAME\n-\t       && phivn[SSA_NAME_VERSION (arg)].value != NULL_TREE\n-\t       && phivn_valid_p (phivn, arg, bb)))\n-\treturn false;\n-    }\n-\n-  /* Find a dereferencing use.  First follow (single use) ssa\n-     copy chains for ptr.  */\n-  while (single_imm_use (ptr, &use, &use_stmt)\n-\t && TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n-\t && GIMPLE_STMT_OPERAND (use_stmt, 1) == ptr\n-\t && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 0)) == SSA_NAME)\n-    ptr = GIMPLE_STMT_OPERAND (use_stmt, 0);\n-\n-  /* Replace the first dereference of *ptr if there is one and if we\n-     can move the loads to the place of the ptr phi node.  */\n-  phi_inserted = false;\n-  FOR_EACH_IMM_USE_STMT (use_stmt, ui, ptr)\n-    {\n-      ssa_op_iter ui2;\n-      tree vuse;\n-\n-      /* Check whether this is a load of *ptr.  */\n-      if (!(TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n-\t    && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 0)) == SSA_NAME \n-\t    && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == INDIRECT_REF\n-\t    && TREE_OPERAND (GIMPLE_STMT_OPERAND (use_stmt, 1), 0) == ptr\n-\t    /* We cannot replace a load that may throw or is volatile.  */\n-\t    && !tree_can_throw_internal (use_stmt)))\n-\tcontinue;\n-\n-      /* Check if we can move the loads.  The def stmts of all virtual uses\n-\t need to be post-dominated by bb.  */\n-      FOR_EACH_SSA_TREE_OPERAND (vuse, use_stmt, ui2, SSA_OP_VUSE)\n-\t{\n-\t  tree def_stmt = SSA_NAME_DEF_STMT (vuse);\n-\t  if (!SSA_NAME_IS_DEFAULT_DEF (vuse)\n-\t      && (bb_for_stmt (def_stmt) == bb\n-\t\t  || !dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t      bb, bb_for_stmt (def_stmt))))\n-\t    goto next;\n-\t}\n-\n-      /* Found a proper dereference.  Insert a phi node if this\n-\t is the first load transformation.  */\n-      if (!phi_inserted)\n-\t{\n-\t  res = phiprop_insert_phi (bb, phi, use_stmt, phivn, n);\n-\n-\t  /* Remember the value we created for *ptr.  */\n-\t  phivn[SSA_NAME_VERSION (ptr)].value = res;\n-\t  phivn[SSA_NAME_VERSION (ptr)].vop_stmt = use_stmt;\n-\n-\t  /* Remove old stmt.  The phi is taken care of by DCE, if we\n-\t     want to delete it here we also have to delete all intermediate\n-\t     copies.  */\n-\t  bsi = bsi_for_stmt (use_stmt);\n-\t  bsi_remove (&bsi, 0);\n-\n-\t  phi_inserted = true;\n-\t}\n-      else\n-\t{\n-\t  /* Further replacements are easy, just make a copy out of the\n-\t     load.  */\n-\t  GIMPLE_STMT_OPERAND (use_stmt, 1) = res;\n-\t  update_stmt (use_stmt);\n-\t}\n-\n-next:;\n-      /* Continue searching for a proper dereference.  */\n-    }\n-\n-  return phi_inserted;\n-}\n-\n-/* Helper walking the dominator tree starting from BB and processing\n-   phi nodes with global data PHIVN and N.  */\n-\n-static bool\n-tree_ssa_phiprop_1 (basic_block bb, struct phiprop_d *phivn, size_t n)\n-{\n-  bool did_something = false; \n-  basic_block son;\n-  tree phi;\n-\n-  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-    did_something |= propagate_with_phi (bb, phi, phivn, n);\n-\n-  for (son = first_dom_son (CDI_DOMINATORS, bb);\n-       son;\n-       son = next_dom_son (CDI_DOMINATORS, son))\n-    did_something |= tree_ssa_phiprop_1 (son, phivn, n);\n-\n-  return did_something;\n-}\n-\n-/* Main entry for phiprop pass.  */\n-\n-static unsigned int\n-tree_ssa_phiprop (void)\n-{\n-  struct phiprop_d *phivn;\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n-  phivn = XCNEWVEC (struct phiprop_d, num_ssa_names);\n-\n-  if (tree_ssa_phiprop_1 (ENTRY_BLOCK_PTR, phivn, num_ssa_names))\n-    bsi_commit_edge_inserts ();\n-\n-  free (phivn);\n-\n-  return 0;\n-}\n-\n-static bool\n-gate_phiprop (void)\n-{\n-  return 1;\n-}\n-\n-struct tree_opt_pass pass_phiprop = {\n-  \"phiprop\",\t\t\t/* name */\n-  gate_phiprop,\t\t\t/* gate */\n-  tree_ssa_phiprop,\t\t/* execute */\n-  NULL,\t\t\t\t/* sub */\n-  NULL,\t\t\t\t/* next */\n-  0,\t\t\t\t/* static_pass_number */\n-  TV_TREE_FORWPROP,\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func\n-  | TODO_ggc_collect\n-  | TODO_update_ssa\n-  | TODO_verify_ssa,\t\t/* todo_flags_finish */\n-  0\t\t\t\t/* letter */\n-};"}, {"sha": "273ed2fa53b075afab8d7d36214049cd0025a982", "filename": "gcc/tree-ssa-phiprop.c", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675144497811ddea99d9e240e8793a4642c728f7/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675144497811ddea99d9e240e8793a4642c728f7/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=675144497811ddea99d9e240e8793a4642c728f7", "patch": "@@ -0,0 +1,388 @@\n+/* Backward propagation of indirect loads through PHIs.\n+   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Richard Guenther <rguenther@suse.de>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"basic-block.h\"\n+#include \"timevar.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-dump.h\"\n+#include \"langhooks.h\"\n+#include \"flags.h\"\n+\n+/* This pass propagates indirect loads through the PHI node for its\n+   address to make the load source possiby non-addressable and to\n+   allow for PHI optimization to trigger.\n+\n+   For example the pass changes\n+\n+     # addr_1 = PHI <&a, &b>\n+     tmp_1 = *addr_1;\n+\n+   to\n+\n+     # tmp_1 = PHI <a, b>\n+\n+   but also handles more complex cenarios like\n+\n+     D.2077_2 = &this_1(D)->a1;\n+     ...\n+\n+     # b_12 = PHI <&c(2), D.2077_2(3)>\n+     D.2114_13 = *b_12;\n+     ...\n+\n+     # b_15 = PHI <b_12(4), &b(5)>\n+     D.2080_5 = &this_1(D)->a0;\n+     ...\n+\n+     # b_18 = PHI <D.2080_5(6), &c(7)>\n+     ...\n+\n+     # b_21 = PHI <b_15(8), b_18(9)>\n+     D.2076_8 = *b_21;\n+\n+   where the addresses loaded are defined by PHIs itself.\n+   The above happens for\n+\n+     std::max(std::min(a0, c), std::min(std::max(a1, c), b))\n+\n+   where this pass transforms it to a form later PHI optimization\n+   recognizes and transforms it to the simple\n+\n+     D.2109_10 = this_1(D)->a1;\n+     D.2110_11 = c;\n+     D.2114_31 = MAX_EXPR <D.2109_10, D.2110_11>;\n+     D.2115_14 = b;\n+     D.2125_17 = MIN_EXPR <D.2115_14, D.2114_31>;\n+     D.2119_16 = this_1(D)->a0;\n+     D.2124_32 = MIN_EXPR <D.2110_11, D.2119_16>;\n+     D.2076_33 = MAX_EXPR <D.2125_17, D.2124_32>;\n+\n+   The pass does a dominator walk processing loads using a basic-block\n+   local analysis and stores the result for use by transformations on\n+   dominated basic-blocks.  */\n+\n+\n+/* Structure to keep track of the value of a dereferenced PHI result\n+   and the set of virtual operands used for that dereference.  */\n+\n+struct phiprop_d\n+{\n+  tree value;\n+  tree vop_stmt;\n+};\n+\n+/* Verify if the value recorded for NAME in PHIVN is still valid at\n+   the start of basic block BB.  */\n+\n+static bool\n+phivn_valid_p (struct phiprop_d *phivn, tree name, basic_block bb)\n+{\n+  tree vop_stmt = phivn[SSA_NAME_VERSION (name)].vop_stmt;\n+  ssa_op_iter ui;\n+  tree vuse;\n+\n+  /* The def stmts of all virtual uses need to be post-dominated\n+     by bb.  */\n+  FOR_EACH_SSA_TREE_OPERAND (vuse, vop_stmt, ui, SSA_OP_VUSE)\n+    {\n+      tree use_stmt;\n+      imm_use_iterator ui2;\n+      bool ok = true;\n+\n+      FOR_EACH_IMM_USE_STMT (use_stmt, ui2, vuse)\n+\t{\n+\t  /* If BB does not dominate a VDEF, the value is invalid.  */\n+\t  if (((TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+\t        && !ZERO_SSA_OPERANDS (use_stmt, SSA_OP_VDEF))\n+\t       || TREE_CODE (use_stmt) == PHI_NODE)\n+\t      && !dominated_by_p (CDI_DOMINATORS, bb_for_stmt (use_stmt), bb))\n+\t    {\n+\t      ok = false;\n+\t      BREAK_FROM_IMM_USE_STMT (ui2);\n+\t    }\n+\t}\n+      if (!ok)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Insert a new phi node for the dereference of PHI at basic_block\n+   BB with the virtual operands from USE_STMT.  */\n+\n+static tree\n+phiprop_insert_phi (basic_block bb, tree phi, tree use_stmt,\n+\t\t    struct phiprop_d *phivn, size_t n)\n+{\n+  tree res, new_phi;\n+  edge_iterator ei;\n+  edge e;\n+\n+  /* Build a new PHI node to replace the definition of\n+     the indirect reference lhs.  */\n+  res = GIMPLE_STMT_OPERAND (use_stmt, 0);\n+  SSA_NAME_DEF_STMT (res) = new_phi = create_phi_node (res, bb);\n+\n+  /* Add PHI arguments for each edge inserting loads of the\n+     addressable operands.  */\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      tree old_arg, new_var, tmp;\n+\n+      old_arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+      while (TREE_CODE (old_arg) == SSA_NAME\n+\t     && (SSA_NAME_VERSION (old_arg) >= n\n+\t         || phivn[SSA_NAME_VERSION (old_arg)].value == NULL_TREE))\n+\t{\n+\t  tree def_stmt = SSA_NAME_DEF_STMT (old_arg);\n+\t  old_arg = GIMPLE_STMT_OPERAND (def_stmt, 1);\n+\t}\n+\n+      if (TREE_CODE (old_arg) == SSA_NAME)\n+\t/* Reuse a formerly created dereference.  */\n+\tnew_var = phivn[SSA_NAME_VERSION (old_arg)].value;\n+      else\n+\t{\n+\t  old_arg = TREE_OPERAND (old_arg, 0);\n+\t  new_var = create_tmp_var (TREE_TYPE (old_arg), NULL);\n+\t  tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n+\t\t\tNULL_TREE, unshare_expr (old_arg));\n+\t  if (TREE_CODE (TREE_TYPE (old_arg)) == COMPLEX_TYPE\n+\t      || TREE_CODE (TREE_TYPE (old_arg)) == VECTOR_TYPE)\n+\t    DECL_GIMPLE_REG_P (new_var) = 1;\n+\t  add_referenced_var (new_var);\n+\t  new_var = make_ssa_name (new_var, tmp);\n+\t  GIMPLE_STMT_OPERAND (tmp, 0) = new_var;\n+\n+\t  bsi_insert_on_edge (e, tmp);\n+\n+\t  update_stmt (tmp);\n+\t  mark_symbols_for_renaming (tmp);\n+\t}\n+\n+      add_phi_arg (new_phi, new_var, e);\n+    }\n+\n+  update_stmt (new_phi);\n+\n+  return res;\n+}\n+\n+/* Propagate between the phi node arguments of PHI in BB and phi result\n+   users.  For now this matches\n+        # p_2 = PHI <&x, &y>\n+      <Lx>:;\n+\tp_3 = p_2;\n+\tz_2 = *p_3;\n+   and converts it to\n+\t# z_2 = PHI <x, y>\n+      <Lx>:;\n+   Returns true if a transformation was done and edge insertions\n+   need to be committed.  Global data PHIVN and N is used to track\n+   past transformation results.  We need to be especially careful here\n+   with aliasing issues as we are moving memory reads.  */\n+\n+static bool\n+propagate_with_phi (basic_block bb, tree phi, struct phiprop_d *phivn, size_t n)\n+{\n+  tree ptr = PHI_RESULT (phi);\n+  tree use_stmt, res = NULL_TREE;\n+  block_stmt_iterator bsi;\n+  imm_use_iterator ui;\n+  use_operand_p arg_p, use;\n+  ssa_op_iter i;\n+  bool phi_inserted;\n+\n+  if (MTAG_P (SSA_NAME_VAR (ptr))\n+      || !POINTER_TYPE_P (TREE_TYPE (ptr))\n+      || !is_gimple_reg_type (TREE_TYPE (TREE_TYPE (ptr))))\n+    return false;\n+\n+  /* Check if we can \"cheaply\" dereference all phi arguments.  */\n+  FOR_EACH_PHI_ARG (arg_p, phi, i, SSA_OP_USE)\n+    {\n+      tree arg = USE_FROM_PTR (arg_p);\n+      /* Walk the ssa chain until we reach a ssa name we already\n+\t created a value for or we reach a definition of the form\n+\t ssa_name_n = &var;  */\n+      while (TREE_CODE (arg) == SSA_NAME\n+\t     && !SSA_NAME_IS_DEFAULT_DEF (arg)\n+\t     && (SSA_NAME_VERSION (arg) >= n\n+\t         || phivn[SSA_NAME_VERSION (arg)].value == NULL_TREE))\n+\t{\n+\t  tree def_stmt = SSA_NAME_DEF_STMT (arg);\n+\t  if (TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT)\n+\t    return false;\n+\t  arg = GIMPLE_STMT_OPERAND (def_stmt, 1);\n+\t}\n+      if ((TREE_CODE (arg) != ADDR_EXPR\n+\t   /* Avoid to have to decay *&a to a[0] later.  */\n+\t   || !is_gimple_reg_type (TREE_TYPE (TREE_OPERAND (arg, 0))))\n+\t  && !(TREE_CODE (arg) == SSA_NAME\n+\t       && phivn[SSA_NAME_VERSION (arg)].value != NULL_TREE\n+\t       && phivn_valid_p (phivn, arg, bb)))\n+\treturn false;\n+    }\n+\n+  /* Find a dereferencing use.  First follow (single use) ssa\n+     copy chains for ptr.  */\n+  while (single_imm_use (ptr, &use, &use_stmt)\n+\t && TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+\t && GIMPLE_STMT_OPERAND (use_stmt, 1) == ptr\n+\t && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 0)) == SSA_NAME)\n+    ptr = GIMPLE_STMT_OPERAND (use_stmt, 0);\n+\n+  /* Replace the first dereference of *ptr if there is one and if we\n+     can move the loads to the place of the ptr phi node.  */\n+  phi_inserted = false;\n+  FOR_EACH_IMM_USE_STMT (use_stmt, ui, ptr)\n+    {\n+      ssa_op_iter ui2;\n+      tree vuse;\n+\n+      /* Check whether this is a load of *ptr.  */\n+      if (!(TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+\t    && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 0)) == SSA_NAME \n+\t    && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == INDIRECT_REF\n+\t    && TREE_OPERAND (GIMPLE_STMT_OPERAND (use_stmt, 1), 0) == ptr\n+\t    /* We cannot replace a load that may throw or is volatile.  */\n+\t    && !tree_can_throw_internal (use_stmt)))\n+\tcontinue;\n+\n+      /* Check if we can move the loads.  The def stmts of all virtual uses\n+\t need to be post-dominated by bb.  */\n+      FOR_EACH_SSA_TREE_OPERAND (vuse, use_stmt, ui2, SSA_OP_VUSE)\n+\t{\n+\t  tree def_stmt = SSA_NAME_DEF_STMT (vuse);\n+\t  if (!SSA_NAME_IS_DEFAULT_DEF (vuse)\n+\t      && (bb_for_stmt (def_stmt) == bb\n+\t\t  || !dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t      bb, bb_for_stmt (def_stmt))))\n+\t    goto next;\n+\t}\n+\n+      /* Found a proper dereference.  Insert a phi node if this\n+\t is the first load transformation.  */\n+      if (!phi_inserted)\n+\t{\n+\t  res = phiprop_insert_phi (bb, phi, use_stmt, phivn, n);\n+\n+\t  /* Remember the value we created for *ptr.  */\n+\t  phivn[SSA_NAME_VERSION (ptr)].value = res;\n+\t  phivn[SSA_NAME_VERSION (ptr)].vop_stmt = use_stmt;\n+\n+\t  /* Remove old stmt.  The phi is taken care of by DCE, if we\n+\t     want to delete it here we also have to delete all intermediate\n+\t     copies.  */\n+\t  bsi = bsi_for_stmt (use_stmt);\n+\t  bsi_remove (&bsi, 0);\n+\n+\t  phi_inserted = true;\n+\t}\n+      else\n+\t{\n+\t  /* Further replacements are easy, just make a copy out of the\n+\t     load.  */\n+\t  GIMPLE_STMT_OPERAND (use_stmt, 1) = res;\n+\t  update_stmt (use_stmt);\n+\t}\n+\n+next:;\n+      /* Continue searching for a proper dereference.  */\n+    }\n+\n+  return phi_inserted;\n+}\n+\n+/* Helper walking the dominator tree starting from BB and processing\n+   phi nodes with global data PHIVN and N.  */\n+\n+static bool\n+tree_ssa_phiprop_1 (basic_block bb, struct phiprop_d *phivn, size_t n)\n+{\n+  bool did_something = false; \n+  basic_block son;\n+  tree phi;\n+\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    did_something |= propagate_with_phi (bb, phi, phivn, n);\n+\n+  for (son = first_dom_son (CDI_DOMINATORS, bb);\n+       son;\n+       son = next_dom_son (CDI_DOMINATORS, son))\n+    did_something |= tree_ssa_phiprop_1 (son, phivn, n);\n+\n+  return did_something;\n+}\n+\n+/* Main entry for phiprop pass.  */\n+\n+static unsigned int\n+tree_ssa_phiprop (void)\n+{\n+  struct phiprop_d *phivn;\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  phivn = XCNEWVEC (struct phiprop_d, num_ssa_names);\n+\n+  if (tree_ssa_phiprop_1 (ENTRY_BLOCK_PTR, phivn, num_ssa_names))\n+    bsi_commit_edge_inserts ();\n+\n+  free (phivn);\n+\n+  return 0;\n+}\n+\n+static bool\n+gate_phiprop (void)\n+{\n+  return 1;\n+}\n+\n+struct tree_opt_pass pass_phiprop = {\n+  \"phiprop\",\t\t\t/* name */\n+  gate_phiprop,\t\t\t/* gate */\n+  tree_ssa_phiprop,\t\t/* execute */\n+  NULL,\t\t\t\t/* sub */\n+  NULL,\t\t\t\t/* next */\n+  0,\t\t\t\t/* static_pass_number */\n+  TV_TREE_PHIPROP,\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func\n+  | TODO_ggc_collect\n+  | TODO_update_ssa\n+  | TODO_verify_ssa,\t\t/* todo_flags_finish */\n+  0\t\t\t\t/* letter */\n+};"}]}