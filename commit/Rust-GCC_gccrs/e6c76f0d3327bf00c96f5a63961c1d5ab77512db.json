{"sha": "e6c76f0d3327bf00c96f5a63961c1d5ab77512db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZjNzZmMGQzMzI3YmYwMGM5NmY1YTYzOTYxYzFkNWFiNzc1MTJkYg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-08-19T13:12:55Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-08-19T13:12:55Z"}, "message": "libstdc++: integer-class types as per [iterator.concept.winc]\n\nThis implements signed and unsigned integer-class types, whose width is\none bit larger than the widest supported signed and unsigned integral\ntype respectively.  In our case this is either __int128 and unsigned\n__int128, or long long and unsigned long long.\n\nInternally, the two integer-class types are represented as a largest\nsupported unsigned integral type plus one extra bit.  The signed\ninteger-class type is represented in two's complement form with the\nextra bit acting as the sign bit.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am (bits_headers): Add new header\n\t<bits/max_size_type.h>.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/iterator_concepts.h\n\t(ranges::__detail::__max_diff_type): Remove definition, replace\n\twith forward declaration of class __max_diff_type.\n\t(__detail::__max_size_type): Remove definition, replace with\n\tforward declaration of class __max_size_type.\n\t(__detail::__is_unsigned_int128, __is_signed_int128)\n\t(__is_int128): New concepts.\n\t(__detail::__is_integer_like): Accept __int128 and unsigned\n\t__int128.\n\t(__detail::__is_signed_integer_like): Accept __int128.\n\t* include/bits/max_size_type.h: New header.\n\t* include/bits/range_access.h: Include <bits/max_size_type.h>.\n\t(__detail::__to_unsigned_like): Two new overloads.\n\t* testsuite/std/ranges/iota/difference_type.cc: New test.\n\t* testsuite/std/ranges/iota/max_size_type.cc: New test.", "tree": {"sha": "d91a89b40462a25485f34df68cbb15c424feca24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d91a89b40462a25485f34df68cbb15c424feca24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6c76f0d3327bf00c96f5a63961c1d5ab77512db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6c76f0d3327bf00c96f5a63961c1d5ab77512db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6c76f0d3327bf00c96f5a63961c1d5ab77512db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/comments", "author": null, "committer": null, "parents": [{"sha": "708b3600d043e5885ed25464189a88590feeaac9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/708b3600d043e5885ed25464189a88590feeaac9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/708b3600d043e5885ed25464189a88590feeaac9"}], "stats": {"total": 1223, "additions": 1219, "deletions": 4}, "files": [{"sha": "1dff3862e35e351dfc08f9c62855d2a8d917baaf", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=e6c76f0d3327bf00c96f5a63961c1d5ab77512db", "patch": "@@ -143,6 +143,7 @@ bits_headers = \\\n \t${bits_srcdir}/locale_facets_nonio.tcc \\\n \t${bits_srcdir}/localefwd.h \\\n \t${bits_srcdir}/mask_array.h \\\n+\t${bits_srcdir}/max_size_type.h \\\n \t${bits_srcdir}/memoryfwd.h \\\n \t${bits_srcdir}/move.h \\\n \t${bits_srcdir}/node_handle.h \\"}, {"sha": "1637101507129022717c0cfeab5c2efe26bf0be9", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=e6c76f0d3327bf00c96f5a63961c1d5ab77512db", "patch": "@@ -489,6 +489,7 @@ bits_headers = \\\n \t${bits_srcdir}/locale_facets_nonio.tcc \\\n \t${bits_srcdir}/localefwd.h \\\n \t${bits_srcdir}/mask_array.h \\\n+\t${bits_srcdir}/max_size_type.h \\\n \t${bits_srcdir}/memoryfwd.h \\\n \t${bits_srcdir}/move.h \\\n \t${bits_srcdir}/node_handle.h \\"}, {"sha": "5033f2bddc396fbb7c0a4417ccec7b2c2a9173ce", "filename": "libstdc++-v3/include/bits/iterator_concepts.h", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h?ref=e6c76f0d3327bf00c96f5a63961c1d5ab77512db", "patch": "@@ -511,12 +511,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   namespace ranges::__detail\n   {\n+    class __max_diff_type;\n+    class __max_size_type;\n+\n+    template<typename _Tp>\n+      concept __is_signed_int128\n #if __SIZEOF_INT128__\n-    using __max_diff_type = __int128;\n-    using __max_size_type = unsigned __int128;\n+\t= same_as<_Tp, __int128>;\n #else\n-    using __max_diff_type = long long;\n-    using __max_size_type = unsigned long long;\n+\t= false;\n+#endif\n+\n+    template<typename _Tp>\n+      concept __is_unsigned_int128\n+#if __SIZEOF_INT128__\n+\t= same_as<_Tp, unsigned __int128>;\n+#else\n+\t= false;\n #endif\n \n     template<typename _Tp>\n@@ -525,12 +536,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     template<typename _Tp>\n       concept __integral_nonbool = integral<_Tp> && !__cv_bool<_Tp>;\n \n+    template<typename _Tp>\n+      concept __is_int128 = __is_signed_int128<_Tp> || __is_unsigned_int128<_Tp>;\n+\n     template<typename _Tp>\n       concept __is_integer_like = __integral_nonbool<_Tp>\n+\t|| __is_int128<_Tp>\n \t|| same_as<_Tp, __max_diff_type> || same_as<_Tp, __max_size_type>;\n \n     template<typename _Tp>\n       concept __is_signed_integer_like = signed_integral<_Tp>\n+\t|| __is_signed_int128<_Tp>\n \t|| same_as<_Tp, __max_diff_type>;\n \n   } // namespace ranges::__detail"}, {"sha": "8e616626c808e711df1e9d2a50f720388d4f0e24", "filename": "libstdc++-v3/include/bits/max_size_type.h", "status": "added", "additions": 753, "deletions": 0, "changes": 753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmax_size_type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmax_size_type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmax_size_type.h?ref=e6c76f0d3327bf00c96f5a63961c1d5ab77512db", "patch": "@@ -0,0 +1,753 @@\n+// <max_size_type.h> -*- C++ -*-\n+\n+// Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/max_size_type.h.\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{iterator}\n+ */\n+\n+#ifndef _GLIBCXX_MAX_SIZE_TYPE_H\n+#define _GLIBCXX_MAX_SIZE_TYPE_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+#include <ext/numeric_traits.h>\n+#include <numbers>\n+\n+// This header implements unsigned and signed integer-class types (as per\n+// [iterator.concept.winc]) that are one bit wider than the widest supported\n+// integer type.\n+//\n+// The set of integer types we consider includes __int128 and unsigned __int128\n+// (when they exist), even though they are really integer types only in GNU\n+// mode.  This is to obtain a consistent ABI for these integer-class types\n+// across strict mode and GNU mode.\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+template<typename _Tp>\n+  struct numeric_limits;\n+\n+namespace ranges\n+{\n+  namespace __detail\n+  {\n+    class __max_size_type\n+    {\n+    public:\n+      __max_size_type() = default;\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tconstexpr\n+\t__max_size_type(_Tp __i) noexcept\n+\t  : _M_val(__i), _M_msb(__i < 0)\n+\t{ }\n+\n+      constexpr explicit\n+      __max_size_type(const __max_diff_type& __d) noexcept;\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tconstexpr explicit operator _Tp() const noexcept\n+\t{ return _M_val; }\n+\n+      constexpr explicit\n+      operator bool() const noexcept\n+      { return _M_val != 0 || _M_msb != 0; }\n+\n+      constexpr __max_size_type\n+      operator+() const noexcept\n+      { return *this; }\n+\n+      constexpr __max_size_type\n+      operator~() const noexcept\n+      { return __max_size_type{~_M_val, !_M_msb}; }\n+\n+      constexpr __max_size_type\n+      operator-() const noexcept\n+      { return operator~() + 1; }\n+\n+      constexpr __max_size_type&\n+      operator+=(const __max_size_type& __r) noexcept\n+      {\n+\tconst auto __sum = _M_val + __r._M_val;\n+\tconst bool __overflow = (__sum < _M_val);\n+\t_M_msb = _M_msb ^ __r._M_msb ^ __overflow;\n+\t_M_val = __sum;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator-=(const __max_size_type& __r) noexcept\n+      { return *this += -__r; }\n+\n+      constexpr __max_size_type&\n+      operator*=(__max_size_type __r) noexcept\n+      {\n+\tconstexpr __max_size_type __threshold\n+\t  = __rep(1) << (_S_rep_bits / 2 - 1);\n+\tif (_M_val < __threshold && __r < __threshold)\n+\t  // When both operands are below this threshold then the\n+\t  // multiplication can be safely computed in the base precision.\n+\t  _M_val = _M_val * __r._M_val;\n+\telse\n+\t  {\n+\t    // Otherwise, perform the multiplication in four steps, by\n+\t    // decomposing the LHS and the RHS into 2*x+a and 2*y+b,\n+\t    // respectively, and computing 4*x*y + 2*x*b + 2*y*a + a*b.\n+\t    const bool __lsb = _M_val & 1;\n+\t    const bool __rlsb = __r._M_val & 1;\n+\t    *this >>= 1;\n+\t    __r >>= 1;\n+\t    _M_val = (2 * _M_val * __r._M_val\n+\t\t      + _M_val * __rlsb + __r._M_val * __lsb);\n+\t    *this <<= 1;\n+\t    *this += __rlsb * __lsb;\n+\t  }\n+\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator/=(const __max_size_type& __r) noexcept\n+      {\n+\t__glibcxx_assert(__r != 0);\n+\n+\tif (!_M_msb && !__r._M_msb) [[likely]]\n+\t  _M_val /= __r._M_val;\n+\telse if (_M_msb && __r._M_msb)\n+\t  {\n+\t    _M_val = (_M_val >= __r._M_val);\n+\t    _M_msb = 0;\n+\t  }\n+\telse if (!_M_msb && __r._M_msb)\n+\t  _M_val = 0;\n+\telse if (_M_msb && !__r._M_msb)\n+\t  {\n+\t    // The non-trivial case: the dividend has its MSB set and the\n+\t    // divisor doesn't.  In this case we compute ((LHS/2)/RHS)*2\n+\t    // in the base precision.  This quantity is either the true\n+\t    // quotient or one less than the true quotient.\n+\t    const auto __orig = *this;\n+\t    *this >>= 1;\n+\t    _M_val /= __r._M_val;\n+\t    *this <<= 1;\n+\t    if (__orig - *this * __r >= __r)\n+\t      ++_M_val;\n+\t  }\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator%=(const __max_size_type& __r) noexcept\n+      {\n+\tif (!_M_msb && !__r._M_msb) [[likely]]\n+\t  _M_val %= __r._M_val;\n+\telse\n+\t  *this -= (*this / __r) * __r;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator<<=(const __max_size_type& __r) noexcept\n+      {\n+\t__glibcxx_assert(__r <= _S_rep_bits);\n+\tif (__r != 0)\n+\t  {\n+\t    _M_msb = (_M_val >> (_S_rep_bits - __r._M_val)) & 1;\n+\n+\t    if (__r._M_val == _S_rep_bits) [[unlikely]]\n+\t      _M_val = 0;\n+\t    else\n+\t      _M_val <<= __r._M_val;\n+\t  }\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator>>=(const __max_size_type& __r) noexcept\n+      {\n+\t__glibcxx_assert(__r <= _S_rep_bits);\n+\tif (__r != 0)\n+\t  {\n+\t    if (__r._M_val == _S_rep_bits) [[unlikely]]\n+\t      _M_val = 0;\n+\t    else\n+\t      _M_val >>= __r._M_val;\n+\n+\t    if (_M_msb) [[unlikely]]\n+\t      {\n+\t\t_M_val |= __rep(1) << (_S_rep_bits - __r._M_val);\n+\t\t_M_msb = 0;\n+\t      }\n+\t  }\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator&=(const __max_size_type& __r) noexcept\n+      {\n+\t_M_val &= __r._M_val;\n+\t_M_msb &= __r._M_msb;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator|=(const __max_size_type& __r) noexcept\n+      {\n+\t_M_val |= __r._M_val;\n+\t_M_msb |= __r._M_msb;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_size_type&\n+      operator^=(const __max_size_type& __r) noexcept\n+      {\n+\t_M_val ^= __r._M_val;\n+\t_M_msb ^= __r._M_msb;\n+\treturn *this;\n+      }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator+=(_Tp& __a, const __max_size_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a + __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator-=(_Tp& __a, const __max_size_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a - __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator*=(_Tp& __a, const __max_size_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a * __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator/=(_Tp& __a, const __max_size_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a / __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator%=(_Tp& __a, const __max_size_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a % __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator&=(_Tp& __a, const __max_size_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a & __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator|=(_Tp& __a, const __max_size_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a | __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator^=(_Tp& __a, const __max_size_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a ^ __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator<<=(_Tp& __a, const __max_size_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a << __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator>>=(_Tp& __a, const __max_size_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a >> __b)); }\n+\n+      friend constexpr __max_size_type\n+      operator+(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l += __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator-(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l -= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator*(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l *= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator/(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l /= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator%(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l %= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator<<(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l <<= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator>>(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l >>= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator&(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l &= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator|(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l |= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_size_type\n+      operator^(__max_size_type __l, const __max_size_type& __r) noexcept\n+      {\n+\t__l ^= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr bool\n+      operator==(const __max_size_type& __l, const __max_size_type& __r) noexcept\n+      { return __l._M_val == __r._M_val && __l._M_msb == __r._M_msb; }\n+\n+      friend constexpr bool\n+      operator!=(const __max_size_type& __l, const __max_size_type& __r) noexcept\n+      { return !(__l == __r); }\n+\n+      friend constexpr bool\n+      operator<(const __max_size_type& __l, const __max_size_type& __r) noexcept\n+      {\n+\tif (__l._M_msb == __r._M_msb)\n+\t  return __l._M_val < __r._M_val;\n+\telse\n+\t  return __r._M_msb;\n+      }\n+\n+      friend constexpr bool\n+      operator>(const __max_size_type& __l, const __max_size_type& __r) noexcept\n+      { return __r < __l; }\n+\n+      friend constexpr bool\n+      operator<=(const __max_size_type& __l, const __max_size_type& __r) noexcept\n+      { return !(__l > __r); }\n+\n+      friend constexpr bool\n+      operator>=(const __max_size_type& __l, const __max_size_type& __r) noexcept\n+      { return __r <= __l; }\n+\n+#if __SIZEOF_INT128__\n+      using __rep = unsigned __int128;\n+#else\n+      using __rep = unsigned long long;\n+#endif\n+      static constexpr size_t _S_rep_bits = sizeof(__rep) * __CHAR_BIT__;\n+    private:\n+      __rep _M_val = 0;\n+      unsigned _M_msb:1 = 0;\n+\n+      constexpr explicit\n+      __max_size_type(__rep __val, int __msb) noexcept\n+\t: _M_val(__val), _M_msb(__msb)\n+      { }\n+\n+      friend __max_diff_type;\n+      friend std::numeric_limits<__max_size_type>;\n+      friend std::numeric_limits<__max_diff_type>;\n+    };\n+\n+    class __max_diff_type\n+    {\n+    public:\n+      __max_diff_type() = default;\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tconstexpr\n+\t__max_diff_type(_Tp __i) noexcept\n+\t  : _M_rep(__i)\n+\t{ }\n+\n+      constexpr explicit\n+      __max_diff_type(const __max_size_type& __d) noexcept\n+\t: _M_rep(__d)\n+      { }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tconstexpr explicit operator _Tp() const noexcept\n+\t{ return static_cast<_Tp>(_M_rep); }\n+\n+      constexpr explicit\n+      operator bool() const noexcept\n+      { return _M_rep != 0; }\n+\n+      constexpr __max_diff_type\n+      operator+() const noexcept\n+      { return *this; }\n+\n+      constexpr __max_diff_type\n+      operator-() const noexcept\n+      { return __max_diff_type(-_M_rep); }\n+\n+      constexpr __max_diff_type\n+      operator~() const noexcept\n+      { return __max_diff_type(~_M_rep); }\n+\n+      constexpr __max_diff_type&\n+      operator+=(const __max_diff_type& __r) noexcept\n+      {\n+\t_M_rep += __r._M_rep;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator-=(const __max_diff_type& __r) noexcept\n+      {\n+\t_M_rep -= __r._M_rep;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator*=(const __max_diff_type& __r) noexcept\n+      {\n+\t_M_rep *= __r._M_rep;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator/=(const __max_diff_type& __r) noexcept\n+      {\n+\t__glibcxx_assert (__r != 0);\n+\tconst bool __neg = *this < 0;\n+\tconst bool __rneg = __r < 0;\n+\tif (!__neg && !__rneg)\n+\t  _M_rep = _M_rep / __r._M_rep;\n+\telse if (__neg && __rneg)\n+\t  _M_rep = -_M_rep / -__r._M_rep;\n+\telse if (__neg && !__rneg)\n+\t  _M_rep = -(-_M_rep / __r._M_rep);\n+\telse\n+\t  _M_rep = -(_M_rep / -__r._M_rep);\n+\treturn *this ;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator%=(const __max_diff_type& __r) noexcept\n+      {\n+\t__glibcxx_assert (__r != 0);\n+\tif (*this >= 0 && __r > 0)\n+\t  _M_rep %= __r._M_rep;\n+\telse\n+\t  *this -= (*this / __r) * __r;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator<<=(const __max_diff_type& __r) noexcept\n+      {\n+\t_M_rep.operator<<=(__r._M_rep);\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator>>=(const __max_diff_type& __r) noexcept\n+      {\n+\t// Arithmetic right shift.\n+\tconst auto __msb = _M_rep._M_msb;\n+\t_M_rep >>= __r._M_rep;\n+\t_M_rep._M_msb |= __msb;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator&=(const __max_diff_type& __r) noexcept\n+      {\n+\t_M_rep &= __r._M_rep;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator|=(const __max_diff_type& __r) noexcept\n+      {\n+\t_M_rep |= __r._M_rep;\n+\treturn *this;\n+      }\n+\n+      constexpr __max_diff_type&\n+      operator^=(const __max_diff_type& __r) noexcept\n+      {\n+\t_M_rep ^= __r._M_rep;\n+\treturn *this;\n+      }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator+=(_Tp& __a, const __max_diff_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a + __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator-=(_Tp& __a, const __max_diff_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a - __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator*=(_Tp& __a, const __max_diff_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a * __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator/=(_Tp& __a, const __max_diff_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a / __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator%=(_Tp& __a, const __max_diff_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a % __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator&=(_Tp& __a, const __max_diff_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a & __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator|=(_Tp& __a, const __max_diff_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a | __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator^=(_Tp& __a, const __max_diff_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a ^ __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator<<=(_Tp& __a, const __max_diff_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a << __b)); }\n+\n+      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>\n+\tfriend constexpr _Tp&\n+\toperator>>=(_Tp& __a, const __max_diff_type& __b) noexcept\n+\t{ return (__a = static_cast<_Tp>(__a >> __b)); }\n+\n+      friend constexpr __max_diff_type\n+      operator+(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l += __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator-(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l -= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator*(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l *= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator/(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l /= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator%(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l %= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator<<(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l <<= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator>>(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l >>= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator&(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l &= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator|(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l |= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr __max_diff_type\n+      operator^(__max_diff_type __l, const __max_diff_type& __r) noexcept\n+      {\n+\t__l ^= __r;\n+\treturn __l;\n+      }\n+\n+      friend constexpr bool\n+      operator==(const __max_diff_type& __l, const __max_diff_type& __r) noexcept\n+      { return __l._M_rep == __r._M_rep; }\n+\n+      friend constexpr bool\n+      operator!=(const __max_diff_type& __l, const __max_diff_type& __r) noexcept\n+      { return !(__l == __r); }\n+\n+      constexpr bool\n+      operator<(const __max_diff_type& __r) const noexcept\n+      {\n+\tconst auto __lsign = _M_rep._M_msb;\n+\tconst auto __rsign = __r._M_rep._M_msb;\n+\tif (__lsign ^ __rsign)\n+\t  return __lsign;\n+\telse\n+\t  return _M_rep < __r._M_rep;\n+      }\n+\n+      friend constexpr bool\n+      operator>(const __max_diff_type& __l, const __max_diff_type& __r) noexcept\n+      { return __r < __l; }\n+\n+      friend constexpr bool\n+      operator<=(const __max_diff_type& __l, const __max_diff_type& __r) noexcept\n+      { return !(__r < __l); }\n+\n+      friend constexpr bool\n+      operator>=(const __max_diff_type& __l, const __max_diff_type& __r) noexcept\n+      { return !(__l < __r); }\n+\n+    private:\n+      __max_size_type _M_rep = 0;\n+\n+      friend class __max_size_type;\n+    };\n+\n+    constexpr\n+    __max_size_type::__max_size_type(const __max_diff_type& __d) noexcept\n+      : __max_size_type(__d._M_rep)\n+    { }\n+\n+  } // namespace __detail\n+} // namespace ranges\n+\n+  template<>\n+    struct numeric_limits<ranges::__detail::__max_size_type>\n+    {\n+      using _Sp = ranges::__detail::__max_size_type;\n+      static constexpr bool is_specialized = true;\n+      static constexpr bool is_signed = false;\n+      static constexpr bool is_integer = true;\n+      static constexpr bool is_exact = true;\n+#if __SIZEOF_INT128__\n+      static_assert(same_as<_Sp::__rep, unsigned __int128>);\n+      static constexpr int digits = 129;\n+#else\n+      static_assert(same_as<_Sp::__rep, unsigned long long>);\n+      static constexpr int digits\n+\t= __gnu_cxx::__int_traits<unsigned long long>::__digits + 1;\n+#endif\n+      static constexpr int digits10\n+\t= static_cast<int>(digits * numbers::ln2 / numbers::ln10);\n+\n+      static constexpr _Sp\n+      min() noexcept\n+      { return 0; }\n+\n+      static constexpr _Sp\n+      max() noexcept\n+      { return _Sp(static_cast<_Sp::__rep>(-1), 1); }\n+\n+      static constexpr _Sp\n+      lowest() noexcept\n+      { return min(); }\n+    };\n+\n+  template<>\n+    struct numeric_limits<ranges::__detail::__max_diff_type>\n+    {\n+      using _Dp = ranges::__detail::__max_diff_type;\n+      using _Sp = ranges::__detail::__max_size_type;\n+      static constexpr bool is_specialized = true;\n+      static constexpr bool is_signed = true;\n+      static constexpr bool is_integer = true;\n+      static constexpr bool is_exact = true;\n+      static constexpr int digits = numeric_limits<_Sp>::digits - 1;\n+      static constexpr int digits10\n+\t= static_cast<int>(digits * numbers::ln2 / numbers::ln10);\n+\n+      static constexpr _Dp\n+      min() noexcept\n+      { return _Dp(_Sp(0, 1)); }\n+\n+      static constexpr _Dp\n+      max() noexcept\n+      { return _Dp(_Sp(static_cast<_Sp::__rep>(-1), 0)); }\n+\n+      static constexpr _Dp\n+      lowest() noexcept\n+      { return min(); }\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+\n+#endif // C++20 && library concepts\n+#endif // _GLIBCXX_MAX_SIZE_TYPE_H"}, {"sha": "3eb1f2fd272c8a512acefa54e332921a9986751a", "filename": "libstdc++-v3/include/bits/range_access.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h?ref=e6c76f0d3327bf00c96f5a63961c1d5ab77512db", "patch": "@@ -36,6 +36,9 @@\n #include <initializer_list>\n #include <bits/iterator_concepts.h>\n #include <ext/numeric_traits.h>\n+#if __cplusplus > 201703L\n+#include <bits/max_size_type.h>\n+#endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -352,6 +355,14 @@ namespace ranges\n \n   namespace __detail\n   {\n+    constexpr __max_size_type\n+    __to_unsigned_like(__max_size_type __t) noexcept\n+    { return __t; }\n+\n+    constexpr __max_size_type\n+    __to_unsigned_like(__max_diff_type __t) noexcept\n+    { return __max_size_type(__t); }\n+\n     template<integral _Tp>\n       constexpr make_unsigned_t<_Tp>\n       __to_unsigned_like(_Tp __t) noexcept"}, {"sha": "6eb1a1676f7da885c6f5738195fab413a4d8e66c", "filename": "libstdc++-v3/testsuite/std/ranges/iota/difference_type.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fiota%2Fdifference_type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fiota%2Fdifference_type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fiota%2Fdifference_type.cc?ref=e6c76f0d3327bf00c96f5a63961c1d5ab77512db", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using I = unsigned long long;\n+  auto imax = std::numeric_limits<I>::max();\n+  std::ranges::iota_view<I, I> i(0, imax);\n+  auto begin = i.begin();\n+  static_assert( std::input_or_output_iterator<decltype(begin)> );\n+  auto size = std::ranges::end(i) - std::ranges::begin(i);\n+  VERIFY( size > 0 );\n+  VERIFY( size == imax );\n+}\n+\n+void\n+test02()\n+{\n+#if !defined(__STRICT_ANSI__) && __SIZEOF_INT128__\n+  using I = unsigned __int128;\n+  auto imax = std::numeric_limits<I>::max();\n+  std::ranges::iota_view<I, I> i(0, imax);\n+  auto begin = i.begin();\n+  static_assert( std::input_or_output_iterator<decltype(begin)> );\n+  auto size = std::ranges::end(i) - std::ranges::begin(i);\n+  VERIFY( size > 0 );\n+  VERIFY( size == imax );\n+#endif\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "cb9444074fc82a3030e8d920c1645e19ea72defa", "filename": "libstdc++-v3/testsuite/std/ranges/iota/max_size_type.cc", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fiota%2Fmax_size_type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c76f0d3327bf00c96f5a63961c1d5ab77512db/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fiota%2Fmax_size_type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fiota%2Fmax_size_type.cc?ref=e6c76f0d3327bf00c96f5a63961c1d5ab77512db", "patch": "@@ -0,0 +1,376 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <limits>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+\n+using max_size_t = std::ranges::__detail::__max_size_type;\n+using max_diff_t = std::ranges::__detail::__max_diff_type;\n+using rep_t = max_size_t::__rep;\n+\n+static_assert(sizeof(max_size_t) == sizeof(max_diff_t));\n+\n+static_assert(std::regular<max_size_t>);\n+static_assert(std::totally_ordered<max_size_t>);\n+\n+static_assert(std::regular<max_diff_t>);\n+static_assert(std::totally_ordered<max_diff_t>);\n+\n+// We can't use numeric_limits<rep_t>::max() here because __int128 is an\n+// integral type only in GNU mode.\n+constexpr max_size_t mu = max_size_t(~rep_t(0));\n+constexpr max_size_t ou = 1;\n+constexpr max_diff_t ns = -1;\n+\n+void\n+test01()\n+{\n+  static_assert(max_size_t(7) % 3 == 1);\n+  static_assert(max_size_t(7) % 4 == 3);\n+\n+  static_assert(-max_diff_t(1) == max_diff_t(-1));\n+  static_assert(max_diff_t(3) % 2 == 1);\n+  static_assert(max_diff_t(-3) / 2 == -1);\n+  static_assert(max_diff_t(-3) % 2 == -1);\n+  static_assert(max_diff_t(3) % -2 == 1);\n+  static_assert(max_diff_t(-3) << 1 == -6);\n+  static_assert(max_diff_t(-3) >> 1 == -2);\n+  static_assert(max_diff_t(3) >> 1 == 1);\n+  static_assert(max_diff_t(3) >> 2 == 0);\n+\n+  static_assert(max_diff_t(-5) / 3 == -1);\n+  static_assert(max_diff_t(5) / -3 == -1);\n+  static_assert(max_diff_t(-5) / -3 == 1);\n+  static_assert(max_diff_t(5) / 3 == 1);\n+\n+  static_assert(max_diff_t(-6) / 3 == -2);\n+  static_assert(max_diff_t(6) / -3 == -2);\n+  static_assert(max_diff_t(-6) / -3 == 2);\n+  static_assert(max_diff_t(6) / 3 == 2);\n+\n+  static_assert(~max_size_t(-3) == 2);\n+  static_assert(~max_diff_t(-3) == 2);\n+\n+  static_assert(max_diff_t(1) < max_diff_t(3));\n+  static_assert(max_diff_t(-1) < max_diff_t(3));\n+  static_assert(max_diff_t(1) > max_diff_t(-3));\n+  static_assert(max_diff_t(-1) > max_diff_t(-3));\n+\n+  static_assert(max_diff_t(mu)/-1 == -max_diff_t(mu));\n+  static_assert(-max_diff_t(mu)/1 == -max_diff_t(mu));\n+  static_assert(max_diff_t(mu)>>1 == max_diff_t(mu)/2);\n+  static_assert(-max_diff_t(mu+1) == max_diff_t(mu+1));\n+  static_assert(-(mu+1) == mu+1);\n+  static_assert((mu+1)<<1 == 0);\n+  static_assert(max_diff_t(mu+1)<<1 == 0);\n+  static_assert(max_diff_t(mu+1)>>1 < 0);\n+\n+  static_assert(int(max_diff_t(mu+1)) == 0);\n+  static_assert(rep_t(max_diff_t(mu+1)) == 0);\n+  static_assert(int(max_diff_t(mu)) == -1);\n+  static_assert(rep_t(max_diff_t(mu)) == rep_t(-1));\n+\n+  static_assert(2*mu+1 > 2*mu);\n+  static_assert(~(2*mu+1) == 0);\n+  static_assert(mu/mu == 1);\n+  static_assert(2*mu > mu);\n+  static_assert(2*mu-mu == mu);\n+  static_assert((2*mu)/mu == 2);\n+  static_assert((2*mu+1)/mu == 2);\n+  static_assert((2*mu-1)/(mu-1) == 2);\n+  static_assert((2*mu-1)/mu == 1);\n+  static_assert((2*mu+-1)/mu == 1);\n+  static_assert(2*mu-1 < 2*mu);\n+  static_assert(2*mu-1 <= 2*mu);\n+  static_assert(2*mu+1 > 2*mu);\n+  static_assert(2*mu+1 >= 2*mu);\n+  static_assert((2*mu)/1 == 2*mu);\n+  static_assert(mu/mu-1 == 0);\n+  static_assert(mu*0 == 0);\n+  static_assert((2*mu-1)*0 == 0);\n+  static_assert((2*mu-1)>>1 == mu-1);\n+  static_assert(mu+-1+1 == mu);\n+  static_assert(mu+1+-1 == mu);\n+  static_assert(mu+1);\n+  static_assert((2*mu)/2 == mu);\n+  static_assert((2*mu)>>1 == mu);\n+  static_assert((mu<<1)>>1 == mu);\n+  static_assert(1/mu == 0);\n+  static_assert(mu/1 == mu);\n+  static_assert(((mu+1)|mu) == -1);\n+  static_assert((mu+1)+(mu+1) < mu+1);\n+\n+  static_assert(max_size_t(ns) == -1);\n+  static_assert(-max_diff_t(ou) == -1);\n+  static_assert(-max_diff_t(-ou) == 1);\n+  static_assert(max_size_t(-max_diff_t(-ou)) == 1);\n+  static_assert(ns*ns == max_diff_t(ou));\n+  static_assert(max_size_t(ns)*max_size_t(ns) == ou);\n+  static_assert(-max_diff_t(0) == max_diff_t(0));\n+  static_assert(-ou-ou == -2*ou);\n+\n+  static_assert(int(ns) == -1);\n+  static_assert(rep_t(ns) == rep_t(-1));\n+\n+  static_assert(max_size_t() == 0);\n+  static_assert(max_diff_t() == 0);\n+\n+  auto f = [] (auto a) { a /= a; return a; };\n+  static_assert(f(max_size_t(5)) == 1);\n+  static_assert(f(max_size_t(-5)) == 1);\n+  static_assert(f(max_diff_t(5)) == 1);\n+\n+  auto g = [] (auto a) { a >>= a; return a; };\n+  static_assert(g(max_size_t(5)) == 0);\n+  static_assert(g(max_diff_t(5)) == 0);\n+\n+  auto h = [] (auto a) { a <<= a; return a; };\n+  static_assert(h(max_size_t(3)) == 24);\n+  static_assert(h(max_diff_t(3)) == 24);\n+}\n+\n+template<bool signed_p, bool shorten_p>\n+void\n+test02()\n+{\n+  using hw_type = std::conditional_t<signed_p, signed rep_t, rep_t>;\n+  using max_type = std::conditional_t<signed_p, max_diff_t, max_size_t>;\n+  using shorten_type = std::conditional_t<shorten_p, hw_type, max_type>;\n+  const int hw_type_bit_size = sizeof(hw_type) * __CHAR_BIT__;\n+  const int limit = 1000;\n+  const int log2_limit = 10;\n+  static_assert((1 << log2_limit) >= limit);\n+  const int min = (signed_p ? -limit : 0);\n+  const int max = limit;\n+  for (hw_type i = min; i <= max; i++)\n+    {\n+      bool ok = true;\n+      if (signed_p || shorten_p)\n+\t{\n+\t  ok &= (~i == shorten_type(~max_type(i)));\n+\t  ok &= (-i == shorten_type(-max_type(i)));\n+\t}\n+      for (hw_type j = min; j <= max; j++)\n+\t{\n+\t  ok &= (i*j == shorten_type(max_type(i)*j));\n+\t  ok &= (i+j == shorten_type(max_type(i)+j));\n+\t  if (j != 0)\n+\t    {\n+\t      ok &= (i/j == shorten_type(max_type(i)/j));\n+\t      ok &= (i%j == shorten_type(max_type(i)%j));\n+\t    }\n+\t  if (signed_p || shorten_p)\n+\t    ok &= (i-j == shorten_type(max_type(i)-j));\n+\t  ok &= ((i&j) == shorten_type(max_type(i)&j));\n+\t  ok &= ((i|j) == shorten_type(max_type(i)|j));\n+\t  ok &= ((i^j) == shorten_type(max_type(i)^j));\n+\t  if (j >= 0 && j < hw_type(hw_type_bit_size)\n+\t      && (shorten_p || j < hw_type(hw_type_bit_size) - log2_limit))\n+\t    {\n+\t      ok &= ((i>>j) == shorten_type(max_type(i)>>j));\n+\t      ok &= ((i<<j) == shorten_type(max_type(i)<<j));\n+\t    }\n+\t  ok &= (i>j) == (max_type(i) > j);\n+\t  ok &= (i<j) == (max_type(i) < j);\n+\t  ok &= (i>=j) == (max_type(i) >= j);\n+\t  ok &= (i<=j) == (max_type(i) <= j);\n+\t  ok &= (i==j) == (max_type(i) == j);\n+\t  ok &= (i!=j) == (max_type(i) != j);\n+\t  if (!ok)\n+\t    {\n+\t      fprintf(stderr,\n+\t\t      \"Inconsistency found: %d %d %lld %lld\\n\",\n+\t\t      signed_p, shorten_p, (long long)i, (long long)j) ;\n+\t       VERIFY(0);\n+\t    }\n+\t}\n+    }\n+}\n+\n+template<bool signed_p, bool toggle_base_p>\n+void\n+test03()\n+{\n+  using hw_type = std::conditional_t<signed_p, signed rep_t, rep_t>;\n+  using max_type = std::conditional_t<signed_p, max_diff_t, max_size_t>;\n+  using base_type = std::conditional_t<toggle_base_p, hw_type, max_type>;\n+  constexpr int hw_type_bit_size = sizeof(hw_type) * __CHAR_BIT__;\n+  constexpr int limit = 1000;\n+  constexpr int log2_limit = 10;\n+  static_assert((1 << log2_limit) >= limit);\n+  const int min = (signed_p ? -limit : 0);\n+  const int max = limit;\n+  for (hw_type i = min; i <= max; i++)\n+    {\n+      bool ok = true;\n+      base_type k;\n+      for (hw_type j = min; j <= max; j++)\n+\t{\n+\t  k = i; k *= j;\n+\t  ok &= (k == (max_type(i)*j));\n+\t  k = i; k += j;\n+\t  ok &= (k == (max_type(i)+j));\n+\t  if (j != 0)\n+\t    {\n+\t      k = i; k /= j;\n+\t      ok &= (k == (max_type(i)/j));\n+\t      k = i; k %= j;\n+\t      ok &= (k == (max_type(i)%j));\n+\t    }\n+\t  if (signed_p)\n+\t    {\n+\t      k = i; k -= j;\n+\t      ok &= (k == (max_type(i)-j));\n+\t    }\n+\t  k = i; k &= j;\n+\t  ok &= (k == (max_type(i)&j));\n+\t  k = i; k |= j;\n+\t  ok &= (k == (max_type(i)|j));\n+\t  k = i; k ^= j;\n+\t  ok &= (k == (max_type(i)^j));\n+\t  if (j >= 0 && j < hw_type(hw_type_bit_size)\n+\t      && (!toggle_base_p || j < hw_type(hw_type_bit_size) - log2_limit))\n+\t    {\n+\t      k = i; k >>= j;\n+\t      ok &= (k == (max_type(i)>>j));\n+\t      k = i; k <<= j;\n+\t      ok &= (k == (max_type(i)<<j));\n+\t    }\n+\t  if (!ok)\n+\t    {\n+\t      fprintf(stderr,\n+\t\t      \"Inconsistency found: %d %d %lld %lld\\n\",\n+\t\t      signed_p, toggle_base_p, (long long)i, (long long)j) ;\n+\t       VERIFY(0);\n+\t    }\n+\t}\n+    }\n+}\n+\n+void\n+test04()\n+{\n+  constexpr int limit = 1000;\n+  for (int i = -limit; i <= limit; i++)\n+    {\n+      VERIFY( -max_size_t(-i) == i );\n+      for (int j = i; j <= limit; j++)\n+\t{\n+\t  VERIFY( max_size_t(-i) * max_size_t(-j) == i*j );\n+\t  VERIFY( max_size_t(-j) * max_size_t(-i) == j*i );\n+\t  VERIFY( rep_t(((mu+1)+i)*((mu+1)+j)) == rep_t(i*j) );\n+\t  VERIFY( rep_t(((mu+1)+j)*((mu+1)+i)) == rep_t(j*i) );\n+\t  if (i >= 0 && j > 0)\n+\t    {\n+\t      auto r = (mu+i)-((mu+i)/j)*j;\n+\t      VERIFY( r >= 0 && r < j );\n+\t      VERIFY( r == (mu+i)%j );\n+\t    }\n+\t}\n+    }\n+}\n+\n+void\n+test05()\n+{\n+#if __SIZEOF_INT128__\n+  max_size_t x = 0;\n+  x = static_cast<__int128>(0);\n+  x = static_cast<unsigned __int128>(0);\n+\n+  max_diff_t y = 0;\n+  y = static_cast<__int128>(0);;\n+  y = static_cast<unsigned __int128>(0);\n+#endif\n+}\n+\n+using std::numeric_limits;\n+\n+static_assert(numeric_limits<max_size_t>::is_specialized);\n+static_assert(!numeric_limits<max_size_t>::is_signed);\n+static_assert(numeric_limits<max_size_t>::is_integer);\n+static_assert(numeric_limits<max_size_t>::is_exact);\n+// We can't unconditionally use numeric_limits here because __int128 is an\n+// integral type only in GNU mode.\n+#if __SIZEOF_INT128__\n+static_assert(numeric_limits<max_size_t>::digits == 129);\n+static_assert(numeric_limits<max_size_t>::digits10 == 38);\n+static_assert(numeric_limits<max_size_t>::max()\n+\t      == 2*max_size_t(~rep_t(0)) + 1);\n+#else\n+static_assert(numeric_limits<max_size_t>::digits\n+\t      == numeric_limits<rep_t>::digits + 1);\n+static_assert(numeric_limits<max_size_t>::digits10\n+\t      == numeric_limits<rep_t>::digits10);\n+static_assert(numeric_limits<max_size_t>::max()\n+\t      == 2*max_size_t(numeric_limits<rep_t>::max())+1);\n+#endif\n+static_assert(numeric_limits<max_size_t>::min() == 0);\n+static_assert(numeric_limits<max_size_t>::max()\n+\t      == max_size_t(-1));\n+static_assert((numeric_limits<max_size_t>::max()\n+\t       >> (numeric_limits<max_size_t>::digits-1)) == 1);\n+static_assert(numeric_limits<max_size_t>::lowest()\n+\t      == numeric_limits<max_size_t>::min());\n+\n+static_assert(numeric_limits<max_diff_t>::is_specialized);\n+static_assert(numeric_limits<max_diff_t>::is_signed);\n+static_assert(numeric_limits<max_diff_t>::is_integer);\n+static_assert(numeric_limits<max_diff_t>::is_exact);\n+static_assert(numeric_limits<max_diff_t>::digits\n+\t      == numeric_limits<max_size_t>::digits - 1);\n+static_assert(numeric_limits<max_diff_t>::digits10\n+\t      == numeric_limits<max_size_t>::digits10);\n+// We can't unconditionally use numeric_limits here because __int128 is an\n+// integral type only in GNU mode.\n+#if __SIZEOF_INT128__\n+static_assert(numeric_limits<max_diff_t>::min() == -max_diff_t(~rep_t(0))-1);\n+static_assert(numeric_limits<max_diff_t>::max() == ~rep_t(0));\n+#else\n+static_assert(numeric_limits<max_diff_t>::min()\n+\t      == -max_diff_t(numeric_limits<rep_t>::max())-1);\n+static_assert(numeric_limits<max_diff_t>::max()\n+\t      == numeric_limits<rep_t>::max());\n+#endif\n+static_assert(numeric_limits<max_diff_t>::lowest()\n+\t      == numeric_limits<max_diff_t>::min());\n+static_assert(max_diff_t(max_size_t(1)\n+\t\t\t << (numeric_limits<max_size_t>::digits-1))\n+\t      == numeric_limits<max_diff_t>::min());\n+\n+int\n+main()\n+{\n+  test01();\n+\n+  test02<false,false>();\n+  test02<false,true>();\n+  test02<true,false>();\n+  test02<true,true>();\n+\n+  test03<false,false>();\n+  test03<false,true>();\n+  test03<true,false>();\n+  test03<true,true>();\n+\n+  test04();\n+  test05();\n+}"}]}