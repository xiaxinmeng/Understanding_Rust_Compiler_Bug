{"sha": "1a5b457d5730b4f83540da3a814c5909d9ada14b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE1YjQ1N2Q1NzMwYjRmODM1NDBkYTNhODE0YzU5MDlkOWFkYTE0Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-13T11:19:34Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-13T11:19:34Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r733", "tree": {"sha": "2efd39ce86d9eaa810dcf16d460511160a787598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2efd39ce86d9eaa810dcf16d460511160a787598"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a5b457d5730b4f83540da3a814c5909d9ada14b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5b457d5730b4f83540da3a814c5909d9ada14b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a5b457d5730b4f83540da3a814c5909d9ada14b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5b457d5730b4f83540da3a814c5909d9ada14b/comments", "author": null, "committer": null, "parents": [{"sha": "77f934bbbf75bddbe4f31482025c68d627fedda7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77f934bbbf75bddbe4f31482025c68d627fedda7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77f934bbbf75bddbe4f31482025c68d627fedda7"}], "stats": {"total": 41, "additions": 33, "deletions": 8}, "files": [{"sha": "eb974de75dcec702be8575dc1555f4bf7a26d1b6", "filename": "gcc/cccp.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5b457d5730b4f83540da3a814c5909d9ada14b/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5b457d5730b4f83540da3a814c5909d9ada14b/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=1a5b457d5730b4f83540da3a814c5909d9ada14b", "patch": "@@ -3318,14 +3318,16 @@ handle_directive (ip, op)\n \t\t*cp++ = *xp++;\n \t\tSKIP_WHITE_SPACE (xp);\n \t      }\n+\t    } else {\n+\t      *cp++ = *xp++;\n \t    }\n \t    break;\n \n \t  case '\\'':\n \t  case '\\\"':\n \t    {\n \t      register U_CHAR *bp1\n-\t\t= skip_quoted_string (xp - 1, limit, ip->lineno, 0, 0, 0);\n+\t\t= skip_quoted_string (xp - 1, bp, ip->lineno, 0, 0, 0);\n \t      while (xp != bp1)\n \t\tif (*xp == '\\\\') {\n \t\t  if (*++xp != '\\n')"}, {"sha": "ef3aeb91ca2327a3201901df63a54455587e3707", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5b457d5730b4f83540da3a814c5909d9ada14b/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5b457d5730b4f83540da3a814c5909d9ada14b/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=1a5b457d5730b4f83540da3a814c5909d9ada14b", "patch": "@@ -529,13 +529,36 @@ gen_lowpart_common (mode, x)\n      from the low-order part of the constant.  */\n   else if (GET_MODE_CLASS (mode) == MODE_INT && GET_MODE (x) == VOIDmode\n \t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE))\n-    return (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_INT ? x\n-\t    : (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_INT\n-\t       && GET_CODE (x) == CONST_INT) ? x\n-\t    : gen_rtx (CONST_INT, VOIDmode,\n-\t\t       (GET_MODE_MASK (mode)\n-\t\t\t& (GET_CODE (x) == CONST_INT\n-\t\t\t   ? INTVAL (x) : CONST_DOUBLE_LOW (x)))));\n+    {\n+      /* If MODE is twice the host word size, X is already the desired\n+\t representation.  Otherwise, if MODE is wider than a word, we can't\n+\t do this.  If MODE is exactly a word, return just one CONST_INT.\n+\t If MODE is smaller than a word, clear the bits that don't belong\n+\t in our mode, unless they and our sign bit are all one.  So we get\n+\t either a reasonable negative value or a reasonable unsigned value\n+\t for this mode.  */\n+\n+      if (GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_INT)\n+\treturn x;\n+      else if (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_INT)\n+\treturn 0;\n+      else if (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_INT)\n+\treturn (GET_CODE (x) == CONST_INT ? x\n+\t\t: gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (x)));\n+      else\n+\t{\n+\t  /* MODE must be narrower than HOST_BITS_PER_INT.  */\n+\t  int width = GET_MODE_BITSIZE (mode);\n+\t  int val = (GET_CODE (x) == CONST_INT ? INTVAL (x)\n+\t\t     : CONST_DOUBLE_LOW (x));\n+\n+\t  if (((val & ((-1) << (width - 1))) != ((-1) << (width - 1))))\n+\t    val &= (1 << width) - 1;\n+\n+\t  return (GET_CODE (x) == CONST_INT && INTVAL (x) == val ? x\n+\t\t  : gen_rtx (CONST_INT, VOIDmode, val));\n+\t}\n+    }\n \n   /* Otherwise, we can't do this.  */\n   return 0;"}]}