{"sha": "d09a75ae9318ed48fb2350b84fe886d9b8bb6b01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA5YTc1YWU5MzE4ZWQ0OGZiMjM1MGI4NGZlODg2ZDliOGJiNmIwMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-11T17:18:02Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-11T17:18:02Z"}, "message": "(expand_asm_operands): See if output operand permits register.\n\n(expand_asm_operands): See if output operand permits register.  If\nnot, mark output addressable, call expand_operand on it, and give\nerror if not MEM.\n\nFrom-SVN: r9923", "tree": {"sha": "41b591b675a223b0d6e3d0827205d9cdf61a6739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41b591b675a223b0d6e3d0827205d9cdf61a6739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d09a75ae9318ed48fb2350b84fe886d9b8bb6b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d09a75ae9318ed48fb2350b84fe886d9b8bb6b01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d09a75ae9318ed48fb2350b84fe886d9b8bb6b01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d09a75ae9318ed48fb2350b84fe886d9b8bb6b01/comments", "author": null, "committer": null, "parents": [{"sha": "621061f4f3f392f3272663b98c71046d7c49692c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/621061f4f3f392f3272663b98c71046d7c49692c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/621061f4f3f392f3272663b98c71046d7c49692c"}], "stats": {"total": 68, "additions": 50, "deletions": 18}, "files": [{"sha": "026e592fbf7909e764c854c58b8d6ab6476ca25c", "filename": "gcc/stmt.c", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d09a75ae9318ed48fb2350b84fe886d9b8bb6b01/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d09a75ae9318ed48fb2350b84fe886d9b8bb6b01/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=d09a75ae9318ed48fb2350b84fe886d9b8bb6b01", "patch": "@@ -1411,41 +1411,73 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       tree type = TREE_TYPE (val);\n       tree val1;\n       int j;\n-      int found_equal;\n+      int found_equal = 0;\n+      int allows_reg = 0;\n \n       /* If there's an erroneous arg, emit no insn.  */\n       if (TREE_TYPE (val) == error_mark_node)\n \treturn;\n \n-      /* Make sure constraint has `=' and does not have `+'.  */\n+      /* Make sure constraint has `=' and does not have `+'.  Also, see\n+\t if it allows any register.  Be liberal on the latter test, since\n+\t the worst that happens if we get it wrong is we issue an error\n+\t message.  */\n \n-      found_equal = 0;\n-      for (j = 0; j < TREE_STRING_LENGTH (TREE_PURPOSE (tail)); j++)\n-\t{\n-\t  if (TREE_STRING_POINTER (TREE_PURPOSE (tail))[j] == '+')\n-\t    {\n-\t      error (\"output operand constraint contains `+'\");\n-\t      return;\n-\t    }\n-\t  if (TREE_STRING_POINTER (TREE_PURPOSE (tail))[j] == '=')\n+      for (j = 0; j < TREE_STRING_LENGTH (TREE_PURPOSE (tail)) - 1; j++)\n+\tswitch (TREE_STRING_POINTER (TREE_PURPOSE (tail))[j])\n+\t  {\n+\t  case '+':\n+\t    error (\"output operand constraint contains `+'\");\n+\t    return;\n+\n+\t  case '=':\n \t    found_equal = 1;\n-\t}\n+\t    break;\n+\n+\t  case '?':  case '!':  case '*':  case '%':  case '&':\n+\t  case '0':  case '1':  case '2':  case '3':  case '4':\n+\t  case 'V':  case 'm':  case 'o':  case '<':  case '>':\n+\t  case 'E':  case 'F':  case 'G':  case 'H':  case 'X':\n+\t  case 's':  case 'i':  case 'n':\n+\t  case 'I':  case 'J':  case 'K':  case 'L':  case 'M':\n+\t  case 'N':  case 'O':  case 'P':  case ',':\n+#ifdef EXTRA_CONSTRAINT\n+\t  case 'Q':  case 'R':  case 'S':  case 'T':  case 'U':\n+#endif\n+\t    break;\n+\n+\t  case 'p':  case 'g':  case 'r':\n+\t  default:\n+\t    allows_reg = 1;\n+\t    break;\n+\t  }\n+\n       if (! found_equal)\n \t{\n \t  error (\"output operand constraint lacks `='\");\n \t  return;\n \t}\n \n-      /* If an output operand is not a decl or indirect ref,\n-\t make a temporary to act as an intermediate.   Make the asm insn\n-\t write into that, then our caller will copy it to the real output\n-\t operand.  Likewise for promoted variables.  */\n+      /* If an output operand is not a decl or indirect ref and our constraint\n+\t allows a register, make a temporary to act as an intermediate.\n+\t Make the asm insn write into that, then our caller will copy it to\n+\t the real output operand.  Likewise for promoted variables.  */\n \n       if (TREE_CODE (val) == INDIRECT_REF\n \t  || (TREE_CODE_CLASS (TREE_CODE (val)) == 'd'\n \t      && ! (GET_CODE (DECL_RTL (val)) == REG\n-\t\t    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type))))\n-\toutput_rtx[i] = expand_expr (TREE_VALUE (tail), NULL_RTX, VOIDmode, 0);\n+\t\t    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))\n+\t  || ! allows_reg)\n+\t{\n+\t  if (! allows_reg)\n+\t    mark_addressable (TREE_VALUE (tail));\n+\n+\t  output_rtx[i]\n+\t    = expand_expr (TREE_VALUE (tail), NULL_RTX, VOIDmode, 0);\n+\n+\t  if (! allows_reg && GET_CODE (output_rtx[i]) != MEM)\n+\t    error (\"output number %d not directly addressable\", i);\n+\t}\n       else\n \t{\n \t  if (TYPE_MODE (type) == BLKmode)"}]}