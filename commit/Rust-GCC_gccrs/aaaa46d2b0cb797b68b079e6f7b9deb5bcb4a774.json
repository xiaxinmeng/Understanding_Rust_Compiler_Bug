{"sha": "aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFhYTQ2ZDJiMGNiNzk3YjY4YjA3OWU2ZjdiOWRlYjViY2I0YTc3NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-16T01:15:43Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-16T01:15:43Z"}, "message": "vec.h (VEC_address): New function.\n\n\t* vec.h (VEC_address): New function.\n\n\t* cp-tree.h (lang_type_class): Remove has_real_assign_ref and\n\thas_abstract_assign_ref.  Make methods a VEC(tree) *.\n\t(TYPE_HAS_CONST_ASSIGN_REF): Add documentation.\n\t(CLASSTYPE_CONSTRUCTORS): Adjust for changes to CLASSTYPE_METHOD_VEC.\n\t(CLASSTYPE_DESTRUCTORS): Likewise.\n\t(TYPE_HAS_REAL_ASSIGN_REF): Remove.\n\t(TYPE_HAS_ABSTRACT_ASSIGN_REF): Likewise.\n\t(add_method): Change prototoype.\n\t* class.c (add_method): Remove error_p parameter.  Adjust for\n\tchanges to CLASSTYPE_METHOD_VEC.\n\t(handle_using_decl): Adjust call to add_method.\n\t(maybe_warn_about_overly_private_class): Adjust for\n\tchanges to CLASSTYPE_METHOD_VEC.\n\t(resort_type_method_vec): Likewise.\n\t(finish_struct_methods): Likewise.\n\t(check_for_override): Likewise.\n\t(warn_hidden): Likewise.\n\t(add_implicitly_declared_members): Defer creation of assignment\n\toperators.  Adjust call to add_method.\n\t(clone_function_decl): Adjust call to add_method.\n\t(check_bases_and_members): Don't set TYPE_HAS_REAL_ASSIGN_REF.\n\t(finish_struct_1): Use CLASSTYPE_DESTRUCTORS.\n\t* decl.c (grok_special_member_properties): Don't set\n\tTYPE_HAS_ABSTRACT_ASSIGN_REF.\n\t* decl2.c (check_classfn): Adjust for\n\tchanges to CLASSTYPE_METHOD_VEC.\n\t* method.c (locate_dtor): Use CLASSTYPE_DESTRUCTORS.\n\t(locate_ctor): Use CLASSTYPE_CONSTRUCTORS.\n\t(locate_copy): Adjust for changes to CLASSTYPE_METHOD_VEC.\n\t(implicitly_declare_fn): Set DECL_SOURCE_LOCATION.  Do not call\n\tcp_finish_decl.\n\t* pt.c (check_explicit_specialization): Adjust for\n\tchanges to CLASSTYPE_METHOD_VEC.\n\t(instantiate_class_template): Do not set\n\tTYPE_HAS_ABSTRACT_ASSIGN_REF.\n\t* ptree.c (cxx_print_type): Don't try to print\n\tCLASSTYPE_METHOD_VEC.\n\t* rtti.c (emit_support_tinfos): Use CLASSTYPE_DESTRUCTORS.\n\t* search.c (lookup_field_r): Adjust for\n\tchanges to CLASSTYPE_METHOD_VEC.\n\t(lookup_fnfields): Likewise.\n\t(lookup_conversion_operator): Likewise.\n\t(lookup_fnfields_1): Likewise.  Create assignment operators\n\tlazily.\n\t(look_for_overrides_here): Adjust for\n\tchanges to CLASSTYPE_METHOD_VEC.\n\t(add_conversions): Likewise.\n\t* semantics.c (finish_member_declaration): Adjust call to add_method.\n\nFrom-SVN: r84796", "tree": {"sha": "682aa43196b4509a69da60da01d7d2806e7bb920", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/682aa43196b4509a69da60da01d7d2806e7bb920"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/comments", "author": null, "committer": null, "parents": [{"sha": "b38b6477f8229197137a63d2e9abd20fb0bb83d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38b6477f8229197137a63d2e9abd20fb0bb83d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b38b6477f8229197137a63d2e9abd20fb0bb83d5"}], "stats": {"total": 536, "additions": 275, "deletions": 261}, "files": [{"sha": "ae44c8b9e9156fbba9659cc8b77650545ce21693", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -1,3 +1,7 @@\n+2004-07-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* vec.h (VEC_address): New function.\n+\n 2004-07-14  Jason Merrill  <jason@redhat.com>\n \n \tPR middle-end/15885"}, {"sha": "6a3bb289e7004196f5112419aaa7b9cf4eb8359e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -1,3 +1,54 @@\n+2004-07-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (lang_type_class): Remove has_real_assign_ref and\n+\thas_abstract_assign_ref.  Make methods a VEC(tree) *.\n+\t(TYPE_HAS_CONST_ASSIGN_REF): Add documentation.\n+\t(CLASSTYPE_CONSTRUCTORS): Adjust for changes to CLASSTYPE_METHOD_VEC.\n+\t(CLASSTYPE_DESTRUCTORS): Likewise.\n+\t(TYPE_HAS_REAL_ASSIGN_REF): Remove.\n+\t(TYPE_HAS_ABSTRACT_ASSIGN_REF): Likewise.\n+\t(add_method): Change prototoype.\n+\t* class.c (add_method): Remove error_p parameter.  Adjust for\n+\tchanges to CLASSTYPE_METHOD_VEC.\n+\t(handle_using_decl): Adjust call to add_method.\n+\t(maybe_warn_about_overly_private_class): Adjust for\n+\tchanges to CLASSTYPE_METHOD_VEC.\n+\t(resort_type_method_vec): Likewise.\n+\t(finish_struct_methods): Likewise.\n+\t(check_for_override): Likewise.\n+\t(warn_hidden): Likewise.\n+\t(add_implicitly_declared_members): Defer creation of assignment\n+\toperators.  Adjust call to add_method.\n+\t(clone_function_decl): Adjust call to add_method.\n+\t(check_bases_and_members): Don't set TYPE_HAS_REAL_ASSIGN_REF.\n+\t(finish_struct_1): Use CLASSTYPE_DESTRUCTORS.\n+\t* decl.c (grok_special_member_properties): Don't set\n+\tTYPE_HAS_ABSTRACT_ASSIGN_REF.\n+\t* decl2.c (check_classfn): Adjust for\n+\tchanges to CLASSTYPE_METHOD_VEC.\n+\t* method.c (locate_dtor): Use CLASSTYPE_DESTRUCTORS.\n+\t(locate_ctor): Use CLASSTYPE_CONSTRUCTORS.\n+\t(locate_copy): Adjust for changes to CLASSTYPE_METHOD_VEC.\n+\t(implicitly_declare_fn): Set DECL_SOURCE_LOCATION.  Do not call\n+\tcp_finish_decl.\n+\t* pt.c (check_explicit_specialization): Adjust for\n+\tchanges to CLASSTYPE_METHOD_VEC.\n+\t(instantiate_class_template): Do not set\n+\tTYPE_HAS_ABSTRACT_ASSIGN_REF.\n+\t* ptree.c (cxx_print_type): Don't try to print\n+\tCLASSTYPE_METHOD_VEC.\n+\t* rtti.c (emit_support_tinfos): Use CLASSTYPE_DESTRUCTORS.\n+\t* search.c (lookup_field_r): Adjust for\n+\tchanges to CLASSTYPE_METHOD_VEC.\n+\t(lookup_fnfields): Likewise.\n+\t(lookup_conversion_operator): Likewise.\n+\t(lookup_fnfields_1): Likewise.  Create assignment operators\n+\tlazily.\n+\t(look_for_overrides_here): Adjust for\n+\tchanges to CLASSTYPE_METHOD_VEC.\n+\t(add_conversions): Likewise.\n+\t* semantics.c (finish_member_declaration): Adjust call to add_method.\n+\n 2004-07-15  Jason Merrill  <jason@redhat.com>\n \n \t* cp-lang.c (cxx_types_compatible_p): To the middle-end,\n@@ -13,7 +64,7 @@\n \t(copy_binfo): Declare.\n \n 2004-07-15  Mark Mitchell  <mark@codesourcery.com>\n-\n+\t\n \t* name-lookup.c (set_inherited_value_binding_p): Add class_type \n \tparameter.\n \t(get_class_binding): Adjust."}, {"sha": "708c1b5b3ebd9fe95acca514a4d649c07768ed81", "filename": "gcc/cp/class.c", "status": "modified", "additions": 113, "deletions": 176, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -795,43 +795,42 @@ modify_vtable_entry (tree t,\n }\n \n \f\n-/* Add method METHOD to class TYPE.  If ERROR_P is true, we are adding\n-   the method after the class has already been defined because a\n-   declaration for it was seen.  (Even though that is erroneous, we\n-   add the method for improved error recovery.)  */\n+/* Add method METHOD to class TYPE.  */\n \n void\n-add_method (tree type, tree method, int error_p)\n+add_method (tree type, tree method)\n {\n   int using;\n-  int len;\n-  int slot;\n-  tree method_vec;\n+  size_t len;\n+  size_t slot;\n   tree overload;\n   int template_conv_p;\n+  VEC(tree) *method_vec;\n+  bool complete_p;\n \n   if (method == error_mark_node)\n     return;\n-  \n+\n+  complete_p = COMPLETE_TYPE_P (type);\n   using = (DECL_CONTEXT (method) != type);\n   template_conv_p = (TREE_CODE (method) == TEMPLATE_DECL\n                      && DECL_TEMPLATE_CONV_FN_P (method));\n \n-  if (!CLASSTYPE_METHOD_VEC (type))\n-    /* Make a new method vector.  We start with 8 entries.  We must\n-       allocate at least two (for constructors and destructors), and\n-       we're going to end up with an assignment operator at some point\n-       as well.\n-       \n-       We could use a TREE_LIST for now, and convert it to a TREE_VEC\n-       in finish_struct, but we would probably waste more memory\n-       making the links in the list than we would by over-allocating\n-       the size of the vector here.  Furthermore, we would complicate\n-       all the code that expects this to be a vector.  */\n-    CLASSTYPE_METHOD_VEC (type) = make_tree_vec (8);\n-\n   method_vec = CLASSTYPE_METHOD_VEC (type);\n-  len = TREE_VEC_LENGTH (method_vec);\n+  if (!method_vec)\n+    {\n+      /* Make a new method vector.  We start with 8 entries.  We must\n+\t allocate at least two (for constructors and destructors), and\n+\t we're going to end up with an assignment operator at some\n+\t point as well.  */\n+      method_vec = VEC_alloc (tree, 8);\n+      /* Create slots for constructors and destructors.  */\n+      VEC_quick_push (tree, method_vec, NULL_TREE);\n+      VEC_quick_push (tree, method_vec, NULL_TREE);\n+      CLASSTYPE_METHOD_VEC (type) = method_vec;\n+    }\n+\n+  len = VEC_length (tree, method_vec);\n \n   /* Constructors and destructors go in special slots.  */\n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (method))\n@@ -849,103 +848,52 @@ add_method (tree type, tree method, int error_p)\n     }\n   else\n     {\n-      int have_template_convs_p = 0;\n-      \n+      bool insert_p = true;\n+      bool conv_p = DECL_CONV_FN_P (method);\n+      tree m;\n+\n       /* See if we already have an entry with this name.  */\n-      for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT; slot < len; ++slot)\n+      for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT; \n+\t   (m = VEC_iterate (tree, method_vec, slot));\n+\t   ++slot)\n \t{\n-\t  tree m = TREE_VEC_ELT (method_vec, slot);\n-\n-\t  if (!m)\n-\t    break;\n \t  m = OVL_CURRENT (m);\n-\t  \n \t  if (template_conv_p)\n \t    {\n-\t      have_template_convs_p = (TREE_CODE (m) == TEMPLATE_DECL\n-\t\t\t\t       && DECL_TEMPLATE_CONV_FN_P (m));\n-\t      \n-\t      /* If we need to move things up, see if there's\n-\t\t space.  */\n-\t      if (!have_template_convs_p)\n-\t\t{\n-\t\t  slot = len - 1;\n-\t\t  if (TREE_VEC_ELT (method_vec, slot))\n-\t\t    slot++;\n-\t\t}\n+\t      if (TREE_CODE (m) == TEMPLATE_DECL\n+\t\t  && DECL_TEMPLATE_CONV_FN_P (m))\n+\t\tinsert_p = false;\n \t      break;\n \t    }\n-\t  if (DECL_NAME (m) == DECL_NAME (method))\n+\t  if (conv_p && !DECL_CONV_FN_P (m))\n \t    break;\n-\t}\n-      \n-      if (slot == len)\n-\t{\n-\t  /* We need a bigger method vector.  */\n-\t  int new_len;\n-\t  tree new_vec;\n-\n-\t  /* In the non-error case, we are processing a class\n-\t     definition.  Double the size of the vector to give room\n-\t     for new methods.  */\n-\t  if (!error_p)\n-\t    new_len = 2 * len;\n-\t  /* In the error case, the vector is already complete.  We\n-\t     don't expect many errors, and the rest of the front-end\n-\t     will get confused if there are empty slots in the vector.  */\n-\t  else\n-\t    new_len = len + 1;\n-\n-\t  new_vec = make_tree_vec (new_len);\n-\t  memcpy (&TREE_VEC_ELT (new_vec, 0), &TREE_VEC_ELT (method_vec, 0),\n-\t\t  len * sizeof (tree));\n-\t  len = new_len;\n-\t  method_vec = CLASSTYPE_METHOD_VEC (type) = new_vec;\n-\t}\n-\n-      if (DECL_CONV_FN_P (method) && !TREE_VEC_ELT (method_vec, slot))\n-\t{\n-\t  /* Type conversion operators have to come before ordinary\n-\t     methods; add_conversions depends on this to speed up\n-\t     looking for conversion operators.  So, if necessary, we\n-\t     slide some of the vector elements up.  In theory, this\n-\t     makes this algorithm O(N^2) but we don't expect many\n-\t     conversion operators.  */\n-\t  if (template_conv_p)\n-\t    slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t  else\n-\t    for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT; slot < len; ++slot)\n-\t      {\n-\t\ttree fn = TREE_VEC_ELT (method_vec, slot);\n-  \n-\t\tif (!fn)\n-\t\t  /* There are no more entries in the vector, so we\n-\t\t     can insert the new conversion operator here.  */\n-\t\t  break;\n-  \t\t  \n-\t\tif (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n-\t\t  /* We can insert the new function right at the\n-\t\t     SLOTth position.  */\n-\t\t  break;\n-\t      }\n-\n-\t  if (template_conv_p && have_template_convs_p)\n-\t    /*OK*/;\n-\t  else if (!TREE_VEC_ELT (method_vec, slot))\n-\t    /* There is nothing in the Ith slot, so we can avoid\n-\t       moving anything.  */\n-\t\t; \n-\t  else\n+\t  if (DECL_NAME (m) == DECL_NAME (method))\n \t    {\n-\t      /* We know the last slot in the vector is empty\n-\t\t because we know that at this point there's room\n-\t\t for a new function.  */\n-\t      memmove (&TREE_VEC_ELT (method_vec, slot + 1),\n-\t\t       &TREE_VEC_ELT (method_vec, slot),\n-\t\t       (len - slot - 1) * sizeof (tree));\n-\t      TREE_VEC_ELT (method_vec, slot) = NULL_TREE;\n+\t      insert_p = false;\n+\t      break;\n \t    }\n+\t  if (complete_p\n+\t      && !DECL_CONV_FN_P (m)\n+\t      && DECL_NAME (m) > DECL_NAME (method))\n+\t    break;\n \t}\n+\n+\t/* If we need a new slot, make room.  */\n+\tif (insert_p)\n+\t  {\n+\t    /* We expect to add few methods in the COMPLETE_P case, so\n+\t       just make room for one more method.  */\n+\t    if (complete_p)\n+\t      VEC_reserve (tree, method_vec, 1);\n+\t    if (slot == len)\n+\t      VEC_safe_push (tree, method_vec, NULL_TREE);\n+\t    else\n+\t      VEC_safe_insert (tree, method_vec, slot, NULL_TREE);\n+\t    len++;\n+\t    /* Inserting a new slot may have caused the vector to be\n+\t       reallocated.  */\n+\t    CLASSTYPE_METHOD_VEC (type) = method_vec;\n+\t  }\n     }\n       \n   if (processing_template_decl)\n@@ -957,7 +905,7 @@ add_method (tree type, tree method, int error_p)\n       tree fns;\n \n       /* Check to see if we've already got this method.  */\n-      for (fns = TREE_VEC_ELT (method_vec, slot);\n+      for (fns = VEC_index (tree, method_vec, slot);\n \t   fns;\n \t   fns = OVL_NEXT (fns))\n \t{\n@@ -1027,13 +975,14 @@ add_method (tree type, tree method, int error_p)\n     }\n \n   /* Add the new binding.  */ \n-  overload = build_overload (method, TREE_VEC_ELT (method_vec, slot));\n+  overload = build_overload (method, VEC_index (tree, method_vec, slot));\n   if (!DECL_CONSTRUCTOR_P (method)\n-      && !DECL_DESTRUCTOR_P (method))\n+      && !DECL_DESTRUCTOR_P (method)\n+      && !complete_p)\n     push_class_level_binding (DECL_NAME (method), overload);\n \n   /* Actually insert the new method.  */\n-  TREE_VEC_ELT (method_vec, slot) = overload;\n+  VEC_replace (tree, method_vec, slot, overload);\n }\n \n /* Subroutines of finish_struct.  */\n@@ -1171,7 +1120,7 @@ handle_using_decl (tree using_decl, tree t)\n   if (flist)\n     for (; flist; flist = OVL_NEXT (flist))\n       {\n-\tadd_method (t, OVL_CURRENT (flist), /*error_p=*/0);\n+\tadd_method (t, OVL_CURRENT (flist));\n \talter_access (t, OVL_CURRENT (flist), access);\n       }\n   else\n@@ -1637,9 +1586,7 @@ maybe_warn_about_overly_private_class (tree t)\n       if (!TYPE_HAS_INIT_REF (t))\n \tnonprivate_ctor = 1;\n       else \n-\tfor (fn = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n-\t     fn;\n-\t     fn = OVL_NEXT (fn)) \n+\tfor (fn = CLASSTYPE_CONSTRUCTORS (t); fn; fn = OVL_NEXT (fn)) \n \t  {\n \t    tree ctor = OVL_CURRENT (fn);\n \t    /* Ideally, we wouldn't count copy constructors (or, in\n@@ -1721,24 +1668,24 @@ resort_type_method_vec (void* obj,\n                         gt_pointer_operator new_value,\n                         void* cookie)\n {\n-  tree method_vec = obj;\n-  int len = TREE_VEC_LENGTH (method_vec);\n-  int slot;\n+  VEC(tree) *method_vec = (VEC(tree) *) obj;\n+  int len = VEC_length (tree, method_vec);\n+  size_t slot;\n+  tree fn;\n \n   /* The type conversion ops have to live at the front of the vec, so we\n      can't sort them.  */\n-  for (slot = 2; slot < len; ++slot)\n-    {\n-      tree fn = TREE_VEC_ELT (method_vec, slot);\n-  \n-      if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n-\tbreak;\n-    }\n+  for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+       (fn = VEC_iterate (tree, method_vec, slot));\n+       ++slot)\n+    if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n+      break;\n+\n   if (len - slot > 1)\n     {\n       resort_data.new_value = new_value;\n       resort_data.cookie = cookie;\n-      qsort (&TREE_VEC_ELT (method_vec, slot), len - slot, sizeof (tree),\n+      qsort (VEC_address (tree, method_vec) + slot, len - slot, sizeof (tree),\n \t     resort_method_name_cmp);\n     }\n }\n@@ -1763,7 +1710,7 @@ static void\n finish_struct_methods (tree t)\n {\n   tree fn_fields;\n-  tree method_vec;\n+  VEC(tree) *method_vec;\n   int slot, len;\n \n   if (!TYPE_METHODS (t))\n@@ -1772,13 +1719,13 @@ finish_struct_methods (tree t)\n \t these incorrectly.  */\n       TYPE_HAS_CONSTRUCTOR (t) = 0;\n       TYPE_HAS_DESTRUCTOR (t) = 0;\n-      CLASSTYPE_METHOD_VEC (t) = NULL_TREE;\n+      CLASSTYPE_METHOD_VEC (t) = NULL;\n       return;\n     }\n \n   method_vec = CLASSTYPE_METHOD_VEC (t);\n-  my_friendly_assert (method_vec != NULL_TREE, 19991215);\n-  len = TREE_VEC_LENGTH (method_vec);\n+  my_friendly_assert (method_vec, 19991215);\n+  len = VEC_length (tree, method_vec);\n \n   /* First fill in entry 0 with the constructors, entry 1 with destructors,\n      and the next few with type conversion operators (if any).  */\n@@ -1796,23 +1743,16 @@ finish_struct_methods (tree t)\n      no methods, then some public defaults are generated.  */\n   maybe_warn_about_overly_private_class (t);\n \n-  /* Now sort the methods.  */\n-  while (len > 2 && TREE_VEC_ELT (method_vec, len-1) == NULL_TREE)\n-    len--;\n-  TREE_VEC_LENGTH (method_vec) = len;\n-\n   /* The type conversion ops have to live at the front of the vec, so we\n      can't sort them.  */\n-  for (slot = 2; slot < len; ++slot)\n-    {\n-      tree fn = TREE_VEC_ELT (method_vec, slot);\n-  \n-      if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n-\tbreak;\n-    }\n+  for (slot = 2;\n+       (fn_fields = VEC_iterate (tree, method_vec, slot));\n+       ++slot)\n+    if (!DECL_CONV_FN_P (OVL_CURRENT (fn_fields)))\n+      break;\n   if (len - slot > 1)\n-    qsort (&TREE_VEC_ELT (method_vec, slot), len-slot, sizeof (tree),\n-\t   method_name_cmp);\n+    qsort (VEC_address (tree, method_vec) + slot,\n+\t   len-slot, sizeof (tree), method_name_cmp);\n }\n \n /* Make BINFO's vtable have N entries, including RTTI entries,\n@@ -2369,7 +2309,7 @@ get_basefndecls (tree name, tree t)\n   /* Find virtual functions in T with the indicated NAME.  */\n   i = lookup_fnfields_1 (t, name);\n   if (i != -1)\n-    for (methods = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), i);\n+    for (methods = VEC_index (tree, CLASSTYPE_METHOD_VEC (t), i);\n \t methods;\n \t methods = OVL_NEXT (methods))\n       {\n@@ -2430,22 +2370,24 @@ check_for_override (tree decl, tree ctype)\n void\n warn_hidden (tree t)\n {\n-  tree method_vec = CLASSTYPE_METHOD_VEC (t);\n-  int n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n-  int i;\n+  VEC(tree) *method_vec = CLASSTYPE_METHOD_VEC (t);\n+  tree fns;\n+  size_t i;\n \n   /* We go through each separately named virtual function.  */\n-  for (i = 2; i < n_methods && TREE_VEC_ELT (method_vec, i); ++i)\n+  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n+       (fns = VEC_iterate (tree, method_vec, i));\n+       ++i)\n     {\n-      tree fns;\n+      tree fn;\n       tree name;\n       tree fndecl;\n       tree base_fndecls;\n       int j;\n \n       /* All functions in this slot in the CLASSTYPE_METHOD_VEC will\n \t have the same name.  Figure out what name that is.  */\n-      name = DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i)));\n+      name = DECL_NAME (OVL_CURRENT (fns));\n       /* There are no possibly hidden functions yet.  */\n       base_fndecls = NULL_TREE;\n       /* Iterate through all of the base classes looking for possibly\n@@ -2462,9 +2404,9 @@ warn_hidden (tree t)\n \tcontinue;\n \n       /* Remove any overridden functions.  */\n-      for (fns = TREE_VEC_ELT (method_vec, i); fns; fns = OVL_NEXT (fns))\n+      for (fn = fns; fn; fn = OVL_NEXT (fn))\n \t{\n-\t  fndecl = OVL_CURRENT (fns);\n+\t  fndecl = OVL_CURRENT (fn);\n \t  if (DECL_VINDEX (fndecl))\n \t    {\n \t      tree *prev = &base_fndecls;\n@@ -2486,8 +2428,7 @@ warn_hidden (tree t)\n \t{\n \t  /* Here we know it is a hider, and no overrider exists.  */\n \t  cp_warning_at (\"`%D' was hidden\", TREE_VALUE (base_fndecls));\n-\t  cp_warning_at (\"  by `%D'\", \n-\t\t\t OVL_CURRENT (TREE_VEC_ELT (method_vec, i)));\n+\t  cp_warning_at (\"  by `%D'\", fns);\n \t  base_fndecls = TREE_CHAIN (base_fndecls);\n \t}\n     }\n@@ -2629,21 +2570,18 @@ add_implicitly_declared_members (tree t,\n       implicit_fns = default_fn;\n     }\n \n-  /* Assignment operator.  */\n-  if (! TYPE_HAS_ASSIGN_REF (t) && ! TYPE_FOR_JAVA (t))\n-    {\n-      default_fn \n-\t= implicitly_declare_fn (sfk_assignment_operator, t,\n-\t\t\t\t /*const_p=*/!cant_have_const_assignment);\n-      TREE_CHAIN (default_fn) = implicit_fns;\n-      implicit_fns = default_fn;\n-    }\n-\n+  /* If there is no assignment operator, one will be created if and\n+     when it is needed.  For now, just record whether or not the type\n+     of the parameter to the assignment operator will be a const or\n+     non-const reference.  */\n+  if (!TYPE_HAS_ASSIGN_REF (t) && !TYPE_FOR_JAVA (t))\n+    TYPE_HAS_CONST_ASSIGN_REF (t) = !cant_have_const_assignment;\n+  \n   /* Now, hook all of the new functions on to TYPE_METHODS,\n      and add them to the CLASSTYPE_METHOD_VEC.  */\n   for (f = &implicit_fns; *f; f = &TREE_CHAIN (*f))\n     {\n-      add_method (t, *f, /*error_p=*/0);\n+      add_method (t, *f);\n       maybe_add_class_template_decl_list (current_class_type, *f, /*friend_p=*/0);\n     }\n   if (abi_version_at_least (2))\n@@ -3923,10 +3861,10 @@ clone_function_decl (tree fn, int update_method_vec_p)\n \t and a not-in-charge version.  */\n       clone = build_clone (fn, complete_ctor_identifier);\n       if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n+\tadd_method (DECL_CONTEXT (clone), clone);\n       clone = build_clone (fn, base_ctor_identifier);\n       if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n+\tadd_method (DECL_CONTEXT (clone), clone);\n     }\n   else\n     {\n@@ -3945,14 +3883,14 @@ clone_function_decl (tree fn, int update_method_vec_p)\n \t{\n \t  clone = build_clone (fn, deleting_dtor_identifier);\n \t  if (update_method_vec_p)\n-\t    add_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n+\t    add_method (DECL_CONTEXT (clone), clone);\n \t}\n       clone = build_clone (fn, complete_dtor_identifier);\n       if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n+\tadd_method (DECL_CONTEXT (clone), clone);\n       clone = build_clone (fn, base_dtor_identifier);\n       if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n+\tadd_method (DECL_CONTEXT (clone), clone);\n     }\n \n   /* Note that this is an abstract function that is never emitted.  */\n@@ -4181,7 +4119,6 @@ check_bases_and_members (tree t)\n   CLASSTYPE_NON_POD_P (t)\n     |= (CLASSTYPE_NON_AGGREGATE (t) || TYPE_HAS_DESTRUCTOR (t) \n \t|| TYPE_HAS_ASSIGN_REF (t));\n-  TYPE_HAS_REAL_ASSIGN_REF (t) |= TYPE_HAS_ASSIGN_REF (t);\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n     |= TYPE_HAS_ASSIGN_REF (t) || TYPE_CONTAINS_VPTR_P (t);\n \n@@ -5164,10 +5101,10 @@ finish_struct_1 (tree t)\n   build_vtt (t);\n \n   if (warn_nonvdtor && TYPE_POLYMORPHIC_P (t) && TYPE_HAS_DESTRUCTOR (t)\n-      && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1)) == NULL_TREE)\n+      && !DECL_VINDEX (CLASSTYPE_DESTRUCTORS (t)))\n \n     {\n-      tree dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1);\n+      tree dtor = CLASSTYPE_DESTRUCTORS (t);\n \n       /* Warn only if the dtor is non-private or the class has friends */\n       if (!TREE_PRIVATE (dtor) ||"}, {"sha": "d8e83d6ee0e4a1fdd61854d4071780d8ae2d2bb7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -991,11 +991,9 @@ struct lang_type_class GTY(())\n   unsigned ptrmemfunc_flag : 1;\n   unsigned was_anonymous : 1;\n \n-  unsigned has_real_assign_ref : 1;\n   unsigned has_const_init_ref : 1;\n   unsigned has_complex_init_ref : 1;\n   unsigned has_complex_assign_ref : 1;\n-  unsigned has_abstract_assign_ref : 1;\n   unsigned non_aggregate : 1;\n   unsigned java_interface : 1;\n \n@@ -1006,7 +1004,7 @@ struct lang_type_class GTY(())\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 9;\n+  unsigned dummy : 11;\n \n   tree primary_base;\n   tree vfields;\n@@ -1018,7 +1016,7 @@ struct lang_type_class GTY(())\n   tree as_base;\n   tree pure_virtuals;\n   tree friend_classes;\n-  tree GTY ((reorder (\"resort_type_method_vec\"))) methods;\n+  VEC (tree) * GTY((reorder (\"resort_type_method_vec\"))) methods;\n   tree key_method;\n   tree decl_list;\n   tree template_info;\n@@ -1093,6 +1091,9 @@ struct lang_type GTY(())\n \n /* Nonzero means that this _CLASSTYPE node overloads operator=(X&).  */\n #define TYPE_HAS_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_assign_ref)\n+\n+/* True iff the class type NODE has an \"operator =\" whose parameter\n+   has a parameter of type \"const X&\".  */\n #define TYPE_HAS_CONST_ASSIGN_REF(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->h.has_const_assign_ref)\n \n@@ -1166,12 +1167,12 @@ struct lang_type GTY(())\n /* A FUNCTION_DECL or OVERLOAD for the constructors for NODE.  These\n    are the constructors that take an in-charge parameter.  */\n #define CLASSTYPE_CONSTRUCTORS(NODE) \\\n-  (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_CONSTRUCTOR_SLOT))\n+  (VEC_index (tree, CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_CONSTRUCTOR_SLOT))\n \n /* A FUNCTION_DECL for the destructor for NODE.  These are the\n    destructors that take an in-charge parameter.  */\n #define CLASSTYPE_DESTRUCTORS(NODE) \\\n-  (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_DESTRUCTOR_SLOT))\n+  (VEC_index (tree, CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_DESTRUCTOR_SLOT))\n \n /* Mark bits for depth-first and breath-first searches.  */\n \n@@ -2367,9 +2368,7 @@ struct lang_decl GTY(())\n   (IS_AGGR_TYPE (NODE) && CLASSTYPE_NON_AGGREGATE (NODE))\n \n /* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n-#define TYPE_HAS_REAL_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_real_assign_ref)\n #define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_assign_ref)\n-#define TYPE_HAS_ABSTRACT_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_abstract_assign_ref)\n #define TYPE_HAS_COMPLEX_INIT_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_init_ref)\n \n /* Nonzero if TYPE has a trivial destructor.  From [class.dtor]:\n@@ -3598,7 +3597,7 @@ extern tree build_vfn_ref\t\t\t(tree, tree);\n extern tree get_vtable_decl                     (tree, int);\n extern void resort_type_method_vec\n   (void *, void *, gt_pointer_operator, void *);\n-extern void add_method\t\t\t\t(tree, tree, int);\n+extern void add_method\t\t\t\t(tree, tree);\n extern int currently_open_class\t\t\t(tree);\n extern tree currently_open_derived_class\t(tree);\n extern tree finish_struct\t\t\t(tree, tree);"}, {"sha": "75487214b79da9e03f3288cc86cb5f7d72253068", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -8352,8 +8352,6 @@ void grok_special_member_properties (tree decl)\n \t  TYPE_HAS_ASSIGN_REF (DECL_CONTEXT (decl)) = 1;\n \t  if (assop != 1)\n \t    TYPE_HAS_CONST_ASSIGN_REF (DECL_CONTEXT (decl)) = 1;\n-\t  if (DECL_PURE_VIRTUAL_P (decl))\n-\t    TYPE_HAS_ABSTRACT_ASSIGN_REF (DECL_CONTEXT (decl)) = 1;\n \t}\n     }\n }"}, {"sha": "8467ad62e7b2e9320bba68f3c0ae7e382ff91b94", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -630,14 +630,14 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \n   if (ix >= 0)\n     {\n-      tree methods = CLASSTYPE_METHOD_VEC (ctype);\n+      VEC(tree) *methods = CLASSTYPE_METHOD_VEC (ctype);\n       tree fndecls, fndecl = 0;\n       bool is_conv_op;\n       bool pop_p;\n       const char *format = NULL;\n       \n       pop_p = push_scope (ctype);\n-      for (fndecls = TREE_VEC_ELT (methods, ix);\n+      for (fndecls = VEC_index (tree, methods, ix);\n \t   fndecls; fndecls = OVL_NEXT (fndecls))\n \t{\n \t  tree p1, p2;\n@@ -685,18 +685,18 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \n       if (is_conv_op)\n \tix = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-      fndecls = TREE_VEC_ELT (methods, ix);\n+      fndecls = VEC_index (tree, methods, ix);\n       while (fndecls)\n \t{\n \t  fndecl = OVL_CURRENT (fndecls);\n \t  fndecls = OVL_NEXT (fndecls);\n \n \t  if (!fndecls && is_conv_op)\n \t    {\n-\t      if (TREE_VEC_LENGTH (methods) > ix)\n+\t      if (VEC_length (tree, methods) > (size_t) ix)\n \t\t{\n \t\t  ix++;\n-\t\t  fndecls = TREE_VEC_ELT (methods, ix);\n+\t\t  fndecls = VEC_index (tree, methods, ix);\n \t\t  if (!DECL_CONV_FN_P (OVL_CURRENT (fndecls)))\n \t\t    {\n \t\t      fndecls = NULL_TREE;\n@@ -726,7 +726,7 @@ check_classfn (tree ctype, tree function, tree template_parms)\n      case we'll only confuse ourselves when the function is declared\n      properly within the class.  */\n   if (COMPLETE_TYPE_P (ctype))\n-    add_method (ctype, function, /*error_p=*/1);\n+    add_method (ctype, function);\n   return NULL_TREE;\n }\n "}, {"sha": "1a9ecadbd77b1b8685000b5239ae7b4ecaac3ad8", "filename": "gcc/cp/method.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -825,13 +825,7 @@ synthesize_exception_spec (tree type, tree (*extractor) (tree, void*),\n static tree\n locate_dtor (tree type, void *client ATTRIBUTE_UNUSED)\n {\n-  tree fns;\n-  \n-  if (!TYPE_HAS_DESTRUCTOR (type))\n-    return NULL_TREE;\n-  fns = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type),\n-                      CLASSTYPE_DESTRUCTOR_SLOT);\n-  return fns;\n+  return CLASSTYPE_DESTRUCTORS (type);\n }\n \n /* Locate the default ctor of TYPE.  */\n@@ -843,10 +837,8 @@ locate_ctor (tree type, void *client ATTRIBUTE_UNUSED)\n   \n   if (!TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n     return NULL_TREE;\n-  \n-  fns = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type),\n-                      CLASSTYPE_CONSTRUCTOR_SLOT);\n-  for (; fns; fns = OVL_NEXT (fns))\n+\n+  for (fns = CLASSTYPE_CONSTRUCTORS (type); fns; fns = OVL_NEXT (fns))\n     {\n       tree fn = OVL_CURRENT (fns);\n       tree parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n@@ -885,7 +877,7 @@ locate_copy (tree type, void *client_)\n     ix = CLASSTYPE_CONSTRUCTOR_SLOT;\n   if (ix < 0)\n     return NULL_TREE;\n-  fns = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), ix);\n+  fns = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n   \n   for (; fns; fns = OVL_NEXT (fns))\n     {\n@@ -989,6 +981,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   if (raises)\n     fn_type = build_exception_variant (fn_type, raises);\n   fn = build_lang_decl (FUNCTION_DECL, name, fn_type);\n+  DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (TYPE_NAME (type));\n   if (kind == sfk_constructor || kind == sfk_copy_constructor)\n     DECL_CONSTRUCTOR_P (fn) = 1;\n   else if (kind == sfk_destructor)\n@@ -1013,8 +1006,8 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n \t       TYPE_UNQUALIFIED);\n   grok_special_member_properties (fn);\n   TREE_PUBLIC (fn) = !decl_function_context (TYPE_MAIN_DECL (type));\n-  cp_finish_decl (fn, /*init=*/NULL_TREE, /*asmspec_tree=*/NULL_TREE,\n-\t\t  /*flags=*/LOOKUP_ONLYCONVERTING);\n+  rest_of_decl_compilation (fn, /*asmspec=*/NULL,\n+\t\t\t    toplevel_bindings_p (), at_eof);\n   DECL_IN_AGGR_P (fn) = 1;\n   DECL_ARTIFICIAL (fn) = 1;\n   DECL_NOT_REALLY_EXTERN (fn) = 1;"}, {"sha": "4a429d6140bb240521eced941928a9a4d61981b3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -1821,11 +1821,12 @@ check_explicit_specialization (tree declarator,\n \t    {\n \t      idx = lookup_fnfields_1 (ctype, name);\n \t      if (idx >= 0)\n-\t\tfns = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (ctype), idx);\n+\t\tfns = VEC_index (tree, CLASSTYPE_METHOD_VEC (ctype), idx);\n \t    }\n \t  else\n \t    {\n-\t      tree methods;\n+\t      VEC(tree) *methods;\n+\t      tree ovl;\n \n \t      /* For a type-conversion operator, we cannot do a\n \t\t name-based lookup.  We might be looking for `operator\n@@ -1837,11 +1838,10 @@ check_explicit_specialization (tree declarator,\n \t      methods = CLASSTYPE_METHOD_VEC (ctype);\n \t      if (methods)\n \t\tfor (idx = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t\t     idx < TREE_VEC_LENGTH (methods); ++idx) \n+\t\t     (ovl = VEC_iterate (tree, methods, idx));\n+\t\t     ++idx)\n \t\t  {\n-\t\t    tree ovl = TREE_VEC_ELT (methods, idx);\n-\n-\t\t    if (!ovl || !DECL_CONV_FN_P (OVL_CURRENT (ovl)))\n+\t\t    if (!DECL_CONV_FN_P (OVL_CURRENT (ovl)))\n \t\t      /* There are no more conversion functions.  */\n \t\t      break;\n \n@@ -5385,7 +5385,6 @@ instantiate_class_template (tree type)\n   TYPE_GETS_DELETE (type) = TYPE_GETS_DELETE (pattern);\n   TYPE_HAS_ASSIGN_REF (type) = TYPE_HAS_ASSIGN_REF (pattern);\n   TYPE_HAS_CONST_ASSIGN_REF (type) = TYPE_HAS_CONST_ASSIGN_REF (pattern);\n-  TYPE_HAS_ABSTRACT_ASSIGN_REF (type) = TYPE_HAS_ABSTRACT_ASSIGN_REF (pattern);\n   TYPE_HAS_INIT_REF (type) = TYPE_HAS_INIT_REF (pattern);\n   TYPE_HAS_CONST_INIT_REF (type) = TYPE_HAS_CONST_INIT_REF (pattern);\n   TYPE_HAS_DEFAULT_CONSTRUCTOR (type) = TYPE_HAS_DEFAULT_CONSTRUCTOR (pattern);"}, {"sha": "289cb19828d77e5574b1f32908db2107caa16ceb", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -139,8 +139,6 @@ cxx_print_type (FILE *file, tree node, int indent)\n \tfprintf (file, \" interface-only\");\n       if (CLASSTYPE_INTERFACE_UNKNOWN (node))\n \tfprintf (file, \" interface-unknown\");\n-      print_node (file, \"member-functions\", CLASSTYPE_METHOD_VEC (node),\n-\t\t  indent + 4);\n     }\n }\n "}, {"sha": "71a7611f712bfa021b6fbdfa943d7de65438d71b", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -1382,7 +1382,7 @@ emit_support_tinfos (void)\n   pop_nested_namespace (abi_node);\n   if (!COMPLETE_TYPE_P (bltn_type))\n     return;\n-  dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (bltn_type), 1);\n+  dtor = CLASSTYPE_DESTRUCTORS (bltn_type);\n   if (DECL_EXTERNAL (dtor))\n     return;\n   doing_runtime = 1;"}, {"sha": "97b97899e4fad045f44f0160b671e982ecfbf78d", "filename": "gcc/cp/search.c", "status": "modified", "additions": 58, "deletions": 42, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -1060,7 +1060,7 @@ lookup_field_r (tree binfo, void *data)\n     {\n       int idx = lookup_fnfields_1 (type, lfi->name);\n       if (idx >= 0)\n-\tnval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n+\tnval = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), idx);\n     }\n \n   if (!nval)\n@@ -1312,20 +1312,16 @@ lookup_conversion_operator (tree class_type, tree type)\n {\n   int pass;\n   int i;\n+  tree fn;\n+  VEC(tree) *methods;\n \n-  tree methods = CLASSTYPE_METHOD_VEC (class_type);\n+  methods = CLASSTYPE_METHOD_VEC (class_type);\n \n   for (pass = 0; pass < 2; ++pass)\n     for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n-\t i < TREE_VEC_LENGTH (methods);\n+\t (fn = VEC_iterate (tree, methods, i));\n \t ++i)\n       {\n-\ttree fn = TREE_VEC_ELT (methods, i);\n-\t/* The size of the vector may have some unused slots at the\n-\t   end.  */\n-\tif (!fn)\n-\t  break;\n-\n \t/* All the conversion operators come near the beginning of the\n \t   class.  Therefore, if FN is not a conversion operator, there\n \t   is no matching conversion operator in CLASS_TYPE.  */\n@@ -1364,12 +1360,11 @@ lookup_conversion_operator (tree class_type, tree type)\n int\n lookup_fnfields_1 (tree type, tree name)\n {\n-  tree method_vec;\n-  tree *methods;\n+  VEC(tree) *method_vec;\n+  tree fn;\n   tree tmp;\n-  int i;\n-  int len;\n-\n+  size_t i;\n+  \n   if (!CLASS_TYPE_P (type))\n     return -1;\n \n@@ -1378,35 +1373,58 @@ lookup_fnfields_1 (tree type, tree name)\n   if (!method_vec)\n     return -1;\n \n-  methods = &TREE_VEC_ELT (method_vec, 0);\n-  len = TREE_VEC_LENGTH (method_vec);\n-\n #ifdef GATHER_STATISTICS\n   n_calls_lookup_fnfields_1++;\n #endif /* GATHER_STATISTICS */\n \n   /* Constructors are first...  */\n   if (name == ctor_identifier)\n-    return (methods[CLASSTYPE_CONSTRUCTOR_SLOT] \n-\t    ? CLASSTYPE_CONSTRUCTOR_SLOT : -1);\n+    {\n+      fn = CLASSTYPE_CONSTRUCTORS (type);\n+      return fn ? CLASSTYPE_CONSTRUCTOR_SLOT : -1;\n+    }\n   /* and destructors are second.  */\n   if (name == dtor_identifier)\n-    return (methods[CLASSTYPE_DESTRUCTOR_SLOT]\n-\t    ? CLASSTYPE_DESTRUCTOR_SLOT : -1);\n+    {\n+      fn = CLASSTYPE_DESTRUCTORS (type);\n+      return fn ? CLASSTYPE_DESTRUCTOR_SLOT : -1;\n+    }\n   if (IDENTIFIER_TYPENAME_P (name))\n     return lookup_conversion_operator (type, TREE_TYPE (name));\n \n   /* Skip the conversion operators.  */\n-  i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-  while (i < len && methods[i] && DECL_CONV_FN_P (OVL_CURRENT (methods[i])))\n-    i++;\n+  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+       (fn = VEC_iterate (tree, method_vec, i));\n+       ++i)\n+    if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n+      break;\n \n   /* If the type is complete, use binary search.  */\n   if (COMPLETE_TYPE_P (type))\n     {\n-      int lo = i;\n-      int hi = len;\n+      int lo;\n+      int hi;\n+\n+      /* All non-Java classes have \"operator=\" -- but we do not\n+\t actually create the declaration until it is needed.  */\n+      if (name == ansi_assopname(NOP_EXPR)\n+\t  && !TYPE_HAS_ASSIGN_REF (type)\n+\t  && !TYPE_FOR_JAVA (type))\n+\t{\n+\t  tree fn;\n+\n+\t  /* Declare the function.  */\n+\t  fn = implicitly_declare_fn (sfk_assignment_operator, type,\n+\t\t\t\t      TYPE_HAS_CONST_ASSIGN_REF (type));\n+\t  add_method (type, fn);\n+\t  TREE_CHAIN (fn) = TYPE_METHODS (type);\n+\t  TYPE_METHODS (type) = fn;\n+\t  maybe_add_class_template_decl_list (type, fn, /*friend_p=*/0);\n+\t  method_vec = CLASSTYPE_METHOD_VEC (type);\n+\t}\n \n+      lo = i;\n+      hi = VEC_length (tree, method_vec);\n       while (lo < hi)\n \t{\n \t  i = (lo + hi) / 2;\n@@ -1415,13 +1433,9 @@ lookup_fnfields_1 (tree type, tree name)\n \t  n_outer_fields_searched++;\n #endif /* GATHER_STATISTICS */\n \n-\t  tmp = methods[i];\n-\t  /* This slot may be empty; we allocate more slots than we\n-\t     need.  In that case, the entry we're looking for is\n-\t     closer to the beginning of the list.  */\n-\t  if (tmp)\n-\t    tmp = DECL_NAME (OVL_CURRENT (tmp));\n-\t  if (!tmp || tmp > name)\n+\t  tmp = VEC_index (tree, method_vec, i);\n+\t  tmp = DECL_NAME (OVL_CURRENT (tmp));\n+\t  if (tmp > name)\n \t    hi = i;\n \t  else if (tmp < name)\n \t    lo = i + 1;\n@@ -1430,14 +1444,14 @@ lookup_fnfields_1 (tree type, tree name)\n \t}\n     }\n   else\n-    for (; i < len && methods[i]; ++i)\n+    for (; \n+\t (fn = VEC_iterate (tree, method_vec, i));\n+\t ++i)\n       {\n #ifdef GATHER_STATISTICS\n \tn_outer_fields_searched++;\n #endif /* GATHER_STATISTICS */\n-\t\n-\ttmp = OVL_CURRENT (methods[i]);\n-\tif (DECL_NAME (tmp) == name)\n+\tif (DECL_NAME (OVL_CURRENT (fn)) == name)\n \t  return i;\n       }\n \n@@ -1781,7 +1795,7 @@ look_for_overrides_here (tree type, tree fndecl)\n     ix = lookup_fnfields_1 (type, DECL_NAME (fndecl));\n   if (ix >= 0)\n     {\n-      tree fns = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), ix);\n+      tree fns = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), ix);\n   \n       for (; fns; fns = OVL_NEXT (fns))\n         {\n@@ -2050,17 +2064,19 @@ reinit_search_statistics (void)\n static tree\n add_conversions (tree binfo, void *data)\n {\n-  int i;\n-  tree method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n+  size_t i;\n+  VEC(tree) *method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n   tree *conversions = (tree *) data;\n+  tree tmp;\n \n   /* Some builtin types have no method vector, not even an empty one.  */\n   if (!method_vec)\n     return NULL_TREE;\n \n-  for (i = 2; i < TREE_VEC_LENGTH (method_vec); ++i)\n+  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n+       (tmp = VEC_iterate (tree, method_vec, i));\n+       ++i)\n     {\n-      tree tmp = TREE_VEC_ELT (method_vec, i);\n       tree name;\n \n       if (!tmp || ! DECL_CONV_FN_P (OVL_CURRENT (tmp)))"}, {"sha": "6bc7e68f298e9587176942c72649caa3725dec33", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -2154,7 +2154,7 @@ finish_member_declaration (tree decl)\n     {\n       /* We also need to add this function to the\n \t CLASSTYPE_METHOD_VEC.  */\n-      add_method (current_class_type, decl, /*error_p=*/0);\n+      add_method (current_class_type, decl);\n \n       TREE_CHAIN (decl) = TYPE_METHODS (current_class_type);\n       TYPE_METHODS (current_class_type) = decl;"}, {"sha": "6d78c832b24bf0f18462e3df30e3e53dc9836828", "filename": "gcc/vec.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=aaaa46d2b0cb797b68b079e6f7b9deb5bcb4a774", "patch": "@@ -244,6 +244,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    removed object.  This is an O(1) operation.  */\n #define VEC_unordered_remove(TDEF,V,I)\t(VEC_OP(TDEF,unordered_remove)(V,I))\n \n+/* Get the address of the array of elements\n+   T *VEC_T_address (VEC(T) v)\n+\n+   If you need to directly manipulate the array (for instance, you\n+   want to feed it to qsort), use this accessor.  */\n+#define VEC_address(TDEF,V)\t\t(VEC_OP(TDEF,address)(V))\n+\n #if !IN_GENGTYPE\n /* Reallocate an array of elements with prefix.  */\n extern void *vec_p_reserve (void *, int MEM_STAT_DECL);\n@@ -449,6 +456,12 @@ static inline TDEF VEC_OP (TDEF,unordered_remove)\t\t\t  \\\n   return obj_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,address)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_)\t\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_ ? vec_->vec : 0;\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n struct vec_swallow_trailing_semi\n #endif\n \n@@ -612,6 +625,12 @@ static inline void VEC_OP (TDEF,unordered_remove)\t\t\t  \\\n   vec_->vec[ix_] = vec_->vec[--vec_->num];\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline TDEF *VEC_OP (TDEF,address)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_)\t\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_ ? vec_->vec : 0;\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n struct vec_swallow_trailing_semi\n #endif\n "}]}