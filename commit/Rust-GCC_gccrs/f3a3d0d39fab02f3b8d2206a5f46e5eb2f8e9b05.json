{"sha": "f3a3d0d39fab02f3b8d2206a5f46e5eb2f8e9b05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNhM2QwZDM5ZmFiMDJmM2I4ZDIyMDZhNWY0NmU1ZWIyZjhlOWIwNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-02T18:07:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-02T18:07:49Z"}, "message": "* md.texi (define_peephole2): New section.\n\nFrom-SVN: r29772", "tree": {"sha": "aed41d502772f3f65f5bb0758a246d5a4b1baba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aed41d502772f3f65f5bb0758a246d5a4b1baba9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3a3d0d39fab02f3b8d2206a5f46e5eb2f8e9b05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3a3d0d39fab02f3b8d2206a5f46e5eb2f8e9b05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3a3d0d39fab02f3b8d2206a5f46e5eb2f8e9b05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3a3d0d39fab02f3b8d2206a5f46e5eb2f8e9b05/comments", "author": null, "committer": null, "parents": [{"sha": "ffab8d8591430b98b70001d968784f7014ecd1b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffab8d8591430b98b70001d968784f7014ecd1b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffab8d8591430b98b70001d968784f7014ecd1b9"}], "stats": {"total": 531, "additions": 319, "deletions": 212}, "files": [{"sha": "9af40180f9e3fa9719aeff92d660fc8a62913ea6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a3d0d39fab02f3b8d2206a5f46e5eb2f8e9b05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a3d0d39fab02f3b8d2206a5f46e5eb2f8e9b05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3a3d0d39fab02f3b8d2206a5f46e5eb2f8e9b05", "patch": "@@ -1,3 +1,7 @@\n+Sat Oct  2 11:06:31 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* md.texi (define_peephole2): New section.\n+\n Sat Oct  2 10:57:56 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \n \t* i386.md (mov?i patterns): Fix handling of TARGET_USE_MOV0"}, {"sha": "8242ea03bfa027f6f0c6af29ba014f917ad283b7", "filename": "gcc/md.texi", "status": "modified", "additions": 315, "deletions": 212, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a3d0d39fab02f3b8d2206a5f46e5eb2f8e9b05/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a3d0d39fab02f3b8d2206a5f46e5eb2f8e9b05/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=f3a3d0d39fab02f3b8d2206a5f46e5eb2f8e9b05", "patch": "@@ -32,10 +32,10 @@ See the next chapter for information on the C header file.\n * Dependent Patterns::  Having one pattern may make you need another.\n * Jump Patterns::       Special considerations for patterns for jump insns.\n * Insn Canonicalizations::Canonicalization of Instructions\n-* Peephole Definitions::Defining machine-specific peephole optimizations.\n * Expander Definitions::Generating a sequence of several RTL insns\n-                         for a standard operation.\n-* Insn Splitting::    Splitting Instructions into Multiple Instructions\n+                          for a standard operation.\n+* Insn Splitting::      Splitting Instructions into Multiple Instructions.\n+* Peephole Definitions::Defining machine-specific peephole optimizations.\n * Insn Attributes::     Specifying the value of attributes for generated insns.\n @end menu\n \n@@ -2907,210 +2907,6 @@ will be written using @code{zero_extract} rather than the equivalent\n \n @end itemize\n \n-@node Peephole Definitions\n-@section Machine-Specific Peephole Optimizers\n-@cindex peephole optimizer definitions\n-@cindex defining peephole optimizers\n-\n-In addition to instruction patterns the @file{md} file may contain\n-definitions of machine-specific peephole optimizations.\n-\n-The combiner does not notice certain peephole optimizations when the data\n-flow in the program does not suggest that it should try them.  For example,\n-sometimes two consecutive insns related in purpose can be combined even\n-though the second one does not appear to use a register computed in the\n-first one.  A machine-specific peephole optimizer can detect such\n-opportunities.\n-\n-@need 1000\n-A definition looks like this:\n-\n-@smallexample\n-(define_peephole\n-  [@var{insn-pattern-1}\n-   @var{insn-pattern-2}\n-   @dots{}]\n-  \"@var{condition}\"\n-  \"@var{template}\"\n-  \"@var{optional insn-attributes}\")\n-@end smallexample\n-\n-@noindent\n-The last string operand may be omitted if you are not using any\n-machine-specific information in this machine description.  If present,\n-it must obey the same rules as in a @code{define_insn}.\n-\n-In this skeleton, @var{insn-pattern-1} and so on are patterns to match\n-consecutive insns.  The optimization applies to a sequence of insns when\n-@var{insn-pattern-1} matches the first one, @var{insn-pattern-2} matches\n-the next, and so on.@refill\n-\n-Each of the insns matched by a peephole must also match a\n-@code{define_insn}.  Peepholes are checked only at the last stage just\n-before code generation, and only optionally.  Therefore, any insn which\n-would match a peephole but no @code{define_insn} will cause a crash in code\n-generation in an unoptimized compilation, or at various optimization\n-stages.\n-\n-The operands of the insns are matched with @code{match_operands},\n-@code{match_operator}, and @code{match_dup}, as usual.  What is not\n-usual is that the operand numbers apply to all the insn patterns in the\n-definition.  So, you can check for identical operands in two insns by\n-using @code{match_operand} in one insn and @code{match_dup} in the\n-other.\n-\n-The operand constraints used in @code{match_operand} patterns do not have\n-any direct effect on the applicability of the peephole, but they will\n-be validated afterward, so make sure your constraints are general enough\n-to apply whenever the peephole matches.  If the peephole matches\n-but the constraints are not satisfied, the compiler will crash.\n-\n-It is safe to omit constraints in all the operands of the peephole; or\n-you can write constraints which serve as a double-check on the criteria\n-previously tested.\n-\n-Once a sequence of insns matches the patterns, the @var{condition} is\n-checked.  This is a C expression which makes the final decision whether to\n-perform the optimization (we do so if the expression is nonzero).  If\n-@var{condition} is omitted (in other words, the string is empty) then the\n-optimization is applied to every sequence of insns that matches the\n-patterns.\n-\n-The defined peephole optimizations are applied after register allocation\n-is complete.  Therefore, the peephole definition can check which\n-operands have ended up in which kinds of registers, just by looking at\n-the operands.\n-\n-@findex prev_active_insn\n-The way to refer to the operands in @var{condition} is to write\n-@code{operands[@var{i}]} for operand number @var{i} (as matched by\n-@code{(match_operand @var{i} @dots{})}).  Use the variable @code{insn}\n-to refer to the last of the insns being matched; use\n-@code{prev_active_insn} to find the preceding insns.\n-\n-@findex dead_or_set_p\n-When optimizing computations with intermediate results, you can use\n-@var{condition} to match only when the intermediate results are not used\n-elsewhere.  Use the C expression @code{dead_or_set_p (@var{insn},\n-@var{op})}, where @var{insn} is the insn in which you expect the value\n-to be used for the last time (from the value of @code{insn}, together\n-with use of @code{prev_nonnote_insn}), and @var{op} is the intermediate\n-value (from @code{operands[@var{i}]}).@refill\n-\n-Applying the optimization means replacing the sequence of insns with one\n-new insn.  The @var{template} controls ultimate output of assembler code\n-for this combined insn.  It works exactly like the template of a\n-@code{define_insn}.  Operand numbers in this template are the same ones\n-used in matching the original sequence of insns.\n-\n-The result of a defined peephole optimizer does not need to match any of\n-the insn patterns in the machine description; it does not even have an\n-opportunity to match them.  The peephole optimizer definition itself serves\n-as the insn pattern to control how the insn is output.\n-\n-Defined peephole optimizers are run as assembler code is being output,\n-so the insns they produce are never combined or rearranged in any way.\n-\n-Here is an example, taken from the 68000 machine description:\n-\n-@smallexample\n-(define_peephole\n-  [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))\n-   (set (match_operand:DF 0 \"register_operand\" \"=f\")\n-        (match_operand:DF 1 \"register_operand\" \"ad\"))]\n-  \"FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])\"\n-  \"*\n-@{\n-  rtx xoperands[2];\n-  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n-#ifdef MOTOROLA\n-  output_asm_insn (\\\"move.l %1,(sp)\\\", xoperands);\n-  output_asm_insn (\\\"move.l %1,-(sp)\\\", operands);\n-  return \\\"fmove.d (sp)+,%0\\\";\n-#else\n-  output_asm_insn (\\\"movel %1,sp@@\\\", xoperands);\n-  output_asm_insn (\\\"movel %1,sp@@-\\\", operands);\n-  return \\\"fmoved sp@@+,%0\\\";\n-#endif\n-@}\n-\")\n-@end smallexample\n-\n-@need 1000\n-The effect of this optimization is to change\n-\n-@smallexample\n-@group\n-jbsr _foobar\n-addql #4,sp\n-movel d1,sp@@-\n-movel d0,sp@@-\n-fmoved sp@@+,fp0\n-@end group\n-@end smallexample\n-\n-@noindent\n-into\n-\n-@smallexample\n-@group\n-jbsr _foobar\n-movel d1,sp@@\n-movel d0,sp@@-\n-fmoved sp@@+,fp0\n-@end group\n-@end smallexample\n-\n-@ignore\n-@findex CC_REVERSED\n-If a peephole matches a sequence including one or more jump insns, you must\n-take account of the flags such as @code{CC_REVERSED} which specify that the\n-condition codes are represented in an unusual manner.  The compiler\n-automatically alters any ordinary conditional jumps which occur in such\n-situations, but the compiler cannot alter jumps which have been replaced by\n-peephole optimizations.  So it is up to you to alter the assembler code\n-that the peephole produces.  Supply C code to write the assembler output,\n-and in this C code check the condition code status flags and change the\n-assembler code as appropriate.\n-@end ignore\n-\n-@var{insn-pattern-1} and so on look @emph{almost} like the second\n-operand of @code{define_insn}.  There is one important difference: the\n-second operand of @code{define_insn} consists of one or more RTX's\n-enclosed in square brackets.  Usually, there is only one: then the same\n-action can be written as an element of a @code{define_peephole}.  But\n-when there are multiple actions in a @code{define_insn}, they are\n-implicitly enclosed in a @code{parallel}.  Then you must explicitly\n-write the @code{parallel}, and the square brackets within it, in the\n-@code{define_peephole}.  Thus, if an insn pattern looks like this,\n-\n-@smallexample\n-(define_insn \"divmodsi4\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-        (div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-                (match_operand:SI 2 \"general_operand\" \"dmsK\")))\n-   (set (match_operand:SI 3 \"general_operand\" \"=d\")\n-        (mod:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_68020\"\n-  \"divsl%.l %2,%3:%0\")\n-@end smallexample\n-\n-@noindent\n-then the way to mention this insn in a peephole is as follows:\n-\n-@smallexample\n-(define_peephole\n-  [@dots{}\n-   (parallel\n-    [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-          (div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-                  (match_operand:SI 2 \"general_operand\" \"dmsK\")))\n-     (set (match_operand:SI 3 \"general_operand\" \"=d\")\n-          (mod:SI (match_dup 1) (match_dup 2)))])\n-   @dots{}]\n-  @dots{})\n-@end smallexample\n-\n @node Expander Definitions\n @section Defining RTL Sequences for Code Generation\n @cindex expander definitions\n@@ -3134,11 +2930,10 @@ A @code{define_expand} RTX has four operands:\n The name.  Each @code{define_expand} must have a name, since the only\n use for it is to refer to it by name.\n \n-@findex define_peephole\n @item\n-The RTL template.  This is just like the RTL template for a\n-@code{define_peephole} in that it is a vector of RTL expressions\n-each being one insn.\n+The RTL template.  This is a vector of RTL expressions representing\n+a sequence of separate instructions.  Unlike @code{define_insn}, there\n+is no implicit surrounding @code{PARALLEL}.\n \n @item\n The condition, a string containing a C expression.  This expression is\n@@ -3333,7 +3128,7 @@ subexpression.  However, in some other cases, such as performing an\n addition of a large constant in two insns on a RISC machine, the way to\n split the addition into two insns is machine-dependent.\n \n-@cindex define_split\n+@findex define_split\n The @code{define_split} definition tells the compiler how to split a\n complex insn into several simpler insns.  It looks like this:\n \n@@ -3466,6 +3261,314 @@ insns that don't.  Instead, write two separate @code{define_split}\n definitions, one for the insns that are valid and one for the insns that\n are not valid.\n \n+@node Peephole Definitions\n+@section Machine-Specific Peephole Optimizers\n+@cindex peephole optimizer definitions\n+@cindex defining peephole optimizers\n+\n+In addition to instruction patterns the @file{md} file may contain\n+definitions of machine-specific peephole optimizations.\n+\n+The combiner does not notice certain peephole optimizations when the data\n+flow in the program does not suggest that it should try them.  For example,\n+sometimes two consecutive insns related in purpose can be combined even\n+though the second one does not appear to use a register computed in the\n+first one.  A machine-specific peephole optimizer can detect such\n+opportunities.\n+\n+There are two forms of peephole definitions that may be used.  The\n+original @code{define_peephole} is run at assembly output time to\n+match insns and substitute assembly text.  Use of @code{define_peephole}\n+is deprecated.\n+\n+A newer @code{define_peephole2} matches insns and substitutes new\n+insns.  The @code{peephole2} pass is run after register allocation\n+but before scheduling, which may result in much better code for \n+targets that do scheduling.\n+\n+@menu\n+* define_peephole::     RTL to Text Peephole Optimizers\n+* define_peephole2::    RTL to RTL Peephole Optimizers\n+@end menu\n+\n+@node define_peephole\n+@subsection RTL to Text Peephole Optimizers\n+@findex define_peephole\n+\n+@need 1000\n+A definition looks like this:\n+\n+@smallexample\n+(define_peephole\n+  [@var{insn-pattern-1}\n+   @var{insn-pattern-2}\n+   @dots{}]\n+  \"@var{condition}\"\n+  \"@var{template}\"\n+  \"@var{optional insn-attributes}\")\n+@end smallexample\n+\n+@noindent\n+The last string operand may be omitted if you are not using any\n+machine-specific information in this machine description.  If present,\n+it must obey the same rules as in a @code{define_insn}.\n+\n+In this skeleton, @var{insn-pattern-1} and so on are patterns to match\n+consecutive insns.  The optimization applies to a sequence of insns when\n+@var{insn-pattern-1} matches the first one, @var{insn-pattern-2} matches\n+the next, and so on.@refill\n+\n+Each of the insns matched by a peephole must also match a\n+@code{define_insn}.  Peepholes are checked only at the last stage just\n+before code generation, and only optionally.  Therefore, any insn which\n+would match a peephole but no @code{define_insn} will cause a crash in code\n+generation in an unoptimized compilation, or at various optimization\n+stages.\n+\n+The operands of the insns are matched with @code{match_operands},\n+@code{match_operator}, and @code{match_dup}, as usual.  What is not\n+usual is that the operand numbers apply to all the insn patterns in the\n+definition.  So, you can check for identical operands in two insns by\n+using @code{match_operand} in one insn and @code{match_dup} in the\n+other.\n+\n+The operand constraints used in @code{match_operand} patterns do not have\n+any direct effect on the applicability of the peephole, but they will\n+be validated afterward, so make sure your constraints are general enough\n+to apply whenever the peephole matches.  If the peephole matches\n+but the constraints are not satisfied, the compiler will crash.\n+\n+It is safe to omit constraints in all the operands of the peephole; or\n+you can write constraints which serve as a double-check on the criteria\n+previously tested.\n+\n+Once a sequence of insns matches the patterns, the @var{condition} is\n+checked.  This is a C expression which makes the final decision whether to\n+perform the optimization (we do so if the expression is nonzero).  If\n+@var{condition} is omitted (in other words, the string is empty) then the\n+optimization is applied to every sequence of insns that matches the\n+patterns.\n+\n+The defined peephole optimizations are applied after register allocation\n+is complete.  Therefore, the peephole definition can check which\n+operands have ended up in which kinds of registers, just by looking at\n+the operands.\n+\n+@findex prev_active_insn\n+The way to refer to the operands in @var{condition} is to write\n+@code{operands[@var{i}]} for operand number @var{i} (as matched by\n+@code{(match_operand @var{i} @dots{})}).  Use the variable @code{insn}\n+to refer to the last of the insns being matched; use\n+@code{prev_active_insn} to find the preceding insns.\n+\n+@findex dead_or_set_p\n+When optimizing computations with intermediate results, you can use\n+@var{condition} to match only when the intermediate results are not used\n+elsewhere.  Use the C expression @code{dead_or_set_p (@var{insn},\n+@var{op})}, where @var{insn} is the insn in which you expect the value\n+to be used for the last time (from the value of @code{insn}, together\n+with use of @code{prev_nonnote_insn}), and @var{op} is the intermediate\n+value (from @code{operands[@var{i}]}).@refill\n+\n+Applying the optimization means replacing the sequence of insns with one\n+new insn.  The @var{template} controls ultimate output of assembler code\n+for this combined insn.  It works exactly like the template of a\n+@code{define_insn}.  Operand numbers in this template are the same ones\n+used in matching the original sequence of insns.\n+\n+The result of a defined peephole optimizer does not need to match any of\n+the insn patterns in the machine description; it does not even have an\n+opportunity to match them.  The peephole optimizer definition itself serves\n+as the insn pattern to control how the insn is output.\n+\n+Defined peephole optimizers are run as assembler code is being output,\n+so the insns they produce are never combined or rearranged in any way.\n+\n+Here is an example, taken from the 68000 machine description:\n+\n+@smallexample\n+(define_peephole\n+  [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))\n+   (set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (match_operand:DF 1 \"register_operand\" \"ad\"))]\n+  \"FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])\"\n+  \"*\n+@{\n+  rtx xoperands[2];\n+  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+#ifdef MOTOROLA\n+  output_asm_insn (\\\"move.l %1,(sp)\\\", xoperands);\n+  output_asm_insn (\\\"move.l %1,-(sp)\\\", operands);\n+  return \\\"fmove.d (sp)+,%0\\\";\n+#else\n+  output_asm_insn (\\\"movel %1,sp@@\\\", xoperands);\n+  output_asm_insn (\\\"movel %1,sp@@-\\\", operands);\n+  return \\\"fmoved sp@@+,%0\\\";\n+#endif\n+@}\n+\")\n+@end smallexample\n+\n+@need 1000\n+The effect of this optimization is to change\n+\n+@smallexample\n+@group\n+jbsr _foobar\n+addql #4,sp\n+movel d1,sp@@-\n+movel d0,sp@@-\n+fmoved sp@@+,fp0\n+@end group\n+@end smallexample\n+\n+@noindent\n+into\n+\n+@smallexample\n+@group\n+jbsr _foobar\n+movel d1,sp@@\n+movel d0,sp@@-\n+fmoved sp@@+,fp0\n+@end group\n+@end smallexample\n+\n+@ignore\n+@findex CC_REVERSED\n+If a peephole matches a sequence including one or more jump insns, you must\n+take account of the flags such as @code{CC_REVERSED} which specify that the\n+condition codes are represented in an unusual manner.  The compiler\n+automatically alters any ordinary conditional jumps which occur in such\n+situations, but the compiler cannot alter jumps which have been replaced by\n+peephole optimizations.  So it is up to you to alter the assembler code\n+that the peephole produces.  Supply C code to write the assembler output,\n+and in this C code check the condition code status flags and change the\n+assembler code as appropriate.\n+@end ignore\n+\n+@var{insn-pattern-1} and so on look @emph{almost} like the second\n+operand of @code{define_insn}.  There is one important difference: the\n+second operand of @code{define_insn} consists of one or more RTX's\n+enclosed in square brackets.  Usually, there is only one: then the same\n+action can be written as an element of a @code{define_peephole}.  But\n+when there are multiple actions in a @code{define_insn}, they are\n+implicitly enclosed in a @code{parallel}.  Then you must explicitly\n+write the @code{parallel}, and the square brackets within it, in the\n+@code{define_peephole}.  Thus, if an insn pattern looks like this,\n+\n+@smallexample\n+(define_insn \"divmodsi4\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+        (div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+                (match_operand:SI 2 \"general_operand\" \"dmsK\")))\n+   (set (match_operand:SI 3 \"general_operand\" \"=d\")\n+        (mod:SI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_68020\"\n+  \"divsl%.l %2,%3:%0\")\n+@end smallexample\n+\n+@noindent\n+then the way to mention this insn in a peephole is as follows:\n+\n+@smallexample\n+(define_peephole\n+  [@dots{}\n+   (parallel\n+    [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+          (div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+                  (match_operand:SI 2 \"general_operand\" \"dmsK\")))\n+     (set (match_operand:SI 3 \"general_operand\" \"=d\")\n+          (mod:SI (match_dup 1) (match_dup 2)))])\n+   @dots{}]\n+  @dots{})\n+@end smallexample\n+\n+@node define_peephole2\n+@subsection RTL to RTL Peephole Optimizers\n+@findex define_peephole2\n+\n+The @code{define_peephole2} definition tells the compiler how to\n+substitute one sequence of instructions for another sequence, \n+what additional scratch registers may be needed and what their\n+lifetimes must be.\n+\n+@smallexample\n+(define_peephole2\n+  [@var{insn-pattern-1}\n+   @var{insn-pattern-2}\n+   @dots{}]\n+  \"@var{condition}\"\n+  [@var{new-insn-pattern-1}\n+   @var{new-insn-pattern-2}\n+   @dots{}]\n+  \"@var{preparation statements}\")\n+@end smallexample\n+\n+The definition is almost identical to @code{define_split}\n+(@pxref{Insn Splitting}) except that the pattern to match is not a\n+single instruction, but a sequence of instructions.\n+\n+It is possible to request additional scratch registers for use in the\n+output template.  If appropriate registers are not free, the pattern\n+will simply not match.\n+\n+@findex match_scratch\n+@findex match_dup\n+Scratch registers are requested with a @code{match_scratch} pattern at\n+the top level of the input pattern.  The allocated register (initially) will\n+be dead at the point requested within the original sequence.  If the scratch\n+is used at more than a single point, a @code{match_dup} pattern at the\n+top level of the input pattern marks the last position in the input sequence\n+at which the register must be available.\n+\n+Here is an example from the IA-32 machine description:\n+\n+@smallexample\n+(define_peephole2\n+  [(match_scratch:SI 2 \"r\")\n+   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+                   (match_operator:SI 3 \"arith_or_logical_operator\"\n+                     [(match_dup 0)\n+                      (match_operand:SI 1 \"memory_operand\" \"\")]))\n+              (clobber (reg:CC 17))])]\n+  \"! optimize_size && ! TARGET_READ_MODIFY\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (parallel [(set (match_dup 0)\n+                   (match_op_dup 3 [(match_dup 0) (match_dup 2)]))\n+              (clobber (reg:CC 17))])]\n+  \"\")\n+@end smallexample\n+\n+@noindent\n+This pattern tries to split a load from its use in the hopes that we'll be\n+able to schedule around the memory load latency.  It allocates a single\n+@code{SImode} register of class @code{GENERAL_REGS} (@code{\"r\"}) that needs\n+to be live only at the point just before the arithmetic.\n+\n+A real example requring extended scratch lifetimes is harder to come by,\n+so here's a silly made-up example:\n+\n+@smallexample\n+(define_peephole2\n+  [(match_scratch:SI 4 \"r\")\n+   (set (match_operand:SI 0 \"\" \"\") (match_operand:SI 1 \"\" \"\"))\n+   (set (match_operand:SI 2 \"\" \"\") (match_dup 1))\n+   (match_dup 4)\n+   (set (match_operand:SI 3 \"\" \"\") (match_dup 1))]\n+  \"@var{determine 1 does not overlap 0 and 2}\"\n+  [(set (match_dup 4) (match_dup 1))\n+   (set (match_dup 0) (match_dup 4))\n+   (set (match_dup 2) (match_dup 4))]\n+   (set (match_dup 3) (match_dup 4))]\n+  \"\")\n+@end smallexample\n+\n+@noindent\n+If we had not added the @code{(match_dup 3)} at the end of the sequence,\n+it might have been the case that the register we chose at the beginning\n+of the sequence is killed by the first or second @code{set}.\n+\n @node Insn Attributes\n @section Instruction Attributes\n @cindex insn attributes"}]}