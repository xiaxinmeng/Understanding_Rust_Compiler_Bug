{"sha": "ddfabf89bbf2d7295725609ac997490160adf8fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRmYWJmODliYmYyZDcyOTU3MjU2MDlhYzk5NzQ5MDE2MGFkZjhmYw==", "commit": {"author": {"name": "Frank Ch. Eigler", "email": "fche@redhat.com", "date": "2004-10-13T18:27:16Z"}, "committer": {"name": "Frank Ch. Eigler", "email": "fche@gcc.gnu.org", "date": "2004-10-13T18:27:16Z"}, "message": "configure.ac: Check for more headers, functions.\n\n2004-10-12  Frank Ch. Eigler  <fche@redhat.com>\n\n\t* configure.ac: Check for more headers, functions.\n\t* mf-hooks2.c (mkbuffer, unmkbuffer): New helper functions for\n\ttracking overridden FILE buffers.\n\t(fopen, setvbuf): New/revised hook functions for buffer overriding.\n\t(setbuf,setlinebuf,fdopen,freopen,fopen64,freopen64,fclose): Ditto.\n\t(fflush): Accept given NULL stream (means \"all streams\").\n\t* mf-runtime.h.in:\n\t* mf-runtime.c (__mfu_check): Accept accesses that span adjacent\n\tHEAP/GUESS objects.\n\t(LOOKUP_CACHE_SIZE_MAX): Raise to 64K entries tentatively.\n\t(__mf_adapt_cache): Use them all.\n\t* testsuite/libmudflap.c/pass35-frag.c: Update warning message.\n\t* testsuite/libmudflap.c++/ctors.exp: Ditto.\n\t* testsuite/libmudflap.c/{pass51,pass52}-frag.c: New tests.\n\t* configure, config.h.in: Regenerated.\n\nFrom-SVN: r88996", "tree": {"sha": "5ba143b308278286023d43a624647837da8e9cbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ba143b308278286023d43a624647837da8e9cbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddfabf89bbf2d7295725609ac997490160adf8fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddfabf89bbf2d7295725609ac997490160adf8fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddfabf89bbf2d7295725609ac997490160adf8fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddfabf89bbf2d7295725609ac997490160adf8fc/comments", "author": {"login": "fche", "id": 588885, "node_id": "MDQ6VXNlcjU4ODg4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/588885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fche", "html_url": "https://github.com/fche", "followers_url": "https://api.github.com/users/fche/followers", "following_url": "https://api.github.com/users/fche/following{/other_user}", "gists_url": "https://api.github.com/users/fche/gists{/gist_id}", "starred_url": "https://api.github.com/users/fche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fche/subscriptions", "organizations_url": "https://api.github.com/users/fche/orgs", "repos_url": "https://api.github.com/users/fche/repos", "events_url": "https://api.github.com/users/fche/events{/privacy}", "received_events_url": "https://api.github.com/users/fche/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ccab73c3b7c38e3c7ac7e3a0b37f063856575953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccab73c3b7c38e3c7ac7e3a0b37f063856575953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccab73c3b7c38e3c7ac7e3a0b37f063856575953"}], "stats": {"total": 531, "additions": 492, "deletions": 39}, "files": [{"sha": "ee4feac614e73699750544faa63a868a69a3ca0a", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=ddfabf89bbf2d7295725609ac997490160adf8fc", "patch": "@@ -1,3 +1,21 @@\n+2004-10-12  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* configure.ac: Check for more headers, functions.\n+\t* mf-hooks2.c (mkbuffer, unmkbuffer): New helper functions for\n+\ttracking overridden FILE buffers.\n+\t(fopen, setvbuf): New/revised hook functions for buffer overriding.\n+\t(setbuf,setlinebuf,fdopen,freopen,fopen64,freopen64,fclose): Ditto.\n+\t(fflush): Accept given NULL stream (means \"all streams\").\n+\t* mf-runtime.h.in: \n+\t* mf-runtime.c (__mfu_check): Accept accesses that span adjacent\n+\tHEAP/GUESS objects.\n+\t(LOOKUP_CACHE_SIZE_MAX): Raise to 64K entries tentatively.\n+\t(__mf_adapt_cache): Use them all.\n+\t* testsuite/libmudflap.c/pass35-frag.c: Update warning message.\n+\t* testsuite/libmudflap.c++/ctors.exp: Ditto.\n+\t* testsuite/libmudflap.c/{pass51,pass52}-frag.c: New tests.\n+\t* configure, config.h.in: Regenerated.\n+\n 2004-10-05  Frank Ch. Eigler  <fche@redhat.com>\n \n \t* configure.ac: Checking for sys/socket.h once is enough."}, {"sha": "7685b575c26dbc0ae8b4df4c3ed65952d23e0317", "filename": "libmudflap/config.h.in", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fconfig.h.in?ref=ddfabf89bbf2d7295725609ac997490160adf8fc", "patch": "@@ -33,6 +33,9 @@\n /* Define to 1 if you have the `fopen64' function. */\n #undef HAVE_FOPEN64\n \n+/* Define to 1 if you have the `freopen64' function. */\n+#undef HAVE_FREOPEN64\n+\n /* Define to 1 if you have the `fseeko64' function. */\n #undef HAVE_FSEEKO64\n \n@@ -126,9 +129,15 @@\n /* Define to 1 if you have the `memrchr' function. */\n #undef HAVE_MEMRCHR\n \n+/* Define to 1 if you have the `mmap' function. */\n+#undef HAVE_MMAP\n+\n /* Define to 1 if you have the <mntent.h> header file. */\n #undef HAVE_MNTENT_H\n \n+/* Define to 1 if you have the `munmap' function. */\n+#undef HAVE_MUNMAP\n+\n /* Define to 1 if you have the <netdb.h> header file. */\n #undef HAVE_NETDB_H\n \n@@ -141,12 +150,24 @@\n /* Define to 1 if you have the <pwd.h> header file. */\n #undef HAVE_PWD_H\n \n+/* Define to 1 if you have the `setbuf' function. */\n+#undef HAVE_SETBUF\n+\n+/* Define to 1 if you have the `setbuffer' function. */\n+#undef HAVE_SETBUFFER\n+\n /* Define to 1 if you have the `sethostname' function. */\n #undef HAVE_SETHOSTNAME\n \n+/* Define to 1 if you have the `setlinebuf' function. */\n+#undef HAVE_SETLINEBUF\n+\n /* Define to 1 if you have the `setmntent' function. */\n #undef HAVE_SETMNTENT\n \n+/* Define to 1 if you have the `setvbuf' function. */\n+#undef HAVE_SETVBUF\n+\n /* Define to 1 if you have the `signal' function. */\n #undef HAVE_SIGNAL\n \n@@ -180,6 +201,9 @@\n /* Define to 1 if you have the <sys/ipc.h> header file. */\n #undef HAVE_SYS_IPC_H\n \n+/* Define to 1 if you have the <sys/mman.h> header file. */\n+#undef HAVE_SYS_MMAN_H\n+\n /* Define to 1 if you have the <sys/sem.h> header file. */\n #undef HAVE_SYS_SEM_H\n "}, {"sha": "0b51fe5ae5d10027777ece9d64b859212bdc4d41", "filename": "libmudflap/configure", "status": "modified", "additions": 113, "deletions": 4, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fconfigure?ref=ddfabf89bbf2d7295725609ac997490160adf8fc", "patch": "@@ -3596,10 +3596,11 @@ done\n \n \n \n+\n \n for ac_header in stdint.h execinfo.h signal.h dlfcn.h dirent.h pwd.h grp.h \\\n   netdb.h sys/ipc.h sys/sem.h sys/shm.h sys/wait.h ctype.h mntent.h \\\n-  sys/socket.h netinet/in.h arpa/inet.h dlfcn.h\n+  sys/socket.h netinet/in.h arpa/inet.h dlfcn.h sys/mman.h\n do\n as_ac_Header=`echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n if eval \"test \\\"\\${$as_ac_Header+set}\\\" = set\"; then\n@@ -3858,7 +3859,113 @@ done\n \n \n \n-for ac_func in fopen64 fseeko64 ftello64 stat64\n+\n+for ac_func in fopen64 fseeko64 ftello64 stat64 freopen64\n+do\n+as_ac_var=`echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n+echo \"$as_me:$LINENO: checking for $ac_func\" >&5\n+echo $ECHO_N \"checking for $ac_func... $ECHO_C\" >&6\n+if eval \"test \\\"\\${$as_ac_var+set}\\\" = set\"; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.\n+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */\n+#define $ac_func innocuous_$ac_func\n+\n+/* System header to define __stub macros and hopefully few prototypes,\n+    which can conflict with char $ac_func (); below.\n+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since\n+    <limits.h> exists even on freestanding compilers.  */\n+\n+#ifdef __STDC__\n+# include <limits.h>\n+#else\n+# include <assert.h>\n+#endif\n+\n+#undef $ac_func\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char $ac_func ();\n+/* The GNU C library defines this for functions which it implements\n+    to always fail with ENOSYS.  Some functions are actually named\n+    something starting with __ and the normal name is an alias.  */\n+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)\n+choke me\n+#else\n+char (*f) () = $ac_func;\n+#endif\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+int\n+main ()\n+{\n+return f != $ac_func;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  eval \"$as_ac_var=yes\"\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+eval \"$as_ac_var=no\"\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`\" >&5\n+echo \"${ECHO_T}`eval echo '${'$as_ac_var'}'`\" >&6\n+if test `eval echo '${'$as_ac_var'}'` = yes; then\n+  cat >>confdefs.h <<_ACEOF\n+#define `echo \"HAVE_$ac_func\" | $as_tr_cpp` 1\n+_ACEOF\n+\n+fi\n+done\n+\n+\n+\n+\n+\n+for ac_func in setbuf setbuffer setlinebuf setvbuf\n do\n as_ac_var=`echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n echo \"$as_me:$LINENO: checking for $ac_func\" >&5\n@@ -4699,7 +4806,9 @@ fi\n done\n \n \n-for ac_func in inet_ntoa\n+\n+\n+for ac_func in inet_ntoa mmap munmap\n do\n as_ac_var=`echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n echo \"$as_me:$LINENO: checking for $ac_func\" >&5\n@@ -5656,7 +5765,7 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 5659 \"configure\"' > conftest.$ac_ext\n+  echo '#line 5768 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?"}, {"sha": "9310b35c94674dd22ceb573dc0a08a256821b48d", "filename": "libmudflap/configure.ac", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fconfigure.ac?ref=ddfabf89bbf2d7295725609ac997490160adf8fc", "patch": "@@ -61,18 +61,19 @@ enable_shared=no])\n \n AC_CHECK_HEADERS(stdint.h execinfo.h signal.h dlfcn.h dirent.h pwd.h grp.h \\\n   netdb.h sys/ipc.h sys/sem.h sys/shm.h sys/wait.h ctype.h mntent.h \\\n-  sys/socket.h netinet/in.h arpa/inet.h dlfcn.h)\n+  sys/socket.h netinet/in.h arpa/inet.h dlfcn.h sys/mman.h)\n \n AC_CHECK_FUNCS(backtrace backtrace_symbols gettimeofday signal)\n-AC_CHECK_FUNCS(fopen64 fseeko64 ftello64 stat64)\n+AC_CHECK_FUNCS(fopen64 fseeko64 ftello64 stat64 freopen64)\n+AC_CHECK_FUNCS(setbuf setbuffer setlinebuf setvbuf)\n AC_CHECK_FUNCS(strnlen memrchr strncpy memmem sethostname)\n AC_CHECK_FUNCS(__ctype_b_loc __ctype_tolower_loc __ctype_toupper_loc)\n AC_CHECK_FUNCS(getlogin cuserid getpwnam getpwuid getpwent getgrnam getgrgid getgrent)\n AC_CHECK_FUNCS(getlogin_r getpwnam_r getpwuid_r getgrnam_r getgrgid_r)\n AC_CHECK_FUNCS(getservent getservbyname getservbyport getaddrinfo gai_strerror)\n AC_CHECK_FUNCS(getprotoent getprotobyname getprotobynumber)\n AC_CHECK_FUNCS(getmntent setmntent addmntent)\n-AC_CHECK_FUNCS(inet_ntoa)\n+AC_CHECK_FUNCS(inet_ntoa mmap munmap)\n \n AC_TRY_COMPILE([#include <sys/types.h>\n #include <sys/ipc.h>"}, {"sha": "5a001ad26b91ebcca0bb72c31e4a732276434484", "filename": "libmudflap/mf-hooks2.c", "status": "modified", "additions": 197, "deletions": 24, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fmf-hooks2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fmf-hooks2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks2.c?ref=ddfabf89bbf2d7295725609ac997490160adf8fc", "patch": "@@ -584,6 +584,66 @@ WRAPPER2(char *, strerror, int errnum)\n }\n \n \n+\n+/* An auxiliary data structure for tracking the hand-made stdio\n+   buffers we generate during the fopen/fopen64 hooks.  In a civilized\n+   language, this would be a simple dynamically sized FILE*->char*\n+   lookup table, but this is C and we get to do it by hand.  */\n+struct mf_filebuffer\n+{\n+  FILE *file;\n+  char *buffer;\n+  struct mf_filebuffer *next;\n+};\n+static struct mf_filebuffer *mf_filebuffers = NULL;\n+\n+static void\n+mkbuffer (FILE *f)\n+{\n+  /* Reset any buffer automatically provided by libc, since this may\n+     have been done via mechanisms that libmudflap couldn't\n+     intercept.  */\n+  int rc;\n+  size_t bufsize = BUFSIZ;\n+  int bufmode;\n+  char *buffer = malloc (bufsize);\n+  struct mf_filebuffer *b = malloc (sizeof (struct mf_filebuffer));\n+  assert ((buffer != NULL) && (b != NULL));\n+\n+  /* Link it into list.  */\n+  b->file = f;\n+  b->buffer = buffer;\n+  b->next = mf_filebuffers;\n+  mf_filebuffers = b;\n+\n+  /* Determine how the file is supposed to be buffered at the moment.  */\n+  bufmode = fileno (f) == 2 ? _IONBF : (isatty (fileno (f)) ? _IOLBF : _IOFBF);\n+\n+  rc = setvbuf (f, buffer, bufmode, bufsize);\n+  assert (rc == 0);\n+}\n+\n+static void\n+unmkbuffer (FILE *f)\n+{\n+  struct mf_filebuffer *b = mf_filebuffers;\n+  struct mf_filebuffer **pb = & mf_filebuffers;\n+  while (b != NULL)\n+    {\n+      if (b->file == f)\n+        {\n+          *pb = b->next;\n+          free (b->buffer);\n+          free (b);\n+          return;\n+        }\n+      pb = & b->next;\n+      b = b->next;\n+    }\n+}\n+\n+\n+\n WRAPPER2(FILE *, fopen, const char *path, const char *mode)\n {\n   size_t n;\n@@ -602,6 +662,106 @@ WRAPPER2(FILE *, fopen, const char *path, const char *mode)\n     __mf_register (p, sizeof (*p), MF_REGISTER_fopen, \"fopen result\");\n #endif\n     MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"fopen result\");\n+\n+    mkbuffer (p);\n+  }\n+\n+  return p;\n+}\n+\n+\n+WRAPPER2(int, setvbuf, FILE *stream, char *buf, int mode, size_t size)\n+{\n+  int rc = 0;\n+  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n+\n+  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE, \"setvbuf stream\");\n+\n+  unmkbuffer (stream);\n+\n+  if (buf != NULL)\n+    MF_VALIDATE_EXTENT (buf, size, __MF_CHECK_WRITE, \"setvbuf buffer\");\n+\n+  /* Override the user only if it's an auto-allocated buffer request.  Otherwise\n+     assume that the supplied buffer is already known to libmudflap.  */\n+  if ((buf == NULL) && ((mode == _IOFBF) || (mode == _IOLBF)))\n+    mkbuffer (stream);\n+  else\n+    rc = setvbuf (stream, buf, mode, size);\n+\n+  return rc;\n+}\n+\n+\n+#ifdef HAVE_SETBUF\n+WRAPPER2(int, setbuf, FILE* stream, char *buf)\n+{\n+  return __mfwrap_setvbuf (stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);\n+}\n+#endif\n+\n+#ifdef HAVE_SETBUFFER\n+WRAPPER2(int, setbuffer, FILE* stream, char *buf, size_t sz)\n+{\n+  return __mfwrap_setvbuf (stream, buf, buf ? _IOFBF : _IONBF, sz);\n+}\n+#endif\n+\n+#ifdef HAVE_SETLINEBUF\n+WRAPPER2(int, setlinebuf, FILE* stream)\n+{\n+  return __mfwrap_setvbuf(stream, NULL, _IOLBF, 0);\n+}\n+#endif\n+\n+\n+\n+WRAPPER2(FILE *, fdopen, int fd, const char *mode)\n+{\n+  size_t n;\n+  FILE *p;\n+  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n+\n+  n = strlen (mode);\n+  MF_VALIDATE_EXTENT (mode, CLAMPADD(n, 1), __MF_CHECK_READ, \"fdopen mode\");\n+\n+  p = fdopen (fd, mode);\n+  if (NULL != p) {\n+#ifdef MF_REGISTER_fopen\n+    __mf_register (p, sizeof (*p), MF_REGISTER_fopen, \"fdopen result\");\n+#endif\n+    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"fdopen result\");\n+\n+    mkbuffer (p);\n+  }\n+\n+  return p;\n+}\n+\n+\n+WRAPPER2(FILE *, freopen, const char *path, const char *mode, FILE *s)\n+{\n+  size_t n;\n+  FILE *p;\n+  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n+\n+  n = strlen (path);\n+  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"freopen path\");\n+\n+  MF_VALIDATE_EXTENT (s, (sizeof (*s)), __MF_CHECK_WRITE, \"freopen stream\");\n+  unmkbuffer (s);\n+\n+  n = strlen (mode);\n+  MF_VALIDATE_EXTENT (mode, CLAMPADD(n, 1), __MF_CHECK_READ, \"freopen mode\");\n+\n+  p = freopen (path, mode, s);\n+  if (NULL != p) {\n+#ifdef MF_REGISTER_fopen\n+    __mf_register (p, sizeof (*p), MF_REGISTER_fopen, \"freopen result\");\n+#endif\n+    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"freopen result\");\n+\n+    mkbuffer (p);\n   }\n \n   return p;\n@@ -627,6 +787,39 @@ WRAPPER2(FILE *, fopen64, const char *path, const char *mode)\n     __mf_register (p, sizeof (*p), MF_REGISTER_fopen, \"fopen64 result\");\n #endif\n     MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"fopen64 result\");\n+\n+    mkbuffer (p);\n+  }\n+\n+  return p;\n+}\n+#endif\n+\n+\n+#ifdef HAVE_FREOPEN64\n+WRAPPER2(FILE *, freopen64, const char *path, const char *mode, FILE *s)\n+{\n+  size_t n;\n+  FILE *p;\n+  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n+\n+  n = strlen (path);\n+  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"freopen64 path\");\n+\n+  MF_VALIDATE_EXTENT (s, (sizeof (*s)), __MF_CHECK_WRITE, \"freopen64 stream\");\n+  unmkbuffer (s);\n+\n+  n = strlen (mode);\n+  MF_VALIDATE_EXTENT (mode, CLAMPADD(n, 1), __MF_CHECK_READ, \"freopen64 mode\");\n+\n+  p = freopen (path, mode, s);\n+  if (NULL != p) {\n+#ifdef MF_REGISTER_fopen\n+    __mf_register (p, sizeof (*p), MF_REGISTER_fopen, \"freopen64 result\");\n+#endif\n+    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"freopen64 result\");\n+\n+    mkbuffer (p);\n   }\n \n   return p;\n@@ -644,6 +837,7 @@ WRAPPER2(int, fclose, FILE *stream)\n #ifdef MF_REGISTER_fopen\n   __mf_unregister (stream, sizeof (*stream), MF_REGISTER_fopen);\n #endif\n+  unmkbuffer (stream);\n \n   return resp;\n }\n@@ -943,8 +1137,9 @@ WRAPPER2(int , remove, const char *path)\n WRAPPER2(int, fflush, FILE *stream)\n {\n   TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fflush stream\");\n+  if (stream != NULL)\n+    MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n+                        \"fflush stream\");\n   return fflush (stream);\n }\n \n@@ -1071,28 +1266,6 @@ WRAPPER2(int , mkfifo, const char *path, mode_t mode)\n }\n \n \n-WRAPPER2(int, setvbuf, FILE *stream, char *buf, int mode , size_t size)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"setvbuf stream\");\n-  if (NULL != buf)\n-    MF_VALIDATE_EXTENT (buf, size, __MF_CHECK_READ, \"setvbuf buf\");\n-  return setvbuf (stream, buf, mode, size);\n-}\n-\n-\n-WRAPPER2(void, setbuf, FILE *stream, char *buf)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"setbuf stream\");\n-  if (NULL != buf)\n-    MF_VALIDATE_EXTENT (buf, BUFSIZ, __MF_CHECK_READ, \"setbuf buf\");\n-  setbuf (stream, buf);\n-}\n-\n-\n #ifdef HAVE_DIRENT_H\n WRAPPER2(DIR *, opendir, const char *path)\n {"}, {"sha": "64b1842766cac181a08aedec4a3fd10435a17708", "filename": "libmudflap/mf-runtime.c", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fmf-runtime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fmf-runtime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.c?ref=ddfabf89bbf2d7295725609ac997490160adf8fc", "patch": "@@ -160,7 +160,7 @@ static void mfsplay_tree_rebalance (mfsplay_tree sp);\n /* Required globals.  */\n \n #define LOOKUP_CACHE_MASK_DFL 1023\n-#define LOOKUP_CACHE_SIZE_MAX 4096 /* Allows max CACHE_MASK 0x0FFF */\n+#define LOOKUP_CACHE_SIZE_MAX 65536 /* Allows max CACHE_MASK 0xFFFF */\n #define LOOKUP_CACHE_SHIFT_DFL 2\n \n struct __mf_cache __mf_lookup_cache [LOOKUP_CACHE_SIZE_MAX];\n@@ -917,7 +917,7 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n                   judgement = -1;\n               }\n \n-            /* We now know that the access spans one or more valid objects.  */\n+            /* We now know that the access spans one or more only valid objects.  */\n             if (LIKELY (judgement >= 0))\n               for (i = 0; i < obj_count; i++)\n                 {\n@@ -931,12 +931,58 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n                       entry->high = obj->high;\n                       judgement = 1;\n                     }\n+                }\n+\n+            /* This access runs off the end of one valid object.  That\n+                could be okay, if other valid objects fill in all the\n+                holes.  We allow this only for HEAP and GUESS type\n+                objects.  Accesses to STATIC and STACK variables\n+                should not be allowed to span.  */\n+            if (UNLIKELY ((judgement == 0) && (obj_count > 1)))\n+              {\n+                unsigned uncovered = 0;\n+                for (i = 0; i < obj_count; i++)\n+                  {\n+                    __mf_object_t *obj = all_ovr_obj[i];\n+                    int j, uncovered_low_p, uncovered_high_p;\n+                    uintptr_t ptr_lower, ptr_higher;\n+\n+                    uncovered_low_p = ptr_low < obj->low;\n+                    ptr_lower = CLAMPSUB (obj->low, 1);\n+                    uncovered_high_p = ptr_high > obj->high;\n+                    ptr_higher = CLAMPADD (obj->high, 1);\n \n-                  /* XXX: Access runs off left or right side of this\n-                          object.  That could be okay, if there are\n-                          other objects that fill in all the holes. */\n+                    for (j = 0; j < obj_count; j++)\n+                      {\n+                        __mf_object_t *obj2 = all_ovr_obj[j];\n+\n+                        if (i == j) continue;\n+\n+                        /* Filter out objects that cannot be spanned across.  */\n+                        if (obj2->type == __MF_TYPE_STACK \n+                            || obj2->type == __MF_TYPE_STATIC)\n+                          continue;\n+\n+                          /* Consider a side \"covered\" if obj2 includes\n+                             the next byte on that side.  */\n+                          if (uncovered_low_p\n+                              && (ptr_lower >= obj2->low && ptr_lower <= obj2->high))\n+                            uncovered_low_p = 0;\n+                          if (uncovered_high_p\n+                              && (ptr_high >= obj2->low && ptr_higher <= obj2->high))\n+                            uncovered_high_p = 0;\n+                      }\n+                    \n+                    if (uncovered_low_p || uncovered_high_p)\n+                      uncovered ++;\n+                  }\n+\n+                /* Success if no overlapping objects are uncovered.  */\n+                if (uncovered == 0)\n+                  judgement = 1;\n                 }\n \n+\n             if (dealloc_me != NULL)\n               CALL_REAL (free, dealloc_me);\n \n@@ -1413,7 +1459,7 @@ __mf_adapt_cache ()\n       cache_utilization += 1.0;\n   cache_utilization /= (1 + __mf_lc_mask);\n \n-  new_mask |= 0x3ff; /* XXX: force a large cache.  */\n+  new_mask |= 0xffff; /* XXX: force a large cache.  */\n   new_mask &= (LOOKUP_CACHE_SIZE_MAX - 1);\n \n   VERBOSE_TRACE (\"adapt cache obj=%u/%u sizes=%lu/%.0f/%.0f => \""}, {"sha": "0f8f9e3e2b154a15a67acc4916b265c0d1929afa", "filename": "libmudflap/mf-runtime.h.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fmf-runtime.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Fmf-runtime.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.h.in?ref=ddfabf89bbf2d7295725609ac997490160adf8fc", "patch": "@@ -108,6 +108,8 @@ extern int __mf_set_options (const char *opts);\n #pragma redefine_extname time __mfwrap_time\n #pragma redefine_extname strerror __mfwrap_strerror\n #pragma redefine_extname fopen __mfwrap_fopen\n+#pragma redefine_extname fdopen __mfwrap_fdopen\n+#pragma redefine_extname freopen __mfwrap_freopen\n #pragma redefine_extname fclose __mfwrap_fclose\n #pragma redefine_extname fread __mfwrap_fread\n #pragma redefine_extname fwrite __mfwrap_fwrite\n@@ -146,6 +148,8 @@ extern int __mf_set_options (const char *opts);\n #pragma redefine_extname mkfifo __mfwrap_mkfifo\n #pragma redefine_extname setvbuf __mfwrap_setvbuf\n #pragma redefine_extname setbuf __mfwrap_setbuf\n+#pragma redefine_extname setbuffer __mfwrap_setbuffer\n+#pragma redefine_extname setlinebuf __mfwrap_setlinebuf\n #pragma redefine_extname opendir __mfwrap_opendir\n #pragma redefine_extname closedir __mfwrap_closedir\n #pragma redefine_extname readdir __mfwrap_readdir\n@@ -176,6 +180,7 @@ extern int __mf_set_options (const char *opts);\n #pragma redefine_extname dlsym __mfwrap_dlsym\n #pragma redefine_extname dlclose __mfwrap_dlclose\n #pragma redefine_extname fopen64 __mfwrap_fopen64\n+#pragma redefine_extname freopen64 __mfwrap_freopen64\n #pragma redefine_extname stat64 __mfwrap_stat64\n #pragma redefine_extname fseeko64 __mfwrap_fseeko64\n #pragma redefine_extname ftello64 __mfwrap_ftello64"}, {"sha": "5d4f1efff61fd1bc7e4d06948e06c28b24395c29", "filename": "libmudflap/testsuite/libmudflap.c++/ctors.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors.exp?ref=ddfabf89bbf2d7295725609ac997490160adf8fc", "patch": "@@ -8,7 +8,7 @@ global srcdir subdir\n foreach flags [list {} {-static} {-O2} {-O3}] {\n     set l1 [libmudflap_target_compile \"$srcdir/$subdir/ctors-1.cxx\" \"ctors-1.o\" object {additional_flags=-fmudflap}]\n     set test \"ctors-1 compilation ${flags}\"\n-    if [string match \"*mudflap cannot track lifetime of*k*\" $l1] { pass $test } { fail $test }\n+    if [string match \"*mudflap cannot track unknown size extern *k*\" $l1] { pass $test } { fail $test }\n \n     set l2 [libmudflap_target_compile \"$srcdir/$subdir/ctors-2.cxx\" \"ctors-2.o\" object {additional_flags=-fmudflap}]\n     set test \"ctors-2 compilation ${flags}\""}, {"sha": "95dafab836dad98ce17d36464522e57e805a6096", "filename": "libmudflap/testsuite/libmudflap.c/pass35-frag.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass35-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass35-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass35-frag.c?ref=ddfabf89bbf2d7295725609ac997490160adf8fc", "patch": "@@ -3,7 +3,7 @@\n #include <string.h>\n \n extern char end [];   /* Any old symbol we're sure will be defined. */\n-/* { dg-warning \"cannot track lifetime of 'end'\" \"cannot track lifetime\" { target *-*-* } 0 } */\n+/* { dg-warning \"cannot track unknown size extern 'end'\" \"cannot track unknown size extern\" { target *-*-* } 0 } */\n \n int main ()\n {"}, {"sha": "b830b3a869d944a3e4909e4832ddd3a01a65d658", "filename": "libmudflap/testsuite/libmudflap.c/pass51-frag.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass51-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass51-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass51-frag.c?ref=ddfabf89bbf2d7295725609ac997490160adf8fc", "patch": "@@ -0,0 +1,41 @@\n+/* Test object-spanning accesses.  This is most conveniently done with\n+   mmap, thus the config.h specificity here.  */\n+#include \"../config.h\"\n+\n+#include <unistd.h>\n+#include <string.h>\n+#ifdef HAVE_SYS_MMAN_H\n+#include <sys/mman.h>\n+#endif\n+\n+int main ()\n+{\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+#ifdef HAVE_MMAP\n+  void *p;\n+  unsigned pg = getpagesize ();\n+  int rc;\n+\n+  p = mmap (NULL, 4 * pg, PROT_READ|PROT_WRITE, \n+            MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);\n+  if (p == NULL)\n+    return 1;\n+\n+  memset (p, 0, 4*pg);\n+  rc = munmap (p, pg);\n+  if (rc < 0) return 1;\n+  memset (p+pg, 0, 3*pg);\n+  rc = munmap (p+pg, pg);\n+  if (rc < 0) return 1;\n+  memset (p+2*pg, 0, 2*pg);\n+  rc = munmap (p+2*pg, pg);\n+  if (rc < 0) return 1;\n+  memset (p+3*pg, 0, pg);\n+  rc = munmap (p+3*pg, pg);\n+  if (rc < 0) return 1;\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "7ff9d577ba7497d12ac78c8989b08d4d563fb5d8", "filename": "libmudflap/testsuite/libmudflap.c/pass52-frag.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass52-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddfabf89bbf2d7295725609ac997490160adf8fc/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass52-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass52-frag.c?ref=ddfabf89bbf2d7295725609ac997490160adf8fc", "patch": "@@ -0,0 +1,36 @@\n+#include <stdio.h>\n+\n+\n+void writestuff (FILE *f)\n+{\n+  fprintf (f, \"hello world\\n\");\n+  fputc ('y', f);\n+  putc ('e', f);\n+}\n+\n+void readstuff (FILE *f)\n+{\n+  int c, d;\n+  char stuff[100], *s;\n+  c = fgetc (f);\n+  ungetc (c, f);\n+  d = fgetc (f);\n+  s = fgets (stuff, sizeof(stuff), f);\n+}\n+\n+int main ()\n+{\n+  FILE *f;\n+  writestuff (stdout);\n+  writestuff (stderr);\n+  f = fopen (\"/dev/null\", \"w\");\n+  writestuff (f);\n+  fclose (f);\n+  f = fopen (\"/dev/zero\", \"r\");\n+  readstuff (f);\n+  f = freopen (\"/dev/null\", \"w\", f);\n+  writestuff (f);\n+  fclose (f);\n+\n+  return 0;\n+}"}]}