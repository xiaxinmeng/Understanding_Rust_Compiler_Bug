{"sha": "68252e2771d4f42996358543cd6d4778f96b9b90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgyNTJlMjc3MWQ0ZjQyOTk2MzU4NTQzY2Q2ZDQ3NzhmOTZiOWI5MA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-05T20:03:36Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-05T20:03:36Z"}, "message": "cse.c: Fix formatting.\n\n\t* cse.c: Fix formatting.\n\t* emit-rtl.c: Likewise.\n\nFrom-SVN: r53191", "tree": {"sha": "104b0d50413d38ab7a5646b3a2d43afede893d91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/104b0d50413d38ab7a5646b3a2d43afede893d91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68252e2771d4f42996358543cd6d4778f96b9b90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68252e2771d4f42996358543cd6d4778f96b9b90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68252e2771d4f42996358543cd6d4778f96b9b90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68252e2771d4f42996358543cd6d4778f96b9b90/comments", "author": null, "committer": null, "parents": [{"sha": "b7c13625c7ac54cfcb797d412b613c8173d31af2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c13625c7ac54cfcb797d412b613c8173d31af2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7c13625c7ac54cfcb797d412b613c8173d31af2"}], "stats": {"total": 106, "additions": 57, "deletions": 49}, "files": [{"sha": "62710337bd49703d8309d853fc5667aa27df1c89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68252e2771d4f42996358543cd6d4778f96b9b90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68252e2771d4f42996358543cd6d4778f96b9b90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68252e2771d4f42996358543cd6d4778f96b9b90", "patch": "@@ -1,3 +1,8 @@\n+2002-05-05  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cse.c: Fix formatting.\n+\t* emit-rtl.c: Likewise.\n+\n 2002-05-05  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* genautomata.c (initiate_states): Add additional guard to"}, {"sha": "c15c63fffb71bbf12576d487448c8a9bd0795a86", "filename": "gcc/cse.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68252e2771d4f42996358543cd6d4778f96b9b90/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68252e2771d4f42996358543cd6d4778f96b9b90/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=68252e2771d4f42996358543cd6d4778f96b9b90", "patch": "@@ -742,7 +742,7 @@ approx_reg_cost (x)\n   int hardregs = 0;\n \n   INIT_REG_SET (&set);\n-  for_each_rtx (&x, approx_reg_cost_1, (void *)&set);\n+  for_each_rtx (&x, approx_reg_cost_1, (void *) &set);\n \n   EXECUTE_IF_SET_IN_REG_SET\n     (&set, 0, i,\n@@ -1990,7 +1990,7 @@ remove_invalid_refs (regno)\n       {\n \tnext = p->next_same_hash;\n \tif (GET_CODE (p->exp) != REG\n-\t    && refers_to_regno_p (regno, regno + 1, p->exp, (rtx*) 0))\n+\t    && refers_to_regno_p (regno, regno + 1, p->exp, (rtx *) 0))\n \t  remove_from_table (p, i);\n       }\n }\n@@ -2020,7 +2020,7 @@ remove_invalid_subreg_refs (regno, offset, mode)\n \t\t|| (((SUBREG_BYTE (exp)\n \t\t      + (GET_MODE_SIZE (GET_MODE (exp)) - 1)) >= offset)\n \t\t    && SUBREG_BYTE (exp) <= end))\n-\t    && refers_to_regno_p (regno, regno + 1, p->exp, (rtx*) 0))\n+\t    && refers_to_regno_p (regno, regno + 1, p->exp, (rtx *) 0))\n \t  remove_from_table (p, i);\n       }\n }\n@@ -2212,8 +2212,8 @@ canon_hash_string (ps)\n      const char *ps;\n {\n   unsigned hash = 0;\n-  const unsigned char *p = (const unsigned char *)ps;\n-  \n+  const unsigned char *p = (const unsigned char *) ps;\n+\n   if (p)\n     while (*p)\n       hash += *p++;\n@@ -2264,7 +2264,7 @@ canon_hash (x, mode)\n \t   failure to do so leads to failure to simplify 0<100 type of\n \t   conditionals.\n \n-\t   On all machines, we can't record any global registers.  \n+\t   On all machines, we can't record any global registers.\n \t   Nor should we record any register that is in a small\n \t   class, as defined by CLASS_LIKELY_SPILLED_P.  */\n \n@@ -2375,7 +2375,7 @@ canon_hash (x, mode)\n       if (GET_CODE (XEXP (x, 0)) == MEM\n \t  && ! MEM_VOLATILE_P (XEXP (x, 0)))\n \t{\n-\t  hash += (unsigned)USE;\n+\t  hash += (unsigned) USE;\n \t  x = XEXP (x, 0);\n \n \t  if (! RTX_UNCHANGING_P (x) || FIXED_BASE_PLUS_P (XEXP (x, 0)))\n@@ -3237,7 +3237,7 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t    || (code == GE\n \t\t\t&& GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n-\t\t        && (REAL_VALUE_NEGATIVE\n+\t\t\t&& (REAL_VALUE_NEGATIVE\n \t\t\t    (FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)))))\n #endif\n \t\t    )\n@@ -3270,7 +3270,8 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n \t  enum rtx_code reversed = reversed_comparison_code (x, NULL_RTX);\n \t  if (reversed == UNKNOWN)\n \t    break;\n-\t  else code = reversed;\n+\t  else\n+\t    code = reversed;\n \t}\n       else if (GET_RTX_CLASS (GET_CODE (x)) == '<')\n \tcode = GET_CODE (x);\n@@ -3808,7 +3809,7 @@ fold_rtx (x, insn)\n \treplacements[0] = cheap_arg;\n \treplacements[1] = expensive_arg;\n \n-\tfor (j = 0; j < 2 && replacements[j];  j++)\n+\tfor (j = 0; j < 2 && replacements[j]; j++)\n \t  {\n \t    int old_cost = COST_IN (XEXP (x, i), code);\n \t    int new_cost = COST_IN (replacements[j], code);\n@@ -3926,7 +3927,7 @@ fold_rtx (x, insn)\n \t  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t    {\n \t      true_rtx = (CONST_DOUBLE_FROM_REAL_VALUE\n-\t\t      (FLOAT_STORE_FLAG_VALUE (mode), mode));\n+\t\t\t  (FLOAT_STORE_FLAG_VALUE (mode), mode));\n \t      false_rtx = CONST0_RTX (mode);\n \t    }\n #endif\n@@ -5469,13 +5470,13 @@ cse_insn (insn, libcall_insn)\n \t      continue;\n \t    }\n \n-          if (elt)\n+\t  if (elt)\n \t    {\n \t      src_elt_cost = elt->cost;\n \t      src_elt_regcost = elt->regcost;\n \t    }\n \n-          /* Find cheapest and skip it for the next time.   For items\n+\t  /* Find cheapest and skip it for the next time.   For items\n \t     of equal cost, use this order:\n \t     src_folded, src, src_eqv, src_related and hash table entry.  */\n \t  if (src_folded\n@@ -5509,7 +5510,7 @@ cse_insn (insn, libcall_insn)\n \t  else if (src_related\n \t\t   && preferrable (src_related_cost, src_related_regcost,\n \t\t\t\t   src_elt_cost, src_elt_regcost) <= 0)\n-  \t    trial = copy_rtx (src_related), src_related_cost = MAX_COST;\n+\t    trial = copy_rtx (src_related), src_related_cost = MAX_COST;\n \t  else\n \t    {\n \t      trial = copy_rtx (elt->exp);\n@@ -5674,7 +5675,7 @@ cse_insn (insn, libcall_insn)\n \t     a new one if one does not already exist.  */\n \t  set_unique_reg_note (insn, REG_EQUAL, src_const);\n \n-          /* If storing a constant value in a register that\n+\t  /* If storing a constant value in a register that\n \t     previously held the constant value 0,\n \t     record this fact with a REG_WAS_0 note on this insn.\n \n@@ -7367,7 +7368,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n      we can cse into the loop.  Don't do this if we changed the jump\n      structure of a loop unless we aren't going to be following jumps.  */\n \n-  insn = prev_nonnote_insn(to);\n+  insn = prev_nonnote_insn (to);\n   if ((cse_jumps_altered == 0\n        || (flag_cse_follow_jumps == 0 && flag_cse_skip_blocks == 0))\n       && around_loop && to != 0\n@@ -7674,7 +7675,8 @@ delete_trivially_dead_insns (insns, nreg)\n \t      dead_libcall = 0;\n \t    }\n \t}\n-    } while (ndead != nlastdead);\n+    }\n+  while (ndead != nlastdead);\n \n   if (rtl_dump_file && ndead)\n     fprintf (rtl_dump_file, \"Deleted %i trivially dead insns; %i iterations\\n\","}, {"sha": "4b9c2dcc4089f327e0927dbd9bd5d1450e30d02e", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68252e2771d4f42996358543cd6d4778f96b9b90/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68252e2771d4f42996358543cd6d4778f96b9b90/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=68252e2771d4f42996358543cd6d4778f96b9b90", "patch": "@@ -422,7 +422,7 @@ gen_rtx_REG (mode, regno)\n #endif\n       if (regno == PIC_OFFSET_TABLE_REGNUM\n \t  && fixed_regs[PIC_OFFSET_TABLE_REGNUM])\n-        return pic_offset_table_rtx;\n+\treturn pic_offset_table_rtx;\n       if (regno == STACK_POINTER_REGNUM)\n \treturn stack_pointer_rtx;\n     }\n@@ -532,7 +532,7 @@ gen_rtx VPARAMS ((enum rtx_code code, enum machine_mode mode, ...))\n \tHOST_WIDE_INT arg0 = va_arg (p, HOST_WIDE_INT);\n \tHOST_WIDE_INT arg1 = va_arg (p, HOST_WIDE_INT);\n \n-        rt_val = gen_rtx_CONST_DOUBLE (mode, arg0, arg1);\n+\trt_val = gen_rtx_CONST_DOUBLE (mode, arg0, arg1);\n       }\n       break;\n \n@@ -905,14 +905,14 @@ gen_lowpart_common (mode, x)\n   else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n \t   && GET_MODE_BITSIZE (mode) == 32\n \t   && GET_CODE (x) == CONST_INT)\n-  {\n+    {\n       REAL_VALUE_TYPE r;\n       HOST_WIDE_INT i;\n \n       i = INTVAL (x);\n       r = REAL_VALUE_FROM_TARGET_SINGLE (i);\n       return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n-  }\n+    }\n   else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n \t   && GET_MODE_BITSIZE (mode) == 64\n \t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n@@ -962,16 +962,16 @@ gen_lowpart_common (mode, x)\n       switch (GET_MODE_BITSIZE (GET_MODE (x)))\n \t{\n \tcase 32:\n-          REAL_VALUE_TO_TARGET_SINGLE (r, i[3 * endian]);\n+\t  REAL_VALUE_TO_TARGET_SINGLE (r, i[3 * endian]);\n \t  i[1] = 0;\n \t  i[2] = 0;\n-          i[3 - 3 * endian] = 0;\n-          break;\n+\t  i[3 - 3 * endian] = 0;\n+\t  break;\n \tcase 64:\n-          REAL_VALUE_TO_TARGET_DOUBLE (r, i + 2 * endian);\n+\t  REAL_VALUE_TO_TARGET_DOUBLE (r, i + 2 * endian);\n \t  i[2 - 2 * endian] = 0;\n \t  i[3 - 2 * endian] = 0;\n-          break;\n+\t  break;\n \tcase 96:\n \t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, i + endian);\n \t  i[3 - 3 * endian] = 0;\n@@ -1139,8 +1139,8 @@ gen_highpart (mode, x)\n    be VOIDmode constant.  */\n rtx\n gen_highpart_mode (outermode, innermode, exp)\n-    enum machine_mode outermode, innermode;\n-    rtx exp;\n+     enum machine_mode outermode, innermode;\n+     rtx exp;\n {\n   if (GET_MODE (exp) != VOIDmode)\n     {\n@@ -1151,6 +1151,7 @@ gen_highpart_mode (outermode, innermode, exp)\n   return simplify_gen_subreg (outermode, exp, innermode,\n \t\t\t      subreg_highpart_offset (outermode, innermode));\n }\n+\n /* Return offset in bytes to get OUTERMODE low part\n    of the value in mode INNERMODE stored in memory in target format.  */\n \n@@ -1182,7 +1183,7 @@ subreg_highpart_offset (outermode, innermode)\n   int difference = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode));\n \n   if (GET_MODE_SIZE (innermode) < GET_MODE_SIZE (outermode))\n-     abort ();\n+    abort ();\n \n   if (difference > 0)\n     {\n@@ -1530,10 +1531,10 @@ component_ref_for_mem_expr (ref)\n \t     || TREE_CODE (inner) == VIEW_CONVERT_EXPR\n \t     || TREE_CODE (inner) == SAVE_EXPR\n \t     || TREE_CODE (inner) == PLACEHOLDER_EXPR)\n-\t  if (TREE_CODE (inner) == PLACEHOLDER_EXPR)\n-\t    inner = find_placeholder (inner, &placeholder_ptr);\n-\t  else\n-\t    inner = TREE_OPERAND (inner, 0);\n+\tif (TREE_CODE (inner) == PLACEHOLDER_EXPR)\n+\t  inner = find_placeholder (inner, &placeholder_ptr);\n+\telse\n+\t  inner = TREE_OPERAND (inner, 0);\n \n       if (! DECL_P (inner))\n \tinner = NULL_TREE;\n@@ -1632,7 +1633,7 @@ set_mem_attributes (ref, t, objectp)\n \t  size = (DECL_SIZE_UNIT (t)\n \t\t  && host_integerp (DECL_SIZE_UNIT (t), 1)\n \t\t  ? GEN_INT (tree_low_cst (DECL_SIZE_UNIT (t), 1)) : 0);\n-\t  align =  DECL_ALIGN (t);\n+\t  align = DECL_ALIGN (t);\n \t}\n \n       /* If this is a constant, we know the alignment.  */\n@@ -1708,7 +1709,7 @@ set_mem_alias_set (mem, set)\n      rtx mem;\n      HOST_WIDE_INT set;\n {\n-#ifdef ENABLE_CHECKING\t\n+#ifdef ENABLE_CHECKING\n   /* If the new and old alias sets don't conflict, something is wrong.  */\n   if (!alias_sets_conflict_p (set, MEM_ALIAS_SET (mem)))\n     abort ();\n@@ -1915,7 +1916,7 @@ offset_address (memref, offset, pow2)\n \n   new = simplify_gen_binary (PLUS, Pmode, addr, offset);\n \n-  /* At this point we don't know _why_ the address is invalid.  It \n+  /* At this point we don't know _why_ the address is invalid.  It\n      could have secondary memory refereces, multiplies or anything.\n \n      However, if we did go and rearrange things, we can wind up not\n@@ -1942,7 +1943,7 @@ offset_address (memref, offset, pow2)\n \t\t     GET_MODE (new));\n   return new;\n }\n-  \n+\n /* Return a memory reference like MEMREF, but with its address changed to\n    ADDR.  The caller is asserting that the actual piece of memory pointed\n    to is the same, just the form of the address is being changed, such as\n@@ -2916,8 +2917,8 @@ prev_cc0_setter (insn)\n /* Increment the label uses for all labels present in rtx.  */\n \n static void\n-mark_label_nuses(x)\n-    rtx x;\n+mark_label_nuses (x)\n+     rtx x;\n {\n   enum rtx_code code;\n   int i, j;\n@@ -3027,7 +3028,7 @@ try_split (pat, trial, last)\n \t\t  = CALL_INSN_FUNCTION_USAGE (trial);\n \n \t  /* Copy notes, particularly those related to the CFG.  */\n-\t  for (note = REG_NOTES (trial); note ; note = XEXP (note, 1))\n+\t  for (note = REG_NOTES (trial); note; note = XEXP (note, 1))\n \t    {\n \t      switch (REG_NOTE_KIND (note))\n \t\t{\n@@ -3081,7 +3082,7 @@ try_split (pat, trial, last)\n \t  if (GET_CODE (trial) == INSN)\n \t    for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n \t      if (GET_CODE (XVECEXP (seq, 0, i)) == INSN)\n-\t        mark_label_nuses (PATTERN (XVECEXP (seq, 0, i)));\n+\t\tmark_label_nuses (PATTERN (XVECEXP (seq, 0, i)));\n \n \t  tem = emit_insn_after (seq, trial);\n \n@@ -3256,7 +3257,7 @@ add_insn_after (insn, after)\n     {\n       set_block_for_insn (insn, bb);\n       if (INSN_P (insn))\n-        bb->flags |= BB_DIRTY;\n+\tbb->flags |= BB_DIRTY;\n       /* Should not happen as first in the BB is always\n \t either NOTE or LABEL.  */\n       if (bb->end == after\n@@ -3325,7 +3326,7 @@ add_insn_before (insn, before)\n     {\n       set_block_for_insn (insn, bb);\n       if (INSN_P (insn))\n-        bb->flags |= BB_DIRTY;\n+\tbb->flags |= BB_DIRTY;\n       /* Should not happen as first in the BB is always\n \t either NOTE or LABEl.  */\n       if (bb->head == insn\n@@ -3404,7 +3405,7 @@ remove_insn (insn)\n       && (bb = BLOCK_FOR_INSN (insn)))\n     {\n       if (INSN_P (insn))\n-        bb->flags |= BB_DIRTY;\n+\tbb->flags |= BB_DIRTY;\n       if (bb->head == insn)\n \t{\n \t  /* Never ever delete the basic block note without deleting whole\n@@ -3483,7 +3484,7 @@ reorder_insns (from, to, after)\n     {\n       rtx x;\n       bb->flags |= BB_DIRTY;\n- \n+\n       if (basic_block_for_insn\n \t  && ((unsigned int) INSN_UID (from)\n \t      < basic_block_for_insn->num_elements)\n@@ -3614,7 +3615,7 @@ remove_unnecessary_notes ()\n \t     then there is no PC range in the generated code that will\n \t     actually be in this block, so there's no point in\n \t     remembering the existence of the block.  */\n-\t  for (tmp = PREV_INSN (insn); tmp ; tmp = PREV_INSN (tmp))\n+\t  for (tmp = PREV_INSN (insn); tmp; tmp = PREV_INSN (tmp))\n \t    {\n \t      /* This block contains a real instruction.  Note that we\n \t\t don't include labels; if the only thing in the block\n@@ -3913,7 +3914,7 @@ emit_line_note_after (file, line, after)\n       return 0;\n     }\n \n-  note  = rtx_alloc (NOTE);\n+  note = rtx_alloc (NOTE);\n   INSN_UID (note) = cur_insn_uid++;\n   NOTE_SOURCE_FILE (note) = file;\n   NOTE_LINE_NUMBER (note) = line;\n@@ -4431,7 +4432,7 @@ end_full_sequence (first, last)\n {\n   *first = first_insn;\n   *last = last_insn;\n-  end_sequence();\n+  end_sequence ();\n }\n \n /* Return 1 if currently emitting into a sequence.  */\n@@ -4929,7 +4930,7 @@ init_emit_once (line_numbers)\n \t   mode = GET_MODE_WIDER_MODE (mode))\n \t{\n \t  rtx tem = rtx_alloc (CONST_DOUBLE);\n- \n+\n \t  /* Can't use CONST_DOUBLE_FROM_REAL_VALUE here; that uses the\n \t     tables we're setting up right now.  */\n \t  memcpy (&CONST_DOUBLE_LOW (tem), r, sizeof (REAL_VALUE_TYPE));"}]}