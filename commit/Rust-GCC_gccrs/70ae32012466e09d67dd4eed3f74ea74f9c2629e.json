{"sha": "70ae32012466e09d67dd4eed3f74ea74f9c2629e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBhZTMyMDEyNDY2ZTA5ZDY3ZGQ0ZWVkM2Y3NGVhNzRmOWMyNjI5ZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-16T16:59:44Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-16T16:59:44Z"}, "message": "cp-tree.h (num_extra_vtbl_entries): New function.\n\n\t* cp-tree.h (num_extra_vtbl_entries): New function.\n\t(size_extra_vtbl_entries): Likewise.\n\t(dfs_vtable_path_unmark): Likewise.\n\t(dfs_vtable_path_unmarked_real_bases_queue_p): Likewise.\n\t(dfs_vtable_path_marked_real_bases_queue_p): Likewise.\n\t* class.c (num_extra_vtbl_entries): New function.\n\t(size_extra_vtbl_entries): Likewise.\n\t(dfs_build_vbase_offset_vtbl_entries): New function.\n\t(build_vbase_offset_vtbl_entries): Likewise.\n\t(build_vtbl_initializer): Use it.\n\t(finish_struct_1): Adjust vtable sizes (using\n\tnum_extra_vtbl_entries).\n\t* expr.c (cplus_expand_expr): Assert that the DECL_RTL for a\n\tTHUNK_DECL is non-NULL before expanding it.\n\t* init.c (expand_virtual_init): Adjust the vtable pointer by\n\tsize_extra_vtbl_entries before storing it.\n\t* search.c (get_shared_vase_if_not_primary): Adjust prototype.\n\tHandle TREE_LIST parameters here, not in the dfs_* functions.\n\t(dfs_unmarked_real_bases_queue_p): Adjust.\n\t(dfs_marked_real_bases_queue_p): Likewise.\n\t(dfs_vtable_path_unmarked_real_bases_queue_p): New function.\n\t(dfs_vtable_path_marked_real_bases_queue_p): New function.\n\t(dfs_vtable_path_unmark): Likewise.\n\nFrom-SVN: r31439", "tree": {"sha": "474362df55656c988b876cb23e1ad22cf0bc2401", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/474362df55656c988b876cb23e1ad22cf0bc2401"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70ae32012466e09d67dd4eed3f74ea74f9c2629e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70ae32012466e09d67dd4eed3f74ea74f9c2629e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70ae32012466e09d67dd4eed3f74ea74f9c2629e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70ae32012466e09d67dd4eed3f74ea74f9c2629e/comments", "author": null, "committer": null, "parents": [{"sha": "2f4facc91eb1b0917f951bb0ff2571ed24d66e08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f4facc91eb1b0917f951bb0ff2571ed24d66e08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f4facc91eb1b0917f951bb0ff2571ed24d66e08"}], "stats": {"total": 274, "additions": 247, "deletions": 27}, "files": [{"sha": "8915d025f3bdf1f2d37a62956aa11d74b4573093", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=70ae32012466e09d67dd4eed3f74ea74f9c2629e", "patch": "@@ -1,3 +1,29 @@\n+2000-01-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (num_extra_vtbl_entries): New function.\n+\t(size_extra_vtbl_entries): Likewise.\n+\t(dfs_vtable_path_unmark): Likewise.\n+\t(dfs_vtable_path_unmarked_real_bases_queue_p): Likewise.\n+\t(dfs_vtable_path_marked_real_bases_queue_p): Likewise.\n+\t* class.c (num_extra_vtbl_entries): New function.\n+\t(size_extra_vtbl_entries): Likewise.\n+\t(dfs_build_vbase_offset_vtbl_entries): New function.\n+\t(build_vbase_offset_vtbl_entries): Likewise.\n+\t(build_vtbl_initializer): Use it.\n+\t(finish_struct_1): Adjust vtable sizes (using\n+\tnum_extra_vtbl_entries).\n+\t* expr.c (cplus_expand_expr): Assert that the DECL_RTL for a\n+\tTHUNK_DECL is non-NULL before expanding it.\n+\t* init.c (expand_virtual_init): Adjust the vtable pointer by\n+\tsize_extra_vtbl_entries before storing it.\n+\t* search.c (get_shared_vase_if_not_primary): Adjust prototype.\n+\tHandle TREE_LIST parameters here, not in the dfs_* functions.\n+\t(dfs_unmarked_real_bases_queue_p): Adjust.\n+\t(dfs_marked_real_bases_queue_p): Likewise.\n+\t(dfs_vtable_path_unmarked_real_bases_queue_p): New function.\n+\t(dfs_vtable_path_marked_real_bases_queue_p): New function.\n+\t(dfs_vtable_path_unmark): Likewise.\n+\t\n 2000-01-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* optimize.c (copy_body_r): Clear the operand three of a"}, {"sha": "2502b85ec75eef6ed9245ff335e7714f297684f8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 158, "deletions": 5, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=70ae32012466e09d67dd4eed3f74ea74f9c2629e", "patch": "@@ -144,6 +144,8 @@ static void remove_base_field PROTO((tree, tree, tree *));\n static void remove_base_fields PROTO((tree));\n static tree dfs_set_offset_for_shared_vbases PROTO((tree, void *));\n static tree dfs_set_offset_for_unshared_vbases PROTO((tree, void *));\n+static tree dfs_build_vbase_offset_vtbl_entries PROTO((tree, void *));\n+static tree build_vbase_offset_vtbl_entries PROTO((tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -2138,6 +2140,148 @@ duplicate_tag_error (t)\n   TYPE_NONCOPIED_PARTS (t) = NULL_TREE;\n }\n \n+/* Returns the number of extra entries (at negative indices) required\n+   for BINFO's vtable.  */\n+\n+tree\n+num_extra_vtbl_entries (binfo)\n+     tree binfo;\n+{\n+  tree type;\n+  int entries;\n+\n+\n+  /* Under the old ABI, there are no entries at negative offsets.  */\n+  if (!flag_new_abi)\n+    return size_zero_node;\n+\n+  type = BINFO_TYPE (binfo);\n+  entries = 0;\n+\n+  /* There is an entry for the offset to each virtual base.  */\n+  entries += list_length (CLASSTYPE_VBASECLASSES (type));\n+\n+  return size_int (entries);\n+}\n+\n+/* Returns the offset (in bytes) from the beginning of BINFO's vtable\n+   where the vptr should actually point.  */\n+\n+tree\n+size_extra_vtbl_entries (binfo)\n+     tree binfo;\n+{\n+  tree offset;\n+\n+  offset = size_binop (EXACT_DIV_EXPR,\n+\t\t       TYPE_SIZE (vtable_entry_type),\n+\t\t       size_int (BITS_PER_UNIT));\n+  offset = size_binop (MULT_EXPR, offset, num_extra_vtbl_entries (binfo));\n+  return fold (offset);\n+}\n+\n+/* Called from build_vbase_offset_vtbl_entries via dfs_walk.  */\n+\n+static tree\n+dfs_build_vbase_offset_vtbl_entries (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree list = (tree) data;\n+\n+  if (TREE_TYPE (list) == binfo)\n+    /* The TREE_TYPE of LIST is the base class from which we started\n+       walking.  If that BINFO is virtual it's not a virtual baseclass\n+       of itself.  */\n+    ;\n+  else if (TREE_VIA_VIRTUAL (binfo))\n+    {\n+      tree init;\n+\n+      init = BINFO_OFFSET (binfo);\n+      init = build1 (NOP_EXPR, vtable_entry_type, init);\n+      TREE_VALUE (list) = tree_cons (NULL_TREE, init, TREE_VALUE (list));\n+    }\n+\n+  SET_BINFO_VTABLE_PATH_MARKED (binfo);\n+  \n+  return NULL_TREE;\n+}\n+\n+/* Returns the initializers for the vbase offset entries in the\n+   vtable, in reverse order.  */\n+\n+static tree\n+build_vbase_offset_vtbl_entries (binfo)\n+     tree binfo;\n+{\n+  tree type;\n+  tree inits;\n+  tree init;\n+\n+  type = BINFO_TYPE (binfo);\n+  if (!TYPE_USES_VIRTUAL_BASECLASSES (type))\n+    return NULL_TREE;\n+\n+  inits = NULL_TREE;\n+\n+  /* Under the new ABI, the vtable contains offsets to all virtual\n+     bases.  The ABI specifies different layouts depending on whether\n+     or not *all* of the bases of this type are virtual.  */\n+  if (CLASSTYPE_N_BASECLASSES (type) \n+      == list_length (CLASSTYPE_VBASECLASSES (type)))\n+    {\n+      /* In this case, the offsets are allocated from right to left of\n+\t the declaration order in which the virtual bases appear.  */\n+      int i;\n+\n+      for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n+\t{\n+\t  tree vbase = BINFO_BASETYPE (binfo, i);\n+\t  init = BINFO_OFFSET (vbase);\n+\t  init = build1 (NOP_EXPR, vtable_entry_type, init);\n+\t  inits = tree_cons (NULL_TREE, init, inits);\n+\t}\n+    }\n+  else\n+    {\n+      tree list;\n+\n+      /* While in this case, the offsets are allocated in the reverse\n+\t order of a depth-first left-to-right traversal of the\n+\t hierarchy.  We use BINFO_VTABLE_PATH_MARKED because we are\n+\t ourselves during a dfs_walk, and so BINFO_MARKED is already\n+\t in use.  */\n+      list = build_tree_list (type, NULL_TREE);\n+      TREE_TYPE (list) = binfo;\n+      dfs_walk (binfo,\n+\t\tdfs_build_vbase_offset_vtbl_entries,\n+\t\tdfs_vtable_path_unmarked_real_bases_queue_p,\n+\t\tlist);\n+      dfs_walk (binfo,\n+\t\tdfs_vtable_path_unmark,\n+\t\tdfs_vtable_path_marked_real_bases_queue_p,\n+\t\tlist);\n+      inits = nreverse (TREE_VALUE (list));\n+    }\n+\n+  /* We've now got offsets in the right oder.  However, the offsets\n+     we've stored are offsets from the beginning of the complete\n+     object, and we need offsets from this BINFO.  */\n+  for (init = inits; init; init = TREE_CHAIN (init))\n+    {\n+      tree exp = TREE_VALUE (init);\n+\n+      exp = ssize_binop (MINUS_EXPR, exp, BINFO_OFFSET (binfo));\n+      exp = build1 (NOP_EXPR, vtable_entry_type, TREE_VALUE (init));\n+      exp = fold (exp);\n+      TREE_CONSTANT (exp) = 1;\n+      TREE_VALUE (init) = exp;\n+    }\n+\n+  return inits;\n+}\n+\n /* Construct the initializer for BINFOs virtual function table.  */\n \n static tree\n@@ -2146,13 +2290,16 @@ build_vtbl_initializer (binfo)\n {\n   tree v = BINFO_VIRTUALS (binfo);\n   tree inits = NULL_TREE;\n+  tree type = BINFO_TYPE (binfo);\n+\n+  if (flag_new_abi)\n+    inits = build_vbase_offset_vtbl_entries (binfo);\n \n   /* Process the RTTI stuff at the head of the list.  If we're not\n      using vtable thunks, then the RTTI entry is just an ordinary\n      function, and we can process it just like the other virtual\n      function entries.  */\n-  if (!CLASSTYPE_COM_INTERFACE (BINFO_TYPE (binfo))\n-      && flag_vtable_thunks)\n+  if (!CLASSTYPE_COM_INTERFACE (type) && flag_vtable_thunks)\n     {\n       tree offset;\n       tree init;\n@@ -4764,9 +4911,15 @@ finish_struct_1 (t)\n   if (has_virtual)\n     {\n       /* Use size_int so values are memoized in common cases.  */\n-      tree itype = build_index_type (size_int (has_virtual));\n-      tree atype = build_cplus_array_type (vtable_entry_type, itype);\n-\n+      tree itype;\n+      tree atype;\n+\n+      itype = size_int (has_virtual);\n+      itype = size_binop (PLUS_EXPR, \n+\t\t\t  itype,\n+\t\t\t  num_extra_vtbl_entries (TYPE_BINFO (t)));\n+      atype = build_cplus_array_type (vtable_entry_type, \n+\t\t\t\t      build_index_type (itype));\n       layout_type (atype);\n \n       /* We may have to grow the vtable.  */"}, {"sha": "2101cae0a5f331d6c5c0671f3ad68ca127a7326c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=70ae32012466e09d67dd4eed3f74ea74f9c2629e", "patch": "@@ -3464,6 +3464,8 @@ extern void unreverse_member_declarations       PROTO((tree));\n extern void invalidate_class_lookup_cache       PROTO((void));\n extern void maybe_note_name_used_in_class       PROTO((tree, tree));\n extern void note_name_declared_in_class         PROTO((tree, tree));\n+extern tree num_extra_vtbl_entries              PROTO((tree));\n+extern tree size_extra_vtbl_entries             PROTO((tree));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPROTO((tree, tree, int, int, tree));\n@@ -3961,12 +3963,17 @@ extern tree dfs_walk                            PROTO((tree,\n \t\t\t\t\t\t       void *));\n extern tree dfs_unmark                          PROTO((tree, void *));\n extern tree dfs_vbase_unmark                    PROTO((tree, void *));\n+extern tree dfs_vtable_path_unmark              PROTO((tree, void *));\n extern tree markedp                             PROTO((tree, void *));\n extern tree unmarkedp                           PROTO((tree, void *));\n extern tree dfs_skip_nonprimary_vbases_unmarkedp PROTO((tree, void *));\n extern tree dfs_skip_nonprimary_vbases_markedp  PROTO((tree, void *));\n extern tree dfs_unmarked_real_bases_queue_p     PROTO((tree, void *));\n extern tree dfs_marked_real_bases_queue_p       PROTO((tree, void *));\n+extern tree dfs_vtable_path_unmarked_real_bases_queue_p\n+                                                PROTO((tree, void *));\n+extern tree dfs_vtable_path_marked_real_bases_queue_p\n+                                                PROTO((tree, void *));\n extern tree dfs_skip_vbases                     PROTO((tree, void *));\n extern void mark_primary_bases                  PROTO((tree));\n extern tree convert_pointer_to_vbase            PROTO((tree, tree));"}, {"sha": "32838f4af8f63e5033875862765949259a26d094", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=70ae32012466e09d67dd4eed3f74ea74f9c2629e", "patch": "@@ -1,6 +1,6 @@\n /* Convert language-specific tree expression to rtl instructions,\n    for GNU compiler.\n-   Copyright (C) 1988, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 92-97, 1998, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -131,6 +131,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n       }\n \n     case THUNK_DECL:\n+      my_friendly_assert (DECL_RTL (exp) != NULL_RTX, 20000115);\n       return DECL_RTL (exp);\n \n     case THROW_EXPR:"}, {"sha": "12815e46a9e6f1c48a62f5e38b2df64b05a7b0af", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=70ae32012466e09d67dd4eed3f74ea74f9c2629e", "patch": "@@ -648,21 +648,26 @@ expand_virtual_init (binfo, decl)\n   tree vtbl, vtbl_ptr;\n   tree vtype, vtype_binfo;\n \n-  /* This code is crusty.  Should be simple, like:\n-     vtbl = BINFO_VTABLE (binfo);\n-     */\n+  /* Compute the location of the vtable.  */\n   vtype = DECL_CONTEXT (TYPE_VFIELD (type));\n   vtype_binfo = get_binfo (vtype, TREE_TYPE (TREE_TYPE (decl)), 0);\n   vtbl = BINFO_VTABLE (binfo_value (DECL_FIELD_CONTEXT (TYPE_VFIELD (type)), binfo));\n   assemble_external (vtbl);\n   TREE_USED (vtbl) = 1;\n   vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n+  /* Under the new ABI, we need to point into the middle of the\n+     vtable.  */\n+  if (flag_new_abi)\n+    vtbl = build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, \n+\t\t  size_extra_vtbl_entries (binfo));\n+\n+  /* Compute the location of the vtpr.  */\n   decl = convert_pointer_to_real (vtype_binfo, decl);\n   vtbl_ptr = build_vfield_ref (build_indirect_ref (decl, NULL_PTR), vtype);\n   if (vtbl_ptr == error_mark_node)\n     return;\n \n-  /* Have to convert VTBL since array sizes may be different.  */\n+  /* Assign the vtable to the vptr.  */\n   vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl, 0);\n   finish_expr_stmt (build_modify_expr (vtbl_ptr, NOP_EXPR, vtbl));\n }"}, {"sha": "697bf8b214e59fda0410519e4f291b0501e31d40", "filename": "gcc/cp/search.c", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ae32012466e09d67dd4eed3f74ea74f9c2629e/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=70ae32012466e09d67dd4eed3f74ea74f9c2629e", "patch": "@@ -150,7 +150,7 @@ static void setup_class_bindings PROTO ((tree, int));\n static int template_self_reference_p PROTO ((tree, tree));\n static void fixup_all_virtual_upcast_offsets PROTO ((tree, tree));\n static tree dfs_mark_primary_bases PROTO((tree, void *));\n-static tree get_shared_vbase_if_not_primary PROTO((tree, tree));\n+static tree get_shared_vbase_if_not_primary PROTO((tree, void *));\n static tree dfs_find_vbase_instance PROTO((tree, void *));\n \n /* Allocate a level of searching.  */\n@@ -2240,12 +2240,17 @@ mark_primary_bases (type)\n    either a non-virtual base or a primary virtual base.  */\n \n static tree\n-get_shared_vbase_if_not_primary (binfo, type)\n+get_shared_vbase_if_not_primary (binfo, data)\n      tree binfo;\n-     tree type;\n+     void *data;\n {\n   if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n     {\n+      tree type = (tree) data;\n+\n+      if (TREE_CODE (type) == TREE_LIST)\n+\ttype = TREE_PURPOSE (type);\n+\n       /* This is a non-primary virtual base.  If there is no primary\n \t version, get the shared version.  */\n       binfo = BINFO_FOR_VBASE (BINFO_TYPE (binfo), type);\n@@ -2271,11 +2276,7 @@ dfs_unmarked_real_bases_queue_p (binfo, data)\n      tree binfo;\n      void *data;\n {\n-  tree type = (tree) data;\n-\n-  if (TREE_CODE (type) == TREE_LIST)\n-    type = TREE_PURPOSE (type);\n-  binfo = get_shared_vbase_if_not_primary (binfo, type); \n+  binfo = get_shared_vbase_if_not_primary (binfo, data); \n   return binfo ? unmarkedp (binfo, NULL) : NULL_TREE;\n }\n \n@@ -2287,14 +2288,34 @@ dfs_marked_real_bases_queue_p (binfo, data)\n      tree binfo;\n      void *data;\n {\n-  tree type = (tree) data;\n-\n-  if (TREE_CODE (type) == TREE_LIST)\n-    type = TREE_PURPOSE (type);\n-  binfo = get_shared_vbase_if_not_primary (binfo, type);\n+  binfo = get_shared_vbase_if_not_primary (binfo, data); \n   return binfo ? markedp (binfo, NULL) : NULL_TREE;\n }\n \n+/* Like dfs_unmarked_real_bases_queue_p but walks only into things\n+   that are not BINFO_VTABLE_PATH_MARKED.  */\n+\n+tree\n+dfs_vtable_path_unmarked_real_bases_queue_p (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  binfo = get_shared_vbase_if_not_primary (binfo, data); \n+  return binfo ? unmarked_vtable_pathp (binfo, NULL): NULL_TREE;\n+}\n+\n+/* Like dfs_unmarked_real_bases_queue_p but walks only into things\n+   that are BINFO_VTABLE_PATH_MARKED.  */\n+\n+tree\n+dfs_vtable_path_marked_real_bases_queue_p (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  binfo = get_shared_vbase_if_not_primary (binfo, data); \n+  return binfo ? marked_vtable_pathp (binfo, NULL): NULL_TREE;\n+}\n+\n /* A queue function that skips all virtual bases (and their \n    bases).  */\n \n@@ -2546,15 +2567,22 @@ dfs_vbase_unmark (binfo, data)\n   return dfs_unmark (binfo, data);\n }\n \n+/* Clear BINFO_VTABLE_PATH_MARKED.  */\n+\n+tree\n+dfs_vtable_path_unmark (binfo, data)\n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{ \n+  CLEAR_BINFO_VTABLE_PATH_MARKED (binfo); \n+  return NULL_TREE;\n+}\n+\n #if 0\n static void\n dfs_mark_vtable_path (binfo) tree binfo;\n { SET_BINFO_VTABLE_PATH_MARKED (binfo); }\n \n-static void\n-dfs_unmark_vtable_path (binfo) tree binfo;\n-{ CLEAR_BINFO_VTABLE_PATH_MARKED (binfo); }\n-\n static void\n dfs_mark_new_vtable (binfo) tree binfo;\n { SET_BINFO_NEW_VTABLE_MARKED (binfo); }"}]}