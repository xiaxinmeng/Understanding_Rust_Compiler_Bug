{"sha": "d89f355e2df9b99f2d37c0c2820414d9da848661", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg5ZjM1NWUyZGY5Yjk5ZjJkMzdjMGMyODIwNDE0ZDlkYTg0ODY2MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-03-27T19:19:00Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-03-27T19:19:00Z"}, "message": "re PR target/78543 (ICE in push_reload, at reload.c:1349 on powerpc64le-linux-gnu)\n\n[gcc]\n2017-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/78543\n\t* config/rs6000/rs6000.md (bswaphi2_extenddi): Combine bswap\n\tHImode and SImode with zero extend to DImode to one insn.\n\t(bswap<mode>2_extenddi): Likewise.\n\t(bswapsi2_extenddi): Likewise.\n\t(bswaphi2_extendsi): Likewise.\n\t(bswaphi2): Combine bswap HImode and SImode into one insn.\n\tSeparate memory insns from swapping register.\n\t(bswapsi2): Likewise.\n\t(bswap<mode>2): Likewise.\n\t(bswaphi2_internal): Delete, no longer used.\n\t(bswapsi2_internal): Likewise.\n\t(bswap<mode>2_load): Split bswap HImode/SImode into separate load,\n\tstore, and gpr<-gpr swap insns.\n\t(bswap<mode>2_store): Likewise.\n\t(bswaphi2_reg): Register only splitter, combine with the splitter.\n\t(bswaphi2 splitter): Likewise.\n\t(bswapsi2_reg): Likewise.\n\t(bswapsi2 splitter): Likewise.\n\t(bswapdi2): If we have the LDBRX and STDBRX instructions, split\n\tthe insns into load, store, and register/register insns.\n\t(bswapdi2_ldbrx): Likewise.\n\t(bswapdi2_load): Likewise.\n\t(bswapdi2_store): Likewise.\n\t(bswapdi2_reg): Likewise.\n\n[gcc/testsuite]\n2017-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/78543\n\t* gcc.target/powerpc/pr78543.c: New test.\n\nFrom-SVN: r246508", "tree": {"sha": "be558930e8119fcb8d4cd77c87409ffe198eaa01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be558930e8119fcb8d4cd77c87409ffe198eaa01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d89f355e2df9b99f2d37c0c2820414d9da848661", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89f355e2df9b99f2d37c0c2820414d9da848661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d89f355e2df9b99f2d37c0c2820414d9da848661", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89f355e2df9b99f2d37c0c2820414d9da848661/comments", "author": null, "committer": null, "parents": [{"sha": "b6749273120e7354f33d60f6974c55c7e1328387", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6749273120e7354f33d60f6974c55c7e1328387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6749273120e7354f33d60f6974c55c7e1328387"}], "stats": {"total": 269, "additions": 189, "deletions": 80}, "files": [{"sha": "37a904f68fac9bc601e54e4db7d13515b2c67bc1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89f355e2df9b99f2d37c0c2820414d9da848661/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89f355e2df9b99f2d37c0c2820414d9da848661/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d89f355e2df9b99f2d37c0c2820414d9da848661", "patch": "@@ -1,3 +1,31 @@\n+2017-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/78543\n+\t* config/rs6000/rs6000.md (bswaphi2_extenddi): Combine bswap\n+\tHImode and SImode with zero extend to DImode to one insn.\n+\t(bswap<mode>2_extenddi): Likewise.\n+\t(bswapsi2_extenddi): Likewise.\n+\t(bswaphi2_extendsi): Likewise.\n+\t(bswaphi2): Combine bswap HImode and SImode into one insn.\n+\tSeparate memory insns from swapping register.\n+\t(bswapsi2): Likewise.\n+\t(bswap<mode>2): Likewise.\n+\t(bswaphi2_internal): Delete, no longer used.\n+\t(bswapsi2_internal): Likewise.\n+\t(bswap<mode>2_load): Split bswap HImode/SImode into separate load,\n+\tstore, and gpr<-gpr swap insns.\n+\t(bswap<mode>2_store): Likewise.\n+\t(bswaphi2_reg): Register only splitter, combine with the splitter.\n+\t(bswaphi2 splitter): Likewise.\n+\t(bswapsi2_reg): Likewise.\n+\t(bswapsi2 splitter): Likewise.\n+\t(bswapdi2): If we have the LDBRX and STDBRX instructions, split\n+\tthe insns into load, store, and register/register insns.\n+\t(bswapdi2_ldbrx): Likewise.\n+\t(bswapdi2_load): Likewise.\n+\t(bswapdi2_store): Likewise.\n+\t(bswapdi2_reg): Likewise.\n+\n 2017-03-27  Gunther Nikl  <gnikl@users.sourceforge.net>\n \n \t* system.h (HAVE_DESIGNATED_INITIALIZERS): Fix non C++ case."}, {"sha": "d1da8042220a92293efc5385e1ff85e0bec85f8e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 96, "deletions": 80, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89f355e2df9b99f2d37c0c2820414d9da848661/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89f355e2df9b99f2d37c0c2820414d9da848661/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=d89f355e2df9b99f2d37c0c2820414d9da848661", "patch": "@@ -2350,12 +2350,12 @@\n \n ;; Since the hardware zeros the upper part of the register, save generating the\n ;; AND immediate if we are converting to unsigned\n-(define_insn \"*bswaphi2_extenddi\"\n+(define_insn \"*bswap<mode>2_extenddi\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(zero_extend:DI\n-\t (bswap:HI (match_operand:HI 1 \"memory_operand\" \"Z\"))))]\n+\t (bswap:HSI (match_operand:HSI 1 \"memory_operand\" \"Z\"))))]\n   \"TARGET_POWERPC64\"\n-  \"lhbrx %0,%y1\"\n+  \"l<wd>brx %0,%y1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"load\")])\n \n@@ -2368,34 +2368,52 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"load\")])\n \n-(define_expand \"bswaphi2\"\n-  [(parallel [(set (match_operand:HI 0 \"reg_or_mem_operand\" \"\")\n-\t\t   (bswap:HI\n-\t\t    (match_operand:HI 1 \"reg_or_mem_operand\" \"\")))\n-\t      (clobber (match_scratch:SI 2 \"\"))])]\n+;; Separate the bswap patterns into load, store, and gpr<-gpr.  This prevents\n+;; the register allocator from converting a gpr<-gpr swap into a store and then\n+;; load with byte swap, which can be slower than doing it in the registers.  It\n+;; also prevents certain failures with the RELOAD register allocator.\n+\n+(define_expand \"bswap<mode>2\"\n+  [(use (match_operand:HSI 0 \"reg_or_mem_operand\"))\n+   (use (match_operand:HSI 1 \"reg_or_mem_operand\"))]\n   \"\"\n {\n-  if (!REG_P (operands[0]) && !REG_P (operands[1]))\n-    operands[1] = force_reg (HImode, operands[1]);\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+\n+  if (!REG_P (dest) && !REG_P (src))\n+    src = force_reg (<MODE>mode, src);\n+\n+  if (MEM_P (src))\n+    emit_insn (gen_bswap<mode>2_load (dest, src));\n+  else if (MEM_P (dest))\n+    emit_insn (gen_bswap<mode>2_store (dest, src));\n+  else\n+    emit_insn (gen_bswap<mode>2_reg (dest, src));\n+  DONE;\n })\n \n-(define_insn \"bswaphi2_internal\"\n-  [(set (match_operand:HI 0 \"reg_or_mem_operand\" \"=r,Z,&r\")\n-\t(bswap:HI\n-\t (match_operand:HI 1 \"reg_or_mem_operand\" \"Z,r,r\")))\n-   (clobber (match_scratch:SI 2 \"=X,X,&r\"))]\n+(define_insn \"bswap<mode>2_load\"\n+  [(set (match_operand:HSI 0 \"gpc_reg_operand\" \"=r\")\n+\t(bswap:HSI (match_operand:HSI 1 \"memory_operand\" \"Z\")))]\n   \"\"\n-  \"@\n-   lhbrx %0,%y1\n-   sthbrx %1,%y0\n-   #\"\n-  [(set_attr \"length\" \"4,4,12\")\n-   (set_attr \"type\" \"load,store,*\")])\n+  \"l<wd>brx %0,%y1\"\n+  [(set_attr \"type\" \"load\")])\n \n-(define_split\n-  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"\")\n-\t(bswap:HI (match_operand:HI 1 \"gpc_reg_operand\" \"\")))\n-   (clobber (match_operand:SI 2 \"gpc_reg_operand\" \"\"))]\n+(define_insn \"bswap<mode>2_store\"\n+  [(set (match_operand:HSI 0 \"memory_operand\" \"=Z\")\n+\t(bswap:HSI (match_operand:HSI 1 \"gpc_reg_operand\" \"r\")))]\n+  \"\"\n+  \"st<wd>brx %1,%y0\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn_and_split \"bswaphi2_reg\"\n+  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"=&r\")\n+\t(bswap:HI\n+\t (match_operand:HI 1 \"gpc_reg_operand\" \"r\")))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"\"\n+  \"#\"\n   \"reload_completed\"\n   [(set (match_dup 3)\n \t(and:SI (lshiftrt:SI (match_dup 4)\n@@ -2408,48 +2426,21 @@\n    (set (match_dup 3)\n \t(ior:SI (match_dup 3)\n \t\t(match_dup 2)))]\n-  \"\n {\n   operands[3] = simplify_gen_subreg (SImode, operands[0], HImode, 0);\n   operands[4] = simplify_gen_subreg (SImode, operands[1], HImode, 0);\n-}\")\n-\n-(define_insn \"*bswapsi2_extenddi\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(zero_extend:DI\n-\t (bswap:SI (match_operand:SI 1 \"memory_operand\" \"Z\"))))]\n-  \"TARGET_POWERPC64\"\n-  \"lwbrx %0,%y1\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"load\")])\n-\n-(define_expand \"bswapsi2\"\n-  [(set (match_operand:SI 0 \"reg_or_mem_operand\" \"\")\n-\t(bswap:SI\n-\t (match_operand:SI 1 \"reg_or_mem_operand\" \"\")))]\n-  \"\"\n-{\n-  if (!REG_P (operands[0]) && !REG_P (operands[1]))\n-    operands[1] = force_reg (SImode, operands[1]);\n-})\n-\n-(define_insn \"*bswapsi2_internal\"\n-  [(set (match_operand:SI 0 \"reg_or_mem_operand\" \"=r,Z,&r\")\n-\t(bswap:SI\n-\t (match_operand:SI 1 \"reg_or_mem_operand\" \"Z,r,r\")))]\n-  \"\"\n-  \"@\n-   lwbrx %0,%y1\n-   stwbrx %1,%y0\n-   #\"\n-  [(set_attr \"length\" \"4,4,12\")\n-   (set_attr \"type\" \"load,store,*\")])\n+}\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"*\")])\n \n ;; We are always BITS_BIG_ENDIAN, so the bit positions below in\n ;; zero_extract insns do not change for -mlittle.\n-(define_split\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(bswap:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n+(define_insn_and_split \"bswapsi2_reg\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=&r\")\n+\t(bswap:SI\n+\t (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n+  \"\"\n+  \"#\"\n   \"reload_completed\"\n   [(set (match_dup 0)\t\t\t\t\t; DABC\n \t(rotate:SI (match_dup 1)\n@@ -2465,11 +2456,13 @@\n \t\t\t\t     (const_int 24))\n \t\t\t(const_int 255))\n \t\t(and:SI (match_dup 0)\n-\t\t\t(const_int -256))))\n-\n-  ]\n+\t\t\t(const_int -256))))]\n   \"\")\n \n+;; On systems with LDBRX/STDBRX generate the loads/stores directly, just like\n+;; we do for L{H,W}BRX and ST{H,W}BRX above.  If not, we have to generate more\n+;; complex code.\n+\n (define_expand \"bswapdi2\"\n   [(parallel [(set (match_operand:DI 0 \"reg_or_mem_operand\" \"\")\n \t\t   (bswap:DI\n@@ -2478,33 +2471,56 @@\n \t      (clobber (match_scratch:DI 3 \"\"))])]\n   \"\"\n {\n-  if (!REG_P (operands[0]) && !REG_P (operands[1]))\n-    operands[1] = force_reg (DImode, operands[1]);\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+\n+  if (!REG_P (dest) && !REG_P (src))\n+    operands[1] = src = force_reg (DImode, src);\n+\n+  if (TARGET_POWERPC64 && TARGET_LDBRX)\n+    {\n+      if (MEM_P (src))\n+\temit_insn (gen_bswapdi2_load (dest, src));\n+      else if (MEM_P (dest))\n+\temit_insn (gen_bswapdi2_store (dest, src));\n+      else\n+\temit_insn (gen_bswapdi2_reg (dest, src));\n+      DONE;\n+    }\n \n   if (!TARGET_POWERPC64)\n     {\n       /* 32-bit mode needs fewer scratch registers, but 32-bit addressing mode\n \t that uses 64-bit registers needs the same scratch registers as 64-bit\n \t mode.  */\n-      emit_insn (gen_bswapdi2_32bit (operands[0], operands[1]));\n+      emit_insn (gen_bswapdi2_32bit (dest, src));\n       DONE;\n     }\n })\n \n ;; Power7/cell has ldbrx/stdbrx, so use it directly\n-(define_insn \"*bswapdi2_ldbrx\"\n-  [(set (match_operand:DI 0 \"reg_or_mem_operand\" \"=r,Z,&r\")\n-\t(bswap:DI (match_operand:DI 1 \"reg_or_mem_operand\" \"Z,r,r\")))\n-   (clobber (match_scratch:DI 2 \"=X,X,&r\"))\n-   (clobber (match_scratch:DI 3 \"=X,X,&r\"))]\n-  \"TARGET_POWERPC64 && TARGET_LDBRX\n-   && (REG_P (operands[0]) || REG_P (operands[1]))\"\n-  \"@\n-   ldbrx %0,%y1\n-   stdbrx %1,%y0\n-   #\"\n-  [(set_attr \"length\" \"4,4,36\")\n-   (set_attr \"type\" \"load,store,*\")])\n+(define_insn \"bswapdi2_load\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(bswap:DI (match_operand:DI 1 \"memory_operand\" \"Z\")))]\n+  \"TARGET_POWERPC64 && TARGET_LDBRX\"\n+  \"ldbrx %0,%y1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"bswapdi2_store\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=Z\")\n+\t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_POWERPC64 && TARGET_LDBRX\"\n+  \"stdbrx %1,%y0\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"bswapdi2_reg\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r\")\n+\t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))\n+   (clobber (match_scratch:DI 2 \"=&r\"))\n+   (clobber (match_scratch:DI 3 \"=&r\"))]\n+  \"TARGET_POWERPC64 && TARGET_LDBRX\"\n+  \"#\"\n+  [(set_attr \"length\" \"36\")])\n \n ;; Non-power7/cell, fall back to use lwbrx/stwbrx\n (define_insn \"*bswapdi2_64bit\""}, {"sha": "8cac7ec4a1a0b29a643db4e0049290a194dcd545", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89f355e2df9b99f2d37c0c2820414d9da848661/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89f355e2df9b99f2d37c0c2820414d9da848661/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d89f355e2df9b99f2d37c0c2820414d9da848661", "patch": "@@ -1,3 +1,8 @@\n+2017-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/78543\n+\t* gcc.target/powerpc/pr78543.c: New test.\n+\n 2017-03-27  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \tPR target/80103"}, {"sha": "0421344d3cedf614148a6504e9ade151f6aa921c", "filename": "gcc/testsuite/gcc.target/powerpc/pr78543.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89f355e2df9b99f2d37c0c2820414d9da848661/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr78543.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89f355e2df9b99f2d37c0c2820414d9da848661/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr78543.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr78543.c?ref=d89f355e2df9b99f2d37c0c2820414d9da848661", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O1 -mno-lra\" } */\n+\n+typedef long a;\n+enum c { e, f, g, h, i, ab } j();\n+int l, n, o, p;\n+a q, r;\n+void *memcpy();\n+void b();\n+static int k(int *s) {\n+  int m;\n+  if (j(&m))\n+    *s = m;\n+  return !0;\n+}\n+void d(char s) {\n+  int af[4];\n+  int ag;\n+  enum c ah;\n+  char ai[24 << 11];\n+  unsigned aj;\n+  if (!k(&aj))\n+    goto ak;\n+  for (;;) {\n+    if (!k(&ag))\n+      goto ak;\n+    switch (ah) {\n+    case e:\n+      b(\"\");\n+      b(\"bad length %d for GUID in fileinfo v%u for \\\"%s\\\"\");\n+    case i:\n+      b(\"bad length %d for TTH in fileinfo v%u for \\\"%s\\\"\", aj);\n+    case ab:\n+      if (ag % 24)\n+        b(\"for \\\"%s\\\"\", s);\n+    case f:\n+      if (20 == ag)\n+      case h:\n+        if (20 == ag)\n+          o = 0;\n+      break;\n+    case g:\n+      memcpy(af, ai, sizeof af);\n+      b();\n+      if (p) {\n+        a al, am;\n+        r = al << 2 | am;\n+        n = af[2];\n+        al = n;\n+        l = __builtin_bswap32(af[3]);\n+        am = q = n | l;\n+      }\n+    default:\n+      b(\"%s0 unhandled field ID %u 0\", __func__);\n+    }\n+  }\n+ak:;\n+}"}]}