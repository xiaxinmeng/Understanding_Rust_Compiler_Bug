{"sha": "4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI2ZTU1ZGYyM2JmMjRiNmY3M2E1MzUxMGJlZjk3YWU4ZjhjYzBiNA==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2009-06-26T18:27:30Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2009-06-26T18:27:30Z"}, "message": "re PR c/39902 (x * 1.0DF gets wrong value)\n\n\tPR c/39902\n\t* tree.c (real_zerop, real_onep, real_twop, real_minus_onep):\n\tSpecial-case decimal float constants.\n\n\t* gcc.dg/dfp/pr39902.c: New test.\n\nFrom-SVN: r148982", "tree": {"sha": "a476e7280267448dc0d062d76cbeb6102d637d18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a476e7280267448dc0d062d76cbeb6102d637d18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4/comments", "author": null, "committer": null, "parents": [{"sha": "27dbd3ac30a786c4081b2a1d75c3996bff35a374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27dbd3ac30a786c4081b2a1d75c3996bff35a374", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27dbd3ac30a786c4081b2a1d75c3996bff35a374"}], "stats": {"total": 275, "additions": 267, "deletions": 8}, "files": [{"sha": "34db7459a2b277d591a866f08cf5c0f5d1f4bb78", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4", "patch": "@@ -1,3 +1,9 @@\n+2009-06-26  Janis Johnson  <janis187@us.ibm.com>\n+\n+\tPR c/39902\n+\t* tree.c (real_zerop, real_onep, real_twop, real_minus_onep):\n+\tSpecial-case decimal float constants.\n+\n 2009-06-26  Richard Henderson  <rth@redhat.com>\n \n \t* function.h (struct function): Add cannot_be_copied_reason,"}, {"sha": "4956bfc45a36d5a229c640e005bb5811851162bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4", "patch": "@@ -1,3 +1,8 @@\n+2009-06-26  Janis Johnson  <janis187@us.ibm.com>\n+\n+\tPR c/39902\n+\t* gcc.dg/dfp/pr39902.c: New test.\n+\n 2009-06-26  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR testsuite/40532"}, {"sha": "8c4e7b2438090d11739195938085c8e05c3ee6c8", "filename": "gcc/testsuite/gcc.dg/dfp/pr39902.c", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fpr39902.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fpr39902.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fpr39902.c?ref=4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4", "patch": "@@ -0,0 +1,239 @@\n+/* { dg-options \"--std=gnu99\" } */\n+\n+/* Check that optimizations like (x * 1) to x, or (x * -1) to -x,\n+   do not apply to decimal float computations where trailing zeroes\n+   are significant.  */\n+\n+extern void abort (void);\n+int failcnt;\n+\n+#ifdef DBG\n+extern int printf (const char *, ...);\n+#define FAILURE { printf (\"failed at line %d\\n\", __LINE__); failcnt++; }\n+#else\n+#define FAILURE abort ();\n+#endif\n+\n+#define COMPARE32(A,B) \\\n+  A.i == B.i\n+\n+#define COMPARE64(A,B) \\\n+  A.i[0] == B.i[0] && A.i[1] == B.i[1]\n+\n+#define COMPARE128(A,B) \\\n+  A.i[0] == B.i[0] && A.i[1] == B.i[1] && A.i[2] == B.i[2] && A.i[3] == B.i[3]\n+\n+typedef union {\n+  _Decimal32 d;\n+  unsigned int i;\n+} u32;\n+\n+typedef union {\n+  _Decimal64 d;\n+  unsigned int i[2];\n+} u64;\n+\n+typedef union {\n+  _Decimal128 d;\n+  unsigned int i[4];\n+} u128;\n+\n+volatile u32 p32_1;\n+volatile u32 p32_1_0;\n+volatile u32 p32_2_0;\n+volatile u32 m32_1;\n+volatile u32 m32_1_0;\n+volatile u32 m32_2_0;\n+volatile u32 a32;\n+\n+volatile u64 p64_1;\n+volatile u64 p64_1_0;\n+volatile u64 p64_2_0;\n+volatile u64 m64_1;\n+volatile u64 m64_1_0;\n+volatile u64 m64_2_0;\n+volatile u64 a64;\n+\n+volatile u128 p128_1;\n+volatile u128 p128_1_0;\n+volatile u128 p128_2_0;\n+volatile u128 m128_1;\n+volatile u128 m128_1_0;\n+volatile u128 m128_2_0;\n+volatile u128 a128;\n+\n+void\n+init32 (void)\n+{\n+  p32_1.d = 1.DF;\n+  p32_1_0.d = 1.0DF;\n+  p32_2_0.d = 2.0DF;\n+  m32_1.d = -1.DF;\n+  m32_1_0.d = -1.0DF;\n+  m32_2_0.d = -2.0DF;\n+}\n+\n+void\n+init64 (void)\n+{\n+  p64_1.d = 1.DD;\n+  p64_1_0.d = 1.0DD;\n+  p64_2_0.d = 2.0DD;\n+  m64_1.d = -1.DD;\n+  m64_1_0.d = -1.0DD;\n+  m64_2_0.d = -2.0DD;\n+}\n+\n+void\n+init128 (void)\n+{\n+  p128_1.d = 1.DL;\n+  p128_1_0.d = 1.0DL;\n+  p128_2_0.d = 2.0DL;\n+  m128_1.d = -1.DL;\n+  m128_1_0.d = -1.0DL;\n+  m128_2_0.d = -2.0DL;\n+}\n+\n+void\n+doit32 (void)\n+{\n+  /* Multiplying by a value with no trailing zero should not change the\n+     quantum exponent.  */\n+\n+  a32.d = p32_2_0.d * p32_1.d;\n+  if (! (COMPARE32 (a32, p32_2_0)))\n+    FAILURE\n+\n+  a32.d = p32_2_0.d * 1.DF;\n+  if (! (COMPARE32 (a32, p32_2_0)))\n+    FAILURE\n+\n+  a32.d = p32_2_0.d * m32_1.d;\n+  if (! (COMPARE32 (a32, m32_2_0)))\n+    FAILURE\n+\n+  a32.d = p32_2_0.d * -1.DF;\n+  if (! (COMPARE32 (a32, m32_2_0)))\n+    FAILURE\n+\n+  /* Multiplying by a value with a trailing zero should change the\n+     quantum exponent.  */\n+\n+  a32.d = p32_2_0.d * p32_1_0.d;\n+  if (COMPARE32 (a32, p32_2_0))\n+    FAILURE\n+\n+  a32.d = p32_2_0.d * 1.0DF;\n+  if (COMPARE32 (a32, p32_2_0))\n+    FAILURE\n+\n+  a32.d = p32_2_0.d * m32_1_0.d;\n+  if (COMPARE32 (a32, m32_2_0))\n+    FAILURE\n+\n+  a32.d = p32_2_0.d * -1.0DF;\n+  if (COMPARE32 (a32, m32_2_0))\n+    FAILURE\n+}\n+\n+void\n+doit64 (void)\n+{\n+  /* Multiplying by a value with no trailing zero should not change the\n+     quantum exponent.  */\n+\n+  a64.d = p64_2_0.d * p64_1.d;\n+  if (! (COMPARE64 (a64, p64_2_0)))\n+    FAILURE\n+\n+  a64.d = p64_2_0.d * 1.DD;\n+  if (! (COMPARE64 (a64, p64_2_0)))\n+    FAILURE\n+\n+  a64.d = p64_2_0.d * m64_1.d;\n+  if (! (COMPARE64 (a64, m64_2_0)))\n+    FAILURE\n+\n+  a64.d = p64_2_0.d * -1.DD;\n+  if (! (COMPARE64 (a64, m64_2_0)))\n+    FAILURE\n+\n+  /* Multiplying by a value with a trailing zero should change the\n+     quantum exponent.  */\n+\n+  a64.d = p64_2_0.d * p64_1_0.d;\n+  if (COMPARE64 (a64, p64_2_0))\n+    FAILURE\n+\n+  a64.d = p64_2_0.d * 1.0DD;\n+  if (COMPARE64 (a64, p64_2_0))\n+    FAILURE\n+\n+  a64.d = p64_2_0.d * m64_1_0.d;\n+  if (COMPARE64 (a64, m64_2_0))\n+    FAILURE\n+\n+  a64.d = p64_2_0.d * -1.0DD;\n+  if (COMPARE64 (a64, m64_2_0))\n+    FAILURE\n+}\n+\n+void\n+doit128 (void)\n+{\n+  /* Multiplying by a value with no trailing zero should not change the\n+     quantum exponent.  */\n+\n+  a128.d = p128_2_0.d * p128_1_0.d;\n+  if (COMPARE128 (a128, p128_2_0))\n+    FAILURE\n+\n+  a128.d = p128_2_0.d * 1.0DD;\n+  if (COMPARE128 (a128, p128_2_0))\n+    FAILURE\n+\n+  a128.d = p128_2_0.d * m128_1_0.d;\n+  if (COMPARE128 (a128, m128_2_0))\n+    FAILURE\n+\n+  a128.d = p128_2_0.d * -1.0DD;\n+  if (COMPARE128 (a128, m128_2_0))\n+    FAILURE\n+\n+  /* Multiplying by a value with a trailing zero should change the\n+     quantum exponent.  */\n+\n+  a128.d = p128_2_0.d * p128_1.d;\n+  if (! (COMPARE128 (a128, p128_2_0)))\n+    FAILURE\n+\n+  a128.d = p128_2_0.d * 1.DD;\n+  if (! (COMPARE128 (a128, p128_2_0)))\n+    FAILURE\n+\n+  a128.d = p128_2_0.d * m128_1.d;\n+  if (! (COMPARE128 (a128, m128_2_0)))\n+    FAILURE\n+\n+  a128.d = p128_2_0.d * -1.DD;\n+  if (! (COMPARE128 (a128, m128_2_0)))\n+    FAILURE\n+}\n+\n+int\n+main (void)\n+{\n+  init32 ();\n+  init64 ();\n+  init128 ();\n+\n+  doit32 ();\n+  doit64 ();\n+  doit128 ();\n+\n+  if (failcnt != 0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "ffdd8888ea3a6c8defc5e52cbbc7bf07b7f0fd2b", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4b6e55df23bf24b6f73a53510bef97ae8f8cc0b4", "patch": "@@ -1591,57 +1591,66 @@ tree_floor_log2 (const_tree expr)\n \t  : floor_log2 (low));\n }\n \n-/* Return 1 if EXPR is the real constant zero.  */\n+/* Return 1 if EXPR is the real constant zero.  Trailing zeroes matter for\n+   decimal float constants, so don't return 1 for them.  */\n \n int\n real_zerop (const_tree expr)\n {\n   STRIP_NOPS (expr);\n \n   return ((TREE_CODE (expr) == REAL_CST\n-\t   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconst0))\n+\t   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconst0)\n+\t   && !(DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (expr)))))\n \t  || (TREE_CODE (expr) == COMPLEX_CST\n \t      && real_zerop (TREE_REALPART (expr))\n \t      && real_zerop (TREE_IMAGPART (expr))));\n }\n \n-/* Return 1 if EXPR is the real constant one in real or complex form.  */\n+/* Return 1 if EXPR is the real constant one in real or complex form.\n+   Trailing zeroes matter for decimal float constants, so don't return\n+   1 for them.  */\n \n int\n real_onep (const_tree expr)\n {\n   STRIP_NOPS (expr);\n \n   return ((TREE_CODE (expr) == REAL_CST\n-\t   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconst1))\n+\t   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconst1)\n+\t   && !(DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (expr)))))\n \t  || (TREE_CODE (expr) == COMPLEX_CST\n \t      && real_onep (TREE_REALPART (expr))\n \t      && real_zerop (TREE_IMAGPART (expr))));\n }\n \n-/* Return 1 if EXPR is the real constant two.  */\n+/* Return 1 if EXPR is the real constant two.  Trailing zeroes matter\n+   for decimal float constants, so don't return 1 for them.  */\n \n int\n real_twop (const_tree expr)\n {\n   STRIP_NOPS (expr);\n \n   return ((TREE_CODE (expr) == REAL_CST\n-\t   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconst2))\n+\t   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconst2)\n+\t   && !(DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (expr)))))\n \t  || (TREE_CODE (expr) == COMPLEX_CST\n \t      && real_twop (TREE_REALPART (expr))\n \t      && real_zerop (TREE_IMAGPART (expr))));\n }\n \n-/* Return 1 if EXPR is the real constant minus one.  */\n+/* Return 1 if EXPR is the real constant minus one.  Trailing zeroes\n+   matter for decimal float constants, so don't return 1 for them.  */\n \n int\n real_minus_onep (const_tree expr)\n {\n   STRIP_NOPS (expr);\n \n   return ((TREE_CODE (expr) == REAL_CST\n-\t   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconstm1))\n+\t   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconstm1)\n+\t   && !(DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (expr)))))\n \t  || (TREE_CODE (expr) == COMPLEX_CST\n \t      && real_minus_onep (TREE_REALPART (expr))\n \t      && real_zerop (TREE_IMAGPART (expr))));"}]}