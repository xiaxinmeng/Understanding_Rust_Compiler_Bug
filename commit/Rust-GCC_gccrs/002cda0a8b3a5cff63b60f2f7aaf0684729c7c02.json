{"sha": "002cda0a8b3a5cff63b60f2f7aaf0684729c7c02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAyY2RhMGE4YjNhNWNmZjYzYjYwZjJmN2FhZjA2ODQ3MjljN2MwMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-01-22T18:52:01Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-01-22T18:52:01Z"}, "message": "re PR tree-optimization/42833 (sra miscompiles qemu)\n\n\tPR tree-opt/42833\n\t* tree-sra.c (sra_modify_assign): Delay re-gimplification of\n\tthe RHS until after generate_subtree_copies has insertted its\n\tcode before the current statement.\n\nFrom-SVN: r156176", "tree": {"sha": "3305726401c185237a4df96747f19c0599fc7716", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3305726401c185237a4df96747f19c0599fc7716"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/002cda0a8b3a5cff63b60f2f7aaf0684729c7c02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002cda0a8b3a5cff63b60f2f7aaf0684729c7c02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/002cda0a8b3a5cff63b60f2f7aaf0684729c7c02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002cda0a8b3a5cff63b60f2f7aaf0684729c7c02/comments", "author": null, "committer": null, "parents": [{"sha": "728d406cd758c24a4e63f1e3089827fd2c470358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/728d406cd758c24a4e63f1e3089827fd2c470358", "html_url": "https://github.com/Rust-GCC/gccrs/commit/728d406cd758c24a4e63f1e3089827fd2c470358"}], "stats": {"total": 200, "additions": 191, "deletions": 9}, "files": [{"sha": "10a3626dedb482223359ea8ba01544df72682645", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002cda0a8b3a5cff63b60f2f7aaf0684729c7c02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002cda0a8b3a5cff63b60f2f7aaf0684729c7c02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=002cda0a8b3a5cff63b60f2f7aaf0684729c7c02", "patch": "@@ -1,3 +1,10 @@\n+2010-01-22  Richard Henderson  <rth@redhat.com>\n+\n+\tPR tree-opt/42833\n+\t* tree-sra.c (sra_modify_assign): Delay re-gimplification of\n+\tthe RHS until after generate_subtree_copies has insertted its\n+\tcode before the current statement.\n+\n 2010-01-22  Joern Rennecke  <amylaar@spamcop.net>\n \n \t* doc/tm.texi (TARGET_MIN_DIVISIONS_FOR_RECIP_MUL): Fix return type."}, {"sha": "5494f98686ec6a5975824d00ae0db3f78b33d8e2", "filename": "gcc/testsuite/gcc.c-torture/execute/pr42833.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002cda0a8b3a5cff63b60f2f7aaf0684729c7c02/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr42833.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002cda0a8b3a5cff63b60f2f7aaf0684729c7c02/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr42833.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr42833.c?ref=002cda0a8b3a5cff63b60f2f7aaf0684729c7c02", "patch": "@@ -0,0 +1,171 @@\n+typedef __INT_LEAST8_TYPE__ int8_t;\n+typedef __UINT_LEAST32_TYPE__ uint32_t;\n+typedef int ssize_t;\n+typedef struct { int8_t v1; int8_t v2; int8_t v3; int8_t v4; } neon_s8;\n+\n+uint32_t helper_neon_rshl_s8 (uint32_t arg1, uint32_t arg2);\n+\n+uint32_t\n+helper_neon_rshl_s8 (uint32_t arg1, uint32_t arg2)\n+{\n+  uint32_t res;\n+  neon_s8 vsrc1;\n+  neon_s8 vsrc2;\n+  neon_s8 vdest;\n+  do\n+    {\n+      union\n+      {\n+\tneon_s8 v;\n+\tuint32_t i;\n+      } conv_u;\n+      conv_u.i = (arg1);\n+      vsrc1 = conv_u.v;\n+    }\n+  while (0);\n+  do\n+    {\n+      union\n+      {\n+\tneon_s8 v;\n+\tuint32_t i;\n+      } conv_u;\n+      conv_u.i = (arg2);\n+      vsrc2 = conv_u.v;\n+    }\n+  while (0);\n+  do\n+    {\n+      int8_t tmp;\n+      tmp = (int8_t) vsrc2.v1;\n+      if (tmp >= (ssize_t) sizeof (vsrc1.v1) * 8)\n+\t{\n+\t  vdest.v1 = 0;\n+\t}\n+      else if (tmp < -(ssize_t) sizeof (vsrc1.v1) * 8)\n+\t{\n+\t  vdest.v1 = vsrc1.v1 >> (sizeof (vsrc1.v1) * 8 - 1);\n+\t}\n+      else if (tmp == -(ssize_t) sizeof (vsrc1.v1) * 8)\n+\t{\n+\t  vdest.v1 = vsrc1.v1 >> (tmp - 1);\n+\t  vdest.v1++;\n+\t  vdest.v1 >>= 1;\n+\t}\n+      else if (tmp < 0)\n+\t{\n+\t  vdest.v1 = (vsrc1.v1 + (1 << (-1 - tmp))) >> -tmp;\n+\t}\n+      else\n+\t{\n+\t  vdest.v1 = vsrc1.v1 << tmp;\n+\t}\n+    }\n+  while (0);\n+  do\n+    {\n+      int8_t tmp;\n+      tmp = (int8_t) vsrc2.v2;\n+      if (tmp >= (ssize_t) sizeof (vsrc1.v2) * 8)\n+\t{\n+\t  vdest.v2 = 0;\n+\t}\n+      else if (tmp < -(ssize_t) sizeof (vsrc1.v2) * 8)\n+\t{\n+\t  vdest.v2 = vsrc1.v2 >> (sizeof (vsrc1.v2) * 8 - 1);\n+\t}\n+      else if (tmp == -(ssize_t) sizeof (vsrc1.v2) * 8)\n+\t{\n+\t  vdest.v2 = vsrc1.v2 >> (tmp - 1);\n+\t  vdest.v2++;\n+\t  vdest.v2 >>= 1;\n+\t}\n+      else if (tmp < 0)\n+\t{\n+\t  vdest.v2 = (vsrc1.v2 + (1 << (-1 - tmp))) >> -tmp;\n+\t}\n+      else\n+\t{\n+\t  vdest.v2 = vsrc1.v2 << tmp;\n+\t}\n+    }\n+  while (0);\n+  do\n+    {\n+      int8_t tmp;\n+      tmp = (int8_t) vsrc2.v3;\n+      if (tmp >= (ssize_t) sizeof (vsrc1.v3) * 8)\n+\t{\n+\t  vdest.v3 = 0;\n+\t}\n+      else if (tmp < -(ssize_t) sizeof (vsrc1.v3) * 8)\n+\t{\n+\t  vdest.v3 = vsrc1.v3 >> (sizeof (vsrc1.v3) * 8 - 1);\n+\t}\n+      else if (tmp == -(ssize_t) sizeof (vsrc1.v3) * 8)\n+\t{\n+\t  vdest.v3 = vsrc1.v3 >> (tmp - 1);\n+\t  vdest.v3++;\n+\t  vdest.v3 >>= 1;\n+\t}\n+      else if (tmp < 0)\n+\t{\n+\t  vdest.v3 = (vsrc1.v3 + (1 << (-1 - tmp))) >> -tmp;\n+\t}\n+      else\n+\t{\n+\t  vdest.v3 = vsrc1.v3 << tmp;\n+\t}\n+    }\n+  while (0);\n+  do\n+    {\n+      int8_t tmp;\n+      tmp = (int8_t) vsrc2.v4;\n+      if (tmp >= (ssize_t) sizeof (vsrc1.v4) * 8)\n+\t{\n+\t  vdest.v4 = 0;\n+\t}\n+      else if (tmp < -(ssize_t) sizeof (vsrc1.v4) * 8)\n+\t{\n+\t  vdest.v4 = vsrc1.v4 >> (sizeof (vsrc1.v4) * 8 - 1);\n+\t}\n+      else if (tmp == -(ssize_t) sizeof (vsrc1.v4) * 8)\n+\t{\n+\t  vdest.v4 = vsrc1.v4 >> (tmp - 1);\n+\t  vdest.v4++;\n+\t  vdest.v4 >>= 1;\n+\t}\n+      else if (tmp < 0)\n+\t{\n+\t  vdest.v4 = (vsrc1.v4 + (1 << (-1 - tmp))) >> -tmp;\n+\t}\n+      else\n+\t{\n+\t  vdest.v4 = vsrc1.v4 << tmp;\n+\t}\n+    }\n+  while (0);;\n+  do\n+    {\n+      union\n+      {\n+\tneon_s8 v;\n+\tuint32_t i;\n+      } conv_u;\n+      conv_u.v = (vdest);\n+      res = conv_u.i;\n+    }\n+  while (0);\n+  return res;\n+}\n+\n+extern void abort(void);\n+\n+int main()\n+{\n+  uint32_t r = helper_neon_rshl_s8 (0x05050505, 0x01010101);\n+  if (r != 0x0a0a0a0a)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "79c5c76c5e1e65b403f81b5c89be120b8c8e0afc", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002cda0a8b3a5cff63b60f2f7aaf0684729c7c02/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002cda0a8b3a5cff63b60f2f7aaf0684729c7c02/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=002cda0a8b3a5cff63b60f2f7aaf0684729c7c02", "patch": "@@ -2533,6 +2533,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n   bool modify_this_stmt = false;\n   bool force_gimple_rhs = false;\n   location_t loc = gimple_location (*stmt);\n+  gimple_stmt_iterator orig_gsi = *gsi;\n \n   if (!gimple_assign_single_p (*stmt))\n     return SRA_SA_NONE;\n@@ -2611,15 +2612,6 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\tforce_gimple_rhs = true;\n \t    }\n \t}\n-\n-      if (force_gimple_rhs)\n-\trhs = force_gimple_operand_gsi (gsi, rhs, true, NULL_TREE,\n-\t\t\t\t\ttrue, GSI_SAME_STMT);\n-      if (gimple_assign_rhs1 (*stmt) != rhs)\n-\t{\n-\t  gimple_assign_set_rhs_from_tree (gsi, rhs);\n-\t  gcc_assert (*stmt == gsi_stmt (*gsi));\n-\t}\n     }\n \n   /* From this point on, the function deals with assignments in between\n@@ -2721,6 +2713,18 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t     0, 0, gsi, true, true);\n \t}\n     }\n+\n+  /* This gimplification must be done after generate_subtree_copies, lest we\n+     insert the subtree copies in the middle of the gimplified sequence.  */\n+  if (force_gimple_rhs)\n+    rhs = force_gimple_operand_gsi (&orig_gsi, rhs, true, NULL_TREE,\n+\t\t\t\t    true, GSI_SAME_STMT);\n+  if (gimple_assign_rhs1 (*stmt) != rhs)\n+    {\n+      gimple_assign_set_rhs_from_tree (&orig_gsi, rhs);\n+      gcc_assert (*stmt == gsi_stmt (orig_gsi));\n+    }\n+\n   return modify_this_stmt ? SRA_SA_PROCESSED : SRA_SA_NONE;\n }\n "}]}