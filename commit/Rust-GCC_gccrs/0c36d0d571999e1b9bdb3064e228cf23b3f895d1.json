{"sha": "0c36d0d571999e1b9bdb3064e228cf23b3f895d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMzNmQwZDU3MTk5OWUxYjliZGIzMDY0ZTIyOGNmMjNiM2Y4OTVkMQ==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2017-05-23T09:16:05Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2017-05-23T09:16:05Z"}, "message": "Runtime checking of OpenACC parallelism dimensions clauses\n\n\tlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/parallel-dims.c: Rewrite.\n\t* testsuite/lib/libgomp.exp\n\t(check_effective_target_openacc_nvidia_accel_configured): New\n\tproc.\n\t* testsuite/libgomp.oacc-c++/c++.exp (check_effective_target_c)\n\t(check_effective_target_c++): New procs.\n\t* testsuite/libgomp.oacc-c/c.exp (check_effective_target_c)\n\t(check_effective_target_c++): Likewise.\n\nFrom-SVN: r248358", "tree": {"sha": "2003c332fd252fed38d355567a81209dbddb9b3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2003c332fd252fed38d355567a81209dbddb9b3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c36d0d571999e1b9bdb3064e228cf23b3f895d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c36d0d571999e1b9bdb3064e228cf23b3f895d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c36d0d571999e1b9bdb3064e228cf23b3f895d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c36d0d571999e1b9bdb3064e228cf23b3f895d1/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bdf58f6bf4ef9b7adb07f4107cda30d154fea71d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdf58f6bf4ef9b7adb07f4107cda30d154fea71d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdf58f6bf4ef9b7adb07f4107cda30d154fea71d"}], "stats": {"total": 560, "additions": 548, "deletions": 12}, "files": [{"sha": "8fd5f07e9fa3c000e264d3d51ed754c3306943e3", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c36d0d571999e1b9bdb3064e228cf23b3f895d1/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c36d0d571999e1b9bdb3064e228cf23b3f895d1/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=0c36d0d571999e1b9bdb3064e228cf23b3f895d1", "patch": "@@ -1,3 +1,14 @@\n+2017-05-23  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* testsuite/libgomp.oacc-c-c++-common/parallel-dims.c: Rewrite.\n+\t* testsuite/lib/libgomp.exp\n+\t(check_effective_target_openacc_nvidia_accel_configured): New\n+\tproc.\n+\t* testsuite/libgomp.oacc-c++/c++.exp (check_effective_target_c)\n+\t(check_effective_target_c++): New procs.\n+\t* testsuite/libgomp.oacc-c/c.exp (check_effective_target_c)\n+\t(check_effective_target_c++): Likewise.\n+\n 2017-05-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/80809"}, {"sha": "ea3da2cb38356d8de90460f38a4d81829a52737e", "filename": "libgomp/testsuite/lib/libgomp.exp", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c36d0d571999e1b9bdb3064e228cf23b3f895d1/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c36d0d571999e1b9bdb3064e228cf23b3f895d1/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp?ref=0c36d0d571999e1b9bdb3064e228cf23b3f895d1", "patch": "@@ -359,6 +359,18 @@ proc check_effective_target_offload_device_shared_as { } {\n     } ]\n }\n \n+# Return 1 if configured for nvptx offloading.\n+\n+proc check_effective_target_openacc_nvidia_accel_configured { } {\n+    global offload_targets\n+    if { ![string match \"*,nvptx,*\" \",$offload_targets,\"] } {\n+        return 0\n+    }\n+    # PR libgomp/65099: Currently, we only support offloading in 64-bit\n+    # configurations.\n+    return [is-effective-target lp64]\n+}\n+\n # Return 1 if at least one nvidia board is present.\n \n proc check_effective_target_openacc_nvidia_accel_present { } {"}, {"sha": "9beadd6fc1ebd09a94efb81f6385e62f8cafdb75", "filename": "libgomp/testsuite/libgomp.oacc-c++/c++.exp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c36d0d571999e1b9bdb3064e228cf23b3f895d1/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c36d0d571999e1b9bdb3064e228cf23b3f895d1/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fc%2B%2B.exp?ref=0c36d0d571999e1b9bdb3064e228cf23b3f895d1", "patch": "@@ -4,6 +4,13 @@ load_lib libgomp-dg.exp\n load_gcc_lib gcc-dg.exp\n load_gcc_lib torture-options.exp\n \n+proc check_effective_target_c { } {\n+    return 0\n+}\n+proc check_effective_target_c++ { } {\n+    return 1\n+}\n+\n global shlib_ext\n \n set shlib_ext [get_shlib_extension]"}, {"sha": "d8af5463b6b95324185eb3eb531951e86d5f28e9", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/parallel-dims.c", "status": "modified", "additions": 511, "deletions": 12, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c36d0d571999e1b9bdb3064e228cf23b3f895d1/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fparallel-dims.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c36d0d571999e1b9bdb3064e228cf23b3f895d1/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fparallel-dims.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fparallel-dims.c?ref=0c36d0d571999e1b9bdb3064e228cf23b3f895d1", "patch": "@@ -1,25 +1,524 @@\n-/* { dg-do run { target openacc_nvidia_accel_selected } } */\n+/* OpenACC parallelism dimensions clauses: num_gangs, num_workers,\n+   vector_length.  */\n+\n+#include <limits.h>\n+#include <openacc.h>\n+\n+/* TODO: \"(int) acc_device_*\" casts because of the C++ acc_on_device wrapper\n+   not behaving as expected for -O0.  */\n+#pragma acc routine seq\n+static unsigned int __attribute__ ((optimize (\"O2\"))) acc_gang ()\n+{\n+  if (acc_on_device ((int) acc_device_host))\n+    return 0;\n+  else if (acc_on_device ((int) acc_device_nvidia))\n+    {\n+      unsigned int r;\n+      asm volatile (\"mov.u32 %0,%%ctaid.x;\" : \"=r\" (r));\n+      return r;\n+    }\n+  else\n+    __builtin_abort ();\n+}\n+\n+#pragma acc routine seq\n+static unsigned int __attribute__ ((optimize (\"O2\"))) acc_worker ()\n+{\n+  if (acc_on_device ((int) acc_device_host))\n+    return 0;\n+  else if (acc_on_device ((int) acc_device_nvidia))\n+    {\n+      unsigned int r;\n+      asm volatile (\"mov.u32 %0,%%tid.y;\" : \"=r\" (r));\n+      return r;\n+    }\n+  else\n+    __builtin_abort ();\n+}\n+\n+#pragma acc routine seq\n+static unsigned int __attribute__ ((optimize (\"O2\"))) acc_vector ()\n+{\n+  if (acc_on_device ((int) acc_device_host))\n+    return 0;\n+  else if (acc_on_device ((int) acc_device_nvidia))\n+    {\n+      unsigned int r;\n+      asm volatile (\"mov.u32 %0,%%tid.x;\" : \"=r\" (r));\n+      return r;\n+    }\n+  else\n+    __builtin_abort ();\n+}\n \n-/* Worker and vector size checks.  Picked an outrageously large\n-   value. */\n \n int main ()\n {\n-  int dummy[10];\n+  acc_init (acc_device_default);\n+\n+  /* Non-positive value.  */\n+\n+  /* GR, WS, VS.  */\n+  {\n+#define GANGS 0 /* { dg-warning \"'num_gangs' value must be positive\" \"\" { target c } } */\n+    int gangs_actual = GANGS;\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc parallel copy (gangs_actual) \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max) \\\n+  num_gangs (GANGS) /* { dg-warning \"'num_gangs' value must be positive\" \"\" { target c++ } } */\n+    {\n+      /* We're actually executing with num_gangs (1).  */\n+      gangs_actual = 1;\n+      for (int i = 100 * gangs_actual; i > -100 * gangs_actual; --i)\n+\t{\n+\t  /* <https://gcc.gnu.org/PR80547>.  */\n+#if 0\n+\t  gangs_min = gangs_max = acc_gang ();\n+\t  workers_min = workers_max = acc_worker ();\n+\t  vectors_min = vectors_max = acc_vector ();\n+#else\n+\t  int gangs = acc_gang ();\n+\t  gangs_min = (gangs_min < gangs) ? gangs_min : gangs;\n+\t  gangs_max = (gangs_max > gangs) ? gangs_max : gangs;\n+\t  int workers = acc_worker ();\n+\t  workers_min = (workers_min < workers) ? workers_min : workers;\n+\t  workers_max = (workers_max > workers) ? workers_max : workers;\n+\t  int vectors = acc_vector ();\n+\t  vectors_min = (vectors_min < vectors) ? vectors_min : vectors;\n+\t  vectors_max = (vectors_max > vectors) ? vectors_max : vectors;\n+#endif\n+\t}\n+    }\n+    if (gangs_actual != 1)\n+      __builtin_abort ();\n+    if (gangs_min != 0 || gangs_max != gangs_actual - 1\n+\t|| workers_min != 0 || workers_max != 0\n+\t|| vectors_min != 0 || vectors_max != 0)\n+      __builtin_abort ();\n+#undef GANGS\n+  }\n+\n+  /* GP, WS, VS.  */\n+  {\n+#define GANGS 0 /* { dg-warning \"'num_gangs' value must be positive\" \"\" { target c } } */\n+    int gangs_actual = GANGS;\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc parallel copy (gangs_actual) \\\n+  num_gangs (GANGS) /* { dg-warning \"'num_gangs' value must be positive\" \"\" { target c++ } } */\n+    {\n+      /* We're actually executing with num_gangs (1).  */\n+      gangs_actual = 1;\n+#pragma acc loop gang reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      for (int i = 100 * gangs_actual; i > -100 * gangs_actual; --i)\n+\t{\n+\t  gangs_min = gangs_max = acc_gang ();\n+\t  workers_min = workers_max = acc_worker ();\n+\t  vectors_min = vectors_max = acc_vector ();\n+\t}\n+    }\n+    if (gangs_actual != 1)\n+      __builtin_abort ();\n+    if (gangs_min != 0 || gangs_max != gangs_actual - 1\n+\t|| workers_min != 0 || workers_max != 0\n+\t|| vectors_min != 0 || vectors_max != 0)\n+      __builtin_abort ();\n+#undef GANGS\n+  }\n+\n+  /* GR, WP, VS.  */\n+  {\n+#define WORKERS 0 /* { dg-warning \"'num_workers' value must be positive\" \"\" { target c } } */\n+    int workers_actual = WORKERS;\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc parallel copy (workers_actual) \\\n+  num_workers (WORKERS) /* { dg-warning \"'num_workers' value must be positive\" \"\" { target c++ } } */\n+    {\n+      /* We're actually executing with num_workers (1).  */\n+      workers_actual = 1;\n+#pragma acc loop worker reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      for (int i = 100 * workers_actual; i > -100 * workers_actual; --i)\n+\t{\n+\t  gangs_min = gangs_max = acc_gang ();\n+\t  workers_min = workers_max = acc_worker ();\n+\t  vectors_min = vectors_max = acc_vector ();\n+\t}\n+    }\n+    if (workers_actual != 1)\n+      __builtin_abort ();\n+    if (gangs_min != 0 || gangs_max != 0\n+\t|| workers_min != 0 || workers_max != workers_actual - 1\n+\t|| vectors_min != 0 || vectors_max != 0)\n+      __builtin_abort ();\n+#undef WORKERS\n+  }\n+\n+  /* GR, WS, VP.  */\n+  {\n+#define VECTORS 0 /* { dg-warning \"'vector_length' value must be positive\" \"\" { target c } } */\n+    int vectors_actual = VECTORS;\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc parallel copy (vectors_actual) /* { dg-warning \"using vector_length \\\\(32\\\\), ignoring 1\" \"\" { target openacc_nvidia_accel_configured } } */ \\\n+  vector_length (VECTORS) /* { dg-warning \"'vector_length' value must be positive\" \"\" { target c++ } } */\n+    {\n+      /* We're actually executing with vector_length (1), just the GCC nvptx\n+\t back end enforces vector_length (32).  */\n+      if (acc_on_device (acc_device_nvidia))\n+\tvectors_actual = 32;\n+      else\n+\tvectors_actual = 1;\n+#pragma acc loop vector reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      for (int i = 100 * vectors_actual; i > -100 * vectors_actual; --i)\n+\t{\n+\t  gangs_min = gangs_max = acc_gang ();\n+\t  workers_min = workers_max = acc_worker ();\n+\t  vectors_min = vectors_max = acc_vector ();\n+\t}\n+    }\n+    if (acc_get_device_type () == acc_device_nvidia)\n+      {\n+\tif (vectors_actual != 32)\n+\t  __builtin_abort ();\n+      }\n+    else\n+      if (vectors_actual != 1)\n+\t__builtin_abort ();\n+    if (gangs_min != 0 || gangs_max != 0\n+\t|| workers_min != 0 || workers_max != 0\n+\t|| vectors_min != 0 || vectors_max != vectors_actual - 1)\n+      __builtin_abort ();\n+#undef VECTORS\n+  }\n+\n \n-#pragma acc parallel num_workers (2<<20) /* { dg-error \"using num_workers\" } */\n+  /* High value.  */\n+  \n+  /* GR, WS, VS.  */\n   {\n-#pragma acc loop worker\n-    for (int  i = 0; i < 10; i++)\n-      dummy[i] = i;\n+    /* There is no actual limit for the number of gangs, so we try with a\n+       rather high value.  */\n+    int gangs = 12345;\n+    int gangs_actual = gangs;\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc parallel copy (gangs_actual) \\\n+  reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max) \\\n+  num_gangs (gangs)\n+    {\n+      if (acc_on_device (acc_device_host))\n+\t{\n+\t  /* We're actually executing with num_gangs (1).  */\n+\t  gangs_actual = 1;\n+\t}\n+      /* As we're executing GR not GP, don't multiply with a \"gangs_actual\"\n+\t factor.  */\n+      for (int i = 100 /* * gangs_actual */; i > -100 /* * gangs_actual */; --i)\n+\t{\n+\t  gangs_min = gangs_max = acc_gang ();\n+\t  workers_min = workers_max = acc_worker ();\n+\t  vectors_min = vectors_max = acc_vector ();\n+\t}\n+    }\n+    if (gangs_actual < 1)\n+      __builtin_abort ();\n+    if (gangs_min != 0 || gangs_max != gangs_actual - 1\n+\t|| workers_min != 0 || workers_max != 0\n+\t|| vectors_min != 0 || vectors_max != 0)\n+      __builtin_abort ();\n   }\n \n-#pragma acc parallel vector_length (2<<20) /* { dg-error \"using vector_length\" } */\n+  /* GP, WS, VS.  */\n   {\n-#pragma acc loop vector\n-    for (int  i = 0; i < 10; i++)\n-      dummy[i] = i;\n+    /* There is no actual limit for the number of gangs, so we try with a\n+       rather high value.  */\n+    int gangs = 12345;\n+    int gangs_actual = gangs;\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc parallel copy (gangs_actual) \\\n+  num_gangs (gangs)\n+    {\n+      if (acc_on_device (acc_device_host))\n+\t{\n+\t  /* We're actually executing with num_gangs (1).  */\n+\t  gangs_actual = 1;\n+\t}\n+#pragma acc loop gang reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      for (int i = 100 * gangs_actual; i > -100 * gangs_actual; --i)\n+\t{\n+\t  gangs_min = gangs_max = acc_gang ();\n+\t  workers_min = workers_max = acc_worker ();\n+\t  vectors_min = vectors_max = acc_vector ();\n+\t}\n+    }\n+    if (gangs_actual < 1)\n+      __builtin_abort ();\n+    if (gangs_min != 0 || gangs_max != gangs_actual - 1\n+\t|| workers_min != 0 || workers_max != 0\n+\t|| vectors_min != 0 || vectors_max != 0)\n+      __builtin_abort ();\n   }\n \n+  /* GR, WP, VS.  */\n+  {\n+    /* We try with an outrageously large value. */\n+#define WORKERS 2 << 20\n+    int workers_actual = WORKERS;\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc parallel copy (workers_actual) /* { dg-warning \"using num_workers \\\\(32\\\\), ignoring 2097152\" \"\" { target openacc_nvidia_accel_configured } } */ \\\n+  num_workers (WORKERS)\n+    {\n+      if (acc_on_device (acc_device_host))\n+\t{\n+\t  /* We're actually executing with num_workers (1).  */\n+\t  workers_actual = 1;\n+\t}\n+      else if (acc_on_device (acc_device_nvidia))\n+\t{\n+\t  /* The GCC nvptx back end enforces num_workers (32).  */\n+\t  workers_actual = 32;\n+\t}\n+      else\n+\t__builtin_abort ();\n+#pragma acc loop worker reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      for (int i = 100 * workers_actual; i > -100 * workers_actual; --i)\n+\t{\n+\t  gangs_min = gangs_max = acc_gang ();\n+\t  workers_min = workers_max = acc_worker ();\n+\t  vectors_min = vectors_max = acc_vector ();\n+\t}\n+    }\n+    if (workers_actual < 1)\n+      __builtin_abort ();\n+    if (gangs_min != 0 || gangs_max != 0\n+\t|| workers_min != 0 || workers_max != workers_actual - 1\n+\t|| vectors_min != 0 || vectors_max != 0)\n+      __builtin_abort ();\n+#undef WORKERS\n+  }\n+\n+  /* GR, WP, VS.  */\n+  {\n+    /* We try with an outrageously large value. */\n+    int workers = 2 << 20;\n+    /* For nvptx offloading, this one will not result in \"using num_workers\n+       (32), ignoring runtime setting\", and will in fact try to launch with\n+       \"num_workers (workers)\", which will run into \"libgomp: cuLaunchKernel\n+       error: invalid argument\".  So, limit ourselves here.  */\n+    if (acc_get_device_type () == acc_device_nvidia)\n+      workers = 32;\n+    int workers_actual = workers;\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc parallel copy (workers_actual) \\\n+  num_workers (workers)\n+    {\n+      if (acc_on_device (acc_device_host))\n+\t{\n+\t  /* We're actually executing with num_workers (1).  */\n+\t  workers_actual = 1;\n+\t}\n+      else if (acc_on_device (acc_device_nvidia))\n+\t{\n+\t  /* We're actually executing with num_workers (32).  */\n+\t  /* workers_actual = 32; */\n+\t}\n+      else\n+\t__builtin_abort ();\n+#pragma acc loop worker reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      for (int i = 100 * workers_actual; i > -100 * workers_actual; --i)\n+\t{\n+\t  gangs_min = gangs_max = acc_gang ();\n+\t  workers_min = workers_max = acc_worker ();\n+\t  vectors_min = vectors_max = acc_vector ();\n+\t}\n+    }\n+    if (workers_actual < 1)\n+      __builtin_abort ();\n+    if (gangs_min != 0 || gangs_max != 0\n+\t|| workers_min != 0 || workers_max != workers_actual - 1\n+\t|| vectors_min != 0 || vectors_max != 0)\n+      __builtin_abort ();\n+  }\n+\n+  /* GR, WS, VP.  */\n+  {\n+    /* We try with an outrageously large value. */\n+#define VECTORS 2 << 20\n+    int vectors_actual = VECTORS;\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc parallel copy (vectors_actual) /* { dg-warning \"using vector_length \\\\(32\\\\), ignoring 2097152\" \"\" { target openacc_nvidia_accel_configured } } */ \\\n+  vector_length (VECTORS)\n+    {\n+      if (acc_on_device (acc_device_host))\n+\t{\n+\t  /* We're actually executing with vector_length (1).  */\n+\t  vectors_actual = 1;\n+\t}\n+      else if (acc_on_device (acc_device_nvidia))\n+\t{\n+\t  /* The GCC nvptx back end enforces vector_length (32).  */\n+\t  vectors_actual = 32;\n+\t}\n+      else\n+\t__builtin_abort ();\n+#pragma acc loop vector reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      for (int i = 100 * vectors_actual; i > -100 * vectors_actual; --i)\n+\t{\n+\t  gangs_min = gangs_max = acc_gang ();\n+\t  workers_min = workers_max = acc_worker ();\n+\t  vectors_min = vectors_max = acc_vector ();\n+\t}\n+    }\n+    if (vectors_actual < 1)\n+      __builtin_abort ();\n+    if (gangs_min != 0 || gangs_max != 0\n+\t|| workers_min != 0 || workers_max != 0\n+\t|| vectors_min != 0 || vectors_max != vectors_actual - 1)\n+      __builtin_abort ();\n+#undef VECTORS\n+  }\n+\n+  /* GR, WS, VP.  */\n+  {\n+    /* We try with an outrageously large value. */\n+    int vectors = 2 << 20;\n+    int vectors_actual = vectors;\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc parallel copy (vectors_actual) /* { dg-warning \"using vector_length \\\\(32\\\\), ignoring runtime setting\" \"\" { target openacc_nvidia_accel_configured } } */ \\\n+  vector_length (vectors)\n+    {\n+      if (acc_on_device (acc_device_host))\n+\t{\n+\t  /* We're actually executing with vector_length (1).  */\n+\t  vectors_actual = 1;\n+\t}\n+      else if (acc_on_device (acc_device_nvidia))\n+\t{\n+\t  /* The GCC nvptx back end enforces vector_length (32).  */\n+\t  vectors_actual = 32;\n+\t}\n+      else\n+\t__builtin_abort ();\n+#pragma acc loop vector reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      for (int i = 100 * vectors_actual; i > -100 * vectors_actual; --i)\n+\t{\n+\t  gangs_min = gangs_max = acc_gang ();\n+\t  workers_min = workers_max = acc_worker ();\n+\t  vectors_min = vectors_max = acc_vector ();\n+\t}\n+    }\n+    if (vectors_actual < 1)\n+      __builtin_abort ();\n+    if (gangs_min != 0 || gangs_max != 0\n+\t|| workers_min != 0 || workers_max != 0\n+\t|| vectors_min != 0 || vectors_max != vectors_actual - 1)\n+      __builtin_abort ();\n+  }\n+\n+\n+  /* Composition of GP, WP, VP.  */\n+  {\n+    int gangs = 12345;\n+    /* With nvptx offloading, multi-level reductions apparently are very slow\n+       in the following case.  So, limit ourselves here.  */\n+    if (acc_get_device_type () == acc_device_nvidia)\n+      gangs = 3;\n+    int gangs_actual = gangs;\n+#define WORKERS 3\n+    int workers_actual = WORKERS;\n+#define VECTORS 11\n+    int vectors_actual = VECTORS;\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc parallel copy (gangs_actual, workers_actual, vectors_actual) /* { dg-warning \"using vector_length \\\\(32\\\\), ignoring 11\" \"\" { target openacc_nvidia_accel_configured } } */ \\\n+  num_gangs (gangs) \\\n+  num_workers (WORKERS) \\\n+  vector_length (VECTORS)\n+    {\n+      if (acc_on_device (acc_device_host))\n+\t{\n+\t  /* We're actually executing with num_gangs (1), num_workers (1),\n+\t     vector_length (1).  */\n+\t  gangs_actual = 1;\n+\t  workers_actual = 1;\n+\t  vectors_actual = 1;\n+\t}\n+      else if (acc_on_device (acc_device_nvidia))\n+\t{\n+\t  /* The GCC nvptx back end enforces vector_length (32).  */\n+\t  vectors_actual = 32;\n+\t}\n+      else\n+\t__builtin_abort ();\n+#pragma acc loop gang reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      for (int i = 100 * gangs_actual; i > -100 * gangs_actual; --i)\n+#pragma acc loop worker reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+\tfor (int j = 100 * workers_actual; j > -100 * workers_actual; --j)\n+#pragma acc loop vector reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+\t  for (int k = 100 * vectors_actual; k > -100 * vectors_actual; --k)\n+\t    {\n+\t      gangs_min = gangs_max = acc_gang ();\n+\t      workers_min = workers_max = acc_worker ();\n+\t      vectors_min = vectors_max = acc_vector ();\n+\t    }\n+    }\n+    if (gangs_min != 0 || gangs_max != gangs_actual - 1\n+\t|| workers_min != 0 || workers_max != workers_actual - 1\n+\t|| vectors_min != 0 || vectors_max != vectors_actual - 1)\n+      __builtin_abort ();\n+#undef VECTORS\n+#undef WORKERS\n+  }\n+\n+\n+  /* We can't test parallelized OpenACC kernels constructs in this way: use of\n+     the acc_gang, acc_worker, acc_vector functions will make the construct\n+     unparallelizable.  */\n+\n+\n+  /* Unparallelized OpenACC kernels constructs must get launched as 1 x 1 x 1\n+     kernels.  */\n+  {\n+    int gangs_min, gangs_max, workers_min, workers_max, vectors_min, vectors_max;\n+    gangs_min = workers_min = vectors_min = INT_MAX;\n+    gangs_max = workers_max = vectors_max = INT_MIN;\n+#pragma acc kernels\n+    {\n+      /* This is to make the OpenACC kernels construct unparallelizable.  */\n+      asm volatile (\"\" : : : \"memory\");\n+\n+#pragma acc loop reduction (min: gangs_min, workers_min, vectors_min) reduction (max: gangs_max, workers_max, vectors_max)\n+      for (int i = 100; i > -100; --i)\n+\t{\n+\t  gangs_min = gangs_max = acc_gang ();\n+\t  workers_min = workers_max = acc_worker ();\n+\t  vectors_min = vectors_max = acc_vector ();\n+\t}\n+    }\n+    if (gangs_min != 0 || gangs_max != 1 - 1\n+\t|| workers_min != 0 || workers_max != 1 - 1\n+\t|| vectors_min != 0 || vectors_max != 1 - 1)\n+      __builtin_abort ();\n+  }\n+\n+\n   return 0;\n }"}, {"sha": "4475bf5341fa3438ccd045aa4cfaf7341893416b", "filename": "libgomp/testsuite/libgomp.oacc-c/c.exp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c36d0d571999e1b9bdb3064e228cf23b3f895d1/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2Fc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c36d0d571999e1b9bdb3064e228cf23b3f895d1/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2Fc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2Fc.exp?ref=0c36d0d571999e1b9bdb3064e228cf23b3f895d1", "patch": "@@ -15,6 +15,13 @@ load_lib libgomp-dg.exp\n load_gcc_lib gcc-dg.exp\n load_gcc_lib torture-options.exp\n \n+proc check_effective_target_c { } {\n+    return 1\n+}\n+proc check_effective_target_c++ { } {\n+    return 0\n+}\n+\n # Initialize dg.\n dg-init\n torture-init"}]}