{"sha": "b7b184a86b471a0cdcdd69062cc2e5827bede7b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdiMTg0YTg2YjQ3MWEwY2RjZGQ2OTA2MmNjMmU1ODI3YmVkZTdiMg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-12-21T21:20:38Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-12-21T21:20:38Z"}, "message": "re PR fortran/34438 (gfortran not compliant w.r.t default initialization of derived type component and implicit SAVE attribute)\n\n2007-12-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34438\n\t* trans-decl.c (gfc_finish_var_decl): Do not mark derived types\n\twith default initializers as TREE_STATIC unless they are in the\n\tmain program scope.\n\t(gfc_get_symbol_decl): Pass derived types with a default\n\tinitializer to gfc_defer_symbol_init.\n\t(init_default_dt): Apply default initializer to a derived type.\n\t(init_intent_out_dt): Call init_default_dt.\n\t(gfc_trans_deferred_vars): Ditto.\n\n\t* module.c (read_module): Check sym->module is there before\n\tusing it in a string comparison.\n\n2007-12-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34438\n\t* gfortran.dg/default_initialization_3.f90: New test.\n\nFrom-SVN: r131124", "tree": {"sha": "122845e14ab1b5b0cedf84997593e4f37ed7cd37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/122845e14ab1b5b0cedf84997593e4f37ed7cd37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7b184a86b471a0cdcdd69062cc2e5827bede7b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7b184a86b471a0cdcdd69062cc2e5827bede7b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7b184a86b471a0cdcdd69062cc2e5827bede7b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7b184a86b471a0cdcdd69062cc2e5827bede7b2/comments", "author": null, "committer": null, "parents": [{"sha": "d7d20e1c12ee9a2df81a86552737a66d5d858c85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7d20e1c12ee9a2df81a86552737a66d5d858c85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7d20e1c12ee9a2df81a86552737a66d5d858c85"}], "stats": {"total": 214, "additions": 189, "deletions": 25}, "files": [{"sha": "f90a0778812188e43cbc5ddbd44733c49bec0123", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7b184a86b471a0cdcdd69062cc2e5827bede7b2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7b184a86b471a0cdcdd69062cc2e5827bede7b2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b7b184a86b471a0cdcdd69062cc2e5827bede7b2", "patch": "@@ -1,3 +1,18 @@\n+2007-12-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34438\n+\t* trans-decl.c (gfc_finish_var_decl): Do not mark derived types\n+\twith default initializers as TREE_STATIC unless they are in the\n+\tmain program scope.\n+\t(gfc_get_symbol_decl): Pass derived types with a default\n+\tinitializer to gfc_defer_symbol_init.\n+\t(init_default_dt): Apply default initializer to a derived type.\n+\t(init_intent_out_dt): Call init_default_dt.\n+\t(gfc_trans_deferred_vars): Ditto.\n+\n+\t* module.c (read_module): Check sym->module is there before\n+\tusing it in a string comparison.\n+\n 2007-12-20  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34482"}, {"sha": "f3c54b7d0a6145a6f692ee4685206c0789c531ca", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7b184a86b471a0cdcdd69062cc2e5827bede7b2/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7b184a86b471a0cdcdd69062cc2e5827bede7b2/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=b7b184a86b471a0cdcdd69062cc2e5827bede7b2", "patch": "@@ -3732,6 +3732,7 @@ read_module (void)\n \t      if (st && only_flag\n \t\t     && !st->n.sym->attr.use_only\n \t\t     && !st->n.sym->attr.use_rename\n+\t\t     && st->n.sym->module\n \t\t     && strcmp (st->n.sym->module, module_name) == 0)\n \t\tst->name = gfc_get_string (\"hidden.%s\", name);\n "}, {"sha": "f97870cf7c94324a8bfecba62ea3878882538135", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 60, "deletions": 25, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7b184a86b471a0cdcdd69062cc2e5827bede7b2/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7b184a86b471a0cdcdd69062cc2e5827bede7b2/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=b7b184a86b471a0cdcdd69062cc2e5827bede7b2", "patch": "@@ -517,8 +517,15 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n       TREE_STATIC (decl) = 1;\n     }\n \n-  if ((sym->attr.save || sym->attr.data || sym->value)\n-      && !sym->attr.use_assoc)\n+  /* Derived types are a bit peculiar because of the possibility of\n+     a default initializer; this must be applied each time the variable\n+     comes into scope it therefore need not be static.  These variables\n+     are SAVE_NONE but have an initializer.  Otherwise explicitly\n+     intitialized variables are SAVE_IMPLICIT and explicitly saved are\n+     SAVE_EXPLICIT.  */\n+  if (!sym->attr.use_assoc\n+\t&& (sym->attr.save != SAVE_NONE || sym->attr.data\n+\t      || (sym->value && sym->ns->proc_name->attr.is_main_program)))\n     TREE_STATIC (decl) = 1;\n \n   if (sym->attr.volatile_)\n@@ -995,6 +1002,14 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \n   if (sym->ts.type == BT_DERIVED && sym->ts.derived->attr.alloc_comp)\n     gfc_defer_symbol_init (sym);\n+  /* This applies a derived type default initializer.  */\n+  else if (sym->ts.type == BT_DERIVED\n+\t     && sym->attr.save == SAVE_NONE\n+\t     && !sym->attr.data\n+\t     && !sym->attr.allocatable\n+\t     && (sym->value && !sym->ns->proc_name->attr.is_main_program)\n+\t     && !sym->attr.use_assoc)\n+    gfc_defer_symbol_init (sym);\n \n   gfc_finish_var_decl (decl, sym);\n \n@@ -2572,43 +2587,53 @@ gfc_trans_vla_type_sizes (gfc_symbol *sym, stmtblock_t *body)\n }\n \n \n-/* Initialize INTENT(OUT) derived type dummies.  */\n+/* Initialize a derived type by building an lvalue from the symbol\n+   and using trans_assignment to do the work.  */\n static tree\n-init_intent_out_dt (gfc_symbol * proc_sym, tree body)\n+init_default_dt (gfc_symbol * sym, tree body)\n {\n   stmtblock_t fnblock;\n-  gfc_formal_arglist *f;\n-  gfc_expr *tmpe;\n+  gfc_expr *e;\n   tree tmp;\n   tree present;\n \n   gfc_init_block (&fnblock);\n-\n-  for (f = proc_sym->formal; f; f = f->next)\n+  gcc_assert (!sym->attr.allocatable);\n+  gfc_set_sym_referenced (sym);\n+  e = gfc_lval_expr_from_sym (sym);\n+  tmp = gfc_trans_assignment (e, sym->value, false);\n+  if (sym->attr.dummy)\n     {\n-      if (f->sym && f->sym->attr.intent == INTENT_OUT\n-\t    && f->sym->ts.type == BT_DERIVED\n-\t    && !f->sym->ts.derived->attr.alloc_comp\n-\t    && f->sym->value)\n-\t{\n-\t  gcc_assert (!f->sym->attr.allocatable);\n-\t  gfc_set_sym_referenced (f->sym);\n-\t  tmpe = gfc_lval_expr_from_sym (f->sym);\n-\t  tmp = gfc_trans_assignment (tmpe, f->sym->value, false);\n-\n-\t  present = gfc_conv_expr_present (f->sym);\n-\t  tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present,\n-\t\t\ttmp, build_empty_stmt ());\n-\t  gfc_add_expr_to_block (&fnblock, tmp);\n-\t  gfc_free_expr (tmpe);\n-\t}\n+      present = gfc_conv_expr_present (sym);\n+      tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present,\n+\t\t    tmp, build_empty_stmt ());\n     }\n-\n+  gfc_add_expr_to_block (&fnblock, tmp);\n+  gfc_free_expr (e);\n   gfc_add_expr_to_block (&fnblock, body);\n   return gfc_finish_block (&fnblock);\n }\n \n \n+/* Initialize INTENT(OUT) derived type dummies.  */\n+static tree\n+init_intent_out_dt (gfc_symbol * proc_sym, tree body)\n+{\n+  stmtblock_t fnblock;\n+  gfc_formal_arglist *f;\n+\n+  gfc_init_block (&fnblock);\n+  for (f = proc_sym->formal; f; f = f->next)\n+    if (f->sym && f->sym->attr.intent == INTENT_OUT\n+\t  && f->sym->ts.type == BT_DERIVED\n+\t  && !f->sym->ts.derived->attr.alloc_comp\n+\t  && f->sym->value)\n+      body = init_default_dt (f->sym, body);\n+\n+  gfc_add_expr_to_block (&fnblock, body);\n+  return gfc_finish_block (&fnblock);\n+}\n+\n \n /* Generate function entry and exit code, and add it to the function body.\n    This includes:\n@@ -2698,6 +2723,11 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t\t      seen_trans_deferred_array = true;\n \t\t      fnbody = gfc_trans_deferred_array (sym, fnbody);\n \t\t    }\n+\t\t  else if (sym->ts.type == BT_DERIVED\n+\t\t\t     && sym->value\n+\t\t\t     && !sym->attr.data\n+\t\t\t     && sym->attr.save == SAVE_NONE)\n+\t\t    fnbody = init_default_dt (sym, fnbody);\n \n \t\t  gfc_get_backend_locus (&loc);\n \t\t  gfc_set_backend_locus (&sym->declared_at);\n@@ -2753,6 +2783,11 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t  fnbody = gfc_trans_assign_aux_var (sym, fnbody);\n \t  gfc_set_backend_locus (&loc);\n \t}\n+      else if (sym->ts.type == BT_DERIVED\n+\t\t && sym->value\n+\t\t && !sym->attr.data\n+\t\t && sym->attr.save == SAVE_NONE)\n+\tfnbody = init_default_dt (sym, fnbody);\n       else\n \tgcc_unreachable ();\n     }"}, {"sha": "3e4d2db0c48aaff1ee7399fc3510ea5ff8af7b14", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7b184a86b471a0cdcdd69062cc2e5827bede7b2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7b184a86b471a0cdcdd69062cc2e5827bede7b2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b7b184a86b471a0cdcdd69062cc2e5827bede7b2", "patch": "@@ -1,3 +1,8 @@\n+2007-12-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34438\n+\t* gfortran.dg/default_initialization_3.f90: New test.\n+\n 2007-12-21  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* gcc.target/mips/mips.exp (setup_mips_tests): Fix _MIPS_SIM"}, {"sha": "43651985dcd347e0aae2dbef111fa0e5d75ab88f", "filename": "gcc/testsuite/gfortran.dg/default_initialization_3.f90", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7b184a86b471a0cdcdd69062cc2e5827bede7b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefault_initialization_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7b184a86b471a0cdcdd69062cc2e5827bede7b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefault_initialization_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdefault_initialization_3.f90?ref=b7b184a86b471a0cdcdd69062cc2e5827bede7b2", "patch": "@@ -0,0 +1,108 @@\n+! { dg-do run }\n+! Test the fix for PR34438, in which default initializers\n+! forced the derived type to be static; ie. initialized once\n+! during the lifetime of the programme.  Instead, they should\n+! be initialized each time they come into scope.\n+!\n+! Contributed by Sven Buijssen <sven.buijssen@math.uni-dortmund.de>\n+! Third test is from  Dominique Dhumieres <dominiq@lps.ens.fr>\n+!\n+module demo\n+   type myint\n+     integer :: bar = 42\n+   end type myint\n+end module demo\n+\n+! As the name implies, this was the original testcase\n+! provided by the contributor....\n+subroutine original\n+  use demo\n+  integer val1 (6)\n+  integer val2 (6)\n+  call recfunc (1)\n+  if (any (val1 .ne. (/1, 2, 3, 1, 2, 3/))) call abort ()\n+  if (any (val2 .ne. (/1, 2, 3, 4, 4, 4/))) call abort ()\n+contains\n+\n+  recursive subroutine recfunc (ivalue)\n+    integer, intent(in) :: ivalue\n+    type(myint) :: foo1\n+    type(myint) :: foo2 = myint (99)\n+    foo1%bar = ivalue\n+    foo2%bar = ivalue\n+    if (ivalue .le. 3) then\n+      val1(ivalue) = foo1%bar\n+      val2(ivalue) = foo2%bar\n+      call recfunc (ivalue + 1)\n+      val1(ivalue + 3) = foo1%bar\n+      val2(ivalue + 3) = foo2%bar\n+    endif\n+  end subroutine recfunc\n+end subroutine original\n+\n+! ...who came up with this one too.\n+subroutine func (ivalue, retval1, retval2)\n+  use demo\n+  integer, intent(in) :: ivalue\n+  type(myint) :: foo1\n+  type(myint) :: foo2 = myint (77)\n+  type(myint) :: retval1\n+  type(myint) :: retval2\n+  retval1 = foo1\n+  retval2 = foo2\n+  foo1%bar = 999\n+  foo2%bar = 999\n+end subroutine func\n+\n+subroutine other\n+  use demo\n+  interface\n+    subroutine func(ivalue, rv1, rv2)\n+      use demo\n+      integer, intent(in) :: ivalue\n+      type(myint) :: foo, rv1, rv2\n+   end subroutine func\n+  end interface\n+  type(myint) :: val1, val2\n+  call func (1, val1, val2)\n+  if ((val1%bar .ne. 42) .or. (val2%bar .ne. 77)) call abort ()\n+  call func (2, val1, val2)\n+  if ((val1%bar .ne. 42) .or. (val2%bar .ne. 999)) call abort ()\n+\n+end subroutine other\n+\n+MODULE M1\n+  TYPE T1\n+    INTEGER :: i=7\n+  END TYPE T1\n+CONTAINS\n+  FUNCTION F1(d1) RESULT(res)\n+    INTEGER :: res\n+    TYPE(T1), INTENT(OUT) :: d1\n+    TYPE(T1), INTENT(INOUT) :: d2\n+    res=d1%i\n+    d1%i=0\n+    RETURN\n+  ENTRY   E1(d2) RESULT(res)\n+    res=d2%i\n+    d2%i=0\n+  END FUNCTION F1\n+END MODULE M1\n+\n+! This tests the fix of a regression caused by the first version\n+! of the patch.\n+subroutine dominique ()\n+  USE M1\n+  TYPE(T1) :: D1\n+  D1=T1(3)\n+  if (F1(D1) .ne. 7) call abort ()\n+  D1=T1(3)\n+  if (E1(D1) .ne. 3) call abort ()\n+END\n+\n+! Run both tests.\n+  call original\n+  call other\n+  call dominique\n+end\n+! { dg-final { cleanup-modules \"demo M1\" } }"}]}