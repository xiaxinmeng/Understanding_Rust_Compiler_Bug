{"sha": "d26cef13fbe5a707e4a495c4a9d56847b9547072", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI2Y2VmMTNmYmU1YTcwN2U0YTQ5NWM0YTlkNTY4NDdiOTU0NzA3Mg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2006-09-05T17:41:22Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2006-09-05T17:41:22Z"}, "message": "re PR rtl-optimization/26847 (Missed optimization in simplify_plus_minus)\n\n2006-09-05  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR rtl-optimization/26847\n\t* simplify-rtx.c (struct simplify_plus_minus_op_data): Remove ix.\n\t(simplify_plus_minus_op_data_cmp): For REGs, break ties on the regno.\n\t(simplify_plus_minus): Count n_constants while filling ops.  Replace\n\tqsort with insertion sort.  Before going through the array to simplify\n\tpairs, sort it.  Delay early exit until after the first sort, exiting\n\tonly if no swaps occurred.  Simplify pairs in reversed order, without\n\tspecial-casing the first iteration.  Pack ops after simplifying pairs.\n\nFrom-SVN: r116701", "tree": {"sha": "7a5dd2d54bd36f40c450bd564a63865f0fcb60b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a5dd2d54bd36f40c450bd564a63865f0fcb60b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d26cef13fbe5a707e4a495c4a9d56847b9547072", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d26cef13fbe5a707e4a495c4a9d56847b9547072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d26cef13fbe5a707e4a495c4a9d56847b9547072", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d26cef13fbe5a707e4a495c4a9d56847b9547072/comments", "author": null, "committer": null, "parents": [{"sha": "5527be59f4f6621b8e99ecf13ed3a3126576b87f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5527be59f4f6621b8e99ecf13ed3a3126576b87f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5527be59f4f6621b8e99ecf13ed3a3126576b87f"}], "stats": {"total": 106, "additions": 58, "deletions": 48}, "files": [{"sha": "71eb20315b59167def0bfd5d41928a65d82849b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d26cef13fbe5a707e4a495c4a9d56847b9547072/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d26cef13fbe5a707e4a495c4a9d56847b9547072/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d26cef13fbe5a707e4a495c4a9d56847b9547072", "patch": "@@ -1,4 +1,15 @@\n-2006-09-02  Anatoly Sokolov <aesok@post.ru>\n+2006-09-05  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR rtl-optimization/26847\n+\t* simplify-rtx.c (struct simplify_plus_minus_op_data): Remove ix.\n+\t(simplify_plus_minus_op_data_cmp): For REGs, break ties on the regno.\n+\t(simplify_plus_minus): Count n_constants while filling ops.  Replace\n+\tqsort with insertion sort.  Before going through the array to simplify\n+\tpairs, sort it.  Delay early exit until after the first sort, exiting\n+\tonly if no swaps occurred.  Simplify pairs in reversed order, without\n+\tspecial-casing the first iteration.  Pack ops after simplifying pairs.\n+\n+2006-09-05  Anatoly Sokolov <aesok@post.ru>\n \n         * config/avr/avr.c (avr_mcu_types): Add support for at90pwm1 device.\n         * config/avr/t-avr (MULTILIB_MATCHES): (Ditto.)."}, {"sha": "3b12b20e682343713694bcf11fba554aa3df7834", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d26cef13fbe5a707e4a495c4a9d56847b9547072/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d26cef13fbe5a707e4a495c4a9d56847b9547072/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=d26cef13fbe5a707e4a495c4a9d56847b9547072", "patch": "@@ -3185,7 +3185,6 @@ struct simplify_plus_minus_op_data\n {\n   rtx op;\n   short neg;\n-  short ix;\n };\n \n static int\n@@ -3199,7 +3198,12 @@ simplify_plus_minus_op_data_cmp (const void *p1, const void *p2)\n \t    - commutative_operand_precedence (d1->op));\n   if (result)\n     return result;\n-  return d1->ix - d2->ix;\n+\n+  /* Group together equal REGs to do more simplification.  */\n+  if (REG_P (d1->op) && REG_P (d2->op))\n+    return REGNO (d1->op) - REGNO (d2->op);\n+  else\n+    return 0;\n }\n \n static rtx\n@@ -3209,7 +3213,7 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n   struct simplify_plus_minus_op_data ops[8];\n   rtx result, tem;\n   int n_ops = 2, input_ops = 2;\n-  int first, changed, canonicalized = 0;\n+  int changed, n_constants = 0, canonicalized = 0;\n   int i, j;\n \n   memset (ops, 0, sizeof ops);\n@@ -3286,6 +3290,7 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t      break;\n \n \t    case CONST_INT:\n+\t      n_constants++;\n \t      if (this_neg)\n \t\t{\n \t\t  ops[i].op = neg_const_int (mode, this_op);\n@@ -3302,18 +3307,10 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n     }\n   while (changed);\n \n-  gcc_assert (n_ops >= 2);\n-  if (!canonicalized)\n-    {\n-      int n_constants = 0;\n-\n-      for (i = 0; i < n_ops; i++)\n-\tif (GET_CODE (ops[i].op) == CONST_INT)\n-\t  n_constants++;\n+  if (n_constants > 1)\n+    canonicalized = 1;\n \n-      if (n_constants <= 1)\n-\treturn NULL_RTX;\n-    }\n+  gcc_assert (n_ops >= 2);\n \n   /* If we only have two operands, we can avoid the loops.  */\n   if (n_ops == 2)\n@@ -3342,22 +3339,37 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n       return simplify_const_binary_operation (code, mode, lhs, rhs);\n     }\n \n-  /* Now simplify each pair of operands until nothing changes.  The first\n-     time through just simplify constants against each other.  */\n-\n-  first = 1;\n+  /* Now simplify each pair of operands until nothing changes.  */\n   do\n     {\n-      changed = first;\n+      /* Insertion sort is good enough for an eight-element array.  */\n+      for (i = 1; i < n_ops; i++)\n+        {\n+          struct simplify_plus_minus_op_data save;\n+          j = i - 1;\n+          if (simplify_plus_minus_op_data_cmp (&ops[j], &ops[i]) < 0)\n+\t    continue;\n+\n+          canonicalized = 1;\n+          save = ops[i];\n+          do\n+\t    ops[j + 1] = ops[j];\n+          while (j-- && simplify_plus_minus_op_data_cmp (&ops[j], &save) > 0);\n+          ops[j + 1] = save;\n+        }\n \n-      for (i = 0; i < n_ops - 1; i++)\n-\tfor (j = i + 1; j < n_ops; j++)\n+      /* This is only useful the first time through.  */\n+      if (!canonicalized)\n+        return NULL_RTX;\n+\n+      changed = 0;\n+      for (i = n_ops - 1; i > 0; i--)\n+\tfor (j = i - 1; j >= 0; j--)\n \t  {\n-\t    rtx lhs = ops[i].op, rhs = ops[j].op;\n-\t    int lneg = ops[i].neg, rneg = ops[j].neg;\n+\t    rtx lhs = ops[j].op, rhs = ops[i].op;\n+\t    int lneg = ops[j].neg, rneg = ops[i].neg;\n \n-\t    if (lhs != 0 && rhs != 0\n-\t\t&& (! first || (CONSTANT_P (lhs) && CONSTANT_P (rhs))))\n+\t    if (lhs != 0 && rhs != 0)\n \t      {\n \t\tenum rtx_code ncode = PLUS;\n \n@@ -3393,13 +3405,7 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t\t    && ! (GET_CODE (tem) == CONST\n \t\t\t  && GET_CODE (XEXP (tem, 0)) == ncode\n \t\t\t  && XEXP (XEXP (tem, 0), 0) == lhs\n-\t\t\t  && XEXP (XEXP (tem, 0), 1) == rhs)\n-\t\t    /* Don't allow -x + -1 -> ~x simplifications in the\n-\t\t       first pass.  This allows us the chance to combine\n-\t\t       the -1 with other constants.  */\n-\t\t    && ! (first\n-\t\t\t  && GET_CODE (tem) == NOT\n-\t\t\t  && XEXP (tem, 0) == rhs))\n+\t\t\t  && XEXP (XEXP (tem, 0), 1) == rhs))\n \t\t  {\n \t\t    lneg &= rneg;\n \t\t    if (GET_CODE (tem) == NEG)\n@@ -3415,24 +3421,17 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t      }\n \t  }\n \n-      first = 0;\n+      /* Pack all the operands to the lower-numbered entries.  */\n+      for (i = 0, j = 0; j < n_ops; j++)\n+        if (ops[j].op)\n+          {\n+\t    ops[i] = ops[j];\n+\t    i++;\n+          }\n+      n_ops = i;\n     }\n   while (changed);\n \n-  /* Pack all the operands to the lower-numbered entries.  */\n-  for (i = 0, j = 0; j < n_ops; j++)\n-    if (ops[j].op)\n-      {\n-\tops[i] = ops[j];\n-\t/* Stabilize sort.  */\n-\tops[i].ix = i;\n-\ti++;\n-      }\n-  n_ops = i;\n-\n-  /* Sort the operations based on swap_commutative_operands_p.  */\n-  qsort (ops, n_ops, sizeof (*ops), simplify_plus_minus_op_data_cmp);\n-\n   /* Create (minus -C X) instead of (neg (const (plus X C))).  */\n   if (n_ops == 2\n       && GET_CODE (ops[1].op) == CONST_INT"}]}