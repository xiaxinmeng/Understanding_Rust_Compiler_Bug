{"sha": "92e63bd2dfefb2d27bc235523bec6740bba512c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJlNjNiZDJkZmVmYjJkMjdiYzIzNTUyM2JlYzY3NDBiYmE1MTJjMg==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2019-11-01T07:59:23Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2019-11-01T07:59:23Z"}, "message": "OpenMP] use_device_addr/use_device_ptr with Fortran allocatable/pointer arrays\n\n        gcc/fortran/\n        * f95-lang.c (LANG_HOOKS_OMP_ARRAY_DATA): Set to gfc_omp_array_data.\n        * trans-array.c (gfc_conv_descriptor_data_get): Handle also\n        REFERENCE_TYPE.\n        * trans-openmp.c (gfc_omp_array_data): New.\n        * trans.h (gfc_omp_array_data): New prototype.\n\n        gcc/\n        * hooks.c (hook_tree_tree_bool_null): New.\n        * hooks.h (hook_tree_tree_bool_null): Declare.\n        * langhooks-def.h (LANG_HOOKS_OMP_ARRAY_DATA): Define.\n        (LANG_HOOKS_DECLS): Add it.\n        * langhooks.h (lang_hooks_for_decls): Add omp_array_data.\n        * omp-low.c (install_var_field): New mode for Fortran descriptor arrays.\n        (lower_omp_target): Handle Fortran array with descriptor in\n        OMP_CLAUSE_USE_DEVICE_ADDR/OMP_CLAUSE_USE_DEVICE_PTR.\n\n        libgomp/\n        * testsuite/libgomp.fortran/use_device_addr-1.f90 (test_nullptr_1,\n        test_dummy_opt_nullptr_callee_1): Add present but unallocated test.\n        * testsuite/libgomp.fortran/use_device_addr-2.f90: Likewise.\n        * testsuite/libgomp.fortran/use_device_addr-3.f90: New.\n        * testsuite/libgomp.fortran/use_device_addr-4.f90: New.\n        * testsuite/testsuite/libgomp.fortran/use_device_ptr-1.f90: New.\n\nFrom-SVN: r277705", "tree": {"sha": "67d9cd0a57317909a139256fdb8379003b5f67b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67d9cd0a57317909a139256fdb8379003b5f67b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92e63bd2dfefb2d27bc235523bec6740bba512c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92e63bd2dfefb2d27bc235523bec6740bba512c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92e63bd2dfefb2d27bc235523bec6740bba512c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92e63bd2dfefb2d27bc235523bec6740bba512c2/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "271da732841345d3834cf458d47f8242ac5ef513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271da732841345d3834cf458d47f8242ac5ef513", "html_url": "https://github.com/Rust-GCC/gccrs/commit/271da732841345d3834cf458d47f8242ac5ef513"}], "stats": {"total": 2379, "additions": 2354, "deletions": 25}, "files": [{"sha": "08d3ba0232c050263a057d18684610ec95a52cd4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -1,3 +1,14 @@\n+2019-11-01  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* hooks.c (hook_tree_tree_bool_null): New.\n+\t* hooks.h (hook_tree_tree_bool_null): Declare.\n+\t* langhooks-def.h (LANG_HOOKS_OMP_ARRAY_DATA): Define.\n+\t(LANG_HOOKS_DECLS): Add it.\n+\t* langhooks.h (lang_hooks_for_decls): Add omp_array_data.\n+\t* omp-low.c (install_var_field): New mode for Fortran descriptor arrays.\n+\t(lower_omp_target): Handle Fortran array with descriptor in\n+\tOMP_CLAUSE_USE_DEVICE_ADDR/OMP_CLAUSE_USE_DEVICE_PTR.\n+\n 2019-10-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64-sve-builtins.cc (register_builtin_types):"}, {"sha": "be8ae58f685794f99785225098141dbba0032c99", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -1,3 +1,11 @@\n+2019-11-01  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* f95-lang.c (LANG_HOOKS_OMP_ARRAY_DATA): Set to gfc_omp_array_data.\n+\t* trans-array.c (gfc_conv_descriptor_data_get): Handle also\n+\tREFERENCE_TYPE.\n+\t* trans-openmp.c (gfc_omp_array_data): New.\n+\t* trans.h (gfc_omp_array_data): New prototype.\n+\n 2019-10-31  Tobias Burnus  <tobias@codesourcery.com>\n \n \tPR fortran/92284."}, {"sha": "0684c3b99cf081cc50b1c025a632022c93f5eda0", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -113,6 +113,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #undef LANG_HOOKS_TYPE_FOR_MODE\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n #undef LANG_HOOKS_INIT_TS\n+#undef LANG_HOOKS_OMP_ARRAY_DATA\n #undef LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR\n #undef LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT\n #undef LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\n@@ -147,6 +148,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #define LANG_HOOKS_TYPE_FOR_MODE\tgfc_type_for_mode\n #define LANG_HOOKS_TYPE_FOR_SIZE\tgfc_type_for_size\n #define LANG_HOOKS_INIT_TS\t\tgfc_init_ts\n+#define LANG_HOOKS_OMP_ARRAY_DATA\t\tgfc_omp_array_data\n #define LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR\tgfc_omp_is_allocatable_or_ptr\n #define LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT\tgfc_omp_is_optional_argument\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\tgfc_omp_privatize_by_reference"}, {"sha": "685f8c5a874a180f87e168508016979e5ae2fb0b", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -142,6 +142,9 @@ gfc_conv_descriptor_data_get (tree desc)\n   tree field, type, t;\n \n   type = TREE_TYPE (desc);\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n \n   field = TYPE_FIELDS (type);"}, {"sha": "14a3c3e4284373c724287284e4024b8ca7414e92", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -71,6 +71,33 @@ gfc_omp_is_optional_argument (const_tree decl)\n \t  && GFC_DECL_OPTIONAL_ARGUMENT (decl));\n }\n \n+\n+/* Returns tree with NULL if it is not an array descriptor and with the tree to\n+   access the 'data' component otherwise.  With type_only = true, it returns the\n+   TREE_TYPE without creating a new tree.  */\n+\n+tree\n+gfc_omp_array_data (tree decl, bool type_only)\n+{\n+  tree type = TREE_TYPE (decl);\n+\n+  if (POINTER_TYPE_P (type))\n+    type = TREE_TYPE (type);\n+\n+  if (!GFC_DESCRIPTOR_TYPE_P (type))\n+    return NULL_TREE;\n+\n+  if (type_only)\n+    return GFC_TYPE_ARRAY_DATAPTR_TYPE (type);\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+    decl = build_fold_indirect_ref (decl);\n+\n+  decl = gfc_conv_descriptor_data_get (decl);\n+  STRIP_NOPS (decl);\n+  return decl;\n+}\n+\n /* True if OpenMP should privatize what this DECL points to rather\n    than the DECL itself.  */\n "}, {"sha": "364efe51d7cbcc9474fba0f57e417926a8a077c9", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -788,6 +788,7 @@ bool gfc_get_array_descr_info (const_tree, struct array_descr_info *);\n /* In trans-openmp.c */\n bool gfc_omp_is_allocatable_or_ptr (const_tree);\n bool gfc_omp_is_optional_argument (const_tree);\n+tree gfc_omp_array_data (tree, bool);\n bool gfc_omp_privatize_by_reference (const_tree);\n enum omp_clause_default_kind gfc_omp_predetermined_sharing (tree);\n tree gfc_omp_report_decl (tree);"}, {"sha": "8e4578d624d889ce7cfdd47da6361c871f9de207", "filename": "gcc/hooks.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -429,6 +429,12 @@ hook_tree_tree_int_treep_bool_null (tree, int, tree *, bool)\n   return NULL;\n }\n \n+tree\n+hook_tree_tree_bool_null (tree, bool)\n+{\n+  return NULL;\n+}\n+\n tree\n hook_tree_tree_tree_null (tree, tree)\n {"}, {"sha": "d5269536357f226615b63e47e27eddb7b0062fc8", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -106,6 +106,7 @@ extern HOST_WIDE_INT hook_hwi_void_0 (void);\n extern tree hook_tree_const_tree_null (const_tree);\n extern tree hook_tree_void_null (void);\n \n+extern tree hook_tree_tree_bool_null (tree, bool);\n extern tree hook_tree_tree_tree_null (tree, tree);\n extern tree hook_tree_tree_tree_tree_null (tree, tree, tree);\n extern tree hook_tree_tree_int_treep_bool_null (tree, int, tree *, bool);"}, {"sha": "2d3ad9a0a76f7fe914f488b7934ad50f48c7263e", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -239,6 +239,7 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n #define LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL lhd_warn_unused_global_decl\n #define LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS NULL\n #define LANG_HOOKS_DECL_OK_FOR_SIBCALL\tlhd_decl_ok_for_sibcall\n+#define LANG_HOOKS_OMP_ARRAY_DATA\thook_tree_tree_bool_null\n #define LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR hook_bool_const_tree_false\n #define LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT hook_bool_const_tree_false\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE hook_bool_const_tree_false\n@@ -266,6 +267,7 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n   LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL, \\\n   LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS, \\\n   LANG_HOOKS_DECL_OK_FOR_SIBCALL, \\\n+  LANG_HOOKS_OMP_ARRAY_DATA, \\\n   LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR, \\\n   LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT, \\\n   LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE, \\"}, {"sha": "39d3608b5f8c8fc3a7c56f9533a209f80917102d", "filename": "gcc/langhooks.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -226,6 +226,11 @@ struct lang_hooks_for_decls\n   /* True if this decl may be called via a sibcall.  */\n   bool (*ok_for_sibcall) (const_tree);\n \n+  /* Return a tree for the actual data of an array descriptor - or NULL_TREE\n+     if original tree is not an array descriptor.  If the the second argument\n+     is true, only the TREE_TYPE is returned without generating a new tree.  */\n+  tree (*omp_array_data) (tree, bool);\n+\n   /* True if OpenMP should regard this DECL as being a scalar which has Fortran's\n      allocatable or pointer attribute.  */\n   bool (*omp_is_allocatable_or_ptr) (const_tree);"}, {"sha": "cd7da6da0ef10cc9c2774b925c9c2705e7d12abb", "filename": "gcc/omp-low.c", "status": "modified", "additions": 74, "deletions": 13, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -715,6 +715,11 @@ install_var_field (tree var, bool by_ref, int mask, omp_context *ctx)\n   tree field, type, sfield = NULL_TREE;\n   splay_tree_key key = (splay_tree_key) var;\n \n+  if ((mask & 16) != 0)\n+    {\n+      key = (splay_tree_key) &DECL_NAME (var);\n+      gcc_checking_assert (key != (splay_tree_key) var);\n+    }\n   if ((mask & 8) != 0)\n     {\n       key = (splay_tree_key) &DECL_UID (var);\n@@ -728,6 +733,9 @@ install_var_field (tree var, bool by_ref, int mask, omp_context *ctx)\n \t      || !is_gimple_omp_oacc (ctx->stmt));\n \n   type = TREE_TYPE (var);\n+  if ((mask & 16) != 0)\n+    type = lang_hooks.decls.omp_array_data (var, true);\n+\n   /* Prevent redeclaring the var in the split-off function with a restrict\n      pointer type.  Note that we only clear type itself, restrict qualifiers in\n      the pointed-to type will be ignored by points-to analysis.  */\n@@ -752,7 +760,7 @@ install_var_field (tree var, bool by_ref, int mask, omp_context *ctx)\n      side effect of making dwarf2out ignore this member, so for helpful\n      debugging we clear it later in delete_omp_context.  */\n   DECL_ABSTRACT_ORIGIN (field) = var;\n-  if (type == TREE_TYPE (var))\n+  if ((mask & 16) == 0 && type == TREE_TYPE (var))\n     {\n       SET_DECL_ALIGN (field, DECL_ALIGN (var));\n       DECL_USER_ALIGN (field) = DECL_USER_ALIGN (var);\n@@ -1240,10 +1248,14 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_USE_DEVICE_ADDR:\n \t  decl = OMP_CLAUSE_DECL (c);\n-\t  if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n-\t       && !omp_is_reference (decl)\n-\t       && !omp_is_allocatable_or_ptr (decl))\n-\t      || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+\n+\t  /* Fortran array descriptors.  */\n+\t  if (lang_hooks.decls.omp_array_data (decl, true))\n+\t    install_var_field (decl, false, 19, ctx);\n+\t  else if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n+\t\t    && !omp_is_reference (decl)\n+\t\t    && !omp_is_allocatable_or_ptr (decl))\n+\t\t   || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t    install_var_field (decl, true, 11, ctx);\n \t  else\n \t    install_var_field (decl, false, 11, ctx);\n@@ -11485,7 +11497,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  }\n \telse if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n \t\t  && !omp_is_reference (var)\n-\t\t  && !omp_is_allocatable_or_ptr (var))\n+\t\t  && !omp_is_allocatable_or_ptr (var)\n+\t\t  && !lang_hooks.decls.omp_array_data (var, true))\n \t\t || TREE_CODE (TREE_TYPE (var)) == ARRAY_TYPE)\n \t  {\n \t    tree new_var = lookup_decl (var, ctx);\n@@ -11866,7 +11879,14 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  case OMP_CLAUSE_IS_DEVICE_PTR:\n \t    ovar = OMP_CLAUSE_DECL (c);\n \t    var = lookup_decl_in_outer_ctx (ovar, ctx);\n-\t    if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR)\n+\n+\t    if (lang_hooks.decls.omp_array_data (ovar, true))\n+\t      {\n+\t\ttkind = (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR\n+\t\t\t ? GOMP_MAP_USE_DEVICE_PTR : GOMP_MAP_FIRSTPRIVATE_INT);\n+\t\tx = build_sender_ref ((splay_tree_key) &DECL_NAME (ovar), ctx);\n+\t      }\n+\t    else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR)\n \t      {\n \t\ttkind = GOMP_MAP_USE_DEVICE_PTR;\n \t\tx = build_sender_ref ((splay_tree_key) &DECL_UID (ovar), ctx);\n@@ -11877,10 +11897,12 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\tx = build_sender_ref (ovar, ctx);\n \t      }\n \t    type = TREE_TYPE (ovar);\n-\t    if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n-\t\t && !omp_is_reference (ovar)\n-\t\t && !omp_is_allocatable_or_ptr (ovar))\n-\t\t|| TREE_CODE (type) == ARRAY_TYPE)\n+\t    if (lang_hooks.decls.omp_array_data (ovar, true))\n+\t      var = lang_hooks.decls.omp_array_data (ovar, false);\n+\t    else if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n+\t\t      && !omp_is_reference (ovar)\n+\t\t      && !omp_is_allocatable_or_ptr (ovar))\n+\t\t     || TREE_CODE (type) == ARRAY_TYPE)\n \t      var = build_fold_addr_expr (var);\n \t    else\n \t      {\n@@ -12048,11 +12070,50 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  case OMP_CLAUSE_USE_DEVICE_ADDR:\n \t  case OMP_CLAUSE_IS_DEVICE_PTR:\n \t    var = OMP_CLAUSE_DECL (c);\n+\t    bool is_array_data;\n+\t    is_array_data = lang_hooks.decls.omp_array_data (var, true) != NULL;\n+\n \t    if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR)\n-\t      x = build_sender_ref ((splay_tree_key) &DECL_UID (var), ctx);\n+\t      x = build_sender_ref (is_array_data\n+\t\t\t\t    ? (splay_tree_key) &DECL_NAME (var)\n+\t\t\t\t    : (splay_tree_key) &DECL_UID (var), ctx);\n \t    else\n \t      x = build_receiver_ref (var, false, ctx);\n-\t    if (is_variable_sized (var))\n+\n+\t    if (is_array_data)\n+\t      {\n+\t\tbool is_ref = omp_is_reference (var);\n+\t\t/* First, we copy the descriptor data from the host; then\n+\t\t   we update its data to point to the target address.  */\n+\t\ttree new_var = lookup_decl (var, ctx);\n+\t\tnew_var = DECL_VALUE_EXPR (new_var);\n+\t\ttree v = new_var;\n+\n+\t\tif (is_ref)\n+\t\t  {\n+\t\t    var = build_fold_indirect_ref (var);\n+\t\t    gimplify_expr (&var, &new_body, NULL, is_gimple_val,\n+\t\t\t\t   fb_rvalue);\n+\t\t    v = create_tmp_var_raw (TREE_TYPE (var), get_name (var));\n+\t\t    gimple_add_tmp_var (v);\n+\t\t    TREE_ADDRESSABLE (v) = 1;\n+\t\t    gimple_seq_add_stmt (&new_body,\n+\t\t\t\t\t gimple_build_assign (v, var));\n+\t\t    tree rhs = build_fold_addr_expr (v);\n+\t\t    gimple_seq_add_stmt (&new_body,\n+\t\t\t\t\t gimple_build_assign (new_var, rhs));\n+\t\t  }\n+\t\telse\n+\t\t  gimple_seq_add_stmt (&new_body,\n+\t\t\t\t       gimple_build_assign (new_var, var));\n+\n+\t\ttree v2 = lang_hooks.decls.omp_array_data (unshare_expr (v), false);\n+\t\tgcc_assert (v2);\n+\t\tgimplify_expr (&x, &new_body, NULL, is_gimple_val, fb_rvalue);\n+\t\tgimple_seq_add_stmt (&new_body,\n+\t\t\t\t     gimple_build_assign (v2, x));\n+\t      }\n+\t    else if (is_variable_sized (var))\n \t      {\n \t\ttree pvar = DECL_VALUE_EXPR (var);\n \t\tgcc_assert (TREE_CODE (pvar) == INDIRECT_REF);"}, {"sha": "8cf7d95859633e448cceb2e991a5b61ab24ddaab", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -1,3 +1,12 @@\n+2019-11-01  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* testsuite/libgomp.fortran/use_device_addr-1.f90 (test_nullptr_1,\n+\ttest_dummy_opt_nullptr_callee_1): Add present but unallocated test.\n+\t* testsuite/libgomp.fortran/use_device_addr-2.f90: Likewise.\n+\t* testsuite/libgomp.fortran/use_device_addr-3.f90: New.\n+\t* testsuite/libgomp.fortran/use_device_addr-4.f90: New.\n+\t* testsuite/testsuite/libgomp.fortran/use_device_ptr-1.f90: New.\n+\n 2019-10-30  Tobias Burnus  <tobias@codesourcery.com>\n \n \t* testsuite/libgomp.fortran/target9.f90: New."}, {"sha": "1183e49f2e4abffdd37d660c9e7b7ec417fce560", "filename": "libgomp/testsuite/libgomp.fortran/use_device_addr-1.f90", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-1.f90?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -884,8 +884,10 @@ subroutine test_nullptr_1()\n      real(c_double), pointer :: aa, bb\n      real(c_double), pointer :: ee, ff\n \n-     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr\n-     real(c_double), pointer :: aptr, bptr, eptr, fptr\n+     real(c_double), allocatable, target :: gg, hh\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_double), pointer :: aptr, bptr, eptr, fptr, gptr, hptr\n \n      aa => null()\n      bb => null()\n@@ -905,15 +907,29 @@ subroutine test_nullptr_1()\n      if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 1\n      if (associated(aptr) .or. associated(bptr, bb)) stop 1\n \n-     call test_dummy_opt_nullptr_callee_1(ee, ff, c_eptr, c_fptr, eptr, fptr)\n+     if (allocated(gg)) stop 1\n+     !$omp target data map(tofrom:gg) use_device_addr(gg)\n+     if (c_associated(c_loc(gg))) stop 1\n+     c_gptr = c_loc(gg)\n+     gptr => gg\n+     if (c_associated(c_gptr)) stop 1\n+     if (associated(gptr)) stop 1\n+     if (allocated(gg)) stop 1\n+     !$omp end target data\n+     if (c_associated(c_gptr)) stop 1\n+     if (associated(gptr)) stop 1\n+     if (allocated(gg)) stop 1\n+\n+     call test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)\n   end subroutine test_nullptr_1\n \n-  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, c_eptr, c_fptr, eptr, fptr)\n+  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)\n      ! scalars\n      real(c_double), optional, pointer :: ee, ff\n+     real(c_double), optional, allocatable, target :: hh\n \n-     type(c_ptr), optional :: c_eptr, c_fptr\n-     real(c_double), optional, pointer :: eptr, fptr\n+     type(c_ptr), optional :: c_eptr, c_fptr, c_hptr\n+     real(c_double), optional, pointer :: eptr, fptr, hptr\n \n      if (.not.present(ee) .or. .not.present(ff)) stop 1\n      if (associated(ee) .or. associated(ff)) stop 1\n@@ -932,6 +948,26 @@ subroutine test_dummy_opt_nullptr_callee_1(ee, ff, c_eptr, c_fptr, eptr, fptr)\n \n      if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 1\n      if (associated(eptr) .or. associated(fptr)) stop 1\n+     if (associated(ee) .or. associated(ff)) stop 1\n+\n+\n+     if (.not.present(hh)) stop 1\n+     if (allocated(hh)) stop 1\n+\n+     !$omp target data map(tofrom:hh) use_device_addr(hh)\n+     if (.not.present(hh)) stop 1\n+     if (allocated(hh)) stop 1\n+     if (c_associated(c_loc(hh))) stop 1\n+     c_hptr = c_loc(hh)\n+     hptr => hh\n+     if (c_associated(c_hptr)) stop 1\n+     if (associated(hptr)) stop 1\n+     if (allocated(hh)) stop 1\n+     !$omp end target data\n+\n+     if (c_associated(c_hptr)) stop 1\n+     if (associated(hptr)) stop 1\n+     if (allocated(hh)) stop 1\n   end subroutine test_dummy_opt_nullptr_callee_1\n end module test_nullptr\n "}, {"sha": "717689fed1dc0db00461bff5e86f5d792e1046a0", "filename": "libgomp/testsuite/libgomp.fortran/use_device_addr-2.f90", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-2.f90?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -884,8 +884,10 @@ subroutine test_nullptr_1()\n      real(c_float), pointer :: aa, bb\n      real(c_float), pointer :: ee, ff\n \n-     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr\n-     real(c_float), pointer :: aptr, bptr, eptr, fptr\n+     real(c_float), allocatable, target :: gg, hh\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_float), pointer :: aptr, bptr, eptr, fptr, gptr, hptr\n \n      aa => null()\n      bb => null()\n@@ -905,15 +907,29 @@ subroutine test_nullptr_1()\n      if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 1\n      if (associated(aptr) .or. associated(bptr, bb)) stop 1\n \n-     call test_dummy_opt_nullptr_callee_1(ee, ff, c_eptr, c_fptr, eptr, fptr)\n+     if (allocated(gg)) stop 1\n+     !$omp target data map(tofrom:gg) use_device_addr(gg)\n+     if (c_associated(c_loc(gg))) stop 1\n+     c_gptr = c_loc(gg)\n+     gptr => gg\n+     if (c_associated(c_gptr)) stop 1\n+     if (associated(gptr)) stop 1\n+     if (allocated(gg)) stop 1\n+     !$omp end target data\n+     if (c_associated(c_gptr)) stop 1\n+     if (associated(gptr)) stop 1\n+     if (allocated(gg)) stop 1\n+\n+     call test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)\n   end subroutine test_nullptr_1\n \n-  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, c_eptr, c_fptr, eptr, fptr)\n+  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)\n      ! scalars\n      real(c_float), optional, pointer :: ee, ff\n+     real(c_float), optional, allocatable, target :: hh\n \n-     type(c_ptr), optional :: c_eptr, c_fptr\n-     real(c_float), optional, pointer :: eptr, fptr\n+     type(c_ptr), optional :: c_eptr, c_fptr, c_hptr\n+     real(c_float), optional, pointer :: eptr, fptr, hptr\n \n      if (.not.present(ee) .or. .not.present(ff)) stop 1\n      if (associated(ee) .or. associated(ff)) stop 1\n@@ -932,6 +948,26 @@ subroutine test_dummy_opt_nullptr_callee_1(ee, ff, c_eptr, c_fptr, eptr, fptr)\n \n      if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 1\n      if (associated(eptr) .or. associated(fptr)) stop 1\n+     if (associated(ee) .or. associated(ff)) stop 1\n+\n+\n+     if (.not.present(hh)) stop 1\n+     if (allocated(hh)) stop 1\n+\n+     !$omp target data map(tofrom:hh) use_device_addr(hh)\n+     if (.not.present(hh)) stop 1\n+     if (allocated(hh)) stop 1\n+     if (c_associated(c_loc(hh))) stop 1\n+     c_hptr = c_loc(hh)\n+     hptr => hh\n+     if (c_associated(c_hptr)) stop 1\n+     if (associated(hptr)) stop 1\n+     if (allocated(hh)) stop 1\n+     !$omp end target data\n+\n+     if (c_associated(c_hptr)) stop 1\n+     if (associated(hptr)) stop 1\n+     if (allocated(hh)) stop 1\n   end subroutine test_dummy_opt_nullptr_callee_1\n end module test_nullptr\n "}, {"sha": "6d794d74cb3e1cfd729e77d3f573d4a61329c1ab", "filename": "libgomp/testsuite/libgomp.fortran/use_device_addr-3.f90", "status": "added", "additions": 763, "deletions": 0, "changes": 763, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-3.f90?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -0,0 +1,763 @@\n+! Comprehensive run-time test for use_device_addr\n+!\n+! Tests array with array descriptor\n+!\n+! Differs from use_device_addr-4.f90 by using a 8-byte variable (c_double)\n+!\n+! This test case assumes that a 'var' appearing in 'use_device_addr' is\n+! only used as 'c_loc(var)' - such that only the actual data is used/usable\n+! on the device - and not meta data ((dynamic) type information, 'present()'\n+! status, array shape).\n+!\n+! Untested in this test case are:\n+! - scalars\n+! - polymorphic variables\n+! - absent optional arguments\n+!\n+module target_procs\n+  use iso_c_binding\n+  implicit none (type, external)\n+  private\n+  public :: copy3_array\n+contains\n+  subroutine copy3_array_int(from_ptr, to_ptr, N)\n+    !$omp declare target\n+    real(c_double) :: from_ptr(:)\n+    real(c_double) :: to_ptr(:)\n+    integer, value :: N\n+    integer :: i\n+\n+    !$omp parallel do\n+    do i = 1, N\n+      to_ptr(i) = 3 * from_ptr(i)\n+    end do\n+    !$omp end parallel do\n+  end subroutine copy3_array_int\n+\n+  subroutine copy3_array(from, to, N)\n+    type(c_ptr), value :: from, to\n+    integer, value :: N\n+    real(c_double), pointer :: from_ptr(:), to_ptr(:)\n+\n+    call c_f_pointer(from, from_ptr, shape=[N])\n+    call c_f_pointer(to, to_ptr, shape=[N])\n+\n+    call do_offload_scalar(from_ptr,to_ptr)\n+  contains\n+    subroutine do_offload_scalar(from_r, to_r)\n+      real(c_double), target :: from_r(:), to_r(:)\n+      ! The extra function is needed as is_device_ptr\n+      ! requires non-value, non-pointer dummy arguments\n+\n+      !$omp target is_device_ptr(from_r, to_r)\n+      call copy3_array_int(from_r, to_r, N)\n+      !$omp end target\n+    end subroutine do_offload_scalar\n+  end subroutine copy3_array\n+end module target_procs\n+\n+\n+\n+! Test local dummy arguments (w/o optional)\n+module test_dummies\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_call_1, test_dummy_call_2\n+contains\n+  subroutine test_dummy_call_1()\n+     integer, parameter :: N = 1000\n+\n+     real(c_double), target :: aa(N), bb(N)\n+     real(c_double), target, allocatable :: cc(:), dd(:)\n+     real(c_double), pointer :: ee(:), ff(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+\n+     aa = 11.0_c_double\n+     bb = 22.0_c_double\n+     cc = 33.0_c_double\n+     dd = 44.0_c_double\n+     ee = 55.0_c_double\n+     ff = 66.0_c_double\n+\n+     call test_dummy_callee_1(aa, bb, cc, dd, ee, ff, N)\n+     deallocate(ee, ff) ! pointers, only\n+  end subroutine test_dummy_call_1\n+\n+  subroutine test_dummy_callee_1(aa, bb, cc, dd, ee, ff, N)\n+     real(c_double), target :: aa(:), bb(:)\n+     real(c_double), target, allocatable :: cc(:), dd(:)\n+     real(c_double), pointer :: ee(:), ff(:)\n+\n+     integer, value :: N\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     call copy3_array(c_loc(aa), c_loc(bb), N)\n+     !$omp end target data\n+     if (any(abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     call copy3_array(c_loc(cc), c_loc(dd), N)\n+     !$omp end target data\n+     if (any(abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     call copy3_array(c_loc(ee), c_loc(ff), N)\n+     !$omp end target data\n+     if (any(abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+  end subroutine test_dummy_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_call_2()\n+     integer, parameter :: N = 1000\n+\n+     real(c_double), target :: aa(N), bb(N)\n+     real(c_double), target, allocatable :: cc(:), dd(:)\n+     real(c_double), pointer :: ee(:), ff(:)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr\n+     real(c_double), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+\n+     call test_dummy_callee_2(aa, bb, cc, dd, ee, ff, &\n+                               c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &\n+                               aptr, bptr, cptr, dptr, eptr, fptr, &\n+                               N)\n+     deallocate(ee, ff)\n+  end subroutine test_dummy_call_2\n+\n+  subroutine test_dummy_callee_2(aa, bb, cc, dd, ee, ff, &\n+                                  c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &\n+                                  aptr, bptr, cptr, dptr, eptr, fptr, &\n+                                  N)\n+     real(c_double), target :: aa(:), bb(:)\n+     real(c_double), target, allocatable :: cc(:), dd(:)\n+     real(c_double), pointer :: ee(:), ff(:)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr\n+     real(c_double), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)\n+\n+     integer, value :: N\n+\n+     real(c_double) :: dummy\n+\n+     aa = 111.0_c_double\n+     bb = 222.0_c_double\n+     cc = 333.0_c_double\n+     dd = 444.0_c_double\n+     ee = 555.0_c_double\n+     ff = 666.0_c_double\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_aptr, c_bptr, N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_array(c_aptr, c_bptr, N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_array(c_loc(aptr), c_loc(bptr), N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 1\n+\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_array(c_loc(cptr), c_loc(dptr), N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd))) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_array(c_loc(eptr), c_loc(fptr), N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+  end subroutine test_dummy_callee_2\n+end module test_dummies\n+\n+\n+\n+! Test local dummy arguments + OPTIONAL\n+! Values present and ptr associated to nonzero\n+module test_dummies_opt\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_opt_call_1, test_dummy_opt_call_2\n+contains\n+  subroutine test_dummy_opt_call_1()\n+     integer, parameter :: N = 1000\n+\n+     real(c_double), target :: aa(N), bb(N)\n+     real(c_double), target, allocatable :: cc(:), dd(:)\n+     real(c_double), pointer :: ee(:), ff(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+\n+     aa = 11.0_c_double\n+     bb = 22.0_c_double\n+     cc = 33.0_c_double\n+     dd = 44.0_c_double\n+     ee = 55.0_c_double\n+     ff = 66.0_c_double\n+\n+     call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)\n+     deallocate(ee, ff) ! pointers, only\n+  end subroutine test_dummy_opt_call_1\n+\n+  subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)\n+     ! scalars\n+     real(c_double), optional, target :: aa(:), bb(:)\n+     real(c_double), optional, target, allocatable :: cc(:), dd(:)\n+     real(c_double), optional, pointer :: ee(:), ff(:)\n+\n+     integer, value :: N\n+\n+     ! All shall be present - and pointing to non-NULL\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+\n+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     call copy3_array(c_loc(aa), c_loc(bb), N)\n+     !$omp end target data\n+     if (any(abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     call copy3_array(c_loc(cc), c_loc(dd), N)\n+     !$omp end target data\n+     if (any(abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     call copy3_array(c_loc(ee), c_loc(ff), N)\n+     !$omp end target data\n+     if (any(abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+  end subroutine test_dummy_opt_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_opt_call_2()\n+     integer, parameter :: N = 1000\n+\n+     real(c_double), target :: aa(N), bb(N)\n+     real(c_double), target, allocatable :: cc(:), dd(:)\n+     real(c_double), pointer :: ee(:), ff(:)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr\n+     real(c_double), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+     call test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, &\n+                                   c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &\n+                                   aptr, bptr, cptr, dptr, eptr, fptr, &\n+                                   N)\n+     deallocate(ee, ff)\n+  end subroutine test_dummy_opt_call_2\n+\n+  subroutine test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, &\n+                                      c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &\n+                                      aptr, bptr, cptr, dptr, eptr, fptr,  &\n+                                      N)\n+     ! scalars\n+     real(c_double), optional, target :: aa(:), bb(:)\n+     real(c_double), optional, target, allocatable :: cc(:), dd(:)\n+     real(c_double), optional, pointer :: ee(:), ff(:)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr\n+     real(c_double), optional, pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)\n+\n+     integer, value :: N\n+\n+     real(c_double) :: dummy\n+\n+     ! All shall be present - and pointing to non-NULL\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+\n+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+\n+     aa = 111.0_c_double\n+     bb = 222.0_c_double\n+     cc = 333.0_c_double\n+     dd = 444.0_c_double\n+     ee = 555.0_c_double\n+     ff = 666.0_c_double\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 1\n+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 1\n+     !$omp end target data\n+\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 1\n+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_aptr, c_bptr, N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_array(c_aptr, c_bptr, N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_array(c_loc(aptr), c_loc(bptr), N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa))) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 1\n+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 1\n+     !$omp end target data\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 1\n+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_array(c_loc(cptr), c_loc(dptr), N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd))) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 1\n+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 1\n+     !$omp end target data\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 1\n+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_array(c_loc(eptr), c_loc(fptr), N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+  end subroutine test_dummy_opt_callee_2\n+end module test_dummies_opt\n+\n+\n+\n+! Test nullptr\n+module test_nullptr\n+  use iso_c_binding\n+  implicit none (type, external)\n+  private\n+  public :: test_nullptr_1\n+contains\n+  subroutine test_nullptr_1()\n+     real(c_double), pointer :: aa(:), bb(:)\n+     real(c_double), pointer :: ee(:), ff(:)\n+\n+     real(c_double), allocatable, target :: gg(:), hh(:)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_double), pointer :: aptr(:), bptr(:), eptr(:), fptr(:), gptr(:), hptr(:)\n+\n+     aa => null()\n+     bb => null()\n+     ee => null()\n+     ff => null()\n+\n+     if (associated(aa) .or. associated(bb)) stop 1\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (c_associated(c_loc(aa)) .or. c_associated(c_loc(bb))) stop 1\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 1\n+     if (associated(aptr) .or. associated(bptr, bb)) stop 1\n+     if (associated(aa) .or. associated(bb)) stop 1\n+     !$omp end target data\n+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 1\n+     if (associated(aptr) .or. associated(bptr, bb)) stop 1\n+     if (associated(aa) .or. associated(bb)) stop 1\n+\n+     if (allocated(gg)) stop 1\n+     !$omp target data map(tofrom:gg) use_device_addr(gg)\n+     if (c_associated(c_loc(gg))) stop 1\n+     c_gptr = c_loc(gg)\n+     gptr => gg\n+     if (c_associated(c_gptr)) stop 1\n+     if (associated(gptr)) stop 1\n+     if (allocated(gg)) stop 1\n+     !$omp end target data\n+     if (c_associated(c_gptr)) stop 1\n+     if (associated(gptr)) stop 1\n+     if (allocated(gg)) stop 1\n+\n+     call test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)\n+  end subroutine test_nullptr_1\n+\n+  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)\n+     ! scalars\n+     real(c_double), optional, pointer :: ee(:), ff(:)\n+     real(c_double), optional, allocatable, target :: hh(:)\n+\n+     type(c_ptr), optional :: c_eptr, c_fptr, c_hptr\n+     real(c_double), optional, pointer :: eptr(:), fptr(:), hptr(:)\n+\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (associated(ee) .or. associated(ff)) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (associated(ee) .or. associated(ff)) stop 1\n+     if (c_associated(c_loc(ee)) .or. c_associated(c_loc(ff))) stop 1\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 1\n+     if (associated(eptr) .or. associated(fptr)) stop 1\n+     !$omp end target data\n+\n+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 1\n+     if (associated(eptr) .or. associated(fptr)) stop 1\n+\n+     if (allocated(hh)) stop 1\n+     !$omp target data map(tofrom:hh) use_device_addr(hh)\n+     if (c_associated(c_loc(hh))) stop 1\n+     c_hptr = c_loc(hh)\n+     hptr => hh\n+     if (c_associated(c_hptr)) stop 1\n+     if (associated(hptr)) stop 1\n+     if (allocated(hh)) stop 1\n+     !$omp end target data\n+     if (c_associated(c_hptr)) stop 1\n+     if (associated(hptr)) stop 1\n+     if (allocated(hh)) stop 1\n+  end subroutine test_dummy_opt_nullptr_callee_1\n+end module test_nullptr\n+\n+\n+\n+! Test local variables\n+module tests\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_main_1, test_main_2\n+contains\n+   ! map + use_device_addr + c_loc\n+   subroutine test_main_1()\n+     integer, parameter :: N = 1000\n+\n+     real(c_double), target, allocatable :: cc(:), dd(:)\n+     real(c_double), pointer :: ee(:), ff(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+\n+     cc = 33.0_c_double\n+     dd = 44.0_c_double\n+     ee = 55.0_c_double\n+     ff = 66.0_c_double\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     call copy3_array(c_loc(cc), c_loc(dd), N)\n+     !$omp end target data\n+     if (any(abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     call copy3_array(c_loc(ee), c_loc(ff), N)\n+     !$omp end target data\n+     if (any(abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+\n+     deallocate(ee, ff) ! pointers, only\n+   end subroutine test_main_1\n+\n+   ! Save device ptr - and recall pointer\n+   subroutine test_main_2\n+     integer, parameter :: N = 1000\n+\n+     real(c_double), target, allocatable :: cc(:), dd(:)\n+     real(c_double), pointer :: ee(:), ff(:)\n+\n+     real(c_double) :: dummy\n+     type(c_ptr) :: c_cptr, c_dptr, c_eptr, c_fptr\n+     real(c_double), pointer :: cptr(:), dptr(:), eptr(:), fptr(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+\n+     cc = 333.0_c_double\n+     dd = 444.0_c_double\n+     ee = 555.0_c_double\n+     ff = 666.0_c_double\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_array(c_loc(cptr), c_loc(dptr), N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd))) stop 1\n+     if (any(abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd))) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_array(c_loc(eptr), c_loc(fptr), N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee))) stop 1\n+\n+     deallocate(ee, ff)\n+   end subroutine test_main_2\n+end module tests\n+\n+\n+program omp_device_addr\n+  use tests\n+  use test_dummies\n+  use test_dummies_opt\n+  use test_nullptr\n+  implicit none (type, external)\n+\n+  call test_main_1()\n+  call test_main_2()\n+\n+  call test_dummy_call_1()\n+  call test_dummy_call_2()\n+\n+  call test_dummy_opt_call_1()\n+  call test_dummy_opt_call_2()\n+\n+  call test_nullptr_1()\n+end program omp_device_addr"}, {"sha": "32dc92c2ff4b7d794f60a15232d79536ffb61883", "filename": "libgomp/testsuite/libgomp.fortran/use_device_addr-4.f90", "status": "added", "additions": 763, "deletions": 0, "changes": 763, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-4.f90?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -0,0 +1,763 @@\n+! Comprehensive run-time test for use_device_addr\n+!\n+! Tests array with array descriptor\n+!\n+! Differs from use_device_addr-3.f90 by using a 4-byte variable (c_float)\n+!\n+! This test case assumes that a 'var' appearing in 'use_device_addr' is\n+! only used as 'c_loc(var)' - such that only the actual data is used/usable\n+! on the device - and not meta data ((dynamic) type information, 'present()'\n+! status, array shape).\n+!\n+! Untested in this test case are:\n+! - scalars\n+! - polymorphic variables\n+! - absent optional arguments\n+!\n+module target_procs\n+  use iso_c_binding\n+  implicit none (type, external)\n+  private\n+  public :: copy3_array\n+contains\n+  subroutine copy3_array_int(from_ptr, to_ptr, N)\n+    !$omp declare target\n+    real(c_float) :: from_ptr(:)\n+    real(c_float) :: to_ptr(:)\n+    integer, value :: N\n+    integer :: i\n+\n+    !$omp parallel do\n+    do i = 1, N\n+      to_ptr(i) = 3 * from_ptr(i)\n+    end do\n+    !$omp end parallel do\n+  end subroutine copy3_array_int\n+\n+  subroutine copy3_array(from, to, N)\n+    type(c_ptr), value :: from, to\n+    integer, value :: N\n+    real(c_float), pointer :: from_ptr(:), to_ptr(:)\n+\n+    call c_f_pointer(from, from_ptr, shape=[N])\n+    call c_f_pointer(to, to_ptr, shape=[N])\n+\n+    call do_offload_scalar(from_ptr,to_ptr)\n+  contains\n+    subroutine do_offload_scalar(from_r, to_r)\n+      real(c_float), target :: from_r(:), to_r(:)\n+      ! The extra function is needed as is_device_ptr\n+      ! requires non-value, non-pointer dummy arguments\n+\n+      !$omp target is_device_ptr(from_r, to_r)\n+      call copy3_array_int(from_r, to_r, N)\n+      !$omp end target\n+    end subroutine do_offload_scalar\n+  end subroutine copy3_array\n+end module target_procs\n+\n+\n+\n+! Test local dummy arguments (w/o optional)\n+module test_dummies\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_call_1, test_dummy_call_2\n+contains\n+  subroutine test_dummy_call_1()\n+     integer, parameter :: N = 1000\n+\n+     real(c_float), target :: aa(N), bb(N)\n+     real(c_float), target, allocatable :: cc(:), dd(:)\n+     real(c_float), pointer :: ee(:), ff(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+\n+     aa = 11.0_c_float\n+     bb = 22.0_c_float\n+     cc = 33.0_c_float\n+     dd = 44.0_c_float\n+     ee = 55.0_c_float\n+     ff = 66.0_c_float\n+\n+     call test_dummy_callee_1(aa, bb, cc, dd, ee, ff, N)\n+     deallocate(ee, ff) ! pointers, only\n+  end subroutine test_dummy_call_1\n+\n+  subroutine test_dummy_callee_1(aa, bb, cc, dd, ee, ff, N)\n+     real(c_float), target :: aa(:), bb(:)\n+     real(c_float), target, allocatable :: cc(:), dd(:)\n+     real(c_float), pointer :: ee(:), ff(:)\n+\n+     integer, value :: N\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     call copy3_array(c_loc(aa), c_loc(bb), N)\n+     !$omp end target data\n+     if (any(abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     call copy3_array(c_loc(cc), c_loc(dd), N)\n+     !$omp end target data\n+     if (any(abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     call copy3_array(c_loc(ee), c_loc(ff), N)\n+     !$omp end target data\n+     if (any(abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+  end subroutine test_dummy_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_call_2()\n+     integer, parameter :: N = 1000\n+\n+     real(c_float), target :: aa(N), bb(N)\n+     real(c_float), target, allocatable :: cc(:), dd(:)\n+     real(c_float), pointer :: ee(:), ff(:)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr\n+     real(c_float), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+\n+     call test_dummy_callee_2(aa, bb, cc, dd, ee, ff, &\n+                               c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &\n+                               aptr, bptr, cptr, dptr, eptr, fptr, &\n+                               N)\n+     deallocate(ee, ff)\n+  end subroutine test_dummy_call_2\n+\n+  subroutine test_dummy_callee_2(aa, bb, cc, dd, ee, ff, &\n+                                  c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &\n+                                  aptr, bptr, cptr, dptr, eptr, fptr, &\n+                                  N)\n+     real(c_float), target :: aa(:), bb(:)\n+     real(c_float), target, allocatable :: cc(:), dd(:)\n+     real(c_float), pointer :: ee(:), ff(:)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr\n+     real(c_float), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)\n+\n+     integer, value :: N\n+\n+     real(c_float) :: dummy\n+\n+     aa = 111.0_c_float\n+     bb = 222.0_c_float\n+     cc = 333.0_c_float\n+     dd = 444.0_c_float\n+     ee = 555.0_c_float\n+     ff = 666.0_c_float\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_aptr, c_bptr, N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_array(c_aptr, c_bptr, N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_array(c_loc(aptr), c_loc(bptr), N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 1\n+\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_array(c_loc(cptr), c_loc(dptr), N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd))) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_array(c_loc(eptr), c_loc(fptr), N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+  end subroutine test_dummy_callee_2\n+end module test_dummies\n+\n+\n+\n+! Test local dummy arguments + OPTIONAL\n+! Values present and ptr associated to nonzero\n+module test_dummies_opt\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_opt_call_1, test_dummy_opt_call_2\n+contains\n+  subroutine test_dummy_opt_call_1()\n+     integer, parameter :: N = 1000\n+\n+     real(c_float), target :: aa(N), bb(N)\n+     real(c_float), target, allocatable :: cc(:), dd(:)\n+     real(c_float), pointer :: ee(:), ff(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+\n+     aa = 11.0_c_float\n+     bb = 22.0_c_float\n+     cc = 33.0_c_float\n+     dd = 44.0_c_float\n+     ee = 55.0_c_float\n+     ff = 66.0_c_float\n+\n+     call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)\n+     deallocate(ee, ff) ! pointers, only\n+  end subroutine test_dummy_opt_call_1\n+\n+  subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, N)\n+     ! scalars\n+     real(c_float), optional, target :: aa(:), bb(:)\n+     real(c_float), optional, target, allocatable :: cc(:), dd(:)\n+     real(c_float), optional, pointer :: ee(:), ff(:)\n+\n+     integer, value :: N\n+\n+     ! All shall be present - and pointing to non-NULL\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+\n+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     call copy3_array(c_loc(aa), c_loc(bb), N)\n+     !$omp end target data\n+     if (any(abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     call copy3_array(c_loc(cc), c_loc(dd), N)\n+     !$omp end target data\n+     if (any(abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     call copy3_array(c_loc(ee), c_loc(ff), N)\n+     !$omp end target data\n+     if (any(abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+  end subroutine test_dummy_opt_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_opt_call_2()\n+     integer, parameter :: N = 1000\n+\n+     real(c_float), target :: aa(N), bb(N)\n+     real(c_float), target, allocatable :: cc(:), dd(:)\n+     real(c_float), pointer :: ee(:), ff(:)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr\n+     real(c_float), pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+     call test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, &\n+                                   c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &\n+                                   aptr, bptr, cptr, dptr, eptr, fptr, &\n+                                   N)\n+     deallocate(ee, ff)\n+  end subroutine test_dummy_opt_call_2\n+\n+  subroutine test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, &\n+                                      c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, &\n+                                      aptr, bptr, cptr, dptr, eptr, fptr,  &\n+                                      N)\n+     ! scalars\n+     real(c_float), optional, target :: aa(:), bb(:)\n+     real(c_float), optional, target, allocatable :: cc(:), dd(:)\n+     real(c_float), optional, pointer :: ee(:), ff(:)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr\n+     real(c_float), optional, pointer :: aptr(:), bptr(:), cptr(:), dptr(:), eptr(:), fptr(:)\n+\n+     integer, value :: N\n+\n+     real(c_float) :: dummy\n+\n+     ! All shall be present - and pointing to non-NULL\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+\n+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+\n+     aa = 111.0_c_float\n+     bb = 222.0_c_float\n+     cc = 333.0_c_float\n+     dd = 444.0_c_float\n+     ee = 555.0_c_float\n+     ff = 666.0_c_float\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 1\n+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 1\n+     !$omp end target data\n+\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 1\n+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_aptr, c_bptr, N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_array(c_aptr, c_bptr, N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_array(c_loc(aptr), c_loc(bptr), N)\n+     !$omp target update from(bb)\n+     if (any(abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa))) stop 1\n+     if (any(abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa))) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.allocated(cc) .or. .not.allocated(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 1\n+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 1\n+     !$omp end target data\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 1\n+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_array(c_loc(cptr), c_loc(dptr), N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd))) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 1\n+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 1\n+     !$omp end target data\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 1\n+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_array(c_loc(eptr), c_loc(fptr), N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+  end subroutine test_dummy_opt_callee_2\n+end module test_dummies_opt\n+\n+\n+\n+! Test nullptr\n+module test_nullptr\n+  use iso_c_binding\n+  implicit none (type, external)\n+  private\n+  public :: test_nullptr_1\n+contains\n+  subroutine test_nullptr_1()\n+     real(c_float), pointer :: aa(:), bb(:)\n+     real(c_float), pointer :: ee(:), ff(:)\n+\n+     real(c_float), allocatable, target :: gg(:), hh(:)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_float), pointer :: aptr(:), bptr(:), eptr(:), fptr(:), gptr(:), hptr(:)\n+\n+     aa => null()\n+     bb => null()\n+     ee => null()\n+     ff => null()\n+\n+     if (associated(aa) .or. associated(bb)) stop 1\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (c_associated(c_loc(aa)) .or. c_associated(c_loc(bb))) stop 1\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 1\n+     if (associated(aptr) .or. associated(bptr, bb)) stop 1\n+     if (associated(aa) .or. associated(bb)) stop 1\n+     !$omp end target data\n+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 1\n+     if (associated(aptr) .or. associated(bptr, bb)) stop 1\n+     if (associated(aa) .or. associated(bb)) stop 1\n+\n+     if (allocated(gg)) stop 1\n+     !$omp target data map(tofrom:gg) use_device_addr(gg)\n+     if (c_associated(c_loc(gg))) stop 1\n+     c_gptr = c_loc(gg)\n+     gptr => gg\n+     if (c_associated(c_gptr)) stop 1\n+     if (associated(gptr)) stop 1\n+     if (allocated(gg)) stop 1\n+     !$omp end target data\n+     if (c_associated(c_gptr)) stop 1\n+     if (associated(gptr)) stop 1\n+     if (allocated(gg)) stop 1\n+\n+     call test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)\n+  end subroutine test_nullptr_1\n+\n+  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, hh, c_eptr, c_fptr, c_hptr, eptr, fptr, hptr)\n+     ! scalars\n+     real(c_float), optional, pointer :: ee(:), ff(:)\n+     real(c_float), optional, allocatable, target :: hh(:)\n+\n+     type(c_ptr), optional :: c_eptr, c_fptr, c_hptr\n+     real(c_float), optional, pointer :: eptr(:), fptr(:), hptr(:)\n+\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (associated(ee) .or. associated(ff)) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (associated(ee) .or. associated(ff)) stop 1\n+     if (c_associated(c_loc(ee)) .or. c_associated(c_loc(ff))) stop 1\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 1\n+     if (associated(eptr) .or. associated(fptr)) stop 1\n+     !$omp end target data\n+\n+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 1\n+     if (associated(eptr) .or. associated(fptr)) stop 1\n+\n+     if (allocated(hh)) stop 1\n+     !$omp target data map(tofrom:hh) use_device_addr(hh)\n+     if (c_associated(c_loc(hh))) stop 1\n+     c_hptr = c_loc(hh)\n+     hptr => hh\n+     if (c_associated(c_hptr)) stop 1\n+     if (associated(hptr)) stop 1\n+     if (allocated(hh)) stop 1\n+     !$omp end target data\n+     if (c_associated(c_hptr)) stop 1\n+     if (associated(hptr)) stop 1\n+     if (allocated(hh)) stop 1\n+  end subroutine test_dummy_opt_nullptr_callee_1\n+end module test_nullptr\n+\n+\n+\n+! Test local variables\n+module tests\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_main_1, test_main_2\n+contains\n+   ! map + use_device_addr + c_loc\n+   subroutine test_main_1()\n+     integer, parameter :: N = 1000\n+\n+     real(c_float), target, allocatable :: cc(:), dd(:)\n+     real(c_float), pointer :: ee(:), ff(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+\n+     cc = 33.0_c_float\n+     dd = 44.0_c_float\n+     ee = 55.0_c_float\n+     ff = 66.0_c_float\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     call copy3_array(c_loc(cc), c_loc(dd), N)\n+     !$omp end target data\n+     if (any(abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     call copy3_array(c_loc(ee), c_loc(ff), N)\n+     !$omp end target data\n+     if (any(abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+\n+     deallocate(ee, ff) ! pointers, only\n+   end subroutine test_main_1\n+\n+   ! Save device ptr - and recall pointer\n+   subroutine test_main_2\n+     integer, parameter :: N = 1000\n+\n+     real(c_float), target, allocatable :: cc(:), dd(:)\n+     real(c_float), pointer :: ee(:), ff(:)\n+\n+     real(c_float) :: dummy\n+     type(c_ptr) :: c_cptr, c_dptr, c_eptr, c_fptr\n+     real(c_float), pointer :: cptr(:), dptr(:), eptr(:), fptr(:)\n+\n+     allocate(cc(N), dd(N), ee(N), ff(N))\n+\n+     cc = 333.0_c_float\n+     dd = 444.0_c_float\n+     ee = 555.0_c_float\n+     ff = 666.0_c_float\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_array(c_cptr, c_dptr, N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_array(c_loc(cptr), c_loc(dptr), N)\n+     !$omp target update from(dd)\n+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd))) stop 1\n+     if (any(abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd))) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_array(c_eptr, c_fptr, N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_array(c_loc(eptr), c_loc(fptr), N)\n+     !$omp target update from(ff)\n+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee))) stop 1\n+     if (any(abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee))) stop 1\n+\n+     deallocate(ee, ff)\n+   end subroutine test_main_2\n+end module tests\n+\n+\n+program omp_device_addr\n+  use tests\n+  use test_dummies\n+  use test_dummies_opt\n+  use test_nullptr\n+  implicit none (type, external)\n+\n+  call test_main_1()\n+  call test_main_2()\n+\n+  call test_dummy_call_1()\n+  call test_dummy_call_2()\n+\n+  call test_dummy_opt_call_1()\n+  call test_dummy_opt_call_2()\n+\n+  call test_nullptr_1()\n+end program omp_device_addr"}, {"sha": "62f096821282eb1efefb35d93f4a83e1b6831ec9", "filename": "libgomp/testsuite/libgomp.fortran/use_device_ptr-1.f90", "status": "added", "additions": 595, "deletions": 0, "changes": 595, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92e63bd2dfefb2d27bc235523bec6740bba512c2/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-1.f90?ref=92e63bd2dfefb2d27bc235523bec6740bba512c2", "patch": "@@ -0,0 +1,595 @@\n+module target_procs\n+  use iso_c_binding\n+  implicit none (type, external)\n+  private\n+  public :: copy3_array, copy3_scalar, copy3_array1, copy3_array3\n+contains\n+  subroutine copy3_array_int(from_ptr, to_ptr, N)\n+    !$omp declare target\n+    real(c_double) :: from_ptr(:)\n+    real(c_double) :: to_ptr(:)\n+    integer, value :: N\n+    integer :: i\n+\n+    !$omp parallel do\n+    do i = 1, N\n+      to_ptr(i) = 3 * from_ptr(i)\n+    end do\n+    !$omp end parallel do\n+  end subroutine copy3_array_int\n+\n+  subroutine copy3_scalar_int(from, to)\n+    !$omp declare target\n+    real(c_double) :: from, to\n+\n+    to = 3 * from\n+  end subroutine copy3_scalar_int\n+\n+\n+  subroutine copy3_array(from, to, N)\n+    type(c_ptr), value :: from, to\n+    integer, value :: N\n+    real(c_double), pointer :: from_ptr(:), to_ptr(:)\n+\n+    call c_f_pointer(from, from_ptr, shape=[N])\n+    call c_f_pointer(to, to_ptr, shape=[N])\n+\n+    call do_offload_scalar(from_ptr,to_ptr)\n+  contains\n+    subroutine do_offload_scalar(from_r, to_r)\n+      real(c_double), target :: from_r(:), to_r(:)\n+      ! The extra function is needed as is_device_ptr\n+      ! requires non-value, non-pointer dummy arguments\n+\n+      !$omp target is_device_ptr(from_r, to_r)\n+      call copy3_array_int(from_r, to_r, N)\n+      !$omp end target\n+    end subroutine do_offload_scalar\n+  end subroutine copy3_array\n+\n+  subroutine copy3_scalar(from, to)\n+    type(c_ptr), value, target :: from, to\n+    real(c_double), pointer :: from_ptr(:), to_ptr(:)\n+\n+    ! Standard-conform detour of using an array as at time of writing\n+    ! is_device_ptr below does not handle scalars\n+    call c_f_pointer(from, from_ptr, shape=[1])\n+    call c_f_pointer(to, to_ptr, shape=[1])\n+\n+    call do_offload_scalar(from_ptr,to_ptr)\n+  contains\n+    subroutine do_offload_scalar(from_r, to_r)\n+      real(c_double), target :: from_r(:), to_r(:)\n+      ! The extra function is needed as is_device_ptr\n+      ! requires non-value, non-pointer dummy arguments\n+\n+      !$omp target is_device_ptr(from_r, to_r)\n+      call copy3_scalar_int(from_r(1), to_r(1))\n+      !$omp end target\n+    end subroutine do_offload_scalar\n+  end subroutine copy3_scalar\n+\n+  subroutine copy3_array1(from, to)\n+    real(c_double), target :: from(:), to(:)\n+    integer :: N\n+    N = size(from)\n+\n+    !!$omp target is_device_ptr(from, to)\n+    call copy3_array(c_loc(from), c_loc(to), N)\n+    !!$omp end target\n+  end subroutine copy3_array1\n+\n+  subroutine copy3_array3(from, to)\n+    real(c_double), optional, target :: from(:), to(:)\n+    integer :: N\n+    N = size(from)\n+\n+!    !$omp target is_device_ptr(from, to)\n+    call copy3_array(c_loc(from), c_loc(to), N)\n+!    !$omp end target\n+  end subroutine copy3_array3\n+end module target_procs\n+\n+\n+\n+module offloading2\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+contains\n+  ! Same as main program but uses dummy *nonoptional* arguments\n+  subroutine use_device_ptr_sub(AA, BB, CC, DD, EE, FF, AptrA, BptrB, N)\n+    real(c_double), pointer :: AA(:), BB(:)\n+    real(c_double), allocatable, target :: CC(:), DD(:)\n+    real(c_double), target :: EE(N), FF(N), dummy(1)\n+    real(c_double), pointer :: AptrA(:), BptrB(:)\n+    intent(inout) :: AA, BB, CC, DD, EE, FF\n+    integer, value :: N\n+\n+    type(c_ptr) :: tgt_aptr, tgt_bptr, tgt_cptr, tgt_dptr, tgt_eptr, tgt_fptr\n+\n+    AA = 11.0_c_double\n+    BB = 22.0_c_double\n+    CC = 33.0_c_double\n+    DD = 44.0_c_double\n+    EE = 55.0_c_double\n+    FF = 66.0_c_double\n+\n+    ! pointer-type array to use_device_ptr\n+    !$omp target data map(to:AA) map(from:BB) use_device_ptr(AA,BB)\n+    call copy3_array(c_loc(AA), c_loc(BB), N)\n+    !$omp end target data\n+\n+    if (any(abs(AA - 11.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+    ! allocatable array to use_device_ptr\n+    !$omp target data map(to:CC) map(from:DD) use_device_ptr(CC,DD)\n+    call copy3_array(c_loc(CC), c_loc(DD), N)\n+    !$omp end target data\n+\n+    if (any(abs(CC - 33.0_c_double) > 10.0_c_double * epsilon(CC))) stop 1\n+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 1\n+\n+    ! fixed-size decriptorless array to use_device_ptr\n+    !$omp target data map(to:EE) map(from:FF) use_device_ptr(EE,FF)\n+    call copy3_array(c_loc(EE), c_loc(FF), N)\n+    !$omp end target data\n+\n+    if (any(abs(EE - 55.0_c_double) > 10.0_c_double * epsilon(EE))) stop 1\n+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 1\n+\n+\n+\n+    AA = 111.0_c_double\n+    BB = 222.0_c_double\n+    CC = 333.0_c_double\n+    DD = 444.0_c_double\n+    EE = 555.0_c_double\n+    FF = 666.0_c_double\n+\n+    ! pointer-type array to use_device_ptr\n+    !$omp target data map(to:AA) map(from:BB)\n+    !$omp target data map(alloc:dummy) use_device_ptr(AA,BB)\n+    tgt_aptr = c_loc(AA)\n+    tgt_bptr = c_loc(BB)\n+    AptrA => AA\n+    BptrB => BB\n+    !$omp end target data\n+\n+    call copy3_array(tgt_aptr, tgt_bptr, N)\n+    !$omp target update from(BB)\n+    if (any(abs(AA - 111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+    AA = 1111.0_c_double\n+    !$omp target update to(AA)\n+    call copy3_array(tgt_aptr, tgt_bptr, N)\n+    !$omp target update from(BB)\n+    if (any(abs(AA - 1111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+    ! AprtA tests\n+    AA = 7.0_c_double\n+    !$omp target update to(AA)\n+    call copy3_array(c_loc(AptrA), c_loc(BptrB), N)\n+    !$omp target update from(BB)\n+    if (any(abs(AA - 7.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+    AA = 77.0_c_double\n+    !$omp target update to(AA)\n+    call copy3_array1(AptrA, BptrB)\n+    !$omp target update from(BB)\n+    if (any(abs(AA - 77.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+!    AA = 777.0_c_double\n+!    !$omp target update to(AA)\n+!    call copy3_array2(AptrA, BptrB)\n+!    !$omp target update from(BB)\n+!    if (any(abs(AA - 777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+!    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+    AA = 7777.0_c_double\n+    !$omp target update to(AA)\n+    call copy3_array3(AptrA, BptrB)\n+    !$omp target update from(BB)\n+    if (any(abs(AA - 7777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+!    AA = 77777.0_c_double\n+!    !$omp target update to(AA)\n+!    call copy3_array4(AptrA, BptrB)\n+!    !$omp target update from(BB)\n+    !$omp end target data\n+!\n+!    if (any(abs(AA - 77777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+!    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+\n+\n+    ! allocatable array to use_device_ptr\n+    !$omp target data map(to:CC) map(from:DD)\n+    !$omp target data map(alloc:dummy) use_device_ptr(CC,DD)\n+    tgt_cptr = c_loc(CC)\n+    tgt_dptr = c_loc(DD)\n+    !$omp end target data\n+\n+    call copy3_array(tgt_cptr, tgt_dptr, N)\n+    !$omp target update from(DD)\n+    if (any(abs(CC - 333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 1\n+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 1\n+\n+    CC = 3333.0_c_double\n+    !$omp target update to(CC)\n+    call copy3_array(tgt_cptr, tgt_dptr, N)\n+    !$omp target update from(DD)\n+    !$omp end target data\n+\n+    if (any(abs(CC - 3333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 1\n+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 1\n+\n+\n+\n+    ! fixed-size decriptorless array to use_device_ptr\n+    !$omp target data map(to:EE) map(from:FF)\n+    !$omp target data map(alloc:dummy) use_device_ptr(EE,FF)\n+    tgt_eptr = c_loc(EE)\n+    tgt_fptr = c_loc(FF)\n+    !$omp end target data\n+\n+    call copy3_array(tgt_eptr, tgt_fptr, N)\n+    !$omp target update from(FF)\n+    if (any(abs(EE - 555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 1\n+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 1\n+\n+    EE = 5555.0_c_double\n+    !$omp target update to(EE)\n+    call copy3_array(tgt_eptr, tgt_fptr, N)\n+    !$omp target update from(FF)\n+    !$omp end target data\n+\n+    if (any(abs(EE - 5555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 1\n+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 1\n+  end subroutine use_device_ptr_sub\n+\n+\n+\n+  ! Same as main program but uses dummy *optional* arguments\n+  subroutine use_device_ptr_sub2(AA, BB, CC, DD, EE, FF, AptrA, BptrB, N)\n+    real(c_double), optional, pointer :: AA(:), BB(:)\n+    real(c_double), optional, allocatable, target :: CC(:), DD(:)\n+    real(c_double), optional, target :: EE(N), FF(N)\n+    real(c_double), pointer :: AptrA(:), BptrB(:)\n+    intent(inout) :: AA, BB, CC, DD, EE, FF\n+    real(c_double), target :: dummy(1)\n+    integer, value :: N\n+\n+    type(c_ptr) :: tgt_aptr, tgt_bptr, tgt_cptr, tgt_dptr, tgt_eptr, tgt_fptr\n+\n+    AA = 11.0_c_double\n+    BB = 22.0_c_double\n+    CC = 33.0_c_double\n+    DD = 44.0_c_double\n+    EE = 55.0_c_double\n+    FF = 66.0_c_double\n+\n+    ! pointer-type array to use_device_ptr\n+    !$omp target data map(to:AA) map(from:BB) use_device_ptr(AA,BB)\n+    call copy3_array(c_loc(AA), c_loc(BB), N)\n+    !$omp end target data\n+\n+    if (any(abs(AA - 11.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+    ! allocatable array to use_device_ptr\n+    !$omp target data map(to:CC) map(from:DD) use_device_ptr(CC,DD)\n+    call copy3_array(c_loc(CC), c_loc(DD), N)\n+    !$omp end target data\n+\n+    if (any(abs(CC - 33.0_c_double) > 10.0_c_double * epsilon(CC))) stop 1\n+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 1\n+\n+    ! fixed-size decriptorless array to use_device_ptr\n+    !$omp target data map(to:EE) map(from:FF) use_device_ptr(EE,FF)\n+    call copy3_array(c_loc(EE), c_loc(FF), N)\n+    !$omp end target data\n+\n+    if (any(abs(EE - 55.0_c_double) > 10.0_c_double * epsilon(EE))) stop 1\n+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 1\n+\n+\n+\n+    AA = 111.0_c_double\n+    BB = 222.0_c_double\n+    CC = 333.0_c_double\n+    DD = 444.0_c_double\n+    EE = 555.0_c_double\n+    FF = 666.0_c_double\n+\n+    ! pointer-type array to use_device_ptr\n+    !$omp target data map(to:AA) map(from:BB)\n+    !$omp target data map(alloc:dummy) use_device_ptr(AA,BB)\n+    tgt_aptr = c_loc(AA)\n+    tgt_bptr = c_loc(BB)\n+    AptrA => AA\n+    BptrB => BB\n+    !$omp end target data\n+\n+    call copy3_array(tgt_aptr, tgt_bptr, N)\n+    !$omp target update from(BB)\n+    if (any(abs(AA - 111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+    AA = 1111.0_c_double\n+    !$omp target update to(AA)\n+    call copy3_array(tgt_aptr, tgt_bptr, N)\n+    !$omp target update from(BB)\n+    if (any(abs(AA - 1111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+    ! AprtA tests\n+    AA = 7.0_c_double\n+    !$omp target update to(AA)\n+    call copy3_array(c_loc(AptrA), c_loc(BptrB), N)\n+    !$omp target update from(BB)\n+    if (any(abs(AA - 7.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+    AA = 77.0_c_double\n+    !$omp target update to(AA)\n+    call copy3_array1(AptrA, BptrB)\n+    !$omp target update from(BB)\n+    if (any(abs(AA - 77.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+!    AA = 777.0_c_double\n+!    !$omp target update to(AA)\n+!    call copy3_array2(AptrA, BptrB)\n+!    !$omp target update from(BB)\n+!    if (any(abs(AA - 777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+!    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+    AA = 7777.0_c_double\n+    !$omp target update to(AA)\n+    call copy3_array3(AptrA, BptrB)\n+    !$omp target update from(BB)\n+    if (any(abs(AA - 7777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+!    AA = 77777.0_c_double\n+!    !$omp target update to(AA)\n+!    call copy3_array4(AptrA, BptrB)\n+!    !$omp target update from(BB)\n+    !$omp end target data\n+!\n+!    if (any(abs(AA - 77777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+!    if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+\n+\n+    ! allocatable array to use_device_ptr\n+    !$omp target data map(to:CC) map(from:DD)\n+    !$omp target data map(alloc:dummy) use_device_ptr(CC,DD)\n+    tgt_cptr = c_loc(CC)\n+    tgt_dptr = c_loc(DD)\n+    !$omp end target data\n+\n+    call copy3_array(tgt_cptr, tgt_dptr, N)\n+    !$omp target update from(DD)\n+    if (any(abs(CC - 333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 1\n+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 1\n+\n+    CC = 3333.0_c_double\n+    !$omp target update to(CC)\n+    call copy3_array(tgt_cptr, tgt_dptr, N)\n+    !$omp target update from(DD)\n+    !$omp end target data\n+\n+    if (any(abs(CC - 3333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 1\n+    if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 1\n+\n+\n+\n+    ! fixed-size decriptorless array to use_device_ptr\n+    !$omp target data map(to:EE) map(from:FF)\n+    !$omp target data map(alloc:dummy) use_device_ptr(EE,FF)\n+    tgt_eptr = c_loc(EE)\n+    tgt_fptr = c_loc(FF)\n+    !$omp end target data\n+\n+    call copy3_array(tgt_eptr, tgt_fptr, N)\n+    !$omp target update from(FF)\n+    if (any(abs(EE - 555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 1\n+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 1\n+\n+    EE = 5555.0_c_double\n+    !$omp target update to(EE)\n+    call copy3_array(tgt_eptr, tgt_fptr, N)\n+    !$omp end target data\n+\n+    if (any(abs(EE - 5555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 1\n+    if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 1\n+  end subroutine use_device_ptr_sub2\n+end module offloading2\n+\n+\n+\n+program omp_device_ptr\n+  use iso_c_binding\n+  use target_procs\n+  use offloading2\n+  implicit none (type, external)\n+\n+  integer, parameter :: N = 1000\n+  real(c_double), pointer :: AA(:), BB(:), arg_AA(:), arg_BB(:), arg2_AA(:), arg2_BB(:)\n+  real(c_double), allocatable, target :: CC(:), DD(:), arg_CC(:), arg_DD(:), arg2_CC(:), arg2_DD(:)\n+  real(c_double), target :: EE(N), FF(N), dummy(1), arg_EE(N), arg_FF(N), arg2_EE(N), arg2_FF(N)\n+\n+  real(c_double), pointer :: AptrA(:), BptrB(:)\n+  type(c_ptr) :: tgt_aptr, tgt_bptr, tgt_cptr, tgt_dptr, tgt_eptr, tgt_fptr\n+\n+  allocate(AA(N), BB(N), CC(N), DD(N))\n+\n+  AA = 11.0_c_double\n+  BB = 22.0_c_double\n+  CC = 33.0_c_double\n+  DD = 44.0_c_double\n+  EE = 55.0_c_double\n+  FF = 66.0_c_double\n+\n+  ! pointer-type array to use_device_ptr\n+  !$omp target data map(to:AA) map(from:BB) use_device_ptr(AA,BB)\n+  call copy3_array(c_loc(AA), c_loc(BB), N)\n+  !$omp end target data\n+\n+  if (any(abs(AA - 11.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+  ! allocatable array to use_device_ptr\n+  !$omp target data map(to:CC) map(from:DD) use_device_ptr(CC,DD)\n+  call copy3_array(c_loc(CC), c_loc(DD), N)\n+  !$omp end target data\n+\n+  if (any(abs(CC - 33.0_c_double) > 10.0_c_double * epsilon(CC))) stop 1\n+  if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 1\n+\n+  ! fixed-size decriptorless array to use_device_ptr\n+  !$omp target data map(to:EE) map(from:FF) use_device_ptr(EE,FF)\n+  call copy3_array(c_loc(EE), c_loc(FF), N)\n+  !$omp end target data\n+\n+  if (any(abs(EE - 55.0_c_double) > 10.0_c_double * epsilon(EE))) stop 1\n+  if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 1\n+\n+\n+\n+  AA = 111.0_c_double\n+  BB = 222.0_c_double\n+  CC = 333.0_c_double\n+  DD = 444.0_c_double\n+  EE = 555.0_c_double\n+  FF = 666.0_c_double\n+\n+  ! pointer-type array to use_device_ptr\n+  !$omp target data map(to:AA) map(from:BB)\n+  !$omp target data map(alloc:dummy) use_device_ptr(AA,BB)\n+  tgt_aptr = c_loc(AA)\n+  tgt_bptr = c_loc(BB)\n+  AptrA => AA\n+  BptrB => BB\n+  !$omp end target data\n+\n+  call copy3_array(tgt_aptr, tgt_bptr, N)\n+  !$omp target update from(BB)\n+  if (any(abs(AA - 111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+  AA = 1111.0_c_double\n+  !$omp target update to(AA)\n+  call copy3_array(tgt_aptr, tgt_bptr, N)\n+  !$omp target update from(BB)\n+  if (any(abs(AA - 1111.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+  ! AprtA tests\n+  AA = 7.0_c_double\n+  !$omp target update to(AA)\n+  call copy3_array(c_loc(AptrA), c_loc(BptrB), N)\n+  !$omp target update from(BB)\n+  if (any(abs(AA - 7.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+  AA = 77.0_c_double\n+  !$omp target update to(AA)\n+  call copy3_array1(AptrA, BptrB)\n+  !$omp target update from(BB)\n+  if (any(abs(AA - 77.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+!  AA = 777.0_c_double\n+!  !$omp target update to(AA)\n+!  call copy3_array2(AptrA, BptrB)\n+!  !$omp target update from(BB)\n+!  if (any(abs(AA - 777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+!  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+  AA = 7777.0_c_double\n+  !$omp target update to(AA)\n+  call copy3_array3(AptrA, BptrB)\n+  !$omp target update from(BB)\n+  if (any(abs(AA - 7777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+!  AA = 77777.0_c_double\n+!  !$omp target update to(AA)\n+!  call copy3_array4(AptrA, BptrB)\n+!  !$omp target update from(BB)\n+  !$omp end target data\n+!\n+!  if (any(abs(AA - 77777.0_c_double) > 10.0_c_double * epsilon(AA))) stop 1\n+!  if (any(abs(3.0_c_double * AA - BB) > 10.0_c_double * epsilon(AA))) stop 1\n+\n+\n+\n+  ! allocatable array to use_device_ptr\n+  !$omp target data map(to:CC) map(from:DD)\n+  !$omp target data map(alloc:dummy) use_device_ptr(CC,DD)\n+  tgt_cptr = c_loc(CC)\n+  tgt_dptr = c_loc(DD)\n+  !$omp end target data\n+\n+  call copy3_array(tgt_cptr, tgt_dptr, N)\n+  !$omp target update from(DD)\n+  if (any(abs(CC - 333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 1\n+  if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 1\n+\n+  CC = 3333.0_c_double\n+  !$omp target update to(CC)\n+  call copy3_array(tgt_cptr, tgt_dptr, N)\n+  !$omp target update from(DD)\n+  !$omp end target data\n+\n+  if (any(abs(CC - 3333.0_c_double) > 10.0_c_double * epsilon(CC))) stop 1\n+  if (any(abs(3.0_c_double * CC - DD) > 10.0_c_double * epsilon(CC))) stop 1\n+\n+\n+\n+  ! fixed-size decriptorless array to use_device_ptr\n+  !$omp target data map(to:EE) map(from:FF)\n+  !$omp target data map(alloc:dummy) use_device_ptr(EE,FF)\n+  tgt_eptr = c_loc(EE)\n+  tgt_fptr = c_loc(FF)\n+  !$omp end target data\n+\n+  call copy3_array(tgt_eptr, tgt_fptr, N)\n+  !$omp target update from(FF)\n+  if (any(abs(EE - 555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 1\n+  if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 1\n+\n+  EE = 5555.0_c_double\n+  !$omp target update to(EE)\n+  call copy3_array(tgt_eptr, tgt_fptr, N)\n+  !$omp target update from(FF)\n+  !$omp end target data\n+\n+  if (any(abs(EE - 5555.0_c_double) > 10.0_c_double * epsilon(EE))) stop 1\n+  if (any(abs(3.0_c_double * EE - FF) > 10.0_c_double * epsilon(EE))) stop 1\n+\n+\n+\n+  deallocate(AA, BB)  ! Free pointers only\n+\n+  AptrA => null()\n+  BptrB => null()\n+  allocate(arg_AA(N), arg_BB(N), arg_CC(N), arg_DD(N))\n+  call use_device_ptr_sub(arg_AA, arg_BB, arg_CC, arg_DD, arg_EE, arg_FF, AptrA, BptrB, N)\n+  deallocate(arg_AA, arg_BB)\n+\n+  AptrA => null()\n+  BptrB => null()\n+  allocate(arg2_AA(N), arg2_BB(N), arg2_CC(N), arg2_DD(N))\n+  call use_device_ptr_sub2(arg2_AA, arg2_BB, arg2_CC, arg2_DD, arg2_EE, arg2_FF, AptrA, BptrB, N)\n+  deallocate(arg2_AA, arg2_BB)\n+end program omp_device_ptr"}]}