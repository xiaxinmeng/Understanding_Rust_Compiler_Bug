{"sha": "79aff5ac0d3a0862fd126b36038c553597368644", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlhZmY1YWMwZDNhMDg2MmZkMTI2YjM2MDM4YzU1MzU5NzM2ODY0NA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-01-16T22:15:53Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-01-16T22:15:53Z"}, "message": "Cleanup specs support\n\nFrom-SVN: r13502", "tree": {"sha": "bed85e5d2f5de57455f020d613a15ee43d206a8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bed85e5d2f5de57455f020d613a15ee43d206a8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79aff5ac0d3a0862fd126b36038c553597368644", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79aff5ac0d3a0862fd126b36038c553597368644", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79aff5ac0d3a0862fd126b36038c553597368644", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79aff5ac0d3a0862fd126b36038c553597368644/comments", "author": null, "committer": null, "parents": [{"sha": "1583720a6d2c09225ae999114808fa145ff8863b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1583720a6d2c09225ae999114808fa145ff8863b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1583720a6d2c09225ae999114808fa145ff8863b"}], "stats": {"total": 308, "additions": 115, "deletions": 193}, "files": [{"sha": "fcdd8995388fd174cecddc85733fc940b1ea6065", "filename": "gcc/gcc.c", "status": "modified", "additions": 115, "deletions": 193, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79aff5ac0d3a0862fd126b36038c553597368644/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79aff5ac0d3a0862fd126b36038c553597368644/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=79aff5ac0d3a0862fd126b36038c553597368644", "patch": "@@ -1,5 +1,5 @@\n /* Compiler driver program that can handle many languages.\n-   Copyright (C) 1987, 89, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 89, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -206,9 +206,9 @@ static char *spec_machine = DEFAULT_TARGET_MACHINE;\n    When -b is used, the value comes from the `specs' file.  */\n \n #ifdef CROSS_COMPILE\n-static int cross_compile = 1;\n+static char *cross_compile = \"1\";\n #else\n-static int cross_compile = 0;\n+static char *cross_compile = \"0\";\n #endif\n \n /* The number of errors that have occurred; the link phase will not be\n@@ -231,6 +231,7 @@ extern char *version_string;\n /* Forward declaration for prototypes.  */\n struct path_prefix;\n \n+static void init_spec\t\tPROTO((int));\n static void set_spec\t\tPROTO((char *, char *));\n static struct compiler *lookup_compiler PROTO((char *, int, char *));\n static char *build_search_list\tPROTO((struct path_prefix *, char *, int));\n@@ -514,10 +515,6 @@ static char *multilib_defaults;\n \n static char *multilib_defaults_raw[] = MULTILIB_DEFAULTS;\n \n-#ifdef EXTRA_SPECS\n-static struct { char *name, *spec; } extra_specs[] = { EXTRA_SPECS };\n-#endif\n-\n struct user_specs {\n   struct user_specs *next;\n   char *filename;\n@@ -1179,14 +1176,89 @@ skip_whitespace (p)\n \n struct spec_list\n {\n-  char *name;                 /* Name of the spec.  */\n-  char *spec;                 /* The spec itself.  */\n-  struct spec_list *next;     /* Next spec in linked list.  */\n+\t\t\t\t/* The following 2 fields must be first */\n+\t\t\t\t/* to allow EXTRA_SPECS to be initialized */\n+  char *name;\t\t\t/* name of the spec.  */\n+  char *ptr;\t\t\t/* available ptr if no static pointer */\n+\n+\t\t\t\t/* The following fields are not initialized */\n+\t\t\t\t/* by EXTRA_SPECS */\n+  char **ptr_spec;\t\t/* pointer to the spec itself.  */\n+  struct spec_list *next;\t/* Next spec in linked list.  */\n+  int name_len;\t\t\t/* length of the name */\n+  int alloc_p;\t\t\t/* whether string was allocated */\n };\n \n-/* List of specs that have been defined so far.  */\n+#define INIT_STATIC_SPEC(NAME,PTR) \\\n+{ NAME, NULL_PTR, PTR, (struct spec_list *)0, sizeof (NAME)-1, 0 }\n+\n+/* List of statically defined specs */\n+static struct spec_list static_specs[] = {\n+  INIT_STATIC_SPEC (\"asm\",\t\t\t&asm_spec),\n+  INIT_STATIC_SPEC (\"asm_final\",\t\t&asm_final_spec),\n+  INIT_STATIC_SPEC (\"cpp\",\t\t\t&cpp_spec),\n+  INIT_STATIC_SPEC (\"cc1\",\t\t\t&cc1_spec),\n+  INIT_STATIC_SPEC (\"cc1plus\",\t\t\t&cc1plus_spec),\n+  INIT_STATIC_SPEC (\"endfile\",\t\t\t&endfile_spec),\n+  INIT_STATIC_SPEC (\"link\",\t\t\t&link_spec),\n+  INIT_STATIC_SPEC (\"lib\",\t\t\t&lib_spec),\n+  INIT_STATIC_SPEC (\"libgcc\",\t\t\t&libgcc_spec),\n+  INIT_STATIC_SPEC (\"startfile\",\t\t&startfile_spec),\n+  INIT_STATIC_SPEC (\"switches_need_spaces\",\t&switches_need_spaces),\n+  INIT_STATIC_SPEC (\"signed_char\",\t\t&signed_char_spec),\n+  INIT_STATIC_SPEC (\"predefines\",\t\t&cpp_predefines),\n+  INIT_STATIC_SPEC (\"cross_compile\",\t\t&cross_compile),\n+  INIT_STATIC_SPEC (\"version\",\t\t\t&compiler_version),\n+  INIT_STATIC_SPEC (\"multilib\",\t\t\t&multilib_select),\n+  INIT_STATIC_SPEC (\"multilib_defaults\",\t&multilib_defaults),\n+  INIT_STATIC_SPEC (\"multilib_extra\",\t\t&multilib_extra),\n+  INIT_STATIC_SPEC (\"multilib_matches\",\t\t&multilib_matches),\n+};\n+\n+#ifdef EXTRA_SPECS\t\t/* additional specs needed */\n+static struct spec_list extra_specs[] = { EXTRA_SPECS };\n+#endif\n+\n+/* List of dynamically allocates specs that have been defined so far.  */\n+\n+static struct spec_list *specs = (struct spec_list *)0;\n+\n+\f\n+/* Initialize the specs lookup routines.  */\n+\n+static void\n+init_spec (use_extra_p)\n+     int use_extra_p;\n+{\n+  struct spec_list *next = (struct spec_list *)0;\n+  struct spec_list *sl   = (struct spec_list *)0;\n+  int i;\n+\n+  if (specs)\n+    return;\t\t\t/* already initialized */\n+\n+#ifdef EXTRA_SPECS\n+  if (use_extra_p)\n+    for (i = (sizeof (extra_specs) / sizeof (extra_specs[0])) - 1; i >= 0; i--)\n+      {\n+\tsl = &extra_specs[i];\n+\tsl->next = next;\n+\tsl->name_len = strlen (sl->name);\n+\tsl->ptr_spec = &sl->ptr;\n+\tnext = sl;\n+      }\n+#endif\n+\n+  for (i = (sizeof (static_specs) / sizeof (static_specs[0])) - 1; i >= 0; i--)\n+    {\n+      sl = &static_specs[i];\n+      sl->next = next;\n+      next = sl;\n+    }\n+\n+  specs = sl;\n+}\n \n-static struct spec_list *specs = (struct spec_list *) 0;\n \f\n /* Change the value of spec NAME to SPEC.  If SPEC is empty, then the spec is\n    removed; If the spec starts with a + then SPEC is added to the end of the\n@@ -1199,84 +1271,39 @@ set_spec (name, spec)\n {\n   struct spec_list *sl;\n   char *old_spec;\n+  int name_len = strlen (name);\n+  int i;\n+\n+  /* See if the\n \n   /* See if the spec already exists */\n   for (sl = specs; sl; sl = sl->next)\n-    if (strcmp (sl->name, name) == 0)\n+    if (name_len == sl->name_len && !strcmp (sl->name, name))\n       break;\n \n   if (!sl)\n     {\n       /* Not found - make it */\n       sl = (struct spec_list *) xmalloc (sizeof (struct spec_list));\n       sl->name = save_string (name, strlen (name));\n-      sl->spec = save_string (\"\", 0);\n+      sl->name_len = name_len;\n+      sl->ptr_spec = &sl->ptr;\n+      sl->alloc_p = 0;\n+      *(sl->ptr_spec) = \"\";\n       sl->next = specs;\n       specs = sl;\n     }\n \n-  old_spec = sl->spec;\n-  if (name && spec[0] == '+' && isspace (spec[1]))\n-    sl->spec = concat (old_spec, spec + 1, NULL_PTR);\n-  else\n-    sl->spec = save_string (spec, strlen (spec));\n-\n-  if (! strcmp (name, \"asm\"))\n-    asm_spec = sl->spec;\n-  else if (! strcmp (name, \"asm_final\"))\n-    asm_final_spec = sl->spec;\n-  else if (! strcmp (name, \"cc1\"))\n-    cc1_spec = sl->spec;\n-  else if (! strcmp (name, \"cc1plus\"))\n-    cc1plus_spec = sl->spec;\n-  else if (! strcmp (name, \"cpp\"))\n-    cpp_spec = sl->spec;\n-  else if (! strcmp (name, \"endfile\"))\n-    endfile_spec = sl->spec;\n-  else if (! strcmp (name, \"lib\"))\n-    lib_spec = sl->spec;\n-  else if (! strcmp (name, \"libgcc\"))\n-    libgcc_spec = sl->spec;\n-  else if (! strcmp (name, \"link\"))\n-    link_spec = sl->spec;\n-  else if (! strcmp (name, \"predefines\"))\n-    cpp_predefines = sl->spec;\n-  else if (! strcmp (name, \"signed_char\"))\n-    signed_char_spec = sl->spec;\n-  else if (! strcmp (name, \"startfile\"))\n-    startfile_spec = sl->spec;\n-  else if (! strcmp (name, \"switches_need_spaces\"))\n-    switches_need_spaces = sl->spec;\n-  else if (! strcmp (name, \"cross_compile\"))\n-    cross_compile = atoi (sl->spec);\n-  else if (! strcmp (name, \"multilib\"))\n-    multilib_select = sl->spec;\n-  else if (! strcmp (name, \"multilib_matches\"))\n-    multilib_matches = sl->spec;\n-  else if (! strcmp (name, \"multilib_extra\"))\n-    multilib_extra = sl->spec;\n-  else if (! strcmp (name, \"multilib_defaults\"))\n-    multilib_defaults = sl->spec;\n-  else if (! strcmp (name, \"version\"))\n-    compiler_version = sl->spec;\n-#ifdef EXTRA_SPECS\n-  else\n-    {\n-      int i;\n-      for (i = 0; i < sizeof (extra_specs) / sizeof (extra_specs[0]); i++)\n-\t{\n-\t  if (! strcmp (name, extra_specs[i].name))\n-\t    {\n-\t      extra_specs[i].spec = sl->spec;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-#endif\n+  old_spec = *(sl->ptr_spec);\n+  *(sl->ptr_spec) = ((spec[0] == '+' && isspace (spec[1]))\n+\t\t     ? concat (old_spec, spec + 1, NULL_PTR)\n+\t\t     : save_string (spec, strlen (spec)));\n \n   /* Free the old spec */\n-  if (old_spec)\n+  if (old_spec && sl->alloc_p)\n     free (old_spec);\n+\n+  sl->alloc_p = 1;\n }\n \f\n /* Accumulate a command (program name and args), and run it.  */\n@@ -2241,7 +2268,7 @@ process_command (argc, argv)\n     }\n \n   temp = getenv (\"LIBRARY_PATH\");\n-  if (temp && ! cross_compile)\n+  if (temp && *cross_compile != '0')\n     {\n       char *startp, *endp;\n       char *nstore = (char *) alloca (strlen (temp) + 3);\n@@ -2273,7 +2300,7 @@ process_command (argc, argv)\n \n   /* Use LPATH like LIBRARY_PATH (for the CMU build program).  */\n   temp = getenv (\"LPATH\");\n-  if (temp && ! cross_compile)\n+  if (temp && *cross_compile != '0')\n     {\n       char *startp, *endp;\n       char *nstore = (char *) alloca (strlen (temp) + 3);\n@@ -2319,34 +2346,10 @@ process_command (argc, argv)\n     {\n       if (! strcmp (argv[i], \"-dumpspecs\"))\n \t{\n-\t  printf (\"*asm:\\n%s\\n\\n\", asm_spec);\n-\t  printf (\"*asm_final:\\n%s\\n\\n\", asm_final_spec);\n-\t  printf (\"*cpp:\\n%s\\n\\n\", cpp_spec);\n-\t  printf (\"*cc1:\\n%s\\n\\n\", cc1_spec);\n-\t  printf (\"*cc1plus:\\n%s\\n\\n\", cc1plus_spec);\n-\t  printf (\"*endfile:\\n%s\\n\\n\", endfile_spec);\n-\t  printf (\"*link:\\n%s\\n\\n\", link_spec);\n-\t  printf (\"*lib:\\n%s\\n\\n\", lib_spec);\n-\t  printf (\"*libgcc:\\n%s\\n\\n\", libgcc_spec);\n-\t  printf (\"*startfile:\\n%s\\n\\n\", startfile_spec);\n-\t  printf (\"*switches_need_spaces:\\n%s\\n\\n\", switches_need_spaces);\n-\t  printf (\"*signed_char:\\n%s\\n\\n\", signed_char_spec);\n-\t  printf (\"*predefines:\\n%s\\n\\n\", cpp_predefines);\n-\t  printf (\"*cross_compile:\\n%d\\n\\n\", cross_compile);\n-\t  printf (\"*version:\\n%s\\n\\n\", compiler_version);\n-\t  printf (\"*multilib:\\n%s\\n\\n\", multilib_select);\n-\t  printf (\"*multilib_defaults:\\n%s\\n\\n\", multilib_defaults);\n-\t  printf (\"*multilib_extra:\\n%s\\n\\n\", multilib_extra);\n-\t  printf (\"*multilib_matches:\\n%s\\n\\n\", multilib_matches);\n-\n-#ifdef EXTRA_SPECS\n-\t  {\n-\t    int j;\n-\t    for (j = 0; j < sizeof (extra_specs) / sizeof (extra_specs[0]); j++)\n-\t      printf (\"*%s:\\n%s\\n\\n\", extra_specs[j].name,\n-\t\t      (extra_specs[j].spec) ? extra_specs[j].spec : \"\");\n-\t  }\n-#endif\n+\t  struct spec_list *sl;\n+\t  init_spec (TRUE);\n+\t  for (sl = specs; sl; sl = sl->next)\n+\t    printf (\"*%s:\\n%s\\n\\n\", sl->name, *(sl->ptr_spec));\n \t  exit (0);\n \t}\n       else if (! strcmp (argv[i], \"-dumpversion\"))\n@@ -3613,9 +3616,9 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \n \t      /* See if it's in the list */\n \t      for (len = p - name, sl = specs; sl; sl = sl->next)\n-\t\tif (strncmp (sl->name, name, len) == 0 && !sl->name[len])\n+\t\tif (sl->name_len == len && !strncmp (sl->name, name, len))\n \t\t  {\n-\t\t    name = sl->spec;\n+\t\t    name = *(sl->ptr_spec);\n \t\t    break;\n \t\t  }\n \n@@ -4242,16 +4245,12 @@ main (argc, argv)\n   specs_file = find_a_file (&startfile_prefixes, \"specs\", R_OK);\n   /* Read the specs file unless it is a default one.  */\n   if (specs_file != 0 && strcmp (specs_file, \"specs\"))\n-    read_specs (specs_file);\n-\n-#ifdef EXTRA_SPECS\n-  else\n     {\n-      int k;\n-      for (k = 0; k < sizeof (extra_specs) / sizeof (extra_specs[0]); k++)\n-\tset_spec (extra_specs[k].name, extra_specs[k].spec);\n+      init_spec (TRUE);\n+      read_specs (specs_file);\n     }\n-#endif\n+  else\n+    init_spec (FALSE);\n \n   /* Process any user specified specs in the order given on the command\n      line.  */\n@@ -4265,7 +4264,7 @@ main (argc, argv)\n   /* The fact that these are done here, after reading the specs file,\n      means that it cannot be found in these directories.\n      But that's okay.  It should never be there anyway.  */\n-  if (!cross_compile)\n+  if (*cross_compile != '0')\n     {\n #ifdef MD_EXEC_PREFIX\n       add_prefix (&exec_prefixes, md_exec_prefix, 0, 0, NULL_PTR);\n@@ -4854,10 +4853,10 @@ validate_all_switches ()\n \t}\n     }\n \n-  /* look through the linked list of extra specs read from the specs file */\n+  /* look through the linked list of specs read from the specs file */\n   for (spec = specs; spec ; spec = spec->next)\n     {\n-      p = spec->spec;\n+      p = *(spec->ptr_spec);\n       while (c = *p++)\n \tif (c == '%' && *p == '{')\n \t  /* We have a switch spec.  */\n@@ -4869,83 +4868,6 @@ validate_all_switches ()\n     if (c == '%' && *p == '{')\n       /* We have a switch spec.  */\n       validate_switches (p + 1);\n-\n-  /* Now notice switches mentioned in the machine-specific specs.  */\n-\n-  p = asm_spec;\n-  while (c = *p++)\n-    if (c == '%' && *p == '{')\n-      /* We have a switch spec.  */\n-      validate_switches (p + 1);\n-\n-  p = asm_final_spec;\n-  while (c = *p++)\n-    if (c == '%' && *p == '{')\n-      /* We have a switch spec.  */\n-      validate_switches (p + 1);\n-\n-  p = cpp_spec;\n-  while (c = *p++)\n-    if (c == '%' && *p == '{')\n-      /* We have a switch spec.  */\n-      validate_switches (p + 1);\n-\n-  p = signed_char_spec;\n-  while (c = *p++)\n-    if (c == '%' && *p == '{')\n-      /* We have a switch spec.  */\n-      validate_switches (p + 1);\n-\n-  p = cc1_spec;\n-  while (c = *p++)\n-    if (c == '%' && *p == '{')\n-      /* We have a switch spec.  */\n-      validate_switches (p + 1);\n-\n-  p = cc1plus_spec;\n-  while (c = *p++)\n-    if (c == '%' && *p == '{')\n-      /* We have a switch spec.  */\n-      validate_switches (p + 1);\n-\n-  p = link_spec;\n-  while (c = *p++)\n-    if (c == '%' && *p == '{')\n-      /* We have a switch spec.  */\n-      validate_switches (p + 1);\n-\n-  p = lib_spec;\n-  while (c = *p++)\n-    if (c == '%' && *p == '{')\n-      /* We have a switch spec.  */\n-      validate_switches (p + 1);\n-\n-  p = libgcc_spec;\n-  while (c = *p++)\n-    if (c == '%' && *p == '{')\n-      /* We have a switch spec.  */\n-      validate_switches (p + 1);\n-\n-  p = startfile_spec;\n-  while (c = *p++)\n-    if (c == '%' && *p == '{')\n-      /* We have a switch spec.  */\n-      validate_switches (p + 1);\n-\n-#ifdef EXTRA_SPECS\n-  {\n-    int i;\n-    for (i = 0; i < sizeof (extra_specs) / sizeof (extra_specs[0]); i++)\n-      {\n-\tp = extra_specs[i].spec;\n-\twhile (c = *p++)\n-\t  if (c == '%' && *p == '{')\n-\t    /* We have a switch spec.  */\n-\t    validate_switches (p + 1);\n-      }\n-  }\n-#endif\n-\n }\n \n /* Look at the switch-name that comes after START"}]}