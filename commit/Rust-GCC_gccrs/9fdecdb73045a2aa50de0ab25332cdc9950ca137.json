{"sha": "9fdecdb73045a2aa50de0ab25332cdc9950ca137", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZkZWNkYjczMDQ1YTJhYTUwZGUwYWIyNTMzMmNkYzk5NTBjYTEzNw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-04-09T23:45:02Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-04-09T23:45:02Z"}, "message": "Initial revision\n\nFrom-SVN: r4072", "tree": {"sha": "7bbbc4bf9882c59845a9c08521aafd4a94eac38f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bbbc4bf9882c59845a9c08521aafd4a94eac38f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fdecdb73045a2aa50de0ab25332cdc9950ca137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fdecdb73045a2aa50de0ab25332cdc9950ca137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fdecdb73045a2aa50de0ab25332cdc9950ca137", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fdecdb73045a2aa50de0ab25332cdc9950ca137/comments", "author": null, "committer": null, "parents": [{"sha": "7aed76fda8ca23e0e325c31f06b5407004757210", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aed76fda8ca23e0e325c31f06b5407004757210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aed76fda8ca23e0e325c31f06b5407004757210"}], "stats": {"total": 855, "additions": 855, "deletions": 0}, "files": [{"sha": "4d95cd29499448152fa2b103e4178acb131c73af", "filename": "gcc/config/i386/next.h", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fi386%2Fnext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fi386%2Fnext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnext.h?ref=9fdecdb73045a2aa50de0ab25332cdc9950ca137", "patch": "@@ -0,0 +1,191 @@\n+/* Target definitions for GNU compiler for Intel x86 CPU running NeXTSTEP\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"i386/i386.h\"\n+#include \"i386/bsd.h\"\n+#include \"nextstep.h\"\n+\n+/* By default, target has a 80387, with IEEE FP.  */\n+\n+#undef\tTARGET_DEFAULT\n+#define TARGET_DEFAULT  (1|0100)\n+\n+/* Implicit library calls should use memcpy, not bcopy, etc.  */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* Machines that use the AT&T assembler syntax\n+   also return floating point values in an FP register.\n+   Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+#undef\tVALUE_REGNO\n+#define VALUE_REGNO(MODE) \\\n+  (((MODE)==SFmode || (MODE)==DFmode) ? FIRST_FLOAT_REG : 0)\n+\n+/* 1 if N is a possible register number for a function value. */\n+\n+#undef\tFUNCTION_VALUE_REGNO_P\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N)== FIRST_FLOAT_REG)\n+\n+#ifdef REAL_VALUE_TO_TARGET_DOUBLE\n+#undef\tASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    long hex[2];\t\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_DOUBLE (VALUE, hex);\t\t\t\t\\\n+    fprintf (FILE, \"\\t.long 0x%x\\n\\t.long 0x%x\\n\", hex[0], hex[1]);\t\\\n+  } while (0)\n+#endif\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#ifdef REAL_VALUE_TO_TARGET_SINGLE\n+#undef\tASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    long hex;\t\t\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_SINGLE (VALUE, hex);\t\t\t\t\\\n+    fprintf (FILE, \"\\t.long 0x%x\\n\", hex);\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+/* A C statement or statements which output an assembler instruction\n+   opcode to the stdio stream STREAM.  The macro-operand PTR is a\n+   variable of type `char *' which points to the opcode name in its\n+   \"internal\" form--the form that is written in the machine description.\n+\n+   GAS version 1.38.1 doesn't understand the `repz' opcode mnemonic.\n+   So use `repe' instead.  */\n+\n+#undef\tASM_OUTPUT_OPCODE\n+#define ASM_OUTPUT_OPCODE(STREAM, PTR)\t\\\n+{\t\t\t\t\t\t\t\\\n+  if ((PTR)[0] == 'r'\t\t\t\t\t\\\n+      && (PTR)[1] == 'e'\t\t\t\t\\\n+      && (PTR)[2] == 'p')\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if ((PTR)[3] == 'z')\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  fprintf (STREAM, \"repe\");\t\t\t\\\n+\t  (PTR) += 4;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      else if ((PTR)[3] == 'n' && (PTR)[4] == 'z')\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  fprintf (STREAM, \"repne\");\t\t\t\\\n+\t  (PTR) += 5;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+/* Define macro used to output shift-double opcodes when the shift\n+   count is in %cl.  Some assemblers require %cl as an argument;\n+   some don't.\n+\n+   GAS requires the %cl argument, so override unx386.h. */\n+\n+#undef\tAS3_SHIFT_DOUBLE\n+#define AS3_SHIFT_DOUBLE(a,b,c,d) AS3 (a,b,c,d)\n+\n+/* Print opcodes the way that GAS expects them. */\n+#define GAS_MNEMONICS 1\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#undef\tCPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Di386 -DNeXT -Dunix -D__MACH__ -D__LITTLE_ENDIAN__ -D__ARCHITECTURE__=\\\"i386\\\"\"\n+\n+/* This accounts for the return pc and saved fp on the i386. */\n+\n+#define OBJC_FORWARDING_STACK_OFFSET 8\n+#define OBJC_FORWARDING_MIN_OFFSET 8\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#undef\tASM_APP_ON\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#undef\tASM_APP_OFF\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+#undef\tASM_OUTPUT_REG_PUSH\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tpushl %se%s\\n\", \"%\", reg_names[REGNO])\n+\n+#undef\tASM_OUTPUT_REG_POP\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tpopl %se%s\\n\", \"%\", reg_names[REGNO])\n+\n+/* This is being overridden because the default i386 configuration\n+   generates calls to \"_mcount\".  NeXT system libraries all use\n+   \"mcount\".  */\n+\n+#undef\tFUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\t\\\n+               LPREFIX, (LABELNO));\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tcall *mcount@GOT(%%ebx)\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t  \t\\\n+      fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", LPREFIX, (LABELNO));\t\\\n+      fprintf (FILE, \"\\tcall mcount\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* BEGIN Calling Convention CHANGES */\n+\n+/* These changes violate the Intel/Unix ABI.  Specifically, they\n+   change the way that space for a block return value is passed to a\n+   function.  The ABI says that the pointer is passed on the stack.\n+   We change to pass the pointer in %ebx.  This makes the NeXT\n+   Objective-C forwarding mechanism possible to implement on an i386.  */\n+\n+/* Do NOT pass address of structure values on the stack.  */\n+\n+#undef\tSTRUCT_VALUE_INCOMING\n+#undef\tSTRUCT_VALUE\n+\n+/* Pass them in %ebx.  */\n+\n+#undef\tSTRUCT_VALUE_REGNUM\n+#define STRUCT_VALUE_REGNUM 3\n+\n+/* Because we are passing the pointer in a register, we don't need to\n+   rely on the callee to pop it.  */\n+\n+#undef\tRETURN_POPS_ARGS\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) \t\t\t\t\\\n+  (TREE_CODE (FUNTYPE) == IDENTIFIER_NODE\t\t\t\\\n+   ? 0\t\t\t\t\t\t\t\t\\\n+   : (TARGET_RTD\t\t\t\t\t\t\\\n+      && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n+          || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n+              == void_type_node))) ? (SIZE) : 0)\n+\n+/* END Calling Convention CHANGES */"}, {"sha": "7dbe1808a261fdcd85f69a4edca1c567c86e2ebf", "filename": "gcc/config/i386/t-next", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fi386%2Ft-next", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fi386%2Ft-next", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-next?ref=9fdecdb73045a2aa50de0ab25332cdc9950ca137", "patch": "@@ -0,0 +1,5 @@\n+# libgcc1.c is not needed, since the standard library has these functions.\n+LIBGCC1=\n+\n+# Specify other dirs of system header files to be fixed.\n+OTHER_FIXINCLUDES_DIRS= /LocalDeveloper/Headers"}, {"sha": "81d2f3f68a2a979efd0924dfb8509d7c867c78f8", "filename": "gcc/config/i386/x-next", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fi386%2Fx-next", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fi386%2Fx-next", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx-next?ref=9fdecdb73045a2aa50de0ab25332cdc9950ca137", "patch": "@@ -0,0 +1,8 @@\n+# Make assignments for compiling on NeXT with their compiler version.\n+CC=cc -traditional-cpp\n+OLDCC=cc -traditional-cpp\n+\n+libgcc2.a: stdarg.h\n+\n+stdarg.h:\n+\tcp $(srcdir)/gstdarg.h ./stdarg.h"}, {"sha": "bf903281a0dc6f72cce42abe10f5d47fc3c0464b", "filename": "gcc/config/i386/xm-next.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fi386%2Fxm-next.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fi386%2Fxm-next.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxm-next.h?ref=9fdecdb73045a2aa50de0ab25332cdc9950ca137", "patch": "@@ -0,0 +1,5 @@\n+#include \"i386/xm-i386.h\"\n+\n+/* malloc does better with chunks the size of a page.  */ \n+\n+#define OBSTACK_CHUNK_SIZE (getpagesize ())"}, {"sha": "e339b8d49812a874661863978a516aa75bd47f20", "filename": "gcc/config/nextstep.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fnextstep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fnextstep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep.c?ref=9fdecdb73045a2aa50de0ab25332cdc9950ca137", "patch": "@@ -0,0 +1,83 @@\n+/* Functions for generic NeXT as target machine for GNU C compiler.\n+   Copyright (C) 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Make everything that used to go in the text section really go there.  */\n+\n+int flag_no_mach_text_sections = 0;\n+\n+#define OPT_STRCMP(opt) (!strncmp (opt, p, sizeof (opt)-1))\n+\n+/* 1 if handle_pragma has been called yet.  */\n+\n+static int pragma_initialized;\n+\n+/* Initial setting of `optimize'.  */\n+\n+static int initial_optimize_flag;\n+\n+extern char *get_directive_line ();\n+\n+/* Called from check_newline via the macro HANDLE_PRAGMA.\n+   FINPUT is the source file input stream.  */\n+\n+void\n+handle_pragma (finput, get_line_function)\n+     FILE *finput;\n+     char *(*get_line_function) ();\n+{\n+  register char *p = (*get_line_function) (finput);\n+\n+  /* Record initial setting of optimize flag, so we can restore it.  */\n+  if (!pragma_initialized)\n+    {\n+      pragma_initialized = 1;\n+      initial_optimize_flag = optimize;\n+    }\n+\n+  if (OPT_STRCMP (\"CC_OPT_ON\"))\n+    {\n+      optimize = 1, obey_regdecls = 0;\n+      warning (\"optimization turned on\");\n+    }\n+  else if (OPT_STRCMP (\"CC_OPT_OFF\"))\n+    {\n+      optimize = 0, obey_regdecls = 1;\n+      warning (\"optimization turned off\");\n+    }\n+  else if (OPT_STRCMP (\"CC_OPT_RESTORE\"))\n+    {\n+      extern int initial_optimize_flag;\n+\n+      if (optimize != initial_optimize_flag)\n+\t{\n+\t  if (initial_optimize_flag)\n+\t    obey_regdecls = 0;\n+\t  else\n+\t    obey_regdecls = 1;\n+\t  optimize = initial_optimize_flag;\n+\t}\n+      warning (\"optimization level restored\");\n+    }\n+  else if (OPT_STRCMP (\"CC_WRITABLE_STRINGS\"))\n+    flag_writable_strings = 1;\n+  else if (OPT_STRCMP (\"CC_NON_WRITABLE_STRINGS\"))\n+    flag_writable_strings = 0;\n+  else if (OPT_STRCMP (\"CC_NO_MACH_TEXT_SECTIONS\"))\n+    flag_no_mach_text_sections = 1;\n+}"}, {"sha": "0e299192d5d43b85fcd50573338253cd2ac8b641", "filename": "gcc/config/nextstep.h", "status": "added", "additions": 563, "deletions": 0, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fnextstep.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fdecdb73045a2aa50de0ab25332cdc9950ca137/gcc%2Fconfig%2Fnextstep.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep.h?ref=9fdecdb73045a2aa50de0ab25332cdc9950ca137", "patch": "@@ -0,0 +1,563 @@\n+/* next.h -- operating system specific defines to be used when\n+   targeting GCC for NeXTSTEP.\n+   Copyright (C) 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Use new NeXT include file search path.\n+   In a cross compiler with NeXT as target, don't expect\n+   the host to use Next's directory scheme.  */\n+\n+#ifndef CROSS_COMPILE\n+#undef\tINCLUDE_DEFAULTS\n+#define INCLUDE_DEFAULTS\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    { GPLUSPLUS_INCLUDE_DIR, 1},\t\t\t\\\n+    { GCC_INCLUDE_DIR, 0},\t\t\t\t\\\n+    { LOCAL_INCLUDE_DIR, 0},\t\t\t\t\\\n+    { \"/NextDeveloper/Headers\", 0},\t\t\t\\\n+    { \"/NextDeveloper/Headers/ansi\", 0},\t\t\\\n+    { \"/NextDeveloper/Headers/bsd\", 0},\t\t\t\\\n+    { \"/LocalDeveloper/Headers\", 0},\t\t\t\\\n+    { \"/LocalDeveloper/Headers/ansi\", 0},\t\t\\\n+    { \"/LocalDeveloper/Headers/bsd\", 0},\t\t\\\n+    { \"/NextDeveloper/2.0CompatibleHeaders\", 0},\t\\\n+    { STANDARD_INCLUDE_DIR, 0},\t\t\t\t\\\n+    { 0, 0}\t\t\t\t\t\t\\\n+  }\n+#endif /* CROSS_COMPILE */\n+\n+/* Search for compiler tools in /lib.  */\n+\n+#undef\tSTANDARD_EXEC_PREFIX\n+#define STANDARD_EXEC_PREFIX \"/lib/\"\n+\n+#undef\tEXTRA_FORMAT_FUNCTIONS\n+#define EXTRA_FORMAT_FUNCTIONS \\\n+      \"NXPrintf\",\tFALSE,\t2,\tFALSE,\t\\\n+      \"NXScanf\",\tTRUE,\t2,\tFALSE,\t\\\n+      \"NXVPrintf\",\tFALSE,\t2,\tTRUE,\t\\\n+      \"NXVScanf\",\tTRUE,\t2,\tTRUE,\t\\\n+      \"DPSPrintf\",\tFALSE,\t2,\tFALSE,\t\\\n+      \"bsd_sprintf\",\tFALSE,\t2,\tFALSE,\t\\\n+      \"bsd_vsprintf\",\tFALSE,\t2,\tTRUE,\n+\n+/* Use NeXT's special calling convention for sending an Objc message.  */\n+\n+#define NEXT_OBJC_RUNTIME\n+\n+/* NeXT-private compiler modifications */\n+\n+#define NeXT_OBJC\n+\n+/* We have atexit.  */\n+\n+#define HAVE_ATEXIT\n+\n+/* Enable recent gcc to compile under the old gcc in Next release 1.0.  */\n+\n+#define __inline inline\n+\n+/* wchar_t is unsigned short */\n+\n+#undef\tWCHAR_TYPE\n+#define WCHAR_TYPE \"short unsigned int\"\n+#undef\tWCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE (BITS_PER_WORD / 2)\n+\n+/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n+   we want to retain compatibility with older gcc versions.  */\n+\n+#undef\tDEFAULT_PCC_STRUCT_RETURN\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* These compiler options take n arguments.  */\n+\n+#undef\tWORD_SWITCH_TAKES_ARG\n+#define WORD_SWITCH_TAKES_ARG(STR)\t \t\\\n+  (!strcmp (STR, \"Ttext\") ? 1 :\t\t\t\\\n+   !strcmp (STR, \"Tdata\") ? 1 :\t\t\t\\\n+   !strcmp (STR, \"Tbss\") ? 1 :\t\t\t\\\n+   !strcmp (STR, \"include\") ? 1 :\t\t\\\n+   !strcmp (STR, \"imacros\") ? 1 :\t\t\\\n+   !strcmp (STR, \"segalign\") ? 1 :\t\t\\\n+   !strcmp (STR, \"seg1addr\") ? 1 :\t\t\\\n+   !strcmp (STR, \"segaddr\") ? 2 :\t\t\\\n+   !strcmp (STR, \"sectobjectsymbols\") ? 2 :\t\\\n+   !strcmp (STR, \"segprot\") ? 3 :\t\t\\\n+   !strcmp (STR, \"sectcreate\") ? 3 :\t\t\\\n+   !strcmp (STR, \"sectalign\") ? 3 :\t\t\\\n+   !strcmp (STR, \"segcreate\") ? 3 :\t\t\\\n+   !strcmp (STR, \"sectorder\") ? 3 :\t\t\\\n+   !strcmp (STR, \"aux-info\") ? 1 :\t\t\\\n+   !strcmp (STR, \"siff-mask\") ? 1 :\t\t\\\n+   !strcmp (STR, \"siff-filter\") ? 1 :\t\t\\\n+   !strcmp (STR, \"siff-warning\") ? 1 :\t\t\\\n+   !strcmp (STR, \"arch\") ? 1 :\t\t\t\\\n+   !strcmp (STR, \"pagezero_size\") ? 1 :\t\t\\\n+   0)\n+\n+#undef\tWORD_SWITCH\n+#define WORD_SWITCH(STR)\t\t\t\\\n+  (WORD_SWITCH_TAKES_ARG (STR)\t\t\t\\\n+   || !strcmp (STR, \"bsd\")\t\t\t\\\n+   || !strcmp (STR, \"object\")\t\t\t\\\n+   || !strcmp (STR, \"ObjC\")\t\t\t\\\n+   || !strcmp (STR, \"all_load\"))\n+\n+/* Machine dependent ccp options.  */\n+\n+#undef\tCPP_SPEC\n+#define CPP_SPEC \"%{!traditional: -D__STDC__}            \\\n+                  %{posixstrict:-D_POSIX_SOURCE}         \\\n+                  %{!posixstrict:%{bsd:-D__STRICT_BSD__} \\\n+                  %{posix:-D_POSIX_SOURCE}               \\\n+                  %{!ansi:-D_NEXT_SOURCE}}               \\\n+                  %{MD:-MD %M} %{MMD:-MMD %M}\"\n+\n+/* Machine dependent ld options.  */\n+\n+#undef\tLINK_SPEC\n+#define LINK_SPEC \"%{Z} %{M} \\\n+%{execute*} %{preload*} %{fvmlib*} \\\n+%{segalign*} %{seg1addr*} %{segaddr*} %{segprot*} \\\n+%{pagezero_size*} \\\n+%{seglinkedit*} %{noseglinkedit*} \\\n+%{sectcreate*} %{sectalign*} %{sectobjectsymbols}\\\n+%{segcreate*} %{Mach*} %{whyload} %{w} \\\n+%{sectorder*} %{whatsloaded} %{ObjC} %{all_load} %{object}\"\n+\n+/* Machine dependent libraries.  */\n+\n+#undef\tLIB_SPEC\n+#define LIB_SPEC \"%{!posix*:-lsys_s} %{posix*:-lposix}\"\n+\n+/* We specify crt0.o as -lcrt0.o so that ld will search the library path. */\n+\n+#undef\tSTARTFILE_SPEC\n+#define STARTFILE_SPEC  \\\n+    \"%{!posix*:%{pg:-lgcrt0.o}%{!pg: \\\n+     %{p:%e-p profiling is no longer supported.  Use -pg instead.} \\\n+     %{!p:-lcrt0.o}}}\\\n+     %{posix*:%{pg:-lgposixcrt0.o}%{!pg: \\\n+     %{p:%e-p profiling is no longer supported.  Use -pg instead.} \\\n+     %{!p:-lposixcrt0.o}}}\"\n+\n+/* Why not? */\n+\n+#undef\tDOLLARS_IN_IDENTIFIERS\n+#define DOLLARS_IN_IDENTIFIERS 2\n+\n+/* Allow #sscs (but don't do anything). */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* We use Dbx symbol format.  */\n+\n+#undef\tSDB_DEBUGGING_INFO\n+#undef\tXCOFF_DEBUGGING_INFO\n+#define DBX_DEBUGGING_INFO\n+\n+/* This saves a fair amount of space. */\n+\n+#undef\tDBX_CONTIN_LENGTH\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* These screw up NeXT's gdb at the moment, so don't use them. */\n+\n+#undef\tDBX_OUTPUT_MAIN_SOURCE_DIRECTORY\n+#define DBX_OUTPUT_MAIN_SOURCE_DIRECTORY(FILE, FILENAME)\n+\n+/* These come from bsd386.h, but are specific to sequent, so make sure\n+   they don't bite us.  */\n+\n+#undef\tDBX_NO_XREFS\n+#undef\tDBX_CONTIN_LENGTH\n+\n+/* gdb needs a null N_SO at the end of each file for scattered loading. */\n+\n+#undef\tDBX_OUTPUT_MAIN_SOURCE_FILE_END\n+#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\t\t\\\n+  fprintf (FILE,\t\t\t\t\t\t\t\\\n+\t   \"\\t.text\\n\\t.stabs \\\"%s\\\",%d,0,0,Letext\\nLetext:\\n\",\t\t\\\n+\t   \"\" , N_SO)\n+\n+/* Don't use .gcc_compiled symbols to communicate with GDB;\n+   They interfere with numerically sorted symbol lists. */\n+\n+#undef\tASM_IDENTIFY_GCC\n+#define ASM_IDENTIFY_GCC(asm_out_file)\n+#undef\tINIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP\n+#undef\tINVOKE__main\n+\n+#undef\tASM_OUTPUT_CONSTRUCTOR\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)                       \\\n+  do { constructor_section ();                                  \\\n+       ASM_OUTPUT_ALIGN (FILE, 1);                              \\\n+       fprintf (FILE, \"\\t.long \");                              \\\n+       assemble_name (FILE, NAME);                              \\\n+       fprintf (FILE, \"\\n\");                                    \\\n+       fprintf (FILE, \".reference .constructors_used\\n\");       \\\n+      } while (0)\n+\n+#undef\tASM_OUTPUT_DESTRUCTOR\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)                        \\\n+  do { destructor_section ();                                   \\\n+       ASM_OUTPUT_ALIGN (FILE, 1);                              \\\n+       fprintf (FILE, \"\\t.long \");                              \\\n+       assemble_name (FILE, NAME);                              \\\n+       fprintf (FILE, \"\\n\");                                    \\\n+       fprintf (FILE, \".reference .destructors_used\\n\");        \\\n+      } while (0)\n+\n+#undef\tASM_FILE_START\n+#define ASM_FILE_START(FILE) \\\n+  fprintf (FILE, \"\\t.file\\t\\\"%s\\\"\\n\", dump_base_name);\n+\n+#undef\tASM_FILE_END\n+#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    extern char *language_string;\t\t\t\t\\\n+    if (strcmp (language_string, \"GNU C++\") == 0)\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tconstructor_section ();\t\t\t\t\t\\\n+\tdestructor_section ();\t\t\t\t\t\\\n+\tASM_OUTPUT_ALIGN (FILE, 1);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* How to parse #pragma's */\n+\n+#undef\tHANDLE_PRAGMA\n+#define HANDLE_PRAGMA(finput) handle_pragma (finput, &get_directive_line)\n+\n+/* Give methods pretty symbol names on NeXT. */\n+\n+#undef\tOBJC_GEN_METHOD_LABEL\n+#define OBJC_GEN_METHOD_LABEL(BUF,IS_INST,CLASS_NAME,CAT_NAME,SEL_NAME,NUM) \\\n+  do { if (CAT_NAME)\t\t\t\t\t\t\t\\\n+\t sprintf (BUF, \"%c[%s(%s) %s]\", (IS_INST) ? '-' : '+',\t\t\\\n+\t\t  (CLASS_NAME), (CAT_NAME), (SEL_NAME));\t\t\\\n+       else\t\t\t\t\t\t\t\t\\\n+\t sprintf (BUF, \"%c[%s %s]\", (IS_INST) ? '-' : '+',\t\t\\\n+\t\t  (CLASS_NAME), (SEL_NAME));\t\t\t\t\\\n+     } while (0)\n+\n+/* Wrap new method names in quotes so the assembler doesn't gag.\n+   Make Objective-C internal symbols local.  */\n+\n+#undef\tASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  do { if (NAME[0] == '+' || NAME[0] == '-') fprintf (FILE, \"\\\"%s\\\"\", NAME); \\\n+       else if (!strncmp (NAME, \"_OBJC_\", 6)) fprintf (FILE, \"L%s\", NAME);   \\\n+       else if (!strncmp (NAME, \".objc_class_name_\", 17))\t\t\\\n+\t fprintf (FILE, \"%s\", NAME);\t\t\t\t\t\\\n+       else fprintf (FILE, \"_%s\", NAME); } while (0)\n+\n+#undef\tALIGN_ASM_OP\n+#define ALIGN_ASM_OP\t\t\".align\"\n+\n+#undef\tASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t%s %d\\n\", ALIGN_ASM_OP, (LOG))\n+\n+/* Ensure correct alignment of bss data.  */\n+\n+#undef\tASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN) \\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fprintf ((FILE), \",%u,%u\\n\", (SIZE), floor_log2 ((ALIGN) / BITS_PER_UNIT)))\n+\n+/* Output #ident as a .ident.  */\n+\n+#undef\tASM_OUTPUT_IDENT\n+#define ASM_OUTPUT_IDENT(FILE, NAME) fprintf (FILE, \"\\t.ident \\\"%s\\\"\\n\", NAME);\n+\n+/* The maximum alignment which the object file format can support.\n+   For NeXT's Mach-O format, this is 2^15.  */\n+\n+#undef\tMAX_OFILE_ALIGNMENT\n+#define MAX_OFILE_ALIGNMENT 0x8000\n+\n+/* Create new Mach-O sections. */\n+\n+#undef\tSECTION_FUNCTION\n+#define SECTION_FUNCTION(FUNCTION, SECTION, DIRECTIVE, WAS_TEXT, OBJC)\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+FUNCTION ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern void text_section ();\t\t\t\t\t \t\\\n+  extern void objc_section_init ();\t\t\t\t\t\\\n+  extern int flag_no_mach_text_sections;\t\t\t\t\\\n+  \t\t\t\t\t\t\t\t\t\\\n+  if (WAS_TEXT && flag_no_mach_text_sections)       \t\t\t\\\n+    text_section ();\t\t\t\t\t\t\t\\\n+  else if (in_section != SECTION)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (OBJC)\t\t\t\t\t\t\t\t\\\n+\tobjc_section_init ();\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DIRECTIVE);\t\t\t\\\n+      in_section = SECTION;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\n+#undef\tEXTRA_SECTIONS\n+#define EXTRA_SECTIONS\t\t\t\t\t\\\n+  in_const, in_cstring, in_literal4, in_literal8,\t\\\n+  in_constructor, in_destructor,\t\t\t\\\n+  in_objc_class, in_objc_meta_class, in_objc_category,\t\\\n+  in_objc_class_vars, in_objc_instance_vars,\t\t\\\n+  in_objc_cls_meth, in_objc_inst_meth,\t\t\t\\\n+  in_objc_cat_cls_meth, in_objc_cat_inst_meth,\t\t\\\n+  in_objc_selector_refs,\t\t\t\t\\\n+  in_objc_symbols, in_objc_module_info,\t\t\t\\\n+  in_objc_protocol, in_objc_string_object,\t\t\\\n+  in_objc_class_names, in_objc_meth_var_names,\t\t\\\n+  in_objc_meth_var_types, in_objc_cls_refs\n+\n+#undef\tEXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\\\n+SECTION_FUNCTION (const_section,\t\t\\\n+\t\t  in_const,\t\t\t\\\n+\t\t  \".const\", 1, 0)\t\t\\\n+SECTION_FUNCTION (cstring_section,\t\t\\\n+\t\t  in_cstring,\t\t\t\\\n+\t\t  \".cstring\", 1, 0)\t\t\\\n+SECTION_FUNCTION (literal4_section,\t\t\\\n+\t\t  in_literal4,\t\t\t\\\n+\t\t  \".literal4\", 1, 0)\t\t\\\n+SECTION_FUNCTION (literal8_section,\t\t\\\n+\t\t  in_literal8,\t\t\t\\\n+\t\t  \".literal8\", 1, 0)\t\t\\\n+SECTION_FUNCTION (constructor_section,\t\t\\\n+\t\t  in_constructor,\t\t\\\n+\t\t  \".constructor\", 0, 0)\t\t\\\n+SECTION_FUNCTION (destructor_section,\t\t\\\n+\t\t  in_destructor,\t\t\\\n+\t\t  \".destructor\", 0, 0)\t\t\\\n+SECTION_FUNCTION (objc_class_section,\t\t\\\n+\t\t  in_objc_class,\t\t\\\n+\t\t  \".objc_class\", 0, 1)\t\t\\\n+SECTION_FUNCTION (objc_meta_class_section,\t\\\n+\t\t  in_objc_meta_class,\t\t\\\n+\t\t  \".objc_meta_class\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_category_section,\t\\\n+\t\t  in_objc_category,\t\t\\\n+\t\t\".objc_category\", 0, 1)\t\t\\\n+SECTION_FUNCTION (objc_class_vars_section,\t\\\n+\t\t  in_objc_class_vars,\t\t\\\n+\t\t  \".objc_class_vars\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_instance_vars_section,\t\\\n+\t\t  in_objc_instance_vars,\t\\\n+\t\t  \".objc_instance_vars\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_cls_meth_section,\t\\\n+\t\t  in_objc_cls_meth,\t\t\\\n+\t\t  \".objc_cls_meth\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_inst_meth_section,\t\\\n+\t\t  in_objc_inst_meth,\t\t\\\n+\t\t  \".objc_inst_meth\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_cat_cls_meth_section,\t\\\n+\t\t  in_objc_cat_cls_meth,\t\t\\\n+\t\t  \".objc_cat_cls_meth\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_cat_inst_meth_section,\t\\\n+\t\t  in_objc_cat_inst_meth,\t\\\n+\t\t  \".objc_cat_inst_meth\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_selector_refs_section,\t\\\n+\t\t  in_objc_selector_refs,\t\\\n+\t\t  \".objc_message_refs\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_symbols_section,\t\t\\\n+\t\t  in_objc_symbols,\t\t\\\n+\t\t  \".objc_symbols\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_module_info_section,\t\\\n+\t\t  in_objc_module_info,\t\t\\\n+\t\t  \".objc_module_info\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_protocol_section,\t\\\n+\t\t  in_objc_protocol,\t\t\\\n+\t\t  \".objc_protocol\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_string_object_section,\t\\\n+\t\t  in_objc_string_object,\t\\\n+\t\t  \".objc_string_object\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_class_names_section,\t\\\n+\t\tin_objc_class_names,\t\t\\\n+\t\t\".objc_class_names\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_meth_var_names_section,\t\\\n+\t\tin_objc_meth_var_names,\t\t\\\n+\t\t\".objc_meth_var_names\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_meth_var_types_section,\t\\\n+\t\tin_objc_meth_var_types,\t\t\\\n+\t\t\".objc_meth_var_types\", 0, 1)\t\\\n+SECTION_FUNCTION (objc_cls_refs_section,\t\\\n+\t\tin_objc_cls_refs,\t\t\\\n+\t\t\".objc_cls_refs\", 0, 1)\t\t\\\n+\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\\\n+objc_section_init ()\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  static int been_here = 0;\t\t\t\\\n+\t\t\t\t\t\t\\\n+  if (been_here == 0)\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      been_here = 1;\t\t\t\t\\\n+      objc_class_section ();\t\t\t\\\n+      objc_meta_class_section ();\t\t\\\n+      objc_cat_cls_meth_section ();\t\t\\\n+      objc_cat_inst_meth_section ();\t\t\\\n+      objc_cls_meth_section ();\t\t\t\\\n+      objc_inst_meth_section ();\t\t\\\n+      objc_selector_refs_section ();\t\t\\\n+      objc_symbols_section ();\t\t\t\\\n+      objc_category_section ();\t\t\t\\\n+      objc_protocol_section ();\t\t\t\\\n+      objc_class_vars_section ();\t\t\\\n+      objc_instance_vars_section ();\t\t\\\n+      objc_module_info_section ();\t\t\\\n+      objc_string_object_section ();\t\t\\\n+      objc_class_names_section ();\t\t\\\n+      objc_meth_var_names_section ();\t\t\\\n+      objc_meth_var_types_section ();\t\t\\\n+      objc_cls_refs_section ();\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+}\n+\n+#undef\tREADONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION const_section\n+\n+#undef\tSELECT_SECTION\n+#define SELECT_SECTION(exp,reloc)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (TREE_CODE (exp) == STRING_CST)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (flag_writable_strings)\t\t\t\t\\\n+\t    data_section ();\t\t\t\t\t\\\n+\t  else if (TREE_STRING_LENGTH (exp) !=\t\t\t\\\n+\t\t   strlen (TREE_STRING_POINTER (exp)) + 1)\t\\\n+\t    readonly_data_section ();\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    cstring_section ();\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else if (TREE_CODE (exp) == INTEGER_CST\t\t\t\\\n+\t       || TREE_CODE (exp) == REAL_CST)\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+\t  tree size = TYPE_SIZE (TREE_TYPE (exp));\t\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  if (TREE_CODE (size) == INTEGER_CST &&\t\t\\\n+\t      TREE_INT_CST_LOW (size) == 4 &&\t\t\t\\\n+\t      TREE_INT_CST_HIGH (size) == 0)\t\t\t\\\n+\t    literal4_section ();\t\t\t\t\\\n+\t  else if (TREE_CODE (size) == INTEGER_CST &&\t\t\\\n+\t      TREE_INT_CST_LOW (size) == 8 &&\t\t\t\\\n+\t      TREE_INT_CST_HIGH (size) == 0)\t\t\t\\\n+\t    literal8_section ();\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    readonly_data_section ();\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else if (TREE_CODE (exp) == CONSTRUCTOR\t\t\t\t\\\n+\t       && TREE_TYPE (exp)\t\t\t\t\t\\\n+\t       && TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\t\t\\\n+\t       && TYPE_NAME (TREE_TYPE (exp))\t\t\t\t\\\n+\t       && TREE_CODE (TYPE_NAME (TREE_TYPE (exp))) == IDENTIFIER_NODE \\\n+\t       && IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (exp))))\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (!strcmp (IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (exp))), \\\n+\t\t\t\"NXConstantString\"))\t\t\t\t\\\n+\t  objc_string_object_section ();\t\t\t\t\\\n+\telse if ((TREE_READONLY (exp) || TREE_CONSTANT (exp))\t\t\\\n+\t\t&& !TREE_SIDE_EFFECTS (exp))\t\t\t\t\\\n+\t  readonly_data_section ();\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  data_section ();\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+      else if (TREE_CODE (exp) == VAR_DECL &&\t\t\t\t\\\n+\t       DECL_NAME (exp) &&\t\t\t\t\t\\\n+\t       TREE_CODE (DECL_NAME (exp)) == IDENTIFIER_NODE &&\t\\\n+\t       IDENTIFIER_POINTER (DECL_NAME (exp)) &&\t\t\t\\\n+\t       !strncmp (IDENTIFIER_POINTER (DECL_NAME (exp)), \"_OBJC_\", 6)) \\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  const char *name = IDENTIFIER_POINTER (DECL_NAME (exp));\t\\\n+\t  \t\t\t\t\t\t\t\t\\\n+\t  if (!strncmp (name, \"_OBJC_CLASS_METHODS_\", 20))\t\t\\\n+\t    objc_cls_meth_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_INSTANCE_METHODS_\", 23))\t\\\n+\t    objc_inst_meth_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CATEGORY_CLASS_METHODS_\", 20)) \\\n+\t    objc_cat_cls_meth_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CATEGORY_INSTANCE_METHODS_\", 23)) \\\n+\t    objc_cat_inst_meth_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_VARIABLES_\", 22))\t\\\n+\t    objc_class_vars_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_INSTANCE_VARIABLES_\", 25))\t\\\n+\t    objc_instance_vars_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_PROTOCOLS_\", 22))\t\\\n+\t    objc_cat_cls_meth_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_NAME_\", 17))\t\t\\\n+\t    objc_class_names_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_METH_VAR_NAME_\", 20))\t\t\\\n+\t    objc_meth_var_names_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_METH_VAR_TYPE_\", 20))\t\t\\\n+\t    objc_meth_var_types_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_REFERENCES\", 22))\t\\\n+\t    objc_cls_refs_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CLASS_\", 12))\t\t\t\\\n+\t    objc_class_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_METACLASS_\", 16))\t\t\\\n+\t    objc_meta_class_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_CATEGORY_\", 15))\t\t\\\n+\t    objc_category_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_SELECTOR_REFERENCES\", 25))\t\\\n+\t    objc_selector_refs_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_SYMBOLS\", 13))\t\t\\\n+\t    objc_symbols_section ();\t\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_MODULES\", 13))\t\t\\\n+\t    objc_module_info_section ();\t\t\t\t\\\n+\t  else if (!strncmp (name, \"_OBJC_PROTOCOL_INSTANCE_METHODS_\", 32)) \\\n+\t    objc_cat_inst_meth_section ();                              \\\n+\t  else if (!strncmp (name, \"_OBJC_PROTOCOL_CLASS_METHODS_\", 29)) \\\n+\t    objc_cat_cls_meth_section ();                               \\\n+\t  else if (!strncmp (name, \"_OBJC_PROTOCOL_REFS_\", 20))         \\\n+\t    objc_cat_cls_meth_section ();                               \\\n+\t  else if (!strncmp (name, \"_OBJC_PROTOCOL_\", 15))              \\\n+\t    objc_protocol_section ();                                   \\\n+\t  else if ((TREE_READONLY (exp) || TREE_CONSTANT (exp))\t\t\\\n+\t\t&& !TREE_SIDE_EFFECTS (exp))     \t\t\t\\\n+\t    readonly_data_section ();                                   \\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    data_section ();\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if ((TREE_READONLY (exp) || TREE_CONSTANT (exp))\t\\\n+\t       && !TREE_SIDE_EFFECTS (exp))\t\t\t\t\\\n+\treadonly_data_section ();\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        data_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef\tSELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(mode, rtx)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_MODE_SIZE(mode) == 8)\t\t\t\t\t\\\n+\tliteral8_section();\t\t\t\t\t\t\\\n+      else if (GET_MODE_SIZE(mode) == 4)\t\t\t\t\\\n+\tliteral4_section();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)"}]}