{"sha": "7988fd364ac120730ec4fdaf48e2bbc5c1df1443", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk4OGZkMzY0YWMxMjA3MzBlYzRmZGFmNDhlMmJiYzVjMWRmMTQ0Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-09T23:45:34Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-09T23:45:34Z"}, "message": "(setup_incoming_promotions): New function.\n\n(combine_instructions): Add calls to setup_incoming_promotions.\n\nFrom-SVN: r3451", "tree": {"sha": "3062f440fa6682c2afb7fafb785f3ead7d042d92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3062f440fa6682c2afb7fafb785f3ead7d042d92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7988fd364ac120730ec4fdaf48e2bbc5c1df1443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7988fd364ac120730ec4fdaf48e2bbc5c1df1443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7988fd364ac120730ec4fdaf48e2bbc5c1df1443", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7988fd364ac120730ec4fdaf48e2bbc5c1df1443/comments", "author": null, "committer": null, "parents": [{"sha": "626043cfc3b0b25d10c80c33e3a76f7a4b9480e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/626043cfc3b0b25d10c80c33e3a76f7a4b9480e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/626043cfc3b0b25d10c80c33e3a76f7a4b9480e3"}], "stats": {"total": 31, "additions": 29, "deletions": 2}, "files": [{"sha": "ee542d059938c422cfbb9abeb33b694509e9365b", "filename": "gcc/combine.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7988fd364ac120730ec4fdaf48e2bbc5c1df1443/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7988fd364ac120730ec4fdaf48e2bbc5c1df1443/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=7988fd364ac120730ec4fdaf48e2bbc5c1df1443", "patch": "@@ -354,6 +354,7 @@ static struct undobuf undobuf;\n static int n_occurrences;\n \n static void set_nonzero_bits_and_sign_copies ();\n+static void setup_incoming_promotions ();\n static void move_deaths ();\n rtx remove_death ();\n static void record_value_for_reg ();\n@@ -458,6 +459,8 @@ combine_instructions (f, nregs)\n \n   label_tick = 1;\n \n+  setup_incoming_promotions ();\n+\n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n     {\n       INSN_CUID (insn) = ++i;\n@@ -488,6 +491,8 @@ combine_instructions (f, nregs)\n   bzero (reg_last_set_label, nregs * sizeof (short));\n   bzero (reg_last_set_invalid, nregs * sizeof (char));\n \n+  setup_incoming_promotions ();\n+\n   for (insn = f; insn; insn = next ? next : NEXT_INSN (insn))\n     {\n       next = 0;\n@@ -594,6 +599,28 @@ combine_instructions (f, nregs)\n   nonzero_sign_valid = 0;\n }\n \f\n+/* Set up any promoted values for incoming argument registers.  */\n+\n+void\n+setup_incoming_promotions ()\n+{\n+#ifdef PROMOTE_FUNCTION_ARGS\n+  int regno;\n+  rtx reg;\n+  enum machine_mode mode;\n+  int unsignedp;\n+  rtx first = get_insns ();\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (FUNCTION_ARG_REGNO_P (regno)\n+\t&& (reg = promoted_input_arg (regno, &mode, &unsignedp)) != 0)\n+      record_value_for_reg (reg, first,\n+\t\t\t    gen_rtx (unsignedp ? ZERO_EXTEND : SIGN_EXTEND,\n+\t\t\t\t     mode,\n+\t\t\t\t     gen_rtx (CLOBBER, VOIDmode, const0_rtx)));\n+#endif\n+}\n+\f\n /* Called via note_stores.  If X is a pseudo that is used in more than\n    one basic block, is narrower that HOST_BITS_PER_WIDE_INT, and is being\n    set, record what bits are known zero.  If we are clobbering X,\n@@ -8637,8 +8664,8 @@ update_table_tick (x)\n \n /* Record that REG is set to VALUE in insn INSN.  If VALUE is zero, we\n    are saying that the register is clobbered and we no longer know its\n-   value.  If INSN is zero, don't update reg_last_set; this call is normally\n-   done with VALUE also zero to invalidate the register.  */\n+   value.  If INSN is zero, don't update reg_last_set; this is only permitted\n+   with VALUE also zero and is used to invalidate the register.  */\n \n static void\n record_value_for_reg (reg, insn, value)"}]}