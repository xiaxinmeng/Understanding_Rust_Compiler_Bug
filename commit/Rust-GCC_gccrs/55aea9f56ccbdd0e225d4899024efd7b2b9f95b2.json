{"sha": "55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVhZWE5ZjU2Y2NiZGQwZTIyNWQ0ODk5MDI0ZWZkN2IyYjlmOTViMg==", "commit": {"author": {"name": "Max Ostapenko", "email": "m.ostapenko@partner.samsung.com", "date": "2015-11-23T09:07:18Z"}, "committer": {"name": "Maxim Ostapenko", "email": "chefmax@gcc.gnu.org", "date": "2015-11-23T09:07:18Z"}, "message": "libsanitizer merge from upstream r253555.\n\nlibsanitizer/\n\n2015-11-23  Maxim Ostapenko  <m.ostapenko@partner.samsung.com>\n\n\t* All source files: Merge from upstream r253555.\n\t* configure.tgt: Enable LSan on aarch64-*-linux* targets. Add new\n\tdependences for TSan for aarch64-*-linux* targets.\n\t* tsan/Makefile.am: Add new source files.\n\t* configure: Regenerate.\n\t* tsan/Makefile.in: Likewise.\n\nFrom-SVN: r230739", "tree": {"sha": "b49fa5302e995c5559c7cb481c5eb8b9d3b42c08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b49fa5302e995c5559c7cb481c5eb8b9d3b42c08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/comments", "author": null, "committer": null, "parents": [{"sha": "096b85f4b4ad0578059d4c3c6ac1c6c330abb3fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/096b85f4b4ad0578059d4c3c6ac1c6c330abb3fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/096b85f4b4ad0578059d4c3c6ac1c6c330abb3fb"}], "stats": {"total": 2487, "additions": 1709, "deletions": 778}, "files": [{"sha": "b97fc7d8344fc101b91cd0c40711c554ab992730", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -1,3 +1,12 @@\n+2015-11-23  Maxim Ostapenko  <m.ostapenko@partner.samsung.com>\n+\n+\t* All source files: Merge from upstream r253555.\n+\t* configure.tgt: Enable LSan on aarch64-*-linux* targets. Add new\n+\tdependences for TSan for aarch64-*-linux* targets.\n+\t* tsan/Makefile.am: Add new source files.\n+\t* configure: Regenerate.\n+\t* tsan/Makefile.in: Likewise.\n+\n 2015-11-09  Alan Modra  <amodra@gmail.com>\n \n \t* sanitizer_common/sanitizer_common_interceptors.inc: Update size"}, {"sha": "dfd606aa0c60a93b318cd3d4ce6d6d90c5939095", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -1,4 +1,4 @@\n-250806\n+253555\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "563b464bff1c4a3cb208f85f5b969b557d9fb705", "filename": "libsanitizer/asan/asan_flags.inc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.inc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -73,6 +73,7 @@ ASAN_FLAG(bool, check_malloc_usable_size, true,\n           \"295.*.\")\n ASAN_FLAG(bool, unmap_shadow_on_exit, false,\n           \"If set, explicitly unmaps the (huge) shadow at exit.\")\n+ASAN_FLAG(bool, protect_shadow_gap, true, \"If set, mprotect the shadow gap\")\n ASAN_FLAG(bool, print_stats, false,\n           \"Print various statistics after printing an error message or if \"\n           \"atexit=1.\")\n@@ -132,3 +133,6 @@ ASAN_FLAG(int, detect_odr_violation, 2,\n ASAN_FLAG(bool, dump_instruction_bytes, false,\n           \"If true, dump 16 bytes starting at the instruction that caused SEGV\")\n ASAN_FLAG(const char *, suppressions, \"\", \"Suppressions file name.\")\n+ASAN_FLAG(bool, halt_on_error, true,\n+          \"Crash the program after printing the first error report \"\n+          \"(WARNING: USE AT YOUR OWN RISK!)\")"}, {"sha": "356f2c028975b3b444929ef5990be54bdc9ae154", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -73,7 +73,7 @@ struct AsanInterceptorContext {\n       }                                                                 \\\n       if (!suppressed) {                                                \\\n         GET_CURRENT_PC_BP_SP;                                           \\\n-        __asan_report_error(pc, bp, sp, __bad, isWrite, __size, 0);     \\\n+        ReportGenericError(pc, bp, sp, __bad, isWrite, __size, 0, false);\\\n       }                                                                 \\\n     }                                                                   \\\n   } while (0)"}, {"sha": "079da9ca5221fa2847c1c19b152490374d2c59c8", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -165,6 +165,19 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE void __asan_loadN(uptr p, uptr size);\n   SANITIZER_INTERFACE_ATTRIBUTE void __asan_storeN(uptr p, uptr size);\n \n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_load1_noabort(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_load2_noabort(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_load4_noabort(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_load8_noabort(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_load16_noabort(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_store1_noabort(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_store2_noabort(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_store4_noabort(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_store8_noabort(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_store16_noabort(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_loadN_noabort(uptr p, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_storeN_noabort(uptr p, uptr size);\n+\n   SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_load1(uptr p, u32 exp);\n   SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_load2(uptr p, u32 exp);\n   SANITIZER_INTERFACE_ATTRIBUTE void __asan_exp_load4(uptr p, u32 exp);"}, {"sha": "20e37ffe7effd18b6e486ba519e3a130f4393665", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -31,17 +31,17 @@ extern \"C\" {\n #endif\n \n #include <dlfcn.h>  // for dladdr()\n+#include <fcntl.h>\n+#include <libkern/OSAtomic.h>\n #include <mach-o/dyld.h>\n #include <mach-o/loader.h>\n+#include <pthread.h>\n+#include <stdlib.h>  // for free()\n #include <sys/mman.h>\n #include <sys/resource.h>\n #include <sys/sysctl.h>\n #include <sys/ucontext.h>\n-#include <fcntl.h>\n-#include <pthread.h>\n-#include <stdlib.h>  // for free()\n #include <unistd.h>\n-#include <libkern/OSAtomic.h>\n \n namespace __asan {\n "}, {"sha": "33ccbf09470c31b6aca0ce27766787df2a83eab5", "filename": "libsanitizer/asan/asan_malloc_mac.cc", "status": "modified", "additions": 39, "deletions": 336, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_mac.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -13,348 +13,51 @@\n #include \"sanitizer_common/sanitizer_platform.h\"\n #if SANITIZER_MAC\n \n-#include <AvailabilityMacros.h>\n-#include <CoreFoundation/CFBase.h>\n-#include <dlfcn.h>\n-#include <malloc/malloc.h>\n-#include <sys/mman.h>\n-\n-#include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n-#include \"asan_internal.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n-#include \"sanitizer_common/sanitizer_mac.h\"\n-\n-// Similar code is used in Google Perftools,\n-// http://code.google.com/p/google-perftools.\n-\n-// ---------------------- Replacement functions ---------------- {{{1\n-using namespace __asan;  // NOLINT\n-\n-// TODO(glider): do we need both zones?\n-static malloc_zone_t *system_malloc_zone = 0;\n-static malloc_zone_t asan_zone;\n-\n-INTERCEPTOR(malloc_zone_t *, malloc_create_zone,\n-                             vm_size_t start_size, unsigned zone_flags) {\n-  ENSURE_ASAN_INITED();\n-  GET_STACK_TRACE_MALLOC;\n-  uptr page_size = GetPageSizeCached();\n-  uptr allocated_size = RoundUpTo(sizeof(asan_zone), page_size);\n-  malloc_zone_t *new_zone =\n-      (malloc_zone_t*)asan_memalign(page_size, allocated_size,\n-                                    &stack, FROM_MALLOC);\n-  internal_memcpy(new_zone, &asan_zone, sizeof(asan_zone));\n-  new_zone->zone_name = NULL;  // The name will be changed anyway.\n-  if (GetMacosVersion() >= MACOS_VERSION_LION) {\n-    // Prevent the client app from overwriting the zone contents.\n-    // Library functions that need to modify the zone will set PROT_WRITE on it.\n-    // This matches the behavior of malloc_create_zone() on OSX 10.7 and higher.\n-    mprotect(new_zone, allocated_size, PROT_READ);\n-  }\n-  return new_zone;\n-}\n-\n-INTERCEPTOR(malloc_zone_t *, malloc_default_zone, void) {\n-  ENSURE_ASAN_INITED();\n-  return &asan_zone;\n-}\n-\n-INTERCEPTOR(malloc_zone_t *, malloc_default_purgeable_zone, void) {\n-  // FIXME: ASan should support purgeable allocations.\n-  // https://code.google.com/p/address-sanitizer/issues/detail?id=139\n-  ENSURE_ASAN_INITED();\n-  return &asan_zone;\n-}\n-\n-INTERCEPTOR(void, malloc_make_purgeable, void *ptr) {\n-  // FIXME: ASan should support purgeable allocations. Ignoring them is fine\n-  // for now.\n-  ENSURE_ASAN_INITED();\n-}\n-\n-INTERCEPTOR(int, malloc_make_nonpurgeable, void *ptr) {\n-  // FIXME: ASan should support purgeable allocations. Ignoring them is fine\n-  // for now.\n-  ENSURE_ASAN_INITED();\n-  // Must return 0 if the contents were not purged since the last call to\n-  // malloc_make_purgeable().\n-  return 0;\n-}\n-\n-INTERCEPTOR(void, malloc_set_zone_name, malloc_zone_t *zone, const char *name) {\n-  ENSURE_ASAN_INITED();\n-  // Allocate |strlen(\"asan-\") + 1 + internal_strlen(name)| bytes.\n-  size_t buflen = 6 + (name ? internal_strlen(name) : 0);\n-  InternalScopedString new_name(buflen);\n-  if (name && zone->introspect == asan_zone.introspect) {\n-    new_name.append(\"asan-%s\", name);\n-    name = new_name.data();\n-  }\n-\n-  // Call the system malloc's implementation for both external and our zones,\n-  // since that appropriately changes VM region protections on the zone.\n-  REAL(malloc_set_zone_name)(zone, name);\n-}\n-\n-INTERCEPTOR(void *, malloc, size_t size) {\n-  ENSURE_ASAN_INITED();\n-  GET_STACK_TRACE_MALLOC;\n-  void *res = asan_malloc(size, &stack);\n-  return res;\n-}\n \n-INTERCEPTOR(void, free, void *ptr) {\n-  ENSURE_ASAN_INITED();\n-  if (!ptr) return;\n-  GET_STACK_TRACE_FREE;\n+using namespace __asan;\n+#define COMMON_MALLOC_ZONE_NAME \"asan\"\n+#define COMMON_MALLOC_ENTER() ENSURE_ASAN_INITED()\n+#define COMMON_MALLOC_SANITIZER_INITIALIZED asan_inited\n+#define COMMON_MALLOC_FORCE_LOCK() asan_mz_force_lock()\n+#define COMMON_MALLOC_FORCE_UNLOCK() asan_mz_force_unlock()\n+#define COMMON_MALLOC_MEMALIGN(alignment, size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  void *p = asan_memalign(alignment, size, &stack, FROM_MALLOC)\n+#define COMMON_MALLOC_MALLOC(size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  void *p = asan_malloc(size, &stack)\n+#define COMMON_MALLOC_REALLOC(ptr, size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  void *p = asan_realloc(ptr, size, &stack);\n+#define COMMON_MALLOC_CALLOC(count, size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  void *p = asan_calloc(count, size, &stack);\n+#define COMMON_MALLOC_VALLOC(size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  void *p = asan_memalign(GetPageSizeCached(), size, &stack, FROM_MALLOC);\n+#define COMMON_MALLOC_FREE(ptr) \\\n+  GET_STACK_TRACE_FREE; \\\n   asan_free(ptr, &stack, FROM_MALLOC);\n-}\n-\n-INTERCEPTOR(void *, realloc, void *ptr, size_t size) {\n-  ENSURE_ASAN_INITED();\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_realloc(ptr, size, &stack);\n-}\n-\n-INTERCEPTOR(void *, calloc, size_t nmemb, size_t size) {\n-  ENSURE_ASAN_INITED();\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_calloc(nmemb, size, &stack);\n-}\n-\n-INTERCEPTOR(void *, valloc, size_t size) {\n-  ENSURE_ASAN_INITED();\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_memalign(GetPageSizeCached(), size, &stack, FROM_MALLOC);\n-}\n-\n-INTERCEPTOR(size_t, malloc_good_size, size_t size) {\n-  ENSURE_ASAN_INITED();\n-  return asan_zone.introspect->good_size(&asan_zone, size);\n-}\n-\n-INTERCEPTOR(int, posix_memalign, void **memptr, size_t alignment, size_t size) {\n-  ENSURE_ASAN_INITED();\n-  CHECK(memptr);\n-  GET_STACK_TRACE_MALLOC;\n-  void *result = asan_memalign(alignment, size, &stack, FROM_MALLOC);\n-  if (result) {\n-    *memptr = result;\n-    return 0;\n-  }\n-  return -1;\n-}\n-\n-namespace {\n-\n-// TODO(glider): the __asan_mz_* functions should be united with the Linux\n-// wrappers, as they are basically copied from there.\n-extern \"C\"\n-SANITIZER_INTERFACE_ATTRIBUTE\n-size_t __asan_mz_size(malloc_zone_t* zone, const void* ptr) {\n-  return asan_mz_size(ptr);\n-}\n-\n-extern \"C\"\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void *__asan_mz_malloc(malloc_zone_t *zone, uptr size) {\n-  if (UNLIKELY(!asan_inited)) {\n-    CHECK(system_malloc_zone);\n-    return malloc_zone_malloc(system_malloc_zone, size);\n-  }\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_malloc(size, &stack);\n-}\n-\n-extern \"C\"\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void *__asan_mz_calloc(malloc_zone_t *zone, size_t nmemb, size_t size) {\n-  if (UNLIKELY(!asan_inited)) {\n-    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n-    const size_t kCallocPoolSize = 1024;\n-    static uptr calloc_memory_for_dlsym[kCallocPoolSize];\n-    static size_t allocated;\n-    size_t size_in_words = ((nmemb * size) + kWordSize - 1) / kWordSize;\n-    void *mem = (void*)&calloc_memory_for_dlsym[allocated];\n-    allocated += size_in_words;\n-    CHECK(allocated < kCallocPoolSize);\n-    return mem;\n-  }\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_calloc(nmemb, size, &stack);\n-}\n-\n-extern \"C\"\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void *__asan_mz_valloc(malloc_zone_t *zone, size_t size) {\n-  if (UNLIKELY(!asan_inited)) {\n-    CHECK(system_malloc_zone);\n-    return malloc_zone_valloc(system_malloc_zone, size);\n-  }\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_memalign(GetPageSizeCached(), size, &stack, FROM_MALLOC);\n-}\n-\n-#define GET_ZONE_FOR_PTR(ptr) \\\n-  malloc_zone_t *zone_ptr = malloc_zone_from_ptr(ptr); \\\n-  const char *zone_name = (zone_ptr == 0) ? 0 : zone_ptr->zone_name\n-\n-void ALWAYS_INLINE free_common(void *context, void *ptr) {\n-  if (!ptr) return;\n-  GET_STACK_TRACE_FREE;\n-  // FIXME: need to retire this flag.\n-  if (!flags()->mac_ignore_invalid_free) {\n-    asan_free(ptr, &stack, FROM_MALLOC);\n-  } else {\n-    GET_ZONE_FOR_PTR(ptr);\n-    WarnMacFreeUnallocated((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n-    return;\n-  }\n-}\n-\n-// TODO(glider): the allocation callbacks need to be refactored.\n-extern \"C\"\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void __asan_mz_free(malloc_zone_t *zone, void *ptr) {\n-  free_common(zone, ptr);\n-}\n-\n-extern \"C\"\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void *__asan_mz_realloc(malloc_zone_t *zone, void *ptr, size_t size) {\n-  if (!ptr) {\n-    GET_STACK_TRACE_MALLOC;\n-    return asan_malloc(size, &stack);\n-  } else {\n-    if (asan_mz_size(ptr)) {\n-      GET_STACK_TRACE_MALLOC;\n-      return asan_realloc(ptr, size, &stack);\n-    } else {\n-      // We can't recover from reallocating an unknown address, because\n-      // this would require reading at most |size| bytes from\n-      // potentially unaccessible memory.\n-      GET_STACK_TRACE_FREE;\n-      GET_ZONE_FOR_PTR(ptr);\n-      ReportMacMzReallocUnknown((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n-    }\n-  }\n-}\n-\n-extern \"C\"\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void __asan_mz_destroy(malloc_zone_t* zone) {\n-  // A no-op -- we will not be destroyed!\n-  Report(\"__asan_mz_destroy() called -- ignoring\\n\");\n-}\n-\n-extern \"C\"\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void *__asan_mz_memalign(malloc_zone_t *zone, size_t align, size_t size) {\n-  if (UNLIKELY(!asan_inited)) {\n-    CHECK(system_malloc_zone);\n-    return malloc_zone_memalign(system_malloc_zone, align, size);\n-  }\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_memalign(align, size, &stack, FROM_MALLOC);\n-}\n-\n-// This function is currently unused, and we build with -Werror.\n-#if 0\n-void __asan_mz_free_definite_size(\n-    malloc_zone_t* zone, void *ptr, size_t size) {\n-  // TODO(glider): check that |size| is valid.\n-  UNIMPLEMENTED();\n-}\n-#endif\n-\n-kern_return_t mi_enumerator(task_t task, void *,\n-                            unsigned type_mask, vm_address_t zone_address,\n-                            memory_reader_t reader,\n-                            vm_range_recorder_t recorder) {\n-  // Should enumerate all the pointers we have.  Seems like a lot of work.\n-  return KERN_FAILURE;\n-}\n-\n-size_t mi_good_size(malloc_zone_t *zone, size_t size) {\n-  // I think it's always safe to return size, but we maybe could do better.\n-  return size;\n-}\n-\n-boolean_t mi_check(malloc_zone_t *zone) {\n-  UNIMPLEMENTED();\n-}\n-\n-void mi_print(malloc_zone_t *zone, boolean_t verbose) {\n-  UNIMPLEMENTED();\n-}\n-\n-void mi_log(malloc_zone_t *zone, void *address) {\n-  // I don't think we support anything like this\n-}\n-\n-void mi_force_lock(malloc_zone_t *zone) {\n-  asan_mz_force_lock();\n-}\n-\n-void mi_force_unlock(malloc_zone_t *zone) {\n-  asan_mz_force_unlock();\n-}\n-\n-void mi_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {\n-  AsanMallocStats malloc_stats;\n-  FillMallocStatistics(&malloc_stats);\n-  CHECK(sizeof(malloc_statistics_t) == sizeof(AsanMallocStats));\n+#define COMMON_MALLOC_SIZE(ptr) \\\n+  uptr size = asan_mz_size(ptr);\n+#define COMMON_MALLOC_FILL_STATS(zone, stats) \\\n+  AsanMallocStats malloc_stats; \\\n+  FillMallocStatistics(&malloc_stats); \\\n+  CHECK(sizeof(malloc_statistics_t) == sizeof(AsanMallocStats)); \\\n   internal_memcpy(stats, &malloc_stats, sizeof(malloc_statistics_t));\n-}\n-\n-boolean_t mi_zone_locked(malloc_zone_t *zone) {\n-  // UNIMPLEMENTED();\n-  return false;\n-}\n-\n-}  // unnamed namespace\n-\n-namespace __asan {\n+#define COMMON_MALLOC_REPORT_UNKNOWN_REALLOC(ptr, zone_ptr, zone_name) \\\n+  GET_STACK_TRACE_FREE; \\\n+  ReportMacMzReallocUnknown((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n+#define COMMON_MALLOC_IGNORE_INVALID_FREE flags()->mac_ignore_invalid_free\n+#define COMMON_MALLOC_REPORT_FREE_UNALLOCATED(ptr, zone_ptr, zone_name) \\\n+  GET_STACK_TRACE_FREE; \\\n+  WarnMacFreeUnallocated((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n+#define COMMON_MALLOC_NAMESPACE __asan\n \n-void ReplaceSystemMalloc() {\n-  static malloc_introspection_t asan_introspection;\n-  // Ok to use internal_memset, these places are not performance-critical.\n-  internal_memset(&asan_introspection, 0, sizeof(asan_introspection));\n+#include \"sanitizer_common/sanitizer_malloc_mac.inc\"\n \n-  asan_introspection.enumerator = &mi_enumerator;\n-  asan_introspection.good_size = &mi_good_size;\n-  asan_introspection.check = &mi_check;\n-  asan_introspection.print = &mi_print;\n-  asan_introspection.log = &mi_log;\n-  asan_introspection.force_lock = &mi_force_lock;\n-  asan_introspection.force_unlock = &mi_force_unlock;\n-  asan_introspection.statistics = &mi_statistics;\n-  asan_introspection.zone_locked = &mi_zone_locked;\n-\n-  internal_memset(&asan_zone, 0, sizeof(malloc_zone_t));\n-\n-  // Use version 6 for OSX >= 10.6.\n-  asan_zone.version = 6;\n-  asan_zone.zone_name = \"asan\";\n-  asan_zone.size = &__asan_mz_size;\n-  asan_zone.malloc = &__asan_mz_malloc;\n-  asan_zone.calloc = &__asan_mz_calloc;\n-  asan_zone.valloc = &__asan_mz_valloc;\n-  asan_zone.free = &__asan_mz_free;\n-  asan_zone.realloc = &__asan_mz_realloc;\n-  asan_zone.destroy = &__asan_mz_destroy;\n-  asan_zone.batch_malloc = 0;\n-  asan_zone.batch_free = 0;\n-  asan_zone.free_definite_size = 0;\n-  asan_zone.memalign = &__asan_mz_memalign;\n-  asan_zone.introspect = &asan_introspection;\n-\n-  // Register the ASan zone.\n-  malloc_zone_register(&asan_zone);\n-}\n-}  // namespace __asan\n-\n-#endif  // SANITIZER_MAC\n+#endif"}, {"sha": "b584cfa2f3c4cd4c9aaf2c745a3b3d16dddee302", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -116,11 +116,7 @@ static const u64 kIosShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kIosShadowOffset64 = 0x130000000;\n static const u64 kIosSimShadowOffset32 = 1ULL << 30;\n static const u64 kIosSimShadowOffset64 = kDefaultShadowOffset64;\n-#if SANITIZER_AARCH64_VMA == 39\n static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n-#elif SANITIZER_AARCH64_VMA == 42\n-static const u64 kAArch64_ShadowOffset64 = 1ULL << 39;\n-#endif\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;"}, {"sha": "39f74879b38f758af64ea19a8de1b893c8b92aa0", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -373,10 +373,10 @@ void __sanitizer_annotate_contiguous_container(const void *beg_p,\n   }\n }\n \n-int __sanitizer_verify_contiguous_container(const void *beg_p,\n-                                            const void *mid_p,\n-                                            const void *end_p) {\n-  if (!flags()->detect_container_overflow) return 1;\n+const void *__sanitizer_contiguous_container_find_bad_address(\n+    const void *beg_p, const void *mid_p, const void *end_p) {\n+  if (!flags()->detect_container_overflow)\n+    return nullptr;\n   uptr beg = reinterpret_cast<uptr>(beg_p);\n   uptr end = reinterpret_cast<uptr>(end_p);\n   uptr mid = reinterpret_cast<uptr>(mid_p);\n@@ -393,17 +393,24 @@ int __sanitizer_verify_contiguous_container(const void *beg_p,\n   uptr r3_end = end;\n   for (uptr i = r1_beg; i < r1_end; i++)\n     if (AddressIsPoisoned(i))\n-      return 0;\n+      return reinterpret_cast<const void *>(i);\n   for (uptr i = r2_beg; i < mid; i++)\n     if (AddressIsPoisoned(i))\n-      return 0;\n+      return reinterpret_cast<const void *>(i);\n   for (uptr i = mid; i < r2_end; i++)\n     if (!AddressIsPoisoned(i))\n-      return 0;\n+      return reinterpret_cast<const void *>(i);\n   for (uptr i = r3_beg; i < r3_end; i++)\n     if (!AddressIsPoisoned(i))\n-      return 0;\n-  return 1;\n+      return reinterpret_cast<const void *>(i);\n+  return nullptr;\n+}\n+\n+int __sanitizer_verify_contiguous_container(const void *beg_p,\n+                                            const void *mid_p,\n+                                            const void *end_p) {\n+  return __sanitizer_contiguous_container_find_bad_address(beg_p, mid_p,\n+                                                           end_p) == nullptr;\n }\n \n extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE"}, {"sha": "7f7eaf515e7cfe0e4a21ed121a0b748427b55201", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 92, "deletions": 41, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -620,41 +620,57 @@ void DescribeThread(AsanThreadContext *context) {\n // immediately after printing error report.\n class ScopedInErrorReport {\n  public:\n-  explicit ScopedInErrorReport(ReportData *report = nullptr) {\n-    static atomic_uint32_t num_calls;\n-    static u32 reporting_thread_tid;\n-    if (atomic_fetch_add(&num_calls, 1, memory_order_relaxed) != 0) {\n+  explicit ScopedInErrorReport(ReportData *report = nullptr,\n+                               bool fatal = false) {\n+    halt_on_error_ = fatal || flags()->halt_on_error;\n+\n+    if (lock_.TryLock()) {\n+      StartReporting(report);\n+      return;\n+    }\n+\n+    // ASan found two bugs in different threads simultaneously.\n+\n+    u32 current_tid = GetCurrentTidOrInvalid();\n+    if (reporting_thread_tid_ == current_tid ||\n+        reporting_thread_tid_ == kInvalidTid) {\n+      // This is either asynch signal or nested error during error reporting.\n+      // Fail simple to avoid deadlocks in Report().\n+\n+      // Can't use Report() here because of potential deadlocks\n+      // in nested signal handlers.\n+      const char msg[] = \"AddressSanitizer: nested bug in the same thread, \"\n+                         \"aborting.\\n\";\n+      WriteToFile(kStderrFd, msg, sizeof(msg));\n+\n+      internal__exit(common_flags()->exitcode);\n+    }\n+\n+    if (halt_on_error_) {\n       // Do not print more than one report, otherwise they will mix up.\n       // Error reporting functions shouldn't return at this situation, as\n-      // they are defined as no-return.\n+      // they are effectively no-returns.\n+\n       Report(\"AddressSanitizer: while reporting a bug found another one. \"\n-                 \"Ignoring.\\n\");\n-      u32 current_tid = GetCurrentTidOrInvalid();\n-      if (current_tid != reporting_thread_tid) {\n-        // ASan found two bugs in different threads simultaneously. Sleep\n-        // long enough to make sure that the thread which started to print\n-        // an error report will finish doing it.\n-        SleepForSeconds(Max(100, flags()->sleep_before_dying + 1));\n-      }\n+             \"Ignoring.\\n\");\n+\n+      // Sleep long enough to make sure that the thread which started\n+      // to print an error report will finish doing it.\n+      SleepForSeconds(Max(100, flags()->sleep_before_dying + 1));\n+\n       // If we're still not dead for some reason, use raw _exit() instead of\n       // Die() to bypass any additional checks.\n       internal__exit(common_flags()->exitcode);\n+    } else {\n+      // The other thread will eventually finish reporting\n+      // so it's safe to wait\n+      lock_.Lock();\n     }\n-    if (report) report_data = *report;\n-    report_happened = true;\n-    ASAN_ON_ERROR();\n-    // Make sure the registry and sanitizer report mutexes are locked while\n-    // we're printing an error report.\n-    // We can lock them only here to avoid self-deadlock in case of\n-    // recursive reports.\n-    asanThreadRegistry().Lock();\n-    CommonSanitizerReportMutex.Lock();\n-    reporting_thread_tid = GetCurrentTidOrInvalid();\n-    Printf(\"====================================================\"\n-           \"=============\\n\");\n+\n+    StartReporting(report);\n   }\n-  // Destructor is NORETURN, as functions that report errors are.\n-  NORETURN ~ScopedInErrorReport() {\n+\n+  ~ScopedInErrorReport() {\n     // Make sure the current thread is announced.\n     DescribeThread(GetCurrentThread());\n     // We may want to grab this lock again when printing stats.\n@@ -665,11 +681,39 @@ class ScopedInErrorReport {\n     if (error_report_callback) {\n       error_report_callback(error_message_buffer);\n     }\n-    Report(\"ABORTING\\n\");\n-    Die();\n+    CommonSanitizerReportMutex.Unlock();\n+    reporting_thread_tid_ = kInvalidTid;\n+    lock_.Unlock();\n+    if (halt_on_error_) {\n+      Report(\"ABORTING\\n\");\n+      Die();\n+    }\n+  }\n+\n+ private:\n+  void StartReporting(ReportData *report) {\n+    if (report) report_data = *report;\n+    report_happened = true;\n+    ASAN_ON_ERROR();\n+    // Make sure the registry and sanitizer report mutexes are locked while\n+    // we're printing an error report.\n+    // We can lock them only here to avoid self-deadlock in case of\n+    // recursive reports.\n+    asanThreadRegistry().Lock();\n+    CommonSanitizerReportMutex.Lock();\n+    reporting_thread_tid_ = GetCurrentTidOrInvalid();\n+    Printf(\"====================================================\"\n+           \"=============\\n\");\n   }\n+\n+  static StaticSpinMutex lock_;\n+  static u32 reporting_thread_tid_;\n+  bool halt_on_error_;\n };\n \n+StaticSpinMutex ScopedInErrorReport::lock_;\n+u32 ScopedInErrorReport::reporting_thread_tid_;\n+\n void ReportStackOverflow(const SignalContext &sig) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n@@ -686,7 +730,7 @@ void ReportStackOverflow(const SignalContext &sig) {\n }\n \n void ReportDeadlySignal(const char *description, const SignalContext &sig) {\n-  ScopedInErrorReport in_report;\n+  ScopedInErrorReport in_report(/*report*/nullptr, /*fatal*/true);\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n   Report(\n@@ -743,7 +787,7 @@ void ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n   stack.Print();\n   DescribeHeapAddress(addr, 1);\n   ReportErrorSummary(\"new-delete-type-mismatch\", &stack);\n-  Report(\"HINT: if you don't care about these warnings you may set \"\n+  Report(\"HINT: if you don't care about these errors you may set \"\n          \"ASAN_OPTIONS=new_delete_type_mismatch=0\\n\");\n }\n \n@@ -783,7 +827,7 @@ void ReportAllocTypeMismatch(uptr addr, BufferedStackTrace *free_stack,\n   stack.Print();\n   DescribeHeapAddress(addr, 1);\n   ReportErrorSummary(\"alloc-dealloc-mismatch\", &stack);\n-  Report(\"HINT: if you don't care about these warnings you may set \"\n+  Report(\"HINT: if you don't care about these errors you may set \"\n          \"ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n\");\n }\n \n@@ -885,7 +929,7 @@ void ReportODRViolation(const __asan_global *g1, u32 stack_id1,\n     Printf(\"  [2]:\\n\");\n     StackDepotGet(stack_id2).Print();\n   }\n-  Report(\"HINT: if you don't care about these warnings you may set \"\n+  Report(\"HINT: if you don't care about these errors you may set \"\n          \"ASAN_OPTIONS=detect_odr_violation=0\\n\");\n   InternalScopedString error_msg(256);\n   error_msg.append(\"odr-violation: global '%s' at %s\",\n@@ -957,13 +1001,8 @@ void ReportMacCfReallocUnknown(uptr addr, uptr zone_ptr, const char *zone_name,\n   DescribeHeapAddress(addr, 1);\n }\n \n-} // namespace __asan\n-\n-// --------------------------- Interface --------------------- {{{1\n-using namespace __asan;  // NOLINT\n-\n-void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n-                         uptr access_size, u32 exp) {\n+void ReportGenericError(uptr pc, uptr bp, uptr sp, uptr addr, bool is_write,\n+                        uptr access_size, u32 exp, bool fatal) {\n   ENABLE_FRAME_POINTER;\n \n   // Optimization experiments.\n@@ -1032,7 +1071,7 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n \n   ReportData report = { pc, sp, bp, addr, (bool)is_write, access_size,\n                         bug_descr };\n-  ScopedInErrorReport in_report(&report);\n+  ScopedInErrorReport in_report(&report, fatal);\n \n   Decorator d;\n   Printf(\"%s\", d.Warning());\n@@ -1058,6 +1097,18 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n   PrintShadowMemoryForAddress(addr);\n }\n \n+}  // namespace __asan\n+\n+// --------------------------- Interface --------------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n+                         uptr access_size, u32 exp) {\n+  ENABLE_FRAME_POINTER;\n+  bool fatal = flags()->halt_on_error;\n+  ReportGenericError(pc, bp, sp, addr, is_write, access_size, exp, fatal);\n+}\n+\n void NOINLINE __asan_set_error_report_callback(void (*callback)(const char*)) {\n   error_report_callback = callback;\n   if (callback) {"}, {"sha": "f2a181552327783261f79a6e1729232e9087ef05", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -47,45 +47,41 @@ bool DescribeAddressIfStack(uptr addr, uptr access_size);\n void DescribeThread(AsanThreadContext *context);\n \n // Different kinds of error reports.\n-void NORETURN ReportStackOverflow(const SignalContext &sig);\n-void NORETURN ReportDeadlySignal(const char* description,\n-                                 const SignalContext &sig);\n-void NORETURN ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n-                                          BufferedStackTrace *free_stack);\n-void NORETURN ReportDoubleFree(uptr addr, BufferedStackTrace *free_stack);\n-void NORETURN ReportFreeNotMalloced(uptr addr, BufferedStackTrace *free_stack);\n-void NORETURN ReportAllocTypeMismatch(uptr addr, BufferedStackTrace *free_stack,\n-                                      AllocType alloc_type,\n-                                      AllocType dealloc_type);\n-void NORETURN\n-    ReportMallocUsableSizeNotOwned(uptr addr, BufferedStackTrace *stack);\n-void NORETURN\n-    ReportSanitizerGetAllocatedSizeNotOwned(uptr addr,\n-                                            BufferedStackTrace *stack);\n-void NORETURN\n-    ReportStringFunctionMemoryRangesOverlap(const char *function,\n-                                            const char *offset1, uptr length1,\n-                                            const char *offset2, uptr length2,\n-                                            BufferedStackTrace *stack);\n-void NORETURN ReportStringFunctionSizeOverflow(uptr offset, uptr size,\n-                                               BufferedStackTrace *stack);\n-void NORETURN\n-    ReportBadParamsToAnnotateContiguousContainer(uptr beg, uptr end,\n-                                                 uptr old_mid, uptr new_mid,\n-                                                 BufferedStackTrace *stack);\n+void ReportGenericError(uptr pc, uptr bp, uptr sp, uptr addr, bool is_write,\n+                        uptr access_size, u32 exp, bool fatal);\n+void ReportStackOverflow(const SignalContext &sig);\n+void ReportDeadlySignal(const char *description, const SignalContext &sig);\n+void ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n+                                 BufferedStackTrace *free_stack);\n+void ReportDoubleFree(uptr addr, BufferedStackTrace *free_stack);\n+void ReportFreeNotMalloced(uptr addr, BufferedStackTrace *free_stack);\n+void ReportAllocTypeMismatch(uptr addr, BufferedStackTrace *free_stack,\n+                             AllocType alloc_type,\n+                             AllocType dealloc_type);\n+void ReportMallocUsableSizeNotOwned(uptr addr, BufferedStackTrace *stack);\n+void ReportSanitizerGetAllocatedSizeNotOwned(uptr addr,\n+                                             BufferedStackTrace *stack);\n+void ReportStringFunctionMemoryRangesOverlap(const char *function,\n+                                             const char *offset1, uptr length1,\n+                                             const char *offset2, uptr length2,\n+                                             BufferedStackTrace *stack);\n+void ReportStringFunctionSizeOverflow(uptr offset, uptr size,\n+                                      BufferedStackTrace *stack);\n+void ReportBadParamsToAnnotateContiguousContainer(uptr beg, uptr end,\n+                                                  uptr old_mid, uptr new_mid,\n+                                                  BufferedStackTrace *stack);\n \n-void NORETURN\n-ReportODRViolation(const __asan_global *g1, u32 stack_id1,\n-                   const __asan_global *g2, u32 stack_id2);\n+void ReportODRViolation(const __asan_global *g1, u32 stack_id1,\n+                        const __asan_global *g2, u32 stack_id2);\n \n // Mac-specific errors and warnings.\n void WarnMacFreeUnallocated(uptr addr, uptr zone_ptr, const char *zone_name,\n                             BufferedStackTrace *stack);\n-void NORETURN ReportMacMzReallocUnknown(uptr addr, uptr zone_ptr,\n-                                        const char *zone_name,\n-                                        BufferedStackTrace *stack);\n-void NORETURN ReportMacCfReallocUnknown(uptr addr, uptr zone_ptr,\n-                                        const char *zone_name,\n-                                        BufferedStackTrace *stack);\n+void ReportMacMzReallocUnknown(uptr addr, uptr zone_ptr,\n+                               const char *zone_name,\n+                               BufferedStackTrace *stack);\n+void ReportMacCfReallocUnknown(uptr addr, uptr zone_ptr,\n+                               const char *zone_name,\n+                               BufferedStackTrace *stack);\n \n }  // namespace __asan"}, {"sha": "50b02453a2b0d72af5144c4263126e68ac896150", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 56, "deletions": 23, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -111,13 +111,18 @@ static void OnLowLevelAllocate(uptr ptr, uptr size) {\n extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                             \\\n void __asan_report_ ## type ## size(uptr addr) {                    \\\n   GET_CALLER_PC_BP_SP;                                              \\\n-  __asan_report_error(pc, bp, sp, addr, is_write, size, 0);         \\\n+  ReportGenericError(pc, bp, sp, addr, is_write, size, 0, true);    \\\n }                                                                   \\\n extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                             \\\n void __asan_report_exp_ ## type ## size(uptr addr, u32 exp) {       \\\n   GET_CALLER_PC_BP_SP;                                              \\\n-  __asan_report_error(pc, bp, sp, addr, is_write, size, exp);       \\\n-}\n+  ReportGenericError(pc, bp, sp, addr, is_write, size, exp, true);  \\\n+}                                                                   \\\n+extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                             \\\n+void __asan_report_ ## type ## size ## _noabort(uptr addr) {        \\\n+  GET_CALLER_PC_BP_SP;                                              \\\n+  ReportGenericError(pc, bp, sp, addr, is_write, size, 0, false);   \\\n+}                                                                   \\\n \n ASAN_REPORT_ERROR(load, false, 1)\n ASAN_REPORT_ERROR(load, false, 2)\n@@ -130,22 +135,27 @@ ASAN_REPORT_ERROR(store, true, 4)\n ASAN_REPORT_ERROR(store, true, 8)\n ASAN_REPORT_ERROR(store, true, 16)\n \n-#define ASAN_REPORT_ERROR_N(type, is_write)                    \\\n-extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                        \\\n-void __asan_report_ ## type ## _n(uptr addr, uptr size) {      \\\n-  GET_CALLER_PC_BP_SP;                                         \\\n-  __asan_report_error(pc, bp, sp, addr, is_write, size, 0);    \\\n-}                                                              \\\n-extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                        \\\n+#define ASAN_REPORT_ERROR_N(type, is_write)                                 \\\n+extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                     \\\n+void __asan_report_ ## type ## _n(uptr addr, uptr size) {                   \\\n+  GET_CALLER_PC_BP_SP;                                                      \\\n+  ReportGenericError(pc, bp, sp, addr, is_write, size, 0, true);            \\\n+}                                                                           \\\n+extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                     \\\n void __asan_report_exp_ ## type ## _n(uptr addr, uptr size, u32 exp) {      \\\n   GET_CALLER_PC_BP_SP;                                                      \\\n-  __asan_report_error(pc, bp, sp, addr, is_write, size, exp);               \\\n-}\n+  ReportGenericError(pc, bp, sp, addr, is_write, size, exp, true);          \\\n+}                                                                           \\\n+extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                     \\\n+void __asan_report_ ## type ## _n_noabort(uptr addr, uptr size) {           \\\n+  GET_CALLER_PC_BP_SP;                                                      \\\n+  ReportGenericError(pc, bp, sp, addr, is_write, size, 0, false);           \\\n+}                                                                           \\\n \n ASAN_REPORT_ERROR_N(load, false)\n ASAN_REPORT_ERROR_N(store, true)\n \n-#define ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, exp_arg)        \\\n+#define ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, exp_arg, fatal) \\\n     uptr sp = MEM_TO_SHADOW(addr);                                             \\\n     uptr s = size <= SHADOW_GRANULARITY ? *reinterpret_cast<u8 *>(sp)          \\\n                                         : *reinterpret_cast<u16 *>(sp);        \\\n@@ -157,20 +167,25 @@ ASAN_REPORT_ERROR_N(store, true)\n           *__asan_test_only_reported_buggy_pointer = addr;                     \\\n         } else {                                                               \\\n           GET_CALLER_PC_BP_SP;                                                 \\\n-          __asan_report_error(pc, bp, sp, addr, is_write, size, exp_arg);      \\\n+          ReportGenericError(pc, bp, sp, addr, is_write, size, exp_arg,        \\\n+                              fatal);                                          \\\n         }                                                                      \\\n       }                                                                        \\\n     }\n \n #define ASAN_MEMORY_ACCESS_CALLBACK(type, is_write, size)                      \\\n   extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                      \\\n   void __asan_##type##size(uptr addr) {                                        \\\n-    ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, 0)                  \\\n+    ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, 0, true)            \\\n   }                                                                            \\\n   extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                      \\\n   void __asan_exp_##type##size(uptr addr, u32 exp) {                           \\\n-    ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, exp)                \\\n-  }\n+    ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, exp, true)          \\\n+  }                                                                            \\\n+  extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                      \\\n+  void __asan_##type##size ## _noabort(uptr addr) {                            \\\n+    ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, 0, false)           \\\n+  }                                                                            \\\n \n ASAN_MEMORY_ACCESS_CALLBACK(load, false, 1)\n ASAN_MEMORY_ACCESS_CALLBACK(load, false, 2)\n@@ -188,7 +203,7 @@ NOINLINE INTERFACE_ATTRIBUTE\n void __asan_loadN(uptr addr, uptr size) {\n   if (__asan_region_is_poisoned(addr, size)) {\n     GET_CALLER_PC_BP_SP;\n-    __asan_report_error(pc, bp, sp, addr, false, size, 0);\n+    ReportGenericError(pc, bp, sp, addr, false, size, 0, true);\n   }\n }\n \n@@ -197,7 +212,16 @@ NOINLINE INTERFACE_ATTRIBUTE\n void __asan_exp_loadN(uptr addr, uptr size, u32 exp) {\n   if (__asan_region_is_poisoned(addr, size)) {\n     GET_CALLER_PC_BP_SP;\n-    __asan_report_error(pc, bp, sp, addr, false, size, exp);\n+    ReportGenericError(pc, bp, sp, addr, false, size, exp, true);\n+  }\n+}\n+\n+extern \"C\"\n+NOINLINE INTERFACE_ATTRIBUTE\n+void __asan_loadN_noabort(uptr addr, uptr size) {\n+  if (__asan_region_is_poisoned(addr, size)) {\n+    GET_CALLER_PC_BP_SP;\n+    ReportGenericError(pc, bp, sp, addr, false, size, 0, false);\n   }\n }\n \n@@ -206,7 +230,7 @@ NOINLINE INTERFACE_ATTRIBUTE\n void __asan_storeN(uptr addr, uptr size) {\n   if (__asan_region_is_poisoned(addr, size)) {\n     GET_CALLER_PC_BP_SP;\n-    __asan_report_error(pc, bp, sp, addr, true, size, 0);\n+    ReportGenericError(pc, bp, sp, addr, true, size, 0, true);\n   }\n }\n \n@@ -215,7 +239,16 @@ NOINLINE INTERFACE_ATTRIBUTE\n void __asan_exp_storeN(uptr addr, uptr size, u32 exp) {\n   if (__asan_region_is_poisoned(addr, size)) {\n     GET_CALLER_PC_BP_SP;\n-    __asan_report_error(pc, bp, sp, addr, true, size, exp);\n+    ReportGenericError(pc, bp, sp, addr, true, size, exp, true);\n+  }\n+}\n+\n+extern \"C\"\n+NOINLINE INTERFACE_ATTRIBUTE\n+void __asan_storeN_noabort(uptr addr, uptr size) {\n+  if (__asan_region_is_poisoned(addr, size)) {\n+    GET_CALLER_PC_BP_SP;\n+    ReportGenericError(pc, bp, sp, addr, true, size, 0, false);\n   }\n }\n \n@@ -291,6 +324,8 @@ static void InitializeHighMemEnd() {\n }\n \n static void ProtectGap(uptr addr, uptr size) {\n+  if (!flags()->protect_shadow_gap)\n+    return;\n   void *res = MmapNoAccess(addr, size, \"shadow gap\");\n   if (addr == (uptr)res)\n     return;\n@@ -376,8 +411,6 @@ static void AsanInitInternal() {\n   // initialization steps look at flags().\n   InitializeFlags();\n \n-  CheckVMASize();\n-\n   AsanCheckIncompatibleRT();\n   AsanCheckDynamicRTPrereqs();\n "}, {"sha": "6c12523498af2e3b6e0bc1a809e27b4de38de7d3", "filename": "libsanitizer/asan/asan_win.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -12,6 +12,7 @@\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n #if SANITIZER_WINDOWS\n+#define WIN32_LEAN_AND_MEAN\n #include <windows.h>\n \n #include <stdlib.h>"}, {"sha": "691aaf36fd0db24c43e81b948079f5eb93948272", "filename": "libsanitizer/asan/asan_win_dll_thunk.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -255,6 +255,9 @@ INTERFACE_FUNCTION(__asan_memcpy);\n INTERFACE_FUNCTION(__asan_memset);\n INTERFACE_FUNCTION(__asan_memmove);\n \n+INTERFACE_FUNCTION(__asan_alloca_poison);\n+INTERFACE_FUNCTION(__asan_allocas_unpoison);\n+\n INTERFACE_FUNCTION(__asan_register_globals)\n INTERFACE_FUNCTION(__asan_unregister_globals)\n \n@@ -298,6 +301,7 @@ INTERFACE_FUNCTION(__asan_stack_free_10)\n \n // FIXME: we might want to have a sanitizer_win_dll_thunk?\n INTERFACE_FUNCTION(__sanitizer_annotate_contiguous_container)\n+INTERFACE_FUNCTION(__sanitizer_contiguous_container_find_bad_address)\n INTERFACE_FUNCTION(__sanitizer_cov)\n INTERFACE_FUNCTION(__sanitizer_cov_dump)\n INTERFACE_FUNCTION(__sanitizer_cov_indir_call16)\n@@ -315,6 +319,7 @@ INTERFACE_FUNCTION(__sanitizer_get_estimated_allocated_size)\n INTERFACE_FUNCTION(__sanitizer_get_free_bytes)\n INTERFACE_FUNCTION(__sanitizer_get_heap_size)\n INTERFACE_FUNCTION(__sanitizer_get_ownership)\n+INTERFACE_FUNCTION(__sanitizer_get_total_unique_caller_callee_pairs)\n INTERFACE_FUNCTION(__sanitizer_get_total_unique_coverage)\n INTERFACE_FUNCTION(__sanitizer_get_unmapped_bytes)\n INTERFACE_FUNCTION(__sanitizer_maybe_open_cov_file)"}, {"sha": "f7358539a1cd65f4282194e16efc2b7b03136691", "filename": "libsanitizer/asan/asan_win_dynamic_runtime_thunk.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -22,6 +22,7 @@\n // Using #ifdef rather than relying on Makefiles etc.\n // simplifies the build procedure.\n #ifdef ASAN_DYNAMIC_RUNTIME_THUNK\n+#define WIN32_LEAN_AND_MEAN\n #include <windows.h>\n \n // First, declare CRT sections we'll be using in this file"}, {"sha": "05ead765e62b12b9a24db750cc68c0f906a45998", "filename": "libsanitizer/configure.tgt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.tgt?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -37,6 +37,8 @@ case \"${target}\" in\n   aarch64*-*-linux*)\n \tif test x$ac_cv_sizeof_void_p = x8; then\n \t\tTSAN_SUPPORTED=yes\n+\t\tLSAN_SUPPORTED=yes\n+\t\tTSAN_TARGET_DEPENDENT_OBJECTS=tsan_rtl_aarch64.lo\n \tfi\n \t;;\n   x86_64-*-darwin[1]* | i?86-*-darwin[1]*)"}, {"sha": "35463e08fbbdf0a256f3d71c39f3c2596f0cc0e3", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -103,6 +103,12 @@ extern \"C\" {\n   int __sanitizer_verify_contiguous_container(const void *beg, const void *mid,\n                                               const void *end);\n \n+  // Similar to __sanitizer_verify_contiguous_container but returns the address\n+  // of the first improperly poisoned byte otherwise. Returns null if the area\n+  // is poisoned properly.\n+  const void *__sanitizer_contiguous_container_find_bad_address(\n+      const void *beg, const void *mid, const void *end);\n+\n   // Print the stack trace leading to this call. Useful for debugging user code.\n   void __sanitizer_print_stack_trace();\n "}, {"sha": "37c133aae3c0d0128aa9748f6a8f27d24f2712d4", "filename": "libsanitizer/include/sanitizer/coverage_interface.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -25,9 +25,11 @@ extern \"C\" {\n   // descriptor. Returns -1 on failure, or if coverage dumping is disabled.\n   // This is intended for use by sandboxing code.\n   intptr_t __sanitizer_maybe_open_cov_file(const char *name);\n-  // Get the number of total unique covered entities (blocks, edges, calls).\n+  // Get the number of unique covered blocks (or edges).\n   // This can be useful for coverage-directed in-process fuzzers.\n   uintptr_t __sanitizer_get_total_unique_coverage();\n+  // Get the number of unique indirect caller-callee pairs.\n+  uintptr_t __sanitizer_get_total_unique_caller_callee_pairs();\n \n   // Reset the basic-block (edge) coverage to the initial state.\n   // Useful for in-process fuzzing to start collecting coverage from scratch."}, {"sha": "df51fa21ead808b0700a09c42d6be4d41951d979", "filename": "libsanitizer/interception/interception_win.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Finterception%2Finterception_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Finterception%2Finterception_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -13,6 +13,7 @@\n #ifdef _WIN32\n \n #include \"interception.h\"\n+#define WIN32_LEAN_AND_MEAN\n #include <windows.h>\n \n namespace __interception {"}, {"sha": "22b5f7e1a4aa0724a3680136af207052235195d7", "filename": "libsanitizer/lsan/lsan_allocator.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Flsan%2Flsan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Flsan%2Flsan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -30,7 +30,7 @@ struct ChunkMetadata {\n   u32 stack_trace_id;\n };\n \n-#if defined(__mips64)\n+#if defined(__mips64) || defined(__aarch64__)\n static const uptr kMaxAllowedMallocSize = 4UL << 30;\n static const uptr kRegionSizeLog = 20;\n static const uptr kNumRegions = SANITIZER_MMAP_RANGE_SIZE >> kRegionSizeLog;"}, {"sha": "6d674c5e437627e2e4d9cd60d5f512e2ada031af", "filename": "libsanitizer/lsan/lsan_common.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Flsan%2Flsan_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Flsan%2Flsan_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -117,6 +117,10 @@ static inline bool CanBeAHeapPointer(uptr p) {\n   return ((p >> 47) == 0);\n #elif defined(__mips64)\n   return ((p >> 40) == 0);\n+#elif defined(__aarch64__)\n+  unsigned runtimeVMA =\n+    (MostSignificantSetBitIndex(GET_CURRENT_FRAME()) + 1);\n+  return ((p >> runtimeVMA) == 0);\n #else\n   return true;\n #endif"}, {"sha": "b415567e7f3f53a1cbcfc027adc816d6f1dcdc98", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -20,8 +20,8 @@\n #include \"sanitizer_common/sanitizer_stoptheworld.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n \n-#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__mips64)) \\\n-    && (SANITIZER_WORDSIZE == 64)\n+#if (SANITIZER_LINUX && !SANITIZER_ANDROID) && (SANITIZER_WORDSIZE == 64) \\\n+     && (defined(__x86_64__) ||  defined(__mips64) ||  defined(__aarch64__))\n #define CAN_SANITIZE_LEAKS 1\n #else\n #define CAN_SANITIZE_LEAKS 0"}, {"sha": "985f59c23c20c59470214f9cda738d0092201b93", "filename": "libsanitizer/sanitizer_common/sanitizer_asm.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -21,16 +21,22 @@\n # define CFI_STARTPROC .cfi_startproc\n # define CFI_ENDPROC .cfi_endproc\n # define CFI_ADJUST_CFA_OFFSET(n) .cfi_adjust_cfa_offset n\n+# define CFI_DEF_CFA_OFFSET(n) .cfi_def_cfa_offset n\n # define CFI_REL_OFFSET(reg, n) .cfi_rel_offset reg, n\n+# define CFI_OFFSET(reg, n) .cfi_offset reg, n\n # define CFI_DEF_CFA_REGISTER(reg) .cfi_def_cfa_register reg\n+# define CFI_DEF_CFA(reg, n) .cfi_def_cfa reg, n\n # define CFI_RESTORE(reg) .cfi_restore reg\n \n #else  // No CFI\n # define CFI_INL_ADJUST_CFA_OFFSET(n)\n # define CFI_STARTPROC\n # define CFI_ENDPROC\n # define CFI_ADJUST_CFA_OFFSET(n)\n+# define CFI_DEF_CFA_OFFSET(n)\n # define CFI_REL_OFFSET(reg, n)\n+# define CFI_OFFSET(reg, n)\n # define CFI_DEF_CFA_REGISTER(reg)\n+# define CFI_DEF_CFA(reg, n)\n # define CFI_RESTORE(reg)\n #endif"}, {"sha": "4529e63eba96f1512d70f55500f4a21e8ceaf88a", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -162,7 +162,7 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n }\n \n void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n-                                      error_t err) {\n+                                      const char *mmap_type, error_t err) {\n   static int recursion_count;\n   if (recursion_count) {\n     // The Report() and CHECK calls below may call mmap recursively and fail.\n@@ -172,9 +172,11 @@ void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n   }\n   recursion_count++;\n   Report(\"ERROR: %s failed to \"\n-         \"allocate 0x%zx (%zd) bytes of %s (error code: %d)\\n\",\n-         SanitizerToolName, size, size, mem_type, err);\n+         \"%s 0x%zx (%zd) bytes of %s (error code: %d)\\n\",\n+         SanitizerToolName, mmap_type, size, size, mem_type, err);\n+#ifndef SANITIZER_GO\n   DumpProcessMap();\n+#endif\n   UNREACHABLE(\"unable to mmap\");\n }\n "}, {"sha": "6fb2dd882aa7d72e7fabf608fb4271cbd6d9b106", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -307,7 +307,7 @@ void NORETURN Die();\n void NORETURN\n CheckFailed(const char *file, int line, const char *cond, u64 v1, u64 v2);\n void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n-                                      error_t err);\n+                                      const char *mmap_type, error_t err);\n \n // Set the name of the current thread to 'name', return true on succees.\n // The name may be truncated to a system-dependent limit."}, {"sha": "8223778cac428b054c68b9a4a8a8e6c7fea95610", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -439,6 +439,8 @@ INTERCEPTOR(int, memcmp, const void *a1, const void *a2, uptr size) {\n \n #if SANITIZER_INTERCEPT_MEMCHR\n INTERCEPTOR(void*, memchr, const void *s, int c, SIZE_T n) {\n+  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n+    return internal_memchr(s, c, n);\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, memchr, s, c, n);\n   void *res = REAL(memchr)(s, c, n);\n@@ -2444,6 +2446,7 @@ INTERCEPTOR(int, readdir64_r, void *dirp, __sanitizer_dirent64 *entry,\n INTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, ptrace, request, pid, addr, data);\n+  __sanitizer_iovec local_iovec;\n \n   if (data) {\n     if (request == ptrace_setregs)\n@@ -2452,11 +2455,19 @@ INTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n       COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_fpregs_struct_sz);\n     else if (request == ptrace_setfpxregs)\n       COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_fpxregs_struct_sz);\n+    else if (request == ptrace_setvfpregs)\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_vfpregs_struct_sz);\n     else if (request == ptrace_setsiginfo)\n       COMMON_INTERCEPTOR_READ_RANGE(ctx, data, siginfo_t_sz);\n-    else if (request == ptrace_setregset) {\n-      __sanitizer_iovec *iov = (__sanitizer_iovec *)data;\n-      COMMON_INTERCEPTOR_READ_RANGE(ctx, iov->iov_base, iov->iov_len);\n+    // Some kernel might zero the iovec::iov_base in case of invalid\n+    // write access.  In this case copy the invalid address for further\n+    // inspection.\n+    else if (request == ptrace_setregset || request == ptrace_getregset) {\n+      __sanitizer_iovec *iovec = (__sanitizer_iovec*)data;\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec, sizeof(*iovec));\n+      local_iovec = *iovec;\n+      if (request == ptrace_setregset)\n+        COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec->iov_base, iovec->iov_len);\n     }\n   }\n \n@@ -2474,13 +2485,17 @@ INTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_fpregs_struct_sz);\n     else if (request == ptrace_getfpxregs)\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_fpxregs_struct_sz);\n+    else if (request == ptrace_getvfpregs)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_vfpregs_struct_sz);\n     else if (request == ptrace_getsiginfo)\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, siginfo_t_sz);\n     else if (request == ptrace_geteventmsg)\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, sizeof(unsigned long));\n     else if (request == ptrace_getregset) {\n-      __sanitizer_iovec *iov = (__sanitizer_iovec *)data;\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iov->iov_base, iov->iov_len);\n+      __sanitizer_iovec *iovec = (__sanitizer_iovec*)data;\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iovec, sizeof(*iovec));\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, local_iovec.iov_base,\n+                                     local_iovec.iov_len);\n     }\n   }\n   return res;\n@@ -4874,9 +4889,8 @@ static void initialize_obstack(__sanitizer_obstack *obstack) {\n                                         sizeof(*obstack->chunk));\n }\n \n-INTERCEPTOR(int, _obstack_begin_1, __sanitizer_obstack *obstack,\n-            _OBSTACK_SIZE_T sz, _OBSTACK_SIZE_T align,\n-            void *(*alloc_fn)(uptr arg, SIZE_T sz),\n+INTERCEPTOR(int, _obstack_begin_1, __sanitizer_obstack *obstack, int sz,\n+            int align, void *(*alloc_fn)(uptr arg, uptr sz),\n             void (*free_fn)(uptr arg, void *p)) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, _obstack_begin_1, obstack, sz, align, alloc_fn,\n@@ -4885,19 +4899,16 @@ INTERCEPTOR(int, _obstack_begin_1, __sanitizer_obstack *obstack,\n   if (res) initialize_obstack(obstack);\n   return res;\n }\n-INTERCEPTOR(int, _obstack_begin, __sanitizer_obstack *obstack,\n-            _OBSTACK_SIZE_T sz, _OBSTACK_SIZE_T align,\n-            void *(*alloc_fn)(SIZE_T sz),\n-            void (*free_fn)(void *p)) {\n+INTERCEPTOR(int, _obstack_begin, __sanitizer_obstack *obstack, int sz,\n+            int align, void *(*alloc_fn)(uptr sz), void (*free_fn)(void *p)) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, _obstack_begin, obstack, sz, align, alloc_fn,\n                            free_fn);\n   int res = REAL(_obstack_begin)(obstack, sz, align, alloc_fn, free_fn);\n   if (res) initialize_obstack(obstack);\n   return res;\n }\n-INTERCEPTOR(void, _obstack_newchunk, __sanitizer_obstack *obstack,\n-            _OBSTACK_SIZE_T length) {\n+INTERCEPTOR(void, _obstack_newchunk, __sanitizer_obstack *obstack, int length) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, _obstack_newchunk, obstack, length);\n   REAL(_obstack_newchunk)(obstack, length);\n@@ -5238,6 +5249,39 @@ INTERCEPTOR(int, mincore, void *addr, uptr length, unsigned char *vec) {\n #define INIT_MINCORE\n #endif\n \n+#if SANITIZER_INTERCEPT_PROCESS_VM_READV\n+INTERCEPTOR(SSIZE_T, process_vm_readv, int pid, __sanitizer_iovec *local_iov,\n+            uptr liovcnt, __sanitizer_iovec *remote_iov, uptr riovcnt,\n+            uptr flags) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, process_vm_readv, pid, local_iov, liovcnt,\n+                           remote_iov, riovcnt, flags);\n+  SSIZE_T res = REAL(process_vm_readv)(pid, local_iov, liovcnt, remote_iov,\n+                                       riovcnt, flags);\n+  if (res > 0)\n+    write_iovec(ctx, local_iov, liovcnt, res);\n+  return res;\n+}\n+\n+INTERCEPTOR(SSIZE_T, process_vm_writev, int pid, __sanitizer_iovec *local_iov,\n+            uptr liovcnt, __sanitizer_iovec *remote_iov, uptr riovcnt,\n+            uptr flags) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, process_vm_writev, pid, local_iov, liovcnt,\n+                           remote_iov, riovcnt, flags);\n+  SSIZE_T res = REAL(process_vm_writev)(pid, local_iov, liovcnt, remote_iov,\n+                                        riovcnt, flags);\n+  if (res > 0)\n+    read_iovec(ctx, local_iov, liovcnt, res);\n+  return res;\n+}\n+#define INIT_PROCESS_VM_READV                                                  \\\n+  COMMON_INTERCEPT_FUNCTION(process_vm_readv);                                 \\\n+  COMMON_INTERCEPT_FUNCTION(process_vm_writev);\n+#else\n+#define INIT_PROCESS_VM_READV\n+#endif\n+\n static void InitializeCommonInterceptors() {\n   static u64 metadata_mem[sizeof(MetadataHashMap) / sizeof(u64) + 1];\n   interceptor_metadata_map = new((void *)&metadata_mem) MetadataHashMap();\n@@ -5411,4 +5455,5 @@ static void InitializeCommonInterceptors() {\n   INIT_SEM;\n   INIT_PTHREAD_SETCANCEL;\n   INIT_MINCORE;\n+  INIT_PROCESS_VM_READV;\n }"}, {"sha": "c67880468b8c154bbfe34d7d2c9aaa43c4f6a4df", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep.cc", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -51,6 +51,12 @@ static const u64 kMagic32 = 0xC0BFFFFFFFFFFF32ULL;\n static atomic_uint32_t dump_once_guard;  // Ensure that CovDump runs only once.\n \n static atomic_uintptr_t coverage_counter;\n+static atomic_uintptr_t caller_callee_counter;\n+\n+static void ResetGlobalCounters() {\n+  return atomic_store(&coverage_counter, 0, memory_order_relaxed);\n+  return atomic_store(&caller_callee_counter, 0, memory_order_relaxed);\n+}\n \n // pc_array is the array containing the covered PCs.\n // To make the pc_array thread- and async-signal-safe it has to be large enough.\n@@ -223,7 +229,8 @@ void CoverageData::InitializeGuardArray(s32 *guards) {\n   Enable();  // Make sure coverage is enabled at this point.\n   s32 n = guards[0];\n   for (s32 j = 1; j <= n; j++) {\n-    uptr idx = atomic_fetch_add(&pc_array_index, 1, memory_order_relaxed);\n+    uptr idx = atomic_load_relaxed(&pc_array_index);\n+    atomic_store_relaxed(&pc_array_index, idx + 1);\n     guards[j] = -static_cast<s32>(idx + 1);\n   }\n }\n@@ -433,7 +440,7 @@ void CoverageData::IndirCall(uptr caller, uptr callee, uptr callee_cache[],\n     uptr was = 0;\n     if (atomic_compare_exchange_strong(&atomic_callee_cache[i], &was, callee,\n                                        memory_order_seq_cst)) {\n-      atomic_fetch_add(&coverage_counter, 1, memory_order_relaxed);\n+      atomic_fetch_add(&caller_callee_counter, 1, memory_order_relaxed);\n       return;\n     }\n     if (was == callee)  // Already have this callee.\n@@ -905,6 +912,11 @@ uptr __sanitizer_get_total_unique_coverage() {\n   return atomic_load(&coverage_counter, memory_order_relaxed);\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_get_total_unique_caller_callee_pairs() {\n+  return atomic_load(&caller_callee_counter, memory_order_relaxed);\n+}\n+\n SANITIZER_INTERFACE_ATTRIBUTE\n void __sanitizer_cov_trace_func_enter(s32 *id) {\n   coverage_data.TraceBasicBlock(id);\n@@ -915,6 +927,7 @@ void __sanitizer_cov_trace_basic_block(s32 *id) {\n }\n SANITIZER_INTERFACE_ATTRIBUTE\n void __sanitizer_reset_coverage() {\n+  ResetGlobalCounters();\n   coverage_data.ReinitializeGuards();\n   internal_bzero_aligned16(\n       coverage_data.data(),"}, {"sha": "0547f9927cb3b52e1c582ba45c7505ad48defaf7", "filename": "libsanitizer/sanitizer_common/sanitizer_interface_internal.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -51,6 +51,9 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE\n   int __sanitizer_verify_contiguous_container(const void *beg, const void *mid,\n                                               const void *end);\n-}  // extern \"C\"\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  const void *__sanitizer_contiguous_container_find_bad_address(\n+      const void *beg, const void *mid, const void *end);\n+  } // extern \"C\"\n \n #endif  // SANITIZER_INTERFACE_INTERNAL_H"}, {"sha": "4b8cbed5ee326e4a4ba5555ec348e6b07e1fc064", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -7,7 +7,7 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC\n \n #include \"sanitizer_libignore.h\"\n #include \"sanitizer_flags.h\""}, {"sha": "2cefa20a5f0832308d6bf8c41126e894181f7164", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -495,14 +495,17 @@ void BlockingMutex::CheckLocked() {\n // Note that getdents64 uses a different structure format. We only provide the\n // 32-bit syscall here.\n struct linux_dirent {\n-#if SANITIZER_X32\n+#if SANITIZER_X32 || defined(__aarch64__)\n   u64 d_ino;\n   u64 d_off;\n #else\n   unsigned long      d_ino;\n   unsigned long      d_off;\n #endif\n   unsigned short     d_reclen;\n+#ifdef __aarch64__\n+  unsigned char      d_type;\n+#endif\n   char               d_name[256];\n };\n "}, {"sha": "ff69664e7b9912eb0fd95878504b6a3e34be389f", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc", "status": "modified", "additions": 24, "deletions": 48, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -60,20 +60,6 @@\n \n namespace __sanitizer {\n \n-// This function is defined elsewhere if we intercepted pthread_attr_getstack.\n-extern \"C\" {\n-SANITIZER_WEAK_ATTRIBUTE int\n-real_pthread_attr_getstack(void *attr, void **addr, size_t *size);\n-} // extern \"C\"\n-\n-static int my_pthread_attr_getstack(void *attr, void **addr, size_t *size) {\n-#if !SANITIZER_GO\n-  if (&real_pthread_attr_getstack)\n-    return real_pthread_attr_getstack((pthread_attr_t *)attr, addr, size);\n-#endif\n-  return pthread_attr_getstack((pthread_attr_t *)attr, addr, size);\n-}\n-\n SANITIZER_WEAK_ATTRIBUTE int\n real_sigaction(int signum, const void *act, void *oldact);\n \n@@ -126,7 +112,7 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n   uptr stacksize = 0;\n   void *stackaddr = nullptr;\n-  my_pthread_attr_getstack(&attr, &stackaddr, (size_t*)&stacksize);\n+  my_pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n   pthread_attr_destroy(&attr);\n \n   CHECK_LE(stacksize, kMaxThreadStackSize);  // Sanity check.\n@@ -178,11 +164,15 @@ static uptr g_tls_size;\n # define DL_INTERNAL_FUNCTION\n #endif\n \n-#if defined(__mips__)\n+#if defined(__mips__) || defined(__powerpc64__)\n // TlsPreTcbSize includes size of struct pthread_descr and size of tcb\n // head structure. It lies before the static tls blocks.\n static uptr TlsPreTcbSize() {\n-  const uptr kTcbHead = 16;\n+# if defined(__mips__)\n+  const uptr kTcbHead = 16; // sizeof (tcbhead_t)\n+# elif defined(__powerpc64__)\n+  const uptr kTcbHead = 88; // sizeof (tcbhead_t)\n+# endif\n   const uptr kTlsAlign = 16;\n   const uptr kTlsPreTcbSize =\n     (ThreadDescriptorSize() + kTcbHead + kTlsAlign - 1) & ~(kTlsAlign - 1);\n@@ -213,9 +203,9 @@ void InitTlsSize() {\n }\n \n #if (defined(__x86_64__) || defined(__i386__) || defined(__mips__) \\\n-    || defined(__aarch64__)) \\\n+    || defined(__aarch64__) || defined(__powerpc64__)) \\\n     && SANITIZER_LINUX && !SANITIZER_ANDROID\n-// sizeof(struct thread) from glibc.\n+// sizeof(struct pthread) from glibc.\n static atomic_uintptr_t kThreadDescriptorSize;\n \n uptr ThreadDescriptorSize() {\n@@ -230,7 +220,7 @@ uptr ThreadDescriptorSize() {\n     char *end;\n     int minor = internal_simple_strtoll(buf + 8, &end, 10);\n     if (end != buf + 8 && (*end == '\\0' || *end == '.')) {\n-      /* sizeof(struct thread) values from various glibc versions.  */\n+      /* sizeof(struct pthread) values from various glibc versions.  */\n       if (SANITIZER_X32)\n         val = 1728;  // Assume only one particular version for x32.\n       else if (minor <= 3)\n@@ -266,6 +256,10 @@ uptr ThreadDescriptorSize() {\n   val = 1776;\n   atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n   return val;\n+#elif defined(__powerpc64__)\n+  val = 1776; // from glibc.ppc64le 2.20-8.fc21\n+  atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n+  return val;\n #endif\n   return 0;\n }\n@@ -297,6 +291,15 @@ uptr ThreadSelf() {\n   descr_addr = thread_pointer - kTlsTcbOffset - TlsPreTcbSize();\n # elif defined(__aarch64__)\n   descr_addr = reinterpret_cast<uptr>(__builtin_thread_pointer());\n+# elif defined(__powerpc64__)\n+  // PPC64LE uses TLS variant I. The thread pointer (in GPR 13)\n+  // points to the end of the TCB + 0x7000. The pthread_descr structure is\n+  // immediately in front of the TCB. TlsPreTcbSize() includes the size of the\n+  // TCB and the size of pthread_descr.\n+  const uptr kTlsTcbOffset = 0x7000;\n+  uptr thread_pointer;\n+  asm(\"addi %0,13,%1\" : \"=r\"(thread_pointer) : \"I\"(-kTlsTcbOffset));\n+  descr_addr = thread_pointer - TlsPreTcbSize();\n # else\n #  error \"unsupported CPU arch\"\n # endif\n@@ -332,7 +335,7 @@ static void GetTls(uptr *addr, uptr *size) {\n   *size = GetTlsSize();\n   *addr -= *size;\n   *addr += ThreadDescriptorSize();\n-# elif defined(__mips__) || defined(__aarch64__)\n+# elif defined(__mips__) || defined(__aarch64__) || defined(__powerpc64__)\n   *addr = ThreadSelf();\n   *size = GetTlsSize();\n # else\n@@ -398,33 +401,6 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n #endif\n }\n \n-#if !SANITIZER_GO\n-void AdjustStackSize(void *attr_) {\n-  pthread_attr_t *attr = (pthread_attr_t *)attr_;\n-  uptr stackaddr = 0;\n-  size_t stacksize = 0;\n-  my_pthread_attr_getstack(attr, (void**)&stackaddr, &stacksize);\n-  // GLibC will return (0 - stacksize) as the stack address in the case when\n-  // stacksize is set, but stackaddr is not.\n-  bool stack_set = (stackaddr != 0) && (stackaddr + stacksize != 0);\n-  // We place a lot of tool data into TLS, account for that.\n-  const uptr minstacksize = GetTlsSize() + 128*1024;\n-  if (stacksize < minstacksize) {\n-    if (!stack_set) {\n-      if (stacksize != 0) {\n-        VPrintf(1, \"Sanitizer: increasing stacksize %zu->%zu\\n\", stacksize,\n-                minstacksize);\n-        pthread_attr_setstacksize(attr, minstacksize);\n-      }\n-    } else {\n-      Printf(\"Sanitizer: pre-allocated stack size is insufficient: \"\n-             \"%zu < %zu\\n\", stacksize, minstacksize);\n-      Printf(\"Sanitizer: pthread_create is likely to fail.\\n\");\n-    }\n-  }\n-}\n-#endif // !SANITIZER_GO\n-\n # if !SANITIZER_FREEBSD\n typedef ElfW(Phdr) Elf_Phdr;\n # elif SANITIZER_WORDSIZE == 32 && __FreeBSD_version <= 902001  // v9.2"}, {"sha": "159db76f01e1f340f4a793022088425b9fdd7494", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -39,6 +39,7 @@ extern char **environ;\n #include <libkern/OSAtomic.h>\n #include <mach-o/dyld.h>\n #include <mach/mach.h>\n+#include <mach/vm_statistics.h>\n #include <pthread.h>\n #include <sched.h>\n #include <signal.h>\n@@ -57,6 +58,7 @@ namespace __sanitizer {\n // ---------------------- sanitizer_libc.h\n uptr internal_mmap(void *addr, size_t length, int prot, int flags,\n                    int fd, u64 offset) {\n+  if (fd == -1) fd = VM_MAKE_TAG(VM_MEMORY_ANALYSIS_TOOL);\n   return (uptr)mmap(addr, length, prot, flags, fd, offset);\n }\n \n@@ -367,8 +369,18 @@ uptr GetRSS() {\n   return info.resident_size;\n }\n \n-void *internal_start_thread(void (*func)(void *arg), void *arg) { return 0; }\n-void internal_join_thread(void *th) { }\n+void *internal_start_thread(void(*func)(void *arg), void *arg) {\n+  // Start the thread with signals blocked, otherwise it can steal user signals.\n+  __sanitizer_sigset_t set, old;\n+  internal_sigfillset(&set);\n+  internal_sigprocmask(SIG_SETMASK, &set, &old);\n+  pthread_t th;\n+  pthread_create(&th, 0, (void*(*)(void *arg))func, arg);\n+  internal_sigprocmask(SIG_SETMASK, &old, 0);\n+  return th;\n+}\n+\n+void internal_join_thread(void *th) { pthread_join((pthread_t)th, 0); }\n \n void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   ucontext_t *ucontext = (ucontext_t*)context;"}, {"sha": "6ed0f69de974ab6880f9fc723a7dbf6375aca84a", "filename": "libsanitizer/sanitizer_common/sanitizer_malloc_mac.inc", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -0,0 +1,337 @@\n+//===-- sanitizer_malloc_mac.inc --------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file contains Mac-specific malloc interceptors and a custom zone\n+// implementation, which together replace the system allocator.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if !SANITIZER_MAC\n+#error \"This file should only be compiled on Darwin.\"\n+#endif\n+\n+#include <AvailabilityMacros.h>\n+#include <CoreFoundation/CFBase.h>\n+#include <dlfcn.h>\n+#include <malloc/malloc.h>\n+#include <sys/mman.h>\n+\n+#include \"interception/interception.h\"\n+#include \"sanitizer_common/sanitizer_mac.h\"\n+\n+// Similar code is used in Google Perftools,\n+// http://code.google.com/p/google-perftools.\n+\n+static malloc_zone_t sanitizer_zone;\n+\n+INTERCEPTOR(malloc_zone_t *, malloc_create_zone,\n+                             vm_size_t start_size, unsigned zone_flags) {\n+  COMMON_MALLOC_ENTER();\n+  uptr page_size = GetPageSizeCached();\n+  uptr allocated_size = RoundUpTo(sizeof(sanitizer_zone), page_size);\n+  COMMON_MALLOC_MEMALIGN(page_size, allocated_size);\n+  malloc_zone_t *new_zone = (malloc_zone_t *)p;\n+  internal_memcpy(new_zone, &sanitizer_zone, sizeof(sanitizer_zone));\n+  new_zone->zone_name = NULL;  // The name will be changed anyway.\n+  if (GetMacosVersion() >= MACOS_VERSION_LION) {\n+    // Prevent the client app from overwriting the zone contents.\n+    // Library functions that need to modify the zone will set PROT_WRITE on it.\n+    // This matches the behavior of malloc_create_zone() on OSX 10.7 and higher.\n+    mprotect(new_zone, allocated_size, PROT_READ);\n+  }\n+  return new_zone;\n+}\n+\n+INTERCEPTOR(malloc_zone_t *, malloc_default_zone, void) {\n+  COMMON_MALLOC_ENTER();\n+  return &sanitizer_zone;\n+}\n+\n+INTERCEPTOR(malloc_zone_t *, malloc_default_purgeable_zone, void) {\n+  // FIXME: ASan should support purgeable allocations.\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=139\n+  COMMON_MALLOC_ENTER();\n+  return &sanitizer_zone;\n+}\n+\n+INTERCEPTOR(void, malloc_make_purgeable, void *ptr) {\n+  // FIXME: ASan should support purgeable allocations. Ignoring them is fine\n+  // for now.\n+  COMMON_MALLOC_ENTER();\n+}\n+\n+INTERCEPTOR(int, malloc_make_nonpurgeable, void *ptr) {\n+  // FIXME: ASan should support purgeable allocations. Ignoring them is fine\n+  // for now.\n+  COMMON_MALLOC_ENTER();\n+  // Must return 0 if the contents were not purged since the last call to\n+  // malloc_make_purgeable().\n+  return 0;\n+}\n+\n+INTERCEPTOR(void, malloc_set_zone_name, malloc_zone_t *zone, const char *name) {\n+  COMMON_MALLOC_ENTER();\n+  // Allocate |sizeof(COMMON_MALLOC_ZONE_NAME \"-\") + internal_strlen(name)|\n+  // bytes.\n+  size_t buflen =\n+      sizeof(COMMON_MALLOC_ZONE_NAME \"-\") + (name ? internal_strlen(name) : 0);\n+  InternalScopedString new_name(buflen);\n+  if (name && zone->introspect == sanitizer_zone.introspect) {\n+    new_name.append(COMMON_MALLOC_ZONE_NAME \"-%s\", name);\n+    name = new_name.data();\n+  }\n+\n+  // Call the system malloc's implementation for both external and our zones,\n+  // since that appropriately changes VM region protections on the zone.\n+  REAL(malloc_set_zone_name)(zone, name);\n+}\n+\n+INTERCEPTOR(void *, malloc, size_t size) {\n+  COMMON_MALLOC_ENTER();\n+  COMMON_MALLOC_MALLOC(size);\n+  return p;\n+}\n+\n+INTERCEPTOR(void, free, void *ptr) {\n+  COMMON_MALLOC_ENTER();\n+  if (!ptr) return;\n+  COMMON_MALLOC_FREE(ptr);\n+}\n+\n+INTERCEPTOR(void *, realloc, void *ptr, size_t size) {\n+  COMMON_MALLOC_ENTER();\n+  COMMON_MALLOC_REALLOC(ptr, size);\n+  return p;\n+}\n+\n+INTERCEPTOR(void *, calloc, size_t nmemb, size_t size) {\n+  COMMON_MALLOC_ENTER();\n+  COMMON_MALLOC_CALLOC(nmemb, size);\n+  return p;\n+}\n+\n+INTERCEPTOR(void *, valloc, size_t size) {\n+  COMMON_MALLOC_ENTER();\n+  COMMON_MALLOC_VALLOC(size);\n+  return p;\n+}\n+\n+INTERCEPTOR(size_t, malloc_good_size, size_t size) {\n+  COMMON_MALLOC_ENTER();\n+  return sanitizer_zone.introspect->good_size(&sanitizer_zone, size);\n+}\n+\n+INTERCEPTOR(int, posix_memalign, void **memptr, size_t alignment, size_t size) {\n+  COMMON_MALLOC_ENTER();\n+  CHECK(memptr);\n+  COMMON_MALLOC_MEMALIGN(alignment, size);\n+  if (p) {\n+    *memptr = p;\n+    return 0;\n+  }\n+  return -1;\n+}\n+\n+namespace {\n+\n+// TODO(glider): the __sanitizer_mz_* functions should be united with the Linux\n+// wrappers, as they are basically copied from there.\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+size_t __sanitizer_mz_size(malloc_zone_t* zone, const void* ptr) {\n+  COMMON_MALLOC_SIZE(ptr);\n+  return size;\n+}\n+\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__sanitizer_mz_malloc(malloc_zone_t *zone, uptr size) {\n+  COMMON_MALLOC_ENTER();\n+  COMMON_MALLOC_MALLOC(size);\n+  return p;\n+}\n+\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__sanitizer_mz_calloc(malloc_zone_t *zone, size_t nmemb, size_t size) {\n+  if (UNLIKELY(!COMMON_MALLOC_SANITIZER_INITIALIZED)) {\n+    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n+    const size_t kCallocPoolSize = 1024;\n+    static uptr calloc_memory_for_dlsym[kCallocPoolSize];\n+    static size_t allocated;\n+    size_t size_in_words = ((nmemb * size) + kWordSize - 1) / kWordSize;\n+    void *mem = (void*)&calloc_memory_for_dlsym[allocated];\n+    allocated += size_in_words;\n+    CHECK(allocated < kCallocPoolSize);\n+    return mem;\n+  }\n+  COMMON_MALLOC_CALLOC(nmemb, size);\n+  return p;\n+}\n+\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__sanitizer_mz_valloc(malloc_zone_t *zone, size_t size) {\n+  COMMON_MALLOC_ENTER();\n+  COMMON_MALLOC_VALLOC(size);\n+  return p;\n+}\n+\n+#define GET_ZONE_FOR_PTR(ptr) \\\n+  malloc_zone_t *zone_ptr = malloc_zone_from_ptr(ptr); \\\n+  const char *zone_name = (zone_ptr == 0) ? 0 : zone_ptr->zone_name\n+\n+void ALWAYS_INLINE free_common(void *context, void *ptr) {\n+  if (!ptr) return;\n+  // FIXME: need to retire this flag.\n+  if (!COMMON_MALLOC_IGNORE_INVALID_FREE) {\n+    COMMON_MALLOC_FREE(ptr);\n+  } else {\n+    GET_ZONE_FOR_PTR(ptr);\n+    COMMON_MALLOC_REPORT_FREE_UNALLOCATED(ptr, zone_ptr, zone_name);\n+  }\n+}\n+\n+// TODO(glider): the allocation callbacks need to be refactored.\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_mz_free(malloc_zone_t *zone, void *ptr) {\n+  free_common(zone, ptr);\n+}\n+\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__sanitizer_mz_realloc(malloc_zone_t *zone, void *ptr, size_t new_size) {\n+  if (!ptr) {\n+    COMMON_MALLOC_MALLOC(new_size);\n+    return p;\n+  } else {\n+    COMMON_MALLOC_SIZE(ptr);\n+    if (size) {\n+      COMMON_MALLOC_REALLOC(ptr, new_size);\n+      return p;\n+    } else {\n+      // We can't recover from reallocating an unknown address, because\n+      // this would require reading at most |new_size| bytes from\n+      // potentially unaccessible memory.\n+      GET_ZONE_FOR_PTR(ptr);\n+      COMMON_MALLOC_REPORT_UNKNOWN_REALLOC(ptr, zone_ptr, zone_name);\n+      return nullptr;\n+    }\n+  }\n+}\n+\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_mz_destroy(malloc_zone_t* zone) {\n+  // A no-op -- we will not be destroyed!\n+  Report(\"__sanitizer_mz_destroy() called -- ignoring\\n\");\n+}\n+\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__sanitizer_mz_memalign(malloc_zone_t *zone, size_t align, size_t size) {\n+  COMMON_MALLOC_ENTER();\n+  COMMON_MALLOC_MEMALIGN(align, size);\n+  return p;\n+}\n+\n+// This function is currently unused, and we build with -Werror.\n+#if 0\n+void __sanitizer_mz_free_definite_size(\n+    malloc_zone_t* zone, void *ptr, size_t size) {\n+  // TODO(glider): check that |size| is valid.\n+  UNIMPLEMENTED();\n+}\n+#endif\n+\n+kern_return_t mi_enumerator(task_t task, void *,\n+                            unsigned type_mask, vm_address_t zone_address,\n+                            memory_reader_t reader,\n+                            vm_range_recorder_t recorder) {\n+  // Should enumerate all the pointers we have.  Seems like a lot of work.\n+  return KERN_FAILURE;\n+}\n+\n+size_t mi_good_size(malloc_zone_t *zone, size_t size) {\n+  // I think it's always safe to return size, but we maybe could do better.\n+  return size;\n+}\n+\n+boolean_t mi_check(malloc_zone_t *zone) {\n+  UNIMPLEMENTED();\n+}\n+\n+void mi_print(malloc_zone_t *zone, boolean_t verbose) {\n+  UNIMPLEMENTED();\n+}\n+\n+void mi_log(malloc_zone_t *zone, void *address) {\n+  // I don't think we support anything like this\n+}\n+\n+void mi_force_lock(malloc_zone_t *zone) {\n+  COMMON_MALLOC_FORCE_LOCK();\n+}\n+\n+void mi_force_unlock(malloc_zone_t *zone) {\n+  COMMON_MALLOC_FORCE_UNLOCK();\n+}\n+\n+void mi_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {\n+  COMMON_MALLOC_FILL_STATS(zone, stats);\n+}\n+\n+boolean_t mi_zone_locked(malloc_zone_t *zone) {\n+  // UNIMPLEMENTED();\n+  return false;\n+}\n+\n+}  // unnamed namespace\n+\n+namespace COMMON_MALLOC_NAMESPACE {\n+\n+void ReplaceSystemMalloc() {\n+  static malloc_introspection_t sanitizer_zone_introspection;\n+  // Ok to use internal_memset, these places are not performance-critical.\n+  internal_memset(&sanitizer_zone_introspection, 0,\n+                  sizeof(sanitizer_zone_introspection));\n+\n+  sanitizer_zone_introspection.enumerator = &mi_enumerator;\n+  sanitizer_zone_introspection.good_size = &mi_good_size;\n+  sanitizer_zone_introspection.check = &mi_check;\n+  sanitizer_zone_introspection.print = &mi_print;\n+  sanitizer_zone_introspection.log = &mi_log;\n+  sanitizer_zone_introspection.force_lock = &mi_force_lock;\n+  sanitizer_zone_introspection.force_unlock = &mi_force_unlock;\n+  sanitizer_zone_introspection.statistics = &mi_statistics;\n+  sanitizer_zone_introspection.zone_locked = &mi_zone_locked;\n+\n+  internal_memset(&sanitizer_zone, 0, sizeof(malloc_zone_t));\n+\n+  // Use version 6 for OSX >= 10.6.\n+  sanitizer_zone.version = 6;\n+  sanitizer_zone.zone_name = COMMON_MALLOC_ZONE_NAME;\n+  sanitizer_zone.size = &__sanitizer_mz_size;\n+  sanitizer_zone.malloc = &__sanitizer_mz_malloc;\n+  sanitizer_zone.calloc = &__sanitizer_mz_calloc;\n+  sanitizer_zone.valloc = &__sanitizer_mz_valloc;\n+  sanitizer_zone.free = &__sanitizer_mz_free;\n+  sanitizer_zone.realloc = &__sanitizer_mz_realloc;\n+  sanitizer_zone.destroy = &__sanitizer_mz_destroy;\n+  sanitizer_zone.batch_malloc = 0;\n+  sanitizer_zone.batch_free = 0;\n+  sanitizer_zone.free_definite_size = 0;\n+  sanitizer_zone.memalign = &__sanitizer_mz_memalign;\n+  sanitizer_zone.introspect = &sanitizer_zone_introspection;\n+\n+  // Register the zone.\n+  malloc_zone_register(&sanitizer_zone);\n+}\n+\n+}  // namespace COMMON_MALLOC_NAMESPACE"}, {"sha": "7d0ff2896e954d5c3040736476757290a7f77b7c", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -95,24 +95,17 @@\n // For such platforms build this code with -DSANITIZER_CAN_USE_ALLOCATOR64=0 or\n // change the definition of SANITIZER_CAN_USE_ALLOCATOR64 here.\n #ifndef SANITIZER_CAN_USE_ALLOCATOR64\n-# if defined(__mips64) || (defined(__aarch64__) && SANITIZER_AARCH64_VMA == 39)\n+# if defined(__mips64) || defined(__aarch64__)\n #  define SANITIZER_CAN_USE_ALLOCATOR64 0\n # else\n #  define SANITIZER_CAN_USE_ALLOCATOR64 (SANITIZER_WORDSIZE == 64)\n # endif\n #endif\n \n // The range of addresses which can be returned my mmap.\n-// FIXME: this value should be different on different platforms,\n-// e.g. on AArch64 it is most likely (1ULL << 39). Larger values will still work\n-// but will consume more memory for TwoLevelByteMap.\n-#if defined(__aarch64__)\n-# if SANITIZER_AARCH64_VMA == 39\n-#  define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 39)\n-# elif SANITIZER_AARCH64_VMA == 42\n-#  define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 42)\n-# endif\n-#elif defined(__mips__)\n+// FIXME: this value should be different on different platforms.  Larger values\n+// will still work but will consume more memory for TwoLevelByteMap.\n+#if defined(__mips__)\n # define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 40)\n #else\n # define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 47)"}, {"sha": "040e030e088becadefe529b5e877fb8ce9efc9de", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -131,7 +131,7 @@\n #define SANITIZER_INTERCEPT_READDIR64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTRACE SI_LINUX_NOT_ANDROID && \\\n   (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-    defined(__powerpc64__) || defined(__aarch64__))\n+    defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__))\n #define SANITIZER_INTERCEPT_SETLOCALE SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETCWD SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME SI_LINUX_NOT_ANDROID\n@@ -218,7 +218,7 @@\n // FIXME: getline seems to be available on OSX 10.7\n #define SANITIZER_INTERCEPT_GETLINE SI_FREEBSD || SI_LINUX_NOT_ANDROID\n \n-#define SANITIZER_INTERCEPT__EXIT SI_LINUX || SI_FREEBSD\n+#define SANITIZER_INTERCEPT__EXIT SI_LINUX || SI_FREEBSD || SI_MAC\n \n #define SANITIZER_INTERCEPT_PHTREAD_MUTEX SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP \\\n@@ -257,6 +257,7 @@\n #define SANITIZER_INTERCEPT_SEM SI_LINUX || SI_FREEBSD\n #define SANITIZER_INTERCEPT_PTHREAD_SETCANCEL SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_MINCORE SI_LINUX\n+#define SANITIZER_INTERCEPT_PROCESS_VM_READV SI_LINUX\n \n #define SANITIZER_INTERCEPTOR_HOOKS SI_LINUX\n "}, {"sha": "9866cc9e17aee84a68bf56b7c536b8d630b405cc", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -117,8 +117,11 @@\n #if SANITIZER_LINUX || SANITIZER_FREEBSD\n # include <utime.h>\n # include <sys/ptrace.h>\n-# if defined(__mips64) || defined(__aarch64__)\n+# if defined(__mips64) || defined(__aarch64__) || defined(__arm__)\n #  include <asm/ptrace.h>\n+#  ifdef __arm__\n+typedef struct user_fpregs elf_fpregset_t;\n+#  endif\n # endif\n # include <semaphore.h>\n #endif\n@@ -302,8 +305,8 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID && \\\n     (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-      defined(__powerpc64__) || defined(__aarch64__))\n-#if defined(__mips64) || defined(__powerpc64__)\n+      defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__))\n+#if defined(__mips64) || defined(__powerpc64__) || defined(__arm__)\n   unsigned struct_user_regs_struct_sz = sizeof(struct pt_regs);\n   unsigned struct_user_fpregs_struct_sz = sizeof(elf_fpregset_t);\n #elif defined(__aarch64__)\n@@ -314,36 +317,51 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned struct_user_fpregs_struct_sz = sizeof(struct user_fpregs_struct);\n #endif // __mips64 || __powerpc64__ || __aarch64__\n #if defined(__x86_64) || defined(__mips64) || defined(__powerpc64__) || \\\n-    defined(__aarch64__)\n+    defined(__aarch64__) || defined(__arm__)\n   unsigned struct_user_fpxregs_struct_sz = 0;\n #else\n   unsigned struct_user_fpxregs_struct_sz = sizeof(struct user_fpxregs_struct);\n-#endif // __x86_64 || __mips64 || __powerpc64__ || __aarch64__\n+#endif // __x86_64 || __mips64 || __powerpc64__ || __aarch64__ || __arm__\n+#ifdef __arm__\n+  unsigned struct_user_vfpregs_struct_sz = ARM_VFPREGS_SIZE;\n+#else\n+  unsigned struct_user_vfpregs_struct_sz = 0;\n+#endif\n \n   int ptrace_peektext = PTRACE_PEEKTEXT;\n   int ptrace_peekdata = PTRACE_PEEKDATA;\n   int ptrace_peekuser = PTRACE_PEEKUSER;\n-#if defined(PT_GETREGS) && defined(PT_SETREGS)\n+#if (defined(PTRACE_GETREGS) && defined(PTRACE_SETREGS)) || \\\n+    (defined(PT_GETREGS) && defined(PT_SETREGS))\n   int ptrace_getregs = PTRACE_GETREGS;\n   int ptrace_setregs = PTRACE_SETREGS;\n #else\n   int ptrace_getregs = -1;\n   int ptrace_setregs = -1;\n #endif\n-#if defined(PT_GETFPREGS) && defined(PT_SETFPREGS)\n+#if (defined(PTRACE_GETFPREGS) && defined(PTRACE_SETFPREGS)) || \\\n+    (defined(PT_GETFPREGS) && defined(PT_SETFPREGS))\n   int ptrace_getfpregs = PTRACE_GETFPREGS;\n   int ptrace_setfpregs = PTRACE_SETFPREGS;\n #else\n   int ptrace_getfpregs = -1;\n   int ptrace_setfpregs = -1;\n #endif\n-#if defined(PT_GETFPXREGS) && defined(PT_SETFPXREGS)\n+#if (defined(PTRACE_GETFPXREGS) && defined(PTRACE_SETFPXREGS)) || \\\n+    (defined(PT_GETFPXREGS) && defined(PT_SETFPXREGS))\n   int ptrace_getfpxregs = PTRACE_GETFPXREGS;\n   int ptrace_setfpxregs = PTRACE_SETFPXREGS;\n #else\n   int ptrace_getfpxregs = -1;\n   int ptrace_setfpxregs = -1;\n #endif // PTRACE_GETFPXREGS/PTRACE_SETFPXREGS\n+#if defined(PTRACE_GETVFPREGS) && defined(PTRACE_SETVFPREGS)\n+  int ptrace_getvfpregs = PTRACE_GETVFPREGS;\n+  int ptrace_setvfpregs = PTRACE_SETVFPREGS;\n+#else\n+  int ptrace_getvfpregs = -1;\n+  int ptrace_setvfpregs = -1;\n+#endif\n   int ptrace_geteventmsg = PTRACE_GETEVENTMSG;\n #if (defined(PTRACE_GETSIGINFO) && defined(PTRACE_SETSIGINFO)) ||              \\\n     (defined(PT_GETSIGINFO) && defined(PT_SETSIGINFO))"}, {"sha": "b6f90eb3a74005e8f464fa2485ee08c53bcbd4af", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -779,10 +779,11 @@ namespace __sanitizer {\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID && \\\n   (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-    defined(__powerpc64__) || defined(__aarch64__))\n+    defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__))\n   extern unsigned struct_user_regs_struct_sz;\n   extern unsigned struct_user_fpregs_struct_sz;\n   extern unsigned struct_user_fpxregs_struct_sz;\n+  extern unsigned struct_user_vfpregs_struct_sz;\n \n   extern int ptrace_peektext;\n   extern int ptrace_peekdata;\n@@ -793,6 +794,8 @@ namespace __sanitizer {\n   extern int ptrace_setfpregs;\n   extern int ptrace_getfpxregs;\n   extern int ptrace_setfpxregs;\n+  extern int ptrace_getvfpregs;\n+  extern int ptrace_setvfpregs;\n   extern int ptrace_getsiginfo;\n   extern int ptrace_setsiginfo;\n   extern int ptrace_getregset;"}, {"sha": "ed44633bc1821fcf106c86a482a759801e3ac2ea", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -117,7 +117,7 @@ void *MmapOrDie(uptr size, const char *mem_type) {\n                            MAP_PRIVATE | MAP_ANON, -1, 0);\n   int reserrno;\n   if (internal_iserror(res, &reserrno))\n-    ReportMmapFailureAndDie(size, mem_type, reserrno);\n+    ReportMmapFailureAndDie(size, mem_type, \"allocate\", reserrno);\n   IncreaseTotalMmap(size);\n   return (void *)res;\n }\n@@ -141,12 +141,8 @@ void *MmapNoReserveOrDie(uptr size, const char *mem_type) {\n                          MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,\n                          -1, 0);\n   int reserrno;\n-  if (internal_iserror(p, &reserrno)) {\n-    Report(\"ERROR: %s failed to \"\n-           \"allocate noreserve 0x%zx (%zd) bytes for '%s' (errno: %d)\\n\",\n-           SanitizerToolName, size, size, mem_type, reserrno);\n-    CHECK(\"unable to mmap\" && 0);\n-  }\n+  if (internal_iserror(p, &reserrno))\n+    ReportMmapFailureAndDie(size, mem_type, \"allocate noreserve\", reserrno);\n   IncreaseTotalMmap(size);\n   return (void *)p;\n }\n@@ -160,10 +156,10 @@ void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n       -1, 0);\n   int reserrno;\n   if (internal_iserror(p, &reserrno)) {\n-    Report(\"ERROR: %s failed to \"\n-           \"allocate 0x%zx (%zd) bytes at address %zx (errno: %d)\\n\",\n-           SanitizerToolName, size, size, fixed_addr, reserrno);\n-    CHECK(\"unable to mmap\" && 0);\n+    char mem_type[30];\n+    internal_snprintf(mem_type, sizeof(mem_type), \"memory at address 0x%zx\",\n+                      fixed_addr);\n+    ReportMmapFailureAndDie(size, mem_type, \"allocate\", reserrno);\n   }\n   IncreaseTotalMmap(size);\n   return (void *)p;"}, {"sha": "8dd259e32bafbe69d9d68c37ad08670c4322cdda", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -72,6 +72,8 @@ int real_pthread_join(void *th, void **ret);\n   }                                                                            \\\n   }  // namespace __sanitizer\n \n+int my_pthread_attr_getstack(void *attr, void **addr, uptr *size);\n+\n int internal_sigaction(int signum, const void *act, void *oldact);\n \n }  // namespace __sanitizer"}, {"sha": "4b7273b4cc034af46d3e2ea77c0d2951baca1183", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -226,7 +226,7 @@ void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n #endif\n }\n \n-#if SANITIZER_ANDROID\n+#if SANITIZER_ANDROID || SANITIZER_GO\n int GetNamedMappingFd(const char *name, uptr size) {\n   return -1;\n }\n@@ -274,6 +274,49 @@ void *MmapNoAccess(uptr fixed_addr, uptr size, const char *name) {\n   return (void *)internal_mmap((void *)fixed_addr, size, PROT_NONE, flags, fd,\n                                0);\n }\n+\n+// This function is defined elsewhere if we intercepted pthread_attr_getstack.\n+extern \"C\" {\n+SANITIZER_WEAK_ATTRIBUTE int\n+real_pthread_attr_getstack(void *attr, void **addr, size_t *size);\n+} // extern \"C\"\n+\n+int my_pthread_attr_getstack(void *attr, void **addr, uptr *size) {\n+#if !SANITIZER_GO && !SANITIZER_MAC\n+  if (&real_pthread_attr_getstack)\n+    return real_pthread_attr_getstack((pthread_attr_t *)attr, addr,\n+                                      (size_t *)size);\n+#endif\n+  return pthread_attr_getstack((pthread_attr_t *)attr, addr, (size_t *)size);\n+}\n+\n+#if !SANITIZER_GO\n+void AdjustStackSize(void *attr_) {\n+  pthread_attr_t *attr = (pthread_attr_t *)attr_;\n+  uptr stackaddr = 0;\n+  uptr stacksize = 0;\n+  my_pthread_attr_getstack(attr, (void**)&stackaddr, &stacksize);\n+  // GLibC will return (0 - stacksize) as the stack address in the case when\n+  // stacksize is set, but stackaddr is not.\n+  bool stack_set = (stackaddr != 0) && (stackaddr + stacksize != 0);\n+  // We place a lot of tool data into TLS, account for that.\n+  const uptr minstacksize = GetTlsSize() + 128*1024;\n+  if (stacksize < minstacksize) {\n+    if (!stack_set) {\n+      if (stacksize != 0) {\n+        VPrintf(1, \"Sanitizer: increasing stacksize %zu->%zu\\n\", stacksize,\n+                minstacksize);\n+        pthread_attr_setstacksize(attr, minstacksize);\n+      }\n+    } else {\n+      Printf(\"Sanitizer: pre-allocated stack size is insufficient: \"\n+             \"%zu < %zu\\n\", stacksize, minstacksize);\n+      Printf(\"Sanitizer: pthread_create is likely to fail.\\n\");\n+    }\n+  }\n+}\n+#endif // !SANITIZER_GO\n+\n } // namespace __sanitizer\n \n #endif // SANITIZER_POSIX"}, {"sha": "e65976c18d0733f62b8f9416e8dc56ac4fa0a6f9", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cc", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -35,8 +35,14 @@ bool DlAddrSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n   return true;\n }\n \n-bool DlAddrSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n-  return false;\n+bool DlAddrSymbolizer::SymbolizeData(uptr addr, DataInfo *datainfo) {\n+  Dl_info info;\n+  int result = dladdr((const void *)addr, &info);\n+  if (!result) return false;\n+  const char *demangled = DemangleCXXABI(info.dli_sname);\n+  datainfo->name = internal_strdup(demangled);\n+  datainfo->start = (uptr)info.dli_saddr;\n+  return true;\n }\n \n class AtosSymbolizerProcess : public SymbolizerProcess {\n@@ -88,15 +94,19 @@ static bool IsAtosErrorMessage(const char *str) {\n   return false;\n }\n \n-static bool ParseCommandOutput(const char *str, SymbolizedStack *res) {\n+static bool ParseCommandOutput(const char *str, uptr addr, char **out_name,\n+                               char **out_module, char **out_file, uptr *line,\n+                               uptr *start_address) {\n   // Trim ending newlines.\n   char *trim;\n   ExtractTokenUpToDelimiter(str, \"\\n\", &trim);\n \n   // The line from `atos` is in one of these formats:\n   //   myfunction (in library.dylib) (sourcefile.c:17)\n   //   myfunction (in library.dylib) + 0x1fe\n+  //   myfunction (in library.dylib) + 15\n   //   0xdeadbeef (in library.dylib) + 0x1fe\n+  //   0xdeadbeef (in library.dylib) + 15\n   //   0xdeadbeef (in library.dylib)\n   //   0xdeadbeef\n \n@@ -107,21 +117,27 @@ static bool ParseCommandOutput(const char *str, SymbolizedStack *res) {\n   }\n \n   const char *rest = trim;\n-  char *function_name;\n-  rest = ExtractTokenUpToDelimiter(rest, \" (in \", &function_name);\n-  if (internal_strncmp(function_name, \"0x\", 2) != 0)\n-    res->info.function = function_name;\n+  char *symbol_name;\n+  rest = ExtractTokenUpToDelimiter(rest, \" (in \", &symbol_name);\n+  if (internal_strncmp(symbol_name, \"0x\", 2) != 0)\n+    *out_name = symbol_name;\n   else\n-    InternalFree(function_name);\n-  rest = ExtractTokenUpToDelimiter(rest, \") \", &res->info.module);\n+    InternalFree(symbol_name);\n+  rest = ExtractTokenUpToDelimiter(rest, \") \", out_module);\n \n   if (rest[0] == '(') {\n-    rest++;\n-    rest = ExtractTokenUpToDelimiter(rest, \":\", &res->info.file);\n-    char *extracted_line_number;\n-    rest = ExtractTokenUpToDelimiter(rest, \")\", &extracted_line_number);\n-    res->info.line = internal_atoll(extracted_line_number);\n-    InternalFree(extracted_line_number);\n+    if (out_file) {\n+      rest++;\n+      rest = ExtractTokenUpToDelimiter(rest, \":\", out_file);\n+      char *extracted_line_number;\n+      rest = ExtractTokenUpToDelimiter(rest, \")\", &extracted_line_number);\n+      if (line) *line = (uptr)internal_atoll(extracted_line_number);\n+      InternalFree(extracted_line_number);\n+    }\n+  } else if (rest[0] == '+') {\n+    rest += 2;\n+    uptr offset = internal_atoll(rest);\n+    if (start_address) *start_address = addr - offset;\n   }\n \n   InternalFree(trim);\n@@ -137,14 +153,29 @@ bool AtosSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n   internal_snprintf(command, sizeof(command), \"0x%zx\\n\", addr);\n   const char *buf = process_->SendCommand(command);\n   if (!buf) return false;\n-  if (!ParseCommandOutput(buf, stack)) {\n+  uptr line;\n+  if (!ParseCommandOutput(buf, addr, &stack->info.function, &stack->info.module,\n+                          &stack->info.file, &line, nullptr)) {\n     process_ = nullptr;\n     return false;\n   }\n+  stack->info.line = (int)line;\n   return true;\n }\n \n-bool AtosSymbolizer::SymbolizeData(uptr addr, DataInfo *info) { return false; }\n+bool AtosSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n+  if (!process_) return false;\n+  char command[32];\n+  internal_snprintf(command, sizeof(command), \"0x%zx\\n\", addr);\n+  const char *buf = process_->SendCommand(command);\n+  if (!buf) return false;\n+  if (!ParseCommandOutput(buf, addr, &info->name, &info->module, nullptr,\n+                          nullptr, &info->start)) {\n+    process_ = nullptr;\n+    return false;\n+  }\n+  return true;\n+}\n \n }  // namespace __sanitizer\n "}, {"sha": "e4ff525d6b05f1b0aa08660d9b19315b7db49397", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -444,14 +444,16 @@ static void ChooseSymbolizerTools(IntrusiveList<SymbolizerTool> *list,\n \n   if (SymbolizerTool *tool = ChooseExternalSymbolizer(allocator)) {\n     list->push_back(tool);\n-  } else {\n-    VReport(2, \"No internal or external symbolizer found.\\n\");\n   }\n \n #if SANITIZER_MAC\n   VReport(2, \"Using dladdr symbolizer.\\n\");\n   list->push_back(new(*allocator) DlAddrSymbolizer());\n #endif  // SANITIZER_MAC\n+\n+  if (list->size() == 0) {\n+    Report(\"WARNING: no internal or external symbolizer found.\\n\");\n+  }\n }\n \n Symbolizer *Symbolizer::PlatformInit() {"}, {"sha": "dadb0eaaf6e8a152f34b2d70f072f4976eb63046", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -12,6 +12,7 @@\n \n #include \"sanitizer_platform.h\"\n #if SANITIZER_WINDOWS\n+#define WIN32_LEAN_AND_MEAN\n #include <windows.h>\n #include <dbghelp.h>\n #pragma comment(lib, \"dbghelp.lib\")"}, {"sha": "7c6ef4f90280b57879df4352c6e44b393f835c24", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.cc", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -76,6 +76,15 @@ void DTLS_Destroy() {\n   DTLS_Deallocate(dtls.dtv, s);\n }\n \n+#if defined(__powerpc64__)\n+// This is glibc's TLS_DTV_OFFSET:\n+// \"Dynamic thread vector pointers point 0x8000 past the start of each\n+//  TLS block.\"\n+static const uptr kDtvOffset = 0x8000;\n+#else\n+static const uptr kDtvOffset = 0;\n+#endif\n+\n DTLS::DTV *DTLS_on_tls_get_addr(void *arg_void, void *res,\n                                 uptr static_tls_begin, uptr static_tls_end) {\n   if (!common_flags()->intercept_tls_get_addr) return 0;\n@@ -85,7 +94,7 @@ DTLS::DTV *DTLS_on_tls_get_addr(void *arg_void, void *res,\n   DTLS_Resize(dso_id + 1);\n   if (dtls.dtv[dso_id].beg) return 0;\n   uptr tls_size = 0;\n-  uptr tls_beg = reinterpret_cast<uptr>(res) - arg->offset;\n+  uptr tls_beg = reinterpret_cast<uptr>(res) - arg->offset - kDtvOffset;\n   VPrintf(2, \"__tls_get_addr: %p {%p,%p} => %p; tls_beg: %p; sp: %p \"\n              \"num_live_dtls %zd\\n\",\n           arg, arg->dso_id, arg->offset, res, tls_beg, &tls_beg,"}, {"sha": "0c0a29cea445f1261110a15b4d3544ca3daaf232", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -84,7 +84,7 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n void *MmapOrDie(uptr size, const char *mem_type) {\n   void *rv = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n   if (rv == 0)\n-    ReportMmapFailureAndDie(size, mem_type, GetLastError());\n+    ReportMmapFailureAndDie(size, mem_type, \"allocate\", GetLastError());\n   return rv;\n }\n \n@@ -218,12 +218,14 @@ struct ModuleInfo {\n   uptr end_address;\n };\n \n+#ifndef SANITIZER_GO\n int CompareModulesBase(const void *pl, const void *pr) {\n   const ModuleInfo *l = (ModuleInfo *)pl, *r = (ModuleInfo *)pr;\n   if (l->base_address < r->base_address)\n     return -1;\n   return l->base_address > r->base_address;\n }\n+#endif\n }  // namespace\n \n #ifndef SANITIZER_GO\n@@ -364,6 +366,7 @@ static uptr GetPreferredBase(const char *modname) {\n   return (uptr)pe_header->ImageBase;\n }\n \n+#ifndef SANITIZER_GO\n uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n                       string_predicate_t filter) {\n   HANDLE cur_process = GetCurrentProcess();\n@@ -432,7 +435,6 @@ uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n   return count;\n };\n \n-#ifndef SANITIZER_GO\n // We can't use atexit() directly at __asan_init time as the CRT is not fully\n // initialized at this point.  Place the functions into a vector and use\n // atexit() as soon as it is ready for use (i.e. after .CRT$XIC initializers)."}, {"sha": "6776923363a3a5a77b7a7ed2ba8315f0e752018f", "filename": "libsanitizer/tsan/Makefile.am", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.am?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -21,13 +21,16 @@ tsan_files = \\\n \ttsan_interface_atomic.cc \\\n \ttsan_interface.cc \\\n \ttsan_interface_java.cc \\\n+\ttsan_libdispatch_mac.cc \\\n+\ttsan_malloc_mac.cc \\\n \ttsan_md5.cc \\\n \ttsan_mman.cc \\\n \ttsan_mutex.cc \\\n \ttsan_mutexset.cc \\\n \ttsan_new_delete.cc \\\n \ttsan_platform_linux.cc \\\n \ttsan_platform_mac.cc \\\n+\ttsan_platform_posix.cc \\\n \ttsan_platform_windows.cc \\\n \ttsan_report.cc \\\n \ttsan_rtl.cc \\\n@@ -41,7 +44,7 @@ tsan_files = \\\n \ttsan_sync.cc \n \n libtsan_la_SOURCES = $(tsan_files)\n-EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S\n+EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S tsan_rtl_aarch64.S\n libtsan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(TSAN_TARGET_DEPENDENT_OBJECTS)\n libtsan_la_DEPENDENCIES = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(TSAN_TARGET_DEPENDENT_OBJECTS)\n if LIBBACKTRACE_SUPPORTED"}, {"sha": "14a4202e32775c074f92459134a693b67e16b3aa", "filename": "libsanitizer/tsan/Makefile.in", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.in?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -107,12 +107,14 @@ am__DEPENDENCIES_1 =\n am__objects_1 = tsan_clock.lo tsan_fd.lo tsan_flags.lo \\\n \ttsan_ignoreset.lo tsan_interceptors.lo tsan_interface_ann.lo \\\n \ttsan_interface_atomic.lo tsan_interface.lo \\\n-\ttsan_interface_java.lo tsan_md5.lo tsan_mman.lo tsan_mutex.lo \\\n+\ttsan_interface_java.lo tsan_libdispatch_mac.lo \\\n+\ttsan_malloc_mac.lo tsan_md5.lo tsan_mman.lo tsan_mutex.lo \\\n \ttsan_mutexset.lo tsan_new_delete.lo tsan_platform_linux.lo \\\n-\ttsan_platform_mac.lo tsan_platform_windows.lo tsan_report.lo \\\n-\ttsan_rtl.lo tsan_rtl_mutex.lo tsan_rtl_report.lo \\\n-\ttsan_rtl_thread.lo tsan_stack_trace.lo tsan_stat.lo \\\n-\ttsan_suppressions.lo tsan_symbolize.lo tsan_sync.lo\n+\ttsan_platform_mac.lo tsan_platform_posix.lo \\\n+\ttsan_platform_windows.lo tsan_report.lo tsan_rtl.lo \\\n+\ttsan_rtl_mutex.lo tsan_rtl_report.lo tsan_rtl_thread.lo \\\n+\ttsan_stack_trace.lo tsan_stat.lo tsan_suppressions.lo \\\n+\ttsan_symbolize.lo tsan_sync.lo\n am_libtsan_la_OBJECTS = $(am__objects_1)\n libtsan_la_OBJECTS = $(am_libtsan_la_OBJECTS)\n libtsan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -318,13 +320,16 @@ tsan_files = \\\n \ttsan_interface_atomic.cc \\\n \ttsan_interface.cc \\\n \ttsan_interface_java.cc \\\n+\ttsan_libdispatch_mac.cc \\\n+\ttsan_malloc_mac.cc \\\n \ttsan_md5.cc \\\n \ttsan_mman.cc \\\n \ttsan_mutex.cc \\\n \ttsan_mutexset.cc \\\n \ttsan_new_delete.cc \\\n \ttsan_platform_linux.cc \\\n \ttsan_platform_mac.cc \\\n+\ttsan_platform_posix.cc \\\n \ttsan_platform_windows.cc \\\n \ttsan_report.cc \\\n \ttsan_rtl.cc \\\n@@ -338,7 +343,7 @@ tsan_files = \\\n \ttsan_sync.cc \n \n libtsan_la_SOURCES = $(tsan_files)\n-EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S\n+EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S tsan_rtl_aarch64.S\n libtsan_la_LIBADD =  \\\n \t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n \t$(top_builddir)/interception/libinterception.la \\\n@@ -473,16 +478,20 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interface_ann.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interface_atomic.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interface_java.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_libdispatch_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_malloc_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_md5.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_mman.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_mutex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_mutexset.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_new_delete.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_platform_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_platform_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_platform_posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_platform_windows.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_report.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_aarch64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_amd64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_mutex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_report.Plo@am__quote@"}, {"sha": "037afc83fc6c660c777254a40788af199cd743ba", "filename": "libsanitizer/tsan/tsan_clock.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_clock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_clock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -88,8 +88,6 @@\n \n namespace __tsan {\n \n-const unsigned kInvalidTid = (unsigned)-1;\n-\n ThreadClock::ThreadClock(unsigned tid, unsigned reused)\n     : tid_(tid)\n     , reused_(reused + 1) {  // 0 has special meaning"}, {"sha": "259b30bee5db88f03863ae8052df19c65e84ba7b", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -81,6 +81,8 @@ const bool kCollectHistory = false;\n const bool kCollectHistory = true;\n #endif\n \n+const unsigned kInvalidTid = (unsigned)-1;\n+\n // The following \"build consistency\" machinery ensures that all source files\n // are built in the same configuration. Inconsistent builds lead to\n // hard to debug crashes."}, {"sha": "4cec0ac09f41648f6bd0e898b2d75294ded5cece", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -59,9 +59,13 @@ void InitializeFlags(Flags *f, const char *env) {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n     cf.allow_addr2line = true;\n-#ifndef SANITIZER_GO\n-    cf.detect_deadlocks = true;\n-#endif\n+    if (kGoMode) {\n+      // Does not work as expected for Go: runtime handles SIGABRT and crashes.\n+      cf.abort_on_error = false;\n+      // Go does not have mutexes.\n+    } else {\n+      cf.detect_deadlocks = true;\n+    }\n     cf.print_suppressions = false;\n     cf.stack_trace_format = \"    #%n %f %S %M\";\n     cf.exitcode = 66;"}, {"sha": "90c1d7bf2436540cf7895cad80ee9ab2534255b9", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 131, "deletions": 66, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -26,16 +26,28 @@\n #include \"tsan_mman.h\"\n #include \"tsan_fd.h\"\n \n+#if SANITIZER_POSIX\n+#include \"sanitizer_common/sanitizer_posix.h\"\n+#endif\n+\n using namespace __tsan;  // NOLINT\n \n-#if SANITIZER_FREEBSD\n+#if SANITIZER_FREEBSD || SANITIZER_MAC\n #define __errno_location __error\n-#define __libc_realloc __realloc\n-#define __libc_calloc __calloc\n #define stdout __stdoutp\n #define stderr __stderrp\n #endif\n \n+#if SANITIZER_FREEBSD\n+#define __libc_realloc __realloc\n+#define __libc_calloc __calloc\n+#elif SANITIZER_MAC\n+#define __libc_malloc REAL(malloc)\n+#define __libc_realloc REAL(realloc)\n+#define __libc_calloc REAL(calloc)\n+#define __libc_free REAL(free)\n+#endif\n+\n #if SANITIZER_LINUX || SANITIZER_FREEBSD\n #define PTHREAD_CREATE_DETACHED 1\n #elif SANITIZER_MAC\n@@ -78,12 +90,13 @@ extern \"C\" int pthread_attr_setstacksize(void *attr, uptr stacksize);\n extern \"C\" int pthread_key_create(unsigned *key, void (*destructor)(void* v));\n extern \"C\" int pthread_setspecific(unsigned key, const void *v);\n DECLARE_REAL(int, pthread_mutexattr_gettype, void *, void *)\n-extern \"C\" int pthread_yield();\n extern \"C\" int pthread_sigmask(int how, const __sanitizer_sigset_t *set,\n                                __sanitizer_sigset_t *oldset);\n // REAL(sigfillset) defined in common interceptors.\n DECLARE_REAL(int, sigfillset, __sanitizer_sigset_t *set)\n DECLARE_REAL(int, fflush, __sanitizer_FILE *fp)\n+DECLARE_REAL_AND_INTERCEPTOR(void *, malloc, uptr size)\n+DECLARE_REAL_AND_INTERCEPTOR(void, free, void *ptr)\n extern \"C\" void *pthread_self();\n extern \"C\" void _exit(int status);\n extern \"C\" int *__errno_location();\n@@ -100,7 +113,9 @@ const int PTHREAD_MUTEX_RECURSIVE_NP = 1;\n const int EINVAL = 22;\n const int EBUSY = 16;\n const int EOWNERDEAD = 130;\n+#if !SANITIZER_MAC\n const int EPOLL_CTL_ADD = 1;\n+#endif\n const int SIGILL = 4;\n const int SIGABRT = 6;\n const int SIGFPE = 8;\n@@ -115,7 +130,9 @@ const int SIGBUS = 7;\n const int SIGSYS = 31;\n #endif\n void *const MAP_FAILED = (void*)-1;\n+#if !SANITIZER_MAC\n const int PTHREAD_BARRIER_SERIAL_THREAD = -1;\n+#endif\n const int MAP_FIXED = 0x10;\n typedef long long_t;  // NOLINT\n \n@@ -245,17 +262,6 @@ ScopedInterceptor::~ScopedInterceptor() {\n   }\n }\n \n-#define SCOPED_TSAN_INTERCEPTOR(func, ...) \\\n-    SCOPED_INTERCEPTOR_RAW(func, __VA_ARGS__); \\\n-    if (REAL(func) == 0) { \\\n-      Report(\"FATAL: ThreadSanitizer: failed to intercept %s\\n\", #func); \\\n-      Die(); \\\n-    }                                                    \\\n-    if (thr->ignore_interceptors || thr->in_ignored_lib) \\\n-      return REAL(func)(__VA_ARGS__); \\\n-/**/\n-\n-#define TSAN_INTERCEPTOR(ret, func, ...) INTERCEPTOR(ret, func, __VA_ARGS__)\n #define TSAN_INTERCEPT(func) INTERCEPT_FUNCTION(func)\n #if SANITIZER_FREEBSD\n # define TSAN_INTERCEPT_VER(func, ver) INTERCEPT_FUNCTION(func)\n@@ -370,6 +376,7 @@ static int setup_at_exit_wrapper(ThreadState *thr, uptr pc, void(*f)(),\n   return res;\n }\n \n+#if !SANITIZER_MAC\n static void on_exit_wrapper(int status, void *arg) {\n   ThreadState *thr = cur_thread();\n   uptr pc = 0;\n@@ -394,6 +401,7 @@ TSAN_INTERCEPTOR(int, on_exit, void(*f)(int, void*), void *arg) {\n   ThreadIgnoreEnd(thr, pc);\n   return res;\n }\n+#endif\n \n // Cleanup old bufs.\n static void JmpBufGarbageCollect(ThreadState *thr, uptr sp) {\n@@ -430,8 +438,12 @@ static void SetJmp(ThreadState *thr, uptr sp, uptr mangled_sp) {\n static void LongJmp(ThreadState *thr, uptr *env) {\n #if SANITIZER_FREEBSD\n   uptr mangled_sp = env[2];\n-#else\n+#elif defined(SANITIZER_LINUX)\n+# ifdef __aarch64__\n+  uptr mangled_sp = env[13];\n+# else\n   uptr mangled_sp = env[6];\n+# endif\n #endif  // SANITIZER_FREEBSD\n   // Find the saved buf by mangled_sp.\n   for (uptr i = 0; i < thr->jmp_bufs.Size(); i++) {\n@@ -517,6 +529,7 @@ TSAN_INTERCEPTOR(void, siglongjmp, uptr *env, int val) {\n   REAL(siglongjmp)(env, val);\n }\n \n+#if !SANITIZER_MAC\n TSAN_INTERCEPTOR(void*, malloc, uptr size) {\n   if (cur_thread()->in_symbolizer)\n     return __libc_malloc(size);\n@@ -583,6 +596,7 @@ TSAN_INTERCEPTOR(uptr, malloc_usable_size, void *p) {\n   SCOPED_INTERCEPTOR_RAW(malloc_usable_size, p);\n   return user_alloc_usable_size(p);\n }\n+#endif\n \n TSAN_INTERCEPTOR(uptr, strlen, const char *s) {\n   SCOPED_TSAN_INTERCEPTOR(strlen, s);\n@@ -607,13 +621,18 @@ TSAN_INTERCEPTOR(void*, memcpy, void *dst, const void *src, uptr size) {\n     MemoryAccessRange(thr, pc, (uptr)dst, size, true);\n     MemoryAccessRange(thr, pc, (uptr)src, size, false);\n   }\n-  return internal_memcpy(dst, src, size);\n+  // On OS X, calling internal_memcpy here will cause memory corruptions,\n+  // because memcpy and memmove are actually aliases of the same implementation.\n+  // We need to use internal_memmove here.\n+  return internal_memmove(dst, src, size);\n }\n \n TSAN_INTERCEPTOR(void*, memmove, void *dst, void *src, uptr n) {\n-  SCOPED_TSAN_INTERCEPTOR(memmove, dst, src, n);\n-  MemoryAccessRange(thr, pc, (uptr)dst, n, true);\n-  MemoryAccessRange(thr, pc, (uptr)src, n, false);\n+  if (!COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED) {\n+    SCOPED_TSAN_INTERCEPTOR(memmove, dst, src, n);\n+    MemoryAccessRange(thr, pc, (uptr)dst, n, true);\n+    MemoryAccessRange(thr, pc, (uptr)src, n, false);\n+  }\n   return REAL(memmove)(dst, src, n);\n }\n \n@@ -626,13 +645,15 @@ TSAN_INTERCEPTOR(char*, strchr, char *s, int c) {\n   return res;\n }\n \n+#if !SANITIZER_MAC\n TSAN_INTERCEPTOR(char*, strchrnul, char *s, int c) {\n   SCOPED_TSAN_INTERCEPTOR(strchrnul, s, c);\n   char *res = REAL(strchrnul)(s, c);\n   uptr len = (char*)res - (char*)s + 1;\n   READ_STRING(thr, pc, s, len);\n   return res;\n }\n+#endif\n \n TSAN_INTERCEPTOR(char*, strrchr, char *s, int c) {\n   SCOPED_TSAN_INTERCEPTOR(strrchr, s, c);\n@@ -676,8 +697,8 @@ static bool fix_mmap_addr(void **addr, long_t sz, int flags) {\n   return true;\n }\n \n-TSAN_INTERCEPTOR(void*, mmap, void *addr, long_t sz, int prot,\n-                         int flags, int fd, unsigned off) {\n+TSAN_INTERCEPTOR(void *, mmap, void *addr, SIZE_T sz, int prot, int flags,\n+                 int fd, OFF_T off) {\n   SCOPED_TSAN_INTERCEPTOR(mmap, addr, sz, prot, flags, fd, off);\n   if (!fix_mmap_addr(&addr, sz, flags))\n     return MAP_FAILED;\n@@ -690,9 +711,9 @@ TSAN_INTERCEPTOR(void*, mmap, void *addr, long_t sz, int prot,\n   return res;\n }\n \n-#if !SANITIZER_FREEBSD\n-TSAN_INTERCEPTOR(void*, mmap64, void *addr, long_t sz, int prot,\n-                           int flags, int fd, u64 off) {\n+#if SANITIZER_LINUX\n+TSAN_INTERCEPTOR(void *, mmap64, void *addr, SIZE_T sz, int prot, int flags,\n+                 int fd, OFF64_T off) {\n   SCOPED_TSAN_INTERCEPTOR(mmap64, addr, sz, prot, flags, fd, off);\n   if (!fix_mmap_addr(&addr, sz, flags))\n     return MAP_FAILED;\n@@ -720,7 +741,7 @@ TSAN_INTERCEPTOR(int, munmap, void *addr, long_t sz) {\n   return res;\n }\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(void*, memalign, uptr align, uptr sz) {\n   SCOPED_INTERCEPTOR_RAW(memalign, align, sz);\n   return user_alloc(thr, pc, sz, align);\n@@ -730,6 +751,7 @@ TSAN_INTERCEPTOR(void*, memalign, uptr align, uptr sz) {\n #define TSAN_MAYBE_INTERCEPT_MEMALIGN\n #endif\n \n+#if !SANITIZER_MAC\n TSAN_INTERCEPTOR(void*, aligned_alloc, uptr align, uptr sz) {\n   SCOPED_INTERCEPTOR_RAW(memalign, align, sz);\n   return user_alloc(thr, pc, sz, align);\n@@ -739,8 +761,9 @@ TSAN_INTERCEPTOR(void*, valloc, uptr sz) {\n   SCOPED_INTERCEPTOR_RAW(valloc, sz);\n   return user_alloc(thr, pc, sz, GetPageSizeCached());\n }\n+#endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(void*, pvalloc, uptr sz) {\n   SCOPED_INTERCEPTOR_RAW(pvalloc, sz);\n   sz = RoundUp(sz, GetPageSizeCached());\n@@ -751,11 +774,13 @@ TSAN_INTERCEPTOR(void*, pvalloc, uptr sz) {\n #define TSAN_MAYBE_INTERCEPT_PVALLOC\n #endif\n \n+#if !SANITIZER_MAC\n TSAN_INTERCEPTOR(int, posix_memalign, void **memptr, uptr align, uptr sz) {\n   SCOPED_INTERCEPTOR_RAW(posix_memalign, memptr, align, sz);\n   *memptr = user_alloc(thr, pc, sz, align);\n   return 0;\n }\n+#endif\n \n // Used in thread-safe function static initialization.\n extern \"C\" int INTERFACE_ATTRIBUTE __cxa_guard_acquire(atomic_uint32_t *g) {\n@@ -785,6 +810,19 @@ extern \"C\" void INTERFACE_ATTRIBUTE __cxa_guard_abort(atomic_uint32_t *g) {\n   atomic_store(g, 0, memory_order_relaxed);\n }\n \n+namespace __tsan {\n+void DestroyThreadState() {\n+  ThreadState *thr = cur_thread();\n+  ThreadFinish(thr);\n+  ThreadSignalContext *sctx = thr->signal_ctx;\n+  if (sctx) {\n+    thr->signal_ctx = 0;\n+    UnmapOrDie(sctx, sizeof(*sctx));\n+  }\n+  cur_thread_finalize();\n+}\n+}  // namespace __tsan\n+\n static void thread_finalize(void *v) {\n   uptr iter = (uptr)v;\n   if (iter > 1) {\n@@ -794,15 +832,7 @@ static void thread_finalize(void *v) {\n     }\n     return;\n   }\n-  {\n-    ThreadState *thr = cur_thread();\n-    ThreadFinish(thr);\n-    ThreadSignalContext *sctx = thr->signal_ctx;\n-    if (sctx) {\n-      thr->signal_ctx = 0;\n-      UnmapOrDie(sctx, sizeof(*sctx));\n-    }\n-  }\n+  DestroyThreadState();\n }\n \n \n@@ -829,7 +859,7 @@ extern \"C\" void *__tsan_thread_start_func(void *arg) {\n     }\n     ThreadIgnoreEnd(thr, 0);\n     while ((tid = atomic_load(&p->tid, memory_order_acquire)) == 0)\n-      pthread_yield();\n+      internal_sched_yield();\n     ThreadStart(thr, tid, GetTid());\n     atomic_store(&p->tid, 0, memory_order_release);\n   }\n@@ -889,7 +919,7 @@ TSAN_INTERCEPTOR(int, pthread_create,\n     //    before the new thread got a chance to acquire from it in ThreadStart.\n     atomic_store(&p.tid, tid, memory_order_release);\n     while (atomic_load(&p.tid, memory_order_acquire) != 0)\n-      pthread_yield();\n+      internal_sched_yield();\n   }\n   if (attr == &myattr)\n     pthread_attr_destroy(&myattr);\n@@ -1092,6 +1122,7 @@ TSAN_INTERCEPTOR(int, pthread_mutex_trylock, void *m) {\n   return res;\n }\n \n+#if !SANITIZER_MAC\n TSAN_INTERCEPTOR(int, pthread_mutex_timedlock, void *m, void *abstime) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_mutex_timedlock, m, abstime);\n   int res = REAL(pthread_mutex_timedlock)(m, abstime);\n@@ -1100,7 +1131,9 @@ TSAN_INTERCEPTOR(int, pthread_mutex_timedlock, void *m, void *abstime) {\n   }\n   return res;\n }\n+#endif\n \n+#if !SANITIZER_MAC\n TSAN_INTERCEPTOR(int, pthread_spin_init, void *m, int pshared) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_spin_init, m, pshared);\n   int res = REAL(pthread_spin_init)(m, pshared);\n@@ -1143,6 +1176,7 @@ TSAN_INTERCEPTOR(int, pthread_spin_unlock, void *m) {\n   int res = REAL(pthread_spin_unlock)(m);\n   return res;\n }\n+#endif\n \n TSAN_INTERCEPTOR(int, pthread_rwlock_init, void *m, void *a) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_init, m, a);\n@@ -1180,6 +1214,7 @@ TSAN_INTERCEPTOR(int, pthread_rwlock_tryrdlock, void *m) {\n   return res;\n }\n \n+#if !SANITIZER_MAC\n TSAN_INTERCEPTOR(int, pthread_rwlock_timedrdlock, void *m, void *abstime) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_timedrdlock, m, abstime);\n   int res = REAL(pthread_rwlock_timedrdlock)(m, abstime);\n@@ -1188,6 +1223,7 @@ TSAN_INTERCEPTOR(int, pthread_rwlock_timedrdlock, void *m, void *abstime) {\n   }\n   return res;\n }\n+#endif\n \n TSAN_INTERCEPTOR(int, pthread_rwlock_wrlock, void *m) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_wrlock, m);\n@@ -1207,6 +1243,7 @@ TSAN_INTERCEPTOR(int, pthread_rwlock_trywrlock, void *m) {\n   return res;\n }\n \n+#if !SANITIZER_MAC\n TSAN_INTERCEPTOR(int, pthread_rwlock_timedwrlock, void *m, void *abstime) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_timedwrlock, m, abstime);\n   int res = REAL(pthread_rwlock_timedwrlock)(m, abstime);\n@@ -1215,6 +1252,7 @@ TSAN_INTERCEPTOR(int, pthread_rwlock_timedwrlock, void *m, void *abstime) {\n   }\n   return res;\n }\n+#endif\n \n TSAN_INTERCEPTOR(int, pthread_rwlock_unlock, void *m) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_unlock, m);\n@@ -1223,6 +1261,7 @@ TSAN_INTERCEPTOR(int, pthread_rwlock_unlock, void *m) {\n   return res;\n }\n \n+#if !SANITIZER_MAC\n TSAN_INTERCEPTOR(int, pthread_barrier_init, void *b, void *a, unsigned count) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_barrier_init, b, a, count);\n   MemoryWrite(thr, pc, (uptr)b, kSizeLog1);\n@@ -1248,12 +1287,17 @@ TSAN_INTERCEPTOR(int, pthread_barrier_wait, void *b) {\n   }\n   return res;\n }\n+#endif\n \n TSAN_INTERCEPTOR(int, pthread_once, void *o, void (*f)()) {\n   SCOPED_INTERCEPTOR_RAW(pthread_once, o, f);\n   if (o == 0 || f == 0)\n     return EINVAL;\n-  atomic_uint32_t *a = static_cast<atomic_uint32_t*>(o);\n+  atomic_uint32_t *a;\n+  if (!SANITIZER_MAC)\n+    a = static_cast<atomic_uint32_t*>(o);\n+  else  // On OS X, pthread_once_t has a header with a long-sized signature.\n+    a = static_cast<atomic_uint32_t*>((void *)((char *)o + sizeof(long_t)));\n   u32 v = atomic_load(a, memory_order_acquire);\n   if (v == 0 && atomic_compare_exchange_strong(a, &v, 1,\n                                                memory_order_relaxed)) {\n@@ -1263,7 +1307,7 @@ TSAN_INTERCEPTOR(int, pthread_once, void *o, void (*f)()) {\n     atomic_store(a, 2, memory_order_release);\n   } else {\n     while (v != 2) {\n-      pthread_yield();\n+      internal_sched_yield();\n       v = atomic_load(a, memory_order_acquire);\n     }\n     if (!thr->in_ignored_lib)\n@@ -1272,7 +1316,7 @@ TSAN_INTERCEPTOR(int, pthread_once, void *o, void (*f)()) {\n   return 0;\n }\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, __xstat, int version, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__xstat, version, path, buf);\n   READ_STRING(thr, pc, path, 0);\n@@ -1284,7 +1328,7 @@ TSAN_INTERCEPTOR(int, __xstat, int version, const char *path, void *buf) {\n #endif\n \n TSAN_INTERCEPTOR(int, stat, const char *path, void *buf) {\n-#if SANITIZER_FREEBSD\n+#if SANITIZER_FREEBSD || SANITIZER_MAC\n   SCOPED_TSAN_INTERCEPTOR(stat, path, buf);\n   READ_STRING(thr, pc, path, 0);\n   return REAL(stat)(path, buf);\n@@ -1295,7 +1339,7 @@ TSAN_INTERCEPTOR(int, stat, const char *path, void *buf) {\n #endif\n }\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, __xstat64, int version, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__xstat64, version, path, buf);\n   READ_STRING(thr, pc, path, 0);\n@@ -1306,7 +1350,7 @@ TSAN_INTERCEPTOR(int, __xstat64, int version, const char *path, void *buf) {\n #define TSAN_MAYBE_INTERCEPT___XSTAT64\n #endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, stat64, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__xstat64, 0, path, buf);\n   READ_STRING(thr, pc, path, 0);\n@@ -1317,7 +1361,7 @@ TSAN_INTERCEPTOR(int, stat64, const char *path, void *buf) {\n #define TSAN_MAYBE_INTERCEPT_STAT64\n #endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, __lxstat, int version, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__lxstat, version, path, buf);\n   READ_STRING(thr, pc, path, 0);\n@@ -1329,7 +1373,7 @@ TSAN_INTERCEPTOR(int, __lxstat, int version, const char *path, void *buf) {\n #endif\n \n TSAN_INTERCEPTOR(int, lstat, const char *path, void *buf) {\n-#if SANITIZER_FREEBSD\n+#if SANITIZER_FREEBSD || SANITIZER_MAC\n   SCOPED_TSAN_INTERCEPTOR(lstat, path, buf);\n   READ_STRING(thr, pc, path, 0);\n   return REAL(lstat)(path, buf);\n@@ -1340,7 +1384,7 @@ TSAN_INTERCEPTOR(int, lstat, const char *path, void *buf) {\n #endif\n }\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, __lxstat64, int version, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__lxstat64, version, path, buf);\n   READ_STRING(thr, pc, path, 0);\n@@ -1351,7 +1395,7 @@ TSAN_INTERCEPTOR(int, __lxstat64, int version, const char *path, void *buf) {\n #define TSAN_MAYBE_INTERCEPT___LXSTAT64\n #endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, lstat64, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__lxstat64, 0, path, buf);\n   READ_STRING(thr, pc, path, 0);\n@@ -1362,7 +1406,7 @@ TSAN_INTERCEPTOR(int, lstat64, const char *path, void *buf) {\n #define TSAN_MAYBE_INTERCEPT_LSTAT64\n #endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, __fxstat, int version, int fd, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__fxstat, version, fd, buf);\n   if (fd > 0)\n@@ -1375,7 +1419,7 @@ TSAN_INTERCEPTOR(int, __fxstat, int version, int fd, void *buf) {\n #endif\n \n TSAN_INTERCEPTOR(int, fstat, int fd, void *buf) {\n-#if SANITIZER_FREEBSD\n+#if SANITIZER_FREEBSD || SANITIZER_MAC\n   SCOPED_TSAN_INTERCEPTOR(fstat, fd, buf);\n   if (fd > 0)\n     FdAccess(thr, pc, fd);\n@@ -1388,7 +1432,7 @@ TSAN_INTERCEPTOR(int, fstat, int fd, void *buf) {\n #endif\n }\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, __fxstat64, int version, int fd, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__fxstat64, version, fd, buf);\n   if (fd > 0)\n@@ -1400,7 +1444,7 @@ TSAN_INTERCEPTOR(int, __fxstat64, int version, int fd, void *buf) {\n #define TSAN_MAYBE_INTERCEPT___FXSTAT64\n #endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, fstat64, int fd, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__fxstat64, 0, fd, buf);\n   if (fd > 0)\n@@ -1421,7 +1465,7 @@ TSAN_INTERCEPTOR(int, open, const char *name, int flags, int mode) {\n   return fd;\n }\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, open64, const char *name, int flags, int mode) {\n   SCOPED_TSAN_INTERCEPTOR(open64, name, flags, mode);\n   READ_STRING(thr, pc, name, 0);\n@@ -1444,7 +1488,7 @@ TSAN_INTERCEPTOR(int, creat, const char *name, int mode) {\n   return fd;\n }\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, creat64, const char *name, int mode) {\n   SCOPED_TSAN_INTERCEPTOR(creat64, name, mode);\n   READ_STRING(thr, pc, name, 0);\n@@ -1474,15 +1518,17 @@ TSAN_INTERCEPTOR(int, dup2, int oldfd, int newfd) {\n   return newfd2;\n }\n \n+#if !SANITIZER_MAC\n TSAN_INTERCEPTOR(int, dup3, int oldfd, int newfd, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(dup3, oldfd, newfd, flags);\n   int newfd2 = REAL(dup3)(oldfd, newfd, flags);\n   if (oldfd >= 0 && newfd2 >= 0 && newfd2 != oldfd)\n     FdDup(thr, pc, oldfd, newfd2, false);\n   return newfd2;\n }\n+#endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, eventfd, unsigned initval, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(eventfd, initval, flags);\n   int fd = REAL(eventfd)(initval, flags);\n@@ -1495,7 +1541,7 @@ TSAN_INTERCEPTOR(int, eventfd, unsigned initval, int flags) {\n #define TSAN_MAYBE_INTERCEPT_EVENTFD\n #endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, signalfd, int fd, void *mask, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(signalfd, fd, mask, flags);\n   if (fd >= 0)\n@@ -1510,7 +1556,7 @@ TSAN_INTERCEPTOR(int, signalfd, int fd, void *mask, int flags) {\n #define TSAN_MAYBE_INTERCEPT_SIGNALFD\n #endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, inotify_init, int fake) {\n   SCOPED_TSAN_INTERCEPTOR(inotify_init, fake);\n   int fd = REAL(inotify_init)(fake);\n@@ -1523,7 +1569,7 @@ TSAN_INTERCEPTOR(int, inotify_init, int fake) {\n #define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT\n #endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, inotify_init1, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(inotify_init1, flags);\n   int fd = REAL(inotify_init1)(flags);\n@@ -1577,7 +1623,7 @@ TSAN_INTERCEPTOR(int, listen, int fd, int backlog) {\n   return res;\n }\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, epoll_create, int size) {\n   SCOPED_TSAN_INTERCEPTOR(epoll_create, size);\n   int fd = REAL(epoll_create)(size);\n@@ -1590,7 +1636,7 @@ TSAN_INTERCEPTOR(int, epoll_create, int size) {\n #define TSAN_MAYBE_INTERCEPT_EPOLL_CREATE\n #endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, epoll_create1, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(epoll_create1, flags);\n   int fd = REAL(epoll_create1)(flags);\n@@ -1610,7 +1656,7 @@ TSAN_INTERCEPTOR(int, close, int fd) {\n   return REAL(close)(fd);\n }\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, __close, int fd) {\n   SCOPED_TSAN_INTERCEPTOR(__close, fd);\n   if (fd >= 0)\n@@ -1623,7 +1669,7 @@ TSAN_INTERCEPTOR(int, __close, int fd) {\n #endif\n \n // glibc guts\n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(void, __res_iclose, void *state, bool free_addr) {\n   SCOPED_TSAN_INTERCEPTOR(__res_iclose, state, free_addr);\n   int fds[64];\n@@ -1647,13 +1693,15 @@ TSAN_INTERCEPTOR(int, pipe, int *pipefd) {\n   return res;\n }\n \n+#if !SANITIZER_MAC\n TSAN_INTERCEPTOR(int, pipe2, int *pipefd, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(pipe2, pipefd, flags);\n   int res = REAL(pipe2)(pipefd, flags);\n   if (res == 0 && pipefd[0] >= 0 && pipefd[1] >= 0)\n     FdPipeCreate(thr, pc, pipefd[0], pipefd[1]);\n   return res;\n }\n+#endif\n \n TSAN_INTERCEPTOR(long_t, send, int fd, void *buf, long_t len, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(send, fd, buf, len, flags);\n@@ -1704,7 +1752,7 @@ TSAN_INTERCEPTOR(void*, tmpfile, int fake) {\n   return res;\n }\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(void*, tmpfile64, int fake) {\n   SCOPED_TSAN_INTERCEPTOR(tmpfile64, fake);\n   void *res = REAL(tmpfile64)(fake);\n@@ -1771,7 +1819,7 @@ TSAN_INTERCEPTOR(int, closedir, void *dirp) {\n   return REAL(closedir)(dirp);\n }\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, epoll_ctl, int epfd, int op, int fd, void *ev) {\n   SCOPED_TSAN_INTERCEPTOR(epoll_ctl, epfd, op, fd, ev);\n   if (epfd >= 0)\n@@ -1788,7 +1836,7 @@ TSAN_INTERCEPTOR(int, epoll_ctl, int epfd, int op, int fd, void *ev) {\n #define TSAN_MAYBE_INTERCEPT_EPOLL_CTL\n #endif\n \n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n TSAN_INTERCEPTOR(int, epoll_wait, int epfd, void *ev, int cnt, int timeout) {\n   SCOPED_TSAN_INTERCEPTOR(epoll_wait, epfd, ev, cnt, timeout);\n   if (epfd >= 0)\n@@ -2087,6 +2135,7 @@ TSAN_INTERCEPTOR(int, vfork, int fake) {\n   return WRAP(fork)(fake);\n }\n \n+#if !SANITIZER_MAC\n typedef int (*dl_iterate_phdr_cb_t)(__sanitizer_dl_phdr_info *info, SIZE_T size,\n                                     void *data);\n struct dl_iterate_phdr_data {\n@@ -2130,6 +2179,7 @@ TSAN_INTERCEPTOR(int, dl_iterate_phdr, dl_iterate_phdr_cb_t cb, void *data) {\n   int res = REAL(dl_iterate_phdr)(dl_iterate_phdr_cb, &cbdata);\n   return res;\n }\n+#endif\n \n static int OnExit(ThreadState *thr) {\n   int status = Finalize(thr);\n@@ -2143,13 +2193,15 @@ struct TsanInterceptorContext {\n   const uptr pc;\n };\n \n+#if !SANITIZER_MAC\n static void HandleRecvmsg(ThreadState *thr, uptr pc,\n     __sanitizer_msghdr *msg) {\n   int fds[64];\n   int cnt = ExtractRecvmsgFDs(msg, fds, ARRAY_SIZE(fds));\n   for (int i = 0; i < cnt; i++)\n     FdEventCreate(thr, pc, fds[i]);\n }\n+#endif\n \n #include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n // Causes interceptor recursion (getaddrinfo() and fopen())\n@@ -2264,9 +2316,11 @@ static void HandleRecvmsg(ThreadState *thr, uptr pc,\n   MutexRepair(((TsanInterceptorContext *)ctx)->thr, \\\n             ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n \n+#if !SANITIZER_MAC\n #define COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg) \\\n   HandleRecvmsg(((TsanInterceptorContext *)ctx)->thr, \\\n       ((TsanInterceptorContext *)ctx)->pc, msg)\n+#endif\n \n #define COMMON_INTERCEPTOR_GET_TLS_RANGE(begin, end)                           \\\n   if (TsanThread *t = GetCurrentThread()) {                                    \\\n@@ -2298,6 +2352,7 @@ struct ScopedSyscall {\n   }\n };\n \n+#if !SANITIZER_MAC\n static void syscall_access_range(uptr pc, uptr p, uptr s, bool write) {\n   TSAN_SYSCALL();\n   MemoryAccessRange(thr, pc, p, s, write);\n@@ -2351,6 +2406,7 @@ static void syscall_post_fork(uptr pc, int pid) {\n     ForkParentAfter(thr, pc);\n   }\n }\n+#endif\n \n #define COMMON_SYSCALL_PRE_READ_RANGE(p, s) \\\n   syscall_access_range(GET_CALLER_PC(), (uptr)(p), (uptr)(s), false)\n@@ -2401,31 +2457,37 @@ static void finalize(void *arg) {\n     Die();\n }\n \n+#if !SANITIZER_MAC\n static void unreachable() {\n   Report(\"FATAL: ThreadSanitizer: unreachable called\\n\");\n   Die();\n }\n+#endif\n \n void InitializeInterceptors() {\n+#if !SANITIZER_MAC\n   // We need to setup it early, because functions like dlsym() can call it.\n   REAL(memset) = internal_memset;\n   REAL(memcpy) = internal_memcpy;\n+#endif\n \n   // Instruct libc malloc to consume less memory.\n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n   mallopt(1, 0);  // M_MXFAST\n   mallopt(-3, 32*1024);  // M_MMAP_THRESHOLD\n #endif\n \n   InitializeCommonInterceptors();\n \n+#if !SANITIZER_MAC\n   // We can not use TSAN_INTERCEPT to get setjmp addr,\n   // because it does &setjmp and setjmp is not present in some versions of libc.\n   using __interception::GetRealFunctionAddress;\n   GetRealFunctionAddress(\"setjmp\", (uptr*)&REAL(setjmp), 0, 0);\n   GetRealFunctionAddress(\"_setjmp\", (uptr*)&REAL(_setjmp), 0, 0);\n   GetRealFunctionAddress(\"sigsetjmp\", (uptr*)&REAL(sigsetjmp), 0, 0);\n   GetRealFunctionAddress(\"__sigsetjmp\", (uptr*)&REAL(__sigsetjmp), 0, 0);\n+#endif\n \n   TSAN_INTERCEPT(longjmp);\n   TSAN_INTERCEPT(siglongjmp);\n@@ -2565,9 +2627,12 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(__cxa_atexit);\n   TSAN_INTERCEPT(_exit);\n \n+#if !SANITIZER_MAC\n   // Need to setup it, because interceptors check that the function is resolved.\n   // But atexit is emitted directly into the module, so can't be resolved.\n   REAL(atexit) = (int(*)(void(*)()))unreachable;\n+#endif\n+\n   if (REAL(__cxa_atexit)(&finalize, 0, 0)) {\n     Printf(\"ThreadSanitizer: failed to setup atexit callback\\n\");\n     Die();"}, {"sha": "ed68eb96bf815d1bdb934466d332736f773eecef", "filename": "libsanitizer/tsan/tsan_interceptors.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -24,6 +24,18 @@ class ScopedInterceptor {\n     (void)pc; \\\n /**/\n \n+#define SCOPED_TSAN_INTERCEPTOR(func, ...) \\\n+    SCOPED_INTERCEPTOR_RAW(func, __VA_ARGS__); \\\n+    if (REAL(func) == 0) { \\\n+      Report(\"FATAL: ThreadSanitizer: failed to intercept %s\\n\", #func); \\\n+      Die(); \\\n+    }                                                    \\\n+    if (thr->ignore_interceptors || thr->in_ignored_lib) \\\n+      return REAL(func)(__VA_ARGS__); \\\n+/**/\n+\n+#define TSAN_INTERCEPTOR(ret, func, ...) INTERCEPTOR(ret, func, __VA_ARGS__)\n+\n #if SANITIZER_FREEBSD\n #define __libc_free __free\n #define __libc_malloc __malloc"}, {"sha": "5b39665d5d20b8eec7fb9af3209f607c93c0f629", "filename": "libsanitizer/tsan/tsan_libdispatch_mac.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -0,0 +1,70 @@\n+//===-- tsan_libdispatch_mac.cc -------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Mac-specific libdispatch (GCD) support.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_MAC\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"interception/interception.h\"\n+#include \"tsan_interceptors.h\"\n+#include \"tsan_platform.h\"\n+#include \"tsan_rtl.h\"\n+\n+#include <dispatch/dispatch.h>\n+#include <pthread.h>\n+\n+namespace __tsan {\n+\n+// GCD's dispatch_once implementation has a fast path that contains a racy read\n+// and it's inlined into user's code. Furthermore, this fast path doesn't\n+// establish a proper happens-before relations between the initialization and\n+// code following the call to dispatch_once. We could deal with this in\n+// instrumented code, but there's not much we can do about it in system\n+// libraries. Let's disable the fast path (by never storing the value ~0 to\n+// predicate), so the interceptor is always called, and let's add proper release\n+// and acquire semantics. Since TSan does not see its own atomic stores, the\n+// race on predicate won't be reported - the only accesses to it that TSan sees\n+// are the loads on the fast path. Loads don't race. Secondly, dispatch_once is\n+// both a macro and a real function, we want to intercept the function, so we\n+// need to undefine the macro.\n+#undef dispatch_once\n+TSAN_INTERCEPTOR(void, dispatch_once, dispatch_once_t *predicate,\n+                 dispatch_block_t block) {\n+  SCOPED_TSAN_INTERCEPTOR(dispatch_once, predicate, block);\n+  atomic_uint32_t *a = reinterpret_cast<atomic_uint32_t *>(predicate);\n+  u32 v = atomic_load(a, memory_order_acquire);\n+  if (v == 0 &&\n+      atomic_compare_exchange_strong(a, &v, 1, memory_order_relaxed)) {\n+    block();\n+    Release(thr, pc, (uptr)a);\n+    atomic_store(a, 2, memory_order_release);\n+  } else {\n+    while (v != 2) {\n+      internal_sched_yield();\n+      v = atomic_load(a, memory_order_acquire);\n+    }\n+    Acquire(thr, pc, (uptr)a);\n+  }\n+}\n+\n+#undef dispatch_once_f\n+TSAN_INTERCEPTOR(void, dispatch_once_f, dispatch_once_t *predicate,\n+                 void *context, dispatch_function_t function) {\n+  SCOPED_TSAN_INTERCEPTOR(dispatch_once_f, predicate, context, function);\n+  WRAP(dispatch_once)(predicate, ^(void) {\n+    function(context);\n+  });\n+}\n+\n+}  // namespace __tsan\n+\n+#endif  // SANITIZER_MAC"}, {"sha": "97090773ca767bb627b9778f7bd5221177cd55b8", "filename": "libsanitizer/tsan/tsan_malloc_mac.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -0,0 +1,67 @@\n+//===-- tsan_malloc_mac.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Mac-specific malloc interception.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_MAC\n+\n+#include \"tsan_interceptors.h\"\n+#include \"tsan_stack_trace.h\"\n+\n+using namespace __tsan;\n+#define COMMON_MALLOC_ZONE_NAME \"tsan\"\n+#define COMMON_MALLOC_ENTER()\n+#define COMMON_MALLOC_SANITIZER_INITIALIZED (cur_thread()->is_inited)\n+#define COMMON_MALLOC_FORCE_LOCK()\n+#define COMMON_MALLOC_FORCE_UNLOCK()\n+#define COMMON_MALLOC_MEMALIGN(alignment, size) \\\n+  void *p =                                     \\\n+      user_alloc(cur_thread(), StackTrace::GetCurrentPc(), size, alignment)\n+#define COMMON_MALLOC_MALLOC(size)      \\\n+  if (cur_thread()->in_symbolizer)      \\\n+    return REAL(malloc)(size);          \\\n+  SCOPED_INTERCEPTOR_RAW(malloc, size); \\\n+  void *p = user_alloc(thr, pc, size)\n+#define COMMON_MALLOC_REALLOC(ptr, size)      \\\n+  if (cur_thread()->in_symbolizer)            \\\n+    return REAL(realloc)(ptr, size);          \\\n+  SCOPED_INTERCEPTOR_RAW(realloc, ptr, size); \\\n+  void *p = user_realloc(thr, pc, ptr, size)\n+#define COMMON_MALLOC_CALLOC(count, size)      \\\n+  if (cur_thread()->in_symbolizer)             \\\n+    return REAL(calloc)(count, size);          \\\n+  SCOPED_INTERCEPTOR_RAW(calloc, size, count); \\\n+  void *p = user_calloc(thr, pc, size, count)\n+#define COMMON_MALLOC_VALLOC(size)                          \\\n+  if (cur_thread()->in_symbolizer)                          \\\n+    return REAL(valloc)(size);                              \\\n+  SCOPED_INTERCEPTOR_RAW(valloc, size);                     \\\n+  void *p = user_alloc(thr, pc, size, GetPageSizeCached())\n+#define COMMON_MALLOC_FREE(ptr)      \\\n+  if (cur_thread()->in_symbolizer)   \\\n+    return REAL(free)(ptr);          \\\n+  SCOPED_INTERCEPTOR_RAW(free, ptr); \\\n+  user_free(thr, pc, ptr)\n+#define COMMON_MALLOC_SIZE(ptr) \\\n+  uptr size = user_alloc_usable_size(ptr);\n+#define COMMON_MALLOC_FILL_STATS(zone, stats)\n+#define COMMON_MALLOC_REPORT_UNKNOWN_REALLOC(ptr, zone_ptr, zone_name) \\\n+  (void)zone_name; \\\n+  Report(\"mz_realloc(%p) -- attempting to realloc unallocated memory.\\n\", ptr);\n+#define COMMON_MALLOC_IGNORE_INVALID_FREE false\n+#define COMMON_MALLOC_REPORT_FREE_UNALLOCATED(ptr, zone_ptr, zone_name) \\\n+  (void)zone_name; \\\n+  Report(\"free_common(%p) -- attempting to free unallocated memory.\\n\", ptr);\n+#define COMMON_MALLOC_NAMESPACE __tsan\n+\n+#include \"sanitizer_common/sanitizer_malloc_mac.inc\"\n+\n+#endif"}, {"sha": "a7c91fae5e16de0fb0f7f5689488a6ad46f750ff", "filename": "libsanitizer/tsan/tsan_mman.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_mman.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_mman.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -18,6 +18,7 @@ namespace __tsan {\n const uptr kDefaultAlignment = 16;\n \n void InitializeAllocator();\n+void ReplaceSystemMalloc();\n void AllocatorThreadStart(ThreadState *thr);\n void AllocatorThreadFinish(ThreadState *thr);\n void AllocatorPrintStats();"}, {"sha": "ba8474e071414b618b569d19f420cbb36cd09f0f", "filename": "libsanitizer/tsan/tsan_new_delete.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_new_delete.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -9,6 +9,7 @@\n //\n // Interceptors for operators new and delete.\n //===----------------------------------------------------------------------===//\n+#include \"interception/interception.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"tsan_interceptors.h\"\n \n@@ -18,6 +19,13 @@ namespace std {\n struct nothrow_t {};\n }  // namespace std\n \n+DECLARE_REAL(void *, malloc, uptr size)\n+DECLARE_REAL(void, free, void *ptr)\n+#if SANITIZER_MAC\n+#define __libc_malloc REAL(malloc)\n+#define __libc_free REAL(free)\n+#endif\n+\n #define OPERATOR_NEW_BODY(mangled_name) \\\n   if (cur_thread()->in_symbolizer) \\\n     return __libc_malloc(size); \\"}, {"sha": "f34f577ec030c7f1baaa1a69dea0a387a7a4e554", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -338,6 +338,8 @@ uptr ALWAYS_INLINE GetThreadTraceHeader(int tid) {\n }\n \n void InitializePlatform();\n+void CheckAndProtect();\n+void InitializeShadowMemoryPlatform();\n void FlushShadowMemory();\n void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive);\n \n@@ -351,6 +353,8 @@ int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,\n     void *abstime), void *c, void *m, void *abstime,\n     void(*cleanup)(void *arg), void *arg);\n \n+void DestroyThreadState();\n+\n }  // namespace __tsan\n \n #endif  // TSAN_PLATFORM_H"}, {"sha": "a2e89f22da6fc7b13d0ea61fd46ee98b4a8a6491", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 5, "deletions": 88, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -130,17 +130,6 @@ void FlushShadowMemory() {\n }\n \n #ifndef SANITIZER_GO\n-static void ProtectRange(uptr beg, uptr end) {\n-  CHECK_LE(beg, end);\n-  if (beg == end)\n-    return;\n-  if (beg != (uptr)MmapNoAccess(beg, end - beg)) {\n-    Printf(\"FATAL: ThreadSanitizer can not protect [%zx,%zx]\\n\", beg, end);\n-    Printf(\"FATAL: Make sure you are not using unlimited stack\\n\");\n-    Die();\n-  }\n-}\n-\n // Mark shadow for .rodata sections with the special kShadowRodata marker.\n // Accesses to .rodata can't race, so this saves time, memory and trace space.\n static void MapRodata() {\n@@ -198,58 +187,7 @@ static void MapRodata() {\n   internal_close(fd);\n }\n \n-void InitializeShadowMemory() {\n-  // Map memory shadow.\n-  uptr shadow =\n-      (uptr)MmapFixedNoReserve(kShadowBeg, kShadowEnd - kShadowBeg, \"shadow\");\n-  if (shadow != kShadowBeg) {\n-    Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n-    Printf(\"FATAL: Make sure to compile with -fPIE and \"\n-               \"to link with -pie (%p, %p).\\n\", shadow, kShadowBeg);\n-    Die();\n-  }\n-  // This memory range is used for thread stacks and large user mmaps.\n-  // Frequently a thread uses only a small part of stack and similarly\n-  // a program uses a small part of large mmap. On some programs\n-  // we see 20% memory usage reduction without huge pages for this range.\n-  // FIXME: don't use constants here.\n-#if defined(__x86_64__)\n-  const uptr kMadviseRangeBeg  = 0x7f0000000000ull;\n-  const uptr kMadviseRangeSize = 0x010000000000ull;\n-#elif defined(__mips64)\n-  const uptr kMadviseRangeBeg  = 0xff00000000ull;\n-  const uptr kMadviseRangeSize = 0x0100000000ull;\n-#elif defined(__aarch64__)\n-  const uptr kMadviseRangeBeg  = 0x7e00000000ull;\n-  const uptr kMadviseRangeSize = 0x0100000000ull;\n-#endif\n-  NoHugePagesInRegion(MemToShadow(kMadviseRangeBeg),\n-                      kMadviseRangeSize * kShadowMultiplier);\n-  // Meta shadow is compressing and we don't flush it,\n-  // so it makes sense to mark it as NOHUGEPAGE to not over-allocate memory.\n-  // On one program it reduces memory consumption from 5GB to 2.5GB.\n-  NoHugePagesInRegion(kMetaShadowBeg, kMetaShadowEnd - kMetaShadowBeg);\n-  if (common_flags()->use_madv_dontdump)\n-    DontDumpShadowMemory(kShadowBeg, kShadowEnd - kShadowBeg);\n-  DPrintf(\"memory shadow: %zx-%zx (%zuGB)\\n\",\n-      kShadowBeg, kShadowEnd,\n-      (kShadowEnd - kShadowBeg) >> 30);\n-\n-  // Map meta shadow.\n-  uptr meta_size = kMetaShadowEnd - kMetaShadowBeg;\n-  uptr meta =\n-      (uptr)MmapFixedNoReserve(kMetaShadowBeg, meta_size, \"meta shadow\");\n-  if (meta != kMetaShadowBeg) {\n-    Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n-    Printf(\"FATAL: Make sure to compile with -fPIE and \"\n-               \"to link with -pie (%p, %p).\\n\", meta, kMetaShadowBeg);\n-    Die();\n-  }\n-  if (common_flags()->use_madv_dontdump)\n-    DontDumpShadowMemory(meta, meta_size);\n-  DPrintf(\"meta shadow: %zx-%zx (%zuGB)\\n\",\n-      meta, meta + meta_size, meta_size >> 30);\n-\n+void InitializeShadowMemoryPlatform() {\n   MapRodata();\n }\n \n@@ -293,31 +231,6 @@ static void InitDataSeg() {\n   CHECK_LT((uptr)&g_data_start, g_data_end);\n }\n \n-static void CheckAndProtect() {\n-  // Ensure that the binary is indeed compiled with -pie.\n-  MemoryMappingLayout proc_maps(true);\n-  uptr p, end;\n-  while (proc_maps.Next(&p, &end, 0, 0, 0, 0)) {\n-    if (IsAppMem(p))\n-      continue;\n-    if (p >= kHeapMemEnd &&\n-        p < HeapEnd())\n-      continue;\n-    if (p >= kVdsoBeg)  // vdso\n-      break;\n-    Printf(\"FATAL: ThreadSanitizer: unexpected memory mapping %p-%p\\n\", p, end);\n-    Die();\n-  }\n-\n-  ProtectRange(kLoAppMemEnd, kShadowBeg);\n-  ProtectRange(kShadowEnd, kMetaShadowBeg);\n-  ProtectRange(kMetaShadowEnd, kTraceMemBeg);\n-  // Memory for traces is mapped lazily in MapThreadTrace.\n-  // Protect the whole range for now, so that user does not map something here.\n-  ProtectRange(kTraceMemBeg, kTraceMemEnd);\n-  ProtectRange(kTraceMemEnd, kHeapMemBeg);\n-  ProtectRange(HeapEnd(), kHiAppMemBeg);\n-}\n #endif  // #ifndef SANITIZER_GO\n \n void InitializePlatform() {\n@@ -416,6 +329,10 @@ int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,\n }\n #endif\n \n+#ifndef SANITIZER_GO\n+void ReplaceSystemMalloc() { }\n+#endif\n+\n }  // namespace __tsan\n \n #endif  // SANITIZER_LINUX || SANITIZER_FREEBSD"}, {"sha": "e1405ffeabf1ffac9e82843f98b9f9be9a156780", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "modified", "additions": 107, "deletions": 16, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -13,8 +13,10 @@\n #include \"sanitizer_common/sanitizer_platform.h\"\n #if SANITIZER_MAC\n \n+#include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_posix.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n #include \"tsan_platform.h\"\n #include \"tsan_rtl.h\"\n@@ -38,6 +40,62 @@\n \n namespace __tsan {\n \n+#ifndef SANITIZER_GO\n+static void *SignalSafeGetOrAllocate(uptr *dst, uptr size) {\n+  atomic_uintptr_t *a = (atomic_uintptr_t *)dst;\n+  void *val = (void *)atomic_load_relaxed(a);\n+  atomic_signal_fence(memory_order_acquire);  // Turns the previous load into\n+                                              // acquire wrt signals.\n+  if (UNLIKELY(val == nullptr)) {\n+    val = (void *)internal_mmap(nullptr, size, PROT_READ | PROT_WRITE,\n+                                MAP_PRIVATE | MAP_ANON, -1, 0);\n+    CHECK(val);\n+    void *cmp = nullptr;\n+    if (!atomic_compare_exchange_strong(a, (uintptr_t *)&cmp, (uintptr_t)val,\n+                                        memory_order_acq_rel)) {\n+      internal_munmap(val, size);\n+      val = cmp;\n+    }\n+  }\n+  return val;\n+}\n+\n+// On OS X, accessing TLVs via __thread or manually by using pthread_key_* is\n+// problematic, because there are several places where interceptors are called\n+// when TLVs are not accessible (early process startup, thread cleanup, ...).\n+// The following provides a \"poor man's TLV\" implementation, where we use the\n+// shadow memory of the pointer returned by pthread_self() to store a pointer to\n+// the ThreadState object. The main thread's ThreadState pointer is stored\n+// separately in a static variable, because we need to access it even before the\n+// shadow memory is set up.\n+static uptr main_thread_identity = 0;\n+static ThreadState *main_thread_state = nullptr;\n+\n+ThreadState *cur_thread() {\n+  ThreadState **fake_tls;\n+  uptr thread_identity = (uptr)pthread_self();\n+  if (thread_identity == main_thread_identity || main_thread_identity == 0) {\n+    fake_tls = &main_thread_state;\n+  } else {\n+    fake_tls = (ThreadState **)MemToShadow(thread_identity);\n+  }\n+  ThreadState *thr = (ThreadState *)SignalSafeGetOrAllocate(\n+      (uptr *)fake_tls, sizeof(ThreadState));\n+  return thr;\n+}\n+\n+// TODO(kuba.brecka): This is not async-signal-safe. In particular, we call\n+// munmap first and then clear `fake_tls`; if we receive a signal in between,\n+// handler will try to access the unmapped ThreadState.\n+void cur_thread_finalize() {\n+  uptr thread_identity = (uptr)pthread_self();\n+  CHECK_NE(thread_identity, main_thread_identity);\n+  ThreadState **fake_tls = (ThreadState **)MemToShadow(thread_identity);\n+  internal_munmap(*fake_tls, sizeof(ThreadState));\n+  *fake_tls = nullptr;\n+}\n+#endif\n+\n uptr GetShadowMemoryConsumption() {\n   return 0;\n }\n@@ -49,28 +107,57 @@ void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive) {\n }\n \n #ifndef SANITIZER_GO\n-void InitializeShadowMemory() {\n-  uptr shadow = (uptr)MmapFixedNoReserve(kShadowBeg,\n-    kShadowEnd - kShadowBeg);\n-  if (shadow != kShadowBeg) {\n-    Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n-    Printf(\"FATAL: Make sure to compile with -fPIE and \"\n-           \"to link with -pie.\\n\");\n-    Die();\n+void InitializeShadowMemoryPlatform() { }\n+\n+// On OS X, GCD worker threads are created without a call to pthread_create. We\n+// need to properly register these threads with ThreadCreate and ThreadStart.\n+// These threads don't have a parent thread, as they are created \"spuriously\".\n+// We're using a libpthread API that notifies us about a newly created thread.\n+// The `thread == pthread_self()` check indicates this is actually a worker\n+// thread. If it's just a regular thread, this hook is called on the parent\n+// thread.\n+typedef void (*pthread_introspection_hook_t)(unsigned int event,\n+                                             pthread_t thread, void *addr,\n+                                             size_t size);\n+extern \"C\" pthread_introspection_hook_t pthread_introspection_hook_install(\n+    pthread_introspection_hook_t hook);\n+static const uptr PTHREAD_INTROSPECTION_THREAD_CREATE = 1;\n+static const uptr PTHREAD_INTROSPECTION_THREAD_DESTROY = 4;\n+static pthread_introspection_hook_t prev_pthread_introspection_hook;\n+static void my_pthread_introspection_hook(unsigned int event, pthread_t thread,\n+                                          void *addr, size_t size) {\n+  if (event == PTHREAD_INTROSPECTION_THREAD_CREATE) {\n+    if (thread == pthread_self()) {\n+      // The current thread is a newly created GCD worker thread.\n+      ThreadState *parent_thread_state = nullptr;  // No parent.\n+      int tid = ThreadCreate(parent_thread_state, 0, (uptr)thread, true);\n+      CHECK_NE(tid, 0);\n+      ThreadState *thr = cur_thread();\n+      ThreadStart(thr, tid, GetTid());\n+    }\n+  } else if (event == PTHREAD_INTROSPECTION_THREAD_DESTROY) {\n+    ThreadState *thr = cur_thread();\n+    if (thr->tctx && thr->tctx->parent_tid == kInvalidTid) {\n+      DestroyThreadState();\n+    }\n   }\n-  if (common_flags()->use_madv_dontdump)\n-    DontDumpShadowMemory(kShadowBeg, kShadowEnd - kShadowBeg);\n-  DPrintf(\"kShadow %zx-%zx (%zuGB)\\n\",\n-      kShadowBeg, kShadowEnd,\n-      (kShadowEnd - kShadowBeg) >> 30);\n-  DPrintf(\"kAppMem %zx-%zx (%zuGB)\\n\",\n-      kAppMemBeg, kAppMemEnd,\n-      (kAppMemEnd - kAppMemBeg) >> 30);\n+\n+  if (prev_pthread_introspection_hook != nullptr)\n+    prev_pthread_introspection_hook(event, thread, addr, size);\n }\n #endif\n \n void InitializePlatform() {\n   DisableCoreDumperIfNecessary();\n+#ifndef SANITIZER_GO\n+  CheckAndProtect();\n+\n+  CHECK_EQ(main_thread_identity, 0);\n+  main_thread_identity = (uptr)pthread_self();\n+\n+  prev_pthread_introspection_hook =\n+      pthread_introspection_hook_install(&my_pthread_introspection_hook);\n+#endif\n }\n \n #ifndef SANITIZER_GO\n@@ -89,6 +176,10 @@ int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,\n }\n #endif\n \n+bool IsGlobalVar(uptr addr) {\n+  return false;\n+}\n+\n }  // namespace __tsan\n \n #endif  // SANITIZER_MAC"}, {"sha": "5e3d12e9496e5f01c90ca0e83e0755e87a1883b2", "filename": "libsanitizer/tsan/tsan_platform_posix.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -0,0 +1,122 @@\n+//===-- tsan_platform_posix.cc --------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// POSIX-specific code.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_POSIX\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_procmaps.h\"\n+#include \"tsan_platform.h\"\n+#include \"tsan_rtl.h\"\n+\n+namespace __tsan {\n+\n+#ifndef SANITIZER_GO\n+void InitializeShadowMemory() {\n+  // Map memory shadow.\n+  uptr shadow =\n+      (uptr)MmapFixedNoReserve(kShadowBeg, kShadowEnd - kShadowBeg, \"shadow\");\n+  if (shadow != kShadowBeg) {\n+    Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n+    Printf(\"FATAL: Make sure to compile with -fPIE and \"\n+               \"to link with -pie (%p, %p).\\n\", shadow, kShadowBeg);\n+    Die();\n+  }\n+  // This memory range is used for thread stacks and large user mmaps.\n+  // Frequently a thread uses only a small part of stack and similarly\n+  // a program uses a small part of large mmap. On some programs\n+  // we see 20% memory usage reduction without huge pages for this range.\n+  // FIXME: don't use constants here.\n+#if defined(__x86_64__)\n+  const uptr kMadviseRangeBeg  = 0x7f0000000000ull;\n+  const uptr kMadviseRangeSize = 0x010000000000ull;\n+#elif defined(__mips64)\n+  const uptr kMadviseRangeBeg  = 0xff00000000ull;\n+  const uptr kMadviseRangeSize = 0x0100000000ull;\n+#elif defined(__aarch64__)\n+  const uptr kMadviseRangeBeg  = 0x7e00000000ull;\n+  const uptr kMadviseRangeSize = 0x0100000000ull;\n+#endif\n+  NoHugePagesInRegion(MemToShadow(kMadviseRangeBeg),\n+                      kMadviseRangeSize * kShadowMultiplier);\n+  // Meta shadow is compressing and we don't flush it,\n+  // so it makes sense to mark it as NOHUGEPAGE to not over-allocate memory.\n+  // On one program it reduces memory consumption from 5GB to 2.5GB.\n+  NoHugePagesInRegion(kMetaShadowBeg, kMetaShadowEnd - kMetaShadowBeg);\n+  if (common_flags()->use_madv_dontdump)\n+    DontDumpShadowMemory(kShadowBeg, kShadowEnd - kShadowBeg);\n+  DPrintf(\"memory shadow: %zx-%zx (%zuGB)\\n\",\n+      kShadowBeg, kShadowEnd,\n+      (kShadowEnd - kShadowBeg) >> 30);\n+\n+  // Map meta shadow.\n+  uptr meta_size = kMetaShadowEnd - kMetaShadowBeg;\n+  uptr meta =\n+      (uptr)MmapFixedNoReserve(kMetaShadowBeg, meta_size, \"meta shadow\");\n+  if (meta != kMetaShadowBeg) {\n+    Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n+    Printf(\"FATAL: Make sure to compile with -fPIE and \"\n+               \"to link with -pie (%p, %p).\\n\", meta, kMetaShadowBeg);\n+    Die();\n+  }\n+  if (common_flags()->use_madv_dontdump)\n+    DontDumpShadowMemory(meta, meta_size);\n+  DPrintf(\"meta shadow: %zx-%zx (%zuGB)\\n\",\n+      meta, meta + meta_size, meta_size >> 30);\n+\n+  InitializeShadowMemoryPlatform();\n+}\n+\n+static void ProtectRange(uptr beg, uptr end) {\n+  CHECK_LE(beg, end);\n+  if (beg == end)\n+    return;\n+  if (beg != (uptr)MmapNoAccess(beg, end - beg)) {\n+    Printf(\"FATAL: ThreadSanitizer can not protect [%zx,%zx]\\n\", beg, end);\n+    Printf(\"FATAL: Make sure you are not using unlimited stack\\n\");\n+    Die();\n+  }\n+}\n+\n+void CheckAndProtect() {\n+  // Ensure that the binary is indeed compiled with -pie.\n+  MemoryMappingLayout proc_maps(true);\n+  uptr p, end, prot;\n+  while (proc_maps.Next(&p, &end, 0, 0, 0, &prot)) {\n+    if (IsAppMem(p))\n+      continue;\n+    if (p >= kHeapMemEnd &&\n+        p < HeapEnd())\n+      continue;\n+    if (prot == 0)  // Zero page or mprotected.\n+      continue;\n+    if (p >= kVdsoBeg)  // vdso\n+      break;\n+    Printf(\"FATAL: ThreadSanitizer: unexpected memory mapping %p-%p\\n\", p, end);\n+    Die();\n+  }\n+\n+  ProtectRange(kLoAppMemEnd, kShadowBeg);\n+  ProtectRange(kShadowEnd, kMetaShadowBeg);\n+  ProtectRange(kMetaShadowEnd, kTraceMemBeg);\n+  // Memory for traces is mapped lazily in MapThreadTrace.\n+  // Protect the whole range for now, so that user does not map something here.\n+  ProtectRange(kTraceMemBeg, kTraceMemEnd);\n+  ProtectRange(kTraceMemEnd, kHeapMemBeg);\n+  ProtectRange(HeapEnd(), kHiAppMemBeg);\n+}\n+#endif\n+\n+}  // namespace __tsan\n+\n+#endif  // SANITIZER_POSIX"}, {"sha": "119b1ec1da9c2d36a3b49391a7c880d2164320b4", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -109,6 +109,12 @@ static const char *ReportTypeString(ReportType typ) {\n   return \"\";\n }\n \n+#if SANITIZER_MAC\n+static const char *const kInterposedFunctionPrefix = \"wrap_\";\n+#else\n+static const char *const kInterposedFunctionPrefix = \"__interceptor_\";\n+#endif\n+\n void PrintStack(const ReportStack *ent) {\n   if (ent == 0 || ent->frames == 0) {\n     Printf(\"    [failed to restore the stack]\\n\\n\");\n@@ -119,7 +125,7 @@ void PrintStack(const ReportStack *ent) {\n     InternalScopedString res(2 * GetPageSizeCached());\n     RenderFrame(&res, common_flags()->stack_trace_format, i, frame->info,\n                 common_flags()->symbolize_vs_style,\n-                common_flags()->strip_path_prefix, \"__interceptor_\");\n+                common_flags()->strip_path_prefix, kInterposedFunctionPrefix);\n     Printf(\"%s\\n\", res.data());\n   }\n   Printf(\"\\n\");\n@@ -163,9 +169,14 @@ static void PrintLocation(const ReportLocation *loc) {\n   Printf(\"%s\", d.Location());\n   if (loc->type == ReportLocationGlobal) {\n     const DataInfo &global = loc->global;\n-    Printf(\"  Location is global '%s' of size %zu at %p (%s+%p)\\n\\n\",\n-           global.name, global.size, global.start,\n-           StripModuleName(global.module), global.module_offset);\n+    if (global.size != 0)\n+      Printf(\"  Location is global '%s' of size %zu at %p (%s+%p)\\n\\n\",\n+             global.name, global.size, global.start,\n+             StripModuleName(global.module), global.module_offset);\n+    else\n+      Printf(\"  Location is global '%s' at %p (%s+%p)\\n\\n\", global.name,\n+             global.start, StripModuleName(global.module),\n+             global.module_offset);\n   } else if (loc->type == ReportLocationHeap) {\n     char thrbuf[kThreadBufSize];\n     Printf(\"  Location is heap block of size %zu at %p allocated by %s:\\n\","}, {"sha": "4fceca6f41f91441c73d86729dfe043490e7e6a7", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -42,7 +42,7 @@ extern \"C\" void __tsan_resume() {\n \n namespace __tsan {\n \n-#ifndef SANITIZER_GO\n+#if !defined(SANITIZER_GO) && !SANITIZER_MAC\n THREADLOCAL char cur_thread_placeholder[sizeof(ThreadState)] ALIGNED(64);\n #endif\n static char ctx_placeholder[sizeof(Context)] ALIGNED(64);\n@@ -323,6 +323,7 @@ void Initialize(ThreadState *thr) {\n   CheckVMASize();\n #ifndef SANITIZER_GO\n   InitializeAllocator();\n+  ReplaceSystemMalloc();\n #endif\n   InitializeInterceptors();\n   CheckShadowMapping();"}, {"sha": "12587dd203ef4ffff9b2ccdd11fd74d4f2484e68", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -408,12 +408,18 @@ struct ThreadState {\n };\n \n #ifndef SANITIZER_GO\n+#if SANITIZER_MAC\n+ThreadState *cur_thread();\n+void cur_thread_finalize();\n+#else\n __attribute__((tls_model(\"initial-exec\")))\n extern THREADLOCAL char cur_thread_placeholder[];\n INLINE ThreadState *cur_thread() {\n   return reinterpret_cast<ThreadState *>(&cur_thread_placeholder);\n }\n-#endif\n+INLINE void cur_thread_finalize() { }\n+#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_GO\n \n class ThreadContext : public ThreadContextBase {\n  public:\n@@ -707,7 +713,7 @@ void AcquireReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c);\n // The trick is that the call preserves all registers and the compiler\n // does not treat it as a call.\n // If it does not work for you, use normal call.\n-#if !SANITIZER_DEBUG && defined(__x86_64__)\n+#if !SANITIZER_DEBUG && defined(__x86_64__) && !SANITIZER_MAC\n // The caller may not create the stack frame for itself at all,\n // so we create a reserve stack frame for it (1024b must be enough).\n #define HACKY_CALL(f) \\"}, {"sha": "20bf00827e9a4ffe07d4ea878ddf87846e503435", "filename": "libsanitizer/tsan/tsan_rtl_aarch64.S", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -0,0 +1,204 @@\n+#include \"sanitizer_common/sanitizer_asm.h\"\n+.hidden __tsan_setjmp\n+.comm _ZN14__interception11real_setjmpE,8,8\n+.type setjmp, @function\n+setjmp:\n+  CFI_STARTPROC\n+\n+  // save env parameters for function call\n+  stp     x29, x30, [sp, -32]!\n+  CFI_DEF_CFA_OFFSET (32)\n+  CFI_OFFSET (29, -32)\n+  CFI_OFFSET (30, -24)\n+\n+  // Adjust the SP for previous frame\n+  add     x29, sp, 0\n+  CFI_DEF_CFA_REGISTER (29)\n+\n+  // Save jmp_buf\n+  str     x19, [sp, 16]\n+  CFI_OFFSET (19, -16)\n+  mov     x19, x0\n+\n+  // SP pointer mangling (see glibc setjmp)\n+  adrp    x2, :got:__pointer_chk_guard\n+  ldr     x2, [x2, #:got_lo12:__pointer_chk_guard]\n+  add     x0, x29, 32\n+  ldr     x2, [x2]\n+  eor     x1, x2, x0\n+\n+  // call tsan interceptor\n+  bl      __tsan_setjmp\n+\n+  // restore env parameter\n+  mov     x0, x19\n+  ldr     x19, [sp, 16]\n+  ldp     x29, x30, [sp], 32\n+  CFI_RESTORE (30)\n+  CFI_RESTORE (19)\n+  CFI_DEF_CFA (31, 0)\n+\n+  // tail jump to libc setjmp\n+  adrp    x1, :got:_ZN14__interception11real_setjmpE\n+  ldr     x1, [x1, #:got_lo12:_ZN14__interception11real_setjmpE]\n+  ldr     x1, [x1]\n+  br      x1\n+\n+  CFI_ENDPROC\n+.size setjmp, .-setjmp\n+\n+.comm _ZN14__interception12real__setjmpE,8,8\n+.globl _setjmp\n+.type _setjmp, @function\n+_setjmp:\n+  CFI_STARTPROC\n+\n+  // save env parameters for function call\n+  stp     x29, x30, [sp, -32]!\n+  CFI_DEF_CFA_OFFSET (32)\n+  CFI_OFFSET (29, -32)\n+  CFI_OFFSET (30, -24)\n+\n+  // Adjust the SP for previous frame\n+  add     x29, sp, 0\n+  CFI_DEF_CFA_REGISTER (29)\n+\n+  // Save jmp_buf\n+  str     x19, [sp, 16]\n+  CFI_OFFSET (19, -16)\n+  mov     x19, x0\n+\n+  // SP pointer mangling (see glibc setjmp)\n+  adrp    x2, :got:__pointer_chk_guard\n+  ldr     x2, [x2, #:got_lo12:__pointer_chk_guard]\n+  add     x0, x29, 32\n+  ldr     x2, [x2]\n+  eor     x1, x2, x0\n+\n+  // call tsan interceptor\n+  bl      __tsan_setjmp\n+\n+  // Restore jmp_buf parameter\n+  mov     x0, x19\n+  ldr     x19, [sp, 16]\n+  ldp     x29, x30, [sp], 32\n+  CFI_RESTORE (30)\n+  CFI_RESTORE (19)\n+  CFI_DEF_CFA (31, 0)\n+\n+  // tail jump to libc setjmp\n+  adrp    x1, :got:_ZN14__interception12real__setjmpE\n+  ldr     x1, [x1, #:got_lo12:_ZN14__interception12real__setjmpE]\n+  ldr     x1, [x1]\n+  br      x1\n+\n+  CFI_ENDPROC\n+.size _setjmp, .-_setjmp\n+\n+.comm _ZN14__interception14real_sigsetjmpE,8,8\n+.globl sigsetjmp\n+.type sigsetjmp, @function\n+sigsetjmp:\n+  CFI_STARTPROC\n+\n+  // save env parameters for function call\n+  stp     x29, x30, [sp, -32]!\n+  CFI_DEF_CFA_OFFSET (32)\n+  CFI_OFFSET (29, -32)\n+  CFI_OFFSET (30, -24)\n+\n+  // Adjust the SP for previous frame\n+  add     x29, sp, 0\n+  CFI_DEF_CFA_REGISTER (29)\n+\n+  // Save jmp_buf and savesigs\n+  stp     x19, x20, [sp, 16]\n+  CFI_OFFSET (19, -16)\n+  CFI_OFFSET (20, -8)\n+  mov     w20, w1\n+  mov     x19, x0\n+\n+  // SP pointer mangling (see glibc setjmp)\n+  adrp    x2, :got:__pointer_chk_guard\n+  ldr     x2, [x2, #:got_lo12:__pointer_chk_guard]\n+  add     x0, x29, 32\n+  ldr     x2, [x2]\n+  eor     x1, x2, x0\n+\n+  // call tsan interceptor\n+  bl      __tsan_setjmp\n+\n+  // restore env parameter\n+  mov     w1, w20\n+  mov     x0, x19\n+  ldp     x19, x20, [sp, 16]\n+  ldp     x29, x30, [sp], 32\n+  CFI_RESTORE (30)\n+  CFI_RESTORE (29)\n+  CFI_RESTORE (19)\n+  CFI_RESTORE (20)\n+  CFI_DEF_CFA (31, 0)\n+\n+  // tail jump to libc sigsetjmp\n+  adrp    x2, :got:_ZN14__interception14real_sigsetjmpE\n+  ldr     x2, [x2, #:got_lo12:_ZN14__interception14real_sigsetjmpE]\n+  ldr     x2, [x2]\n+  br      x2\n+  CFI_ENDPROC\n+.size sigsetjmp, .-sigsetjmp\n+\n+.comm _ZN14__interception16real___sigsetjmpE,8,8\n+.globl __sigsetjmp\n+.type __sigsetjmp, @function\n+__sigsetjmp:\n+  CFI_STARTPROC\n+\n+  // save env parameters for function call\n+  stp     x29, x30, [sp, -32]!\n+  CFI_DEF_CFA_OFFSET (32)\n+  CFI_OFFSET (29, -32)\n+  CFI_OFFSET (30, -24)\n+\n+  // Adjust the SP for previous frame\n+  add     x29, sp, 0\n+  CFI_DEF_CFA_REGISTER (29)\n+\n+  // Save jmp_buf and savesigs\n+  stp     x19, x20, [sp, 16]\n+  CFI_OFFSET (19, -16)\n+  CFI_OFFSET (20, -8)\n+  mov     w20, w1\n+  mov     x19, x0\n+\n+  // SP pointer mangling (see glibc setjmp)\n+  adrp    x2, :got:__pointer_chk_guard\n+  ldr     x2, [x2, #:got_lo12:__pointer_chk_guard]\n+  add     x0, x29, 32\n+  ldr     x2, [x2]\n+  eor     x1, x2, x0\n+\n+  // call tsan interceptor\n+  bl      __tsan_setjmp\n+\n+  mov     w1, w20\n+  mov     x0, x19\n+  ldp     x19, x20, [sp, 16]\n+  ldp     x29, x30, [sp], 32\n+  CFI_RESTORE (30)\n+  CFI_RESTORE (29)\n+  CFI_RESTORE (19)\n+  CFI_RESTORE (20)\n+  CFI_DEF_CFA (31, 0)\n+\n+  // tail jump to libc __sigsetjmp\n+  adrp    x2, :got:_ZN14__interception16real___sigsetjmpE\n+  ldr     x2, [x2, #:got_lo12:_ZN14__interception16real___sigsetjmpE]\n+  ldr     x2, [x2]\n+  br      x2\n+  CFI_ENDPROC\n+.size __sigsetjmp, .-__sigsetjmp\n+\n+#if defined(__linux__)\n+/* We do not need executable stack.  */\n+.section        .note.GNU-stack,\"\",@progbits\n+#endif"}, {"sha": "3939c77d41c348ad117153e8e980cdbcdcfd3995", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55aea9f56ccbdd0e225d4899024efd7b2b9f95b2/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=55aea9f56ccbdd0e225d4899024efd7b2b9f95b2", "patch": "@@ -53,6 +53,8 @@ void ThreadContext::OnCreated(void *arg) {\n   if (tid == 0)\n     return;\n   OnCreatedArgs *args = static_cast<OnCreatedArgs *>(arg);\n+  if (!args->thr)  // GCD workers don't have a parent thread.\n+    return;\n   args->thr->fast_state.IncrementEpoch();\n   // Can't increment epoch w/o writing to the trace as well.\n   TraceAddEvent(args->thr, args->thr->fast_state, EventTypeMop, 0);\n@@ -229,8 +231,10 @@ int ThreadCount(ThreadState *thr) {\n int ThreadCreate(ThreadState *thr, uptr pc, uptr uid, bool detached) {\n   StatInc(thr, StatThreadCreate);\n   OnCreatedArgs args = { thr, pc };\n-  int tid = ctx->thread_registry->CreateThread(uid, detached, thr->tid, &args);\n-  DPrintf(\"#%d: ThreadCreate tid=%d uid=%zu\\n\", thr->tid, tid, uid);\n+  u32 parent_tid = thr ? thr->tid : kInvalidTid;  // No parent for GCD workers.\n+  int tid =\n+      ctx->thread_registry->CreateThread(uid, detached, parent_tid, &args);\n+  DPrintf(\"#%d: ThreadCreate tid=%d uid=%zu\\n\", parent_tid, tid, uid);\n   StatSet(thr, StatThreadMaxAlive, ctx->thread_registry->GetMaxAliveThreads());\n   return tid;\n }"}]}