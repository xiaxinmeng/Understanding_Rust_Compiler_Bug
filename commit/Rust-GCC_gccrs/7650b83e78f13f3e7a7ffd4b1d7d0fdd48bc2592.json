{"sha": "7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY1MGI4M2U3OGYxM2YzZTdhN2ZmZDRiMWQ3ZDBmZGQ0OGJjMjU5Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-01-06T15:08:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-01-06T15:08:44Z"}, "message": "i386.h (CONDITIONAL_CALL_USAGE): SSE regs are not used for w64 ABI.\n\n\n\t* i386.h (CONDITIONAL_CALL_USAGE): SSE regs are not used for w64 ABI.\n\t* i386.c (struct ix86_frame): Add padding0 and nsseregs.\n\t(ix86_nsaved_regs): Count only general purpose regs.\n\t(ix86_nsaved_sseregs): New.\n\t(ix86_compute_frame_layout): Update nsseregs; set preferred alignment\n\tto 16 for w64; compute padding and size of sse reg save area.\n\t(ix86_emit_save_regs, ix86_emit_save_regs_using_mov): Save only general\n\tpurpose regs.\n\t(ix86_emit_save_sse_regs_using_mov): New.\n\t(ix86_expand_prologue): Save SSE regs if needed.\n\t(ix86_emit_restore_regs_using_mov): Use only general purpose regs.\n\t(ix86_emit_restore_sse_regs_using_mov): New.\n\t(ix86_expand_epilogue): Save SSE regs if needed.\n\nCo-Authored-By: Kai Tietz <kai.tietz@onevision.com>\n\nFrom-SVN: r143119", "tree": {"sha": "7059171040fe1db464c9107f120272574044d14d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7059171040fe1db464c9107f120272574044d14d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592/comments", "author": null, "committer": null, "parents": [{"sha": "9aa5c1b2acb324d7d221f7d919e976110cdeedfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9aa5c1b2acb324d7d221f7d919e976110cdeedfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9aa5c1b2acb324d7d221f7d919e976110cdeedfc"}], "stats": {"total": 200, "additions": 178, "deletions": 22}, "files": [{"sha": "21de6806b2b9cc0656ba37dc746247ce98883dca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592", "patch": "@@ -1,3 +1,20 @@\n+2009-01-06  Jan Hubicka  <jh@suse.cz>\n+\t    Kai Tietz <kai.tietz@onevision.com>\n+\n+\t* i386.h (CONDITIONAL_CALL_USAGE): SSE regs are not used for w64 ABI.\n+\t* i386.c (struct ix86_frame): Add padding0 and nsseregs.\n+\t(ix86_nsaved_regs): Count only general purpose regs.\n+\t(ix86_nsaved_sseregs): New.\n+\t(ix86_compute_frame_layout): Update nsseregs; set preferred alignment\n+\tto 16 for w64; compute padding and size of sse reg save area.\n+\t(ix86_emit_save_regs, ix86_emit_save_regs_using_mov): Save only general\n+\tpurpose regs.\n+\t(ix86_emit_save_sse_regs_using_mov): New.\n+\t(ix86_expand_prologue): Save SSE regs if needed.\n+\t(ix86_emit_restore_regs_using_mov): Use only general purpose regs.\n+\t(ix86_emit_restore_sse_regs_using_mov): New.\n+\t(ix86_expand_epilogue): Save SSE regs if needed.\n+\n 2009-01-06  Jan Hubicka  <jh@suse.cz>\n \t    Kai Tietz <kai.tietz@onevision.com>\n "}, {"sha": "73a717ddbe63af3f955661f0aa50a1f1edc06650", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 157, "deletions": 22, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592", "patch": "@@ -1655,6 +1655,10 @@ struct stack_local_entry GTY(())\n \t\t\t\t\t      <- HARD_FRAME_POINTER\n    [saved regs]\n \n+   [padding0]\n+\n+   [saved SSE regs]\n+\n    [padding1]          \\\n \t\t        )\n    [va_arg registers]  (\n@@ -1665,6 +1669,8 @@ struct stack_local_entry GTY(())\n   */\n struct ix86_frame\n {\n+  int padding0;\n+  int nsseregs;\n   int nregs;\n   int padding1;\n   int va_arg_size;\n@@ -7417,17 +7423,33 @@ ix86_save_reg (unsigned int regno, int maybe_eh_return)\n \t  && (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed));\n }\n \n-/* Return number of registers to be saved on the stack.  */\n+/* Return number of saved general prupose registers.  */\n \n static int\n ix86_nsaved_regs (void)\n {\n   int nregs = 0;\n   int regno;\n \n-  for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)\n-    if (ix86_save_reg (regno, true))\n-      nregs++;\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, true))\n+      nregs ++;\n+  return nregs;\n+}\n+\n+/* Return number of saved SSE registrers.  */\n+\n+static int\n+ix86_nsaved_sseregs (void)\n+{\n+  int nregs = 0;\n+  int regno;\n+\n+  if (ix86_cfun_abi () != MS_ABI)\n+    return 0;\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (SSE_REGNO_P (regno) && ix86_save_reg (regno, true))\n+      nregs ++;\n   return nregs;\n }\n \n@@ -7487,11 +7509,22 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   HOST_WIDE_INT size = get_frame_size ();\n \n   frame->nregs = ix86_nsaved_regs ();\n+  frame->nsseregs = ix86_nsaved_sseregs ();\n   total_size = size;\n \n   stack_alignment_needed = crtl->stack_alignment_needed / BITS_PER_UNIT;\n   preferred_alignment = crtl->preferred_stack_boundary / BITS_PER_UNIT;\n \n+  /* MS ABI seem to require stack alignment to be always 16 except for function\n+     prologues.  */\n+  if (ix86_cfun_abi () == MS_ABI && preferred_alignment < 16)\n+    {\n+      preferred_alignment = 16;\n+      stack_alignment_needed = 16;\n+      crtl->preferred_stack_boundary = 128;\n+      crtl->stack_alignment_needed = 128;\n+    }\n+\n   gcc_assert (!size || stack_alignment_needed);\n   gcc_assert (preferred_alignment >= STACK_BOUNDARY / BITS_PER_UNIT);\n   gcc_assert (preferred_alignment <= stack_alignment_needed);\n@@ -7546,6 +7579,15 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   /* Register save area */\n   offset += frame->nregs * UNITS_PER_WORD;\n \n+  /* Align SSE reg save area.  */\n+  if (frame->nsseregs)\n+    frame->padding0 = ((offset + 16 - 1) & -16) - offset;\n+  else\n+    frame->padding0 = 0;\n+  \n+  /* SSE register save area.  */\n+  offset += frame->padding0 + frame->nsseregs * 16;\n+\n   /* Va-arg area */\n   frame->va_arg_size = ix86_varargs_gpr_size + ix86_varargs_fpr_size;\n   offset += frame->va_arg_size;\n@@ -7615,8 +7657,10 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   frame->stack_pointer_offset -= frame->red_zone_size;\n #if 0\n   fprintf (stderr, \"\\n\");\n-  fprintf (stderr, \"nregs: %ld\\n\", (long)frame->nregs);\n   fprintf (stderr, \"size: %ld\\n\", (long)size);\n+  fprintf (stderr, \"nregs: %ld\\n\", (long)frame->nregs);\n+  fprintf (stderr, \"nsseregs: %ld\\n\", (long)frame->nsseregs);\n+  fprintf (stderr, \"padding0: %ld\\n\", (long)frame->padding0);\n   fprintf (stderr, \"alignment1: %ld\\n\", (long)stack_alignment_needed);\n   fprintf (stderr, \"padding1: %ld\\n\", (long)frame->padding1);\n   fprintf (stderr, \"va_arg: %ld\\n\", (long)frame->va_arg_size);\n@@ -7641,8 +7685,8 @@ ix86_emit_save_regs (void)\n   unsigned int regno;\n   rtx insn;\n \n-  for (regno = FIRST_PSEUDO_REGISTER; regno-- > 0; )\n-    if (ix86_save_reg (regno, true))\n+  for (regno = FIRST_PSEUDO_REGISTER - 1; regno-- > 0; )\n+    if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, true))\n       {\n \tinsn = emit_insn (gen_push (gen_rtx_REG (Pmode, regno)));\n \tRTX_FRAME_RELATED_P (insn) = 1;\n@@ -7658,7 +7702,7 @@ ix86_emit_save_regs_using_mov (rtx pointer, HOST_WIDE_INT offset)\n   rtx insn;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (ix86_save_reg (regno, true))\n+    if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, true))\n       {\n \tinsn = emit_move_insn (adjust_address (gen_rtx_MEM (Pmode, pointer),\n \t\t\t\t\t       Pmode, offset),\n@@ -7668,6 +7712,26 @@ ix86_emit_save_regs_using_mov (rtx pointer, HOST_WIDE_INT offset)\n       }\n }\n \n+/* Emit code to save registers using MOV insns.  First register\n+   is restored from POINTER + OFFSET.  */\n+static void\n+ix86_emit_save_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset)\n+{\n+  unsigned int regno;\n+  rtx insn;\n+  rtx mem;\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (SSE_REGNO_P (regno) && ix86_save_reg (regno, true))\n+      {\n+\tmem = adjust_address (gen_rtx_MEM (TImode, pointer), TImode, offset);\n+\tset_mem_align (mem, 128);\n+\tinsn = emit_move_insn (mem, gen_rtx_REG (TImode, regno));\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+\toffset += 16;\n+      }\n+}\n+\n /* Expand prologue or epilogue stack adjustment.\n    The pattern exist to put a dependency on all ebp-based memory accesses.\n    STYLE should be negative if instructions should be marked as frame related,\n@@ -7972,7 +8036,7 @@ ix86_expand_prologue (void)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  allocate = frame.to_allocate;\n+  allocate = frame.to_allocate + frame.nsseregs * 16 + frame.padding0;\n \n   if (!frame.save_regs_using_mov)\n     ix86_emit_save_regs ();\n@@ -8051,11 +8115,22 @@ ix86_expand_prologue (void)\n \t  || !frame.to_allocate\n \t  || crtl->stack_realign_needed)\n         ix86_emit_save_regs_using_mov (stack_pointer_rtx,\n-\t\t\t\t       frame.to_allocate);\n+\t\t\t\t       frame.to_allocate\n+\t\t\t\t       + frame.nsseregs * 16 + frame.padding0);\n       else\n         ix86_emit_save_regs_using_mov (hard_frame_pointer_rtx,\n \t\t\t\t       -frame.nregs * UNITS_PER_WORD);\n     }\n+  if (!frame_pointer_needed\n+      || !frame.to_allocate\n+      || crtl->stack_realign_needed)\n+    ix86_emit_save_sse_regs_using_mov (stack_pointer_rtx,\n+\t\t\t\t       frame.to_allocate);\n+  else\n+    ix86_emit_save_sse_regs_using_mov (hard_frame_pointer_rtx,\n+\t\t\t\t       - frame.nregs * UNITS_PER_WORD\n+\t\t\t\t       - frame.nsseregs * 16\n+\t\t\t\t       - frame.padding0);\n \n   pic_reg_used = false;\n   if (pic_offset_table_rtx\n@@ -8127,7 +8202,7 @@ ix86_emit_restore_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n   rtx base_address = gen_rtx_MEM (Pmode, pointer);\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (ix86_save_reg (regno, maybe_eh_return))\n+    if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, maybe_eh_return))\n       {\n \t/* Ensure that adjust_address won't be forced to produce pointer\n \t   out of range allowed by x86-64 instruction set.  */\n@@ -8142,11 +8217,43 @@ ix86_emit_restore_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n \t    offset = 0;\n \t  }\n \temit_move_insn (gen_rtx_REG (Pmode, regno),\n-\t\t\tadjust_address (base_address, Pmode, offset));\n+\t                adjust_address (base_address, Pmode, offset));\n \toffset += UNITS_PER_WORD;\n       }\n }\n \n+/* Emit code to restore saved registers using MOV insns.  First register\n+   is restored from POINTER + OFFSET.  */\n+static void\n+ix86_emit_restore_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n+\t\t\t\t      int maybe_eh_return)\n+{\n+  int regno;\n+  rtx base_address = gen_rtx_MEM (TImode, pointer);\n+  rtx mem;\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (SSE_REGNO_P (regno) && ix86_save_reg (regno, maybe_eh_return))\n+      {\n+\t/* Ensure that adjust_address won't be forced to produce pointer\n+\t   out of range allowed by x86-64 instruction set.  */\n+\tif (TARGET_64BIT && offset != trunc_int_for_mode (offset, SImode))\n+\t  {\n+\t    rtx r11;\n+\n+\t    r11 = gen_rtx_REG (DImode, R11_REG);\n+\t    emit_move_insn (r11, GEN_INT (offset));\n+\t    emit_insn (gen_adddi3 (r11, r11, pointer));\n+\t    base_address = gen_rtx_MEM (TImode, r11);\n+\t    offset = 0;\n+\t  }\n+\tmem = adjust_address (base_address, TImode, offset);\n+\tset_mem_align (mem, 128);\n+\temit_move_insn (gen_rtx_REG (TImode, regno), mem);\n+\toffset += 16;\n+      }\n+}\n+\n /* Restore function stack, frame, and registers.  */\n \n void\n@@ -8174,6 +8281,7 @@ ix86_expand_epilogue (int style)\n   if (crtl->calls_eh_return && style != 2)\n     offset -= 2;\n   offset *= -UNITS_PER_WORD;\n+  offset -= frame.nsseregs * 16 + frame.padding0;\n \n   /* If we're only restoring one register and sp is not valid then\n      using a move instruction to restore the register since it's\n@@ -8207,11 +8315,23 @@ ix86_expand_epilogue (int style)\n       if (!frame_pointer_needed\n \t  || (sp_valid && !frame.to_allocate) \n \t  || stack_realign_fp)\n-\tix86_emit_restore_regs_using_mov (stack_pointer_rtx,\n-\t\t\t\t\t  frame.to_allocate, style == 2);\n+\t{\n+\t  ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,\n+\t\t\t\t\t        frame.to_allocate, style == 2);\n+\t  ix86_emit_restore_regs_using_mov (stack_pointer_rtx,\n+\t\t\t\t\t    frame.to_allocate\n+\t\t\t\t\t    + frame.nsseregs * 16\n+\t\t\t\t\t    + frame.padding0, style == 2);\n+\t}\n       else\n-\tix86_emit_restore_regs_using_mov (hard_frame_pointer_rtx,\n-\t\t\t\t\t  offset, style == 2);\n+        {\n+\t  ix86_emit_restore_sse_regs_using_mov (hard_frame_pointer_rtx,\n+\t\t\t\t\t        offset, style == 2);\n+\t  ix86_emit_restore_regs_using_mov (hard_frame_pointer_rtx,\n+\t\t\t\t\t    offset\n+\t\t\t\t\t    + frame.nsseregs * 16\n+\t\t\t\t\t    + frame.padding0, style == 2);\n+        }\n \n       /* eh_return epilogues need %ecx added to the stack pointer.  */\n       if (style == 2)\n@@ -8237,14 +8357,18 @@ ix86_expand_epilogue (int style)\n \t    {\n \t      tmp = gen_rtx_PLUS (Pmode, stack_pointer_rtx, sa);\n \t      tmp = plus_constant (tmp, (frame.to_allocate\n-                                         + frame.nregs * UNITS_PER_WORD));\n+                                         + frame.nregs * UNITS_PER_WORD\n+\t\t\t\t\t + frame.nsseregs * 16\n+\t\t\t\t\t + frame.padding0));\n \t      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx, tmp));\n \t    }\n \t}\n       else if (!frame_pointer_needed)\n \tpro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t   GEN_INT (frame.to_allocate\n-\t\t\t\t\t    + frame.nregs * UNITS_PER_WORD),\n+\t\t\t\t\t    + frame.nregs * UNITS_PER_WORD\n+\t\t\t\t\t    + frame.nsseregs * 16\n+\t\t\t\t\t    + frame.padding0),\n \t\t\t\t   style);\n       /* If not an i386, mov & pop is faster than \"leave\".  */\n       else if (TARGET_USE_LEAVE || optimize_function_for_size_p (cfun)\n@@ -8275,13 +8399,24 @@ ix86_expand_epilogue (int style)\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n \t\t\t\t     hard_frame_pointer_rtx,\n \t\t\t\t     GEN_INT (offset), style);\n+          ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,\n+\t\t\t\t\t        frame.to_allocate, style == 2);\n+\t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (frame.nsseregs * 16), style);\n+\t}\n+      else if (frame.to_allocate || frame.nsseregs)\n+\t{\n+          ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,\n+\t\t\t\t\t        frame.to_allocate,\n+\t\t\t\t\t\tstyle == 2);\n+\t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t     GEN_INT (frame.to_allocate\n+\t\t\t\t     \t      + frame.nsseregs * 16\n+\t\t\t\t\t      + frame.padding0), style);\n \t}\n-      else if (frame.to_allocate)\n-\tpro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t   GEN_INT (frame.to_allocate), style);\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\tif (ix86_save_reg (regno, false))\n+\tif (!SSE_REGNO_P (regno) && ix86_save_reg (regno, false))\n \t  emit_insn ((*ix86_gen_pop1) (gen_rtx_REG (Pmode, regno)));\n       if (frame_pointer_needed)\n \t{"}, {"sha": "55935985a2921679a90749bb3bba02373d0b01fb", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=7650b83e78f13f3e7a7ffd4b1d7d0fdd48bc2592", "patch": "@@ -968,8 +968,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n         && ((cfun && cfun->machine->call_abi == MS_ABI)\t\t\t\\\n             || (!cfun && DEFAULT_ABI == MS_ABI)))\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n+        int i;\t\t\t\t\t\t\t\t\\\n         call_used_regs[4 /*RSI*/] = 0;                                  \\\n         call_used_regs[5 /*RDI*/] = 0;                                  \\\n+\tfor (i = 0; i < 8; i++)\t\t\t\t\t\t\\\n+\t  call_used_regs[45+i] = 0;\t\t\t\t\t\\\n+\tcall_used_regs[27] = call_used_regs[28] = 0;\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n "}]}