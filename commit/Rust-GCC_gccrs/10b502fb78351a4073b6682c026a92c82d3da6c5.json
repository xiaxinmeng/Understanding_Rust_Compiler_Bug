{"sha": "10b502fb78351a4073b6682c026a92c82d3da6c5", "node_id": "C_kwDOANBUbNoAKDEwYjUwMmZiNzgzNTFhNDA3M2I2NjgyYzAyNmE5MmM4MmQzZGE2YzU", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-04T10:36:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-04T10:41:41Z"}, "message": "Keep virtual SSA up-to-date in vectorizer\n\nThe following removes a FIXME where we fail(ed) to keep virtual\nSSA up-to-date, patching up the remaining two cases I managed to\ntrigger.  I've left an assert so that we pick up cases arising\nfor the cases I wasn't able to trigger.\n\n2022-07-04  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop-manip.cc (vect_do_peeling): Assert that\n\tno SSA update is needed instead of updating virtual SSA\n\tform.\n\t* tree-vect-stmts.cc (vectorizable_load): For hoisted\n\tinvariant load use the loop entry virtual use.\n\tFor emulated gather loads use the virtual use of the\n\toriginal stmt like vect_finish_stmt_generation would do.", "tree": {"sha": "568b211740e1fc1ce5e6e4b3f9ee6ce7aedbf323", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/568b211740e1fc1ce5e6e4b3f9ee6ce7aedbf323"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10b502fb78351a4073b6682c026a92c82d3da6c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b502fb78351a4073b6682c026a92c82d3da6c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b502fb78351a4073b6682c026a92c82d3da6c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b502fb78351a4073b6682c026a92c82d3da6c5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88b9d090aa1686ba52ce6016aeed66464fb0d4bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b9d090aa1686ba52ce6016aeed66464fb0d4bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b9d090aa1686ba52ce6016aeed66464fb0d4bb"}], "stats": {"total": 26, "additions": 16, "deletions": 10}, "files": [{"sha": "7b7af944dba001ed71a26ec46865286e074a344a", "filename": "gcc/tree-vect-loop-manip.cc", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b502fb78351a4073b6682c026a92c82d3da6c5/gcc%2Ftree-vect-loop-manip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b502fb78351a4073b6682c026a92c82d3da6c5/gcc%2Ftree-vect-loop-manip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.cc?ref=10b502fb78351a4073b6682c026a92c82d3da6c5", "patch": "@@ -2683,14 +2683,11 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   class loop *first_loop = loop;\n   bool irred_flag = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;\n \n-  /* We might have a queued need to update virtual SSA form.  As we\n-     delete the update SSA machinery below after doing a regular\n+  /* Historically we might have a queued need to update virtual SSA form.\n+     As we delete the update SSA machinery below after doing a regular\n      incremental SSA update during loop copying make sure we don't\n-     lose that fact.\n-     ???  Needing to update virtual SSA form by renaming is unfortunate\n-     but not all of the vectorizer code inserting new loads / stores\n-     properly assigns virtual operands to those statements.  */\n-  update_ssa (TODO_update_ssa_only_virtuals);\n+     lose that fact.  */\n+  gcc_assert (!need_ssa_update_p (cfun));\n \n   create_lcssa_for_virtual_phi (loop);\n "}, {"sha": "d6a6fe3fb384fcaa47abc7f40fff7801b93849db", "filename": "gcc/tree-vect-stmts.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b502fb78351a4073b6682c026a92c82d3da6c5/gcc%2Ftree-vect-stmts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b502fb78351a4073b6682c026a92c82d3da6c5/gcc%2Ftree-vect-stmts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.cc?ref=10b502fb78351a4073b6682c026a92c82d3da6c5", "patch": "@@ -9024,9 +9024,16 @@ vectorizable_load (vec_info *vinfo,\n \t\t\t     \"hoisting out of the vectorized loop: %G\", stmt);\n \t  scalar_dest = copy_ssa_name (scalar_dest);\n \t  tree rhs = unshare_expr (gimple_assign_rhs1 (stmt));\n-\t  gsi_insert_on_edge_immediate\n-\t    (loop_preheader_edge (loop),\n-\t     gimple_build_assign (scalar_dest, rhs));\n+\t  edge pe = loop_preheader_edge (loop);\n+\t  gphi *vphi = get_virtual_phi (loop->header);\n+\t  tree vuse;\n+\t  if (vphi)\n+\t    vuse = PHI_ARG_DEF_FROM_EDGE (vphi, pe);\n+\t  else\n+\t    vuse = gimple_vuse (gsi_stmt (*gsi));\n+\t  gimple *new_stmt = gimple_build_assign (scalar_dest, rhs);\n+\t  gimple_set_vuse (new_stmt, vuse);\n+\t  gsi_insert_on_edge_immediate (pe, new_stmt);\n \t}\n       /* These copies are all equivalent, but currently the representation\n \t requires a separate STMT_VINFO_VEC_STMT for each one.  */\n@@ -9769,6 +9776,8 @@ vectorizable_load (vec_info *vinfo,\n \t\t\t    tree ref = build2 (MEM_REF, ltype, ptr,\n \t\t\t\t\t       build_int_cst (ref_type, 0));\n \t\t\t    new_stmt = gimple_build_assign (elt, ref);\n+\t\t\t    gimple_set_vuse (new_stmt,\n+\t\t\t\t\t     gimple_vuse (gsi_stmt (*gsi)));\n \t\t\t    gimple_seq_add_stmt (&stmts, new_stmt);\n \t\t\t    CONSTRUCTOR_APPEND_ELT (ctor_elts, NULL_TREE, elt);\n \t\t\t  }"}]}