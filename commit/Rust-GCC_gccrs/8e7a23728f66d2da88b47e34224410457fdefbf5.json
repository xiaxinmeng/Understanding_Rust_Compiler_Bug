{"sha": "8e7a23728f66d2da88b47e34224410457fdefbf5", "node_id": "C_kwDOANBUbNoAKDhlN2EyMzcyOGY2NmQyZGE4OGI0N2UzNDIyNDQxMDQ1N2ZkZWZiZjU", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-01-10T14:47:08Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-01-10T14:47:08Z"}, "message": "ira: Try to avoid propagating conflicts\n\nSuppose that:\n\n- an inner loop L contains an allocno A\n- L clobbers hard register R while A is live\n- A's parent allocno is AP\n\nPreviously, propagate_allocno_info would propagate conflict sets up the\nloop tree, so that the conflict between A and R would become a conflict\nbetween AP and R (and so on for ancestors of AP).\n\nHowever, when IRA treats loops as separate allocation regions, it can\ndecide on a loop-by-loop basis whether to allocate a register or spill\nto memory.  Conflicts in inner loops therefore don't need to become\nhard conflicts in parent loops.  Instead we can record that using the\n\u201cconflicting\u201d registers for the parent allocnos has a higher cost.\nIn the example above, this higher cost is the sum of:\n\n- the cost of saving R on entry to L\n- the cost of keeping the pseudo register in memory throughout L\n- the cost of reloading R on exit from L\n\nThis value is also a cap on the hard register cost that A can contribute\nto AP in general (not just for conflicts).  Whatever allocation we pick\nfor AP, there is always the option of spilling that register to memory\nthroughout L, so the cost to A of allocating a register to AP can't be\nmore than the cost of spilling A.\n\nTo take an extreme example: if allocating a register R2 to A is more\nexpensive than spilling A to memory, ALLOCNO_HARD_REG_COSTS (A)[R2]\ncould be (say) 2 times greater than ALLOCNO_MEMORY_COST (A) or 100\ntimes greater than ALLOCNO_MEMORY_COST (A).  But this scale factor\ndoesn't matter to AP.  All that matters is that R2 is more expensive\nthan memory for A, so that allocating R2 to AP should be costed as\nspilling A to memory (again assuming that A and AP are in different\nallocation regions).  Propagating a factor of 100 would distort the\nregister costs for AP.\n\nmove_spill_restore tries to undo the propagation done by\npropagate_allocno_info, so we need some extra processing there.\n\ngcc/\n\tPR rtl-optimization/98782\n\t* ira-int.h (ira_allocno::might_conflict_with_parent_p): New field.\n\t(ALLOCNO_MIGHT_CONFLICT_WITH_PARENT_P): New macro.\n\t(ira_single_region_allocno_p): New function.\n\t(ira_total_conflict_hard_regs): Likewise.\n\t* ira-build.c (ira_create_allocno): Initialize\n\tALLOCNO_MIGHT_CONFLICT_WITH_PARENT_P.\n\t(ira_propagate_hard_reg_costs): New function.\n\t(propagate_allocno_info): Use it.  Try to avoid propagating\n\thard register conflicts to parent allocnos if we can handle\n\tthe conflicts by spilling instead.  Limit the propagated\n\tregister costs to the cost of spilling throughout the child loop.\n\t* ira-color.c (color_pass): Use ira_single_region_allocno_p to\n\ttest whether a child and parent allocno can share the same\n\tregister.\n\t(move_spill_restore): Adjust for the new behavior of\n\tpropagate_allocno_info.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/reg-alloc-2.c: New test.", "tree": {"sha": "5ce6592a88faae7ccb7c4156714217ca74a684de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ce6592a88faae7ccb7c4156714217ca74a684de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e7a23728f66d2da88b47e34224410457fdefbf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7a23728f66d2da88b47e34224410457fdefbf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7a23728f66d2da88b47e34224410457fdefbf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7a23728f66d2da88b47e34224410457fdefbf5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d54565d87ff79b882208dfb29af50232033c233d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54565d87ff79b882208dfb29af50232033c233d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d54565d87ff79b882208dfb29af50232033c233d"}], "stats": {"total": 192, "additions": 169, "deletions": 23}, "files": [{"sha": "875b4d8ed7c9c02a0b7f2233f140d1924e623de6", "filename": "gcc/ira-build.c", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7a23728f66d2da88b47e34224410457fdefbf5/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7a23728f66d2da88b47e34224410457fdefbf5/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=8e7a23728f66d2da88b47e34224410457fdefbf5", "patch": "@@ -497,6 +497,7 @@ ira_create_allocno (int regno, bool cap_p,\n   bitmap_set_bit (loop_tree_node->all_allocnos, ALLOCNO_NUM (a));\n   ALLOCNO_NREFS (a) = 0;\n   ALLOCNO_FREQ (a) = 0;\n+  ALLOCNO_MIGHT_CONFLICT_WITH_PARENT_P (a) = false;\n   ALLOCNO_HARD_REGNO (a) = -1;\n   ALLOCNO_CALL_FREQ (a) = 0;\n   ALLOCNO_CALLS_CROSSED_NUM (a) = 0;\n@@ -1991,6 +1992,35 @@ propagate_modified_regnos (ira_loop_tree_node_t loop_tree_node)\n \t\t   loop_tree_node->modified_regnos);\n }\n \n+/* Propagate ALLOCNO_HARD_REG_COSTS from A to PARENT_A.  Use SPILL_COST\n+   as the cost of spilling a register throughout A (which we have to do\n+   for PARENT_A allocations that conflict with A).  */\n+static void\n+ira_propagate_hard_reg_costs (ira_allocno_t parent_a, ira_allocno_t a,\n+\t\t\t      int spill_cost)\n+{\n+  HARD_REG_SET conflicts = ira_total_conflict_hard_regs (a);\n+  conflicts &= ~ira_total_conflict_hard_regs (parent_a);\n+\n+  auto costs = ALLOCNO_HARD_REG_COSTS (a);\n+  if (!hard_reg_set_empty_p (conflicts))\n+    ALLOCNO_MIGHT_CONFLICT_WITH_PARENT_P (a) = true;\n+  else if (!costs)\n+    return;\n+\n+  auto aclass = ALLOCNO_CLASS (a);\n+  ira_allocate_and_set_costs (&ALLOCNO_HARD_REG_COSTS (parent_a),\n+\t\t\t      aclass, ALLOCNO_CLASS_COST (parent_a));\n+  auto parent_costs = ALLOCNO_HARD_REG_COSTS (parent_a);\n+  for (int i = 0; i < ira_class_hard_regs_num[aclass]; ++i)\n+    if (TEST_HARD_REG_BIT (conflicts, ira_class_hard_regs[aclass][i]))\n+      parent_costs[i] += spill_cost;\n+    else if (costs)\n+      /* The cost to A of allocating this register to PARENT_A can't\n+\t be more than the cost of spilling the register throughout A.  */\n+      parent_costs[i] += MIN (costs[i], spill_cost);\n+}\n+\n /* Propagate new info about allocno A (see comments about accumulated\n    info in allocno definition) to the corresponding allocno on upper\n    loop tree level.  So allocnos on upper levels accumulate\n@@ -2019,12 +2049,27 @@ propagate_allocno_info (void)\n \t  && bitmap_bit_p (ALLOCNO_LOOP_TREE_NODE (a)->border_allocnos,\n \t\t\t   ALLOCNO_NUM (a)))\n \t{\n+\t  /* Calculate the cost of storing to memory on entry to A's loop,\n+\t     referencing as memory within A's loop, and restoring from\n+\t     memory on exit from A's loop.  */\n+\t  ira_loop_border_costs border_costs (a);\n+\t  int spill_cost = INT_MAX;\n+\t  if (ira_subloop_allocnos_can_differ_p (parent_a))\n+\t    spill_cost = (border_costs.spill_inside_loop_cost ()\n+\t\t\t  + ALLOCNO_MEMORY_COST (a));\n+\n \t  if (! ALLOCNO_BAD_SPILL_P (a))\n \t    ALLOCNO_BAD_SPILL_P (parent_a) = false;\n \t  ALLOCNO_NREFS (parent_a) += ALLOCNO_NREFS (a);\n \t  ALLOCNO_FREQ (parent_a) += ALLOCNO_FREQ (a);\n+\n+\t  /* If A's allocation can differ from PARENT_A's, we can if necessary\n+\t     spill PARENT_A on entry to A's loop and restore it afterwards.\n+\t     Doing that has cost SPILL_COST.  */\n+\t  if (!ira_subloop_allocnos_can_differ_p (parent_a))\n+\t    merge_hard_reg_conflicts (a, parent_a, true);\n+\n \t  ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n-\t  merge_hard_reg_conflicts (a, parent_a, true);\n \t  ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n \t    += ALLOCNO_CALLS_CROSSED_NUM (a);\n \t  ALLOCNO_CHEAP_CALLS_CROSSED_NUM (parent_a)\n@@ -2037,15 +2082,15 @@ propagate_allocno_info (void)\n \t    += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n \t  aclass = ALLOCNO_CLASS (a);\n \t  ira_assert (aclass == ALLOCNO_CLASS (parent_a));\n-\t  ira_allocate_and_accumulate_costs\n-\t    (&ALLOCNO_HARD_REG_COSTS (parent_a), aclass,\n-\t     ALLOCNO_HARD_REG_COSTS (a));\n+\t  ira_propagate_hard_reg_costs (parent_a, a, spill_cost);\n \t  ira_allocate_and_accumulate_costs\n \t    (&ALLOCNO_CONFLICT_HARD_REG_COSTS (parent_a),\n \t     aclass,\n \t     ALLOCNO_CONFLICT_HARD_REG_COSTS (a));\n+\t  /* The cost to A of allocating a register to PARENT_A can't be\n+\t     more than the cost of spilling the register throughout A.  */\n \t  ALLOCNO_CLASS_COST (parent_a)\n-\t    += ALLOCNO_CLASS_COST (a);\n+\t    += MIN (ALLOCNO_CLASS_COST (a), spill_cost);\n \t  ALLOCNO_MEMORY_COST (parent_a) += ALLOCNO_MEMORY_COST (a);\n \t}\n }"}, {"sha": "4344ee6689ed8628e45fa780dcbb9f2144299080", "filename": "gcc/ira-color.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7a23728f66d2da88b47e34224410457fdefbf5/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7a23728f66d2da88b47e34224410457fdefbf5/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=8e7a23728f66d2da88b47e34224410457fdefbf5", "patch": "@@ -3344,7 +3344,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n   unsigned int j;\n   bitmap_iterator bi;\n   machine_mode mode;\n-  enum reg_class rclass, aclass, pclass;\n+  enum reg_class rclass, aclass;\n   ira_allocno_t a, subloop_allocno;\n   ira_loop_tree_node_t subloop_node;\n \n@@ -3389,10 +3389,9 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t/* Remove from processing in the next loop.  */\n \tbitmap_clear_bit (consideration_allocno_bitmap, j);\n \trclass = ALLOCNO_CLASS (a);\n-\tpclass = ira_pressure_class_translate[rclass];\n-\tif (flag_ira_region == IRA_REGION_MIXED\n-\t    && (loop_tree_node->reg_pressure[pclass]\n-\t\t<= ira_class_hard_regs_num[pclass]))\n+\tsubloop_allocno = ALLOCNO_CAP_MEMBER (a);\n+\tsubloop_node = ALLOCNO_LOOP_TREE_NODE (subloop_allocno);\n+\tif (ira_single_region_allocno_p (a, subloop_allocno))\n \t  {\n \t    mode = ALLOCNO_MODE (a);\n \t    hard_regno = ALLOCNO_HARD_REGNO (a);\n@@ -3402,8 +3401,6 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t\tira_assert (index >= 0);\n \t      }\n \t    regno = ALLOCNO_REGNO (a);\n-\t    subloop_allocno = ALLOCNO_CAP_MEMBER (a);\n-\t    subloop_node = ALLOCNO_LOOP_TREE_NODE (subloop_allocno);\n \t    ira_assert (!ALLOCNO_ASSIGNED_P (subloop_allocno));\n \t    ALLOCNO_HARD_REGNO (subloop_allocno) = hard_regno;\n \t    ALLOCNO_ASSIGNED_P (subloop_allocno) = true;\n@@ -3426,7 +3423,6 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t  ira_assert (ALLOCNO_CAP_MEMBER (a) == NULL);\n \t  mode = ALLOCNO_MODE (a);\n \t  rclass = ALLOCNO_CLASS (a);\n-\t  pclass = ira_pressure_class_translate[rclass];\n \t  hard_regno = ALLOCNO_HARD_REGNO (a);\n \t  /* Use hard register class here.  ??? */\n \t  if (hard_regno >= 0)\n@@ -3443,11 +3439,11 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t  ira_assert (ALLOCNO_CLASS (subloop_allocno) == rclass);\n \t  ira_assert (bitmap_bit_p (subloop_node->all_allocnos,\n \t\t\t\t    ALLOCNO_NUM (subloop_allocno)));\n-\t  if ((flag_ira_region == IRA_REGION_MIXED\n-\t       && (loop_tree_node->reg_pressure[pclass]\n-\t\t   <= ira_class_hard_regs_num[pclass]))\n+\t  if (ira_single_region_allocno_p (a, subloop_allocno)\n \t      || !ira_subloop_allocnos_can_differ_p (a, hard_regno >= 0))\n \t    {\n+\t      gcc_assert (!ALLOCNO_MIGHT_CONFLICT_WITH_PARENT_P\n+\t\t\t  (subloop_allocno));\n \t      if (! ALLOCNO_ASSIGNED_P (subloop_allocno))\n \t\t{\n \t\t  ALLOCNO_HARD_REGNO (subloop_allocno) = hard_regno;\n@@ -3583,14 +3579,35 @@ move_spill_restore (void)\n \t      if (subloop_allocno == NULL)\n \t\tcontinue;\n \t      ira_assert (rclass == ALLOCNO_CLASS (subloop_allocno));\n-\t      /* We have accumulated cost.  To get the real cost of\n-\t\t allocno usage in the loop we should subtract costs of\n-\t\t the subloop allocnos.  */\n-\t      cost -= (ALLOCNO_MEMORY_COST (subloop_allocno)\n-\t\t       - (ALLOCNO_HARD_REG_COSTS (subloop_allocno) == NULL\n-\t\t\t  ? ALLOCNO_CLASS_COST (subloop_allocno)\n-\t\t\t  : ALLOCNO_HARD_REG_COSTS (subloop_allocno)[index]));\n \t      ira_loop_border_costs border_costs (subloop_allocno);\n+\n+\t      /* We have accumulated cost.  To get the real cost of\n+\t\t allocno usage in the loop we should subtract the costs\n+\t\t added by propagate_allocno_info for the subloop allocnos.  */\n+\t      int reg_cost\n+\t\t= (ALLOCNO_HARD_REG_COSTS (subloop_allocno) == NULL\n+\t\t   ? ALLOCNO_CLASS_COST (subloop_allocno)\n+\t\t   : ALLOCNO_HARD_REG_COSTS (subloop_allocno)[index]);\n+\n+\t      int spill_cost\n+\t\t= (border_costs.spill_inside_loop_cost ()\n+\t\t   + ALLOCNO_MEMORY_COST (subloop_allocno));\n+\n+\t      /* If HARD_REGNO conflicts with SUBLOOP_A then\n+\t\t propagate_allocno_info will have propagated\n+\t\t the cost of spilling HARD_REGNO in SUBLOOP_NODE.\n+\t\t (ira_subloop_allocnos_can_differ_p must be true\n+\t\t in that case.)  Otherwise, SPILL_COST acted as\n+\t\t a cap on the propagated register cost, in cases\n+\t\t where the allocations can differ.  */\n+\t      auto conflicts = ira_total_conflict_hard_regs (subloop_allocno);\n+\t      if (TEST_HARD_REG_BIT (conflicts, hard_regno))\n+\t\treg_cost = spill_cost;\n+\t      else if (ira_subloop_allocnos_can_differ_p (a))\n+\t\treg_cost = MIN (reg_cost, spill_cost);\n+\n+\t      cost -= ALLOCNO_MEMORY_COST (subloop_allocno) - reg_cost;\n+\n \t      if ((hard_regno2 = ALLOCNO_HARD_REGNO (subloop_allocno)) < 0)\n \t\t/* The register was spilled in the subloop.  If we spill\n \t\t   it in the outer loop too then we'll no longer need to"}, {"sha": "8b87498f77f633ff19c3e5df28166a7e0ea3af2c", "filename": "gcc/ira-int.h", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7a23728f66d2da88b47e34224410457fdefbf5/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7a23728f66d2da88b47e34224410457fdefbf5/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=8e7a23728f66d2da88b47e34224410457fdefbf5", "patch": "@@ -314,6 +314,13 @@ struct ira_allocno\n      vector where a bit with given index represents allocno with the\n      same number.  */\n   unsigned int conflict_vec_p : 1;\n+  /* True if the parent loop has an allocno for the same register and\n+     if the parent allocno's assignment might not be valid in this loop.\n+     This means that we cannot merge this allocno and the parent allocno\n+     together.\n+\n+     This is only ever true for non-cap allocnos.  */\n+  unsigned int might_conflict_with_parent_p : 1;\n   /* Hard register assigned to given allocno.  Negative value means\n      that memory was allocated to the allocno.  During the reload,\n      spilled allocno has value equal to the corresponding stack slot\n@@ -423,6 +430,8 @@ struct ira_allocno\n #define ALLOCNO_CAP_MEMBER(A) ((A)->cap_member)\n #define ALLOCNO_NREFS(A) ((A)->nrefs)\n #define ALLOCNO_FREQ(A) ((A)->freq)\n+#define ALLOCNO_MIGHT_CONFLICT_WITH_PARENT_P(A) \\\n+  ((A)->might_conflict_with_parent_p)\n #define ALLOCNO_HARD_REGNO(A) ((A)->hard_regno)\n #define ALLOCNO_CALL_FREQ(A) ((A)->call_freq)\n #define ALLOCNO_CALLS_CROSSED_NUM(A) ((A)->calls_crossed_num)\n@@ -1623,4 +1632,32 @@ ira_subloop_allocnos_can_differ_p (ira_allocno_t a, bool allocated_p = true)\n   return true;\n }\n \n+/* Return true if we should treat A and SUBLOOP_A as belonging to a\n+   single region.  */\n+inline bool\n+ira_single_region_allocno_p (ira_allocno_t a, ira_allocno_t subloop_a)\n+{\n+  if (flag_ira_region != IRA_REGION_MIXED)\n+    return false;\n+\n+  if (ALLOCNO_MIGHT_CONFLICT_WITH_PARENT_P (subloop_a))\n+    return false;\n+\n+  auto rclass = ALLOCNO_CLASS (a);\n+  auto pclass = ira_pressure_class_translate[rclass];\n+  auto loop_used_regs = ALLOCNO_LOOP_TREE_NODE (a)->reg_pressure[pclass];\n+  return loop_used_regs <= ira_class_hard_regs_num[pclass];\n+}\n+\n+/* Return the set of all hard registers that conflict with A.  */\n+inline HARD_REG_SET\n+ira_total_conflict_hard_regs (ira_allocno_t a)\n+{\n+  auto obj_0 = ALLOCNO_OBJECT (a, 0);\n+  HARD_REG_SET conflicts = OBJECT_TOTAL_CONFLICT_HARD_REGS (obj_0);\n+  for (int i = 1; i < ALLOCNO_NUM_OBJECTS (a); i++)\n+    conflicts |= OBJECT_TOTAL_CONFLICT_HARD_REGS (ALLOCNO_OBJECT (a, i));\n+  return conflicts;\n+}\n+\n #endif /* GCC_IRA_INT_H */"}, {"sha": "d4d260c96b54f89b309c8606f96defefb634cf2c", "filename": "gcc/testsuite/gcc.target/aarch64/reg-alloc-2.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7a23728f66d2da88b47e34224410457fdefbf5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7a23728f66d2da88b47e34224410457fdefbf5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-2.c?ref=8e7a23728f66d2da88b47e34224410457fdefbf5", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-options \"-O2 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#define PROB 0.1\n+\n+struct L\n+{\n+  int data;\n+  volatile struct L *next;\n+  volatile struct L *inner;\n+};\n+\n+/* The thing we're testing here is that the !head->inner path of the outer loop\n+   body has no stack accesses.  It's possible that we'll need to update this\n+   pattern for unrelated code changes. but the test should be XFAILed rather\n+   than changed if any new stack accesses occur on the !head->inner path.  */\n+/*\n+** foo:\n+**\t...\n+**\tldr\t(w[0-9]+), \\[(x[0-9]+)\\]\n+**\tadd\t(w[0-9]+), (?:\\3, \\1|\\1, \\3)\n+**\tldr\t(x[0-9]+), \\[\\2, #?16\\]\n+**\tstr\t\\3, \\[\\2\\]\n+**\tldr\t\\2, \\[\\2, #?8\\]\n+**\tcbn?z\t\\4, .*\n+**\t...\n+**\tret\n+*/\n+void\n+foo (volatile struct L *head, int inc)\n+{\n+  while (head)\n+    {\n+      inc = head->data + inc;\n+      volatile struct L *inner = head->inner;\n+      head->data = inc;\n+      head = head->next;\n+      if (__builtin_expect_with_probability (inner != 0, 0, PROB))\n+\tfor (int i = 0; i < 1000; ++i)\n+\t  /* Leave x30 for i.  */\n+\t  asm volatile (\"// foo\" :::\n+\t\t\t\"x0\", \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\",\n+\t\t\t\"x8\", \"x9\", \"x10\", \"x11\", \"x12\", \"x13\", \"x14\", \"x15\",\n+\t\t\t\"x16\", \"x17\", \"x18\", \"x19\", \"x20\", \"x21\", \"x22\", \"x23\",\n+\t\t\t\"x24\", \"x25\", \"x26\", \"x27\", \"x28\");\n+    }\n+}"}]}