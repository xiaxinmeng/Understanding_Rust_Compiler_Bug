{"sha": "0d22e81f866c4899b4481f2052833cd031a778d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQyMmU4MWY4NjZjNDg5OWI0NDgxZjIwNTI4MzNjZDAzMWE3NzhkMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2005-06-16T21:25:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-06-16T21:25:00Z"}, "message": "re PR tree-optimization/22018 (VRP miscompiles multiply)\n\n\tPR tree-optimization/22018\n\t* tree-vrp.c (vrp_int_const_binop): Overhaul handling of overflow.\n\nFrom-SVN: r101097", "tree": {"sha": "84c25a09eddd7ede8024c7825f30c9798ec849d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84c25a09eddd7ede8024c7825f30c9798ec849d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d22e81f866c4899b4481f2052833cd031a778d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d22e81f866c4899b4481f2052833cd031a778d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d22e81f866c4899b4481f2052833cd031a778d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d22e81f866c4899b4481f2052833cd031a778d1/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b9c745ee35407c173875e5a15d8e98a242330a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b9c745ee35407c173875e5a15d8e98a242330a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b9c745ee35407c173875e5a15d8e98a242330a6"}], "stats": {"total": 50, "additions": 33, "deletions": 17}, "files": [{"sha": "6120d5caedd303ecb3f04b6aad5d3129e348f80d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d22e81f866c4899b4481f2052833cd031a778d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d22e81f866c4899b4481f2052833cd031a778d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d22e81f866c4899b4481f2052833cd031a778d1", "patch": "@@ -1,3 +1,8 @@\n+2005-06-16  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR tree-optimization/22018\n+\t* tree-vrp.c (vrp_int_const_binop): Overhaul handling of overflow.\n+\n 2005-06-16  Richard Henderson  <rth@redhat.com>\n \n \tPR tree-opt/22035"}, {"sha": "e040f41bdfa21c9d7fdb0cb1360a69d698a83191", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d22e81f866c4899b4481f2052833cd031a778d1/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d22e81f866c4899b4481f2052833cd031a778d1/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=0d22e81f866c4899b4481f2052833cd031a778d1", "patch": "@@ -986,30 +986,41 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n   res = int_const_binop (code, val1, val2, 0);\n \n   /* If the operation overflowed but neither VAL1 nor VAL2 are\n-     overflown, return -INF or +INF depending on whether VAL1 CODE\n-     VAL2 is a growing function or not.  */\n+     overflown, return -INF or +INF depending on the operation\n+     and the combination of signs of the operands.  */\n   if (TREE_OVERFLOW (res)\n       && !TREE_OVERFLOW (val1)\n       && !TREE_OVERFLOW (val2))\n     {\n-      bool grows = false;\n       int sgn1 = tree_int_cst_sgn (val1);\n       int sgn2 = tree_int_cst_sgn (val2);\n \n-      /* Determine whether VAL1 CODE VAL2 yields a growing value.\n-\t Notice that we only need to handle the restricted set of\n-\t operations handled by extract_range_from_binary_expr:\n-\n-\t VAL1 + VAL2 grows if VAL2 is >= 0.\n-\t VAL1 * VAL2 grows if both VAL1 and VAL2 have the same sign.\n-\t VAL1 - VAL2 grows if VAL2 is < 0 (because it becomes an addition).\n-      */\n-      if ((code == PLUS_EXPR && sgn2 >= 0)\n-\t  || (code == MULT_EXPR && sgn1 == sgn2)\n-\t  || (code == MINUS_EXPR && sgn2 < 0))\n-\tgrows = true;\n-\n-      if (grows)\n+      /* Notice that we only need to handle the restricted set of\n+\t operations handled by extract_range_from_binary_expr.\n+\t Among them, only multiplication, addition and subtraction\n+\t can yield overflow without overflown operands because we\n+\t are working with integral types only... except in the\n+\t case VAL1 = -INF and VAL2 = -1 which overflows to +INF\n+\t for division too.  */\n+\n+      /* For multiplication, the sign of the overflow is given\n+\t by the comparison of the signs of the operands.  */\n+      if ((code == MULT_EXPR && sgn1 == sgn2)\n+          /* For addition, the operands must be of the same sign\n+\t     to yield an overflow.  Its sign is therefore that\n+\t     of one of the operands, for example the first.  */\n+\t  || (code == PLUS_EXPR && sgn1 > 0)\n+\t  /* For subtraction, the operands must be of different\n+\t     signs to yield an overflow.  Its sign is therefore\n+\t     that of the first operand or the opposite of that\n+\t     of the second operand.  */\n+\t  || (code == MINUS_EXPR && sgn1 > 0)\n+\t  /* For division, the only case is -INF / -1 = +INF.  */\n+\t  || code == TRUNC_DIV_EXPR\n+\t  || code == FLOOR_DIV_EXPR\n+\t  || code == CEIL_DIV_EXPR\n+\t  || code == EXACT_DIV_EXPR\n+\t  || code == ROUND_DIV_EXPR)\n \treturn TYPE_MAX_VALUE (TREE_TYPE (res));\n       else\n \treturn TYPE_MIN_VALUE (TREE_TYPE (res));"}]}