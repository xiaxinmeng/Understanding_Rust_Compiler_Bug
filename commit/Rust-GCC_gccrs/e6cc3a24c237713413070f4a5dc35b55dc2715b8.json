{"sha": "e6cc3a24c237713413070f4a5dc35b55dc2715b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZjYzNhMjRjMjM3NzEzNDEzMDcwZjRhNWRjMzViNTVkYzI3MTViOA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-05T00:24:00Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-05T00:24:00Z"}, "message": "cpplib.h (CPP_AT_NAME, [...]): New token types.\n\n\t* cpplib.h (CPP_AT_NAME, CPP_OBJC_STRING): New token types.\n\t(struct cpp_options): Add narrow_charset, wide_charset,\n\tbytes_big_endian fields.  Remove EBCDIC field.\n\t(cpp_init_iconv, cpp_interpret_string): New external interfaces.\n\n\t* cpphash.h: Include <iconv.h> if we have it, otherwise\n\tprovide a dummy definition of iconv_t.\n\t(struct cpp_reader): Add narrow_cset_desc and wide_cset_desc fields.\n\t(_cpp_valid_ucn): Update prototype.\n\t(_cpp_destroy_iconv): New prototype.\n\n\t* doc/cpp.texi: Document character set handling.\n\t* doc/cppopts.texi: Document -fexec-charset= and -fexec-wide-charset=.\n\t* doc/extend.texi: Delete entire section on multiline strings.\n\tRewrite section on __FUNCTION__ etc now that these are\n\tvariables in C.\n\n\t* cppucnid.tab, cppucnid.pl: New files.\n\t* cppucnid.h: New generated file.\n\t* cppcharset.c: Include cppucnid.h.  Lots of commentary added.\n\t(iconv_open, iconv, iconv_close): Provide dummy definitions\n\tif !HAVE_ICONV.\n\t(SOURCE_CHARSET, struct strbuf, init_iconv_desc, cpp_init_iconv,\n\t_cpp_destroy_iconv, convert_cset, width_to_mask, convert_ucn,\n\temit_numeric_escape, convert_hex, convert_oct, convert_escape,\n\tcpp_interpret_string, narrow_str_to_charconst,\n\twide_str_to_charconst): New.\n\t(ucn_valid_in_identifier): Use a binary search through the\n\tucnranges table defined in cppucnid.h, not a long chain of if\n\tstatements.\n\t(_cpp_valid_ucn): Add a limit pointer.  Downgrade \"universal\n\tcharacter names are only valid in C++ and C99\" to a warning.\n\tIssue the \"meaning of \\[uU] is different in traditional C\"\n\twarning here.  Take care not to let iconv see an invalid UCS\n\tvalue if we get a malformed UCN.  Issue an error if we don't\n\thave iconv.\n\t(cpp_interpret_charconst): Moved here from cpplex.c.  Use\n\tcpp_interpret_string to do the heavy lifting.\n\n\t* cppinit.c (cpp_create_reader): Initialize bytes_big_endian,\n\tnarrow_charset, wide_charset fields of options structure.\n\t(cpp_destroy): Call _cpp_destroy_iconv.\n\t* cpplex.c (forms_identifier_p): Adjust call to _cpp_valid_ucn.\n\t(maybe_read_ucn, hex_digit_value, cpp_parse_escape): Delete.\n\t(cpp_interpret_charconst): Moved to cppcharset.c.\n\t* cpplib.c (dequote_string): Delete.\n\t(interpret_string_notranslate): New.\n\t(do_line, do_linemarker): Use interpret_string_notranslate.\n\n\t* Makefile.in (cppcharset.o): Depend on cppucnid.h.\n\n\t* c-common.c (fname_string, combine_strings): Delete.\n\t* c-common.h (fname_string, combine_strings): Delete prototypes.\n\t* c-lex.c (ignore_escape_flag): Delete.\n\t(cb_ident): Use cpp_interpret_string, not lex_string.\n\t(get_nonpadding_token): New function.\n\t(c_lex): Handle Objective-C @-prefixed identifiers and strings here.\n\tAdjust calls to lex_string.  Don't write *value twice.\n\t(lex_string): Now handles string constant concatenation.\n\tMost of the work handed off to cpp_interpret_string.\n\tCall fix_string_type here.\n\t* c-parse.in (STRING_FUNC_NAME, VAR_FUNC_NAME): Replace with\n\tFUNC_NAME, throughout.\n\t(OBJC_STRING): New token type.\n\t(primary:STRING): No need to call fix_string_type here.\n\t(primary:objc_string): Make that OBJC_STRING.\n\t(objc_string nonterminal): Delete.\n\t(yylexname): Delete code to handle fake string constants.\n\t(yylexstring): Delete entirely.\n\t(_yylex): Handle CPP_AT_NAME and CPP_OBJC_STRING.  No need\n\tto handle CPP_ATSIGN.\n\n\t* c.opt (-fexec-charset=, -fwide-exec-charset=): New options.\n\t* c-opts.c (missing_arg, c_common_handle_option): Handle\n\tOPT_fexec_charset_ and OPT_fwide_exec_charset_.\n\t(c_common_init): Set cpp_opts->bytes_big_endian, not\n\tcpp_opts->EBCDIC.  Call cpp_init_iconv.\n\t(print_help): Document -fexec-charset= and -fexec-wide-charset=.\n\t(TARGET_EBCDIC): Delete default definition.\n\n\t* objc/objc-act.c (build_objc_string_object): No need to\n\thandle string constant concatenation.\n\ncp:\n\t* parser.c (cp_lexer_read_token): No need to handle string\n\tconstant concatenation.\n\ntestsuite:\n\t* gcc.c-torture/execute/wchar_t-1.x: New file; XFAIL wchar_t-1.c\n\teverywhere.\n\t* gcc.dg/concat.c: Concatenation of string constants with\n\t__FUNCTION__ / __PRETTY_FUNCTION__ is now a hard error.\n\t* gcc.dg/wtr-strcat-1.c: Loosen dg-warning regexp.\n\t* gcc.dg/cpp/escape-2.c: Use wide character constants where\n\tnecessary to avoid multi-character character constant warning.\n\t* gcc.dg/cpp/escape.c: Likewise.\n\t* gcc.dg/cpp/ucs.c: Likewise.\n\tRemove backslashes from dg-bogus comments, as they confuse Tcl.\n\tFix a typo.\n\nlibstdc++-v3:\n\t* testsuite/22_locale/collate/compare/wchar_t/2.cc\n\t* testsuite/22_locale/collate/compare/wchar_t/wrapped_env.cc\n\t* testsuite/22_locale/collate/compare/wchar_t/wrapped_locale.cc\n\t* testsuite/22_locale/collate/hash/wchar_t/2.cc\n\t* testsuite/22_locale/collate/hash/wchar_t/wrapped_env.cc\n\t* testsuite/22_locale/collate/hash/wchar_t/wrapped_locale.cc\n\t* testsuite/22_locale/collate/transform/wchar_t/2.cc\n\t* testsuite/22_locale/collate/transform/wchar_t/wrapped_env.cc\n\t* testsuite/22_locale/collate/transform/wchar_t/wrapped_locale.cc:\n\tXFAIL on all targets.\n\nFrom-SVN: r68952", "tree": {"sha": "34c7734f7acee49beff2b3d99cbdf53576456697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34c7734f7acee49beff2b3d99cbdf53576456697"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6cc3a24c237713413070f4a5dc35b55dc2715b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6cc3a24c237713413070f4a5dc35b55dc2715b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6cc3a24c237713413070f4a5dc35b55dc2715b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6cc3a24c237713413070f4a5dc35b55dc2715b8/comments", "author": null, "committer": null, "parents": [{"sha": "61aeb06fe596bd822b665d65a271804efdaf0053", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61aeb06fe596bd822b665d65a271804efdaf0053", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61aeb06fe596bd822b665d65a271804efdaf0053"}], "stats": {"total": 3635, "additions": 2201, "deletions": 1434}, "files": [{"sha": "0b077b0b04108c5a9a799781085c98bb926c8387", "filename": "gcc/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -1,3 +1,88 @@\n+2003-07-04  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* cpplib.h (CPP_AT_NAME, CPP_OBJC_STRING): New token types.\n+\t(struct cpp_options): Add narrow_charset, wide_charset,\n+\tbytes_big_endian fields.  Remove EBCDIC field.\n+\t(cpp_init_iconv, cpp_interpret_string): New external interfaces.\n+\n+\t* cpphash.h: Include <iconv.h> if we have it, otherwise\n+\tprovide a dummy definition of iconv_t.\n+\t(struct cpp_reader): Add narrow_cset_desc and wide_cset_desc fields.\n+\t(_cpp_valid_ucn): Update prototype.\n+\t(_cpp_destroy_iconv): New prototype.\n+\n+\t* doc/cpp.texi: Document character set handling.\n+\t* doc/cppopts.texi: Document -fexec-charset= and -fexec-wide-charset=.\n+\t* doc/extend.texi: Delete entire section on multiline strings.\n+\tRewrite section on __FUNCTION__ etc now that these are\n+\tvariables in C.\n+\n+\t* cppucnid.tab, cppucnid.pl: New files.\n+\t* cppucnid.h: New generated file.\n+\t* cppcharset.c: Include cppucnid.h.  Lots of commentary added.\n+\t(iconv_open, iconv, iconv_close): Provide dummy definitions\n+\tif !HAVE_ICONV.\n+\t(SOURCE_CHARSET, struct strbuf, init_iconv_desc, cpp_init_iconv,\n+\t_cpp_destroy_iconv, convert_cset, width_to_mask, convert_ucn,\n+\temit_numeric_escape, convert_hex, convert_oct, convert_escape,\n+\tcpp_interpret_string, narrow_str_to_charconst,\n+\twide_str_to_charconst): New.\n+\t(ucn_valid_in_identifier): Use a binary search through the\n+\tucnranges table defined in cppucnid.h, not a long chain of if\n+\tstatements.\n+\t(_cpp_valid_ucn): Add a limit pointer.  Downgrade \"universal\n+\tcharacter names are only valid in C++ and C99\" to a warning.\n+\tIssue the \"meaning of \\[uU] is different in traditional C\"\n+\twarning here.  Take care not to let iconv see an invalid UCS\n+\tvalue if we get a malformed UCN.  Issue an error if we don't\n+\thave iconv.\n+\t(cpp_interpret_charconst): Moved here from cpplex.c.  Use\n+\tcpp_interpret_string to do the heavy lifting.\n+\n+\t* cppinit.c (cpp_create_reader): Initialize bytes_big_endian,\n+\tnarrow_charset, wide_charset fields of options structure.\n+\t(cpp_destroy): Call _cpp_destroy_iconv.\n+\t* cpplex.c (forms_identifier_p): Adjust call to _cpp_valid_ucn.\n+\t(maybe_read_ucn, hex_digit_value, cpp_parse_escape): Delete.\n+\t(cpp_interpret_charconst): Moved to cppcharset.c.\n+\t* cpplib.c (dequote_string): Delete.\n+\t(interpret_string_notranslate): New.\n+\t(do_line, do_linemarker): Use interpret_string_notranslate.\n+\n+\t* Makefile.in (cppcharset.o): Depend on cppucnid.h.\n+\n+\t* c-common.c (fname_string, combine_strings): Delete.\n+\t* c-common.h (fname_string, combine_strings): Delete prototypes.\n+\t* c-lex.c (ignore_escape_flag): Delete.\n+\t(cb_ident): Use cpp_interpret_string, not lex_string.\n+\t(get_nonpadding_token): New function.\n+\t(c_lex): Handle Objective-C @-prefixed identifiers and strings here.\n+\tAdjust calls to lex_string.  Don't write *value twice.\n+\t(lex_string): Now handles string constant concatenation.\n+\tMost of the work handed off to cpp_interpret_string.\n+\tCall fix_string_type here.\n+\t* c-parse.in (STRING_FUNC_NAME, VAR_FUNC_NAME): Replace with\n+\tFUNC_NAME, throughout.\n+\t(OBJC_STRING): New token type.\n+\t(primary:STRING): No need to call fix_string_type here.\n+\t(primary:objc_string): Make that OBJC_STRING.\n+\t(objc_string nonterminal): Delete.\n+\t(yylexname): Delete code to handle fake string constants.\n+\t(yylexstring): Delete entirely.\n+\t(_yylex): Handle CPP_AT_NAME and CPP_OBJC_STRING.  No need\n+\tto handle CPP_ATSIGN.\n+\n+\t* c.opt (-fexec-charset=, -fwide-exec-charset=): New options.\n+\t* c-opts.c (missing_arg, c_common_handle_option): Handle\n+\tOPT_fexec_charset_ and OPT_fwide_exec_charset_.\n+\t(c_common_init): Set cpp_opts->bytes_big_endian, not\n+\tcpp_opts->EBCDIC.  Call cpp_init_iconv.\n+\t(print_help): Document -fexec-charset= and -fexec-wide-charset=.\n+\t(TARGET_EBCDIC): Delete default definition.\n+\n+\t* objc/objc-act.c (build_objc_string_object): No need to\n+\thandle string constant concatenation.\n+\n 2003-07-04  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* doc/install.texi: Fix typos."}, {"sha": "7b475735f669e8440486b338b2b840564fdff400", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -2351,7 +2351,7 @@ libcpp.a: $(LIBCPP_OBJS)\n \t$(AR) $(AR_FLAGS) libcpp.a $(LIBCPP_OBJS)\n \t-$(RANLIB) libcpp.a\n \n-cppcharset.o: cppcharset.c $(LIBCPP_DEPS)\n+cppcharset.o: cppcharset.c $(LIBCPP_DEPS) cppucnid.h\n cpperror.o: cpperror.c $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(LIBCPP_DEPS)\n cpplex.o:   cpplex.c   $(LIBCPP_DEPS)"}, {"sha": "341018c0e5bd0f28d8bc043f4754a1752ac35144", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -1084,20 +1084,6 @@ fname_as_string (int pretty_p)\n   return name;\n }\n \n-/* Return the text name of the current function, formatted as\n-   required by the supplied RID value.  */\n-\n-const char *\n-fname_string (unsigned int rid)\n-{\n-  unsigned ix;\n-\n-  for (ix = 0; fname_vars[ix].decl; ix++)\n-    if (fname_vars[ix].rid == rid)\n-      break;\n-  return fname_as_string (fname_vars[ix].pretty);\n-}\n-\n /* Return the VAR_DECL for a const char array naming the current\n    function. If the VAR_DECL has not yet been created, create it\n    now. RID indicates how it should be formatted and IDENTIFIER_NODE\n@@ -1190,111 +1176,6 @@ fix_string_type (tree value)\n   TREE_STATIC (value) = 1;\n   return value;\n }\n-\n-/* Given a VARRAY of STRING_CST nodes, concatenate them into one\n-   STRING_CST.  */\n-\n-tree\n-combine_strings (varray_type strings)\n-{\n-  const int wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n-  const int nstrings = VARRAY_ACTIVE_SIZE (strings);\n-  tree value, t;\n-  int length = 1;\n-  int wide_length = 0;\n-  int wide_flag = 0;\n-  int i;\n-  char *p, *q;\n-\n-  /* Don't include the \\0 at the end of each substring.  Count wide\n-     strings and ordinary strings separately.  */\n-  for (i = 0; i < nstrings; ++i)\n-    {\n-      t = VARRAY_TREE (strings, i);\n-\n-      if (TREE_TYPE (t) == wchar_array_type_node)\n-\t{\n-\t  wide_length += TREE_STRING_LENGTH (t) - wchar_bytes;\n-\t  wide_flag = 1;\n-\t}\n-      else\n-\t{\n-\t  length += (TREE_STRING_LENGTH (t) - 1);\n-\t  if (C_ARTIFICIAL_STRING_P (t) && !in_system_header)\n-\t    warning (\"concatenation of string literals with __FUNCTION__ is deprecated\");\n-\t}\n-    }\n-\n-  /* If anything is wide, the non-wides will be converted,\n-     which makes them take more space.  */\n-  if (wide_flag)\n-    length = length * wchar_bytes + wide_length;\n-\n-  p = xmalloc (length);\n-\n-  /* Copy the individual strings into the new combined string.\n-     If the combined string is wide, convert the chars to ints\n-     for any individual strings that are not wide.  */\n-\n-  q = p;\n-  for (i = 0; i < nstrings; ++i)\n-    {\n-      int len, this_wide;\n-\n-      t = VARRAY_TREE (strings, i);\n-      this_wide = TREE_TYPE (t) == wchar_array_type_node;\n-      len = TREE_STRING_LENGTH (t) - (this_wide ? wchar_bytes : 1);\n-      if (this_wide == wide_flag)\n-\t{\n-\t  memcpy (q, TREE_STRING_POINTER (t), len);\n-\t  q += len;\n-\t}\n-      else\n-\t{\n-\t  const int nzeros = (TYPE_PRECISION (wchar_type_node)\n-\t\t\t      / BITS_PER_UNIT) - 1;\n-\t  int j, k;\n-\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    {\n-\t      for (k = 0; k < len; k++)\n-\t\t{\n-\t\t  for (j = 0; j < nzeros; j++)\n-\t\t    *q++ = 0;\n-\t\t  *q++ = TREE_STRING_POINTER (t)[k];\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      for (k = 0; k < len; k++)\n-\t\t{\n-\t\t  *q++ = TREE_STRING_POINTER (t)[k];\n-\t\t  for (j = 0; j < nzeros; j++)\n-\t\t    *q++ = 0;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* Nul terminate the string.  */\n-  if (wide_flag)\n-    {\n-      for (i = 0; i < wchar_bytes; i++)\n-\t*q++ = 0;\n-    }\n-  else\n-    *q = 0;\n-\n-  value = build_string (length, p);\n-  free (p);\n-\n-  if (wide_flag)\n-    TREE_TYPE (value) = wchar_array_type_node;\n-  else\n-    TREE_TYPE (value) = char_array_type_node;\n-\n-  return value;\n-}\n \f\n static int is_valid_printf_arglist (tree);\n static rtx c_expand_builtin (tree, rtx, enum machine_mode,"}, {"sha": "d1c3e5a0fff44cf9dcec0386f2e097f0059933ed", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -883,7 +883,6 @@ extern void start_fname_decls (void);\n extern void finish_fname_decls (void);\n extern const char *fname_as_string (int);\n extern tree fname_decl (unsigned, tree);\n-extern const char *fname_string (unsigned);\n \n extern void check_function_arguments (tree, tree);\n extern void check_function_arguments_recurse (void (*)\n@@ -922,7 +921,6 @@ extern void c_expand_end_cond (void);\n extern tree check_case_value (tree);\n extern tree fix_string_type (tree);\n struct varray_head_tag;\n-extern tree combine_strings (struct varray_head_tag *);\n extern void constant_expression_warning (tree);\n extern tree convert_and_check (tree, tree);\n extern void overflow_warning (tree);"}, {"sha": "f5733604a5a17ee2cca0472a3f09eed318942720", "filename": "gcc/c-lex.c", "status": "modified", "additions": 132, "deletions": 63, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -61,16 +61,13 @@ static splay_tree file_info_tree;\n int pending_lang_change; /* If we need to switch languages - C++ only */\n int c_header_level;\t /* depth in C headers - C++ only */\n \n-/* Nonzero tells yylex to ignore \\ in string constants.  */\n-static int ignore_escape_flag;\n-\n static tree interpret_integer (const cpp_token *, unsigned int);\n static tree interpret_float (const cpp_token *, unsigned int);\n static enum integer_type_kind\n   narrowest_unsigned_type (tree, unsigned int);\n static enum integer_type_kind\n   narrowest_signed_type (tree, unsigned int);\n-static tree lex_string (const cpp_string *);\n+static enum cpp_ttype lex_string (const cpp_token *, tree *, bool);\n static tree lex_charconst (const cpp_token *);\n static void update_header_times (const char *);\n static int dump_one_header (splay_tree_node, void *);\n@@ -184,8 +181,12 @@ cb_ident (cpp_reader *pfile ATTRIBUTE_UNUSED,\n   if (! flag_no_ident)\n     {\n       /* Convert escapes in the string.  */\n-      tree value ATTRIBUTE_UNUSED = lex_string (str);\n-      ASM_OUTPUT_IDENT (asm_out_file, TREE_STRING_POINTER (value));\n+      cpp_string cstr = { 0, 0 };\n+      if (cpp_interpret_string (pfile, str, 1, &cstr, false))\n+\t{\n+\t  ASM_OUTPUT_IDENT (asm_out_file, cstr.text);\n+\t  free ((void *)cstr.text);\n+\t}\n     }\n #endif\n }\n@@ -296,12 +297,10 @@ cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, unsigned int line,\n \t\t\t (const char *) NODE_NAME (node));\n }\n \f\n-int\n-c_lex (tree *value)\n+static inline const cpp_token *\n+get_nonpadding_token (void)\n {\n   const cpp_token *tok;\n-\n- retry:\n   timevar_push (TV_CPP);\n   do\n     tok = cpp_get_token (parse_in);\n@@ -310,10 +309,22 @@ c_lex (tree *value)\n \n   /* The C++ front end does horrible things with the current line\n      number.  To ensure an accurate line number, we must reset it\n-     every time we return a token.  */\n+     every time we advance a token.  */\n   input_line = src_lineno;\n \n-  *value = NULL_TREE;\n+  return tok;\n+}  \n+\n+int\n+c_lex (tree *value)\n+{\n+  const cpp_token *tok;\n+  location_t atloc;\n+\n+ retry:\n+  tok = get_nonpadding_token ();\n+\n+ retry_after_at:\n   switch (tok->type)\n     {\n     case CPP_NAME:\n@@ -345,6 +356,37 @@ c_lex (tree *value)\n       }\n       break;\n \n+    case CPP_ATSIGN:\n+      /* An @ may give the next token special significance in Objective-C.  */\n+      atloc = input_location;\n+      tok = get_nonpadding_token ();\n+      if (c_dialect_objc ())\n+\t{\n+\t  tree val;\n+\t  switch (tok->type)\n+\t    {\n+\t    case CPP_NAME:\n+\t      val = HT_IDENT_TO_GCC_IDENT (HT_NODE (tok->val.node));\n+\t      if (C_IS_RESERVED_WORD (val)\n+\t\t  && OBJC_IS_AT_KEYWORD (C_RID_CODE (val)))\n+\t\t{\n+\t\t  *value = val;\n+\t\t  return CPP_AT_NAME;\n+\t\t}\n+\t      break;\n+\n+\t    case CPP_STRING:\n+\t    case CPP_WSTRING:\n+\t      return lex_string (tok, value, true);\n+\n+\t    default: break;\n+\t    }\n+\t}\n+\n+      /* ... or not.  */\n+      error (\"%Hstray '@' in program\", &atloc);\n+      goto retry_after_at;\n+\n     case CPP_OTHER:\n       {\n \tcppchar_t c = tok->val.str.text[0];\n@@ -365,7 +407,7 @@ c_lex (tree *value)\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n-      *value = lex_string (&tok->val.str);\n+      return lex_string (tok, value, false);\n       break;\n \n       /* These tokens should not be visible outside cpplib.  */\n@@ -374,7 +416,9 @@ c_lex (tree *value)\n     case CPP_MACRO_ARG:\n       abort ();\n \n-    default: break;\n+    default:\n+      *value = NULL_TREE;\n+      break;\n     }\n \n   return tok->type;\n@@ -571,75 +615,100 @@ interpret_float (const cpp_token *token, unsigned int flags)\n   return value;\n }\n \n-static tree\n-lex_string (const cpp_string *str)\n+/* Convert a series of STRING and/or WSTRING tokens into a tree,\n+   performing string constant concatenation.  TOK is the first of\n+   these.  VALP is the location to write the string into.  OBJC_STRING\n+   indicates whether an '@' token preceded the incoming token.\n+   Returns the CPP token type of the result (CPP_STRING, CPP_WSTRING,\n+   or CPP_OBJC_STRING).\n+\n+   This is unfortunately more work than it should be.  If any of the\n+   strings in the series has an L prefix, the result is a wide string\n+   (6.4.5p4).  Whether or not the result is a wide string affects the\n+   meaning of octal and hexadecimal escapes (6.4.4.4p6,9).  But escape\n+   sequences do not continue across the boundary between two strings in\n+   a series (6.4.5p7), so we must not lose the boundaries.  Therefore\n+   cpp_interpret_string takes a vector of cpp_string structures, which\n+   we must arrange to provide.  */\n+\n+static enum cpp_ttype\n+lex_string (const cpp_token *tok, tree *valp, bool objc_string)\n {\n-  bool wide;\n   tree value;\n-  char *buf, *q;\n-  cppchar_t c;\n-  const unsigned char *p, *limit;\n+  bool wide = false;\n+  size_t count = 1;\n+  struct obstack str_ob;\n+  cpp_string istr;\n \n-  wide = str->text[0] == 'L';\n-  p = str->text + 1 + wide;\n-  limit = str->text + str->len - 1;\n-  q = buf = alloca ((str->len + 1) * (wide ? WCHAR_BYTES : 1));\n+  /* Try to avoid the overhead of creating and destroying an obstack\n+     for the common case of just one string.  */\n+  cpp_string str = tok->val.str;\n+  cpp_string *strs = &str;\n \n-  while (p < limit)\n-    {\n-      c = *p++;\n+  if (tok->type == CPP_WSTRING)\n+    wide = true;\n \n-      if (c == '\\\\' && !ignore_escape_flag)\n-\tc = cpp_parse_escape (parse_in, &p, limit, wide);\n+  tok = get_nonpadding_token ();\n+  if (c_dialect_objc () && tok->type == CPP_ATSIGN)\n+    {\n+      objc_string = true;\n+      tok = get_nonpadding_token ();\n+    }\n+  if (tok->type == CPP_STRING || tok->type == CPP_WSTRING)\n+    {\n+      gcc_obstack_init (&str_ob);\n+      obstack_grow (&str_ob, &str, sizeof (cpp_string));\n \n-      /* Add this single character into the buffer either as a wchar_t,\n-\t a multibyte sequence, or as a single byte.  */\n-      if (wide)\n+      do\n \t{\n-\t  unsigned charwidth = TYPE_PRECISION (char_type_node);\n-\t  unsigned bytemask = (1 << charwidth) - 1;\n-\t  int byte;\n-\n-\t  for (byte = 0; byte < WCHAR_BYTES; ++byte)\n+\t  count++;\n+\t  if (tok->type == CPP_WSTRING)\n+\t    wide = true;\n+\t  obstack_grow (&str_ob, &tok->val.str, sizeof (cpp_string));\n+\t  \n+\t  tok = get_nonpadding_token ();\n+\t  if (c_dialect_objc () && tok->type == CPP_ATSIGN)\n \t    {\n-\t      int n;\n-\t      if (byte >= (int) sizeof (c))\n-\t\tn = 0;\n-\t      else\n-\t\tn = (c >> (byte * charwidth)) & bytemask;\n-\t      if (BYTES_BIG_ENDIAN)\n-\t\tq[WCHAR_BYTES - byte - 1] = n;\n-\t      else\n-\t\tq[byte] = n;\n+\t      objc_string = true;\n+\t      tok = get_nonpadding_token ();\n \t    }\n-\t  q += WCHAR_BYTES;\n-\t}\n-      else\n-\t{\n-\t  *q++ = c;\n \t}\n+      while (tok->type == CPP_STRING || tok->type == CPP_WSTRING);\n+      strs = obstack_finish (&str_ob);\n     }\n \n-  /* Terminate the string value, either with a single byte zero\n-     or with a wide zero.  */\n+  /* We have read one more token than we want.  */\n+  _cpp_backup_tokens (parse_in, 1);\n+\n+  if (count > 1 && !objc_string && warn_traditional && !in_system_header)\n+    warning (\"traditional C rejects string constant concatenation\");\n \n-  if (wide)\n+  if (cpp_interpret_string (parse_in, strs, count, &istr, wide))\n     {\n-      memset (q, 0, WCHAR_BYTES);\n-      q += WCHAR_BYTES;\n+      value = build_string (istr.len, (char *)istr.text);\n+      free ((void *)istr.text);\n     }\n   else\n     {\n-      *q++ = '\\0';\n+      /* Callers cannot generally handle error_mark_node in this context,\n+\t so return the empty string instead.  cpp_interpret_string has\n+\t issued an error.  */\n+      if (wide)\n+\tvalue = build_string (TYPE_PRECISION (wchar_type_node)\n+\t\t\t      / TYPE_PRECISION (char_type_node),\n+\t\t\t      \"\\0\\0\\0\");  /* widest supported wchar_t\n+\t\t\t\t\t     is 32 bits */\n+      else\n+\tvalue = build_string (1, \"\");\n     }\n \n-  value = build_string (q - buf, buf);\n+  TREE_TYPE (value) = wide ? wchar_array_type_node : char_array_type_node;\n+  *valp = fix_string_type (value);\n \n-  if (wide)\n-    TREE_TYPE (value) = wchar_array_type_node;\n-  else\n-    TREE_TYPE (value) = char_array_type_node;\n-  return value;\n+  if (strs != &str)\n+    obstack_free (&str_ob, 0);\n+\n+  return objc_string ? CPP_OBJC_STRING : wide ? CPP_WSTRING : CPP_STRING;\n }\n \n /* Converts a (possibly wide) character constant token into a tree.  */"}, {"sha": "52a7536140e398dacd822a51854a1821c0ad3041", "filename": "gcc/c-opts.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -46,10 +46,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n # define TARGET_SYSTEM_ROOT NULL\n #endif\n \n-#ifndef TARGET_EBCDIC\n-# define TARGET_EBCDIC 0\n-#endif\n-\n static int saved_lineno;\n \n /* CPP's options.  */\n@@ -143,6 +139,8 @@ missing_arg (enum opt_code code)\n     case OPT_fdump_:\n     case OPT_fname_mangling_version_:\n     case OPT_ftabstop_:\n+    case OPT_fexec_charset_:\n+    case OPT_fwide_exec_charset_:\n     case OPT_ftemplate_depth_:\n     case OPT_iprefix:\n     case OPT_iwithprefix:\n@@ -892,6 +890,14 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n \tcpp_opts->tabstop = value;\n       break;\n \n+    case OPT_fexec_charset_:\n+      cpp_opts->narrow_charset = arg;\n+      break;\n+\n+    case OPT_fwide_exec_charset_:\n+      cpp_opts->wide_charset = arg;\n+      break;\n+\n     case OPT_ftemplate_depth_:\n       max_tinst_depth = value;\n       break;\n@@ -1145,7 +1151,11 @@ c_common_init (void)\n   cpp_opts->int_precision = TYPE_PRECISION (integer_type_node);\n   cpp_opts->wchar_precision = TYPE_PRECISION (wchar_type_node);\n   cpp_opts->unsigned_wchar = TREE_UNSIGNED (wchar_type_node);\n-  cpp_opts->EBCDIC = TARGET_EBCDIC;\n+  cpp_opts->bytes_big_endian = BYTES_BIG_ENDIAN;\n+\n+  /* This can't happen until after wchar_precision and bytes_big_endian\n+     are known.  */\n+  cpp_init_iconv (parse_in);\n \n   if (flag_preprocess_only)\n     {\n@@ -1571,6 +1581,12 @@ Switches:\\n\\\n   fputs (_(\"\\\n   -f[no-]preprocessed       Treat the input file as already preprocessed\\n\\\n   -ftabstop=<number>        Distance between tab stops for column reporting\\n\\\n+  -ftarget-charset=<c>      Convert all strings and character constants\\n\\\n+                            to character set <c>\\n\\\n+  -ftarget-wide-charset=<c> Convert all wide strings and character constants\\n\\\n+                            to character set <c>\\n\\\n+\"), stdout);\n+  fputs (_(\"\\\n   -isysroot <dir>           Set <dir> to be the system root directory\\n\\\n   -P                        Do not generate #line directives\\n\\\n   -remap                    Remap file names when including files\\n\\"}, {"sha": "b62f2ff7294a0ba27d9f9e71931c5e2fee0856ce", "filename": "gcc/c-parse.in", "status": "modified", "additions": 19, "deletions": 119, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -151,9 +151,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n %token ATTRIBUTE EXTENSION LABEL\n %token REALPART IMAGPART VA_ARG CHOOSE_EXPR TYPES_COMPATIBLE_P\n %token PTR_VALUE PTR_BASE PTR_EXTENT\n-\n-/* function name can be a string const or a var decl. */\n-%token STRING_FUNC_NAME VAR_FUNC_NAME\n+%token FUNC_NAME\n \n /* Add precedence rules to solve dangling else s/r conflict */\n %nonassoc IF\n@@ -183,6 +181,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    Objective C, so that the token codes are the same in both.  */\n %token INTERFACE IMPLEMENTATION END SELECTOR DEFS ENCODE\n %token CLASSNAME PUBLIC PRIVATE PROTECTED PROTOCOL OBJECTNAME CLASS ALIAS\n+%token OBJC_STRING\n \n %type <code> unop\n %type <ttype> ENUM STRUCT UNION IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n@@ -249,9 +248,9 @@ ifobjc\n %type <ttype> keywordexpr keywordarglist keywordarg\n %type <ttype> myparms myparm optparmlist reservedwords objcselectorexpr\n %type <ttype> selectorarg keywordnamelist keywordname objcencodeexpr\n-%type <ttype> objc_string non_empty_protocolrefs protocolrefs identifier_list objcprotocolexpr\n+%type <ttype> non_empty_protocolrefs protocolrefs identifier_list objcprotocolexpr\n \n-%type <ttype> CLASSNAME OBJECTNAME\n+%type <ttype> CLASSNAME OBJECTNAME OBJC_STRING\n end ifobjc\n \f\n %{\n@@ -340,7 +339,6 @@ static bool parsing_iso_function_signature;\n static void yyprint\t  PARAMS ((FILE *, int, YYSTYPE));\n static void yyerror\t  PARAMS ((const char *));\n static int yylexname\t  PARAMS ((void));\n-static int yylexstring\t  PARAMS ((void));\n static inline int _yylex  PARAMS ((void));\n static int  yylex\t  PARAMS ((void));\n static void init_reswords PARAMS ((void));\n@@ -657,8 +655,7 @@ primary:\n \t\t}\n \t| CONSTANT\n \t| STRING\n-\t\t{ $$ = fix_string_type ($$); }\n-\t| VAR_FUNC_NAME\n+\t| FUNC_NAME\n \t\t{ $$ = fname_decl (C_RID_CODE ($$), $$); }\n \t| '(' typename ')' '{'\n \t\t{ start_init (NULL_TREE, NULL, 0);\n@@ -763,22 +760,11 @@ ifobjc\n \t\t{ $$ = build_protocol_expr ($1); }\n \t| objcencodeexpr\n \t\t{ $$ = build_encode_expr ($1); }\n-\t| objc_string\n+\t| OBJC_STRING\n \t\t{ $$ = build_objc_string_object ($1); }\n end ifobjc\n \t;\n \n-ifobjc\n-/* Produces an STRING_CST with perhaps more STRING_CSTs chained\n-   onto it, which is to be read as an ObjC string object.  */\n-objc_string:\n-\t  '@' STRING\n-\t\t{ $$ = $2; }\n-\t| objc_string '@' STRING\n-\t\t{ $$ = chainon ($1, $3); }\n-\t;\n-end ifobjc\n-\n old_style_parm_decls:\n \told_style_parm_decls_1\n \t{\n@@ -3494,9 +3480,9 @@ static const short rid_to_yy[RID_MAX] =\n   /* RID_CHOOSE_EXPR */\t\t\tCHOOSE_EXPR,\n   /* RID_TYPES_COMPATIBLE_P */\t\tTYPES_COMPATIBLE_P,\n \n-  /* RID_FUNCTION_NAME */\t\tSTRING_FUNC_NAME,\n-  /* RID_PRETTY_FUNCTION_NAME */\tSTRING_FUNC_NAME,\n-  /* RID_C99_FUNCTION_NAME */\t\tVAR_FUNC_NAME,\n+  /* RID_FUNCTION_NAME */\t\tFUNC_NAME,\n+  /* RID_PRETTY_FUNCTION_NAME */\tFUNC_NAME,\n+  /* RID_C99_FUNCTION_NAME */\t\tFUNC_NAME,\n \n   /* C++ */\n   /* RID_BOOL */\tTYPESPEC,\n@@ -3627,22 +3613,9 @@ ifobjc\n \t  && (!OBJC_IS_PQ_KEYWORD (rid_code) || objc_pq_context))\n end ifobjc\n       {\n-\tint yycode = rid_to_yy[(int) rid_code];\n-\tif (yycode == STRING_FUNC_NAME)\n-\t  {\n-\t    /* __FUNCTION__ and __PRETTY_FUNCTION__ get converted\n-\t       to string constants.  */\n-\t    const char *name = fname_string (rid_code);\n-\n-\t    yylval.ttype = build_string (strlen (name) + 1, name);\n-\t    C_ARTIFICIAL_STRING_P (yylval.ttype) = 1;\n-\t    last_token = CPP_STRING;  /* so yyerror won't choke */\n-\t    return STRING;\n-\t  }\n-\n \t/* Return the canonical spelling for this keyword.  */\n \tyylval.ttype = ridpointers[(int) rid_code];\n-\treturn yycode;\n+\treturn rid_to_yy[(int) rid_code];\n       }\n     }\n \n@@ -3671,57 +3644,6 @@ end ifobjc\n   return IDENTIFIER;\n }\n \n-/* Concatenate strings before returning them to the parser.  This isn't quite\n-   as good as having it done in the lexer, but it's better than nothing.  */\n-\n-static int\n-yylexstring ()\n-{\n-  enum cpp_ttype next_type;\n-  tree orig = yylval.ttype;\n-\n-  next_type = c_lex (&yylval.ttype);\n-  if (next_type == CPP_STRING\n-      || next_type == CPP_WSTRING\n-      || (next_type == CPP_NAME && yylexname () == STRING))\n-    {\n-      varray_type strings;\n-\n-ifc\n-      static location_t last_location;\n-      if (warn_traditional && !in_system_header\n-\t  && (input_location.line != last_location.line\n-\t      || !last_location.file ||\n-\t      strcmp (last_location.file, input_location.file)))\n-\t{\n-\t  warning (\"traditional C rejects string concatenation\");\n-\t  last_location = input_location;\n-\t}\n-end ifc\n-\n-      VARRAY_TREE_INIT (strings, 32, \"strings\");\n-      VARRAY_PUSH_TREE (strings, orig);\n-\n-      do\n-\t{\n-\t  VARRAY_PUSH_TREE (strings, yylval.ttype);\n-\t  next_type = c_lex (&yylval.ttype);\n-\t}\n-      while (next_type == CPP_STRING\n-\t     || next_type == CPP_WSTRING\n-\t     || (next_type == CPP_NAME && yylexname () == STRING));\n-\n-      yylval.ttype = combine_strings (strings);\n-    }\n-  else\n-    yylval.ttype = orig;\n-\n-  /* We will have always read one token too many.  */\n-  _cpp_backup_tokens (parse_in, 1);\n-\n-  return STRING;\n-}\n-\n static inline int\n _yylex ()\n {\n@@ -3787,13 +3709,11 @@ _yylex ()\n       return 0;\n \n     case CPP_NAME:\n-      {\n-\tint ret = yylexname ();\n-\tif (ret == STRING)\n-\t  return yylexstring ();\n-\telse\n-\t  return ret;\n-      }\n+      return yylexname ();\n+\n+    case CPP_AT_NAME:\n+      /* This only happens in Objective-C; it must be a keyword.  */\n+      return rid_to_yy [(int) C_RID_CODE (yylval.ttype)];\n \n     case CPP_NUMBER:\n     case CPP_CHAR:\n@@ -3802,30 +3722,10 @@ _yylex ()\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n-      return yylexstring ();\n-\n-      /* This token is Objective-C specific.  It gives the next token\n-\t special significance.  */\n-    case CPP_ATSIGN:\n-ifobjc\n-      {\n-\ttree after_at;\n-\tenum cpp_ttype after_at_type;\n-\n-\tafter_at_type = c_lex (&after_at);\n-\n-\tif (after_at_type == CPP_NAME\n-\t    && C_IS_RESERVED_WORD (after_at)\n-\t    && OBJC_IS_AT_KEYWORD (C_RID_CODE (after_at)))\n-\t  {\n-\t    yylval.ttype = after_at;\n-\t    last_token = after_at_type;\n-\t    return rid_to_yy [(int) C_RID_CODE (after_at)];\n-\t  }\n-\t_cpp_backup_tokens (parse_in, 1);\n-\treturn '@';\n-      }\n-end ifobjc\n+      return STRING;\n+      \n+    case CPP_OBJC_STRING:\n+      return OBJC_STRING;\n \n       /* These tokens are C++ specific (and will not be generated\n          in C mode, but let's be cautious).  */"}, {"sha": "e8f61df9c9a799585832cdba74e34f780abaf899", "filename": "gcc/c.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -368,6 +368,9 @@ C++ ObjC++\n fenum-int-equiv\n C++ ObjC++\n \n+fexec-charset=\n+C ObjC C++ ObjC++ Joined RejectNegative\n+\n fexternal-templates\n C++ ObjC++\n \n@@ -509,6 +512,9 @@ C++ ObjC++\n fweak\n C++ ObjC++\n \n+fwide-exec-charset=\n+C ObjC C++ ObjC++ Joined RejectNegative\n+\n fxref\n C++ ObjC++\n "}, {"sha": "8776631ee270b41528c4340e8e67bd5a5215886a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -1,3 +1,8 @@\n+2003-07-04  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* parser.c (cp_lexer_read_token): No need to handle string\n+\tconstant concatenation.\n+\n 2003-07-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cp-tree.h (GCC_DIAG_STYLE, ATTRIBUTE_GCC_CXXDIAG): Define.\n@@ -51,7 +56,7 @@\n \t(convert_for_initialization): Likewise.\n \t* typeck2.c (build_x_arrow): Likewise.\n \t(build_m_component_ref): Simplify.\n-\t\n+\n \t* call.c (build_scoped_method_call): Use convert_to_void.\n \t(build_method_call): Likewise.\n \t* class.c (check_field_decls): Remove dead code.\n@@ -63,7 +68,7 @@\n \t(build_vec_delete_1): Use convert_to_void.\n \t* mangle.c (write_type): Avoid relying on POINTER_TYPE over OFFSET_TYPE\n \tas pointer-to-member representation.\n-\t\n+\n 2003-07-03  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/9162\n@@ -145,10 +150,10 @@ Wed Jul  2 00:36:48 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \tis a class type.\n \n 2003-07-01  Giovanni Bajo  <giovannibajo@libero.it>\n-\t\n-        PR c++/8046\n-        * error.c (dump_decl): Handle BIT_NOT_EXPR as\n-        pseudo destructor calls.\n+\n+\tPR c++/8046\n+\t* error.c (dump_decl): Handle BIT_NOT_EXPR as\n+\tpseudo destructor calls.\n \n 2003-07-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n@@ -176,28 +181,28 @@ Wed Jul  2 00:36:48 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-06-30  Giovanni Bajo  <giovannibajo@libero.it>\n \n-        PR c++/4933\n-        * error.c (dump_expr): Support correctly the COMPOUND_EXPR\n-        tree generated within a template. Use dump_expr to dump an\n-        expression sizeof.\n+\tPR c++/4933\n+\t* error.c (dump_expr): Support correctly the COMPOUND_EXPR\n+\ttree generated within a template. Use dump_expr to dump an\n+\texpression sizeof.\n \n 2003-06-30  Giovanni Bajo  <giovannibajo@libero.it>\n \n-        * mangle.c (write_expression): Exit gracefully when trying to\n-        mangle a CALL_EXPR.\n+\t* mangle.c (write_expression): Exit gracefully when trying to\n+\tmangle a CALL_EXPR.\n \n 2003-06-30  Giovanni Bajo  <giovannibajo@libero.it>\n \n-        PR c++/10750\n-        * parser.c (cp_parser_primary_expression): A VAR_DECL with a\n-        (value- or type-) dependent expression as DECL_INITIAL is a\n-        valid constant-expression (at parser time).\n+\tPR c++/10750\n+\t* parser.c (cp_parser_primary_expression): A VAR_DECL with a\n+\t(value- or type-) dependent expression as DECL_INITIAL is a\n+\tvalid constant-expression (at parser time).\n \n 2003-06-30  Giovanni Bajo <giovannibajo@libero.it>\n \n-        PR c++/11106\n-        * error.c (dump_decl): Call dump_decl to dump the DECL_NAME for a\n-        USING_DECL, instead of print_tree_identifier.\n+\tPR c++/11106\n+\t* error.c (dump_decl): Call dump_decl to dump the DECL_NAME for a\n+\tUSING_DECL, instead of print_tree_identifier.\n \n 2003-06-29  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n "}, {"sha": "1f484663e2c152f5caa1928bfa1cabb8217520ca", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 15, "deletions": 59, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -479,66 +479,22 @@ cp_lexer_read_token (cp_lexer* lexer)\n   /* Increment LAST_TOKEN.  */\n   lexer->last_token = cp_lexer_next_token (lexer, token);\n \n-  /* The preprocessor does not yet do translation phase six, i.e., the\n-     combination of adjacent string literals.  Therefore, we do it\n-     here.  */\n-  if (token->type == CPP_STRING || token->type == CPP_WSTRING)\n-    {\n-      ptrdiff_t delta;\n-      int i;\n-\n-      /* When we grow the buffer, we may invalidate TOKEN.  So, save\n-\t the distance from the beginning of the BUFFER so that we can\n-\t recaulate it.  */\n-      delta = cp_lexer_token_difference (lexer, lexer->buffer, token);\n-      /* Make sure there is room in the buffer for another token.  */\n-      cp_lexer_maybe_grow_buffer (lexer);\n-      /* Restore TOKEN.  */\n-      token = lexer->buffer;\n-      for (i = 0; i < delta; ++i)\n-\ttoken = cp_lexer_next_token (lexer, token);\n-\n-      VARRAY_PUSH_TREE (lexer->string_tokens, token->value);\n-      while (true)\n-\t{\n-\t  /* Read the token after TOKEN.  */\n-\t  cp_lexer_get_preprocessor_token (lexer, lexer->last_token);\n-\t  /* See whether it's another string constant.  */\n-\t  if (lexer->last_token->type != token->type)\n-\t    {\n-\t      /* If not, then it will be the next real token.  */\n-\t      lexer->last_token = cp_lexer_next_token (lexer, \n-\t\t\t\t\t\t       lexer->last_token);\n-\t      break;\n-\t    }\n-\n-\t  /* Chain the strings together.  */\n-\t  VARRAY_PUSH_TREE (lexer->string_tokens, \n-\t\t\t    lexer->last_token->value);\n-\t}\n-\n-      /* Create a single STRING_CST.  Curiously we have to call\n-\t combine_strings even if there is only a single string in\n-\t order to get the type set correctly.  */\n-      token->value = combine_strings (lexer->string_tokens);\n-      VARRAY_CLEAR (lexer->string_tokens);\n-      token->value = fix_string_type (token->value);\n-      /* Strings should have type `const char []'.  Right now, we will\n-\t have an ARRAY_TYPE that is constant rather than an array of\n-\t constant elements.  */\n-      if (flag_const_strings)\n-\t{\n-\t  tree type;\n+  /* Strings should have type `const char []'.  Right now, we will\n+     have an ARRAY_TYPE that is constant rather than an array of\n+     constant elements.\n+     FIXME: Make fix_string_type get this right in the first place.  */\n+  if ((token->type == CPP_STRING || token->type == CPP_WSTRING)\n+      && flag_const_strings)\n+    {\n+      tree type;\n \n-\t  /* Get the current type.  It will be an ARRAY_TYPE.  */\n-\t  type = TREE_TYPE (token->value);\n-\t  /* Use build_cplus_array_type to rebuild the array, thereby\n-\t     getting the right type.  */\n-\t  type = build_cplus_array_type (TREE_TYPE (type),\n-\t\t\t\t\t TYPE_DOMAIN (type));\n-\t  /* Reset the type of the token.  */\n-\t  TREE_TYPE (token->value) = type;\n-\t}\n+      /* Get the current type.  It will be an ARRAY_TYPE.  */\n+      type = TREE_TYPE (token->value);\n+      /* Use build_cplus_array_type to rebuild the array, thereby\n+\t getting the right type.  */\n+      type = build_cplus_array_type (TREE_TYPE (type), TYPE_DOMAIN (type));\n+      /* Reset the type of the token.  */\n+      TREE_TYPE (token->value) = type;\n     }\n \n   return token;"}, {"sha": "0ba7e930ab0ab8f584dfd7abb01f9c7296d8db51", "filename": "gcc/cppcharset.c", "status": "modified", "additions": 771, "deletions": 467, "changes": 1238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcppcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcppcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppcharset.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -24,8 +24,278 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"tm.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n+#include \"cppucnid.h\"\n+\n+/* Character set handling for C-family languages.\n+\n+   Terminological note: In what follows, \"charset\" or \"character set\"\n+   will be taken to mean both an abstract set of characters and an\n+   encoding for that set.\n+\n+   The C99 standard discusses two character sets: source and execution.\n+   The source character set is used for internal processing in translation\n+   phases 1 through 4; the execution character set is used thereafter.\n+   Both are required by 5.2.1.2p1 to be multibyte encodings, not wide\n+   character encodings (see 3.7.2, 3.7.3 for the standardese meanings\n+   of these terms).  Furthermore, the \"basic character set\" (listed in\n+   5.2.1p3) is to be encoded in each with values one byte wide, and is\n+   to appear in the initial shift state.\n+\n+   It is not explicitly mentioned, but there is also a \"wide execution\n+   character set\" used to encode wide character constants and wide\n+   string literals; this is supposed to be the result of applying the\n+   standard library function mbstowcs() to an equivalent narrow string\n+   (6.4.5p5).  However, the behavior of hexadecimal and octal\n+   \\-escapes is at odds with this; they are supposed to be translated\n+   directly to wchar_t values (6.4.4.4p5,6).\n+\n+   The source character set is not necessarily the character set used\n+   to encode physical source files on disk; translation phase 1 converts\n+   from whatever that encoding is to the source character set.\n+\n+   The presence of universal character names in C99 (6.4.3 et seq.)\n+   forces the source character set to be isomorphic to ISO 10646,\n+   that is, Unicode.  There is no such constraint on the execution\n+   character set; note also that the conversion from source to\n+   execution character set does not occur for identifiers (5.1.1.2p1#5).\n+\n+   For convenience of implementation, the source character set's\n+   encoding of the basic character set should be identical to the\n+   execution character set OF THE HOST SYSTEM's encoding of the basic\n+   character set, and it should not be a state-dependent encoding.\n+\n+   cpplib uses UTF-8 or UTF-EBCDIC for the source character set,\n+   depending on whether the host is based on ASCII or EBCDIC (see\n+   respectively Unicode section 2.3/ISO10646 Amendment 2, and Unicode\n+   Technical Report #16).  It relies on the system library's iconv()\n+   primitive to do charset conversion (specified in SUSv2).  If this\n+   primitive is not present, the source and execution character sets\n+   must be identical and are limited to the basic ASCII or EBCDIC\n+   range, and wide characters are implemented by padding narrow\n+   characters to the size of wchar_t.  */\n+\n+#if !HAVE_ICONV\n+/* Make certain that the uses of iconv(), iconv_open(), iconv_close()\n+   below, which are guarded only by if statements with compile-time\n+   constant conditions, do not cause link errors.  */\n+#define iconv_open(x, y) (errno = EINVAL, (iconv_t)-1)\n+#define iconv(a,b,c,d,e) (errno = EINVAL, (iconv_t)-1)\n+#define iconv_close(x)   0\n+#endif\n+\n+#if HOST_CHARSET == HOST_CHARSET_ASCII\n+#define SOURCE_CHARSET \"UTF-8\"\n+#elif HOST_CHARSET == HOST_CHARSET_EBCDIC\n+#define SOURCE_CHARSET \"UTF-EBCDIC\"\n+#else\n+#error \"Unrecognized basic host character set\"\n+#endif\n+\n+/* This structure is used for a resizable string buffer, mostly by\n+   convert_cset and cpp_interpret_string.  */\n+struct strbuf\n+{\n+  uchar *text;\n+  size_t asize;\n+  size_t len;\n+};\n+\n+/* This is enough to hold any string that fits on a single 80-column\n+   line, even if iconv quadruples its size (e.g. conversion from\n+   ASCII to UCS-4) rounded up to a power of two.  */\n+#define OUTBUF_BLOCK_SIZE 256\n+\n+/* Subroutine of cpp_init_iconv: initialize and return an iconv\n+   descriptor for conversion from FROM to TO.  If iconv_open() fails,\n+   issue an error and return (iconv_t) -1.  Silently return\n+   (iconv_t) -1 if FROM and TO are identical.  */\n+static iconv_t\n+init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n+{\n+  iconv_t dsc;\n+\n+  if (!strcmp (to, from))\n+    return (iconv_t) -1;\n+\n+  dsc = iconv_open (to, from);\n+  if (dsc == (iconv_t) -1)\n+    {\n+      if (errno == EINVAL)\n+\tcpp_error (pfile, DL_ERROR, /* XXX should be DL_SORRY */\n+\t\t   \"conversion from %s to %s not supported by iconv\",\n+\t\t   from, to);\n+      else\n+\tcpp_errno (pfile, DL_ERROR, \"iconv_open\");\n+    }\n+  return dsc;\n+}\n+\n+/* If charset conversion is requested, initialize iconv(3) descriptors\n+   for conversion from the source character set to the execution\n+   character sets.  If iconv is not present in the C library, and\n+   conversion is requested, issue an error.  */\n+\n+void\n+cpp_init_iconv (cpp_reader *pfile)\n+{\n+  const char *ncset = CPP_OPTION (pfile, narrow_charset);\n+  const char *wcset = CPP_OPTION (pfile, wide_charset);\n+  const char *default_wcset;\n+\n+  bool be = CPP_OPTION (pfile, bytes_big_endian);\n+\n+  if (CPP_OPTION (pfile, wchar_precision) >= 32)\n+    default_wcset = be ? \"UCS-4BE\" : \"UCS-4LE\";\n+  else if (CPP_OPTION (pfile, wchar_precision) >= 16)\n+    default_wcset = be ? \"UCS-2BE\" : \"UCS-2LE\";\n+  else\n+    /* This effectively means that wide strings are not supported,\n+       so don't do any conversion at all.  */\n+   default_wcset = SOURCE_CHARSET;\n+\n+  if (!HAVE_ICONV)\n+    {\n+      if (ncset && strcmp (ncset, SOURCE_CHARSET))\n+\tcpp_error (pfile, DL_ERROR,  /* XXX should be DL_SORRY */\n+\t\t   \"no iconv implementation, cannot convert to %s\", ncset);\n+\n+      if (wcset && strcmp (wcset, default_wcset))\n+\tcpp_error (pfile, DL_ERROR,  /* XXX should be DL_SORRY */\n+\t\t   \"no iconv implementation, cannot convert to %s\", wcset);\n+    }\n+  else\n+    {\n+      if (!ncset)\n+\tncset = SOURCE_CHARSET;\n+      if (!wcset)\n+\twcset = default_wcset;\n+\n+      pfile->narrow_cset_desc = init_iconv_desc (pfile, ncset, SOURCE_CHARSET);\n+      pfile->wide_cset_desc = init_iconv_desc (pfile, wcset, SOURCE_CHARSET);\n+    }\n+}\n+\n+void\n+_cpp_destroy_iconv (cpp_reader *pfile)\n+{\n+  if (HAVE_ICONV)\n+    {\n+      if (pfile->narrow_cset_desc != (iconv_t) -1)\n+\ticonv_close (pfile->narrow_cset_desc);\n+      if (pfile->wide_cset_desc != (iconv_t) -1)\n+\ticonv_close (pfile->wide_cset_desc);\n+    }\n+}\n+\n+/* iconv(3) utility wrapper.  Convert the string FROM, of length FLEN,\n+   according to the iconv descriptor CD.  The result is appended to\n+   the string buffer TO.  If DESC is (iconv_t)-1 or iconv is not\n+   available, the string is simply copied into TO.\n+\n+   Returns true on success, false on error.  */\n+\n+static bool\n+convert_cset (iconv_t cd, const uchar *from, size_t flen, struct strbuf *to)\n+{\n+  if (!HAVE_ICONV || cd == (iconv_t)-1)\n+    {\n+      if (to->len + flen > to->asize)\n+\t{\n+\t  to->asize = to->len + flen;\n+\t  to->text = xrealloc (to->text, to->asize);\n+\t}\n+      memcpy (to->text + to->len, from, flen);\n+      to->len += flen;\n+      return true;\n+    }\n+  else\n+    {\n+      char *inbuf, *outbuf;\n+      size_t inbytesleft, outbytesleft;\n+\n+      /* Reset conversion descriptor and check that it is valid.  */\n+      if (iconv (cd, 0, 0, 0, 0) == (size_t)-1)\n+\treturn false;\n+\n+      inbuf = (char *)from;\n+      inbytesleft = flen;\n+      outbuf = (char *)to->text + to->len;\n+      outbytesleft = to->asize - to->len;\n+\n+      for (;;)\n+\t{\n+\t  iconv (cd, &inbuf, &inbytesleft, &outbuf, &outbytesleft);\n+\t  if (__builtin_expect (inbytesleft == 0, 1))\n+\t    {\n+\t      to->len = to->asize - outbytesleft;\n+\t      return true;\n+\t    }\n+\t  if (errno != E2BIG)\n+\t    return false;\n+\n+\t  outbytesleft += OUTBUF_BLOCK_SIZE;\n+\t  to->asize += OUTBUF_BLOCK_SIZE;\n+\t  to->text = xrealloc (to->text, to->asize);\n+\t  outbuf = (char *)to->text + to->asize - outbytesleft;\n+\t}\n+    }\n+}\n+\n+/* Utility routine that computes a mask of the form 0000...111... with\n+   WIDTH 1-bits.  */\n+static inline size_t\n+width_to_mask (size_t width)\n+{\n+  width = MIN (width, BITS_PER_CPPCHAR_T);\n+  if (width >= CHAR_BIT * sizeof (size_t))\n+    return ~(size_t) 0;\n+  else\n+    return ((size_t) 1 << width) - 1;\n+}\n+\n+\f\n+\n+/* Returns 1 if C is valid in an identifier, 2 if C is valid except at\n+   the start of an identifier, and 0 if C is not valid in an\n+   identifier.  We assume C has already gone through the checks of\n+   _cpp_valid_ucn.  The algorithm is a simple binary search on the\n+   table defined in cppucnid.h.  */\n+\n+static int\n+ucn_valid_in_identifier (cpp_reader *pfile, cppchar_t c)\n+{\n+  int mn, mx, md;\n+\n+  mn = -1;\n+  mx = ARRAY_SIZE (ucnranges);\n+  while (mx - mn > 1)\n+    {\n+      md = (mn + mx) / 2;\n+      if (c < ucnranges[md].lo)\n+\tmx = md;\n+      else if (c > ucnranges[md].hi)\n+\tmn = md;\n+      else\n+\tgoto found;\n+    }\n+  return 0;\n \n-static int ucn_valid_in_identifier (cpp_reader *, cppchar_t);\n+ found:\n+  /* When -pedantic, we require the character to have been listed by\n+     the standard for the current language.  Otherwise, we accept the\n+     union of the acceptable sets for C++98 and C99.  */\n+  if (CPP_PEDANTIC (pfile)\n+      && ((CPP_OPTION (pfile, c99) && !(ucnranges[md].flags & C99))\n+\t  || (CPP_OPTION (pfile, cplusplus)\n+\t      && !(ucnranges[md].flags & CXX))))\n+    return 0;\n+\n+  /* In C99, UCN digits may not begin identifiers.  */\n+  if (CPP_OPTION (pfile, c99) && (ucnranges[md].flags & DIG))\n+    return 2;\n+\n+  return 1;\n+}\n \n /* [lex.charset]: The character designated by the universal character\n    name \\UNNNNNNNN is that character whose character short name in\n@@ -52,20 +322,21 @@ static int ucn_valid_in_identifier (cpp_reader *, cppchar_t);\n */\n \n cppchar_t\n-_cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr, int identifier_pos)\n+_cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n+\t\tconst uchar *limit, int identifier_pos)\n {\n   cppchar_t result, c;\n   unsigned int length;\n   const uchar *str = *pstr;\n   const uchar *base = str - 2;\n \n-  /* Only attempt to interpret a UCS for C++ and C99.  */\n   if (!CPP_OPTION (pfile, cplusplus) && !CPP_OPTION (pfile, c99))\n-    return 0;\n-\n-  /* We don't accept UCNs for an EBCDIC target.  */\n-  if (CPP_OPTION (pfile, EBCDIC))\n-    return 0;\n+    cpp_error (pfile, DL_WARNING,\n+\t       \"universal character names are only valid in C++ and C99\");\n+  else if (CPP_WTRADITIONAL (pfile) && identifier_pos == 0)\n+    cpp_error (pfile, DL_WARNING,\n+\t       \"the meaning of '\\\\%c' is different in traditional C\",\n+\t       (int) str[-1]);\n \n   if (str[-1] == 'u')\n     length = 4;\n@@ -83,13 +354,16 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr, int identifier_pos)\n       str++;\n       result = (result << 4) + hex_value (c);\n     }\n-  while (--length);\n+  while (--length && str < limit);\n \n   *pstr = str;\n   if (length)\n-    /* We'll error when we try it out as the start of an identifier.  */\n-    cpp_error (pfile, DL_ERROR, \"incomplete universal character name %.*s\",\n-\t       (int) (str - base), base);\n+    {\n+      /* We'll error when we try it out as the start of an identifier.  */\n+      cpp_error (pfile, DL_ERROR, \"incomplete universal character name %.*s\",\n+\t\t (int) (str - base), base);\n+      result = 1;\n+    }\n   /* The standard permits $, @ and ` to be specified as UCNs.  We use\n      hex escapes so that this also works with EBCDIC hosts.  */\n   else if ((result < 0xa0\n@@ -99,6 +373,7 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr, int identifier_pos)\n     {\n       cpp_error (pfile, DL_ERROR, \"%.*s is not a valid universal character\",\n \t\t (int) (str - base), base);\n+      result = 1;\n     }\n   else if (identifier_pos)\n     {\n@@ -113,474 +388,503 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr, int identifier_pos)\n    \"universal character %.*s is not valid at the start of an identifier\",\n \t\t   (int) (str - base), base);\n     }\n+  /* We don't accept UCNs if iconv is not available or will not\n+     convert to the target wide character set.  */\n+  else if (!HAVE_ICONV || pfile->wide_cset_desc == (iconv_t) -1)\n+    {\n+      /* XXX should be DL_SORRY */\n+      cpp_error (pfile, DL_ERROR,\n+\t\"universal character names are not supported in this configuration\");\n+    }\n+\n \n   if (result == 0)\n     result = 1;\n \n   return result;\n }\n \n-/* Returns 1 if C is valid in an identifier, 2 if C is valid except at\n-   the start of an identifier, and 0 if C is not valid in an\n-   identifier.  We assume C has already gone through the checks of\n-   _cpp_valid_ucn.  */\n-static int\n-ucn_valid_in_identifier (cpp_reader *pfile, cppchar_t c)\n+/* Convert an UCN, pointed to by FROM, to UTF-8 encoding, then translate\n+   it to the execution character set and write the result into TBUF.\n+   An advanced pointer is returned.  Issues all relevant diagnostics.\n+\n+   UTF-8 encoding looks like this:\n+\n+   value range\t       encoded as\n+   00000000-0000007F   0xxxxxxx\n+   00000080-000007FF   110xxxxx 10xxxxxx\n+   00000800-0000FFFF   1110xxxx 10xxxxxx 10xxxxxx\n+   00010000-001FFFFF   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+   00200000-03FFFFFF   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n+   04000000-7FFFFFFF   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n+\n+   Values in the 0000D800 ... 0000DFFF range (surrogates) are invalid,\n+   which means that three-byte sequences ED xx yy, with A0 <= xx <= BF,\n+   never occur.  Note also that any value that can be encoded by a\n+   given row of the table can also be encoded by all successive rows,\n+   but this is not done; only the shortest possible encoding for any\n+   given value is valid.  For instance, the character 07C0 could be\n+   encoded as any of DF 80, E0 9F 80, F0 80 9F 80, F8 80 80 9F 80, or\n+   FC 80 80 80 9F 80.  Only the first is valid.  */\n+\n+static const uchar *\n+convert_ucn (cpp_reader *pfile, const uchar *from, const uchar *limit,\n+\t     struct strbuf *tbuf, bool wide)\n {\n-  /* None of the valid chars are outside the Basic Multilingual Plane (the\n-     low 16 bits).  */\n-  if (c > 0xffff)\n-    return 0;\n+  int nbytes;\n+  uchar buf[6], *p = &buf[6];\n+  static const uchar masks[6] = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n+  cppchar_t ucn;\n+\n+  from++; /* skip u/U */\n+  ucn = _cpp_valid_ucn (pfile, &from, limit, 0);\n+  if (!ucn)\n+    return from;\n+\n+  nbytes = 1;\n+  if (ucn < 0x80)\n+    *--p = ucn;\n+  else\n+    {\n+      do\n+\t{\n+\t  *--p = ((ucn & 0x3F) | 0x80);\n+\t  ucn >>= 6;\n+\t  nbytes++;\n+\t}\n+      while (ucn >= 0x3F || (ucn & masks[nbytes-1]));\n+      *--p = (ucn | masks[nbytes-1]);\n+    }\n+\n+  if (!convert_cset (wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc,\n+\t\t     p, nbytes, tbuf))\n+    cpp_errno (pfile, DL_ERROR, \"converting UCN to execution character set\");\n+\n+  return from;\n+}\n \n-  if (CPP_OPTION (pfile, c99) || !CPP_PEDANTIC (pfile))\n+static void\n+emit_numeric_escape (cpp_reader *pfile, cppchar_t n,\n+\t\t     struct strbuf *tbuf, bool wide)\n+{\n+  if (wide)\n     {\n-      /* Latin.  */\n-      if (c == 0x0aa || c == 0x00ba || c == 0x207f || c == 0x1e9b)\n-\treturn 1;\n-\n-      /* Greek.  */\n-      if (c == 0x0386)\n-\treturn 1;\n-\n-      /* Cyrillic.  */\n-      if (c == 0x040c)\n-\treturn 1;\n-\n-      /* Hebrew.  */\n-      if ((c >= 0x05b0 && c <= 0x05b9)\n-\t  || (c >= 0x05bb && c <= 0x005bd)\n-\t  || c == 0x05bf\n-\t  || (c >= 0x05c1 && c <= 0x05c2))\n-\treturn 1;\n-\n-      /* Arabic.  */\n-      if ((c >= 0x06d0 && c <= 0x06dc)\n-\t  || c == 0x06e8\n-\t  || (c >= 0x06ea && c <= 0x06ed))\n-\treturn 1;\n-\n-      /* Devanagari */\n-      if ((c >= 0x0901 && c <= 0x0903)\n-\t  || (c >= 0x093e && c <= 0x094d)\n-\t  || (c >= 0x0950 && c <= 0x0952)\n-\t  || c == 0x0963)\n-\treturn 1;\n-\n-      /* Bengali */\n-      if ((c >= 0x0981 && c <= 0x0983)\n-\t  || (c >= 0x09be && c <= 0x09c4)\n-\t  || (c >= 0x09c7 && c <= 0x09c8)\n-\t  || (c >= 0x09cb && c <= 0x09cd)\n-\t  || (c >= 0x09e2 && c <= 0x09e3))\n-\treturn 1;\n-\n-      /* Gurmukhi */\n-      if (c == 0x0a02\n-\t  || (c >= 0x0a3e && c <= 0x0a42)\n-\t  || (c >= 0x0a47 && c <= 0x0a48)\n-\t  || (c >= 0x0a4b && c <= 0x0a4d)\n-\t  || (c == 0x0a74))\n-\treturn 1;\n-      \n-      /* Gujarati */\n-      if ((c >= 0x0a81 && c <= 0x0a83)\n-\t  || (c >= 0x0abd && c <= 0x0ac5)\n-\t  || (c >= 0x0ac7 && c <= 0x0ac9)\n-\t  || (c >= 0x0acb && c <= 0x0acd)\n-\t  || (c == 0x0ad0))\n-\treturn 1;\n-\n-      /* Oriya */\n-      if ((c >= 0x0b01 && c <= 0x0b03)\n-\t  || (c >= 0x0b3e && c <= 0x0b43)\n-\t  || (c >= 0x0b47 && c <= 0x0b48)\n-\t  || (c >= 0x0b4b && c <= 0x0b4d))\n-\treturn 1;\n-\n-      /* Tamil */\n-      if ((c >= 0x0b82 && c <= 0x0b83)\n-\t  || (c >= 0x0bbe && c <= 0x0bc2)\n-\t  || (c >= 0x0bc6 && c <= 0x0bc8)\n-\t  || (c >= 0x0bc8 && c <= 0x0bcd))\n-\treturn 1;\n-\n-      /* Telugu */\n-      if ((c >= 0x0c01 && c <= 0x0c03)\n-\t  || (c >= 0x0c3e && c <= 0x0c44)\n-\t  || (c >= 0x0c46 && c <= 0x0c48)\t\n-\t  || (c >= 0x0c4a && c <= 0x0c4d))\n-\treturn 1;\n-\n-      /* Kannada */\n-      if ((c >= 0x0c82 && c <= 0x0c83)\n-\t  || (c >= 0x0cbe && c <= 0x0cc4)\n-\t  || (c >= 0x0cc6 && c <= 0x0cc8)\n-\t  || (c >= 0x0cca && c <= 0x0ccd)\n-\t  || c == 0x0cde)\n-\treturn 1;\n-\n-      /* Malayalam */\n-      if ((c >= 0x0d02 && c <= 0x0d03)\n-\t  || (c >= 0x0d3e && c <= 0x0d43)\n-\t  || (c >= 0x0d46 && c <= 0x0d48)\n-\t  || (c >= 0x0d4a && c <= 0x0d4d))\n-\treturn 1;\n-\n-      /* Thai */\n-      if ((c >= 0x0e01 && c <= 0x0e3a)\n-\t  || (c >= 0x0e40 && c <= 0x0e5b))\n-\treturn 1;\n-\n-      /* Lao */\n-      if ((c >= 0x0ead && c <= 0x0eae)\n-\t  || (c >= 0x0eb0 && c <= 0x0eb9)\n-\t  || (c >= 0x0ebb && c <= 0x0ebd)\n-\t  || (c >= 0x0ec0 && c <= 0x0ec4)\n-\t  || c == 0x0ec6\n-\t  || (c >= 0x0ec8 && c <= 0x0ecd)\n-\t  || (c >= 0x0edc && c <= 0x0ed))\n-\treturn 1;\n-\n-      /* Tibetan.  */\n-      if (c == 0x0f00\n-\t  || (c >= 0x0f18 && c <= 0x0f19)\n-\t  || c == 0x0f35\n-\t  || c == 0x0f37\n-\t  || c == 0x0f39\n-\t  || (c >= 0x0f3e && c <= 0x0f47)\n-\t  || (c >= 0x0f49 && c <= 0x0f69)\n-\t  || (c >= 0x0f71 && c <= 0x0f84)\n-\t  || (c >= 0x0f86 && c <= 0x0f8b)\n-\t  || (c >= 0x0f90 && c <= 0x0f95)\n-\t  || c == 0x0f97\n-\t  || (c >= 0x0f99 && c <= 0x0fad)\n-\t  || (c >= 0x0fb1 && c <= 0x0fb7)\n-\t  || c == 0x0fb9)\n-\treturn 1;\n-\n-      /* Katakana */\n-      if ((c >= 0x30a1 && c <= 0x30f6)\n-\t  || (c >= 0x30fb && c <= 0x30fc))\n-\treturn 1;\n-\n-      /* CJK Unified Ideographs.  */\n-      if (c >= 0x4e00 && c <= 0x9fa5)\n-\treturn 1;\n-\n-      /* Hangul.  */\n-      if (c >= 0xac00 && c <= 0xd7a3)\n-\treturn 1;\n-\n-      /* Digits.  */\n-      if ((c >= 0x0660 && c <= 0x0669)\n-\t  || (c >= 0x06f0 && c <= 0x06f9)\n-\t  || (c >= 0x0966 && c <= 0x096f)\n-\t  || (c >= 0x09e6 && c <= 0x09ef)\n-\t  || (c >= 0x0a66 && c <= 0x0a6f)\n-\t  || (c >= 0x0ae6 && c <= 0x0aef)\n-\t  || (c >= 0x0b66 && c <= 0x0b6f)\n-\t  || (c >= 0x0be7 && c <= 0x0bef)\n-\t  || (c >= 0x0c66 && c <= 0x0c6f)\n-\t  || (c >= 0x0ce6 && c <= 0x0cef)\n-\t  || (c >= 0x0d66 && c <= 0x0d6f)\n-\t  || (c >= 0x0e50 && c <= 0x0e59)\n-\t  || (c >= 0x0ed0 && c <= 0x0ed9)\n-\t  || (c >= 0x0f20 && c <= 0x0f33))\n-\treturn 2;\n-\n-      /* Special characters.  */\n-      if (c == 0x00b5\n-\t  || c == 0x00b7\n-\t  || (c >= 0x02b0 && c <= 0x02b8)\n-\t  || c == 0x02bb\n-\t  || (c >= 0x02bd && c <= 0x02c1)\n-\t  || (c >= 0x02d0 && c <= 0x02d1)\n-\t  || (c >= 0x02e0 && c <= 0x02e4)\n-\t  || c == 0x037a\n-\t  || c == 0x0559\n-\t  || c == 0x093d\n-\t  || c == 0x0b3d\n-\t  || c == 0x1fbe\n-\t  || (c >= 0x203f && c <= 0x2040)\n-\t  || c == 0x2102\n-\t  || c == 0x2107\n-\t  || (c >= 0x210a && c <= 0x2113)\n-\t  || c == 0x2115\n-\t  || (c >= 0x2118 && c <= 0x211d)\n-\t  || c == 0x2124\n-\t  || c == 0x2126\n-\t  || c == 0x2128\n-\t  || (c >= 0x212a && c <= 0x2131)\n-\t  || (c >= 0x2133 && c <= 0x2138)\n-\t  || (c >= 0x2160 && c <= 0x2182)\n-\t  || (c >= 0x3005 && c <= 0x3007)\n-\t  || (c >= 0x3021 && c <= 0x3029))\n-\treturn 1;\t  \n+      /* We have to render this into the target byte order, which may not\n+\t be our byte order.  */\n+      bool bigend = CPP_OPTION (pfile, bytes_big_endian);\n+      size_t width = CPP_OPTION (pfile, wchar_precision);\n+      size_t cwidth = CPP_OPTION (pfile, char_precision);\n+      size_t cmask = width_to_mask (cwidth);\n+      size_t nbwc = width / cwidth;\n+      size_t i;\n+      size_t off = tbuf->len;\n+      cppchar_t c;\n+\n+      if (tbuf->len + nbwc > tbuf->asize)\n+\t{\n+\t  tbuf->asize += OUTBUF_BLOCK_SIZE;\n+\t  tbuf->text = xrealloc (tbuf->text, tbuf->asize);\n+\t}\n+\n+      for (i = 0; i < nbwc; i++)\n+\t{\n+\t  c = n & cmask;\n+\t  n >>= cwidth;\n+\t  tbuf->text[off + (bigend ? nbwc - i - 1 : i)] = c;\n+\t}\n+      tbuf->len += nbwc;\n     }\n-  \n-  if (CPP_OPTION (pfile, cplusplus) || !CPP_PEDANTIC (pfile))\n+  else\n     {\n-      /* Greek.  */\n-      if (c == 0x0384)\n-\treturn 1;\n-\n-      /* Cyrillic.  */\n-      if (c == 0x040d)\n-\treturn 1;\n-\n-      /* Hebrew.  */\n-      if (c >= 0x05f3 && c <= 0x05f4)\n-\treturn 1;\n-\n-      /* Lao.  */\n-      if ((c >= 0x0ead && c <= 0x0eb0)\n-\t  || (c == 0x0eb2)\n-\t  || (c == 0x0eb3)\n-\t  || (c == 0x0ebd)\n-\t  || (c >= 0x0ec0 && c <= 0x0ec4)\n-\t  || (c == 0x0ec6))\n-\treturn 1;\n-\n-      /* Hiragana */\n-      if (c == 0x3094\n-\t  || (c >= 0x309d && c <= 0x309e))\n-\treturn 1;\n-\n-      /* Katakana */\n-      if ((c >= 0x30a1 && c <= 0x30fe))\n-\treturn 1;\n-\n-      /* Hangul */\n-      if ((c >= 0x1100 && c <= 0x1159)\n-\t  || (c >= 0x1161 && c <= 0x11a2)\n-\t  || (c >= 0x11a8 && c <= 0x11f9))\n-\treturn 1;\n-\n-      /* CJK Unified Ideographs */\n-      if ((c >= 0xf900 && c <= 0xfa2d)\n-\t  || (c >= 0xfb1f && c <= 0xfb36)\n-\t  || (c >= 0xfb38 && c <= 0xfb3c)\n-\t  || (c == 0xfb3e)\n-\t  || (c >= 0xfb40 && c <= 0xfb41)\n-\t  || (c >= 0xfb42 && c <= 0xfb44)\n-\t  || (c >= 0xfb46 && c <= 0xfbb1)\n-\t  || (c >= 0xfbd3 && c <= 0xfd3f)\n-\t  || (c >= 0xfd50 && c <= 0xfd8f)\n-\t  || (c >= 0xfd92 && c <= 0xfdc7)\n-\t  || (c >= 0xfdf0 && c <= 0xfdfb)\n-\t  || (c >= 0xfe70 && c <= 0xfe72)\n-\t  || (c == 0xfe74)\n-\t  || (c >= 0xfe76 && c <= 0xfefc)\n-\t  || (c >= 0xff21 && c <= 0xff3a)\n-\t  || (c >= 0xff41 && c <= 0xff5a)\n-\t  || (c >= 0xff66 && c <= 0xffbe)\n-\t  || (c >= 0xffc2 && c <= 0xffc7)\n-\t  || (c >= 0xffca && c <= 0xffcf)\n-\t  || (c >= 0xffd2 && c <= 0xffd7)\n-\t  || (c >= 0xffda && c <= 0xffdc)\n-\t  || (c >= 0x4e00 && c <= 0x9fa5))\n-\treturn 1;\n+      if (tbuf->len + 1 > tbuf->asize)\n+\t{\n+\t  tbuf->asize += OUTBUF_BLOCK_SIZE;\n+\t  tbuf->text = xrealloc (tbuf->text, tbuf->asize);\n+\t}\n+      tbuf->text[tbuf->len++] = n;\n     }\n+}\n \n-  /* Latin */\n-  if ((c >= 0x00c0 && c <= 0x00d6)\n-      || (c >= 0x00d8 && c <= 0x00f6)\n-      || (c >= 0x00f8 && c <= 0x01f5)\n-      || (c >= 0x01fa && c <= 0x0217)\n-      || (c >= 0x0250 && c <= 0x02a8)\n-      || (c >= 0x1e00 && c <= 0x1e9a)\n-      || (c >= 0x1ea0 && c <= 0x1ef9))\n-    return 1;\n-\n-  /* Greek */\n-  if ((c >= 0x0388 && c <= 0x038a)\n-      || (c == 0x038c)\n-      || (c >= 0x038e && c <= 0x03a1)\n-      || (c >= 0x03a3 && c <= 0x03ce)\n-      || (c >= 0x03d0 && c <= 0x03d6)\n-      || (c == 0x03da)\n-      || (c == 0x03dc)\n-      || (c == 0x03de)\n-      || (c == 0x03e0)\n-      || (c >= 0x03e2 && c <= 0x03f3)\n-      || (c >= 0x1f00 && c <= 0x1f15)\n-      || (c >= 0x1f18 && c <= 0x1f1d)\n-      || (c >= 0x1f20 && c <= 0x1f45)\n-      || (c >= 0x1f48 && c <= 0x1f4d)\n-      || (c >= 0x1f50 && c <= 0x1f57)\n-      || (c == 0x1f59)\n-      || (c == 0x1f5b)\n-      || (c == 0x1f5d)\n-      || (c >= 0x1f5f && c <= 0x1f7d)\n-      || (c >= 0x1f80 && c <= 0x1fb4)\n-      || (c >= 0x1fb6 && c <= 0x1fbc)\n-      || (c >= 0x1fc2 && c <= 0x1fc4)\n-      || (c >= 0x1fc6 && c <= 0x1fcc)\n-      || (c >= 0x1fd0 && c <= 0x1fd3)\n-      || (c >= 0x1fd6 && c <= 0x1fdb)\n-      || (c >= 0x1fe0 && c <= 0x1fec)\n-      || (c >= 0x1ff2 && c <= 0x1ff4)\n-      || (c >= 0x1ff6 && c <= 0x1ffc))\n-    return 1;\n-\n-  /* Cyrillic */\n-  if ((c >= 0x0401 && c <= 0x040c)\n-      || (c >= 0x040f && c <= 0x044f)\n-      || (c >= 0x0451 && c <= 0x045c)\n-      || (c >= 0x045e && c <= 0x0481)\n-      || (c >= 0x0490 && c <= 0x04c4)\n-      || (c >= 0x04c7 && c <= 0x04c8)\n-      || (c >= 0x04cb && c <= 0x04cc)\n-      || (c >= 0x04d0 && c <= 0x04eb)\n-      || (c >= 0x04ee && c <= 0x04f5)\n-      || (c >= 0x04f8 && c <= 0x04f9))\n-    return 1;\n-\n-  /* Armenian */\n-  if ((c >= 0x0531 && c <= 0x0556)\n-      || (c >= 0x0561 && c <= 0x0587))\n-    return 1;\n-\n-  /* Hebrew */\n-  if ((c >= 0x05d0 && c <= 0x05ea)\n-      || (c >= 0x05f0 && c <= 0x05f2))\n-    return 1;\n-\n-  /* Arabic */\n-  if ((c >= 0x0621 && c <= 0x063a)\n-      || (c >= 0x0640 && c <= 0x0652)\n-      || (c >= 0x0670 && c <= 0x06b7)\n-      || (c >= 0x06ba && c <= 0x06be)\n-      || (c >= 0x06c0 && c <= 0x06ce)\n-      || (c >= 0x06e5 && c <= 0x06e7))\n-    return 1;\n-\n-  /* Devanagari */\n-  if ((c >= 0x0905 && c <= 0x0939)\n-      || (c >= 0x0958 && c <= 0x0962))\n-    return 1;\n-\n-  /* Bengali */\n-  if ((c >= 0x0985 && c <= 0x098c)\n-      || (c >= 0x098f && c <= 0x0990)\n-      || (c >= 0x0993 && c <= 0x09a8)\n-      || (c >= 0x09aa && c <= 0x09b0)\n-      || (c == 0x09b2)\n-      || (c >= 0x09b6 && c <= 0x09b9)\n-      || (c >= 0x09dc && c <= 0x09dd)\n-      || (c >= 0x09df && c <= 0x09e1)\n-      || (c >= 0x09f0 && c <= 0x09f1))\n-    return 1;\n-\n-  /* Gurmukhi */\n-  if ((c >= 0x0a05 && c <= 0x0a0a)\n-      || (c >= 0x0a0f && c <= 0x0a10)\n-      || (c >= 0x0a13 && c <= 0x0a28)\n-      || (c >= 0x0a2a && c <= 0x0a30)\n-      || (c >= 0x0a32 && c <= 0x0a33)\n-      || (c >= 0x0a35 && c <= 0x0a36)\n-      || (c >= 0x0a38 && c <= 0x0a39)\n-      || (c >= 0x0a59 && c <= 0x0a5c)\n-      || (c == 0x0a5e))\n-    return 1;\n-\n-  /* Gujarati */\n-  if ((c >= 0x0a85 && c <= 0x0a8b)\n-      || (c == 0x0a8d)\n-      || (c >= 0x0a8f && c <= 0x0a91)\n-      || (c >= 0x0a93 && c <= 0x0aa8)\n-      || (c >= 0x0aaa && c <= 0x0ab0)\n-      || (c >= 0x0ab2 && c <= 0x0ab3)\n-      || (c >= 0x0ab5 && c <= 0x0ab9)\n-      || (c == 0x0ae0))\n-    return 1;\n-\n-  /* Oriya */\n-  if ((c >= 0x0b05 && c <= 0x0b0c)\n-      || (c >= 0x0b0f && c <= 0x0b10)\n-      || (c >= 0x0b13 && c <= 0x0b28)\n-      || (c >= 0x0b2a && c <= 0x0b30)\n-      || (c >= 0x0b32 && c <= 0x0b33)\n-      || (c >= 0x0b36 && c <= 0x0b39)\n-      || (c >= 0x0b5c && c <= 0x0b5d)\n-      || (c >= 0x0b5f && c <= 0x0b61))\n-    return 1;\n-\n-  /* Tamil */\n-  if ((c >= 0x0b85 && c <= 0x0b8a)\n-      || (c >= 0x0b8e && c <= 0x0b90)\n-      || (c >= 0x0b92 && c <= 0x0b95)\n-      || (c >= 0x0b99 && c <= 0x0b9a)\n-      || (c == 0x0b9c)\n-      || (c >= 0x0b9e && c <= 0x0b9f)\n-      || (c >= 0x0ba3 && c <= 0x0ba4)\n-      || (c >= 0x0ba8 && c <= 0x0baa)\n-      || (c >= 0x0bae && c <= 0x0bb5)\n-      || (c >= 0x0bb7 && c <= 0x0bb9))\n-    return 1;\n-\n-  /* Telugu */\n-  if ((c >= 0x0c05 && c <= 0x0c0c)\n-      || (c >= 0x0c0e && c <= 0x0c10)\n-      || (c >= 0x0c12 && c <= 0x0c28)\n-      || (c >= 0x0c2a && c <= 0x0c33)\n-      || (c >= 0x0c35 && c <= 0x0c39)\n-      || (c >= 0x0c60 && c <= 0x0c61))\n-    return 1;\n-\n-  /* Kannada */\n-  if ((c >= 0x0c85 && c <= 0x0c8c)\n-      || (c >= 0x0c8e && c <= 0x0c90)\n-      || (c >= 0x0c92 && c <= 0x0ca8)\n-      || (c >= 0x0caa && c <= 0x0cb3)\n-      || (c >= 0x0cb5 && c <= 0x0cb9)\n-      || (c >= 0x0ce0 && c <= 0x0ce1))\n-    return 1;\n-\n-  /* Malayalam */\n-  if ((c >= 0x0d05 && c <= 0x0d0c)\n-      || (c >= 0x0d0e && c <= 0x0d10)\n-      || (c >= 0x0d12 && c <= 0x0d28)\n-      || (c >= 0x0d2a && c <= 0x0d39)\n-      || (c >= 0x0d60 && c <= 0x0d61))\n-    return 1;\n-\n-  /* Thai */\n-  if ((c >= 0x0e01 && c <= 0x0e30)\n-      || (c >= 0x0e32 && c <= 0x0e33)\n-      || (c >= 0x0e40 && c <= 0x0e46)\n-      || (c >= 0x0e4f && c <= 0x0e5b))\n-    return 1;\n-\n-  /* Lao */\n-  if ((c >= 0x0e81 && c <= 0x0e82)\n-      || (c == 0x0e84)\n-      || (c == 0x0e87)\n-      || (c == 0x0e88)\n-      || (c == 0x0e8a)\n-      || (c == 0x0e8d)\n-      || (c >= 0x0e94 && c <= 0x0e97)\n-      || (c >= 0x0e99 && c <= 0x0e9f)\n-      || (c >= 0x0ea1 && c <= 0x0ea3)\n-      || (c == 0x0ea5)\n-      || (c == 0x0ea7)\n-      || (c == 0x0eaa)\n-      || (c == 0x0eab))\n-    return 1;\n-\n-  /* Georgian */\n-  if ((c >= 0x10a0 && c <= 0x10c5)\n-      || (c >= 0x10d0 && c <= 0x10f6))\n-    return 1;\n-\n-  /* Hiragana */\n-  if ((c >= 0x3041 && c <= 0x3093)\n-      || (c >= 0x309b && c <= 0x309c))\n-    return 1;\n-\n-  /* Bopmofo */\n-  if ((c >= 0x3105 && c <= 0x312c))\n-    return 1;\n+/* Convert a hexadecimal escape, pointed to by FROM, to the execution\n+   character set and write it into the string buffer TBUF.  Returns an\n+   advanced pointer, and issues diagnostics as necessary.\n+   No character set translation occurs; this routine always produces the\n+   execution-set character with numeric value equal to the given hex\n+   number.  You can, e.g. generate surrogate pairs this way.  */\n+static const uchar *\n+convert_hex (cpp_reader *pfile, const uchar *from, const uchar *limit,\n+\t     struct strbuf *tbuf, bool wide)\n+{\n+  cppchar_t c, n = 0, overflow = 0;\n+  int digits_found = 0;\n+  size_t width = (wide ? CPP_OPTION (pfile, wchar_precision)\n+\t\t  : CPP_OPTION (pfile, char_precision));\n+  size_t mask = width_to_mask (width);\n+\n+  if (CPP_WTRADITIONAL (pfile))\n+    cpp_error (pfile, DL_WARNING,\n+\t       \"the meaning of '\\\\x' is different in traditional C\");\n+\n+  from++;  /* skip 'x' */\n+  while (from < limit)\n+    {\n+      c = *from;\n+      if (! hex_p (c))\n+\tbreak;\n+      from++;\n+      overflow |= n ^ (n << 4 >> 4);\n+      n = (n << 4) + hex_value (c);\n+      digits_found = 1;\n+    }\n \n-  return 0;\n+  if (!digits_found)\n+    {\n+      cpp_error (pfile, DL_ERROR,\n+\t\t \"\\\\x used with no following hex digits\");\n+      return from;\n+    }\n+\n+  if (overflow | (n != (n & mask)))\n+    {\n+      cpp_error (pfile, DL_PEDWARN,\n+\t\t \"hex escape sequence out of range\");\n+      n &= mask;\n+    }\n+\n+  emit_numeric_escape (pfile, n, tbuf, wide);\n+\n+  return from;\n+}\n+\n+/* Convert an octal escape, pointed to by FROM, to the execution\n+   character set and write it into the string buffer TBUF.  Returns an\n+   advanced pointer, and issues diagnostics as necessary.\n+   No character set translation occurs; this routine always produces the\n+   execution-set character with numeric value equal to the given octal\n+   number.  */\n+static const uchar *\n+convert_oct (cpp_reader *pfile, const uchar *from, const uchar *limit,\n+\t     struct strbuf *tbuf, bool wide)\n+{\n+  size_t count = 0;\n+  cppchar_t c, n = 0;\n+  size_t width = (wide ? CPP_OPTION (pfile, wchar_precision)\n+\t\t  : CPP_OPTION (pfile, char_precision));\n+  size_t mask = width_to_mask (width);\n+  bool overflow = false;\n+\n+  while (from < limit && count++ < 3)\n+    {\n+      c = *from;\n+      if (c < '0' || c > '7')\n+\tbreak;\n+      from++;\n+      overflow |= n ^ (n << 3 >> 3);\n+      n = (n << 3) + c - '0';\n+    }\n+\n+  if (n != (n & mask))\n+    {\n+      cpp_error (pfile, DL_PEDWARN,\n+\t\t \"octal escape sequence out of range\");\n+      n &= mask;\n+    }\n+\n+  emit_numeric_escape (pfile, n, tbuf, wide);\n+\n+  return from;\n+}\n+\n+/* Convert an escape sequence (pointed to by FROM) to its value on\n+   the target, and to the execution character set.  Do not scan past\n+   LIMIT.  Write the converted value into TBUF.  Returns an advanced\n+   pointer.  Handles all relevant diagnostics.  */\n+static const uchar *\n+convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n+\t\tstruct strbuf *tbuf, bool wide)\n+{\n+  /* Values of \\a \\b \\e \\f \\n \\r \\t \\v respectively.  */\n+#if HOST_CHARSET == HOST_CHARSET_ASCII\n+  static const uchar charconsts[] = {  7,  8, 27, 12, 10, 13,  9, 11 };\n+#elif HOST_CHARSET == HOST_CHARSET_EBCDIC\n+  static const uchar charconsts[] = { 47, 22, 39, 12, 21, 13,  5, 11 };\n+#else\n+#error \"unknown host character set\"\n+#endif\n+\n+  uchar c;\n+\n+  c = *from;\n+  switch (c)\n+    {\n+      /* UCNs, hex escapes, and octal escapes are processed separately.  */\n+    case 'u': case 'U':\n+      return convert_ucn (pfile, from, limit, tbuf, wide);\n+\n+    case 'x':\n+      return convert_hex (pfile, from, limit, tbuf, wide);\n+      break;\n+\n+    case '0':  case '1':  case '2':  case '3':\n+    case '4':  case '5':  case '6':  case '7':\n+      return convert_oct (pfile, from, limit, tbuf, wide);\n+\n+      /* Various letter escapes.  Get the appropriate host-charset\n+\t value into C.  */\n+    case '\\\\': case '\\'': case '\"': case '?': break;\n+\n+    case '(': case '{': case '[': case '%':\n+      /* '\\(', etc, can be used at the beginning of a line in a long\n+\t string split onto multiple lines with \\-newline, to prevent\n+\t Emacs or other text editors from getting confused.  '\\%' can\n+\t be used to prevent SCCS from mangling printf format strings.  */\n+      if (CPP_PEDANTIC (pfile))\n+\tgoto unknown;\n+      break;\n+\n+    case 'b': c = charconsts[1];  break;\n+    case 'f': c = charconsts[3];  break;\n+    case 'n': c = charconsts[4];  break;\n+    case 'r': c = charconsts[5];  break;\n+    case 't': c = charconsts[6];  break;\n+    case 'v': c = charconsts[7];  break;\n+\n+    case 'a':\n+      if (CPP_WTRADITIONAL (pfile))\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"the meaning of '\\\\a' is different in traditional C\");\n+      c = charconsts[0];\n+      break;\n+\n+    case 'e': case 'E':\n+      if (CPP_PEDANTIC (pfile))\n+\tcpp_error (pfile, DL_PEDWARN,\n+\t\t   \"non-ISO-standard escape sequence, '\\\\%c'\", (int) c);\n+      c = charconsts[2];\n+      break;\n+\n+    default:\n+    unknown:\n+      if (ISGRAPH (c))\n+\tcpp_error (pfile, DL_PEDWARN,\n+\t\t   \"unknown escape sequence '\\\\%c'\", (int) c);\n+      else\n+\tcpp_error (pfile, DL_PEDWARN,\n+\t\t   \"unknown escape sequence: '\\\\%03o'\", (int) c);\n+    }\n+\n+  /* Now convert what we have to the execution character set.  */\n+  if (!convert_cset (wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc,\n+\t\t     &c, 1, tbuf))\n+    cpp_errno (pfile, DL_ERROR,\n+\t       \"converting escape sequence to execution character set\");\n+\n+  return from + 1;\n+}\n+\f\n+/* FROM is an array of cpp_string structures of length COUNT.  These\n+   are to be converted from the source to the execution character set,\n+   escape sequences translated, and finally all are to be\n+   concatenated.  WIDE indicates whether or not to produce a wide\n+   string.  The result is written into TO.  Returns true for success,\n+   false for failure.  */\n+bool\n+cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n+\t\t      cpp_string *to, bool wide)\n+{\n+  struct strbuf tbuf;\n+  const uchar *p, *base, *limit;\n+  size_t i;\n+  iconv_t cd = wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc;\n+\n+  tbuf.asize = MAX (OUTBUF_BLOCK_SIZE, from->len);\n+  tbuf.text = xmalloc (tbuf.asize);\n+  tbuf.len = 0;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      p = from[i].text;\n+      if (*p == 'L') p++;\n+      p++; /* skip leading quote */\n+      limit = from[i].text + from[i].len - 1; /* skip trailing quote */\n+\n+      for (;;)\n+\t{\n+\t  base = p;\n+\t  while (p < limit && *p != '\\\\')\n+\t    p++;\n+\t  if (p > base)\n+\t    {\n+\t      /* We have a run of normal characters; these can be fed\n+\t\t directly to convert_cset.  */\n+\t      if (!convert_cset (cd, base, p - base, &tbuf))\n+\t\tgoto fail;\n+\t    }\n+\t  if (p == limit)\n+\t    break;\n+\n+\t  p = convert_escape (pfile, p + 1, limit, &tbuf, wide);\n+\t}\n+    }\n+  /* NUL-terminate the 'to' buffer and translate it to a cpp_string\n+     structure.  */\n+  emit_numeric_escape (pfile, 0, &tbuf, wide);\n+  tbuf.text = xrealloc (tbuf.text, tbuf.len);\n+  to->text = tbuf.text;\n+  to->len = tbuf.len;\n+  return true;\n+\n+ fail:\n+  cpp_errno (pfile, DL_ERROR, \"converting to execution character set\");\n+  free (tbuf.text);\n+  return false;\n+}\n+\f\n+/* Subroutine of cpp_interpret_charconst which performs the conversion\n+   to a number, for narrow strings.  STR is the string structure returned\n+   by cpp_interpret_string.  PCHARS_SEEN and UNSIGNEDP are as for\n+   cpp_interpret_charconst.  */\n+static cppchar_t\n+narrow_str_to_charconst (cpp_reader *pfile, cpp_string str,\n+\t\t\t unsigned int *pchars_seen, int *unsignedp)\n+{\n+  size_t width = CPP_OPTION (pfile, char_precision);\n+  size_t max_chars = CPP_OPTION (pfile, int_precision) / width;\n+  size_t mask = width_to_mask (width);\n+  size_t i;\n+  cppchar_t result, c;\n+  bool unsigned_p;\n+\n+  /* The value of a multi-character character constant, or a\n+     single-character character constant whose representation in the\n+     execution character set is more than one byte long, is\n+     implementation defined.  This implementation defines it to be the\n+     number formed by interpreting the byte sequence in memory as a\n+     big-endian binary number.  If overflow occurs, the high bytes are\n+     lost, and a warning is issued.\n+\n+     We don't want to process the NUL terminator handed back by\n+     cpp_interpret_string.  */\n+  result = 0;\n+  for (i = 0; i < str.len - 1; i++)\n+    {\n+      c = str.text[i] & mask;\n+      if (width < BITS_PER_CPPCHAR_T)\n+\tresult = (result << width) | c;\n+      else\n+\tresult = c;\n+    }\n+\n+  if (i > max_chars)\n+    {\n+      i = max_chars;\n+      cpp_error (pfile, DL_WARNING, \"character constant too long for its type\");\n+    }\n+  else if (i > 1 && CPP_OPTION (pfile, warn_multichar))\n+    cpp_error (pfile, DL_WARNING, \"multi-character character constant\");\n+\n+  /* Multichar constants are of type int and therefore signed.  */\n+  if (i > 1)\n+    unsigned_p = 0;\n+  else\n+    unsigned_p = CPP_OPTION (pfile, unsigned_char);\n+\n+  /* Truncate the constant to its natural width, and simultaneously\n+     sign- or zero-extend to the full width of cppchar_t.\n+     For single-character constants, the value is WIDTH bits wide.\n+     For multi-character constants, the value is INT_PRECISION bits wide.  */\n+  if (i > 1)\n+    width = CPP_OPTION (pfile, int_precision);\n+  if (width < BITS_PER_CPPCHAR_T)\n+    {\n+      mask = ((cppchar_t) 1 << width) - 1;\n+      if (unsigned_p || !(result & (1 << (width - 1))))\n+\tresult &= mask;\n+      else\n+\tresult |= ~mask;\n+    }\n+  *pchars_seen = i;\n+  *unsignedp = unsigned_p;\n+  return result;\n+}\n+\t\t\t \n+/* Subroutine of cpp_interpret_charconst which performs the conversion\n+   to a number, for wide strings.  STR is the string structure returned\n+   by cpp_interpret_string.  PCHARS_SEEN and UNSIGNEDP are as for\n+   cpp_interpret_charconst.  */\n+static cppchar_t\n+wide_str_to_charconst (cpp_reader *pfile, cpp_string str,\n+\t\t       unsigned int *pchars_seen, int *unsignedp)\n+{\n+  bool bigend = CPP_OPTION (pfile, bytes_big_endian);\n+  size_t width = CPP_OPTION (pfile, wchar_precision);\n+  size_t cwidth = CPP_OPTION (pfile, char_precision);\n+  size_t mask = width_to_mask (width);\n+  size_t cmask = width_to_mask (cwidth);\n+  size_t nbwc = width / cwidth;\n+  size_t off, i;\n+  cppchar_t result = 0, c;\n+\n+  /* This is finicky because the string is in the target's byte order,\n+     which may not be our byte order.  Only the last character, ignoring\n+     the NUL terminator, is relevant.  */\n+  off = str.len - (nbwc * 2);\n+  result = 0;\n+  for (i = 0; i < nbwc; i++)\n+    {\n+      c = bigend ? str.text[off + i] : str.text[off + nbwc - i - 1];\n+      result = (result << cwidth) | (c & cmask);\n+    }\n+\n+  /* Wide character constants have type wchar_t, and a single\n+     character exactly fills a wchar_t, so a multi-character wide\n+     character constant is guaranteed to overflow.  */\n+  if (off > 0)\n+    cpp_error (pfile, DL_WARNING, \"character constant too long for its type\");\n+\n+  /* Truncate the constant to its natural width, and simultaneously\n+     sign- or zero-extend to the full width of cppchar_t.  */\n+  if (width < BITS_PER_CPPCHAR_T)\n+    {\n+      if (CPP_OPTION (pfile, unsigned_wchar) || !(result & (1 << (width - 1))))\n+\tresult &= mask;\n+      else\n+\tresult |= ~mask;\n+    }\n+\n+  *unsignedp = CPP_OPTION (pfile, unsigned_wchar);\n+  *pchars_seen = 1;\n+  return result;\n+}\n+\n+/* Interpret a (possibly wide) character constant in TOKEN.\n+   PCHARS_SEEN points to a variable that is filled in with the number\n+   of characters seen, and UNSIGNEDP to a variable that indicates\n+   whether the result has signed type.  */\n+cppchar_t\n+cpp_interpret_charconst (cpp_reader *pfile, const cpp_token *token,\n+\t\t\t unsigned int *pchars_seen, int *unsignedp)\n+{\n+  cpp_string str = { 0, 0 };\n+  bool wide = (token->type == CPP_WCHAR);\n+  cppchar_t result;\n+\n+  /* an empty constant will appear as L'' or '' */\n+  if (token->val.str.len == (size_t) (2 + wide))\n+    {\n+      cpp_error (pfile, DL_ERROR, \"empty character constant\");\n+      return 0;\n+    }\n+  else if (!cpp_interpret_string (pfile, &token->val.str, 1, &str, wide))\n+    return 0;\n+\n+  if (wide)\n+    result = wide_str_to_charconst (pfile, str, pchars_seen, unsignedp);\n+  else\n+    result = narrow_str_to_charconst (pfile, str, pchars_seen, unsignedp);\n+\n+  if (str.text != token->val.str.text)\n+    free ((void *)str.text);\n+\n+  return result;\n }"}, {"sha": "f4a7cfcde287644f269a2dc2295536e2b122338f", "filename": "gcc/cpphash.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -25,6 +25,13 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n #include \"hashtable.h\"\n \n+#ifdef HAVE_ICONV\n+#include <iconv.h>\n+#else\n+#define HAVE_ICONV 0\n+typedef int iconv_t;  /* dummy */\n+#endif\n+\n struct directive;\t\t/* Deliberately incomplete.  */\n struct pending_option;\n struct op;\n@@ -362,6 +369,15 @@ struct cpp_reader\n   unsigned char *macro_buffer;\n   unsigned int macro_buffer_len;\n \n+  /* Iconv descriptor for converting from the source character set\n+     to the execution character set.  (iconv_t)-1 for no conversion.  */\n+  iconv_t narrow_cset_desc;\n+\n+  /* Iconv descriptor for converting from the execution character set\n+     to the wide execution character set.  (iconv_t)-1 for no conversion\n+     other than zero-extending each character to the width of wchar_t.  */\n+  iconv_t wide_cset_desc;\n+\n   /* Tree of other included files.  See cppfiles.c.  */\n   struct splay_tree_s *all_include_files;\n \n@@ -539,7 +555,8 @@ extern uchar *_cpp_copy_replacement_text (const cpp_macro *, uchar *);\n extern size_t _cpp_replacement_text_len (const cpp_macro *);\n \n /* In cppcharset.c.  */\n-cppchar_t _cpp_valid_ucn (cpp_reader *, const uchar **, int identifer_p);\n+cppchar_t _cpp_valid_ucn (cpp_reader *, const uchar **, const uchar *, int);\n+void _cpp_destroy_iconv (cpp_reader *);\n \n /* Utility routines and macros.  */\n #define DSC(str) (const uchar *)str, sizeof str - 1"}, {"sha": "cc1faecf966008a51cd89d12299ce95f2eabf892", "filename": "gcc/cppinit.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -157,6 +157,11 @@ cpp_create_reader (enum c_lang lang, hash_table *table)\n   CPP_OPTION (pfile, int_precision) = CHAR_BIT * sizeof (int);\n   CPP_OPTION (pfile, unsigned_char) = 0;\n   CPP_OPTION (pfile, unsigned_wchar) = 1;\n+  CPP_OPTION (pfile, bytes_big_endian) = 1;  /* does not matter */\n+\n+  /* Default to no charset conversion.  */\n+  CPP_OPTION (pfile, narrow_charset) = 0;\n+  CPP_OPTION (pfile, wide_charset) = 0;\n \n   /* Initialize the line map.  Start at logical line 1, so we can use\n      a line number of zero for special states.  */\n@@ -227,6 +232,7 @@ cpp_destroy (cpp_reader *pfile)\n \n   _cpp_destroy_hashtable (pfile);\n   _cpp_cleanup_includes (pfile);\n+  _cpp_destroy_iconv (pfile);\n \n   _cpp_free_buff (pfile->a_buff);\n   _cpp_free_buff (pfile->u_buff);"}, {"sha": "edb765dc61b47cb9466ea8a1b1ed8e7e4d38c46e", "filename": "gcc/cpplex.c", "status": "modified", "additions": 1, "deletions": 288, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -64,10 +64,8 @@ static void create_literal (cpp_reader *, cpp_token *, const uchar *,\n \t\t\t    unsigned int, enum cpp_ttype);\n static bool warn_in_comment (cpp_reader *, _cpp_line_note *);\n static int name_p (cpp_reader *, const cpp_string *);\n-static cppchar_t maybe_read_ucn (cpp_reader *, const uchar **);\n static tokenrun *next_tokenrun (tokenrun *);\n \n-static unsigned int hex_digit_value (unsigned int);\n static _cpp_buff *new_buff (size_t);\n \n \n@@ -397,7 +395,7 @@ forms_identifier_p (cpp_reader *pfile, int first)\n       && (buffer->cur[1] == 'u' || buffer->cur[1] == 'U'))\n     {\n       buffer->cur += 2;\n-      if (_cpp_valid_ucn (pfile, &buffer->cur, 1 + !first))\n+      if (_cpp_valid_ucn (pfile, &buffer->cur, buffer->rlimit, 1 + !first))\n \treturn true;\n       buffer->cur -= 2;\n     }\n@@ -1316,291 +1314,6 @@ cpp_output_line (cpp_reader *pfile, FILE *fp)\n   putc ('\\n', fp);\n }\n \n-/* Returns the value of a hexadecimal digit.  */\n-static unsigned int\n-hex_digit_value (unsigned int c)\n-{\n-  if (hex_p (c))\n-    return hex_value (c);\n-  else\n-    abort ();\n-}\n-\n-/* Read a possible universal character name starting at *PSTR.  */\n-static cppchar_t\n-maybe_read_ucn (cpp_reader *pfile, const uchar **pstr)\n-{\n-  cppchar_t result, c = (*pstr)[-1];\n-\n-  result = _cpp_valid_ucn (pfile, pstr, false);\n-  if (result)\n-    {\n-      if (CPP_WTRADITIONAL (pfile))\n-\tcpp_error (pfile, DL_WARNING,\n-\t\t   \"the meaning of '\\\\%c' is different in traditional C\",\n-\t\t   (int) c);\n-\n-      if (CPP_OPTION (pfile, EBCDIC))\n-\t{\n-\t  cpp_error (pfile, DL_ERROR,\n-\t\t     \"universal character with an EBCDIC target\");\n-\t  result = 0x3f;  /* EBCDIC invalid character */\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n-/* Returns the value of an escape sequence, truncated to the correct\n-   target precision.  PSTR points to the input pointer, which is just\n-   after the backslash.  LIMIT is how much text we have.  WIDE is true\n-   if the escape sequence is part of a wide character constant or\n-   string literal.  Handles all relevant diagnostics.  */\n-cppchar_t\n-cpp_parse_escape (cpp_reader *pfile, const unsigned char **pstr,\n-\t\t  const unsigned char *limit, int wide)\n-{\n-  /* Values of \\a \\b \\e \\f \\n \\r \\t \\v respectively.  */\n-  static const uchar ascii[]  = {  7,  8, 27, 12, 10, 13,  9, 11 };\n-  static const uchar ebcdic[] = { 47, 22, 39, 12, 21, 13,  5, 11 };\n-\n-  int unknown = 0;\n-  const unsigned char *str = *pstr, *charconsts;\n-  cppchar_t c, ucn, mask;\n-  unsigned int width;\n-\n-  if (CPP_OPTION (pfile, EBCDIC))\n-    charconsts = ebcdic;\n-  else\n-    charconsts = ascii;\n-\n-  if (wide)\n-    width = CPP_OPTION (pfile, wchar_precision);\n-  else\n-    width = CPP_OPTION (pfile, char_precision);\n-  if (width < BITS_PER_CPPCHAR_T)\n-    mask = ((cppchar_t) 1 << width) - 1;\n-  else\n-    mask = ~0;\n-\n-  c = *str++;\n-  switch (c)\n-    {\n-    case '\\\\': case '\\'': case '\"': case '?': break;\n-    case 'b': c = charconsts[1];  break;\n-    case 'f': c = charconsts[3];  break;\n-    case 'n': c = charconsts[4];  break;\n-    case 'r': c = charconsts[5];  break;\n-    case 't': c = charconsts[6];  break;\n-    case 'v': c = charconsts[7];  break;\n-\n-    case '(': case '{': case '[': case '%':\n-      /* '\\(', etc, are used at beginning of line to avoid confusing Emacs.\n-\t '\\%' is used to prevent SCCS from getting confused.  */\n-      unknown = CPP_PEDANTIC (pfile);\n-      break;\n-\n-    case 'a':\n-      if (CPP_WTRADITIONAL (pfile))\n-\tcpp_error (pfile, DL_WARNING,\n-\t\t   \"the meaning of '\\\\a' is different in traditional C\");\n-      c = charconsts[0];\n-      break;\n-\n-    case 'e': case 'E':\n-      if (CPP_PEDANTIC (pfile))\n-\tcpp_error (pfile, DL_PEDWARN,\n-\t\t   \"non-ISO-standard escape sequence, '\\\\%c'\", (int) c);\n-      c = charconsts[2];\n-      break;\n-\n-    case 'u': case 'U':\n-      ucn = maybe_read_ucn (pfile, &str);\n-      if (ucn)\n-\tc = ucn;\n-      else\n-\tunknown = true;\n-      break;\n-\n-    case 'x':\n-      if (CPP_WTRADITIONAL (pfile))\n-\tcpp_error (pfile, DL_WARNING,\n-\t\t   \"the meaning of '\\\\x' is different in traditional C\");\n-\n-      {\n-\tcppchar_t i = 0, overflow = 0;\n-\tint digits_found = 0;\n-\n-\twhile (str < limit)\n-\t  {\n-\t    c = *str;\n-\t    if (! ISXDIGIT (c))\n-\t      break;\n-\t    str++;\n-\t    overflow |= i ^ (i << 4 >> 4);\n-\t    i = (i << 4) + hex_digit_value (c);\n-\t    digits_found = 1;\n-\t  }\n-\n-\tif (!digits_found)\n-\t  cpp_error (pfile, DL_ERROR,\n-\t\t       \"\\\\x used with no following hex digits\");\n-\n-\tif (overflow | (i != (i & mask)))\n-\t  {\n-\t    cpp_error (pfile, DL_PEDWARN,\n-\t\t       \"hex escape sequence out of range\");\n-\t    i &= mask;\n-\t  }\n-\tc = i;\n-      }\n-      break;\n-\n-    case '0':  case '1':  case '2':  case '3':\n-    case '4':  case '5':  case '6':  case '7':\n-      {\n-\tsize_t count = 0;\n-\tcppchar_t i = c - '0';\n-\n-\twhile (str < limit && ++count < 3)\n-\t  {\n-\t    c = *str;\n-\t    if (c < '0' || c > '7')\n-\t      break;\n-\t    str++;\n-\t    i = (i << 3) + c - '0';\n-\t  }\n-\n-\tif (i != (i & mask))\n-\t  {\n-\t    cpp_error (pfile, DL_PEDWARN,\n-\t\t       \"octal escape sequence out of range\");\n-\t    i &= mask;\n-\t  }\n-\tc = i;\n-      }\n-      break;\n-\n-    default:\n-      unknown = 1;\n-      break;\n-    }\n-\n-  if (unknown)\n-    {\n-      if (ISGRAPH (c))\n-\tcpp_error (pfile, DL_PEDWARN,\n-\t\t   \"unknown escape sequence '\\\\%c'\", (int) c);\n-      else\n-\tcpp_error (pfile, DL_PEDWARN,\n-\t\t   \"unknown escape sequence: '\\\\%03o'\", (int) c);\n-    }\n-\n-  if (c > mask)\n-    {\n-      cpp_error (pfile, DL_PEDWARN,\n-\t\t \"escape sequence out of range for its type\");\n-      c &= mask;\n-    }\n-\n-  *pstr = str;\n-  return c;\n-}\n-\n-/* Interpret a (possibly wide) character constant in TOKEN.\n-   WARN_MULTI warns about multi-character charconsts.  PCHARS_SEEN\n-   points to a variable that is filled in with the number of\n-   characters seen, and UNSIGNEDP to a variable that indicates whether\n-   the result has signed type.  */\n-cppchar_t\n-cpp_interpret_charconst (cpp_reader *pfile, const cpp_token *token,\n-\t\t\t unsigned int *pchars_seen, int *unsignedp)\n-{\n-  const unsigned char *str, *limit;\n-  unsigned int chars_seen = 0;\n-  size_t width, max_chars;\n-  cppchar_t c, mask, result = 0;\n-  bool unsigned_p;\n-\n-  str = token->val.str.text + 1 + (token->type == CPP_WCHAR);\n-  limit = token->val.str.text + token->val.str.len - 1;\n-\n-  if (token->type == CPP_CHAR)\n-    {\n-      width = CPP_OPTION (pfile, char_precision);\n-      max_chars = CPP_OPTION (pfile, int_precision) / width;\n-      unsigned_p = CPP_OPTION (pfile, unsigned_char);\n-    }\n-  else\n-    {\n-      width = CPP_OPTION (pfile, wchar_precision);\n-      max_chars = 1;\n-      unsigned_p = CPP_OPTION (pfile, unsigned_wchar);\n-    }\n-\n-  if (width < BITS_PER_CPPCHAR_T)\n-    mask = ((cppchar_t) 1 << width) - 1;\n-  else\n-    mask = ~0;\n-\n-  while (str < limit)\n-    {\n-      c = *str++;\n-\n-      if (c == '\\\\')\n-\tc = cpp_parse_escape (pfile, &str, limit, token->type == CPP_WCHAR);\n-\n-#ifdef MAP_CHARACTER\n-      if (ISPRINT (c))\n-\tc = MAP_CHARACTER (c);\n-#endif\n-\n-      chars_seen++;\n-\n-      /* Truncate the character, scale the result and merge the two.  */\n-      c &= mask;\n-      if (width < BITS_PER_CPPCHAR_T)\n-\tresult = (result << width) | c;\n-      else\n-\tresult = c;\n-    }\n-\n-  if (chars_seen == 0)\n-    cpp_error (pfile, DL_ERROR, \"empty character constant\");\n-  else if (chars_seen > 1)\n-    {\n-      /* Multichar charconsts are of type int and therefore signed.  */\n-      unsigned_p = 0;\n-\n-      if (chars_seen > max_chars)\n-\t{\n-\t  chars_seen = max_chars;\n-\t  cpp_error (pfile, DL_WARNING,\n-\t\t     \"character constant too long for its type\");\n-\t}\n-      else if (CPP_OPTION (pfile, warn_multichar))\n-\tcpp_error (pfile, DL_WARNING, \"multi-character character constant\");\n-    }\n-\n-  /* Sign-extend or truncate the constant to cppchar_t.  The value is\n-     in WIDTH bits, but for multi-char charconsts it's value is the\n-     full target type's width.  */\n-  if (chars_seen > 1)\n-    width *= max_chars;\n-  if (width < BITS_PER_CPPCHAR_T)\n-    {\n-      mask = ((cppchar_t) 1 << width) - 1;\n-      if (unsigned_p || !(result & (1 << (width - 1))))\n-\tresult &= mask;\n-      else\n-\tresult |= ~mask;\n-    }\n-\n-  *pchars_seen = chars_seen;\n-  *unsignedp = unsigned_p;\n-  return result;\n-}\n-\n /* Memory buffers.  Changing these three constants can have a dramatic\n    effect on performance.  The values here are reasonable defaults,\n    but might be tuned.  If you adjust them, be sure to test across a"}, {"sha": "2fac44e62fdaa92d830bb194baec6694b2ffd5ce", "filename": "gcc/cpplib.c", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -106,7 +106,6 @@ static char *glue_header_name (cpp_reader *);\n static const char *parse_include (cpp_reader *, int *);\n static void push_conditional (cpp_reader *, int, int, const cpp_hashnode *);\n static unsigned int read_flag (cpp_reader *, unsigned int);\n-static uchar *dequote_string (cpp_reader *, const uchar *, unsigned int);\n static int strtoul_for_line (const uchar *, unsigned int, unsigned long *);\n static void do_diagnostic (cpp_reader *, int, int);\n static cpp_hashnode *lex_macro_node (cpp_reader *);\n@@ -714,29 +713,6 @@ read_flag (cpp_reader *pfile, unsigned int last)\n   return 0;\n }\n \n-/* Subroutine of do_line and do_linemarker.  Returns a version of STR\n-   which has a NUL terminator and all escape sequences converted to\n-   their equivalents.  Temporary, hopefully.  */\n-static uchar *\n-dequote_string (cpp_reader *pfile, const uchar *str, unsigned int len)\n-{\n-  uchar *result = _cpp_unaligned_alloc (pfile, len + 1);\n-  uchar *dst = result;\n-  const uchar *limit = str + len;\n-  cppchar_t c;\n-\n-  while (str < limit)\n-    {\n-      c = *str++;\n-      if (c != '\\\\')\n-\t*dst++ = c;\n-      else\n-\t*dst++ = cpp_parse_escape (pfile, &str, limit, 0);\n-    }\n-  *dst++ = '\\0';\n-  return result;\n-}\n-\n /* Subroutine of do_line and do_linemarker.  Convert a number in STR,\n    of length LEN, to binary; store it in NUMP, and return 0 if the\n    number was well-formed, 1 if not.  Temporary, hopefully.  */\n@@ -757,6 +733,21 @@ strtoul_for_line (const uchar *str, unsigned int len, long unsigned int *nump)\n   return 0;\n }\n \n+/* Subroutine of do_line and do_linemarker.  Convert escape sequences\n+   in a string, but do not perform character set conversion.  */\n+static bool\n+interpret_string_notranslate (cpp_reader *pfile, const cpp_string *in,\n+\t\t\t      cpp_string *out)\n+{\n+  iconv_t save_narrow_cset_desc = pfile->narrow_cset_desc;\n+  bool retval;\n+\n+  pfile->narrow_cset_desc = (iconv_t) -1;\n+  retval = cpp_interpret_string (pfile, in, 1, out, false);\n+  pfile->narrow_cset_desc = save_narrow_cset_desc;\n+  return retval;\n+}\n+\n /* Interpret #line command.\n    Note that the filename string (if any) is a true string constant\n    (escapes are interpreted), unlike in #line.  */\n@@ -788,8 +779,9 @@ do_line (cpp_reader *pfile)\n   token = cpp_get_token (pfile);\n   if (token->type == CPP_STRING)\n     {\n-      new_file = (const char *) dequote_string (pfile, token->val.str.text + 1,\n-\t\t\t\t\t\ttoken->val.str.len - 2);\n+      cpp_string s = { 0, 0 };\n+      if (interpret_string_notranslate (pfile, &token->val.str, &s))\n+\tnew_file = (const char *)s.text;\n       check_eol (pfile);\n     }\n   else if (token->type != CPP_EOF)\n@@ -836,8 +828,10 @@ do_linemarker (cpp_reader *pfile)\n   token = cpp_get_token (pfile);\n   if (token->type == CPP_STRING)\n     {\n-      new_file = (const char *) dequote_string (pfile, token->val.str.text + 1,\n-\t\t\t\t\t\ttoken->val.str.len - 2);\n+      cpp_string s = { 0, 0 };\n+      if (interpret_string_notranslate (pfile, &token->val.str, &s))\n+\tnew_file = (const char *)s.text;\n+      \n       new_sysp = 0;\n       flag = read_flag (pfile, 0);\n       if (flag == 1)"}, {"sha": "fb3cc78ec67b8d1d574942660c9eaf92399ba165", "filename": "gcc/cpplib.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -124,6 +124,7 @@ struct file_name_map_list;\n   OP(CPP_ATSIGN,\t\"@\")  /* used in Objective-C */ \\\n \\\n   TK(CPP_NAME,\t\tSPELL_IDENT)\t/* word */\t\t\t\\\n+  TK(CPP_AT_NAME,       SPELL_IDENT)    /* @word - Objective-C */       \\\n   TK(CPP_NUMBER,\tSPELL_LITERAL)\t/* 34_be+ta  */\t\t\t\\\n \\\n   TK(CPP_CHAR,\t\tSPELL_LITERAL)\t/* 'char' */\t\t\t\\\n@@ -132,6 +133,7 @@ struct file_name_map_list;\n \\\n   TK(CPP_STRING,\tSPELL_LITERAL)\t/* \"string\" */\t\t\t\\\n   TK(CPP_WSTRING,\tSPELL_LITERAL)\t/* L\"string\" */\t\t\t\\\n+  TK(CPP_OBJC_STRING,   SPELL_LITERAL)  /* @\"string\" - Objective-C */\t\\\n   TK(CPP_HEADER_NAME,\tSPELL_LITERAL)\t/* <stdio.h> in #include */\t\\\n \\\n   TK(CPP_COMMENT,\tSPELL_LITERAL)\t/* Only if output comments.  */ \\\n@@ -332,6 +334,12 @@ struct cpp_options\n   /* True for traditional preprocessing.  */\n   unsigned char traditional;\n \n+  /* Holds the name of the target (execution) character set.  */\n+  const char *narrow_charset;\n+\n+  /* Holds the name of the target wide character set.  */\n+  const char *wide_charset;\n+\n   /* True to warn about precompiled header files we couldn't use.  */\n   bool warn_invalid_pch;\n \n@@ -364,8 +372,9 @@ struct cpp_options\n   /* True means chars (wide chars) are unsigned.  */\n   bool unsigned_char, unsigned_wchar;\n \n-  /* True if target is EBCDIC.  */\n-  bool EBCDIC;\n+  /* True if the most significant byte in a word has the lowest\n+     address in memory.  */\n+  bool bytes_big_endian;\n \n   /* Nonzero means __STDC__ should have the value 0 in system headers.  */\n   unsigned char stdc_0_in_system_headers;\n@@ -529,6 +538,9 @@ extern const char *cpp_read_main_file (cpp_reader *, const char *);\n /* Set up built-ins like __FILE__.  */\n extern void cpp_init_builtins (cpp_reader *, int);\n \n+/* Set up translation to the target character set.  */\n+extern void cpp_init_iconv (cpp_reader *);\n+\n /* Call this to finish preprocessing.  If you requested dependency\n    generation, pass an open stream to write the information to,\n    otherwise NULL.  It is your responsibility to close the stream.\n@@ -560,6 +572,10 @@ extern void _cpp_backup_tokens (cpp_reader *, unsigned int);\n /* Evaluate a CPP_CHAR or CPP_WCHAR token.  */\n extern cppchar_t cpp_interpret_charconst (cpp_reader *, const cpp_token *,\n \t\t\t\t\t  unsigned int *, int *);\n+/* Evaluate a vector of CPP_STRING or CPP_WSTRING tokens.  */\n+extern bool cpp_interpret_string (cpp_reader *,\n+\t\t\t\t  const cpp_string *, size_t,\n+\t\t\t\t  cpp_string *, bool);\n \n /* Used to register macros and assertions, perhaps from the command line.\n    The text is the same as the command line argument.  */"}, {"sha": "1cac7df0a9419476e30a80587457db8c657bace8", "filename": "gcc/cppucnid.h", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcppucnid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcppucnid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppucnid.h?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -0,0 +1,336 @@\n+/* Table of UCNs which are valid in identifiers.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+/* Automatically generated from cppucnid.tab, do not edit */\n+\n+/* This file reproduces the table in ISO/IEC 9899:1999 (C99) Annex\n+   D, which is itself a reproduction from ISO/IEC TR 10176:1998, and\n+   the similar table from ISO/IEC 14882:1988 (C++98) Annex E, which is\n+   a reproduction of ISO/IEC PDTR 10176.  Unfortunately these tables\n+   are not identical.  */\n+\n+#ifndef CPPUCNID_H\n+#define CPPUCNID_H\n+\n+#define C99 1\n+#define CXX 2\n+#define DIG 4\n+\n+struct ucnrange\n+{\n+  unsigned short lo, hi;\n+  unsigned short flags;\n+};\n+\n+static const struct ucnrange ucnranges[] = {\n+  { 0x00aa, 0x00aa,     C99     },  /* Latin */\n+  { 0x00b5, 0x00b5,     C99     },  /* Special characters */\n+  { 0x00b7, 0x00b7,     C99     },\n+  { 0x00ba, 0x00ba,     C99     },  /* Latin */\n+  { 0x00c0, 0x00d6, CXX|C99     },\n+  { 0x00d8, 0x00f6, CXX|C99     },\n+  { 0x00f8, 0x01f5, CXX|C99     },\n+  { 0x01fa, 0x0217, CXX|C99     },\n+  { 0x0250, 0x02a8, CXX|C99     },\n+  { 0x02b0, 0x02b8,     C99     },  /* Special characters */\n+  { 0x02bb, 0x02bb,     C99     },\n+  { 0x02bd, 0x02c1,     C99     },\n+  { 0x02d0, 0x02d1,     C99     },\n+  { 0x02e0, 0x02e4,     C99     },\n+  { 0x037a, 0x037a,     C99     },\n+  { 0x0384, 0x0384, CXX         },  /* Greek */\n+  { 0x0386, 0x0386,     C99     },\n+  { 0x0388, 0x038a, CXX|C99     },\n+  { 0x038c, 0x038c, CXX|C99     },\n+  { 0x038e, 0x03a1, CXX|C99     },\n+  { 0x03a3, 0x03ce, CXX|C99     },\n+  { 0x03d0, 0x03d6, CXX|C99     },\n+  { 0x03da, 0x03da, CXX|C99     },\n+  { 0x03dc, 0x03dc, CXX|C99     },\n+  { 0x03de, 0x03de, CXX|C99     },\n+  { 0x03e0, 0x03e0, CXX|C99     },\n+  { 0x03e2, 0x03f3, CXX|C99     },\n+  { 0x0401, 0x040c, CXX|C99     },  /* Cyrillic */\n+  { 0x040d, 0x040d, CXX         },\n+  { 0x040e, 0x040e,     C99     },\n+  { 0x040f, 0x044f, CXX|C99     },\n+  { 0x0451, 0x045c, CXX|C99     },\n+  { 0x045e, 0x0481, CXX|C99     },\n+  { 0x0490, 0x04c4, CXX|C99     },\n+  { 0x04c7, 0x04c8, CXX|C99     },\n+  { 0x04cb, 0x04cc, CXX|C99     },\n+  { 0x04d0, 0x04eb, CXX|C99     },\n+  { 0x04ee, 0x04f5, CXX|C99     },\n+  { 0x04f8, 0x04f9, CXX|C99     },\n+  { 0x0531, 0x0556, CXX|C99     },  /* Armenian */\n+  { 0x0559, 0x0559,     C99     },  /* Special characters */\n+  { 0x0561, 0x0587, CXX|C99     },  /* Armenian */\n+  { 0x05b0, 0x05b9,     C99     },  /* Hebrew */\n+  { 0x05bb, 0x05bd,     C99     },\n+  { 0x05bf, 0x05bf,     C99     },\n+  { 0x05c1, 0x05c2,     C99     },\n+  { 0x05d0, 0x05ea, CXX|C99     },\n+  { 0x05f0, 0x05f2, CXX|C99     },\n+  { 0x05f3, 0x05f4, CXX         },\n+  { 0x0621, 0x063a, CXX|C99     },  /* Arabic */\n+  { 0x0640, 0x0652, CXX|C99     },\n+  { 0x0660, 0x0669,     C99|DIG },  /* Digits */\n+  { 0x0670, 0x06b7, CXX|C99     },  /* Arabic */\n+  { 0x06ba, 0x06be, CXX|C99     },\n+  { 0x06c0, 0x06ce, CXX|C99     },\n+  { 0x06d0, 0x06dc,     C99     },\n+  { 0x06e5, 0x06e7, CXX|C99     },\n+  { 0x06e8, 0x06e8,     C99     },\n+  { 0x06ea, 0x06ed,     C99     },\n+  { 0x06f0, 0x06f9,     C99|DIG },  /* Digits */\n+  { 0x0901, 0x0903,     C99     },  /* Devanagari */\n+  { 0x0905, 0x0939, CXX|C99     },\n+  { 0x093d, 0x093d,     C99     },  /* Special characters */\n+  { 0x093e, 0x094d,     C99     },  /* Devanagari */\n+  { 0x0950, 0x0952,     C99     },\n+  { 0x0958, 0x0962, CXX|C99     },\n+  { 0x0963, 0x0963,     C99     },\n+  { 0x0966, 0x096f,     C99|DIG },  /* Digits */\n+  { 0x0981, 0x0983,     C99     },  /* Bengali */\n+  { 0x0985, 0x098c, CXX|C99     },\n+  { 0x098f, 0x0990, CXX|C99     },\n+  { 0x0993, 0x09a8, CXX|C99     },\n+  { 0x09aa, 0x09b0, CXX|C99     },\n+  { 0x09b2, 0x09b2, CXX|C99     },\n+  { 0x09b6, 0x09b9, CXX|C99     },\n+  { 0x09be, 0x09c4,     C99     },\n+  { 0x09c7, 0x09c8,     C99     },\n+  { 0x09cb, 0x09cd,     C99     },\n+  { 0x09dc, 0x09dd, CXX|C99     },\n+  { 0x09df, 0x09e1, CXX|C99     },\n+  { 0x09e2, 0x09e3,     C99     },\n+  { 0x09e6, 0x09ef,     C99|DIG },  /* Digits */\n+  { 0x09f0, 0x09f1, CXX|C99     },  /* Bengali */\n+  { 0x0a02, 0x0a02,     C99     },  /* Gurmukhi */\n+  { 0x0a05, 0x0a0a, CXX|C99     },\n+  { 0x0a0f, 0x0a10, CXX|C99     },\n+  { 0x0a13, 0x0a28, CXX|C99     },\n+  { 0x0a2a, 0x0a30, CXX|C99     },\n+  { 0x0a32, 0x0a33, CXX|C99     },\n+  { 0x0a35, 0x0a36, CXX|C99     },\n+  { 0x0a38, 0x0a39, CXX|C99     },\n+  { 0x0a3e, 0x0a42,     C99     },\n+  { 0x0a47, 0x0a48,     C99     },\n+  { 0x0a4b, 0x0a4d,     C99     },\n+  { 0x0a59, 0x0a5c, CXX|C99     },\n+  { 0x0a5e, 0x0a5e, CXX|C99     },\n+  { 0x0a66, 0x0a6f,     C99|DIG },  /* Digits */\n+  { 0x0a74, 0x0a74,     C99     },  /* Gurmukhi */\n+  { 0x0a81, 0x0a83,     C99     },  /* Gujarati */\n+  { 0x0a85, 0x0a8b, CXX|C99     },\n+  { 0x0a8d, 0x0a8d, CXX|C99     },\n+  { 0x0a8f, 0x0a91, CXX|C99     },\n+  { 0x0a93, 0x0aa8, CXX|C99     },\n+  { 0x0aaa, 0x0ab0, CXX|C99     },\n+  { 0x0ab2, 0x0ab3, CXX|C99     },\n+  { 0x0ab5, 0x0ab9, CXX|C99     },\n+  { 0x0abd, 0x0ac5,     C99     },\n+  { 0x0ac7, 0x0ac9,     C99     },\n+  { 0x0acb, 0x0acd,     C99     },\n+  { 0x0ad0, 0x0ad0,     C99     },\n+  { 0x0ae0, 0x0ae0, CXX|C99     },\n+  { 0x0ae6, 0x0aef,     C99|DIG },  /* Digits */\n+  { 0x0b01, 0x0b03,     C99     },  /* Oriya */\n+  { 0x0b05, 0x0b0c, CXX|C99     },\n+  { 0x0b0f, 0x0b10, CXX|C99     },\n+  { 0x0b13, 0x0b28, CXX|C99     },\n+  { 0x0b2a, 0x0b30, CXX|C99     },\n+  { 0x0b32, 0x0b33, CXX|C99     },\n+  { 0x0b36, 0x0b39, CXX|C99     },\n+  { 0x0b3d, 0x0b3d,     C99     },  /* Special characters */\n+  { 0x0b3e, 0x0b43,     C99     },  /* Oriya */\n+  { 0x0b47, 0x0b48,     C99     },\n+  { 0x0b4b, 0x0b4d,     C99     },\n+  { 0x0b5c, 0x0b5d, CXX|C99     },\n+  { 0x0b5f, 0x0b61, CXX|C99     },\n+  { 0x0b66, 0x0b6f,     C99|DIG },  /* Digits */\n+  { 0x0b82, 0x0b83,     C99     },  /* Tamil */\n+  { 0x0b85, 0x0b8a, CXX|C99     },\n+  { 0x0b8e, 0x0b90, CXX|C99     },\n+  { 0x0b92, 0x0b95, CXX|C99     },\n+  { 0x0b99, 0x0b9a, CXX|C99     },\n+  { 0x0b9c, 0x0b9c, CXX|C99     },\n+  { 0x0b9e, 0x0b9f, CXX|C99     },\n+  { 0x0ba3, 0x0ba4, CXX|C99     },\n+  { 0x0ba8, 0x0baa, CXX|C99     },\n+  { 0x0bae, 0x0bb5, CXX|C99     },\n+  { 0x0bb7, 0x0bb9, CXX|C99     },\n+  { 0x0bbe, 0x0bc2,     C99     },\n+  { 0x0bc6, 0x0bc8,     C99     },\n+  { 0x0bca, 0x0bcd,     C99     },\n+  { 0x0be7, 0x0bef,     C99|DIG },  /* Digits */\n+  { 0x0c01, 0x0c03,     C99     },  /* Telugu */\n+  { 0x0c05, 0x0c0c, CXX|C99     },\n+  { 0x0c0e, 0x0c10, CXX|C99     },\n+  { 0x0c12, 0x0c28, CXX|C99     },\n+  { 0x0c2a, 0x0c33, CXX|C99     },\n+  { 0x0c35, 0x0c39, CXX|C99     },\n+  { 0x0c3e, 0x0c44,     C99     },\n+  { 0x0c46, 0x0c48,     C99     },\n+  { 0x0c4a, 0x0c4d,     C99     },\n+  { 0x0c60, 0x0c61, CXX|C99     },\n+  { 0x0c66, 0x0c6f,     C99|DIG },  /* Digits */\n+  { 0x0c82, 0x0c83,     C99     },  /* Kannada */\n+  { 0x0c85, 0x0c8c, CXX|C99     },\n+  { 0x0c8e, 0x0c90, CXX|C99     },\n+  { 0x0c92, 0x0ca8, CXX|C99     },\n+  { 0x0caa, 0x0cb3, CXX|C99     },\n+  { 0x0cb5, 0x0cb9, CXX|C99     },\n+  { 0x0cbe, 0x0cc4,     C99     },\n+  { 0x0cc6, 0x0cc8,     C99     },\n+  { 0x0cca, 0x0ccd,     C99     },\n+  { 0x0cde, 0x0cde,     C99     },\n+  { 0x0ce0, 0x0ce1, CXX|C99     },\n+  { 0x0ce6, 0x0cef,     C99|DIG },  /* Digits */\n+  { 0x0d02, 0x0d03,     C99     },  /* Malayalam */\n+  { 0x0d05, 0x0d0c, CXX|C99     },\n+  { 0x0d0e, 0x0d10, CXX|C99     },\n+  { 0x0d12, 0x0d28, CXX|C99     },\n+  { 0x0d2a, 0x0d39, CXX|C99     },\n+  { 0x0d3e, 0x0d43,     C99     },\n+  { 0x0d46, 0x0d48,     C99     },\n+  { 0x0d4a, 0x0d4d,     C99     },\n+  { 0x0d60, 0x0d61, CXX|C99     },\n+  { 0x0d66, 0x0d6f,     C99|DIG },  /* Digits */\n+  { 0x0e01, 0x0e30, CXX|C99     },  /* Thai */\n+  { 0x0e31, 0x0e31,     C99     },\n+  { 0x0e32, 0x0e33, CXX|C99     },\n+  { 0x0e34, 0x0e3a,     C99     },\n+  { 0x0e40, 0x0e46, CXX|C99     },\n+  { 0x0e47, 0x0e49,     C99     },\n+  { 0x0e50, 0x0e59, CXX|C99|DIG },  /* Digits */\n+  { 0x0e5a, 0x0e5b, CXX|C99     },  /* Thai */\n+  { 0x0e81, 0x0e82, CXX|C99     },  /* Lao */\n+  { 0x0e84, 0x0e84, CXX|C99     },\n+  { 0x0e87, 0x0e88, CXX|C99     },\n+  { 0x0e8a, 0x0e8a, CXX|C99     },\n+  { 0x0e8d, 0x0e8d, CXX|C99     },\n+  { 0x0e94, 0x0e97, CXX|C99     },\n+  { 0x0e99, 0x0e9f, CXX|C99     },\n+  { 0x0ea1, 0x0ea3, CXX|C99     },\n+  { 0x0ea5, 0x0ea5, CXX|C99     },\n+  { 0x0ea7, 0x0ea7, CXX|C99     },\n+  { 0x0eaa, 0x0eab, CXX|C99     },\n+  { 0x0ead, 0x0eae, CXX|C99     },\n+  { 0x0eaf, 0x0eaf, CXX         },\n+  { 0x0eb0, 0x0eb0, CXX|C99     },\n+  { 0x0eb1, 0x0eb1,     C99     },\n+  { 0x0eb2, 0x0eb3, CXX|C99     },\n+  { 0x0eb4, 0x0eb9,     C99     },\n+  { 0x0ebb, 0x0ebc,     C99     },\n+  { 0x0ebd, 0x0ebd, CXX|C99     },\n+  { 0x0ec0, 0x0ec4, CXX|C99     },\n+  { 0x0ec6, 0x0ec6, CXX|C99     },\n+  { 0x0ec8, 0x0ecd,     C99     },\n+  { 0x0ed0, 0x0ed9,     C99|DIG },  /* Digits */\n+  { 0x0edc, 0x0edd,     C99     },  /* Lao */\n+  { 0x0f00, 0x0f00,     C99     },  /* Tibetan */\n+  { 0x0f18, 0x0f19,     C99     },\n+  { 0x0f20, 0x0f33,     C99|DIG },  /* Digits */\n+  { 0x0f35, 0x0f35,     C99     },  /* Tibetan */\n+  { 0x0f37, 0x0f37,     C99     },\n+  { 0x0f39, 0x0f39,     C99     },\n+  { 0x0f3e, 0x0f47,     C99     },\n+  { 0x0f49, 0x0f69,     C99     },\n+  { 0x0f71, 0x0f84,     C99     },\n+  { 0x0f86, 0x0f8b,     C99     },\n+  { 0x0f90, 0x0f95,     C99     },\n+  { 0x0f97, 0x0f97,     C99     },\n+  { 0x0f99, 0x0fad,     C99     },\n+  { 0x0fb1, 0x0fb7,     C99     },\n+  { 0x0fb9, 0x0fb9,     C99     },\n+  { 0x10a0, 0x10c5, CXX|C99     },  /* Georgian */\n+  { 0x10d0, 0x10f6, CXX|C99     },\n+  { 0x1100, 0x1159, CXX         },  /* Hangul */\n+  { 0x1161, 0x11a2, CXX         },\n+  { 0x11a8, 0x11f9, CXX         },\n+  { 0x1e00, 0x1e9a, CXX|C99     },  /* Latin */\n+  { 0x1e9b, 0x1e9b,     C99     },\n+  { 0x1ea0, 0x1ef9, CXX|C99     },\n+  { 0x1f00, 0x1f15, CXX|C99     },  /* Greek */\n+  { 0x1f18, 0x1f1d, CXX|C99     },\n+  { 0x1f20, 0x1f45, CXX|C99     },\n+  { 0x1f48, 0x1f4d, CXX|C99     },\n+  { 0x1f50, 0x1f57, CXX|C99     },\n+  { 0x1f59, 0x1f59, CXX|C99     },\n+  { 0x1f5b, 0x1f5b, CXX|C99     },\n+  { 0x1f5d, 0x1f5d, CXX|C99     },\n+  { 0x1f5f, 0x1f7d, CXX|C99     },\n+  { 0x1f80, 0x1fb4, CXX|C99     },\n+  { 0x1fb6, 0x1fbc, CXX|C99     },\n+  { 0x1fbe, 0x1fbe,     C99     },  /* Special characters */\n+  { 0x1fc2, 0x1fc4, CXX|C99     },  /* Greek */\n+  { 0x1fc6, 0x1fcc, CXX|C99     },\n+  { 0x1fd0, 0x1fd3, CXX|C99     },\n+  { 0x1fd6, 0x1fdb, CXX|C99     },\n+  { 0x1fe0, 0x1fec, CXX|C99     },\n+  { 0x1ff2, 0x1ff4, CXX|C99     },\n+  { 0x1ff6, 0x1ffc, CXX|C99     },\n+  { 0x203f, 0x2040,     C99     },  /* Special characters */\n+  { 0x207f, 0x207f,     C99     },  /* Latin */\n+  { 0x2102, 0x2102,     C99     },  /* Special characters */\n+  { 0x2107, 0x2107,     C99     },\n+  { 0x210a, 0x2113,     C99     },\n+  { 0x2115, 0x2115,     C99     },\n+  { 0x2118, 0x211d,     C99     },\n+  { 0x2124, 0x2124,     C99     },\n+  { 0x2126, 0x2126,     C99     },\n+  { 0x2128, 0x2128,     C99     },\n+  { 0x212a, 0x2131,     C99     },\n+  { 0x2133, 0x2138,     C99     },\n+  { 0x2160, 0x2182,     C99     },\n+  { 0x3005, 0x3007,     C99     },\n+  { 0x3021, 0x3029,     C99     },\n+  { 0x3041, 0x3093, CXX|C99     },  /* Hiragana */\n+  { 0x3094, 0x3094, CXX         },\n+  { 0x309b, 0x309c, CXX|C99     },\n+  { 0x309d, 0x309e, CXX         },\n+  { 0x30a1, 0x30f6, CXX|C99     },  /* Katakana */\n+  { 0x30f7, 0x30fa, CXX         },\n+  { 0x30fb, 0x30fc, CXX|C99     },\n+  { 0x30fd, 0x30fe, CXX         },\n+  { 0x3105, 0x312c, CXX|C99     },  /* Bopomofo */\n+  { 0x4e00, 0x9fa5, CXX|C99     },  /* CJK Unified Ideographs */\n+  { 0xac00, 0xd7a3,     C99     },  /* Hangul */\n+  { 0xf900, 0xfa2d, CXX         },  /* CJK Unified Ideographs */\n+  { 0xfb1f, 0xfb36, CXX         },\n+  { 0xfb38, 0xfb3c, CXX         },\n+  { 0xfb3e, 0xfb3e, CXX         },\n+  { 0xfb40, 0xfb44, CXX         },\n+  { 0xfb46, 0xfbb1, CXX         },\n+  { 0xfbd3, 0xfd3f, CXX         },\n+  { 0xfd50, 0xfd8f, CXX         },\n+  { 0xfd92, 0xfdc7, CXX         },\n+  { 0xfdf0, 0xfdfb, CXX         },\n+  { 0xfe70, 0xfe72, CXX         },\n+  { 0xfe74, 0xfe74, CXX         },\n+  { 0xfe76, 0xfefc, CXX         },\n+  { 0xff21, 0xff3a, CXX         },\n+  { 0xff41, 0xff5a, CXX         },\n+  { 0xff66, 0xffbe, CXX         },\n+  { 0xffc2, 0xffc7, CXX         },\n+  { 0xffca, 0xffcf, CXX         },\n+  { 0xffd2, 0xffd7, CXX         },\n+  { 0xffda, 0xffdc, CXX         },\n+};\n+\n+#endif /* cppucnid.h */"}, {"sha": "eb8bbcac627ba974746569fff26a6be3e371b4ab", "filename": "gcc/cppucnid.pl", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcppucnid.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcppucnid.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppucnid.pl?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -0,0 +1,130 @@\n+#! /usr/bin/perl -w\n+use strict;\n+\n+# Convert cppucnid.tab to cppucnid.h.  We use two arrays of length\n+# 65536 to represent the table, since this is nice and simple.  The\n+# first array holds the tags indicating which ranges are valid in\n+# which contexts.  The second array holds the language name associated\n+# with each element.\n+\n+our(@tags, @names);\n+@tags = (\"\") x 65536;\n+@names = (\"\") x 65536;\n+\n+\n+# Array mapping tag numbers to standard #defines\n+our @stds;\n+\n+# Current standard and language\n+our($curstd, $curlang);\n+\n+# First block of the file is a template to be saved for later.\n+our @template;\n+\n+while (<>) {\n+    chomp;\n+    last if $_ eq '%%';\n+    push @template, $_;\n+};\n+\n+# Second block of the file is the UCN tables.\n+# The format looks like this:\n+#\n+# [std]\n+#\n+# ; language\n+# xxxx-xxxx xxxx xxxx-xxxx ....\n+#\n+# with comment lines starting with #.\n+\n+while (<>) {\n+    chomp;\n+    /^#/ and next;\n+    /^\\s*$/ and next;\n+    /^\\[(.+)\\]$/ and do {\n+\t$curstd = $1;\n+ \tnext;\n+    };\n+    /^; (.+)$/ and do {\n+\t$curlang = $1;\n+\tnext;\n+    };\n+\n+    process_range(split);\n+}\n+\n+# Print out the template, inserting as requested.\n+$\\ = \"\\n\";\n+for (@template) {\n+    print(\"/* Automatically generated from cppucnid.tab, do not edit */\"),\n+        next if $_ eq \"[dne]\";\n+    print_table(), next if $_ eq \"[table]\";\n+    print;\n+}\n+\n+sub print_table {\n+    my($lo, $hi);\n+    my $prevname = \"\";\n+\n+    for ($lo = 0; $lo <= $#tags; $lo = $hi) {\n+\t$hi = $lo;\n+\t$hi++ while $hi <= $#tags\n+\t    && $tags[$hi] eq $tags[$lo]\n+\t    && $names[$hi] eq $names[$lo];\n+\n+\t# Range from $lo to $hi-1.\n+\t# Don't make entries for ranges that are not valid idchars.\n+\tnext if ($tags[$lo] eq \"\");\n+\tmy $tag = $tags[$lo];\n+        $tag = \"    \".$tag if $tag =~ /^C99/;\n+\n+\tif ($names[$lo] eq $prevname) {\n+\t    printf(\"  { 0x%04x, 0x%04x, %-11s },\\n\",\n+\t\t   $lo, $hi-1, $tag);\n+\t} else {\n+\t    printf(\"  { 0x%04x, 0x%04x, %-11s },  /* %s */\\n\",\n+\t\t   $lo, $hi-1, $tag, $names[$lo]);\n+\t}\n+\t$prevname = $names[$lo];\n+    }\n+}\n+\n+# The line is a list of four-digit hexadecimal numbers or\n+# pairs of such numbers.  Each is a valid identifier character\n+# from the given language, under the given standard.\n+sub process_range {\n+    for my $range (@_) {\n+\tif ($range =~ /^[0-9a-f]{4}$/) {\n+\t    my $i = hex($range);\n+\t    if ($tags[$i] eq \"\") {\n+\t\t$tags[$i] = $curstd;\n+\t    } else {\n+\t\t$tags[$i] = $curstd . \"|\" . $tags[$i];\n+\t    }\n+\t    if ($names[$i] ne \"\" && $names[$i] ne $curlang) {\n+\t\twarn sprintf (\"language overlap: %s/%s at %x (tag %d)\",\n+\t\t\t      $names[$i], $curlang, $i, $tags[$i]);\n+\t\tnext;\n+\t    }\n+\t    $names[$i] = $curlang;\n+\t} elsif ($range =~ /^ ([0-9a-f]{4}) - ([0-9a-f]{4}) $/x) {\n+\t    my ($start, $end) = (hex($1), hex($2));\n+\t    my $i;\n+\t    for ($i = $start; $i <= $end; $i++) {\n+\t\tif ($tags[$i] eq \"\") {\n+\t\t    $tags[$i] = $curstd;\n+\t\t} else {\n+\t\t    $tags[$i] = $curstd . \"|\" . $tags[$i];\n+\t\t}\n+\t\tif ($names[$i] ne \"\" && $names[$i] ne $curlang) {\n+\t\t    warn sprintf (\"language overlap: %s/%s at %x (tag %d)\",\n+\t\t\t\t  $names[$i], $curlang, $i, $tags[$i]);\n+\t\t    next;\n+\t\t}\n+\t\t$names[$i] = $curlang;\n+\t    }\n+\t} else {\n+\t    warn \"malformed range expression $range\";\n+\t}\n+    }\n+}"}, {"sha": "4a7a0f4094cfb641eb82178737d44fbf2f428ebc", "filename": "gcc/cppucnid.tab", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcppucnid.tab", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fcppucnid.tab", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppucnid.tab?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -0,0 +1,239 @@\n+/* Table of UCNs which are valid in identifiers.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+[dne]\n+\n+/* This file reproduces the table in ISO/IEC 9899:1999 (C99) Annex\n+   D, which is itself a reproduction from ISO/IEC TR 10176:1998, and\n+   the similar table from ISO/IEC 14882:1988 (C++98) Annex E, which is\n+   a reproduction of ISO/IEC PDTR 10176.  Unfortunately these tables\n+   are not identical.  */\n+\n+#ifndef CPPUCNID_H\n+#define CPPUCNID_H\n+\n+#define C99 1\n+#define CXX 2\n+#define DIG 4\n+\n+struct ucnrange\n+{\n+  unsigned short lo, hi;\n+  unsigned short flags;\n+};\n+\n+static const struct ucnrange ucnranges[] = {\n+[table]\n+};\n+\n+#endif /* cppucnid.h */\n+%%\n+\n+[C99]\n+\n+; Latin\n+00aa 00ba 00c0-00d6 00d8-00f6 00f8-01f5 01fa-0217 0250-02a8 1e00-1e9b\n+1ea0-1ef9 207f\n+\n+; Greek\n+0386 0388-038a 038c 038e-03a1 03a3-03ce 03d0-03d6 03da 03dc 03de 03e0\n+03e2-03f3 1f00-1f15 1f18-1f1d 1f20-1f45 1f48-1f4d 1f50-1f57 1f59 1f5b\n+1f5d 1f5f-1f7d 1f80-1fb4 1fb6-1fbc 1fc2-1fc4 1fc6-1fcc 1fd0-1fd3\n+1fd6-1fdb 1fe0-1fec 1ff2-1ff4 1ff6-1ffc\n+\n+; Cyrillic\n+0401-040c 040e-044f 0451-045c 045e-0481 0490-04c4 04c7-04c8 04cb-04cc\n+04d0-04eb 04ee-04f5 04f8-04f9\n+\n+; Armenian\n+0531-0556 0561-0587\n+\n+; Hebrew\n+05b0-05b9 05bb-05bd 05bf 05c1-05c2 05d0-05ea 05f0-05f2\n+\n+; Arabic\n+0621-063a 0640-0652 0670-06b7 06ba-06be 06c0-06ce 06d0-06dc 06e5-06e8\n+06ea-06ed\n+\n+; Devanagari\n+0901-0903 0905-0939 093e-094d 0950-0952 0958-0963\n+\n+; Bengali\n+0981-0983 0985-098c 098f-0990 0993-09a8 09aa-09b0 09b2 09b6-09b9\n+09be-09c4 09c7-09c8 09cb-09cd 09dc-09dd 09df-09e3 09f0-09f1\n+\n+; Gurmukhi\n+0a02 0a05-0a0a 0a0f-0a10 0a13-0a28 0a2a-0a30 0a32-0a33 0a35-0a36\n+0a38-0a39 0a3e-0a42 0a47-0a48 0a4b-0a4d 0a59-0a5c 0a5e 0a74\n+\n+; Gujarati\n+0a81-0a83 0a85-0a8b 0a8d 0a8f-0a91 0a93-0aa8 0aaa-0ab0 0ab2-0ab3\n+0ab5-0ab9 0abd-0ac5 0ac7-0ac9 0acb-0acd 0ad0 0ae0\n+\n+; Oriya\n+0b01-0b03 0b05-0b0c 0b0f-0b10 0b13-0b28 0b2a-0b30 0b32-0b33 0b36-0b39\n+0b3e-0b43 0b47-0b48 0b4b-0b4d 0b5c-0b5d 0b5f-0b61\n+\n+; Tamil\n+0b82-0b83 0b85-0b8a 0b8e-0b90 0b92-0b95 0b99-0b9a 0b9c 0b9e-0b9f\n+0ba3-0ba4 0ba8-0baa 0bae-0bb5 0bb7-0bb9 0bbe-0bc2 0bc6-0bc8 0bca-0bcd\n+\n+; Telugu\n+0c01-0c03 0c05-0c0c 0c0e-0c10 0c12-0c28 0c2a-0c33 0c35-0c39 0c3e-0c44\n+0c46-0c48 0c4a-0c4d 0c60-0c61\n+\n+; Kannada\n+0c82-0c83 0c85-0c8c 0c8e-0c90 0c92-0ca8 0caa-0cb3 0cb5-0cb9 0cbe-0cc4\n+0cc6-0cc8 0cca-0ccd 0cde 0ce0-0ce1\n+\n+; Malayalam\n+0d02-0d03 0d05-0d0c 0d0e-0d10 0d12-0d28 0d2a-0d39 0d3e-0d43 0d46-0d48\n+0d4a-0d4d 0d60-0d61\n+\n+# CORRECTION: exclude 0e50-0e59 from the Thai range as it also appears\n+# in the Digits range below.\n+; Thai\n+0e01-0e3a 0e40-0e49 0e5a-0e5b\n+\n+; Lao\n+0e81-0e82 0e84 0e87-0e88 0e8a 0e8d 0e94-0e97 0e99-0e9f 0ea1-0ea3 0ea5\n+0ea7 0eaa-0eab 0ead-0eae 0eb0-0eb9 0ebb-0ebd 0ec0-0ec4 0ec6 0ec8-0ecd\n+0edc-0edd\n+\n+; Tibetan\n+0f00 0f18-0f19 0f35 0f37 0f39 0f3e-0f47 0f49-0f69 0f71-0f84 0f86-0f8b\n+0f90-0f95 0f97 0f99-0fad 0fb1-0fb7 0fb9\n+\n+; Georgian\n+10a0-10c5 10d0-10f6\n+\n+; Hiragana\n+3041-3093 309b-309c\n+\n+; Katakana\n+30a1-30f6 30fb-30fc\n+\n+; Bopomofo\n+3105-312c\n+\n+; CJK Unified Ideographs\n+4e00-9fa5\n+\n+; Hangul\n+ac00-d7a3\n+\n+; Special characters\n+00b5 00b7 02b0-02b8 02bb 02bd-02c1 02d0-02d1 02e0-02e4 037a 0559 093d\n+0b3d 1fbe 203f-2040 2102 2107 210a-2113 2115 2118-211d 2124 2126 2128\n+212a-2131 2133-2138 2160-2182 3005-3007 3021-3029\n+\n+[C99|DIG]\n+; Digits\n+0660-0669 06f0-06f9 0966-096f 09e6-09ef 0a66-0a6f 0ae6-0aef 0b66-0b6f\n+0be7-0bef 0c66-0c6f 0ce6-0cef 0d66-0d6f 0e50-0e59 0ed0-0ed9 0f20-0f33\n+\n+[CXX]\n+\n+; Latin\n+00c0-00d6 00d8-00f6 00f8-01f5 01fa-0217 0250-02a8 1e00-1e9a 1ea0-1ef9\n+\n+; Greek\n+0384 0388-038a 038c 038e-03a1 03a3-03ce 03d0-03d6 03da 03dc 03de 03e0 \n+03e2-03f3 1f00-1f15 1f18-1f1d 1f20-1f45 1f48-1f4d 1f50-1f57 1f59 1f5b\n+1f5d 1f5f-1f7d 1f80-1fb4 1fb6-1fbc 1fc2-1fc4 1fc6-1fcc 1fd0-1fd3 \n+1fd6-1fdb 1fe0-1fec 1ff2-1ff4 1ff6-1ffc\n+\n+; Cyrillic\n+0401-040d 040f-044f 0451-045c 045e-0481 0490-04c4 04c7-04c8 04cb-04cc\n+04d0-04eb 04ee-04f5 04f8-04f9\n+\n+; Armenian\n+0531-0556 0561-0587\n+\n+; Hebrew\n+05d0-05ea 05f0-05f4\n+\n+; Arabic\n+0621-063a 0640-0652 0670-06b7 06ba-06be 06c0-06ce 06e5-06e7\n+\n+; Devanagari\n+0905-0939 0958-0962\n+\n+; Bengali\n+0985-098c 098f-0990 0993-09a8 09aa-09b0 09b2 09b6-09b9 09dc-09dd \n+09df-09e1 09f0-09f1\n+\n+; Gurmukhi\n+0a05-0a0a 0a0f-0a10 0a13-0a28 0a2a-0a30 0a32-0a33 0a35-0a36 0a38-0a39\n+0a59-0a5c 0a5e\n+\n+; Gujarati\n+0a85-0a8b 0a8d 0a8f-0a91 0a93-0aa8 0aaa-0ab0 0ab2-0ab3 0ab5-0ab9 0ae0\n+\n+; Oriya\n+0b05-0b0c 0b0f-0b10 0b13-0b28 0b2a-0b30 0b32-0b33 0b36-0b39 0b5c-0b5d\n+0b5f-0b61\n+\n+; Tamil\n+0b85-0b8a 0b8e-0b90 0b92-0b95 0b99-0b9a 0b9c 0b9e-0b9f 0ba3-0ba4 \n+0ba8-0baa 0bae-0bb5 0bb7-0bb9\n+\n+; Telugu\n+0c05-0c0c 0c0e-0c10 0c12-0c28 0c2a-0c33 0c35-0c39 0c60-0c61\n+\n+; Kannada\n+0c85-0c8c 0c8e-0c90 0c92-0ca8 0caa-0cb3 0cb5-0cb9 0ce0-0ce1\n+\n+; Malayalam\n+0d05-0d0c 0d0e-0d10 0d12-0d28 0d2a-0d39 0d60-0d61\n+\n+# CORRECTION: Exclude 0e50-0e59 from the Thai range and make a fake\n+# Digits range for it, to match C99.  cppcharset.c knows that C++\n+# doesn't distinguish digits from other UCNs valid in identifiers.\n+; Thai\n+0e01-0e30 0e32-0e33 0e40-0e46 0e4f-0e49 0e5a-0e5b\n+\n+; Digits\n+0e50-0e59\n+\n+# CORRECTION: Change 0e0d to 0e8d (typo in standard; see C++ DR 131)\n+; Lao\n+0e81-0e82 0e84 0e87-0e88 0e8a 0e8d 0e94-0e97 0e99-0e9f 0ea1-0ea3 0ea5\n+0ea7 0eaa-0eab 0ead-0eb0 0eb2 0eb3 0ebd 0ec0-0ec4 0ec6\n+\n+; Georgian\n+10a0-10c5 10d0-10f6\n+\n+; Hiragana\n+3041-3094 309b-309e\n+\n+; Katakana\n+30a1-30fe\n+\n+# CORRECTION: language spelled \"Bopmofo\" in C++98.\n+; Bopomofo\n+3105-312c\n+\n+; Hangul\n+1100-1159 1161-11a2 11a8-11f9\n+\n+; CJK Unified Ideographs\n+f900-fa2d fb1f-fb36 fb38-fb3c fb3e fb40-fb41 fb42-fb44 fb46-fbb1\n+fbd3-fd3f fd50-fd8f fd92-fdc7 fdf0-fdfb fe70-fe72 fe74 fe76-fefc\n+ff21-ff3a ff41-ff5a ff66-ffbe ffc2-ffc7 ffca-ffcf ffd2-ffd7\n+ffda-ffdc 4e00-9fa5\n+"}, {"sha": "c043b88b9ee7fe65c925ca308f3a50ae9cae254c", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 66, "deletions": 20, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -104,6 +104,7 @@ useful on its own.\n \n Overview\n \n+* Character sets::\n * Initial processing::\n * Tokenization::\n * The preprocessing language::\n@@ -233,11 +234,62 @@ manual refer to GNU CPP.\n @c man end\n \n @menu\n+* Character sets::\n * Initial processing::\n * Tokenization::\n * The preprocessing language::\n @end menu\n \n+@node Character sets\n+@section Character sets\n+\n+Source code character set processing in C and related languages is\n+rather complicated.  The C standard discusses two character sets, but\n+there are really at least four.\n+\n+The files input to CPP might be in any character set at all.  CPP's\n+very first action, before it even looks for line boundaries, is to\n+convert the file into the character set it uses for internal\n+processing.  That set is what the C standard calls the @dfn{source}\n+character set.  It must be isomorphic with ISO 10646, also known as\n+Unicode.  CPP uses the UTF-8 encoding of Unicode.\n+\n+At present, GNU CPP does not implement conversion from arbitrary file\n+encodings to the source character set.  Use of any encoding other than\n+plain ASCII or UTF-8, except in comments, will cause errors.  Use of\n+encodings that are not strict supersets of ASCII, such as Shift JIS,\n+may cause errors even if non-ASCII characters appear only in comments. \n+We plan to fix this in the near future.\n+\n+All preprocessing work (the subject of the rest of this manual) is\n+carried out in the source character set.  If you request textual\n+output from the preprocessor with the @option{-E} option, it will be\n+in UTF-8.\n+\n+After preprocessing is complete, string and character constants are\n+converted again, into the @dfn{execution} character set.  This\n+character set is under control of the user; the default is UTF-8,\n+matching the source character set.  Wide string and character\n+constants have their own character set, which is not called out\n+specifically in the standard.  Again, it is under control of the user.\n+The default is UTF-16 or UTF-32, whichever fits in the target's\n+@code{wchar_t} type, in the target machine's byte\n+order.@footnote{UTF-16 does not meet the requirements of the C\n+standard for a wide character set, but the choice of 16-bit\n+@code{wchar_t} is enshrined in some system ABIs so we cannot fix\n+this.}  Octal and hexadecimal escape sequences do not undergo\n+conversion; @t{'\\x12'} has the value 0x12 regardless of the currently\n+selected execution character set.  All other escapes are replaced by\n+the character in the source character set that they represent, then\n+converted to the execution character set, just like unescaped\n+characters.\n+\n+GCC does not permit the use of characters outside the ASCII range, nor\n+@samp{\\u} and @samp{\\U} escapes, in identifiers.  We hope this will\n+change eventually, but there are problems with the standard semantics\n+of such ``extended identifiers'' which must be resolved through the\n+ISO C and C++ committees first.\n+\n @node Initial processing\n @section Initial processing\n \n@@ -251,27 +303,19 @@ standard.\n \n @enumerate\n @item\n-@cindex character sets\n @cindex line endings\n The input file is read into memory and broken into lines.\n \n-CPP expects its input to be a text file, that is, an unstructured\n-stream of ASCII characters, with some characters indicating the end of a\n-line of text.  Extended ASCII character sets, such as ISO Latin-1 or\n-Unicode encoded in UTF-8, are also acceptable.  Character sets that are\n-not strict supersets of seven-bit ASCII will not work.  We plan to add\n-complete support for international character sets in a future release.\n-\n Different systems use different conventions to indicate the end of a\n line.  GCC accepts the ASCII control sequences @kbd{LF}, @kbd{@w{CR\n-LF}} and @kbd{CR} as end-of-line markers.  These\n-are the canonical sequences used by Unix, DOS and VMS, and the\n-classic Mac OS (before OSX) respectively.  You may therefore safely copy\n-source code written on any of those systems to a different one and use\n-it without conversion.  (GCC may lose track of the current line number\n-if a file doesn't consistently use one convention, as sometimes happens\n-when it is edited on computers with different conventions that share a\n-network file system.)\n+LF}} and @kbd{CR} as end-of-line markers.  These are the canonical\n+sequences used by Unix, DOS and VMS, and the classic Mac OS (before\n+OSX) respectively.  You may therefore safely copy source code written\n+on any of those systems to a different one and use it without\n+conversion.  (GCC may lose track of the current line number if a file\n+doesn't consistently use one convention, as sometimes happens when it\n+is edited on computers with different conventions that share a network\n+file system.)\n \n If the last line of any input file lacks an end-of-line marker, the end\n of the file is considered to implicitly supply one.  The C standard says\n@@ -378,8 +422,9 @@ comment.\n @end group\n @end example\n \n-Comments are not recognized within string literals.  @t{@w{\"/* blah\n-*/\"}} is the string constant @samp{@w{/* blah */}}, not an empty string.\n+Comments are not recognized within string literals.  \n+@t{@w{\"/* blah */\"}} is the string constant @samp{@w{/* blah */}}, not\n+an empty string.\n \n Line comments are not in the 1989 edition of the C standard, but they\n are recognized by GCC as an extension.  In C++ and in the 1999 edition\n@@ -3706,8 +3751,9 @@ and stick to it.\n @item The mapping of physical source file multi-byte characters to the\n execution character set.\n \n-Currently, GNU cpp only supports character sets that are strict supersets\n-of ASCII, and performs no translation of characters.\n+Currently, CPP requires its input to be ASCII or UTF-8.  The execution\n+character set may be controlled by the user, with the\n+@code{-ftarget-charset} and @code{-ftarget-wide-charset} options.\n \n @item Identifier characters.\n @anchor{Identifier characters}"}, {"sha": "8096763e6edded34d695f7301d18b9f9d585db7d", "filename": "gcc/doc/cppopts.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fdoc%2Fcppopts.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fdoc%2Fcppopts.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcppopts.texi?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -498,6 +498,21 @@ correct column numbers in warnings or errors, even if tabs appear on the\n line.  If the value is less than 1 or greater than 100, the option is\n ignored.  The default is 8.\n \n+@item -fexec-charset=@var{charset}\n+@opindex fexec-charset\n+Set the execution character set, used for string and character\n+constants.  The default is UTF-8.  @var{charset} can be any encoding\n+supported by the system's @code{iconv} library routine.\n+\n+@item -fwide-exec-charset=@var{charset}\n+@opindex fwide-exec-charset\n+Set the wide execution character set, used for wide string and\n+character constants.  The default is UTF-32 or UTF-16, whichever\n+corresponds to the width of @code{wchar_t}.  As with\n+@option{-ftarget-charset}, @var{charset} can be any encoding supported\n+by the system's @code{iconv} library routine; however, you will have\n+problems with encodings that do not fit exactly in @code{wchar_t}.\n+\n @item -fno-show-column\n @opindex fno-show-column\n Do not print column numbers in diagnostics.  This may be necessary if"}, {"sha": "b8fefede87116e46c0e9d62e53aae96f5d099a62", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 50, "deletions": 65, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -439,7 +439,6 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Empty Structures::    Structures with no members.\n * Variadic Macros::\tMacros with a variable number of arguments.\n * Escaped Newlines::    Slightly looser rules for escaped newlines.\n-* Multi-line Strings::  String literals with embedded newlines.\n * Subscripting::        Any array can be subscripted, even if not an lvalue.\n * Pointer Arith::       Arithmetic on @code{void}-pointers and function pointers.\n * Initializers::        Non-constant initializers.\n@@ -1529,27 +1528,14 @@ argument, these arguments are not macro expanded.\n \n Recently, the preprocessor has relaxed its treatment of escaped\n newlines.  Previously, the newline had to immediately follow a\n-backslash.  The current implementation allows whitespace in the form of\n-spaces, horizontal and vertical tabs, and form feeds between the\n+backslash.  The current implementation allows whitespace in the form\n+of spaces, horizontal and vertical tabs, and form feeds between the\n backslash and the subsequent newline.  The preprocessor issues a\n warning, but treats it as a valid escaped newline and combines the two\n lines to form a single logical line.  This works within comments and\n-tokens, including multi-line strings, as well as between tokens.\n-Comments are @emph{not} treated as whitespace for the purposes of this\n-relaxation, since they have not yet been replaced with spaces.\n-\n-@node Multi-line Strings\n-@section String Literals with Embedded Newlines\n-@cindex multi-line string literals\n-\n-As an extension, GNU CPP permits string literals to cross multiple lines\n-without escaping the embedded newlines.  Each embedded newline is\n-replaced with a single @samp{\\n} character in the resulting string\n-literal, regardless of what form the newline took originally.\n-\n-CPP currently allows such strings in directives as well (other than the\n-@samp{#include} family).  This is deprecated and will eventually be\n-removed.\n+tokens, as well as between tokens.  Comments are @emph{not} treated as\n+whitespace for the purposes of this relaxation, since they have not\n+yet been replaced with spaces.\n \n @node Subscripting\n @section Non-Lvalue Arrays May Have Subscripts\n@@ -4437,18 +4423,47 @@ This extension is not supported by GNU C++.\n \n @node Function Names\n @section Function Names as Strings\n+@cindex @code{__func__} identifier\n @cindex @code{__FUNCTION__} identifier\n @cindex @code{__PRETTY_FUNCTION__} identifier\n-@cindex @code{__func__} identifier\n \n-GCC predefines two magic identifiers to hold the name of the current\n-function.  The identifier @code{__FUNCTION__} holds the name of the function\n-as it appears in the source.  The identifier @code{__PRETTY_FUNCTION__}\n-holds the name of the function pretty printed in a language specific\n-fashion.\n+GCC provides three magic variables which hold the name of the current\n+function, as a string.  The first of these is @code{__func__}, which\n+is part of the C99 standard:\n+\n+@display\n+The identifier @code{__func__} is implicitly declared by the translator\n+as if, immediately following the opening brace of each function\n+definition, the declaration\n+\n+@smallexample\n+static const char __func__[] = \"function-name\";\n+@end smallexample\n \n-These names are always the same in a C function, but in a C++ function\n-they may be different.  For example, this program:\n+appeared, where function-name is the name of the lexically-enclosing\n+function.  This name is the unadorned name of the function.\n+@end display\n+\n+@code{__FUNCTION__} is another name for @code{__func__}.  Older\n+versions of GCC recognize only this name.  However, it is not\n+standardized.  For maximum portability, we recommend you use\n+@code{__func__}, but provide a fallback definition with the\n+preprocessor:\n+\n+@smallexample\n+#if __STDC_VERSION__ < 199901L\n+# if __GNUC__ >= 2\n+#  define __func__ __FUNCTION__\n+# else\n+#  define __func__ \"<unknown>\"\n+# endif\n+#endif\n+@end smallexample\n+\n+In C, @code{__PRETTY_FUNCTION__} is yet another name for\n+@code{__func__}.  However, in C++, @code{__PRETTY_FUNCTION__} contains\n+the type signature of the function as well as its bare name.  For\n+example, this program:\n \n @smallexample\n extern \"C\" @{\n@@ -4478,46 +4493,16 @@ gives this output:\n \n @smallexample\n __FUNCTION__ = sub\n-__PRETTY_FUNCTION__ = int  a::sub (int)\n-@end smallexample\n-\n-The compiler automagically replaces the identifiers with a string\n-literal containing the appropriate name.  Thus, they are neither\n-preprocessor macros, like @code{__FILE__} and @code{__LINE__}, nor\n-variables.  This means that they catenate with other string literals, and\n-that they can be used to initialize char arrays.  For example\n-\n-@smallexample\n-char here[] = \"Function \" __FUNCTION__ \" in \" __FILE__;\n+__PRETTY_FUNCTION__ = void a::sub(int)\n @end smallexample\n \n-On the other hand, @samp{#ifdef __FUNCTION__} does not have any special\n-meaning inside a function, since the preprocessor does not do anything\n-special with the identifier @code{__FUNCTION__}.\n-\n-Note that these semantics are deprecated, and that GCC 3.2 will handle\n-@code{__FUNCTION__} and @code{__PRETTY_FUNCTION__} the same way as\n-@code{__func__}.  @code{__func__} is defined by the ISO standard C99:\n-\n-@display\n-The identifier @code{__func__} is implicitly declared by the translator\n-as if, immediately following the opening brace of each function\n-definition, the declaration\n-\n-@smallexample\n-static const char __func__[] = \"function-name\";\n-@end smallexample\n-\n-appeared, where function-name is the name of the lexically-enclosing\n-function.  This name is the unadorned name of the function.\n-@end display\n-\n-By this definition, @code{__func__} is a variable, not a string literal.\n-In particular, @code{__func__} does not catenate with other string\n-literals.\n-\n-In @code{C++}, @code{__FUNCTION__} and @code{__PRETTY_FUNCTION__} are\n-variables, declared in the same way as @code{__func__}.\n+These identifiers are not preprocessor macros.  In GCC 3.3 and\n+earlier, in C only, @code{__FUNCTION__} and @code{__PRETTY_FUNCTION__}\n+were treated as string literals; they could be used to initialize\n+@code{char} arrays, and they could be concatenated with other string\n+literals.  GCC 3.4 and later treat them as variables, like\n+@code{__func__}.  In C++, @code{__FUNCTION__} and\n+@code{__PRETTY_FUNCTION__} have always been variables.\n \n @node Return Address\n @section Getting the Return or Frame Address of a Function"}, {"sha": "3d78b099941b42069c07021fbe1bc77ea4a41462", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -1274,18 +1274,18 @@ my_build_string (len, str)\n   return fix_string_type (build_string (len, str));\n }\n \n-/* Given a chain of STRING_CST's, build a static instance of\n-   NXConstantString which points at the concatenation of those strings.\n+/* Build a static instance of NXConstantString which points at the\n+   string constant STRING.\n    We place the string object in the __string_objects section of the\n    __OBJC segment.  The Objective-C runtime will initialize the isa\n    pointers of the string objects to point at the NXConstantString\n    class object.  */\n \n tree\n-build_objc_string_object (strings)\n-     tree strings;\n+build_objc_string_object (string)\n+     tree string;\n {\n-  tree string, initlist, constructor;\n+  tree initlist, constructor;\n   int length;\n \n   if (lookup_interface (constant_string_id) == NULL_TREE)\n@@ -1297,22 +1297,6 @@ build_objc_string_object (strings)\n \n   add_class_reference (constant_string_id);\n \n-  if (TREE_CHAIN (strings))\n-    {\n-      varray_type vstrings;\n-      VARRAY_TREE_INIT (vstrings, 32, \"strings\");\n-\n-      for (; strings ; strings = TREE_CHAIN (strings))\n-\tVARRAY_PUSH_TREE (vstrings, strings);\n-\n-      string = combine_strings (vstrings);\n-    }\n-  else\n-    string = strings;\n-\n-  string = fix_string_type (string);\n-\n-  TREE_SET_CODE (string, STRING_CST);\n   length = TREE_STRING_LENGTH (string) - 1;\n \n   /* We could not properly create NXConstantString in synth_module_prologue,"}, {"sha": "d67d0b74693e02dc6a2f8d3ff8729fd6c22809d6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -1,3 +1,17 @@\n+2003-07-04  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gcc.c-torture/execute/wchar_t-1.x: New file; XFAIL wchar_t-1.c\n+\teverywhere.\n+\t* gcc.dg/concat.c: Concatenation of string constants with\n+\t__FUNCTION__ / __PRETTY_FUNCTION__ is now a hard error.\n+\t* gcc.dg/wtr-strcat-1.c: Loosen dg-warning regexp.\n+\t* gcc.dg/cpp/escape-2.c: Use wide character constants where\n+\tnecessary to avoid multi-character character constant warning.\n+\t* gcc.dg/cpp/escape.c: Likewise.\n+\t* gcc.dg/cpp/ucs.c: Likewise.\n+\tRemove backslashes from dg-bogus comments, as they confuse Tcl.\n+\tFix a typo.\n+\n 2003-07-04  Kazu Hirata  <kazu@cs.umass.edu>\n \n \tPR c/11428\n@@ -117,7 +131,7 @@\n \n \tPR c++/10219\n \t* g++.dg/template/error1.C: New.\n-\t\n+\n \tPR c++/9779\n \t* g++.dg/template/dependent-expr1.C: New.\n \n@@ -131,8 +145,8 @@\n \n 2003-07-01  Giovanni Bajo  <giovannibajo@libero.it>\n \n-        PR c++/8046\n-        * g++.dg/other/error7.C: New test.\n+\tPR c++/8046\n+\t* g++.dg/other/error7.C: New test.\n \n 2003-07-01  Kazu Hirata  <kazu@cs.umass.edu>\n \n@@ -164,22 +178,22 @@\n \n 2003-06-30  Giovanni Bajo  <giovannibajo@libero.it>\n \n-        PR c++/4933\n-        * g++.dg/template/sizeof4.C: New test.\n+\tPR c++/4933\n+\t* g++.dg/template/sizeof4.C: New test.\n \n 2003-06-30  Giovanni Bajo  <giovannibajo@libero.it>\n \n-        * g++.dg/other/error6.C: New test.\n+\t* g++.dg/other/error6.C: New test.\n \n 2003-06-30  Giovanni Bajo  <giovannibajo@libero.it>\n \n-        PR c++/10750\n-        * g++.dg/parse/constant2.C: New test.\n+\tPR c++/10750\n+\t* g++.dg/parse/constant2.C: New test.\n \n 2003-06-30  Giovanni Bajo <giovannibajo@libero.it>\n \n-        PR c++/11106\n-        * g++.dg/other/error5.C: New test.\n+\tPR c++/11106\n+\t* g++.dg/other/error5.C: New test.\n \n 2003-06-29  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n@@ -238,8 +252,8 @@\n \n 2003-06-26  Giovanni Bajo  <giovannibajo@libero.it>\n \n-        PR c++/8266\n-        * g++.dg/template/explicit-instantiation3.C: New test.\n+\tPR c++/8266\n+\t* g++.dg/template/explicit-instantiation3.C: New test.\n \n 2003-06-26  Eric Botcazou <ebotcazou@libertysurf.fr>\n \n@@ -263,7 +277,7 @@\n \n \tPR c++/10931\n \t* g++.dg/expr/static_cast1.C: New test.\n-\t\n+\n 2003-06-25  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* gcc.dg/20030625-1.c: New test.\n@@ -295,10 +309,10 @@\n \n 2003-06-21  Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n-        * g++.old-deja/g++.benjamin/16077.C: Add -Wconversion  option.\n-        * g++.old-deja/g++.other/conv7.C: Likewise\n-        * g++.old-deja/g++.other/overcnv2.C: Likewise.\n-        * g++.old-deja/g++.other/overload14.C: Likewise.\n+\t* g++.old-deja/g++.benjamin/16077.C: Add -Wconversion  option.\n+\t* g++.old-deja/g++.other/conv7.C: Likewise\n+\t* g++.old-deja/g++.other/overcnv2.C: Likewise.\n+\t* g++.old-deja/g++.other/overload14.C: Likewise.\n \n 2003-06-21  Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n@@ -308,7 +322,7 @@\n 2003-06-20  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/10888\n-\t* g++.dg/warn/Winline-3.C: New test. \n+\t* g++.dg/warn/Winline-3.C: New test.\n \n 2003-06-20  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -319,8 +333,8 @@\n \t* g++.dg/template/memclass2.C: New test.\n \n 2003-06-20  Mark Mitchell  <mark@codesourcery.com>\n-            Eric Botcazou  <ebotcazou@libertysurf.fr>\n-\t\n+\t    Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n \t* lib/gcc-dg.exp (dg-xfail-if): Do not process conditional xfail\n \tdata for non-matching targets.\n \t* gcc.c-torture/compile/simd-5.c: Fix typo in conditional xfail.\n@@ -349,7 +363,7 @@\n \t* g++.dg/anew2.C: New test.\n \t* g++.dg/anew3.C: New test.\n \t* g++.dg/anew4.C: New test.\n-\t\n+\n 2003-06-19  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* gcc.c-torture/compile/simd-5.c: Don't XFAIL on H8.\n@@ -363,7 +377,7 @@\n \n \t* lib/g++.exp (g++_include_flags): Tweak path to testsuite_flags.\n \tRemove cruft.\n-\t\n+\n 2003-06-17  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* gcc.c-torture/compile/20020604-1.c: Use dg-xfail-if for h8300.\n@@ -374,7 +388,7 @@\n \n \tPR c++/10712\n \t* g++.dg/lookup/using7.C: New test.\n-\t\n+\n 2003-06-17  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/11105\n@@ -444,7 +458,7 @@\n \t(dg-xfail-if): Likewise.\n \t* gcc.c-torture/compile/compile.exp: Use dg rather than c-torture\n \tdriver.\n-\t\n+\n \t* gcc.c-torture/compile/20000804-1.c: Convert to dg format.\n \t* gcc.c-torture/compile/20001205-1.c: Likewise.\n \t* gcc.c-torture/compile/20001226-1.c: Likewise.\n@@ -775,7 +789,7 @@ Sun Jun  8 16:46:04 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \t* lib/g++.exp (additional_sources): Remove.\n \t(additional_files): Likewise.\n \t(g++_target_compile): Use dg-additional-files-options.\n-\t\n+\n \t* gcc.dg/special/special.exp: Add \"ecos\" tests.  Remove complex\n \tTcl logic.\n \t* gcc.dg/special/ecos.exp: Remove.\n@@ -787,7 +801,7 @@ Sun Jun  8 16:46:04 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \t* gcc.dg/special/weak-2.c: Likewise.\n \t* gcc.dg/special/wkali-1.c: Likewise.\n \t* gcc.dg/special/wkali-2.c: Likewise.\n-\t\n+\n \t* g++.dg/special/conpr-2.C: Use dg-additional-*, not\n \tdg-gpp-additional-*.\n \t* g++.dg/special/conpr-3.C: Likewise.\n@@ -819,13 +833,13 @@ Sun Jun  8 16:46:04 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-06-04  Richard Henderson  <rth@redhat.com>\n \n-        * gcc.dg/cleanup-1.c: New.\n-        * gcc.dg/cleanup-2.c: New.\n-        * gcc.dg/cleanup-3.c: New.\n-        * gcc.dg/cleanup-4.c: New.\n-        * gcc.dg/cleanup-5.c: New.\n-        * gcc.dg/cleanup-6.c: New.\n-        * gcc.dg/cleanup-7.c: New.\n+\t* gcc.dg/cleanup-1.c: New.\n+\t* gcc.dg/cleanup-2.c: New.\n+\t* gcc.dg/cleanup-3.c: New.\n+\t* gcc.dg/cleanup-4.c: New.\n+\t* gcc.dg/cleanup-5.c: New.\n+\t* gcc.dg/cleanup-6.c: New.\n+\t* gcc.dg/cleanup-7.c: New.\n \n 2003-06-04  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -866,7 +880,7 @@ Sun Jun  8 16:46:04 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-06-03  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * gcc.c-torture/compile/simd-5.x: Remove xfail for PPC64.\n+\t* gcc.c-torture/compile/simd-5.x: Remove xfail for PPC64.\n \n 2003-06-03  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n@@ -934,7 +948,7 @@ Sun Jun  8 16:46:04 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \t* gcc.dg/cpp/cpp.exp: Remove scanning of \".cpp\" files.\n \n 2003-06-01  Loren James Rittle  <ljrittle@acm.org>\n-\t\n+\n \t* gcc.dg/cpp/redef3.c: New file.\n \n 2003-06-01  Eric Botcazou  <ebotcazou@libertysurf.fr>\n@@ -964,7 +978,7 @@ Sun Jun  8 16:46:04 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \tPR fortran/10843\n \t* g77.dg/ffixed-form-1.f: New test\n \t* g77.dg/ffixed-form-2.f: New test\n-\t* g77.dg/ffree-form-2.f: New test - XFAIL pending fix \n+\t* g77.dg/ffree-form-2.f: New test - XFAIL pending fix\n \t* g77.dg/ffree-form-3.f: New test\n \n 2003-05-26  Andreas Tobler <a.tobler@schweiz.ch>\n@@ -982,21 +996,21 @@ Sun Jun  8 16:46:04 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \t* g++.dg/template/access10.C: New test.\n \n 2003-05-24  Eric Botcazou  <ebotcazou@libertysurf.fr>\n-            Kaveh R. Ghazi <ghazi@caip.rutgers.edu>\n+\t    Kaveh R. Ghazi <ghazi@caip.rutgers.edu>\n \n \t* gcc.c-torture/compile/simd-5.x: XFAIL on SPARC64.\n \n 2003-05-24  Andreas Tobler <a.tobler@schweiz.ch>\n \n-        * gcc.dg/torture/builtin-noret-1.c: Add dg-option -multiply_defined\n-        suppress for powerpc-*-darwin*.\n+\t* gcc.dg/torture/builtin-noret-1.c: Add dg-option -multiply_defined\n+\tsuppress for powerpc-*-darwin*.\n \t* gcc.dg/torture/builtin-noret-2.c: Likewise.\n \n 2003-05-24  Andreas Tobler <a.tobler@schweiz.ch>\n \n \t* gcc.c-torture/execute/builtins/builtins.exp: Add -multiply_defined\n \tsuppress option for powerpc-*-darwin*.\n-\t\n+\n 2003-05-23  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc.dg/builtins-1.c: Add tests for tan and atan.\n@@ -1123,7 +1137,7 @@ Sun Jun  8 16:46:04 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \t* lib/g++-dg.exp: Use gcc-dg.exp to implement all functionality.\n \t* lib/g77-dg.exp: Likewise.\n \t* lib/obj-dg.exp: Likewise.\n-\t\n+\n 2003-05-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tMerge from gcc-3_2-rhl8-branch:\n@@ -1316,13 +1330,13 @@ Sun Jun  8 16:46:04 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-05-07  Richard Henderson  <rth@redhat.com>\n \n-        PR c++/10570\n-        * g++.dg/eh/forced1.C: Expect catch-all handlers to run.\n-        Verify exception_cleanup not called for rethrows.\n-        * g++.dg/eh/forced2.C: Test that exception_cleanup is called\n-        when exiting catch block without rethrowing.\n-        * g++.dg/eh/forced3.C: New.\n-        * g++.dg/eh/forced4.C: New.\n+\tPR c++/10570\n+\t* g++.dg/eh/forced1.C: Expect catch-all handlers to run.\n+\tVerify exception_cleanup not called for rethrows.\n+\t* g++.dg/eh/forced2.C: Test that exception_cleanup is called\n+\twhen exiting catch block without rethrowing.\n+\t* g++.dg/eh/forced3.C: New.\n+\t* g++.dg/eh/forced4.C: New.\n \n 2003-05-07  Aldy Hernandez  <aldyh@redhat.com>\n "}, {"sha": "38c693d2f0033440906b0f2963277d5b6c65e580", "filename": "gcc/testsuite/gcc.c-torture/execute/wchar_t-1.x", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fwchar_t-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fwchar_t-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fwchar_t-1.x?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -0,0 +1,3 @@\n+# Doesn't compile due to use of literal ISO8859.1 characters.  PR 11439.\n+set torture_compile_xfail \"*-*-*\"\n+return 0"}, {"sha": "17a80a7e41dbefd9173948a8b6412522bfadda24", "filename": "gcc/testsuite/gcc.dg/concat.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.dg%2Fconcat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.dg%2Fconcat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fconcat.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -2,15 +2,15 @@\n \n /* { dg-do compile } */\n \n-/* Test we output a warning for concatenation of artificial strings.\n+/* Test we output an error for concatenation of artificial strings.\n \n    Neil Booth, 10 Dec 2001.  */\n \n void foo ()\n {\n-  char str1[] = __FUNCTION__ \".\";\t/* { dg-warning \"deprecated\" } */\n-  char str2[] = __PRETTY_FUNCTION__ \".\";/* { dg-warning \"deprecated\" } */\n-  char str3[] = \".\" __FUNCTION__;\t/* { dg-warning \"deprecated\" } */\n-  char str4[] = \".\" __PRETTY_FUNCTION__;/* { dg-warning \"deprecated\" } */\n-  char str5[] = \".\" \".\";\t/* No warning.  */\n+  char s1[] = __FUNCTION__\".\";\t     /* { dg-error \"(parse|syntax|invalid)\" } */\n+  char s2[] = __PRETTY_FUNCTION__\".\";/* { dg-error \"(parse|syntax|invalid)\" } */\n+  char s3[] = \".\"__FUNCTION__;\t     /* { dg-error \"(parse|syntax|invalid)\" } */\n+  char s4[] = \".\"__PRETTY_FUNCTION__;/* { dg-error \"(parse|syntax|invalid)\" } */\n+  char s5[] = \".\"\".\";                /* No error.  */\n }"}, {"sha": "e79fa91cbe9e558cca2c4fb114b291c2eee6593f", "filename": "gcc/testsuite/gcc.dg/cpp/escape-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape-2.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -10,11 +10,11 @@\n \n #if '\\e'\t\t/* { dg-warning \"non-ISO\" \"non-ISO \\\\e\" } */\n #endif\n-#if '\\u00a0'\t\t/* { dg-bogus \"unknown\" \"\\\\u is known in C99\" } */\n+#if L'\\u00a0'\t\t/* { dg-bogus \"unknown\" \"\\\\u is known in C99\" } */\n #endif\n \n void foo ()\n {\n   int c = '\\E';\t\t/* { dg-warning \"non-ISO\" \"non-ISO \\\\E\" } */\n-  c = '\\u00a0';\t\t/* { dg-bogus \"unknown\" \"\\\\u is known in C99\" } */\n+  c = L'\\u00a0';\t/* { dg-bogus \"unknown\" \"\\\\u is known in C99\" } */\n }"}, {"sha": "c9dd44e43e5bd7c84ba09be8b21f434aff2d96d2", "filename": "gcc/testsuite/gcc.dg/cpp/escape.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fescape.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -13,13 +13,13 @@\n #if '\\x1a' != 26\t/* { dg-warning \"traditional\" \"traditional hex\" } */\n  #error bad hex\t\t/* { dg-bogus \"bad\" \"bad hexadecimal evaluation\" } */\n #endif\n-#if '\\u'\t\t/* { dg-warning \"unknown\" \"\\u is unknown in C89\" } */\n+#if L'\\u00a1'\t\t/* { dg-warning \"only valid\" \"\\u is unknown in C89\" } */\n #endif\n \n void foo ()\n {\n   int c = '\\a';\t\t/* { dg-warning \"traditional\" \"traditional bell\" } */\n \n   c = '\\xa1';\t\t/* { dg-warning \"traditional\" \"traditional hex\" } */\n-  c = '\\u';\t\t/* { dg-warning \"unknown\" \"\\u is unknown in C89\" } */\n+  c = L'\\u00a1';\t/* { dg-warning \"only valid\" \"\\u is unknown in C89\" } */\n }"}, {"sha": "3f3d97edfa50a4efcc3135cdd14d656ab48d77fe", "filename": "gcc/testsuite/gcc.dg/cpp/ucs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fucs.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -35,20 +35,20 @@\n #undef long\n \n #if L'\\u1234' != 0x1234\n-#error bad short ucs\t/* { dg-bogus \"bad\" \"bad \\u1234 evaluation\" } */\n+#error bad short ucs\t/* { dg-bogus \"bad\" \"bad u1234 evaluation\" } */\n #endif\n \n #if WCHAR_MAX >= 0x7ffffff\n # if L'\\U1234abcd' != 0x1234abcd\n-#  error bad long ucs\t/* { dg-bogus \"bad\" \"bad \\U1234abcd evaluation\" } */\n+#  error bad long ucs\t/* { dg-bogus \"bad\" \"bad U1234abcd evaluation\" } */\n # endif\n #endif\n \n void foo ()\n {\n   int c;\n \n-  c = L'\\ubad';\t\t/* { dg-error \"incomplete\" \"incompete UCN 1\" } */\n+  c = L'\\ubad';\t\t/* { dg-error \"incomplete\" \"incomplete UCN 1\" } */\n   c = L\"\\U1234\"[0];\t/* { dg-error \"incomplete\" \"incompete UCN 2\" } */\n \n   c = L'\\u000x';\t/* { dg-error \"incomplete\" \"non-hex digit in UCN\" } */\n@@ -58,7 +58,7 @@ void foo ()\n \n   c = '\\u0024';\t\t/* { dg-bogus \"invalid\" \"0024 is a valid UCN\" } */\n   c = \"\\u0040\"[0];\t/* { dg-bogus \"invalid\" \"0040 is a valid UCN\" } */\n-  c = '\\u00a0';\t\t/* { dg-bogus \"invalid\" \"00a0 is a valid UCN\" } */\n+  c = L'\\u00a0';\t/* { dg-bogus \"invalid\" \"00a0 is a valid UCN\" } */\n   c = '\\U00000060';\t/* { dg-bogus \"invalid\" \"0060 is a valid UCN\" } */\n \n   c = '\\u0025';\t\t/* { dg-error \"not a valid\" \"0025 invalid UCN\" } */"}, {"sha": "730a929c5960399b21870e5076995298ebaa0738", "filename": "gcc/testsuite/gcc.dg/wtr-strcat-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-strcat-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-strcat-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-strcat-1.c?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -9,7 +9,7 @@ testfunc ()\n {\n   const char *foo;\n   \n-  foo = \"hello\" \"hello\"; /* { dg-warning \"string concatenation\" \"string concatenation\" } */\n+  foo = \"hello\" \"hello\"; /* { dg-warning \"concatenation\" \"string concatenation\" } */\n \n # 15 \"sys-header.h\" 3\n /* We are in system headers now, no -Wtraditional warnings should issue.  */"}, {"sha": "078886137dc1a41dd85bd32b82936b04138b4bb6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 105, "deletions": 92, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -1,17 +1,30 @@\n+2003-07-04  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* testsuite/22_locale/collate/compare/wchar_t/2.cc\n+\t* testsuite/22_locale/collate/compare/wchar_t/wrapped_env.cc\n+\t* testsuite/22_locale/collate/compare/wchar_t/wrapped_locale.cc\n+\t* testsuite/22_locale/collate/hash/wchar_t/2.cc\n+\t* testsuite/22_locale/collate/hash/wchar_t/wrapped_env.cc\n+\t* testsuite/22_locale/collate/hash/wchar_t/wrapped_locale.cc\n+\t* testsuite/22_locale/collate/transform/wchar_t/2.cc\n+\t* testsuite/22_locale/collate/transform/wchar_t/wrapped_env.cc\n+\t* testsuite/22_locale/collate/transform/wchar_t/wrapped_locale.cc:\n+\tXFAIL on all targets.\n+\n 2003-07-04  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* acinclude.m4 (GLIBCPP_ENABLE_PCH): Fix missed variable.\n \t* aclocal.m4: Regenerate.\n \t* configure: Regenerate.\n-\t\n+\n 2003-07-04  Jerry Quinn  <jlquinn@optonline.net>\n \n \t* include/bits/locale_facets.tcc (__int_to_char): Move common case\n \tto the top.\n \n 2003-07-04  Benjamin Kosnik  <bkoz@redhat.com>\n-            Petur Runolfsson  <peturr02@ru.is>\n-\t\n+\t    Petur Runolfsson  <peturr02@ru.is>\n+\n \t* config/io/basic_file_stdio.cc: Revert.\n \n 2003-07-04  Paolo Carlini  <pcarlini@unitus.it>\n@@ -49,7 +62,7 @@\n \t* src/Makefile.in: Regenerate.\n \n \t* config/os/gnu-linux/os_defines.h: Remove glibc-2.0 support.\n-\t\n+\n 2003-07-04  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* acinclude.m4 (GLIBCPP_ENABLE_DEBUG_FLAGS): To\n@@ -59,7 +72,7 @@\n \t* aclocal.m4: Regenerate.\n \t* configure: Same.\n \t* docs/html/configopts.html: Update.\n-\t\n+\n 2003-07-04  Paolo Carlini  <pcarlini@unitus.it>\n \n \tRevert the fix for libstdc++/11378.\n@@ -81,7 +94,7 @@\n \t* include/bits/stl_tree.h: Likewise.\n \t* include/bits/stl_uninitialized.h: Likewise.\n \t* include/bits/stl_vector.h: Likewise.\n-\t* include/ext/rope: Change includes order.\t\n+\t* include/ext/rope: Change includes order.\n \n 2003-07-04  Benjamin Kosnik  <bkoz@redhat.com>\n \n@@ -108,23 +121,23 @@\n \t* configure: Regenerate.\n \t* configure.host: Add fpos_include_dir.\n \t* config/os/gnu-linux/fpos.h: New.\n-\t* config/os/generic/fpos.h: Add.\t\n-\t* include/bits/fpos.h: Remove.\t\n+\t* config/os/generic/fpos.h: Add.\n+\t* include/bits/fpos.h: Remove.\n \n \t* config/io/c_io_stdio.h: Remove fpos_t typedef.\n \n \t* include/bits/fstream.tcc: Tweaks.\n \t* include/std/std_fstream.h: Same.\n-\t\n+\n \t* testsuite/27_io/fpos/1.cc (test01): Uncomment. Move to...\n \t* testsuite/27_io/fpos/mbstate_t/1.cc: ...here.\n \t* testsuite/27_io/fpos/mbstate_t/2.cc: Same.\n \t* testsuite/27_io/fpos/mbstate_t/3.cc: Same.\n \t* testsuite/27_io/fpos/1.cc: New.\n-\t\n+\n 2003-07-03  Benjamin Kosnik  <bkoz@redhat.com>\n \t    Petur Runolfsson  <peturr02@ru.is>\n-\t\n+\n \t* include/std/std_streambuf.h: Remove _M_pos.\n \t* config/io/basic_file_stdio.h: Use seekpos instead of seekoff.\n \t* config/io/basic_file_stdio.cc: Same, use fseek instead of lseek,\n@@ -133,7 +146,7 @@\n \t* testsuite/27_io/basic_filebuf/sputn/char/9339.cc: Close filebufs\n \tbefore reading again.\n \t* testsuite/27_io/objects/char/6.cc: Tweak.\n-\t\n+\n 2003-07-03  David Edelsohn  <edelsohn@gnu.org>\n \n \t* testsuite/22_locale/num_put/put/char/7.cc: Guard with\n@@ -175,7 +188,7 @@\n \t* acinclude.m4 (GLIBCPP_ENABLE_PCH): Fix obvious error.\n \t* aclocal.m4: Regenerated.\n \t* configure: Regenerated.\n-\t\n+\n 2003-07-01  Paolo Carlini  <pcarlini@unitus.it>\n \n \tPR libstdc++/11389\n@@ -247,30 +260,30 @@\n \tfunctions with std::, thus avoiding Koenig lookup.\n \n 2003-06-30  Doug Gregor <dgregor@apple.com>\n-\t\n+\n \t* include/bits/locale_facets.tcc (money_get::do_get): Avoid\n-        subscripting empty string. \n+\tsubscripting empty string.\n \n 2003-06-30  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* testsuite/Makefile.am (check-am):  Do not override.\n \t(baseline_symbols):  Declare as PHONY, so no need to 'touch' it.\n \t* testsuite/Makefile.in:  Regenerate.\n \n-2003-06-30  Doug Gregor <dgregor@apple.com> \n-\t\n+2003-06-30  Doug Gregor <dgregor@apple.com>\n+\n \t* testsuite/24_iterators/insert_iterator.cc (test01, test02):\n \tDon't initialize an insert_iterator with a singular iterator.\n \n 2003-06-30  Benjamin Kosnik  <bkoz@redhat.com>\n-\t\n+\n \t* acinclude.m4 (GLIBCPP_ENABLE_PCH): Add bits for --enable-pch.\n \t* aclocal.m4: Regenerate.\n \t* configure.in (GLIBCPP_CHECK_PCH): Move, change to\n \tGLIBCPP_ENABLE_PCH, default to yes.\n \t* configure: Regenerate.\n \t* docs/html/configopts.html: Add --enable-pch.\n-\t\n+\n 2003-06-30  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* testsuite/lib/libstdc++-v3-dg.exp:  Add comments.\n@@ -297,13 +310,13 @@\n \t* include/std/std_fstream.h (_M_underflow): Remove.\n \t(uflow): Remove, inherited from streambuf.\n \t(underflow): Only declare.\n-\t* include/bits/fstream.tcc (_M_underflow): Rename to \n+\t* include/bits/fstream.tcc (_M_underflow): Rename to\n \tunderflow, to which is equivalent for __bump == false,\n \tsimplify.\n \t* include/std/std_sstream.h (_M_underflow): Remove.\n \t(uflow): Remove, inherited from streambuf.\n \t(underflow): Only declare.\n-\t* include/bits/sstream.tcc (_M_underflow): Rename to \n+\t* include/bits/sstream.tcc (_M_underflow): Rename to\n \tunderflow, to which is equivalent for __bump == false,\n \tsimplify.\n \n@@ -344,7 +357,7 @@\n \toutput name to libstdc++-v3-performance.sum.\n \t* testsuite/Makefile.am (CLEANFILES): Remove .performance.\n \t* testsuite/Makefile.in: Regenerate.\n-\t\n+\n 2003-06-27  Matthias Klose  <doko@debian.org>\n \n \t* testsuite/Makefile.am (check-abi, check-abi-verbose): Save\n@@ -398,21 +411,21 @@\n \t(numpunct::_M_initialize_numpunct): Account for _M_data, fill in\n \tall elements for \"C\" locale.\n \t(numpunct::~numpunct): Delete _M_data.\n-\t* config/locale/generic/numeric_members.cc: Same.\t\n+\t* config/locale/generic/numeric_members.cc: Same.\n \t* include/bits/basic_ios.tcc\n \t(basic_ios::init): Remove __locale_cache bits.\n \t(basic_ios::_M_cache_locale): Same.\n-\t* include/bits/ios_base.h: Same. Tweaks. \n+\t* include/bits/ios_base.h: Same. Tweaks.\n \t* include/bits/locale_classes.h: Tweaks. Reorder classes.\n \t(__use_cache): Make friends with _Impl, locale.\n \t(_Impl::_M_caches): Add.\n \t(_Impl::_M_install_cache): Add.\n \t* include/bits/locale_facets.h (__numpunct_cache): New.\n \t(numpunct): Encapsulate data members in __numpunct_cache member,\n \t_M_data. Adjust virtuals.\n-\t(numpunct::numpunct): New ctor for the same. \n+\t(numpunct::numpunct): New ctor for the same.\n \t(__locale_cache_base): Remove.\n-\t(__locale_cache): Remove.\t\n+\t(__locale_cache): Remove.\n \t* include/bits/locale_facets.tcc (__use_cache): New function,\n \tspecializations.\n \t(num_put::_M_convert_int, _M_convert_float, do_put): Use it.\n@@ -429,13 +442,13 @@\n \t* testsuite/27_io/ios_base/cons/copy_neg.cc: Same.\n \n 2003-06-26  Nathan C. Myers  <ncm-nospam@cantrip.org>\n-            Paolo Carlini  <pcarlini@unitus.it>\n+\t    Paolo Carlini  <pcarlini@unitus.it>\n \n \t* testsuite/performance/filebuf_copy.cc: New, testing char\n \tby char file copy.\n \n 2003-06-26  Paolo Carlini  <pcarlini@unitus.it>\n-            Nathan C. Myers  <ncm-nospam@cantrip.org>\n+\t    Nathan C. Myers  <ncm-nospam@cantrip.org>\n \n \t* include/bits/fstream.tcc (_M_underflow): When the actual\n \tend of file is reached, set 'uncommitted' mode to allow a\n@@ -465,14 +478,14 @@\n \t* docs/html/test.html: Update.\n \n \t* README: Update.\n-\t\n+\n 2003-06-24  Benjamin Kosnik  <bkoz@redhat.com>\n-            Ulrich Drepper  <drepper@redhat.com>\n+\t    Ulrich Drepper  <drepper@redhat.com>\n \n \t* testsuite/testsuite_performance.h: Tweak mallinfo.\n \n 2003-06-24  Paolo Carlini  <pcarlini@unitus.it>\n-            Nathan C. Myers  <ncm-nospam@cantrip.org>\n+\t    Nathan C. Myers  <ncm-nospam@cantrip.org>\n \n \t* include/std/std_fstream.h (_M_filepos): Remove.\n \t(_M_reading, _M_writing): New, encode the various I/O modes:\n@@ -499,7 +512,7 @@\n \t* include/std/std_streambuf.h (_M_move_out_cur, _M_move_in_cur,\n \t_M_out_lim, _M_buf_unified): Remove.\n \t(basic_streambuf): Don't set _M_out_lim and _M_buf_unified.\n-\t(setp): Don't set _M_out_lim.\t\n+\t(setp): Don't set _M_out_lim.\n \t* testsuite/27_io/basic_filebuf/sbumpc/char/1-io.cc: Fix for\n \tthe new logic ('read', 'write' and 'uncommitted' modes): e.g.,\n \tupon open the mode is 'uncommitted' and therefore the put area\n@@ -552,11 +565,11 @@\n \t* docs/html/17_intro/libstdc++-assign.txt: Update address.\n \n \t* testsuite/performance/ifstream_getline.cc: Fix.\n-\t\n+\n 2003-06-23  Doug Gregor <dgregor@apple.com>\n \n-        * include/bits/boost_concept_check.h: Don't use _D or _R for type \n-        names.\n+\t* include/bits/boost_concept_check.h: Don't use _D or _R for type\n+\tnames.\n \n 2003-06-22  Paolo Carlini  <pcarlini@unitus.it>\n \t    Nathan C. Myers  <ncm-nospam@cantrip.org>\n@@ -605,7 +618,7 @@\n \n 2003-06-20  Doug Gregor <dgregor@apple.com>\n \n-\t* include/bits/basic_string.h (basic_string::replace): Dispatch \n+\t* include/bits/basic_string.h (basic_string::replace): Dispatch\n \t_InputIterator version based on _Is_integer.\n \t* include/bits/basic_string.tcc (basic_string::replace):\n \tRenamed replace(iterator, iterator, size_type, _CharT) to\n@@ -661,7 +674,7 @@\n \t(CLEANFILES): Add.\n \n 2003-06-18  Paolo Carlini  <pcarlini@unitus.it>\n-            Benjamin Kosnik  <bkoz@redhat.com>\n+\t    Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/std/std_sstream.h (setbuf): Check __n >= 0.\n \t* include/bits/fstream.tcc (setbuf): Tweak.\n@@ -674,7 +687,7 @@\n \t(seekpos): Likewise, clean up.\n \n 2003-06-18  Nathan C. Myers  <ncm-nospam@cantrip.org>\n-            Paolo Carlini  <pcarlini@unitus.it>\n+\t    Paolo Carlini  <pcarlini@unitus.it>\n \n \t* include/bits/fstream.tcc (setbuf): Allow (__s, 1) too,\n \tsimply equivalent to the unbuffered case (0, 0) as far as\n@@ -745,7 +758,7 @@\n \n 2003-06-16  Andreas Jaeger  <aj@suse.de>\n \n-        * testsuite/abi_check.cc: Create summary report.\n+\t* testsuite/abi_check.cc: Create summary report.\n \n 2003-06-16  Paolo Carlini  <pcarlini@unitus.it>\n \n@@ -763,14 +776,14 @@\n \t* configure: Regenerate.\n \n 2003-06-16  Benjamin Kosnik  <bkoz@redhat.com>\n-            Andreas Jaeger  <aj@suse.de>\n+\t    Andreas Jaeger  <aj@suse.de>\n \n \t* configure.host: Set x86_64 abi_baseline pair correctly.\n \n 2003-06-16  Paolo Carlini  <pcarlini@unitus.it>\n \n \t* testsuite/27_io/basic_filebuf/sungetc/char/1.cc: Split and\n-        fix for missing seeks between gets and puts into...\n+\tfix for missing seeks between gets and puts into...\n \t* testsuite/27_io/basic_filebuf/sungetc/char/1-in.cc: New.\n \t* testsuite/27_io/basic_filebuf/sungetc/char/1-io.cc: New.\n \t* testsuite/27_io/basic_filebuf/sungetc/char/1-out.cc: New.\n@@ -826,8 +839,8 @@\n \n \tAvoid multi-processor bus contention on increment/decrement-and-\n \ttest of the reference count in the empty-string object, by comparing\n-        addresses first, and never touching the reference count of the empty-\n-        string object.\n+\taddresses first, and never touching the reference count of the empty-\n+\tstring object.\n \t* include/bits/basic_string.h:\n \t(_S_empty_rep_storage): Move into basic_string<>::_Rep for use by its\n \tmembers.\n@@ -839,16 +852,16 @@\n \tsince no longer must increment its refcount.\n \t* include/bits/basic_string.tcc:\n \t(_Rep::_M_destroy, _M_leak_hard): Check for the empty string and\n-        return immediately.  The former might be unnecessary.  The latter\n-        prevents begin() and end() from cloning it unnecessarily.\n+\treturn immediately.  The former might be unnecessary.  The latter\n+\tprevents begin() and end() from cloning it unnecessarily.\n \t(_S_construct(_InIterator, _InIterator, const _Alloc&,\n \tinput_iterator_tag), _S_construct(_InIterator, _InIterator,\n \tconst _Alloc&, forward_iterator_tag), _S_construct(size_type, _CharT,\n \tconst _Alloc&)): Change to use _M_refdata() in place of _M_refcopy().\n \t(_M_mutate): Check for the empty string and treat it as shared.\n-        This is necessary here because _M_mutate is sometimes called with\n-        all-zero arguments; in all other uses of _M_is_shared, the test comes\n-        out right anyhow.\n+\tThis is necessary here because _M_mutate is sometimes called with\n+\tall-zero arguments; in all other uses of _M_is_shared, the test comes\n+\tout right anyhow.\n \n 2003-06-12  Benjamin Kosnik  <bkoz@redhat.com>\n \n@@ -912,7 +925,7 @@\n \t* testsuite/ext/allocators.cc: Fixup.\n \n 2003-06-11  Stefan Olsson  <stefan@snon.net>\n-            Ola R\ufffdnnerup  <fnolis@home.se>\n+\t    Ola R\ufffdnnerup  <fnolis@home.se>\n \n \t* include/Makefile.am (ext_headers): Add.\n \t* include/Makefile.in: Regenerate.\n@@ -1364,16 +1377,16 @@\n \t* docs/html/test.html: ...here. Add documentation.\n \t* docs/html/install.html: Move testing bits out..\n \t* docs/html/documentation.html: Add separate testing link.\n-        * testsuite/performance: Add.\n-        * testsuite/performance/allocator.cc: New.\n-        * testsuite/performance/complex_norm.cc: New.\n-        * testsuite/performance/cout_insert_int.cc: New.\n-        * testsuite/performance/fstream_seek_write.cc: New.\n-        * testsuite/performance/ifstream_getline.cc: New.\n-        * testsuite/performance/map_create_fill.cc: New.\n-        * testsuite/performance/ofstream_insert_float.cc: New.\n-        * testsuite/performance/ofstream_insert_int.cc: New.\n-        * testsuite/performance/string_append.cc: New.\n+\t* testsuite/performance: Add.\n+\t* testsuite/performance/allocator.cc: New.\n+\t* testsuite/performance/complex_norm.cc: New.\n+\t* testsuite/performance/cout_insert_int.cc: New.\n+\t* testsuite/performance/fstream_seek_write.cc: New.\n+\t* testsuite/performance/ifstream_getline.cc: New.\n+\t* testsuite/performance/map_create_fill.cc: New.\n+\t* testsuite/performance/ofstream_insert_float.cc: New.\n+\t* testsuite/performance/ofstream_insert_int.cc: New.\n+\t* testsuite/performance/string_append.cc: New.\n \t* testsuite/lib/libstdc++-v3-dg.exp (v3-compute-tests): Filter\n \tperformance tests.\n \n@@ -1631,16 +1644,16 @@\n \n 2003-05-07  Richard Henderson  <rth@redhat.com>\n \n-        PR c++/10570\n-        * libsupc++/eh_catch.cc (__cxa_begin_catch): Handle foreign exceptions.\n-        (__cxa_end_catch): Likewise.\n-        * libsupc++/eh_throw.cc (__cxa_rethrow): Likewise.  Use\n-        _Unwind_Resume_or_Rethrow.\n-        * libsupc++/eh_personality.cc (empty_exception_spec): New.\n-        (PERSONALITY_FUNCTION): Don't ignore terminate or catch-all\n-        for _UA_FORCE_UNWIND.  Honor empty filter spec for foreign\n-        exceptions.  Don't push terminate/unexpected to cxa functions.\n-        (__cxa_call_unexpected): Remove foreign exception fixmes.\n+\tPR c++/10570\n+\t* libsupc++/eh_catch.cc (__cxa_begin_catch): Handle foreign exceptions.\n+\t(__cxa_end_catch): Likewise.\n+\t* libsupc++/eh_throw.cc (__cxa_rethrow): Likewise.  Use\n+\t_Unwind_Resume_or_Rethrow.\n+\t* libsupc++/eh_personality.cc (empty_exception_spec): New.\n+\t(PERSONALITY_FUNCTION): Don't ignore terminate or catch-all\n+\tfor _UA_FORCE_UNWIND.  Honor empty filter spec for foreign\n+\texceptions.  Don't push terminate/unexpected to cxa functions.\n+\t(__cxa_call_unexpected): Remove foreign exception fixmes.\n \n 2003-05-07  Benjamin Kosnik  <bkoz@redhat.com>\n \n@@ -1683,7 +1696,7 @@\n \t* include/std/std_sstream.h: Replace _M_really_sync to _M_sync.\n \t* include/bits/sstream.tcc: Same.\n \n-        * include/bits/basic_ios.h: Correct spacing for '< ctype'.\n+\t* include/bits/basic_ios.h: Correct spacing for '< ctype'.\n \n \t* include/bits/locale_facets.tcc: Replace __temp to __tmp.\n \n@@ -1914,27 +1927,27 @@\n \n 2003-04-28  Petur Runolfsson  <peturr02@ru.is>\n \n-        PR libstdc++/9523\n-        * include/bits/ios_base.h (Init::_S_ios_create,\n-        Init::_S_ios_destroy):  Remove declarations.\n-        (Init::_S_create_buffers,\n-        Init::_S_destroy_buffers):  Declare\n-        * src/ios.cc (Init::_S_ios_create):  Remove\n-        (Init::_S_create_buffers):  Create buffers and add to streams.\n-        (Init::_S_ios_destroy):  Rename to...\n-        (Init::_S_destroy_buffers):  this.\n-        (Init::Init):  Only construct streams once.\n-        (Init::~Init):  Flush streams, don't destroy them.\n-        (ios_base::sync_with_stdio):  Don't destroy streams, only buffers.\n-        * testsuite/27_io/ios_base/sync_with_stdio/9523.cc:  New test.\n-        * testsuite/27_io/objects/char/5.cc:  New test.\n-        * testsuite/27_io/objects/char/5268.cc:  Avoid undefined behavior.\n-        * testsuite/27_io/objects/char/6.cc:  New test.\n-        * testsuite/27_io/objects/char/7.cc:  New test.\n+\tPR libstdc++/9523\n+\t* include/bits/ios_base.h (Init::_S_ios_create,\n+\tInit::_S_ios_destroy):  Remove declarations.\n+\t(Init::_S_create_buffers,\n+\tInit::_S_destroy_buffers):  Declare\n+\t* src/ios.cc (Init::_S_ios_create):  Remove\n+\t(Init::_S_create_buffers):  Create buffers and add to streams.\n+\t(Init::_S_ios_destroy):  Rename to...\n+\t(Init::_S_destroy_buffers):  this.\n+\t(Init::Init):  Only construct streams once.\n+\t(Init::~Init):  Flush streams, don't destroy them.\n+\t(ios_base::sync_with_stdio):  Don't destroy streams, only buffers.\n+\t* testsuite/27_io/ios_base/sync_with_stdio/9523.cc:  New test.\n+\t* testsuite/27_io/objects/char/5.cc:  New test.\n+\t* testsuite/27_io/objects/char/5268.cc:  Avoid undefined behavior.\n+\t* testsuite/27_io/objects/char/6.cc:  New test.\n+\t* testsuite/27_io/objects/char/7.cc:  New test.\n \n 2003-04-28  Benjamin Kosnik  <bkoz@redhat.com>\n \n-        * testsuite/27_io/objects/char/8.cc:  New test.\n+\t* testsuite/27_io/objects/char/8.cc:  New test.\n \n 2003-04-28  Benjamin Kosnik  <bkoz@redhat.com>\n \n@@ -2007,7 +2020,7 @@\n \t_M_in_cur, not gptr().\n \n 2003-04-25  Ranjit Mathew  <rmathew@hotmail.com>\n-            Phil Edwards  <pme@gcc.gnu.org>\n+\t    Phil Edwards  <pme@gcc.gnu.org>\n \n \t* testsuite_flags.in: Guard against the possibility\n \tof having \"xgcc\" as a part of a folder name in the\n@@ -2270,8 +2283,8 @@\n \t(install-pch): New rule.\n \t(install-headers): New rule.\n \t(install-data-local): Install headers and conditionally pch.\n-        * include/Makefile.in: Regenerate.\n-        * testsuite_flags.in (--build-cxx): Use pch file.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite_flags.in (--build-cxx): Use pch file.\n \n 2003-04-16  Jonathan Wakely  <redi@gcc.gnu.org>\n \n@@ -2477,7 +2490,7 @@\n \twhen target is *-*-freebsd*.\n \n 2003-04-14  Nathan Myers  <ncm@cantrip.org>\n-            Paolo Carlini  <pcarlini@unitus.it>\n+\t    Paolo Carlini  <pcarlini@unitus.it>\n \n \tPR libstdc++/9701 (in_avail())\n \t* include/std/std_streambuf.h (in_avail): Simplify, in_avail"}, {"sha": "56a4083f6ee70432a050e04254ed30dc51948e44", "filename": "libstdc++-v3/testsuite/22_locale/collate/compare/wchar_t/2.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fcompare%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fcompare%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fcompare%2Fwchar_t%2F2.cc?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -18,6 +18,10 @@\n // Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n // USA.\n \n+// Doesn't work due to use of literal ISO8859.1 characters.  PR 11439\n+// { dg-do compile { xfail *-*-* } } should be run\n+// { dg-excess-errors \"\" }\n+\n // 22.2.4.1.1 collate members\n \n #include <locale>"}, {"sha": "1a36ca2d7449d4ccf6fe925302427ef67556bf5a", "filename": "libstdc++-v3/testsuite/22_locale/collate/compare/wchar_t/wrapped_env.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fcompare%2Fwchar_t%2Fwrapped_env.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fcompare%2Fwchar_t%2Fwrapped_env.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fcompare%2Fwchar_t%2Fwrapped_env.cc?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -20,6 +20,10 @@\n \n // 22.2.4.1.1 collate members\n \n+// Doesn't work due to use of literal ISO8859.1 characters.  PR 11439\n+// { dg-do compile { xfail *-*-* } } should be run\n+// { dg-excess-errors \"\" }\n+\n #include <testsuite_hooks.h>\n \n #define main discard_main_1"}, {"sha": "0a5f060e621a228ee138a701099995f0da5eb9bb", "filename": "libstdc++-v3/testsuite/22_locale/collate/compare/wchar_t/wrapped_locale.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fcompare%2Fwchar_t%2Fwrapped_locale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fcompare%2Fwchar_t%2Fwrapped_locale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fcompare%2Fwchar_t%2Fwrapped_locale.cc?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -20,6 +20,10 @@\n \n // 22.2.4.1.1 collate members\n \n+// Doesn't work due to use of literal ISO8859.1 characters.  PR 11439\n+// { dg-do compile { xfail *-*-* } } should be run\n+// { dg-excess-errors \"\" }\n+\n #include <testsuite_hooks.h>\n \n #define main discard_main_1"}, {"sha": "44c0eb77eb324d12c863edb1138fb8325c685cf2", "filename": "libstdc++-v3/testsuite/22_locale/collate/hash/wchar_t/2.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fhash%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fhash%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fhash%2Fwchar_t%2F2.cc?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -20,6 +20,10 @@\n \n // 22.2.4.1.1 collate members\n \n+// Doesn't work due to use of literal ISO8859.1 characters.  PR 11439\n+// { dg-do compile { xfail *-*-* } } should be run\n+// { dg-excess-errors \"\" }\n+\n #include <locale>\n #include <testsuite_hooks.h>\n "}, {"sha": "1a36ca2d7449d4ccf6fe925302427ef67556bf5a", "filename": "libstdc++-v3/testsuite/22_locale/collate/hash/wchar_t/wrapped_env.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fhash%2Fwchar_t%2Fwrapped_env.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fhash%2Fwchar_t%2Fwrapped_env.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fhash%2Fwchar_t%2Fwrapped_env.cc?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -20,6 +20,10 @@\n \n // 22.2.4.1.1 collate members\n \n+// Doesn't work due to use of literal ISO8859.1 characters.  PR 11439\n+// { dg-do compile { xfail *-*-* } } should be run\n+// { dg-excess-errors \"\" }\n+\n #include <testsuite_hooks.h>\n \n #define main discard_main_1"}, {"sha": "0a5f060e621a228ee138a701099995f0da5eb9bb", "filename": "libstdc++-v3/testsuite/22_locale/collate/hash/wchar_t/wrapped_locale.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fhash%2Fwchar_t%2Fwrapped_locale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fhash%2Fwchar_t%2Fwrapped_locale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Fhash%2Fwchar_t%2Fwrapped_locale.cc?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -20,6 +20,10 @@\n \n // 22.2.4.1.1 collate members\n \n+// Doesn't work due to use of literal ISO8859.1 characters.  PR 11439\n+// { dg-do compile { xfail *-*-* } } should be run\n+// { dg-excess-errors \"\" }\n+\n #include <testsuite_hooks.h>\n \n #define main discard_main_1"}, {"sha": "b0a68cf2c6e9be7655426e28b31ce8c98ba7c827", "filename": "libstdc++-v3/testsuite/22_locale/collate/transform/wchar_t/2.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Ftransform%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Ftransform%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Ftransform%2Fwchar_t%2F2.cc?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -20,6 +20,10 @@\n \n // 22.2.4.1.1 collate members\n \n+// Doesn't work due to use of literal ISO8859.1 characters.  PR 11439\n+// { dg-do compile { xfail *-*-* } } should be run\n+// { dg-excess-errors \"\" }\n+\n #include <locale>\n #include <testsuite_hooks.h>\n "}, {"sha": "fb4923958c888528bbf6208d6659a0de0db9da9e", "filename": "libstdc++-v3/testsuite/22_locale/collate/transform/wchar_t/wrapped_env.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Ftransform%2Fwchar_t%2Fwrapped_env.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Ftransform%2Fwchar_t%2Fwrapped_env.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Ftransform%2Fwchar_t%2Fwrapped_env.cc?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -20,6 +20,10 @@\n \n // 22.2.4.1.1 collate members\n \n+// Doesn't work due to use of literal ISO8859.1 characters.  PR 11439\n+// { dg-do compile { xfail *-*-* } } should be run\n+// { dg-excess-errors \"\" }\n+\n #include <testsuite_hooks.h>\n \n #define main discard_main_2"}, {"sha": "11327b3958224cb5cb8538d9915ede80a98301fe", "filename": "libstdc++-v3/testsuite/22_locale/collate/transform/wchar_t/wrapped_locale.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Ftransform%2Fwchar_t%2Fwrapped_locale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cc3a24c237713413070f4a5dc35b55dc2715b8/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Ftransform%2Fwchar_t%2Fwrapped_locale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcollate%2Ftransform%2Fwchar_t%2Fwrapped_locale.cc?ref=e6cc3a24c237713413070f4a5dc35b55dc2715b8", "patch": "@@ -20,6 +20,10 @@\n \n // 22.2.4.1.1 collate members\n \n+// Doesn't work due to use of literal ISO8859.1 characters.  PR 11439\n+// { dg-do compile { xfail *-*-* } } should be run\n+// { dg-excess-errors \"\" }\n+\n #include <testsuite_hooks.h>\n \n #define main discard_main_2"}]}