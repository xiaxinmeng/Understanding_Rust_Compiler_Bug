{"sha": "0080e8929257ca9c0cceeb61e4d30c425b5c9c4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA4MGU4OTI5MjU3Y2E5YzBjY2VlYjYxZTRkMzBjNDI1YjVjOWM0Yg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-07-12T19:41:30Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-12T19:41:30Z"}, "message": "cppexp.c (LOGICAL): Delete macro.\n\n\t* cppexp.c (LOGICAL): Delete macro.\n\t(_cpp_parse_expr): Do not use UNARY for unary +.  Implement ||\n\tand && directly.\n\n\t* cpphash.c (HASHSIZE): Increase to 4096.\n\t(struct hashdummy): Add hash field.\n\t(eq_HASHNODE): Compare unreduced hashes, then lengths, then\n\tthe string values using memcmp.\n\t(cpp_lookup): Set dummy.hash.\n\nFrom-SVN: r34994", "tree": {"sha": "230a45b12a0aeb61272c4410e2c6679f2e10e469", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/230a45b12a0aeb61272c4410e2c6679f2e10e469"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0080e8929257ca9c0cceeb61e4d30c425b5c9c4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0080e8929257ca9c0cceeb61e4d30c425b5c9c4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0080e8929257ca9c0cceeb61e4d30c425b5c9c4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0080e8929257ca9c0cceeb61e4d30c425b5c9c4b/comments", "author": null, "committer": null, "parents": [{"sha": "50ceaae014a3f4259a1d084b6ca720a8954010e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ceaae014a3f4259a1d084b6ca720a8954010e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50ceaae014a3f4259a1d084b6ca720a8954010e8"}], "stats": {"total": 47, "additions": 35, "deletions": 12}, "files": [{"sha": "f61388a44ddb0b1802c2ff39deba175838369ca7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0080e8929257ca9c0cceeb61e4d30c425b5c9c4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0080e8929257ca9c0cceeb61e4d30c425b5c9c4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0080e8929257ca9c0cceeb61e4d30c425b5c9c4b", "patch": "@@ -1,3 +1,15 @@\n+2000-07-12  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppexp.c (LOGICAL): Delete macro.\n+\t(_cpp_parse_expr): Do not use UNARY for unary +.  Implement ||\n+\tand && directly.\n+\n+\t* cpphash.c (HASHSIZE): Increase to 4096.\n+\t(struct hashdummy): Add hash field.\n+\t(eq_HASHNODE): Compare unreduced hashes, then lengths, then\n+\tthe string values using memcmp.\n+\t(cpp_lookup): Set dummy.hash.\n+\n Wed Jul 12 13:15:16 2000  Marc Espie <espie@openbsd.org>\n \n \t* configure.in (m88k-openbsd): Express configuration using new fragment"}, {"sha": "5f141e2c5c09a518083287ad3da3e86119ae64e8", "filename": "gcc/cppexp.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0080e8929257ca9c0cceeb61e4d30c425b5c9c4b/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0080e8929257ca9c0cceeb61e4d30c425b5c9c4b/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=0080e8929257ca9c0cceeb61e4d30c425b5c9c4b", "patch": "@@ -706,10 +706,6 @@ op_to_prio[] =\n   top->value = OP v2; \\\n   top->unsignedp = unsigned2; \\\n   top->flags |= HAVE_VALUE;\n-#define LOGICAL(OP, NEG) \\\n-  top->value = v1 OP v2; \\\n-  top->unsignedp = 0; \\\n-  if (NEG v1) skip_evaluation--;\n #define SHIFT(PSH, MSH) \\\n   if (skip_evaluation)  \\\n     break;\t\t\\\n@@ -834,15 +830,18 @@ _cpp_parse_expr (pfile)\n \t    case CPP_AND:\t BITWISE(&);\tbreak;\n \t    case CPP_XOR:\t BITWISE(^);\tbreak;\n \t    case CPP_OR:\t BITWISE(|);\tbreak;\n-\t    case CPP_AND_AND:\t LOGICAL(&&,!); break;\n-\t    case CPP_OR_OR:\t LOGICAL(||,);\tbreak;\n \t    case CPP_LSHIFT:\t SHIFT(left_shift, right_shift); break;\n \t    case CPP_RSHIFT:\t SHIFT(right_shift, left_shift); break;\n \n \t    case CPP_PLUS:\n \t      if (!(top->flags & HAVE_VALUE))\n \t\t{\n-\t\t  UNARY(/* + */);\t/* K+R C doesn't like unary + */\n+\t\t  /* Can't use UNARY(+) because K+R C did not have unary\n+\t\t     plus.  Can't use UNARY() because some compilers object\n+\t\t     to the empty argument.  */\n+\t\t  top->value = v2;\n+\t\t  top->unsignedp = unsigned2;\n+\t\t  top->flags |= HAVE_VALUE;\n \t\t}\n \t      else\n \t\t{\n@@ -908,6 +907,16 @@ _cpp_parse_expr (pfile)\n \t\t}\n \t      break;\n \n+\t    case CPP_OR_OR:\n+\t      top->value = v1 || v2;\n+\t      top->unsignedp = 0;\n+\t      if (v1) skip_evaluation--;\n+\t      break;\n+\t    case CPP_AND_AND:\n+\t      top->value = v1 && v2;\n+\t      top->unsignedp = 0;\n+\t      if (!v1) skip_evaluation--;\n+\t      break;\n \t    case CPP_COMMA:\n \t      if (CPP_PEDANTIC (pfile))\n \t\tcpp_pedwarn (pfile, \"comma operator in operand of #if\");"}, {"sha": "d18a4158395797f0bd7966d7e129307aca0f902d", "filename": "gcc/cpphash.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0080e8929257ca9c0cceeb61e4d30c425b5c9c4b/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0080e8929257ca9c0cceeb61e4d30c425b5c9c4b/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=0080e8929257ca9c0cceeb61e4d30c425b5c9c4b", "patch": "@@ -37,6 +37,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n struct hashdummy\n {\n   const U_CHAR *name;\n+  unsigned int hash;\n   unsigned short length;\n };\n \n@@ -49,7 +50,7 @@ struct macro_info\n };\n \n /* Initial hash table size.  (It can grow if necessary - see hashtab.c.)  */\n-#define HASHSIZE 500\n+#define HASHSIZE 4096\n \n static unsigned int hash_HASHNODE PARAMS ((const void *));\n static int eq_HASHNODE\t\t  PARAMS ((const void *, const void *));\n@@ -104,7 +105,7 @@ hash_HASHNODE (x)\n    rule that the existing entry is the first argument, the potential\n    entry the second.  It also relies on the comparison function never\n    being called except as a direct consequence of a call to\n-   htab_find(_slot)_with_hash.  */\n+   the htab_find routines.  */\n static int\n eq_HASHNODE (x, y)\n      const void *x;\n@@ -113,8 +114,9 @@ eq_HASHNODE (x, y)\n   const cpp_hashnode *a = (const cpp_hashnode *)x;\n   const struct hashdummy *b = (const struct hashdummy *)y;\n \n-  return (a->length == b->length\n-\t  && !ustrncmp (a->name, b->name, a->length));\n+  return (a->hash == b->hash\n+\t  && a->length == b->length\n+\t  && !memcmp (a->name, b->name, a->length));\n }\n \n /* Find the hash node for name \"name\", of length LEN.  */\n@@ -132,7 +134,7 @@ cpp_lookup (pfile, name, len)\n \n   dummy.name = name;\n   dummy.length = len;\n-  hash = _cpp_calc_hash (name, len);\n+  dummy.hash = hash = _cpp_calc_hash (name, len);\n \n   slot = (cpp_hashnode **)\n     htab_find_slot_with_hash (pfile->hashtab, (void *)&dummy, hash, INSERT);"}]}