{"sha": "995683a614a3a5f3ac8466a6a13776a27d0f0666", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk1NjgzYTYxNGEzYTVmM2FjODQ2NmE2YTEzNzc2YTI3ZDBmMDY2Ng==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T14:12:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T14:12:37Z"}, "message": "[multiple changes]\n\n2014-07-30  Bob Duff  <duff@adacore.com>\n\n\t* g-exctra.adb, g-exctra.ads, s-exctra.adb, s-exctra.ads, Makefile.rtl,\n\tg-trasym.adb, g-trasym.ads, s-trasym.adb, s-trasym.ads: Move\n\tGNAT.Traceback.Symbolic and GNAT.Exception_Traces into the System\n\thierarchy (System.Traceback.Symbolic and System.Exception_Traces), so\n\twe can call them from the runtimes. Leave renamings in place under GNAT.\n\n2014-07-30  Yannick Moy  <moy@adacore.com>\n\n\t* inline.adb (Check_And_Build_Body_To_Inline): Include code for\n\tinlining in GNATprove mode.\n\n2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-cohase.adb, a-cohase.ads (Generic_Keys): Add a\n\tReference_Control_Type to generic package, to keep additional\n\tinformation for Reference_Types that manipulate keys. Add Adjust and\n\tFinalize procedures for this type.\n\t(Delete_Node): New procedure called when finalizing a\n\tReference_Control_Type, to remove a node whose element has been\n\timproperly updated through a Reference.\n\t(Insert): Detect tampering.\n\t(Reference_Preserving_Key): Build proper Reference_Control_Type,\n\tand update Busy and Lock bits to detect tampering.\n\n2014-07-30  Bob Duff  <duff@adacore.com>\n\n\t* exp_intr.ads: Minor comment fix.\n\nFrom-SVN: r213276", "tree": {"sha": "8439071ec216e8e7e5e38d76037ef763d0436196", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8439071ec216e8e7e5e38d76037ef763d0436196"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/995683a614a3a5f3ac8466a6a13776a27d0f0666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/995683a614a3a5f3ac8466a6a13776a27d0f0666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/995683a614a3a5f3ac8466a6a13776a27d0f0666", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/995683a614a3a5f3ac8466a6a13776a27d0f0666/comments", "author": null, "committer": null, "parents": [{"sha": "793c5f05923d8faf0005ae1c100777f46554537a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/793c5f05923d8faf0005ae1c100777f46554537a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/793c5f05923d8faf0005ae1c100777f46554537a"}], "stats": {"total": 1013, "additions": 717, "deletions": 296}, "files": [{"sha": "d216f82fccb758453bf2e0b0ac2430fe538235e3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -1,3 +1,33 @@\n+2014-07-30  Bob Duff  <duff@adacore.com>\n+\n+\t* g-exctra.adb, g-exctra.ads, s-exctra.adb, s-exctra.ads, Makefile.rtl,\n+\tg-trasym.adb, g-trasym.ads, s-trasym.adb, s-trasym.ads: Move\n+\tGNAT.Traceback.Symbolic and GNAT.Exception_Traces into the System\n+\thierarchy (System.Traceback.Symbolic and System.Exception_Traces), so\n+\twe can call them from the runtimes. Leave renamings in place under GNAT.\n+\n+2014-07-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* inline.adb (Check_And_Build_Body_To_Inline): Include code for\n+\tinlining in GNATprove mode.\n+\n+2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-cohase.adb, a-cohase.ads (Generic_Keys): Add a\n+\tReference_Control_Type to generic package, to keep additional\n+\tinformation for Reference_Types that manipulate keys. Add Adjust and\n+\tFinalize procedures for this type.\n+\t(Delete_Node): New procedure called when finalizing a\n+\tReference_Control_Type, to remove a node whose element has been\n+\timproperly updated through a Reference.\n+\t(Insert): Detect tampering.\n+\t(Reference_Preserving_Key): Build proper Reference_Control_Type,\n+\tand update Busy and Lock bits to detect tampering.\n+\n+2014-07-30  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_intr.ads: Minor comment fix.\n+\n 2014-07-30  Gary Dismukes  <dismukes@adacore.com>\n \n \t* exp_prag.adb, a-tags.ads: Minor typo fixes."}, {"sha": "4798864e9f4e4d4080620941a9cac2e8848a2b8f", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -408,6 +408,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-excact$(objext) \\\n   g-except$(objext) \\\n   g-exctra$(objext) \\\n+  s-exctra$(objext) \\\n   g-expect$(objext) \\\n   g-exptty$(objext) \\\n   g-flocon$(objext) \\\n@@ -458,6 +459,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-timsta$(objext) \\\n   g-traceb$(objext) \\\n   g-trasym$(objext) \\\n+  s-trasym$(objext) \\\n   g-tty$(objext) \\\n   g-u3spch$(objext) \\\n   g-utf_32$(objext) \\"}, {"sha": "421ac3e63e0a8bf177a1b0d6bb4fee28e340a9ed", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 139, "deletions": 10, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -132,6 +132,16 @@ package body Ada.Containers.Hashed_Sets is\n    procedure Write_Nodes is\n       new HT_Ops.Generic_Write (Write_Node);\n \n+   procedure Delete_Node\n+     (C    : in out Set;\n+      Indx : Hash_Type;\n+      X    : in out Node_Access);\n+\n+   --  Delete a node whose bucket position is known. Used to remove a node\n+   --  whose element has been modified through a key_preserving reference.\n+   --  We cannot use the value of the element precisely because the current\n+   --  value does not correspond to the hash code that determines the bucket.\n+\n    ---------\n    -- \"=\" --\n    ---------\n@@ -328,6 +338,48 @@ package body Ada.Containers.Hashed_Sets is\n       Position.Container := null;\n    end Delete;\n \n+   procedure Delete_Node\n+     (C    : in out Set;\n+      Indx : Hash_Type;\n+      X    : in out Node_Access)\n+   is\n+      HT   : Hash_Table_Type renames C.HT;\n+      Prev : Node_Access;\n+      Curr : Node_Access;\n+\n+   begin\n+      Prev := HT.Buckets (Indx);\n+      if Prev = X then\n+         HT.Buckets (Indx) := Next (Prev);\n+         HT.Length := HT.Length - 1;\n+         Free (X);\n+         return;\n+      end if;\n+\n+      if HT.Length = 1 then\n+         raise Program_Error with\n+           \"attempt to delete node not in its proper hash bucket\";\n+      end if;\n+\n+      loop\n+         Curr := Next (Prev);\n+\n+         if Curr = null then\n+            raise Program_Error with\n+              \"attempt to delete node not in its proper hash bucket\";\n+         end if;\n+\n+         if Curr = X then\n+            Set_Next (Node => Prev, Next => Next (Curr));\n+            HT.Length := HT.Length - 1;\n+            Free (X);\n+            return;\n+         end if;\n+         Prev := Curr;\n+      end loop;\n+\n+   end Delete_Node;\n+\n    ----------------\n    -- Difference --\n    ----------------\n@@ -824,6 +876,11 @@ package body Ada.Containers.Hashed_Sets is\n          HT_Ops.Reserve_Capacity (HT, 1);\n       end if;\n \n+      if HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt tp tamper with cursors (set is busy)\";\n+      end if;\n+\n       Local_Insert (HT, New_Item, Node, Inserted);\n \n       if Inserted\n@@ -1921,6 +1978,24 @@ package body Ada.Containers.Hashed_Sets is\n       -- Local Subprograms --\n       -----------------------\n \n+      ------------\n+      -- Adjust --\n+      ------------\n+\n+      procedure Adjust (Control : in out Reference_Control_Type) is\n+      begin\n+         if Control.Container /= null then\n+            declare\n+               HT : Hash_Table_Type renames Control.Container.all.HT;\n+               B : Natural renames HT.Busy;\n+               L : Natural renames HT.Lock;\n+            begin\n+               B := B + 1;\n+               L := L + 1;\n+            end;\n+         end if;\n+      end Adjust;\n+\n       function Equivalent_Key_Node\n         (Key  : Key_Type;\n          Node : Node_Access) return Boolean;\n@@ -2046,6 +2121,33 @@ package body Ada.Containers.Hashed_Sets is\n          Free (X);\n       end Exclude;\n \n+      --------------\n+      -- Finalize --\n+      --------------\n+\n+      procedure Finalize (Control : in out Reference_Control_Type) is\n+      begin\n+         if Control.Container /= null then\n+            declare\n+               HT : Hash_Table_Type renames Control.Container.all.HT;\n+               B : Natural renames HT.Busy;\n+               L : Natural renames HT.Lock;\n+            begin\n+               B := B - 1;\n+               L := L - 1;\n+            end;\n+\n+            if Hash (Key (Element (Control.Old_Pos))) /= Control.Old_Hash\n+            then\n+               Delete_Node\n+                (Control.Container.all, Control.Index,  Control.Old_Pos.Node);\n+               raise Program_Error with \"key not preserved in reference\";\n+            end if;\n+\n+            Control.Container := null;\n+         end if;\n+      end Finalize;\n+\n       ----------\n       -- Find --\n       ----------\n@@ -2115,11 +2217,24 @@ package body Ada.Containers.Hashed_Sets is\n            (Vet (Position),\n             \"bad cursor in function Reference_Preserving_Key\");\n \n-         --  Some form of finalization will be required in order to actually\n-         --  check that the key-part of the element designated by Position has\n-         --  not changed.  ???\n-\n-         return (Element => Position.Node.Element'Access);\n+         declare\n+            HT : Hash_Table_Type renames Position.Container.all.HT;\n+            B : Natural renames HT.Busy;\n+            L : Natural renames HT.Lock;\n+         begin\n+            return R : constant Reference_Type :=\n+                (Element  => Position.Node.Element'Access,\n+                  Control  =>\n+                    (Controlled with\n+                       Container'Unrestricted_Access,\n+                       Index  => HT_Ops.Index (HT, Position.Node),\n+                       Old_Pos => Position,\n+                       Old_Hash => Hash (Key (Position))))\n+            do\n+               B := B + 1;\n+               L := L + 1;\n+            end return;\n+         end;\n       end Reference_Preserving_Key;\n \n       function Reference_Preserving_Key\n@@ -2133,11 +2248,25 @@ package body Ada.Containers.Hashed_Sets is\n             raise Constraint_Error with \"Key not in set\";\n          end if;\n \n-         --  Some form of finalization will be required in order to actually\n-         --  check that the key-part of the element designated by Key has not\n-         --  changed.  ???\n-\n-         return (Element => Node.Element'Access);\n+         declare\n+            HT : Hash_Table_Type renames Container.HT;\n+            B : Natural renames HT.Busy;\n+            L : Natural renames HT.Lock;\n+            P : constant Cursor := Find (Container, Key);\n+         begin\n+            return R : constant Reference_Type :=\n+              (Element  => Node.Element'Access,\n+               Control  =>\n+                 (Controlled with\n+                   Container'Unrestricted_Access,\n+                   Index  => HT_Ops.Index (HT, P.Node),\n+                   Old_Pos => P,\n+                   Old_Hash => Hash (Key)))\n+            do\n+               B := B + 1;\n+               L := L + 1;\n+            end return;\n+         end;\n       end Reference_Preserving_Key;\n \n       -------------"}, {"sha": "9e40f0e06b8207b3649e9b9f4a49c64f9f7514fb", "filename": "gcc/ada/a-cohase.ads", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -35,7 +35,7 @@ with Ada.Iterator_Interfaces;\n \n private with Ada.Containers.Hash_Tables;\n private with Ada.Streams;\n-private with Ada.Finalization;\n+with Ada.Finalization;\n \n generic\n    type Element_Type is private;\n@@ -433,10 +433,44 @@ package Ada.Containers.Hashed_Sets is\n          Key       : Key_Type) return Reference_Type;\n \n    private\n-      type Reference_Type (Element : not null access Element_Type)\n-         is null record;\n-\n       use Ada.Streams;\n+      type Set_Access is access all Set;\n+      for Set_Access'Storage_Size use 0;\n+\n+      --  Key_Preserving references must carry information to allow removal\n+      --  of elements whose value may have been altered improperly, i.e. have\n+      --  been given values incompatible with the hash-code of the previous\n+      --  value, and are thus in the wrong bucket. (RM 18.7 (96.6/3))\n+\n+      --  We cannot store the key directly because it is an unconstrained type.\n+      --  To avoid using additional dynamic allocation we store the old cursor\n+      --  which simplifies possible removal. This is not possible for some\n+      --  other set types.\n+\n+      --  The mechanism is different for Update_Element_Preserving_Key, as\n+      --  in that case the check that buckets have not changed is performed\n+      --  at the time of the update, not when the reference is finalized.\n+\n+      type Reference_Control_Type is\n+         new Ada.Finalization.Controlled with\n+      record\n+         Container : Set_Access;\n+         Index     : Hash_Type;\n+         Old_Pos   : Cursor;\n+         Old_Hash  : Hash_Type;\n+      end record;\n+\n+      overriding procedure\n+         Adjust (Control : in out Reference_Control_Type);\n+      pragma Inline (Adjust);\n+\n+      overriding procedure\n+         Finalize (Control : in out Reference_Control_Type);\n+      pragma Inline (Finalize);\n+\n+      type Reference_Type (Element : not null access Element_Type) is record\n+         Control  : Reference_Control_Type;\n+      end record;\n \n       procedure Read\n         (Stream : not null access Root_Stream_Type'Class;\n@@ -449,7 +483,6 @@ package Ada.Containers.Hashed_Sets is\n          Item   : Reference_Type);\n \n       for Reference_Type'Write use Write;\n-\n    end Generic_Keys;\n \n private\n@@ -498,6 +531,10 @@ private\n       Node      : Node_Access;\n    end record;\n \n+   type Reference_Control_Type is new Ada.Finalization.Controlled with record\n+      Container : Set_Access;\n+   end record;\n+\n    procedure Write\n      (Stream : not null access Root_Stream_Type'Class;\n       Item   : Cursor);\n@@ -510,11 +547,6 @@ private\n \n    for Cursor'Read use Read;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : Set_Access;\n-      end record;\n-\n    overriding procedure Adjust (Control : in out Reference_Control_Type);\n    pragma Inline (Adjust);\n "}, {"sha": "1285f4ffc0728d0cfb05570aa5d75c3d3eb7d72b", "filename": "gcc/ada/exp_intr.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fexp_intr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fexp_intr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.ads?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,9 +32,9 @@ package Exp_Intr is\n    procedure Expand_Intrinsic_Call (N : Node_Id; E : Entity_Id);\n    --  N is either a function call node, a procedure call statement node, or\n    --  an operator where the corresponding subprogram is intrinsic (i.e. was\n-   --  the subject of a Import or Interface pragma specifying the subprogram\n-   --  as intrinsic.  The effect is to replace the call with appropriate\n-   --  specialized nodes.  The second argument is the entity for the\n+   --  the subject of an Import or Interface pragma specifying the subprogram\n+   --  as intrinsic. The effect is to replace the call with appropriate\n+   --  specialized nodes. The second argument is the entity for the\n    --  subprogram spec.\n \n end Exp_Intr;"}, {"sha": "8844fcf09e9dad8662f4b19c21d421eb6d9daf39", "filename": "gcc/ada/g-exctra.adb", "status": "modified", "additions": 5, "deletions": 86, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fg-exctra.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fg-exctra.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-exctra.adb?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2010, AdaCore                     --\n+--                     Copyright (C) 2000-2014, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,89 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Standard_Library; use System.Standard_Library;\n-with System.Soft_Links;       use System.Soft_Links;\n+--  This package does not require a body, since it is a package renaming. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-package body GNAT.Exception_Traces is\n-\n-   --  Calling the decorator directly from where it is needed would require\n-   --  introducing nasty dependencies upon the spec of this package (typically\n-   --  in a-except.adb). We also have to deal with the fact that the traceback\n-   --  array within an exception occurrence and the one the decorator shall\n-   --  accept are of different types. These are two reasons for which a wrapper\n-   --  with a System.Address argument is indeed used to call the decorator\n-   --  provided by the user of this package. This wrapper is called via a\n-   --  soft-link, which either is null when no decorator is in place or \"points\n-   --  to\" the following function otherwise.\n-\n-   function Decorator_Wrapper\n-     (Traceback : System.Address;\n-      Len       : Natural) return String;\n-   --  The wrapper to be called when a decorator is in place for exception\n-   --  backtraces.\n-   --\n-   --  Traceback is the address of the call chain array as stored in the\n-   --  exception occurrence and Len is the number of significant addresses\n-   --  contained in this array.\n-\n-   Current_Decorator : Traceback_Decorator := null;\n-   --  The decorator to be called by the wrapper when it is not null, as set\n-   --  by Set_Trace_Decorator. When this access is null, the wrapper is null\n-   --  also and shall then not be called.\n-\n-   -----------------------\n-   -- Decorator_Wrapper --\n-   -----------------------\n-\n-   function Decorator_Wrapper\n-     (Traceback : System.Address;\n-      Len       : Natural) return String\n-   is\n-      Decorator_Traceback : Tracebacks_Array (1 .. Len);\n-      for Decorator_Traceback'Address use Traceback;\n-\n-      --  Handle the \"transition\" from the array stored in the exception\n-      --  occurrence to the array expected by the decorator.\n-\n-      pragma Import (Ada, Decorator_Traceback);\n-\n-   begin\n-      return Current_Decorator.all (Decorator_Traceback);\n-   end Decorator_Wrapper;\n-\n-   -------------------------\n-   -- Set_Trace_Decorator --\n-   -------------------------\n-\n-   procedure Set_Trace_Decorator (Decorator : Traceback_Decorator) is\n-   begin\n-      Current_Decorator := Decorator;\n-      Traceback_Decorator_Wrapper :=\n-        (if Current_Decorator /= null\n-         then Decorator_Wrapper'Access else null);\n-   end Set_Trace_Decorator;\n-\n-   ---------------\n-   -- Trace_Off --\n-   ---------------\n-\n-   procedure Trace_Off is\n-   begin\n-      Exception_Trace := RM_Convention;\n-   end Trace_Off;\n-\n-   --------------\n-   -- Trace_On --\n-   --------------\n-\n-   procedure Trace_On (Kind : Trace_Kind) is\n-   begin\n-      case Kind is\n-         when Every_Raise =>\n-            Exception_Trace := Every_Raise;\n-         when Unhandled_Raise =>\n-            Exception_Trace := Unhandled_Raise;\n-      end case;\n-   end Trace_On;\n-\n-end GNAT.Exception_Traces;\n+pragma No_Body;"}, {"sha": "aa264ba12a05ee7ff5d2d92c80fc303d15372f5e", "filename": "gcc/ada/g-exctra.ads", "status": "modified", "additions": 5, "deletions": 62, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fg-exctra.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fg-exctra.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-exctra.ads?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2010, AdaCore                     --\n+--                     Copyright (C) 2000-2014, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,66 +31,9 @@\n \n --  This package provides an interface allowing to control *automatic* output\n --  to standard error upon exception occurrences (as opposed to explicit\n---  generation of traceback information using GNAT.Traceback).\n+--  generation of traceback information using System.Traceback).\n \n---  This output includes the basic information associated with the exception\n---  (name, message) as well as a backtrace of the call chain at the point\n---  where the exception occurred. This backtrace is only output if the call\n---  chain information is available, depending if the binder switch dedicated\n---  to that purpose has been used or not.\n+--  See file s-exctra.ads for full documentation of the interface\n \n---  The default backtrace is in the form of absolute code locations which may\n---  be converted to corresponding source locations using the addr2line utility\n---  or from within GDB. Please refer to GNAT.Traceback for information about\n---  what is necessary to be able to exploit this possibility.\n-\n---  The backtrace output can also be customized by way of a \"decorator\" which\n---  may return any string output in association with a provided call chain.\n---  The decorator replaces the default backtrace mentioned above.\n-\n-with GNAT.Traceback; use GNAT.Traceback;\n-\n-package GNAT.Exception_Traces is\n-\n-   --  The following defines the exact situations in which raises will\n-   --  cause automatic output of trace information.\n-\n-   type Trace_Kind is\n-     (Every_Raise,\n-      --  Denotes the initial raise event for any exception occurrence, either\n-      --  explicit or due to a specific language rule, within the context of a\n-      --  task or not.\n-\n-      Unhandled_Raise\n-      --  Denotes the raise events corresponding to exceptions for which there\n-      --  is no user defined handler, in particular, when a task dies due to an\n-      --  unhandled exception.\n-     );\n-\n-   --  The following procedures can be used to activate and deactivate\n-   --  traces identified by the above trace kind values.\n-\n-   procedure Trace_On (Kind : Trace_Kind);\n-   --  Activate the traces denoted by Kind\n-\n-   procedure Trace_Off;\n-   --  Stop the tracing requested by the last call to Trace_On.\n-   --  Has no effect if no such call has ever occurred.\n-\n-   --  The following provide the backtrace decorating facilities\n-\n-   type Traceback_Decorator is access\n-     function (Traceback : Tracebacks_Array) return String;\n-   --  A backtrace decorator is a function which returns the string to be\n-   --  output for a call chain provided by way of a tracebacks array.\n-\n-   procedure Set_Trace_Decorator (Decorator : Traceback_Decorator);\n-   --  Set the decorator to be used for future automatic outputs. Restore\n-   --  the default behavior (output of raw addresses) if the provided\n-   --  access value is null.\n-   --\n-   --  Note: GNAT.Traceback.Symbolic.Symbolic_Traceback may be used as the\n-   --  Decorator, to get a symbolic traceback. This will cause a significant\n-   --  cpu and memory overhead.\n-\n-end GNAT.Exception_Traces;\n+with System.Exception_Traces;\n+package GNAT.Exception_Traces renames System.Exception_Traces;"}, {"sha": "3fdfd1adad73fdc55916b60db072507e778f45bb", "filename": "gcc/ada/g-trasym.adb", "status": "modified", "additions": 4, "deletions": 47, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fg-trasym.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fg-trasym.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym.adb?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -29,51 +29,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the default implementation for platforms where the full capability\n---  is not supported. It returns tracebacks as lists of LF separated strings of\n---  the form \"0x...\" corresponding to the addresses.\n+--  This package does not require a body, since it is a package renaming. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not interfere.\n \n-with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;\n-with System.Address_Image;\n-\n-package body GNAT.Traceback.Symbolic is\n-\n-   ------------------------\n-   -- Symbolic_Traceback --\n-   ------------------------\n-\n-   function Symbolic_Traceback (Traceback : Tracebacks_Array) return String is\n-   begin\n-      if Traceback'Length = 0 then\n-         return \"\";\n-\n-      else\n-         declare\n-            Img : String := System.Address_Image (Traceback (Traceback'First));\n-\n-            Result : String (1 .. (Img'Length + 3) * Traceback'Length);\n-            Last   : Natural := 0;\n-\n-         begin\n-            for J in Traceback'Range loop\n-               Img := System.Address_Image (Traceback (J));\n-               Result (Last + 1 .. Last + 2) := \"0x\";\n-               Last := Last + 2;\n-               Result (Last + 1 .. Last + Img'Length) := Img;\n-               Last := Last + Img'Length + 1;\n-               Result (Last) := ASCII.LF;\n-            end loop;\n-\n-            return Result (1 .. Last);\n-         end;\n-      end if;\n-   end Symbolic_Traceback;\n-\n-   function Symbolic_Traceback\n-     (E : Ada.Exceptions.Exception_Occurrence) return String\n-   is\n-   begin\n-      return Symbolic_Traceback (Tracebacks (E));\n-   end Symbolic_Traceback;\n-\n-end GNAT.Traceback.Symbolic;\n+pragma No_Body;"}, {"sha": "1d9b3f7ec211f110bec25ee685e6b5040de58ce9", "filename": "gcc/ada/g-trasym.ads", "status": "modified", "additions": 3, "deletions": 67, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fg-trasym.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fg-trasym.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym.ads?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -31,71 +31,7 @@\n \n --  Run-time symbolic traceback support\n \n---  The full capability is currently supported on the following targets:\n+--  See file s-trasym.ads for full documentation of the interface\n \n---     HP-UX ia64\n---     GNU/Linux x86, x86_64, ia64\n---     FreeBSD x86, x86_64\n---     Solaris sparc and x86\n---     OpenVMS Alpha and ia64\n---     Windows\n-\n---  Note: on targets other than those listed above, a dummy implementation of\n---  the body returns a series of LF separated strings of the form \"0x...\"\n---  corresponding to the addresses.\n-\n---  The routines provided in this package assume that your application has\n---  been compiled with debugging information turned on, since this information\n---  is used to build a symbolic traceback.\n-\n---  If you want to retrieve tracebacks from exception occurrences, it is also\n---  necessary to invoke the binder with -E switch. Please refer to the gnatbind\n---  documentation for more information.\n-\n---  Note that it is also possible (and often recommended) to compute symbolic\n---  traceback outside the program execution, which in addition allows you\n---  to distribute the executable with no debug info:\n---\n---  - build your executable with debug info\n---  - archive this executable\n---  - strip a copy of the executable and distribute/deploy this version\n---  - at run time, compute absolute traceback (-bargs -E) from your\n---    executable and log it using Ada.Exceptions.Exception_Information\n---  - off line, compute the symbolic traceback using the executable archived\n---    with debug info and addr2line or gdb (using info line *<addr>) on the\n---    absolute addresses logged by your application.\n-\n---  In order to retrieve symbolic information, functions in this package will\n---  read on disk all the debug information of the executable file (found via\n---  Argument (0), and looked in the PATH if needed) or shared libraries using\n---  OS facilities, and load them in memory, causing a significant cpu and\n---  memory overhead.\n-\n---  Symbolic traceback from shared libraries is only supported for VMS, Windows\n---  and GNU/Linux. On other targets symbolic tracebacks are only supported for\n---  the main executable. You should consider using gdb to obtain symbolic\n---  traceback in such cases.\n-\n---  On VMS, there is no restriction on using this facility with shared\n---  libraries. However, the OS should be at least v7.3-1 and OS patch\n---  VMS731_TRACE-V0100 must be applied in order to use this package.\n-\n---  On platforms where the full capability is not supported, function\n---  Symbolic_Traceback return a list of addresses expressed as \"0x...\"\n---  separated by line feed.\n-\n-with Ada.Exceptions;\n-\n-package GNAT.Traceback.Symbolic is\n-   pragma Elaborate_Body;\n-\n-   function Symbolic_Traceback (Traceback : Tracebacks_Array) return String;\n-   --  Build a string containing a symbolic traceback of the given call chain.\n-   --  Note: This procedure may be installed by Set_Trace_Decorator, to get a\n-   --  symbolic traceback on all exceptions raised (see GNAT.Exception_Traces).\n-\n-   function Symbolic_Traceback\n-     (E : Ada.Exceptions.Exception_Occurrence) return String;\n-   --  Build string containing symbolic traceback of given exception occurrence\n-\n-end GNAT.Traceback.Symbolic;\n+with System.Traceback.Symbolic;\n+package GNAT.Traceback.Symbolic renames System.Traceback.Symbolic;"}, {"sha": "315a21d390671a0231189737c45ae41f765618e3", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 108, "deletions": 10, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -1938,6 +1938,11 @@ package body Inline is\n          --  Return True if some enclosing body contains instantiations that\n          --  appear before the corresponding generic body.\n \n+         function Has_Single_Return_In_GNATprove_Mode return Boolean;\n+         --  This function is called only in GNATprove mode, and it returns\n+         --  True if the subprogram has no or a single return statement as\n+         --  last statement.\n+\n          function Returns_Compile_Time_Constant (N : Node_Id) return Boolean;\n          --  Return True if all the return statements of the function body N\n          --  are simple return statements and return a compile time constant\n@@ -1999,18 +2004,48 @@ package body Inline is\n          begin\n             D := First (Decls);\n             while Present (D) loop\n-               if (Nkind (D) = N_Function_Instantiation\n-                    and then not Is_Unchecked_Conversion (D))\n-                 or else Nkind_In (D, N_Protected_Type_Declaration,\n-                                   N_Package_Declaration,\n-                                   N_Package_Instantiation,\n-                                   N_Subprogram_Body,\n-                                   N_Procedure_Instantiation,\n-                                   N_Task_Type_Declaration)\n+               if Nkind (D) = N_Function_Instantiation\n+                 and then not Is_Unchecked_Conversion (D)\n                then\n                   Cannot_Inline\n-                    (\"cannot inline & (non-allowed declaration)?\", D, Subp);\n+                    (\"cannot inline & (nested function instantiation)?\",\n+                     D, Subp);\n+                  return True;\n+\n+               elsif Nkind (D) = N_Protected_Type_Declaration then\n+                  Cannot_Inline\n+                    (\"cannot inline & (nested protected type declaration)?\",\n+                     D, Subp);\n+                  return True;\n+\n+               elsif Nkind (D) = N_Package_Declaration then\n+                  Cannot_Inline\n+                    (\"cannot inline & (nested package declaration)?\",\n+                     D, Subp);\n+                  return True;\n \n+               elsif Nkind (D) = N_Package_Instantiation then\n+                  Cannot_Inline\n+                    (\"cannot inline & (nested package instantiation)?\",\n+                     D, Subp);\n+                  return True;\n+\n+               elsif Nkind (D) = N_Subprogram_Body then\n+                  Cannot_Inline\n+                    (\"cannot inline & (nested subprogram)?\",\n+                     D, Subp);\n+                  return True;\n+\n+               elsif Nkind (D) = N_Procedure_Instantiation then\n+                  Cannot_Inline\n+                    (\"cannot inline & (nested procedure instantiation)?\",\n+                     D, Subp);\n+                  return True;\n+\n+               elsif Nkind (D) = N_Task_Type_Declaration then\n+                  Cannot_Inline\n+                    (\"cannot inline & (nested task type declaration)?\",\n+                     D, Subp);\n                   return True;\n                end if;\n \n@@ -2158,6 +2193,58 @@ package body Inline is\n             return False;\n          end Has_Pending_Instantiation;\n \n+         -----------------------------------------\n+         -- Has_Single_Return_In_GNATprove_Mode --\n+         -----------------------------------------\n+\n+         function Has_Single_Return_In_GNATprove_Mode return Boolean is\n+            Last_Statement : Node_Id := Empty;\n+\n+            function Check_Return (N : Node_Id) return Traverse_Result;\n+            --  Returns OK on node N if this is not a return statement\n+            --  different from the last statement in the subprogram.\n+\n+            ------------------\n+            -- Check_Return --\n+            ------------------\n+\n+            function Check_Return (N : Node_Id) return Traverse_Result is\n+            begin\n+               if Nkind_In (N, N_Simple_Return_Statement,\n+                            N_Extended_Return_Statement)\n+               then\n+                  if N = Last_Statement then\n+                     return OK;\n+                  else\n+                     return Abandon;\n+                  end if;\n+\n+               else\n+                  return OK;\n+               end if;\n+            end Check_Return;\n+\n+            function Check_All_Returns is new Traverse_Func (Check_Return);\n+\n+         --  Start of processing for Has_Single_Return_In_GNATprove_Mode\n+\n+         begin\n+            --  Retrieve last statement inside possible block statements\n+\n+            Last_Statement :=\n+              Last (Statements (Handled_Statement_Sequence (N)));\n+\n+            while Nkind (Last_Statement) = N_Block_Statement loop\n+               Last_Statement := Last\n+                 (Statements (Handled_Statement_Sequence (Last_Statement)));\n+            end loop;\n+\n+            --  Check that the last statement is the only possible return\n+            --  statement in the subprogram.\n+\n+            return Check_All_Returns (N) = OK;\n+         end Has_Single_Return_In_GNATprove_Mode;\n+\n          ------------------------------------\n          --  Returns_Compile_Time_Constant --\n          ------------------------------------\n@@ -2356,6 +2443,16 @@ package body Inline is\n          elsif Present (Body_To_Inline (Decl)) then\n             return False;\n \n+         --  Subprograms that have return statements in the middle of the\n+         --  body are inlined with gotos. GNATprove does not currently\n+         --  support gotos, so we prevent such inlining.\n+\n+         elsif GNATprove_Mode\n+           and then not Has_Single_Return_In_GNATprove_Mode\n+         then\n+            Cannot_Inline (\"cannot inline & (multiple returns)?\", N, Subp);\n+            return False;\n+\n          --  No action needed if the subprogram does not fulfill the minimum\n          --  conditions to be inlined by the frontend\n \n@@ -2396,7 +2493,8 @@ package body Inline is\n          --  on inlining (forbidden declarations, handlers, etc).\n \n          if Front_End_Inlining\n-           and then not Has_Pragma_Inline_Always (Subp)\n+           and then\n+             not (Has_Pragma_Inline_Always (Subp) or else GNATprove_Mode)\n            and then Stat_Count > Max_Size\n          then\n             Cannot_Inline (\"cannot inline& (body too large)?\", N, Subp);"}, {"sha": "234b726ac5cd6047d1db27fe8de63589dbc88491", "filename": "gcc/ada/s-exctra.adb", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fs-exctra.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fs-exctra.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-exctra.adb?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -0,0 +1,117 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                S Y S T E M . E X C E P T I O N _ T R A C E S             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2000-2014, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Standard_Library; use System.Standard_Library;\n+with System.Soft_Links;       use System.Soft_Links;\n+\n+package body System.Exception_Traces is\n+\n+   --  Calling the decorator directly from where it is needed would require\n+   --  introducing nasty dependencies upon the spec of this package (typically\n+   --  in a-except.adb). We also have to deal with the fact that the traceback\n+   --  array within an exception occurrence and the one the decorator shall\n+   --  accept are of different types. These are two reasons for which a wrapper\n+   --  with a System.Address argument is indeed used to call the decorator\n+   --  provided by the user of this package. This wrapper is called via a\n+   --  soft-link, which either is null when no decorator is in place or \"points\n+   --  to\" the following function otherwise.\n+\n+   function Decorator_Wrapper\n+     (Traceback : System.Address;\n+      Len       : Natural) return String;\n+   --  The wrapper to be called when a decorator is in place for exception\n+   --  backtraces.\n+   --\n+   --  Traceback is the address of the call chain array as stored in the\n+   --  exception occurrence and Len is the number of significant addresses\n+   --  contained in this array.\n+\n+   Current_Decorator : Traceback_Decorator := null;\n+   --  The decorator to be called by the wrapper when it is not null, as set\n+   --  by Set_Trace_Decorator. When this access is null, the wrapper is null\n+   --  also and shall then not be called.\n+\n+   -----------------------\n+   -- Decorator_Wrapper --\n+   -----------------------\n+\n+   function Decorator_Wrapper\n+     (Traceback : System.Address;\n+      Len       : Natural) return String\n+   is\n+      Decorator_Traceback : Traceback_Entries.Tracebacks_Array (1 .. Len);\n+      for Decorator_Traceback'Address use Traceback;\n+\n+      --  Handle the \"transition\" from the array stored in the exception\n+      --  occurrence to the array expected by the decorator.\n+\n+      pragma Import (Ada, Decorator_Traceback);\n+\n+   begin\n+      return Current_Decorator.all (Decorator_Traceback);\n+   end Decorator_Wrapper;\n+\n+   -------------------------\n+   -- Set_Trace_Decorator --\n+   -------------------------\n+\n+   procedure Set_Trace_Decorator (Decorator : Traceback_Decorator) is\n+   begin\n+      Current_Decorator := Decorator;\n+      Traceback_Decorator_Wrapper :=\n+        (if Current_Decorator /= null\n+         then Decorator_Wrapper'Access else null);\n+   end Set_Trace_Decorator;\n+\n+   ---------------\n+   -- Trace_Off --\n+   ---------------\n+\n+   procedure Trace_Off is\n+   begin\n+      Exception_Trace := RM_Convention;\n+   end Trace_Off;\n+\n+   --------------\n+   -- Trace_On --\n+   --------------\n+\n+   procedure Trace_On (Kind : Trace_Kind) is\n+   begin\n+      case Kind is\n+         when Every_Raise =>\n+            Exception_Trace := Every_Raise;\n+         when Unhandled_Raise =>\n+            Exception_Trace := Unhandled_Raise;\n+      end case;\n+   end Trace_On;\n+\n+end System.Exception_Traces;"}, {"sha": "956f531284ce23e77e1261a5396c21912ff496c2", "filename": "gcc/ada/s-exctra.ads", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fs-exctra.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fs-exctra.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-exctra.ads?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -0,0 +1,96 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                S Y S T E M . E X C E P T I O N _ T R A C E S             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 2000-2014, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an interface allowing to control *automatic* output\n+--  to standard error upon exception occurrences (as opposed to explicit\n+--  generation of traceback information using System.Traceback).\n+\n+--  This output includes the basic information associated with the exception\n+--  (name, message) as well as a backtrace of the call chain at the point\n+--  where the exception occurred. This backtrace is only output if the call\n+--  chain information is available, depending if the binder switch dedicated\n+--  to that purpose has been used or not.\n+\n+--  The default backtrace is in the form of absolute code locations which may\n+--  be converted to corresponding source locations using the addr2line utility\n+--  or from within GDB. Please refer to System.Traceback for information about\n+--  what is necessary to be able to exploit this possibility.\n+\n+--  The backtrace output can also be customized by way of a \"decorator\" which\n+--  may return any string output in association with a provided call chain.\n+--  The decorator replaces the default backtrace mentioned above.\n+\n+with System.Traceback_Entries;\n+\n+package System.Exception_Traces is\n+\n+   --  The following defines the exact situations in which raises will\n+   --  cause automatic output of trace information.\n+\n+   type Trace_Kind is\n+     (Every_Raise,\n+      --  Denotes the initial raise event for any exception occurrence, either\n+      --  explicit or due to a specific language rule, within the context of a\n+      --  task or not.\n+\n+      Unhandled_Raise\n+      --  Denotes the raise events corresponding to exceptions for which there\n+      --  is no user defined handler, in particular, when a task dies due to an\n+      --  unhandled exception.\n+     );\n+\n+   --  The following procedures can be used to activate and deactivate\n+   --  traces identified by the above trace kind values.\n+\n+   procedure Trace_On (Kind : Trace_Kind);\n+   --  Activate the traces denoted by Kind\n+\n+   procedure Trace_Off;\n+   --  Stop the tracing requested by the last call to Trace_On.\n+   --  Has no effect if no such call has ever occurred.\n+\n+   --  The following provide the backtrace decorating facilities\n+\n+   type Traceback_Decorator is access\n+     function (Traceback : Traceback_Entries.Tracebacks_Array) return String;\n+   --  A backtrace decorator is a function which returns the string to be\n+   --  output for a call chain provided by way of a tracebacks array.\n+\n+   procedure Set_Trace_Decorator (Decorator : Traceback_Decorator);\n+   --  Set the decorator to be used for future automatic outputs. Restore\n+   --  the default behavior (output of raw addresses) if the provided\n+   --  access value is null.\n+   --\n+   --  Note: System.Traceback.Symbolic.Symbolic_Traceback may be used as the\n+   --  Decorator, to get a symbolic traceback. This will cause a significant\n+   --  cpu and memory overhead.\n+\n+end System.Exception_Traces;"}, {"sha": "ad5588761d1404a114a93c22a18d9884517ca834", "filename": "gcc/ada/s-trasym.adb", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fs-trasym.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fs-trasym.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-trasym.adb?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -0,0 +1,81 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--           S Y S T E M . T R A C E B A C K . S Y M B O L I C              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 1999-2014, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the default implementation for platforms where the full capability\n+--  is not supported. It returns tracebacks as lists of LF separated strings of\n+--  the form \"0x...\" corresponding to the addresses.\n+\n+with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;\n+with System.Address_Image;\n+\n+package body System.Traceback.Symbolic is\n+\n+   ------------------------\n+   -- Symbolic_Traceback --\n+   ------------------------\n+\n+   function Symbolic_Traceback\n+     (Traceback : System.Traceback_Entries.Tracebacks_Array) return String\n+   is\n+   begin\n+      if Traceback'Length = 0 then\n+         return \"\";\n+\n+      else\n+         declare\n+            Img : String := System.Address_Image (Traceback (Traceback'First));\n+\n+            Result : String (1 .. (Img'Length + 3) * Traceback'Length);\n+            Last   : Natural := 0;\n+\n+         begin\n+            for J in Traceback'Range loop\n+               Img := System.Address_Image (Traceback (J));\n+               Result (Last + 1 .. Last + 2) := \"0x\";\n+               Last := Last + 2;\n+               Result (Last + 1 .. Last + Img'Length) := Img;\n+               Last := Last + Img'Length + 1;\n+               Result (Last) := ASCII.LF;\n+            end loop;\n+\n+            return Result (1 .. Last);\n+         end;\n+      end if;\n+   end Symbolic_Traceback;\n+\n+   function Symbolic_Traceback\n+     (E : Ada.Exceptions.Exception_Occurrence) return String\n+   is\n+   begin\n+      return Symbolic_Traceback (Ada.Exceptions.Traceback.Tracebacks (E));\n+   end Symbolic_Traceback;\n+\n+end System.Traceback.Symbolic;"}, {"sha": "ea0b46bf9fc3863f64c6ce836bc733eaa334c631", "filename": "gcc/ada/s-trasym.ads", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fs-trasym.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/995683a614a3a5f3ac8466a6a13776a27d0f0666/gcc%2Fada%2Fs-trasym.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-trasym.ads?ref=995683a614a3a5f3ac8466a6a13776a27d0f0666", "patch": "@@ -0,0 +1,81 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--           S Y S T E M . T R A C E B A C K . S Y M B O L I C              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 1999-2014, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Run-time symbolic traceback support\n+\n+--  The routines provided in this package assume that your application has\n+--  been compiled with debugging information turned on, since this information\n+--  is used to build a symbolic traceback.\n+\n+--  If you want to retrieve tracebacks from exception occurrences, it is also\n+--  necessary to invoke the binder with -E switch. Please refer to the gnatbind\n+--  documentation for more information.\n+\n+--  Note that it is also possible (and often recommended) to compute symbolic\n+--  traceback outside the program execution, which in addition allows you\n+--  to distribute the executable with no debug info:\n+--\n+--  - build your executable with debug info\n+--  - archive this executable\n+--  - strip a copy of the executable and distribute/deploy this version\n+--  - at run time, compute absolute traceback (-bargs -E) from your\n+--    executable and log it using Ada.Exceptions.Exception_Information\n+--  - off line, compute the symbolic traceback using the executable archived\n+--    with debug info and addr2line or gdb (using info line *<addr>) on the\n+--    absolute addresses logged by your application.\n+\n+--  In order to retrieve symbolic information, functions in this package will\n+--  read on disk all the debug information of the executable file (found via\n+--  Argument (0), and looked in the PATH if needed) or shared libraries using\n+--  OS facilities, and load them in memory, causing a significant cpu and\n+--  memory overhead.\n+\n+--  On platforms where the full capability is not supported, function\n+--  Symbolic_Traceback return a list of addresses expressed as \"0x...\"\n+--  separated by line feed.\n+\n+with Ada.Exceptions;\n+\n+package System.Traceback.Symbolic is\n+   pragma Elaborate_Body;\n+\n+   function Symbolic_Traceback\n+     (Traceback : System.Traceback_Entries.Tracebacks_Array) return String;\n+   --  Build a string containing a symbolic traceback of the given call chain.\n+   --  Note: This procedure may be installed by Set_Trace_Decorator, to get a\n+   --  symbolic traceback on all exceptions raised (see\n+   --  System.Exception_Traces).\n+\n+   function Symbolic_Traceback\n+     (E : Ada.Exceptions.Exception_Occurrence) return String;\n+   --  Build string containing symbolic traceback of given exception occurrence\n+\n+end System.Traceback.Symbolic;"}]}