{"sha": "91f8ce668b14d42e1bcbead322f869009fc896f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFmOGNlNjY4YjE0ZDQyZTFiY2JlYWQzMjJmODY5MDA5ZmM4OTZmMA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-05-24T21:44:34Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-05-24T21:44:34Z"}, "message": "re PR libgcj/27024 (Implement URLConnection.getFileNameMap)\n\n\tPR libgcj/27024:\n\t* sources.am, Makefile.in: Rebuilt.\n\t* gnu/java/net/DefaultContentHandlerFactory.java: Removed.\n\t* java/net/URLConnection.java: Removed.\n\nFrom-SVN: r114056", "tree": {"sha": "dbb2532ad683f3ac930ff54e5e6ae655dbfd88c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbb2532ad683f3ac930ff54e5e6ae655dbfd88c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91f8ce668b14d42e1bcbead322f869009fc896f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f8ce668b14d42e1bcbead322f869009fc896f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91f8ce668b14d42e1bcbead322f869009fc896f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f8ce668b14d42e1bcbead322f869009fc896f0/comments", "author": null, "committer": null, "parents": [{"sha": "d1a162abd317521e391b8da2567504aa29c0cbfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1a162abd317521e391b8da2567504aa29c0cbfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1a162abd317521e391b8da2567504aa29c0cbfd"}], "stats": {"total": 1199, "additions": 11, "deletions": 1188}, "files": [{"sha": "4cc701379e47e9b3cbbc775d490518467a310ac3", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f8ce668b14d42e1bcbead322f869009fc896f0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f8ce668b14d42e1bcbead322f869009fc896f0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=91f8ce668b14d42e1bcbead322f869009fc896f0", "patch": "@@ -1,3 +1,10 @@\n+2006-05-24  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/27024:\n+\t* sources.am, Makefile.in: Rebuilt.\n+\t* gnu/java/net/DefaultContentHandlerFactory.java: Removed.\n+\t* java/net/URLConnection.java: Removed.\n+\n 2006-05-24  Carlos O'Donell  <carlos@codesourcery.com>\n \n \t* Makefile.am: Add install-html target. Add install-html to .PHONY"}, {"sha": "feca00a3e2563835912b949d50e3d8a8ffcc3736", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f8ce668b14d42e1bcbead322f869009fc896f0/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f8ce668b14d42e1bcbead322f869009fc896f0/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=91f8ce668b14d42e1bcbead322f869009fc896f0", "patch": "@@ -1698,7 +1698,7 @@ gnu_java_net_source_files = \\\n classpath/gnu/java/net/BASE64.java \\\n classpath/gnu/java/net/CRLFInputStream.java \\\n classpath/gnu/java/net/CRLFOutputStream.java \\\n-gnu/java/net/DefaultContentHandlerFactory.java \\\n+classpath/gnu/java/net/DefaultContentHandlerFactory.java \\\n classpath/gnu/java/net/EmptyX509TrustManager.java \\\n classpath/gnu/java/net/GetLocalHostAction.java \\\n classpath/gnu/java/net/HeaderFieldHelper.java \\\n@@ -3966,7 +3966,7 @@ classpath/java/net/URI.java \\\n classpath/java/net/URISyntaxException.java \\\n java/net/URL.java \\\n java/net/URLClassLoader.java \\\n-java/net/URLConnection.java \\\n+classpath/java/net/URLConnection.java \\\n classpath/java/net/URLDecoder.java \\\n classpath/java/net/URLEncoder.java \\\n classpath/java/net/URLStreamHandler.java \\"}, {"sha": "3b6e4450c1e3bfaeb7fd5a9e4e42799241def78e", "filename": "libjava/gnu/java/net/DefaultContentHandlerFactory.java", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a162abd317521e391b8da2567504aa29c0cbfd/libjava%2Fgnu%2Fjava%2Fnet%2FDefaultContentHandlerFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a162abd317521e391b8da2567504aa29c0cbfd/libjava%2Fgnu%2Fjava%2Fnet%2FDefaultContentHandlerFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FDefaultContentHandlerFactory.java?ref=d1a162abd317521e391b8da2567504aa29c0cbfd", "patch": "@@ -1,97 +0,0 @@\n-/* DefaultContentHandlerFactory.java\n-   Copyright (C) 2004 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package gnu.java.net;\n-\n-import java.awt.Toolkit;\n-import java.io.IOException;\n-import java.net.ContentHandler;\n-import java.net.ContentHandlerFactory;\n-import java.net.URLConnection;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-\n-import gnu.java.awt.ClasspathToolkit;\n-\n-/** Content Handler for Image types, using the AWT Toolkit's image decoder. */\n-class ImageHandler extends ContentHandler\n-{\n-  static ImageHandler instance = new ImageHandler();\n-  \n-  public Object getContent(URLConnection urlc) throws IOException\n-  {\n-    // FIXME: implement using ImageIO\n-    // ClasspathToolkit tk = (ClasspathToolkit) Toolkit.getDefaultToolkit();\n-    // java.awt.image.ImageProducer ip = tk.createImageProducer(urlc.getURL());\n-    // return ip;\n-    return null;\n-  }\n-}\n-\n-/**\n- */\n-public class DefaultContentHandlerFactory implements ContentHandlerFactory\n-{\n-  /** For now, hard code the list of types that we assume should\n-   *  be supported by the Toolkit. ClasspathToolkit should perhaps provide\n-   *  an API to express what Image MIME types the Toolkit understands.\n-   */\n-  private static String[] known_image_types =\n-    {\n-      \"image/bmp\",\n-      \"image/gif\",\n-      \"image/jpeg\",\n-      \"image/png\",\n-      \"image/tiff\",\n-      \"image/x-portable-anymap\",\n-      \"image/x-cmu-raster\",\n-      \"image/x-xbitmap\",\n-      \"image/x-xpixmap\"\n-    };\n-   \n-  private static HashSet imageTypes\n-    = new HashSet(Arrays.asList(known_image_types));\n-\n-  public ContentHandler createContentHandler(String mimeType)\n-  {\n-    if (imageTypes.contains(mimeType))\n-      return ImageHandler.instance;\n-    // Currently, only image types are handled.\n-    return null;\n-  }\n-}"}, {"sha": "b5e4cb0624149426de42b5caccc64be2966c82d3", "filename": "libjava/java/net/URLConnection.java", "status": "removed", "additions": 0, "deletions": 1087, "changes": 1087, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a162abd317521e391b8da2567504aa29c0cbfd/libjava%2Fjava%2Fnet%2FURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a162abd317521e391b8da2567504aa29c0cbfd/libjava%2Fjava%2Fnet%2FURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLConnection.java?ref=d1a162abd317521e391b8da2567504aa29c0cbfd", "patch": "@@ -1,1087 +0,0 @@\n-/* URLConnection.java -- Abstract superclass for reading from URL's\n-   Copyright (C) 1998, 2002, 2003, 2004 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.net;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.security.AllPermission;\n-import java.security.Permission;\n-import java.text.ParsePosition;\n-import java.text.SimpleDateFormat;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Hashtable;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.StringTokenizer;\n-import gnu.gcj.io.MimeTypes;\n-\n-\n-/**\n- * Written using on-line Java Platform 1.2 API Specification, as well\n- * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n- * Status:  One guessContentTypeFrom... methods not implemented.\n- *    getContent method assumes content type from response; see comment there.\n- */\n-/**\n- * This class models a connection that retrieves the information pointed\n- * to by a URL object.  This is typically a connection to a remote node\n- * on the network, but could be a simple disk read.\n- * <p>\n- * A URLConnection object is normally created by calling the openConnection()\n- * method of a URL object.  This method is somewhat misnamed because it does\n- * not actually open the connection.  Instead, it return an unconnected\n- * instance of this object.  The caller then has the opportunity to set\n- * various connection options prior to calling the actual connect() method.\n- * <p>\n- * After the connection has been opened, there are a number of methods in\n- * this class that access various attributes of the data, typically\n- * represented by headers sent in advance of the actual data itself.\n- * <p>\n- * Also of note are the getInputStream and getContent() methods which allow\n- * the caller to retrieve the actual data from the connection.  Note that\n- * for some types of connections, writing is also allowed.  The setDoOutput()\n- * method must be called prior to connecing in order to enable this, then\n- * the getOutputStream method called after the connection in order to\n- * obtain a stream to write the output to.\n- * <p>\n- * The getContent() method is of particular note.  This method returns an\n- * Object that encapsulates the data returned.  There is no way do determine\n- * the type of object that will be returned in advance.  This is determined\n- * by the actual content handlers as described in the description of that\n- * method.\n- *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Warren Levy (warrenl@cygnus.com)\n- */\n-public abstract class URLConnection\n-{\n-  /**\n-   * This is an object that maps filenames to MIME types.  The interface\n-   * to do this is implemented by this class, so just create an empty\n-   * instance and store it here.\n-   */\n-  private static FileNameMap fileNameMap;\n-\n-  /**\n-   * This is the ContentHandlerFactory set by the caller, if any\n-   */\n-  private static ContentHandlerFactory factory;\n-\n-  /**\n-   * This is the default value that will be used to determine whether or\n-   * not user interaction should be allowed.\n-   */\n-  private static boolean defaultAllowUserInteraction;\n-\n-  /**\n-   * This is the default flag indicating whether or not to use caches to\n-   * store the data returned from a server\n-   */\n-  private static boolean defaultUseCaches = true;\n-\n-  private static ContentHandlerFactory defaultFactory\n-    = new gnu.java.net.DefaultContentHandlerFactory();\n-\n-  /**\n-   * This variable determines whether or not interaction is allowed with\n-   * the user.  For example, to prompt for a username and password.\n-   */\n-  protected boolean allowUserInteraction;\n-\n-  /**\n-   * Indicates whether or not a connection has been established to the\n-   * destination specified in the URL\n-   */\n-  protected boolean connected;\n-\n-  /**\n-   * Indicates whether or not input can be read from this URL\n-   */\n-  protected boolean doInput = true;\n-\n-  /**\n-   * Indicates whether or not output can be sent to this URL\n-   */\n-  protected boolean doOutput;\n-\n-  /**\n-   * If this flag is set, the protocol is allowed to cache data whenever\n-   * it can (caching is not guaranteed). If it is not set, the protocol\n-   * must a get a fresh copy of the data.\n-   * <p>\n-   * This field is set by the setUseCaches method and returned by the\n-   * getUseCaches method.\n-   *\n-   * Its default value is that determined by the last invocation of\n-   * setDefaultUseCaches\n-   */\n-  protected boolean useCaches;\n-\n-  /**\n-   * If this value is non-zero, then the connection will only attempt to\n-   * fetch the document pointed to by the URL if the document has been\n-   * modified more recently than the date set in this variable.  That date\n-   * should be specified as the number of seconds since 1/1/1970 GMT.\n-   */\n-  protected long ifModifiedSince;\n-\n-  /**\n-   * This is the URL associated with this connection\n-   */\n-  protected URL url;\n-\n-  private static Hashtable handlers = new Hashtable();\n-  private static SimpleDateFormat[] dateFormats;\n-  private static boolean dateformats_initialized;\n-\n-  /* Cached ParsePosition, used when parsing dates. */\n-  private ParsePosition position;\n-\n-  /**\n-   * Creates a URL connection to a given URL. A real connection is not made.\n-   * Use #connect to do this.\n-   *\n-   * @param url The Object to create the URL connection to\n-   *\n-   * @see URLConnection#connect()\n-   */\n-  protected URLConnection(URL url)\n-  {\n-    // Set up all our instance variables\n-    this.url = url;\n-    allowUserInteraction = defaultAllowUserInteraction;\n-    useCaches = defaultUseCaches;\n-  }\n-\n-  /**\n-   * Establishes the actual connection to the URL associated with this\n-   * connection object\n-   *\n-   * @exception IOException if an error occurs\n-   */\n-  public abstract void connect() throws IOException;\n-\n-  /**\n-   * Returns the URL object associated with this connection\n-   *\n-   * @return The URL for this connection.\n-   */\n-  public URL getURL()\n-  {\n-    return url;\n-  }\n-\n-  /**\n-   * Returns the value of the content-length header field or -1 if the value\n-   * is not known or not present.\n-   *\n-   * @return The content-length field\n-   */\n-  public int getContentLength()\n-  {\n-    return getHeaderFieldInt(\"content-length\", -1);\n-  }\n-\n-  /**\n-   * Returns the the content-type of the data pointed to by the URL.  This\n-   * method first tries looking for a content-type header.  If that is not\n-   * present, it attempts to use the file name to determine the content's\n-   * MIME type.  If that is unsuccessful, the method returns null.  The caller\n-   * may then still attempt to determine the MIME type by a call to\n-   * guessContentTypeFromStream()\n-   *\n-   * @return The content MIME type\n-   */\n-  public String getContentType()\n-  {\n-    return getHeaderField(\"content-type\");\n-  }\n-\n-  /**\n-   * Returns the value of the content-encoding field or null if it is not\n-   * known or not present.\n-   *\n-   * @return The content-encoding field\n-   */\n-  public String getContentEncoding()\n-  {\n-    return getHeaderField(\"content-encoding\");\n-  }\n-\n-  /**\n-   * Returns the value of the expires header or 0 if not known or present.\n-   * If populated, the return value is number of seconds since midnight\n-   * on 1/1/1970 GMT.\n-   *\n-   * @return The expiration time.\n-   */\n-  public long getExpiration()\n-  {\n-    return getHeaderFieldDate(\"expires\", 0L);\n-  }\n-\n-  /**\n-   * Returns the date of the document pointed to by the URL as reported in\n-   * the date field of the header or 0 if the value is not present or not\n-   * known. If populated, the return value is number of seconds since\n-   * midnight on 1/1/1970 GMT.\n-   *\n-   * @return The document date\n-   */\n-  public long getDate()\n-  {\n-    return getHeaderFieldDate(\"date\", 0L);\n-  }\n-\n-  /**\n-   * Returns the value of the last-modified header field or 0 if not known known\n-   * or not present.  If populated, the return value is the number of seconds\n-   * since midnight on 1/1/1970.\n-   *\n-   * @return The last modified time\n-   */\n-  public long getLastModified()\n-  {\n-    return getHeaderFieldDate(\"last-modified\", 0L);\n-  }\n-\n-  /**\n-   * Return a String representing the header value at the specified index.\n-   * This allows the caller to walk the list of header fields.  The analogous\n-   * getHeaderFieldKey(int) method allows access to the corresponding key\n-   * for this header field\n-   *\n-   * @param index The index into the header field list to retrieve the value for\n-   *\n-   * @return The header value or null if index is past the end of the headers\n-   */\n-  public String getHeaderField(int index)\n-  {\n-    // Subclasses for specific protocols override this.\n-    return null;\n-  }\n-\n-  /**\n-   * Returns a String representing the value of the header field having\n-   * the named key.  Returns null if the header field does not exist.\n-   *\n-   * @param name The key of the header field\n-   *\n-   * @return The value of the header field as a String\n-   */\n-  public String getHeaderField(String name)\n-  {\n-    // Subclasses for specific protocols override this.\n-    return null;\n-  }\n-\n-  /**\n-   * Returns a map of all sent header fields\n-   *\n-   * @return all header fields\n-   *\n-   * @since 1.4\n-   */\n-  public Map getHeaderFields()\n-  {\n-    // Subclasses for specific protocols override this.\n-    return Collections.EMPTY_MAP;\n-  }\n-\n-  /**\n-   * Returns the value of the named header field as an int.  If the field\n-   * is not present or cannot be parsed as an integer, the default value\n-   * will be returned.\n-   *\n-   * @param name The header field key to lookup\n-   * @param defaultValue The defaule value if the header field is not found\n-   * or can't be parsed.\n-   *\n-   * @return The value of the header field or the default value if the field\n-   * is missing or malformed\n-   */\n-  public int getHeaderFieldInt(String name, int defaultValue)\n-  {\n-    String value = getHeaderField(name);\n-\n-    if (value == null)\n-      return defaultValue;\n-\n-    try\n-      {\n-\treturn Integer.parseInt(value);\n-      }\n-    catch (NumberFormatException e)\n-      {\n-\treturn defaultValue;\n-      }\n-  }\n-\n-  /**\n-   * Returns the value of the named header field as a date.  This date will\n-   * be the number of seconds since midnight 1/1/1970 GMT or the default\n-   * value if the field is not present or cannot be converted to a date.\n-   *\n-   * @param name The name of the header field\n-   * @param defaultValue The default date if the header field is not found\n-   * or can't be converted.\n-   *\n-   * @return Returns the date value of the header filed or the default value\n-   * if the field is missing or malformed\n-   */\n-  public long getHeaderFieldDate(String name, long defaultValue)\n-  {\n-    if (! dateformats_initialized)\n-      initializeDateFormats();\n-\n-    if (position == null)\n-      position = new ParsePosition(0);\n-\n-    long result = defaultValue;\n-    String str = getHeaderField(name);\n-\n-    if (str != null)\n-      {\n-\tfor (int i = 0; i < dateFormats.length; i++)\n-\t  {\n-\t    SimpleDateFormat df = dateFormats[i];\n-\t    position.setIndex(0);\n-\t    position.setErrorIndex(0);\n-\t    Date date = df.parse(str, position);\n-\t    if (date != null)\n-\t      return date.getTime();\n-\t  }\n-      }\n-\n-    return result;\n-  }\n-\n-  /**\n-   * Returns a String representing the header key at the specified index.\n-   * This allows the caller to walk the list of header fields.  The analogous\n-   * getHeaderField(int) method allows access to the corresponding value for\n-   * this tag.\n-   *\n-   * @param index The index into the header field list to retrieve the key for.\n-   *\n-   * @return The header field key or null if index is past the end\n-   * of the headers.\n-   */\n-  public String getHeaderFieldKey(int index)\n-  {\n-    // Subclasses for specific protocols override this.\n-    return null;\n-  }\n-\n-  /**\n-   * This method returns the content of the document pointed to by the\n-   * URL as an Object.  The type of object depends on the MIME type of\n-   * the object and particular content hander loaded.  Most text type\n-   * content handlers will return a subclass of\n-   * <code>InputStream</code>.  Images usually return a class that\n-   * implements <code>ImageProducer</code>.  There is not guarantee\n-   * what type of object will be returned, however.\n-   *\n-   * <p>This class first determines the MIME type of the content, then\n-   * creates a ContentHandler object to process the input.  If the\n-   * <code>ContentHandlerFactory</code> is set, then that object is\n-   * called to load a content handler, otherwise a class called\n-   * gnu.java.net.content.&lt;content_type&gt; is tried.  If this\n-   * handler does not exist, the method will simple return the\n-   * <code>InputStream</code> returned by\n-   * <code>getInputStream()</code>.  Note that the default\n-   * implementation of <code>getInputStream()</code> throws a\n-   * <code>UnknownServiceException</code> so subclasses are encouraged\n-   * to override this method.</p>\n-   *\n-   * @return the content\n-   *\n-   * @exception IOException If an error with the connection occurs.\n-   * @exception UnknownServiceException If the protocol does not support the\n-   * content type at all.\n-   */\n-  public Object getContent() throws IOException\n-  {\n-    if (!connected)\n-      connect();\n-\n-    // FIXME: Doc indicates that other criteria should be applied as\n-    // heuristics to determine the true content type, e.g. see \n-    // guessContentTypeFromName() and guessContentTypeFromStream methods\n-    // as well as FileNameMap class & fileNameMap field & get/set methods.\n-    String type = getContentType();\n-    ContentHandler ch = getContentHandler(type);\n-\n-    if (ch != null)\n-      return ch.getContent(this);\n-\n-    return getInputStream();\n-  }\n-\n-  /**\n-   * Retrieves the content of this URLConnection\n-   *\n-   * @param classes The allowed classes for the content\n-   *\n-   * @return the content\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception UnknownServiceException If the protocol does not support the\n-   * content type\n-   */\n-  public Object getContent(Class[] classes) throws IOException\n-  {\n-    // FIXME: implement this\n-    return getContent();\n-  }\n-\n-  /**\n-   * This method returns a <code>Permission</code> object representing the\n-   * permissions required to access this URL.  This method returns\n-   * <code>java.security.AllPermission</code> by default.  Subclasses should\n-   * override it to return a more specific permission.  For example, an\n-   * HTTP URL should return an instance of <code>SocketPermission</code>\n-   * for the appropriate host and port.\n-   * <p>\n-   * Note that because of items such as HTTP redirects, the permission\n-   * object returned might be different before and after connecting.\n-   *\n-   * @return A Permission object\n-   *\n-   * @exception IOException If the computation of the permission requires\n-   * network or file I/O and an exception occurs while computing it\n-   */\n-  public Permission getPermission() throws IOException\n-  {\n-    // Subclasses may override this.\n-    return new AllPermission();\n-  }\n-\n-  /**\n-   * Returns an InputStream for this connection.  As this default\n-   * implementation returns null, subclasses should override this method\n-   *\n-   * @return An InputStream for this connection\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception UnknownServiceException If the protocol does not support input\n-   */\n-  public InputStream getInputStream() throws IOException\n-  {\n-    // Subclasses for specific protocols override this.\n-    throw new UnknownServiceException(\"Protocol \" + url.getProtocol()\n-                                      + \" does not support input.\");\n-  }\n-\n-  /**\n-   * Returns an OutputStream for this connection.  As this default\n-   * implementation returns null, subclasses should override this method\n-   *\n-   * @return An OutputStream for this connection\n-   *\n-   * @exception IOException If an error occurs\n-   * @exception UnknownServiceException If the protocol does not support output\n-   */\n-  public OutputStream getOutputStream() throws IOException\n-  {\n-    // Subclasses for specific protocols override this.\n-    throw new UnknownServiceException(\"Protocol \" + url.getProtocol()\n-                                      + \" does not support output.\");\n-  }\n-\n-  /**\n-   * The methods prints the value of this object as a String by calling the\n-   * toString() method of its associated URL.  Overrides Object.toString()\n-   *\n-   * @return A String representation of this object\n-   */\n-  public String toString()\n-  {\n-    return this.getClass().getName() + \":\" + url.toString();\n-  }\n-\n-  /**\n-   * Sets the value of a flag indicating whether or not input is going\n-   * to be done for this connection.  This default to true unless the\n-   * doOutput flag is set to false, in which case this defaults to false.\n-   *\n-   * @param input <code>true</code> if input is to be done,\n-   * <code>false</code> otherwise\n-   *\n-   * @exception IllegalStateException If already connected\n-   */\n-  public void setDoInput(boolean input)\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-\n-    doInput = input;\n-  }\n-\n-  /**\n-   * Returns the value of a flag indicating whether or not input is going\n-   * to be done for this connection.  This default to true unless the\n-   * doOutput flag is set to false, in which case this defaults to false.\n-   *\n-   * @return true if input is to be done, false otherwise\n-   */\n-  public boolean getDoInput()\n-  {\n-    return doInput;\n-  }\n-\n-  /**\n-   * Sets a boolean flag indicating whether or not output will be done\n-   * on this connection.  The default value is false, so this method can\n-   * be used to override the default\n-   *\n-   * @param output ture if output is to be done, false otherwise\n-   *\n-   * @exception IllegalStateException If already connected\n-   */\n-  public void setDoOutput(boolean output)\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-\n-    doOutput = output;\n-  }\n-\n-  /**\n-   * Returns a boolean flag indicating whether or not output will be done\n-   * on this connection.  This defaults to false.\n-   *\n-   * @return true if output is to be done, false otherwise\n-   */\n-  public boolean getDoOutput()\n-  {\n-    return doOutput;\n-  }\n-\n-  /**\n-   * Sets a boolean flag indicating whether or not user interaction is\n-   * allowed for this connection.  (For example, in order to prompt for\n-   * username and password info.\n-   *\n-   * @param allow true if user interaction should be allowed, false otherwise.\n-   *\n-   * @exception IllegalStateException If already connected\n-   */\n-  public void setAllowUserInteraction(boolean allow)\n-  {\n-    allowUserInteraction = allow;\n-  }\n-\n-  /**\n-   * Returns a boolean flag indicating whether or not user interaction is\n-   * allowed for this connection.  (For example, in order to prompt for\n-   * username and password info.\n-   *\n-   * @return true if user interaction is allowed, false otherwise\n-   */\n-  public boolean getAllowUserInteraction()\n-  {\n-    return allowUserInteraction;\n-  }\n-\n-  /**\n-   * Sets the default flag for whether or not interaction with a user\n-   * is allowed.  This will be used for all connections unless overridden\n-   *\n-   * @param allow true to allow user interaction, false otherwise\n-   */\n-  public static void setDefaultAllowUserInteraction(boolean allow)\n-  {\n-    defaultAllowUserInteraction = allow;\n-  }\n-\n-  /**\n-   * Returns the default flag for whether or not interaction with a user\n-   * is allowed.  This will be used for all connections unless overridden\n-   *\n-   * @return true if user interaction is allowed, false otherwise\n-   */\n-  public static boolean getDefaultAllowUserInteraction()\n-  {\n-    return defaultAllowUserInteraction;\n-  }\n-\n-  /**\n-   * Sets a boolean flag indicating whether or not caching will be used\n-   * (if possible) to store data downloaded via the connection.\n-   *\n-   * @param usecaches The new value\n-   *\n-   * @exception IllegalStateException If already connected\n-   */\n-  public void setUseCaches(boolean usecaches)\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-\n-    useCaches = usecaches;\n-  }\n-\n-  /**\n-   * Returns a boolean flag indicating whether or not caching will be used\n-   * (if possible) to store data downloaded via the connection.\n-   *\n-   * @return true if caching should be used if possible, false otherwise\n-   */\n-  public boolean getUseCaches()\n-  {\n-    return useCaches;\n-  }\n-\n-  /**\n-   * Sets the ifModified since instance variable.  If this value is non\n-   * zero and the underlying protocol supports it, the actual document will\n-   * not be fetched unless it has been modified since this time.  The value\n-   * passed should  be 0 if this feature is to be disabled or the time expressed\n-   * as the number of seconds since midnight 1/1/1970 GMT otherwise.\n-   *\n-   * @param ifmodifiedsince The new value in milliseconds\n-   * since January 1, 1970 GMT\n-   *\n-   * @exception IllegalStateException If already connected\n-   */\n-  public void setIfModifiedSince(long ifmodifiedsince)\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-\n-    ifModifiedSince = ifmodifiedsince;\n-  }\n-\n-  /**\n-   * Returns the ifModified since instance variable.  If this value is non\n-   * zero and the underlying protocol supports it, the actual document will\n-   * not be fetched unless it has been modified since this time.  The value\n-   * returned will be 0 if this feature is disabled or the time expressed\n-   * as the number of seconds since midnight 1/1/1970 GMT otherwise\n-   *\n-   * @return The ifModifiedSince value\n-   */\n-  public long getIfModifiedSince()\n-  {\n-    return ifModifiedSince;\n-  }\n-\n-  /**\n-   * Returns the default value used to determine whether or not caching\n-   * of documents will be done when possible.\n-   *\n-   * @return true if caches will be used, false otherwise\n-   */\n-  public boolean getDefaultUseCaches()\n-  {\n-    return defaultUseCaches;\n-  }\n-\n-  /**\n-   * Sets the default value used to determine whether or not caching\n-   * of documents will be done when possible.\n-   *\n-   * @param use true to use caches if possible by default, false otherwise\n-   */\n-  public void setDefaultUseCaches(boolean use)\n-  {\n-    defaultUseCaches = use;\n-  }\n-\n-  /**\n-   * Sets the value of the named request property\n-   *\n-   * @param key The name of the property\n-   * @param value The value of the property\n-   *\n-   * @exception IllegalStateException If already connected\n-   * @exception NullPointerException If key is null\n-   *\n-   * @see URLConnection#getRequestProperty(String key)\n-   * @see URLConnection#addRequestProperty(String key, String value)\n-   *\n-   * @since 1.4\n-   */\n-  public void setRequestProperty(String key, String value)\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-\n-    if (key == null)\n-      throw new NullPointerException(\"key is null\");\n-\n-    // Do nothing unless overridden by subclasses that support setting\n-    // header fields in the request.\n-  }\n-\n-  /**\n-   * Adds a new request property by a key/value pair.\n-   * This method does not overwrite existing properties with the same key.\n-   *\n-   * @param key Key of the property to add\n-   * @param value Value of the Property to add\n-   *\n-   * @exception IllegalStateException If already connected\n-   * @exception NullPointerException If key is null\n-   *\n-   * @see URLConnection#getRequestProperty(String key)\n-   * @see URLConnection#setRequestProperty(String key, String value)\n-   *\n-   * @since 1.4\n-   */\n-  public void addRequestProperty(String key, String value)\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-\n-    if (key == null)\n-      throw new NullPointerException(\"key is null\");\n-\n-    // Do nothing unless overridden by subclasses that support adding\n-    // header fields in the request.\n-  }\n-\n-  /**\n-   * Returns the value of the named request property.\n-   *\n-   * @param key The name of the property\n-   *\n-   * @return Value of the property\n-   *\n-   * @exception IllegalStateException If already connected\n-   *\n-   * @see URLConnection#setRequestProperty(String key, String value)\n-   * @see URLConnection#addRequestProperty(String key, String value)\n-   */\n-  public String getRequestProperty(String key)\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-\n-    // Overridden by subclasses that support reading header fields from the\n-    // request.\n-    return null;\n-  }\n-\n-  /**\n-   * Returns an unmodifiable Map containing the request properties.\n-   *\n-   * @return The map of properties\n-   *\n-   * @exception IllegalStateException If already connected\n-   *\n-   * @since 1.4\n-   */\n-  public Map getRequestProperties()\n-  {\n-    if (connected)\n-      throw new IllegalStateException(\"Already connected\");\n-\n-    // Overridden by subclasses that support reading header fields from the\n-    // request.\n-    return Collections.EMPTY_MAP;\n-  }\n-\n-  /**\n-   * Sets the default value of a request property.  This will be used\n-   * for all connections unless the value of the property is manually\n-   * overridden.\n-   *\n-   * @param key The request property name the default is being set for\n-   * @param value The value to set the default to\n-   *\n-   * @deprecated 1.3 The method setRequestProperty should be used instead.\n-   * This method does nothing now.\n-   *\n-   * @see URLConnection#setRequestProperty(String key, String value)\n-   */\n-  public static void setDefaultRequestProperty(String key, String value)\n-  {\n-    // This method does nothing since JDK 1.3.\n-  }\n-\n-  /**\n-   * Returns the default value of a request property.  This will be used\n-   * for all connections unless the value of the property is manually\n-   * overridden.\n-   *\n-   * @param key The request property to return the default value of\n-   *\n-   * @return The value of the default property or null if not available\n-   *\n-   * @deprecated 1.3 The method getRequestProperty should be used instead.\n-   * This method does nothing now.\n-   *\n-   * @see URLConnection#getRequestProperty(String key)\n-   */\n-  public static String getDefaultRequestProperty(String key)\n-  {\n-    // This method does nothing since JDK 1.3.\n-    return null;\n-  }\n-\n-  /**\n-   * Sets the ContentHandlerFactory for an application.  This can be called\n-   * once and only once.  If it is called again, then an Error is thrown.\n-   * Unlike for other set factory methods, this one does not do a security\n-   * check prior to setting the factory.\n-   *\n-   * @param factory The ContentHandlerFactory for this application\n-   *\n-   * @exception Error If the factory has already been defined\n-   * @exception SecurityException If a security manager exists and its\n-   * checkSetFactory method doesn't allow the operation\n-   */\n-  public static synchronized void setContentHandlerFactory(ContentHandlerFactory factory)\n-  {\n-    if (URLConnection.factory != null)\n-      throw new Error(\"ContentHandlerFactory already set\");\n-\n-    // Throw an exception if an extant security mgr precludes\n-    // setting the factory.\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkSetFactory();\n-\n-    URLConnection.factory = factory;\n-  }\n-\n-  /**\n-   * Returns the MIME type of a file based on the name of the file.  This\n-   * works by searching for the file's extension in a list of file extensions\n-   * and returning the MIME type associated with it.  If no type is found,\n-   * then a MIME type of \"application/octet-stream\" will be returned.\n-   *\n-   * @param filename The filename to determine the MIME type for\n-   *\n-   * @return The MIME type String\n-   *\n-   * @specnote public since JDK 1.4\n-   */\n-  public static String guessContentTypeFromName(String filename)\n-  {\n-    int dot = filename.lastIndexOf(\".\");\n-    \n-    if (dot != -1)\n-      {\n-\tif (dot == filename.length())\n-\t  return \"application/octet-stream\";\n-\telse\n-\t  filename = filename.substring(dot + 1);\n-      }\n-    \n-    String type = MimeTypes.getMimeTypeFromExtension(filename);\n-    \n-    if (type == null)\n-      return\"application/octet-stream\";\n-\n-    return type;\n-  }\n-\n-  /**\n-   * Returns the MIME type of a stream based on the first few characters\n-   * at the beginning of the stream.  This routine can be used to determine\n-   * the MIME type if a server is believed to be returning an incorrect\n-   * MIME type.  This method returns \"application/octet-stream\" if it\n-   * cannot determine the MIME type.\n-   * <p>\n-   * NOTE: Overriding MIME types sent from the server can be obnoxious\n-   * to user's.  See Internet Exploder 4 if you don't believe me.\n-   *\n-   * @param is The InputStream to determine the MIME type from\n-   *\n-   * @return The MIME type\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public static String guessContentTypeFromStream(InputStream is)\n-    throws IOException\n-  {\n-    is.mark(1024);\n-    // FIXME: Implement this. Use system mimetype informations (like \"file\").\n-    is.reset();\n-    return null;\n-  }\n-\n-  /**\n-   * This method returns the <code>FileNameMap</code> object being used\n-   * to decode MIME types by file extension.\n-   *\n-   * @return The <code>FileNameMap</code>.\n-   *\n-   * @since 1.2\n-   */\n-  public static FileNameMap getFileNameMap()\n-  {\n-    return fileNameMap;\n-  }\n-\n-  /**\n-   * This method sets the <code>FileNameMap</code> object being used\n-   * to decode MIME types by file extension.\n-   *\n-   * @param map The <code>FileNameMap</code>.\n-   *\n-   * @exception SecurityException If a security manager exists and its\n-   * checkSetFactory method doesn't allow the operation\n-   *\n-   * @since 1.2\n-   */\n-  public static void setFileNameMap(FileNameMap map)\n-  {\n-    // Throw an exception if an extant security manager precludes\n-    // setting the factory.\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkSetFactory();\n-\n-    fileNameMap = map;\n-  }\n-\n-  private ContentHandler getContentHandler(String contentType)\n-  {\n-    // No content type so just handle it as the default.\n-    if (contentType == null || contentType.equals(\"\"))\n-      return null;\n-\n-    ContentHandler handler = null;\n-\n-    // See if a handler has been cached for this content type.\n-    // For efficiency, if a content type has been searched for but not\n-    // found, it will be in the hash table but as the contentType String\n-    // instead of a ContentHandler.\n-    {\n-      Object cachedHandler;\n-      if ((cachedHandler = handlers.get(contentType)) != null)\n-\t{\n-\t  if (cachedHandler instanceof ContentHandler)\n-\t    return (ContentHandler)cachedHandler;\n-\t  else\n-\t    return null;\n-\t}\n-    }\n-\n-    // If a non-default factory has been set, use it.\n-    if (factory != null)\n-      handler = factory.createContentHandler(contentType);\n-\n-    // Now try default factory. Using this factory to instantiate built-in\n-    // content handlers is preferable  \n-    if (handler == null)\n-      handler = defaultFactory.createContentHandler(contentType);\n-\n-    // User-set factory has not returned a handler. Use the default search \n-    // algorithm.\n-    if (handler == null)\n-      {\n-\t// Get the list of packages to check and append our default handler\n-\t// to it, along with the JDK specified default as a last resort.\n-\t// Except in very unusual environments the JDK specified one shouldn't\n-\t// ever be needed (or available).\n-\tString propVal = System.getProperty(\"java.content.handler.pkgs\");\n-\tpropVal = (propVal == null) ? \"\" : (propVal + \"|\");\n-\tpropVal = propVal + \"gnu.java.net.content|sun.net.www.content\";\n-\n-\t// Replace the '/' character in the content type with '.' and\n-\t// all other non-alphabetic, non-numeric characters with '_'.\n-\tchar[] cArray = contentType.toCharArray();\n-\tfor (int i = 0; i < cArray.length; i++)\n-\t  {\n-\t    if (cArray[i] == '/')\n-\t      cArray[i] = '.';\n-\t    else if (! ((cArray[i] >= 'A' && cArray[i] <= 'Z') || \n-\t\t\t(cArray[i] >= 'a' && cArray[i] <= 'z') ||\n-\t\t\t(cArray[i] >= '0' && cArray[i] <= '9')))\n-\t      cArray[i] = '_';\n-\t  }\n-\tString contentClass = new String(cArray);\n-\n-\t// See if a class of this content type exists in any of the packages.\n-\tStringTokenizer pkgPrefix = new StringTokenizer(propVal, \"|\");\n-\tdo\n-\t  {\n-\t    String facName = pkgPrefix.nextToken() + \".\" + contentClass;\n-\t    try\n-\t      {\n-\t\thandler =\n-\t\t  (ContentHandler) Class.forName(facName).newInstance();\n-\t      }\n-\t    catch (Exception e)\n-\t      {\n-\t\t// Can't instantiate; handler still null, go on to next element.\n-\t      }\n-\t  } while ((handler == null ||\n-\t\t    ! (handler instanceof ContentHandler)) &&\n-\t\t   pkgPrefix.hasMoreTokens());\n-      }\n-\n-    // Update the hashtable with the new content handler.\n-    if (handler instanceof ContentHandler)\n-      {\n-\thandlers.put(contentType, handler);\n-\treturn handler;\n-      }\n-\n-    // For efficiency on subsequent searches, put a dummy entry in the hash\n-    // table for content types that don't have a non-default ContentHandler.\n-    handlers.put(contentType, contentType);\n-    return null;\n-  }\n-  \n-  // We don't put these in a static initializer, because it creates problems\n-  // with initializer co-dependency: SimpleDateFormat's constructors eventually \n-  // depend on URLConnection (via the java.text.*Symbols classes).\n-  private static synchronized void initializeDateFormats()\n-  {\n-    if (dateformats_initialized)\n-      return;\n-\n-    Locale locale = new Locale(\"En\", \"Us\", \"Unix\");\n-    dateFormats = new SimpleDateFormat[3];\n-    dateFormats[0] =\n-      new SimpleDateFormat(\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", locale);\n-    dateFormats[1] =\n-      new SimpleDateFormat(\"EEEE, dd-MMM-yy hh:mm:ss 'GMT'\", locale);\n-    dateFormats[2] = new SimpleDateFormat(\"EEE MMM d hh:mm:ss yyyy\", locale);\n-    dateformats_initialized = true;\n-  }\n-}"}, {"sha": "fb83ccfbff052c11b7df1a64b8271198a932297a", "filename": "libjava/sources.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f8ce668b14d42e1bcbead322f869009fc896f0/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f8ce668b14d42e1bcbead322f869009fc896f0/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=91f8ce668b14d42e1bcbead322f869009fc896f0", "patch": "@@ -1265,7 +1265,7 @@ gnu_java_net_source_files = \\\n classpath/gnu/java/net/BASE64.java \\\n classpath/gnu/java/net/CRLFInputStream.java \\\n classpath/gnu/java/net/CRLFOutputStream.java \\\n-gnu/java/net/DefaultContentHandlerFactory.java \\\n+classpath/gnu/java/net/DefaultContentHandlerFactory.java \\\n classpath/gnu/java/net/EmptyX509TrustManager.java \\\n classpath/gnu/java/net/GetLocalHostAction.java \\\n classpath/gnu/java/net/HeaderFieldHelper.java \\\n@@ -4892,7 +4892,7 @@ classpath/java/net/URI.java \\\n classpath/java/net/URISyntaxException.java \\\n java/net/URL.java \\\n java/net/URLClassLoader.java \\\n-java/net/URLConnection.java \\\n+classpath/java/net/URLConnection.java \\\n classpath/java/net/URLDecoder.java \\\n classpath/java/net/URLEncoder.java \\\n classpath/java/net/URLStreamHandler.java \\"}]}