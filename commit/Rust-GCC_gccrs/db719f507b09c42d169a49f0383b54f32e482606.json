{"sha": "db719f507b09c42d169a49f0383b54f32e482606", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI3MTlmNTA3YjA5YzQyZDE2OWE0OWYwMzgzYjU0ZjMyZTQ4MjYwNg==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2011-08-19T14:36:34Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2011-08-19T14:36:34Z"}, "message": "tree-ssa-math-opts.c (convert_mult_to_widen): Convert unsupported unsigned multiplies to signed.\n\n2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* tree-ssa-math-opts.c (convert_mult_to_widen): Convert\n\tunsupported unsigned multiplies to signed.\n\t(convert_plusminus_to_widen): Likewise.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/wmul-6.c: New file.\n\nFrom-SVN: r177905", "tree": {"sha": "34ea0aaf3a645997d9e650d4b1a93bbd16157380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34ea0aaf3a645997d9e650d4b1a93bbd16157380"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db719f507b09c42d169a49f0383b54f32e482606", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db719f507b09c42d169a49f0383b54f32e482606", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db719f507b09c42d169a49f0383b54f32e482606", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db719f507b09c42d169a49f0383b54f32e482606/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cefb4d4f6018fa673ce82687f695ec21624566df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cefb4d4f6018fa673ce82687f695ec21624566df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cefb4d4f6018fa673ce82687f695ec21624566df"}], "stats": {"total": 102, "additions": 86, "deletions": 16}, "files": [{"sha": "75b3db4e0ad3cee123ab438e73eac0e4ee98a057", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db719f507b09c42d169a49f0383b54f32e482606/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db719f507b09c42d169a49f0383b54f32e482606/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db719f507b09c42d169a49f0383b54f32e482606", "patch": "@@ -1,3 +1,9 @@\n+2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* tree-ssa-math-opts.c (convert_mult_to_widen): Convert\n+\tunsupported unsigned multiplies to signed.\n+\t(convert_plusminus_to_widen): Likewise.\n+\n 2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* tree-ssa-math-opts.c (convert_plusminus_to_widen): Permit a single"}, {"sha": "96cb094634308df0c5593df4ffb846517e323815", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db719f507b09c42d169a49f0383b54f32e482606/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db719f507b09c42d169a49f0383b54f32e482606/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=db719f507b09c42d169a49f0383b54f32e482606", "patch": "@@ -1,3 +1,7 @@\n+2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* gcc.target/arm/wmul-6.c: New file.\n+\n 2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* gcc.target/arm/wmul-5.c: New file."}, {"sha": "babdaab1efd55d356d6e5999023df9915caabc45", "filename": "gcc/testsuite/gcc.target/arm/wmul-6.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db719f507b09c42d169a49f0383b54f32e482606/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db719f507b09c42d169a49f0383b54f32e482606/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-6.c?ref=db719f507b09c42d169a49f0383b54f32e482606", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-require-effective-target arm_dsp } */\n+\n+long long\n+foo (long long a, unsigned char *b, signed char *c)\n+{\n+  return a + (long long)*b * (long long)*c;\n+}\n+\n+/* { dg-final { scan-assembler \"smlalbb\" } } */"}, {"sha": "0505603ed2f3bdf61bdbda4b9a3de955f7ee805e", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db719f507b09c42d169a49f0383b54f32e482606/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db719f507b09c42d169a49f0383b54f32e482606/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=db719f507b09c42d169a49f0383b54f32e482606", "patch": "@@ -2068,12 +2068,13 @@ is_widening_mult_p (gimple stmt,\n static bool\n convert_mult_to_widen (gimple stmt, gimple_stmt_iterator *gsi)\n {\n-  tree lhs, rhs1, rhs2, type, type1, type2, tmp;\n+  tree lhs, rhs1, rhs2, type, type1, type2, tmp = NULL;\n   enum insn_code handler;\n   enum machine_mode to_mode, from_mode, actual_mode;\n   optab op;\n   int actual_precision;\n   location_t loc = gimple_location (stmt);\n+  bool from_unsigned1, from_unsigned2;\n \n   lhs = gimple_assign_lhs (stmt);\n   type = TREE_TYPE (lhs);\n@@ -2085,10 +2086,12 @@ convert_mult_to_widen (gimple stmt, gimple_stmt_iterator *gsi)\n \n   to_mode = TYPE_MODE (type);\n   from_mode = TYPE_MODE (type1);\n+  from_unsigned1 = TYPE_UNSIGNED (type1);\n+  from_unsigned2 = TYPE_UNSIGNED (type2);\n \n-  if (TYPE_UNSIGNED (type1) && TYPE_UNSIGNED (type2))\n+  if (from_unsigned1 && from_unsigned2)\n     op = umul_widen_optab;\n-  else if (!TYPE_UNSIGNED (type1) && !TYPE_UNSIGNED (type2))\n+  else if (!from_unsigned1 && !from_unsigned2)\n     op = smul_widen_optab;\n   else\n     op = usmul_widen_optab;\n@@ -2097,22 +2100,45 @@ convert_mult_to_widen (gimple stmt, gimple_stmt_iterator *gsi)\n \t\t\t\t\t\t  0, &actual_mode);\n \n   if (handler == CODE_FOR_nothing)\n-    return false;\n+    {\n+      if (op != smul_widen_optab)\n+\t{\n+\t  from_mode = GET_MODE_WIDER_MODE (from_mode);\n+\t  if (GET_MODE_SIZE (to_mode) <= GET_MODE_SIZE (from_mode))\n+\t    return false;\n+\n+\t  op = smul_widen_optab;\n+\t  handler = find_widening_optab_handler_and_mode (op, to_mode,\n+\t\t\t\t\t\t\t  from_mode, 0,\n+\t\t\t\t\t\t\t  &actual_mode);\n+\n+\t  if (handler == CODE_FOR_nothing)\n+\t    return false;\n+\n+\t  from_unsigned1 = from_unsigned2 = false;\n+\t}\n+      else\n+\treturn false;\n+    }\n \n   /* Ensure that the inputs to the handler are in the correct precison\n      for the opcode.  This will be the full mode size.  */\n   actual_precision = GET_MODE_PRECISION (actual_mode);\n-  if (actual_precision != TYPE_PRECISION (type1))\n+  if (actual_precision != TYPE_PRECISION (type1)\n+      || from_unsigned1 != TYPE_UNSIGNED (type1))\n     {\n       tmp = create_tmp_var (build_nonstandard_integer_type\n-\t\t\t\t(actual_precision, TYPE_UNSIGNED (type1)),\n+\t\t\t\t(actual_precision, from_unsigned1),\n \t\t\t    NULL);\n       rhs1 = build_and_insert_cast (gsi, loc, tmp, rhs1);\n-\n+    }\n+  if (actual_precision != TYPE_PRECISION (type2)\n+      || from_unsigned2 != TYPE_UNSIGNED (type2))\n+    {\n       /* Reuse the same type info, if possible.  */\n-      if (TYPE_UNSIGNED (type1) != TYPE_UNSIGNED (type2))\n+      if (!tmp || from_unsigned1 != from_unsigned2)\n \ttmp = create_tmp_var (build_nonstandard_integer_type\n-\t\t\t\t(actual_precision, TYPE_UNSIGNED (type2)),\n+\t\t\t\t(actual_precision, from_unsigned2),\n \t\t\t      NULL);\n       rhs2 = build_and_insert_cast (gsi, loc, tmp, rhs2);\n     }\n@@ -2137,7 +2163,7 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n {\n   gimple rhs1_stmt = NULL, rhs2_stmt = NULL;\n   gimple conv1_stmt = NULL, conv2_stmt = NULL, conv_stmt;\n-  tree type, type1, type2, tmp;\n+  tree type, type1, type2, optype, tmp = NULL;\n   tree lhs, rhs1, rhs2, mult_rhs1, mult_rhs2, add_rhs;\n   enum tree_code rhs1_code = ERROR_MARK, rhs2_code = ERROR_MARK;\n   optab this_optab;\n@@ -2146,6 +2172,7 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n   enum machine_mode to_mode, from_mode, actual_mode;\n   location_t loc = gimple_location (stmt);\n   int actual_precision;\n+  bool from_unsigned1, from_unsigned2;\n \n   lhs = gimple_assign_lhs (stmt);\n   type = TREE_TYPE (lhs);\n@@ -2239,16 +2266,29 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n \n   to_mode = TYPE_MODE (type);\n   from_mode = TYPE_MODE (type1);\n+  from_unsigned1 = TYPE_UNSIGNED (type1);\n+  from_unsigned2 = TYPE_UNSIGNED (type2);\n \n-  if (TYPE_UNSIGNED (type1) != TYPE_UNSIGNED (type2))\n-    return false;\n+  /* There's no such thing as a mixed sign madd yet, so use a wider mode.  */\n+  if (from_unsigned1 != from_unsigned2)\n+    {\n+      enum machine_mode mode = GET_MODE_WIDER_MODE (from_mode);\n+      if (GET_MODE_PRECISION (mode) < GET_MODE_PRECISION (to_mode))\n+\t{\n+\t  from_mode = mode;\n+\t  from_unsigned1 = from_unsigned2 = false;\n+\t}\n+      else\n+\treturn false;\n+    }\n \n   /* If there was a conversion between the multiply and addition\n      then we need to make sure it fits a multiply-and-accumulate.\n      The should be a single mode change which does not change the\n      value.  */\n   if (conv_stmt)\n     {\n+      /* We use the original, unmodified data types for this.  */\n       tree from_type = TREE_TYPE (gimple_assign_rhs1 (conv_stmt));\n       tree to_type = TREE_TYPE (gimple_assign_lhs (conv_stmt));\n       int data_size = TYPE_PRECISION (type1) + TYPE_PRECISION (type2);\n@@ -2273,7 +2313,8 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n   /* Verify that the machine can perform a widening multiply\n      accumulate in this mode/signedness combination, otherwise\n      this transformation is likely to pessimize code.  */\n-  this_optab = optab_for_tree_code (wmult_code, type1, optab_default);\n+  optype = build_nonstandard_integer_type (from_mode, from_unsigned1);\n+  this_optab = optab_for_tree_code (wmult_code, optype, optab_default);\n   handler = find_widening_optab_handler_and_mode (this_optab, to_mode,\n \t\t\t\t\t\t  from_mode, 0, &actual_mode);\n \n@@ -2283,13 +2324,21 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n   /* Ensure that the inputs to the handler are in the correct precison\n      for the opcode.  This will be the full mode size.  */\n   actual_precision = GET_MODE_PRECISION (actual_mode);\n-  if (actual_precision != TYPE_PRECISION (type1))\n+  if (actual_precision != TYPE_PRECISION (type1)\n+      || from_unsigned1 != TYPE_UNSIGNED (type1))\n     {\n       tmp = create_tmp_var (build_nonstandard_integer_type\n-\t\t\t\t(actual_precision, TYPE_UNSIGNED (type1)),\n+\t\t\t\t(actual_precision, from_unsigned1),\n \t\t\t    NULL);\n-\n       mult_rhs1 = build_and_insert_cast (gsi, loc, tmp, mult_rhs1);\n+    }\n+  if (actual_precision != TYPE_PRECISION (type2)\n+      || from_unsigned2 != TYPE_UNSIGNED (type2))\n+    {\n+      if (!tmp || from_unsigned1 != from_unsigned2)\n+\ttmp = create_tmp_var (build_nonstandard_integer_type\n+\t\t\t\t(actual_precision, from_unsigned2),\n+\t\t\t      NULL);\n       mult_rhs2 = build_and_insert_cast (gsi, loc, tmp, mult_rhs2);\n     }\n "}]}