{"sha": "e804281eadc6e2adf7da500be1cee62b6f572438", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgwNDI4MWVhZGM2ZTJhZGY3ZGE1MDBiZTFjZWU2MmI2ZjU3MjQzOA==", "commit": {"author": {"name": "Stan Shebs", "email": "shebs@apple.com", "date": "2001-03-28T02:49:19Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2001-03-28T02:49:19Z"}, "message": "objc-act.c (objc_init): Use dump_base_name.\n\n\t* objc/objc-act.c (objc_init): Use dump_base_name.\n        (gen_declaration): Clear the buffer arg.\n        (gen_declaration_1): New function, body of gen_declaration.\n        (adorn_decl): Call gen_declaration_1 instead of gen_declaration.\n        (gen_method_decl): Ditto, plus always clear buffer arg.\n        (error_with_ivar): Simplify.\n        (warn_with_method): Ditto.\n        (build_message_expr): Don't clear buffers.\n        (dump_interface): Ditto.\n        (objc_debug): Ditto.\n        (build_keyword_selector): Clear the buffer by only zeroing\n        the first element.\n        (objc_implementation_context): Declare.\n        (start_class): Warn about missing @end.\n        (finish_objc): Ditto.\n\nFrom-SVN: r40895", "tree": {"sha": "90f57e3b213570146b46f96de3241492f9d1f113", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90f57e3b213570146b46f96de3241492f9d1f113"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e804281eadc6e2adf7da500be1cee62b6f572438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e804281eadc6e2adf7da500be1cee62b6f572438", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e804281eadc6e2adf7da500be1cee62b6f572438", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e804281eadc6e2adf7da500be1cee62b6f572438/comments", "author": null, "committer": null, "parents": [{"sha": "787d2fb712fa7871c40a87b44b86adae14ae3f7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/787d2fb712fa7871c40a87b44b86adae14ae3f7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/787d2fb712fa7871c40a87b44b86adae14ae3f7a"}], "stats": {"total": 109, "additions": 78, "deletions": 31}, "files": [{"sha": "6d8d1152e076abb400633a19d9104eb77918afa2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e804281eadc6e2adf7da500be1cee62b6f572438/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e804281eadc6e2adf7da500be1cee62b6f572438/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e804281eadc6e2adf7da500be1cee62b6f572438", "patch": "@@ -1,3 +1,21 @@\n+2001-03-27  Stan Shebs  <shebs@apple.com>\n+\n+\t* objc/objc-act.c (objc_init): Use dump_base_name.\n+\t(gen_declaration): Clear the buffer arg.\n+\t(gen_declaration_1): New function, body of gen_declaration.\n+\t(adorn_decl): Call gen_declaration_1 instead of gen_declaration.\n+\t(gen_method_decl): Ditto, plus always clear buffer arg.\n+\t(error_with_ivar): Simplify.\n+\t(warn_with_method): Ditto.\n+\t(build_message_expr): Don't clear buffers.\n+\t(dump_interface): Ditto.\n+\t(objc_debug): Ditto.\n+\t(build_keyword_selector): Clear the buffer by only zeroing\n+\tthe first element.\n+\t(objc_implementation_context): Declare.\n+\t(start_class): Warn about missing @end.\n+\t(finish_objc): Ditto.\n+\n 2001-03-28  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* reload1.c (eliminate_regs): Don't abort on MEM USEs."}, {"sha": "51f940eb2a1bcf58ee41c226023a5c95f21d4e42", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 60, "deletions": 31, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e804281eadc6e2adf7da500be1cee62b6f572438/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e804281eadc6e2adf7da500be1cee62b6f572438/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=e804281eadc6e2adf7da500be1cee62b6f572438", "patch": "@@ -142,6 +142,9 @@ char *util_firstobj;\n #define OBJC_ENCODE_INLINE_DEFS \t0\n #define OBJC_ENCODE_DONT_INLINE_DEFS\t1\n \n+/* Needed to help fix missing @end situations.  */\n+extern tree objc_implementation_context;\n+\n /*** Private Interface (procedures) ***/\n \n /* Used by compile_file.  */\n@@ -272,6 +275,7 @@ static void warn_with_method\t\t\tPARAMS ((const char *, int, tree));\n static void error_with_ivar\t\t\tPARAMS ((const char *, tree, tree));\n static char *gen_method_decl\t\t\tPARAMS ((tree, char *));\n static char *gen_declaration\t\t\tPARAMS ((tree, char *));\n+static void gen_declaration_1\t\t\tPARAMS ((tree, char *));\n static char *gen_declarator\t\t\tPARAMS ((tree, char *,\n \t\t\t\t\t\t       const char *));\n static int is_complex_decl\t\t\tPARAMS ((tree));\n@@ -727,7 +731,7 @@ objc_init ()\n   /* If gen_declaration desired, open the output file.  */\n   if (flag_gen_declaration)\n     {\n-      register char * const dumpname = concat (dumpname, \".decl\", NULL);\n+      register char * const dumpname = concat (dump_base_name, \".decl\", NULL);\n       gen_declaration_file = fopen (dumpname, \"w\");\n       if (gen_declaration_file == 0)\n \tfatal_io_error (\"can't open %s\", dumpname);\n@@ -1146,7 +1150,7 @@ get_object_reference (protocols)\n       type = TREE_TYPE (type_decl);\n       if (TYPE_MAIN_VARIANT (type) != id_type)\n \twarning (\"Unexpected type for `id' (%s)\",\n-\t\tgen_declaration (type, errbuf));\n+\t\t gen_declaration (type, errbuf));\n     }\n   else\n     {\n@@ -3616,13 +3620,11 @@ error_with_ivar (message, decl, rawdecl)\n \n   report_error_function (DECL_SOURCE_FILE (decl));\n \n-  strcpy (errbuf, message);\n-  strcat (errbuf, \" `\");\n-  gen_declaration (rawdecl, errbuf + strlen (errbuf));\n-  strcat (errbuf, \"'\");\n   error_with_file_and_line (DECL_SOURCE_FILE (decl),\n \t\t\t    DECL_SOURCE_LINE (decl),\n-\t\t\t    errbuf);\n+\t\t\t    \"%s `%s'\",\n+\t\t\t    message, gen_declaration (rawdecl, errbuf));\n+\n }\n \n #define USERTYPE(t) \\\n@@ -4717,6 +4719,7 @@ build_keyword_selector (selector)\n   tree key_chain, key_name;\n   char *buf;\n \n+  /* Scan the selector to see how much space we'll need.  */\n   for (key_chain = selector; key_chain; key_chain = TREE_CHAIN (key_chain))\n     {\n       if (TREE_CODE (selector) == KEYWORD_DECL)\n@@ -4733,8 +4736,9 @@ build_keyword_selector (selector)\n \tlen++;\n     }\n \n-  buf = (char *)alloca (len + 1);\n-  memset (buf, 0, len + 1);\n+  buf = (char *) alloca (len + 1);\n+  /* Start the buffer out as an empty string.  */\n+  buf[0] = '\\0';\n \n   for (key_chain = selector; key_chain; key_chain = TREE_CHAIN (key_chain))\n     {\n@@ -4970,7 +4974,6 @@ build_message_expr (mess)\n \t       /* Allow any type that matches objc_class_type.  */\n \t       && ! comptypes (rtype, objc_class_type))\n \t{\n-\t  memset (errbuf, 0, BUFSIZE);\n \t  warning (\"invalid receiver type `%s'\",\n \t\t   gen_declaration (rtype, errbuf));\n \t}\n@@ -6135,6 +6138,14 @@ start_class (code, class_name, super_name, protocol_list)\n {\n   tree class, decl;\n \n+  if (objc_implementation_context)\n+    {\n+      warning (\"`@end' missing in implementation context\");\n+      finish_class (objc_implementation_context);\n+      objc_ivar_chain = NULL_TREE;\n+      objc_implementation_context = NULL_TREE;\n+    }\n+\n   class = make_node (code);\n   TYPE_BINFO (class) = make_tree_vec (5);\n \n@@ -7047,13 +7058,11 @@ warn_with_method (message, mtype, method)\n   report_error_function (DECL_SOURCE_FILE (method));\n \n   /* Add a readable method name to the warning.  */\n-  sprintf (errbuf, \"%s `%c\", message, mtype);\n-  gen_method_decl (method, errbuf + strlen (errbuf));\n-  strcat (errbuf, \"'\");\n-\n   warning_with_file_and_line (DECL_SOURCE_FILE (method),\n \t\t\t      DECL_SOURCE_LINE (method),\n-\t\t\t      errbuf);\n+\t\t\t      \"%s `%c%s'\",\n+\t\t\t      message, mtype,\n+\t\t\t      gen_method_decl (method, errbuf));\n }\n \n /* Return 1 if METHOD is consistent with PROTO.  */\n@@ -7477,7 +7486,7 @@ adorn_decl (decl, str)\n       strcat (str, \"(\");\n       while (chain)\n \t{\n-\t  gen_declaration (chain, str);\n+\t  gen_declaration_1 (chain, str);\n \t  chain = TREE_CHAIN (chain);\n \t  if (chain)\n \t    strcat (str, \", \");\n@@ -7492,7 +7501,7 @@ adorn_decl (decl, str)\n       strcat (str, \"(\");\n       while (chain && TREE_VALUE (chain) != void_type_node)\n \t{\n-\t  gen_declaration (TREE_VALUE (chain), str);\n+\t  gen_declaration_1 (TREE_VALUE (chain), str);\n \t  chain = TREE_CHAIN (chain);\n \t  if (chain && TREE_VALUE (chain) != void_type_node)\n \t    strcat (str, \", \");\n@@ -7885,10 +7894,26 @@ gen_declspecs (declspecs, buf, raw)\n     }\n }\n \n+/* Given a tree node, produce a printable description of it in the given\n+   buffer, overwriting the buffer.  */\n+\n static char *\n gen_declaration (atype_or_adecl, buf)\n      tree atype_or_adecl;\n      char *buf;\n+{\n+  buf[0] = '\\0';\n+  gen_declaration_1 (atype_or_adecl, buf);\n+  return buf;\n+}\n+\n+/* Given a tree node, append a printable description to the end of the\n+   given buffer.  */\n+\n+static void\n+gen_declaration_1 (atype_or_adecl, buf)\n+     tree atype_or_adecl;\n+     char *buf;\n {\n   char declbuf[256];\n \n@@ -7969,23 +7994,25 @@ gen_declaration (atype_or_adecl, buf)\n \t  strcat (buf, gen_declarator (declarator, declbuf, \"\"));\n \t}\n     }\n-\n-  return buf;\n }\n \n #define RAW_TYPESPEC(meth) (TREE_VALUE (TREE_PURPOSE (TREE_TYPE (meth))))\n \n+/* Given a method tree, put a printable description into the given\n+   buffer (overwriting) and return a pointer to the buffer.  */\n+\n static char *\n gen_method_decl (method, buf)\n      tree method;\n      char *buf;\n {\n   tree chain;\n \n+  buf[0] = '\\0';\n   if (RAW_TYPESPEC (method) != objc_object_reference)\n     {\n-      strcpy (buf, \"(\");\n-      gen_declaration (TREE_TYPE (method), buf);\n+      strcat (buf, \"(\");\n+      gen_declaration_1 (TREE_TYPE (method), buf);\n       strcat (buf, \")\");\n     }\n \n@@ -8002,7 +8029,7 @@ gen_method_decl (method, buf)\n \t  if (RAW_TYPESPEC (chain) != objc_object_reference)\n \t    {\n \t      strcat (buf, \"(\");\n-\t      gen_declaration (TREE_TYPE (chain), buf);\n+\t      gen_declaration_1 (TREE_TYPE (chain), buf);\n \t      strcat (buf, \")\");\n \t    }\n \n@@ -8023,7 +8050,7 @@ gen_method_decl (method, buf)\n           while (chain)\n             {\n \t      strcat (buf, \", \");\n-\t      gen_declaration (chain, buf);\n+\t      gen_declaration_1 (chain, buf);\n \t      chain = TREE_CHAIN (chain);\n             }\n \t}\n@@ -8064,7 +8091,6 @@ dump_interface (fp, chain)\n       fprintf (fp, \"{\\n\");\n       do\n \t{\n-\t  memset (buf, 0, 256);\n \t  fprintf (fp, \"\\t%s;\\n\", gen_declaration (ivar_decls, buf));\n \t  ivar_decls = TREE_CHAIN (ivar_decls);\n \t}\n@@ -8074,14 +8100,12 @@ dump_interface (fp, chain)\n \n   while (nst_methods)\n     {\n-      memset (buf, 0, 256);\n       fprintf (fp, \"- %s;\\n\", gen_method_decl (nst_methods, buf));\n       nst_methods = TREE_CHAIN (nst_methods);\n     }\n \n   while (cls_methods)\n     {\n-      memset (buf, 0, 256);\n       fprintf (fp, \"+ %s;\\n\", gen_method_decl (cls_methods, buf));\n       cls_methods = TREE_CHAIN (cls_methods);\n     }\n@@ -8196,6 +8220,15 @@ finish_objc ()\n   int save_warn_missing_braces = warn_missing_braces;\n   warn_missing_braces = 0;\n \n+  /* A missing @end may not be detected by the parser.  */\n+  if (objc_implementation_context)\n+    {\n+      warning (\"`@end' missing in implementation context\");\n+      finish_class (implementation_context);\n+      objc_ivar_chain = NULL_TREE;\n+      objc_implementation_context = NULL_TREE;\n+    }\n+\n   generate_forward_declaration_to_string_table ();\n \n #ifdef OBJC_PROLOGUE\n@@ -8480,9 +8513,7 @@ objc_debug (fp)\n \tif (TREE_CODE (loop) == FUNCTION_DECL && DECL_INITIAL (loop))\n \t  {\n \t    /* We have a function definition: generate prototype.  */\n-            memset (errbuf, 0, BUFSIZE);\n-\t    gen_declaration (loop, errbuf);\n-\t    fprintf (fp, \"%s;\\n\", errbuf);\n+\t    fprintf (fp, \"%s;\\n\", gen_declaration (loop, errbuf));\n \t  }\n \tloop = TREE_CHAIN (loop);\n       }\n@@ -8500,7 +8531,6 @@ objc_debug (fp)\n \t    fprintf (fp, \"\\n\\nnst_method_hash_list[%d]:\\n\", i);\n \t    do\n \t      {\n-\t\tmemset (buf, 0, 256);\n \t\tfprintf (fp, \"-%s;\\n\", gen_method_decl (hashlist->key, buf));\n \t\thashlist = hashlist->next;\n \t      }\n@@ -8515,7 +8545,6 @@ objc_debug (fp)\n \t    fprintf (fp, \"\\n\\ncls_method_hash_list[%d]:\\n\", i);\n \t    do\n \t      {\n-\t\tmemset (buf, 0, 256);\n \t\tfprintf (fp, \"-%s;\\n\", gen_method_decl (hashlist->key, buf));\n \t\thashlist = hashlist->next;\n \t      }"}]}