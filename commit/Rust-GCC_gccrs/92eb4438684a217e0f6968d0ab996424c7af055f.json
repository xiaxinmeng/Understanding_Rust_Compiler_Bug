{"sha": "92eb4438684a217e0f6968d0ab996424c7af055f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJlYjQ0Mzg2ODRhMjE3ZTBmNjk2OGQwYWI5OTY0MjRjN2FmMDU1Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-07-05T18:25:04Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-07-05T18:25:04Z"}, "message": "cgraph.h (cgraph_node, [...]): Update docmentation of in_other_partition.\n\n\n\t* cgraph.h (cgraph_node, cgraph_varpool_node): Update docmentation of\n\tin_other_partition.\n\t* lto-cgraph.c (referenced_from_other_partition_p,\n\treachable_from_other_partition_p): Use in_other_partition flags.\n\t(output_node, output_varpool_node): COMDAT nodes always have private\n\tcopies and thus are never used from other partition.\n\n\t* lto.c (add_cgraph_node_to_partition): Forward declare; walk also\n\tnodes from same comdat group as well as all comdat functions referenced\n\there.\n\t(add_varpool_node_to_partition, add_references_to_partition): New function.\n\t(lto_1_1_map): Skip COMDAT fnctions/variables; use add_varpool_node_to_partition;\n\tclear aux flags when done.\n\t(lto_promote_cross_file_statics): Do not promote stuff that gets duplicated to\n\teach ltrans.\n\nFrom-SVN: r161846", "tree": {"sha": "1ae95da0182acf8c922d2c36bf583ce953dc8ba6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ae95da0182acf8c922d2c36bf583ce953dc8ba6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92eb4438684a217e0f6968d0ab996424c7af055f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92eb4438684a217e0f6968d0ab996424c7af055f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92eb4438684a217e0f6968d0ab996424c7af055f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92eb4438684a217e0f6968d0ab996424c7af055f/comments", "author": null, "committer": null, "parents": [{"sha": "69e18c0985d5e4488b30ccae1e242e004bf274ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69e18c0985d5e4488b30ccae1e242e004bf274ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69e18c0985d5e4488b30ccae1e242e004bf274ed"}], "stats": {"total": 135, "additions": 120, "deletions": 15}, "files": [{"sha": "75b56458fe34c601d2eff5f3264b217d6dcf9f61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92eb4438684a217e0f6968d0ab996424c7af055f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92eb4438684a217e0f6968d0ab996424c7af055f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92eb4438684a217e0f6968d0ab996424c7af055f", "patch": "@@ -1,3 +1,12 @@\n+2010-07-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (cgraph_node, cgraph_varpool_node): Update docmentation of\n+\tin_other_partition.\n+\t* lto-cgraph.c (referenced_from_other_partition_p,\n+\treachable_from_other_partition_p): Use in_other_partition flags.\n+\t(output_node, output_varpool_node): COMDAT nodes always have private\n+\tcopies and thus are never used from other partition.\n+\n 2010-07-05  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/ia64/ia64.h (MEMORY_MOVE_COST): Remove macro."}, {"sha": "bbce3d8ef03538ef92326185cdfb38edd7317c36", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92eb4438684a217e0f6968d0ab996424c7af055f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92eb4438684a217e0f6968d0ab996424c7af055f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=92eb4438684a217e0f6968d0ab996424c7af055f", "patch": "@@ -286,7 +286,9 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   /* Set once the function has been instantiated and its callee\n      lists created.  */\n   unsigned analyzed : 1;\n-  /* Set when function is available in the other LTRANS partition.  */\n+  /* Set when function is available in the other LTRANS partition.  \n+     During WPA output it is used to mark nodes that are present in\n+     multiple partitions.  */\n   unsigned in_other_partition : 1;\n   /* Set when function is scheduled to be processed by local passes.  */\n   unsigned process : 1;\n@@ -497,7 +499,9 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n   unsigned alias : 1;\n   /* Set when variable is used from other LTRANS partition.  */\n   unsigned used_from_other_partition : 1;\n-  /* Set when variable is available in the other LTRANS partition.  */\n+  /* Set when variable is available in the other LTRANS partition.\n+     During WPA output it is used to mark nodes that are present in\n+     multiple partitions.  */\n   unsigned in_other_partition : 1;\n };\n \n@@ -556,6 +560,7 @@ struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n struct cgraph_edge *cgraph_create_indirect_edge (struct cgraph_node *, gimple, int,\n \t\t\t\t\t\t gcov_type, int, int);\n struct cgraph_node * cgraph_get_node (tree);\n+struct cgraph_node * cgraph_get_node_or_alias (tree);\n struct cgraph_node *cgraph_node (tree);\n bool cgraph_same_body_alias (tree, tree);\n void cgraph_add_thunk (tree, tree, bool, HOST_WIDE_INT, HOST_WIDE_INT, tree, tree);"}, {"sha": "4217a71da35c76a19382669b90eba2dd16868b15", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92eb4438684a217e0f6968d0ab996424c7af055f/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92eb4438684a217e0f6968d0ab996424c7af055f/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=92eb4438684a217e0f6968d0ab996424c7af055f", "patch": "@@ -319,13 +319,15 @@ referenced_from_other_partition_p (struct ipa_ref_list *list, cgraph_node_set se\n     {\n       if (ref->refering_type == IPA_REF_CGRAPH)\n \t{\n-\t  if (!cgraph_node_in_set_p (ipa_ref_refering_node (ref), set))\n+\t  if (ipa_ref_refering_node (ref)->in_other_partition\n+\t      || !cgraph_node_in_set_p (ipa_ref_refering_node (ref), set))\n \t    return true;\n \t}\n       else\n \t{\n-\t  if (!varpool_node_in_set_p (ipa_ref_refering_varpool_node (ref),\n-\t\t\t\t      vset))\n+\t  if (ipa_ref_refering_varpool_node (ref)->in_other_partition\n+\t      || !varpool_node_in_set_p (ipa_ref_refering_varpool_node (ref),\n+\t\t\t\t         vset))\n \t    return true;\n \t}\n     }\n@@ -343,7 +345,8 @@ reachable_from_other_partition_p (struct cgraph_node *node, cgraph_node_set set)\n   if (node->global.inlined_to)\n     return false;\n   for (e = node->callers; e; e = e->next_caller)\n-    if (!cgraph_node_in_set_p (e->caller, set))\n+    if (e->caller->in_other_partition\n+\t|| !cgraph_node_in_set_p (e->caller, set))\n       return true;\n   return false;\n }\n@@ -503,6 +506,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->abstract_and_needed, 1);\n   bp_pack_value (&bp, tag == LTO_cgraph_analyzed_node\n \t\t && !DECL_EXTERNAL (node->decl)\n+\t\t && !DECL_COMDAT (node->decl)\n \t\t && (reachable_from_other_partition_p (node, set)\n \t\t     || referenced_from_other_partition_p (&node->ref_list, set, vset)), 1);\n   bp_pack_value (&bp, node->lowered, 1);\n@@ -576,7 +580,8 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n      FIXME: Alternatively at -Os we may want to avoid generating for them the local\n      labels and share them across LTRANS partitions.  */\n-  if (DECL_IN_CONSTANT_POOL (node->decl))\n+  if (DECL_IN_CONSTANT_POOL (node->decl)\n+      && !DECL_COMDAT (node->decl))\n     {\n       bp_pack_value (&bp, 0, 1);  /* used_from_other_parition.  */\n       bp_pack_value (&bp, 0, 1);  /* in_other_partition.  */"}, {"sha": "a1a03b67a8c4cde86b1d43ae257363c3cabe6bd0", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92eb4438684a217e0f6968d0ab996424c7af055f/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92eb4438684a217e0f6968d0ab996424c7af055f/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=92eb4438684a217e0f6968d0ab996424c7af055f", "patch": "@@ -1,3 +1,14 @@\n+2010-07-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (add_cgraph_node_to_partition): Forward declare; walk also\n+\tnodes from same comdat group as well as all comdat functions referenced\n+\there.\n+\t(add_varpool_node_to_partition, add_references_to_partition): New function.\n+\t(lto_1_1_map): Skip COMDAT fnctions/variables; use add_varpool_node_to_partition;\n+\tclear aux flags when done.\n+\t(lto_promote_cross_file_statics): Do not promote stuff that gets duplicated to\n+\teach ltrans.\n+\n 2010-07-04  Jan Hubicka  <jh@suse.cz>\n \n         * lto.c (read_cgraph_and_symbols): Dump cgraph before merging."}, {"sha": "4ac1ac1bea37f0771490f1af57d291d84a89de39", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 83, "deletions": 8, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92eb4438684a217e0f6968d0ab996424c7af055f/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92eb4438684a217e0f6968d0ab996424c7af055f/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=92eb4438684a217e0f6968d0ab996424c7af055f", "patch": "@@ -525,6 +525,9 @@ DEF_VEC_ALLOC_P(ltrans_partition,gc);\n \n static GTY (()) VEC(ltrans_partition, gc) *ltrans_partitions;\n \n+static void add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node);\n+static void add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode);\n+\n /* Create new partition with name NAME.  */\n static ltrans_partition\n new_partition (const char *name)\n@@ -538,17 +541,77 @@ new_partition (const char *name)\n   return part;\n }\n \n-/* Add NODE to partition as well as the inline callees into partition PART. */\n+/* See all references that go to comdat objects and bring them into partition too.  */\n+static void\n+add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_reference_iterate (refs, i, ref); i++)\n+    {\n+      if (ref->refered_type == IPA_REF_CGRAPH\n+\t  && DECL_COMDAT (ipa_ref_node (ref)->decl)\n+\t  && !cgraph_node_in_set_p (ipa_ref_node (ref), part->cgraph_set))\n+\tadd_cgraph_node_to_partition (part, ipa_ref_node (ref));\n+      else\n+\tif (ref->refered_type == IPA_REF_VARPOOL\n+\t    && DECL_COMDAT (ipa_ref_varpool_node (ref)->decl)\n+\t    && !varpool_node_in_set_p (ipa_ref_varpool_node (ref), part->varpool_set))\n+\t  add_varpool_node_to_partition (part, ipa_ref_varpool_node (ref));\n+    }\n+}\n+\n+/* Add NODE to partition as well as the inline callees and referred comdats into partition PART. */\n \n static void\n add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n+\n   part->insns += node->local.inline_summary.self_size;\n+\n+  if (node->aux)\n+    {\n+      gcc_assert (node->aux != part);\n+      node->in_other_partition = 1;\n+    }\n+  else\n+    node->aux = part;\n+\n   cgraph_node_set_add (part->cgraph_set, node);\n+\n   for (e = node->callees; e; e = e->next_callee)\n-    if (!e->inline_failed)\n+    if ((!e->inline_failed || DECL_COMDAT (e->callee->decl))\n+\t&& !cgraph_node_in_set_p (e->callee, part->cgraph_set))\n       add_cgraph_node_to_partition (part, e->callee);\n+\n+  add_references_to_partition (part, &node->ref_list);\n+\n+  if (node->same_comdat_group\n+      && !cgraph_node_in_set_p (node->same_comdat_group, part->cgraph_set))\n+    add_cgraph_node_to_partition (part, node->same_comdat_group);\n+}\n+\n+/* Add VNODE to partition as well as comdat references partition PART. */\n+\n+static void\n+add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode)\n+{\n+  varpool_node_set_add (part->varpool_set, vnode);\n+\n+  if (vnode->aux)\n+    {\n+      gcc_assert (vnode->aux != part);\n+      vnode->in_other_partition = 1;\n+    }\n+  else\n+    vnode->aux = part;\n+\n+  add_references_to_partition (part, &vnode->ref_list);\n+\n+  if (vnode->same_comdat_group\n+      && !varpool_node_in_set_p (vnode->same_comdat_group, part->varpool_set))\n+    add_varpool_node_to_partition (part, vnode->same_comdat_group);\n }\n \n /* Group cgrah nodes by input files.  This is used mainly for testing\n@@ -577,6 +640,10 @@ lto_1_to_1_map (void)\n       /* Nodes without a body do not need partitioning.  */\n       if (!node->analyzed)\n \tcontinue;\n+      /* Extern inlines and comdat are always only in partitions they are needed.  */\n+      if (DECL_EXTERNAL (node->decl)\n+\t  || DECL_COMDAT (node->decl))\n+\tcontinue;\n \n       file_data = node->local.lto_file_data;\n       gcc_assert (!node->same_body_alias && file_data);\n@@ -599,6 +666,10 @@ lto_1_to_1_map (void)\n     {\n       if (vnode->alias || !vnode->needed)\n \tcontinue;\n+      /* Constant pool and comdat are always only in partitions they are needed.  */\n+      if (DECL_IN_CONSTANT_POOL (vnode->decl)\n+\t  || DECL_COMDAT (vnode->decl))\n+\tcontinue;\n       file_data = vnode->lto_file_data;\n       slot = pointer_map_contains (pmap, file_data);\n       if (slot)\n@@ -611,8 +682,12 @@ lto_1_to_1_map (void)\n \t  npartitions++;\n \t}\n \n-      varpool_node_set_add (partition->varpool_set, vnode);\n+      add_varpool_node_to_partition (partition, vnode);\n     }\n+  for (node = cgraph_nodes; node; node = node->next)\n+    node->aux = NULL;\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    vnode->aux = NULL;\n \n   /* If the cgraph is empty, create one cgraph node set so that there is still\n      an output file for any variables that need to be exported in a DSO.  */\n@@ -704,7 +779,7 @@ lto_promote_cross_file_statics (void)\n \t    continue;\n \t  if (node->global.inlined_to)\n \t    continue;\n-\t  if (!DECL_EXTERNAL (node->decl)\n+\t  if ((!DECL_EXTERNAL (node->decl) && !DECL_COMDAT (node->decl))\n \t      && (referenced_from_other_partition_p (&node->ref_list, set, vset)\n \t\t  || reachable_from_other_partition_p (node, set)))\n \t    promote_fn (node);\n@@ -715,10 +790,10 @@ lto_promote_cross_file_statics (void)\n \t  /* Constant pool references use internal labels and thus can not\n \t     be made global.  It is sensible to keep those ltrans local to\n \t     allow better optimization.  */\n-\t  if (!DECL_IN_CONSTANT_POOL (vnode->decl)\n-\t     && !vnode->externally_visible && vnode->analyzed\n-\t     && referenced_from_other_partition_p (&vnode->ref_list,\n-\t\t\t\t\t\t   set, vset))\n+\t  if (!DECL_IN_CONSTANT_POOL (vnode->decl) && !DECL_COMDAT (vnode->decl)\n+\t      && !vnode->externally_visible && vnode->analyzed\n+\t      && referenced_from_other_partition_p (&vnode->ref_list,\n+\t\t\t\t\t\t    set, vset))\n \t    promote_var (vnode);\n \t}\n "}]}