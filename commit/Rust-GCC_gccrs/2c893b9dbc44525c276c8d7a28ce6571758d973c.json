{"sha": "2c893b9dbc44525c276c8d7a28ce6571758d973c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4OTNiOWRiYzQ0NTI1YzI3NmM4ZDdhMjhjZTY1NzE3NThkOTczYw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2011-10-05T08:05:14Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-10-05T08:05:14Z"}, "message": "i386.c (ix86_emit_binop): New static function.\n\n\t* config/i386/i386.c (ix86_emit_binop): New static function.\n\t(ix86_split_lea_for_addr): Use ix86_emit_binop to emit add and shl\n\tinstructions.\n\t(x86_output_mi_thunk): Use ix86_emit_binop to emit add instructions.\n\nFrom-SVN: r179537", "tree": {"sha": "2b59e921df550c37ec14e8ff0b415867d6094a6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b59e921df550c37ec14e8ff0b415867d6094a6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c893b9dbc44525c276c8d7a28ce6571758d973c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c893b9dbc44525c276c8d7a28ce6571758d973c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c893b9dbc44525c276c8d7a28ce6571758d973c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c893b9dbc44525c276c8d7a28ce6571758d973c/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6f37c8d466bf2e90ea74a6e6d5e7cb79e37bbe8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f37c8d466bf2e90ea74a6e6d5e7cb79e37bbe8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f37c8d466bf2e90ea74a6e6d5e7cb79e37bbe8d"}], "stats": {"total": 113, "additions": 51, "deletions": 62}, "files": [{"sha": "9147e87c1888ea592e41b009a2e604a5bd95a1fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c893b9dbc44525c276c8d7a28ce6571758d973c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c893b9dbc44525c276c8d7a28ce6571758d973c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c893b9dbc44525c276c8d7a28ce6571758d973c", "patch": "@@ -1,3 +1,10 @@\n+2011-10-05  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (ix86_emit_binop): New static function.\n+\t(ix86_split_lea_for_addr): Use ix86_emit_binop to emit add and shl\n+\tinstructions.\n+\t(x86_output_mi_thunk): Use ix86_emit_binop to emit add instructions.\n+\n 2011-10-04  David S. Miller  <davem@davemloft.net>\n \n \t* config/sparc/sparc.md (UNSPEC_FHADD, UNSPEC_FHSUB,"}, {"sha": "ca7d85ab0737bbcd5f4515147da14c70006f5c21", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 44, "deletions": 62, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c893b9dbc44525c276c8d7a28ce6571758d973c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c893b9dbc44525c276c8d7a28ce6571758d973c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2c893b9dbc44525c276c8d7a28ce6571758d973c", "patch": "@@ -16470,6 +16470,21 @@ ix86_avoid_lea_for_addr (rtx insn, rtx operands[])\n   return !ix86_lea_outperforms (insn, regno0, regno1, regno2, split_cost);\n }\n \n+/* Emit x86 binary operand CODE in mode MODE, where the first operand\n+   matches destination.  RTX includes clobber of FLAGS_REG.  */\n+\n+static void\n+ix86_emit_binop (enum rtx_code code, enum machine_mode mode,\n+\t\t rtx dst, rtx src)\n+{\n+  rtx op, clob;\n+\n+  op = gen_rtx_SET (VOIDmode, dst, gen_rtx_fmt_ee (code, mode, dst, src));\n+  clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+  \n+  emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, op, clob)));\n+}\n+\n /* Split lea instructions into a sequence of instructions\n    which are executed on ALU to avoid AGU stalls.\n    It is assumed that it is allowed to clobber flags register\n@@ -16482,8 +16497,7 @@ ix86_split_lea_for_addr (rtx operands[], enum machine_mode mode)\n   unsigned int regno1 = INVALID_REGNUM;\n   unsigned int regno2 = INVALID_REGNUM;\n   struct ix86_address parts;\n-  rtx tmp, clob;\n-  rtvec par;\n+  rtx tmp;\n   int ok, adds;\n \n   ok = ix86_decompose_address (operands[1], &parts);\n@@ -16515,14 +16529,7 @@ ix86_split_lea_for_addr (rtx operands[], enum machine_mode mode)\n \t  gcc_assert (regno2 != regno0);\n \n \t  for (adds = parts.scale; adds > 0; adds--)\n-\t    {\n-\t      tmp = gen_rtx_PLUS (mode, operands[0], parts.index);\n-\t      tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n-\t      clob = gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t      gen_rtx_REG (CCmode, FLAGS_REG));\n-\t      par = gen_rtvec (2, tmp, clob);\n-\t      emit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n-\t    }\n+\t    ix86_emit_binop (PLUS, mode, operands[0], parts.index);\n \t}\n       else\n \t{\n@@ -16531,30 +16538,14 @@ ix86_split_lea_for_addr (rtx operands[], enum machine_mode mode)\n \t    emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.index));\n \n \t  /* Use shift for scaling.  */\n-\t  tmp = gen_rtx_ASHIFT (mode, operands[0],\n-\t\t\t\tGEN_INT (exact_log2 (parts.scale)));\n-\t  tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n-\t  clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n-\t  par = gen_rtvec (2, tmp, clob);\n-\t  emit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n+\t  ix86_emit_binop (ASHIFT, mode, operands[0],\n+\t\t\t   GEN_INT (exact_log2 (parts.scale)));\n \n \t  if (parts.base)\n-\t    {\n-\t      tmp = gen_rtx_PLUS (mode, operands[0], parts.base);\n-\t      tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n-\t      clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n-\t      par = gen_rtvec (2, tmp, clob);\n-\t      emit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n-\t    }\n+\t    ix86_emit_binop (PLUS, mode, operands[0], parts.base);\n \n \t  if (parts.disp && parts.disp != const0_rtx)\n-\t    {\n-\t      tmp = gen_rtx_PLUS (mode, operands[0], parts.disp);\n-\t      tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n-\t      clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n-\t      par = gen_rtvec (2, tmp, clob);\n-\t      emit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n-\t    }\n+\t    ix86_emit_binop (PLUS, mode, operands[0], parts.disp);\n \t}\n     }\n   else if (!parts.base && !parts.index)\n@@ -16565,41 +16556,32 @@ ix86_split_lea_for_addr (rtx operands[], enum machine_mode mode)\n   else\n     {\n       if (!parts.base)\n-      {\n-        if (regno0 != regno2)\n-\t  emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.index));\n-      }\n+\t{\n+\t  if (regno0 != regno2)\n+\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.index));\n+\t}\n       else if (!parts.index)\n-      {\n-        if (regno0 != regno1)\n-          emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.base));\n-      }\n-      else\n-      {\n-\tif (regno0 == regno1)\n-\t  tmp = gen_rtx_PLUS (mode, operands[0], parts.index);\n-\telse if (regno0 == regno2)\n-\t  tmp = gen_rtx_PLUS (mode, operands[0], parts.base);\n-\telse\n-\t  {\n+\t{\n+\t  if (regno0 != regno1)\n \t    emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.base));\n-\t    tmp = gen_rtx_PLUS (mode, operands[0], parts.index);\n-\t  }\n+\t}\n+      else\n+\t{\n+\t  if (regno0 == regno1)\n+\t    tmp = parts.index;\n+\t  else if (regno0 == regno2)\n+\t    tmp = parts.base;\n+\t  else\n+\t    {\n+\t      emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.base));\n+\t      tmp = parts.index;\n+\t    }\n \n-        tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n-\tclob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n-\tpar = gen_rtvec (2, tmp, clob);\n-\temit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n-      }\n+\t  ix86_emit_binop (PLUS, mode, operands[0], tmp);\n+\t}\n \n       if (parts.disp && parts.disp != const0_rtx)\n-      {\n-        tmp = gen_rtx_PLUS (mode, operands[0], parts.disp);\n-        tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n-\tclob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n-\tpar = gen_rtvec (2, tmp, clob);\n-\temit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n-      }\n+\tix86_emit_binop (PLUS, mode, operands[0], parts.disp);\n     }\n }\n \n@@ -30940,7 +30922,7 @@ x86_output_mi_thunk (FILE *file,\n \t    }\n \t}\n \n-      emit_insn (ix86_gen_add3 (delta_dst, delta_dst, delta_rtx));\n+      ix86_emit_binop (PLUS, Pmode, delta_dst, delta_rtx);\n     }\n \n   /* Adjust the this parameter by a value stored in the vtable.  */\n@@ -30983,7 +30965,7 @@ x86_output_mi_thunk (FILE *file,\n \t\t\t\t\t\t  REGNO (this_reg)),\n \t\t\t\t     vcall_mem));\n       else\n-\temit_insn (ix86_gen_add3 (this_reg, this_reg, vcall_mem));\n+\tix86_emit_binop (PLUS, Pmode, this_reg, vcall_mem);\n     }\n \n   /* If necessary, drop THIS back to its stack slot.  */"}]}