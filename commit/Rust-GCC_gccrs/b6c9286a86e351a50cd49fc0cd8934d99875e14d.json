{"sha": "b6c9286a86e351a50cd49fc0cd8934d99875e14d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZjOTI4NmE4NmUzNTFhNTBjZDQ5ZmMwY2Q4OTM0ZDk5ODc1ZTE0ZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-11-30T20:02:16Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-11-30T20:02:16Z"}, "message": "update PowerPC support\n\nFrom-SVN: r10648", "tree": {"sha": "f69151651957ffbce7b66d0aafdb2b7dcb94a799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f69151651957ffbce7b66d0aafdb2b7dcb94a799"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6c9286a86e351a50cd49fc0cd8934d99875e14d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c9286a86e351a50cd49fc0cd8934d99875e14d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6c9286a86e351a50cd49fc0cd8934d99875e14d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c9286a86e351a50cd49fc0cd8934d99875e14d/comments", "author": null, "committer": null, "parents": [{"sha": "1bad666c7e811d9969feacdaaed4c810a537b24c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bad666c7e811d9969feacdaaed4c810a537b24c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bad666c7e811d9969feacdaaed4c810a537b24c"}], "stats": {"total": 3011, "additions": 2035, "deletions": 976}, "files": [{"sha": "2d9b6530a34e61a0b6c3d2eb23930140ceaabdaa", "filename": "gcc/config/rs6000/aix3newas.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Faix3newas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Faix3newas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix3newas.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -45,6 +45,7 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=403: -mppc} \\\n %{mcpu=601: -m601} \\\n %{mcpu=603: -mppc} \\\n+%{mcpu=603e: -mppc} \\\n %{mcpu=604: -mppc}\"\n \n /* Define the options for the binder: Start text at 512, align all segments\n@@ -65,10 +66,17 @@ Boston, MA 02111-1307, USA.  */\n    as per README.RS6000.  */\n \n #undef\tLINK_SPEC\n+#ifndef CROSS_COMPILE\n #define LINK_SPEC \"-T512 -H512 %{!r:-btextro} -bhalt:4 -bnodelcsect\\\n    %{static:-bnso -bI:/lib/syscalls.exp} \\\n    %{mcpu=common: milli.exp%s} \\\n    %{!shared:%{g*:-bexport:/usr/lib/libg.exp}} %{shared:-bM:SRE}\"\n+#else\n+#define LINK_SPEC \"-T512 -H512 %{!r:-btextro} -bhalt:4 -bnodelcsect\\\n+   %{static:-bnso} \\\n+   %{mcpu=common: milli.exp%s} \\\n+   %{shared:-bM:SRE}\"\n+#endif\n \n /* These are not necessary when we pass -u to the assembler, and undefining\n    them saves a great deal of space in object files.  */"}, {"sha": "a35b3fa1f76d9abc6ccfe0c1fca13fc4337cdb62", "filename": "gcc/config/rs6000/aix41.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Faix41.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Faix41.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix41.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -43,6 +43,7 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=403: -mppc} \\\n %{mcpu=601: -m601} \\\n %{mcpu=603: -mppc} \\\n+%{mcpu=603e: -mppc} \\\n %{mcpu=604: -mppc}\"\n \n /* These are not necessary when we pass -u to the assembler, and undefining\n@@ -65,6 +66,13 @@ Boston, MA 02111-1307, USA.  */\n }\n \n #undef LINK_SPEC\n+#ifndef CROSS_COMPILE\n #define LINK_SPEC \"-bpT:0x10000000 -bpD:0x20000000 %{!r:-btextro} -bnodelcsect\\\n    %{static:-bnso -bI:/lib/syscalls.exp} %{g*:-bexport:/usr/lib/libg.exp}\\\n    %{shared:-bM:SRE}\"\n+#else\n+#define LINK_SPEC \"-bpT:0x10000000 -bpD:0x20000000 %{!r:-btextro} -bnodelcsect\\\n+   %{static:-bnso} \\\n+   %{shared:-bM:SRE}\"\n+#endif\n+"}, {"sha": "b5cf5c5f131fd5c92984ef2cd3fe5b7e6f0559ce", "filename": "gcc/config/rs6000/eabi.asm", "status": "modified", "additions": 316, "deletions": 328, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabi.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabi.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabi.asm?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -1,379 +1,367 @@\n-# File to either setup register 2 to point to the GOT, or to adjust the\n-# pointers in the .got2 section to point to their new addresses.\n+/* Do any initializations needed for the eabi environment */\n \n \t.file\t\"eabi.asm\"\n \t.section \".text\"\n-\t.globl\t __eabi\n+\t#include \"ppc-asm.h\"\n \n \t .section \".got2\",\"aw\"\n-.LCTOC1 = . # +32768\n+.LCTOC1 = . /* +32768 */\n \n-# Table of addresses\n+/* Table of addresses */\n .Ltable = .-.LCTOC1\n-\t.long\t.LCTOC1\t\t\t\t# address we are really at\n+\t.long\t.LCTOC1\t\t\t\t/* address we are really at */\n \n .Lgot = .-.LCTOC1\n-\t.long\t_GLOBAL_OFFSET_TABLE_\t\t# normal GOT address\n+\t.long\t_GLOBAL_OFFSET_TABLE_\t\t/* normal GOT address */\n \n .Lgots = .-.LCTOC1\n-\t.long\t_GOT_START_\t\t\t# start of .got section\n+\t.long\t_GOT_START_\t\t\t/* start of .got section */\n \n .Lgote = .-.LCTOC1\n-\t.long\t_GOT_END_\t\t\t# end of .got section\n+\t.long\t_GOT_END_\t\t\t/* end of .got section */\n \n .Lgot2s = .-.LCTOC1\n-\t.long\t_GOT2_START_\t\t\t# -mrelocatable GOT pointers start\n+\t.long\t_GOT2_START_\t\t\t/* -mrelocatable GOT pointers start */\n \n .Lgot2e = .-.LCTOC1\n-\t.long\t_GOT2_END_\t\t\t# -mrelocatable GOT pointers end\n+\t.long\t_GOT2_END_\t\t\t/* -mrelocatable GOT pointers end */\n \n .Lfixups = .-.LCTOC1\n-\t.long\t_FIXUP_START_\t\t\t# start of .fixup section\n+\t.long\t_FIXUP_START_\t\t\t/* start of .fixup section */\n \n .Lfixupe = .-.LCTOC1\n-\t.long\t_FIXUP_END_\t\t\t# end of .fixup section\n+\t.long\t_FIXUP_END_\t\t\t/* end of .fixup section */\n \n \t.text\n .Lptr:\n-\t.long\t.LCTOC1-.Laddr\t\t\t# PC relative pointer to .got2\n-\t.long\t0x4000\t\t\t\t# traceback table\n+\t.long\t.LCTOC1-.Laddr\t\t\t/* PC relative pointer to .got2 */\n \n-__eabi:\tmflr\t0\n-\tbl\t.Laddr\t\t\t\t# get current address\n+FUNC_START(__eabi)\n+\tmflr\t0\n+\tbl\t.Laddr\t\t\t\t/* get current address */\n .Laddr:\n-\tmflr\t12\t\t\t\t# real address of .Laddr\n-\tlwz\t11,(.Lptr-.Laddr)(12)\t\t# linker generated address of .LCTOC1\n-\tadd\t11,11,12\t\t\t# correct to real pointer\n-\tlwz\t12,.Ltable(11)\t\t\t# get linker's idea of where .Laddr is\n-\tsubf.\t12,12,11\t\t\t# calculate difference\n-\tmtlr\t0\t\t\t\t# restore link register\n-\tbc\t4,2,.Lreloc\t\t\t# skip if we need to relocate\n-\n-# Only load up register 2 if there is a .got section\n-\n-\tlwz\t3,.Lgots(11)\t\t\t# start of .got section\n-\tlwz\t4,.Lgote(11)\t\t\t# end of .got section\n-\tcmpw\t1,3,4\t\t\t\t# .got section non-empty?\n+\tmflr\t12\t\t\t\t/* real address of .Laddr */\n+\tlwz\t11,(.Lptr-.Laddr)(12)\t\t/* linker generated address of .LCTOC1 */\n+\tadd\t11,11,12\t\t\t/* correct to real pointer */\n+\tlwz\t12,.Ltable(11)\t\t\t/* get linker's idea of where .Laddr is */\n+\tsubf.\t12,12,11\t\t\t/* calculate difference */\n+\tmtlr\t0\t\t\t\t/* restore link register */\n+\tbc\t4,2,.Lreloc\t\t\t/* skip if we need to relocate */\n+\n+/* Only load up register 2 if there is a .got section */\n+\n+\tlwz\t3,.Lgots(11)\t\t\t/* start of .got section */\n+\tlwz\t4,.Lgote(11)\t\t\t/* end of .got section */\n+\tcmpw\t1,3,4\t\t\t\t/* .got section non-empty? */\n \tbc\t12,6,.Ldone\n \n-# Normal program, load up register 2\n+/* Normal program, load up register 2 */\n \n-\tlwz\t2,.Lgot(11)\t\t\t# normal GOT address (obsolete in register 2)\n-\tmr\t13,2\t\t\t\t# also same as _SDA_BASE_ (V.4 small data ptr)\n-\tb\t__do_global_ctors\t\t# do any C++ global constructors (which returns to caller)\n+\tlwz\t2,.Lgot(11)\t\t\t/* normal GOT address (obsolete in register 2) */\n+\tmr\t13,2\t\t\t\t/* also same as _SDA_BASE_ (V.4 small data ptr) */\n+\tb\tFUNC_NAME(__do_global_ctors)\t/* do any C++ global constructors (which returns to caller) */\n \n-# We need to relocate the .got2 pointers.  Don't load register 2\n+/* We need to relocate the .got2 pointers.  Don't load register 2 */\n \n .Lreloc:\n-\tlwz\t3,.Lgot2s(11)\t\t\t# GOT pointers start\n-\tlwz\t4,.Lgot2e(11)\t\t\t# GOT pointers end\n-\tadd\t3,12,3\t\t\t\t# adjust pointers\n+\tlwz\t3,.Lgot2s(11)\t\t\t/* GOT pointers start */\n+\tlwz\t4,.Lgot2e(11)\t\t\t/* GOT pointers end */\n+\tadd\t3,12,3\t\t\t\t/* adjust pointers */\n \tadd\t4,12,4\n \n-\tcmpw\t1,3,4\t\t\t\t# any pointers to adjust\n+\tcmpw\t1,3,4\t\t\t\t/* any pointers to adjust */\n \tbc\t12,6,.Lfix\n \n .Lloop:\n-\tlwz\t5,0(3)\t\t\t\t# next pointer\n-\tadd\t5,5,12\t\t\t\t# adjust\n+\tlwz\t5,0(3)\t\t\t\t/* next pointer */\n+\tadd\t5,5,12\t\t\t\t/* adjust */\n \tstw\t5,0(3)\n-\taddi\t3,3,4\t\t\t\t# bump to next word\n-\tcmpw\t1,3,4\t\t\t\t# more pointers to adjust?\n+\taddi\t3,3,4\t\t\t\t/* bump to next word */\n+\tcmpw\t1,3,4\t\t\t\t/* more pointers to adjust? */\n \tbc\t4,6,.Lloop\n \n-# Fixup any user initialized pointers now (the compiler drops pointers to\n-# each of the relocs that it does in the .fixup section).  Note, the pointers\n-# themselves have already been fixed up by the previous loop.\n+/* Fixup any user initialized pointers now (the compiler drops pointers to */\n+/* each of the relocs that it does in the .fixup section).  Note, the pointers */\n+/* themselves have already been fixed up by the previous loop. */\n \n .Lfix:\n-\tlwz\t3,.Lfixups(11)\t\t\t# fixup pointers start\n-\tlwz\t4,.Lfixupe(11)\t\t\t# fixup pointers end\n+\tlwz\t3,.Lfixups(11)\t\t\t/* fixup pointers start */\n+\tlwz\t4,.Lfixupe(11)\t\t\t/* fixup pointers end */\n \n-\tcmpw\t1,3,4\t\t\t\t# any user pointers to adjust\n+\tcmpw\t1,3,4\t\t\t\t/* any user pointers to adjust */\n \tbc\t12,6,.Ldone\n \n .Lfloop:\n-\tlwz\t5,0(3)\t\t\t\t# next pointer\n-\tlwz\t6,0(5)\t\t\t\t# get the pointer it points to\n-\tadd\t6,6,12\t\t\t\t# adjust\n+\tlwz\t5,0(3)\t\t\t\t/* next pointer */\n+\tlwz\t6,0(5)\t\t\t\t/* get the pointer it points to */\n+\tadd\t6,6,12\t\t\t\t/* adjust */\n \tstw\t6,0(5)\n-\taddi\t3,3,4\t\t\t\t# bump to next word\n-\tcmpw\t1,3,4\t\t\t\t# more pointers to adjust?\n+\taddi\t3,3,4\t\t\t\t/* bump to next word */\n+\tcmpw\t1,3,4\t\t\t\t/* more pointers to adjust? */\n \tbc\t4,6,.Lfloop\n \n-# Done adjusting pointers, return\n+/* Done adjusting pointers, return */\n \n .Ldone:\n-\tb\t__do_global_ctors\t\t# do any C++ global constructors (which returns to caller)\n-\n-# Routines for saving floating point registers, called by the compiler.\n-# Called with r11 pointing to the stack header word of the caller of the\n-# function, just beyond the end of the floating point save area.\n-\n-\t.globl\t_savefpr_14\n-\t.globl\t_savefpr_15\n-\t.globl\t_savefpr_16\n-\t.globl\t_savefpr_17\n-\t.globl\t_savefpr_18\n-\t.globl\t_savefpr_19\n-\t.globl\t_savefpr_20\n-\t.globl\t_savefpr_21\n-\t.globl\t_savefpr_22\n-\t.globl\t_savefpr_23\n-\t.globl\t_savefpr_24\n-\t.globl\t_savefpr_25\n-\t.globl\t_savefpr_26\n-\t.globl\t_savefpr_27\n-\t.globl\t_savefpr_28\n-\t.globl\t_savefpr_29\n-\t.globl\t_savefpr_30\n-\t.globl\t_savefpr_31\n-\n-\t\t.long\t0x00400000\t# traceback tag\n-_savefpr_14:\tstfd\t14,-144(11)\t# save fp registers\n-_savefpr_15:\tstfd\t15,-136(11)\n-_savefpr_16:\tstfd\t16,-128(11)\n-_savefpr_17:\tstfd\t17,-120(11)\n-_savefpr_18:\tstfd\t18,-112(11)\n-_savefpr_19:\tstfd\t19,-104(11)\n-_savefpr_20:\tstfd\t20,-96(11)\n-_savefpr_21:\tstfd\t21,-88(11)\n-_savefpr_22:\tstfd\t22,-80(11)\n-_savefpr_23:\tstfd\t23,-72(11)\n-_savefpr_24:\tstfd\t24,-64(11)\n-_savefpr_25:\tstfd\t25,-56(11)\n-_savefpr_26:\tstfd\t26,-48(11)\n-_savefpr_27:\tstfd\t27,-40(11)\n-_savefpr_28:\tstfd\t28,-32(11)\n-_savefpr_29:\tstfd\t29,-24(11)\n-_savefpr_30:\tstfd\t30,-16(11)\n-_savefpr_31:\tstfd\t31,-8(11)\n-\t\tblr\n-\n-# Routines for saving integer registers, called by the compiler.\n-# Called with r11 pointing to the stack header word of the caller of the\n-# function, just beyond the end of the integer save area.\n-\n-\t.globl\t_savegpr_14\n-\t.globl\t_savegpr_15\n-\t.globl\t_savegpr_16\n-\t.globl\t_savegpr_17\n-\t.globl\t_savegpr_18\n-\t.globl\t_savegpr_19\n-\t.globl\t_savegpr_20\n-\t.globl\t_savegpr_21\n-\t.globl\t_savegpr_22\n-\t.globl\t_savegpr_23\n-\t.globl\t_savegpr_24\n-\t.globl\t_savegpr_25\n-\t.globl\t_savegpr_26\n-\t.globl\t_savegpr_27\n-\t.globl\t_savegpr_28\n-\t.globl\t_savegpr_29\n-\t.globl\t_savegpr_30\n-\t.globl\t_savegpr_31\n-\n-\t\t.long\t0x00400000\t# traceback tag\n-_savegpr_14:\tstw\t14,-72(11)\t# save gp registers\n-_savegpr_15:\tstw\t15,-68(11)\n-_savegpr_16:\tstw\t16,-64(11)\n-_savegpr_17:\tstw\t17,-60(11)\n-_savegpr_18:\tstw\t18,-56(11)\n-_savegpr_19:\tstw\t19,-52(11)\n-_savegpr_20:\tstw\t20,-48(11)\n-_savegpr_21:\tstw\t21,-44(11)\n-_savegpr_22:\tstw\t22,-40(11)\n-_savegpr_23:\tstw\t23,-36(11)\n-_savegpr_24:\tstw\t24,-32(11)\n-_savegpr_25:\tstw\t25,-28(11)\n-_savegpr_26:\tstw\t26,-24(11)\n-_savegpr_27:\tstw\t27,-20(11)\n-_savegpr_28:\tstw\t28,-16(11)\n-_savegpr_29:\tstw\t29,-12(11)\n-_savegpr_30:\tstw\t30,-8(11)\n-_savegpr_31:\tstw\t31,-4(11)\n-\t\tblr\n-\n-# Routines for restoring floating point registers, called by the compiler.\n-# Called with r11 pointing to the stack header word of the caller of the\n-# function, just beyond the end of the floating point save area.\n-\n-\t.globl\t_restfpr_14\n-\t.globl\t_restfpr_15\n-\t.globl\t_restfpr_16\n-\t.globl\t_restfpr_17\n-\t.globl\t_restfpr_18\n-\t.globl\t_restfpr_19\n-\t.globl\t_restfpr_20\n-\t.globl\t_restfpr_21\n-\t.globl\t_restfpr_22\n-\t.globl\t_restfpr_23\n-\t.globl\t_restfpr_24\n-\t.globl\t_restfpr_25\n-\t.globl\t_restfpr_26\n-\t.globl\t_restfpr_27\n-\t.globl\t_restfpr_28\n-\t.globl\t_restfpr_29\n-\t.globl\t_restfpr_30\n-\t.globl\t_restfpr_31\n-\n-\t\t.long\t0x00600000\t# traceback tag\n-_restfpr_14:\tlfd\t14,-144(11)\t# restore fp registers\n-_restfpr_15:\tlfd\t15,-136(11)\n-_restfpr_16:\tlfd\t16,-128(11)\n-_restfpr_17:\tlfd\t17,-120(11)\n-_restfpr_18:\tlfd\t18,-112(11)\n-_restfpr_19:\tlfd\t19,-104(11)\n-_restfpr_20:\tlfd\t20,-96(11)\n-_restfpr_21:\tlfd\t21,-88(11)\n-_restfpr_22:\tlfd\t22,-80(11)\n-_restfpr_23:\tlfd\t23,-72(11)\n-_restfpr_24:\tlfd\t24,-64(11)\n-_restfpr_25:\tlfd\t25,-56(11)\n-_restfpr_26:\tlfd\t26,-48(11)\n-_restfpr_27:\tlfd\t27,-40(11)\n-_restfpr_28:\tlfd\t28,-32(11)\n-_restfpr_29:\tlfd\t29,-24(11)\n-_restfpr_30:\tlfd\t30,-16(11)\n-_restfpr_31:\tlfd\t31,-8(11)\n-\t\tblr\n-\n-# Routines for restoring integer registers, called by the compiler.\n-# Called with r11 pointing to the stack header word of the caller of the\n-# function, just beyond the end of the integer restore area.\n-\n-\t.globl\t_restgpr_14\n-\t.globl\t_restgpr_15\n-\t.globl\t_restgpr_16\n-\t.globl\t_restgpr_17\n-\t.globl\t_restgpr_18\n-\t.globl\t_restgpr_19\n-\t.globl\t_restgpr_20\n-\t.globl\t_restgpr_21\n-\t.globl\t_restgpr_22\n-\t.globl\t_restgpr_23\n-\t.globl\t_restgpr_24\n-\t.globl\t_restgpr_25\n-\t.globl\t_restgpr_26\n-\t.globl\t_restgpr_27\n-\t.globl\t_restgpr_28\n-\t.globl\t_restgpr_29\n-\t.globl\t_restgpr_30\n-\t.globl\t_restgpr_31\n-\n-\t\t.long\t0x00600000\t# traceback tag\n-_restgpr_14:\tlwz\t14,-72(11)\t# rest gp registers\n-_restgpr_15:\tlwz\t15,-68(11)\n-_restgpr_16:\tlwz\t16,-64(11)\n-_restgpr_17:\tlwz\t17,-60(11)\n-_restgpr_18:\tlwz\t18,-56(11)\n-_restgpr_19:\tlwz\t19,-52(11)\n-_restgpr_20:\tlwz\t20,-48(11)\n-_restgpr_21:\tlwz\t21,-44(11)\n-_restgpr_22:\tlwz\t22,-40(11)\n-_restgpr_23:\tlwz\t23,-36(11)\n-_restgpr_24:\tlwz\t24,-32(11)\n-_restgpr_25:\tlwz\t25,-28(11)\n-_restgpr_26:\tlwz\t26,-24(11)\n-_restgpr_27:\tlwz\t27,-20(11)\n-_restgpr_28:\tlwz\t28,-16(11)\n-_restgpr_29:\tlwz\t29,-12(11)\n-_restgpr_30:\tlwz\t30,-8(11)\n-_restgpr_31:\tlwz\t31,-4(11)\n-\t\tblr\n-\n-# Routines for restoring floating point registers, called by the compiler.\n-# Called with r11 pointing to the stack header word of the caller of the\n-# function, just beyond the end of the floating point save area.\n-# In addition to restoring the fp registers, it will return to the caller's\n-# caller\n-\n-\t.globl\t_restfpr_14_x\n-\t.globl\t_restfpr_15_x\n-\t.globl\t_restfpr_16_x\n-\t.globl\t_restfpr_17_x\n-\t.globl\t_restfpr_18_x\n-\t.globl\t_restfpr_19_x\n-\t.globl\t_restfpr_20_x\n-\t.globl\t_restfpr_21_x\n-\t.globl\t_restfpr_22_x\n-\t.globl\t_restfpr_23_x\n-\t.globl\t_restfpr_24_x\n-\t.globl\t_restfpr_25_x\n-\t.globl\t_restfpr_26_x\n-\t.globl\t_restfpr_27_x\n-\t.globl\t_restfpr_28_x\n-\t.globl\t_restfpr_29_x\n-\t.globl\t_restfpr_30_x\n-\t.globl\t_restfpr_31_x\n-\n-\t\t.long\t0x00600000\t# traceback tag\n-_restfpr_14_x:\tlfd\t14,-144(11)\t# restore fp registers\n-_restfpr_15_x:\tlfd\t15,-136(11)\n-_restfpr_16_x:\tlfd\t16,-128(11)\n-_restfpr_17_x:\tlfd\t17,-120(11)\n-_restfpr_18_x:\tlfd\t18,-112(11)\n-_restfpr_19_x:\tlfd\t19,-104(11)\n-_restfpr_20_x:\tlfd\t20,-96(11)\n-_restfpr_21_x:\tlfd\t21,-88(11)\n-_restfpr_22_x:\tlfd\t22,-80(11)\n-_restfpr_23_x:\tlfd\t23,-72(11)\n-_restfpr_24_x:\tlfd\t24,-64(11)\n-_restfpr_25_x:\tlfd\t25,-56(11)\n-_restfpr_26_x:\tlfd\t26,-48(11)\n-_restfpr_27_x:\tlfd\t27,-40(11)\n-_restfpr_28_x:\tlfd\t28,-32(11)\n-_restfpr_29_x:\tlfd\t29,-24(11)\n-_restfpr_30_x:\tlfd\t30,-16(11)\n-_restfpr_31_x:\tlwz\t0,4(11)\n-\t\tlfd\t31,-8(11)\n-\t\tmtlr\t0\n-\t\tmr\t1,11\n-\t\tblr\n-\n-# Routines for restoring integer registers, called by the compiler.\n-# Called with r11 pointing to the stack header word of the caller of the\n-# function, just beyond the end of the integer restore area.\n-\n-\t.globl\t_restgpr_14_x\n-\t.globl\t_restgpr_15_x\n-\t.globl\t_restgpr_16_x\n-\t.globl\t_restgpr_17_x\n-\t.globl\t_restgpr_18_x\n-\t.globl\t_restgpr_19_x\n-\t.globl\t_restgpr_20_x\n-\t.globl\t_restgpr_21_x\n-\t.globl\t_restgpr_22_x\n-\t.globl\t_restgpr_23_x\n-\t.globl\t_restgpr_24_x\n-\t.globl\t_restgpr_25_x\n-\t.globl\t_restgpr_26_x\n-\t.globl\t_restgpr_27_x\n-\t.globl\t_restgpr_28_x\n-\t.globl\t_restgpr_29_x\n-\t.globl\t_restgpr_30_x\n-\t.globl\t_restgpr_31_x\n-\n-\t\t.long\t0x00600000\t# traceback tag\n-_restgpr_14_x:\tlwz\t14,-72(11)\t# rest gp registers\n-_restgpr_15_x:\tlwz\t15,-68(11)\n-_restgpr_16_x:\tlwz\t16,-64(11)\n-_restgpr_17_x:\tlwz\t17,-60(11)\n-_restgpr_18_x:\tlwz\t18,-56(11)\n-_restgpr_19_x:\tlwz\t19,-52(11)\n-_restgpr_20_x:\tlwz\t20,-48(11)\n-_restgpr_21_x:\tlwz\t21,-44(11)\n-_restgpr_22_x:\tlwz\t22,-40(11)\n-_restgpr_23_x:\tlwz\t23,-36(11)\n-_restgpr_24_x:\tlwz\t24,-32(11)\n-_restgpr_25_x:\tlwz\t25,-28(11)\n-_restgpr_26_x:\tlwz\t26,-24(11)\n-_restgpr_27_x:\tlwz\t27,-20(11)\n-_restgpr_28_x:\tlwz\t28,-16(11)\n-_restgpr_29_x:\tlwz\t29,-12(11)\n-_restgpr_30_x:\tlwz\t30,-8(11)\n-_restgpr_31_x:\tlwz\t0,4(11)\n-\t\tlwz\t31,-4(11)\n-\t\tmtlr\t0\n-\t\tmr\t1,11\n-\t\tblr\n+\tb\tFUNC_NAME(__do_global_ctors)\t/* do any C++ global constructors (which returns to caller) */\n+FUNC_END(__eabi)\n+\n+/* Routines for saving floating point registers, called by the compiler. */\n+/* Called with r11 pointing to the stack header word of the caller of the */\n+/* function, just beyond the end of the floating point save area. */\n+\n+FUNC_START(_savefpr_14)\tstfd\t14,-144(11)\t/* save fp registers */\n+FUNC_START(_savefpr_15)\tstfd\t15,-136(11)\n+FUNC_START(_savefpr_16)\tstfd\t16,-128(11)\n+FUNC_START(_savefpr_17)\tstfd\t17,-120(11)\n+FUNC_START(_savefpr_18)\tstfd\t18,-112(11)\n+FUNC_START(_savefpr_19)\tstfd\t19,-104(11)\n+FUNC_START(_savefpr_20)\tstfd\t20,-96(11)\n+FUNC_START(_savefpr_21)\tstfd\t21,-88(11)\n+FUNC_START(_savefpr_22)\tstfd\t22,-80(11)\n+FUNC_START(_savefpr_23)\tstfd\t23,-72(11)\n+FUNC_START(_savefpr_24)\tstfd\t24,-64(11)\n+FUNC_START(_savefpr_25)\tstfd\t25,-56(11)\n+FUNC_START(_savefpr_26)\tstfd\t26,-48(11)\n+FUNC_START(_savefpr_27)\tstfd\t27,-40(11)\n+FUNC_START(_savefpr_28)\tstfd\t28,-32(11)\n+FUNC_START(_savefpr_29)\tstfd\t29,-24(11)\n+FUNC_START(_savefpr_30)\tstfd\t30,-16(11)\n+FUNC_START(_savefpr_31)\tstfd\t31,-8(11)\n+\t\t\tblr\n+FUNC_END(_savefpr_31)\n+FUNC_END(_savefpr_30)\n+FUNC_END(_savefpr_29)\n+FUNC_END(_savefpr_28)\n+FUNC_END(_savefpr_27)\n+FUNC_END(_savefpr_26)\n+FUNC_END(_savefpr_25)\n+FUNC_END(_savefpr_24)\n+FUNC_END(_savefpr_23)\n+FUNC_END(_savefpr_22)\n+FUNC_END(_savefpr_21)\n+FUNC_END(_savefpr_20)\n+FUNC_END(_savefpr_19)\n+FUNC_END(_savefpr_18)\n+FUNC_END(_savefpr_17)\n+FUNC_END(_savefpr_16)\n+FUNC_END(_savefpr_15)\n+FUNC_END(_savefpr_14)\n+\n+/* Routines for saving integer registers, called by the compiler. */\n+/* Called with r11 pointing to the stack header word of the caller of the */\n+/* function, just beyond the end of the integer save area. */\n+\n+FUNC_START(_savegpr_14)\tstw\t14,-72(11)\t/* save gp registers */\n+FUNC_START(_savegpr_15)\tstw\t15,-68(11)\n+FUNC_START(_savegpr_16)\tstw\t16,-64(11)\n+FUNC_START(_savegpr_17)\tstw\t17,-60(11)\n+FUNC_START(_savegpr_18)\tstw\t18,-56(11)\n+FUNC_START(_savegpr_19)\tstw\t19,-52(11)\n+FUNC_START(_savegpr_20)\tstw\t20,-48(11)\n+FUNC_START(_savegpr_21)\tstw\t21,-44(11)\n+FUNC_START(_savegpr_22)\tstw\t22,-40(11)\n+FUNC_START(_savegpr_23)\tstw\t23,-36(11)\n+FUNC_START(_savegpr_24)\tstw\t24,-32(11)\n+FUNC_START(_savegpr_25)\tstw\t25,-28(11)\n+FUNC_START(_savegpr_26)\tstw\t26,-24(11)\n+FUNC_START(_savegpr_27)\tstw\t27,-20(11)\n+FUNC_START(_savegpr_28)\tstw\t28,-16(11)\n+FUNC_START(_savegpr_29)\tstw\t29,-12(11)\n+FUNC_START(_savegpr_30)\tstw\t30,-8(11)\n+FUNC_START(_savegpr_31)\tstw\t31,-4(11)\n+\t\t\tblr\n+FUNC_END(_savegpr_31)\n+FUNC_END(_savegpr_30)\n+FUNC_END(_savegpr_29)\n+FUNC_END(_savegpr_28)\n+FUNC_END(_savegpr_27)\n+FUNC_END(_savegpr_26)\n+FUNC_END(_savegpr_25)\n+FUNC_END(_savegpr_24)\n+FUNC_END(_savegpr_23)\n+FUNC_END(_savegpr_22)\n+FUNC_END(_savegpr_21)\n+FUNC_END(_savegpr_20)\n+FUNC_END(_savegpr_19)\n+FUNC_END(_savegpr_18)\n+FUNC_END(_savegpr_17)\n+FUNC_END(_savegpr_16)\n+FUNC_END(_savegpr_15)\n+FUNC_END(_savegpr_14)\n+\n+/* Routines for restoring floating point registers, called by the compiler. */\n+/* Called with r11 pointing to the stack header word of the caller of the */\n+/* function, just beyond the end of the floating point save area. */\n+\n+FUNC_START(_restfpr_14)\tlfd\t14,-144(11)\t/* restore fp registers */\n+FUNC_START(_restfpr_15)\tlfd\t15,-136(11)\n+FUNC_START(_restfpr_16)\tlfd\t16,-128(11)\n+FUNC_START(_restfpr_17)\tlfd\t17,-120(11)\n+FUNC_START(_restfpr_18)\tlfd\t18,-112(11)\n+FUNC_START(_restfpr_19)\tlfd\t19,-104(11)\n+FUNC_START(_restfpr_20)\tlfd\t20,-96(11)\n+FUNC_START(_restfpr_21)\tlfd\t21,-88(11)\n+FUNC_START(_restfpr_22)\tlfd\t22,-80(11)\n+FUNC_START(_restfpr_23)\tlfd\t23,-72(11)\n+FUNC_START(_restfpr_24)\tlfd\t24,-64(11)\n+FUNC_START(_restfpr_25)\tlfd\t25,-56(11)\n+FUNC_START(_restfpr_26)\tlfd\t26,-48(11)\n+FUNC_START(_restfpr_27)\tlfd\t27,-40(11)\n+FUNC_START(_restfpr_28)\tlfd\t28,-32(11)\n+FUNC_START(_restfpr_29)\tlfd\t29,-24(11)\n+FUNC_START(_restfpr_30)\tlfd\t30,-16(11)\n+FUNC_START(_restfpr_31)\tlfd\t31,-8(11)\n+\t\t\tblr\n+FUNC_END(_restfpr_31)\n+FUNC_END(_restfpr_30)\n+FUNC_END(_restfpr_29)\n+FUNC_END(_restfpr_28)\n+FUNC_END(_restfpr_27)\n+FUNC_END(_restfpr_26)\n+FUNC_END(_restfpr_25)\n+FUNC_END(_restfpr_24)\n+FUNC_END(_restfpr_23)\n+FUNC_END(_restfpr_22)\n+FUNC_END(_restfpr_21)\n+FUNC_END(_restfpr_20)\n+FUNC_END(_restfpr_19)\n+FUNC_END(_restfpr_18)\n+FUNC_END(_restfpr_17)\n+FUNC_END(_restfpr_16)\n+FUNC_END(_restfpr_15)\n+FUNC_END(_restfpr_14)\n+\n+/* Routines for restoring integer registers, called by the compiler. */\n+/* Called with r11 pointing to the stack header word of the caller of the */\n+/* function, just beyond the end of the integer restore area. */\n+\n+FUNC_START(_restgpr_14)\tlwz\t14,-72(11)\t/* restore gp registers */\n+FUNC_START(_restgpr_15)\tlwz\t15,-68(11)\n+FUNC_START(_restgpr_16)\tlwz\t16,-64(11)\n+FUNC_START(_restgpr_17)\tlwz\t17,-60(11)\n+FUNC_START(_restgpr_18)\tlwz\t18,-56(11)\n+FUNC_START(_restgpr_19)\tlwz\t19,-52(11)\n+FUNC_START(_restgpr_20)\tlwz\t20,-48(11)\n+FUNC_START(_restgpr_21)\tlwz\t21,-44(11)\n+FUNC_START(_restgpr_22)\tlwz\t22,-40(11)\n+FUNC_START(_restgpr_23)\tlwz\t23,-36(11)\n+FUNC_START(_restgpr_24)\tlwz\t24,-32(11)\n+FUNC_START(_restgpr_25)\tlwz\t25,-28(11)\n+FUNC_START(_restgpr_26)\tlwz\t26,-24(11)\n+FUNC_START(_restgpr_27)\tlwz\t27,-20(11)\n+FUNC_START(_restgpr_28)\tlwz\t28,-16(11)\n+FUNC_START(_restgpr_29)\tlwz\t29,-12(11)\n+FUNC_START(_restgpr_30)\tlwz\t30,-8(11)\n+FUNC_START(_restgpr_31)\tlwz\t31,-4(11)\n+\t\t\tblr\n+FUNC_END(_restgpr_31)\n+FUNC_END(_restgpr_30)\n+FUNC_END(_restgpr_29)\n+FUNC_END(_restgpr_28)\n+FUNC_END(_restgpr_27)\n+FUNC_END(_restgpr_26)\n+FUNC_END(_restgpr_25)\n+FUNC_END(_restgpr_24)\n+FUNC_END(_restgpr_23)\n+FUNC_END(_restgpr_22)\n+FUNC_END(_restgpr_21)\n+FUNC_END(_restgpr_20)\n+FUNC_END(_restgpr_19)\n+FUNC_END(_restgpr_18)\n+FUNC_END(_restgpr_17)\n+FUNC_END(_restgpr_16)\n+FUNC_END(_restgpr_15)\n+FUNC_END(_restgpr_14)\n+\n+/* Routines for restoring floating point registers, called by the compiler. */\n+/* Called with r11 pointing to the stack header word of the caller of the */\n+/* function, just beyond the end of the floating point save area. */\n+/* In addition to restoring the fp registers, it will return to the caller's */\n+/* caller */\n+\n+FUNC_START(_restfpr_14_x)\tlfd\t14,-144(11)\t/* restore fp registers */\n+FUNC_START(_restfpr_15_x)\tlfd\t15,-136(11)\n+FUNC_START(_restfpr_16_x)\tlfd\t16,-128(11)\n+FUNC_START(_restfpr_17_x)\tlfd\t17,-120(11)\n+FUNC_START(_restfpr_18_x)\tlfd\t18,-112(11)\n+FUNC_START(_restfpr_19_x)\tlfd\t19,-104(11)\n+FUNC_START(_restfpr_20_x)\tlfd\t20,-96(11)\n+FUNC_START(_restfpr_21_x)\tlfd\t21,-88(11)\n+FUNC_START(_restfpr_22_x)\tlfd\t22,-80(11)\n+FUNC_START(_restfpr_23_x)\tlfd\t23,-72(11)\n+FUNC_START(_restfpr_24_x)\tlfd\t24,-64(11)\n+FUNC_START(_restfpr_25_x)\tlfd\t25,-56(11)\n+FUNC_START(_restfpr_26_x)\tlfd\t26,-48(11)\n+FUNC_START(_restfpr_27_x)\tlfd\t27,-40(11)\n+FUNC_START(_restfpr_28_x)\tlfd\t28,-32(11)\n+FUNC_START(_restfpr_29_x)\tlfd\t29,-24(11)\n+FUNC_START(_restfpr_30_x)\tlfd\t30,-16(11)\n+FUNC_START(_restfpr_31_x)\tlwz\t0,4(11)\n+\t\t\t\tlfd\t31,-8(11)\n+\t\t\t\tmtlr\t0\n+\t\t\t\tmr\t1,11\n+\t\t\t\tblr\n+FUNC_END(_restfpr_31_x)\n+FUNC_END(_restfpr_30_x)\n+FUNC_END(_restfpr_29_x)\n+FUNC_END(_restfpr_28_x)\n+FUNC_END(_restfpr_27_x)\n+FUNC_END(_restfpr_26_x)\n+FUNC_END(_restfpr_25_x)\n+FUNC_END(_restfpr_24_x)\n+FUNC_END(_restfpr_23_x)\n+FUNC_END(_restfpr_22_x)\n+FUNC_END(_restfpr_21_x)\n+FUNC_END(_restfpr_20_x)\n+FUNC_END(_restfpr_19_x)\n+FUNC_END(_restfpr_18_x)\n+FUNC_END(_restfpr_17_x)\n+FUNC_END(_restfpr_16_x)\n+FUNC_END(_restfpr_15_x)\n+FUNC_END(_restfpr_14_x)\n+\n+/* Routines for restoring integer registers, called by the compiler. */\n+/* Called with r11 pointing to the stack header word of the caller of the */\n+/* function, just beyond the end of the integer restore area. */\n+\n+FUNC_START(_restgpr_14_x)\tlwz\t14,-72(11)\t/* restore gp registers */\n+FUNC_START(_restgpr_15_x)\tlwz\t15,-68(11)\n+FUNC_START(_restgpr_16_x)\tlwz\t16,-64(11)\n+FUNC_START(_restgpr_17_x)\tlwz\t17,-60(11)\n+FUNC_START(_restgpr_18_x)\tlwz\t18,-56(11)\n+FUNC_START(_restgpr_19_x)\tlwz\t19,-52(11)\n+FUNC_START(_restgpr_20_x)\tlwz\t20,-48(11)\n+FUNC_START(_restgpr_21_x)\tlwz\t21,-44(11)\n+FUNC_START(_restgpr_22_x)\tlwz\t22,-40(11)\n+FUNC_START(_restgpr_23_x)\tlwz\t23,-36(11)\n+FUNC_START(_restgpr_24_x)\tlwz\t24,-32(11)\n+FUNC_START(_restgpr_25_x)\tlwz\t25,-28(11)\n+FUNC_START(_restgpr_26_x)\tlwz\t26,-24(11)\n+FUNC_START(_restgpr_27_x)\tlwz\t27,-20(11)\n+FUNC_START(_restgpr_28_x)\tlwz\t28,-16(11)\n+FUNC_START(_restgpr_29_x)\tlwz\t29,-12(11)\n+FUNC_START(_restgpr_30_x)\tlwz\t30,-8(11)\n+FUNC_START(_restgpr_31_x)\tlwz\t0,4(11)\n+\t\t\t\tlwz\t31,-4(11)\n+\t\t\t\tmtlr\t0\n+\t\t\t\tmr\t1,11\n+\t\t\t\tblr\n+FUNC_END(_restgpr_31_x)\n+FUNC_END(_restgpr_30_x)\n+FUNC_END(_restgpr_29_x)\n+FUNC_END(_restgpr_28_x)\n+FUNC_END(_restgpr_27_x)\n+FUNC_END(_restgpr_26_x)\n+FUNC_END(_restgpr_25_x)\n+FUNC_END(_restgpr_24_x)\n+FUNC_END(_restgpr_23_x)\n+FUNC_END(_restgpr_22_x)\n+FUNC_END(_restgpr_21_x)\n+FUNC_END(_restgpr_20_x)\n+FUNC_END(_restgpr_19_x)\n+FUNC_END(_restgpr_18_x)\n+FUNC_END(_restgpr_17_x)\n+FUNC_END(_restgpr_16_x)\n+FUNC_END(_restgpr_15_x)\n+FUNC_END(_restgpr_14_x)"}, {"sha": "6044be7622e1941e8660702be27a1a70e1d055f6", "filename": "gcc/config/rs6000/eabi.h", "status": "modified", "additions": 7, "deletions": 46, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabi.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -60,7 +60,6 @@ Boston, MA 02111-1307, USA.  */\n \n /* Invoke an initializer function to set up the GOT */\n #define NAME__MAIN \"__eabi\"\n-#define INVOKE__main 1\n \n #undef TARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (PowerPC Embedded)\");\n@@ -69,57 +68,19 @@ Boston, MA 02111-1307, USA.  */\n #define CPP_PREDEFINES \\\n   \"-DPPC -D__embedded__ -Asystem(embedded) -Acpu(powerpc) -Amachine(powerpc)\"\n \n-/* Don't use startfiles or libraries except for libgcc.a */\n+/* Use the simulator crt0 or mvme and libgloss/newlib libraries if desired */\n #undef  STARTFILE_SPEC\n-#define\tSTARTFILE_SPEC \"\"\n+#define\tSTARTFILE_SPEC \"\\\n+%{mmvme: mvme-crt0.o%s} \\\n+%{msim:  sim-crt0.o%s}\"\n \n #undef\tLIB_SPEC\n-#define\tLIB_SPEC \"\"\n+#define\tLIB_SPEC \"\\\n+%{mmvme: -lmvme -lc -lmvme} \\\n+%{msim: -lsim -lc -lsim}\"\n \n #undef\tLIBGCC_SPEC\n #define\tLIBGCC_SPEC \"libgcc.a%s\"\n \n #undef\tENDFILE_SPEC\n #define\tENDFILE_SPEC \"\"\n-\n-/* This is how to output an assembler line defining an `int' constant.\n-   For -mrelocatable, we mark all addresses that need to be fixed up\n-   in the .fixup section.  */\n-#undef\tASM_OUTPUT_INT\n-#define ASM_OUTPUT_INT(FILE,VALUE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  static int recurse = 0;\t\t\t\t\t\t\\\n-  if (TARGET_RELOCATABLE\t\t\t\t\t\t\\\n-      && in_section != in_toc\t\t\t\t\t\t\\\n-      && in_section != in_text\t\t\t\t\t\t\\\n-      && in_section != in_ctors\t\t\t\t\t\t\\\n-      && in_section != in_dtors\t\t\t\t\t\t\\\n-      && !recurse\t\t\t\t\t\t\t\\\n-      && GET_CODE (VALUE) != CONST_INT\t\t\t\t\t\\\n-      && GET_CODE (VALUE) != CONST_DOUBLE\t\t\t\t\\\n-      && CONSTANT_P (VALUE))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      static int labelno = 0;\t\t\t\t\t\t\\\n-      char buf[256], *p;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      recurse = 1;\t\t\t\t\t\t\t\\\n-      ASM_GENERATE_INTERNAL_LABEL (buf, \"LCP\", labelno++);\t\t\\\n-      STRIP_NAME_ENCODING (p, buf);\t\t\t\t\t\\\n-      fprintf (FILE, \"%s:\\n\", p);\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.long (\");\t\t\t\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\t\t\t\\\n-      fprintf (FILE, \")@fixup\\n\");\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.section\\t\\\".fixup\\\",\\\"aw\\\"\\n\");\t\t\\\n-      ASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.long\\t%s\\n\", p);\t\t\t\t\\\n-      fprintf (FILE, \"\\t.previous\\n\");\t\t\t\t\t\\\n-      recurse = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.long \");\t\t\t\t\t\\\n-      output_addr_const (FILE, (VALUE));\t\t\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-"}, {"sha": "c07f6d63bca7abfe6ed12679b8dacbc87c33784a", "filename": "gcc/config/rs6000/eabiaix.h", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabiaix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabiaix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabiaix.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -28,7 +28,9 @@ Boston, MA 02111-1307, USA.  */\n #define CPP_SPEC \"\\\n %{posix: -D_POSIX_SOURCE} \\\n %{mrelocatable: -D_RELOCATABLE} \\\n-%{mcall-sysv: -D_CALL_SYSV} %{mcall-aix: -D_CALL_AIX} %{!mcall-sysv: %{!mcall-aix: -D_CALL_AIX}} \\\n+%{mcall-sysv: -D_CALL_SYSV} %{mcall-nt: -D_CALL_NT} \\\n+%{mcall-aix: -D_CALL_AIX} %{mcall-aixdesc: -D_CALL_AIX -D_CALL_AIXDESC} \\\n+%{!mcall-sysv: %{!mcall-aix: %{!mcall-aixdesc: %{!mcall-nt: -D_CALL_AIX}}}} \\\n %{msoft-float: -D_SOFT_FLOAT} %{mcpu=403: -D_SOFT_FLOAT} \\\n %{mlittle: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n %{mlittle-endian: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n@@ -49,5 +51,20 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=rsc1: -D_ARCH_PWR} \\\n %{mcpu=403: -D_ARCH_PPC} \\\n %{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=602: -D_ARCH_PPC} \\\n %{mcpu=603: -D_ARCH_PPC} \\\n-%{mcpu=604: -D_ARCH_PPC}\"\n+%{mcpu=603e: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC} \\\n+%{mcpu=620: -D_ARCH_PPC}\"\n+\n+/* Define this macro as a C expression for the initializer of an\n+   array of string to tell the driver program which options are\n+   defaults for this target and thus do not need to be handled\n+   specially when using `MULTILIB_OPTIONS'.\n+\n+   Do not define this macro if `MULTILIB_OPTIONS' is not defined in\n+   the target makefile fragment or if none of the options listed in\n+   `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.  */\n+\n+#undef\tMULTILIB_DEFAULTS\n+#define\tMULTILIB_DEFAULTS { \"mbig\", \"mbig-endian\", \"mcall-aix\" }"}, {"sha": "430660b1d6d12571ffe26c4801291e31463fa7b1", "filename": "gcc/config/rs6000/eabile.h", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabile.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -29,7 +29,9 @@ Boston, MA 02111-1307, USA.  */\n #define CPP_SPEC \"\\\n %{posix: -D_POSIX_SOURCE} \\\n %{mrelocatable: -D_RELOCATABLE} \\\n-%{mcall-sysv: -D_CALL_SYSV} %{mcall-aix: -D_CALL_AIX} %{!mcall-sysv: %{!mcall-aix: -D_CALL_SYSV}} \\\n+%{mcall-sysv: -D_CALL_SYSV} %{mcall-nt: -D_CALL_NT} \\\n+%{mcall-aix: -D_CALL_AIX} %{mcall-aixdesc: -D_CALL_AIX -D_CALL_AIXDESC} \\\n+%{!mcall-sysv: %{!mcall-aix: %{!mcall-aixdesc: %{!mcall-nt: -D_CALL_SYSV}}}} \\\n %{msoft-float: -D_SOFT_FLOAT} %{mcpu=403: -D_SOFT_FLOAT} \\\n %{mbig: -D_BIG_ENDIAN -Amachine(bigendian)} \\\n %{mbig-endian: -D_BIG_ENDIAN -Amachine(bigendian)} \\\n@@ -50,5 +52,20 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=rsc1: -D_ARCH_PWR} \\\n %{mcpu=403: -D_ARCH_PPC} \\\n %{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=602: -D_ARCH_PPC} \\\n %{mcpu=603: -D_ARCH_PPC} \\\n-%{mcpu=604: -D_ARCH_PPC}\"\n+%{mcpu=603e: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC} \\\n+%{mcpu=620: -D_ARCH_PPC}\"\n+\n+/* Define this macro as a C expression for the initializer of an\n+   array of string to tell the driver program which options are\n+   defaults for this target and thus do not need to be handled\n+   specially when using `MULTILIB_OPTIONS'.\n+\n+   Do not define this macro if `MULTILIB_OPTIONS' is not defined in\n+   the target makefile fragment or if none of the options listed in\n+   `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.  */\n+\n+#undef\tMULTILIB_DEFAULTS\n+#define\tMULTILIB_DEFAULTS { \"mlittle\", \"mlittle-endian\", \"mcall-sysv\" }"}, {"sha": "4df32f777424c8277beef342d84c245b3e99d112", "filename": "gcc/config/rs6000/eabilesim.h", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabilesim.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabilesim.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabilesim.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -22,52 +22,23 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"rs6000/eabile.h\"\n \n-/* Right now, the simulator doesn't handle floating point, so disable it\n-   by default.  */\n-#undef TARGET_DEFAULT\n-#define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_LITTLE_ENDIAN | MASK_SOFT_FLOAT)\n-\n #undef TARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (PowerPC Simulated)\");\n \n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \\\n   \"-DPPC -D__embedded__ -D__simulator__ -Asystem(embedded) -Asystem(simulator) -Acpu(powerpc) -Amachine(powerpc)\"\n \n-#undef CPP_SPEC\n-#define CPP_SPEC \"\\\n-%{posix: -D_POSIX_SOURCE} \\\n-%{mrelocatable: -D_RELOCATABLE} \\\n-%{mcall-sysv: -D_CALL_SYSV} %{mcall-aix: -D_CALL_AIX} %{!mcall-sysv: %{!mcall-aix: -D_CALL_SYSV}} \\\n-%{!mhard-float: -D_SOFT_FLOAT} \\\n-%{mlittle: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n-%{mlittle-endian: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n-%{!mlittle: %{!mlittle-endian: -D_LITTLE_ENDIAN -Amachine(littleendian)}} \\\n-%{!mcpu*: \\\n-  %{mpower: %{!mpower2: -D_ARCH_PWR}} \\\n-  %{mpower2: -D_ARCH_PWR2} \\\n-  %{mpowerpc*: -D_ARCH_PPC} \\\n-  %{mno-powerpc: %{!mpower: %{!mpower2: -D_ARCH_COM}}} \\\n-  %{!mno-powerpc: -D_ARCH_PPC}} \\\n-%{mcpu=common: -D_ARCH_COM} \\\n-%{mcpu=power: -D_ARCH_PWR} \\\n-%{mcpu=powerpc: -D_ARCH_PPC} \\\n-%{mcpu=rios: -D_ARCH_PWR} \\\n-%{mcpu=rios1: -D_ARCH_PWR} \\\n-%{mcpu=rios2: -D_ARCH_PWR2} \\\n-%{mcpu=rsc: -D_ARCH_PWR} \\\n-%{mcpu=rsc1: -D_ARCH_PWR} \\\n-%{mcpu=403: -D_ARCH_PPC} \\\n-%{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n-%{mcpu=603: -D_ARCH_PPC} \\\n-%{mcpu=604: -D_ARCH_PPC}\"\n-\n-/* Use the simulator crt0 and libgloss/newlib libraries */\n+/* Use the simulator crt0 or mvme and libgloss/newlib libraries if desired */\n #undef  STARTFILE_SPEC\n-#define\tSTARTFILE_SPEC \"sim-crt0.o%s\"\n+#define\tSTARTFILE_SPEC \"\\\n+%{mmvme: mvme-crt0.o%s} \\\n+%{!mmvme: sim-crt0.o%s}\"\n \n #undef\tLIB_SPEC\n-#define\tLIB_SPEC \"-lsim -lc -lsim\"\n+#define\tLIB_SPEC \"\\\n+%{mmvme: -lmvme -lc -lmvme} \\\n+%{!mmvme: -lsim -lc -lsim}\"\n \n #undef\tLIBGCC_SPEC\n #define\tLIBGCC_SPEC \"libgcc.a%s\""}, {"sha": "826801c8b96914b719dc4dea83bdc654903b0cd0", "filename": "gcc/config/rs6000/eabisim.h", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabisim.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Feabisim.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabisim.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -22,52 +22,23 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"rs6000/eabi.h\"\n \n-/* Right now, the simulator doesn't handle floating point, so disable it\n-   by default.  */\n-#undef TARGET_DEFAULT\n-#define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_SOFT_FLOAT)\n-\n #undef TARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (PowerPC Simulated)\");\n \n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \\\n   \"-DPPC -D__embedded__ -D__simulator__ -Asystem(embedded) -Asystem(simulator) -Acpu(powerpc) -Amachine(powerpc)\"\n \n-#undef CPP_SPEC\n-#define CPP_SPEC \"\\\n-%{posix: -D_POSIX_SOURCE} \\\n-%{mrelocatable: -D_RELOCATABLE} \\\n-%{mcall-sysv: -D_CALL_SYSV} %{mcall-aix: -D_CALL_AIX} %{!mcall-sysv: %{!mcall-aix: -D_CALL_SYSV}} \\\n-%{!mhard-float: -D_SOFT_FLOAT} \\\n-%{mlittle: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n-%{mlittle-endian: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n-%{!mlittle: %{!mlittle-endian: -D_BIG_ENDIAN -Amachine(bigendian)}} \\\n-%{!mcpu*: \\\n-  %{mpower: %{!mpower2: -D_ARCH_PWR}} \\\n-  %{mpower2: -D_ARCH_PWR2} \\\n-  %{mpowerpc*: -D_ARCH_PPC} \\\n-  %{mno-powerpc: %{!mpower: %{!mpower2: -D_ARCH_COM}}} \\\n-  %{!mno-powerpc: -D_ARCH_PPC}} \\\n-%{mcpu=common: -D_ARCH_COM} \\\n-%{mcpu=power: -D_ARCH_PWR} \\\n-%{mcpu=powerpc: -D_ARCH_PPC} \\\n-%{mcpu=rios: -D_ARCH_PWR} \\\n-%{mcpu=rios1: -D_ARCH_PWR} \\\n-%{mcpu=rios2: -D_ARCH_PWR2} \\\n-%{mcpu=rsc: -D_ARCH_PWR} \\\n-%{mcpu=rsc1: -D_ARCH_PWR} \\\n-%{mcpu=403: -D_ARCH_PPC} \\\n-%{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n-%{mcpu=603: -D_ARCH_PPC} \\\n-%{mcpu=604: -D_ARCH_PPC}\"\n-\n-/* Use the simulator crt0 and libgloss/newlib libraries */\n+/* Use the simulator crt0 or mvme and libgloss/newlib libraries if desired */\n #undef  STARTFILE_SPEC\n-#define\tSTARTFILE_SPEC \"sim-crt0.o%s\"\n+#define\tSTARTFILE_SPEC \"\\\n+%{mmvme: mvme-crt0.o%s} \\\n+%{!mmvme: sim-crt0.o%s}\"\n \n #undef\tLIB_SPEC\n-#define\tLIB_SPEC \"-lsim -lc -lsim\"\n+#define\tLIB_SPEC \"\\\n+%{mmvme: -lmvme -lc -lmvme} \\\n+%{!mmvme: -lsim -lc -lsim}\"\n \n #undef\tLIBGCC_SPEC\n #define\tLIBGCC_SPEC \"libgcc.a%s\""}, {"sha": "bb4e8b4df8437cf547e17de2ab477dd22de35c64", "filename": "gcc/config/rs6000/mach.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Fmach.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Fmach.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fmach.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -20,6 +20,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#define TARGET_AIX 0\n \n #include \"rs6000/rs6000.h\"\n "}, {"sha": "7d5bbaa2b377b32fddcb79e793d39cc02da46d79", "filename": "gcc/config/rs6000/netware.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Fnetware.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Fnetware.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fnetware.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -19,6 +19,8 @@ You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n+#define TARGET_AIX 0\n+\n #include \"rs6000/powerpc.h\"\n \n /* Don't generate XCOFF debugging information.  */\n@@ -32,8 +34,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* The XCOFF support uses weird symbol suffixes, which we don't want\n    for ELF.  */\n \n-#undef RS6000_OUTPUT_BASENAME\n-#define RS6000_OUTPUT_BASENAME(FILE, NAME) assemble_name (FILE, NAME)\n+#undef STRIP_NAME_ENCODING\n \n /* Don't bother to output .extern pseudo-ops.  They are not needed by\n    ELF assemblers.  */"}, {"sha": "96e15d7c0fc7f66751d982f728001b5de1ca6c23", "filename": "gcc/config/rs6000/powerpc.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Fpowerpc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Fpowerpc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpowerpc.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -43,6 +43,7 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=403: -mppc} \\\n %{mcpu=601: -m601} \\\n %{mcpu=603: -mppc} \\\n+%{mcpu=603e: -mppc} \\\n %{mcpu=604: -mppc}\"\n \n #undef CPP_PREDEFINES\n@@ -68,8 +69,11 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=rsc1: -D_ARCH_PWR} \\\n %{mcpu=403: -D_ARCH_PPC} \\\n %{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=602: -D_ARCH_PPC} \\\n %{mcpu=603: -D_ARCH_PPC} \\\n-%{mcpu=604: -D_ARCH_PPC}\"\n+%{mcpu=603e: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC} \\\n+%{mcpu=620: -D_ARCH_PPC}\"\n \n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS)"}, {"sha": "a28bd5c2fd596abd5842671e2abdacffb093c676", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 749, "deletions": 185, "changes": 934, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -74,6 +74,12 @@ int rs6000_pic_labelno;\n /* Whether a System V.4 varargs area was created.  */\n int rs6000_sysv_varargs_p;\n \n+/* Whether we need to save the TOC register.  */\n+int rs6000_save_toc_p;\n+\n+/* ABI enumeration available for subtarget to use.  */\n+enum rs6000_abi rs6000_current_abi;\n+\n /* Temporary memory used to convert integer -> float */\n static rtx stack_temps[NUM_MACHINE_MODES];\n \n@@ -223,10 +229,19 @@ rs6000_override_options ()\n \t {\"601\", PROCESSOR_PPC601,\n \t    MASK_POWER | MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_MULTIPLE | MASK_STRING,\n \t    MASK_POWER2 | POWERPC_OPT_MASKS | MASK_POWERPC64},\n+\t {\"602\", PROCESSOR_PPC602,\n+\t    MASK_POWER | MASK_POWERPC | MASK_NEW_MNEMONICS,\n+\t    MASK_POWER2 | POWERPC_OPT_MASKS | MASK_POWERPC64},\n \t {\"603\", PROCESSOR_PPC603,\n \t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n \t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t {\"603e\", PROCESSOR_PPC603,\n+\t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n+\t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n \t {\"604\", PROCESSOR_PPC604,\n+\t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n+\t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t {\"620\", PROCESSOR_PPC620,\n \t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n \t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64}};\n \n@@ -350,6 +365,23 @@ any_operand (op, mode)\n   return 1;\n }\n \n+/* Returns 1 if op is the count register */\n+int count_register_operand(op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != REG)\n+    return 0;\n+\n+  if (REGNO (op) == COUNT_REGISTER_REGNUM)\n+    return 1;\n+\n+  if (REGNO (op) > FIRST_PSEUDO_REGISTER)\n+    return 1;\n+\n+  return 0;\n+}\n+\n /* Return 1 if OP is a constant that can fit in a D field.  */\n \n int\n@@ -476,6 +508,10 @@ easy_fp_constant (op, mode)\n       || GET_MODE_CLASS (mode) != MODE_FLOAT)\n     return 0;\n \n+  /* Consider all constants with -msoft-float to be easy */\n+  if (TARGET_SOFT_FLOAT)\n+    return 1;\n+\n   high = operand_subword (op, 0, 0, mode);\n   low = operand_subword (op, 1, 0, mode);\n \n@@ -486,6 +522,34 @@ easy_fp_constant (op, mode)\n \t  || (low != 0 && input_operand (low, word_mode)));\n }\n \n+/* Return 1 if the operand is in volatile memory.  Note that during the\n+   RTL generation phase, memory_operand does not return TRUE for\n+   volatile memory references.  So this function allows us to\n+   recognize volatile references where its safe.  */\n+\n+int\n+volatile_mem_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  if (!MEM_VOLATILE_P (op))\n+    return 0;\n+\n+  if (mode != GET_MODE (op))\n+    return 0;\n+\n+  if (reload_completed)\n+    return memory_operand (op, mode);\n+\n+  if (reload_in_progress)\n+    return strict_memory_address_p (mode, XEXP (op, 0));\n+\n+  return memory_address_p (mode, XEXP (op, 0));\n+}\n+\n /* Return 1 if the operand is an offsettable memory address.  */\n \n int\n@@ -506,6 +570,7 @@ fp_reg_or_mem_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (memory_operand (op, mode)\n+\t  || volatile_mem_operand (op, mode)\n \t  || (register_operand (op, mode)\n \t      && (GET_CODE (op) != REG\n \t\t  || REGNO (op) >= FIRST_PSEUDO_REGISTER\n@@ -640,7 +705,9 @@ reg_or_mem_operand (op, mode)\n      register rtx op;\n      register enum machine_mode mode;\n {\n-  return gpc_reg_operand (op, mode) || memory_operand (op, mode);\n+  return (gpc_reg_operand (op, mode)\n+\t  || memory_operand (op, mode)\n+\t  || volatile_mem_operand (op, mode));\n }\n \n /* Return 1 if the operand is a general register or memory operand without\n@@ -732,6 +799,12 @@ input_operand (op, mode)\n   if (LEGITIMATE_CONSTANT_POOL_ADDRESS_P (op))\n     return 1;\n \n+  /* Windows NT allows SYMBOL_REFs and LABEL_REFs against the TOC\n+     directly in the instruction stream */\n+  if (DEFAULT_ABI == ABI_NT\n+      && (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF))\n+    return 1;\n+\n   /* Otherwise, we will be doing this SET with an add, so anything valid\n      for an add will be valid.  */\n   return add_operand (op, mode);\n@@ -796,6 +869,26 @@ init_cumulative_args (cum, fntype, libname, incoming)\n     }\n }\n \f\n+/* If defined, a C expression that gives the alignment boundary, in bits,\n+   of an argument with the specified mode and type.  If it is not defined, \n+   PARM_BOUNDARY is used for all arguments.\n+   \n+   Windows NT wants anything >= 8 bytes to be double word aligned.  */\n+\n+int\n+function_arg_boundary (mode, type)\n+     enum machine_mode mode;\n+     tree type;\n+{\n+  if (DEFAULT_ABI != ABI_NT || TARGET_64BIT)\n+    return PARM_BOUNDARY;\n+\n+  if (mode != BLKmode)\n+    return (GET_MODE_SIZE (mode)) >= 8 ? 64 : 32;\n+\n+  return (int_size_in_bytes (type) >= 8) ? 64 : 32;\n+}\n+\f\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n@@ -807,6 +900,8 @@ function_arg_advance (cum, mode, type, named)\n      tree type;\n      int named;\n {\n+  int align = ((cum->words & 1) != 0 && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n+  cum->words += align;\n   cum->nargs_prototype--;\n \n #ifdef TARGET_V4_CALLS\n@@ -846,8 +941,8 @@ function_arg_advance (cum, mode, type, named)\n \n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr,\n-\t     \"function_adv: words = %2d, fregno = %2d, nargs = %4d, proto = %d, mode = %4s, named = %d\\n\",\n-\t     cum->words, cum->fregno, cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode), named);\n+\t     \"function_adv: words = %2d, fregno = %2d, nargs = %4d, proto = %d, mode = %4s, named = %d, align = %d\\n\",\n+\t     cum->words, cum->fregno, cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode), named, align);\n }\n \f\n /* Determine where to put an argument to a function.\n@@ -880,10 +975,13 @@ function_arg (cum, mode, type, named)\n      tree type;\n      int named;\n {\n+  int align = ((cum->words & 1) != 0 && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n+  int align_words = cum->words + align;\n+\n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr,\n-\t     \"function_arg: words = %2d, fregno = %2d, nargs = %4d, proto = %d, mode = %4s, named = %d\\n\",\n-\t     cum->words, cum->fregno, cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode), named);\n+\t     \"function_arg: words = %2d, fregno = %2d, nargs = %4d, proto = %d, mode = %4s, named = %d, align = %d\\n\",\n+\t     cum->words, cum->fregno, cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode), named, align);\n \n   /* Return a marker to indicate whether CR1 needs to set or clear the bit that V.4\n      uses to say fp args were passed in registers.  Assume that we don't need the\n@@ -920,23 +1018,23 @@ function_arg (cum, mode, type, named)\n \treturn gen_rtx (REG, mode, cum->fregno);\n \n       return gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t      ((cum->words < GP_ARG_NUM_REG)\n-\t\t       ? gen_rtx (REG, mode, GP_ARG_MIN_REG + cum->words)\n+\t\t      ((align_words < GP_ARG_NUM_REG)\n+\t\t       ? gen_rtx (REG, mode, GP_ARG_MIN_REG + align_words)\n \t\t       : NULL_RTX),\n \t\t      gen_rtx (REG, mode, cum->fregno));\n     }\n \n #ifdef TARGET_V4_CALLS\n   /* Long longs won't be split between register and stack */\n   else if (TARGET_V4_CALLS &&\n-\t   cum->words + RS6000_ARG_SIZE (mode, type, named) > GP_ARG_NUM_REG)\n+\t   align_words + RS6000_ARG_SIZE (mode, type, named) > GP_ARG_NUM_REG)\n     {\n       return NULL_RTX;\n     }\n #endif\n \n-  else if (cum->words < GP_ARG_NUM_REG)\n-    return gen_rtx (REG, mode, GP_ARG_MIN_REG + cum->words);\n+  else if (align_words < GP_ARG_NUM_REG)\n+    return gen_rtx (REG, mode, GP_ARG_MIN_REG + align_words);\n \n   return NULL_RTX;\n }\n@@ -1164,8 +1262,13 @@ expand_block_move_mem (mode, addr, orig_mem)\n      rtx orig_mem;\n {\n   rtx mem = gen_rtx (MEM, mode, addr);\n+\n+  RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (orig_mem);\n   MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (orig_mem);\n   MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (orig_mem);\n+#ifdef MEM_UNALIGNED_P\n+  MEM_UNALIGNED_P (mem) = MEM_UNALIGNED_P (orig_mem);\n+#endif\n   return mem;\n }\n \n@@ -1183,6 +1286,8 @@ int\n expand_block_move (operands)\n      rtx operands[];\n {\n+  rtx orig_dest = operands[0];\n+  rtx orig_src\t= operands[1];\n   rtx bytes_rtx\t= operands[2];\n   rtx align_rtx = operands[3];\n   int constp\t= (GET_CODE (bytes_rtx) == CONST_INT);\n@@ -1224,8 +1329,8 @@ expand_block_move (operands)\n     return 0;\n \n   /* Move the address into scratch registers.  */\n-  dest_reg = copy_addr_to_reg (XEXP (operands[0], 0));\n-  src_reg  = copy_addr_to_reg (XEXP (operands[1], 0));\n+  dest_reg = copy_addr_to_reg (XEXP (orig_dest, 0));\n+  src_reg  = copy_addr_to_reg (XEXP (orig_src,  0));\n \n   if (TARGET_STRING)\t/* string instructions are available */\n     {\n@@ -1242,8 +1347,8 @@ expand_block_move (operands)\n \t      && !fixed_regs[12])\n \t    {\n \t      move_bytes = (bytes > 32) ? 32 : bytes;\n-\t      emit_insn (gen_movstrsi_8reg (dest_reg,\n-\t\t\t\t\t    src_reg,\n+\t      emit_insn (gen_movstrsi_8reg (expand_block_move_mem (BLKmode, dest_reg, orig_dest),\n+\t\t\t\t\t    expand_block_move_mem (BLKmode, src_reg, orig_src),\n \t\t\t\t\t    GEN_INT ((move_bytes == 32) ? 0 : move_bytes),\n \t\t\t\t\t    align_rtx));\n \t    }\n@@ -1256,8 +1361,8 @@ expand_block_move (operands)\n \t\t   && !fixed_regs[12])\n \t    {\n \t      move_bytes = (bytes > 24) ? 24 : bytes;\n-\t      emit_insn (gen_movstrsi_6reg (dest_reg,\n-\t\t\t\t\t    src_reg,\n+\t      emit_insn (gen_movstrsi_6reg (expand_block_move_mem (BLKmode, dest_reg, orig_dest),\n+\t\t\t\t\t    expand_block_move_mem (BLKmode, src_reg, orig_src),\n \t\t\t\t\t    GEN_INT (move_bytes),\n \t\t\t\t\t    align_rtx));\n \t    }\n@@ -1268,45 +1373,45 @@ expand_block_move (operands)\n \t\t   && !fixed_regs[12])\n \t    {\n \t      move_bytes = (bytes > 16) ? 16 : bytes;\n-\t      emit_insn (gen_movstrsi_4reg (dest_reg,\n-\t\t\t\t\t    src_reg,\n+\t      emit_insn (gen_movstrsi_4reg (expand_block_move_mem (BLKmode, dest_reg, orig_dest),\n+\t\t\t\t\t    expand_block_move_mem (BLKmode, src_reg, orig_src),\n \t\t\t\t\t    GEN_INT (move_bytes),\n \t\t\t\t\t    align_rtx));\n \t    }\n \t  else if (bytes > 4 && !TARGET_64BIT)\n \t    {\t\t\t/* move up to 8 bytes at a time */\n \t      move_bytes = (bytes > 8) ? 8 : bytes;\n-\t      emit_insn (gen_movstrsi_2reg (dest_reg,\n-\t\t\t\t\t    src_reg,\n+\t      emit_insn (gen_movstrsi_2reg (expand_block_move_mem (BLKmode, dest_reg, orig_dest),\n+\t\t\t\t\t    expand_block_move_mem (BLKmode, src_reg, orig_src),\n \t\t\t\t\t    GEN_INT (move_bytes),\n \t\t\t\t\t    align_rtx));\n \t    }\n \t  else if (bytes >= 4 && (align >= 4 || !STRICT_ALIGNMENT))\n \t    {\t\t\t/* move 4 bytes */\n \t      move_bytes = 4;\n \t      tmp_reg = gen_reg_rtx (SImode);\n-\t      emit_move_insn (tmp_reg, gen_rtx (MEM, SImode, src_reg));\n-\t      emit_move_insn (gen_rtx (MEM, SImode, dest_reg), tmp_reg);\n+\t      emit_move_insn (tmp_reg, expand_block_move_mem (SImode, src_reg, orig_src));\n+\t      emit_move_insn (expand_block_move_mem (SImode, dest_reg, orig_dest), tmp_reg);\n \t    }\n \t  else if (bytes == 2 && (align >= 2 || !STRICT_ALIGNMENT))\n \t    {\t\t\t/* move 2 bytes */\n \t      move_bytes = 2;\n \t      tmp_reg = gen_reg_rtx (HImode);\n-\t      emit_move_insn (tmp_reg, gen_rtx (MEM, HImode, src_reg));\n-\t      emit_move_insn (gen_rtx (MEM, HImode, dest_reg), tmp_reg);\n+\t      emit_move_insn (tmp_reg, expand_block_move_mem (HImode, src_reg, orig_src));\n+\t      emit_move_insn (expand_block_move_mem (HImode, dest_reg, orig_dest), tmp_reg);\n \t    }\n \t  else if (bytes == 1)\t/* move 1 byte */\n \t    {\n \t      move_bytes = 1;\n \t      tmp_reg = gen_reg_rtx (QImode);\n-\t      emit_move_insn (tmp_reg, gen_rtx (MEM, QImode, src_reg));\n-\t      emit_move_insn (gen_rtx (MEM, QImode, dest_reg), tmp_reg);\n+\t      emit_move_insn (tmp_reg, expand_block_move_mem (QImode, src_reg, orig_src));\n+\t      emit_move_insn (expand_block_move_mem (QImode, dest_reg, orig_dest), tmp_reg);\n \t    }\n \t  else\n \t    {\t\t\t/* move up to 4 bytes at a time */\n \t      move_bytes = (bytes > 4) ? 4 : bytes;\n-\t      emit_insn (gen_movstrsi_1reg (dest_reg,\n-\t\t\t\t\t    src_reg,\n+\t      emit_insn (gen_movstrsi_1reg (expand_block_move_mem (BLKmode, dest_reg, orig_dest),\n+\t\t\t\t\t    expand_block_move_mem (BLKmode, src_reg, orig_src),\n \t\t\t\t\t    GEN_INT (move_bytes),\n \t\t\t\t\t    align_rtx));\n \t    }\n@@ -1337,26 +1442,33 @@ expand_block_move (operands)\n \t    }\n \n \t  /* Generate the appropriate load and store, saving the stores for later */\n-\t  if (bytes >= 4 && (align >= 4 || !STRICT_ALIGNMENT))\n+\t  if (bytes >= 8 && TARGET_64BIT && (align >= 8 || !STRICT_ALIGNMENT))\n+\t    {\n+\t      move_bytes = 8;\n+\t      tmp_reg = gen_reg_rtx (DImode);\n+\t      emit_insn (gen_movdi (tmp_reg, expand_block_move_mem (DImode, src_addr, orig_src)));\n+\t      stores[ num_reg++ ] = gen_movdi (expand_block_move_mem (DImode, dest_addr, orig_dest), tmp_reg);\n+\t    }\n+\t  else if (bytes >= 4 && (align >= 4 || !STRICT_ALIGNMENT))\n \t    {\n \t      move_bytes = 4;\n \t      tmp_reg = gen_reg_rtx (SImode);\n-\t      emit_insn (gen_movsi (tmp_reg, gen_rtx (MEM, SImode, src_addr)));\n-\t      stores[ num_reg++ ] = gen_movsi (gen_rtx (MEM, SImode, dest_addr), tmp_reg);\n+\t      emit_insn (gen_movsi (tmp_reg, expand_block_move_mem (SImode, src_addr, orig_src)));\n+\t      stores[ num_reg++ ] = gen_movsi (expand_block_move_mem (SImode, dest_addr, orig_dest), tmp_reg);\n \t    }\n \t  else if (bytes >= 2 && (align >= 2 || !STRICT_ALIGNMENT))\n \t    {\n \t      move_bytes = 2;\n \t      tmp_reg = gen_reg_rtx (HImode);\n-\t      emit_insn (gen_movhi (tmp_reg, gen_rtx (MEM, HImode, src_addr)));\n-\t      stores[ num_reg++ ] = gen_movhi (gen_rtx (MEM, HImode, dest_addr), tmp_reg);\n+\t      emit_insn (gen_movsi (tmp_reg, expand_block_move_mem (HImode, src_addr, orig_src)));\n+\t      stores[ num_reg++ ] = gen_movhi (expand_block_move_mem (HImode, dest_addr, orig_dest), tmp_reg);\n \t    }\n \t  else\n \t    {\n \t      move_bytes = 1;\n \t      tmp_reg = gen_reg_rtx (QImode);\n-\t      emit_insn (gen_movqi (tmp_reg, gen_rtx (MEM, QImode, src_addr)));\n-\t      stores[ num_reg++ ] = gen_movqi (gen_rtx (MEM, QImode, dest_addr), tmp_reg);\n+\t      emit_insn (gen_movsi (tmp_reg, expand_block_move_mem (QImode, src_addr, orig_src)));\n+\t      stores[ num_reg++ ] = gen_movqi (expand_block_move_mem (QImode, dest_addr, orig_dest), tmp_reg);\n \t    }\n \n \t  if (num_reg >= MAX_MOVE_REG)\n@@ -1367,11 +1479,8 @@ expand_block_move (operands)\n \t    }\n \t}\n \n-      if (num_reg > 0)\n-\t{\n-\t  for (i = 0; i < num_reg; i++)\n-\t    emit_insn (stores[i]);\n-\t}\n+      for (i = 0; i < num_reg; i++)\n+\temit_insn (stores[i]);\n     }\n \n   return 1;\n@@ -2127,9 +2236,26 @@ print_operand (file, x, code)\n       if (GET_CODE (x) != SYMBOL_REF)\n \tabort ();\n \n-#ifndef USING_SVR4_H\n-      putc ('.', file);\n-#endif\n+      if (XSTR (x, 0)[0] != '.')\n+\t{\n+\t  switch (DEFAULT_ABI)\n+\t    {\n+\t    default:\n+\t      abort ();\n+\n+\t    case ABI_AIX:\n+\t      putc ('.', file);\n+\t      break;\n+\n+\t    case ABI_V4:\n+\t    case ABI_AIX_NODESC:\n+\t      break;\n+\n+\t    case ABI_NT:\n+\t      fputs (\"..\", file);\n+\t      break;\n+\t    }\n+\t}\n       RS6000_OUTPUT_BASENAME (file, XSTR (x, 0));\n       return;\n \n@@ -2235,11 +2361,9 @@ first_reg_to_save ()\n      to 23 to do this.  Don't use the frame pointer in reg 31.\n \n      For now, save enough room for all of the parameter registers.  */\n-#ifndef USING_SVR4_H\n-  if (profile_flag)\n+  if (DEFAULT_ABI == ABI_AIX && profile_flag)\n     if (first_reg > 23)\n       first_reg = 23;\n-#endif\n \n   return first_reg;\n }\n@@ -2333,7 +2457,49 @@ rs6000_makes_calls ()\n \t\t+---------------------------------------+\n \told SP->| back chain to caller's caller\t\t|\n \t\t+---------------------------------------+\n-*/\n+\n+\n+   A PowerPC Windows/NT frame looks like:\n+\n+\tSP---->\t+---------------------------------------+\n+\t\t| back chain to caller\t\t\t| 0\n+\t\t+---------------------------------------+\n+\t\t| reserved\t\t\t\t| 4\n+\t\t+---------------------------------------+\n+\t\t| reserved\t\t\t\t| 8\n+\t\t+---------------------------------------+\n+\t\t| reserved\t\t\t\t| 12\n+\t\t+---------------------------------------+\n+\t\t| reserved\t\t\t\t| 16\n+\t\t+---------------------------------------+\n+\t\t| reserved\t\t\t\t| 20\n+\t\t+---------------------------------------+\n+\t\t| Parameter save area (P)\t\t| 24\n+\t\t+---------------------------------------+\n+\t\t| Alloca space (A)\t\t\t| 24+P\n+\t\t+---------------------------------------+\n+\t\t| Local variable space (L)\t\t| 24+P+A\n+\t\t+---------------------------------------+\n+\t\t| Save area for FP registers (F)\t| 24+P+A+L\n+\t\t+---------------------------------------+\n+\t\t| Possible alignment area (X)\t\t| 24+P+A+L+F\n+\t\t+---------------------------------------+\n+\t\t| Save area for GP registers (G)\t| 24+P+A+L+F+X\n+\t\t+---------------------------------------+\n+\t\t| Save area for CR (C)\t\t\t| 24+P+A+L+F+X+G\n+\t\t+---------------------------------------+\n+\t\t| Save area for TOC (T)\t\t\t| 24+P+A+L+F+X+G+C\n+\t\t+---------------------------------------+\n+\t\t| Save area for LR (R)\t\t\t| 24+P+A+L+F+X+G+C+T\n+\t\t+---------------------------------------+\n+\told SP->| back chain to caller's caller\t\t|\n+\t\t+---------------------------------------+\n+\n+   For NT, there is no specific order to save the registers, but in\n+   order to support __builtin_return_address, the save area for the\n+   link register needs to be in a known place, so we use -4 off of the\n+   old SP.  To support calls through pointers, we also allocate a\n+   fixed slot to store the TOC, -8 off the old SP.  */\n \n rs6000_stack_t *\n rs6000_stack_info ()\n@@ -2342,19 +2508,13 @@ rs6000_stack_info ()\n   rs6000_stack_t *info_ptr = &info;\n   int reg_size = TARGET_64BIT ? 8 : 4;\n   enum rs6000_abi abi;\n+  int total_raw_size;\n \n   /* Zero all fields portably */\n   info = zero_info;\n \n   /* Select which calling sequence */\n-#ifdef TARGET_V4_CALLS\n-  if (TARGET_V4_CALLS)\n-    abi = ABI_V4;\n-  else\n-#endif\n-    abi = ABI_AIX;\n-\n-  info_ptr->abi = abi;\n+  info_ptr->abi = abi = DEFAULT_ABI;\n \n   /* Calculate which registers need to be saved & save area size */\n   info_ptr->first_gp_reg_save = first_reg_to_save ();\n@@ -2366,6 +2526,39 @@ rs6000_stack_info ()\n   /* Does this function call anything? */\n   info_ptr->calls_p = rs6000_makes_calls ();\n \n+  /* Do we need to allocate space to save the toc? */\n+  if (rs6000_save_toc_p)\n+    {\n+      info_ptr->toc_save_p = 1;\n+      info_ptr->toc_size = reg_size;\n+    }\n+\n+  /* If this is main and we need to call a function to set things up,\n+     save main's arguments around the call.  */\n+  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)), \"main\") == 0)\n+    {\n+      info_ptr->main_p = 1;\n+\n+#ifdef NAME__MAIN\n+      if (DECL_ARGUMENTS (current_function_decl))\n+\t{\n+\t  int i;\n+\t  tree arg;\n+\n+\t  info_ptr->main_save_p = 1;\n+\t  info_ptr->main_size = 0;\n+\t  info_ptr->calls_p = 1;\n+\n+\t  for ((i = 0), (arg = DECL_ARGUMENTS (current_function_decl));\n+\t       arg != NULL_TREE && i < 8;\n+\t       (arg = TREE_CHAIN (arg)), i++)\n+\t    {\n+\t      info_ptr->main_size += reg_size;\n+\t    }\n+\t}\n+#endif\n+    }\n+\n   /* Determine if we need to save the link register */\n   if (regs_ever_live[65] || profile_flag\n #ifdef TARGET_RELOCATABLE\n@@ -2378,13 +2571,15 @@ rs6000_stack_info ()\n     {\n       info_ptr->lr_save_p = 1;\n       regs_ever_live[65] = 1;\n+      if (abi == ABI_NT)\n+\tinfo_ptr->lr_size = reg_size;\n     }\n \n   /* Determine if we need to save the condition code registers */\n   if (regs_ever_live[70] || regs_ever_live[71] || regs_ever_live[72])\n     {\n       info_ptr->cr_save_p = 1;\n-      if (abi == ABI_V4)\n+      if (abi == ABI_V4 || abi == ABI_NT)\n \tinfo_ptr->cr_size = reg_size;\n     }\n \n@@ -2394,12 +2589,20 @@ rs6000_stack_info ()\n   info_ptr->varargs_size = RS6000_VARARGS_AREA;\n   info_ptr->vars_size    = ALIGN (get_frame_size (), 8);\n   info_ptr->parm_size    = ALIGN (current_function_outgoing_args_size, 8);\n-  info_ptr->save_size    = ALIGN (info_ptr->fp_size + info_ptr->gp_size + info_ptr->cr_size, 8);\n-  info_ptr->total_size   = ALIGN (info_ptr->vars_size\n-\t\t\t\t  + info_ptr->parm_size\n-\t\t\t\t  + info_ptr->save_size\n-\t\t\t\t  + info_ptr->varargs_size\n-\t\t\t\t  + info_ptr->fixed_size, STACK_BOUNDARY / BITS_PER_UNIT);\n+  info_ptr->save_size    = ALIGN (info_ptr->fp_size\n+\t\t\t\t  + info_ptr->gp_size\n+\t\t\t\t  + info_ptr->cr_size\n+\t\t\t\t  + info_ptr->lr_size\n+\t\t\t\t  + info_ptr->toc_size\n+\t\t\t\t  + info_ptr->main_size, 8);\n+\n+  total_raw_size\t = (info_ptr->vars_size\n+\t\t\t    + info_ptr->parm_size\n+\t\t\t    + info_ptr->save_size\n+\t\t\t    + info_ptr->varargs_size\n+\t\t\t    + info_ptr->fixed_size);\n+\n+  info_ptr->total_size   = ALIGN (total_raw_size, STACK_BOUNDARY / BITS_PER_UNIT);\n \n   /* Determine if we need to allocate any stack frame.\n      For AIX We need to push the stack if a frame pointer is needed (because\n@@ -2412,8 +2615,8 @@ rs6000_stack_info ()\n   if (info_ptr->calls_p)\n     info_ptr->push_p = 1;\n \n-  else if (abi == ABI_V4)\n-    info_ptr->push_p = (info_ptr->total_size > info_ptr->fixed_size\n+  else if (abi == ABI_V4 || abi == ABI_NT)\n+    info_ptr->push_p = (total_raw_size > info_ptr->fixed_size\n \t\t\t|| info_ptr->lr_save_p);\n \n   else\n@@ -2422,18 +2625,40 @@ rs6000_stack_info ()\n \t\t\t|| info_ptr->total_size > 220);\n \n   /* Calculate the offsets */\n-  info_ptr->fp_save_offset = - info_ptr->fp_size;\n-  info_ptr->gp_save_offset = info_ptr->fp_save_offset - info_ptr->gp_size;\n   switch (abi)\n     {\n+    case ABI_NONE:\n     default:\n-      info_ptr->cr_save_offset = 4;\n-      info_ptr->lr_save_offset = 8;\n+      abort ();\n+\n+    case ABI_AIX:\n+    case ABI_AIX_NODESC:\n+      info_ptr->fp_save_offset   = - info_ptr->fp_size;\n+      info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n+      info_ptr->main_save_offset = info_ptr->gp_save_offset - info_ptr->main_size;\n+      info_ptr->cr_save_offset   = 4;\n+      info_ptr->lr_save_offset   = 8;\n       break;\n \n     case ABI_V4:\n-      info_ptr->cr_save_offset = info_ptr->gp_save_offset - reg_size;\n-      info_ptr->lr_save_offset = reg_size;\n+      info_ptr->fp_save_offset   = - info_ptr->fp_size;\n+      info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n+      info_ptr->cr_save_offset   = info_ptr->gp_save_offset - reg_size;\n+      info_ptr->toc_save_offset  = info_ptr->cr_save_offset - info_ptr->cr_size;\n+      info_ptr->main_save_offset = info_ptr->toc_save_offset - info_ptr->toc_size;\n+      info_ptr->lr_save_offset   = reg_size;\n+      break;\n+\n+    case ABI_NT:\n+      info_ptr->lr_save_offset    = -4;\n+      info_ptr->toc_save_offset   = info_ptr->lr_save_offset - info_ptr->lr_size;\n+      info_ptr->cr_save_offset    = info_ptr->toc_save_offset - info_ptr->toc_size;\n+      info_ptr->gp_save_offset    = info_ptr->cr_save_offset - info_ptr->cr_size - info_ptr->gp_size + reg_size;\n+      info_ptr->fp_save_offset    = info_ptr->gp_save_offset - info_ptr->fp_size;\n+      if (info_ptr->fp_size && ((- info_ptr->fp_save_offset) % 8) != 0)\n+\tinfo_ptr->fp_save_offset -= 4;\n+\n+      info_ptr->main_save_offset = info_ptr->fp_save_offset - info_ptr->main_size;\n       break;\n     }\n \n@@ -2450,6 +2675,12 @@ rs6000_stack_info ()\n   if (!info_ptr->cr_save_p)\n     info_ptr->cr_save_offset = 0;\n \n+  if (!info_ptr->toc_save_p)\n+    info_ptr->toc_save_offset = 0;\n+\n+  if (!info_ptr->main_save_p)\n+    info_ptr->main_save_offset = 0;\n+\n   return info_ptr;\n }\n \n@@ -2469,10 +2700,12 @@ debug_stack_info (info)\n \n   switch (info->abi)\n     {\n-    default:\t   abi_string = \"Unknown\";\tbreak;\n-    case ABI_NONE: abi_string = \"NONE\";\t\tbreak;\n-    case ABI_AIX:  abi_string = \"AIX\";\t\tbreak;\n-    case ABI_V4:   abi_string = \"V.4\";\t\tbreak;\n+    default:\t\t abi_string = \"Unknown\";\tbreak;\n+    case ABI_NONE:\t abi_string = \"NONE\";\t\tbreak;\n+    case ABI_AIX:\t abi_string = \"AIX\";\t\tbreak;\n+    case ABI_AIX_NODESC: abi_string = \"AIX\";\t\tbreak;\n+    case ABI_V4:\t abi_string = \"V.4\";\t\tbreak;\n+    case ABI_NT:\t abi_string = \"NT\";\t\tbreak;\n     }\n \n   fprintf (stderr, \"\\tABI                 = %5s\\n\", abi_string);\n@@ -2489,12 +2722,21 @@ debug_stack_info (info)\n   if (info->cr_save_p)\n     fprintf (stderr, \"\\tcr_save_p           = %5d\\n\", info->cr_save_p);\n \n+  if (info->toc_save_p)\n+    fprintf (stderr, \"\\ttoc_save_p          = %5d\\n\", info->toc_save_p);\n+\n   if (info->push_p)\n     fprintf (stderr, \"\\tpush_p              = %5d\\n\", info->push_p);\n \n   if (info->calls_p)\n     fprintf (stderr, \"\\tcalls_p             = %5d\\n\", info->calls_p);\n \n+  if (info->main_p)\n+    fprintf (stderr, \"\\tmain_p              = %5d\\n\", info->main_p);\n+\n+  if (info->main_save_p)\n+    fprintf (stderr, \"\\tmain_save_p         = %5d\\n\", info->main_save_p);\n+\n   if (info->gp_save_offset)\n     fprintf (stderr, \"\\tgp_save_offset      = %5d\\n\", info->gp_save_offset);\n \n@@ -2507,9 +2749,15 @@ debug_stack_info (info)\n   if (info->cr_save_offset)\n     fprintf (stderr, \"\\tcr_save_offset      = %5d\\n\", info->cr_save_offset);\n \n+  if (info->toc_save_offset)\n+    fprintf (stderr, \"\\ttoc_save_offset     = %5d\\n\", info->toc_save_offset);\n+\n   if (info->varargs_save_offset)\n     fprintf (stderr, \"\\tvarargs_save_offset = %5d\\n\", info->varargs_save_offset);\n \n+  if (info->main_save_offset)\n+    fprintf (stderr, \"\\tmain_save_offset    = %5d\\n\", info->main_save_offset);\n+\n   if (info->total_size)\n     fprintf (stderr, \"\\ttotal_size          = %5d\\n\", info->total_size);\n \n@@ -2531,9 +2779,18 @@ debug_stack_info (info)\n   if (info->fp_size)\n     fprintf (stderr, \"\\tfp_size             = %5d\\n\", info->fp_size);\n \n+ if (info->lr_size)\n+    fprintf (stderr, \"\\tlr_size             = %5d\\n\", info->cr_size);\n+\n   if (info->cr_size)\n     fprintf (stderr, \"\\tcr_size             = %5d\\n\", info->cr_size);\n \n+ if (info->toc_size)\n+    fprintf (stderr, \"\\ttoc_size            = %5d\\n\", info->toc_size);\n+\n+ if (info->main_size)\n+    fprintf (stderr, \"\\tmain_size           = %5d\\n\", info->main_size);\n+\n   if (info->save_size)\n     fprintf (stderr, \"\\tsave_size           = %5d\\n\", info->save_size);\n \n@@ -2543,65 +2800,6 @@ debug_stack_info (info)\n   fprintf (stderr, \"\\n\");\n }\n \n-\f\n-\n-#ifdef USING_SVR4_H\n-/* Write out a System V.4 style traceback table before the prologue\n-\n-   At present, only emit the basic tag table (ie, do not emit tag_types other\n-   than 0, which might use more than 1 tag word).\n-\n-   The first tag word looks like:\n-\n-    0\t\t\t1\t\t    2\t\t\t3\n-    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n-   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n-   |         0 |ver| tag |e|s| alloca  | # fprs  | # gprs  |s|l|c|f|\n-   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n-\n-*/\n-\n-void\n-svr4_traceback (file, name, decl)\n-     FILE *file;\n-     tree name, decl;\n-{\n-  rs6000_stack_t *info = rs6000_stack_info ();\n-  long tag;\n-  long version\t\t= 0;\t\t\t\t/* version number */\n-  long tag_type\t\t= 0;\t\t\t\t/* function type */\n-  long extended_tag\t= 0;\t\t\t\t/* additional tag words needed */\n-  long spare\t\t= 0;\t\t\t\t/* reserved for future use */\n-  long fpscr_max\t= 0;\t\t\t\t/* 1 if the function has a FPSCR save word */\n-  long fpr_max\t\t= 64 - info->first_fp_reg_save;\t/* # of floating point registers saved */\n-  long gpr_max\t\t= 32 - info->first_gp_reg_save;\t/* # of general purpose registers saved */\n-  long alloca_reg;\t\t\t\t\t/* stack/frame register */\n-\n-  if (frame_pointer_needed)\n-    alloca_reg = 31;\n-\n-  else if (info->push_p != 0)\n-    alloca_reg = 1;\n-\n-  else\n-    alloca_reg = 0;\n-\n-  tag = ((version << 24)\n-\t | (tag_type << 21)\n-\t | (extended_tag << 20)\n-\t | (spare << 19)\n-\t | (alloca_reg << 14)\n-\t | (fpr_max << 9)\n-\t | (gpr_max << 4)\n-\t | (info->push_p << 3)\n-\t | (info->lr_save_p << 2)\n-\t | (info->cr_save_p << 1)\n-\t | (fpscr_max << 0));\n-\t   \n-  fprintf (file, \"\\t.long 0x%lx\\n\", tag);\n-}\n-\n-#endif /* USING_SVR4_H */\n \f\n /* Write function prologue.  */\n void\n@@ -2610,19 +2808,30 @@ output_prolog (file, size)\n      int size;\n {\n   rs6000_stack_t *info = rs6000_stack_info ();\n-  char *store_reg = (TARGET_64BIT) ? \"\\tstd %s,%d(%s)\" : \"\\t{st|stw} %s,%d(%s)\\n\";\n+  int reg_size = info->reg_size;\n+  char *store_reg;\n+  char *load_reg;\n+\n+  if (TARGET_64BIT)\n+    {\n+      store_reg = \"\\tstd %s,%d(%s)\";\n+      load_reg = \"\\tlld %s,%d(%s)\";\n+    }\n+  else\n+    {\n+      store_reg = \"\\t{st|stw} %s,%d(%s)\\n\";\n+      load_reg = \"\\t{l|lwz} %s,%d(%s)\\n\";\n+    }\n \n   if (TARGET_DEBUG_STACK)\n     debug_stack_info (info);\n \n   /* Write .extern for any function we will call to save and restore fp\n      values.  */\n-#ifndef USING_SVR4_H\n-  if (info->first_fp_reg_save < 62)\n+  if (info->first_fp_reg_save < 64 && !FP_SAVE_INLINE (info->first_fp_reg_save))\n     fprintf (file, \"\\t.extern %s%d%s\\n\\t.extern %s%d%s\\n\",\n \t     SAVE_FP_PREFIX, info->first_fp_reg_save - 32, SAVE_FP_SUFFIX,\n \t     RESTORE_FP_PREFIX, info->first_fp_reg_save - 32, RESTORE_FP_SUFFIX);\n-#endif\n \n   /* Write .extern for truncation routines, if needed.  */\n   if (rs6000_trunc_used && ! trunc_defined)\n@@ -2672,7 +2881,6 @@ output_prolog (file, size)\n     {\n       int regno    = info->first_gp_reg_save;\n       int loc      = info->gp_save_offset;\n-      int reg_size = (TARGET_64BIT) ? 8 : 4;\n \n       for ( ; regno < 32; regno++, loc += reg_size)\n \tasm_fprintf (file, store_reg, reg_names[regno], loc, reg_names[1]);\n@@ -2684,6 +2892,19 @@ output_prolog (file, size)\n \t\t info->gp_save_offset,\n \t\t reg_names[1]);\n \n+  /* Save main's arguments if we need to call a function */\n+#ifdef NAME__MAIN\n+  if (info->main_save_p)\n+    {\n+      int regno;\n+      int loc = info->main_save_offset;\n+      int size = info->main_size;\n+\n+      for (regno = 3; size > 0; regno++, loc -= reg_size, size -= reg_size)\n+\tasm_fprintf (file, store_reg, reg_names[regno], loc, reg_names[1]);\n+    }\n+#endif\n+\n   /* Save lr if we used it.  */\n   if (info->lr_save_p)\n     asm_fprintf (file, store_reg, reg_names[0], info->lr_save_offset, reg_names[1]);\n@@ -2692,6 +2913,9 @@ output_prolog (file, size)\n   if (info->cr_save_p)\n     asm_fprintf (file, store_reg, reg_names[12], info->cr_save_offset, reg_names[1]);\n \n+  if (info->toc_save_p)\n+    asm_fprintf (file, store_reg, reg_names[2], info->toc_save_offset, reg_names[1]);\n+\n   /* Update stack and set back pointer.  */\n   if (info->push_p)\n     {\n@@ -2715,13 +2939,62 @@ output_prolog (file, size)\n   if (frame_pointer_needed)\n     asm_fprintf (file, \"\\tmr %s,%s\\n\", reg_names[31], reg_names[1]);\n \n+#ifdef NAME__MAIN\n+  /* If we need to call a function to set things up for main, do so now\n+     before dealing with the TOC.  */\n+  if (info->main_p)\n+    {\n+      char *prefix = \"\";\n+\n+      switch (DEFAULT_ABI)\n+\t{\n+\tcase ABI_AIX:\tprefix = \".\";\tbreak;\n+\tcase ABI_NT:\tprefix = \"..\";\tbreak;\n+\t}\n+\n+      fprintf (file, \"\\tbl %s%s\\n\", prefix, NAME__MAIN);\n+#ifdef RS6000_CALL_GLUE2\n+      fprintf (file, \"\\t%s%s%s\\n\", RS6000_CALL_GLUE2, prefix, NAME_MAIN);\n+#else\n+#ifdef RS6000_CALL_GLUE\n+      if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT)\n+\tfprintf (file, \"\\t%s\\n\", RS6000_CALL_GLUE);\n+#endif\n+#endif\n+\n+      if (info->main_save_p)\n+\t{\n+\t  int regno;\n+\t  int loc;\n+\t  int size = info->main_size;\n+\n+\t  if (info->total_size < 32767)\n+\t    {\n+\t      loc = info->total_size + info->main_save_offset;\n+\t      for (regno = 3; size > 0; regno++, size -= reg_size, loc -= reg_size)\n+\t\tasm_fprintf (file, load_reg, reg_names[regno], loc, reg_names[1]);\n+\t    }\n+\t  else\n+\t    {\t\t\t/* for large frames, reg 0 above contains -frame size */\n+\t      loc = info->main_save_offset;\n+\t      asm_fprintf (file, \"\\t{sf|subf} %s,%s,%s\\n\", reg_names[0], reg_names[0],\n+\t\t\t   reg_names[1]);\n+\n+\t      for (regno = 3; size > 0; regno++, size -= reg_size, loc -= reg_size)\n+\t\tasm_fprintf (file, load_reg, reg_names[regno], loc, reg_names[0]);\n+\t    }\n+\t}\n+    }\n+#endif\n+\n+\n   /* If TARGET_MINIMAL_TOC, and the constant pool is needed, then load the\n      TOC_TABLE address into register 30.  */\n   if (TARGET_TOC && TARGET_MINIMAL_TOC && get_pool_size () != 0)\n     {\n       char buf[256];\n \n-#ifdef USING_SVR4_H\n+#ifdef TARGET_RELOCATABLE\n       if (TARGET_RELOCATABLE)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\n@@ -2732,13 +3005,7 @@ output_prolog (file, size)\n \t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LCF\", rs6000_pic_labelno);\n \t  fprintf (file, \"\\tmflr %s\\n\", reg_names[30]);\n \n-\t  if (TARGET_POWERPC64)\n-\t    fprintf (file, \"\\tld\");\n-\t  else if (TARGET_NEW_MNEMONICS)\n-\t    fprintf (file, \"\\tlwz\");\n-\t  else\n-\t    fprintf (file, \"\\tl\");\n-\n+\t  asm_fprintf (file, TARGET_64BIT ? \"\\tld\" : \"\\t{l|lwz}\");\n \t  fprintf (file, \" %s,(\", reg_names[0]);\n \t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCL\", rs6000_pic_labelno);\n \t  assemble_name (file, buf);\n@@ -2750,34 +3017,51 @@ output_prolog (file, size)\n \t\t       reg_names[30], reg_names[0], reg_names[30]);\n \t  rs6000_pic_labelno++;\n \t}\n-      else if (!TARGET_64BIT)\n-\t{\n-\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 1);\n-\t  asm_fprintf (file, \"\\t{cau|addis} %s,%s,\", reg_names[30], reg_names[0]);\n+      else\n+#endif\n+\n+\tswitch (DEFAULT_ABI)\n+\t  {\n+\t  case ABI_V4:\n+\t  case ABI_AIX_NODESC:\n+\t    if (!TARGET_64BIT)\n+\t      {\n+\t\tASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 1);\n+\t\tasm_fprintf (file, \"\\t{cau|addis} %s,%s,\", reg_names[30], reg_names[0]);\n+\t\tassemble_name (file, buf);\n+\t\tasm_fprintf (file, \"@ha\\n\");\n+\t\tif (TARGET_NEW_MNEMONICS)\n+\t\t  {\n+\t\t    asm_fprintf (file, \"\\taddi %s,%s,\", reg_names[30], reg_names[30]);\n+\t\t    assemble_name (file, buf);\n+\t\t    asm_fprintf (file, \"@l\\n\");\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    asm_fprintf (file, \"\\tcal %s,\", reg_names[30]);\n+\t\t    assemble_name (file, buf);\n+\t\t    asm_fprintf (file, \"@l(%s)\\n\", reg_names[30]);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      abort ();\n+\n+\t  break;\n+\n+\tcase ABI_NT:\n+\tcase ABI_AIX:\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 0);\n+\t  asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[30]);\n \t  assemble_name (file, buf);\n-\t  asm_fprintf (file, \"@ha\\n\");\n-\t  if (TARGET_NEW_MNEMONICS)\n-\t    {\n-\t      asm_fprintf (file, \"\\taddi %s,%s,\", reg_names[30], reg_names[30]);\n-\t      assemble_name (file, buf);\n-\t      asm_fprintf (file, \"@l\\n\");\n-\t    }\n-\t  else\n-\t    {\n-\t      asm_fprintf (file, \"\\tcal %s,\", reg_names[30]);\n-\t      assemble_name (file, buf);\n-\t      asm_fprintf (file, \"@l(%s)\\n\", reg_names[30]);\n-\t    }\n+\t  asm_fprintf (file, \"(%s)\\n\", reg_names[2]);\n+\t  break;\n \t}\n-      else\n-\tabort ();\n+    }\n \n-#else\t/* !USING_SVR4_H */\n-      ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 0);\n-      asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[30]);\n-      assemble_name (file, buf);\n-      asm_fprintf (file, \"(%s)\\n\", reg_names[2]);\n-#endif /* USING_SVR4_H */\n+  if (DEFAULT_ABI == ABI_NT)\n+    {\n+      assemble_name (file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n+      fputs (\".b:\\n\", file);\n     }\n }\n \n@@ -2886,14 +3170,16 @@ output_epilog (file, size)\n      traceback table itself.\n \n      System V.4 Powerpc's (and the embedded ABI derived from it) use a\n-     different traceback table located before the prologue.  */\n-#ifndef USING_SVR4_H\n-  if (! flag_inhibit_size_directive)\n+     different traceback table.  */\n+  if (DEFAULT_ABI == ABI_AIX && ! flag_inhibit_size_directive)\n     {\n       char *fname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n       int fixed_parms, float_parms, parm_info;\n       int i;\n \n+      while (*fname == '.')\t/* V.4 encodes . in the name */\n+\tfname++;\n+\n       /* Need label immediately before tbtab, so we can compute its offset\n \t from the function start.  */\n       if (*fname == '*')\n@@ -3065,10 +3351,18 @@ output_epilog (file, size)\n       if (frame_pointer_needed)\n \tfprintf (file, \"\\t.byte 31\\n\");\n     }\n-#endif /* !USING_SVR4_H */\n \n-  /* Reset varargs indicator */\n+  /* Reset varargs and save TOC indicator */\n   rs6000_sysv_varargs_p = 0;\n+  rs6000_save_toc_p = 0;\n+\n+  if (DEFAULT_ABI == ABI_NT)\n+    {\n+      RS6000_OUTPUT_BASENAME (file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n+      fputs (\".e:\\nFE_MOT_RESVD..\", file);\n+      RS6000_OUTPUT_BASENAME (file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n+      fputs (\":\\n\", file);\n+    }\n }\n \f\n /* Output a TOC entry.  We derive the entry name from what is\n@@ -3082,6 +3376,7 @@ output_toc (file, x, labelno)\n {\n   char buf[256];\n   char *name = buf;\n+  char *real_name;\n   rtx base = x;\n   int offset = 0;\n \n@@ -3098,16 +3393,14 @@ output_toc (file, x, labelno)\n   }\n \n \n-#ifdef USING_SVR4_H\n-  if (TARGET_MINIMAL_TOC)\n+  if (TARGET_ELF && TARGET_MINIMAL_TOC)\n     {\n       ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LC\");\n       fprintf (file, \"%d = .-\", labelno);\n       ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LCTOC\");\n       fprintf (file, \"1\\n\");\n     }\n   else\n-#endif /* USING_SVR4_H */\n     ASM_OUTPUT_INTERNAL_LABEL (file, \"LC\", labelno);\n \n   /* Handle FP constants specially.  Note that if we have a minimal\n@@ -3163,8 +3456,8 @@ output_toc (file, x, labelno)\n     fprintf (file, \"\\t.long \");\n   else\n     {\n-      fprintf (file, \"\\t.tc \");\n-      RS6000_OUTPUT_BASENAME (file, name);\n+      STRIP_NAME_ENCODING (real_name, name);\n+      fprintf (file, \"\\t.tc %s\", real_name);\n \n       if (offset < 0)\n \tfprintf (file, \".N%d\", - offset);\n@@ -3309,14 +3602,14 @@ output_function_profiler (file, labelno)\n   FILE *file;\n   int labelno;\n {\n-#ifdef USING_SVR4_H\n-  abort ();\n-#else\n   /* The last used parameter register.  */\n   int last_parm_reg;\n   int i, j;\n   char buf[100];\n \n+  if (DEFAULT_ABI != ABI_AIX)\n+    abort ();\n+\n   /* Set up a TOC entry for the profiler label.  */\n   toc_section ();\n   ASM_OUTPUT_INTERNAL_LABEL (file, \"LPC\", labelno);\n@@ -3363,7 +3656,6 @@ output_function_profiler (file, labelno)\n \n   for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n     fprintf (file, \"\\tai %d,%d,0\\n\", i, j);\n-#endif\n }\n \n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n@@ -3399,3 +3691,275 @@ rs6000_adjust_cost (insn, link, dep_insn, cost)\n \n   return cost;\n }\n+\n+/* Return how many instructions the machine can issue per cycle */\n+int get_issue_rate()\n+{\n+  switch (rs6000_cpu_attr) {\n+  case CPU_RIOS1:\n+    return 3;       /* ? */\n+  case CPU_RIOS2:\n+    return 4;\n+  case CPU_PPC601:\n+    return 3;       /* ? */\n+  case CPU_PPC602:\n+    return 1; \n+  case CPU_PPC603:\n+    return 2; \n+  case CPU_PPC604:\n+    return 4;\n+  case CPU_PPC620:\n+    return 4;\n+  default:\n+    return 1;\n+  }\n+}\n+\n+\f\n+/* Output insns to flush the {data|instruction} caches after building a\n+   trampoline. */\n+\n+static void\n+rs6000_sync_trampoline (addr)\n+     rtx addr;\n+{\n+  enum machine_mode pmode = Pmode;\n+  rtx reg = gen_reg_rtx (pmode);\n+  rtx mem2;\n+  rtx mem1;\n+  int size = rs6000_trampoline_size ();\n+  rtx (*sub_fcn) PROTO ((rtx, rtx, rtx));\n+  rtx (*cmp_fcn) PROTO ((rtx, rtx));\n+  rtx label;\n+\n+  if (TARGET_64BIT)\n+    {\n+      abort ();\t\t\t/* no cmpdi function yet */\n+    }\n+  else\n+    {\n+      sub_fcn = gen_subsi3;\n+      cmp_fcn = gen_cmpsi;\n+    }\n+\n+  addr = force_reg (pmode, addr);\n+  mem2 = gen_rtx (MEM, pmode, gen_rtx (PLUS, pmode, addr, reg));\n+  mem1 = gen_rtx (MEM, pmode, addr);\n+\n+  /* Issue a loop of dcbst's to flush the data cache */\n+  emit_move_insn (reg, GEN_INT (size-4));\n+  label = gen_label_rtx ();\n+  emit_label (label);\n+  emit_insn (gen_dcbst (mem2, addr, reg));\n+  emit_insn ((*sub_fcn) (reg, reg, GEN_INT (4)));\n+  emit_insn ((*cmp_fcn) (reg, const0_rtx));\n+  emit_jump_insn (gen_bgt (label));\n+\n+  /* Issue a sync after the dcbst's to let things settle down */\n+  emit_insn (gen_sync (mem1));\n+\n+  /* Issue a loop of icbi's to flush the instruction cache */\n+  emit_move_insn (reg, GEN_INT (size-4));\n+  label = gen_label_rtx ();\n+  emit_label (label);\n+  emit_insn (gen_icbi (mem2, addr, reg));\n+  emit_insn ((*sub_fcn) (reg, reg, GEN_INT (4)));\n+  emit_insn ((*cmp_fcn) (reg, const0_rtx));\n+  emit_jump_insn (gen_bgt (label));\n+\n+  /* Issue a sync after the icbi's to let things settle down */\n+  emit_insn (gen_sync (mem1));\n+\n+  /* Finally issue an isync to synchronize the icache */\n+  emit_insn (gen_isync (mem1));\n+}\n+\n+\f\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   The trampoline should set the static chain pointer to value placed\n+   into the trampoline and should branch to the specified routine.  */\n+\n+void\n+rs6000_trampoline_template (file)\n+     FILE *file;\n+{\n+  char *sc = reg_names[STATIC_CHAIN_REGNUM];\n+  char *r0 = reg_names[0];\n+\n+  switch (DEFAULT_ABI)\n+    {\n+    default:\n+      abort ();\n+\n+    /* Under AIX, this is not code at all, but merely a data area,\n+       since that is the way all functions are called.  The first word is\n+       the address of the function, the second word is the TOC pointer (r2),\n+       and the third word is the static chain value.  */\n+    case ABI_AIX:\n+      fprintf (file, \"\\t.long %s\\n\", (TARGET_64BIT) ? \"0,0,0,0,0,0\" : \"0,0,0\");\n+      break;\n+\n+\n+    /* V.4/eabi function pointers are just a single pointer, so we need to\n+       do the full gory code to load up the static chain.  */\n+    case ABI_V4:\n+    case ABI_AIX_NODESC:\n+      if (STATIC_CHAIN_REGNUM == 0 || !TARGET_NEW_MNEMONICS)\n+\tabort ();\n+\n+      if (TARGET_64BIT)\n+\t{\n+\t  fprintf (file, \"\\tmflr %s\\n\", r0);\t\t/* offset  0 */\n+\t  fprintf (file, \"\\tbl .LTRAMP1\\n\");\t\t/* offset  4 */\n+\t  fprintf (file, \"\\t.long 0,0,0,0\\n\");\t\t/* offset  8 */\n+\t  fprintf (file, \".LTRAMP1:\\n\");\n+\t  fprintf (file, \"\\tmflr %s\\n\", sc);\t\t/* offset 28 */\n+\t  fprintf (file, \"\\tmtlr %s\\n\", r0);\t\t/* offset 32 */\n+\t  fprintf (file, \"\\tld %s,0(%s)\\n\", r0, sc);\t/* offset 36 */\n+\t  fprintf (file, \"\\tld %s,8(%s)\\n\", sc, sc);\t/* offset 40 */\n+\t  fprintf (file, \"\\tmtctr %s\\n\", r0);\t\t/* offset 44 */\n+\t  fprintf (file, \"\\tbctr\\n\");\t\t\t/* offset 48 */\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tmflr %s\\n\", r0);\t\t/* offset  0 */\n+\t  fprintf (file, \"\\tbl .LTRAMP1\\n\");\t\t/* offset  4 */\n+\t  fprintf (file, \"\\t.long 0,0\\n\");\t\t/* offset  8 */\n+\t  fprintf (file, \".LTRAMP1:\\n\");\n+\t  fprintf (file, \"\\tmflr %s\\n\", sc);\t\t/* offset 20 */\n+\t  fprintf (file, \"\\tmtlr %s\\n\", r0);\t\t/* offset 24 */\n+\t  fprintf (file, \"\\tlwz %s,0(%s)\\n\", r0, sc);\t/* offset 28 */\n+\t  fprintf (file, \"\\tlwz %s,4(%s)\\n\", sc, sc);\t/* offset 32 */\n+\t  fprintf (file, \"\\tmtctr %s\\n\", r0);\t\t/* offset 36 */\n+\t  fprintf (file, \"\\tbctr\\n\");\t\t\t/* offset 40 */\n+\t}\n+      break;\n+\n+  /* NT function pointers point to a two word area (real address, TOC)\n+     which unfortunately does not include a static chain field.  So we\n+     need to have a 2 word area followed by the code to load up the\n+     static chain.  */\n+    case ABI_NT:\n+      if (STATIC_CHAIN_REGNUM == 0 || !TARGET_NEW_MNEMONICS || TARGET_64BIT)\n+\tabort ();\n+\n+      fprintf (file, \"\\t.ualong 0,0\\n\");\t\t/* offset  0 */\n+      fprintf (file, \"\\tmflr %s\\n\", r0);\t\t/* offset  8 */\n+      fprintf (file, \"\\tbl .LTRAMP1\\n\");\t\t/* offset 12 */\n+      fprintf (file, \"\\t.ualong 0,0\\n\");\t\t/* offset 16 */\n+      fprintf (file, \".LTRAMP1:\\n\");\n+      fprintf (file, \"\\tmflr %s\\n\", sc);\t\t/* offset 28 */\n+      fprintf (file, \"\\tmtlr %s\\n\", r0);\t\t/* offset 32 */\n+      fprintf (file, \"\\tlwz %s,0(%s)\\n\", r0, sc);\t/* offset 36 */\n+      fprintf (file, \"\\tlwz %s,4(%s)\\n\", sc, sc);\t/* offset 40 */\n+      fprintf (file, \"\\tmtctr %s\\n\", r0);\t\t/* offset 44 */\n+      fprintf (file, \"\\tbctr\\n\");\t\t\t/* offset 48 */\n+      break;\n+    }\n+\n+  return;\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+int\n+rs6000_trampoline_size ()\n+{\n+  int ret = 0;\n+\n+  switch (DEFAULT_ABI)\n+    {\n+    default:\n+      abort ();\n+\n+    case ABI_AIX:\n+      ret = (TARGET_64BIT) ? 24 : 12;\n+      break;\n+\n+    case ABI_V4:\n+    case ABI_AIX_NODESC:\n+      ret = (TARGET_64BIT ? 48 : 40);\n+      break;\n+\n+    case ABI_NT:\n+      ret = 52;\n+      break;\n+    }\n+\n+  return ret;\n+}\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+void\n+rs6000_initialize_trampoline (addr, fnaddr, cxt)\n+     rtx addr;\n+     rtx fnaddr;\n+     rtx cxt;\n+{\n+  rtx reg, reg2, reg3;\n+\n+  switch (DEFAULT_ABI)\n+    {\n+    default:\n+      abort ();\n+\n+    /* Under AIX, just build the 3 word function descriptor */\n+    case ABI_AIX:\n+      emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t       memory_address (SImode, (addr))),\n+\t\t      gen_rtx (MEM, SImode,\n+\t\t\t       memory_address (SImode, (fnaddr))));\n+      emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t       memory_address (SImode,\n+\t\t\t\t\t       plus_constant ((addr), 4))),\n+\t\t      gen_rtx (MEM, SImode,\n+\t\t\t       memory_address (SImode,\n+\t\t\t\t\t       plus_constant ((fnaddr), 4))));\n+      emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t       memory_address (SImode,\n+\t\t\t\t\t       plus_constant ((addr), 8))),\n+\t\t      force_reg (SImode, (cxt)));\n+      break;\n+\n+    /* Under V.4/eabi, update the two words after the bl to have the real\n+       function address and the static chain.  */\n+    case ABI_V4:\n+    case ABI_AIX_NODESC:\n+      reg = gen_reg_rtx (Pmode);\n+\n+      emit_move_insn (reg, fnaddr);\n+      emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (addr, 8)), reg);\n+      emit_move_insn (gen_rtx (MEM, Pmode,\n+\t\t\t       plus_constant (addr, (TARGET_64BIT ? 16 : 12))),\n+\t\t      cxt);\n+\n+      rs6000_sync_trampoline (addr);\n+      break;\n+\n+    /* Under NT, update the first 2 words to look like a normal descriptor, and\n+       then fill in the fields with the function address and static chain after\n+       the bl instruction.  */\n+    case ABI_NT:\n+      reg  = gen_reg_rtx (Pmode);\n+      reg2 = gen_reg_rtx (Pmode);\n+      reg3 = gen_reg_rtx (Pmode);\n+\n+      emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (addr, 4)),\n+\t\t      gen_rtx (REG, Pmode, 2));\n+      emit_move_insn (reg, fnaddr);\n+      emit_move_insn (reg2, gen_rtx (MEM, Pmode, reg));\n+      emit_move_insn (reg3, plus_constant (addr, 8));\n+      emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (addr, 16)), reg);\n+      emit_move_insn (gen_rtx (MEM, Pmode, addr), reg3);\n+      emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (addr, 20)), cxt);\n+      rs6000_sync_trampoline (addr);\n+      break;\n+    }\n+\n+  return;\n+}"}, {"sha": "f52a3814ab64ca0c656485ea916cc90afa4686e2", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 123, "deletions": 49, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -63,8 +63,11 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=rsc1: -D_ARCH_PWR} \\\n %{mcpu=403: -D_ARCH_PPC} \\\n %{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=602: -D_ARCH_PPC} \\\n %{mcpu=603: -D_ARCH_PPC} \\\n-%{mcpu=604: -D_ARCH_PPC}\"\n+%{mcpu=603e: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC} \\\n+%{mcpu=620: -D_ARCH_PPC}\"\n \n /* Define the options for the binder: Start text at 512, align all segments\n    to 512 bytes, and warn if there is text relocation.\n@@ -80,9 +83,15 @@ Boston, MA 02111-1307, USA.  */\n    that to actually build a shared library you will also need to specify an\n    export list with the -Wl,-bE option.  */\n \n+#ifndef CROSS_COMPILE\n+#define LINK_SPEC \"-T512 -H512 %{!r:-btextro} -bhalt:4 -bnodelcsect\\\n+   %{static:-bnso} \\\n+   %{shared:-bM:SRE}\"\n+#else\n #define LINK_SPEC \"-T512 -H512 %{!r:-btextro} -bhalt:4 -bnodelcsect\\\n    %{static:-bnso -bI:/lib/syscalls.exp} \\\n    %{!shared:%{g*:-bexport:/usr/lib/libg.exp}} %{shared:-bM:SRE}\"\n+#endif\n \n /* Profiled library versions are used by linking with special directories.  */\n #define LIB_SPEC \"%{pg:-L/lib/profiled -L/usr/lib/profiled}\\\n@@ -187,6 +196,25 @@ extern int target_flags;\n #define\tTARGET_TOC\t\t1\n #endif\n \n+/* Pseudo target to say whether this is Windows NT */\n+#ifndef\tTARGET_WINDOWS_NT\n+#define\tTARGET_WINDOWS_NT 0\n+#endif\n+\n+/* Pseudo target to say whether this is MAC */\n+#ifndef\tTARGET_MACOS\n+#define\tTARGET_MACOS 0\n+#endif\n+\n+/* Pseudo target to say whether this is AIX */\n+#ifndef TARGET_AIX\n+#if (TARGET_ELF || TARGET_WINDOWS_NT || TARGET_MACOS)\n+#define TARGET_AIX 0\n+#else\n+#define TARGET_AIX 1\n+#endif\n+#endif\n+\n /* Run-time compilation parameters selecting different hardware subsets.\n \n    Macro to define tables used to set the flags.\n@@ -246,6 +274,7 @@ enum processor_type\n   PROCESSOR_RIOS2,\n   PROCESSOR_PPC403,\n   PROCESSOR_PPC601,\n+  PROCESSOR_PPC602,\n   PROCESSOR_PPC603,\n   PROCESSOR_PPC604,\n   PROCESSOR_PPC620};\n@@ -256,7 +285,7 @@ extern enum processor_type rs6000_cpu;\n #define rs6000_cpu_attr ((enum attr_cpu)rs6000_cpu)\n \n /* Define generic processor types based upon current deployment.  */\n-#define PROCESSOR_COMMON  PROCESSOR_PPC601\n+#define PROCESSOR_COMMON  PROCESSOR_PPC604\n #define PROCESSOR_POWER   PROCESSOR_RIOS1\n #define PROCESSOR_POWERPC PROCESSOR_PPC601\n \n@@ -284,8 +313,16 @@ extern enum processor_type rs6000_cpu;\n \textern char *m88k_short_data;\n \t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n \n-#define TARGET_OPTIONS\t\t\\\n-{ {\"cpu=\", &rs6000_cpu_string}}\n+/* This is meant to be overriden in target specific files.  */\n+#ifndef SUBTARGET_OPTIONS\n+#define\tSUBTARGET_OPTIONS\n+#endif\n+\n+#define TARGET_OPTIONS\t\t\t\\\n+{\t\t\t\t\t\\\n+   {\"cpu=\", &rs6000_cpu_string}\t\t\\\n+   SUBTARGET_OPTIONS\t\t\t\\\n+}\n \n extern char *rs6000_cpu_string;\n \n@@ -670,6 +707,9 @@ extern char *rs6000_cpu_string;\n /* Place to put static chain when calling a function that requires it.  */\n #define STATIC_CHAIN_REGNUM 11\n \n+/* count register number for special purposes */\n+#define COUNT_REGISTER_REGNUM 66\n+\n /* Place that structure value return address is placed.\n \n    On the RS/6000, it is passed as an extra parameter.  */\n@@ -802,12 +842,16 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n \n /* Optional extra constraints for this machine.\n \n-   For the RS/6000, `Q' means that this is a memory operand that is just\n-   an offset from a register.  */\n+   'Q' means that is a memory operand that is just an offset from a reg.\n+   'R' is for AIX TOC entries.\n+   'S' is for Windows NT SYMBOL_REFs\n+   'T' is for Windows NT LABEL_REFs.  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n   ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t\\\n    : (C) == 'R' ? LEGITIMATE_CONSTANT_POOL_ADDRESS_P (OP)\t\t\\\n+   : (C) == 'S' ? (TARGET_WINDOWS_NT && DEFAULT_ABI == ABI_NT && GET_CODE (OP) == SYMBOL_REF)\\\n+   : (C) == 'T' ? (TARGET_WINDOWS_NT && DEFAULT_ABI == ABI_NT && GET_CODE (OP) == LABEL_REF) \\\n    : 0)\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -857,32 +901,49 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n enum rs6000_abi {\n   ABI_NONE,\n   ABI_AIX,\t\t\t/* IBM's AIX */\n-  ABI_V4\t\t\t/* System V.4/eabi */\n+  ABI_AIX_NODESC,\t\t/* AIX calling sequence minus function descriptors */\n+  ABI_V4,\t\t\t/* System V.4/eabi */\n+  ABI_NT\t\t\t/* Windows/NT */\n };\n \n+extern enum rs6000_abi rs6000_current_abi;\t/* available for use by subtarget */\n+\n+/* Default ABI to compile code for */\n+#ifndef DEFAULT_ABI\n+#define DEFAULT_ABI ABI_AIX\n+#endif\n+\n /* Structure used to define the rs6000 stack */\n typedef struct rs6000_stack {\n   int first_gp_reg_save;\t/* first callee saved GP register used */\n   int first_fp_reg_save;\t/* first callee saved FP register used */\n   int lr_save_p;\t\t/* true if the link reg needs to be saved */\n   int cr_save_p;\t\t/* true if the CR reg needs to be saved */\n+  int toc_save_p;\t\t/* true if the TOC needs to be saved */\n   int push_p;\t\t\t/* true if we need to allocate stack space */\n   int calls_p;\t\t\t/* true if the function makes any calls */\n+  int main_p;\t\t\t/* true if this is main */\n+  int main_save_p;\t\t/* true if this is main and we need to save args */\n   enum rs6000_abi abi;\t\t/* which ABI to use */\n   int gp_save_offset;\t\t/* offset to save GP regs from initial SP */\n   int fp_save_offset;\t\t/* offset to save FP regs from initial SP */\n   int lr_save_offset;\t\t/* offset to save LR from initial SP */\n   int cr_save_offset;\t\t/* offset to save CR from initial SP */\n+  int toc_save_offset;\t\t/* offset to save the TOC pointer */\n   int varargs_save_offset;\t/* offset to save the varargs registers */\n+  int main_save_offset;\t\t/* offset to save main's args */\n   int reg_size;\t\t\t/* register size (4 or 8) */\n   int varargs_size;\t\t/* size to hold V.4 args passed in regs */\n   int vars_size;\t\t/* variable save area size */\n   int parm_size;\t\t/* outgoing parameter size */\n+  int main_size;\t\t/* size to hold saving main's args */\n   int save_size;\t\t/* save area size */\n   int fixed_size;\t\t/* fixed size of stack frame */\n   int gp_size;\t\t\t/* size of saved GP registers */\n   int fp_size;\t\t\t/* size of saved FP registers */\n   int cr_size;\t\t\t/* size to hold CR if not in save_size */\n+  int lr_size;\t\t\t/* size to hold LR if not in save_size */\n+  int toc_size;\t\t\t/* size to hold TOC if not in save_size */\n   int total_size;\t\t/* total bytes allocated for stack */\n } rs6000_stack_t;\n \n@@ -905,6 +966,12 @@ typedef struct rs6000_stack {\n /* Size of the fixed area on the stack */\n #define RS6000_SAVE_AREA (TARGET_64BIT ? 48 : 24)\n \n+/* Address to save the TOC register */\n+#define RS6000_SAVE_TOC plus_constant (stack_pointer_rtx, 20)\n+\n+/* Whether a separate TOC save area is needed */\n+extern int rs6000_save_toc_p;\n+\n /* Size of the V.4 varargs area if needed */\n #define RS6000_VARARGS_AREA 0\n \n@@ -1130,6 +1197,13 @@ typedef struct rs6000_args\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n   function_arg_pass_by_reference(&CUM, MODE, TYPE, NAMED)\n \n+/* If defined, a C expression that gives the alignment boundary, in bits,\n+   of an argument with the specified mode and type.  If it is not defined, \n+   PARM_BOUNDARY is used for all arguments.  */\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n+  function_arg_boundary (MODE, TYPE)\n+\n /* Perform any needed actions needed for a function that is receiving a\n    variable number of arguments. \n \n@@ -1202,40 +1276,19 @@ typedef struct rs6000_args\n    of a trampoline, leaving space for the variable parts.\n \n    The trampoline should set the static chain pointer to value placed\n-   into the trampoline and should branch to the specified routine.\n-\n-   On the RS/6000, this is not code at all, but merely a data area,\n-   since that is the way all functions are called.  The first word is\n-   the address of the function, the second word is the TOC pointer (r2),\n-   and the third word is the static chain value.  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE) { fprintf (FILE, \"\\t.long 0, 0, 0\\n\"); }\n+   into the trampoline and should branch to the specified routine.  */\n+#define TRAMPOLINE_TEMPLATE(FILE) rs6000_trampoline_template (FILE)\n \n /* Length in units of the trampoline for entering a nested function.  */\n \n-#define TRAMPOLINE_SIZE    12\n+#define TRAMPOLINE_SIZE rs6000_trampoline_size ()\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n    CXT is an RTX for the static chain value for the function.  */\n \n #define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode,\t\t\t\t\\\n-\t\t\t   memory_address (SImode, (ADDR))),\t\\\n-\t\t  gen_rtx (MEM, SImode,\t\t\t\t\\\n-\t\t\t   memory_address (SImode, (FNADDR))));\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode,\t\t\t\t\\\n-\t\t\t   memory_address (SImode,\t\t\\\n-\t\t\t\t\t   plus_constant ((ADDR), 4))), \\\n-\t\t  gen_rtx (MEM, SImode,\t\t\t\t\\\n-\t\t\t   memory_address (SImode,\t\t\\\n-\t\t\t\t\t   plus_constant ((FNADDR), 4)))); \\\n-  emit_move_insn (gen_rtx (MEM, SImode,\t\t\t\t\\\n-\t\t\t   memory_address (SImode,\t\t\\\n-\t\t\t\t\t   plus_constant ((ADDR), 8))), \\\n-\t\t  force_reg (SImode, (CXT)));\t\t\t\\\n-}\n+  rs6000_initialize_trampoline (ADDR, FNADDR, CXT)\n \f\n /* Definitions for __builtin_return_address and __builtin_frame_address.\n    __builtin_return_address (0) should give link register (65), enable\n@@ -1247,13 +1300,15 @@ typedef struct rs6000_args\n    (mrs) */\n /* #define RETURN_ADDR_IN_PREVIOUS_FRAME */\n \n-/* Number of bytes into the frame return addresses can be found.  */\n-#ifndef TARGET_V4_CALLS\n-#define RETURN_ADDRESS_OFFSET 8\n-#else\n-#define RETURN_ADDRESS_OFFSET \\\n- ((TARGET_V4_CALLS) ?  (TARGET_64BIT ? 8 : 4) : 8)\n-#endif\n+/* Number of bytes into the frame return addresses can be found.  See\n+   rs6000_stack_info in rs6000.c for more information on how the different\n+   abi's store the return address.  */\n+#define RETURN_ADDRESS_OFFSET\t\t\t\t\t\t\\\n+ ((DEFAULT_ABI == ABI_AIX\t\t\t\t\t\t\\\n+   || DEFAULT_ABI == ABI_AIX_NODESC)\t? 8 :\t\t\t\t\\\n+  (DEFAULT_ABI == ABI_V4)\t\t? (TARGET_64BIT ? 8 : 4) :\t\\\n+  (DEFAULT_ABI == ABI_NT)\t\t? -4 :\t\t\t\t\\\n+  (fatal (\"RETURN_ADDRESS_OFFSET not supported\"), 0))\n \n /* The current return address is in link register (65).  The return address\n    of anything farther back is accessed normally at an offset of 8 from the\n@@ -1638,8 +1693,13 @@ typedef struct rs6000_args\n    .stabs in cc1plus.  */\n    \n #define FASCIST_ASSEMBLER\n+\n+#ifndef ASM_OUTPUT_CONSTRUCTOR\n #define ASM_OUTPUT_CONSTRUCTOR(file, name)\n+#endif\n+#ifndef ASM_OUTPUT_DESTRUCTOR\n #define ASM_OUTPUT_DESTRUCTOR(file, name)\n+#endif\n \n /* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n    is done just by pretending it is already truncated.  */\n@@ -2106,19 +2166,17 @@ toc_section ()\t\t\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       char *_name = (NAME);\t\t\t\t\t\t\\\n+      int _len;\t\t\t\t\t\t\t\t\\\n       if (_name[0] == '*')\t\t\t\t\t\t\\\n-\t(VAR) = _name+1;\t\t\t\t\t\t\\\n+\t_name++;\t\t\t\t\t\t\t\\\n+      _len = strlen (_name);\t\t\t\t\t\t\\\n+      if (_name[_len - 1] != ']')\t\t\t\t\t\\\n+\t(VAR) = _name;\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  int _len = strlen (_name);\t\t\t\t\t\\\n-\t  if (_name[_len - 1] != ']')\t\t\t\t\t\\\n-\t    (VAR) = _name;\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      (VAR) = (char *) alloca (_len + 1);\t\t\t\\\n-\t      strcpy ((VAR), _name);\t\t\t\t\t\\\n-\t      (VAR)[_len - 4] = '\\0';\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n+\t  (VAR) = (char *) alloca (_len + 1);\t\t\t\t\\\n+\t  strcpy ((VAR), _name);\t\t\t\t\t\\\n+\t  (VAR)[_len - 4] = '\\0';\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n@@ -2468,6 +2526,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"easy_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\\\n   {\"reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\t\\\n   {\"lwa_operand\", {SUBREG, MEM, REG}},\t\t\t\t\\\n+  {\"volatile_mem_operand\", {MEM}},\t\t\t\t\\\n   {\"offsettable_addr_operand\", {REG, SUBREG, PLUS}},\t\t\\\n   {\"fp_reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\\\n   {\"mem_or_easy_const_operand\", {SUBREG, MEM, CONST_DOUBLE}},\t\\\n@@ -2478,6 +2537,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"logical_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n   {\"non_logical_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"mask_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"count_register_operand\", {REG}},\t\t\t\t\\\n   {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\\\n   {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\\\n   {\"input_operand\", {SUBREG, MEM, REG, CONST_INT, SYMBOL_REF}},\t\\\n@@ -2488,6 +2548,16 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"scc_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\\\n \t\t\t       GT, LEU, LTU, GEU, GTU}},\n \n+\n+/* uncomment for disabling the corresponding default options */\n+/* #define  MACHINE_no_sched_interblock */\n+/* #define  MACHINE_no_sched_speculative */\n+/* #define  MACHINE_no_sched_speculative_load */\n+\n+/* indicate that issue rate is defined for this machine\n+   (no need to use the default) */\n+#define MACHINE_issue_rate\n+\n /* Declare functions in rs6000.c */\n extern void output_options ();\n extern void rs6000_override_options ();\n@@ -2524,6 +2594,7 @@ extern int current_file_function_operand ();\n extern int input_operand ();\n extern void init_cumulative_args ();\n extern void function_arg_advance ();\n+extern int function_arg_boundary ();\n extern struct rtx_def *function_arg ();\n extern int function_arg_partial_nregs ();\n extern int function_arg_pass_by_reference ();\n@@ -2555,3 +2626,6 @@ extern void output_ascii ();\n extern void rs6000_gen_section_name ();\n extern void output_function_profiler ();\n extern int rs6000_adjust_cost ();\n+extern void rs6000_trampoline_template ();\n+extern int rs6000_trampoline_size ();\n+extern void rs6000_initialize_trampoline ();"}, {"sha": "3a46ecc915ea5c99362bb022808c7ca516d395f5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 458, "deletions": 149, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -40,7 +40,7 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in rs6000.h.\n \n-(define_attr \"cpu\" \"rios1,rios2,ppc403,ppc601,ppc603,ppc604,ppc620\"\n+(define_attr \"cpu\" \"rios1,rios2,ppc403,ppc601,ppc602,ppc603,ppc604,ppc620\"\n   (const (symbol_ref \"rs6000_cpu_attr\")))\n \n ; (define_function_unit NAME MULTIPLICITY SIMULTANEITY\n@@ -50,87 +50,99 @@\n ; (POWER and 601 use Integer Unit)\n (define_function_unit \"lsu\" 1 0\n   (and (eq_attr \"type\" \"load\")\n-       (eq_attr \"cpu\" \"rios2,ppc603,ppc604,ppc620\"))\n-  2 0)\n+       (eq_attr \"cpu\" \"ppc602,ppc603,ppc604,ppc620\"))\n+  2 1)\n \n (define_function_unit \"lsu\" 1 0\n   (and (eq_attr \"type\" \"fpload\")\n-       (eq_attr \"cpu\" \"rios2,ppc603,ppc604,ppc620\"))\n-  2 0)\n+       (eq_attr \"cpu\" \"ppc604,ppc620\"))\n+  3 1)\n+\n+(define_function_unit \"lsu\" 1 0\n+  (and (eq_attr \"type\" \"fpload\")\n+       (eq_attr \"cpu\" \"ppc602,ppc603\"))\n+  2 1)\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"load\")\n-       (eq_attr \"cpu\" \"rios1,ppc403,ppc601\"))\n-  2 0)\n+       (eq_attr \"cpu\" \"rios1,ppc601\"))\n+  2 1)\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"fpload\")\n        (eq_attr \"cpu\" \"rios1,ppc601\"))\n-  3 0)\n+  2 0)\n \n ; Integer Unit (RIOS1, PPC601, PPC603)\n ; Trivial operations take one cycle which need not be listed here.\n (define_function_unit \"iu\" 1 0\n-  (and (eq_attr \"type\" \"imul\")\n-       (eq_attr \"cpu\" \"rios1\"))\n-  3 3)\n+  (and (eq_attr \"type\" \"integer\")\n+       (eq_attr \"cpu\" \"rios1,ppc601\"))\n+  1 1)\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"imul\")\n-       (eq_attr \"cpu\" \"ppc403\"))\n-  4 4)\n+       (eq_attr \"cpu\" \"rios1\"))\n+  3 3)\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"imul\")\n-       (eq_attr \"cpu\" \"ppc601,ppc603\"))\n+       (eq_attr \"cpu\" \"ppc601,ppc602,ppc603\"))\n   5 5)\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"idiv\")\n        (eq_attr \"cpu\" \"rios1\"))\n   19 19)\n \n-(define_function_unit \"iu\" 1 0\n-  (and (eq_attr \"type\" \"idiv\")\n-       (eq_attr \"cpu\" \"ppc403\"))\n-  33 33)\n-\n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"idiv\")\n        (eq_attr \"cpu\" \"ppc601\"))\n   36 36)\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"idiv\")\n-       (eq_attr \"cpu\" \"ppc603\"))\n+       (eq_attr \"cpu\" \"ppc602,ppc603\"))\n   37 36)\n \n ; RIOS2 has two integer units: a primary one which can perform all\n ; operations and a secondary one which is fed in lock step with the first\n-; and can perform \"simple\" integer operations.\n+; and can perform \"simple\" integer operations.  \n+; To catch this we define a 'dummy' imuldiv-unit that is also needed\n+; for the complex insns. \n (define_function_unit \"iu2\" 2 0\n   (and (eq_attr \"type\" \"integer\")\n        (eq_attr \"cpu\" \"rios2\"))\n-  1 0\n-  [(eq_attr \"type\" \"imul,idiv\")])\n+  1 0)\n+\n+(define_function_unit \"iu2\" 2 0\n+  (and (eq_attr \"type\" \"imul\")\n+       (eq_attr \"cpu\" \"rios2\"))\n+  2 2)\n+\n+(define_function_unit \"iu2\" 2 0\n+  (and (eq_attr \"type\" \"idiv\")\n+       (eq_attr \"cpu\" \"rios2\"))\n+  13 13)\n \n (define_function_unit \"imuldiv\" 1 0\n   (and (eq_attr \"type\" \"imul\")\n        (eq_attr \"cpu\" \"rios2\"))\n-  2 2\n-  [(eq_attr \"type\" \"integer\")])\n+  2 2)\n+\n \n (define_function_unit \"imuldiv\" 1 0\n   (and (eq_attr \"type\" \"idiv\")\n        (eq_attr \"cpu\" \"rios2\"))\n-  13 13\n-  [(eq_attr \"type\" \"integer\")])\n+  13 13)\n \n-; PPC604 has three integer units: one primary and two secondary.\n-(define_function_unit \"iu3\" 3 0\n+; PPC604 has two units that perform integer operations\n+; and one unit for divide/multiply operations (and move\n+; from/to spr).\n+(define_function_unit \"iu2\" 2 0\n   (and (eq_attr \"type\" \"integer\")\n        (eq_attr \"cpu\" \"ppc604,ppc620\"))\n-  1 0\n+  1 1\n   [(eq_attr \"type\" \"imul,idiv\")])\n \n (define_function_unit \"imuldiv\" 1 0\n@@ -145,24 +157,65 @@\n   20 19\n   [(eq_attr \"type\" \"integer\")])\n \n-; Branch Processing Unit\n-(define_function_unit \"bpu\" 1 0\n-  (eq_attr \"type\" \"compare\")\n-  4 0)\n+; compare is done on integer unit, but feeds insns which\n+; execute on the branch unit.  Ready-delay of the compare \n+; on the branch unit is large (3-5 cycles).  On the iu/fpu\n+; it is 1.  One drawback is that the compare will also be \n+; assigned to the bpu, but this inaccuracy is worth for being\n+; able to fill the compare-branch delay, with insns on iu/fpu.\n+(define_function_unit \"iu\" 1 0   \n+  (and (eq_attr \"type\" \"compare\")\n+       (eq_attr \"cpu\" \"rios1,ppc601\"))\n+  1 1)\n+\n+(define_function_unit \"iu2\" 2 0   \n+  (and (eq_attr \"type\" \"compare\")\n+       (eq_attr \"cpu\" \"rios2\"))\n+  1 1)\n+\n+(define_function_unit \"bpu\" 1 0   \n+  (and (eq_attr \"type\" \"compare\")\n+       (eq_attr \"cpu\" \"rios1,rios2,ppc601\"))\n+  4 1)\n+\n+; different machines have different compare timings\n+; in ppc604, compare is done on the one of the two\n+; main integer units.\n+(define_function_unit \"iu2\" 2 0\n+  (and (eq_attr \"type\" \"compare\")\n+       (eq_attr \"cpu\" \"ppc604,ppc620\"))\n+  1 1)\n \n (define_function_unit \"bpu\" 1 0\n   (eq_attr \"type\" \"delayed_compare\")\n   5 0)\n \n-(define_function_unit \"bpu\" 1 0\n+; fp compare uses fp unit\n+(define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fpcompare\")\n-       (eq_attr \"cpu\" \"rios1,rios2\"))\n-  8 0)\n+       (eq_attr \"cpu\" \"rios1\"))\n+  8 1)\n \n-(define_function_unit \"bpu\" 1 0\n+; rios1 and rios2 have different fpcompare delays\n+(define_function_unit \"fpu2\" 2 0\n   (and (eq_attr \"type\" \"fpcompare\")\n-       (eq_attr \"cpu\" \"ppc601,ppc603,ppc604,ppc620\"))\n-  4 0)\n+       (eq_attr \"cpu\" \"rios2\"))\n+  5 1)\n+\n+; on ppc601 and ppc603, fpcompare takes also 2 cycles from\n+; the integer unit\n+; here we do not define delays, just occupy the unit. The dependencies\n+; will be signed by the fpcompare definition in the fpu.\n+(define_function_unit \"iu\" 1 0\n+  (and (eq_attr \"type\" \"fpcompare\")\n+       (eq_attr \"cpu\" \"ppc601,ppc602,ppc603\"))\n+  0 2)\n+\n+; fp compare uses fp unit\n+(define_function_unit \"fpu\" 1 0\n+  (and (eq_attr \"type\" \"fpcompare\")\n+       (eq_attr \"cpu\" \"ppc601,ppc602,ppc603,ppc604,ppc620\"))\n+  5 1)\n \n (define_function_unit \"bpu\" 1 0\n   (and (eq_attr \"type\" \"mtjmpr\")\n@@ -171,9 +224,18 @@\n \n (define_function_unit \"bpu\" 1 0\n   (and (eq_attr \"type\" \"mtjmpr\")\n-       (eq_attr \"cpu\" \"ppc403,ppc601,ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc601,ppc602,ppc603,ppc604,ppc620\"))\n   4 0)\n \n+; all jumps/branches are executing on the bpu, in 1 cycle, for all machines.\n+(define_function_unit \"bpu\" 1 0\n+  (eq_attr \"type\" \"jmpreg\")\n+  1 0)\n+\n+(define_function_unit \"bpu\" 1 0\n+  (eq_attr \"type\" \"branch\")\n+  1 0)\n+\n ; Floating Point Unit (RIOS1, PPC601, PPC603, PPC604).\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fp,dmul\")\n@@ -187,23 +249,24 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fp\")\n-       (eq_attr \"cpu\" \"ppc603,ppc604,ppc620\"))\n-  3 0)\n+       (eq_attr \"cpu\" \"ppc602,ppc603,ppc604,ppc620\"))\n+  3 1)\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"dmul\")\n        (eq_attr \"cpu\" \"ppc601\"))\n-  5 5)\n+  5 2)\n \n+; is this true?\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"dmul\")\n-       (eq_attr \"cpu\" \"ppc603\"))\n+       (eq_attr \"cpu\" \"ppc602,ppc603\"))\n   4 2)\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"dmul\")\n        (eq_attr \"cpu\" \"ppc604,ppc620\"))\n-  3 0)\n+  3 1)\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"sdiv,ddiv\")\n@@ -217,7 +280,7 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"sdiv\")\n-       (eq_attr \"cpu\" \"ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc602,ppc603,ppc604,ppc620\"))\n   18 18)\n \n (define_function_unit \"fpu\" 1 0\n@@ -227,7 +290,7 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"ddiv\")\n-       (eq_attr \"cpu\" \"ppc603\"))\n+       (eq_attr \"cpu\" \"ppc602,ppc603\"))\n   33 33)\n \n (define_function_unit \"fpu\" 1 0\n@@ -260,6 +323,7 @@\n   (and (eq_attr \"type\" \"ssqrt,dsqrt\")\n        (eq_attr \"cpu\" \"rios2\"))\n   26 26)\n+\n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n@@ -1284,12 +1348,11 @@\n   if (GET_CODE (operands[2]) == CONST_INT\n       && exact_log2 (INTVAL (operands[2])) >= 0)\n     ;\n-  else if (TARGET_POWER && ! TARGET_POWERPC)\n+  else if (TARGET_POWERPC)\n+    operands[2] = force_reg (SImode, operands[2]);\n+  else if (TARGET_POWER)\n     FAIL;\n   else\n-    operands[2] = force_reg (SImode, operands[2]);\n-\n-  if (! TARGET_POWER && ! TARGET_POWERPC)\n     {\n       emit_move_insn (gen_rtx (REG, SImode, 3), operands[1]);\n       emit_move_insn (gen_rtx (REG, SImode, 4), operands[2]);\n@@ -3898,12 +3961,61 @@\n       rtx target = (reload_completed || reload_in_progress)\n \t\t\t? operands[0] : gen_reg_rtx (SImode);\n \n+      /* If this is a function address on -mcall-aixdesc or -mcall-nt,\n+\t convert it to the address of the descriptor.  */\n+      if ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT)\n+\t  && GET_CODE (operands[1]) == SYMBOL_REF\n+\t  && XSTR (operands[1], 0)[0] == '.')\n+\t{\n+\t  char *name = XSTR (operands[1], 0);\n+\t  rtx new_ref;\n+\t  while (*name == '.')\n+\t    name++;\n+\t  new_ref = gen_rtx (SYMBOL_REF, Pmode, name);\n+\t  CONSTANT_POOL_ADDRESS_P (new_ref) = CONSTANT_POOL_ADDRESS_P (operands[1]);\n+\t  SYMBOL_REF_FLAG (new_ref) = SYMBOL_REF_FLAG (operands[1]);\n+\t  SYMBOL_REF_USED (new_ref) = SYMBOL_REF_USED (operands[1]);\n+\t  operands[1] = new_ref;\n+\t}\n+\n       emit_insn (gen_elf_high (target, operands[1]));\n       emit_insn (gen_elf_low (operands[0], target, operands[1]));\n       DONE;\n     }\n \n-  if (CONSTANT_P (operands[1])\n+  if (GET_CODE (operands[1]) == CONST\n+      && DEFAULT_ABI == ABI_NT\n+      && !side_effects_p (operands[0]))\n+    {\n+      rtx const_term = const0_rtx;\n+      rtx sym = eliminate_constant_term (XEXP (operands[1], 0), &const_term);\n+      if (sym && GET_CODE (const_term) == CONST_INT\n+\t  && (GET_CODE (sym) == SYMBOL_REF || GET_CODE (sym) == LABEL_REF))\n+\t{\n+\t  emit_insn (gen_movsi (operands[0], sym));\n+\t  if (INTVAL (const_term) != 0)\n+\t    {\n+\t      unsigned HOST_WIDE_INT value = INTVAL (const_term);\n+\t      if (value + 0x8000 < 0x10000)\n+\t\temit_insn (gen_addsi3 (operands[0], operands[0], GEN_INT (value)));\n+\t      else\n+\t\t{\n+\t\t  emit_insn (gen_addsi3 (operands[0], operands[0],\n+\t\t\t\t\t GEN_INT ((value >> 16) + ((value >> 15) & 1))));\n+\n+\t\t  if ((value & 0xffff) != 0)\n+\t\t    emit_insn (gen_addsi3 (operands[0], operands[0],\n+\t\t\t\t\t   GEN_INT (value & 0xffff)));\n+\t\t}\n+\t    }\n+\t  DONE;\n+\t}\n+      else\n+\tfatal_insn (\\\"bad address\\\", operands[1]);\n+    }\n+\n+  if ((!TARGET_WINDOWS_NT || DEFAULT_ABI != ABI_NT)\n+      && CONSTANT_P (operands[1])\n       && GET_CODE (operands[1]) != CONST_INT\n       && GET_CODE (operands[1]) != HIGH\n       && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1]))\n@@ -3949,12 +4061,14 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,r,*q,*c*l,*h\")\n-\t(match_operand:SI 1 \"input_operand\" \"r,m,r,I,J,R,*h,r,r,0\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,r,r,r,r,*q,*c*l,*h\")\n+\t(match_operand:SI 1 \"input_operand\" \"r,S,T,m,r,I,J,R,*h,r,r,0\"))]\n   \"gpc_reg_operand (operands[0], SImode)\n    || gpc_reg_operand (operands[1], SImode)\"\n   \"@\n    mr %0,%1\n+   {l|lwz} %0,[toc]%1(2)\n+   {l|lwz} %0,[toc]%l1(2)\n    {l%U1%X1|lwz%U1%X1} %0,%1\n    {st%U0%X0|stw%U0%X0} %1,%0\n    {lil|li} %0,%1\n@@ -3964,7 +4078,7 @@\n    mt%0 %1\n    mt%0 %1\n    cror 0,0,0\"\n-  [(set_attr \"type\" \"*,load,*,*,*,*,*,*,mtjmpr,*\")])\n+  [(set_attr \"type\" \"*,load,load,load,*,*,*,*,*,*,mtjmpr,*\")])\n \n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence.\n@@ -4823,10 +4937,10 @@\n ;; Argument 3 is the alignment\n \n (define_expand \"movstrsi\"\n-  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-\t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n-\t      (use (match_operand:SI 2 \"general_operand\" \"\"))\n-\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))])]\n+  [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n+\t\t   (match_operand:BLK 1 \"\" \"\"))\n+\t      (use (match_operand:SI 2 \"\" \"\"))\n+\t      (use (match_operand:SI 3 \"\" \"\"))])]\n   \"\"\n   \"\n {\n@@ -4839,10 +4953,10 @@\n ;; Move up to 32 bytes at a time.  The fixed registers are needed because the\n ;; register allocator doesn't have a clue about allocating 8 word registers\n (define_expand \"movstrsi_8reg\"\n-  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n-\t      (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n-\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (match_operand 1 \"\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))\n+\t      (use (match_operand 3 \"\" \"\"))\n \t      (clobber (reg:SI  5))\n \t      (clobber (reg:SI  6))\n \t      (clobber (reg:SI  7))\n@@ -4902,10 +5016,10 @@\n ;; Move up to 24 bytes at a time.  The fixed registers are needed because the\n ;; register allocator doesn't have a clue about allocating 6 word registers\n (define_expand \"movstrsi_6reg\"\n-  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n-\t      (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n-\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (match_operand 1 \"\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))\n+\t      (use (match_operand 3 \"\" \"\"))\n \t      (clobber (reg:SI  7))\n \t      (clobber (reg:SI  8))\n \t      (clobber (reg:SI  9))\n@@ -4959,10 +5073,10 @@\n ;; Move up to 16 bytes at a time, using 4 fixed registers to avoid spill problems\n ;; with TImode\n (define_expand \"movstrsi_4reg\"\n-  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n-\t      (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n-\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (match_operand 1 \"\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))\n+\t      (use (match_operand 3 \"\" \"\"))\n \t      (clobber (reg:SI  9))\n \t      (clobber (reg:SI 10))\n \t      (clobber (reg:SI 11))\n@@ -5009,10 +5123,10 @@\n \n ;; Move up to 8 bytes at a time.\n (define_expand \"movstrsi_2reg\"\n-  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n-\t      (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n-\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (match_operand 1 \"\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))\n+\t      (use (match_operand 3 \"\" \"\"))\n \t      (clobber (match_scratch:DI 4 \"\"))\n \t      (clobber (match_scratch:SI 5 \"\"))])]\n   \"TARGET_STRING && !TARGET_64BIT\"\n@@ -5044,10 +5158,10 @@\n \n ;; Move up to 4 bytes at a time.\n (define_expand \"movstrsi_1reg\"\n-  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n-\t      (use (match_operand:SI 2 \"immediate_operand\" \"\"))\n-\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (match_operand 1 \"\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))\n+\t      (use (match_operand 3 \"\" \"\"))\n \t      (clobber (match_scratch:SI 4 \"\"))\n \t      (clobber (match_scratch:SI 5 \"\"))])]\n   \"TARGET_STRING\"\n@@ -5395,32 +5509,132 @@\n   DONE;\n }\")\n \f\n-;; A function pointer is a pointer to a data area whose first word contains\n-;; the actual address of the function, whose second word contains a pointer\n-;; to its TOC, and whose third word contains a value to place in the static\n-;; chain register (r11).  Note that if we load the static chain, our\n+\n+;; A function pointer under AIX is a pointer to a data area whose first word\n+;; contains the actual address of the function, whose second word contains a\n+;; pointer to its TOC, and whose third word contains a value to place in the\n+;; static chain register (r11).  Note that if we load the static chain, our\n ;; \"trampoline\" need not have any executable code.\n ;;\n-;; operands[0] is an SImode pseudo in which we place the address of the\n-;; \t       function.\n-;; operands[1] is the address of data area of the function to call\n+;; operands[0] is a register pointing to the 3 word descriptor (aka, the function address)\n+;; operands[1] is the stack size to clean up\n+;; operands[2] is the value FUNCTION_ARG returns for the VOID argument (must be 0 for AIX)\n+;; operands[3] is location to store the TOC\n+;; operands[4] is the TOC register\n+;; operands[5] is the static chain register\n+;;\n+;; We do not break this into separate insns, so that the scheduler will not try\n+;; to move the load of the new TOC before any loads from the TOC.\n+\n+(define_insn \"call_indirect_aix\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"b\"))\n+\t (match_operand 1 \"const_int_operand\" \"n\"))\n+   (use (match_operand 2 \"const_int_operand\" \"O\"))\n+   (use (match_operand 3 \"offsettable_addr_operand\" \"p\"))\n+   (use (match_operand 4 \"register_operand\" \"r\"))\n+   (clobber (match_operand 5 \"register_operand\" \"=r\"))\n+   (clobber (match_scratch:SI 6 \"=&r\"))\n+   (clobber (match_scratch:SI 7 \"=l\"))]\n+  \"DEFAULT_ABI == ABI_AIX\"\n+  \"{st|stw} %4,%a3\\;{l|lwz} %6,0(%0)\\;{l|lwz} %4,4(%0);\\;mt%7 %6\\;{l|lwz} %5,8(%0)\\;{brl|blrl}\\;{l|lwz} %4,%a3\"\n+  [(set_attr \"length\" \"28\")])\n+\n+(define_insn \"call_value_indirect_aix\"\n+  [(set (match_operand 0 \"register_operand\" \"fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"b\"))\n+\t      (match_operand 2 \"const_int_operand\" \"n\")))\n+   (use (match_operand 3 \"const_int_operand\" \"O\"))\n+   (use (match_operand 4 \"offsettable_addr_operand\" \"p\"))\n+   (use (match_operand 5 \"register_operand\" \"r\"))\n+   (clobber (match_operand 6 \"register_operand\" \"=r\"))\n+   (clobber (match_scratch:SI 7 \"=&r\"))\n+   (clobber (match_scratch:SI 8 \"=l\"))]\n+  \"DEFAULT_ABI == ABI_AIX\"\n+  \"{st|stw} %5,%a4\\;{l|lwz} %7,0(%1)\\;{l|lwz} %5,4(%1);\\;mt%8 %7\\;{l|lwz} %6,8(%1)\\;{brl|blrl}\\;{l|lwz} %5,%a4\"\n+  [(set_attr \"length\" \"28\")])\n+\n+;; A function pointer undef NT is a pointer to a data area whose first word\n+;; contains the actual address of the function, whose second word contains a\n+;; pointer to its TOC.  The static chain is not stored under NT, which means\n+;; that we need a trampoline.\n+;;\n+;; operands[0] is an SImode pseudo in which we place the address of the function.\n+;; operands[1] is the stack size to clean up\n+;; operands[2] is the value FUNCTION_ARG returns for the VOID argument (must be 0 for NT)\n+;; operands[3] is location to store the TOC\n+;; operands[4] is the TOC register\n+;;\n+;; We do not break this into separate insns, so that the scheduler will not try\n+;; to move the load of the new TOC before any loads from the TOC.\n+\n+(define_insn \"call_indirect_nt\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"b\"))\n+\t (match_operand 1 \"const_int_operand\" \"n\"))\n+   (use (match_operand 2 \"const_int_operand\" \"O\"))\n+   (use (match_operand 3 \"offsettable_addr_operand\" \"p\"))\n+   (use (match_operand 4 \"register_operand\" \"r\"))\n+   (clobber (match_scratch:SI 5 \"=&r\"))\n+   (clobber (match_scratch:SI 6 \"=l\"))]\n+  \"DEFAULT_ABI == ABI_NT\"\n+  \"{st|stw} %4,%a3\\;{l|lwz} %6,0(%0)\\;{l|lwz} %4,4(%0);\\;mt%6 %5\\;{brl|blrl}\\;{l|lwz} %4,%a3\"\n+  [(set_attr \"length\" \"24\")])\n+\n+(define_insn \"call_value_indirect_nt\"\n+  [(set (match_operand 0 \"register_operand\" \"fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"b\"))\n+\t      (match_operand 2 \"const_int_operand\" \"n\")))\n+   (use (match_operand 3 \"const_int_operand\" \"O\"))\n+   (use (match_operand 4 \"offsettable_addr_operand\" \"p\"))\n+   (use (match_operand 5 \"register_operand\" \"r\"))\n+   (clobber (match_scratch:SI 6 \"=&r\"))\n+   (clobber (match_scratch:SI 7 \"=l\"))]\n+  \"DEFAULT_ABI == ABI_NT\"\n+  \"{st|stw} %5,%a4\\;{l|lwz} %6,0(%1)\\;{l|lwz} %5,4(%1);\\;mt%7 %6\\;{brl|blrl}\\;{l|lwz} %5,%a4\"\n+  [(set_attr \"length\" \"24\")])\n+\n+;; A function pointer under System V is just a normal pointer\n+;; operands[0] is the function pointer\n+;; operands[1] is the stack size to clean up\n+;; operands[2] is the value FUNCTION_ARG returns for the VOID argument which indicates how to set cr1\n+\n+(define_insn \"call_indirect_sysv\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l,l\"))\n+\t (match_operand 1 \"const_int_operand\" \"n,n\"))\n+   (use (match_operand 2 \"const_int_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 3 \"=l,l\"))]\n+  \"DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_AIX_NODESC\"\n+  \"*\n+{\n+  if (INTVAL (operands[2]) > 0)\n+    return \\\"creqv 6,6,6\\;{brl|blrl}\\\";\n \n-(define_expand \"call_via_ptr\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n-   (set (mem:SI (plus:SI (reg:SI 1) (const_int 20)))\n-\t(reg:SI 2))\n-   (set (reg:SI 2)\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (const_int 4))))\n-   (set (reg:SI 11)\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (const_int 8))))\n-   (use (reg:SI 2))\n-   (use (reg:SI 11))]\n-  \"\"\n-  \"\")\n+  else if (INTVAL (operands[2]) < 0)\n+    return \\\"crxor 6,6,6\\;{brl|blrl}\\\";\n+\n+  return \\\"{brl|blrl}\\\";\n+}\"\n+  [(set_attr \"length\" \"4,8\")])\n+\n+(define_insn \"call_value_indirect_sysv\"\n+  [(set (match_operand 0 \"register_operand\" \"=fg,fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l,l\"))\n+\t      (match_operand 2 \"const_int_operand\" \"n,n\")))\n+   (use (match_operand 3 \"const_int_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 4 \"=l,l\"))]\n+  \"DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_AIX_NODESC\"\n+  \"*\n+{\n+  if (INTVAL (operands[3]) > 0)\n+    return \\\"creqv 6,6,6\\;{brl|blrl}\\\";\n+\n+  else if (INTVAL (operands[3]) < 0)\n+    return \\\"crxor 6,6,6\\;{brl|blrl}\\\";\n+\n+  return \\\"{brl|blrl}\\\";\n+}\"\n+  [(set_attr \"length\" \"4,8\")])\n \n+;; Now the definitions for the call and call_value insns\n (define_expand \"call\"\n   [(parallel [(call (mem:SI (match_operand:SI 0 \"address_operand\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n@@ -5435,13 +5649,33 @@\n   operands[0] = XEXP (operands[0], 0);\n   if (GET_CODE (operands[0]) != SYMBOL_REF)\n     {\n-#ifndef USING_SVR4_H\n-      /* AIX function pointers are really pointers to a three word area */\n-      rtx temp = gen_reg_rtx (SImode);\n+      if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_AIX_NODESC)\n+\temit_call_insn (gen_call_indirect_sysv (force_reg (Pmode, operands[0]),\n+\t\t\t\t\t\toperands[1], operands[2]));\n+      else\n+\t{\n+\t  rtx toc_reg = gen_rtx (REG, Pmode, 2);\n+\t  rtx toc_addr = RS6000_SAVE_TOC;\n \n-      emit_insn (gen_call_via_ptr (temp, force_reg (SImode, operands[0])));\n-      operands[0] = temp;\n-#endif\t/* !USING_SVR4_H */\n+\t  if (DEFAULT_ABI == ABI_AIX)\n+\t    {\n+\t      /* AIX function pointers are really pointers to a three word area */\n+\t      rtx static_chain = gen_rtx (REG, Pmode, STATIC_CHAIN_REGNUM);\n+\t      emit_call_insn (gen_call_indirect_aix (force_reg (Pmode, operands[0]),\n+\t\t\t\t\t\t     operands[1], operands[2],\n+\t\t\t\t\t\t     toc_addr, toc_reg, static_chain));\n+\t    }\n+\t  else if (DEFAULT_ABI == ABI_NT)\n+\t    {\n+\t      /* NT function pointers are really pointers to a two word area */\n+\t      emit_call_insn (gen_call_indirect_nt (force_reg (Pmode, operands[0]),\n+\t\t\t\t\t\t    operands[1], operands[2],\n+\t\t\t\t\t\t    toc_addr, toc_reg));\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+      DONE;\n     }\n }\")\n \n@@ -5460,13 +5694,35 @@\n   operands[1] = XEXP (operands[1], 0);\n   if (GET_CODE (operands[1]) != SYMBOL_REF)\n     {\n-#ifndef USING_SVR4_H\n-      /* AIX function pointers are really pointers to a three word area */\n-      rtx temp = gen_reg_rtx (SImode);\n+      if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_AIX_NODESC)\n+\temit_call_insn (gen_call_value_indirect_sysv (operands[0], operands[1],\n+\t\t\t\t\t\t      operands[2], operands[3]));\n+      else\n+\t{\n+\t  rtx toc_reg = gen_rtx (REG, Pmode, 2);\n+\t  rtx toc_addr = RS6000_SAVE_TOC;\n \n-      emit_insn (gen_call_via_ptr (temp, force_reg (SImode, operands[1])));\n-      operands[1] = temp;\n-#endif\t/* !USING_SVR4_H */\n+\t  if (DEFAULT_ABI == ABI_AIX)\n+\t    {\n+\t      /* AIX function pointers are really pointers to a three word area */\n+\t      rtx static_chain = gen_rtx (REG, Pmode, STATIC_CHAIN_REGNUM);\n+\t      emit_call_insn (gen_call_value_indirect_aix (operands[0],\n+\t\t\t\t\t\t\t   force_reg (Pmode, operands[1]),\n+\t\t\t\t\t\t\t   operands[2], operands[3],\n+\t\t\t\t\t\t\t   toc_addr, toc_reg, static_chain));\n+\t    }\n+\t  else if (DEFAULT_ABI == ABI_NT)\n+\t    {\n+\t      /* NT function pointers are really pointers to a two word area */\n+\t      emit_call_insn (gen_call_value_indirect_nt (operands[0],\n+\t\t\t\t\t\t\t  force_reg (Pmode, operands[1]),\n+\t\t\t\t\t\t\t  operands[2], operands[3],\n+\t\t\t\t\t\t\t  toc_addr, toc_reg));\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+      DONE;\n     }\n }\")\n \n@@ -5502,11 +5758,11 @@\n ;; and < 0 if they were not.\n \n (define_insn \"\"\n-  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"l,s,l,s\"))\n-\t (match_operand 1 \"\" \"fg,fg,fg,fg\"))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"O,O,n,n\"))\n-   (clobber (match_scratch:SI 3 \"=l,l,l,l\"))]\n-  \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"s,s\"))\n+\t (match_operand 1 \"\" \"fg,fg\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 3 \"=l,l\"))]\n+  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT\"\n   \"*\n {\n   if (INTVAL (operands[2]) > 0)\n@@ -5515,20 +5771,35 @@\n   else if (INTVAL (operands[2]) < 0)\n     output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n \n-#ifndef USING_SVR4_H\n+  /* Indirect calls should go through call_indirect */\n   if (GET_CODE (operands[0]) == REG)\n-    return \\\"{brl|blrl}\\;{l|lwz} 2,20(1)\\\";\n+    abort ();\n \n-  return \\\"bl %z0\\;%.\\\";\n+  return (TARGET_WINDOWS_NT) ? \\\"bl %z0\\;.znop %z0\\\" : \\\"bl %z0\\;%.\\\";\n+}\"\n+  [(set_attr \"length\" \"8,12\")])\n \n-#else\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"s,s\"))\n+\t (match_operand 1 \"\" \"fg,fg\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 3 \"=l,l\"))]\n+  \"DEFAULT_ABI == ABI_AIX_NODESC || DEFAULT_ABI == ABI_V4\"\n+  \"*\n+{\n+  if (INTVAL (operands[2]) > 0)\n+    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+\n+  else if (INTVAL (operands[2]) < 0)\n+    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+\n+  /* Indirect calls should go through call_indirect */\n   if (GET_CODE (operands[0]) == REG)\n-    return \\\"{brl|blrl}\\\";\n+    abort ();\n \n   return \\\"bl %z0\\\";\n-#endif\n }\"\n-  [(set_attr \"length\" \"8,8,12,12\")])\n+  [(set_attr \"length\" \"4,8\")])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"\" \"=fg,fg\")\n@@ -5550,12 +5821,12 @@\n   [(set_attr \"length\" \"4,8\")])\n \n (define_insn \"\"\n-  [(set (match_operand 0 \"\" \"=fg,fg,fg,fg\")\n-\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"l,s,l,s\"))\n-\t      (match_operand 2 \"\" \"fg,fg,fg,fg\")))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O,O,n,n\"))\n-   (clobber (match_scratch:SI 4 \"=l,l,l,l\"))]\n-  \"\"\n+  [(set (match_operand 0 \"\" \"=fg,fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"s,s\"))\n+\t      (match_operand 2 \"\" \"fg,fg\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 4 \"=l,l\"))]\n+  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT\"\n   \"*\n {\n   if (INTVAL (operands[3]) > 0)\n@@ -5564,20 +5835,37 @@\n   else if (INTVAL (operands[3]) < 0)\n     output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n \n-#ifndef USING_SVR4_H\n+  /* This should be handled by call_value_indirect */\n   if (GET_CODE (operands[1]) == REG)\n-    return \\\"{brl|blrl}\\;{l|lwz} 2,20(1)\\\";\n+    abort ();\n+\n+  return (TARGET_WINDOWS_NT) ? \\\"bl %z1\\;.znop %z1\\\" : \\\"bl %z1\\;%.\\\";\n+}\"\n+  [(set_attr \"length\" \"8,12\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"\" \"=fg,fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"s,s\"))\n+\t      (match_operand 2 \"\" \"fg,fg\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n+   (clobber (match_scratch:SI 4 \"=l,l\"))]\n+  \"DEFAULT_ABI == ABI_AIX_NODESC || DEFAULT_ABI == ABI_V4\"\n+  \"*\n+{\n+  if (INTVAL (operands[3]) > 0)\n+    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n \n-  return \\\"bl %z1\\;%.\\\";\n+  else if (INTVAL (operands[3]) < 0)\n+    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n \n-#else\n+  /* This should be handled by call_value_indirect */\n   if (GET_CODE (operands[1]) == REG)\n-    return \\\"{brl|blrl}\\\";\n+    abort ();\n \n   return \\\"bl %z1\\\";\n-#endif\n }\"\n-  [(set_attr \"length\" \"8,8,12,12\")])\n+  [(set_attr \"length\" \"4,8\")])\n+\n \n ;; Call subroutine returning any type.\n \n@@ -5616,12 +5904,32 @@\n   \"\"\n   \"\")\n \n-;; Synchronize instruction/data caches for V.4 trampolines\n-(define_insn \"sync_isync\"\n-  [(unspec [(match_operand 0 \"memory_operand\" \"=m\")] 1)]\n+;; Synchronize instructions/data caches for V.4 trampolines\n+;; The extra memory_operand is to prevent the optimizer from\n+;; deleting insns with \"no\" effect.\n+(define_insn \"icbi\"\n+  [(unspec [(match_operand 0 \"memory_operand\" \"=m\")\n+\t    (match_operand 1 \"register_operand\" \"b\")\n+\t    (match_operand 2 \"register_operand\" \"r\")] 3)]\n+  \"TARGET_POWERPC\"\n+  \"icbi %1,%2\")\n+\n+(define_insn \"dcbst\"\n+  [(unspec [(match_operand 0 \"memory_operand\" \"=m\")\n+\t    (match_operand 1 \"register_operand\" \"b\")\n+\t    (match_operand 2 \"register_operand\" \"r\")] 4)]\n+  \"TARGET_POWERPC\"\n+  \"dcbst %1,%2\")\n+\n+(define_insn \"sync\"\n+  [(unspec [(match_operand 0 \"memory_operand\" \"=m\")] 5)]\n   \"\"\n-  \"{dcs|sync}\\;{ics|isync}\"\n-  [(set_attr \"length\" \"8\")])\n+  \"{dcs|sync}\")\n+\n+(define_insn \"isync\"\n+  [(unspec [(match_operand 0 \"memory_operand\" \"=m\")] 6)]\n+  \"\"\n+  \"{ics|isync}\")\n \n \f\n ;; Compare insns are next.  Note that the RS/6000 has two types of compares,\n@@ -7285,14 +7593,14 @@\n ;; Define the subtract-one-and-jump insns, starting with the template\n ;; so loop.c knows what to generate.\n \n-(define_expand \"decrement_and_branchsi\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (plus:SI (match_dup 0)\n-\t\t\t    (const_int -1)))\n-\t      (set (pc) (if_then_else (ne (match_dup 0)\n+(define_expand \"decrement_and_branch_on_count\"\n+  [(parallel [(set (pc) (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"\")\n \t\t\t\t\t  (const_int 1))\n \t\t\t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t\t\t      (pc)))\n+\t      (set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (const_int -1)))\n \t      (clobber (match_scratch:CC 2 \"\"))\n \t      (clobber (match_scratch:SI 3 \"\"))])]\n   \"\"\n@@ -7503,3 +7811,4 @@\n   \"\n { operands[7] = gen_rtx (GET_CODE (operands[2]), VOIDmode, operands[3],\n \t\t\t const0_rtx); }\")\n+"}, {"sha": "d7e8af0acbff8dac81b1a51b2a2fc84077ee21d2", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 274, "deletions": 133, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -25,30 +25,38 @@ Boston, MA 02111-1307, USA.  */\n #define\tMASK_NO_BITFIELD_TYPE\t0x40000000\t/* Set PCC_BITFIELD_TYPE_MATTERS to 0 */\n #define\tMASK_STRICT_ALIGN\t0x20000000\t/* Set STRICT_ALIGNMENT to 1.  */\n #define MASK_RELOCATABLE\t0x10000000\t/* GOT pointers are PC relative */\n-#define\tMASK_NO_TRACEBACK\t0x08000000\t/* eliminate traceback words */\n+#define\tMASK_UNUSED\t\t0x08000000\t/* UNUSED, was no-traceback */\n #define MASK_LITTLE_ENDIAN\t0x04000000\t/* target is little endian */\n-#define MASK_AIX_CALLS\t\t0x02000000\t/* Use AIX calling sequence */\n+#define MASK_CALLS_1\t\t0x02000000\t/* First ABI bit (AIX, AIXDESC) */\n #define MASK_PROTOTYPE\t\t0x01000000\t/* Only prototyped fcns pass variable args */\n+#define\tMASK_CALLS_2\t\t0x00800000\t/* Second ABI bit (NT) */\n+\n+#define\tMASK_CALLS\t\t(MASK_CALLS_1 | MASK_CALLS_2)\n+#define\tMASK_CALLS_V4\t\t0\n+#define\tMASK_CALLS_AIX\t\tMASK_CALLS_1\n+#define\tMASK_CALLS_NT\t\tMASK_CALLS_2\n+#define\tMASK_CALLS_AIXDESC\tMASK_CALLS\n \n #define\tTARGET_NO_BITFIELD_TYPE\t(target_flags & MASK_NO_BITFIELD_TYPE)\n #define TARGET_STRICT_ALIGN\t(target_flags & MASK_STRICT_ALIGN)\n #define TARGET_RELOCATABLE\t(target_flags & MASK_RELOCATABLE)\n-#define TARGET_NO_TRACEBACK\t(target_flags & MASK_NO_TRACEBACK)\n #define TARGET_LITTLE_ENDIAN\t(target_flags & MASK_LITTLE_ENDIAN)\n-#define TARGET_AIX_CALLS\t(target_flags & MASK_AIX_CALLS)\n #define\tTARGET_PROTOTYPE\t(target_flags & MASK_PROTOTYPE)\n-#define\tTARGET_TOC\t\t(target_flags & (MASK_64BIT\t\t\\\n+#define\tTARGET_TOC\t\t((target_flags & (MASK_64BIT\t\t\\\n \t\t\t\t\t\t | MASK_RELOCATABLE\t\\\n-\t\t\t\t\t\t | MASK_MINIMAL_TOC))\n+\t\t\t\t\t\t | MASK_MINIMAL_TOC))\t\\\n+\t\t\t\t || DEFAULT_ABI == ABI_AIX\t\t\\\n+\t\t\t\t || DEFAULT_ABI == ABI_NT)\n \n #define\tTARGET_BITFIELD_TYPE\t(! TARGET_NO_BITFIELD_TYPE)\n-#define\tTARGET_TRACEBACK\t(! TARGET_NO_TRACEBACK)\n #define TARGET_BIG_ENDIAN\t(! TARGET_LITTLE_ENDIAN)\n-#define TARGET_NO_AIX_CALLS\t(! TARGET_AIX_CALLS)\n #define\tTARGET_NO_PROTOTYPE\t(! TARGET_PROTOTYPE)\n #define\tTARGET_NO_TOC\t\t(! TARGET_TOC)\n \n-#define TARGET_V4_CALLS\t\tTARGET_NO_AIX_CALLS\n+#define TARGET_AIX_CALLS\t(target_flags & MASK_CALLS_1)\t/* either -mcall-aix or -mcall-aixdesc */\n+#define TARGET_V4_CALLS\t\t((target_flags & MASK_CALLS) == MASK_CALLS_V4)\n+#define TARGET_NT_CALLS\t\t((target_flags & MASK_CALLS) == MASK_CALLS_NT)\n+#define TARGET_AIXDESC_CALLS\t((target_flags & MASK_CALLS) == MASK_CALLS_AIXDESC)\n \n /* Pseudo target to indicate whether the object format is ELF\n    (to get around not having conditional compilation in the md file)  */\n@@ -64,19 +72,28 @@ Boston, MA 02111-1307, USA.  */\n   { \"no-strict-align\",\t-MASK_STRICT_ALIGN },\t\t\t\t\\\n   { \"relocatable\",\t MASK_RELOCATABLE | MASK_MINIMAL_TOC | MASK_NO_FP_IN_TOC }, \\\n   { \"no-relocatable\",\t-MASK_RELOCATABLE },\t\t\t\t\\\n-  { \"traceback\",\t-MASK_NO_TRACEBACK },\t\t\t\t\\\n-  { \"no-traceback\",\t MASK_NO_TRACEBACK },\t\t\t\t\\\n+  { \"relocatable-lib\",\t MASK_RELOCATABLE | MASK_MINIMAL_TOC | MASK_NO_FP_IN_TOC }, \\\n+  { \"no-relocatable-lib\", -MASK_RELOCATABLE },\t\t\t\t\\\n   { \"little-endian\",\t MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"little\",\t\t MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"big-endian\",\t-MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"big\",\t\t-MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"no-toc\",\t\t 0 },\t\t\t\t\t\t\\\n   { \"toc\",\t\t MASK_MINIMAL_TOC },\t\t\t\t\\\n   { \"full-toc\",\t\t MASK_MINIMAL_TOC },\t\t\t\t\\\n-  { \"call-aix\",\t\t MASK_AIX_CALLS },\t\t\t\t\\\n-  { \"call-sysv\",\t-MASK_AIX_CALLS },\t\t\t\t\\\n+  { \"call-aix\",\t\t MASK_CALLS_AIX },\t\t\t\t\\\n+  { \"call-aix\",\t\t-MASK_CALLS_NT },\t\t\t\t\\\n+  { \"call-aixdesc\",\t MASK_CALLS_AIXDESC },\t\t\t\t\\\n+  { \"call-aixdesc\",\t-MASK_LITTLE_ENDIAN },\t\t\t\t\\\n+  { \"call-sysv\",\t-MASK_CALLS },\t\t\t\t\t\\\n+  { \"call-nt\",\t\t MASK_CALLS_NT | MASK_LITTLE_ENDIAN },\t\t\\\n+  { \"call-nt\",\t\t-MASK_CALLS_AIX },\t\t\t\t\\\n   { \"prototype\",\t MASK_PROTOTYPE },\t\t\t\t\\\n-  { \"no-prototype\",\t-MASK_PROTOTYPE },\n+  { \"no-prototype\",\t-MASK_PROTOTYPE },\t\t\t\t\\\n+  { \"no-traceback\",\t 0 },\t\t\t\t\t\t\\\n+  { \"sim\",\t\t 0 },\t\t\t\t\t\t\\\n+  { \"mvme\",\t\t 0 },\t\t\t\t\t\t\\\n+  { \"emb\",\t\t 0 },\t\t\t\t\t\t\\\n \n /* Sometimes certain combinations of command options do not make sense\n    on a particular target machine.  You can define a macro\n@@ -94,8 +111,40 @@ do {\t\t\t\t\t\t\t\t\t\\\n       target_flags |= MASK_MINIMAL_TOC;\t\t\t\t\t\\\n       error (\"-mrelocatable and -mno-minimal-toc are incompatible.\");\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_RELOCATABLE && TARGET_AIXDESC_CALLS)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      target_flags &= ~MASK_RELOCATABLE;\t\t\t\t\\\n+      error (\"-mrelocatable and -mcall-aixdesc are incompatible.\");\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_RELOCATABLE && TARGET_NT_CALLS)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      target_flags &= ~MASK_MINIMAL_TOC;\t\t\t\t\\\n+      error (\"-mrelocatable and -mcall-nt are incompatible.\");\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_AIXDESC_CALLS && TARGET_LITTLE_ENDIAN)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      target_flags &= ~MASK_LITTLE_ENDIAN;\t\t\t\t\\\n+      error (\"-mcall-aixdesc must be big endian\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_NT_CALLS && TARGET_BIG_ENDIAN)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      target_flags |= MASK_LITTLE_ENDIAN;\t\t\t\t\\\n+      error (\"-mcall-nt must be little endian\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  rs6000_current_abi = ((TARGET_AIXDESC_CALLS) ? ABI_AIX :\t\t\\\n+\t\t\t(TARGET_NT_CALLS)      ? ABI_NT :\t\t\\\n+\t\t\t(TARGET_AIX_CALLS)     ? ABI_AIX_NODESC :\t\\\n+\t\t\t\t\t\t ABI_V4);\t\t\\\n } while (0)\n \n+/* Default ABI to compile code for */\n+#define DEFAULT_ABI rs6000_current_abi\n+\n #include \"rs6000/powerpc.h\"\n \n /* System V.4 uses register 13 as a pointer to the small data area,\n@@ -152,12 +201,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #undef OBJECT_FORMAT_COFF\n \n-/* The XCOFF support uses weird symbol suffixes, which we don't want\n-   for ELF.  */\n-\n-#undef RS6000_OUTPUT_BASENAME\n-#define RS6000_OUTPUT_BASENAME(FILE, NAME) assemble_name (FILE, NAME)\n-\n /* Don't bother to output .extern pseudo-ops.  They are not needed by\n    ELF assemblers.  */\n \n@@ -237,12 +280,39 @@ toc_section ()\t\t\t\t\t\t\t\t\\\n   if (in_section != in_toc)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       in_section = in_toc;\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP);\t\\\n-      if (! toc_initialized)\t\t\t\t\t\t\\\n+      if ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT)\t\t\\\n+\t  && TARGET_MINIMAL_TOC\t\t\t\t\t\t\\\n+\t  && !TARGET_RELOCATABLE)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (! toc_initialized)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      toc_initialized = 1;\t\t\t\t\t\\\n+\t      fprintf (asm_out_file, \"%s\\n\", TOC_SECTION_ASM_OP);\t\\\n+\t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LCTOC\", 0);\t\\\n+\t      fprintf (asm_out_file, \"\\t.tc \");\t\t\t\t\\\n+\t      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, \"LCTOC1[TC],\"); \\\n+\t      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, \"LCTOC1\"); \\\n+\t      fprintf (asm_out_file, \"\\n\");\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t      fprintf (asm_out_file, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP); \\\n+\t      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, \"LCTOC1\"); \\\n+\t      fprintf (asm_out_file, \" = .+32768\\n\");\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    fprintf (asm_out_file, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP);\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT)\t\\\n+\t       && !TARGET_RELOCATABLE)\t\t\t\t\t\\\n+\tfprintf (asm_out_file, \"%s\\n\", TOC_SECTION_ASM_OP);\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, \"LCTOC1\");\t\\\n-\t  fprintf (asm_out_file, \" = .+32768\\n\");\t\t\t\\\n-\t  toc_initialized = 1;\t\t\t\t\t\t\\\n+\t  fprintf (asm_out_file, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP);\t\\\n+\t  if (! toc_initialized)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, \"LCTOC1\"); \\\n+\t      fprintf (asm_out_file, \" = .+32768\\n\");\t\t\t\\\n+\t      toc_initialized = 1;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n@@ -260,6 +330,30 @@ toc_section ()\t\t\t\t\t\t\t\t\\\n     const_section ();\t\t\t\t\\\n }\n \n+/* Return non-zero if this entry is to be written into the constant pool\n+   in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF or a CONST\n+   containing one of them.  If -mfp-in-toc (the default), we also do\n+   this for floating-point constants.  We actually can only do this\n+   if the FP formats of the target and host machines are the same, but\n+   we can't check that since not every file that uses\n+   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.\n+\n+   Unlike AIX, we don't key off of -mmininal-toc, but instead do not\n+   allow floating point constants in the TOC if -mrelocatable.  */\n+\n+#undef\tASM_OUTPUT_SPECIAL_POOL_ENTRY_P\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X)\t\t\t\t\\\n+  (TARGET_TOC\t\t\t\t\t\t\t\t\\\n+   && (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n+       || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n+\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n+       || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n+       || (!TARGET_NO_FP_IN_TOC\t\t\t\t\t\t\\\n+\t   && !TARGET_RELOCATABLE\t\t\t\t\t\\\n+\t   && GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\\n+\t   && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+\t   && BITS_PER_WORD == HOST_BITS_PER_INT)))\n+\n /* These macros generate the special .type and .size directives which\n    are used to set the corresponding fields of the linker symbol table\n    entries in an ELF object file under SVR4.  These macros also output\n@@ -269,37 +363,53 @@ toc_section ()\t\t\t\t\t\t\t\t\\\n    Some svr4 assemblers need to also have something extra said about the\n    function's return value.  We allow for that here.  */\n \n-extern void svr4_traceback ();\n extern int rs6000_pic_labelno;\n \n #undef\tASM_DECLARE_FUNCTION_NAME\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n+    char *orig_name;\t\t\t\t\t\t\t\\\n+    char *init_ptr = (TARGET_64BIT) ? \".quad\" : \".long\";\t\t\\\n+    STRIP_NAME_ENCODING (orig_name, NAME);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n     if (TARGET_RELOCATABLE && get_pool_size () != 0)\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tchar buf[256];\t\t\t\t\t\t\t\\\n+\tchar buf[256], *buf_ptr;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \tASM_OUTPUT_INTERNAL_LABEL (FILE, \"LCL\", rs6000_pic_labelno);\t\\\n \t\t\t\t\t\t\t\t\t\\\n \tASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 1);\t\t\t\\\n-\tfprintf (FILE, (TARGET_POWERPC64) ? \"\\t.quad \" : \"\\t.long \");\t\\\n-\tassemble_name (FILE, buf);\t\t\t\t\t\\\n-\tputc ('-', FILE);\t\t\t\t\t\t\\\n+\tSTRIP_NAME_ENCODING (buf_ptr, buf);\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s %s-\", init_ptr, buf_ptr);\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \tASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\t\\\n-\tassemble_name (FILE, buf);\t\t\t\t\t\\\n-\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"%s\\n\", buf_ptr);\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n-    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t %s,\", TYPE_ASM_OP, orig_name);\t\t\\\n     fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n     putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n-    if (TARGET_TRACEBACK)\t\t\t\t\t\t\\\n-      svr4_traceback (FILE, NAME, DECL);\t\t\t\t\\\n     ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n-    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT)\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tchar *desc_name = orig_name;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\twhile (*desc_name == '.')\t\t\t\t\t\\\n+\t  desc_name++;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (TREE_PUBLIC (DECL))\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t.globl %s\\n\", desc_name);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP);\t\t\\\n+\tfprintf (FILE, \"%s:\\n\", desc_name);\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s %s\\n\", init_ptr, orig_name);\t\t\\\n+\tfprintf (FILE, \"\\t%s _GLOBAL_OFFSET_TABLE_\\n\", init_ptr);\t\\\n+\tif (DEFAULT_ABI == ABI_AIX)\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t%s 0\\n\", init_ptr);\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.previous\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s:\\n\", orig_name);\t\t\t\t\t\\\n   } while (0)\n \n /* How to renumber registers for dbx and gdb.  */\n@@ -315,11 +425,30 @@ extern int rs6000_pic_labelno;\n /* Pass -mppc to the assembler, since that is what powerpc.h currently\n    implies.  */\n #undef ASM_SPEC\n-#define ASM_SPEC \\\n-  \"-u \\\n-%{mcpu=601: -m601} %{!mcpu=601: -mppc} \\\n+#define ASM_SPEC \"\\\n+-u \\\n+%{!mcpu*: \\\n+  %{mpower2: -mpwrx} \\\n+  %{mpowerpc*: %{!mpower: -mppc}} \\\n+  %{mno-powerpc: %{!mpower: %{!mpower2: -mcom}}} \\\n+  %{mno-powerpc: %{mpower: %{!mpower2: -mpwr}}} \\\n+  %{!mno-powerpc: %{mpower: -m601}} \\\n+  %{!mno-powerpc: %{!mpower: -mppc}}} \\\n+%{mcpu=common: -mcom} \\\n+%{mcpu=power: -mpwr} \\\n+%{mcpu=powerpc: -mppc} \\\n+%{mcpu=rios: -mpwr} \\\n+%{mcpu=rios1: -mpwr} \\\n+%{mcpu=rios2: -mpwrx} \\\n+%{mcpu=rsc: -mpwr} \\\n+%{mcpu=rsc1: -mpwr} \\\n+%{mcpu=403: -mppc} \\\n+%{mcpu=601: -m601} \\\n+%{mcpu=603: -mppc} \\\n+%{mcpu=603e: -mppc} \\\n+%{mcpu=604: -mppc} \\\n %{V} %{v:%{!V:-V}} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*} \\\n-%{mrelocatable} \\\n+%{mrelocatable} %{mrelocatable-lib} %{memb} \\\n %{mlittle} %{mlittle-endian} %{mbig} %{mbig-endian}\"\n \n /* Output .file and comments listing what options there are */\n@@ -330,38 +459,104 @@ do {\t\t\t\t\t\t\t\t\t\\\n   output_file_directive ((FILE), main_input_filename);\t\t\t\\\n } while (0)\n \n+\n+/* This is how to output an assembler line defining an `int' constant.\n+   For -mrelocatable, we mark all addresses that need to be fixed up\n+   in the .fixup section.  */\n+#undef\tASM_OUTPUT_INT\n+#define ASM_OUTPUT_INT(FILE,VALUE)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  static int recurse = 0;\t\t\t\t\t\t\\\n+  if (TARGET_RELOCATABLE\t\t\t\t\t\t\\\n+      && in_section != in_toc\t\t\t\t\t\t\\\n+      && in_section != in_text\t\t\t\t\t\t\\\n+      && in_section != in_ctors\t\t\t\t\t\t\\\n+      && in_section != in_dtors\t\t\t\t\t\t\\\n+      && !recurse\t\t\t\t\t\t\t\\\n+      && GET_CODE (VALUE) != CONST_INT\t\t\t\t\t\\\n+      && GET_CODE (VALUE) != CONST_DOUBLE\t\t\t\t\\\n+      && CONSTANT_P (VALUE))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static int labelno = 0;\t\t\t\t\t\t\\\n+      char buf[256], *p;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      recurse = 1;\t\t\t\t\t\t\t\\\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LCP\", labelno++);\t\t\\\n+      STRIP_NAME_ENCODING (p, buf);\t\t\t\t\t\\\n+      fprintf (FILE, \"%s:\\n\", p);\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.long (\");\t\t\t\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\t\t\t\\\n+      fprintf (FILE, \")@fixup\\n\");\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.section\\t\\\".fixup\\\",\\\"aw\\\"\\n\");\t\t\\\n+      ASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.long\\t%s\\n\", p);\t\t\t\t\\\n+      fprintf (FILE, \"\\t.previous\\n\");\t\t\t\t\t\\\n+      recurse = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  /* Remove initial .'s to turn a -mcall-aixdesc or -mcall-nt function\t\\\n+     address into the address of the descriptor, not the function\t\\\n+     itself.  */\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (VALUE) == SYMBOL_REF\t\t\t\t\\\n+\t   && XSTR (VALUE, 0)[0] == '.'\t\t\t\t\t\\\n+\t   && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT))\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      char *name = XSTR (VALUE, 0);\t\t\t\t\t\\\n+      while (*name == '.')\t\t\t\t\t\t\\\n+\tname++;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.long %s\\n\", name);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.long \");\t\t\t\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\t\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n /* This is the end of what might become sysv4.h.  */\n \n /* Allow stabs and dwarf, prefer dwarf.  */\n #define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG\n #define\tDBX_DEBUGGING_INFO\n #define\tDWARF_DEBUGGING_INFO\n \n+/* If we are referencing a function that is static or is known to be\n+   in this file, make the SYMBOL_REF special.  We can use this to indicate\n+   that we can branch to this function without emitting a no-op after the\n+   call.  For real AIX and NT calling sequences, we also replace the\n+   function name with the real name (1 or 2 leading .'s), rather than\n+   the function descriptor name.  This saves a lot of overriding code\n+   to readd the prefixes.  */\n+\n+#undef\tENCODE_SECTION_INFO\n+#define ENCODE_SECTION_INFO(DECL)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\trtx sym_ref = XEXP (DECL_RTL (DECL), 0);\t\t\t\\\n+\tif (TREE_ASM_WRITTEN (DECL) || ! TREE_PUBLIC (DECL))\t\t\\\n+\t  SYMBOL_REF_FLAG (sym_ref) = 1;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT)\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    char *prefix = (DEFAULT_ABI == ABI_AIX) ? \".\" : \"..\";\t\\\n+\t    char *str = permalloc (strlen (prefix) + 1\t\t\t\\\n+\t\t\t\t   + strlen (XSTR (sym_ref, 0)));\t\\\n+\t    strcpy (str, prefix);\t\t\t\t\t\\\n+\t    strcat (str, XSTR (sym_ref, 0));\t\t\t\t\\\n+\t    XSTR (sym_ref, 0) = str;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n /* This macro gets just the user-specified name\n    out of the string in a SYMBOL_REF.  Discard\n    a leading * */\n #undef  STRIP_NAME_ENCODING\n #define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME) \\\n   (VAR) = ((SYMBOL_NAME) + ((SYMBOL_NAME)[0] == '*'))\n \n-/* Like block addresses, stabs line numbers are relative to the\n-   current function.  */\n-\n-#undef  ASM_OUTPUT_SOURCE_LINE\n-#define ASM_OUTPUT_SOURCE_LINE(file, line)\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    static int sym_lineno = 1;\t\t\t\t\t\t\\\n-    char *_p;\t\t\t\t\t\t\t\t\\\n-    fprintf (file, \"\\t.stabn 68,0,%d,.LM%d-\",\t\t\t\t\\\n-\t     line, sym_lineno);\t\t\t\t\t\t\\\n-    STRIP_NAME_ENCODING (_p, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0)); \\\n-    assemble_name (file, _p);\t\t\t\t\t\t\\\n-    fprintf (file, \"\\n.LM%d:\\n\", sym_lineno);\t\t\t\t\\\n-    sym_lineno += 1;\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n /* But, to make this work, we have to output the stabs for the function\n    name *first*...  */\n \n@@ -371,77 +566,6 @@ while (0)\n \n #undef TARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (PowerPC System V.4)\");\n-\f\n-\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.\n-\n-   The trampoline should set the static chain pointer to value placed\n-   into the trampoline and should branch to the specified routine.\n-\n-   Unlike AIX, this needs real code.  */\n-\n-#undef\tTRAMPOLINE_TEMPLATE\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  char *sc = reg_names[STATIC_CHAIN_REGNUM];\t\t\t\t\\\n-  char *r0 = reg_names[0];\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (STATIC_CHAIN_REGNUM == 0 || !TARGET_NEW_MNEMONICS)\t\t\\\n-    abort ();\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_64BIT)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmflr %s\\n\", r0);\t\t/* offset  0 */\t\\\n-      fprintf (FILE, \"\\tbl .LTRAMP1\\n\");\t\t/* offset  4 */\t\\\n-      fprintf (FILE, \"\\t.long 0,0,0,0\\n\");\t\t/* offset  8 */\t\\\n-      fprintf (FILE, \".LTRAMP1:\\n\");\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmflr %s\\n\", sc);\t\t/* offset 28 */\t\\\n-      fprintf (FILE, \"\\tmtlr %s\\n\", r0);\t\t/* offset 32 */\t\\\n-      fprintf (FILE, \"\\tld %s,0(%s)\\n\", r0, sc);\t/* offset 36 */\t\\\n-      fprintf (FILE, \"\\tld %s,8(%s)\\n\", sc, sc);\t/* offset 40 */\t\\\n-      fprintf (FILE, \"\\tmtctr %s\\n\", r0);\t\t/* offset 44 */\t\\\n-      fprintf (FILE, \"\\tbctr\\n\");\t\t\t/* offset 48 */\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmflr %s\\n\", r0);\t\t/* offset  0 */\t\\\n-      fprintf (FILE, \"\\tbl .LTRAMP1\\n\");\t\t/* offset  4 */\t\\\n-      fprintf (FILE, \"\\t.long 0,0\\n\");\t\t\t/* offset  8 */\t\\\n-      fprintf (FILE, \".LTRAMP1:\\n\");\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmflr %s\\n\", sc);\t\t/* offset 20 */\t\\\n-      fprintf (FILE, \"\\tmtlr %s\\n\", r0);\t\t/* offset 24 */\t\\\n-      fprintf (FILE, \"\\tlwz %s,0(%s)\\n\", r0, sc);\t/* offset 28 */\t\\\n-      fprintf (FILE, \"\\tlwz %s,4(%s)\\n\", sc, sc);\t/* offset 32 */\t\\\n-      fprintf (FILE, \"\\tmtctr %s\\n\", r0);\t\t/* offset 36 */\t\\\n-      fprintf (FILE, \"\\tbctr\\n\");\t\t\t/* offset 40 */\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#undef\tTRAMPOLINE_SIZE\n-#define TRAMPOLINE_SIZE    (TARGET_64BIT ? 48 : 40)\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#undef\tINITIALIZE_TRAMPOLINE\n-#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx reg = gen_reg_rtx (Pmode);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (reg, FNADDR);\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, Pmode,\t\t\t\t\t\\\n-\t\t\t   plus_constant (ADDR, 8)),\t\t\t\\\n-\t\t  reg);\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, Pmode,\t\t\t\t\t\\\n-\t\t\t   plus_constant (ADDR, (TARGET_64BIT ? 16 : 12))), \\\n-\t\t  CXT);\t\t\t\t\t\t\t\\\n-  emit_insn (gen_sync_isync (gen_rtx (MEM, BLKmode, ADDR)));\t\t\\\n-}\n-\n \f\n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \\\n@@ -482,7 +606,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define CPP_SPEC \"\\\n %{posix: -D_POSIX_SOURCE} \\\n %{mrelocatable: -D_RELOCATABLE} \\\n-%{mcall-sysv: -D_CALL_SYSV} %{mcall-aix: -D_CALL_AIX} %{!mcall-sysv: %{!mcall-aix: -D_CALL_SYSV}} \\\n+%{mcall-sysv: -D_CALL_SYSV} %{mcall-nt: -D_CALL_NT} \\\n+%{mcall-aix: -D_CALL_AIX} %{mcall-aixdesc: -D_CALL_AIX -D_CALL_AIXDESC} \\\n+%{!mcall-sysv: %{!mcall-aix: %{!mcall-aixdesc: %{!mcall-nt: -D_CALL_SYSV}}}} \\\n %{msoft-float: -D_SOFT_FLOAT} %{mcpu=403: -D_SOFT_FLOAT} \\\n %{mlittle: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n %{mlittle-endian: -D_LITTLE_ENDIAN -Amachine(littleendian)} \\\n@@ -503,5 +629,20 @@ do {\t\t\t\t\t\t\t\t\t\\\n %{mcpu=rsc1: -D_ARCH_PWR} \\\n %{mcpu=403: -D_ARCH_PPC} \\\n %{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=602: -D_ARCH_PPC} \\\n %{mcpu=603: -D_ARCH_PPC} \\\n-%{mcpu=604: -D_ARCH_PPC}\"\n+%{mcpu=603e: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC} \\\n+%{mcpu=620: -D_ARCH_PPC}\"\n+\n+/* Define this macro as a C expression for the initializer of an\n+   array of string to tell the driver program which options are\n+   defaults for this target and thus do not need to be handled\n+   specially when using `MULTILIB_OPTIONS'.\n+\n+   Do not define this macro if `MULTILIB_OPTIONS' is not defined in\n+   the target makefile fragment or if none of the options listed in\n+   `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.  */\n+\n+#undef\tMULTILIB_DEFAULTS\n+#define\tMULTILIB_DEFAULTS { \"mbig\", \"mbig-endian\", \"mcall-sysv\" }"}, {"sha": "7a2e55b6b7c233bae37cc1943b4ee18ed5ddc200", "filename": "gcc/config/rs6000/sysv4le.h", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Fsysv4le.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Fsysv4le.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4le.h?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -29,7 +29,9 @@ Boston, MA 02111-1307, USA.  */\n #define CPP_SPEC \"\\\n %{posix: -D_POSIX_SOURCE} \\\n %{mrelocatable: -D_RELOCATABLE} \\\n-%{mcall-sysv: -D_CALL_SYSV} %{mcall-aix: -D_CALL_AIX} %{!mcall-sysv: %{!mcall-aix: -D_CALL_SYSV}} \\\n+%{mcall-sysv: -D_CALL_SYSV} %{mcall-nt: -D_CALL_NT} \\\n+%{mcall-aix: -D_CALL_AIX} %{mcall-aixdesc: -D_CALL_AIX -D_CALL_AIXDESC} \\\n+%{!mcall-sysv: %{!mcall-aix: %{!mcall-aixdesc: %{!mcall-nt: -D_CALL_SYSV}}}} \\\n %{msoft-float: -D_SOFT_FLOAT} %{mcpu=403: -D_SOFT_FLOAT} \\\n %{mbig: -D_BIG_ENDIAN -Amachine(bigendian)} \\\n %{mbig-endian: -D_BIG_ENDIAN -Amachine(bigendian)} \\\n@@ -50,5 +52,20 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=rsc1: -D_ARCH_PWR} \\\n %{mcpu=403: -D_ARCH_PPC} \\\n %{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=602: -D_ARCH_PPC} \\\n %{mcpu=603: -D_ARCH_PPC} \\\n-%{mcpu=604: -D_ARCH_PPC}\"\n+%{mcpu=603e: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC} \\\n+%{mcpu=620: -D_ARCH_PPC}\"\n+\n+/* Define this macro as a C expression for the initializer of an\n+   array of string to tell the driver program which options are\n+   defaults for this target and thus do not need to be handled\n+   specially when using `MULTILIB_OPTIONS'.\n+\n+   Do not define this macro if `MULTILIB_OPTIONS' is not defined in\n+   the target makefile fragment or if none of the options listed in\n+   `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.  */\n+\n+#undef\tMULTILIB_DEFAULTS\n+#define\tMULTILIB_DEFAULTS { \"mlittle\", \"mlittle-endian\", \"mcall-sysv\" }"}, {"sha": "e664aa5053cf22a22b4d7f2dc447678a82ca32d0", "filename": "gcc/config/rs6000/t-ppc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Ft-ppc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Ft-ppc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-ppc?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -2,6 +2,8 @@\n LIBGCC1 =\n CROSS_LIBGCC1 =\n \n+EXTRA_HEADERS = $(srcdir)/ginclude/ppc-asm.h\n+\n # These are really part of libgcc1, but this will cause them to be\n # built correctly, so... [taken from t-sparclite]\n LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c"}, {"sha": "1169ef69c89526b0df9d7b28bb366a263567daeb", "filename": "gcc/config/rs6000/t-ppcgas", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Ft-ppcgas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c9286a86e351a50cd49fc0cd8934d99875e14d/gcc%2Fconfig%2Frs6000%2Ft-ppcgas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-ppcgas?ref=b6c9286a86e351a50cd49fc0cd8934d99875e14d", "patch": "@@ -2,6 +2,8 @@\n LIBGCC1 =\n CROSS_LIBGCC1 =\n \n+EXTRA_HEADERS = $(srcdir)/ginclude/ppc-asm.h\n+\n # These are really part of libgcc1, but this will cause them to be\n # built correctly, so... [taken from t-sparclite]\n LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n@@ -16,15 +18,18 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n # Build libgcc.a with different options.\n \n MULTILIB_OPTIONS\t= msoft-float \\\n-\t\t\t  mlittle\n+\t\t\t  mlittle/mbig \\\n+\t\t\t  mcall-sysv/mcall-aix/mcall-aixdesc\n \n MULTILIB_DIRNAMES\t= soft-float \\\n-\t\t\t  little-endian\n+\t\t\t  little big \\\n+\t\t\t  sysv aix aixdesc\n \n MULTILIB_MATCHES\t= mlittle=mlittle-endian \\\n-\t\t\t  msoft-float=mcpu?403 \\\n-\t\t\t  msoft-float=mcpu?mpc403 \\\n-\t\t\t  msoft-float=mcpu?ppc403\n+\t\t\t  mbig=mbig-endian \\\n+\t\t\t  msoft-float=mcpu?403\n+\n+MULTILIB_EXCEPTIONS\t= *mlittle/*mcall-aixdesc*\n \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib"}]}