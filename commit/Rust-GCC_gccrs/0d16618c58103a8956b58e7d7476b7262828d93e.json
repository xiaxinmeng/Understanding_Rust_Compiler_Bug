{"sha": "0d16618c58103a8956b58e7d7476b7262828d93e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQxNjYxOGM1ODEwM2E4OTU2YjU4ZTdkNzQ3NmI3MjYyODI4ZDkzZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-06-24T20:06:09Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-06-24T20:06:09Z"}, "message": "[multiple changes]\n\nFri May 28 22:20:03 1999  Anthony Green  <green@cygnus.com>\n\t* java/lang/fdlibm.h: Don't use __uint32_t.  Include mprec.h.\n\t* java/lang/e_log.c: Don't use __uint32_t.\n1999-05-27  Eric Christopher <echristo@cygnus.com>\n\t* configure: Rebuilt\n\t* configure.in: Fixed ISO C9X and namespace collision with __uint32_t\n\t* acconfig.h: Rebuilt\n\t* include/config.h.in: Rebuilt\n\t* java/lang/mprec.h, java/lang/e_acos.c, java/lang/e_asin.c,\n \tjava/lang/e_atan2.c, java/lang/e_exp.c, java/lang/e_fmod.c,\n \te_log.c, java/lang/e_pow.c, java/lang/e_rem_pio2.c,\n \tjava/lang/e_remainder.c, java/lang/e_sqrt.c, java/lang/fdlibm.h,\n \tk_tan.c, java/lang/mprec.h, java/lang/s_atan.c,\n \tjava/lang/s_ceil.c, java/lang/s_copysign.c, java/lang/s_fabs.c,\n \ts_floor.c, java/lang/s_rint.c, java/lang/sf_rint.c: Fixed ISO C9X\n \tand namespace collision with __uint32_t\n\nFrom-SVN: r27729", "tree": {"sha": "f577c36db61fa83932e1fd4b93c845f64b0d2b7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f577c36db61fa83932e1fd4b93c845f64b0d2b7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d16618c58103a8956b58e7d7476b7262828d93e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d16618c58103a8956b58e7d7476b7262828d93e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d16618c58103a8956b58e7d7476b7262828d93e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d16618c58103a8956b58e7d7476b7262828d93e/comments", "author": null, "committer": null, "parents": [{"sha": "fe574d5d92f83b0b34a8d4cb782f2885a28d3754", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe574d5d92f83b0b34a8d4cb782f2885a28d3754", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe574d5d92f83b0b34a8d4cb782f2885a28d3754"}], "stats": {"total": 1138, "additions": 613, "deletions": 525}, "files": [{"sha": "faa2bdb89a525e4c8817c97ba6aacca7821a6ca2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -1,3 +1,24 @@\n+Fri May 28 22:20:03 1999  Anthony Green  <green@cygnus.com>\n+\n+\t* java/lang/fdlibm.h: Don't use __uint32_t.  Include mprec.h.\n+\t* java/lang/e_log.c: Don't use __uint32_t.\n+\n+1999-05-27  Eric Christopher <echristo@cygnus.com>\n+\n+\t* configure: Rebuilt\n+\t* configure.in: Fixed ISO C9X and namespace collision with __uint32_t\n+\t* acconfig.h: Rebuilt\n+\t* include/config.h.in: Rebuilt\n+\n+\t* java/lang/mprec.h, java/lang/e_acos.c, java/lang/e_asin.c,\n+ \tjava/lang/e_atan2.c, java/lang/e_exp.c, java/lang/e_fmod.c,\n+ \te_log.c, java/lang/e_pow.c, java/lang/e_rem_pio2.c,\n+ \tjava/lang/e_remainder.c, java/lang/e_sqrt.c, java/lang/fdlibm.h,\n+ \tk_tan.c, java/lang/mprec.h, java/lang/s_atan.c,\n+ \tjava/lang/s_ceil.c, java/lang/s_copysign.c, java/lang/s_fabs.c,\n+ \ts_floor.c, java/lang/s_rint.c, java/lang/sf_rint.c: Fixed ISO C9X\n+ \tand namespace collision with __uint32_t\n+\n 1999-06-23  Tom Tromey  <tromey@cygnus.com>\n \n \t* java/util/zip/InflaterInputStream.java (read): Throw"}, {"sha": "daddbb141027ddd66cc946ff476963adc8266adc", "filename": "libjava/acconfig.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Facconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Facconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Facconfig.h?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -28,9 +28,12 @@\n /* Define if you have sleep.  */\n #undef HAVE_SLEEP\n \n-/* Define if you have __int32_t and __uint32_t. */\n+/* Define if you have int32_t and uint32_t. */\n #undef HAVE_INT32_DEFINED\n \n+/* Define if you have u_int32_t */\n+#undef HAVE_BSD_INT32_DEFINED\n+\n /* Define if you're running eCos. */\n #undef ECOS\n "}, {"sha": "563ed45f2a4538b428bcc9514325ee6beb47ae55", "filename": "libjava/configure", "status": "modified", "additions": 143, "deletions": 112, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -2707,10 +2707,10 @@ echo \"$ac_t\"\"$CPP\" 1>&6\n cat > conftest.$ac_ext <<EOF\n #line 2709 \"configure\"\n #include \"confdefs.h\"\n-#include <sys/types.h>\n+#include <stdint.h>\n EOF\n if (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n-  egrep \"__uint32_t\" >/dev/null 2>&1; then\n+  egrep \"uint32_t\" >/dev/null 2>&1; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_INT32_DEFINED 1\n@@ -2722,10 +2722,10 @@ rm -f conftest*\n cat > conftest.$ac_ext <<EOF\n #line 2724 \"configure\"\n #include \"confdefs.h\"\n-#include <sys/config.h>\n+#include <inttypes.h>\n EOF\n if (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n-  egrep \"__uint32_t\" >/dev/null 2>&1; then\n+  egrep \"uint32_t\" >/dev/null 2>&1; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_INT32_DEFINED 1\n@@ -2734,9 +2734,40 @@ EOF\n fi\n rm -f conftest*\n \n+cat > conftest.$ac_ext <<EOF\n+#line 2739 \"configure\"\n+#include \"confdefs.h\"\n+#include <sys/types.h>\n+EOF\n+if (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n+  egrep \"u_int32_t\" >/dev/null 2>&1; then\n+  rm -rf conftest*\n+  cat >> confdefs.h <<\\EOF\n+#define HAVE_BSD_INT32_DEFINED 1\n+EOF\n+\n+fi\n+rm -f conftest*\n+\n+cat > conftest.$ac_ext <<EOF\n+#line 2754 \"configure\"\n+#include \"confdefs.h\"\n+#include <sys/config.h>\n+EOF\n+if (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n+  egrep \"u_int32_t\" >/dev/null 2>&1; then\n+  rm -rf conftest*\n+  cat >> confdefs.h <<\\EOF\n+#define HAVE_BSD_INT32_DEFINED 1\n+EOF\n+\n+fi\n+rm -f conftest*\n+\n+\n \n cat > conftest.$ac_ext <<EOF\n-#line 2740 \"configure\"\n+#line 2771 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n EOF\n@@ -2751,7 +2782,7 @@ fi\n rm -f conftest*\n \n cat > conftest.$ac_ext <<EOF\n-#line 2755 \"configure\"\n+#line 2786 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n EOF\n@@ -2789,7 +2820,7 @@ ZLIBSPEC=\n libsubdir=.libs\n \n echo $ac_n \"checking for garbage collector to use\"\"... $ac_c\" 1>&6\n-echo \"configure:2793: checking for garbage collector to use\" >&5\n+echo \"configure:2824: checking for garbage collector to use\" >&5\n # Check whether --enable-java-gc or --disable-java-gc was given.\n if test \"${enable_java_gc+set}\" = set; then\n   enableval=\"$enable_java_gc\"\n@@ -2839,7 +2870,7 @@ esac\n \n \n echo $ac_n \"checking for threads package to use\"\"... $ac_c\" 1>&6\n-echo \"configure:2843: checking for threads package to use\" >&5\n+echo \"configure:2874: checking for threads package to use\" >&5\n # Check whether --enable-threads or --disable-threads was given.\n if test \"${enable_threads+set}\" = set; then\n   enableval=\"$enable_threads\"\n@@ -3031,12 +3062,12 @@ else\n    for ac_func in strerror ioctl select open fsync sleep\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3035: checking for $ac_func\" >&5\n+echo \"configure:3066: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3040 \"configure\"\n+#line 3071 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3059,7 +3090,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3063: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3094: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3086,12 +3117,12 @@ done\n    for ac_func in ctime_r ctime\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3090: checking for $ac_func\" >&5\n+echo \"configure:3121: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3095 \"configure\"\n+#line 3126 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3114,7 +3145,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3118: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3149: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3141,12 +3172,12 @@ done\n    for ac_func in gmtime_r localtime_r readdir_r getpwuid_r\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3145: checking for $ac_func\" >&5\n+echo \"configure:3176: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3150 \"configure\"\n+#line 3181 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3169,7 +3200,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3173: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3204: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3196,12 +3227,12 @@ done\n    for ac_func in access stat mkdir rename rmdir unlink realpath\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3200: checking for $ac_func\" >&5\n+echo \"configure:3231: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3205 \"configure\"\n+#line 3236 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3224,7 +3255,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3228: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3259: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3251,12 +3282,12 @@ done\n    for ac_func in inet_aton inet_addr\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3255: checking for $ac_func\" >&5\n+echo \"configure:3286: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3260 \"configure\"\n+#line 3291 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3279,7 +3310,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3283: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3314: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3306,12 +3337,12 @@ done\n    for ac_func in inet_pton uname\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3310: checking for $ac_func\" >&5\n+echo \"configure:3341: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3315 \"configure\"\n+#line 3346 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3334,7 +3365,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3338: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3369: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3362,12 +3393,12 @@ done\n    for ac_func in gethostbyname_r\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3366: checking for $ac_func\" >&5\n+echo \"configure:3397: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3371 \"configure\"\n+#line 3402 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3390,7 +3421,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3394: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3425: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3417,7 +3448,7 @@ EOF\n      # We look for the one that returns `int'.\n      # Hopefully this check is robust enough.\n      cat > conftest.$ac_ext <<EOF\n-#line 3421 \"configure\"\n+#line 3452 \"configure\"\n #include \"confdefs.h\"\n #include <netdb.h>\n EOF\n@@ -3441,12 +3472,12 @@ done\n    for ac_func in gethostbyaddr_r\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3445: checking for $ac_func\" >&5\n+echo \"configure:3476: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3450 \"configure\"\n+#line 3481 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3469,7 +3500,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3473: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3504: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3496,7 +3527,7 @@ EOF\n      # We look for the one that returns `int'.\n      # Hopefully this check is robust enough.\n      cat > conftest.$ac_ext <<EOF\n-#line 3500 \"configure\"\n+#line 3531 \"configure\"\n #include \"confdefs.h\"\n #include <netdb.h>\n EOF\n@@ -3520,12 +3551,12 @@ done\n    for ac_func in gethostname\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3524: checking for $ac_func\" >&5\n+echo \"configure:3555: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3529 \"configure\"\n+#line 3560 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3548,7 +3579,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3552: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3583: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3572,7 +3603,7 @@ EOF\n EOF\n \n      cat > conftest.$ac_ext <<EOF\n-#line 3576 \"configure\"\n+#line 3607 \"configure\"\n #include \"confdefs.h\"\n #include <unistd.h>\n EOF\n@@ -3599,12 +3630,12 @@ done\n    for ac_func in pthread_mutexattr_settype pthread_mutexattr_setkind_np sched_yield\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3603: checking for $ac_func\" >&5\n+echo \"configure:3634: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3608 \"configure\"\n+#line 3639 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3627,7 +3658,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3631: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3662: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3655,12 +3686,12 @@ done\n    for ac_func in sched_yield\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3659: checking for $ac_func\" >&5\n+echo \"configure:3690: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3664 \"configure\"\n+#line 3695 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3683,7 +3714,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3687: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3718: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3705,15 +3736,15 @@ EOF\n else\n   echo \"$ac_t\"\"no\" 1>&6\n echo $ac_n \"checking for sched_yield in -lposix4\"\"... $ac_c\" 1>&6\n-echo \"configure:3709: checking for sched_yield in -lposix4\" >&5\n+echo \"configure:3740: checking for sched_yield in -lposix4\" >&5\n ac_lib_var=`echo posix4'_'sched_yield | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lposix4  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 3717 \"configure\"\n+#line 3748 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -3724,7 +3755,7 @@ int main() {\n sched_yield()\n ; return 0; }\n EOF\n-if { (eval echo configure:3728: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3759: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -3759,12 +3790,12 @@ done\n    for ac_func in gettimeofday time ftime\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3763: checking for $ac_func\" >&5\n+echo \"configure:3794: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3768 \"configure\"\n+#line 3799 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3787,7 +3818,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3791: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3822: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3820,12 +3851,12 @@ done\n    for ac_func in memmove\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3824: checking for $ac_func\" >&5\n+echo \"configure:3855: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3829 \"configure\"\n+#line 3860 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3848,7 +3879,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3852: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3883: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3881,12 +3912,12 @@ done\n    for ac_func in memcpy\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3885: checking for $ac_func\" >&5\n+echo \"configure:3916: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3890 \"configure\"\n+#line 3921 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3909,7 +3940,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3913: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3944: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3957,20 +3988,20 @@ done\n    #--------------------------------------------------------------------\n \n    echo $ac_n \"checking for socket libraries\"\"... $ac_c\" 1>&6\n-echo \"configure:3961: checking for socket libraries\" >&5\n+echo \"configure:3992: checking for socket libraries\" >&5\n if eval \"test \\\"`echo '$''{'gcj_cv_lib_sockets'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   gcj_cv_lib_sockets=\n      gcj_checkBoth=0\n      unset ac_cv_func_connect\n      echo $ac_n \"checking for connect\"\"... $ac_c\" 1>&6\n-echo \"configure:3969: checking for connect\" >&5\n+echo \"configure:4000: checking for connect\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_connect'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3974 \"configure\"\n+#line 4005 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char connect(); below.  */\n@@ -3993,7 +4024,7 @@ connect();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3997: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4028: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_connect=yes\"\n else\n@@ -4016,22 +4047,22 @@ fi\n      if test \"$gcj_checkSocket\" = 1; then\n \t unset ac_cv_func_connect\n \t echo $ac_n \"checking for main in -lsocket\"\"... $ac_c\" 1>&6\n-echo \"configure:4020: checking for main in -lsocket\" >&5\n+echo \"configure:4051: checking for main in -lsocket\" >&5\n ac_lib_var=`echo socket'_'main | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lsocket  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4028 \"configure\"\n+#line 4059 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n main()\n ; return 0; }\n EOF\n-if { (eval echo configure:4035: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4066: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4058,12 +4089,12 @@ fi\n \t LIBS=\"$LIBS -lsocket -lnsl\"\n \t unset ac_cv_func_accept\n \t echo $ac_n \"checking for accept\"\"... $ac_c\" 1>&6\n-echo \"configure:4062: checking for accept\" >&5\n+echo \"configure:4093: checking for accept\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_accept'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4067 \"configure\"\n+#line 4098 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char accept(); below.  */\n@@ -4086,7 +4117,7 @@ accept();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4090: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4121: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_accept=yes\"\n else\n@@ -4113,12 +4144,12 @@ fi\n      gcj_oldLibs=$LIBS\n      LIBS=\"$LIBS $gcj_cv_lib_sockets\"\n      echo $ac_n \"checking for gethostbyname\"\"... $ac_c\" 1>&6\n-echo \"configure:4117: checking for gethostbyname\" >&5\n+echo \"configure:4148: checking for gethostbyname\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4122 \"configure\"\n+#line 4153 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char gethostbyname(); below.  */\n@@ -4141,7 +4172,7 @@ gethostbyname();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4145: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4176: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_gethostbyname=yes\"\n else\n@@ -4159,22 +4190,22 @@ if eval \"test \\\"`echo '$ac_cv_func_'gethostbyname`\\\" = yes\"; then\n else\n   echo \"$ac_t\"\"no\" 1>&6\n echo $ac_n \"checking for main in -lnsl\"\"... $ac_c\" 1>&6\n-echo \"configure:4163: checking for main in -lnsl\" >&5\n+echo \"configure:4194: checking for main in -lnsl\" >&5\n ac_lib_var=`echo nsl'_'main | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lnsl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4171 \"configure\"\n+#line 4202 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n main()\n ; return 0; }\n EOF\n-if { (eval echo configure:4178: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4209: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4206,15 +4237,15 @@ echo \"$ac_t\"\"$gcj_cv_lib_sockets\" 1>&6\n \n    if test \"$with_system_zlib\" = yes; then\n       echo $ac_n \"checking for deflate in -lz\"\"... $ac_c\" 1>&6\n-echo \"configure:4210: checking for deflate in -lz\" >&5\n+echo \"configure:4241: checking for deflate in -lz\" >&5\n ac_lib_var=`echo z'_'deflate | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lz  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4218 \"configure\"\n+#line 4249 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -4225,7 +4256,7 @@ int main() {\n deflate()\n ; return 0; }\n EOF\n-if { (eval echo configure:4229: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4260: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4254,22 +4285,22 @@ fi\n    # requires -ldl.\n    if test \"$GC\" = boehm; then\n       echo $ac_n \"checking for main in -ldl\"\"... $ac_c\" 1>&6\n-echo \"configure:4258: checking for main in -ldl\" >&5\n+echo \"configure:4289: checking for main in -ldl\" >&5\n ac_lib_var=`echo dl'_'main | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-ldl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4266 \"configure\"\n+#line 4297 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n main()\n ; return 0; }\n EOF\n-if { (eval echo configure:4273: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4304: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4374,21 +4405,21 @@ EOF\n \n \n \n-for ac_hdr in unistd.h sys/time.h sys/types.h fcntl.h sys/ioctl.h sys/filio.h sys/stat.h sys/select.h sys/socket.h netinet/in.h arpa/inet.h netdb.h pwd.h\n+for ac_hdr in unistd.h sys/time.h sys/types.h fcntl.h sys/ioctl.h sys/filio.h sys/stat.h sys/select.h sys/socket.h netinet/in.h arpa/inet.h netdb.h pwd.h sys/config.h inttypes.h stdint.h\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:4382: checking for $ac_hdr\" >&5\n+echo \"configure:4413: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4387 \"configure\"\n+#line 4418 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:4392: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:4423: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -4418,17 +4449,17 @@ for ac_hdr in dirent.h\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:4422: checking for $ac_hdr\" >&5\n+echo \"configure:4453: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4427 \"configure\"\n+#line 4458 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:4432: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:4463: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -4456,16 +4487,16 @@ done\n \n \n echo $ac_n \"checking whether struct sockaddr_in6 is in netinet/in.h\"\"... $ac_c\" 1>&6\n-echo \"configure:4460: checking whether struct sockaddr_in6 is in netinet/in.h\" >&5\n+echo \"configure:4491: checking whether struct sockaddr_in6 is in netinet/in.h\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 4462 \"configure\"\n+#line 4493 \"configure\"\n #include \"confdefs.h\"\n #include <netinet/in.h>\n int main() {\n struct sockaddr_in6 addr6;\n ; return 0; }\n EOF\n-if { (eval echo configure:4469: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:4500: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_INET6 1\n@@ -4481,16 +4512,16 @@ fi\n rm -f conftest*\n \n echo $ac_n \"checking for socklen_t in sys/socket.h\"\"... $ac_c\" 1>&6\n-echo \"configure:4485: checking for socklen_t in sys/socket.h\" >&5\n+echo \"configure:4516: checking for socklen_t in sys/socket.h\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 4487 \"configure\"\n+#line 4518 \"configure\"\n #include \"confdefs.h\"\n #include <sys/socket.h>\n int main() {\n socklen_t x = 5;\n ; return 0; }\n EOF\n-if { (eval echo configure:4494: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:4525: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_SOCKLEN_T 1\n@@ -4506,16 +4537,16 @@ fi\n rm -f conftest*\n \n echo $ac_n \"checking for tm_gmtoff in struct tm\"\"... $ac_c\" 1>&6\n-echo \"configure:4510: checking for tm_gmtoff in struct tm\" >&5\n+echo \"configure:4541: checking for tm_gmtoff in struct tm\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 4512 \"configure\"\n+#line 4543 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n int main() {\n struct tm tim; tim.tm_gmtoff = 0;\n ; return 0; }\n EOF\n-if { (eval echo configure:4519: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:4550: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define STRUCT_TM_HAS_GMTOFF 1\n@@ -4528,16 +4559,16 @@ else\n   rm -rf conftest*\n   echo \"$ac_t\"\"no\" 1>&6\n    echo $ac_n \"checking for global timezone variable\"\"... $ac_c\" 1>&6\n-echo \"configure:4532: checking for global timezone variable\" >&5\n+echo \"configure:4563: checking for global timezone variable\" >&5\n             cat > conftest.$ac_ext <<EOF\n-#line 4534 \"configure\"\n+#line 4565 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n int main() {\n long z2 = timezone;\n ; return 0; }\n EOF\n-if { (eval echo configure:4541: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:4572: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_TIMEZONE 1\n@@ -4557,19 +4588,19 @@ rm -f conftest*\n # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works\n # for constant arguments.  Useless!\n echo $ac_n \"checking for working alloca.h\"\"... $ac_c\" 1>&6\n-echo \"configure:4561: checking for working alloca.h\" >&5\n+echo \"configure:4592: checking for working alloca.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_alloca_h'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4566 \"configure\"\n+#line 4597 \"configure\"\n #include \"confdefs.h\"\n #include <alloca.h>\n int main() {\n char *p = alloca(2 * sizeof(int));\n ; return 0; }\n EOF\n-if { (eval echo configure:4573: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4604: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_header_alloca_h=yes\n else\n@@ -4590,12 +4621,12 @@ EOF\n fi\n \n echo $ac_n \"checking for alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:4594: checking for alloca\" >&5\n+echo \"configure:4625: checking for alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_alloca_works'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4599 \"configure\"\n+#line 4630 \"configure\"\n #include \"confdefs.h\"\n \n #ifdef __GNUC__\n@@ -4623,7 +4654,7 @@ int main() {\n char *p = (char *) alloca(1);\n ; return 0; }\n EOF\n-if { (eval echo configure:4627: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4658: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_func_alloca_works=yes\n else\n@@ -4655,12 +4686,12 @@ EOF\n \n \n echo $ac_n \"checking whether alloca needs Cray hooks\"\"... $ac_c\" 1>&6\n-echo \"configure:4659: checking whether alloca needs Cray hooks\" >&5\n+echo \"configure:4690: checking whether alloca needs Cray hooks\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_os_cray'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4664 \"configure\"\n+#line 4695 \"configure\"\n #include \"confdefs.h\"\n #if defined(CRAY) && ! defined(CRAY2)\n webecray\n@@ -4685,12 +4716,12 @@ echo \"$ac_t\"\"$ac_cv_os_cray\" 1>&6\n if test $ac_cv_os_cray = yes; then\n for ac_func in _getb67 GETB67 getb67; do\n   echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:4689: checking for $ac_func\" >&5\n+echo \"configure:4720: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4694 \"configure\"\n+#line 4725 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -4713,7 +4744,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4717: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4748: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -4740,15 +4771,15 @@ done\n fi\n \n echo $ac_n \"checking stack direction for C alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:4744: checking stack direction for C alloca\" >&5\n+echo \"configure:4775: checking stack direction for C alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_stack_direction'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_c_stack_direction=0\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4752 \"configure\"\n+#line 4783 \"configure\"\n #include \"confdefs.h\"\n find_stack_direction ()\n {\n@@ -4767,7 +4798,7 @@ main ()\n   exit (find_stack_direction() < 0);\n }\n EOF\n-if { (eval echo configure:4771: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:4802: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_stack_direction=1\n else\n@@ -4794,7 +4825,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4798: checking for $ac_word\" >&5\n+echo \"configure:4829: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_PERL'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else"}, {"sha": "9ba86e5a3277c0ed0e06e741c1043aed02d7e655", "filename": "libjava/configure.in", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.in?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -1,7 +1,7 @@\n dnl Process this with autoconf to create configure\n AC_INIT(java/lang/System.java)\n \n-dnl Can't be done in LIBGCJ_CONFIGURE because that confuses automake. \n+dnl Can't be done in LIBGCJ_CONFIGURE because that confuses automake.\n AC_CONFIG_AUX_DIR(..)\n \n AC_CANONICAL_SYSTEM\n@@ -64,8 +64,11 @@ case \"$TARGET_ECOS\" in\n       ;;\n esac\n \n-AC_EGREP_HEADER(__uint32_t, sys/types.h, AC_DEFINE(HAVE_INT32_DEFINED))\n-AC_EGREP_HEADER(__uint32_t, sys/config.h, AC_DEFINE(HAVE_INT32_DEFINED))\n+AC_EGREP_HEADER(uint32_t, stdint.h, AC_DEFINE(HAVE_INT32_DEFINED))\n+AC_EGREP_HEADER(uint32_t, inttypes.h, AC_DEFINE(HAVE_INT32_DEFINED))\n+AC_EGREP_HEADER(u_int32_t, sys/types.h, AC_DEFINE(HAVE_BSD_INT32_DEFINED))\n+AC_EGREP_HEADER(u_int32_t, sys/config.h, AC_DEFINE(HAVE_BSD_INT32_DEFINED))\n+\n \n dnl These may not be defined in a non-ANS conformant embedded system.\n dnl FIXME: Should these case a runtime exception in that case?\n@@ -466,7 +469,7 @@ AC_SUBST(AM_RUNTESTFLAGS)\n dnl We check for sys/filio.h because Solaris 2.5 defines FIONREAD there.\n dnl On that system, sys/ioctl.h will not include sys/filio.h unless\n dnl BSD_COMP is defined; just including sys/filio.h is simpler.\n-AC_CHECK_HEADERS(unistd.h sys/time.h sys/types.h fcntl.h sys/ioctl.h sys/filio.h sys/stat.h sys/select.h sys/socket.h netinet/in.h arpa/inet.h netdb.h pwd.h)\n+AC_CHECK_HEADERS(unistd.h sys/time.h sys/types.h fcntl.h sys/ioctl.h sys/filio.h sys/stat.h sys/select.h sys/socket.h netinet/in.h arpa/inet.h netdb.h pwd.h sys/config.h inttypes.h stdint.h)\n dnl We avoid AC_HEADER_DIRENT since we really only care about dirent.h\n dnl for now.  If you change this, you also must update natFile.cc.\n AC_CHECK_HEADERS(dirent.h)"}, {"sha": "be94a759c0db26620ecdc230b111964c29bc6051", "filename": "libjava/include/config.h.in", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Finclude%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Finclude%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fconfig.h.in?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -40,9 +40,12 @@\n /* Define if you have strerror.  */\n #undef HAVE_STRERROR\n \n-/* Define if you have __int32_t and __uint32_t. */\n+/* Define if you have int32_t and uint32_t. */\n #undef HAVE_INT32_DEFINED\n \n+/* Define if you have u_int32_t */\n+#undef HAVE_BSD_INT32_DEFINED\n+\n /* Define if you're running eCos. */\n #undef ECOS\n \n@@ -214,6 +217,9 @@\n /* Define if you have the <fcntl.h> header file.  */\n #undef HAVE_FCNTL_H\n \n+/* Define if you have the <inttypes.h> header file.  */\n+#undef HAVE_INTTYPES_H\n+\n /* Define if you have the <netdb.h> header file.  */\n #undef HAVE_NETDB_H\n \n@@ -223,6 +229,12 @@\n /* Define if you have the <pwd.h> header file.  */\n #undef HAVE_PWD_H\n \n+/* Define if you have the <stdint.h> header file.  */\n+#undef HAVE_STDINT_H\n+\n+/* Define if you have the <sys/config.h> header file.  */\n+#undef HAVE_SYS_CONFIG_H\n+\n /* Define if you have the <sys/filio.h> header file.  */\n #undef HAVE_SYS_FILIO_H\n "}, {"sha": "e0d4aaaa8ee9b41aeeef812fa0ad3600cef0f348", "filename": "libjava/java/lang/dtoa.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fdtoa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fdtoa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fdtoa.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -205,7 +205,7 @@ _DEFUN (_dtoa_r,\n \tchar **rve _AND\n \tint float_type)\n {\n-  /*\t\n+  /*\n \tfloat_type == 0 for double precision, 1 for float.\n \n \tArguments ndigits, decpt, sign are similar to those\n@@ -679,7 +679,7 @@ _DEFUN (_dtoa_r,\n     {\n       if (!word1 (d) && !(word0 (d) & Bndry_mask)\n #ifndef Sudden_Underflow\n-\t  && word0 (d) & Exp_mask\n+\t  && word0(d) & Exp_mask\n #endif\n \t)\n \t{\n@@ -893,7 +893,7 @@ _DEFUN (_dtoa,\n \tchar *buf _AND\n \tint float_type)\n {\n-  struct _Jv_reent reent;  \n+  struct _Jv_reent reent;\n   char *p;\n   memset (&reent, 0, sizeof reent);\n \n@@ -902,5 +902,3 @@ _DEFUN (_dtoa,\n \n   return;\n }\n-\n-  "}, {"sha": "ee6b168a1c5a5586d305fab91a5d6258d7b0d7d7", "filename": "libjava/java/lang/e_acos.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_acos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_acos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_acos.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,20 +6,20 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n \n /* __ieee754_acos(x)\n- * Method :                  \n+ * Method :\n  *\tacos(x)  = pi/2 - asin(x)\n  *\tacos(-x) = pi/2 + asin(x)\n  * For |x|<=0.5\n  *\tacos(x) = pi/2 - (x + x*x^2*R(x^2))\t(see asin.c)\n  * For x>0.5\n  * \tacos(x) = pi/2 - (pi/2 - 2asin(sqrt((1-x)/2)))\n- *\t\t= 2asin(sqrt((1-x)/2))  \n+ *\t\t= 2asin(sqrt((1-x)/2))\n  *\t\t= 2s + 2s*z*R(z) \t...z=(1-x)/2, s=sqrt(z)\n  *\t\t= 2f + (2c + 2s*z*R(z))\n  *     where f=hi part of s, and c = (z-f*f)/(s+f) is the correction term\n@@ -40,9 +40,9 @@\n #ifndef _DOUBLE_IS_32BITS\n \n #ifdef __STDC__\n-static const double \n+static const double\n #else\n-static double \n+static double\n #endif\n one=  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */\n pi =  3.14159265358979311600e+00, /* 0x400921FB, 0x54442D18 */\n@@ -67,11 +67,11 @@ qS4 =  7.70381505559019352791e-02; /* 0x3FB3B8C5, 0xB12E9282 */\n #endif\n {\n \tdouble z,p,q,r,w,s,c,df;\n-\t__int32_t hx,ix;\n+\tint32_t hx,ix;\n \tGET_HIGH_WORD(hx,x);\n \tix = hx&0x7fffffff;\n \tif(ix>=0x3ff00000) {\t/* |x| >= 1 */\n-\t    __uint32_t lx;\n+\t    uint32_t lx;\n \t    GET_LOW_WORD(lx,x);\n \t    if(((ix-0x3ff00000)|lx)==0) {\t/* |x|==1 */\n \t\tif(hx>0) return 0.0;\t\t/* acos(1) = 0  */"}, {"sha": "c75448db26cf7646de11245b9cef7d226ad93a7e", "filename": "libjava/java/lang/e_atan2.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_atan2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_atan2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_atan2.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  *\n@@ -15,7 +15,7 @@\n /* __ieee754_atan2(y,x)\n  * Method :\n  *\t1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).\n- *\t2. Reduce x to positive by (if x and y are unexceptional): \n+ *\t2. Reduce x to positive by (if x and y are unexceptional):\n  *\t\tARG (x+iy) = arctan(y/x)   \t   ... if x > 0,\n  *\t\tARG (x+iy) = pi - arctan[y/(-x)]   ... if x < 0,\n  *\n@@ -33,9 +33,9 @@\n  *\tATAN2(+-INF, (anything but,0,NaN, and INF)) is +-pi/2;\n  *\n  * Constants:\n- * The hexadecimal values are the intended ones for the following \n- * constants. The decimal values may be used, provided that the \n- * compiler will convert from decimal to binary accurately enough \n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n  * to produce the hexadecimal values shown.\n  */\n \n@@ -44,9 +44,9 @@\n #ifndef _DOUBLE_IS_32BITS\n \n #ifdef __STDC__\n-static const double \n+static const double\n #else\n-static double \n+static double\n #endif\n tiny  = 1.0e-300,\n zero  = 0.0,\n@@ -61,10 +61,10 @@ pi_lo   = 1.2246467991473531772E-16; /* 0x3CA1A626, 0x33145C07 */\n \tdouble __ieee754_atan2(y,x)\n \tdouble  y,x;\n #endif\n-{  \n+{\n \tdouble z;\n-\t__int32_t k,m,hx,hy,ix,iy;\n-\t__uint32_t lx,ly;\n+\tint32_t k,m,hx,hy,ix,iy;\n+\tuint32_t lx,ly;\n \n \tEXTRACT_WORDS(hx,lx,x);\n \tix = hx&0x7fffffff;\n@@ -79,15 +79,15 @@ pi_lo   = 1.2246467991473531772E-16; /* 0x3CA1A626, 0x33145C07 */\n     /* when y = 0 */\n \tif((iy|ly)==0) {\n \t    switch(m) {\n-\t\tcase 0: \n+\t\tcase 0:\n \t\tcase 1: return y; \t/* atan(+-0,+anything)=+-0 */\n \t\tcase 2: return  pi+tiny;/* atan(+0,-anything) = pi */\n \t\tcase 3: return -pi-tiny;/* atan(-0,-anything) =-pi */\n \t    }\n \t}\n     /* when x = 0 */\n \tif((ix|lx)==0) return (hy<0)?  -pi_o_2-tiny: pi_o_2+tiny;\n-\t    \n+\n     /* when x is INF */\n \tif(ix==0x7ff00000) {\n \t    if(iy==0x7ff00000) {\n@@ -117,7 +117,7 @@ pi_lo   = 1.2246467991473531772E-16; /* 0x3CA1A626, 0x33145C07 */\n \tswitch (m) {\n \t    case 0: return       z  ;\t/* atan(+,+) */\n \t    case 1: {\n-\t    \t      __uint32_t zh;\n+\t    \t      uint32_t zh;\n \t\t      GET_HIGH_WORD(zh,z);\n \t\t      SET_HIGH_WORD(z,zh ^ 0x80000000);\n \t\t    }"}, {"sha": "e11ca8b38565af00e42474538cb2e4c70972bf98", "filename": "libjava/java/lang/e_exp.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_exp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_exp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_exp.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -19,36 +19,36 @@\n  *      Reduce x to an r so that |r| <= 0.5*ln2 ~ 0.34658.\n  *\tGiven x, find r and integer k such that\n  *\n- *               x = k*ln2 + r,  |r| <= 0.5*ln2.  \n+ *               x = k*ln2 + r,  |r| <= 0.5*ln2.\n  *\n- *      Here r will be represented as r = hi-lo for better \n+ *      Here r will be represented as r = hi-lo for better\n  *\taccuracy.\n  *\n  *   2. Approximation of exp(r) by a special rational function on\n  *\tthe interval [0,0.34658]:\n  *\tWrite\n  *\t    R(r**2) = r*(exp(r)+1)/(exp(r)-1) = 2 + r*r/6 - r**4/360 + ...\n- *      We use a special Reme algorithm on [0,0.34658] to generate \n- * \ta polynomial of degree 5 to approximate R. The maximum error \n+ *      We use a special Reme algorithm on [0,0.34658] to generate\n+ * \ta polynomial of degree 5 to approximate R. The maximum error\n  *\tof this polynomial approximation is bounded by 2**-59. In\n  *\tother words,\n  *\t    R(z) ~ 2.0 + P1*z + P2*z**2 + P3*z**3 + P4*z**4 + P5*z**5\n  *  \t(where z=r*r, and the values of P1 to P5 are listed below)\n  *\tand\n  *\t    |                  5          |     -59\n- *\t    | 2.0+P1*z+...+P5*z   -  R(z) | <= 2 \n+ *\t    | 2.0+P1*z+...+P5*z   -  R(z) | <= 2\n  *\t    |                             |\n  *\tThe computation of exp(r) thus becomes\n  *                             2*r\n  *\t\texp(r) = 1 + -------\n  *\t\t              R - r\n- *                                 r*R1(r)\t\n+ *                                 r*R1(r)\n  *\t\t       = 1 + r + ----------- (for better accuracy)\n  *\t\t                  2 - R1(r)\n  *\twhere\n  *\t\t\t         2       4             10\n  *\t\tR1(r) = r - (P1*r  + P2*r  + ... + P5*r   ).\n- *\t\n+ *\n  *   3. Scale back to obtain exp(x):\n  *\tFrom step 1, we have\n  *\t   exp(x) = 2^k * exp(r)\n@@ -63,13 +63,13 @@\n  *\t1 ulp (unit in the last place).\n  *\n  * Misc. info.\n- *\tFor IEEE double \n+ *\tFor IEEE double\n  *\t    if x >  7.09782712893383973096e+02 then exp(x) overflow\n  *\t    if x < -7.45133219101941108420e+02 then exp(x) underflow\n  *\n  * Constants:\n- * The hexadecimal values are the intended ones for the following \n- * constants. The decimal values may be used, provided that the \n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n  * compiler will convert from decimal to binary accurately enough\n  * to produce the hexadecimal values shown.\n  */\n@@ -109,8 +109,8 @@ P5   =  4.13813679705723846039e-08; /* 0x3E663769, 0x72BEA4D0 */\n #endif\n {\n \tdouble y,hi,lo,c,t;\n-\t__int32_t k,xsb;\n-\t__uint32_t hx;\n+\tint32_t k,xsb;\n+\tuint32_t hx;\n \n \tGET_HIGH_WORD(hx,x);\n \txsb = (hx>>31)&1;\t\t/* sign bit of x */\n@@ -119,9 +119,9 @@ P5   =  4.13813679705723846039e-08; /* 0x3E663769, 0x72BEA4D0 */\n     /* filter out non-finite argument */\n \tif(hx >= 0x40862E42) {\t\t\t/* if |x|>=709.78... */\n             if(hx>=0x7ff00000) {\n-\t        __uint32_t lx;\n+\t        uint32_t lx;\n \t\tGET_LOW_WORD(lx,x);\n-\t\tif(((hx&0xfffff)|lx)!=0) \n+\t\tif(((hx&0xfffff)|lx)!=0)\n \t\t     return x+x; \t\t/* NaN */\n \t\telse return (xsb==0)? x:0.0;\t/* exp(+-inf)={inf,0} */\n \t    }\n@@ -130,7 +130,7 @@ P5   =  4.13813679705723846039e-08; /* 0x3E663769, 0x72BEA4D0 */\n \t}\n \n     /* argument reduction */\n-\tif(hx > 0x3fd62e42) {\t\t/* if  |x| > 0.5 ln2 */ \n+\tif(hx > 0x3fd62e42) {\t\t/* if  |x| > 0.5 ln2 */\n \t    if(hx < 0x3FF0A2B2) {\t/* and |x| < 1.5 ln2 */\n \t\thi = x-ln2HI[xsb]; lo=ln2LO[xsb]; k = 1-xsb-xsb;\n \t    } else {\n@@ -140,7 +140,7 @@ P5   =  4.13813679705723846039e-08; /* 0x3E663769, 0x72BEA4D0 */\n \t\tlo = t*ln2LO[0];\n \t    }\n \t    x  = hi - lo;\n-\t} \n+\t}\n \telse if(hx < 0x3e300000)  {\t/* when |x|<2**-28 */\n \t    if(huge+x>one) return one+x;/* trigger inexact */\n \t}\n@@ -149,15 +149,15 @@ P5   =  4.13813679705723846039e-08; /* 0x3E663769, 0x72BEA4D0 */\n     /* x is now in primary range */\n \tt  = x*x;\n \tc  = x - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));\n-\tif(k==0) \treturn one-((x*c)/(c-2.0)-x); \n+\tif(k==0) \treturn one-((x*c)/(c-2.0)-x);\n \telse \t\ty = one-((lo-(x*c)/(2.0-c))-hi);\n \tif(k >= -1021) {\n-\t    __uint32_t hy;\n+\t    uint32_t hy;\n \t    GET_HIGH_WORD(hy,y);\n \t    SET_HIGH_WORD(y,hy+(k<<20));\t/* add k to y's exponent */\n \t    return y;\n \t} else {\n-\t    __uint32_t hy;\n+\t    uint32_t hy;\n \t    GET_HIGH_WORD(hy,y);\n \t    SET_HIGH_WORD(y,hy+((k+1000)<<20));\t/* add k to y's exponent */\n \t    return y*twom1000;"}, {"sha": "1cf099076668e48315f640403e520fea5ce22e36", "filename": "libjava/java/lang/e_fmod.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_fmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_fmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_fmod.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,12 +6,12 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n \n-/* \n+/*\n  * __ieee754_fmod(x,y)\n  * Return x mod y in exact arithmetic\n  * Method: shift and subtract\n@@ -34,8 +34,8 @@ static double one = 1.0, Zero[] = {0.0, -0.0,};\n \tdouble x,y ;\n #endif\n {\n-\t__int32_t n,hx,hy,hz,ix,iy,sx,i;\n-\t__uint32_t lx,ly,lz;\n+\tint32_t n,hx,hy,hz,ix,iy,sx,i;\n+\tuint32_t lx,ly,lz;\n \n \tEXTRACT_WORDS(hx,lx,x);\n \tEXTRACT_WORDS(hy,ly,y);\n@@ -49,8 +49,8 @@ static double one = 1.0, Zero[] = {0.0, -0.0,};\n \t    return (x*y)/(x*y);\n \tif(hx<=hy) {\n \t    if((hx<hy)||(lx<ly)) return x;\t/* |x|<|y| return x */\n-\t    if(lx==ly) \n-\t\treturn Zero[(__uint32_t)sx>>31];\t/* |x|=|y| return x*0*/\n+\t    if(lx==ly)\n+\t\treturn Zero[(uint32_t)sx>>31];\t/* |x|=|y| return x*0*/\n \t}\n \n     /* determine ix = ilogb(x) */\n@@ -72,7 +72,7 @@ static double one = 1.0, Zero[] = {0.0, -0.0,};\n \t} else iy = (hy>>20)-1023;\n \n     /* set up {hx,lx}, {hy,ly} and align y to x */\n-\tif(ix >= -1022) \n+\tif(ix >= -1022)\n \t    hx = 0x00100000|(0x000fffff&hx);\n \telse {\t\t/* subnormal x, shift x to normal */\n \t    n = -1022-ix;\n@@ -84,7 +84,7 @@ static double one = 1.0, Zero[] = {0.0, -0.0,};\n \t\tlx = 0;\n \t    }\n \t}\n-\tif(iy >= -1022) \n+\tif(iy >= -1022)\n \t    hy = 0x00100000|(0x000fffff&hy);\n \telse {\t\t/* subnormal y, shift y to normal */\n \t    n = -1022-iy;\n@@ -104,7 +104,7 @@ static double one = 1.0, Zero[] = {0.0, -0.0,};\n \t    if(hz<0){hx = hx+hx+(lx>>31); lx = lx+lx;}\n \t    else {\n \t    \tif((hz|lz)==0) \t\t/* return sign(x)*0 */\n-\t\t    return Zero[(__uint32_t)sx>>31];\n+\t\t    return Zero[(uint32_t)sx>>31];\n \t    \thx = hz+hz+(lz>>31); lx = lz+lz;\n \t    }\n \t}\n@@ -113,7 +113,7 @@ static double one = 1.0, Zero[] = {0.0, -0.0,};\n \n     /* convert back to floating value and restore the sign */\n \tif((hx|lx)==0) \t\t\t/* return sign(x)*0 */\n-\t    return Zero[(__uint32_t)sx>>31];\t\n+\t    return Zero[(uint32_t)sx>>31];\n \twhile(hx<0x00100000) {\t\t/* normalize x */\n \t    hx = hx+hx+(lx>>31); lx = lx+lx;\n \t    iy -= 1;\n@@ -124,7 +124,7 @@ static double one = 1.0, Zero[] = {0.0, -0.0,};\n \t} else {\t\t/* subnormal output */\n \t    n = -1022 - iy;\n \t    if(n<=20) {\n-\t\tlx = (lx>>n)|((__uint32_t)hx<<(32-n));\n+\t\tlx = (lx>>n)|((uint32_t)hx<<(32-n));\n \t\thx >>= n;\n \t    } else if (n<=31) {\n \t\tlx = (hx<<(32-n))|(lx>>n); hx = sx;"}, {"sha": "093473e1048f5541cd64bdf2e1a9316203e6a81a", "filename": "libjava/java/lang/e_log.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_log.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_log.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_log.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,48 +6,48 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n \n /* __ieee754_log(x)\n  * Return the logrithm of x\n  *\n- * Method :                  \n- *   1. Argument Reduction: find k and f such that \n- *\t\t\tx = 2^k * (1+f), \n+ * Method :\n+ *   1. Argument Reduction: find k and f such that\n+ *\t\t\tx = 2^k * (1+f),\n  *\t   where  sqrt(2)/2 < 1+f < sqrt(2) .\n  *\n  *   2. Approximation of log(1+f).\n  *\tLet s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)\n  *\t\t = 2s + 2/3 s**3 + 2/5 s**5 + .....,\n  *\t     \t = 2s + s*R\n- *      We use a special Reme algorithm on [0,0.1716] to generate \n- * \ta polynomial of degree 14 to approximate R The maximum error \n+ *      We use a special Reme algorithm on [0,0.1716] to generate\n+ * \ta polynomial of degree 14 to approximate R The maximum error\n  *\tof this polynomial approximation is bounded by 2**-58.45. In\n  *\tother words,\n  *\t\t        2      4      6      8      10      12      14\n  *\t    R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s\n  *  \t(the values of Lg1 to Lg7 are listed in the program)\n  *\tand\n  *\t    |      2          14          |     -58.45\n- *\t    | Lg1*s +...+Lg7*s    -  R(z) | <= 2 \n+ *\t    | Lg1*s +...+Lg7*s    -  R(z) | <= 2\n  *\t    |                             |\n  *\tNote that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.\n  *\tIn order to guarantee error in log below 1ulp, we compute log\n  *\tby\n  *\t\tlog(1+f) = f - s*(f - R)\t(if f is not too large)\n  *\t\tlog(1+f) = f - (hfsq - s*(hfsq+R)).\t(better accuracy)\n- *\t\n- *\t3. Finally,  log(x) = k*ln2 + log(1+f).  \n+ *\n+ *\t3. Finally,  log(x) = k*ln2 + log(1+f).\n  *\t\t\t    = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))\n- *\t   Here ln2 is split into two floating point number: \n+ *\t   Here ln2 is split into two floating point number:\n  *\t\t\tln2_hi + ln2_lo,\n  *\t   where n*ln2_hi is always exact for |n| < 2000.\n  *\n  * Special cases:\n- *\tlog(x) is NaN with signal if x < 0 (including -INF) ; \n+ *\tlog(x) is NaN with signal if x < 0 (including -INF) ;\n  *\tlog(+INF) is +INF; log(0) is -INF with signal;\n  *\tlog(NaN) is that NaN with no signal.\n  *\n@@ -56,9 +56,9 @@\n  *\t1 ulp (unit in the last place).\n  *\n  * Constants:\n- * The hexadecimal values are the intended ones for the following \n- * constants. The decimal values may be used, provided that the \n- * compiler will convert from decimal to binary accurately enough \n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n  * to produce the hexadecimal values shown.\n  */\n \n@@ -96,19 +96,19 @@ static double zero   =  0.0;\n #endif\n {\n \tdouble hfsq,f,s,z,R,w,t1,t2,dk;\n-\t__int32_t k,hx,i,j;\n-\t__uint32_t lx;\n+\tint32_t k,hx,i,j;\n+\tuint32_t lx;\n \n \tEXTRACT_WORDS(hx,lx,x);\n \n \tk=0;\n \tif (hx < 0x00100000) {\t\t\t/* x < 2**-1022  */\n-\t    if (((hx&0x7fffffff)|lx)==0) \n+\t    if (((hx&0x7fffffff)|lx)==0)\n \t\treturn -two54/zero;\t\t/* log(+-0)=-inf */\n \t    if (hx<0) return (x-x)/zero;\t/* log(-#) = NaN */\n \t    k -= 54; x *= two54; /* subnormal number, scale up x */\n \t    GET_HIGH_WORD(hx,x);\n-\t} \n+\t}\n \tif (hx >= 0x7ff00000) return x+x;\n \tk += (hx>>20)-1023;\n \thx &= 0x000fffff;\n@@ -129,14 +129,14 @@ static double zero   =  0.0;\n \t    if(k==0) return f-R; else {dk=(double)k;\n \t    \t     return dk*ln2_hi-((R-dk*ln2_lo)-f);}\n \t}\n- \ts = f/(2.0+f); \n+ \ts = f/(2.0+f);\n \tdk = (double)k;\n \tz = s*s;\n \ti = hx-0x6147a;\n \tw = z*z;\n \tj = 0x6b851-hx;\n-\tt1= w*(Lg2+w*(Lg4+w*Lg6)); \n-\tt2= z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7))); \n+\tt1= w*(Lg2+w*(Lg4+w*Lg6));\n+\tt2= z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7)));\n \ti |= j;\n \tR = t2+t1;\n \tif(i>0) {"}, {"sha": "e53a8a287cc4bf2835ef61351615d655e57bf520", "filename": "libjava/java/lang/e_pow.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_pow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_pow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_pow.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -18,7 +18,7 @@\n  *\t1. Compute and return log2(x) in two pieces:\n  *\t\tlog2(x) = w1 + w2,\n  *\t   where w1 has 53-24 = 29 bit trailing zeros.\n- *\t2. Perform y*log2(x) = n+y' by simulating muti-precision \n+ *\t2. Perform y*log2(x) = n+y' by simulating muti-precision\n  *\t   arithmetic, where |y'|<=0.5.\n  *\t3. Return x**y = 2**n*exp(y'*log2)\n  *\n@@ -46,13 +46,13 @@\n  * Accuracy:\n  *\tpow(x,y) returns x**y nearly rounded. In particular\n  *\t\t\tpow(integer,integer)\n- *\talways returns the correct integer provided it is \n+ *\talways returns the correct integer provided it is\n  *\trepresentable.\n  *\n  * Constants :\n- * The hexadecimal values are the intended ones for the following \n- * constants. The decimal values may be used, provided that the \n- * compiler will convert from decimal to binary accurately enough \n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n  * to produce the hexadecimal values shown.\n  */\n \n@@ -61,9 +61,9 @@\n #ifndef _DOUBLE_IS_32BITS\n \n #ifdef __STDC__\n-static const double \n+static const double\n #else\n-static double \n+static double\n #endif\n bp[] = {1.0, 1.5,},\n dp_h[] = { 0.0, 5.84962487220764160156e-01,}, /* 0x3FE2B803, 0x40000000 */\n@@ -106,59 +106,59 @@ ivln2_l  =  1.92596299112661746887e-08; /* 0x3E54AE0B, 0xF85DDF44 =1/ln2 tail*/\n {\n \tdouble z,ax,z_h,z_l,p_h,p_l;\n \tdouble y1,t1,t2,r,s,t,u,v,w;\n-\t__int32_t i,j,k,yisint,n;\n-\t__int32_t hx,hy,ix,iy;\n-\t__uint32_t lx,ly;\n+\tint32_t i,j,k,yisint,n;\n+\tint32_t hx,hy,ix,iy;\n+\tuint32_t lx,ly;\n \n \tEXTRACT_WORDS(hx,lx,x);\n \tEXTRACT_WORDS(hy,ly,y);\n \tix = hx&0x7fffffff;  iy = hy&0x7fffffff;\n \n     /* y==zero: x**0 = 1 */\n-\tif((iy|ly)==0) return one; \t\n+\tif((iy|ly)==0) return one;\n \n     /* +-NaN return x+y */\n \tif(ix > 0x7ff00000 || ((ix==0x7ff00000)&&(lx!=0)) ||\n-\t   iy > 0x7ff00000 || ((iy==0x7ff00000)&&(ly!=0))) \n-\t\treturn x+y;\t\n+\t   iy > 0x7ff00000 || ((iy==0x7ff00000)&&(ly!=0)))\n+\t\treturn x+y;\n \n     /* determine if y is an odd int when x < 0\n      * yisint = 0\t... y is not an integer\n      * yisint = 1\t... y is an odd int\n      * yisint = 2\t... y is an even int\n      */\n \tyisint  = 0;\n-\tif(hx<0) {\t\n+\tif(hx<0) {\n \t    if(iy>=0x43400000) yisint = 2; /* even integer y */\n \t    else if(iy>=0x3ff00000) {\n \t\tk = (iy>>20)-0x3ff;\t   /* exponent */\n \t\tif(k>20) {\n \t\t    j = ly>>(52-k);\n-\t\t    if((__uint32_t)(j<<(52-k))==ly) yisint = 2-(j&1);\n+\t\t    if((uint32_t)(j<<(52-k))==ly) yisint = 2-(j&1);\n \t\t} else if(ly==0) {\n \t\t    j = iy>>(20-k);\n \t\t    if((j<<(20-k))==iy) yisint = 2-(j&1);\n \t\t}\n-\t    }\t\t\n-\t} \n+\t    }\n+\t}\n \n     /* special value of y */\n-\tif(ly==0) { \t\n+\tif(ly==0) {\n \t    if (iy==0x7ff00000) {\t/* y is +-inf */\n \t        if(((ix-0x3ff00000)|lx)==0)\n \t\t    return  y - y;\t/* inf**+-1 is NaN */\n \t        else if (ix >= 0x3ff00000)/* (|x|>1)**+-inf = inf,0 */\n \t\t    return (hy>=0)? y: zero;\n \t        else\t\t\t/* (|x|<1)**-,+inf = inf,0 */\n \t\t    return (hy<0)?-y: zero;\n-\t    } \n+\t    }\n \t    if(iy==0x3ff00000) {\t/* y is  +-1 */\n \t\tif(hy<0) return one/x; else return x;\n \t    }\n \t    if(hy==0x40000000) return x*x; /* y is  2 */\n \t    if(hy==0x3fe00000) {\t/* y is  0.5 */\n \t\tif(hx>=0)\t/* x >= +0 */\n-\t\treturn __ieee754_sqrt(x);\t\n+\t\treturn __ieee754_sqrt(x);\n \t    }\n \t}\n \n@@ -171,19 +171,19 @@ ivln2_l  =  1.92596299112661746887e-08; /* 0x3E54AE0B, 0xF85DDF44 =1/ln2 tail*/\n \t\tif(hx<0) {\n \t\t    if(((ix-0x3ff00000)|yisint)==0) {\n \t\t\tz = (z-z)/(z-z); /* (-1)**non-int is NaN */\n-\t\t    } else if(yisint==1) \n+\t\t    } else if(yisint==1)\n \t\t\tz = -z;\t\t/* (x<0)**odd = -(|x|**odd) */\n \t\t}\n \t\treturn z;\n \t    }\n \t}\n-    \n+\n     /* (x<0)**(non-int) is NaN */\n     /* CYGNUS LOCAL: This used to be\n \tif((((hx>>31)+1)|yisint)==0) return (x-x)/(x-x);\n        but ANSI C says a right shift of a signed negative quantity is\n        implementation defined.  */\n-\tif(((((__uint32_t)hx>>31)-1)|yisint)==0) return (x-x)/(x-x);\n+\tif(((((uint32_t)hx>>31)-1)|yisint)==0) return (x-x)/(x-x);\n \n     /* |y| is huge */\n \tif(iy>0x41e00000) { /* if |y| > 2**31 */\n@@ -194,7 +194,7 @@ ivln2_l  =  1.92596299112661746887e-08; /* 0x3E54AE0B, 0xF85DDF44 =1/ln2 tail*/\n \t/* over/underflow if x is not close to one */\n \t    if(ix<0x3fefffff) return (hy<0)? huge*huge:tiny*tiny;\n \t    if(ix>0x3ff00000) return (hy>0)? huge*huge:tiny*tiny;\n-\t/* now |1-x| is tiny <= 2**-20, suffice to compute \n+\t/* now |1-x| is tiny <= 2**-20, suffice to compute\n \t   log(x) by x-x^2/2+x^3/3-x^4/4 */\n \t    t = x-1;\t\t/* t has 20 trailing zeros */\n \t    w = (t*t)*(0.5-t*(0.3333333333333333333333-t*0.25));\n@@ -254,7 +254,7 @@ ivln2_l  =  1.92596299112661746887e-08; /* 0x3E54AE0B, 0xF85DDF44 =1/ln2 tail*/\n \t}\n \n \ts = one; /* s (sign of result -ve**odd) = -1 else = 1 */\n-\tif(((((__uint32_t)hx>>31)-1)|(yisint-1))==0)\n+\tif(((((uint32_t)hx>>31)-1)|(yisint-1))==0)\n \t    s = -one;/* (-ve)**(odd int) */\n \n     /* split up y into y1+y2 and compute (y1+y2)*(t1+t2) */\n@@ -291,7 +291,7 @@ ivln2_l  =  1.92596299112661746887e-08; /* 0x3E54AE0B, 0xF85DDF44 =1/ln2 tail*/\n \t    n = ((n&0x000fffff)|0x00100000)>>(20-k);\n \t    if(j<0) n = -n;\n \t    p_h -= t;\n-\t} \n+\t}\n \tt = p_l+p_h;\n \tSET_LOW_WORD(t,0);\n \tu = t*lg2_h;"}, {"sha": "6d3fd19a48cc4a91efb299758ff4a93edc34e9d5", "filename": "libjava/java/lang/e_rem_pio2.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_rem_pio2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_rem_pio2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_rem_pio2.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,15 +6,15 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  *\n  */\n \n /* __ieee754_rem_pio2(x,y)\n- * \n- * return the remainder of x rem pi/2 in y[0]+y[1] \n+ *\n+ * return the remainder of x rem pi/2 in y[0]+y[1]\n  * use __kernel_rem_pio2()\n  */\n \n@@ -23,30 +23,30 @@\n #ifndef _DOUBLE_IS_32BITS\n \n /*\n- * Table of constants for 2/pi, 396 Hex digits (476 decimal) of 2/pi \n+ * Table of constants for 2/pi, 396 Hex digits (476 decimal) of 2/pi\n  */\n #ifdef __STDC__\n-static const __int32_t two_over_pi[] = {\n+static const int32_t two_over_pi[] = {\n #else\n-static __int32_t two_over_pi[] = {\n+static int32_t two_over_pi[] = {\n #endif\n-0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62, \n-0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7, 0x246E3A, \n-0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129, \n-0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C, 0x7026B4, 0x5F7E41, \n-0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8, \n-0x97FFDE, 0x05980F, 0xEF2F11, 0x8B5A0A, 0x6D1F6D, 0x367ECF, \n-0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5, \n-0xF17B3D, 0x0739F7, 0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08, \n-0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3, \n-0x91615E, 0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880, \n-0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B, \n+0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62,\n+0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7, 0x246E3A,\n+0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129,\n+0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C, 0x7026B4, 0x5F7E41,\n+0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8,\n+0x97FFDE, 0x05980F, 0xEF2F11, 0x8B5A0A, 0x6D1F6D, 0x367ECF,\n+0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5,\n+0xF17B3D, 0x0739F7, 0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08,\n+0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3,\n+0x91615E, 0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880,\n+0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B,\n };\n \n #ifdef __STDC__\n-static const __int32_t npio2_hw[] = {\n+static const int32_t npio2_hw[] = {\n #else\n-static __int32_t npio2_hw[] = {\n+static int32_t npio2_hw[] = {\n #endif\n 0x3FF921FB, 0x400921FB, 0x4012D97C, 0x401921FB, 0x401F6A7A, 0x4022D97C,\n 0x4025FDBB, 0x402921FB, 0x402C463A, 0x402F6A7A, 0x4031475C, 0x4032D97C,\n@@ -67,9 +67,9 @@ static __int32_t npio2_hw[] = {\n  */\n \n #ifdef __STDC__\n-static const double \n+static const double\n #else\n-static double \n+static double\n #endif\n zero =  0.00000000000000000000e+00, /* 0x00000000, 0x00000000 */\n half =  5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */\n@@ -83,24 +83,24 @@ pio2_3  =  2.02226624871116645580e-21, /* 0x3BA3198A, 0x2E000000 */\n pio2_3t =  8.47842766036889956997e-32; /* 0x397B839A, 0x252049C1 */\n \n #ifdef __STDC__\n-\t__int32_t __ieee754_rem_pio2(double x, double *y)\n+\tint32_t __ieee754_rem_pio2(double x, double *y)\n #else\n-\t__int32_t __ieee754_rem_pio2(x,y)\n+\tint32_t __ieee754_rem_pio2(x,y)\n \tdouble x,y[];\n #endif\n {\n \tdouble z,w,t,r,fn;\n \tdouble tx[3];\n-\t__int32_t i,j,n,ix,hx;\n+\tint32_t i,j,n,ix,hx;\n \tint e0,nx;\n-\t__uint32_t low;\n+\tuint32_t low;\n \n \tGET_HIGH_WORD(hx,x);\t\t/* high word of x */\n \tix = hx&0x7fffffff;\n \tif(ix<=0x3fe921fb)   /* |x| ~<= pi/4 , no need for reduction */\n \t    {y[0] = x; y[1] = 0; return 0;}\n \tif(ix<0x4002d97c) {  /* |x| < 3pi/4, special case with n=+-1 */\n-\t    if(hx>0) { \n+\t    if(hx>0) {\n \t\tz = x - pio2_1;\n \t\tif(ix!=0x3ff921fb) { \t/* 33+53 bit pi is good enough */\n \t\t    y[0] = z - pio2_1t;\n@@ -126,31 +126,31 @@ pio2_3t =  8.47842766036889956997e-32; /* 0x397B839A, 0x252049C1 */\n \t}\n \tif(ix<=0x413921fb) { /* |x| ~<= 2^19*(pi/2), medium size */\n \t    t  = fabs(x);\n-\t    n  = (__int32_t) (t*invpio2+half);\n+\t    n  = (int32_t) (t*invpio2+half);\n \t    fn = (double)n;\n \t    r  = t-fn*pio2_1;\n \t    w  = fn*pio2_1t;\t/* 1st round good to 85 bit */\n-\t    if(n<32&&ix!=npio2_hw[n-1]) {\t\n+\t    if(n<32&&ix!=npio2_hw[n-1]) {\n \t\ty[0] = r-w;\t/* quick check no cancellation */\n \t    } else {\n-\t        __uint32_t high;\n+\t        uint32_t high;\n \t        j  = ix>>20;\n-\t        y[0] = r-w; \n+\t        y[0] = r-w;\n \t\tGET_HIGH_WORD(high,y[0]);\n \t        i = j-((high>>20)&0x7ff);\n \t        if(i>16) {  /* 2nd iteration needed, good to 118 */\n \t\t    t  = r;\n-\t\t    w  = fn*pio2_2;\t\n+\t\t    w  = fn*pio2_2;\n \t\t    r  = t-w;\n-\t\t    w  = fn*pio2_2t-((t-r)-w);\t\n+\t\t    w  = fn*pio2_2t-((t-r)-w);\n \t\t    y[0] = r-w;\n \t\t    GET_HIGH_WORD(high,y[0]);\n \t\t    i = j-((high>>20)&0x7ff);\n \t\t    if(i>49)  {\t/* 3rd iteration need, 151 bits acc */\n \t\t    \tt  = r;\t/* will cover all possible cases */\n-\t\t    \tw  = fn*pio2_3;\t\n+\t\t    \tw  = fn*pio2_3;\n \t\t    \tr  = t-w;\n-\t\t    \tw  = fn*pio2_3t-((t-r)-w);\t\n+\t\t    \tw  = fn*pio2_3t-((t-r)-w);\n \t\t    \ty[0] = r-w;\n \t\t    }\n \t\t}\n@@ -159,7 +159,7 @@ pio2_3t =  8.47842766036889956997e-32; /* 0x397B839A, 0x252049C1 */\n \t    if(hx<0) \t{y[0] = -y[0]; y[1] = -y[1]; return -n;}\n \t    else\t return n;\n \t}\n-    /* \n+    /*\n      * all other (large) arguments\n      */\n \tif(ix>=0x7ff00000) {\t\t/* x is inf or NaN */\n@@ -169,9 +169,9 @@ pio2_3t =  8.47842766036889956997e-32; /* 0x397B839A, 0x252049C1 */\n \tGET_LOW_WORD(low,x);\n \tSET_LOW_WORD(z,low);\n \te0 \t= (int)((ix>>20)-1046);\t/* e0 = ilogb(z)-23; */\n-\tSET_HIGH_WORD(z, ix - ((__int32_t)e0<<20));\n+\tSET_HIGH_WORD(z, ix - ((int32_t)e0<<20));\n \tfor(i=0;i<2;i++) {\n-\t\ttx[i] = (double)((__int32_t)(z));\n+\t\ttx[i] = (double)((int32_t)(z));\n \t\tz     = (z-tx[i])*two24;\n \t}\n \ttx[2] = z;"}, {"sha": "4716d8d05fd22afcb6e02984b009ee57411db447", "filename": "libjava/java/lang/e_remainder.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_remainder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_remainder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_remainder.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,17 +6,17 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n \n /* __ieee754_remainder(x,p)\n- * Return :                  \n- * \treturns  x REM p  =  x - [x/p]*p as if in infinite \n- * \tprecise arithmetic, where [x/p] is the (infinite bit) \n+ * Return :\n+ * \treturns  x REM p  =  x - [x/p]*p as if in infinite\n+ * \tprecise arithmetic, where [x/p] is the (infinite bit)\n  *\tinteger nearest x/p (in half way case choose the even one).\n- * Method : \n+ * Method :\n  *\tBased on fmod() return x-[x/p]chopped*p exactlp.\n  */\n \n@@ -38,8 +38,8 @@ static double zero = 0.0;\n \tdouble x,p;\n #endif\n {\n-\t__int32_t hx,hp;\n-\t__uint32_t sx,lx,lp;\n+\tint32_t hx,hp;\n+\tuint32_t sx,lx,lp;\n \tdouble p_half;\n \n \tEXTRACT_WORDS(hx,lx,x);"}, {"sha": "1d566a0847e39b5c88a7ab34b1969681642850f5", "filename": "libjava/java/lang/e_sqrt.c", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_sqrt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fe_sqrt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fe_sqrt.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -16,10 +16,10 @@\n  *           ------------------------------------------\n  *\t     |  Use the hardware sqrt if you have one |\n  *           ------------------------------------------\n- * Method: \n- *   Bit by bit method using integer arithmetic. (Slow, but portable) \n+ * Method:\n+ *   Bit by bit method using integer arithmetic. (Slow, but portable)\n  *   1. Normalization\n- *\tScale x to y in [1,4) with even powers of 2: \n+ *\tScale x to y in [1,4) with even powers of 2:\n  *\tfind an integer k such that  1 <= (y=x*2^(2k)) < 4, then\n  *\t\tsqrt(x) = 2^k * sqrt(y)\n  *   2. Bit by bit computation\n@@ -28,9 +28,9 @@\n  *                                     i+1         2\n  *\t    s  = 2*q , and\ty  =  2   * ( y - q  ).\t\t(1)\n  *\t     i      i            i                 i\n- *                                                        \n- *\tTo compute q    from q , one checks whether \n- *\t\t    i+1       i                       \n+ *\n+ *\tTo compute q    from q , one checks whether\n+ *\t\t    i+1       i\n  *\n  *\t\t\t      -(i+1) 2\n  *\t\t\t(q + 2      ) <= y.\t\t\t(2)\n@@ -40,12 +40,12 @@\n  *\t\t \t       i+1   i             i+1   i\n  *\n  *\tWith some algebric manipulation, it is not difficult to see\n- *\tthat (2) is equivalent to \n+ *\tthat (2) is equivalent to\n  *                             -(i+1)\n  *\t\t\ts  +  2       <= y\t\t\t(3)\n  *\t\t\t i                i\n  *\n- *\tThe advantage of (3) is that s  and y  can be computed by \n+ *\tThe advantage of (3) is that s  and y  can be computed by\n  *\t\t\t\t      i      i\n  *\tthe following recurrence formula:\n  *\t    if (3) is false\n@@ -57,10 +57,10 @@\n  *                         -i                     -(i+1)\n  *\t    s\t  =  s  + 2  ,  y    = y  -  s  - 2  \t\t(5)\n  *           i+1      i          i+1    i     i\n- *\t\t\t\t\n- *\tOne may easily use induction to prove (4) and (5). \n+ *\n+ *\tOne may easily use induction to prove (4) and (5).\n  *\tNote. Since the left hand side of (3) contain only i+2 bits,\n- *\t      it does not necessary to do a full (53-bit) comparison \n+ *\t      it does not necessary to do a full (53-bit) comparison\n  *\t      in (3).\n  *   3. Final rounding\n  *\tAfter generating the 53 bits result, we compute one more bit.\n@@ -70,7 +70,7 @@\n  *\tThe rounding mode can be detected by checking whether\n  *\thuge + tiny is equal to huge, and whether huge - tiny is\n  *\tequal to huge for some floating point number \"huge\" and \"tiny\".\n- *\t\t\n+ *\n  * Special cases:\n  *\tsqrt(+-0) = +-0 \t... exact\n  *\tsqrt(inf) = inf\n@@ -99,17 +99,17 @@ static\tdouble\tone\t= 1.0, tiny=1.0e-300;\n #endif\n {\n \tdouble z;\n-\t__int32_t sign = (int)0x80000000; \n-\t__uint32_t r,t1,s1,ix1,q1;\n-\t__int32_t ix0,s0,q,m,t,i;\n+\tint32_t sign = (int)0x80000000;\n+\tuint32_t r,t1,s1,ix1,q1;\n+\tint32_t ix0,s0,q,m,t,i;\n \n \tEXTRACT_WORDS(ix0,ix1,x);\n \n     /* take care of Inf and NaN */\n-\tif((ix0&0x7ff00000)==0x7ff00000) {\t\t\t\n+\tif((ix0&0x7ff00000)==0x7ff00000) {\n \t    return x*x+x;\t\t/* sqrt(NaN)=NaN, sqrt(+inf)=+inf\n \t\t\t\t\t   sqrt(-inf)=sNaN */\n-\t} \n+\t}\n     /* take care of zero */\n \tif(ix0<=0) {\n \t    if(((ix0&(~sign))|ix1)==0) return x;/* sqrt(+-0) = +-0 */\n@@ -143,24 +143,24 @@ static\tdouble\tone\t= 1.0, tiny=1.0e-300;\n \tr = 0x00200000;\t\t/* r = moving bit from right to left */\n \n \twhile(r!=0) {\n-\t    t = s0+r; \n-\t    if(t<=ix0) { \n-\t\ts0   = t+r; \n-\t\tix0 -= t; \n-\t\tq   += r; \n-\t    } \n+\t    t = s0+r;\n+\t    if(t<=ix0) {\n+\t\ts0   = t+r;\n+\t\tix0 -= t;\n+\t\tq   += r;\n+\t    }\n \t    ix0 += ix0 + ((ix1&sign)>>31);\n \t    ix1 += ix1;\n \t    r>>=1;\n \t}\n \n \tr = sign;\n \twhile(r!=0) {\n-\t    t1 = s1+r; \n+\t    t1 = s1+r;\n \t    t  = s0;\n-\t    if((t<ix0)||((t==ix0)&&(t1<=ix1))) { \n+\t    if((t<ix0)||((t==ix0)&&(t1<=ix1))) {\n \t\ts1  = t1+r;\n-\t\tif(((t1&sign)==(__uint32_t)sign)&&(s1&sign)==0) s0 += 1;\n+\t\tif(((t1&sign)==(uint32_t)sign)&&(s1&sign)==0) s0 += 1;\n \t\tix0 -= t;\n \t\tif (ix1 < t1) ix0 -= 1;\n \t\tix1 -= t1;\n@@ -176,10 +176,10 @@ static\tdouble\tone\t= 1.0, tiny=1.0e-300;\n \t    z = one-tiny; /* trigger inexact flag */\n \t    if (z>=one) {\n \t        z = one+tiny;\n-\t        if (q1==(__uint32_t)0xffffffff) { q1=0; q += 1;}\n+\t        if (q1==(uint32_t)0xffffffff) { q1=0; q += 1;}\n \t\telse if (z>one) {\n-\t\t    if (q1==(__uint32_t)0xfffffffe) q+=1;\n-\t\t    q1+=2; \n+\t\t    if (q1==(uint32_t)0xfffffffe) q+=1;\n+\t\t    q1+=2;\n \t\t} else\n \t            q1 += (q1&1);\n \t    }\n@@ -191,24 +191,24 @@ static\tdouble\tone\t= 1.0, tiny=1.0e-300;\n \tINSERT_WORDS(z,ix0,ix1);\n \treturn z;\n }\n- \n+\n #endif /* defined(_DOUBLE_IS_32BITS) */\n \n /*\n Other methods  (use floating-point arithmetic)\n -------------\n-(This is a copy of a drafted paper by Prof W. Kahan \n+(This is a copy of a drafted paper by Prof W. Kahan\n and K.C. Ng, written in May, 1986)\n \n-\tTwo algorithms are given here to implement sqrt(x) \n+\tTwo algorithms are given here to implement sqrt(x)\n \t(IEEE double precision arithmetic) in software.\n \tBoth supply sqrt(x) correctly rounded. The first algorithm (in\n \tSection A) uses newton iterations and involves four divisions.\n \tThe second one uses reciproot iterations to avoid division, but\n \trequires more multiplications. Both algorithms need the ability\n-\tto chop results of arithmetic operations instead of round them, \n+\tto chop results of arithmetic operations instead of round them,\n \tand the INEXACT flag to indicate when an arithmetic operation\n-\tis executed exactly with no roundoff error, all part of the \n+\tis executed exactly with no roundoff error, all part of the\n \tstandard (IEEE 754-1985). The ability to perform shift, add,\n \tsubtract and logical AND operations upon 32-bit words is needed\n \ttoo, though not part of the standard.\n@@ -218,15 +218,15 @@ A.  sqrt(x) by Newton Iteration\n    (1)\tInitial approximation\n \n \tLet x0 and x1 be the leading and the trailing 32-bit words of\n-\ta floating point number x (in IEEE double format) respectively \n+\ta floating point number x (in IEEE double format) respectively\n \n \t    1    11\t\t     52\t\t\t\t  ...widths\n \t   ------------------------------------------------------\n \tx: |s|\t  e     |\t      f\t\t\t\t|\n \t   ------------------------------------------------------\n \t      msb    lsb  msb\t\t\t\t      lsb ...order\n \n- \n+\n \t     ------------------------  \t     ------------------------\n \tx0:  |s|   e    |    f1     |\t x1: |          f2           |\n \t     ------------------------  \t     ------------------------\n@@ -251,7 +251,7 @@ A.  sqrt(x) by Newton Iteration\n \n     (2)\tIterative refinement\n \n-\tApply Heron's rule three times to y, we have y approximates \n+\tApply Heron's rule three times to y, we have y approximates\n \tsqrt(x) to within 1 ulp (Unit in the Last Place):\n \n \t\ty := (y+x/y)/2\t\t... almost 17 sig. bits\n@@ -276,12 +276,12 @@ A.  sqrt(x) by Newton Iteration\n \tit requires more multiplications and additions. Also x must be\n \tscaled in advance to avoid spurious overflow in evaluating the\n \texpression 3y*y+x. Hence it is not recommended uless division\n-\tis slow. If division is very slow, then one should use the \n+\tis slow. If division is very slow, then one should use the\n \treciproot algorithm given in section B.\n \n     (3) Final adjustment\n \n-\tBy twiddling y's last bit it is possible to force y to be \n+\tBy twiddling y's last bit it is possible to force y to be\n \tcorrectly rounded according to the prevailing rounding mode\n \tas follows. Let r and i be copies of the rounding mode and\n \tinexact flag before entering the square root program. Also we\n@@ -312,7 +312,7 @@ A.  sqrt(x) by Newton Iteration\n \t        I := i;\t \t\t... restore inexact flag\n \t        R := r;  \t\t... restore rounded mode\n \t        return sqrt(x):=y.\n-\t\t    \n+\n     (4)\tSpecial cases\n \n \tSquare root of +inf, +-0, or NaN is itself;\n@@ -331,7 +331,7 @@ B.  sqrt(x) by Reciproot Iteration\n \t    k := 0x5fe80000 - (x0>>1);\n \t    y0:= k - T2[63&(k>>14)].\t... y ~ 1/sqrt(x) to 7.8 bits\n \n-\tHere k is a 32-bit integer and T2[] is an integer array \n+\tHere k is a 32-bit integer and T2[] is an integer array\n \tcontaining correction terms. Now magically the floating\n \tvalue of y (y's leading 32-bit word is y0, the value of\n \tits trailing word y1 is set to zero) approximates 1/sqrt(x)\n@@ -352,9 +352,9 @@ B.  sqrt(x) by Reciproot Iteration\n \n \tApply Reciproot iteration three times to y and multiply the\n \tresult by x to get an approximation z that matches sqrt(x)\n-\tto about 1 ulp. To be exact, we will have \n+\tto about 1 ulp. To be exact, we will have\n \t\t-1ulp < sqrt(x)-z<1.0625ulp.\n-\t\n+\n \t... set rounding mode to Round-to-nearest\n \t   y := y*(1.5-0.5*x*y*y)\t... almost 15 sig. bits to 1/sqrt(x)\n \t   y := y*((1.5-2^-30)+0.5*x*y*y)... about 29 sig. bits to 1/sqrt(x)\n@@ -363,14 +363,14 @@ B.  sqrt(x) by Reciproot Iteration\n \t   z := z + 0.5*z*(1-z*y)\t... about 1 ulp to sqrt(x)\n \n \tRemark 2. The constant 1.5-2^-30 is chosen to bias the error so that\n-\t(a) the term z*y in the final iteration is always less than 1; \n+\t(a) the term z*y in the final iteration is always less than 1;\n \t(b) the error in the final result is biased upward so that\n \t\t-1 ulp < sqrt(x) - z < 1.0625 ulp\n \t    instead of |sqrt(x)-z|<1.03125ulp.\n \n     (3)\tFinal adjustment\n \n-\tBy twiddling y's last bit it is possible to force y to be \n+\tBy twiddling y's last bit it is possible to force y to be\n \tcorrectly rounded according to the prevailing rounding mode\n \tas follows. Let r and i be copies of the rounding mode and\n \tinexact flag before entering the square root program. Also we\n@@ -410,27 +410,27 @@ B.  sqrt(x) by Reciproot Iteration\n \t    I := 1;\t\t... Raise Inexact flag: z is not exact\n \telse {\n \t    j := 1 - [(x0>>20)&1]\t... j = logb(x) mod 2\n-\t    k := z1 >> 26;\t\t... get z's 25-th and 26-th \n+\t    k := z1 >> 26;\t\t... get z's 25-th and 26-th\n \t\t\t\t\t    fraction bits\n \t    I := i or (k&j) or ((k&(j+j+1))!=(x1&3));\n \t}\n \tR:= r\t\t... restore rounded mode\n \treturn sqrt(x):=z.\n \n-\tIf multiplication is cheaper then the foregoing red tape, the \n+\tIf multiplication is cheaper then the foregoing red tape, the\n \tInexact flag can be evaluated by\n \n \t    I := i;\n \t    I := (z*z!=x) or I.\n \n-\tNote that z*z can overwrite I; this value must be sensed if it is \n+\tNote that z*z can overwrite I; this value must be sensed if it is\n \tTrue.\n \n \tRemark 4. If z*z = x exactly, then bit 25 to bit 0 of z1 must be\n \tzero.\n \n \t\t    --------------------\n-\t\tz1: |        f2        | \n+\t\tz1: |        f2        |\n \t\t    --------------------\n \t\tbit 31\t\t   bit 0\n \n@@ -447,6 +447,6 @@ B.  sqrt(x) by Reciproot Iteration\n \t11\t\t\t01\t\teven\n \t-------------------------------------------------\n \n-    (4)\tSpecial cases (see (4) of Section A).\t\n- \n+    (4)\tSpecial cases (see (4) of Section A).\n+\n  */"}, {"sha": "acf50a82e837130a772326dc26298c5e5387e885", "filename": "libjava/java/lang/k_cos.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fk_cos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fk_cos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fk_cos.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -15,7 +15,7 @@\n  * __kernel_cos( x,  y )\n  * kernel cos function on [-pi/4, pi/4], pi/4 ~ 0.785398164\n  * Input x is assumed to be bounded by ~pi/4 in magnitude.\n- * Input y is the tail of x. \n+ * Input y is the tail of x.\n  *\n  * Algorithm\n  *\t1. Since cos(-x) = cos(x), we need only to consider positive x.\n@@ -25,15 +25,15 @@\n  *\t\t  \t                 4            14\n  *\t   \tcos(x) ~ 1 - x*x/2 + C1*x + ... + C6*x\n  *\t   where the remez error is\n- *\t\n+ *\n  * \t|              2     4     6     8     10    12     14 |     -58\n  * \t|cos(x)-(1-.5*x +C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  )| <= 2\n- * \t|    \t\t\t\t\t               | \n- * \n- * \t               4     6     8     10    12     14 \n+ * \t|    \t\t\t\t\t               |\n+ *\n+ * \t               4     6     8     10    12     14\n  *\t4. let r = C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  , then\n  *\t       cos(x) = 1 - x*x/2 + r\n- *\t   since cos(x+y) ~ cos(x) - sin(x)*y \n+ *\t   since cos(x+y) ~ cos(x) - sin(x)*y\n  *\t\t\t  ~ cos(x) - x*y,\n  *\t   a correction term is necessary in cos(x) and hence\n  *\t\tcos(x+y) = 1 - (x*x/2 - (r - x*y))\n@@ -51,9 +51,9 @@\n #ifndef _DOUBLE_IS_32BITS\n \n #ifdef __STDC__\n-static const double \n+static const double\n #else\n-static double \n+static double\n #endif\n one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */\n C1  =  4.16666666666666019037e-02, /* 0x3FA55555, 0x5555554C */\n@@ -71,15 +71,15 @@ C6  = -1.13596475577881948265e-11; /* 0xBDA8FAE9, 0xBE8838D4 */\n #endif\n {\n \tdouble a,hz,z,r,qx;\n-\t__int32_t ix;\n+\tint32_t ix;\n \tGET_HIGH_WORD(ix,x);\n \tix &= 0x7fffffff;\t\t\t/* ix = |x|'s high word*/\n \tif(ix<0x3e400000) {\t\t\t/* if x < 2**27 */\n \t    if(((int)x)==0) return one;\t\t/* generate inexact */\n \t}\n \tz  = x*x;\n \tr  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));\n-\tif(ix < 0x3FD33333) \t\t\t/* if |x| < 0.3 */ \n+\tif(ix < 0x3FD33333) \t\t\t/* if |x| < 0.3 */\n \t    return one - (0.5*z - (z*r - x*y));\n \telse {\n \t    if(ix > 0x3fe90000) {\t\t/* x > 0.78125 */"}, {"sha": "2f4ca17256c968ce82a205e4e0d6a5574e74ec1f", "filename": "libjava/java/lang/k_rem_pio2.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fk_rem_pio2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fk_rem_pio2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fk_rem_pio2.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,20 +6,20 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n \n /*\n  * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)\n  * double x[],y[]; int e0,nx,prec; int ipio2[];\n- * \n- * __kernel_rem_pio2 return the last three digits of N with \n+ *\n+ * __kernel_rem_pio2 return the last three digits of N with\n  *\t\ty = x - N*pi/2\n  * so that |y| < pi/2.\n  *\n- * The method is to compute the integer (mod 8) and fraction parts of \n+ * The method is to compute the integer (mod 8) and fraction parts of\n  * (2/pi)*x without doing the full multiplication. In general we\n  * skip the part of the product that are known to be a huge integer (\n  * more accurately, = 0 mod 8 ). Thus the number of operations are\n@@ -28,10 +28,10 @@\n  * (2/pi) is represented by an array of 24-bit integers in ipio2[].\n  *\n  * Input parameters:\n- * \tx[]\tThe input value (must be positive) is broken into nx \n+ * \tx[]\tThe input value (must be positive) is broken into nx\n  *\t\tpieces of 24-bit integers in double precision format.\n- *\t\tx[i] will be the i-th 24 bit of x. The scaled exponent \n- *\t\tof x[0] is given in input parameter e0 (i.e., x[0]*2^e0 \n+ *\t\tx[i] will be the i-th 24 bit of x. The scaled exponent\n+ *\t\tof x[0] is given in input parameter e0 (i.e., x[0]*2^e0\n  *\t\tmatch x's up to 24 bits.\n  *\n  *\t\tExample of breaking a double positive z into x[0]+x[1]+x[2]:\n@@ -68,8 +68,8 @@\n  *\t\t\t3\t113 bits (quad)\n  *\n  *\tipio2[]\n- *\t\tinteger array, contains the (24*i)-th to (24*i+23)-th \n- *\t\tbit of 2/pi after binary point. The corresponding \n+ *\t\tinteger array, contains the (24*i)-th to (24*i+23)-th\n+ *\t\tbit of 2/pi after binary point. The corresponding\n  *\t\tfloating value is\n  *\n  *\t\t\tipio2[i] * 2^(-24(i+1)).\n@@ -84,8 +84,8 @@\n  *\t\tin the computation. The recommended value is 2,3,4,\n  *\t\t6 for single, double, extended,and quad.\n  *\n- * \tjz\tlocal integer variable indicating the number of \n- *\t\tterms of ipio2[] used. \n+ * \tjz\tlocal integer variable indicating the number of\n+ *\t\tterms of ipio2[] used.\n  *\n  *\tjx\tnx - 1\n  *\n@@ -105,9 +105,9 @@\n  *\t\texponent for q[i] would be q0-24*i.\n  *\n  *\tPIo2[]\tdouble precision array, obtained by cutting pi/2\n- *\t\tinto 24 bits chunks. \n+ *\t\tinto 24 bits chunks.\n  *\n- *\tf[]\tipio2[] in floating point \n+ *\tf[]\tipio2[] in floating point\n  *\n  *\tiq[]\tinteger array by breaking up q[] in 24-bits chunk.\n  *\n@@ -121,9 +121,9 @@\n \n /*\n  * Constants:\n- * The hexadecimal values are the intended ones for the following \n- * constants. The decimal values may be used, provided that the \n- * compiler will convert from decimal to binary accurately enough \n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n  * to produce the hexadecimal values shown.\n  */\n \n@@ -134,7 +134,7 @@\n #ifdef __STDC__\n static const int init_jk[] = {2,3,4,6}; /* initial value for jk */\n #else\n-static int init_jk[] = {2,3,4,6}; \n+static int init_jk[] = {2,3,4,6};\n #endif\n \n #ifdef __STDC__\n@@ -153,23 +153,23 @@ static double PIo2[] = {\n };\n \n #ifdef __STDC__\n-static const double\t\t\t\n+static const double\n #else\n-static double\t\t\t\n+static double\n #endif\n zero   = 0.0,\n one    = 1.0,\n two24   =  1.67772160000000000000e+07, /* 0x41700000, 0x00000000 */\n twon24  =  5.96046447753906250000e-08; /* 0x3E700000, 0x00000000 */\n \n #ifdef __STDC__\n-\tint __kernel_rem_pio2(double *x, double *y, int e0, int nx, int prec, const __int32_t *ipio2) \n+\tint __kernel_rem_pio2(double *x, double *y, int e0, int nx, int prec, const int32_t *ipio2)\n #else\n-\tint __kernel_rem_pio2(x,y,e0,nx,prec,ipio2) \t\n-\tdouble x[], y[]; int e0,nx,prec; __int32_t ipio2[];\n+\tint __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)\n+\tdouble x[], y[]; int e0,nx,prec; int32_t ipio2[];\n #endif\n {\n-\t__int32_t jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;\n+\tint32_t jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;\n \tdouble z,fw,f[20],fq[20],q[20];\n \n     /* initialize jk*/\n@@ -194,22 +194,22 @@ twon24  =  5.96046447753906250000e-08; /* 0x3E700000, 0x00000000 */\n recompute:\n     /* distill q[] into iq[] reversingly */\n \tfor(i=0,j=jz,z=q[jz];j>0;i++,j--) {\n-\t    fw    =  (double)((__int32_t)(twon24* z));\n-\t    iq[i] =  (__int32_t)(z-two24*fw);\n+\t    fw    =  (double)((int32_t)(twon24* z));\n+\t    iq[i] =  (int32_t)(z-two24*fw);\n \t    z     =  q[j-1]+fw;\n \t}\n \n     /* compute n */\n \tz  = scalbn(z,(int)q0);\t\t/* actual value of z */\n \tz -= 8.0*floor(z*0.125);\t\t/* trim off integer >= 8 */\n-\tn  = (__int32_t) z;\n+\tn  = (int32_t) z;\n \tz -= (double)n;\n \tih = 0;\n \tif(q0>0) {\t/* need iq[jz-1] to determine n */\n \t    i  = (iq[jz-1]>>(24-q0)); n += i;\n \t    iq[jz-1] -= i<<(24-q0);\n \t    ih = iq[jz-1]>>(23-q0);\n-\t} \n+\t}\n \telse if(q0==0) ih = iq[jz-1]>>23;\n \telse if(z>=0.5) ih=2;\n \n@@ -260,12 +260,12 @@ twon24  =  5.96046447753906250000e-08; /* 0x3E700000, 0x00000000 */\n \t    while(iq[jz]==0) { jz--; q0-=24;}\n \t} else { /* break z into 24-bit if necessary */\n \t    z = scalbn(z,-(int)q0);\n-\t    if(z>=two24) { \n-\t\tfw = (double)((__int32_t)(twon24*z));\n-\t\tiq[jz] = (__int32_t)(z-two24*fw);\n+\t    if(z>=two24) {\n+\t\tfw = (double)((int32_t)(twon24*z));\n+\t\tiq[jz] = (int32_t)(z-two24*fw);\n \t\tjz += 1; q0 += 24;\n-\t\tiq[jz] = (__int32_t) fw;\n-\t    } else iq[jz] = (__int32_t) z ;\n+\t\tiq[jz] = (int32_t) fw;\n+\t    } else iq[jz] = (int32_t) z ;\n \t}\n \n     /* convert integer \"bit\" chunk to floating-point value */\n@@ -285,29 +285,29 @@ twon24  =  5.96046447753906250000e-08; /* 0x3E700000, 0x00000000 */\n \t    case 0:\n \t\tfw = 0.0;\n \t\tfor (i=jz;i>=0;i--) fw += fq[i];\n-\t\ty[0] = (ih==0)? fw: -fw; \n+\t\ty[0] = (ih==0)? fw: -fw;\n \t\tbreak;\n \t    case 1:\n \t    case 2:\n \t\tfw = 0.0;\n-\t\tfor (i=jz;i>=0;i--) fw += fq[i]; \n-\t\ty[0] = (ih==0)? fw: -fw; \n+\t\tfor (i=jz;i>=0;i--) fw += fq[i];\n+\t\ty[0] = (ih==0)? fw: -fw;\n \t\tfw = fq[0]-fw;\n \t\tfor (i=1;i<=jz;i++) fw += fq[i];\n-\t\ty[1] = (ih==0)? fw: -fw; \n+\t\ty[1] = (ih==0)? fw: -fw;\n \t\tbreak;\n \t    case 3:\t/* painful */\n \t\tfor (i=jz;i>0;i--) {\n-\t\t    fw      = fq[i-1]+fq[i]; \n+\t\t    fw      = fq[i-1]+fq[i];\n \t\t    fq[i]  += fq[i-1]-fw;\n \t\t    fq[i-1] = fw;\n \t\t}\n \t\tfor (i=jz;i>1;i--) {\n-\t\t    fw      = fq[i-1]+fq[i]; \n+\t\t    fw      = fq[i-1]+fq[i];\n \t\t    fq[i]  += fq[i-1]-fw;\n \t\t    fq[i-1] = fw;\n \t\t}\n-\t\tfor (fw=0.0,i=jz;i>=2;i--) fw += fq[i]; \n+\t\tfor (fw=0.0,i=jz;i>=2;i--) fw += fq[i];\n \t\tif(ih==0) {\n \t\t    y[0] =  fq[0]; y[1] =  fq[1]; y[2] =  fw;\n \t\t} else {"}, {"sha": "b4ad387c5891f8df7a66202858fbcae655509999", "filename": "libjava/java/lang/k_sin.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fk_sin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fk_sin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fk_sin.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -15,24 +15,24 @@\n  * kernel sin function on [-pi/4, pi/4], pi/4 ~ 0.7854\n  * Input x is assumed to be bounded by ~pi/4 in magnitude.\n  * Input y is the tail of x.\n- * Input iy indicates whether y is 0. (if iy=0, y assume to be 0). \n+ * Input iy indicates whether y is 0. (if iy=0, y assume to be 0).\n  *\n  * Algorithm\n- *\t1. Since sin(-x) = -sin(x), we need only to consider positive x. \n+ *\t1. Since sin(-x) = -sin(x), we need only to consider positive x.\n  *\t2. if x < 2^-27 (hx<0x3e400000 0), return x with inexact if x!=0.\n  *\t3. sin(x) is approximated by a polynomial of degree 13 on\n  *\t   [0,pi/4]\n  *\t\t  \t         3            13\n  *\t   \tsin(x) ~ x + S1*x + ... + S6*x\n  *\t   where\n- *\t\n+ *\n  * \t|sin(x)         2     4     6     8     10     12  |     -58\n  * \t|----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x   )| <= 2\n- * \t|  x \t\t\t\t\t           | \n- * \n+ * \t|  x \t\t\t\t\t           |\n+ *\n  *\t4. sin(x+y) = sin(x) + sin'(x')*y\n  *\t\t    ~ sin(x) + (1-x*x/2)*y\n- *\t   For better accuracy, let \n+ *\t   For better accuracy, let\n  *\t\t     3      2      2      2      2\n  *\t\tr = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))\n  *\t   then                   3    2\n@@ -44,9 +44,9 @@\n #ifndef _DOUBLE_IS_32BITS\n \n #ifdef __STDC__\n-static const double \n+static const double\n #else\n-static double \n+static double\n #endif\n half =  5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */\n S1  = -1.66666666666666324348e-01, /* 0xBFC55555, 0x55555549 */\n@@ -64,7 +64,7 @@ S6  =  1.58969099521155010221e-10; /* 0x3DE5D93A, 0x5ACFD57C */\n #endif\n {\n \tdouble z,r,v;\n-\t__int32_t ix;\n+\tint32_t ix;\n \tGET_HIGH_WORD(ix,x);\n \tix &= 0x7fffffff;\t\t\t/* high word of x */\n \tif(ix<0x3e400000)\t\t\t/* |x| < 2**-27 */"}, {"sha": "a1067a70a0d9f5799a7eeb30e79fb62eea7d7446", "filename": "libjava/java/lang/k_tan.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fk_tan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fk_tan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fk_tan.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -15,25 +15,25 @@\n  * kernel tan function on [-pi/4, pi/4], pi/4 ~ 0.7854\n  * Input x is assumed to be bounded by ~pi/4 in magnitude.\n  * Input y is the tail of x.\n- * Input k indicates whether tan (if k=1) or \n+ * Input k indicates whether tan (if k=1) or\n  * -1/tan (if k= -1) is returned.\n  *\n  * Algorithm\n- *\t1. Since tan(-x) = -tan(x), we need only to consider positive x. \n+ *\t1. Since tan(-x) = -tan(x), we need only to consider positive x.\n  *\t2. if x < 2^-28 (hx<0x3e300000 0), return x with inexact if x!=0.\n  *\t3. tan(x) is approximated by a odd polynomial of degree 27 on\n  *\t   [0,0.67434]\n  *\t\t  \t         3             27\n  *\t   \ttan(x) ~ x + T1*x + ... + T13*x\n  *\t   where\n- *\t\n+ *\n  * \t        |tan(x)         2     4            26   |     -59.2\n  * \t        |----- - (1+T1*x +T2*x +.... +T13*x    )| <= 2\n- * \t        |  x \t\t\t\t\t| \n- * \n+ * \t        |  x \t\t\t\t\t|\n+ *\n  *\t   Note: tan(x+y) = tan(x) + tan'(x)*y\n  *\t\t          ~ tan(x) + (1+x*x)*y\n- *\t   Therefore, for better accuracy in computing tan(x+y), let \n+ *\t   Therefore, for better accuracy in computing tan(x+y), let\n  *\t\t     3      2      2       2       2\n  *\t\tr = x *(T2+x *(T3+x *(...+x *(T12+x *T13))))\n  *\t   then\n@@ -50,9 +50,9 @@\n #ifndef _DOUBLE_IS_32BITS\n \n #ifdef __STDC__\n-static const double \n+static const double\n #else\n-static double \n+static double\n #endif\n one   =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */\n pio4  =  7.85398163397448278999e-01, /* 0x3FE921FB, 0x54442D18 */\n@@ -81,12 +81,12 @@ T[] =  {\n #endif\n {\n \tdouble z,r,v,w,s;\n-\t__int32_t ix,hx;\n+\tint32_t ix,hx;\n \tGET_HIGH_WORD(hx,x);\n \tix = hx&0x7fffffff;\t/* high word of |x| */\n \tif(ix<0x3e300000)\t\t\t/* x < 2**-28 */\n \t    {if((int)x==0) {\t\t\t/* generate inexact */\n-\t        __uint32_t low;\n+\t        uint32_t low;\n \t\tGET_LOW_WORD(low,x);\n \t\tif(((ix|low)|(iy+1))==0) return one/fabs(x);\n \t\telse return (iy==1)? x: -one/x;\n@@ -115,7 +115,7 @@ T[] =  {\n \t    return (double)(1-((hx>>30)&2))*(v-2.0*(x-(w*w/(w+v)-r)));\n \t}\n \tif(iy==1) return w;\n-\telse {\t\t/* if allow error up to 2 ulp, \n+\telse {\t\t/* if allow error up to 2 ulp,\n \t\t\t   simply return -1.0/(x+r) here */\n      /*  compute -1.0/(x+r) accurately */\n \t    double a,t;"}, {"sha": "7989075aac342e04c0020b3b10aad0d5a37a8160", "filename": "libjava/java/lang/mprec.h", "status": "modified", "additions": 78, "deletions": 58, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fmprec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fmprec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fmprec.h?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -37,13 +37,35 @@ extern \"C\" {\n // #include <float.h>\n // #include <errno.h>\n \n-/* These typedefs are true for the targets running Java. */\n+#if defined HAVE_STDINT_H\n+#include <stdint.h>\n+#elif defined HAVE_INTTYPES_H\n+#include <inttypes.h>\n+#endif\n+\n+#if defined HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n \n-#ifndef HAVE_INT32_DEFINED\n-typedef int __int32_t;\n-typedef unsigned int __uint32_t;\n+#if defined HAVE_SYS_CONFIG_H\n+#include <sys/config.h>\n #endif\n \n+\n+/* ISO C9X int type declarations */\n+\n+#if !defined HAVE_INT32_DEFINED && defined HAVE_BSD_INT32_DEFINED\n+typedef u_int32_t uint32_t;\n+#endif\n+\n+#if !defined HAVE_BSD_INT32_DEFINED && !defined HAVE_INT32_DEFINED\n+// FIXME -- this could have problems with systems that don't define SI to be 4\n+typedef int int32_t __attribute__((mode(SI)));\n+typedef unsigned int uint32_t __attribute__((mode(SI)));\n+#endif\n+\n+  /* These typedefs are true for the targets running Java. */\n+\n #ifdef __IEEE_LITTLE_ENDIAN\n #define IEEE_8087\n #endif\n@@ -63,7 +85,7 @@ typedef unsigned int __uint32_t;\n \n \n #ifdef Unsigned_Shifts\n-#define Sign_Extend(a,b) if (b < 0) a |= (__uint32_t)0xffff0000;\n+#define Sign_Extend(a,b) if (b < 0) a |= (uint32_t)0xffff0000;\n #else\n #define Sign_Extend(a,b) /*no-op*/\n #endif\n@@ -79,8 +101,7 @@ Exactly one of IEEE_8087, IEEE_MC68k, VAX, or IBM should be defined.\n union double_union\n {\n   double d;\n-  // FIXME: This should be some well-defined 32 bit type.\n-  __uint32_t i[2];\n+  uint32_t i[2];\n };\n \n #ifdef IEEE_8087\n@@ -110,37 +131,37 @@ union double_union\n /* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */\n \n #if defined(IEEE_8087) + defined(IEEE_MC68k)\n-#if defined (_DOUBLE_IS_32BITS) \n+#if defined (_DOUBLE_IS_32BITS)\n #define Exp_shift   23\n #define Exp_shift1  23\n-#define Exp_msk1    ((__uint32_t)0x00800000L)\n-#define Exp_msk11   ((__uint32_t)0x00800000L)\n-#define Exp_mask    ((__uint32_t)0x7f800000L)\n+#define Exp_msk1    ((uint32_t)0x00800000L)\n+#define Exp_msk11   ((uint32_t)0x00800000L)\n+#define Exp_mask    ((uint32_t)0x7f800000L)\n #define P    \t    24\n #define Bias \t    127\n #if 0\n #define IEEE_Arith  /* it is, but the code doesn't handle IEEE singles yet */\n #endif\n #define Emin        (-126)\n-#define Exp_1       ((__uint32_t)0x3f800000L)\n-#define Exp_11      ((__uint32_t)0x3f800000L)\n+#define Exp_1       ((uint32_t)0x3f800000L)\n+#define Exp_11      ((uint32_t)0x3f800000L)\n #define Ebits \t    8\n-#define Frac_mask   ((__uint32_t)0x007fffffL)\n-#define Frac_mask1  ((__uint32_t)0x007fffffL)\n+#define Frac_mask   ((uint32_t)0x007fffffL)\n+#define Frac_mask1  ((uint32_t)0x007fffffL)\n #define Ten_pmax    10\n-#define Sign_bit    ((__uint32_t)0x80000000L)\n+#define Sign_bit    ((uint32_t)0x80000000L)\n #define Ten_pmax    10\n #define Bletch\t    2\n-#define Bndry_mask  ((__uint32_t)0x007fffffL)\n-#define Bndry_mask1 ((__uint32_t)0x007fffffL)\n+#define Bndry_mask  ((uint32_t)0x007fffffL)\n+#define Bndry_mask1 ((uint32_t)0x007fffffL)\n #define LSB 1\n-#define Sign_bit    ((__uint32_t)0x80000000L)\n+#define Sign_bit    ((uint32_t)0x80000000L)\n #define Log2P \t    1\n #define Tiny0 \t    0\n #define Tiny1 \t    1\n #define Quick_max   5\n #define Int_max     6\n-#define Infinite(x) (word0(x) == ((__uint32_t)0x7f800000L))\n+#define Infinite(x) (word0(x) == ((uint32_t)0x7f800000L))\n #undef word0\n #undef word1\n \n@@ -150,30 +171,30 @@ union double_union\n \n #define Exp_shift  20\n #define Exp_shift1 20\n-#define Exp_msk1    ((__uint32_t)0x100000L)\n-#define Exp_msk11   ((__uint32_t)0x100000L)\n-#define Exp_mask  ((__uint32_t)0x7ff00000L)\n+#define Exp_msk1    ((uint32_t)0x100000L)\n+#define Exp_msk11   ((uint32_t)0x100000L)\n+#define Exp_mask  ((uint32_t)0x7ff00000L)\n #define P 53\n #define Bias 1023\n #define IEEE_Arith\n #define Emin (-1022)\n-#define Exp_1  ((__uint32_t)0x3ff00000L)\n-#define Exp_11 ((__uint32_t)0x3ff00000L)\n+#define Exp_1  ((uint32_t)0x3ff00000L)\n+#define Exp_11 ((uint32_t)0x3ff00000L)\n #define Ebits 11\n-#define Frac_mask  ((__uint32_t)0xfffffL)\n-#define Frac_mask1 ((__uint32_t)0xfffffL)\n+#define Frac_mask  ((uint32_t)0xfffffL)\n+#define Frac_mask1 ((uint32_t)0xfffffL)\n #define Ten_pmax 22\n #define Bletch 0x10\n-#define Bndry_mask  ((__uint32_t)0xfffffL)\n-#define Bndry_mask1 ((__uint32_t)0xfffffL)\n+#define Bndry_mask  ((uint32_t)0xfffffL)\n+#define Bndry_mask1 ((uint32_t)0xfffffL)\n #define LSB 1\n-#define Sign_bit ((__uint32_t)0x80000000L)\n+#define Sign_bit ((uint32_t)0x80000000L)\n #define Log2P 1\n #define Tiny0 0\n #define Tiny1 1\n #define Quick_max 14\n #define Int_max 14\n-#define Infinite(x) (word0(x) == ((__uint32_t)0x7ff00000L)) /* sufficient test for here */\n+#define Infinite(x) (word0(x) == ((uint32_t)0x7ff00000L)) /* sufficient test for here */\n #endif\n \n #else\n@@ -182,46 +203,46 @@ union double_union\n #ifdef IBM\n #define Exp_shift  24\n #define Exp_shift1 24\n-#define Exp_msk1   ((__uint32_t)0x1000000L)\n-#define Exp_msk11  ((__uint32_t)0x1000000L)\n-#define Exp_mask  ((__uint32_t)0x7f000000L)\n+#define Exp_msk1   ((uint32_t)0x1000000L)\n+#define Exp_msk11  ((uint32_t)0x1000000L)\n+#define Exp_mask  ((uint32_t)0x7f000000L)\n #define P 14\n #define Bias 65\n-#define Exp_1  ((__uint32_t)0x41000000L)\n-#define Exp_11 ((__uint32_t)0x41000000L)\n+#define Exp_1  ((uint32_t)0x41000000L)\n+#define Exp_11 ((uint32_t)0x41000000L)\n #define Ebits 8\t/* exponent has 7 bits, but 8 is the right value in b2d */\n-#define Frac_mask  ((__uint32_t)0xffffffL)\n-#define Frac_mask1 ((__uint32_t)0xffffffL)\n+#define Frac_mask  ((uint32_t)0xffffffL)\n+#define Frac_mask1 ((uint32_t)0xffffffL)\n #define Bletch 4\n #define Ten_pmax 22\n-#define Bndry_mask  ((__uint32_t)0xefffffL)\n-#define Bndry_mask1 ((__uint32_t)0xffffffL)\n+#define Bndry_mask  ((uint32_t)0xefffffL)\n+#define Bndry_mask1 ((uint32_t)0xffffffL)\n #define LSB 1\n-#define Sign_bit ((__uint32_t)0x80000000L)\n+#define Sign_bit ((uint32_t)0x80000000L)\n #define Log2P 4\n-#define Tiny0 ((__uint32_t)0x100000L)\n+#define Tiny0 ((uint32_t)0x100000L)\n #define Tiny1 0\n #define Quick_max 14\n #define Int_max 15\n #else /* VAX */\n #define Exp_shift  23\n #define Exp_shift1 7\n #define Exp_msk1    0x80\n-#define Exp_msk11   ((__uint32_t)0x800000L)\n-#define Exp_mask  ((__uint32_t)0x7f80L)\n+#define Exp_msk11   ((uint32_t)0x800000L)\n+#define Exp_mask  ((uint32_t)0x7f80L)\n #define P 56\n #define Bias 129\n-#define Exp_1  ((__uint32_t)0x40800000L)\n-#define Exp_11 ((__uint32_t)0x4080L)\n+#define Exp_1  ((uint32_t)0x40800000L)\n+#define Exp_11 ((uint32_t)0x4080L)\n #define Ebits 8\n-#define Frac_mask  ((__uint32_t)0x7fffffL)\n-#define Frac_mask1 ((__uint32_t)0xffff007fL)\n+#define Frac_mask  ((uint32_t)0x7fffffL)\n+#define Frac_mask1 ((uint32_t)0xffff007fL)\n #define Ten_pmax 24\n #define Bletch 2\n-#define Bndry_mask  ((__uint32_t)0xffff007fL)\n-#define Bndry_mask1 ((__uint32_t)0xffff007fL)\n-#define LSB ((__uint32_t)0x10000L)\n-#define Sign_bit ((__uint32_t)0x8000L)\n+#define Bndry_mask  ((uint32_t)0xffff007fL)\n+#define Bndry_mask1 ((uint32_t)0xffff007fL)\n+#define LSB ((uint32_t)0x10000L)\n+#define Sign_bit ((uint32_t)0x8000L)\n #define Log2P 1\n #define Tiny0 0x80\n #define Tiny1 0\n@@ -248,7 +269,7 @@ extern double rnd_prod(double, double), rnd_quot(double, double);\n #endif\n \n #define Big0 (Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))\n-#define Big1 ((__uint32_t)0xffffffffL)\n+#define Big1 ((uint32_t)0xffffffffL)\n \n #ifndef Just_16\n /* When Pack_32 is not defined, we store 16 bits per 32-bit long.\n@@ -266,7 +287,7 @@ extern double rnd_prod(double, double), rnd_quot(double, double);\n #define MAX_BIGNUMS 16\n #define MAX_BIGNUM_WDS 32\n \n-struct _Jv_Bigint \n+struct _Jv_Bigint\n {\n   struct _Jv_Bigint *_next;\n   int _k, _maxwds, _sign, _wds;\n@@ -333,10 +354,10 @@ typedef struct _Jv_Bigint _Jv_Bigint;\n #define _strtod_r _Jv_strtod_r\n \n extern double _EXFUN(_strtod_r, (struct _Jv_reent *ptr, const char *s00, char **se));\n-extern char* _EXFUN(_dtoa_r, (struct _Jv_reent *ptr, double d, \n-\t\t\t      int mode, int ndigits, int *decpt, int *sign, \n+extern char* _EXFUN(_dtoa_r, (struct _Jv_reent *ptr, double d,\n+\t\t\t      int mode, int ndigits, int *decpt, int *sign,\n \t\t\t      char **rve, int float_type));\n-void _EXFUN(_dtoa, (double d, int mode, int ndigits, int *decpt, int *sign, \n+void _EXFUN(_dtoa, (double d, int mode, int ndigits, int *decpt, int *sign,\n \t\t    char **rve, char *buf, int float_type));\n \n double \t\t_EXFUN(ulp,(double x));\n@@ -371,4 +392,3 @@ extern _CONST double tens[];\n #ifdef __cplusplus\n }\n #endif\n-"}, {"sha": "2ee74585423a8fcc6428961f96e089a283e80613", "filename": "libjava/java/lang/s_atan.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_atan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_atan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_atan.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  *\n@@ -67,9 +67,9 @@ PORTABILITY\n  *      [39/16,INF]   atan(x) = atan(INF) + atan( -1/t )\n  *\n  * Constants:\n- * The hexadecimal values are the intended ones for the following \n- * constants. The decimal values may be used, provided that the \n- * compiler will convert from decimal to binary accurately enough \n+ * The hexadecimal values are the intended ones for the following\n+ * constants. The decimal values may be used, provided that the\n+ * compiler will convert from decimal to binary accurately enough\n  * to produce the hexadecimal values shown.\n  */\n \n@@ -118,9 +118,9 @@ static double aT[] = {\n };\n \n #ifdef __STDC__\n-\tstatic const double \n+\tstatic const double\n #else\n-\tstatic double \n+\tstatic double\n #endif\n one   = 1.0,\n huge   = 1.0e300;\n@@ -133,12 +133,12 @@ huge   = 1.0e300;\n #endif\n {\n \tdouble w,s1,s2,z;\n-\t__int32_t ix,hx,id;\n+\tint32_t ix,hx,id;\n \n \tGET_HIGH_WORD(hx,x);\n \tix = hx&0x7fffffff;\n \tif(ix>=0x44100000) {\t/* if |x| >= 2^66 */\n-\t    __uint32_t low;\n+\t    uint32_t low;\n \t    GET_LOW_WORD(low,x);\n \t    if(ix>0x7ff00000||\n \t\t(ix==0x7ff00000&&(low!=0)))\n@@ -154,9 +154,9 @@ huge   = 1.0e300;\n \tx = fabs(x);\n \tif (ix < 0x3ff30000) {\t\t/* |x| < 1.1875 */\n \t    if (ix < 0x3fe60000) {\t/* 7/16 <=|x|<11/16 */\n-\t\tid = 0; x = (2.0*x-one)/(2.0+x); \n+\t\tid = 0; x = (2.0*x-one)/(2.0+x);\n \t    } else {\t\t\t/* 11/16<=|x|< 19/16 */\n-\t\tid = 1; x  = (x-one)/(x+one); \n+\t\tid = 1; x  = (x-one)/(x+one);\n \t    }\n \t} else {\n \t    if (ix < 0x40038000) {\t/* |x| < 2.4375 */"}, {"sha": "250373b40d130a882480eeb110d3b483a7be5b0b", "filename": "libjava/java/lang/s_ceil.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_ceil.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_ceil.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_ceil.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -37,14 +37,14 @@ static double huge = 1.0e300;\n \tdouble x;\n #endif\n {\n-\t__int32_t i0,i1,j0;\n-\t__uint32_t i,j;\n+\tint32_t i0,i1,j0;\n+\tuint32_t i,j;\n \tEXTRACT_WORDS(i0,i1,x);\n \tj0 = ((i0>>20)&0x7ff)-0x3ff;\n \tif(j0<20) {\n \t    if(j0<0) { \t/* raise inexact if x != 0 */\n \t\tif(huge+x>0.0) {/* return 0*sign(x) if |x|<1 */\n-\t\t    if(i0<0) {i0=0x80000000;i1=0;} \n+\t\t    if(i0<0) {i0=0x80000000;i1=0;}\n \t\t    else if((i0|i1)!=0) { i0=0x3ff00000;i1=0;}\n \t\t}\n \t    } else {\n@@ -59,14 +59,14 @@ static double huge = 1.0e300;\n \t    if(j0==0x400) return x+x;\t/* inf or NaN */\n \t    else return x;\t\t/* x is integral */\n \t} else {\n-\t    i = ((__uint32_t)(0xffffffff))>>(j0-20);\n+\t    i = ((uint32_t)(0xffffffff))>>(j0-20);\n \t    if((i1&i)==0) return x;\t/* x is integral */\n \t    if(huge+x>0.0) { \t\t/* raise inexact flag */\n \t\tif(i0>0) {\n-\t\t    if(j0==20) i0+=1; \n+\t\t    if(j0==20) i0+=1;\n \t\t    else {\n \t\t\tj = i1 + (1<<(52-j0));\n-\t\t\tif(j<(__uint32_t)i1) i0+=1;\t/* got a carry */\n+\t\t\tif(j<(uint32_t)i1) i0+=1;\t/* got a carry */\n \t\t\ti1 = j;\n \t\t    }\n \t\t}"}, {"sha": "4804df130dc46d7d48abdea0ebe6a36f357077c2", "filename": "libjava/java/lang/s_copysign.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_copysign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_copysign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_copysign.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -72,7 +72,7 @@ Definition (Issue 2).\n \tdouble x,y;\n #endif\n {\n-\t__uint32_t hx,hy;\n+\tuint32_t hx,hy;\n \tGET_HIGH_WORD(hx,x);\n \tGET_HIGH_WORD(hy,y);\n \tSET_HIGH_WORD(x,(hx&0x7fffffff)|(hy&0x80000000));"}, {"sha": "be1538d4c0b639818345884bb0c423e8b6222c2c", "filename": "libjava/java/lang/s_cos.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_cos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_cos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_cos.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -20,8 +20,8 @@\n  *\t__ieee754_rem_pio2\t... argument reduction routine\n  *\n  * Method.\n- *      Let S,C and T denote the sin, cos and tan respectively on \n- *\t[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2 \n+ *      Let S,C and T denote the sin, cos and tan respectively on\n+ *\t[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2\n  *\tin [-pi/4 , +pi/4], and let n = k mod 4.\n  *\tWe have\n  *\n@@ -39,7 +39,7 @@\n  *      trig(NaN)    is that NaN;\n  *\n  * Accuracy:\n- *\tTRIG(x) returns trig(x) nearly rounded \n+ *\tTRIG(x) returns trig(x) nearly rounded\n  */\n \n #include \"fdlibm.h\"\n@@ -54,7 +54,7 @@\n #endif\n {\n \tdouble y[2],z=0.0;\n-\t__int32_t n,ix;\n+\tint32_t n,ix;\n \n     /* High word of x. */\n \tGET_HIGH_WORD(ix,x);"}, {"sha": "dfee33fecdbeca76b936b0515010ea6a0ff47dbc", "filename": "libjava/java/lang/s_fabs.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_fabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_fabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_fabs.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -26,16 +26,16 @@ ANSI_SYNOPSIS\n \n TRAD_SYNOPSIS\n \t#include <math.h>\n-       double fabs(<[x]>) \n+       double fabs(<[x]>)\n        double <[x]>;\n \n        float fabsf(<[x]>)\n        float <[x]>;\n \n DESCRIPTION\n-<<fabs>> and <<fabsf>> calculate \n+<<fabs>> and <<fabsf>> calculate\n @tex\n-$|x|$, \n+$|x|$,\n @end tex\n the absolute value (magnitude) of the argument <[x]>, by direct\n manipulation of the bit representation of <[x]>.\n@@ -64,7 +64,7 @@ PORTABILITY\n \tdouble x;\n #endif\n {\n-\t__uint32_t high;\n+\tuint32_t high;\n \tGET_HIGH_WORD(high,x);\n \tSET_HIGH_WORD(x,high&0x7fffffff);\n         return x;"}, {"sha": "77e39cb7de0b05ac926e24f022a445415ebc9b5a", "filename": "libjava/java/lang/s_floor.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_floor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_floor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_floor.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -34,20 +34,20 @@ TRAD_SYNOPSIS\n \t#include <math.h>\n         double floor(<[x]>)\n \tdouble <[x]>;\n-        float floorf(<[x]>) \n+        float floorf(<[x]>)\n \tfloat <[x]>;\n-        double ceil(<[x]>) \n+        double ceil(<[x]>)\n \tdouble <[x]>;\n-        float ceilf(<[x]>) \n+        float ceilf(<[x]>)\n \tfloat <[x]>;\n \n DESCRIPTION\n-<<floor>> and <<floorf>> find \n+<<floor>> and <<floorf>> find\n @tex\n-$\\lfloor x \\rfloor$, \n+$\\lfloor x \\rfloor$,\n @end tex\n the nearest integer less than or equal to <[x]>.\n-<<ceil>> and <<ceilf>> find \n+<<ceil>> and <<ceilf>> find\n @tex\n $\\lceil x\\rceil$,\n @end tex\n@@ -90,14 +90,14 @@ static double huge = 1.0e300;\n \tdouble x;\n #endif\n {\n-\t__int32_t i0,i1,j0;\n-\t__uint32_t i,j;\n+\tint32_t i0,i1,j0;\n+\tuint32_t i,j;\n \tEXTRACT_WORDS(i0,i1,x);\n \tj0 = ((i0>>20)&0x7ff)-0x3ff;\n \tif(j0<20) {\n \t    if(j0<0) { \t/* raise inexact if x != 0 */\n \t\tif(huge+x>0.0) {/* return 0*sign(x) if |x|<1 */\n-\t\t    if(i0>=0) {i0=i1=0;} \n+\t\t    if(i0>=0) {i0=i1=0;}\n \t\t    else if(((i0&0x7fffffff)|i1)!=0)\n \t\t\t{ i0=0xbff00000;i1=0;}\n \t\t}\n@@ -113,14 +113,14 @@ static double huge = 1.0e300;\n \t    if(j0==0x400) return x+x;\t/* inf or NaN */\n \t    else return x;\t\t/* x is integral */\n \t} else {\n-\t    i = ((__uint32_t)(0xffffffff))>>(j0-20);\n+\t    i = ((uint32_t)(0xffffffff))>>(j0-20);\n \t    if((i1&i)==0) return x;\t/* x is integral */\n \t    if(huge+x>0.0) { \t\t/* raise inexact flag */\n \t\tif(i0<0) {\n-\t\t    if(j0==20) i0+=1; \n+\t\t    if(j0==20) i0+=1;\n \t\t    else {\n \t\t\tj = i1+(1<<(52-j0));\n-\t\t\tif(j<(__uint32_t)i1) i0 +=1 ; \t/* got a carry */\n+\t\t\tif(j<(uint32_t)i1) i0 +=1 ; \t/* got a carry */\n \t\t\ti1=j;\n \t\t    }\n \t\t}"}, {"sha": "5d3f8114e2b7dcbc6b421afe72b28ca62cfe7752", "filename": "libjava/java/lang/s_rint.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_rint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_rint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_rint.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -28,7 +28,7 @@\n #ifdef __STDC__\n static const double\n #else\n-static double \n+static double\n #endif\n TWO52[2]={\n   4.50359962737049600000e+15, /* 0x43300000, 0x00000000 */\n@@ -42,15 +42,15 @@ TWO52[2]={\n \tdouble x;\n #endif\n {\n-\t__int32_t i0,j0,sx;\n-\t__uint32_t i,i1;\n+\tint32_t i0,j0,sx;\n+\tuint32_t i,i1;\n \tdouble t;\n \tvolatile double w;\n \tEXTRACT_WORDS(i0,i1,x);\n \tsx = (i0>>31)&1;\n \tj0 = ((i0>>20)&0x7ff)-0x3ff;\n \tif(j0<20) {\n-\t    if(j0<0) { \t\n+\t    if(j0<0) {\n \t\tif(((i0&0x7fffffff)|i1)==0) return x;\n \t\ti1 |= (i0&0x0fffff);\n \t\ti0 &= 0xfffe0000;\n@@ -74,7 +74,7 @@ TWO52[2]={\n \t    if(j0==0x400) return x+x;\t/* inf or NaN */\n \t    else return x;\t\t/* x is integral */\n \t} else {\n-\t    i = ((__uint32_t)(0xffffffff))>>(j0-20);\n+\t    i = ((uint32_t)(0xffffffff))>>(j0-20);\n \t    if((i1&i)==0) return x;\t/* x is integral */\n \t    i>>=1;\n \t    if((i1&i)!=0) i1 = (i1&(~i))|((0x40000000)>>(j0-20));"}, {"sha": "36ee88981bab63476803af2f4d79876976af97ec", "filename": "libjava/java/lang/s_scalbn.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_scalbn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_scalbn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_scalbn.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -48,10 +48,10 @@ Interface Definition (Issue 2).\n \n */\n \n-/* \n+/*\n  * scalbn (double x, int n)\n- * scalbn(x,n) returns x* 2**n  computed by  exponent  \n- * manipulation rather than by actually performing an \n+ * scalbn(x,n) returns x* 2**n  computed by  exponent\n+ * manipulation rather than by actually performing an\n  * exponentiation or a multiplication.\n  */\n \n@@ -76,18 +76,18 @@ tiny   = 1.0e-300;\n \tdouble x; int n;\n #endif\n {\n-\t__int32_t  k,hx,lx;\n+\tint32_t  k,hx,lx;\n \tEXTRACT_WORDS(hx,lx,x);\n         k = (hx&0x7ff00000)>>20;\t\t/* extract exponent */\n         if (k==0) {\t\t\t\t/* 0 or subnormal x */\n             if ((lx|(hx&0x7fffffff))==0) return x; /* +-0 */\n-\t    x *= two54; \n+\t    x *= two54;\n \t    GET_HIGH_WORD(hx,x);\n-\t    k = ((hx&0x7ff00000)>>20) - 54; \n+\t    k = ((hx&0x7ff00000)>>20) - 54;\n             if (n< -50000) return tiny*x; \t/*underflow*/\n \t    }\n         if (k==0x7ff) return x+x;\t\t/* NaN or Inf */\n-        k = k+n; \n+        k = k+n;\n         if (k >  0x7fe) return huge*copysign(huge,x); /* overflow  */\n         if (k > 0) \t\t\t\t/* normal result */\n \t    {SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20)); return x;}"}, {"sha": "d315455549c7222f0acdb21e0b7a067f37eeded3", "filename": "libjava/java/lang/s_sin.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_sin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_sin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_sin.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -43,17 +43,17 @@ TRAD_SYNOPSIS\n \n DESCRIPTION\n \t<<sin>> and <<cos>> compute (respectively) the sine and cosine\n-\tof the argument <[x]>.  Angles are specified in radians. \n+\tof the argument <[x]>.  Angles are specified in radians.\n \n \t<<sinf>> and <<cosf>> are identical, save that they take and\n-\treturn <<float>> values. \n+\treturn <<float>> values.\n \n \n RETURNS\n \tThe sine or cosine of <[x]> is returned.\n \n PORTABILITY\n-\t<<sin>> and <<cos>> are ANSI C. \n+\t<<sin>> and <<cos>> are ANSI C.\n \t<<sinf>> and <<cosf>> are extensions.\n \n QUICKREF\n@@ -70,8 +70,8 @@ QUICKREF\n  *\t__ieee754_rem_pio2\t... argument reduction routine\n  *\n  * Method.\n- *      Let S,C and T denote the sin, cos and tan respectively on \n- *\t[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2 \n+ *      Let S,C and T denote the sin, cos and tan respectively on\n+ *\t[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2\n  *\tin [-pi/4 , +pi/4], and let n = k mod 4.\n  *\tWe have\n  *\n@@ -89,7 +89,7 @@ QUICKREF\n  *      trig(NaN)    is that NaN;\n  *\n  * Accuracy:\n- *\tTRIG(x) returns trig(x) nearly rounded \n+ *\tTRIG(x) returns trig(x) nearly rounded\n  */\n \n #include \"fdlibm.h\"\n@@ -104,7 +104,7 @@ QUICKREF\n #endif\n {\n \tdouble y[2],z=0.0;\n-\t__int32_t n,ix;\n+\tint32_t n,ix;\n \n     /* High word of x. */\n \tGET_HIGH_WORD(ix,x);"}, {"sha": "20995fcbdeebbbfecd4f3df85ec0b2eef20955ce", "filename": "libjava/java/lang/s_tan.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_tan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fs_tan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fs_tan.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -6,7 +6,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -37,13 +37,13 @@ TRAD_SYNOPSIS\n \n \n DESCRIPTION\n-<<tan>> computes the tangent of the argument <[x]>.  \n-Angles are specified in radians.  \n+<<tan>> computes the tangent of the argument <[x]>.\n+Angles are specified in radians.\n \n <<tanf>> is identical, save that it takes and returns <<float>> values.\n \n RETURNS\n-The tangent of <[x]> is returned. \n+The tangent of <[x]> is returned.\n \n PORTABILITY\n <<tan>> is ANSI. <<tanf>> is an extension.\n@@ -57,8 +57,8 @@ PORTABILITY\n  *\t__ieee754_rem_pio2\t... argument reduction routine\n  *\n  * Method.\n- *      Let S,C and T denote the sin, cos and tan respectively on \n- *\t[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2 \n+ *      Let S,C and T denote the sin, cos and tan respectively on\n+ *\t[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2\n  *\tin [-pi/4 , +pi/4], and let n = k mod 4.\n  *\tWe have\n  *\n@@ -76,7 +76,7 @@ PORTABILITY\n  *      trig(NaN)    is that NaN;\n  *\n  * Accuracy:\n- *\tTRIG(x) returns trig(x) nearly rounded \n+ *\tTRIG(x) returns trig(x) nearly rounded\n  */\n \n #include \"fdlibm.h\"\n@@ -91,7 +91,7 @@ PORTABILITY\n #endif\n {\n \tdouble y[2],z=0.0;\n-\t__int32_t n,ix;\n+\tint32_t n,ix;\n \n     /* High word of x. */\n \tGET_HIGH_WORD(ix,x);"}, {"sha": "f442072874e939e0e1cfa8dd83e5529e7ea032e3", "filename": "libjava/java/lang/sf_rint.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fsf_rint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d16618c58103a8956b58e7d7476b7262828d93e/libjava%2Fjava%2Flang%2Fsf_rint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Fsf_rint.c?ref=0d16618c58103a8956b58e7d7476b7262828d93e", "patch": "@@ -8,7 +8,7 @@\n  *\n  * Developed at SunPro, a Sun Microsystems, Inc. business.\n  * Permission to use, copy, modify, and distribute this\n- * software is freely granted, provided that this notice \n+ * software is freely granted, provided that this notice\n  * is preserved.\n  * ====================================================\n  */\n@@ -18,7 +18,7 @@\n #ifdef __STDC__\n static const float\n #else\n-static float \n+static float\n #endif\n TWO23[2]={\n   8.3886080000e+06, /* 0x4b000000 */\n@@ -32,14 +32,14 @@ TWO23[2]={\n \tfloat x;\n #endif\n {\n-\t__int32_t i0,j0,sx;\n-\t__uint32_t i,i1;\n+\tint32_t i0,j0,sx;\n+\tuint32_t i,i1;\n \tfloat w,t;\n \tGET_FLOAT_WORD(i0,x);\n \tsx = (i0>>31)&1;\n \tj0 = ((i0>>23)&0xff)-0x7f;\n \tif(j0<23) {\n-\t    if(j0<0) { \t\n+\t    if(j0<0) {\n \t\tif((i0&0x7fffffff)==0) return x;\n \t\ti1 = (i0&0x07fffff);\n \t\ti0 &= 0xfff00000;"}]}