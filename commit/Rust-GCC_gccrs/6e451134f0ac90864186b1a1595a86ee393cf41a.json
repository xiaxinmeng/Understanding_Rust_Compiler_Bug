{"sha": "6e451134f0ac90864186b1a1595a86ee393cf41a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU0NTExMzRmMGFjOTA4NjQxODZiMWExNTk1YTg2ZWUzOTNjZjQxYQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2006-10-31T17:44:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:44:55Z"}, "message": "a-calend-vms.adb (Leap_Sec_Ops): Temp body for package in private part of Ada.Calendar...\n\n2006-10-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Jose Ruiz  <ruiz@adacore.com>\n\n\t* a-calend-vms.adb (Leap_Sec_Ops): Temp body for package in private\n\tpart of Ada.Calendar: all subprogram raise Unimplemented.\n\t(Split_W_Offset): Temp function body, raising Unimplemented\n\n\t* a-calend.ads, a-calend-vms.ads: \n\tAdd imported variable Invalid_TZ_Offset used to designate targets unable\n\tto support time zones.\n\t(Unimplemented): Temporary function raised by the body of new\n\tsubprograms below.\n\t(Leap_Sec_Ops): New package in the private part of Ada.Calendar. This\n\tunit provides handling of leap seconds and is used by the new Ada 2005\n\tpackages Ada.Calendar.Arithmetic and Ada.Calendar.Formatting.\n\t(Split_W_Offset): Identical spec to that of Ada.Calendar.Split. This\n\tversion returns an extra value which is the offset to UTC.\n\n\t* a-calend.adb (Split_W_Offset): Add call to localtime_tzoff.\n\t(Leap_Sec_Ops): New body for package in private part of Ada.Calendar.\n\t(Split_W_Offset): New function body.\n\t(Time_Of): When a date is close to UNIX epoch, compute the time for\n\tthat date plus one day (that amount is later substracted after\n\texecuting mktime) so there are no problems with time zone adjustments.\n\n\t* a-calend-mingw.adb: Remove Windows specific version no longer needed.\n\n\t* a-calari.ads, a-calari.adb, a-calfor.ads, a-calfor.adb,\n\ta-catizo.ads, a-catizo.adb: New files.\n\n        * impunit.adb: Add new Ada 2005 entries\n\n\t* sysdep.c: Add external variable __gnat_invalid_tz_offset.\n\tRename all occurences of \"__gnat_localtime_r\" to\n\t\"__gnat_localtime_tzoff\".\n\t(__gnat_localtime_tzoff for Windows): Add logic to retrieve the time\n\tzone data and calculate the GMT offset.\n\t(__gnat_localtime_tzoff for Darwin, Free BSD, Linux, Lynx and Tru64):\n\tUse the field \"tm_gmtoff\" to extract the GMT offset.\n\t(__gnat_localtime_tzoff for AIX, HPUX, SGI Irix and Sun Solaris): Use\n\tthe external variable \"timezone\" to calculate the GMT offset.\n\nFrom-SVN: r118234", "tree": {"sha": "203369273dd14a7ee74aea51ee6f81faf1d82050", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/203369273dd14a7ee74aea51ee6f81faf1d82050"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e451134f0ac90864186b1a1595a86ee393cf41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e451134f0ac90864186b1a1595a86ee393cf41a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e451134f0ac90864186b1a1595a86ee393cf41a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e451134f0ac90864186b1a1595a86ee393cf41a/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "014c9caac5151925c7ec3c7243bfc84daf660a31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014c9caac5151925c7ec3c7243bfc84daf660a31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/014c9caac5151925c7ec3c7243bfc84daf660a31"}], "stats": {"total": 2556, "additions": 2121, "deletions": 435}, "files": [{"sha": "de02a90ce6de37a7b8e286624ec5db1835167c08", "filename": "gcc/ada/a-calari.adb", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calari.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calari.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calari.adb?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -0,0 +1,142 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . C A L E N D A R . A R I T H M E T I C               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Unchecked_Conversion;\n+\n+package body Ada.Calendar.Arithmetic is\n+\n+   use Leap_Sec_Ops;\n+\n+   Day_Duration : constant Duration := 86_400.0;\n+\n+   ---------\n+   -- \"+\" --\n+   ---------\n+\n+   function \"+\" (Left : Time; Right : Day_Count) return Time is\n+   begin\n+      return Left + Integer (Right) * Day_Duration;\n+   end \"+\";\n+\n+   function \"+\" (Left : Day_Count; Right : Time) return Time is\n+   begin\n+      return Integer (Left) * Day_Duration + Right;\n+   end \"+\";\n+\n+   ---------\n+   -- \"-\" --\n+   ---------\n+\n+   function \"-\" (Left : Time; Right : Day_Count) return Time is\n+   begin\n+      return Left - Integer (Right) * Day_Duration;\n+   end \"-\";\n+\n+   function \"-\" (Left, Right : Time) return Day_Count is\n+      Days         : Day_Count;\n+      Seconds      : Duration;\n+      Leap_Seconds : Leap_Seconds_Count;\n+\n+   begin\n+      Difference (Left, Right, Days, Seconds, Leap_Seconds);\n+      return Days;\n+   end \"-\";\n+\n+   ----------------\n+   -- Difference --\n+   ----------------\n+\n+   procedure Difference\n+     (Left, Right  : Time;\n+      Days         : out Day_Count;\n+      Seconds      : out Duration;\n+      Leap_Seconds : out Leap_Seconds_Count)\n+   is\n+      Diff        : Duration;\n+      Earlier     : Time;\n+      Later       : Time;\n+      Leaps_Dur   : Duration;\n+      Negate      : Boolean;\n+      Next_Leap   : Time;\n+      Secs_Diff   : Long_Integer;\n+      Sub_Seconds : Duration;\n+\n+   begin\n+      if Left >= Right then\n+         Later   := Left;\n+         Earlier := Right;\n+         Negate  := False;\n+      else\n+         Later   := Right;\n+         Earlier := Left;\n+         Negate  := True;\n+      end if;\n+\n+      Diff := Later - Earlier;\n+\n+      Cumulative_Leap_Secs (Earlier, Later, Leaps_Dur, Next_Leap);\n+\n+      if Later >= Next_Leap then\n+         Leaps_Dur := Leaps_Dur + 1.0;\n+      end if;\n+\n+      Diff := Diff - Leaps_Dur;\n+\n+      declare\n+         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n+         for D_Int'Size use Duration'Size;\n+\n+         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n+         D_As_Int  : D_Int;\n+\n+         function To_D_As_Int is new Unchecked_Conversion (Duration, D_Int);\n+         function To_Duration is new Unchecked_Conversion (D_Int, Duration);\n+\n+      begin\n+         D_As_Int    := To_D_As_Int (Diff);\n+         Secs_Diff   := Long_Integer (D_As_Int / Small_Div);\n+         Sub_Seconds := To_Duration (D_As_Int rem Small_Div);\n+      end;\n+\n+      Days    := Day_Count (Secs_Diff / 86_400);\n+      Seconds := Duration (Secs_Diff mod 86_400) + Sub_Seconds;\n+      Leap_Seconds := Leap_Seconds_Count (Leaps_Dur);\n+\n+      if Negate then\n+         Days         := -Days;\n+         Seconds      := -Seconds;\n+         Leap_Seconds := -Leap_Seconds;\n+      end if;\n+   end Difference;\n+\n+end Ada.Calendar.Arithmetic;"}, {"sha": "11c0e32cbd64fa35d1551b2cbc1ebabe74cb9d51", "filename": "gcc/ada/a-calari.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calari.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calari.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calari.ads?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . C A L E N D A R . A R I T H M E T I C               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--        Copyright (C) 2005 - 2006, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.Calendar.Arithmetic is\n+\n+   --  Arithmetic on days:\n+\n+   type Day_Count is range\n+     -(366 * (1 + Year_Number'Last - Year_Number'First))\n+        ..\n+     +(366 * (1 + Year_Number'Last - Year_Number'First));\n+\n+   subtype Leap_Seconds_Count is Integer range -2047 .. 2047;\n+\n+   procedure Difference\n+     (Left, Right  : Time;\n+      Days         : out Day_Count;\n+      Seconds      : out Duration;\n+      Leap_Seconds : out Leap_Seconds_Count);\n+\n+   function \"+\" (Left : Time; Right : Day_Count) return Time;\n+   function \"+\" (Left : Day_Count; Right : Time) return Time;\n+   function \"-\" (Left : Time; Right : Day_Count) return Time;\n+   function \"-\" (Left, Right : Time) return Day_Count;\n+\n+end Ada.Calendar.Arithmetic;"}, {"sha": "0ec1ca94a8c34dfd16c5492ff24c13bf3c341617", "filename": "gcc/ada/a-calend-mingw.adb", "status": "removed", "additions": 0, "deletions": 397, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014c9caac5151925c7ec3c7243bfc84daf660a31/gcc%2Fada%2Fa-calend-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014c9caac5151925c7ec3c7243bfc84daf660a31/gcc%2Fada%2Fa-calend-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-mingw.adb?ref=014c9caac5151925c7ec3c7243bfc84daf660a31", "patch": "@@ -1,397 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAT RUN-TIME COMPONENTS                          --\n---                                                                          --\n---                         A D A . C A L E N D A R                          --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1997-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Windows NT/95 version\n-\n---  Why do we need separate version ???\n---  Do we need *this* much code duplication???\n-\n-with System.OS_Primitives;\n---  used for Clock\n-\n-with System.OS_Interface;\n-\n-package body Ada.Calendar is\n-\n-   use System.OS_Interface;\n-\n-   ------------------------------\n-   -- Use of Pragma Unsuppress --\n-   ------------------------------\n-\n-   --  This implementation of Calendar takes advantage of the permission in\n-   --  Ada 95 of using arithmetic overflow checks to check for out of bounds\n-   --  time values. This means that we must catch the constraint error that\n-   --  results from arithmetic overflow, so we use pragma Unsuppress to make\n-   --  sure that overflow is enabled, using software overflow checking if\n-   --  necessary. That way, compiling Calendar with options to suppress this\n-   --  checking will not affect its correctness.\n-\n-   ------------------------\n-   -- Local Declarations --\n-   ------------------------\n-\n-   Ada_Year_Min : constant := 1901;\n-   Ada_Year_Max : constant := 2099;\n-\n-   --  Win32 time constants\n-\n-   epoch_1970     : constant := 16#19D_B1DE_D53E_8000#; -- win32 UTC epoch\n-   system_time_ns : constant := 100;                    -- 100 ns per tick\n-   Sec_Unit       : constant := 10#1#E9;\n-\n-   ---------\n-   -- \"+\" --\n-   ---------\n-\n-   function \"+\" (Left : Time; Right : Duration) return Time is\n-      pragma Unsuppress (Overflow_Check);\n-   begin\n-      return (Left + Time (Right));\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Time_Error;\n-   end \"+\";\n-\n-   function \"+\" (Left : Duration; Right : Time) return Time is\n-      pragma Unsuppress (Overflow_Check);\n-   begin\n-      return (Time (Left) + Right);\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Time_Error;\n-   end \"+\";\n-\n-   ---------\n-   -- \"-\" --\n-   ---------\n-\n-   function \"-\" (Left : Time; Right : Duration)  return Time is\n-      pragma Unsuppress (Overflow_Check);\n-   begin\n-      return Left - Time (Right);\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Time_Error;\n-   end \"-\";\n-\n-   function \"-\" (Left : Time; Right : Time) return Duration is\n-      pragma Unsuppress (Overflow_Check);\n-   begin\n-      return Duration (Left) - Duration (Right);\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Time_Error;\n-   end \"-\";\n-\n-   ---------\n-   -- \"<\" --\n-   ---------\n-\n-   function \"<\" (Left, Right : Time) return Boolean is\n-   begin\n-      return Duration (Left) < Duration (Right);\n-   end \"<\";\n-\n-   ----------\n-   -- \"<=\" --\n-   ----------\n-\n-   function \"<=\" (Left, Right : Time) return Boolean is\n-   begin\n-      return Duration (Left) <= Duration (Right);\n-   end \"<=\";\n-\n-   ---------\n-   -- \">\" --\n-   ---------\n-\n-   function \">\" (Left, Right : Time) return Boolean is\n-   begin\n-      return Duration (Left) > Duration (Right);\n-   end \">\";\n-\n-   ----------\n-   -- \">=\" --\n-   ----------\n-\n-   function \">=\" (Left, Right : Time) return Boolean is\n-   begin\n-      return Duration (Left) >= Duration (Right);\n-   end \">=\";\n-\n-   -----------\n-   -- Clock --\n-   -----------\n-\n-   --  The Ada.Calendar.Clock function gets the time from the soft links\n-   --  interface which will call the appropriate function depending wether\n-   --  tasking is involved or not.\n-\n-   function Clock return Time is\n-   begin\n-      return Time (System.OS_Primitives.Clock);\n-   end Clock;\n-\n-   ---------\n-   -- Day --\n-   ---------\n-\n-   function Day (Date : Time) return Day_Number is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n-   begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DD;\n-   end Day;\n-\n-   -----------\n-   -- Month --\n-   -----------\n-\n-   function Month (Date : Time) return Month_Number is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n-\n-   begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DM;\n-   end Month;\n-\n-   -------------\n-   -- Seconds --\n-   -------------\n-\n-   function Seconds (Date : Time) return Day_Duration is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n-   begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DS;\n-   end Seconds;\n-\n-   -----------\n-   -- Split --\n-   -----------\n-\n-   procedure Split\n-     (Date    : Time;\n-      Year    : out Year_Number;\n-      Month   : out Month_Number;\n-      Day     : out Day_Number;\n-      Seconds : out Day_Duration)\n-   is\n-\n-      Date_Int    : aliased Long_Long_Integer;\n-      Date_Loc    : aliased Long_Long_Integer;\n-      Timbuf      : aliased SYSTEMTIME;\n-      Int_Date    : Long_Long_Integer;\n-      Sub_Seconds : Duration;\n-\n-   begin\n-      --  We take the sub-seconds (decimal part) of Date and this is added\n-      --  to compute the Seconds. This way we keep the precision of the\n-      --  high-precision clock that was lost with the Win32 API calls\n-      --  below.\n-\n-      if Date < 0.0 then\n-\n-         --  this is a Date before Epoch (January 1st, 1970)\n-\n-         Sub_Seconds := Duration (Date) -\n-           Duration (Long_Long_Integer (Date + Duration'(0.5)));\n-\n-         Int_Date := Long_Long_Integer (Date - Sub_Seconds);\n-\n-         --  For Date = -86400.1 we are 2 days before Epoch at 0.1 seconds\n-         --  from day 1 before Epoch. It means that it is 23h 59m 59.9s.\n-         --  here we adjust for that.\n-\n-         if Sub_Seconds < 0.0 then\n-            Int_Date    := Int_Date - 1;\n-            Sub_Seconds := 1.0 + Sub_Seconds;\n-         end if;\n-\n-      else\n-\n-         --  this is a Date after Epoch (January 1st, 1970)\n-\n-         Sub_Seconds := Duration (Date) -\n-           Duration (Long_Long_Integer (Date - Duration'(0.5)));\n-\n-         Int_Date := Long_Long_Integer (Date - Sub_Seconds);\n-\n-      end if;\n-\n-      --  Date_Int is the number of seconds from Epoch\n-\n-      Date_Int := Long_Long_Integer\n-        (Int_Date * Sec_Unit / system_time_ns) + epoch_1970;\n-\n-      if not FileTimeToLocalFileTime (Date_Int'Access, Date_Loc'Access) then\n-         raise Time_Error;\n-      end if;\n-\n-      if not FileTimeToSystemTime (Date_Loc'Access, Timbuf'Access) then\n-         raise Time_Error;\n-      end if;\n-\n-      if Timbuf.wYear not in Ada_Year_Min .. Ada_Year_Max then\n-         raise Time_Error;\n-      end if;\n-\n-      Seconds :=\n-        Duration (Timbuf.wHour) * 3_600.0 +\n-        Duration (Timbuf.wMinute) * 60.0 +\n-        Duration (Timbuf.wSecond) +\n-        Sub_Seconds;\n-\n-      Day       := Integer (Timbuf.wDay);\n-      Month     := Integer (Timbuf.wMonth);\n-      Year      := Integer (Timbuf.wYear);\n-   end Split;\n-\n-   -------------\n-   -- Time_Of --\n-   -------------\n-\n-   function Time_Of\n-     (Year    : Year_Number;\n-      Month   : Month_Number;\n-      Day     : Day_Number;\n-      Seconds : Day_Duration := 0.0)\n-      return    Time\n-   is\n-\n-      Timbuf      : aliased SYSTEMTIME;\n-      Now         : aliased Long_Long_Integer;\n-      Loc         : aliased Long_Long_Integer;\n-      Int_Secs    : Integer;\n-      Secs        : Integer;\n-      Add_One_Day : Boolean := False;\n-      Date        : Time;\n-\n-   begin\n-      --  The following checks are redundant with respect to the constraint\n-      --  error checks that should normally be made on parameters, but we\n-      --  decide to raise Constraint_Error in any case if bad values come\n-      --  in (as a result of checks being off in the caller, or for other\n-      --  erroneous or bounded error cases).\n-\n-      if        not Year   'Valid\n-        or else not Month  'Valid\n-        or else not Day    'Valid\n-        or else not Seconds'Valid\n-      then\n-         raise Constraint_Error;\n-      end if;\n-\n-      if Seconds = 0.0 then\n-         Int_Secs := 0;\n-      else\n-         Int_Secs := Integer (Seconds - 0.5);\n-      end if;\n-\n-      --  Timbuf.wMillisec is to keep the msec. We can't use that because the\n-      --  high-resolution clock has a precision of 1 Microsecond.\n-      --  Anyway the sub-seconds part is not needed to compute the number\n-      --  of seconds in UTC.\n-\n-      if Int_Secs = 86_400 then\n-         Secs := 0;\n-         Add_One_Day := True;\n-      else\n-         Secs := Int_Secs;\n-      end if;\n-\n-      Timbuf.wMilliseconds := 0;\n-      Timbuf.wSecond       := WORD (Secs mod 60);\n-      Timbuf.wMinute       := WORD ((Secs / 60) mod 60);\n-      Timbuf.wHour         := WORD (Secs / 3600);\n-      Timbuf.wDay          := WORD (Day);\n-      Timbuf.wMonth        := WORD (Month);\n-      Timbuf.wYear         := WORD (Year);\n-\n-      if not SystemTimeToFileTime (Timbuf'Access, Loc'Access) then\n-         raise Time_Error;\n-      end if;\n-\n-      if not LocalFileTimeToFileTime (Loc'Access, Now'Access) then\n-         raise Time_Error;\n-      end if;\n-\n-      --  Here we have the UTC now translate UTC to Epoch time (UNIX style\n-      --  time based on 1 january 1970) and add there the sub-seconds part.\n-\n-      declare\n-         Sub_Sec : constant Duration := Seconds - Duration (Int_Secs);\n-      begin\n-         Date := Time ((Now - epoch_1970) * system_time_ns / Sec_Unit) +\n-                   Sub_Sec;\n-      end;\n-\n-      if Add_One_Day then\n-         Date := Date + Duration (86400.0);\n-      end if;\n-\n-      return Date;\n-   end Time_Of;\n-\n-   ----------\n-   -- Year --\n-   ----------\n-\n-   function Year (Date : Time) return Year_Number is\n-      DY : Year_Number;\n-      DM : Month_Number;\n-      DD : Day_Number;\n-      DS : Day_Duration;\n-\n-   begin\n-      Split (Date, DY, DM, DD, DS);\n-      return DY;\n-   end Year;\n-\n-begin\n-   System.OS_Primitives.Initialize;\n-end Ada.Calendar;"}, {"sha": "67a5697691bfbec010b76988a60b266235a1d28c", "filename": "gcc/ada/a-calend-vms.adb", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calend-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calend-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.adb?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -224,7 +224,7 @@ package body Ada.Calendar is\n       procedure Numtim (\n         Status : out Unsigned_Longword;\n         Timbuf : out Unsigned_Word_Array;\n-        Timadr : in  Time);\n+        Timadr : Time);\n \n       pragma Interface (External, Numtim);\n \n@@ -256,6 +256,22 @@ package body Ada.Calendar is\n       Year  := Integer (Timbuf (1));\n    end Split;\n \n+   -----------------------\n+   -- Split_With_Offset --\n+   -----------------------\n+\n+   procedure Split_With_Offset\n+     (Date    : Time;\n+      Year    : out Year_Number;\n+      Month   : out Month_Number;\n+      Day     : out Day_Number;\n+      Seconds : out Day_Duration;\n+      Offset  : out Long_Integer)\n+   is\n+   begin\n+      raise Unimplemented;\n+   end Split_With_Offset;\n+\n    -------------\n    -- Time_Of --\n    -------------\n@@ -270,7 +286,7 @@ package body Ada.Calendar is\n \n       procedure Cvt_Vectim (\n         Status         : out Unsigned_Longword;\n-        Input_Time     : in  Unsigned_Word_Array;\n+        Input_Time     : Unsigned_Word_Array;\n         Resultant_Time : out Time);\n \n       pragma Interface (External, Cvt_Vectim);\n@@ -358,4 +374,43 @@ package body Ada.Calendar is\n       return DY;\n    end Year;\n \n+   -------------------\n+   --  Leap_Sec_Ops --\n+   -------------------\n+\n+   --  The package that is used by the Ada 2005 children of Ada.Calendar:\n+   --  Ada.Calendar.Arithmetic and Ada.Calendar.Formatting.\n+\n+   package body Leap_Sec_Ops is\n+\n+      --------------------------\n+      -- Cumulative_Leap_Secs --\n+      --------------------------\n+\n+      procedure Cumulative_Leap_Secs\n+        (Start_Date    : Time;\n+         End_Date      : Time;\n+         Leaps_Between : out Duration;\n+         Next_Leap_Sec : out Time)\n+      is\n+      begin\n+         raise Unimplemented;\n+      end Cumulative_Leap_Secs;\n+\n+      ----------------------\n+      -- All_Leap_Seconds --\n+      ----------------------\n+\n+      function All_Leap_Seconds return Duration is\n+      begin\n+         raise Unimplemented;\n+         return 0.0;\n+      end All_Leap_Seconds;\n+\n+   --  Start of processing in package Leap_Sec_Ops\n+\n+   begin\n+      null;\n+   end Leap_Sec_Ops;\n+\n end Ada.Calendar;"}, {"sha": "3f68ffb64684e7620cec4a2fcff4301548a086f6", "filename": "gcc/ada/a-calend-vms.ads", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calend-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calend-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.ads?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -87,6 +87,8 @@ package Ada.Calendar is\n \n    Time_Error : exception;\n \n+   Unimplemented : exception;\n+\n private\n \n    pragma Inline (Clock);\n@@ -118,4 +120,66 @@ private\n    --  Relative Time is positive, whereas relative OS_Time is negative,\n    --  but this declaration makes for easier conversion.\n \n+   --  The following package provides handling of leap seconds. It is\n+   --  used by Ada.Calendar.Arithmetic and Ada.Calendar.Formatting, both\n+   --  Ada 2005 children of Ada.Calendar.\n+\n+   package Leap_Sec_Ops is\n+\n+      After_Last_Leap : constant Time := Time'Last;\n+      --  Bigger by far than any leap second value. Not within range of\n+      --  Ada.Calendar specified dates.\n+\n+      procedure Cumulative_Leap_Secs\n+        (Start_Date    : Time;\n+         End_Date      : Time;\n+         Leaps_Between : out Duration;\n+         Next_Leap_Sec : out Time);\n+      --  Leaps_Between is the sum of the leap seconds that have occured\n+      --  on or after Start_Date and before (strictly before) End_Date.\n+      --  Next_Leap_Sec represents the next leap second occurence on or\n+      --  after End_Date. If there are no leaps seconds after End_Date,\n+      --  After_Last_Leap is returned. This does not provide info about\n+      --  the next leap second (pos/neg or ?). After_Last_Leap can be used\n+      --  as End_Date to count all the leap seconds that have occured on\n+      --  or after Start_Date.\n+      --\n+      --  Important Notes: any fractional parts of Start_Date and End_Date\n+      --  are discarded before the calculations are done. For instance: if\n+      --  113 seconds is a leap second (it isn't) and 113.5 is input as an\n+      --  End_Date, the leap second at 113 will not be counted in\n+      --  Leaps_Between, but it will be returned as Next_Leap_Sec. Thus, if\n+      --  the caller wants to know if the End_Date is a leap second, the\n+      --  comparison should be:\n+      --\n+      --     End_Date >= Next_Leap_Sec;\n+      --\n+      --  After_Last_Leap is designed so that this comparison works without\n+      --  having to first check if Next_Leap_Sec is a valid leap second.\n+\n+      function All_Leap_Seconds return Duration;\n+      --  Returns the sum off all of the leap seoncds.\n+\n+   end Leap_Sec_Ops;\n+\n+   procedure Split_With_Offset\n+     (Date    : Time;\n+      Year    : out Year_Number;\n+      Month   : out Month_Number;\n+      Day     : out Day_Number;\n+      Seconds : out Day_Duration;\n+      Offset  : out Long_Integer);\n+   --  Split_W_Offset has the same spec as Split with the addition of an\n+   --  offset value which give the offset of the local time zone from UTC\n+   --  at the input Date. This value comes for free during the implementation\n+   --  of Split and is needed by UTC_Time_Offset. The returned Offset time\n+   --  is straight from the C tm struct and is in seconds. If the system\n+   --  dependent code has no way to find the offset it will return the value\n+   --  Invalid_TZ_Offset declared below. Otherwise no checking is done, so\n+   --  it is up to the user to check both for Invalid_TZ_Offset and otherwise\n+   --  for a value that is acceptable.\n+\n+   Invalid_TZ_Offset : Long_Integer;\n+   pragma Import (C, Invalid_TZ_Offset, \"__gnat_invalid_tzoff\");\n+\n end Ada.Calendar;"}, {"sha": "02851ad50b32c23b1ffa90c508e06aa9b469c4ad", "filename": "gcc/ada/a-calend.adb", "status": "modified", "additions": 239, "deletions": 15, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.adb?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,9 +54,10 @@ package body Ada.Calendar is\n    -- Local Declarations --\n    ------------------------\n \n-   type Char_Pointer is access Character;\n-   subtype int  is Integer;\n+   type char_Pointer is access Character;\n+   subtype int is Integer;\n    subtype long is Long_Integer;\n+   type long_Pointer is access all long;\n    --  Synonyms for C types. We don't want to get them from Interfaces.C\n    --  because there is no point in loading that unit just for calendar.\n \n@@ -71,7 +72,7 @@ package body Ada.Calendar is\n       tm_yday   : int;           -- days since January 1 (0 .. 365)\n       tm_isdst  : int;           -- Daylight Savings Time flag (-1 .. +1)\n       tm_gmtoff : long;          -- offset from CUT in seconds\n-      tm_zone   : Char_Pointer;  -- timezone abbreviation\n+      tm_zone   : char_Pointer;  -- timezone abbreviation\n    end record;\n \n    type tm_Pointer is access all tm;\n@@ -80,8 +81,15 @@ package body Ada.Calendar is\n \n    type time_t_Pointer is access all time_t;\n \n-   procedure localtime_r (C : time_t_Pointer; res : tm_Pointer);\n-   pragma Import (C, localtime_r, \"__gnat_localtime_r\");\n+   procedure localtime_tzoff\n+     (C   : time_t_Pointer;\n+      res : tm_Pointer;\n+      off : long_Pointer);\n+   pragma Import (C, localtime_tzoff, \"__gnat_localtime_tzoff\");\n+   --  This is a lightweight wrapper around the system library localtime_r\n+   --  function. Parameter 'off' captures the UTC offset which is either\n+   --  retrieved from the tm struct or calculated from the 'timezone' extern\n+   --  and the tm_isdst flag in the tm struct.\n \n    function mktime (TM : tm_Pointer) return time_t;\n    pragma Import (C, mktime);\n@@ -259,6 +267,24 @@ package body Ada.Calendar is\n       Month   : out Month_Number;\n       Day     : out Day_Number;\n       Seconds : out Day_Duration)\n+   is\n+      Offset : Long_Integer;\n+\n+   begin\n+      Split_With_Offset (Date, Year, Month, Day, Seconds, Offset);\n+   end Split;\n+\n+   -----------------------\n+   -- Split_With_Offset --\n+   -----------------------\n+\n+   procedure Split_With_Offset\n+     (Date    : Time;\n+      Year    : out Year_Number;\n+      Month   : out Month_Number;\n+      Day     : out Day_Number;\n+      Seconds : out Day_Duration;\n+      Offset  : out Long_Integer)\n    is\n       --  The following declare bounds for duration that are comfortably\n       --  wider than the maximum allowed output result for the Ada range\n@@ -273,11 +299,12 @@ package body Ada.Calendar is\n \n       --  Finally the actual variables used in the computation\n \n+      Adjusted_Seconds : aliased time_t;\n       D                : Duration;\n       Frac_Sec         : Duration;\n-      Year_Val         : Integer;\n-      Adjusted_Seconds : aliased time_t;\n+      Local_Offset     : aliased long;\n       Tm_Val           : aliased tm;\n+      Year_Val         : Integer;\n \n    begin\n       --  For us a time is simply a signed duration value, so we work with\n@@ -331,23 +358,26 @@ package body Ada.Calendar is\n          type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n          for D_Int'Size use Duration'Size;\n \n-         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n-         D_As_Int  : D_Int;\n-\n-         function To_D_As_Int is new Unchecked_Conversion (Duration, D_Int);\n+         function To_D_Int is new Unchecked_Conversion (Duration, D_Int);\n          function To_Duration is new Unchecked_Conversion (D_Int, Duration);\n \n+         D_As_Int  : constant D_Int := To_D_Int (D);\n+         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n+\n       begin\n-         D_As_Int := To_D_As_Int (D);\n          Adjusted_Seconds := time_t (D_As_Int / Small_Div);\n          Frac_Sec := To_Duration (D_As_Int rem Small_Div);\n       end;\n \n-      localtime_r (Adjusted_Seconds'Unchecked_Access, Tm_Val'Unchecked_Access);\n+      localtime_tzoff\n+        (Adjusted_Seconds'Unchecked_Access,\n+         Tm_Val'Unchecked_Access,\n+         Local_Offset'Unchecked_Access);\n \n       Year_Val := Tm_Val.tm_year + 1900 + Year_Val;\n       Month    := Tm_Val.tm_mon + 1;\n       Day      := Tm_Val.tm_mday;\n+      Offset   := Long_Integer (Local_Offset);\n \n       --  The Seconds value is a little complex. The localtime function\n       --  returns the integral number of seconds, which is what we want, but\n@@ -375,7 +405,7 @@ package body Ada.Calendar is\n       else\n          Year := Year_Val;\n       end if;\n-   end Split;\n+   end Split_With_Offset;\n \n    -------------\n    -- Time_Of --\n@@ -444,6 +474,20 @@ package body Ada.Calendar is\n \n       TM_Val.tm_year := Year_Val - 1900;\n \n+      --  If time is very close to UNIX epoch mktime may behave uncorrectly\n+      --  because of the way the different time zones are handled (a date\n+      --  after epoch in a given time zone may correspond to a GMT date\n+      --  before epoch). Adding one day to the date (this amount is latter\n+      --  substracted) avoids this problem.\n+\n+      if Year_Val = Unix_Year_Min\n+        and then Month = 1\n+        and then Day = 1\n+      then\n+         TM_Val.tm_mday := TM_Val.tm_mday + 1;\n+         Duration_Adjust := Duration_Adjust - Duration (86400.0);\n+      end if;\n+\n       --  Since we do not have information on daylight savings, rely on the\n       --  default information.\n \n@@ -476,6 +520,186 @@ package body Ada.Calendar is\n       return DY;\n    end Year;\n \n+   -------------------\n+   --  Leap_Sec_Ops --\n+   -------------------\n+\n+   --  The package that is used by the Ada 2005 children of Ada.Calendar:\n+   --  Ada.Calendar.Arithmetic and Ada.Calendar.Formatting.\n+\n+   package body Leap_Sec_Ops is\n+\n+      --  This package must be updated when leap seconds are added. Adding a\n+      --  leap second requires incrementing the value of N_Leap_Secs and adding\n+      --  the day of the new leap second to the end of Leap_Second_Dates.\n+\n+      --  Elaboration of the Leap_Sec_Ops package takes care of converting the\n+      --  Leap_Second_Dates table to a form that is better suited for the\n+      --  procedures provided by this package (a table that would be more\n+      --  difficult to maintain by hand).\n+\n+      N_Leap_Secs : constant := 23;\n+\n+      type Leap_Second_Date is record\n+         Year  : Year_Number;\n+         Month : Month_Number;\n+         Day   : Day_Number;\n+      end record;\n+\n+      Leap_Second_Dates :\n+        constant array (1 .. N_Leap_Secs) of Leap_Second_Date :=\n+          ((1972,  6, 30), (1972, 12, 31), (1973, 12, 31), (1974, 12, 31),\n+           (1975, 12, 31), (1976, 12, 31), (1977, 12, 31), (1978, 12, 31),\n+           (1979, 12, 31), (1981,  6, 30), (1982,  6, 30), (1983,  6, 30),\n+           (1985,  6, 30), (1987, 12, 31), (1989, 12, 31), (1990, 12, 31),\n+           (1992,  6, 30), (1993,  6, 30), (1994,  6, 30), (1995, 12, 31),\n+           (1997,  6, 30), (1998, 12, 31), (2005, 12, 31));\n+\n+      Leap_Second_Times : array (1 .. N_Leap_Secs) of Time;\n+      --  This is the needed internal representation that is calculated\n+      --  from Leap_Second_Dates during elaboration;\n+\n+      --------------------------\n+      -- Cumulative_Leap_Secs --\n+      --------------------------\n+\n+      procedure Cumulative_Leap_Secs\n+        (Start_Date    : Time;\n+         End_Date      : Time;\n+         Leaps_Between : out Duration;\n+         Next_Leap_Sec : out Time)\n+      is\n+         End_T      : Time;\n+         K          : Positive;\n+         Leap_Index : Positive;\n+         Start_Tmp  : Time;\n+         Start_T    : Time;\n+\n+         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n+         for  D_Int'Size use Duration'Size;\n+\n+         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n+         D_As_Int  : D_Int;\n+\n+         function To_D_As_Int is new Unchecked_Conversion (Duration, D_Int);\n+\n+      begin\n+         Next_Leap_Sec := After_Last_Leap;\n+\n+         --  We want to throw away the fractional part of seconds. Before\n+         --  proceding with this operation, make sure our working values\n+         --  are non-negative.\n+\n+         if End_Date < 0.0 then\n+            Leaps_Between := 0.0;\n+            return;\n+         end if;\n+\n+         if Start_Date < 0.0 then\n+            Start_Tmp := Time (0.0);\n+         else\n+            Start_Tmp := Start_Date;\n+         end if;\n+\n+         if Start_Date <= Leap_Second_Times (N_Leap_Secs) then\n+\n+            --  Manipulate the fixed point value as an integer, similar to\n+            --  Ada.Calendar.Split in order to remove the fractional part\n+            --  from the time we will work with, Start_T and End_T.\n+\n+            D_As_Int := To_D_As_Int (Duration (Start_Tmp));\n+            D_As_Int := D_As_Int / Small_Div;\n+            Start_T  := Time (D_As_Int);\n+            D_As_Int := To_D_As_Int (Duration (End_Date));\n+            D_As_Int := D_As_Int / Small_Div;\n+            End_T    := Time (D_As_Int);\n+\n+            Leap_Index := 1;\n+            loop\n+               exit when Leap_Second_Times (Leap_Index) >= Start_T;\n+               Leap_Index := Leap_Index + 1;\n+            end loop;\n+\n+            K := Leap_Index;\n+            loop\n+               exit when K > N_Leap_Secs or else\n+                 Leap_Second_Times (K) >= End_T;\n+               K := K + 1;\n+            end loop;\n+\n+            if K <= N_Leap_Secs then\n+               Next_Leap_Sec := Leap_Second_Times (K);\n+            end if;\n+\n+            Leaps_Between := Duration (K - Leap_Index);\n+         else\n+            Leaps_Between := Duration (0.0);\n+         end if;\n+      end Cumulative_Leap_Secs;\n+\n+      ----------------------\n+      -- All_Leap_Seconds --\n+      ----------------------\n+\n+      function All_Leap_Seconds return Duration is\n+      begin\n+         return Duration (N_Leap_Secs);\n+         --  Presumes each leap second is +1.0 second;\n+      end All_Leap_Seconds;\n+\n+   --  Start of processing in package Leap_Sec_Ops\n+\n+   begin\n+      declare\n+         Days         : Natural;\n+         Is_Leap_Year : Boolean;\n+         Years        : Natural;\n+\n+         Cumulative_Days_Before_Month :\n+           constant array (Month_Number) of Natural :=\n+             (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334);\n+      begin\n+         for J in 1 .. N_Leap_Secs loop\n+            Years := Leap_Second_Dates (J).Year - Unix_Year_Min;\n+            Days  := (Years / 4) * Days_In_4_Years;\n+            Years := Years mod 4;\n+            Is_Leap_Year := False;\n+\n+            if Years = 1 then\n+               Days := Days + 365;\n+\n+            elsif Years = 2 then\n+               Is_Leap_Year := True;\n+\n+               --  1972 or multiple of 4 after\n+\n+               Days := Days + 365 * 2;\n+\n+            elsif Years = 3 then\n+               Days := Days + 365 * 3 + 1;\n+            end if;\n+\n+            Days := Days + Cumulative_Days_Before_Month\n+                             (Leap_Second_Dates (J).Month);\n+\n+            if Is_Leap_Year\n+              and then Leap_Second_Dates (J).Month > 2\n+            then\n+               Days := Days + 1;\n+            end if;\n+\n+            Days := Days + Leap_Second_Dates (J).Day;\n+\n+            Leap_Second_Times (J) :=\n+              Time (Days * Duration (86_400.0) + Duration (J - 1));\n+\n+            --  Add one to get to the leap second. Add J - 1 previous\n+            --  leap seconds.\n+\n+         end loop;\n+      end;\n+   end Leap_Sec_Ops;\n+\n begin\n    System.OS_Primitives.Initialize;\n end Ada.Calendar;"}, {"sha": "9f4e66a1d43c8c02aed9d82b1a846262d3eb3397", "filename": "gcc/ada/a-calend.ads", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.ads?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -127,4 +127,66 @@ private\n \n    type Time is new Duration;\n \n+   --  The following package provides handling of leap seconds. It is\n+   --  used by Ada.Calendar.Arithmetic and Ada.Calendar.Formatting, both\n+   --  Ada 2005 children of Ada.Calendar.\n+\n+   package Leap_Sec_Ops is\n+\n+      After_Last_Leap : constant Time := Time'Last;\n+      --  Bigger by far than any leap second value. Not within range of\n+      --  Ada.Calendar specified dates.\n+\n+      procedure Cumulative_Leap_Secs\n+        (Start_Date    : Time;\n+         End_Date      : Time;\n+         Leaps_Between : out Duration;\n+         Next_Leap_Sec : out Time);\n+      --  Leaps_Between is the sum of the leap seconds that have occured\n+      --  on or after Start_Date and before (strictly before) End_Date.\n+      --  Next_Leap_Sec represents the next leap second occurence on or\n+      --  after End_Date. If there are no leaps seconds after End_Date,\n+      --  After_Last_Leap is returned. This does not provide info about\n+      --  the next leap second (pos/neg or ?). After_Last_Leap can be used\n+      --  as End_Date to count all the leap seconds that have occured on\n+      --  or after Start_Date.\n+      --\n+      --  Important Notes: any fractional parts of Start_Date and End_Date\n+      --  are discarded before the calculations are done. For instance: if\n+      --  113 seconds is a leap second (it isn't) and 113.5 is input as an\n+      --  End_Date, the leap second at 113 will not be counted in\n+      --  Leaps_Between, but it will be returned as Next_Leap_Sec. Thus, if\n+      --  the caller wants to know if the End_Date is a leap second, the\n+      --  comparison should be:\n+      --\n+      --     End_Date >= Next_Leap_Sec;\n+      --\n+      --  After_Last_Leap is designed so that this comparison works without\n+      --  having to first check if Next_Leap_Sec is a valid leap second.\n+\n+      function All_Leap_Seconds return Duration;\n+      --  Returns the sum off all of the leap seoncds.\n+\n+   end Leap_Sec_Ops;\n+\n+   procedure Split_With_Offset\n+     (Date    : Time;\n+      Year    : out Year_Number;\n+      Month   : out Month_Number;\n+      Day     : out Day_Number;\n+      Seconds : out Day_Duration;\n+      Offset  : out Long_Integer);\n+   --  Split_W_Offset has the same spec as Split with the addition of an\n+   --  offset value which give the offset of the local time zone from UTC\n+   --  at the input Date. This value comes for free during the implementation\n+   --  of Split and is needed by UTC_Time_Offset. The returned Offset time\n+   --  is straight from the C tm struct and is in seconds. If the system\n+   --  dependent code has no way to find the offset it will return the value\n+   --  Invalid_TZ_Offset declared below. Otherwise no checking is done, so\n+   --  it is up to the user to check both for Invalid_TZ_Offset and otherwise\n+   --  for a value that is acceptable.\n+\n+   Invalid_TZ_Offset : Long_Integer;\n+   pragma Import (C, Invalid_TZ_Offset, \"__gnat_invalid_tzoff\");\n+\n end Ada.Calendar;"}, {"sha": "23d2ab5850f6c8778bbd3036a53cb3cf13a8ae34", "filename": "gcc/ada/a-calfor.adb", "status": "added", "additions": 1135, "deletions": 0, "changes": 1135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calfor.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calfor.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calfor.adb?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -0,0 +1,1135 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . C A L E N D A R . F O R M A T T I N G               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Calendar;            use Ada.Calendar;\n+with Ada.Calendar.Time_Zones; use Ada.Calendar.Time_Zones;\n+with Unchecked_Conversion;\n+\n+package body Ada.Calendar.Formatting is\n+\n+   use Leap_Sec_Ops;\n+\n+   Days_In_4_Years          : constant := 365 * 3 + 366;\n+   Seconds_In_Day           : constant := 86_400;\n+   Seconds_In_4_Years       : constant := Days_In_4_Years * Seconds_In_Day;\n+   Seconds_In_Non_Leap_Year : constant := 365 * Seconds_In_Day;\n+\n+   --  Exact time bounds for the range of Ada time: January 1, 1901 -\n+   --  December 31, 2099. These bounds are based on the Unix Time of Epoc,\n+   --  January 1, 1970. Start of Time is -69 years from TOE while End of\n+   --  time is +130 years and one second from TOE.\n+\n+   Start_Of_Time : constant Time :=\n+                     Time (-(17 * Seconds_In_4_Years +\n+                                  Seconds_In_Non_Leap_Year));\n+\n+   End_Of_Time   : constant Time :=\n+                     Time (32 * Seconds_In_4_Years +\n+                            2 * Seconds_In_Non_Leap_Year) +\n+                                All_Leap_Seconds;\n+\n+   Days_In_Month : constant array (Month_Number) of Day_Number :=\n+     (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\n+\n+   procedure Check_Char (S : String; C : Character; Index : Integer);\n+   --  Subsidiary to the two versions of Value. Determine whether the\n+   --  input strint S has character C at position Index. Raise\n+   --  Constraint_Error if there is a mismatch.\n+\n+   procedure Check_Digit (S : String; Index : Integer);\n+   --  Subsidiary to the two versions of Value. Determine whether the\n+   --  character of string S at position Index is a digit. This catches\n+   --  invalid input such as 1983-*1-j3 u5:n7:k9 which should be\n+   --  1983-01-03 05:07:09. Raise Constraint_Error if there is a mismatch.\n+\n+   ----------------\n+   -- Check_Char --\n+   ----------------\n+\n+   procedure Check_Char (S : String; C : Character; Index : Integer) is\n+   begin\n+      if S (Index) /= C then\n+         raise Constraint_Error;\n+      end if;\n+   end Check_Char;\n+\n+   -----------------\n+   -- Check_Digit --\n+   -----------------\n+\n+   procedure Check_Digit (S : String; Index : Integer) is\n+   begin\n+      if S (Index) not in '0' .. '9' then\n+         raise Constraint_Error;\n+      end if;\n+   end Check_Digit;\n+\n+   ---------\n+   -- Day --\n+   ---------\n+\n+   function Day\n+     (Date      : Time;\n+      Time_Zone : Time_Zones.Time_Offset := 0) return Day_Number\n+   is\n+      Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration;\n+      Leap_Second : Boolean;\n+\n+   begin\n+      Split (Date, Year, Month, Day,\n+             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n+      return Day;\n+   end Day;\n+\n+   -----------------\n+   -- Day_Of_Week --\n+   -----------------\n+\n+   function Day_Of_Week (Date : Time) return Day_Name is\n+      Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration;\n+      Leap_Second : Boolean;\n+\n+      D           : Duration;\n+      Day_Count   : Long_Long_Integer;\n+      Midday_Date : Time;\n+      Secs_Count  : Long_Long_Integer;\n+\n+   begin\n+      --  Split the Date to obtain the year, month and day, then build a time\n+      --  value for the middle of the same day, so that we don't have to worry\n+      --  about leap seconds in the subsequent arithmetic.\n+\n+      Split (Date, Year, Month, Day,\n+             Hour, Minute, Second, Sub_Second, Leap_Second);\n+\n+      Midday_Date := Time_Of (Year, Month, Day, 12, 0, 0);\n+      D           := Midday_Date - Start_Of_Time;\n+\n+      --  D is a positive Duration value counting seconds since 1901. Convert\n+      --  it into an integer for ease of arithmetic.\n+\n+      declare\n+         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n+         for D_Int'Size use Duration'Size;\n+\n+         function To_D_Int is new Unchecked_Conversion (Duration, D_Int);\n+\n+         D_As_Int  : constant D_Int := To_D_Int (D);\n+         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n+\n+      begin\n+         Secs_Count := Long_Long_Integer (D_As_Int / Small_Div);\n+      end;\n+\n+      Day_Count := Secs_Count / Seconds_In_Day;\n+      Day_Count := Day_Count + 1;  --  Jan 1, 1901 was a Tuesday;\n+\n+      return Day_Name'Val (Day_Count mod 7);\n+   end Day_Of_Week;\n+\n+   ----------\n+   -- Hour --\n+   ----------\n+\n+   function Hour\n+     (Date      : Time;\n+      Time_Zone : Time_Zones.Time_Offset := 0) return Hour_Number\n+   is\n+      Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration;\n+      Leap_Second : Boolean;\n+\n+   begin\n+      Split (Date, Year, Month, Day,\n+             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n+      return Hour;\n+   end Hour;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image\n+     (Elapsed_Time          : Duration;\n+      Include_Time_Fraction : Boolean := False) return String\n+   is\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number;\n+      Sub_Second : Second_Duration;\n+      SS_Nat     : Natural;\n+\n+      Result : String := \"00:00:00.00\";\n+\n+   begin\n+      Split (Elapsed_Time, Hour, Minute, Second, Sub_Second);\n+      SS_Nat := Natural (Sub_Second * 100.0);\n+\n+      declare\n+         Hour_Str   : constant String := Hour_Number'Image (Hour);\n+         Minute_Str : constant String := Minute_Number'Image (Minute);\n+         Second_Str : constant String := Second_Number'Image (Second);\n+         SS_Str     : constant String := Natural'Image (SS_Nat);\n+\n+      begin\n+         --  Hour processing, positions 1 and 2\n+\n+         if Hour < 10 then\n+            Result (2) := Hour_Str (2);\n+         else\n+            Result (1) := Hour_Str (2);\n+            Result (2) := Hour_Str (3);\n+         end if;\n+\n+         --  Minute processing, positions 4 and 5\n+\n+         if Minute < 10 then\n+            Result (5) := Minute_Str (2);\n+         else\n+            Result (4) := Minute_Str (2);\n+            Result (5) := Minute_Str (3);\n+         end if;\n+\n+         --  Second processing, positions 7 and 8\n+\n+         if Second < 10 then\n+            Result (8) := Second_Str (2);\n+         else\n+            Result (7) := Second_Str (2);\n+            Result (8) := Second_Str (3);\n+         end if;\n+\n+         --  Optional sub second processing, positions 10 and 11\n+\n+         if Include_Time_Fraction then\n+            if SS_Nat < 10 then\n+               Result (11) := SS_Str (2);\n+            else\n+               Result (10) := SS_Str (2);\n+               Result (11) := SS_Str (3);\n+            end if;\n+\n+            return Result;\n+         else\n+            return Result (1 .. 8);\n+         end if;\n+      end;\n+   end Image;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image\n+     (Date                  : Time;\n+      Include_Time_Fraction : Boolean := False;\n+      Time_Zone             : Time_Zones.Time_Offset := 0) return String\n+   is\n+      Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration;\n+      SS_Nat      : Natural;\n+      Leap_Second : Boolean;\n+\n+      Result : String := \"0000-00-00 00:00:00.00\";\n+\n+   begin\n+      Split (Date, Year, Month, Day,\n+             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n+\n+      SS_Nat := Natural (Sub_Second * 100.0);\n+\n+      declare\n+         Year_Str   : constant String := Year_Number'Image (Year);\n+         Month_Str  : constant String := Month_Number'Image (Month);\n+         Day_Str    : constant String := Day_Number'Image (Day);\n+         Hour_Str   : constant String := Hour_Number'Image (Hour);\n+         Minute_Str : constant String := Minute_Number'Image (Minute);\n+         Second_Str : constant String := Second_Number'Image (Second);\n+         SS_Str     : constant String := Natural'Image (SS_Nat);\n+\n+      begin\n+         --  Year processing, positions 1, 2, 3 and 4\n+\n+         Result (1) := Year_Str (2);\n+         Result (2) := Year_Str (3);\n+         Result (3) := Year_Str (4);\n+         Result (4) := Year_Str (5);\n+\n+         --  Month processing, positions 6 and 7\n+\n+         if Month < 10 then\n+            Result (7) := Month_Str (2);\n+         else\n+            Result (6) := Month_Str (2);\n+            Result (7) := Month_Str (3);\n+         end if;\n+\n+         --  Day processing, positions 9 and 10\n+\n+         if Day < 10 then\n+            Result (10) := Day_Str (2);\n+         else\n+            Result (9)  := Day_Str (2);\n+            Result (10) := Day_Str (3);\n+         end if;\n+\n+         --  Hour processing, positions 12 and 13\n+\n+         if Hour < 10 then\n+            Result (13) := Hour_Str (2);\n+         else\n+            Result (12) := Hour_Str (2);\n+            Result (13) := Hour_Str (3);\n+         end if;\n+\n+         --  Minute processing, positions 15 and 16\n+\n+         if Minute < 10 then\n+            Result (16) := Minute_Str (2);\n+         else\n+            Result (15) := Minute_Str (2);\n+            Result (16) := Minute_Str (3);\n+         end if;\n+\n+         --  Second processing, positions 18 and 19\n+\n+         if Second < 10 then\n+            Result (19) := Second_Str (2);\n+         else\n+            Result (18) := Second_Str (2);\n+            Result (19) := Second_Str (3);\n+         end if;\n+\n+         --  Optional sub second processing, positions 21 and 22\n+\n+         if Include_Time_Fraction then\n+            if SS_Nat < 10 then\n+               Result (22) := SS_Str (2);\n+            else\n+               Result (21) := SS_Str (2);\n+               Result (22) := SS_Str (3);\n+            end if;\n+\n+            return Result;\n+         else\n+            return Result (1 .. 19);\n+         end if;\n+      end;\n+   end Image;\n+\n+   ------------\n+   -- Minute --\n+   ------------\n+\n+   function Minute\n+     (Date      : Time;\n+      Time_Zone : Time_Zones.Time_Offset := 0) return Minute_Number\n+   is\n+      Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration;\n+      Leap_Second : Boolean;\n+\n+   begin\n+      Split (Date, Year, Month, Day,\n+             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n+      return Minute;\n+   end Minute;\n+\n+   -----------\n+   -- Month --\n+   -----------\n+\n+   function Month\n+     (Date      : Time;\n+      Time_Zone : Time_Zones.Time_Offset := 0) return Month_Number\n+   is\n+      Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration;\n+      Leap_Second : Boolean;\n+\n+   begin\n+      Split (Date, Year, Month, Day,\n+             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n+      return Month;\n+   end Month;\n+\n+   ------------\n+   -- Second --\n+   ------------\n+\n+   function Second (Date : Time) return Second_Number is\n+      Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration;\n+      Leap_Second : Boolean;\n+\n+   begin\n+      Split (Date, Year, Month, Day,\n+             Hour, Minute, Second, Sub_Second, Leap_Second);\n+      return Second;\n+   end Second;\n+\n+   ----------------\n+   -- Seconds_Of --\n+   ----------------\n+\n+   function Seconds_Of\n+     (Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number := 0;\n+      Sub_Second : Second_Duration := 0.0) return Day_Duration is\n+\n+   begin\n+      --  Validity checks\n+\n+      if not Hour'Valid\n+        or else not Minute'Valid\n+        or else not Second'Valid\n+        or else not Sub_Second'Valid\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Day_Duration (Hour   * 3600) +\n+             Day_Duration (Minute *   60) +\n+             Day_Duration (Second)        +\n+                           Sub_Second;\n+   end Seconds_Of;\n+\n+   -----------\n+   -- Split --\n+   -----------\n+\n+   procedure Split\n+     (Seconds    : Day_Duration;\n+      Hour       : out Hour_Number;\n+      Minute     : out Minute_Number;\n+      Second     : out Second_Number;\n+      Sub_Second : out Second_Duration)\n+   is\n+      Secs : Natural;\n+\n+   begin\n+      --  Validity checks\n+\n+      if not Seconds'Valid then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Seconds = 0.0 then\n+         Secs := 0;\n+      else\n+         Secs := Natural (Seconds - 0.5);\n+      end if;\n+\n+      Sub_Second := Second_Duration (Seconds - Day_Duration (Secs));\n+      Hour       := Hour_Number (Secs / 3600);\n+      Secs       := Secs mod 3600;\n+      Minute     := Minute_Number (Secs / 60);\n+      Second     := Second_Number (Secs mod 60);\n+   end Split;\n+\n+   -----------\n+   -- Split --\n+   -----------\n+\n+   procedure Split\n+     (Date        : Time;\n+      Year        : out Year_Number;\n+      Month       : out Month_Number;\n+      Day         : out Day_Number;\n+      Seconds     : out Day_Duration;\n+      Leap_Second : out Boolean;\n+      Time_Zone   : Time_Zones.Time_Offset := 0)\n+   is\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration;\n+\n+   begin\n+      Split (Date, Year, Month, Day,\n+             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n+\n+      Seconds := Seconds_Of (Hour, Minute, Second, Sub_Second);\n+   end Split;\n+\n+   -----------\n+   -- Split --\n+   -----------\n+\n+   procedure Split\n+     (Date       : Time;\n+      Year       : out Year_Number;\n+      Month      : out Month_Number;\n+      Day        : out Day_Number;\n+      Hour       : out Hour_Number;\n+      Minute     : out Minute_Number;\n+      Second     : out Second_Number;\n+      Sub_Second : out Second_Duration;\n+      Time_Zone  : Time_Zones.Time_Offset := 0)\n+   is\n+      Leap_Second : Boolean;\n+\n+   begin\n+      Split (Date, Year, Month, Day,\n+             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n+   end Split;\n+\n+   -----------\n+   -- Split --\n+   -----------\n+\n+   procedure Split\n+     (Date        : Time;\n+      Year        : out Year_Number;\n+      Month       : out Month_Number;\n+      Day         : out Day_Number;\n+      Hour        : out Hour_Number;\n+      Minute      : out Minute_Number;\n+      Second      : out Second_Number;\n+      Sub_Second  : out Second_Duration;\n+      Leap_Second : out Boolean;\n+      Time_Zone   : Time_Zones.Time_Offset := 0)\n+   is\n+      Ada_Year_Min    : constant Year_Number := Year_Number'First;\n+      Day_In_Year     : Integer;\n+      Day_Second      : Integer;\n+      Elapsed_Leaps   : Duration;\n+      Hour_Second     : Integer;\n+      In_Leap_Year    : Boolean;\n+      Modified_Date   : Time;\n+      Next_Leap       : Time;\n+      Remaining_Years : Integer;\n+      Seconds_Count   : Long_Long_Integer;\n+\n+   begin\n+      --  Our measurement of time is the number of seconds that have elapsed\n+      --  since the Unix TOE. To calculate a UTC date from this we do a\n+      --  sequence of divides and mods to get the components of a date based\n+      --  on 86,400 seconds in each day. Since, UTC time depends upon the\n+      --  occasional insertion of leap seconds, the number of leap seconds\n+      --  that have been added prior to the input time are then subtracted\n+      --  from the previous calculation. In fact, it is easier to do the\n+      --  subtraction first, so a more accurate discription of what is\n+      --  actually done, is that the number of added leap seconds is looked\n+      --  up using the input Time value, than that number of seconds is\n+      --  subtracted before the sequence of divides and mods.\n+      --\n+      --  If the input date turns out to be a leap second, we don't add it to\n+      --  date (we want to return 23:59:59) but we set the Leap_Second output\n+      --  to true.\n+\n+      --  Is there a need to account for a difference from Unix time prior\n+      --  to the first leap second ???\n+\n+      --  Step 1: Determine the number of leap seconds since the start\n+      --  of Ada time and the input date as well as the next leap second\n+      --  occurence and process accordingly.\n+\n+      Cumulative_Leap_Secs (Start_Of_Time, Date, Elapsed_Leaps, Next_Leap);\n+\n+      Leap_Second   := Date >= Next_Leap;\n+      Modified_Date := Date - Elapsed_Leaps;\n+\n+      if Leap_Second then\n+         Modified_Date := Modified_Date - Duration (1.0);\n+      end if;\n+\n+      --  Step 2: Process the time zone\n+\n+      Modified_Date := Modified_Date + Duration (Time_Zone * 60);\n+\n+      --  Step 3: Sanity check on the calculated date. Since the leap\n+      --  seconds and the time zone have been eliminated, the result needs\n+      --  to be within the range of Ada time.\n+\n+      if Modified_Date < Start_Of_Time\n+        or else Modified_Date >= (End_Of_Time - All_Leap_Seconds)\n+      then\n+         raise Time_Error;\n+      end if;\n+\n+      Modified_Date := Modified_Date - Start_Of_Time;\n+\n+      declare\n+         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n+         for D_Int'Size use Duration'Size;\n+\n+         function To_D_Int is new Unchecked_Conversion (Duration, D_Int);\n+         function To_Duration is new Unchecked_Conversion (D_Int, Duration);\n+         function To_Duration is new Unchecked_Conversion (Time, Duration);\n+\n+         D_As_Int  : constant D_Int := To_D_Int (To_Duration (Modified_Date));\n+         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n+\n+      begin\n+         Seconds_Count := Long_Long_Integer (D_As_Int / Small_Div);\n+         Sub_Second    := Second_Duration\n+                            (To_Duration (D_As_Int rem Small_Div));\n+      end;\n+\n+      --  Step 4: Calculate the number of years since the start of Ada time.\n+      --  First consider sequences of four years, then the remaining years.\n+\n+      Year := Ada_Year_Min + 4 * Integer (Seconds_Count / Seconds_In_4_Years);\n+      Seconds_Count   := Seconds_Count mod Seconds_In_4_Years;\n+      Remaining_Years := Integer (Seconds_Count / Seconds_In_Non_Leap_Year);\n+\n+      if Remaining_Years > 3 then\n+         Remaining_Years := 3;\n+      end if;\n+\n+      Year := Year + Remaining_Years;\n+\n+      --  Remove the seconds elapsed in those remaining years\n+\n+      Seconds_Count := Seconds_Count - Long_Long_Integer\n+                         (Remaining_Years * Seconds_In_Non_Leap_Year);\n+      In_Leap_Year := (Year mod 4) = 0;\n+\n+      --  Step 5: Month and day processing. Determine the day to which the\n+      --  remaining seconds map to.\n+\n+      Day_In_Year := Integer (Seconds_Count / Seconds_In_Day) + 1;\n+\n+      Month := 1;\n+\n+      if Day_In_Year > 31 then\n+         Month       := 2;\n+         Day_In_Year := Day_In_Year - 31;\n+\n+         if Day_In_Year > 28\n+           and then ((not In_Leap_Year)\n+                        or else Day_In_Year > 29)\n+         then\n+            Month       := 3;\n+            Day_In_Year := Day_In_Year - 28;\n+\n+            if In_Leap_Year then\n+               Day_In_Year := Day_In_Year - 1;\n+            end if;\n+\n+            while Day_In_Year > Days_In_Month (Month) loop\n+               Day_In_Year := Day_In_Year - Days_In_Month (Month);\n+               Month := Month + 1;\n+            end loop;\n+         end if;\n+      end if;\n+\n+      --  Step 6: Hour, minute and second processing\n+\n+      Day         := Day_In_Year;\n+      Day_Second  := Integer (Seconds_Count mod Seconds_In_Day);\n+      Hour        := Day_Second / 3600;\n+      Hour_Second := Day_Second mod 3600;\n+      Minute      := Hour_Second / 60;\n+      Second      := Hour_Second mod 60;\n+   end Split;\n+\n+   ----------------\n+   -- Sub_Second --\n+   ----------------\n+\n+   function Sub_Second (Date : Time) return Second_Duration is\n+      Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration;\n+      Leap_Second : Boolean;\n+\n+   begin\n+      Split (Date, Year, Month, Day,\n+             Hour, Minute, Second, Sub_Second, Leap_Second);\n+\n+      return Sub_Second;\n+   end Sub_Second;\n+\n+   -------------\n+   -- Time_Of --\n+   -------------\n+\n+   function Time_Of\n+     (Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Seconds     : Day_Duration := 0.0;\n+      Leap_Second : Boolean := False;\n+      Time_Zone   : Time_Zones.Time_Offset := 0) return Time\n+   is\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Sec_Num    : Second_Number;\n+      Sub_Sec    : Second_Duration;\n+      Whole_Part : Integer;\n+\n+   begin\n+      if not Seconds'Valid then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  The fact that Seconds can go to 86,400 creates all this extra work.\n+      --  Perhaps a Time_Of just like the next one but allowing the Second_\n+      --  Number input to reach 60 should become an internal version that this\n+      --  and the next version call.... but for now we do the ugly bumping up\n+      --  of Day, Month and Year;\n+\n+      if Seconds = 86_400.0 then\n+         declare\n+            Adj_Year  : Year_Number  := Year;\n+            Adj_Month : Month_Number := Month;\n+            Adj_Day   : Day_Number   := Day;\n+\n+         begin\n+            Hour    := 0;\n+            Minute  := 0;\n+            Sec_Num := 0;\n+            Sub_Sec := 0.0;\n+\n+            if Day < Days_In_Month (Month)\n+              or else (Month = 2\n+                         and then Year mod 4 = 0)\n+            then\n+               Adj_Day := Day + 1;\n+            else\n+               Adj_Day := 1;\n+\n+               if Month < 12 then\n+                  Adj_Month := Month + 1;\n+               else\n+                  Adj_Month := 1;\n+                  Adj_Year  := Year + 1;\n+               end if;\n+            end if;\n+\n+            return Time_Of (Adj_Year, Adj_Month, Adj_Day, Hour, Minute,\n+                            Sec_Num, Sub_Sec, Leap_Second, Time_Zone);\n+         end;\n+      end if;\n+\n+      declare\n+         type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n+         for D_Int'Size use Duration'Size;\n+\n+         function To_D_Int is new Unchecked_Conversion (Duration, D_Int);\n+         function To_Duration is new Unchecked_Conversion (D_Int, Duration);\n+\n+         D_As_Int  : constant D_Int := To_D_Int (Seconds);\n+         Small_Div : constant D_Int := D_Int (1.0 / Duration'Small);\n+\n+      begin\n+         Whole_Part := Integer (D_As_Int / Small_Div);\n+         Sub_Sec    := Second_Duration\n+                         (To_Duration (D_As_Int rem Small_Div));\n+      end;\n+\n+      Hour       := Hour_Number (Whole_Part / 3600);\n+      Whole_Part := Whole_Part mod 3600;\n+      Minute     := Minute_Number (Whole_Part / 60);\n+      Sec_Num    := Second_Number (Whole_Part mod 60);\n+\n+      return Time_Of (Year, Month, Day,\n+                      Hour, Minute, Sec_Num, Sub_Sec, Leap_Second, Time_Zone);\n+   end Time_Of;\n+\n+   -------------\n+   -- Time_Of --\n+   -------------\n+\n+   function Time_Of\n+     (Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration := 0.0;\n+      Leap_Second : Boolean := False;\n+      Time_Zone   : Time_Zones.Time_Offset := 0) return Time\n+   is\n+      Cumulative_Days_Before_Month :\n+        constant array (Month_Number) of Natural :=\n+          (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334);\n+\n+      Ada_Year_Min         : constant Year_Number := Year_Number'First;\n+      Count                : Integer;\n+      Elapsed_Leap_Seconds : Duration;\n+      Fractional_Second    : Duration;\n+      Next_Leap            : Time;\n+      Result               : Time;\n+\n+   begin\n+      --  The following checks are redundant with respect to the constraint\n+      --  error checks that should normally be made on parameters, but we\n+      --  decide to raise Constraint_Error in any case if bad values come in\n+      --  (as a result of checks being off in the caller, or for other\n+      --  erroneous or bounded error cases).\n+\n+      if not Year'Valid\n+        or else not Month'Valid\n+        or else not Day'Valid\n+        or else not Hour'Valid\n+        or else not Minute'Valid\n+        or else not Second'Valid\n+        or else not Sub_Second'Valid\n+        or else not Time_Zone'Valid\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  Start the accumulation from the beginning of Ada time\n+\n+      Result := Start_Of_Time;\n+\n+      --  Step 1: Determine the number of leap and non-leap years since 1901\n+      --  and the input date.\n+\n+      --  Count the number of four year segments\n+\n+      Count  := (Year - Ada_Year_Min) / 4;\n+      Result := Result + Duration (Count * Seconds_In_4_Years);\n+\n+      --  Count the number of remaining non-leap years\n+\n+      Count  := (Year - Ada_Year_Min) mod 4;\n+      Result := Result + Duration (Count * Seconds_In_Non_Leap_Year);\n+\n+      --  Step 2: Determine the number of days elapsed singe the start of the\n+      --  input year and add them to the result.\n+\n+      --  Do not include the current day since it is not over yet\n+\n+      Count := Cumulative_Days_Before_Month (Month) + Day - 1;\n+\n+      --  The input year is a leap year and we have passed February\n+\n+      if (Year mod 4) = 0\n+        and then Month > 2\n+      then\n+         Count := Count + 1;\n+      end if;\n+\n+      Result := Result + Duration (Count * Seconds_In_Day);\n+\n+      --  Step 3: Hour, minute and second processing\n+\n+      Result := Result + Duration (Hour   * 3600) +\n+                         Duration (Minute *   60) +\n+                         Duration (Second);\n+\n+      --  The sub second may designate a whole second\n+\n+      if Sub_Second = 1.0 then\n+         Result            := Result + Duration (1.0);\n+         Fractional_Second := 0.0;\n+      else\n+         Fractional_Second := Sub_Second;\n+      end if;\n+\n+      --  Step 4: Time zone processing\n+\n+      Result := Result - Duration (Time_Zone * 60);\n+\n+      --  Step 5: The caller wants a leap second\n+\n+      if Leap_Second then\n+         Result := Result + Duration (1.0);\n+      end if;\n+\n+      --  Step 6: Calculate the number of leap seconds occured since the\n+      --  start of Ada time and the current point in time. The following\n+      --  is an approximation which does not yet count leap seconds. It\n+      --  can be pushed beyond 1 leap second, but not more.\n+\n+      Cumulative_Leap_Secs\n+        (Start_Of_Time, Result, Elapsed_Leap_Seconds, Next_Leap);\n+\n+      Result := Result + Elapsed_Leap_Seconds;\n+\n+      --  Step 7: Validity check of a leap second occurence. It requires an\n+      --  additional comparison to Next_Leap to ensure that we landed right\n+      --  on a valid occurence and that Elapsed_Leap_Seconds did not shoot\n+      --  past it.\n+\n+      if Leap_Second\n+        and then\n+           not (Result >= Next_Leap\n+                  and then Result - Duration (1.0) < Next_Leap)\n+      then\n+         raise Time_Error;\n+      end if;\n+\n+      --  Step 8: Final sanity check on the calculated duration value\n+\n+      if Result < Start_Of_Time\n+        or else Result >= End_Of_Time\n+      then\n+         raise Time_Error;\n+      end if;\n+\n+      --  Step 9: Lastly, add the sub second part\n+\n+      return Result + Fractional_Second;\n+   end Time_Of;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value\n+     (Date      : String;\n+      Time_Zone : Time_Zones.Time_Offset := 0) return Time\n+   is\n+      D          : String (1 .. 22);\n+      Year       : Year_Number;\n+      Month      : Month_Number;\n+      Day        : Day_Number;\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number;\n+      Sub_Second : Second_Duration := 0.0;\n+\n+   begin\n+      --  Validity checks\n+\n+      if not Time_Zone'Valid then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  Length checks\n+\n+      if Date'Length /= 19\n+        and then Date'Length /= 22\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  After the correct length has been determined, it is safe to\n+      --  copy the Date in order to avoid Date'First + N indexing.\n+\n+      D (1 .. Date'Length) := Date;\n+\n+      --  Format checks\n+\n+      Check_Char (D, '-', 5);\n+      Check_Char (D, '-', 8);\n+      Check_Char (D, ' ', 11);\n+      Check_Char (D, ':', 14);\n+      Check_Char (D, ':', 17);\n+\n+      if Date'Length = 22 then\n+         Check_Char (D, '.', 20);\n+      end if;\n+\n+      --  Leading zero checks\n+\n+      Check_Digit (D, 6);\n+      Check_Digit (D, 9);\n+      Check_Digit (D, 12);\n+      Check_Digit (D, 15);\n+      Check_Digit (D, 18);\n+\n+      if Date'Length = 22 then\n+         Check_Digit (D, 21);\n+      end if;\n+\n+      --  Value extraction\n+\n+      Year   := Year_Number   (Year_Number'Value   (D (1 .. 4)));\n+      Month  := Month_Number  (Month_Number'Value  (D (6 .. 7)));\n+      Day    := Day_Number    (Day_Number'Value    (D (9 .. 10)));\n+      Hour   := Hour_Number   (Hour_Number'Value   (D (12 .. 13)));\n+      Minute := Minute_Number (Minute_Number'Value (D (15 .. 16)));\n+      Second := Second_Number (Second_Number'Value (D (18 .. 19)));\n+\n+      --  Optional part\n+\n+      if Date'Length = 22 then\n+         Sub_Second := Second_Duration (Second_Duration'Value (D (20 .. 22)));\n+      end if;\n+\n+      --  Sanity checks\n+\n+      if not Year'Valid\n+        or else not Month'Valid\n+        or else not Day'Valid\n+        or else not Hour'Valid\n+        or else not Minute'Valid\n+        or else not Second'Valid\n+        or else not Sub_Second'Valid\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Time_Of (Year, Month, Day,\n+                      Hour, Minute, Second, Sub_Second, False, Time_Zone);\n+\n+   exception\n+      when others => raise Constraint_Error;\n+   end Value;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (Elapsed_Time : String) return Duration is\n+      D          : String (1 .. 11);\n+      Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number;\n+      Sub_Second : Second_Duration := 0.0;\n+\n+   begin\n+      --  Length checks\n+\n+      if Elapsed_Time'Length /= 8\n+        and then Elapsed_Time'Length /= 11\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  After the correct length has been determined, it is safe to\n+      --  copy the Elapsed_Time in order to avoid Date'First + N indexing.\n+\n+      D (1 .. Elapsed_Time'Length) := Elapsed_Time;\n+\n+      --  Format checks\n+\n+      Check_Char (D, ':', 3);\n+      Check_Char (D, ':', 6);\n+\n+      if Elapsed_Time'Length = 11 then\n+         Check_Char (D, '.', 9);\n+      end if;\n+\n+      --  Leading zero checks\n+\n+      Check_Digit (D, 1);\n+      Check_Digit (D, 4);\n+      Check_Digit (D, 7);\n+\n+      if Elapsed_Time'Length = 11 then\n+         Check_Digit (D, 10);\n+      end if;\n+\n+      --  Value extraction\n+\n+      Hour   := Hour_Number   (Hour_Number'Value   (D (1 .. 2)));\n+      Minute := Minute_Number (Minute_Number'Value (D (4 .. 5)));\n+      Second := Second_Number (Second_Number'Value (D (7 .. 8)));\n+\n+      --  Optional part\n+\n+      if Elapsed_Time'Length = 11 then\n+         Sub_Second := Second_Duration (Second_Duration'Value (D (9 .. 11)));\n+      end if;\n+\n+      --  Sanity checks\n+\n+      if not Hour'Valid\n+        or else not Minute'Valid\n+        or else not Second'Valid\n+        or else not Sub_Second'Valid\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Seconds_Of (Hour, Minute, Second, Sub_Second);\n+\n+   exception\n+      when others => raise Constraint_Error;\n+   end Value;\n+\n+   ----------\n+   -- Year --\n+   ----------\n+\n+   function Year\n+     (Date      : Time;\n+      Time_Zone : Time_Zones.Time_Offset := 0) return Year_Number\n+   is\n+      Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration;\n+      Leap_Second : Boolean;\n+\n+   begin\n+      Split (Date, Year, Month, Day,\n+             Hour, Minute, Second, Sub_Second, Leap_Second, Time_Zone);\n+      return Year;\n+   end Year;\n+\n+end Ada.Calendar.Formatting;"}, {"sha": "89e704bb64b69310823261c0f820c129e1e3535c", "filename": "gcc/ada/a-calfor.ads", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calfor.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-calfor.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calfor.ads?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -0,0 +1,163 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . C A L E N D A R . F O R M A T T I N G               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--        Copyright (C) 2005 - 2006, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Calendar.Time_Zones;\n+\n+package Ada.Calendar.Formatting is\n+\n+   --  Day of the week\n+\n+   type Day_Name is\n+     (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday);\n+\n+   function Day_Of_Week (Date : Time) return Day_Name;\n+\n+   --  Hours:Minutes:Seconds access\n+\n+   subtype Hour_Number     is Natural range 0 .. 23;\n+   subtype Minute_Number   is Natural range 0 .. 59;\n+   subtype Second_Number   is Natural range 0 .. 59;\n+   subtype Second_Duration is Day_Duration range 0.0 .. 1.0;\n+\n+   function Year\n+     (Date      : Time;\n+      Time_Zone : Time_Zones.Time_Offset := 0) return Year_Number;\n+\n+   function Month\n+     (Date      : Time;\n+      Time_Zone : Time_Zones.Time_Offset := 0) return Month_Number;\n+\n+   function Day\n+     (Date      : Time;\n+      Time_Zone : Time_Zones.Time_Offset := 0) return Day_Number;\n+\n+   function Hour\n+     (Date      : Time;\n+      Time_Zone : Time_Zones.Time_Offset := 0) return Hour_Number;\n+\n+   function Minute\n+     (Date      : Time;\n+      Time_Zone : Time_Zones.Time_Offset := 0) return Minute_Number;\n+\n+   function Second\n+     (Date : Time)                             return Second_Number;\n+\n+   function Sub_Second\n+     (Date : Time)                             return Second_Duration;\n+\n+   function Seconds_Of\n+     (Hour       : Hour_Number;\n+      Minute     : Minute_Number;\n+      Second     : Second_Number := 0;\n+      Sub_Second : Second_Duration := 0.0) return Day_Duration;\n+\n+   procedure Split\n+     (Seconds    : Day_Duration;\n+      Hour       : out Hour_Number;\n+      Minute     : out Minute_Number;\n+      Second     : out Second_Number;\n+      Sub_Second : out Second_Duration);\n+\n+   procedure Split\n+     (Date       : Time;\n+      Year       : out Year_Number;\n+      Month      : out Month_Number;\n+      Day        : out Day_Number;\n+      Hour       : out Hour_Number;\n+      Minute     : out Minute_Number;\n+      Second     : out Second_Number;\n+      Sub_Second : out Second_Duration;\n+      Time_Zone  : Time_Zones.Time_Offset := 0);\n+\n+   function Time_Of\n+     (Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Hour        : Hour_Number;\n+      Minute      : Minute_Number;\n+      Second      : Second_Number;\n+      Sub_Second  : Second_Duration := 0.0;\n+      Leap_Second : Boolean := False;\n+      Time_Zone   : Time_Zones.Time_Offset := 0) return Time;\n+\n+   function Time_Of\n+     (Year        : Year_Number;\n+      Month       : Month_Number;\n+      Day         : Day_Number;\n+      Seconds     : Day_Duration := 0.0;\n+      Leap_Second : Boolean := False;\n+      Time_Zone   : Time_Zones.Time_Offset := 0) return Time;\n+\n+   procedure Split\n+     (Date        : Time;\n+      Year        : out Year_Number;\n+      Month       : out Month_Number;\n+      Day         : out Day_Number;\n+      Hour        : out Hour_Number;\n+      Minute      : out Minute_Number;\n+      Second      : out Second_Number;\n+      Sub_Second  : out Second_Duration;\n+      Leap_Second : out Boolean;\n+      Time_Zone   : Time_Zones.Time_Offset := 0);\n+\n+   procedure Split\n+     (Date        : Time;\n+      Year        : out Year_Number;\n+      Month       : out Month_Number;\n+      Day         : out Day_Number;\n+      Seconds     : out Day_Duration;\n+      Leap_Second : out Boolean;\n+      Time_Zone   : Time_Zones.Time_Offset := 0);\n+\n+   --  Simple image and value\n+\n+   function Image\n+     (Date                  : Time;\n+      Include_Time_Fraction : Boolean := False;\n+      Time_Zone             : Time_Zones.Time_Offset := 0) return String;\n+\n+   function Value\n+     (Date       : String;\n+      Time_Zone  : Time_Zones.Time_Offset := 0) return Time;\n+\n+   function Image\n+     (Elapsed_Time          : Duration;\n+      Include_Time_Fraction : Boolean := False) return String;\n+\n+   function Value (Elapsed_Time : String) return Duration;\n+\n+end Ada.Calendar.Formatting;"}, {"sha": "8243e8b9639640aa0d45e7eb21a25be80a888bac", "filename": "gcc/ada/a-catizo.adb", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-catizo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-catizo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-catizo.adb?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -0,0 +1,67 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . C A L E N D A R . T I M E _ Z O N E S               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Calendar.Time_Zones is\n+\n+   ---------------------\n+   -- UTC_Time_Offset --\n+   ---------------------\n+\n+   function UTC_Time_Offset (Date : Time := Clock) return Time_Offset is\n+      Year    : Year_Number;\n+      Month   : Month_Number;\n+      Day     : Day_Number;\n+      Seconds : Day_Duration;\n+      Offset  : Long_Integer;\n+\n+   begin\n+      Split_With_Offset (Date, Year, Month, Day, Seconds, Offset);\n+\n+      --  The system dependent code does not support time zones\n+\n+      if Offset = Invalid_TZ_Offset then\n+         raise Unknown_Zone_Error;\n+      end if;\n+\n+      Offset := Offset / 60;\n+\n+      if Offset < Long_Integer (Time_Offset'First)\n+        or else Offset > Long_Integer (Time_Offset'Last)\n+      then\n+         raise Unknown_Zone_Error;\n+      end if;\n+\n+      return Time_Offset (Offset);\n+   end UTC_Time_Offset;\n+\n+end Ada.Calendar.Time_Zones;"}, {"sha": "83907c48e081aa63ec23ea431eb9b2edb558e762", "filename": "gcc/ada/a-catizo.ads", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-catizo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fa-catizo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-catizo.ads?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -0,0 +1,48 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              A D A . C A L E N D A R . T I M E _ Z O N E S               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--        Copyright (C) 2005 - 2006, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Ada.Calendar.Time_Zones is\n+\n+   --  Time zone manipulation\n+\n+   type Time_Offset is range -(28 * 60) .. 28 * 60;\n+\n+   Unknown_Zone_Error : exception;\n+\n+   function UTC_Time_Offset (Date : Time := Clock) return Time_Offset;\n+\n+end Ada.Calendar.Time_Zones;"}, {"sha": "e84979749541536c114833b2cd1f5d0cca878934", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -334,8 +334,10 @@ package body Impunit is\n    -- Ada Hierarchy Units from Ada 2005 Reference Manual --\n    --------------------------------------------------------\n \n+     \"a-calari\",    -- Ada.Calendar.Arithmetic\n+     \"a-calfor\",    -- Ada.Calendar.Formatting\n+     \"a-catizo\",    -- Ada.Calendar.Time_Zones\n      \"a-cdlili\",    -- Ada.Containers.Doubly_Linked_Lists\n-     \"a-cgaaso\",    -- Ada.Containers.Generic_Anonymous_Array_Sort\n      \"a-cgarso\",    -- Ada.Containers.Generic_Array_Sort\n      \"a-cgcaso\",    -- Ada.Containers.Generic_Constrained_Array_Sort\n      \"a-chacon\",    -- Ada.Characters.Conversions\n@@ -353,11 +355,10 @@ package body Impunit is\n      \"a-coorse\",    -- Ada.Containers.Ordered_Sets\n      \"a-coteio\",    -- Ada.Complex_Text_IO\n      \"a-direct\",    -- Ada.Directories\n+     \"a-diroro\",    -- Ada.Dispatching.Round_Robin\n+     \"a-dispat\",    -- Ada.Dispatching\n      \"a-envvar\",    -- Ada.Environment_Variables\n      \"a-rttiev\",    -- Ada.Real_Time.Timing_Events\n-     \"a-secain\",    -- Ada.Strings.Equal_Case_Insensitive\n-     \"a-shcain\",    -- Ada.Strings.Hash_Case_Insensitive\n-     \"a-slcain\",    -- Ada.Strings.Less_Case_Insensitive\n      \"a-stboha\",    -- Ada.Strings.Bounded.Hash\n      \"a-stfiha\",    -- Ada.Strings.Fixed.Hash\n      \"a-strhas\",    -- Ada.Strings.Hash\n@@ -383,6 +384,8 @@ package body Impunit is\n      \"a-wwboio\",    -- Ada.Wide_Text_IO.Wide_Bounded_IO\n      \"a-wwunio\",    -- Ada.Wide_Text_IO.Wide_Unbounded_IO\n      \"a-zchara\",    -- Ada.Wide_Wide_Characters\n+     \"a-ztcoio\",    -- Ada.Wide_Wide_Text_IO.Complex_IO\n+     \"a-ztedit\",    -- Ada.Wide_Wide_Text_IO.Editing\n      \"a-zttest\",    -- Ada.Wide_Wide_Text_IO.Text_Streams\n      \"a-ztexio\",    -- Ada.Wide_Wide_Text_IO\n      \"a-zzboio\",    -- Ada.Wide_Wide_Text_IO.Wide_Wide_Bounded_IO\n@@ -408,10 +411,15 @@ package body Impunit is\n    -- GNAT Defined Additions to Ada 2005 --\n    ----------------------------------------\n \n+     \"a-cgaaso\",    -- Ada.Containers.Generic_Anonymous_Array_Sort\n      \"a-chzla1\",    -- Ada.Characters.Wide_Wide_Latin_1\n      \"a-chzla9\",    -- Ada.Characters.Wide_Wide_Latin_9\n      \"a-ciormu\",    -- Ada.Containers.Indefinite_Ordered_Multisets\n      \"a-coormu\",    -- Ada.Containers.Ordered_Multisets\n+     \"a-crdlli\",    -- Ada.Containers.Restricted_Doubly_Linked_Lists\n+     \"a-secain\",    -- Ada.Strings.Equal_Case_Insensitive\n+     \"a-shcain\",    -- Ada.Strings.Hash_Case_Insensitive\n+     \"a-slcain\",    -- Ada.Strings.Less_Case_Insensitive\n      \"a-szuzti\",    -- Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO\n      \"a-zchuni\",    -- Ada.Wide_Wide_Characters.Unicode\n "}, {"sha": "0562766a9e5becefd26acb12706e97fa2d55d46a", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 69, "deletions": 14, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e451134f0ac90864186b1a1595a86ee393cf41a/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=6e451134f0ac90864186b1a1595a86ee393cf41a", "patch": "@@ -44,7 +44,6 @@\n #include \"tsystem.h\"\n #include <fcntl.h>\n #include <sys/stat.h>\n-#include <time.h>\n #ifdef VMS\n #include <unixio.h>\n #endif\n@@ -53,6 +52,14 @@\n #include \"system.h\"\n #endif\n \n+#include <time.h>\n+\n+#if defined (sun) && defined (__SVR4) && !defined (__vxworks)\n+/* The declaration is present in <time.h> but conditionalized\n+   on a couple of macros we don't define.  */\n+extern struct tm *localtime_r(const time_t *, struct tm *);\n+#endif\n+\n #include \"adaint.h\"\n \n /*\n@@ -664,8 +671,6 @@ rts_get_nShowCmd (void)\n \n /* This gets around a problem with using the old threads library on VMS 7.0. */\n \n-#include <time.h>\n-\n extern long get_gmtoff (void);\n \n long\n@@ -680,27 +685,57 @@ get_gmtoff (void)\n }\n #endif\n \n+/* This value is returned as the time zone offset when a valid value\n+   cannot be determined. It is simply a bizarre value that will never\n+   occur. It is 3 days plus 73 seconds (offset is in seconds. */\n+\n+long __gnat_invalid_tzoff = 259273;\n+\n /* Definition of __gnat_locatime_r used by a-calend.adb */\n \n-#if defined (__EMX__)\n+#if defined (__EMX__) || defined (__MINGW32__)\n+\n+#ifdef CERT\n+\n+/* For the Cert run times on native Windows we use dummy functions\n+   for locking and unlocking tasks since we do not support multiple\n+   threads on this configuration (Cert run time on native Windows). */\n+\n+void dummy (void) {}\n+\n+void (*Lock_Task) ()   = &dummy;\n+void (*Unlock_Task) () = &dummy;\n+\n+#else\n+\n #define Lock_Task system__soft_links__lock_task\n extern void (*Lock_Task) (void);\n \n #define Unlock_Task system__soft_links__unlock_task\n extern void (*Unlock_Task) (void);\n \n-/* Provide reentrant version of localtime on OS/2. */\n+#endif\n+\n+/* Reentrant localtime for Windows and OS/2. */\n \n-extern struct tm *__gnat_localtime_r (const time_t *, struct tm *);\n+extern struct tm *\n+__gnat_localtime_tzoff (const time_t *, struct tm *, long *);\n \n struct tm *\n-__gnat_localtime_r (const time_t *timer, struct tm *tp)\n+__gnat_localtime_tzoff (const time_t *timer, struct tm *tp, long *off)\n {\n+  DWORD dwRet;\n   struct tm *tmp;\n+  TIME_ZONE_INFORMATION tzi;\n \n   (*Lock_Task) ();\n   tmp = localtime (timer);\n   memcpy (tp, tmp, sizeof (struct tm));\n+  dwRet = GetTimeZoneInformation (&tzi);\n+  *off = tzi.Bias;\n+  if (tp->tm_isdst > 0)\n+    *off = *off + tzi.DaylightBias;\n+  *off = *off * -60;\n   (*Unlock_Task) ();\n   return tp;\n }\n@@ -714,31 +749,51 @@ __gnat_localtime_r (const time_t *timer, struct tm *tp)\n    spec is required. Only use when ___THREADS_POSIX4ad4__ is defined,\n    the Lynx convention when building against the legacy API. */\n \n-extern struct tm *__gnat_localtime_r (const time_t *, struct tm *);\n+extern struct tm *\n+__gnat_localtime_tzoff (const time_t *, struct tm *, long *);\n \n struct tm *\n-__gnat_localtime_r (const time_t *timer, struct tm *tp)\n+__gnat_localtime_tzoff (const time_t *timer, struct tm *tp, long *off)\n {\n   localtime_r (tp, timer);\n+  *off = __gnat_invalid_tzoff;\n   return NULL;\n }\n \n #else\n-#if defined (VMS) || defined (__MINGW32__)\n+#if defined (VMS)\n \n-/* __gnat_localtime_r is not needed on NT and VMS */\n+/* __gnat_localtime_tzoff is not needed on VMS */\n \n #else\n \n /* All other targets provide a standard localtime_r */\n \n-extern struct tm *__gnat_localtime_r (const time_t *, struct tm *);\n+extern struct tm *\n+__gnat_localtime_tzoff (const time_t *, struct tm *, long *);\n \n struct tm *\n-__gnat_localtime_r (const time_t *timer, struct tm *tp)\n+__gnat_localtime_tzoff (const time_t *timer, struct tm *tp, long *off)\n {\n-  return (struct tm *) localtime_r (timer, tp);\n+   localtime_r (timer, tp);\n+\n+/* AIX, HPUX, SGI Irix, Sun Solaris */\n+#if defined (_AIX) || defined (__hpux__) || defined (sgi) || defined (sun)\n+  *off = (long) -timezone;\n+  if (tp->tm_isdst > 0)\n+    *off = *off + 3600;\n+\n+/* Lynx, VXWorks */\n+#elif defined (__Lynx__) || defined (__vxworks)\n+  *off = __gnat_invalid_tzoff;\n+\n+/* Darwin, Free BSD, Linux, Tru64 */\n+#else\n+  *off = tp->tm_gmtoff;\n+#endif\n+   return NULL;\n }\n+\n #endif\n #endif\n #endif"}]}