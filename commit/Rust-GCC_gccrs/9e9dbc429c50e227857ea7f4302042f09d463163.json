{"sha": "9e9dbc429c50e227857ea7f4302042f09d463163", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5ZGJjNDI5YzUwZTIyNzg1N2VhN2Y0MzAyMDQyZjA5ZDQ2MzE2Mw==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2014-07-04T07:35:43Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2014-07-04T07:35:43Z"}, "message": "Move some external functions used by machine description patterns to nds32-md-auxiliary.c module.\n\ngcc/\n\t* config/nds32/nds32.c (nds32_byte_to_size): Move to ...\n\t(nds32_output_casesi_pc_relative): Move to ...\n\t(nds32_output_casesi): Move to ...\n\t(nds32_mem_format): Move to ...\n\t(nds32_output_16bit_store): Move to ...\n\t(nds32_output_16bit_load): Move to ...\n\t(nds32_output_32bit_store): Move to ...\n\t(nds32_output_32bit_load): Move to ...\n\t(nds32_output_32bit_load_s): Move to ...\n\t(nds32_output_stack_push): Move to ...\n\t(nds32_output_stack_pop): Move to ...\n\t* config/nds32/nds32-md-auxiliary.c: ... here.\n\nCo-Authored-By: Kito Cheng <kito@0xlab.org>\nCo-Authored-By: Monk Chiang <sh.chiang04@gmail.com>\n\nFrom-SVN: r212286", "tree": {"sha": "956f77fb3a49b0ef3317f6dbb6bfcac744ea03a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/956f77fb3a49b0ef3317f6dbb6bfcac744ea03a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e9dbc429c50e227857ea7f4302042f09d463163", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9dbc429c50e227857ea7f4302042f09d463163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9dbc429c50e227857ea7f4302042f09d463163", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9dbc429c50e227857ea7f4302042f09d463163/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c65cef105141aa9264c59b2a82b1232ce7f9a1cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65cef105141aa9264c59b2a82b1232ce7f9a1cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c65cef105141aa9264c59b2a82b1232ce7f9a1cc"}], "stats": {"total": 1611, "additions": 832, "deletions": 779}, "files": [{"sha": "cc364eb8b0249576ce345bc58aeae4d457bcdc24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9dbc429c50e227857ea7f4302042f09d463163/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9dbc429c50e227857ea7f4302042f09d463163/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e9dbc429c50e227857ea7f4302042f09d463163", "patch": "@@ -1,3 +1,20 @@\n+2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\t    Kito Cheng  <kito@0xlab.org>\n+\t    Monk Chiang  <sh.chiang04@gmail.com>\n+\n+\t* config/nds32/nds32.c (nds32_byte_to_size): Move to ...\n+\t(nds32_output_casesi_pc_relative): Move to ...\n+\t(nds32_output_casesi): Move to ...\n+\t(nds32_mem_format): Move to ...\n+\t(nds32_output_16bit_store): Move to ...\n+\t(nds32_output_16bit_load): Move to ...\n+\t(nds32_output_32bit_store): Move to ...\n+\t(nds32_output_32bit_load): Move to ...\n+\t(nds32_output_32bit_load_s): Move to ...\n+\t(nds32_output_stack_push): Move to ...\n+\t(nds32_output_stack_pop): Move to ...\n+\t* config/nds32/nds32-md-auxiliary.c: ... here.\n+\n 2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n \t    Ling-Hua Tseng  <uranus@tinlans.org>\n "}, {"sha": "419f4effa9741f3d01715cea361936311cd4d8e3", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 815, "deletions": 0, "changes": 815, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9dbc429c50e227857ea7f4302042f09d463163/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9dbc429c50e227857ea7f4302042f09d463163/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=9e9dbc429c50e227857ea7f4302042f09d463163", "patch": "@@ -18,3 +18,818 @@\n    You should have received a copy of the GNU General Public License\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n+\n+/* ------------------------------------------------------------------------ */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stor-layout.h\"\n+#include \"varasm.h\"\n+#include \"calls.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\t/* Required by recog.h.  */\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\t\t/* For DFA state_t.  */\n+#include \"insn-codes.h\"\t\t/* For CODE_FOR_xxx.  */\n+#include \"reload.h\"\t\t/* For push_reload().  */\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"recog.h\"\n+#include \"diagnostic-core.h\"\n+#include \"df.h\"\n+#include \"tm_p.h\"\n+#include \"tm-constrs.h\"\n+#include \"optabs.h\"\t\t/* For GEN_FCN.  */\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"langhooks.h\"\t\t/* For add_builtin_function().  */\n+#include \"ggc.h\"\n+#include \"builtins.h\"\n+\n+/* ------------------------------------------------------------------------ */\n+\n+/* A helper function to return character based on byte size.  */\n+static char\n+nds32_byte_to_size (int byte)\n+{\n+  switch (byte)\n+    {\n+    case 4:\n+      return 'w';\n+    case 2:\n+      return 'h';\n+    case 1:\n+      return 'b';\n+    default:\n+      /* Normally it should not be here.  */\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* A helper function to return memory format.  */\n+enum nds32_16bit_address_type\n+nds32_mem_format (rtx op)\n+{\n+  enum machine_mode mode_test;\n+  int val;\n+  int regno;\n+\n+  if (!TARGET_16_BIT)\n+    return ADDRESS_NOT_16BIT_FORMAT;\n+\n+  mode_test = GET_MODE (op);\n+\n+  op = XEXP (op, 0);\n+\n+  /* 45 format.  */\n+  if (GET_CODE (op) == REG && (mode_test == SImode))\n+    return ADDRESS_REG;\n+\n+  /* 333 format for QI/HImode.  */\n+  if (GET_CODE (op) == REG && (REGNO (op) < R8_REGNUM))\n+    return ADDRESS_LO_REG_IMM3U;\n+\n+  /* post_inc 333 format.  */\n+  if ((GET_CODE (op) == POST_INC) && (mode_test == SImode))\n+    {\n+      regno = REGNO(XEXP (op, 0));\n+\n+      if (regno < 8)\n+\treturn ADDRESS_POST_INC_LO_REG_IMM3U;\n+    }\n+\n+  /* post_inc 333 format.  */\n+  if ((GET_CODE (op) == POST_MODIFY)\n+      && (mode_test == SImode)\n+      && (REG_P (XEXP (XEXP (op, 1), 0)))\n+      && (CONST_INT_P (XEXP (XEXP (op, 1), 1))))\n+    {\n+      regno = REGNO (XEXP (XEXP (op, 1), 0));\n+      val = INTVAL (XEXP (XEXP (op, 1), 1));\n+      if (regno < 8 && val < 32)\n+\treturn ADDRESS_POST_INC_LO_REG_IMM3U;\n+    }\n+\n+  if ((GET_CODE (op) == PLUS)\n+      && (GET_CODE (XEXP (op, 0)) == REG)\n+      && (GET_CODE (XEXP (op, 1)) == CONST_INT))\n+    {\n+      val = INTVAL (XEXP (op, 1));\n+\n+      regno = REGNO(XEXP (op, 0));\n+\n+      if (regno > 7\n+\t  && regno != SP_REGNUM\n+\t  && regno != FP_REGNUM)\n+\treturn ADDRESS_NOT_16BIT_FORMAT;\n+\n+      switch (mode_test)\n+\t{\n+\tcase QImode:\n+\t  /* 333 format.  */\n+\t  if (val >= 0 && val < 8 && regno < 8)\n+\t    return ADDRESS_LO_REG_IMM3U;\n+\t  break;\n+\n+\tcase HImode:\n+\t  /* 333 format.  */\n+\t  if (val >= 0 && val < 16 && (val % 2 == 0) && regno < 8)\n+\t    return ADDRESS_LO_REG_IMM3U;\n+\t  break;\n+\n+\tcase SImode:\n+\tcase SFmode:\n+\tcase DFmode:\n+\t  /* fp imply 37 format.  */\n+\t  if ((regno == FP_REGNUM) &&\n+\t      (val >= 0 && val < 512 && (val % 4 == 0)))\n+\t    return ADDRESS_FP_IMM7U;\n+\t  /* sp imply 37 format.  */\n+\t  else if ((regno == SP_REGNUM) &&\n+\t\t   (val >= 0 && val < 512 && (val % 4 == 0)))\n+\t    return ADDRESS_SP_IMM7U;\n+\t  /* 333 format.  */\n+\t  else if (val >= 0 && val < 32 && (val % 4 == 0) && regno < 8)\n+\t    return ADDRESS_LO_REG_IMM3U;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  return ADDRESS_NOT_16BIT_FORMAT;\n+}\n+\n+/* Output 16-bit store.  */\n+const char *\n+nds32_output_16bit_store (rtx *operands, int byte)\n+{\n+  char pattern[100];\n+  char size;\n+  rtx code = XEXP (operands[0], 0);\n+\n+  size = nds32_byte_to_size (byte);\n+\n+  switch (nds32_mem_format (operands[0]))\n+    {\n+    case ADDRESS_REG:\n+      operands[0] = code;\n+      output_asm_insn (\"swi450\\t%1, [%0]\", operands);\n+      break;\n+    case ADDRESS_LO_REG_IMM3U:\n+      snprintf (pattern, sizeof (pattern), \"s%ci333\\t%%1, %%0\", size);\n+      output_asm_insn (pattern, operands);\n+      break;\n+    case ADDRESS_POST_INC_LO_REG_IMM3U:\n+      snprintf (pattern, sizeof (pattern), \"s%ci333.bi\\t%%1, %%0\", size);\n+      output_asm_insn (pattern, operands);\n+      break;\n+    case ADDRESS_FP_IMM7U:\n+      output_asm_insn (\"swi37\\t%1, %0\", operands);\n+      break;\n+    case ADDRESS_SP_IMM7U:\n+      /* Get immediate value and set back to operands[1].  */\n+      operands[0] = XEXP (code, 1);\n+      output_asm_insn (\"swi37.sp\\t%1, [ + (%0)]\", operands);\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  return \"\";\n+}\n+\n+/* Output 16-bit load.  */\n+const char *\n+nds32_output_16bit_load (rtx *operands, int byte)\n+{\n+  char pattern[100];\n+  unsigned char size;\n+  rtx code = XEXP (operands[1], 0);\n+\n+  size = nds32_byte_to_size (byte);\n+\n+  switch (nds32_mem_format (operands[1]))\n+    {\n+    case ADDRESS_REG:\n+      operands[1] = code;\n+      output_asm_insn (\"lwi450\\t%0, [%1]\", operands);\n+      break;\n+    case ADDRESS_LO_REG_IMM3U:\n+      snprintf (pattern, sizeof (pattern), \"l%ci333\\t%%0, %%1\", size);\n+      output_asm_insn (pattern, operands);\n+      break;\n+    case ADDRESS_POST_INC_LO_REG_IMM3U:\n+      snprintf (pattern, sizeof (pattern), \"l%ci333.bi\\t%%0, %%1\", size);\n+      output_asm_insn (pattern, operands);\n+      break;\n+    case ADDRESS_FP_IMM7U:\n+      output_asm_insn (\"lwi37\\t%0, %1\", operands);\n+      break;\n+    case ADDRESS_SP_IMM7U:\n+      /* Get immediate value and set back to operands[0].  */\n+      operands[1] = XEXP (code, 1);\n+      output_asm_insn (\"lwi37.sp\\t%0, [ + (%1)]\", operands);\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  return \"\";\n+}\n+\n+/* Output 32-bit store.  */\n+const char *\n+nds32_output_32bit_store (rtx *operands, int byte)\n+{\n+  char pattern[100];\n+  unsigned char size;\n+  rtx code = XEXP (operands[0], 0);\n+\n+  size = nds32_byte_to_size (byte);\n+\n+  switch (GET_CODE (code))\n+    {\n+    case REG:\n+      /* (mem (reg X))\n+\t => access location by using register,\n+\t use \"sbi / shi / swi\" */\n+      snprintf (pattern, sizeof (pattern), \"s%ci\\t%%1, %%0\", size);\n+      break;\n+\n+    case SYMBOL_REF:\n+    case CONST:\n+      /* (mem (symbol_ref X))\n+\t (mem (const (...)))\n+\t => access global variables,\n+\t use \"sbi.gp / shi.gp / swi.gp\" */\n+      operands[0] = XEXP (operands[0], 0);\n+      snprintf (pattern, sizeof (pattern), \"s%ci.gp\\t%%1, [ + %%0]\", size);\n+      break;\n+\n+    case POST_INC:\n+      /* (mem (post_inc reg))\n+\t => access location by using register which will be post increment,\n+\t use \"sbi.bi / shi.bi / swi.bi\" */\n+      snprintf (pattern, sizeof (pattern),\n+\t\t\"s%ci.bi\\t%%1, %%0, %d\", size, byte);\n+      break;\n+\n+    case POST_DEC:\n+      /* (mem (post_dec reg))\n+\t => access location by using register which will be post decrement,\n+\t use \"sbi.bi / shi.bi / swi.bi\" */\n+      snprintf (pattern, sizeof (pattern),\n+\t\t\"s%ci.bi\\t%%1, %%0, -%d\", size, byte);\n+      break;\n+\n+    case POST_MODIFY:\n+      switch (GET_CODE (XEXP (XEXP (code, 1), 1)))\n+\t{\n+\tcase REG:\n+\tcase SUBREG:\n+\t  /* (mem (post_modify (reg) (plus (reg) (reg))))\n+\t     => access location by using register which will be\n+\t     post modified with reg,\n+\t     use \"sb.bi/ sh.bi / sw.bi\" */\n+\t  snprintf (pattern, sizeof (pattern), \"s%c.bi\\t%%1, %%0\", size);\n+\t  break;\n+\tcase CONST_INT:\n+\t  /* (mem (post_modify (reg) (plus (reg) (const_int))))\n+\t     => access location by using register which will be\n+\t     post modified with const_int,\n+\t     use \"sbi.bi/ shi.bi / swi.bi\" */\n+\t  snprintf (pattern, sizeof (pattern), \"s%ci.bi\\t%%1, %%0\", size);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case PLUS:\n+      switch (GET_CODE (XEXP (code, 1)))\n+\t{\n+\tcase REG:\n+\tcase SUBREG:\n+\t  /* (mem (plus reg reg)) or (mem (plus (mult reg const_int) reg))\n+\t     => access location by adding two registers,\n+\t     use \"sb / sh / sw\" */\n+\t  snprintf (pattern, sizeof (pattern), \"s%c\\t%%1, %%0\", size);\n+\t  break;\n+\tcase CONST_INT:\n+\t  /* (mem (plus reg const_int))\n+\t     => access location by adding one register with const_int,\n+\t     use \"sbi / shi / swi\" */\n+\t  snprintf (pattern, sizeof (pattern), \"s%ci\\t%%1, %%0\", size);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case LO_SUM:\n+      operands[2] = XEXP (code, 1);\n+      operands[0] = XEXP (code, 0);\n+      snprintf (pattern, sizeof (pattern),\n+\t\t\"s%ci\\t%%1, [%%0 + lo12(%%2)]\", size);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  output_asm_insn (pattern, operands);\n+  return \"\";\n+}\n+\n+/* Output 32-bit load.  */\n+const char *\n+nds32_output_32bit_load (rtx *operands, int byte)\n+{\n+  char pattern[100];\n+  unsigned char size;\n+  rtx code;\n+\n+  code = XEXP (operands[1], 0);\n+\n+  size = nds32_byte_to_size (byte);\n+\n+  switch (GET_CODE (code))\n+    {\n+    case REG:\n+      /* (mem (reg X))\n+\t => access location by using register,\n+\t use \"lbi / lhi / lwi\" */\n+      snprintf (pattern, sizeof (pattern), \"l%ci\\t%%0, %%1\", size);\n+      break;\n+\n+    case SYMBOL_REF:\n+    case CONST:\n+      /* (mem (symbol_ref X))\n+\t (mem (const (...)))\n+\t => access global variables,\n+\t use \"lbi.gp / lhi.gp / lwi.gp\" */\n+      operands[1] = XEXP (operands[1], 0);\n+      snprintf (pattern, sizeof (pattern), \"l%ci.gp\\t%%0, [ + %%1]\", size);\n+      break;\n+\n+    case POST_INC:\n+      /* (mem (post_inc reg))\n+\t => access location by using register which will be post increment,\n+\t use \"lbi.bi / lhi.bi / lwi.bi\" */\n+      snprintf (pattern, sizeof (pattern),\n+\t\t\"l%ci.bi\\t%%0, %%1, %d\", size, byte);\n+      break;\n+\n+    case POST_DEC:\n+      /* (mem (post_dec reg))\n+\t => access location by using register which will be post decrement,\n+\t use \"lbi.bi / lhi.bi / lwi.bi\" */\n+      snprintf (pattern, sizeof (pattern),\n+\t\t\"l%ci.bi\\t%%0, %%1, -%d\", size, byte);\n+      break;\n+\n+    case POST_MODIFY:\n+      switch (GET_CODE (XEXP (XEXP (code, 1), 1)))\n+\t{\n+\tcase REG:\n+\tcase SUBREG:\n+\t  /* (mem (post_modify (reg) (plus (reg) (reg))))\n+\t     => access location by using register which will be\n+\t     post modified with reg,\n+\t     use \"lb.bi/ lh.bi / lw.bi\" */\n+\t  snprintf (pattern, sizeof (pattern), \"l%c.bi\\t%%0, %%1\", size);\n+\t  break;\n+\tcase CONST_INT:\n+\t  /* (mem (post_modify (reg) (plus (reg) (const_int))))\n+\t     => access location by using register which will be\n+\t     post modified with const_int,\n+\t     use \"lbi.bi/ lhi.bi / lwi.bi\" */\n+\t  snprintf (pattern, sizeof (pattern), \"l%ci.bi\\t%%0, %%1\", size);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case PLUS:\n+      switch (GET_CODE (XEXP (code, 1)))\n+\t{\n+\tcase REG:\n+\tcase SUBREG:\n+\t  /* (mem (plus reg reg)) or (mem (plus (mult reg const_int) reg))\n+\t     use \"lb / lh / lw\" */\n+\t  snprintf (pattern, sizeof (pattern), \"l%c\\t%%0, %%1\", size);\n+\t  break;\n+\tcase CONST_INT:\n+\t  /* (mem (plus reg const_int))\n+\t     => access location by adding one register with const_int,\n+\t     use \"lbi / lhi / lwi\" */\n+\t  snprintf (pattern, sizeof (pattern), \"l%ci\\t%%0, %%1\", size);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case LO_SUM:\n+      operands[2] = XEXP (code, 1);\n+      operands[1] = XEXP (code, 0);\n+      snprintf (pattern, sizeof (pattern),\n+\t\t\"l%ci\\t%%0, [%%1 + lo12(%%2)]\", size);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  output_asm_insn (pattern, operands);\n+  return \"\";\n+}\n+\n+/* Output 32-bit load with signed extension.  */\n+const char *\n+nds32_output_32bit_load_s (rtx *operands, int byte)\n+{\n+  char pattern[100];\n+  unsigned char size;\n+  rtx code;\n+\n+  code = XEXP (operands[1], 0);\n+\n+  size = nds32_byte_to_size (byte);\n+\n+  switch (GET_CODE (code))\n+    {\n+    case REG:\n+      /* (mem (reg X))\n+         => access location by using register,\n+         use \"lbsi / lhsi\" */\n+      snprintf (pattern, sizeof (pattern), \"l%csi\\t%%0, %%1\", size);\n+      break;\n+\n+    case SYMBOL_REF:\n+    case CONST:\n+      /* (mem (symbol_ref X))\n+         (mem (const (...)))\n+         => access global variables,\n+         use \"lbsi.gp / lhsi.gp\" */\n+      operands[1] = XEXP (operands[1], 0);\n+      snprintf (pattern, sizeof (pattern), \"l%csi.gp\\t%%0, [ + %%1]\", size);\n+      break;\n+\n+    case POST_INC:\n+      /* (mem (post_inc reg))\n+         => access location by using register which will be post increment,\n+         use \"lbsi.bi / lhsi.bi\" */\n+      snprintf (pattern, sizeof (pattern),\n+\t\t\"l%csi.bi\\t%%0, %%1, %d\", size, byte);\n+      break;\n+\n+    case POST_DEC:\n+      /* (mem (post_dec reg))\n+         => access location by using register which will be post decrement,\n+         use \"lbsi.bi / lhsi.bi\" */\n+      snprintf (pattern, sizeof (pattern),\n+\t\t\"l%csi.bi\\t%%0, %%1, -%d\", size, byte);\n+      break;\n+\n+    case POST_MODIFY:\n+      switch (GET_CODE (XEXP (XEXP (code, 1), 1)))\n+\t{\n+\tcase REG:\n+\tcase SUBREG:\n+\t  /* (mem (post_modify (reg) (plus (reg) (reg))))\n+\t     => access location by using register which will be\n+\t     post modified with reg,\n+\t     use \"lbs.bi/ lhs.bi\" */\n+\t  snprintf (pattern, sizeof (pattern), \"l%cs.bi\\t%%0, %%1\", size);\n+\t  break;\n+\tcase CONST_INT:\n+\t  /* (mem (post_modify (reg) (plus (reg) (const_int))))\n+\t     => access location by using register which will be\n+\t     post modified with const_int,\n+\t     use \"lbsi.bi/ lhsi.bi\" */\n+\t  snprintf (pattern, sizeof (pattern), \"l%csi.bi\\t%%0, %%1\", size);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case PLUS:\n+      switch (GET_CODE (XEXP (code, 1)))\n+\t{\n+\tcase REG:\n+\tcase SUBREG:\n+\t  /* (mem (plus reg reg)) or (mem (plus (mult reg const_int) reg))\n+\t     use \"lbs / lhs\" */\n+\t  snprintf (pattern, sizeof (pattern), \"l%cs\\t%%0, %%1\", size);\n+\t  break;\n+\tcase CONST_INT:\n+\t  /* (mem (plus reg const_int))\n+\t     => access location by adding one register with const_int,\n+\t     use \"lbsi / lhsi\" */\n+\t  snprintf (pattern, sizeof (pattern), \"l%csi\\t%%0, %%1\", size);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n+    case LO_SUM:\n+      operands[2] = XEXP (code, 1);\n+      operands[1] = XEXP (code, 0);\n+      snprintf (pattern, sizeof (pattern),\n+\t\t\"l%csi\\t%%0, [%%1 + lo12(%%2)]\", size);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  output_asm_insn (pattern, operands);\n+  return \"\";\n+}\n+\n+/* Function to output stack push operation.\n+   We need to deal with normal stack push multiple or stack v3push.  */\n+const char *\n+nds32_output_stack_push (void)\n+{\n+  /* A string pattern for output_asm_insn().  */\n+  char pattern[100];\n+  /* The operands array which will be used in output_asm_insn().  */\n+  rtx operands[3];\n+  /* Pick up callee-saved first regno and last regno for further use.  */\n+  int rb_regno = cfun->machine->callee_saved_regs_first_regno;\n+  int re_regno = cfun->machine->callee_saved_regs_last_regno;\n+\n+  if (TARGET_V3PUSH)\n+    {\n+      /* For stack v3push:\n+           operands[0]: Re\n+           operands[1]: imm8u */\n+\n+      /* This variable is to check if 'push25 Re,imm8u' is available.  */\n+      int sp_adjust;\n+\n+      /* Set operands[0].  */\n+      operands[0] = gen_rtx_REG (SImode, re_regno);\n+\n+      /* Check if we can generate 'push25 Re,imm8u',\n+         otherwise, generate 'push25 Re,0'.  */\n+      sp_adjust = cfun->machine->local_size\n+\t\t  + cfun->machine->out_args_size\n+\t\t  + cfun->machine->callee_saved_area_padding_bytes;\n+      if (satisfies_constraint_Iu08 (GEN_INT (sp_adjust))\n+\t  && NDS32_DOUBLE_WORD_ALIGN_P (sp_adjust))\n+\toperands[1] = GEN_INT (sp_adjust);\n+      else\n+\toperands[1] = GEN_INT (0);\n+\n+      /* Create assembly code pattern.  */\n+      snprintf (pattern, sizeof (pattern), \"push25\\t%%0, %%1\");\n+    }\n+  else\n+    {\n+      /* For normal stack push multiple:\n+         operands[0]: Rb\n+         operands[1]: Re\n+         operands[2]: En4 */\n+\n+      /* This variable is used to check if we only need to generate En4 field.\n+         As long as Rb==Re=SP_REGNUM, we set this variable to 1.  */\n+      int push_en4_only_p = 0;\n+\n+      /* Set operands[0] and operands[1].  */\n+      operands[0] = gen_rtx_REG (SImode, rb_regno);\n+      operands[1] = gen_rtx_REG (SImode, re_regno);\n+\n+      /* 'smw.adm $sp,[$sp],$sp,0' means push nothing.  */\n+      if (!cfun->machine->fp_size\n+\t  && !cfun->machine->gp_size\n+\t  && !cfun->machine->lp_size\n+\t  && REGNO (operands[0]) == SP_REGNUM\n+\t  && REGNO (operands[1]) == SP_REGNUM)\n+\t{\n+\t  /* No need to generate instruction.  */\n+\t  return \"\";\n+\t}\n+      else\n+\t{\n+\t  /* If Rb==Re=SP_REGNUM, we only need to generate En4 field.  */\n+\t  if (REGNO (operands[0]) == SP_REGNUM\n+\t      && REGNO (operands[1]) == SP_REGNUM)\n+\t    push_en4_only_p = 1;\n+\n+\t  /* Create assembly code pattern.\n+\t     We need to handle the form: \"Rb, Re, { $fp $gp $lp }\".  */\n+\t  snprintf (pattern, sizeof (pattern),\n+\t\t    \"push.s\\t%s{%s%s%s }\",\n+\t\t    push_en4_only_p ? \"\" : \"%0, %1, \",\n+\t\t    cfun->machine->fp_size ? \" $fp\" : \"\",\n+\t\t    cfun->machine->gp_size ? \" $gp\" : \"\",\n+\t\t    cfun->machine->lp_size ? \" $lp\" : \"\");\n+\t}\n+    }\n+\n+  /* We use output_asm_insn() to output assembly code by ourself.  */\n+  output_asm_insn (pattern, operands);\n+  return \"\";\n+}\n+\n+/* Function to output stack pop operation.\n+   We need to deal with normal stack pop multiple or stack v3pop.  */\n+const char *\n+nds32_output_stack_pop (void)\n+{\n+  /* A string pattern for output_asm_insn().  */\n+  char pattern[100];\n+  /* The operands array which will be used in output_asm_insn().  */\n+  rtx operands[3];\n+  /* Pick up callee-saved first regno and last regno for further use.  */\n+  int rb_regno = cfun->machine->callee_saved_regs_first_regno;\n+  int re_regno = cfun->machine->callee_saved_regs_last_regno;\n+\n+  if (TARGET_V3PUSH)\n+    {\n+      /* For stack v3pop:\n+           operands[0]: Re\n+           operands[1]: imm8u */\n+\n+      /* This variable is to check if 'pop25 Re,imm8u' is available.  */\n+      int sp_adjust;\n+\n+      /* Set operands[0].  */\n+      operands[0] = gen_rtx_REG (SImode, re_regno);\n+\n+      /* Check if we can generate 'pop25 Re,imm8u',\n+         otherwise, generate 'pop25 Re,0'.\n+         We have to consider alloca issue as well.\n+         If the function does call alloca(), the stack pointer is not fixed.\n+         In that case, we cannot use 'pop25 Re,imm8u' directly.\n+         We have to caculate stack pointer from frame pointer\n+         and then use 'pop25 Re,0'.  */\n+      sp_adjust = cfun->machine->local_size\n+\t\t  + cfun->machine->out_args_size\n+\t\t  + cfun->machine->callee_saved_area_padding_bytes;\n+      if (satisfies_constraint_Iu08 (GEN_INT (sp_adjust))\n+\t  && NDS32_DOUBLE_WORD_ALIGN_P (sp_adjust)\n+\t  && !cfun->calls_alloca)\n+\toperands[1] = GEN_INT (sp_adjust);\n+      else\n+\toperands[1] = GEN_INT (0);\n+\n+      /* Create assembly code pattern.  */\n+      snprintf (pattern, sizeof (pattern), \"pop25\\t%%0, %%1\");\n+    }\n+  else\n+    {\n+      /* For normal stack pop multiple:\n+         operands[0]: Rb\n+         operands[1]: Re\n+         operands[2]: En4 */\n+\n+      /* This variable is used to check if we only need to generate En4 field.\n+         As long as Rb==Re=SP_REGNUM, we set this variable to 1.  */\n+      int pop_en4_only_p = 0;\n+\n+      /* Set operands[0] and operands[1].  */\n+      operands[0] = gen_rtx_REG (SImode, rb_regno);\n+      operands[1] = gen_rtx_REG (SImode, re_regno);\n+\n+      /* 'lmw.bim $sp,[$sp],$sp,0' means pop nothing.  */\n+      if (!cfun->machine->fp_size\n+\t  && !cfun->machine->gp_size\n+\t  && !cfun->machine->lp_size\n+\t  && REGNO (operands[0]) == SP_REGNUM\n+\t  && REGNO (operands[1]) == SP_REGNUM)\n+\t{\n+\t  /* No need to generate instruction.  */\n+\t  return \"\";\n+\t}\n+      else\n+\t{\n+\t  /* If Rb==Re=SP_REGNUM, we only need to generate En4 field.  */\n+\t  if (REGNO (operands[0]) == SP_REGNUM\n+\t      && REGNO (operands[1]) == SP_REGNUM)\n+\t    pop_en4_only_p = 1;\n+\n+\t  /* Create assembly code pattern.\n+\t     We need to handle the form: \"Rb, Re, { $fp $gp $lp }\".  */\n+\t  snprintf (pattern, sizeof (pattern),\n+\t\t    \"pop.s\\t%s{%s%s%s }\",\n+\t\t    pop_en4_only_p ? \"\" : \"%0, %1, \",\n+\t\t    cfun->machine->fp_size ? \" $fp\" : \"\",\n+\t\t    cfun->machine->gp_size ? \" $gp\" : \"\",\n+\t\t    cfun->machine->lp_size ? \" $lp\" : \"\");\n+\t}\n+    }\n+\n+  /* We use output_asm_insn() to output assembly code by ourself.  */\n+  output_asm_insn (pattern, operands);\n+  return \"\";\n+}\n+\n+/* Function to generate PC relative jump table.\n+   Refer to nds32.md for more details.\n+\n+   The following is the sample for the case that diff value\n+   can be presented in '.short' size.\n+\n+     addi    $r1, $r1, -(case_lower_bound)\n+     slti    $ta, $r1, (case_number)\n+     beqz    $ta, .L_skip_label\n+\n+     la      $ta, .L35             ! get jump table address\n+     lh      $r1, [$ta + $r1 << 1] ! load symbol diff from jump table entry\n+     addi    $ta, $r1, $ta\n+     jr5     $ta\n+\n+     ! jump table entry\n+   L35:\n+     .short  .L25-.L35\n+     .short  .L26-.L35\n+     .short  .L27-.L35\n+     .short  .L28-.L35\n+     .short  .L29-.L35\n+     .short  .L30-.L35\n+     .short  .L31-.L35\n+     .short  .L32-.L35\n+     .short  .L33-.L35\n+     .short  .L34-.L35 */\n+const char *\n+nds32_output_casesi_pc_relative (rtx *operands)\n+{\n+  enum machine_mode mode;\n+  rtx diff_vec;\n+\n+  diff_vec = PATTERN (NEXT_INSN (operands[1]));\n+\n+  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n+\n+  /* Step C: \"t <-- operands[1]\".  */\n+  output_asm_insn (\"la\\t$ta, %l1\", operands);\n+\n+  /* Get the mode of each element in the difference vector.  */\n+  mode = GET_MODE (diff_vec);\n+\n+  /* Step D: \"z <-- (mem (plus (operands[0] << m) t))\",\n+     where m is 0, 1, or 2 to load address-diff value from table.  */\n+  switch (mode)\n+    {\n+    case QImode:\n+      output_asm_insn (\"lb\\t%2, [$ta + %0 << 0]\", operands);\n+      break;\n+    case HImode:\n+      output_asm_insn (\"lh\\t%2, [$ta + %0 << 1]\", operands);\n+      break;\n+    case SImode:\n+      output_asm_insn (\"lw\\t%2, [$ta + %0 << 2]\", operands);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Step E: \"t <-- z + t\".\n+     Add table label_ref with address-diff value to\n+     obtain target case address.  */\n+  output_asm_insn (\"add\\t$ta, %2, $ta\", operands);\n+\n+  /* Step F: jump to target with register t.  */\n+  if (TARGET_16_BIT)\n+    return \"jr5\\t$ta\";\n+  else\n+    return \"jr\\t$ta\";\n+}\n+\n+/* Function to generate normal jump table.  */\n+const char *\n+nds32_output_casesi (rtx *operands)\n+{\n+  /* Step C: \"t <-- operands[1]\".  */\n+  output_asm_insn (\"la\\t$ta, %l1\", operands);\n+\n+  /* Step D: \"z <-- (mem (plus (operands[0] << 2) t))\".  */\n+  output_asm_insn (\"lw\\t%2, [$ta + %0 << 2]\", operands);\n+\n+  /* No need to perform Step E, which is only used for\n+     pc relative jump table.  */\n+\n+  /* Step F: jump to target with register z.  */\n+  if (TARGET_16_BIT)\n+    return \"jr5\\t%2\";\n+  else\n+    return \"jr\\t%2\";\n+}\n+\n+/* ------------------------------------------------------------------------ */"}, {"sha": "eb3fbefbc5ca4b09c1bf6892d47bfb990f3eac69", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 0, "deletions": 779, "changes": 779, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9dbc429c50e227857ea7f4302042f09d463163/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9dbc429c50e227857ea7f4302042f09d463163/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=9e9dbc429c50e227857ea7f4302042f09d463163", "patch": "@@ -1106,24 +1106,6 @@ nds32_legitimate_index_p (enum machine_mode outer_mode,\n     }\n }\n \n-/* A helper function to return character based on byte size.  */\n-static char\n-nds32_byte_to_size (int byte)\n-{\n-  switch (byte)\n-    {\n-    case 4:\n-      return 'w';\n-    case 2:\n-      return 'h';\n-    case 1:\n-      return 'b';\n-    default:\n-      /* Normally it should not be here.  */\n-      gcc_unreachable ();\n-    }\n-}\n-\n /* A helper function to check if this function should contain prologue.  */\n static int\n nds32_have_prologue_p (void)\n@@ -3436,767 +3418,6 @@ nds32_fp_as_gp_check_available (void)\n   return 0;\n }\n \n-\n-/* Function to generate PC relative jump table.\n-   Refer to nds32.md for more details.\n-\n-   The following is the sample for the case that diff value\n-   can be presented in '.short' size.\n-\n-     addi    $r1, $r1, -(case_lower_bound)\n-     slti    $ta, $r1, (case_number)\n-     beqz    $ta, .L_skip_label\n-\n-     la      $ta, .L35             ! get jump table address\n-     lh      $r1, [$ta + $r1 << 1] ! load symbol diff from jump table entry\n-     addi    $ta, $r1, $ta\n-     jr5     $ta\n-\n-     ! jump table entry\n-   L35:\n-     .short  .L25-.L35\n-     .short  .L26-.L35\n-     .short  .L27-.L35\n-     .short  .L28-.L35\n-     .short  .L29-.L35\n-     .short  .L30-.L35\n-     .short  .L31-.L35\n-     .short  .L32-.L35\n-     .short  .L33-.L35\n-     .short  .L34-.L35 */\n-const char *\n-nds32_output_casesi_pc_relative (rtx *operands)\n-{\n-  enum machine_mode mode;\n-  rtx diff_vec;\n-\n-  diff_vec = PATTERN (NEXT_INSN (operands[1]));\n-\n-  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n-\n-  /* Step C: \"t <-- operands[1]\".  */\n-  output_asm_insn (\"la\\t$ta, %l1\", operands);\n-\n-  /* Get the mode of each element in the difference vector.  */\n-  mode = GET_MODE (diff_vec);\n-\n-  /* Step D: \"z <-- (mem (plus (operands[0] << m) t))\",\n-     where m is 0, 1, or 2 to load address-diff value from table.  */\n-  switch (mode)\n-    {\n-    case QImode:\n-      output_asm_insn (\"lb\\t%2, [$ta + %0 << 0]\", operands);\n-      break;\n-    case HImode:\n-      output_asm_insn (\"lh\\t%2, [$ta + %0 << 1]\", operands);\n-      break;\n-    case SImode:\n-      output_asm_insn (\"lw\\t%2, [$ta + %0 << 2]\", operands);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Step E: \"t <-- z + t\".\n-     Add table label_ref with address-diff value to\n-     obtain target case address.  */\n-  output_asm_insn (\"add\\t$ta, %2, $ta\", operands);\n-\n-  /* Step F: jump to target with register t.  */\n-  if (TARGET_16_BIT)\n-    return \"jr5\\t$ta\";\n-  else\n-    return \"jr\\t$ta\";\n-}\n-\n-/* Function to generate normal jump table.  */\n-const char *\n-nds32_output_casesi (rtx *operands)\n-{\n-  /* Step C: \"t <-- operands[1]\".  */\n-  output_asm_insn (\"la\\t$ta, %l1\", operands);\n-\n-  /* Step D: \"z <-- (mem (plus (operands[0] << 2) t))\".  */\n-  output_asm_insn (\"lw\\t%2, [$ta + %0 << 2]\", operands);\n-\n-  /* No need to perform Step E, which is only used for\n-     pc relative jump table.  */\n-\n-  /* Step F: jump to target with register z.  */\n-  if (TARGET_16_BIT)\n-    return \"jr5\\t%2\";\n-  else\n-    return \"jr\\t%2\";\n-}\n-\n-\n-/* Function to return memory format.  */\n-enum nds32_16bit_address_type\n-nds32_mem_format (rtx op)\n-{\n-  enum machine_mode mode_test;\n-  int val;\n-  int regno;\n-\n-  if (!TARGET_16_BIT)\n-    return ADDRESS_NOT_16BIT_FORMAT;\n-\n-  mode_test = GET_MODE (op);\n-\n-  op = XEXP (op, 0);\n-\n-  /* 45 format.  */\n-  if (GET_CODE (op) == REG && (mode_test == SImode))\n-    return ADDRESS_REG;\n-\n-  /* 333 format for QI/HImode.  */\n-  if (GET_CODE (op) == REG && (REGNO (op) < R8_REGNUM))\n-    return ADDRESS_LO_REG_IMM3U;\n-\n-  /* post_inc 333 format.  */\n-  if ((GET_CODE (op) == POST_INC) && (mode_test == SImode))\n-    {\n-      regno = REGNO(XEXP (op, 0));\n-\n-      if (regno < 8)\n-\treturn ADDRESS_POST_INC_LO_REG_IMM3U;\n-    }\n-\n-  /* post_inc 333 format.  */\n-  if ((GET_CODE (op) == POST_MODIFY)\n-      && (mode_test == SImode)\n-      && (REG_P (XEXP (XEXP (op, 1), 0)))\n-      && (CONST_INT_P (XEXP (XEXP (op, 1), 1))))\n-    {\n-      regno = REGNO (XEXP (XEXP (op, 1), 0));\n-      val = INTVAL (XEXP (XEXP (op, 1), 1));\n-      if (regno < 8 && val < 32)\n-\treturn ADDRESS_POST_INC_LO_REG_IMM3U;\n-    }\n-\n-  if ((GET_CODE (op) == PLUS)\n-      && (GET_CODE (XEXP (op, 0)) == REG)\n-      && (GET_CODE (XEXP (op, 1)) == CONST_INT))\n-    {\n-      val = INTVAL (XEXP (op, 1));\n-\n-      regno = REGNO(XEXP (op, 0));\n-\n-      if (regno > 7\n-\t  && regno != SP_REGNUM\n-\t  && regno != FP_REGNUM)\n-\treturn ADDRESS_NOT_16BIT_FORMAT;\n-\n-      switch (mode_test)\n-\t{\n-\tcase QImode:\n-\t  /* 333 format.  */\n-\t  if (val >= 0 && val < 8 && regno < 8)\n-\t    return ADDRESS_LO_REG_IMM3U;\n-\t  break;\n-\n-\tcase HImode:\n-\t  /* 333 format.  */\n-\t  if (val >= 0 && val < 16 && (val % 2 == 0) && regno < 8)\n-\t    return ADDRESS_LO_REG_IMM3U;\n-\t  break;\n-\n-\tcase SImode:\n-\tcase SFmode:\n-\tcase DFmode:\n-\t  /* fp imply 37 format.  */\n-\t  if ((regno == FP_REGNUM) &&\n-\t      (val >= 0 && val < 512 && (val % 4 == 0)))\n-\t    return ADDRESS_FP_IMM7U;\n-\t  /* sp imply 37 format.  */\n-\t  else if ((regno == SP_REGNUM) &&\n-\t\t   (val >= 0 && val < 512 && (val % 4 == 0)))\n-\t    return ADDRESS_SP_IMM7U;\n-\t  /* 333 format.  */\n-\t  else if (val >= 0 && val < 32 && (val % 4 == 0) && regno < 8)\n-\t    return ADDRESS_LO_REG_IMM3U;\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-\n-  return ADDRESS_NOT_16BIT_FORMAT;\n-}\n-\n-/* Output 16-bit store.  */\n-const char *\n-nds32_output_16bit_store (rtx *operands, int byte)\n-{\n-  char pattern[100];\n-  char size;\n-  rtx code = XEXP (operands[0], 0);\n-\n-  size = nds32_byte_to_size (byte);\n-\n-  switch (nds32_mem_format (operands[0]))\n-    {\n-    case ADDRESS_REG:\n-      operands[0] = code;\n-      output_asm_insn (\"swi450\\t%1, [%0]\", operands);\n-      break;\n-    case ADDRESS_LO_REG_IMM3U:\n-      snprintf (pattern, sizeof (pattern), \"s%ci333\\t%%1, %%0\", size);\n-      output_asm_insn (pattern, operands);\n-      break;\n-    case ADDRESS_POST_INC_LO_REG_IMM3U:\n-      snprintf (pattern, sizeof (pattern), \"s%ci333.bi\\t%%1, %%0\", size);\n-      output_asm_insn (pattern, operands);\n-      break;\n-    case ADDRESS_FP_IMM7U:\n-      output_asm_insn (\"swi37\\t%1, %0\", operands);\n-      break;\n-    case ADDRESS_SP_IMM7U:\n-      /* Get immediate value and set back to operands[1].  */\n-      operands[0] = XEXP (code, 1);\n-      output_asm_insn (\"swi37.sp\\t%1, [ + (%0)]\", operands);\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  return \"\";\n-}\n-\n-/* Output 16-bit load.  */\n-const char *\n-nds32_output_16bit_load (rtx *operands, int byte)\n-{\n-  char pattern[100];\n-  unsigned char size;\n-  rtx code = XEXP (operands[1], 0);\n-\n-  size = nds32_byte_to_size (byte);\n-\n-  switch (nds32_mem_format (operands[1]))\n-    {\n-    case ADDRESS_REG:\n-      operands[1] = code;\n-      output_asm_insn (\"lwi450\\t%0, [%1]\", operands);\n-      break;\n-    case ADDRESS_LO_REG_IMM3U:\n-      snprintf (pattern, sizeof (pattern), \"l%ci333\\t%%0, %%1\", size);\n-      output_asm_insn (pattern, operands);\n-      break;\n-    case ADDRESS_POST_INC_LO_REG_IMM3U:\n-      snprintf (pattern, sizeof (pattern), \"l%ci333.bi\\t%%0, %%1\", size);\n-      output_asm_insn (pattern, operands);\n-      break;\n-    case ADDRESS_FP_IMM7U:\n-      output_asm_insn (\"lwi37\\t%0, %1\", operands);\n-      break;\n-    case ADDRESS_SP_IMM7U:\n-      /* Get immediate value and set back to operands[0].  */\n-      operands[1] = XEXP (code, 1);\n-      output_asm_insn (\"lwi37.sp\\t%0, [ + (%1)]\", operands);\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  return \"\";\n-}\n-\n-/* Output 32-bit store.  */\n-const char *\n-nds32_output_32bit_store (rtx *operands, int byte)\n-{\n-  char pattern[100];\n-  unsigned char size;\n-  rtx code = XEXP (operands[0], 0);\n-\n-  size = nds32_byte_to_size (byte);\n-\n-  switch (GET_CODE (code))\n-    {\n-    case REG:\n-      /* (mem (reg X))\n-\t => access location by using register,\n-\t use \"sbi / shi / swi\" */\n-      snprintf (pattern, sizeof (pattern), \"s%ci\\t%%1, %%0\", size);\n-      break;\n-\n-    case SYMBOL_REF:\n-    case CONST:\n-      /* (mem (symbol_ref X))\n-\t (mem (const (...)))\n-\t => access global variables,\n-\t use \"sbi.gp / shi.gp / swi.gp\" */\n-      operands[0] = XEXP (operands[0], 0);\n-      snprintf (pattern, sizeof (pattern), \"s%ci.gp\\t%%1, [ + %%0]\", size);\n-      break;\n-\n-    case POST_INC:\n-      /* (mem (post_inc reg))\n-\t => access location by using register which will be post increment,\n-\t use \"sbi.bi / shi.bi / swi.bi\" */\n-      snprintf (pattern, sizeof (pattern),\n-\t\t\"s%ci.bi\\t%%1, %%0, %d\", size, byte);\n-      break;\n-\n-    case POST_DEC:\n-      /* (mem (post_dec reg))\n-\t => access location by using register which will be post decrement,\n-\t use \"sbi.bi / shi.bi / swi.bi\" */\n-      snprintf (pattern, sizeof (pattern),\n-\t\t\"s%ci.bi\\t%%1, %%0, -%d\", size, byte);\n-      break;\n-\n-    case POST_MODIFY:\n-      switch (GET_CODE (XEXP (XEXP (code, 1), 1)))\n-\t{\n-\tcase REG:\n-\tcase SUBREG:\n-\t  /* (mem (post_modify (reg) (plus (reg) (reg))))\n-\t     => access location by using register which will be\n-\t     post modified with reg,\n-\t     use \"sb.bi/ sh.bi / sw.bi\" */\n-\t  snprintf (pattern, sizeof (pattern), \"s%c.bi\\t%%1, %%0\", size);\n-\t  break;\n-\tcase CONST_INT:\n-\t  /* (mem (post_modify (reg) (plus (reg) (const_int))))\n-\t     => access location by using register which will be\n-\t     post modified with const_int,\n-\t     use \"sbi.bi/ shi.bi / swi.bi\" */\n-\t  snprintf (pattern, sizeof (pattern), \"s%ci.bi\\t%%1, %%0\", size);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    case PLUS:\n-      switch (GET_CODE (XEXP (code, 1)))\n-\t{\n-\tcase REG:\n-\tcase SUBREG:\n-\t  /* (mem (plus reg reg)) or (mem (plus (mult reg const_int) reg))\n-\t     => access location by adding two registers,\n-\t     use \"sb / sh / sw\" */\n-\t  snprintf (pattern, sizeof (pattern), \"s%c\\t%%1, %%0\", size);\n-\t  break;\n-\tcase CONST_INT:\n-\t  /* (mem (plus reg const_int))\n-\t     => access location by adding one register with const_int,\n-\t     use \"sbi / shi / swi\" */\n-\t  snprintf (pattern, sizeof (pattern), \"s%ci\\t%%1, %%0\", size);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    case LO_SUM:\n-      operands[2] = XEXP (code, 1);\n-      operands[0] = XEXP (code, 0);\n-      snprintf (pattern, sizeof (pattern),\n-\t\t\"s%ci\\t%%1, [%%0 + lo12(%%2)]\", size);\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  output_asm_insn (pattern, operands);\n-  return \"\";\n-}\n-\n-/* Output 32-bit load.  */\n-const char *\n-nds32_output_32bit_load (rtx *operands, int byte)\n-{\n-  char pattern[100];\n-  unsigned char size;\n-  rtx code;\n-\n-  code = XEXP (operands[1], 0);\n-\n-  size = nds32_byte_to_size (byte);\n-\n-  switch (GET_CODE (code))\n-    {\n-    case REG:\n-      /* (mem (reg X))\n-\t => access location by using register,\n-\t use \"lbi / lhi / lwi\" */\n-      snprintf (pattern, sizeof (pattern), \"l%ci\\t%%0, %%1\", size);\n-      break;\n-\n-    case SYMBOL_REF:\n-    case CONST:\n-      /* (mem (symbol_ref X))\n-\t (mem (const (...)))\n-\t => access global variables,\n-\t use \"lbi.gp / lhi.gp / lwi.gp\" */\n-      operands[1] = XEXP (operands[1], 0);\n-      snprintf (pattern, sizeof (pattern), \"l%ci.gp\\t%%0, [ + %%1]\", size);\n-      break;\n-\n-    case POST_INC:\n-      /* (mem (post_inc reg))\n-\t => access location by using register which will be post increment,\n-\t use \"lbi.bi / lhi.bi / lwi.bi\" */\n-      snprintf (pattern, sizeof (pattern),\n-\t\t\"l%ci.bi\\t%%0, %%1, %d\", size, byte);\n-      break;\n-\n-    case POST_DEC:\n-      /* (mem (post_dec reg))\n-\t => access location by using register which will be post decrement,\n-\t use \"lbi.bi / lhi.bi / lwi.bi\" */\n-      snprintf (pattern, sizeof (pattern),\n-\t\t\"l%ci.bi\\t%%0, %%1, -%d\", size, byte);\n-      break;\n-\n-    case POST_MODIFY:\n-      switch (GET_CODE (XEXP (XEXP (code, 1), 1)))\n-\t{\n-\tcase REG:\n-\tcase SUBREG:\n-\t  /* (mem (post_modify (reg) (plus (reg) (reg))))\n-\t     => access location by using register which will be\n-\t     post modified with reg,\n-\t     use \"lb.bi/ lh.bi / lw.bi\" */\n-\t  snprintf (pattern, sizeof (pattern), \"l%c.bi\\t%%0, %%1\", size);\n-\t  break;\n-\tcase CONST_INT:\n-\t  /* (mem (post_modify (reg) (plus (reg) (const_int))))\n-\t     => access location by using register which will be\n-\t     post modified with const_int,\n-\t     use \"lbi.bi/ lhi.bi / lwi.bi\" */\n-\t  snprintf (pattern, sizeof (pattern), \"l%ci.bi\\t%%0, %%1\", size);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    case PLUS:\n-      switch (GET_CODE (XEXP (code, 1)))\n-\t{\n-\tcase REG:\n-\tcase SUBREG:\n-\t  /* (mem (plus reg reg)) or (mem (plus (mult reg const_int) reg))\n-\t     use \"lb / lh / lw\" */\n-\t  snprintf (pattern, sizeof (pattern), \"l%c\\t%%0, %%1\", size);\n-\t  break;\n-\tcase CONST_INT:\n-\t  /* (mem (plus reg const_int))\n-\t     => access location by adding one register with const_int,\n-\t     use \"lbi / lhi / lwi\" */\n-\t  snprintf (pattern, sizeof (pattern), \"l%ci\\t%%0, %%1\", size);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    case LO_SUM:\n-      operands[2] = XEXP (code, 1);\n-      operands[1] = XEXP (code, 0);\n-      snprintf (pattern, sizeof (pattern),\n-\t\t\"l%ci\\t%%0, [%%1 + lo12(%%2)]\", size);\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  output_asm_insn (pattern, operands);\n-  return \"\";\n-}\n-\n-/* Output 32-bit load with signed extension.  */\n-const char *\n-nds32_output_32bit_load_s (rtx *operands, int byte)\n-{\n-  char pattern[100];\n-  unsigned char size;\n-  rtx code;\n-\n-  code = XEXP (operands[1], 0);\n-\n-  size = nds32_byte_to_size (byte);\n-\n-  switch (GET_CODE (code))\n-    {\n-    case REG:\n-      /* (mem (reg X))\n-         => access location by using register,\n-         use \"lbsi / lhsi\" */\n-      snprintf (pattern, sizeof (pattern), \"l%csi\\t%%0, %%1\", size);\n-      break;\n-\n-    case SYMBOL_REF:\n-    case CONST:\n-      /* (mem (symbol_ref X))\n-         (mem (const (...)))\n-         => access global variables,\n-         use \"lbsi.gp / lhsi.gp\" */\n-      operands[1] = XEXP (operands[1], 0);\n-      snprintf (pattern, sizeof (pattern), \"l%csi.gp\\t%%0, [ + %%1]\", size);\n-      break;\n-\n-    case POST_INC:\n-      /* (mem (post_inc reg))\n-         => access location by using register which will be post increment,\n-         use \"lbsi.bi / lhsi.bi\" */\n-      snprintf (pattern, sizeof (pattern),\n-\t\t\"l%csi.bi\\t%%0, %%1, %d\", size, byte);\n-      break;\n-\n-    case POST_DEC:\n-      /* (mem (post_dec reg))\n-         => access location by using register which will be post decrement,\n-         use \"lbsi.bi / lhsi.bi\" */\n-      snprintf (pattern, sizeof (pattern),\n-\t\t\"l%csi.bi\\t%%0, %%1, -%d\", size, byte);\n-      break;\n-\n-    case POST_MODIFY:\n-      switch (GET_CODE (XEXP (XEXP (code, 1), 1)))\n-\t{\n-\tcase REG:\n-\tcase SUBREG:\n-\t  /* (mem (post_modify (reg) (plus (reg) (reg))))\n-\t     => access location by using register which will be\n-\t     post modified with reg,\n-\t     use \"lbs.bi/ lhs.bi\" */\n-\t  snprintf (pattern, sizeof (pattern), \"l%cs.bi\\t%%0, %%1\", size);\n-\t  break;\n-\tcase CONST_INT:\n-\t  /* (mem (post_modify (reg) (plus (reg) (const_int))))\n-\t     => access location by using register which will be\n-\t     post modified with const_int,\n-\t     use \"lbsi.bi/ lhsi.bi\" */\n-\t  snprintf (pattern, sizeof (pattern), \"l%csi.bi\\t%%0, %%1\", size);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    case PLUS:\n-      switch (GET_CODE (XEXP (code, 1)))\n-\t{\n-\tcase REG:\n-\tcase SUBREG:\n-\t  /* (mem (plus reg reg)) or (mem (plus (mult reg const_int) reg))\n-\t     use \"lbs / lhs\" */\n-\t  snprintf (pattern, sizeof (pattern), \"l%cs\\t%%0, %%1\", size);\n-\t  break;\n-\tcase CONST_INT:\n-\t  /* (mem (plus reg const_int))\n-\t     => access location by adding one register with const_int,\n-\t     use \"lbsi / lhsi\" */\n-\t  snprintf (pattern, sizeof (pattern), \"l%csi\\t%%0, %%1\", size);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    case LO_SUM:\n-      operands[2] = XEXP (code, 1);\n-      operands[1] = XEXP (code, 0);\n-      snprintf (pattern, sizeof (pattern),\n-\t\t\"l%csi\\t%%0, [%%1 + lo12(%%2)]\", size);\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  output_asm_insn (pattern, operands);\n-  return \"\";\n-}\n-\n-/* Function to output stack push operation.\n-   We need to deal with normal stack push multiple or stack v3push.  */\n-const char *\n-nds32_output_stack_push (void)\n-{\n-  /* A string pattern for output_asm_insn().  */\n-  char pattern[100];\n-  /* The operands array which will be used in output_asm_insn().  */\n-  rtx operands[3];\n-  /* Pick up callee-saved first regno and last regno for further use.  */\n-  int rb_regno = cfun->machine->callee_saved_regs_first_regno;\n-  int re_regno = cfun->machine->callee_saved_regs_last_regno;\n-\n-  if (TARGET_V3PUSH)\n-    {\n-      /* For stack v3push:\n-           operands[0]: Re\n-           operands[1]: imm8u */\n-\n-      /* This variable is to check if 'push25 Re,imm8u' is available.  */\n-      int sp_adjust;\n-\n-      /* Set operands[0].  */\n-      operands[0] = gen_rtx_REG (SImode, re_regno);\n-\n-      /* Check if we can generate 'push25 Re,imm8u',\n-         otherwise, generate 'push25 Re,0'.  */\n-      sp_adjust = cfun->machine->local_size\n-\t\t  + cfun->machine->out_args_size\n-\t\t  + cfun->machine->callee_saved_area_padding_bytes;\n-      if (satisfies_constraint_Iu08 (GEN_INT (sp_adjust))\n-\t  && NDS32_DOUBLE_WORD_ALIGN_P (sp_adjust))\n-\toperands[1] = GEN_INT (sp_adjust);\n-      else\n-\toperands[1] = GEN_INT (0);\n-\n-      /* Create assembly code pattern.  */\n-      snprintf (pattern, sizeof (pattern), \"push25\\t%%0, %%1\");\n-    }\n-  else\n-    {\n-      /* For normal stack push multiple:\n-         operands[0]: Rb\n-         operands[1]: Re\n-         operands[2]: En4 */\n-\n-      /* This variable is used to check if we only need to generate En4 field.\n-         As long as Rb==Re=SP_REGNUM, we set this variable to 1.  */\n-      int push_en4_only_p = 0;\n-\n-      /* Set operands[0] and operands[1].  */\n-      operands[0] = gen_rtx_REG (SImode, rb_regno);\n-      operands[1] = gen_rtx_REG (SImode, re_regno);\n-\n-      /* 'smw.adm $sp,[$sp],$sp,0' means push nothing.  */\n-      if (!cfun->machine->fp_size\n-\t  && !cfun->machine->gp_size\n-\t  && !cfun->machine->lp_size\n-\t  && REGNO (operands[0]) == SP_REGNUM\n-\t  && REGNO (operands[1]) == SP_REGNUM)\n-\t{\n-\t  /* No need to generate instruction.  */\n-\t  return \"\";\n-\t}\n-      else\n-\t{\n-\t  /* If Rb==Re=SP_REGNUM, we only need to generate En4 field.  */\n-\t  if (REGNO (operands[0]) == SP_REGNUM\n-\t      && REGNO (operands[1]) == SP_REGNUM)\n-\t    push_en4_only_p = 1;\n-\n-\t  /* Create assembly code pattern.\n-\t     We need to handle the form: \"Rb, Re, { $fp $gp $lp }\".  */\n-\t  snprintf (pattern, sizeof (pattern),\n-\t\t    \"push.s\\t%s{%s%s%s }\",\n-\t\t    push_en4_only_p ? \"\" : \"%0, %1, \",\n-\t\t    cfun->machine->fp_size ? \" $fp\" : \"\",\n-\t\t    cfun->machine->gp_size ? \" $gp\" : \"\",\n-\t\t    cfun->machine->lp_size ? \" $lp\" : \"\");\n-\t}\n-    }\n-\n-  /* We use output_asm_insn() to output assembly code by ourself.  */\n-  output_asm_insn (pattern, operands);\n-  return \"\";\n-}\n-\n-/* Function to output stack pop operation.\n-   We need to deal with normal stack pop multiple or stack v3pop.  */\n-const char *\n-nds32_output_stack_pop (void)\n-{\n-  /* A string pattern for output_asm_insn().  */\n-  char pattern[100];\n-  /* The operands array which will be used in output_asm_insn().  */\n-  rtx operands[3];\n-  /* Pick up callee-saved first regno and last regno for further use.  */\n-  int rb_regno = cfun->machine->callee_saved_regs_first_regno;\n-  int re_regno = cfun->machine->callee_saved_regs_last_regno;\n-\n-  if (TARGET_V3PUSH)\n-    {\n-      /* For stack v3pop:\n-           operands[0]: Re\n-           operands[1]: imm8u */\n-\n-      /* This variable is to check if 'pop25 Re,imm8u' is available.  */\n-      int sp_adjust;\n-\n-      /* Set operands[0].  */\n-      operands[0] = gen_rtx_REG (SImode, re_regno);\n-\n-      /* Check if we can generate 'pop25 Re,imm8u',\n-         otherwise, generate 'pop25 Re,0'.\n-         We have to consider alloca issue as well.\n-         If the function does call alloca(), the stack pointer is not fixed.\n-         In that case, we cannot use 'pop25 Re,imm8u' directly.\n-         We have to caculate stack pointer from frame pointer\n-         and then use 'pop25 Re,0'.  */\n-      sp_adjust = cfun->machine->local_size\n-\t\t  + cfun->machine->out_args_size\n-\t\t  + cfun->machine->callee_saved_area_padding_bytes;\n-      if (satisfies_constraint_Iu08 (GEN_INT (sp_adjust))\n-\t  && NDS32_DOUBLE_WORD_ALIGN_P (sp_adjust)\n-\t  && !cfun->calls_alloca)\n-\toperands[1] = GEN_INT (sp_adjust);\n-      else\n-\toperands[1] = GEN_INT (0);\n-\n-      /* Create assembly code pattern.  */\n-      snprintf (pattern, sizeof (pattern), \"pop25\\t%%0, %%1\");\n-    }\n-  else\n-    {\n-      /* For normal stack pop multiple:\n-         operands[0]: Rb\n-         operands[1]: Re\n-         operands[2]: En4 */\n-\n-      /* This variable is used to check if we only need to generate En4 field.\n-         As long as Rb==Re=SP_REGNUM, we set this variable to 1.  */\n-      int pop_en4_only_p = 0;\n-\n-      /* Set operands[0] and operands[1].  */\n-      operands[0] = gen_rtx_REG (SImode, rb_regno);\n-      operands[1] = gen_rtx_REG (SImode, re_regno);\n-\n-      /* 'lmw.bim $sp,[$sp],$sp,0' means pop nothing.  */\n-      if (!cfun->machine->fp_size\n-\t  && !cfun->machine->gp_size\n-\t  && !cfun->machine->lp_size\n-\t  && REGNO (operands[0]) == SP_REGNUM\n-\t  && REGNO (operands[1]) == SP_REGNUM)\n-\t{\n-\t  /* No need to generate instruction.  */\n-\t  return \"\";\n-\t}\n-      else\n-\t{\n-\t  /* If Rb==Re=SP_REGNUM, we only need to generate En4 field.  */\n-\t  if (REGNO (operands[0]) == SP_REGNUM\n-\t      && REGNO (operands[1]) == SP_REGNUM)\n-\t    pop_en4_only_p = 1;\n-\n-\t  /* Create assembly code pattern.\n-\t     We need to handle the form: \"Rb, Re, { $fp $gp $lp }\".  */\n-\t  snprintf (pattern, sizeof (pattern),\n-\t\t    \"pop.s\\t%s{%s%s%s }\",\n-\t\t    pop_en4_only_p ? \"\" : \"%0, %1, \",\n-\t\t    cfun->machine->fp_size ? \" $fp\" : \"\",\n-\t\t    cfun->machine->gp_size ? \" $gp\" : \"\",\n-\t\t    cfun->machine->lp_size ? \" $lp\" : \"\");\n-\t}\n-    }\n-\n-  /* We use output_asm_insn() to output assembly code by ourself.  */\n-  output_asm_insn (pattern, operands);\n-  return \"\";\n-}\n-\n /* Return align 2 (log base 2) if the next instruction of LABEL is 4 byte.  */\n int\n nds32_target_alignment (rtx label)"}]}