{"sha": "1cdfc98a9981768c475fabf069ba4d3e460deb2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNkZmM5OGE5OTgxNzY4YzQ3NWZhYmYwNjliYTRkM2U0NjBkZWIyYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-26T23:20:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-26T23:20:42Z"}, "message": "dwarf2cfi: Defer queued register saves some more [PR99334]\n\nOn the testcase in the PR with\n-fno-tree-sink -O3 -fPIC -fomit-frame-pointer -fno-strict-aliasing -mstackrealign\nwe have prologue:\n0000000000000000 <_func_with_dwarf_issue_>:\n   0:   4c 8d 54 24 08          lea    0x8(%rsp),%r10\n   5:   48 83 e4 f0             and    $0xfffffffffffffff0,%rsp\n   9:   41 ff 72 f8             pushq  -0x8(%r10)\n   d:   55                      push   %rbp\n   e:   48 89 e5                mov    %rsp,%rbp\n  11:   41 57                   push   %r15\n  13:   41 56                   push   %r14\n  15:   41 55                   push   %r13\n  17:   41 54                   push   %r12\n  19:   41 52                   push   %r10\n  1b:   53                      push   %rbx\n  1c:   48 83 ec 20             sub    $0x20,%rsp\nand emit\n00000000 0000000000000014 00000000 CIE\n  Version:               1\n  Augmentation:          \"zR\"\n  Code alignment factor: 1\n  Data alignment factor: -8\n  Return address column: 16\n  Augmentation data:     1b\n  DW_CFA_def_cfa: r7 (rsp) ofs 8\n  DW_CFA_offset: r16 (rip) at cfa-8\n  DW_CFA_nop\n  DW_CFA_nop\n\n00000018 0000000000000044 0000001c FDE cie=00000000 pc=0000000000000000..00000000000001d5\n  DW_CFA_advance_loc: 5 to 0000000000000005\n  DW_CFA_def_cfa: r10 (r10) ofs 0\n  DW_CFA_advance_loc: 9 to 000000000000000e\n  DW_CFA_expression: r6 (rbp) (DW_OP_breg6 (rbp): 0)\n  DW_CFA_advance_loc: 13 to 000000000000001b\n  DW_CFA_def_cfa_expression (DW_OP_breg6 (rbp): -40; DW_OP_deref)\n  DW_CFA_expression: r15 (r15) (DW_OP_breg6 (rbp): -8)\n  DW_CFA_expression: r14 (r14) (DW_OP_breg6 (rbp): -16)\n  DW_CFA_expression: r13 (r13) (DW_OP_breg6 (rbp): -24)\n  DW_CFA_expression: r12 (r12) (DW_OP_breg6 (rbp): -32)\n...\nunwind info for that.  The problem is when async signal\n(or stepping through in the debugger) stops after the pushq %rbp\ninstruction and before movq %rsp, %rbp, the unwind info says that\ncaller's %rbp is saved there at *%rbp, but that is not true, caller's\n%rbp is either still available in the %rbp register, or in *%rsp,\nonly after executing the next instruction - movq %rsp, %rbp - the\nlocation for %rbp is correct.  So, either we'd need to temporarily\nsay:\n  DW_CFA_advance_loc: 9 to 000000000000000e\n  DW_CFA_expression: r6 (rbp) (DW_OP_breg7 (rsp): 0)\n  DW_CFA_advance_loc: 3 to 0000000000000011\n  DW_CFA_expression: r6 (rbp) (DW_OP_breg6 (rbp): 0)\n  DW_CFA_advance_loc: 10 to 000000000000001b\nor to me it seems more compact to just say:\n  DW_CFA_advance_loc: 12 to 0000000000000011\n  DW_CFA_expression: r6 (rbp) (DW_OP_breg6 (rbp): 0)\n  DW_CFA_advance_loc: 10 to 000000000000001b\n\nI've tried instead to deal with it through REG_FRAME_RELATED_EXPR\nfrom the backend, but that failed miserably as explained in the PR,\ndwarf2cfi.c has some rules (Rule 16 to Rule 19) that are specific to the\ndynamic stack realignment using drap register that only the i386 backend\ndoes right now, and by using REG_FRAME_RELATED_EXPR or REG_CFA* notes we\ncan't emulate those rules.  The following patch instead does the deferring\nof the hard frame pointer save rule in dwarf2cfi.c Rule 18 handling and\nemits it on the (set hfp sp) assignment that must appear shortly after it\nand adds assertion that it is the case.\n\nThe difference before/after the patch on the assembly is:\n--- pr99334.s~  2021-03-26 15:42:40.881749380 +0100\n+++ pr99334.s   2021-03-26 17:38:05.729161910 +0100\n@@ -11,8 +11,8 @@ _func_with_dwarf_issue_:\n        andq    $-16, %rsp\n        pushq   -8(%r10)\n        pushq   %rbp\n-       .cfi_escape 0x10,0x6,0x2,0x76,0\n        movq    %rsp, %rbp\n+       .cfi_escape 0x10,0x6,0x2,0x76,0\n        pushq   %r15\n        pushq   %r14\n        pushq   %r13\ni.e. does just what we IMHO need, after pushq %rbp %rbp\nstill contains parent's frame value and so the save rule doesn't\nneed to be overridden there, ditto at the start of the next insn\nbefore the side-effect took effect, and we override it only after\nit when %rbp already has the right value.\n\nIf some other target adds dynamic stack realignment in the future and\nthe offset 0 case wouldn't be true there, the code can be adjusted so that\nit works on all the drap architectures, I'm pretty sure the code would\nneed other adjustments too.\n\nFor the rule 18 and for the (set hfp sp) after it we already have asserts\nfor the drap cases that check whether the code looks the way i?86/x86_64\nemit it currently.\n\n2021-03-26  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/99334\n\t* dwarf2out.h (struct dw_fde_node): Add rule18 member.\n\t* dwarf2cfi.c (dwarf2out_frame_debug_expr): When handling (set hfp sp)\n\tassignment with drap_reg active, queue reg save for hfp with offset 0\n\tand flush queued reg saves.  When handling a push with rule18,\n\tdefer queueing reg save for hfp and just assert the offset is 0.\n\t(scan_trace): Assert that fde->rule18 is false.", "tree": {"sha": "ec30ddcfce5424cdb7123978d0483de699f805db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec30ddcfce5424cdb7123978d0483de699f805db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cdfc98a9981768c475fabf069ba4d3e460deb2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cdfc98a9981768c475fabf069ba4d3e460deb2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cdfc98a9981768c475fabf069ba4d3e460deb2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cdfc98a9981768c475fabf069ba4d3e460deb2a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "980b12cc81979e52f491bf0dfe961d30c07fe864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980b12cc81979e52f491bf0dfe961d30c07fe864", "html_url": "https://github.com/Rust-GCC/gccrs/commit/980b12cc81979e52f491bf0dfe961d30c07fe864"}], "stats": {"total": 36, "additions": 32, "deletions": 4}, "files": [{"sha": "362ff3fdac27bc486840757e1eb0d4498007fd25", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cdfc98a9981768c475fabf069ba4d3e460deb2a/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cdfc98a9981768c475fabf069ba4d3e460deb2a/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=1cdfc98a9981768c475fabf069ba4d3e460deb2a", "patch": "@@ -1695,9 +1695,19 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      if (fde\n \t\t  && fde->stack_realign\n \t\t  && REGNO (src) == STACK_POINTER_REGNUM)\n-\t\tgcc_assert (REGNO (dest) == HARD_FRAME_POINTER_REGNUM\n-\t\t\t    && fde->drap_reg != INVALID_REGNUM\n-\t\t\t    && cur_cfa->reg != dwf_regno (src));\n+\t\t{\n+\t\t  gcc_assert (REGNO (dest) == HARD_FRAME_POINTER_REGNUM\n+\t\t\t      && fde->drap_reg != INVALID_REGNUM\n+\t\t\t      && cur_cfa->reg != dwf_regno (src)\n+\t\t\t      && fde->rule18);\n+\t\t  fde->rule18 = 0;\n+\t\t  /* The save of hard frame pointer has been deferred\n+\t\t     until this point when Rule 18 applied.  Emit it now.  */\n+\t\t  queue_reg_save (dest, NULL_RTX, 0);\n+\t\t  /* And as the instruction modifies the hard frame pointer,\n+\t\t     flush the queue as well.  */\n+\t\t  dwarf2out_flush_queued_reg_saves ();\n+\t\t}\n \t      else\n \t\tqueue_reg_save (src, dest, 0);\n \t    }\n@@ -1907,6 +1917,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t    {\n \t      gcc_assert (cur_cfa->reg != dw_frame_pointer_regnum);\n \t      cur_trace->cfa_store.offset = 0;\n+\t      fde->rule18 = 1;\n \t    }\n \n \t  if (cur_cfa->reg == dw_stack_pointer_regnum)\n@@ -2041,7 +2052,17 @@ dwarf2out_frame_debug_expr (rtx expr)\n \tspan = NULL;\n \n       if (!span)\n-\tqueue_reg_save (src, NULL_RTX, offset);\n+\t{\n+\t  if (fde->rule18)\n+\t    /* Just verify the hard frame pointer save when doing dynamic\n+\t       realignment uses expected offset.  The actual queue_reg_save\n+\t       needs to be deferred until the instruction that sets\n+\t       hard frame pointer to stack pointer, see PR99334 for\n+\t       details.  */\n+\t    gcc_assert (known_eq (offset, 0));\n+\t  else\n+\t    queue_reg_save (src, NULL_RTX, offset);\n+\t}\n       else\n \t{\n \t  /* We have a PARALLEL describing where the contents of SRC live.\n@@ -2732,6 +2753,7 @@ scan_trace (dw_trace_info *trace, bool entry)\n       create_trace_edges (control);\n     }\n \n+  gcc_assert (!cfun->fde || !cfun->fde->rule18);\n   add_cfi_insn = NULL;\n   cur_row = NULL;\n   cur_trace = NULL;"}, {"sha": "76a9c0a39a298eff4fd0150eb24eb83735524e23", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cdfc98a9981768c475fabf069ba4d3e460deb2a/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cdfc98a9981768c475fabf069ba4d3e460deb2a/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=1cdfc98a9981768c475fabf069ba4d3e460deb2a", "patch": "@@ -108,6 +108,12 @@ struct GTY(()) dw_fde_node {\n   /* True iff dw_fde_second_begin label is in text_section or\n      cold_text_section.  */\n   unsigned second_in_std_section : 1;\n+  /* True if Rule 18 described in dwarf2cfi.c is in action, i.e. for dynamic\n+     stack realignment in between pushing of hard frame pointer to stack\n+     and setting hard frame pointer to stack pointer.  The register save for\n+     hard frame pointer register should be emitted only on the latter\n+     instruction.  */\n+  unsigned rule18 : 1;\n };\n \n "}]}