{"sha": "69f73bd39537419efe9d74c63c84e3292c9f4a15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlmNzNiZDM5NTM3NDE5ZWZlOWQ3NGM2M2M4NGUzMjkyYzlmNGExNQ==", "commit": {"author": {"name": "Carlo Wood", "email": "carlo@alinoe.com", "date": "2003-12-05T02:40:53Z"}, "committer": {"name": "Carlo Wood", "email": "carlo@gcc.gnu.org", "date": "2003-12-05T02:40:53Z"}, "message": "re PR libstdc++/13045 (Demangler does demangle floating values.)\n\nPR libstdc++/13045\n* bits/demangle.h\nnamespace __gnu_cxx::demangler\n(enum substitution_nt): Removed trailing comma.\n(implementation_details): Added.\n(session<Allocator>::M_implementation_details): Added.\n(session<Allocator>::session): Pass implementation_details.\n(session<Allocator>::decode_encoding): Same.\n(session<Allocator>::decode_real): Added.\n(_GLIBCXX_DEMANGLER_STYLE_VOID _GLIBCXX_DEMANGLER_STYLE_LITERAL\n_GLIBCXX_DEMANGLER_STYLE_LITERAL_INT\n_GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n_GLIBCXX_DEMANGLER_STYLE_SIZEOF_TYPENAME): Replaced with\nimplementation_details equivalent.\n(session<Allocator>::decode_expression):\nUse M_implementation_details instead of macros. Add extra parentheses\naround 'larger than' operator in expressions in template arguments.\n(session<Allocator>::decode_bare_function_type): Idem.\n(session<Allocator>::decode_literal):\nIdem, and call decode_real for floating literals.\n(session<Allocator>::decode_type_with_postfix): Put the postfix\nof the return type of (member) functions after the function\ninstead of after the return type.  Also, put a space after the\nprefix of qualified function pointers: \"int (* const<space>\".\n* src/demangle.cc: include most dependent header file first.\n* testsuite/demangle/regression/cw-16.cc: Updated two\nand added three tests.\n\nFrom-SVN: r74304", "tree": {"sha": "3580ef8e6b68df46d03fc5518c47c464da930533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3580ef8e6b68df46d03fc5518c47c464da930533"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69f73bd39537419efe9d74c63c84e3292c9f4a15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f73bd39537419efe9d74c63c84e3292c9f4a15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69f73bd39537419efe9d74c63c84e3292c9f4a15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f73bd39537419efe9d74c63c84e3292c9f4a15/comments", "author": {"login": "CarloWood", "id": 590303, "node_id": "MDQ6VXNlcjU5MDMwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/590303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CarloWood", "html_url": "https://github.com/CarloWood", "followers_url": "https://api.github.com/users/CarloWood/followers", "following_url": "https://api.github.com/users/CarloWood/following{/other_user}", "gists_url": "https://api.github.com/users/CarloWood/gists{/gist_id}", "starred_url": "https://api.github.com/users/CarloWood/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CarloWood/subscriptions", "organizations_url": "https://api.github.com/users/CarloWood/orgs", "repos_url": "https://api.github.com/users/CarloWood/repos", "events_url": "https://api.github.com/users/CarloWood/events{/privacy}", "received_events_url": "https://api.github.com/users/CarloWood/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "efdba735bef6fc3c86df8e37bdfd17525f32ca8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efdba735bef6fc3c86df8e37bdfd17525f32ca8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efdba735bef6fc3c86df8e37bdfd17525f32ca8c"}], "stats": {"total": 370, "additions": 256, "deletions": 114}, "files": [{"sha": "f2936ed29efcb9c0c83477125c2a6d5b5c3e3ba9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f73bd39537419efe9d74c63c84e3292c9f4a15/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f73bd39537419efe9d74c63c84e3292c9f4a15/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=69f73bd39537419efe9d74c63c84e3292c9f4a15", "patch": "@@ -1,3 +1,33 @@\n+2003-12-05  Carlo Wood  <carlo@alinoe.com>\n+\n+\tPR libstdc++/13045\n+\t* bits/demangle.h\n+\tnamespace __gnu_cxx::demangler\n+\t(enum substitution_nt): Removed trailing comma.\n+\t(implementation_details): Added.\n+\t(session<Allocator>::M_implementation_details): Added.\n+\t(session<Allocator>::session): Pass implementation_details.\n+\t(session<Allocator>::decode_encoding): Same.\n+\t(session<Allocator>::decode_real): Added.\n+\t(_GLIBCXX_DEMANGLER_STYLE_VOID _GLIBCXX_DEMANGLER_STYLE_LITERAL\n+\t_GLIBCXX_DEMANGLER_STYLE_LITERAL_INT\n+\t_GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n+\t_GLIBCXX_DEMANGLER_STYLE_SIZEOF_TYPENAME): Replaced with\n+\timplementation_details equivalent.\n+\t(session<Allocator>::decode_expression):\n+\tUse M_implementation_details instead of macros. Add extra parentheses\n+\taround 'larger than' operator in expressions in template arguments.\n+\t(session<Allocator>::decode_bare_function_type): Idem.\n+\t(session<Allocator>::decode_literal):\n+\tIdem, and call decode_real for floating literals.\n+\t(session<Allocator>::decode_type_with_postfix): Put the postfix\n+\tof the return type of (member) functions after the function\n+\tinstead of after the return type.  Also, put a space after the\n+\tprefix of qualified function pointers: \"int (* const<space>\".\n+\t* src/demangle.cc: include most dependent header file first.\n+\t* testsuite/demangle/regression/cw-16.cc: Updated two\n+\tand added three tests.\n+\n 2003-12-04  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/13284"}, {"sha": "cb90acc224f9b827e9483e1ec59a5fcd0d1b1ba5", "filename": "libstdc++-v3/include/bits/demangle.h", "status": "modified", "additions": 216, "deletions": 111, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f73bd39537419efe9d74c63c84e3292c9f4a15/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f73bd39537419efe9d74c63c84e3292c9f4a15/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h?ref=69f73bd39537419efe9d74c63c84e3292c9f4a15", "patch": "@@ -54,32 +54,6 @@\n #define _GLIBCXX_DEMANGLER_CWDEBUG 1\n #endif\n \n-// The following defines change the behaviour of the demangler.  The\n-// default behaviour is that none of these macros is defined.\n-\n-// _GLIBCXX_DEMANGLER_STYLE_VOID\n-// Default behaviour:\t\t\t\t\tint f()\n-// Uses (void) instead of ():\t\t\t\tint f(void)\n-\n-// _GLIBCXX_DEMANGLER_STYLE_LITERAL\n-// Default behaviour:\t\t\t\t\t(long)13, \n-//\t\t\t\t\t\t\t(unsigned long long)19\n-// Use extensions 'u', 'l' and 'll' for integral\n-// literals (as in template arguments):\t\t\t13l, 19ull\n-\n-// _GLIBCXX_DEMANGLER_STYLE_LITERAL_INT\n-// Default behaviour:\t\t\t\t\t4\n-// Use also an explicit cast for int in literals:\t(int)4\n-\n-// _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n-// Default behaviour:\t\t\t\t\t(i) < (3), sizeof (int)\n-// Don't output spaces around operators in expressions:\t(i)<(3), sizeof(int)\n-\n-// _GLIBCXX_DEMANGLER_STYLE_SIZEOF_TYPENAME\n-// Default behaviour:\t\t\t\t\tsizeof (X::t)\n-// Put 'typename' infront of <nested-name> types\n-// inside a 'sizeof':\t\t\t\t\tsizeof (typename X::t)\n-\n namespace __gnu_cxx\n {\n   namespace demangler\n@@ -91,7 +65,7 @@ namespace __gnu_cxx\n       template_template_param,\n       nested_name_prefix,\n       nested_name_template_prefix,\n-      unscoped_template_name,\n+      unscoped_template_name\n     };\n \n     struct substitution_st\n@@ -312,6 +286,59 @@ namespace __gnu_cxx\n #endif\n       };\n \n+    struct implementation_details\n+    {\n+      private:\n+        unsigned int M_style;\n+\n+      public:\n+\t// The following flags change the behaviour of the demangler.  The\n+\t// default behaviour is that none of these flags is set.\n+\n+        static unsigned int const style_void = 1;\n+\t// Default behaviour:\t\t\t\tint f()\n+\t// Use (void) instead of ():\t\t\tint f(void)\n+\n+        static unsigned int const style_literal = 2;\n+\t// Default behaviour:\t\t\t\t(long)13, \n+\t//\t\t\t\t\t\t(unsigned long long)19\n+\t// Use extensions 'u', 'l' and 'll' for integral\n+\t// literals (as in template arguments):\t\t13l, 19ull\n+\n+        static unsigned int const style_literal_int = 4;\n+\t// Default behaviour:\t\t\t\t4\n+\t// Use also an explicit\n+\t//   cast for int in literals:\t\t\t(int)4\n+\n+        static unsigned int const style_compact_expr_ops = 8;\n+\t// Default behaviour:\t\t\t\t(i) < (3), sizeof (int)\n+\t// Don't output spaces around\n+\t//   operators in expressions:\t\t\t(i)<(3), sizeof(int)\n+\n+        static unsigned int const style_sizeof_typename = 16;\n+\t// Default behaviour:\t\t\t\tsizeof (X::t)\n+\t// Put 'typename' infront of <nested-name>\n+\t// types inside a 'sizeof':\t\t\tsizeof (typename X::t)\n+\n+      public:\n+\timplementation_details(unsigned int style_flags = 0) :\n+\t    M_style(style_flags) { }\n+\tvirtual ~implementation_details() { }\n+\tbool get_style_void(void) const\n+\t    { return (M_style & style_void); }\n+\tbool get_style_literal(void) const\n+\t    { return (M_style & style_literal); }\n+\tbool get_style_literal_int(void) const\n+\t    { return (M_style & style_literal_int); }\n+\tbool get_style_compact_expr_ops(void) const\n+\t    { return (M_style & style_compact_expr_ops); }\n+\tbool get_style_sizeof_typename(void) const\n+\t    { return (M_style & style_sizeof_typename); }\n+        // This can be overridden by user implementations.\n+\tvirtual bool decode_real(char* output, unsigned long* input,\n+                                 size_t size_of_real) const { return false; }\n+    };\n+\n     template<typename Allocator>\n       class session\n       {\n@@ -336,25 +363,29 @@ namespace __gnu_cxx\n \tstd::vector<int, Allocator> M_template_arg_pos;\n \tint M_template_arg_pos_offset;\n \tstd::vector<substitution_st, Allocator> M_substitutions_pos;\n+\timplementation_details const& M_implementation_details;\n #if _GLIBCXX_DEMANGLER_CWDEBUG\n \tbool M_inside_add_substitution;\n #endif\n \n       public:\n-\texplicit session(char const* in, int len)\n+\texplicit session(char const* in, int len,\n+\t    implementation_details const& id = implementation_details())\n \t: M_str(in), M_pos(0), M_maxpos(len - 1), M_result(true),\n \t  M_inside_template_args(0), M_inside_type(0),\n \t  M_inside_substitution(0), M_saw_destructor(false),\n \t  M_name_is_cdtor(false), M_name_is_template(false),\n \t  M_name_is_conversion_operator(false),\n-\t  M_template_args_need_space(false), M_template_arg_pos_offset(0)\n+\t  M_template_args_need_space(false), M_template_arg_pos_offset(0),\n+\t  M_implementation_details(id)\n #if _GLIBCXX_DEMANGLER_CWDEBUG\n \t  , M_inside_add_substitution(false)\n #endif\n \t{ }\n \n \tstatic int\n-\tdecode_encoding(string_type& output, char const* input, int len);\n+\tdecode_encoding(string_type& output, char const* input, int len,\n+\t  implementation_details const& id = implementation_details());\n \n \tbool\n \tdecode_type(string_type& output,\n@@ -425,6 +456,7 @@ namespace __gnu_cxx\n \tbool decode_unscoped_name(string_type& output);\n \tbool decode_non_negative_decimal_integer(string_type& output);\n \tbool decode_special_name(string_type& output);\n+        bool decode_real(string_type& output, size_t size_of_real);\n       };\n \n     template<typename Allocator>\n@@ -879,6 +911,66 @@ namespace __gnu_cxx\n \t_GLIBCXX_DEMANGLER_RETURN;\n       }\n \n+    template<typename Allocator>\n+      bool\n+      session<Allocator>::decode_real(string_type& output, size_t size_of_real)\n+      {\n+\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_real\");\n+\n+\tunsigned long words[4];\t// 32 bit per long, maximum of 128 bits.\n+\tunsigned long* word = &words[0];\n+\n+\tint saved_pos;\n+\tstore(saved_pos);\n+\n+\t// The following assumes that leading zeroes are also included in the\n+\t// mangled name, I am not sure that is conforming to the C++-ABI, but\n+\t// it is what g++ does.\n+\tunsigned char nibble, c = current();\n+\tfor(size_t word_cnt = size_of_real / 4; word_cnt > 0; --word_cnt)\n+\t{\n+\t  for (int nibble_cnt = 0; nibble_cnt < 8; ++nibble_cnt)\n+\t  {\n+\t    // Translate character into nibble.\n+\t    if (c < '0' || c > 'f')\n+\t      _GLIBCXX_DEMANGLER_FAILURE;\n+\t    if (c <= '9')\n+\t      nibble = c - '0';\n+\t    else if (c >= 'a')\n+\t      nibble = c - 'a' + 10;\n+\t    else\n+\t      _GLIBCXX_DEMANGLER_FAILURE;\n+\t    // Write nibble into word array.\n+\t    if (nibble_cnt == 0)\n+\t      *word = nibble << 28;\n+\t    else\n+\t      *word |= (nibble << (28 - 4 * nibble_cnt));\n+\t    c = next();\n+\t  }\n+\t  ++word;\n+\t}\n+\tchar buf[24];\n+\tif (M_implementation_details.decode_real(buf, words, size_of_real))\n+\t{\n+\t  output += buf;\n+\t  _GLIBCXX_DEMANGLER_RETURN;\n+\t}\n+\trestore(saved_pos);\n+\n+\toutput += '[';\n+\tc = current();\n+\tfor(size_t nibble_cnt = 0; nibble_cnt < 2 * size_of_real; ++nibble_cnt)\n+\t{\n+\t  if (c < '0' || c > 'f' || (c > '9' && c < 'a'))\n+\t    _GLIBCXX_DEMANGLER_FAILURE;\n+\t  output += c;\n+\t  c = next();\n+\t}\n+\toutput += ']';\n+\n+\t_GLIBCXX_DEMANGLER_RETURN;\n+      }\n+\n     template<typename Allocator>\n       bool\n       session<Allocator>::decode_literal(string_type& output)\n@@ -891,7 +983,7 @@ namespace __gnu_cxx\n \t    _GLIBCXX_DEMANGLER_FAILURE;\n \t  eat_current();\n \t  if ((M_pos += decode_encoding(output, M_str + M_pos,\n-\t\t  M_maxpos - M_pos + 1)) < 0)\n+\t\t  M_maxpos - M_pos + 1, M_implementation_details)) < 0)\n \t    _GLIBCXX_DEMANGLER_FAILURE;\n \t}\n \telse\n@@ -907,34 +999,39 @@ namespace __gnu_cxx\n \t    _GLIBCXX_DEMANGLER_RETURN;\n \t  }\n \t  char c = current();\n-#ifdef _GLIBCXX_DEMANGLER_STYLE_LITERAL\n-\t  if (c == 'i' || c == 'j' || c == 'l' ||\n-\t      c == 'm' || c == 'x' || c == 'y')\n+\t  if ((c == 'i' || c == 'j' || c == 'l' ||\n+\t       c == 'm' || c == 'x' || c == 'y') &&\n+              M_implementation_details.get_style_literal())\n \t    eat_current();\n-\t  else\n-#else\n-#ifndef _GLIBCXX_DEMANGLER_STYLE_LITERAL_INT\n-\t  if (c == 'i')\n+\t  else if (c == 'i' &&\n+\t      !M_implementation_details.get_style_literal_int())\n \t    eat_current();\n \t  else\n-#endif\n-#endif\n \t  {\n \t    output += '(';\n \t    if (!decode_type(output))\n \t      _GLIBCXX_DEMANGLER_FAILURE;\n \t    output += ')';\n \t  }\n-\t  if (!decode_number(output))\n+\t  if (c >= 'd' && c <= 'g')\n+\t  {\n+\t    size_t size_of_real = (c == 'd') ? sizeof(double) :\n+\t        ((c == 'f') ? sizeof(float) :\n+\t\t(c == 'e') ?  sizeof(long double) : 16);\n+\t    if (!decode_real(output, size_of_real))\n+\t\t_GLIBCXX_DEMANGLER_FAILURE;\n+\t  }\n+\t  else if (!decode_number(output))\n \t    _GLIBCXX_DEMANGLER_FAILURE;\n-#ifdef _GLIBCXX_DEMANGLER_STYLE_LITERAL\n-\t  if (c == 'j' || c == 'm' || c == 'y')\n-\t    output += 'u';\n-\t  if (c == 'l' || c == 'm')\n-\t    output += 'l';\n-\t  if (c == 'x' || c == 'y')\n-\t    output += \"ll\";\n-#endif\n+          if (M_implementation_details.get_style_literal())\n+\t  {\n+\t    if (c == 'j' || c == 'm' || c == 'y')\n+\t      output += 'u';\n+\t    if (c == 'l' || c == 'm')\n+\t      output += 'l';\n+\t    if (c == 'x' || c == 'y')\n+\t      output += \"ll\";\n+\t  }\n \t}\n \t_GLIBCXX_DEMANGLER_RETURN;\n       }\n@@ -1204,11 +1301,10 @@ namespace __gnu_cxx\n \t  if (opcode1 == 't' || opcode1 == 'z')\n \t  {\n \t    eat_current();\n-#ifdef _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n-\t    output += \"sizeof(\";\n-#else\n-\t    output += \"sizeof (\";\n-#endif\n+\t    if (M_implementation_details.get_style_compact_expr_ops())\n+\t      output += \"sizeof(\";\n+\t    else\n+\t      output += \"sizeof (\";\n \t    if (opcode1 == 't')\n \t    {\n \t      // I cannot think of a mangled name that is valid for both cases\n@@ -1240,21 +1336,22 @@ namespace __gnu_cxx\n \t      // This is ambiguity is very unlikely to happen and it is kind\n \t      // of fuzzy to detect when adding a 'typename' makes sense.\n \t      //\n-#ifdef _GLIBCXX_DEMANGLER_STYLE_SIZEOF_TYPENAME\n-\t      // We can only get here inside a template parameter,\n-\t      // so this is syntactically correct if the given type is\n-\t      // a typedef.  The only disadvantage is that it is inconsistent\n-\t      // with all other places where the 'typename' keyword should be\n-\t      // used and we don't.\n-\t      // With this, the above example will demangle as\n-\t      // void f<5, A>(C<sizeof (typename T::t), sizeof (T::t)>::q)\n-\t      if (current() == 'N' ||\t// <nested-name>\n-\t      \t\t\t\t// This should be a safe bet.\n-\t          (current() == 'S' &&\n-\t\t   next_peek() == 't'))\t// std::something, guess that\n-\t\t   \t\t\t// this involves a typedef.\n-\t\toutput += \"typename \";\n-#endif\n+\t      if (M_implementation_details.get_style_sizeof_typename())\n+\t      {\n+\t\t// We can only get here inside a template parameter,\n+\t\t// so this is syntactically correct if the given type is\n+\t\t// a typedef.  The only disadvantage is that it is inconsistent\n+\t\t// with all other places where the 'typename' keyword should be\n+\t\t// used and we don't.\n+\t\t// With this, the above example will demangle as\n+\t\t// void f<5, A>(C<sizeof (typename T::t), sizeof (T::t)>::q)\n+\t\tif (current() == 'N' ||\t// <nested-name>\n+\t\t\t\t\t  // This should be a safe bet.\n+\t\t    (current() == 'S' &&\n+\t\t     next_peek() == 't'))\t// std::something, guess that\n+\t\t\t\t\t  // this involves a typedef.\n+\t\t  output += \"typename \";\n+\t      }\n \t      if (!decode_type(output))\n \t\t_GLIBCXX_DEMANGLER_FAILURE;\n \t    }\n@@ -1305,32 +1402,33 @@ namespace __gnu_cxx\n \t\t  output += op;\n \t\tbool is_eq = (opcode1 != current());\n \t\teat_current();\n+\t\tif (index == 34 && M_inside_template_args)\t// operator>\n+\t\t  output += '(';\n \t\toutput += '(';\n \t\tif (!decode_expression(output))\n \t\t  _GLIBCXX_DEMANGLER_FAILURE;\n \t\toutput += ')';\n \t\tif (entry.type != unary)\n \t\t{\n-#ifndef _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n-\t\t  output += ' ';\n-#endif\n+\t          if (!M_implementation_details.get_style_compact_expr_ops())\n+\t\t    output += ' ';\n \t\t  output += op;\n \t\t  if (is_eq)\n \t\t    output += '=';\n-#ifndef _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n-\t\t  output += ' ';\n-#endif\n+\t          if (!M_implementation_details.get_style_compact_expr_ops())\n+\t\t    output += ' ';\n \t\t  output += '(';\n \t\t  if (!decode_expression(output))\n \t\t    _GLIBCXX_DEMANGLER_FAILURE;\n \t\t  output += ')';\n+\t\t  if (index == 34 && M_inside_template_args)\n+\t\t    output += ')';\n \t\t  if (entry.type == trinary)\n \t\t  {\n-#ifdef _GLIBCXX_DEMANGLER_STYLE_COMPACT_EXPR_OPS\n-\t\t    output += \":(\";\n-#else\n-\t\t    output += \" : (\";\n-#endif\n+\t\t    if (M_implementation_details.get_style_compact_expr_ops())\n+\t\t      output += \":(\";\n+\t\t    else\n+\t\t      output += \" : (\";\n \t\t    if (!decode_expression(output))\n \t\t      _GLIBCXX_DEMANGLER_FAILURE;\n \t\t    output += ')';\n@@ -1440,8 +1538,7 @@ namespace __gnu_cxx\n \t  M_saw_destructor = false;\n \t  _GLIBCXX_DEMANGLER_RETURN;\n \t}\n-#ifndef _GLIBCXX_DEMANGLER_STYLE_VOID\n-\tif (current() == 'v')\n+\tif (current() == 'v' && !M_implementation_details.get_style_void())\n \t{\n \t  eat_current();\n \t  if (current() != 'E' && current() != 0)\n@@ -1450,7 +1547,6 @@ namespace __gnu_cxx\n \t  M_saw_destructor = false;\n \t  _GLIBCXX_DEMANGLER_RETURN;\n \t}\n-#endif\n \toutput += '(';\n \tM_template_args_need_space = false;\n \tif (!decode_type(output))\t// Must have at least one parameter.\n@@ -1508,8 +1604,8 @@ namespace __gnu_cxx\n     // <Q>F<R><B>E \t    ==> R (Q)B\t\t\"<R>\", \"<B>\" (<B> recursive)\n     //                                              and \"F<R><B>E\".\n     //\n-    // Note that if <R> has postfix qualifiers (an array), then those\n-    // are added AFTER the (member) function type.  For example:\n+    // Note that if <R> has postfix qualifiers (an array or function), then\n+    // those are added AFTER the (member) function type.  For example:\n     // <Q>FPA<R><B>E ==> R (*(Q)B) [], where the PA added the prefix\n     // \"(*\" and the postfix \") []\".\n     //\n@@ -1863,7 +1959,8 @@ namespace __gnu_cxx\n \t\t// Return type.\n \t\t// Constructors, destructors and conversion operators don't\n \t\t// have a return type, but seem to never get here.\n-\t\tif (!decode_type_with_postfix(prefix, postfix))\n+\t\tstring_type return_type_postfix;\n+\t\tif (!decode_type_with_postfix(prefix, return_type_postfix))\n \t\t    // substitution: <R> recursive\n \t\t{\n \t\t  failure = true;\n@@ -1885,9 +1982,10 @@ namespace __gnu_cxx\n \t\tadd_substitution(start_pos, type);\n \t\t// substitution: all qualified types if any.\n \t\tqualifiers->decode_qualifiers(prefix, postfix);\n-\t\tprefix += \")\";\n-\t\tprefix += bare_function_type;\n-\t\tprefix += member_function_qualifiers;\n+\t\tpostfix += \")\";\n+\t\tpostfix += bare_function_type;\n+\t\tpostfix += member_function_qualifiers;\n+\t\tpostfix += return_type_postfix;\n \t\tgoto decode_type_exit;\n \t      }\n \t      qualifiers->add_qualifier_start(pointer_to_member, start_pos,\n@@ -1929,17 +2027,19 @@ namespace __gnu_cxx\n \t      //     substitution: \"<R>\", \"<B>\" (<B> recursive) and \"F<R><B>E\".\n \n \t      // Return type.\n-\t      if (!decode_type_with_postfix(prefix, postfix))\n+\t      string_type return_type_postfix;\n+\t      if (!decode_type_with_postfix(prefix, return_type_postfix))\n \t\t  // Substitution: \"<R>\".\n \t      {\n \t\tfailure = true;\n \t\tbreak;\n \t      }\n-\t      // Only array (pointer) types have a postfix.\n-\t      // In that case we don't want the space but\n-\t      // expect something like prefix is \"int (*\"\n-\t      // and postfix is \") [1]\".\n-\t      if (postfix.size() == 0)\n+\t      // Only array and function (pointer) types have a postfix.\n+\t      // In that case we don't want the space but expect something\n+\t      // like prefix is \"int (*\" and postfix is \") [1]\".\n+\t      // We do want the space if this pointer is qualified.\n+\t      if (return_type_postfix.size() == 0 ||\n+\t          (prefix.size() > 0 && *prefix.rbegin() != '*'))\n \t\tprefix += ' ';\n \t      prefix += '(';\n \t      string_type bare_function_type;\n@@ -1953,10 +2053,11 @@ namespace __gnu_cxx\n \t      add_substitution(start_pos, type);  // Substitution: \"F<R><B>E\".\n \t      qualifiers->decode_qualifiers(prefix, postfix);\n \t\t  // substitution: all qualified types, if any.\n-\t      prefix += \")\";\n+\t      postfix += \")\";\n \t      if (extern_C)\n-\t        prefix += \" [extern \\\"C\\\"] \";\n-\t      prefix += bare_function_type;\n+\t        postfix += \" [extern \\\"C\\\"] \";\n+\t      postfix += bare_function_type;\n+\t      postfix += return_type_postfix;\n \t      break;\n \t    }\n \t    case 'T':\n@@ -2181,7 +2282,8 @@ namespace __gnu_cxx\n \tif (current() != 'Z' || M_pos >= M_maxpos)\n \t  _GLIBCXX_DEMANGLER_FAILURE;\n \tif ((M_pos += decode_encoding(output, M_str + M_pos + 1,\n-\t\tM_maxpos - M_pos) + 1) < 0 || eat_current() != 'E')\n+\t\tM_maxpos - M_pos, M_implementation_details) + 1) < 0 ||\n+\t\teat_current() != 'E')\n \t  _GLIBCXX_DEMANGLER_FAILURE;\n \toutput += \"::\";\n \tif (current() == 's')\n@@ -2480,7 +2582,7 @@ namespace __gnu_cxx\n \t    if (!decode_call_offset(output)\n \t\t|| !decode_call_offset(output)\n \t\t|| (M_pos += decode_encoding(output, M_str + M_pos,\n-\t\t    M_maxpos - M_pos + 1)) < 0)\n+\t\t    M_maxpos - M_pos + 1, M_implementation_details)) < 0)\n \t      _GLIBCXX_DEMANGLER_FAILURE;\n \t    _GLIBCXX_DEMANGLER_RETURN;\n \t  case 'C':\t\t// GNU extension?\n@@ -2507,7 +2609,7 @@ namespace __gnu_cxx\n \t      output += \"non-virtual thunk to \";\n \t    if (!decode_call_offset(output)\n \t\t|| (M_pos += decode_encoding(output, M_str + M_pos,\n-\t\t    M_maxpos - M_pos + 1)) < 0)\n+\t\t    M_maxpos - M_pos + 1, M_implementation_details)) < 0)\n \t      _GLIBCXX_DEMANGLER_FAILURE;\n \t    _GLIBCXX_DEMANGLER_RETURN;\n \t}\n@@ -2522,8 +2624,7 @@ namespace __gnu_cxx\n     template<typename Allocator>\n       int\n       session<Allocator>::decode_encoding(string_type& output,\n-\t\t\t\t\t  char const* in,\n-\t\t\t\t\t  int len)\n+          char const* in, int len, implementation_details const& id)\n       {\n #if _GLIBCXX_DEMANGLER_CWDEBUG\n \t_GLIBCXX_DEMANGLER_DOUT(dc::demangler,\n@@ -2534,7 +2635,7 @@ namespace __gnu_cxx\n #endif\n \tif (len <= 0)\n \t  return INT_MIN;\n-\tsession<Allocator> demangler_session(in, len);\n+\tsession<Allocator> demangler_session(in, len, id);\n \tstring_type nested_name_qualifiers;\n \tint saved_pos;\n \tdemangler_session.store(saved_pos);\n@@ -2577,8 +2678,10 @@ namespace __gnu_cxx\n       typedef Allocator allocator_type;\n       typedef std::basic_string<char, std::char_traits<char>, Allocator> \n \t  string_type;\n-      static string_type symbol(char const* in);\n-      static string_type type(char const* in);\n+      static string_type symbol(char const* in,\n+                                demangler::implementation_details const& id);\n+      static string_type type(char const* in,\n+                              demangler::implementation_details const& id);\n     };\n \n   // demangle::symbol()\n@@ -2587,7 +2690,8 @@ namespace __gnu_cxx\n   // instance returned by nm(1).\n   template<typename Allocator>\n     std::basic_string<char, std::char_traits<char>, Allocator>\n-    demangle<Allocator>::symbol(char const* input)\n+    demangle<Allocator>::symbol(char const* input,\n+                                demangler::implementation_details const& id)\n     {\n       // <mangled-name> ::= _Z <encoding>\n       // <mangled-name> ::= _GLOBAL_ _<type>_ <disambiguation part>\n@@ -2616,8 +2720,8 @@ namespace __gnu_cxx\n \t}\n \telse if (input[1] == 'Z')\n \t{\n-\t  int cnt = demangler_type::decode_encoding(result, input + 2,\n-\t\t\t\t\t\t    INT_MAX);\n+\t  int cnt =\n+\t      demangler_type::decode_encoding(result, input + 2, INT_MAX, id);\n \t  if (cnt < 0 || input[cnt + 2] != 0)\n \t    failure = true;\n \t}\n@@ -2637,14 +2741,15 @@ namespace __gnu_cxx\n   // name as for instance returned by std::type_info::name().\n   template<typename Allocator>\n     std::basic_string<char, std::char_traits<char>, Allocator> \n-    demangle<Allocator>::type(char const* input)\n+    demangle<Allocator>::type(char const* input,\n+                              demangler::implementation_details const& id)\n     {\n       std::basic_string<char, std::char_traits<char>, Allocator> result;\n       if (input == NULL)\n \tresult = \"(null)\";\n       else\n       {\n-\tdemangler::session<Allocator> demangler_session(input, INT_MAX);\n+\tdemangler::session<Allocator> demangler_session(input, INT_MAX, id);\n \tif (!demangler_session.decode_type(result)\n \t    || demangler_session.remaining_input_characters())\n \t{"}, {"sha": "58c076785e52da82a9c2f99b00a9f77c309fa623", "filename": "libstdc++-v3/src/demangle.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f73bd39537419efe9d74c63c84e3292c9f4a15/libstdc%2B%2B-v3%2Fsrc%2Fdemangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f73bd39537419efe9d74c63c84e3292c9f4a15/libstdc%2B%2B-v3%2Fsrc%2Fdemangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fdemangle.cc?ref=69f73bd39537419efe9d74c63c84e3292c9f4a15", "patch": "@@ -28,8 +28,8 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <cxxabi.h>\n #include <bits/demangle.h>\n+#include <cxxabi.h>\n \n // __cxa_demangle\n //"}, {"sha": "8dbfcb1f56e073af7083ba82843d813107f90ce4", "filename": "libstdc++-v3/testsuite/demangle/regression/cw-16.cc", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f73bd39537419efe9d74c63c84e3292c9f4a15/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2Fcw-16.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f73bd39537419efe9d74c63c84e3292c9f4a15/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2Fcw-16.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fdemangle%2Fregression%2Fcw-16.cc?ref=69f73bd39537419efe9d74c63c84e3292c9f4a15", "patch": "@@ -32,15 +32,22 @@ verify_demangle(\"_Z3fooIA6_KiEvA9_KT_rVPrS4_\",\n \t\t\"void foo<int const [6]>(int const [9][6], int const restrict (* volatile restrict) [9][6])\");\n // 2003/11/12, libstdc++/12947\n verify_demangle(\"_Z1fILi5E1AEvN1CIXqugtT_Li0ELi1ELi2EEE1qE\",\n-                \"void f<5, A>(C<((5) > (0)) ? (1) : (2)>::q)\");\n+                \"void f<5, A>(C<(((5) > (0))) ? (1) : (2)>::q)\");\n verify_demangle(\"_Z1fILi5EEvN1AIXcvimlT_Li22EEE1qE\",\n                 \"void f<5>(A<(int)((5) * (22))>::q)\");\n verify_demangle(\"_Z1fPFYPFiiEiE\",\n-                \"f(int (*)(int) (*) [extern \\\"C\\\"] (int))\");\n+                \"f(int (*(*) [extern \\\"C\\\"] (int))(int))\");\n verify_demangle(\"_Z1fI1XENT_1tES2_\",\n                 \"X::t f<X>(X::t)\");\n verify_demangle(\"_Z1fILi5E1AEvN1CIXstN1T1tEEXszsrS2_1tEE1qE\",\n                 \"void f<5, A>(C<sizeof (T::t), sizeof (T::t)>::q)\");\n+// 2003/12/03, libstdc++/13045\n+verify_demangle(\"_Z1fILi1ELc120EEv1AIXplT_cviLd4028ae147ae147aeEEE\",\n+                \"void f<1, (char)120>(A<(1) + ((int)((double)[4028ae147ae147ae]))>)\");\n+verify_demangle(\"_Z1fILi1ELc120EEv1AIXplT_cviLf3f800000EEE\",\n+                \"void f<1, (char)120>(A<(1) + ((int)((float)[3f800000]))>)\");\n+verify_demangle(\"_Z9hairyfuncM1YKFPVPFrPA2_PM1XKFKPA3_ilEPcEiE\",\n+                \"hairyfunc(int (* const (X::** (* restrict (* volatile* (Y::*)(int) const)(char*)) [2])(long) const) [3])\");\n \n   return 0;\n }"}]}