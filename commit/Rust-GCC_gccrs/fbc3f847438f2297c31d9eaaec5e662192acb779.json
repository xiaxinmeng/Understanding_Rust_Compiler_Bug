{"sha": "fbc3f847438f2297c31d9eaaec5e662192acb779", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJjM2Y4NDc0MzhmMjI5N2MzMWQ5ZWFhZWM1ZTY2MjE5MmFjYjc3OQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-03T13:08:18Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-03T13:16:31Z"}, "message": "c++: rtti cleanups\n\nHere are a few cleanups from the modules branch.  Generally some RAII,\nand a bit of lazy namespace pushing.\n\n\tgcc/cp/\n\t* rtti.c (init_rtti_processing): Move var decl to its init.\n\t(get_tinfo_decl): Likewise.  Break out creation to called helper\n\t...\n\t(get_tinfo_decl_direct): ... here.\n\t(build_dynamic_cast_1): Move var decls to their initializers.\n\t(tinfo_base_init): Set decl's location to BUILTINS_LOCATION.\n\t(get_tinfo_desc): Only push ABI namespace when needed.  Set type's\n\tcontext.", "tree": {"sha": "4606279cbb1dc8de0467634e9bf7af68a6288343", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4606279cbb1dc8de0467634e9bf7af68a6288343"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbc3f847438f2297c31d9eaaec5e662192acb779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc3f847438f2297c31d9eaaec5e662192acb779", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbc3f847438f2297c31d9eaaec5e662192acb779", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc3f847438f2297c31d9eaaec5e662192acb779/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "918e8b10a716ec720215afafb7baa1b9b75e4fa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/918e8b10a716ec720215afafb7baa1b9b75e4fa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/918e8b10a716ec720215afafb7baa1b9b75e4fa1"}], "stats": {"total": 88, "additions": 48, "deletions": 40}, "files": [{"sha": "887aae31bf641f1dffc12caedc41aa1c94124735", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 48, "deletions": 40, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc3f847438f2297c31d9eaaec5e662192acb779/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc3f847438f2297c31d9eaaec5e662192acb779/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=fbc3f847438f2297c31d9eaaec5e662192acb779", "patch": "@@ -123,6 +123,7 @@ static GTY (()) vec<tinfo_s, va_gc> *tinfo_descs;\n \n static tree ifnonnull (tree, tree, tsubst_flags_t);\n static tree tinfo_name (tree, bool);\n+static tree get_tinfo_decl_direct (tree type, tree name, int pseudo_ix);\n static tree build_dynamic_cast_1 (location_t, tree, tree, tsubst_flags_t);\n static tree throw_bad_cast (void);\n static tree throw_bad_typeid (void);\n@@ -166,10 +167,8 @@ pop_abi_namespace (void)\n void\n init_rtti_processing (void)\n {\n-  tree type_info_type;\n-\n   push_nested_namespace (std_node);\n-  type_info_type = xref_tag (class_type, get_identifier (\"type_info\"));\n+  tree type_info_type = xref_tag (class_type, get_identifier (\"type_info\"));\n   pop_nested_namespace (std_node);\n   const_type_info_type_node\n     = cp_build_qualified_type (type_info_type, TYPE_QUAL_CONST);\n@@ -414,9 +413,6 @@ tinfo_name (tree type, bool mark_private)\n tree\n get_tinfo_decl (tree type)\n {\n-  tree name;\n-  tree d;\n-\n   if (variably_modified_type_p (type, /*fn=*/NULL_TREE))\n     {\n       error (\"cannot create type information for type %qT because \"\n@@ -429,25 +425,41 @@ get_tinfo_decl (tree type)\n     type = build_function_type (TREE_TYPE (type),\n \t\t\t\tTREE_CHAIN (TYPE_ARG_TYPES (type)));\n \n-  type = complete_type (type);\n+  return get_tinfo_decl_direct (type, NULL, -1);\n+}\n \n+/* Get or create a tinfo VAR_DECL directly from the provided information.\n+   The caller must have already checked it is valid to do so.  */\n+\n+static tree\n+get_tinfo_decl_direct (tree type, tree name, int pseudo_ix)\n+{\n   /* For a class type, the variable is cached in the type node\n      itself.  */\n+  tree d = NULL_TREE;\n+\n+  gcc_checking_assert (TREE_CODE (type) != METHOD_TYPE);\n+\n+  if (pseudo_ix < 0)\n+    type = complete_type (type);\n+\n   if (CLASS_TYPE_P (type))\n-    {\n-      d = CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (type));\n-      if (d)\n-\treturn d;\n-    }\n+    d = CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (type));\n+\n+  if (!name)\n+    name = mangle_typeinfo_for_type (type);\n \n-  name = mangle_typeinfo_for_type (type);\n+  if (!CLASS_TYPE_P (type))\n+    d = get_global_binding (name);\n \n-  d = get_global_binding (name);\n   if (!d)\n     {\n-      int ix = get_pseudo_ti_index (type);\n-      const tinfo_s *ti = get_tinfo_desc (ix);\n-      \n+      /* Create it.  */\n+      if (pseudo_ix < 0)\n+\tpseudo_ix = get_pseudo_ti_index (type);\n+\n+      const tinfo_s *ti = get_tinfo_desc (pseudo_ix);\n+\n       d = build_lang_decl (VAR_DECL, name, ti->type);\n       SET_DECL_ASSEMBLER_NAME (d, name);\n       /* Remember the type it is for.  */\n@@ -754,23 +766,21 @@ build_dynamic_cast_1 (location_t loc, tree type, tree expr,\n \t  dcast_fn = dynamic_cast_node;\n \t  if (!dcast_fn)\n \t    {\n-\t      tree tmp;\n-\t      tree tinfo_ptr;\n-\t      const char *name;\n-\n \t      push_abi_namespace ();\n-\t      tinfo_ptr = xref_tag (class_type,\n-\t\t\t\t    get_identifier (\"__class_type_info\"));\n-\t      tinfo_ptr = build_pointer_type\n-\t\t(cp_build_qualified_type\n-\t\t (tinfo_ptr, TYPE_QUAL_CONST));\n-\t      name = \"__dynamic_cast\";\n-\t      tmp = build_function_type_list (ptr_type_node,\n-\t\t\t\t\t      const_ptr_type_node,\n-\t\t\t\t\t      tinfo_ptr, tinfo_ptr,\n-\t\t\t\t\t      ptrdiff_type_node, NULL_TREE);\n-\t      dcast_fn = build_library_fn_ptr (name, tmp,\n-\t\t\t\t\t       ECF_LEAF | ECF_PURE | ECF_NOTHROW);\n+\t      tree tinfo_ptr = xref_tag (class_type,\n+\t\t\t\t\t get_identifier (\"__class_type_info\"));\n+\t      tinfo_ptr = cp_build_qualified_type (tinfo_ptr, TYPE_QUAL_CONST);\n+\t      tinfo_ptr = build_pointer_type (tinfo_ptr);\n+\n+\t      const char *fn_name = \"__dynamic_cast\";\n+\t      /* void *() (void const *, __class_type_info const *,\n+\t\t           __class_type_info const *, ptrdiff_t)  */\n+\t      tree fn_type = (build_function_type_list\n+\t\t\t      (ptr_type_node, const_ptr_type_node,\n+\t\t\t       tinfo_ptr, tinfo_ptr, ptrdiff_type_node,\n+\t\t\t       NULL_TREE));\n+\t      dcast_fn = (build_library_fn_ptr\n+\t\t\t  (fn_name, fn_type, ECF_LEAF | ECF_PURE | ECF_NOTHROW));\n \t      pop_abi_namespace ();\n \t      dynamic_cast_node = dcast_fn;\n \t    }\n@@ -947,6 +957,8 @@ tinfo_base_init (tinfo_s *ti, tree target)\n     {\n       push_abi_namespace ();\n       tree real_type = xref_tag (class_type, ti->name);\n+      tree real_decl = TYPE_NAME (real_type);\n+      DECL_SOURCE_LOCATION (real_decl) = BUILTINS_LOCATION;\n       pop_abi_namespace ();\n \n       if (!COMPLETE_TYPE_P (real_type))\n@@ -1450,8 +1462,6 @@ get_tinfo_desc (unsigned ix)\n       }\n     }\n \n-  push_abi_namespace ();\n-\n   /* Generate the pseudo type name.  */\n   const char *real_name = tinfo_names[ix < TK_VMI_CLASS_TYPES\n \t\t\t\t      ? ix : unsigned (TK_VMI_CLASS_TYPES)];\n@@ -1468,6 +1478,7 @@ get_tinfo_desc (unsigned ix)\n   /* Pass the fields chained in reverse.  */\n   finish_builtin_struct (pseudo_type, pseudo_name, fields, NULL_TREE);\n   CLASSTYPE_AS_BASE (pseudo_type) = pseudo_type;\n+  DECL_CONTEXT (TYPE_NAME (pseudo_type)) = FROB_CONTEXT (global_namespace);\n   xref_basetypes (pseudo_type, /*bases=*/NULL_TREE);\n \n   res->type = cp_build_qualified_type (pseudo_type, TYPE_QUAL_CONST);\n@@ -1477,7 +1488,6 @@ get_tinfo_desc (unsigned ix)\n      internal linkage.  */\n   TREE_PUBLIC (TYPE_MAIN_DECL (res->type)) = 1;\n \n-  pop_abi_namespace ();\n   return res;\n }\n \n@@ -1608,12 +1618,10 @@ emit_support_tinfos (void)\n bool\n emit_tinfo_decl (tree decl)\n {\n-  tree type = TREE_TYPE (DECL_NAME (decl));\n-  int in_library = typeinfo_in_lib_p (type);\n-\n   gcc_assert (DECL_TINFO_P (decl));\n \n-  if (in_library)\n+  tree type = TREE_TYPE (DECL_NAME (decl));\n+  if (typeinfo_in_lib_p (type))\n     {\n       if (doing_runtime)\n \tDECL_EXTERNAL (decl) = 0;"}]}