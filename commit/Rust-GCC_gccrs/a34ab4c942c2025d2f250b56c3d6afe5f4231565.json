{"sha": "a34ab4c942c2025d2f250b56c3d6afe5f4231565", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM0YWI0Yzk0MmMyMDI1ZDJmMjUwYjU2YzNkNmFmZTVmNDIzMTU2NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-01-10T23:05:13Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-01-10T23:05:13Z"}, "message": "expr.c (store_field): In the bitfield case...\n\n\t* expr.c (store_field): In the bitfield case, fetch the return value\n\tfrom the registers before applying a single big-endian adjustment.\n\tAlways do a final load for a BLKmode value not larger than a word.\n\nFrom-SVN: r244299", "tree": {"sha": "e54b6b24677d5899783213375480f5f536e3f812", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e54b6b24677d5899783213375480f5f536e3f812"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a34ab4c942c2025d2f250b56c3d6afe5f4231565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a34ab4c942c2025d2f250b56c3d6afe5f4231565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a34ab4c942c2025d2f250b56c3d6afe5f4231565", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a34ab4c942c2025d2f250b56c3d6afe5f4231565/comments", "author": null, "committer": null, "parents": [{"sha": "664b1a6b290dcf5dc9622a5e0a94196afa765165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/664b1a6b290dcf5dc9622a5e0a94196afa765165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/664b1a6b290dcf5dc9622a5e0a94196afa765165"}], "stats": {"total": 84, "additions": 45, "deletions": 39}, "files": [{"sha": "cc81d79a758f442af89746bd02aadcd81cf51b3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a34ab4c942c2025d2f250b56c3d6afe5f4231565/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a34ab4c942c2025d2f250b56c3d6afe5f4231565/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a34ab4c942c2025d2f250b56c3d6afe5f4231565", "patch": "@@ -1,3 +1,9 @@\n+2017-01-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* expr.c (store_field): In the bitfield case, fetch the return value\n+\tfrom the registers before applying a single big-endian adjustment.\n+\tAlways do a final load for a BLKmode value not larger than a word.\n+\n 2017-01-10  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/77949"}, {"sha": "4c54faf82875426fa4684fed9593a1907377fba9", "filename": "gcc/expr.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a34ab4c942c2025d2f250b56c3d6afe5f4231565/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a34ab4c942c2025d2f250b56c3d6afe5f4231565/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a34ab4c942c2025d2f250b56c3d6afe5f4231565", "patch": "@@ -6832,13 +6832,36 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \n       temp = expand_normal (exp);\n \n-      /* If the value has a record type and an integral mode then, if BITSIZE\n-\t is narrower than this mode and this is for big-endian data, we must\n-\t first put the value into the low-order bits.  Moreover, the field may\n-\t be not aligned on a byte boundary; in this case, if it has reverse\n-\t storage order, it needs to be accessed as a scalar field with reverse\n-\t storage order and we must first put the value into target order.  */\n-      if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n+      /* Handle calls that return values in multiple non-contiguous locations.\n+\t The Irix 6 ABI has examples of this.  */\n+      if (GET_CODE (temp) == PARALLEL)\n+\t{\n+\t  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));\n+\t  machine_mode temp_mode\n+\t    = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);\n+\t  rtx temp_target = gen_reg_rtx (temp_mode);\n+\t  emit_group_store (temp_target, temp, TREE_TYPE (exp), size);\n+\t  temp = temp_target;\n+\t}\n+\n+      /* Handle calls that return BLKmode values in registers.  */\n+      else if (mode == BLKmode && REG_P (temp) && TREE_CODE (exp) == CALL_EXPR)\n+\t{\n+\t  rtx temp_target = gen_reg_rtx (GET_MODE (temp));\n+\t  copy_blkmode_from_reg (temp_target, temp, TREE_TYPE (exp));\n+\t  temp = temp_target;\n+\t}\n+\n+      /* If the value has aggregate type and an integral mode then, if BITSIZE\n+\t is narrower than this mode and this is for big-endian data, we first\n+\t need to put the value into the low-order bits for store_bit_field,\n+\t except when MODE is BLKmode and BITSIZE larger than the word size\n+\t (see the handling of fields larger than a word in store_bit_field).\n+\t Moreover, the field may be not aligned on a byte boundary; in this\n+\t case, if it has reverse storage order, it needs to be accessed as a\n+\t scalar field with reverse storage order and we must first put the\n+\t value into target order.  */\n+      if (AGGREGATE_TYPE_P (TREE_TYPE (exp))\n \t  && GET_MODE_CLASS (GET_MODE (temp)) == MODE_INT)\n \t{\n \t  HOST_WIDE_INT size = GET_MODE_BITSIZE (GET_MODE (temp));\n@@ -6849,7 +6872,8 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t    temp = flip_storage_order (GET_MODE (temp), temp);\n \n \t  if (bitsize < size\n-\t      && reverse ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n+\t      && reverse ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN\n+\t      && !(mode == BLKmode && bitsize > BITS_PER_WORD))\n \t    temp = expand_shift (RSHIFT_EXPR, GET_MODE (temp), temp,\n \t\t\t\t size - bitsize, NULL_RTX, 1);\n \t}\n@@ -6859,12 +6883,10 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t  && mode != TYPE_MODE (TREE_TYPE (exp)))\n \ttemp = convert_modes (mode, TYPE_MODE (TREE_TYPE (exp)), temp, 1);\n \n-      /* If TEMP is not a PARALLEL (see below) and its mode and that of TARGET\n-\t are both BLKmode, both must be in memory and BITPOS must be aligned\n-\t on a byte boundary.  If so, we simply do a block copy.  Likewise for\n-\t a BLKmode-like TARGET.  */\n-      if (GET_CODE (temp) != PARALLEL\n-\t  && GET_MODE (temp) == BLKmode\n+      /* If the mode of TEMP and TARGET is BLKmode, both must be in memory\n+\t and BITPOS must be aligned on a byte boundary.  If so, we simply do\n+\t a block copy.  Likewise for a BLKmode-like TARGET.  */\n+      if (GET_MODE (temp) == BLKmode\n \t  && (GET_MODE (target) == BLKmode\n \t      || (MEM_P (target)\n \t\t  && GET_MODE_CLASS (GET_MODE (target)) == MODE_INT\n@@ -6883,31 +6905,9 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t  return const0_rtx;\n \t}\n \n-      /* Handle calls that return values in multiple non-contiguous locations.\n-\t The Irix 6 ABI has examples of this.  */\n-      if (GET_CODE (temp) == PARALLEL)\n-\t{\n-\t  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));\n-\t  machine_mode temp_mode\n-\t    = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);\n-\t  rtx temp_target = gen_reg_rtx (temp_mode);\n-\t  emit_group_store (temp_target, temp, TREE_TYPE (exp), size);\n-\t  temp = temp_target;\n-\t}\n-\n-      /* Handle calls that return BLKmode values in registers.  */\n-      else if (mode == BLKmode && REG_P (temp) && TREE_CODE (exp) == CALL_EXPR)\n-\t{\n-\t  rtx temp_target = gen_reg_rtx (GET_MODE (temp));\n-\t  copy_blkmode_from_reg (temp_target, temp, TREE_TYPE (exp));\n-\t  temp = temp_target;\n-\t}\n-\n-      /* The behavior of store_bit_field is awkward when mode is BLKmode:\n-\t it always takes its value from the lsb up to the word size but\n-\t expects it left justified beyond it.  At this point TEMP is left\n-\t justified so extract the value in the former case.  */\n-      if (mode == BLKmode && bitsize <= BITS_PER_WORD)\n+      /* If the mode of TEMP is still BLKmode and BITSIZE not larger than the\n+\t word size, we need to load the value (see again store_bit_field).  */\n+      if (GET_MODE (temp) == BLKmode && bitsize <= BITS_PER_WORD)\n \t{\n \t  machine_mode temp_mode = smallest_mode_for_size (bitsize, MODE_INT);\n \t  temp = extract_bit_field (temp, bitsize, 0, 1, NULL_RTX, temp_mode,"}]}