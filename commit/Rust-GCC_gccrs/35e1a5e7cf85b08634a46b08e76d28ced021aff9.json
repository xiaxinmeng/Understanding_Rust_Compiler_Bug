{"sha": "35e1a5e7cf85b08634a46b08e76d28ced021aff9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVlMWE1ZTdjZjg1YjA4NjM0YTQ2YjA4ZTc2ZDI4Y2VkMDIxYWZmOQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2010-06-07T09:12:32Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2010-06-07T09:12:32Z"}, "message": "tm.texi (TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST): Update documentation.\n\n\n\t* doc/tm.texi (TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST): Update\n\tdocumentation.\n\t* targhooks.c (default_builtin_vectorization_cost): New function.\n\t* targhooks.h (default_builtin_vectorization_cost): Declare.\n\t* target.h (enum vect_cost_for_stmt): Define.\n\t(builtin_vectorization_cost): Change argument and comment.\n\t* tree-vectorizer.h: Remove cost model macros.\n\t* tree-vect-loop.c: Include target.h.\n\t(vect_get_cost): New function.\n\t(vect_estimate_min_profitable_iters): Replace cost model macros with\n\tcalls to vect_get_cost.\n\t(vect_model_reduction_cost, vect_model_induction_cost): Likewise.\n\t* target-def.h (TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST): Add\n\tdefault implementation.\n\t* tree-vect-stmts.c (cost_for_stmt): Replace cost model macros with\n\tcalls to target hook builtin_vectorization_cost.\n\t(vect_model_simple_cost, vect_model_store_cost, vect_model_load_cost):\n\tLikewise.\n\t* Makefile.in (tree-vect-loop.o): Add dependency on TARGET_H.\n\t* config/spu/spu.c (spu_builtin_vectorization_cost): Replace with new\n\timplementation to return costs.\n\t* config/i386/i386.c (ix86_builtin_vectorization_cost): Likewise.\n\t* config/spu/spu.h: Remove vectorizer cost model macros.\n\t* config/i386/i386.h: Likewise.\n\t* tree-vect-slp.c (vect_build_slp_tree): Replace cost model macro with\n\ta call to target hook builtin_vectorization_cost.\n\nFrom-SVN: r160360", "tree": {"sha": "8795ce881dcce2d97198c58aa7cb9c8a103a4f24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8795ce881dcce2d97198c58aa7cb9c8a103a4f24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35e1a5e7cf85b08634a46b08e76d28ced021aff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e1a5e7cf85b08634a46b08e76d28ced021aff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35e1a5e7cf85b08634a46b08e76d28ced021aff9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e1a5e7cf85b08634a46b08e76d28ced021aff9/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "81c566c2fa32ad31b8b22f7ada161778150e51d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81c566c2fa32ad31b8b22f7ada161778150e51d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81c566c2fa32ad31b8b22f7ada161778150e51d1"}], "stats": {"total": 458, "additions": 221, "deletions": 237}, "files": [{"sha": "550bb7049843c58813e9b7b51e058504eb9861c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -1,3 +1,32 @@\n+2010-06-07  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* doc/tm.texi (TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST): Update\n+\tdocumentation.\n+\t* targhooks.c (default_builtin_vectorization_cost): New function.\n+\t* targhooks.h (default_builtin_vectorization_cost): Declare.\n+\t* target.h (enum vect_cost_for_stmt): Define.\n+\t(builtin_vectorization_cost): Change argument and comment.\n+\t* tree-vectorizer.h: Remove cost model macros.\n+\t* tree-vect-loop.c: Include target.h.\n+\t(vect_get_cost): New function.\n+\t(vect_estimate_min_profitable_iters): Replace cost model macros with\n+\tcalls to vect_get_cost.\n+\t(vect_model_reduction_cost, vect_model_induction_cost): Likewise.\n+\t* target-def.h (TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST): Add\n+\tdefault implementation.\n+\t* tree-vect-stmts.c (cost_for_stmt): Replace cost model macros with\n+\tcalls to target hook builtin_vectorization_cost.\n+\t(vect_model_simple_cost, vect_model_store_cost, vect_model_load_cost):\n+\tLikewise.\n+\t* Makefile.in (tree-vect-loop.o): Add dependency on TARGET_H.\n+\t* config/spu/spu.c (spu_builtin_vectorization_cost): Replace with new\n+\timplementation to return costs.\n+\t* config/i386/i386.c (ix86_builtin_vectorization_cost): Likewise.\n+\t* config/spu/spu.h: Remove vectorizer cost model macros.\n+\t* config/i386/i386.h: Likewise.\n+\t* tree-vect-slp.c (vect_build_slp_tree): Replace cost model macro with\n+\ta call to target hook builtin_vectorization_cost.\n+\n 2010-06-06  Sriraman Tallam  <tmsriram@google.com>\n \n \tPR target/44319"}, {"sha": "fed7fe8d498c848fb76e8f0e8d81175ba5627898", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -2704,7 +2704,7 @@ tree-vect-loop.o: tree-vect-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) \\\n    $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) $(EXPR_H) $(RECOG_H) $(OPTABS_H) \\\n    $(TOPLEV_H) $(SCEV_H) $(TREE_VECTORIZER_H) tree-pretty-print.h \\\n-   gimple-pretty-print.h\n+   gimple-pretty-print.h $(TARGET_H)\n tree-vect-loop-manip.o: tree-vect-loop-manip.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) $(EXPR_H) $(TOPLEV_H) \\"}, {"sha": "407238fd430565763d2246d101c43da6d1ba320f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -29296,28 +29296,52 @@ static const struct attribute_spec ix86_attribute_table[] =\n \n /* Implement targetm.vectorize.builtin_vectorization_cost.  */\n static int\n-ix86_builtin_vectorization_cost (bool runtime_test)\n+ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost)\n {\n-  /* If the branch of the runtime test is taken - i.e. - the vectorized\n-     version is skipped - this incurs a misprediction cost (because the\n-     vectorized version is expected to be the fall-through).  So we subtract\n-     the latency of a mispredicted branch from the costs that are incured\n-     when the vectorized version is executed.\n+  switch (type_of_cost)\n+    {\n+      case scalar_stmt:\n+        return ix86_cost->scalar_stmt_cost;\n \n-     TODO: The values in individual target tables have to be tuned or new\n-     fields may be needed. For eg. on K8, the default branch path is the\n-     not-taken path. If the taken path is predicted correctly, the minimum\n-     penalty of going down the taken-path is 1 cycle. If the taken-path is\n-     not predicted correctly, then the minimum penalty is 10 cycles.  */\n+      case scalar_load:\n+        return ix86_cost->scalar_load_cost;\n \n-  if (runtime_test)\n-    {\n-      return (-(ix86_cost->cond_taken_branch_cost));\n+      case scalar_store:\n+        return ix86_cost->scalar_store_cost;\n+\n+      case vector_stmt:\n+        return ix86_cost->vec_stmt_cost;\n+\n+      case vector_load:\n+        return ix86_cost->vec_align_load_cost;\n+\n+      case vector_store:\n+        return ix86_cost->vec_store_cost;\n+\n+      case vec_to_scalar:\n+        return ix86_cost->vec_to_scalar_cost;\n+\n+      case scalar_to_vec:\n+        return ix86_cost->scalar_to_vec_cost;\n+\n+      case unaligned_load:\n+        return ix86_cost->vec_unalign_load_cost;\n+\n+      case cond_branch_taken:\n+        return ix86_cost->cond_taken_branch_cost;\n+\n+      case cond_branch_not_taken:\n+        return ix86_cost->cond_not_taken_branch_cost;\n+\n+      case vec_perm:\n+        return 1;\n+\n+      default:\n+        gcc_unreachable ();\n     }\n-  else\n-    return 0;\n }\n \n+\n /* Implement targetm.vectorize.builtin_vec_perm.  */\n \n static tree"}, {"sha": "226f7849829bcd476db0183c45c72882a9814d8d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -2420,57 +2420,6 @@ struct GTY(()) machine_function {\n #define SYMBOL_REF_DLLEXPORT_P(X) \\\n \t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_DLLEXPORT) != 0)\n \n-/* Model costs for vectorizer.  */\n-\n-/* Cost of conditional branch.  */\n-#undef TARG_COND_BRANCH_COST\n-#define TARG_COND_BRANCH_COST           ix86_cost->branch_cost\n-\n-/* Cost of any scalar operation, excluding load and store.  */\n-#undef TARG_SCALAR_STMT_COST\n-#define TARG_SCALAR_STMT_COST           ix86_cost->scalar_stmt_cost\n-\n-/* Cost of scalar load.  */\n-#undef TARG_SCALAR_LOAD_COST\n-#define TARG_SCALAR_LOAD_COST           ix86_cost->scalar_load_cost\n-\n-/* Cost of scalar store.  */\n-#undef TARG_SCALAR_STORE_COST\n-#define TARG_SCALAR_STORE_COST          ix86_cost->scalar_store_cost\n-\n-/* Cost of any vector operation, excluding load, store or vector to scalar\n-   operation.  */\n-#undef TARG_VEC_STMT_COST\n-#define TARG_VEC_STMT_COST              ix86_cost->vec_stmt_cost\n-\n-/* Cost of vector to scalar operation.  */\n-#undef TARG_VEC_TO_SCALAR_COST\n-#define TARG_VEC_TO_SCALAR_COST         ix86_cost->vec_to_scalar_cost\n-\n-/* Cost of scalar to vector operation.  */\n-#undef TARG_SCALAR_TO_VEC_COST\n-#define TARG_SCALAR_TO_VEC_COST         ix86_cost->scalar_to_vec_cost\n-\n-/* Cost of aligned vector load.  */\n-#undef TARG_VEC_LOAD_COST\n-#define TARG_VEC_LOAD_COST              ix86_cost->vec_align_load_cost\n-\n-/* Cost of misaligned vector load.  */\n-#undef TARG_VEC_UNALIGNED_LOAD_COST\n-#define TARG_VEC_UNALIGNED_LOAD_COST    ix86_cost->vec_unalign_load_cost\n-\n-/* Cost of vector store.  */\n-#undef TARG_VEC_STORE_COST\n-#define TARG_VEC_STORE_COST             ix86_cost->vec_store_cost\n-\n-/* Cost of conditional taken branch for vectorizer cost model.  */\n-#undef TARG_COND_TAKEN_BRANCH_COST\n-#define TARG_COND_TAKEN_BRANCH_COST     ix86_cost->cond_taken_branch_cost\n-\n-/* Cost of conditional not taken branch for vectorizer cost model.  */\n-#undef TARG_COND_NOT_TAKEN_BRANCH_COST\n-#define TARG_COND_NOT_TAKEN_BRANCH_COST ix86_cost->cond_not_taken_branch_cost\n-\n /*\n Local variables:\n version-control: t"}, {"sha": "f8dd30517823510404c78d8de15eea851ec37c07", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -209,7 +209,7 @@ static rtx spu_addr_space_legitimize_address (rtx, rtx, enum machine_mode,\n static tree spu_builtin_mul_widen_even (tree);\n static tree spu_builtin_mul_widen_odd (tree);\n static tree spu_builtin_mask_for_load (void);\n-static int spu_builtin_vectorization_cost (bool);\n+static int spu_builtin_vectorization_cost (enum vect_cost_for_stmt);\n static bool spu_vector_alignment_reachable (const_tree, bool);\n static tree spu_builtin_vec_perm (tree, tree *);\n static enum machine_mode spu_addr_space_pointer_mode (addr_space_t);\n@@ -6695,17 +6695,36 @@ spu_builtin_mask_for_load (void)\n \n /* Implement targetm.vectorize.builtin_vectorization_cost.  */\n static int \n-spu_builtin_vectorization_cost (bool runtime_test)\n-{\n-  /* If the branch of the runtime test is taken - i.e. - the vectorized\n-     version is skipped - this incurs a misprediction cost (because the\n-     vectorized version is expected to be the fall-through).  So we subtract\n-     the latency of a mispredicted branch from the costs that are incurred\n-     when the vectorized version is executed.  */\n-  if (runtime_test)\n-    return -19;\n-  else\n-    return 0;\n+spu_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost)\n+{\n+  switch (type_of_cost)\n+    {\n+      case scalar_stmt:\n+      case vector_stmt:\n+      case vector_load:\n+      case vector_store:\n+      case vec_to_scalar:\n+      case scalar_to_vec:\n+      case cond_branch_not_taken:\n+      case vec_perm:\n+        return 1;\n+\n+      case scalar_store:\n+        return 10;\n+\n+      case scalar_load:\n+        /* Load + rotate.  */\n+        return 2;\n+\n+      case unaligned_load:\n+        return 2;\n+\n+      case cond_branch_taken:\n+        return 6;\n+\n+      default:\n+        gcc_unreachable ();\n+    }\n }\n \n /* Return true iff, data reference of TYPE can reach vector alignment (16)"}, {"sha": "54b461235a7b3ab2b91673560151db6ec037f2e1", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -523,57 +523,6 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n #define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n   do { if (LOG!=0) fprintf (FILE, \"\\t.align\\t%d\\n\", (LOG)); } while (0)\n \n-\f\n-/* Model costs for the vectorizer.  */\n-\n-/* Cost of conditional branch.  */\n-#ifndef TARG_COND_BRANCH_COST\n-#define TARG_COND_BRANCH_COST        6\n-#endif\n-\n-/* Cost of any scalar operation, excluding load and store.  */\n-#ifndef TARG_SCALAR_STMT_COST\n-#define TARG_SCALAR_STMT_COST        1\n-#endif\n-\n-/* Cost of scalar load. */\n-#undef TARG_SCALAR_LOAD_COST\n-#define TARG_SCALAR_LOAD_COST        2 /* load + rotate */\n-\n-/* Cost of scalar store.  */\n-#undef TARG_SCALAR_STORE_COST\n-#define TARG_SCALAR_STORE_COST       10\n-\n-/* Cost of any vector operation, excluding load, store,\n-   or vector to scalar operation.  */\n-#undef TARG_VEC_STMT_COST\n-#define TARG_VEC_STMT_COST           1\n-\n-/* Cost of vector to scalar operation.  */\n-#undef TARG_VEC_TO_SCALAR_COST\n-#define TARG_VEC_TO_SCALAR_COST      1\n-\n-/* Cost of scalar to vector operation.  */\n-#undef TARG_SCALAR_TO_VEC_COST\n-#define TARG_SCALAR_TO_VEC_COST      1\n-\n-/* Cost of aligned vector load.  */\n-#undef TARG_VEC_LOAD_COST\n-#define TARG_VEC_LOAD_COST           1\n-\n-/* Cost of misaligned vector load.  */\n-#undef TARG_VEC_UNALIGNED_LOAD_COST\n-#define TARG_VEC_UNALIGNED_LOAD_COST 2\n-\n-/* Cost of vector store.  */\n-#undef TARG_VEC_STORE_COST\n-#define TARG_VEC_STORE_COST          1\n-\n-/* Cost of vector permutation.  */\n-#ifndef TARG_VEC_PERMUTE_COST\n-#define TARG_VEC_PERMUTE_COST        1 \n-#endif\n-\n \f\n /* Misc */\n "}, {"sha": "34f94c6e29d36acc17c5ce6609be292cd7e0e8c2", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -5742,9 +5742,8 @@ preserved (e.g.@: used only by a reduction computation). Otherwise, the\n @code{widen_mult_hi/lo} idioms will be used.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST (bool @var{runtime_test})\n-Returns the cost to be added to the overhead involved with executing \n-the vectorized version of a loop.\n+@deftypefn {Target Hook} int TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST (enum vect_cost_for_stmt @var{type_of_cost})\n+Returns cost of different scalar or vector statements for vectorization cost model.\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE (const_tree @var{type}, bool @var{is_packed})"}, {"sha": "91120bae535f1917a41bb492d65ddd73e260a7a6", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -417,7 +417,8 @@\n   default_builtin_vectorized_conversion\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN 0\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD 0\n-#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST 0\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST \\\n+  default_builtin_vectorization_cost\n #define TARGET_VECTOR_ALIGNMENT_REACHABLE \\\n   default_builtin_vector_alignment_reachable\n #define TARGET_VECTORIZE_BUILTIN_VEC_PERM 0"}, {"sha": "e209cfe74047bf8ca4b830a3496728cf99c8f216", "filename": "gcc/target.h", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -110,6 +110,23 @@ struct asm_int_op\n   const char *ti;\n };\n \n+/* Types of costs for vectorizer cost model.  */\n+enum vect_cost_for_stmt\n+{\n+  scalar_stmt,\n+  scalar_load,\n+  scalar_store,\n+  vector_stmt,\n+  vector_load,\n+  unaligned_load,\n+  vector_store,\n+  vec_to_scalar,\n+  scalar_to_vec,\n+  cond_branch_not_taken,\n+  cond_branch_taken,\n+  vec_perm\n+};\n+\n /* The target structure.  This holds all the backend hooks.  */\n \n struct gcc_target\n@@ -505,9 +522,9 @@ struct gcc_target\n     tree (* builtin_mul_widen_even) (tree);\n     tree (* builtin_mul_widen_odd) (tree);\n \n-    /* Returns the cost to be added to the overheads involved with\n-       executing the vectorized version of a loop.  */\n-    int (*builtin_vectorization_cost) (bool);\n+    /* Cost of different vector/scalar statements in vectorization cost\n+       model.  */ \n+    int (* builtin_vectorization_cost) (enum vect_cost_for_stmt);\n \n     /* Return true if vector alignment is reachable (by peeling N\n        iterations) for the given type.  */"}, {"sha": "821b83f9d23078fa0fe508a5c91dae1d0f09a991", "filename": "gcc/targhooks.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -476,6 +476,36 @@ default_builtin_vectorized_conversion (unsigned int code ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n+/* Default vectorizer cost model values.  */\n+\n+int\n+default_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost)\n+{\n+  switch (type_of_cost)\n+    {\n+      case scalar_stmt:\n+      case scalar_load:\n+      case scalar_store:\n+      case vector_stmt:\n+      case vector_load:\n+      case vector_store:\n+      case vec_to_scalar:\n+      case scalar_to_vec:\n+      case cond_branch_not_taken:\n+      case vec_perm:\n+        return 1;\n+\n+      case unaligned_load:\n+        return 2;\n+\n+      case cond_branch_taken:\n+        return 3;\n+\n+      default:\n+        gcc_unreachable ();\n+    }\n+}\n+\n /* Reciprocal.  */\n \n tree"}, {"sha": "6e7144516868a5a46355c69c9d83a630073a648a", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -77,6 +77,8 @@ extern tree default_builtin_vectorized_function (tree, tree, tree);\n \n extern tree default_builtin_vectorized_conversion (unsigned int, tree, tree);\n \n+extern int default_builtin_vectorization_cost (enum vect_cost_for_stmt);\n+\n extern tree default_builtin_reciprocal (unsigned int, bool, bool);\n \n extern bool default_builtin_vector_alignment_reachable (const_tree, bool);"}, {"sha": "ccddab3b33643b3cec5cde725fc7cc9dcbd4d1da", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-chrec.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-vectorizer.h\"\n+#include \"target.h\"\n \n /* Loop Vectorization Pass.\n \n@@ -1116,6 +1117,15 @@ vect_analyze_loop_form (struct loop *loop)\n }\n \n \n+/* Get cost by calling cost target builtin.  */\n+\n+static inline \n+int vect_get_cost (enum vect_cost_for_stmt type_of_cost)\n+{\n+  return targetm.vectorize.builtin_vectorization_cost (type_of_cost); \n+}\n+\n+ \n /* Function vect_analyze_loop_operations.\n \n    Scan the loop stmts and make sure they are all vectorizable.  */\n@@ -2056,7 +2066,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n       || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n-    vec_outside_cost += TARG_COND_TAKEN_BRANCH_COST;\n+    vec_outside_cost += vect_get_cost (cond_branch_taken); \n \n   /* Count statements in scalar loop.  Using this as scalar cost for a single\n      iteration for now.\n@@ -2125,8 +2135,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n          branch per peeled loop. Even if scalar loop iterations are known,\n          vector iterations are not known since peeled prologue iterations are\n          not known. Hence guards remain the same.  */\n-      peel_guard_costs +=  2 * (TARG_COND_TAKEN_BRANCH_COST\n-                              + TARG_COND_NOT_TAKEN_BRANCH_COST);\n+      peel_guard_costs +=  2 * (vect_get_cost (cond_branch_taken)\n+                                + vect_get_cost (cond_branch_not_taken));\n     }\n   else\n     {\n@@ -2152,8 +2162,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n \t  /* If peeled iterations are known but number of scalar loop\n \t     iterations are unknown, count a taken branch per peeled loop.  */\n-\t  peel_guard_costs +=  2 * TARG_COND_TAKEN_BRANCH_COST;\n-\n+\t  peel_guard_costs +=  2 * vect_get_cost (cond_branch_taken); \n         }\n       else\n \t{\n@@ -2228,16 +2237,16 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n       /* Cost model check occurs at versioning.  */\n       if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n           || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n-\tscalar_outside_cost += TARG_COND_NOT_TAKEN_BRANCH_COST;\n+\tscalar_outside_cost += vect_get_cost (cond_branch_not_taken);\n       else\n \t{\n \t  /* Cost model check occurs at prologue generation.  */\n \t  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) < 0)\n-\t    scalar_outside_cost += 2 * TARG_COND_TAKEN_BRANCH_COST\n-\t      + TARG_COND_NOT_TAKEN_BRANCH_COST;\n+\t    scalar_outside_cost += 2 * vect_get_cost (cond_branch_taken)\n+                                   + vect_get_cost (cond_branch_not_taken); \n \t  /* Cost model check occurs at epilogue generation.  */\n \t  else\n-\t    scalar_outside_cost += 2 * TARG_COND_TAKEN_BRANCH_COST;\n+\t    scalar_outside_cost += 2 * vect_get_cost (cond_branch_taken); \n \t}\n     }\n \n@@ -2347,7 +2356,8 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \n \n   /* Cost of reduction op inside loop.  */\n-  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) += ncopies * TARG_VEC_STMT_COST;\n+  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) \n+    += ncopies * vect_get_cost (vector_stmt);\n \n   stmt = STMT_VINFO_STMT (stmt_info);\n \n@@ -2387,7 +2397,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   code = gimple_assign_rhs_code (orig_stmt);\n \n   /* Add in cost for initial definition.  */\n-  outer_cost += TARG_SCALAR_TO_VEC_COST;\n+  outer_cost += vect_get_cost (scalar_to_vec);\n \n   /* Determine cost of epilogue code.\n \n@@ -2397,7 +2407,8 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   if (!nested_in_vect_loop_p (loop, orig_stmt))\n     {\n       if (reduc_code != ERROR_MARK)\n-\touter_cost += TARG_VEC_STMT_COST + TARG_VEC_TO_SCALAR_COST;\n+\touter_cost += vect_get_cost (vector_stmt) \n+                      + vect_get_cost (vec_to_scalar); \n       else\n \t{\n \t  int vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n@@ -2414,12 +2425,14 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \t      && optab_handler (vec_shr_optab, mode)->insn_code != CODE_FOR_nothing)\n \t    /* Final reduction via vector shifts and the reduction operator. Also\n \t       requires scalar extract.  */\n-\t    outer_cost += ((exact_log2(nelements) * 2) * TARG_VEC_STMT_COST\n-\t\t\t\t+ TARG_VEC_TO_SCALAR_COST);\n+\t    outer_cost += ((exact_log2(nelements) * 2) \n+              * vect_get_cost (vector_stmt) \n+  \t      + vect_get_cost (vec_to_scalar));\n \t  else\n \t    /* Use extracts and reduction op for final reduction.  For N elements,\n                we have N extracts and N-1 reduction ops.  */\n-\t    outer_cost += ((nelements + nelements - 1) * TARG_VEC_STMT_COST);\n+\t    outer_cost += ((nelements + nelements - 1) \n+              * vect_get_cost (vector_stmt));\n \t}\n     }\n \n@@ -2442,9 +2455,11 @@ static void\n vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n {\n   /* loop cost for vec_loop.  */\n-  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = ncopies * TARG_VEC_STMT_COST;\n+  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) \n+    = ncopies * vect_get_cost (vector_stmt);\n   /* prologue cost for vec_init and vec_step.  */\n-  STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = 2 * TARG_SCALAR_TO_VEC_COST;\n+  STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info)  \n+    = 2 * vect_get_cost (scalar_to_vec);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_induction_cost: inside_cost = %d, \""}, {"sha": "41c01b977093c8b2aed838db3dbad99c6eea5ae5", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -645,7 +645,9 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       if (permutation)\n         {\n           VEC_safe_push (slp_tree, heap, *loads, *node);\n-          *inside_cost += TARG_VEC_PERMUTE_COST * group_size;\n+          *inside_cost \n+            += targetm.vectorize.builtin_vectorization_cost (vec_perm) \n+               * group_size;\n         }\n \n       return true;"}, {"sha": "eded879eb38ecc97a63131be6f88f3b2bd28af00", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -553,9 +553,9 @@ cost_for_stmt (gimple stmt)\n   switch (STMT_VINFO_TYPE (stmt_info))\n   {\n   case load_vec_info_type:\n-    return TARG_SCALAR_LOAD_COST;\n+    return targetm.vectorize.builtin_vectorization_cost (scalar_load);\n   case store_vec_info_type:\n-    return TARG_SCALAR_STORE_COST;\n+    return targetm.vectorize.builtin_vectorization_cost (scalar_store);\n   case op_vec_info_type:\n   case condition_vec_info_type:\n   case assignment_vec_info_type:\n@@ -565,7 +565,7 @@ cost_for_stmt (gimple stmt)\n   case type_demotion_vec_info_type:\n   case type_conversion_vec_info_type:\n   case call_vec_info_type:\n-    return TARG_SCALAR_STMT_COST;\n+    return targetm.vectorize.builtin_vectorization_cost (scalar_stmt);\n   case undef_vec_info_type:\n   default:\n     gcc_unreachable ();\n@@ -589,13 +589,15 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n   if (PURE_SLP_STMT (stmt_info))\n     return;\n \n-  inside_cost = ncopies * TARG_VEC_STMT_COST;\n+  inside_cost = ncopies \n+    * targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n \n   /* FORNOW: Assuming maximum 2 args per stmts.  */\n   for (i = 0; i < 2; i++)\n     {\n       if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n-\toutside_cost += TARG_SCALAR_TO_VEC_COST;\n+\toutside_cost \n+          += targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n     }\n \n   if (vect_print_dump_info (REPORT_COST))\n@@ -643,7 +645,8 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n     return;\n \n   if (dt == vect_constant_def || dt == vect_external_def)\n-    outside_cost = TARG_SCALAR_TO_VEC_COST;\n+    outside_cost \n+      = targetm.vectorize.builtin_vectorization_cost (scalar_to_vec);\n \n   /* Strided access?  */\n   if (DR_GROUP_FIRST_DR (stmt_info) && !slp_node)\n@@ -658,7 +661,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n     {\n       /* Uses a high and low interleave operation for each needed permute.  */\n       inside_cost = ncopies * exact_log2(group_size) * group_size\n-             * TARG_VEC_STMT_COST;\n+             * targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n \n       if (vect_print_dump_info (REPORT_COST))\n         fprintf (vect_dump, \"vect_model_store_cost: strided group_size = %d .\",\n@@ -667,7 +670,8 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n     }\n \n   /* Costs of the stores.  */\n-  inside_cost += ncopies * TARG_VEC_STORE_COST;\n+  inside_cost += ncopies \n+    * targetm.vectorize.builtin_vectorization_cost (vector_store);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_store_cost: inside_cost = %d, \"\n@@ -722,7 +726,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n     {\n       /* Uses an even and odd extract operations for each needed permute.  */\n       inside_cost = ncopies * exact_log2(group_size) * group_size\n-\t* TARG_VEC_STMT_COST;\n+\t* targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n \n       if (vect_print_dump_info (REPORT_COST))\n         fprintf (vect_dump, \"vect_model_load_cost: strided group_size = %d .\",\n@@ -735,7 +739,8 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n     {\n     case dr_aligned:\n       {\n-        inside_cost += ncopies * TARG_VEC_LOAD_COST;\n+        inside_cost += ncopies \n+          * targetm.vectorize.builtin_vectorization_cost (vector_load);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_load_cost: aligned.\");\n@@ -745,7 +750,8 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n     case dr_unaligned_supported:\n       {\n         /* Here, we assign an additional cost for the unaligned load.  */\n-        inside_cost += ncopies * TARG_VEC_UNALIGNED_LOAD_COST;\n+        inside_cost += ncopies \n+        * targetm.vectorize.builtin_vectorization_cost (unaligned_load);\n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_load_cost: unaligned supported by \"\n@@ -755,13 +761,16 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n       }\n     case dr_explicit_realign:\n       {\n-        inside_cost += ncopies * (2*TARG_VEC_LOAD_COST + TARG_VEC_STMT_COST);\n+        inside_cost += ncopies * (2 \n+         * targetm.vectorize.builtin_vectorization_cost (vector_load) \n+           + targetm.vectorize.builtin_vectorization_cost (vector_stmt));\n \n         /* FIXME: If the misalignment remains fixed across the iterations of\n            the containing loop, the following cost should be added to the\n            outside costs.  */\n         if (targetm.vectorize.builtin_mask_for_load)\n-          inside_cost += TARG_VEC_STMT_COST;\n+          inside_cost \n+            += targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n \n         break;\n       }\n@@ -780,13 +789,16 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n \n         if ((!DR_GROUP_FIRST_DR (stmt_info)) || group_size > 1 || slp_node)\n           {\n-            outside_cost = 2*TARG_VEC_STMT_COST;\n+            outside_cost = 2 \n+              * targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n             if (targetm.vectorize.builtin_mask_for_load)\n-              outside_cost += TARG_VEC_STMT_COST;\n+              outside_cost \n+                += targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n           }\n \n-        inside_cost += ncopies * (TARG_VEC_LOAD_COST + TARG_VEC_STMT_COST);\n-\n+        inside_cost += ncopies \n+          * (targetm.vectorize.builtin_vectorization_cost (vector_load)\n+             + targetm.vectorize.builtin_vectorization_cost (vector_stmt));\n         break;\n       }\n "}, {"sha": "11795d88632f34e87486e752e048c99b18800400", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e1a5e7cf85b08634a46b08e76d28ced021aff9/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=35e1a5e7cf85b08634a46b08e76d28ced021aff9", "patch": "@@ -543,70 +543,6 @@ typedef struct _stmt_vec_info {\n #define PURE_SLP_STMT(S)                  ((S)->slp_type == pure_slp)\n #define STMT_SLP_TYPE(S)                   (S)->slp_type\n \n-/* These are some defines for the initial implementation of the vectorizer's\n-   cost model.  These will later be target specific hooks.  */\n-\n-/* Cost of conditional taken branch.  */\n-#ifndef TARG_COND_TAKEN_BRANCH_COST\n-#define TARG_COND_TAKEN_BRANCH_COST        3\n-#endif\n-\n-/* Cost of conditional not taken branch.  */\n-#ifndef TARG_COND_NOT_TAKEN_BRANCH_COST\n-#define TARG_COND_NOT_TAKEN_BRANCH_COST        1\n-#endif\n-\n-/* Cost of any scalar operation, excluding load and store.  */\n-#ifndef TARG_SCALAR_STMT_COST\n-#define TARG_SCALAR_STMT_COST           1\n-#endif\n-\n-/* Cost of scalar load.  */\n-#ifndef TARG_SCALAR_LOAD_COST\n-#define TARG_SCALAR_LOAD_COST           1\n-#endif\n-\n-/* Cost of scalar store.  */\n-#ifndef TARG_SCALAR_STORE_COST\n-#define TARG_SCALAR_STORE_COST           1\n-#endif\n-\n-/* Cost of any vector operation, excluding load, store or vector to scalar\n-   operation.  */\n-#ifndef TARG_VEC_STMT_COST\n-#define TARG_VEC_STMT_COST           1\n-#endif\n-\n-/* Cost of vector to scalar operation.  */\n-#ifndef TARG_VEC_TO_SCALAR_COST\n-#define TARG_VEC_TO_SCALAR_COST      1\n-#endif\n-\n-/* Cost of scalar to vector operation.  */\n-#ifndef TARG_SCALAR_TO_VEC_COST\n-#define TARG_SCALAR_TO_VEC_COST      1\n-#endif\n-\n-/* Cost of aligned vector load.  */\n-#ifndef TARG_VEC_LOAD_COST\n-#define TARG_VEC_LOAD_COST           1\n-#endif\n-\n-/* Cost of misaligned vector load.  */\n-#ifndef TARG_VEC_UNALIGNED_LOAD_COST\n-#define TARG_VEC_UNALIGNED_LOAD_COST 2\n-#endif\n-\n-/* Cost of vector store.  */\n-#ifndef TARG_VEC_STORE_COST\n-#define TARG_VEC_STORE_COST          1\n-#endif\n-\n-/* Cost of vector permutation.  */\n-#ifndef TARG_VEC_PERMUTE_COST\n-#define TARG_VEC_PERMUTE_COST          1\n-#endif\n-\n /* The maximum number of intermediate steps required in multi-step type\n    conversion.  */\n #define MAX_INTERM_CVT_STEPS         3"}]}