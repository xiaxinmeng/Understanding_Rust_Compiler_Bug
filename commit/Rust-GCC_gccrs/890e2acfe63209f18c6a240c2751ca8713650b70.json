{"sha": "890e2acfe63209f18c6a240c2751ca8713650b70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkwZTJhY2ZlNjMyMDlmMThjNmEyNDBjMjc1MWNhODcxMzY1MGI3MA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-11-30T18:38:35Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-11-30T18:38:35Z"}, "message": "Initial revision\n\nFrom-SVN: r10644", "tree": {"sha": "9d9eb18ba81edc71a2a4c6c06fc8185db92065d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d9eb18ba81edc71a2a4c6c06fc8185db92065d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/890e2acfe63209f18c6a240c2751ca8713650b70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/890e2acfe63209f18c6a240c2751ca8713650b70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/890e2acfe63209f18c6a240c2751ca8713650b70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/890e2acfe63209f18c6a240c2751ca8713650b70/comments", "author": null, "committer": null, "parents": [{"sha": "9e19701e69491cec96e0212856280f65a0d5eea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e19701e69491cec96e0212856280f65a0d5eea8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e19701e69491cec96e0212856280f65a0d5eea8"}], "stats": {"total": 274, "additions": 274, "deletions": 0}, "files": [{"sha": "8e86a3438dd43e6528607015b1bebb2e295a804d", "filename": "gcc/config/rs6000/netware.h", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/890e2acfe63209f18c6a240c2751ca8713650b70/gcc%2Fconfig%2Frs6000%2Fnetware.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/890e2acfe63209f18c6a240c2751ca8713650b70/gcc%2Fconfig%2Frs6000%2Fnetware.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fnetware.h?ref=890e2acfe63209f18c6a240c2751ca8713650b70", "patch": "@@ -0,0 +1,274 @@\n+/* Core target definitions for GNU compiler\n+   for IBM RS/6000 PowerPC running NetWare\n+   Copyright (C) 1994 Free Software Foundation, Inc.\n+   Contributed by Cygnus Support.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"rs6000/powerpc.h\"\n+\n+/* Don't generate XCOFF debugging information.  */\n+\n+#undef XCOFF_DEBUGGING_INFO\n+\n+/* Don't use the COFF object file format.  */\n+\n+#undef OBJECT_FORMAT_COFF\n+\n+/* The XCOFF support uses weird symbol suffixes, which we don't want\n+   for ELF.  */\n+\n+#undef RS6000_OUTPUT_BASENAME\n+#define RS6000_OUTPUT_BASENAME(FILE, NAME) assemble_name (FILE, NAME)\n+\n+/* Don't bother to output .extern pseudo-ops.  They are not needed by\n+   ELF assemblers.  */\n+\n+#undef ASM_OUTPUT_EXTERNAL\n+\n+/* Undefine some things which are defined by the generic svr4.h.  */\n+\n+#undef ASM_FILE_END\n+#undef ASM_OUTPUT_EXTERNAL_LIBCALL\n+#undef READONLY_DATA_SECTION\n+#undef SELECT_SECTION\n+#undef ASM_DECLARE_FUNCTION_NAME\n+\n+/* Use the regular svr4 definitions.  */\n+\n+#include \"svr4.h\"\n+#include \"netware.h\"\n+\n+/* Create a function descriptor when we declare a function name.  This\n+   is a mixture of the ASM_DECLARE_FUNCTION_NAME macros in rs6000.h\n+   and svr4.h.  The unmodified function name is used to name the\n+   descriptor.  The function name with an initial `.' is used to name\n+   the code.  */\n+\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n+    if (TREE_PUBLIC (DECL))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"\\t.globl .\");\t\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+        fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    data_section ();\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.long .\");\t\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fprintf (FILE, \", __GOT0, 0\\n\");\t\t\t\t\t\\\n+    text_section ();\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \".\");\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* We need to override the .size output in order to put a `.' before\n+   the function name.  */\n+\n+#undef ASM_DECLARE_FUNCTION_SIZE\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        char label[256];\t\t\t\t\t\t\\\n+\tstatic int labelno;\t\t\t\t\t\t\\\n+\tlabelno++;\t\t\t\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\t\\\n+\tASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+        fprintf (FILE, \",\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, label);\t\t\t\t\t\\\n+        fprintf (FILE, \"-.\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Use ELF style section commands.  */\n+\n+#undef TEXT_SECTION_ASM_OP\n+#define TEXT_SECTION_ASM_OP\t\"\\t.section\\t\\\".text\\\"\"\n+\n+#undef DATA_SECTION_ASM_OP\n+#define DATA_SECTION_ASM_OP\t\"\\t.section\\t\\\".data\\\"\"\n+\n+/* Besides the usual ELF sections, we need a toc section.  */\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_ctors, in_dtors, in_toc\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  TOC_SECTION_FUNCTION\n+\n+#define TOC_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+toc_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_MINIMAL_TOC)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static int toc_initialized = 0;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (! toc_initialized)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  fprintf (asm_out_file, \"%s\\n\", TOC_SECTION_ASM_OP);\t\t\\\n+\t  fprintf (asm_out_file, \".LCTOC0:\\n\");\t\t\t\t\\\n+\t  fprintf (asm_out_file, \"\\t.tc .LCTOC1\\n\");\t\t\t\\\n+\t  fprintf (asm_out_file, \"%s\\n\", MINIMAL_TOC_SECTION_ASM_OP);\t\\\n+\t  fprintf (asm_out_file, \".LCTOC1:\\n\");\t\t\t\t\\\n+\t  toc_initialized = 1;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_toc)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\",\t\t\t\t\t\\\n+\t       (TARGET_MINIMAL_TOC\t\t\t\t\t\\\n+\t\t? MINIMAL_TOC_SECTION_ASM_OP\t\t\t\t\\\n+\t\t: TOC_SECTION_ASM_OP));\t\t\t\t\t\\\n+      in_section = in_toc;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define TOC_SECTION_ASM_OP \"\\t.section\\t.got,\\\"aw\\\"\"\n+#define MINIMAL_TOC_SECTION_ASM_OP \"\\t.section\\t.got1,\\\"aw\\\"\"\n+\n+/* Use the TOC section for TOC entries.  */\n+\n+#undef SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE, X)\t\t\\\n+{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X))\t\\\n+    toc_section ();\t\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\\\n+}\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* svr4.h overrides ASM_OUTPUT_INTERNAL_LABEL.  */\n+\n+#undef ASM_OUTPUT_INTERNAL_LABEL_PREFIX\n+#define ASM_OUTPUT_INTERNAL_LABEL_PREFIX(FILE,PREFIX)\t\\\n+  fprintf (FILE, \".%s\", PREFIX)\n+\n+/* Pass -m601 to the assembler, since that is what powerpc.h currently\n+   implies.  */\n+#undef ASM_SPEC\n+#define ASM_SPEC \\\n+  \"-u -m601 %{V} %{v:%{!V:-V}} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}\"\n+/* This is the end of what might become sysv4.h.  */\n+\n+/* Enable output of DBX (stabs) debugging information when asked for it.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* Prefer DBX (stabs) debugging information over the native (DWARF) format. */\n+\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+/* Line numbers are relative to the current function.  */\n+\n+#undef  ASM_OUTPUT_SOURCE_LINE\n+#define ASM_OUTPUT_SOURCE_LINE(file, line)\t\t\\\n+  { static int sym_lineno = 1;\t\t\t\t\\\n+    fprintf (file, \".stabn 68,0,%d,.LM%d-.%s\\n.LM%d:\\n\",\\\n+\t     line, sym_lineno, \t\t\t\t\\\n+\t     XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0), \\\n+\t     sym_lineno);\t\t\t\t\\\n+    sym_lineno += 1; }\n+\n+/* But, to make this work, we have to output the stabs for the function\n+   name *first*...  */\n+\n+#define\tDBX_FUNCTION_FIRST\n+\n+/* We need to output LBRAC and RBRAC lines specially to include the\n+   dot in from of the text symbol for a function.  */\n+\n+#define DBX_OUTPUT_LBRAC(FILE, BUF)\t\t\t\t\t   \\\n+do\t\t\t\t\t\t\t\t\t   \\\n+  {\t\t\t\t\t\t\t\t\t   \\\n+    fprintf (FILE, \"%s %d,0,0,\", ASM_STABN_OP, N_LBRAC);\t\t   \\\n+    assemble_name (FILE, BUF);\t\t\t\t\t\t   \\\n+    fprintf (FILE, \"-.\");\t\t\t\t\t\t   \\\n+    assemble_name (asmfile,\t\t\t\t\t\t   \\\n+\t\t   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));  \\\n+    fprintf (asmfile, \"\\n\");\t\t\t\t\t\t   \\\n+  }\t\t\t\t\t\t\t\t\t   \\\n+while (0)\n+\n+#define DBX_OUTPUT_RBRAC(FILE, BUF)\t\t\t\t\t   \\\n+do\t\t\t\t\t\t\t\t\t   \\\n+  {\t\t\t\t\t\t\t\t\t   \\\n+    fprintf (FILE, \"%s %d,0,0,\", ASM_STABN_OP, N_RBRAC);\t\t   \\\n+    assemble_name (FILE, BUF);\t\t\t\t\t\t   \\\n+    fprintf (FILE, \"-.\");\t\t\t\t\t\t   \\\n+    assemble_name (asmfile,\t\t\t\t\t\t   \\\n+\t\t   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));  \\\n+    fprintf (asmfile, \"\\n\");\t\t\t\t\t\t   \\\n+  }\t\t\t\t\t\t\t\t\t   \\\n+while (0)\n+\n+/* We are using function descriptors, so the value of a function\n+   symbol is in the .data section.  However, we want the stabs entry\n+   for that function to point at the actual function code in the .text\n+   section, which we get by prefixing the symbol with a dot.  */\n+\n+#define DBX_FINISH_SYMBOL(sym)\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  int line = 0;\t\t\t\t\t\t\t\t\\\n+  if (use_gnu_debug_info_extensions && sym != 0)\t\t\t\\\n+    line = DECL_SOURCE_LINE (sym);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  fprintf (asmfile, \"\\\",%d,0,%d,\", current_sym_code, line);\t\t\\\n+  if (current_sym_addr)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (TREE_CODE (sym) == FUNCTION_DECL)\t\t\t\t\\\n+\tfprintf (asmfile, \".\");\t\t\t\t\t\t\\\n+      output_addr_const (asmfile, current_sym_addr);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (asmfile, \"%d\", current_sym_value);\t\t\t\t\\\n+  putc ('\\n', asmfile);\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is the end of what might become sysv4dbx.h.  */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (PowerPC Netware)\");\n+\n+/* FIXME: These should actually indicate PowerPC, when there is some\n+   standard way of expressing that.  */\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \\\n+  \"-DPPC D__netware__ -Asystem(netware) -Acpu(powerpc) -Amachine(powerpc)\""}]}