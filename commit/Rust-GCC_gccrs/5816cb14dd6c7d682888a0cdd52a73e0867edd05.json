{"sha": "5816cb14dd6c7d682888a0cdd52a73e0867edd05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxNmNiMTRkZDZjN2Q2ODI4ODhhMGNkZDUyYTczZTA4NjdlZGQwNQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1998-06-23T07:10:29Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1998-06-23T07:10:29Z"}, "message": "Have -fnew-exceptions actually use the runtime field, and not generate runtime checking code inside each handler.\n\nHave -fnew-exceptions actually use the runtime field, and not generate\nruntime checking code inside each handler.\nTHis works at low opt, but not with optimization at the moment.\nTue Jun 23 10:06:07 EDT 1998  Andrew MacLeod  (amacleod@cygnus.com)\n\t* eh-common.h (struct __eh_info): Remove coerced value field.\n\t* libgcc2.c (find_exception_handler): Don't set coerced_value field.\n\t* except.c (get_dynamic_handler_chain, get_dynamic_cleanup_chain): Use\n\tPOINTER_SIZE instead of Pmode.\n\t(expand_start_all_catch): Call start_catch_handler() if we are not\n\tusing new style exceptions.\n1998-06-22  Andrew MacLeod  (amacleod@cygnus.com)\n\t* parse.y (function_try_block): Don't call start_catch_handler.\n\t* except.c (call_eh_info): Remove coerced field from declaration.\n\t(build_eh_type_type_ref): New function to create an address of a\n\trtti function for the new style exception tables.\n\t(expand_start_catch_block): Split function, this contains the\n\tcommon part.\n\t(process_start_catch_block_old): New function to perform the rest\n\tof expand_start_catch_block under old style exceptions.\n\t(process_start_catch_block_old): New function to perform the rest\n\tof expand_start_catch_block under new style exceptions.\n\t(expand_end_catch_block): Only pop the false label off the stack under\n\tthe old style of exceptions.\n\t* semantics.c (finish_try_block): Don't call start_catch_handler.\n\t* exception.cc (struct cp_eh_info): Add original_value field.\n\t(__cplus_type_matcher): Perform type matching on the original exception\n\tvalue, and if we have a match, set the current value.\n\t(__cp_push_exception): Set the original expcetion value.\n\nFrom-SVN: r20671", "tree": {"sha": "caff48e4d357cdb27c61741d2e59101bb1bba09b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caff48e4d357cdb27c61741d2e59101bb1bba09b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5816cb14dd6c7d682888a0cdd52a73e0867edd05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5816cb14dd6c7d682888a0cdd52a73e0867edd05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5816cb14dd6c7d682888a0cdd52a73e0867edd05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5816cb14dd6c7d682888a0cdd52a73e0867edd05/comments", "author": null, "committer": null, "parents": [{"sha": "83de03dfd8d9c845da0d3370839dbf1518c48f52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83de03dfd8d9c845da0d3370839dbf1518c48f52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83de03dfd8d9c845da0d3370839dbf1518c48f52"}], "stats": {"total": 238, "additions": 217, "deletions": 21}, "files": [{"sha": "d4f3d456c6494407e8ab261d19526ddb0c290c60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5816cb14dd6c7d682888a0cdd52a73e0867edd05", "patch": "@@ -1,3 +1,12 @@\n+Tue Jun 23 10:06:07 EDT 1998  Andrew MacLeod  (amacleod@cygnus.com)\n+\n+\t* eh-common.h (struct __eh_info): Remove coerced value field.\n+\t* libgcc2.c (find_exception_handler): Don't set coerced_value field.\n+\t* except.c (get_dynamic_handler_chain, get_dynamic_cleanup_chain): Use \n+\tPOINTER_SIZE instead of Pmode.\n+\t(expand_start_all_catch): Call start_catch_handler() if we are not\n+\tusing new style exceptions.\n+\n Tue Jun 23 06:45:00 1998  Catherine Moore  <clm@cygnus.com>\n \n         * varasm.c (assemble_variable): Remove reference to warn_bss_align."}, {"sha": "ddd56db73370bf7ec08a881c12378dd5a1093985", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5816cb14dd6c7d682888a0cdd52a73e0867edd05", "patch": "@@ -1,3 +1,23 @@\n+1998-06-23  Andrew MacLeod  (amacleod@cygnus.com)\n+\n+\t* parse.y (function_try_block): Don't call start_catch_handler.\n+\t* except.c (call_eh_info): Remove coerced field from declaration.\n+\t(build_eh_type_type_ref): New function to create an address of a\n+\trtti function for the new style exception tables.\n+\t(expand_start_catch_block): Split function, this contains the\n+\tcommon part.\n+\t(process_start_catch_block_old): New function to perform the rest\n+\tof expand_start_catch_block under old style exceptions.\n+\t(process_start_catch_block_old): New function to perform the rest\n+\tof expand_start_catch_block under new style exceptions.\n+\t(expand_end_catch_block): Only pop the false label off the stack under\n+\tthe old style of exceptions.\n+\t* semantics.c (finish_try_block): Don't call start_catch_handler.\n+\t* exception.cc (struct cp_eh_info): Add original_value field.\n+\t(__cplus_type_matcher): Perform type matching on the original exception\n+\tvalue, and if we have a match, set the current value.\n+\t(__cp_push_exception): Set the original expcetion value.\n+\n 1998-06-23  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* call.c (joust): Fix confusing conversion warning."}, {"sha": "438351ef8cd7848af762f860faa7344294833bb5", "filename": "gcc/cp/except.c", "status": "modified", "additions": 175, "deletions": 10, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=5816cb14dd6c7d682888a0cdd52a73e0867edd05", "patch": "@@ -56,6 +56,9 @@ static tree get_eh_type PROTO((void));\n static tree get_eh_caught PROTO((void));\n static tree get_eh_handlers PROTO((void));\n static tree do_pop_exception PROTO((void));\n+static void process_start_catch_block PROTO((tree, tree));\n+static void process_start_catch_block_old PROTO((tree, tree));\n+static tree build_eh_type_type_ref PROTO((tree));\n \n #if 0\n /* This is the startup, and finish stuff per exception table.  */\n@@ -273,14 +276,12 @@ call_eh_info ()\n       fields[0] = build_lang_field_decl (FIELD_DECL, \n                     get_identifier (\"match_function\"), ptr_type_node);\n       fields[1] = build_lang_field_decl (FIELD_DECL, \n-                    get_identifier (\"coerced_value\"), ptr_type_node);\n-      fields[2] = build_lang_field_decl (FIELD_DECL, \n                     get_identifier (\"language\"), short_integer_type_node);\n-      fields[3] = build_lang_field_decl (FIELD_DECL, \n+      fields[2] = build_lang_field_decl (FIELD_DECL, \n                     get_identifier (\"version\"), short_integer_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */\n-      finish_builtin_type (t1, \"__eh_info\", fields, 3, ptr_type_node);\n+      finish_builtin_type (t1, \"__eh_info\", fields, 2, ptr_type_node);\n       t = make_lang_type (RECORD_TYPE);\n       fields[0] = build_lang_field_decl (FIELD_DECL, \n                                               get_identifier (\"eh_info\"), t1);\n@@ -414,6 +415,48 @@ build_eh_type_type (type)\n   return build1 (ADDR_EXPR, ptr_type_node, exp);\n }\n \n+/* Build the address of a runtime type for use in the runtime matching\n+   field of the new exception model */\n+\n+static tree\n+build_eh_type_type_ref (type)\n+     tree type;\n+{\n+  char *typestring;\n+  tree exp;\n+  int susp;\n+\n+  if (type == error_mark_node)\n+    return error_mark_node;\n+\n+  /* peel back references, so they match.  */\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  /* Peel off cv qualifiers.  */\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  push_obstacks_nochange ();\n+  end_temporary_allocation ();\n+\n+  if (flag_rtti)\n+    {\n+      exp = get_tinfo_fn (type);\n+      TREE_USED (exp) = 1;\n+      mark_inline_for_output (exp);\n+      exp = build1 (ADDR_EXPR, ptr_type_node, exp);\n+    }\n+  else\n+    {\n+      typestring = build_overload_name (type, 1, 1);\n+      exp = combine_strings (build_string (strlen (typestring)+1, typestring));\n+      exp = build1 (ADDR_EXPR, ptr_type_node, exp);\n+    }\n+  pop_obstacks ();\n+  return (exp);\n+}\n+\n+\n /* Build a type value for use at runtime for a exp that is thrown or\n    matched against by the exception handling system.  */\n \n@@ -495,7 +538,7 @@ build_terminate_handler ()\n   return term;\n }\n \n-/* call this to start a catch block. Typename is the typename, and identifier\n+/* Call this to start a catch block. Typename is the typename, and identifier\n    is the variable to place the object in or NULL if the variable doesn't\n    matter.  If typename is NULL, that means its a \"catch (...)\" or catch\n    everything.  In that case we don't need to do any type checking.\n@@ -505,9 +548,7 @@ void\n expand_start_catch_block (declspecs, declarator)\n      tree declspecs, declarator;\n {\n-  rtx false_label_rtx;\n-  tree decl = NULL_TREE;\n-  tree init;\n+  tree decl;\n \n   if (processing_template_decl)\n     {\n@@ -527,6 +568,25 @@ expand_start_catch_block (declspecs, declarator)\n   if (! doing_eh (1))\n     return;\n \n+  if (flag_new_exceptions)\n+    process_start_catch_block (declspecs, declarator);\n+  else\n+    process_start_catch_block_old (declspecs, declarator);\n+}\n+\n+\n+/* This function performs the expand_start_catch_block functionality for \n+   exceptions implemented in the old style, where catch blocks were all\n+   called, and had to check the runtime information themselves. */\n+\n+static void \n+process_start_catch_block_old (declspecs, declarator)\n+     tree declspecs, declarator;\n+{\n+  rtx false_label_rtx;\n+  tree decl = NULL_TREE;\n+  tree init;\n+\n   /* Create a binding level for the eh_info and the exception object\n      cleanup.  */\n   pushlevel (0);\n@@ -631,6 +691,111 @@ expand_start_catch_block (declspecs, declarator)\n   emit_line_note (input_filename, lineno);\n }\n \n+/* This function performs the expand_start_catch_block functionality for \n+   exceptions implemented in the new style. __throw determines whether\n+   a handler needs to be called or not, so the handler itself has to do\n+   nothing additionaal. */\n+\n+static void \n+process_start_catch_block (declspecs, declarator)\n+     tree declspecs, declarator;\n+{\n+  rtx false_label_rtx;\n+  tree decl = NULL_TREE;\n+  tree init;\n+\n+  /* Create a binding level for the eh_info and the exception object\n+     cleanup.  */\n+  pushlevel (0);\n+  expand_start_bindings (0);\n+\n+\n+  if (declspecs)\n+    {\n+      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);\n+\n+      if (decl == NULL_TREE)\n+\terror (\"invalid catch parameter\");\n+    }\n+\n+  if (decl)\n+    start_catch_handler (build_eh_type_type_ref (TREE_TYPE (decl)));\n+  else\n+    start_catch_handler (NULL_TREE);\n+\n+  emit_line_note (input_filename, lineno);\n+\n+  push_eh_info ();\n+\n+  if (decl)\n+    {\n+      tree exp;\n+      rtx call_rtx, return_value_rtx;\n+      tree init_type;\n+\n+      /* Make sure we mark the catch param as used, otherwise we'll get\n+\t a warning about an unused ((anonymous)).  */\n+      TREE_USED (decl) = 1;\n+\n+      /* Figure out the type that the initializer is.  */\n+      init_type = TREE_TYPE (decl);\n+      if (TREE_CODE (init_type) != REFERENCE_TYPE\n+\t  && TREE_CODE (init_type) != POINTER_TYPE)\n+\tinit_type = build_reference_type (init_type);\n+\n+      exp = get_eh_value ();\n+\n+      /* Since pointers are passed by value, initialize a reference to\n+\t pointer catch parm with the address of the value slot.  */\n+      if (TREE_CODE (init_type) == REFERENCE_TYPE\n+\t  && TREE_CODE (TREE_TYPE (init_type)) == POINTER_TYPE)\n+\texp = build_unary_op (ADDR_EXPR, exp, 1);\n+\n+      exp = ocp_convert (init_type , exp, CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n+\n+      push_eh_cleanup ();\n+\n+      /* Create a binding level for the parm.  */\n+      pushlevel (0);\n+      expand_start_bindings (0);\n+\n+      init = convert_from_reference (exp);\n+\n+      /* If the constructor for the catch parm exits via an exception, we\n+         must call terminate.  See eh23.C.  */\n+      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n+\t{\n+\t  /* Generate the copy constructor call directly so we can wrap it.\n+\t     See also expand_default_init.  */\n+\t  init = ocp_convert (TREE_TYPE (decl), init,\n+\t\t\t      CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n+\t  init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init,\n+\t\t\tbuild_terminate_handler ());\n+\t}\n+\n+      /* Let `cp_finish_decl' know that this initializer is ok.  */\n+      DECL_INITIAL (decl) = init;\n+      decl = pushdecl (decl);\n+\n+      cp_finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n+    }\n+  else\n+    {\n+      push_eh_cleanup ();\n+\n+      /* Create a binding level for the parm.  */\n+      pushlevel (0);\n+      expand_start_bindings (0);\n+\n+      /* Fall into the catch all section.  */\n+    }\n+\n+  init = build_modify_expr (get_eh_caught (), NOP_EXPR, integer_one_node);\n+  expand_expr (init, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  emit_line_note (input_filename, lineno);\n+}\n+\n \n \n /* Call this to end a catch block.  Its responsible for emitting the\n@@ -658,7 +823,8 @@ expand_end_catch_block ()\n \n   /* label we emit to jump to if this catch block didn't match.  */\n   /* This the closing } in the `if (eq) {' of the documentation.  */\n-  emit_label (pop_label_entry (&false_label_stack));\n+  if (! flag_new_exceptions)\n+    emit_label (pop_label_entry (&false_label_stack));\n }\n \n /* An exception spec is implemented more or less like:\n@@ -686,7 +852,6 @@ expand_end_eh_spec (raises)\n   int count = 0;\n \n   expand_start_all_catch ();\n-  start_catch_handler (NULL);\n   expand_start_catch_block (NULL_TREE, NULL_TREE);\n \n   /* Build up an array of type_infos.  */"}, {"sha": "cad73046462b8793e4d4a8d239a35937c2c335b2", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=5816cb14dd6c7d682888a0cdd52a73e0867edd05", "patch": "@@ -93,6 +93,7 @@ struct cp_eh_info\n   bool caught;\n   cp_eh_info *next;\n   long handlers;\n+  void *original_value;\n };\n \n /* Language-specific EH info pointer, defined in libgcc2. */\n@@ -162,7 +163,10 @@ __cplus_type_matcher (cp_eh_info *info, exception_table *matching_info,\n   /* we don't worry about version info yet, there is only one version! */\n   \n   void *match_type = ((rtimetype) (matching_info->match_info)) ();\n-  ret = __throw_type_match_rtti (match_type, info->type, info->value);\n+  ret = __throw_type_match_rtti (match_type, info->type, info->original_value);\n+  /* change value of exception */\n+  if (ret)\n+    info->value = ret;\n   return ret;\n }\n \n@@ -180,11 +184,11 @@ __cp_push_exception (void *value, void *type, void (*cleanup)(void *, int))\n   p->cleanup = cleanup;\n   p->handlers = 0;\n   p->caught = false;\n+  p->original_value = value;\n \n   p->eh_info.match_function = __cplus_type_matcher;\n   p->eh_info.language = EH_LANG_C_plus_plus;\n   p->eh_info.version = 1;\n-  p->eh_info.coerced_value = NULL;\n \n   cp_eh_info **q = __get_eh_info ();\n "}, {"sha": "ffc45e61c6ee886ffb1907e10694868001260e53", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=5816cb14dd6c7d682888a0cdd52a73e0867edd05", "patch": "@@ -3253,7 +3253,6 @@ function_try_block:\n \t  ctor_initializer_opt compstmt\n \t\t{ \n                   expand_start_all_catch (); \n-                  start_catch_handler (NULL);\n                 }\n \t  handler_seq\n \t\t{"}, {"sha": "763f208cf360af65a0d443411e44bfdcb7b20076", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5816cb14dd6c7d682888a0cdd52a73e0867edd05", "patch": "@@ -589,7 +589,6 @@ finish_try_block (try_block)\n   else\n     {\n       expand_start_all_catch ();  \n-      start_catch_handler (NULL);\n     }\n }\n "}, {"sha": "c8d98c09072fcaca810cf7dd66a90f28f7754eaa", "filename": "gcc/eh-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Feh-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Feh-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Feh-common.h?ref=5816cb14dd6c7d682888a0cdd52a73e0867edd05", "patch": "@@ -92,7 +92,6 @@ typedef void * (*__eh_matcher)          PROTO ((void *, void *, void *));\n typedef struct __eh_info \n {\n   __eh_matcher match_function;\n-  void *coerced_value;\n   short language;\n   short version;\n } __eh_info;"}, {"sha": "6ffa92038676a72c108c18793563c9b2bf0b1295", "filename": "gcc/except.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=5816cb14dd6c7d682888a0cdd52a73e0867edd05", "patch": "@@ -1025,7 +1025,7 @@ get_dynamic_handler_chain ()\n \n   /* This is the offset of dynamic_handler_chain in the eh_context struct\n      declared in eh-common.h. If its location is change, change this offset */\n-  dhc = plus_constant (ehc, GET_MODE_SIZE (Pmode));\n+  dhc = plus_constant (ehc, POINTER_SIZE / BITS_PER_UNIT);\n \n   result = copy_to_reg (dhc);\n \n@@ -1045,7 +1045,7 @@ get_dynamic_cleanup_chain ()\n   rtx dhc, dcc, result;\n \n   dhc = get_dynamic_handler_chain ();\n-  dcc = plus_constant (dhc, GET_MODE_SIZE (Pmode));\n+  dcc = plus_constant (dhc, POINTER_SIZE / BITS_PER_UNIT);\n \n   result = copy_to_reg (dcc);\n \n@@ -1618,6 +1618,10 @@ expand_start_all_catch ()\n       expand_eh_region_start ();\n       ehstack.top->entry->outer_context = outer_context;\n     }\n+\n+  /* We also have to start the handler if we aren't using the new model. */\n+  if (! flag_new_exceptions)\n+    start_catch_handler (NULL);\n }\n \n /* Finish up the catch block.  At this point all the insns for the"}, {"sha": "4e17faf491948370704d50ab5dbf9209600efe41", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5816cb14dd6c7d682888a0cdd52a73e0867edd05/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=5816cb14dd6c7d682888a0cdd52a73e0867edd05", "patch": "@@ -3426,10 +3426,7 @@ find_exception_handler (void *pc, exception_descriptor *table, void *eh_info)\n                     {\n                       ret = (*matcher)(eh_info, &tab[pos], table);\n                       if (ret)\n-                        {\n-                          ((__eh_info *)eh_info)->coerced_value = ret;\n-                          return tab[pos].exception_handler;\n-                        }\n+                        return tab[pos].exception_handler;\n                     }\n                 }\n               else"}]}