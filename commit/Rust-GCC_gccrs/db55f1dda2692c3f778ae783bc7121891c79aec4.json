{"sha": "db55f1dda2692c3f778ae783bc7121891c79aec4", "node_id": "C_kwDOANBUbNoAKGRiNTVmMWRkYTI2OTJjM2Y3NzhhZTc4M2JjNzEyMTg5MWM3OWFlYzQ", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-31T19:13:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-31T19:15:27Z"}, "message": "libstdc++-v3: <complex> support for extended floating point types\n\nThe following patch adds <complex> support for extended floating point\ntypes.\nC++23 removes the float/double/long double specializations from the spec\nand instead adds explicit(bool) specifier on the converting constructor.\nThe patch uses that for converting constructor of the base template as well\nas the float/double/long double specializations's converting constructors\n(e.g. so that it handles convertion construction also from complex of extended\nfloating point types).  Copy ctor was already defaulted as the spec now\nrequires.\nThe patch also adds partial specialization for the _Float{16,32,64,128}\nand __gnu_cxx::__bfloat16_t types because the base template doesn't use\n__complex__ but a pair of floating point values.\nThe g++.dg/cpp23/ testcase verifies explicit(bool) works correctly.\n\n2022-10-31  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/testsuite/\n\t* g++.dg/cpp23/ext-floating12.C: New test.\nlibstdc++-v3/\n\t* include/std/complex (complex::complex converting ctor): For C++23\n\tuse explicit specifier with constant expression.  Explicitly cast\n\tboth parts to _Tp.\n\t(__complex_abs, __complex_arg, __complex_cos, __complex_cosh,\n\t__complex_exp, __complex_log, __complex_sin, __complex_sinh,\n\t__complex_sqrt, __complex_tan, __complex_tanh, __complex_pow): Add\n\t__complex__ _Float{16,32,64,128} and __complex__ decltype(0.0bf16)\n\toverloads.\n\t(complex<float>::complex converting ctor,\n\tcomplex<double>::complex converting ctor,\n\tcomplex<long double>::complex converting ctor): For C++23 implement\n\tas template with explicit specifier with constant expression\n\tand explicit casts.\n\t(__complex_type): New template.\n\t(complex): New partial specialization for types with extended floating\n\tpoint types.\n\t(__complex_acos, __complex_asin, __complex_atan, __complex_acosh,\n\t__complex_asinh, __complex_atanh): Add __complex__ _Float{16,32,64,128}\n\tand __complex__ decltype(0.0bf16) overloads.\n\t(__complex_proj): Likewise.  Add template for complex of extended\n\tfloating point types.\n\t* include/bits/cpp_type_traits.h (__is_floating): Specialize for\n\t_Float{16,32,64,128} and __gnu_cxx::__bfloat16_t.\n\t* testsuite/26_numerics/complex/ext_c++23.cc: New test.", "tree": {"sha": "8d52dbc318c855b5cce71dc41d11a39bc825e2bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d52dbc318c855b5cce71dc41d11a39bc825e2bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db55f1dda2692c3f778ae783bc7121891c79aec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db55f1dda2692c3f778ae783bc7121891c79aec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db55f1dda2692c3f778ae783bc7121891c79aec4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db55f1dda2692c3f778ae783bc7121891c79aec4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8422861bddc7c4fd202cd59c8487d4bc6b807dc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8422861bddc7c4fd202cd59c8487d4bc6b807dc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8422861bddc7c4fd202cd59c8487d4bc6b807dc3"}], "stats": {"total": 957, "additions": 955, "deletions": 2}, "files": [{"sha": "77ee4c70a93ba03cd6e02edde580b43c707d6f66", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating12.C", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db55f1dda2692c3f778ae783bc7121891c79aec4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db55f1dda2692c3f778ae783bc7121891c79aec4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating12.C?ref=db55f1dda2692c3f778ae783bc7121891c79aec4", "patch": "@@ -0,0 +1,182 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do compile { target { c++23 && { i?86-*-linux* x86_64-*-linux* } } } }\n+// { dg-options \"\" }\n+\n+#include <complex>\n+#include <stdfloat>\n+\n+#if !defined(__STDCPP_FLOAT32_T__) \\\n+    || !defined(__STDCPP_FLOAT64_T__) || !defined(__STDCPP_FLOAT128_T__) \\\n+    || __FLT_MAX_EXP__ != __FLT32_MAX_EXP__ || __FLT_MANT_DIG__ != __FLT32_MANT_DIG__ \\\n+    || __DBL_MAX_EXP__ != __FLT64_MAX_EXP__ || __DBL_MANT_DIG__ != __FLT64_MANT_DIG__ \\\n+    || __LDBL_MAX_EXP__ != __FLT128_MAX_EXP__ || __LDBL_MANT_DIG__ >= __FLT128_MANT_DIG__ \\\n+    || !defined(__SIZEOF_FLOAT128__)\n+#error Unexpected set of floating point types\n+#endif\n+\n+using namespace std;\n+\n+int\n+main()\n+{\n+  complex<float> a01(complex<float>(1.0f, 2.0f));\n+  complex<float> a02 = complex<float>(1.0f, 2.0f);\n+  complex<float> a03(complex<double>(1.0, 2.0));\n+  complex<float> a04 = complex<double>(1.0, 2.0);\t\t\t// { dg-error \"conversion from 'complex<double>' to non-scalar type 'complex<float>' requested\" }\n+  complex<float> a05(complex<long double>(1.0L, 2.0L));\n+  complex<float> a06 = complex<long double>(1.0L, 2.0L);\t\t// { dg-error \"conversion from 'complex<long double>' to non-scalar type 'complex<float>' requested\" }\n+  complex<float> a07(complex<float32_t>(1.0f32, 2.0f32));\n+  complex<float> a08 = complex<float32_t>(1.0f32, 2.0f32);\n+  complex<float> a09(complex<float64_t>(1.0f64, 2.0f64));\n+  complex<float> a10 = complex<float64_t>(1.0f64, 2.0f64);\t\t// { dg-error \"conversion from 'complex<_Float64>' to non-scalar type 'complex<float>' requested\" }\n+  complex<float> a11(complex<float128_t>(1.0f128, 2.0f128));\n+  complex<float> a12 = complex<float128_t>(1.0f128, 2.0f128);\t\t// { dg-error \"conversion from 'complex<_Float128>' to non-scalar type 'complex<float>' requested\" }\n+#ifdef __STDCPP_FLOAT16_T__\n+  complex<float> a13(complex<float16_t>(1.0f16, 2.0f16));\n+  complex<float> a14 = complex<float16_t>(1.0f16, 2.0f16);\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+  complex<float> a15(complex<bfloat16_t>(1.0bf16, 2.0bf16));\n+  complex<float> a16 = complex<bfloat16_t>(1.0bf16, 2.0bf16);\n+#endif\n+  complex<double> b01(complex<float>(1.0f, 2.0f));\n+  complex<double> b02 = complex<float>(1.0f, 2.0f);\n+  complex<double> b03(complex<double>(1.0, 2.0));\n+  complex<double> b04 = complex<double>(1.0, 2.0);\n+  complex<double> b05(complex<long double>(1.0L, 2.0L));\n+  complex<double> b06 = complex<long double>(1.0L, 2.0L);\t\t// { dg-error \"conversion from 'complex<long double>' to non-scalar type 'complex<double>' requested\" }\n+  complex<double> b07(complex<float32_t>(1.0f32, 2.0f32));\n+  complex<double> b08 = complex<float32_t>(1.0f32, 2.0f32);\n+  complex<double> b09(complex<float64_t>(1.0f64, 2.0f64));\n+  complex<double> b10 = complex<float64_t>(1.0f64, 2.0f64);\n+  complex<double> b11(complex<float128_t>(1.0f128, 2.0f128));\n+  complex<double> b12 = complex<float128_t>(1.0f128, 2.0f128);\t\t// { dg-error \"conversion from 'complex<_Float128>' to non-scalar type 'complex<double>' requested\" }\n+#ifdef __STDCPP_FLOAT16_T__\n+  complex<double> b13(complex<float16_t>(1.0f16, 2.0f16));\n+  complex<double> b14 = complex<float16_t>(1.0f16, 2.0f16);\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+  complex<double> b15(complex<bfloat16_t>(1.0bf16, 2.0bf16));\n+  complex<double> b16 = complex<bfloat16_t>(1.0bf16, 2.0bf16);\n+#endif\n+  complex<long double> c01(complex<float>(1.0f, 2.0f));\n+  complex<long double> c02 = complex<float>(1.0f, 2.0f);\n+  complex<long double> c03(complex<double>(1.0, 2.0));\n+  complex<long double> c04 = complex<double>(1.0, 2.0);\n+  complex<long double> c05(complex<long double>(1.0L, 2.0L));\n+  complex<long double> c06 = complex<long double>(1.0L, 2.0L);\n+  complex<long double> c07(complex<float32_t>(1.0f32, 2.0f32));\n+  complex<long double> c08 = complex<float32_t>(1.0f32, 2.0f32);\n+  complex<long double> c09(complex<float64_t>(1.0f64, 2.0f64));\n+  complex<long double> c10 = complex<float64_t>(1.0f64, 2.0f64);\n+  complex<long double> c11(complex<float128_t>(1.0f128, 2.0f128));\n+  complex<long double> c12 = complex<float128_t>(1.0f128, 2.0f128);\t// { dg-error \"conversion from 'complex<_Float128>' to non-scalar type 'complex<long double>' requested\" }\n+#ifdef __STDCPP_FLOAT16_T__\n+  complex<long double> c13(complex<float16_t>(1.0f16, 2.0f16));\n+  complex<long double> c14 = complex<float16_t>(1.0f16, 2.0f16);\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+  complex<long double> c15(complex<bfloat16_t>(1.0bf16, 2.0bf16));\n+  complex<long double> c16 = complex<bfloat16_t>(1.0bf16, 2.0bf16);\n+#endif\n+  complex<float32_t> d01(complex<float>(1.0f, 2.0f));\n+  complex<float32_t> d02 = complex<float>(1.0f, 2.0f);\n+  complex<float32_t> d03(complex<double>(1.0, 2.0));\n+  complex<float32_t> d04 = complex<double>(1.0, 2.0);\t\t\t// { dg-error \"conversion from 'complex<double>' to non-scalar type 'complex<_Float32>' requested\" }\n+  complex<float32_t> d05(complex<long double>(1.0L, 2.0L));\n+  complex<float32_t> d06 = complex<long double>(1.0L, 2.0L);\t\t// { dg-error \"conversion from 'complex<long double>' to non-scalar type 'complex<_Float32>' requested\" }\n+  complex<float32_t> d07(complex<float32_t>(1.0f32, 2.0f32));\n+  complex<float32_t> d08 = complex<float32_t>(1.0f32, 2.0f32);\n+  complex<float32_t> d09(complex<float64_t>(1.0f64, 2.0f64));\n+  complex<float32_t> d10 = complex<float64_t>(1.0f64, 2.0f64);\t\t// { dg-error \"conversion from 'complex<_Float64>' to non-scalar type 'complex<_Float32>' requested\" }\n+  complex<float32_t> d11(complex<float128_t>(1.0f128, 2.0f128));\n+  complex<float32_t> d12 = complex<float128_t>(1.0f128, 2.0f128);\t// { dg-error \"conversion from 'complex<_Float128>' to non-scalar type 'complex<_Float32>' requested\" }\n+#ifdef __STDCPP_FLOAT16_T__\n+  complex<float32_t> d13(complex<float16_t>(1.0f16, 2.0f16));\n+  complex<float32_t> d14 = complex<float16_t>(1.0f16, 2.0f16);\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+  complex<float32_t> d15(complex<bfloat16_t>(1.0bf16, 2.0bf16));\n+  complex<float32_t> d16 = complex<bfloat16_t>(1.0bf16, 2.0bf16);\n+#endif\n+  complex<float64_t> e01(complex<float>(1.0f, 2.0f));\n+  complex<float64_t> e02 = complex<float>(1.0f, 2.0f);\n+  complex<float64_t> e03(complex<double>(1.0, 2.0));\n+  complex<float64_t> e04 = complex<double>(1.0, 2.0);\n+  complex<float64_t> e05(complex<long double>(1.0L, 2.0L));\n+  complex<float64_t> e06 = complex<long double>(1.0L, 2.0L);\t\t// { dg-error \"conversion from 'complex<long double>' to non-scalar type 'complex<_Float64>' requested\" }\n+  complex<float64_t> e07(complex<float32_t>(1.0f32, 2.0f32));\n+  complex<float64_t> e08 = complex<float32_t>(1.0f32, 2.0f32);\n+  complex<float64_t> e09(complex<float64_t>(1.0f64, 2.0f64));\n+  complex<float64_t> e10 = complex<float64_t>(1.0f64, 2.0f64);\n+  complex<float64_t> e11(complex<float128_t>(1.0f128, 2.0f128));\n+  complex<float64_t> e12 = complex<float128_t>(1.0f128, 2.0f128);\t// { dg-error \"conversion from 'complex<_Float128>' to non-scalar type 'complex<_Float64>' requested\" }\n+#ifdef __STDCPP_FLOAT16_T__\n+  complex<float64_t> e13(complex<float16_t>(1.0f16, 2.0f16));\n+  complex<float64_t> e14 = complex<float16_t>(1.0f16, 2.0f16);\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+  complex<float64_t> e15(complex<bfloat16_t>(1.0bf16, 2.0bf16));\n+  complex<float64_t> e16 = complex<bfloat16_t>(1.0bf16, 2.0bf16);\n+#endif\n+  complex<float128_t> f01(complex<float>(1.0f, 2.0f));\n+  complex<float128_t> f02 = complex<float>(1.0f, 2.0f);\n+  complex<float128_t> f03(complex<double>(1.0, 2.0));\n+  complex<float128_t> f04 = complex<double>(1.0, 2.0);\n+  complex<float128_t> f05(complex<long double>(1.0L, 2.0L));\n+  complex<float128_t> f06 = complex<long double>(1.0L, 2.0L);\n+  complex<float128_t> f07(complex<float32_t>(1.0f32, 2.0f32));\n+  complex<float128_t> f08 = complex<float32_t>(1.0f32, 2.0f32);\n+  complex<float128_t> f09(complex<float64_t>(1.0f64, 2.0f64));\n+  complex<float128_t> f10 = complex<float64_t>(1.0f64, 2.0f64);\n+  complex<float128_t> f11(complex<float128_t>(1.0f128, 2.0f128));\n+  complex<float128_t> f12 = complex<float128_t>(1.0f128, 2.0f128);\n+#ifdef __STDCPP_FLOAT16_T__\n+  complex<float128_t> f13(complex<float16_t>(1.0f16, 2.0f16));\n+  complex<float128_t> f14 = complex<float16_t>(1.0f16, 2.0f16);\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+  complex<float128_t> f15(complex<bfloat16_t>(1.0bf16, 2.0bf16));\n+  complex<float128_t> f16 = complex<bfloat16_t>(1.0bf16, 2.0bf16);\n+#endif\n+#ifdef __STDCPP_FLOAT16_T__\n+  complex<float16_t> g01(complex<float>(1.0f, 2.0f));\n+  complex<float16_t> g02 = complex<float>(1.0f, 2.0f);\t\t\t// { dg-error \"conversion from 'complex<float>' to non-scalar type 'complex<_Float16>' requested\" \"\" { target float16 } }\n+  complex<float16_t> g03(complex<double>(1.0, 2.0));\n+  complex<float16_t> g04 = complex<double>(1.0, 2.0);\t\t\t// { dg-error \"conversion from 'complex<double>' to non-scalar type 'complex<_Float16>' requested\" \"\" { target float16 } }\n+  complex<float16_t> g05(complex<long double>(1.0L, 2.0L));\n+  complex<float16_t> g06 = complex<long double>(1.0L, 2.0L);\t\t// { dg-error \"conversion from 'complex<long double>' to non-scalar type 'complex<_Float16>' requested\" \"\" { target float16 } }\n+  complex<float16_t> g07(complex<float32_t>(1.0f32, 2.0f32));\n+  complex<float16_t> g08 = complex<float32_t>(1.0f32, 2.0f32);\t\t// { dg-error \"conversion from 'complex<_Float32>' to non-scalar type 'complex<_Float16>' requested\" \"\" { target float16 } }\n+  complex<float16_t> g09(complex<float64_t>(1.0f64, 2.0f64));\n+  complex<float16_t> g10 = complex<float64_t>(1.0f64, 2.0f64);\t\t// { dg-error \"conversion from 'complex<_Float64>' to non-scalar type 'complex<_Float16>' requested\" \"\" { target float16 } }\n+  complex<float16_t> g11(complex<float128_t>(1.0f128, 2.0f128));\n+  complex<float16_t> g12 = complex<float128_t>(1.0f128, 2.0f128);\t// { dg-error \"conversion from 'complex<_Float128>' to non-scalar type 'complex<_Float16>' requested\" \"\" { target float16 } }\n+  complex<float16_t> g13(complex<float16_t>(1.0f16, 2.0f16));\n+  complex<float16_t> g14 = complex<float16_t>(1.0f16, 2.0f16);\n+#ifdef __STDCPP_BFLOAT16_T__\n+  complex<float16_t> g15(complex<bfloat16_t>(1.0bf16, 2.0bf16));\n+  complex<float16_t> g16 = complex<bfloat16_t>(1.0bf16, 2.0bf16);\t// { dg-error \"conversion from 'complex<\\[^\\n\\r]*>' to non-scalar type 'complex<_Float16>' requested\" \"\" { target { float16 && bfloat16 } } }\n+#endif\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+  complex<bfloat16_t> h01(complex<float>(1.0f, 2.0f));\n+  complex<bfloat16_t> h02 = complex<float>(1.0f, 2.0f);\t\t\t// { dg-error \"conversion from 'complex<float>' to non-scalar type 'complex<\\[^\\n\\r]*>' requested\" \"\" { target bfloat16 } }\n+  complex<bfloat16_t> h03(complex<double>(1.0, 2.0));\n+  complex<bfloat16_t> h04 = complex<double>(1.0, 2.0);\t\t\t// { dg-error \"conversion from 'complex<double>' to non-scalar type 'complex<\\[^\\n\\r]*>' requested\" \"\" { target bfloat16 } }\n+  complex<bfloat16_t> h05(complex<long double>(1.0L, 2.0L));\n+  complex<bfloat16_t> h06 = complex<long double>(1.0L, 2.0L);\t\t// { dg-error \"conversion from 'complex<long double>' to non-scalar type 'complex<\\[^\\n\\r]*>' requested\" \"\" { target bfloat16 } }\n+  complex<bfloat16_t> h07(complex<float32_t>(1.0f32, 2.0f32));\n+  complex<bfloat16_t> h08 = complex<float32_t>(1.0f32, 2.0f32);\t\t// { dg-error \"conversion from 'complex<_Float32>' to non-scalar type 'complex<\\[^\\n\\r]*>' requested\" \"\" { target bfloat16 } }\n+  complex<bfloat16_t> h09(complex<float64_t>(1.0f64, 2.0f64));\n+  complex<bfloat16_t> h10 = complex<float64_t>(1.0f64, 2.0f64);\t\t// { dg-error \"conversion from 'complex<_Float64>' to non-scalar type 'complex<\\[^\\n\\r]*>' requested\" \"\" { target bfloat16 } }\n+  complex<bfloat16_t> h11(complex<float128_t>(1.0f128, 2.0f128));\n+  complex<bfloat16_t> h12 = complex<float128_t>(1.0f128, 2.0f128);\t// { dg-error \"conversion from 'complex<_Float128>' to non-scalar type 'complex<\\[^\\n\\r]*>' requested\" \"\" { target bfloat16 } }\n+#ifdef __STDCPP_FLOAT16_T__\n+  complex<bfloat16_t> h13(complex<float16_t>(1.0f16, 2.0f16));\n+  complex<bfloat16_t> h14 = complex<float16_t>(1.0f16, 2.0f16);\t\t// { dg-error \"conversion from 'complex<_Float16>' to non-scalar type 'complex<\\[^\\n\\r]*>' requested\" \"\" { target { float16 && bfloat16 } } }\n+#endif\n+  complex<bfloat16_t> h15(complex<bfloat16_t>(1.0bf16, 2.0bf16));\n+  complex<bfloat16_t> h16 = complex<bfloat16_t>(1.0bf16, 2.0bf16);\n+#endif\n+}"}, {"sha": "592673a1d11b6fe7af99e4f9e5d95a1482b90cd3", "filename": "libstdc++-v3/include/bits/cpp_type_traits.h", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db55f1dda2692c3f778ae783bc7121891c79aec4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db55f1dda2692c3f778ae783bc7121891c79aec4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h?ref=db55f1dda2692c3f778ae783bc7121891c79aec4", "patch": "@@ -315,6 +315,51 @@ __INT_N(__GLIBCXX_TYPE_INT_N_3)\n       typedef __true_type __type;\n     };\n \n+#ifdef __STDCPP_FLOAT16_T__\n+  template<>\n+    struct __is_floating<_Float16>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT32_T__\n+  template<>\n+    struct __is_floating<_Float32>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT64_T__\n+  template<>\n+    struct __is_floating<_Float64>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT128_T__\n+  template<>\n+    struct __is_floating<_Float128>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+#endif\n+\n+#ifdef __STDCPP_BFLOAT16_T__\n+  template<>\n+    struct __is_floating<__gnu_cxx::__bfloat16_t>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+#endif\n+\n   //\n   // Pointer types\n   //"}, {"sha": "da2df912ecc0507535fa9dd0d4030a699266e93a", "filename": "libstdc++-v3/include/std/complex", "status": "modified", "additions": 639, "deletions": 2, "changes": 641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db55f1dda2692c3f778ae783bc7121891c79aec4/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db55f1dda2692c3f778ae783bc7121891c79aec4/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex?ref=db55f1dda2692c3f778ae783bc7121891c79aec4", "patch": "@@ -142,8 +142,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       ///  Converting constructor.\n       template<typename _Up>\n-        _GLIBCXX_CONSTEXPR complex(const complex<_Up>& __z)\n-\t: _M_real(__z.real()), _M_imag(__z.imag()) { }\n+#if __cplusplus > 202002L\n+\texplicit(!requires(_Up __u) { _Tp{__u}; })\n+#endif\n+\t_GLIBCXX_CONSTEXPR complex(const complex<_Up>& __z)\n+\t: _M_real(_Tp(__z.real())), _M_imag(_Tp(__z.imag())) { }\n \n #if __cplusplus >= 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -1077,6 +1080,264 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t                 : std::pow(complex<_Tp>(__x), __y);\n     }\n \n+#if _GLIBCXX_USE_C99_COMPLEX\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline _Float16\n+  __complex_abs(__complex__ _Float16 __z)\n+  { return _Float16(__builtin_cabsf(__z)); }\n+\n+  inline _Float16\n+  __complex_arg(__complex__ _Float16 __z)\n+  { return _Float16(__builtin_cargf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_cos(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_ccosf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_cosh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_ccoshf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_exp(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_cexpf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_log(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_clogf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_sin(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_csinf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_sinh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_csinhf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_sqrt(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_csqrtf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_tan(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_ctanf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_tanh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_ctanhf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_pow(__complex__ _Float16 __x, __complex__ _Float16 __y)\n+  { return static_cast<__complex__ _Float16>(__builtin_cpowf(__x, __y)); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline _Float32\n+  __complex_abs(__complex__ _Float32 __z) { return __builtin_cabsf(__z); }\n+\n+  inline _Float32\n+  __complex_arg(__complex__ _Float32 __z) { return __builtin_cargf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_cos(__complex__ _Float32 __z) { return __builtin_ccosf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_cosh(__complex__ _Float32 __z) { return __builtin_ccoshf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_exp(__complex__ _Float32 __z) { return __builtin_cexpf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_log(__complex__ _Float32 __z) { return __builtin_clogf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_sin(__complex__ _Float32 __z) { return __builtin_csinf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_sinh(__complex__ _Float32 __z) { return __builtin_csinhf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_sqrt(__complex__ _Float32 __z) { return __builtin_csqrtf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_tan(__complex__ _Float32 __z) { return __builtin_ctanf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_tanh(__complex__ _Float32 __z) { return __builtin_ctanhf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_pow(__complex__ _Float32 __x, __complex__ _Float32 __y)\n+  { return __builtin_cpowf(__x, __y); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  inline _Float64\n+  __complex_abs(__complex__ _Float64 __z) { return __builtin_cabs(__z); }\n+\n+  inline _Float64\n+  __complex_arg(__complex__ _Float64 __z) { return __builtin_carg(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_cos(__complex__ _Float64 __z) { return __builtin_ccos(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_cosh(__complex__ _Float64 __z) { return __builtin_ccosh(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_exp(__complex__ _Float64 __z) { return __builtin_cexp(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_log(__complex__ _Float64 __z) { return __builtin_clog(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_sin(__complex__ _Float64 __z) { return __builtin_csin(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_sinh(__complex__ _Float64 __z) { return __builtin_csinh(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_sqrt(__complex__ _Float64 __z) { return __builtin_csqrt(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_tan(__complex__ _Float64 __z) { return __builtin_ctan(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_tanh(__complex__ _Float64 __z) { return __builtin_ctanh(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_pow(__complex__ _Float64 __x, __complex__ _Float64 __y)\n+  { return __builtin_cpow(__x, __y); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  inline _Float128\n+  __complex_abs(__complex__ _Float128 __z) { return __builtin_cabsl(__z); }\n+\n+  inline _Float128\n+  __complex_arg(__complex__ _Float128 __z) { return __builtin_cargl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_cos(__complex__ _Float128 __z) { return __builtin_ccosl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_cosh(__complex__ _Float128 __z) { return __builtin_ccoshl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_exp(__complex__ _Float128 __z) { return __builtin_cexpl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_log(__complex__ _Float128 __z) { return __builtin_clogl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_sin(__complex__ _Float128 __z) { return __builtin_csinl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_sinh(__complex__ _Float128 __z) { return __builtin_csinhl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_sqrt(__complex__ _Float128 __z) { return __builtin_csqrtl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_tan(__complex__ _Float128 __z) { return __builtin_ctanl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_tanh(__complex__ _Float128 __z) { return __builtin_ctanhl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_pow(__complex__ _Float128 __x, __complex__ _Float128 __y)\n+  { return __builtin_cpowl(__x, __y); }\n+#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n+  inline _Float128\n+  __complex_abs(__complex__ _Float128 __z) { return __builtin_cabsf128(__z); }\n+\n+  inline _Float128\n+  __complex_arg(__complex__ _Float128 __z) { return __builtin_cargf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_cos(__complex__ _Float128 __z) { return __builtin_ccosf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_cosh(__complex__ _Float128 __z) { return __builtin_ccoshf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_exp(__complex__ _Float128 __z) { return __builtin_cexpf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_log(__complex__ _Float128 __z) { return __builtin_clogf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_sin(__complex__ _Float128 __z) { return __builtin_csinf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_sinh(__complex__ _Float128 __z) { return __builtin_csinhf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_sqrt(__complex__ _Float128 __z) { return __builtin_csqrtf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_tan(__complex__ _Float128 __z) { return __builtin_ctanf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_tanh(__complex__ _Float128 __z) { return __builtin_ctanhf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_pow(__complex__ _Float128 __x, __complex__ _Float128 __y)\n+  { return __builtin_cpowf128(__x, __y); }\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __gnu_cxx::__bfloat16_t\n+  __complex_abs(__complex__ decltype(0.0bf16) __z)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_cabsf(__z)); }\n+\n+  inline __gnu_cxx::__bfloat16_t\n+  __complex_arg(__complex__ decltype(0.0bf16) __z)\n+  { return __gnu_cxx::__bfloat16_t(__builtin_cargf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_cos(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ccosf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_cosh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ccoshf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_exp(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cexpf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_log(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_clogf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_sin(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_csinf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_sinh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_csinhf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_sqrt(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_csqrtf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_tan(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ctanf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_tanh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_ctanhf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_pow(__complex__ decltype(0.0bf16) __x,\n+\t\t__complex__ decltype(0.0bf16) __y)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cpowf(__x,\n+\t\t\t\t\t\t\t\t      __y)); }\n+#endif\n+#endif\n+\n   /// 26.2.3  complex specializations\n   /// complex<float> specialization\n   template<>\n@@ -1098,8 +1359,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n #endif\n \n+#if __cplusplus > 202002L\n+      template<typename _Up>\n+\texplicit(!requires(_Up __u) { value_type{__u}; })\n+\tconstexpr complex(const complex<_Up>& __z)\n+\t: _M_value{ value_type(__z.real()), value_type(__z.imag()) } { }\n+#else\n       explicit _GLIBCXX_CONSTEXPR complex(const complex<double>&);\n       explicit _GLIBCXX_CONSTEXPR complex(const complex<long double>&);\n+#endif\n \n #if __cplusplus >= 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -1244,10 +1512,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n #endif\n \n+#if __cplusplus > 202002L\n+      template<typename _Up>\n+\texplicit(!requires(_Up __u) { value_type{__u}; })\n+\tconstexpr complex(const complex<_Up>& __z)\n+\t: _M_value{ value_type(__z.real()), value_type(__z.imag()) } { }\n+#else\n       _GLIBCXX_CONSTEXPR complex(const complex<float>& __z)\n       : _M_value(__z.__rep()) { }\n \n       explicit _GLIBCXX_CONSTEXPR complex(const complex<long double>&);\n+#endif\n \n #if __cplusplus >= 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -1391,11 +1666,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n #endif\n \n+#if __cplusplus > 202002L\n+      template<typename _Up>\n+\texplicit(!requires(_Up __u) { value_type{__u}; })\n+\tconstexpr complex(const complex<_Up>& __z)\n+\t: _M_value{ value_type(__z.real()), value_type(__z.imag()) } { }\n+#else\n       _GLIBCXX_CONSTEXPR complex(const complex<float>& __z)\n       : _M_value(__z.__rep()) { }\n \n       _GLIBCXX_CONSTEXPR complex(const complex<double>& __z)\n       : _M_value(__z.__rep()) { }\n+#endif\n \n #if __cplusplus >= 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -1517,6 +1799,161 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _ComplexT _M_value;\n     };\n \n+#if __cplusplus > 202002L\n+  template<typename _Tp>\n+    struct __complex_type\n+    { };\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+  template<>\n+    struct __complex_type<_Float16>\n+    { typedef __complex__ _Float16 type; };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT32_T__\n+  template<>\n+    struct __complex_type<_Float32>\n+    { typedef __complex__ _Float32 type; };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT64_T__\n+  template<>\n+    struct __complex_type<_Float64>\n+    { typedef __complex__ _Float64 type; };\n+#endif\n+\n+#ifdef __STDCPP_FLOAT128_T__\n+  template<>\n+    struct __complex_type<_Float128>\n+    { typedef __complex__ _Float128 type; };\n+#endif\n+\n+#ifdef __STDCPP_BFLOAT16_T__\n+  template<>\n+    struct __complex_type<__gnu_cxx::__bfloat16_t>\n+    { typedef __complex__ decltype(0.0bf16) type; };\n+#endif\n+\n+  template<typename _Tp>\n+    requires(__complex_type<_Tp>::type)\n+    class complex<_Tp>\n+    {\n+    public:\n+      typedef _Tp value_type;\n+      typedef std::__complex_type<_Tp>::type _ComplexT;\n+\n+      constexpr complex(_ComplexT __z) : _M_value(__z) { }\n+\n+      constexpr complex(_Tp __r = _Tp(), _Tp __i = _Tp())\n+      : _M_value{ __r, __i } { }\n+\n+      template<typename _Up>\n+\texplicit(!requires(_Up __u) { value_type{__u}; })\n+\tconstexpr complex(const complex<_Up>& __z)\n+\t: _M_value{ value_type(__z.real()), value_type(__z.imag()) } { }\n+\n+      constexpr _Tp\n+      real() const { return __real__ _M_value; }\n+\n+      constexpr _Tp\n+      imag() const { return __imag__ _M_value; }\n+\n+      constexpr void\n+      real(_Tp __val) { __real__ _M_value = __val; }\n+\n+      constexpr void\n+      imag(_Tp __val) { __imag__ _M_value = __val; }\n+\n+      constexpr complex&\n+      operator=(_Tp __f)\n+      {\n+\t_M_value = __f;\n+\treturn *this;\n+      }\n+\n+      constexpr complex&\n+      operator+=(_Tp __f)\n+      {\n+\t_M_value += __f;\n+\treturn *this;\n+      }\n+\n+      constexpr complex&\n+      operator-=(_Tp __f)\n+      {\n+\t_M_value -= __f;\n+\treturn *this;\n+      }\n+\n+      constexpr complex&\n+      operator*=(_Tp __f)\n+      {\n+\t_M_value *= __f;\n+\treturn *this;\n+      }\n+\n+      constexpr complex&\n+      operator/=(_Tp __f)\n+      {\n+\t_M_value /= __f;\n+\treturn *this;\n+      }\n+\n+      // Let the compiler synthesize the copy and assignment\n+      // operator.  It always does a pretty good job.\n+      constexpr complex& operator=(const complex&) = default;\n+\n+      template<typename _Up>\n+\tconstexpr complex&\n+\toperator=(const complex<_Up>&  __z)\n+\t{\n+\t  __real__ _M_value = __z.real();\n+\t  __imag__ _M_value = __z.imag();\n+\t  return *this;\n+\t}\n+\n+      template<typename _Up>\n+\tconstexpr complex&\n+\toperator+=(const complex<_Up>& __z)\n+\t{\n+\t  _M_value += __z.__rep();\n+\t  return *this;\n+\t}\n+\n+      template<class _Up>\n+\tconstexpr complex&\n+\toperator-=(const complex<_Up>& __z)\n+\t{\n+\t  _M_value -= __z.__rep();\n+\t  return *this;\n+\t}\n+\n+      template<class _Up>\n+\tconstexpr complex&\n+\toperator*=(const complex<_Up>& __z)\n+\t{\n+\t  const _ComplexT __t = __z.__rep();\n+\t  _M_value *= __t;\n+\t  return *this;\n+\t}\n+\n+      template<class _Up>\n+\tconstexpr complex&\n+\toperator/=(const complex<_Up>& __z)\n+\t{\n+\t  const _ComplexT __t = __z.__rep();\n+\t  _M_value /= __t;\n+\t  return *this;\n+\t}\n+\n+      constexpr _ComplexT __rep() const { return _M_value; }\n+\n+    private:\n+      _ComplexT _M_value;\n+    };\n+#endif\n+\n+#if __cplusplus <= 202002L\n   // These bits have to be at the end of this file, so that the\n   // specializations have all been defined.\n   inline _GLIBCXX_CONSTEXPR\n@@ -1530,6 +1967,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   inline _GLIBCXX_CONSTEXPR\n   complex<double>::complex(const complex<long double>& __z)\n   : _M_value(__z.__rep()) { }\n+#endif\n \n   // Inhibit implicit instantiations for required instantiations,\n   // which are defined via explicit instantiations elsewhere.\n@@ -1809,6 +2247,162 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __complex_atanh(__z); }\n #endif\n \n+#if _GLIBCXX_USE_C99_COMPLEX_TR1\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __complex__ _Float16\n+  __complex_acos(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_cacosf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_asin(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_casinf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_atan(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_catanf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_acosh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_cacoshf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_asinh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_casinhf(__z)); }\n+\n+  inline __complex__ _Float16\n+  __complex_atanh(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_catanhf(__z)); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __complex__ _Float32\n+  __complex_acos(__complex__ _Float32 __z)\n+  { return __builtin_cacosf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_asin(__complex__ _Float32 __z)\n+  { return __builtin_casinf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_atan(__complex__ _Float32 __z)\n+  { return __builtin_catanf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_acosh(__complex__ _Float32 __z)\n+  { return __builtin_cacoshf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_asinh(__complex__ _Float32 __z)\n+  { return __builtin_casinhf(__z); }\n+\n+  inline __complex__ _Float32\n+  __complex_atanh(__complex__ _Float32 __z)\n+  { return __builtin_catanhf(__z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  inline __complex__ _Float64\n+  __complex_acos(__complex__ _Float64 __z)\n+  { return __builtin_cacos(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_asin(__complex__ _Float64 __z)\n+  { return __builtin_casin(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_atan(__complex__ _Float64 __z)\n+  { return __builtin_catan(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_acosh(__complex__ _Float64 __z)\n+  { return __builtin_cacosh(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_asinh(__complex__ _Float64 __z)\n+  { return __builtin_casinh(__z); }\n+\n+  inline __complex__ _Float64\n+  __complex_atanh(__complex__ _Float64 __z)\n+  { return __builtin_catanh(__z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  inline __complex__ _Float128\n+  __complex_acos(__complex__ _Float128 __z)\n+  { return __builtin_cacosl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_asin(__complex__ _Float128 __z)\n+  { return __builtin_casinl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_atan(__complex__ _Float128 __z)\n+  { return __builtin_catanl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_acosh(__complex__ _Float128 __z)\n+  { return __builtin_cacoshl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_asinh(__complex__ _Float128 __z)\n+  { return __builtin_casinhl(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_atanh(__complex__ _Float128 __z)\n+  { return __builtin_catanhl(__z); }\n+#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n+  inline __complex__ _Float128\n+  __complex_acos(__complex__ _Float128 __z)\n+  { return __builtin_cacosf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_asin(__complex__ _Float128 __z)\n+  { return __builtin_casinf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_atan(__complex__ _Float128 __z)\n+  { return __builtin_catanf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_acosh(__complex__ _Float128 __z)\n+  { return __builtin_cacoshf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_asinh(__complex__ _Float128 __z)\n+  { return __builtin_casinhf128(__z); }\n+\n+  inline __complex__ _Float128\n+  __complex_atanh(__complex__ _Float128 __z)\n+  { return __builtin_catanhf128(__z); }\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_acos(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cacosf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_asin(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_casinf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_atan(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_catanf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_acosh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cacoshf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_asinh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_casinhf(__z)); }\n+\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_atanh(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_catanhf(__z)); }\n+#endif\n+#endif\n+\n   template<typename _Tp>\n     inline _Tp\n     /// fabs(__z) [8.1.8].\n@@ -1897,6 +2491,49 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   inline complex<long double>\n   __complex_proj(const complex<long double>& __z)\n   { return __builtin_cprojl(__z.__rep()); }\n+\n+#if __cplusplus > 202002L\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __complex__ _Float16\n+  __complex_proj(__complex__ _Float16 __z)\n+  { return static_cast<__complex__ _Float16>(__builtin_cprojf(__z)); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __complex__ _Float32\n+  __complex_proj(__complex__ _Float32 __z)\n+  { return __builtin_cprojf(__z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  inline __complex__ _Float64\n+  __complex_proj(__complex__ _Float64 __z)\n+  { return __builtin_cproj(__z); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  inline __complex__ _Float128\n+  __complex_proj(__complex__ _Float128 __z)\n+  { return __builtin_cprojl(__z); }\n+#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n+  inline __complex__ _Float128\n+  __complex_proj(__complex__ _Float128 __z)\n+  { return __builtin_cprojf128(__z); }\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline __complex__ decltype(0.0bf16)\n+  __complex_proj(__complex__ decltype(0.0bf16) __z)\n+  { return static_cast<__complex__ decltype(0.0bf16)>(__builtin_cprojf(__z)); }\n+#endif\n+\n+  template<typename _Tp>\n+    requires(__complex_type<_Tp>::type)\n+    inline complex<_Tp>\n+    __complex_proj(const complex<_Tp>& __z)\n+    { return __complex_proj(__z.__rep()); }\n+#endif\n+\n #elif defined _GLIBCXX_USE_C99_MATH_TR1\n   inline complex<float>\n   __complex_proj(const complex<float>& __z)"}, {"sha": "bdc9af016c77a9ecb77808b1bc1c117af7a0dfb1", "filename": "libstdc++-v3/testsuite/26_numerics/complex/ext_c++23.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db55f1dda2692c3f778ae783bc7121891c79aec4/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fext_c%2B%2B23.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db55f1dda2692c3f778ae783bc7121891c79aec4/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fext_c%2B%2B23.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fext_c%2B%2B23.cc?ref=db55f1dda2692c3f778ae783bc7121891c79aec4", "patch": "@@ -0,0 +1,89 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2b\" }\n+// { dg-do link { target c++23 } }\n+\n+#include <stdfloat>\n+#include <complex>\n+\n+template <typename T>\n+__attribute__((__noipa__)) void\n+test_functions(T *p, std::complex<T> *q)\n+{\n+  p[0] = std::abs(q[0]);\n+  p[1] = std::arg(q[1]);\n+  q[2] = std::cos(q[2]);\n+  q[3] = std::cosh(q[3]);\n+  q[4] = std::exp(q[4]);\n+  q[5] = std::log(q[5]);\n+  q[6] = std::sin(q[6]);\n+  q[7] = std::sinh(q[7]);\n+  q[8] = std::sqrt(q[8]);\n+  q[9] = std::tan(q[9]);\n+  q[10] = std::tanh(q[10]);\n+  q[11] = std::pow(q[11], q[19]);\n+  q[12] = std::acos(q[12]);\n+  q[13] = std::asin(q[13]);\n+  q[14] = std::atan(q[14]);\n+  q[15] = std::acosh(q[15]);\n+  q[16] = std::asinh(q[16]);\n+  q[17] = std::atanh(q[17]);\n+  q[18] = std::proj(q[18]);\n+}\n+\n+int\n+main()\n+{\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  {\n+    std::float16_t p[2] = {};\n+    std::complex<std::float16_t> q[20] = {};\n+    test_functions(p, q);\n+  }\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  {\n+    std::float32_t p[2] = {};\n+    std::complex<std::float32_t> q[20] = {};\n+    test_functions(p, q);\n+  }\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  {\n+    std::float64_t p[2] = {};\n+    std::complex<std::float64_t> q[20] = {};\n+    test_functions(p, q);\n+  }\n+#endif\n+#if defined(__STDCPP_FLOAT128_T__) \\\n+    && (defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY128) \\\n+\t|| defined(_GLIBCXX_HAVE_FLOAT128_MATH))\n+  {\n+    std::float128_t p[2] = {};\n+    std::complex<std::float128_t> q[20] = {};\n+    test_functions(p, q);\n+  }\n+#endif\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  {\n+    std::bfloat16_t p[2] = {};\n+    std::complex<std::bfloat16_t> q[20] = {};\n+    test_functions(p, q);\n+  }\n+#endif\n+}"}]}