{"sha": "403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAzZjIyYWFlNWI2ZTRlOGYwZTUwYjg5YjQxYTgyYWFmOTEwOTMxZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-05-14T20:08:11Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-05-14T20:08:11Z"}, "message": "Handle TYPE_HAS_LATE_RETURN_TYPE like ref-qualifier and eh spec.\n\n\t* tree.c (build_cp_fntype_variant): New.\n\t(build_ref_qualified_type, build_exception_variant)\n\t(strip_typedefs, cxx_copy_lang_qualifiers): Use it.\n\t(cxx_type_hash_eq, cp_check_qualified_type): Check\n\tTYPE_HAS_LATE_RETURN_TYPE.\n\t(cp_build_type_attribute_variant): Check cxx_type_hash_eq.\n\t(cp_build_qualified_type_real): No need to preserve C++ qualifiers.\n\t* class.c (build_clone): Use cxx_copy_lang_qualifiers.\n\t(adjust_clone_args): Likewise.\n\t* decl.c (grokfndecl): Add late_return_type_p parameter.  Use\n\tbuild_cp_fntype_variant.\n\t(grokdeclarator): Pass late_return_type_p to grokfndecl.\n\t(check_function_type): Use cxx_copy_lang_qualifiers.\n\t(static_fn_type): Use cxx_copy_lang_qualifiers.\n\t* decl2.c (build_memfn_type, maybe_retrofit_in_chrg)\n\t(cp_reconstruct_complex_type, coerce_new_type, coerce_delete_type)\n\t(change_return_type): Use cxx_copy_lang_qualifiers.\n\t* mangle.c (write_type): Use cxx_copy_lang_qualifiers.\n\t* parser.c (cp_parser_lambda_declarator_opt): Represent an explicit\n\treturn type on the declarator like a normal trailing return type.\n\t* pt.c (tsubst_function_type): Use build_cp_fntype_variant.\n\t(copy_default_args_to_explicit_spec): Use cxx_copy_lang_qualifiers.\n\t* typeck.c (merge_types): Use build_cp_fntype_variant.\n\nFrom-SVN: r260238", "tree": {"sha": "44823e1213f902339f160615a5c9aef85d4f9e09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44823e1213f902339f160615a5c9aef85d4f9e09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc05c538c95025b0ac7c7d7313666e2f7550d548", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc05c538c95025b0ac7c7d7313666e2f7550d548", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc05c538c95025b0ac7c7d7313666e2f7550d548"}], "stats": {"total": 384, "additions": 155, "deletions": 229}, "files": [{"sha": "27ff8f353b98bae80ae2024041939471d8427640", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "patch": "@@ -1,3 +1,30 @@\n+2018-05-14  Jason Merrill  <jason@redhat.com>\n+\n+\tHandle TYPE_HAS_LATE_RETURN_TYPE like ref-qualifier and eh spec.\n+\t* tree.c (build_cp_fntype_variant): New.\n+\t(build_ref_qualified_type, build_exception_variant)\n+\t(strip_typedefs, cxx_copy_lang_qualifiers): Use it.\n+\t(cxx_type_hash_eq, cp_check_qualified_type): Check\n+\tTYPE_HAS_LATE_RETURN_TYPE.\n+\t(cp_build_type_attribute_variant): Check cxx_type_hash_eq.\n+\t(cp_build_qualified_type_real): No need to preserve C++ qualifiers.\n+\t* class.c (build_clone): Use cxx_copy_lang_qualifiers.\n+\t(adjust_clone_args): Likewise.\n+\t* decl.c (grokfndecl): Add late_return_type_p parameter.  Use\n+\tbuild_cp_fntype_variant.\n+\t(grokdeclarator): Pass late_return_type_p to grokfndecl.\n+\t(check_function_type): Use cxx_copy_lang_qualifiers.\n+\t(static_fn_type): Use cxx_copy_lang_qualifiers.\n+\t* decl2.c (build_memfn_type, maybe_retrofit_in_chrg)\n+\t(cp_reconstruct_complex_type, coerce_new_type, coerce_delete_type)\n+\t(change_return_type): Use cxx_copy_lang_qualifiers.\n+\t* mangle.c (write_type): Use cxx_copy_lang_qualifiers.\n+\t* parser.c (cp_parser_lambda_declarator_opt): Represent an explicit\n+\treturn type on the declarator like a normal trailing return type.\n+\t* pt.c (tsubst_function_type): Use build_cp_fntype_variant.\n+\t(copy_default_args_to_explicit_spec): Use cxx_copy_lang_qualifiers.\n+\t* typeck.c (merge_types): Use build_cp_fntype_variant.\n+\n 2018-05-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* cp-tree.h (TYPE_REF_P): New."}, {"sha": "306ee294d8ab8c3eed08a2adb2ccb63b734a7006", "filename": "gcc/cp/class.c", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "patch": "@@ -4469,13 +4469,8 @@ build_clone (tree fn, tree name)\n      type.  */\n   if (DECL_HAS_IN_CHARGE_PARM_P (clone))\n     {\n-      tree basetype;\n-      tree parmtypes;\n-      tree exceptions;\n-\n-      exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (clone));\n-      basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (clone));\n-      parmtypes = TYPE_ARG_TYPES (TREE_TYPE (clone));\n+      tree basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (clone));\n+      tree parmtypes = TYPE_ARG_TYPES (TREE_TYPE (clone));\n       /* Skip the `this' parameter.  */\n       parmtypes = TREE_CHAIN (parmtypes);\n       /* Skip the in-charge parameter.  */\n@@ -4494,12 +4489,11 @@ build_clone (tree fn, tree name)\n \t= build_method_type_directly (basetype,\n \t\t\t\t      TREE_TYPE (TREE_TYPE (clone)),\n \t\t\t\t      parmtypes);\n-      if (exceptions)\n-\tTREE_TYPE (clone) = build_exception_variant (TREE_TYPE (clone),\n-\t\t\t\t\t\t     exceptions);\n       TREE_TYPE (clone)\n \t= cp_build_type_attribute_variant (TREE_TYPE (clone),\n \t\t\t\t\t   TYPE_ATTRIBUTES (TREE_TYPE (fn)));\n+      TREE_TYPE (clone)\n+\t= cxx_copy_lang_qualifiers (TREE_TYPE (clone), TREE_TYPE (fn));\n     }\n \n   /* Copy the function parameters.  */\n@@ -4687,11 +4681,6 @@ adjust_clone_args (tree decl)\n \t    {\n \t      /* A default parameter has been added. Adjust the\n \t\t clone's parameters.  */\n-\t      tree exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (clone));\n-\t      tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (clone));\n-\t      tree basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (clone));\n-\t      tree type;\n-\n \t      clone_parms = orig_decl_parms;\n \n \t      if (DECL_HAS_VTT_PARM_P (clone))\n@@ -4701,13 +4690,15 @@ adjust_clone_args (tree decl)\n \t\t\t\t\t   clone_parms);\n \t\t  TREE_TYPE (clone_parms) = TREE_TYPE (orig_clone_parms);\n \t\t}\n-\t      type = build_method_type_directly (basetype,\n-\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (clone)),\n-\t\t\t\t\t\t clone_parms);\n-\t      if (exceptions)\n-\t\ttype = build_exception_variant (type, exceptions);\n-\t      if (attrs)\n+\n+\t      tree basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (clone));\n+\t      tree type\n+\t\t= build_method_type_directly (basetype,\n+\t\t\t\t\t      TREE_TYPE (TREE_TYPE (clone)),\n+\t\t\t\t\t      clone_parms);\n+\t      if (tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (clone)))\n \t\ttype = cp_build_type_attribute_variant (type, attrs);\n+\t      type = cxx_copy_lang_qualifiers (type, TREE_TYPE (clone));\n \t      TREE_TYPE (clone) = type;\n \n \t      clone_parms = NULL_TREE;"}, {"sha": "398f7adc05112bd43d45fefb390d4eb09c0d0448", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "patch": "@@ -7103,6 +7103,7 @@ extern tree ovl_scope\t\t\t\t(tree);\n extern const char *cxx_printable_name\t\t(tree, int);\n extern const char *cxx_printable_name_translate\t(tree, int);\n extern tree canonical_eh_spec\t\t\t(tree);\n+extern tree build_cp_fntype_variant\t\t(tree, cp_ref_qualifier, tree, bool);\n extern tree build_exception_variant\t\t(tree, tree);\n extern tree bind_template_template_parm\t\t(tree, tree);\n extern tree array_type_nelts_total\t\t(tree);\n@@ -7262,7 +7263,8 @@ extern tree build_ptrmemfunc\t\t\t(tree, tree, int, bool,\n extern int cp_type_quals\t\t\t(const_tree);\n extern int type_memfn_quals\t\t\t(const_tree);\n extern cp_ref_qualifier type_memfn_rqual\t(const_tree);\n-extern tree apply_memfn_quals\t\t\t(tree, cp_cv_quals, cp_ref_qualifier);\n+extern tree apply_memfn_quals\t\t\t(tree, cp_cv_quals,\n+\t\t\t\t\t\t cp_ref_qualifier = REF_QUAL_NONE);\n extern bool cp_has_mutable_p\t\t\t(const_tree);\n extern bool at_least_as_qualified_p\t\t(const_tree, const_tree);\n extern void cp_apply_type_quals_to_decl\t\t(int, tree);"}, {"sha": "92639a886a1714b8d4d2fac78ed145ce983048f7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "patch": "@@ -8592,6 +8592,7 @@ grokfndecl (tree ctype,\n \t    bool deletedp,\n \t    special_function_kind sfk,\n \t    bool funcdef_flag,\n+\t    bool late_return_type_p,\n \t    int template_count,\n \t    tree in_namespace,\n \t    tree* attrlist,\n@@ -8611,10 +8612,7 @@ grokfndecl (tree ctype,\n       return NULL_TREE;\n     }\n \n-  if (rqual)\n-    type = build_ref_qualified_type (type, rqual);\n-  if (raises)\n-    type = build_exception_variant (type, raises);\n+  type = build_cp_fntype_variant (type, rqual, raises, late_return_type_p);\n \n   decl = build_lang_decl (FUNCTION_DECL, declarator, type);\n \n@@ -12136,9 +12134,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t    publicp = (! friendp || ! staticp)\n \t      && function_context == NULL_TREE;\n \n-\t    if (late_return_type_p)\n-\t      TYPE_HAS_LATE_RETURN_TYPE (type) = 1;\n-\n \t    decl = grokfndecl (ctype, type,\n \t\t\t       TREE_CODE (unqualified_id) != TEMPLATE_ID_EXPR\n \t\t\t       ? unqualified_id : dname,\n@@ -12149,7 +12144,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t       friendp ? -1 : 0, friendp, publicp,\n                                inlinep | (2 * constexpr_p) | (4 * concept_p),\n \t\t\t       initialized == SD_DELETED, sfk,\n-\t\t\t       funcdef_flag, template_count, in_namespace,\n+\t\t\t       funcdef_flag, late_return_type_p,\n+\t\t\t       template_count, in_namespace,\n \t\t\t       attrlist, declarator->id_loc);\n             decl = set_virt_specifiers (decl, virt_specifiers);\n \t    if (decl == NULL_TREE)\n@@ -12386,9 +12382,6 @@ grokdeclarator (const cp_declarator *declarator,\n \tpublicp = (ctype != NULL_TREE\n \t\t   || storage_class != sc_static);\n \n-\tif (late_return_type_p)\n-\t  TYPE_HAS_LATE_RETURN_TYPE (type) = 1;\n-\n \tdecl = grokfndecl (ctype, type, original_name, parms, unqualified_id,\n                            reqs, virtualp, flags, memfn_quals, rqual, raises,\n \t\t\t   1, friendp,\n@@ -12397,6 +12390,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t   initialized == SD_DELETED,\n                            sfk,\n                            funcdef_flag,\n+\t\t\t   late_return_type_p,\n \t\t\t   template_count, in_namespace, attrlist,\n \t\t\t   declarator->id_loc);\n \tif (decl == NULL_TREE)\n@@ -14753,11 +14747,9 @@ check_function_type (tree decl, tree current_function_parms)\n \t\t\t\t\t     TREE_CHAIN (args));\n       else\n \tfntype = build_function_type (void_type_node, args);\n-      fntype\n-\t= build_exception_variant (fntype,\n-\t\t\t\t   TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl)));\n       fntype = (cp_build_type_attribute_variant\n \t\t(fntype, TYPE_ATTRIBUTES (TREE_TYPE (decl))));\n+      fntype = cxx_copy_lang_qualifiers (fntype, TREE_TYPE (decl));\n       TREE_TYPE (decl) = fntype;\n     }\n   else\n@@ -16161,15 +16153,11 @@ static_fn_type (tree memfntype)\n     return memfntype;\n   gcc_assert (TREE_CODE (memfntype) == METHOD_TYPE);\n   args = TYPE_ARG_TYPES (memfntype);\n-  cp_ref_qualifier rqual = type_memfn_rqual (memfntype);\n   fntype = build_function_type (TREE_TYPE (memfntype), TREE_CHAIN (args));\n-  fntype = apply_memfn_quals (fntype, type_memfn_quals (memfntype), rqual);\n+  fntype = apply_memfn_quals (fntype, type_memfn_quals (memfntype));\n   fntype = (cp_build_type_attribute_variant\n \t    (fntype, TYPE_ATTRIBUTES (memfntype)));\n-  fntype = (build_exception_variant\n-\t    (fntype, TYPE_RAISES_EXCEPTIONS (memfntype)));\n-  if (TYPE_HAS_LATE_RETURN_TYPE (memfntype))\n-    TYPE_HAS_LATE_RETURN_TYPE (fntype) = 1;\n+  fntype = cxx_copy_lang_qualifiers (fntype, memfntype);\n   return fntype;\n }\n "}, {"sha": "14a3cddacb8822f98dcb7399bc1094cc44d3289b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 28, "deletions": 54, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "patch": "@@ -155,36 +155,27 @@ tree\n build_memfn_type (tree fntype, tree ctype, cp_cv_quals quals,\n \t\t  cp_ref_qualifier rqual)\n {\n-  tree raises;\n-  tree attrs;\n-  int type_quals;\n-  bool late_return_type_p;\n-\n   if (fntype == error_mark_node || ctype == error_mark_node)\n     return error_mark_node;\n \n   gcc_assert (TREE_CODE (fntype) == FUNCTION_TYPE\n \t      || TREE_CODE (fntype) == METHOD_TYPE);\n \n-  type_quals = quals & ~TYPE_QUAL_RESTRICT;\n+  cp_cv_quals type_quals = quals & ~TYPE_QUAL_RESTRICT;\n   ctype = cp_build_qualified_type (ctype, type_quals);\n-  raises = TYPE_RAISES_EXCEPTIONS (fntype);\n-  attrs = TYPE_ATTRIBUTES (fntype);\n-  late_return_type_p = TYPE_HAS_LATE_RETURN_TYPE (fntype);\n-  fntype = build_method_type_directly (ctype, TREE_TYPE (fntype),\n-\t\t\t\t       (TREE_CODE (fntype) == METHOD_TYPE\n-\t\t\t\t\t? TREE_CHAIN (TYPE_ARG_TYPES (fntype))\n-\t\t\t\t\t: TYPE_ARG_TYPES (fntype)));\n-  if (attrs)\n-    fntype = cp_build_type_attribute_variant (fntype, attrs);\n-  if (rqual)\n-    fntype = build_ref_qualified_type (fntype, rqual);\n-  if (raises)\n-    fntype = build_exception_variant (fntype, raises);\n-  if (late_return_type_p)\n-    TYPE_HAS_LATE_RETURN_TYPE (fntype) = 1;\n-\n-  return fntype;\n+\n+  tree newtype\n+    = build_method_type_directly (ctype, TREE_TYPE (fntype),\n+\t\t\t\t  (TREE_CODE (fntype) == METHOD_TYPE\n+\t\t\t\t   ? TREE_CHAIN (TYPE_ARG_TYPES (fntype))\n+\t\t\t\t   : TYPE_ARG_TYPES (fntype)));\n+  if (tree attrs = TYPE_ATTRIBUTES (fntype))\n+    newtype = cp_build_type_attribute_variant (newtype, attrs);\n+  newtype = build_cp_fntype_variant (newtype, rqual,\n+\t\t\t\t     TYPE_RAISES_EXCEPTIONS (fntype),\n+\t\t\t\t     TYPE_HAS_LATE_RETURN_TYPE (fntype));\n+\n+  return newtype;\n }\n \n /* Return a variant of FNTYPE, a FUNCTION_TYPE or METHOD_TYPE, with its\n@@ -193,36 +184,28 @@ build_memfn_type (tree fntype, tree ctype, cp_cv_quals quals,\n tree\n change_return_type (tree new_ret, tree fntype)\n {\n-  tree newtype;\n-  tree args = TYPE_ARG_TYPES (fntype);\n-  tree raises = TYPE_RAISES_EXCEPTIONS (fntype);\n-  tree attrs = TYPE_ATTRIBUTES (fntype);\n-  bool late_return_type_p = TYPE_HAS_LATE_RETURN_TYPE (fntype);\n-\n   if (new_ret == error_mark_node)\n     return fntype;\n \n   if (same_type_p (new_ret, TREE_TYPE (fntype)))\n     return fntype;\n \n+  tree newtype;\n+  tree args = TYPE_ARG_TYPES (fntype);\n+\n   if (TREE_CODE (fntype) == FUNCTION_TYPE)\n     {\n       newtype = build_function_type (new_ret, args);\n       newtype = apply_memfn_quals (newtype,\n-\t\t\t\t   type_memfn_quals (fntype),\n-\t\t\t\t   type_memfn_rqual (fntype));\n+\t\t\t\t   type_memfn_quals (fntype));\n     }\n   else\n     newtype = build_method_type_directly\n       (class_of_this_parm (fntype), new_ret, TREE_CHAIN (args));\n-  if (FUNCTION_REF_QUALIFIED (fntype))\n-    newtype = build_ref_qualified_type (newtype, type_memfn_rqual (fntype));\n-  if (raises)\n-    newtype = build_exception_variant (newtype, raises);\n-  if (attrs)\n+\n+  if (tree attrs = TYPE_ATTRIBUTES (fntype))\n     newtype = cp_build_type_attribute_variant (newtype, attrs);\n-  if (late_return_type_p)\n-    TYPE_HAS_LATE_RETURN_TYPE (newtype) = 1;\n+  newtype = cxx_copy_lang_qualifiers (newtype, fntype);\n \n   return newtype;\n }\n@@ -326,12 +309,10 @@ maybe_retrofit_in_chrg (tree fn)\n   /* And rebuild the function type.  */\n   fntype = build_method_type_directly (basetype, TREE_TYPE (TREE_TYPE (fn)),\n \t\t\t\t       arg_types);\n-  if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn)))\n-    fntype = build_exception_variant (fntype,\n-\t\t\t\t      TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn)));\n   if (TYPE_ATTRIBUTES (TREE_TYPE (fn)))\n     fntype = (cp_build_type_attribute_variant\n \t      (fntype, TYPE_ATTRIBUTES (TREE_TYPE (fn))));\n+  fntype = cxx_copy_lang_qualifiers (fntype, TREE_TYPE (fn));\n   TREE_TYPE (fn) = fntype;\n \n   /* Now we've got the in-charge parameter.  */\n@@ -1337,7 +1318,6 @@ tree\n cp_reconstruct_complex_type (tree type, tree bottom)\n {\n   tree inner, outer;\n-  bool late_return_type_p = false;\n \n   if (TYPE_PTR_P (type))\n     {\n@@ -1363,16 +1343,12 @@ cp_reconstruct_complex_type (tree type, tree bottom)\n     }\n   else if (TREE_CODE (type) == FUNCTION_TYPE)\n     {\n-      late_return_type_p = TYPE_HAS_LATE_RETURN_TYPE (type);\n       inner = cp_reconstruct_complex_type (TREE_TYPE (type), bottom);\n       outer = build_function_type (inner, TYPE_ARG_TYPES (type));\n-      outer = apply_memfn_quals (outer,\n-\t\t\t\t type_memfn_quals (type),\n-\t\t\t\t type_memfn_rqual (type));\n+      outer = apply_memfn_quals (outer, type_memfn_quals (type));\n     }\n   else if (TREE_CODE (type) == METHOD_TYPE)\n     {\n-      late_return_type_p = TYPE_HAS_LATE_RETURN_TYPE (type);\n       inner = cp_reconstruct_complex_type (TREE_TYPE (type), bottom);\n       /* The build_method_type_directly() routine prepends 'this' to argument list,\n \t so we must compensate by getting rid of it.  */\n@@ -1392,9 +1368,7 @@ cp_reconstruct_complex_type (tree type, tree bottom)\n   if (TYPE_ATTRIBUTES (type))\n     outer = cp_build_type_attribute_variant (outer, TYPE_ATTRIBUTES (type));\n   outer = cp_build_qualified_type (outer, cp_type_quals (type));\n-\n-  if (late_return_type_p)\n-    TYPE_HAS_LATE_RETURN_TYPE (outer) = 1;\n+  outer = cxx_copy_lang_qualifiers (outer, type);\n \n   return outer;\n }\n@@ -1748,9 +1722,9 @@ coerce_new_type (tree type)\n       args = tree_cons (NULL_TREE, size_type_node, args);\n       /* Fall through.  */\n     case 1:\n-      type = build_exception_variant\n+      type = (cxx_copy_lang_qualifiers\n \t      (build_function_type (ptr_type_node, args),\n-\t       TYPE_RAISES_EXCEPTIONS (type));\n+\t       type));\n       /* Fall through.  */\n     default:;\n   }\n@@ -1786,9 +1760,9 @@ coerce_delete_type (tree type)\n       args = tree_cons (NULL_TREE, ptr_type_node, args);\n       /* Fall through.  */\n     case 1:\n-      type = build_exception_variant\n+      type = (cxx_copy_lang_qualifiers\n \t      (build_function_type (void_type_node, args),\n-\t       TYPE_RAISES_EXCEPTIONS (type));\n+\t       type));\n       /* Fall through.  */\n     default:;\n   }"}, {"sha": "387990b76a35845aa536874eee251444e83fe2bf", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "patch": "@@ -2155,11 +2155,7 @@ write_type (tree type)\n       type = TYPE_MAIN_VARIANT (type);\n       if (TREE_CODE (type) == FUNCTION_TYPE\n \t  || TREE_CODE (type) == METHOD_TYPE)\n-\t{\n-\t  type = build_ref_qualified_type (type, type_memfn_rqual (type_orig));\n-\t  type = build_exception_variant (type,\n-\t\t\t\t\t  TYPE_RAISES_EXCEPTIONS (type_orig));\n-\t}\n+\ttype = cxx_copy_lang_qualifiers (type, type_orig);\n \n       /* According to the C++ ABI, some library classes are passed the\n \t same as the scalar type of their single member and use the same"}, {"sha": "c0058085ee924820f950d1524c247fd2eb16bb09", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "patch": "@@ -10563,11 +10563,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n     void *p;\n \n     clear_decl_specs (&return_type_specs);\n-    if (return_type)\n-      return_type_specs.type = return_type;\n-    else\n-      /* Maybe we will deduce the return type later.  */\n-      return_type_specs.type = make_auto ();\n+    return_type_specs.type = make_auto ();\n \n     if (lambda_specs.locations[ds_constexpr])\n       {\n@@ -10593,6 +10589,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n                                        /*late_return_type=*/NULL_TREE,\n                                        /*requires_clause*/NULL_TREE);\n     declarator->id_loc = LAMBDA_EXPR_LOCATION (lambda_expr);\n+    if (return_type)\n+      declarator->u.function.late_return_type = return_type;\n \n     fco = grokmethod (&return_type_specs,\n \t\t      declarator,\n@@ -10603,8 +10601,6 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \tDECL_ARTIFICIAL (fco) = 1;\n \t/* Give the object parameter a different name.  */\n \tDECL_NAME (DECL_ARGUMENTS (fco)) = get_identifier (\"__closure\");\n-\tif (return_type)\n-\t  TYPE_HAS_LATE_RETURN_TYPE (TREE_TYPE (fco)) = 1;\n       }\n     if (template_param_list)\n       {"}, {"sha": "1e4204043bb6e1c9a1cc8ca412ffeb3ca73d0565", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "patch": "@@ -2528,11 +2528,7 @@ copy_default_args_to_explicit_spec (tree decl)\n \t\t\t\t    new_spec_types);\n   new_type = cp_build_type_attribute_variant (new_type,\n \t\t\t\t\t      TYPE_ATTRIBUTES (old_type));\n-  new_type = build_exception_variant (new_type,\n-\t\t\t\t      TYPE_RAISES_EXCEPTIONS (old_type));\n-\n-  if (TYPE_HAS_LATE_RETURN_TYPE (old_type))\n-    TYPE_HAS_LATE_RETURN_TYPE (new_type) = 1;\n+  new_type = cxx_copy_lang_qualifiers (new_type, old_type);\n \n   TREE_TYPE (decl) = new_type;\n }\n@@ -14020,9 +14016,7 @@ tsubst_function_type (tree t,\n   if (TREE_CODE (t) == FUNCTION_TYPE)\n     {\n       fntype = build_function_type (return_type, arg_types);\n-      fntype = apply_memfn_quals (fntype,\n-\t\t\t\t  type_memfn_quals (t),\n-\t\t\t\t  type_memfn_rqual (t));\n+      fntype = apply_memfn_quals (fntype, type_memfn_quals (t));\n     }\n   else\n     {\n@@ -14046,12 +14040,13 @@ tsubst_function_type (tree t,\n \n       fntype = build_method_type_directly (r, return_type,\n \t\t\t\t\t   TREE_CHAIN (arg_types));\n-      fntype = build_ref_qualified_type (fntype, type_memfn_rqual (t));\n     }\n   fntype = cp_build_type_attribute_variant (fntype, TYPE_ATTRIBUTES (t));\n \n-  if (late_return_type_p)\n-    TYPE_HAS_LATE_RETURN_TYPE (fntype) = 1;\n+  /* See comment above.  */\n+  tree raises = NULL_TREE;\n+  cp_ref_qualifier rqual = type_memfn_rqual (t);\n+  fntype = build_cp_fntype_variant (fntype, rqual, raises, late_return_type_p);\n \n   return fntype;\n }"}, {"sha": "463a06d83707e32c51d42da3ecbf2fb56b646119", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 55, "deletions": 90, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "patch": "@@ -1299,15 +1299,6 @@ cp_build_qualified_type_real (tree type,\n   /* Retrieve (or create) the appropriately qualified variant.  */\n   result = build_qualified_type (type, type_quals);\n \n-  /* Preserve exception specs and ref-qualifier since build_qualified_type\n-     doesn't know about them.  */\n-  if (TREE_CODE (result) == FUNCTION_TYPE\n-      || TREE_CODE (result) == METHOD_TYPE)\n-    {\n-      result = build_exception_variant (result, TYPE_RAISES_EXCEPTIONS (type));\n-      result = build_ref_qualified_type (result, type_memfn_rqual (type));\n-    }\n-\n   return result;\n }\n \n@@ -1535,22 +1526,16 @@ strip_typedefs (tree t, bool *remove_attributes)\n \t    result =\n \t      build_method_type_directly (class_type, type,\n \t\t\t\t\t  TREE_CHAIN (arg_types));\n-\t    result\n-\t      = build_ref_qualified_type (result, type_memfn_rqual (t));\n \t  }\n \telse\n \t  {\n-\t    result = build_function_type (type,\n-\t\t\t\t\t  arg_types);\n-\t    result = apply_memfn_quals (result,\n-\t\t\t\t\ttype_memfn_quals (t),\n-\t\t\t\t\ttype_memfn_rqual (t));\n+\t    result = build_function_type (type, arg_types);\n+\t    result = apply_memfn_quals (result, type_memfn_quals (t));\n \t  }\n \n-\tif (canon_spec)\n-\t  result = build_exception_variant (result, canon_spec);\n-\tif (TYPE_HAS_LATE_RETURN_TYPE (t))\n-\t  TYPE_HAS_LATE_RETURN_TYPE (result) = 1;\n+\tresult = build_cp_fntype_variant (result,\n+\t\t\t\t\t  type_memfn_rqual (t), canon_spec,\n+\t\t\t\t\t  TYPE_HAS_LATE_RETURN_TYPE (t));\n       }\n       break;\n     case TYPENAME_TYPE:\n@@ -2093,17 +2078,19 @@ build_qualified_name (tree type, tree scope, tree name, bool template_p)\n   return t;\n }\n \n-/* Like check_qualified_type, but also check ref-qualifier and exception\n-   specification.  */\n+/* Like check_qualified_type, but also check ref-qualifier, exception\n+   specification, and whether the return type was specified after the\n+   parameters.  */\n \n static bool\n cp_check_qualified_type (const_tree cand, const_tree base, int type_quals,\n-\t\t\t cp_ref_qualifier rqual, tree raises)\n+\t\t\t cp_ref_qualifier rqual, tree raises, bool late)\n {\n   return (TYPE_QUALS (cand) == type_quals\n \t  && check_base_type (cand, base)\n \t  && comp_except_specs (raises, TYPE_RAISES_EXCEPTIONS (cand),\n \t\t\t\tce_exact)\n+\t  && TYPE_HAS_LATE_RETURN_TYPE (cand) == late\n \t  && type_memfn_rqual (cand) == rqual);\n }\n \n@@ -2112,46 +2099,9 @@ cp_check_qualified_type (const_tree cand, const_tree base, int type_quals,\n tree\n build_ref_qualified_type (tree type, cp_ref_qualifier rqual)\n {\n-  tree t;\n-\n-  if (rqual == type_memfn_rqual (type))\n-    return type;\n-\n-  int type_quals = TYPE_QUALS (type);\n   tree raises = TYPE_RAISES_EXCEPTIONS (type);\n-  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n-    if (cp_check_qualified_type (t, type, type_quals, rqual, raises))\n-      return t;\n-\n-  t = build_variant_type_copy (type);\n-  switch (rqual)\n-    {\n-    case REF_QUAL_RVALUE:\n-      FUNCTION_RVALUE_QUALIFIED (t) = 1;\n-      FUNCTION_REF_QUALIFIED (t) = 1;\n-      break;\n-    case REF_QUAL_LVALUE:\n-      FUNCTION_RVALUE_QUALIFIED (t) = 0;\n-      FUNCTION_REF_QUALIFIED (t) = 1;\n-      break;\n-    default:\n-      FUNCTION_REF_QUALIFIED (t) = 0;\n-      break;\n-    }\n-\n-  if (TYPE_STRUCTURAL_EQUALITY_P (type))\n-    /* Propagate structural equality. */\n-    SET_TYPE_STRUCTURAL_EQUALITY (t);\n-  else if (TYPE_CANONICAL (type) != type)\n-    /* Build the underlying canonical type, since it is different\n-       from TYPE. */\n-    TYPE_CANONICAL (t) = build_ref_qualified_type (TYPE_CANONICAL (type),\n-\t\t\t\t\t\t   rqual);\n-  else\n-    /* T is its own canonical type. */\n-    TYPE_CANONICAL (t) = t;\n-\n-  return t;\n+  bool late = TYPE_HAS_LATE_RETURN_TYPE (type);\n+  return build_cp_fntype_variant (type, rqual, raises, late);\n }\n \n /* Cache of free ovl nodes.  Uses OVL_FUNCTION for chaining.  */\n@@ -2656,49 +2606,68 @@ canonical_eh_spec (tree raises)\n     return NULL_TREE;\n }\n \n-/* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions\n-   listed in RAISES.  */\n-\n tree\n-build_exception_variant (tree type, tree raises)\n+build_cp_fntype_variant (tree type, cp_ref_qualifier rqual,\n+\t\t\t tree raises, bool late)\n {\n-  tree v;\n-  int type_quals;\n+  cp_cv_quals type_quals = TYPE_QUALS (type);\n \n-  if (comp_except_specs (raises, TYPE_RAISES_EXCEPTIONS (type), ce_exact))\n+  if (cp_check_qualified_type (type, type, type_quals, rqual, raises, late))\n     return type;\n \n-  type_quals = TYPE_QUALS (type);\n-  cp_ref_qualifier rqual = type_memfn_rqual (type);\n-  for (v = TYPE_MAIN_VARIANT (type); v; v = TYPE_NEXT_VARIANT (v))\n-    if (cp_check_qualified_type (v, type, type_quals, rqual, raises))\n+  tree v = TYPE_MAIN_VARIANT (type);\n+  for (; v; v = TYPE_NEXT_VARIANT (v))\n+    if (cp_check_qualified_type (v, type, type_quals, rqual, raises, late))\n       return v;\n \n   /* Need to build a new variant.  */\n   v = build_variant_type_copy (type);\n   TYPE_RAISES_EXCEPTIONS (v) = raises;\n-\n-  if (!flag_noexcept_type)\n-    /* The exception-specification is not part of the canonical type.  */\n-    return v;\n+  TYPE_HAS_LATE_RETURN_TYPE (v) = late;\n+  switch (rqual)\n+    {\n+    case REF_QUAL_RVALUE:\n+      FUNCTION_RVALUE_QUALIFIED (v) = 1;\n+      FUNCTION_REF_QUALIFIED (v) = 1;\n+      break;\n+    case REF_QUAL_LVALUE:\n+      FUNCTION_RVALUE_QUALIFIED (v) = 0;\n+      FUNCTION_REF_QUALIFIED (v) = 1;\n+      break;\n+    default:\n+      FUNCTION_REF_QUALIFIED (v) = 0;\n+      break;\n+    }\n \n   /* Canonicalize the exception specification.  */\n-  tree cr = canonical_eh_spec (raises);\n+  tree cr = flag_noexcept_type ? canonical_eh_spec (raises) : NULL_TREE;\n \n   if (TYPE_STRUCTURAL_EQUALITY_P (type))\n     /* Propagate structural equality. */\n     SET_TYPE_STRUCTURAL_EQUALITY (v);\n-  else if (TYPE_CANONICAL (type) != type || cr != raises)\n+  else if (TYPE_CANONICAL (type) != type || cr != raises || late)\n     /* Build the underlying canonical type, since it is different\n        from TYPE. */\n-    TYPE_CANONICAL (v) = build_exception_variant (TYPE_CANONICAL (type), cr);\n+    TYPE_CANONICAL (v) = build_cp_fntype_variant (TYPE_CANONICAL (type),\n+\t\t\t\t\t\t  rqual, cr, false);\n   else\n     /* T is its own canonical type. */\n     TYPE_CANONICAL (v) = v;\n \n   return v;\n }\n \n+/* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions\n+   listed in RAISES.  */\n+\n+tree\n+build_exception_variant (tree type, tree raises)\n+{\n+  cp_ref_qualifier rqual = type_memfn_rqual (type);\n+  bool late = TYPE_HAS_LATE_RETURN_TYPE (type);\n+  return build_cp_fntype_variant (type, rqual, raises, late);\n+}\n+\n /* Given a TEMPLATE_TEMPLATE_PARM node T, create a new\n    BOUND_TEMPLATE_TEMPLATE_PARM bound with NEWARGS as its template\n    arguments.  */\n@@ -4736,12 +4705,7 @@ cp_build_type_attribute_variant (tree type, tree attributes)\n   new_type = build_type_attribute_variant (type, attributes);\n   if (TREE_CODE (new_type) == FUNCTION_TYPE\n       || TREE_CODE (new_type) == METHOD_TYPE)\n-    {\n-      new_type = build_exception_variant (new_type,\n-\t\t\t\t\t  TYPE_RAISES_EXCEPTIONS (type));\n-      new_type = build_ref_qualified_type (new_type,\n-\t\t\t\t\t   type_memfn_rqual (type));\n-    }\n+    gcc_checking_assert (cxx_type_hash_eq (type, new_type));\n \n   /* Making a new main variant of a class type is broken.  */\n   gcc_assert (!CLASS_TYPE_P (type) || new_type == type);\n@@ -4760,6 +4724,8 @@ cxx_type_hash_eq (const_tree typea, const_tree typeb)\n \n   if (type_memfn_rqual (typea) != type_memfn_rqual (typeb))\n     return false;\n+  if (TYPE_HAS_LATE_RETURN_TYPE (typea) != TYPE_HAS_LATE_RETURN_TYPE (typeb))\n+    return false;\n   return comp_except_specs (TYPE_RAISES_EXCEPTIONS (typea),\n \t\t\t    TYPE_RAISES_EXCEPTIONS (typeb), ce_exact);\n }\n@@ -4772,10 +4738,9 @@ cxx_copy_lang_qualifiers (const_tree typea, const_tree typeb)\n {\n   tree type = CONST_CAST_TREE (typea);\n   if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n-    {\n-      type = build_exception_variant (type, TYPE_RAISES_EXCEPTIONS (typeb));\n-      type = build_ref_qualified_type (type, type_memfn_rqual (typeb));\n-    }\n+    type = build_cp_fntype_variant (type, type_memfn_rqual (typeb),\n+\t\t\t\t    TYPE_RAISES_EXCEPTIONS (typeb),\n+\t\t\t\t    TYPE_HAS_LATE_RETURN_TYPE (typeb));\n   return type;\n }\n "}, {"sha": "ecb334d19d2030c1199769744be9528f8b87a263", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/403f22aae5b6e4e8f0e50b89b41a82aaf910931e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=403f22aae5b6e4e8f0e50b89b41a82aaf910931e", "patch": "@@ -830,8 +830,6 @@ merge_types (tree t1, tree t2)\n \ttree p1 = TYPE_ARG_TYPES (t1);\n \ttree p2 = TYPE_ARG_TYPES (t2);\n \ttree parms;\n-\ttree rval, raises;\n-\tbool late_return_type_p = TYPE_HAS_LATE_RETURN_TYPE (t1);\n \n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (valtype == TREE_TYPE (t1) && ! p2)\n@@ -847,17 +845,17 @@ merge_types (tree t1, tree t2)\n \telse\n \t  parms = commonparms (p1, p2);\n \n-\trval = build_function_type (valtype, parms);\n-\tgcc_assert (type_memfn_quals (t1) == type_memfn_quals (t2));\n-\tgcc_assert (type_memfn_rqual (t1) == type_memfn_rqual (t2));\n-\trval = apply_memfn_quals (rval,\n-\t\t\t\t  type_memfn_quals (t1),\n-\t\t\t\t  type_memfn_rqual (t1));\n-\traises = merge_exception_specifiers (TYPE_RAISES_EXCEPTIONS (t1),\n-\t\t\t\t\t     TYPE_RAISES_EXCEPTIONS (t2));\n-\tt1 = build_exception_variant (rval, raises);\n-\tif (late_return_type_p)\n-\t  TYPE_HAS_LATE_RETURN_TYPE (t1) = 1;\n+\tcp_cv_quals quals = type_memfn_quals (t1);\n+\tcp_ref_qualifier rqual = type_memfn_rqual (t1);\n+\tgcc_assert (quals == type_memfn_quals (t2));\n+\tgcc_assert (rqual == type_memfn_rqual (t2));\n+\n+\ttree rval = build_function_type (valtype, parms);\n+\trval = apply_memfn_quals (rval, quals);\n+\ttree raises = merge_exception_specifiers (TYPE_RAISES_EXCEPTIONS (t1),\n+\t\t\t\t\t\t  TYPE_RAISES_EXCEPTIONS (t2));\n+\tbool late_return_type_p = TYPE_HAS_LATE_RETURN_TYPE (t1);\n+\tt1 = build_cp_fntype_variant (rval, rqual, raises, late_return_type_p);\n \tbreak;\n       }\n \n@@ -871,7 +869,6 @@ merge_types (tree t1, tree t2)\n \tcp_ref_qualifier rqual = type_memfn_rqual (t1);\n \ttree t3;\n \tbool late_return_type_1_p = TYPE_HAS_LATE_RETURN_TYPE (t1);\n-\tbool late_return_type_2_p = TYPE_HAS_LATE_RETURN_TYPE (t2);\n \n \t/* If this was a member function type, get back to the\n \t   original type of type member function (i.e., without\n@@ -883,12 +880,7 @@ merge_types (tree t1, tree t2)\n \tt3 = merge_types (t1, t2);\n \tt3 = build_method_type_directly (basetype, TREE_TYPE (t3),\n \t\t\t\t\t TYPE_ARG_TYPES (t3));\n-\tt1 = build_exception_variant (t3, raises);\n-\tt1 = build_ref_qualified_type (t1, rqual);\n-\tif (late_return_type_1_p)\n-\t  TYPE_HAS_LATE_RETURN_TYPE (t1) = 1;\n-\tif (late_return_type_2_p)\n-\t  TYPE_HAS_LATE_RETURN_TYPE (t2) = 1;\n+\tt1 = build_cp_fntype_variant (t3, rqual, raises, late_return_type_1_p);\n \tbreak;\n       }\n "}]}