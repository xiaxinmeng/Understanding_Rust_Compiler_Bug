{"sha": "2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZhM2QzMWJkNmJiOTI3NGFiYWEzYTdkNTljYzg4ZTlhNjExMjE5NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-09T18:23:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-09T18:23:23Z"}, "message": "cgraph.h (cgraph_node): Add profile_id.\n\n\t* cgraph.h (cgraph_node): Add profile_id.\n\t* value-prof.c (cgraph_node_map): Turn into pointer_map.\n\t(init_node_map): Rewrite to handle hashes increas of incremental\n\tIDs.\n\t(del_node_map): Update.\n\t(find_func_by_funcdef_no): Replace by ...\n\t(find_func_by_profile_id): ... this one.\n\t(gimple_ic_transform): Do not remove useful histograms when\n\tspeculation is not done; dump info when indirect call removal\n\tcan happen at LTO.\n\t* value-prof.h (find_func_by_profile_id, gimple_ic): Declare.\n\t* gcov-io.h (__gcov_indirect_call_profiler): Replace by ...\n\t(__gcov_indirect_call_profiler_v2): .. this one.\n\t* profile.h (init_node_map): Update.\n\t* coverage.c (coverage_compute_profile_id): New function.\n\t* coverage.h (coverage_compute_profile_id): Declare.\n\t* tree-profile.c (init_ic_make_global_vars): Make\n\t__gcov_indirect_call_callee and  __gcov_indirect_call_counters global.\n\t(gimple_init_edge_profiler): Update prototype of\n\t__gcov_indirect_call_profiler.\n\t(gimple_gen_ic_func_profiler): Simplify.\n\t(tree_profiling): Use init_node_map\n\nFrom-SVN: r201634", "tree": {"sha": "58562426672deca3c5be2e63eabd43cdf4af64ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58562426672deca3c5be2e63eabd43cdf4af64ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/comments", "author": null, "committer": null, "parents": [{"sha": "36849c21ccee087a778360d3a5dce38d1f7dd586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36849c21ccee087a778360d3a5dce38d1f7dd586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36849c21ccee087a778360d3a5dce38d1f7dd586"}], "stats": {"total": 253, "additions": 188, "deletions": 65}, "files": [{"sha": "bca5102de92bca1eb673dc0b45a46e5efb71b197", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "patch": "@@ -1,3 +1,28 @@\n+2013-08-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (cgraph_node): Add profile_id.\n+\t* value-prof.c (cgraph_node_map): Turn into pointer_map.\n+\t(init_node_map): Rewrite to handle hashes increas of incremental\n+\tIDs.\n+\t(del_node_map): Update.\n+\t(find_func_by_funcdef_no): Replace by ...\n+\t(find_func_by_profile_id): ... this one.\n+\t(gimple_ic_transform): Do not remove useful histograms when\n+\tspeculation is not done; dump info when indirect call removal\n+\tcan happen at LTO.\n+\t* value-prof.h (find_func_by_profile_id, gimple_ic): Declare.\n+\t* gcov-io.h (__gcov_indirect_call_profiler): Replace by ...\n+\t(__gcov_indirect_call_profiler_v2): .. this one.\n+\t* profile.h (init_node_map): Update.\n+\t* coverage.c (coverage_compute_profile_id): New function.\n+\t* coverage.h (coverage_compute_profile_id): Declare.\n+\t* tree-profile.c (init_ic_make_global_vars): Make\n+\t__gcov_indirect_call_callee and  __gcov_indirect_call_counters global.\n+\t(gimple_init_edge_profiler): Update prototype of\n+\t__gcov_indirect_call_profiler.\n+\t(gimple_gen_ic_func_profiler): Simplify.\n+\t(tree_profiling): Use init_node_map\n+\n 2013-08-09  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphbuild.c (cgraph_rebuild_references): Rebuild only non-speculative"}, {"sha": "f67287fc78dd4ee333160e1cdd0a3178c1f50d58", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "patch": "@@ -300,6 +300,8 @@ struct GTY(()) cgraph_node {\n   int count_materialization_scale;\n   /* Unique id of the node.  */\n   int uid;\n+  /* ID assigned by the profiling.  */\n+  unsigned int profile_id;\n \n   /* Set when decl is an abstract function pointed to by the\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */"}, {"sha": "9b664cf1500a23fe46a36fc37f1f4ff9e524598c", "filename": "gcc/coverage.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "patch": "@@ -539,6 +539,28 @@ coverage_compute_lineno_checksum (void)\n   return chksum;\n }\n \n+/* Compute profile ID.  This is better to be unique in whole program.  */\n+\n+unsigned\n+coverage_compute_profile_id (struct cgraph_node *n)\n+{\n+  expanded_location xloc\n+    = expand_location (DECL_SOURCE_LOCATION (n->symbol.decl));\n+  unsigned chksum = xloc.line;\n+\n+  chksum = coverage_checksum_string (chksum, xloc.file);\n+  chksum = coverage_checksum_string\n+    (chksum, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (n->symbol.decl)));\n+  if (first_global_object_name)\n+    chksum = coverage_checksum_string\n+      (chksum, first_global_object_name);\n+  chksum = coverage_checksum_string\n+    (chksum, aux_base_name);\n+\n+  /* Non-negative integers are hopefully small enough to fit in all targets.  */\n+  return chksum & 0x7fffffff;\n+}\n+\n /* Compute cfg checksum for the current function.\n    The checksum is calculated carefully so that\n    source code changes that doesn't affect the control flow graph"}, {"sha": "342d73e16536ab1b10935cb966e93fc6b986e90f", "filename": "gcc/coverage.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fcoverage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fcoverage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.h?ref=2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "patch": "@@ -35,6 +35,9 @@ extern void coverage_end_function (unsigned, unsigned);\n /* Compute the control flow checksum for the current function.  */\n extern unsigned coverage_compute_cfg_checksum (void);\n \n+/* Compute the profile id of function N.  */\n+extern unsigned coverage_compute_profile_id (struct cgraph_node *n);\n+\n /* Compute the line number checksum for the current function.  */\n extern unsigned coverage_compute_lineno_checksum (void);\n "}, {"sha": "db1a6bf4c303f439fd7fa7c1deeb7bc7305379f7", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "patch": "@@ -515,7 +515,7 @@ extern void __gcov_merge_ior (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n extern void __gcov_interval_profiler (gcov_type *, gcov_type, int, unsigned);\n extern void __gcov_pow2_profiler (gcov_type *, gcov_type);\n extern void __gcov_one_value_profiler (gcov_type *, gcov_type);\n-extern void __gcov_indirect_call_profiler (gcov_type *, gcov_type, void *, void *);\n+extern void __gcov_indirect_call_profiler_v2 (gcov_type, void *);\n extern void __gcov_average_profiler (gcov_type *, gcov_type);\n extern void __gcov_ior_profiler (gcov_type *, gcov_type);\n "}, {"sha": "b31cf7869b50f7ef4050ab66711b965953bd0655", "filename": "gcc/profile.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.h?ref=2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "patch": "@@ -43,7 +43,7 @@ extern void mcf_smooth_cfg (void);\n \n extern gcov_type sum_edge_counts (vec<edge, va_gc> *edges);\n \n-extern void init_node_map (void);\n+extern void init_node_map (bool);\n extern void del_node_map (void);\n \n extern void get_working_sets (void);"}, {"sha": "3a508a00e43fcf4e4a63da2591216a798f72e2dd", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "patch": "@@ -57,8 +57,8 @@ static GTY(()) tree ptr_void;\n /* Do initialization work for the edge profiler.  */\n \n /* Add code:\n-   static gcov*\t__gcov_indirect_call_counters; // pointer to actual counter\n-   static void*\t__gcov_indirect_call_callee; // actual callee address\n+   __thread gcov*\t__gcov_indirect_call_counters; // pointer to actual counter\n+   __thread  void*\t__gcov_indirect_call_callee; // actual callee address\n */\n static void\n init_ic_make_global_vars (void)\n@@ -72,7 +72,8 @@ init_ic_make_global_vars (void)\n \t\t  get_identifier (\"__gcov_indirect_call_callee\"),\n \t\t  ptr_void);\n   TREE_STATIC (ic_void_ptr_var) = 1;\n-  TREE_PUBLIC (ic_void_ptr_var) = 0;\n+  TREE_PUBLIC (ic_void_ptr_var) = 1;\n+  DECL_EXTERNAL (ic_void_ptr_var) = 1;\n   DECL_ARTIFICIAL (ic_void_ptr_var) = 1;\n   DECL_INITIAL (ic_void_ptr_var) = NULL;\n   if (targetm.have_tls)\n@@ -87,7 +88,8 @@ init_ic_make_global_vars (void)\n \t\t  get_identifier (\"__gcov_indirect_call_counters\"),\n \t\t  gcov_type_ptr);\n   TREE_STATIC (ic_gcov_type_ptr_var) = 1;\n-  TREE_PUBLIC (ic_gcov_type_ptr_var) = 0;\n+  TREE_PUBLIC (ic_gcov_type_ptr_var) = 1;\n+  DECL_EXTERNAL (ic_gcov_type_ptr_var) = 1;\n   DECL_ARTIFICIAL (ic_gcov_type_ptr_var) = 1;\n   DECL_INITIAL (ic_gcov_type_ptr_var) = NULL;\n   if (targetm.have_tls)\n@@ -155,14 +157,14 @@ gimple_init_edge_profiler (void)\n \n       init_ic_make_global_vars ();\n \n-      /* void (*) (gcov_type *, gcov_type, void *, void *)  */\n+      /* void (*) (gcov_type, void *)  */\n       ic_profiler_fn_type\n \t       = build_function_type_list (void_type_node,\n-\t\t\t\t\t  gcov_type_ptr, gcov_type_node,\n+\t\t\t\t\t  gcov_type_node,\n \t\t\t\t\t  ptr_void,\n-\t\t\t\t\t  ptr_void, NULL_TREE);\n+\t\t\t\t\t  NULL_TREE);\n       tree_indirect_call_profiler_fn\n-\t      = build_fn_decl (\"__gcov_indirect_call_profiler\",\n+\t      = build_fn_decl (\"__gcov_indirect_call_profiler_v2\",\n \t\t\t\t     ic_profiler_fn_type);\n       TREE_NOTHROW (tree_indirect_call_profiler_fn) = 1;\n       DECL_ATTRIBUTES (tree_indirect_call_profiler_fn)\n@@ -352,7 +354,7 @@ gimple_gen_ic_func_profiler (void)\n   struct cgraph_node * c_node = cgraph_get_node (current_function_decl);\n   gimple_stmt_iterator gsi;\n   gimple stmt1, stmt2;\n-  tree tree_uid, cur_func, counter_ptr, ptr_var, void0;\n+  tree tree_uid, cur_func, void0;\n \n   if (cgraph_only_called_directly_p (c_node))\n     return;\n@@ -361,27 +363,20 @@ gimple_gen_ic_func_profiler (void)\n \n   /* Insert code:\n \n-    stmt1: __gcov_indirect_call_profiler (__gcov_indirect_call_counters,\n-\t\t\t\t\t  current_function_funcdef_no,\n-\t\t\t\t\t  &current_function_decl,\n-\t\t\t\t\t  __gcov_indirect_call_callee);\n+    stmt1: __gcov_indirect_call_profiler_v2 (profile_id,\n+\t\t\t\t\t     &current_function_decl)\n    */\n-  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+  gsi = gsi_after_labels (split_edge (single_succ_edge (ENTRY_BLOCK_PTR)));\n \n   cur_func = force_gimple_operand_gsi (&gsi,\n \t\t\t\t       build_addr (current_function_decl,\n \t\t\t\t\t\t   current_function_decl),\n \t\t\t\t       true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n-  counter_ptr = force_gimple_operand_gsi (&gsi, ic_gcov_type_ptr_var,\n-\t\t\t\t\t  true, NULL_TREE, true,\n-\t\t\t\t\t  GSI_SAME_STMT);\n-  ptr_var = force_gimple_operand_gsi (&gsi, ic_void_ptr_var,\n-\t\t\t\t      true, NULL_TREE, true,\n-\t\t\t\t      GSI_SAME_STMT);\n-  tree_uid = build_int_cst (gcov_type_node, current_function_funcdef_no);\n-  stmt1 = gimple_build_call (tree_indirect_call_profiler_fn, 4,\n-\t\t\t     counter_ptr, tree_uid, cur_func, ptr_var);\n+  tree_uid = build_int_cst\n+\t      (gcov_type_node, cgraph_get_node (current_function_decl)->profile_id);\n+  stmt1 = gimple_build_call (tree_indirect_call_profiler_fn, 2,\n+\t\t\t     tree_uid, cur_func);\n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n \n   /* Set __gcov_indirect_call_callee to 0,\n@@ -461,7 +456,7 @@ tree_profiling (void)\n      cgraphunit.c:ipa_passes().  */\n   gcc_assert (cgraph_state == CGRAPH_STATE_IPA_SSA);\n \n-  init_node_map();\n+  init_node_map (true);\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     {"}, {"sha": "f110277f22d9b0083df9323880d1eb314ec57f7a", "filename": "gcc/value-prof.c", "status": "modified", "additions": 86, "deletions": 33, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "patch": "@@ -1173,52 +1173,88 @@ gimple_mod_subtract_transform (gimple_stmt_iterator *si)\n   return true;\n }\n \n-static vec<cgraph_node_ptr> cgraph_node_map\n-    = vNULL;\n+static pointer_map_t *cgraph_node_map;\n \n-/* Initialize map from FUNCDEF_NO to CGRAPH_NODE.  */\n+/* Initialize map from PROFILE_ID to CGRAPH_NODE.\n+   When LOCAL is true, the PROFILE_IDs are computed.  when it is false we assume\n+   that the PROFILE_IDs was already assigned.  */\n \n void\n-init_node_map (void)\n+init_node_map (bool local)\n {\n   struct cgraph_node *n;\n+  cgraph_node_map = pointer_map_create ();\n \n-  if (get_last_funcdef_no ())\n-    cgraph_node_map.safe_grow_cleared (get_last_funcdef_no ());\n-\n-  FOR_EACH_FUNCTION (n)\n-    {\n-      if (DECL_STRUCT_FUNCTION (n->symbol.decl))\n-        cgraph_node_map[DECL_STRUCT_FUNCTION (n->symbol.decl)->funcdef_no] = n;\n-    }\n+  FOR_EACH_DEFINED_FUNCTION (n)\n+    if (cgraph_function_with_gimple_body_p (n)\n+\t&& !cgraph_only_called_directly_p (n))\n+      {\n+\tvoid **val;\n+\tif (local)\n+\t  {\n+\t    n->profile_id = coverage_compute_profile_id (n);\n+\t    while ((val = pointer_map_contains (cgraph_node_map,\n+\t\t\t\t\t\t(void *)(size_t)n->profile_id))\n+\t\t   || !n->profile_id)\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Local profile-id %i conflict\"\n+\t\t\t   \" with nodes %s/%i %s/%i\\n\",\n+\t\t\t   n->profile_id,\n+\t\t\t   cgraph_node_name (n),\n+\t\t\t   n->symbol.order,\n+\t\t\t   symtab_node_name (*(symtab_node*)val),\n+\t\t\t   (*(symtab_node *)val)->symbol.order);\n+\t\tn->profile_id = (n->profile_id + 1) & 0x7fffffff;\n+\t      }\n+\t  }\n+\telse if (!n->profile_id)\n+\t  {\n+\t    if (dump_file)\n+\t      fprintf (dump_file,\n+\t\t       \"Node %s/%i has no profile-id\"\n+\t\t       \" (profile feedback missing?)\\n\",\n+\t\t       cgraph_node_name (n),\n+\t\t       n->symbol.order);\n+\t    continue;\n+\t  }\n+\telse if ((val = pointer_map_contains (cgraph_node_map,\n+\t\t\t\t\t      (void *)(size_t)n->profile_id)))\n+\t  {\n+\t    if (dump_file)\n+\t      fprintf (dump_file,\n+\t\t       \"Node %s/%i has IP profile-id %i conflict. \"\n+\t\t       \"Giving up.\\n\",\n+\t\t       cgraph_node_name (n),\n+\t\t       n->symbol.order,\n+\t\t       n->profile_id);\n+\t    *val = NULL;\n+\t    continue;\n+\t  }\n+\t*pointer_map_insert (cgraph_node_map,\n+\t\t\t     (void *)(size_t)n->profile_id) = (void *)n;\n+      }\n }\n \n /* Delete the CGRAPH_NODE_MAP.  */\n \n void\n del_node_map (void)\n {\n-   cgraph_node_map.release ();\n+  pointer_map_destroy (cgraph_node_map);\n }\n \n /* Return cgraph node for function with pid */\n \n-static inline struct cgraph_node*\n-find_func_by_funcdef_no (int func_id)\n+struct cgraph_node*\n+find_func_by_profile_id (int profile_id)\n {\n-  int max_id = get_last_funcdef_no ();\n-  if (func_id >= max_id || cgraph_node_map[func_id] == NULL)\n-    {\n-      if (flag_profile_correction)\n-        inform (DECL_SOURCE_LOCATION (current_function_decl),\n-                \"Inconsistent profile: indirect call target (%d) does not exist\", func_id);\n-      else\n-        error (\"Inconsistent profile: indirect call target (%d) does not exist\", func_id);\n-\n-      return NULL;\n-    }\n-\n-  return cgraph_node_map[func_id];\n+  void **val = pointer_map_contains (cgraph_node_map,\n+\t\t\t\t     (void *)(size_t)profile_id);\n+  if (val)\n+    return (struct cgraph_node *)*val;\n+  else\n+    return NULL;\n }\n \n /* Perform sanity check on the indirect call target. Due to race conditions,\n@@ -1415,27 +1451,44 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n   val = histogram->hvalue.counters [0];\n   count = histogram->hvalue.counters [1];\n   all = histogram->hvalue.counters [2];\n-  gimple_remove_histogram_value (cfun, stmt, histogram);\n \n   if (4 * count <= 3 * all)\n-    return false;\n+    {\n+      gimple_remove_histogram_value (cfun, stmt, histogram);\n+      return false;\n+    }\n \n   bb_all = gimple_bb (stmt)->count;\n   /* The order of CHECK_COUNTER calls is important -\n      since check_counter can correct the third parameter\n      and we want to make count <= all <= bb_all. */\n   if ( check_counter (stmt, \"ic\", &all, &bb_all, bb_all)\n       || check_counter (stmt, \"ic\", &count, &all, all))\n-    return false;\n+    {\n+      gimple_remove_histogram_value (cfun, stmt, histogram);\n+      return false;\n+    }\n \n   if (all > 0)\n     prob = GCOV_COMPUTE_SCALE (count, all);\n   else\n     prob = 0;\n-  direct_call = find_func_by_funcdef_no ((int)val);\n+  direct_call = find_func_by_profile_id ((int)val);\n \n   if (direct_call == NULL)\n-    return false;\n+    {\n+      if (val)\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Indirect call -> direct call from other module\");\n+\t      print_generic_expr (dump_file, gimple_call_fn (stmt), TDF_SLIM);\n+\t      fprintf (dump_file, \"=> %i (will resolve only with LTO)\\n\", (int)val);\n+\t    }\n+\t}\n+      return false;\n+    }\n+  gimple_remove_histogram_value (cfun, stmt, histogram);\n \n   if (!check_ic_target (stmt, direct_call))\n     return false;"}, {"sha": "57f249d56ef2e7dec6609dca354c0e6a69e8295d", "filename": "gcc/value-prof.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "patch": "@@ -103,6 +103,8 @@ extern void gimple_gen_average_profiler (histogram_value, unsigned, unsigned);\n extern void gimple_gen_ior_profiler (histogram_value, unsigned, unsigned);\n extern void stream_out_histogram_value (struct output_block *, histogram_value);\n extern void stream_in_histogram_value (struct lto_input_block *, gimple);\n+extern struct cgraph_node* find_func_by_profile_id (int func_id);\n+\n \n /* In profile.c.  */\n extern void init_branch_prob (void);"}, {"sha": "f098a42ba6c2519dbf56769b6edb4f47de48bed5", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "patch": "@@ -1,3 +1,10 @@\n+2013-08-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* libgcov.c (__gcov_indirect_call_callee,\n+\t__gcov_indirect_call_counters): New global vars.\n+\t(__gcov_indirect_call_profiler): replace by ...\n+\t(__gcov_indirect_call_profiler_v2) ... this one.\n+\n 2013-08-06  Caroline Tice  <cmtice@google.com>\n \n \t* config.host (extra_parts): Add vtv_start.o, vtv_end.o"}, {"sha": "93b8bd999631a41f981482bed4deb7eac7e48b92", "filename": "libgcc/libgcov.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/libgcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194/libgcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.c?ref=2fa3d31bd6bb9274abaa3a7d59cc88e9a6112194", "patch": "@@ -1121,6 +1121,21 @@ __gcov_one_value_profiler (gcov_type *counters, gcov_type value)\n \n #ifdef L_gcov_indirect_call_profiler\n \n+/* These two variables are used to actually track caller and callee.  Keep\n+   them in TLS memory so races are not common (they are written to often).\n+   The variables are set directly by GCC instrumented code, so declaration\n+   here must match one in tree-profile.c  */\n+\n+#ifdef HAVE_CC_TLS\n+__thread \n+#endif\n+void * __gcov_indirect_call_callee;\n+#ifdef HAVE_CC_TLS\n+__thread \n+#endif\n+gcov_type * __gcov_indirect_call_counters;\n+\n+\n /* By default, the C++ compiler will use function addresses in the\n    vtable entries.  Setting TARGET_VTABLE_USES_DESCRIPTORS to nonzero\n    tells the compiler to use function descriptors instead.  The value\n@@ -1140,16 +1155,15 @@ __gcov_one_value_profiler (gcov_type *counters, gcov_type value)\n \n /* Tries to determine the most common value among its inputs. */\n void\n-__gcov_indirect_call_profiler (gcov_type* counter, gcov_type value,\n-\t\t\t       void* cur_func, void* callee_func)\n+__gcov_indirect_call_profiler_v2 (gcov_type value, void* cur_func)\n {\n   /* If the C++ virtual tables contain function descriptors then one\n      function may have multiple descriptors and we need to dereference\n      the descriptors to see if they point to the same function.  */\n-  if (cur_func == callee_func\n-      || (VTABLE_USES_DESCRIPTORS && callee_func\n-\t  && *(void **) cur_func == *(void **) callee_func))\n-    __gcov_one_value_profiler_body (counter, value);\n+  if (cur_func == __gcov_indirect_call_callee\n+      || (VTABLE_USES_DESCRIPTORS && __gcov_indirect_call_callee\n+\t  && *(void **) cur_func == *(void **) __gcov_indirect_call_callee))\n+    __gcov_one_value_profiler_body (__gcov_indirect_call_counters, value);\n }\n #endif\n "}]}