{"sha": "f57ff1895725753f325552fc95f0baf8dd708f96", "node_id": "C_kwDOANBUbNoAKGY1N2ZmMTg5NTcyNTc1M2YzMjU1NTJmYzk1ZjBiYWY4ZGQ3MDhmOTY", "commit": {"author": {"name": "Lulu Cheng", "email": "chenglulu@loongson.cn", "date": "2022-11-29T08:06:12Z"}, "committer": {"name": "Lulu Cheng", "email": "chenglulu@loongson.cn", "date": "2022-11-30T03:11:34Z"}, "message": "LoongArch: Optimize the implementation of stack check.\n\nThe old stack check was performed before the stack was dropped,\nwhich would cause the detection tool to report a memory leak.\n\nThe current stack check scheme is as follows:\n\n'-fstack-clash-protection':\n1. When the frame->total_size is smaller than the guard page size,\n   the stack is dropped according to the original scheme, and there\n   is no need to perform stack detection in the prologue.\n2. When frame->total_size is greater than or equal to guard page size,\n   the first step to drop the stack is to drop the space required by\n   the caller-save registers. This space needs to save the caller-save\n   registers, so an implicit stack check is performed.\n   So just need to check the rest of the stack space.\n\n'-fstack-check':\nThere is no one-time stack drop and then page-by-page detection as\ndescribed in the document. It is also the same as\n'-fstack-clash-protection', which is detected immediately after page drop.\n\nIt is judged that when frame->total_size is not 0, only the size required\nto save the s register is dropped for the first stack down.\n\nThe test cases are referenced from aarch64.\n\ngcc/ChangeLog:\n\n\t* config/loongarch/linux.h (STACK_CHECK_MOVING_SP):\n\tDefine this macro to 1.\n\t* config/loongarch/loongarch.cc (STACK_CLASH_PROTECTION_GUARD_SIZE):\n\tSize of guard page.\n\t(loongarch_first_stack_step): Return the size of the first drop stack\n\taccording to whether stack checking is performed.\n\t(loongarch_emit_probe_stack_range): Adjust the method of stack checking in prologue.\n\t(loongarch_output_probe_stack_range): Delete useless code.\n\t(loongarch_expand_prologue): Adjust the method of stack checking in prologue.\n\t(loongarch_option_override_internal): Enforce that interval is the same\n\tsize as size so the mid-end does the right thing.\n\t* config/loongarch/loongarch.h (STACK_CLASH_MAX_UNROLL_PAGES):\n\tNew macro decide whether to loop stack detection.\n\ngcc/testsuite/ChangeLog:\n\n\t* lib/target-supports.exp:\n\t* gcc.target/loongarch/stack-check-alloca-1.c: New test.\n\t* gcc.target/loongarch/stack-check-alloca-2.c: New test.\n\t* gcc.target/loongarch/stack-check-alloca-3.c: New test.\n\t* gcc.target/loongarch/stack-check-alloca-4.c: New test.\n\t* gcc.target/loongarch/stack-check-alloca-5.c: New test.\n\t* gcc.target/loongarch/stack-check-alloca-6.c: New test.\n\t* gcc.target/loongarch/stack-check-alloca.h: New test.\n\t* gcc.target/loongarch/stack-check-cfa-1.c: New test.\n\t* gcc.target/loongarch/stack-check-cfa-2.c: New test.\n\t* gcc.target/loongarch/stack-check-prologue-1.c: New test.\n\t* gcc.target/loongarch/stack-check-prologue-2.c: New test.\n\t* gcc.target/loongarch/stack-check-prologue-3.c: New test.\n\t* gcc.target/loongarch/stack-check-prologue-4.c: New test.\n\t* gcc.target/loongarch/stack-check-prologue-5.c: New test.\n\t* gcc.target/loongarch/stack-check-prologue-6.c: New test.\n\t* gcc.target/loongarch/stack-check-prologue-7.c: New test.\n\t* gcc.target/loongarch/stack-check-prologue.h: New test.", "tree": {"sha": "c784393cea6d06407642adc200bebb9479d7769c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c784393cea6d06407642adc200bebb9479d7769c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f57ff1895725753f325552fc95f0baf8dd708f96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57ff1895725753f325552fc95f0baf8dd708f96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f57ff1895725753f325552fc95f0baf8dd708f96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57ff1895725753f325552fc95f0baf8dd708f96/comments", "author": {"login": "chenglulu326", "id": 88083425, "node_id": "MDQ6VXNlcjg4MDgzNDI1", "avatar_url": "https://avatars.githubusercontent.com/u/88083425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenglulu326", "html_url": "https://github.com/chenglulu326", "followers_url": "https://api.github.com/users/chenglulu326/followers", "following_url": "https://api.github.com/users/chenglulu326/following{/other_user}", "gists_url": "https://api.github.com/users/chenglulu326/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenglulu326/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenglulu326/subscriptions", "organizations_url": "https://api.github.com/users/chenglulu326/orgs", "repos_url": "https://api.github.com/users/chenglulu326/repos", "events_url": "https://api.github.com/users/chenglulu326/events{/privacy}", "received_events_url": "https://api.github.com/users/chenglulu326/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenglulu326", "id": 88083425, "node_id": "MDQ6VXNlcjg4MDgzNDI1", "avatar_url": "https://avatars.githubusercontent.com/u/88083425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenglulu326", "html_url": "https://github.com/chenglulu326", "followers_url": "https://api.github.com/users/chenglulu326/followers", "following_url": "https://api.github.com/users/chenglulu326/following{/other_user}", "gists_url": "https://api.github.com/users/chenglulu326/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenglulu326/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenglulu326/subscriptions", "organizations_url": "https://api.github.com/users/chenglulu326/orgs", "repos_url": "https://api.github.com/users/chenglulu326/repos", "events_url": "https://api.github.com/users/chenglulu326/events{/privacy}", "received_events_url": "https://api.github.com/users/chenglulu326/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84046b192e568e1a0619b72a12c7263553d9610a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84046b192e568e1a0619b72a12c7263553d9610a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84046b192e568e1a0619b72a12c7263553d9610a"}], "stats": {"total": 462, "additions": 361, "deletions": 101}, "files": [{"sha": "00039ac1871bc62facf463f6fafc8fbbbbf8d4c1", "filename": "gcc/config/loongarch/linux.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Fconfig%2Floongarch%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Fconfig%2Floongarch%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Flinux.h?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -48,3 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n #define STACK_CHECK_PROTECT (TARGET_64BIT ? 16 * 1024 : 12 * 1024)\n \n #define TARGET_ASM_FILE_END file_end_indicate_exec_stack\n+\n+/* The stack pointer needs to be moved while checking the stack.  */\n+#define STACK_CHECK_MOVING_SP 1"}, {"sha": "c6b03fcf2f9cf97073a4f02472af96606d836d28", "filename": "gcc/config/loongarch/loongarch.cc", "status": "modified", "additions": 148, "deletions": 100, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.cc?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -257,6 +257,10 @@ const char *const\n loongarch_fp_conditions[16]= {LARCH_FP_CONDITIONS (STRINGIFY)};\n #undef STRINGIFY\n \n+/* Size of guard page.  */\n+#define STACK_CLASH_PROTECTION_GUARD_SIZE \\\n+  (1 << param_stack_clash_protection_guard_size)\n+\n /* Implement TARGET_FUNCTION_ARG_BOUNDARY.  Every parameter gets at\n    least PARM_BOUNDARY bits of alignment, but will be given anything up\n    to PREFERRED_STACK_BOUNDARY bits if the type requires it.  */\n@@ -1070,11 +1074,20 @@ loongarch_restore_reg (rtx reg, rtx mem)\n static HOST_WIDE_INT\n loongarch_first_stack_step (struct loongarch_frame_info *frame)\n {\n+  HOST_WIDE_INT min_first_step\n+    = LARCH_STACK_ALIGN (frame->total_size - frame->fp_sp_offset);\n+\n+  /* When stack checking is required, if the sum of frame->total_size\n+     and stack_check_protect is greater than stack clash protection guard\n+     size, then return min_first_step.  */\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK\n+      || (flag_stack_clash_protection\n+\t  && frame->total_size > STACK_CLASH_PROTECTION_GUARD_SIZE))\n+    return min_first_step;\n+\n   if (IMM12_OPERAND (frame->total_size))\n     return frame->total_size;\n \n-  HOST_WIDE_INT min_first_step\n-    = LARCH_STACK_ALIGN (frame->total_size - frame->fp_sp_offset);\n   HOST_WIDE_INT max_first_step = IMM_REACH / 2 - PREFERRED_STACK_BOUNDARY / 8;\n   HOST_WIDE_INT min_second_step = frame->total_size - max_first_step;\n   gcc_assert (min_first_step <= max_first_step);\n@@ -1107,103 +1120,109 @@ loongarch_emit_stack_tie (void)\n static void\n loongarch_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n {\n-  /* See if we have a constant small number of probes to generate.  If so,\n-     that's the easy case.  */\n-  if ((TARGET_64BIT && (first + size <= 32768))\n-      || (!TARGET_64BIT && (first + size <= 2048)))\n-    {\n-      HOST_WIDE_INT i;\n+  HOST_WIDE_INT rounded_size;\n+  HOST_WIDE_INT interval;\n \n-      /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until\n-\t it exceeds SIZE.  If only one probe is needed, this will not\n-\t generate any code.  Then probe at FIRST + SIZE.  */\n-      for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n-\temit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t -(first + i)));\n+  if (flag_stack_clash_protection)\n+    interval = STACK_CLASH_PROTECTION_GUARD_SIZE;\n+  else\n+    interval = PROBE_INTERVAL;\n \n-      emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t       -(first + size)));\n-    }\n+  rtx r12 = LARCH_PROLOGUE_TEMP2 (Pmode);\n+  rtx r14 = LARCH_PROLOGUE_TEMP3 (Pmode);\n \n-  /* Otherwise, do the same as above, but in a loop.  Note that we must be\n-     extra careful with variables wrapping around because we might be at\n-     the very top (or the very bottom) of the address space and we have\n-     to be able to handle this case properly; in particular, we use an\n-     equality test for the loop condition.  */\n-  else\n-    {\n-      HOST_WIDE_INT rounded_size;\n-      rtx r13 = LARCH_PROLOGUE_TEMP (Pmode);\n-      rtx r12 = LARCH_PROLOGUE_TEMP2 (Pmode);\n-      rtx r14 = LARCH_PROLOGUE_TEMP3 (Pmode);\n+  size = size + first;\n \n-      /* Sanity check for the addressing mode we're going to use.  */\n-      gcc_assert (first <= 16384);\n+  /* Sanity check for the addressing mode we're going to use.  */\n+  gcc_assert (first <= 16384);\n \n+  /* Step 1: round SIZE to the previous multiple of the interval.  */\n \n-      /* Step 1: round SIZE to the previous multiple of the interval.  */\n+  rounded_size = ROUND_DOWN (size, interval);\n \n-      rounded_size = ROUND_DOWN (size, PROBE_INTERVAL);\n+  /* Step 2: compute initial and final value of the loop counter.  */\n \n-      /* TEST_ADDR = SP + FIRST */\n-      if (first != 0)\n-\t{\n-\t  emit_move_insn (r14, GEN_INT (first));\n-\t  emit_insn (gen_rtx_SET (r13, gen_rtx_MINUS (Pmode,\n-\t\t\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t\t\t      r14)));\n-\t}\n-      else\n-\temit_move_insn (r13, stack_pointer_rtx);\n+  emit_move_insn (r14, GEN_INT (interval));\n+\n+  /* If rounded_size is zero, it means that the space requested by\n+     the local variable is less than the interval, and there is no\n+     need to display and detect the allocated space.  */\n+  if (rounded_size != 0)\n+    {\n+      /* Step 3: the loop\n+\n+\t do\n+\t {\n+\t TEST_ADDR = TEST_ADDR + PROBE_INTERVAL\n+\t probe at TEST_ADDR\n+\t }\n+\t while (TEST_ADDR != LAST_ADDR)\n \n-      /* Step 2: compute initial and final value of the loop counter.  */\n+\t probes at FIRST + N * PROBE_INTERVAL for values of N from 1\n+\t until it is equal to ROUNDED_SIZE.  */\n \n-      emit_move_insn (r14, GEN_INT (PROBE_INTERVAL));\n-      /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */\n-      if (rounded_size == 0)\n-\temit_move_insn (r12, r13);\n+      if (rounded_size <= STACK_CLASH_MAX_UNROLL_PAGES * interval)\n+\t{\n+\t  for (HOST_WIDE_INT i = 0; i < rounded_size; i += interval)\n+\t    {\n+\t      emit_insn (gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t\t      gen_rtx_MINUS (Pmode,\n+\t\t\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t\t\t     r14)));\n+\t      emit_move_insn (gen_rtx_MEM (Pmode,\n+\t\t\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t\t const0_rtx)),\n+\t\t\t      const0_rtx);\n+\t      emit_insn (gen_blockage ());\n+\t    }\n+\t  dump_stack_clash_frame_info (PROBE_INLINE, size != rounded_size);\n+\t}\n       else\n \t{\n \t  emit_move_insn (r12, GEN_INT (rounded_size));\n-\t  emit_insn (gen_rtx_SET (r12, gen_rtx_MINUS (Pmode, r13, r12)));\n-\t  /* Step 3: the loop\n-\n-\t     do\n-\t     {\n-\t     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL\n-\t     probe at TEST_ADDR\n-\t     }\n-\t     while (TEST_ADDR != LAST_ADDR)\n-\n-\t     probes at FIRST + N * PROBE_INTERVAL for values of N from 1\n-\t     until it is equal to ROUNDED_SIZE.  */\n-\n-\t  emit_insn (gen_probe_stack_range (Pmode, r13, r13, r12, r14));\n+\t  emit_insn (gen_rtx_SET (r12,\n+\t\t\t\t  gen_rtx_MINUS (Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t r12)));\n+\n+\t  emit_insn (gen_probe_stack_range (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t    stack_pointer_rtx, r12, r14));\n+\t  emit_insn (gen_blockage ());\n+\t  dump_stack_clash_frame_info (PROBE_LOOP, size != rounded_size);\n \t}\n+    }\n+  else\n+    dump_stack_clash_frame_info (NO_PROBE_SMALL_FRAME, true);\n+\n \n-      /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time\n-\t that SIZE is equal to ROUNDED_SIZE.  */\n+  /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time\n+     that SIZE is equal to ROUNDED_SIZE.  */\n \n-      if (size != rounded_size)\n+  if (size != rounded_size)\n+    {\n+      if (size - rounded_size >= 2048)\n \t{\n-\t  if (TARGET_64BIT)\n-\t    emit_stack_probe (plus_constant (Pmode, r12, rounded_size - size));\n-\t  else\n-\t    {\n-\t      HOST_WIDE_INT i;\n-\t      for (i = 2048; i < (size - rounded_size); i += 2048)\n-\t\t{\n-\t\t  emit_stack_probe (plus_constant (Pmode, r12, -i));\n-\t\t  emit_insn (gen_rtx_SET (r12,\n-\t\t\t\t\t  plus_constant (Pmode, r12, -2048)));\n-\t\t}\n-\t      rtx r1 = plus_constant (Pmode, r12,\n-\t\t\t\t      -(size - rounded_size - i + 2048));\n-\t      emit_stack_probe (r1);\n-\t    }\n+\t  emit_move_insn (r14, GEN_INT (size - rounded_size));\n+\t  emit_insn (gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t\t  gen_rtx_MINUS (Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t r14)));\n \t}\n+      else\n+\temit_insn (gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t\tgen_rtx_PLUS (Pmode,\n+\t\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t\t      GEN_INT (rounded_size - size))));\n     }\n \n+  if (first)\n+    {\n+      emit_move_insn (r12, GEN_INT (first));\n+      emit_insn (gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t      gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t    stack_pointer_rtx, r12)));\n+    }\n   /* Make sure nothing is scheduled before we are done.  */\n   emit_insn (gen_blockage ());\n }\n@@ -1224,7 +1243,6 @@ loongarch_output_probe_stack_range (rtx reg1, rtx reg2, rtx reg3)\n \n   /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n   xops[0] = reg1;\n-  xops[1] = GEN_INT (-PROBE_INTERVAL);\n   xops[2] = reg3;\n   if (TARGET_64BIT)\n     output_asm_insn (\"sub.d\\t%0,%0,%2\", xops);\n@@ -1250,28 +1268,11 @@ loongarch_expand_prologue (void)\n {\n   struct loongarch_frame_info *frame = &cfun->machine->frame;\n   HOST_WIDE_INT size = frame->total_size;\n-  HOST_WIDE_INT tmp;\n   rtx insn;\n \n   if (flag_stack_usage_info)\n     current_function_static_stack_size = size;\n \n-  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK\n-      || flag_stack_clash_protection)\n-    {\n-      if (crtl->is_leaf && !cfun->calls_alloca)\n-\t{\n-\t  if (size > PROBE_INTERVAL && size > get_stack_check_protect ())\n-\t    {\n-\t      tmp = size - get_stack_check_protect ();\n-\t      loongarch_emit_probe_stack_range (get_stack_check_protect (),\n-\t\t\t\t\t\ttmp);\n-\t    }\n-\t}\n-      else if (size > 0)\n-\tloongarch_emit_probe_stack_range (get_stack_check_protect (), size);\n-    }\n-\n   /* Save the registers.  */\n   if ((frame->mask | frame->fmask) != 0)\n     {\n@@ -1284,7 +1285,6 @@ loongarch_expand_prologue (void)\n       loongarch_for_each_saved_reg (size, loongarch_save_reg);\n     }\n \n-\n   /* Set up the frame pointer, if we're using one.  */\n   if (frame_pointer_needed)\n     {\n@@ -1295,7 +1295,45 @@ loongarch_expand_prologue (void)\n       loongarch_emit_stack_tie ();\n     }\n \n-  /* Allocate the rest of the frame.  */\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK\n+       || flag_stack_clash_protection)\n+    {\n+      HOST_WIDE_INT first = get_stack_check_protect ();\n+\n+      if (frame->total_size == 0)\n+\t{\n+\t  /* do nothing.  */\n+\t  dump_stack_clash_frame_info (NO_PROBE_NO_FRAME, false);\n+\t  return;\n+\t}\n+\n+      if (crtl->is_leaf && !cfun->calls_alloca)\n+\t{\n+\t  HOST_WIDE_INT interval;\n+\n+\t  if (flag_stack_clash_protection)\n+\t    interval = STACK_CLASH_PROTECTION_GUARD_SIZE;\n+\t  else\n+\t    interval = PROBE_INTERVAL;\n+\n+\t  if (size > interval && size > first)\n+\t    loongarch_emit_probe_stack_range (first, size - first);\n+\t  else\n+\t    loongarch_emit_probe_stack_range (first, size);\n+\t}\n+      else\n+\tloongarch_emit_probe_stack_range (first, size);\n+\n+      if (size > 0)\n+\t{\n+\t  /* Describe the effect of the previous instructions.  */\n+\t  insn = plus_constant (Pmode, stack_pointer_rtx, -size);\n+\t  insn = gen_rtx_SET (stack_pointer_rtx, insn);\n+\t  loongarch_set_frame_expr (insn);\n+\t}\n+      return;\n+    }\n+\n   if (size > 0)\n     {\n       if (IMM12_OPERAND (-size))\n@@ -1306,7 +1344,8 @@ loongarch_expand_prologue (void)\n \t}\n       else\n \t{\n-\t  loongarch_emit_move (LARCH_PROLOGUE_TEMP (Pmode), GEN_INT (-size));\n+\t  loongarch_emit_move (LARCH_PROLOGUE_TEMP (Pmode),\n+\t\t\t       GEN_INT (-size));\n \t  emit_insn (gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t    LARCH_PROLOGUE_TEMP (Pmode)));\n \n@@ -6163,6 +6202,15 @@ loongarch_option_override_internal (struct gcc_options *opts)\n \tgcc_unreachable ();\n     }\n \n+  /* Validate the guard size.  */\n+  int guard_size = param_stack_clash_protection_guard_size;\n+\n+  /* Enforce that interval is the same size as size so the mid-end does the\n+     right thing.  */\n+  SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t       param_stack_clash_protection_probe_interval,\n+\t\t       guard_size);\n+\n   loongarch_init_print_operand_punct ();\n \n   /* Set up array to map GCC register number to debug register number."}, {"sha": "a402d3ba35afc03cf9e50ee56e85dd6ac897d7af", "filename": "gcc/config/loongarch/loongarch.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Fconfig%2Floongarch%2Floongarch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Fconfig%2Floongarch%2Floongarch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.h?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -668,6 +668,10 @@ enum reg_class\n \n #define STACK_BOUNDARY (TARGET_ABI_LP64 ? 128 : 64)\n \n+/* This value controls how many pages we manually unroll the loop for when\n+   generating stack clash probes.  */\n+#define STACK_CLASH_MAX_UNROLL_PAGES 4\n+\n /* Symbolic macros for the registers used to return integer and floating\n    point values.  */\n "}, {"sha": "6ee589c4b3da63ac44cdce4f6baeb9f8d76e656d", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-alloca-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-1.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-require-effective-target alloca } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE y\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {stp*t*r*\\.d\\t\\$r0,\\$r\\d{1,2},-8} 1 } } */\n+/* { dg-final { scan-assembler-times {stx\\.d\\t\\$r0,\\$r3,\\$r12} 1 } } */\n+\n+/* Dynamic alloca, expect loop, and 1 probes with top at sp.\n+   1st probe is inside the loop for the full guard-size allocations, second\n+   probe is for the case where residual is zero.  */"}, {"sha": "8deaa587305e156fe49e7157c1b86c23b8f5ed3b", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-alloca-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-2.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-require-effective-target alloca } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 0\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-not {stp*t*r*\\.d\\t\\$r0,\\$r3,4088} } } */\n+\n+/* Alloca of 0 should emit no probes, boundary condition.  */"}, {"sha": "e326ba9a092733d6229b285861aaac4e0bd0c813", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-alloca-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-3.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-require-effective-target alloca } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 100\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {st\\.d\\t\\$r0,\\$r3,104} 1 } } */\n+\n+/* Alloca is less than guard-size, 1 probe at the top of the new allocation.  */"}, {"sha": "b9f7572dedcc834c76e433c6008ad1b260494b38", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-alloca-4.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-4.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-require-effective-target alloca } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 64 * 1024\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {stp*t*r*\\.d\\t\\$r0,\\$r\\d{1,2},-8} 1 } } */\n+\n+/* Alloca is exactly one guard-size, 1 probe expected at top.  */"}, {"sha": "0ff6e493fec123999832a688f6d2becc229a99bb", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-alloca-5.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-5.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-require-effective-target alloca } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 65 * 1024\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {stp*t*r*\\.d\\t\\$r0,\\$r\\d{1,2},-8} 1 } } */\n+/* { dg-final { scan-assembler-times {stp*t*r*\\.d\\t\\$r0,\\$r3,1016} 1 } } */\n+\n+/* Alloca is more than one guard-page. 2 probes expected.  */"}, {"sha": "c5cf74fcb4fc6224d6c8b4f13d46b2469738da47", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-alloca-6.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca-6.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-require-effective-target alloca } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 127 * 64 * 1024\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {stp*t*r*\\.d\\t\\$r0,\\$r\\d{1,2},-8} 1 } } */\n+\n+/* Large alloca of a constant amount which is a multiple of a guard-size.\n+   Loop expected with top probe.  */"}, {"sha": "8c75f6c0f703ef3d661309fddf046e0f89e4b58d", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-alloca.h", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-alloca.h?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,15 @@\n+\n+/* Avoid inclusion of alloca.h, unavailable on some systems.  */\n+#define alloca __builtin_alloca\n+\n+__attribute__((noinline, noipa))\n+void g (char* ptr, int y)\n+{\n+  ptr[y] = '\\0';\n+}\n+\n+void f_caller (int y)\n+{\n+  char* pStr = alloca(SIZE);\n+  g (pStr, y);\n+}"}, {"sha": "f0c6877fc258a11bb8ef765a0b7000e0ad6104a6", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-cfa-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-cfa-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-cfa-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-cfa-1.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -funwind-tables\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 128*1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa_offset 131088} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa_offset 0} 1 } } */\n+\n+/* Checks that the CFA notes are correct for every sp adjustment.  */"}, {"sha": "c6e07bc561a6b2be0e568a73570319608b59895c", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-cfa-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-cfa-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-cfa-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-cfa-2.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16 -funwind-tables\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 1280*1024 + 512\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa_offset 1311248} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.cfi_def_cfa_offset 0} 1 } } */\n+\n+/* Checks that the CFA notes are correct for every sp adjustment.  */"}, {"sha": "351bc1f61fd262a5d52adbfb99bf7b3f434a99df", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-prologue-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-1.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 128\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {stp*t*r*\\.d\\t\\$r0,\\$r3,0} 0 } } */\n+\n+/* SIZE is smaller than guard-size so no probe expected.  */"}, {"sha": "6bba659a36d8b6273d6ff835cd4b41b5be3690fc", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-prologue-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-2.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 63 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {stp*t*r*.d\\t\\$r0,\\$r3,0} 0 } } */\n+\n+/* SIZE is smaller than guard-size so no probe expected.  */"}, {"sha": "164956c37471a1cc5589aba1abed2af2d5161d51", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-prologue-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-3.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 64 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {stp*t*r*\\.d\\t\\$r0,\\$r3,0} 1 } } */\n+\n+/* SIZE is equal to guard-size, 1 probe expected, boundary condition.  */"}, {"sha": "f53da6b0de9e6d17205030ce01db9ca706ece9eb", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-prologue-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-4.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 65 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {stp*t*r*\\.d\\t\\$r0,\\$r3,0} 1 } } */\n+\n+/* SIZE is more than guard-size 1 probe expected.  */"}, {"sha": "c092317ea941c7bed88b2d2e1846c974103397c7", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-prologue-5.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-5.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 127 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {stp*t*r*\\.d\\t\\$r0,\\$r3,0} 1 } } */\n+\n+/* SIZE is more than 1x guard-size and remainder small than guard-size,\n+   1 probe expected, unrolled, no loop.  */"}, {"sha": "70a2f53f6d74db2d3ce8ba4374ebb4e74cceb7bb", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-prologue-6.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-6.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 128 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {stp*t*r*\\.d\\t\\$r0,\\$r3,0} 2 } } */\n+\n+/* SIZE is more than 2x guard-size and no remainder, unrolled, no loop.  */"}, {"sha": "e2df89acc77af66e25202eb372017d513fa616a8", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-prologue-7.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue-7.c?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fstack-check\" } { \"\" } } */\n+\n+#define SIZE 6 * 64 * 1024\n+#include \"stack-check-prologue.h\"\n+\n+/* { dg-final { scan-assembler-times {stp*t*r*.d\\t\\$r0,\\$r3,0} 1 } } */\n+\n+/* SIZE is more than 4x guard-size and no remainder, 1 probe expected in a loop\n+   and no residual probe.  */"}, {"sha": "b7e06aedb81d7692ebd587b23d1065436b1c7218", "filename": "gcc/testsuite/gcc.target/loongarch/stack-check-prologue.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Fstack-check-prologue.h?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -0,0 +1,5 @@\n+int f_test (int x)\n+{\n+  char arr[SIZE];\n+  return arr[x];\n+}"}, {"sha": "2a058c67c53466fe41b748d37ab660afd4e3403f", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57ff1895725753f325552fc95f0baf8dd708f96/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=f57ff1895725753f325552fc95f0baf8dd708f96", "patch": "@@ -11557,7 +11557,8 @@ proc check_effective_target_supports_stack_clash_protection { } {\n \n     if { [istarget x86_64-*-*] || [istarget i?86-*-*] \n \t  || [istarget powerpc*-*-*] || [istarget rs6000*-*-*]\n-\t  || [istarget aarch64*-**] || [istarget s390*-*-*] } {\n+\t  || [istarget aarch64*-**] || [istarget s390*-*-*]\n+\t  || [istarget loongarch64*-**] } {\n \treturn 1\n     }\n   return 0\n@@ -11608,6 +11609,10 @@ proc check_effective_target_caller_implicit_probes { } {\n \treturn 1;\n   }\n \n+  if { [istarget loongarch64*-*-*] } {\n+\treturn 1;\n+  }\n+\n   return 0\n }\n "}]}