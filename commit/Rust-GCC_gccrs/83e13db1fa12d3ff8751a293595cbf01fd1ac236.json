{"sha": "83e13db1fa12d3ff8751a293595cbf01fd1ac236", "node_id": "C_kwDOANBUbNoAKDgzZTEzZGIxZmExMmQzZmY4NzUxYTI5MzU5NWNiZjAxZmQxYWMyMzY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-28T14:19:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-28T14:19:07Z"}, "message": "Merge #1190 #1192 #1193\n\n1190: Fix ICE in reachability class and refactor associated types code r=philberty a=philberty\n\nThere are several fixes going on to solve these issues which overlap with one\r\nanother so it seemed best to pack them within the same PR.\r\n\r\nThe main issue for #1128 was that we did not resolve a trait when it was unused\r\nleading to us hitting the ICE in the privacy pass. Since the type check context was\r\nempty for the trait since it was not resolved. To fix this we needed to refactor the\r\ntrait resolver to resolve the trait as part of iterating the crate. This resulted in some\r\nregressions in the testsuite so this is why we need the the other commits. Which\r\nrequired us to finally perform the refactor specified in #1105 to fix these.\r\n\r\nFixes #1105 #1128 #1132\n\n1192: Add an assertion to avoid peeking when the stack is empty r=philberty a=philberty\n\nThis will ensure we get a proper ICE instead of memory corruption/segv.\r\n\r\nAddresses #1130 \n\n1193: Remove unused parameter caller from generating Call expressions r=philberty a=philberty\n\nWithin const context the fncontext maybe empty which in turn results in a\r\nsegv for generating const calls which will be evaluated by the const-expr\r\ncode anyway.\r\n\r\nAddresses #1130\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "7ac4415a617592db114100fe78b9702df9eb37a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ac4415a617592db114100fe78b9702df9eb37a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83e13db1fa12d3ff8751a293595cbf01fd1ac236", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiaqJbCRBK7hj4Ov3rIwAA3FUIABSBVce9AR/NxOJ4QY/8UL9z\nq8tpDu+B8GNL3GL4H9gVfvnIJaLSEn4a13FDcMYxWTTLrYcYmt8FdKYLIBs75ySQ\n4O4OU0ZmH8TJqSk+eIjYkfvZoExJ1k9Kdvwkui9hoX+Cu1dyfFV4fDU91OERAaTr\nnBpFzBmtT9+yn/5H9RwZDtjbu25Shu0SG2gjPrc27DMG4Etf8ltWDdtptz7IR+kl\nSNp5zV3aASqGz8ptE4L+eVvZH+bzlkFYwJ60S+E+7HjCUmJ2ypeN3gjmDQKwKYrd\njxPSRW0SttAguacVzKMaBObP19/xZMT7fj+9CSqdV9r/gu04Xt9uDUdqax8bB4o=\n=e7fK\n-----END PGP SIGNATURE-----\n", "payload": "tree 7ac4415a617592db114100fe78b9702df9eb37a8\nparent 9cf744cbd762442ab33b3f92067829883d7d2d73\nparent bbf171c9d25becdf77087a9e7d2b9e4bde030e80\nparent 7fe6bc1ba1a8d296262e1e06ac067190c8ab3ebb\nparent ae085ac7b12809cadaf6bfdb18c34f1a177290c1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1651155547 +0000\ncommitter GitHub <noreply@github.com> 1651155547 +0000\n\nMerge #1190 #1192 #1193\n\n1190: Fix ICE in reachability class and refactor associated types code r=philberty a=philberty\n\nThere are several fixes going on to solve these issues which overlap with one\r\nanother so it seemed best to pack them within the same PR.\r\n\r\nThe main issue for #1128 was that we did not resolve a trait when it was unused\r\nleading to us hitting the ICE in the privacy pass. Since the type check context was\r\nempty for the trait since it was not resolved. To fix this we needed to refactor the\r\ntrait resolver to resolve the trait as part of iterating the crate. This resulted in some\r\nregressions in the testsuite so this is why we need the the other commits. Which\r\nrequired us to finally perform the refactor specified in #1105 to fix these.\r\n\r\nFixes #1105 #1128 #1132\n\n1192: Add an assertion to avoid peeking when the stack is empty r=philberty a=philberty\n\nThis will ensure we get a proper ICE instead of memory corruption/segv.\r\n\r\nAddresses #1130 \n\n1193: Remove unused parameter caller from generating Call expressions r=philberty a=philberty\n\nWithin const context the fncontext maybe empty which in turn results in a\r\nsegv for generating const calls which will be evaluated by the const-expr\r\ncode anyway.\r\n\r\nAddresses #1130\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e13db1fa12d3ff8751a293595cbf01fd1ac236", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e13db1fa12d3ff8751a293595cbf01fd1ac236", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e13db1fa12d3ff8751a293595cbf01fd1ac236/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cf744cbd762442ab33b3f92067829883d7d2d73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cf744cbd762442ab33b3f92067829883d7d2d73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cf744cbd762442ab33b3f92067829883d7d2d73"}, {"sha": "bbf171c9d25becdf77087a9e7d2b9e4bde030e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf171c9d25becdf77087a9e7d2b9e4bde030e80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbf171c9d25becdf77087a9e7d2b9e4bde030e80"}, {"sha": "7fe6bc1ba1a8d296262e1e06ac067190c8ab3ebb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fe6bc1ba1a8d296262e1e06ac067190c8ab3ebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fe6bc1ba1a8d296262e1e06ac067190c8ab3ebb"}, {"sha": "ae085ac7b12809cadaf6bfdb18c34f1a177290c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae085ac7b12809cadaf6bfdb18c34f1a177290c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae085ac7b12809cadaf6bfdb18c34f1a177290c1"}], "stats": {"total": 723, "additions": 323, "deletions": 400}, "files": [{"sha": "d17034b51df78ce53a69fdc4a1cd2a03119f9f19", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -254,7 +254,11 @@ class Context\n   bool in_fn () { return fn_stack.size () != 0; }\n \n   // Note: it is undefined behavior to call peek_fn () if fn_stack is empty.\n-  fncontext peek_fn () { return fn_stack.back (); }\n+  fncontext peek_fn ()\n+  {\n+    rust_assert (!fn_stack.empty ());\n+    return fn_stack.back ();\n+  }\n \n   void push_type (tree t) { type_decls.push_back (t); }\n   void push_var (::Bvariable *v) { var_decls.push_back (v); }"}, {"sha": "edeea8d2fbdc31ff45ffae34bbbb2700c6e9a0da", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -497,10 +497,8 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \n   // must be a call to a function\n   auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n-  auto fncontext = ctx->peek_fn ();\n-  translated\n-    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address, args,\n-\t\t\t\t\t    nullptr, expr.get_locus ());\n+  translated = ctx->get_backend ()->call_expression (fn_address, args, nullptr,\n+\t\t\t\t\t\t     expr.get_locus ());\n }\n \n void\n@@ -610,10 +608,8 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n       args.push_back (rvalue);\n     }\n \n-  auto fncontext = ctx->peek_fn ();\n-  translated\n-    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n-\t\t\t\t\t    nullptr, expr.get_locus ());\n+  translated = ctx->get_backend ()->call_expression (fn_expr, args, nullptr,\n+\t\t\t\t\t\t     expr.get_locus ());\n }\n \n tree\n@@ -696,8 +692,8 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n   tree fn_expr\n     = ctx->get_backend ()->var_expression (fn_convert_expr_tmp, expr_locus);\n \n-  return ctx->get_backend ()->call_expression (fnctx.fndecl, fn_expr, args,\n-\t\t\t\t\t       nullptr, expr_locus);\n+  return ctx->get_backend ()->call_expression (fn_expr, args, nullptr,\n+\t\t\t\t\t       expr_locus);\n }\n \n tree\n@@ -866,9 +862,8 @@ CompileExpr::resolve_operator_overload (\n   if (rhs != nullptr)\t // can be null for negation_expr (unary ones)\n     args.push_back (rhs);\n \n-  auto fncontext = ctx->peek_fn ();\n-  return ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n-\t\t\t\t\t       nullptr, expr.get_locus ());\n+  return ctx->get_backend ()->call_expression (fn_expr, args, nullptr,\n+\t\t\t\t\t       expr.get_locus ());\n }\n \n tree\n@@ -1289,10 +1284,8 @@ HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n     }\n \n   // make the call\n-  auto fncontext = ctx->peek_fn ();\n-  return ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address,\n-\t\t\t\t\t       {adjusted_argument}, nullptr,\n-\t\t\t\t\t       locus);\n+  return ctx->get_backend ()->call_expression (fn_address, {adjusted_argument},\n+\t\t\t\t\t       nullptr, locus);\n }\n \n tree"}, {"sha": "9dc6d14d629493bde846d51de413f86d2ea269d7", "filename": "gcc/rust/backend/rust-compile-implitem.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -52,6 +52,7 @@ CompileTraitItem::visit (HIR::TraitItemFunc &func)\n \n   rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n   TyTy::FnType *fntype = static_cast<TyTy::FnType *> (concrete);\n+  fntype->monomorphize ();\n \n   // items can be forward compiled which means we may not need to invoke this\n   // code. We might also have already compiled this generic function as well."}, {"sha": "969c852d5164d06b08444eadb89e590cfbf70dac", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -127,6 +127,7 @@ CompileItem::visit (HIR::Function &function)\n \t{\n \t  rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n \t  fntype = static_cast<TyTy::FnType *> (concrete);\n+\t  fntype->monomorphize ();\n \t}\n     }\n "}, {"sha": "55a2fffe9dd6c25327f3d8aa869d0ffccd21bd6c", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -251,21 +251,6 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t      rust_assert (ok);\t\t\t\t    // found\n \t      rust_assert (trait_item_ref->is_optional ()); // has definition\n \n-\t      Analysis::NodeMapping trait_mappings\n-\t\t= trait_item_ref->get_parent_trait_mappings ();\n-\n-\t      HirId associated_impl_id;\n-\t      ok = ctx->get_tyctx ()->lookup_associated_impl_mapping_for_self (\n-\t\ttrait_mappings.get_hirid (), receiver, &associated_impl_id);\n-\t      rust_assert (ok);\n-\n-\t      Resolver::AssociatedImplTrait *associated = nullptr;\n-\t      bool found_associated_trait_impl\n-\t\t= ctx->get_tyctx ()->lookup_associated_trait_impl (\n-\t\t  associated_impl_id, &associated);\n-\t      rust_assert (found_associated_trait_impl);\n-\t      associated->setup_associated_types ();\n-\n \t      return CompileTraitItem::Compile (\n \t\ttrait_item_ref->get_hir_trait_item (), ctx, lookup, true,\n \t\texpr_locus);"}, {"sha": "6d631a0365ac17ebc72dd5ff97617ee0b8a97a18", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -285,8 +285,7 @@ class Backend\n \n   // Create an expression for a call to FN with ARGS, taking place within\n   // caller CALLER.\n-  virtual tree call_expression (tree caller, tree fn,\n-\t\t\t\tconst std::vector<tree> &args,\n+  virtual tree call_expression (tree fn, const std::vector<tree> &args,\n \t\t\t\ttree static_chain, Location)\n     = 0;\n "}, {"sha": "445cb0da8766d2027cfdbdef085dc770b5cb7ed1", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -250,7 +250,7 @@ class Gcc_backend : public Backend\n \n   tree array_index_expression (tree array, tree index, Location);\n \n-  tree call_expression (tree caller, tree fn, const std::vector<tree> &args,\n+  tree call_expression (tree fn, const std::vector<tree> &args,\n \t\t\ttree static_chain, Location);\n \n   // Statements.\n@@ -1794,8 +1794,7 @@ Gcc_backend::array_index_expression (tree array_tree, tree index_tree,\n \n // Create an expression for a call to FN_EXPR with FN_ARGS.\n tree\n-Gcc_backend::call_expression (tree, // containing fcn for call\n-\t\t\t      tree fn, const std::vector<tree> &fn_args,\n+Gcc_backend::call_expression (tree fn, const std::vector<tree> &fn_args,\n \t\t\t      tree chain_expr, Location location)\n {\n   if (fn == error_mark_node || TREE_TYPE (fn) == error_mark_node)"}, {"sha": "348b9f775e82bbaaa21d126429aa15fff5841ac7", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -326,18 +326,6 @@ class PathProbeType : public TypeCheckBase\n       }\n \n     TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n-    if (impl != nullptr && !is_reciever_generic ())\n-\n-      {\n-\tHirId impl_block_id = impl->get_mappings ().get_hirid ();\n-\tAssociatedImplTrait *lookup_associated = nullptr;\n-\tbool found_impl_trait\n-\t  = context->lookup_associated_trait_impl (impl_block_id,\n-\t\t\t\t\t\t   &lookup_associated);\n-\t// see testsuite/rust/compile/torture/traits10.rs this can be false\n-\tif (found_impl_trait)\n-\t  lookup_associated->setup_associated_types ();\n-      }\n \n     // we can substitute the Self with the receiver here\n     if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)"}, {"sha": "6eec461e8a5ed522e3d3801562c38a12cb2265af", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -454,18 +454,11 @@ class AssociatedImplTrait\n \n   TyTy::BaseType *get_self () { return self; }\n \n-  void setup_associated_types ();\n-\n-  void setup_associated_types2 (const TyTy::BaseType *self,\n-\t\t\t\tconst TyTy::TypeBoundPredicate &bound);\n+  void setup_associated_types (const TyTy::BaseType *self,\n+\t\t\t       const TyTy::TypeBoundPredicate &bound);\n \n   void reset_associated_types ();\n \n-  TyTy::BaseType *get_projected_type (const TraitItemReference *trait_item_ref,\n-\t\t\t\t      TyTy::BaseType *reciever, HirId ref,\n-\t\t\t\t      HIR::GenericArgs &trait_generics,\n-\t\t\t\t      Location expr_locus);\n-\n private:\n   TraitReference *trait;\n   HIR::ImplBlock *impl;"}, {"sha": "13edd8d1a6f8cbb88742953af2eed2e8c400c67e", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 207, "deletions": 63, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -61,8 +61,214 @@ ResolveTraitItemToRef::visit (HIR::TraitItemFunc &fn)\n \t\t\t\t self, std::move (substitutions), locus);\n }\n \n+ResolveTraitItemToRef::ResolveTraitItemToRef (\n+  TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> &&substitutions)\n+  : TypeCheckBase (), resolved (TraitItemReference::error ()), self (self),\n+    substitutions (std::move (substitutions))\n+{}\n+\n // TraitItemReference items\n \n+TraitReference *\n+TraitResolver::Resolve (HIR::TypePath &path)\n+{\n+  TraitResolver resolver;\n+  return resolver.resolve_path (path);\n+}\n+\n+TraitReference *\n+TraitResolver::Resolve (HIR::Trait &trait)\n+{\n+  TraitResolver resolver;\n+  return resolver.resolve_trait (&trait);\n+}\n+\n+TraitReference *\n+TraitResolver::Lookup (HIR::TypePath &path)\n+{\n+  TraitResolver resolver;\n+  return resolver.lookup_path (path);\n+}\n+\n+TraitResolver::TraitResolver ()\n+  : TypeCheckBase (), resolved_trait_reference (nullptr)\n+{}\n+\n+TraitReference *\n+TraitResolver::resolve_path (HIR::TypePath &path)\n+{\n+  NodeId ref;\n+  if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n+\t\t\t\t       &ref))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HirId hir_node = UNKNOWN_HIRID;\n+  if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n+\t\t\t\t     &hir_node))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HIR::Item *resolved_item\n+    = mappings->lookup_hir_item (mappings->get_current_crate (), hir_node);\n+\n+  rust_assert (resolved_item != nullptr);\n+  resolved_item->accept_vis (*this);\n+  rust_assert (resolved_trait_reference != nullptr);\n+\n+  return resolve_trait (resolved_trait_reference);\n+}\n+\n+TraitReference *\n+TraitResolver::resolve_trait (HIR::Trait *trait_reference)\n+{\n+  TraitReference *tref = &TraitReference::error_node ();\n+  if (context->lookup_trait_reference (\n+\ttrait_reference->get_mappings ().get_defid (), &tref))\n+    {\n+      return tref;\n+    }\n+\n+  TyTy::BaseType *self = nullptr;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  for (auto &generic_param : trait_reference->get_generic_params ())\n+    {\n+      switch (generic_param.get ()->get_kind ())\n+\t{\n+\tcase HIR::GenericParam::GenericKind::LIFETIME:\n+\t  // Skipping Lifetime completely until better handling.\n+\t  break;\n+\n+\t  case HIR::GenericParam::GenericKind::TYPE: {\n+\t    auto param_type\n+\t      = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t    context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t    auto &typaram = static_cast<HIR::TypeParam &> (*generic_param);\n+\t    substitutions.push_back (\n+\t      TyTy::SubstitutionParamMapping (typaram, param_type));\n+\n+\t    if (typaram.get_type_representation ().compare (\"Self\") == 0)\n+\t      {\n+\t\tself = param_type;\n+\t      }\n+\t  }\n+\t  break;\n+\t}\n+    }\n+  rust_assert (self != nullptr);\n+\n+  // Check if there is a super-trait, and apply this bound to the Self\n+  // TypeParam\n+  std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+\n+  // copy the substitition mappings\n+  std::vector<TyTy::SubstitutionParamMapping> self_subst_copy;\n+  for (auto &sub : substitutions)\n+    self_subst_copy.push_back (sub.clone ());\n+\n+  // They also inherit themselves as a bound this enables a trait item to\n+  // reference other Self::trait_items\n+  auto self_hrtb\n+    = TyTy::TypeBoundPredicate (trait_reference->get_mappings ().get_defid (),\n+\t\t\t\tstd::move (self_subst_copy),\n+\t\t\t\ttrait_reference->get_locus ());\n+  specified_bounds.push_back (self_hrtb);\n+\n+  // look for any\n+  std::vector<const TraitReference *> super_traits;\n+  if (trait_reference->has_type_param_bounds ())\n+    {\n+      for (auto &bound : trait_reference->get_type_param_bounds ())\n+\t{\n+\t  if (bound->get_bound_type ()\n+\t      == HIR::TypeParamBound::BoundType::TRAITBOUND)\n+\t    {\n+\t      HIR::TraitBound *b\n+\t\t= static_cast<HIR::TraitBound *> (bound.get ());\n+\n+\t      // FIXME this might be recursive we need a check for that\n+\t      auto predicate = get_predicate_from_bound (b->get_path ());\n+\t      specified_bounds.push_back (predicate);\n+\t      super_traits.push_back (predicate.get ());\n+\t    }\n+\t}\n+    }\n+  self->inherit_bounds (specified_bounds);\n+\n+  std::vector<TraitItemReference> item_refs;\n+  for (auto &item : trait_reference->get_trait_items ())\n+    {\n+      // make a copy of the substs\n+      std::vector<TyTy::SubstitutionParamMapping> item_subst;\n+      for (auto &sub : substitutions)\n+\titem_subst.push_back (sub.clone ());\n+\n+      TraitItemReference trait_item_ref\n+\t= ResolveTraitItemToRef::Resolve (*item.get (), self,\n+\t\t\t\t\t  std::move (item_subst));\n+      item_refs.push_back (std::move (trait_item_ref));\n+    }\n+\n+  TraitReference trait_object (trait_reference, item_refs,\n+\t\t\t       std::move (super_traits),\n+\t\t\t       std::move (substitutions));\n+  context->insert_trait_reference (\n+    trait_reference->get_mappings ().get_defid (), std::move (trait_object));\n+\n+  tref = &TraitReference::error_node ();\n+  bool ok = context->lookup_trait_reference (\n+    trait_reference->get_mappings ().get_defid (), &tref);\n+  rust_assert (ok);\n+\n+  // hook to allow the trait to resolve its optional item blocks, we cant\n+  // resolve the blocks of functions etc because it can end up in a recursive\n+  // loop of trying to resolve traits as required by the types\n+  tref->on_resolved ();\n+\n+  return tref;\n+}\n+\n+TraitReference *\n+TraitResolver::lookup_path (HIR::TypePath &path)\n+{\n+  NodeId ref;\n+  if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n+\t\t\t\t       &ref))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HirId hir_node = UNKNOWN_HIRID;\n+  if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n+\t\t\t\t     &hir_node))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HIR::Item *resolved_item\n+    = mappings->lookup_hir_item (mappings->get_current_crate (), hir_node);\n+\n+  rust_assert (resolved_item != nullptr);\n+  resolved_item->accept_vis (*this);\n+  rust_assert (resolved_trait_reference != nullptr);\n+\n+  TraitReference *tref = &TraitReference::error_node ();\n+  if (context->lookup_trait_reference (\n+\tresolved_trait_reference->get_mappings ().get_defid (), &tref))\n+    {\n+      return tref;\n+    }\n+  return &TraitReference::error_node ();\n+}\n+\n void\n TraitItemReference::on_resolved ()\n {\n@@ -154,29 +360,7 @@ TraitItemReference::associated_type_reset () const\n }\n \n void\n-AssociatedImplTrait::setup_associated_types ()\n-{\n-  ImplTypeIterator iter (*impl, [&] (HIR::TypeAlias &type) {\n-    TraitItemReference *resolved_trait_item = nullptr;\n-    bool ok = trait->lookup_trait_item (type.get_new_type_name (),\n-\t\t\t\t\t&resolved_trait_item);\n-    if (!ok)\n-      return;\n-    if (resolved_trait_item->get_trait_item_type ()\n-\t!= TraitItemReference::TraitItemType::TYPE)\n-      return;\n-\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n-      return;\n-\n-    resolved_trait_item->associated_type_set (lookup);\n-  });\n-  iter.go ();\n-}\n-\n-void\n-AssociatedImplTrait::setup_associated_types2 (\n+AssociatedImplTrait::setup_associated_types (\n   const TyTy::BaseType *self, const TyTy::TypeBoundPredicate &bound)\n {\n   // compute the constrained impl block generic arguments based on self and the\n@@ -390,46 +574,6 @@ TraitItemReference::is_object_safe () const\n   return false;\n }\n \n-TyTy::BaseType *\n-AssociatedImplTrait::get_projected_type (\n-  const TraitItemReference *trait_item_ref, TyTy::BaseType *receiver, HirId ref,\n-  HIR::GenericArgs &trait_generics, Location expr_locus)\n-{\n-  TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ()->clone ();\n-\n-  // we can substitute the Self with the receiver here\n-  if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-    {\n-      TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n-      TyTy::SubstitutionParamMapping *param = nullptr;\n-      for (auto &param_mapping : fn->get_substs ())\n-\t{\n-\t  const HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n-\t  if (type_param.get_type_representation ().compare (\"Self\") == 0)\n-\t    {\n-\t      param = &param_mapping;\n-\t      break;\n-\t    }\n-\t}\n-      rust_assert (param != nullptr);\n-\n-      std::vector<TyTy::SubstitutionArg> mappings;\n-      mappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n-\n-      TyTy::SubstitutionArgumentMappings args (std::move (mappings),\n-\t\t\t\t\t       expr_locus);\n-      trait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n-    }\n-\n-  if (!trait_generics.is_empty ())\n-    {\n-      trait_item_tyty\n-\t= SubstMapper::Resolve (trait_item_tyty, expr_locus, &trait_generics);\n-    }\n-\n-  return trait_item_tyty;\n-}\n-\n // rust-hir-path-probe.h\n \n void"}, {"sha": "a73b67fc142e9dd13d49416035c794b8b7c36da5", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 11, "deletions": 180, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -52,10 +52,7 @@ class ResolveTraitItemToRef : public TypeCheckBase\n private:\n   ResolveTraitItemToRef (\n     TyTy::BaseType *self,\n-    std::vector<TyTy::SubstitutionParamMapping> &&substitutions)\n-    : TypeCheckBase (), resolved (TraitItemReference::error ()), self (self),\n-      substitutions (std::move (substitutions))\n-  {}\n+    std::vector<TyTy::SubstitutionParamMapping> &&substitutions);\n \n   TraitItemReference resolved;\n   TyTy::BaseType *self;\n@@ -67,191 +64,25 @@ class TraitResolver : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static TraitReference *Resolve (HIR::TypePath &path)\n-  {\n-    TraitResolver resolver;\n-    return resolver.go (path);\n-  }\n-\n-  static TraitReference *Lookup (HIR::TypePath &path)\n-  {\n-    TraitResolver resolver;\n-    return resolver.lookup_path (path);\n-  }\n-\n-private:\n-  TraitResolver () : TypeCheckBase () {}\n-\n-  TraitReference *go (HIR::TypePath &path)\n-  {\n-    NodeId ref;\n-    if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n-\t\t\t\t\t &ref))\n-      {\n-\trust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n-\treturn &TraitReference::error_node ();\n-      }\n-\n-    HirId hir_node = UNKNOWN_HIRID;\n-    if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n-\t\t\t\t       &hir_node))\n-      {\n-\trust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n-\treturn &TraitReference::error_node ();\n-      }\n-\n-    HIR::Item *resolved_item\n-      = mappings->lookup_hir_item (mappings->get_current_crate (), hir_node);\n-\n-    rust_assert (resolved_item != nullptr);\n-    resolved_item->accept_vis (*this);\n-    rust_assert (trait_reference != nullptr);\n-\n-    TraitReference *tref = &TraitReference::error_node ();\n-    if (context->lookup_trait_reference (\n-\t  trait_reference->get_mappings ().get_defid (), &tref))\n-      {\n-\treturn tref;\n-      }\n-\n-    TyTy::BaseType *self = nullptr;\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    for (auto &generic_param : trait_reference->get_generic_params ())\n-      {\n-\tswitch (generic_param.get ()->get_kind ())\n-\t  {\n-\t  case HIR::GenericParam::GenericKind::LIFETIME:\n-\t    // Skipping Lifetime completely until better handling.\n-\t    break;\n-\n-\t    case HIR::GenericParam::GenericKind::TYPE: {\n-\t      auto param_type\n-\t\t= TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t      context->insert_type (generic_param->get_mappings (), param_type);\n-\n-\t      auto &typaram = static_cast<HIR::TypeParam &> (*generic_param);\n-\t      substitutions.push_back (\n-\t\tTyTy::SubstitutionParamMapping (typaram, param_type));\n+  static TraitReference *Resolve (HIR::TypePath &path);\n \n-\t      if (typaram.get_type_representation ().compare (\"Self\") == 0)\n-\t\t{\n-\t\t  self = param_type;\n-\t\t}\n-\t    }\n-\t    break;\n-\t  }\n-      }\n-    rust_assert (self != nullptr);\n+  static TraitReference *Resolve (HIR::Trait &trait);\n \n-    // Check if there is a super-trait, and apply this bound to the Self\n-    // TypeParam\n-    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+  static TraitReference *Lookup (HIR::TypePath &path);\n \n-    // copy the substitition mappings\n-    std::vector<TyTy::SubstitutionParamMapping> self_subst_copy;\n-    for (auto &sub : substitutions)\n-      self_subst_copy.push_back (sub.clone ());\n-\n-    // They also inherit themselves as a bound this enables a trait item to\n-    // reference other Self::trait_items\n-    auto self_hrtb\n-      = TyTy::TypeBoundPredicate (trait_reference->get_mappings ().get_defid (),\n-\t\t\t\t  std::move (self_subst_copy),\n-\t\t\t\t  trait_reference->get_locus ());\n-    specified_bounds.push_back (self_hrtb);\n-\n-    // look for any\n-    std::vector<const TraitReference *> super_traits;\n-    if (trait_reference->has_type_param_bounds ())\n-      {\n-\tfor (auto &bound : trait_reference->get_type_param_bounds ())\n-\t  {\n-\t    if (bound->get_bound_type ()\n-\t\t== HIR::TypeParamBound::BoundType::TRAITBOUND)\n-\t      {\n-\t\tHIR::TraitBound *b\n-\t\t  = static_cast<HIR::TraitBound *> (bound.get ());\n-\n-\t\t// FIXME this might be recursive we need a check for that\n-\t\tauto predicate = get_predicate_from_bound (b->get_path ());\n-\t\tspecified_bounds.push_back (predicate);\n-\t\tsuper_traits.push_back (predicate.get ());\n-\t      }\n-\t  }\n-      }\n-    self->inherit_bounds (specified_bounds);\n-\n-    std::vector<TraitItemReference> item_refs;\n-    for (auto &item : trait_reference->get_trait_items ())\n-      {\n-\t// make a copy of the substs\n-\tstd::vector<TyTy::SubstitutionParamMapping> item_subst;\n-\tfor (auto &sub : substitutions)\n-\t  item_subst.push_back (sub.clone ());\n-\n-\tTraitItemReference trait_item_ref\n-\t  = ResolveTraitItemToRef::Resolve (*item.get (), self,\n-\t\t\t\t\t    std::move (item_subst));\n-\titem_refs.push_back (std::move (trait_item_ref));\n-      }\n-\n-    TraitReference trait_object (trait_reference, item_refs,\n-\t\t\t\t std::move (super_traits),\n-\t\t\t\t std::move (substitutions));\n-    context->insert_trait_reference (\n-      trait_reference->get_mappings ().get_defid (), std::move (trait_object));\n-\n-    tref = &TraitReference::error_node ();\n-    bool ok = context->lookup_trait_reference (\n-      trait_reference->get_mappings ().get_defid (), &tref);\n-    rust_assert (ok);\n-\n-    // hook to allow the trait to resolve its optional item blocks, we cant\n-    // resolve the blocks of functions etc because it can end up in a recursive\n-    // loop of trying to resolve traits as required by the types\n-    tref->on_resolved ();\n-\n-    return tref;\n-  }\n-\n-  TraitReference *lookup_path (HIR::TypePath &path)\n-  {\n-    NodeId ref;\n-    if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n-\t\t\t\t\t &ref))\n-      {\n-\trust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n-\treturn &TraitReference::error_node ();\n-      }\n-\n-    HirId hir_node = UNKNOWN_HIRID;\n-    if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n-\t\t\t\t       &hir_node))\n-      {\n-\trust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n-\treturn &TraitReference::error_node ();\n-      }\n+private:\n+  TraitResolver ();\n \n-    HIR::Item *resolved_item\n-      = mappings->lookup_hir_item (mappings->get_current_crate (), hir_node);\n+  TraitReference *resolve_path (HIR::TypePath &path);\n \n-    rust_assert (resolved_item != nullptr);\n-    resolved_item->accept_vis (*this);\n-    rust_assert (trait_reference != nullptr);\n+  TraitReference *resolve_trait (HIR::Trait *trait_reference);\n \n-    TraitReference *tref = &TraitReference::error_node ();\n-    if (context->lookup_trait_reference (\n-\t  trait_reference->get_mappings ().get_defid (), &tref))\n-      {\n-\treturn tref;\n-      }\n-    return &TraitReference::error_node ();\n-  }\n+  TraitReference *lookup_path (HIR::TypePath &path);\n \n-  HIR::Trait *trait_reference;\n+  HIR::Trait *resolved_trait_reference;\n \n public:\n-  void visit (HIR::Trait &trait) override { trait_reference = &trait; }\n+  void visit (HIR::Trait &trait) override { resolved_trait_reference = &trait; }\n };\n \n } // namespace Resolver"}, {"sha": "71b6b815e36d29dd7c789c123a78525216df5053", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -224,6 +224,8 @@ class TypeCheckItem : public TypeCheckBase\n       TypeCheckItem::Resolve (item.get ());\n   }\n \n+  void visit (HIR::Trait &trait) override { TraitResolver::Resolve (trait); }\n+\n private:\n   TypeCheckItem () : TypeCheckBase () {}\n };"}, {"sha": "3823c570d25e1177cc8ce35821c92d660bcbc28f", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -67,41 +67,41 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n   // inherit the bound\n   root->inherit_bounds ({specified_bound});\n \n-  // we need resolve to the impl block\n-  NodeId impl_resolved_id = UNKNOWN_NODEID;\n-  bool ok = resolver->lookup_resolved_name (\n-    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n-  rust_assert (ok);\n-\n-  HirId impl_block_id;\n-  ok = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t     impl_resolved_id, &impl_block_id);\n-  rust_assert (ok);\n-\n-  AssociatedImplTrait *lookup_associated = nullptr;\n-  bool found_impl_trait\n-    = context->lookup_associated_trait_impl (impl_block_id, &lookup_associated);\n-  rust_assert (found_impl_trait);\n-\n+  // lookup the associated item from the specified bound\n   HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n-\n-  const TraitItemReference *trait_item_ref = nullptr;\n-  ok = trait_ref->lookup_trait_item (item_seg.get_segment ().as_string (),\n-\t\t\t\t     &trait_item_ref);\n-  if (!ok)\n+  HIR::PathIdentSegment item_seg_identifier = item_seg.get_segment ();\n+  TyTy::TypeBoundPredicateItem item\n+    = specified_bound.lookup_associated_item (item_seg_identifier.as_string ());\n+  if (item.is_error ())\n     {\n       rust_error_at (item_seg.get_locus (), \"unknown associated item\");\n       return;\n     }\n \n-  HIR::GenericArgs trait_generics = qual_path_type.trait_has_generic_args ()\n-\t\t\t\t      ? qual_path_type.get_trait_generic_args ()\n-\t\t\t\t      : HIR::GenericArgs::create_empty ();\n+  // infer the root type\n+  infered = item.get_tyty_for_receiver (root);\n \n-  lookup_associated->setup_associated_types ();\n-  infered = lookup_associated->get_projected_type (\n-    trait_item_ref, root, item_seg.get_mappings ().get_hirid (), trait_generics,\n-    item_seg.get_locus ());\n+  // we need resolve to the impl block\n+  NodeId impl_resolved_id = UNKNOWN_NODEID;\n+  bool have_associated_impl = resolver->lookup_resolved_name (\n+    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n+  AssociatedImplTrait *lookup_associated = nullptr;\n+  if (have_associated_impl)\n+    {\n+      HirId impl_block_id;\n+      bool ok\n+\t= mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t\timpl_resolved_id, &impl_block_id);\n+      rust_assert (ok);\n+\n+      bool found_impl_trait\n+\t= context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t &lookup_associated);\n+      if (found_impl_trait)\n+\t{\n+\t  lookup_associated->setup_associated_types (root, specified_bound);\n+\t}\n+    }\n \n   // turbo-fish segment path::<ty>\n   if (item_seg.has_generic_args ())\n@@ -119,6 +119,7 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n     }\n \n   // continue on as a path-in-expression\n+  const TraitItemReference *trait_item_ref = item.get_raw_item ();\n   NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n   bool fully_resolved = expr.get_segments ().size () <= 1;\n \n@@ -348,20 +349,6 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t  HIR::ImplBlock *impl = candidate.item.trait.impl;\n \t  if (impl != nullptr)\n \t    {\n-\t      AssociatedImplTrait *lookup_associated = nullptr;\n-\t      bool found_impl_trait = context->lookup_associated_trait_impl (\n-\t\timpl->get_mappings ().get_hirid (), &lookup_associated);\n-\n-\t      // setup associated mappings if possible we might be resolving a\n-\t      // path within a default implementation of a trait function\n-\t      // see: testsuite/rust/compile/torture/traits16.rs\n-\t      if (found_impl_trait)\n-\t\tlookup_associated->setup_associated_types ();\n-\n-\t      // we need a new ty_ref_id for this trait item\n-\t      tyseg = tyseg->clone ();\n-\t      tyseg->set_ty_ref (mappings->get_next_hir_id ());\n-\n \t      // get the associated impl block\n \t      associated_impl_block = impl;\n \t    }"}, {"sha": "bd40344aa6c9de5039a5989fbe3569d68947fcd4", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 21, "deletions": 46, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -142,31 +142,35 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n       return;\n     }\n \n+  // get the predicate for the bound\n+  auto specified_bound\n+    = get_predicate_from_bound (*qual_path_type.get_trait ().get ());\n+  if (specified_bound.is_error ())\n+    return;\n+\n+  // inherit the bound\n+  root->inherit_bounds ({specified_bound});\n+\n+  // lookup the associated item from the specified bound\n   std::unique_ptr<HIR::TypePathSegment> &item_seg\n     = path.get_associated_segment ();\n-  const TraitItemReference *trait_item_ref = nullptr;\n-  bool ok\n-    = trait_ref->lookup_trait_item (item_seg->get_ident_segment ().as_string (),\n-\t\t\t\t    &trait_item_ref);\n-  if (!ok)\n+  HIR::PathIdentSegment item_seg_identifier = item_seg->get_ident_segment ();\n+  TyTy::TypeBoundPredicateItem item\n+    = specified_bound.lookup_associated_item (item_seg_identifier.as_string ());\n+  if (item.is_error ())\n     {\n       rust_error_at (item_seg->get_locus (), \"unknown associated item\");\n       return;\n     }\n \n-  // this will be the placeholder from the trait but we may be able to project\n-  // it based on the impl block\n-  translated = trait_item_ref->get_tyty ();\n-\n-  // this is the associated generics we need to potentially apply\n-  HIR::GenericArgs trait_generics = qual_path_type.trait_has_generic_args ()\n-\t\t\t\t      ? qual_path_type.get_trait_generic_args ()\n-\t\t\t\t      : HIR::GenericArgs::create_empty ();\n+  // infer the root type\n+  translated = item.get_tyty_for_receiver (root);\n \n   // we need resolve to the impl block\n   NodeId impl_resolved_id = UNKNOWN_NODEID;\n   bool have_associated_impl = resolver->lookup_resolved_name (\n     qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n+  AssociatedImplTrait *lookup_associated = nullptr;\n   if (have_associated_impl)\n     {\n       HirId impl_block_id;\n@@ -175,30 +179,16 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n \t\t\t\t\timpl_resolved_id, &impl_block_id);\n       rust_assert (ok);\n \n-      AssociatedImplTrait *lookup_associated = nullptr;\n       bool found_impl_trait\n \t= context->lookup_associated_trait_impl (impl_block_id,\n \t\t\t\t\t\t &lookup_associated);\n-      rust_assert (found_impl_trait);\n-\n-      // project\n-      lookup_associated->setup_associated_types ();\n-      translated = lookup_associated->get_projected_type (\n-\ttrait_item_ref, root, item_seg->get_mappings ().get_hirid (),\n-\ttrait_generics, item_seg->get_locus ());\n-    }\n-\n-  if (translated->get_kind () == TyTy::TypeKind::PLACEHOLDER)\n-    {\n-      // lets grab the actual projection type\n-      TyTy::PlaceholderType *p\n-\t= static_cast<TyTy::PlaceholderType *> (translated);\n-      if (p->can_resolve ())\n+      if (found_impl_trait)\n \t{\n-\t  translated = p->resolve ();\n+\t  lookup_associated->setup_associated_types (root, specified_bound);\n \t}\n     }\n \n+  // turbo-fish segment path::<ty>\n   if (item_seg->get_type () == HIR::TypePathSegment::SegmentType::GENERIC)\n     {\n       HIR::TypePathSegmentGeneric &generic_seg\n@@ -222,6 +212,7 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n     }\n \n   // continue on as a path-in-expression\n+  const TraitItemReference *trait_item_ref = item.get_raw_item ();\n   NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n   bool fully_resolved = path.get_segments ().empty ();\n   if (fully_resolved)\n@@ -448,22 +439,6 @@ TypeCheckType::resolve_segments (\n \t{\n \t  resolved_node_id\n \t    = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n-\n-\t  // lookup the associated-impl-trait\n-\t  HIR::ImplBlock *impl = candidate.item.trait.impl;\n-\t  if (impl != nullptr && !reciever_is_generic)\n-\t    {\n-\t      AssociatedImplTrait *lookup_associated = nullptr;\n-\t      bool found_impl_trait = context->lookup_associated_trait_impl (\n-\t\timpl->get_mappings ().get_hirid (), &lookup_associated);\n-\t      rust_assert (found_impl_trait);\n-\n-\t      lookup_associated->setup_associated_types ();\n-\n-\t      // we need a new ty_ref_id for this trait item\n-\t      tyseg = tyseg->clone ();\n-\t      tyseg->set_ty_ref (mappings->get_next_hir_id ());\n-\t    }\n \t}\n \n       if (seg->is_generic_segment ())"}, {"sha": "7302b069923d462f5615fe68db86da8e0c278648", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -826,22 +826,23 @@ SubstitutionRef::monomorphize ()\n \t      bool found_impl_trait\n \t\t= context->lookup_associated_trait_impl (impl_block_id,\n \t\t\t\t\t\t\t &associated);\n-\t      rust_assert (found_impl_trait);\n-\n-\t      bool found_trait\n-\t\t= specified_bound_ref->is_equal (*bound_trait_ref);\n-\t      bool found_self\n-\t\t= associated->get_self ()->can_eq (binding, false);\n-\t      if (found_trait && found_self)\n+\t      if (found_impl_trait)\n \t\t{\n-\t\t  associated_impl_trait = associated;\n-\t\t  break;\n+\t\t  bool found_trait\n+\t\t    = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t\t  bool found_self\n+\t\t    = associated->get_self ()->can_eq (binding, false);\n+\t\t  if (found_trait && found_self)\n+\t\t    {\n+\t\t      associated_impl_trait = associated;\n+\t\t      break;\n+\t\t    }\n \t\t}\n \t    }\n \n \t  if (associated_impl_trait != nullptr)\n \t    {\n-\t      associated_impl_trait->setup_associated_types2 (binding, bound);\n+\t      associated_impl_trait->setup_associated_types (binding, bound);\n \t    }\n \t}\n     }\n@@ -1230,6 +1231,19 @@ FnType::is_equal (const BaseType &other) const\n     {\n       if (get_num_substitutions () != other2.get_num_substitutions ())\n \treturn false;\n+\n+      const FnType &ofn = static_cast<const FnType &> (other);\n+      for (size_t i = 0; i < get_num_substitutions (); i++)\n+\t{\n+\t  const SubstitutionParamMapping &a = get_substs ().at (i);\n+\t  const SubstitutionParamMapping &b = ofn.get_substs ().at (i);\n+\n+\t  const ParamType *pa = a.get_param_ty ();\n+\t  const ParamType *pb = b.get_param_ty ();\n+\n+\t  if (!pa->is_equal (*pb))\n+\t    return false;\n+\t}\n     }\n \n   if (num_params () != other2.num_params ())\n@@ -2961,6 +2975,7 @@ TypeCheckCallExpr::visit (ADTType &type)\n void\n TypeCheckCallExpr::visit (FnType &type)\n {\n+  type.monomorphize ();\n   if (call.num_params () != type.num_params ())\n     {\n       if (type.is_varadic ())"}, {"sha": "462426b679dad20c0ff5d33fb8d991bf209f60d3", "filename": "gcc/testsuite/rust/compile/issue-1128.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1128.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e13db1fa12d3ff8751a293595cbf01fd1ac236/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1128.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1128.rs?ref=83e13db1fa12d3ff8751a293595cbf01fd1ac236", "patch": "@@ -0,0 +1,6 @@\n+pub trait Hasher {\n+    fn write(&mut self, bytes: &[u8]);\n+    fn write_u8(&mut self, i: u8) {\n+        self.write(&[i])\n+    }\n+}"}]}