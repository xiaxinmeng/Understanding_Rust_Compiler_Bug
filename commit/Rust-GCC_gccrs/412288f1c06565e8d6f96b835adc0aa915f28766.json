{"sha": "412288f1c06565e8d6f96b835adc0aa915f28766", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEyMjg4ZjFjMDY1NjVlOGQ2Zjk2YjgzNWFkYzBhYTkxNWYyODc2Ng==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2011-08-12T16:42:13Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2011-08-12T16:42:13Z"}, "message": "data-streamer.h (streamer_write_zero): Rename from output_zero.\n\n\t* data-streamer.h (streamer_write_zero): Rename from output_zero.\n \t(streamer_write_uhwi): Rename from lto_output_uleb128.\n \t(streamer_write_hwi): Rename from output_sleb128.\n \t(streamer_write_string): Rename from lto_output_string.\n \t(streamer_string_index): Rename from lto_string_index.\n \t(streamer_write_string_with_length): Rename from\n \tlto_output_string_with_length.\n \t(streamer_write_uhwi_stream): Rename from lto_output_uleb128_stream.\n \t(streamer_write_hwi_stream): Rename from lto_output_sleb128_stream.\n \t(streamer_read_string): Rename from lto_input_string.\n \t(streamer_read_indexed_string): Rename from input_string_internal.\n \t(streamer_read_uhwi): Rename from lto_input_uleb128.\n \t(streamer_read_hwi): Rename from lto_input_sleb128.\n \t(streamer_write_hwi_in_range): Rename from lto_output_int_in_range.\n \t(streamer_read_hwi_in_range): Rename from lto_input_int_in_range.\n \t(streamer_write_enum): Rename from lto_output_enum.\n \t(streamer_read_enum): Rename from lto_input_enum.\n \t(streamer_write_record_start): Rename from output_record_start.\n \t(streamer_read_record_start): Rename from input_record_start.\n \t(streamer_write_bitpack): Rename from lto_output_bitpack.\n \t(streamer_read_bitpack): Rename from lto_input_bitpack.\n \t(streamer_write_char_stream): Rename from lto_output_1_stream.\n \t(streamer_read_uchar): Rename from lto_input_1_unsigned.\n \t* tree-streamer.h (streamer_cache_d): Rename from lto_streamer_cache_d.\n \t(streamer_handle_as_builtin_p): Rename from lto_stream_as_builtin_p.\n \t(streamer_read_string_cst): Rename from input_string_cst.\n \t(streamer_read_chain): Rename from lto_input_chain.\n \t(streamer_alloc_tree): Rename from lto_materialize_tree.\n \t(streamer_read_tree_body): Rename from lto_input_tree_pointers.\n \t(streamer_get_pickled_tree): Rename from lto_get_pickled_tree.\n \t(streamer_get_builtin_tree): Rename from lto_get_builtin_tree.\n \t(streamer_read_integer_cst): Rename from lto_input_integer_cst.\n \t(streamer_read_tree_bitfields): Rename from tree_read_bitfields.\n \t(streamer_write_chain): Rename from lto_output_chain.\n \t(streamer_write_tree_header): Rename from lto_output_tree_header.\n \t(streamer_pack_tree_bitfields): Rename from pack_value_fields.\n \t(streamer_write_tree_body): Rename from lto_output_tree_pointers.\n \t(streamer_write_integer_cst): Rename from lto_output_integer_cst.\n \t(streamer_write_builtin): Rename from lto_output_builtin_tree.\n \t(streamer_check_handled_ts_structures): Rename from\n \tcheck_handled_ts_structures.\n \t(streamer_tree_cache_insert): Rename from lto_streamer_cache_insert.\n \t(streamer_tree_cache_insert_at): Rename from\n \tlto_streamer_cache_insert_at.\n \t(streamer_tree_cache_append): Rename from lto_streamer_cache_append.\n \t(streamer_tree_cache_lookup): Rename from lto_streamer_cache_lookup.\n \t(streamer_tree_cache_get): Rename from lto_streamer_cache_get.\n \t(streamer_tree_cache_create): Rename from lto_streamer_cache_create.\n \t(streamer_tree_cache_delete): Rename from lto_streamer_cache_delete.\n \t* tree-streamer-out.c (write_string_cst): Rename from output_string_cst.\n \t(write_identifier): Rename from output_identifier.\n \t(write_ts_common_tree_pointers): Rename from\n \tlto_output_ts_common_tree_pointers.\n \t(write_ts_vector_tree_pointers): Rename from\n \tlto_output_ts_vector_tree_pointers.\n \t(write_ts_complex_tree_pointers): Rename from\n \tlto_output_ts_complex_tree_pointers.\n \t(write_ts_decl_minimal_tree_pointers): Rename from\n \tlto_output_ts_decl_minimal_tree_pointers.\n \t(write_ts_decl_common_tree_pointers): Rename from\n \tlto_output_ts_decl_common_tree_pointers.\n \t(write_ts_decl_non_common_tree_pointers): Rename from\n \tlto_output_ts_decl_non_common_tree_pointers.\n \t(write_ts_decl_with_vis_tree_pointers): Rename from\n \tlto_output_ts_decl_with_vis_tree_pointers.\n \t(write_ts_field_decl_tree_pointers): Rename from\n \tlto_output_ts_field_decl_tree_pointers.\n \t(write_ts_function_decl_tree_pointers): Rename from\n \tlto_output_ts_function_decl_tree_pointers.\n \t(write_ts_type_common_tree_pointers): Rename from\n \tlto_output_ts_type_common_tree_pointers.\n \t(write_ts_type_non_common_tree_pointers): Rename from\n \tlto_output_ts_type_non_common_tree_pointers.\n \t(write_ts_list_tree_pointers): Rename from\n \tlto_output_ts_list_tree_pointers.\n \t(write_ts_vec_tree_pointers): Rename from\n \tlto_output_ts_vec_tree_pointers.\n \t(write_ts_exp_tree_pointers): Rename from\n \tlto_output_ts_exp_tree_pointers.\n \t(write_ts_block_tree_pointers): Rename from\n \tlto_output_ts_block_tree_pointers.\n \t(write_ts_binfo_tree_pointers): Rename from\n \tlto_output_ts_binfo_tree_pointers.\n \t(write_ts_constructor_tree_pointers): Rename from\n \tlto_output_ts_constructor_tree_pointers.\n \t(write_ts_target_option): Rename from\n \tlto_output_ts_target_option.\n \t(write_ts_translation_unit_decl_tree_pointers): Rename from\n \tlto_output_ts_translation_unit_decl_tree_pointers.\n \t* tree-streamer.c (streamer_tree_cache_add_to_node_array):\n \tRename from lto_streamer_cache_add_to_node_array.\n \t(streamer_tree_cache_insert_1): Rename from lto_streamer_cache_insert_1.\n \t(record_common_node): Rename from lto_record_common_node.\n\n\t* streamer-hooks.h (bitpack_d, lto_streamer_cache_d): Remove forward\n\tdeclarations.\n\t* data-streamer-in.c (lto_input_widest_uint_uleb128): Remove unused\n\tfunction.\n\t* data-streamer-out.c (lto_output_widest_uint_uleb128_stream): Remove\n\tunused function.\n\t* Makefile.in (lto-section-out.o): Add dependency on DATA_STREAMER_H.\n\t(ipa-reference.o): Likewise.\n\t* lto-section-out.c: Include data-streamer.h.\n\t* ipa-reference.c: Include data-streamer.h.\n\nFrom-SVN: r177704", "tree": {"sha": "ef2a7dfd0af1b4be822dcf83bf3264d9f4d97d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef2a7dfd0af1b4be822dcf83bf3264d9f4d97d0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/412288f1c06565e8d6f96b835adc0aa915f28766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/412288f1c06565e8d6f96b835adc0aa915f28766", "html_url": "https://github.com/Rust-GCC/gccrs/commit/412288f1c06565e8d6f96b835adc0aa915f28766", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/412288f1c06565e8d6f96b835adc0aa915f28766/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f"}], "stats": {"total": 1652, "additions": 848, "deletions": 804}, "files": [{"sha": "7b2c447b955c9a38aaf28ab13a454925d3c2e810", "filename": "gcc/ChangeLog", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -1,3 +1,110 @@\n+2011-08-12   Diego Novillo  <dnovillo@google.com>\n+\n+\t* data-streamer.h (streamer_write_zero): Rename from output_zero.\n+ \t(streamer_write_uhwi): Rename from lto_output_uleb128.\n+ \t(streamer_write_hwi): Rename from output_sleb128.\n+ \t(streamer_write_string): Rename from lto_output_string.\n+ \t(streamer_string_index): Rename from lto_string_index.\n+ \t(streamer_write_string_with_length): Rename from\n+ \tlto_output_string_with_length.\n+ \t(streamer_write_uhwi_stream): Rename from lto_output_uleb128_stream.\n+ \t(streamer_write_hwi_stream): Rename from lto_output_sleb128_stream.\n+ \t(streamer_read_string): Rename from lto_input_string.\n+ \t(streamer_read_indexed_string): Rename from input_string_internal.\n+ \t(streamer_read_uhwi): Rename from lto_input_uleb128.\n+ \t(streamer_read_hwi): Rename from lto_input_sleb128.\n+ \t(streamer_write_hwi_in_range): Rename from lto_output_int_in_range.\n+ \t(streamer_read_hwi_in_range): Rename from lto_input_int_in_range.\n+ \t(streamer_write_enum): Rename from lto_output_enum.\n+ \t(streamer_read_enum): Rename from lto_input_enum.\n+ \t(streamer_write_record_start): Rename from output_record_start.\n+ \t(streamer_read_record_start): Rename from input_record_start.\n+ \t(streamer_write_bitpack): Rename from lto_output_bitpack.\n+ \t(streamer_read_bitpack): Rename from lto_input_bitpack.\n+ \t(streamer_write_char_stream): Rename from lto_output_1_stream.\n+ \t(streamer_read_uchar): Rename from lto_input_1_unsigned.\n+ \t* tree-streamer.h (streamer_cache_d): Rename from lto_streamer_cache_d.\n+ \t(streamer_handle_as_builtin_p): Rename from lto_stream_as_builtin_p.\n+ \t(streamer_read_string_cst): Rename from input_string_cst.\n+ \t(streamer_read_chain): Rename from lto_input_chain.\n+ \t(streamer_alloc_tree): Rename from lto_materialize_tree.\n+ \t(streamer_read_tree_body): Rename from lto_input_tree_pointers.\n+ \t(streamer_get_pickled_tree): Rename from lto_get_pickled_tree.\n+ \t(streamer_get_builtin_tree): Rename from lto_get_builtin_tree.\n+ \t(streamer_read_integer_cst): Rename from lto_input_integer_cst.\n+ \t(streamer_read_tree_bitfields): Rename from tree_read_bitfields.\n+ \t(streamer_write_chain): Rename from lto_output_chain.\n+ \t(streamer_write_tree_header): Rename from lto_output_tree_header.\n+ \t(streamer_pack_tree_bitfields): Rename from pack_value_fields.\n+ \t(streamer_write_tree_body): Rename from lto_output_tree_pointers.\n+ \t(streamer_write_integer_cst): Rename from lto_output_integer_cst.\n+ \t(streamer_write_builtin): Rename from lto_output_builtin_tree.\n+ \t(streamer_check_handled_ts_structures): Rename from\n+ \tcheck_handled_ts_structures.\n+ \t(streamer_tree_cache_insert): Rename from lto_streamer_cache_insert.\n+ \t(streamer_tree_cache_insert_at): Rename from\n+ \tlto_streamer_cache_insert_at.\n+ \t(streamer_tree_cache_append): Rename from lto_streamer_cache_append.\n+ \t(streamer_tree_cache_lookup): Rename from lto_streamer_cache_lookup.\n+ \t(streamer_tree_cache_get): Rename from lto_streamer_cache_get.\n+ \t(streamer_tree_cache_create): Rename from lto_streamer_cache_create.\n+ \t(streamer_tree_cache_delete): Rename from lto_streamer_cache_delete.\n+ \t* tree-streamer-out.c (write_string_cst): Rename from output_string_cst.\n+ \t(write_identifier): Rename from output_identifier.\n+ \t(write_ts_common_tree_pointers): Rename from\n+ \tlto_output_ts_common_tree_pointers.\n+ \t(write_ts_vector_tree_pointers): Rename from\n+ \tlto_output_ts_vector_tree_pointers.\n+ \t(write_ts_complex_tree_pointers): Rename from\n+ \tlto_output_ts_complex_tree_pointers.\n+ \t(write_ts_decl_minimal_tree_pointers): Rename from\n+ \tlto_output_ts_decl_minimal_tree_pointers.\n+ \t(write_ts_decl_common_tree_pointers): Rename from\n+ \tlto_output_ts_decl_common_tree_pointers.\n+ \t(write_ts_decl_non_common_tree_pointers): Rename from\n+ \tlto_output_ts_decl_non_common_tree_pointers.\n+ \t(write_ts_decl_with_vis_tree_pointers): Rename from\n+ \tlto_output_ts_decl_with_vis_tree_pointers.\n+ \t(write_ts_field_decl_tree_pointers): Rename from\n+ \tlto_output_ts_field_decl_tree_pointers.\n+ \t(write_ts_function_decl_tree_pointers): Rename from\n+ \tlto_output_ts_function_decl_tree_pointers.\n+ \t(write_ts_type_common_tree_pointers): Rename from\n+ \tlto_output_ts_type_common_tree_pointers.\n+ \t(write_ts_type_non_common_tree_pointers): Rename from\n+ \tlto_output_ts_type_non_common_tree_pointers.\n+ \t(write_ts_list_tree_pointers): Rename from\n+ \tlto_output_ts_list_tree_pointers.\n+ \t(write_ts_vec_tree_pointers): Rename from\n+ \tlto_output_ts_vec_tree_pointers.\n+ \t(write_ts_exp_tree_pointers): Rename from\n+ \tlto_output_ts_exp_tree_pointers.\n+ \t(write_ts_block_tree_pointers): Rename from\n+ \tlto_output_ts_block_tree_pointers.\n+ \t(write_ts_binfo_tree_pointers): Rename from\n+ \tlto_output_ts_binfo_tree_pointers.\n+ \t(write_ts_constructor_tree_pointers): Rename from\n+ \tlto_output_ts_constructor_tree_pointers.\n+ \t(write_ts_target_option): Rename from\n+ \tlto_output_ts_target_option.\n+ \t(write_ts_translation_unit_decl_tree_pointers): Rename from\n+ \tlto_output_ts_translation_unit_decl_tree_pointers.\n+ \t* tree-streamer.c (streamer_tree_cache_add_to_node_array):\n+ \tRename from lto_streamer_cache_add_to_node_array.\n+ \t(streamer_tree_cache_insert_1): Rename from lto_streamer_cache_insert_1.\n+ \t(record_common_node): Rename from lto_record_common_node.\n+\n+\t* streamer-hooks.h (bitpack_d, lto_streamer_cache_d): Remove forward\n+\tdeclarations.\n+\t* data-streamer-in.c (lto_input_widest_uint_uleb128): Remove unused\n+\tfunction.\n+\t* data-streamer-out.c (lto_output_widest_uint_uleb128_stream): Remove\n+\tunused function.\n+\t* Makefile.in (lto-section-out.o): Add dependency on DATA_STREAMER_H.\n+\t(ipa-reference.o): Likewise.\n+\t* lto-section-out.c: Include data-streamer.h.\n+\t* ipa-reference.c: Include data-streamer.h.\n+\n 2011-08-12  Nick Clifton  <nickc@redhat.com>\n \n \t* builtins.c (expand_builtin_memcmp): Do not use cmpstrnsi"}, {"sha": "762b72bdae9bc50baee005359764b1ae74a796c4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -2345,7 +2345,8 @@ lto-section-out.o : lto-section-out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(DIAGNOSTIC_CORE_H) $(TREE_H) $(EXPR_H) $(PARAMS_H) input.h \\\n    $(HASHTAB_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TREE_PASS_H) \\\n    $(CGRAPH_H) $(FUNCTION_H) $(GGC_H) $(EXCEPT_H) pointer-set.h \\\n-   $(BITMAP_H) langhooks.h $(LTO_STREAMER_H) lto-compress.h\n+   $(BITMAP_H) langhooks.h $(LTO_STREAMER_H) lto-compress.h \\\n+   $(DATA_STREAMER_H)\n lto-symtab.o: lto-symtab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TREE_H) $(GIMPLE_H) $(GGC_H) $(HASHTAB_H) \\\n    $(LTO_STREAMER_H) $(LINKER_PLUGIN_API_H) gt-lto-symtab.h\n@@ -3079,7 +3080,8 @@ ipa-reference.o : ipa-reference.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_REFERENCE_H) $(IPA_UTILS_H) $(SPLAY_TREE_H) \\\n    $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) \\\n-   $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H) $(LTO_STREAMER_H) $(DIAGNOSTIC_CORE_H)\n+   $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H) $(LTO_STREAMER_H) \\\n+   $(DIAGNOSTIC_CORE_H) $(DATA_STREAMER_H)\n ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_UTILS_H) $(TARGET_H) \\"}, {"sha": "72fce0598a7e04ad9c90b0baeacc5759238fc862", "filename": "gcc/data-streamer-in.c", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fdata-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fdata-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer-in.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -45,7 +45,7 @@ string_for_index (struct data_in *data_in, unsigned int loc, unsigned int *rlen)\n   /* Get the string stored at location LOC in DATA_IN->STRINGS.  */\n   LTO_INIT_INPUT_BLOCK (str_tab, data_in->strings, loc - 1,\n \t\t\tdata_in->strings_len);\n-  len = lto_input_uleb128 (&str_tab);\n+  len = streamer_read_uhwi (&str_tab);\n   *rlen = len;\n \n   if (str_tab.p + len > data_in->strings_len)\n@@ -61,22 +61,22 @@ string_for_index (struct data_in *data_in, unsigned int loc, unsigned int *rlen)\n    IB.  Write the length to RLEN.  */\n \n const char *\n-input_string_internal (struct data_in *data_in, struct lto_input_block *ib,\n-\t\t       unsigned int *rlen)\n+streamer_read_indexed_string (struct data_in *data_in,\n+\t\t\t      struct lto_input_block *ib, unsigned int *rlen)\n {\n-  return string_for_index (data_in, lto_input_uleb128 (ib), rlen);\n+  return string_for_index (data_in, streamer_read_uhwi (ib), rlen);\n }\n \n \n /* Read a NULL terminated string from the string table in DATA_IN.  */\n \n const char *\n-lto_input_string (struct data_in *data_in, struct lto_input_block *ib)\n+streamer_read_string (struct data_in *data_in, struct lto_input_block *ib)\n {\n   unsigned int len;\n   const char *ptr;\n \n-  ptr = input_string_internal (data_in, ib, &len);\n+  ptr = streamer_read_indexed_string (data_in, ib, &len);\n   if (!ptr)\n     return NULL;\n   if (ptr[len - 1] != '\\0')\n@@ -86,18 +86,18 @@ lto_input_string (struct data_in *data_in, struct lto_input_block *ib)\n }\n \n \n-/* Read an ULEB128 Number of IB.  */\n+/* Read an unsigned HOST_WIDE_INT number from IB.  */\n \n unsigned HOST_WIDE_INT\n-lto_input_uleb128 (struct lto_input_block *ib)\n+streamer_read_uhwi (struct lto_input_block *ib)\n {\n   unsigned HOST_WIDE_INT result = 0;\n   int shift = 0;\n   unsigned HOST_WIDE_INT byte;\n \n   while (true)\n     {\n-      byte = lto_input_1_unsigned (ib);\n+      byte = streamer_read_uchar (ib);\n       result |= (byte & 0x7f) << shift;\n       shift += 7;\n       if ((byte & 0x80) == 0)\n@@ -106,39 +106,18 @@ lto_input_uleb128 (struct lto_input_block *ib)\n }\n \n \n-/* HOST_WIDEST_INT version of lto_input_uleb128.  IB is as in\n-   lto_input_uleb128.  */\n-\n-unsigned HOST_WIDEST_INT\n-lto_input_widest_uint_uleb128 (struct lto_input_block *ib)\n-{\n-  unsigned HOST_WIDEST_INT result = 0;\n-  int shift = 0;\n-  unsigned HOST_WIDEST_INT byte;\n-\n-  while (true)\n-    {\n-      byte = lto_input_1_unsigned (ib);\n-      result |= (byte & 0x7f) << shift;\n-      shift += 7;\n-      if ((byte & 0x80) == 0)\n-\treturn result;\n-    }\n-}\n-\n-\n-/* Read an SLEB128 Number of IB.  */\n+/* Read a HOST_WIDE_INT number from IB.  */\n \n HOST_WIDE_INT\n-lto_input_sleb128 (struct lto_input_block *ib)\n+streamer_read_hwi (struct lto_input_block *ib)\n {\n   HOST_WIDE_INT result = 0;\n   int shift = 0;\n   unsigned HOST_WIDE_INT byte;\n \n   while (true)\n     {\n-      byte = lto_input_1_unsigned (ib);\n+      byte = streamer_read_uchar (ib);\n       result |= (byte & 0x7f) << shift;\n       shift += 7;\n       if ((byte & 0x80) == 0)"}, {"sha": "98cbf22617638fb9dfbc5e81ad6ea8c7c4ea1a70", "filename": "gcc/data-streamer-out.c", "status": "modified", "additions": 32, "deletions": 54, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fdata-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fdata-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer-out.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -32,8 +32,8 @@ along with GCC; see the file COPYING3.  If not see\n    duration of the OB and thus OB can keep pointer into it.  */\n \n unsigned\n-lto_string_index (struct output_block *ob, const char *s, unsigned int len,\n-\t\t  bool persistent)\n+streamer_string_index (struct output_block *ob, const char *s, unsigned int len,\n+\t\t       bool persistent)\n {\n   struct string_slot **slot;\n   struct string_slot s_slot;\n@@ -64,7 +64,7 @@ lto_string_index (struct output_block *ob, const char *s, unsigned int len,\n       new_slot->len = len;\n       new_slot->slot_num = start;\n       *slot = new_slot;\n-      lto_output_uleb128_stream (string_stream, len);\n+      streamer_write_uhwi_stream (string_stream, len);\n       lto_output_data_stream (string_stream, string, len);\n       return start + 1;\n     }\n@@ -83,15 +83,16 @@ lto_string_index (struct output_block *ob, const char *s, unsigned int len,\n    duration of the OB and thus OB can keep pointer into it.  */\n \n void\n-lto_output_string_with_length (struct output_block *ob,\n-\t\t\t       struct lto_output_stream *index_stream,\n-\t\t\t       const char *s, unsigned int len, bool persistent)\n+streamer_write_string_with_length (struct output_block *ob,\n+\t\t\t\t   struct lto_output_stream *index_stream,\n+\t\t\t\t   const char *s, unsigned int len,\n+\t\t\t\t   bool persistent)\n {\n   if (s)\n-    lto_output_uleb128_stream (index_stream,\n-\t\t\t       lto_string_index (ob, s, len, persistent));\n+    streamer_write_uhwi_stream (index_stream,\n+\t\t\t        streamer_string_index (ob, s, len, persistent));\n   else\n-    lto_output_1_stream (index_stream, 0);\n+    streamer_write_char_stream (index_stream, 0);\n }\n \n \n@@ -101,51 +102,51 @@ lto_output_string_with_length (struct output_block *ob,\n    duration of the OB and thus OB can keep pointer into it.  */\n \n void\n-lto_output_string (struct output_block *ob,\n-\t           struct lto_output_stream *index_stream,\n-\t           const char *string, bool persistent)\n+streamer_write_string (struct output_block *ob,\n+\t\t       struct lto_output_stream *index_stream,\n+\t\t       const char *string, bool persistent)\n {\n   if (string)\n-    lto_output_string_with_length (ob, index_stream, string,\n-\t\t\t\t   strlen (string) + 1,\n-\t\t\t\t   persistent);\n+    streamer_write_string_with_length (ob, index_stream, string,\n+\t\t\t\t       strlen (string) + 1,\n+\t\t\t\t       persistent);\n   else\n-    lto_output_1_stream (index_stream, 0);\n+    streamer_write_char_stream (index_stream, 0);\n }\n \n \n /* Write a zero to the output stream.  */\n \n void\n-output_zero (struct output_block *ob)\n+streamer_write_zero (struct output_block *ob)\n {\n-  lto_output_1_stream (ob->main_stream, 0);\n+  streamer_write_char_stream (ob->main_stream, 0);\n }\n \n \n-/* Output an unsigned LEB128 quantity to OB->main_stream.  */\n+/* Write an unsigned HOST_WIDE_INT value WORK to OB->main_stream.  */\n \n void\n-output_uleb128 (struct output_block *ob, unsigned HOST_WIDE_INT work)\n+streamer_write_uhwi (struct output_block *ob, unsigned HOST_WIDE_INT work)\n {\n-  lto_output_uleb128_stream (ob->main_stream, work);\n+  streamer_write_uhwi_stream (ob->main_stream, work);\n }\n \n \n-/* Output a signed LEB128 quantity to OB->main_stream.  */\n+/* Write a HOST_WIDE_INT value WORK to OB->main_stream.  */\n \n void\n-output_sleb128 (struct output_block *ob, HOST_WIDE_INT work)\n+streamer_write_hwi (struct output_block *ob, HOST_WIDE_INT work)\n {\n-  lto_output_sleb128_stream (ob->main_stream, work);\n+  streamer_write_hwi_stream (ob->main_stream, work);\n }\n \n \n-/* Output an unsigned LEB128 quantity to OBS.  */\n+/* Write an unsigned HOST_WIDE_INT value WORK to OBS.  */\n \n void\n-lto_output_uleb128_stream (struct lto_output_stream *obs,\n-\t\t\t   unsigned HOST_WIDE_INT work)\n+streamer_write_uhwi_stream (struct lto_output_stream *obs,\n+                            unsigned HOST_WIDE_INT work)\n {\n   do\n     {\n@@ -155,39 +156,16 @@ lto_output_uleb128_stream (struct lto_output_stream *obs,\n \t/* More bytes to follow.  */\n \tbyte |= 0x80;\n \n-      lto_output_1_stream (obs, byte);\n+      streamer_write_char_stream (obs, byte);\n     }\n   while (work != 0);\n }\n \n \n-/* Identical to output_uleb128_stream above except using unsigned\n-   HOST_WIDEST_INT type.  For efficiency on host where unsigned HOST_WIDEST_INT\n-   is not native, we only use this if we know that HOST_WIDE_INT is not wide\n-   enough.  */\n+/* Write a HOST_WIDE_INT value WORK to OBS.  */\n \n void\n-lto_output_widest_uint_uleb128_stream (struct lto_output_stream *obs,\n-\t\t\t\t       unsigned HOST_WIDEST_INT work)\n-{\n-  do\n-    {\n-      unsigned int byte = (work & 0x7f);\n-      work >>= 7;\n-      if (work != 0)\n-\t/* More bytes to follow.  */\n-\tbyte |= 0x80;\n-\n-      lto_output_1_stream (obs, byte);\n-    }\n-  while (work != 0);\n-}\n-\n-\n-/* Output a signed LEB128 quantity.  */\n-\n-void\n-lto_output_sleb128_stream (struct lto_output_stream *obs, HOST_WIDE_INT work)\n+streamer_write_hwi_stream (struct lto_output_stream *obs, HOST_WIDE_INT work)\n {\n   int more, byte;\n \n@@ -201,7 +179,7 @@ lto_output_sleb128_stream (struct lto_output_stream *obs, HOST_WIDE_INT work)\n       if (more)\n \tbyte |= 0x80;\n \n-      lto_output_1_stream (obs, byte);\n+      streamer_write_char_stream (obs, byte);\n     }\n   while (more);\n }"}, {"sha": "c413a75930f54c490e56db5cc9ce23c27088f17e", "filename": "gcc/data-streamer.h", "status": "modified", "additions": 65, "deletions": 58, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fdata-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fdata-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer.h?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -55,6 +55,35 @@ struct string_slot\n   unsigned int slot_num;\n };\n \n+/* In data-streamer.c  */\n+void bp_pack_var_len_unsigned (struct bitpack_d *, unsigned HOST_WIDE_INT);\n+void bp_pack_var_len_int (struct bitpack_d *, HOST_WIDE_INT);\n+unsigned HOST_WIDE_INT bp_unpack_var_len_unsigned (struct bitpack_d *);\n+HOST_WIDE_INT bp_unpack_var_len_int (struct bitpack_d *);\n+\n+/* In data-streamer-out.c  */\n+void streamer_write_zero (struct output_block *);\n+void streamer_write_uhwi (struct output_block *, unsigned HOST_WIDE_INT);\n+void streamer_write_hwi (struct output_block *, HOST_WIDE_INT);\n+void streamer_write_string (struct output_block *, struct lto_output_stream *,\n+\t\t\t    const char *, bool);\n+unsigned streamer_string_index (struct output_block *, const char *,\n+\t\t\t\tunsigned int, bool);\n+void streamer_write_string_with_length (struct output_block *,\n+\t\t\t\t\tstruct lto_output_stream *,\n+\t\t\t\t\tconst char *, unsigned int, bool);\n+void streamer_write_uhwi_stream (struct lto_output_stream *,\n+\t\t\t\t unsigned HOST_WIDE_INT);\n+void streamer_write_hwi_stream (struct lto_output_stream *, HOST_WIDE_INT);\n+\n+/* In data-streamer-in.c  */\n+const char *string_for_index (struct data_in *, unsigned int, unsigned int *);\n+const char *streamer_read_string (struct data_in *, struct lto_input_block *);\n+const char *streamer_read_indexed_string (struct data_in *,\n+\t\t\t\t\t  struct lto_input_block *,\n+\t\t\t\t\t  unsigned int *);\n+unsigned HOST_WIDE_INT streamer_read_uhwi (struct lto_input_block *);\n+HOST_WIDE_INT streamer_read_hwi (struct lto_input_block *);\n \n /* Returns a hash code for P.  Adapted from libiberty's htab_hash_string\n    to support strings that may not end in '\\0'.  */\n@@ -111,7 +140,8 @@ bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n      next one.  */\n   if (pos + nbits > BITS_PER_BITPACK_WORD)\n     {\n-      lto_output_uleb128_stream ((struct lto_output_stream *) bp->stream, word);\n+      streamer_write_uhwi_stream ((struct lto_output_stream *) bp->stream,\n+\t\t\t\t  word);\n       word = val;\n       pos = nbits;\n     }\n@@ -126,20 +156,20 @@ bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n \n /* Finishes bit-packing of BP.  */\n static inline void\n-lto_output_bitpack (struct bitpack_d *bp)\n+streamer_write_bitpack (struct bitpack_d *bp)\n {\n-  lto_output_uleb128_stream ((struct lto_output_stream *) bp->stream,\n-\t\t\t     bp->word);\n+  streamer_write_uhwi_stream ((struct lto_output_stream *) bp->stream,\n+\t\t\t      bp->word);\n   bp->word = 0;\n   bp->pos = 0;\n }\n \n /* Returns a new bit-packing context for bit-unpacking from IB.  */\n static inline struct bitpack_d\n-lto_input_bitpack (struct lto_input_block *ib)\n+streamer_read_bitpack (struct lto_input_block *ib)\n {\n   struct bitpack_d bp;\n-  bp.word = lto_input_uleb128 (ib);\n+  bp.word = streamer_read_uhwi (ib);\n   bp.pos = 0;\n   bp.stream = (void *)ib;\n   return bp;\n@@ -160,7 +190,8 @@ bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n      switch to the next one.  */\n   if (pos + nbits > BITS_PER_BITPACK_WORD)\n     {\n-      bp->word = val = lto_input_uleb128 ((struct lto_input_block *)bp->stream);\n+      bp->word = val \n+\t= streamer_read_uhwi ((struct lto_input_block *)bp->stream);\n       bp->pos = nbits;\n       return val & mask;\n     }\n@@ -175,7 +206,7 @@ bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n /* Write a character to the output block.  */\n \n static inline void\n-lto_output_1_stream (struct lto_output_stream *obs, char c)\n+streamer_write_char_stream (struct lto_output_stream *obs, char c)\n {\n   /* No space left.  */\n   if (obs->left_in_block == 0)\n@@ -192,7 +223,7 @@ lto_output_1_stream (struct lto_output_stream *obs, char c)\n /* Read byte from the input block.  */\n \n static inline unsigned char\n-lto_input_1_unsigned (struct lto_input_block *ib)\n+streamer_read_uchar (struct lto_input_block *ib)\n {\n   if (ib->p >= ib->len)\n     lto_section_overrun (ib);\n@@ -204,46 +235,46 @@ lto_input_1_unsigned (struct lto_input_block *ib)\n    Be host independent, limit range to 31bits.  */\n \n static inline void\n-lto_output_int_in_range (struct lto_output_stream *obs,\n-\t\t\t HOST_WIDE_INT min,\n-\t\t\t HOST_WIDE_INT max,\n-\t\t\t HOST_WIDE_INT val)\n+streamer_write_hwi_in_range (struct lto_output_stream *obs,\n+\t\t\t\t  HOST_WIDE_INT min,\n+\t\t\t\t  HOST_WIDE_INT max,\n+\t\t\t\t  HOST_WIDE_INT val)\n {\n   HOST_WIDE_INT range = max - min;\n \n   gcc_checking_assert (val >= min && val <= max && range > 0\n \t\t       && range < 0x7fffffff);\n \n   val -= min;\n-  lto_output_1_stream (obs, val & 255);\n+  streamer_write_char_stream (obs, val & 255);\n   if (range >= 0xff)\n-    lto_output_1_stream (obs, (val >> 8) & 255);\n+    streamer_write_char_stream (obs, (val >> 8) & 255);\n   if (range >= 0xffff)\n-    lto_output_1_stream (obs, (val >> 16) & 255);\n+    streamer_write_char_stream (obs, (val >> 16) & 255);\n   if (range >= 0xffffff)\n-    lto_output_1_stream (obs, (val >> 24) & 255);\n+    streamer_write_char_stream (obs, (val >> 24) & 255);\n }\n \n /* Input VAL into OBS and verify it is in range MIN...MAX that is supposed\n    to be compile time constant.  PURPOSE is used for error reporting.  */\n \n static inline HOST_WIDE_INT\n-lto_input_int_in_range (struct lto_input_block *ib,\n-\t\t\tconst char *purpose,\n-\t\t\tHOST_WIDE_INT min,\n-\t\t\tHOST_WIDE_INT max)\n+streamer_read_hwi_in_range (struct lto_input_block *ib,\n+\t\t\t\t const char *purpose,\n+\t\t\t\t HOST_WIDE_INT min,\n+\t\t\t\t HOST_WIDE_INT max)\n {\n   HOST_WIDE_INT range = max - min;\n-  HOST_WIDE_INT val = lto_input_1_unsigned (ib);\n+  HOST_WIDE_INT val = streamer_read_uchar (ib);\n \n   gcc_checking_assert (range > 0 && range < 0x7fffffff);\n \n   if (range >= 0xff)\n-    val |= ((HOST_WIDE_INT)lto_input_1_unsigned (ib)) << 8;\n+    val |= ((HOST_WIDE_INT)streamer_read_uchar (ib)) << 8;\n   if (range >= 0xffff)\n-    val |= ((HOST_WIDE_INT)lto_input_1_unsigned (ib)) << 16;\n+    val |= ((HOST_WIDE_INT)streamer_read_uchar (ib)) << 16;\n   if (range >= 0xffffff)\n-    val |= ((HOST_WIDE_INT)lto_input_1_unsigned (ib)) << 24;\n+    val |= ((HOST_WIDE_INT)streamer_read_uchar (ib)) << 24;\n   val += min;\n   if (val < min || val > max)\n     lto_value_range_error (purpose, val, min, max);\n@@ -292,14 +323,14 @@ bp_unpack_int_in_range (struct bitpack_d *bp,\n \n /* Output VAL of type \"enum enum_name\" into OBS.\n    Assume range 0...ENUM_LAST - 1.  */\n-#define lto_output_enum(obs,enum_name,enum_last,val) \\\n-  lto_output_int_in_range ((obs), 0, (int)(enum_last) - 1, (int)(val))\n+#define streamer_write_enum(obs,enum_name,enum_last,val) \\\n+  streamer_write_hwi_in_range ((obs), 0, (int)(enum_last) - 1, (int)(val))\n \n /* Input enum of type \"enum enum_name\" from IB.\n    Assume range 0...ENUM_LAST - 1.  */\n-#define lto_input_enum(ib,enum_name,enum_last) \\\n-  (enum enum_name)lto_input_int_in_range ((ib), #enum_name, 0, \\\n-\t\t\t\t\t  (int)(enum_last) - 1)\n+#define streamer_read_enum(ib,enum_name,enum_last) \\\n+  (enum enum_name)streamer_read_hwi_in_range ((ib), #enum_name, 0, \\\n+\t\t\t\t\t      (int)(enum_last) - 1)\n \n /* Output VAL of type \"enum enum_name\" into BP.\n    Assume range 0...ENUM_LAST - 1.  */\n@@ -315,41 +346,17 @@ bp_unpack_int_in_range (struct bitpack_d *bp,\n /* Output the start of a record with TAG to output block OB.  */\n \n static inline void\n-output_record_start (struct output_block *ob, enum LTO_tags tag)\n+streamer_write_record_start (struct output_block *ob, enum LTO_tags tag)\n {\n-  lto_output_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS, tag);\n+  streamer_write_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS, tag);\n }\n \n /* Return the next tag in the input block IB.  */\n \n static inline enum LTO_tags\n-input_record_start (struct lto_input_block *ib)\n+streamer_read_record_start (struct lto_input_block *ib)\n {\n-  return lto_input_enum (ib, LTO_tags, LTO_NUM_TAGS);\n+  return streamer_read_enum (ib, LTO_tags, LTO_NUM_TAGS);\n }\n \n-/* In data-streamer.c  */\n-void bp_pack_var_len_unsigned (struct bitpack_d *, unsigned HOST_WIDE_INT);\n-void bp_pack_var_len_int (struct bitpack_d *, HOST_WIDE_INT);\n-unsigned HOST_WIDE_INT bp_unpack_var_len_unsigned (struct bitpack_d *);\n-HOST_WIDE_INT bp_unpack_var_len_int (struct bitpack_d *);\n-\n-/* In data-streamer-out.c  */\n-void output_zero (struct output_block *);\n-void output_uleb128 (struct output_block *, unsigned HOST_WIDE_INT);\n-void output_sleb128 (struct output_block *, HOST_WIDE_INT);\n-void lto_output_string (struct output_block *, struct lto_output_stream *,\n-\t\t\tconst char *, bool);\n-unsigned lto_string_index (struct output_block *, const char *, unsigned int,\n-\t\t\t   bool);\n-void lto_output_string_with_length (struct output_block *,\n-\t\t\t\t    struct lto_output_stream *,\n-\t\t\t\t    const char *, unsigned int, bool);\n-const char *input_string_internal (struct data_in *, struct lto_input_block *,\n-\t\t\t\t   unsigned int *);\n-\n-/* In data-streamer-in.c  */\n-const char *string_for_index (struct data_in *, unsigned int, unsigned int *);\n-const char *lto_input_string (struct data_in *, struct lto_input_block *);\n-\n #endif  /* GCC_DATA_STREAMER_H  */"}, {"sha": "fc6ceb43aa1b9956a01012a3361f29ad228472dd", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -41,7 +41,7 @@ input_phi (struct lto_input_block *ib, basic_block bb, struct data_in *data_in,\n   int i, len;\n   gimple result;\n \n-  ix = lto_input_uleb128 (ib);\n+  ix = streamer_read_uhwi (ib);\n   phi_result = VEC_index (tree, SSANAMES (fn), ix);\n   len = EDGE_COUNT (bb->preds);\n   result = create_phi_node (phi_result, bb);\n@@ -53,7 +53,7 @@ input_phi (struct lto_input_block *ib, basic_block bb, struct data_in *data_in,\n   for (i = 0; i < len; i++)\n     {\n       tree def = stream_read_tree (ib, data_in);\n-      int src_index = lto_input_uleb128 (ib);\n+      int src_index = streamer_read_uhwi (ib);\n       location_t arg_loc = lto_input_location (ib, data_in);\n       basic_block sbb = BASIC_BLOCK_FOR_FUNCTION (fn, src_index);\n \n@@ -90,7 +90,7 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n   code = lto_tag_to_gimple_code (tag);\n \n   /* Read the tuple header.  */\n-  bp = lto_input_bitpack (ib);\n+  bp = streamer_read_bitpack (ib);\n   num_ops = bp_unpack_var_len_unsigned (&bp);\n   stmt = gimple_alloc (code, num_ops);\n   stmt->gsbase.no_warning = bp_unpack_value (&bp, 1);\n@@ -109,26 +109,26 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n   switch (code)\n     {\n     case GIMPLE_RESX:\n-      gimple_resx_set_region (stmt, lto_input_sleb128 (ib));\n+      gimple_resx_set_region (stmt, streamer_read_hwi (ib));\n       break;\n \n     case GIMPLE_EH_MUST_NOT_THROW:\n       gimple_eh_must_not_throw_set_fndecl (stmt, stream_read_tree (ib, data_in));\n       break;\n \n     case GIMPLE_EH_DISPATCH:\n-      gimple_eh_dispatch_set_region (stmt, lto_input_sleb128 (ib));\n+      gimple_eh_dispatch_set_region (stmt, streamer_read_hwi (ib));\n       break;\n \n     case GIMPLE_ASM:\n       {\n \t/* FIXME lto.  Move most of this into a new gimple_asm_set_string().  */\n \ttree str;\n-\tstmt->gimple_asm.ni = lto_input_uleb128 (ib);\n-\tstmt->gimple_asm.no = lto_input_uleb128 (ib);\n-\tstmt->gimple_asm.nc = lto_input_uleb128 (ib);\n-\tstmt->gimple_asm.nl = lto_input_uleb128 (ib);\n-\tstr = input_string_cst (data_in, ib);\n+\tstmt->gimple_asm.ni = streamer_read_uhwi (ib);\n+\tstmt->gimple_asm.no = streamer_read_uhwi (ib);\n+\tstmt->gimple_asm.nc = streamer_read_uhwi (ib);\n+\tstmt->gimple_asm.nl = streamer_read_uhwi (ib);\n+\tstr = streamer_read_string_cst (data_in, ib);\n \tstmt->gimple_asm.string = TREE_STRING_POINTER (str);\n       }\n       /* Fallthru  */\n@@ -221,7 +221,7 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t{\n \t  if (gimple_call_internal_p (stmt))\n \t    gimple_call_set_internal_fn\n-\t      (stmt, lto_input_enum (ib, internal_fn, IFN_LAST));\n+\t      (stmt, streamer_read_enum (ib, internal_fn, IFN_LAST));\n \t  else\n \t    gimple_call_set_fntype (stmt, stream_read_tree (ib, data_in));\n \t}\n@@ -286,21 +286,21 @@ input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n      basic GIMPLE routines that use CFUN.  */\n   gcc_assert (cfun == fn);\n \n-  index = lto_input_uleb128 (ib);\n+  index = streamer_read_uhwi (ib);\n   bb = BASIC_BLOCK_FOR_FUNCTION (fn, index);\n \n-  bb->count = (lto_input_sleb128 (ib) * count_materialization_scale\n+  bb->count = (streamer_read_hwi (ib) * count_materialization_scale\n \t       + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n-  bb->loop_depth = lto_input_sleb128 (ib);\n-  bb->frequency = lto_input_sleb128 (ib);\n-  bb->flags = lto_input_sleb128 (ib);\n+  bb->loop_depth = streamer_read_hwi (ib);\n+  bb->frequency = streamer_read_hwi (ib);\n+  bb->flags = streamer_read_hwi (ib);\n \n   /* LTO_bb1 has statements.  LTO_bb0 does not.  */\n   if (tag == LTO_bb0)\n     return;\n \n   bsi = gsi_start_bb (bb);\n-  tag = input_record_start (ib);\n+  tag = streamer_read_record_start (ib);\n   while (tag)\n     {\n       gimple stmt = input_gimple_stmt (ib, data_in, fn, tag);\n@@ -310,24 +310,24 @@ input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n \n       /* After the statement, expect a 0 delimiter or the EH region\n \t that the previous statement belongs to.  */\n-      tag = input_record_start (ib);\n+      tag = streamer_read_record_start (ib);\n       lto_tag_check_set (tag, 2, LTO_eh_region, LTO_null);\n \n       if (tag == LTO_eh_region)\n \t{\n-\t  HOST_WIDE_INT region = lto_input_sleb128 (ib);\n+\t  HOST_WIDE_INT region = streamer_read_hwi (ib);\n \t  gcc_assert (region == (int) region);\n \t  add_stmt_to_eh_lp (stmt, region);\n \t}\n \n-      tag = input_record_start (ib);\n+      tag = streamer_read_record_start (ib);\n     }\n \n-  tag = input_record_start (ib);\n+  tag = streamer_read_record_start (ib);\n   while (tag)\n     {\n       gimple phi = input_phi (ib, bb, data_in, fn);\n       find_referenced_vars_in (phi);\n-      tag = input_record_start (ib);\n+      tag = streamer_read_record_start (ib);\n     }\n }"}, {"sha": "78ed2815dde28855254339049e0c0384b464e71c", "filename": "gcc/gimple-streamer-out.c", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -36,13 +36,13 @@ output_phi (struct output_block *ob, gimple phi)\n {\n   unsigned i, len = gimple_phi_num_args (phi);\n \n-  output_record_start (ob, lto_gimple_code_to_tag (GIMPLE_PHI));\n-  output_uleb128 (ob, SSA_NAME_VERSION (PHI_RESULT (phi)));\n+  streamer_write_record_start (ob, lto_gimple_code_to_tag (GIMPLE_PHI));\n+  streamer_write_uhwi (ob, SSA_NAME_VERSION (PHI_RESULT (phi)));\n \n   for (i = 0; i < len; i++)\n     {\n       stream_write_tree (ob, gimple_phi_arg_def (phi, i), true);\n-      output_uleb128 (ob, gimple_phi_arg_edge (phi, i)->src->index);\n+      streamer_write_uhwi (ob, gimple_phi_arg_edge (phi, i)->src->index);\n       lto_output_location (ob, gimple_phi_arg_location (phi, i));\n     }\n }\n@@ -61,7 +61,7 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n   /* Emit identifying tag.  */\n   code = gimple_code (stmt);\n   tag = lto_gimple_code_to_tag (code);\n-  output_record_start (ob, tag);\n+  streamer_write_record_start (ob, tag);\n \n   /* Emit the tuple header.  */\n   bp = bitpack_create (ob->main_stream);\n@@ -71,7 +71,7 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n     bp_pack_value (&bp, gimple_assign_nontemporal_move_p (stmt), 1);\n   bp_pack_value (&bp, gimple_has_volatile_ops (stmt), 1);\n   bp_pack_var_len_unsigned (&bp, stmt->gsbase.subcode);\n-  lto_output_bitpack (&bp);\n+  streamer_write_bitpack (&bp);\n \n   /* Emit location information for the statement.  */\n   lto_output_location (ob, gimple_location (stmt));\n@@ -83,23 +83,24 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_RESX:\n-      output_sleb128 (ob, gimple_resx_region (stmt));\n+      streamer_write_hwi (ob, gimple_resx_region (stmt));\n       break;\n \n     case GIMPLE_EH_MUST_NOT_THROW:\n       stream_write_tree (ob, gimple_eh_must_not_throw_fndecl (stmt), true);\n       break;\n \n     case GIMPLE_EH_DISPATCH:\n-      output_sleb128 (ob, gimple_eh_dispatch_region (stmt));\n+      streamer_write_hwi (ob, gimple_eh_dispatch_region (stmt));\n       break;\n \n     case GIMPLE_ASM:\n-      lto_output_uleb128_stream (ob->main_stream, gimple_asm_ninputs (stmt));\n-      lto_output_uleb128_stream (ob->main_stream, gimple_asm_noutputs (stmt));\n-      lto_output_uleb128_stream (ob->main_stream, gimple_asm_nclobbers (stmt));\n-      lto_output_uleb128_stream (ob->main_stream, gimple_asm_nlabels (stmt));\n-      lto_output_string (ob, ob->main_stream, gimple_asm_string (stmt), true);\n+      streamer_write_uhwi (ob, gimple_asm_ninputs (stmt));\n+      streamer_write_uhwi (ob, gimple_asm_noutputs (stmt));\n+      streamer_write_uhwi (ob, gimple_asm_nclobbers (stmt));\n+      streamer_write_uhwi (ob, gimple_asm_nlabels (stmt));\n+      streamer_write_string (ob, ob->main_stream, gimple_asm_string (stmt),\n+\t\t\t     true);\n       /* Fallthru  */\n \n     case GIMPLE_ASSIGN:\n@@ -139,8 +140,8 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n       if (is_gimple_call (stmt))\n \t{\n \t  if (gimple_call_internal_p (stmt))\n-\t    lto_output_enum (ob->main_stream, internal_fn,\n-\t\t\t     IFN_LAST, gimple_call_internal_fn (stmt));\n+\t    streamer_write_enum (ob->main_stream, internal_fn,\n+\t\t\t\t IFN_LAST, gimple_call_internal_fn (stmt));\n \t  else\n \t    stream_write_tree (ob, gimple_call_fntype (stmt), true);\n \t}\n@@ -163,16 +164,16 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n {\n   gimple_stmt_iterator bsi = gsi_start_bb (bb);\n \n-  output_record_start (ob,\n-\t\t       (!gsi_end_p (bsi)) || phi_nodes (bb)\n-\t\t        ? LTO_bb1\n-\t\t\t: LTO_bb0);\n+  streamer_write_record_start (ob,\n+\t\t\t       (!gsi_end_p (bsi)) || phi_nodes (bb)\n+\t\t\t        ? LTO_bb1\n+\t\t\t\t: LTO_bb0);\n \n-  output_uleb128 (ob, bb->index);\n-  output_sleb128 (ob, bb->count);\n-  output_sleb128 (ob, bb->loop_depth);\n-  output_sleb128 (ob, bb->frequency);\n-  output_sleb128 (ob, bb->flags);\n+  streamer_write_uhwi (ob, bb->index);\n+  streamer_write_hwi (ob, bb->count);\n+  streamer_write_hwi (ob, bb->loop_depth);\n+  streamer_write_hwi (ob, bb->frequency);\n+  streamer_write_hwi (ob, bb->flags);\n \n   if (!gsi_end_p (bsi) || phi_nodes (bb))\n     {\n@@ -189,14 +190,14 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n \t  region = lookup_stmt_eh_lp_fn (fn, stmt);\n \t  if (region != 0)\n \t    {\n-\t      output_record_start (ob, LTO_eh_region);\n-\t      output_sleb128 (ob, region);\n+\t      streamer_write_record_start (ob, LTO_eh_region);\n+\t      streamer_write_hwi (ob, region);\n \t    }\n \t  else\n-\t    output_record_start (ob, LTO_null);\n+\t    streamer_write_record_start (ob, LTO_null);\n \t}\n \n-      output_record_start (ob, LTO_null);\n+      streamer_write_record_start (ob, LTO_null);\n \n       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t{\n@@ -209,6 +210,6 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n \t    output_phi (ob, phi);\n \t}\n \n-      output_record_start (ob, LTO_null);\n+      streamer_write_record_start (ob, LTO_null);\n     }\n }"}, {"sha": "c0eacbb62fde50b7a32e8e3054b2a823084e2ef0", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 34, "deletions": 45, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -2326,7 +2326,7 @@ read_predicate (struct lto_input_block *ib)\n   do \n     {\n       gcc_assert (k <= MAX_CLAUSES);\n-      clause = out.clause[k++] = lto_input_uleb128 (ib);\n+      clause = out.clause[k++] = streamer_read_uhwi (ib);\n     }\n   while (clause);\n \n@@ -2346,9 +2346,9 @@ read_inline_edge_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n   struct inline_edge_summary *es = inline_edge_summary (e);\n   struct predicate p;\n \n-  es->call_stmt_size = lto_input_uleb128 (ib);\n-  es->call_stmt_time = lto_input_uleb128 (ib);\n-  es->loop_depth = lto_input_uleb128 (ib);\n+  es->call_stmt_size = streamer_read_uhwi (ib);\n+  es->call_stmt_time = streamer_read_uhwi (ib);\n+  es->loop_depth = streamer_read_uhwi (ib);\n   p = read_predicate (ib);\n   edge_set_predicate (e, &p);\n }\n@@ -2376,7 +2376,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n   data_in =\n     lto_data_in_create (file_data, (const char *) data + string_offset,\n \t\t\theader->string_size, NULL);\n-  f_count = lto_input_uleb128 (&ib);\n+  f_count = streamer_read_uhwi (&ib);\n   for (i = 0; i < f_count; i++)\n     {\n       unsigned int index;\n@@ -2386,38 +2386,38 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       struct bitpack_d bp;\n       struct cgraph_edge *e;\n \n-      index = lto_input_uleb128 (&ib);\n+      index = streamer_read_uhwi (&ib);\n       encoder = file_data->cgraph_node_encoder;\n       node = lto_cgraph_encoder_deref (encoder, index);\n       info = inline_summary (node);\n \n       info->estimated_stack_size\n-\t= info->estimated_self_stack_size = lto_input_uleb128 (&ib);\n-      info->size = info->self_size = lto_input_uleb128 (&ib);\n-      info->time = info->self_time = lto_input_uleb128 (&ib);\n+\t= info->estimated_self_stack_size = streamer_read_uhwi (&ib);\n+      info->size = info->self_size = streamer_read_uhwi (&ib);\n+      info->time = info->self_time = streamer_read_uhwi (&ib);\n \n-      bp = lto_input_bitpack (&ib);\n+      bp = streamer_read_bitpack (&ib);\n       info->inlinable = bp_unpack_value (&bp, 1);\n       info->versionable = bp_unpack_value (&bp, 1);\n \n-      count2 = lto_input_uleb128 (&ib);\n+      count2 = streamer_read_uhwi (&ib);\n       gcc_assert (!info->conds);\n       for (j = 0; j < count2; j++)\n \t{\n \t  struct condition c;\n-\t  c.operand_num = lto_input_uleb128 (&ib);\n-\t  c.code = (enum tree_code) lto_input_uleb128 (&ib);\n+\t  c.operand_num = streamer_read_uhwi (&ib);\n+\t  c.code = (enum tree_code) streamer_read_uhwi (&ib);\n \t  c.val = stream_read_tree (&ib, data_in);\n \t  VEC_safe_push (condition, gc, info->conds, &c);\n \t}\n-      count2 = lto_input_uleb128 (&ib);\n+      count2 = streamer_read_uhwi (&ib);\n       gcc_assert (!info->entry);\n       for (j = 0; j < count2; j++)\n \t{\n \t  struct size_time_entry e;\n \n-\t  e.size = lto_input_uleb128 (&ib);\n-\t  e.time = lto_input_uleb128 (&ib);\n+\t  e.size = streamer_read_uhwi (&ib);\n+\t  e.time = streamer_read_uhwi (&ib);\n \t  e.predicate = read_predicate (&ib);\n \n \t  VEC_safe_push (size_time_entry, gc, info->entry, &e);\n@@ -2480,10 +2480,9 @@ write_predicate (struct output_block *ob, struct predicate *p)\n     for (j = 0; p->clause[j]; j++)\n       {\n \t gcc_assert (j < MAX_CLAUSES);\n-\t lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t    p->clause[j]);\n+\t streamer_write_uhwi (ob, p->clause[j]);\n       }\n-  lto_output_uleb128_stream (ob->main_stream, 0);\n+  streamer_write_uhwi (ob, 0);\n }\n \n \n@@ -2493,9 +2492,9 @@ static void\n write_inline_edge_summary (struct output_block *ob, struct cgraph_edge *e)\n {\n   struct inline_edge_summary *es = inline_edge_summary (e);\n-  lto_output_uleb128_stream (ob->main_stream, es->call_stmt_size);\n-  lto_output_uleb128_stream (ob->main_stream, es->call_stmt_time);\n-  lto_output_uleb128_stream (ob->main_stream, es->loop_depth);\n+  streamer_write_uhwi (ob, es->call_stmt_size);\n+  streamer_write_uhwi (ob, es->call_stmt_time);\n+  streamer_write_uhwi (ob, es->loop_depth);\n   write_predicate (ob, es->predicate);\n }\n \n@@ -2517,7 +2516,7 @@ inline_write_summary (cgraph_node_set set,\n   for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n     if (lto_cgraph_encoder_deref (encoder, i)->analyzed)\n       count++;\n-  lto_output_uleb128_stream (ob->main_stream, count);\n+  streamer_write_uhwi (ob, count);\n \n   for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n     {\n@@ -2532,38 +2531,28 @@ inline_write_summary (cgraph_node_set set,\n \t  struct condition *c;\n \t  \n \n-\t  lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t     lto_cgraph_encoder_encode (encoder, node));\n-\t  lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t     info->estimated_self_stack_size);\n-\t  lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t     info->self_size);\n-\t  lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t\t     info->self_time);\n+\t  streamer_write_uhwi (ob, lto_cgraph_encoder_encode (encoder, node));\n+\t  streamer_write_hwi (ob, info->estimated_self_stack_size);\n+\t  streamer_write_hwi (ob, info->self_size);\n+\t  streamer_write_hwi (ob, info->self_time);\n \t  bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, info->inlinable, 1);\n \t  bp_pack_value (&bp, info->versionable, 1);\n-\t  lto_output_bitpack (&bp);\n-\t  lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t     VEC_length (condition, info->conds));\n+\t  streamer_write_bitpack (&bp);\n+\t  streamer_write_uhwi (ob, VEC_length (condition, info->conds));\n \t  for (i = 0; VEC_iterate (condition, info->conds, i, c); i++)\n \t    {\n-\t      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t\t c->operand_num);\n-\t      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t\t c->code);\n+\t      streamer_write_uhwi (ob, c->operand_num);\n+\t      streamer_write_uhwi (ob, c->code);\n \t      stream_write_tree (ob, c->val, true);\n \t    }\n-\t  lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t     VEC_length (size_time_entry, info->entry));\n+\t  streamer_write_uhwi (ob, VEC_length (size_time_entry, info->entry));\n \t  for (i = 0;\n \t       VEC_iterate (size_time_entry, info->entry, i, e);\n \t       i++)\n \t    {\n-\t      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t\t e->size);\n-\t      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t\t e->time);\n+\t      streamer_write_uhwi (ob, e->size);\n+\t      streamer_write_uhwi (ob, e->time);\n \t      write_predicate (ob, &e->predicate);\n \t    }\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n@@ -2572,7 +2561,7 @@ inline_write_summary (cgraph_node_set set,\n \t    write_inline_edge_summary (ob, edge);\n \t}\n     }\n-  lto_output_1_stream (ob->main_stream, 0);\n+  streamer_write_char_stream (ob->main_stream, 0);\n   produce_asm (ob, NULL);\n   destroy_output_block (ob);\n "}, {"sha": "a81bb3cb1cdf5d1d9f60ece397c9e1622276cc76", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -2644,8 +2644,7 @@ static void\n ipa_write_jump_function (struct output_block *ob,\n \t\t\t struct ipa_jump_func *jump_func)\n {\n-  lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t     jump_func->type);\n+  streamer_write_uhwi (ob, jump_func->type);\n \n   switch (jump_func->type)\n     {\n@@ -2659,17 +2658,13 @@ ipa_write_jump_function (struct output_block *ob,\n       break;\n     case IPA_JF_PASS_THROUGH:\n       stream_write_tree (ob, jump_func->value.pass_through.operand, true);\n-      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t jump_func->value.pass_through.formal_id);\n-      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t jump_func->value.pass_through.operation);\n+      streamer_write_uhwi (ob, jump_func->value.pass_through.formal_id);\n+      streamer_write_uhwi (ob, jump_func->value.pass_through.operation);\n       break;\n     case IPA_JF_ANCESTOR:\n-      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t jump_func->value.ancestor.offset);\n+      streamer_write_uhwi (ob, jump_func->value.ancestor.offset);\n       stream_write_tree (ob, jump_func->value.ancestor.type, true);\n-      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t jump_func->value.ancestor.formal_id);\n+      streamer_write_uhwi (ob, jump_func->value.ancestor.formal_id);\n       break;\n     case IPA_JF_CONST_MEMBER_PTR:\n       stream_write_tree (ob, jump_func->value.member_cst.pfn, true);\n@@ -2685,7 +2680,7 @@ ipa_read_jump_function (struct lto_input_block *ib,\n \t\t\tstruct ipa_jump_func *jump_func,\n \t\t\tstruct data_in *data_in)\n {\n-  jump_func->type = (enum jump_func_type) lto_input_uleb128 (ib);\n+  jump_func->type = (enum jump_func_type) streamer_read_uhwi (ib);\n \n   switch (jump_func->type)\n     {\n@@ -2699,13 +2694,14 @@ ipa_read_jump_function (struct lto_input_block *ib,\n       break;\n     case IPA_JF_PASS_THROUGH:\n       jump_func->value.pass_through.operand = stream_read_tree (ib, data_in);\n-      jump_func->value.pass_through.formal_id = lto_input_uleb128 (ib);\n-      jump_func->value.pass_through.operation = (enum tree_code) lto_input_uleb128 (ib);\n+      jump_func->value.pass_through.formal_id = streamer_read_uhwi (ib);\n+      jump_func->value.pass_through.operation\n+\t= (enum tree_code) streamer_read_uhwi (ib);\n       break;\n     case IPA_JF_ANCESTOR:\n-      jump_func->value.ancestor.offset = lto_input_uleb128 (ib);\n+      jump_func->value.ancestor.offset = streamer_read_uhwi (ib);\n       jump_func->value.ancestor.type = stream_read_tree (ib, data_in);\n-      jump_func->value.ancestor.formal_id = lto_input_uleb128 (ib);\n+      jump_func->value.ancestor.formal_id = streamer_read_uhwi (ib);\n       break;\n     case IPA_JF_CONST_MEMBER_PTR:\n       jump_func->value.member_cst.pfn = stream_read_tree (ib, data_in);\n@@ -2724,15 +2720,15 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n   struct cgraph_indirect_call_info *ii = cs->indirect_info;\n   struct bitpack_d bp;\n \n-  lto_output_sleb128_stream (ob->main_stream, ii->param_index);\n-  lto_output_sleb128_stream (ob->main_stream, ii->anc_offset);\n+  streamer_write_hwi (ob, ii->param_index);\n+  streamer_write_hwi (ob, ii->anc_offset);\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, ii->polymorphic, 1);\n-  lto_output_bitpack (&bp);\n+  streamer_write_bitpack (&bp);\n \n   if (ii->polymorphic)\n     {\n-      lto_output_sleb128_stream (ob->main_stream, ii->otr_token);\n+      streamer_write_hwi (ob, ii->otr_token);\n       stream_write_tree (ob, ii->otr_type, true);\n     }\n }\n@@ -2748,13 +2744,13 @@ ipa_read_indirect_edge_info (struct lto_input_block *ib,\n   struct cgraph_indirect_call_info *ii = cs->indirect_info;\n   struct bitpack_d bp;\n \n-  ii->param_index = (int) lto_input_sleb128 (ib);\n-  ii->anc_offset = (HOST_WIDE_INT) lto_input_sleb128 (ib);\n-  bp = lto_input_bitpack (ib);\n+  ii->param_index = (int) streamer_read_hwi (ib);\n+  ii->anc_offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n+  bp = streamer_read_bitpack (ib);\n   ii->polymorphic = bp_unpack_value (&bp, 1);\n   if (ii->polymorphic)\n     {\n-      ii->otr_token = (HOST_WIDE_INT) lto_input_sleb128 (ib);\n+      ii->otr_token = (HOST_WIDE_INT) streamer_read_hwi (ib);\n       ii->otr_type = stream_read_tree (ib, data_in);\n     }\n }\n@@ -2773,7 +2769,7 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n \n   encoder = ob->decl_state->cgraph_node_encoder;\n   node_ref = lto_cgraph_encoder_encode (encoder, node);\n-  lto_output_uleb128_stream (ob->main_stream, node_ref);\n+  streamer_write_uhwi (ob, node_ref);\n \n   bp = bitpack_create (ob->main_stream);\n   gcc_assert (info->uses_analysis_done\n@@ -2782,22 +2778,20 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n   gcc_assert (!info->ipcp_orig_node);\n   for (j = 0; j < ipa_get_param_count (info); j++)\n     bp_pack_value (&bp, ipa_is_param_used (info, j), 1);\n-  lto_output_bitpack (&bp);\n+  streamer_write_bitpack (&bp);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n \n-      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t ipa_get_cs_argument_count (args));\n+      streamer_write_uhwi (ob, ipa_get_cs_argument_count (args));\n       for (j = 0; j < ipa_get_cs_argument_count (args); j++)\n \tipa_write_jump_function (ob, ipa_get_ith_jump_func (args, j));\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n \n-      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t ipa_get_cs_argument_count (args));\n+      streamer_write_uhwi (ob, ipa_get_cs_argument_count (args));\n       for (j = 0; j < ipa_get_cs_argument_count (args); j++)\n \tipa_write_jump_function (ob, ipa_get_ith_jump_func (args, j));\n       ipa_write_indirect_edge_info (ob, e);\n@@ -2817,7 +2811,7 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n \n   ipa_initialize_node_params (node);\n \n-  bp = lto_input_bitpack (ib);\n+  bp = streamer_read_bitpack (ib);\n   if (ipa_get_param_count (info) != 0)\n     info->uses_analysis_done = true;\n   info->node_enqueued = false;\n@@ -2826,7 +2820,7 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n-      int count = lto_input_uleb128 (ib);\n+      int count = streamer_read_uhwi (ib);\n \n       ipa_set_cs_argument_count (args, count);\n       if (!count)\n@@ -2840,7 +2834,7 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n-      int count = lto_input_uleb128 (ib);\n+      int count = streamer_read_uhwi (ib);\n \n       ipa_set_cs_argument_count (args, count);\n       if (count)\n@@ -2877,7 +2871,7 @@ ipa_prop_write_jump_functions (cgraph_node_set set)\n \tcount++;\n     }\n \n-  lto_output_uleb128_stream (ob->main_stream, count);\n+  streamer_write_uhwi (ob, count);\n \n   /* Process all of the functions.  */\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n@@ -2887,7 +2881,7 @@ ipa_prop_write_jump_functions (cgraph_node_set set)\n \t  && IPA_NODE_REF (node) != NULL)\n         ipa_write_node_info (ob, node);\n     }\n-  lto_output_1_stream (ob->main_stream, 0);\n+  streamer_write_char_stream (ob->main_stream, 0);\n   produce_asm (ob, NULL);\n   destroy_output_block (ob);\n }\n@@ -2914,15 +2908,15 @@ ipa_prop_read_section (struct lto_file_decl_data *file_data, const char *data,\n   data_in =\n     lto_data_in_create (file_data, (const char *) data + string_offset,\n \t\t\theader->string_size, NULL);\n-  count = lto_input_uleb128 (&ib_main);\n+  count = streamer_read_uhwi (&ib_main);\n \n   for (i = 0; i < count; i++)\n     {\n       unsigned int index;\n       struct cgraph_node *node;\n       lto_cgraph_encoder_t encoder;\n \n-      index = lto_input_uleb128 (&ib_main);\n+      index = streamer_read_uhwi (&ib_main);\n       encoder = file_data->cgraph_node_encoder;\n       node = lto_cgraph_encoder_deref (encoder, index);\n       gcc_assert (node->analyzed);"}, {"sha": "36212cda67b5708107ae66e577cc633a8e2eddd0", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -950,7 +950,7 @@ pure_const_write_summary (cgraph_node_set set,\n \tcount++;\n     }\n \n-  lto_output_uleb128_stream (ob->main_stream, count);\n+  streamer_write_uhwi_stream (ob->main_stream, count);\n \n   /* Process all of the functions.  */\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n@@ -967,7 +967,7 @@ pure_const_write_summary (cgraph_node_set set,\n \n \t  encoder = ob->decl_state->cgraph_node_encoder;\n \t  node_ref = lto_cgraph_encoder_encode (encoder, node);\n-\t  lto_output_uleb128_stream (ob->main_stream, node_ref);\n+\t  streamer_write_uhwi_stream (ob->main_stream, node_ref);\n \n \t  /* Note that flags will need to be read in the opposite\n \t     order as we are pushing the bitflags into FLAGS.  */\n@@ -977,7 +977,7 @@ pure_const_write_summary (cgraph_node_set set,\n \t  bp_pack_value (&bp, fs->looping_previously_known, 1);\n \t  bp_pack_value (&bp, fs->looping, 1);\n \t  bp_pack_value (&bp, fs->can_throw, 1);\n-\t  lto_output_bitpack (&bp);\n+\t  streamer_write_bitpack (&bp);\n \t}\n     }\n \n@@ -1006,7 +1006,7 @@ pure_const_read_summary (void)\n       if (ib)\n \t{\n \t  unsigned int i;\n-\t  unsigned int count = lto_input_uleb128 (ib);\n+\t  unsigned int count = streamer_read_uhwi (ib);\n \n \t  for (i = 0; i < count; i++)\n \t    {\n@@ -1017,15 +1017,15 @@ pure_const_read_summary (void)\n \t      lto_cgraph_encoder_t encoder;\n \n \t      fs = XCNEW (struct funct_state_d);\n-\t      index = lto_input_uleb128 (ib);\n+\t      index = streamer_read_uhwi (ib);\n \t      encoder = file_data->cgraph_node_encoder;\n \t      node = lto_cgraph_encoder_deref (encoder, index);\n \t      set_function_state (node, fs);\n \n \t      /* Note that the flags must be read in the opposite\n \t\t order in which they were written (the bitflags were\n \t\t pushed into FLAGS).  */\n-\t      bp = lto_input_bitpack (ib);\n+\t      bp = streamer_read_bitpack (ib);\n \t      fs->pure_const_state\n \t\t\t= (enum pure_const_state_e) bp_unpack_value (&bp, 2);\n \t      fs->state_previously_known"}, {"sha": "7b45c653675d1731c7d3af2050f1bbbbe297636a", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n #include \"langhooks.h\"\n+#include \"data-streamer.h\"\n #include \"lto-streamer.h\"\n \n static void remove_node_data (struct cgraph_node *node,\n@@ -992,17 +993,17 @@ stream_out_bitmap (struct lto_simple_output_block *ob,\n   bitmap_iterator bi;\n   if (bits == all_module_statics)\n     {\n-      lto_output_sleb128_stream (ob->main_stream, -1);\n+      streamer_write_hwi_stream (ob->main_stream, -1);\n       return;\n     }\n   EXECUTE_IF_AND_IN_BITMAP (bits, ltrans_statics, 0, index, bi)\n     count ++;\n   if (count == ltrans_statics_bitcount)\n     {\n-      lto_output_sleb128_stream (ob->main_stream, -1);\n+      streamer_write_hwi_stream (ob->main_stream, -1);\n       return;\n     }\n-  lto_output_sleb128_stream (ob->main_stream, count);\n+  streamer_write_hwi_stream (ob->main_stream, count);\n   if (!count)\n     return;\n   EXECUTE_IF_AND_IN_BITMAP (bits, ltrans_statics, 0, index, bi)\n@@ -1054,7 +1055,7 @@ ipa_reference_write_optimization_summary (cgraph_node_set set,\n \t\t\t\tset, vset, ltrans_statics))\n \t  count++;\n \n-  lto_output_uleb128_stream (ob->main_stream, count);\n+  streamer_write_uhwi_stream (ob->main_stream, count);\n   if (count)\n     stream_out_bitmap (ob, ltrans_statics, ltrans_statics,\n \t\t       -1);\n@@ -1071,7 +1072,7 @@ ipa_reference_write_optimization_summary (cgraph_node_set set,\n \n \t    info = get_reference_optimization_summary (node);\n \t    node_ref = lto_cgraph_encoder_encode (encoder, node);\n-\t    lto_output_uleb128_stream (ob->main_stream, node_ref);\n+\t    streamer_write_uhwi_stream (ob->main_stream, node_ref);\n \n \t    stream_out_bitmap (ob, info->statics_not_read, ltrans_statics,\n \t\t\t       ltrans_statics_bitcount);\n@@ -1112,16 +1113,16 @@ ipa_reference_read_optimization_summary (void)\n       if (ib)\n \t{\n \t  unsigned int i;\n-\t  unsigned int f_count = lto_input_uleb128 (ib);\n+\t  unsigned int f_count = streamer_read_uhwi (ib);\n \t  int b_count;\n \t  if (!f_count)\n \t    continue;\n-\t  b_count = lto_input_sleb128 (ib);\n+\t  b_count = streamer_read_hwi (ib);\n \t  if (dump_file)\n \t    fprintf (dump_file, \"all module statics:\");\n \t  for (i = 0; i < (unsigned int)b_count; i++)\n \t    {\n-\t      unsigned int var_index = lto_input_uleb128 (ib);\n+\t      unsigned int var_index = streamer_read_uhwi (ib);\n \t      tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n \t\t\t\t\t\t\t     var_index);\n \t      bitmap_set_bit (all_module_statics, DECL_UID (v_decl));\n@@ -1138,7 +1139,7 @@ ipa_reference_read_optimization_summary (void)\n \t      int v_count;\n \t      lto_cgraph_encoder_t encoder;\n \n-\t      index = lto_input_uleb128 (ib);\n+\t      index = streamer_read_uhwi (ib);\n \t      encoder = file_data->cgraph_node_encoder;\n \t      node = lto_cgraph_encoder_deref (encoder, index);\n \t      info = XCNEW (struct ipa_reference_optimization_summary_d);\n@@ -1151,7 +1152,7 @@ ipa_reference_read_optimization_summary (void)\n \t\t\t cgraph_node_name (node), node->uid);\n \n \t      /* Set the statics not read.  */\n-\t      v_count = lto_input_sleb128 (ib);\n+\t      v_count = streamer_read_hwi (ib);\n \t      if (v_count == -1)\n \t\t{\n \t\t  info->statics_not_read = all_module_statics;\n@@ -1161,7 +1162,7 @@ ipa_reference_read_optimization_summary (void)\n \t      else\n \t\tfor (j = 0; j < (unsigned int)v_count; j++)\n \t\t  {\n-\t\t    unsigned int var_index = lto_input_uleb128 (ib);\n+\t\t    unsigned int var_index = streamer_read_uhwi (ib);\n \t\t    tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n \t\t\t\t\t\t\t\t   var_index);\n \t\t    bitmap_set_bit (info->statics_not_read, DECL_UID (v_decl));\n@@ -1174,7 +1175,7 @@ ipa_reference_read_optimization_summary (void)\n \t\tfprintf (dump_file,\n \t\t\t \"\\n  static not written:\");\n \t      /* Set the statics not written.  */\n-\t      v_count = lto_input_sleb128 (ib);\n+\t      v_count = streamer_read_hwi (ib);\n \t      if (v_count == -1)\n \t\t{\n \t\t  info->statics_not_written = all_module_statics;\n@@ -1184,7 +1185,7 @@ ipa_reference_read_optimization_summary (void)\n \t      else\n \t\tfor (j = 0; j < (unsigned int)v_count; j++)\n \t\t  {\n-\t\t    unsigned int var_index = lto_input_uleb128 (ib);\n+\t\t    unsigned int var_index = streamer_read_uhwi (ib);\n \t\t    tree v_decl = lto_file_decl_data_get_var_decl (file_data,\n \t\t\t\t\t\t\t\t   var_index);\n \t\t    bitmap_set_bit (info->statics_not_written, DECL_UID (v_decl));"}, {"sha": "5bcc342d83f12d77b914abe67727e74a36506023", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 107, "deletions": 109, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -267,24 +267,24 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   struct bitpack_d bp;\n \n   if (edge->indirect_unknown_callee)\n-    lto_output_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag,\n-\t\t     LTO_cgraph_indirect_edge);\n+    streamer_write_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag,\n+\t\t\t LTO_cgraph_indirect_edge);\n   else\n-    lto_output_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag,\n-\t\t     LTO_cgraph_edge);\n+    streamer_write_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag,\n+\t\t\t LTO_cgraph_edge);\n \n   ref = lto_cgraph_encoder_lookup (encoder, edge->caller);\n   gcc_assert (ref != LCC_NOT_FOUND);\n-  lto_output_sleb128_stream (ob->main_stream, ref);\n+  streamer_write_hwi_stream (ob->main_stream, ref);\n \n   if (!edge->indirect_unknown_callee)\n     {\n       ref = lto_cgraph_encoder_lookup (encoder, edge->callee);\n       gcc_assert (ref != LCC_NOT_FOUND);\n-      lto_output_sleb128_stream (ob->main_stream, ref);\n+      streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n \n-  lto_output_sleb128_stream (ob->main_stream, edge->count);\n+  streamer_write_hwi_stream (ob->main_stream, edge->count);\n \n   bp = bitpack_create (ob->main_stream);\n   uid = (!gimple_has_body_p (edge->caller->decl)\n@@ -312,7 +312,7 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n \t\t\t     | ECF_LEAF\n \t\t\t     | ECF_NOVOPS)));\n     }\n-  lto_output_bitpack (&bp);\n+  streamer_write_bitpack (&bp);\n }\n \n /* Return if LIST contain references from other partitions.  */\n@@ -423,7 +423,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   else\n     tag = LTO_cgraph_unavail_node;\n \n-  lto_output_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag, tag);\n+  streamer_write_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag,\n+\t\t       tag);\n \n   /* In WPA mode, we only output part of the call-graph.  Also, we\n      fake cgraph node attributes.  There are two cases that we care.\n@@ -459,14 +460,14 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   if (LTO_cgraph_analyzed_node)\n     gcc_assert (clone_of || !node->clone_of);\n   if (!clone_of)\n-    lto_output_sleb128_stream (ob->main_stream, LCC_NOT_FOUND);\n+    streamer_write_hwi_stream (ob->main_stream, LCC_NOT_FOUND);\n   else\n-    lto_output_sleb128_stream (ob->main_stream, ref);\n+    streamer_write_hwi_stream (ob->main_stream, ref);\n \n \n   lto_output_fn_decl_index (ob->decl_state, ob->main_stream, node->decl);\n-  lto_output_sleb128_stream (ob->main_stream, node->count);\n-  lto_output_sleb128_stream (ob->main_stream, node->count_materialization_scale);\n+  streamer_write_hwi_stream (ob->main_stream, node->count);\n+  streamer_write_hwi_stream (ob->main_stream, node->count_materialization_scale);\n \n   if (tag == LTO_cgraph_analyzed_node)\n     {\n@@ -478,7 +479,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       else\n \tref = LCC_NOT_FOUND;\n \n-      lto_output_sleb128_stream (ob->main_stream, ref);\n+      streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n \n   if (node->same_comdat_group && !boundary_p)\n@@ -488,7 +489,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n     }\n   else\n     ref = LCC_NOT_FOUND;\n-  lto_output_sleb128_stream (ob->main_stream, ref);\n+  streamer_write_hwi_stream (ob->main_stream, ref);\n \n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, node->local.local, 1);\n@@ -513,23 +514,21 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->thunk.thunk_p && !boundary_p, 1);\n   bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n \t        LDPR_NUM_KNOWN, node->resolution);\n-  lto_output_bitpack (&bp);\n+  streamer_write_bitpack (&bp);\n \n   if (node->thunk.thunk_p && !boundary_p)\n     {\n-      lto_output_uleb128_stream\n+      streamer_write_uhwi_stream\n \t (ob->main_stream,\n \t  1 + (node->thunk.this_adjusting != 0) * 2\n \t  + (node->thunk.virtual_offset_p != 0) * 4);\n-      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t node->thunk.fixed_offset);\n-      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t node->thunk.virtual_value);\n+      streamer_write_uhwi_stream (ob->main_stream, node->thunk.fixed_offset);\n+      streamer_write_uhwi_stream (ob->main_stream, node->thunk.virtual_value);\n     }\n   if ((node->alias || node->thunk.thunk_p) && !boundary_p)\n     {\n-      lto_output_int_in_range (ob->main_stream, 0, 1,\n-\t\t\t       node->thunk.alias != NULL);\n+      streamer_write_hwi_in_range (ob->main_stream, 0, 1,\n+\t\t\t\t\tnode->thunk.alias != NULL);\n       if (node->thunk.alias != NULL)\n         lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n \t\t\t          node->thunk.alias);\n@@ -573,7 +572,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n \t\t\t\t\t\t\t   set, vset), 1);\n       bp_pack_value (&bp, boundary_p, 1);  /* in_other_partition.  */\n     }\n-  lto_output_bitpack (&bp);\n+  streamer_write_bitpack (&bp);\n   if (node->alias_of)\n     lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->alias_of);\n   if (node->same_comdat_group && !boundary_p)\n@@ -583,9 +582,9 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n     }\n   else\n     ref = LCC_NOT_FOUND;\n-  lto_output_sleb128_stream (ob->main_stream, ref);\n-  lto_output_enum (ob->main_stream, ld_plugin_symbol_resolution,\n-\t\t   LDPR_NUM_KNOWN, node->resolution);\n+  streamer_write_hwi_stream (ob->main_stream, ref);\n+  streamer_write_enum (ob->main_stream, ld_plugin_symbol_resolution,\n+\t\t       LDPR_NUM_KNOWN, node->resolution);\n }\n \n /* Output the varpool NODE to OB. \n@@ -600,19 +599,19 @@ lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, ref->refered_type, 1);\n   bp_pack_value (&bp, ref->use, 2);\n-  lto_output_bitpack (&bp);\n+  streamer_write_bitpack (&bp);\n   if (ref->refered_type == IPA_REF_CGRAPH)\n     {\n       int nref = lto_cgraph_encoder_lookup (encoder, ipa_ref_node (ref));\n       gcc_assert (nref != LCC_NOT_FOUND);\n-      lto_output_sleb128_stream (ob->main_stream, nref);\n+      streamer_write_hwi_stream (ob->main_stream, nref);\n     }\n   else\n     {\n       int nref = lto_varpool_encoder_lookup (varpool_encoder,\n \t\t\t\t             ipa_ref_varpool_node (ref));\n       gcc_assert (nref != LCC_NOT_FOUND);\n-      lto_output_sleb128_stream (ob->main_stream, nref);\n+      streamer_write_hwi_stream (ob->main_stream, nref);\n     }\n }\n \n@@ -627,11 +626,11 @@ output_profile_summary (struct lto_simple_output_block *ob)\n \t GCC profile feedback and they are difficult to merge from multiple\n \t units.  */\n       gcc_assert (profile_info->runs);\n-      lto_output_uleb128_stream (ob->main_stream, profile_info->runs);\n-      lto_output_uleb128_stream (ob->main_stream, profile_info->sum_max);\n+      streamer_write_uhwi_stream (ob->main_stream, profile_info->runs);\n+      streamer_write_uhwi_stream (ob->main_stream, profile_info->sum_max);\n     }\n   else\n-    lto_output_uleb128_stream (ob->main_stream, 0);\n+    streamer_write_uhwi_stream (ob->main_stream, 0);\n }\n \n /* Add NODE into encoder as well as nodes it is cloned from.\n@@ -709,15 +708,15 @@ output_refs (cgraph_node_set set, varpool_node_set vset,\n       count = ipa_ref_list_nreferences (&node->ref_list);\n       if (count)\n \t{\n-\t  lto_output_uleb128_stream (ob->main_stream, count);\n-\t  lto_output_uleb128_stream (ob->main_stream,\n+\t  streamer_write_uhwi_stream (ob->main_stream, count);\n+\t  streamer_write_uhwi_stream (ob->main_stream,\n \t\t\t\t     lto_cgraph_encoder_lookup (encoder, node));\n \t  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n \t    lto_output_ref (ob, ref, encoder, varpool_encoder);\n \t}\n     }\n \n-  lto_output_uleb128_stream (ob->main_stream, 0);\n+  streamer_write_uhwi_stream (ob->main_stream, 0);\n \n   for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n     {\n@@ -726,16 +725,16 @@ output_refs (cgraph_node_set set, varpool_node_set vset,\n       count = ipa_ref_list_nreferences (&node->ref_list);\n       if (count)\n \t{\n-\t  lto_output_uleb128_stream (ob->main_stream, count);\n-\t  lto_output_uleb128_stream (ob->main_stream,\n+\t  streamer_write_uhwi_stream (ob->main_stream, count);\n+\t  streamer_write_uhwi_stream (ob->main_stream,\n \t\t\t\t     lto_varpool_encoder_lookup (varpool_encoder,\n \t\t\t\t\t\t\t\t node));\n \t  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n \t    lto_output_ref (ob, ref, encoder, varpool_encoder);\n \t}\n     }\n \n-  lto_output_uleb128_stream (ob->main_stream, 0);\n+  streamer_write_uhwi_stream (ob->main_stream, 0);\n \n   lto_destroy_simple_output_block (ob);\n }\n@@ -852,7 +851,7 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n       output_outgoing_cgraph_edges (node->indirect_calls, ob, encoder);\n     }\n \n-  lto_output_uleb128_stream (ob->main_stream, 0);\n+  streamer_write_uhwi_stream (ob->main_stream, 0);\n \n   /* Emit toplevel asms.\n      When doing WPA we must output every asm just once.  Since we do not partition asm\n@@ -864,14 +863,14 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n       for (can = cgraph_asm_nodes; can; can = can->next)\n \t{\n \t  int len = TREE_STRING_LENGTH (can->asm_str);\n-\t  lto_output_uleb128_stream (ob->main_stream, len);\n+\t  streamer_write_uhwi_stream (ob->main_stream, len);\n \t  for (i = 0; i < len; ++i)\n-\t    lto_output_1_stream (ob->main_stream,\n-\t\t\t\t TREE_STRING_POINTER (can->asm_str)[i]);\n+\t    streamer_write_char_stream (ob->main_stream,\n+\t\t\t\t\tTREE_STRING_POINTER (can->asm_str)[i]);\n \t}\n     }\n \n-  lto_output_uleb128_stream (ob->main_stream, 0);\n+  streamer_write_uhwi_stream (ob->main_stream, 0);\n \n   lto_destroy_simple_output_block (ob);\n   output_varpool (set, vset);\n@@ -938,7 +937,7 @@ output_varpool (cgraph_node_set set, varpool_node_set vset)\n   lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n   int len = lto_varpool_encoder_size (varpool_encoder), i;\n \n-  lto_output_uleb128_stream (ob->main_stream, len);\n+  streamer_write_uhwi_stream (ob->main_stream, len);\n \n   /* Write out the nodes.  We must first output a node and then its clones,\n      otherwise at a time reading back the node there would be nothing to clone\n@@ -969,9 +968,9 @@ input_node (struct lto_file_decl_data *file_data,\n   int ref = LCC_NOT_FOUND, ref2 = LCC_NOT_FOUND;\n   int clone_ref;\n \n-  clone_ref = lto_input_sleb128 (ib);\n+  clone_ref = streamer_read_hwi (ib);\n \n-  decl_index = lto_input_uleb128 (ib);\n+  decl_index = streamer_read_uhwi (ib);\n   fn_decl = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n \n   if (clone_ref != LCC_NOT_FOUND)\n@@ -982,13 +981,13 @@ input_node (struct lto_file_decl_data *file_data,\n   else\n     node = cgraph_get_create_node (fn_decl);\n \n-  node->count = lto_input_sleb128 (ib);\n-  node->count_materialization_scale = lto_input_sleb128 (ib);\n+  node->count = streamer_read_hwi (ib);\n+  node->count_materialization_scale = streamer_read_hwi (ib);\n \n   if (tag == LTO_cgraph_analyzed_node)\n-    ref = lto_input_sleb128 (ib);\n+    ref = streamer_read_hwi (ib);\n \n-  ref2 = lto_input_sleb128 (ib);\n+  ref2 = streamer_read_hwi (ib);\n \n   /* Make sure that we have not read this node before.  Nodes that\n      have already been read will have their tag stored in the 'aux'\n@@ -998,7 +997,7 @@ input_node (struct lto_file_decl_data *file_data,\n     internal_error (\"bytecode stream: found multiple instances of cgraph \"\n \t\t    \"node %d\", node->uid);\n \n-  bp = lto_input_bitpack (ib);\n+  bp = streamer_read_bitpack (ib);\n   input_overwrite_node (file_data, node, tag, &bp);\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n@@ -1009,9 +1008,9 @@ input_node (struct lto_file_decl_data *file_data,\n \n   if (node->thunk.thunk_p)\n     {\n-      int type = lto_input_uleb128 (ib);\n-      HOST_WIDE_INT fixed_offset = lto_input_uleb128 (ib);\n-      HOST_WIDE_INT virtual_value = lto_input_uleb128 (ib);\n+      int type = streamer_read_uhwi (ib);\n+      HOST_WIDE_INT fixed_offset = streamer_read_uhwi (ib);\n+      HOST_WIDE_INT virtual_value = streamer_read_uhwi (ib);\n \n       node->thunk.fixed_offset = fixed_offset;\n       node->thunk.this_adjusting = (type & 2);\n@@ -1020,9 +1019,9 @@ input_node (struct lto_file_decl_data *file_data,\n     }\n   if (node->thunk.thunk_p || node->alias)\n     {\n-      if (lto_input_int_in_range (ib, \"alias nonzero flag\", 0, 1))\n+      if (streamer_read_hwi_in_range (ib, \"alias nonzero flag\", 0, 1))\n \t{\n-          decl_index = lto_input_uleb128 (ib);\n+          decl_index = streamer_read_uhwi (ib);\n           node->thunk.alias = lto_file_decl_data_get_fn_decl (file_data,\n \t\t\t\t\t\t\t      decl_index);\n \t}\n@@ -1044,12 +1043,12 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   int ref = LCC_NOT_FOUND;\n   bool non_null_aliasof;\n \n-  decl_index = lto_input_uleb128 (ib);\n+  decl_index = streamer_read_uhwi (ib);\n   var_decl = lto_file_decl_data_get_var_decl (file_data, decl_index);\n   node = varpool_node (var_decl);\n   node->lto_file_data = file_data;\n \n-  bp = lto_input_bitpack (ib);\n+  bp = streamer_read_bitpack (ib);\n   node->externally_visible = bp_unpack_value (&bp, 1);\n   node->force_output = bp_unpack_value (&bp, 1);\n   node->finalized = bp_unpack_value (&bp, 1);\n@@ -1067,14 +1066,14 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n     varpool_mark_needed_node (node);\n   if (non_null_aliasof)\n     {\n-      decl_index = lto_input_uleb128 (ib);\n+      decl_index = streamer_read_uhwi (ib);\n       node->alias_of = lto_file_decl_data_get_var_decl (file_data, decl_index);\n     }\n-  ref = lto_input_sleb128 (ib);\n+  ref = streamer_read_hwi (ib);\n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->same_comdat_group = (struct varpool_node *) (intptr_t) ref;\n-  node->resolution = lto_input_enum (ib, ld_plugin_symbol_resolution,\n-\t\t\t\t     LDPR_NUM_KNOWN);\n+  node->resolution = streamer_read_enum (ib, ld_plugin_symbol_resolution,\n+\t\t\t\t\t LDPR_NUM_KNOWN);\n \n   return node;\n }\n@@ -1095,13 +1094,14 @@ input_ref (struct lto_input_block *ib,\n   enum ipa_ref_type type;\n   enum ipa_ref_use use;\n \n-  bp = lto_input_bitpack (ib);\n+  bp = streamer_read_bitpack (ib);\n   type = (enum ipa_ref_type) bp_unpack_value (&bp, 1);\n   use = (enum ipa_ref_use) bp_unpack_value (&bp, 2);\n   if (type == IPA_REF_CGRAPH)\n-    node = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n+    node = VEC_index (cgraph_node_ptr, nodes, streamer_read_hwi (ib));\n   else\n-    varpool_node = VEC_index (varpool_node_ptr, varpool_nodes, lto_input_sleb128 (ib));\n+    varpool_node = VEC_index (varpool_node_ptr, varpool_nodes,\n+\t\t\t      streamer_read_hwi (ib));\n   ipa_record_reference (refering_node, refering_varpool_node,\n \t\t        node, varpool_node, use, NULL);\n }\n@@ -1124,22 +1124,22 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n   struct bitpack_d bp;\n   int ecf_flags = 0;\n \n-  caller = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n+  caller = VEC_index (cgraph_node_ptr, nodes, streamer_read_hwi (ib));\n   if (caller == NULL || caller->decl == NULL_TREE)\n     internal_error (\"bytecode stream: no caller found while reading edge\");\n \n   if (!indirect)\n     {\n-      callee = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n+      callee = VEC_index (cgraph_node_ptr, nodes, streamer_read_hwi (ib));\n       if (callee == NULL || callee->decl == NULL_TREE)\n \tinternal_error (\"bytecode stream: no callee found while reading edge\");\n     }\n   else\n     callee = NULL;\n \n-  count = (gcov_type) lto_input_sleb128 (ib);\n+  count = (gcov_type) streamer_read_hwi (ib);\n \n-  bp = lto_input_bitpack (ib);\n+  bp = streamer_read_bitpack (ib);\n   inline_failed = bp_unpack_enum (&bp, cgraph_inline_failed_enum, CIF_N_REASONS);\n   stmt_id = bp_unpack_var_len_unsigned (&bp);\n   freq = (int) bp_unpack_var_len_unsigned (&bp);\n@@ -1185,7 +1185,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n   unsigned i;\n   unsigned HOST_WIDE_INT len;\n \n-  tag = lto_input_enum (ib, LTO_cgraph_tags, LTO_cgraph_last_tag);\n+  tag = streamer_read_enum (ib, LTO_cgraph_tags, LTO_cgraph_last_tag);\n   while (tag)\n     {\n       if (tag == LTO_cgraph_edge)\n@@ -1201,20 +1201,20 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \t  lto_cgraph_encoder_encode (file_data->cgraph_node_encoder, node);\n \t}\n \n-      tag = lto_input_enum (ib, LTO_cgraph_tags, LTO_cgraph_last_tag);\n+      tag = streamer_read_enum (ib, LTO_cgraph_tags, LTO_cgraph_last_tag);\n     }\n \n   /* Input toplevel asms.  */\n-  len = lto_input_uleb128 (ib);\n+  len = streamer_read_uhwi (ib);\n   while (len)\n     {\n       char *str = (char *)xmalloc (len + 1);\n       for (i = 0; i < len; ++i)\n-\tstr[i] = lto_input_1_unsigned (ib);\n+\tstr[i] = streamer_read_uchar (ib);\n       cgraph_add_asm_node (build_string (len, str));\n       free (str);\n \n-      len = lto_input_uleb128 (ib);\n+      len = streamer_read_uhwi (ib);\n     }\n   /* AUX pointers should be all non-zero for nodes read from the stream.  */\n #ifdef ENABLE_CHECKING\n@@ -1260,7 +1260,7 @@ input_varpool_1 (struct lto_file_decl_data *file_data,\n   int i;\n   struct varpool_node *node;\n \n-  len = lto_input_uleb128 (ib);\n+  len = streamer_read_uhwi (ib);\n   while (len)\n     {\n       VEC_safe_push (varpool_node_ptr, heap, varpool,\n@@ -1302,10 +1302,10 @@ input_refs (struct lto_input_block *ib,\n   while (true)\n     {\n       struct cgraph_node *node;\n-      count = lto_input_uleb128 (ib);\n+      count = streamer_read_uhwi (ib);\n       if (!count)\n \tbreak;\n-      idx = lto_input_uleb128 (ib);\n+      idx = streamer_read_uhwi (ib);\n       node = VEC_index (cgraph_node_ptr, nodes, idx);\n       while (count)\n \t{\n@@ -1316,10 +1316,11 @@ input_refs (struct lto_input_block *ib,\n   while (true)\n     {\n       struct varpool_node *node;\n-      count = lto_input_uleb128 (ib);\n+      count = streamer_read_uhwi (ib);\n       if (!count)\n \tbreak;\n-      node = VEC_index (varpool_node_ptr, varpool, lto_input_uleb128 (ib));\n+      node = VEC_index (varpool_node_ptr, varpool,\n+\t\t\tstreamer_read_uhwi (ib));\n       while (count)\n \t{\n \t  input_ref (ib, NULL, node, nodes, varpool);\n@@ -1336,11 +1337,11 @@ static void\n input_profile_summary (struct lto_input_block *ib,\n \t\t       struct lto_file_decl_data *file_data)\n {\n-  unsigned int runs = lto_input_uleb128 (ib);\n+  unsigned int runs = streamer_read_uhwi (ib);\n   if (runs)\n     {\n       file_data->profile_info.runs = runs;\n-      file_data->profile_info.sum_max = lto_input_uleb128 (ib);\n+      file_data->profile_info.sum_max = streamer_read_uhwi (ib);\n     }\n \n }\n@@ -1528,10 +1529,9 @@ output_edge_opt_summary (struct output_block *ob,\n \t\t\t struct cgraph_edge *edge)\n {\n   if (edge->indirect_info)\n-    lto_output_sleb128_stream (ob->main_stream,\n-\t\t\t       edge->indirect_info->thunk_delta);\n+    streamer_write_hwi (ob, edge->indirect_info->thunk_delta);\n   else\n-    lto_output_sleb128_stream (ob->main_stream, 0);\n+    streamer_write_hwi (ob, 0);\n }\n \n /* Output optimization summary for NODE to OB.  */\n@@ -1550,24 +1550,22 @@ output_node_opt_summary (struct output_block *ob,\n \n   if (node->clone.args_to_skip)\n     {\n-      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t bitmap_count_bits (node->clone.args_to_skip));\n+      streamer_write_uhwi (ob, bitmap_count_bits (node->clone.args_to_skip));\n       EXECUTE_IF_SET_IN_BITMAP (node->clone.args_to_skip, 0, index, bi)\n-\tlto_output_uleb128_stream (ob->main_stream, index);\n+\tstreamer_write_uhwi (ob, index);\n     }\n   else\n-    lto_output_uleb128_stream (ob->main_stream, 0);\n+    streamer_write_uhwi (ob, 0);\n   if (node->clone.combined_args_to_skip)\n     {\n-      lto_output_uleb128_stream (ob->main_stream,\n-\t\t\t\t bitmap_count_bits (node->clone.combined_args_to_skip));\n+      streamer_write_uhwi (ob, bitmap_count_bits (node->clone.combined_args_to_skip));\n       EXECUTE_IF_SET_IN_BITMAP (node->clone.combined_args_to_skip, 0, index, bi)\n-\tlto_output_uleb128_stream (ob->main_stream, index);\n+\tstreamer_write_uhwi (ob, index);\n     }\n   else\n-    lto_output_uleb128_stream (ob->main_stream, 0);\n-  lto_output_uleb128_stream (ob->main_stream,\n-\t\t             VEC_length (ipa_replace_map_p, node->clone.tree_map));\n+    streamer_write_uhwi (ob, 0);\n+  streamer_write_uhwi (ob, VEC_length (ipa_replace_map_p,\n+\t\t\t               node->clone.tree_map));\n   FOR_EACH_VEC_ELT (ipa_replace_map_p, node->clone.tree_map, i, map)\n     {\n       int parm_num;\n@@ -1580,12 +1578,12 @@ output_node_opt_summary (struct output_block *ob,\n       /* At the moment we assume all old trees to be PARM_DECLs, because we have no\n          mechanism to store function local declarations into summaries.  */\n       gcc_assert (parm);\n-      lto_output_uleb128_stream (ob->main_stream, parm_num);\n+      streamer_write_uhwi (ob, parm_num);\n       stream_write_tree (ob, map->new_tree, true);\n       bp = bitpack_create (ob->main_stream);\n       bp_pack_value (&bp, map->replace_p, 1);\n       bp_pack_value (&bp, map->ref_p, 1);\n-      lto_output_bitpack (&bp);\n+      streamer_write_bitpack (&bp);\n     }\n \n   if (cgraph_node_in_set_p (node, set))\n@@ -1616,13 +1614,13 @@ output_cgraph_opt_summary (cgraph_node_set set)\n     if (output_cgraph_opt_summary_p (lto_cgraph_encoder_deref (encoder, i),\n \t\t\t\t     set))\n       count++;\n-  lto_output_uleb128_stream (ob->main_stream, count);\n+  streamer_write_uhwi (ob, count);\n   for (i = 0; i < n_nodes; i++)\n     {\n       node = lto_cgraph_encoder_deref (encoder, i);\n       if (output_cgraph_opt_summary_p (node, set))\n \t{\n-\t  lto_output_uleb128_stream (ob->main_stream, i);\n+\t  streamer_write_uhwi (ob, i);\n \t  output_node_opt_summary (ob, node, set);\n \t}\n     }\n@@ -1637,7 +1635,7 @@ input_edge_opt_summary (struct cgraph_edge *edge,\n \t\t\tstruct lto_input_block *ib_main)\n {\n   HOST_WIDE_INT thunk_delta;\n-  thunk_delta = lto_input_sleb128 (ib_main);\n+  thunk_delta = streamer_read_hwi (ib_main);\n   if (thunk_delta != 0)\n     {\n       gcc_assert (!edge->indirect_info);\n@@ -1659,23 +1657,23 @@ input_node_opt_summary (struct cgraph_node *node,\n   struct bitpack_d bp;\n   struct cgraph_edge *e;\n \n-  count = lto_input_uleb128 (ib_main);\n+  count = streamer_read_uhwi (ib_main);\n   if (count)\n     node->clone.args_to_skip = BITMAP_GGC_ALLOC ();\n   for (i = 0; i < count; i++)\n     {\n-      bit = lto_input_uleb128 (ib_main);\n+      bit = streamer_read_uhwi (ib_main);\n       bitmap_set_bit (node->clone.args_to_skip, bit);\n     }\n-  count = lto_input_uleb128 (ib_main);\n+  count = streamer_read_uhwi (ib_main);\n   if (count)\n     node->clone.combined_args_to_skip = BITMAP_GGC_ALLOC ();\n   for (i = 0; i < count; i++)\n     {\n-      bit = lto_input_uleb128 (ib_main);\n+      bit = streamer_read_uhwi (ib_main);\n       bitmap_set_bit (node->clone.combined_args_to_skip, bit);\n     }\n-  count = lto_input_uleb128 (ib_main);\n+  count = streamer_read_uhwi (ib_main);\n   for (i = 0; i < count; i++)\n     {\n       int parm_num;\n@@ -1686,10 +1684,10 @@ input_node_opt_summary (struct cgraph_node *node,\n       for (parm_num = 0, parm = DECL_ARGUMENTS (node->decl); parm_num;\n \t   parm = DECL_CHAIN (parm))\n \tparm_num --;\n-      map->parm_num = lto_input_uleb128 (ib_main);\n+      map->parm_num = streamer_read_uhwi (ib_main);\n       map->old_tree = NULL;\n       map->new_tree = stream_read_tree (ib_main, data_in);\n-      bp = lto_input_bitpack (ib_main);\n+      bp = streamer_read_bitpack (ib_main);\n       map->replace_p = bp_unpack_value (&bp, 1);\n       map->ref_p = bp_unpack_value (&bp, 1);\n     }\n@@ -1722,11 +1720,11 @@ input_cgraph_opt_section (struct lto_file_decl_data *file_data,\n   data_in =\n     lto_data_in_create (file_data, (const char *) data + string_offset,\n \t\t\theader->string_size, NULL);\n-  count = lto_input_uleb128 (&ib_main);\n+  count = streamer_read_uhwi (&ib_main);\n \n   for (i = 0; i < count; i++)\n     {\n-      int ref = lto_input_uleb128 (&ib_main);\n+      int ref = streamer_read_uhwi (&ib_main);\n       input_node_opt_summary (VEC_index (cgraph_node_ptr, nodes, ref),\n \t\t\t      &ib_main, data_in);\n     }"}, {"sha": "fe3cc54c7f96b2cd2667674e971de098aac1e220", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pointer-set.h\"\n #include \"bitmap.h\"\n #include \"langhooks.h\"\n+#include \"data-streamer.h\"\n #include \"lto-streamer.h\"\n #include \"lto-compress.h\"\n \n@@ -303,7 +304,7 @@ lto_output_decl_index (struct lto_output_stream *obs,\n     }\n \n   if (obs)\n-    lto_output_uleb128_stream (obs, index);\n+    streamer_write_uhwi_stream (obs, index);\n   *this_index = index;\n   return new_entry_p;\n }"}, {"sha": "331eba8bd30c81db926c9d375a6324a248bc5efa", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 67, "deletions": 66, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -86,7 +86,7 @@ lto_input_data_block (struct lto_input_block *ib, void *addr, size_t length)\n   unsigned char *const buffer = (unsigned char *const) addr;\n \n   for (i = 0; i < length; i++)\n-    buffer[i] = lto_input_1_unsigned (ib);\n+    buffer[i] = streamer_read_uchar (ib);\n }\n \n \n@@ -186,7 +186,7 @@ lto_input_location (struct lto_input_block *ib, struct data_in *data_in)\n {\n   struct bitpack_d bp;\n \n-  bp = lto_input_bitpack (ib);\n+  bp = streamer_read_bitpack (ib);\n   return lto_input_location_bitpack (data_in, &bp);\n }\n \n@@ -210,32 +210,32 @@ lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in,\n   switch (tag)\n     {\n     case LTO_type_ref:\n-      ix_u = lto_input_uleb128 (ib);\n+      ix_u = streamer_read_uhwi (ib);\n       result = lto_file_decl_data_get_type (data_in->file_data, ix_u);\n       break;\n \n     case LTO_ssa_name_ref:\n-      ix_u = lto_input_uleb128 (ib);\n+      ix_u = streamer_read_uhwi (ib);\n       result = VEC_index (tree, SSANAMES (fn), ix_u);\n       break;\n \n     case LTO_field_decl_ref:\n-      ix_u = lto_input_uleb128 (ib);\n+      ix_u = streamer_read_uhwi (ib);\n       result = lto_file_decl_data_get_field_decl (data_in->file_data, ix_u);\n       break;\n \n     case LTO_function_decl_ref:\n-      ix_u = lto_input_uleb128 (ib);\n+      ix_u = streamer_read_uhwi (ib);\n       result = lto_file_decl_data_get_fn_decl (data_in->file_data, ix_u);\n       break;\n \n     case LTO_type_decl_ref:\n-      ix_u = lto_input_uleb128 (ib);\n+      ix_u = streamer_read_uhwi (ib);\n       result = lto_file_decl_data_get_type_decl (data_in->file_data, ix_u);\n       break;\n \n     case LTO_namespace_decl_ref:\n-      ix_u = lto_input_uleb128 (ib);\n+      ix_u = streamer_read_uhwi (ib);\n       result = lto_file_decl_data_get_namespace_decl (data_in->file_data, ix_u);\n       break;\n \n@@ -245,7 +245,7 @@ lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in,\n     case LTO_imported_decl_ref:\n     case LTO_label_decl_ref:\n     case LTO_translation_unit_decl_ref:\n-      ix_u = lto_input_uleb128 (ib);\n+      ix_u = streamer_read_uhwi (ib);\n       result = lto_file_decl_data_get_var_decl (data_in->file_data, ix_u);\n       break;\n \n@@ -270,7 +270,7 @@ lto_input_eh_catch_list (struct lto_input_block *ib, struct data_in *data_in,\n   enum LTO_tags tag;\n \n   *last_p = first = NULL;\n-  tag = input_record_start (ib);\n+  tag = streamer_read_record_start (ib);\n   while (tag)\n     {\n       tree list;\n@@ -298,7 +298,7 @@ lto_input_eh_catch_list (struct lto_input_block *ib, struct data_in *data_in,\n       if (first == NULL)\n \tfirst = n;\n \n-      tag = input_record_start (ib);\n+      tag = streamer_read_record_start (ib);\n     }\n \n   return first;\n@@ -315,20 +315,20 @@ input_eh_region (struct lto_input_block *ib, struct data_in *data_in, int ix)\n   eh_region r;\n \n   /* Read the region header.  */\n-  tag = input_record_start (ib);\n+  tag = streamer_read_record_start (ib);\n   if (tag == LTO_null)\n     return NULL;\n \n   r = ggc_alloc_cleared_eh_region_d ();\n-  r->index = lto_input_sleb128 (ib);\n+  r->index = streamer_read_hwi (ib);\n \n   gcc_assert (r->index == ix);\n \n   /* Read all the region pointers as region numbers.  We'll fix up\n      the pointers once the whole array has been read.  */\n-  r->outer = (eh_region) (intptr_t) lto_input_sleb128 (ib);\n-  r->inner = (eh_region) (intptr_t) lto_input_sleb128 (ib);\n-  r->next_peer = (eh_region) (intptr_t) lto_input_sleb128 (ib);\n+  r->outer = (eh_region) (intptr_t) streamer_read_hwi (ib);\n+  r->inner = (eh_region) (intptr_t) streamer_read_hwi (ib);\n+  r->next_peer = (eh_region) (intptr_t) streamer_read_hwi (ib);\n \n   switch (tag)\n     {\n@@ -353,7 +353,7 @@ input_eh_region (struct lto_input_block *ib, struct data_in *data_in, int ix)\n \t  r->type = ERT_ALLOWED_EXCEPTIONS;\n \t  r->u.allowed.type_list = stream_read_tree (ib, data_in);\n \t  r->u.allowed.label = stream_read_tree (ib, data_in);\n-\t  r->u.allowed.filter = lto_input_uleb128 (ib);\n+\t  r->u.allowed.filter = streamer_read_uhwi (ib);\n \n \t  for (l = r->u.allowed.type_list; l ; l = TREE_CHAIN (l))\n \t    add_type_for_runtime (TREE_VALUE (l));\n@@ -370,7 +370,7 @@ input_eh_region (struct lto_input_block *ib, struct data_in *data_in, int ix)\n \tgcc_unreachable ();\n     }\n \n-  r->landing_pads = (eh_landing_pad) (intptr_t) lto_input_sleb128 (ib);\n+  r->landing_pads = (eh_landing_pad) (intptr_t) streamer_read_hwi (ib);\n \n   return r;\n }\n@@ -386,17 +386,17 @@ input_eh_lp (struct lto_input_block *ib, struct data_in *data_in, int ix)\n   eh_landing_pad lp;\n \n   /* Read the landing pad header.  */\n-  tag = input_record_start (ib);\n+  tag = streamer_read_record_start (ib);\n   if (tag == LTO_null)\n     return NULL;\n \n   lto_tag_check_range (tag, LTO_eh_landing_pad, LTO_eh_landing_pad);\n \n   lp = ggc_alloc_cleared_eh_landing_pad_d ();\n-  lp->index = lto_input_sleb128 (ib);\n+  lp->index = streamer_read_hwi (ib);\n   gcc_assert (lp->index == ix);\n-  lp->next_lp = (eh_landing_pad) (intptr_t) lto_input_sleb128 (ib);\n-  lp->region = (eh_region) (intptr_t) lto_input_sleb128 (ib);\n+  lp->next_lp = (eh_landing_pad) (intptr_t) streamer_read_hwi (ib);\n+  lp->region = (eh_region) (intptr_t) streamer_read_hwi (ib);\n   lp->post_landing_pad = stream_read_tree (ib, data_in);\n \n   return lp;\n@@ -492,7 +492,7 @@ input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n   HOST_WIDE_INT i, root_region, len;\n   enum LTO_tags tag;\n \n-  tag = input_record_start (ib);\n+  tag = streamer_read_record_start (ib);\n   if (tag == LTO_null)\n     return;\n \n@@ -505,11 +505,11 @@ input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n \n   gcc_assert (fn->eh);\n \n-  root_region = lto_input_sleb128 (ib);\n+  root_region = streamer_read_hwi (ib);\n   gcc_assert (root_region == (int) root_region);\n \n   /* Read the EH region array.  */\n-  len = lto_input_sleb128 (ib);\n+  len = streamer_read_hwi (ib);\n   gcc_assert (len == (int) len);\n   if (len > 0)\n     {\n@@ -522,7 +522,7 @@ input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n     }\n \n   /* Read the landing pads.  */\n-  len = lto_input_sleb128 (ib);\n+  len = streamer_read_hwi (ib);\n   gcc_assert (len == (int) len);\n   if (len > 0)\n     {\n@@ -535,7 +535,7 @@ input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n     }\n \n   /* Read the runtime type data.  */\n-  len = lto_input_sleb128 (ib);\n+  len = streamer_read_hwi (ib);\n   gcc_assert (len == (int) len);\n   if (len > 0)\n     {\n@@ -548,7 +548,7 @@ input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n     }\n \n   /* Read the table of action chains.  */\n-  len = lto_input_sleb128 (ib);\n+  len = streamer_read_hwi (ib);\n   gcc_assert (len == (int) len);\n   if (len > 0)\n     {\n@@ -566,7 +566,7 @@ input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n \t  VEC_safe_grow (uchar, gc, fn->eh->ehspec_data.other, len);\n \t  for (i = 0; i < len; i++)\n \t    {\n-\t      uchar c = lto_input_1_unsigned (ib);\n+\t      uchar c = streamer_read_uchar (ib);\n \t      VEC_replace (uchar, fn->eh->ehspec_data.other, i, c);\n \t    }\n \t}\n@@ -576,7 +576,7 @@ input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n      pointers.  */\n   fixup_eh_region_pointers (fn, root_region);\n \n-  tag = input_record_start (ib);\n+  tag = streamer_read_record_start (ib);\n   lto_tag_check_range (tag, LTO_null, LTO_null);\n }\n \n@@ -611,9 +611,10 @@ input_cfg (struct lto_input_block *ib, struct function *fn,\n   init_empty_tree_cfg_for_function (fn);\n   init_ssa_operands ();\n \n-  profile_status_for_function (fn) = lto_input_enum (ib, profile_status_d, PROFILE_LAST);\n+  profile_status_for_function (fn) = streamer_read_enum (ib, profile_status_d,\n+\t\t\t\t\t\t\t PROFILE_LAST);\n \n-  bb_count = lto_input_uleb128 (ib);\n+  bb_count = streamer_read_uhwi (ib);\n \n   last_basic_block_for_function (fn) = bb_count;\n   if (bb_count > VEC_length (basic_block, basic_block_info_for_function (fn)))\n@@ -624,7 +625,7 @@ input_cfg (struct lto_input_block *ib, struct function *fn,\n     VEC_safe_grow_cleared (basic_block, gc,\n \t\t\t   label_to_block_map_for_function (fn), bb_count);\n \n-  index = lto_input_sleb128 (ib);\n+  index = streamer_read_hwi (ib);\n   while (index != -1)\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FUNCTION (fn, index);\n@@ -633,7 +634,7 @@ input_cfg (struct lto_input_block *ib, struct function *fn,\n       if (bb == NULL)\n \tbb = make_new_block (fn, index);\n \n-      edge_count = lto_input_uleb128 (ib);\n+      edge_count = streamer_read_uhwi (ib);\n \n       /* Connect up the CFG.  */\n       for (i = 0; i < edge_count; i++)\n@@ -645,11 +646,11 @@ input_cfg (struct lto_input_block *ib, struct function *fn,\n \t  gcov_type count;\n \t  edge e;\n \n-\t  dest_index = lto_input_uleb128 (ib);\n-\t  probability = (int) lto_input_sleb128 (ib);\n-\t  count = ((gcov_type) lto_input_sleb128 (ib) * count_materialization_scale\n+\t  dest_index = streamer_read_uhwi (ib);\n+\t  probability = (int) streamer_read_hwi (ib);\n+\t  count = ((gcov_type) streamer_read_hwi (ib) * count_materialization_scale\n \t\t   + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n-\t  edge_flags = lto_input_uleb128 (ib);\n+\t  edge_flags = streamer_read_uhwi (ib);\n \n \t  dest = BASIC_BLOCK_FOR_FUNCTION (fn, dest_index);\n \n@@ -661,18 +662,18 @@ input_cfg (struct lto_input_block *ib, struct function *fn,\n \t  e->count = count;\n \t}\n \n-      index = lto_input_sleb128 (ib);\n+      index = streamer_read_hwi (ib);\n     }\n \n   p_bb = ENTRY_BLOCK_PTR_FOR_FUNCTION(fn);\n-  index = lto_input_sleb128 (ib);\n+  index = streamer_read_hwi (ib);\n   while (index != -1)\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FUNCTION (fn, index);\n       bb->prev_bb = p_bb;\n       p_bb->next_bb = bb;\n       p_bb = bb;\n-      index = lto_input_sleb128 (ib);\n+      index = streamer_read_hwi (ib);\n     }\n }\n \n@@ -686,10 +687,10 @@ input_ssa_names (struct lto_input_block *ib, struct data_in *data_in,\n {\n   unsigned int i, size;\n \n-  size = lto_input_uleb128 (ib);\n+  size = streamer_read_uhwi (ib);\n   init_ssanames (fn, size);\n \n-  i = lto_input_uleb128 (ib);\n+  i = streamer_read_uhwi (ib);\n   while (i)\n     {\n       tree ssa_name, name;\n@@ -699,14 +700,14 @@ input_ssa_names (struct lto_input_block *ib, struct data_in *data_in,\n       while (VEC_length (tree, SSANAMES (fn)) < i)\n \tVEC_quick_push (tree, SSANAMES (fn), NULL_TREE);\n \n-      is_default_def = (lto_input_1_unsigned (ib) != 0);\n+      is_default_def = (streamer_read_uchar (ib) != 0);\n       name = stream_read_tree (ib, data_in);\n       ssa_name = make_ssa_name_fn (fn, name, gimple_build_nop ());\n \n       if (is_default_def)\n \tset_default_def (SSA_NAME_VAR (ssa_name), ssa_name);\n \n-      i = lto_input_uleb128 (ib);\n+      i = streamer_read_uhwi (ib);\n     }\n }\n \n@@ -769,14 +770,14 @@ input_function (tree fn_decl, struct data_in *data_in,\n   int len;\n \n   fn = DECL_STRUCT_FUNCTION (fn_decl);\n-  tag = input_record_start (ib);\n+  tag = streamer_read_record_start (ib);\n   clear_line_info (data_in);\n \n   gimple_register_cfg_hooks ();\n   lto_tag_check (tag, LTO_function);\n \n   /* Read all the attributes for FN.  */\n-  bp = lto_input_bitpack (ib);\n+  bp = streamer_read_bitpack (ib);\n   fn->is_thunk = bp_unpack_value (&bp, 1);\n   fn->has_local_explicit_reg_vars = bp_unpack_value (&bp, 1);\n   fn->after_tree_profile = bp_unpack_value (&bp, 1);\n@@ -797,14 +798,14 @@ input_function (tree fn_decl, struct data_in *data_in,\n   fn->function_end_locus = lto_input_location (ib, data_in);\n \n   /* Input the current IL state of the function.  */\n-  fn->curr_properties = lto_input_uleb128 (ib);\n+  fn->curr_properties = streamer_read_uhwi (ib);\n \n   /* Read the static chain and non-local goto save area.  */\n   fn->static_chain_decl = stream_read_tree (ib, data_in);\n   fn->nonlocal_goto_save_area = stream_read_tree (ib, data_in);\n \n   /* Read all the local symbols.  */\n-  len = lto_input_sleb128 (ib);\n+  len = streamer_read_hwi (ib);\n   if (len > 0)\n     {\n       int i;\n@@ -825,10 +826,10 @@ input_function (tree fn_decl, struct data_in *data_in,\n     {\n       unsigned ix;\n       bool res;\n-      res = lto_streamer_cache_lookup (data_in->reader_cache, oarg, &ix);\n+      res = streamer_tree_cache_lookup (data_in->reader_cache, oarg, &ix);\n       gcc_assert (res);\n       /* Replace the argument in the streamer cache.  */\n-      lto_streamer_cache_insert_at (data_in->reader_cache, narg, ix);\n+      streamer_tree_cache_insert_at (data_in->reader_cache, narg, ix);\n     }\n   gcc_assert (!oarg && !narg);\n \n@@ -845,12 +846,12 @@ input_function (tree fn_decl, struct data_in *data_in,\n   node = cgraph_get_create_node (fn_decl);\n \n   /* Read all the basic blocks.  */\n-  tag = input_record_start (ib);\n+  tag = streamer_read_record_start (ib);\n   while (tag)\n     {\n       input_bb (ib, tag, data_in, fn,\n \t\tnode->count_materialization_scale);\n-      tag = input_record_start (ib);\n+      tag = streamer_read_record_start (ib);\n     }\n \n   /* Fix up the call statements that are mentioned in the callgraph\n@@ -1052,20 +1053,20 @@ lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n \t       enum LTO_tags tag)\n {\n   /* Instantiate a new tree node.  */\n-  tree result = lto_materialize_tree (ib, data_in, tag);\n+  tree result = streamer_alloc_tree (ib, data_in, tag);\n \n   /* Enter RESULT in the reader cache.  This will make RESULT\n      available so that circular references in the rest of the tree\n      structure can be resolved in subsequent calls to stream_read_tree.  */\n-  lto_streamer_cache_append (data_in->reader_cache, result);\n+  streamer_tree_cache_append (data_in->reader_cache, result);\n \n   /* Read all the bitfield values in RESULT.  Note that for LTO, we\n      only write language-independent bitfields, so no more unpacking is\n      needed.  */\n-  tree_read_bitfields (ib, result);\n+  streamer_read_tree_bitfields (ib, result);\n \n   /* Read all the pointer fields in RESULT.  */\n-  lto_input_tree_pointers (ib, data_in, result);\n+  streamer_read_tree_body (ib, data_in, result);\n \n   /* Read any LTO-specific data not read by the tree streamer.  */\n   if (DECL_P (result)\n@@ -1075,13 +1076,13 @@ lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n \n   /* We should never try to instantiate an MD or NORMAL builtin here.  */\n   if (TREE_CODE (result) == FUNCTION_DECL)\n-    gcc_assert (!lto_stream_as_builtin_p (result));\n+    gcc_assert (!streamer_handle_as_builtin_p (result));\n \n-  /* end_marker = */ lto_input_1_unsigned (ib);\n+  /* end_marker = */ streamer_read_uchar (ib);\n \n #ifdef LTO_STREAMER_DEBUG\n   /* Remove the mapping to RESULT's original address set by\n-     lto_materialize_tree.  */\n+     streamer_alloc_tree.  */\n   lto_orig_address_remove (result);\n #endif\n \n@@ -1099,7 +1100,7 @@ lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n   enum LTO_tags tag;\n   tree result;\n \n-  tag = input_record_start (ib);\n+  tag = streamer_read_record_start (ib);\n   gcc_assert ((unsigned) tag < (unsigned) LTO_NUM_TAGS);\n \n   if (tag == LTO_null)\n@@ -1115,19 +1116,19 @@ lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n     {\n       /* If TAG is a reference to a previously read tree, look it up in\n \t the reader cache.  */\n-      result = lto_get_pickled_tree (ib, data_in);\n+      result = streamer_get_pickled_tree (ib, data_in);\n     }\n   else if (tag == LTO_builtin_decl)\n     {\n       /* If we are going to read a built-in function, all we need is\n \t the code and class.  */\n-      result = lto_get_builtin_tree (ib, data_in);\n+      result = streamer_get_builtin_tree (ib, data_in);\n     }\n   else if (tag == lto_tree_code_to_tag (INTEGER_CST))\n     {\n       /* For integer constants we only need the type and its hi/low\n \t words.  */\n-      result = lto_input_integer_cst (ib, data_in);\n+      result = streamer_read_integer_cst (ib, data_in);\n     }\n   else\n     {\n@@ -1164,7 +1165,7 @@ lto_data_in_create (struct lto_file_decl_data *file_data, const char *strings,\n   data_in->strings = strings;\n   data_in->strings_len = len;\n   data_in->globals_resolution = resolutions;\n-  data_in->reader_cache = lto_streamer_cache_create ();\n+  data_in->reader_cache = streamer_tree_cache_create ();\n \n   return data_in;\n }\n@@ -1176,7 +1177,7 @@ void\n lto_data_in_delete (struct data_in *data_in)\n {\n   VEC_free (ld_plugin_symbol_resolution_t, heap, data_in->globals_resolution);\n-  lto_streamer_cache_delete (data_in->reader_cache);\n+  streamer_tree_cache_delete (data_in->reader_cache);\n   free (data_in->labels);\n   free (data_in);\n }"}, {"sha": "a8d60073c773cac57b2f3455d121e92df6b2acb9", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 98, "deletions": 95, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -70,7 +70,7 @@ create_output_block (enum lto_section_type section_type)\n   ob->decl_state = lto_get_out_decl_state ();\n   ob->main_stream = XCNEW (struct lto_output_stream);\n   ob->string_stream = XCNEW (struct lto_output_stream);\n-  ob->writer_cache = lto_streamer_cache_create ();\n+  ob->writer_cache = streamer_tree_cache_create ();\n \n   if (section_type == LTO_section_function_body)\n     ob->cfg_stream = XCNEW (struct lto_output_stream);\n@@ -99,7 +99,7 @@ destroy_output_block (struct output_block *ob)\n   if (section_type == LTO_section_function_body)\n     free (ob->cfg_stream);\n \n-  lto_streamer_cache_delete (ob->writer_cache);\n+  streamer_tree_cache_delete (ob->writer_cache);\n   obstack_free (&ob->obstack, NULL);\n \n   free (ob);\n@@ -111,7 +111,7 @@ destroy_output_block (struct output_block *ob)\n static void\n output_type_ref (struct output_block *ob, tree node)\n {\n-  output_record_start (ob, LTO_type_ref);\n+  streamer_write_record_start (ob, LTO_type_ref);\n   lto_output_type_ref_index (ob->decl_state, ob->main_stream, node);\n }\n \n@@ -153,10 +153,10 @@ lto_output_location_bitpack (struct bitpack_d *bp,\n \n   bp_pack_value (bp, ob->current_file != xloc.file, 1);\n   if (ob->current_file != xloc.file)\n-    bp_pack_var_len_unsigned (bp, lto_string_index (ob,\n-\t\t\t\t\t            xloc.file,\n-\t\t\t\t\t\t    strlen (xloc.file) + 1,\n-\t\t\t\t\t\t    true));\n+    bp_pack_var_len_unsigned (bp,\n+\t                      streamer_string_index (ob, xloc.file,\n+\t\t\t\t\t\t     strlen (xloc.file) + 1,\n+\t\t\t\t\t\t     true));\n   ob->current_file = xloc.file;\n \n   bp_pack_value (bp, ob->current_line != xloc.line, 1);\n@@ -180,7 +180,7 @@ lto_output_location (struct output_block *ob, location_t loc)\n {\n   struct bitpack_d bp = bitpack_create (ob->main_stream);\n   lto_output_location_bitpack (&bp, ob, loc);\n-  lto_output_bitpack (&bp);\n+  streamer_write_bitpack (&bp);\n }\n \n \n@@ -203,60 +203,60 @@ lto_output_tree_ref (struct output_block *ob, tree expr)\n   switch (code)\n     {\n     case SSA_NAME:\n-      output_record_start (ob, LTO_ssa_name_ref);\n-      output_uleb128 (ob, SSA_NAME_VERSION (expr));\n+      streamer_write_record_start (ob, LTO_ssa_name_ref);\n+      streamer_write_uhwi (ob, SSA_NAME_VERSION (expr));\n       break;\n \n     case FIELD_DECL:\n-      output_record_start (ob, LTO_field_decl_ref);\n+      streamer_write_record_start (ob, LTO_field_decl_ref);\n       lto_output_field_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n \n     case FUNCTION_DECL:\n-      output_record_start (ob, LTO_function_decl_ref);\n+      streamer_write_record_start (ob, LTO_function_decl_ref);\n       lto_output_fn_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n \n     case VAR_DECL:\n     case DEBUG_EXPR_DECL:\n       gcc_assert (decl_function_context (expr) == NULL || TREE_STATIC (expr));\n-      output_record_start (ob, LTO_global_decl_ref);\n+      streamer_write_record_start (ob, LTO_global_decl_ref);\n       lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n \n     case CONST_DECL:\n-      output_record_start (ob, LTO_const_decl_ref);\n+      streamer_write_record_start (ob, LTO_const_decl_ref);\n       lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n \n     case IMPORTED_DECL:\n       gcc_assert (decl_function_context (expr) == NULL);\n-      output_record_start (ob, LTO_imported_decl_ref);\n+      streamer_write_record_start (ob, LTO_imported_decl_ref);\n       lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n \n     case TYPE_DECL:\n-      output_record_start (ob, LTO_type_decl_ref);\n+      streamer_write_record_start (ob, LTO_type_decl_ref);\n       lto_output_type_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n \n     case NAMESPACE_DECL:\n-      output_record_start (ob, LTO_namespace_decl_ref);\n+      streamer_write_record_start (ob, LTO_namespace_decl_ref);\n       lto_output_namespace_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n \n     case LABEL_DECL:\n-      output_record_start (ob, LTO_label_decl_ref);\n+      streamer_write_record_start (ob, LTO_label_decl_ref);\n       lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n \n     case RESULT_DECL:\n-      output_record_start (ob, LTO_result_decl_ref);\n+      streamer_write_record_start (ob, LTO_result_decl_ref);\n       lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n \n     case TRANSLATION_UNIT_DECL:\n-      output_record_start (ob, LTO_translation_unit_decl_ref);\n+      streamer_write_record_start (ob, LTO_translation_unit_decl_ref);\n       lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n \n@@ -311,16 +311,16 @@ lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n \n   /* Write the header, containing everything needed to materialize\n      EXPR on the reading side.  */\n-  lto_output_tree_header (ob, expr);\n+  streamer_write_tree_header (ob, expr);\n \n   /* Pack all the non-pointer fields in EXPR into a bitpack and write\n      the resulting bitpack.  */\n   bp = bitpack_create (ob->main_stream);\n-  pack_value_fields (&bp, expr);\n-  lto_output_bitpack (&bp);\n+  streamer_pack_tree_bitfields (&bp, expr);\n+  streamer_write_bitpack (&bp);\n \n   /* Write all the pointer fields in EXPR.  */\n-  lto_output_tree_pointers (ob, expr, ref_p);\n+  streamer_write_tree_body (ob, expr, ref_p);\n \n   /* Write any LTO-specific data to OB.  */\n   if (DECL_P (expr)\n@@ -349,7 +349,7 @@ lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n     }\n \n   /* Mark the end of EXPR.  */\n-  output_zero (ob);\n+  streamer_write_zero (ob);\n }\n \n \n@@ -365,7 +365,7 @@ lto_output_tree (struct output_block *ob, tree expr, bool ref_p)\n \n   if (expr == NULL_TREE)\n     {\n-      output_record_start (ob, LTO_null);\n+      streamer_write_record_start (ob, LTO_null);\n       return;\n     }\n \n@@ -379,29 +379,29 @@ lto_output_tree (struct output_block *ob, tree expr, bool ref_p)\n      to be materialized by the reader (to implement TYPE_CACHED_VALUES).  */\n   if (TREE_CODE (expr) == INTEGER_CST)\n     {\n-      lto_output_integer_cst (ob, expr, ref_p);\n+      streamer_write_integer_cst (ob, expr, ref_p);\n       return;\n     }\n \n-  existed_p = lto_streamer_cache_insert (ob->writer_cache, expr, &ix);\n+  existed_p = streamer_tree_cache_insert (ob->writer_cache, expr, &ix);\n   if (existed_p)\n     {\n       /* If a node has already been streamed out, make sure that\n \t we don't write it more than once.  Otherwise, the reader\n \t will instantiate two different nodes for the same object.  */\n-      output_record_start (ob, LTO_tree_pickle_reference);\n-      output_uleb128 (ob, ix);\n-      lto_output_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS,\n-\t\t       lto_tree_code_to_tag (TREE_CODE (expr)));\n+      streamer_write_record_start (ob, LTO_tree_pickle_reference);\n+      streamer_write_uhwi (ob, ix);\n+      streamer_write_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS,\n+\t\t\t   lto_tree_code_to_tag (TREE_CODE (expr)));\n     }\n-  else if (lto_stream_as_builtin_p (expr))\n+  else if (streamer_handle_as_builtin_p (expr))\n     {\n       /* MD and NORMAL builtins do not need to be written out\n \t completely as they are always instantiated by the\n \t compiler on startup.  The only builtins that need to\n \t be written out are BUILT_IN_FRONTEND.  For all other\n \t builtins, we simply write the class and code.  */\n-      lto_output_builtin_tree (ob, expr);\n+      streamer_write_builtin (ob, expr);\n     }\n   else\n     {\n@@ -421,13 +421,13 @@ output_eh_try_list (struct output_block *ob, eh_catch first)\n \n   for (n = first; n; n = n->next_catch)\n     {\n-      output_record_start (ob, LTO_eh_catch);\n+      streamer_write_record_start (ob, LTO_eh_catch);\n       stream_write_tree (ob, n->type_list, true);\n       stream_write_tree (ob, n->filter_list, true);\n       stream_write_tree (ob, n->label, true);\n     }\n \n-  output_record_start (ob, LTO_null);\n+  streamer_write_record_start (ob, LTO_null);\n }\n \n \n@@ -442,7 +442,7 @@ output_eh_region (struct output_block *ob, eh_region r)\n \n   if (r == NULL)\n     {\n-      output_record_start (ob, LTO_null);\n+      streamer_write_record_start (ob, LTO_null);\n       return;\n     }\n \n@@ -457,23 +457,23 @@ output_eh_region (struct output_block *ob, eh_region r)\n   else\n     gcc_unreachable ();\n \n-  output_record_start (ob, tag);\n-  output_sleb128 (ob, r->index);\n+  streamer_write_record_start (ob, tag);\n+  streamer_write_hwi (ob, r->index);\n \n   if (r->outer)\n-    output_sleb128 (ob, r->outer->index);\n+    streamer_write_hwi (ob, r->outer->index);\n   else\n-    output_zero (ob);\n+    streamer_write_zero (ob);\n \n   if (r->inner)\n-    output_sleb128 (ob, r->inner->index);\n+    streamer_write_hwi (ob, r->inner->index);\n   else\n-    output_zero (ob);\n+    streamer_write_zero (ob);\n \n   if (r->next_peer)\n-    output_sleb128 (ob, r->next_peer->index);\n+    streamer_write_hwi (ob, r->next_peer->index);\n   else\n-    output_zero (ob);\n+    streamer_write_zero (ob);\n \n   if (r->type == ERT_TRY)\n     {\n@@ -483,7 +483,7 @@ output_eh_region (struct output_block *ob, eh_region r)\n     {\n       stream_write_tree (ob, r->u.allowed.type_list, true);\n       stream_write_tree (ob, r->u.allowed.label, true);\n-      output_uleb128 (ob, r->u.allowed.filter);\n+      streamer_write_uhwi (ob, r->u.allowed.filter);\n     }\n   else if (r->type == ERT_MUST_NOT_THROW)\n     {\n@@ -492,9 +492,9 @@ output_eh_region (struct output_block *ob, eh_region r)\n     }\n \n   if (r->landing_pads)\n-    output_sleb128 (ob, r->landing_pads->index);\n+    streamer_write_hwi (ob, r->landing_pads->index);\n   else\n-    output_zero (ob);\n+    streamer_write_zero (ob);\n }\n \n \n@@ -505,21 +505,21 @@ output_eh_lp (struct output_block *ob, eh_landing_pad lp)\n {\n   if (lp == NULL)\n     {\n-      output_record_start (ob, LTO_null);\n+      streamer_write_record_start (ob, LTO_null);\n       return;\n     }\n \n-  output_record_start (ob, LTO_eh_landing_pad);\n-  output_sleb128 (ob, lp->index);\n+  streamer_write_record_start (ob, LTO_eh_landing_pad);\n+  streamer_write_hwi (ob, lp->index);\n   if (lp->next_lp)\n-    output_sleb128 (ob, lp->next_lp->index);\n+    streamer_write_hwi (ob, lp->next_lp->index);\n   else\n-    output_zero (ob);\n+    streamer_write_zero (ob);\n \n   if (lp->region)\n-    output_sleb128 (ob, lp->region->index);\n+    streamer_write_hwi (ob, lp->region->index);\n   else\n-    output_zero (ob);\n+    streamer_write_zero (ob);\n \n   stream_write_tree (ob, lp->post_landing_pad, true);\n }\n@@ -537,46 +537,48 @@ output_eh_regions (struct output_block *ob, struct function *fn)\n       eh_landing_pad lp;\n       tree ttype;\n \n-      output_record_start (ob, LTO_eh_table);\n+      streamer_write_record_start (ob, LTO_eh_table);\n \n       /* Emit the index of the root of the EH region tree.  */\n-      output_sleb128 (ob, fn->eh->region_tree->index);\n+      streamer_write_hwi (ob, fn->eh->region_tree->index);\n \n       /* Emit all the EH regions in the region array.  */\n-      output_sleb128 (ob, VEC_length (eh_region, fn->eh->region_array));\n+      streamer_write_hwi (ob, VEC_length (eh_region, fn->eh->region_array));\n       FOR_EACH_VEC_ELT (eh_region, fn->eh->region_array, i, eh)\n \toutput_eh_region (ob, eh);\n \n       /* Emit all landing pads.  */\n-      output_sleb128 (ob, VEC_length (eh_landing_pad, fn->eh->lp_array));\n+      streamer_write_hwi (ob, VEC_length (eh_landing_pad, fn->eh->lp_array));\n       FOR_EACH_VEC_ELT (eh_landing_pad, fn->eh->lp_array, i, lp)\n \toutput_eh_lp (ob, lp);\n \n       /* Emit all the runtime type data.  */\n-      output_sleb128 (ob, VEC_length (tree, fn->eh->ttype_data));\n+      streamer_write_hwi (ob, VEC_length (tree, fn->eh->ttype_data));\n       FOR_EACH_VEC_ELT (tree, fn->eh->ttype_data, i, ttype)\n \tstream_write_tree (ob, ttype, true);\n \n       /* Emit the table of action chains.  */\n       if (targetm.arm_eabi_unwinder)\n \t{\n \t  tree t;\n-\t  output_sleb128 (ob, VEC_length (tree, fn->eh->ehspec_data.arm_eabi));\n+\t  streamer_write_hwi (ob, VEC_length (tree,\n+\t\t\t\t              fn->eh->ehspec_data.arm_eabi));\n \t  FOR_EACH_VEC_ELT (tree, fn->eh->ehspec_data.arm_eabi, i, t)\n \t    stream_write_tree (ob, t, true);\n \t}\n       else\n \t{\n \t  uchar c;\n-\t  output_sleb128 (ob, VEC_length (uchar, fn->eh->ehspec_data.other));\n+\t  streamer_write_hwi (ob, VEC_length (uchar,\n+\t\t\t\t              fn->eh->ehspec_data.other));\n \t  FOR_EACH_VEC_ELT (uchar, fn->eh->ehspec_data.other, i, c)\n-\t    lto_output_1_stream (ob->main_stream, c);\n+\t    streamer_write_char_stream (ob->main_stream, c);\n \t}\n     }\n \n   /* The LTO_null either terminates the record or indicates that there\n      are no eh_records at all.  */\n-  output_record_start (ob, LTO_null);\n+  streamer_write_record_start (ob, LTO_null);\n }\n \n \n@@ -588,7 +590,7 @@ output_ssa_names (struct output_block *ob, struct function *fn)\n   unsigned int i, len;\n \n   len = VEC_length (tree, SSANAMES (fn));\n-  output_uleb128 (ob, len);\n+  streamer_write_uhwi (ob, len);\n \n   for (i = 1; i < len; i++)\n     {\n@@ -599,12 +601,13 @@ output_ssa_names (struct output_block *ob, struct function *fn)\n \t  || !is_gimple_reg (ptr))\n \tcontinue;\n \n-      output_uleb128 (ob, i);\n-      lto_output_1_stream (ob->main_stream, SSA_NAME_IS_DEFAULT_DEF (ptr));\n+      streamer_write_uhwi (ob, i);\n+      streamer_write_char_stream (ob->main_stream,\n+\t\t\t\t  SSA_NAME_IS_DEFAULT_DEF (ptr));\n       stream_write_tree (ob, SSA_NAME_VAR (ptr), true);\n     }\n \n-  output_zero (ob);\n+  streamer_write_zero (ob);\n }\n \n \n@@ -618,40 +621,40 @@ output_cfg (struct output_block *ob, struct function *fn)\n \n   ob->main_stream = ob->cfg_stream;\n \n-  lto_output_enum (ob->main_stream, profile_status_d, PROFILE_LAST,\n-\t\t   profile_status_for_function (fn));\n+  streamer_write_enum (ob->main_stream, profile_status_d, PROFILE_LAST,\n+\t\t       profile_status_for_function (fn));\n \n   /* Output the number of the highest basic block.  */\n-  output_uleb128 (ob, last_basic_block_for_function (fn));\n+  streamer_write_uhwi (ob, last_basic_block_for_function (fn));\n \n   FOR_ALL_BB_FN (bb, fn)\n     {\n       edge_iterator ei;\n       edge e;\n \n-      output_sleb128 (ob, bb->index);\n+      streamer_write_hwi (ob, bb->index);\n \n       /* Output the successors and the edge flags.  */\n-      output_uleb128 (ob, EDGE_COUNT (bb->succs));\n+      streamer_write_uhwi (ob, EDGE_COUNT (bb->succs));\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n-\t  output_uleb128 (ob, e->dest->index);\n-\t  output_sleb128 (ob, e->probability);\n-\t  output_sleb128 (ob, e->count);\n-\t  output_uleb128 (ob, e->flags);\n+\t  streamer_write_uhwi (ob, e->dest->index);\n+\t  streamer_write_hwi (ob, e->probability);\n+\t  streamer_write_hwi (ob, e->count);\n+\t  streamer_write_uhwi (ob, e->flags);\n \t}\n     }\n \n-  output_sleb128 (ob, -1);\n+  streamer_write_hwi (ob, -1);\n \n   bb = ENTRY_BLOCK_PTR;\n   while (bb->next_bb)\n     {\n-      output_sleb128 (ob, bb->next_bb->index);\n+      streamer_write_hwi (ob, bb->next_bb->index);\n       bb = bb->next_bb;\n     }\n \n-  output_sleb128 (ob, -1);\n+  streamer_write_hwi (ob, -1);\n \n   ob->main_stream = tmp_stream;\n }\n@@ -737,9 +740,9 @@ output_function (struct cgraph_node *node)\n   push_cfun (fn);\n \n   /* Make string 0 be a NULL string.  */\n-  lto_output_1_stream (ob->string_stream, 0);\n+  streamer_write_char_stream (ob->string_stream, 0);\n \n-  output_record_start (ob, LTO_function);\n+  streamer_write_record_start (ob, LTO_function);\n \n   /* Write all the attributes for FN.  */\n   bp = bitpack_create (ob->main_stream);\n@@ -757,21 +760,21 @@ output_function (struct cgraph_node *node)\n   bp_pack_value (&bp, fn->calls_setjmp, 1);\n   bp_pack_value (&bp, fn->va_list_fpr_size, 8);\n   bp_pack_value (&bp, fn->va_list_gpr_size, 8);\n-  lto_output_bitpack (&bp);\n+  streamer_write_bitpack (&bp);\n \n   /* Output the function start and end loci.  */\n   lto_output_location (ob, fn->function_start_locus);\n   lto_output_location (ob, fn->function_end_locus);\n \n   /* Output current IL state of the function.  */\n-  output_uleb128 (ob, fn->curr_properties);\n+  streamer_write_uhwi (ob, fn->curr_properties);\n \n   /* Output the static chain and non-local goto save area.  */\n   stream_write_tree (ob, fn->static_chain_decl, true);\n   stream_write_tree (ob, fn->nonlocal_goto_save_area, true);\n \n   /* Output all the local variables in the function.  */\n-  output_sleb128 (ob, VEC_length (tree, fn->local_decls));\n+  streamer_write_hwi (ob, VEC_length (tree, fn->local_decls));\n   FOR_EACH_VEC_ELT (tree, fn->local_decls, i, t)\n     stream_write_tree (ob, t, true);\n \n@@ -810,7 +813,7 @@ output_function (struct cgraph_node *node)\n     output_bb (ob, bb, fn);\n \n   /* The terminator for this function.  */\n-  output_record_start (ob, LTO_null);\n+  streamer_write_record_start (ob, LTO_null);\n \n   output_cfg (ob, fn);\n \n@@ -907,7 +910,7 @@ output_unreferenced_globals (cgraph_node_set set, varpool_node_set vset)\n   clear_line_info (ob);\n \n   /* Make string 0 be a NULL string.  */\n-  lto_output_1_stream (ob->string_stream, 0);\n+  streamer_write_char_stream (ob->string_stream, 0);\n \n   /* We really need to propagate in both directoins:\n      for normal aliases we propagate from first defined alias to\n@@ -924,7 +927,7 @@ output_unreferenced_globals (cgraph_node_set set, varpool_node_set vset)\n       }\n   symbol_alias_set_destroy (defined);\n \n-  output_record_start (ob, LTO_null);\n+  streamer_write_record_start (ob, LTO_null);\n \n   produce_asm (ob, NULL);\n   destroy_output_block (ob);\n@@ -1089,7 +1092,7 @@ write_global_stream (struct output_block *ob,\n   for (index = 0; index < size; index++)\n     {\n       t = lto_tree_ref_encoder_get_tree (encoder, index);\n-      if (!lto_streamer_cache_lookup (ob->writer_cache, t, NULL))\n+      if (!streamer_tree_cache_lookup (ob->writer_cache, t, NULL))\n \tstream_write_tree (ob, t, false);\n     }\n }\n@@ -1117,7 +1120,7 @@ write_global_references (struct output_block *ob,\n       uint32_t slot_num;\n \n       t = lto_tree_ref_encoder_get_tree (encoder, index);\n-      lto_streamer_cache_lookup (ob->writer_cache, t, &slot_num);\n+      streamer_tree_cache_lookup (ob->writer_cache, t, &slot_num);\n       gcc_assert (slot_num != (unsigned)-1);\n       lto_output_data_stream (ref_stream, &slot_num, sizeof slot_num);\n     }\n@@ -1153,7 +1156,7 @@ lto_output_decl_state_refs (struct output_block *ob,\n   /* Write reference to FUNCTION_DECL.  If there is not function,\n      write reference to void_type_node. */\n   decl = (state->fn_decl) ? state->fn_decl : void_type_node;\n-  lto_streamer_cache_lookup (ob->writer_cache, decl, &ref);\n+  streamer_tree_cache_lookup (ob->writer_cache, decl, &ref);\n   gcc_assert (ref != (unsigned)-1);\n   lto_output_data_stream (out_stream, &ref, sizeof (uint32_t));\n \n@@ -1185,7 +1188,7 @@ lto_out_decl_state_written_size (struct lto_out_decl_state *state)\n    so far.  */\n \n static void\n-write_symbol (struct lto_streamer_cache_d *cache,\n+write_symbol (struct streamer_tree_cache_d *cache,\n \t      struct lto_output_stream *stream,\n \t      tree t, struct pointer_set_t *seen, bool alias)\n {\n@@ -1218,7 +1221,7 @@ write_symbol (struct lto_streamer_cache_d *cache,\n     return;\n   pointer_set_insert (seen, name);\n \n-  lto_streamer_cache_lookup (cache, t, &slot_num);\n+  streamer_tree_cache_lookup (cache, t, &slot_num);\n   gcc_assert (slot_num != (unsigned)-1);\n \n   if (DECL_EXTERNAL (t))\n@@ -1307,7 +1310,7 @@ static void\n produce_symtab (struct output_block *ob,\n \t        cgraph_node_set set, varpool_node_set vset)\n {\n-  struct lto_streamer_cache_d *cache = ob->writer_cache;\n+  struct streamer_tree_cache_d *cache = ob->writer_cache;\n   char *section_name = lto_get_section_name (LTO_section_symtab, NULL, NULL);\n   struct pointer_set_t *seen;\n   struct cgraph_node *node;\n@@ -1438,7 +1441,7 @@ produce_asm_for_decls (cgraph_node_set set, varpool_node_set vset)\n   free (section_name);\n \n   /* Make string 0 be a NULL string.  */\n-  lto_output_1_stream (ob->string_stream, 0);\n+  streamer_write_char_stream (ob->string_stream, 0);\n \n   /* Write the global symbols.  */\n   out_state = lto_get_out_decl_state ();"}, {"sha": "633c3ce4d5059538854be6b7c8b35346b564a068", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -291,7 +291,7 @@ lto_streamer_init (void)\n      match exactly the structures defined in treestruct.def.  When a\n      new TS_* astructure is added, the streamer should be updated to\n      handle it.  */\n-  check_handled_ts_structures ();\n+  streamer_check_handled_ts_structures ();\n \n #ifdef LTO_STREAMER_DEBUG\n   tree_htab = htab_create (31, hash_tree, eq_tree, NULL);"}, {"sha": "190d6a3a821656323d073414b5dcd20a0d8929eb", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -652,7 +652,7 @@ struct output_block\n   bool global;\n \n   /* Cache of nodes written in this section.  */\n-  struct lto_streamer_cache_d *writer_cache;\n+  struct streamer_tree_cache_d *writer_cache;\n \n   /* All data persistent across whole duration of output block\n      can go here.  */\n@@ -690,7 +690,7 @@ struct data_in\n   VEC(ld_plugin_symbol_resolution_t,heap) *globals_resolution;\n \n   /* Cache of pickled nodes.  */\n-  struct lto_streamer_cache_d *reader_cache;\n+  struct streamer_tree_cache_d *reader_cache;\n };\n \n \n@@ -712,10 +712,6 @@ extern const char *lto_get_section_data (struct lto_file_decl_data *,\n extern void lto_free_section_data (struct lto_file_decl_data *,\n \t\t\t\t   enum lto_section_type,\n \t\t\t\t   const char *, const char *, size_t);\n-extern unsigned HOST_WIDE_INT lto_input_uleb128 (struct lto_input_block *);\n-extern unsigned HOST_WIDEST_INT lto_input_widest_uint_uleb128 (\n-\t\t\t\t\t\tstruct lto_input_block *);\n-extern HOST_WIDE_INT lto_input_sleb128 (struct lto_input_block *);\n extern htab_t lto_create_renaming_table (void);\n extern void lto_record_renamed_decl (struct lto_file_decl_data *,\n \t\t\t\t     const char *, const char *);\n@@ -742,12 +738,6 @@ extern void lto_end_section (void);\n extern void lto_write_stream (struct lto_output_stream *);\n extern void lto_output_data_stream (struct lto_output_stream *, const void *,\n \t\t\t\t    size_t);\n-extern void lto_output_uleb128_stream (struct lto_output_stream *,\n-       \t\t\t\t       unsigned HOST_WIDE_INT);\n-extern void lto_output_widest_uint_uleb128_stream (struct lto_output_stream *,\n-       \t\t\t\t\t           unsigned HOST_WIDEST_INT);\n-extern void lto_output_sleb128_stream (struct lto_output_stream *,\n-\t\t\t\t       HOST_WIDE_INT);\n extern bool lto_output_decl_index (struct lto_output_stream *,\n \t\t\t    struct lto_tree_ref_encoder *,\n \t\t\t    tree, unsigned int *);"}, {"sha": "0b1dcb9c8b53dcb34689b3949ed89d73a3493b64", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -204,7 +204,7 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n   uint32_t i, j;\n   \n   ix = *data++;\n-  decl = lto_streamer_cache_get (data_in->reader_cache, ix);\n+  decl = streamer_tree_cache_get (data_in->reader_cache, ix);\n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n       gcc_assert (decl == void_type_node);\n@@ -218,7 +218,7 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n       tree *decls = ggc_alloc_vec_tree (size);\n \n       for (j = 0; j < size; j++)\n-\tdecls[j] = lto_streamer_cache_get (data_in->reader_cache, data[j]);\n+\tdecls[j] = streamer_tree_cache_get (data_in->reader_cache, data[j]);\n \n       state->streams[i].size = size;\n       state->streams[i].trees = decls;\n@@ -563,7 +563,7 @@ lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl)\n   if (TREE_PUBLIC (decl))\n     {\n       unsigned ix;\n-      if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n+      if (!streamer_tree_cache_lookup (data_in->reader_cache, decl, &ix))\n \tgcc_unreachable ();\n       lto_symtab_register_decl (decl, get_resolution (data_in, ix),\n \t\t\t\tdata_in->file_data);\n@@ -629,7 +629,7 @@ lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl)\n   if (TREE_PUBLIC (decl) && !DECL_ABSTRACT (decl))\n     {\n       unsigned ix;\n-      if (!lto_streamer_cache_lookup (data_in->reader_cache, decl, &ix))\n+      if (!streamer_tree_cache_lookup (data_in->reader_cache, decl, &ix))\n \tgcc_unreachable ();\n       lto_symtab_register_decl (decl, get_resolution (data_in, ix),\n \t\t\t\tdata_in->file_data);\n@@ -645,7 +645,7 @@ lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl)\n static void\n uniquify_nodes (struct data_in *data_in, unsigned from)\n {\n-  struct lto_streamer_cache_d *cache = data_in->reader_cache;\n+  struct streamer_tree_cache_d *cache = data_in->reader_cache;\n   unsigned len = VEC_length (tree, cache->nodes);\n   unsigned i;\n \n@@ -756,7 +756,7 @@ uniquify_nodes (struct data_in *data_in, unsigned from)\n \t\t  {\n \t\t    unsigned ix;\n \t\t    gcc_assert (f1 != f2 && DECL_NAME (f1) == DECL_NAME (f2));\n-\t\t    if (!lto_streamer_cache_lookup (cache, f2, &ix))\n+\t\t    if (!streamer_tree_cache_lookup (cache, f2, &ix))\n \t\t      gcc_unreachable ();\n \t\t    /* If we're going to replace an element which we'd\n \t\t       still visit in the next iterations, we wouldn't\n@@ -772,14 +772,14 @@ uniquify_nodes (struct data_in *data_in, unsigned from)\n \t\t       operand handling.  */\n \t\t    if (ix < i)\n \t\t      lto_fixup_types (f2);\n-\t\t    lto_streamer_cache_insert_at (cache, f1, ix);\n+\t\t    streamer_tree_cache_insert_at (cache, f1, ix);\n \t\t  }\n \t    }\n \n \t  /* If we found a tree that is equal to oldt replace it in the\n \t     cache, so that further users (in the various LTO sections)\n \t     make use of it.  */\n-\t  lto_streamer_cache_insert_at (cache, t, i);\n+\t  streamer_tree_cache_insert_at (cache, t, i);\n \t}\n     }\n "}, {"sha": "b4c65629e4758fe750ab6d6fb94fd548953c577b", "filename": "gcc/streamer-hooks.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fstreamer-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Fstreamer-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstreamer-hooks.h?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -29,8 +29,6 @@ along with GCC; see the file COPYING3.  If not see\n struct output_block;\n struct lto_input_block;\n struct data_in;\n-struct bitpack_d;\n-struct lto_streamer_cache_d;\n \n /* Streamer hooks.  These functions do additional processing as\n    needed by the module.  There are two types of callbacks, those that"}, {"sha": "efa4bd877be44947ce9c4ba97000bfa1e8c3301f", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -34,12 +34,12 @@ along with GCC; see the file COPYING3.  If not see\n    block IB.  */\n \n tree\n-input_string_cst (struct data_in *data_in, struct lto_input_block *ib)\n+streamer_read_string_cst (struct data_in *data_in, struct lto_input_block *ib)\n {\n   unsigned int len;\n   const char * ptr;\n \n-  ptr = input_string_internal (data_in, ib, &len);\n+  ptr = streamer_read_indexed_string (data_in, ib, &len);\n   if (!ptr)\n     return NULL;\n   return build_string (len, ptr);\n@@ -55,7 +55,7 @@ input_identifier (struct data_in *data_in, struct lto_input_block *ib)\n   unsigned int len;\n   const char *ptr;\n \n-  ptr = input_string_internal (data_in, ib, &len);\n+  ptr = streamer_read_indexed_string (data_in, ib, &len);\n   if (!ptr)\n     return NULL;\n   return get_identifier_with_length (ptr, len);\n@@ -65,14 +65,14 @@ input_identifier (struct data_in *data_in, struct lto_input_block *ib)\n /* Read a chain of tree nodes from input block IB. DATA_IN contains\n    tables and descriptors for the file being read.  */\n \n-static tree\n-lto_input_chain (struct lto_input_block *ib, struct data_in *data_in)\n+tree\n+streamer_read_chain (struct lto_input_block *ib, struct data_in *data_in)\n {\n   int i, count;\n   tree first, prev, curr;\n \n   first = prev = NULL_TREE;\n-  count = lto_input_sleb128 (ib);\n+  count = streamer_read_hwi (ib);\n   for (i = 0; i < count; i++)\n     {\n       curr = stream_read_tree (ib, data_in);\n@@ -96,7 +96,7 @@ static void\n unpack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n {\n   /* Note that the code for EXPR has already been unpacked to create EXPR in\n-     lto_materialize_tree.  */\n+     streamer_alloc_tree.  */\n   if (!TYPE_P (expr))\n     {\n       TREE_SIDE_EFFECTS (expr) = (unsigned) bp_unpack_value (bp, 1);\n@@ -409,13 +409,13 @@ unpack_value_fields (struct bitpack_d *bp, tree expr)\n    bitfield values that the writer may have written.  */\n \n struct bitpack_d\n-tree_read_bitfields (struct lto_input_block *ib, tree expr)\n+streamer_read_tree_bitfields (struct lto_input_block *ib, tree expr)\n {\n   enum tree_code code;\n   struct bitpack_d bp;\n \n   /* Read the bitpack of non-pointer values from IB.  */\n-  bp = lto_input_bitpack (ib);\n+  bp = streamer_read_bitpack (ib);\n \n   /* The first word in BP contains the code of the tree that we\n      are about to read.  */\n@@ -435,8 +435,8 @@ tree_read_bitfields (struct lto_input_block *ib, tree expr)\n    *IX_P the index into the reader cache where the new tree is stored.  */\n \n tree\n-lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n-\t\t      enum LTO_tags tag)\n+streamer_alloc_tree (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t     enum LTO_tags tag)\n {\n   enum tree_code code;\n   tree result;\n@@ -450,7 +450,7 @@ lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n   /* Read the word representing the memory address for the tree\n      as it was written by the writer.  This is useful when\n      debugging differences between the writer and reader.  */\n-  orig_address_in_writer = lto_input_sleb128 (ib);\n+  orig_address_in_writer = streamer_read_hwi (ib);\n   gcc_assert ((intptr_t) orig_address_in_writer == orig_address_in_writer);\n #endif\n \n@@ -462,22 +462,22 @@ lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n \n   /* Instantiate a new tree using the header data.  */\n   if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n-    result = input_string_cst (data_in, ib);\n+    result = streamer_read_string_cst (data_in, ib);\n   else if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n     result = input_identifier (data_in, ib);\n   else if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n     {\n-      HOST_WIDE_INT len = lto_input_sleb128 (ib);\n+      HOST_WIDE_INT len = streamer_read_hwi (ib);\n       result = make_tree_vec (len);\n     }\n   else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n     {\n-      unsigned HOST_WIDE_INT len = lto_input_uleb128 (ib);\n+      unsigned HOST_WIDE_INT len = streamer_read_uhwi (ib);\n       result = make_tree_binfo (len);\n     }\n   else if (code == CALL_EXPR)\n     {\n-      unsigned HOST_WIDE_INT nargs = lto_input_uleb128 (ib);\n+      unsigned HOST_WIDE_INT nargs = streamer_read_uhwi (ib);\n       return build_vl_exp (CALL_EXPR, nargs + 3);\n     }\n   else\n@@ -522,7 +522,7 @@ static void\n lto_input_ts_vector_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t   struct data_in *data_in, tree expr)\n {\n-  TREE_VECTOR_CST_ELTS (expr) = lto_input_chain (ib, data_in);\n+  TREE_VECTOR_CST_ELTS (expr) = streamer_read_chain (ib, data_in);\n }\n \n \n@@ -570,7 +570,7 @@ lto_input_ts_decl_common_tree_pointers (struct lto_input_block *ib,\n      dwarf2out.c.  */\n \n   if (TREE_CODE (expr) == PARM_DECL)\n-    TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n+    TREE_CHAIN (expr) = streamer_read_chain (ib, data_in);\n \n   if ((TREE_CODE (expr) == VAR_DECL\n        || TREE_CODE (expr) == PARM_DECL)\n@@ -638,7 +638,7 @@ lto_input_ts_field_decl_tree_pointers (struct lto_input_block *ib,\n   DECL_QUALIFIER (expr) = stream_read_tree (ib, data_in);\n   DECL_FIELD_BIT_OFFSET (expr) = stream_read_tree (ib, data_in);\n   DECL_FCONTEXT (expr) = stream_read_tree (ib, data_in);\n-  TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n+  TREE_CHAIN (expr) = streamer_read_chain (ib, data_in);\n }\n \n \n@@ -724,7 +724,7 @@ lto_input_ts_list_tree_pointers (struct lto_input_block *ib,\n {\n   TREE_PURPOSE (expr) = stream_read_tree (ib, data_in);\n   TREE_VALUE (expr) = stream_read_tree (ib, data_in);\n-  TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n+  TREE_CHAIN (expr) = streamer_read_chain (ib, data_in);\n }\n \n \n@@ -738,7 +738,7 @@ lto_input_ts_vec_tree_pointers (struct lto_input_block *ib,\n {\n   int i;\n \n-  /* Note that TREE_VEC_LENGTH was read by lto_materialize_tree to\n+  /* Note that TREE_VEC_LENGTH was read by streamer_alloc_tree to\n      instantiate EXPR.  */\n   for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n     TREE_VEC_ELT (expr, i) = stream_read_tree (ib, data_in);\n@@ -757,7 +757,7 @@ lto_input_ts_exp_tree_pointers (struct lto_input_block *ib,\n   int i, length;\n   location_t loc;\n \n-  length = lto_input_sleb128 (ib);\n+  length = streamer_read_hwi (ib);\n   gcc_assert (length == TREE_OPERAND_LENGTH (expr));\n \n   for (i = 0; i < length; i++)\n@@ -780,7 +780,7 @@ lto_input_ts_block_tree_pointers (struct lto_input_block *ib,\n   /* Do not stream BLOCK_SOURCE_LOCATION.  We cannot handle debug information\n      for early inlining so drop it on the floor instead of ICEing in\n      dwarf2out.c.  */\n-  BLOCK_VARS (expr) = lto_input_chain (ib, data_in);\n+  BLOCK_VARS (expr) = streamer_read_chain (ib, data_in);\n \n   /* Do not stream BLOCK_NONLOCALIZED_VARS.  We cannot handle debug information\n      for early inlining so drop it on the floor instead of ICEing in\n@@ -827,7 +827,7 @@ lto_input_ts_binfo_tree_pointers (struct lto_input_block *ib,\n   tree t;\n \n   /* Note that the number of slots in EXPR was read in\n-     lto_materialize_tree when instantiating EXPR.  However, the\n+     streamer_alloc_tree when instantiating EXPR.  However, the\n      vector is empty so we cannot rely on VEC_length to know how many\n      elements to read.  So, this list is emitted as a 0-terminated\n      list on the writer side.  */\n@@ -844,7 +844,7 @@ lto_input_ts_binfo_tree_pointers (struct lto_input_block *ib,\n   BINFO_VIRTUALS (expr) = stream_read_tree (ib, data_in);\n   BINFO_VPTR_FIELD (expr) = stream_read_tree (ib, data_in);\n \n-  len = lto_input_uleb128 (ib);\n+  len = streamer_read_uhwi (ib);\n   if (len > 0)\n     {\n       VEC_reserve_exact (tree, gc, BINFO_BASE_ACCESSES (expr), len);\n@@ -871,7 +871,7 @@ lto_input_ts_constructor_tree_pointers (struct lto_input_block *ib,\n {\n   unsigned i, len;\n \n-  len = lto_input_uleb128 (ib);\n+  len = streamer_read_uhwi (ib);\n   for (i = 0; i < len; i++)\n     {\n       tree index, value;\n@@ -892,7 +892,7 @@ lto_input_ts_target_option (struct lto_input_block *ib, tree expr)\n   struct bitpack_d bp;\n   struct cl_target_option *t = TREE_TARGET_OPTION (expr);\n \n-  bp = lto_input_bitpack (ib);\n+  bp = streamer_read_bitpack (ib);\n   len = sizeof (struct cl_target_option);\n   for (i = 0; i < len; i++)\n     ((unsigned char *)t)[i] = bp_unpack_value (&bp, 8);\n@@ -907,15 +907,15 @@ lto_input_ts_translation_unit_decl_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t\t\t  struct data_in *data_in,\n \t\t\t\t\t\t  tree expr)\n {\n-  TRANSLATION_UNIT_LANGUAGE (expr) = xstrdup (lto_input_string (data_in, ib));\n+  TRANSLATION_UNIT_LANGUAGE (expr) = xstrdup (streamer_read_string (data_in, ib));\n   VEC_safe_push (tree, gc, all_translation_units, expr);\n }\n \n /* Read all pointer fields in EXPR from input block IB.  DATA_IN\n    contains tables and descriptors for the file being read.  */\n \n void\n-lto_input_tree_pointers (struct lto_input_block *ib, struct data_in *data_in,\n+streamer_read_tree_body (struct lto_input_block *ib, struct data_in *data_in,\n \t\t\t tree expr)\n {\n   enum tree_code code;\n@@ -985,16 +985,16 @@ lto_input_tree_pointers (struct lto_input_block *ib, struct data_in *data_in,\n    context in DATA_IN.  */\n \n tree\n-lto_input_integer_cst (struct lto_input_block *ib, struct data_in *data_in)\n+streamer_read_integer_cst (struct lto_input_block *ib, struct data_in *data_in)\n {\n   tree result, type;\n   HOST_WIDE_INT low, high;\n   bool overflow_p;\n \n   type = stream_read_tree (ib, data_in);\n-  overflow_p = (lto_input_1_unsigned (ib) != 0);\n-  low = lto_input_uleb128 (ib);\n-  high = lto_input_uleb128 (ib);\n+  overflow_p = (streamer_read_uchar (ib) != 0);\n+  low = streamer_read_uhwi (ib);\n+  high = streamer_read_uhwi (ib);\n   result = build_int_cst_wide (type, low, high);\n \n   /* If the original constant had overflown, build a replica of RESULT to\n@@ -1013,16 +1013,16 @@ lto_input_integer_cst (struct lto_input_block *ib, struct data_in *data_in)\n    DATA_IN->FILE_DATA->GLOBALS_INDEX[IX].  */\n \n tree\n-lto_get_pickled_tree (struct lto_input_block *ib, struct data_in *data_in)\n+streamer_get_pickled_tree (struct lto_input_block *ib, struct data_in *data_in)\n {\n   unsigned HOST_WIDE_INT ix;\n   tree result;\n   enum LTO_tags expected_tag;\n \n-  ix = lto_input_uleb128 (ib);\n-  expected_tag = lto_input_enum (ib, LTO_tags, LTO_NUM_TAGS);\n+  ix = streamer_read_uhwi (ib);\n+  expected_tag = streamer_read_enum (ib, LTO_tags, LTO_NUM_TAGS);\n \n-  result = lto_streamer_cache_get (data_in->reader_cache, ix);\n+  result = streamer_tree_cache_get (data_in->reader_cache, ix);\n   gcc_assert (result\n               && TREE_CODE (result) == lto_tag_to_tree_code (expected_tag));\n \n@@ -1034,17 +1034,17 @@ lto_get_pickled_tree (struct lto_input_block *ib, struct data_in *data_in)\n    corresponding builtin.  DATA_IN is as in stream_read_tree.  */\n \n tree\n-lto_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n+streamer_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n {\n   enum built_in_class fclass;\n   enum built_in_function fcode;\n   const char *asmname;\n   tree result;\n \n-  fclass = lto_input_enum (ib, built_in_class, BUILT_IN_LAST);\n+  fclass = streamer_read_enum (ib, built_in_class, BUILT_IN_LAST);\n   gcc_assert (fclass == BUILT_IN_NORMAL || fclass == BUILT_IN_MD);\n \n-  fcode = (enum built_in_function) lto_input_uleb128 (ib);\n+  fcode = (enum built_in_function) streamer_read_uhwi (ib);\n \n   if (fclass == BUILT_IN_NORMAL)\n     {\n@@ -1062,11 +1062,11 @@ lto_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n   else\n     gcc_unreachable ();\n \n-  asmname = lto_input_string (data_in, ib);\n+  asmname = streamer_read_string (data_in, ib);\n   if (asmname)\n     set_builtin_user_assembler_name (result, asmname);\n \n-  lto_streamer_cache_append (data_in->reader_cache, result);\n+  streamer_tree_cache_append (data_in->reader_cache, result);\n \n   return result;\n }"}, {"sha": "61e674ab4f77f39b988606659b8e5b1a3b314dcc", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 101, "deletions": 106, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -32,29 +32,29 @@ along with GCC; see the file COPYING3.  If not see\n    table in OB.  Then put the index onto the INDEX_STREAM.  */\n \n static void\n-output_string_cst (struct output_block *ob,\n+write_string_cst (struct output_block *ob,\n \t\t   struct lto_output_stream *index_stream,\n \t\t   tree string)\n {\n-  lto_output_string_with_length (ob, index_stream,\n-\t\t\t\t TREE_STRING_POINTER (string),\n-\t\t\t\t TREE_STRING_LENGTH (string),\n-\t\t\t\t true);\n+  streamer_write_string_with_length (ob, index_stream,\n+\t\t\t\t     TREE_STRING_POINTER (string),\n+\t\t\t\t     TREE_STRING_LENGTH (string),\n+\t\t\t\t     true);\n }\n \n \n /* Output the identifier ID to the string\n    table in OB.  Then put the index onto the INDEX_STREAM.  */\n \n static void\n-output_identifier (struct output_block *ob,\n+write_identifier (struct output_block *ob,\n \t\t   struct lto_output_stream *index_stream,\n \t\t   tree id)\n {\n-  lto_output_string_with_length (ob, index_stream,\n-\t\t\t\t IDENTIFIER_POINTER (id),\n-\t\t\t\t IDENTIFIER_LENGTH (id),\n-\t\t\t\t true);\n+  streamer_write_string_with_length (ob, index_stream,\n+\t\t\t\t     IDENTIFIER_POINTER (id),\n+\t\t\t\t     IDENTIFIER_LENGTH (id),\n+\t\t\t\t     true);\n }\n \n \n@@ -235,7 +235,7 @@ pack_ts_function_decl_value_fields (struct bitpack_d *bp, tree expr)\n {\n   /* For normal/md builtins we only write the class and code, so they\n      should never be handled here.  */\n-  gcc_assert (!lto_stream_as_builtin_p (expr));\n+  gcc_assert (!streamer_handle_as_builtin_p (expr));\n \n   bp_pack_enum (bp, built_in_class, BUILT_IN_LAST,\n \t\tDECL_BUILT_IN_CLASS (expr));\n@@ -303,10 +303,11 @@ pack_ts_translation_unit_decl_value_fields (struct bitpack_d *bp ATTRIBUTE_UNUSE\n {\n }\n \n-/* Pack all the non-pointer fields in EXPR into a bit pack.  */\n+\n+/* Pack all the bitfields in EXPR into a bit pack.  */\n \n void\n-pack_value_fields (struct bitpack_d *bp, tree expr)\n+streamer_pack_tree_bitfields (struct bitpack_d *bp, tree expr)\n {\n   enum tree_code code;\n \n@@ -349,19 +350,19 @@ pack_value_fields (struct bitpack_d *bp, tree expr)\n    the index into the streamer cache where EXPR is stored.*/\n \n void\n-lto_output_builtin_tree (struct output_block *ob, tree expr)\n+streamer_write_builtin (struct output_block *ob, tree expr)\n {\n-  gcc_assert (lto_stream_as_builtin_p (expr));\n+  gcc_assert (streamer_handle_as_builtin_p (expr));\n \n   if (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_MD\n       && !targetm.builtin_decl)\n-    sorry (\"gimple bytecode streams do not support machine specific builtin \"\n+    sorry (\"tree bytecode streams do not support machine specific builtin \"\n \t   \"functions on this target\");\n \n-  output_record_start (ob, LTO_builtin_decl);\n-  lto_output_enum (ob->main_stream, built_in_class, BUILT_IN_LAST,\n-\t\t   DECL_BUILT_IN_CLASS (expr));\n-  output_uleb128 (ob, DECL_FUNCTION_CODE (expr));\n+  streamer_write_record_start (ob, LTO_builtin_decl);\n+  streamer_write_enum (ob->main_stream, built_in_class, BUILT_IN_LAST,\n+\t\t       DECL_BUILT_IN_CLASS (expr));\n+  streamer_write_uhwi (ob, DECL_FUNCTION_CODE (expr));\n \n   if (DECL_ASSEMBLER_NAME_SET_P (expr))\n     {\n@@ -371,12 +372,12 @@ lto_output_builtin_tree (struct output_block *ob, tree expr)\n \t reader side from adding a second '*', we omit it here.  */\n       const char *str = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (expr));\n       if (strlen (str) > 1 && str[0] == '*')\n-\tlto_output_string (ob, ob->main_stream, &str[1], true);\n+\tstreamer_write_string (ob, ob->main_stream, &str[1], true);\n       else\n-\tlto_output_string (ob, ob->main_stream, NULL, true);\n+\tstreamer_write_string (ob, ob->main_stream, NULL, true);\n     }\n   else\n-    lto_output_string (ob, ob->main_stream, NULL, true);\n+    streamer_write_string (ob, ob->main_stream, NULL, true);\n }\n \n \n@@ -385,12 +386,12 @@ lto_output_builtin_tree (struct output_block *ob, tree expr)\n    as references.  */\n \n void\n-lto_output_chain (struct output_block *ob, tree t, bool ref_p)\n+streamer_write_chain (struct output_block *ob, tree t, bool ref_p)\n {\n   int i, count;\n \n   count = list_length (t);\n-  output_sleb128 (ob, count);\n+  streamer_write_hwi (ob, count);\n   for (i = 0; i < count; i++)\n     {\n       tree saved_chain;\n@@ -413,8 +414,7 @@ lto_output_chain (struct output_block *ob, tree t, bool ref_p)\n    fields.  */\n \n static void\n-lto_output_ts_common_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t    bool ref_p)\n+write_ts_common_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n   if (TREE_CODE (expr) != IDENTIFIER_NODE)\n     stream_write_tree (ob, TREE_TYPE (expr), ref_p);\n@@ -426,10 +426,9 @@ lto_output_ts_common_tree_pointers (struct output_block *ob, tree expr,\n    fields.  */\n \n static void\n-lto_output_ts_vector_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t    bool ref_p)\n+write_ts_vector_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n-  lto_output_chain (ob, TREE_VECTOR_CST_ELTS (expr), ref_p);\n+  streamer_write_chain (ob, TREE_VECTOR_CST_ELTS (expr), ref_p);\n }\n \n \n@@ -438,8 +437,7 @@ lto_output_ts_vector_tree_pointers (struct output_block *ob, tree expr,\n    fields.  */\n \n static void\n-lto_output_ts_complex_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t     bool ref_p)\n+write_ts_complex_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n   stream_write_tree (ob, TREE_REALPART (expr), ref_p);\n   stream_write_tree (ob, TREE_IMAGPART (expr), ref_p);\n@@ -451,8 +449,8 @@ lto_output_ts_complex_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-lto_output_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t  bool ref_p)\n+write_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t     bool ref_p)\n {\n   stream_write_tree (ob, DECL_NAME (expr), ref_p);\n   stream_write_tree (ob, DECL_CONTEXT (expr), ref_p);\n@@ -465,8 +463,8 @@ lto_output_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-lto_output_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t bool ref_p)\n+write_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t    bool ref_p)\n {\n   stream_write_tree (ob, DECL_SIZE (expr), ref_p);\n   stream_write_tree (ob, DECL_SIZE_UNIT (expr), ref_p);\n@@ -481,7 +479,7 @@ lto_output_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n      dwarf2out.c.  */\n \n   if (TREE_CODE (expr) == PARM_DECL)\n-    lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n+    streamer_write_chain (ob, TREE_CHAIN (expr), ref_p);\n \n   if ((TREE_CODE (expr) == VAR_DECL\n        || TREE_CODE (expr) == PARM_DECL)\n@@ -498,8 +496,8 @@ lto_output_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-lto_output_ts_decl_non_common_tree_pointers (struct output_block *ob,\n-\t\t\t\t\t     tree expr, bool ref_p)\n+write_ts_decl_non_common_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t        bool ref_p)\n {\n   if (TREE_CODE (expr) == FUNCTION_DECL)\n     {\n@@ -515,8 +513,8 @@ lto_output_ts_decl_non_common_tree_pointers (struct output_block *ob,\n    pointer fields.  */\n \n static void\n-lto_output_ts_decl_with_vis_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t   bool ref_p)\n+write_ts_decl_with_vis_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t              bool ref_p)\n {\n   /* Make sure we don't inadvertently set the assembler name.  */\n   if (DECL_ASSEMBLER_NAME_SET_P (expr))\n@@ -534,15 +532,15 @@ lto_output_ts_decl_with_vis_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-lto_output_ts_field_decl_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\tbool ref_p)\n+write_ts_field_decl_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t   bool ref_p)\n {\n   stream_write_tree (ob, DECL_FIELD_OFFSET (expr), ref_p);\n   stream_write_tree (ob, DECL_BIT_FIELD_TYPE (expr), ref_p);\n   stream_write_tree (ob, DECL_QUALIFIER (expr), ref_p);\n   stream_write_tree (ob, DECL_FIELD_BIT_OFFSET (expr), ref_p);\n   stream_write_tree (ob, DECL_FCONTEXT (expr), ref_p);\n-  lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n+  streamer_write_chain (ob, TREE_CHAIN (expr), ref_p);\n }\n \n \n@@ -551,8 +549,8 @@ lto_output_ts_field_decl_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-lto_output_ts_function_decl_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t   bool ref_p)\n+write_ts_function_decl_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t      bool ref_p)\n {\n   /* DECL_STRUCT_FUNCTION is handled by lto_output_function.  FIXME lto,\n      maybe it should be handled here?  */\n@@ -567,8 +565,8 @@ lto_output_ts_function_decl_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-lto_output_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t bool ref_p)\n+write_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t    bool ref_p)\n {\n   stream_write_tree (ob, TYPE_SIZE (expr), ref_p);\n   stream_write_tree (ob, TYPE_SIZE_UNIT (expr), ref_p);\n@@ -590,8 +588,8 @@ lto_output_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-lto_output_ts_type_non_common_tree_pointers (struct output_block *ob,\n-\t\t\t\t\t     tree expr, bool ref_p)\n+write_ts_type_non_common_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\tbool ref_p)\n {\n   if (TREE_CODE (expr) == ENUMERAL_TYPE)\n     stream_write_tree (ob, TYPE_VALUES (expr), ref_p);\n@@ -616,12 +614,11 @@ lto_output_ts_type_non_common_tree_pointers (struct output_block *ob,\n    fields.  */\n \n static void\n-lto_output_ts_list_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t  bool ref_p)\n+write_ts_list_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n   stream_write_tree (ob, TREE_PURPOSE (expr), ref_p);\n   stream_write_tree (ob, TREE_VALUE (expr), ref_p);\n-  lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n+  streamer_write_chain (ob, TREE_CHAIN (expr), ref_p);\n }\n \n \n@@ -630,12 +627,12 @@ lto_output_ts_list_tree_pointers (struct output_block *ob, tree expr,\n    fields.  */\n \n static void\n-lto_output_ts_vec_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+write_ts_vec_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n   int i;\n \n   /* Note that the number of slots for EXPR has already been emitted\n-     in EXPR's header (see lto_output_tree_header).  */\n+     in EXPR's header (see streamer_write_tree_header).  */\n   for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n     stream_write_tree (ob, TREE_VEC_ELT (expr, i), ref_p);\n }\n@@ -646,11 +643,11 @@ lto_output_ts_vec_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    fields.  */\n \n static void\n-lto_output_ts_exp_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+write_ts_exp_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n   int i;\n \n-  output_sleb128 (ob, TREE_OPERAND_LENGTH (expr));\n+  streamer_write_hwi (ob, TREE_OPERAND_LENGTH (expr));\n   for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n     stream_write_tree (ob, TREE_OPERAND (expr, i), ref_p);\n   lto_output_location (ob, EXPR_LOCATION (expr));\n@@ -663,13 +660,12 @@ lto_output_ts_exp_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    fields.  */\n \n static void\n-lto_output_ts_block_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t   bool ref_p)\n+write_ts_block_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n   /* Do not stream BLOCK_SOURCE_LOCATION.  We cannot handle debug information\n      for early inlining so drop it on the floor instead of ICEing in\n      dwarf2out.c.  */\n-  lto_output_chain (ob, BLOCK_VARS (expr), ref_p);\n+  streamer_write_chain (ob, BLOCK_VARS (expr), ref_p);\n \n   /* Do not stream BLOCK_NONLOCALIZED_VARS.  We cannot handle debug information\n      for early inlining so drop it on the floor instead of ICEing in\n@@ -691,14 +687,13 @@ lto_output_ts_block_tree_pointers (struct output_block *ob, tree expr,\n    fields.  */\n \n static void\n-lto_output_ts_binfo_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t   bool ref_p)\n+write_ts_binfo_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n {\n   unsigned i;\n   tree t;\n \n   /* Note that the number of BINFO slots has already been emitted in\n-     EXPR's header (see lto_output_tree_header) because this length\n+     EXPR's header (see streamer_write_tree_header) because this length\n      is needed to build the empty BINFO node on the reader side.  */\n   FOR_EACH_VEC_ELT (tree, BINFO_BASE_BINFOS (expr), i, t)\n     stream_write_tree (ob, t, ref_p);\n@@ -713,7 +708,7 @@ lto_output_ts_binfo_tree_pointers (struct output_block *ob, tree expr,\n   stream_write_tree (ob, flag_wpa ? NULL : BINFO_VIRTUALS (expr), ref_p);\n   stream_write_tree (ob, BINFO_VPTR_FIELD (expr), ref_p);\n \n-  output_uleb128 (ob, VEC_length (tree, BINFO_BASE_ACCESSES (expr)));\n+  streamer_write_uhwi (ob, VEC_length (tree, BINFO_BASE_ACCESSES (expr)));\n   FOR_EACH_VEC_ELT (tree, BINFO_BASE_ACCESSES (expr), i, t)\n     stream_write_tree (ob, t, ref_p);\n \n@@ -728,13 +723,13 @@ lto_output_ts_binfo_tree_pointers (struct output_block *ob, tree expr,\n    pointer fields.  */\n \n static void\n-lto_output_ts_constructor_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t bool ref_p)\n+write_ts_constructor_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t    bool ref_p)\n {\n   unsigned i;\n   tree index, value;\n \n-  output_uleb128 (ob, CONSTRUCTOR_NELTS (expr));\n+  streamer_write_uhwi (ob, CONSTRUCTOR_NELTS (expr));\n   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (expr), i, index, value)\n     {\n       stream_write_tree (ob, index, ref_p);\n@@ -745,7 +740,7 @@ lto_output_ts_constructor_tree_pointers (struct output_block *ob, tree expr,\n /* Write a TS_TARGET_OPTION tree in EXPR to OB.  */\n \n static void\n-lto_output_ts_target_option (struct output_block *ob, tree expr)\n+write_ts_target_option (struct output_block *ob, tree expr)\n {\n   struct cl_target_option *t = TREE_TARGET_OPTION (expr);\n   struct bitpack_d bp;\n@@ -760,85 +755,85 @@ lto_output_ts_target_option (struct output_block *ob, tree expr)\n     bp_pack_value (&bp, ((unsigned char *)t)[i], 8);\n   /* Catch struct size mismatches between reader and writer. */\n   bp_pack_value (&bp, 0x12345678, 32);\n-  lto_output_bitpack (&bp);\n+  streamer_write_bitpack (&bp);\n }\n \n /* Write a TS_TRANSLATION_UNIT_DECL tree in EXPR to OB.  */\n \n static void\n-lto_output_ts_translation_unit_decl_tree_pointers (struct output_block *ob,\n-\t\t\t\t\t\t   tree expr)\n+write_ts_translation_unit_decl_tree_pointers (struct output_block *ob,\n+\t\t\t\t\t      tree expr)\n {\n-  lto_output_string (ob, ob->main_stream,\n-\t\t     TRANSLATION_UNIT_LANGUAGE (expr), true);\n+  streamer_write_string (ob, ob->main_stream,\n+\t\t\t TRANSLATION_UNIT_LANGUAGE (expr), true);\n }\n \n /* Write all pointer fields in EXPR to output block OB.  If REF_P is true,\n    the leaves of EXPR are emitted as references.  */\n \n void\n-lto_output_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+streamer_write_tree_body (struct output_block *ob, tree expr, bool ref_p)\n {\n   enum tree_code code;\n \n   code = TREE_CODE (expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n-    lto_output_ts_common_tree_pointers (ob, expr, ref_p);\n+    write_ts_common_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n-    lto_output_ts_vector_tree_pointers (ob, expr, ref_p);\n+    write_ts_vector_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n-    lto_output_ts_complex_tree_pointers (ob, expr, ref_p);\n+    write_ts_complex_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n-    lto_output_ts_decl_minimal_tree_pointers (ob, expr, ref_p);\n+    write_ts_decl_minimal_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n-    lto_output_ts_decl_common_tree_pointers (ob, expr, ref_p);\n+    write_ts_decl_common_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n-    lto_output_ts_decl_non_common_tree_pointers (ob, expr, ref_p);\n+    write_ts_decl_non_common_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n-    lto_output_ts_decl_with_vis_tree_pointers (ob, expr, ref_p);\n+    write_ts_decl_with_vis_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n-    lto_output_ts_field_decl_tree_pointers (ob, expr, ref_p);\n+    write_ts_field_decl_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n-    lto_output_ts_function_decl_tree_pointers (ob, expr, ref_p);\n+    write_ts_function_decl_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n-    lto_output_ts_type_common_tree_pointers (ob, expr, ref_p);\n+    write_ts_type_common_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n-    lto_output_ts_type_non_common_tree_pointers (ob, expr, ref_p);\n+    write_ts_type_non_common_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n-    lto_output_ts_list_tree_pointers (ob, expr, ref_p);\n+    write_ts_list_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n-    lto_output_ts_vec_tree_pointers (ob, expr, ref_p);\n+    write_ts_vec_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n-    lto_output_ts_exp_tree_pointers (ob, expr, ref_p);\n+    write_ts_exp_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n-    lto_output_ts_block_tree_pointers (ob, expr, ref_p);\n+    write_ts_block_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n-    lto_output_ts_binfo_tree_pointers (ob, expr, ref_p);\n+    write_ts_binfo_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n-    lto_output_ts_constructor_tree_pointers (ob, expr, ref_p);\n+    write_ts_constructor_tree_pointers (ob, expr, ref_p);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TARGET_OPTION))\n-    lto_output_ts_target_option (ob, expr);\n+    write_ts_target_option (ob, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n-    lto_output_ts_translation_unit_decl_tree_pointers (ob, expr);\n+    write_ts_translation_unit_decl_tree_pointers (ob, expr);\n }\n \n \n@@ -848,7 +843,7 @@ lto_output_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n    where EXPR is stored.  */\n \n void\n-lto_output_tree_header (struct output_block *ob, tree expr)\n+streamer_write_tree_header (struct output_block *ob, tree expr)\n {\n   enum LTO_tags tag;\n   enum tree_code code;\n@@ -861,7 +856,7 @@ lto_output_tree_header (struct output_block *ob, tree expr)\n      EXPR on the reading side (such as the number of slots in\n      variable sized nodes).  */\n   tag = lto_tree_code_to_tag (code);\n-  output_record_start (ob, tag);\n+  streamer_write_record_start (ob, tag);\n \n   /* The following will cause bootstrap miscomparisons.  Enable with care.  */\n #ifdef LTO_STREAMER_DEBUG\n@@ -870,33 +865,33 @@ lto_output_tree_header (struct output_block *ob, tree expr)\n      value for EXPR can be used to track down the differences in\n      the debugger.  */\n   gcc_assert ((HOST_WIDEST_INT) (intptr_t) expr == (intptr_t) expr);\n-  output_sleb128 (ob, (HOST_WIDEST_INT) (intptr_t) expr);\n+  streamer_write_hwi (ob, (HOST_WIDEST_INT) (intptr_t) expr);\n #endif\n \n   /* The text in strings and identifiers are completely emitted in\n      the header.  */\n   if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n-    output_string_cst (ob, ob->main_stream, expr);\n+    write_string_cst (ob, ob->main_stream, expr);\n   else if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n-    output_identifier (ob, ob->main_stream, expr);\n+    write_identifier (ob, ob->main_stream, expr);\n   else if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n-    output_sleb128 (ob, TREE_VEC_LENGTH (expr));\n+    streamer_write_hwi (ob, TREE_VEC_LENGTH (expr));\n   else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n-    output_uleb128 (ob, BINFO_N_BASE_BINFOS (expr));\n+    streamer_write_uhwi (ob, BINFO_N_BASE_BINFOS (expr));\n   else if (TREE_CODE (expr) == CALL_EXPR)\n-    output_uleb128 (ob, call_expr_nargs (expr));\n+    streamer_write_uhwi (ob, call_expr_nargs (expr));\n }\n \n \n /* Emit the integer constant CST to output block OB.  If REF_P is true,\n    CST's type will be emitted as a reference.  */\n \n void\n-lto_output_integer_cst (struct output_block *ob, tree cst, bool ref_p)\n+streamer_write_integer_cst (struct output_block *ob, tree cst, bool ref_p)\n {\n-  output_record_start (ob, lto_tree_code_to_tag (INTEGER_CST));\n+  streamer_write_record_start (ob, lto_tree_code_to_tag (INTEGER_CST));\n   stream_write_tree (ob, TREE_TYPE (cst), ref_p);\n-  lto_output_1_stream (ob->main_stream, TREE_OVERFLOW_P (cst));\n-  output_uleb128 (ob, TREE_INT_CST_LOW (cst));\n-  output_uleb128 (ob, TREE_INT_CST_HIGH (cst));\n+  streamer_write_char_stream (ob->main_stream, TREE_OVERFLOW_P (cst));\n+  streamer_write_uhwi (ob, TREE_INT_CST_LOW (cst));\n+  streamer_write_uhwi (ob, TREE_INT_CST_HIGH (cst));\n }"}, {"sha": "94d540b59843e8cedd81228aa18a5d198b08f66c", "filename": "gcc/tree-streamer.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Ftree-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Ftree-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.c?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -26,12 +26,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"streamer-hooks.h\"\n #include \"tree-streamer.h\"\n \n-/* Check that all the TS_* structures handled by the lto_output_* and\n-   lto_input_* routines are exactly ALL the structures defined in\n+/* Check that all the TS_* structures handled by the streamer_write_* and\n+   streamer_read_* routines are exactly ALL the structures defined in\n    treestruct.def.  */\n \n void\n-check_handled_ts_structures (void)\n+streamer_check_handled_ts_structures (void)\n {\n   bool handled_p[LAST_TS_ENUM];\n   unsigned i;\n@@ -87,12 +87,12 @@ check_handled_ts_structures (void)\n }\n \n \n-/* Helper for lto_streamer_cache_insert_1.  Add T to CACHE->NODES at\n+/* Helper for streamer_tree_cache_insert_1.  Add T to CACHE->NODES at\n    slot IX.  */\n \n static void\n-lto_streamer_cache_add_to_node_array (struct lto_streamer_cache_d *cache,\n-\t\t\t\t      unsigned ix, tree t)\n+streamer_tree_cache_add_to_node_array (struct streamer_tree_cache_d *cache,\n+\t\t\t\t       unsigned ix, tree t)\n {\n   /* Make sure we're either replacing an old element or\n      appending consecutively.  */\n@@ -105,8 +105,8 @@ lto_streamer_cache_add_to_node_array (struct lto_streamer_cache_d *cache,\n }\n \n \n-/* Helper for lto_streamer_cache_insert and lto_streamer_cache_insert_at.\n-   CACHE, T, and IX_P are as in lto_streamer_cache_insert.\n+/* Helper for streamer_tree_cache_insert and streamer_tree_cache_insert_at.\n+   CACHE, T, and IX_P are as in streamer_tree_cache_insert.\n \n    If INSERT_AT_NEXT_SLOT_P is true, T is inserted at the next available\n    slot in the cache.  Otherwise, T is inserted at the position indicated\n@@ -116,9 +116,9 @@ lto_streamer_cache_add_to_node_array (struct lto_streamer_cache_d *cache,\n    return false.  */\n \n static bool\n-lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n-\t\t\t     tree t, unsigned *ix_p,\n-\t\t\t     bool insert_at_next_slot_p)\n+streamer_tree_cache_insert_1 (struct streamer_tree_cache_d *cache,\n+\t\t\t      tree t, unsigned *ix_p,\n+\t\t\t      bool insert_at_next_slot_p)\n {\n   void **slot;\n   unsigned ix;\n@@ -136,7 +136,7 @@ lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n \tix = *ix_p;\n        *slot = (void *)(size_t) (ix + 1);\n \n-      lto_streamer_cache_add_to_node_array (cache, ix, t);\n+      streamer_tree_cache_add_to_node_array (cache, ix, t);\n \n       /* Indicate that the item was not present in the cache.  */\n       existed_p = false;\n@@ -151,7 +151,7 @@ lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n \t     location, and ENTRY->TO does not match *IX_P, add T to\n \t     the requested location slot.  */\n \t  ix = *ix_p;\n-\t  lto_streamer_cache_add_to_node_array (cache, ix, t);\n+\t  streamer_tree_cache_add_to_node_array (cache, ix, t);\n \t}\n \n       /* Indicate that T was already in the cache.  */\n@@ -172,40 +172,40 @@ lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n    T has been stored.  */\n \n bool\n-lto_streamer_cache_insert (struct lto_streamer_cache_d *cache, tree t,\n-\t\t\t   unsigned *ix_p)\n+streamer_tree_cache_insert (struct streamer_tree_cache_d *cache, tree t,\n+\t\t\t    unsigned *ix_p)\n {\n-  return lto_streamer_cache_insert_1 (cache, t, ix_p, true);\n+  return streamer_tree_cache_insert_1 (cache, t, ix_p, true);\n }\n \n \n /* Insert tree node T in CACHE at slot IX.  If T already\n    existed in the cache return true.  Otherwise, return false.  */\n \n bool\n-lto_streamer_cache_insert_at (struct lto_streamer_cache_d *cache,\n-\t\t\t      tree t, unsigned ix)\n+streamer_tree_cache_insert_at (struct streamer_tree_cache_d *cache,\n+\t\t\t       tree t, unsigned ix)\n {\n-  return lto_streamer_cache_insert_1 (cache, t, &ix, false);\n+  return streamer_tree_cache_insert_1 (cache, t, &ix, false);\n }\n \n \n /* Appends tree node T to CACHE, even if T already existed in it.  */\n \n void\n-lto_streamer_cache_append (struct lto_streamer_cache_d *cache, tree t)\n+streamer_tree_cache_append (struct streamer_tree_cache_d *cache, tree t)\n {\n   unsigned ix = VEC_length (tree, cache->nodes);\n-  lto_streamer_cache_insert_1 (cache, t, &ix, false);\n+  streamer_tree_cache_insert_1 (cache, t, &ix, false);\n }\n \n /* Return true if tree node T exists in CACHE, otherwise false.  If IX_P is\n    not NULL, write to *IX_P the index into the cache where T is stored\n    ((unsigned)-1 if T is not found).  */\n \n bool\n-lto_streamer_cache_lookup (struct lto_streamer_cache_d *cache, tree t,\n-\t\t\t   unsigned *ix_p)\n+streamer_tree_cache_lookup (struct streamer_tree_cache_d *cache, tree t,\n+\t\t\t    unsigned *ix_p)\n {\n   void **slot;\n   bool retval;\n@@ -235,7 +235,7 @@ lto_streamer_cache_lookup (struct lto_streamer_cache_d *cache, tree t,\n /* Return the tree node at slot IX in CACHE.  */\n \n tree\n-lto_streamer_cache_get (struct lto_streamer_cache_d *cache, unsigned ix)\n+streamer_tree_cache_get (struct streamer_tree_cache_d *cache, unsigned ix)\n {\n   gcc_assert (cache);\n \n@@ -249,7 +249,7 @@ lto_streamer_cache_get (struct lto_streamer_cache_d *cache, unsigned ix)\n /* Record NODE in CACHE.  */\n \n static void\n-lto_record_common_node (struct lto_streamer_cache_d *cache, tree node)\n+record_common_node (struct streamer_tree_cache_d *cache, tree node)\n {\n   /* We have to make sure to fill exactly the same number of\n      elements for all frontends.  That can include NULL trees.\n@@ -260,12 +260,12 @@ lto_record_common_node (struct lto_streamer_cache_d *cache, tree node)\n   if (!node)\n     node = error_mark_node;\n \n-  lto_streamer_cache_append (cache, node);\n+  streamer_tree_cache_append (cache, node);\n \n   if (POINTER_TYPE_P (node)\n       || TREE_CODE (node) == COMPLEX_TYPE\n       || TREE_CODE (node) == ARRAY_TYPE)\n-    lto_record_common_node (cache, TREE_TYPE (node));\n+    record_common_node (cache, TREE_TYPE (node));\n   else if (TREE_CODE (node) == RECORD_TYPE)\n     {\n       /* The FIELD_DECLs of structures should be shared, so that every\n@@ -275,7 +275,7 @@ lto_record_common_node (struct lto_streamer_cache_d *cache, tree node)\n \t nonoverlapping_component_refs_p).  */\n       tree f;\n       for (f = TYPE_FIELDS (node); f; f = TREE_CHAIN (f))\n-\tlto_record_common_node (cache, f);\n+\trecord_common_node (cache, f);\n     }\n }\n \n@@ -284,35 +284,35 @@ lto_record_common_node (struct lto_streamer_cache_d *cache, tree node)\n    properly according to the gimple type table.  */\n \n static void\n-preload_common_nodes (struct lto_streamer_cache_d *cache)\n+preload_common_nodes (struct streamer_tree_cache_d *cache)\n {\n   unsigned i;\n \n   for (i = 0; i < itk_none; i++)\n     /* Skip itk_char.  char_type_node is dependent on -f[un]signed-char.  */\n     if (i != itk_char)\n-      lto_record_common_node (cache, integer_types[i]);\n+      record_common_node (cache, integer_types[i]);\n \n   for (i = 0; i < TYPE_KIND_LAST; i++)\n-    lto_record_common_node (cache, sizetype_tab[i]);\n+    record_common_node (cache, sizetype_tab[i]);\n \n   for (i = 0; i < TI_MAX; i++)\n     /* Skip boolean type and constants, they are frontend dependent.  */\n     if (i != TI_BOOLEAN_TYPE\n \t&& i != TI_BOOLEAN_FALSE\n \t&& i != TI_BOOLEAN_TRUE)\n-      lto_record_common_node (cache, global_trees[i]);\n+      record_common_node (cache, global_trees[i]);\n }\n \n \n /* Create a cache of pickled nodes.  */\n \n-struct lto_streamer_cache_d *\n-lto_streamer_cache_create (void)\n+struct streamer_tree_cache_d *\n+streamer_tree_cache_create (void)\n {\n-  struct lto_streamer_cache_d *cache;\n+  struct streamer_tree_cache_d *cache;\n \n-  cache = XCNEW (struct lto_streamer_cache_d);\n+  cache = XCNEW (struct streamer_tree_cache_d);\n \n   cache->node_map = pointer_map_create ();\n \n@@ -328,7 +328,7 @@ lto_streamer_cache_create (void)\n /* Delete the streamer cache C.  */\n \n void\n-lto_streamer_cache_delete (struct lto_streamer_cache_d *c)\n+streamer_tree_cache_delete (struct streamer_tree_cache_d *c)\n {\n   if (c == NULL)\n     return;"}, {"sha": "b8f2d1fd335d7be9bb4d8a649e5a1f2263284add", "filename": "gcc/tree-streamer.h", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Ftree-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412288f1c06565e8d6f96b835adc0aa915f28766/gcc%2Ftree-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.h?ref=412288f1c06565e8d6f96b835adc0aa915f28766", "patch": "@@ -43,7 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n      T.  The reconstructed T is inserted in some array so that when\n      the reference index for T is found in the input stream, it can be\n      used to look up into the array to get the reconstructed T.  */\n-struct lto_streamer_cache_d\n+struct streamer_tree_cache_d\n {\n   /* The mapping between tree nodes and slots into the nodes array.  */\n   struct pointer_map_t *node_map;\n@@ -55,7 +55,7 @@ struct lto_streamer_cache_d\n /* Return true if tree node EXPR should be streamed as a builtin.  For\n    these nodes, we just emit the class and function code.  */\n static inline bool\n-lto_stream_as_builtin_p (tree expr)\n+streamer_handle_as_builtin_p (tree expr)\n {\n   return (TREE_CODE (expr) == FUNCTION_DECL\n \t  && DECL_IS_BUILTIN (expr)\n@@ -64,35 +64,35 @@ lto_stream_as_builtin_p (tree expr)\n }\n \n /* In tree-streamer-in.c.  */\n-tree input_string_cst (struct data_in *, struct lto_input_block *);\n-void lto_streamer_read_tree (struct lto_input_block *, struct data_in *, tree);\n-tree lto_materialize_tree (struct lto_input_block *, struct data_in *,\n-\t\t\t   enum LTO_tags);\n-void lto_input_tree_pointers (struct lto_input_block *, struct data_in *, tree);\n-tree lto_get_pickled_tree (struct lto_input_block *, struct data_in *);\n-tree lto_get_builtin_tree (struct lto_input_block *, struct data_in *);\n-tree lto_input_integer_cst (struct lto_input_block *, struct data_in *);\n-struct bitpack_d tree_read_bitfields (struct lto_input_block *, tree);\n+tree streamer_read_string_cst (struct data_in *, struct lto_input_block *);\n+tree streamer_read_chain (struct lto_input_block *, struct data_in *);\n+tree streamer_alloc_tree (struct lto_input_block *, struct data_in *,\n+\t\t          enum LTO_tags);\n+void streamer_read_tree_body (struct lto_input_block *, struct data_in *, tree);\n+tree streamer_get_pickled_tree (struct lto_input_block *, struct data_in *);\n+tree streamer_get_builtin_tree (struct lto_input_block *, struct data_in *);\n+tree streamer_read_integer_cst (struct lto_input_block *, struct data_in *);\n+struct bitpack_d streamer_read_tree_bitfields (struct lto_input_block *, tree);\n \n /* In tree-streamer-out.c.  */\n-void lto_output_chain (struct output_block *, tree, bool);\n-void lto_output_tree_header (struct output_block *, tree);\n-void pack_value_fields (struct bitpack_d *, tree);\n-void lto_output_tree_pointers (struct output_block *, tree, bool);\n-void lto_output_integer_cst (struct output_block *, tree, bool);\n-void lto_output_builtin_tree (struct output_block *, tree);\n+void streamer_write_chain (struct output_block *, tree, bool);\n+void streamer_write_tree_header (struct output_block *, tree);\n+void streamer_pack_tree_bitfields (struct bitpack_d *, tree);\n+void streamer_write_tree_body (struct output_block *, tree, bool);\n+void streamer_write_integer_cst (struct output_block *, tree, bool);\n+void streamer_write_builtin (struct output_block *, tree);\n \n /* In tree-streamer.c.  */\n-void check_handled_ts_structures (void);\n-bool lto_streamer_cache_insert (struct lto_streamer_cache_d *, tree,\n- \t\t\t        unsigned *);\n-bool lto_streamer_cache_insert_at (struct lto_streamer_cache_d *, tree,\n- \t\t\t\t   unsigned);\n-void lto_streamer_cache_append (struct lto_streamer_cache_d *, tree);\n-bool lto_streamer_cache_lookup (struct lto_streamer_cache_d *, tree,\n- \t\t\t        unsigned *);\n-tree lto_streamer_cache_get (struct lto_streamer_cache_d *, unsigned);\n-struct lto_streamer_cache_d *lto_streamer_cache_create (void);\n-void lto_streamer_cache_delete (struct lto_streamer_cache_d *);\n+void streamer_check_handled_ts_structures (void);\n+bool streamer_tree_cache_insert (struct streamer_tree_cache_d *, tree,\n+\t\t\t\t unsigned *);\n+bool streamer_tree_cache_insert_at (struct streamer_tree_cache_d *, tree,\n+\t\t\t\t    unsigned);\n+void streamer_tree_cache_append (struct streamer_tree_cache_d *, tree);\n+bool streamer_tree_cache_lookup (struct streamer_tree_cache_d *, tree,\n+\t\t\t\t unsigned *);\n+tree streamer_tree_cache_get (struct streamer_tree_cache_d *, unsigned);\n+struct streamer_tree_cache_d *streamer_tree_cache_create (void);\n+void streamer_tree_cache_delete (struct streamer_tree_cache_d *);\n \n #endif  /* GCC_TREE_STREAMER_H  */"}]}