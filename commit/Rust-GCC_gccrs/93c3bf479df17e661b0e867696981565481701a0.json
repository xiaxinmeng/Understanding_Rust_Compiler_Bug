{"sha": "93c3bf479df17e661b0e867696981565481701a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNjM2JmNDc5ZGYxN2U2NjFiMGU4Njc2OTY5ODE1NjU0ODE3MDFhMA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-01-11T05:19:20Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-01-11T05:19:20Z"}, "message": "re PR fortran/47051 (Wrong reallocate)\n\n2011-01-11  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/47051\n\t* trans-array.c (gfc_alloc_allocatable_for_assignment): Change\n\tto be standard compliant by testing for shape rather than size\n\tbefore skipping reallocation. Improve comments.\n\n2011-01-11  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/47051\n\t* gfortran.dg/realloc_on_assign_2.f03 : Modify 'test1' to be\n\tstandard compliant and comment.\n\nFrom-SVN: r168650", "tree": {"sha": "1265f84e90249ed16e7a6a23ec9f38b2efbd5e94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1265f84e90249ed16e7a6a23ec9f38b2efbd5e94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93c3bf479df17e661b0e867696981565481701a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c3bf479df17e661b0e867696981565481701a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93c3bf479df17e661b0e867696981565481701a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c3bf479df17e661b0e867696981565481701a0/comments", "author": null, "committer": null, "parents": [{"sha": "b7e945c8e7c3e479458dda2b750d46f2024cf8d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e945c8e7c3e479458dda2b750d46f2024cf8d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7e945c8e7c3e479458dda2b750d46f2024cf8d2"}], "stats": {"total": 182, "additions": 96, "deletions": 86}, "files": [{"sha": "c61ed9287ee709fbbd994f012cf78852c77af199", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c3bf479df17e661b0e867696981565481701a0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c3bf479df17e661b0e867696981565481701a0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=93c3bf479df17e661b0e867696981565481701a0", "patch": "@@ -1,3 +1,10 @@\n+2011-01-11  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/47051\n+\t* trans-array.c (gfc_alloc_allocatable_for_assignment): Change\n+\tto be standard compliant by testing for shape rather than size\n+\tbefore skipping reallocation. Improve comments.\n+\n 2011-01-09  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/47224"}, {"sha": "4dc69d25c267cf82e72f9b4b2a490f1eec357672", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 71, "deletions": 82, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c3bf479df17e661b0e867696981565481701a0/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c3bf479df17e661b0e867696981565481701a0/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=93c3bf479df17e661b0e867696981565481701a0", "patch": "@@ -1,5 +1,6 @@\n /* Array translation routines\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -6877,35 +6878,11 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   desc = lss->data.info.descriptor;\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)));\n   array1 = gfc_conv_descriptor_data_get (desc);\n-  size1 = gfc_conv_descriptor_size (desc, expr1->rank);\n \n-  /* Get the rhs size.  Fix both sizes.  */\n-  if (expr2)\n-    desc2 = rss->data.info.descriptor;\n-  else\n-    desc2 = NULL_TREE;\n-  size2 = gfc_index_one_node;\n-  for (n = 0; n < expr2->rank; n++)\n-    {\n-      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t     gfc_array_index_type,\n-\t\t\t     loop->to[n], loop->from[n]);\n-      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t     gfc_array_index_type,\n-\t\t\t     tmp, gfc_index_one_node);\n-      size2 = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t       gfc_array_index_type,\n-\t\t\t       tmp, size2);\n-    }\n-  size1 = gfc_evaluate_now (size1, &fblock);\n-  size2 = gfc_evaluate_now (size2, &fblock);\n-  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n-\t\t\t  size1, size2);\n-  neq_size = gfc_evaluate_now (cond, &fblock);\n-\n-  /* If the lhs is allocated and the lhs and rhs are equal length, jump\n-     past the realloc/malloc.  This allows F95 compliant expressions\n-     to escape allocation on assignment.  */\n+  /* 7.4.1.3 \"If variable is an allocated allocatable variable, it is\n+     deallocated if expr is an array of different shape or any of the\n+     corresponding length type parameter values of variable and expr\n+     differ.\"  This assures F95 compatibility.  */\n   jump_label1 = gfc_build_label_decl (NULL_TREE);\n   jump_label2 = gfc_build_label_decl (NULL_TREE);\n \n@@ -6917,12 +6894,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \t\t  build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&fblock, tmp);\n \n-  /* Reallocate if sizes are different.  */\n-  tmp = build3_v (COND_EXPR, neq_size,\n-\t\t  build1_v (GOTO_EXPR, jump_label1),\n-\t\t  build_empty_stmt (input_location));\n-  gfc_add_expr_to_block (&fblock, tmp);\n-\n+  /* Get arrayspec if expr is a full array.  */\n   if (expr2 && expr2->expr_type == EXPR_FUNCTION\n \t&& expr2->value.function.isym\n \t&& expr2->value.function.isym->conversion)\n@@ -6936,59 +6908,76 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   else\n     as = NULL;\n \n-  /* Reset the lhs bounds if any are different from the rhs.  */ \n-  if (as && expr2->expr_type == EXPR_VARIABLE)\n+  /* If the lhs shape is not the same as the rhs jump to setting the\n+     bounds and doing the reallocation.......  */ \n+  for (n = 0; n < expr1->rank; n++)\n     {\n-      for (n = 0; n < expr1->rank; n++)\n-\t{\n-\t  /* First check the lbounds.  */\n-\t  dim = rss->data.info.dim[n];\n-\t  lbd = get_std_lbound (expr2, desc2, dim,\n-\t\t\t\tas->type == AS_ASSUMED_SIZE);\n-\t  lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[n]);\n-\t  cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t  boolean_type_node, lbd, lbound);\n-\t  tmp = build3_v (COND_EXPR, cond,\n-\t\t\t  build1_v (GOTO_EXPR, jump_label1),\n-\t\t\t  build_empty_stmt (input_location));\n-\t  gfc_add_expr_to_block (&fblock, tmp);\n+      /* Check the shape.  */\n+      lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[n]);\n+      ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[n]);\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     loop->to[n], loop->from[n]);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     tmp, lbound);\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     tmp, ubound);\n+      cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t      boolean_type_node,\n+\t\t\t      tmp, gfc_index_zero_node);\n+      tmp = build3_v (COND_EXPR, cond,\n+\t\t      build1_v (GOTO_EXPR, jump_label1),\n+\t\t      build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&fblock, tmp);\t  \n+    }\n+\n+  /* ....else jump past the (re)alloc code.  */\n+  tmp = build1_v (GOTO_EXPR, jump_label2);\n+  gfc_add_expr_to_block (&fblock, tmp);\n+    \n+  /* Add the label to start automatic (re)allocation.  */\n+  tmp = build1_v (LABEL_EXPR, jump_label1);\n+  gfc_add_expr_to_block (&fblock, tmp);\n \n-\t  /* Now check the shape.  */\n-\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t gfc_array_index_type,\n-\t\t\t\t loop->to[n], loop->from[n]);\n-\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t gfc_array_index_type,\n-\t\t\t\t tmp, lbound);\n-\t  ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[n]);\n-\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t gfc_array_index_type,\n-\t\t\t\t tmp, ubound);\n-\t  cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t  boolean_type_node,\n-\t\t\t\t  tmp, gfc_index_zero_node);\n-\t  tmp = build3_v (COND_EXPR, cond,\n-\t\t\t  build1_v (GOTO_EXPR, jump_label1),\n-\t\t\t  build_empty_stmt (input_location));\n-\t  gfc_add_expr_to_block (&fblock, tmp);\t  \n-\t}\n+  size1 = gfc_conv_descriptor_size (desc, expr1->rank);\n+\n+  /* Get the rhs size.  Fix both sizes.  */\n+  if (expr2)\n+    desc2 = rss->data.info.descriptor;\n+  else\n+    desc2 = NULL_TREE;\n+  size2 = gfc_index_one_node;\n+  for (n = 0; n < expr2->rank; n++)\n+    {\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     loop->to[n], loop->from[n]);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n+      size2 = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t       gfc_array_index_type,\n+\t\t\t       tmp, size2);\n     }\n \n-    /* Otherwise jump past the (re)alloc code.  */\n-    tmp = build1_v (GOTO_EXPR, jump_label2);\n-    gfc_add_expr_to_block (&fblock, tmp);\n-    \n-    /* Add the label to start automatic (re)allocation.  */\n-    tmp = build1_v (LABEL_EXPR, jump_label1);\n-    gfc_add_expr_to_block (&fblock, tmp);\n+  size1 = gfc_evaluate_now (size1, &fblock);\n+  size2 = gfc_evaluate_now (size2, &fblock);\n+\n+  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t  size1, size2);\n+  neq_size = gfc_evaluate_now (cond, &fblock);\n+\n \n   /* Now modify the lhs descriptor and the associated scalarizer\n-     variables.\n-     7.4.1.3: If variable is or becomes an unallocated allocatable\n-     variable, then it is allocated with each deferred type parameter\n-     equal to the corresponding type parameters of expr , with the\n-     shape of expr , and with each lower bound equal to the\n-     corresponding element of LBOUND(expr).  */\n+     variables. F2003 7.4.1.3: \"If variable is or becomes an\n+     unallocated allocatable variable, then it is allocated with each\n+     deferred type parameter equal to the corresponding type parameters\n+     of expr , with the shape of expr , and with each lower bound equal\n+     to the corresponding element of LBOUND(expr).\"  \n+     Reuse size1 to keep a dimension-by-dimension track of the\n+     stride of the new array.  */\n   size1 = gfc_index_one_node;\n   offset = gfc_index_zero_node;\n "}, {"sha": "6a57865e26d42b7a7e614e537f75277e6f7c73a7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c3bf479df17e661b0e867696981565481701a0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c3bf479df17e661b0e867696981565481701a0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=93c3bf479df17e661b0e867696981565481701a0", "patch": "@@ -1,3 +1,9 @@\n+2011-01-11  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/47051\n+\t* gfortran.dg/realloc_on_assign_2.f03 : Modify 'test1' to be\n+\tstandard compliant and comment.\n+\n 2011-01-10  Jan Hubicka  <jh@suse.cz>\n \n \tPR lto/46083"}, {"sha": "e30911026972772a10b79c0e701840fd61e93edf", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_2.f03", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c3bf479df17e661b0e867696981565481701a0/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c3bf479df17e661b0e867696981565481701a0/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_2.f03?ref=93c3bf479df17e661b0e867696981565481701a0", "patch": "@@ -3,6 +3,7 @@\n ! reallocation of allocatable arrays on assignment.  The tests\n ! below were generated in the final stages of the development of\n ! this patch.\n+! test1 has been corrected for PR47051\n !\n ! Contributed by Dominique Dhumieres <dominiq@lps.ens.fr>\n !            and Tobias Burnus <burnus@gcc.gnu.org>\n@@ -28,14 +29,21 @@ subroutine test1\n     if (lbound (c, 1) .ne. lbound(a, 1)) call abort\n     if (ubound (c, 1) .ne. ubound(a, 1)) call abort\n     c=b\n-    if (lbound (c, 1) .ne. lbound(b, 1)) call abort\n-    if (ubound (c, 1) .ne. ubound(b, 1)) call abort\n+! 7.4.1.3 \"If variable is an allocated allocatable variable, it is\n+! deallocated if expr is an array of different shape or any of the\n+! corresponding length type parameter values of variable and expr\n+! differ.\" Here the shape is the same so the deallocation does not\n+! occur and the bounds are not recalculated. This was corrected\n+! for the fix of PR47051. \n+    if (lbound (c, 1) .ne. lbound(a, 1)) call abort\n+    if (ubound (c, 1) .ne. ubound(a, 1)) call abort\n     d=b\n     if (lbound (d, 1) .ne. lbound(b, 1)) call abort\n     if (ubound (d, 1) .ne. ubound(b, 1)) call abort\n     d=a\n-    if (lbound (d, 1) .ne. lbound(a, 1)) call abort\n-    if (ubound (d, 1) .ne. ubound(a, 1)) call abort\n+! The other PR47051 correction.\n+    if (lbound (d, 1) .ne. lbound(b, 1)) call abort\n+    if (ubound (d, 1) .ne. ubound(b, 1)) call abort\n   end subroutine\n   subroutine test2\n !"}]}