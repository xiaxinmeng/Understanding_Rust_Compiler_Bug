{"sha": "5aabc487d3bd2d6c973c0b18edba58267b623c3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFhYmM0ODdkM2JkMmQ2Yzk3M2MwYjE4ZWRiYTU4MjY3YjYyM2MzZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-05-28T14:52:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-05-28T14:52:46Z"}, "message": "predict.c (edge_predicted_by_p): New function.\n\n\t* predict.c (edge_predicted_by_p): New function.\n\t(predict_paths_for_bb): Do not put multiple predictions of the same type\n\ton one edge.\n\nFrom-SVN: r236848", "tree": {"sha": "cda2da680f59be1be71bb82a043b341eb9bbc379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cda2da680f59be1be71bb82a043b341eb9bbc379"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5aabc487d3bd2d6c973c0b18edba58267b623c3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aabc487d3bd2d6c973c0b18edba58267b623c3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aabc487d3bd2d6c973c0b18edba58267b623c3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aabc487d3bd2d6c973c0b18edba58267b623c3d/comments", "author": null, "committer": null, "parents": [{"sha": "018b22f3316ae73a57c0c19f7598b34afac954f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/018b22f3316ae73a57c0c19f7598b34afac954f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/018b22f3316ae73a57c0c19f7598b34afac954f7"}], "stats": {"total": 36, "additions": 35, "deletions": 1}, "files": [{"sha": "3a75b8034e2cdf5f9e753ad9bf4009502c503131", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aabc487d3bd2d6c973c0b18edba58267b623c3d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aabc487d3bd2d6c973c0b18edba58267b623c3d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5aabc487d3bd2d6c973c0b18edba58267b623c3d", "patch": "@@ -1,3 +1,9 @@\n+2016-05-27  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* predict.c (edge_predicted_by_p): New function.\n+\t(predict_paths_for_bb): Do not put multiple predictions of the same type\n+\ton one edge.\n+\n 2016-05-27  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree-ssa-loop-niter.c (number_of_iterations_exit): Revert accidental"}, {"sha": "22ec8a053a015669752a5e7b98fb7ee826010564", "filename": "gcc/predict.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aabc487d3bd2d6c973c0b18edba58267b623c3d/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aabc487d3bd2d6c973c0b18edba58267b623c3d/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=5aabc487d3bd2d6c973c0b18edba58267b623c3d", "patch": "@@ -478,6 +478,31 @@ gimple_predicted_by_p (const_basic_block bb, enum br_predictor predictor)\n   return false;\n }\n \n+/* Return true if the one of outgoing edges is already predicted by\n+   PREDICTOR for edge E predicted as TAKEN.  */\n+\n+bool\n+edge_predicted_by_p (edge e, enum br_predictor predictor, bool taken)\n+{\n+  struct edge_prediction *i;\n+  basic_block bb = e->src;\n+  edge_prediction **preds = bb_predictions->get (bb);\n+  if (!preds)\n+    return false;\n+\n+  int probability = predictor_info[(int) predictor].hitrate;\n+\n+  if (taken != TAKEN)\n+    probability = REG_BR_PROB_BASE - probability;\n+\n+  for (i = *preds; i; i = i->ep_next)\n+    if (i->ep_predictor == predictor\n+\t&& i->ep_edge == e\n+\t&& i->ep_probability == probability)\n+      return true;\n+  return false;\n+}\n+\n /* Return true when the probability of edge is reliable.\n \n    The profile guessing code is good at predicting branch outcome (ie.\n@@ -2415,7 +2440,10 @@ predict_paths_for_bb (basic_block cur, basic_block bb,\n \t regions that are only reachable by abnormal edges.  We simply\n \t prevent visiting given BB twice.  */\n       if (found)\n-        predict_edge_def (e, pred, taken);\n+\t{\n+\t  if (!edge_predicted_by_p (e, pred, taken))\n+            predict_edge_def (e, pred, taken);\n+\t}\n       else if (bitmap_set_bit (visited, e->src->index))\n \tpredict_paths_for_bb (e->src, e->src, pred, taken, visited);\n     }"}]}