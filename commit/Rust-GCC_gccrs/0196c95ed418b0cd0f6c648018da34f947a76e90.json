{"sha": "0196c95ed418b0cd0f6c648018da34f947a76e90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE5NmM5NWVkNDE4YjBjZDBmNmM2NDgwMThkYTM0Zjk0N2E3NmU5MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-01-15T08:07:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-01-15T08:07:38Z"}, "message": "re PR rtl-optimization/38245 (stack corruption when a call is removed but not the outgoing argument pushes)\n\n\tPR rtl-optimization/38245\n\t* calls.c (expand_call): Add stack arguments to\n\tCALL_INSN_FUNCTION_USAGE even for pure calls (when\n\tACCUMULATE_OUTGOING_ARGS) and even for args partially passed\n\tin regs and partially in memory or BLKmode arguments.\n\t(emit_library_call_value_1): Add stack arguments to\n\tCALL_INSN_FUNCTION_USAGE even for pure calls (when\n\tACCUMULATE_OUTGOING_ARGS).\n\t* dce.c: Include tm_p.h.\n\t(find_call_stack_args): New function.\n\t(deletable_insn_p): Call it for CALL_P insns.  Add ARG_STORES\n\targument.\n\t(mark_insn): Call find_call_stack_args for CALL_Ps.\n\t(prescan_insns_for_dce): Walk insns backwards in bb rather than\n\tforwards.  Allocate and free arg_stores bitmap if needed, pass it\n\tdown to deletable_insn_p, don't mark stores set in arg_stores\n\tbitmap, clear the bitmap at the beginning of each bb.\n\t* Makefile.in (dce.o): Depend on $(TM_P_H).\n\n\t* gcc.dg/pr38245-3.c: New test.\n\t* gcc.dg/pr38245-3.h: New file.\n\t* gcc.dg/pr38245-4.c: New file.\n\t* gcc.dg/pr38364.c: New test.\n\nFrom-SVN: r143387", "tree": {"sha": "df30f7de379a5cadc80eb495456de5a3b9f9d10b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df30f7de379a5cadc80eb495456de5a3b9f9d10b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0196c95ed418b0cd0f6c648018da34f947a76e90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0196c95ed418b0cd0f6c648018da34f947a76e90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0196c95ed418b0cd0f6c648018da34f947a76e90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0196c95ed418b0cd0f6c648018da34f947a76e90/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6df6bcfa0fde9cc6413088d609f799188444f51b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df6bcfa0fde9cc6413088d609f799188444f51b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6df6bcfa0fde9cc6413088d609f799188444f51b"}], "stats": {"total": 715, "additions": 678, "deletions": 37}, "files": [{"sha": "aeab680011ba311667c1dab8767828a2d730d1ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0196c95ed418b0cd0f6c648018da34f947a76e90", "patch": "@@ -1,3 +1,24 @@\n+2009-01-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/38245\n+\t* calls.c (expand_call): Add stack arguments to\n+\tCALL_INSN_FUNCTION_USAGE even for pure calls (when\n+\tACCUMULATE_OUTGOING_ARGS) and even for args partially passed\n+\tin regs and partially in memory or BLKmode arguments.\n+\t(emit_library_call_value_1): Add stack arguments to\n+\tCALL_INSN_FUNCTION_USAGE even for pure calls (when\n+\tACCUMULATE_OUTGOING_ARGS).\n+\t* dce.c: Include tm_p.h.\n+\t(find_call_stack_args): New function.\n+\t(deletable_insn_p): Call it for CALL_P insns.  Add ARG_STORES\n+\targument.\n+\t(mark_insn): Call find_call_stack_args for CALL_Ps.\n+\t(prescan_insns_for_dce): Walk insns backwards in bb rather than\n+\tforwards.  Allocate and free arg_stores bitmap if needed, pass it\n+\tdown to deletable_insn_p, don't mark stores set in arg_stores\n+\tbitmap, clear the bitmap at the beginning of each bb.\n+\t* Makefile.in (dce.o): Depend on $(TM_P_H).\n+\n 2009-01-14  Michael Meissner  <gnu@the-meissners.org>\n \n \tPR target/22599"}, {"sha": "2190d437eb1367fba684499e6d5a0dc80bcca9fe", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0196c95ed418b0cd0f6c648018da34f947a76e90", "patch": "@@ -2672,7 +2672,7 @@ cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    $(DF_H) $(DBGCNT_H)\n dce.o : dce.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) $(DF_H) cselib.h \\\n-   $(DBGCNT_H) dce.h $(TIMEVAR_H) tree-pass.h $(DBGCNT_H)\n+   $(DBGCNT_H) dce.h $(TIMEVAR_H) tree-pass.h $(DBGCNT_H) $(TM_P_H)\n dse.o : dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(TM_P_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(RECOG_H) $(EXPR_H) $(DF_H) cselib.h $(DBGCNT_H) $(TIMEVAR_H) tree-pass.h \\"}, {"sha": "a75e3b36569877d66540448e47ae989b57511a34", "filename": "gcc/calls.c", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=0196c95ed418b0cd0f6c648018da34f947a76e90", "patch": "@@ -1,6 +1,6 @@\n /* Convert function calls to rtl insns, for GNU C compiler.\n    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -2705,26 +2705,28 @@ expand_call (tree exp, rtx target, int ignore)\n \t but we do preallocate space here if they want that.  */\n \n       for (i = 0; i < num_actuals; i++)\n-\tif (args[i].reg == 0 || args[i].pass_on_stack)\n-\t  {\n-\t    rtx before_arg = get_last_insn ();\n-\n-\t    if (store_one_arg (&args[i], argblock, flags,\n-\t\t\t       adjusted_args_size.var != 0,\n-\t\t\t       reg_parm_stack_space)\n-\t\t|| (pass == 0\n-\t\t    && check_sibcall_argument_overlap (before_arg,\n-\t\t\t\t\t\t       &args[i], 1)))\n-\t      sibcall_failure = 1;\n-\n-\t    if (flags & ECF_CONST\n-\t\t&& args[i].stack\n-\t\t&& args[i].value == args[i].stack)\n-\t      call_fusage = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       gen_rtx_USE (VOIDmode,\n-\t\t\t\t\t\t\t    args[i].value),\n-\t\t\t\t\t       call_fusage);\n-\t  }\n+\t{\n+\t  if (args[i].reg == 0 || args[i].pass_on_stack)\n+\t    {\n+\t      rtx before_arg = get_last_insn ();\n+\n+\t      if (store_one_arg (&args[i], argblock, flags,\n+\t\t\t\t adjusted_args_size.var != 0,\n+\t\t\t\t reg_parm_stack_space)\n+\t\t  || (pass == 0\n+\t\t      && check_sibcall_argument_overlap (before_arg,\n+\t\t\t\t\t\t\t &args[i], 1)))\n+\t\tsibcall_failure = 1;\n+\t      }\n+\n+\t  if (((flags & ECF_CONST)\n+\t       || ((flags & ECF_PURE) && ACCUMULATE_OUTGOING_ARGS))\n+\t      && args[i].stack)\n+\t    call_fusage = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t     gen_rtx_USE (VOIDmode,\n+\t\t\t\t\t\t\t  args[i].stack),\n+\t\t\t\t\t     call_fusage);\n+\t}\n \n       /* If we have a parm that is passed in registers but not in memory\n \t and whose alignment does not permit a direct copy into registers,\n@@ -3672,7 +3674,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n \t  NO_DEFER_POP;\n \n-\t  if (flags & ECF_CONST)\n+\t  if ((flags & ECF_CONST)\n+\t      || ((flags & ECF_PURE) && ACCUMULATE_OUTGOING_ARGS))\n \t    {\n \t      rtx use;\n "}, {"sha": "75e148cf434151d20bda20f5f69a8380789d8ad5", "filename": "gcc/dce.c", "status": "modified", "additions": 290, "deletions": 14, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=0196c95ed418b0cd0f6c648018da34f947a76e90", "patch": "@@ -1,5 +1,5 @@\n /* RTL dead code elimination.\n-   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n+#include \"tm_p.h\"\n \n DEF_VEC_I(int);\n DEF_VEC_ALLOC_I(int,heap);\n@@ -57,6 +58,7 @@ static sbitmap marked;\n static bitmap_obstack dce_blocks_bitmap_obstack;\n static bitmap_obstack dce_tmp_bitmap_obstack;\n \n+static bool find_call_stack_args (rtx, bool, bool, bitmap);\n \n /* A subroutine for which BODY is part of the instruction being tested;\n    either the top-level pattern, or an element of a PARALLEL.  The\n@@ -94,7 +96,7 @@ deletable_insn_p_1 (rtx body)\n    the DCE pass.  */\n \n static bool\n-deletable_insn_p (rtx insn, bool fast)\n+deletable_insn_p (rtx insn, bool fast, bitmap arg_stores)\n {\n   rtx body, x;\n   int i;\n@@ -111,7 +113,7 @@ deletable_insn_p (rtx insn, bool fast)\n          infinite loop.  */\n       && (RTL_CONST_OR_PURE_CALL_P (insn)\n \t  && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn)))\n-    return true;\n+    return find_call_stack_args (insn, false, fast, arg_stores);\n \n   if (!NONJUMP_INSN_P (insn))\n     return false;\n@@ -174,6 +176,12 @@ mark_insn (rtx insn, bool fast)\n       SET_BIT (marked, INSN_UID (insn));\n       if (dump_file)\n \tfprintf (dump_file, \"  Adding insn %d to worklist\\n\", INSN_UID (insn));\n+      if (CALL_P (insn)\n+\t  && !df_in_progress\n+\t  && !SIBLING_CALL_P (insn)\n+\t  && (RTL_CONST_OR_PURE_CALL_P (insn)\n+\t      && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn)))\n+\tfind_call_stack_args (insn, true, fast, NULL);\n     }\n }\n \n@@ -212,6 +220,254 @@ mark_nonreg_stores (rtx body, rtx insn, bool fast)\n }\n \n \n+/* Try to find all stack stores of CALL_INSN arguments if\n+   ACCUMULATE_OUTGOING_ARGS.  If all stack stores have been found\n+   and it is therefore safe to eliminate the call, return true,\n+   otherwise return false.  This function should be first called\n+   with DO_MARK false, and only when the CALL_INSN is actually\n+   going to be marked called again with DO_MARK true.  */\n+\n+static bool\n+find_call_stack_args (rtx call_insn, bool do_mark, bool fast,\n+\t\t      bitmap arg_stores)\n+{\n+  rtx p, insn, prev_insn;\n+  bool ret;\n+  HOST_WIDE_INT min_sp_off, max_sp_off;\n+  bitmap sp_bytes;\n+\n+  gcc_assert (CALL_P (call_insn));\n+  if (!ACCUMULATE_OUTGOING_ARGS)\n+    return true;\n+\n+  if (!do_mark)\n+    {\n+      gcc_assert (arg_stores);\n+      bitmap_clear (arg_stores);\n+    }\n+\n+  min_sp_off = INTTYPE_MAXIMUM (HOST_WIDE_INT);\n+  max_sp_off = 0;\n+\n+  /* First determine the minimum and maximum offset from sp for\n+     stored arguments.  */\n+  for (p = CALL_INSN_FUNCTION_USAGE (call_insn); p; p = XEXP (p, 1))\n+    if (GET_CODE (XEXP (p, 0)) == USE\n+\t&& MEM_P (XEXP (XEXP (p, 0), 0)))\n+      {\n+\trtx mem = XEXP (XEXP (p, 0), 0), addr, size;\n+\tHOST_WIDE_INT off = 0;\n+\tsize = MEM_SIZE (mem);\n+\tif (size == NULL_RTX)\n+\t  return false;\n+\taddr = XEXP (mem, 0);\n+\tif (GET_CODE (addr) == PLUS\n+\t    && REG_P (XEXP (addr, 0))\n+\t    && CONST_INT_P (XEXP (addr, 1)))\n+\t  {\n+\t    off = INTVAL (XEXP (addr, 1));\n+\t    addr = XEXP (addr, 0);\n+\t  }\n+\tif (addr != stack_pointer_rtx)\n+\t  {\n+\t    if (!REG_P (addr))\n+\t      return false;\n+\t    /* If not fast, use chains to see if addr wasn't set to\n+\t       sp + offset.  */\n+\t    if (!fast)\n+\t      {\n+\t\tdf_ref *use_rec;\n+\t\tstruct df_link *defs;\n+\t\trtx set;\n+\n+\t\tfor (use_rec = DF_INSN_USES (call_insn); *use_rec; use_rec++)\n+\t\t  if (rtx_equal_p (addr, DF_REF_REG (*use_rec)))\n+\t\t    break;\n+\n+\t\tif (*use_rec == NULL)\n+\t\t  return false;\n+\n+\t\tfor (defs = DF_REF_CHAIN (*use_rec); defs; defs = defs->next)\n+\t\t  if (! DF_REF_IS_ARTIFICIAL (defs->ref))\n+\t\t    break;\n+\n+\t\tif (defs == NULL)\n+\t\t  return false;\n+\n+\t\tset = single_set (DF_REF_INSN (defs->ref));\n+\t\tif (!set)\n+\t\t  return false;\n+\n+\t\tif (GET_CODE (SET_SRC (set)) != PLUS\n+\t\t    || XEXP (SET_SRC (set), 0) != stack_pointer_rtx\n+\t\t    || !CONST_INT_P (XEXP (SET_SRC (set), 1)))\n+\t\t  return false;\n+\n+\t\toff += INTVAL (XEXP (SET_SRC (set), 1));\n+\t      }\n+\t    else\n+\t      return false;\n+\t  }\n+\tmin_sp_off = MIN (min_sp_off, off);\n+\tmax_sp_off = MAX (max_sp_off, off + INTVAL (size));\n+      }\n+\n+  if (min_sp_off >= max_sp_off)\n+    return true;\n+  sp_bytes = BITMAP_ALLOC (NULL);\n+\n+  /* Set bits in SP_BYTES bitmap for bytes relative to sp + min_sp_off\n+     which contain arguments.  Checking has been done in the previous\n+     loop.  */\n+  for (p = CALL_INSN_FUNCTION_USAGE (call_insn); p; p = XEXP (p, 1))\n+    if (GET_CODE (XEXP (p, 0)) == USE\n+\t&& MEM_P (XEXP (XEXP (p, 0), 0)))\n+      {\n+\trtx mem = XEXP (XEXP (p, 0), 0), addr;\n+\tHOST_WIDE_INT off = 0, byte;\n+\taddr = XEXP (mem, 0);\n+\tif (GET_CODE (addr) == PLUS\n+\t    && REG_P (XEXP (addr, 0))\n+\t    && CONST_INT_P (XEXP (addr, 1)))\n+\t  {\n+\t    off = INTVAL (XEXP (addr, 1));\n+\t    addr = XEXP (addr, 0);\n+\t  }\n+\tif (addr != stack_pointer_rtx)\n+\t  {\n+\t    df_ref *use_rec;\n+\t    struct df_link *defs;\n+\t    rtx set;\n+\n+\t    for (use_rec = DF_INSN_USES (call_insn); *use_rec; use_rec++)\n+\t      if (rtx_equal_p (addr, DF_REF_REG (*use_rec)))\n+\t\tbreak;\n+\n+\t    for (defs = DF_REF_CHAIN (*use_rec); defs; defs = defs->next)\n+\t      if (! DF_REF_IS_ARTIFICIAL (defs->ref))\n+\t\tbreak;\n+\n+\t    set = single_set (DF_REF_INSN (defs->ref));\n+\t    off += INTVAL (XEXP (SET_SRC (set), 1));\n+\t  }\n+\tfor (byte = off; byte < off + INTVAL (MEM_SIZE (mem)); byte++)\n+\t  {\n+\t    gcc_assert (!bitmap_bit_p (sp_bytes, byte - min_sp_off));\n+\t    bitmap_set_bit (sp_bytes, byte - min_sp_off);\n+\t  }\n+      }\n+\n+  /* Walk backwards, looking for argument stores.  The search stops\n+     when seeting another call, sp adjustment or memory store other than\n+     argument store.  */\n+  ret = false;\n+  for (insn = PREV_INSN (call_insn); insn; insn = prev_insn)\n+    {\n+      rtx set, mem, addr;\n+      HOST_WIDE_INT off, byte;\n+\n+      if (insn == BB_HEAD (BLOCK_FOR_INSN (call_insn)))\n+\tprev_insn = NULL_RTX;\n+      else\n+\tprev_insn = PREV_INSN (insn);\n+\n+      if (CALL_P (insn))\n+\tbreak;\n+\n+      if (!INSN_P (insn))\n+\tcontinue;\n+\n+      set = single_set (insn);\n+      if (!set || SET_DEST (set) == stack_pointer_rtx)\n+\tbreak;\n+\n+      if (!MEM_P (SET_DEST (set)))\n+\tcontinue;\n+\n+      mem = SET_DEST (set);\n+      addr = XEXP (mem, 0);\n+      off = 0;\n+      if (GET_CODE (addr) == PLUS\n+\t  && REG_P (XEXP (addr, 0))\n+\t  && CONST_INT_P (XEXP (addr, 1)))\n+\t{\n+\t  off = INTVAL (XEXP (addr, 1));\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      if (addr != stack_pointer_rtx)\n+\t{\n+\t  if (!REG_P (addr))\n+\t    break;\n+\t  if (!fast)\n+\t    {\n+\t      df_ref *use_rec;\n+\t      struct df_link *defs;\n+\t      rtx set;\n+\n+\t      for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+\t\tif (rtx_equal_p (addr, DF_REF_REG (*use_rec)))\n+\t\t  break;\n+\n+\t      if (*use_rec == NULL)\n+\t\tbreak;\n+\n+\t      for (defs = DF_REF_CHAIN (*use_rec); defs; defs = defs->next)\n+\t\tif (! DF_REF_IS_ARTIFICIAL (defs->ref))\n+\t\t  break;\n+\n+\t      if (defs == NULL)\n+\t\tbreak;\n+\n+\t      set = single_set (DF_REF_INSN (defs->ref));\n+\t      if (!set)\n+\t\tbreak;\n+\n+\t      if (GET_CODE (SET_SRC (set)) != PLUS\n+\t\t  || XEXP (SET_SRC (set), 0) != stack_pointer_rtx\n+\t\t  || !CONST_INT_P (XEXP (SET_SRC (set), 1)))\n+\t\tbreak;\n+\n+\t      off += INTVAL (XEXP (SET_SRC (set), 1));\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n+\n+      if (GET_MODE_SIZE (GET_MODE (mem)) == 0)\n+\tbreak;\n+\n+      for (byte = off; byte < off + GET_MODE_SIZE (GET_MODE (mem)); byte++)\n+\t{\n+\t  if (byte < min_sp_off\n+\t      || byte >= max_sp_off\n+\t      || !bitmap_bit_p (sp_bytes, byte - min_sp_off))\n+\t    break;\n+\t  bitmap_clear_bit (sp_bytes, byte - min_sp_off);\n+\t}\n+\n+      if (!deletable_insn_p (insn, fast, NULL))\n+\tbreak;\n+\n+      if (do_mark)\n+\tmark_insn (insn, fast);\n+      else\n+\tbitmap_set_bit (arg_stores, INSN_UID (insn));\n+\n+      if (bitmap_empty_p (sp_bytes))\n+\t{\n+\t  ret = true;\n+\t  break;\n+\t}\n+    }\n+\n+  BITMAP_FREE (sp_bytes);\n+  if (!ret && arg_stores)\n+    bitmap_clear (arg_stores);\n+\n+  return ret;\n+}\n+\n+\n /* Delete all REG_EQUAL notes of the registers INSN writes, to prevent\n    bad dangling REG_EQUAL notes. */\n \n@@ -266,6 +522,9 @@ delete_unmarked_insns (void)\n \t  else if (marked_insn_p (insn))\n \t    continue;\n \n+\t  /* Beware that reaching a dbg counter limit here can easily result\n+\t     in miscompiled file, whenever some insn is eliminated, but\n+\t     insn that depends on it is not.  */\n \t  if (!dbg_cnt (dce))\n \t    continue;\n \n@@ -300,20 +559,37 @@ static void\n prescan_insns_for_dce (bool fast)\n {\n   basic_block bb;\n-  rtx insn, next;\n-  \n+  rtx insn, prev;\n+  bitmap arg_stores = NULL;\n+\n   if (dump_file)\n     fprintf (dump_file, \"Finding needed instructions:\\n\");\n-  \n+\n+  if (!df_in_progress && ACCUMULATE_OUTGOING_ARGS)\n+    arg_stores = BITMAP_ALLOC (NULL);\n+\n   FOR_EACH_BB (bb)\n-    FOR_BB_INSNS_SAFE (bb, insn, next)\n-      if (INSN_P (insn))\n-\t{\n-\t  if (deletable_insn_p (insn, fast))\n-\t    mark_nonreg_stores (PATTERN (insn), insn, fast);\n-\t  else\n-\t    mark_insn (insn, fast);\n-\t}\n+    {\n+      FOR_BB_INSNS_REVERSE_SAFE (bb, insn, prev)\n+\tif (INSN_P (insn))\n+\t  {\n+\t    /* Don't mark argument stores now.  They will be marked\n+\t       if needed when the associated CALL is marked.  */\n+\t    if (arg_stores && bitmap_bit_p (arg_stores, INSN_UID (insn)))\n+\t      continue;\n+\t    if (deletable_insn_p (insn, fast, arg_stores))\n+\t      mark_nonreg_stores (PATTERN (insn), insn, fast);\n+\t    else\n+\t      mark_insn (insn, fast);\n+\t  }\n+      /* find_call_stack_args only looks at argument stores in the\n+\t same bb.  */\n+      if (arg_stores)\n+\tbitmap_clear (arg_stores);\n+    }\n+\n+  if (arg_stores)\n+    BITMAP_FREE (arg_stores);\n \n   if (dump_file)\n     fprintf (dump_file, \"Finished finding needed instructions:\\n\");"}, {"sha": "fae2df8f3f6dc9aeb4070bff4a342d10b6a767f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0196c95ed418b0cd0f6c648018da34f947a76e90", "patch": "@@ -1,3 +1,11 @@\n+2009-01-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/38245\n+\t* gcc.dg/pr38245-3.c: New test.\n+\t* gcc.dg/pr38245-3.h: New file.\n+\t* gcc.dg/pr38245-4.c: New file.\n+\t* gcc.dg/pr38364.c: New test.\n+\n 2009-01-14  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* gcc.target/mips/mips.exp (mips_option_tests(-mips16)): Make the"}, {"sha": "6ef8372a14f2b7ed4c2b49550864f923303781eb", "filename": "gcc/testsuite/gcc.dg/pr38245-3.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-3.c?ref=0196c95ed418b0cd0f6c648018da34f947a76e90", "patch": "@@ -0,0 +1,112 @@\n+/* PR rtl-optimization/38245 */\n+/* { dg-do run } */\n+/* { dg-additional-sources \"pr38245-4.c\" } */\n+/* { dg-options \"-O2\" } */\n+\n+#include \"pr38245-3.h\"\n+\n+extern void abort (void);\n+\n+struct A { int i, j; union { short s[4]; long long l; }; char pad[512]; } a;\n+int globv = 6;\n+\n+void __attribute__((noinline))\n+f1 (void)\n+{\n+  a.s[2] = b1 (6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n+\t       6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21);\n+  a.l = 6;\n+}\n+\n+void __attribute__((noinline))\n+f2 (void)\n+{\n+  a.s[2] = b2 (6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n+\t       6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21);\n+  a.l = 6;\n+}\n+\n+void __attribute__((noinline))\n+f3 (void)\n+{\n+  struct B b = { 30, 31, { 32, 33 } };\n+  a.s[2] = b3 (6, 7, 8, 9, 10, 11, 12, b, 14, b, 16, b, 18, 19, 20, 21,\n+\t       6, b, 8, b, 10, 11, 12, 13, 14, b, 16, b, 18, 19, 20, 21);\n+  a.l = 6;\n+}\n+\n+void __attribute__((noinline))\n+f4 (void)\n+{\n+  struct B b = { 30, 31, { 32, 33 } };\n+  a.s[2] = b4 (6, 7, 8, 9, 10, 11, 12, b, 14, b, 16, b, 18, 19, 20, 21,\n+\t       6, b, 8, b, 10, 11, 12, 13, 14, b, 16, b, 18, 19, 20, 21);\n+  a.l = 6;\n+}\n+\n+void __attribute__((noinline))\n+f5 (void)\n+{\n+  a.s[2] = b5 (6.0, 7, 8, 9, 10, 11, 21.0, 22.0, 23.0);\n+  a.l = 6;\n+}\n+\n+void __attribute__((noinline))\n+f6 (void)\n+{\n+  a.s[2] = b6 (6.0, 7, 8, 9, 10, 11, 21.0, 22.0, 23.0);\n+  a.l = 6;\n+}\n+\n+void __attribute__((noinline))\n+f7 (void)\n+{\n+  a.s[2] = b7 (6, 7);\n+  a.l = 6;\n+}\n+\n+void __attribute__((noinline))\n+f8 (void)\n+{\n+  a.s[2] = b8 (6, 7);\n+  a.l = 6;\n+}\n+\n+void __attribute__((noinline))\n+f9 (void)\n+{\n+  a.s[2] = b9 (6, 7, 8, 9, 10, 11, 12);\n+  a.l = 6;\n+}\n+\n+void __attribute__((noinline))\n+f10 (void)\n+{\n+  a.s[2] = b10 (6, 7, 8, 9, 10, 11, 12);\n+  a.l = 6;\n+}\n+\n+int\n+main (void)\n+{\n+  char buf[256];\n+  int i;\n+  for (i = 0; i < (int) sizeof buf; i++)\n+    buf[i] = i;\n+  asm volatile (\"\" : : \"r\" (buf) : \"memory\");\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+  f4 ();\n+  f5 ();\n+  f6 ();\n+  f7 ();\n+  f8 ();\n+  f9 ();\n+  f10 ();\n+  asm volatile (\"\" : : \"r\" (buf) : \"memory\");\n+  for (i = 0; i < (int) sizeof buf; i++)\n+    if (buf[i] != (char) i)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "b1c2a0f67c218ab5290ee962981d1197b08e28af", "filename": "gcc/testsuite/gcc.dg/pr38245-3.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-3.h?ref=0196c95ed418b0cd0f6c648018da34f947a76e90", "patch": "@@ -0,0 +1,35 @@\n+/* PR rtl-optimization/38245 */\n+\n+struct B { long a, b; char p[32]; };\n+extern int globv;\n+\n+extern int b1 (long long, long, long, long, long, long, long, long,\n+\t       long long, long, long, long, long, long, long, long,\n+\t       long long, long, long, long, long, long, long, long,\n+\t       long long, long, long, long, long, long, long, long)\n+     __attribute__((pure, noinline));\n+extern int b2 (long long, long, long, long, long, long, long, long,\n+\t       long long, long, long, long, long, long, long, long,\n+\t       long long, long, long, long, long, long, long, long,\n+\t       long long, long, long, long, long, long, long, long)\n+     __attribute__((const, noinline));\n+extern int b3 (long long, long, long, long, long, long, long, struct B,\n+\t       long long, struct B, long, struct B, long, long, long, long,\n+\t       long long, struct B, long, struct B, long, long, long, long,\n+\t       long long, struct B, long, struct B, long, long, long, long)\n+     __attribute__((pure, noinline));\n+extern int b4 (long long, long, long, long, long, long, long, struct B,\n+\t       long long, struct B, long, struct B, long, long, long, long,\n+\t       long long, struct B, long, struct B, long, long, long, long,\n+\t       long long, struct B, long, struct B, long, long, long, long)\n+     __attribute__((const, noinline));\n+extern int b5 () __attribute__((pure, noinline));\n+extern int b6 () __attribute__((const, noinline));\n+extern int b7 (int, int)\n+     __attribute__((pure, noinline));\n+extern int b8 (int, int)\n+     __attribute__((const, noinline));\n+extern int b9 (int, int, int, int, int, int, int)\n+     __attribute__((pure, noinline));\n+extern int b10 (int, int, int, int, int, int, int)\n+     __attribute__((const, noinline));"}, {"sha": "c9b3d2d8fb81e9028de8b44b8a5479708a8530aa", "filename": "gcc/testsuite/gcc.dg/pr38245-4.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-4.c?ref=0196c95ed418b0cd0f6c648018da34f947a76e90", "patch": "@@ -0,0 +1,107 @@\n+/* PR rtl-optimization/38245 */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+#include \"pr38245-3.h\"\n+\n+int\n+b1 (long long a1, long a2, long a3, long a4,\n+    long a5, long a6, long a7, long a8,\n+    long long a9, long a10, long a11, long a12,\n+    long a13, long a14, long a15, long a16,\n+    long long a17, long a18, long a19, long a20,\n+    long a21, long a22, long a23, long a24,\n+    long long a25, long a26, long a27, long a28,\n+    long a29, long a30, long a31, long a32)\n+{\n+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10\n+\t + a11 + a12 + a13 + a14 + a15 + a16 + a17 + a18 + a19 + a20\n+\t + a21 + a22 + a23 + a24 + a25 + a26 + a27 + a28 + a29 + a30\n+\t + a31 + a32 + globv;\n+}\n+\n+int\n+b2 (long long a1, long a2, long a3, long a4,\n+    long a5, long a6, long a7, long a8,\n+    long long a9, long a10, long a11, long a12,\n+    long a13, long a14, long a15, long a16,\n+    long long a17, long a18, long a19, long a20,\n+    long a21, long a22, long a23, long a24,\n+    long long a25, long a26, long a27, long a28,\n+    long a29, long a30, long a31, long a32)\n+{\n+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10\n+\t + a11 + a12 + a13 + a14 + a15 + a16 + a17 + a18 + a19 + a20\n+\t + a21 + a22 + a23 + a24 + a25 + a26 + a27 + a28 + a29 + a30\n+\t + a31 + a32;\n+}\n+\n+int\n+b3 (long long a1, long a2, long a3, long a4,\n+    long a5, long a6, long a7, struct B a8,\n+    long long a9, struct B a10, long a11, struct B a12,\n+    long a13, long a14, long a15, long a16,\n+    long long a17, struct B a18, long a19, struct B a20,\n+    long a21, long a22, long a23, long a24,\n+    long long a25, struct B a26, long a27, struct B a28,\n+    long a29, long a30, long a31, long a32)\n+{\n+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8.a + a9 + a10.a\n+\t + a11 + a12.a + a13 + a14 + a15 + a16 + a17 + a18.a + a19 + a20.a\n+\t + a21 + a22 + a23 + a24 + a25 + a26.a + a27 + a28.a + a29 + a30\n+\t + a31 + a32 + globv;\n+}\n+\n+int\n+b4 (long long a1, long a2, long a3, long a4,\n+    long a5, long a6, long a7, struct B a8,\n+    long long a9, struct B a10, long a11, struct B a12,\n+    long a13, long a14, long a15, long a16,\n+    long long a17, struct B a18, long a19, struct B a20,\n+    long a21, long a22, long a23, long a24,\n+    long long a25, struct B a26, long a27, struct B a28,\n+    long a29, long a30, long a31, long a32)\n+{\n+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8.a + a9 + a10.a\n+\t + a11 + a12.a + a13 + a14 + a15 + a16 + a17 + a18.a + a19 + a20.a\n+\t + a21 + a22 + a23 + a24 + a25 + a26.a + a27 + a28.a + a29 + a30\n+\t + a31 + a32;\n+}\n+\n+int\n+b5 (double a1, int a2, int a3, int a4, int a5, int a6, double a7,\n+    double a8, double a9)\n+{\n+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + globv;\n+}\n+\n+int\n+b6 (double a1, int a2, int a3, int a4, int a5, int a6, double a7,\n+    double a8, double a9)\n+{\n+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9;\n+}\n+\n+int\n+b7 (int a1, int a2)\n+{\n+  return a1 + a2 + globv;\n+}\n+\n+int\n+b8 (int a1, int a2)\n+{\n+  return a1 + a2;\n+}\n+\n+int\n+b9 (int a1, int a2, int a3, int a4, int a5, int a6, int a7)\n+{\n+  return a1 + a2 + a3 + a4 + a5 + a6 + a7 + globv;\n+}\n+\n+int\n+b10 (int a1, int a2, int a3, int a4, int a5, int a6, int a7)\n+{\n+  return a1 + a2 + a3 + a4 + a5 + a6 + a7;\n+}"}, {"sha": "23f72de74ee41cf07bc2be681e841967f87af2b6", "filename": "gcc/testsuite/gcc.dg/pr38364.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38364.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0196c95ed418b0cd0f6c648018da34f947a76e90/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38364.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38364.c?ref=0196c95ed418b0cd0f6c648018da34f947a76e90", "patch": "@@ -0,0 +1,79 @@\n+/* PR middle-end/38364 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftrapv\" } */\n+\n+extern void abort (void);\n+\n+static inline short\n+f1 (short x, short y)\n+{\n+  if (x > 0)\n+    {\n+      if (y > 0)\n+\t{\n+\t  if (x > __SHRT_MAX__ / y)\n+\t    return x;\n+\t}\n+      else if (y < (-__SHRT_MAX__ - 1) / x)\n+\treturn x;\n+    }\n+  else\n+    {\n+      if (y > 0)\n+\t{\n+\t  if (x < (-__SHRT_MAX__ - 1) / y)\n+\t    return x;\n+\t}\n+      else if (x != 0 && y < __SHRT_MAX__ / x)\n+\treturn x;\n+    }\n+  return x * y;\n+}\n+\n+static inline signed char\n+f2 (signed char x, signed char y)\n+{\n+  if (((x ^ y) & (((x ^ ((x ^ y) & (1 << (__CHAR_BIT__ - 1)))) - y) ^ y)) < 0)\n+    return x;\n+  return x - y;\n+}\n+\n+unsigned int v;\n+\n+int\n+f3 (int x, unsigned int y)\n+{\n+  f1 (1, 1);\n+  return 1;\n+}\n+\n+int\n+f4 (unsigned short x)\n+{\n+  v = x;\n+  return 1;\n+}\n+\n+int\n+f5 (int x)\n+{\n+  if (f2 (x, 1))\n+    f1 (1, f4 (1));\n+  return x;\n+}\n+\n+int\n+f6 (unsigned int x)\n+{\n+  f4 (x < (1 != f5 (0)));\n+  return x;\n+}\n+\n+int\n+main (void)\n+{\n+  f6 (1);\n+  if (v != 0)\n+    abort ();\n+  return 0;\n+}"}]}