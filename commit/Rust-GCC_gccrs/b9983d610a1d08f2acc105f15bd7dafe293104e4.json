{"sha": "b9983d610a1d08f2acc105f15bd7dafe293104e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk5ODNkNjEwYTFkMDhmMmFjYzEwNWYxNWJkN2RhZmUyOTMxMDRlNA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-06-19T00:58:28Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-06-19T00:58:28Z"}, "message": "re PR fortran/44477 (Sequential I/O with END FILE: File position should be at EoF)\n\n2010-06-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/44477\n\t* io/file_pos.c (st_endfile): Add check for ENDFILE when file is\n\talready positioned after the EOF marker. Use find_or_create_unit\n\tinstead of find_unit. If unit is not connected, connect it and create \n\tthe file with default settings.\n\t* io/transfer.c (data_transfer_init):  Add check for attempted READ or\n\tWRITE when file is already positioned after the EOF marker.\n\nFrom-SVN: r161020", "tree": {"sha": "c26ee912ace44e4f202d4c98d4191a4565da6421", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c26ee912ace44e4f202d4c98d4191a4565da6421"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9983d610a1d08f2acc105f15bd7dafe293104e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9983d610a1d08f2acc105f15bd7dafe293104e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9983d610a1d08f2acc105f15bd7dafe293104e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9983d610a1d08f2acc105f15bd7dafe293104e4/comments", "author": null, "committer": null, "parents": [{"sha": "b3b5bf9468756f4f6fe2a88d7c024738888838b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b5bf9468756f4f6fe2a88d7c024738888838b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3b5bf9468756f4f6fe2a88d7c024738888838b2"}], "stats": {"total": 91, "additions": 80, "deletions": 11}, "files": [{"sha": "83ff864a5ff6526452f1dca1ed3e130f38daba4d", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9983d610a1d08f2acc105f15bd7dafe293104e4/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9983d610a1d08f2acc105f15bd7dafe293104e4/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b9983d610a1d08f2acc105f15bd7dafe293104e4", "patch": "@@ -1,3 +1,13 @@\n+2010-06-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/44477\n+\t* io/file_pos.c (st_endfile): Add check for ENDFILE when file is\n+\talready positioned after the EOF marker. Use find_or_create_unit\n+\tinstead of find_unit. If unit is not connected, connect it and create \n+\tthe file with default settings.\n+\t* io/transfer.c (data_transfer_init):  Add check for attempted READ or\n+\tWRITE when file is already positioned after the EOF marker.\n+\n 2010-06-10  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* intrinsics/selected_char_kind.c (selected_char_kind): Fix"}, {"sha": "e7fbab4c8cc9870b3767a34ee1474c6a4d5c56c1", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9983d610a1d08f2acc105f15bd7dafe293104e4/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9983d610a1d08f2acc105f15bd7dafe293104e4/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=b9983d610a1d08f2acc105f15bd7dafe293104e4", "patch": "@@ -283,8 +283,17 @@ st_endfile (st_parameter_filepos *fpp)\n       if (u->flags.access == ACCESS_DIRECT)\n \t{\n \t  generate_error (&fpp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t\t  \"Cannot perform ENDFILE on a file opened\"\n-\t\t\t  \" for DIRECT access\");\n+\t\t\t  \"Cannot perform ENDFILE on a file opened \"\n+\t\t\t  \"for DIRECT access\");\n+\t  goto done;\n+\t}\n+\n+      if (u->flags.access == ACCESS_SEQUENTIAL\n+      \t  && u->endfile == AFTER_ENDFILE)\n+\t{\n+\t  generate_error (&fpp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t  \"Cannot perform ENDFILE on a file already \"\n+\t\t\t  \"positioned after the EOF marker\");\n \t  goto done;\n \t}\n \n@@ -309,9 +318,49 @@ st_endfile (st_parameter_filepos *fpp)\n       u->endfile = AFTER_ENDFILE;\n       if (0 == stell (u->s))\n         u->flags.position = POSITION_REWIND;\n-    done:\n-      unlock_unit (u);\n     }\n+  else\n+    {\n+      if (fpp->common.unit < 0)\n+\t{\n+\t  generate_error (&fpp->common, LIBERROR_BAD_OPTION,\n+\t\t\t  \"Bad unit number in statement\");\n+\t  return;\n+\t}\n+\n+      u = find_or_create_unit (fpp->common.unit);\n+      if (u->s == NULL)\n+\t{\n+\t  /* Open the unit with some default flags.  */\n+\t  st_parameter_open opp;\n+\t  unit_flags u_flags;\n+\n+\t  memset (&u_flags, '\\0', sizeof (u_flags));\n+\t  u_flags.access = ACCESS_SEQUENTIAL;\n+\t  u_flags.action = ACTION_READWRITE;\n+\t  u_flags.form = FORM_UNSPECIFIED;\n+\t  u_flags.delim = DELIM_UNSPECIFIED;\n+\t  u_flags.blank = BLANK_UNSPECIFIED;\n+\t  u_flags.pad = PAD_UNSPECIFIED;\n+\t  u_flags.decimal = DECIMAL_UNSPECIFIED;\n+\t  u_flags.encoding = ENCODING_UNSPECIFIED;\n+\t  u_flags.async = ASYNC_UNSPECIFIED;\n+\t  u_flags.round = ROUND_UNSPECIFIED;\n+\t  u_flags.sign = SIGN_UNSPECIFIED;\n+\t  u_flags.status = STATUS_UNKNOWN;\n+\t  u_flags.convert = GFC_CONVERT_NATIVE;\n+\n+\t  opp.common = fpp->common;\n+\t  opp.common.flags &= IOPARM_COMMON_MASK;\n+\t  u = new_unit (&opp, u, &u_flags);\n+\t  if (u == NULL)\n+\t    return;\n+\t  u->endfile = AFTER_ENDFILE;\n+\t}\n+    }\n+\n+  done:\n+    unlock_unit (u);\n \n   library_end ();\n }"}, {"sha": "9f2aafaf1a40858003742356d58288adb030c183", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9983d610a1d08f2acc105f15bd7dafe293104e4/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9983d610a1d08f2acc105f15bd7dafe293104e4/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=b9983d610a1d08f2acc105f15bd7dafe293104e4", "patch": "@@ -2267,15 +2267,25 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       return;\n     }\n \n-  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n-      && (cf & IOPARM_DT_HAS_REC) != 0)\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n     {\n-      generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t      \"Record number not allowed for sequential access \"\n-\t\t      \"data transfer\");\n-      return;\n-    }\n+      if ((cf & IOPARM_DT_HAS_REC) != 0)\n+\t{\n+\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t\"Record number not allowed for sequential access \"\n+\t\t\t\"data transfer\");\n+\t  return;\n+\t}\n \n+      if (dtp->u.p.current_unit->endfile == AFTER_ENDFILE)\n+      \t{\n+\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t\"Sequential READ or WRITE not allowed after \"\n+\t\t\t\"EOF marker, possibly use REWIND or BACKSPACE\");\n+\t  return;\n+\t}\n+\n+    }\n   /* Process the ADVANCE option.  */\n \n   dtp->u.p.advance_status"}]}