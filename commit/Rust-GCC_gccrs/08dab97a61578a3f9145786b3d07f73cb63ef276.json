{"sha": "08dab97a61578a3f9145786b3d07f73cb63ef276", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhkYWI5N2E2MTU3OGEzZjkxNDU3ODZiM2QwN2Y3M2NiNjNlZjI3Ng==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@il.ibm.com", "date": "2009-07-30T08:39:57Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2009-07-30T08:39:57Z"}, "message": "ssa-loop-manip.c: Include langhooks.h.\n\n2009-07-30  Razya Ladelsky <razya@il.ibm.com>\n\n        * ssa-loop-manip.c: Include langhooks.h.\n        (rewrite_phi_with_iv): New.\n        (rewrite_all_phi_nodes_with_iv): New.\n        (canonicalize_loop_ivs): Move here from tree-parloops.c.\n        Remove reduction_list argument. Use rewrite_all_phi_nodes_with_iv.\n        * tree-parloops.c (loop_parallel_p): Move out all conditions\n        except dependency check.\n        (canonicalize_loop_ivs): Move to tree-ssa-loop-manip.c.\n        (gen_parallel_loop): Call canonicalize_loop_ivs without\n        reduction_list argument.\n        (build_new_reduction): New.\n        (gather_scalar_reductions): New.\n        (try_get_loop_niter): New.\n        (try_create_reduction_list): New.\n        (parallleize_loops): Change the parallel conditions check.\n        * tree-flow.h (canonicalize_loop_ivs): Remove one argument.\n        * Makefile.in (tree-ssa-loop-manip.o): Add langhooks.h dependency.\n\nFrom-SVN: r150250", "tree": {"sha": "299bb21c623018572b34cfc6bc1013e8fb209dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/299bb21c623018572b34cfc6bc1013e8fb209dea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08dab97a61578a3f9145786b3d07f73cb63ef276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08dab97a61578a3f9145786b3d07f73cb63ef276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08dab97a61578a3f9145786b3d07f73cb63ef276", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08dab97a61578a3f9145786b3d07f73cb63ef276/comments", "author": null, "committer": null, "parents": [{"sha": "88c2fd3d625c9a0536d72f07fd969ef535b90c52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c2fd3d625c9a0536d72f07fd969ef535b90c52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88c2fd3d625c9a0536d72f07fd969ef535b90c52"}], "stats": {"total": 648, "additions": 366, "deletions": 282}, "files": [{"sha": "ca374c343d1c1e2db814501008eb1802277e0bdd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08dab97a61578a3f9145786b3d07f73cb63ef276/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08dab97a61578a3f9145786b3d07f73cb63ef276/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08dab97a61578a3f9145786b3d07f73cb63ef276", "patch": "@@ -1,3 +1,23 @@\n+2009-07-30  Razya Ladelsky <razya@il.ibm.com>\n+\n+\t* ssa-loop-manip.c: Include langhooks.h.\n+\t(rewrite_phi_with_iv): New.\n+\t(rewrite_all_phi_nodes_with_iv): New.\n+\t(canonicalize_loop_ivs): Move here from tree-parloops.c.\n+\tRemove reduction_list argument. Use rewrite_all_phi_nodes_with_iv.\n+\t* tree-parloops.c (loop_parallel_p): Move out all conditions\n+\texcept dependency check.\n+\t(canonicalize_loop_ivs): Move to tree-ssa-loop-manip.c.\n+\t(gen_parallel_loop): Call canonicalize_loop_ivs without\n+\treduction_list argument.\n+\t(build_new_reduction): New.\n+\t(gather_scalar_reductions): New.\n+\t(try_get_loop_niter): New.\n+\t(try_create_reduction_list): New.\n+\t(parallleize_loops): Change the parallel conditions check.\n+\t* tree-flow.h (canonicalize_loop_ivs): Remove one argument.\n+\t* Makefile.in (tree-ssa-loop-manip.o): Add langhooks.h dependency.\n+\n 2009-07-30  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n \t* opt-functions.awk (opt_args): Allow argument to be enclosed in"}, {"sha": "eeac7deab6a7f88e63caa32ae79f4b79397672f5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08dab97a61578a3f9145786b3d07f73cb63ef276/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08dab97a61578a3f9145786b3d07f73cb63ef276/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=08dab97a61578a3f9145786b3d07f73cb63ef276", "patch": "@@ -2356,7 +2356,7 @@ tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) $(TM_P_H) hard-reg-set.h \\\n    $(BASIC_BLOCK_H) output.h $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \\\n    $(TIMEVAR_H) $(CFGLOOP_H) $(TREE_PASS_H) $(CFGLAYOUT_H) \\\n-   $(SCEV_H) $(PARAMS_H) $(TREE_INLINE_H)\n+   $(SCEV_H) $(PARAMS_H) $(TREE_INLINE_H) langhooks.h\n tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) domwalk.h \\\n    $(PARAMS_H) output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\"}, {"sha": "f9f0da200250c38392727112f53ce0844e3fad4b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08dab97a61578a3f9145786b3d07f73cb63ef276/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08dab97a61578a3f9145786b3d07f73cb63ef276/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=08dab97a61578a3f9145786b3d07f73cb63ef276", "patch": "@@ -746,7 +746,7 @@ unsigned int tree_unroll_loops_completely (bool, bool);\n unsigned int tree_ssa_prefetch_arrays (void);\n void tree_ssa_iv_optimize (void);\n unsigned tree_predictive_commoning (void);\n-tree canonicalize_loop_ivs (struct loop *, htab_t, tree *);\n+tree canonicalize_loop_ivs (struct loop *, tree *);\n bool parallelize_loops (void);\n \n bool loop_only_exit_p (const struct loop *, const_edge);"}, {"sha": "f9a2e40d480d4cb501edba7048ebf4048470b5c7", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 214, "deletions": 280, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08dab97a61578a3f9145786b3d07f73cb63ef276/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08dab97a61578a3f9145786b3d07f73cb63ef276/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=08dab97a61578a3f9145786b3d07f73cb63ef276", "patch": "@@ -241,175 +241,22 @@ name_to_copy_elt_hash (const void *aa)\n   return (hashval_t) a->version;\n }\n \n-/* Returns true if the iterations of LOOP are independent on each other (that\n-   is, if we can execute them in parallel), and if LOOP satisfies other\n-   conditions that we need to be able to parallelize it.  Description of number\n-   of iterations is stored to NITER.  Reduction analysis is done, if\n-   reductions are found, they are inserted to the REDUCTION_LIST.  */  \n+\n+/* Data dependency analysis. Returns true if the iterations of LOOP\n+   are independent on each other (that is, if we can execute them\n+   in parallel).  */\n \n static bool\n-loop_parallel_p (struct loop *loop, htab_t reduction_list,\n-\t\t struct tree_niter_desc *niter)\n+loop_parallel_p (struct loop *loop)\n {\n-  edge exit = single_dom_exit (loop);\n   VEC (ddr_p, heap) * dependence_relations;\n   VEC (data_reference_p, heap) *datarefs;\n   lambda_trans_matrix trans;\n   bool ret = false;\n-  gimple_stmt_iterator gsi;\n-  loop_vec_info simple_loop_info;\n-\n-  /* Only consider innermost loops with just one exit.  The innermost-loop\n-     restriction is not necessary, but it makes things simpler.  */\n-  if (loop->inner || !exit)\n-    return false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nConsidering loop %d\\n\", loop->num);\n \n-  /* We need to know # of iterations, and there should be no uses of values\n-     defined inside loop outside of it, unless the values are invariants of\n-     the loop.  */\n-  if (!number_of_iterations_exit (loop, exit, niter, false))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"  FAILED: number of iterations not known\\n\");\n-      return false;\n-    }\n-\n-  vect_dump = NULL;\n-  simple_loop_info = vect_analyze_loop_form (loop);\n-\n-  for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple phi = gsi_stmt (gsi);\n-      gimple reduc_stmt = NULL;\n-      bool dummy;\n-\n-      /* ??? TODO: Change this into a generic function that \n-         recognizes reductions.  */\n-      if (!is_gimple_reg (PHI_RESULT (phi)))\n-\tcontinue;\n-      if (simple_loop_info)\n-\treduc_stmt = vect_is_simple_reduction (simple_loop_info, phi, true, \n-                                               &dummy);\n-\n-      /*  Create a reduction_info struct, initialize it and insert it to \n-         the reduction list.  */\n-\n-      if (reduc_stmt)\n-\t{\n-\t  PTR *slot;\n-\t  struct reduction_info *new_reduction;\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file,\n-\t\t       \"Detected reduction. reduction stmt is: \\n\");\n-\t      print_gimple_stmt (dump_file, reduc_stmt, 0, 0);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\n-\t  new_reduction = XCNEW (struct reduction_info);\n-\n-\t  new_reduction->reduc_stmt = reduc_stmt;\n-\t  new_reduction->reduc_phi = phi;\n-\t  new_reduction->reduction_code = gimple_assign_rhs_code (reduc_stmt);\n-\t  slot = htab_find_slot (reduction_list, new_reduction, INSERT);\n-\t  *slot = new_reduction;\n-\t}\n-    }\n-\n-  /* Get rid of the information created by the vectorizer functions.  */\n-  destroy_loop_vec_info (simple_loop_info, true);\n-\n-  for (gsi = gsi_start_phis (exit->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple phi = gsi_stmt (gsi);\n-      struct reduction_info *red;\n-      imm_use_iterator imm_iter;\n-      use_operand_p use_p;\n-      gimple reduc_phi;\n-      tree val = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n-\n-      if (is_gimple_reg (val))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"phi is \");\n-\t      print_gimple_stmt (dump_file, phi, 0, 0);\n-\t      fprintf (dump_file, \"arg of phi to exit:   value \");\n-\t      print_generic_expr (dump_file, val, 0);\n-\t      fprintf (dump_file, \" used outside loop\\n\");\n-\t      fprintf (dump_file,\n-\t\t       \"  checking if it a part of reduction pattern:  \\n\");\n-\t    }\n-\t  if (htab_elements (reduction_list) == 0)\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file,\n-\t\t\t \"  FAILED: it is not a part of reduction.\\n\");\n-\t      return false;\n-\t    }\n-\t  reduc_phi = NULL;\n-\t  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, val)\n-\t  {\n-\t    if (flow_bb_inside_loop_p (loop, gimple_bb (USE_STMT (use_p))))\n-\t      {\n-\t\treduc_phi = USE_STMT (use_p);\n-\t\tbreak;\n-\t      }\n-\t  }\n-\t  red = reduction_phi (reduction_list, reduc_phi);\n-\t  if (red == NULL)\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file,\n-\t\t\t \"  FAILED: it is not a part of reduction.\\n\");\n-\t      return false;\n-\t    }\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"reduction phi is  \");\n-\t      print_gimple_stmt (dump_file, red->reduc_phi, 0, 0);\n-\t      fprintf (dump_file, \"reduction stmt is  \");\n-\t      print_gimple_stmt (dump_file, red->reduc_stmt, 0, 0);\n-\t    }\n-\n-\t}\n-    }\n-\n-  /* The iterations of the loop may communicate only through bivs whose\n-     iteration space can be distributed efficiently.  */\n-  for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple phi = gsi_stmt (gsi);\n-      tree def = PHI_RESULT (phi);\n-      affine_iv iv;\n-\n-      if (is_gimple_reg (def) && !simple_iv (loop, loop, def, &iv, true))\n-\t{\n-\t  struct reduction_info *red;\n-\n-\t  red = reduction_phi (reduction_list, phi);\n-\t  if (red == NULL)\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file,\n-\t\t\t \"  FAILED: scalar dependency between iterations\\n\");\n-\t      return false;\n-\t    }\n-\t}\n-    }\n-\n-  /* We need to version the loop to verify assumptions in runtime.  */\n-  if (!can_duplicate_loop_p (loop))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"  FAILED: cannot be duplicated\\n\");\n-      return false;\n-    }\n-\n   /* Check for problems with dependences.  If the loop can be reversed,\n      the iterations are independent.  */\n   datarefs = VEC_alloc (data_reference_p, heap, 10);\n@@ -1330,114 +1177,6 @@ create_loop_fn (void)\n   return decl;\n }\n \n-/* Bases all the induction variables in LOOP on a single induction\n-   variable (unsigned with base 0 and step 1), whose final value is\n-   compared with *NIT.  When the IV type precision has to be larger\n-   than *NIT type precision, *NIT is converted to the larger type, the\n-   conversion code is inserted before the loop, and *NIT is updated to\n-   the new definition.  The induction variable is incremented in the\n-   loop latch.  REDUCTION_LIST describes the reductions in LOOP.\n-   Return the induction variable that was created.  */\n-\n-tree\n-canonicalize_loop_ivs (struct loop *loop, htab_t reduction_list, tree *nit)\n-{\n-  unsigned precision = TYPE_PRECISION (TREE_TYPE (*nit));\n-  unsigned original_precision = precision;\n-  tree res, type, var_before, val, atype, mtype;\n-  gimple_stmt_iterator gsi, psi;\n-  gimple phi, stmt;\n-  bool ok;\n-  affine_iv iv;\n-  edge exit = single_dom_exit (loop);\n-  struct reduction_info *red;\n-  gimple_seq stmts;\n-\n-  for (psi = gsi_start_phis (loop->header);\n-       !gsi_end_p (psi); gsi_next (&psi))\n-    {\n-      phi = gsi_stmt (psi);\n-      res = PHI_RESULT (phi);\n-\n-      if (is_gimple_reg (res) && TYPE_PRECISION (TREE_TYPE (res)) > precision)\n-\tprecision = TYPE_PRECISION (TREE_TYPE (res));\n-    }\n-\n-  type = lang_hooks.types.type_for_size (precision, 1);\n-\n-  if (original_precision != precision)\n-    {\n-      *nit = fold_convert (type, *nit);\n-      *nit = force_gimple_operand (*nit, &stmts, true, NULL_TREE);\n-      if (stmts)\n-\tgsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n-    }\n-\n-  gsi = gsi_last_bb (loop->latch);\n-  create_iv (build_int_cst_type (type, 0), build_int_cst (type, 1), NULL_TREE,\n-\t     loop, &gsi, true, &var_before, NULL);\n-\n-  gsi = gsi_after_labels (loop->header);\n-  for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); )\n-    {\n-      phi = gsi_stmt (psi);\n-      res = PHI_RESULT (phi);\n-\n-      if (!is_gimple_reg (res) || res == var_before)\n-\t{\n-\t  gsi_next (&psi);\n-\t  continue;\n-\t}\n-\n-      ok = simple_iv (loop, loop, res, &iv, true);\n-\n-      if (reduction_list)\n-\tred = reduction_phi (reduction_list, phi);\n-      else\n-\tred = NULL;\n-\n-      /* We preserve the reduction phi nodes.  */\n-      if (!ok && red)\n-\t{\n-\t  gsi_next (&psi);\n-\t  continue;\n-\t}\n-      else\n-\tgcc_assert (ok);\n-      remove_phi_node (&psi, false);\n-\n-      atype = TREE_TYPE (res);\n-      mtype = POINTER_TYPE_P (atype) ? sizetype : atype;\n-      val = fold_build2 (MULT_EXPR, mtype, unshare_expr (iv.step),\n-\t\t\t fold_convert (mtype, var_before));\n-      val = fold_build2 (POINTER_TYPE_P (atype)\n-\t\t\t ? POINTER_PLUS_EXPR : PLUS_EXPR,\n-\t\t\t atype, unshare_expr (iv.base), val);\n-      val = force_gimple_operand_gsi (&gsi, val, false, NULL_TREE, true,\n-\t\t\t\t      GSI_SAME_STMT);\n-      stmt = gimple_build_assign (res, val);\n-      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-      SSA_NAME_DEF_STMT (res) = stmt;\n-    }\n-\n-  stmt = last_stmt (exit->src);\n-  /* Make the loop exit if the control condition is not satisfied.  */\n-  if (exit->flags & EDGE_TRUE_VALUE)\n-    {\n-      edge te, fe;\n-\n-      extract_true_false_edges_from_block (exit->src, &te, &fe);\n-      te->flags = EDGE_FALSE_VALUE;\n-      fe->flags = EDGE_TRUE_VALUE;\n-    }\n-  gimple_cond_set_code (stmt, LT_EXPR);\n-  gimple_cond_set_lhs (stmt, var_before);\n-  gimple_cond_set_rhs (stmt, *nit);\n-  update_stmt (stmt);\n-\n-  return var_before;\n-}\n-\n /* Moves the exit condition of LOOP to the beginning of its header, and\n    duplicates the part of the last iteration that gets disabled to the\n    exit of the loop.  NIT is the number of iterations of the loop\n@@ -1675,12 +1414,14 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   return paral_bb;\n }\n \n-/* Generates code to execute the iterations of LOOP in N_THREADS threads in\n-   parallel.  NITER describes number of iterations of LOOP.  \n+/* Generates code to execute the iterations of LOOP in N_THREADS\n+   threads in parallel.\n+\n+   NITER describes number of iterations of LOOP.\n    REDUCTION_LIST describes the reductions existent in the LOOP.  */\n \n static void\n-gen_parallel_loop (struct loop *loop, htab_t reduction_list, \n+gen_parallel_loop (struct loop *loop, htab_t reduction_list,\n \t\t   unsigned n_threads, struct tree_niter_desc *niter)\n {\n   struct loop *nloop;\n@@ -1782,7 +1523,7 @@ gen_parallel_loop (struct loop *loop, htab_t reduction_list,\n   free_original_copy_tables ();\n \n   /* Base all the induction variables in LOOP on a single control one.  */\n-  canonicalize_loop_ivs (loop, reduction_list, &nit);\n+  canonicalize_loop_ivs (loop, &nit);\n \n   /* Ensure that the exit condition is the first statement in the loop.  */\n   transform_to_exit_first_loop (loop, reduction_list, nit);\n@@ -1848,6 +1589,184 @@ loop_has_vector_phi_nodes (struct loop *loop ATTRIBUTE_UNUSED)\n   return res;\n }\n \n+/* Create a reduction_info struct, initialize it with REDUC_STMT\n+   and PHI, insert it to the REDUCTION_LIST.  */\n+\n+static void\n+build_new_reduction (htab_t reduction_list, gimple reduc_stmt, gimple phi)\n+{\n+  PTR *slot;\n+  struct reduction_info *new_reduction;\n+\n+  gcc_assert (reduc_stmt);\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file,\n+\t       \"Detected reduction. reduction stmt is: \\n\");\n+      print_gimple_stmt (dump_file, reduc_stmt, 0, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  \n+  new_reduction = XCNEW (struct reduction_info);\n+  \n+  new_reduction->reduc_stmt = reduc_stmt;\n+  new_reduction->reduc_phi = phi;\n+  new_reduction->reduction_code = gimple_assign_rhs_code (reduc_stmt);\n+  slot = htab_find_slot (reduction_list, new_reduction, INSERT);\n+  *slot = new_reduction;\n+}\n+\n+/* Detect all reductions in the LOOP, insert them into REDUCTION_LIST.  */\n+\n+static void\n+gather_scalar_reductions (loop_p loop, htab_t reduction_list)\n+{\n+  gimple_stmt_iterator gsi;\n+  loop_vec_info simple_loop_info;\n+\n+  vect_dump = NULL;\n+  simple_loop_info = vect_analyze_loop_form (loop);\n+\n+  for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+      affine_iv iv;\n+      tree res = PHI_RESULT (phi);\n+      bool double_reduc;\n+\n+      if (!is_gimple_reg (res))\n+\tcontinue;\n+\n+      if (!simple_iv (loop, loop, res, &iv, true)\n+\t&& simple_loop_info)\n+\t{\n+           gimple reduc_stmt = vect_is_simple_reduction (simple_loop_info, phi, true, &double_reduc);\n+\t   if (reduc_stmt)\n+              build_new_reduction (reduction_list, reduc_stmt, phi);\n+        }\n+    }\n+    destroy_loop_vec_info (simple_loop_info, true);\n+}\n+\n+/* Try to initialize NITER for code generation part.  */\n+\n+static bool\n+try_get_loop_niter (loop_p loop, struct tree_niter_desc *niter)\n+{\n+  edge exit = single_dom_exit (loop);\n+\n+  gcc_assert (exit);\n+\n+  /* We need to know # of iterations, and there should be no uses of values\n+     defined inside loop outside of it, unless the values are invariants of\n+     the loop.  */\n+  if (!number_of_iterations_exit (loop, exit, niter, false))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  FAILED: number of iterations not known\\n\");\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Try to initialize REDUCTION_LIST for code generation part.\n+   REDUCTION_LIST describes the reductions.  */\n+\n+static bool\n+try_create_reduction_list (loop_p loop, htab_t reduction_list)\n+{\n+  edge exit = single_dom_exit (loop);\n+  gimple_stmt_iterator gsi;\n+\n+  gcc_assert (exit);\n+\n+  gather_scalar_reductions (loop, reduction_list);\n+\n+\t\n+  for (gsi = gsi_start_phis (exit->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+      struct reduction_info *red;\n+      imm_use_iterator imm_iter;\n+      use_operand_p use_p;\n+      gimple reduc_phi;\n+      tree val = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n+\n+      if (is_gimple_reg (val))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"phi is \");\n+\t      print_gimple_stmt (dump_file, phi, 0, 0);\n+\t      fprintf (dump_file, \"arg of phi to exit:   value \");\n+\t      print_generic_expr (dump_file, val, 0);\n+\t      fprintf (dump_file, \" used outside loop\\n\");\n+\t      fprintf (dump_file,\n+\t\t       \"  checking if it a part of reduction pattern:  \\n\");\n+\t    }\n+\t  if (htab_elements (reduction_list) == 0)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file,\n+\t\t\t \"  FAILED: it is not a part of reduction.\\n\");\n+\t      return false;\n+\t    }\n+\t  reduc_phi = NULL;\n+\t  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, val)\n+\t    {\n+\t      if (flow_bb_inside_loop_p (loop, gimple_bb (USE_STMT (use_p))))\n+\t\t{\n+\t\t  reduc_phi = USE_STMT (use_p);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  red = reduction_phi (reduction_list, reduc_phi);\n+\t  if (red == NULL)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file,\n+\t\t\t \"  FAILED: it is not a part of reduction.\\n\");\n+\t      return false;\n+\t    }\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"reduction phi is  \");\n+\t      print_gimple_stmt (dump_file, red->reduc_phi, 0, 0);\n+\t      fprintf (dump_file, \"reduction stmt is  \");\n+\t      print_gimple_stmt (dump_file, red->reduc_stmt, 0, 0);\n+\t    }\n+\t}\n+    }\n+\n+  /* The iterations of the loop may communicate only through bivs whose\n+     iteration space can be distributed efficiently.  */\n+  for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+      tree def = PHI_RESULT (phi);\n+      affine_iv iv;\n+\n+      if (is_gimple_reg (def) && !simple_iv (loop, loop, def, &iv, true))\n+\t{\n+\t  struct reduction_info *red;\n+\n+\t  red = reduction_phi (reduction_list, phi);\n+\t  if (red == NULL)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file,\n+\t\t\t \"  FAILED: scalar dependency between iterations\\n\");\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+\n+\n+  return true;\n+}\n+\n /* Detect parallel loops and generate parallel code using libgomp\n    primitives.  Returns true if some loop was parallelized, false\n    otherwise.  */\n@@ -1867,26 +1786,41 @@ parallelize_loops (void)\n     return false;\n \n   reduction_list = htab_create (10, reduction_info_hash,\n-                                reduction_info_eq, free);\n+\t\t\t\t     reduction_info_eq, free);\n   init_stmt_vec_info_vec ();\n \n   FOR_EACH_LOOP (li, loop, 0)\n     {\n       htab_empty (reduction_list);\n-      if (/* Do not bother with loops in cold areas.  */\n-\t  optimize_loop_nest_for_size_p (loop)\n-\t  /* Or loops that roll too little.  */\n-\t  || expected_loop_iterations (loop) <= n_threads\n-\t  /* And of course, the loop must be parallelizable.  */\n-\t  || !can_duplicate_loop_p (loop)\n+\n+      /* FIXME: Only consider innermost loops with just one exit.  */\n+      if (loop->inner || !single_dom_exit (loop))\n+\tcontinue;\n+\n+      if (/* And of course, the loop must be parallelizable.  */\n+\t  !can_duplicate_loop_p (loop)\n \t  || loop_has_blocks_with_irreducible_flag (loop)\n \t  /* FIXME: the check for vector phi nodes could be removed.  */\n-\t  || loop_has_vector_phi_nodes (loop)\n-\t  || !loop_parallel_p (loop, reduction_list, &niter_desc))\n+\t  || loop_has_vector_phi_nodes (loop))\n+\tcontinue;\n+     \n+        if (/* Do not bother with loops in cold areas.  */\n+\t    optimize_loop_nest_for_size_p (loop)\n+\t    /* Or loops that roll too little.  */\n+\t    || expected_loop_iterations (loop) <= n_threads)\n+\tcontinue;\n+      if (!try_get_loop_niter (loop, &niter_desc))\n+\tcontinue;\n+\n+      if (!try_create_reduction_list (loop, reduction_list))\n+\tcontinue;\n+\n+      if (!loop_parallel_p (loop))\n \tcontinue;\n \n       changed = true;\n-      gen_parallel_loop (loop, reduction_list, n_threads, &niter_desc);\n+      gen_parallel_loop (loop, reduction_list, \n+\t\t\t n_threads, &niter_desc);\n       verify_flow_info ();\n       verify_dominators (CDI_DOMINATORS);\n       verify_loop_structure ();"}, {"sha": "c4a40b084a6e491fb92cf7b12de522f15a136ef0", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08dab97a61578a3f9145786b3d07f73cb63ef276/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08dab97a61578a3f9145786b3d07f73cb63ef276/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=08dab97a61578a3f9145786b3d07f73cb63ef276", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"params.h\"\n #include \"tree-inline.h\"\n+#include \"langhooks.h\"\n \n /* Creates an induction variable with value BASE + STEP * iteration in LOOP.\n    It is expected that neither BASE nor STEP are shared with other expressions\n@@ -1100,3 +1101,132 @@ tree_unroll_loop (struct loop *loop, unsigned factor,\n   tree_transform_and_unroll_loop (loop, factor, exit, desc,\n \t\t\t\t  NULL, NULL);\n }\n+\n+/* Rewrite the phi node at position PSI in function of the main\n+   induction variable MAIN_IV and insert the generated code at GSI.  */\n+\n+static void\n+rewrite_phi_with_iv (loop_p loop,\n+\t\t     gimple_stmt_iterator *psi,\n+\t\t     gimple_stmt_iterator *gsi,\n+\t\t     tree main_iv)\n+{\n+  affine_iv iv;\n+  gimple stmt, phi = gsi_stmt (*psi);\n+  tree atype, mtype, val, res = PHI_RESULT (phi);\n+\n+  if (!is_gimple_reg (res) || res == main_iv)\n+    {\n+      gsi_next (psi);\n+      return;\n+    }\n+\n+  if (!simple_iv (loop, loop, res, &iv, true))\n+    {\n+      gsi_next (psi);\n+      return;\n+    }\n+\n+  remove_phi_node (psi, false);\n+\n+  atype = TREE_TYPE (res);\n+  mtype = POINTER_TYPE_P (atype) ? sizetype : atype;\n+  val = fold_build2 (MULT_EXPR, mtype, unshare_expr (iv.step),\n+\t\t     fold_convert (mtype, main_iv));\n+  val = fold_build2 (POINTER_TYPE_P (atype)\n+\t\t     ? POINTER_PLUS_EXPR : PLUS_EXPR,\n+\t\t     atype, unshare_expr (iv.base), val);\n+  val = force_gimple_operand_gsi (gsi, val, false, NULL_TREE, true,\n+\t\t\t\t  GSI_SAME_STMT);\n+  stmt = gimple_build_assign (res, val);\n+  gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+  SSA_NAME_DEF_STMT (res) = stmt;\n+}\n+\n+/* Rewrite all the phi nodes of LOOP in function of the main induction\n+   variable MAIN_IV.  */\n+\n+static void\n+rewrite_all_phi_nodes_with_iv (loop_p loop, tree main_iv)\n+{\n+  unsigned i;\n+  basic_block *bbs = get_loop_body_in_dom_order (loop);\n+  gimple_stmt_iterator psi;\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = bbs[i];\n+      gimple_stmt_iterator gsi = gsi_after_labels (bb);\n+\n+      if (bb->loop_father != loop)\n+\tcontinue;\n+\n+      for (psi = gsi_start_phis (bb); !gsi_end_p (psi); )\n+\trewrite_phi_with_iv (loop, &psi, &gsi, main_iv);\n+    }\n+\n+  free (bbs);\n+}\n+\n+/* Bases all the induction variables in LOOP on a single induction\n+   variable (unsigned with base 0 and step 1), whose final value is\n+   compared with *NIT.  When the IV type precision has to be larger\n+   than *NIT type precision, *NIT is converted to the larger type, the\n+   conversion code is inserted before the loop, and *NIT is updated to\n+   the new definition.  The induction variable is incremented in the\n+   loop latch.  Return the induction variable that was created.  */\n+\n+tree\n+canonicalize_loop_ivs (struct loop *loop, tree *nit)\n+{\n+  unsigned precision = TYPE_PRECISION (TREE_TYPE (*nit));\n+  unsigned original_precision = precision;\n+  tree type, var_before;\n+  gimple_stmt_iterator gsi, psi;\n+  gimple stmt;\n+  edge exit = single_dom_exit (loop);\n+  gimple_seq stmts;\n+\n+  for (psi = gsi_start_phis (loop->header);\n+       !gsi_end_p (psi); gsi_next (&psi))\n+    {\n+      gimple phi = gsi_stmt (psi);\n+      tree res = PHI_RESULT (phi);\n+\n+      if (is_gimple_reg (res) && TYPE_PRECISION (TREE_TYPE (res)) > precision)\n+\tprecision = TYPE_PRECISION (TREE_TYPE (res));\n+    }\n+\n+  type = lang_hooks.types.type_for_size (precision, 1);\n+\n+  if (original_precision != precision)\n+    {\n+      *nit = fold_convert (type, *nit);\n+      *nit = force_gimple_operand (*nit, &stmts, true, NULL_TREE);\n+      if (stmts)\n+\tgsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+    }\n+\n+  gsi = gsi_last_bb (loop->latch);\n+  create_iv (build_int_cst_type (type, 0), build_int_cst (type, 1), NULL_TREE,\n+\t     loop, &gsi, true, &var_before, NULL);\n+\n+  rewrite_all_phi_nodes_with_iv (loop, var_before);\n+\n+  stmt = last_stmt (exit->src);\n+  /* Make the loop exit if the control condition is not satisfied.  */\n+  if (exit->flags & EDGE_TRUE_VALUE)\n+    {\n+      edge te, fe;\n+\n+      extract_true_false_edges_from_block (exit->src, &te, &fe);\n+      te->flags = EDGE_FALSE_VALUE;\n+      fe->flags = EDGE_TRUE_VALUE;\n+    }\n+  gimple_cond_set_code (stmt, LT_EXPR);\n+  gimple_cond_set_lhs (stmt, var_before);\n+  gimple_cond_set_rhs (stmt, *nit);\n+  update_stmt (stmt);\n+\n+  return var_before;\n+}"}]}