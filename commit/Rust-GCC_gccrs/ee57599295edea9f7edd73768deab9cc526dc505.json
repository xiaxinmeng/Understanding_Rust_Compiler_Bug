{"sha": "ee57599295edea9f7edd73768deab9cc526dc505", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU1NzU5OTI5NWVkZWE5ZjdlZGQ3Mzc2OGRlYWI5Y2M1MjZkYzUwNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-11-19T10:54:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-11-19T10:54:53Z"}, "message": "a-exexpr.adb (Others_Value, [...]): New variables...\n\n\t* a-exexpr.adb (Others_Value, All_Others_Value): New variables, the\n\taddress of which may be used to represent \"others\" and \"all others\"\n\tchoices in exception tables, instead of the current harcoded\n\t(void *)0 and (void *)1.\n\t(Setup_Exception): Do nothing in the GNAT SJLJ case.\n\n\t* gigi.h (others_decl, all_others_decl): New decls representing the\n\tnew Others_Value and All_Others_Value objects.\n\t(struct attrib): Rename \"arg\" component as \"args\", since GCC expects a\n\tlist of arguments in there.\n\n\t* raise.c (GNAT_OTHERS, GNAT_ALL_OTHERS): Are now the address of the\n\tcorresponding objects exported by a-exexpr, instead of hardcoded dummy\n\taddresses.\n\n\t* trans.c (Exception_Handler_to_gnu_zcx): Use the address of\n\tothers_decl and all_others_decl instead of hardcoded dummy addresses\n\tto represent \"others\" and \"all others\" choices, which is cleaner and\n\tmore flexible with respect to the possible eh pointer encoding policies.\n\n\t* utils.c (init_gigi_decls): Initialize others_decl and all_others_decl.\n\t(process_attributes): Account for the naming change of the \"args\"\n\tattribute list entry component.\n\n\t* decl.c (build_attr_list): Rename into prepend_attributes to allow\n\tcumulating attributes for different entities into a single list.\n\t(gnat_to_gnu_entity): Use prepend_attributes to build the list of\n\tattributes for the current entity and propagate first subtype\n\tattributes to other subtypes.\n\t<E_Procedure>: Attribute arguments are attr->args and not\n\tattr->arg any more.\n\t(build_attr_list): Ditto. Make attr->args a TREE_LIST when there is an\n\targument provided, as this is what GCC expects. Use NULL_TREE instead\n\tof 0 for trees.\n\nFrom-SVN: r90900", "tree": {"sha": "6efa7bf4ecf82f27c400f99353c69a8bcca1b6c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6efa7bf4ecf82f27c400f99353c69a8bcca1b6c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee57599295edea9f7edd73768deab9cc526dc505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee57599295edea9f7edd73768deab9cc526dc505", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee57599295edea9f7edd73768deab9cc526dc505", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee57599295edea9f7edd73768deab9cc526dc505/comments", "author": null, "committer": null, "parents": [{"sha": "f5a0cbf1083ff9d9635c813929b89d9f831f4ec9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5a0cbf1083ff9d9635c813929b89d9f831f4ec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5a0cbf1083ff9d9635c813929b89d9f831f4ec9"}], "stats": {"total": 159, "additions": 110, "deletions": 49}, "files": [{"sha": "ea9ce671ca711da487a9f6c1ef53d760a6a4dabc", "filename": "gcc/ada/a-exexpr.adb", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Fa-exexpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Fa-exexpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr.adb?ref=ee57599295edea9f7edd73768deab9cc526dc505", "patch": "@@ -131,7 +131,7 @@ package body Exception_Propagation is\n \n    type GNAT_GCC_Exception is record\n       Header : Unwind_Exception;\n-      --  ABI Exception header first.\n+      --  ABI Exception header first\n \n       Id : Exception_Id;\n       --  GNAT Exception identifier.  This is filled by Propagate_Exception\n@@ -146,7 +146,7 @@ package body Exception_Propagation is\n       --  an exception is not handled.\n \n       Next_Exception : EOA;\n-      --  Used to create a linked list of exception occurrences.\n+      --  Used to create a linked list of exception occurrences\n    end record;\n \n    pragma Convention (C, GNAT_GCC_Exception);\n@@ -204,9 +204,9 @@ package body Exception_Propagation is\n       UW_Argument  : System.Address);\n    pragma Import (C, Unwind_ForcedUnwind, \"__gnat_Unwind_ForcedUnwind\");\n \n-   --------------------------------------------\n-   -- Occurrence stack management facilities --\n-   --------------------------------------------\n+   ------------------------------------------------------------------\n+   -- Occurrence Stack Management Facilities for the GCC-EH Scheme --\n+   ------------------------------------------------------------------\n \n    function Remove\n      (Top   : EOA;\n@@ -245,7 +245,7 @@ package body Exception_Propagation is\n    ------------------------------------------------------------\n \n    --  As of today, these are only used by the C implementation of the\n-   --  propagation personality routine to avoid having to rely on a C\n+   --  GCC propagation personality routine to avoid having to rely on a C\n    --  counterpart of the whole exception_data structure, which is both\n    --  painful and error prone. These subprograms could be moved to a\n    --  more widely visible location if need be.\n@@ -268,6 +268,20 @@ package body Exception_Propagation is\n       Adjustment     : Integer);\n    pragma Export (C, Adjust_N_Cleanups_For, \"__gnat_adjust_n_cleanups_for\");\n \n+   ---------------------------------------------------------------------------\n+   -- Objects to materialize \"others\" and \"all others\" in the GCC EH tables --\n+   ---------------------------------------------------------------------------\n+\n+   --  Currently, these only have their address taken and compared so there is\n+   --  no real point having whole exception data blocks allocated. In any case\n+   --  the types should match what gigi and the personality routine expect.\n+\n+   Others_Value : constant Integer := 16#BEEF#;\n+   pragma Export (C, Others_Value, \"__gnat_others_value\");\n+\n+   All_Others_Value : constant Integer := 16#BEEF#;\n+   pragma Export (C, All_Others_Value, \"__gnat_all_others_value\");\n+\n    ------------\n    -- Remove --\n    ------------\n@@ -360,7 +374,7 @@ package body Exception_Propagation is\n \n    function Is_Setup_And_Not_Propagated (E : EOA) return Boolean is\n       GCC_E : GNAT_GCC_Exception_Access :=\n-        To_GNAT_GCC_Exception (E.Private_Data);\n+                To_GNAT_GCC_Exception (E.Private_Data);\n    begin\n       return GCC_E /= null and then GCC_E.Header.Private1 = Setup_Key;\n    end Is_Setup_And_Not_Propagated;\n@@ -371,7 +385,7 @@ package body Exception_Propagation is\n \n    procedure Clear_Setup_And_Not_Propagated (E : EOA) is\n       GCC_E : GNAT_GCC_Exception_Access :=\n-        To_GNAT_GCC_Exception (E.Private_Data);\n+                To_GNAT_GCC_Exception (E.Private_Data);\n    begin\n       pragma Assert (GCC_E /= null);\n       GCC_E.Header.Private1 := 0;\n@@ -383,7 +397,7 @@ package body Exception_Propagation is\n \n    procedure Set_Setup_And_Not_Propagated (E : EOA) is\n       GCC_E : GNAT_GCC_Exception_Access :=\n-        To_GNAT_GCC_Exception (E.Private_Data);\n+                To_GNAT_GCC_Exception (E.Private_Data);\n    begin\n       pragma Assert (GCC_E /= null);\n       GCC_E.Header.Private1 := Setup_Key;\n@@ -393,10 +407,17 @@ package body Exception_Propagation is\n    -- Setup_Exception --\n    ---------------------\n \n-   --  In this implementation of the exception propagation scheme, this\n-   --  subprogram should be understood as: Setup the exception occurrence\n+   --  In the GCC-EH implementation of the propagation scheme, this\n+   --  subprogram should be understood as : Setup the exception occurrence\n    --  stack headed at Current for a forthcoming raise of Excep.\n \n+   --  In the GNAT-SJLJ case this \"stack\" only exists implicitely, by way of\n+   --  local occurrence declarations together with save/restore operations\n+   --  generated by the front-end, and this routine has nothing to do.\n+\n+   --  The differenciation is done here and not in the callers to avoid having\n+   --  to spread out the test in numerous places.\n+\n    procedure Setup_Exception\n      (Excep    : EOA;\n       Current  : EOA;\n@@ -407,12 +428,22 @@ package body Exception_Propagation is\n       GCC_Exception : GNAT_GCC_Exception_Access;\n \n    begin\n+      --  Just return if we're not in the GCC-EH case. What is otherwise\n+      --  performed is useless and even harmful since it potentially involves\n+      --  dynamic allocations that would never be released, and participates\n+      --  in the Setup_And_Not_Propagated predicate management, only properly\n+      --  handled by the rest of the GCC-EH scheme.\n \n-      --  The exception Excep is soon to be propagated, and the storage used\n-      --  for that will be the occurrence statically allocated for the current\n-      --  thread. This storage might currently be used for a still active\n-      --  occurrence, so we need to push it on the thread's occurrence stack\n-      --  (headed at that static occurrence) before it gets clobbered.\n+      if Zero_Cost_Exceptions = 0 then\n+         return;\n+      end if;\n+\n+      --  Otherwise, the exception Excep is soon to be propagated, and the\n+      --  storage used for that will be the occurrence statically allocated\n+      --  for the current thread. This storage might currently be used for a\n+      --  still active occurrence, so we need to push it on the thread's\n+      --  occurrence stack (headed at that static occurrence) before it gets\n+      --  clobbered.\n \n       --  What we do here is to trigger this push when need be, and allocate a\n       --  Private_Data block for the forthcoming Propagation.\n@@ -461,7 +492,6 @@ package body Exception_Propagation is\n       Top.Private_Data := GCC_Exception.all'Address;\n \n       Set_Setup_And_Not_Propagated (Top);\n-\n    end Setup_Exception;\n \n    -------------------"}, {"sha": "d5c56b5e306d692ec0ef6d2ff5137b1126fa6db0", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=ee57599295edea9f7edd73768deab9cc526dc505", "patch": "@@ -83,7 +83,7 @@ static struct incomplete\n static void copy_alias_set (tree, tree);\n static tree substitution_list (Entity_Id, Entity_Id, tree, bool);\n static bool allocatable_size_p (tree, bool);\n-static struct attrib *build_attr_list (Entity_Id);\n+static void prepend_attributes (Entity_Id, struct attrib **);\n static tree elaborate_expression (Node_Id, Entity_Id, tree, bool, bool, bool);\n static bool is_variable_size (tree);\n static tree elaborate_expression_1 (Node_Id, Entity_Id, tree, tree,\n@@ -298,9 +298,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  && (kind == E_Function || kind == E_Procedure)))\n     force_global++, this_global = true;\n \n-  /* Handle any attributes.  */\n+  /* Handle any attributes directly attached to the entity.  */\n   if (Has_Gigi_Rep_Item (gnat_entity))\n-    attr_list = build_attr_list (gnat_entity);\n+    prepend_attributes (gnat_entity, &attr_list);\n+\n+  /* Machine_Attributes on types are expected to be propagated to subtypes.\n+     The corresponding Gigi_Rep_Items are only attached to the first subtype\n+     though, so we handle the propagation here.  */\n+  if (Is_Type (gnat_entity) && Base_Type (gnat_entity) != gnat_entity\n+      && !Is_First_Subtype (gnat_entity)\n+      && Has_Gigi_Rep_Item (First_Subtype (Base_Type (gnat_entity))))\n+    prepend_attributes (First_Subtype (Base_Type (gnat_entity)), &attr_list);\n \n   switch (kind)\n     {\n@@ -3598,7 +3606,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    attr->next = attr_list;\n \t    attr->type = ATTR_MACHINE_ATTRIBUTE;\n \t    attr->name = get_identifier (\"stdcall\");\n-\t    attr->arg = NULL_TREE;\n+\t    attr->args = NULL_TREE;\n \t    attr->error_point = gnat_entity;\n \t    attr_list = attr;\n \t  }\n@@ -4365,20 +4373,19 @@ allocatable_size_p (tree gnu_size, bool static_p)\n   return (int) our_size == our_size;\n }\n \f\n-/* Return a list of attributes for GNAT_ENTITY, if any.  */\n+/* Prepend to ATTR_LIST the list of attributes for GNAT_ENTITY, if any.  */\n \n-static struct attrib *\n-build_attr_list (Entity_Id gnat_entity)\n+static void\n+prepend_attributes (Entity_Id gnat_entity, struct attrib ** attr_list)\n {\n-  struct attrib *attr_list = 0;\n   Node_Id gnat_temp;\n \n   for (gnat_temp = First_Rep_Item (gnat_entity); Present (gnat_temp);\n        gnat_temp = Next_Rep_Item (gnat_temp))\n     if (Nkind (gnat_temp) == N_Pragma)\n       {\n \tstruct attrib *attr;\n-\ttree gnu_arg0 = 0, gnu_arg1 = 0;\n+\ttree gnu_arg0 = NULL_TREE, gnu_arg1 = NULL_TREE;\n \tNode_Id gnat_assoc = Pragma_Argument_Associations (gnat_temp);\n \tenum attr_type etype;\n \n@@ -4424,17 +4431,23 @@ build_attr_list (Entity_Id gnat_entity)\n \t  }\n \n \tattr = (struct attrib *) xmalloc (sizeof (struct attrib));\n-\tattr->next = attr_list;\n+\tattr->next = *attr_list;\n \tattr->type = etype;\n \tattr->name = gnu_arg0;\n-\tattr->arg = gnu_arg1;\n+\n+\t/* If we have an argument specified together with an attribute name,\n+\t   make it a single TREE_VALUE entry in a list of arguments, as GCC\n+\t   expects it.  */\n+\tif (gnu_arg1 != NULL_TREE)\n+\t  attr->args = build_tree_list (NULL_TREE, gnu_arg1);\n+\telse\n+\t  attr->args = NULL_TREE;\n+\n \tattr->error_point\n \t  = Present (Next (First (gnat_assoc)))\n \t    ? Expression (Next (First (gnat_assoc))) : gnat_temp;\n-\tattr_list = attr;\n+\t*attr_list = attr;\n       }\n-\n-  return attr_list;\n }\n \f\n /* Get the unpadded version of a GNAT type.  */"}, {"sha": "20784c1b5d2336fc134d04f983438b6bed5e0019", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=ee57599295edea9f7edd73768deab9cc526dc505", "patch": "@@ -297,7 +297,7 @@ struct attrib\n   struct attrib *next;\n   enum attr_type type;\n   tree name;\n-  tree arg;\n+  tree args;\n   Node_Id error_point;\n };\n \n@@ -340,6 +340,8 @@ enum standard_datatypes\n   ADT_raise_nodefer_decl,\n   ADT_begin_handler_decl,\n   ADT_end_handler_decl,\n+  ADT_others_decl,\n+  ADT_all_others_decl,\n   ADT_LAST};\n \n extern GTY(()) tree gnat_std_decls[(int) ADT_LAST];\n@@ -363,6 +365,8 @@ extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n #define update_setjmp_buf_decl gnat_std_decls[(int) ADT_update_setjmp_buf_decl]\n #define raise_nodefer_decl gnat_std_decls[(int) ADT_raise_nodefer_decl]\n #define begin_handler_decl gnat_std_decls[(int) ADT_begin_handler_decl]\n+#define others_decl gnat_std_decls[(int) ADT_others_decl]\n+#define all_others_decl gnat_std_decls[(int) ADT_all_others_decl]\n #define end_handler_decl gnat_std_decls[(int) ADT_end_handler_decl]\n \n /* Routines expected by the gcc back-end. They must have exactly the same"}, {"sha": "7de1f7754b799f981081f60b6464ab77b103519a", "filename": "gcc/ada/raise.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Fraise.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Fraise.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.c?ref=ee57599295edea9f7edd73768deab9cc526dc505", "patch": "@@ -480,11 +480,13 @@ typedef struct\n } _GNAT_Exception;\n \n /* The two constants below are specific ttype identifiers for special\n-   exception ids. Their value is currently hardcoded at the gigi level\n-   (see N_Exception_Handler).  */\n+   exception ids.  Their type should match what a-exexpr exports.  */\n \n-#define GNAT_OTHERS      ((_Unwind_Ptr) 0x0)\n-#define GNAT_ALL_OTHERS  ((_Unwind_Ptr) 0x1)\n+extern const int __gnat_others_value;\n+#define GNAT_OTHERS      ((_Unwind_Ptr) &__gnat_others_value)\n+\n+extern const int __gnat_all_others_value;\n+#define GNAT_ALL_OTHERS  ((_Unwind_Ptr) &__gnat_all_others_value)\n \n /* Describe the useful region data associated with an unwind context.  */\n "}, {"sha": "162e6acc1988543bf002566ea82eac7506054569", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=ee57599295edea9f7edd73768deab9cc526dc505", "patch": "@@ -2299,24 +2299,22 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n      handler can catch, with special cases for others and all others cases.\n \n      Each exception type is actually identified by a pointer to the exception\n-     id, with special value zero for \"others\" and one for \"all others\". Beware\n-     that these special values are known and used by the personality routine to\n-     identify the corresponding specific kinds of handlers.\n+     id, or to a dummy object for \"others\" and \"all others\".\n \n-     ??? For initial time frame reasons, the others and all_others cases have\n-     been handled using specific type trees, but this somehow hides information\n-     from the back-end, which expects NULL to be passed for catch all and\n-     end_cleanup to be used for cleanups.\n-\n-     Care should be taken to ensure that the control flow impact of such\n-     clauses is rendered in some way. lang_eh_type_covers is doing the trick\n+     Care should be taken to ensure that the control flow impact of \"others\"\n+     and \"all others\" is known to GCC. lang_eh_type_covers is doing the trick\n      currently.  */\n   for (gnat_temp = First (Exception_Choices (gnat_node));\n        gnat_temp; gnat_temp = Next (gnat_temp))\n     {\n       if (Nkind (gnat_temp) == N_Others_Choice)\n-\tgnu_etype = (All_Others (gnat_temp) ? integer_one_node\n-\t\t     : integer_zero_node);\n+\t{\n+\t  tree gnu_expr\n+\t    = All_Others (gnat_temp) ? all_others_decl : others_decl;\n+\n+\t  gnu_etype\n+\t    = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_expr);\n+\t}\n       else if (Nkind (gnat_temp) == N_Identifier\n \t       || Nkind (gnat_temp) == N_Expanded_Name)\n \t{"}, {"sha": "e2205d0353f5a797d8ba3302af87174962991042", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee57599295edea9f7edd73768deab9cc526dc505/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=ee57599295edea9f7edd73768deab9cc526dc505", "patch": "@@ -613,6 +613,20 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t       endlink)),\n        NULL_TREE, false, true, true, NULL, Empty);\n \n+  /* Dummy objects to materialize \"others\" and \"all others\" in the exception\n+     tables.  These are exported by a-exexpr.adb, so see this unit for the\n+     types to use.  */\n+\n+  others_decl\n+    = create_var_decl (get_identifier (\"OTHERS\"),\n+\t\t       get_identifier (\"__gnat_others_value\"),\n+\t\t       integer_type_node, 0, 1, 0, 1, 1, 0, Empty);\n+\n+  all_others_decl\n+    = create_var_decl (get_identifier (\"ALL_OTHERS\"),\n+\t\t       get_identifier (\"__gnat_all_others_value\"),\n+\t\t       integer_type_node, 0, 1, 0, 1, 1, 0, Empty);\n+\n   /* Hooks to call when entering/leaving an exception handler.  */\n   begin_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_begin_handler\"), NULL_TREE,\n@@ -1550,7 +1564,7 @@ process_attributes (tree decl, struct attrib *attr_list)\n     switch (attr_list->type)\n       {\n       case ATTR_MACHINE_ATTRIBUTE:\n-\tdecl_attributes (&decl, tree_cons (attr_list->name, attr_list->arg,\n+\tdecl_attributes (&decl, tree_cons (attr_list->name, attr_list->args,\n \t\t\t\t\t   NULL_TREE),\n \t\t\t ATTR_FLAG_TYPE_IN_PLACE);\n \tbreak;"}]}