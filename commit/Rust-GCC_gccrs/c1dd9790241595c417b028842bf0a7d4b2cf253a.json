{"sha": "c1dd9790241595c417b028842bf0a7d4b2cf253a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFkZDk3OTAyNDE1OTVjNDE3YjAyODg0MmJmMGE3ZDRiMmNmMjUzYQ==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2014-10-21T20:12:01Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2014-10-21T20:12:01Z"}, "message": "avr-c.c (avr_cpu_cpp_builtins): Don't define __MEMX for avrtiny.\n\ngcc:\n\n2014-10-21  Joern Rennecke  <joern.rennecke@embecosm.com>\n\t    Vidya Praveen <vidya.praveen@atmel.com>\n\t    Praveen Kumar Kaushik <Praveen_Kumar.Kaushik@atmel.com>\n\t    Senthil Kumar Selvaraj <Senthil_Kumar.Selvaraj@atmel.com>\n\t    Pitchumani Sivanupandi <Pitchumani.S@atmel.com>\n\n\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): Don't define\n\t__MEMX for avrtiny.\n\t* config/avr/avr.c (avr_insert_attributes): Reject __memx for avrtiny.\n\t(avr_nonconst_pointer_addrspace): Likewise.\n\t* config/avr/avr.h (AVR_HAVE_LPM): Define.\n\n\tAdded AVRTINY architecture to avr target.\n\t* config/avr/avr-arch.h (avr_arch): Added AVRTINY architecture.\n\t(base_arch_s): member added for AVRTINY architecture.\n\t* config/avr/avr.c: Added TINY_ADIW, TINY_SBIW macros as AVRTINY\n\talternate for adiw/sbiw instructions. Added AVR_TMP_REGNO and\n\tAVR_ZERO_REGNO macros for tmp and zero registers. Replaced TMP_REGNO\n\tand ZERO_REGNO occurrences by AVR_TMP_REGNO and AVR_ZERO_REGNO\n\trespectively. LAST_CALLEE_SAVED_REG macro added for the last register\n\tin callee saved register list.\n\t(avr_option_override): CCP address updated for AVRTINY.\n\t(avr_init_expanders): tmp and zero rtx initialized as per arch.\n\tReset avr_have_dimode if AVRTINY.\n\t(sequent_regs_live): Use LAST_CALLEE_SAVED_REG instead magic number.\n\t(emit_push_sfr): Use AVR_TMP_REGNO for tmp register number.\n\t(avr_prologue_setup_frame): Don't minimize prologue if AVRTINY.\n\tUse LAST_CALLEE_SAVED_REG to refer last callee saved register.\n\t(expand_epilogue): Likewise.\n\t(avr_print_operand): Print CCP address in case of AVRTINY also.\n\t<TBD>bad address\n\t(function_arg_regno_p): Check different register list for arguments\n\tif AVRTINY.\n\t(init_cumulative_args): Check for AVRTINY to update number of argument\n\tregisters.\n\t(tiny_valid_direct_memory_access_range): New function. Return false if\n\tdirect memory access range is not in accepted range for AVRTINY.\n\t(avr_out_movqi_r_mr_reg_disp_tiny): New function to handle register\n\tindirect load (with displacement) for AVRTINY.\n\t(out_movqi_r_mr): Updated instruction length for AVRTINY. Call\n\tavr_out_movqi_r_mr_reg_disp_tiny for load from reg+displacement.\n\t(avr_out_movhi_r_mr_reg_no_disp_tiny): New function to handle register\n\tindirect load (no displacement) for AVRTINY.\n\t(avr_out_movhi_r_mr_reg_disp_tiny): New function to handle register\n\tindirect load (with displacement) for AVRTINY.\n\t(avr_out_movhi_r_mr_pre_dec_tiny): New function to handle register\n\tindirect load for pre-decrement address.\n\t(out_movhi_r_mr): In case of AVRTINY, call tiny register indirect load\n\tfunctions. Update instruction length for AVRTINY.\n\t(avr_out_movsi_r_mr_reg_no_disp_tiny): New function. Likewise, for\n\tSImode.\n\t(avr_out_movsi_r_mr_reg_disp_tiny): New function. Likewise, for SImode.\n\t(out_movsi_r_mr): Likewise, for SImode.\n\t(avr_out_movsi_mr_r_reg_no_disp_tiny): New function to handle register\n\tindirect store (no displacement) for AVRTINY.\n\t(avr_out_movsi_mr_r_reg_disp_tiny): New function to handle register\n\tindirect store (with displacement) for AVRTINY.\n\t(out_movsi_mr_r): Emit out insn for IO address store. Update store\n\tinstruction's size for AVRTINY. For AVRTINY, call tiny SImode indirect\n\tstore functions.\n\t(avr_out_load_psi_reg_no_disp_tiny): New function to handle register\n\tindirect load (no displacement) for PSImode in AVRTINY.\n\t(avr_out_load_psi_reg_disp_tiny): New function to handle register\n\tindirect load (with displacement) for PSImode in AVRTINY.\n\t(avr_out_load_psi): Call PSImode register indirect load functions for\n\tAVRTINY. Update instruction length for AVRTINY.\n\t(avr_out_store_psi_reg_no_disp_tiny): New function to handle register\n\tindirect store (no displacement) for PSImode in AVRTINY.\n\t(avr_out_store_psi_reg_disp_tiny): New function to handle register\n\tindirect store (with displacement) for PSImode in AVRTINY.\n\t(avr_out_store_psi): Update instruction length for AVRTINY. Call tiny\n\tregister indirect store functions for AVRTINY.\n\t(avr_out_movqi_mr_r_reg_disp_tiny): New function to handle QImode\n\tregister indirect store (with displacement) for AVRTINY.\n\t(out_movqi_mr_r): Update instruction length for AVRTINY. Call tiny\n\tregister indirect store function for QImode in AVRTINY.\n\t(avr_out_movhi_mr_r_xmega): Update instruction length for AVRTINY.\n\t(avr_out_movhi_mr_r_reg_no_disp_tiny): New function to handle register\n\tindirect store (no displacement) for HImode in AVRTINY.\n\t(avr_out_movhi_mr_r_reg_disp_tiny): New function to handle register\n\tindirect store (with displacement) for HImode in AVRTINY.\n\t(avr_out_movhi_mr_r_post_inc_tiny): New function to handle register\n\tindirect store for post-increment address in HImode.\n\t(out_movhi_mr_r): Update instruction length for AVRTINY. Call tiny\n\tregister indirect store function for HImode in AVRTINY.\n\t(avr_out_compare): Use TINY_SBIW/ TINY_ADIW in place of sbiw/adiw\n\tin case of AVRTINY.\n\t(order_regs_for_local_alloc): Updated register allocation order for\n\tAVRTINY.\n\t(avr_conditional_register_usage): New function. It is a target hook\n\t(TARGET_CONDITIONAL_REGISTER_USAGE) function which updates fixed, call\n\tused registers list and register allocation order for AVRTINY.\n\t(avr_return_in_memory): Update return value size for AVRTINY.\n\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): Added builtin macros\n\tfor AVRTINY arch and tiny program memory base address.\n\t* config/avr/avr-devices.c (avr_arch_types): Added AVRTINY arch.\n\t(avr_texinfo): Added description for AVRTINY arch.\n\t* config/avr/avr.h: Added macro to identify AVRTINY arch. Updated\n\tSTATIC_CHAIN_REGNUM for AVRTINY.\n\t* config/avr/avr-mcus.def: Added AVRTINY arch devices.\n\t* config/avr/avr.md: Added constants for tmp/ zero registers in\n\tAVRTINY. Attributes for AVRTINY added.\n\t(mov<mode>): Move src/ dest address to register if it is not in AVRTINY\n\tmemory access range.\n\t(mov<mode>_insn): Avoid QImode direct load for AVRTINY if address not\n\tin AVRTINY memory access range.\n\t(*mov<mode>): Likewise for HImode and SImode.\n\t(*movsf): Likewise for SFmode.\n\t(delay_cycles_2): Updated instructions to be emitted as AVRTINY does\n\tnot have sbiw.\n\t* config/avr/avr-protos.h: Added function prototype for\n\ttiny_valid_direct_memory_access_range.\n\t* config/avr/avr-tables.opt: Regenerate.\n\t* gcc/config/avr/t-multilib: Regenerate.\n\t* doc/avr-mmcu.texi: Regenerate.\n\ngcc/testsuite:\n\n2014-10-21  Joern Rennecke  <joern.rennecke@embecosm.com>\n\n\t* gcc.target/avr/tiny-memx.c: New test.\n\n\t* gcc.target/avr/tiny-caller-save.c: New test.\n\nlibgcc:\n\n2014-10-21  Joern Rennecke  <joern.rennecke@embecosm.com>\n\t    Vidya Praveen <vidya.praveen@atmel.com>\n\t    Praveen Kumar Kaushik <Praveen_Kumar.Kaushik@atmel.com>\n\t    Senthil Kumar Selvaraj <Senthil_Kumar.Selvaraj@atmel.com>\n\t    Pitchumani Sivanupandi <Pitchumani.S@atmel.com>\n\n\t* config/avr/lib1funcs.S (__do_global_dtors): Go back to descending\n\torder.\n\n\tUpdated library functions for AVRTINY arch.\n\t* config/avr/lib1funcs.S: Updated zero/tmp regs for AVRTINY.\n\tReplaced occurrences of r0/r1 with tmp/zero reg macros.\n\tAdded wsubi/ wadi macros that expands conditionally as sbiw/ adiw\n\tor AVRTINY equivalent. Replaced occurrences of sbiw/adiw with\n\twsubi/wadi macors.\n\t(__mulsi3_helper): Update stack, preserve callee saved regs and\n\targument from stack. Restore callee save registers.\n\t(__mulpsi3): Likewise.\n\t(__muldi3, __udivmodsi4, __divmodsi4, __negsi2, __umoddi3, __udivmod64,\n\t__moddi3, __adddi3, __adddi3_s8, __subdi3, __cmpdi2, __cmpdi2_s8,\n\t__negdi2, __prologue_saves__, __epilogue_restores__): Excluded for \n\tAVRTINY.\n\t(__tablejump2__): Added lpm equivalent instructions for AVRTINY.\n\t(__do_copy_data): Added new definition for AVRTINY.\n\t(__do_clear_bss): Replace r17 by r18 to preserve zero reg for AVRTINY.\n\t(__load_3, __load_4, __xload_1, __xload_2, __xload_3,\n\t__xload_4, __movmemx_qi, __movmemx_hi): Excluded for AVRTINY.\n\t* config/avr/lib1funcs-fixed.S: Replaced occurrences of r0/r1 with\n\ttmp/zero reg macros. Replaced occurrences of sbiw/adiw with wsubi/wadi\n\tmacors.\n\t   * config/avr/t-avr (LIB1ASMFUNCS): Remove unsupported functions for\n\tAVRTINY.\n\n\tFix broken long multiplication on tiny arch.         \n\n\nCo-Authored-By: Pitchumani Sivanupandi <pitchumani.s@atmel.com>\nCo-Authored-By: Praveen Kumar Kaushik <Praveen_Kumar.Kaushik@atmel.com>\nCo-Authored-By: Senthil Kumar Selvaraj <Senthil_Kumar.Selvaraj@atmel.com>\nCo-Authored-By: Vidya Praveen <vidya.praveen@atmel.com>\n\nFrom-SVN: r216525", "tree": {"sha": "8a99b2fe7809176559637dc20e6524507bc78c4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a99b2fe7809176559637dc20e6524507bc78c4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1dd9790241595c417b028842bf0a7d4b2cf253a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1dd9790241595c417b028842bf0a7d4b2cf253a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1dd9790241595c417b028842bf0a7d4b2cf253a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1dd9790241595c417b028842bf0a7d4b2cf253a/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d1bcc29f799a1d2d04fae6adf3b732b51a9259a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1bcc29f799a1d2d04fae6adf3b732b51a9259a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1bcc29f799a1d2d04fae6adf3b732b51a9259a6"}], "stats": {"total": 1583, "additions": 1429, "deletions": 154}, "files": [{"sha": "6d5e2cc908d1e1212d9eac3d9b489d9fd225916a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -1,3 +1,119 @@\n+2014-10-21  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\t    Vidya Praveen <vidya.praveen@atmel.com>\n+\t    Praveen Kumar Kaushik <Praveen_Kumar.Kaushik@atmel.com>\n+\t    Senthil Kumar Selvaraj <Senthil_Kumar.Selvaraj@atmel.com>\n+\t    Pitchumani Sivanupandi <Pitchumani.S@atmel.com>\n+\n+\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): Don't define\n+\t__MEMX for avrtiny.\n+\t* config/avr/avr.c (avr_insert_attributes): Reject __memx for avrtiny.\n+\t(avr_nonconst_pointer_addrspace): Likewise.\n+\t* config/avr/avr.h (AVR_HAVE_LPM): Define.\n+\n+\tAdded AVRTINY architecture to avr target.\n+\t* config/avr/avr-arch.h (avr_arch): Added AVRTINY architecture.\n+\t(base_arch_s): member added for AVRTINY architecture.\n+\t* config/avr/avr.c: Added TINY_ADIW, TINY_SBIW macros as AVRTINY\n+\talternate for adiw/sbiw instructions. Added AVR_TMP_REGNO and\n+\tAVR_ZERO_REGNO macros for tmp and zero registers. Replaced TMP_REGNO\n+\tand ZERO_REGNO occurrences by AVR_TMP_REGNO and AVR_ZERO_REGNO\n+\trespectively. LAST_CALLEE_SAVED_REG macro added for the last register\n+\tin callee saved register list.\n+\t(avr_option_override): CCP address updated for AVRTINY.\n+\t(avr_init_expanders): tmp and zero rtx initialized as per arch.\n+\tReset avr_have_dimode if AVRTINY.\n+\t(sequent_regs_live): Use LAST_CALLEE_SAVED_REG instead magic number.\n+\t(emit_push_sfr): Use AVR_TMP_REGNO for tmp register number.\n+\t(avr_prologue_setup_frame): Don't minimize prologue if AVRTINY.\n+\tUse LAST_CALLEE_SAVED_REG to refer last callee saved register.\n+\t(expand_epilogue): Likewise.\n+\t(avr_print_operand): Print CCP address in case of AVRTINY also.\n+\t<TBD>bad address\n+\t(function_arg_regno_p): Check different register list for arguments\n+\tif AVRTINY.\n+\t(init_cumulative_args): Check for AVRTINY to update number of argument\n+\tregisters.\n+\t(tiny_valid_direct_memory_access_range): New function. Return false if\n+\tdirect memory access range is not in accepted range for AVRTINY.\n+\t(avr_out_movqi_r_mr_reg_disp_tiny): New function to handle register\n+\tindirect load (with displacement) for AVRTINY.\n+\t(out_movqi_r_mr): Updated instruction length for AVRTINY. Call\n+\tavr_out_movqi_r_mr_reg_disp_tiny for load from reg+displacement.\n+\t(avr_out_movhi_r_mr_reg_no_disp_tiny): New function to handle register\n+\tindirect load (no displacement) for AVRTINY.\n+\t(avr_out_movhi_r_mr_reg_disp_tiny): New function to handle register\n+\tindirect load (with displacement) for AVRTINY.\n+\t(avr_out_movhi_r_mr_pre_dec_tiny): New function to handle register\n+\tindirect load for pre-decrement address.\n+\t(out_movhi_r_mr): In case of AVRTINY, call tiny register indirect load\n+\tfunctions. Update instruction length for AVRTINY.\n+\t(avr_out_movsi_r_mr_reg_no_disp_tiny): New function. Likewise, for\n+\tSImode.\n+\t(avr_out_movsi_r_mr_reg_disp_tiny): New function. Likewise, for SImode.\n+\t(out_movsi_r_mr): Likewise, for SImode.\n+\t(avr_out_movsi_mr_r_reg_no_disp_tiny): New function to handle register\n+\tindirect store (no displacement) for AVRTINY.\n+\t(avr_out_movsi_mr_r_reg_disp_tiny): New function to handle register\n+\tindirect store (with displacement) for AVRTINY.\n+\t(out_movsi_mr_r): Emit out insn for IO address store. Update store\n+\tinstruction's size for AVRTINY. For AVRTINY, call tiny SImode indirect\n+\tstore functions.\n+\t(avr_out_load_psi_reg_no_disp_tiny): New function to handle register\n+\tindirect load (no displacement) for PSImode in AVRTINY.\n+\t(avr_out_load_psi_reg_disp_tiny): New function to handle register\n+\tindirect load (with displacement) for PSImode in AVRTINY.\n+\t(avr_out_load_psi): Call PSImode register indirect load functions for\n+\tAVRTINY. Update instruction length for AVRTINY.\n+\t(avr_out_store_psi_reg_no_disp_tiny): New function to handle register\n+\tindirect store (no displacement) for PSImode in AVRTINY.\n+\t(avr_out_store_psi_reg_disp_tiny): New function to handle register\n+\tindirect store (with displacement) for PSImode in AVRTINY.\n+\t(avr_out_store_psi): Update instruction length for AVRTINY. Call tiny\n+\tregister indirect store functions for AVRTINY.\n+\t(avr_out_movqi_mr_r_reg_disp_tiny): New function to handle QImode\n+\tregister indirect store (with displacement) for AVRTINY.\n+\t(out_movqi_mr_r): Update instruction length for AVRTINY. Call tiny\n+\tregister indirect store function for QImode in AVRTINY.\n+\t(avr_out_movhi_mr_r_xmega): Update instruction length for AVRTINY.\n+\t(avr_out_movhi_mr_r_reg_no_disp_tiny): New function to handle register\n+\tindirect store (no displacement) for HImode in AVRTINY.\n+\t(avr_out_movhi_mr_r_reg_disp_tiny): New function to handle register\n+\tindirect store (with displacement) for HImode in AVRTINY.\n+\t(avr_out_movhi_mr_r_post_inc_tiny): New function to handle register\n+\tindirect store for post-increment address in HImode.\n+\t(out_movhi_mr_r): Update instruction length for AVRTINY. Call tiny\n+\tregister indirect store function for HImode in AVRTINY.\n+\t(avr_out_compare): Use TINY_SBIW/ TINY_ADIW in place of sbiw/adiw\n+\tin case of AVRTINY.\n+\t(order_regs_for_local_alloc): Updated register allocation order for\n+\tAVRTINY.\n+\t(avr_conditional_register_usage): New function. It is a target hook\n+\t(TARGET_CONDITIONAL_REGISTER_USAGE) function which updates fixed, call\n+\tused registers list and register allocation order for AVRTINY.\n+\t(avr_return_in_memory): Update return value size for AVRTINY.\n+\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): Added builtin macros\n+\tfor AVRTINY arch and tiny program memory base address.\n+\t* config/avr/avr-devices.c (avr_arch_types): Added AVRTINY arch.\n+\t(avr_texinfo): Added description for AVRTINY arch.\n+\t* config/avr/avr.h: Added macro to identify AVRTINY arch. Updated\n+\tSTATIC_CHAIN_REGNUM for AVRTINY.\n+\t* config/avr/avr-mcus.def: Added AVRTINY arch devices.\n+\t* config/avr/avr.md: Added constants for tmp/ zero registers in\n+\tAVRTINY. Attributes for AVRTINY added.\n+\t(mov<mode>): Move src/ dest address to register if it is not in AVRTINY\n+\tmemory access range.\n+\t(mov<mode>_insn): Avoid QImode direct load for AVRTINY if address not\n+\tin AVRTINY memory access range.\n+\t(*mov<mode>): Likewise for HImode and SImode.\n+\t(*movsf): Likewise for SFmode.\n+\t(delay_cycles_2): Updated instructions to be emitted as AVRTINY does\n+\tnot have sbiw.\n+\t* config/avr/avr-protos.h: Added function prototype for\n+\ttiny_valid_direct_memory_access_range.\n+\t* config/avr/avr-tables.opt: Regenerate.\n+\t* gcc/config/avr/t-multilib: Regenerate.\n+\t* doc/avr-mmcu.texi: Regenerate.\n+\n 2014-10-21  Andrew Pinski  <apinski@cavium.com>\n \n \t* doc/invoke.texi (AARCH64/mtune): Document thunderx as an"}, {"sha": "168793efccb2c4f7bd708ee202194ccc59b89d39", "filename": "gcc/config/avr/avr-arch.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-arch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-arch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-arch.h?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -37,6 +37,7 @@ enum avr_arch\n   ARCH_AVR5,\n   ARCH_AVR51,\n   ARCH_AVR6,\n+  ARCH_AVRTINY,\n   ARCH_AVRXMEGA2,\n   ARCH_AVRXMEGA4,\n   ARCH_AVRXMEGA5,\n@@ -77,6 +78,9 @@ typedef struct\n      and thus also the RAMPX, RAMPY and RAMPZ registers.  */\n   int have_rampd;\n \n+  /* This is a TINY core. */\n+  int tiny_p;\n+\n   /* Default start of data section address for architecture.  */\n   int default_data_section_start;\n "}, {"sha": "f66f36186f7758e133cbd2a586ba4a9939655d03", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -321,6 +321,23 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n     }\n   if (AVR_XMEGA)\n     cpp_define (pfile, \"__AVR_XMEGA__\");\n+\n+  if (AVR_TINY)\n+    {\n+      cpp_define (pfile, \"__AVR_TINY__\");\n+\n+      /* Define macro \"__AVR_TINY_PM_BASE_ADDRESS__\" with mapped program memory\n+         start address. This macro shall be referred where mapped program memory\n+         is accessed. (Eg. copying data section (do_copy_data) contents to data\n+         memory region.\n+         NOTE:\n+         Program memory of AVR_TINY devices can not be accessed directly, it has\n+         been mapped to the data memory. For AVR_TINY devices (ATtiny4/ 5/ 9/ 10/\n+         20 and 40) mapped program memory starts at 0x4000.\n+      */\n+      cpp_define (pfile, \"__AVR_TINY_PM_BASE_ADDRESS__=0x4000\");\n+    }\n+\n   if (avr_current_arch->have_eijmp_eicall)\n     {\n       cpp_define (pfile, \"__AVR_HAVE_EIJMP_EICALL__\");\n@@ -376,7 +393,10 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n             /* Only supply __FLASH<n> macro if the address space is reasonable\n                for this target.  The address space qualifier itself is still\n                supported, but using it will throw an error.  */\n-            && avr_addrspace[i].segment < avr_n_flash)\n+            && avr_addrspace[i].segment < avr_n_flash\n+\t    /* Only support __MEMX macro if we have LPM.  */\n+\t    && (AVR_HAVE_LPM || avr_addrspace[i].pointer_size <= 2))\n+\n           {\n             const char *name = avr_addrspace[i].name;\n             char *Name = (char*) alloca (1 + strlen (name));"}, {"sha": "a926d2055cb4688cfe72be6b8d4e72b490d2be1b", "filename": "gcc/config/avr/avr-devices.c", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-devices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-devices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-devices.c?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -31,29 +31,30 @@ const avr_arch_t\n avr_arch_types[] =\n {\n   /* unknown device specified */\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, NULL,              \"avr2\"  },\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, NULL,  \"avr2\"  },\n   /*\n-    A  M  J  LM E  E  E  X  R   d S   S O   A\n-    S  U  M  PO L  L  I  M  A   a t   F ff  r\n-    M  L  P  MV P  P  J  E  M   t a   R s   c\n-             XW M  M  M  G  P   a r     e   h\n-                   X  P  A  D     t     t   ID   */\n-  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"1\",   \"avr1\"  },\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"2\",   \"avr2\"  },\n-  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, \"25\",  \"avr25\" },\n-  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"3\",   \"avr3\"  },\n-  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0x0060, 32, \"31\",  \"avr31\" },\n-  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, \"35\",  \"avr35\" },\n-  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, \"4\",   \"avr4\"  },\n-  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, \"5\",   \"avr5\"  },\n-  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, \"51\",  \"avr51\" },\n-  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0x0060, 32, \"6\",   \"avr6\"  },\n+    A  M  J  LM E  E  E  X  R  T  d S   S O   A\n+    S  U  M  PO L  L  I  M  A  I  a t   F ff  r\n+    M  L  P  MV P  P  J  E  M  N  t a   R s   c\n+             XW M  M  M  G  P  Y  a r     e   h\n+                   X  P  A  D       t     t   ID   */\n+  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"1\",   \"avr1\"  },\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"2\",   \"avr2\"  },\n+  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"25\",  \"avr25\" },\n+  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"3\",   \"avr3\"  },\n+  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, \"31\",  \"avr31\" },\n+  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"35\",  \"avr35\" },\n+  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"4\",   \"avr4\"  },\n+  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, \"5\",   \"avr5\"  },\n+  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0x0060, 32, \"51\",  \"avr51\" },\n+  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, \"6\",   \"avr6\"  },\n \n-  { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0x2000,  0, \"102\", \"avrxmega2\" },\n-  { 0, 1, 1, 1, 1, 1, 0, 1, 0, 0x2000,  0, \"104\", \"avrxmega4\" },\n-  { 0, 1, 1, 1, 1, 1, 0, 1, 1, 0x2000,  0, \"105\", \"avrxmega5\" },\n-  { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0x2000,  0, \"106\", \"avrxmega6\" },\n-  { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0x2000,  0, \"107\", \"avrxmega7\" }\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0x0040,  0, \"100\", \"avrtiny\" },\n+  { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0x2000,  0, \"102\", \"avrxmega2\" },\n+  { 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0x2000,  0, \"104\", \"avrxmega4\" },\n+  { 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0x2000,  0, \"105\", \"avrxmega5\" },\n+  { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0x2000,  0, \"106\", \"avrxmega6\" },\n+  { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0x2000,  0, \"107\", \"avrxmega7\" }\n };\n \n const avr_arch_info_t\n@@ -85,6 +86,9 @@ avr_texinfo[] =\n   { ARCH_AVR6,\n     \"``Enhanced'' devices with 3-byte PC, i.e.@: with more than 128@tie{}KiB \"\n     \"of program memory.\" },\n+  { ARCH_AVRTINY,\n+    \"``TINY'' Tiny core devices with 512@tie{}B up to 4@tie{}KiB of \"\n+    \"program memory.\" },\n   { ARCH_AVRXMEGA2,\n     \"``XMEGA'' devices with more than 8@tie{}KiB and up to 64@tie{}KiB \"\n     \"of program memory.\" },"}, {"sha": "e890149f158b2ca1e74254183dd1bf2c43710924", "filename": "gcc/config/avr/avr-mcus.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-mcus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-mcus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-mcus.def?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -326,6 +326,14 @@ AVR_MCU (\"avrxmega7\",        ARCH_AVRXMEGA7, AVR_ISA_NONE, NULL,\n AVR_MCU (\"atxmega128a1\",     ARCH_AVRXMEGA7, AVR_ISA_NONE, \"__AVR_ATxmega128A1__\",     0x2000, 0x0, 3, \"x128a1\")\n AVR_MCU (\"atxmega128a1u\",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  \"__AVR_ATxmega128A1U__\",    0x2000, 0x0, 3, \"x128a1u\")\n AVR_MCU (\"atxmega128a4u\",    ARCH_AVRXMEGA7, AVR_ISA_RMW,  \"__AVR_ATxmega128A4U__\",    0x2000, 0x0, 3, \"x128a4u\")\n+/* Tiny family */\n+AVR_MCU (\"avrtiny\",          ARCH_AVRTINY,   AVR_ISA_NONE, NULL,                       0x0040, 0x0, 1, \"tn10\")\n+AVR_MCU (\"attiny4\",          ARCH_AVRTINY,   AVR_ISA_NONE, \"__AVR_ATtiny4__\",          0x0040, 0x0, 1, \"tn4\")\n+AVR_MCU (\"attiny5\",          ARCH_AVRTINY,   AVR_ISA_NONE, \"__AVR_ATtiny5__\",          0x0040, 0x0, 1, \"tn5\")\n+AVR_MCU (\"attiny9\",          ARCH_AVRTINY,   AVR_ISA_NONE, \"__AVR_ATtiny9__\",          0x0040, 0x0, 1, \"tn9\") \n+AVR_MCU (\"attiny10\",         ARCH_AVRTINY,   AVR_ISA_NONE, \"__AVR_ATtiny10__\",         0x0040, 0x0, 1, \"tn10\")\n+AVR_MCU (\"attiny20\",         ARCH_AVRTINY,   AVR_ISA_NONE, \"__AVR_ATtiny20__\",         0x0040, 0x0, 1, \"tn20\")\n+AVR_MCU (\"attiny40\",         ARCH_AVRTINY,   AVR_ISA_NONE, \"__AVR_ATtiny40__\",         0x0040, 0x0, 1, \"tn40\")\n /* Assembler only.  */\n AVR_MCU (\"avr1\",                 ARCH_AVR1, AVR_ISA_NONE, NULL,                        0x0060, 0x0, 1, \"s1200\")\n AVR_MCU (\"at90s1200\",            ARCH_AVR1, AVR_ISA_NONE, \"__AVR_AT90S1200__\",         0x0060, 0x0, 1, \"s1200\")"}, {"sha": "6342c087d4a76d1afc939ffc8701b0d27cc0a829", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -46,6 +46,7 @@ extern void avr_init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx, tree);\n \n #ifdef RTX_CODE\n extern int avr_hard_regno_call_part_clobbered (unsigned, enum machine_mode);\n+extern bool tiny_valid_direct_memory_access_range(rtx, enum machine_mode);\n extern const char *output_movqi (rtx_insn *insn, rtx operands[], int *l);\n extern const char *output_movhi (rtx_insn *insn, rtx operands[], int *l);\n extern const char *output_movsisf (rtx_insn *insn, rtx operands[], int *l);"}, {"sha": "c7e72c2ad7734db607dd955ce6b805e4da86c770", "filename": "gcc/config/avr/avr-tables.opt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-tables.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr-tables.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-tables.opt?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -65,6 +65,9 @@ Enum(avr_arch) String(avrxmega6) Value(ARCH_AVRXMEGA6)\n EnumValue\n Enum(avr_arch) String(avrxmega7) Value(ARCH_AVRXMEGA7)\n \n+EnumValue\n+Enum(avr_arch) String(avrtiny) Value(ARCH_AVRTINY)\n+\n EnumValue\n Enum(avr_arch) String(avr1) Value(ARCH_AVR1)\n "}, {"sha": "6c781c9466d7f334e2abccdc692c76699b1ac429", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 845, "deletions": 60, "changes": 905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -88,6 +88,17 @@\n   ((SYMBOL_REF_FLAGS (sym) & AVR_SYMBOL_FLAG_PROGMEM)           \\\n    / SYMBOL_FLAG_MACH_DEP)\n \n+#define TINY_ADIW(REG1, REG2, I)                                \\\n+    \"subi \" #REG1 \",lo8(-(\" #I \"))\" CR_TAB                        \\\n+    \"sbci \" #REG2 \",hi8(-(\" #I \"))\"        \n+\n+#define TINY_SBIW(REG1, REG2, I)                                \\\n+    \"subi \" #REG1 \",lo8((\" #I \"))\" CR_TAB                         \\\n+    \"sbci \" #REG2 \",hi8((\" #I \"))\"        \n+\n+#define AVR_TMP_REGNO (AVR_TINY ? TMP_REGNO_TINY : TMP_REGNO)\n+#define AVR_ZERO_REGNO (AVR_TINY ? ZERO_REGNO_TINY : ZERO_REGNO)\n+\n /* Known address spaces.  The order must be the same as in the respective\n    enum from avr.h (or designated initialized must be used).  */\n const avr_addrspace_t avr_addrspace[ADDR_SPACE_COUNT] =\n@@ -156,6 +167,9 @@ static bool avr_rtx_costs (rtx, int, int, int, int*, bool);\n /* Allocate registers from r25 to r8 for parameters for function calls.  */\n #define FIRST_CUM_REG 26\n \n+/* Last call saved register */\n+#define LAST_CALLEE_SAVED_REG (AVR_TINY ? 19 : 17)\n+\n /* Implicit target register of LPM instruction (R0) */\n extern GTY(()) rtx lpm_reg_rtx;\n rtx lpm_reg_rtx;\n@@ -365,7 +379,7 @@ avr_option_override (void)\n   avr_addr.rampy = 0x3A + avr_current_arch->sfr_offset;\n   avr_addr.rampx = 0x39 + avr_current_arch->sfr_offset;\n   avr_addr.rampd = 0x38 + avr_current_arch->sfr_offset;\n-  avr_addr.ccp = 0x34 + avr_current_arch->sfr_offset;\n+  avr_addr.ccp = (AVR_TINY ? 0x3C : 0x34) + avr_current_arch->sfr_offset;\n \n   /* SP: Stack Pointer (SP_H:SP_L) */\n   avr_addr.sp_l = 0x3D + avr_current_arch->sfr_offset;\n@@ -397,8 +411,8 @@ avr_init_expanders (void)\n     all_regs_rtx[regno] = gen_rtx_REG (QImode, regno);\n \n   lpm_reg_rtx  = all_regs_rtx[LPM_REGNO];\n-  tmp_reg_rtx  = all_regs_rtx[TMP_REGNO];\n-  zero_reg_rtx = all_regs_rtx[ZERO_REGNO];\n+  tmp_reg_rtx  = all_regs_rtx[AVR_TMP_REGNO];\n+  zero_reg_rtx = all_regs_rtx[AVR_ZERO_REGNO];\n \n   lpm_addr_reg_rtx = gen_rtx_REG (HImode, REG_Z);\n \n@@ -410,6 +424,11 @@ avr_init_expanders (void)\n \n   xstring_empty = gen_rtx_CONST_STRING (VOIDmode, \"\");\n   xstring_e = gen_rtx_CONST_STRING (VOIDmode, \"e\");\n+\n+  /* TINY core does not have regs r10-r16, but avr-dimode.md expects them\n+     to be present */\n+  if (AVR_TINY)\n+    avr_have_dimode = false; \n }\n \n \n@@ -918,7 +937,7 @@ sequent_regs_live (void)\n   int live_seq = 0;\n   int cur_seq = 0;\n \n-  for (reg = 0; reg < 18; ++reg)\n+  for (reg = 0; reg <= LAST_CALLEE_SAVED_REG; ++reg)\n     {\n       if (fixed_regs[reg])\n         {\n@@ -1031,7 +1050,7 @@ emit_push_sfr (rtx sfr, bool frame_related_p, bool clr_p)\n     RTX_FRAME_RELATED_P (insn) = 1;\n \n   /* PUSH __tmp_reg__ */\n-  emit_push_byte (TMP_REGNO, frame_related_p);\n+  emit_push_byte (AVR_TMP_REGNO, frame_related_p);\n \n   if (clr_p)\n     {\n@@ -1057,7 +1076,8 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n                    && live_seq\n                    && !isr_p\n                    && !cfun->machine->is_OS_task\n-                   && !cfun->machine->is_OS_main);\n+                   && !cfun->machine->is_OS_main\n+                   && !AVR_TINY);\n \n   if (minimize\n       && (frame_pointer_needed\n@@ -1094,11 +1114,11 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n       /* Note that live_seq always contains r28+r29, but the other\n          registers to be saved are all below 18.  */\n \n-      first_reg = 18 - (live_seq - 2);\n+      first_reg = (LAST_CALLEE_SAVED_REG + 1) - (live_seq - 2);\n \n       for (reg = 29, offset = -live_seq + 1;\n            reg >= first_reg;\n-           reg = (reg == 28 ? 17 : reg - 1), ++offset)\n+           reg = (reg == 28 ? LAST_CALLEE_SAVED_REG : reg - 1), ++offset)\n         {\n           rtx m, r;\n \n@@ -1338,10 +1358,10 @@ avr_expand_prologue (void)\n         emit_insn (gen_enable_interrupt ());\n \n       /* Push zero reg.  */\n-      emit_push_byte (ZERO_REGNO, true);\n+      emit_push_byte (AVR_ZERO_REGNO, true);\n \n       /* Push tmp reg.  */\n-      emit_push_byte (TMP_REGNO, true);\n+      emit_push_byte (AVR_TMP_REGNO, true);\n \n       /* Push SREG.  */\n       /* ??? There's no dwarf2 column reserved for SREG.  */\n@@ -1483,7 +1503,8 @@ avr_expand_epilogue (bool sibcall_p)\n               && live_seq\n               && !isr_p\n               && !cfun->machine->is_OS_task\n-              && !cfun->machine->is_OS_main);\n+              && !cfun->machine->is_OS_main\n+              && !AVR_TINY);\n \n   if (minimize\n       && (live_seq > 4\n@@ -1641,14 +1662,14 @@ avr_expand_epilogue (bool sibcall_p)\n \n       /* Restore SREG using tmp_reg as scratch.  */\n \n-      emit_pop_byte (TMP_REGNO);\n+      emit_pop_byte (AVR_TMP_REGNO);\n       emit_move_insn (sreg_rtx, tmp_reg_rtx);\n \n       /* Restore tmp REG.  */\n-      emit_pop_byte (TMP_REGNO);\n+      emit_pop_byte (AVR_TMP_REGNO);\n \n       /* Restore zero REG.  */\n-      emit_pop_byte (ZERO_REGNO);\n+      emit_pop_byte (AVR_ZERO_REGNO);\n     }\n \n   if (!sibcall_p)\n@@ -2130,10 +2151,14 @@ avr_print_operand_punct_valid_p (unsigned char code)\n static void\n avr_print_operand (FILE *file, rtx x, int code)\n {\n-  int abcd = 0;\n+  int abcd = 0, ef = 0, ij = 0;\n \n   if (code >= 'A' && code <= 'D')\n     abcd = code - 'A';\n+  else if (code == 'E' || code == 'F')\n+    ef = code - 'E';\n+  else if (code == 'I' || code == 'J')\n+    ij = code - 'I';\n \n   if (code == '~')\n     {\n@@ -2170,6 +2195,16 @@ avr_print_operand (FILE *file, rtx x, int code)\n       else\n         fatal_insn (\"operands to %T/%t must be reg + const_int:\", x);\n     }\n+  else if (code == 'E' || code == 'F')\n+    {\n+      rtx op = XEXP(x, 0);\n+      fprintf (file, reg_names[REGNO (op) + ef]);\n+    }\n+  else if (code == 'I' || code == 'J')\n+    {\n+      rtx op = XEXP(XEXP(x, 0), 0);\n+      fprintf (file, reg_names[REGNO (op) + ij]);\n+    }\n   else if (REG_P (x))\n     {\n       if (x == zero_reg_rtx)\n@@ -2196,7 +2231,7 @@ avr_print_operand (FILE *file, rtx x, int code)\n             fprintf (file, \"__RAMPX__\");\n           else if (AVR_HAVE_RAMPD && ival == avr_addr.rampd)\n             fprintf (file, \"__RAMPD__\");\n-          else if (AVR_XMEGA && ival == avr_addr.ccp)\n+          else if ((AVR_XMEGA || AVR_TINY) && ival == avr_addr.ccp)\n             fprintf (file, \"__CCP__\");\n           else if (ival == avr_addr.sreg)   fprintf (file, \"__SREG__\");\n           else if (ival == avr_addr.sp_l)   fprintf (file, \"__SP_L__\");\n@@ -2239,6 +2274,13 @@ avr_print_operand (FILE *file, rtx x, int code)\n \n           avr_print_operand (file, XEXP (addr, 1), 0);\n         }\n+      else if (code == 'b')\n+        {\n+          if (GET_CODE (addr) != PLUS)\n+               fatal_insn (\"bad address, not (reg+disp):\", addr);\n+\n+          avr_print_operand_address (file, XEXP (addr, 0));\n+        }\n       else if (code == 'p' || code == 'r')\n         {\n           if (GET_CODE (addr) != POST_INC && GET_CODE (addr) != PRE_DEC)\n@@ -2596,7 +2638,7 @@ avr_simplify_comparison_p (enum machine_mode mode, RTX_CODE op, rtx x)\n int\n avr_function_arg_regno_p(int r)\n {\n-  return (r >= 8 && r <= 25);\n+  return (AVR_TINY ? r >= 20 && r <= 25 : r >= 8 && r <= 25);\n }\n \n \n@@ -2608,7 +2650,7 @@ void\n avr_init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype, rtx libname,\n                           tree fndecl ATTRIBUTE_UNUSED)\n {\n-  cum->nregs = 18;\n+  cum->nregs = AVR_TINY ? 6 : 18;\n   cum->regno = FIRST_CUM_REG;\n   if (!libname && stdarg_p (fntype))\n     cum->nregs = 0;\n@@ -3144,6 +3186,35 @@ avr_out_xload (rtx_insn *insn ATTRIBUTE_UNUSED, rtx *op, int *plen)\n   return \"\";\n }\n \n+/*\n+AVRTC-579\n+if operand is symbol or constant expression with value > 0xbf\n+  return false, otherwise true\n+This check is used to avoid lds/sts instruction with invalid memory\n+access range (valid range 0x40..0xbf). For io operand range 0x0..0x3f,\n+in/out instruction will be generated.\n+*/\n+bool tiny_valid_direct_memory_access_range(rtx op, enum machine_mode mode)\n+{\n+  rtx x;\n+\n+  if (!AVR_TINY)\n+    return true;\n+\n+  x = XEXP(op,0);\n+\n+  if (MEM_P(op) && x && (GET_CODE(x) == SYMBOL_REF))\n+  {\n+    return false;\n+  }\n+  if (MEM_P(op) && x && (CONSTANT_ADDRESS_P (x)) &&\n+     !(IN_RANGE (INTVAL (x), 0, 0xC0 - GET_MODE_SIZE (mode))))\n+  {\n+    return false;\n+  }\n+\n+  return true;\n+}\n \n const char*\n output_movqi (rtx_insn *insn, rtx operands[], int *plen)\n@@ -3272,6 +3343,24 @@ output_movhi (rtx_insn *insn, rtx xop[], int *plen)\n   return \"\";\n }\n \n+/* Same as out_movqi_r_mr, but TINY does not have ADIW or SBIW */\n+static const char*\n+avr_out_movqi_r_mr_reg_disp_tiny (rtx_insn *insn, rtx op[], int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx x = XEXP (src, 0);\n+\n+  avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n+          \"ld %0,%b1\" , op, plen, -3);\n+\n+  if (!reg_overlap_mentioned_p (dest, XEXP (x,0))\n+          && !reg_unused_after (insn, XEXP (x,0)))\n+      avr_asm_len (TINY_SBIW (%I1, %J1, %o1), op, plen, 2);\n+\n+  return \"\";\n+}\n+\n static const char*\n out_movqi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n {\n@@ -3281,18 +3370,23 @@ out_movqi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n \n   if (CONSTANT_ADDRESS_P (x))\n     {\n+      int n_words = AVR_TINY ? 1 : 2;\n       return optimize > 0 && io_address_operand (x, QImode)\n         ? avr_asm_len (\"in %0,%i1\", op, plen, -1)\n-        : avr_asm_len (\"lds %0,%m1\", op, plen, -2);\n+        : avr_asm_len (\"lds %0,%m1\", op, plen, -n_words);\n     }\n-  else if (GET_CODE (x) == PLUS\n+\n+  if (GET_CODE (x) == PLUS\n            && REG_P (XEXP (x, 0))\n            && CONST_INT_P (XEXP (x, 1)))\n     {\n       /* memory access by reg+disp */\n \n       int disp = INTVAL (XEXP (x, 1));\n \n+      if (AVR_TINY)\n+        return avr_out_movqi_r_mr_reg_disp_tiny (insn, op, plen);\n+\n       if (disp - GET_MODE_SIZE (GET_MODE (src)) >= 63)\n         {\n           if (REGNO (XEXP (x, 0)) != REG_Y)\n@@ -3332,6 +3426,82 @@ out_movqi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n   return avr_asm_len (\"ld %0,%1\", op, plen, -1);\n }\n \n+/* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */\n+static const char*\n+avr_out_movhi_r_mr_reg_no_disp_tiny (rtx op[], int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (src, 0);\n+\n+  int reg_dest = true_regnum (dest);\n+  int reg_base = true_regnum (base);\n+\n+  if (reg_dest == reg_base)         /* R = (R) */\n+      return avr_asm_len (\"ld __tmp_reg__,%1+\" CR_TAB\n+              \"ld %B0,%1\"          CR_TAB\n+              \"mov %A0,__tmp_reg__\", op, plen, -3);\n+\n+  return avr_asm_len (\"ld %A0,%1\"             CR_TAB                        \n+          TINY_ADIW (%E1, %F1, 1) CR_TAB                       \n+          \"ld %B0,%1\"             CR_TAB                        \n+          TINY_SBIW (%E1, %F1, 1), op, plen, -6);\n+\n+}\n+\n+/* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */\n+static const char*\n+avr_out_movhi_r_mr_reg_disp_tiny (rtx op[], int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (src, 0);\n+\n+  int reg_dest = true_regnum (dest);\n+  int reg_base = true_regnum (XEXP (base, 0));\n+\n+  if (reg_base == reg_dest)\n+  {\n+      return avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n+              \"ld __tmp_reg__,%b1+\"    CR_TAB\n+              \"ld %B0,%b1\"             CR_TAB \n+              \"mov %A0,__tmp_reg__\", op, plen, -5);\n+  }\n+  else\n+  {\n+      return avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n+              \"ld %A0,%b1+\"             CR_TAB\n+              \"ld %B0,%b1\"              CR_TAB\n+              TINY_SBIW (%I1, %J1, %o1+1), op, plen, -6);\n+  }\n+} \n+\n+/* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */\n+static const char*\n+avr_out_movhi_r_mr_pre_dec_tiny (rtx_insn *insn, rtx op[], int *plen)\n+{\n+  int mem_volatile_p = 0;\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (src, 0);\n+\n+  /* \"volatile\" forces reading low byte first, even if less efficient,\n+     for correct operation with 16-bit I/O registers.  */\n+  mem_volatile_p = MEM_VOLATILE_P (src);\n+\n+  if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))\n+      fatal_insn (\"incorrect insn:\", insn);\n+\n+  if (!mem_volatile_p)\n+      return avr_asm_len (\"ld %B0,%1\" CR_TAB\n+              \"ld %A0,%1\", op, plen, -2);\n+\n+  return avr_asm_len (TINY_SBIW (%I1, %J1, 2)  CR_TAB\n+          \"ld %A0,%p1+\"   CR_TAB\n+          \"ld %B0,%p1\"    CR_TAB\n+          TINY_SBIW (%I1, %J1, 1), op, plen, -6);\n+}\n+\n static const char*\n out_movhi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n {\n@@ -3346,6 +3516,9 @@ out_movhi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n \n   if (reg_base > 0)\n     {\n+      if (AVR_TINY)\n+        return avr_out_movhi_r_mr_reg_no_disp_tiny (op, plen);\n+\n       if (reg_dest == reg_base)         /* R = (R) */\n         return avr_asm_len (\"ld __tmp_reg__,%1+\" CR_TAB\n                             \"ld %B0,%1\"          CR_TAB\n@@ -3368,6 +3541,9 @@ out_movhi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n       int disp = INTVAL (XEXP (base, 1));\n       int reg_base = true_regnum (XEXP (base, 0));\n \n+      if (AVR_TINY)\n+        return avr_out_movhi_r_mr_reg_disp_tiny (op, plen);\n+\n       if (disp > MAX_LD_OFFSET (GET_MODE (src)))\n         {\n           if (REGNO (XEXP (base, 0)) != REG_Y)\n@@ -3379,7 +3555,7 @@ out_movhi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n                            \"ldd %B0,Y+63\"    CR_TAB\n                            \"sbiw r28,%o1-62\", op, plen, -4)\n \n-            : avr_asm_len (\"subi r28,lo8(-%o1)\" CR_TAB\n+              : avr_asm_len (\"subi r28,lo8(-%o1)\" CR_TAB\n                            \"sbci r29,hi8(-%o1)\" CR_TAB\n                            \"ld %A0,Y\"           CR_TAB\n                            \"ldd %B0,Y+1\"        CR_TAB\n@@ -3413,6 +3589,9 @@ out_movhi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n     }\n   else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n     {\n+      if (AVR_TINY)\n+          return avr_out_movhi_r_mr_pre_dec_tiny (insn, op, plen);\n+\n       if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))\n         fatal_insn (\"incorrect insn:\", insn);\n \n@@ -3440,18 +3619,112 @@ out_movhi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n     }\n   else if (CONSTANT_ADDRESS_P (base))\n     {\n+      int n_words = AVR_TINY ? 2 : 4;\n       return optimize > 0 && io_address_operand (base, HImode)\n         ? avr_asm_len (\"in %A0,%i1\" CR_TAB\n                        \"in %B0,%i1+1\", op, plen, -2)\n \n         : avr_asm_len (\"lds %A0,%m1\" CR_TAB\n-                       \"lds %B0,%m1+1\", op, plen, -4);\n+                       \"lds %B0,%m1+1\", op, plen, -n_words);\n     }\n \n   fatal_insn (\"unknown move insn:\",insn);\n   return \"\";\n }\n \n+static const char*\n+avr_out_movsi_r_mr_reg_no_disp_tiny (rtx_insn *insn, rtx op[], int *l)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (src, 0);\n+  int reg_dest = true_regnum (dest);\n+  int reg_base = true_regnum (base);\n+\n+  if (reg_dest == reg_base)\n+    {\n+\t  /* \"ld r26,-X\" is undefined */\n+      return *l=9, (TINY_ADIW (%E1, %F1, 3) CR_TAB\n+                    \"ld %D0,%1\"             CR_TAB\n+                    \"ld %C0,-%1\"            CR_TAB\n+                    \"ld __tmp_reg__,-%1\"   CR_TAB\n+                    TINY_SBIW (%E1, %F1, 1) CR_TAB\n+                    \"ld %A0,%1\"             CR_TAB\n+                    \"mov %B0,__tmp_reg__\");\n+    }\n+  else if (reg_dest == reg_base - 2)\n+    {\n+      return *l=5, (\"ld %A0,%1+\"            CR_TAB\n+                    \"ld %B0,%1+\"            CR_TAB\n+                    \"ld __tmp_reg__,%1+\"   CR_TAB\n+                    \"ld %D0,%1\"            CR_TAB\n+                    \"mov %C0,__tmp_reg__\");\n+    }\n+  else if (reg_unused_after (insn, base))\n+    {\n+      return *l=4, (\"ld %A0,%1+\"    CR_TAB\n+                    \"ld %B0,%1+\"    CR_TAB \n+                    \"ld %C0,%1+\"    CR_TAB\n+                    \"ld %D0,%1\");\n+    }\n+  else\n+    {\n+      return *l=6, (\"ld %A0,%1+\"    CR_TAB\n+                    \"ld %B0,%1+\"    CR_TAB \n+                    \"ld %C0,%1+\"    CR_TAB\n+                    \"ld %D0,%1\"     CR_TAB\n+                    TINY_SBIW (%E1, %F1, 3));\n+    }\n+}\n+\n+static const char*\n+avr_out_movsi_r_mr_reg_disp_tiny (rtx_insn *insn, rtx op[], int *l)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (src, 0);\n+  int reg_dest = true_regnum (dest);\n+  int reg_base = true_regnum (XEXP (base, 0));\n+\n+  if (reg_dest == reg_base)\n+    {\n+\t  /* \"ld r26,-X\" is undefined */\n+      return *l=9, (TINY_ADIW (%I1, %J1, %o1+3) CR_TAB\n+                    \"ld %D0,%b1\"                 CR_TAB\n+                    \"ld %C0,-%b1\"                CR_TAB\n+                    \"ld __tmp_reg__,-%b1\"        CR_TAB\n+                    TINY_SBIW (%I1, %J1, 1)     CR_TAB\n+                    \"ld %A0,%b1\"                 CR_TAB\n+                    \"mov %B0,__tmp_reg__\");\n+    }\n+  else if (reg_dest == reg_base - 2)\n+    {\n+      return *l=7, (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n+                    \"ld %A0,%b1+\"              CR_TAB\n+                    \"ld %B0,%b1+\"              CR_TAB\n+                    \"ld __tmp_reg__,%b1+\"      CR_TAB\n+                    \"ld %D0,%b1\"               CR_TAB\n+                    \"mov %C0,__tmp_reg__\");\n+    }\n+  else if (reg_unused_after (insn, XEXP (base, 0)))\n+    {\n+      return *l=6, (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n+                    \"ld %A0,%b1+\"              CR_TAB\n+                    \"ld %B0,%b1+\"              CR_TAB \n+                    \"ld %C0,%b1+\"              CR_TAB\n+                    \"ld %D0,%b1\");\n+    }\n+  else\n+    {\n+      return *l=8, (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n+                    \"ld %A0,%b1+\"              CR_TAB\n+                    \"ld %B0,%b1+\"              CR_TAB \n+                    \"ld %C0,%b1+\"              CR_TAB\n+                    \"ld %D0,%b1\"               CR_TAB\n+                    TINY_SBIW (%I1, %J1, %o1+3));\n+    }\n+}\n+\n static const char*\n out_movsi_r_mr (rtx_insn *insn, rtx op[], int *l)\n {\n@@ -3467,6 +3740,9 @@ out_movsi_r_mr (rtx_insn *insn, rtx op[], int *l)\n \n   if (reg_base > 0)\n     {\n+      if (AVR_TINY)\n+        return avr_out_movsi_r_mr_reg_no_disp_tiny (insn, op, l);\n+\n       if (reg_base == REG_X)        /* (R26) */\n         {\n           if (reg_dest == REG_X)\n@@ -3521,6 +3797,9 @@ out_movsi_r_mr (rtx_insn *insn, rtx op[], int *l)\n     {\n       int disp = INTVAL (XEXP (base, 1));\n \n+      if (AVR_TINY)\n+        return avr_out_movsi_r_mr_reg_disp_tiny (insn, op, l);\n+\n       if (disp > MAX_LD_OFFSET (GET_MODE (src)))\n \t{\n \t  if (REGNO (XEXP (base, 0)) != REG_Y)\n@@ -3604,15 +3883,133 @@ out_movsi_r_mr (rtx_insn *insn, rtx op[], int *l)\n \t\t  \"ld %C0,%1\" CR_TAB\n \t\t  \"ld %D0,%1\");\n   else if (CONSTANT_ADDRESS_P (base))\n-    return *l=8, (\"lds %A0,%m1\"   CR_TAB\n+    {\n+      if (io_address_operand (base, SImode))\n+        {\n+          *l = 4;\n+          return (\"in %A0,%i1\"   CR_TAB\n+                  \"in %B0,%i1+1\" CR_TAB\n+                  \"in %C0,%i1+2\" CR_TAB\n+                  \"in %D0,%i1+3\");\n+        }\n+      else\n+        {\n+          *l = AVR_TINY ? 4 : 8;\n+          return (\"lds %A0,%m1\"   CR_TAB\n                   \"lds %B0,%m1+1\" CR_TAB\n                   \"lds %C0,%m1+2\" CR_TAB\n                   \"lds %D0,%m1+3\");\n+        }\n+    }\n \n   fatal_insn (\"unknown move insn:\",insn);\n   return \"\";\n }\n \n+static const char*\n+avr_out_movsi_mr_r_reg_no_disp_tiny (rtx_insn *insn, rtx op[], int *l)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (dest, 0);\n+  int reg_base = true_regnum (base);\n+  int reg_src = true_regnum (src);\n+  \n+  if (reg_base == reg_src)\n+    {\n+\t  /* \"ld r26,-X\" is undefined */\n+      if (reg_unused_after (insn, base))\n+        { \n+          return *l=7, (\"mov __tmp_reg__, %B1\"  CR_TAB\n+                        \"st %0,%A1\"             CR_TAB\n+                        TINY_ADIW (%E0, %F0, 1) CR_TAB\n+                        \"st %0+,__tmp_reg__\"    CR_TAB\n+                        \"st %0+,%C1\"            CR_TAB\n+                        \"st %0+,%D1\");\n+        }\n+      else\n+        {\n+          return *l=9, (\"mov __tmp_reg__, %B1\"  CR_TAB\n+                        \"st %0,%A1\"             CR_TAB\n+                        TINY_ADIW (%E0, %F0, 1) CR_TAB\n+                        \"st %0+,__tmp_reg__\"    CR_TAB\n+                        \"st %0+,%C1\"            CR_TAB\n+                        \"st %0+,%D1\"            CR_TAB\n+                        TINY_SBIW (%E0, %F0, 3));\n+        }\n+    }\n+    else if (reg_base == reg_src + 2)\n+      {\n+        if (reg_unused_after (insn, base))\n+          return *l=7, (\"mov __zero_reg__,%C1\" CR_TAB\n+                        \"mov __tmp_reg__,%D1\"  CR_TAB\n+                        \"st %0+,%A1\"           CR_TAB\n+                        \"st %0+,%B1\"           CR_TAB\n+                        \"st %0+,__zero_reg__\"  CR_TAB\n+                        \"st %0,__tmp_reg__\"    CR_TAB\n+                        \"clr __zero_reg__\");\n+        else\n+          return *l=9, (\"mov __zero_reg__,%C1\" CR_TAB\n+                        \"mov __tmp_reg__,%D1\"  CR_TAB\n+                        \"st %0+,%A1\"           CR_TAB\n+                        \"st %0+,%B1\"           CR_TAB\n+                        \"st %0+,__zero_reg__\"  CR_TAB\n+                        \"st %0,__tmp_reg__\"    CR_TAB\n+                        \"clr __zero_reg__\"     CR_TAB\n+                        TINY_SBIW (%E0, %F0, 3));\n+      }\n+\n+    return *l=6, (\"st %0+,%A1\" CR_TAB\n+                  \"st %0+,%B1\" CR_TAB\n+                  \"st %0+,%C1\" CR_TAB\n+                  \"st %0,%D1\"  CR_TAB\n+                  TINY_SBIW (%E0, %F0, 3));\n+}\n+\n+static const char*\n+avr_out_movsi_mr_r_reg_disp_tiny (rtx op[], int *l)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (dest, 0);\n+  int reg_base = REGNO (XEXP (base, 0));\n+  int reg_src =true_regnum (src);\n+\n+  if (reg_base == reg_src)\n+    {\n+\t  *l = 11;\n+\t  return (\"mov __tmp_reg__,%A2\"        CR_TAB\n+\t\t      \"mov __zero_reg__,%B2\"       CR_TAB\n+              TINY_ADIW (%I0, %J0, %o0)    CR_TAB\n+\t\t      \"st %b0+,__tmp_reg__\"        CR_TAB\n+\t\t      \"st %b0+,__zero_reg__\"       CR_TAB\n+\t\t      \"st %b0+,%C2\"                CR_TAB\n+\t\t      \"st %b0,%D2\"                 CR_TAB\n+\t\t      \"clr __zero_reg__\"           CR_TAB\n+\t\t      TINY_SBIW (%I0, %J0, %o0+3));\n+\t }\n+  else if (reg_src == reg_base - 2)\n+    {\n+\t  *l = 11;\n+\t  return (\"mov __tmp_reg__,%C2\"         CR_TAB\n+\t\t      \"mov __zero_reg__,%D2\"        CR_TAB\n+\t\t      TINY_ADIW (%I0, %J0, %o0)     CR_TAB\n+\t\t      \"st %b0+,%A0\"                 CR_TAB\n+\t\t      \"st %b0+,%B0\"                 CR_TAB\n+\t\t      \"st %b0+,__tmp_reg__\"         CR_TAB\n+\t\t      \"st %b0,__zero_reg__\"         CR_TAB\n+\t\t      \"clr __zero_reg__\"            CR_TAB\n+\t\t      TINY_SBIW (%I0, %J0, %o0+3));\n+\t    }\n+  *l = 8;\n+  return (TINY_ADIW (%I0, %J0, %o0)     CR_TAB\n+\t\t  \"st %b0+,%A1\"                 CR_TAB\n+\t\t  \"st %b0+,%B1\"                 CR_TAB\n+\t\t  \"st %b0+,%C1\"                 CR_TAB\n+\t\t  \"st %b0,%D1\"                  CR_TAB\n+\t\t  TINY_SBIW (%I0, %J0, %o0+3));\n+}\n+\n static const char*\n out_movsi_mr_r (rtx_insn *insn, rtx op[], int *l)\n {\n@@ -3627,12 +4024,29 @@ out_movsi_mr_r (rtx_insn *insn, rtx op[], int *l)\n     l = &tmp;\n \n   if (CONSTANT_ADDRESS_P (base))\n-    return *l=8,(\"sts %m0,%A1\" CR_TAB\n-                 \"sts %m0+1,%B1\" CR_TAB\n-                 \"sts %m0+2,%C1\" CR_TAB\n-                 \"sts %m0+3,%D1\");\n+    {\n+      if (io_address_operand (base, SImode))\n+        {\n+          return *l=4,(\"out %i0, %A1\"  CR_TAB\n+                       \"out %i0+1,%B1\" CR_TAB\n+                       \"out %i0+2,%C1\" CR_TAB\n+                       \"out %i0+3,%D1\");\n+        }\n+      else\n+        {\n+          *l = AVR_TINY ? 4 : 8;\n+          return (\"sts %m0,%A1\"   CR_TAB\n+                  \"sts %m0+1,%B1\" CR_TAB\n+                  \"sts %m0+2,%C1\" CR_TAB\n+                  \"sts %m0+3,%D1\");\n+        }\n+    }\n+\n   if (reg_base > 0)                 /* (r) */\n     {\n+      if (AVR_TINY)\n+        return avr_out_movsi_mr_r_reg_no_disp_tiny (insn, op, l);\n+\n       if (reg_base == REG_X)                /* (R26) */\n         {\n           if (reg_src == REG_X)\n@@ -3689,6 +4103,10 @@ out_movsi_mr_r (rtx_insn *insn, rtx op[], int *l)\n   else if (GET_CODE (base) == PLUS) /* (R + i) */\n     {\n       int disp = INTVAL (XEXP (base, 1));\n+\n+      if (AVR_TINY)\n+        return avr_out_movsi_mr_r_reg_disp_tiny (op, l);\n+\n       reg_base = REGNO (XEXP (base, 0));\n       if (disp > MAX_LD_OFFSET (GET_MODE (dest)))\n \t{\n@@ -3848,6 +4266,73 @@ output_movsisf (rtx_insn *insn, rtx operands[], int *l)\n \n /* Handle loads of 24-bit types from memory to register.  */\n \n+static const char*\n+avr_out_load_psi_reg_no_disp_tiny (rtx_insn *insn, rtx *op, int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (src, 0);\n+  int reg_dest = true_regnum (dest);\n+  int reg_base = true_regnum (base);\n+\n+  if (reg_base == reg_dest)\n+    {\n+      return avr_asm_len (TINY_ADIW (%E1, %F1, 2)   CR_TAB\n+                          \"ld %C0,%1\"               CR_TAB\n+                          \"ld __tmp_reg__,-%1\"     CR_TAB\n+                          TINY_SBIW (%E1, %F1, 1)   CR_TAB\n+                          \"ld %A0,%1\"              CR_TAB\n+                          \"mov %B0,__tmp_reg__\", op, plen, -8);\n+    }\n+  else\n+    {\n+      return avr_asm_len (\"ld %A0,%1+\"  CR_TAB\n+                          \"ld %B0,%1+\"  CR_TAB\n+                          \"ld %C0,%1\", op, plen, -3);\n+\n+      if (reg_dest != reg_base - 2 &&\n+          !reg_unused_after (insn, base))\n+        {\n+          avr_asm_len (TINY_SBIW (%E1, %F1, 2), op, plen, 2);\n+        }\n+      return \"\";\n+    }\n+}\n+\n+static const char*\n+avr_out_load_psi_reg_disp_tiny (rtx_insn *insn, rtx *op, int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (src, 0);\n+  int reg_dest = true_regnum (dest);\n+  int reg_base = true_regnum (base);\n+\n+  reg_base = true_regnum (XEXP (base, 0));\n+  if (reg_base == reg_dest)\n+    {\n+      return avr_asm_len (TINY_ADIW (%I1, %J1, %o1+2) CR_TAB\n+                          \"ld %C0,%b1\"                CR_TAB\n+                          \"ld __tmp_reg__,-%b1\"       CR_TAB\n+                          TINY_SBIW (%I1, %J1, 1)     CR_TAB\n+                          \"ld %A0,%b1\"                CR_TAB\n+                          \"mov %B0,__tmp_reg__\", op, plen, -8);\n+   }\n+  else\n+    {\n+      avr_asm_len (TINY_ADIW (%I1, %J1, %o1)   CR_TAB\n+                          \"ld %A0,%b1+\"              CR_TAB\n+                          \"ld %B0,%b1+\"              CR_TAB  \n+                          \"ld %C0,%b1\", op, plen, -5);\n+\n+      if (reg_dest != (reg_base - 2)\n+          && !reg_unused_after (insn, XEXP (base, 0)))\n+          avr_asm_len (TINY_SBIW (%I1, %J1, %o1+2), op, plen, 2);\n+      \n+      return \"\";\n+    }\n+}\n+\n static const char*\n avr_out_load_psi (rtx_insn *insn, rtx *op, int *plen)\n {\n@@ -3859,6 +4344,9 @@ avr_out_load_psi (rtx_insn *insn, rtx *op, int *plen)\n \n   if (reg_base > 0)\n     {\n+      if (AVR_TINY)\n+        return avr_out_load_psi_reg_no_disp_tiny (insn, op, plen);\n+\n       if (reg_base == REG_X)        /* (R26) */\n         {\n           if (reg_dest == REG_X)\n@@ -3901,6 +4389,9 @@ avr_out_load_psi (rtx_insn *insn, rtx *op, int *plen)\n     {\n       int disp = INTVAL (XEXP (base, 1));\n \n+      if (AVR_TINY)\n+        return avr_out_load_psi_reg_disp_tiny (insn, op, plen);\n+\n       if (disp > MAX_LD_OFFSET (GET_MODE (src)))\n         {\n           if (REGNO (XEXP (base, 0)) != REG_Y)\n@@ -3969,14 +4460,94 @@ avr_out_load_psi (rtx_insn *insn, rtx *op, int *plen)\n                         \"ld %C0,%1\", op, plen, -3);\n \n   else if (CONSTANT_ADDRESS_P (base))\n-    return avr_asm_len (\"lds %A0,%m1\" CR_TAB\n-                        \"lds %B0,%m1+1\" CR_TAB\n-                        \"lds %C0,%m1+2\", op, plen , -6);\n+    {\n+      int n_words = AVR_TINY ? 3 : 6;\n+      return avr_asm_len (\"lds %A0,%m1\" CR_TAB\n+                          \"lds %B0,%m1+1\" CR_TAB\n+                          \"lds %C0,%m1+2\", op, plen , -n_words);\n+    }\n \n   fatal_insn (\"unknown move insn:\",insn);\n   return \"\";\n }\n \n+\n+static const char*\n+avr_out_store_psi_reg_no_disp_tiny (rtx_insn *insn, rtx *op, int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (dest, 0);\n+  int reg_base = true_regnum (base);\n+  int reg_src = true_regnum (src);\n+\n+  if (reg_base == reg_src)\n+    {\n+      avr_asm_len (\"st %0,%A1\"              CR_TAB\n+                   \"mov __tmp_reg__,%B1\"    CR_TAB\n+                   TINY_ADIW (%E0, %F0, 1)  CR_TAB /* st X+, r27 is undefined */\n+                   \"st %0+,__tmp_reg__\"     CR_TAB\n+                   \"st %0,%C1\", op, plen, -6);\n+\n+    }\n+  else if (reg_src == reg_base - 2)\n+    {\n+      avr_asm_len (\"st %0,%A1\"              CR_TAB\n+                   \"mov __tmp_reg__,%C1\"    CR_TAB\n+                   TINY_ADIW (%E0, %F0, 1)  CR_TAB\n+                   \"st %0+,%B1\"             CR_TAB\n+                   \"st %0,__tmp_reg__\", op, plen, 6);\n+    }\n+  else\n+    {\n+      avr_asm_len (\"st %0+,%A1\"  CR_TAB\n+                   \"st %0+,%B1\" CR_TAB\n+                   \"st %0,%C1\", op, plen, -3);\n+    }\n+\n+  if (!reg_unused_after (insn, base))\n+    avr_asm_len (TINY_SBIW (%E0, %F0, 2), op, plen, 2);\n+\n+  return \"\";\n+}\n+\n+static const char*\n+avr_out_store_psi_reg_disp_tiny (rtx *op, int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (dest, 0);\n+  int reg_base = REGNO (XEXP (base, 0));\n+  int reg_src = true_regnum (src);\n+\n+  if (reg_src == reg_base)\n+    {\n+      return avr_asm_len (\"mov __tmp_reg__,%A1\"          CR_TAB\n+                          \"mov __zero_reg__,%B1\"         CR_TAB\n+                          TINY_ADIW (%I0, %J0, %o0)      CR_TAB\n+                          \"st %b0+,__tmp_reg__\"          CR_TAB\n+                          \"st %b0+,__zero_reg__\"         CR_TAB\n+                          \"st %b0,%C1\"                   CR_TAB\n+                          \"clr __zero_reg__\"             CR_TAB\n+                          TINY_SBIW (%I0, %J0, %o0+2), op, plen, -10);\n+    }\n+  else if (reg_src == reg_base - 2)\n+    {\n+      return avr_asm_len (\"mov __tmp_reg__,%C1\"          CR_TAB  \n+                          TINY_ADIW (%I0, %J0, %o0)      CR_TAB\n+                          \"st %b0+,%A1\"                  CR_TAB\n+                          \"st %b0+,%B1\"                  CR_TAB\n+                          \"st %b0,__tmp_reg__\"           CR_TAB\n+                          TINY_SBIW (%I0, %J0, %o0+2), op, plen, -8);\n+    }\n+\n+  return avr_asm_len (TINY_ADIW (%I0, %J0, %o0)      CR_TAB\n+                          \"st %b0+,%A1\"                  CR_TAB\n+                          \"st %b0+,%B1\"                  CR_TAB\n+                          \"st %b0,%C1\"                   CR_TAB\n+                          TINY_SBIW (%I0, %J0, %o0+2), op, plen, -7);\n+}\n+\n /* Handle store of 24-bit type from register or zero to memory.  */\n \n static const char*\n@@ -3988,12 +4559,18 @@ avr_out_store_psi (rtx_insn *insn, rtx *op, int *plen)\n   int reg_base = true_regnum (base);\n \n   if (CONSTANT_ADDRESS_P (base))\n-    return avr_asm_len (\"sts %m0,%A1\"   CR_TAB\n-                        \"sts %m0+1,%B1\" CR_TAB\n-                        \"sts %m0+2,%C1\", op, plen, -6);\n+    {\n+      int n_words = AVR_TINY ? 3 : 6;\n+      return avr_asm_len (\"sts %m0,%A1\"   CR_TAB\n+                          \"sts %m0+1,%B1\" CR_TAB\n+                          \"sts %m0+2,%C1\", op, plen, -n_words);\n+    }\n \n   if (reg_base > 0)                 /* (r) */\n     {\n+      if (AVR_TINY)\n+        return avr_out_store_psi_reg_no_disp_tiny (insn, op, plen);\n+\n       if (reg_base == REG_X)        /* (R26) */\n         {\n           gcc_assert (!reg_overlap_mentioned_p (base, src));\n@@ -4015,6 +4592,10 @@ avr_out_store_psi (rtx_insn *insn, rtx *op, int *plen)\n   else if (GET_CODE (base) == PLUS) /* (R + i) */\n     {\n       int disp = INTVAL (XEXP (base, 1));\n+\n+      if (AVR_TINY)\n+        return avr_out_store_psi_reg_disp_tiny (op, plen);\n+\n       reg_base = REGNO (XEXP (base, 0));\n \n       if (disp > MAX_LD_OFFSET (GET_MODE (dest)))\n@@ -4131,6 +4712,30 @@ avr_out_movpsi (rtx_insn *insn, rtx *op, int *plen)\n   return \"\";\n }\n \n+static const char*\n+avr_out_movqi_mr_r_reg_disp_tiny (rtx_insn *insn, rtx op[], int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx x = XEXP (dest, 0);\n+\n+  if (reg_overlap_mentioned_p (src, XEXP (x, 0)))\n+    {\n+      avr_asm_len (\"mov __tmp_reg__,%1\"      CR_TAB\n+                   TINY_ADIW (%I0, %J0, %o0) CR_TAB\n+                   \"st %b0,__tmp_reg__\", op, plen, -4);\n+    }\n+    else\n+    {\n+      avr_asm_len (TINY_ADIW (%I0, %J0, %o0) CR_TAB\n+          \"st %b0,%1\" , op, plen, -3);\n+    }\n+\n+  if (!reg_unused_after (insn, XEXP (x,0)))\n+      avr_asm_len (TINY_SBIW (%I0, %J0, %o0), op, plen, 2);\n+\n+  return \"\";\n+}\n \n static const char*\n out_movqi_mr_r (rtx_insn *insn, rtx op[], int *plen)\n@@ -4141,9 +4746,10 @@ out_movqi_mr_r (rtx_insn *insn, rtx op[], int *plen)\n \n   if (CONSTANT_ADDRESS_P (x))\n     {\n+      int n_words = AVR_TINY ? 1 : 2;\n       return optimize > 0 && io_address_operand (x, QImode)\n         ? avr_asm_len (\"out %i0,%1\", op, plen, -1)\n-        : avr_asm_len (\"sts %m0,%1\", op, plen, -2);\n+        : avr_asm_len (\"sts %m0,%1\", op, plen, -n_words);\n     }\n   else if (GET_CODE (x) == PLUS\n            && REG_P (XEXP (x, 0))\n@@ -4153,6 +4759,9 @@ out_movqi_mr_r (rtx_insn *insn, rtx op[], int *plen)\n \n       int disp = INTVAL (XEXP (x, 1));\n \n+      if (AVR_TINY)\n+        return avr_out_movqi_mr_r_reg_disp_tiny (insn, op, plen);\n+\n       if (disp - GET_MODE_SIZE (GET_MODE (dest)) >= 63)\n         {\n           if (REGNO (XEXP (x, 0)) != REG_Y)\n@@ -4213,12 +4822,15 @@ avr_out_movhi_mr_r_xmega (rtx_insn *insn, rtx op[], int *plen)\n   int mem_volatile_p = MEM_VOLATILE_P (dest);\n \n   if (CONSTANT_ADDRESS_P (base))\n-    return optimize > 0 && io_address_operand (base, HImode)\n-      ? avr_asm_len (\"out %i0,%A1\" CR_TAB\n-                     \"out %i0+1,%B1\", op, plen, -2)\n+    {\n+      int n_words = AVR_TINY ? 2 : 4;\n+      return optimize > 0 && io_address_operand (base, HImode)\n+        ? avr_asm_len (\"out %i0,%A1\" CR_TAB\n+                       \"out %i0+1,%B1\", op, plen, -2)\n \n-      : avr_asm_len (\"sts %m0,%A1\" CR_TAB\n-                     \"sts %m0+1,%B1\", op, plen, -4);\n+        : avr_asm_len (\"sts %m0,%A1\" CR_TAB\n+                       \"sts %m0+1,%B1\", op, plen, -n_words);\n+    }\n \n   if (reg_base > 0)\n     {\n@@ -4307,6 +4919,70 @@ avr_out_movhi_mr_r_xmega (rtx_insn *insn, rtx op[], int *plen)\n   return \"\";\n }\n \n+static const char*\n+avr_out_movhi_mr_r_reg_no_disp_tiny (rtx_insn *insn, rtx op[], int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (dest, 0);\n+  int reg_base = true_regnum (base);\n+  int reg_src = true_regnum (src);\n+  int mem_volatile_p = MEM_VOLATILE_P (dest);\n+\n+  if (reg_base == reg_src)\n+    {\n+      return !mem_volatile_p && reg_unused_after (insn, src)\n+        ? avr_asm_len (\"mov __tmp_reg__,%B1\"   CR_TAB\n+                       \"st %0,%A1\"             CR_TAB\n+                       TINY_ADIW (%E0, %F0, 1) CR_TAB\n+                       \"st %0,__tmp_reg__\", op, plen, -5)\n+        : avr_asm_len (\"mov __tmp_reg__,%B1\"   CR_TAB\n+                       TINY_ADIW (%E0, %F0, 1) CR_TAB\n+                       \"st %0,__tmp_reg__\"      CR_TAB\n+                       TINY_SBIW (%E0, %F0, 1) CR_TAB\n+                       \"st %0, %A1\", op, plen, -7);\n+    }\n+\n+  return !mem_volatile_p && reg_unused_after (insn, base)\n+      ? avr_asm_len (\"st %0+,%A1\" CR_TAB\n+                     \"st %0,%B1\", op, plen, -2)\n+      : avr_asm_len (TINY_ADIW (%E0, %F0, 1) CR_TAB\n+                     \"st %0,%B1\"             CR_TAB\n+                     \"st -%0,%A1\", op, plen, -4);\n+}\n+\n+static const char*\n+avr_out_movhi_mr_r_reg_disp_tiny (rtx op[], int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (dest, 0);\n+  int reg_base = REGNO (XEXP (base, 0));\n+  int reg_src = true_regnum (src);\n+\n+  return reg_src == reg_base\n+        ? avr_asm_len (\"mov __tmp_reg__,%A1\"          CR_TAB\n+                       \"mov __zero_reg__,%B1\"         CR_TAB\n+                       TINY_ADIW (%I0, %J0, %o0+1)    CR_TAB\n+                       \"st %b0,__zero_reg__\"          CR_TAB\n+                       \"st -%b0,__tmp_reg__\"          CR_TAB\n+                       \"clr __zero_reg__\"             CR_TAB\n+                       TINY_SBIW (%I0, %J0, %o0), op, plen, -9) \n+\n+        : avr_asm_len (TINY_ADIW (%I0, %J0, %o0+1) CR_TAB\n+                       \"st %b0,%B1\"                CR_TAB\n+                       \"st -%b0,%A1\"               CR_TAB\n+                       TINY_SBIW (%I0, %J0, %o0), op, plen, -6);\n+}\n+\n+static const char*\n+avr_out_movhi_mr_r_post_inc_tiny (rtx op[], int *plen)\n+{\n+  return avr_asm_len (TINY_ADIW (%I0, %J0, 1)  CR_TAB\n+                      \"st %p0,%B1\"    CR_TAB\n+                      \"st -%p0,%A1\"   CR_TAB\n+                      TINY_ADIW (%I0, %J0, 2), op, plen, -6);\n+}\n \n static const char*\n out_movhi_mr_r (rtx_insn *insn, rtx op[], int *plen)\n@@ -4328,15 +5004,21 @@ out_movhi_mr_r (rtx_insn *insn, rtx op[], int *plen)\n   mem_volatile_p = MEM_VOLATILE_P (dest);\n \n   if (CONSTANT_ADDRESS_P (base))\n-    return optimize > 0 && io_address_operand (base, HImode)\n-      ? avr_asm_len (\"out %i0+1,%B1\" CR_TAB\n-                     \"out %i0,%A1\", op, plen, -2)\n+    {\n+      int n_words = AVR_TINY ? 2 : 4;\n+      return optimize > 0 && io_address_operand (base, HImode)\n+        ? avr_asm_len (\"out %i0+1,%B1\" CR_TAB\n+                       \"out %i0,%A1\", op, plen, -2)\n \n-      : avr_asm_len (\"sts %m0+1,%B1\" CR_TAB\n-                     \"sts %m0,%A1\", op, plen, -4);\n+        : avr_asm_len (\"sts %m0+1,%B1\" CR_TAB\n+                       \"sts %m0,%A1\", op, plen, -n_words);\n+    }\n \n   if (reg_base > 0)\n     {\n+      if (AVR_TINY)\n+        return avr_out_movhi_mr_r_reg_no_disp_tiny (insn, op, plen);\n+\n       if (reg_base != REG_X)\n         return avr_asm_len (\"std %0+1,%B1\" CR_TAB\n                             \"st %0,%A1\", op, plen, -2);\n@@ -4365,6 +5047,10 @@ out_movhi_mr_r (rtx_insn *insn, rtx op[], int *plen)\n   else if (GET_CODE (base) == PLUS)\n     {\n       int disp = INTVAL (XEXP (base, 1));\n+\n+      if (AVR_TINY)\n+        return avr_out_movhi_mr_r_reg_disp_tiny (op, plen);\n+\n       reg_base = REGNO (XEXP (base, 0));\n       if (disp > MAX_LD_OFFSET (GET_MODE (dest)))\n         {\n@@ -4414,6 +5100,9 @@ out_movhi_mr_r (rtx_insn *insn, rtx op[], int *plen)\n         return avr_asm_len (\"st %0,%A1\"  CR_TAB\n                             \"st %0,%B1\", op, plen, -2);\n \n+      if (AVR_TINY)\n+        return avr_out_movhi_mr_r_post_inc_tiny (op, plen);\n+\n       return REGNO (XEXP (base, 0)) == REG_X\n         ? avr_asm_len (\"adiw r26,1\"  CR_TAB\n                        \"st X,%B1\"    CR_TAB\n@@ -4596,7 +5285,11 @@ avr_out_compare (rtx_insn *insn, rtx *xop, int *plen)\n               && (val8 == 0\n                   || reg_unused_after (insn, xreg)))\n             {\n-              avr_asm_len (\"sbiw %0,%1\", xop, plen, 1);\n+              if (AVR_TINY)\n+                avr_asm_len (TINY_SBIW (%A0, %B0, %1), xop, plen, 2);\n+              else\n+                avr_asm_len (\"sbiw %0,%1\", xop, plen, 1);\n+\n               i++;\n               continue;\n             }\n@@ -4606,7 +5299,9 @@ avr_out_compare (rtx_insn *insn, rtx *xop, int *plen)\n               && compare_eq_p (insn)\n               && reg_unused_after (insn, xreg))\n             {\n-              return avr_asm_len (\"adiw %0,%n1\", xop, plen, 1);\n+              return AVR_TINY\n+                  ? avr_asm_len (TINY_ADIW (%A0, %B0, %n1), xop, plen, 2)\n+                  : avr_asm_len (\"adiw %0,%n1\", xop, plen, 1);\n             }\n         }\n \n@@ -8070,7 +8765,8 @@ avr_assemble_integer (rtx x, unsigned int size, int aligned_p)\n static bool\n avr_class_likely_spilled_p (reg_class_t c)\n {\n-  return (c != ALL_REGS && c != ADDW_REGS);\n+  return (c != ALL_REGS &&\n+           (AVR_TINY ? 1 : c != ADDW_REGS));\n }\n \n \n@@ -8343,7 +9039,9 @@ avr_nonconst_pointer_addrspace (tree typ)\n \n       if (!ADDR_SPACE_GENERIC_P (as)\n           && (!TYPE_READONLY (target)\n-              || avr_addrspace[as].segment >= avr_n_flash))\n+              || avr_addrspace[as].segment >= avr_n_flash\n+\t      /* Also refuse __memx address space if we can't support it.  */\n+\t      || (!AVR_HAVE_LPM && avr_addrspace[as].pointer_size > 2)))\n         {\n           return as;\n         }\n@@ -8465,6 +9163,12 @@ avr_insert_attributes (tree node, tree *attributes)\n                  \" beyond flash of %qs\",\n                  node, avr_addrspace[as].name, avr_current_device->name);\n         }\n+      else if (!AVR_HAVE_LPM && avr_addrspace[as].pointer_size > 2)\n+\t{\n+          error (\"variable %q+D located in address space %qs\"\n+                 \" which is not supported by %qs\",\n+                 node, avr_addrspace[as].name, avr_current_arch->arch_name);\n+\t}\n \n       if (!TYPE_READONLY (node0)\n           && !TREE_READONLY (node))\n@@ -8901,10 +9605,10 @@ avr_file_start (void)\n     fprintf (asm_out_file, \"__RAMPX__ = 0x%02x\\n\", avr_addr.rampx - sfr_offset);\n   if (AVR_HAVE_RAMPD)\n     fprintf (asm_out_file, \"__RAMPD__ = 0x%02x\\n\", avr_addr.rampd - sfr_offset);\n-  if (AVR_XMEGA)\n+  if (AVR_XMEGA || AVR_TINY)\n     fprintf (asm_out_file, \"__CCP__ = 0x%02x\\n\", avr_addr.ccp - sfr_offset);\n-  fprintf (asm_out_file, \"__tmp_reg__ = %d\\n\", TMP_REGNO);\n-  fprintf (asm_out_file, \"__zero_reg__ = %d\\n\", ZERO_REGNO);\n+  fprintf (asm_out_file, \"__tmp_reg__ = %d\\n\", AVR_TMP_REGNO);\n+  fprintf (asm_out_file, \"__zero_reg__ = %d\\n\", AVR_ZERO_REGNO);\n }\n \n \n@@ -8951,6 +9655,18 @@ avr_adjust_reg_alloc_order (void)\n       0, 1,\n       32, 33, 34, 35\n   };\n+  static const int tiny_order_0[] = {\n+    20, 21,\n+    22, 23,\n+    24, 25,\n+    30, 31,\n+    26, 27,\n+    28, 29,\n+    19, 18,\n+    16, 17,\n+    32, 33, 34, 35,\n+    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n+  };\n   static const int order_1[] =\n     {\n       18, 19, 20, 21, 22, 23, 24, 25,\n@@ -8960,6 +9676,17 @@ avr_adjust_reg_alloc_order (void)\n       0, 1,\n       32, 33, 34, 35\n   };\n+  static const int tiny_order_1[] = {\n+    22, 23,\n+    24, 25,\n+    30, 31,\n+    26, 27,\n+    28, 29,\n+    21, 20, 19, 18,\n+    16, 17,\n+    32, 33, 34, 35,\n+    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n+  };\n   static const int order_2[] =\n     {\n       25, 24, 23, 22, 21, 20, 19, 18,\n@@ -8970,9 +9697,14 @@ avr_adjust_reg_alloc_order (void)\n       32, 33, 34, 35\n   };\n \n-  const int *order = (TARGET_ORDER_1 ? order_1 :\n-\t\t      TARGET_ORDER_2 ? order_2 :\n-\t\t      order_0);\n+  /*\n+  Select specific register allocation order. Tiny Core (attiny4/5/9/10/20/40)\n+  devices has only 16 registers, so different allocation order should be used\n+  */ \n+  const int *order = (TARGET_ORDER_1 ? (AVR_TINY ? tiny_order_1 : order_1) :\n+             TARGET_ORDER_2 ? (AVR_TINY ? tiny_order_0 : order_2) :\n+                                       (AVR_TINY ? tiny_order_0 : order_0));\n+\n   for (i = 0; i < ARRAY_SIZE (order_0); ++i)\n       reg_alloc_order[i] = order[i];\n }\n@@ -10657,7 +11389,7 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n         {\n           if (!clear_p)\n             avr_asm_len (ldreg_p ? \"ldi %0,0\"\n-                         : ZERO_REGNO == REGNO (xdest[n]) ? \"clr %0\"\n+                         : AVR_ZERO_REGNO == REGNO (xdest[n]) ? \"clr %0\"\n                          : \"mov %0,__zero_reg__\",\n                          &xdest[n], len, 1);\n           continue;\n@@ -10859,6 +11591,49 @@ avr_output_addr_vec_elt (FILE *stream, int value)\n     fprintf (stream, \"\\trjmp .L%d\\n\", value);\n }\n \n+static void\n+avr_conditional_register_usage(void) {\n+\n+  if (AVR_TINY) {\n+    unsigned int i;\n+\n+    const int tiny_reg_alloc_order[] = {\n+      24, 25,\n+      22, 23,\n+      30, 31,\n+      26, 27,\n+      28, 29,\n+      21, 20, 19, 18,\n+      16, 17,\n+      32, 33, 34, 35,\n+      15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n+    };\n+\n+    /* Set R0-R17 as fixed registers. Reset R0-R17 in call used register list\n+    - R0-R15 are not available in Tiny Core devices\n+    - R16 and R17 are fixed registers\n+    */\n+    for (i = 0;  i <= 17;  i++) {\n+      fixed_regs[i] = 1;\n+      call_used_regs[i] = 1;\n+    }\n+\n+    /* Set R18 to R21 as callee saved registers\n+    - R18, R19, R20 and R21 are the callee saved registers in Tiny Core devices\n+    */\n+    for (i = 18; i <= LAST_CALLEE_SAVED_REG; i++) {\n+      call_used_regs[i] = 0;\n+    }\n+\n+    /*update register allocation order for Tiny Core devices */\n+    for (i=0; i < ARRAY_SIZE (tiny_reg_alloc_order); i++) {\n+      reg_alloc_order[i] = tiny_reg_alloc_order[i];\n+    }\n+\n+    CLEAR_HARD_REG_SET(reg_class_contents[(int)ADDW_REGS]);\n+    CLEAR_HARD_REG_SET(reg_class_contents[(int)NO_LD_REGS]);\n+  }\n+}\n \n /* Implement `TARGET_HARD_REGNO_SCRATCH_OK'.  */\n /* Returns true if SCRATCH are safe to be allocated as a scratch\n@@ -11013,13 +11788,20 @@ avr_asm_out_dtor (rtx symbol, int priority)\n static bool\n avr_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n {\n-  if (TYPE_MODE (type) == BLKmode)\n-    {\n-      HOST_WIDE_INT size = int_size_in_bytes (type);\n-      return (size == -1 || size > 8);\n-    }\n+  HOST_WIDE_INT size = int_size_in_bytes (type);\n+  HOST_WIDE_INT ret_size_limit = AVR_TINY ? 4 : 8;                                      \n+\n+  /* In avr, there are 8 return registers. But, for Tiny Core \n+  (attiny4/5/9/10/20/40) devices, only 4 registers available.\n+  Return true if size is unknown or greater than the limit */\n+  if ((size == -1) || (size > ret_size_limit))\n+  {\n+    return true;\n+  }\n   else\n+  {\n     return false;\n+  }\n }\n \n \n@@ -12639,6 +13421,9 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n #undef  TARGET_BUILTIN_SETJMP_FRAME_VALUE\n #define TARGET_BUILTIN_SETJMP_FRAME_VALUE avr_builtin_setjmp_frame_value\n \n+#undef TARGET_CONDITIONAL_REGISTER_USAGE\n+#define TARGET_CONDITIONAL_REGISTER_USAGE avr_conditional_register_usage\n+\n #undef  TARGET_HARD_REGNO_SCRATCH_OK\n #define TARGET_HARD_REGNO_SCRATCH_OK avr_hard_regno_scratch_ok\n #undef  TARGET_CASE_VALUES_THRESHOLD"}, {"sha": "ba31cd08fc576953b63b9a89a3a16908729f8884", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -63,6 +63,7 @@ enum\n #define AVR_HAVE_JMP_CALL (avr_current_arch->have_jmp_call)\n #define AVR_HAVE_MUL (avr_current_arch->have_mul)\n #define AVR_HAVE_MOVW (avr_current_arch->have_movw_lpmx)\n+#define AVR_HAVE_LPM (!AVR_TINY)\n #define AVR_HAVE_LPMX (avr_current_arch->have_movw_lpmx)\n #define AVR_HAVE_ELPM (avr_current_arch->have_elpm)\n #define AVR_HAVE_ELPMX (avr_current_arch->have_elpmx)\n@@ -99,6 +100,7 @@ FIXME: DRIVER_SELF_SPECS has changed.\n #define AVR_3_BYTE_PC (AVR_HAVE_EIJMP_EICALL)\n \n #define AVR_XMEGA (avr_current_arch->xmega_p)\n+#define AVR_TINY  (avr_current_arch->tiny_p)\n \n #define BITS_BIG_ENDIAN 0\n #define BYTES_BIG_ENDIAN 0\n@@ -305,7 +307,7 @@ enum reg_class {\n \n #define ARG_POINTER_REGNUM 34\n \n-#define STATIC_CHAIN_REGNUM 2\n+#define STATIC_CHAIN_REGNUM ((AVR_TINY) ? 18 :2)\n \n #define ELIMINABLE_REGS {\t\t\t\t\t\\\n       {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\"}, {"sha": "06e1cb0abe6bd71b81236be2045557e0f64821c9", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 82, "deletions": 16, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -24,6 +24,10 @@\n ;;  B  Add 1 to REG number, MEM address or CONST_INT.\n ;;  C  Add 2.\n ;;  D  Add 3.\n+;;  E  reg number in XEXP(x, 0).\n+;;  F  Add 1 to reg number.\n+;;  I  reg number in XEXP(XEXP(x, 0), 0).\n+;;  J  Add 1 to reg number.\n ;;  j  Branch condition.\n ;;  k  Reverse branch condition.\n ;;..m..Constant Direct Data memory address.\n@@ -59,6 +63,11 @@\n    (ZERO_REGNO  1)      ; zero register r1\n    ])\n \n+(define_constants\n+  [ (TMP_REGNO_TINY 16)  ; r16 is temp register for AVR_TINY\n+    (ZERO_REGNO_TINY 17) ; r17 is zero register for AVR_TINY\n+  ])\n+\n (define_c_enum \"unspec\"\n   [UNSPEC_STRLEN\n    UNSPEC_MOVMEM\n@@ -159,9 +168,10 @@\n ;; lpm  : ISA has no LPMX                lpmx  : ISA has LPMX\n ;; elpm : ISA has ELPM but no ELPMX      elpmx : ISA has ELPMX\n ;; no_xmega: non-XMEGA core              xmega : XMEGA core\n+;; no_tiny:  non-TINY core               tiny  : TINY core\n \n (define_attr \"isa\"\n-  \"mov,movw, rjmp,jmp, ijmp,eijmp, lpm,lpmx, elpm,elpmx, no_xmega,xmega,\n+  \"mov,movw, rjmp,jmp, ijmp,eijmp, lpm,lpmx, elpm,elpmx, no_xmega,xmega, no_tiny,tiny,\n    standard\"\n   (const_string \"standard\"))\n \n@@ -213,9 +223,18 @@\n               (match_test \"AVR_XMEGA\"))\n          (const_int 1)\n \n+         (and (eq_attr \"isa\" \"tiny\")\n+              (match_test \"AVR_TINY\"))\n+         (const_int 1)\n+\n          (and (eq_attr \"isa\" \"no_xmega\")\n               (match_test \"!AVR_XMEGA\"))\n          (const_int 1)\n+\n+         (and (eq_attr \"isa\" \"no_tiny\")\n+              (match_test \"!AVR_TINY\"))\n+         (const_int 1)\n+\n          ] (const_int 0)))\n \n \n@@ -620,6 +639,33 @@\n         emit_insn (gen_load<mode>_libgcc (dest, src));\n         DONE;\n       }\n+\n+    /* AVRTC-579\n+    if the source operand expression is out of range for 'lds' instruction\n+      copy source operand expression to register\n+    For tiny core, LDS instruction's memory access range limited to 0x40..0xbf\n+    */\n+    if (!tiny_valid_direct_memory_access_range(src,<MODE>mode))\n+      {\n+        rtx srcx = XEXP(src,0);\n+        operands[1] = src = replace_equiv_address (src,copy_to_mode_reg (GET_MODE(srcx),srcx));\n+        emit_move_insn(dest,src);\n+        DONE;\n+      }\n+\n+    /* AVRTC-579\n+    if the destination operand expression is out of range for 'sts' instruction\n+      copy destination operand expression to register\n+    For tiny core, STS instruction's memory access range limited to 0x40..0xbf\n+    */\n+    if (!tiny_valid_direct_memory_access_range(dest,<MODE>mode))\n+    {\n+      rtx destx = XEXP(dest,0);\n+      operands[0] = dest = replace_equiv_address (dest,copy_to_mode_reg (GET_MODE(destx),destx));\n+      emit_move_insn(dest,src);\n+      DONE;\n+    }\n+\n   })\n \n ;;========================================================================\n@@ -636,8 +682,13 @@\n (define_insn \"mov<mode>_insn\"\n   [(set (match_operand:ALL1 0 \"nonimmediate_operand\" \"=r    ,d    ,Qm   ,r ,q,r,*r\")\n         (match_operand:ALL1 1 \"nox_general_operand\"   \"r Y00,n Ynn,r Y00,Qm,r,q,i\"))]\n-  \"register_operand (operands[0], <MODE>mode)\n-   || reg_or_0_operand (operands[1], <MODE>mode)\"\n+  \"(register_operand (operands[0], <MODE>mode)\n+   || reg_or_0_operand (operands[1], <MODE>mode)) &&\n+   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)\n+   though access range is checked during define_expand, it is required\n+   here to avoid merging rtls during combine pass */\n+   tiny_valid_direct_memory_access_range(operands[0],QImode) &&\n+   tiny_valid_direct_memory_access_range(operands[1],QImode)\"\n   {\n     return output_movqi (insn, operands, NULL);\n   }\n@@ -730,8 +781,13 @@\n (define_insn \"*mov<mode>\"\n   [(set (match_operand:ALL2 0 \"nonimmediate_operand\" \"=r,r  ,r,m    ,d,*r,q,r\")\n         (match_operand:ALL2 1 \"nox_general_operand\"   \"r,Y00,m,r Y00,i,i ,r,q\"))]\n-  \"register_operand (operands[0], <MODE>mode)\n-   || reg_or_0_operand (operands[1], <MODE>mode)\"\n+  \"(register_operand (operands[0], <MODE>mode)\n+   || reg_or_0_operand (operands[1], <MODE>mode)) &&\n+   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)\n+   though access range is checked during define_expand, it is required\n+   here to avoid merging rtls during combine pass */\n+   tiny_valid_direct_memory_access_range(operands[0],HImode) &&\n+   tiny_valid_direct_memory_access_range(operands[1],HImode)\"\n   {\n     return output_movhi (insn, operands, NULL);\n   }\n@@ -879,8 +935,13 @@\n (define_insn \"*mov<mode>\"\n   [(set (match_operand:ALL4 0 \"nonimmediate_operand\" \"=r,r  ,r ,Qm   ,!d,r\")\n         (match_operand:ALL4 1 \"nox_general_operand\"   \"r,Y00,Qm,r Y00,i ,i\"))]\n-  \"register_operand (operands[0], <MODE>mode)\n-   || reg_or_0_operand (operands[1], <MODE>mode)\"\n+  \"(register_operand (operands[0], <MODE>mode)\n+   || reg_or_0_operand (operands[1], <MODE>mode)) &&\n+   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)\n+   though access range is checked during define_expand, it is required\n+   here to avoid merging rtls during combine pass */\n+   tiny_valid_direct_memory_access_range(operands[0],SImode) &&\n+   tiny_valid_direct_memory_access_range(operands[1],SImode)\"\n   {\n     return output_movsisf (insn, operands, NULL);\n   }\n@@ -894,8 +955,13 @@\n (define_insn \"*movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,r ,Qm,!d,r\")\n         (match_operand:SF 1 \"nox_general_operand\"   \"r,G,Qm,rG,F ,F\"))]\n-  \"register_operand (operands[0], SFmode)\n-   || reg_or_0_operand (operands[1], SFmode)\"\n+  \"(register_operand (operands[0], SFmode)\n+   || reg_or_0_operand (operands[1], SFmode)) &&\n+   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)\n+   though access range is checked during define_expand, it is required\n+   here to avoid merging rtls during combine pass */\n+   tiny_valid_direct_memory_access_range(operands[0],SFmode) &&\n+   tiny_valid_direct_memory_access_range(operands[1],SFmode)\"\n   {\n     return output_movsisf (insn, operands, NULL);\n   }\n@@ -5551,18 +5617,18 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"delay_cycles_2\"\n-  [(unspec_volatile [(match_operand:HI 0 \"const_int_operand\" \"n\")\n+  [(unspec_volatile [(match_operand:HI 0 \"const_int_operand\" \"n,n\")\n                      (const_int 2)]\n                     UNSPECV_DELAY_CYCLES)\n    (set (match_operand:BLK 1 \"\" \"\")\n \t(unspec_volatile:BLK [(match_dup 1)] UNSPECV_MEMORY_BARRIER))\n-   (clobber (match_scratch:HI 2 \"=&w\"))]\n+   (clobber (match_scratch:HI 2 \"=&w,&d\"))]\n   \"\"\n-  \"ldi %A2,lo8(%0)\n-\tldi %B2,hi8(%0)\n-\t1: sbiw %A2,1\n-\tbrne 1b\"\n-  [(set_attr \"length\" \"4\")\n+  \"@\n+    ldi %A2,lo8(%0)\\;ldi %B2,hi8(%0)\\;1: sbiw %A2,1\\;brne 1b\n+    ldi %A2,lo8(%0)\\;ldi %B2,hi8(%0)\\;1: subi %A2,1\\;sbci %B2,0\\;brne 1b\"\n+  [(set_attr \"length\" \"4,5\")\n+   (set_attr \"isa\" \"no_tiny,tiny\")\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"delay_cycles_3\""}, {"sha": "89d0036fbddb69fe9c13999f186307857c50b121", "filename": "gcc/config/avr/t-multilib", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Ft-multilib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fconfig%2Favr%2Ft-multilib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-multilib?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -21,9 +21,9 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-MULTILIB_OPTIONS = march=avr2/march=avr25/march=avr3/march=avr31/march=avr35/march=avr4/march=avr5/march=avr51/march=avr6/march=avrxmega2/march=avrxmega4/march=avrxmega5/march=avrxmega6/march=avrxmega7 msp8\n+MULTILIB_OPTIONS = march=avr2/march=avr25/march=avr3/march=avr31/march=avr35/march=avr4/march=avr5/march=avr51/march=avr6/march=avrxmega2/march=avrxmega4/march=avrxmega5/march=avrxmega6/march=avrxmega7/march=avrtiny msp8\n \n-MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 tiny-stack avr25/tiny-stack\n+MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 avrtiny tiny-stack avr25/tiny-stack\n \n MULTILIB_EXCEPTIONS = \\\n \tmarch=avr3/msp8 \\\n@@ -37,4 +37,5 @@ MULTILIB_EXCEPTIONS = \\\n \tmarch=avrxmega4/msp8 \\\n \tmarch=avrxmega5/msp8 \\\n \tmarch=avrxmega6/msp8 \\\n-\tmarch=avrxmega7/msp8\n+\tmarch=avrxmega7/msp8 \\\n+\tmarch=avrtiny/msp8"}, {"sha": "468dda0133cd3e388a89dcad4ee377269803a5d2", "filename": "gcc/doc/avr-mmcu.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fdoc%2Favr-mmcu.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Fdoc%2Favr-mmcu.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Favr-mmcu.texi?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -68,6 +68,10 @@\n ``XMEGA'' devices with more than 128@tie{}KiB of program memory and more than 64@tie{}KiB of RAM.\n @*@var{mcu}@tie{}= @code{atxmega128a1}, @code{atxmega128a1u}, @code{atxmega128a4u}.\n \n+@item avrtiny\n+``TINY'' Tiny core devices with 512@tie{}B up to 4@tie{}KiB of program memory.\n+@*@var{mcu}@tie{}= @code{attiny10}, @code{attiny20}, @code{attiny4}, @code{attiny40}, @code{attiny5}, @code{attiny9}.\n+\n @item avr1\n This ISA is implemented by the minimal AVR core and supported for assembler only.\n @*@var{mcu}@tie{}= @code{attiny11}, @code{attiny12}, @code{attiny15}, @code{attiny28}, @code{at90s1200}."}, {"sha": "7db3ce4e5b06fcdddaece0ec91c6bca8eab1a110", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -1,3 +1,9 @@\n+2014-10-21  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\t* gcc.target/avr/tiny-memx.c: New test.\n+\n+\t* gcc.target/avr/tiny-caller-save.c: New test.\n+\n 2014-10-21  Jiong Wang  <jiong.wang@arm.com>\n \n \t* gcc.target/arm/20031108-1.c (Proc_7): Add explicit declaration."}, {"sha": "0e46ee065944dd2c23f224af494da5236c4d7b9c", "filename": "gcc/testsuite/gcc.target/avr/tiny-caller-save.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftiny-caller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftiny-caller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftiny-caller-save.c?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=avrtiny -gdwarf -Os\" } */\n+\n+/* This is a stripped down piece of libgcc2.c that triggerd an ICE for avr with\n+   \"-march=avrtiny -g -Os\"; replace_reg_with_saved_mem would generate:\n+   (concatn:SI [\n+                    (reg:SI 18 r18)\n+                    (reg:SI 19 r19)\n+                    (mem/c:QI (plus:HI (reg/f:HI 28 r28)\n+                            (const_int 43 [0x2b])) [6  S1 A8])\n+                    (mem/c:QI (plus:HI (reg/f:HI 28 r28)\n+                            (const_int 44 [0x2c])) [6  S1 A8])\n+                ]) */\n+\n+typedef int SItype __attribute__ ((mode (SI)));\n+typedef unsigned int USItype __attribute__ ((mode (SI)));\n+typedef int DItype __attribute__ ((mode (DI)));\n+typedef unsigned int UDItype __attribute__ ((mode (DI)));\n+struct DWstruct\n+{\n+  SItype low, high;\n+};\n+typedef union\n+{\n+  struct DWstruct s;\n+  DItype ll;\n+} DWunion;\n+\n+UDItype\n+__udivmoddi4 (UDItype n, UDItype d)\n+{\n+  const DWunion nn = {.ll = n };\n+  const DWunion dd = {.ll = d };\n+  USItype d0, d1, n2;\n+  USItype q0;\n+\n+  d0 = dd.s.low;\n+  d1 = dd.s.high;\n+  n2 = nn.s.high;\n+\n+      USItype m0;\n+\n+      do\n+\t{\n+\t  USItype __d1, __d0, __q1, __q0;\n+\t  USItype __r1, __m;\n+\t  __d1 = ((USItype) (d1) >> 16);\n+\t  __d0 = ((USItype) (d1) & (((USItype) 1 << 16) - 1));\n+\t  __r1 = (n2) % __d1;\n+\t  __q1 = (n2) / __d1;\n+\t  __m = (USItype) __q1 *__d0;\n+\t  __r1 -= __m;\n+\t  __q0 = __r1 / __d1;\n+\t  (q0) = (USItype) __q1 *((USItype) 1 << 16) | __q0;\n+\t}\n+      while (0);\n+      do\n+\t{\n+\t  USItype __x0, __x1, __x2;\n+\t  USItype __ul, __vl, __uh, __vh;\n+\t  __ul = ((USItype) (q0) & (((USItype) 1 << 16) - 1));\n+\t  __uh = ((USItype) (q0) >> 16);\n+\t  __vl = ((USItype) (d0) & (((USItype) 1 << 16) - 1));\n+\t  __vh = ((USItype) (d0) >> 16);\n+\t  __x0 = (USItype) __ul *__vl;\n+\t  __x1 = (USItype) __ul *__vh;\n+\t  __x2 = (USItype) __uh *__vl;\n+\t  __x1 += ((USItype) (__x0) >> 16);\n+\t  __x1 += __x2;\n+\t  (m0) =\n+\t    ((USItype) (__x1) & (((USItype) 1 << 16) - 1)) *\n+\t    ((USItype) 1 << 16) +\n+\t    ((USItype) (__x0) & (((USItype) 1 << 16) - 1));\n+\t}\n+      while (0);\n+\n+return m0;\n+}"}, {"sha": "3ad164dfed4bf87a98c36c4314f71835c647ac26", "filename": "gcc/testsuite/gcc.target/avr/tiny-memx.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftiny-memx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftiny-memx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftiny-memx.c?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=avrtiny\" } */\n+\n+const __memx char ascmonth[] = \"Jan\"; /* { dg-error \"not supported\" } */"}, {"sha": "a87aa3354cf881c4d91a5216f3f79309c93e263e", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -1,3 +1,38 @@\n+2014-10-21  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\t    Vidya Praveen <vidya.praveen@atmel.com>\n+\t    Praveen Kumar Kaushik <Praveen_Kumar.Kaushik@atmel.com>\n+\t    Senthil Kumar Selvaraj <Senthil_Kumar.Selvaraj@atmel.com>\n+\t    Pitchumani Sivanupandi <Pitchumani.S@atmel.com>\n+\n+\t* config/avr/lib1funcs.S (__do_global_dtors): Go back to descending\n+\torder.\n+\n+\tUpdated library functions for AVRTINY arch.\n+\t* config/avr/lib1funcs.S: Updated zero/tmp regs for AVRTINY.\n+\tReplaced occurrences of r0/r1 with tmp/zero reg macros.\n+\tAdded wsubi/ wadi macros that expands conditionally as sbiw/ adiw\n+\tor AVRTINY equivalent. Replaced occurrences of sbiw/adiw with\n+\twsubi/wadi macors.\n+\t(__mulsi3_helper): Update stack, preserve callee saved regs and\n+\targument from stack. Restore callee save registers.\n+\t(__mulpsi3): Likewise.\n+\t(__muldi3, __udivmodsi4, __divmodsi4, __negsi2, __umoddi3, __udivmod64,\n+\t__moddi3, __adddi3, __adddi3_s8, __subdi3, __cmpdi2, __cmpdi2_s8,\n+\t__negdi2, __prologue_saves__, __epilogue_restores__): Excluded for \n+\tAVRTINY.\n+\t(__tablejump2__): Added lpm equivalent instructions for AVRTINY.\n+\t(__do_copy_data): Added new definition for AVRTINY.\n+\t(__do_clear_bss): Replace r17 by r18 to preserve zero reg for AVRTINY.\n+\t(__load_3, __load_4, __xload_1, __xload_2, __xload_3,\n+\t__xload_4, __movmemx_qi, __movmemx_hi): Excluded for AVRTINY.\n+\t* config/avr/lib1funcs-fixed.S: Replaced occurrences of r0/r1 with\n+\ttmp/zero reg macros. Replaced occurrences of sbiw/adiw with wsubi/wadi\n+\tmacors.\n+\t   * config/avr/t-avr (LIB1ASMFUNCS): Remove unsupported functions for\n+\tAVRTINY.\n+\n+\tFix broken long multiplication on tiny arch.         \n+\n 2014-10-09  Joseph Myers  <joseph@codesourcery.com>\n \n \t* soft-fp/double.h: Update from glibc."}, {"sha": "ae4dcf0fe8a002bc5373f8a129b063db1424ce77", "filename": "libgcc/config/avr/lib1funcs-fixed.S", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -31,8 +31,18 @@\n ;; Fixed point library routines for AVR\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n+#if defined __AVR_TINY__\n+#define __zero_reg__ r17\n+#define __tmp_reg__ r16\n+#else                                                                                                                                              \n+#define __zero_reg__ r1\n+#define __tmp_reg__ r0\n+#endif\n+\n .section .text.libgcc.fixed, \"ax\", @progbits\n \n+#ifndef __AVR_TINY__\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; Conversions to float\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n@@ -1913,3 +1923,5 @@ DEFUN __ret\n     ret\n ENDF  __ret\n #endif /* L_ret */\n+\n+#endif /* if not __AVR_TINY__ */"}, {"sha": "0205d833ecb36972196aa7533e5517ae849ef607", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 139, "deletions": 29, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -21,8 +21,13 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n+#if defined (__AVR_TINY__)\n+#define __zero_reg__ r17\n+#define __tmp_reg__ r16\n+#else\n #define __zero_reg__ r1\n #define __tmp_reg__ r0\n+#endif\n #define __SREG__ 0x3f\n #if defined (__AVR_HAVE_SPH__)\n #define __SP_H__ 0x3e\n@@ -126,6 +131,24 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n ;; Support function entry and exit for convenience\n \n+.macro wsubi r_arg1, i_arg2\n+#if defined (__AVR_TINY__)\n+    subi \\r_arg1,   lo8(\\i_arg2)\n+    sbci \\r_arg1+1, hi8(\\i_arg2)\n+#else\n+    sbiw \\r_arg1, \\i_arg2\n+#endif\n+.endm\n+\n+.macro waddi r_arg1, i_arg2\n+#if defined (__AVR_TINY__)\n+    subi \\r_arg1,   lo8(-\\i_arg2)\n+    sbci \\r_arg1+1, hi8(-\\i_arg2)\n+#else\n+    adiw \\r_arg1, \\i_arg2\n+#endif\n+.endm\n+\n .macro DEFUN name\n .global \\name\n .func \\name\n@@ -146,7 +169,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n .endm\n \n ;; Skip next instruction, typically a jump target\n+#if defined(__AVR_TINY__)\n #define skip cpse 0,0\n+#else\n+#define skip cpse 16,16\n+#endif\n \n ;; Negate a 2-byte value held in consecutive registers\n .macro NEG2  reg\n@@ -219,16 +246,16 @@ ENDF __mulqi3\n     Multiplication  16 x 16  without MUL\n *******************************************************/\n \n-#define A0  r22\n-#define A1  r23\n-#define B0  r24\n-#define BB0 r20\n-#define B1  r25\n+#define A0  22\n+#define A1  23\n+#define B0  24\n+#define BB0 20\n+#define B1  25\n ;; Output overlaps input, thus expand result in CC0/1\n-#define C0  r24\n-#define C1  r25\n+#define C0  24\n+#define C1  25\n #define CC0  __tmp_reg__\n-#define CC1  R21\n+#define CC1  21\n \n #if defined (L_umulqihi3)\n ;;; R25:R24 = (unsigned int) R22 * (unsigned int) R24\n@@ -294,7 +321,7 @@ DEFUN __mulhi3\n     rol     B1\n 3:\n     ;; If B == 0 we are ready\n-    sbiw    B0, 0\n+    wsubi   B0, 0\n     breq 9f\n \n     ;; Carry = n-th bit of A\n@@ -402,6 +429,18 @@ ENDF __mulhisi3\n \n #if defined (L_mulsi3)\n DEFUN __mulsi3\n+#if defined (__AVR_TINY__)\n+    in     r26, __SP_L__ ; safe to use X, as it is CC0/CC1\n+    in     r27, __SP_H__\n+    subi   r26, lo8(-3)   ; Add 3 to point past return address\n+    sbci   r27, hi8(-3)\n+    push   B0    ; save callee saved regs\n+    push   B1\n+    ld     B0, X+   ; load from caller stack\n+    ld     B1, X+\n+    ld     B2, X+\n+    ld     B3, X\n+#endif\n     ;; Clear result\n     clr     CC2\n     clr     CC3\n@@ -427,12 +466,17 @@ DEFUN __mulsi3_helper\n     ;; Only continue if  A != 0\n     sbci    A1, 0\n     brne 2b\n-    sbiw    A2, 0\n+    wsubi   A2, 0\n     brne 2b\n \n     ;; All bits of A are consumed:  Copy result to return register C\n     wmov    C0, CC0\n     wmov    C2, CC2\n+#if defined (__AVR_TINY__)\n+    pop     B1      ; restore callee saved regs\n+    pop     B0 \n+#endif  /* defined (__AVR_TINY__) */\n+\n     ret\n ENDF __mulsi3_helper\n #endif /* L_mulsi3 */\n@@ -682,16 +726,30 @@ ENDF __mulpsi3\n #undef C0\n \n #else /* !HAVE_MUL */\n-\n ;; C[0..2]: Expand Result\n+#if defined (__AVR_TINY__)\n+#define C0  16\n+#else\n #define C0  0\n+#endif /* defined (__AVR_TINY__) */\n #define C1  C0+1\n #define C2  21\n \n ;; R24:R22 *= R20:R18\n ;; Clobbers: __tmp_reg__, R18, R19, R20, R21\n \n DEFUN __mulpsi3\n+#if defined (__AVR_TINY__)\n+    in r26,__SP_L__ \n+    in r27,__SP_H__\n+    subi r26, lo8(-3)   ; Add 3 to point past return address\n+    sbci r27, hi8(-3)\n+    push B0    ; save callee saved regs\n+    push B1\n+    ld B0,X+   ; load from caller stack \n+    ld B1,X+\n+    ld B2,X+\n+#endif /* defined (__AVR_TINY__) */\n \n     ;; C[] = 0\n     clr     __tmp_reg__\n@@ -718,6 +776,10 @@ DEFUN __mulpsi3\n     mov     A2, C2\n \n     clr     __zero_reg__\n+#if defined (__AVR_TINY__)\n+    pop B1\n+    pop B0\n+#endif /* (__AVR_TINY__) */\n     ret\n ENDF __mulpsi3\n \n@@ -809,8 +871,8 @@ ENDF __mulsqipsi3\n #define B6  B0+6\n #define B7  B0+7\n \n+#ifndef __AVR_TINY__\n #if defined (__AVR_HAVE_MUL__)\n-\n ;; Define C[] for convenience\n ;; Notice that parts of C[] overlap A[] respective B[]\n #define C0  16\n@@ -1012,6 +1074,7 @@ ENDF __muldi3\n \n #endif /* L_muldi3 */\n #endif /* HAVE_MUL */\n+#endif /* if not __AVR_TINY__ */\n \n #undef B7\n #undef B6\n@@ -1169,7 +1232,7 @@ ENDF __mulsidi3\n /**********************************************************\n     Widening Multiplication 64 = 32 x 32  without  MUL\n **********************************************************/\n-\n+#ifndef __AVR_TINY__ /* if not __AVR_TINY__ */\n #if defined (L_mulsidi3) && !defined (__AVR_HAVE_MUL__)\n #define A0 18\n #define A1 A0+1\n@@ -1265,7 +1328,7 @@ ENDF __umulsidi3\n #undef BB3\n #undef Mask\n #endif /* L_mulsidi3 && !HAVE_MUL */\n-\n+#endif /* if not __AVR_TINY__ */\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \t\n \f\n@@ -1437,7 +1500,7 @@ ENDF __divmodhi4\n #define r_cnt   21\n \n #if defined (L_udivmodpsi4)\n-;; R24:R22 = R24:R22  udiv  R20:R18\n+;; R24:R22 = R24:R24  udiv  R20:R18\n ;; R20:R18 = R24:R22  umod  R20:R18\n ;; Clobbers: R21, R25, R26\n \n@@ -1672,6 +1735,10 @@ ENDF __negsi2\n #undef r_arg2L\n #undef r_cnt\n \n+/* *di routines use registers below R19 and won't work with tiny arch\n+   right now. */\n+\n+#if !defined (__AVR_TINY__)\n /*******************************************************\n        Division 64 / 64\n        Modulo   64 % 64\n@@ -2087,12 +2154,15 @@ ENDF __negdi2\n #undef A1\n #undef A0\n \n+#endif /* !defined (__AVR_TINY__) */\n+\n \f\n .section .text.libgcc.prologue, \"ax\", @progbits\n \n /**********************************\n  * This is a prologue subroutine\n  **********************************/\n+#if !defined (__AVR_TINY__)\n #if defined (L_prologue)\n \n ;; This function does not clobber T-flag; 64-bit division relies on it\n@@ -2194,6 +2264,7 @@ DEFUN __epilogue_restores__\n \tret\n ENDF __epilogue_restores__\n #endif /* defined (L_epilogue) */\n+#endif /* !defined (__AVR_TINY__) */\n \n #ifdef L_exit\n \t.section .fini9,\"ax\",@progbits\n@@ -2259,6 +2330,12 @@ DEFUN __tablejump2__\n     lpm     r31, Z\n     mov     r30, __tmp_reg__\n     ijmp\n+#elif defined (__AVR_TINY__)\n+    wsubi 30, -(__AVR_TINY_PM_BASE_ADDRESS__) ; Add PM offset to Z\n+    ld __tmp_reg__, Z+\n+    ld r31, Z   ; Use ld instead of lpm to load Z\n+    mov r30, __tmp_reg__    \n+    ijmp\n #else\n     lpm\n     push    r0\n@@ -2270,6 +2347,26 @@ DEFUN __tablejump2__\n ENDF __tablejump2__\n #endif /* L_tablejump2 */\n \n+#if defined(__AVR_TINY__)\n+#ifdef L_copy_data\n+        .section .init4,\"ax\",@progbits\n+        .global __do_copy_data\n+__do_copy_data:\n+        ldi     r18, hi8(__data_end)\n+        ldi     r26, lo8(__data_start)\n+        ldi     r27, hi8(__data_start)\n+        ldi     r30, lo8(__data_load_start + __AVR_TINY_PM_BASE_ADDRESS__)\n+        ldi     r31, hi8(__data_load_start + __AVR_TINY_PM_BASE_ADDRESS__)\n+        rjmp    .L__do_copy_data_start\n+.L__do_copy_data_loop:\n+        ld      r19, z+\n+        st      X+, r19\n+.L__do_copy_data_start:\n+        cpi     r26, lo8(__data_end)\n+        cpc     r27, r18\n+        brne    .L__do_copy_data_loop\n+#endif\n+#else\n #ifdef L_copy_data\n \t.section .init4,\"ax\",@progbits\n DEFUN __do_copy_data\n@@ -2335,40 +2432,47 @@ DEFUN __do_copy_data\n #endif /* ELPM && RAMPD */\n ENDF __do_copy_data\n #endif /* L_copy_data */\n+#endif /* !defined (__AVR_TINY__) */\n \n /* __do_clear_bss is only necessary if there is anything in .bss section.  */\n \n #ifdef L_clear_bss\n \t.section .init4,\"ax\",@progbits\n DEFUN __do_clear_bss\n-\tldi\tr17, hi8(__bss_end)\n+\tldi\tr18, hi8(__bss_end)\n \tldi\tr26, lo8(__bss_start)\n \tldi\tr27, hi8(__bss_start)\n \trjmp\t.do_clear_bss_start\n .do_clear_bss_loop:\n \tst\tX+, __zero_reg__\n .do_clear_bss_start:\n \tcpi\tr26, lo8(__bss_end)\n-\tcpc\tr27, r17\n+\tcpc\tr27, r18\n \tbrne\t.do_clear_bss_loop\n ENDF __do_clear_bss\n #endif /* L_clear_bss */\n \n /* __do_global_ctors and __do_global_dtors are only necessary\n    if there are any constructors/destructors.  */\n \n+#if defined(__AVR_TINY__)\n+#define cdtors_tst_reg r18\n+#else\n+#define cdtors_tst_reg r17\n+#endif\n+\n #ifdef L_ctors\n \t.section .init6,\"ax\",@progbits\n DEFUN __do_global_ctors\n-    ldi     r17, pm_hi8(__ctors_start)\n+    ldi     cdtors_tst_reg, pm_hi8(__ctors_start)\n     ldi     r28, pm_lo8(__ctors_end)\n     ldi     r29, pm_hi8(__ctors_end)\n #ifdef __AVR_HAVE_EIJMP_EICALL__\n     ldi     r16, pm_hh8(__ctors_end)\n #endif /* HAVE_EIJMP */\n     rjmp    .L__do_global_ctors_start\n .L__do_global_ctors_loop:\n-    sbiw    r28, 1\n+    wsubi   28, 1\n #ifdef __AVR_HAVE_EIJMP_EICALL__\n     sbc     r16, __zero_reg__\n     mov     r24, r16\n@@ -2378,7 +2482,7 @@ DEFUN __do_global_ctors\n     XCALL   __tablejump2__\n .L__do_global_ctors_start:\n     cpi     r28, pm_lo8(__ctors_start)\n-    cpc     r29, r17\n+    cpc     r29, cdtors_tst_reg\n #ifdef __AVR_HAVE_EIJMP_EICALL__\n     ldi     r24, pm_hh8(__ctors_start)\n     cpc     r16, r24\n@@ -2390,27 +2494,27 @@ ENDF __do_global_ctors\n #ifdef L_dtors\n \t.section .fini6,\"ax\",@progbits\n DEFUN __do_global_dtors\n-    ldi     r17, pm_hi8(__dtors_start)\n-    ldi     r28, pm_lo8(__dtors_end)\n-    ldi     r29, pm_hi8(__dtors_end)\n+    ldi     cdtors_tst_reg, pm_hi8(__dtors_end)\n+    ldi     r28, pm_lo8(__dtors_start)\n+    ldi     r29, pm_hi8(__dtors_start)\n #ifdef __AVR_HAVE_EIJMP_EICALL__\n-    ldi     r16, pm_hh8(__dtors_end)\n+    ldi     r16, pm_hh8(__dtors_start)\n #endif /* HAVE_EIJMP */\n     rjmp    .L__do_global_dtors_start\n .L__do_global_dtors_loop:\n-    sbiw    r28, 1\n+    waddi   28, 1\n #ifdef __AVR_HAVE_EIJMP_EICALL__\n-    sbc     r16, __zero_reg__\n+    adc     r16, __zero_reg__\n     mov     r24, r16\n #endif /* HAVE_EIJMP */\n     mov_h   r31, r29\n     mov_l   r30, r28\n     XCALL   __tablejump2__\n .L__do_global_dtors_start:\n-    cpi     r28, pm_lo8(__dtors_start)\n-    cpc     r29, r17\n+    cpi     r28, pm_lo8(__dtors_end)\n+    cpc     r29, cdtors_tst_reg\n #ifdef __AVR_HAVE_EIJMP_EICALL__\n-    ldi     r24, pm_hh8(__dtors_start)\n+    ldi     r24, pm_hh8(__dtors_end)\n     cpc     r16, r24\n #endif /* HAVE_EIJMP */\n     brne    .L__do_global_dtors_loop\n@@ -2419,6 +2523,7 @@ ENDF __do_global_dtors\n \n .section .text.libgcc, \"ax\", @progbits\n \n+#if !defined (__AVR_TINY__)\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; Loading n bytes from Flash; n = 3,4\n ;; R22... = Flash[Z]\n@@ -2464,7 +2569,9 @@ ENDF __load_4\n #endif /* L_load_4 */\n \n #endif /* L_load_3 || L_load_3 */\n+#endif /* !defined (__AVR_TINY__) */\n \n+#if !defined (__AVR_TINY__)\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; Loading n bytes from Flash or RAM;  n = 1,2,3,4\n ;; R22... = Flash[R21:Z] or RAM[Z] depending on R21.7\n@@ -2590,7 +2697,9 @@ ENDF __xload_4\n #endif /* L_xload_4 */\n \n #endif /* L_xload_{1|2|3|4} */\n+#endif /* if !defined (__AVR_TINY__) */\n \n+#if !defined (__AVR_TINY__)\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; memcopy from Address Space __pgmx to RAM\n ;; R23:Z = Source Address\n@@ -2662,6 +2771,7 @@ ENDF __movmemx_hi\n #undef LOOP\n \n #endif /* L_movmemx */\n+#endif /* !defined (__AVR_TINY__) */ \n \n \f\n .section .text.libgcc.builtins, \"ax\", @progbits"}, {"sha": "c420c5d8fb98da89002b5145a32e056b3135cfc4", "filename": "libgcc/config/avr/t-avr", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd9790241595c417b028842bf0a7d4b2cf253a/libgcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd9790241595c417b028842bf0a7d4b2cf253a/libgcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Ft-avr?ref=c1dd9790241595c417b028842bf0a7d4b2cf253a", "patch": "@@ -3,12 +3,7 @@ LIB1ASMFUNCS = \\\n \t_mulqi3 \\\n \t_mulhi3 \\\n \t_mulqihi3 _umulqihi3 \\\n-\t_mulpsi3 _mulsqipsi3 \\\n-\t_mulhisi3 \\\n-\t_umulhisi3 \\\n-\t_usmulhisi3 \\\n-\t_muluhisi3 \\\n-\t_mulshisi3 \\\n+\t_mulpsi3 \\\n \t_mulsi3 \\\n \t_udivmodqi4 \\\n \t_divmodqi4 \\\n@@ -17,19 +12,10 @@ LIB1ASMFUNCS = \\\n \t_divmodpsi4 _udivmodpsi4 \\\n \t_udivmodsi4 \\\n \t_divmodsi4 \\\n-\t_divdi3 _udivdi3 \\\n-\t_muldi3 _muldi3_6 \\\n-\t_mulsidi3 _umulsidi3 \\\n-\t_udivmod64 \\\n-\t_negsi2 _negdi2 \\\n-\t_prologue \\\n-\t_epilogue \\\n+\t_negsi2 \\\n \t_exit \\\n \t_cleanup \\\n \t_tablejump2 \\\n-\t_load_3 _load_4 \\\n-\t_xload_1 _xload_2 _xload_3 _xload_4 \\\n-\t_movmemx \\\n \t_copy_data \\\n \t_clear_bss \\\n \t_ctors \\\n@@ -39,24 +25,54 @@ LIB1ASMFUNCS = \\\n \t_loop_ffsqi2 \\\n \t_ctzsi2 \\\n \t_ctzhi2 \\\n-\t_clzdi2 \\\n \t_clzsi2 \\\n \t_clzhi2 \\\n-\t_paritydi2 \\\n \t_paritysi2 \\\n \t_parityhi2 \\\n \t_popcounthi2 \\\n \t_popcountsi2 \\\n-\t_popcountdi2 \\\n \t_popcountqi2 \\\n \t_bswapsi2 \\\n+\t_fmul _fmuls _fmulsu\n+\n+# The below functions either use registers that are not present\n+# in tiny core, or use a different register conventions (don't save\n+# callee saved regs, for example)\n+# _mulhisi3 and variations - clobber R18, R19\n+# All *di funcs - use regs < R16 or expect args in regs < R20\n+# _prologue and _epilogue save registers < R16\n+# _load ad _xload variations - expect lpm and elpm support\n+# _movmemx - expects elpm/lpm\n+\n+ifneq ($(MULTIFLAGS),-mmcu=avrtiny)\n+LIB1ASMFUNCS += \\\n+    _mulsqipsi3 \\\n+\t_mulhisi3 \\\n+\t_umulhisi3 \\\n+\t_usmulhisi3 \\\n+\t_muluhisi3 \\\n+\t_mulshisi3 \\\n+    _muldi3 _muldi3_6 \\\n+    _mulsidi3 _umulsidi3 \\\n+\t_divdi3 _udivdi3 \\\n+\t_udivmod64 \\\n+\t_negdi2 \\\n+\t_prologue \\\n+\t_epilogue \\\n+\t_load_3 _load_4 \\\n+\t_xload_1 _xload_2 _xload_3 _xload_4 \\\n+\t_movmemx \\\n+\t_clzdi2 \\\n+\t_paritydi2 \\\n+\t_popcountdi2 \\\n \t_bswapdi2 \\\n \t_ashldi3 _ashrdi3 _lshrdi3 _rotldi3 \\\n \t_adddi3 _adddi3_s8 _subdi3 \\\n-\t_cmpdi2 _cmpdi2_s8 \\\n-\t_fmul _fmuls _fmulsu\n+\t_cmpdi2 _cmpdi2_s8\n+endif\n \n # Fixed point routines in avr/lib1funcs-fixed.S\n+ifneq ($(MULTIFLAGS),-mmcu=avrtiny)\n LIB1ASMFUNCS += \\\n \t_fractqqsf _fractuqqsf \\\n \t_fracthqsf _fractuhqsf _fracthasf _fractuhasf \\\n@@ -87,8 +103,8 @@ LIB1ASMFUNCS += \\\n \t_round_x8 \\\n \t_rounddq3 _roundudq3 \\\n \t_roundda3 _rounduda3 \\\n-\t_roundta3 _rounduta3 \\\n-\n+\t_roundta3 _rounduta3\n+endif\n \n LIB2FUNCS_EXCLUDE = \\\n \t_moddi3 _umoddi3 \\"}]}