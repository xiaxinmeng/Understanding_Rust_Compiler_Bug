{"sha": "35a382b82d0c7a65e5974298af5b32a003ea1fcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVhMzgyYjgyZDBjN2E2NWU1OTc0Mjk4YWY1YjMyYTAwM2VhMWZjZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-10-25T10:35:07Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-10-25T10:35:07Z"}, "message": "decl.c (gnat_to_gnu_entity, [...]): Allow In Out/Out parameters for functions.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity, case E_Function): Allow\n\tIn Out/Out parameters for functions.\n\t* gcc-interface/trans.c (gnu_return_var_stack): New variable.\n\t(create_init_temporary): New static function.\n\t(Subprogram_Body_to_gnu): Handle In Out/Out parameters for functions.\n\t(call_to_gnu): Likewise.  Use create_init_temporary in order to create\n\ttemporaries for unaligned parameters and return value.  If there is an\n\tunaligned In Out or Out parameter passed by reference, push a binding\n\tlevel if not already done.  If a binding level has been pushed and the\n\tcall is returning a value, create the call statement.\n\t(gnat_to_gnu) <N_Return_Statement>: Handle In Out/Out parameters for\n\tfunctions.\n\nFrom-SVN: r165914", "tree": {"sha": "8cc3581d1da42f9345f072e15d0748dc2e860814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cc3581d1da42f9345f072e15d0748dc2e860814"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35a382b82d0c7a65e5974298af5b32a003ea1fcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35a382b82d0c7a65e5974298af5b32a003ea1fcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35a382b82d0c7a65e5974298af5b32a003ea1fcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35a382b82d0c7a65e5974298af5b32a003ea1fcf/comments", "author": null, "committer": null, "parents": [{"sha": "7fa2619a2ff66d8c8100554d33ad1ebb046c295e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fa2619a2ff66d8c8100554d33ad1ebb046c295e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fa2619a2ff66d8c8100554d33ad1ebb046c295e"}], "stats": {"total": 456, "additions": 338, "deletions": 118}, "files": [{"sha": "7d3f1600a7a9c9b93434e8fc523ce7c0fc6d67e8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=35a382b82d0c7a65e5974298af5b32a003ea1fcf", "patch": "@@ -1,3 +1,19 @@\n+2010-10-25  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity, case E_Function): Allow\n+\tIn Out/Out parameters for functions.\n+\t* gcc-interface/trans.c (gnu_return_var_stack): New variable.\n+\t(create_init_temporary): New static function.\n+\t(Subprogram_Body_to_gnu): Handle In Out/Out parameters for functions.\n+\t(call_to_gnu): Likewise.  Use create_init_temporary in order to create\n+\ttemporaries for unaligned parameters and return value.  If there is an\n+\tunaligned In Out or Out parameter passed by reference, push a binding\n+\tlevel if not already done.  If a binding level has been pushed and the\n+\tcall is returning a value, create the call statement.\n+\t(gnat_to_gnu) <N_Return_Statement>: Handle In Out/Out parameters for\n+\tfunctions.\n+\n 2010-10-22  Ben Brosgol  <brosgol@adacore.com>\n \n \t* gnat_rm.texi: Add chapter on Ada 2012 support."}, {"sha": "8a284ea2f4f9835aaf4c52492a68404745c13543", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=35a382b82d0c7a65e5974298af5b32a003ea1fcf", "patch": "@@ -3941,7 +3941,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbool return_by_direct_ref_p = false;\n \tbool return_by_invisi_ref_p = false;\n \tbool return_unconstrained_p = false;\n-\tbool has_copy_in_out = false;\n \tbool has_stub = false;\n \tint parmnum;\n \n@@ -4194,15 +4193,31 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    if (copy_in_copy_out)\n \t      {\n-\t\tif (!has_copy_in_out)\n+\t\tif (!gnu_cico_list)\n \t\t  {\n-\t\t    gcc_assert (TREE_CODE (gnu_return_type) == VOID_TYPE);\n-\t\t    gnu_return_type = make_node (RECORD_TYPE);\n+\t\t    tree gnu_new_ret_type = make_node (RECORD_TYPE);\n+\n+\t\t    /* If this is a function, we also need a field for the\n+\t\t       return value to be placed.  */\n+\t\t    if (TREE_CODE (gnu_return_type) != VOID_TYPE)\n+\t\t      {\n+\t\t\tgnu_field\n+\t\t\t  = create_field_decl (get_identifier (\"RETVAL\"),\n+\t\t\t\t\t       gnu_return_type,\n+\t\t\t\t\t       gnu_new_ret_type, NULL_TREE,\n+\t\t\t\t\t       NULL_TREE, 0, 0);\n+\t\t\tSloc_to_locus (Sloc (gnat_entity),\n+\t\t\t\t       &DECL_SOURCE_LOCATION (gnu_field));\n+\t\t\tgnu_field_list = gnu_field;\n+\t\t\tgnu_cico_list\n+\t\t\t  = tree_cons (gnu_field, void_type_node, NULL_TREE);\n+\t\t      }\n+\n+\t\t    gnu_return_type = gnu_new_ret_type;\n \t\t    TYPE_NAME (gnu_return_type) = get_identifier (\"RETURN\");\n \t\t    /* Set a default alignment to speed up accesses.  */\n \t\t    TYPE_ALIGN (gnu_return_type)\n \t\t      = get_mode_alignment (ptr_mode);\n-\t\t    has_copy_in_out = true;\n \t\t  }\n \n \t\tgnu_field"}, {"sha": "3156e77c6035b3648b448b4ee033afdd1e471fe8", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 231, "deletions": 113, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=35a382b82d0c7a65e5974298af5b32a003ea1fcf", "patch": "@@ -165,6 +165,10 @@ static GTY(()) VEC(tree,gc) *gnu_elab_proc_stack;\n    some functions.  See processing for N_Subprogram_Body.  */\n static GTY(()) VEC(tree,gc) *gnu_return_label_stack;\n \n+/* Stack of variable for the return value of a function with copy-in/copy-out\n+   parameters.  See processing for N_Subprogram_Body.  */\n+static GTY(()) VEC(tree,gc) *gnu_return_var_stack;\n+\n /* Stack of LOOP_STMT nodes.  */\n static GTY(()) VEC(tree,gc) *gnu_loop_label_stack;\n \n@@ -2445,9 +2449,12 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   tree gnu_subprog_decl;\n   /* Its RESULT_DECL node.  */\n   tree gnu_result_decl;\n-  /* The FUNCTION_TYPE node corresponding to the subprogram spec.  */\n+  /* Its FUNCTION_TYPE node.  */\n   tree gnu_subprog_type;\n+  /* The TYPE_CI_CO_LIST of its FUNCTION_TYPE node, if any.  */\n   tree gnu_cico_list;\n+  /* The entry in the CI_CO_LIST that represents a function return, if any.  */\n+  tree gnu_return_var_elmt = NULL_TREE;\n   tree gnu_result;\n   VEC(parm_attr,gc) *cache;\n \n@@ -2470,10 +2477,14 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t\t\t  && !present_gnu_tree (gnat_subprog_id));\n   gnu_result_decl = DECL_RESULT (gnu_subprog_decl);\n   gnu_subprog_type = TREE_TYPE (gnu_subprog_decl);\n+  gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n+  if (gnu_cico_list)\n+    gnu_return_var_elmt = value_member (void_type_node, gnu_cico_list);\n \n   /* If the function returns by invisible reference, make it explicit in the\n-     function body.  See gnat_to_gnu_entity, E_Subprogram_Type case.  */\n-  if (TREE_ADDRESSABLE (gnu_subprog_type))\n+     function body.  See gnat_to_gnu_entity, E_Subprogram_Type case.\n+     Handle the explicit case here and the copy-in/copy-out case below.  */\n+  if (TREE_ADDRESSABLE (gnu_subprog_type) && !gnu_return_var_elmt)\n     {\n       TREE_TYPE (gnu_result_decl)\n \t= build_reference_type (TREE_TYPE (gnu_result_decl));\n@@ -2499,15 +2510,38 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   /* If there are In Out or Out parameters, we need to ensure that the return\n      statement properly copies them out.  We do this by making a new block and\n      converting any return into a goto to a label at the end of the block.  */\n-  gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n   if (gnu_cico_list)\n     {\n+      tree gnu_return_var = NULL_TREE;\n+\n       VEC_safe_push (tree, gc, gnu_return_label_stack,\n \t\t     create_artificial_label (input_location));\n \n       start_stmt_group ();\n       gnat_pushlevel ();\n \n+      /* If this is a function with In Out or Out parameters, we also need a\n+\t variable for the return value to be placed.  */\n+      if (gnu_return_var_elmt)\n+\t{\n+\t  tree gnu_return_type\n+\t    = TREE_TYPE (TREE_PURPOSE (gnu_return_var_elmt));\n+\n+\t  /* If the function returns by invisible reference, make it\n+\t     explicit in the function body.  See gnat_to_gnu_entity,\n+\t     E_Subprogram_Type case.  */\n+\t  if (TREE_ADDRESSABLE (gnu_subprog_type))\n+\t    gnu_return_type = build_reference_type (gnu_return_type);\n+\n+\t  gnu_return_var\n+\t    = create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n+\t\t\t       gnu_return_type, NULL_TREE, false, false,\n+\t\t\t       false, false, NULL, gnat_subprog_id);\n+\t  TREE_VALUE (gnu_return_var_elmt) = gnu_return_var;\n+\t}\n+\n+      VEC_safe_push (tree, gc, gnu_return_var_stack, gnu_return_var);\n+\n       /* See whether there are parameters for which we don't have a GCC tree\n \t yet.  These must be Out parameters.  Make a VAR_DECL for them and\n \t put it into TYPE_CI_CO_LIST, which must contain an empty entry too.\n@@ -2649,9 +2683,33 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   if (DECL_FUNCTION_STUB (gnu_subprog_decl))\n     build_function_stub (gnu_subprog_decl, gnat_subprog_id);\n \n+  if (gnu_return_var_elmt)\n+    TREE_VALUE (gnu_return_var_elmt) = void_type_node;\n+\n   mark_out_of_scope (Defining_Unit_Name (Specification (gnat_node)));\n }\n \f\n+\n+/* Create a temporary variable with PREFIX and initialize it with GNU_INIT.\n+   Put the initialization statement into GNU_INIT_STMT and annotate it with\n+   the SLOC of GNAT_NODE.  Return the temporary variable.  */\n+\n+static tree\n+create_init_temporary (const char *prefix, tree gnu_init, tree *gnu_init_stmt,\n+\t\t       Node_Id gnat_node)\n+{\n+  tree gnu_temp = create_var_decl (create_tmp_var_name (prefix), NULL_TREE,\n+\t\t\t\t   TREE_TYPE (gnu_init), NULL_TREE, false,\n+\t\t\t\t   false, false, false, NULL, Empty);\n+  DECL_ARTIFICIAL (gnu_temp) = 1;\n+  DECL_IGNORED_P (gnu_temp) = 1;\n+\n+  *gnu_init_stmt = build_binary_op (INIT_EXPR, NULL_TREE, gnu_temp, gnu_init);\n+  set_expr_location_from_node (*gnu_init_stmt, gnat_node);\n+\n+  return gnu_temp;\n+}\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, either an N_Function_Call\n    or an N_Procedure_Call_Statement, to a GCC tree, which is returned.\n    GNU_RESULT_TYPE_P is a pointer to where we should place the result type.\n@@ -2675,7 +2733,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n   tree gnu_name_list = NULL_TREE;\n   tree gnu_before_list = NULL_TREE;\n   tree gnu_after_list = NULL_TREE;\n-  tree gnu_call;\n+  tree gnu_call, gnu_result;\n+  bool returning_value = (Nkind (gnat_node) == N_Function_Call && !gnu_target);\n+  bool pushed_binding_level = false;\n   bool went_into_elab_proc = false;\n \n   gcc_assert (TREE_CODE (gnu_subprog_type) == FUNCTION_TYPE);\n@@ -2692,7 +2752,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t   gnat_actual = Next_Actual (gnat_actual))\n \tadd_stmt (gnat_to_gnu (gnat_actual));\n \n-      if (Nkind (gnat_node) == N_Function_Call && !gnu_target)\n+      if (returning_value)\n \t{\n \t  *gnu_result_type_p = TREE_TYPE (gnu_subprog_type);\n \t  return build1 (NULL_EXPR, TREE_TYPE (gnu_subprog_type), call_expr);\n@@ -2713,17 +2773,23 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n   else\n     gnat_formal = First_Formal_With_Extras (Entity (Name (gnat_node)));\n \n-  /* If we are translating a statement, open a new nesting level that will\n-     surround it to declare the temporaries created for the call.  */\n-  if (Nkind (gnat_node) == N_Procedure_Call_Statement || gnu_target)\n+  /* If we are translating a statement, push a new binding level that will\n+     surround it to declare the temporaries created for the call.  Likewise\n+     if we'll be returning a value and also have copy-in/copy-out parameters,\n+     as we need to create statements to fetch their value after the call.\n+\n+     ??? We could do that unconditionally, but the middle-end doesn't seem\n+     to be prepared to handle the construct in nested contexts.  */\n+  if (!returning_value || TYPE_CI_CO_LIST (gnu_subprog_type))\n     {\n       start_stmt_group ();\n       gnat_pushlevel ();\n+      pushed_binding_level = true;\n     }\n \n   /* The lifetime of the temporaries created for the call ends with the call\n      so we can give them the scope of the elaboration routine at top level.  */\n-  else if (!current_function_decl)\n+  if (!current_function_decl)\n     {\n       current_function_decl = get_elaboration_procedure ();\n       went_into_elab_proc = true;\n@@ -2778,6 +2844,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  && (gnu_name_type = gnat_to_gnu_type (Etype (gnat_name)))\n \t  && !addressable_p (gnu_name, gnu_name_type))\n \t{\n+\t  bool in_param = (Ekind (gnat_formal) == E_In_Parameter);\n \t  tree gnu_orig = gnu_name, gnu_temp, gnu_stmt;\n \n \t  /* Do not issue warnings for CONSTRUCTORs since this is not a copy\n@@ -2837,26 +2904,28 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t\t\t       TREE_TYPE (gnu_name))))\n \t    gnu_name = convert (gnu_name_type, gnu_name);\n \n+\t  /* If we haven't pushed a binding level and this is an In Out or Out\n+\t     parameter, push a new one.  This is needed to wrap the copy-back\n+\t     statements we'll be making below.  */\n+\t  if (!pushed_binding_level && !in_param)\n+\t    {\n+\t      start_stmt_group ();\n+\t      gnat_pushlevel ();\n+\t      pushed_binding_level = true;\n+\t    }\n+\n \t  /* Create an explicit temporary holding the copy.  This ensures that\n \t     its lifetime is as narrow as possible around a statement.  */\n-\t  gnu_temp = create_var_decl (create_tmp_var_name (\"A\"), NULL_TREE,\n-\t\t\t\t      TREE_TYPE (gnu_name), NULL_TREE,\n-\t\t\t\t      false, false, false, false, NULL, Empty);\n-\t  DECL_ARTIFICIAL (gnu_temp) = 1;\n-\t  DECL_IGNORED_P (gnu_temp) = 1;\n+\t  gnu_temp\n+\t    = create_init_temporary (\"A\", gnu_name, &gnu_stmt, gnat_actual);\n \n \t  /* But initialize it on the fly like for an implicit temporary as\n \t     we aren't necessarily dealing with a statement.  */\n-\t  gnu_stmt\n-\t    = build_binary_op (INIT_EXPR, NULL_TREE, gnu_temp, gnu_name);\n-\t  set_expr_location_from_node (gnu_stmt, gnat_actual);\n-\n-\t  /* From now on, the real object is the temporary.  */\n \t  gnu_name = build2 (COMPOUND_EXPR, TREE_TYPE (gnu_name), gnu_stmt,\n \t\t\t     gnu_temp);\n \n \t  /* Set up to move the copy back to the original if needed.  */\n-\t  if (Ekind (gnat_formal) != E_In_Parameter)\n+\t  if (!in_param)\n \t    {\n \t      gnu_stmt = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_orig,\n \t\t\t\t\t  gnu_temp);\n@@ -3034,92 +3103,34 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n                              gnu_actual_vec);\n   set_expr_location_from_node (gnu_call, gnat_node);\n \n-  /* If it's a function call, the result is the call expression unless a target\n-     is specified, in which case we copy the result into the target and return\n-     the assignment statement.  */\n-  if (Nkind (gnat_node) == N_Function_Call)\n-    {\n-      tree gnu_result = gnu_call;\n-\n-      /* If the function returns an unconstrained array or by direct reference,\n-\t we have to dereference the pointer.  */\n-      if (TYPE_RETURN_UNCONSTRAINED_P (gnu_subprog_type)\n-\t  || TYPE_RETURN_BY_DIRECT_REF_P (gnu_subprog_type))\n-\tgnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n-\n-      if (gnu_target)\n-\t{\n-\t  Node_Id gnat_parent = Parent (gnat_node);\n-\t  tree gnu_result_type = TREE_TYPE (gnu_subprog_type);\n-\t  enum tree_code op_code;\n-\n-\t  /* If range check is needed, emit code to generate it.  */\n-\t  if (Do_Range_Check (gnat_node))\n-\t    gnu_result\n-\t      = emit_range_check (gnu_result, Etype (Name (gnat_parent)),\n-\t\t\t\t  gnat_parent);\n-\n-\t  /* ??? If the return type has non-constant size, then force the\n-\t     return slot optimization as we would not be able to generate\n-\t     a temporary.  Likewise if it was unconstrained as we would\n-\t     copy too much data.  That's what has been done historically.  */\n-\t  if (!TREE_CONSTANT (TYPE_SIZE (gnu_result_type))\n-\t      || (TYPE_IS_PADDING_P (gnu_result_type)\n-\t\t  && CONTAINS_PLACEHOLDER_P\n-\t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_result_type))))))\n-\t    op_code = INIT_EXPR;\n-\t  else\n-\t    op_code = MODIFY_EXPR;\n-\n-\t  gnu_result\n-\t    = build_binary_op (op_code, NULL_TREE, gnu_target, gnu_result);\n-\t  add_stmt_with_node (gnu_result, gnat_parent);\n-\t  gnat_poplevel ();\n-\t  gnu_result = end_stmt_group ();\n-\t}\n-      else\n-\t{\n-\t  if (went_into_elab_proc)\n-\t    current_function_decl = NULL_TREE;\n-\t  *gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n-\t}\n-\n-      return gnu_result;\n-    }\n-\n-  /* If this is the case where the GNAT tree contains a procedure call but the\n-     Ada procedure has copy-in/copy-out parameters, then the special parameter\n-     passing mechanism must be used.  */\n+  /* If this is a subprogram with copy-in/copy-out parameters, we need to\n+     unpack the valued returned from the function into the In Out or Out\n+     parameters.  We deal with the function return (if this is an Ada\n+     function) below.  */\n   if (TYPE_CI_CO_LIST (gnu_subprog_type))\n     {\n       /* List of FIELD_DECLs associated with the PARM_DECLs of the copy-in/\n \t copy-out parameters.  */\n       tree gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n       const int length = list_length (gnu_cico_list);\n \n+      /* The call sequence must contain one and only one call, even though the\n+\t function is pure.  Save the result into a temporary if needed.  */\n       if (length > 1)\n \t{\n-\t  tree gnu_temp, gnu_stmt;\n-\n-\t  /* The call sequence must contain one and only one call, even though\n-\t     the function is pure.  Save the result into a temporary.  */\n-\t  gnu_temp = create_var_decl (create_tmp_var_name (\"R\"), NULL_TREE,\n-\t\t\t\t      TREE_TYPE (gnu_call), NULL_TREE, false,\n-\t\t\t\t      false, false, false, NULL, Empty);\n-\t  DECL_ARTIFICIAL (gnu_temp) = 1;\n-\t  DECL_IGNORED_P (gnu_temp) = 1;\n-\n-\t  gnu_stmt\n-\t    = build_binary_op (INIT_EXPR, NULL_TREE, gnu_temp, gnu_call);\n-\t  set_expr_location_from_node (gnu_stmt, gnat_node);\n-\n-\t  /* Add the call statement to the list and start from its result.  */\n+\t  tree gnu_stmt;\n+\t  gnu_call\n+\t    = create_init_temporary (\"R\", gnu_call, &gnu_stmt, gnat_node);\n \t  append_to_statement_list (gnu_stmt, &gnu_before_list);\n-\t  gnu_call = gnu_temp;\n \n \t  gnu_name_list = nreverse (gnu_name_list);\n \t}\n \n+      /* The first entry is for the actual return value if this is a\n+\t function, so skip it.  */\n+      if (TREE_VALUE (gnu_cico_list) == void_type_node)\n+\tgnu_cico_list = TREE_CHAIN (gnu_cico_list);\n+\n       if (Nkind (Name (gnat_node)) == N_Explicit_Dereference)\n \tgnat_formal = First_Formal_With_Extras (Etype (Name (gnat_node)));\n       else\n@@ -3129,7 +3140,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t   Present (gnat_actual);\n \t   gnat_formal = Next_Formal_With_Extras (gnat_formal),\n \t   gnat_actual = Next_Actual (gnat_actual))\n-\t/* If we are dealing with a copy in copy out parameter, we must\n+\t/* If we are dealing with a copy-in/copy-out parameter, we must\n \t   retrieve its value from the record returned in the call.  */\n \tif (!(present_gnu_tree (gnat_formal)\n \t      && TREE_CODE (get_gnu_tree (gnat_formal)) == PARM_DECL\n@@ -3208,14 +3219,109 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    gnu_name_list = TREE_CHAIN (gnu_name_list);\n \t  }\n     }\n-  else\n+\n+  /* If this is a function call, the result is the call expression unless a\n+     target is specified, in which case we copy the result into the target\n+     and return the assignment statement.  */\n+  if (Nkind (gnat_node) == N_Function_Call)\n+    {\n+      tree gnu_result_type = TREE_TYPE (gnu_subprog_type);\n+\n+      /* If this is a function with copy-in/copy-out parameters, extract the\n+\t return value from it and update the return type.  */\n+      if (TYPE_CI_CO_LIST (gnu_subprog_type))\n+\t{\n+\t  tree gnu_elmt = value_member (void_type_node,\n+\t\t\t\t\tTYPE_CI_CO_LIST (gnu_subprog_type));\n+\t  gnu_call = build_component_ref (gnu_call, NULL_TREE,\n+\t\t\t\t\t  TREE_PURPOSE (gnu_elmt), false);\n+\t  gnu_result_type = TREE_TYPE (gnu_call);\n+\t}\n+\n+      /* If the function returns an unconstrained array or by direct reference,\n+\t we have to dereference the pointer.  */\n+      if (TYPE_RETURN_UNCONSTRAINED_P (gnu_subprog_type)\n+\t  || TYPE_RETURN_BY_DIRECT_REF_P (gnu_subprog_type))\n+\tgnu_call = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_call);\n+\n+      if (gnu_target)\n+\t{\n+\t  Node_Id gnat_parent = Parent (gnat_node);\n+\t  enum tree_code op_code;\n+\n+\t  /* If range check is needed, emit code to generate it.  */\n+\t  if (Do_Range_Check (gnat_node))\n+\t    gnu_call\n+\t      = emit_range_check (gnu_call, Etype (Name (gnat_parent)),\n+\t\t\t\t  gnat_parent);\n+\n+\t  /* ??? If the return type has non-constant size, then force the\n+\t     return slot optimization as we would not be able to generate\n+\t     a temporary.  Likewise if it was unconstrained as we would\n+\t     copy too much data.  That's what has been done historically.  */\n+\t  if (!TREE_CONSTANT (TYPE_SIZE (gnu_result_type))\n+\t      || (TYPE_IS_PADDING_P (gnu_result_type)\n+\t\t  && CONTAINS_PLACEHOLDER_P\n+\t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_result_type))))))\n+\t    op_code = INIT_EXPR;\n+\t  else\n+\t    op_code = MODIFY_EXPR;\n+\n+\t  gnu_call\n+\t    = build_binary_op (op_code, NULL_TREE, gnu_target, gnu_call);\n+\t  set_expr_location_from_node (gnu_call, gnat_parent);\n+\t  append_to_statement_list (gnu_call, &gnu_before_list);\n+\t}\n+      else\n+\t*gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n+    }\n+\n+  /* Otherwise, if this is a procedure call statement without copy-in/copy-out\n+     parameters, the result is just the call statement.  */\n+  else if (!TYPE_CI_CO_LIST (gnu_subprog_type))\n     append_to_statement_list (gnu_call, &gnu_before_list);\n \n-  append_to_statement_list (gnu_after_list, &gnu_before_list);\n+  if (went_into_elab_proc)\n+    current_function_decl = NULL_TREE;\n \n-  add_stmt (gnu_before_list);\n-  gnat_poplevel ();\n-  return end_stmt_group ();\n+  /* If we have pushed a binding level, the result is the statement group.\n+     Otherwise it's just the call expression.  */\n+  if (pushed_binding_level)\n+    {\n+      /* If we need a value and haven't created the call statement, do so.  */\n+      if (returning_value && !TYPE_CI_CO_LIST (gnu_subprog_type))\n+\t{\n+\t  tree gnu_stmt;\n+\t  gnu_call\n+\t    = create_init_temporary (\"R\", gnu_call, &gnu_stmt, gnat_node);\n+\t  append_to_statement_list (gnu_stmt, &gnu_before_list);\n+\t}\n+      append_to_statement_list (gnu_after_list, &gnu_before_list);\n+      add_stmt (gnu_before_list);\n+      gnat_poplevel ();\n+      gnu_result = end_stmt_group ();\n+    }\n+  else\n+    return gnu_call;\n+\n+  /* If we need a value, make a COMPOUND_EXPR to return it; otherwise,\n+     return the result.  Deal specially with UNCONSTRAINED_ARRAY_REF.  */\n+  if (returning_value)\n+    {\n+      if (TREE_CODE (gnu_call) == UNCONSTRAINED_ARRAY_REF\n+\t  || TREE_CODE (gnu_call) == INDIRECT_REF)\n+\tgnu_result = build1 (TREE_CODE (gnu_call), TREE_TYPE (gnu_call),\n+\t\t\t     fold_build2 (COMPOUND_EXPR,\n+\t\t\t\t\t  TREE_TYPE (TREE_OPERAND (gnu_call,\n+\t\t\t\t\t\t\t\t   0)),\n+\t\t\t\t\t  gnu_result,\n+\t\t\t\t\t  TREE_OPERAND (gnu_call, 0)));\n+      else\n+\tgnu_result = fold_build2 (COMPOUND_EXPR, TREE_TYPE (gnu_call),\n+\t\t\t\t  gnu_result, gnu_call);\n+    }\n+\n+  return gnu_result;\n }\n \f\n /* Subroutine of gnat_to_gnu to translate gnat_node, an\n@@ -4958,25 +5064,22 @@ gnat_to_gnu (Node_Id gnat_node)\n       {\n \ttree gnu_ret_val, gnu_ret_obj;\n \n-\t/* If we have a return label defined, convert this into a branch to\n-\t   that label.  The return proper will be handled elsewhere.  */\n-\tif (VEC_last (tree, gnu_return_label_stack))\n-\t  {\n-\t    gnu_result = build1 (GOTO_EXPR, void_type_node,\n-\t\t\t\t VEC_last (tree, gnu_return_label_stack));\n-\t    /* When not optimizing, make sure the return is preserved.  */\n-\t    if (!optimize && Comes_From_Source (gnat_node))\n-\t      DECL_ARTIFICIAL (VEC_last (tree, gnu_return_label_stack)) = 0;\n-\t    break;\n-\t  }\n-\n \t/* If the subprogram is a function, we must return the expression.  */\n \tif (Present (Expression (gnat_node)))\n \t  {\n \t    tree gnu_subprog_type = TREE_TYPE (current_function_decl);\n+\t    tree gnu_ret_type = TREE_TYPE (gnu_subprog_type);\n \t    tree gnu_result_decl = DECL_RESULT (current_function_decl);\n \t    gnu_ret_val = gnat_to_gnu (Expression (gnat_node));\n \n+\t    /* If this function has copy-in/copy-out parameters, get the real\n+\t       variable and type for the return.  See Subprogram_to_gnu.  */\n+\t    if (TYPE_CI_CO_LIST (gnu_subprog_type))\n+\t      {\n+\t\tgnu_result_decl = VEC_last (tree, gnu_return_var_stack);\n+\t\tgnu_ret_type = TREE_TYPE (gnu_result_decl);\n+\t      }\n+\n \t    /* Do not remove the padding from GNU_RET_VAL if the inner type is\n \t       self-referential since we want to allocate the fixed size.  */\n \t    if (TREE_CODE (gnu_ret_val) == COMPONENT_REF\n@@ -4998,8 +5101,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      {\n \t\tgnu_ret_val = maybe_unconstrained_array (gnu_ret_val);\n \t\tgnu_ret_val = build_allocator (TREE_TYPE (gnu_ret_val),\n-\t\t\t\t\t       gnu_ret_val,\n-\t\t\t\t\t       TREE_TYPE (gnu_subprog_type),\n+\t\t\t\t\t       gnu_ret_val, gnu_ret_type,\n \t\t\t\t\t       Procedure_To_Call (gnat_node),\n \t\t\t\t\t       Storage_Pool (gnat_node),\n \t\t\t\t\t       gnat_node, false);\n@@ -5032,6 +5134,22 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_ret_obj = NULL_TREE;\n \t  }\n \n+\t/* If we have a return label defined, convert this into a branch to\n+\t   that label.  The return proper will be handled elsewhere.  */\n+\tif (VEC_last (tree, gnu_return_label_stack))\n+\t  {\n+\t    if (gnu_ret_obj)\n+\t      add_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_ret_obj,\n+\t\t\t\t\t gnu_ret_val));\n+\n+\t    gnu_result = build1 (GOTO_EXPR, void_type_node,\n+\t\t\t\t VEC_last (tree, gnu_return_label_stack));\n+\t    /* When not optimizing, make sure the return is preserved.  */\n+\t    if (!optimize && Comes_From_Source (gnat_node))\n+\t      DECL_ARTIFICIAL (VEC_last (tree, gnu_return_label_stack)) = 0;\n+\t    break;\n+\t  }\n+\n \tgnu_result = build_return_expr (gnu_ret_obj, gnu_ret_val);\n       }\n       break;"}, {"sha": "429f334ae46f1b0f873f686472727ea7db46a4e9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=35a382b82d0c7a65e5974298af5b32a003ea1fcf", "patch": "@@ -1,3 +1,8 @@\n+2010-10-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/in_out_parameter2.adb: New test.\n+\t* gnat.dg/in_out_parameter3.adb: Likewise.\n+\n 2010-10-25  Jie Zhang  <jie@codesourcery.com>\n \n \tg++.dg/opt/combine.c: New test."}, {"sha": "1b5cc7e6abf6634b2059f090d26a8f56d88367ba", "filename": "gcc/testsuite/gnat.dg/in_out_parameter2.adb", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Ftestsuite%2Fgnat.dg%2Fin_out_parameter2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Ftestsuite%2Fgnat.dg%2Fin_out_parameter2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fin_out_parameter2.adb?ref=35a382b82d0c7a65e5974298af5b32a003ea1fcf", "patch": "@@ -0,0 +1,24 @@\n+-- { dg-do run }\n+-- { dg-options \"-gnat12\" }\n+\n+procedure In_Out_Parameter2 is\n+\n+  function F (I : In Out Integer) return Boolean is\n+    A : Integer := I;\n+  begin\n+    I := I + 1;\n+    return (A > 0);\n+  end;\n+\n+  I : Integer := 0;\n+  B : Boolean;\n+\n+begin\n+  B := F (I);\n+  if B then\n+    raise Program_Error;\n+  end if;\n+  if I /= 1 then\n+    raise Program_Error;\n+  end if;\n+end;"}, {"sha": "dab3f8d52df83bd8aed90e424d7fe4db72e47fca", "filename": "gcc/testsuite/gnat.dg/in_out_parameter3.adb", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Ftestsuite%2Fgnat.dg%2Fin_out_parameter3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35a382b82d0c7a65e5974298af5b32a003ea1fcf/gcc%2Ftestsuite%2Fgnat.dg%2Fin_out_parameter3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fin_out_parameter3.adb?ref=35a382b82d0c7a65e5974298af5b32a003ea1fcf", "patch": "@@ -0,0 +1,42 @@\n+-- { dg-do run }\n+-- { dg-options \"-gnat12\" }\n+\n+procedure In_Out_Parameter3 is\n+\n+  type Arr is array (1..16) of Integer;\n+\n+  type Rec1 is record\n+    A : Arr;\n+    B : Boolean;\n+  end record;\n+\n+  type Rec2 is record\n+    R : Rec1;\n+  end record;\n+  pragma Pack (Rec2);\n+\n+  function F (I : In Out Rec1) return Boolean is\n+    A : Integer := I.A (1);\n+  begin\n+    I.A (1) := I.A (1) + 1;\n+    return (A > 0);\n+  end;\n+\n+  I : Rec2 := (R => (A => (others => 0), B => True));\n+  B : Boolean;\n+\n+begin\n+  B := F (I.R);\n+  if B then\n+    raise Program_Error;\n+  end if;\n+  if I.R.A (1) /= 1 then\n+    raise Program_Error;\n+  end if;\n+  if F (I.R) = False then\n+     raise Program_Error;\n+  end if;\n+  if I.R.A (1) /= 2 then\n+    raise Program_Error;\n+  end if;\n+end;"}]}