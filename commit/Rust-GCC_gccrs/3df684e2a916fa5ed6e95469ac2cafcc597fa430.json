{"sha": "3df684e2a916fa5ed6e95469ac2cafcc597fa430", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RmNjg0ZTJhOTE2ZmE1ZWQ2ZTk1NDY5YWMyY2FmY2M1OTdmYTQzMA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-08-22T10:53:40Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-08-22T10:53:40Z"}, "message": "gfortran.h (in_prefix): Removed from this header.\n\n2008-08-22  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.h (in_prefix): Removed from this header.\n\t* match.h (gfc_matching_prefix): Moved and renamed from `in_prefix'.\n\t* decl.c (in_prefix): Removed from here.\n\t(gfc_match_prefix): Use new name of `gfc_matching_prefix'.\n\t* symbol.c (gfc_check_symbol_typed): Ditto.\n\t* expr.c (check_typed_ns): New helper variable.\n\t(expr_check_typed_help): New helper method.\n\t(gfc_expr_check_typed): Rewrote to use gfc_traverse_expr to do the\n\twork, fixing a minor problem.\n\t* match.c (gfc_matching_prefix): New variable.\n\nFrom-SVN: r139435", "tree": {"sha": "a6aa2c356ea640719d7b66506437016368b699e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6aa2c356ea640719d7b66506437016368b699e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3df684e2a916fa5ed6e95469ac2cafcc597fa430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3df684e2a916fa5ed6e95469ac2cafcc597fa430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3df684e2a916fa5ed6e95469ac2cafcc597fa430", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3df684e2a916fa5ed6e95469ac2cafcc597fa430/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0d4aed994f4f2f3d5176a642c97912b3200e4660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4aed994f4f2f3d5176a642c97912b3200e4660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d4aed994f4f2f3d5176a642c97912b3200e4660"}], "stats": {"total": 142, "additions": 76, "deletions": 66}, "files": [{"sha": "1b588cd9d9ca9549a2bb99cfcc5aa552b5ec0570", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3df684e2a916fa5ed6e95469ac2cafcc597fa430", "patch": "@@ -1,3 +1,16 @@\n+2008-08-22  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.h (in_prefix): Removed from this header.\n+\t* match.h (gfc_matching_prefix): Moved and renamed from `in_prefix'.\n+\t* decl.c (in_prefix): Removed from here.\n+\t(gfc_match_prefix): Use new name of `gfc_matching_prefix'.\n+\t* symbol.c (gfc_check_symbol_typed): Ditto.\n+\t* expr.c (check_typed_ns): New helper variable.\n+\t(expr_check_typed_help): New helper method.\n+\t(gfc_expr_check_typed): Rewrote to use gfc_traverse_expr to do the\n+\twork, fixing a minor problem.\n+\t* match.c (gfc_matching_prefix): New variable.\n+\n 2008-08-22  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/32095"}, {"sha": "04d25cc7eff78d52ff1342e0326893aa6bbb73ea", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=3df684e2a916fa5ed6e95469ac2cafcc597fa430", "patch": "@@ -3753,8 +3753,6 @@ gfc_match_data_decl (void)\n    can be matched.  Note that if nothing matches, MATCH_YES is\n    returned (the null string was matched).  */\n \n-bool in_prefix = false;\n-\n match\n gfc_match_prefix (gfc_typespec *ts)\n {\n@@ -3763,8 +3761,8 @@ gfc_match_prefix (gfc_typespec *ts)\n   gfc_clear_attr (&current_attr);\n   seen_type = 0;\n \n-  gcc_assert (!in_prefix);\n-  in_prefix = true;\n+  gcc_assert (!gfc_matching_prefix);\n+  gfc_matching_prefix = true;\n \n loop:\n   if (!seen_type && ts != NULL\n@@ -3801,13 +3799,13 @@ gfc_match_prefix (gfc_typespec *ts)\n     }\n \n   /* At this point, the next item is not a prefix.  */\n-  gcc_assert (in_prefix);\n-  in_prefix = false;\n+  gcc_assert (gfc_matching_prefix);\n+  gfc_matching_prefix = false;\n   return MATCH_YES;\n \n error:\n-  gcc_assert (in_prefix);\n-  in_prefix = false;\n+  gcc_assert (gfc_matching_prefix);\n+  gfc_matching_prefix = false;\n   return MATCH_ERROR;\n }\n "}, {"sha": "5e6214b73860fbd60a6811dd9ff73650e8a4b5e0", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 23, "deletions": 55, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=3df684e2a916fa5ed6e95469ac2cafcc597fa430", "patch": "@@ -3276,68 +3276,36 @@ gfc_expr_set_symbols_referenced (gfc_expr *expr)\n \n    The namespace is needed for IMPLICIT typing.  */\n \n-gfc_try\n-gfc_expr_check_typed (gfc_expr* e, gfc_namespace* ns, bool strict)\n+static gfc_namespace* check_typed_ns;\n+\n+static bool\n+expr_check_typed_help (gfc_expr* e, gfc_symbol* sym ATTRIBUTE_UNUSED,\n+                       int* f ATTRIBUTE_UNUSED)\n {\n   gfc_try t;\n-  gfc_actual_arglist* act;\n-  gfc_constructor* c;\n-\n-  if (!e)\n-    return SUCCESS;\n-\n-  /* FIXME:  Check indices for EXPR_VARIABLE / EXPR_SUBSTRING, too, to catch\n-     things like len(arr(1:n)) as specification expression.  */\n-\n-  switch (e->expr_type)\n-    {\n-\n-    case EXPR_NULL:\n-    case EXPR_CONSTANT:\n-    case EXPR_SUBSTRING:\n-      break;\n-\n-    case EXPR_VARIABLE:\n-      gcc_assert (e->symtree);\n-      t = gfc_check_symbol_typed (e->symtree->n.sym, ns, strict, e->where);\n-      if (t == FAILURE)\n-\treturn t;\n-      break;\n-\n-    case EXPR_FUNCTION:\n-      for (act = e->value.function.actual; act; act = act->next)\n-\t{\n-\t  t = gfc_expr_check_typed (act->expr, ns, true);\n-\t  if (t == FAILURE)\n-\t    return t;\n-\t}\n-      break;\n \n-    case EXPR_OP:\n-      t = gfc_expr_check_typed (e->value.op.op1, ns, true);\n-      if (t == FAILURE)\n-\treturn t;\n+  if (e->expr_type != EXPR_VARIABLE)\n+    return false;\n \n-      t = gfc_expr_check_typed (e->value.op.op2, ns, true);\n-      if (t == FAILURE)\n-\treturn t;\n+  gcc_assert (e->symtree);\n+  t = gfc_check_symbol_typed (e->symtree->n.sym, check_typed_ns,\n+                              true, e->where);\n \n-      break;\n+  return (t == FAILURE);\n+}\n \n-    case EXPR_STRUCTURE:\n-    case EXPR_ARRAY:\n-      for (c = e->value.constructor; c; c = c->next)\n-\t{\n-\t  t = gfc_expr_check_typed (c->expr, ns, true);\n-\t  if (t == FAILURE)\n-\t    return t;\n-\t}\n-      break;\n+gfc_try\n+gfc_expr_check_typed (gfc_expr* e, gfc_namespace* ns, bool strict)\n+{\n+  bool error_found;\n \n-    default:\n-      gcc_unreachable ();\n+  /* If this is a top-level variable, do the check with strict given to us.  */\n+  if (!strict && e->expr_type == EXPR_VARIABLE && !e->ref)\n+    return gfc_check_symbol_typed (e->symtree->n.sym, ns, strict, e->where);\n \n-    }\n+  /* Otherwise, walk the expression and do it strictly.  */\n+  check_typed_ns = ns;\n+  error_found = gfc_traverse_expr (e, NULL, &expr_check_typed_help, 0);\n \n-  return SUCCESS;\n+  return error_found ? FAILURE : SUCCESS;\n }"}, {"sha": "6b5c02a79ee08850e1f3b989051714b01df2f344", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=3df684e2a916fa5ed6e95469ac2cafcc597fa430", "patch": "@@ -2245,8 +2245,6 @@ void copy_formal_args (gfc_symbol *dest, gfc_symbol *src);\n \n void gfc_free_finalizer (gfc_finalizer *el); /* Needed in resolve.c, too  */\n \n-/* FIXME:  Do this with parser-state instead of global variable.  */\n-extern bool in_prefix;\n gfc_try gfc_check_symbol_typed (gfc_symbol*, gfc_namespace*, bool, locus);\n \n /* intrinsic.c */"}, {"sha": "a02d1d17c667aa99a88f19e005eac4a5b49bddf9", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=3df684e2a916fa5ed6e95469ac2cafcc597fa430", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"parse.h\"\n \n int gfc_matching_procptr_assignment = 0;\n+bool gfc_matching_prefix = false;\n \n /* For debugging and diagnostic purposes.  Return the textual representation\n    of the intrinsic operator OP.  */"}, {"sha": "02d088e12d2c8447a0521a0da588a2274471a05c", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=3df684e2a916fa5ed6e95469ac2cafcc597fa430", "patch": "@@ -34,6 +34,7 @@ extern gfc_symbol *gfc_new_block;\n extern gfc_st_label *gfc_statement_label;\n \n extern int gfc_matching_procptr_assignment;\n+extern bool gfc_matching_prefix;\n \n /****************** All gfc_match* routines *****************/\n "}, {"sha": "f49f773d20e6b1a81bfff0232c406747f6d214a9", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=3df684e2a916fa5ed6e95469ac2cafcc597fa430", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"gfortran.h\"\n #include \"parse.h\"\n+#include \"match.h\"\n \n \n /* Strings for all symbol attributes.  We use these for dumping the\n@@ -4240,7 +4241,7 @@ gfc_check_symbol_typed (gfc_symbol* sym, gfc_namespace* ns,\n {\n   gcc_assert (sym);\n \n-  if (in_prefix)\n+  if (gfc_matching_prefix)\n     return SUCCESS;\n \n   /* Check for the type and try to give it an implicit one.  */"}, {"sha": "ae16c70a1f355dd6dfee37ca27ee4839731b4eeb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3df684e2a916fa5ed6e95469ac2cafcc597fa430", "patch": "@@ -1,3 +1,7 @@\n+2008-08-22  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.dg/used_before_typed_4.f90: New test.\n+\n 2008-08-22  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/32095"}, {"sha": "9d7ccc10add4d83dc171ea6c16a437ebeccd1b35", "filename": "gcc/testsuite/gfortran.dg/used_before_typed_4.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3df684e2a916fa5ed6e95469ac2cafcc597fa430/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_before_typed_4.f90?ref=3df684e2a916fa5ed6e95469ac2cafcc597fa430", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+\n+! Test for a special case of the used-before-typed errors, when the symbols\n+! not-yet-typed are indices.\n+\n+SUBROUTINE test (n, arr1, m, arr2) ! { dg-error \"has no IMPLICIT type\" }\n+  IMPLICIT NONE\n+\n+  INTEGER :: myarr(42)\n+\n+  INTEGER :: arr1(SIZE (myarr(1:n))) ! { dg-error \"'n' is used before\" }\n+  INTEGER :: n\n+\n+  INTEGER :: arr2(LEN (\"hello\"(1:m))) ! { dg-error \"'m' is used before\" }\n+  INTEGER :: m\n+\n+  WRITE (*,*) SIZE (arr1)\n+  WRITE (*,*) SIZE (arr2)\n+END SUBROUTINE test\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER :: arr1(42), arr2(42)\n+  CALL test (3, arr1, 2, arr2)\n+END PROGRAM main"}]}