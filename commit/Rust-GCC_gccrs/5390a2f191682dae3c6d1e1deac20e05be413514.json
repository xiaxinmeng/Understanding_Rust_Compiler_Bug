{"sha": "5390a2f191682dae3c6d1e1deac20e05be413514", "node_id": "C_kwDOANBUbNoAKDUzOTBhMmYxOTE2ODJkYWUzYzZkMWUxZGVhYzIwZTA1YmU0MTM1MTQ", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2022-01-30T18:08:14Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2022-02-09T12:30:13Z"}, "message": "x86: Check each component of source operand for AVX_U128_DIRTY\n\ncommit 9775e465c1fbfc32656de77c618c61acf5bd905d\nAuthor: H.J. Lu <hjl.tools@gmail.com>\nDate:   Tue Jul 27 07:46:04 2021 -0700\n\n    x86: Don't set AVX_U128_DIRTY when zeroing YMM/ZMM register\n\ncalled ix86_check_avx_upper_register to check mode on source operand.\nBut ix86_check_avx_upper_register doesn't work on source operand like\n\n(vec_select:V2DI (reg/v:V4DI 23 xmm3 [orig:91 ymm ] [91])\n    (parallel [\n            (const_int 2 [0x2])\n            (const_int 3 [0x3])\n        ]))\n\nAdd ix86_avx_u128_mode_source to check mode for each component of source\noperand.\n\ngcc/\n\n\tPR target/104441\n\t* config/i386/i386.cc (ix86_avx_u128_mode_source): New function.\n\t(ix86_avx_u128_mode_needed): Return AVX_U128_ANY for debug INSN.\n\tCall ix86_avx_u128_mode_source to check mode for each component\n\tof source operand.\n\ngcc/testsuite/\n\n\tPR target/104441\n\t* gcc.target/i386/pr104441-1a.c: New test.\n\t* gcc.target/i386/pr104441-1b.c: Likewise.", "tree": {"sha": "8e601cbe75954c26b809329c26b25f3d8a4d138d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e601cbe75954c26b809329c26b25f3d8a4d138d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5390a2f191682dae3c6d1e1deac20e05be413514", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5390a2f191682dae3c6d1e1deac20e05be413514", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5390a2f191682dae3c6d1e1deac20e05be413514", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5390a2f191682dae3c6d1e1deac20e05be413514/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59b31f0e2d187ebdb3d399661e22b28e4ebd8099", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b31f0e2d187ebdb3d399661e22b28e4ebd8099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59b31f0e2d187ebdb3d399661e22b28e4ebd8099"}], "stats": {"total": 234, "additions": 168, "deletions": 66}, "files": [{"sha": "db5e1681e980ca936d5240f2ffef406c3acd6778", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 79, "deletions": 66, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5390a2f191682dae3c6d1e1deac20e05be413514/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5390a2f191682dae3c6d1e1deac20e05be413514/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=5390a2f191682dae3c6d1e1deac20e05be413514", "patch": "@@ -14365,11 +14365,82 @@ ix86_check_avx_upper_stores (rtx dest, const_rtx, void *data)\n     }\n  }\n \n+/* For YMM/ZMM store or YMM/ZMM extract.  Return mode for the source\n+   operand of SRC DEFs in the same basic block before INSN.  */\n+\n+static int\n+ix86_avx_u128_mode_source (rtx_insn *insn, const_rtx src)\n+{\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n+  rtx_insn *end = BB_END (bb);\n+\n+  /* Return AVX_U128_DIRTY if there is no DEF in the same basic\n+     block.  */\n+  int status = AVX_U128_DIRTY;\n+\n+  for (df_ref def = DF_REG_DEF_CHAIN (REGNO (src));\n+       def; def = DF_REF_NEXT_REG (def))\n+    if (DF_REF_BB (def) == bb)\n+      {\n+\t/* Ignore DEF from different basic blocks.  */\n+\trtx_insn *def_insn = DF_REF_INSN (def);\n+\n+\t/* Check if DEF_INSN is before INSN.  */\n+\trtx_insn *next;\n+\tfor (next = NEXT_INSN (def_insn);\n+\t     next != nullptr && next != end && next != insn;\n+\t     next = NEXT_INSN (next))\n+\t  ;\n+\n+\t/* Skip if DEF_INSN isn't before INSN.  */\n+\tif (next != insn)\n+\t  continue;\n+\n+\t/* Return AVX_U128_DIRTY if the source operand of DEF_INSN\n+\t   isn't constant zero.  */\n+\n+\tif (CALL_P (def_insn))\n+\t  {\n+\t    bool avx_upper_reg_found = false;\n+\t    note_stores (def_insn,\n+\t\t\t ix86_check_avx_upper_stores,\n+\t\t\t &avx_upper_reg_found);\n+\n+\t    /* Return AVX_U128_DIRTY if call returns AVX.  */\n+\t    if (avx_upper_reg_found)\n+\t      return AVX_U128_DIRTY;\n+\n+\t    continue;\n+\t  }\n+\n+\trtx set = single_set (def_insn);\n+\tif (!set)\n+\t  return AVX_U128_DIRTY;\n+\n+\trtx dest = SET_DEST (set);\n+\n+\t/* Skip if DEF_INSN is not an AVX load.  Return AVX_U128_DIRTY\n+\t   if the source operand isn't constant zero.  */\n+\tif (ix86_check_avx_upper_register (dest)\n+\t    && standard_sse_constant_p (SET_SRC (set),\n+\t\t\t\t\tGET_MODE (dest)) != 1)\n+\t  return AVX_U128_DIRTY;\n+\n+\t/* We get here only if all AVX loads are from constant zero.  */\n+\tstatus = AVX_U128_ANY;\n+      }\n+\n+  return status;\n+}\n+\n /* Return needed mode for entity in optimize_mode_switching pass.  */\n \n static int\n ix86_avx_u128_mode_needed (rtx_insn *insn)\n {\n+  if (DEBUG_INSN_P (insn))\n+    return AVX_U128_ANY;\n+\n   if (CALL_P (insn))\n     {\n       rtx link;\n@@ -14409,6 +14480,8 @@ ix86_avx_u128_mode_needed (rtx_insn *insn)\n       return AVX_U128_CLEAN;\n     }\n \n+  subrtx_iterator::array_type array;\n+\n   rtx set = single_set (insn);\n   if (set)\n     {\n@@ -14423,74 +14496,15 @@ ix86_avx_u128_mode_needed (rtx_insn *insn)\n \t  else\n \t    return AVX_U128_ANY;\n \t}\n-      else if (ix86_check_avx_upper_register (src))\n+      else\n \t{\n-\t  /* This is an YMM/ZMM store.  Check for the source operand\n-\t     of SRC DEFs in the same basic block before INSN.  */\n-\t  basic_block bb = BLOCK_FOR_INSN (insn);\n-\t  rtx_insn *end = BB_END (bb);\n-\n-\t  /* Return AVX_U128_DIRTY if there is no DEF in the same basic\n-\t     block.  */\n-\t  int status = AVX_U128_DIRTY;\n-\n-\t  for (df_ref def = DF_REG_DEF_CHAIN (REGNO (src));\n-\t       def; def = DF_REF_NEXT_REG (def))\n-\t    if (DF_REF_BB (def) == bb)\n+\t  FOR_EACH_SUBRTX (iter, array, src, NONCONST)\n+\t    if (ix86_check_avx_upper_register (*iter))\n \t      {\n-\t\t/* Ignore DEF from different basic blocks.  */\n-\t\trtx_insn *def_insn = DF_REF_INSN (def);\n-\n-\t\t/* Check if DEF_INSN is before INSN.  */\n-\t\trtx_insn *next;\n-\t\tfor (next = NEXT_INSN (def_insn);\n-\t\t     next != nullptr && next != end && next != insn;\n-\t\t     next = NEXT_INSN (next))\n-\t\t  ;\n-\n-\t\t/* Skip if DEF_INSN isn't before INSN.  */\n-\t\tif (next != insn)\n-\t\t  continue;\n-\n-\t\t/* Return AVX_U128_DIRTY if the source operand of\n-\t\t   DEF_INSN isn't constant zero.  */\n-\n-\t\tif (CALL_P (def_insn))\n-\t\t  {\n-\t\t    bool avx_upper_reg_found = false;\n-\t\t    note_stores (def_insn, ix86_check_avx_upper_stores,\n-\t\t\t\t &avx_upper_reg_found);\n-\n-\t\t    /* Return AVX_U128_DIRTY if call returns AVX.  */\n-\t\t    if (avx_upper_reg_found)\n-\t\t      return AVX_U128_DIRTY;\n-\n-\t\t    continue;\n-\t\t  }\n-\n-\t\tset = single_set (def_insn);\n-\t\tif (!set)\n-\t\t  return AVX_U128_DIRTY;\n-\n-\t\tdest = SET_DEST (set);\n-\n-\t\t/* Skip if DEF_INSN is not an AVX load.  */\n-\t\tif (ix86_check_avx_upper_register (dest))\n-\t\t  {\n-\t\t    src = SET_SRC (set);\n-\t\t    /* Return AVX_U128_DIRTY if the source operand isn't\n-\t\t       constant zero.  */\n-\t\t    if (standard_sse_constant_p (src, GET_MODE (dest))\n-\t\t\t!= 1)\n-\t\t      return AVX_U128_DIRTY;\n-\t\t  }\n-\n-\t\t/* We get here only if all AVX loads are from constant\n-\t\t   zero.  */\n-\t\tstatus = AVX_U128_ANY;\n+\t\tint status = ix86_avx_u128_mode_source (insn, *iter);\n+\t\tif (status == AVX_U128_DIRTY)\n+\t\t  return status;\n \t      }\n-\n-\t  return status;\n \t}\n \n       /* This isn't YMM/ZMM load/store.  */\n@@ -14501,7 +14515,6 @@ ix86_avx_u128_mode_needed (rtx_insn *insn)\n      Hardware changes state only when a 256bit register is written to,\n      but we need to prevent the compiler from moving optimal insertion\n      point above eventual read from 256bit or 512 bit register.  */\n-  subrtx_iterator::array_type array;\n   FOR_EACH_SUBRTX (iter, array, PATTERN (insn), NONCONST)\n     if (ix86_check_avx_upper_register (*iter))\n       return AVX_U128_DIRTY;"}, {"sha": "f4d263205f8c4781293bec04f045f07284dc5496", "filename": "gcc/testsuite/gcc.target/i386/pr104441-1a.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5390a2f191682dae3c6d1e1deac20e05be413514/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104441-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5390a2f191682dae3c6d1e1deac20e05be413514/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104441-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104441-1a.c?ref=5390a2f191682dae3c6d1e1deac20e05be413514", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mtune=skylake -Wno-attributes\" } */\n+\n+#include <x86intrin.h>\n+#include <stdint.h>\n+\n+__attribute__((always_inline, target(\"avx2\")))\n+static __m256i\n+load8bit_4x4_avx2(const uint8_t *const src, const uint32_t stride)\n+{\n+  __m128i src01, src23;\n+  src01 = _mm_cvtsi32_si128(*(int32_t*)(src + 0 * stride));\n+  src23 = _mm_insert_epi32(src23, *(int32_t *)(src + 3 * stride), 1);\n+  return _mm256_setr_m128i(src01, src23);\n+}\n+\n+__attribute__ ((noinline, noipa, target(\"avx2\")))\n+uint32_t\n+compute4x_m_sad_avx2_intrin(uint8_t *src, uint32_t src_stride,\n+\t\t\t    uint8_t *ref, uint32_t ref_stride,\n+\t\t\t    uint32_t height)\n+{\n+  __m128i xmm0;\n+  __m256i ymm = _mm256_setzero_si256();\n+  uint32_t y;\n+\n+  for (y = 0; y < height; y += 4) {\n+    const __m256i src0123 = load8bit_4x4_avx2(src, src_stride);\n+    const __m256i ref0123 = load8bit_4x4_avx2(ref, ref_stride);\n+    ymm = _mm256_add_epi32(ymm, _mm256_sad_epu8(src0123, ref0123));\n+    src += src_stride << 2;\n+    ref += ref_stride << 2;\n+  }\n+\n+  xmm0 = _mm_add_epi32(_mm256_castsi256_si128(ymm),\n+\t\t       _mm256_extracti128_si256(ymm, 1));\n+\n+  return (uint32_t)_mm_cvtsi128_si32(xmm0);\n+}  \n+\n+/* Expect assembly like:\n+\n+\tvextracti128\t$0x1, %ymm3, %xmm3\n+\tvpaddd\t%xmm3, %xmm0, %xmm0\n+\tvmovd\t%xmm0, %eax\n+\tvzeroupper\n+\n+rather than:\n+\n+\tvzeroupper\n+\tvextracti128\t$0x1, %ymm3, %xmm3\n+\tvpaddd\t%xmm3, %xmm0, %xmm0\n+\tvmovd\t%xmm0, %eax\n+\n+ */\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]+vextracti128\\[ \\t\\]+\\[^\\n\\]+\\n\\[ \\t\\]+vpaddd\\[ \\t\\]+\\[^\\n\\]+\\n\\[ \\t\\]+vmovd\\[ \\t\\]+\\[^\\n\\]+\\n\\[ \\t\\]+vzeroupper\" } } */"}, {"sha": "0b8a796d93cf10c3284141b24bada24e85551a98", "filename": "gcc/testsuite/gcc.target/i386/pr104441-1b.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5390a2f191682dae3c6d1e1deac20e05be413514/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104441-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5390a2f191682dae3c6d1e1deac20e05be413514/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104441-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104441-1b.c?ref=5390a2f191682dae3c6d1e1deac20e05be413514", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mvzeroupper -Wno-attributes\" } */\n+\n+#include \"pr104441-1a.c\"\n+\n+#define ARRAY_SIZE 255\n+\n+__attribute__ ((noinline, noipa))\n+static void\n+do_test (void)\n+{\n+  uint8_t src[ARRAY_SIZE];\n+  uint8_t ref[ARRAY_SIZE];\n+  uint32_t x;\n+  uint32_t i;\n+  for (i = 0; i < ARRAY_SIZE; i++)\n+    {\n+      src[i] = i;\n+      ref[i] = i;\n+    }\n+  x = compute4x_m_sad_avx2_intrin(src, 64 >> 2, ref, 64, 4);\n+  if (x != 0x240)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  if (__builtin_cpu_supports (\"avx2\"))\n+    do_test ();\n+  return 0;\n+}"}]}