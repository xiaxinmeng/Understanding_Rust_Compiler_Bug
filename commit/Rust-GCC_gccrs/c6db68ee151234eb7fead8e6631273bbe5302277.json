{"sha": "c6db68ee151234eb7fead8e6631273bbe5302277", "node_id": "C_kwDOANBUbNoAKGM2ZGI2OGVlMTUxMjM0ZWI3ZmVhZDhlNjYzMTI3M2JiZTUzMDIyNzc", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-01-18T11:23:37Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-02-08T11:02:54Z"}, "message": "macros: Perform macro expansion in a fixed-point fashion.\n\nThis commit changes our macro expansion system from an eager and recursive\nmacro expansion to a fixed-point like system. Instead of, when seeing\na macro invocation, expanding it and all of the macros within it, we\nnow perform multiple passes of expansion on the entire crate.\n\nThis, however, leads to a problem. Rust macros are expanded lazily, but\nRust builtin macros should be expanded eagerly. Due to this, we must\nwork around the lazy expansion in builtin macros and perform eager\nexpansion for each pass of the fixed-point, before finally expanding\nthe builtin when there are no longer any inner macro invocations.\n\nTo perform proper macro scoping, the ENR now keeps track of the current\nscope (`current_scope` member) and resolves macros accordingly.\n\nThis is done through the use of the `scoped` method, which creates a new\nscope, runs a specified lambda and then exits the scope. This prevents\npushing/popping errors that we've seen happen already in similar\ncontexts.\n\nWe might think about generalizing it to other classes, providing a\n`Scoped<EntryFn, ExitFn>` class or similar\n\ngcc/rust/ChangeLog:\n\n\t* ast/rust-macro.cc: New file.\n\t* Make-lang.in: Add `rust-macro.o` object\n\t* ast/rust-ast-fragment.cc (Fragment::Fragment): Change API around\n\tthe construction of AST fragments.\n\t(Fragment::operator=): Correct `Fragment::operator=` to take into\n\taccount the fragment tokens.\n\t(Fragment::create_error): Use new constructor.\n\t(Fragment::complete): Remove in favor of new constructor.\n\t(Fragment::unexpanded): Remove as that Fragment type is no longer used\n\tor possible.\n\t(Fragment::get_tokens): Add helper to access a fragment's tokens.\n\t* ast/rust-ast-fragment.h (enum class): Remove `FragmentKind::Unused`\n\t* ast/rust-ast.cc (MacroInvocation::as_string): Display\n\tbuiltin macro invocations properly.\n\t* ast/rust-ast.h: Fix `DelimTokenTree` class copy constructors and\n\thandling of its token vector.\n\t* ast/rust-macro.h (class MacroMatcher): Format.\n\t(class MetaItemSeq): Likewise.\n\t(builtin_macro_from_string): Get a `BuiltinMacroKind` from a given\n\tstring, i.e the name of the macro (`assert!`, `cfg!` and so on).\n\t* expand/rust-attribute-visitor.cc (AttrVisitor::visit): Do not expand\n\tmacros recursively anymore.\n\t(AttrVisitor::maybe_expand_expr): Likewise.\n\t(AttrVisitor::maybe_expand_type): Likewise.\n\t* expand/rust-attribute-visitor.h: Likewise, and remove\n\t`expand_macro_fragment_recursively` function.\n\t* expand/rust-macro-builtins.cc (make_token): Add shorthand for\n\treturning `std::unique_ptr<AST::Token>`s.\n\t(make_macro_invocation): Add shorthand for returning fragments\n\tcontaining builtin macro invocations.\n\t(try_expand_macro_expression): Do not expand macros recursively.\n\t(try_expand_single_string_literal): Likewise.\n\t(try_expand_many_expr): Likewise.\n\t(parse_single_string_literal): Error out more appropriately.\n\t(MacroBuiltin::file_handler): Return the proper tokens associated with\n\tmacro invocation, and builtin macros in the case of necessary eager\n\texpansion.\n\t(MacroBuiltin::column_handler): Likewise.\n\t(MacroBuiltin::include_bytes_handler): Likewise.\n\t(MacroBuiltin::include_str_handler): Likewise.\n\t(MacroBuiltin::concat_handler): Likewise.\n\t(MacroBuiltin::env_handler): Likewise.\n\t(MacroBuiltin::cfg_handler): Likewise.\n\t(MacroBuiltin::include_handler): Likewise.\n\t(MacroBuiltin::line_handler): Likewise.\n\t* expand/rust-macro-expand.cc (MacroExpander::expand_eager_invocations):\n\tAdd function to expand eager invocations *once* in the fixed point\n\tpipeline.\n\t(MacroExpander::expand_invoc): Call into `expand_eager_invocations` for\n\tbuiltin macro invocations.\n\t(MacroExpander::expand_crate): Use new `AttrVisitor` API.\n\t(parse_many): Return tokens in `AST::Fragment`.\n\t(transcribe_expression): Likewise.\n\t(transcribe_type): Likewise.\n\t* expand/rust-macro-expand.h (struct MacroExpander): Add `has_changed`\n\tflag for fixed point checking.\n\t* resolve/rust-early-name-resolver.cc (EarlyNameResolver::EarlyNameResolver):\n\tKeep track of the current macro scope.\n\t(EarlyNameResolver::go): Use `scoped` API.\n\t(EarlyNameResolver::visit): Likewise.\n\t* resolve/rust-early-name-resolver.h: Add `scoped` API.\n\t* rust-session-manager.cc (Session::expansion): Perform macro expansion\n\tin a fixed-point fashion.\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/macro17.rs: Fix testsuite for new recursion errors.\n\t* rust/compile/macro44.rs: Fix invalid testcase assertions.\n\t* rust/compile/builtin_macro_recurse.rs: Fix invalid test.\n\t* rust/compile/builtin_macro_recurse2.rs: New test.\n\t* rust/compile/macro46.rs: New test.", "tree": {"sha": "40a40cfe7eae0a0c24b5912c8a6d23fb5263ff47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40a40cfe7eae0a0c24b5912c8a6d23fb5263ff47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6db68ee151234eb7fead8e6631273bbe5302277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6db68ee151234eb7fead8e6631273bbe5302277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6db68ee151234eb7fead8e6631273bbe5302277", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6db68ee151234eb7fead8e6631273bbe5302277/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9501cbe2624a80365e33550fc92035620a64e7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9501cbe2624a80365e33550fc92035620a64e7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9501cbe2624a80365e33550fc92035620a64e7b"}], "stats": {"total": 985, "additions": 747, "deletions": 238}, "files": [{"sha": "989c0796ddba5db1d884bca9581ed5b5ecf8d9f3", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -90,6 +90,7 @@ GRS_OBJS = \\\n     rust/rust-hir-map.o \\\n     rust/rust-attributes.o \\\n     rust/rust-abi.o \\\n+\trust/rust-macro.o \\\n     rust/rust-ast-lower.o \\\n     rust/rust-ast-lower-base.o \\\n     rust/rust-ast-lower-pattern.o \\"}, {"sha": "fba629c0119e05e09978d2f67454e2ef935d645a", "filename": "gcc/rust/ast/rust-ast-fragment.cc", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-ast-fragment.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-ast-fragment.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-fragment.cc?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -21,8 +21,9 @@\n namespace Rust {\n namespace AST {\n \n-Fragment::Fragment (FragmentKind kind, std::vector<SingleASTNode> nodes)\n-  : kind (kind), nodes (std::move (nodes))\n+Fragment::Fragment (FragmentKind kind, std::vector<SingleASTNode> nodes,\n+\t\t    std::vector<std::unique_ptr<AST::Token>> tokens)\n+  : kind (kind), nodes (std::move (nodes)), tokens (std::move (tokens))\n {}\n \n Fragment::Fragment (Fragment const &other) : kind (other.get_kind ())\n@@ -33,33 +34,38 @@ Fragment::Fragment (Fragment const &other) : kind (other.get_kind ())\n Fragment &\n Fragment::operator= (Fragment const &other)\n {\n+  kind = other.get_kind ();\n+\n   nodes.clear ();\n   nodes.reserve (other.nodes.size ());\n-  kind = other.get_kind ();\n   for (auto &n : other.nodes)\n-    {\n-      nodes.push_back (n);\n-    }\n+    nodes.push_back (n);\n+\n+  tokens.clear ();\n+  tokens.reserve (other.tokens.size ());\n+  for (auto &t : other.tokens)\n+    tokens.emplace_back (t->clone_token ());\n \n   return *this;\n }\n \n Fragment\n Fragment::create_error ()\n {\n-  return Fragment (FragmentKind::Error, {});\n+  return Fragment (FragmentKind::Error, {}, {});\n }\n \n-Fragment\n-Fragment::complete (std::vector<AST::SingleASTNode> nodes)\n-{\n-  return Fragment (FragmentKind::Complete, std::move (nodes));\n-}\n+Fragment::Fragment (std::vector<AST::SingleASTNode> nodes,\n+\t\t    std::vector<std::unique_ptr<AST::Token>> tokens)\n+  : kind (FragmentKind::Complete), nodes (std::move (nodes)),\n+    tokens (std::move (tokens))\n+{}\n \n-Fragment\n-Fragment::unexpanded ()\n+Fragment::Fragment (std::vector<AST::SingleASTNode> nodes,\n+\t\t    std::unique_ptr<AST::Token> token)\n+  : kind (FragmentKind::Complete), nodes (std::move (nodes))\n {\n-  return Fragment (FragmentKind::Unexpanded, {});\n+  tokens.emplace_back (std::move (token));\n }\n \n std::vector<SingleASTNode> &\n@@ -68,6 +74,12 @@ Fragment::get_nodes ()\n   return nodes;\n }\n \n+std::vector<std::unique_ptr<AST::Token>> &\n+Fragment::get_tokens ()\n+{\n+  return tokens;\n+}\n+\n FragmentKind\n Fragment::get_kind () const\n {"}, {"sha": "22e99090b25be9d19db25951ea9848bd7be34d53", "filename": "gcc/rust/ast/rust-ast-fragment.h", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-ast-fragment.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-ast-fragment.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-fragment.h?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -27,11 +27,6 @@ namespace AST {\n \n enum class FragmentKind\n {\n-  /**\n-   * If an AST Fragment still contains unexpanded tokens - this should only be\n-   * used in the case of builtin macros which need to be expanded eagerly.\n-   */\n-  Unexpanded,\n   /**\n    * A completely expanded AST Fragment. This signifies that all\n    * `SingleASTNode`s in the `nodes` vector are valid.\n@@ -68,15 +63,18 @@ class Fragment\n   /**\n    * Create a complete AST fragment\n    */\n-  static Fragment complete (std::vector<AST::SingleASTNode> nodes);\n+  Fragment (std::vector<AST::SingleASTNode> nodes,\n+\t    std::vector<std::unique_ptr<AST::Token>> tokens);\n \n   /**\n-   * Create a fragment which contains unexpanded nodes\n+   * Create a complete AST fragment made of a single token\n    */\n-  static Fragment unexpanded ();\n+  Fragment (std::vector<AST::SingleASTNode> nodes,\n+\t    std::unique_ptr<AST::Token> tok);\n \n   FragmentKind get_kind () const;\n   std::vector<SingleASTNode> &get_nodes ();\n+  std::vector<std::unique_ptr<AST::Token>> &get_tokens ();\n \n   bool is_error () const;\n   bool should_expand () const;\n@@ -90,7 +88,8 @@ class Fragment\n   void accept_vis (ASTVisitor &vis);\n \n private:\n-  Fragment (FragmentKind kind, std::vector<SingleASTNode> nodes);\n+  Fragment (FragmentKind kind, std::vector<SingleASTNode> nodes,\n+\t    std::vector<std::unique_ptr<AST::Token>> tokens);\n \n   FragmentKind kind;\n \n@@ -104,6 +103,12 @@ class Fragment\n    */\n   std::vector<SingleASTNode> nodes;\n \n+  /**\n+   * The tokens associated with an AST fragment. This vector represents the\n+   * actual tokens of the various nodes that are part of the fragment.\n+   */\n+  std::vector<std::unique_ptr<AST::Token>> tokens;\n+\n   /**\n    * We need to make a special case for Expression and Type fragments as only\n    * one Node will be extracted from the `nodes` vector"}, {"sha": "a5b7f60bdad129e0349035d892df05437f0101e4", "filename": "gcc/rust/ast/rust-ast.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-ast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-ast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.cc?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -1323,6 +1323,12 @@ std::string\n MacroInvocation::as_string () const\n {\n   std::string str = \"MacroInvocation: \";\n+  auto is_builtin = kind == InvocKind::Builtin;\n+\n+  if (is_builtin)\n+    str += \"[builtin] \";\n+  else\n+    str += \"[regular] \";\n \n   str += append_attributes (outer_attrs, OUTER);\n \n@@ -1331,6 +1337,16 @@ MacroInvocation::as_string () const\n   str += \"\\n has semicolon: \";\n   str += has_semicolon () ? \"true\" : \"false\";\n \n+  if (is_builtin)\n+    {\n+      str += \"[PENDING EAGER INVOCATIONS]: \";\n+      for (auto &pending : pending_eager_invocs)\n+\t{\n+\t  str += pending->as_string ();\n+\t  str += \"\\n\";\n+\t}\n+    }\n+\n   return str;\n }\n "}, {"sha": "ffb671de9853224d8e3fd08e9fff1b80c8f1df0f", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -773,6 +773,7 @@ class DelimTokenTree : public TokenTree, public AttrInput\n   DelimTokenTree (DelimTokenTree const &other)\n     : delim_type (other.delim_type), locus (other.locus)\n   {\n+    token_trees.clear ();\n     token_trees.reserve (other.token_trees.size ());\n     for (const auto &e : other.token_trees)\n       token_trees.push_back (e->clone_token_tree ());\n@@ -784,6 +785,7 @@ class DelimTokenTree : public TokenTree, public AttrInput\n     delim_type = other.delim_type;\n     locus = other.locus;\n \n+    token_trees.clear ();\n     token_trees.reserve (other.token_trees.size ());\n     for (const auto &e : other.token_trees)\n       token_trees.push_back (e->clone_token_tree ());\n@@ -1523,6 +1525,9 @@ struct MacroInvocData\n   DelimTokenTree &get_delim_tok_tree () { return token_tree; }\n   const DelimTokenTree &get_delim_tok_tree () const { return token_tree; }\n \n+  // Set the delim token tree of a macro invocation\n+  void set_delim_tok_tree (DelimTokenTree tree) { token_tree = tree; }\n+\n   // TODO: this mutable getter seems kinda dodgy\n   SimplePath &get_path () { return path; }\n   const SimplePath &get_path () const { return path; }"}, {"sha": "b90cc15898eb5ec5f23cf716475aec2868e3babe", "filename": "gcc/rust/ast/rust-macro.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-macro.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-macro.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.cc?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -0,0 +1,64 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-macro.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+BuiltinMacro\n+builtin_macro_from_string (const std::string &identifier)\n+{\n+  if (identifier == \"assert\")\n+    return BuiltinMacro::Assert;\n+\n+  if (identifier == \"file\")\n+    return BuiltinMacro::File;\n+\n+  if (identifier == \"line\")\n+    return BuiltinMacro::Line;\n+\n+  if (identifier == \"column\")\n+    return BuiltinMacro::Column;\n+\n+  if (identifier == \"include_bytes\")\n+    return BuiltinMacro::IncludeBytes;\n+\n+  if (identifier == \"include_str\")\n+    return BuiltinMacro::IncludeStr;\n+\n+  if (identifier == \"compile_error\")\n+    return BuiltinMacro::CompileError;\n+\n+  if (identifier == \"concat\")\n+    return BuiltinMacro::Concat;\n+\n+  if (identifier == \"env\")\n+    return BuiltinMacro::Env;\n+\n+  if (identifier == \"cfg\")\n+    return BuiltinMacro::Cfg;\n+\n+  if (identifier == \"include\")\n+    return BuiltinMacro::Include;\n+\n+  gcc_unreachable ();\n+}\n+\n+} // namespace AST\n+} // namespace Rust"}, {"sha": "e7b0d1fae0e565dd48b7123a4d511ed8606a9071", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 76, "deletions": 25, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -222,7 +222,7 @@ class MacroMatchRepetition : public MacroMatch\n   };\n \n private:\n-  std::vector<std::unique_ptr<MacroMatch> > matches;\n+  std::vector<std::unique_ptr<MacroMatch>> matches;\n   MacroRepOp op;\n \n   // bool has_sep;\n@@ -235,7 +235,7 @@ class MacroMatchRepetition : public MacroMatch\n   // Returns whether macro match repetition has separator token.\n   bool has_sep () const { return sep != nullptr; }\n \n-  MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch> > matches,\n+  MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch>> matches,\n \t\t\tMacroRepOp op, std::unique_ptr<MacroRepSep> sep,\n \t\t\tLocation locus)\n     : matches (std::move (matches)), op (op), sep (std::move (sep)),\n@@ -290,8 +290,8 @@ class MacroMatchRepetition : public MacroMatch\n \n   MacroRepOp get_op () const { return op; }\n   const std::unique_ptr<MacroRepSep> &get_sep () const { return sep; }\n-  std::vector<std::unique_ptr<MacroMatch> > &get_matches () { return matches; }\n-  const std::vector<std::unique_ptr<MacroMatch> > &get_matches () const\n+  std::vector<std::unique_ptr<MacroMatch>> &get_matches () { return matches; }\n+  const std::vector<std::unique_ptr<MacroMatch>> &get_matches () const\n   {\n     return matches;\n   }\n@@ -309,15 +309,15 @@ class MacroMatchRepetition : public MacroMatch\n class MacroMatcher : public MacroMatch\n {\n   DelimType delim_type;\n-  std::vector<std::unique_ptr<MacroMatch> > matches;\n+  std::vector<std::unique_ptr<MacroMatch>> matches;\n   Location locus;\n \n   // TODO: think of way to mark invalid that doesn't take up more space\n   bool is_invalid;\n \n public:\n   MacroMatcher (DelimType delim_type,\n-\t\tstd::vector<std::unique_ptr<MacroMatch> > matches,\n+\t\tstd::vector<std::unique_ptr<MacroMatch>> matches,\n \t\tLocation locus)\n     : delim_type (delim_type), matches (std::move (matches)), locus (locus),\n       is_invalid (false)\n@@ -369,8 +369,8 @@ class MacroMatcher : public MacroMatch\n   }\n \n   DelimType get_delim_type () const { return delim_type; }\n-  std::vector<std::unique_ptr<MacroMatch> > &get_matches () { return matches; }\n-  const std::vector<std::unique_ptr<MacroMatch> > &get_matches () const\n+  std::vector<std::unique_ptr<MacroMatch>> &get_matches () { return matches; }\n+  const std::vector<std::unique_ptr<MacroMatch>> &get_matches () const\n   {\n     return matches;\n   }\n@@ -596,6 +596,9 @@ enum class BuiltinMacro\n   Include\n };\n \n+BuiltinMacro\n+builtin_macro_from_string (const std::string &identifier);\n+\n /* AST node of a macro invocation, which is replaced by the macro result at\n  * compile time. This is technically a sum-type/tagged-union, which represents\n  * both classic macro invocations and builtin macro invocations. Regular macro\n@@ -634,23 +637,27 @@ class MacroInvocation : public TypeNoBounds,\n   {\n     return std::unique_ptr<MacroInvocation> (\n       new MacroInvocation (InvocKind::Regular, Optional<BuiltinMacro>::none (),\n-\t\t\t   invoc_data, outer_attrs, locus, is_semi_coloned));\n+\t\t\t   invoc_data, outer_attrs, locus, is_semi_coloned,\n+\t\t\t   {}));\n   }\n \n   /**\n    * Create a builtin macro invocation. This can only be done after macro\n    * name-resolution and within the macro expander, so unless you're modifying\n    * these visitors, you probably do not want to use this function.\n    */\n-  static std::unique_ptr<MacroInvocation>\n-  Builtin (BuiltinMacro kind, MacroInvocData invoc_data,\n-\t   std::vector<Attribute> outer_attrs, Location locus,\n-\t   bool is_semi_coloned = false)\n+  static std::unique_ptr<MacroInvocation> Builtin (\n+    BuiltinMacro kind, MacroInvocData invoc_data,\n+    std::vector<Attribute> outer_attrs, Location locus,\n+    std::vector<std::unique_ptr<MacroInvocation>> &&pending_eager_invocations\n+    = {},\n+    bool is_semi_coloned = false)\n   {\n     return std::unique_ptr<MacroInvocation> (\n       new MacroInvocation (InvocKind::Builtin,\n \t\t\t   Optional<BuiltinMacro>::some (kind), invoc_data,\n-\t\t\t   outer_attrs, locus, is_semi_coloned));\n+\t\t\t   outer_attrs, locus, is_semi_coloned,\n+\t\t\t   std::move (pending_eager_invocations)));\n   }\n \n   Location get_locus () const override final { return locus; }\n@@ -688,18 +695,53 @@ class MacroInvocation : public TypeNoBounds,\n   InvocKind get_kind () const { return kind; }\n   Optional<BuiltinMacro> get_builtin_kind () const { return builtin_kind; }\n \n+  /**\n+   * Turn the current MacroInvocation into a builtin macro invocation\n+   */\n+  void map_to_builtin (BuiltinMacro macro)\n+  {\n+    kind = InvocKind::Builtin;\n+    builtin_kind = Optional<BuiltinMacro>::some (macro);\n+  }\n+\n+  /**\n+   * Get the list of pending macro invcations within the builtin macro\n+   * invocation that should get expanded eagerly.\n+   */\n+  std::vector<std::unique_ptr<MacroInvocation>> &\n+  get_pending_eager_invocations ()\n+  {\n+    rust_assert (kind == InvocKind::Builtin);\n+\n+    return pending_eager_invocs;\n+  }\n+\n private:\n   /* Full constructor */\n-  MacroInvocation (InvocKind kind, Optional<BuiltinMacro> builtin_kind,\n-\t\t   MacroInvocData invoc_data,\n-\t\t   std::vector<Attribute> outer_attrs, Location locus,\n-\t\t   bool is_semi_coloned)\n+  MacroInvocation (\n+    InvocKind kind, Optional<BuiltinMacro> builtin_kind,\n+    MacroInvocData invoc_data, std::vector<Attribute> outer_attrs,\n+    Location locus, bool is_semi_coloned,\n+    std::vector<std::unique_ptr<MacroInvocation>> &&pending_eager_invocs)\n     : outer_attrs (std::move (outer_attrs)), locus (locus),\n       node_id (Analysis::Mappings::get ()->get_next_node_id ()),\n       invoc_data (std::move (invoc_data)), is_semi_coloned (is_semi_coloned),\n-      kind (kind), builtin_kind (builtin_kind)\n+      kind (kind), builtin_kind (builtin_kind),\n+      pending_eager_invocs (std::move (pending_eager_invocs))\n   {}\n \n+  MacroInvocation (const MacroInvocation &other)\n+    : outer_attrs (other.outer_attrs), locus (other.locus),\n+      node_id (other.node_id), invoc_data (other.invoc_data),\n+      is_semi_coloned (other.is_semi_coloned), kind (other.kind),\n+      builtin_kind (other.builtin_kind)\n+  {\n+    if (other.kind == InvocKind::Builtin)\n+      for (auto &pending : other.pending_eager_invocs)\n+\tpending_eager_invocs.emplace_back (\n+\t  pending->clone_macro_invocation_impl ());\n+  }\n+\n   std::vector<Attribute> outer_attrs;\n   Location locus;\n   NodeId node_id;\n@@ -716,6 +758,16 @@ class MacroInvocation : public TypeNoBounds,\n   /* If it is a builtin macro, which one */\n   Optional<BuiltinMacro> builtin_kind = Optional<BuiltinMacro>::none ();\n \n+  /**\n+   * Pending invocations within a builtin macro invocation. This vector is empty\n+   * and should not be accessed for a regular macro invocation. The macro\n+   * invocations within should be name resolved and expanded before the builtin\n+   * macro invocation get expanded again. It is then the role of the expander to\n+   * insert these new tokens properly in the delimited token tree and try the\n+   * builtin transcriber once again.\n+   */\n+  std::vector<std::unique_ptr<MacroInvocation>> pending_eager_invocs;\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -817,11 +869,10 @@ class MetaItemPath : public MetaItem\n class MetaItemSeq : public MetaItem\n {\n   SimplePath path;\n-  std::vector<std::unique_ptr<MetaItemInner> > seq;\n+  std::vector<std::unique_ptr<MetaItemInner>> seq;\n \n public:\n-  MetaItemSeq (SimplePath path,\n-\t       std::vector<std::unique_ptr<MetaItemInner> > seq)\n+  MetaItemSeq (SimplePath path, std::vector<std::unique_ptr<MetaItemInner>> seq)\n     : path (std::move (path)), seq (std::move (seq))\n   {}\n \n@@ -1024,18 +1075,18 @@ struct AttributeParser\n {\n private:\n   // TODO: might as well rewrite to use lexer tokens\n-  std::vector<std::unique_ptr<Token> > token_stream;\n+  std::vector<std::unique_ptr<Token>> token_stream;\n   int stream_pos;\n \n public:\n-  AttributeParser (std::vector<std::unique_ptr<Token> > token_stream,\n+  AttributeParser (std::vector<std::unique_ptr<Token>> token_stream,\n \t\t   int stream_start_pos = 0)\n     : token_stream (std::move (token_stream)), stream_pos (stream_start_pos)\n   {}\n \n   ~AttributeParser () = default;\n \n-  std::vector<std::unique_ptr<MetaItemInner> > parse_meta_item_seq ();\n+  std::vector<std::unique_ptr<MetaItemInner>> parse_meta_item_seq ();\n \n private:\n   // Parses a MetaItemInner."}, {"sha": "3e5d793f05a2fff5d1b748056c45e820223979e4", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -389,8 +389,6 @@ AttrVisitor::visit (AST::ConstGenericParam &)\n void\n AttrVisitor::visit (AST::MacroInvocation &macro_invoc)\n {\n-  // FIXME: Probably need to check macro_invoc.kind\n-\n   // initial strip test based on outer attrs\n   expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n   if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))\n@@ -1124,7 +1122,7 @@ AttrVisitor::visit (AST::CallExpr &expr)\n \n       stmt->accept_vis (*this);\n \n-      auto final_fragment = expand_macro_fragment_recursive ();\n+      auto final_fragment = expander.take_expanded_fragment ();\n       if (final_fragment.should_expand ())\n \t{\n \t  // Remove the current expanded invocation\n@@ -3423,7 +3421,7 @@ AttrVisitor::visit (AST::BareFunctionType &type)\n void\n AttrVisitor::maybe_expand_expr (std::unique_ptr<AST::Expr> &expr)\n {\n-  auto final_fragment = expand_macro_fragment_recursive ();\n+  auto final_fragment = expander.take_expanded_fragment ();\n   if (final_fragment.should_expand ()\n       && final_fragment.is_expression_fragment ())\n     expr = final_fragment.take_expression_fragment ();\n@@ -3432,7 +3430,7 @@ AttrVisitor::maybe_expand_expr (std::unique_ptr<AST::Expr> &expr)\n void\n AttrVisitor::maybe_expand_type (std::unique_ptr<AST::Type> &type)\n {\n-  auto final_fragment = expand_macro_fragment_recursive ();\n+  auto final_fragment = expander.take_expanded_fragment ();\n   if (final_fragment.should_expand () && final_fragment.is_type_fragment ())\n     type = final_fragment.take_type_fragment ();\n }"}, {"sha": "f1530467fec14278f426b0d3a6fb311d4e48ccb6", "filename": "gcc/rust/expand/rust-attribute-visitor.h", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.h?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -43,39 +43,6 @@ class AttrVisitor : public AST::ASTVisitor\n   void expand_trait_function_decl (AST::TraitFunctionDecl &decl);\n   void expand_trait_method_decl (AST::TraitMethodDecl &decl);\n \n-  /**\n-   * Expand The current macro fragment recursively until it could not be\n-   * expanded further.\n-   *\n-   * The return value checking works because correctly\n-   * expanded fragment can never be an error (if the fragment can not be\n-   * expanded, a stand-in error fragment will be returned; for fragments that\n-   * could not be further expanded: the fragment prior to the expansion failure\n-   * will be returned).\n-   *\n-   * @return Either the expanded fragment or an empty errored-out fragment\n-   * indicating an expansion failure.\n-   */\n-  AST::Fragment expand_macro_fragment_recursive ()\n-  {\n-    auto fragment = expander.take_expanded_fragment (*this);\n-    unsigned int original_depth = expander.expansion_depth;\n-    auto final_fragment = AST::Fragment::create_error ();\n-\n-    while (fragment.should_expand ())\n-      {\n-\tfinal_fragment = std::move (fragment);\n-\texpander.expansion_depth++;\n-\t// further expand the previously expanded macro fragment\n-\tauto new_fragment = expander.take_expanded_fragment (*this);\n-\tif (new_fragment.is_error ())\n-\t  break;\n-\tfragment = std::move (new_fragment);\n-      }\n-    expander.expansion_depth = original_depth;\n-    return final_fragment;\n-  }\n-\n   /**\n    * Expand a set of values, erasing them if they are marked for strip, and\n    * replacing them with expanded macro nodes if necessary.\n@@ -101,8 +68,7 @@ class AttrVisitor : public AST::ASTVisitor\n \t// mark for stripping if required\n \tvalue->accept_vis (*this);\n \n-\t// recursively expand the children\n-\tauto final_fragment = expand_macro_fragment_recursive ();\n+\tauto final_fragment = expander.take_expanded_fragment ();\n \n \tif (final_fragment.should_expand ())\n \t  {"}, {"sha": "1caba514c57d1729844cd081ebfd2a3b69ecdbee", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 124, "deletions": 70, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -29,6 +29,16 @@\n \n namespace Rust {\n namespace {\n+\n+/**\n+ * Shorthand function for creating unique_ptr tokens\n+ */\n+static std::unique_ptr<AST::Token>\n+make_token (const TokenPtr tok)\n+{\n+  return std::unique_ptr<AST::Token> (new AST::Token (tok));\n+}\n+\n std::unique_ptr<AST::Expr>\n make_string (Location locus, std::string value)\n {\n@@ -38,35 +48,60 @@ make_string (Location locus, std::string value)\n }\n \n // TODO: Is this correct?\n-static std::unique_ptr<AST::Expr>\n-make_macro_invocation (AST::BuiltinMacro kind, AST::DelimTokenTree arguments)\n+static AST::Fragment\n+make_eager_builtin_invocation (\n+  AST::BuiltinMacro kind, Location locus, AST::DelimTokenTree arguments,\n+  std::vector<std::unique_ptr<AST::MacroInvocation>> &&pending_invocations)\n {\n   std::string path_str;\n \n   switch (kind)\n     {\n+    // TODO: Should this be a table lookup?\n     case AST::BuiltinMacro::Assert:\n+      path_str = \"assert\";\n+      break;\n     case AST::BuiltinMacro::File:\n+      path_str = \"file\";\n+      break;\n     case AST::BuiltinMacro::Line:\n+      path_str = \"line\";\n+      break;\n     case AST::BuiltinMacro::Column:\n+      path_str = \"column\";\n+      break;\n     case AST::BuiltinMacro::IncludeBytes:\n+      path_str = \"include_bytes\";\n+      break;\n     case AST::BuiltinMacro::IncludeStr:\n+      path_str = \"include_str\";\n+      break;\n     case AST::BuiltinMacro::CompileError:\n+      path_str = \"compile_error\";\n+      break;\n     case AST::BuiltinMacro::Concat:\n       path_str = \"concat\";\n       break;\n     case AST::BuiltinMacro::Env:\n+      path_str = \"env\";\n+      break;\n     case AST::BuiltinMacro::Cfg:\n+      path_str = \"cfg\";\n+      break;\n     case AST::BuiltinMacro::Include:\n+      path_str = \"include\";\n       break;\n     }\n \n-  return AST::MacroInvocation::builtin (\n+  std::unique_ptr<AST::Expr> node = AST::MacroInvocation::Builtin (\n     kind,\n     AST::MacroInvocData (AST::SimplePath (\n-\t\t\t   {AST::SimplePathSegment (path_str, Location ())}),\n+\t\t\t   {AST::SimplePathSegment (path_str, locus)}),\n \t\t\t std::move (arguments)),\n-    {}, Location ());\n+    {}, locus, std::move (pending_invocations));\n+\n+  return AST::Fragment ({AST::SingleASTNode (std::move (node))},\n+\t\t\targuments.to_token_stream ());\n }\n \n /* Match the end token of a macro given the start delimiter of the macro */\n@@ -95,22 +130,7 @@ macro_end_token (AST::DelimTokenTree &invoc_token_tree,\n   return last_token_id;\n }\n \n-/* Expand and extract an expression from the macro */\n-\n-static inline AST::Fragment\n-try_expand_macro_expression (AST::Expr *expr, MacroExpander *expander)\n-{\n-  rust_assert (expander);\n-\n-  auto attr_visitor = Rust::AttrVisitor (*expander);\n-  auto early_name_resolver = Resolver::EarlyNameResolver ();\n-  expr->accept_vis (early_name_resolver);\n-  expr->accept_vis (attr_visitor);\n-  return expander->take_expanded_fragment (attr_visitor);\n-}\n-\n /* Expand and then extract a string literal from the macro */\n-\n static std::unique_ptr<AST::LiteralExpr>\n try_extract_string_literal_from_fragment (const Location &parent_locus,\n \t\t\t\t\t  std::unique_ptr<AST::Expr> &node)\n@@ -128,22 +148,6 @@ try_extract_string_literal_from_fragment (const Location &parent_locus,\n     static_cast<AST::LiteralExpr *> (node->clone_expr ().release ()));\n }\n \n-static std::unique_ptr<AST::LiteralExpr>\n-try_expand_single_string_literal (AST::Expr *input_expr,\n-\t\t\t\t  MacroExpander *expander)\n-{\n-  auto nodes = try_expand_macro_expression (input_expr, expander);\n-  if (nodes.is_error () || nodes.is_expression_fragment ())\n-    {\n-      rust_error_at (input_expr->get_locus (),\n-\t\t     \"argument must be a string literal\");\n-      return nullptr;\n-    }\n-  auto expr = nodes.take_expression_fragment ();\n-  return try_extract_string_literal_from_fragment (input_expr->get_locus (),\n-\t\t\t\t\t\t   expr);\n-}\n-\n static std::vector<std::unique_ptr<AST::Expr>>\n try_expand_many_expr (Parser<MacroInvocLexer> &parser,\n \t\t      const TokenId last_token_id, MacroExpander *expander,\n@@ -171,22 +175,7 @@ try_expand_many_expr (Parser<MacroInvocLexer> &parser,\n       auto expr = parser.parse_expr (AST::AttrVec (), restrictions);\n       // something must be so wrong that the expression could not be parsed\n       rust_assert (expr);\n-      auto nodes = try_expand_macro_expression (expr.get (), expander);\n-      if (nodes.is_error ())\n-\t{\n-\t  // not macro\n-\t  result.push_back (std::move (expr));\n-\t}\n-      else if (!nodes.is_expression_fragment ())\n-\t{\n-\t  rust_error_at (expr->get_locus (), \"expected expression\");\n-\t  has_error = true;\n-\t  return empty_expr;\n-\t}\n-      else\n-\t{\n-\t  result.push_back (nodes.take_expression_fragment ());\n-\t}\n+      result.push_back (std::move (expr));\n \n       auto next_token = parser.peek_current_token ();\n       if (!parser.skip_token (COMMA) && next_token->get_id () != last_token_id)\n@@ -230,12 +219,7 @@ parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n   else if (parser.peek_current_token ()->get_id () == last_token_id)\n     rust_error_at (invoc_locus, \"macro takes 1 argument\");\n   else\n-    {\n-      // when the expression does not seem to be a string literal, we then try\n-      // to parse/expand it as macro to see if it expands to a string literal\n-      auto expr = parser.parse_expr ();\n-      lit_expr = try_expand_single_string_literal (expr.get (), expander);\n-    }\n+    rust_error_at (invoc_locus, \"argument must be a string literal\");\n \n   parser.skip_token (last_token_id);\n \n@@ -307,8 +291,10 @@ MacroBuiltin::file_handler (Location invoc_locus, AST::MacroInvocData &)\n   auto current_file\n     = Session::get_instance ().linemap->location_file (invoc_locus);\n   auto file_str = AST::SingleASTNode (make_string (invoc_locus, current_file));\n+  auto str_token\n+    = make_token (Token::make_string (invoc_locus, std::move (current_file)));\n \n-  return AST::Fragment::complete ({file_str});\n+  return AST::Fragment ({file_str}, std::move (str_token));\n }\n \n AST::Fragment\n@@ -317,11 +303,13 @@ MacroBuiltin::column_handler (Location invoc_locus, AST::MacroInvocData &)\n   auto current_column\n     = Session::get_instance ().linemap->location_to_column (invoc_locus);\n \n+  auto column_tok = make_token (\n+    Token::make_int (invoc_locus, std::to_string (current_column)));\n   auto column_no = AST::SingleASTNode (std::unique_ptr<AST::Expr> (\n     new AST::LiteralExpr (std::to_string (current_column), AST::Literal::INT,\n \t\t\t  PrimitiveCoreType::CORETYPE_U32, {}, invoc_locus)));\n \n-  return AST::Fragment::complete ({column_no});\n+  return AST::Fragment ({column_no}, std::move (column_tok));\n }\n \n /* Expand builtin macro include_bytes!(\"filename\"), which includes the contents\n@@ -347,14 +335,25 @@ MacroBuiltin::include_bytes_handler (Location invoc_locus,\n \n   /* Is there a more efficient way to do this?  */\n   std::vector<std::unique_ptr<AST::Expr>> elts;\n+\n+  // We create the tokens for a borrow expression of a byte array, so\n+  // & [ <byte0>, <byte1>, ... ]\n+  std::vector<std::unique_ptr<AST::Token>> toks;\n+  toks.emplace_back (make_token (Token::make (AMP, invoc_locus)));\n+  toks.emplace_back (make_token (Token::make (LEFT_SQUARE, invoc_locus)));\n+\n   for (uint8_t b : bytes)\n     {\n       elts.emplace_back (\n \tnew AST::LiteralExpr (std::string (1, (char) b), AST::Literal::BYTE,\n \t\t\t      PrimitiveCoreType::CORETYPE_U8,\n \t\t\t      {} /* outer_attrs */, invoc_locus));\n+      toks.emplace_back (make_token (Token::make_byte_char (invoc_locus, b)));\n+      toks.emplace_back (make_token (Token::make (COMMA, invoc_locus)));\n     }\n \n+  toks.emplace_back (make_token (Token::make (RIGHT_SQUARE, invoc_locus)));\n+\n   auto elems = std::unique_ptr<AST::ArrayElems> (\n     new AST::ArrayElemsValues (std::move (elts), invoc_locus));\n \n@@ -365,8 +364,9 @@ MacroBuiltin::include_bytes_handler (Location invoc_locus,\n     new AST::BorrowExpr (std::move (array), false, false, {}, invoc_locus));\n \n   auto node = AST::SingleASTNode (std::move (borrow));\n-  return AST::Fragment::complete ({node});\n-}\n+\n+  return AST::Fragment ({node}, std::move (toks));\n+} // namespace Rust\n \n /* Expand builtin macro include_str!(\"filename\"), which includes the contents\n    of the given file as a string. The file must be UTF-8 encoded. Yields an\n@@ -393,7 +393,10 @@ MacroBuiltin::include_str_handler (Location invoc_locus,\n   std::string str ((const char *) &bytes[0], bytes.size ());\n \n   auto node = AST::SingleASTNode (make_string (invoc_locus, str));\n-  return AST::Fragment::complete ({node});\n+  auto str_tok = make_token (Token::make_string (invoc_locus, std::move (str)));\n+\n+  // FIXME: Do not return an empty token vector here\n+  return AST::Fragment ({node}, std::move (str_tok));\n }\n \n /* Expand builtin macro compile_error!(\"error\"), which forces a compile error\n@@ -414,6 +417,20 @@ MacroBuiltin::compile_error_handler (Location invoc_locus,\n   return AST::Fragment::create_error ();\n }\n \n+static std::vector<std::unique_ptr<AST::MacroInvocation>>\n+check_for_eager_invocations (\n+  std::vector<std::unique_ptr<AST::Expr>> &expressions)\n+{\n+  std::vector<std::unique_ptr<AST::MacroInvocation>> pending;\n+\n+  for (auto &expr : expressions)\n+    if (expr->get_ast_kind () == AST::Kind::MACRO_INVOCATION)\n+      pending.emplace_back (std::unique_ptr<AST::MacroInvocation> (\n+\tstatic_cast<AST::MacroInvocation *> (expr->clone_expr ().release ())));\n+\n+  return pending;\n+}\n+\n /* Expand builtin macro concat!(), which joins all the literal parameters\n    into a string with no delimiter. */\n \n@@ -468,12 +485,25 @@ MacroBuiltin::concat_handler (Location invoc_locus, AST::MacroInvocData &invoc)\n \n   auto last_token_id = macro_end_token (invoc_token_tree, parser);\n \n+  auto start = lex.get_offs ();\n   /* NOTE: concat! could accept no argument, so we don't have any checks here */\n   auto expanded_expr = try_expand_many_expr (parser, last_token_id,\n \t\t\t\t\t     invoc.get_expander (), has_error);\n+  auto end = lex.get_offs ();\n+\n+  auto tokens = lex.get_token_slice (start, end);\n+\n+  auto pending_invocations = check_for_eager_invocations (expanded_expr);\n+  if (!pending_invocations.empty ())\n+    return make_eager_builtin_invocation (AST::BuiltinMacro::Concat,\n+\t\t\t\t\t  invoc_locus,\n+\t\t\t\t\t  invoc.get_delim_tok_tree (),\n+\t\t\t\t\t  std::move (pending_invocations));\n+\n   for (auto &expr : expanded_expr)\n     {\n-      if (!expr->is_literal ())\n+      if (!expr->is_literal ()\n+\t  && expr->get_ast_kind () != AST::MACRO_INVOCATION)\n \t{\n \t  has_error = true;\n \t  rust_error_at (expr->get_locus (), \"expected a literal\");\n@@ -501,12 +531,13 @@ MacroBuiltin::concat_handler (Location invoc_locus, AST::MacroInvocData &invoc)\n     return AST::Fragment::create_error ();\n \n   auto node = AST::SingleASTNode (make_string (invoc_locus, str));\n-  return AST::Fragment::complete ({node});\n+  auto str_tok = make_token (Token::make_string (invoc_locus, std::move (str)));\n+\n+  return AST::Fragment ({node}, std::move (str_tok));\n }\n \n /* Expand builtin macro env!(), which inspects an environment variable at\n    compile time. */\n-\n AST::Fragment\n MacroBuiltin::env_handler (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n@@ -519,10 +550,22 @@ MacroBuiltin::env_handler (Location invoc_locus, AST::MacroInvocData &invoc)\n   std::unique_ptr<AST::LiteralExpr> lit_expr = nullptr;\n   bool has_error = false;\n \n+  auto start = lex.get_offs ();\n   auto expanded_expr = try_expand_many_expr (parser, last_token_id,\n \t\t\t\t\t     invoc.get_expander (), has_error);\n+  auto end = lex.get_offs ();\n+\n+  auto tokens = lex.get_token_slice (start, end);\n+\n   if (has_error)\n     return AST::Fragment::create_error ();\n+\n+  auto pending = check_for_eager_invocations (expanded_expr);\n+  if (!pending.empty ())\n+    return make_eager_builtin_invocation (AST::BuiltinMacro::Env, invoc_locus,\n+\t\t\t\t\t  invoc_token_tree,\n+\t\t\t\t\t  std::move (pending));\n+\n   if (expanded_expr.size () < 1 || expanded_expr.size () > 2)\n     {\n       rust_error_at (invoc_locus, \"env! takes 1 or 2 arguments\");\n@@ -562,7 +605,11 @@ MacroBuiltin::env_handler (Location invoc_locus, AST::MacroInvocData &invoc)\n     }\n \n   auto node = AST::SingleASTNode (make_string (invoc_locus, env_value));\n-  return AST::Fragment::complete ({node});\n+  auto tok\n+    = make_token (Token::make_string (invoc_locus, std::move (env_value)));\n+\n+  // FIXME: Do not return an empty token vector here\n+  return AST::Fragment ({node}, std::move (tok));\n }\n \n AST::Fragment\n@@ -597,8 +644,11 @@ MacroBuiltin::cfg_handler (Location invoc_locus, AST::MacroInvocData &invoc)\n   auto literal_exp = AST::SingleASTNode (std::unique_ptr<AST::Expr> (\n     new AST::LiteralExpr (result ? \"true\" : \"false\", AST::Literal::BOOL,\n \t\t\t  PrimitiveCoreType::CORETYPE_BOOL, {}, invoc_locus)));\n+  auto tok = make_token (\n+    Token::make (result ? TRUE_LITERAL : FALSE_LITERAL, invoc_locus));\n \n-  return AST::Fragment::complete ({literal_exp});\n+  // FIXME: Do not return an empty token vector here\n+  return AST::Fragment ({literal_exp}, std::move (tok));\n }\n \n /* Expand builtin macro include!(), which includes a source file at the current\n@@ -655,7 +705,8 @@ MacroBuiltin::include_handler (Location invoc_locus, AST::MacroInvocData &invoc)\n       nodes.push_back (node);\n     }\n \n-  return AST::Fragment::complete (nodes);\n+  // FIXME: Do not return an empty token vector here\n+  return AST::Fragment (nodes, nullptr);\n }\n \n AST::Fragment\n@@ -667,8 +718,11 @@ MacroBuiltin::line_handler (Location invoc_locus, AST::MacroInvocData &)\n   auto line_no = AST::SingleASTNode (std::unique_ptr<AST::Expr> (\n     new AST::LiteralExpr (std::to_string (current_line), AST::Literal::INT,\n \t\t\t  PrimitiveCoreType::CORETYPE_U32, {}, invoc_locus)));\n+  auto tok\n+    = make_token (Token::make_int (invoc_locus, std::to_string (current_line)));\n \n-  return AST::Fragment::complete ({line_no});\n+  // FIXME: Do not return an empty token vector here\n+  return AST::Fragment ({line_no}, std::move (tok));\n }\n \n } // namespace Rust"}, {"sha": "1684c2ba16f7fec99610ad0c7bc3279b34c8d075", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 134, "deletions": 4, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -110,6 +110,114 @@ MacroExpander::expand_decl_macro (Location invoc_locus,\n \t\t\t  semicolon, peek_context ());\n }\n \n+void\n+MacroExpander::expand_eager_invocations (AST::MacroInvocation &invoc)\n+{\n+  if (invoc.get_pending_eager_invocations ().empty ())\n+    return;\n+\n+  // We have to basically create a new delimited token tree which contains the\n+  // result of one step of expansion. In the case of builtin macros called with\n+  // other macro invocations, such as `concat!(\"h\", 'a', a!())`, we need to\n+  // expand `a!()` before expanding the concat macro.\n+  // This will, ideally, give us a new token tree containing the various\n+  // existing tokens + the result of the expansion of a!().\n+  // To do this, we \"parse\" the given token tree to find anything that \"looks\n+  // like a macro invocation\". Then, we get the corresponding macro invocation\n+  // from the `pending_eager_invocations` vector and expand it.\n+  // Because the `pending_eager_invocations` vector is created in the same order\n+  // that the DelimTokenTree is parsed, we know that the first macro invocation\n+  // within the DelimTokenTree corresponds to the first element in\n+  // `pending_eager_invocations`. The idea is thus to:\n+  // 1. Find a macro invocation in the token tree, noting the index of the start\n+  //    token and of the end token\n+  // 2. Get its associated invocation in `pending_eager_invocations`\n+  // 3. Expand that element\n+  // 4. Get the token tree associated with that AST fragment\n+  // 5. Replace the original tokens corresponding to the invocation with the new\n+  //    tokens from the fragment\n+  // pseudo-code:\n+  //\n+  // i = 0;\n+  // for tok in dtt:\n+  //   if tok is identifier && tok->next() is !:\n+  //     start = index(tok);\n+  //     l_delim = tok->next()->next();\n+  //     tok = skip_until_r_delim();\n+  //     end = index(tok);\n+  //\n+  //     new_tt = expand_eager_invoc(eagers[i++]);\n+  //     old_tt[start..end] = new_tt;\n+\n+  auto dtt = invoc.get_invoc_data ().get_delim_tok_tree ();\n+  auto stream = dtt.to_token_stream ();\n+  std::vector<std::unique_ptr<AST::TokenTree>> new_stream;\n+  size_t current_pending = 0;\n+\n+  // we need to create a clone of the delimited token tree as the lexer\n+  // expects ownership of the tokens\n+  std::vector<std::unique_ptr<Rust::AST::Token>> dtt_clone;\n+  for (auto &tok : stream)\n+    dtt_clone.emplace_back (tok->clone_token ());\n+\n+  MacroInvocLexer lex (std::move (dtt_clone));\n+  Parser<MacroInvocLexer> parser (lex);\n+\n+  // we want to build a substitution map - basically, associating a `start` and\n+  // `end` index for each of the pending macro invocations\n+  std::map<std::pair<size_t, size_t>, std::unique_ptr<AST::MacroInvocation> &>\n+    substitution_map;\n+\n+  for (size_t i = 0; i < stream.size (); i++)\n+    {\n+      // FIXME: Can't these offsets be figure out when we actually parse the\n+      // pending_eager_invocation in the first place?\n+      auto invocation = parser.parse_macro_invocation ({});\n+\n+      // if we've managed to parse a macro invocation, we look at the current\n+      // offset and store them in the substitution map. Otherwise, we skip one\n+      // token and try parsing again\n+      if (invocation)\n+\tsubstitution_map.insert (\n+\t  {{i, parser.get_token_source ().get_offs ()},\n+\t   invoc.get_pending_eager_invocations ()[current_pending++]});\n+      else\n+\tparser.skip_token (stream[i]->get_id ());\n+    }\n+\n+  size_t current_idx = 0;\n+  for (auto kv : substitution_map)\n+    {\n+      auto &to_expand = kv.second;\n+      expand_invoc (*to_expand, false);\n+\n+      auto fragment = take_expanded_fragment ();\n+      auto &new_tokens = fragment.get_tokens ();\n+\n+      auto start = kv.first.first;\n+      auto end = kv.first.second;\n+\n+      // TODO: Add doc\n+      for (size_t i = current_idx; i < start; i++)\n+\tnew_stream.emplace_back (stream[i]->clone_token ());\n+\n+      // TODO: Add doc\n+      for (auto &tok : new_tokens)\n+\tnew_stream.emplace_back (tok->clone_token ());\n+\n+      current_idx = end;\n+    }\n+  // TODO: Add doc\n+  for (size_t i = current_idx; i < stream.size (); i++)\n+    new_stream.emplace_back (stream[i]->clone_token ());\n+\n+  auto new_dtt\n+    = AST::DelimTokenTree (dtt.get_delim_type (), std::move (new_stream));\n+\n+  invoc.get_pending_eager_invocations ().clear ();\n+  invoc.get_invoc_data ().set_delim_tok_tree (new_dtt);\n+}\n+\n void\n MacroExpander::expand_invoc (AST::MacroInvocation &invoc, bool has_semicolon)\n {\n@@ -119,6 +227,9 @@ MacroExpander::expand_invoc (AST::MacroInvocation &invoc, bool has_semicolon)\n       return;\n     }\n \n+  if (invoc.get_kind () == AST::MacroInvocation::InvocKind::Builtin)\n+    expand_eager_invocations (invoc);\n+\n   AST::MacroInvocData &invoc_data = invoc.get_invoc_data ();\n \n   // ??\n@@ -151,6 +262,11 @@ MacroExpander::expand_invoc (AST::MacroInvocation &invoc, bool has_semicolon)\n   if (!ok)\n     return;\n \n+  // We store the last expanded invocation and macro definition for error\n+  // reporting in case the recursion limit is reached\n+  last_invoc = &invoc;\n+  last_def = rules_def;\n+\n   if (rules_def->is_builtin ())\n     fragment\n       = rules_def->get_builtin_transcriber () (invoc.get_locus (), invoc_data);\n@@ -292,7 +408,7 @@ MacroExpander::expand_crate ()\n       // mark for stripping if required\n       item->accept_vis (attr_visitor);\n \n-      auto fragment = take_expanded_fragment (attr_visitor);\n+      auto fragment = take_expanded_fragment ();\n       if (fragment.should_expand ())\n \t{\n \t  // Remove the current expanded invocation\n@@ -711,6 +827,9 @@ static AST::Fragment\n parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n \t    std::function<AST::SingleASTNode ()> parse_fn)\n {\n+  auto &lexer = parser.get_token_source ();\n+  auto start = lexer.get_offs ();\n+\n   std::vector<AST::SingleASTNode> nodes;\n   while (true)\n     {\n@@ -728,8 +847,9 @@ parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n \n       nodes.emplace_back (std::move (node));\n     }\n+  auto end = lexer.get_offs ();\n \n-  return AST::Fragment::complete (std::move (nodes));\n+  return AST::Fragment (std::move (nodes), lexer.get_token_slice (start, end));\n }\n \n /**\n@@ -838,11 +958,16 @@ transcribe_many_stmts (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n static AST::Fragment\n transcribe_expression (Parser<MacroInvocLexer> &parser)\n {\n+  auto &lexer = parser.get_token_source ();\n+  auto start = lexer.get_offs ();\n+\n   auto expr = parser.parse_expr ();\n   if (expr == nullptr)\n     return AST::Fragment::create_error ();\n \n-  return AST::Fragment::complete ({std::move (expr)});\n+  auto end = lexer.get_offs ();\n+\n+  return AST::Fragment ({std::move (expr)}, lexer.get_token_slice (start, end));\n }\n \n /**\n@@ -853,11 +978,16 @@ transcribe_expression (Parser<MacroInvocLexer> &parser)\n static AST::Fragment\n transcribe_type (Parser<MacroInvocLexer> &parser)\n {\n+  auto &lexer = parser.get_token_source ();\n+  auto start = lexer.get_offs ();\n+\n   auto type = parser.parse_type (true);\n   for (auto err : parser.get_errors ())\n     err.emit_error ();\n \n-  return AST::Fragment::complete ({std::move (type)});\n+  auto end = lexer.get_offs ();\n+\n+  return AST::Fragment ({std::move (type)}, lexer.get_token_slice (start, end));\n }\n \n static AST::Fragment"}, {"sha": "e440edf42399ea679fd397586bcf26f176295c41", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -231,7 +231,7 @@ struct MacroExpander\n     : cfg (cfg), crate (crate), session (session),\n       sub_stack (SubstitutionScope ()),\n       expanded_fragment (AST::Fragment::create_error ()),\n-      resolver (Resolver::Resolver::get ()),\n+      has_changed_flag (false), resolver (Resolver::Resolver::get ()),\n       mappings (Analysis::Mappings::get ())\n   {}\n \n@@ -240,6 +240,12 @@ struct MacroExpander\n   // Expands all macros in the crate passed in.\n   void expand_crate ();\n \n+  /**\n+   * Expand the eager invocations contained within a builtin macro invocation.\n+   * Called by `expand_invoc` when expanding builtin invocations.\n+   */\n+  void expand_eager_invocations (AST::MacroInvocation &invoc);\n+\n   /* Expands a macro invocation - possibly make both\n    * have similar duck-typed interface and use templates?*/\n   // should this be public or private?\n@@ -315,49 +321,44 @@ struct MacroExpander\n \n   void set_expanded_fragment (AST::Fragment &&fragment)\n   {\n+    if (!fragment.is_error ())\n+      has_changed_flag = true;\n+\n     expanded_fragment = std::move (fragment);\n   }\n \n-  AST::Fragment take_expanded_fragment (AST::ASTVisitor &vis)\n+  AST::Fragment take_expanded_fragment ()\n   {\n-    AST::Fragment old_fragment = std::move (expanded_fragment);\n-    auto accumulator = std::vector<AST::SingleASTNode> ();\n+    auto fragment = std::move (expanded_fragment);\n     expanded_fragment = AST::Fragment::create_error ();\n-    auto early_name_resolver = Resolver::EarlyNameResolver ();\n-\n-    for (auto &node : old_fragment.get_nodes ())\n-      {\n-\texpansion_depth++;\n-\n-\tnode.accept_vis (early_name_resolver);\n-\tnode.accept_vis (vis);\n-\t// we'll decide the next move according to the outcome of the macro\n-\t// expansion\n-\tif (expanded_fragment.is_error ())\n-\t  accumulator.push_back (node); // if expansion fails, there might be a\n-\t\t\t\t\t// non-macro expression we need to keep\n-\telse\n-\t  {\n-\t    // if expansion succeeded, then we need to merge the fragment with\n-\t    // the contents in the accumulator, so that our final expansion\n-\t    // result will contain non-macro nodes as it should\n-\t    auto new_nodes = expanded_fragment.get_nodes ();\n-\t    std::move (new_nodes.begin (), new_nodes.end (),\n-\t\t       std::back_inserter (accumulator));\n-\t    expanded_fragment = AST::Fragment::complete (accumulator);\n-\t  }\n-\texpansion_depth--;\n-      }\n-\n-    return old_fragment;\n+\n+    return fragment;\n   }\n \n+  /**\n+   * Has the MacroExpander expanded a macro since its state was last reset?\n+   */\n+  bool has_changed () const { return has_changed_flag; }\n+\n+  /**\n+   * Reset the expander's \"changed\" state. This function should be executed at\n+   * each iteration in a fixed point loop\n+   */\n+  void reset_changed_state () { has_changed_flag = false; }\n+\n+  AST::MacroRulesDefinition *get_last_definition () { return last_def; }\n+  AST::MacroInvocation *get_last_invocation () { return last_invoc; }\n+\n private:\n   AST::Crate &crate;\n   Session &session;\n   SubstitutionScope sub_stack;\n   std::vector<ContextType> context;\n   AST::Fragment expanded_fragment;\n+  bool has_changed_flag;\n+\n+  AST::MacroRulesDefinition *last_def;\n+  AST::MacroInvocation *last_invoc;\n \n public:\n   Resolver::Resolver *resolver;"}, {"sha": "60d6c8abc4db7f281feb2bcfea3681961bad662a", "filename": "gcc/rust/resolve/rust-early-name-resolver.cc", "status": "modified", "additions": 93, "deletions": 34, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.cc?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -24,20 +24,17 @@ namespace Rust {\n namespace Resolver {\n \n EarlyNameResolver::EarlyNameResolver ()\n-  : resolver (*Resolver::get ()), mappings (*Analysis::Mappings::get ())\n+  : current_scope (UNKNOWN_NODEID), resolver (*Resolver::get ()),\n+    mappings (*Analysis::Mappings::get ())\n {}\n \n void\n EarlyNameResolver::go (AST::Crate &crate)\n {\n-  // FIXME: Is that valid? Why is the regular name resolution doing\n-  // mappings->get_next_node_id()?\n-  resolver.get_macro_scope ().push (crate.get_node_id ());\n-\n-  for (auto &item : crate.items)\n-    item->accept_vis (*this);\n-\n-  // FIXME: Should we pop the macro scope?\n+  scoped (crate.get_node_id (), [&crate, this] () {\n+    for (auto &item : crate.items)\n+      item->accept_vis (*this);\n+  });\n }\n \n void\n@@ -335,11 +332,13 @@ EarlyNameResolver::visit (AST::ClosureExprInner &expr)\n void\n EarlyNameResolver::visit (AST::BlockExpr &expr)\n {\n-  for (auto &stmt : expr.get_statements ())\n-    stmt->accept_vis (*this);\n+  scoped (expr.get_node_id (), [&expr, this] () {\n+    for (auto &stmt : expr.get_statements ())\n+      stmt->accept_vis (*this);\n \n-  if (expr.has_tail_expr ())\n-    expr.get_tail_expr ()->accept_vis (*this);\n+    if (expr.has_tail_expr ())\n+      expr.get_tail_expr ()->accept_vis (*this);\n+  });\n }\n \n void\n@@ -434,8 +433,11 @@ EarlyNameResolver::visit (AST::WhileLetLoopExpr &expr)\n void\n EarlyNameResolver::visit (AST::ForLoopExpr &expr)\n {\n-  expr.get_iterator_expr ()->accept_vis (*this);\n-  expr.get_loop_block ()->accept_vis (*this);\n+  scoped (expr.get_node_id (), [&expr, this] () {\n+    expr.get_pattern ()->accept_vis (*this);\n+    expr.get_iterator_expr ()->accept_vis (*this);\n+    expr.get_loop_block ()->accept_vis (*this);\n+  });\n }\n \n void\n@@ -473,7 +475,9 @@ void\n EarlyNameResolver::visit (AST::IfLetExpr &expr)\n {\n   expr.get_value_expr ()->accept_vis (*this);\n-  expr.get_if_block ()->accept_vis (*this);\n+\n+  scoped (expr.get_node_id (),\n+\t  [&expr, this] () { expr.get_if_block ()->accept_vis (*this); });\n }\n \n void\n@@ -504,16 +508,21 @@ void\n EarlyNameResolver::visit (AST::MatchExpr &expr)\n {\n   expr.get_scrutinee_expr ()->accept_vis (*this);\n-  for (auto &match_arm : expr.get_match_cases ())\n-    {\n-      if (match_arm.get_arm ().has_match_arm_guard ())\n-\tmatch_arm.get_arm ().get_guard_expr ()->accept_vis (*this);\n \n-      for (auto &pattern : match_arm.get_arm ().get_patterns ())\n-\tpattern->accept_vis (*this);\n+  scoped (expr.get_node_id (), [&expr, this] () {\n+    for (auto &arm : expr.get_match_cases ())\n+      {\n+\tscoped (arm.get_node_id (), [&arm, this] () {\n+\t  if (arm.get_arm ().has_match_arm_guard ())\n+\t    arm.get_arm ().get_guard_expr ()->accept_vis (*this);\n \n-      match_arm.get_expr ()->accept_vis (*this);\n-    }\n+\t  for (auto &pattern : arm.get_arm ().get_patterns ())\n+\t    pattern->accept_vis (*this);\n+\n+\t  arm.get_expr ()->accept_vis (*this);\n+\t});\n+      }\n+  });\n }\n \n void\n@@ -571,8 +580,10 @@ EarlyNameResolver::visit (AST::Method &method)\n void\n EarlyNameResolver::visit (AST::Module &module)\n {\n-  for (auto &item : module.get_items ())\n-    item->accept_vis (*this);\n+  scoped (module.get_node_id (), [&module, this] () {\n+    for (auto &item : module.get_items ())\n+      item->accept_vis (*this);\n+  });\n }\n \n void\n@@ -722,8 +733,13 @@ EarlyNameResolver::visit (AST::TraitItemType &)\n void\n EarlyNameResolver::visit (AST::Trait &trait)\n {\n-  for (auto &item : trait.get_trait_items ())\n-    item->accept_vis (*this);\n+  for (auto &generic : trait.get_generic_params ())\n+    generic->accept_vis (*this);\n+\n+  scoped (trait.get_node_id (), [&trait, this] () {\n+    for (auto &item : trait.get_trait_items ())\n+      item->accept_vis (*this);\n+  });\n }\n \n void\n@@ -734,8 +750,10 @@ EarlyNameResolver::visit (AST::InherentImpl &impl)\n   for (auto &generic : impl.get_generic_params ())\n     generic->accept_vis (*this);\n \n-  for (auto &item : impl.get_impl_items ())\n-    item->accept_vis (*this);\n+  scoped (impl.get_node_id (), [&impl, this] () {\n+    for (auto &item : impl.get_impl_items ())\n+      item->accept_vis (*this);\n+  });\n }\n \n void\n@@ -746,8 +764,10 @@ EarlyNameResolver::visit (AST::TraitImpl &impl)\n   for (auto &generic : impl.get_generic_params ())\n     generic->accept_vis (*this);\n \n-  for (auto &item : impl.get_impl_items ())\n-    item->accept_vis (*this);\n+  scoped (impl.get_node_id (), [&impl, this] () {\n+    for (auto &item : impl.get_impl_items ())\n+      item->accept_vis (*this);\n+  });\n }\n \n void\n@@ -772,8 +792,10 @@ EarlyNameResolver::visit (AST::ExternalFunctionItem &item)\n void\n EarlyNameResolver::visit (AST::ExternBlock &block)\n {\n-  for (auto &item : block.get_extern_items ())\n-    item->accept_vis (*this);\n+  scoped (block.get_node_id (), [&block, this] () {\n+    for (auto &item : block.get_extern_items ())\n+      item->accept_vis (*this);\n+  });\n }\n \n void\n@@ -795,6 +817,15 @@ EarlyNameResolver::visit (AST::MacroRulesDefinition &rules_def)\n \t\t\t\t      rules_def.get_rule_name ());\n   resolver.get_macro_scope ().insert (path, rules_def.get_node_id (),\n \t\t\t\t      rules_def.get_locus ());\n+\n+  /* Since the EarlyNameResolver runs multiple time (fixed point algorithm)\n+   * we could be inserting the same macro def over and over again until we\n+   * implement some optimizations */\n+  // FIXME: ARTHUR: Remove that lookup and add proper optimizations instead\n+  AST::MacroRulesDefinition *tmp = nullptr;\n+  if (mappings.lookup_macro_def (rules_def.get_node_id (), &tmp))\n+    return;\n+\n   mappings.insert_macro_def (&rules_def);\n   rust_debug_loc (rules_def.get_locus (), \"inserting macro def: [%s]\",\n \t\t  path.get ().c_str ());\n@@ -806,6 +837,10 @@ EarlyNameResolver::visit (AST::MacroInvocation &invoc)\n   auto &invoc_data = invoc.get_invoc_data ();\n   auto has_semicolon = invoc.has_semicolon ();\n \n+  if (invoc.get_kind () == AST::MacroInvocation::InvocKind::Builtin)\n+    for (auto &pending_invoc : invoc.get_pending_eager_invocations ())\n+      pending_invoc->accept_vis (*this);\n+\n   // ??\n   // switch on type of macro:\n   //  - '!' syntax macro (inner switch)\n@@ -847,6 +882,30 @@ EarlyNameResolver::visit (AST::MacroInvocation &invoc)\n   bool ok = mappings.lookup_macro_def (resolved_node, &rules_def);\n   rust_assert (ok);\n \n+  auto &outer_attrs = rules_def->get_outer_attrs ();\n+  bool is_builtin\n+    = std::any_of (outer_attrs.begin (), outer_attrs.end (),\n+\t\t   [] (AST::Attribute attr) {\n+\t\t     return attr.get_path () == \"rustc_builtin_macro\";\n+\t\t   });\n+\n+  if (is_builtin)\n+    {\n+      auto builtin_kind\n+\t= AST::builtin_macro_from_string (rules_def->get_rule_name ());\n+      invoc.map_to_builtin (builtin_kind);\n+    }\n+\n+  auto attributes = rules_def->get_outer_attrs ();\n+\n+  /* Since the EarlyNameResolver runs multiple time (fixed point algorithm)\n+   * we could be inserting the same macro def over and over again until we\n+   * implement some optimizations */\n+  // FIXME: ARTHUR: Remove that lookup and add proper optimizations instead\n+  AST::MacroRulesDefinition *tmp_def = nullptr;\n+  if (mappings.lookup_macro_invocation (invoc, &tmp_def))\n+    return;\n+\n   mappings.insert_macro_invocation (invoc, rules_def);\n }\n "}, {"sha": "c74c452ecafcc505d26ec02a20b76e8a6c7e4349", "filename": "gcc/rust/resolve/rust-early-name-resolver.h", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.h?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -35,6 +35,71 @@ class EarlyNameResolver : public AST::ASTVisitor\n   void go (AST::Crate &crate);\n \n private:\n+  /**\n+   * Execute a lambda within a scope. This is equivalent to calling\n+   * `enter_scope` before your code and `exit_scope` after. This ensures\n+   * no errors can be committed\n+   */\n+  void scoped (NodeId scope_id, std::function<void ()> fn)\n+  {\n+    auto old_scope = current_scope;\n+    current_scope = scope_id;\n+    resolver.get_macro_scope ().push (scope_id);\n+    resolver.push_new_macro_rib (resolver.get_macro_scope ().peek ());\n+\n+    fn ();\n+\n+    resolver.get_macro_scope ().pop ();\n+    current_scope = old_scope;\n+  }\n+\n+  /**\n+   * The \"scope\" we are currently in.\n+   *\n+   * This involves lexical scopes:\n+   *\n+   * ```rust\n+   * // current_scope = crate_id;\n+   * macro_rules! foo { () => {} )\n+   *\n+   * {\n+   *     // current_scope = current_block_id;\n+   *     macro_rules! foo { () => { something!(); } }\n+   * }\n+   * // current_scope = crate_id;\n+   * ```\n+   *\n+   * as well as any sort of scope-like structure that might impact import name\n+   * resolution or macro name resolution:\n+   *\n+   * ```rust\n+   * macro_rules! foo {\n+   *     () => { fn empty() {} }\n+   * }\n+   *\n+   *\n+   * trait Foo {\n+   *     fn foo() {\n+   *         fn inner_foo() {\n+   *             macro_rules! foo { () => {} )\n+   *\n+   *             foo!();\n+   *         }\n+   *\n+   *         foo!();\n+   *     }\n+   *\n+   *     foo!();\n+   * }\n+   *\n+   * foo!();\n+   * ```\n+   */\n+  NodeId current_scope;\n+\n+  /* The crate's scope */\n+  NodeId crate_scope;\n+\n   Resolver &resolver;\n   Analysis::Mappings &mappings;\n "}, {"sha": "ae564ad62607de99c1092924d8640544a1c3ca41", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -827,9 +827,6 @@ Session::injection (AST::Crate &crate)\n void\n Session::expansion (AST::Crate &crate)\n {\n-  /* We need to name resolve macros and imports here */\n-  Resolver::EarlyNameResolver ().go (crate);\n-\n   rust_debug (\"started expansion\");\n \n   /* rustc has a modification to windows PATH temporarily here, which may end\n@@ -839,11 +836,41 @@ Session::expansion (AST::Crate &crate)\n   // if not, would at least have to configure recursion_limit\n   ExpansionCfg cfg;\n \n+  auto fixed_point_reached = false;\n+  unsigned iterations = 0;\n+\n   // create extctxt? from parse session, cfg, and resolver?\n   /* expand by calling cxtctxt object's monotonic_expander's expand_crate\n    * method. */\n   MacroExpander expander (crate, cfg, *this);\n-  expander.expand_crate ();\n+\n+  while (!fixed_point_reached && iterations < cfg.recursion_limit)\n+    {\n+      /* We need to name resolve macros and imports here */\n+      Resolver::EarlyNameResolver ().go (crate);\n+\n+      expander.expand_crate ();\n+\n+      fixed_point_reached = !expander.has_changed ();\n+      expander.reset_changed_state ();\n+      iterations++;\n+\n+      if (saw_errors ())\n+\tbreak;\n+    }\n+\n+  if (iterations == cfg.recursion_limit)\n+    {\n+      auto last_invoc = expander.get_last_invocation ();\n+      auto last_def = expander.get_last_definition ();\n+\n+      rust_assert (last_def && last_invoc);\n+\n+      RichLocation range (last_invoc->get_locus ());\n+      range.add_range (last_def->get_locus ());\n+\n+      rust_error_at (range, \"reached recursion limit\");\n+    }\n \n   // error reporting - check unused macros, get missing fragment specifiers\n "}, {"sha": "0b516fd93a9ddd798e08dded182bfc5255173934", "filename": "gcc/testsuite/rust/compile/builtin_macro_eager1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_eager1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_eager1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_eager1.rs?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "previous_filename": "gcc/testsuite/rust/compile/builtin_macro_recurse.rs"}, {"sha": "21bf95c78297a1cde6dc34c72ed4229fa860ed2f", "filename": "gcc/testsuite/rust/compile/builtin_macro_eager2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_eager2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_eager2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_eager2.rs?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -0,0 +1,16 @@\n+#[rustc_builtin_macro]\n+macro_rules! env {\n+    () => {};\n+}\n+\n+macro_rules! a {\n+    () => {\n+        \"__undefined__\"\n+    };\n+}\n+\n+fn main() {\n+    let _ = env!(a!()); // { dg-error \"environment variable .__undefined__. not defined\" }\n+    let _ = env!(a!(), \"custom\"); // { dg-error \"custom\" }\n+    let _ = env!(a!(), a!()); // { dg-error \"__undefined__\" }\n+}"}, {"sha": "d859920862451a77920f2d9d9df10cd8245e687d", "filename": "gcc/testsuite/rust/compile/builtin_macro_recurse2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_recurse2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_recurse2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_recurse2.rs?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -0,0 +1,20 @@\n+// { dg-additional-options \"-fdump-tree-gimple\" }\n+\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+\n+macro_rules! a {\n+    () => {\n+        \"hey\"\n+    };\n+    ($($t:tt)*) => {\n+        \"ho\"\n+    };\n+}\n+\n+fn main() {\n+    // { dg-final { scan-tree-dump-times {\"abheyho\"} 1 gimple } }\n+    let _ = concat!(\"a\", 'b', a!(), a!(b c d e f a!()), '\\0');\n+}"}, {"sha": "b50afbece41fbe753fb204f8673c84aba6d714c9", "filename": "gcc/testsuite/rust/compile/macro17.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro17.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro17.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro17.rs?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -1,7 +1,7 @@\n macro_rules! rep {\n-    ($a:literal) => { $a }; // { dg-error \"reached recursion limit\" }\n-    ($a:literal $(, $e:literal)*) => { // { dg-error \"reached recursion limit\" }\n-        $a + rep!(0 $(, $e)*) // { dg-error \"Failed to match\" }\n+    ($a:literal) => { $a };\n+    ($a:literal $(, $e:literal)*) => {\n+        $a + rep!(0 $(, $e)*) // { dg-error \"reached recursion limit\" }\n     }\n }\n "}, {"sha": "dabac6f78442053c9c957d2ce7fe25d2a356bece", "filename": "gcc/testsuite/rust/compile/macro44.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro44.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro44.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro44.rs?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -11,12 +11,12 @@ mod foo {\n         () => {{}};\n     }\n \n-    fn foo_f() { // { dg-warning \"function is never used\" }\n+    fn foo_f() {\n         foo!();\n     }\n \n-    fn bar_f() { // { dg-warning \"function is never used\" }\n-        baz!();\n+    fn bar_f() {\n+        baz!(); // { dg-error \"unknown macro\" }\n     }\n }\n "}, {"sha": "3ef811aeab508ca08584da6f9f444adc22ec3b98", "filename": "gcc/testsuite/rust/compile/macro46.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro46.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6db68ee151234eb7fead8e6631273bbe5302277/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro46.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro46.rs?ref=c6db68ee151234eb7fead8e6631273bbe5302277", "patch": "@@ -0,0 +1,19 @@\n+fn foo() {}\n+\n+fn main() {\n+    macro_rules! a {\n+        () => {\n+            foo();\n+        };\n+    }\n+\n+    {\n+        macro_rules! a {\n+            () => {\n+                bar();\n+            };\n+        }\n+    }\n+\n+    a!();\n+}"}]}