{"sha": "533c07c594cef102741325e09a6580094fa32cba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMzYzA3YzU5NGNlZjEwMjc0MTMyNWUwOWE2NTgwMDk0ZmEzMmNiYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-05-31T14:58:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-05-31T14:58:49Z"}, "message": "cgraph.h (cgraph_inline_failed_t): Give enum a name\n\n\t* cgraph.h (cgraph_inline_failed_t): Give enum a name\n\t* lto-cgraph.c (LDPR_NUM_KNOWN): New macro.\n\t(LTO_cgraph_tags): Add LTO_cgraph_last_tag.\n\t(lto_output_edge): Use output_enum and var_len_unsigned.\n\t(lto_output_varpool_node): Likewise.\n\t(input_overwrite_node): Do not take resolution parameter;\n\textract it from a bitpack.\n\t(input_node): Do not read resolution; use input_enum and\n\tvar_len_unsigned.\n\t(input_varpool_node): Likewise.\n\t(input_edge): Likewise.\n\t(input_cgraph_1): Likewise.\n\nFrom-SVN: r174487", "tree": {"sha": "935e97bf85492ea491a4ae45257e0ecd95234485", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/935e97bf85492ea491a4ae45257e0ecd95234485"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/533c07c594cef102741325e09a6580094fa32cba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533c07c594cef102741325e09a6580094fa32cba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/533c07c594cef102741325e09a6580094fa32cba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533c07c594cef102741325e09a6580094fa32cba/comments", "author": null, "committer": null, "parents": [{"sha": "2611db71ea2dda0b3c5fb32b2fc5778779a57fda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2611db71ea2dda0b3c5fb32b2fc5778779a57fda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2611db71ea2dda0b3c5fb32b2fc5778779a57fda"}], "stats": {"total": 79, "additions": 52, "deletions": 27}, "files": [{"sha": "0057740d7e0a11dc54b63bff55d714bdee502d2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533c07c594cef102741325e09a6580094fa32cba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533c07c594cef102741325e09a6580094fa32cba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=533c07c594cef102741325e09a6580094fa32cba", "patch": "@@ -1,3 +1,18 @@\n+2011-05-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (cgraph_inline_failed_t): Give enum a name\n+\t* lto-cgraph.c (LDPR_NUM_KNOWN): New macro.\n+\t(LTO_cgraph_tags): Add LTO_cgraph_last_tag.\n+\t(lto_output_edge): Use output_enum and var_len_unsigned.\n+\t(lto_output_varpool_node): Likewise.\n+\t(input_overwrite_node): Do not take resolution parameter;\n+\textract it from a bitpack.\n+\t(input_node): Do not read resolution; use input_enum and\n+\tvar_len_unsigned.\n+\t(input_varpool_node): Likewise.\n+\t(input_edge): Likewise.\n+\t(input_cgraph_1): Likewise.\n+\n 2011-05-31  Richard Guenther  <rguenther@suse.de>\n \n \t* gimple.c (gimple_register_canonical_type): Do not register"}, {"sha": "ded3aedbb0f4c11bab69101a49670d83058c2d38", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533c07c594cef102741325e09a6580094fa32cba/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533c07c594cef102741325e09a6580094fa32cba/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=533c07c594cef102741325e09a6580094fa32cba", "patch": "@@ -304,7 +304,7 @@ typedef struct\n \n #define DEFCIFCODE(code, string)\tCIF_ ## code,\n /* Reasons for inlining failures.  */\n-typedef enum {\n+typedef enum cgraph_inline_failed_enum {\n #include \"cif-code.def\"\n   CIF_N_REASONS\n } cgraph_inline_failed_t;"}, {"sha": "1d2f92e9d1eea2fd0ffcadba8ce099ab0b13fbe1", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533c07c594cef102741325e09a6580094fa32cba/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533c07c594cef102741325e09a6580094fa32cba/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=533c07c594cef102741325e09a6580094fa32cba", "patch": "@@ -49,6 +49,8 @@ static void output_varpool (cgraph_node_set, varpool_node_set);\n static void output_cgraph_opt_summary (cgraph_node_set set);\n static void input_cgraph_opt_summary (VEC (cgraph_node_ptr, heap) * nodes);\n \n+/* Number of LDPR values known to GCC.  */\n+#define LDPR_NUM_KNOWN (LDPR_RESOLVED_DYN + 1)\n \n /* Cgraph streaming is organized as set of record whose type\n    is indicated by a tag.  */\n@@ -62,7 +64,8 @@ enum LTO_cgraph_tags\n   LTO_cgraph_analyzed_node,\n   /* Cgraph edges.  */\n   LTO_cgraph_edge,\n-  LTO_cgraph_indirect_edge\n+  LTO_cgraph_indirect_edge,\n+  LTO_cgraph_last_tag\n };\n \n /* Create a new cgraph encoder.  */\n@@ -262,9 +265,11 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   struct bitpack_d bp;\n \n   if (edge->indirect_unknown_callee)\n-    lto_output_uleb128_stream (ob->main_stream, LTO_cgraph_indirect_edge);\n+    lto_output_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag,\n+\t\t     LTO_cgraph_indirect_edge);\n   else\n-    lto_output_uleb128_stream (ob->main_stream, LTO_cgraph_edge);\n+    lto_output_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag,\n+\t\t     LTO_cgraph_edge);\n \n   ref = lto_cgraph_encoder_lookup (encoder, edge->caller);\n   gcc_assert (ref != LCC_NOT_FOUND);\n@@ -282,9 +287,10 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   bp = bitpack_create (ob->main_stream);\n   uid = (!gimple_has_body_p (edge->caller->decl)\n \t ? edge->lto_stmt_uid : gimple_uid (edge->call_stmt));\n-  bp_pack_value (&bp, uid, HOST_BITS_PER_INT);\n-  bp_pack_value (&bp, edge->inline_failed, HOST_BITS_PER_INT);\n-  bp_pack_value (&bp, edge->frequency, HOST_BITS_PER_INT);\n+  bp_pack_enum (&bp, cgraph_inline_failed_enum,\n+\t        CIF_N_REASONS, edge->inline_failed);\n+  bp_pack_var_len_unsigned (&bp, uid);\n+  bp_pack_var_len_unsigned (&bp, edge->frequency);\n   bp_pack_value (&bp, edge->indirect_inlining_edge, 1);\n   bp_pack_value (&bp, edge->call_stmt_cannot_inline_p, 1);\n   bp_pack_value (&bp, edge->can_throw_external, 1);\n@@ -415,7 +421,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   else\n     tag = LTO_cgraph_unavail_node;\n \n-  lto_output_uleb128_stream (ob->main_stream, tag);\n+  lto_output_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag, tag);\n \n   /* In WPA mode, we only output part of the call-graph.  Also, we\n      fake cgraph node attributes.  There are two cases that we care.\n@@ -503,8 +509,9 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n   bp_pack_value (&bp, node->thunk.thunk_p && !boundary_p, 1);\n+  bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n+\t        LDPR_NUM_KNOWN, node->resolution);\n   lto_output_bitpack (&bp);\n-  lto_output_uleb128_stream (ob->main_stream, node->resolution);\n \n   if (node->thunk.thunk_p && !boundary_p)\n     {\n@@ -534,7 +541,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t  lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n \t\t\t\t    alias->thunk.alias);\n \t  gcc_assert (cgraph_get_node (alias->thunk.alias) == node);\n-\t  lto_output_uleb128_stream (ob->main_stream, alias->resolution);\n+\t  lto_output_enum (ob->main_stream, ld_plugin_symbol_resolution,\n+\t\t\t   LDPR_NUM_KNOWN, alias->resolution);\n \t  alias = alias->previous;\n \t}\n       while (alias);\n@@ -595,15 +603,17 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   else\n     ref = LCC_NOT_FOUND;\n   lto_output_sleb128_stream (ob->main_stream, ref);\n-  lto_output_uleb128_stream (ob->main_stream, node->resolution);\n+  lto_output_enum (ob->main_stream, ld_plugin_symbol_resolution,\n+\t\t   LDPR_NUM_KNOWN, node->resolution);\n \n   if (count)\n     {\n       lto_output_uleb128_stream (ob->main_stream, count);\n       for (alias = node->extra_name; alias; alias = alias->next)\n \t{\n \t  lto_output_var_decl_index (ob->decl_state, ob->main_stream, alias->decl);\n-\t  lto_output_uleb128_stream (ob->main_stream, alias->resolution);\n+\t  lto_output_enum (ob->main_stream, ld_plugin_symbol_resolution,\n+\t\t\t   LDPR_NUM_KNOWN, alias->resolution);\n \t}\n     }\n }\n@@ -909,8 +919,7 @@ static void\n input_overwrite_node (struct lto_file_decl_data *file_data,\n \t\t      struct cgraph_node *node,\n \t\t      enum LTO_cgraph_tags tag,\n-\t\t      struct bitpack_d *bp,\n-\t\t      enum ld_plugin_symbol_resolution resolution)\n+\t\t      struct bitpack_d *bp)\n {\n   node->aux = (void *) tag;\n   node->local.lto_file_data = file_data;\n@@ -946,7 +955,8 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->only_called_at_startup = bp_unpack_value (bp, 1);\n   node->only_called_at_exit = bp_unpack_value (bp, 1);\n   node->thunk.thunk_p = bp_unpack_value (bp, 1);\n-  node->resolution = resolution;\n+  node->resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n+\t\t\t\t     LDPR_NUM_KNOWN);\n }\n \n /* Output the part of the cgraph in SET.  */\n@@ -989,7 +999,6 @@ input_node (struct lto_file_decl_data *file_data,\n   int ref = LCC_NOT_FOUND, ref2 = LCC_NOT_FOUND;\n   unsigned long same_body_count = 0;\n   int clone_ref;\n-  enum ld_plugin_symbol_resolution resolution;\n \n   clone_ref = lto_input_sleb128 (ib);\n \n@@ -1021,8 +1030,7 @@ input_node (struct lto_file_decl_data *file_data,\n \t\t    \"node %d\", node->uid);\n \n   bp = lto_input_bitpack (ib);\n-  resolution = (enum ld_plugin_symbol_resolution)lto_input_uleb128 (ib);\n-  input_overwrite_node (file_data, node, tag, &bp, resolution);\n+  input_overwrite_node (file_data, node, tag, &bp);\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->global.inlined_to = (cgraph_node_ptr) (intptr_t) ref;\n@@ -1058,7 +1066,8 @@ input_node (struct lto_file_decl_data *file_data,\n       real_alias = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n       alias = cgraph_same_body_alias (node, alias_decl, real_alias);\n       gcc_assert (alias);\n-      alias->resolution = (enum ld_plugin_symbol_resolution)lto_input_uleb128 (ib);\n+      alias->resolution = lto_input_enum (ib, ld_plugin_symbol_resolution,\n+\t\t\t\t\t  LDPR_NUM_KNOWN);\n     }\n   return node;\n }\n@@ -1102,7 +1111,8 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   ref = lto_input_sleb128 (ib);\n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->same_comdat_group = (struct varpool_node *) (intptr_t) ref;\n-  node->resolution = (enum ld_plugin_symbol_resolution)lto_input_uleb128 (ib);\n+  node->resolution = lto_input_enum (ib, ld_plugin_symbol_resolution,\n+\t\t\t\t     LDPR_NUM_KNOWN);\n   if (aliases_p)\n     {\n       count = lto_input_uleb128 (ib);\n@@ -1112,7 +1122,8 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n \t\t\t\t\t\t       lto_input_uleb128 (ib));\n \t  struct varpool_node *alias;\n \t  alias = varpool_extra_name_alias (decl, var_decl);\n-\t  alias->resolution = (enum ld_plugin_symbol_resolution)lto_input_uleb128 (ib);\n+\t  alias->resolution = lto_input_enum (ib, ld_plugin_symbol_resolution,\n+\t\t\t\t\t      LDPR_NUM_KNOWN);\n \t}\n     }\n   return node;\n@@ -1179,10 +1190,9 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n   count = (gcov_type) lto_input_sleb128 (ib);\n \n   bp = lto_input_bitpack (ib);\n-  stmt_id = (unsigned int) bp_unpack_value (&bp, HOST_BITS_PER_INT);\n-  inline_failed = (cgraph_inline_failed_t) bp_unpack_value (&bp,\n-\t\t\t\t\t\t\t    HOST_BITS_PER_INT);\n-  freq = (int) bp_unpack_value (&bp, HOST_BITS_PER_INT);\n+  inline_failed = bp_unpack_enum (&bp, cgraph_inline_failed_enum, CIF_N_REASONS);\n+  stmt_id = bp_unpack_var_len_unsigned (&bp);\n+  freq = (int) bp_unpack_var_len_unsigned (&bp);\n \n   if (indirect)\n     edge = cgraph_create_indirect_edge (caller, NULL, 0, count, freq);\n@@ -1225,7 +1235,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n   unsigned i;\n   unsigned HOST_WIDE_INT len;\n \n-  tag = (enum LTO_cgraph_tags) lto_input_uleb128 (ib);\n+  tag = lto_input_enum (ib, LTO_cgraph_tags, LTO_cgraph_last_tag);\n   while (tag)\n     {\n       if (tag == LTO_cgraph_edge)\n@@ -1241,7 +1251,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \t  lto_cgraph_encoder_encode (file_data->cgraph_node_encoder, node);\n \t}\n \n-      tag = (enum LTO_cgraph_tags) lto_input_uleb128 (ib);\n+      tag = lto_input_enum (ib, LTO_cgraph_tags, LTO_cgraph_last_tag);\n     }\n \n   /* Input toplevel asms.  */"}]}