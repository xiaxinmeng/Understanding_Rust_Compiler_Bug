{"sha": "fc12098dbe6144bf04ebec95adb0968a1d04da58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMxMjA5OGRiZTYxNDRiZjA0ZWJlYzk1YWRiMDk2OGExZDA0ZGE1OA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2016-02-15T22:31:13Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2016-02-15T22:31:13Z"}, "message": "re PR libfortran/69651 ([6 Regession] Usage of unitialized pointer io/list_read.c)\n\n2016-02-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/69651\n\t* io/list_read.c: Entire file trailing spaces removed.\n\t(CASE_SEPARATORS): Remove '!'.\n\t(is_separator): Add namelist mode as condition with '!'.\n\t(push_char): Remove un-needed memset. (push_char4): Likewise and remove\n\t'new' pointer. (eat_separator): Remove un-needed use of notify_std.\n\t(read_logical): If '!' bang encountered when not in namelist mode got\n\tbad_logical to give an error. (read_integer): Likewise reject '!'.\n\t(read_character): Remove condition testing c = '!' which is now inside\n\tthe is_separator macro. (parse_real): Reject '!' unless in namelist mode.\n\t(read_complex): Reject '!' unless in namelist mode. (read_real): Likewise\n\treject '!'.\n\n\tPR libgfortran/69651\n\t* gfortran.dg/read_bang.f90: New test.\n\t* gfortran.dg/read_bang4.f90: New test.\n\nFrom-SVN: r233436", "tree": {"sha": "1d6efbd55b7f05ed50951724c9cfbc8a635f439f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d6efbd55b7f05ed50951724c9cfbc8a635f439f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc12098dbe6144bf04ebec95adb0968a1d04da58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc12098dbe6144bf04ebec95adb0968a1d04da58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc12098dbe6144bf04ebec95adb0968a1d04da58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc12098dbe6144bf04ebec95adb0968a1d04da58/comments", "author": null, "committer": null, "parents": [{"sha": "f0516ca404ec64ddf9ab465b73077d672ee52fd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0516ca404ec64ddf9ab465b73077d672ee52fd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0516ca404ec64ddf9ab465b73077d672ee52fd4"}], "stats": {"total": 272, "additions": 208, "deletions": 64}, "files": [{"sha": "020ab2b4a03525e6b6b808ba1a7b53a6ceed54e3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc12098dbe6144bf04ebec95adb0968a1d04da58/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc12098dbe6144bf04ebec95adb0968a1d04da58/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc12098dbe6144bf04ebec95adb0968a1d04da58", "patch": "@@ -1,3 +1,9 @@\n+2016-02-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/69651\n+\t* gfortran.dg/read_bang.f90: New test.\n+\t* gfortran.dg/read_bang4.f90: New test.\n+\n 2016-02-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/69658"}, {"sha": "7806ca776ebacf87314e7115bbbaa77158b23eb6", "filename": "gcc/testsuite/gfortran.dg/read_bang.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc12098dbe6144bf04ebec95adb0968a1d04da58/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_bang.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc12098dbe6144bf04ebec95adb0968a1d04da58/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_bang.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_bang.f90?ref=fc12098dbe6144bf04ebec95adb0968a1d04da58", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+! PR69651 Usage of unitialized pointer io/list_read.c \n+! Note: The uninitialized pointer was not the cause of the problem\n+!       observed with this test case. The problem was mishandling '!'\n+!       See also test case read_bang4.f90.\n+program test\n+  implicit none\n+  integer :: i, j, ios\n+  real ::  r, s\n+  complex :: c, d\n+  character(20) :: str1, str2\n+  \n+  i = -5\n+  j = -6\n+  r = -3.14\n+  s = -2.71\n+  c = (-1.1,-2.2)\n+  d = (-3.3,-4.4)\n+  str1 = \"candy\"\n+  str2 = \"peppermint\"\n+  open(15, status='scratch')\n+  write(15,*) \"10  1!2\"\n+  write(15,*) \"  23.5! 34.5\"\n+  write(15,*) \"  (67.50,69.25)  (51.25,87.75)!\"\n+  write(15,*) \"  'abcdefgh!' '  !klmnopq!'\"\n+  rewind(15)\n+  read(15,*,iostat=ios) i, j\n+  if (ios.ne.5010) call abort\n+  read(15,*,iostat=ios) r, s\n+  if (ios.ne.5010) call abort\n+  read(15,*,iostat=ios) c, d\n+  if (ios.ne.5010) call abort\n+  read(15,*,iostat=ios) str1, str2\n+  if (ios.ne.0) call abort\n+  if (str1.ne.\"abcdefgh!\") print *, str1\n+  if (str2.ne.\"  !klmnopq!\") print *, str2\n+  close(15)\n+end program"}, {"sha": "78101fcb8ad1e7e2e0079719ef71637d88fd5790", "filename": "gcc/testsuite/gfortran.dg/read_bang4.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc12098dbe6144bf04ebec95adb0968a1d04da58/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_bang4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc12098dbe6144bf04ebec95adb0968a1d04da58/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_bang4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_bang4.f90?ref=fc12098dbe6144bf04ebec95adb0968a1d04da58", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+! PR69651 Usage of unitialized pointer io/list_read.c \n+! Note: The uninitialized pointer was not the cause of the problem\n+!       observed with this test case. This tests the case with UTF-8\n+!       files. The large string test the realloc use in push_char4 of\n+!       list_read.c\n+program test\n+  implicit none\n+  integer :: i, j, k, ios\n+  integer, parameter :: big = 600\n+  real ::  r, s\n+  complex :: c, d\n+  character(kind=4,len=big) :: str1, str2, str3\n+\n+  do i=1,big, 10\n+    do j = 0, 9\n+      k = i + j\n+      str2(k:k) = char(65+j)\n+    end do\n+  end do\n+  i = -5\n+  j = -6\n+  r = -3.14\n+  s = -2.71\n+  c = (-1.1,-2.2)\n+  d = (-3.3,-4.4)\n+  str3 = str2\n+  open(15, status='scratch', encoding=\"utf-8\")\n+  write(15,*) \"10  1!2\"\n+  write(15,*) \"  23.5! 34.5\"\n+  write(15,*) \"  (67.50,69.25)  (51.25,87.75)!\"\n+  write(15,*) \"  'abcdefgh!'\", \" \", str2\n+  rewind(15)\n+  str1 = 4_\"candy\"\n+  str2 = 4_\"peppermint\"\n+  read(15,*,iostat=ios) i, j\n+  if (ios.ne.5010) call abort\n+  read(15,*,iostat=ios) r, s\n+  if (ios.ne.5010) call abort\n+  read(15,*,iostat=ios) c, d\n+  if (ios.ne.5010) call abort\n+  read(15,*,iostat=ios) str1, str2\n+  if (ios.ne.0) call abort\n+  if (str1.ne.4_\"abcdefgh!\") call abort\n+  if (str2.ne.str3) call abort\n+  close(15)\n+end program"}, {"sha": "5120a433f29bd562b15122bfc13fbd8a6184cf43", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc12098dbe6144bf04ebec95adb0968a1d04da58/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc12098dbe6144bf04ebec95adb0968a1d04da58/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=fc12098dbe6144bf04ebec95adb0968a1d04da58", "patch": "@@ -1,3 +1,18 @@\n+2016-02-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/69651\n+\t* io/list_read.c: Entire file trailing spaces removed.\n+\t(CASE_SEPARATORS): Remove '!'.\n+\t(is_separator): Add namelist mode as condition with '!'.\n+\t(push_char): Remove un-needed memset. (push_char4): Likewise and remove\n+\t'new' pointer. (eat_separator): Remove un-needed use of notify_std.\n+\t(read_logical): If '!' bang encountered when not in namelist mode got\n+\tbad_logical to give an error. (read_integer): Likewise reject '!'.\n+\t(read_character): Remove condition testing c = '!' which is now inside\n+\tthe is_separator macro. (parse_real): Reject '!' unless in namelist mode.\n+\t(read_complex): Reject '!' unless in namelist mode. (read_real): Likewise\n+\treject '!'. \n+\n 2016-02-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/69668"}, {"sha": "fcd4b6e25e97073ca7f2ed23b8eec9eb91c7bd52", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 102, "deletions": 64, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc12098dbe6144bf04ebec95adb0968a1d04da58/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc12098dbe6144bf04ebec95adb0968a1d04da58/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=fc12098dbe6144bf04ebec95adb0968a1d04da58", "patch": "@@ -52,13 +52,14 @@ typedef unsigned char uchar;\n #define CASE_DIGITS   case '0': case '1': case '2': case '3': case '4': \\\n                       case '5': case '6': case '7': case '8': case '9'\n \n-#define CASE_SEPARATORS  case ' ': case ',': case '/': case '\\n': case '\\t': \\\n-                         case '\\r': case ';': case '!'\n+#define CASE_SEPARATORS case ' ': case ',': case '/': case '\\n': \\\n+\t\t\tcase '\\t': case '\\r': case ';'\n \n /* This macro assumes that we're operating on a variable.  */\n \n #define is_separator(c) (c == '/' ||  c == ',' || c == '\\n' || c == ' ' \\\n-                         || c == '\\t' || c == '\\r' || c == ';' || c == '!')\n+                         || c == '\\t' || c == '\\r' || c == ';' || \\\n+\t\t\t (dtp->u.p.namelist_mode && c == '!'))\n \n /* Maximum repeat count.  Less than ten times the maximum signed int32.  */\n \n@@ -75,7 +76,7 @@ typedef unsigned char uchar;\n \n /* Worker function to save a default KIND=1 character to a string\n    buffer, enlarging it as necessary.  */\n-   \n+\n static void\n push_char_default (st_parameter_dt *dtp, int c)\n {\n@@ -92,13 +93,8 @@ push_char_default (st_parameter_dt *dtp, int c)\n   if (dtp->u.p.saved_used >= dtp->u.p.saved_length)\n     {\n       dtp->u.p.saved_length = 2 * dtp->u.p.saved_length;\n-      dtp->u.p.saved_string = \n+      dtp->u.p.saved_string =\n \txrealloc (dtp->u.p.saved_string, dtp->u.p.saved_length);\n-      \n-      // Also this should not be necessary.\n-      memset (dtp->u.p.saved_string + dtp->u.p.saved_used, 0, \n-\t      dtp->u.p.saved_length - dtp->u.p.saved_used);\n-\n     }\n \n   dtp->u.p.saved_string[dtp->u.p.saved_used++] = (char) c;\n@@ -107,11 +103,10 @@ push_char_default (st_parameter_dt *dtp, int c)\n \n /* Worker function to save a KIND=4 character to a string buffer,\n    enlarging the buffer as necessary.  */\n-   \n static void\n push_char4 (st_parameter_dt *dtp, int c)\n {\n-  gfc_char4_t *new, *p = (gfc_char4_t *) dtp->u.p.saved_string;\n+  gfc_char4_t *p = (gfc_char4_t *) dtp->u.p.saved_string;\n \n   if (p == NULL)\n     {\n@@ -125,9 +120,6 @@ push_char4 (st_parameter_dt *dtp, int c)\n     {\n       dtp->u.p.saved_length = 2 * dtp->u.p.saved_length;\n       p = xrealloc (p, dtp->u.p.saved_length * sizeof (gfc_char4_t));\n-      \n-      memset4 (new + dtp->u.p.saved_used, 0, \n-\t      dtp->u.p.saved_length - dtp->u.p.saved_used);\n     }\n \n   p[dtp->u.p.saved_used++] = c;\n@@ -168,7 +160,7 @@ free_line (st_parameter_dt *dtp)\n /* Unget saves the last character so when reading the next character,\n    we need to check to see if there is a character waiting.  Similar,\n    if the line buffer is being used to read_logical, check it too.  */\n-   \n+\n static int\n check_buffers (st_parameter_dt *dtp)\n {\n@@ -200,7 +192,7 @@ check_buffers (st_parameter_dt *dtp)\n       dtp->u.p.line_buffer_pos = 0;\n       dtp->u.p.line_buffer_enabled = 0;\n     }\n-    \n+\n done:\n   dtp->u.p.at_eol = (c == '\\n' || c == EOF);\n   return c;\n@@ -254,7 +246,7 @@ next_char_internal (st_parameter_dt *dtp)\n \t  record = next_array_record (dtp, dtp->u.p.current_unit->ls,\n \t\t\t\t      &finished);\n \n-\t  /* Check for \"end-of-file\" condition.  */      \n+\t  /* Check for \"end-of-file\" condition.  */\n \t  if (finished)\n \t    {\n \t      dtp->u.p.at_eof = 1;\n@@ -289,17 +281,17 @@ next_char_internal (st_parameter_dt *dtp)\n \n   if (is_array_io (dtp))\n     {\n-      /* Check whether we hit EOF.  */ \n+      /* Check whether we hit EOF.  */\n       if (unlikely (length == 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t  return '\\0';\n-\t} \n+\t}\n       dtp->u.p.current_unit->bytes_left--;\n     }\n   else\n     {\n-      if (dtp->u.p.at_eof) \n+      if (dtp->u.p.at_eof)\n \treturn EOF;\n       if (length == 0)\n \t{\n@@ -316,7 +308,7 @@ next_char_internal (st_parameter_dt *dtp)\n \n /* Worker function for UTF encoded files.  */\n static int\n-next_char_utf8 (st_parameter_dt *dtp) \n+next_char_utf8 (st_parameter_dt *dtp)\n {\n   static const uchar masks[6] = { 0x7F, 0x1F, 0x0F, 0x07, 0x02, 0x01 };\n   static const uchar patns[6] = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n@@ -336,7 +328,7 @@ next_char_utf8 (st_parameter_dt *dtp)\n     if ((c & ~masks[nb-1]) == patns[nb-1])\n       goto found;\n   goto invalid;\n-\t\n+\n  found:\n   c = (c & masks[nb-1]);\n \n@@ -363,7 +355,7 @@ next_char_utf8 (st_parameter_dt *dtp)\n utf_done:\n   dtp->u.p.at_eol = (c == '\\n' || c == (gfc_char4_t) EOF);\n   return (int) c;\n-      \n+\n  invalid:\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, \"Invalid UTF-8 encoding\");\n   return (gfc_char4_t) '?';\n@@ -457,7 +449,7 @@ eat_line (st_parameter_dt *dtp)\n    separator, we stop reading.  If there are more input items, we\n    continue reading the separator with finish_separator() which takes\n    care of the fact that we may or may not have seen a comma as part\n-   of the separator. \n+   of the separator.\n \n    Returns 0 for success, and non-zero error code otherwise.  */\n \n@@ -521,11 +513,9 @@ eat_separator (st_parameter_dt *dtp)\n       break;\n \n     case '!':\n+      /* Eat a namelist comment.  */\n       if (dtp->u.p.namelist_mode)\n-\t{\t\t\t/* Eat a namelist comment.  */\n-\t  notify_std (&dtp->common, GFC_STD_GNU,\n-\t\t      \"'!' in namelist is not a valid separator,\"\n-\t\t      \" try inserting a space\");\n+\t{\n \t  err = eat_line (dtp);\n \t  if (err)\n \t    return err;\n@@ -789,7 +779,7 @@ parse_repeat (st_parameter_dt *dtp)\n \n \n /* To read a logical we have to look ahead in the input stream to make sure\n-    there is not an equal sign indicating a variable name.  To do this we use \n+    there is not an equal sign indicating a variable name.  To do this we use\n     line_buffer to point to a temporary buffer, pushing characters there for\n     possible later reading. */\n \n@@ -855,6 +845,10 @@ read_logical (st_parameter_dt *dtp, int length)\n \n       break;\n \n+    case '!':\n+      if (!dtp->u.p.namelist_mode)\n+        goto bad_logical;\n+\n     CASE_SEPARATORS:\n     case EOF:\n       unget_char (dtp, c);\n@@ -903,7 +897,7 @@ read_logical (st_parameter_dt *dtp, int length)\n \t      goto logical_done;\n \t    }\n \t}\n- \n+\n       l_push_char (dtp, c);\n       if (c == '=')\n \t{\n@@ -912,7 +906,7 @@ read_logical (st_parameter_dt *dtp, int length)\n \t  dtp->u.p.line_buffer_pos = 0;\n \t  return;\n \t}\n-      \n+\n     }\n \n  bad_logical:\n@@ -974,6 +968,10 @@ read_integer (st_parameter_dt *dtp, int length)\n \tgoto bad_integer;\n       goto get_integer;\n \n+    case '!':\n+      if (!dtp->u.p.namelist_mode)\n+        goto bad_integer;\n+\n     CASE_SEPARATORS:\t\t/* Single null.  */\n       unget_char (dtp, c);\n       eat_separator (dtp);\n@@ -1002,6 +1000,10 @@ read_integer (st_parameter_dt *dtp, int length)\n \t  push_char (dtp, '\\0');\n \t  goto repeat;\n \n+\tcase '!':\n+\t  if (!dtp->u.p.namelist_mode)\n+\t    goto bad_integer;\n+\n \tCASE_SEPARATORS:\t/* Not a repeat count.  */\n \tcase EOF:\n \t  goto done;\n@@ -1024,6 +1026,10 @@ read_integer (st_parameter_dt *dtp, int length)\n     CASE_DIGITS:\n       break;\n \n+    case '!':\n+      if (!dtp->u.p.namelist_mode)\n+        goto bad_integer;\n+\n     CASE_SEPARATORS:\n       unget_char (dtp, c);\n       eat_separator (dtp);\n@@ -1052,6 +1058,10 @@ read_integer (st_parameter_dt *dtp, int length)\n \t  push_char (dtp, c);\n \t  break;\n \n+\tcase '!':\n+\t  if (!dtp->u.p.namelist_mode)\n+\t    goto bad_integer;\n+\n \tCASE_SEPARATORS:\n \tcase EOF:\n \t  goto done;\n@@ -1066,7 +1076,7 @@ read_integer (st_parameter_dt *dtp, int length)\n   if (nml_bad_return (dtp, c))\n     return;\n \n-  free_saved (dtp);  \n+  free_saved (dtp);\n   if (c == EOF)\n     {\n       free_line (dtp);\n@@ -1204,32 +1214,32 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n \t      push_char (dtp, c);\n \t      break;\n \t    }\n-  \n+\n \t  /* See if we have a doubled quote character or the end of\n \t     the string.  */\n-  \n+\n \t  if ((c = next_char (dtp)) == EOF)\n \t    goto done_eof;\n \t  if (c == quote)\n \t    {\n \t      push_char (dtp, quote);\n \t      break;\n \t    }\n-  \n+\n \t  unget_char (dtp, c);\n \t  goto done;\n-  \n+\n \tCASE_SEPARATORS:\n \t  if (quote == ' ')\n \t    {\n \t      unget_char (dtp, c);\n \t      goto done;\n \t    }\n-  \n+\n \t  if (c != '\\n' && c != '\\r')\n \t    push_char (dtp, c);\n \t  break;\n-  \n+\n \tdefault:\n \t  push_char (dtp, c);\n \t  break;\n@@ -1241,13 +1251,13 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n  done:\n   c = next_char (dtp);\n  done_eof:\n-  if (is_separator (c) || c == '!' || c == EOF)\n+  if (is_separator (c) || c == EOF)\n     {\n       unget_char (dtp, c);\n       eat_separator (dtp);\n       dtp->u.p.saved_type = BT_CHARACTER;\n     }\n-  else \n+  else\n     {\n       free_saved (dtp);\n       snprintf (message, MSGLEN, \"Invalid string input in item %d\",\n@@ -1275,7 +1285,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \n   if ((c = next_char (dtp)) == EOF)\n     goto bad;\n-    \n+\n   if (c == '-' || c == '+')\n     {\n       push_char (dtp, c);\n@@ -1285,7 +1295,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \n   if (c == ',' && dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA)\n     c = '.';\n-  \n+\n   if (!isdigit (c) && c != '.')\n     {\n       if (c == 'i' || c == 'I' || c == 'n' || c == 'N')\n@@ -1335,6 +1345,10 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \t    goto bad;\n \t  goto exp2;\n \n+\tcase '!':\n+\t  if (!dtp->u.p.namelist_mode)\n+\t    goto bad;\n+\n \tCASE_SEPARATORS:\n \tcase EOF:\n \t  goto done;\n@@ -1371,6 +1385,10 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n \t  push_char (dtp, c);\n \t  break;\n \n+\tcase '!':\n+\t  if (!dtp->u.p.namelist_mode)\n+\t    goto bad;\n+\n \tCASE_SEPARATORS:\n \tcase EOF:\n \t  unget_char (dtp, c);\n@@ -1431,7 +1449,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n       push_char (dtp, 'n');\n       push_char (dtp, 'a');\n       push_char (dtp, 'n');\n-      \n+\n       /* Match \"NAN(alphanum)\".  */\n       if (c == '(')\n \t{\n@@ -1488,6 +1506,10 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n     case '(':\n       break;\n \n+    case '!':\n+      if (!dtp->u.p.namelist_mode)\n+\tgoto bad_complex;\n+\n     CASE_SEPARATORS:\n     case EOF:\n       unget_char (dtp, c);\n@@ -1531,7 +1553,7 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n \n   if (parse_real (dtp, dest + size / 2, kind))\n     return;\n-    \n+\n eol_4:\n   eat_spaces (dtp);\n   c = next_char (dtp);\n@@ -1566,7 +1588,7 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n       hit_eof (dtp);\n       return;\n     }\n-  else if (c != '\\n')   \n+  else if (c != '\\n')\n     eat_line (dtp);\n \n   snprintf (message, MSGLEN, \"Bad complex value in item %d of list input\",\n@@ -1606,6 +1628,10 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n     case '-':\n       goto got_sign;\n \n+    case '!':\n+      if (!dtp->u.p.namelist_mode)\n+\tgoto bad_real;\n+\n     CASE_SEPARATORS:\n       unget_char (dtp, c);\t\t/* Single null.  */\n       eat_separator (dtp);\n@@ -1661,6 +1687,10 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n \t  push_char (dtp, '\\0');\n \t  goto got_repeat;\n \n+\tcase '!':\n+\t  if (!dtp->u.p.namelist_mode)\n+\t    goto bad_real;\n+\n \tCASE_SEPARATORS:\n \tcase EOF:\n           if (c != '\\n' && c != ',' && c != '\\r' && c != ';')\n@@ -1730,6 +1760,10 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n \t  push_char (dtp, c);\n \t  break;\n \n+\tcase '!':\n+\t  if (!dtp->u.p.namelist_mode)\n+\t    goto bad_real;\n+\n \tCASE_SEPARATORS:\n \tcase EOF:\n \t  goto done;\n@@ -1790,6 +1824,10 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n \t  push_char (dtp, c);\n \t  break;\n \n+\tcase '!':\n+\t  if (!dtp->u.p.namelist_mode)\n+\t    goto bad_real;\n+\n \tCASE_SEPARATORS:\n \tcase EOF:\n \t  goto done;\n@@ -1887,7 +1925,7 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n     goto unwind;\n \n   if (dtp->u.p.namelist_mode)\n-    {\t\n+    {\n       if (c == ' ' || c =='\\n' || c == '\\r')\n \t{\n \t  do\n@@ -2046,7 +2084,7 @@ list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p,\n       dtp->u.p.input_complete = 0;\n       dtp->u.p.repeat_count = 1;\n       dtp->u.p.at_eol = 0;\n-      \n+\n       if ((c = eat_spaces (dtp)) == EOF)\n \t{\n \t  err = LIBERROR_END;\n@@ -2080,7 +2118,7 @@ list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p,\n \t    return err;\n \t  goto set_value;\n \t}\n-\t\n+\n       if (dtp->u.p.input_complete)\n \tgoto cleanup;\n \n@@ -2219,7 +2257,7 @@ list_formatted_read (st_parameter_dt *dtp, bt type, void *p, int kind,\n   for (elem = 0; elem < nelems; elem++)\n     {\n       dtp->u.p.item_count++;\n-      err = list_formatted_read_scalar (dtp, type, tmp + stride*elem, \n+      err = list_formatted_read_scalar (dtp, type, tmp + stride*elem,\n \t\t\t\t\tkind, size);\n       if (err)\n \tbreak;\n@@ -2362,10 +2400,10 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t      || (c==')' && dim < rank -1))\n \t\t    {\n \t\t      if (is_char)\n-\t\t        snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t        snprintf (parse_err_msg, parse_err_msg_size,\n \t\t\t\t  \"Bad substring qualifier\");\n \t\t      else\n-\t\t\tsnprintf (parse_err_msg, parse_err_msg_size, \n+\t\t\tsnprintf (parse_err_msg, parse_err_msg_size,\n \t\t\t\t \"Bad number of index fields\");\n \t\t      goto err_ret;\n \t\t    }\n@@ -2384,7 +2422,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t    snprintf (parse_err_msg, parse_err_msg_size,\n \t\t\t     \"Bad character in substring qualifier\");\n \t\t  else\n-\t\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t    snprintf (parse_err_msg, parse_err_msg_size,\n \t\t\t      \"Bad character in index\");\n \t\t  goto err_ret;\n \t\t}\n@@ -2393,10 +2431,10 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t  && dtp->u.p.saved_string == 0)\n \t\t{\n \t\t  if (is_char)\n-\t\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t    snprintf (parse_err_msg, parse_err_msg_size,\n \t\t\t      \"Null substring qualifier\");\n \t\t  else\n-\t\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t    snprintf (parse_err_msg, parse_err_msg_size,\n \t\t\t      \"Null index field\");\n \t\t  goto err_ret;\n \t\t}\n@@ -2405,7 +2443,7 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t\t  || (indx == 2 && dtp->u.p.saved_string == 0))\n \t\t{\n \t\t  if (is_char)\n-\t\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t\t    snprintf (parse_err_msg, parse_err_msg_size,\n \t\t\t      \"Bad substring qualifier\");\n \t\t  else\n \t\t    snprintf (parse_err_msg, parse_err_msg_size,\n@@ -2494,18 +2532,18 @@ nml_parse_qualifier (st_parameter_dt *dtp, descriptor_dimension *ad,\n \t   || (ls[dim].end < GFC_DIMENSION_LBOUND(ad[dim])))\n \t{\n \t  if (is_char)\n-\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t    snprintf (parse_err_msg, parse_err_msg_size,\n \t\t      \"Substring out of range\");\n \t  else\n-\t    snprintf (parse_err_msg, parse_err_msg_size, \n+\t    snprintf (parse_err_msg, parse_err_msg_size,\n \t\t      \"Index %d out of range\", dim + 1);\n \t  goto err_ret;\n \t}\n \n       if (((ls[dim].end - ls[dim].start ) * ls[dim].step < 0)\n \t  || (ls[dim].step == 0))\n \t{\n-\t  snprintf (parse_err_msg, parse_err_msg_size, \n+\t  snprintf (parse_err_msg, parse_err_msg_size,\n \t\t   \"Bad range in index %d\", dim + 1);\n \t  goto err_ret;\n \t}\n@@ -2548,7 +2586,7 @@ static bool\n strcmp_extended_type (char *p, char *q)\n {\n   char *r, *s;\n-  \n+\n   for (r = p, s = q; *r && *s; r++, s++)\n     {\n       if (*r != *s)\n@@ -3056,7 +3094,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \tgoto nml_err_ret;\n       if (c != '?')\n \t{\n-\t  snprintf (nml_err_msg, nml_err_msg_size, \n+\t  snprintf (nml_err_msg, nml_err_msg_size,\n \t\t    \"namelist read: misplaced = sign\");\n \t  goto nml_err_ret;\n \t}\n@@ -3072,7 +3110,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n       nml_match_name (dtp, \"end\", 3);\n       if (dtp->u.p.nml_read_error)\n \t{\n-\t  snprintf (nml_err_msg, nml_err_msg_size, \n+\t  snprintf (nml_err_msg, nml_err_msg_size,\n \t\t    \"namelist not terminated with / or &end\");\n \t  goto nml_err_ret;\n \t}\n@@ -3367,7 +3405,7 @@ namelist_read (st_parameter_dt *dtp)\n   dtp->u.p.namelist_mode = 1;\n   dtp->u.p.input_complete = 0;\n   dtp->u.p.expanded_read = 0;\n-  \n+\n   /* Set the next_char and push_char worker functions.  */\n   set_workers (dtp);\n \n@@ -3413,7 +3451,7 @@ namelist_read (st_parameter_dt *dtp)\n   if (dtp->u.p.nml_read_error)\n     goto find_nml_name;\n \n-  /* A trailing space is required, we give a little latitude here, 10.9.1.  */ \n+  /* A trailing space is required, we give a little latitude here, 10.9.1.  */\n   c = next_char (dtp);\n   if (!is_separator(c) && c != '!')\n     {"}]}