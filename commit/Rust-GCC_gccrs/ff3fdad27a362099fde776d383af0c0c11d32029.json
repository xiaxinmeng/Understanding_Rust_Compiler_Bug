{"sha": "ff3fdad27a362099fde776d383af0c0c11d32029", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYzZmRhZDI3YTM2MjA5OWZkZTc3NmQzODNhZjBjMGMxMWQzMjAyOQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-12-07T20:24:09Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-12-07T20:24:09Z"}, "message": "tree-ssa-pre.c (bitmap_set_and): New function.\n\n2005-12-07  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-pre.c (bitmap_set_and): New function.\n\t(bitmap_set_and_compl): New function.\n\t(bitmap_set_empty_p): New function.\n\t(insert_extra_phis): New function.\n\t(compute_avail): Use insert_extra_phis.\n\nFrom-SVN: r108183", "tree": {"sha": "ad7ffdd358071c95998ff4dab0541121b1568e24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad7ffdd358071c95998ff4dab0541121b1568e24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff3fdad27a362099fde776d383af0c0c11d32029", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff3fdad27a362099fde776d383af0c0c11d32029", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff3fdad27a362099fde776d383af0c0c11d32029", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff3fdad27a362099fde776d383af0c0c11d32029/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45d18331f6fef4363e14fd19871ef765d1203472", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d18331f6fef4363e14fd19871ef765d1203472", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d18331f6fef4363e14fd19871ef765d1203472"}], "stats": {"total": 135, "additions": 135, "deletions": 0}, "files": [{"sha": "cdf18d67e55f81eec1d100f07fe8f65a6b90b0a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3fdad27a362099fde776d383af0c0c11d32029/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3fdad27a362099fde776d383af0c0c11d32029/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff3fdad27a362099fde776d383af0c0c11d32029", "patch": "@@ -1,3 +1,11 @@\n+2005-12-07  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-pre.c (bitmap_set_and): New function.\n+\t(bitmap_set_and_compl): New function.\n+\t(bitmap_set_empty_p): New function.\n+\t(insert_extra_phis): New function.\n+\t(compute_avail): Use insert_extra_phis.\n+\n 2005-12-07  Adrian Straetling  <straetling@de.ibm.com>\n \n \t* config/s390/s390.c (s390_expand_atomic): New function."}, {"sha": "7c1fde8d7bde689d5a114d2431694e4a992eac17", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3fdad27a362099fde776d383af0c0c11d32029/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3fdad27a362099fde776d383af0c0c11d32029/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=ff3fdad27a362099fde776d383af0c0c11d32029", "patch": "@@ -555,6 +555,55 @@ bitmap_set_copy (bitmap_set_t dest, bitmap_set_t orig)\n   bitmap_copy (dest->values, orig->values);\n }\n \n+/* Perform bitmapped set rperation DEST &= ORIG.  */\n+\n+static void\n+bitmap_set_and (bitmap_set_t dest, bitmap_set_t orig)\n+{\n+  bitmap_iterator bi;\n+  unsigned int i;\n+  bitmap temp = BITMAP_ALLOC (&grand_bitmap_obstack);\n+\n+  bitmap_and_into (dest->values, orig->values);\n+  bitmap_copy (temp, dest->expressions);\n+  EXECUTE_IF_SET_IN_BITMAP (temp, 0, i, bi)\n+    {\n+      tree name = ssa_name (i);\n+      tree val = get_value_handle (name);\n+      if (!bitmap_bit_p (dest->values, VALUE_HANDLE_ID (val)))\n+\tbitmap_clear_bit (dest->expressions, i);\n+    }\n+\n+}\n+\n+/* Perform bitmapped value set operation DEST = DEST & ~ORIG.  */\n+\n+static void\n+bitmap_set_and_compl (bitmap_set_t dest, bitmap_set_t orig)\n+{\n+  bitmap_iterator bi;\n+  unsigned int i;\n+  bitmap temp = BITMAP_ALLOC (&grand_bitmap_obstack);\n+\n+  bitmap_and_compl_into (dest->values, orig->values);\n+  bitmap_copy (temp, dest->expressions);\n+  EXECUTE_IF_SET_IN_BITMAP (temp, 0, i, bi)\n+    {\n+      tree name = ssa_name (i);\n+      tree val = get_value_handle (name);\n+      if (!bitmap_bit_p (dest->values, VALUE_HANDLE_ID (val)))\n+\tbitmap_clear_bit (dest->expressions, i);\n+    }\n+}\n+\n+/* Return true if the bitmap set SET is empty.  */\n+\n+static bool\n+bitmap_set_empty_p (bitmap_set_t set)\n+{\n+  return bitmap_empty_p (set->values);\n+}\n+\n /* Copy the set ORIG to the set DEST.  */\n \n static void\n@@ -2136,6 +2185,81 @@ can_value_number_call (tree stmt)\n   return false;\n }\n \n+/* Insert extra phis to merge values that are fully available from\n+   preds of BLOCK, but have no dominating representative coming from\n+   block DOM.   */\n+\n+static void\n+insert_extra_phis (basic_block block, basic_block dom)\n+{\n+  \n+  if (!single_pred_p (block))\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      bool first = true;\n+      bitmap_set_t tempset = bitmap_set_new ();\n+\n+      FOR_EACH_EDGE (e, ei, block->preds)\n+\t{\n+\t  if (first)\n+\t    {\n+\t      bitmap_set_copy (tempset, AVAIL_OUT (e->src));\n+\t      first = false;\n+\t    }\n+\t  else\n+\t    bitmap_set_and (tempset, AVAIL_OUT (e->src));\n+\t}\n+\n+      if (dom)\n+\tbitmap_set_and_compl (tempset, AVAIL_OUT (dom));\n+\n+      if (!bitmap_set_empty_p (tempset))\n+\t{\n+\t  unsigned int i;\n+\t  bitmap_iterator bi;\n+\n+\t  EXECUTE_IF_SET_IN_BITMAP (tempset->expressions, 0, i, bi)\n+\t    {\n+\t      tree name = ssa_name (i);\n+\t      tree val = get_value_handle (name);\n+\t      tree temp = create_tmp_var (TREE_TYPE (name), \"mergephitmp\");\n+\t\t  \n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"Creating phi \");\n+\t\t  print_generic_expr (dump_file, temp, 0);\n+\t\t  fprintf (dump_file, \" to merge available but not dominating values \");\n+\t\t}\n+\n+\t      add_referenced_tmp_var (temp);\n+\t      temp = create_phi_node (temp, block);\n+\t      NECESSARY (temp) = 0; \n+\t      VEC_safe_push (tree, heap, inserted_exprs, temp);\n+\n+\t      FOR_EACH_EDGE (e, ei, block->preds)\n+\t\t{\n+\t\t  tree leader = bitmap_find_leader (AVAIL_OUT (e->src), val);\n+\t\t  \n+\t\t  gcc_assert (leader);\n+\t\t  add_phi_arg (temp, leader, e);\n+\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      print_generic_expr (dump_file, leader, 0);\n+\t\t      fprintf (dump_file, \" in block %d,\", e->src->index);\n+\t\t    }\n+\t\t}\n+\n+\t      vn_add (PHI_RESULT (temp), val, NULL);\n+\t      \n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"\\n\");\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Given a statement STMT and its right hand side which is a load, try\n    to look for the expression stored in the location for the load, and\n    return true if a useful equivalence was recorded for LHS.  */\n@@ -2266,6 +2390,9 @@ compute_avail (void)\n       if (dom)\n \tbitmap_set_copy (AVAIL_OUT (block), AVAIL_OUT (dom));\n \n+      if (!in_fre)\n+\tinsert_extra_phis (block, dom);\n+\n       /* Generate values for PHI nodes.  */\n       for (phi = phi_nodes (block); phi; phi = PHI_CHAIN (phi))\n \t/* We have no need for virtual phis, as they don't represent"}]}