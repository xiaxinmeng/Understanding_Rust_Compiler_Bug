{"sha": "4fc5ebf12924235c9b88a2c645624bc8b1ea266c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZjNWViZjEyOTI0MjM1YzliODhhMmM2NDU2MjRiYzhiMWVhMjY2Yw==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2017-05-16T20:18:05Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2017-05-16T20:18:05Z"}, "message": "re PR tree-optimization/80457 (vectorizable_condition does not update the vectorizer cost model)\n\n[gcc]\n\n2017-05-16  James Greenhalgh  <james.greenhalgh@arm.com>\n\t    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/80457\n\t* tree-vect-stmts.c (vect_model_simple_cost): Model the cost\n\tof all arguments to a statement as scalar_to_vec operations.\n\t(vectorizable_call): Adjust call to vect_model_simple_cost for\n\tnew parameter.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_comparison): Likewise.\n\t(vect_is_simple_cond): Record the def types for operands.\n\t(vectorizable_condition): Likewise, call vect_model_simple_cost.\n\t* tree-vectorizer.h (vect_model_simple_cost): Add new parameter\n\tfor statement argument count.\n\n[gcc/testsuite]\n\n2017-05-16  James Greenhalgh  <james.greenhalgh@arm.com>\n\t    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/80457\n\t* gcc.target/powerpc/pr78604.c: Verify that vectorized COND_EXPRs\n\tcall vect_model_simple_cost.\n\n\nCo-Authored-By: Bill Schmidt <wschmidt@linux.vnet.ibm.com>\n\nFrom-SVN: r248130", "tree": {"sha": "10188067ad9955e728e5cf75a7076e0a75af421a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10188067ad9955e728e5cf75a7076e0a75af421a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fc5ebf12924235c9b88a2c645624bc8b1ea266c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc5ebf12924235c9b88a2c645624bc8b1ea266c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fc5ebf12924235c9b88a2c645624bc8b1ea266c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc5ebf12924235c9b88a2c645624bc8b1ea266c/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bedee914ca77688f4c2d9138216b3a3b84fbb619", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bedee914ca77688f4c2d9138216b3a3b84fbb619", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bedee914ca77688f4c2d9138216b3a3b84fbb619"}], "stats": {"total": 103, "additions": 76, "deletions": 27}, "files": [{"sha": "25a2d3b6a908a165ddd1b5c26d77023ce57d0a73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc5ebf12924235c9b88a2c645624bc8b1ea266c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc5ebf12924235c9b88a2c645624bc8b1ea266c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fc5ebf12924235c9b88a2c645624bc8b1ea266c", "patch": "@@ -1,3 +1,21 @@\n+2017-05-16  James Greenhalgh  <james.greenhalgh@arm.com>\n+\t    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/80457\n+\t* tree-vect-stmts.c (vect_model_simple_cost): Model the cost\n+\tof all arguments to a statement as scalar_to_vec operations.\n+\t(vectorizable_call): Adjust call to vect_model_simple_cost for\n+\tnew parameter.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_comparison): Likewise.\n+\t(vect_is_simple_cond): Record the def types for operands.\n+\t(vectorizable_condition): Likewise, call vect_model_simple_cost.\n+\t* tree-vectorizer.h (vect_model_simple_cost): Add new parameter\n+\tfor statement argument count.\n+\n 2017-05-16  Carl Love  <cel@us.ibm.com>\n \n \t* config/rs6000/rs6000-c: Add support for built-in functions"}, {"sha": "9572cc49ba98aaf96ee845f4d00f5647892ad913", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc5ebf12924235c9b88a2c645624bc8b1ea266c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc5ebf12924235c9b88a2c645624bc8b1ea266c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4fc5ebf12924235c9b88a2c645624bc8b1ea266c", "patch": "@@ -1,3 +1,10 @@\n+2017-05-16  James Greenhalgh  <james.greenhalgh@arm.com>\n+\t    Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/80457\n+\t* gcc.target/powerpc/pr78604.c: Verify that vectorized COND_EXPRs\n+\tcall vect_model_simple_cost.\n+\n 2017-05-16  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/80554"}, {"sha": "757328e1a55d70ef01cda5cd910c30b14d598ee1", "filename": "gcc/testsuite/gcc.target/powerpc/pr78604.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc5ebf12924235c9b88a2c645624bc8b1ea266c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr78604.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc5ebf12924235c9b88a2c645624bc8b1ea266c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr78604.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr78604.c?ref=4fc5ebf12924235c9b88a2c645624bc8b1ea266c", "patch": "@@ -2,7 +2,7 @@\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n-/* { dg-options \"-mcpu=power8 -O2 -ftree-vectorize\" } */\n+/* { dg-options \"-mcpu=power8 -O2 -ftree-vectorize -fdump-tree-details\" } */\n \n #ifndef SIZE\n #define SIZE 1024\n@@ -110,3 +110,4 @@ uns_gte (UNS_TYPE val1, UNS_TYPE val2)\n /* { dg-final { scan-assembler-times {\\mvcmpgtsd\\M} 4 } } */\n /* { dg-final { scan-assembler-times {\\mvcmpgtud\\M} 4 } } */\n /* { dg-final { scan-assembler-not   {\\mvcmpequd\\M} } } */\n+/* { dg-final { scan-tree-dump-times \"vect_model_simple_cost\" 8 \"vect\" } } */"}, {"sha": "74c9a113082893c700c688b2ab14be87111b95a7", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc5ebf12924235c9b88a2c645624bc8b1ea266c/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc5ebf12924235c9b88a2c645624bc8b1ea266c/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=4fc5ebf12924235c9b88a2c645624bc8b1ea266c", "patch": "@@ -801,6 +801,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n void\n vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t\tenum vect_def_type *dt,\n+\t\t\tint ndts,\n \t\t\tstmt_vector_for_cost *prologue_cost_vec,\n \t\t\tstmt_vector_for_cost *body_cost_vec)\n {\n@@ -811,10 +812,12 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n   if (PURE_SLP_STMT (stmt_info))\n     return;\n \n-  /* FORNOW: Assuming maximum 2 args per stmts.  */\n-  for (i = 0; i < 2; i++)\n+  /* Cost the \"broadcast\" of a scalar operand in to a vector operand.\n+     Use scalar_to_vec to cost the broadcast, as elsewhere in the vector\n+     cost model.  */\n+  for (i = 0; i < ndts; i++)\n     if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n-      prologue_cost += record_stmt_cost (prologue_cost_vec, 1, vector_stmt,\n+      prologue_cost += record_stmt_cost (prologue_cost_vec, 1, scalar_to_vec,\n \t\t\t\t\t stmt_info, 0, vect_prologue);\n \n   /* Pass the inside-of-loop statements to the target-specific cost model.  */\n@@ -2601,6 +2604,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   gimple *def_stmt;\n   enum vect_def_type dt[3]\n     = {vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type};\n+  int ndts = 3;\n   gimple *new_stmt = NULL;\n   int ncopies, j;\n   vec<tree> vargs = vNULL;\n@@ -2806,7 +2810,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_call ===\"\n                          \"\\n\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n       if (ifn != IFN_LAST && modifier == NARROW && !slp_node)\n \tadd_stmt_cost (stmt_info->vinfo->target_cost_data, ncopies / 2,\n \t\t       vec_promote_demote, stmt_info, 0, vect_body);\n@@ -4025,6 +4029,7 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree new_temp;\n   gimple *def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n+  int ndts = 2;\n   gimple *new_stmt = NULL;\n   stmt_vec_info prev_stmt_info;\n   int nunits_in;\n@@ -4303,7 +4308,7 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (code == FIX_TRUNC_EXPR || code == FLOAT_EXPR)\n         {\n \t  STMT_VINFO_TYPE (stmt_info) = type_conversion_vec_info_type;\n-\t  vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n+\t  vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n \t}\n       else if (modifier == NARROW)\n \t{\n@@ -4612,7 +4617,8 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree new_temp;\n   gimple *def_stmt;\n-  enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n+  enum vect_def_type dt[1] = {vect_unknown_def_type};\n+  int ndts = 1;\n   int ncopies;\n   int i, j;\n   vec<tree> vec_oprnds = vNULL;\n@@ -4712,7 +4718,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_assignment ===\\n\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n       return true;\n     }\n \n@@ -4824,6 +4830,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n   machine_mode optab_op2_mode;\n   gimple *def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n+  int ndts = 2;\n   gimple *new_stmt = NULL;\n   stmt_vec_info prev_stmt_info;\n   int nunits_in;\n@@ -5082,7 +5089,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_shift ===\\n\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n       return true;\n     }\n \n@@ -5198,6 +5205,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   gimple *def_stmt;\n   enum vect_def_type dt[3]\n     = {vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type};\n+  int ndts = 3;\n   gimple *new_stmt = NULL;\n   stmt_vec_info prev_stmt_info;\n   int nunits_in;\n@@ -5409,7 +5417,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_operation ===\\n\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n       return true;\n     }\n \n@@ -7661,15 +7669,16 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n    Output:\n    *COMP_VECTYPE - the vector type for the comparison.\n+   *DTS - The def types for the arguments of the comparison\n \n    Returns whether a COND can be vectorized.  Checks whether\n    condition operands are supportable using vec_is_simple_use.  */\n \n static bool\n-vect_is_simple_cond (tree cond, vec_info *vinfo, tree *comp_vectype)\n+vect_is_simple_cond (tree cond, vec_info *vinfo,\n+\t\t     tree *comp_vectype, enum vect_def_type *dts)\n {\n   tree lhs, rhs;\n-  enum vect_def_type dt;\n   tree vectype1 = NULL_TREE, vectype2 = NULL_TREE;\n \n   /* Mask case.  */\n@@ -7678,7 +7687,7 @@ vect_is_simple_cond (tree cond, vec_info *vinfo, tree *comp_vectype)\n     {\n       gimple *lhs_def_stmt = SSA_NAME_DEF_STMT (cond);\n       if (!vect_is_simple_use (cond, vinfo, &lhs_def_stmt,\n-\t\t\t       &dt, comp_vectype)\n+\t\t\t       &dts[0], comp_vectype)\n \t  || !*comp_vectype\n \t  || !VECTOR_BOOLEAN_TYPE_P (*comp_vectype))\n \treturn false;\n@@ -7694,21 +7703,25 @@ vect_is_simple_cond (tree cond, vec_info *vinfo, tree *comp_vectype)\n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n       gimple *lhs_def_stmt = SSA_NAME_DEF_STMT (lhs);\n-      if (!vect_is_simple_use (lhs, vinfo, &lhs_def_stmt, &dt, &vectype1))\n+      if (!vect_is_simple_use (lhs, vinfo, &lhs_def_stmt, &dts[0], &vectype1))\n \treturn false;\n     }\n-  else if (TREE_CODE (lhs) != INTEGER_CST && TREE_CODE (lhs) != REAL_CST\n-\t   && TREE_CODE (lhs) != FIXED_CST)\n+  else if (TREE_CODE (lhs) == INTEGER_CST || TREE_CODE (lhs) == REAL_CST\n+\t   || TREE_CODE (lhs) == FIXED_CST)\n+    dts[0] = vect_constant_def;\n+  else\n     return false;\n \n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n       gimple *rhs_def_stmt = SSA_NAME_DEF_STMT (rhs);\n-      if (!vect_is_simple_use (rhs, vinfo, &rhs_def_stmt, &dt, &vectype2))\n+      if (!vect_is_simple_use (rhs, vinfo, &rhs_def_stmt, &dts[1], &vectype2))\n \treturn false;\n     }\n-  else if (TREE_CODE (rhs) != INTEGER_CST && TREE_CODE (rhs) != REAL_CST\n-\t   && TREE_CODE (rhs) != FIXED_CST)\n+  else if (TREE_CODE (rhs) == INTEGER_CST || TREE_CODE (rhs) == REAL_CST\n+\t   || TREE_CODE (rhs) == FIXED_CST)\n+    dts[1] = vect_constant_def;\n+  else\n     return false;\n \n   if (vectype1 && vectype2\n@@ -7748,7 +7761,10 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree vec_compare;\n   tree new_temp;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  enum vect_def_type dt, dts[4];\n+  enum vect_def_type dts[4]\n+    = {vect_unknown_def_type, vect_unknown_def_type,\n+       vect_unknown_def_type, vect_unknown_def_type};\n+  int ndts = 4;\n   int ncopies;\n   enum tree_code code, cond_code, bitop1 = NOP_EXPR, bitop2 = NOP_EXPR;\n   stmt_vec_info prev_stmt_info = NULL;\n@@ -7810,15 +7826,16 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   then_clause = gimple_assign_rhs2 (stmt);\n   else_clause = gimple_assign_rhs3 (stmt);\n \n-  if (!vect_is_simple_cond (cond_expr, stmt_info->vinfo, &comp_vectype)\n+  if (!vect_is_simple_cond (cond_expr, stmt_info->vinfo,\n+\t\t\t    &comp_vectype, &dts[0])\n       || !comp_vectype)\n     return false;\n \n   gimple *def_stmt;\n-  if (!vect_is_simple_use (then_clause, stmt_info->vinfo, &def_stmt, &dt,\n+  if (!vect_is_simple_use (then_clause, stmt_info->vinfo, &def_stmt, &dts[2],\n \t\t\t   &vectype1))\n     return false;\n-  if (!vect_is_simple_use (else_clause, stmt_info->vinfo, &def_stmt, &dt,\n+  if (!vect_is_simple_use (else_clause, stmt_info->vinfo, &def_stmt, &dts[3],\n \t\t\t   &vectype2))\n     return false;\n \n@@ -7902,8 +7919,13 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\treturn false;\n \t    }\n \t}\n-      return expand_vec_cond_expr_p (vectype, comp_vectype,\n-\t\t\t\t     cond_code);\n+      if (expand_vec_cond_expr_p (vectype, comp_vectype,\n+\t\t\t\t     cond_code))\n+\t{\n+\t  vect_model_simple_cost (stmt_info, ncopies, dts, ndts, NULL, NULL);\n+\t  return true;\n+\t}\n+      return false;\n     }\n \n   /* Transform.  */\n@@ -8106,6 +8128,7 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree new_temp;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum vect_def_type dts[2] = {vect_unknown_def_type, vect_unknown_def_type};\n+  int ndts = 2;\n   unsigned nunits;\n   int ncopies;\n   enum tree_code code, bitop1 = NOP_EXPR, bitop2 = NOP_EXPR;\n@@ -8231,7 +8254,7 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n     {\n       STMT_VINFO_TYPE (stmt_info) = comparison_vec_info_type;\n       vect_model_simple_cost (stmt_info, ncopies * (1 + (bitop2 != NOP_EXPR)),\n-\t\t\t      dts, NULL, NULL);\n+\t\t\t      dts, ndts, NULL, NULL);\n       if (bitop1 == NOP_EXPR)\n \treturn expand_vec_cmp_expr_p (vectype, mask_type, code);\n       else"}, {"sha": "c0bc4930605400ff3d311f88aa6961030069288e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc5ebf12924235c9b88a2c645624bc8b1ea266c/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc5ebf12924235c9b88a2c645624bc8b1ea266c/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=4fc5ebf12924235c9b88a2c645624bc8b1ea266c", "patch": "@@ -1079,7 +1079,7 @@ extern bool supportable_narrowing_operation (enum tree_code, tree, tree,\n extern stmt_vec_info new_stmt_vec_info (gimple *stmt, vec_info *);\n extern void free_stmt_vec_info (gimple *stmt);\n extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *,\n-                                    stmt_vector_for_cost *,\n+\t\t\t\t    int, stmt_vector_for_cost *,\n \t\t\t\t    stmt_vector_for_cost *);\n extern void vect_model_store_cost (stmt_vec_info, int, vect_memory_access_type,\n \t\t\t\t   enum vect_def_type, slp_tree,"}]}