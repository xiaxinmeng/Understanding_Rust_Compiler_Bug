{"sha": "e5c617ff163919020a7125ec43c0b59f84275486", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVjNjE3ZmYxNjM5MTkwMjBhNzEyNWVjNDNjMGI1OWY4NDI3NTQ4Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-02-19T13:27:36Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-02-19T13:27:36Z"}, "message": "sibcall.c (call_ends_block_p): New function.\n\n\t* sibcall.c (call_ends_block_p): New function.\n\t(optimize_sibling_and_tail_recursive_call): Use it.\n\nFrom-SVN: r39879", "tree": {"sha": "8b56fc13031f5629cdb8d97aea8e31316e907a1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b56fc13031f5629cdb8d97aea8e31316e907a1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5c617ff163919020a7125ec43c0b59f84275486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c617ff163919020a7125ec43c0b59f84275486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5c617ff163919020a7125ec43c0b59f84275486", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c617ff163919020a7125ec43c0b59f84275486/comments", "author": null, "committer": null, "parents": [{"sha": "2091638a5f9c9625c4c41dda3c33edd0f312dcac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2091638a5f9c9625c4c41dda3c33edd0f312dcac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2091638a5f9c9625c4c41dda3c33edd0f312dcac"}], "stats": {"total": 123, "additions": 69, "deletions": 54}, "files": [{"sha": "be525f1a1ba2a2ff623de1396e5347dfc16b9ef4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c617ff163919020a7125ec43c0b59f84275486/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c617ff163919020a7125ec43c0b59f84275486/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5c617ff163919020a7125ec43c0b59f84275486", "patch": "@@ -1,3 +1,8 @@\n+Mon Feb 19 08:27:21 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* sibcall.c (call_ends_block_p): New function.\n+\t(optimize_sibling_and_tail_recursive_call): Use it.\n+\n 2001-02-18  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/h8300/h8300.md: Update copyright."}, {"sha": "c599a8eac1895ce64c50545c6f75b25ad12a7823", "filename": "gcc/sibcall.c", "status": "modified", "additions": 64, "deletions": 54, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c617ff163919020a7125ec43c0b59f84275486/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c617ff163919020a7125ec43c0b59f84275486/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=e5c617ff163919020a7125ec43c0b59f84275486", "patch": "@@ -1,5 +1,5 @@\n /* Generic sibling call optimization support\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -38,6 +38,7 @@ static rtx skip_use_of_return_value\tPARAMS ((rtx, enum rtx_code));\n static rtx skip_stack_adjustment\tPARAMS ((rtx));\n static rtx skip_pic_restore\t\tPARAMS ((rtx));\n static rtx skip_jump_insn\t\tPARAMS ((rtx));\n+static int call_ends_block_p\t\tPARAMS ((rtx, rtx));\n static int uses_addressof\t\tPARAMS ((rtx));\n static int sequence_uses_addressof\tPARAMS ((rtx));\n static void purge_reg_equiv_notes\tPARAMS ((void));\n@@ -255,6 +256,52 @@ skip_jump_insn (orig_insn)\n \n   return orig_insn;\n }\n+\f\n+/* Using the above functions, see if INSN, skipping any of the above,\n+   goes all the way to END, the end of a basic block.  Return 1 if so.  */\n+\n+static int\n+call_ends_block_p (insn, end)\n+     rtx insn;\n+     rtx end;\n+{\n+  rtx hardret, softret;\n+\n+  /* END might be a note, so get the last nonnote insn of the block.  */\n+  end = next_nonnote_insn (PREV_INSN (end));\n+\n+  /* If the call was the end of the block, then we're OK.  */\n+  if (insn == end)\n+    return 1;\n+\n+  /* Skip over copying from the call's return value pseudo into\n+     this function's hard return register and if that's the end\n+     of the block, we're OK.  */\n+  identify_call_return_value (PATTERN (insn), &hardret, &softret);\n+  insn = skip_copy_to_return_value (insn, hardret, softret);\n+  if (insn == end)\n+    return 1;\n+\n+  /* Skip any stack adjustment.  */\n+  insn = skip_stack_adjustment (insn);\n+  if (insn == end)\n+    return 1;\n+\n+  /* Skip over a CLOBBER of the return value as a hard reg.  */\n+  insn = skip_use_of_return_value (insn, CLOBBER);\n+  if (insn == end)\n+    return 1;\n+\n+  /* Skip over a USE of the return value (as a hard reg).  */\n+  insn = skip_use_of_return_value (insn, USE);\n+  if (insn == end)\n+    return 1;\n+\n+  /* Skip over a JUMP_INSN at the end of the block.  If that doesn't end the\n+     block, the original CALL_INSN didn't.  */\n+  insn = skip_jump_insn (insn);\n+  return insn == end;\n+}\n \n /* Scan the rtx X for ADDRESSOF expressions or\n    current_function_internal_arg_pointer registers.\n@@ -533,18 +580,7 @@ optimize_sibling_and_tail_recursive_calls ()\n \t{\n \t  int sibcall = (XEXP (PATTERN (insn), 1) != NULL_RTX);\n \t  int tailrecursion = (XEXP (PATTERN (insn), 2) != NULL_RTX);\n-\t  basic_block call_block;\n-\t  rtx end, temp, hardret, softret;\n-\n-\t  /* We must be careful with stack slots which are live at\n-\t     potential optimization sites.\n-\n-\t     ?!? This test is overly conservative and will be replaced.  */\n-\t  if (frame_offset\n-\t      /* Taking the address of a local variable is fatal to tail\n-\t\t recursion if the address is used by the recursive call.  */\n-\t      || current_function_uses_addressof)\n-\t    sibcall = 0, tailrecursion = 0;\n+\t  basic_block call_block = BLOCK_FOR_INSN (insn);\n \n \t  /* alloca (until we have stack slot life analysis) inhibits\n \t     sibling call optimizations, but not tail recursion.\n@@ -554,49 +590,23 @@ optimize_sibling_and_tail_recursive_calls ()\n \t      || current_function_varargs || current_function_stdarg)\n \t    sibcall = 0;\n \n-\t  /* Get the block for the call and the last non-note insn in it.  We\n-\t     take advantage of the fact that this cannot be the exit block.  */\n-\t  call_block = BLOCK_FOR_INSN (insn);\n-\t  end = prev_nonnote_insn (NEXT_INSN (call_block->end));\n-\n-\t  /* If the block has more than one successor, then we can not\n-\t     perform sibcall or tail recursion optimizations.  If the single\n-\t     successor is not the exit block, then we can not perform sibcall\n-\t     or tail recursion optimizations.  Note that these two tests\n-\t     combined are sufficient to prevent tail call optimization in the\n-\t     presense of active exception handlers.  */\n-\t  if (call_block->succ == NULL\n+\t  /* See if there are any reasons we can't perform either sibling or\n+\t     tail call optimizations.  We must be careful with stack slots\n+\t     which are live at potential optimization sites.  ?!? This test\n+\t     is overly conservative and will be replaced.  */\n+\t  if (frame_offset\n+\t      /* Can't take address of local var if used by recursive call.  */\n+\t      || current_function_uses_addressof\n+\t      /* Can't if more than one successor or single successor is not\n+\t\t exit block.  These two tests prevent tail call optimization\n+\t\t in the presense of active exception handlers.  */\n+\t      || call_block->succ == NULL\n \t      || call_block->succ->succ_next != NULL\n \t      || (call_block->succ->dest != EXIT_BLOCK_PTR\n-\t\t  && call_block->succ->dest != alternate_exit))\n-\t    sibcall = 0, tailrecursion = 0;\n-\t  \n-\t  /* If we haven't failed yet, check if this (or safe things) ends our\n-\t     block.  */\n-\t  if ((sibcall || tailrecursion)\n-\t      /* If the call was the end of the block, then we're OK.  */\n-\t      && (end == (temp = insn)\n-\t\t  /* Skip over copying from the call's return value pseudo into\n-\t\t     this function's hard return register and if that's the end\n-\t\t     of the block, we're OK.  */\n-\t\t  || (identify_call_return_value (PATTERN (insn), &hardret,\n-\t\t\t\t\t\t  &softret)\n-\t\t      && end == (temp = skip_copy_to_return_value (insn,\n-\t\t\t\t\t\t\t\t   hardret,\n-\t\t\t\t\t\t\t\t   softret)))\n-\t\t  /* Skip any stack adjustment.  */\n-\t\t  || end == (temp = skip_stack_adjustment (temp))\n-\t\t  /* Skip over a CLOBBER of the return value as a hard reg.  */\n-\t\t  || end == (temp = skip_use_of_return_value (temp, CLOBBER))\n-\t\t  /* Skip over a USE of the return value (as a hard reg).  */\n-\t\t  || end == (temp = skip_use_of_return_value (temp, USE))\n-\t\t  /* Skip over the JUMP_INSN at the end of the block.  */\n-\t\t  || end == (temp = skip_jump_insn (temp))))\n-\t    ;\n-\t  else\n-\t    /* There are operations at the end of the block which we must\n-\t       execute after returning from the function call.  So this call\n-\t       can not be optimized.  */\n+\t\t  && call_block->succ->dest != alternate_exit)\n+\t      /* If this call doesn't end the block, there are operations at\n+\t\t the end of the block which we must execute after returning. */\n+\t      || ! call_ends_block_p (insn, call_block->end))\n \t    sibcall = 0, tailrecursion = 0;\n \n \t  /* Select a set of insns to implement the call and emit them."}]}