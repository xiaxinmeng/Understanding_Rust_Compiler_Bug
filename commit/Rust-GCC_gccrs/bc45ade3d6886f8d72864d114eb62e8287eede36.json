{"sha": "bc45ade3d6886f8d72864d114eb62e8287eede36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM0NWFkZTNkNjg4NmY4ZDcyODY0ZDExNGViNjJlODI4N2VlZGUzNg==", "commit": {"author": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1993-04-30T14:29:19Z"}, "committer": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1993-04-30T14:29:19Z"}, "message": "Initial revision\n\nFrom-SVN: r4284", "tree": {"sha": "9feb4b58ac9e3d7937ddd75e4770187cb03a9d3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9feb4b58ac9e3d7937ddd75e4770187cb03a9d3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc45ade3d6886f8d72864d114eb62e8287eede36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc45ade3d6886f8d72864d114eb62e8287eede36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc45ade3d6886f8d72864d114eb62e8287eede36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc45ade3d6886f8d72864d114eb62e8287eede36/comments", "author": null, "committer": null, "parents": [{"sha": "8efabd131fd35d9fc2b9b8480809415d7903319e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8efabd131fd35d9fc2b9b8480809415d7903319e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8efabd131fd35d9fc2b9b8480809415d7903319e"}], "stats": {"total": 3667, "additions": 3667, "deletions": 0}, "files": [{"sha": "2e3634c0ad2088aff070569f9f5103e915172089", "filename": "gcc/config/sh/sh.c", "status": "added", "additions": 1188, "deletions": 0, "changes": 1188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc45ade3d6886f8d72864d114eb62e8287eede36/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc45ade3d6886f8d72864d114eb62e8287eede36/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=bc45ade3d6886f8d72864d114eb62e8287eede36", "patch": "@@ -0,0 +1,1188 @@\n+/* Output routines for GCC for Hitachi Super-H\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Contributed by Steve Chamberlain (sac@cygnus.com) */\n+\n+#include <stdio.h>\n+#include \"assert.h\"\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"tree.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"obstack.h\"\n+#include \"expr.h\"\n+\n+\n+static int add_constant ();\n+static void dump_constants ();\n+\n+int current_function_anonymous_args;\n+extern int current_function_pretend_args_size;\n+\n+/* Global variables for machine-dependent things. */\n+\n+/* Saved operands from the last compare to use when we generate an scc\n+  or bcc insn. */\n+\n+rtx sh_compare_op0;\n+rtx sh_compare_op1;\n+\n+/* Provides the class number of the smallest class containing\n+   reg number */\n+\n+int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n+{\n+  R0_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, PR_REGS, T_REGS, NO_REGS, MAC_REGS,\n+  MAC_REGS,\n+};\n+\n+/* Provide reg_class from a letter such as appears in the machine\n+   description. */\n+\n+enum reg_class reg_class_from_letter[] =\n+{\n+  /* a */ NO_REGS, /* b */ NO_REGS, /* c */ NO_REGS, /* d */ NO_REGS,\n+  /* e */ NO_REGS, /* f */ NO_REGS, /* g */ NO_REGS, /* h */ NO_REGS,\n+  /* i */ NO_REGS, /* j */ NO_REGS, /* k */ NO_REGS, /* l */ PR_REGS,\n+  /* m */ NO_REGS, /* n */ NO_REGS, /* o */ NO_REGS, /* p */ NO_REGS,\n+  /* q */ NO_REGS, /* r */ NO_REGS, /* s */ NO_REGS, /* t */ T_REGS,\n+  /* u */ NO_REGS, /* v */ NO_REGS, /* w */ NO_REGS, /* x */ MAC_REGS,\n+  /* y */ NO_REGS, /* z */ R0_REGS\n+};\n+\n+\n+/* Local label counter, used for constants in the pool and inside\n+   pattern branches.  */\n+\n+static int lf;\n+\n+/* Used to work out sizes of instructions */\n+static int first_pc;\n+static int pc;\n+\n+static int dumpnext;\n+\f\n+/* Functions for generating procedure prologue and epilogue code */\n+\n+/* Adjust the stack and return the number of bytes taken to do it */\n+\n+static int\n+output_stack_adjust (file, direction, size)\n+     FILE *file;\n+     int direction;\n+     int size;\n+{\n+  int code_size;\n+\n+  if (size > 127)\n+    {\n+      fprintf (file, \"\\tmov.l\tLK%d,r13\\n\",\n+\t       add_constant (GEN_INT (size * direction), SImode));\n+\n+      fprintf (file, \"\\tadd\tr13,r15\\n\");\n+      code_size += 4;\n+    }\n+  else if (size)\n+    {\n+      fprintf (file, \"\\tadd\t#%d,r15\\n\", direction * size);\n+      code_size += 2;\n+    }\n+  return code_size;\n+}\n+\n+/* Generate code to push the regs specified in the mask, and return\n+   the number of bytes the insns take. */\n+\n+static int\n+push_regs (f, mask)\n+     FILE *f;\n+     int mask;\n+{\n+  int i;\n+  int size = 0;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (mask & (1 << i))\n+\t{\n+\t  fprintf (f, \"\\tmov.l\tr%d,@-r15\\n\", i);\n+\t  size += 2;\n+\t}\n+    }\n+  return size;\n+}\n+\n+\n+/* Working out the right code to use for an epilogue can get quite\n+   hairy, since there are only certain insns which can go in the delay\n+   slot, and there may or may not be a delay insn provided already.\n+\n+   We generate a canonical list of the instructions to use to perform\n+   the exit, massage that and output from that list */\n+\n+\n+/* The structure of a canonical element. */\n+\n+typedef struct\n+{\n+  enum epi_type\n+    {\n+      STACK_ADJUST,\t\t/* add i to stack pointer \t*/\n+      POP,\t\t\t/* pop into register i \t\t*/\n+      RTS,\t\t\t/* rts instruction \t\t*/\n+      DELAY,\t\t\t/* delay slot instruction \t*/\n+      NOP,\t\t\t/* a nop \t\t\t*/\n+      DELETED,\n+    } type;\n+  int i;\n+}\n+\n+epilogue_insn;\n+\n+static epilogue_insn epilogue_vec[20];\n+static int epilogue_vec_len;\n+\n+static void\n+set_epilogue_insn (type, l)\n+     enum epi_type type;\n+     int l;\n+{\n+  epilogue_vec[epilogue_vec_len].type = type;\n+  epilogue_vec[epilogue_vec_len].i = l;\n+  epilogue_vec_len++;\n+}\n+\n+/* Delete an insn from the epilogue list. */\n+\n+static void\n+delete_epilogue_insn (n)\n+     int n;\n+{\n+  int j;\n+\n+  for (j = n; j < epilogue_vec_len; j++)\n+    epilogue_vec[j] = epilogue_vec[j + 1];\n+\n+  epilogue_vec_len--;\n+}\n+\n+/* Run through the epilogue list and optimize it. */\n+\n+static void\n+optimize_epilogue_vec ()\n+{\n+  int i;\n+\n+  /* Turn two adds in a row into one add and kill empty adds */\n+  for (i = 0; i < epilogue_vec_len - 1; i++)\n+    {\n+      if (epilogue_vec[i].type == STACK_ADJUST\n+\t  && epilogue_vec[i + 1].type == STACK_ADJUST)\n+\t{\n+\t  epilogue_vec[i].i += epilogue_vec[i + 1].i;\n+\t  delete_epilogue_insn (i + 1);\n+\t}\n+      if (epilogue_vec[i].type == STACK_ADJUST\n+\t  && epilogue_vec[i].i == 0)\n+\tdelete_epilogue_insn (i);\n+    }\n+\n+  /* If the instruction after the RTS is a nop, see if it can be\n+     changed */\n+\n+  for (i = 1; i < epilogue_vec_len - 1; i++)\n+    {\n+      if (epilogue_vec[i].type == RTS\n+\t  && epilogue_vec[i + 1].type == NOP)\n+\t{\n+\t  epilogue_vec[i + 1] = epilogue_vec[i - 1];\n+\t  delete_epilogue_insn (i - 1);\n+\t}\n+    }\n+\n+  /* Delete all the instructions after the rts's delay slot */\n+  for (i = 0; i < epilogue_vec_len; i++)\n+    {\n+      if (epilogue_vec[i].type == RTS)\n+\t{\n+\t  int j;\n+\n+\t  for (j = i + 2; j < epilogue_vec_len; j++)\n+\t    epilogue_vec[j].type = DELETED;\n+\t  return;\n+\t}\n+    }\n+}\n+\n+/* Dump out the insns in epilogue vector. */\n+\n+static void\n+output_epilogue_vec ()\n+{\n+  int i;\n+\n+  for (i = 0; i < epilogue_vec_len; i++)\n+    {\n+      switch (epilogue_vec[i].type)\n+\t{\n+\tcase STACK_ADJUST:\n+\t  fprintf (asm_out_file, \"\\tadd\t#%d,r15\\n\", epilogue_vec[i].i);\n+\t  break;\n+\n+\tcase NOP:\n+\t  fprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n+\t  break;\n+\n+\tcase DELAY:\n+\t  final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n+\t\t\t   asm_out_file, 1, 0, 1);\n+\t  break;\n+\n+\tcase DELETED:\n+\t  fprintf (asm_out_file, \"\\t!delete_epilogue_insnd\\n\");\n+\t  break;\n+\n+\tcase RTS:\n+\t  fprintf (asm_out_file, \"\\trts\\n\");\n+\t  break;\n+\n+\tcase POP:\n+\t  fprintf (asm_out_file, \"\\tmov.l\t@r15+,r%d\\n\",\n+\t\t   epilogue_vec[i].i);\n+\t  break;\n+\t}\n+    }\n+  epilogue_vec_len = 0;\n+}\n+\n+/* Number of bytes pushed for anonymous args */\n+\n+static int extra_push;\n+\n+/* Work out the registers which need to be saved, both as a mask and a\n+   count */\n+\n+int\n+calc_live_regs (count)\n+     int *count;\n+{\n+  int reg;\n+  int live_regs_mask = 0;\n+  *count = 0;\n+\n+  for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n+    {\n+      if (regs_ever_live[reg] && !call_used_regs[reg])\n+\t{\n+\t  (*count)++;\n+\t  live_regs_mask |= (1 << reg);\n+\t}\n+    }\n+  return live_regs_mask;\n+}\n+\n+/* Generate a procedure prologue.  */\n+\n+void\n+output_prologue (f, frame_size)\n+     FILE *f;\n+     int frame_size;\n+{\n+  int live_regs_mask;\n+  int d;\n+\n+  pc = 0;\n+\n+  /* This only happens when an arg has been split, part in\n+     registers, part in memory.  Allocate the stack space so there is\n+     somewhere to put the value */\n+\n+  output_stack_adjust (f, -1, current_function_pretend_args_size);\n+\n+  live_regs_mask = calc_live_regs (&d);\n+\n+  extra_push = 0;\n+\n+  if (current_function_anonymous_args)\n+    {\n+      /* Push arg regs as if they'd been provided by caller in stack */\n+      int i;\n+      for (i = 0; i < NPARM_REGS; i++)\n+\t{\n+\t  int rn = NPARM_REGS + FIRST_PARM_REG - i - 1;\n+\t  if (i > NPARM_REGS - current_function_args_info)\n+\t    break;\n+\t  fprintf (f, \"\\tmov.l\tr%d,@-r15\\n\", rn);\n+\t  extra_push += 4;\n+\t  pc += 2;\n+\t}\n+    }\n+\n+  if (frame_pointer_needed)\n+    {\n+      /* Don't need to push the fp with the rest of the registers. */\n+      live_regs_mask &= ~(1 << FRAME_POINTER_REGNUM);\n+      pc += push_regs (f, live_regs_mask);\n+      if (regs_ever_live[PR_REG])\n+\t{\n+\n+\t  fprintf (f, \"\\tsts.l\tpr,@-r15\\n\");\n+\t  pc += 2;\n+\t}\n+\n+      fprintf (f, \"\\tmov.l\tr14,@-r15\\n\");\n+      fprintf (f, \"\\tmov\tr15,r14\\n\");\n+      pc += 4;\n+      pc += output_stack_adjust (f, -1, frame_size);\n+    }\n+  else\n+    {\n+      pc += push_regs (f, live_regs_mask);\n+\n+      if (regs_ever_live[PR_REG])\n+\t{\n+\n+\t  fprintf (f, \"\\tsts.l\tpr,@-r15\\n\");\n+\t  pc += 2;\n+\t}\n+      pc += output_stack_adjust (f, -1, frame_size);\n+    }\n+}\n+\n+\n+/* Generate a procedure epilogue. */\n+\n+void\n+output_epilogue (f, frame_size)\n+     FILE *f;\n+     int frame_size;\n+{\n+  int live_regs_mask = 0;\n+  int d;\n+  int i;\n+\n+  live_regs_mask = calc_live_regs (&d);\n+\n+  /* Reclaim the room for the automatics. */\n+\n+  output_stack_adjust (f, 1, frame_size);\n+\n+  /* Make the frame pointer. */\n+\n+  if (frame_pointer_needed)\n+    {\n+      fprintf (f, \"\\tmov\tr14,r15\\n\");\n+      fprintf (f, \"\\tmov.l\t@r15+,r14\\n\");\n+      live_regs_mask &= ~(1 << FRAME_POINTER_REGNUM);\n+    }\n+\n+  /* Get the PR register if it was clobbered in the function. */\n+\n+  if (regs_ever_live[PR_REG])\n+    fprintf (f, \"\\tlds.l\t@r15+,pr\\n\");\n+\n+  /* Pop all the registers */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n+      if (live_regs_mask & (1 << j))\n+\t{\n+\t  set_epilogue_insn (POP, j);\n+\t}\n+    }\n+\n+  /* Need to adjust the stack by some amount of bytes since we've pushed\n+     some of the args which normally come in registers */\n+\n+  set_epilogue_insn (STACK_ADJUST, extra_push);\n+\n+  /* Need to adjust the stack by some amount of bytes if there\n+     an arg has been split part register and part stack */\n+\n+  set_epilogue_insn (STACK_ADJUST, current_function_pretend_args_size);\n+\n+  set_epilogue_insn (RTS, 0);\n+\n+  /* Got here without dumping a register pop into the delay slot */\n+  if (current_function_epilogue_delay_list)\n+    {\n+      set_epilogue_insn (DELAY, 0);\n+    }\n+  set_epilogue_insn (NOP, 0);\n+\n+  optimize_epilogue_vec ();\n+\n+  output_epilogue_vec ();\n+\n+  dump_constants ();\n+  current_function_anonymous_args = 0;\n+}\n+\f\n+/* Print the operand address in x to the stream */\n+\n+void\n+print_operand_address (stream, x)\n+     FILE *stream;\n+     rtx x;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      fprintf (stream, \"@%s\", reg_names[REGNO (x)]);\n+      break;\n+\n+    case PLUS:\n+      {\n+\trtx base = XEXP (x, 0);\n+\trtx index = XEXP (x, 1);\n+\n+\tif (GET_CODE (base) != REG)\n+\t  {\n+\t    /* Ensure that BASE is a register (one of them must be). */\n+\t    rtx temp = base;\n+\t    base = index;\n+\t    index = temp;\n+\t  }\n+\n+\tswitch (GET_CODE (index))\n+\t  {\n+\t  case CONST_INT:\n+\t    fprintf (stream, \"@(%d,%s)\",\n+\t\t     INTVAL (index),\n+\t\t     reg_names[REGNO (base)]);\n+\t    break;\n+\n+\t  case REG:\n+\t    fprintf (stream, \"@(%s,%s)\",\n+\t\t     reg_names[REGNO (base)],\n+\t\t     reg_names[REGNO (index)]);\n+\t    break;\n+\n+\t  default:\n+\t    abort ();\n+\t  }\n+      }\n+\n+      break;\n+    case PRE_DEC:\n+      fprintf (stream, \"@-%s\", reg_names[REGNO (XEXP (x, 0))]);\n+      break;\n+\n+    case POST_INC:\n+      fprintf (stream, \"@%s+\", reg_names[REGNO (XEXP (x, 0))]);\n+      break;\n+\n+    default:\n+      output_addr_const (stream, x);\n+      break;\n+    }\n+}\n+\n+/* Print operand x (an rtx) in assembler syntax to file stream\n+   according to modifier code.\n+\n+ '*'  print a local label\n+ '^'  increment the local label number\n+ '!'  dump the constant table\n+ '#'  output a nop if there is nothing to put in the delay slot\n+ 'R'  print the next register or memory location along, ie the lsw in\n+      a double word value\n+ 'I'  put something into the constant pool and print its label */\n+\n+void\n+print_operand (stream, x, code)\n+     FILE *stream;\n+     rtx x;\n+     int code;\n+{\n+  switch (code)\n+    {\n+    case '*':\n+      fprintf (stream, \"LF%d\", lf);\n+      break;\n+    case '!':\n+      dump_constants();\n+      break;\n+    case '^':\n+      lf++;\n+      break;\n+\n+    case '#':\n+      /* Output a nop if there's nothing in the delay slot */\n+      if (dbr_sequence_length () == 0)\n+\t{\n+\t  fprintf (stream, \"\\n\\tor\tr0,r0\\t!wasted slot\");\n+\t}\n+      break;\n+\n+    case 'I':\n+      fprintf (asm_out_file, \"LK%d\", add_constant (x, SImode));\n+      break;\n+\n+    case 'R':\n+      /* Next location along in memory or register*/\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  fputs (reg_names[REGNO (x) + 1], (stream));\n+\t  break;\n+\tcase MEM:\n+\t  print_operand_address (stream,\n+\t\t\t       XEXP (adj_offsettable_operand (x, 4), 0), 0);\n+\t  break;\n+\t}\n+      break;\n+\n+    default:\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  fputs (reg_names[REGNO (x)], (stream));\n+\t  break;\n+\tcase MEM:\n+\t  output_address (XEXP (x, 0));\n+\t  break;\n+\tdefault:\n+\t  fputc ('#', stream);\n+\t  output_addr_const (stream, x);\n+\t  break;\n+\n+\t}\n+      break;\n+    }\n+}\n+\n+\f\n+\n+/* Define the offset between two registers, one to be eliminated, and \n+   the other its replacement, at the start of a routine.  */\n+\n+int\n+initial_elimination_offset (from, to)\n+{\n+  int regs_saved;\n+  int d = calc_live_regs (&regs_saved);\n+  int total_saved_regs_space = (regs_saved + regs_ever_live[PR_REG]) * 4;\n+  int total_auto_space = get_frame_size ();\n+\n+\n+  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n+    {\n+      return total_saved_regs_space;\n+    }\n+\n+  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    {\n+      return total_saved_regs_space + total_auto_space;\n+    }\n+\n+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    {\n+      return total_auto_space;\n+    }\n+}\n+\n+delay_slots_for_epilogue ()\n+{\n+  /* We need to find something to fill the epilogue if there won't be\n+     any instructions to make the stack or pop registers which can be\n+     moved into the slot */\n+\n+  int d;\n+  calc_live_regs (&d);\n+  return !(get_frame_size () + d);\n+}\n+\f\n+\n+/* Prepare operands for a move define_expand; specifically, one of the\n+   operands must be in a register */\n+\n+void\n+prepare_move_operands (operands, mode)\n+     rtx operands[];\n+     enum machine_mode mode;\n+{\n+  /* One of the operands has to be a register */\n+  if ((!register_operand (operands[0], mode)\n+       && !register_operand (operands[1], mode))\n+      || GET_CODE(operands[1]) == PLUS)\n+    {\n+      /* copy the source to a register */\n+      operands[1] = copy_to_mode_reg (mode, operands[1]);\n+    }\n+}\n+\n+\n+/* Prepare the operands for an scc instruction; make sure that the\n+   compare has been done.  */\n+rtx\n+prepare_scc_operands (code)\n+{\n+  if (GET_CODE(sh_compare_op0) != REG \n+      || REGNO(sh_compare_op0) != T_REG)\n+    {\n+      /* First need a compare insn */\n+      emit_insn (gen_rtx (SET, SImode, \n+\t\t\t  gen_rtx (REG, SImode, T_REG),\n+\t\t\t  gen_rtx (code, SImode, sh_compare_op0,\n+\t\t\t\t   sh_compare_op1)));\n+    }\n+  return gen_rtx(REG, SImode, T_REG);\n+}\n+\f\n+/* Functions to output assembly */\n+\n+/* Return a sequence of instructions to perform DI move, taking into\n+   account overlapping source and dest registers */\n+\n+char *\n+output_movedouble (operands, mode)\n+     rtx operands[];\n+     enum machine_mode mode;\n+{\n+  if (register_operand (operands[0], mode)\n+      && register_operand (operands[1], mode))\n+    {\n+      if (REGNO (operands[1]) == MACH_REG)\n+\treturn \"sts\tmach,%0\\n\\tsts\tmacl,%R0\";\n+      return \"mov\t%1,%0\\n\\tmov\t%R1,%R0\";\n+    }\n+\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if (INTVAL (operands[1]) < 0)\n+\treturn \"mov\t#-1,%0\\n\\tmov\t%1,%R0\";\n+      else\n+\treturn \"mov\t#0,%0\\n\\tmov\t%1,%R0\";\n+    }\n+\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      int idxreg = -1;\n+      rtx inside = XEXP (operands[1], 0);\n+\n+      if (GET_CODE (inside) == REG)\n+\tidxreg = REGNO (inside);\n+      else if (GET_CODE (inside) == PLUS)\n+\t{\n+\t  rtx lhs = XEXP (inside, 0);\n+\t  rtx rhs = XEXP (inside, 1);\n+\t  if (GET_CODE (lhs) == REG)\n+\t    idxreg = REGNO (lhs);\n+\t  else if (GET_CODE (rhs) == REG)\n+\t    idxreg = REGNO (rhs);\n+\t  else\n+\t    abort ();\n+\t}\n+      else\n+\tabort ();\n+\n+      if (REGNO (operands[0]) != idxreg)\n+\t{\n+\t  /* The dest register is mentioned in the addressing mode,\n+\t     so print them the other way around */\n+\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%R1,%R0 ! one way\";\n+\t}\n+      return \"mov.l\t%R1,%R0\\n\\tmov.l\t%1,%0 ! other way\";\n+    }\n+\n+  return \"mov.l\t%R1,%R0\\n\\tmov.l\t%1,%0\";\n+}\n+\n+/* Emit assembly to shift reg by k bits */\n+\n+char *\n+output_shift (string, reg, k)\n+     char *string;\n+     rtx reg;\n+     rtx k;\n+{\n+  int s = INTVAL (k);\n+  while (s)\n+    {\n+      char *out;\n+      int d;\n+\n+      if (s >= 16)\n+\t{\n+\t  d = 16;\n+\t  out = \"16\";\n+\t}\n+      else if (s >= 8)\n+\t{\n+\t  d = 8;\n+\t  out = \"8\";\n+\t}\n+      else if (s >= 2)\n+\t{\n+\t  d = 2;\n+\t  out = \"2\";\n+\t}\n+      else\n+\t{\n+\t  d = 1;\n+\t  out = \"\";\n+\t}\n+      fprintf (asm_out_file, \"\\t%s%s\\tr%d\\n\", string, out, REGNO (reg));\n+      s -= d;\n+    }\n+  return \"\";\n+}\n+\n+/* Return the text of the branch instruction which matches its length\n+   attribute.  */\n+\n+char *\n+output_branch (logic, insn)\n+     int logic;\n+     rtx *insn;\n+{\n+  extern rtx recog_operand[];\n+  int label = lf++;\n+  \n+  switch (get_attr_length (insn))\n+    {\n+    case 2:\n+      /* Simple branch in range -200..+200 bytes */\n+      return logic ? \"bt\t%l0\" : \"bf\t%l0\";\n+\n+    case 6:\n+      /* Branch in range -4000..+4000 bytes */\n+      fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n+      output_asm_insn (\"bra\t%l0\t! 12 bit cond \", recog_operand);\n+      fprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n+      fprintf (asm_out_file, \"LF%d:\\n\", label);\n+      lf++;\n+      return \"\";\n+\n+    case 8:\n+      /* Branches a long way away */\n+\t\n+      fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n+      output_asm_insn (\"mov.l\t%I0,r13\", recog_operand);\n+      fprintf (asm_out_file, \"\\tjmp\t@r13\t! 32 cond \\n\");\n+      fprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n+      fprintf (asm_out_file, \"LF%d:\\n\", label);\n+      return \"\";\n+    }\n+  return \"bad\";\n+\n+}\n+\f\n+/* Predicates used by the templates */\n+\n+/* Nonzero if OP is a valid source operand for an arithmetic insn.  */\n+\n+int\n+arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      if (CONST_OK_FOR_I (INTVAL (op)))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+\n+/* Nonzero if OP is a valid source operand for a logical operation */\n+\n+int\n+logical_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      if (CONST_OK_FOR_L (INTVAL (op)))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+/* Nonzero if p is a valid shift operand for lshr and ashl */\n+\n+int\n+ok_shift_value (p)\n+     rtx p;\n+{\n+  if (GET_CODE (p) == CONST_INT)\n+    {\n+      switch (INTVAL (p))\n+\t{\n+\tcase 1:\n+\tcase 2:\n+\tcase 8:\n+\tcase 16:\n+\t  return 1;\n+\tdefault:\n+\t  if (TARGET_FASTCODE)\n+\t    return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Nonzero if the arg is an immediate which has to be loaded from\n+   memory */\n+\n+int\n+hard_immediate_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (immediate_operand (op, mode))\n+    {\n+      if (GET_CODE (op) == CONST_INT\n+\t  && INTVAL (op) >= -128 && INTVAL (op) < 127)\n+\treturn 0;\n+      return 1;\n+    }\n+  return 0;\n+}\n+\f\n+/* The SH cannot load a large constant into a register, constants have to\n+   come from a pc relative load.  The reference of a pc relative load\n+   instruction must be less than 1k infront of the instruction.  This\n+   means that we often have to dump a constant inside a function, and\n+   generate code to branch around it.\n+\n+   It is important to minimize this, since the branches will slow things\n+   down and make things bigger.\n+\n+  Worst case code looks like:\n+\n+      mov.l L1,rn\n+      bra   L2\n+      nop\n+      align\n+L1:   .long value\n+L2:\n+      ..\n+\n+      mov.l L3,rn\n+      bra   L4\n+      nop\n+      align\n+L3:   .long value\n+L4:\n+      ..\n+\n+   During shorten_branches we notice the instructions which can have a\n+   constant table in them, if we see two that are close enough\n+   together, we move the constants from the first table to the second\n+   table and continue.  This process can happen again and again, and\n+   in the best case, moves the constant table outside of the function.\n+\n+   In the above example, we can tell that L3 is within 1k of L1, so\n+   the first move can be shrunk from the 3 insn+constant sequence into\n+   just 1 insn, and the constant moved to L3 to make:\n+\n+   mov.l\tL1,rn\n+   ..\n+   mov.l\tL3,rn\n+   bra\t\tL4\n+   nop\n+   align\n+L3:.long value\n+L4:.long value\n+\n+   Then the second move becomes the target for the shortening process.\n+\n+   We keep a simple list of all the constants accumulated in the\n+   current pool so there are no duplicates in a single table, but\n+   they are not factored into the size estimates.\n+\n+*/\n+\n+typedef struct\n+{\n+  rtx value;\n+  int number;\n+  enum machine_mode mode;\n+} pool_node;\n+\n+/* The maximum number of constants that can fit into one pool, since\n+   the pc relative range is 0...1020 bytes and constants are at least 4\n+   bytes long */\n+\n+#define MAX_POOL_SIZE (1020/4)\n+static pool_node pool_vector[MAX_POOL_SIZE];\n+static int pool_size;\n+\n+\n+/* Add a constant to the pool and return its label number.  */\n+\n+static int\n+add_constant (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  int i;\n+\n+  /* Start the countdown on the first constant */\n+\n+  if (!pool_size)\n+    {\n+      first_pc = pc;\n+    }\n+\n+  /* First see if we've already got it */\n+\n+  for (i = 0; i < pool_size; i++)\n+    {\n+\n+      if (x->code == pool_vector[i].value->code\n+\t  && mode == pool_vector[i].mode)\n+\t{\n+\t  if (x->code == CODE_LABEL)\n+\t    {\n+\t      if (XINT (x, 3) != XINT (pool_vector[i].value, 3))\n+\t\tcontinue;\n+\t    }\n+\t}\n+\n+      if (rtx_equal_p (x, pool_vector[i].value))\n+\treturn pool_vector[i].number;\n+    }\n+  \n+\n+  pool_vector[pool_size].value = x;\n+  pool_vector[pool_size].mode = mode;\n+  pool_vector[pool_size].number = lf;\n+  pool_size++;\n+\n+  return lf++;\n+}\n+\n+/* Nonzero if the insn could take a constant table.  */\n+\n+static int\n+has_constant_table (insn)\n+     rtx insn;\n+{\n+  rtx body;\n+\n+  if (GET_CODE (insn) == NOTE\n+      || GET_CODE (insn) == BARRIER\n+      || GET_CODE (insn) == CODE_LABEL)\n+    return 0;\n+\n+  body = PATTERN (insn);\n+  if (GET_CODE (body) == SEQUENCE)\n+    return 0;\n+  if (GET_CODE (body) == ADDR_VEC)\n+    return 0;\n+  if (GET_CODE (body) == USE)\n+    return 0;\n+  if (GET_CODE (body) == CLOBBER)\n+    return 0;\n+  if (get_attr_constneed (insn) == CONSTNEED_YES)\n+    return 1;\n+\n+  if (GET_CODE (body) == UNSPEC_VOLATILE)\n+    {\n+      return INTVAL (XVECEXP (body, 0, 0)) == 1;\n+    }\n+  return 0;\n+}\n+\n+/*  Adjust the length of an instruction.\n+\n+    We'll look at the previous instruction which holds a constant\n+    table and see if we can move the table to here instead. */\n+\n+int target_insn_uid;\n+int target_insn_smallest_size;\n+\n+int target_pc;\n+int target_insn_range;\n+int current_pc;\n+int table_size;\n+\n+void\n+adjust_insn_length (insn, insn_lengths)\n+     rtx insn;\n+     short *insn_lengths;\n+{\n+  int uid = INSN_UID (insn);\n+\n+  current_pc += insn_lengths[uid];\n+\n+  if (has_constant_table (insn)) \n+    {\n+      if (current_pc >= target_insn_range)\n+\t{\n+\t  /* This instruction is further away from the referencing\n+\t     instruction than it can reach, so we'll stop accumulating\n+\t     from that one and start fresh. */\n+\t  target_pc = current_pc;\n+\t  target_insn_range = current_pc + 1000;\n+\t}\n+      else\n+\t{\n+\t  /* This instruction is within the reach of the target,\n+\t     remove the constant table from the target by adjusting\n+\t     downwards, and increase the size of this one to\n+\t     compensate.  */\n+\n+\n+\t  /* Add the stuff from this insn to what will go in the\n+\t     growing table. */\n+\n+\t  table_size += get_attr_constantsize (insn);\n+\n+\t  /* The target shinks to its smallest natural size */\n+\t  insn_lengths[target_insn_uid] = target_insn_smallest_size;\n+\n+\t  /* The current insn grows to be its larger size plust the\n+\t     table size. */\n+\n+\t  insn_lengths[uid] = get_attr_largestsize (insn) + table_size;\n+\n+\t}\n+      /* Current insn becomes the target.  */\n+      target_insn_uid = uid;\n+      target_insn_smallest_size = get_attr_smallestsize (insn);\n+\n+    }\n+\n+}\n+\n+\n+/* Dump out the pending constant pool.  */\n+\n+static void\n+dump_constants ()\n+{\n+  int i;\n+  for (i = 0; i < pool_size; i++)\n+    {\n+      pool_node *p = pool_vector + i;\n+      fprintf (asm_out_file, \"\\n\\t! constants - waited %d\\n\", pc - first_pc);\n+      fprintf (asm_out_file, \"\\t.align\\t2\\n\");\n+      fprintf (asm_out_file, \"LK%d:\", p->number);\n+      switch (GET_MODE_CLASS (p->mode))\n+\t{\n+\tcase MODE_INT:\n+\tcase MODE_PARTIAL_INT:\n+\t  assemble_integer (p->value, GET_MODE_SIZE (p->mode), 1);\n+\t  break;\n+\tcase MODE_FLOAT:\n+\t  {\n+\t    union real_extract u;\n+\t    bcopy (&CONST_DOUBLE_LOW (p->value), &u, sizeof u);\n+\t    assemble_real (u.d, p->mode);\n+\t  }\n+\t}\n+\n+      fprintf (asm_out_file, \"\\n\");\n+    }\n+  pool_size = 0;\n+  current_pc = 0;\n+  target_insn_range = 0;\n+}\n+\n+\n+/* Emit the text to load a value from a constant table.  */\n+\n+char *\n+output_movepcrel (insn, operands, mode)\n+     rtx insn;\n+     rtx operands[];\n+     enum machine_mode mode;\n+{\n+  int len = GET_MODE_SIZE (mode);\n+  int rn = REGNO (operands[0]);\n+\n+  fprintf (asm_out_file, \"\\tmov.l\tLK%d,r%d\\n\",\n+\t   add_constant (operands[1], mode), rn);\n+\n+  if (GET_MODE_SIZE(mode) > 4) \n+    {\n+      fprintf (asm_out_file,\n+\t       \"\\tmov.l\tLK%d+4,r%d\\n\",\n+\t       add_constant (operands[1], mode),\n+\t       rn + 1);\n+\n+    } \n+  /* If this instruction is as small as it can be, there can be no \n+     constant table attached to it.  */\n+  if (get_attr_length (insn) !=  get_attr_smallestsize (insn))\n+    {\n+      /* This needs a constant table */\n+      fprintf (asm_out_file, \"\\t!constant table start\\n\");\n+      fprintf (asm_out_file, \"\\tbra\tLF%d\\n\", lf);\n+      fprintf (asm_out_file, \"\\tor\tr0,r0 ! wasted slot\\n\");\n+      dump_constants ();\n+      fprintf (asm_out_file, \"LF%d:\\n\", lf++);\n+      fprintf (asm_out_file, \"\\t!constant table end\\n\");\n+    }\n+  return \"\";\n+}\n+\f\n+\n+/* Dump out interesting debug info */\n+\n+void\n+final_prescan_insn (insn, opvec, noperands)\n+     rtx insn;\n+     rtx *opvec;\n+     int noperands;\n+{\n+  register rtx body = PATTERN (insn);\n+\n+  if (target_flags & ISIZE_BIT)\n+    {\n+      extern int *insn_addresses;\n+\n+      fprintf (asm_out_file, \"\\n!%04x*\\n\",\n+\t       insn_addresses[INSN_UID (insn)] + 0x10);\n+\n+      fprintf (asm_out_file, \"\\n!%04x %d %04x len=%d\\n\",\n+\t       pc, pool_size, first_pc, get_attr_length (insn));\n+\n+      if (TARGET_DUMP_RTL)\n+\tprint_rtl (asm_out_file, body);\n+\n+      pc += get_attr_length (insn);\n+    }\n+}\n+"}, {"sha": "0a75098b3b14f27178bc8d9bbaa7340c7529428e", "filename": "gcc/config/sh/sh.h", "status": "added", "additions": 1159, "deletions": 0, "changes": 1159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc45ade3d6886f8d72864d114eb62e8287eede36/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc45ade3d6886f8d72864d114eb62e8287eede36/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=bc45ade3d6886f8d72864d114eb62e8287eede36", "patch": "@@ -0,0 +1,1159 @@\n+/* Definitions of target machine for GNU compiler, for Hitachi Super-H.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+   Contributed by Steve Chamberlain (sac@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\f\n+/* Run-time Target Specification.  */\n+#define TARGET_SH\n+\n+#define TARGET_VERSION  \\\n+  fputs (\" (Hitachi SH)\", stderr);\n+\n+/* Generate SDB debugging information.  */\n+\n+#define SDB_DEBUGGING_INFO  1\n+\n+#define SDB_DELIM \";\"\n+\n+#define CPP_PREDEFINES \"-D__sh__\"\n+\n+\n+/* Omitting the frame pointer is a very good idea on the SH */\n+\n+#define OPTIMIZATION_OPTIONS(OPTIMIZE)  \\\n+{\t\t\t\t\t\\\n+  if (OPTIMIZE)\t\t\t\t\\\n+    flag_omit_frame_pointer = 1;\t\\\n+   if (OPTIMIZE==0)OPTIMIZE=1;\t\t\\\n+}\n+\f\n+/* Run-time compilation parameters selecting different hardware subsets. */\n+\n+extern int target_flags;\n+#define ISIZE_BIT  1\n+#define FAST_BIT   2\n+#define MULSI3_BIT 4\n+#define MAC_BIT    8\n+#define RTL_BIT    16\n+#define DT_BIT     32\n+#define DALIGN_BIT 64\n+\n+/* Nonzero if we should generate code using muls.l insn */\n+#define TARGET_HAS_MULSI3 (target_flags & MULSI3_BIT)\n+\n+/* Nonzero if we should generate faster code rather than smaller code */\n+#define TARGET_FASTCODE   (target_flags & FAST_BIT)\n+\n+/* Nonzero if we should dump out instruction size info */\n+#define TARGET_DUMPISIZE  (target_flags & ISIZE_BIT)\n+\n+/* Nonzero if we should try to generate mac instructions */\n+#define TARGET_MAC        (target_flags & MAC_BIT)\n+\n+/* Nonzero if we should dump the rtl in the assembly file. */\n+#define TARGET_DUMP_RTL\t  (target_flags & RTL_BIT)\n+\n+/* Nonzero if the target has a decrement and test instruction .*/\n+#define TARGET_HAS_DT     (target_flags & DT_BIT)\n+\n+/* Nonzero to align doubles on 64 bit boundaries */\n+#define TARGET_ALIGN_DOUBLE (target_flags & DALIGN_BIT)\n+\n+#define TARGET_SWITCHES  \t\\\n+{ {\"isize\", \t( ISIZE_BIT)  },\\\n+  {\"space\", \t(-FAST_BIT)   },\\\n+  {\"hasmulsi\",  ( MULSI3_BIT) },\\\n+  {\"hasdt\", \t( DT_BIT)     },\\\n+  {\"ac\",  \t( MAC_BIT)    },\\\n+  {\"dalign\",  \t( DALIGN_BIT) },\\\n+  {\"\",   \tTARGET_DEFAULT} \\\n+}\n+\n+#define TARGET_DEFAULT  FAST_BIT\n+\n+\f\n+/* Target machine storage Layout.  */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN  0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* Number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT  8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD  32\n+#define MAX_BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD\t4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE  32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY  \t32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY  32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY  16\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY  32\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT  (TARGET_ALIGN_DOUBLE ? 64 : 32)\n+\n+/* The best alignment to use in cases where we have a choice.  */\n+#define FASTEST_ALIGNMENT 32\n+\n+/* Every structures size must be a multiple of 32 bits.  */\n+#define STRUCTURE_SIZE_BOUNDARY 32\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  ((TREE_CODE (EXP) == STRING_CST\t\\\n+    && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n+   ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Set this nonzero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+\f\n+/* Standard register usage.  */\n+\n+/* Register allocation for our first guess \n+\n+\tr0-r3\t\tscratch\n+\tr4-r7\t\targs in and out\n+\tr8-r11\t\tcall saved\n+\tr12\t\t\n+\tr13\t\tassembler temp\n+\tr14\t\tframe pointer\n+\tr15\t\tstack pointer\n+\tap\t\targ pointer (doesn't really exist, always eliminated)\n+\tpr\t\tsubroutine return address\n+\tt               t bit\n+\tmach\t\tmultiply/accumulate result\n+\tmacl\n+*/\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   SH has 16 integer registers and 4 control registers + the arg\n+   pointer */\n+\n+#define FIRST_PSEUDO_REGISTER 22\n+\n+#define PR_REG   17\n+#define T_REG    18\n+#define GBR_REG  19\n+#define MACH_REG 20\n+#define MACL_REG 21\n+\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.  */\n+ /*  r0  r1  r2  r3  r4  r5  r6  r7  r8 \n+     r9  r10 r11 r12 r13 r14 r15 ap  pr  t   gbr mh   ml */\n+#define FIXED_REGISTERS  \\\n+   { 0,  0,  0,  0,  0,  0,  0,  0,  0, \t\t\\\n+     0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  1, 1,   1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+\n+ /*  r0  r1  r2  r3  r4  r5  r6  r7  r8 \n+     r9  r10 r11 r12 r13 r14 r15 ap  pr  t   gbr mh  ml */\n+#define CALL_USED_REGISTERS \\\n+   { 1,  1,  1,  1,  1,  1,  1,  1,  0, \\\n+     0,  0,  0,  1,  1,  0,  1,  1,  1,  1,  1, 1, 1}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On the SH regs are UNITS_PER_WORD bits wide; */\n+#define HARD_REGNO_NREGS(REGNO, MODE)  \\\n+   (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   We may keep double values in even registers */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)  \\\n+  ((TARGET_ALIGN_DOUBLE && GET_MODE_SIZE(MODE) > 4) ? (((REGNO)&1)==0) : 1)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  ((MODE1) == (MODE2) || GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Define this if the program counter is overloaded on a register.  */\n+/* #define PC_REGNUM\t\t15*/\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM\t15\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM\t14\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms may be accessed\n+   via the stack pointer) in functions that seem suitable.  */\n+#define FRAME_POINTER_REQUIRED\t0\n+\n+/* Definitions for register eliminations.\n+\n+   We have two registers that can be eliminated on the m88k.  First, the\n+   frame pointer register can often be eliminated in favor of the stack\n+   pointer register.  Secondly, the argument pointer register can always be\n+   eliminated; it is replaced with either the stack or frame pointer.  */\n+\n+/* This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.  */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM},}\n+\n+/* Given FROM and TO register numbers, say whether this elimination\n+   is allowed.  */\n+#define CAN_ELIMINATE(FROM, TO) \\\n+  (!((FROM) == FRAME_POINTER_REGNUM && FRAME_POINTER_REQUIRED))\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  OFFSET = initial_elimination_offset (FROM, TO)\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM\t16\n+\n+/* Register in which the static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM\t13\n+\n+/* If the structure value address is not passed in a register, define\n+   this as an expression returning an RTX for the place\n+   where the address is passed.  If it returns 0, the address is\n+   passed as an \"invisible\" first argument. */\n+\n+#define STRUCT_VALUE 0\n+\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+/* The SH has two sorts of general registers, R0 and the rest.  R0 can \n+   be used as the destination of some of the arithmetic ops. There are\n+   also some special purpose registers; the T bit register, the\n+   Procedure Return Register and the Multipy Accumulate Registers */\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  R0_REGS,\n+  GENERAL_REGS,\n+  PR_REGS,\n+  T_REGS,\n+  MAC_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES  (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+#define REG_CLASS_NAMES  \\\n+{\t\t\t\\\n+  \"NO_REGS\",\t\t\\\n+  \"R0_REGS\",\t\t\\\n+  \"GENERAL_REGS\",\t\\\n+  \"PR_REGS\",\t\t\\\n+  \"T_REGS\",\t\t\\\n+  \"MAC_REGS\",\t\t\\\n+  \"ALL_REGS\",\t\t\\\n+}\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS      \\\n+{\t\t\t\t\\\n+  0x000000,  /* NO_REGS      */\t\\\n+  0x000001,  /* R0_REGS      */\t\\\n+  0x01FFFF,  /* GENERAL_REGS */\t\\\n+  0x020000,  /* PR_REGS      */\t\\\n+  0x040000,  /* T_REGS       */\t\\\n+  0x300000,  /* MAC_REGS     */\t\\\n+  0x37FFFF   /* ALL_REGS     */\t\\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+extern int regno_reg_class[];\n+#define REGNO_REG_CLASS(REGNO) regno_reg_class[REGNO]\n+\n+/* The order in which register should be allocated.  */\n+#define REG_ALLOC_ORDER  \\\n+  { 1,2,3,0,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21}\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS  R0_REGS\n+#define BASE_REG_CLASS\t GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine \n+   description. */\n+extern enum reg_class reg_class_from_letter[];\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+   ( (C) >= 'a' && (C) <= 'z' ? reg_class_from_letter[(C)-'a'] : NO_REGS )\n+\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\tI: arithmetic operand -127..128, as used in add, sub, etc\n+\tL: logical operand 0..255, as used in add, or, etc.\n+\tM: constant 1\n+\tK: shift operand 1,2,8 or 16 */\n+\n+\n+#define CONST_OK_FOR_I(VALUE) ((VALUE)>= -128 && (VALUE) <= 127)\n+#define CONST_OK_FOR_L(VALUE) ((VALUE)>= 0 && (VALUE) <= 255)\n+#define CONST_OK_FOR_M(VALUE) ((VALUE)==1)\n+#define CONST_OK_FOR_K(VALUE) ((VALUE)==1||(VALUE)==2||(VALUE)==8||(VALUE)==16)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)     \\\n+     ((C) == 'I' ? CONST_OK_FOR_I (VALUE)   \\\n+    : (C) == 'L' ? CONST_OK_FOR_L (VALUE)   \\\n+    : (C) == 'M' ? CONST_OK_FOR_M (VALUE)   \\\n+    : (C) == 'K' ? CONST_OK_FOR_K (VALUE)   \\\n+    : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n+   ((C) == 'G' ? CONST_OK_FOR_I (CONST_DOUBLE_HIGH (VALUE)) \\\n+\t      && CONST_OK_FOR_I (CONST_DOUBLE_LOW (VALUE))  \\\n+    : 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)  (CLASS)\n+\n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) NO_REGS\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS. \n+\n+   On SH this is the size of MODE in words */\n+#define CLASS_MAX_NREGS(CLASS, MODE)  \\\n+     ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define the number of register that can hold parameters.\n+   These two macros are used only in other macro definitions below.  */\n+#define NPARM_REGS 4\n+#define FIRST_PARM_REG 4\n+#define FIRST_RET_REG 4\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD  \n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD \n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET  0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.  */\n+#define PUSH_ROUNDING(NPUSHED)  (((NPUSHED) + 3) & ~3)\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL)  0\n+\n+/* Value is the number of byte of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.\n+\n+   On the SH, the caller does not pop any of its arguments that were passed\n+   on the stack.  */\n+#define RETURN_POPS_ARGS(FUNTYPE, SIZE)  0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+    gen_rtx (REG, TYPE_MODE (VALTYPE), FIRST_RET_REG)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+#define LIBCALL_VALUE(MODE)  \\\n+    gen_rtx (REG, MODE, FIRST_RET_REG)\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the SH, only r4 can return results.  */\n+#define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n+\t  ((REGNO) == FIRST_RET_REG)\n+\n+/* 1 if N is a possible register number for function argument passing.*/\n+\n+#define FUNCTION_ARG_REGNO_P(REGNO)  \\\n+  ((REGNO) >= FIRST_PARM_REG && (REGNO) < (NPARM_REGS + FIRST_PARM_REG))\n+\n+\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On SH, this is a single integer, which is a number of words\n+   of arguments scanned so far (including the invisible argument,\n+   if any, which holds the structure-value-address).\n+   Thus NARGREGS or more means all following args should go on the stack.  */\n+\n+#define CUMULATIVE_ARGS  int\n+\n+#define ROUND_ADVANCE(SIZE)\t\\\n+  ((SIZE + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Round a register number up to a proper boundary for an arg of mode \n+   MODE. \n+   \n+   We round to an even reg for things larger than a word */\n+\n+#define ROUND_REG(X, MODE) \t\t\t\t\t\\\n+  ((TARGET_ALIGN_DOUBLE \t\t\t\t\t\\\n+   && GET_MODE_UNIT_SIZE ((MODE)) > UNITS_PER_WORD) \t\t\\\n+   ? ((X) + ((X) & 1)) : (X))\n+\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On SH, the offset always starts at 0: the first parm reg is always\n+   the same reg.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME)  \\\n+  ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be\n+   available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) = (ROUND_REG ((CUM), (MODE))\t\t\t\\\n+\t   + ((MODE) != BLKmode\t\t\t\t\\\n+\t      ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\\\n+\t      : ROUND_ADVANCE (int_size_in_bytes (TYPE)))))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+\n+   On SH the first args are normally in registers\n+   and the rest are pushed.  Any arg that starts within the first\n+   NPARM_REGS words is at least partially passed in a register unless\n+   its data type forbids.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+  (NAMED && ROUND_REG ((CUM), (MODE)) < NPARM_REGS\t\t\\\n+   && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\\\n+   && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\\\n+       || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\\\n+   ? gen_rtx (REG, (MODE),\t\t\t\t\t\\\n+  \t    (FIRST_PARM_REG + ROUND_REG ((CUM), (MODE))))\t\\\n+   : 0)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.\n+   Any arg that starts in the first NPARM_REGS regs but won't entirely\n+   fit in them needs partial registers on the SH.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \t\t\\\n+  ((ROUND_REG ((CUM), (MODE)) < NPARM_REGS\t\t\t\t\\\n+    && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n+    && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\\\n+\t|| (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\\\n+    && (ROUND_REG ((CUM), (MODE))\t\t\t\t\t\\\n+\t+ ((MODE) == BLKmode\t\t\t\t\t\t\\\n+\t   ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\t\t\\\n+\t   : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))) - NPARM_REGS > 0)\t\\\n+   ? (NPARM_REGS - ROUND_REG ((CUM), (MODE)))\t\t\t\t\\\n+   : 0)\n+\n+extern int current_function_anonymous_args;\n+\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments. */\n+\n+#define SETUP_INCOMING_VARARGS(ASF, MODE, TYPE, PAS, ST) \\\n+  current_function_anonymous_args = 1;\n+\n+\n+/* Generate assembly output for the start of a function.  */\n+\n+#define FUNCTION_PROLOGUE(STREAM, SIZE)  \\\n+  output_prologue ((STREAM), (SIZE))\n+\n+/* Call the function profiler with a given profile label. */\n+\n+#define FUNCTION_PROFILER(STREAM,LABELNO)  \t\t\\\n+{\t\t\t\t\t\t\t\\\n+    fprintf(STREAM, \"\\tsts.l\tpr,@-r15\\n\");\t\t\\\n+    fprintf(STREAM, \"\\tjsr\\tmcount\\n\");\t\t\t\\\n+    fprintf(STREAM, \"\\tor\tr0,r0\\n\");\t\t\\\n+    fprintf(STREAM, \"\\t.long\\tLP%d\\n\", (LABELNO));\t\\\n+}\n+\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 0\n+\n+/* Generate the assembly code for function exit. */\n+\n+#define FUNCTION_EPILOGUE(STREAM, SIZE)  \\\n+  output_epilogue ((STREAM), (SIZE))\n+\n+#define ELIGIBLE_FOR_EPILOGUE_DELAY(INSN,N) \\\n+  (get_attr_in_delay_slot(INSN) == IN_DELAY_SLOT_YES)  \n+\n+#define DELAY_SLOTS_FOR_EPILOGUE \\\n+  delay_slots_for_epilogue();\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   On the SH, the trapoline looks like\n+   1 0000 D301     \t\tmov.l\tl1,r3\n+   2 0002 DD02     \t   \tmov.l\tl2,r13\n+   3 0004 4D2B     \t\tjmp\t@r13\n+   4 0006 200B     \t\tor\tr0,r0\n+   5 0008 00000000 \tl1:  \t.long   function\n+   6 000c 00000000 \tl2:\t.long   area\t\n+*/\n+#define TRAMPOLINE_TEMPLATE(FILE)  \t\t\\\n+{\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\t.word\t0xd301\\n\");\t\\\n+  fprintf ((FILE), \"\t.word\t0xdd02\\n\");\t\\\n+  fprintf ((FILE), \"\t.word\t0x4d2b\\n\");        \\\n+  fprintf ((FILE), \"\t.word\t0x200b\\n\");\t\\\n+  fprintf ((FILE), \"\t.long\t0\\n\");\t\t\\\n+  fprintf ((FILE), \"\t.long\t0\\n\");\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+#define TRAMPOLINE_SIZE  16\n+\n+/* Alignment required for a trampoline in units.  */\n+#define TRAMPOLINE_ALIGN  4\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 8)),\t\\\n+\t\t  (CXT));\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 12)),\t\\\n+\t\t  (FNADDR));\t\t\t\t\t\t\\\n+}\n+\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/*#define HAVE_POST_INCREMENT  1*/\n+/*#define HAVE_PRE_INCREMENT   1*/\n+/*#define HAVE_POST_DECREMENT  1*/\n+/*#define HAVE_PRE_DECREMENT   1*/\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.\n+\n+*/\n+#define REGNO_OK_FOR_BASE_P(REGNO)  \\\n+  ((REGNO) < PR_REG || (unsigned) reg_renumber[(REGNO)] < PR_REG)\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO)   ((REGNO)==0)\n+\n+/* Maximum number of registers that can appear in a valid memory \n+   address. */\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X) \t\\\n+  (GET_CODE (X) == LABEL_REF)\n+#if 0\n+\n+   || GET_CODE (X) == SYMBOL_REF\t\\\n+   || GET_CODE (X) == CONST_INT \t\\\n+   || GET_CODE (X) == CONST)\n+\n+#endif\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n+\n+   On the SH, allow any thing but a double */\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+  (GET_CODE (X) != CONST_DOUBLE || GET_MODE (X) == VOIDmode)\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.  */\n+\n+#ifndef REG_OK_STRICT\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) \\\n+  (REGNO(X) <= 16 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) \\\n+    (REGNO(X)==0||REGNO(X)>=FIRST_PSEUDO_REGISTER)\n+#define REG_OK_FOR_PRE_POST_P(X) (REGNO(X) <= 16)\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X)  REGNO_OK_FOR_BASE_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X)  REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#define REG_OK_FOR_PRE_POST_P(X)  \\\n+\t (REGNO (X) <= 16 || (unsigned) reg_renumber[REGNO (X)] <=16)\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n+#define BASE_REGISTER_RTX_P(X)  \\\n+  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n+\n+#define INDEX_REGISTER_RTX_P(X)  \\\n+  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n+\n+\n+/* Jump to LABEL if X is a valid address RTX.  This must also take\n+   REG_OK_STRICT into account when deciding about valid registers, but it uses\n+   the above macros so we are in luck.  \n+ \n+   Allow  REG\n+\t  REG+disp\n+\t  REG+r0\n+\t  REG++\n+\t  --REG\n+*/\n+\n+/* A legitimate index for a QI or HI is 0, SI and above can be any \n+   number 0..64 */\n+\n+#define GO_IF_LEGITIMATE_INDEX(MODE, REGNO, OP, LABEL)  \\\n+  do {\t\t\t\t\t\t\t\\\n+    if (GET_CODE (OP) == CONST_INT) \t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (GET_MODE_SIZE (MODE) < 4 && INTVAL(OP) == 0)\\\n+\t  goto LABEL;\t\t\t\t\t\\\n+\tif (GET_MODE_SIZE (MODE) >=4 \t\t\t\\\n+\t    && ((unsigned)INTVAL(OP)) < 64)\t\t\\\n+\t  goto LABEL;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  } while(0)\n+\n+\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx xop0 = XEXP(X,0);\t\t\t\t\t\t\\\n+      rtx xop1 = XEXP(X,1);\t\t\t\t\t\t\\\n+      if (BASE_REGISTER_RTX_P (xop0))\t\t\t\t\t\\\n+\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL);\t\\\n+      else if (BASE_REGISTER_RTX_P (xop1))\t\t\t\t\\\n+\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_DEC)\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+}\n+\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   On the SH we don't try anything */\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)  ;\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE(ADDR) == PRE_DEC || GET_CODE(ADDR) == POST_DEC\t\t\\\n+      || GET_CODE(ADDR) == PRE_INC || GET_CODE(ADDR) == POST_INC)\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR  FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR  TRUNC_DIV_EXPR\n+\n+/* 'char' is signed by default */\n+#define DEFAULT_SIGNED_CHAR  1\n+\n+/* The type of size_t unsigned int.  */\n+#define SIZE_TYPE \"unsigned int\"\n+\n+/* Don't cse the address of the function being compiled.  */\n+#define NO_RECURSIVE_FUNCTION_CSE 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* Define if normal loads of shorter-than-word items from sign extends\n+   the rest of the bigs in the register. */\n+#define BYTE_LOADS_SIGN_EXTEND  1\n+\n+/* Define this if zero-extension is slow (more than one real instruction).\n+   On the SH, it's only one instruction */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* Immediate shift counts are truncated by the output routines (or was it\n+   the assembler?).  Shift counts in a register are truncated by ARM.  Note\n+   that the native compiler puts too large (> 32) immediate shift counts\n+   into a register and shifts by the register, letting the ARM decide what\n+   to do instead of doing that itself.  */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* We have the vprintf function.  */\n+#define HAVE_VPRINTF 1\n+\n+/* All integers have the same format so truncation is easy.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC)  1\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+/*#define NO_FUNCTION_CSE 1*/\n+\n+/* Chars and shorts should be passed as ints.  */\n+#define PROMOTE_PROTOTYPES 1\n+\n+/* The machine modes of pointers and functions */\n+#define Pmode  SImode\n+#define FUNCTION_MODE  Pmode\n+\n+/* The structure type of the machine dependent info field of insns\n+   No uses for this yet.  */\n+/* #define INSN_MACHINE_INFO  struct machine_info  */\n+\n+/* The relative costs of various types of constants.  Note that cse.c defines\n+   REG = 1, SUBREG = 2, any node = (2 + sum of subnodes).  */\n+\n+#define CONST_COSTS(RTX, CODE, OUTER_CODE)      \\\n+  case CONST_INT:\t\t\t\t\\\n+    if (CONST_OK_FOR_I (INTVAL(RTX)))           \\\n+      return 1;\t\t\t\t\t\\\n+    else\t\t\t\t\t\\\n+      return 5;\t\t\t\t\t\\\n+  case CONST: \t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\\\n+    return 6;\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\\\n+      return 10;\n+\n+#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (TARGET_HAS_MULSI3 ? 2 : 20); \t\\\n+  case DIV:\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (100);\t\t\t\t\\\n+  case FLOAT:\t\t\t\t\t\t\\\n+  case FIX:\t\t\t\t\t\t\\\n+    return 100;\n+\n+/* Compute extra cost of moving data between one register class\n+   and another.  \n+\n+   On the SH it is hard to move into the T reg, but simple to load\n+   from it.\n+*/\n+\n+#define REGISTER_MOVE_COST(SRCCLASS, DSTCLASS)  \\\n+    ((DSTCLASS ==T_REGS) ? 10 : 2)\n+\f\n+/* Assembler output control */\n+\n+/* The text to go at the start of the assembler file */\n+#define ASM_FILE_START(STREAM) \\\n+  fprintf (STREAM,\"! GCC for the Hitachi Super-H\\n\");  \t\\\n+  output_file_directive (STREAM, main_input_filename);\n+\n+#define ASM_APP_ON  \"\"\n+#define ASM_APP_OFF  \"\"\n+\n+#define FILE_ASM_OP \"\\t.file\\n\"\n+#define IDENT_ASM_OP \"\\t.ident\\n\"\n+\n+\n+/* Switch to the text or data segment.  */\n+#define TEXT_SECTION_ASM_OP  \".text\"\n+#define DATA_SECTION_ASM_OP  \".data\"\n+\n+/* The assembler's names for the registers.  RFP need not always be used as\n+   the Real framepointer; it can also be used as a normal general register.\n+   Note that the name `fp' is horribly misleading since `fp' is in fact only\n+   the argument-and-return-context pointer.  */\n+#define REGISTER_NAMES  \t\t\t\t\\\n+{\t\t\t\t                   \t\\\n+  \"r0\", \"r1\", \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\", \t\\\n+  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\\\n+  \"ap\", \"pr\", \"t\",  \"gbr\", \"mach\",\"macl\" \t\t\\\n+}\n+\n+/* DBX register number for a given compiler register number */\n+#define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n+\n+/* Output a label definition.  */\n+#define ASM_OUTPUT_LABEL(FILE,NAME)  \\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", LOG)\n+\n+/* Output a function label definition.  */\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL) \\\n+    ASM_OUTPUT_LABEL(STREAM, NAME)\n+\n+/* Output a globalising directive for a label.  */\n+#define ASM_GLOBALIZE_LABEL(STREAM,NAME)  \\\n+  (fprintf (STREAM, \"\\t.global\\t\"),\t  \\\n+   assemble_name (STREAM, NAME),\t  \\\n+   fputc ('\\n',STREAM))                   \\\n+\n+/* Output a reference to a label.  */\n+#define ASM_OUTPUT_LABELREF(STREAM,NAME)  \\\n+  fprintf (STREAM, \"_%s\", NAME)\n+\n+/* Make an internal label into a string.  */\n+#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)  \\\n+  sprintf (STRING, \"*%s%d\", PREFIX, NUM)\n+\n+/* Output an internal label definition.  */\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* Nothing special is done about jump tables */\n+/* #define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE)   */\n+/* #define ASM_OUTPUT_CASE_END(STREAM,NUM,TABLE)\t    */\n+\n+/* Construct a private name.  */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)  \\\n+  ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),  \\\n+   sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n+\n+/* Output a relative address. Not needed since jump tables are absolute\n+   but we must define it anyway.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)  \\\n+  fputs (\"- - - ASM_OUTPUT_ADDR_DIFF_ELT called!\\n\", STREAM)\n+\n+/* Output an element of a dispatch table.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \\\n+    fprintf (STREAM, \"\\t.long\\tL%d\\n\", VALUE)\n+\n+/* Output various types of constants.  */\n+\n+\n+/* This is how to output an assembler line defining a `double' */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tlong t[2];\t\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\t\\\n+\tfprintf (FILE, \"\\t.long\\t0x%lx\\n\\t.long\\t0x%lx\\n\",\t\t\\\n+\t\t  t[0], t[1]);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+\tlong t;\t\t\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\t\\\n+\tfprintf (FILE, \"\\t.long\\t0x%lx\\n\", t);\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+#define ASM_OUTPUT_INT(STREAM, EXP)  \t\\\n+  (fprintf (STREAM, \"\\t.long\\t\"),      \t\\\n+   output_addr_const (STREAM, (EXP)),  \t\\\n+   fputc ('\\n', STREAM))\t\t\n+\n+#define ASM_OUTPUT_SHORT(STREAM, EXP)  \\\n+  (fprintf (STREAM, \"\\t.short\\t\"),     \\\n+   output_addr_const (STREAM, (EXP)),  \\\n+   fputc ('\\n', STREAM))\t\t\n+\n+#define ASM_OUTPUT_CHAR(STREAM, EXP)  \t\\\n+  (fprintf (STREAM, \"\\t.byte\\t\"),      \t\\\n+   output_addr_const (STREAM, (EXP)),  \t\\\n+   fputc ('\\n', STREAM))\n+\n+#define ASM_OUTPUT_BYTE(STREAM, VALUE)  \t\\\n+  fprintf (STREAM, \"\\t.byte\\t%d\\n\", VALUE)  \t\\\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\t.comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)\t\\\n+( fputs (\"\\t.lcomm \", (FILE)),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+\n+/* The assembler's parentheses characters.  */\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Target characters.  */\n+#define TARGET_BELL\t007\n+#define TARGET_BS\t010\n+#define TARGET_TAB\t011\n+#define TARGET_NEWLINE\t012\n+#define TARGET_VT\t013\n+#define TARGET_FF\t014\n+#define TARGET_CR\t015\n+\f\n+\n+/* Only perform branch elimination (by making instructions conditional) if\n+   we're optimising.  Otherwise it's of no use anyway.  */\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)  \\\n+    final_prescan_insn (INSN, OPVEC, NOPERANDS)\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+#define PRINT_OPERAND(STREAM, X, CODE)  print_operand (STREAM, X, CODE)\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(STREAM,X)  print_operand_address (STREAM, X)\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n+  ((CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR) == '!')\n+\n+\f\n+/* Define the information needed to generate branch insns.  This is stored\n+   from the compare operation.  Note that we can't use \"rtx\" here since it\n+   hasn't been defined!  */\n+\n+extern struct rtx_def *sh_compare_op0;\n+extern struct rtx_def *sh_compare_op1;\n+extern struct rtx_def *prepare_scc_operands();\n+\n+\n+\n+/* Declare functions defined in sh.c and used in templates. */\n+\n+extern char *output_branch();\n+extern char *output_shift();\n+extern char *output_movedouble();\n+extern char *output_movepcrel();\n+\n+\n+#define ADJUST_INSN_LENGTH(insn, length) \\\n+  adjust_insn_length (insn, insn_lengths)"}, {"sha": "c28cda9f6b531beb4c7a810b6845caae79396f2c", "filename": "gcc/config/sh/sh.md", "status": "added", "additions": 1262, "deletions": 0, "changes": 1262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc45ade3d6886f8d72864d114eb62e8287eede36/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc45ade3d6886f8d72864d114eb62e8287eede36/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=bc45ade3d6886f8d72864d114eb62e8287eede36", "patch": "@@ -0,0 +1,1262 @@\n+;;- Machine description the Hitachi SH\n+;;  Copyright (C) 1993 Free Software Foundation, Inc.\n+;;  Contributed by Steve Chamberlain (sac@cygnus.com)\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+\n+\n+;; -------------------------------------------------------------------------\n+;; Attributes\n+;; -------------------------------------------------------------------------\n+\n+(define_attr \"type\" \"cbranch,ctable,jump,arith,other\"\n+  (const_string \"other\"))\n+\n+; If a conditional branch destination is within -100..100 bytes away \n+; from the instruction it can be 2 bytes long.  Something in the\n+; range -4000..4000 bytes can be 6 bytes long, all other conditional\n+; branches are 8 bytes long.\n+\n+; An unconditional jump which can reach forward or back 4k can be \n+; 6 bytes long (including the delay slot).  If it is too big, it\n+; must be 8 bytes long.\n+\n+; All other instructions are two bytes long by default.\n+\n+(define_attr \"length\" \"\" \n+  (cond [(eq_attr \"type\" \"cbranch\")\n+\t  (if_then_else (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t (const_int -100))\n+\t\t\t     (le (minus (pc) (match_dup 0))\n+\t\t\t\t (const_int 100)))\n+\t\t\t(const_int 2)\n+\t\t\t(if_then_else (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t\t       (const_int -4000))\n+\t\t\t\t\t   (le (minus (pc) (match_dup 0))\n+\t\t\t\t\t       (const_int 4000)))\n+\t\t\t\t      (const_int 6)\n+\t\t\t\t      (const_int 8)))\n+\n+\t (eq_attr \"type\" \"jump\")\n+\t\t\t(if_then_else (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t\t       (const_int -4000))\n+\t\t\t\t\t   (le (minus (pc) (match_dup 0))\n+\t\t\t\t\t       (const_int 4000)))\n+\t\t\t\t      (const_int 4)\n+\t\t\t\t      (const_int 6))\n+\t ] (const_int 2)))\n+\t\t\t\t      \n+\n+(define_attr \"needs_delay_slot\" \"yes,no\"\n+  (cond [(eq_attr \"type\" \"jump\") (const_string \"yes\")]\n+\t(const_string \"no\")))\n+\n+(define_attr \"dump\" \"yes,no,must\" (const_string \"no\"))\n+(define_attr \"constneed\" \"yes,no\" (const_string \"no\"))\n+(define_attr \"smallestsize\" \"\" (const_int 2))\n+(define_attr \"largestsize\" \"\" (const_int 8))\n+(define_attr \"constantsize\" \"\" (const_int 4))\n+\n+(define_attr \"in_delay_slot\" \"maybe,yes,no\" \n+  (cond [(eq_attr \"type\" \"cbranch\") (const_string \"no\")\n+\t (eq_attr \"type\" \"jump\") (const_string \"no\")\n+\t (eq_attr \"length\" \"2\") (const_string \"yes\")\n+\t (eq_attr \"length\" \"4,6,8,10,12\") (const_string \"no\")\n+\t ] (const_string \"yes\")))\n+\n+\n+(define_delay (eq_attr \"needs_delay_slot\" \"yes\")\n+  [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n+\n+\n+\f\n+;; -------------------------------------------------------------------------\n+;; SImode signed integer comparisons\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(eq:SI (reg:SI 18)\n+\t       (const_int 1)))]\n+  \"\"\n+  \"movt\t%0 !movt1\")\n+  \n+(define_insn \"\"\n+  [(set (reg:SI 18) (gt (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t  (const_int 0)))]\n+  \"\"\n+  \"cmp/pl\t%0\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 18) (ge (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t  (const_int 0)))]\n+  \"\"\n+  \"cmp/pz\t%0\")\n+\n+(define_insn \"cmpeqsi_t\"\n+  [(set (reg:SI 18) (eq (match_operand:SI 0 \"register_operand\" \"r,z\")\n+\t\t  (match_operand:SI 1 \"arith_operand\" \"r,I\")))]\n+  \"\"\n+  \"cmp/eq\t%1,%0\")\n+\n+\n+(define_insn \"cmpgtsi_t\"\n+  [(set (reg:SI 18) (gt (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"cmp/gt\t%1,%0\")\n+\n+(define_insn \"cmpgesi_t\"\n+  [(set (reg:SI 18) (ge (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"cmp/ge\t%1,%0\")\n+\n+(define_insn \"cmpltsi_t\"\n+  [(set (reg:SI 18) (lt (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"cmp/gt\t%0,%1\")\n+\n+(define_insn \"cmplesi_t\"\n+  [(set (reg:SI 18) (le (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"cmp/ge\t%0,%1\")\n+\n+\f\n+;; -------------------------------------------------------------------------\n+;; SImode unsigned integer comparisons\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"cmpgeusi_t\"\n+  [(set (reg:SI 18) (geu (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"cmp/hs\t%1,%0\")\n+\n+(define_insn \"cmpgtusi_t\"\n+  [(set (reg:SI 18) (gtu (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"cmp/hi\t%1,%0\")\n+\n+(define_insn \"cmpleusi_t\"\n+  [(set (reg:SI 18) (leu (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"cmp/hs\t%0,%1\")\n+\n+(define_insn \"cmpltusi_t\"\n+  [(set (reg:SI 18) (ltu (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"cmp/hi\t%0,%1\")\n+\n+;; We save the compare operands in the cmpxx patterns and use them when\n+;; we generate the branch.\n+\n+(define_expand \"cmpsi\"\n+  [(set (reg:SI 18) (compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t     (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{ sh_compare_op0 = operands[0];\n+  sh_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+\f\n+;; -------------------------------------------------------------------------\n+;; Addition instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  \"clrt\\;addc\t%R2,%R0\\;addc\t%2,%0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"type\" \"arith\")])\n+\n+\n+(define_insn \"addsi3_i\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"add\t%2,%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"arith\")])\n+\n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"\"\n+  \"\")\n+\n+\f\n+;; -------------------------------------------------------------------------\n+;; Subtraction instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  \"clrt\\;subc\t%R2,%R0\\;subc\t%2,%0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"type\" \"arith\")])\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sub\t%2,%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+\f\n+;; -------------------------------------------------------------------------\n+;; Multiplication instructions\n+;; -------------------------------------------------------------------------\n+\n+\n+(define_insn \"\"\n+  [(set (reg:SI 21)\n+\t(mult:SI (zero_extend:SI\n+\t\t  (match_operand:HI 1 \"register_operand\" \"r\"))\n+\t\t (zero_extend:SI\n+\t\t  (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"mulu\t%2,%1\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 21)\n+\t(mult:SI (sign_extend:SI\n+\t\t  (match_operand:HI 1 \"register_operand\" \"r\"))\n+\t\t (sign_extend:SI\n+\t\t  (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"muls\t%2,%1\")\n+\n+(define_expand \"mulhisi3\"\n+  [(set (reg:SI 21)\n+\t(mult:SI (sign_extend:SI\n+\t\t  (match_operand:HI 1 \"register_operand\" \"r\"))\n+\t\t (sign_extend:SI\n+\t\t  (match_operand:HI 2 \"register_operand\" \"r\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(reg:SI 21))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"umulhisi3\"\n+  [(set (reg:SI 21)\n+\t(mult:SI (zero_extend:SI\n+\t\t  (match_operand:HI 1 \"register_operand\" \"r\"))\n+\t\t (zero_extend:SI\n+\t\t  (match_operand:HI 2 \"register_operand\" \"r\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(reg:SI 21))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 21)\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_HAS_MULSI3\"\n+  \"muls.l\t%2,%1\")\n+\n+(define_expand \"mulsi3\"\n+  [(set (reg:SI 21)\n+\t(mult:SI  (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(reg:SI 20))]\n+  \"TARGET_HAS_MULSI3\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (reg:DI 20)\n+\t(mult:DI (sign_extend:DI\n+\t\t  (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t (sign_extend:DI\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_HAS_MULSI3\"\n+  \"dmuls.l\t%2,%1\")\n+\n+(define_expand \"mulsidi3\"\n+  [(set (reg:DI 20)\n+\t(mult:DI (sign_extend:DI\n+\t\t  (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t (sign_extend:DI\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(reg:DI 20))]\n+  \"TARGET_HAS_MULSI3\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (reg:DI 20)\n+\t(mult:DI (zero_extend:DI\n+\t\t  (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t (zero_extend:DI\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_HAS_MULSI3\"\n+  \"dmulu.l\t%2,%1\")\n+\n+(define_expand \"umulsidi3\"\n+  [(set (reg:DI 20)\n+\t(mult:DI (zero_extend:DI\n+\t\t  (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t (zero_extend:DI\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(reg:DI 20))]\n+  \"TARGET_HAS_MULSI3\"\n+  \"\")\n+\f\n+;; -------------------------------------------------------------------------\n+;; Logical operations\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,z\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"logical_operand\" \"r,L\")))]\n+  \"\"\n+  \"and\t%2,%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,z\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"logical_operand\" \"r,L\")))]\n+  \"\"\n+  \"or\t%2,%0\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,z\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"logical_operand\" \"r,L\")))]\n+  \"\"\n+  \"xor\t%2,%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+\f\n+;; -------------------------------------------------------------------------\n+;; Shifts and rotates\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"ashlsi3_k\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"L,n\")))]\n+  \"\"\n+  \"*return output_shift(\\\"shll\\\", operands[0], operands[2]);\"\n+  [(set_attr \"length\" \"2,12\")\n+   (set_attr \"in_delay_slot\" \"yes,no\")\n+   (set_attr \"type\" \"arith\")])\n+\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"if (!ok_shift_value(operands[2])) FAIL;\")\n+\n+(define_insn \"ashrsi3_k\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"shar\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"M\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT ||\n+      INTVAL (operands[2]) != 1) FAIL;\n+}\n+\")\n+\n+(define_insn \"lshrsi3_k\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"L\")))]\n+  \"\"\n+  \"* return output_shift (\\\"shlr\\\", operands[0], operands[2]);\"\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"type\" \"arith\")])\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"if (!ok_shift_value (operands[2])) FAIL; \")\n+\n+(define_insn \"ashldi3_k\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:DI 2 \"immediate_operand\" \"I\")))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  \"shll\t%R0\\;rotcl\t%0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_expand \"ashldi3\"\n+  [(parallel[(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t  (ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t     (match_operand:DI 2 \"immediate_operand\" \"\")))\n+\t     (clobber (reg:SI 18))])]\n+\t    \n+  \"\"\n+  \"{ if (GET_CODE (operands[2]) != CONST_INT \t\n+\t|| INTVAL (operands[2]) != 1) FAIL;} \")\n+\n+(define_insn \"lshrdi3_k\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t\t   (lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t\t      (match_operand:DI 2 \"immediate_operand\" \"I\")))\n+      (clobber (reg:SI 18))]\n+  \"\"\n+  \"shlr\t%0\\;rotcr\t%R0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_expand \"lshrdi3\"\n+  [(parallel[(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t  (lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t       (match_operand:DI 2 \"immediate_operand\" \"\")))\n+\t     (clobber (reg:SI 18))])]\n+  \"\"\n+  \"{ if (GET_CODE (operands[2]) != CONST_INT \n+\t|| INTVAL (operands[2]) != 1) FAIL;} \")\n+\n+(define_insn \"ashrdi3_k\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:DI 2 \"immediate_operand\" \"\")))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  \"shar\t%0\\;rotcr\t%R0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_expand \"ashrdi3\"\n+  [(parallel[(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t  (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t       (match_operand:DI 2 \"immediate_operand\" \"\")))\n+\t     (clobber (reg:SI 18))])]\n+  \"\"\n+  \"{ if (GET_CODE (operands[2]) != CONST_INT \n+\t|| INTVAL (operands[2]) != 1) FAIL; } \")\n+\n+\n+\f\n+;; -------------------------------------------------------------------------\n+;; Unary arithmetic\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"0\")))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  \"clrt\\;negc\t%R1,%R0\\;negc\t%1,%0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"type\" \"arith\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"neg\t%1,%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"not\t%1,%0\"\n+[  (set_attr \"type\" \"arith\")])\n+\n+\f\n+;; -------------------------------------------------------------------------\n+;; Zero extension instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"extu.w\t%1,%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"extu.b\t%1,%0\"\n+  [(set_attr \"type\" \"arith\")]) \n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"extu.b\t%1,%0\"\n+  [(set_attr \"type\" \"arith\")]) \n+\n+\f\n+;; -------------------------------------------------------------------------\n+;; Sign extension instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"mov\t%1,%0\\;shll\t%0\\;subc\t%0,%0\"\n+  [(set_attr \"length\" \"6\")]) \n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"exts.w\t%1,%0\")\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"exts.b\t%1,%0\")\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"exts.b\t%1,%0\")\n+\n+\f\n+;; -------------------------------------------------------------------------\n+;; Move instructions\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))]\n+   \"\"\n+   \"mov.l\t%1,%0\")\n+\n+(define_insn \"movsi_pcrel\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"hard_immediate_operand\" \"i\"))]\n+  \"\"\n+  \"* return output_movepcrel (insn, operands, SImode);\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"constneed\" \"yes\")\n+   (set_attr \"smallestsize\" \"2\")\n+   (set_attr \"largestsize\" \"8\")])\n+\t\t\n+(define_insn \"movsi_i\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,m,l,r,r,r,t\")\n+\t(match_operand:SI 1 \"general_operand\"  \"r,I,m,r,r,l,t,x,r\"))]\n+  \"\"\n+  \"@\n+\tmov\t%1,%0\n+\tmov\t%1,%0\n+\tmov.l\t%1,%0\n+\tmov.l\t%1,%0\n+\tmov\t%1,%0\n+\tmov\t%1,%0\n+        movt\t%0\n+\tsts\t%1,%0\n+\ttst\t%1,%1\\;bt\tT%*\\;bra\tF%*\\;sett\\;T%*:clrt\\;F%*:%^\"\n+\t[(set_attr \"length\" \"2,2,2,2,2,2,2,2,10\")])\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"{ prepare_move_operands(operands, SImode); } \")\n+\n+(define_insn \"movqi_i\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,z,m,r,m,r,r\")\n+\t(match_operand:QI 1 \"general_operand\"  \"r,n,m,z,m,r,x,t\"))]\n+  \"\"\n+  \"@\n+\tmov\t%1,%0\n+\tmov\t%1,%0\n+\tmov.b\t%1,%0 !4\n+\tmov.b\t%1,%0 !5\n+\tmov.b\t%1,%0 !6\n+\tmov.b\t%1,%0 ! 7\n+\tsts\t%1,%0\n+\tmovt\t%0\")\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\"  \"\"))]\n+  \"\"\n+  \"prepare_move_operands(operands, QImode);\")\n+  \n+(define_insn \"movhi_pcrel\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_operand:HI 1 \"hard_immediate_operand\" \"i\"))]\n+  \"\"\n+  \"* return output_movepcrel (insn, operands, SImode);\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"constneed\" \"yes\")\n+   (set_attr \"smallestsize\" \"2\")\n+   (set_attr \"largestsize\" \"8\")])\n+\n+(define_insn \"movhi_i\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,m,z,m,r,r\")\n+\t(match_operand:HI 1 \"general_operand\"  \"rI,m,r,m,z,x,t\"))]\n+  \"\"\n+  \"@\n+\tmov\t%1,%0\n+\tmov.w\t%1,%0\n+\tmov.w\t%1,%0\n+\tmov.w\t%1,%0\n+\tmov.w\t%1,%0\n+\tsts\t%1,%0\n+\tmovt\t%0\")\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\"  \"\"))]\n+  \"\"\n+  \"prepare_move_operands (operands, HImode);\")\n+  \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n+\t(match_operand:DI 1 \"register_operand\" \"r\"))]\n+   \"\"\n+   \"mov.l\t%R1,%0\\;mov.l\t%1,%0\"\n+   [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"movdi_pcrel\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"hard_immediate_operand\" \"i\"))]\n+  \"\"\n+  \"* return output_movepcrel (insn, operands, DImode);\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"constneed\" \"yes\")\n+   (set_attr \"smallestsize\" \"4\")\n+   (set_attr \"constantsize\" \"8\")\n+   (set_attr \"largestsize\" \"18\")])\n+\n+(define_insn \"movdi_k\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=r,r,m,r,r,m,r\")\n+\t(match_operand:DI 1 \"general_operand\" \"r,m,r,I,m,r,x\"))]\n+  \"\"\n+  \"* return output_movedouble(operands, DImode);\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"prepare_move_operands (operands, DImode);\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<\")\n+\t(match_operand:DF 1 \"register_operand\" \"r\"))]\n+   \"\"\n+   \"mov.l\t%R1,%0\\;mov.l\t%1,%0\"\n+   [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"movdf_pcrel\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(match_operand:DF 1 \"hard_immediate_operand\" \"i\"))]\n+  \"\"\n+  \"* return output_movepcrel  (insn, operands, DFmode);\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"constneed\" \"yes\")\n+   (set_attr \"smallestsize\" \"4\")\n+   (set_attr \"constantsize\" \"8\")\n+   (set_attr \"largestsize\" \"18\")])\n+\n+(define_insn \"movdf_k\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=r,r,m\")\n+\t(match_operand:DF 1 \"general_operand\" \"r,m,r\"))]\n+  \"\"\n+  \"* return output_movedouble(operands, DFmode);\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"prepare_move_operands(operands, DFmode);\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"push_operand\" \"=<\")\n+\t(match_operand:SF 1 \"register_operand\" \"r\"))]\n+   \"\"\n+   \"mov.l\t%1,%0\")\n+\n+(define_insn \"movsf_pcrel\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(match_operand:SF 1 \"hard_immediate_operand\" \"i\"))]\n+  \"\"\n+  \"* return output_movepcrel (insn, operands, SFmode);\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"constneed\" \"yes\")\n+   (set_attr \"smallestsize\" \"2\")\n+   (set_attr \"largestsize\" \"8\")])\n+\t\t\n+(define_insn \"movsf_i\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=r,r,r,m,l,r,m,r\")\n+\t(match_operand:SF 1 \"general_operand\"  \"r,I,m,r,r,l,r,m\"))]\n+  \"\"\n+  \"@\n+\tmov\t%1,%0\n+\tmov\t%1,%0\n+\tmov.l\t%1,%0\n+\tmov.l\t%1,%0\n+\tmov\t%1,%0\n+\tmov\t%1,%0\n+\tmov\t%1,%0\n+\tmov\t%1,%0\")\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"prepare_move_operands(operands, SFmode);\")\n+\n+\f\n+;; ------------------------------------------------------------------------\n+;; Define the real conditional branch instructions.\n+;; ------------------------------------------------------------------------\n+\n+(define_insn \"branch_true\"\n+  [(set (pc) (if_then_else (eq (reg:SI 18) (const_int 1))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"* return output_branch (1, insn);\"\n+  [(set_attr \"type\" \"cbranch\")])\n+\n+(define_insn \"branch_false\"\n+  [(set (pc) (if_then_else (ne (reg:SI 18) (const_int 1))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"* return output_branch (0, insn);\"\n+  [(set_attr \"type\" \"cbranch\")])\n+\n+(define_insn \"inverse_branch_true\"\n+  [(set (pc) (if_then_else (eq (reg:SI 18) (const_int 1))\n+\t\t\t   (pc)\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_branch (0, insn);\"\n+  [(set_attr \"type\" \"cbranch\")])\n+\n+(define_insn \"inverse_branch_false\"\n+  [(set (pc) (if_then_else (ne (reg:SI 18) (const_int 1))\n+   \t\t\t   (pc)\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_branch (1, insn);\"\n+  [(set_attr \"type\" \"cbranch\")])\n+\n+\f\n+;; Conditional branch insns\n+\n+(define_expand \"beq\"\n+  [(set (reg:SI 18) (eq:SI (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (eq (reg:SI 18)\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = sh_compare_op0;\n+  operands[2] = sh_compare_op1;\n+}\")\n+\n+\n+; There is no bne compare, so we reverse the branch arms.\n+\n+(define_expand \"bne\"\n+  [(set (reg:SI 18) (eq:SI (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (eq (reg:SI 18)\n+\t\t\t  (const_int 1))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = sh_compare_op0;\n+  operands[2] = sh_compare_op1;\n+}\")\n+\n+(define_expand \"bgt\"\n+  [(set (reg:SI 18) (gt:SI (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (eq (reg:SI 18)\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = sh_compare_op0;\n+  operands[2] = sh_compare_op1;\n+}\")\n+\n+(define_expand \"blt\"\n+  [(set (reg:SI 18) (lt:SI (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (eq (reg:SI 18)\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = sh_compare_op0;\n+  operands[2] = sh_compare_op1;\n+}\")\n+\n+(define_expand \"ble\"\n+  [(set (reg:SI 18) (le:SI (match_dup 1) (match_dup 2)))\n+   (set (pc)\t\t\t\t\n+\t(if_then_else (eq (reg:SI 18)\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = sh_compare_op0;\n+  operands[2] = sh_compare_op1;\n+}\")\n+\n+(define_expand \"bge\"\n+  [(set (reg:SI 18) (ge:SI (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (eq (reg:SI 18)\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = sh_compare_op0;\n+  operands[2] = sh_compare_op1;\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(set (reg:SI 18) (gtu:SI (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (eq (reg:SI 18)\n+\t\t\t   (const_int 1))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = sh_compare_op0;\n+  operands[2] = sh_compare_op1;\n+}\")\n+\n+(define_expand \"bltu\"\n+  [(set (reg:SI 18) (ltu:SI (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (eq (reg:SI 18)\n+\t\t\t   (const_int 1))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = sh_compare_op0;\n+  operands[2] = sh_compare_op1;\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(set (reg:SI 18) (geu:SI (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (eq (reg:SI 18)\n+\t\t\t   (const_int 1))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = sh_compare_op0;\n+  operands[2] = sh_compare_op1;\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(set (reg:SI 18) (leu:SI (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (eq (reg:SI 18)\n+\t\t\t   (const_int 1))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = sh_compare_op0;\n+  operands[2] = sh_compare_op1;\n+}\")\n+\n+\f\n+;; ------------------------------------------------------------------------\n+;; Jump and linkage insns\n+;; ------------------------------------------------------------------------\n+\n+(define_insn \"jump_real\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  if (get_attr_length(insn) == 6) \n+    {\n+      return \\\"mov.l\t%I0,r13\\;jmp\t@r13%#\\\";\n+    }\n+  else\n+    {\n+      return   \\\"bra\t%l0%#\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"jump\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n+(define_expand \"jump\"\n+ [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+ \"\"\n+ \"\n+{\n+  emit_insn(gen_jump_real(operand0));\n+  DONE;\n+}\n+\")\n+\n+(define_insn \"calli\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"jsr\t@%0%#\"\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"call_valuei\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"jsr\t@%1%#\"\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"call\"\n+  [(parallel[(call (match_operand 0 \"register_operand\" \"o\")\n+\t\t   (match_operand 1 \"\" \"\"))\n+\t     (clobber (reg:SI 17))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM) \n+    {\n+      operands[0] \n+\t= gen_rtx(MEM,GET_MODE (operands[0]),\n+\t\t  force_reg (Pmode,\n+\t\t\t    XEXP (operands[0], 0)));\n+    }\n+}\")\n+\n+(define_expand \"call_value\"\n+  [(parallel[(set (match_operand 0 \"\" \"=rf\")\n+\t\t  (call (match_operand 1 \"register_operand\" \"o\")\n+\t\t\t(match_operand 2 \"\" \"\")))\n+\t     (clobber (reg:SI 17))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == MEM) \n+    {\n+      operands[1] \n+\t= gen_rtx (MEM, GET_MODE (operands[1]),\n+\t\t   force_reg (Pmode,\n+\t\t\t      XEXP (operands[1], 0)));\n+    }\n+}\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jmp\t@%0\"\n+  [(set_attr \"needs_delay_slot\" \"yes\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"length\" \"4\")])\n+\n+\n+\f\n+;; ------------------------------------------------------------------------\n+;; Misc insns\n+;; ------------------------------------------------------------------------\n+\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"or\tr0,r0\")\n+\n+(define_insn \"tablejump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"!table jump\\;jmp\t@%0\\;or\tr0,r0\\;.align\t4\\;%!\"\n+  [(set_attr \"needs_delay_slot\" \"no\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"type\" \"jump\")\n+   (set_attr \"dump\" \"no\")])\n+\f\n+;; ------------------------------------------------------------------------\n+;; Scc instructions\n+;; ------------------------------------------------------------------------\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(eq (reg:SI 18) (const_int 1)))]\n+  \"\"\n+  \"movt\t%0 ! \")\n+\n+(define_expand \"seq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = prepare_scc_operands (EQ);\")\n+\n+(define_expand \"slt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = prepare_scc_operands (LT);\")\n+\n+(define_expand \"sle\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = prepare_scc_operands (LE);\")\n+\n+(define_expand \"sgt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = prepare_scc_operands (GT);\")\n+\n+(define_expand \"sge\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = prepare_scc_operands (GE);\")\n+\n+(define_expand \"sgtu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = prepare_scc_operands (GTU);\")\n+\n+(define_expand \"sltu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = prepare_scc_operands (LTU);\")\n+\n+(define_expand \"sleu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = prepare_scc_operands (LEU);\")\n+\n+(define_expand \"sgeu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = prepare_scc_operands (GEU);\")\n+\n+(define_expand \"sne\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))\n+   (set (match_dup 0) (xor:SI (match_dup 0) (const_int 1)))]\n+  \"\"\n+  \"operands[1] = prepare_scc_operands (EQ);\")\n+\n+(define_insn \"anddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"and\t%2,%0\\;and\t%R2,%R0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"iordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"or\t%2,%0\\;or\t%R2,%R0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"xordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(xor:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"xor\t%2,%0\\;xor\t%R2,%R0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+\f\n+;; ------------------------------------------------------------------------\n+;; Block move\n+;; ------------------------------------------------------------------------\n+\n+(define_expand \"movstrsi\"\n+  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n+\t     (use (match_operand:SI 2 \"general_operand\" \"\"))\n+\t     (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+  ])]\n+  \"\"\n+  \"\n+{\n+  rtx src_ptr = copy_to_mode_reg(Pmode,XEXP(operands[1], 0));\n+  rtx dst_ptr = copy_to_mode_reg(Pmode,XEXP(operands[0], 0));\n+\n+  enum machine_mode mode = \n+     (INTVAL(operands[3]) >=4)  ? SImode :\n+       (INTVAL(operands[3]) >=2) ? HImode :\n+\t QImode;\n+\n+  rtx tmpreg = gen_reg_rtx(mode);\n+  rtx increment =  GEN_INT(GET_MODE_SIZE(mode));\n+  rtx length = operands[2];\n+  rtx label = gen_label_rtx();\n+  rtx end_src_ptr = gen_reg_rtx(Pmode);\n+\n+  /* If done first rtl emmiting stage we can't generate a loop */\n+  /*  if    (!rtx_equal_function_value_matters)\n+      FAIL;*/\n+  \n+  if (GET_CODE (length) != CONST_INT)\n+    length = convert_to_mode (Pmode, length, 1);\n+\n+  if (!arith_operand (length, SImode))\n+\tlength = force_reg (SImode, length);\n+\t\n+  emit_insn(gen_rtx(SET,\n+\t\t    VOIDmode, \n+\t\t    end_src_ptr,\n+\t\t    gen_rtx(PLUS, Pmode, src_ptr, length)));\n+\n+\n+  emit_label(label);\n+  emit_move_insn(tmpreg, gen_rtx(MEM, mode, src_ptr));\n+\n+\n+  emit_insn(gen_rtx(SET,\n+\t\t    VOIDmode,\n+\t\t    src_ptr,\n+\t\t    gen_rtx(PLUS, Pmode, src_ptr, increment)));\n+\n+  emit_move_insn(gen_rtx(MEM, mode, dst_ptr), tmpreg);\n+\n+  emit_insn(gen_rtx(SET, \n+\t\t    VOIDmode,\n+\t\t    dst_ptr,\n+\t\t    gen_rtx(PLUS, Pmode, dst_ptr, increment)));\n+\n+  sh_compare_op0 = src_ptr;\n+  sh_compare_op1 = end_src_ptr;\n+  \n+  emit_insn(gen_cmpeqsi_t(src_ptr, end_src_ptr));\n+  emit_jump_insn(gen_bne(label));\n+  emit_insn(gen_rtx(SET, VOIDmode, dst_ptr, dst_ptr));\n+  \n+  DONE;\t\n+}\n+\")\n+\n+\n+\n+\n+   \n+;; -------------------------------------------------------------------------\n+;; Peepholes\n+;; -------------------------------------------------------------------------\n+\n+\n+(define_peephole \n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(mem:QI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))]\n+  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"mov.b\t@%1+,%0\")\n+\n+(define_peephole \n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mem:HI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 2)))]\n+  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"mov.w\t@%1+,%0\")\n+\n+(define_peephole \n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 4)))]\n+  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"mov.l\t@%1+,%0\")"}, {"sha": "54c780baec3e02d3989d715257ed5adbce5452be", "filename": "gcc/config/sh/t-sh", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc45ade3d6886f8d72864d114eb62e8287eede36/gcc%2Fconfig%2Fsh%2Ft-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc45ade3d6886f8d72864d114eb62e8287eede36/gcc%2Fconfig%2Fsh%2Ft-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh?ref=bc45ade3d6886f8d72864d114eb62e8287eede36", "patch": "@@ -0,0 +1,17 @@\n+LIBGCC1 = libgcc1.null\n+T_CFLAGS = -DDONT_HAVE_STDIO -DDONT_HAVE_SETJMP  -Dinhibit_libc\n+LIBGCC2_CFLAGS=-g -fno-omit-frame-pointer -O2 $(GCC_CFLAGS) \n+LANGUAGES=c\n+COMPILERS=cc1\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so... [taken from t-ose68k]\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+"}, {"sha": "148ff57267a950e99610d0aac71dd9486027c13f", "filename": "gcc/config/sh/xm-sh.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc45ade3d6886f8d72864d114eb62e8287eede36/gcc%2Fconfig%2Fsh%2Fxm-sh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc45ade3d6886f8d72864d114eb62e8287eede36/gcc%2Fconfig%2Fsh%2Fxm-sh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fxm-sh.h?ref=bc45ade3d6886f8d72864d114eb62e8287eede36", "patch": "@@ -0,0 +1,41 @@\n+/* Configuration for GNU C-compiler for Hitachi SH.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 32\n+\n+/* If compiled with GNU C, use the built-in alloca.  */\n+#ifdef __GNUC__\n+#define alloca __builtin_alloca\n+#endif\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.  */\n+#include \"tm.h\"\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+"}]}