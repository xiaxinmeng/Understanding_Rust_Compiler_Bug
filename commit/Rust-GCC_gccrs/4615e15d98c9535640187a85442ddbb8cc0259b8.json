{"sha": "4615e15d98c9535640187a85442ddbb8cc0259b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYxNWUxNWQ5OGM5NTM1NjQwMTg3YTg1NDQyZGRiYjhjYzAyNTliOA==", "commit": {"author": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "2000-05-08T13:05:16Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "2000-05-08T13:05:16Z"}, "message": "no longer needed\n\nFrom-SVN: r33765", "tree": {"sha": "a2e5469a31d9d4dbea3f3c500a40120aa947a991", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2e5469a31d9d4dbea3f3c500a40120aa947a991"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4615e15d98c9535640187a85442ddbb8cc0259b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4615e15d98c9535640187a85442ddbb8cc0259b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4615e15d98c9535640187a85442ddbb8cc0259b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4615e15d98c9535640187a85442ddbb8cc0259b8/comments", "author": null, "committer": null, "parents": [{"sha": "b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e"}], "stats": {"total": 4313, "additions": 0, "deletions": 4313}, "files": [{"sha": "c6a701127328409a0d4f26f2413672a926afd4fd", "filename": "gcc/fixinc/hackshell.tpl", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e/gcc%2Ffixinc%2Fhackshell.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e/gcc%2Ffixinc%2Fhackshell.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fhackshell.tpl?ref=b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e", "patch": "@@ -1,200 +0,0 @@\n-[= autogen template include =]\n-[=\n-#\n-#  This file contanes the shell template replacement for the\n-#  fixincl program.  It is the repetitive guts of the fixincludes logic.\n-#\n-=]\n-  echo Checking header files\n-  for file in $files; do\n-\n-    # Skip unreadable files, symlinks to directories and glibc files\n-    if test ! -r \"${file}\" || test -d \"${file}/.\" ; then\n-      continue\n-    fi\n-\n-    fixlist=\"\"\n-    DESTFILE=${DESTDIR}/`echo ${file} | sed \"s;${FIND_BASE}/;;\" `\n-[=\n-#\n-#  FOR  every fix description,\n-#  DO:  emit the shell text to apply the fix to the current file\n-#\n-# =][=\n-\n-_FOR fix \"\\n\\n\" =]\n-    #\n-    # Fix [=\n-       _IF FIXINC_DEBUG _exist =][=_eval _index 1 + #%3d _printf=]:  [=\n-       _ENDIF =][=hackname _Cap=]\n-    #[=\n-    _IF files _exist=]\n-    case \"${file}\" in [=_FOR files \" | \\\\\\n\\t\"=]./[=files=][=/files=] )[=\n-    _ENDIF=][=\n-\n-    _IF mach _exist=]\n-    case \"$target_canonical\" in [=\n-        _FOR mach \" | \\\\\\n\\t\" =][=\n-            mach =][=\n-        /mach =] )[=\n-        _IF mach_unmatched _exist =] : ;;\n-    * )[=\n-        _ENDIF =][=\n-\n-    _ENDIF=][=\n-\n-    #  There are four conditional tests:  select, bypass and test c_test.\n-       They may appear as often as desired.  They must all pass for\n-       the fix to be applied.  \"select\" and \"bypass\" are egrep expressions\n-       that must each appear (or not appear) in the target file.\n-       \"test\" is an arbitrary test program expression that must yield\n-       true or false.  =][=\n-\n-    _IF select _exist =]\n-    if ( test [=\n-        _FOR select \" -a \\\\\\n              \"\n-              =]-n [=select _shrstr \"#`egrep %s ${file}`\"\n-                            _printf _shstr =][=\n-        /select=]\n-       ) > /dev/null 2>&1 ; then[=\n-    _ENDIF =][=\n-\n-    _IF bypass _exist =]\n-    if ( test [=\n-            _FOR bypass \" -a \\\\\\n              \"\n-              =]-z [=bypass _shrstr \"#`egrep %s ${file}`\"\n-                            _printf _shstr =][=\n-            /bypass=]\n-       ) > /dev/null 2>&1 ; then[=\n-    _ENDIF =][=\n-\n-    _IF test _exist =]\n-    if ( test [=\n-        _FOR test \" -a \\\\\\n              \"\n-              =]'(' [=test=] ')'[=\n-        /test=]\n-       ) > /dev/null 2>&1 ; then[=\n-    _ENDIF=][=\n-\n-    _IF c_test _exist =]\n-    if [=\n-        _FOR c_test \" && \\\\\\n              \"\n-              =]${FIXTESTS} ${file} [=c_test=][=\n-        /c_test=]\n-    then[=\n-\n-    _ENDIF=][=\n-    _IF replace _exist ! =]\n-    fixlist=\"${fixlist}\n-      [=hackname=]\"\n-    if [ ! -r ${DESTFILE} ]\n-    then infile=${file}\n-    else infile=${DESTFILE} ; fi [=\n-    _ENDIF =][=\n-\n-    _IF sed _exist=][=\n-        _IF shell _exist =][=\n-          _ERROR hackname _get\n-          \"fixincludes Error:  %s fix has multiple fixups\" _printf=][=\n-        _ENDIF=]\n-\n-    sed [=\n-        _FOR sed =]-e [=sed _shrstr=] \\\n-        [=\n-        /sed=]  < $infile > ${DESTDIR}/fixinc.tmp[=\n-\n-\n-    _ELIF shell _exist =]\n-    ( [=shell=] ) < $infile > ${DESTDIR}/fixinc.tmp\n-\n-    #  Shell scripts have the potential of removing the output\n-    #  We interpret that to mean the file is not to be altered\n-    #\n-    if test ! -f ${DESTDIR}/fixinc.tmp\n-    then continue ; fi [=\n-\n-    _ELIF c_fix _exist =]\n-    ${FIXFIXES} ${file} [=c_fix=] < $infile > ${DESTDIR}/fixinc.tmp[=\n-\n-    _ELIF replace _exist =][=\n-\n-      _IF replace _len 0 > =]\n-    echo \"[=hackname =] replacing file ${file}\" >&2\n-    cat > ${DESTFILE} << '_EOF_'\n-[=replace=]\n-_EOF_[=\n-      _ELSE =]\n-    echo \"[=hackname =] bypassing file ${file}\"[=\n-      _ENDIF =]\n-    continue\n-[=\n-\n-    _ELSE=][=\n-        _ERROR hackname _get \"ERROR:  %s has no fixup\" _printf=][=\n-\n-    _ENDIF=][=\n-\n-    _IF replace _exist ! =]\n-    rm -f ${DESTFILE}\n-    mv -f ${DESTDIR}/fixinc.tmp ${DESTFILE}[=\n-    _ENDIF =][=\n-\n-    #  Close off any opened \"if\" or \"case\" statements in reverse order\n-\n-    # =][=\n-\n-    _IF c_test _exist =]\n-    fi # end of c_test 'if'[=\n-    _ENDIF =][=\n-\n-    _IF test _exist =]\n-    fi # end of test expression 'if'[=\n-    _ENDIF =][=\n-\n-    _IF bypass _exist =]\n-    fi # end of bypass 'if'[=\n-    _ENDIF =][=\n-\n-    _IF select _exist =]\n-    fi # end of select 'if'[=\n-    _ENDIF =][=\n-\n-    _IF mach _exist=]\n-    ;; # case end for machine type test\n-    esac[=\n-    _ENDIF =][=\n-\n-    _IF files _exist=]\n-    ;; # case end for file name test\n-    esac[=\n-    _ENDIF =][=\n-\n-/fix =][=\n-#\n-#  DONE with every fix for the current file\n-#\n-#=]\n-    #  IF the output has been removed OR it is unchanged,\n-    #  THEN ensure the output is gone\n-    #  ELSE look for local directory include syntax\n-    #\n-    if ( test ! -f ${DESTFILE} || \\\n-         cmp ${file} ${DESTFILE} ) > /dev/null 2>&1\n-    then\n-      rm -f ${DESTFILE}\n-    else\n-      echo \"Fixed ${file}:${fixlist}\"\n-\n-      # Find any include directives that use \"file\".\n-      #\n-      dir=`echo ${file} | sed -e s';/[^/]*$;;'`\n-      ddir=${DESTDIR}/$dir\n-\n-      for include in `\n-         egrep '^[      ]*#[    ]*include[      ]*\"[^/]' ${DESTFILE} |\n-         sed -e 's/^[   ]*#[    ]*include[      ]*\"\\([^\"]*\\)\".*$/\\1/'`\n-      do\n-        required=\"$required ${SRCDIR} $dir/$include ${ddir}/$include\"\n-      done\n-    fi\n-  done # for file in $files"}, {"sha": "aa363dc65c927e44eecf241bd5f225f24f8153f7", "filename": "gcc/fixinc/inclhack.sh", "status": "removed", "additions": 0, "deletions": 3623, "changes": 3623, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e/gcc%2Ffixinc%2Finclhack.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e/gcc%2Ffixinc%2Finclhack.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.sh?ref=b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e"}, {"sha": "7b085a75f7d23d858cea9c6eeffb16bd5b1fec53", "filename": "gcc/fixinc/inclhack.tpl", "status": "removed", "additions": 0, "deletions": 490, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e/gcc%2Ffixinc%2Finclhack.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e/gcc%2Ffixinc%2Finclhack.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.tpl?ref=b78f1c7bb1ecf4a8190d3f716a9713783b6c3f0e", "patch": "@@ -1,490 +0,0 @@\n-[= autogen template -*- Mode: sh -*-\n-sh\n-#\n-#\n-=]\n-#!/bin/sh\n-#\n-#  DO NOT EDIT THIS FILE - it has been generated\n-#\n-# Install modified versions of certain ANSI-incompatible system header\n-# files which are fixed to work correctly with ANSI C and placed in a\n-# directory that GNU C will search.\n-#[=\n-_IF PROGRAM _env ! =]\n-# This script contains [=_eval fix _count =] fixup scripts.\n-#[=\n-_ENDIF =]\n-# See README-fixinc for more information.\n-#\n-#  fixincludes copyright (c) 1998, 1999, 2000\n-#  The Free Software Foundation, Inc.\n-#\n-[=_eval fixincludes \"## \" _gpl=]\n-#\n-# # # # # # # # # # # # # # # # # # # # #\n-#\n-# Directory in which to store the results.\n-# Fail if no arg to specify a directory for the output.\n-if [ \"x$1\" = \"x\" ]\n-then\n-  echo fixincludes: no output directory specified\n-  exit 1\n-fi\n-\n-LIB=${1}\n-shift\n-\n-# Make sure it exists.\n-if [ ! -d $LIB ]; then\n-  mkdir $LIB || {\n-    echo fixincludes:  output dir '`'$LIB\"' cannot be created\"\n-    exit 1\n-  }\n-else\n-  ( cd $LIB && touch DONE && rm DONE ) || {\n-    echo fixincludes:  output dir '`'$LIB\"' is an invalid directory\"\n-    exit 1\n-  }\n-fi\n-[=_IF PROGRAM _env ! =]\n-FIXTESTS=$PWD/fixinc/fixtests\n-FIXFIXES=$PWD/fixinc/fixfixes\n-[=_ENDIF=]\n-if test -z \"$VERBOSE\"\n-then\n-  VERBOSE=[=\n-  _IF FIXINC_DEBUG _exist =]3[=_ELSE=]2[=_ENDIF=]\n-  export VERBOSE\n-else\n-  case \"$VERBOSE\" in\n-  [0-9] ) : ;;\n-  * )  VERBOSE=3 ;;\n-  esac\n-fi\n-\n-# Define what target system we're fixing.\n-#\n-if test -r ./Makefile; then\n-  target_canonical=\"`sed -n -e 's,^target[ \t]*=[ \t]*\\(.*\\)$,\\1,p' < Makefile`\"\n-fi\n-\n-# If not from the Makefile, then try config.guess\n-#\n-if test -z \"${target_canonical}\" ; then\n-  if test -x ./config.guess ; then\n-    target_canonical=\"`config.guess`\" ; fi\n-  test -z \"${target_canonical}\" && target_canonical=unknown\n-fi\n-export target_canonical\n-\n-# # # # # # # # # # # # # # # # # # # # #\n-#\n-# Define PWDCMD as a command to use to get the working dir\n-# in the form that we want.\n-PWDCMD=pwd\n-\n-case \"`$PWDCMD`\" in\n-//*)\n-    # On an Apollo, discard everything before `/usr'.\n-    PWDCMD=\"eval pwd | sed -e 's,.*/usr/,/usr/,'\"\n-    ;;\n-esac\n-\n-# Original directory.\n-ORIGDIR=`${PWDCMD}`[=\n-_IF PROGRAM _env =]\n-FIXINCL=${ORIGDIR}/fixincl\n-export FIXINCL[=\n-_ENDIF=]\n-\n-# Make LIB absolute only if needed to avoid problems with the amd.\n-case $LIB in\n-/*)\n-    ;;\n-*)\n-    cd $LIB; LIB=`${PWDCMD}`\n-    ;;\n-esac\n-\n-if test $VERBOSE -gt 0\n-then echo Fixing headers into ${LIB} for ${target_canonical} target ; fi\n-\n-# Determine whether this system has symbolic links.\n-if ln -s X $LIB/ShouldNotExist 2>/dev/null; then\n-  rm -f $LIB/ShouldNotExist\n-  LINKS=true\n-elif ln -s X /tmp/ShouldNotExist 2>/dev/null; then\n-  rm -f /tmp/ShouldNotExist\n-  LINKS=true\n-else\n-  LINKS=false\n-fi\n-\n-# # # # # # # # # # # # # # # # # # # # #\n-#\n-#  Search each input directory for broken header files.\n-#  This loop ends near the end of the file.\n-#\n-if test $# -eq 0\n-then\n-    INPUTLIST=\"/usr/include\"\n-else\n-    INPUTLIST=\"$@\"\n-fi\n-\n-for INPUT in ${INPUTLIST} ; do\n-\n-cd ${ORIGDIR}\n-\n-#  Make sure a directory exists before changing into it,\n-#  otherwise Solaris2 will fail-exit the script.\n-#\n-if [ ! -d ${INPUT} ]; then\n-  continue\n-fi\n-cd ${INPUT}\n-\n-INPUT=`${PWDCMD}`\n-\n-#\n-# # # # # # # # # # # # # # # # # # # # #\n-#\n-if test $VERBOSE -gt 1\n-then echo Finding directories and links to directories ; fi\n-\n-# Find all directories and all symlinks that point to directories.\n-# Put the list in $all_dirs.\n-# Each time we find a symlink, add it to newdirs\n-# so that we do another find within the dir the link points to.\n-# Note that $all_dirs may have duplicates in it;\n-# later parts of this file are supposed to ignore them.\n-dirs=\".\"\n-levels=2\n-all_dirs=\"\"\n-search_dirs=\"\"\n-\n-while [ -n \"$dirs\" ] && [ $levels -gt 0 ]\n-do\n-  levels=`expr $levels - 1`\n-  newdirs=\n-  for d in $dirs\n-  do\n-    if test $VERBOSE -gt 1\n-    then echo \" Searching $INPUT/$d\" ; fi\n-\n-    # Find all directories under $d, relative to $d, excluding $d itself.\n-    # (The /. is needed after $d in case $d is a symlink.)\n-    all_dirs=\"$all_dirs `find $d/. -type d -print | \\\n-               sed -e '/\\/\\.$/d' -e 's@/./@/@g'`\"\n-    # Find all links to directories.\n-    # Using `-exec test -d' in find fails on some systems,\n-    # and trying to run test via sh fails on others,\n-    # so this is the simplest alternative left.\n-    # First find all the links, then test each one.\n-    theselinks=\n-    $LINKS && \\\n-      theselinks=`find $d/. -type l -print | sed -e 's@/./@/@g'`\n-    for d1 in $theselinks --dummy--\n-    do\n-      # If the link points to a directory,\n-      # add that dir to $newdirs\n-      if [ -d $d1 ]\n-      then\n-        all_dirs=\"$all_dirs $d1\"\n-        if [ \"`ls -ld $d1 | sed -n 's/.*-> //p'`\" != \".\" ]\n-        then\n-          newdirs=\"$newdirs $d1\"\n-          search_dirs=\"$search_dirs $d1\"\n-        fi\n-      fi\n-    done\n-  done\n-\n-  dirs=\"$newdirs\"\n-done\n-\n-# # # # # # # # # # # # # # # # # # # # #\n-#\n-dirs=\n-if test $VERBOSE -gt 2\n-then echo \"All directories (including links to directories):\"\n-     echo $all_dirs\n-fi\n-\n-for file in $all_dirs; do\n-  rm -rf $LIB/$file\n-  if [ ! -d $LIB/$file ]\n-  then mkdir $LIB/$file\n-  fi\n-done\n-mkdir $LIB/root\n-\n-# # # # # # # # # # # # # # # # # # # # #\n-#\n-# treetops gets an alternating list\n-# of old directories to copy\n-# and the new directories to copy to.\n-treetops=\". ${LIB}\"\n-\n-if $LINKS; then\n-  if test $VERBOSE -gt 1\n-  then echo 'Making symbolic directory links' ; fi\n-  cwd=`${PWDCMD}`\n-\n-  for sym_link in $search_dirs; do\n-    cd ${INPUT}\n-    dest=`ls -ld ${sym_link} | sed -n 's/.*-> //p'`\n-\n-    # In case $dest is relative, get to ${sym_link}'s dir first.\n-    #\n-    cd ./`echo ${sym_link} | sed 's;/[^/]*$;;'`\n-\n-    # Check that the target directory exists.\n-    # Redirections changed to avoid bug in sh on Ultrix.\n-    #\n-    (cd $dest) > /dev/null 2>&1\n-    if [ $? = 0 ]; then\n-      cd $dest\n-\n-      # full_dest_dir gets the dir that the link actually leads to.\n-      #\n-      full_dest_dir=`${PWDCMD}`\n-\n-      # Canonicalize ${INPUT} now to minimize the time an\n-      # automounter has to change the result of ${PWDCMD}.\n-      #\n-      cinput=`cd ${INPUT}; ${PWDCMD}`\n-\n-      # If a link points to ., make a similar link to .\n-      #\n-      if [ ${full_dest_dir} = ${cinput} ]; then\n-        if test $VERBOSE -gt 2\n-        then echo ${sym_link} '->' . ': Making self link' ; fi\n-        rm -fr ${LIB}/${sym_link} > /dev/null 2>&1\n-        ln -s . ${LIB}/${sym_link} > /dev/null 2>&1\n-\n-      # If link leads back into ${INPUT},\n-      # make a similar link here.\n-      #\n-      elif expr ${full_dest_dir} : \"${cinput}/.*\" > /dev/null; then\n-        # Y gets the actual target dir name, relative to ${INPUT}.\n-        y=`echo ${full_dest_dir} | sed -n \"s&${cinput}/&&p\"`\n-        # DOTS is the relative path from ${LIB}/${sym_link} back to ${LIB}.\n-        dots=`echo \"${sym_link}\" |\n-          sed -e 's@^./@@' -e 's@/./@/@g' -e 's@[^/][^/]*@..@g' -e 's@..$@@'`\n-        if test $VERBOSE -gt 2\n-        then echo ${sym_link} '->' $dots$y ': Making local link' ; fi\n-        rm -fr ${LIB}/${sym_link} > /dev/null 2>&1\n-        ln -s $dots$y ${LIB}/${sym_link} > /dev/null 2>&1\n-\n-      else\n-        # If the link is to a dir $target outside ${INPUT},\n-        # repoint the link at ${INPUT}/root$target\n-        # and process $target into ${INPUT}/root$target\n-        # treat this directory as if it actually contained the files.\n-        #\n-        if test $VERBOSE -gt 2\n-        then echo ${sym_link} '->' root${full_dest_dir} ': Making rooted link'\n-        fi\n-        if [ -d $LIB/root${full_dest_dir} ]\n-        then true\n-        else\n-          dirname=root${full_dest_dir}/\n-          dirmade=.\n-          cd $LIB\n-          while [ x$dirname != x ]; do\n-            component=`echo $dirname | sed -e 's|/.*$||'`\n-            mkdir $component >/dev/null 2>&1\n-            cd $component\n-            dirmade=$dirmade/$component\n-            dirname=`echo $dirname | sed -e 's|[^/]*/||'`\n-          done\n-        fi\n-\n-        # Duplicate directory structure created in ${LIB}/${sym_link} in new\n-        # root area.\n-        #\n-        for file2 in $all_dirs; do\n-          case $file2 in\n-            ${sym_link}/*)\n-              dupdir=${LIB}/root${full_dest_dir}/`echo $file2 |\n-                      sed -n \"s|^${sym_link}/||p\"`\n-              if test $VERBOSE -gt 2\n-              then echo \"Duplicating ${sym_link}'s ${dupdir}\" ; fi\n-              if [ -d ${dupdir} ]\n-              then true\n-              else\n-                mkdir ${dupdir}\n-              fi\n-              ;;\n-            *)\n-              ;;\n-          esac\n-        done\n-\n-        # Get the path from ${LIB} to ${sym_link}, accounting for symlinks.\n-        #\n-        parent=`echo \"${sym_link}\" | sed -e 's@/[^/]*$@@'`\n-        libabs=`cd ${LIB}; ${PWDCMD}`\n-        file2=`cd ${LIB}; cd $parent; ${PWDCMD} | sed -e \"s@^${libabs}@@\"`\n-\n-        # DOTS is the relative path from ${LIB}/${sym_link} back to ${LIB}.\n-        #\n-        dots=`echo \"$file2\" | sed -e 's@/[^/]*@../@g'`\n-        rm -fr ${LIB}/${sym_link} > /dev/null 2>&1\n-        ln -s ${dots}root${full_dest_dir} ${LIB}/${sym_link} > /dev/null 2>&1\n-        treetops=\"$treetops ${sym_link} ${LIB}/root${full_dest_dir}\"\n-      fi\n-    fi\n-  done\n-fi\n-\n-# # # # # # # # # # # # # # # # # # # # #\n-#\n-required=\n-set x $treetops\n-shift\n-while [ $# != 0 ]; do\n-  # $1 is an old directory to copy, and $2 is the new directory to copy to.\n-  #\n-  SRCDIR=`cd ${INPUT} ; cd $1 ; ${PWDCMD}`\n-  export SRCDIR\n-\n-  FIND_BASE=$1\n-  export FIND_BASE\n-  shift\n-\n-  DESTDIR=`cd $1;${PWDCMD}`\n-  export DESTDIR\n-  shift\n-\n-  # The same dir can appear more than once in treetops.\n-  # There's no need to scan it more than once.\n-  #\n-  if [ -f ${DESTDIR}/DONE ]\n-  then continue ; fi\n-\n-  touch ${DESTDIR}/DONE\n-  if test $VERBOSE -gt 1\n-  then echo Fixing directory ${SRCDIR} into ${DESTDIR} ; fi\n-\n-  # Check files which are symlinks as well as those which are files.\n-  #\n-  cd ${INPUT}[=\n-_IF PROGRAM _env ! =]\n-  files=`if $LINKS; then\n-    find ${FIND_BASE}/. -name '*.h' \\( -type f -o -type l \\) -print\n-  else\n-    find ${FIND_BASE}/. -name '*.h' -type f -print\n-  fi | \\\n-    sed -e 's;/\\./;/;g' -e 's;//*;/;g' `\n-[=\n-\n-    _include hackshell =][=\n-\n-  _ELSE\n-\n-=]\n-  required=\"$required `if $LINKS; then\n-    find ${FIND_BASE}/. -name '*.h' \\( -type f -o -type l \\) -print\n-  else\n-    find ${FIND_BASE}/. -name '*.h' -type f -print\n-  fi | \\\n-    sed -e 's;/\\./;/;g' -e 's;//*;/;g' | \\\n-    ${FIXINCL}`\"[=\n-\n-\n-  _ENDIF =]\n-done\n-\n-## Make sure that any include files referenced using double quotes\n-## exist in the fixed directory.  This comes last since otherwise\n-## we might end up deleting some of these files \"because they don't\n-## need any change.\"\n-set x `echo $required`\n-shift\n-while [ $# != 0 ]; do\n-  newreq=\n-  while [ $# != 0 ]; do\n-    # $1 is the directory to copy from,\n-    # $2 is the unfixed file,\n-    # $3 is the fixed file name.\n-    #\n-    cd ${INPUT}\n-    cd $1\n-    if [ -f $2 ] ; then\n-      if [ -r $2 ] && [ ! -r $3 ]; then\n-        cp $2 $3 >/dev/null 2>&1 || echo \"Can't copy $2\" >&2\n-        chmod +w $3 2>/dev/null\n-        chmod a+r $3 2>/dev/null\n-        if test $VERBOSE -gt 2\n-        then echo Copied $2 ; fi\n-        for include in `egrep '^[ \t]*#[ \t]*include[ \t]*\"[^/]' $3 |\n-             sed -e 's/^[ \t]*#[ \t]*include[ \t]*\"\\([^\"]*\\)\".*$/\\1/'`\n-        do\n-\t  dir=`echo $2 | sed -e s'|/[^/]*$||'`\n-\t  dir2=`echo $3 | sed -e s'|/[^/]*$||'`\n-\t  newreq=\"$newreq $1 $dir/$include $dir2/$include\"\n-        done\n-      fi\n-    fi\n-    shift; shift; shift\n-  done\n-  set x $newreq\n-  shift\n-done\n-\n-if test $VERBOSE -gt 2\n-then echo 'Cleaning up DONE files.' ; fi\n-cd $LIB\n-find . -name DONE -exec rm -f '{}' ';'\n-\n-if test $VERBOSE -gt 1\n-then echo 'Cleaning up unneeded directories:' ; fi\n-cd $LIB\n-all_dirs=`find . -type d \\! -name '.' -print | sort -r`\n-for file in $all_dirs; do\n-  if rmdir $LIB/$file > /dev/null\n-  then\n-    test $VERBOSE -gt 3 && echo \"  removed $file\"\n-  fi\n-done 2> /dev/null\n-\n-test $VERBOSE -gt 2 && echo \"Removing unused symlinks\"\n-\n-all_dirs=`find . -type l -print`\n-for file in $all_dirs\n-do\n-  if ls -lLd $file > /dev/null\n-  then :\n-  else rm -f $file\n-       test $VERBOSE -gt 3 && echo \"  removed $file\"\n-       rmdir `dirname $file` > /dev/null && \\\n-         test $VERBOSE -gt 3 && \\\n-         echo \"  removed `dirname $file`\"\n-  fi\n-done 2> /dev/null\n-\n-if test $VERBOSE -gt 0\n-then echo fixincludes is done ; fi\n-\n-# # # # # # # # # # # # # # # # # # # # #\n-#\n-# End of for INPUT directories\n-#\n-done\n-#\n-# # # # # # # # # # # # # # # # # # # # #\n-\n-if [ x${INSTALL_ASSERT_H} != x ] && [ -f ${srcdir}/assert.h ]\n-then\n-  cd $ORIGDIR\n-  rm -f include/assert.h\n-  cp ${srcdir}/assert.h include/assert.h || exit 1\n-  chmod a+r include/assert.h\n-fi[=\n-\n-#  Make the output file executable\n-# =][=\n-_eval _outfile \"chmod +x %s\" _printf _shell=]"}]}