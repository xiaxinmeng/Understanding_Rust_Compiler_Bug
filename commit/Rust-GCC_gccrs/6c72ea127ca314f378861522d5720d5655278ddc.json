{"sha": "6c72ea127ca314f378861522d5720d5655278ddc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM3MmVhMTI3Y2EzMTRmMzc4ODYxNTIyZDU3MjBkNTY1NTI3OGRkYw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-12-19T16:04:11Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-12-19T16:04:11Z"}, "message": "i386.h (enum ix86_tune_indices): Add X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE.\n\n\t* config/i386/i386.h (enum ix86_tune_indices): Add\n\tX86_TUNE_AVOID_MEM_OPND_FOR_CMOVE.\n\t(TARGET_AVOID_MEM_OPND_FOR_CMOVE): New define.\n\t* config/i386/i386.c (initial_ix86_tune_features)\n\t<X86TUNE_AVOID_MEM_OPND_FOR_CMOVE>: Initialize.\n\t* config/i386/i386.md (splitters to avoid cmove memory operands): New.\n\t(peephole2s to avoid cmove memory operands): New.\n\nFrom-SVN: r194614", "tree": {"sha": "614efbf1375c8927ee6c8f66bdb937f8f41abcfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/614efbf1375c8927ee6c8f66bdb937f8f41abcfe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c72ea127ca314f378861522d5720d5655278ddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c72ea127ca314f378861522d5720d5655278ddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c72ea127ca314f378861522d5720d5655278ddc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c72ea127ca314f378861522d5720d5655278ddc/comments", "author": null, "committer": null, "parents": [{"sha": "aa86bf1e9c7f5324c9ed2a1233875cd090b43283", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa86bf1e9c7f5324c9ed2a1233875cd090b43283", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa86bf1e9c7f5324c9ed2a1233875cd090b43283"}], "stats": {"total": 166, "additions": 138, "deletions": 28}, "files": [{"sha": "be21ba93aaf17e30b49df37b4b8c85d04a912a31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c72ea127ca314f378861522d5720d5655278ddc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c72ea127ca314f378861522d5720d5655278ddc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c72ea127ca314f378861522d5720d5655278ddc", "patch": "@@ -1,3 +1,14 @@\n+2012-12-19  Uros Bizjak  <ubizjak@gmail.com>\n+\t    Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* config/i386/i386.h (enum ix86_tune_indices): Add\n+\tX86_TUNE_AVOID_MEM_OPND_FOR_CMOVE.\n+\t(TARGET_AVOID_MEM_OPND_FOR_CMOVE): New define.\n+\t* config/i386/i386.c (initial_ix86_tune_features)\n+\t<X86TUNE_AVOID_MEM_OPND_FOR_CMOVE>: Initialize.\n+\t* config/i386/i386.md (splitters to avoid cmove memory operands): New.\n+\t(peephole2s to avoid cmove memory operands): New.\n+\n 2012-12-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.md (f_minmaxs, f_minmaxd): New types.\n@@ -34,34 +45,26 @@\n \t* combine.c (try_combine): Adjust to use the target hook.\n \t* config/alpha/alpha.h (CANONICALIZE_COMPARISON): Remove macro\n \tdefinition.\n-\t* config/alpha/alpha.c (alpha_canonicalize_comparison): New\n-\tfunction.\n+\t* config/alpha/alpha.c (alpha_canonicalize_comparison): New function.\n \t(TARGET_CANONICALIZE_COMPARISON): New macro definition.\n \t* config/arm/arm-protos.h (arm_canonicalize_comparison): Remove\n \tprototype.\n-\t* config/arm/arm.c (arm_canonicalize_comparison): Add new\n-\tparameter.\n+\t* config/arm/arm.c (arm_canonicalize_comparison): Add new parameter.\n \t(TARGET_CANONICALIZE_COMPARISON): New macro definition.\n-\t* config/arm/arm.h (CANONICALIZE_COMPARISON): Remove macro\n-\tdefinition.\n+\t* config/arm/arm.h (CANONICALIZE_COMPARISON): Remove macro definition.\n \t* config/s390/s390-protos.h (s390_canonicalize_comparison): Remove\n \tprototype.\n-\t* config/s390/s390.c (s390_canonicalize_comparison): Add new\n-\tparameter.\n+\t* config/s390/s390.c (s390_canonicalize_comparison): Add new parameter.\n \t(TARGET_CANONICALIZE_COMPARISON): New macro definition.\n-\t* config/s390/s390.h (CANONICALIZE_COMPARISON): Remove macro\n-\tdefinition.\n-\t* config/sh/sh-protos.h (sh_canonicalize_comparison): Remove\n-\tprototype.\n+\t* config/s390/s390.h (CANONICALIZE_COMPARISON): Remove macro definition.\n+\t* config/sh/sh-protos.h (sh_canonicalize_comparison): Remove prototype.\n \t* config/sh/sh.c (sh_canonicalize_comparison): Add new prototype.  New\n \tfunction overloading the old one.\n \t(TARGET_CANONICALIZE_COMPARISON): New macro definition.\n-\t* config/sh/sh.h (CANONICALIZE_COMPARISON): Remove macro\n-\tdefinition.\n+\t* config/sh/sh.h (CANONICALIZE_COMPARISON): Remove macro definition.\n \t* config/spu/spu.c (spu_canonicalize_comparison): New function.\n \t(TARGET_CANONICALIZE_COMPARISON): New macro definition.\n-\t* config/spu/spu.h (CANONICALIZE_COMPARISON): Remove macro\n-\tdefinition.\n+\t* config/spu/spu.h (CANONICALIZE_COMPARISON): Remove macro definition.\n \n 2012-12-19  Jakub Jelinek  <jakub@redhat.com>\n \n@@ -74,7 +77,8 @@\n 2012-12-18  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/55683\n-\t* ipa-prop.c (try_make_edge_direct_virtual_call): Look into constants for binfo.\n+\t* ipa-prop.c (try_make_edge_direct_virtual_call): Look into constants\n+\tfor binfo.\n \n 2012-12-19  Terry Guo  <terry.guo@arm.com>\n \n@@ -100,8 +104,7 @@\n \n 2012-12-18  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n-\t* config/arm/driver-arm.c (arm_cpu_table):\n-\tAdd Cortex-A7.\n+\t* config/arm/driver-arm.c (arm_cpu_table): Add Cortex-A7.\n \n 2012-12-18  Aldy Hernandez  <aldyh@redhat.com>\n \n@@ -152,7 +155,7 @@\n \tgen_lowpart_if_possible.\n \t(gen_lowpart_no_emit_general): Remove prototype.\n \t* rtlhooks.c (gen_lowpart_no_emit_general): Removed.\n-\t* simplify-rtx.c (simplify_unary_operation_1, \n+\t* simplify-rtx.c (simplify_unary_operation_1,\n \tsimplify_binary_operation_1): Continue simplifying if\n \trtl_hooks.gen_lowpart_no_emit returns NULL_RTX.\n \t* dwarf2out.c (mem_loc_descriptor) <case TRUNCATE>: Handle"}, {"sha": "b466a4fbbdf4349fa4583b3ea365c9e66698214a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c72ea127ca314f378861522d5720d5655278ddc/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c72ea127ca314f378861522d5720d5655278ddc/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6c72ea127ca314f378861522d5720d5655278ddc", "patch": "@@ -2026,7 +2026,11 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n \n   /* X86_TUNE_GENERAL_REGS_SSE_SPILL: Try to spill general regs to SSE\n      regs instead of memory.  */\n-  m_COREI7 | m_CORE2I7\n+  m_COREI7 | m_CORE2I7,\n+\n+  /* X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE: Try to avoid memory operands for\n+     a conditional move.  */\n+  m_ATOM\n };\n \n /* Feature tests against the various architecture variations.  */"}, {"sha": "d2f535a756627e143ea4610e8b575fb3bda2831d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c72ea127ca314f378861522d5720d5655278ddc/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c72ea127ca314f378861522d5720d5655278ddc/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=6c72ea127ca314f378861522d5720d5655278ddc", "patch": "@@ -331,6 +331,7 @@ enum ix86_tune_indices {\n   X86_TUNE_REASSOC_INT_TO_PARALLEL,\n   X86_TUNE_REASSOC_FP_TO_PARALLEL,\n   X86_TUNE_GENERAL_REGS_SSE_SPILL,\n+  X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE,\n \n   X86_TUNE_LAST\n };\n@@ -436,6 +437,8 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n \tix86_tune_features[X86_TUNE_REASSOC_FP_TO_PARALLEL]\n #define TARGET_GENERAL_REGS_SSE_SPILL \\\n \tix86_tune_features[X86_TUNE_GENERAL_REGS_SSE_SPILL]\n+#define TARGET_AVOID_MEM_OPND_FOR_CMOVE \\\n+\tix86_tune_features[X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE]\n \n /* Feature tests against the various architecture variations.  */\n enum ix86_arch_indices {"}, {"sha": "95a52cdd1a7981013f055332c0e7f00bee1a4d39", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 107, "deletions": 7, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c72ea127ca314f378861522d5720d5655278ddc/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c72ea127ca314f378861522d5720d5655278ddc/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6c72ea127ca314f378861522d5720d5655278ddc", "patch": "@@ -16093,6 +16093,28 @@\n   [(set_attr \"type\" \"icmov\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+;; Don't do conditional moves with memory inputs.  This splitter helps\n+;; register starved x86_32 by forcing inputs into registers before reload.\n+(define_split\n+  [(set (match_operand:SWI248 0 \"register_operand\")\n+\t(if_then_else:SWI248 (match_operator 1 \"ix86_comparison_operator\"\n+\t\t\t       [(reg FLAGS_REG) (const_int 0)])\n+\t  (match_operand:SWI248 2 \"nonimmediate_operand\")\n+\t  (match_operand:SWI248 3 \"nonimmediate_operand\")))]\n+  \"!TARGET_64BIT && TARGET_CMOVE\n+   && TARGET_AVOID_MEM_OPND_FOR_CMOVE\n+   && (MEM_P (operands[2]) || MEM_P (operands[3]))\n+   && can_create_pseudo_p ()\n+   && optimize_insn_for_speed_p ()\"\n+  [(set (match_dup 0)\n+\t(if_then_else:SWI248 (match_dup 1) (match_dup 2) (match_dup 3)))]\n+{\n+  if (MEM_P (operands[2]))\n+    operands[2] = force_reg (<MODE>mode, operands[2]);\n+  if (MEM_P (operands[3]))\n+    operands[3] = force_reg (<MODE>mode, operands[3]);\n+})\n+\n (define_insn \"*movqicc_noc\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n \t(if_then_else:QI (match_operator 1 \"ix86_comparison_operator\"\n@@ -16105,14 +16127,12 @@\n    (set_attr \"mode\" \"QI\")])\n \n (define_split\n-  [(set (match_operand 0 \"register_operand\")\n-\t(if_then_else (match_operator 1 \"ix86_comparison_operator\"\n-\t\t\t[(reg FLAGS_REG) (const_int 0)])\n-\t\t      (match_operand 2 \"register_operand\")\n-\t\t      (match_operand 3 \"register_operand\")))]\n+  [(set (match_operand:SWI12 0 \"register_operand\")\n+\t(if_then_else:SWI12 (match_operator 1 \"ix86_comparison_operator\"\n+\t\t\t      [(reg FLAGS_REG) (const_int 0)])\n+\t\t      (match_operand:SWI12 2 \"register_operand\")\n+\t\t      (match_operand:SWI12 3 \"register_operand\")))]\n   \"TARGET_CMOVE && !TARGET_PARTIAL_REG_STALL\n-   && (GET_MODE (operands[0]) == QImode\n-       || GET_MODE (operands[0]) == HImode)\n    && reload_completed\"\n   [(set (match_dup 0)\n \t(if_then_else:SI (match_dup 1) (match_dup 2) (match_dup 3)))]\n@@ -16122,6 +16142,33 @@\n   operands[3] = gen_lowpart (SImode, operands[3]);\n })\n \n+;; Don't do conditional moves with memory inputs\n+(define_peephole2\n+  [(match_scratch:SWI248 2 \"r\")\n+   (set (match_operand:SWI248 0 \"register_operand\")\n+\t(if_then_else:SWI248 (match_operator 1 \"ix86_comparison_operator\"\n+\t\t\t       [(reg FLAGS_REG) (const_int 0)])\n+\t  (match_dup 0)\n+\t  (match_operand:SWI248 3 \"memory_operand\")))]\n+  \"TARGET_CMOVE && TARGET_AVOID_MEM_OPND_FOR_CMOVE\n+   && optimize_insn_for_speed_p ()\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 0)\n+\t(if_then_else:SWI248 (match_dup 1) (match_dup 0) (match_dup 2)))])\n+\n+(define_peephole2\n+  [(match_scratch:SWI248 2 \"r\")\n+   (set (match_operand:SWI248 0 \"register_operand\")\n+\t(if_then_else:SWI248 (match_operator 1 \"ix86_comparison_operator\"\n+\t\t\t       [(reg FLAGS_REG) (const_int 0)])\n+\t  (match_operand:SWI248 3 \"memory_operand\")\n+\t  (match_dup 0)))]\n+  \"TARGET_CMOVE && TARGET_AVOID_MEM_OPND_FOR_CMOVE\n+   && optimize_insn_for_speed_p ()\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 0)\n+\t(if_then_else:SWI248 (match_dup 1) (match_dup 2) (match_dup 0)))])\n+\n (define_expand \"mov<mode>cc\"\n   [(set (match_operand:X87MODEF 0 \"register_operand\")\n \t(if_then_else:X87MODEF\n@@ -16209,6 +16256,59 @@\n   [(set_attr \"type\" \"fcmov,fcmov,icmov,icmov\")\n    (set_attr \"mode\" \"SF,SF,SI,SI\")])\n \n+;; Don't do conditional moves with memory inputs.  This splitter helps\n+;; register starved x86_32 by forcing inputs into registers before reload.\n+(define_split\n+  [(set (match_operand:MODEF 0 \"register_operand\")\n+\t(if_then_else:MODEF (match_operator 1 \"ix86_comparison_operator\"\n+\t\t\t      [(reg FLAGS_REG) (const_int 0)])\n+\t  (match_operand:MODEF 2 \"nonimmediate_operand\")\n+\t  (match_operand:MODEF 3 \"nonimmediate_operand\")))]\n+  \"!TARGET_64BIT && TARGET_80387 && TARGET_CMOVE\n+   && TARGET_AVOID_MEM_OPND_FOR_CMOVE\n+   && (MEM_P (operands[2]) || MEM_P (operands[3]))\n+   && can_create_pseudo_p ()\n+   && optimize_insn_for_speed_p ()\"\n+  [(set (match_dup 0)\n+\t(if_then_else:MODEF (match_dup 1) (match_dup 2) (match_dup 3)))]\n+{\n+  if (MEM_P (operands[2]))\n+    operands[2] = force_reg (<MODE>mode, operands[2]);\n+  if (MEM_P (operands[3]))\n+    operands[3] = force_reg (<MODE>mode, operands[3]);\n+})\n+\n+;; Don't do conditional moves with memory inputs\n+(define_peephole2\n+  [(match_scratch:MODEF 2 \"r\")\n+   (set (match_operand:MODEF 0 \"register_and_not_any_fp_reg_operand\")\n+\t(if_then_else:MODEF (match_operator 1 \"fcmov_comparison_operator\"\n+\t\t\t      [(reg FLAGS_REG) (const_int 0)])\n+\t  (match_dup 0)\n+\t  (match_operand:MODEF 3 \"memory_operand\")))]\n+  \"(<MODE>mode != DFmode || TARGET_64BIT)\n+   && TARGET_80387 && TARGET_CMOVE\n+   && TARGET_AVOID_MEM_OPND_FOR_CMOVE\n+   && optimize_insn_for_speed_p ()\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 0)\n+\t(if_then_else:MODEF (match_dup 1) (match_dup 0) (match_dup 2)))])\n+\n+(define_peephole2\n+  [(match_scratch:MODEF 2 \"r\")\n+   (set (match_operand:MODEF 0 \"register_and_not_any_fp_reg_operand\")\n+\t(if_then_else:MODEF (match_operator 1 \"fcmov_comparison_operator\"\n+\t\t\t      [(reg FLAGS_REG) (const_int 0)])\n+\t  (match_operand:MODEF 3 \"memory_operand\")\n+\t  (match_dup 0)))]\n+  \"(<MODE>mode != DFmode || TARGET_64BIT)\n+   && TARGET_80387 && TARGET_CMOVE\n+   && TARGET_AVOID_MEM_OPND_FOR_CMOVE\n+   && optimize_insn_for_speed_p ()\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 0)\n+\t(if_then_else:MODEF (match_dup 1) (match_dup 2) (match_dup 0)))])\n+\n ;; All moves in XOP pcmov instructions are 128 bits and hence we restrict\n ;; the scalar versions to have only XMM registers as operands.\n "}]}