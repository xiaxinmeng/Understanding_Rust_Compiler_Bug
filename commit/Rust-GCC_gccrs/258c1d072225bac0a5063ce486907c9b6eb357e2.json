{"sha": "258c1d072225bac0a5063ce486907c9b6eb357e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU4YzFkMDcyMjI1YmFjMGE1MDYzY2U0ODY5MDdjOWI2ZWIzNTdlMg==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2015-11-20T00:10:08Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2015-11-20T00:10:08Z"}, "message": "Support __cxa_free_exception and fix exception handling.\n\n\tgcc/cp/\n\t* except.c (do_free_exception): Use transactional wrapper.\n\n\tlibitm/\n\t* testsuite/libitm.c++/eh-5.C: New.\n\t* libitm.h (_ITM_cxa_free_exception): New.\n\t* libitm.map (_ITM_cxa_free_exception): Add it.\n\t* libitm.texi: Update ABI docs.\n\t* libitm_i.h (gtm_transaction_cp::cxa_unthrown): Remove.\n\t(gtm_transaction_cp::cxa_uncaught_count): Add.\n\t(gtm_thread::cxa_unthrown): Remove.\n\t(gtm_thread::cxa_uncaught_count_ptr): Add.\n\t(gtm_thread::cxa_uncaught_count): Add.\n\t(gtm_thread::drop_references_allocations): Rename to...\n\t(gtm_thread::discard_allocation): ... this and adapt.\n\t(gtm_thread::init_cpp_exceptions): New.\n\t* beginend.cc (gtm_thread::gtm_thread): Adapt EH handling.\n\t(gtm_thread::begin_transaction): Likewise.\n\t(gtm_transaction_cp::save): Likewise.\n\t(gtm_thread::trycommit): Likewise.\n\t* eh_cpp.cc: Add overview comments.\n\t(__cxa_eh_globals, __cxa_get_globals, __cxa_free_exception): Declare.\n\t(free_any_exception, _ITM_cxa_free_exception): New.\n\t(gtm_thread::init_cpp_exceptions): Define.\n\t(_ITM_cxa_allocate_exception, _ITM_cxa_throw): Adapt.\n\t(_ITM_cxa_begin_catch, _ITM_cxa_end_catch): Likewise.\n\t(gtm_thread::revert_cpp_exceptions): Likewise.\n\nFrom-SVN: r230634", "tree": {"sha": "a5f0213fc60fbb82a4c54b886984d2979e44646d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5f0213fc60fbb82a4c54b886984d2979e44646d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/258c1d072225bac0a5063ce486907c9b6eb357e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258c1d072225bac0a5063ce486907c9b6eb357e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/258c1d072225bac0a5063ce486907c9b6eb357e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258c1d072225bac0a5063ce486907c9b6eb357e2/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9afebea2d5e12b574d70497a87f0d2fd1b1d7f90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9afebea2d5e12b574d70497a87f0d2fd1b1d7f90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9afebea2d5e12b574d70497a87f0d2fd1b1d7f90"}], "stats": {"total": 273, "additions": 243, "deletions": 30}, "files": [{"sha": "92b1d280c3d85ad2c6a49fa5152aa5270c8552f4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258c1d072225bac0a5063ce486907c9b6eb357e2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258c1d072225bac0a5063ce486907c9b6eb357e2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=258c1d072225bac0a5063ce486907c9b6eb357e2", "patch": "@@ -1,3 +1,7 @@\n+2015-11-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* except.c (do_free_exception): Use transactional wrapper.\n+\n 2015-11-19  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/68422"}, {"sha": "ad40436222990821bb0e8c3575631f53808086c8", "filename": "gcc/cp/except.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258c1d072225bac0a5063ce486907c9b6eb357e2/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258c1d072225bac0a5063ce486907c9b6eb357e2/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=258c1d072225bac0a5063ce486907c9b6eb357e2", "patch": "@@ -662,6 +662,16 @@ do_free_exception (tree ptr)\n       /* Declare void __cxa_free_exception (void *) throw().  */\n       fn = declare_library_fn (fn, void_type_node, ptr_type_node,\n \t\t\t       ECF_NOTHROW | ECF_LEAF);\n+\n+      if (flag_tm)\n+\t{\n+\t  tree fn2 = get_identifier (\"_ITM_cxa_free_exception\");\n+\t  if (!get_global_value_if_present (fn2, &fn2))\n+\t    fn2 = declare_library_fn (fn2, void_type_node,\n+\t\t\t\t      ptr_type_node,\n+\t\t\t\t      ECF_NOTHROW | ECF_LEAF | ECF_TM_PURE);\n+\t  record_tm_replacement (fn, fn2);\n+\t}\n     }\n \n   return cp_build_function_call_nary (fn, tf_warning_or_error, ptr, NULL_TREE);"}, {"sha": "4be05613c6c51a8cbbce815fa4316f6f74ac78ca", "filename": "libitm/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=258c1d072225bac0a5063ce486907c9b6eb357e2", "patch": "@@ -1,3 +1,29 @@\n+2015-11-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* testsuite/libitm.c++/eh-5.C: New.\n+\t* libitm.h (_ITM_cxa_free_exception): New.\n+\t* libitm.map (_ITM_cxa_free_exception): Add it.\n+\t* libitm.texi: Update ABI docs.\n+\t* libitm_i.h (gtm_transaction_cp::cxa_unthrown): Remove.\n+\t(gtm_transaction_cp::cxa_uncaught_count): Add.\n+\t(gtm_thread::cxa_unthrown): Remove.\n+\t(gtm_thread::cxa_uncaught_count_ptr): Add.\n+\t(gtm_thread::cxa_uncaught_count): Add.\n+\t(gtm_thread::drop_references_allocations): Rename to...\n+\t(gtm_thread::discard_allocation): ... this and adapt.\n+\t(gtm_thread::init_cpp_exceptions): New.\n+\t* beginend.cc (gtm_thread::gtm_thread): Adapt EH handling.\n+\t(gtm_thread::begin_transaction): Likewise.\n+\t(gtm_transaction_cp::save): Likewise.\n+\t(gtm_thread::trycommit): Likewise.\n+\t* eh_cpp.cc: Add overview comments.\n+\t(__cxa_eh_globals, __cxa_get_globals, __cxa_free_exception): Declare.\n+\t(free_any_exception, _ITM_cxa_free_exception): New.\n+\t(gtm_thread::init_cpp_exceptions): Define.\n+\t(_ITM_cxa_allocate_exception, _ITM_cxa_throw): Adapt.\n+\t(_ITM_cxa_begin_catch, _ITM_cxa_end_catch): Likewise.\n+\t(gtm_thread::revert_cpp_exceptions): Likewise.\n+\n 2015-11-09  Torvald Riegel  <triegel@redhat.com>\n \n \t* alloc_cpp.cc (_ZdlPvX, _ZdlPvXRKSt9nothrow_t, _ZGTtdlPvX,"}, {"sha": "86f7b39173e2a1312aa582caed463e3bdddc807d", "filename": "libitm/beginend.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=258c1d072225bac0a5063ce486907c9b6eb357e2", "patch": "@@ -132,6 +132,8 @@ GTM::gtm_thread::gtm_thread ()\n   number_of_threads_changed(number_of_threads - 1, number_of_threads);\n   serial_lock.write_unlock ();\n \n+  init_cpp_exceptions ();\n+\n   if (pthread_once(&thr_release_once, thread_exit_init))\n     GTM_fatal(\"Initializing thread release TLS key failed.\");\n   // Any non-null value is sufficient to trigger destruction of this\n@@ -383,6 +385,11 @@ GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n #endif\n     }\n \n+  // Log the number of uncaught exceptions if we might have to roll back this\n+  // state.\n+  if (tx->cxa_uncaught_count_ptr != 0)\n+    tx->cxa_uncaught_count = *tx->cxa_uncaught_count_ptr;\n+\n   // Run dispatch-specific restart code. Retry until we succeed.\n   GTM::gtm_restart_reason rr;\n   while ((rr = disp->begin_or_restart()) != NO_RESTART)\n@@ -411,7 +418,7 @@ GTM::gtm_transaction_cp::save(gtm_thread* tx)\n   id = tx->id;\n   prop = tx->prop;\n   cxa_catch_count = tx->cxa_catch_count;\n-  cxa_unthrown = tx->cxa_unthrown;\n+  cxa_uncaught_count = tx->cxa_uncaught_count;\n   disp = abi_disp();\n   nesting = tx->nesting;\n }\n@@ -583,7 +590,6 @@ GTM::gtm_thread::trycommit ()\n       undolog.commit ();\n       // Reset further transaction state.\n       cxa_catch_count = 0;\n-      cxa_unthrown = NULL;\n       restart_total = 0;\n \n       // Ensure privatization safety, if necessary."}, {"sha": "1fe1c909339c7821d5c7f6dff1df1f123bc0ac55", "filename": "libitm/eh_cpp.cc", "status": "modified", "additions": 121, "deletions": 19, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Feh_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Feh_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Feh_cpp.cc?ref=258c1d072225bac0a5063ce486907c9b6eb357e2", "patch": "@@ -26,92 +26,194 @@\n \n using namespace GTM;\n \n+/* Exceptions can exist in three phases: (1) after having been allocated by\n+   __cxa_allocate_exception but before being handed off to __cxa_throw,\n+   (2) when they are in flight, so between __cxa_throw and __cxa_begin_catch,\n+   and (3) when they are being handled (between __cxa_begin_catch and\n+   __cxa_end_catch).  Note that when an exception is re-thrown in (3), it is\n+   not moving back to (2) but handled as a special case of (3) by the EH\n+   runtime.\n+\n+   We can get aborts in all three phases, for example in (1) during\n+   construction of the exception object, or in (2) in destructors called\n+   while unwinding the stack.  The transaction that created an exception\n+   object can only commit in phase (3) by re-throwing the exception; it cannot\n+   commit in other phases because throw expressions and catch clauses are\n+   properly nested wrt transactions and because the compiler wraps\n+   transaction bodies in a try/catch-all construct.\n+\n+   We handle phase (1) by dealing with exception objects similar to how we\n+   deal with other (de)allocations, which also ensures that we can have more\n+   than one exception object allocated at the same time (e.g., if the\n+   throw expression itself throws an exception and thus calls\n+   __cxa_allocate_exception).  However, on the call to __cxa_begin_catch\n+   we hand off the exception to the special handling of phase (3) and\n+   remove the undo log entry of the allocation.  Note that if the allocation\n+   happened outside of this transaction, we do not need to do anything.\n+\n+   When an exception reaches phase (2) due to a call to __cxa_throw, the count\n+   of uncaught exceptions is incremented.  We roll back this effect by saving\n+   and restoring this number in the structure returned from __cxa_get_globals.\n+   This also takes care of increments of this count when re-throwing an\n+   exception.\n+\n+   For phase (3), we keep track of the number of times __cxa_begin_catch\n+   has been called without a matching call to __cxa_end_catch.  This count\n+   is then used by __cxa_tm_cleanup to roll back the exception handling state\n+   by calling __cxa_end_catch for the exceptions that have not been finished\n+   yet (without running destructors though because we roll back the memory\n+   anyway).\n+   Once an exception that was allocated in this transaction enters phase (3),\n+   it does not need to be deallocated on abort anymore because the calls to\n+   __cxa_end_catch will take care of that.\n+\n+   We require all code executed by the transaction to be transaction_safe (or\n+   transaction_pure, or to have wrappers) if the transaction is to be rolled\n+   back.  However, we take care to not require this for transactions that\n+   just commit; this way, transactions that enter serial mode and then call\n+   uninstrumented code continue to work.\n+   */\n+\n /* Everything from libstdc++ is weak, to avoid requiring that library\n    to be linked into plain C applications using libitm.so.  */\n \n #define WEAK  __attribute__((weak))\n \n extern \"C\" {\n \n+struct __cxa_eh_globals\n+{\n+  void *\tcaughtExceptions;\n+  unsigned int\tuncaughtExceptions;\n+};\n+\n extern void *__cxa_allocate_exception (size_t) WEAK;\n+extern void __cxa_free_exception (void *) WEAK;\n extern void __cxa_throw (void *, void *, void *) WEAK;\n extern void *__cxa_begin_catch (void *) WEAK;\n extern void __cxa_end_catch (void) WEAK;\n extern void __cxa_tm_cleanup (void *, void *, unsigned int) WEAK;\n+extern __cxa_eh_globals *__cxa_get_globals (void) WEAK;\n \n #if !defined (HAVE_ELF_STYLE_WEAKREF) \n void *__cxa_allocate_exception (size_t) { return NULL; }\n+void __cxa_free_exception (void *) { return; }\n void __cxa_throw (void *, void *, void *) { return; }\n void *__cxa_begin_catch (void *) { return NULL; }\n void __cxa_end_catch (void) { return; }\n void __cxa_tm_cleanup (void *, void *, unsigned int) { return; }\n void _Unwind_DeleteException (_Unwind_Exception *) { return; }\n+__cxa_eh_globals *__cxa_get_globals (void) { return NULL; }\n #endif /* HAVE_ELF_STYLE_WEAKREF */\n \n }\n \n+static void\n+free_any_exception (void *exc_ptr)\n+{\n+  // The exception could be in phase (2) and thus calling just\n+  // _cxa_free_exception might not be sufficient.\n+  __cxa_tm_cleanup (NULL, exc_ptr, 0);\n+}\n \n void *\n _ITM_cxa_allocate_exception (size_t size)\n {\n   void *r = __cxa_allocate_exception (size);\n-  gtm_thr()->cxa_unthrown = r;\n+  gtm_thr()->record_allocation (r, free_any_exception);\n   return r;\n }\n \n+void\n+_ITM_cxa_free_exception (void *exc_ptr)\n+{\n+  // __cxa_free_exception can be called from user code directly if\n+  // construction of an exception object throws another exception, in which\n+  // case we need to roll back the initial exception.  We handle this similar\n+  // to dead allocations in that we deallocate the exception on both commit\n+  // and abort of an outermost transaction.\n+  gtm_thr()->forget_allocation (exc_ptr, free_any_exception);\n+}\n+\n void\n _ITM_cxa_throw (void *obj, void *tinfo, void *dest)\n {\n-  gtm_thr()->cxa_unthrown = NULL;\n+  // This used to be instrumented, but does not need to be anymore.\n   __cxa_throw (obj, tinfo, dest);\n }\n \n void *\n _ITM_cxa_begin_catch (void *exc_ptr)\n {\n-  gtm_thr()->cxa_catch_count++;\n+  // If this exception object has been allocated by this transaction, we\n+  // discard the undo log entry for the allocation; we are entering phase (3)\n+  // now and will handle this exception specially.\n+  // Note that this exception cannot have been allocated in a parent\n+  // transaction or enclosing nontransactional block because an atomic block\n+  // cannot contain just a catch clause but not the associated try clause.\n+  // The exception can have been allocated in a nested transaction, in which\n+  // case the commit of the nested transaction will have inserted the undo\n+  // log entry of the allocation in our undo log.\n+  // The exception can also have been allocated in a nested nontransactional\n+  // block, but then this transaction cannot abort anymore; functions that\n+  // are marked transaction_pure, for example, must not side-step the\n+  // transactional exception handling we implement here.\n+  gtm_thread *t = gtm_thr ();\n+  t->discard_allocation (exc_ptr);\n+  // Keep track of the number of unfinished catch handlers.\n+  t->cxa_catch_count++;\n   return __cxa_begin_catch (exc_ptr);\n }\n \n void\n _ITM_cxa_end_catch (void)\n {\n+  // Keep track of the number of unfinished catch handlers.\n   gtm_thr()->cxa_catch_count--;\n   __cxa_end_catch ();\n }\n \n+void\n+GTM::gtm_thread::init_cpp_exceptions ()\n+{\n+  // Only save and restore the number of uncaught exceptions if this is\n+  // actually used in the program.\n+  if (__cxa_get_globals != NULL && __cxa_get_globals () != 0)\n+    cxa_uncaught_count_ptr = &__cxa_get_globals ()->uncaughtExceptions;\n+  else\n+    cxa_uncaught_count_ptr = 0;\n+}\n+\n void\n GTM::gtm_thread::revert_cpp_exceptions (gtm_transaction_cp *cp)\n {\n   if (cp)\n     {\n-      // If rolling back a nested transaction, only clean up unthrown\n-      // exceptions since the last checkpoint. Always reset eh_in_flight\n-      // because it just contains the argument provided to\n-      // _ITM_commitTransactionEH\n-      void *unthrown =\n-\t  (cxa_unthrown != cp->cxa_unthrown ? cxa_unthrown : NULL);\n+      // If rolling back a nested transaction, only clean up incompletely\n+      // caught exceptions since the last checkpoint.\n       assert (cxa_catch_count >= cp->cxa_catch_count);\n       uint32_t catch_count = cxa_catch_count - cp->cxa_catch_count;\n-      if (unthrown || catch_count)\n+      if (catch_count)\n \t{\n-\t  __cxa_tm_cleanup (unthrown, this->eh_in_flight, catch_count);\n+\t  __cxa_tm_cleanup (NULL, NULL, catch_count);\n \t  cxa_catch_count = cp->cxa_catch_count;\n-\t  cxa_unthrown = cp->cxa_unthrown;\n-\t  this->eh_in_flight = NULL;\n \t}\n     }\n   else\n     {\n       // Both cxa_catch_count and cxa_unthrown are maximal because EH regions\n       // and transactions are properly nested.\n-      if (this->cxa_unthrown || this->cxa_catch_count)\n+      if (cxa_catch_count)\n \t{\n-\t  __cxa_tm_cleanup (this->cxa_unthrown, this->eh_in_flight,\n-\t      this->cxa_catch_count);\n-\t  this->cxa_catch_count = 0;\n-\t  this->cxa_unthrown = NULL;\n-\t  this->eh_in_flight = NULL;\n+\t  __cxa_tm_cleanup (NULL, NULL, cxa_catch_count);\n+\t  cxa_catch_count = 0;\n \t}\n     }\n+  // Reset the number of uncaught exceptions.  Any allocations for these\n+  // exceptions have been rolled back already, if necessary.\n+  if (cxa_uncaught_count_ptr != 0)\n+    *cxa_uncaught_count_ptr = cxa_uncaught_count;\n+  // Always reset eh_in_flight because it just contains the argument provided\n+  // to _ITM_commitTransactionEH.\n+  eh_in_flight = NULL;\n }"}, {"sha": "900c444721564ac2f51170f47c06bc9217156532", "filename": "libitm/libitm.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Flibitm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Flibitm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm.h?ref=258c1d072225bac0a5063ce486907c9b6eb357e2", "patch": "@@ -283,6 +283,7 @@ extern void _ITM_registerTMCloneTable (void *, size_t);\n extern void _ITM_deregisterTMCloneTable (void *);\n \n extern void *_ITM_cxa_allocate_exception (size_t);\n+extern void _ITM_cxa_free_exception (void *exc_ptr);\n extern void _ITM_cxa_throw (void *obj, void *tinfo, void *dest);\n extern void *_ITM_cxa_begin_catch (void *exc_ptr);\n extern void _ITM_cxa_end_catch (void);"}, {"sha": "b2e1c2db39c753ed7d01f6fe4f44bef2943edb4b", "filename": "libitm/libitm.map", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Flibitm.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Flibitm.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm.map?ref=258c1d072225bac0a5063ce486907c9b6eb357e2", "patch": "@@ -186,4 +186,5 @@ LIBITM_1.1 {\n   global:\n \t_ZGTtdlPv?;\n \t_ZGTtdlPv?RKSt9nothrow_t;\n+\t_ITM_cxa_free_exception;\n } LIBITM_1.0;"}, {"sha": "eb57fda482dd8942e1a64090a23c1a753f1aaec6", "filename": "libitm/libitm.texi", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Flibitm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Flibitm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm.texi?ref=258c1d072225bac0a5063ce486907c9b6eb357e2", "patch": "@@ -268,17 +268,26 @@ transactions.\n @example\n void _ITM_commitTransactionEH(void *exc_ptr) ITM_REGPARM;\n void *_ITM_cxa_allocate_exception (size_t);\n+void _ITM_cxa_free_exception (void *exc_ptr);\n void _ITM_cxa_throw (void *obj, void *tinfo, void *dest);\n void *_ITM_cxa_begin_catch (void *exc_ptr);\n void _ITM_cxa_end_catch (void);\n @end example\n \n-@code{_ITM_commitTransactionEH} must be called to commit a transaction if an\n-exception could be in flight at this position in the code. @code{exc_ptr} is\n-the current exception or zero if there is no current exception.\n+The EH scheme changed in version 6 of GCC.  Previously, the compiler\n+added a call to @code{_ITM_commitTransactionEH} to commit a transaction if\n+an exception could be in flight at this position in the code; @code{exc_ptr} is\n+the address of the current exception and must be non-zero.  Now, the\n+compiler must catch all exceptions that are about to be thrown out of a\n+transaction and call @code{_ITM_commitTransactionEH} from the catch clause,\n+with @code{exc_ptr} being zero.\n+\n+Note that the old EH scheme never worked completely in GCC's implementation;\n+libitm currently does not try to be compatible with the old scheme.\n+\n The @code{_ITM_cxa...} functions are transactional wrappers for the respective\n @code{__cxa...} functions and must be called instead of these in transactional\n-code.\n+code.  @code{_ITM_cxa_free_exception} is new in GCC 6.\n \n To support this EH scheme, libstdc++ needs to provide one additional function\n (@code{_cxa_tm_cleanup}), which is used by the TM to clean up the exception\n@@ -289,7 +298,8 @@ void __cxa_tm_cleanup (void *unthrown_obj, void *cleanup_exc,\n                        unsigned int caught_count);\n @end example\n \n-@code{unthrown_obj} is non-null if the program called\n+Since GCC 6, @code{unthrown_obj} is not used anymore and always null;\n+prior to that, @code{unthrown_obj} is non-null if the program called\n @code{__cxa_allocate_exception} for this exception but did not yet called\n @code{__cxa_throw} for it. @code{cleanup_exc} is non-null if the program is\n currently processing a cleanup along an exception path but has not caught this\n@@ -406,6 +416,10 @@ These functions are essentially transactional wrappers for @code{malloc},\n @code{calloc}, and @code{free}. Within transactions, the compiler should\n replace calls to the original functions with calls to the wrapper functions.\n \n+libitm also provides transactional clones of C++ memory management functions\n+such as global operator new and delete.  They are part of libitm for historic\n+reasons but do not need to be part of this ABI.\n+\n \n @section [No changes] Future Enhancements to the ABI\n "}, {"sha": "f01a1ab54e40f71baf92ab8e67a014b636f67880", "filename": "libitm/libitm_i.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Flibitm_i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Flibitm_i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm_i.h?ref=258c1d072225bac0a5063ce486907c9b6eb357e2", "patch": "@@ -132,7 +132,7 @@ struct gtm_transaction_cp\n   _ITM_transactionId_t id;\n   uint32_t prop;\n   uint32_t cxa_catch_count;\n-  void *cxa_unthrown;\n+  unsigned int cxa_uncaught_count;\n   // We might want to use a different but compatible dispatch method for\n   // a nested transaction.\n   abi_dispatch *disp;\n@@ -242,7 +242,9 @@ struct gtm_thread\n \n   // Data used by eh_cpp.c for managing exceptions within the transaction.\n   uint32_t cxa_catch_count;\n-  void *cxa_unthrown;\n+  // If cxa_uncaught_count_ptr is 0, we don't need to roll back exceptions.\n+  unsigned int *cxa_uncaught_count_ptr;\n+  unsigned int cxa_uncaught_count;\n   void *eh_in_flight;\n \n   // Checkpoints for closed nesting.\n@@ -284,9 +286,9 @@ struct gtm_thread\n   void record_allocation (void *, void (*)(void *));\n   void forget_allocation (void *, void (*)(void *));\n   void forget_allocation (void *, size_t, void (*)(void *, size_t));\n-  void drop_references_allocations (const void *ptr)\n+  void discard_allocation (const void *ptr)\n   {\n-    this->alloc_actions.erase((uintptr_t) ptr);\n+    alloc_actions.erase((uintptr_t) ptr);\n   }\n \n   // In beginend.cc\n@@ -306,6 +308,7 @@ struct gtm_thread\n   static uint32_t begin_transaction(uint32_t, const gtm_jmpbuf *)\n \t__asm__(UPFX \"GTM_begin_transaction\") ITM_REGPARM;\n   // In eh_cpp.cc\n+  void init_cpp_exceptions ();\n   void revert_cpp_exceptions (gtm_transaction_cp *cp = 0);\n \n   // In retry.cc"}, {"sha": "ae38bbaced5e6bf445fe9893a1eb406f80893475", "filename": "libitm/testsuite/libitm.c++/eh-5.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Feh-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258c1d072225bac0a5063ce486907c9b6eb357e2/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Feh-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Feh-5.C?ref=258c1d072225bac0a5063ce486907c9b6eb357e2", "patch": "@@ -0,0 +1,46 @@\n+// Test throwing an exception whose constructor might throw.  This tests that\n+// _cxa_free_exception is instrumented.\n+\n+// { dg-do run }\n+// { dg-options \"-fgnu-tm\" }\n+\n+void __attribute__ ((transaction_pure,noinline)) dontoptimize (int *i)\n+{ }\n+\n+struct test\n+{\n+  int* data;\n+  test (int i)\n+  {\n+    // new may throw\n+    data = new int[1];\n+    data[0] = i;\n+    dontoptimize (data);\n+  }\n+  test (const test& t) : test (t.data[0])\n+  { }\n+  ~test ()\n+  {\n+    delete data;\n+  }\n+  bool operator !=(const test& other)\n+  {\n+    return data[0] != other.data[0];\n+  }\n+};\n+\n+int main()\n+{\n+  try\n+    {\n+      atomic_commit\n+      {\n+\tthrow test(23);\n+      }\n+    }\n+  catch (test ex)\n+    {\n+      if (ex.data[0] != 23) __builtin_abort ();\n+    }\n+  return 0;\n+}"}]}