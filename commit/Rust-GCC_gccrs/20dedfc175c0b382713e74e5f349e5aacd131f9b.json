{"sha": "20dedfc175c0b382713e74e5f349e5aacd131f9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBkZWRmYzE3NWMwYjM4MjcxM2U3NGU1ZjM0OWU1YWFjZDEzMWY5Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:50:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:50:09Z"}, "message": "s-tpobop.ads, [...] (Requeue_With_Abort): Rename field With_Abort.\n\n2007-08-14  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-tpobop.ads, s-tpobop.adb, s-tasren.ads, s-tasren.adb,\n\ts-taskin.ads (Requeue_With_Abort): Rename field With_Abort.\n\t(PO_Do_Or_Queue, Task_Do_Or_Queue, Requeue_Call): Remove With_Abort\n\tparameter.\n\n\t* s-tassta.adb (Task_Wrapper): Increased value of the small overflow\n\tguard to 12K.\n\nFrom-SVN: r127464", "tree": {"sha": "a20a112267b3d26b76911b0e846b2fcf076bcea7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a20a112267b3d26b76911b0e846b2fcf076bcea7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20dedfc175c0b382713e74e5f349e5aacd131f9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20dedfc175c0b382713e74e5f349e5aacd131f9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20dedfc175c0b382713e74e5f349e5aacd131f9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20dedfc175c0b382713e74e5f349e5aacd131f9b/comments", "author": null, "committer": null, "parents": [{"sha": "cc8be39eb70e2ce724d6f82fb8847ac458af0428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc8be39eb70e2ce724d6f82fb8847ac458af0428", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc8be39eb70e2ce724d6f82fb8847ac458af0428"}], "stats": {"total": 129, "additions": 60, "deletions": 69}, "files": [{"sha": "e8c0653deb61157421caf76292dfc5364154cbea", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=20dedfc175c0b382713e74e5f349e5aacd131f9b", "patch": "@@ -799,9 +799,9 @@ package System.Tasking is\n       --  Cancellation of the call has been attempted.\n       --  Consider merging this into State???\n \n-      Requeue_With_Abort : Boolean := False;\n-      --  Temporary to tell caller whether requeue is with abort.\n-      --  Find a better way of doing this ???\n+      With_Abort : Boolean := False;\n+      --  Tell caller whether the call may be aborted\n+      --  ??? consider merging this with Was_Abortable state\n \n       Needs_Requeue : Boolean := False;\n       --  Temporary to tell acceptor of task entry call that"}, {"sha": "2af7365554bb0b196f0ee5d8dd5b20d961a24428", "filename": "gcc/ada/s-tasren.adb", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.adb?ref=20dedfc175c0b382713e74e5f349e5aacd131f9b", "patch": "@@ -456,16 +456,15 @@ package body System.Tasking.Rendezvous is\n       Entry_Call.Uninterpreted_Data := Uninterpreted_Data;\n       Entry_Call.Called_Task := Acceptor;\n       Entry_Call.Exception_To_Raise := Ada.Exceptions.Null_Id;\n+      Entry_Call.With_Abort := True;\n \n       --  Note: the caller will undefer abort on return (see WARNING above)\n \n       if Single_Lock then\n          Lock_RTS;\n       end if;\n \n-      if not Task_Do_Or_Queue\n-        (Self_Id, Entry_Call, With_Abort => True)\n-      then\n+      if not Task_Do_Or_Queue (Self_Id, Entry_Call) then\n          STPO.Write_Lock (Self_Id);\n          Utilities.Exit_One_ATC_Level (Self_Id);\n          STPO.Unlock (Self_Id);\n@@ -646,9 +645,7 @@ package body System.Tasking.Rendezvous is\n                   Lock_RTS;\n                end if;\n \n-               if not Task_Do_Or_Queue\n-                 (Self_Id, Entry_Call, Entry_Call.Requeue_With_Abort)\n-               then\n+               if not Task_Do_Or_Queue (Self_Id, Entry_Call) then\n                   if Single_Lock then\n                      Unlock_RTS;\n                   end if;\n@@ -687,9 +684,7 @@ package body System.Tasking.Rendezvous is\n                   end if;\n \n                else\n-                  POO.PO_Do_Or_Queue\n-                    (Self_Id, Called_PO, Entry_Call,\n-                     Entry_Call.Requeue_With_Abort);\n+                  POO.PO_Do_Or_Queue (Self_Id, Called_PO, Entry_Call);\n                   POO.PO_Service_Entries (Self_Id, Called_PO);\n                end if;\n             end if;\n@@ -758,7 +753,7 @@ package body System.Tasking.Rendezvous is\n       Entry_Call.E := Entry_Index (E);\n       Entry_Call.Called_Task := Acceptor;\n       Entry_Call.Called_PO := Null_Address;\n-      Entry_Call.Requeue_With_Abort := With_Abort;\n+      Entry_Call.With_Abort := With_Abort;\n       Object.Call_In_Progress := null;\n    end Requeue_Protected_To_Task_Entry;\n \n@@ -777,7 +772,7 @@ package body System.Tasking.Rendezvous is\n    begin\n       Initialization.Defer_Abort (Self_Id);\n       Entry_Call.Needs_Requeue := True;\n-      Entry_Call.Requeue_With_Abort := With_Abort;\n+      Entry_Call.With_Abort := With_Abort;\n       Entry_Call.E := Entry_Index (E);\n       Entry_Call.Called_Task := Acceptor;\n       Initialization.Undefer_Abort (Self_Id);\n@@ -1102,12 +1097,12 @@ package body System.Tasking.Rendezvous is\n          Unlock_RTS;\n       end if;\n \n+      Initialization.Undefer_Abort (Self_Id);\n+\n       --  Call Yield to let other tasks get a chance to run as this is a\n       --  potential dispatching point.\n \n       Yield (Do_Yield => False);\n-\n-      Initialization.Undefer_Abort (Self_Id);\n       return Return_Count;\n    end Task_Count;\n \n@@ -1117,8 +1112,7 @@ package body System.Tasking.Rendezvous is\n \n    function Task_Do_Or_Queue\n      (Self_ID    : Task_Id;\n-      Entry_Call : Entry_Call_Link;\n-      With_Abort : Boolean) return Boolean\n+      Entry_Call : Entry_Call_Link) return Boolean\n    is\n       E             : constant Task_Entry_Index :=\n                         Task_Entry_Index (Entry_Call.E);\n@@ -1273,7 +1267,7 @@ package body System.Tasking.Rendezvous is\n       --  (re)enqueue the call, if the mode permits that.\n \n       if Entry_Call.Mode /= Conditional_Call\n-        or else not With_Abort\n+        or else not Entry_Call.With_Abort\n       then\n          --  Timed_Call, Simple_Call, or Asynchronous_Call\n \n@@ -1283,7 +1277,8 @@ package body System.Tasking.Rendezvous is\n \n          pragma Assert (Old_State < Done);\n \n-         Entry_Call.State := New_State (With_Abort, Entry_Call.State);\n+         Entry_Call.State :=\n+           New_State (Entry_Call.With_Abort, Entry_Call.State);\n \n          STPO.Unlock (Acceptor);\n \n@@ -1391,14 +1386,13 @@ package body System.Tasking.Rendezvous is\n          Entry_Call.Called_Task := Acceptor;\n          Entry_Call.Called_PO := Null_Address;\n          Entry_Call.Exception_To_Raise := Ada.Exceptions.Null_Id;\n+         Entry_Call.With_Abort := True;\n \n          if Single_Lock then\n             Lock_RTS;\n          end if;\n \n-         if not Task_Do_Or_Queue\n-           (Self_Id, Entry_Call, With_Abort => True)\n-         then\n+         if not Task_Do_Or_Queue (Self_Id, Entry_Call) then\n             STPO.Write_Lock (Self_Id);\n             Utilities.Exit_One_ATC_Level (Self_Id);\n             STPO.Unlock (Self_Id);\n@@ -1759,16 +1753,15 @@ package body System.Tasking.Rendezvous is\n       Entry_Call.Called_Task := Acceptor;\n       Entry_Call.Called_PO := Null_Address;\n       Entry_Call.Exception_To_Raise := Ada.Exceptions.Null_Id;\n+      Entry_Call.With_Abort := True;\n \n       --  Note: the caller will undefer abort on return (see WARNING above)\n \n       if Single_Lock then\n          Lock_RTS;\n       end if;\n \n-      if not Task_Do_Or_Queue\n-       (Self_Id, Entry_Call, With_Abort => True)\n-      then\n+      if not Task_Do_Or_Queue (Self_Id, Entry_Call) then\n          STPO.Write_Lock (Self_Id);\n          Utilities.Exit_One_ATC_Level (Self_Id);\n          STPO.Unlock (Self_Id);"}, {"sha": "67fdc5a1437f5b7c2ef758a8b2c19c4b7b908cad", "filename": "gcc/ada/s-tasren.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-tasren.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-tasren.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.ads?ref=20dedfc175c0b382713e74e5f349e5aacd131f9b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -319,8 +319,7 @@ package System.Tasking.Rendezvous is\n \n    function Task_Do_Or_Queue\n      (Self_ID    : Task_Id;\n-      Entry_Call : Entry_Call_Link;\n-      With_Abort : Boolean) return Boolean;\n+      Entry_Call : Entry_Call_Link) return Boolean;\n    --  Call this only with abort deferred and holding no locks, except\n    --  the global RTS lock when Single_Lock is True which must be owned.\n    --  Returns False iff the call cannot be served or queued, as is the"}, {"sha": "3086a69f6d26252e11e52ed2af1956f4060f8c0f", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=20dedfc175c0b382713e74e5f349e5aacd131f9b", "patch": "@@ -770,7 +770,7 @@ package body System.Tasking.Stages is\n       pragma Assert (Self_ID = Environment_Task);\n \n       --  Set Environment_Task'Callable to false to notify library-level tasks\n-      --  that it is waiting for them (cf 5619-003).\n+      --  that it is waiting for them.\n \n       Self_ID.Callable := False;\n \n@@ -798,8 +798,8 @@ package body System.Tasking.Stages is\n          exit when Utilities.Independent_Task_Count = 0;\n \n          --  We used to yield here, but this did not take into account\n-         --  low priority tasks that would cause dead lock in some cases.\n-         --  See 8126-020.\n+         --  low priority tasks that would cause dead lock in some cases\n+         --  (true FIFO scheduling).\n \n          Timed_Sleep\n            (Self_ID, 0.01, System.OS_Primitives.Relative,\n@@ -958,24 +958,30 @@ package body System.Tasking.Stages is\n       Secondary_Stack : aliased SSE.Storage_Array (1 .. Secondary_Stack_Size);\n \n       pragma Warnings (Off);\n+      --  Why are warnings being turned off here???\n+\n       Secondary_Stack_Address : System.Address := Secondary_Stack'Address;\n \n-      Small_Overflow_Guard    : constant := 4 * 1024;\n-      Big_Overflow_Guard      : constant := 16 * 1024;\n-      Small_Stack_Limit       : constant := 64 * 1024;\n+      Small_Overflow_Guard : constant := 12 * 1024;\n+      --  Note: this used to be 4K, but was changed to 12K, since smaller\n+      --  values resulted in segmentation faults from dynamic stack analysis.\n+\n+      Big_Overflow_Guard   : constant := 16 * 1024;\n+      Small_Stack_Limit    : constant := 64 * 1024;\n       --  ??? These three values are experimental, and seems to work on most\n-      --  platforms. They still need to be analyzed further.\n+      --  platforms. They still need to be analyzed further. They also need\n+      --  documentation, what are they???\n \n-      Size :\n-        Natural := Natural (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size);\n+      Size : Natural :=\n+               Natural (Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size);\n \n       Overflow_Guard : Natural;\n       --  Size of the overflow guard, used by dynamic stack usage analysis\n \n       pragma Warnings (On);\n       --  Address of secondary stack. In the fixed secondary stack case, this\n       --  value is not modified, causing a warning, hence the bracketing with\n-      --  Warnings (Off/On).\n+      --  Warnings (Off/On). But why is so much *more* bracketed ???\n \n       SEH_Table : aliased SSE.Storage_Array (1 .. 8);\n       --  Structured Exception Registration table (2 words)\n@@ -1145,8 +1151,7 @@ package body System.Tasking.Stages is\n                Cause := Abnormal;\n             end if;\n          when others =>\n-            --  ??? Using an E : others here causes CD2C11A  to fail on\n-            --      DEC Unix, see 7925-005.\n+            --  ??? Using an E : others here causes CD2C11A to fail on Tru64.\n \n             Initialization.Defer_Abort_Nestable (Self_ID);\n \n@@ -1253,7 +1258,7 @@ package body System.Tasking.Stages is\n       --  Since GCC cannot allocate stack chunks efficiently without reordering\n       --  some of the allocations, we have to handle this unexpected situation\n       --  here. We should normally never have to call Vulnerable_Complete_Task\n-      --  here. See 6602-003 for more details.\n+      --  here.\n \n       if Self_ID.Common.Activator /= null then\n          Vulnerable_Complete_Task (Self_ID);"}, {"sha": "25208ad10c038cea4fd4e27e8216e83ac8242838", "filename": "gcc/ada/s-tpobop.adb", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-tpobop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-tpobop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpobop.adb?ref=20dedfc175c0b382713e74e5f349e5aacd131f9b", "patch": "@@ -123,8 +123,7 @@ package body System.Tasking.Protected_Objects.Operations is\n    procedure Requeue_Call\n      (Self_Id    : Task_Id;\n       Object     : Protection_Entries_Access;\n-      Entry_Call : Entry_Call_Link;\n-      With_Abort : Boolean);\n+      Entry_Call : Entry_Call_Link);\n    --  Handle requeue of Entry_Call.\n    --  In particular, queue the call if needed, or service it immediately\n    --  if possible.\n@@ -314,8 +313,7 @@ package body System.Tasking.Protected_Objects.Operations is\n    procedure PO_Do_Or_Queue\n      (Self_ID    : Task_Id;\n       Object     : Protection_Entries_Access;\n-      Entry_Call : Entry_Call_Link;\n-      With_Abort : Boolean)\n+      Entry_Call : Entry_Call_Link)\n    is\n       E             : constant Protected_Entry_Index :=\n                         Protected_Entry_Index (Entry_Call.E);\n@@ -366,11 +364,11 @@ package body System.Tasking.Protected_Objects.Operations is\n             end if;\n \n          else\n-            Requeue_Call (Self_ID, Object, Entry_Call, With_Abort);\n+            Requeue_Call (Self_ID, Object, Entry_Call);\n          end if;\n \n       elsif Entry_Call.Mode /= Conditional_Call\n-        or else not With_Abort\n+        or else not Entry_Call.With_Abort\n       then\n \n          if Run_Time_Restrictions.Set (Max_Entry_Queue_Length)\n@@ -396,7 +394,7 @@ package body System.Tasking.Protected_Objects.Operations is\n             end if;\n          else\n             Queuing.Enqueue (Object.Entry_Queues (E), Entry_Call);\n-            Update_For_Queue_To_PO (Entry_Call, With_Abort);\n+            Update_For_Queue_To_PO (Entry_Call, Entry_Call.With_Abort);\n          end if;\n       else\n          --  Conditional_Call and With_Abort\n@@ -467,8 +465,7 @@ package body System.Tasking.Protected_Objects.Operations is\n          end;\n \n          if Object.Call_In_Progress = null then\n-            Requeue_Call\n-              (Self_ID, Object, Entry_Call, Entry_Call.Requeue_With_Abort);\n+            Requeue_Call (Self_ID, Object, Entry_Call);\n             exit when Entry_Call.State = Cancelled;\n \n          else\n@@ -628,8 +625,9 @@ package body System.Tasking.Protected_Objects.Operations is\n       Entry_Call.Called_PO := To_Address (Object);\n       Entry_Call.Called_Task := null;\n       Entry_Call.Exception_To_Raise := Ada.Exceptions.Null_Id;\n+      Entry_Call.With_Abort := True;\n \n-      PO_Do_Or_Queue (Self_ID, Object, Entry_Call, With_Abort => True);\n+      PO_Do_Or_Queue (Self_ID, Object, Entry_Call);\n       Initially_Abortable := Entry_Call.State = Now_Abortable;\n       PO_Service_Entries (Self_ID, Object);\n \n@@ -712,8 +710,7 @@ package body System.Tasking.Protected_Objects.Operations is\n    procedure Requeue_Call\n      (Self_Id    : Task_Id;\n       Object     : Protection_Entries_Access;\n-      Entry_Call : Entry_Call_Link;\n-      With_Abort : Boolean)\n+      Entry_Call : Entry_Call_Link)\n    is\n       New_Object        : Protection_Entries_Access;\n       Ceiling_Violation : Boolean;\n@@ -731,9 +728,7 @@ package body System.Tasking.Protected_Objects.Operations is\n             STPO.Lock_RTS;\n          end if;\n \n-         Result := Rendezvous.Task_Do_Or_Queue\n-           (Self_Id, Entry_Call,\n-            With_Abort => Entry_Call.Requeue_With_Abort);\n+         Result := Rendezvous.Task_Do_Or_Queue (Self_Id, Entry_Call);\n \n          if not Result then\n             Queuing.Broadcast_Program_Error\n@@ -759,7 +754,7 @@ package body System.Tasking.Protected_Objects.Operations is\n                  (Self_Id, Object, Entry_Call);\n \n             else\n-               PO_Do_Or_Queue (Self_Id, New_Object, Entry_Call, With_Abort);\n+               PO_Do_Or_Queue (Self_Id, New_Object, Entry_Call);\n                PO_Service_Entries (Self_Id, New_Object);\n             end if;\n \n@@ -772,7 +767,7 @@ package body System.Tasking.Protected_Objects.Operations is\n \n             STPO.Yield (False);\n \n-            if Entry_Call.Requeue_With_Abort\n+            if Entry_Call.With_Abort\n               and then Entry_Call.Cancellation_Attempted\n             then\n                --  If this is a requeue with abort and someone tried\n@@ -782,7 +777,7 @@ package body System.Tasking.Protected_Objects.Operations is\n                return;\n             end if;\n \n-            if not With_Abort\n+            if not Entry_Call.With_Abort\n               or else Entry_Call.Mode /= Conditional_Call\n             then\n                E := Protected_Entry_Index (Entry_Call.E);\n@@ -812,11 +807,11 @@ package body System.Tasking.Protected_Objects.Operations is\n                else\n                   Queuing.Enqueue\n                     (New_Object.Entry_Queues (E), Entry_Call);\n-                  Update_For_Queue_To_PO (Entry_Call, With_Abort);\n+                  Update_For_Queue_To_PO (Entry_Call, Entry_Call.With_Abort);\n                end if;\n \n             else\n-               PO_Do_Or_Queue (Self_Id, New_Object, Entry_Call, With_Abort);\n+               PO_Do_Or_Queue (Self_Id, New_Object, Entry_Call);\n             end if;\n          end if;\n       end if;\n@@ -890,7 +885,7 @@ package body System.Tasking.Protected_Objects.Operations is\n       Entry_Call.E := Entry_Index (E);\n       Entry_Call.Called_PO := To_Address (New_Object);\n       Entry_Call.Called_Task := null;\n-      Entry_Call.Requeue_With_Abort := With_Abort;\n+      Entry_Call.With_Abort := With_Abort;\n       Object.Call_In_Progress := null;\n    end Requeue_Protected_Entry;\n \n@@ -935,7 +930,7 @@ package body System.Tasking.Protected_Objects.Operations is\n       --  at this point, and therefore, the caller cannot cancel the call.\n \n       Entry_Call.Needs_Requeue := True;\n-      Entry_Call.Requeue_With_Abort := With_Abort;\n+      Entry_Call.With_Abort := With_Abort;\n       Entry_Call.Called_PO := To_Address (New_Object);\n       Entry_Call.Called_Task := null;\n       Entry_Call.E := Entry_Index (E);\n@@ -1022,8 +1017,9 @@ package body System.Tasking.Protected_Objects.Operations is\n       Entry_Call.Called_PO := To_Address (Object);\n       Entry_Call.Called_Task := null;\n       Entry_Call.Exception_To_Raise := Ada.Exceptions.Null_Id;\n+      Entry_Call.With_Abort := True;\n \n-      PO_Do_Or_Queue (Self_Id, Object, Entry_Call, With_Abort => True);\n+      PO_Do_Or_Queue (Self_Id, Object, Entry_Call);\n       PO_Service_Entries (Self_Id, Object);\n \n       if Single_Lock then"}, {"sha": "0316e0c6564547e11ff1da311b7121a3d7f53dc2", "filename": "gcc/ada/s-tpobop.ads", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-tpobop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20dedfc175c0b382713e74e5f349e5aacd131f9b/gcc%2Fada%2Fs-tpobop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpobop.ads?ref=20dedfc175c0b382713e74e5f349e5aacd131f9b", "patch": "@@ -187,8 +187,7 @@ package System.Tasking.Protected_Objects.Operations is\n    procedure PO_Do_Or_Queue\n      (Self_ID    : Task_Id;\n       Object     : Entries.Protection_Entries_Access;\n-      Entry_Call : Entry_Call_Link;\n-      With_Abort : Boolean);\n+      Entry_Call : Entry_Call_Link);\n    --  This procedure either executes or queues an entry call, depending\n    --  on the status of the corresponding barrier. It assumes that abort\n    --  is deferred and that the specified object is locked.\n@@ -201,10 +200,9 @@ private\n    end record;\n    pragma Volatile (Communication_Block);\n \n-   --  ?????\n    --  The Communication_Block seems to be a relic. At the moment, the\n    --  compiler seems to be generating unnecessary conditional code based on\n    --  this block. See the code generated for async. select with task entry\n-   --  call for another way of solving this.\n+   --  call for another way of solving this ???\n \n end System.Tasking.Protected_Objects.Operations;"}]}