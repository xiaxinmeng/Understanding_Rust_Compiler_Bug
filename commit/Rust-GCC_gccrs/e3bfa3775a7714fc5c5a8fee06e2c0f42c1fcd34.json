{"sha": "e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNiZmEzNzc1YTc3MTRmYzVjNWE4ZmVlMDZlMmMwZjQyYzFmY2QzNA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2018-05-25T10:35:44Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2018-05-25T10:35:44Z"}, "message": "tree-outof-ssa.c (tree-ssa.h, tree-dfa.h): Include header files.\n\n\t* tree-outof-ssa.c (tree-ssa.h, tree-dfa.h): Include header files.\n\t(create_default_def, for_all_parms): Moved from tree-ssa-coalesce.c.\n\t(parm_default_def_partition_arg): Ditto.\n\t(set_parm_default_def_partition): Ditto.\n\t(get_parm_default_def_partitions): Ditto and make it static.\n\t(get_undefined_value_partitions): Ditto and make it static.\n\t(remove_ssa_form): Refactor call to init_var_map here.\n\t* tree-ssa-coalesce.c (build_ssa_conflict_graph): Support live range\n\tcomputation for loop region.\n\t(coalesce_partitions, compute_optimized_partition_bases): Ditto.\n\t(register_default_def): Delete.\n\t(for_all_parms, create_default_def): Move to tree-outof-ssa.c.\n\t(parm_default_def_partition_arg): Ditto.\n\t(set_parm_default_def_partition): Ditto.\n\t(get_parm_default_def_partitions): Ditto and make it static.\n\t(get_undefined_value_partitions): Ditto and make it static.\n\t(coalesce_with_default, coalesce_with_default): Update comment.\n\t(create_coalesce_list_for_region): New func factored out from\n\tcreate_outofssa_var_map.\n\t(populate_coalesce_list_for_outofssa): New func factored out from\n\tcreate_outofssa_var_map and coalesce_ssa_name.\n\t(create_outofssa_var_map): Delete.\n\t(coalesce_ssa_name): Refactor to support live range computation.\n\t* tree-ssa-coalesce.h (coalesce_ssa_name): Change decl.\n\t(get_parm_default_def_partitions): Delete.\n\t(get_undefined_value_partitions): Ditto.\n\t* tree-ssa-live.c (init_var_map, delete_var_map): Support live range\n\tcomputation for loop region.\n\t(new_tree_live_info, loe_visit_block): Ditto.\n\t(live_worklist, set_var_live_on_entry): Ditto.\n\t(calculate_live_on_exit, verify_live_on_entry): Ditto.\n\t* tree-ssa-live.h (struct _var_map): New fields.\n\t(init_var_map): Change decl.\n\t(region_contains_p): New.\n\nFrom-SVN: r260747", "tree": {"sha": "24d850051850f9a7fea69c5a4e13e800d0166ddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24d850051850f9a7fea69c5a4e13e800d0166ddf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/comments", "author": null, "committer": null, "parents": [{"sha": "34f7080eb0d738c4f27d7990907172eb907055be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f7080eb0d738c4f27d7990907172eb907055be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34f7080eb0d738c4f27d7990907172eb907055be"}], "stats": {"total": 563, "additions": 330, "deletions": 233}, "files": [{"sha": "06e6591aa2199ace2056658c1b91f2a1cebe093c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34", "patch": "@@ -1,3 +1,40 @@\n+2018-05-25  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-outof-ssa.c (tree-ssa.h, tree-dfa.h): Include header files.\n+\t(create_default_def, for_all_parms): Moved from tree-ssa-coalesce.c.\n+\t(parm_default_def_partition_arg): Ditto.\n+\t(set_parm_default_def_partition): Ditto.\n+\t(get_parm_default_def_partitions): Ditto and make it static.\n+\t(get_undefined_value_partitions): Ditto and make it static.\n+\t(remove_ssa_form): Refactor call to init_var_map here.\n+\t* tree-ssa-coalesce.c (build_ssa_conflict_graph): Support live range\n+\tcomputation for loop region.\n+\t(coalesce_partitions, compute_optimized_partition_bases): Ditto.\n+\t(register_default_def): Delete.\n+\t(for_all_parms, create_default_def): Move to tree-outof-ssa.c.\n+\t(parm_default_def_partition_arg): Ditto.\n+\t(set_parm_default_def_partition): Ditto.\n+\t(get_parm_default_def_partitions): Ditto and make it static.\n+\t(get_undefined_value_partitions): Ditto and make it static.\n+\t(coalesce_with_default, coalesce_with_default): Update comment.\n+\t(create_coalesce_list_for_region): New func factored out from\n+\tcreate_outofssa_var_map.\n+\t(populate_coalesce_list_for_outofssa): New func factored out from\n+\tcreate_outofssa_var_map and coalesce_ssa_name.\n+\t(create_outofssa_var_map): Delete.\n+\t(coalesce_ssa_name): Refactor to support live range computation.\n+\t* tree-ssa-coalesce.h (coalesce_ssa_name): Change decl.\n+\t(get_parm_default_def_partitions): Delete.\n+\t(get_undefined_value_partitions): Ditto.\n+\t* tree-ssa-live.c (init_var_map, delete_var_map): Support live range\n+\tcomputation for loop region.\n+\t(new_tree_live_info, loe_visit_block): Ditto.\n+\t(live_worklist, set_var_live_on_entry): Ditto.\n+\t(calculate_live_on_exit, verify_live_on_entry): Ditto.\n+\t* tree-ssa-live.h (struct _var_map): New fields.\n+\t(init_var_map): Change decl.\n+\t(region_contains_p): New.\n+\n 2018-05-25  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-live.h (live_merge_and_clear): Delete."}, {"sha": "3f880ef7382ff2678797ce5fb277a7b250118303", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34", "patch": "@@ -27,10 +27,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"cfghooks.h\"\n #include \"ssa.h\"\n+#include \"tree-ssa.h\"\n #include \"memmodel.h\"\n #include \"emit-rtl.h\"\n #include \"gimple-pretty-print.h\"\n #include \"diagnostic-core.h\"\n+#include \"tree-dfa.h\"\n #include \"stor-layout.h\"\n #include \"cfgrtl.h\"\n #include \"cfganal.h\"\n@@ -888,6 +890,102 @@ rewrite_trees (var_map map)\n     }\n }\n \n+/* Create a default def for VAR.  */\n+\n+static void\n+create_default_def (tree var, void *arg ATTRIBUTE_UNUSED)\n+{\n+  if (!is_gimple_reg (var))\n+    return;\n+\n+  tree ssa = get_or_create_ssa_default_def (cfun, var);\n+  gcc_assert (ssa);\n+}\n+\n+/* Call CALLBACK for all PARM_DECLs and RESULT_DECLs for which\n+   assign_parms may ask for a default partition.  */\n+\n+static void\n+for_all_parms (void (*callback)(tree var, void *arg), void *arg)\n+{\n+  for (tree var = DECL_ARGUMENTS (current_function_decl); var;\n+       var = DECL_CHAIN (var))\n+    callback (var, arg);\n+  if (!VOID_TYPE_P (TREE_TYPE (DECL_RESULT (current_function_decl))))\n+    callback (DECL_RESULT (current_function_decl), arg);\n+  if (cfun->static_chain_decl)\n+    callback (cfun->static_chain_decl, arg);\n+}\n+\n+/* We need to pass two arguments to set_parm_default_def_partition,\n+   but for_all_parms only supports one.  Use a pair.  */\n+\n+typedef std::pair<var_map, bitmap> parm_default_def_partition_arg;\n+\n+/* Set in ARG's PARTS bitmap the bit corresponding to the partition in\n+   ARG's MAP containing VAR's default def.  */\n+\n+static void\n+set_parm_default_def_partition (tree var, void *arg_)\n+{\n+  parm_default_def_partition_arg *arg = (parm_default_def_partition_arg *)arg_;\n+  var_map map = arg->first;\n+  bitmap parts = arg->second;\n+\n+  if (!is_gimple_reg (var))\n+    return;\n+\n+  tree ssa = ssa_default_def (cfun, var);\n+  gcc_assert (ssa);\n+\n+  int version = var_to_partition (map, ssa);\n+  gcc_assert (version != NO_PARTITION);\n+\n+  bool changed = bitmap_set_bit (parts, version);\n+  gcc_assert (changed);\n+}\n+\n+/* Allocate and return a bitmap that has a bit set for each partition\n+   that contains a default def for a parameter.  */\n+\n+static bitmap\n+get_parm_default_def_partitions (var_map map)\n+{\n+  bitmap parm_default_def_parts = BITMAP_ALLOC (NULL);\n+\n+  parm_default_def_partition_arg\n+    arg = std::make_pair (map, parm_default_def_parts);\n+\n+  for_all_parms (set_parm_default_def_partition, &arg);\n+\n+  return parm_default_def_parts;\n+}\n+\n+/* Allocate and return a bitmap that has a bit set for each partition\n+   that contains an undefined value.  */\n+\n+static bitmap\n+get_undefined_value_partitions (var_map map)\n+{\n+  bitmap undefined_value_parts = BITMAP_ALLOC (NULL);\n+\n+  for (unsigned int i = 1; i < num_ssa_names; i++)\n+    {\n+      tree var = ssa_name (i);\n+      if (var\n+\t  && !virtual_operand_p (var)\n+\t  && !has_zero_uses (var)\n+\t  && ssa_undefined_value_p (var))\n+\t{\n+\t  const int p = var_to_partition (map, var);\n+\t  if (p != NO_PARTITION)\n+\t    bitmap_set_bit (undefined_value_parts, p);\n+\t}\n+    }\n+\n+  return undefined_value_parts;\n+}\n+\n /* Given the out-of-ssa info object SA (with prepared partitions)\n    eliminate all phi nodes in all basic blocks.  Afterwards no\n    basic block will have phi nodes anymore and there are possibly\n@@ -945,7 +1043,9 @@ remove_ssa_form (bool perform_ter, struct ssaexpand *sa)\n   bitmap values = NULL;\n   var_map map;\n \n-  map = coalesce_ssa_name ();\n+  for_all_parms (create_default_def, NULL);\n+  map = init_var_map (num_ssa_names);\n+  coalesce_ssa_name (map);\n \n   /* Return to viewing the variable list as just all reference variables after\n      coalescing has been performed.  */"}, {"sha": "e4f576fbc19900a2c93e7f30d173715dcc0c1a06", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 111, "deletions": 206, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34", "patch": "@@ -879,7 +879,7 @@ build_ssa_conflict_graph (tree_live_info_p liveinfo)\n \n   live = new_live_track (map);\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  for (unsigned i = 0; liveinfo->map->vec_bbs.iterate (i, &bb); ++i)\n     {\n       /* Start with live on exit temporaries.  */\n       live_track_init (live, live_on_exit (liveinfo, bb));\n@@ -944,6 +944,8 @@ build_ssa_conflict_graph (tree_live_info_p liveinfo)\n \t{\n \t  gphi *phi = gsi.phi ();\n \t  tree result = PHI_RESULT (phi);\n+\t  if (virtual_operand_p (result))\n+\t    continue;\n \t  if (live_track_live_p (live, result))\n \t    live_track_process_def (live, result, graph);\n \t}\n@@ -1012,48 +1014,9 @@ fail_abnormal_edge_coalesce (int x, int y)\n   internal_error (\"SSA corruption\");\n }\n \n-/* Call CALLBACK for all PARM_DECLs and RESULT_DECLs for which\n-   assign_parms may ask for a default partition.  */\n-\n-static void\n-for_all_parms (void (*callback)(tree var, void *arg), void *arg)\n-{\n-  for (tree var = DECL_ARGUMENTS (current_function_decl); var;\n-       var = DECL_CHAIN (var))\n-    callback (var, arg);\n-  if (!VOID_TYPE_P (TREE_TYPE (DECL_RESULT (current_function_decl))))\n-    callback (DECL_RESULT (current_function_decl), arg);\n-  if (cfun->static_chain_decl)\n-    callback (cfun->static_chain_decl, arg);\n-}\n-\n-/* Create a default def for VAR.  */\n-\n-static void\n-create_default_def (tree var, void *arg ATTRIBUTE_UNUSED)\n-{\n-  if (!is_gimple_reg (var))\n-    return;\n-\n-  tree ssa = get_or_create_ssa_default_def (cfun, var);\n-  gcc_assert (ssa);\n-}\n-\n-/* Register VAR's default def in MAP.  */\n-\n-static void\n-register_default_def (tree var, void *arg ATTRIBUTE_UNUSED)\n-{\n-  if (!is_gimple_reg (var))\n-    return;\n-\n-  tree ssa = ssa_default_def (cfun, var);\n-  gcc_assert (ssa);\n-}\n-\n /* If VAR is an SSA_NAME associated with a PARM_DECL or a RESULT_DECL,\n    and the DECL's default def is unused (i.e., it was introduced by\n-   create_default_def), mark VAR and the default def for\n+   create_default_def for out-of-ssa), mark VAR and the default def for\n    coalescing.  */\n \n static void\n@@ -1070,32 +1033,25 @@ coalesce_with_default (tree var, coalesce_list *cl, bitmap used_in_copy)\n \n   add_cost_one_coalesce (cl, SSA_NAME_VERSION (ssa), SSA_NAME_VERSION (var));\n   bitmap_set_bit (used_in_copy, SSA_NAME_VERSION (var));\n-  /* Default defs will have their used_in_copy bits set at the end of\n-     create_outofssa_var_map.  */\n+  /* Default defs will have their used_in_copy bits set at the beginning of\n+     populate_coalesce_list_for_outofssa.  */\n }\n \n-/* This function creates a var_map for the current function as well as creating\n-   a coalesce list for use later in the out of ssa process.  */\n \n-static var_map\n-create_outofssa_var_map (coalesce_list *cl, bitmap used_in_copy)\n+/* Given var_map MAP for a region, this function creates and returns a coalesce\n+   list as well as recording related ssa names in USED_IN_COPIES for use later\n+   in the out-of-ssa or live range computation process.  */\n+\n+static coalesce_list *\n+create_coalesce_list_for_region (var_map map, bitmap used_in_copy)\n {\n   gimple_stmt_iterator gsi;\n   basic_block bb;\n-  tree var;\n+  coalesce_list *cl = create_coalesce_list ();\n   gimple *stmt;\n-  tree first;\n-  var_map map;\n   int v1, v2, cost;\n-  unsigned i;\n-\n-  for_all_parms (create_default_def, NULL);\n-\n-  map = init_var_map (num_ssa_names);\n-\n-  for_all_parms (register_default_def, NULL);\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  for (unsigned j = 0; map->vec_bbs.iterate (j, &bb); ++j)\n     {\n       tree arg;\n \n@@ -1110,6 +1066,8 @@ create_outofssa_var_map (coalesce_list *cl, bitmap used_in_copy)\n \t  bool saw_copy = false;\n \n \t  res = gimple_phi_result (phi);\n+\t  if (virtual_operand_p (res))\n+\t    continue;\n \t  ver = SSA_NAME_VERSION (res);\n \n \t  /* Register ssa_names and coalesces between the args and the result\n@@ -1249,8 +1207,44 @@ create_outofssa_var_map (coalesce_list *cl, bitmap used_in_copy)\n \t}\n     }\n \n-  /* Now process result decls and live on entry variables for entry into\n-     the coalesce list.  */\n+  return cl;\n+}\n+\n+\n+/* Hashtable support for storing SSA names hashed by their SSA_NAME_VAR.  */\n+\n+struct ssa_name_var_hash : nofree_ptr_hash <tree_node>\n+{\n+  static inline hashval_t hash (const tree_node *);\n+  static inline int equal (const tree_node *, const tree_node *);\n+};\n+\n+inline hashval_t\n+ssa_name_var_hash::hash (const_tree n)\n+{\n+  return DECL_UID (SSA_NAME_VAR (n));\n+}\n+\n+inline int\n+ssa_name_var_hash::equal (const tree_node *n1, const tree_node *n2)\n+{\n+  return SSA_NAME_VAR (n1) == SSA_NAME_VAR (n2);\n+}\n+\n+\n+/* This function populates coalesce list CL as well as recording related ssa\n+   names in USED_IN_COPIES for use later in the out-of-ssa process.  */\n+\n+static void\n+populate_coalesce_list_for_outofssa (coalesce_list *cl, bitmap used_in_copy)\n+{\n+  tree var;\n+  tree first;\n+  int v1, v2, cost;\n+  unsigned i;\n+\n+  /* Process result decls and live on entry variables for entry into the\n+     coalesce list.  */\n   first = NULL_TREE;\n   FOR_EACH_SSA_NAME (i, var, cfun)\n     {\n@@ -1285,7 +1279,46 @@ create_outofssa_var_map (coalesce_list *cl, bitmap used_in_copy)\n \t}\n     }\n \n-  return map;\n+  /* If this optimization is disabled, we need to coalesce all the\n+     names originating from the same SSA_NAME_VAR so debug info\n+     remains undisturbed.  */\n+  if (!flag_tree_coalesce_vars)\n+    {\n+      tree a;\n+      hash_table<ssa_name_var_hash> ssa_name_hash (10);\n+\n+      FOR_EACH_SSA_NAME (i, a, cfun)\n+\t{\n+\t  if (SSA_NAME_VAR (a)\n+\t      && !DECL_IGNORED_P (SSA_NAME_VAR (a))\n+\t      && (!has_zero_uses (a) || !SSA_NAME_IS_DEFAULT_DEF (a)\n+\t\t  || !VAR_P (SSA_NAME_VAR (a))))\n+\t    {\n+\t      tree *slot = ssa_name_hash.find_slot (a, INSERT);\n+\n+\t      if (!*slot)\n+\t\t*slot = a;\n+\t      else\n+\t\t{\n+\t\t  /* If the variable is a PARM_DECL or a RESULT_DECL, we\n+\t\t     _require_ that all the names originating from it be\n+\t\t     coalesced, because there must be a single partition\n+\t\t     containing all the names so that it can be assigned\n+\t\t     the canonical RTL location of the DECL safely.\n+\t\t     If in_lto_p, a function could have been compiled\n+\t\t     originally with optimizations and only the link\n+\t\t     performed at -O0, so we can't actually require it.  */\n+\t\t  const int cost\n+\t\t    = (TREE_CODE (SSA_NAME_VAR (a)) == VAR_DECL || in_lto_p)\n+\t\t      ? MUST_COALESCE_COST - 1 : MUST_COALESCE_COST;\n+\t\t  add_coalesce (cl, SSA_NAME_VERSION (a),\n+\t\t\t\tSSA_NAME_VERSION (*slot), cost);\n+\t\t  bitmap_set_bit (used_in_copy, SSA_NAME_VERSION (a));\n+\t\t  bitmap_set_bit (used_in_copy, SSA_NAME_VERSION (*slot));\n+\t\t}\n+\t    }\n+\t}\n+    }\n }\n \n \n@@ -1384,13 +1417,15 @@ coalesce_partitions (var_map map, ssa_conflicts *graph, coalesce_list *cl,\n \t\t gsi_next (&gsi))\n \t      {\n \t\tgphi *phi = gsi.phi ();\n+\t\ttree res = PHI_RESULT (phi);\n+\t\tif (virtual_operand_p (res))\n+\t\t  continue;\n \t\ttree arg = PHI_ARG_DEF (phi, e->dest_idx);\n \t\tif (SSA_NAME_IS_DEFAULT_DEF (arg)\n \t\t    && (!SSA_NAME_VAR (arg)\n \t\t\t|| TREE_CODE (SSA_NAME_VAR (arg)) != PARM_DECL))\n \t\t  continue;\n \n-\t\ttree res = PHI_RESULT (phi);\n \t\tint v1 = SSA_NAME_VERSION (res);\n \t\tint v2 = SSA_NAME_VERSION (arg);\n \n@@ -1420,27 +1455,6 @@ coalesce_partitions (var_map map, ssa_conflicts *graph, coalesce_list *cl,\n }\n \n \n-/* Hashtable support for storing SSA names hashed by their SSA_NAME_VAR.  */\n-\n-struct ssa_name_var_hash : nofree_ptr_hash <tree_node>\n-{\n-  static inline hashval_t hash (const tree_node *);\n-  static inline int equal (const tree_node *, const tree_node *);\n-};\n-\n-inline hashval_t\n-ssa_name_var_hash::hash (const_tree n)\n-{\n-  return DECL_UID (SSA_NAME_VAR (n));\n-}\n-\n-inline int\n-ssa_name_var_hash::equal (const tree_node *n1, const tree_node *n2)\n-{\n-  return SSA_NAME_VAR (n1) == SSA_NAME_VAR (n2);\n-}\n-\n-\n /* Output partition map MAP with coalescing plan PART to file F.  */\n \n void\n@@ -1629,8 +1643,9 @@ compute_optimized_partition_bases (var_map map, bitmap used_in_copies,\n   /* And also with abnormal edges.  */\n   basic_block bb;\n   edge e;\n+  unsigned i;\n   edge_iterator ei;\n-  FOR_EACH_BB_FN (bb, cfun)\n+  for (i = 0; map->vec_bbs.iterate (i, &bb); ++i)\n     {\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (e->flags & EDGE_ABNORMAL)\n@@ -1640,14 +1655,15 @@ compute_optimized_partition_bases (var_map map, bitmap used_in_copies,\n \t\t gsi_next (&gsi))\n \t      {\n \t\tgphi *phi = gsi.phi ();\n+\t\ttree res = PHI_RESULT (phi);\n+\t\tif (virtual_operand_p (res))\n+\t\t  continue;\n \t\ttree arg = PHI_ARG_DEF (phi, e->dest_idx);\n \t\tif (SSA_NAME_IS_DEFAULT_DEF (arg)\n \t\t    && (!SSA_NAME_VAR (arg)\n \t\t\t|| TREE_CODE (SSA_NAME_VAR (arg)) != PARM_DECL))\n \t\t  continue;\n \n-\t\ttree res = PHI_RESULT (phi);\n-\n \t\tint p1 = partition_find (tentative, var_to_partition (map, res));\n \t\tint p2 = partition_find (tentative, var_to_partition (map, arg));\n \n@@ -1675,7 +1691,6 @@ compute_optimized_partition_bases (var_map map, bitmap used_in_copies,\n      between all SSA versions that ended up in the same potential\n      coalesce partition.  */\n   bitmap_iterator bi;\n-  unsigned i;\n   EXECUTE_IF_SET_IN_BITMAP (used_in_copies, 0, i, bi)\n     {\n       int pidx = var_to_partition (map, ssa_name (i));\n@@ -1784,62 +1799,22 @@ compute_samebase_partition_bases (var_map map)\n   free (mapstorage);\n }\n \n-/* Reduce the number of copies by coalescing variables in the function.  Return\n-   a partition map with the resulting coalesces.  */\n+/* Given an initial var_map MAP, coalesce variables and return a partition map\n+   with the resulting coalesce.  Note that this function is called in either\n+   live range computation context or out-of-ssa context, indicated by MAP.  */\n \n-extern var_map\n-coalesce_ssa_name (void)\n+extern void\n+coalesce_ssa_name (var_map map)\n {\n   tree_live_info_p liveinfo;\n   ssa_conflicts *graph;\n   coalesce_list *cl;\n   auto_bitmap used_in_copies;\n-  var_map map;\n-  unsigned int i;\n-  tree a;\n \n-  cl = create_coalesce_list ();\n-  map = create_outofssa_var_map (cl, used_in_copies);\n+  cl = create_coalesce_list_for_region (map, used_in_copies);\n+  if (map->outofssa_p)\n+    populate_coalesce_list_for_outofssa (cl, used_in_copies);\n \n-  /* If this optimization is disabled, we need to coalesce all the\n-     names originating from the same SSA_NAME_VAR so debug info\n-     remains undisturbed.  */\n-  if (!flag_tree_coalesce_vars)\n-    {\n-      hash_table<ssa_name_var_hash> ssa_name_hash (10);\n-\n-      FOR_EACH_SSA_NAME (i, a, cfun)\n-\t{\n-\t  if (SSA_NAME_VAR (a)\n-\t      && !DECL_IGNORED_P (SSA_NAME_VAR (a))\n-\t      && (!has_zero_uses (a) || !SSA_NAME_IS_DEFAULT_DEF (a)\n-\t\t  || !VAR_P (SSA_NAME_VAR (a))))\n-\t    {\n-\t      tree *slot = ssa_name_hash.find_slot (a, INSERT);\n-\n-\t      if (!*slot)\n-\t\t*slot = a;\n-\t      else\n-\t\t{\n-\t\t  /* If the variable is a PARM_DECL or a RESULT_DECL, we\n-\t\t     _require_ that all the names originating from it be\n-\t\t     coalesced, because there must be a single partition\n-\t\t     containing all the names so that it can be assigned\n-\t\t     the canonical RTL location of the DECL safely.\n-\t\t     If in_lto_p, a function could have been compiled\n-\t\t     originally with optimizations and only the link\n-\t\t     performed at -O0, so we can't actually require it.  */\n-\t\t  const int cost\n-\t\t    = (TREE_CODE (SSA_NAME_VAR (a)) == VAR_DECL || in_lto_p)\n-\t\t      ? MUST_COALESCE_COST - 1 : MUST_COALESCE_COST;\n-\t\t  add_coalesce (cl, SSA_NAME_VERSION (a),\n-\t\t\t\tSSA_NAME_VERSION (*slot), cost);\n-\t\t  bitmap_set_bit (used_in_copies, SSA_NAME_VERSION (a));\n-\t\t  bitmap_set_bit (used_in_copies, SSA_NAME_VERSION (*slot));\n-\t\t}\n-\t    }\n-\t}\n-    }\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_var_map (dump_file, map);\n \n@@ -1853,7 +1828,7 @@ coalesce_ssa_name (void)\n   if (num_var_partitions (map) < 1)\n     {\n       delete_coalesce_list (cl);\n-      return map;\n+      return;\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1890,75 +1865,5 @@ coalesce_ssa_name (void)\n \n   delete_coalesce_list (cl);\n   ssa_conflicts_delete (graph);\n-\n-  return map;\n }\n \n-/* We need to pass two arguments to set_parm_default_def_partition,\n-   but for_all_parms only supports one.  Use a pair.  */\n-\n-typedef std::pair<var_map, bitmap> parm_default_def_partition_arg;\n-\n-/* Set in ARG's PARTS bitmap the bit corresponding to the partition in\n-   ARG's MAP containing VAR's default def.  */\n-\n-static void\n-set_parm_default_def_partition (tree var, void *arg_)\n-{\n-  parm_default_def_partition_arg *arg = (parm_default_def_partition_arg *)arg_;\n-  var_map map = arg->first;\n-  bitmap parts = arg->second;\n-\n-  if (!is_gimple_reg (var))\n-    return;\n-\n-  tree ssa = ssa_default_def (cfun, var);\n-  gcc_assert (ssa);\n-\n-  int version = var_to_partition (map, ssa);\n-  gcc_assert (version != NO_PARTITION);\n-\n-  bool changed = bitmap_set_bit (parts, version);\n-  gcc_assert (changed);\n-}\n-\n-/* Allocate and return a bitmap that has a bit set for each partition\n-   that contains a default def for a parameter.  */\n-\n-bitmap\n-get_parm_default_def_partitions (var_map map)\n-{\n-  bitmap parm_default_def_parts = BITMAP_ALLOC (NULL);\n-\n-  parm_default_def_partition_arg\n-    arg = std::make_pair (map, parm_default_def_parts);\n-\n-  for_all_parms (set_parm_default_def_partition, &arg);\n-\n-  return parm_default_def_parts;\n-}\n-\n-/* Allocate and return a bitmap that has a bit set for each partition\n-   that contains an undefined value.  */\n-\n-bitmap\n-get_undefined_value_partitions (var_map map)\n-{\n-  bitmap undefined_value_parts = BITMAP_ALLOC (NULL);\n-\n-  for (unsigned int i = 1; i < num_ssa_names; i++)\n-    {\n-      tree var = ssa_name (i);\n-      if (var\n-\t  && !virtual_operand_p (var)\n-\t  && !has_zero_uses (var)\n-\t  && ssa_undefined_value_p (var))\n-\t{\n-\t  const int p = var_to_partition (map, var);\n-\t  if (p != NO_PARTITION)\n-\t    bitmap_set_bit (undefined_value_parts, p);\n-\t}\n-    }\n-\n-  return undefined_value_parts;\n-}"}, {"sha": "f787637164953985f020bb5a148a4dfdabe8dbe8", "filename": "gcc/tree-ssa-coalesce.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2Ftree-ssa-coalesce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2Ftree-ssa-coalesce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.h?ref=e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34", "patch": "@@ -20,9 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_SSA_COALESCE_H\n #define GCC_TREE_SSA_COALESCE_H\n \n-extern var_map coalesce_ssa_name (void);\n+extern void coalesce_ssa_name (var_map);\n extern bool gimple_can_coalesce_p (tree, tree);\n-extern bitmap get_parm_default_def_partitions (var_map);\n-extern bitmap get_undefined_value_partitions (var_map);\n \n #endif /* GCC_TREE_SSA_COALESCE_H */"}, {"sha": "7447f7a6f0ccd4e2d0cc5e0afd6bf89754db9c16", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 54, "deletions": 22, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34", "patch": "@@ -71,10 +71,12 @@ var_map_base_fini (var_map map)\n       map->num_basevars = 0;\n     }\n }\n-/* Create a variable partition map of SIZE, initialize and return it.  */\n+/* Create a variable partition map of SIZE for region, initialize and return\n+   it.  Region is a loop if LOOP is non-NULL, otherwise is the current\n+   function.  */\n \n var_map\n-init_var_map (int size)\n+init_var_map (int size, struct loop *loop)\n {\n   var_map map;\n \n@@ -87,6 +89,27 @@ init_var_map (int size)\n   map->partition_size = size;\n   map->num_basevars = 0;\n   map->partition_to_base_index = NULL;\n+  map->vec_bbs = vNULL;\n+  if (loop)\n+    {\n+      map->bmp_bbs = BITMAP_ALLOC (NULL);\n+      map->outofssa_p = false;\n+      basic_block *bbs = get_loop_body_in_dom_order (loop);\n+      for (unsigned i = 0; i < loop->num_nodes; ++i)\n+\t{\n+\t  bitmap_set_bit (map->bmp_bbs, bbs[i]->index);\n+\t  map->vec_bbs.safe_push (bbs[i]);\n+\t}\n+      free (bbs);\n+    }\n+  else\n+    {\n+      map->bmp_bbs = NULL;\n+      map->outofssa_p = true;\n+      basic_block bb;\n+      FOR_EACH_BB_FN (bb, cfun)\n+\tmap->vec_bbs.safe_push (bb);\n+    }\n   return map;\n }\n \n@@ -100,6 +123,9 @@ delete_var_map (var_map map)\n   partition_delete (map->var_partition);\n   free (map->partition_to_view);\n   free (map->view_to_partition);\n+  if (map->bmp_bbs)\n+    BITMAP_FREE (map->bmp_bbs);\n+  map->vec_bbs.release ();\n   free (map);\n }\n \n@@ -901,13 +927,14 @@ new_tree_live_info (var_map map)\n \n   bitmap_obstack_initialize (&live->livein_obstack);\n   bitmap_obstack_initialize (&live->liveout_obstack);\n-  live->livein = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n-  FOR_EACH_BB_FN (bb, cfun)\n-    bitmap_initialize (&live->livein[bb->index], &live->livein_obstack);\n \n-  live->liveout = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n-  FOR_EACH_BB_FN (bb, cfun)\n-    bitmap_initialize (&live->liveout[bb->index], &live->liveout_obstack);\n+  live->livein = XCNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n+  live->liveout = XCNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n+  for (unsigned i = 0; map->vec_bbs.iterate (i, &bb); ++i)\n+    {\n+      bitmap_initialize (&live->livein[bb->index], &live->livein_obstack);\n+      bitmap_initialize (&live->liveout[bb->index], &live->liveout_obstack);\n+    }\n \n   live->work_stack = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   live->stack_top = live->work_stack;\n@@ -960,7 +987,7 @@ loe_visit_block (tree_live_info_p live, basic_block bb, sbitmap visited)\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       pred_bb = e->src;\n-      if (pred_bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+      if (!region_contains_p (live->map, pred_bb))\n \tcontinue;\n       /* Variables live-on-entry from BB that aren't defined in the\n \t predecessor block.  This should be the live on entry vars to pred.\n@@ -993,9 +1020,10 @@ live_worklist (tree_live_info_p live)\n \n   bitmap_clear (visited);\n \n-  /* Visit all the blocks in reverse order and propagate live on entry values\n+  /* Visit region's blocks in reverse order and propagate live on entry values\n      into the predecessors blocks.  */\n-  FOR_EACH_BB_REVERSE_FN (bb, cfun)\n+  for (unsigned i = live->map->vec_bbs.length () - 1;\n+       live->map->vec_bbs.iterate (i, &bb); --i)\n     loe_visit_block (live, bb, visited);\n \n   /* Process any blocks which require further iteration.  */\n@@ -1030,7 +1058,7 @@ set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n     {\n       def_bb = gimple_bb (stmt);\n       /* Mark defs in liveout bitmap temporarily.  */\n-      if (def_bb)\n+      if (def_bb && region_contains_p (live->map, def_bb))\n \tbitmap_set_bit (&live->liveout[def_bb->index], p);\n     }\n   else\n@@ -1054,19 +1082,16 @@ set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n \t     defined in that block, or whether its live on entry.  */\n \t  int index = PHI_ARG_INDEX_FROM_USE (use);\n \t  edge e = gimple_phi_arg_edge (as_a <gphi *> (use_stmt), index);\n-\t  if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-\t    {\n-\t      if (e->src != def_bb)\n-\t\tadd_block = e->src;\n-\t    }\n+\t  if (e->src != def_bb && region_contains_p (live->map, e->src))\n+\t    add_block = e->src;\n \t}\n       else if (is_gimple_debug (use_stmt))\n \tcontinue;\n       else\n         {\n \t  /* If its not defined in this block, its live on entry.  */\n \t  basic_block use_bb = gimple_bb (use_stmt);\n-\t  if (use_bb != def_bb)\n+\t  if (use_bb != def_bb && region_contains_p (live->map, use_bb))\n \t    add_block = use_bb;\n \t}\n \n@@ -1095,7 +1120,7 @@ calculate_live_on_exit (tree_live_info_p liveinfo)\n   edge_iterator ei;\n \n   /* live on entry calculations used liveout vectors for defs, clear them.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n+  for (unsigned i = 0; liveinfo->map->vec_bbs.iterate (i, &bb); ++i)\n     bitmap_clear (&liveinfo->liveout[bb->index]);\n \n   /* Set all the live-on-exit bits for uses in PHIs.  */\n@@ -1108,6 +1133,8 @@ calculate_live_on_exit (tree_live_info_p liveinfo)\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gphi *phi = gsi.phi ();\n+\t  if (virtual_operand_p (gimple_phi_result (phi)))\n+\t    continue;\n \t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t    {\n \t      tree t = PHI_ARG_DEF (phi, i);\n@@ -1120,14 +1147,17 @@ calculate_live_on_exit (tree_live_info_p liveinfo)\n \t      if (p == NO_PARTITION)\n \t\tcontinue;\n \t      e = gimple_phi_arg_edge (phi, i);\n-\t      if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t      if (region_contains_p (liveinfo->map, e->src))\n \t\tbitmap_set_bit (&liveinfo->liveout[e->src->index], p);\n \t    }\n \t}\n \n+      if (!region_contains_p (liveinfo->map, bb))\n+\tcontinue;\n+\n       /* Add each successors live on entry to this bock live on exit.  */\n       FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\tif (region_contains_p (liveinfo->map, e->dest))\n \t  bitmap_ior_into (&liveinfo->liveout[bb->index],\n \t\t\t   live_on_entry (liveinfo, e->dest));\n     }\n@@ -1314,7 +1344,7 @@ verify_live_on_entry (tree_live_info_p live)\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       int entry_block = e->dest->index;\n-      if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+      if (!region_contains_p (live->map, e->dest))\n         continue;\n       for (i = 0; i < (unsigned)num_var_partitions (map); i++)\n \t{\n@@ -1380,6 +1410,8 @@ verify_live_on_entry (tree_live_info_p live)\n \t\t     gsi_next (&gsi))\n \t\t  {\n \t\t    gphi *phi = gsi.phi ();\n+\t\t    if (virtual_operand_p (gimple_phi_result (phi)))\n+\t\t      continue;\n \t\t    for (z = 0; z < gimple_phi_num_args (phi); z++)\n \t\t      if (var == gimple_phi_arg_def (phi, z))\n \t\t\t{"}, {"sha": "9aa541804bb44855d686226906f299165301de42", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=e3bfa3775a7714fc5c5a8fee06e2c0f42c1fcd34", "patch": "@@ -62,13 +62,25 @@ typedef struct _var_map\n \n   /* Map of partitions numbers to base variable table indexes.  */\n   int *partition_to_base_index;\n+\n+  /* Bitmap of basic block.  It describes the region within which the analysis\n+     is done.  Using pointer avoids allocating memory in out-of-ssa case.  */\n+  bitmap bmp_bbs;\n+\n+  /* Vector of basic block in the region.  */\n+  vec<basic_block> vec_bbs;\n+\n+  /* True if this map is for out-of-ssa, otherwise for live range\n+     computation.  When for out-of-ssa, it also means the var map is computed\n+     for whole current function.  */\n+  bool outofssa_p;\n } *var_map;\n \n \n /* Value used to represent no partition number.  */\n #define NO_PARTITION\t\t-1\n \n-extern var_map init_var_map (int);\n+extern var_map init_var_map (int, struct loop* = NULL);\n extern void delete_var_map (var_map);\n extern int var_union (var_map, tree, tree);\n extern void partition_view_normal (var_map);\n@@ -82,6 +94,19 @@ extern void debug (_var_map &ref);\n extern void debug (_var_map *ptr);\n \n \n+/* Return TRUE if region of the MAP contains basic block BB.  */\n+\n+inline bool\n+region_contains_p (var_map map, basic_block bb)\n+{\n+  /* It's possible that the function is called with ENTRY_BLOCK/EXIT_BLOCK.  */\n+  if (map->outofssa_p)\n+    return (bb->index != ENTRY_BLOCK && bb->index != EXIT_BLOCK);\n+\n+  return bitmap_bit_p (map->bmp_bbs, bb->index);\n+}\n+\n+\n /* Return number of partitions in MAP.  */\n \n static inline unsigned"}]}