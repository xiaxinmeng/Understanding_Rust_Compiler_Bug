{"sha": "c2699190282c19bd5703de0a606b842774715074", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI2OTkxOTAyODJjMTliZDU3MDNkZTBhNjA2Yjg0Mjc3NDcxNTA3NA==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2008-06-04T21:49:45Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2008-06-04T21:49:45Z"}, "message": "tree-call-cdce.c: New file.\n\n2008-06-04  Xinliang David Li  <davidxl@google.com>\n\n\t* tree-call-cdce.c: New file. \n\t(cond_dead_built_in_calls): New static variable.\n\t(input_domain): New struct.\n\t(check_pow): New function.\n\t(check_builtin_call): Ditto.\n\t(check_target_format): Ditto.\n\t(is_call_dce_candidate): Ditto.\n\t(gen_one_condition): Ditto.\n\t(gen_conditions_for_domain): Ditto.\n\t(get_domain): Ditto.\n\t(gen_conditions_for_pow_cst_base): Ditto.\n\t(gen_conditions_for_pow_int_base): Ditto.\n\t(gen_conditions_for_pow): Ditto.\n\t(get_no_error_domain): Ditto.\n\t(gen_shrink_wrap_conditions): Ditto.\n\t(shrink_wrap_one_built_in_call): Ditto.\n\t(shink_wrap_conditional_dead_built_in_calls): Ditto.\n\t(tree_call_cdce): Ditto.\n\t(gate_call_cdce): Ditto.\n\t(pass_call_cdce): New gimple pass.\n\t* passes.c: (init_optimization_passes): New pass.\n\t* tree-pass.h: New pass declaration.\n\t* opts.c (decode_options): New flag setting.\n\t* common.opt: Add -ftree-builtin-call-dce flag.\n\t* Makefile.in: Add new source file.\n\t* tempvar.def: New tv_id.\n\t* doc/invoke.texi (-ftree-builtin-call-dce): New flag.\n\n2008-06-04  Xinliang David Li  <davidxl@google.com>\n\t* gcc.dg/cdce1.c: New test.\n\t* gcc.dg/cdce2.c: Ditto.\n\t* g++.dg/cdce3.C: Ditto.\n\nFrom-SVN: r136374", "tree": {"sha": "e298fb5d3a5ce2f2f94d42716feeeb493ca9e188", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e298fb5d3a5ce2f2f94d42716feeeb493ca9e188"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2699190282c19bd5703de0a606b842774715074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2699190282c19bd5703de0a606b842774715074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2699190282c19bd5703de0a606b842774715074", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2699190282c19bd5703de0a606b842774715074/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7db5da56edab33b9dc4ab1991ad06d023c9516b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7db5da56edab33b9dc4ab1991ad06d023c9516b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7db5da56edab33b9dc4ab1991ad06d023c9516b1"}], "stats": {"total": 1348, "additions": 1346, "deletions": 2}, "files": [{"sha": "96de8a0569077887f14e8620387251ef6ddcb2c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -1,3 +1,33 @@\n+2008-06-04  Xinliang David Li  <davidxl@google.com>\n+\n+\t* tree-call-cdce.c: New file. \n+\t(cond_dead_built_in_calls): New static variable.\n+\t(input_domain): New struct.\n+\t(check_pow): New function.\n+\t(check_builtin_call): Ditto.\n+\t(check_target_format): Ditto.\n+\t(is_call_dce_candidate): Ditto.\n+\t(gen_one_condition): Ditto.\n+\t(gen_conditions_for_domain): Ditto.\n+\t(get_domain): Ditto.\n+\t(gen_conditions_for_pow_cst_base): Ditto.\n+\t(gen_conditions_for_pow_int_base): Ditto.\n+\t(gen_conditions_for_pow): Ditto.\n+\t(get_no_error_domain): Ditto.\n+\t(gen_shrink_wrap_conditions): Ditto.\n+\t(shrink_wrap_one_built_in_call): Ditto.\n+\t(shink_wrap_conditional_dead_built_in_calls): Ditto.\n+\t(tree_call_cdce): Ditto.\n+\t(gate_call_cdce): Ditto.\n+\t(pass_call_cdce): New gimple pass.\n+\t* passes.c: (init_optimization_passes): New pass.\n+\t* tree-pass.h: New pass declaration.\n+\t* opts.c (decode_options): New flag setting.\n+\t* common.opt: Add -ftree-builtin-call-dce flag.\n+\t* Makefile.in: Add new source file.\n+\t* tempvar.def: New tv_id.\n+\t* doc/invoke.texi (-ftree-builtin-call-dce): New flag.\n+\n 2008-06-04  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-flow-inline.h (is_global_var): Do not check TREE_STATIC"}, {"sha": "f66b7405db262cff9cc2f28e95ff592336adc2fc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -1143,6 +1143,7 @@ OBJS-common = \\\n \ttoplev.o \\\n \ttracer.o \\\n \ttree-affine.o \\\n+\ttree-call-cdce.o \\\n \ttree-cfg.o \\\n \ttree-cfgcleanup.o \\\n \ttree-chrec.o \\\n@@ -2603,6 +2604,10 @@ tree-ssa-dce.o : tree-ssa-dce.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n     coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(BASIC_BLOCK_H) \\\n     $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(TREE_GIMPLE_H) $(CFGLOOP_H) \\\n     $(SCEV_H)\n+tree-call-cdce.o : tree-call-cdce.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n+    $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \\\n+    coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(BASIC_BLOCK_H) \\\n+    $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(TREE_GIMPLE_H)\n tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\"}, {"sha": "94f2c56a362a879d39ff71af5486a35a2eb2cfce", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -1255,6 +1255,10 @@ fweb\n Common Report Var(flag_web) Init(2) Optimization\n Construct webs and split unrelated uses of single variable\n \n+ftree-builtin-call-dce\n+Common Report Var(flag_tree_builtin_call_dce) Init(0) Optimization\n+Enable conditional dead code elimination for builtin calls\n+\n fwhole-program\n Common Report Var(flag_whole_program) Init(0) Optimization\n Perform whole program optimizations"}, {"sha": "0b5ad590a785b1781b791943ca0e998e444b8573", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -352,8 +352,9 @@ Objective-C and Objective-C++ Dialects}.\n -fschedule-insns -fschedule-insns2 -fsection-anchors -fsee @gol\n -fsignaling-nans -fsingle-precision-constant -fsplit-ivs-in-unroller @gol\n -fsplit-wide-types -fstack-protector -fstack-protector-all @gol\n--fstrict-aliasing -fstrict-overflow -fthread-jumps -ftracer -ftree-ccp @gol\n--ftree-ch -ftree-copy-prop -ftree-copyrename -ftree-dce @gol\n+-fstrict-aliasing -fstrict-overflow -fthread-jumps -ftracer @gol\n+-ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-copy-prop @gol\n+-ftree-copyrename -ftree-dce @gol\n -ftree-dominator-opts -ftree-dse -ftree-fre -ftree-loop-im @gol\n -ftree-loop-distribution @gol\n -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol\n@@ -5154,6 +5155,7 @@ compilation time.\n -fipa-reference @gol\n -fmerge-constants\n -fsplit-wide-types @gol\n+-ftree-builtin-call-dce @gol\n -ftree-ccp @gol\n -ftree-ch @gol\n -ftree-copyrename @gol\n@@ -5874,6 +5876,13 @@ enabled by default at @option{-O2} and higher.\n Perform dead code elimination (DCE) on trees.  This flag is enabled by\n default at @option{-O} and higher.\n \n+@item -ftree-builtin-call-dce\n+@opindex ftree-builtin-call-dce\n+Perform conditional dead code elimination (DCE) for calls to builtin functions \n+that may set @code{errno} but are otherwise side-effect free.  This flag is \n+enabled by default at @option{-O2} and higher if @option{-Os} is not also \n+specified.\n+\n @item -ftree-dominator-opts\n @opindex ftree-dominator-opts\n Perform a variety of simple scalar cleanups (constant/copy"}, {"sha": "d86c2b34be83d40b6a026ba2ba0b050dd4b770da", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -889,6 +889,8 @@ decode_options (unsigned int argc, const char **argv)\n \n       if (!optimize_size)\n \t{\n+          /* Conditional DCE generates bigger code.  */\n+          flag_tree_builtin_call_dce = 1;\n           /* PRE tends to generate bigger code.  */\n           flag_tree_pre = 1;\n \t}"}, {"sha": "4f19f7af1e1a43dc5abf31da1e176527ba986fab", "filename": "gcc/passes.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -561,6 +561,14 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_copy_prop);\n \t  NEXT_PASS (pass_merge_phi);\n \t  NEXT_PASS (pass_dce);\n+          /* Ideally the function call conditional \n+             dead code elimination phase can be delayed\n+             till later where potentially more opportunities\n+             can be found.  Due to lack of good ways to\n+             update VDEFs associated with the shrink-wrapped\n+             calls, it is better to do the transformation\n+             here where memory SSA is not built yet.  */\n+\t  NEXT_PASS (pass_call_cdce);\n \t  NEXT_PASS (pass_update_address_taken);\n \t  NEXT_PASS (pass_simple_dse);\n \t  NEXT_PASS (pass_tail_recursion);"}, {"sha": "5ada62bc7c44eae6508e9ad8b360b455e43e2133", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -1,3 +1,8 @@\n+2008-06-04  Xinliang David Li  <davidxl@google.com>\n+\t* gcc.dg/cdce1.c: New test.\n+\t* gcc.dg/cdce2.c: Ditto.\n+\t* g++.dg/cdce3.C: Ditto.\n+\n 2008-06-04  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/36322"}, {"sha": "e1e8509f2ac7ab453cce092bf7782e8007a337ea", "filename": "gcc/testsuite/g++.dg/cdce3.C", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcdce3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcdce3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcdce3.C?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -0,0 +1,200 @@\n+/* { dg-do  run { target { ! \"*-*-darwin\" } } } */\n+/* { dg-options \"-O2 -fmath-errno -fdump-tree-cdce-details  -lm\" } */\n+/* { dg-final { scan-tree-dump  \"cdce3.C:68: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:69: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:70: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:71: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:72: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:73: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:74: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:75: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:76: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:77: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:78: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:79: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:80: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:81: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:82: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { scan-tree-dump  \"cdce3.C:83: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { cleanup-tree-dump \"cdce\" } } */\n+#include <stdlib.h>\n+#include <math.h>\n+#ifdef DEBUG\n+#include <stdio.h>\n+#endif\n+#include <errno.h>\n+typedef long double ldouble; \n+typedef void (*FP) (int xp);\n+#define NI __attribute__((noinline))\n+ldouble result;\n+\n+#define DEF_MATH_FUNC(prefix, name) NI void prefix##name##f (int x) \\\n+{ \\\n+  float yy = name##f ((float) x); \\\n+  STORE_RESULT; \\\n+} \\\n+NI void prefix##name (int x) \\\n+{ \\\n+  double yy = name ((double)x); \\\n+  STORE_RESULT; \\\n+} \\\n+NI void prefix##name##l (int x) \\\n+{ \\\n+  ldouble yy = name##l ((ldouble)x); \\\n+  STORE_RESULT; \\\n+} \n+\n+#undef STORE_RESULT\n+#define STORE_RESULT result = yy\n+DEF_MATH_FUNC (m,pow10)\n+DEF_MATH_FUNC (m,exp10)\n+DEF_MATH_FUNC (m,exp2)\n+DEF_MATH_FUNC (m,exp)\n+DEF_MATH_FUNC (m,expm1)\n+DEF_MATH_FUNC (m,cosh)\n+DEF_MATH_FUNC (m,sinh)\n+DEF_MATH_FUNC (m,acos)\n+DEF_MATH_FUNC (m,asin)\n+DEF_MATH_FUNC (m,acosh)\n+DEF_MATH_FUNC (m,atanh)\n+DEF_MATH_FUNC (m,log)\n+DEF_MATH_FUNC (m,log2)\n+DEF_MATH_FUNC (m,log10)\n+DEF_MATH_FUNC (m,log1p)\n+DEF_MATH_FUNC (m,sqrt)\n+\n+#undef STORE_RESULT\n+#define STORE_RESULT\n+DEF_MATH_FUNC (o,pow10)\n+DEF_MATH_FUNC (o,exp10)\n+DEF_MATH_FUNC (o,exp2)\n+DEF_MATH_FUNC (o,exp)\n+DEF_MATH_FUNC (o,expm1)\n+DEF_MATH_FUNC (o,cosh)\n+DEF_MATH_FUNC (o,sinh)\n+DEF_MATH_FUNC (o,acos)\n+DEF_MATH_FUNC (o,asin)\n+DEF_MATH_FUNC (o,acosh)\n+DEF_MATH_FUNC (o,atanh)\n+DEF_MATH_FUNC (o,log)\n+DEF_MATH_FUNC (o,log2)\n+DEF_MATH_FUNC (o,log10)\n+DEF_MATH_FUNC (o,log1p)\n+DEF_MATH_FUNC (o,sqrt)\n+\n+#define INIT_MATH_FUNC(prefix, name, lb, ub) { prefix##name##f, #name \"f\", 0, 0, lb, ub }, \\\n+{ prefix##name, #name, 0, 0, lb, ub }, \\\n+{ prefix##name##l, #name \"l\" , 0, 0, lb, ub }, \n+\n+struct MathFuncInfo\n+{\n+  FP math_func;\n+  const char*  name;\n+  int lb;\n+  int ub;\n+  bool has_lb;\n+  bool has_ub;\n+} math_func_arr[] = { \n+  INIT_MATH_FUNC (m,pow10, false, true)\n+  INIT_MATH_FUNC (m,exp10, false, true)\n+  INIT_MATH_FUNC (m,exp2, false, true)\n+  INIT_MATH_FUNC (m,expm1, false, true)\n+  INIT_MATH_FUNC (m,exp, false, true)\n+  INIT_MATH_FUNC (m,cosh, true, true)\n+  INIT_MATH_FUNC (m,sinh, true, true)\n+  INIT_MATH_FUNC (m,acos, true, true)\n+  INIT_MATH_FUNC (m,asin, true, true)\n+  INIT_MATH_FUNC (m,acosh, true, false)\n+  INIT_MATH_FUNC (m,atanh, true, true)\n+  INIT_MATH_FUNC (m,log10, true, false)\n+  INIT_MATH_FUNC (m,log, true, false)\n+  INIT_MATH_FUNC (m,log2, true, false)\n+  INIT_MATH_FUNC (m,log1p, true, false)\n+  INIT_MATH_FUNC (m,sqrt, true, false)\n+  { 0, 0,  0, 0, 0, 0} };\n+\n+MathFuncInfo opt_math_func_arr[] = \n+{ INIT_MATH_FUNC (o,pow10, false, true)\n+  INIT_MATH_FUNC (o,exp10, false, true)\n+  INIT_MATH_FUNC (o,exp2, false, true)\n+  INIT_MATH_FUNC (o,expm1, false, true)\n+  INIT_MATH_FUNC (o,exp, false, true)\n+  INIT_MATH_FUNC (o,cosh, true, true)\n+  INIT_MATH_FUNC (o,sinh, true, true)\n+  INIT_MATH_FUNC (o,acos, true, true)\n+  INIT_MATH_FUNC (o,asin, true, true)\n+  INIT_MATH_FUNC (o,acosh, true, false)\n+  INIT_MATH_FUNC (o,atanh, true, true)\n+  INIT_MATH_FUNC (o,log10, true, false)\n+  INIT_MATH_FUNC (o,log, true, false)\n+  INIT_MATH_FUNC (o,log2, true, false)\n+  INIT_MATH_FUNC (o,log1p, true, false)\n+  INIT_MATH_FUNC (o,sqrt, true, false)\n+  { 0, 0,  0, 0, 0, 0} };\n+\n+int test (MathFuncInfo* math_func_infos)\n+{\n+  int i = 0;\n+  int te = 0;\n+\n+  for (i = 0; math_func_infos[i].math_func; i++)\n+    {\n+      MathFuncInfo& info = math_func_infos[i];\n+      int j;\n+      if (info.has_lb)\n+        {\n+          for (j = 0; j > -500000; j--)\n+            {\n+        \n+              errno = 0;\n+              info.math_func (j);\n+              if (errno != 0)\n+                {\n+\t\t  te++;\n+                  info.lb = j ;\n+                  break;\n+                }\n+            }\n+        }\n+      if (info.has_ub)\n+        {\n+          for (j = 0; j < 500000; j++)\n+            {\n+              errno = 0;\n+              info.math_func (j);\n+              if (errno != 0)\n+              {\n+\t        te++;\n+                info.ub = j ;\n+                break;\n+              }\n+            }\n+        }\n+    }\n+  return te;\n+}\n+\n+int main()\n+{\n+   int te1, te2;\n+\n+   te1 = test (&math_func_arr[0]);\n+   te2 = test (&opt_math_func_arr[0]);\n+\n+   // Now examine the result \n+   int i = 0;\n+   int errcnt = 0;\n+   for (i = 0; math_func_arr[i].math_func; i++)\n+   {\n+      MathFuncInfo& info = math_func_arr[i];\n+      MathFuncInfo& opt_info = opt_math_func_arr[i];\n+#ifdef DEBUG\n+      fprintf (stderr,\" %s: lb = %d, ub = %d: lb_opt = %d, ub_opt = %d\\n\",\n+\tinfo.name, info.lb, info.ub, opt_info.lb, opt_info.ub);\n+#endif\n+      if (info.lb != opt_info.lb) errcnt ++;\n+      if (info.ub != opt_info.ub) errcnt ++;\n+   }\n+   if (errcnt) abort();\n+   return 0;\n+}"}, {"sha": "26d38ae40f5ac47f32ade9a563dd8a5e85ce0072", "filename": "gcc/testsuite/gcc.dg/cdce1.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce1.c?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do  run  { target { !  \"*-*-darwin\"  } } } */\n+/* { dg-options \"-O2 -fmath-errno -fdump-tree-cdce-details  -lm\" } */\n+/* { dg-final { scan-tree-dump  \"cdce1.c:16: note: function call is shrink-wrapped into error conditions\\.\"  \"cdce\" } } */\n+/* { dg-final { cleanup-tree-dump \"cdce\" } } */\n+\n+ \n+#include <stdlib.h>\n+#include <math.h>\n+#include <errno.h>\n+int total_err_count = 0;\n+double foo_opt (int x, double y) __attribute__((noinline));\n+double foo_opt (int x, double y)\n+{\n+  double yy = 0;\n+  errno = 0;\n+  yy = pow (x, y * y);\n+  return 0;\n+}\n+\n+double foo (int x, double y) __attribute__((noinline));\n+double foo (int x, double y)\n+{\n+  double yy = 0;\n+  errno = 0;\n+  yy = pow (x, y * y);\n+  return yy;\n+}\n+\n+int test (double (*fp)(int x, double y))\n+{\n+  int i,x;\n+  \n+  x = 127; \n+  for (i = 30; i < 300; i++)\n+    {  \n+      fp (x, i);\n+      if (errno)\n+        total_err_count ++;\n+    }\n+  \n+  x = -300; \n+  for (i = 100; i < 300; i++)\n+    {  \n+      fp (x, i);\n+      if (errno)\n+        total_err_count ++;\n+    }\n+\n+   x = 65577;\n+   for (i = 60; i < 200; i++)\n+     {  \n+       fp (x, i);\n+       if (errno)\n+         total_err_count ++;\n+     }\n+\n+   x = 65577 * 127;\n+   for (i = 1; i < 100; i++)\n+     {  \n+       fp (x, i);\n+       if (errno)\n+         total_err_count ++;\n+     }\n+\n+   return total_err_count;\n+}\n+\n+int main ()\n+{\n+  int en1, en2;\n+  total_err_count = 0;\n+  en1 = test (foo_opt);\n+  total_err_count = 0;\n+  en2 = test (foo);\n+  \n+  if (en1 != en2)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "ba9e4962050fa71f455be608e789e794dc3b3bc2", "filename": "gcc/testsuite/gcc.dg/cdce2.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcdce2.c?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do  run { target { ! \"*-*-darwin\" } } } */\n+/* { dg-options \"-O2 -fmath-errno -fdump-tree-cdce-details  -lm\" } */\n+/* { dg-final { scan-tree-dump  \"cdce2.c:16: note: function call is shrink-wrapped into error conditions\\.\" \"cdce\" } }*/\n+/* { dg-final { cleanup-tree-dump \"cdce\" } } */\n+ \n+\n+#include <stdlib.h>\n+#include <math.h>\n+#include <errno.h>\n+int total_err_count = 0;\n+double foo_opt (double y) __attribute__((noinline));\n+double foo_opt (double y)\n+{\n+  double yy = 0;\n+  errno = 0;\n+  yy = log (y);\n+  return 0;\n+}\n+\n+double foo (double y) __attribute__((noinline));\n+double foo (double y)\n+{\n+  double yy = 0;\n+  errno = 0;\n+  yy = log (y);\n+  return yy;\n+}\n+\n+int test (double (*fp) (double y))\n+{\n+  int i,x;\n+  for (i = -100; i < 100; i++)\n+    {  \n+      fp (i);\n+      if (errno)\n+        total_err_count ++;\n+    }\n+\n+  return total_err_count;\n+}\n+\n+int main ()\n+{\n+  int en1, en2;\n+  double yy;\n+  total_err_count = 0;\n+  en1 = test (foo_opt);\n+  total_err_count = 0;\n+  en2 = test (foo);\n+\n+  if (en1 != en2)\n+    abort();\n+\n+  return 0;\n+}"}, {"sha": "0429eb41275adfff69cd1dd9ddf25cebd73d9b41", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -113,6 +113,7 @@ DEFTIMEVAR (TV_TREE_FORWPROP\t     , \"tree forward propagate\")\n DEFTIMEVAR (TV_TREE_PHIPROP\t     , \"tree phiprop\")\n DEFTIMEVAR (TV_TREE_DCE\t\t     , \"tree conservative DCE\")\n DEFTIMEVAR (TV_TREE_CD_DCE\t     , \"tree aggressive DCE\")\n+DEFTIMEVAR (TV_TREE_CALL_CDCE\t     , \"tree buildin call DCE\")\n DEFTIMEVAR (TV_TREE_DSE\t\t     , \"tree DSE\")\n DEFTIMEVAR (TV_TREE_MERGE_PHI\t     , \"PHI merge\")\n DEFTIMEVAR (TV_TREE_LOOP\t     , \"tree loop optimization\")"}, {"sha": "4be0cf9bd890c43573775a5af29741c03650ad41", "filename": "gcc/tree-call-cdce.c", "status": "added", "additions": 944, "deletions": 0, "changes": 944, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -0,0 +1,944 @@\n+/* Conditional Dead Call Elimination pass for the GNU compiler.\n+   Copyright (C) 2008\n+   Free Software Foundation, Inc.\n+   Contributed by Xinliang David Li <davidxl@google.com>\n+\n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+\n+/* These RTL headers are needed for basic-block.h.  */\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n+#include \"obstack.h\"\n+#include \"basic-block.h\"\n+\n+#include \"tree.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-gimple.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-pass.h\"\n+#include \"timevar.h\"\n+#include \"flags.h\"\n+\f\n+\n+/* Conditional dead call elimination\n+\n+   Some builtin functions can set errno on error conditions, but they\n+   are otherwise pure.  If the result of a call to such a function is\n+   not used, the compiler can still not eliminate the call without\n+   powerful interprocedural analysis to prove that the errno is not\n+   checked.  However, if the conditions under which the error occurs\n+   are known, the compiler can conditionally dead code eliminate the \n+   calls by shrink-wrapping the semi-dead calls into the error condition:\n+\n+        built_in_call (args)\n+          ==>\n+        if (error_cond (args))\n+             built_in_call (args)\n+\n+    An actual simple example is :\n+         log (x);   // Mostly dead call\n+     ==>\n+         if (x < 0)\n+             log (x);\n+     With this change, call to log (x) is effectively eliminated, as\n+     in majority of the cases, log won't be called with x out of\n+     range.  The branch is totally predictable, so the branch cost\n+     is low.  \n+\n+   Note that library functions are not supposed to clear errno to zero without\n+   error.  See IEEE Std 1003.1, section 2.3 Error Numbers, and section 7.5:3 of\n+   ISO/IEC 9899 (C99).\n+\n+   The condition wrapping the builtin call is conservatively set to avoid too\n+   aggressive (wrong) shrink wrapping.  The optimization is called conditional\n+   dead call elimination because the call is eliminated under the condition\n+   that the input arguments would not lead to domain or range error (for\n+   instance when x <= 0 for a log (x) call), however the chances that the error\n+   condition is hit is very low (those builtin calls which are conditionally\n+   dead are usually part of the C++ abstraction penalty exposed after\n+   inlining).  */\n+\n+\n+/* A structure for representing input domain of \n+   a function argument in integer.  If the lower\n+   bound is -inf, has_lb is set to false.  If the \n+   upper bound is +inf, has_ub is false. \n+   is_lb_inclusive and is_ub_inclusive are flags \n+   to indicate if lb and ub value are inclusive \n+   respectively.  */\n+\n+typedef struct input_domain\n+{\n+  int lb;\n+  int ub;\n+  bool has_lb;\n+  bool has_ub;\n+  bool is_lb_inclusive;\n+  bool is_ub_inclusive;\n+} inp_domain;\n+\n+static VEC (tree, heap) *cond_dead_built_in_calls;\n+\n+/* A helper function to construct and return an input\n+   domain object.  LB is the lower bound, HAS_LB is \n+   a boolean flag indicating if the lower bound exists,\n+   and LB_INCLUSIVE is a boolean flag indicating if the\n+   lower bound is inclusive or not.  UB, HAS_UB, and\n+   UB_INCLUSIVE have the same meaning, but for upper \n+   bound of the domain.  */\n+\n+static inp_domain\n+get_domain (int lb, bool has_lb, bool lb_inclusive,\n+            int ub, bool has_ub, bool ub_inclusive)\n+{\n+  inp_domain domain;\n+  domain.lb = lb;\n+  domain.has_lb = has_lb;\n+  domain.is_lb_inclusive = lb_inclusive;\n+  domain.ub = ub;\n+  domain.has_ub = has_ub;\n+  domain.is_ub_inclusive = ub_inclusive;\n+  return domain;\n+}\n+\n+/* A helper function to check the target format for the \n+   argument type. In this implementation, only IEEE formats\n+   are supported.  ARG is the call argument to be checked.  \n+   Returns true if the format is supported.  To support other\n+   target formats,  function get_no_error_domain needs to be\n+   enhanced to have range bounds properly computed. Since \n+   the check is cheap (very small number of candidates \n+   to be checked), the result is not cached for each float type.  */\n+\n+static bool\n+check_target_format (tree arg)\n+{\n+  tree type;\n+  enum machine_mode mode;\n+  const struct real_format *rfmt;\n+  \n+  type = TREE_TYPE (arg);\n+  mode = TYPE_MODE (type);\n+  rfmt = REAL_MODE_FORMAT (mode);\n+  if ((mode == SFmode && rfmt == &ieee_single_format)\n+      || (mode == DFmode && rfmt == &ieee_double_format)\n+      /* For long double, we can not really check XFmode\n+         which is only defined on intel platforms.  \n+         Candidate pre-selection using builtin function \n+         code guarantees that we are checking formats \n+         for long double modes: double, quad, and extended.  */\n+      || (mode != SFmode && mode != DFmode \n+          && (rfmt == &ieee_quad_format\n+              || rfmt == &ieee_extended_intel_96_format \n+              || rfmt == &ieee_extended_intel_128_format \n+              || rfmt == &ieee_extended_intel_96_round_53_format)))\n+    return true;\n+\n+  return false;\n+}\n+\n+\f\n+/* A helper function to help select calls to pow that are suitable for\n+   conditional DCE transformation.  It looks for pow calls that can be\n+   guided with simple conditions.  Such calls either have constant base\n+   values or base values converted from integers.  Returns true if \n+   the pow call POW_CALL is a candidate.  */\n+\n+/* The maximum integer bit size for base argument of a pow call\n+   that is suitable for shrink-wrapping transformation.  */\n+#define MAX_BASE_INT_BIT_SIZE 32\n+\n+static bool\n+check_pow (tree pow_call)\n+{\n+  tree base, expn;\n+  enum tree_code bc, ec;\n+\n+  if (call_expr_nargs (pow_call) != 2)\n+    return false;\n+\n+  base = CALL_EXPR_ARG (pow_call, 0);\n+  expn = CALL_EXPR_ARG (pow_call, 1);\n+\n+  if (!check_target_format (expn))\n+    return false;\n+\n+  bc = TREE_CODE (base);\n+  ec = TREE_CODE (expn);\n+\n+  /* Folding candidates are not interesting.\n+     Can actually assert that it is already folded.  */\n+  if (ec == REAL_CST && bc == REAL_CST)\n+    return false;\n+\n+  if (bc == REAL_CST)\n+    {\n+      /* Only handle a fixed range of constant.  */\n+      REAL_VALUE_TYPE mv;\n+      REAL_VALUE_TYPE bcv = TREE_REAL_CST (base);\n+      if (REAL_VALUES_EQUAL (bcv, dconst1))\n+        return false;\n+      if (REAL_VALUES_LESS (bcv, dconst1))\n+        return false;\n+      real_from_integer (&mv, TYPE_MODE (TREE_TYPE (base)), 256, 0, 1);\n+      if (REAL_VALUES_LESS (mv, bcv))\n+        return false;\n+      return true;\n+    }\n+  else if (bc == SSA_NAME)\n+    {\n+      tree base_def, base_val, base_val0, base_var, type;\n+      int bit_sz;\n+\n+      /* Only handles cases where base value is converted\n+         from integer values.  */ \n+      base_def = SSA_NAME_DEF_STMT (base);\n+      if (TREE_CODE (base_def) != GIMPLE_MODIFY_STMT)\n+        return false;\n+\n+      base_val = GIMPLE_STMT_OPERAND (base_def, 1);\n+\n+      if (TREE_CODE (base_val) != FLOAT_EXPR)\n+        return false;\n+      base_val0 = TREE_OPERAND (base_val, 0);\n+\n+      base_var = SSA_NAME_VAR (base_val0);\n+      if (!DECL_P  (base_var))\n+        return false;\n+\n+      type = TREE_TYPE (base_var);\n+      if (TREE_CODE (type) != INTEGER_TYPE)\n+        return false;\n+      bit_sz = TYPE_PRECISION (type);\n+      /* If the type of the base is too wide,\n+         the resulting shrink wrapping condition\n+\t will be too conservative.  */\n+      if (bit_sz > MAX_BASE_INT_BIT_SIZE)\n+        return false;\n+\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* A helper function to help select candidate function calls that are\n+   suitable for conditional DCE.  Candidate functions must have single\n+   valid input domain in this implementation except for pow (see check_pow).\n+   Returns true if the function call is a candidate.  */\n+\n+static bool\n+check_builtin_call (tree bcall)\n+{\n+  tree arg;\n+\n+  arg = CALL_EXPR_ARG (bcall, 0);\n+  return check_target_format (arg);\n+}\n+\n+/* A helper function to determine if a builtin function call is a\n+   candidate for conditional DCE.  Returns true if the builtin call\n+   is a candidate.  */\n+\n+static bool\n+is_call_dce_candidate (tree call)\n+{\n+  tree fn;\n+  enum built_in_function fnc;\n+\n+  if (!flag_tree_builtin_call_dce)\n+    return false;\n+\n+  gcc_assert (call && TREE_CODE (call) == CALL_EXPR);\n+\n+  fn = get_callee_fndecl (call);\n+  if (!fn || !DECL_BUILT_IN (fn) \n+      || (DECL_BUILT_IN_CLASS (fn) != BUILT_IN_NORMAL))\n+    return false;\n+\n+  fnc = DECL_FUNCTION_CODE (fn);\n+  switch (fnc)\n+    {\n+    /* Trig functions.  */\n+    CASE_FLT_FN (BUILT_IN_ACOS):\n+    CASE_FLT_FN (BUILT_IN_ASIN):\n+    /* Hyperbolic functions.  */\n+    CASE_FLT_FN (BUILT_IN_ACOSH):\n+    CASE_FLT_FN (BUILT_IN_ATANH):\n+    CASE_FLT_FN (BUILT_IN_COSH):\n+    CASE_FLT_FN (BUILT_IN_SINH):\n+    /* Log functions.  */\n+    CASE_FLT_FN (BUILT_IN_LOG):\n+    CASE_FLT_FN (BUILT_IN_LOG2):\n+    CASE_FLT_FN (BUILT_IN_LOG10):\n+    CASE_FLT_FN (BUILT_IN_LOG1P):\n+    /* Exp functions.  */\n+    CASE_FLT_FN (BUILT_IN_EXP):\n+    CASE_FLT_FN (BUILT_IN_EXP2):\n+    CASE_FLT_FN (BUILT_IN_EXP10):\n+    CASE_FLT_FN (BUILT_IN_EXPM1):\n+    CASE_FLT_FN (BUILT_IN_POW10):\n+    /* Sqrt.  */\n+    CASE_FLT_FN (BUILT_IN_SQRT):\n+      return check_builtin_call (call);\n+    /* Special one: two argument pow.  */\n+    case BUILT_IN_POW:\n+      return check_pow (call);\n+    default:\n+      break;\n+    }\n+\n+  return false;\n+}\n+\n+\f\n+/* A helper function to generate gimple statements for\n+   one bound comparison.  ARG is the call argument to\n+   be compared with the bound, LBUB is the bound value\n+   in integer, TCODE is the tree_code of the comparison,\n+   TEMP_NAME1/TEMP_NAME2 are names of the temporaries,\n+   CONDS is a vector holding the produced GIMPLE statements,\n+   and NCONDS points to the variable holding the number\n+   of logical comparisons.  CONDS is either empty or \n+   a list ended with a null tree.  */\n+\n+static void\n+gen_one_condition (tree arg, int lbub, \n+                   enum tree_code tcode,\n+                   const char *temp_name1,\n+                   const char *temp_name2,\n+                   VEC (tree, heap) *conds,\n+                   unsigned *nconds)\n+{\n+  tree lbub_real_cst, lbub_cst, float_type;\n+  tree temp, tempn, tempc, tempcn;\n+  tree stmt1, stmt2, stmt3;\n+\n+  float_type = TREE_TYPE (arg);\n+  lbub_cst = build_int_cst (integer_type_node, lbub);\n+  lbub_real_cst = build_real_from_int_cst (float_type, lbub_cst);\n+\n+  temp = create_tmp_var (float_type, temp_name1);\n+  stmt1 = build_gimple_modify_stmt (temp, arg);\n+  tempn = make_ssa_name (temp, stmt1);\n+  GIMPLE_STMT_OPERAND (stmt1, 0) = tempn;\n+\n+  tempc = create_tmp_var (boolean_type_node, temp_name2);\n+  stmt2 = build_gimple_modify_stmt (tempc,\n+                                    fold_build2 (tcode,\n+                                                 boolean_type_node,\n+                                                 tempn, lbub_real_cst));\n+  tempcn = make_ssa_name (tempc, stmt2);\n+  GIMPLE_STMT_OPERAND (stmt2, 0) = tempcn;\n+\n+  /* fold_built3 not used for gimple statement here,\n+     as it will hit assertion.  */\n+  stmt3 = build3 (COND_EXPR, void_type_node,\n+                  tempcn, NULL_TREE, NULL_TREE);\n+  VEC_quick_push (tree, conds, stmt1);\n+  VEC_quick_push (tree, conds, stmt2);\n+  VEC_quick_push (tree, conds, stmt3);\n+  (*nconds)++;\n+}\n+\n+/* A helper function to generate GIMPLE statements for\n+   out of input domain check.  ARG is the call argument\n+   to be runtime checked, DOMAIN holds the valid domain\n+   for the given function, CONDS points to the vector\n+   holding the result GIMPLE statements.  *NCONDS is \n+   the number of logical comparisons.  This function \n+   produces no more than two logical comparisons, one\n+   for lower bound check, one for upper bound check.  */\n+\n+static void\n+gen_conditions_for_domain (tree arg, inp_domain domain,\n+                           VEC (tree, heap) *conds, \n+                           unsigned *nconds)\n+{\n+  if (domain.has_lb)\n+    gen_one_condition (arg, domain.lb,\n+                       (domain.is_lb_inclusive\n+                        ? LT_EXPR : LE_EXPR),\n+                       \"DCE_COND_LB\", \"DCE_COND_LB_TEST\",\n+                       conds, nconds);\n+\n+  if (domain.has_ub)\n+    {\n+      /* Now push a separator.  */\n+      if (domain.has_lb)\n+        VEC_quick_push (tree, conds, NULL);\n+\n+      gen_one_condition (arg, domain.ub,\n+                         (domain.is_ub_inclusive\n+                          ? GT_EXPR : GE_EXPR),\n+                         \"DCE_COND_UB\", \"DCE_COND_UB_TEST\",\n+                         conds, nconds);\n+    }\n+}\n+\n+\n+/* A helper function to generate condition\n+   code for the y argument in call pow (some_const, y).\n+   See candidate selection in check_pow.  Since the \n+   candidates' base values have a limited range,\n+   the guarded code generated for y are simple:\n+   if (y > max_y)\n+     pow (const, y);\n+   Note max_y can be computed separately for each\n+   const base, but in this implementation, we\n+   choose to compute it using the max base\n+   in the allowed range for the purpose of\n+   simplicity.  BASE is the constant base value,\n+   EXPN is the expression for the exponent argument,\n+   *CONDS is the vector to hold resulting statements,\n+   and *NCONDS is the number of logical conditions.  */\n+\n+static void\n+gen_conditions_for_pow_cst_base (tree base, tree expn,\n+                                 VEC (tree, heap) *conds,\n+                                 unsigned *nconds)\n+{\n+  inp_domain exp_domain; \n+  /* Validate the range of the base constant to make \n+     sure it is consistent with check_pow.  */\n+  REAL_VALUE_TYPE mv;\n+  REAL_VALUE_TYPE bcv = TREE_REAL_CST (base);\n+  gcc_assert (!REAL_VALUES_EQUAL (bcv, dconst1)\n+              && !REAL_VALUES_LESS (bcv, dconst1));\n+  real_from_integer (&mv, TYPE_MODE (TREE_TYPE (base)), 256, 0, 1);\n+  gcc_assert (!REAL_VALUES_LESS (mv, bcv));\n+\n+  exp_domain = get_domain (0, false, false,\n+                           127, true, false);\n+\n+  gen_conditions_for_domain (expn, exp_domain,\n+                             conds, nconds);\n+}\n+\n+/* Generate error condition code for pow calls with\n+   non constant base values.  The candidates selected\n+   have their base argument value converted from\n+   integer (see check_pow) value (1, 2, 4 bytes), and\n+   the max exp value is computed based on the size\n+   of the integer type (i.e. max possible base value).\n+   The resulting input domain for exp argument is thus\n+   conservative (smaller than the max value allowed by \n+   the runtime value of the base).  BASE is the integer \n+   base value, EXPN is the expression for the exponent \n+   argument, *CONDS is the vector to hold resulting \n+   statements, and *NCONDS is the number of logical \n+   conditions.  */\n+\n+static void\n+gen_conditions_for_pow_int_base (tree base, tree expn,\n+                                 VEC (tree, heap) *conds,\n+                                 unsigned *nconds)\n+{\n+  tree base_def, base_nm, base_val, base_val0;\n+  tree base_var, int_type;\n+  tree temp, tempn;\n+  tree cst0, stmt1, stmt2;\n+  int bit_sz, max_exp;\n+  inp_domain exp_domain;\n+\n+  base_def = SSA_NAME_DEF_STMT (base);\n+  base_nm = GIMPLE_STMT_OPERAND (base_def, 0);\n+  base_val = GIMPLE_STMT_OPERAND (base_def, 1);\n+  base_val0 = TREE_OPERAND (base_val, 0);\n+  base_var = SSA_NAME_VAR (base_val0);\n+  int_type = TREE_TYPE (base_var);\n+  bit_sz = TYPE_PRECISION (int_type);\n+  gcc_assert (bit_sz > 0 \n+              && bit_sz <= MAX_BASE_INT_BIT_SIZE);\n+\n+  /* Determine the max exp argument value according to\n+     the size of the base integer.  The max exp value\n+     is conservatively estimated assuming IEEE754 double\n+     precision format.  */\n+  if (bit_sz == 8)\n+    max_exp = 128;\n+  else if (bit_sz == 16)\n+    max_exp = 64;\n+  else\n+  {\n+    gcc_assert (bit_sz == MAX_BASE_INT_BIT_SIZE);\n+    max_exp = 32;\n+  }\n+\n+  /* For pow ((double)x, y), generate the following conditions:\n+     cond 1:\n+     temp1 = x;\n+     if (temp1 <= 0)\n+\n+     cond 2:\n+     temp2 = y;\n+     if (temp2 > max_exp_real_cst)  */\n+\n+  /* Generate condition in reverse order -- first\n+     the condition for the exp argument.  */\n+\n+  exp_domain = get_domain (0, false, false,\n+                           max_exp, true, true);\n+\n+  gen_conditions_for_domain (expn, exp_domain,\n+                             conds, nconds);\n+\n+  /* Now generate condition for the base argument.\n+     Note it does not use the helper function\n+     gen_conditions_for_domain because the base\n+     type is integer.  */\n+\n+  /* Push a separator.  */\n+  VEC_quick_push (tree, conds, NULL);\n+\n+  temp = create_tmp_var (int_type, \"DCE_COND1\");\n+  cst0 = build_int_cst (int_type, 0);\n+  stmt1 = build_gimple_modify_stmt (temp, base_val0);\n+  tempn = make_ssa_name (temp, stmt1);\n+  GIMPLE_STMT_OPERAND (stmt1, 0) = tempn;\n+  stmt2 = build3 (COND_EXPR, void_type_node,\n+                  fold_build2 (LE_EXPR, boolean_type_node, tempn, cst0),\n+                  NULL_TREE, NULL_TREE);\n+\n+  VEC_quick_push (tree, conds, stmt1);\n+  VEC_quick_push (tree, conds, stmt2);\n+  (*nconds)++;\n+}\n+\n+/* Method to generate conditional statements for guarding conditionally\n+   dead calls to pow.  One or more statements can be generated for\n+   each logical condition.  Statement groups of different conditions\n+   are separated by a NULL tree and they are stored in the VEC\n+   conds.  The number of logical conditions are stored in *nconds.\n+\n+   See C99 standard, 7.12.7.4:2, for description of pow (x, y).\n+   The precise condition for domain errors are complex.  In this\n+   implementation, a simplified (but conservative) valid domain\n+   for x and y are used: x is positive to avoid dom errors, while\n+   y is smaller than a upper bound (depending on x) to avoid range\n+   errors.  Runtime code is generated to check x (if not constant)\n+   and y against the valid domain.  If it is out, jump to the call,\n+   otherwise the call is bypassed.  POW_CALL is the call statement,\n+   *CONDS is a vector holding the resulting condition statements,\n+   and *NCONDS is the number of logical conditions.  */\n+\n+static void\n+gen_conditions_for_pow (tree pow_call, VEC (tree, heap) *conds, \n+                        unsigned *nconds)\n+{\n+  tree base, expn;\n+  enum tree_code bc, ec;\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (check_pow (pow_call));\n+#endif\n+\n+  *nconds = 0;\n+\n+  base = CALL_EXPR_ARG (pow_call, 0);\n+  expn = CALL_EXPR_ARG (pow_call, 1);\n+\n+  bc = TREE_CODE (base);\n+  ec = TREE_CODE (expn);\n+\n+  if (bc == REAL_CST)\n+      gen_conditions_for_pow_cst_base (base, expn,\n+                                       conds, nconds);\n+  else if (bc == SSA_NAME)\n+      gen_conditions_for_pow_int_base (base, expn,\n+                                       conds, nconds);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* A helper routine to help computing the valid input domain\n+   for a builtin function.  See C99 7.12.7 for details.  In this\n+   implementation, we only handle single region domain.  The\n+   resulting region can be conservative (smaller) than the actual\n+   one and rounded to integers.  Some of the bounds are documented\n+   in the standard, while other limit constants are computed\n+   assuming IEEE floating point format (for SF and DF modes).  \n+   Since IEEE only sets minimum requirements for long double format, \n+   different long double formats exist under different implementations \n+   (e.g, 64 bit double precision (DF), 80 bit double-extended \n+   precision (XF), and 128 bit quad precision (QF) ).  For simplicity, \n+   in this implementation, the computed bounds for long double assume \n+   64 bit format (DF), and are therefore conservative.  Another \n+   assumption is that single precision float type is always SF mode,\n+   and double type is DF mode.  This function is quite \n+   implementation specific, so it may not be suitable to be part of\n+   builtins.c.  This needs to be revisited later to see if it can\n+   be leveraged in x87 assembly expansion.  */\n+\n+static inp_domain\n+get_no_error_domain (enum built_in_function fnc)\n+{\n+  switch (fnc)\n+    {\n+    /* Trig functions: return [-1, +1]  */\n+    CASE_FLT_FN (BUILT_IN_ACOS):\n+    CASE_FLT_FN (BUILT_IN_ASIN):\n+      return get_domain (-1, true, true,\n+                         1, true, true);\n+    /* Hyperbolic functions.  */\n+    CASE_FLT_FN (BUILT_IN_ACOSH):\n+      /* acosh: [1, +inf)  */\n+      return get_domain (1, true, true,\n+                         1, false, false);\n+    CASE_FLT_FN (BUILT_IN_ATANH):\n+      /* atanh: (-1, +1)  */\n+      return get_domain (-1, true, false,\n+                         1, true, false);\n+    case BUILT_IN_COSHF:\n+    case BUILT_IN_SINHF:\n+      /* coshf: (-89, +89)  */\n+      return get_domain (-89, true, false,\n+                         89, true, false);\n+    case BUILT_IN_COSH:\n+    case BUILT_IN_SINH:\n+    case BUILT_IN_COSHL:\n+    case BUILT_IN_SINHL:\n+      /* cosh: (-710, +710)  */\n+      return get_domain (-710, true, false,\n+                         710, true, false);\n+    /* Log functions: (0, +inf)  */\n+    CASE_FLT_FN (BUILT_IN_LOG):\n+    CASE_FLT_FN (BUILT_IN_LOG2):\n+    CASE_FLT_FN (BUILT_IN_LOG10):\n+      return get_domain (0, true, false,\n+                         0, false, false);\n+    CASE_FLT_FN (BUILT_IN_LOG1P):\n+      return get_domain (-1, true, false,\n+                         0, false, false);\n+    /* Exp functions.  */\n+    case BUILT_IN_EXPF:\n+    case BUILT_IN_EXPM1F:\n+      /* expf: (-inf, 88)  */\n+      return get_domain (-1, false, false,\n+                         88, true, false);\n+    case BUILT_IN_EXP:\n+    case BUILT_IN_EXPM1:\n+    case BUILT_IN_EXPL:\n+    case BUILT_IN_EXPM1L:\n+      /* exp: (-inf, 709)  */\n+      return get_domain (-1, false, false,\n+                         709, true, false);\n+    case BUILT_IN_EXP2F:\n+      /* exp2f: (-inf, 128)  */\n+      return get_domain (-1, false, false,\n+                         128, true, false);\n+    case BUILT_IN_EXP2:\n+    case BUILT_IN_EXP2L:\n+      /* exp2: (-inf, 1024)  */\n+      return get_domain (-1, false, false,\n+                         1024, true, false);\n+    case BUILT_IN_EXP10F:\n+    case BUILT_IN_POW10F:\n+      /* exp10f: (-inf, 38)  */\n+      return get_domain (-1, false, false,\n+                         38, true, false);\n+    case BUILT_IN_EXP10:\n+    case BUILT_IN_POW10:\n+    case BUILT_IN_EXP10L:\n+    case BUILT_IN_POW10L:\n+      /* exp10: (-inf, 308)  */\n+      return get_domain (-1, false, false,\n+                         308, true, false);\n+    /* sqrt: [0, +inf)  */\n+    CASE_FLT_FN (BUILT_IN_SQRT):\n+      return get_domain (0, true, true,\n+                         0, false, false);\n+    default:\n+      gcc_unreachable (); \n+    }\n+\n+  gcc_unreachable (); \n+}\n+\n+/* The function to generate shrink wrap conditions for a partially\n+   dead builtin call whose return value is not used anywhere,\n+   but has to be kept live due to potential error condition.\n+   BI_CALL is the builtin call, CONDS is the vector of statements \n+   for condition code, NCODES is the pointer to the number of \n+   logical conditions.  Statements belonging to different logical\n+   condition are separated by NULL tree in the vector.  */\n+\n+static void\n+gen_shrink_wrap_conditions (tree bi_call, VEC (tree, heap) *conds, \n+                            unsigned int *nconds)\n+{\n+  tree call, fn;\n+  enum built_in_function fnc;\n+\n+  gcc_assert (nconds && conds);\n+  gcc_assert (VEC_length (tree, conds) == 0);\n+  gcc_assert (TREE_CODE (bi_call) == GIMPLE_MODIFY_STMT\n+              || TREE_CODE (bi_call) == CALL_EXPR);\n+\n+  call = bi_call;\n+  if (TREE_CODE (call) == GIMPLE_MODIFY_STMT)\n+    call = get_call_expr_in (bi_call);\n+\n+  fn = get_callee_fndecl (call);\n+  gcc_assert (fn && DECL_BUILT_IN (fn));\n+  fnc = DECL_FUNCTION_CODE (fn);\n+  *nconds = 0;\n+\n+  if (fnc == BUILT_IN_POW)\n+    gen_conditions_for_pow (call, conds, nconds);\n+  else\n+    {\n+      tree arg;\n+      inp_domain domain = get_no_error_domain (fnc);\n+      *nconds = 0;\n+      arg = CALL_EXPR_ARG (bi_call, 0);\n+      gen_conditions_for_domain (arg, domain, conds, nconds);\n+    }\n+\n+  return;\n+}\n+\n+\n+/* Probability of the branch (to the call) is taken.  */\n+#define ERR_PROB 0.01\n+\n+/* The function to shrink wrap a partially dead builtin call \n+   whose return value is not used anywhere, but has to be kept \n+   live due to potential error condition.  Returns true if the\n+   transformation actually happens.  */\n+\n+static bool \n+shrink_wrap_one_built_in_call (tree bi_call)\n+{\n+  block_stmt_iterator bi_call_bsi;\n+  basic_block bi_call_bb, join_tgt_bb, guard_bb, guard_bb0;\n+  edge join_tgt_in_edge_from_call, join_tgt_in_edge_fall_thru;\n+  edge bi_call_in_edge0, guard_bb_in_edge;\n+  VEC (tree, heap) *conds;\n+  unsigned tn_cond_stmts, nconds;\n+  unsigned ci;\n+  tree cond_expr = NULL;\n+  tree cond_expr_start;\n+  tree bi_call_label_decl;\n+  tree bi_call_label;\n+\n+  conds = VEC_alloc (tree, heap, 12);\n+  gen_shrink_wrap_conditions (bi_call, conds, &nconds);\n+\n+  /* This can happen if the condition generator decides\n+     it is not beneficial to do the transformation.  Just\n+     return false and do not do any transformation for \n+     the call.  */\n+  if (nconds == 0)\n+    return false;\n+\n+  bi_call_bb = bb_for_stmt (bi_call);\n+\n+  /* Now find the join target bb -- split\n+     bi_call_bb if needed.  */\n+  bi_call_bsi = bsi_for_stmt (bi_call);\n+\n+  join_tgt_in_edge_from_call = split_block (bi_call_bb, bi_call);\n+  bi_call_bsi = bsi_for_stmt (bi_call);\n+\n+  join_tgt_bb = join_tgt_in_edge_from_call->dest;\n+\n+  /* Now it is time to insert the first conditional expression\n+     into bi_call_bb and split this bb so that bi_call is\n+     shrink-wrapped.  */\n+  tn_cond_stmts = VEC_length (tree, conds);\n+  cond_expr = NULL;\n+  cond_expr_start = VEC_index (tree, conds, 0);\n+  for (ci = 0; ci < tn_cond_stmts; ci++)\n+    {\n+      tree c = VEC_index (tree, conds, ci);\n+      gcc_assert (c || ci != 0);\n+      if (!c)\n+        break;\n+      bsi_insert_before (&bi_call_bsi, c, BSI_SAME_STMT);\n+      cond_expr = c;\n+    }\n+  nconds--;\n+  ci++;\n+  gcc_assert (cond_expr && TREE_CODE (cond_expr) == COND_EXPR);\n+\n+  /* Now the label.  */\n+  bi_call_label_decl = create_artificial_label ();\n+  bi_call_label = build1 (LABEL_EXPR, void_type_node, bi_call_label_decl);\n+  bsi_insert_before (&bi_call_bsi, bi_call_label, BSI_SAME_STMT);\n+\n+  bi_call_in_edge0 = split_block (bi_call_bb, cond_expr);\n+  bi_call_in_edge0->flags &= ~EDGE_FALLTHRU;\n+  bi_call_in_edge0->flags |= EDGE_TRUE_VALUE;\n+  guard_bb0 = bi_call_bb;\n+  bi_call_bb = bi_call_in_edge0->dest;\n+  join_tgt_in_edge_fall_thru = make_edge (guard_bb0, join_tgt_bb, \n+                                          EDGE_FALSE_VALUE);\n+\n+  bi_call_in_edge0->probability = REG_BR_PROB_BASE * ERR_PROB;\n+  join_tgt_in_edge_fall_thru->probability =\n+      REG_BR_PROB_BASE - bi_call_in_edge0->probability;\n+\n+  /* Code generation for the rest of the conditions  */\n+  guard_bb = guard_bb0;\n+  while (nconds > 0)\n+    {\n+      unsigned ci0;\n+      edge bi_call_in_edge;\n+      block_stmt_iterator guard_bsi = bsi_for_stmt (cond_expr_start);\n+      ci0 = ci;\n+      cond_expr_start = VEC_index (tree, conds, ci0);\n+      for (; ci < tn_cond_stmts; ci++)\n+        {\n+          tree c = VEC_index (tree, conds, ci);\n+          gcc_assert (c || ci != ci0);\n+          if (!c)\n+            break;\n+          bsi_insert_before (&guard_bsi, c, BSI_SAME_STMT);\n+          cond_expr = c;\n+        }\n+      nconds--;\n+      ci++;\n+      gcc_assert (cond_expr && TREE_CODE (cond_expr) == COND_EXPR);\n+      guard_bb_in_edge = split_block (guard_bb, cond_expr);\n+      guard_bb_in_edge->flags &= ~EDGE_FALLTHRU;\n+      guard_bb_in_edge->flags |= EDGE_FALSE_VALUE;\n+\n+      bi_call_in_edge = make_edge (guard_bb, bi_call_bb, EDGE_TRUE_VALUE);\n+\n+      bi_call_in_edge->probability = REG_BR_PROB_BASE * ERR_PROB;\n+      guard_bb_in_edge->probability =\n+          REG_BR_PROB_BASE - bi_call_in_edge->probability;\n+    }\n+\n+  VEC_free (tree, heap, conds);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      location_t loc;\n+      loc = EXPR_LOCATION (bi_call);\n+      fprintf (dump_file,\n+               \"%s:%d: note: function call is shrink-wrapped\"\n+               \" into error conditions.\\n\",\n+               LOCATION_FILE (loc), LOCATION_LINE (loc));\n+    }\n+\n+  return true;\n+}\n+\n+/* The top level function for conditional dead code shrink\n+   wrapping transformation.  */\n+\n+static bool\n+shrink_wrap_conditional_dead_built_in_calls (void)\n+{\n+  bool changed = false;\n+  unsigned i = 0;\n+\n+  unsigned n = VEC_length (tree, cond_dead_built_in_calls);\n+  if (n == 0) \n+    return false;\n+\n+  for (; i < n ; i++)\n+    {\n+      tree bi_call = VEC_index (tree, cond_dead_built_in_calls, i);\n+      changed |= shrink_wrap_one_built_in_call (bi_call);\n+    }\n+\n+  return changed;\n+}\n+\n+/* Pass entry points.  */\n+\n+static unsigned int\n+tree_call_cdce (void)\n+{\n+  basic_block bb;\n+  block_stmt_iterator i;\n+  bool something_changed = false;\n+  cond_dead_built_in_calls = VEC_alloc (tree, heap, 64);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      /* Collect dead call candidates.  */\n+      for (i = bsi_start (bb); ! bsi_end_p (i); bsi_next (&i))\n+        {\n+\t  tree stmt = bsi_stmt (i);\n+          if (TREE_CODE (stmt) == CALL_EXPR\n+              && is_call_dce_candidate (stmt))\n+            {\n+              if (dump_file && (dump_flags & TDF_DETAILS))\n+                {\n+                  fprintf (dump_file, \"Found conditional dead call: \");\n+                  print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+                  fprintf (dump_file, \"\\n\");\n+                }\n+              VEC_quick_push (tree, cond_dead_built_in_calls, stmt);\n+            }\n+\t}\n+    }\n+\n+  something_changed =\n+    shrink_wrap_conditional_dead_built_in_calls ();\n+\n+  VEC_free (tree, heap, cond_dead_built_in_calls);\n+\n+  if (something_changed)\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      return (TODO_update_ssa | TODO_cleanup_cfg | TODO_ggc_collect \n+              | TODO_remove_unused_locals);\n+    }\n+  else\n+    return 0;\n+}\n+\n+static bool\n+gate_call_cdce (void)\n+{\n+  /* The limit constants used in the implementation\n+     assume IEEE floating point format.  Other formats\n+     can be supported in the future if needed.  */\n+  return flag_tree_builtin_call_dce != 0; \n+}\n+\n+struct gimple_opt_pass pass_call_cdce =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"cdce\",                               /* name */\n+  gate_call_cdce,                       /* gate */\n+  tree_call_cdce,                       /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_TREE_CALL_CDCE,                    /* tv_id */\n+  PROP_cfg | PROP_ssa,                  /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func | TODO_verify_ssa      /* todo_flags_finish */\n+ }\n+};"}, {"sha": "ea5aae069c1bf688c4c3f1aae44704b7d3a675ac", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2699190282c19bd5703de0a606b842774715074/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=c2699190282c19bd5703de0a606b842774715074", "patch": "@@ -337,6 +337,7 @@ extern struct gimple_opt_pass pass_dominator;\n extern struct gimple_opt_pass pass_dce;\n extern struct gimple_opt_pass pass_dce_loop;\n extern struct gimple_opt_pass pass_cd_dce;\n+extern struct gimple_opt_pass pass_call_cdce;\n extern struct gimple_opt_pass pass_merge_phi;\n extern struct gimple_opt_pass pass_split_crit_edges;\n extern struct gimple_opt_pass pass_pre;"}]}