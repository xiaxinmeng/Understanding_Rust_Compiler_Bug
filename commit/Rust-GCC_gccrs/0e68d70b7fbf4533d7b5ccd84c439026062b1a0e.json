{"sha": "0e68d70b7fbf4533d7b5ccd84c439026062b1a0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU2OGQ3MGI3ZmJmNDUzM2Q3YjVjY2Q4NGM0MzkwMjYwNjJiMWEwZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-07-04T02:20:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-07-04T02:20:37Z"}, "message": "compiler: optimize 0,1,2-case select statement\n    \n    For a select statement with zero-, one-, or two-case with a\n    default case, we can generate simpler code instead of calling the\n    generic selectgo. A zero-case select is just blocking the\n    execution. A one-case select is mostly just executing the case. A\n    two-case select with a default case is a non-blocking send or\n    receive. We add these special cases for lowering a select\n    statement.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/184998\n\nFrom-SVN: r273034", "tree": {"sha": "b01088e287d6565278c17bc004de616ba1a0891f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b01088e287d6565278c17bc004de616ba1a0891f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/comments", "author": null, "committer": null, "parents": [{"sha": "9c5784fa7585c274b188f4df26bb80244ef97cb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c5784fa7585c274b188f4df26bb80244ef97cb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c5784fa7585c274b188f4df26bb80244ef97cb0"}], "stats": {"total": 294, "additions": 289, "deletions": 5}, "files": [{"sha": "410afb0bab17b9da54461b6049c7699891fa854b", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=0e68d70b7fbf4533d7b5ccd84c439026062b1a0e", "patch": "@@ -1,4 +1,4 @@\n-197b6fdfb861f07bab7365e350b5b855cfccc290\n+7a8e10be0ddb8909ce25a264d03b24cee4df60cc\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "3abf7ea9762fd2a14381886aa4a2718dc032d1b6", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=0e68d70b7fbf4533d7b5ccd84c439026062b1a0e", "patch": "@@ -6262,7 +6262,8 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n \n \t  if (this->asm_name_ == \"runtime.gopanic\"\n \t      || this->asm_name_ == \"__go_runtime_error\"\n-              || this->asm_name_ == \"runtime.panicdottype\")\n+              || this->asm_name_ == \"runtime.panicdottype\"\n+              || this->asm_name_ == \"runtime.block\")\n \t    flags |= Backend::function_does_not_return;\n \t}\n "}, {"sha": "c754739227ebf45d5bbfd45724471810690252be", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=0e68d70b7fbf4533d7b5ccd84c439026062b1a0e", "patch": "@@ -204,6 +204,22 @@ DEF_GO_RUNTIME(CHANRECV2, \"runtime.chanrecv2\", P2(CHAN, POINTER), R1(BOOL))\n DEF_GO_RUNTIME(SELECTGO, \"runtime.selectgo\", P3(POINTER, POINTER, INT),\n \t       R2(INT, BOOL))\n \n+// Non-blocking send a value on a channel, used for two-case select\n+// statement with a default case.\n+DEF_GO_RUNTIME(SELECTNBSEND, \"runtime.selectnbsend\", P2(CHAN, POINTER), R1(BOOL))\n+\n+// Non-blocking receive a value from a channel, used for two-case select\n+// statement with a default case.\n+DEF_GO_RUNTIME(SELECTNBRECV, \"runtime.selectnbrecv\", P2(POINTER, CHAN), R1(BOOL))\n+\n+// Non-blocking tuple receive from a channel, used for two-case select\n+// statement with a default case.\n+DEF_GO_RUNTIME(SELECTNBRECV2, \"runtime.selectnbrecv2\", P3(POINTER, POINTER, CHAN),\n+               R1(BOOL))\n+\n+// Block execution.  Used for zero-case select.\n+DEF_GO_RUNTIME(BLOCK, \"runtime.block\", P0(), R0())\n+\n \n // Panic.\n DEF_GO_RUNTIME(GOPANIC, \"runtime.gopanic\", P1(EFACE), R0())"}, {"sha": "1e88fabecf98474807be2763144a0085fbc14899", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=0e68d70b7fbf4533d7b5ccd84c439026062b1a0e", "patch": "@@ -5665,6 +5665,28 @@ Select_statement::do_lower(Gogo* gogo, Named_object* function,\n   Block* b = new Block(enclosing, loc);\n \n   int ncases = this->clauses_->size();\n+\n+  // Zero-case select.  Just block the execution.\n+  if (ncases == 0)\n+    {\n+      Expression* call = Runtime::make_call(Runtime::BLOCK, loc, 0);\n+      Statement *s = Statement::make_statement(call, false);\n+      b->add_statement(s);\n+      this->is_lowered_ = true;\n+      return Statement::make_block_statement(b, loc);\n+    }\n+\n+  // One-case select.  It is mostly just to run the case.\n+  if (ncases == 1)\n+    return this->lower_one_case(b);\n+\n+  // Two-case select with one default case.  It is a non-blocking\n+  // send/receive.\n+  if (ncases == 2\n+      && (this->clauses_->at(0).is_default()\n+          || this->clauses_->at(1).is_default()))\n+    return this->lower_two_case(b);\n+\n   Type* scase_type = Channel_type::select_case_type();\n   Expression* ncases_expr =\n     Expression::make_integer_ul(ncases, NULL,\n@@ -5733,6 +5755,213 @@ Select_statement::do_lower(Gogo* gogo, Named_object* function,\n   return Statement::make_block_statement(b, loc);\n }\n \n+// Lower a one-case select statement.\n+\n+Statement*\n+Select_statement::lower_one_case(Block* b)\n+{\n+  Select_clauses::Select_clause& scase = this->clauses_->at(0);\n+  Location loc = this->location();\n+  Expression* chan = scase.channel();\n+  if (chan != NULL)\n+    {\n+      // Lower this to\n+      //   if chan == nil { block() }; send/recv; body\n+      Temporary_statement* chantmp = Statement::make_temporary(NULL, chan, loc);\n+      b->add_statement(chantmp);\n+      Expression* chanref = Expression::make_temporary_reference(chantmp, loc);\n+\n+      Expression* nil = Expression::make_nil(loc);\n+      Expression* cond = Expression::make_binary(OPERATOR_EQEQ, chanref, nil, loc);\n+      Block* bnil = new Block(b, loc);\n+      Expression* call = Runtime::make_call(Runtime::BLOCK, loc, 0);\n+      Statement* s = Statement::make_statement(call, false);\n+      bnil->add_statement(s);\n+      Statement* ifs = Statement::make_if_statement(cond, bnil, NULL, loc);\n+      b->add_statement(ifs);\n+\n+      chanref = chanref->copy();\n+      Location cloc = scase.location();\n+      if (scase.is_send())\n+        {\n+          s = Statement::make_send_statement(chanref, scase.val(), cloc);\n+          b->add_statement(s);\n+        }\n+      else\n+        {\n+          if (scase.closed() == NULL && scase.closedvar() == NULL)\n+            {\n+              // Simple receive.\n+              Expression* recv = Expression::make_receive(chanref, cloc);\n+              if (scase.val() != NULL)\n+                s = Statement::make_assignment(scase.val(), recv, cloc);\n+              else if (scase.var() != NULL)\n+                {\n+                  Temporary_statement *ts =\n+                    Statement::make_temporary(NULL, recv, cloc);\n+                  Expression* ref =\n+                    Expression::make_temporary_reference(ts, cloc);\n+                  s = ts;\n+                  scase.var()->var_value()->set_init(ref);\n+                  scase.var()->var_value()->clear_type_from_chan_element();\n+                }\n+              else\n+                s = Statement::make_statement(recv, false);\n+              b->add_statement(s);\n+            }\n+          else\n+            {\n+              // Tuple receive.\n+              Expression* lhs;\n+              if (scase.val() != NULL)\n+                lhs = scase.val();\n+              else\n+                {\n+                  Type* valtype = chan->type()->channel_type()->element_type();\n+                  Temporary_statement *ts =\n+                    Statement::make_temporary(valtype, NULL, cloc);\n+                  lhs = Expression::make_temporary_reference(ts, cloc);\n+                  b->add_statement(ts);\n+                }\n+\n+              Expression* lhs2;\n+              if (scase.closed() != NULL)\n+                lhs2 = scase.closed();\n+              else\n+                {\n+                  Type* booltype = Type::make_boolean_type();\n+                  Temporary_statement *ts =\n+                    Statement::make_temporary(booltype, NULL, cloc);\n+                  lhs2 = Expression::make_temporary_reference(ts, cloc);\n+                  b->add_statement(ts);\n+                }\n+\n+              s = Statement::make_tuple_receive_assignment(lhs, lhs2, chanref, cloc);\n+              b->add_statement(s);\n+\n+              if (scase.var() != NULL)\n+                {\n+                  scase.var()->var_value()->set_init(lhs->copy());\n+                  scase.var()->var_value()->clear_type_from_chan_element();\n+                }\n+\n+              if (scase.closedvar() != NULL)\n+                scase.closedvar()->var_value()->set_init(lhs2->copy());\n+            }\n+        }\n+    }\n+\n+  Statement* bs =\n+    Statement::make_block_statement(scase.statements(), scase.location());\n+  b->add_statement(bs);\n+\n+  this->is_lowered_ = true;\n+  return Statement::make_block_statement(b, loc);\n+}\n+\n+// Lower a two-case select statement with one default case.\n+\n+Statement*\n+Select_statement::lower_two_case(Block* b)\n+{\n+  Select_clauses::Select_clause& chancase =\n+    (this->clauses_->at(0).is_default()\n+     ? this->clauses_->at(1)\n+     : this->clauses_->at(0));\n+  Select_clauses::Select_clause& defcase =\n+    (this->clauses_->at(0).is_default()\n+     ? this->clauses_->at(0)\n+     : this->clauses_->at(1));\n+  Location loc = this->location();\n+  Expression* chan = chancase.channel();\n+\n+  Temporary_statement* chantmp = Statement::make_temporary(NULL, chan, loc);\n+  b->add_statement(chantmp);\n+  Expression* chanref = Expression::make_temporary_reference(chantmp, loc);\n+\n+  Block* bchan;\n+  Expression* call;\n+  if (chancase.is_send())\n+    {\n+      // if selectnbsend(chan, &val) { body } else { default body }\n+\n+      Temporary_statement* ts = Statement::make_temporary(NULL, chancase.val(), loc);\n+      // Tell the escape analysis that the value escapes, as it may be sent\n+      // to a channel.\n+      ts->set_value_escapes();\n+      b->add_statement(ts);\n+\n+      Expression* ref = Expression::make_temporary_reference(ts, loc);\n+      Expression* addr = Expression::make_unary(OPERATOR_AND, ref, loc);\n+      call = Runtime::make_call(Runtime::SELECTNBSEND, loc, 2, chanref, addr);\n+      bchan = chancase.statements();\n+    }\n+  else\n+    {\n+      Type* valtype = chan->type()->channel_type()->element_type();\n+      Temporary_statement* ts = Statement::make_temporary(valtype, NULL, loc);\n+      b->add_statement(ts);\n+\n+      Expression* ref = Expression::make_temporary_reference(ts, loc);\n+      Expression* addr = Expression::make_unary(OPERATOR_AND, ref, loc);\n+      Expression* okref = NULL;\n+      if (chancase.closed() == NULL && chancase.closedvar() == NULL)\n+        {\n+          // Simple receive.\n+          // if selectnbrecv(&lhs, chan) { body } else { default body }\n+          call = Runtime::make_call(Runtime::SELECTNBRECV, loc, 2, addr, chanref);\n+        }\n+      else\n+        {\n+          // Tuple receive.\n+          // if selectnbrecv2(&lhs, &ok, chan) { body } else { default body }\n+\n+          Type* booltype = Type::make_boolean_type();\n+          Temporary_statement* ts = Statement::make_temporary(booltype, NULL, loc);\n+          b->add_statement(ts);\n+\n+          okref = Expression::make_temporary_reference(ts, loc);\n+          Expression* okaddr = Expression::make_unary(OPERATOR_AND, okref, loc);\n+          call = Runtime::make_call(Runtime::SELECTNBRECV2, loc, 3, addr, okaddr,\n+                                    chanref);\n+        }\n+\n+      Location cloc = chancase.location();\n+      bchan = new Block(b, loc);\n+      if (chancase.val() != NULL && !chancase.val()->is_sink_expression())\n+        {\n+          Statement* as = Statement::make_assignment(chancase.val(), ref->copy(),\n+                                                     cloc);\n+          bchan->add_statement(as);\n+        }\n+      else if (chancase.var() != NULL)\n+        {\n+          chancase.var()->var_value()->set_init(ref->copy());\n+          chancase.var()->var_value()->clear_type_from_chan_element();\n+        }\n+\n+      if (chancase.closed() != NULL && !chancase.closed()->is_sink_expression())\n+        {\n+          Statement* as = Statement::make_assignment(chancase.closed(),\n+                                                     okref->copy(), cloc);\n+          bchan->add_statement(as);\n+        }\n+      else if (chancase.closedvar() != NULL)\n+        chancase.closedvar()->var_value()->set_init(okref->copy());\n+\n+      Statement* bs = Statement::make_block_statement(chancase.statements(),\n+                                                      cloc);\n+      bchan->add_statement(bs);\n+    }\n+\n+  Statement* ifs =\n+    Statement::make_if_statement(call, bchan, defcase.statements(), loc);\n+  b->add_statement(ifs);\n+\n+  this->is_lowered_ = true;\n+  return Statement::make_block_statement(b, loc);\n+}\n+\n // Whether the select statement itself may fall through to the following\n // statement.\n "}, {"sha": "7c254d0e28e45e5365e6a2741bd7b45d1ddaa588", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=0e68d70b7fbf4533d7b5ccd84c439026062b1a0e", "patch": "@@ -1061,7 +1061,7 @@ class Select_clauses\n   // for the variable to set, and CLOSED is either NULL or a\n   // Var_expression to set to whether the channel is closed.  If VAL\n   // is NULL, VAR may be a variable to be initialized with the\n-  // received value, and CLOSEDVAR ma be a variable to be initialized\n+  // received value, and CLOSEDVAR may be a variable to be initialized\n   // with whether the channel is closed.  IS_DEFAULT is true if this\n   // is the default clause.  STATEMENTS is the list of statements to\n   // execute.\n@@ -1110,7 +1110,6 @@ class Select_clauses\n   void\n   dump_clauses(Ast_dump_context*) const;\n \n- private:\n   // A single clause.\n   class Select_clause\n   {\n@@ -1166,8 +1165,30 @@ class Select_clauses\n       return this->is_send_;\n     }\n \n+    // Return the value to send or the lvalue to receive into.\n+    Expression*\n+    val() const\n+    { return this->val_; }\n+\n+    // Return the lvalue to set to whether the channel is closed\n+    // on a receive.\n+    Expression*\n+    closed() const\n+    { return this->closed_; }\n+\n+    // Return the variable to initialize, for \"case a := <-ch\".\n+    Named_object*\n+    var() const\n+    { return this->var_; }\n+\n+    // Return the variable to initialize to whether the channel\n+    // is closed, for \"case a, c := <-ch\".\n+    Named_object*\n+    closedvar() const\n+    { return this->closedvar_; }\n+\n     // Return the statements.\n-    const Block*\n+    Block*\n     statements() const\n     { return this->statements_; }\n \n@@ -1235,6 +1256,11 @@ class Select_clauses\n     bool is_lowered_;\n   };\n \n+  Select_clause&\n+  at(size_t i)\n+  { return this->clauses_.at(i); }\n+\n+ private:\n   typedef std::vector<Select_clause> Clauses;\n \n   Clauses clauses_;\n@@ -1288,6 +1314,14 @@ class Select_statement : public Statement\n   do_dump_statement(Ast_dump_context*) const;\n \n  private:\n+  // Lower a one-case select statement.\n+  Statement*\n+  lower_one_case(Block*);\n+\n+  // Lower a two-case select statement with one defualt case.\n+  Statement*\n+  lower_two_case(Block*);\n+\n   // The select clauses.\n   Select_clauses* clauses_;\n   // A temporary that holds the index value returned by selectgo."}, {"sha": "6c8d6f70ebda7aee91d36e8841eb10f58b1169e2", "filename": "libgo/go/runtime/chan.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/libgo%2Fgo%2Fruntime%2Fchan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/libgo%2Fgo%2Fruntime%2Fchan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan.go?ref=0e68d70b7fbf4533d7b5ccd84c439026062b1a0e", "patch": "@@ -32,6 +32,9 @@ import (\n //go:linkname chanrecv1 runtime.chanrecv1\n //go:linkname chanrecv2 runtime.chanrecv2\n //go:linkname closechan runtime.closechan\n+//go:linkname selectnbsend runtime.selectnbsend\n+//go:linkname selectnbrecv runtime.selectnbrecv\n+//go:linkname selectnbrecv2 runtime.selectnbrecv2\n \n const (\n \tmaxAlign  = 8"}, {"sha": "16de9b88f6c17ed1330a3266808f1a94944ad46b", "filename": "libgo/go/runtime/select.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/libgo%2Fgo%2Fruntime%2Fselect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e68d70b7fbf4533d7b5ccd84c439026062b1a0e/libgo%2Fgo%2Fruntime%2Fselect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fselect.go?ref=0e68d70b7fbf4533d7b5ccd84c439026062b1a0e", "patch": "@@ -14,6 +14,7 @@ import (\n // themselves, so that the compiler will export them.\n //\n //go:linkname selectgo runtime.selectgo\n+//go:linkname block runtime.block\n \n const debugSelect = false\n "}]}