{"sha": "9415a4b712371706d7f130695fd959fddb6506cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQxNWE0YjcxMjM3MTcwNmQ3ZjEzMDY5NWZkOTU5ZmRkYjY1MDZjYw==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-12T11:10:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-12T11:10:07Z"}, "message": "Merge #561\n\n561: Handle doc comments strings r=philberty a=philberty\n\nThis adds support for inner and outer doc comments within the parser.\n\nCo-authored-by: Mark Wielaard <mark@klomp.org>", "tree": {"sha": "8a82f15833bf654a6ba2b1c13ab1c9b5cf5edf67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a82f15833bf654a6ba2b1c13ab1c9b5cf5edf67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9415a4b712371706d7f130695fd959fddb6506cc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg7CMPCRBK7hj4Ov3rIwAAYnkIAGi+g4Hhanu+CSHR+uck87Eo\nQ/X3LuW24bpIK4wejxjcwuT4TAW2PdCRlD12OoDbWTnMWyq1GbpOJ1Aj+xiegQRm\no1xLinYVYdvGnsss9Wi265mzbr9FBg5hrwx85M/Qyld/yMb75nTPwxB03Crco9GK\ngXIa/3CuWIsfUfmZFvnhTNr68E3+ehyeYae5JBv+/aYlZTsB4RpC2pd/GxZAHM/F\n+yu6nCHksQ6iLfd7QEqjA9paL9ivlCVzNNwO+y0fjsjI/9QpPqGrZuJS+Qf6oCk7\nxlx0KXWHMwlZUKoKDCELMDyarLHY4vWH8/qAH74KKoLnlmN85AHlnffTUtKWPz0=\n=gVfZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 8a82f15833bf654a6ba2b1c13ab1c9b5cf5edf67\nparent 7cecfe983b389fb05b339ea9be71ade9e016dbb9\nparent 876f70e905ac30e9517bd99d8ed898a16191c1c5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1626088207 +0000\ncommitter GitHub <noreply@github.com> 1626088207 +0000\n\nMerge #561\n\n561: Handle doc comments strings r=philberty a=philberty\n\nThis adds support for inner and outer doc comments within the parser.\n\nCo-authored-by: Mark Wielaard <mark@klomp.org>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9415a4b712371706d7f130695fd959fddb6506cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9415a4b712371706d7f130695fd959fddb6506cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9415a4b712371706d7f130695fd959fddb6506cc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cecfe983b389fb05b339ea9be71ade9e016dbb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cecfe983b389fb05b339ea9be71ade9e016dbb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cecfe983b389fb05b339ea9be71ade9e016dbb9"}, {"sha": "876f70e905ac30e9517bd99d8ed898a16191c1c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/876f70e905ac30e9517bd99d8ed898a16191c1c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/876f70e905ac30e9517bd99d8ed898a16191c1c5"}], "stats": {"total": 431, "additions": 401, "deletions": 30}, "files": [{"sha": "3e3e185b9b5945967a64ba31e0381ec28e3fc5e6", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -455,6 +455,8 @@ struct Attribute\n   // Returns whether the attribute is considered an \"empty\" attribute.\n   bool is_empty () const { return attr_input == nullptr && path.is_empty (); }\n \n+  Location get_locus () const { return locus; }\n+\n   /* e.g.:\n       #![crate_type = \"lib\"]\n       #[test]"}, {"sha": "0b8a8eae65198a880f8bf2db39e2de03b29ace69", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 198, "deletions": 16, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -265,9 +265,16 @@ Lexer::build_token ()\n \t      int next_char = peek_input (n);\n \t      if (is_whitespace (next_char))\n \t\tn++;\n-\t      else if (next_char == '/' && peek_input (n + 1) == '/')\n+\t      else if ((next_char == '/' && peek_input (n + 1) == '/'\n+\t\t\t&& peek_input (n + 2) != '!'\n+\t\t\t&& peek_input (n + 2) != '/')\n+\t\t       || (next_char == '/' && peek_input (n + 1) == '/'\n+\t\t\t   && peek_input (n + 2) == '/'\n+\t\t\t   && peek_input (n + 3) == '/'))\n \t\t{\n+\t\t  // two // or four ////\n \t\t  // A single line comment\n+\t\t  // (but not an inner or outer doc comment)\n \t\t  n += 2;\n \t\t  next_char = peek_input (n);\n \t\t  while (next_char != '\\n' && next_char != EOF)\n@@ -278,9 +285,30 @@ Lexer::build_token ()\n \t\t  if (next_char == '\\n')\n \t\t    n++;\n \t\t}\n-\t      else if (next_char == '/' && peek_input (n + 1) == '*')\n+\t      else if (next_char == '/' && peek_input (n + 1) == '*'\n+\t\t       && peek_input (n + 2) == '*'\n+\t\t       && peek_input (n + 3) == '/')\n \t\t{\n+\t\t  /**/\n+\t\t  n += 4;\n+\t\t}\n+\t      else if (next_char == '/' && peek_input (n + 1) == '*'\n+\t\t       && peek_input (n + 2) == '*' && peek_input (n + 3) == '*'\n+\t\t       && peek_input (n + 4) == '/')\n+\t\t{\n+\t\t  /***/\n+\t\t  n += 5;\n+\t\t}\n+\t      else if ((next_char == '/' && peek_input (n + 1) == '*'\n+\t\t\t&& peek_input (n + 2) != '*'\n+\t\t\t&& peek_input (n + 2) != '!')\n+\t\t       || (next_char == '/' && peek_input (n + 1) == '*'\n+\t\t\t   && peek_input (n + 2) == '*'\n+\t\t\t   && peek_input (n + 3) == '*'))\n+\t\t{\n+\t\t  // one /* or three /***\n \t\t  // Start of a block comment\n+\t\t  // (but not an inner or outer doc comment)\n \t\t  n += 2;\n \t\t  int level = 1;\n \t\t  while (level > 0)\n@@ -339,6 +367,9 @@ Lexer::build_token ()\n \t  // tell line_table that new line starts\n \t  line_map->start_line (current_line, max_column_hint);\n \t  continue;\n+\tcase '\\r': // cr\n+\t  // Ignore, we expect a newline (lf) soon.\n+\t  continue;\n \tcase ' ': // space\n \t  current_column++;\n \t  continue;\n@@ -445,11 +476,14 @@ Lexer::build_token ()\n \n \t      return Token::make (DIV_EQ, loc);\n \t    }\n-\t  else if (peek_input () == '/')\n+\t  else if ((peek_input () == '/' && peek_input (1) != '!'\n+\t\t    && peek_input (1) != '/')\n+\t\t   || (peek_input () == '/' && peek_input (1) == '/'\n+\t\t       && peek_input (2) == '/'))\n \t    {\n-\t      // TODO: single-line doc comments\n-\n+\t      // two // or four ////\n \t      // single line comment\n+\t      // (but not an inner or outer doc comment)\n \t      skip_input ();\n \t      current_column += 2;\n \n@@ -461,23 +495,85 @@ Lexer::build_token ()\n \t\t  current_char = peek_input ();\n \t\t}\n \t      continue;\n-\t      break;\n \t    }\n-\t  else if (peek_input () == '*')\n+\t  else if (peek_input () == '/'\n+\t\t   && (peek_input (1) == '!' || peek_input (1) == '/'))\n \t    {\n+\t      /* single line doc comment, inner or outer.  */\n+\t      bool is_inner = peek_input (1) == '!';\n+\t      skip_input (1);\n+\t      current_column += 3;\n+\n+\t      std::string str;\n+\t      str.reserve (32);\n+\t      current_char = peek_input ();\n+\t      while (current_char != '\\n')\n+\t\t{\n+\t\t  skip_input ();\n+\t\t  if (current_char == '\\r')\n+\t\t    {\n+\t\t      char next_char = peek_input ();\n+\t\t      if (next_char == '\\n')\n+\t\t\t{\n+\t\t\t  current_char = '\\n';\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      rust_error_at (\n+\t\t\tloc, \"Isolated CR %<\\\\r%> not allowed in doc comment\");\n+\t\t      current_char = next_char;\n+\t\t      continue;\n+\t\t    }\n+\t\t  if (current_char == EOF)\n+\t\t    {\n+\t\t      rust_error_at (\n+\t\t\tloc, \"unexpected EOF while looking for end of comment\");\n+\t\t      break;\n+\t\t    }\n+\t\t  str += current_char;\n+\t\t  current_char = peek_input ();\n+\t\t}\n+\t      skip_input ();\n+\t      current_line++;\n+\t      current_column = 1;\n+\t      // tell line_table that new line starts\n+\t      line_map->start_line (current_line, max_column_hint);\n+\n+\t      str.shrink_to_fit ();\n+\t      if (is_inner)\n+\t\treturn Token::make_inner_doc_comment (loc, std::move (str));\n+\t      else\n+\t\treturn Token::make_outer_doc_comment (loc, std::move (str));\n+\t    }\n+\t  else if (peek_input () == '*' && peek_input (1) == '*'\n+\t\t   && peek_input (2) == '/')\n+\t    {\n+\t      /**/\n+\t      skip_input (2);\n+\t      current_column += 4;\n+\t      continue;\n+\t    }\n+\t  else if (peek_input () == '*' && peek_input (1) == '*'\n+\t\t   && peek_input (2) == '*' && peek_input (3) == '/')\n+\t    {\n+\t      /***/\n+\t      skip_input (3);\n+\t      current_column += 5;\n+\t      continue;\n+\t    }\n+\t  else if ((peek_input () == '*' && peek_input (1) != '!'\n+\t\t    && peek_input (1) != '*')\n+\t\t   || (peek_input () == '*' && peek_input (1) == '*'\n+\t\t       && peek_input (2) == '*'))\n+\t    {\n+\t      // one /* or three /***\n \t      // block comment\n+\t      // (but not an inner or outer doc comment)\n \t      skip_input ();\n \t      current_column += 2;\n \n-\t      // TODO: block doc comments\n-\n-\t      current_char = peek_input ();\n-\n \t      int level = 1;\n \t      while (level > 0)\n \t\t{\n-\t\t  skip_input ();\n-\t\t  current_column++; // for error-handling\n \t\t  current_char = peek_input ();\n \n \t\t  if (current_char == EOF)\n@@ -496,6 +592,7 @@ Lexer::build_token ()\n \t\t      current_column += 2;\n \n \t\t      level += 1;\n+\t\t      continue;\n \t\t    }\n \n \t\t  // ignore until */ is found\n@@ -505,16 +602,101 @@ Lexer::build_token ()\n \t\t      skip_input (1);\n \n \t\t      current_column += 2;\n-\t\t      // should only break inner loop here - seems to do so\n-\t\t      // break;\n \n \t\t      level -= 1;\n+\t\t      continue;\n \t\t    }\n+\n+\t\t  if (current_char == '\\n')\n+\t\t    {\n+\t\t      skip_input ();\n+\t\t      current_line++;\n+\t\t      current_column = 1;\n+\t\t      // tell line_table that new line starts\n+\t\t      line_map->start_line (current_line, max_column_hint);\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  skip_input ();\n+\t\t  current_column++;\n \t\t}\n \n \t      // refresh new token\n \t      continue;\n-\t      break;\n+\t    }\n+\t  else if (peek_input () == '*'\n+\t\t   && (peek_input (1) == '!' || peek_input (1) == '*'))\n+\t    {\n+\t      // block doc comment, inner /*! or outer /**\n+\t      bool is_inner = peek_input (1) == '!';\n+\t      skip_input (1);\n+\t      current_column += 3;\n+\n+\t      std::string str;\n+\t      str.reserve (96);\n+\n+\t      int level = 1;\n+\t      while (level > 0)\n+\t\t{\n+\t\t  current_char = peek_input ();\n+\n+\t\t  if (current_char == EOF)\n+\t\t    {\n+\t\t      rust_error_at (\n+\t\t\tloc, \"unexpected EOF while looking for end of comment\");\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  // if /* found\n+\t\t  if (current_char == '/' && peek_input (1) == '*')\n+\t\t    {\n+\t\t      // skip /* characters\n+\t\t      skip_input (1);\n+\t\t      current_column += 2;\n+\n+\t\t      level += 1;\n+\t\t      str += \"/*\";\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  // ignore until */ is found\n+\t\t  if (current_char == '*' && peek_input (1) == '/')\n+\t\t    {\n+\t\t      // skip */ characters\n+\t\t      skip_input (1);\n+\t\t      current_column += 2;\n+\n+\t\t      level -= 1;\n+\t\t      if (level > 0)\n+\t\t\tstr += \"*/\";\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  if (current_char == '\\r' && peek_input (1) != '\\n')\n+\t\t    rust_error_at (\n+\t\t      loc, \"Isolated CR %<\\\\r%> not allowed in doc comment\");\n+\n+\t\t  if (current_char == '\\n')\n+\t\t    {\n+\t\t      skip_input ();\n+\t\t      current_line++;\n+\t\t      current_column = 1;\n+\t\t      // tell line_table that new line starts\n+\t\t      line_map->start_line (current_line, max_column_hint);\n+\t\t      str += '\\n';\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  str += current_char;\n+\t\t  skip_input ();\n+\t\t  current_column++;\n+\t\t}\n+\n+\t      str.shrink_to_fit ();\n+\t      if (is_inner)\n+\t\treturn Token::make_inner_doc_comment (loc, std::move (str));\n+\t      else\n+\t\treturn Token::make_outer_doc_comment (loc, std::move (str));\n \t    }\n \t  else\n \t    {"}, {"sha": "1c397c839fdbfc99e0358217bf088122639e5daa", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -151,15 +151,10 @@ enum PrimitiveCoreType\n   RS_TOKEN (RIGHT_SQUARE, \"]\")                                                 \\\n   /* Macros */                                                                 \\\n   RS_TOKEN (DOLLAR_SIGN, \"$\")                                                  \\\n-  /* Comments */                                                               \\\n-  RS_TOKEN (LINE_COMMENT, \"//\")                                                \\\n-  RS_TOKEN (INNER_LINE_DOC, \"//!\")                                             \\\n-  RS_TOKEN (OUTER_LINE_DOC, \"///\")                                             \\\n-  RS_TOKEN (BLOCK_COMMENT_START, \"/*\")                                         \\\n-  RS_TOKEN (BLOCK_COMMENT_END, \"*/\")                                           \\\n-  RS_TOKEN (INNER_BLOCK_DOC_START, \"/*!\")                                      \\\n-  RS_TOKEN (OUTER_BLOCK_DOC_START,                                             \\\n-\t    \"/**\") /* have \"weak\" union and 'static keywords? */               \\\n+  /* Doc Comments */                                                           \\\n+  RS_TOKEN (INNER_DOC_COMMENT, \"#![doc]\")                                      \\\n+  RS_TOKEN (OUTER_DOC_COMMENT, \"#[doc]\")                                       \\\n+  /* have \"weak\" union and 'static keywords? */                                \\\n                                                                                \\\n   RS_TOKEN_KEYWORD (ABSTRACT, \"abstract\") /* unused */                         \\\n   RS_TOKEN_KEYWORD (AS, \"as\")                                                  \\\n@@ -368,6 +363,18 @@ class Token\n     return TokenPtr (new Token (BYTE_STRING_LITERAL, locus, std::move (str)));\n   }\n \n+  // Makes and returns a new TokenPtr of type INNER_DOC_COMMENT.\n+  static TokenPtr make_inner_doc_comment (Location locus, std::string &&str)\n+  {\n+    return TokenPtr (new Token (INNER_DOC_COMMENT, locus, std::move (str)));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type OUTER_DOC_COMMENT.\n+  static TokenPtr make_outer_doc_comment (Location locus, std::string &&str)\n+  {\n+    return TokenPtr (new Token (OUTER_DOC_COMMENT, locus, std::move (str)));\n+  }\n+\n   // Makes and returns a new TokenPtr of type LIFETIME.\n   static TokenPtr make_lifetime (Location locus, std::string &&str)\n   {"}, {"sha": "eedc76db43ed3ea4afe2da8f2075b8138d89754a", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -434,8 +434,9 @@ Parser<ManagedTokenSource>::parse_inner_attributes ()\n   AST::AttrVec inner_attributes;\n \n   // only try to parse it if it starts with \"#!\" not only \"#\"\n-  while (lexer.peek_token ()->get_id () == HASH\n-\t && lexer.peek_token (1)->get_id () == EXCLAM)\n+  while ((lexer.peek_token ()->get_id () == HASH\n+\t  && lexer.peek_token (1)->get_id () == EXCLAM)\n+\t || lexer.peek_token ()->get_id () == INNER_DOC_COMMENT)\n     {\n       AST::Attribute inner_attr = parse_inner_attribute ();\n \n@@ -457,11 +458,33 @@ Parser<ManagedTokenSource>::parse_inner_attributes ()\n   return inner_attributes;\n }\n \n+// Parse a inner or outer doc comment into an doc attribute\n+template <typename ManagedTokenSource>\n+AST::Attribute\n+Parser<ManagedTokenSource>::parse_doc_comment ()\n+{\n+  const_TokenPtr token = lexer.peek_token ();\n+  Location locus = token->get_locus ();\n+  AST::SimplePathSegment segment (\"doc\", locus);\n+  std::vector<AST::SimplePathSegment> segments;\n+  segments.push_back (std::move (segment));\n+  AST::SimplePath attr_path (std::move (segments), false, locus);\n+  AST::LiteralExpr lit_expr (token->get_str (), AST::Literal::STRING,\n+\t\t\t     PrimitiveCoreType::CORETYPE_STR, {}, locus);\n+  std::unique_ptr<AST::AttrInput> attr_input (\n+    new AST::AttrInputLiteral (std::move (lit_expr)));\n+  lexer.skip_token ();\n+  return AST::Attribute (std::move (attr_path), std::move (attr_input), locus);\n+}\n+\n // Parse a single inner attribute.\n template <typename ManagedTokenSource>\n AST::Attribute\n Parser<ManagedTokenSource>::parse_inner_attribute ()\n {\n+  if (lexer.peek_token ()->get_id () == INNER_DOC_COMMENT)\n+    return parse_doc_comment ();\n+\n   if (lexer.peek_token ()->get_id () != HASH)\n     {\n       Error error (lexer.peek_token ()->get_locus (),\n@@ -1019,7 +1042,15 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n   switch (t->get_id ())\n     {\n     case END_OF_FILE:\n-      // not necessarily an error\n+      // not necessarily an error, unless we just read outer\n+      // attributes which needs to be attached\n+      if (!outer_attrs.empty ())\n+\t{\n+\t  Rust::AST::Attribute attr = outer_attrs.back ();\n+\t  Error error (attr.get_locus (),\n+\t\t       \"expected item after outer attribute or doc comment\");\n+\t  add_error (std::move (error));\n+\t}\n       return nullptr;\n     case PUB:\n     case MOD:\n@@ -1091,7 +1122,11 @@ Parser<ManagedTokenSource>::parse_outer_attributes ()\n {\n   AST::AttrVec outer_attributes;\n \n-  while (lexer.peek_token ()->get_id () == HASH)\n+  while (lexer.peek_token ()->get_id ()\n+\t   == HASH /* Can also be #!, which catches errors.  */\n+\t || lexer.peek_token ()->get_id () == OUTER_DOC_COMMENT\n+\t || lexer.peek_token ()->get_id ()\n+\t      == INNER_DOC_COMMENT) /* For error handling.  */\n     {\n       AST::Attribute outer_attr = parse_outer_attribute ();\n \n@@ -1121,6 +1156,20 @@ template <typename ManagedTokenSource>\n AST::Attribute\n Parser<ManagedTokenSource>::parse_outer_attribute ()\n {\n+  if (lexer.peek_token ()->get_id () == OUTER_DOC_COMMENT)\n+    return parse_doc_comment ();\n+\n+  if (lexer.peek_token ()->get_id () == INNER_DOC_COMMENT)\n+    {\n+      Error error (\n+\tlexer.peek_token ()->get_locus (),\n+\t\"inner doc (%<//!%> or %</*!%>) only allowed at start of item \"\n+\t\"and before any outer attribute or doc (%<#[%>, %<///%> or %</**%>)\");\n+      add_error (std::move (error));\n+      lexer.skip_token ();\n+      return AST::Attribute::create_empty ();\n+    }\n+\n   /* OuterAttribute -> '#' '[' Attr ']' */\n \n   if (lexer.peek_token ()->get_id () != HASH)\n@@ -1134,12 +1183,13 @@ Parser<ManagedTokenSource>::parse_outer_attribute ()\n       if (id == EXCLAM)\n \t{\n \t  // this is inner attribute syntax, so throw error\n+\t  // inner attributes were either already parsed or not allowed here.\n \t  Error error (\n \t    lexer.peek_token ()->get_locus (),\n \t    \"token %<!%> found, indicating inner attribute definition. Inner \"\n \t    \"attributes are not possible at this location\");\n \t  add_error (std::move (error));\n-\t} // TODO: are there any cases where this wouldn't be an error?\n+\t}\n       return AST::Attribute::create_empty ();\n     }\n "}, {"sha": "1cd85eae8c2e66f316368cb543304f7ab1c6a2ff", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -107,6 +107,7 @@ template <typename ManagedTokenSource> class Parser\n   AST::Attribute parse_outer_attribute ();\n   AST::Attribute parse_attribute_body ();\n   std::unique_ptr<AST::AttrInput> parse_attr_input ();\n+  AST::Attribute parse_doc_comment ();\n \n   // Path-related\n   AST::SimplePath parse_simple_path ();"}, {"sha": "cfd166ce3ec9d244892bdd6632bd2288e3b56404", "filename": "gcc/testsuite/rust/compile/bad_inner_doc.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_inner_doc.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_inner_doc.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_inner_doc.rs?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -0,0 +1,15 @@\n+pub fn main ()\n+{\n+  //! inner doc allowed\n+  let _x = 42;\n+  // { dg-error \"inner doc\" \"\" { target *-*-* } .+1 }\n+  //! inner doc disallowed\n+  mod module\n+  {\n+    /*! inner doc allowed */\n+    /// outer doc allowed\n+    // { dg-error \"inner doc\" \"\" { target *-*-* } .+1 }\n+    /*! but inner doc not here */\n+    mod x { }\n+  }\n+}"}, {"sha": "0ada77f69cf76627b43ef274c6df7b59bf0c8ebd", "filename": "gcc/testsuite/rust/compile/doc_isolated_cr_block_comment.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_block_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_block_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_block_comment.rs?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -0,0 +1,3 @@\n+// { dg-error \"Isolated CR\" \"\" { target *-*-* } .+1 }\n+/** doc cr\r comment */\n+pub fn main () { }"}, {"sha": "7db35341bee163327ceaffeb36578600ef097b80", "filename": "gcc/testsuite/rust/compile/doc_isolated_cr_inner_block_comment.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_block_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_block_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_block_comment.rs?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -0,0 +1,5 @@\n+pub fn main ()\n+{\n+// { dg-error \"Isolated CR\" \"\" { target *-*-* } .+1 }\n+  /*! doc cr\r comment */\n+}"}, {"sha": "d75da75e2189b0e1ebd255e9f849382fc53dd52d", "filename": "gcc/testsuite/rust/compile/doc_isolated_cr_inner_line_comment.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_line_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_line_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_inner_line_comment.rs?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -0,0 +1,5 @@\n+pub fn main ()\n+{\n+// { dg-error \"Isolated CR\" \"\" { target *-*-* } .+1 }\n+  //! doc cr\r comment\n+}"}, {"sha": "7b6ef989c308ad9f658c19163d40d7f7dfce7867", "filename": "gcc/testsuite/rust/compile/doc_isolated_cr_line_comment.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_line_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_line_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdoc_isolated_cr_line_comment.rs?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -0,0 +1,3 @@\n+// { dg-error \"Isolated CR\" \"\" { target *-*-* } .+1 }\n+/// doc cr\r comment\n+pub fn main () { }"}, {"sha": "ab38ac696105dd4a3c19e6421b00f9fa697ca494", "filename": "gcc/testsuite/rust/compile/torture/all_doc_comment_line_blocks.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks.rs?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -0,0 +1,47 @@\n+// comment line not a doc\n+/* comment block not a doc                   */\n+\n+//! inner line comment for most outer crate\n+/*! inner block comment for most outer crate */\n+\n+// comment line not a doc\n+/* comment block not a doc                   */\n+\n+/// outer doc line for module\n+/** outer doc block for module               */\n+pub mod module\n+{\n+  //!  inner line doc\n+  //!! inner line doc!\n+  /*!  inner block doc  */\n+  /*!! inner block doc! */\n+\n+  //   line comment\n+  ///  outer line doc\n+  //// line comment\n+\n+  /*   block comment   */\n+  /**  outer block doc */\n+  /*** block comment   */\n+\n+  mod block_doc_comments\n+  {\n+    /*   /* */  /** */  /*! */  */\n+    /*!  /* */  /** */  /*! */  */\n+    /**  /* */  /** */  /*! */  */\n+    mod item { }\n+  }\n+\n+  pub mod empty\n+  {\n+    //!\n+    /*!*/\n+    //\n+\n+    ///\n+    mod doc { }\n+    /**/\n+    /***/\n+  }\n+}\n+pub fn main () { }"}, {"sha": "3ea2cd01c8cf7961783d259cc52de00ccd633cb8", "filename": "gcc/testsuite/rust/compile/torture/all_doc_comment_line_blocks_crlf.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks_crlf.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks_crlf.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fall_doc_comment_line_blocks_crlf.rs?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -0,0 +1,47 @@\n+// comment line not a doc\r\n+/* comment block not a doc                   */\r\n+\r\n+//! inner line comment for most outer crate\r\n+/*! inner block comment for most outer crate */\r\n+\r\n+// comment line not a doc\r\n+/* comment block not a doc                   */\r\n+\r\n+/// outer doc line for module\r\n+/** outer doc block for module               */\r\n+pub mod module\r\n+{\r\n+  //!  inner line doc\r\n+  //!! inner line doc!\r\n+  /*!  inner block doc  */\r\n+  /*!! inner block doc! */\r\n+\r\n+  //   line comment\r\n+  ///  outer line doc\r\n+  //// line comment\r\n+\r\n+  /*   block comment   */\r\n+  /**  outer block doc */\r\n+  /*** block comment   */\r\n+\r\n+  mod block_doc_comments\r\n+  {\r\n+    /*   /* */  /** */  /*! */  */\r\n+    /*!  /* */  /** */  /*! */  */\r\n+    /**  /* */  /** */  /*! */  */\r\n+    mod item { }\r\n+  }\r\n+\r\n+  pub mod empty\r\n+  {\r\n+    //!\r\n+    /*!*/\r\n+    //\r\n+\r\n+    ///\r\n+    mod doc { }\r\n+    /**/\r\n+    /***/\r\n+  }\r\n+}\r\n+pub fn main () { }\r"}, {"sha": "9a1e090f330f1ecc3a79493b952f30b35c3afc79", "filename": "gcc/testsuite/rust/compile/torture/isolated_cr_block_comment.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_block_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_block_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_block_comment.rs?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -0,0 +1,2 @@\n+/* comment cr\r is allowed */\n+pub fn main () { }"}, {"sha": "4e921a225c27baddc346e7a83fc6e8eb43ef61e0", "filename": "gcc/testsuite/rust/compile/torture/isolated_cr_line_comment.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_line_comment.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9415a4b712371706d7f130695fd959fddb6506cc/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_line_comment.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fisolated_cr_line_comment.rs?ref=9415a4b712371706d7f130695fd959fddb6506cc", "patch": "@@ -0,0 +1,2 @@\n+// comment cr\r is allowed\n+pub fn main () { }"}]}