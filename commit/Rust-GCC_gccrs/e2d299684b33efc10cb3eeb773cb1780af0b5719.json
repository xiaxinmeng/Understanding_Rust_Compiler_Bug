{"sha": "e2d299684b33efc10cb3eeb773cb1780af0b5719", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJkMjk5Njg0YjMzZWZjMTBjYjNlZWI3NzNjYjE3ODBhZjBiNTcxOQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-10-02T07:17:01Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-10-02T07:17:01Z"}, "message": "re PR fortran/31154 (IMPORT fails for  \"<imported symbol> FUNCTION (...)\" kind of procedures)\n\n2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31154\n\tPR fortran/31229\n\tPR fortran/33334\n\t* decl.c : Declare gfc_function_kind_locs and\n\tgfc_function_type_locus.\n\t(gfc_match_kind_spec): Add second argument kind_expr_only.\n\tStore locus before trying to match the expression. If the\n\tcurrent state corresponds to a function declaration and there\n\tis no match to the expression, read to the parenthesis, return\n\tkind = -1, dump the expression and return.\n\t(gfc_match_type_spec): Renamed from match_type_spec and all\n\treferences changed.  If an interface or an external function,\n\tstore the locus, set kind = -1 and return.  Otherwise, if kind\n\tis already = -1, use gfc_find_symbol to try to find a use\n\tassociated or imported type.\n\tmatch.h : Prototype for gfc_match_type_spec.\n\t* parse.c (match_deferred_characteristics): New function.\n\t(parse_spec): If in a function, statement is USE or IMPORT\n\tor DERIVED_DECL and the function kind=-1, call\n\tmatch_deferred_characteristics.  If kind=-1 at the end of the\n\tspecification expressions, this is an error.\n\t* parse.h : Declare external gfc_function_kind_locs and\n\tgfc_function_type_locus.\n\n2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31154\n\tPR fortran/31229\n\tPR fortran/33334\n\t* gfortran.dg/function_kinds_1.f90: New test.\n\t* gfortran.dg/function_kinds_2.f90: New test.\n\t* gfortran.dg/derived_function_interface_1.f90: Correct illegal\n\tuse association into interfaces.\n\nFrom-SVN: r128948", "tree": {"sha": "26f64a0d0161584dc4242168347be17a7d00656a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26f64a0d0161584dc4242168347be17a7d00656a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2d299684b33efc10cb3eeb773cb1780af0b5719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2d299684b33efc10cb3eeb773cb1780af0b5719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2d299684b33efc10cb3eeb773cb1780af0b5719", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2d299684b33efc10cb3eeb773cb1780af0b5719/comments", "author": null, "committer": null, "parents": [{"sha": "c052733d54a2fba0583cb5c17522cdd662b5fad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c052733d54a2fba0583cb5c17522cdd662b5fad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c052733d54a2fba0583cb5c17522cdd662b5fad4"}], "stats": {"total": 322, "additions": 300, "deletions": 22}, "files": [{"sha": "d6ae6dc7178adefc1c5189d6780f02f803aabd82", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e2d299684b33efc10cb3eeb773cb1780af0b5719", "patch": "@@ -1,3 +1,29 @@\n+2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31154\n+\tPR fortran/31229\n+\tPR fortran/33334\n+\t* decl.c : Declare gfc_function_kind_locs and\n+\tgfc_function_type_locus.\n+\t(gfc_match_kind_spec): Add second argument kind_expr_only.\n+\tStore locus before trying to match the expression. If the\n+\tcurrent state corresponds to a function declaration and there\n+\tis no match to the expression, read to the parenthesis, return\n+\tkind = -1, dump the expression and return.\n+\t(gfc_match_type_spec): Renamed from match_type_spec and all\n+\treferences changed.  If an interface or an external function,\n+\tstore the locus, set kind = -1 and return.  Otherwise, if kind\n+\tis already = -1, use gfc_find_symbol to try to find a use\n+\tassociated or imported type.\n+\tmatch.h : Prototype for gfc_match_type_spec.\n+\t* parse.c (match_deferred_characteristics): New function.\n+\t(parse_spec): If in a function, statement is USE or IMPORT\n+\tor DERIVED_DECL and the function kind=-1, call\n+\tmatch_deferred_characteristics.  If kind=-1 at the end of the\n+\tspecification expressions, this is an error.\n+\t* parse.h : Declare external gfc_function_kind_locs and\n+\tgfc_function_type_locus.\n+\n 2007-09-27  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* module.c (mio_expr): Avoid -Wcast-qual warning."}, {"sha": "e25389f94bea30e42b868c1836e232b9931ed75d", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 78, "deletions": 17, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=e2d299684b33efc10cb3eeb773cb1780af0b5719", "patch": "@@ -78,6 +78,9 @@ static enumerator_history *max_enum = NULL;\n \n gfc_symbol *gfc_new_block;\n \n+locus gfc_function_kind_locus;\n+locus gfc_function_type_locus;\n+\n \n /********************* DATA statement subroutines *********************/\n \n@@ -1762,17 +1765,21 @@ gfc_match_old_kind_spec (gfc_typespec *ts)\n    string is found, then we know we have an error.  */\n \n match\n-gfc_match_kind_spec (gfc_typespec *ts)\n+gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n {\n-  locus where;\n+  locus where, loc;\n   gfc_expr *e;\n   match m, n;\n   const char *msg;\n \n   m = MATCH_NO;\n+  n = MATCH_YES;\n   e = NULL;\n \n-  where = gfc_current_locus;\n+  where = loc = gfc_current_locus;\n+\n+  if (kind_expr_only)\n+    goto kind_expr;\n \n   if (gfc_match_char ('(') == MATCH_NO)\n     return MATCH_NO;\n@@ -1781,11 +1788,42 @@ gfc_match_kind_spec (gfc_typespec *ts)\n   if (gfc_match (\" kind = \") == MATCH_YES)\n     m = MATCH_ERROR;\n \n+  loc = gfc_current_locus;\n+\n+kind_expr:\n   n = gfc_match_init_expr (&e);\n-  if (n == MATCH_NO)\n-    gfc_error (\"Expected initialization expression at %C\");\n+\n   if (n != MATCH_YES)\n-    return MATCH_ERROR;\n+    {\n+      if (gfc_current_state () == COMP_INTERFACE\n+            || gfc_current_state () == COMP_NONE\n+            || gfc_current_state () == COMP_CONTAINS)\n+\t{\n+\t  /* Signal using kind = -1 that the expression might include\n+\t     use associated or imported parameters and try again after\n+\t     the specification expressions.....  */\n+\t  if (gfc_match_char (')') != MATCH_YES)\n+\t    {\n+\t      gfc_error (\"Missing right parenthesis at %C\");\n+\t      m = MATCH_ERROR;\n+\t      goto no_match;\n+\t    }\n+\n+\t  gfc_free_expr (e);\n+\t  ts->kind = -1;\n+\t  gfc_function_kind_locus = loc;\n+\t  gfc_undo_symbols ();\n+\t  return MATCH_YES;\n+\t}\n+      else\n+\t{\n+\t  /* ....or else, the match is real.  */\n+\t  if (n == MATCH_NO)\n+\t    gfc_error (\"Expected initialization expression at %C\");\n+\t  if (n != MATCH_YES)\n+\t    return MATCH_ERROR;\n+\t}\n+    }\n \n   if (e->rank != 0)\n     {\n@@ -1826,7 +1864,7 @@ gfc_match_kind_spec (gfc_typespec *ts)\n   else if (gfc_match_char (')') != MATCH_YES)\n     {\n       gfc_error (\"Missing right parenthesis at %C\");\n-     m = MATCH_ERROR;\n+      m = MATCH_ERROR;\n     }\n   else\n      /* All tests passed.  */\n@@ -2033,13 +2071,14 @@ match_char_spec (gfc_typespec *ts)\n    kind specification.  Not doing so is needed for matching an IMPLICIT\n    statement correctly.  */\n \n-static match\n-match_type_spec (gfc_typespec *ts, int implicit_flag)\n+match\n+gfc_match_type_spec (gfc_typespec *ts, int implicit_flag)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n   match m;\n   int c;\n+  locus loc = gfc_current_locus;\n \n   gfc_clear_ts (ts);\n \n@@ -2123,12 +2162,34 @@ match_type_spec (gfc_typespec *ts, int implicit_flag)\n   if (m != MATCH_YES)\n     return m;\n \n-  /* Search for the name but allow the components to be defined later.  */\n-  if (gfc_get_ha_symbol (name, &sym))\n+  if (gfc_current_state () == COMP_INTERFACE\n+\t|| gfc_current_state () == COMP_NONE)\n+    {\n+      gfc_function_type_locus = loc;\n+      ts->type = BT_UNKNOWN;\n+      ts->kind = -1;\n+      return MATCH_YES;\n+    }\n+\n+  /* Search for the name but allow the components to be defined later.  If\n+     type = -1, this typespec has been seen in a function declaration but\n+     the type could not legally be accessed at that point.  */\n+  if (ts->kind != -1 && gfc_get_ha_symbol (name, &sym))\n     {\n       gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n       return MATCH_ERROR;\n     }\n+  else if (ts->kind == -1)\n+    {\n+      if (gfc_find_symbol (name, NULL, 0, &sym))\n+\t{       \n+\t  gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      if (sym == NULL)\n+\treturn MATCH_NO;\n+    }\n \n   if (sym->attr.flavor != FL_DERIVED\n       && gfc_add_flavor (&sym->attr, FL_DERIVED, sym->name, NULL) == FAILURE)\n@@ -2154,7 +2215,7 @@ match_type_spec (gfc_typespec *ts, int implicit_flag)\n        return MATCH_NO;\n     }\n \n-  m = gfc_match_kind_spec (ts);\n+  m = gfc_match_kind_spec (ts, false);\n   if (m == MATCH_NO && ts->type != BT_CHARACTER)\n     m = gfc_match_old_kind_spec (ts);\n \n@@ -2301,7 +2362,7 @@ gfc_match_implicit (void)\n       gfc_clear_new_implicit ();\n \n       /* A basic type is mandatory here.  */\n-      m = match_type_spec (&ts, 1);\n+      m = gfc_match_type_spec (&ts, 1);\n       if (m == MATCH_ERROR)\n \tgoto error;\n       if (m == MATCH_NO)\n@@ -2344,7 +2405,7 @@ gfc_match_implicit (void)\n \tm = match_char_spec (&ts);\n       else\n \t{\n-\t  m = gfc_match_kind_spec (&ts);\n+\t  m = gfc_match_kind_spec (&ts, false);\n \t  if (m == MATCH_NO)\n \t    {\n \t      m = gfc_match_old_kind_spec (&ts);\n@@ -3390,7 +3451,7 @@ gfc_match_data_decl (void)\n \n   num_idents_on_line = 0;\n   \n-  m = match_type_spec (&current_ts, 0);\n+  m = gfc_match_type_spec (&current_ts, 0);\n   if (m != MATCH_YES)\n     return m;\n \n@@ -3492,7 +3553,7 @@ match_prefix (gfc_typespec *ts)\n \n loop:\n   if (!seen_type && ts != NULL\n-      && match_type_spec (ts, 0) == MATCH_YES\n+      && gfc_match_type_spec (ts, 0) == MATCH_YES\n       && gfc_match_space () == MATCH_YES)\n     {\n \n@@ -3798,7 +3859,7 @@ match_procedure_decl (void)\n \n   /* Get the type spec. for the procedure interface.  */\n   old_loc = gfc_current_locus;\n-  m = match_type_spec (&current_ts, 0);\n+  m = gfc_match_type_spec (&current_ts, 0);\n   if (m == MATCH_YES || (m == MATCH_NO && gfc_peek_char () == ')'))\n     goto got_ts;\n "}, {"sha": "f9d6aea7010a7993cf74eead2ca0e8df09c00377", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=e2d299684b33efc10cb3eeb773cb1780af0b5719", "patch": "@@ -127,8 +127,9 @@ match gfc_match_omp_end_single (void);\n \n match gfc_match_data (void);\n match gfc_match_null (gfc_expr **);\n-match gfc_match_kind_spec (gfc_typespec *);\n+match gfc_match_kind_spec (gfc_typespec *, bool);\n match gfc_match_old_kind_spec (gfc_typespec *);\n+match gfc_match_type_spec (gfc_typespec *, int);\n \n match gfc_match_end (gfc_statement *);\n match gfc_match_data_decl (void);"}, {"sha": "86e486c917e86daf5e77358a6c527be183caaa8a", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=e2d299684b33efc10cb3eeb773cb1780af0b5719", "patch": "@@ -1866,6 +1866,35 @@ parse_interface (void)\n }\n \n \n+/* Recover use associated or imported function characteristics.  */\n+\n+static try\n+match_deferred_characteristics (gfc_typespec * ts)\n+{\n+  locus loc;\n+  match m;\n+\n+  loc = gfc_current_locus;\n+\n+  if (gfc_current_block ()->ts.type != BT_UNKNOWN)\n+    {\n+      /* Kind expression for an intrinsic type.  */\n+      gfc_current_locus = gfc_function_kind_locus;\n+      m = gfc_match_kind_spec (ts, true);\n+    }\n+  else\n+    {\n+      /* A derived type.  */\n+      gfc_current_locus = gfc_function_type_locus;\n+      m = gfc_match_type_spec (ts, 0);\n+    }\n+\n+  gfc_current_ns->proc_name->result->ts = *ts;\n+  gfc_current_locus =loc;\n+  return m;\n+}\n+\n+\n /* Parse a set of specification statements.  Returns the statement\n    that doesn't fit.  */\n \n@@ -1951,6 +1980,15 @@ parse_spec (gfc_statement st)\n \t}\n \n       accept_statement (st);\n+\n+      /* Look out for function kind/type information that used\n+\t use associated or imported parameter.  This is signalled\n+\t by kind = -1.  */\n+      if (gfc_current_state () == COMP_FUNCTION\n+\t    && (st == ST_USE || st == ST_IMPORT || st == ST_DERIVED_DECL)\n+\t    && gfc_current_block ()->ts.kind == -1)\n+\tmatch_deferred_characteristics (&gfc_current_block ()->ts);\n+\n       st = next_statement ();\n       goto loop;\n \n@@ -1964,6 +2002,19 @@ parse_spec (gfc_statement st)\n       break;\n     }\n \n+  /* If we still have kind = -1 at the end of the specification block,\n+     then there is an error. */\n+  if (gfc_current_state () == COMP_FUNCTION\n+\t&& gfc_current_block ()->ts.kind == -1)\n+    {\n+      if (gfc_current_block ()->ts.type != BT_UNKNOWN)\n+\tgfc_error (\"Bad kind expression for function '%s' at %L\",\n+\t\t   gfc_current_block ()->name, &gfc_function_kind_locus);\n+      else\n+\tgfc_error (\"The type for function '%s' at %L is not accessible\",\n+\t\t   gfc_current_block ()->name, &gfc_function_type_locus);\n+    }\n+\n   return st;\n }\n "}, {"sha": "307d59a0ff8b6714cd69cfd1a7d910ee6fb7eadc", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=e2d299684b33efc10cb3eeb773cb1780af0b5719", "patch": "@@ -66,5 +66,7 @@ const char *gfc_ascii_statement (gfc_statement);\n match gfc_match_enum (void);\n match gfc_match_enumerator_def (void);\n void gfc_free_enum_history (void);\n+extern locus gfc_function_kind_locus;\n+extern locus gfc_function_type_locus;\n \n #endif  /* GFC_PARSE_H  */"}, {"sha": "1cc26f816a5e2b2c4e26a16f3689290e5792b2f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e2d299684b33efc10cb3eeb773cb1780af0b5719", "patch": "@@ -1,3 +1,13 @@\n+2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31154\n+\tPR fortran/31229\n+\tPR fortran/33334\n+\t* gfortran.dg/function_kinds_1.f90: New test.\n+\t* gfortran.dg/function_kinds_2.f90: New test.\n+\t* gfortran.dg/derived_function_interface_1.f90: Correct illegal\n+\tuse association into interfaces.\n+\n 2007-10-01  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR testsuite/31828"}, {"sha": "a9e404182f646363efb916daeddf0017b1335885", "filename": "gcc/testsuite/gfortran.dg/derived_function_interface_1.f90", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_function_interface_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_function_interface_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_function_interface_1.f90?ref=e2d299684b33efc10cb3eeb773cb1780af0b5719", "patch": "@@ -6,24 +6,28 @@\n !\n ! Contributed by Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n !\n-type(foo) function ext_fun()\n+module kinds\n   type foo\n     integer :: i\n   end type foo\n+end module\n+\n+type(foo) function ext_fun()\n+  use kinds\n   ext_fun%i = 1\n end function ext_fun\n \n-  type foo\n-    integer :: i\n-  end type foo\n+  use kinds\n \n   interface fun_interface\n     type(foo) function fun()\n+      use kinds\n     end function fun\n   end interface\n \n   interface ext_fun_interface\n     type(foo) function ext_fun()\n+      use kinds\n     end function ext_fun\n   end interface\n \n@@ -38,3 +42,4 @@ type(foo) function fun() ! { dg-error \"already has an explicit interface\" }\n   end function fun  ! { dg-error \"Expecting END PROGRAM\" }\n \n end ! { dg-warning \"CONTAINS statement without FUNCTION or SUBROUTINE statement\" }\n+! { dg-final { cleanup-modules \"kinds\" } }"}, {"sha": "f0140df0620ce96fd8719ab1b3cac43bb097023e", "filename": "gcc/testsuite/gfortran.dg/function_kinds_1.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_1.f90?ref=e2d299684b33efc10cb3eeb773cb1780af0b5719", "patch": "@@ -0,0 +1,54 @@\n+! { dg-do run }\n+! Tests the fix for PR31229, PR31154 and PR33334, in which\n+! the KIND and TYPE parameters in the function declarations\n+! would cause errors.\n+!\n+! Contributed by Brooks Moses <brooks@gcc.gnu.org>\n+!           and Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module kinds\n+  implicit none\n+  integer, parameter :: dp = selected_real_kind(6)\n+  type t\n+     integer :: i\n+  end type t\n+  interface\n+    real(dp) function y()\n+      import\n+    end function\n+  end interface\n+end module kinds\n+\n+type(t) function func() ! The legal bit of PR33334\n+  use kinds\n+  func%i = 5\n+end function func\n+\n+real(dp) function another_dp_before_defined ()\n+  use kinds\n+  another_dp_before_defined = real (kind (4.0_DP))\n+end function\n+\n+module mymodule;\n+contains\n+  REAL(2*DP) function declared_dp_before_defined()\n+    use kinds, only: dp\n+    real (dp) :: x\n+    declared_dp_before_defined = 1.0_dp\n+    x = 1.0_dp\n+    declared_dp_before_defined = real (kind (x))\n+  end function\n+end module mymodule\n+\n+  use kinds\n+  use mymodule\n+  type(t), external :: func\n+  type(t) :: z\n+  if (kind (y ()) .ne. 4) call abort ()\n+  if (kind (declared_dp_before_defined ()) .ne. 8) call abort ()\n+  if (int (declared_dp_before_defined ()) .ne. 4) call abort ()\n+  if (int (another_dp_before_defined ()) .ne. 4) call abort ()\n+  z = func()\n+  if (z%i .ne. 5) call abort ()\n+end\n+! { dg-final { cleanup-modules \"kinds mymodule\" } }"}, {"sha": "f14453df9b2e67ae128cce9b011107cc92ba3b5a", "filename": "gcc/testsuite/gfortran.dg/function_kinds_2.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_kinds_2.f90?ref=e2d299684b33efc10cb3eeb773cb1780af0b5719", "patch": "@@ -0,0 +1,21 @@\n+! Tests the fix for PR33334, in which the TYPE in the function\n+! declaration cannot be legally accessed.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module types\n+ implicit none\n+ type t\n+   integer :: i = 99\n+ end type t\n+end module\n+\n+module x\n+ use types\n+ interface\n+   type(t) function bar() ! { dg-error \"is not accessible\" }\n+   end function\n+ end interface\n+end module\n+! { dg-final { cleanup-modules \"types x\" } }\n+"}, {"sha": "0fad1b8f3feadf3c305788bcec13514a61863b71", "filename": "gcc/testsuite/gfortran.dg/intent_out_2.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d299684b33efc10cb3eeb773cb1780af0b5719/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_2.f90?ref=e2d299684b33efc10cb3eeb773cb1780af0b5719", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do -run }\r\n+! Tests the fix for PR33554, in which the default initialization\n+! of temp, in construct_temp, caused a segfault because it was\n+! being done before the array offset and lower bound were\n+! available.\n+!\n+! Contributed by Harald Anlauf <anlauf@gmx.de> \n+!\r\n+module gfcbug72\r\n+  implicit none\r\n+\r\n+  type t_datum\r\n+    character(len=8) :: mn = 'abcdefgh'\r\n+  end type t_datum\r\n+\r\n+  type t_temp\r\n+    type(t_datum) :: p\r\n+  end type t_temp\r\n+\r\n+contains\r\n+\r\n+  subroutine setup ()\r\n+    integer :: i\r\n+    type (t_temp), pointer :: temp(:) => NULL ()\r\n+\r\n+    do i=1,2\r\n+       allocate (temp (2))\r\n+       call construct_temp (temp)\r\n+       if (any (temp % p% mn .ne. 'ijklmnop')) call abort ()\r\n+       deallocate (temp)\r\n+    end do\r\n+  end subroutine setup\r\n+  !--\r\n+  subroutine construct_temp (temp)\r\n+    type (t_temp), intent(out) :: temp (:)\r\n+    if (any (temp % p% mn .ne. 'abcdefgh')) call abort ()\r\n+    temp(:)% p% mn = 'ijklmnop'\r\n+  end subroutine construct_temp\r\n+end module gfcbug72\r\n+\r\n+program test\r\n+  use gfcbug72\r\n+  implicit none\r\n+  call setup ()\r\n+end program test\r\n+! { dg-final { cleanup-modules \"gfcbug72\" } }\n+\r"}]}