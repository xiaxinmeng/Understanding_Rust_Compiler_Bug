{"sha": "79af883cd48fbd3267a319c8d89aefc2ed129516", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlhZjg4M2NkNDhmYmQzMjY3YTMxOWM4ZDg5YWVmYzJlZDEyOTUxNg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-11-22T11:59:59Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-11-22T11:59:59Z"}, "message": "Makefile.in: Rebuilt.\n\n2000-11-22  Bryce McKinlay  <bryce@albatross.co.nz>\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (core_java_source_files): Added Collections.java.\n\t* java/util/List.java: Merged from classpath.\n\t* java/util/Vector.java: Ditto.\n\t* java/util/Collections.java: From classpath.\n\t* java/util/ArrayList.java (addAll(Collection)): Call\n\taddAll(int,Collection) instead of duplicating code.\n\t(indexOf): Clean up int initialization.\n\t(clear): Set cleared array entries to null, to allow garbage\n\tcollection.\n\t* java/util/List.java: Minor formatting fixes.\n\t* java/util/SimpleTimeZone.java: ditto.\n\nFrom-SVN: r37652", "tree": {"sha": "9f0271f14f274b6e8dc112c3c88edbeb6d136806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f0271f14f274b6e8dc112c3c88edbeb6d136806"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79af883cd48fbd3267a319c8d89aefc2ed129516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79af883cd48fbd3267a319c8d89aefc2ed129516", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79af883cd48fbd3267a319c8d89aefc2ed129516", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79af883cd48fbd3267a319c8d89aefc2ed129516/comments", "author": null, "committer": null, "parents": [{"sha": "e9905e2d9d42a818ec671da242e56c44a14baac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9905e2d9d42a818ec671da242e56c44a14baac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9905e2d9d42a818ec671da242e56c44a14baac5"}], "stats": {"total": 3245, "additions": 2824, "deletions": 421}, "files": [{"sha": "d8481b20c3aa1bc2cf0625baa02f834988d20d46", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=79af883cd48fbd3267a319c8d89aefc2ed129516", "patch": "@@ -1,3 +1,18 @@\n+2000-11-22  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (core_java_source_files): Added Collections.java.\n+\t* java/util/List.java: Merged from classpath.\n+\t* java/util/Vector.java: Ditto.\t\n+\t* java/util/Collections.java: From classpath.\n+\t* java/util/ArrayList.java (addAll(Collection)): Call \n+\taddAll(int,Collection) instead of duplicating code.\n+\t(indexOf): Clean up int initialization.\n+\t(clear): Set cleared array entries to null, to allow garbage \n+\tcollection.\n+\t* java/util/List.java: Minor formatting fixes.\t\n+\t* java/util/SimpleTimeZone.java: ditto.\n+\t\n 2000-11-18  Tom Tromey  <tromey@cygnus.com>\n \n \t* Makefile.in: Rebuilt."}, {"sha": "c8e6f07020f199a2aeb210eb6241690e45706694", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=79af883cd48fbd3267a319c8d89aefc2ed129516", "patch": "@@ -929,6 +929,7 @@ java/util/BitSet.java \\\n java/util/Bucket.java \\\n java/util/Calendar.java\t\\\n java/util/Collection.java \\\n+java/util/Collections.java \\\n java/util/Comparator.java \\\n java/util/ConcurrentModificationException.java \\\n java/util/Date.java \\"}, {"sha": "fe3d641a65bbe71b8a1e341ab8daf312d4c24911", "filename": "libjava/Makefile.in", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=79af883cd48fbd3267a319c8d89aefc2ed129516", "patch": "@@ -119,43 +119,29 @@ here = @here@\n libgcj_basedir = @libgcj_basedir@\n \n AUTOMAKE_OPTIONS = foreign no-installinfo\n-@TESTSUBDIR_TRUE@SUBDIRS = \\\n-@TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n-@TESTSUBDIR_FALSE@SUBDIRS = \\\n-@TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n-@USE_LIBDIR_TRUE@toolexeclibdir = \\\n-@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = \\\n-@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = \\\n-@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n-@NO_X_TRUE@cond_x_ltlibrary = \\\n-@NO_X_FALSE@cond_x_ltlibrary = \\\n-@NO_X_FALSE@libgcjx.la\n+@TESTSUBDIR_TRUE@SUBDIRS = @TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n+@TESTSUBDIR_FALSE@SUBDIRS = @TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n+@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@NO_X_TRUE@cond_x_ltlibrary = \n+@NO_X_FALSE@cond_x_ltlibrary = @NO_X_FALSE@libgcjx.la\n \n toolexeclib_LTLIBRARIES = libgcj.la $(cond_x_ltlibrary)\n toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.zip\n \n-@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.a\n-@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.c\n+@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = @NEEDS_DATA_START_TRUE@libgcjdata.a\n+@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = @NEEDS_DATA_START_TRUE@libgcjdata.c\n \n-@NATIVE_TRUE@bin_PROGRAMS = \\\n-@NATIVE_TRUE@jv-convert gij\n+@NATIVE_TRUE@bin_PROGRAMS = @NATIVE_TRUE@jv-convert gij\n \n bin_SCRIPTS = addr2name.awk\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@zip\n-@CANADIAN_FALSE@ZIP = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n-@CANADIAN_TRUE@GCJH = \\\n-@CANADIAN_TRUE@gcjh\n-@CANADIAN_FALSE@GCJH = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_FALSE@zip\n+@CANADIAN_FALSE@ZIP = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = @CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n \n GCJCOMPILE = $(LIBTOOL) --tag=GCJ --mode=compile $(GCJ) -fassume-compiled -fclasspath=$(here) -L$(here) $(JC1FLAGS) -MD -MT $@ -MF $(@:.lo=.d) -c\n GCJLINK = $(LIBTOOL) --mode=link $(GCJ) -L$(here) $(JC1FLAGS) $(LDFLAGS) -o $@\n@@ -170,10 +156,8 @@ AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fasynchronous-exceptions \\\n \t-fdollars-in-identifiers \\\n \t@LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE\n \n-@USING_GCC_TRUE@AM_CFLAGS = \\\n-@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n-@USING_GCC_FALSE@AM_CFLAGS = \\\n-@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+@USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n \n JCFLAGS = -g\n JC1FLAGS = -g @LIBGCJ_JAVAFLAGS@\n@@ -240,8 +224,7 @@ extra_headers = java/lang/Object.h java/lang/Class.h\n \n NM = nm\n \n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n \n CONVERT_DIR = gnu/gcj/convert\n \n@@ -695,6 +678,7 @@ java/util/BitSet.java \\\n java/util/Bucket.java \\\n java/util/Calendar.java\t\\\n java/util/Collection.java \\\n+java/util/Collections.java \\\n java/util/Comparator.java \\\n java/util/ConcurrentModificationException.java \\\n java/util/Date.java \\\n@@ -1180,7 +1164,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -1653,7 +1637,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/Arrays.P .deps/java/util/BasicMapEntry.P \\\n .deps/java/util/BitSet.P .deps/java/util/Bucket.P \\\n .deps/java/util/Calendar.P .deps/java/util/Collection.P \\\n-.deps/java/util/Comparator.P \\\n+.deps/java/util/Collections.P .deps/java/util/Comparator.P \\\n .deps/java/util/ConcurrentModificationException.P \\\n .deps/java/util/Date.P .deps/java/util/Dictionary.P \\\n .deps/java/util/EmptyStackException.P .deps/java/util/Enumeration.P \\\n@@ -2070,7 +2054,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "ef7d6e5f7d38a0531db1166623ddafa431feab4f", "filename": "libjava/java/util/ArrayList.java", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2Fjava%2Futil%2FArrayList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2Fjava%2Futil%2FArrayList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FArrayList.java?ref=79af883cd48fbd3267a319c8d89aefc2ed129516", "patch": "@@ -43,7 +43,7 @@\n  * to or removing from the end of a list, checking the size, &c.\n  *\n  * @author        Jon A. Zeppieri\n- * @version       $Id: ArrayList.java,v 1.2 2000/10/29 05:06:10 bryce Exp $\n+ * @version       $Id: ArrayList.java,v 1.3 2000/11/02 10:08:03 bryce Exp $\n  * @see           java.util.AbstractList\n  * @see           java.util.List\n  */\n@@ -219,15 +219,7 @@ public void add(int index, Object e)\n    */\n   public boolean addAll(Collection c)\n   {\n-    modCount++;\n-    Iterator itr = c.iterator();\n-    int csize = c.size();\n-    ensureCapacity(size + csize);\n-    for (int pos = 0; pos < csize; pos++)\n-      {\n-\tdata[size++] = itr.next();\n-      }\n-    return (csize > 0);\n+    return addAll(size, c);\n   }\n \n   /** \n@@ -295,9 +287,7 @@ public boolean contains(Object e)\n    */\n   public int indexOf(Object e)\n   {\n-    int i;\n-\n-    for (i = 0; i < size; i++)\n+    for (int i = 0; i < size; i++)\n       {\n \tif (e == null ? data[i] == null : e.equals(data[i]))\n \t  return i;\n@@ -330,6 +320,10 @@ public int lastIndexOf(Object e)\n   public void clear()\n   {\n     modCount++;\n+    for (int i = 0; i < size; i++)\n+      {\n+\tdata[i] = null;\n+      }    \n     size = 0;\n   }\n \n@@ -364,8 +358,8 @@ public Object[] toArray()\n   }\n \n   /**\n-   * Returns an Array whse component type is the runtime component type of\n-   * the passes-in Array.  The returned Array is populated with all of the\n+   * Returns an Array whose component type is the runtime component type of\n+   * the passed-in Array.  The returned Array is populated with all of the\n    * elements in this ArrayList.  If the passed-in Array is not large enough\n    * to store all of the elements in this List, a new Array will be created \n    * and returned; if the passed-in Array is <i>larger</i> than the size"}, {"sha": "a827071ef26b27e308aafc32456d9844c0b6076e", "filename": "libjava/java/util/Collections.java", "status": "added", "additions": 1829, "deletions": 0, "changes": 1829, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2Fjava%2Futil%2FCollections.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2Fjava%2Futil%2FCollections.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCollections.java?ref=79af883cd48fbd3267a319c8d89aefc2ed129516", "patch": "@@ -0,0 +1,1829 @@\n+/* Collections.java -- Utility class with methods to operate on collections\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+// TO DO:\n+// ~ Serialization is very much broken. Blame Sun for not specifying it.\n+// ~ The synchronized* and unmodifiable* methods don't have doc-comments.\n+\n+package java.util;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Utility class consisting of static methods that operate on, or return\n+ * Collections. Contains methods to sort, search, reverse, fill and shuffle\n+ * Collections, methods to facilitate interoperability with legacy APIs that\n+ * are unaware of collections, a method to return a list which consists of\n+ * multiple copies of one element, and methods which \"wrap\" collections to give\n+ * them extra properties, such as thread-safety and unmodifiability.\n+ */\n+public class Collections\n+{\n+\n+  /**\n+   * This class is non-instantiable.\n+   */\n+  private Collections()\n+  {\n+  }\n+\n+  /**\n+   * An immutable, empty Set.\n+   * Note: This implementation isn't Serializable, although it should be by the\n+   * spec.\n+   */\n+  public static final Set EMPTY_SET = new AbstractSet()\n+  {\n+\n+    public int size()\n+    {\n+      return 0;\n+    }\n+\n+    // This is really cheating! I think it's perfectly valid, though - the\n+    // more conventional code is here, commented out, in case anyone disagrees.\n+    public Iterator iterator()\n+    {\n+      return EMPTY_LIST.iterator();\n+    }\n+\n+    // public Iterator iterator() {\n+    //   return new Iterator() {\n+    // \n+    //     public boolean hasNext() {\n+    //       return false;\n+    //     }\n+    // \n+    //     public Object next() {\n+    //       throw new NoSuchElementException();\n+    //     }\n+    // \n+    //     public void remove() {\n+    //       throw new UnsupportedOperationException();\n+    //     }\n+    //   };\n+    // }\n+\n+  };\n+\n+  /**\n+   * An immutable, empty List.\n+   * Note: This implementation isn't serializable, although it should be by the\n+   * spec.\n+   */\n+  public static final List EMPTY_LIST = new AbstractList()\n+  {\n+\n+    public int size()\n+    {\n+      return 0;\n+    }\n+\n+    public Object get(int index)\n+    {\n+      throw new IndexOutOfBoundsException();\n+    }\n+  };\n+\n+  /**\n+   * An immutable, empty Map.\n+   * Note: This implementation isn't serializable, although it should be by the\n+   * spec.\n+   */\n+  public static final Map EMPTY_MAP = new AbstractMap()\n+  {\n+\n+    public Set entrySet()\n+    {\n+      return EMPTY_SET;\n+    }\n+  };\n+\n+  /**\n+   * Compare two objects with or without a Comparator. If c is null, uses the\n+   * natural ordering. Slightly slower than doing it inline if the JVM isn't\n+   * clever, but worth it for removing a duplicate of the search code.\n+   * Note: This same code is used in Arrays (for sort as well as search)\n+   */\n+  private static int compare(Object o1, Object o2, Comparator c)\n+  {\n+    if (c == null)\n+      {\n+\treturn ((Comparable) o1).compareTo(o2);\n+      }\n+    else\n+      {\n+\treturn c.compare(o1, o2);\n+      }\n+  }\n+\n+  /**\n+   * The hard work for the search routines. If the Comparator given is null,\n+   * uses the natural ordering of the elements.\n+   */\n+  private static int search(List l, Object key, final Comparator c)\n+  {\n+\n+    int pos = 0;\n+\n+    // We use a linear search using an iterator if we can guess that the list\n+    // is sequential-access.\n+    if (l instanceof AbstractSequentialList)\n+      {\n+\tListIterator i = l.listIterator();\n+\twhile (i.hasNext())\n+\t  {\n+\t    final int d = compare(key, i.next(), c);\n+\t    if (d == 0)\n+\t      {\n+\t\treturn pos;\n+\t      }\n+\t    else if (d < 0)\n+\t      {\n+\t\treturn -pos - 1;\n+\t      }\n+\t    pos++;\n+\t  }\n+\n+\t// We assume the list is random-access, and use a binary search\n+      }\n+    else\n+      {\n+\tint low = 0;\n+\tint hi = l.size() - 1;\n+\twhile (low <= hi)\n+\t  {\n+\t    pos = (low + hi) >> 1;\n+\t    final int d = compare(key, l.get(pos), c);\n+\t    if (d == 0)\n+\t      {\n+\t\treturn pos;\n+\t      }\n+\t    else if (d < 0)\n+\t      {\n+\t\thi = pos - 1;\n+\t      }\n+\t    else\n+\t      {\n+\t\tlow = ++pos;\t// This gets the insertion point right on the last loop\n+\t      }\n+\t  }\n+      }\n+\n+    // If we failed to find it, we do the same whichever search we did.\n+    return -pos - 1;\n+  }\n+\n+  /**\n+   * Perform a binary search of a List for a key, using the natural ordering of\n+   * the elements. The list must be sorted (as by the sort() method) - if it is\n+   * not, the behaviour of this method is undefined, and may be an infinite\n+   * loop. Further, the key must be comparable with every item in the list. If\n+   * the list contains the key more than once, any one of them may be found. To\n+   * avoid pathological behaviour on sequential-access lists, a linear search\n+   * is used if (l instanceof AbstractSequentialList). Note: although the\n+   * specification allows for an infinite loop if the list is unsorted, it will\n+   * not happen in this (Classpath) implementation.\n+   *\n+   * @param l the list to search (must be sorted)\n+   * @param key the value to search for\n+   * @returns the index at which the key was found, or -n-1 if it was not\n+   *   found, where n is the index of the first value higher than key or\n+   *   a.length if there is no such value.\n+   * @exception ClassCastException if key could not be compared with one of the\n+   *   elements of l\n+   * @exception NullPointerException if a null element has compareTo called\n+   */\n+  public static int binarySearch(List l, Object key)\n+  {\n+    return search(l, key, null);\n+  }\n+\n+  /**\n+   * Perform a binary search of a List for a key, using a supplied Comparator.\n+   * The list must be sorted (as by the sort() method with the same Comparator)\n+   * - if it is not, the behaviour of this method is undefined, and may be an\n+   * infinite loop. Further, the key must be comparable with every item in the\n+   * list. If the list contains the key more than once, any one of them may be\n+   * found. To avoid pathological behaviour on sequential-access lists, a\n+   * linear search is used if (l instanceof AbstractSequentialList). Note:\n+   * although the specification allows for an infinite loop if the list is\n+   * unsorted, it will not happen in this (Classpath) implementation.\n+   *\n+   * @param l the list to search (must be sorted)\n+   * @param key the value to search for\n+   * @param c the comparator by which the list is sorted\n+   * @returns the index at which the key was found, or -n-1 if it was not\n+   *   found, where n is the index of the first value higher than key or\n+   *   a.length if there is no such value.\n+   * @exception ClassCastException if key could not be compared with one of the\n+   *   elements of l\n+   */\n+  public static int binarySearch(List l, Object key, Comparator c)\n+  {\n+    if (c == null)\n+      {\n+\tthrow new NullPointerException();\n+      }\n+    return search(l, key, c);\n+  }\n+\n+  /**\n+   * Copy one list to another. If the destination list is longer than the\n+   * source list, the remaining elements are unaffected. This method runs in\n+   * linear time.\n+   *\n+   * @param dest the destination list.\n+   * @param source the source list.\n+   * @exception IndexOutOfBoundsException if the destination list is shorter\n+   *   than the source list (the elements that can be copied will be, prior to\n+   *   the exception being thrown).\n+   * @exception UnsupportedOperationException if dest.listIterator() does not\n+   *   support the set operation.\n+   */\n+  public static void copy(List dest, List source)\n+  {\n+    Iterator i1 = source.iterator();\n+    ListIterator i2 = dest.listIterator();\n+    while (i1.hasNext())\n+      {\n+\ti2.next();\n+\ti2.set(i1.next());\n+      }\n+  }\n+\n+  /**\n+   * Returns an Enumeration over a collection. This allows interoperability\n+   * with legacy APIs that require an Enumeration as input.\n+   *\n+   * @param c the Collection to iterate over\n+   * @returns an Enumeration backed by an Iterator over c\n+   */\n+  public static Enumeration enumeration(Collection c)\n+  {\n+    final Iterator i = c.iterator();\n+    return new Enumeration()\n+    {\n+      public final boolean hasMoreElements()\n+      {\n+\treturn i.hasNext();\n+      }\n+      public final Object nextElement()\n+      {\n+\treturn i.next();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Replace every element of a list with a given value. This method runs in\n+   * linear time.\n+   *\n+   * @param l the list to fill.\n+   * @param val the object to vill the list with.\n+   * @exception UnsupportedOperationException if l.listIterator() does not\n+   *   support the set operation.\n+   */\n+  public static void fill(List l, Object val)\n+  {\n+    ListIterator i = l.listIterator();\n+    while (i.hasNext())\n+      {\n+\ti.next();\n+\ti.set(val);\n+      }\n+  }\n+\n+  /**\n+   * Find the maximum element in a Collection, according to the natural\n+   * ordering of the elements. This implementation iterates over the\n+   * Collection, so it works in linear time.\n+   *\n+   * @param c the Collection to find the maximum element of\n+   * @returns the maximum element of c\n+   * @exception NoSuchElementException if c is empty\n+   * @exception ClassCastException if elements in c are not mutually comparable\n+   * @exception NullPointerException if null.compareTo is called\n+   */\n+  public static Object max(Collection c)\n+  {\n+    Iterator i = c.iterator();\n+    Comparable max = (Comparable) i.next();\t// throws NoSuchElementException\n+    while (i.hasNext())\n+      {\n+\tObject o = i.next();\n+\tif (max.compareTo(o) < 0)\n+\t  {\n+\t    max = (Comparable) o;\n+\t  }\n+      }\n+    return max;\n+  }\n+\n+  /**\n+   * Find the maximum element in a Collection, according to a specified\n+   * Comparator. This implementation iterates over the Collection, so it\n+   * works in linear time.\n+   *\n+   * @param c the Collection to find the maximum element of\n+   * @param order the Comparator to order the elements by\n+   * @returns the maximum element of c\n+   * @exception NoSuchElementException if c is empty\n+   * @exception ClassCastException if elements in c are not mutually comparable\n+   */\n+  public static Object max(Collection c, Comparator order)\n+  {\n+    Iterator i = c.iterator();\n+    Object max = i.next();\t// throws NoSuchElementException\n+    while (i.hasNext())\n+      {\n+\tObject o = i.next();\n+\tif (order.compare(max, o) < 0)\n+\t  {\n+\t    max = o;\n+\t  }\n+      }\n+    return max;\n+  }\n+\n+  /**\n+   * Find the minimum element in a Collection, according to the natural\n+   * ordering of the elements. This implementation iterates over the\n+   * Collection, so it works in linear time.\n+   *\n+   * @param c the Collection to find the minimum element of\n+   * @returns the minimum element of c\n+   * @exception NoSuchElementException if c is empty\n+   * @exception ClassCastException if elements in c are not mutually comparable\n+   * @exception NullPointerException if null.compareTo is called\n+   */\n+  public static Object min(Collection c)\n+  {\n+    Iterator i = c.iterator();\n+    Comparable min = (Comparable) i.next();\t// throws NoSuchElementException\n+    while (i.hasNext())\n+      {\n+\tObject o = i.next();\n+\tif (min.compareTo(o) > 0)\n+\t  {\n+\t    min = (Comparable) o;\n+\t  }\n+      }\n+    return min;\n+  }\n+\n+  /**\n+   * Find the minimum element in a Collection, according to a specified\n+   * Comparator. This implementation iterates over the Collection, so it\n+   * works in linear time.\n+   *\n+   * @param c the Collection to find the minimum element of\n+   * @param order the Comparator to order the elements by\n+   * @returns the minimum element of c\n+   * @exception NoSuchElementException if c is empty\n+   * @exception ClassCastException if elements in c are not mutually comparable\n+   */\n+  public static Object min(Collection c, Comparator order)\n+  {\n+    Iterator i = c.iterator();\n+    Object min = i.next();\t// throws NoSuchElementExcception\n+    while (i.hasNext())\n+      {\n+\tObject o = i.next();\n+\tif (order.compare(min, o) > 0)\n+\t  {\n+\t    min = o;\n+\t  }\n+      }\n+    return min;\n+  }\n+\n+  /**\n+   * Creates an immutable list consisting of the same object repeated n times.\n+   * The returned object is tiny, consisting of only a single reference to the\n+   * object and a count of the number of elements. It is Serializable.\n+   *\n+   * @param n the number of times to repeat the object\n+   * @param o the object to repeat\n+   * @returns a List consisting of n copies of o\n+   * @throws IllegalArgumentException if n < 0\n+   */\n+  // It's not Serializable, because the serialized form is unspecced.\n+  // Also I'm only assuming that it should be because I don't think it's\n+  // stated - I just would be amazed if it isn't...\n+  public static List nCopies(final int n, final Object o)\n+  {\n+\n+    // Check for insane arguments\n+    if (n < 0)\n+      {\n+\tthrow new IllegalArgumentException();\n+      }\n+\n+    // Create a minimal implementation of List\n+    return new AbstractList()\n+    {\n+\n+      public int size()\n+      {\n+\treturn n;\n+      }\n+\n+      public Object get(int index)\n+      {\n+\tif (index < 0 || index >= n)\n+\t  {\n+\t    throw new IndexOutOfBoundsException();\n+\t  }\n+\treturn o;\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Reverse a given list. This method works in linear time.\n+   *\n+   * @param l the list to reverse.\n+   * @exception UnsupportedOperationException if l.listIterator() does not\n+   *   support the set operation.\n+   */\n+  public static void reverse(List l)\n+  {\n+    ListIterator i1 = l.listIterator();\n+    ListIterator i2 = l.listIterator(l.size());\n+    while (i1.nextIndex() < i2.previousIndex())\n+      {\n+\tObject o = i1.next();\n+\ti1.set(i2.previous());\n+\ti2.set(o);\n+      }\n+  }\n+\n+  /**\n+   * Get a comparator that implements the reverse of natural ordering. This is\n+   * intended to make it easy to sort into reverse order, by simply passing\n+   * Collections.reverseOrder() to the sort method. The return value of this\n+   * method is Serializable.\n+   */\n+  // The return value isn't Serializable, because the spec is broken.\n+  public static Comparator reverseOrder()\n+  {\n+    return new Comparator()\n+    {\n+      public int compare(Object a, Object b)\n+      {\n+\treturn -((Comparable) a).compareTo(b);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Shuffle a list according to a default source of randomness. The algorithm\n+   * used would result in a perfectly fair shuffle (that is, each element would\n+   * have an equal chance of ending up in any position) with a perfect source\n+   * of randomness; in practice the results are merely very close to perfect.\n+   * <p>\n+   * This method operates in linear time on a random-access list, but may take\n+   * quadratic time on a sequential-access list.\n+   * Note: this (classpath) implementation will never take quadratic time, but\n+   * it does make a copy of the list. This is in line with the behaviour of the\n+   * sort methods and seems preferable.\n+   *\n+   * @param l the list to shuffle.\n+   * @exception UnsupportedOperationException if l.listIterator() does not\n+   *   support the set operation.\n+   */\n+  public static void shuffle(List l)\n+  {\n+    shuffle(l, new Random());\n+  }\n+\n+  /**\n+   * Shuffle a list according to a given source of randomness. The algorithm\n+   * used iterates backwards over the list, swapping each element with an\n+   * element randomly selected from the elements in positions less than or\n+   * equal to it (using r.nextInt(int)).\n+   * <p>\n+   * This algorithm would result in a perfectly fair shuffle (that is, each\n+   * element would have an equal chance of ending up in any position) if r were\n+   * a perfect source of randomness. In practise (eg if r = new Random()) the\n+   * results are merely very close to perfect.\n+   * <p>\n+   * This method operates in linear time on a random-access list, but may take\n+   * quadratic time on a sequential-access list.\n+   * Note: this (classpath) implementation will never take quadratic time, but\n+   * it does make a copy of the list. This is in line with the behaviour of the\n+   * sort methods and seems preferable.\n+   *\n+   * @param l the list to shuffle.\n+   * @param r the source of randomness to use for the shuffle.\n+   * @exception UnsupportedOperationException if l.listIterator() does not\n+   *   support the set operation.\n+   */\n+  public static void shuffle(List l, Random r)\n+  {\n+    Object[] a = l.toArray();\t// Dump l into an array\n+    ListIterator i = l.listIterator(l.size());\n+\n+    // Iterate backwards over l\n+    while (i.hasPrevious())\n+      {\n+\n+\t// Obtain a random position to swap with. nextIndex is used so that the\n+\t// range of the random number includes the current position.\n+\tint swap = r.nextInt(i.nextIndex());\n+\n+\t// Swap the swapth element of the array with the next element of the\n+\t// list.\n+\tObject o = a[swap];\n+\ta[swap] = a[i.previousIndex()];\n+\ta[i.previousIndex()] = o;\n+\n+\t// Set the element in the original list accordingly.\n+\ti.previous();\n+\ti.set(o);\n+      }\n+  }\n+\n+  /**\n+   * Obtain an immutable Set consisting of a single element. The return value\n+   * of this method is Serializable.\n+   *\n+   * @param o the single element.\n+   * @returns an immutable Set containing only o.\n+   */\n+  // It's not serializable because the spec is broken.\n+  public static Set singleton(final Object o)\n+  {\n+\n+    return new AbstractSet()\n+    {\n+\n+      public int size()\n+      {\n+\treturn 1;\n+      }\n+\n+      public Iterator iterator()\n+      {\n+\treturn new Iterator()\n+\t{\n+\n+\t  private boolean hasNext = true;\n+\n+\t  public boolean hasNext()\n+\t  {\n+\t    return hasNext;\n+\t  }\n+\n+\t  public Object next()\n+\t  {\n+\t    if (hasNext)\n+\t      {\n+\t\thasNext = false;\n+\t\treturn o;\n+\t      }\n+\t    else\n+\t      {\n+\t\tthrow new NoSuchElementException();\n+\t      }\n+\t  }\n+\n+\t  public void remove()\n+\t  {\n+\t    throw new UnsupportedOperationException();\n+\t  }\n+\t};\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Obtain an immutable List consisting of a single element. The return value\n+   * of this method is Serializable.\n+   *\n+   * @param o the single element.\n+   * @returns an immutable List containing only o.\n+   */\n+  // It's not serializable because the spec is broken.\n+  public static List singletonList(final Object o)\n+  {\n+\n+    return new AbstractList()\n+    {\n+\n+      public int size()\n+      {\n+\treturn 1;\n+      }\n+\n+      public Object get(int index)\n+      {\n+\tif (index == 0)\n+\t  {\n+\t    throw new IndexOutOfBoundsException();\n+\t  }\n+\telse\n+\t  {\n+\t    return o;\n+\t  }\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Obtain an immutable Map consisting of a single key value pair.\n+   * The return value of this method is Serializable.\n+   *\n+   * @param key the single key.\n+   * @param value the single value.\n+   * @returns an immutable Map containing only the single key value pair.\n+   */\n+  // It's not serializable because the spec is broken.\n+  public static Map singletonMap(final Object key, final Object value)\n+  {\n+\n+    return new AbstractMap()\n+    {\n+      public Set entrySet()\n+      {\n+\treturn singleton(new BasicMapEntry(key, value));\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Sort a list according to the natural ordering of its elements. The list\n+   * must be modifiable, but can be of fixed size. The sort algorithm is\n+   * precisely that used by Arrays.sort(Object[]), which offers guaranteed\n+   * nlog(n) performance. This implementation dumps the list into an array,\n+   * sorts the array, and then iterates over the list setting each element from\n+   * the array.\n+   *\n+   * @param l the List to sort\n+   * @exception ClassCastException if some items are not mutually comparable\n+   * @exception UnsupportedOperationException if the List is not modifiable\n+   */\n+  public static void sort(List l)\n+  {\n+    Object[] a = l.toArray();\n+    Arrays.sort(a);\n+    ListIterator i = l.listIterator();\n+    for (int pos = 0; pos < a.length; pos++)\n+      {\n+\ti.next();\n+\ti.set(a[pos]);\n+      }\n+  }\n+\n+  /**\n+   * Sort a list according to a specified Comparator. The list must be\n+   * modifiable, but can be of fixed size. The sort algorithm is precisely that\n+   * used by Arrays.sort(Object[], Comparator), which offers guaranteed\n+   * nlog(n) performance. This implementation dumps the list into an array,\n+   * sorts the array, and then iterates over the list setting each element from\n+   * the array.\n+   *\n+   * @param l the List to sort\n+   * @param c the Comparator specifying the ordering for the elements\n+   * @exception ClassCastException if c will not compare some pair of items\n+   * @exception UnsupportedOperationException if the List is not modifiable\n+   */\n+  public static void sort(List l, Comparator c)\n+  {\n+    Object[] a = l.toArray();\n+    Arrays.sort(a, c);\n+    ListIterator i = l.listIterator();\n+    for (int pos = 0; pos < a.length; pos++)\n+      {\n+\ti.next();\n+\ti.set(a[pos]);\n+      }\n+  }\n+\n+  // All the methods from here on in require doc-comments.\n+\n+  public static Collection synchronizedCollection(Collection c)\n+  {\n+    return new SynchronizedCollection(c);\n+  }\n+  public static List synchronizedList(List l)\n+  {\n+    return new SynchronizedList(l);\n+  }\n+  public static Map synchronizedMap(Map m)\n+  {\n+    return new SynchronizedMap(m);\n+  }\n+  public static Set synchronizedSet(Set s)\n+  {\n+    return new SynchronizedSet(s);\n+  }\n+  public static SortedMap synchronizedSortedMap(SortedMap m)\n+  {\n+    return new SynchronizedSortedMap(m);\n+  }\n+  public static SortedSet synchronizedSortedSet(SortedSet s)\n+  {\n+    return new SynchronizedSortedSet(s);\n+  }\n+  public static Collection unmodifiableCollection(Collection c)\n+  {\n+    return new UnmodifiableCollection(c);\n+  }\n+  public static List unmodifiableList(List l)\n+  {\n+    return new UnmodifiableList(l);\n+  }\n+  public static Map unmodifiableMap(Map m)\n+  {\n+    return new UnmodifiableMap(m);\n+  }\n+  public static Set unmodifiableSet(Set s)\n+  {\n+    return new UnmodifiableSet(s);\n+  }\n+  public static SortedMap unmodifiableSortedMap(SortedMap m)\n+  {\n+    return new UnmodifiableSortedMap(m);\n+  }\n+  public static SortedSet unmodifiableSortedSet(SortedSet s)\n+  {\n+    return new UnmodifiableSortedSet(s);\n+  }\n+\n+  // Sun's spec will need to be checked for the precise names of these\n+  // classes, for serializability's sake. However, from what I understand,\n+  // serialization is broken for these classes anyway.\n+\n+  // Note: although this code is largely uncommented, it is all very\n+  // mechanical and there's nothing really worth commenting.\n+  // When serialization of these classes works, we'll need doc-comments on\n+  // them to document the serialized form.\n+\n+  private static class UnmodifiableIterator implements Iterator\n+  {\n+    private Iterator i;\n+\n+    public UnmodifiableIterator(Iterator i)\n+    {\n+      this.i = i;\n+    }\n+\n+    public Object next()\n+    {\n+      return i.next();\n+    }\n+    public boolean hasNext()\n+    {\n+      return i.hasNext();\n+    }\n+    public void remove()\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  private static class UnmodifiableListIterator extends UnmodifiableIterator\n+    implements ListIterator\n+  {\n+\n+    // This is stored both here and in the superclass, to avoid excessive\n+    // casting.\n+    private ListIterator li;\n+\n+    public UnmodifiableListIterator(ListIterator li)\n+    {\n+      super(li);\n+      this.li = li;\n+    }\n+\n+    public boolean hasPrevious()\n+    {\n+      return li.hasPrevious();\n+    }\n+    public Object previous()\n+    {\n+      return li.previous();\n+    }\n+    public int nextIndex()\n+    {\n+      return li.nextIndex();\n+    }\n+    public int previousIndex()\n+    {\n+      return li.previousIndex();\n+    }\n+    public void add(Object o)\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    public void set(Object o)\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  private static class UnmodifiableCollection implements Collection,\n+    Serializable\n+  {\n+    Collection c;\n+\n+    public UnmodifiableCollection(Collection c)\n+    {\n+      this.c = c;\n+    }\n+\n+    public boolean add(Object o)\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    public boolean addAll(Collection c)\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    public void clear()\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    public boolean contains(Object o)\n+    {\n+      return c.contains(o);\n+    }\n+    public boolean containsAll(Collection c1)\n+    {\n+      return c.containsAll(c1);\n+    }\n+    public boolean isEmpty()\n+    {\n+      return c.isEmpty();\n+    }\n+    public Iterator iterator()\n+    {\n+      return new UnmodifiableIterator(c.iterator());\n+    }\n+    public boolean remove(Object o)\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    public boolean removeAll(Collection c)\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    public boolean retainAll(Collection c)\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    public int size()\n+    {\n+      return c.size();\n+    }\n+    public Object[] toArray()\n+    {\n+      return c.toArray();\n+    }\n+    public Object[] toArray(Object[]a)\n+    {\n+      return c.toArray(a);\n+    }\n+  }\n+\n+  private static class UnmodifiableList extends UnmodifiableCollection\n+    implements List\n+  {\n+\n+    // This is stored both here and in the superclass, to avoid excessive\n+    // casting.\n+    List l;\n+\n+    public UnmodifiableList(List l)\n+    {\n+      super(l);\n+      this.l = l;\n+    }\n+\n+    public void add(int index, Object o)\n+    {\n+      l.add(index, o);\n+    }\n+    public boolean addAll(int index, Collection c)\n+    {\n+      return l.addAll(index, c);\n+    }\n+    public boolean equals(Object o)\n+    {\n+      return l.equals(o);\n+    }\n+    public Object get(int index)\n+    {\n+      return l.get(index);\n+    }\n+    public int hashCode()\n+    {\n+      return l.hashCode();\n+    }\n+    public int indexOf(Object o)\n+    {\n+      return l.indexOf(o);\n+    }\n+    public int lastIndexOf(Object o)\n+    {\n+      return l.lastIndexOf(o);\n+    }\n+    public ListIterator listIterator()\n+    {\n+      return new UnmodifiableListIterator(l.listIterator());\n+    }\n+    public ListIterator listIterator(int index)\n+    {\n+      return new UnmodifiableListIterator(l.listIterator(index));\n+    }\n+    public Object remove(int index)\n+    {\n+      return l.remove(index);\n+    }\n+    public boolean remove(Object o)\n+    {\n+      return l.remove(o);\n+    }\n+    public Object set(int index, Object o)\n+    {\n+      return l.set(index, o);\n+    }\n+    public List subList(int fromIndex, int toIndex)\n+    {\n+      return new UnmodifiableList(l.subList(fromIndex, toIndex));\n+    }\n+  }\n+\n+  private static class UnmodifiableSet extends UnmodifiableCollection\n+    implements Set\n+  {\n+    public UnmodifiableSet(Set s)\n+    {\n+      super(s);\n+    }\n+    public boolean equals(Object o)\n+    {\n+      return c.equals(o);\n+    }\n+    public int hashCode()\n+    {\n+      return c.hashCode();\n+    }\n+  }\n+\n+  private static class UnmodifiableSortedSet extends UnmodifiableSet\n+    implements SortedSet\n+  {\n+\n+    // This is stored both here and in the superclass, to avoid excessive\n+    // casting.\n+    private SortedSet ss;\n+\n+    public UnmodifiableSortedSet(SortedSet ss)\n+    {\n+      super(ss);\n+      this.ss = ss;\n+    }\n+\n+    public Comparator comparator()\n+    {\n+      return ss.comparator();\n+    }\n+    public Object first()\n+    {\n+      return ss.first();\n+    }\n+    public Object last()\n+    {\n+      return ss.last();\n+    }\n+    public SortedSet headSet(Object toElement)\n+    {\n+      return new UnmodifiableSortedSet(ss.headSet(toElement));\n+    }\n+    public SortedSet tailSet(Object fromElement)\n+    {\n+      return new UnmodifiableSortedSet(ss.tailSet(fromElement));\n+    }\n+    public SortedSet subSet(Object fromElement, Object toElement)\n+    {\n+      return new UnmodifiableSortedSet(ss.subSet(fromElement, toElement));\n+    }\n+  }\n+\n+  private static class UnmodifiableMap implements Map, Serializable\n+  {\n+\n+    Map m;\n+\n+    public UnmodifiableMap(Map m)\n+    {\n+      this.m = m;\n+    }\n+\n+    public void clear()\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    public boolean containsKey(Object key)\n+    {\n+      return m.containsKey(key);\n+    }\n+    public boolean containsValue(Object value)\n+    {\n+      return m.containsValue(value);\n+    }\n+\n+    // This is one of the ickiest cases of nesting I've ever seen. It just\n+    // means \"return an UnmodifiableSet, except that the iterator() method\n+    // returns an UnmodifiableIterator whos next() method returns an\n+    // unmodifiable wrapper around its normal return value\".\n+    public Set entrySet()\n+    {\n+      return new UnmodifiableSet(m.entrySet())\n+      {\n+\tpublic Iterator iterator()\n+\t{\n+\t  return new UnmodifiableIterator(c.iterator())\n+\t  {\n+\t    public Object next()\n+\t    {\n+\t      final Map.Entry e = (Map.Entry) super.next();\n+\t      return new Map.Entry()\n+\t      {\n+\t\tpublic Object getKey()\n+\t\t{\n+\t\t  return e.getKey();\n+\t\t}\n+\t\tpublic Object getValue()\n+\t\t{\n+\t\t  return e.getValue();\n+\t\t}\n+\t\tpublic Object setValue(Object value)\n+\t\t{\n+\t\t  throw new UnsupportedOperationException();\n+\t\t}\n+\t\tpublic int hashCode()\n+\t\t{\n+\t\t  return e.hashCode();\n+\t\t}\n+\t\tpublic boolean equals(Object o)\n+\t\t{\n+\t\t  return e.equals(o);\n+\t\t}\n+\t      };\n+\t    }\n+\t  };\n+\t}\n+      };\n+    }\n+    public boolean equals(Object o)\n+    {\n+      return m.equals(o);\n+    }\n+    public Object get(Object key)\n+    {\n+      return m.get(key);\n+    }\n+    public Object put(Object key, Object value)\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    public int hashCode()\n+    {\n+      return m.hashCode();\n+    }\n+    public boolean isEmpty()\n+    {\n+      return m.isEmpty();\n+    }\n+    public Set keySet()\n+    {\n+      return new UnmodifiableSet(m.keySet());\n+    }\n+    public void putAll(Map m)\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    public Object remove(Object o)\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    public int size()\n+    {\n+      return m.size();\n+    }\n+    public Collection values()\n+    {\n+      return new UnmodifiableCollection(m.values());\n+    }\n+  }\n+\n+  private static class UnmodifiableSortedMap extends UnmodifiableMap\n+    implements SortedMap\n+  {\n+\n+    // This is stored both here and in the superclass, to avoid excessive\n+    // casting.\n+    private SortedMap sm;\n+\n+    public UnmodifiableSortedMap(SortedMap sm)\n+    {\n+      super(sm);\n+      this.sm = sm;\n+    }\n+\n+    public Comparator comparator()\n+    {\n+      return sm.comparator();\n+    }\n+    public Object firstKey()\n+    {\n+      return sm.firstKey();\n+    }\n+    public Object lastKey()\n+    {\n+      return sm.lastKey();\n+    }\n+    public SortedMap headMap(Object toKey)\n+    {\n+      return new UnmodifiableSortedMap(sm.headMap(toKey));\n+    }\n+    public SortedMap tailMap(Object fromKey)\n+    {\n+      return new UnmodifiableSortedMap(sm.tailMap(fromKey));\n+    }\n+    public SortedMap subMap(Object fromKey, Object toKey)\n+    {\n+      return new UnmodifiableSortedMap(sm.subMap(fromKey, toKey));\n+    }\n+  }\n+\n+  // All the \"Synchronized\" wrapper objects include a \"sync\" field which\n+  // specifies what object to synchronize on. That way, nested wrappers such as\n+  // UnmodifiableMap.keySet synchronize on the right things.\n+\n+  private static class SynchronizedIterator implements Iterator\n+  {\n+    Object sync;\n+    private Iterator i;\n+\n+    public SynchronizedIterator(Object sync, Iterator i)\n+    {\n+      this.sync = sync;\n+      this.i = i;\n+    }\n+\n+    public Object next()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn i.next();\n+      }\n+    }\n+    public boolean hasNext()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn i.hasNext();\n+      }\n+    }\n+    public void remove()\n+    {\n+      synchronized(sync)\n+      {\n+\ti.remove();\n+      }\n+    }\n+  }\n+\n+  private static class SynchronizedListIterator extends SynchronizedIterator\n+    implements ListIterator\n+  {\n+\n+    // This is stored both here and in the superclass, to avoid excessive\n+    // casting.\n+    private ListIterator li;\n+\n+    public SynchronizedListIterator(Object sync, ListIterator li)\n+    {\n+      super(sync, li);\n+      this.li = li;\n+    }\n+\n+    public boolean hasPrevious()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn li.hasPrevious();\n+      }\n+    }\n+    public Object previous()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn li.previous();\n+      }\n+    }\n+    public int nextIndex()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn li.nextIndex();\n+      }\n+    }\n+    public int previousIndex()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn li.previousIndex();\n+      }\n+    }\n+    public void add(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\tli.add(o);\n+      }\n+    }\n+    public void set(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\tli.set(o);\n+      }\n+    }\n+  }\n+\n+  private static class SynchronizedCollection implements Collection,\n+    Serializable\n+  {\n+    Object sync;\n+    Collection c;\n+\n+    public SynchronizedCollection(Collection c)\n+    {\n+      this.sync = this;\n+      this.c = c;\n+    }\n+    public SynchronizedCollection(Object sync, Collection c)\n+    {\n+      this.c = c;\n+      this.sync = sync;\n+    }\n+\n+    public boolean add(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.add(o);\n+      }\n+    }\n+    public boolean addAll(Collection col)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.addAll(col);\n+      }\n+    }\n+    public void clear()\n+    {\n+      synchronized(sync)\n+      {\n+\tc.clear();\n+      }\n+    }\n+    public boolean contains(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.contains(o);\n+      }\n+    }\n+    public boolean containsAll(Collection c1)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.containsAll(c1);\n+      }\n+    }\n+    public boolean isEmpty()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.isEmpty();\n+      }\n+    }\n+    public Iterator iterator()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn new SynchronizedIterator(sync, c.iterator());\n+      }\n+    }\n+    public boolean remove(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.remove(o);\n+      }\n+    }\n+    public boolean removeAll(Collection col)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.removeAll(col);\n+      }\n+    }\n+    public boolean retainAll(Collection col)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.retainAll(col);\n+      }\n+    }\n+    public int size()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.size();\n+      }\n+    }\n+    public Object[] toArray()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.toArray();\n+      }\n+    }\n+    public Object[] toArray(Object[]a)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.toArray(a);\n+      }\n+    }\n+  }\n+\n+  private static class SynchronizedList extends SynchronizedCollection\n+    implements List\n+  {\n+\n+    // This is stored both here and in the superclass, to avoid excessive\n+    // casting.\n+    List l;\n+\n+    public SynchronizedList(Object sync, List l)\n+    {\n+      super(sync, l);\n+      this.l = l;\n+    }\n+    public SynchronizedList(List l)\n+    {\n+      super(l);\n+    }\n+\n+    public void add(int index, Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\tl.add(index, o);\n+      }\n+    }\n+    public boolean addAll(int index, Collection c)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn l.addAll(index, c);\n+      }\n+    }\n+    public boolean equals(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn l.equals(o);\n+      }\n+    }\n+    public Object get(int index)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn l.get(index);\n+      }\n+    }\n+    public int hashCode()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn l.hashCode();\n+      }\n+    }\n+    public int indexOf(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn l.indexOf(o);\n+      }\n+    }\n+    public int lastIndexOf(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn l.lastIndexOf(o);\n+      }\n+    }\n+    public ListIterator listIterator()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn new SynchronizedListIterator(sync, l.listIterator());\n+      }\n+    }\n+    public ListIterator listIterator(int index)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn new SynchronizedListIterator(sync, l.listIterator(index));\n+      }\n+    }\n+    public Object remove(int index)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn l.remove(index);\n+      }\n+    }\n+    public boolean remove(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn l.remove(o);\n+      }\n+    }\n+    public Object set(int index, Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn l.set(index, o);\n+      }\n+    }\n+    public List subList(int fromIndex, int toIndex)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn new SynchronizedList(l.subList(fromIndex, toIndex));\n+      }\n+    }\n+  }\n+\n+  private static class SynchronizedSet extends SynchronizedCollection\n+    implements Set\n+  {\n+\n+    public SynchronizedSet(Object sync, Set s)\n+    {\n+      super(sync, s);\n+    }\n+    public SynchronizedSet(Set s)\n+    {\n+      super(s);\n+    }\n+\n+    public boolean equals(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.equals(o);\n+      }\n+    }\n+    public int hashCode()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn c.hashCode();\n+      }\n+    }\n+  }\n+\n+  private static class SynchronizedSortedSet extends SynchronizedSet\n+    implements SortedSet\n+  {\n+\n+    // This is stored both here and in the superclass, to avoid excessive\n+    // casting.\n+    private SortedSet ss;\n+\n+    public SynchronizedSortedSet(Object sync, SortedSet ss)\n+    {\n+      super(sync, ss);\n+      this.ss = ss;\n+    }\n+    public SynchronizedSortedSet(SortedSet ss)\n+    {\n+      super(ss);\n+    }\n+\n+    public Comparator comparator()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn ss.comparator();\n+      }\n+    }\n+    public Object first()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn ss.first();\n+      }\n+    }\n+    public Object last()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn ss.last();\n+      }\n+    }\n+    public SortedSet headSet(Object toElement)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn new SynchronizedSortedSet(sync, ss.headSet(toElement));\n+      }\n+    }\n+    public SortedSet tailSet(Object fromElement)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn new SynchronizedSortedSet(sync, ss.tailSet(fromElement));\n+      }\n+    }\n+    public SortedSet subSet(Object fromElement, Object toElement)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn new SynchronizedSortedSet(sync,\n+\t\t\t\t\t ss.subSet(fromElement, toElement));\n+      }\n+    }\n+  }\n+\n+  private static class SynchronizedMap implements Map, Serializable\n+  {\n+\n+    Object sync;\n+    Map m;\n+\n+    public SynchronizedMap(Object sync, Map m)\n+    {\n+      this.sync = sync;\n+      this.m = m;\n+    }\n+    public SynchronizedMap(Map m)\n+    {\n+      this.m = m;\n+      this.sync = this;\n+    }\n+\n+    public void clear()\n+    {\n+      synchronized(sync)\n+      {\n+\tm.clear();\n+      }\n+    }\n+    public boolean containsKey(Object key)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn m.containsKey(key);\n+      }\n+    }\n+    public boolean containsValue(Object value)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn m.containsValue(value);\n+      }\n+    }\n+\n+    // This is one of the ickiest cases of nesting I've ever seen. It just\n+    // means \"return an SynchronizedSet, except that the iterator() method\n+    // returns an SynchronizedIterator whos next() method returns a\n+    // synchronized wrapper around its normal return value\".\n+    public Set entrySet()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn new SynchronizedSet(sync, m.entrySet())\n+\t{\n+\t  public Iterator iterator()\n+\t  {\n+\t    synchronized(SynchronizedMap.this.sync)\n+\t    {\n+\t      return new SynchronizedIterator(SynchronizedMap.this.sync,\n+\t\t\t\t\t      c.iterator())\n+\t      {\n+\t\tpublic Object next()\n+\t\t{\n+\t\t  synchronized(SynchronizedMap.this.sync)\n+\t\t  {\n+\t\t    final Map.Entry e = (Map.Entry) super.next();\n+\t\t    return new Map.Entry()\n+\t\t    {\n+\t\t      public Object getKey()\n+\t\t      {\n+\t\t\tsynchronized(SynchronizedMap.this.sync)\n+\t\t\t{\n+\t\t\t  return e.getKey();\n+\t\t\t}\n+\t\t      }\n+\t\t      public Object getValue()\n+\t\t      {\n+\t\t\tsynchronized(SynchronizedMap.this.sync)\n+\t\t\t{\n+\t\t\t  return e.getValue();\n+\t\t\t}\n+\t\t      }\n+\t\t      public Object setValue(Object value)\n+\t\t      {\n+\t\t\tsynchronized(SynchronizedMap.this.sync)\n+\t\t\t{\n+\t\t\t  return e.setValue(value);\n+\t\t\t}\n+\t\t      }\n+\t\t      public int hashCode()\n+\t\t      {\n+\t\t\tsynchronized(SynchronizedMap.this.sync)\n+\t\t\t{\n+\t\t\t  return e.hashCode();\n+\t\t\t}\n+\t\t      }\n+\t\t      public boolean equals(Object o)\n+\t\t      {\n+\t\t\tsynchronized(SynchronizedMap.this.sync)\n+\t\t\t{\n+\t\t\t  return e.equals(o);\n+\t\t\t}\n+\t\t      }\n+\t\t    };\n+\t\t  }\n+\t\t}\n+\t      };\n+\t    }\n+\t  }\n+\t};\n+      }\n+    }\n+    public boolean equals(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn m.equals(o);\n+      }\n+    }\n+    public Object get(Object key)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn m.get(key);\n+      }\n+    }\n+    public Object put(Object key, Object value)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn m.put(key, value);\n+      }\n+    }\n+    public int hashCode()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn m.hashCode();\n+      }\n+    }\n+    public boolean isEmpty()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn m.isEmpty();\n+      }\n+    }\n+    public Set keySet()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn new SynchronizedSet(sync, m.keySet());\n+      }\n+    }\n+    public void putAll(Map map)\n+    {\n+      synchronized(sync)\n+      {\n+\tm.putAll(map);\n+      }\n+    }\n+    public Object remove(Object o)\n+    {\n+      synchronized(sync)\n+      {\n+\treturn m.remove(o);\n+      }\n+    }\n+\n+    public int size()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn m.size();\n+      }\n+    }\n+    public Collection values()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn new SynchronizedCollection(sync, m.values());\n+      }\n+    }\n+  }\n+\n+  private static class SynchronizedSortedMap extends SynchronizedMap\n+    implements SortedMap\n+  {\n+\n+    // This is stored both here and in the superclass, to avoid excessive\n+    // casting.\n+    private SortedMap sm;\n+\n+    public SynchronizedSortedMap(Object sync, SortedMap sm)\n+    {\n+      super(sync, sm);\n+      this.sm = sm;\n+    }\n+    public SynchronizedSortedMap(SortedMap sm)\n+    {\n+      super(sm);\n+    }\n+\n+    public Comparator comparator()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn sm.comparator();\n+      }\n+    }\n+    public Object firstKey()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn sm.firstKey();\n+      }\n+    }\n+    public Object lastKey()\n+    {\n+      synchronized(sync)\n+      {\n+\treturn sm.lastKey();\n+      }\n+    }\n+    public SortedMap headMap(Object toKey)\n+    {\n+      return new SynchronizedSortedMap(sync, sm.headMap(toKey));\n+    }\n+    public SortedMap tailMap(Object fromKey)\n+    {\n+      return new SynchronizedSortedMap(sync, sm.tailMap(fromKey));\n+    }\n+    public SortedMap subMap(Object fromKey, Object toKey)\n+    {\n+      return new SynchronizedSortedMap(sync, sm.subMap(fromKey, toKey));\n+    }\n+  }\n+}"}, {"sha": "e3e2617e58c327bc226bee70dfefa1b6b9f98d89", "filename": "libjava/java/util/List.java", "status": "modified", "additions": 323, "deletions": 37, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2Fjava%2Futil%2FList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2Fjava%2Futil%2FList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FList.java?ref=79af883cd48fbd3267a319c8d89aefc2ed129516", "patch": "@@ -1,47 +1,333 @@\n-/* Copyright (C) 2000  Free Software Foundation\n+/* List.java -- An ordered collection which allows indexed access\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+// TO DO:\n+// ~ Doc comment for the interface itself needs to be put into english.\n+// ~ Some more @see clauses might be nice.\n \n package java.util;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date March 16, 2000.\n- */\n-/* Written using on-line Java Platform 1.2 API Specification.\n- * Status:  Believed complete and correct.\n+ * [This is what this doc comment will mention:\n+ * ~ Additional restrictions on some methods. Others included for completeness.\n+ * ~ ListIterator and what it can do\n+ * ~ Positional and iterated access\n+ * ~ search (but linear time)\n+ * ~ be careful when containing self as an element, because equals and hashCode\n+ *   loop.]\n  */\n-\n-// JDK1.2\n public interface List extends Collection\n {\n-  public int size();\n-  public boolean isEmpty();\n-  public boolean contains(Object o);\n-  public Iterator iterator();\n-  public Object[] toArray();\n-  public Object[] toArray(Object[] a);\n-  public boolean add(Object o);\n-  public boolean remove(Object o);\n-  public boolean containsAll(Collection c);\n-  public boolean addAll(Collection c);\n-  public boolean addAll(int index, Collection c);\n-  public boolean removeAll(Collection c);\n-  public boolean retainAll(Collection c);\n-  public void clear();\n-  public boolean equals(Object o);\n-  public int hashCode();\n-  public Object get(int index);\n-  public Object set(int index, Object element);\n-  public void add(int index, Object element);\n-  public Object remove(int index);\n-  public int indexOf(Object o);\n-  public int lastIndexOf(Object o);\n-  public ListIterator listIterator();\n-  public ListIterator listIterator(int index);\n-  public List subList(int fromIndex, int toIndex);\n+  /**\n+   * Insert an element into the list at a given position.\n+   *\n+   * @param index the location to insert the item.\n+   * @param o the object to insert.\n+   * @exception UnsupportedOperationException if this list does not support the\n+   *   add operation.\n+   * @exception IndexOutOfBoundsException if index < 0 || index > size()\n+   * @exception ClassCastException if o cannot be added to this list due to its\n+   *   type.\n+   * @exception IllegalArgumentException if o cannot be added to this list for\n+   *   some other reason.\n+   */\n+  void add(int index, Object o);\n+\n+  /**\n+   * Add an element to the end of the list.\n+   *\n+   * @param o the object to add.\n+   * @returns true, as Collection defines this method as returning true if the\n+   *   list was modified as a result of this action, and it always is for a\n+   *   list.\n+   * @exception UnsupportedOperationException if this list does not support the\n+   *   add operation.\n+   * @exception ClassCastException if o cannot be added to this list due to its\n+   *   type.\n+   * @exception IllegalArgumentException if o cannot be added to this list for\n+   *   some other reason.\n+   */\n+  boolean add(Object o);\n+\n+  /**\n+   * Insert the contents of a collection into the list at a given position.\n+   *\n+   * @param index the location to insert the collection.\n+   * @param c the collection to insert.\n+   * @returns true if the list was modified by this action, that is, if c is\n+   *   non-empty.\n+   * @exception UnsupportedOperationException if this list does not support the\n+   *   addAll operation.\n+   * @exception IndexOutOfBoundsException if index < 0 || index > size()\n+   * @exception ClassCastException if some element of c cannot be added to this\n+   *   list due to its type.\n+   * @exception IllegalArgumentException if some element of c cannot be added\n+   *   to this list for some other reason.\n+   */\n+  boolean addAll(int index, Collection c);\n+\n+  /**\n+   * Add the contents of a collection to the end of the list.\n+   *\n+   * @param c the collection to add.\n+   * @returns true if the list was modified by this action, that is, if c is\n+   *   non-empty.\n+   * @exception UnsupportedOperationException if this list does not support the\n+   *   addAll operation.\n+   * @exception ClassCastException if some element of c cannot be added to this\n+   *   list due to its type.\n+   * @exception IllegalArgumentException if some element of c cannot be added\n+   *   to this list for some other reason.\n+   */\n+  boolean addAll(Collection c);\n+\n+  /**\n+   * Clear the list, such that a subsequent call to isEmpty() would return\n+   * true.\n+   *\n+   * @exception UnsupportedOperationException if this list does not support the\n+   *   clear operation.\n+   */\n+  void clear();\n+\n+  /**\n+   * Test whether this list contains a given object as one of its elements.\n+   *\n+   * @param o the element to look for.\n+   * @returns true if this list contains an element e such that <code>o ==\n+   *   null ? e == null : o.equals(e)</code>.\n+   */\n+  boolean contains(Object o);\n+\n+  /**\n+   * Test whether this list contains every element in a given collection.\n+   *\n+   * @param c the collection to test for.\n+   * @returns true if for every element o in c, contains(o) would return true.\n+   */\n+  boolean containsAll(Collection c);\n+\n+  /**\n+   * Test whether this list is equal to another object. A List is defined to be\n+   * equal to an object if and only if that object is also a List, and the two\n+   * lists are equal. Two lists l1 and l2 are defined to be equal if and only\n+   * if <code>l1.size() == l2.size()</code>, and for every integer n between 0\n+   * and <code>l1.size() - 1</code> inclusive, <code>l1.get(n) == null ?\n+   * l2.get(n) == null : l1.get(n).equals(l2.get(n))</code>.\n+   *\n+   * @param o the object to test for equality with this list.\n+   * @returns true if o is equal to this list.\n+   */\n+  boolean equals(Object o);\n+\n+  /**\n+   * Get the element at a given index in this list.\n+   *\n+   * @param index the index of the element to be returned.\n+   * @returns the element at index index in this list.\n+   * @exception IndexOutOfBoundsException if index < 0 || index >= size()\n+   */\n+  Object get(int index);\n+\n+  /**\n+   * Obtain a hash code for this list. In order to obey the general contract of\n+   * the hashCode method of class Object, this value is calculated as follows:\n+   * <pre>\n+   *   hashCode = 1;\n+   *   Iterator i = list.iterator();\n+   *   while (i.hasNext()) {\n+   *     Object obj = i.next();\n+   *     hashCode = 31*hashCode + (obj==null ? 0 : obj.hashCode());\n+   *   }\n+   * </pre>\n+   * This ensures that the general contract of Object.hashCode() is adhered to.\n+   *\n+   * @returns the hash code of this list.\n+   */\n+  int hashCode();\n+\n+  /**\n+   * Obtain the first index at which a given object is to be found in this\n+   * list.\n+   *\n+   * @returns the least integer n such that <code>o == null ? get(n) == null :\n+   *   o.equals(get(n))</code>, or -1 if there is no such index.\n+   */\n+  int indexOf(Object o);\n+\n+  /**\n+   * Test whether this list is empty, that is, if size() == 0.\n+   *\n+   * @returns true if this list contains no elements.\n+   */\n+  boolean isEmpty();\n+\n+  /**\n+   * Obtain an Iterator over this list.\n+   *\n+   * @returns an Iterator over the elements of this list, in order.\n+   */\n+  Iterator iterator();\n+\n+  /**\n+   * Obtain the last index at which a given object is to be found in this\n+   * list.\n+   *\n+   * @returns the greatest integer n such that <code>o == null ? get(n) == null\n+   *   : o.equals(get(n))</code>.\n+   */\n+  int lastIndexOf(Object o);\n+\n+  /**\n+   * Obtain a ListIterator over this list, starting at the beginning.\n+   *\n+   * @returns a ListIterator over the elements of this list, in order, starting\n+   *   at the beginning.\n+   */\n+  ListIterator listIterator();\n+\n+  /**\n+   * Obtain a ListIterator over this list, starting at a given position.\n+   *\n+   * @param index the position, between 0 and size() inclusive, to begin the\n+   *   iteration from.\n+   * @returns a ListIterator over the elements of this list, in order, starting\n+   *   at index.\n+   * @exception IndexOutOfBoundsException if index < 0 || index > size()\n+   */\n+  ListIterator listIterator(int index);\n+\n+  /**\n+   * Remove the element at a given position in this list.\n+   *\n+   * @param index the position within the list of the object to remove.\n+   * @returns the object that was removed.\n+   * @exception UnsupportedOperationException if this list does not support the\n+   *   remove operation.\n+   * @exception IndexOutOfBoundsException if index < 0 || index > size()\n+   */\n+  Object remove(int index);\n+\n+  /**\n+   * Remove the first occurence of an object from this list. That is, remove\n+   * the first element e such that <code>o == null ? e == null :\n+   * o.equals(e)</code>.\n+   *\n+   * @param o the object to remove.\n+   * @returns true if the list changed as a result of this call, that is, if\n+   *   the list contained at least one occurrence of o.\n+   * @exception UnsupportedOperationException if this list does not support the\n+   *   remove operation.\n+   */\n+  boolean remove(Object o);\n+\n+  /**\n+   * Remove all elements of a given collection from this list. That is, remove\n+   * every element e such that c.contains(e).\n+   *\n+   * @returns true if this list was modified as a result of this call.\n+   * @exception UnsupportedOperationException if this list does not support the\n+   *   removeAll operation.\n+   */\n+  boolean removeAll(Collection c);\n+\n+  /**\n+   * Remove all elements of this list that are not contained in a given\n+   * collection. That is, remove every element e such that !c.contains(e).\n+   *\n+   * @returns true if this list was modified as a result of this call.\n+   * @exception UnsupportedOperationException if this list does not support the\n+   *   retainAll operation.\n+   */\n+  boolean retainAll(Collection c);\n+\n+  /**\n+   * Replace an element of this list with another object.\n+   *\n+   * @param index the position within this list of the element to be replaced.\n+   * @param o the object to replace it with.\n+   * @returns the object that was replaced.\n+   * @exception UnsupportedOperationException if this list does not support the\n+   *   set operation.\n+   * @exception IndexOutOfBoundsException if index < 0 || index >= size()\n+   * @exception ClassCastException if o cannot be added to this list due to its\n+   *   type.\n+   * @exception IllegalArgumentException if o cannot be added to this list for\n+   *   some other reason.\n+   */\n+  Object set(int index, Object o);\n+\n+  /**\n+   * Get the number of elements in this list.\n+   *\n+   * @returns the number of elements in the list.\n+   */\n+  int size();\n+\n+  /**\n+   * Obtain a List view of a subsection of this list, from fromIndex\n+   * (inclusive) to toIndex (exclusive). The returned list should be modifiable\n+   * if and only if this list is modifiable. Changes to the returned list\n+   * should be reflected in this list. If this list is structurally modified in\n+   * any way other than through the returned list, the result of any subsequent\n+   * operations on the returned list is undefined.\n+   *\n+   * @param fromIndex the index that the returned list should start from\n+   *    (inclusive).\n+   * @param toIndex the index that the returned list should go to (exclusive).\n+   * @returns a List backed by a subsection of this list.\n+   * @exception IndexOutOfBoundsException if fromIndex < 0 || toIndex > size()\n+   *   || fromIndex > toIndex.\n+   */\n+  List subList(int fromIndex, int toIndex);\n+\n+  /**\n+   * Copy the current contents of this list into an array.\n+   *\n+   * @returns an array of type Object[] and length equal to the length of this\n+   *   list, containing the elements currently in this list, in order.\n+   */\n+  Object[] toArray();\n+\n+  /**\n+   * Copy the current contents of this list into an array. If the array passed\n+   * as an argument has length less than that of this list, an array of the\n+   * same run-time type as a, and length equal to the length of this list, is\n+   * allocated using Reflection. Otherwise, a itself is used. The elements of\n+   * this list are copied into it, and if there is space in the array, the\n+   * following element is set to null. The resultant array is returned.\n+   * Note: The fact that the following element is set to null is only useful\n+   * if it is known that this list does not contain any null elements.\n+   *\n+   * @param a the array to copy this list into.\n+   * @returns an array containing the elements currently in this list, in\n+   *    order.\n+   * @exception ArrayStoreException if the type of any element of the\n+   *   collection is not a subtype of the element type of a.\n+   */\n+  Object[] toArray(Object[] a);\n }"}, {"sha": "685949cde40e6618d0d876a047a5476d7808b7ee", "filename": "libjava/java/util/SimpleTimeZone.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2Fjava%2Futil%2FSimpleTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2Fjava%2Futil%2FSimpleTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FSimpleTimeZone.java?ref=79af883cd48fbd3267a319c8d89aefc2ed129516", "patch": "@@ -763,7 +763,7 @@ private void readObject(java.io.ObjectInputStream input)\n     else\n       {\n \tint length = input.readInt();\n-\tbyte[]byteArray = new byte[length];\n+\tbyte[] byteArray = new byte[length];\n \tinput.read(byteArray, 0, length);\n \tif (length >= 4)\n \t  {"}, {"sha": "2fcc029b2c08e4ae178f9cbd3b5f31c347cb9bd8", "filename": "libjava/java/util/Vector.java", "status": "modified", "additions": 624, "deletions": 330, "changes": 954, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2Fjava%2Futil%2FVector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79af883cd48fbd3267a319c8d89aefc2ed129516/libjava%2Fjava%2Futil%2FVector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FVector.java?ref=79af883cd48fbd3267a319c8d89aefc2ed129516", "patch": "@@ -1,463 +1,757 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Vector.java -- Class that provides growable arrays.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-package java.util;\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n+\n+package java.util;\n+import java.lang.reflect.Array;\n import java.io.Serializable;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date August 17, 1998.\n+ * the <b>Vector</b> classes implements growable arrays of Objects.\n+ * You can access elements in a Vector with an index, just as you\n+ * can in a built in array, but Vectors can grow and shrink to accomodate\n+ * more or fewer objects.  \n+ *\n+ * Vectors try to mantain efficiency in growing by having a\n+ * <b>capacityIncrement</b> that can be specified at instantiation.\n+ * When a Vector can no longer hold a new Object, it grows by the amount\n+ * in <b>capacityIncrement</b>.  \n+ *\n+ * Vector implements the JDK 1.2 List interface, and is therefor a fully\n+ * compliant Collection object.\n+ *\n+ * @specnote The JCL claims that various methods in this class throw\n+ * IndexOutOfBoundsException, which would be consistent with other collections\n+ * classes. ArrayIndexOutOfBoundsException is actually thrown, per the online \n+ * docs, even for List method implementations.\n+ * \n+ * @author Scott G. Miller\n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct\n- */\n-\n-final class VectorEnumeration implements Enumeration\n+public class Vector extends AbstractList \n+  implements List, Cloneable, Serializable\n {\n-  private int enumIndex;\n-  private Vector enumVec;\n+  /**\n+   * The amount the Vector's internal array should be increased in size when\n+   * a new element is added that exceeds the current size of the array,\n+   * or when {@link #ensureCapacity} is called.\n+   * @serial\n+   */\n+  protected int capacityIncrement = 0;\n+\n+  /**\n+   * The number of elements currently in the vector, also returned by\n+   * {@link #size}.\n+   * @serial\n+   */\n+  protected int elementCount = 0;\n+\n+  /**\n+   * The internal array used to hold members of a Vector\n+   * @serial\n+   */\n+  protected Object[] elementData;\n \n-  public VectorEnumeration(Vector vec)\n-  {\n-    enumVec = vec;\n-    enumIndex = 0;\n-  }\n+  private static final long serialVersionUID = -2767605614048989439L;\n \n-  public boolean hasMoreElements()\n+  /**\n+   * Constructs an empty vector with an initial size of 10, and\n+   * a capacity increment of 0\n+   */\n+  public Vector()\n   {\n-    return enumIndex < enumVec.size();\n+    this(10);\n   }\n \n-  public Object nextElement()\n+  /**\n+   * Constructs a vector containing the contents of Collection, in the\n+   * order given by the collection\n+   *\n+   * @param c A collection of elements to be added to the newly constructed\n+   * vector\n+   */\n+  public Vector(Collection c)\n   {\n-    if (! (enumIndex < enumVec.size()))\n-      throw new NoSuchElementException();\n-\n-    return enumVec.elementData[enumIndex++];\n+    int csize = c.size();\n+    elementData = new Object[csize];\n+    elementCount = csize;\n+    Iterator itr = c.iterator();\n+    for (int i = 0; i < csize; i++)\n+      {\n+\telementData[i] = itr.next();\n+      }\n   }\n-}\n \n-// TODO12:\n-// public class Vector extends AbstractList\n-//\timplements List, Cloneable, Serializable\n-\n-public class Vector implements Cloneable, Serializable\n-{\n-  /* The size of the increment to use when growing this vector.\n-     The default of 0 means to double the capacity when growing. */\n-  protected int capacityIncrement;\n-\n-  /* The number of elements currently in elementData */\n-  protected int elementCount;\n-\n-  /* The buffer in which elements of this vector are stored */\n-  protected Object[] elementData;\n-\n-  private static final long serialVersionUID = -2767605614048989439L;\n-\n-  public Vector()\n+  /**\n+   * Constructs a Vector with the initial capacity and capacity \n+   * increment specified\n+   *\n+   * @param initialCapacity The initial size of the Vector's internal\n+   * array\n+   * @param capacityIncrement The amount the internal array should be\n+   * increased if necessary\n+   */\n+  public Vector(int initialCapacity, int capacityIncrement)\n   {\n-    this(10, 0);\n+    elementData = new Object[initialCapacity];\n+    this.capacityIncrement = capacityIncrement;\n   }\n \n-  public Vector(int initCap)\n+  /**\n+   * Constructs a Vector with the initial capacity specified\n+   *\n+   * @param initialCapacity The initial size of the Vector's internal array\n+   */\n+  public Vector(int initialCapacity)\n   {\n-    this(initCap, 0);\n+    elementData = new Object[initialCapacity];\n   }\n \n-  public Vector(int initCap, int capIncrement)\n+  /**\n+   * Copies the contents of a provided array into the Vector.  If the \n+   * array is too large to fit in the Vector, an ArrayIndexOutOfBoundsException\n+   * is thrown.  Old elements in the Vector are overwritten by the new\n+   * elements\n+   *\n+   * @param anArray An array from which elements will be copied into the Vector\n+   * \n+   * @throws ArrayIndexOutOfBoundsException the array being copied\n+   * is larger than the Vectors internal data array\n+   */\n+  public synchronized void copyInto(Object[] anArray)\n   {\n-    if (initCap < 0)\n-      throw new IllegalArgumentException ();\n-    elementData = new Object[initCap];\n-    capacityIncrement = capIncrement;\n-    elementCount = 0;\n+    System.arraycopy(elementData, 0, anArray, 0, elementCount);\n   }\n \n-  public final synchronized void addElement(Object obj)\n+  /**\n+   * Trims the Vector down to size.  If the internal data array is larger\n+   * than the number of Objects its holding, a new array is constructed\n+   * that precisely holds the elements.  \n+   */\n+  public synchronized void trimToSize()\n   {\n-    // Make sure there's room for a new element\n+    // Check if the Vector is already trimmed, to save execution time\n     if (elementCount == elementData.length)\n-      ensureCapacity(elementCount+1);\n+      return;\n+    // Guess not\n \n-    elementData[elementCount++] = obj;\n+    Object[]newArray = new Object[elementCount];\n+    System.arraycopy(elementData, 0, newArray, 0, elementCount);\n+    elementData = newArray;\n   }\n \n-  public final int capacity()\n+  /**\n+   * Ensures that <b>minCapacity</b> elements can fit within this Vector.\n+   * If it cannot hold this many elements, the internal data array is expanded\n+   * in the following manner.  If the current size plus the capacityIncrement\n+   * is sufficient, the internal array is expanded by capacityIncrement.  \n+   * If capacityIncrement is non-positive, the size is doubled.  If \n+   * neither is sufficient, the internal array is expanded to size minCapacity\n+   *\n+   * @param minCapacity The minimum capacity the internal array should be\n+   * able to handle after executing this method\n+   */\n+  public synchronized void ensureCapacity(int minCapacity)\n   {\n-    return elementData.length;\n-  }\n+    modCount++;\n+    if (elementData.length >= minCapacity)\n+      return;\n \n-  public synchronized Object clone()\n-  {\n-    // New vector needs to have same size, capacity and capacityIncrement\n-    Vector newVec = new Vector(elementData.length, capacityIncrement);\n+    int newCapacity; \n+    if (capacityIncrement <= 0)\n+      newCapacity = elementData.length * 2;\n+    else\n+      newCapacity = elementData.length + capacityIncrement;\n+      \n+    Object[] newArray = new Object[Math.max(newCapacity, minCapacity)];\n \n-    System.arraycopy(elementData, 0, newVec.elementData, 0, elementCount);\n-    newVec.elementCount = elementCount;\n-    return newVec;\n+    System.arraycopy(elementData, 0, newArray, 0, elementData.length);\n+    elementData = newArray;\n   }\n \n-  public final boolean contains(Object obj)\n+  /**\n+   * Explicitly sets the size of the internal data array, copying the \n+   * old values to the new internal array.  If the new array is smaller\n+   * than the old one, old values that don't fit are lost. If the new size\n+   * is larger than the old one, the vector is padded with null entries.\n+   *\n+   * @param newSize The new size of the internal array\n+   */\n+  public synchronized void setSize(int newSize)\n   {\n-    for (int i = 0; i < elementCount; i++)\n-      {\n-\tif (obj == null\n-\t    ? elementData[i] == null\n-\t    : obj.equals(elementData[i]))\n-\t  return true;\n-      }\n-\n-    return false;\n+    modCount++;\n+    Object[] newArray = new Object[newSize];\n+    System.arraycopy(elementData, 0, newArray, 0, \n+                     Math.min(newSize, elementCount));\n+    elementCount = newSize;\n+    elementData = newArray;\n   }\n \n-  public final synchronized void copyInto(Object[] objArray)\n+  /**\n+   * Returns the size of the internal data array (not the amount of elements\n+   * contained in the Vector)\n+   *\n+   * @returns capacity of the internal data array\n+   */\n+  public int capacity()\n   {\n-    System.arraycopy(elementData, 0, objArray, 0, elementCount);\n+    return elementData.length;\n   }\n \n-  public final synchronized Object elementAt(int idx)\n+  /**\n+   * Returns the number of elements stored in this Vector\n+   *\n+   * @returns the number of elements in this Vector\n+   */\n+  public int size()\n   {\n-    if (idx < 0 || idx >= size())\n-      throw new ArrayIndexOutOfBoundsException();\n-\n-    return elementData[idx];\n+    return elementCount;\n   }\n \n-  public final synchronized Enumeration elements()\n+  /**\n+   * Returns true if this Vector is empty, false otherwise\n+   *\n+   * @returns true if the Vector is empty, false otherwise\n+   */\n+  public boolean isEmpty()\n   {\n-    return new VectorEnumeration(this);\n+    return elementCount == 0;\n   }\n \n-  public final synchronized void ensureCapacity(int minCap)\n+  /**\n+   * Searches the vector starting at <b>index</b> for object <b>elem</b>\n+   * and returns the index of the first occurence of this Object.  If\n+   * the object is not found, -1 is returned\n+   *\n+   * @param e The Object to search for\n+   * @param index Start searching at this index\n+   * @returns The index of the first occurence of <b>elem</b>, or -1\n+   * if it is not found\n+   */\n+  public synchronized int indexOf(Object e, int index)\n   {\n-    // Increasing the vector could make it much larger than minCap;\n-    // e.g. if minCap is just larger than the vector, size may double.\n-    // If someone cares about this possibility they should set capacityIncrement\n-    if (minCap > elementData.length)\n+    for (int i = index; i < elementCount; i++)\n       {\n-\t// Increase the vector; double it if capacityIncrement is zero\n-\tint newSize = elementData.length;\n-\tnewSize +=\n-\t  (capacityIncrement > 0) ? capacityIncrement : elementData.length;\n-\n-\t// Make sure newSize is at least minCap\n-\tif (newSize < minCap)\n-\t  newSize = minCap;\n-\n-\tObject[] newArray = new Object[newSize];\n-\tSystem.arraycopy(elementData, 0, newArray, 0, elementCount);\n-\telementData = newArray;\n+\tif (e == null ? elementData[i] == null : e.equals(elementData[i]))\n+\t  return i;\n       }\n+    return -1;\n   }\n \n-  public final synchronized Object firstElement()\n+  /**\n+   * Returns the first occurence of <b>elem</b> in the Vector, or -1 if\n+   * <b>elem</b> is not found.\n+   *\n+   * @param elem The object to search for\n+   * @returns The index of the first occurence of <b>elem</b> or -1 if \n+   * not found\n+   */\n+  public int indexOf(Object elem)\n   {\n-    if (elementCount == 0)\n-      throw new NoSuchElementException();\n-\n-    return elementData[0];\n+    return indexOf(elem, 0);\n   }\n \n-  public final int indexOf(Object obj)\n+  /**\n+   * Returns true if <b>elem</b> is contained in this Vector, false otherwise.\n+   *\n+   * @param elem The element to check\n+   * @returns true if the object is contained in this Vector, false otherwise\n+   */\n+  public boolean contains(Object elem)\n   {\n-    return indexOf(obj, 0);\n+    return indexOf(elem, 0) != -1;\n   }\n \n-  public final synchronized int indexOf(Object obj, int idx)\n+  /**\n+   * Returns the index of the first occurence of <b>elem</b>, when searching\n+   * backwards from <b>index</b>.  If the object does not occur in this Vector,\n+   * -1 is returned.\n+   *\n+   * @param eThe object to search for\n+   * @param index The index to start searching in reverse from\n+   * @returns The index of the Object if found, -1 otherwise\n+   */\n+  public synchronized int lastIndexOf(Object e, int index)\n   {\n-    if (idx < 0)\n-      throw new IllegalArgumentException ();\n-    for (int i = idx; i < elementCount; i++)\n+    if (index >= elementCount)\n+      throw new ArrayIndexOutOfBoundsException(index);\n+\n+    for (int i = index; i >= 0; i--)\n       {\n-\tif (obj == null\n-\t    ? elementData[i] == null\n-\t    : obj.equals(elementData[i]))\n+\tif (e == null ? elementData[i] == null : e.equals(elementData[i]))\n \t  return i;\n       }\n-\n     return -1;\n   }\n \n-  public final synchronized void insertElementAt(Object obj, int idx)\n+  /**\n+   * Returns the last index of <b>elem</b> within this Vector, or -1\n+   * if the object is not within the Vector\n+   *\n+   * @param elem The object to search for\n+   * @returns the last index of the object, or -1 if not found\n+   */\n+  public int lastIndexOf(Object elem)\n   {\n-    if (idx < 0 || idx > size())\n-      throw new ArrayIndexOutOfBoundsException();\n-    else if (idx == size())\t\t// Spec says just use addElement()\n-      addElement(obj);\n-    else\n-      {\n-\t// Make sure there's room for a new element\n-\tif (elementCount == elementData.length)\n-\t  ensureCapacity(elementCount+1);\n+    return lastIndexOf(elem, elementCount - 1);\n+  }\n \n-\t// Shift the existing elements up and increment elementCount\n-\tfor (int i = elementCount++; i > idx; --i)\n-\t  elementData[i] = elementData[i-1];\n+  /**\n+   * Returns the Object stored at <b>index</b>.  If index is out of range\n+   * an ArrayIndexOutOfBoundsException is thrown.\n+   *\n+   * @param index the index of the Object to retrieve\n+   * @returns The object at <b>index</b>\n+   * @throws ArrayIndexOutOfBoundsException <b>index</b> is\n+   * larger than the Vector\n+   */\n+  public synchronized Object elementAt(int index)\n+  {\n+    //Within the bounds of this Vector does not necessarily mean within \n+    //the bounds of the internal array\n+    if (index >= elementCount)\n+      throw new ArrayIndexOutOfBoundsException(index);\n \n-\telementData[idx] = obj;\n-      }\n+    return elementData[index];\n   }\n \n-  public final boolean isEmpty()\n+  /**\n+   * Returns the first element in the Vector.  If there is no first Object \n+   * (The vector is empty), a NoSuchElementException is thrown.\n+   *\n+   * @returns The first Object in the Vector\n+   * @throws NoSuchElementException the Vector is empty\n+   */\n+  public synchronized Object firstElement()\n   {\n-    return elementCount == 0;\n+    if (elementCount == 0)\n+      throw new NoSuchElementException();\n+\n+    return elementAt(0);\n   }\n \n-  public final synchronized Object lastElement()\n+  /**\n+   * Returns the last element in the Vector.  If the Vector has no last element\n+   * (The vector is empty), a NoSuchElementException is thrown.\n+   *\n+   * @returns The last Object in the Vector\n+   * @throws NoSuchElementException the Vector is empty\n+   */\n+  public synchronized Object lastElement()\n   {\n     if (elementCount == 0)\n       throw new NoSuchElementException();\n \n-    return elementData[elementCount - 1];\n+    return elementAt(elementCount - 1);\n   }\n \n-  public final int lastIndexOf(Object obj)\n+  /**\n+   * Places <b>obj</b> at <b>index</b> within the Vector.  If <b>index</b>\n+   * refers to an index outside the Vector, an ArrayIndexOutOfBoundsException\n+   * is thrown.  \n+   * \n+   * @param obj The object to store\n+   * @param index The position in the Vector to store the object\n+   * @throws ArrayIndexOutOfBoundsException the index is out of range\n+   */\n+  public synchronized void setElementAt(Object obj, int index)\n   {\n-    return lastIndexOf(obj, size()-1);\n+    if ((index < 0) || (index >= elementCount))\n+      throw new ArrayIndexOutOfBoundsException(index);\n+\n+    elementData[index] = obj;\n   }\n \n-  public final synchronized int lastIndexOf(Object obj, int idx)\n+  /**\n+   * Puts <b>element</b> into the Vector at position <b>index</b> and returns\n+   * the Object that previously occupied that position.\n+   *\n+   * @param index The index within the Vector to place the Object\n+   * @param element The Object to store in the Vector\n+   * @returns The previous object at the specified index\n+   * @throws ArrayIndexOutOfBoundsException the index is out of range\n+   *\n+   */\n+  public synchronized Object set(int index, Object element)\n   {\n-    if (idx < 0)\n-      throw new IllegalArgumentException ();\n-    for (int i = idx; i >= 0; --i)\n-      {\n-\tif (obj == null\n-\t    ? elementData[i] == null\n-\t    : obj.equals(elementData[i]))\n-\t  return i;\n-      }\n+    if (index >= elementCount)\n+      throw new ArrayIndexOutOfBoundsException(index);\n \n-    return -1;\n+    Object temp = elementData[index];\n+    elementData[index] = element;\n+    return temp;\n   }\n \n-  public final synchronized void removeAllElements()\n+  /**\n+   * Removes the element at <b>index</b>, and shifts all elements at\n+   * positions greater than index to their index - 1.  \n+   *\n+   * @param index The index of the element to remove\n+   */\n+  public synchronized void removeElementAt(int index)\n   {\n-    // Remove elements now to assist the gc in early cleanup\n-    for (int i = elementCount-1; i >= 0; --i)\n-\telementData[i] = null;\n-    elementCount = 0;\n+    if (index >= elementCount)\n+      throw new ArrayIndexOutOfBoundsException(index);\n+\n+    modCount++;\n+    elementCount--;\n+    if (index < elementCount)\n+      System.arraycopy(elementData, index + 1, elementData, index,\n+\t\t       elementCount - index);\n+    //Delete the last element (which has been copied back one index)\n+    //so it can be garbage collected;\n+    elementData[elementCount] = null;\n   }\n \n-  public final synchronized boolean removeElement(Object obj)\n+  /**\n+   * Inserts a new element into the Vector at <b>index</b>.  Any elements\n+   * at or greater than index are shifted up one position.\n+   *\n+   * @param obj The object to insert\n+   * @param index The index at which the object is inserted\n+   */\n+  public void insertElementAt(Object obj, int index)\n   {\n-    for (int i = 0; i < elementCount; i++)\n-      {\n-\tif (obj == null\n-\t    ? elementData[i] == null\n-\t    : obj.equals(elementData[i]))\n-\t  {\n-\t    int j;\n-\n-\t    // Decrement count first to ensure we don't walk off end of array\n-\t    --elementCount;\n-\n-\t    for (j = i; j < elementCount; j++)\n-\t      elementData[j] = elementData[j+1];\n-\n-\t    // At this point, j was incrememented and points to old last element\n-\t    // Remove element now to assist the gc in early cleanup\n-\t    elementData[j] = null;\n-\t    return true;\n-\t  }\n-      }\n-\n-    return false;\n+    if ((index < 0) || (index > elementCount))\n+      throw new ArrayIndexOutOfBoundsException(index);\n+\n+    ensureCapacity(++elementCount);\n+    modCount++;\n+    System.arraycopy(elementData, index, elementData, index + 1,\n+\t\t     elementCount - 1 - index);\n+    elementData[index] = obj;\n   }\n \n-  public final synchronized void removeElementAt(int idx)\n+  /**\n+   * Adds an element to the Vector at the end of the Vector.  If the vector\n+   * cannot hold the element with its present capacity, its size is increased\n+   * based on the same rules followed if ensureCapacity was called with the\n+   * argument currentSize+1.\n+   *\n+   * @param obj The object to add to the Vector\n+   */\n+  public synchronized void addElement(Object obj)\n   {\n-    int i;\n-\n-    if (idx < 0 || idx >= size())\n-      throw new ArrayIndexOutOfBoundsException();\n-\n-    // Decrement count first to ensure we don't walk off the end of the array\n-    --elementCount;\n-\n-    for (i = idx; i < elementCount; i++)\n-      elementData[i] = elementData[i+1];\n+    ensureCapacity(elementCount + 1);\n+    modCount++;\n+    elementData[elementCount++] = obj;\n+  }\n \n-    // At this point, i was incrememented and now points to the old last element\n-    // Remove element now to assist the gc in early cleanup\n-    elementData[i] = null;\n+  /**\n+   * Removes the first occurence of the given object from the Vector.\n+   * If such a remove was performed (the object was found), true is returned.\n+   * If there was no such object, false is returned.\n+   *\n+   * @param obj The object to remove from the Vector\n+   * @returns true if the Object was in the Vector, false otherwise\n+   */\n+  public synchronized boolean removeElement(Object obj)\n+  {\n+    int idx = indexOf(obj);\n+    if (idx != -1)\n+      {\n+\tremoveElementAt(idx);\n+\treturn true;\n+      }\n+    return false;\n   }\n \n-  public final synchronized void setElementAt(Object obj, int idx)\n+  /**\n+   * Removes all elements from the Vector.  Note that this does not\n+   * resize the internal data array.\n+   */\n+  public synchronized void removeAllElements()\n   {\n-    if (idx < 0 || idx >= size())\n-      throw new ArrayIndexOutOfBoundsException();\n+    modCount++;\n+    if (elementCount == 0)\n+      return;\n \n-    elementData[idx] = obj;\n+    for (int i = 0; i < elementCount; i++)\n+      {\n+\telementData[i] = null;\n+      }\n+    elementCount = 0;\n   }\n \n-  public final synchronized void setSize(int newSize)\n+  /**\n+   * Creates a new Vector with the same contents as this one.\n+   */\n+  public synchronized Object clone()\n   {\n-    if (newSize < 0)\n-      throw new ArrayIndexOutOfBoundsException();\n-\n-    // Java Lang Spec p. 658 says to remove the excess elements and discard\n-    // when new size is smaller than old size.\n-    // When truncating, we could alternatively just reset elementCount instead\n-    // of freeing up the memory if the spec hadn't specified.  The spec makes\n-    // sense though; if someone cares enough to call a setSize() function\n-    // they probably are doing so to free memory.\n-    if (newSize < elementCount)\n+    try\n       {\n-\telementCount = newSize;\n-\ttrimToSize();\n+\tVector clone = (Vector) super.clone();\n+\tclone.elementData = (Object[]) elementData.clone();\n+\treturn clone;\n       }\n-    else if (newSize > elementCount)\t// Skip == case\n+    catch (CloneNotSupportedException ex)\n       {\n-\t// TBD: ensureCapacity() may create a vector much larger than newSize;\n-\t// do we want to make the vector exactly newSize?  Spec is unclear.\n-\tensureCapacity(newSize);\n-\n-\t// Make sure to null out new elements of grown vector\n-\tfor (int i = elementCount; i < newSize; i++)\n-\t  elementData[i] = null;\n-\telementCount = newSize;\n+\tthrow new InternalError(ex.toString());\n       }\n   }\n \n-  public final int size()\n+  /**\n+   * Returns an Object array with the contents of this Vector, in the order\n+   * they are stored within this Vector.  Note that the Object array returned \n+   * is not the internal data array, and that it holds only the elements \n+   * within the Vector.  This is similar to creating a new Object[] with the \n+   * size of this Vector, then calling Vector.copyInto(yourArray).\n+   *\n+   * @returns An Object[] containing the contents of this Vector in order\n+   *\n+   */\n+  public synchronized Object[] toArray()\n   {\n-    return elementCount;\n+    Object[] newArray = new Object[elementCount];\n+    copyInto(newArray);\n+    return newArray;\n   }\n \n-  public final synchronized String toString()\n+  /**\n+   * Returns an array containing the contents of this Vector.  \n+   * If the provided array is large enough, the contents are copied\n+   * into that array, and a null is placed in the position size(). \n+   * In this manner, you can obtain the size of a Vector by the position\n+   * of the null element.  If the type of the provided array cannot \n+   * hold the elements, an ArrayStoreException is thrown.\n+   * \n+   * If the provided array is not large enough,\n+   * a new one is created with the contents of the Vector, and no null \n+   * element.  The new array is of the same runtime type as the provided\n+   * array.\n+   *\n+   *\n+   * @param array An array to copy the Vector into if large enough\n+   * @returns An array with the contents of this Vector in order\n+   * @throws ArrayStoreException the runtime type of the provided array\n+   * cannot hold the elements of the Vector\n+   */\n+  public synchronized Object[] toArray(Object[] array)\n   {\n-    // Following the Java Lang Spec p. 656\n-\n-    // Prepend first element with open bracket\n-    StringBuffer result = new StringBuffer(\"[\");\n-\n-    if (elementCount > 0)\t// add first element if one exists\n-      result.append(elementData[0].toString());\n-\n-    // Prepend subsequent elements with \", \"\n-    for (int i = 1; i < elementCount; i++)\n-      result.append(\", \").append(elementData[i].toString());\n-\n-    // Append last element with closing bracket\n-    result.append(\"]\");\n-    return result.toString();\n+    if (array.length < elementCount)\n+      array = (Object[]) Array.newInstance(array.getClass().getComponentType(), \n+        \t\t\t\t   elementCount);\n+    else\n+      array[elementCount] = null;\n+    System.arraycopy(elementData, 0, array, 0, elementCount);\n+    return array;\n   }\n \n-  public final synchronized void trimToSize()\n+  /**\n+   * Returns the element at position <b>index</b>\n+   *\n+   * @param index the position from which an element will be retrieved\n+   * @throws ArrayIndexOutOfBoundsException the index is not within the \n+   * range of the Vector\n+   */\n+  public synchronized Object get(int index)\n   {\n-    // Give up excess storage capacity to save memory\n-    //\n-    // Don't bother checking for the case where size() == the capacity of the\n-    // vector since that is a much less likely case; it's more efficient to\n-    // not do the check and lose a bit of performance in that infrequent case\n-    Object[] newArray = new Object[elementCount];\n-    System.arraycopy(elementData, 0, newArray, 0, elementCount);\n-    elementData = newArray;\n+    return elementAt(index);\n   }\n \n-  // TODO12:\n-  // public Vector(Collection c)\n-  // {\n-  // }\n-\n-  // TODO12:\n-  // public public boolean add(Object o)\n-  // {\n-  // }\n-\n-  // TODO12:\n-  // public void add(int index, Object element)\n-  // {\n-  // }\n-\n-  // TODO12:\n-  // public boolean addAll(Collection c)\n-  // {\n-  // }\n-\n-  // TODO12:\n-  // public boolean addAll(int index, Collection c)\n-  // {\n-  // }\n-\n-  // TODO12:\n-  // public void clear()\n-  // {\n-  // }\n+  /**\n+   * Removes the given Object from the Vector.  If it exists, true\n+   * is returned, if not, false is returned.\n+   *\n+   * @param o The object to remove from the Vector\n+   * @returns true if the Object existed in the Vector, false otherwise\n+   */\n+  public boolean remove(Object o)\n+  {\n+    return removeElement(o);\n+  }\n \n-  // TODO12:\n-  // public boolean containsAll(Collection c)\n-  // {\n-  // }\n+  /**\n+   * Adds an object to the Vector.\n+   *\n+   * @param o The element to add to the Vector\n+   */\n+  public synchronized boolean add(Object o)\n+  {\n+    addElement(o);\n+    return true;\n+  }\n \n-  // TODO12:\n-  // public boolean equals(Object o)\n-  // {\n-  // }\n+  /**\n+   * Adds an object at the specified index.  Elements at or above\n+   * index are shifted up one position.\n+   *\n+   * @param index The index at which to add the element\n+   * @param element The element to add to the Vector\n+   */\n+  public void add(int index, Object element)\n+  {\n+    insertElementAt(element, index);\n+  }\n \n-  // TODO12:\n-  // public int hashCode()\n-  // {\n-  // }\n+  /**\n+   * Removes the element at the specified index, and returns it.\n+   *\n+   * @param index The position from which to remove the element\n+   * @returns The object removed\n+   * @throws ArrayIndexOutOfBoundsException the index was out of the range\n+   * of the Vector\n+   */\n+  public synchronized Object remove(int index)\n+  {\n+    if (index >= elementCount)\n+      throw new ArrayIndexOutOfBoundsException(index);\n+  \n+    Object temp = elementData[index];\n+    removeElementAt(index);\n+    return temp;\n+  }\n \n-  // TODO12:\n-  // public Object get(int index)\n-  // {\n-  // }\n+  /**\n+   * Clears all elements in the Vector and sets its size to 0\n+   */\n+  public void clear()\n+  {\n+    removeAllElements();\n+  }\n \n-  public synchronized boolean remove(Object o)\n+  public synchronized boolean containsAll(Collection c)\n   {\n-    for (int i = 0; i < elementCount; ++i)\n+    Iterator itr = c.iterator();\n+    int size = c.size();\n+    for (int pos = 0; pos < size; pos++)\n       {\n-\tif (o == null\n-\t    ? elementData[i] == null\n-\t    : o.equals (elementData[i]))\n-\t  {\n-\t    System.arraycopy (elementData, i, elementData, i + 1,\n-\t\t\t      elementCount - i - 1);\n-\t    return true;\n-\t  }\n+\tif (!contains(itr.next()))\n+\t  return false;\n       }\n-    return false;\n+    return true;\n   }\n \n-  // TODO12:\n-  // public Object remove(int index)\n-  // {\n-  // }\n+  public synchronized boolean addAll(Collection c)\n+  {\n+    return addAll(elementCount, c);\n+  }\n+  \n+  public synchronized boolean removeAll(Collection c)\n+  {\n+    return super.removeAll(c);\n+  }\n+  \n+  public synchronized boolean retainAll(Collection c)\n+  {\n+    return super.retainAll(c);\n+  }\n \n-  // TODO12:\n-  // public boolean removeAll(Collection c)\n-  // {\n-  // }\n+  public synchronized boolean addAll(int index, Collection c)\n+  {\n+    if (index < 0 || index > elementCount)\n+      throw new ArrayIndexOutOfBoundsException(index);\n+    modCount++;\n+    Iterator itr = c.iterator();\n+    int csize = c.size();\n+\n+    ensureCapacity(elementCount + csize);\n+    int end = index + csize;\n+    if (elementCount > 0 && index != elementCount)\n+      System.arraycopy(elementData, index, elementData, end, csize);\n+    elementCount += csize;\n+    for (; index < end; index++)\n+      {\n+        elementData[index] = itr.next();\n+      }\n+    return (csize > 0);  \n+  }\n \n-  // TODO12:\n-  // public boolean retainAll(Collection c)\n-  // {\n-  // }\n+  public synchronized boolean equals(Object c)\n+  {\n+    return super.equals(c);\n+  }\n \n-  // TODO12:\n-  // public Object set(int index, Object element)\n-  // {\n-  // }\n+  public synchronized int hashCode()\n+  {\n+    return super.hashCode();\n+  }\n \n-  // TODO12:\n-  // public Object[] toArray()\n-  // {\n-  // }\n+  /**\n+   * Returns a string representation of this Vector in the form \n+   * [element0, element1, ... elementN]\n+   *\n+   * @returns the String representation of this Vector\n+   */\n+  public synchronized String toString()\n+  {\n+    String r = \"[\";\n+    for (int i = 0; i < elementCount; i++)\n+      {\n+\tr += elementData[i];\n+\tif (i < elementCount - 1)\n+\t  r += \", \";\n+      }\n+    r += \"]\";\n+    return r;\n+  }\n \n-  // TODO12:\n-  // public Object[] toArray(Object[] a)\n-  // {\n-  // }\n+  /**\n+   * Returns an Enumeration of the elements of this List.\n+   * The Enumeration returned is compatible behavior-wise with\n+   * the 1.1 elements() method, in that it does not check for\n+   * concurrent modification.\n+   *\n+   * @returns an Enumeration\n+   */\n+  public synchronized Enumeration elements()\n+  {\n+    return new Enumeration()\n+    {\n+      int i = 0;\n+      public boolean hasMoreElements()\n+      {\n+\treturn (i < elementCount);\n+      }\n+      public Object nextElement()\n+      {\n+\tif (i >= elementCount)\n+\t  throw new NoSuchElementException();\n+\treturn (elementAt(i++));\n+      }\n+    };\n+  }\n+  \n+  public List subList(int fromIndex, int toIndex)\n+  {\n+    List sub = super.subList(fromIndex, toIndex);\n+    return Collections.synchronizedList(sub);\n+  }\n+  \n+  /** @specnote This is not specified as synchronized in the JCL, but it seems\n+    * to me that is should be. If it isn't, a clear() operation on a sublist\n+    * will not be synchronized w.r.t. the Vector object.\n+    */\n+  protected synchronized void removeRange(int fromIndex, int toIndex)\n+  {\n+    modCount++;\n+    if (fromIndex != toIndex)\n+      {\n+\tSystem.arraycopy(elementData, toIndex, elementData, fromIndex, \n+\t                 elementCount - toIndex);\n+\telementCount -= (toIndex - fromIndex);\n+      }\n+  }\n }"}]}