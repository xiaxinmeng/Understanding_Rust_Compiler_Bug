{"sha": "37b659dd29908f5b5320f15fbe89f5c560d62464", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdiNjU5ZGQyOTkwOGY1YjUzMjBmMTVmYmU4OWY1YzU2MGQ2MjQ2NA==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2012-03-15T15:14:43Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2012-03-15T15:14:43Z"}, "message": "re PR libfortran/52434 (Insufficient number of digits in floating point formatting)\n\n2012-03-15  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        PR libfortran/52434\n        PR libfortran/48878\n        PR libfortran/38199\n        * io/unit.c (get_internal_unit): Default to ROUND_UNSPECIFIED.\n        (init_units): Likewise.\n        * io/write_float.def (determine_precision): New function.\n        (output_float): Take into account buffer with %f format, no need\n        for our own rounding if unspecified or processor specified\n        rounding.\n        (DTOA): Simplify format string, add parameters.\n        (FDTOA): New macros similar to DTOA, but using %f format.\n        (OUTPUT_FLOAT_FMT_G): Stack allocate newf, determine correct\n        precision and fill buffer.\n        (EN_PREC): New macro.\n        (determine_en_precision): New function.\n        (WRITE_FLOAT): For G format, move buffer filling into\n        output_float_FMT_G, use FDTOA for F format.\n        (write_float): Increase buffer due to F format.\n\ntestsuite ChangeLog:\n\n2012-03-15  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        PR libfortran/52434\n        PR libfortran/48878\n        PR libfortran/38199\n        * gfortran.dg/edit_real_1.f90: Don't assume roundTiesToAway.\n        * gfortran.dg/round_1.f03: Likewise.\n\nFrom-SVN: r185433", "tree": {"sha": "45e8784a537c5c9f8f7c86d17a1756db37da6e4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45e8784a537c5c9f8f7c86d17a1756db37da6e4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37b659dd29908f5b5320f15fbe89f5c560d62464", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b659dd29908f5b5320f15fbe89f5c560d62464", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37b659dd29908f5b5320f15fbe89f5c560d62464", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b659dd29908f5b5320f15fbe89f5c560d62464/comments", "author": null, "committer": null, "parents": [{"sha": "ff63ac4d66fdcd9e0952b31b5dae947ffc638814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff63ac4d66fdcd9e0952b31b5dae947ffc638814", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff63ac4d66fdcd9e0952b31b5dae947ffc638814"}], "stats": {"total": 468, "additions": 348, "deletions": 120}, "files": [{"sha": "e7cce3903ef3031d924adca6797d2398dbd42942", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b659dd29908f5b5320f15fbe89f5c560d62464/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b659dd29908f5b5320f15fbe89f5c560d62464/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=37b659dd29908f5b5320f15fbe89f5c560d62464", "patch": "@@ -1,3 +1,11 @@\n+2012-03-15  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR libfortran/52434\n+        PR libfortran/48878\n+        PR libfortran/38199\n+        * gfortran.dg/edit_real_1.f90: Don't assume roundTiesToAway.\n+        * gfortran.dg/round_1.f03: Likewise.\n+\n 2012-03-15  Jakub Jelinek  <jakub@redhat.com>\n \t    Andrew Pinski  <apinski@cavium.com>\n "}, {"sha": "594b2f17223ace2aebb43c60ef25a1e223a81aa6", "filename": "gcc/testsuite/gfortran.dg/edit_real_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b659dd29908f5b5320f15fbe89f5c560d62464/gcc%2Ftestsuite%2Fgfortran.dg%2Fedit_real_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b659dd29908f5b5320f15fbe89f5c560d62464/gcc%2Ftestsuite%2Fgfortran.dg%2Fedit_real_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fedit_real_1.f90?ref=37b659dd29908f5b5320f15fbe89f5c560d62464", "patch": "@@ -68,7 +68,7 @@ program edit_real_1\n   if (s .ne. '12.345E-01z') call abort\n   ! E format, negative scale factor\n   s = x\n-  write (s, '(-2PE10.4,A)') 1.25, \"z\"\n+  write (s, '(-2PE10.4,A)') 1.250001, \"z\"\n   if (s .ne. '0.0013E+03z') call abort\n   ! E format, single digit precision\n   s = x"}, {"sha": "f74b13791b59670cc36f5d7609b6b3ebb21e69fa", "filename": "gcc/testsuite/gfortran.dg/round_1.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b659dd29908f5b5320f15fbe89f5c560d62464/gcc%2Ftestsuite%2Fgfortran.dg%2Fround_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b659dd29908f5b5320f15fbe89f5c560d62464/gcc%2Ftestsuite%2Fgfortran.dg%2Fround_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fround_1.f03?ref=37b659dd29908f5b5320f15fbe89f5c560d62464", "patch": "@@ -20,9 +20,9 @@\n if (line.ne.\"      1.20      1.22      1.25      1.27      1.30      1.12\") call abort\n write(line, fmt(5)) 1.20, 1.22, 1.25, 1.27, 1.30, 1.125\n if (line.ne.\"      1.20      1.22      1.25      1.27      1.30      1.13\") call abort\n-write(line, fmt(6)) 1.20, 1.22, 1.25, 1.27, 1.30, 1.125\n+write(line, fmt(6)) 1.20, 1.22, 1.250001, 1.27, 1.30, 1.125\n if (line.ne.\"       1.2       1.2       1.3       1.3       1.3       1.1\") call abort\n-write(line, fmt(7)) 1.20, 1.22, 1.25, 1.27, 1.30, 1.125\n+write(line, fmt(7)) 1.20, 1.22, 1.250001, 1.27, 1.30, 1.125\n if (line.ne.\"      +1.2      +1.2      +1.3      +1.3      +1.3      +1.1\") call abort\n \n end"}, {"sha": "66f81c8fd59280790bf1c63c7a8e781220cf8b0b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b659dd29908f5b5320f15fbe89f5c560d62464/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b659dd29908f5b5320f15fbe89f5c560d62464/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=37b659dd29908f5b5320f15fbe89f5c560d62464", "patch": "@@ -1,3 +1,24 @@\n+2012-03-15  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR libfortran/52434\n+        PR libfortran/48878\n+        PR libfortran/38199\n+        * io/unit.c (get_internal_unit): Default to ROUND_UNSPECIFIED.\n+        (init_units): Likewise.\n+        * io/write_float.def (determine_precision): New function.\n+        (output_float): Take into account buffer with %f format, no need\n+        for our own rounding if unspecified or processor specified\n+        rounding.\n+        (DTOA): Simplify format string, add parameters.\n+        (FDTOA): New macros similar to DTOA, but using %f format.\n+        (OUTPUT_FLOAT_FMT_G): Stack allocate newf, determine correct\n+        precision and fill buffer.\n+        (EN_PREC): New macro.\n+        (determine_en_precision): New function.\n+        (WRITE_FLOAT): For G format, move buffer filling into\n+        output_float_FMT_G, use FDTOA for F format.\n+        (write_float): Increase buffer due to F format.\n+\n 2012-03-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* intrinsics/c99_functions.c [__sgi__ && !HAVE_COMPLEX_H]: Remove."}, {"sha": "819d0e9c0083750b7275e0009819ea286d16be05", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b659dd29908f5b5320f15fbe89f5c560d62464/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b659dd29908f5b5320f15fbe89f5c560d62464/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=37b659dd29908f5b5320f15fbe89f5c560d62464", "patch": "@@ -453,7 +453,7 @@ get_internal_unit (st_parameter_dt *dtp)\n   iunit->flags.decimal = DECIMAL_POINT;\n   iunit->flags.encoding = ENCODING_DEFAULT;\n   iunit->flags.async = ASYNC_NO;\n-  iunit->flags.round = ROUND_COMPATIBLE;\n+  iunit->flags.round = ROUND_UNSPECIFIED;\n \n   /* Initialize the data transfer parameters.  */\n \n@@ -543,7 +543,7 @@ init_units (void)\n       u->flags.decimal = DECIMAL_POINT;\n       u->flags.encoding = ENCODING_DEFAULT;\n       u->flags.async = ASYNC_NO;\n-      u->flags.round = ROUND_COMPATIBLE;\n+      u->flags.round = ROUND_UNSPECIFIED;\n      \n       u->recl = options.default_recl;\n       u->endfile = NO_ENDFILE;\n@@ -573,7 +573,7 @@ init_units (void)\n       u->flags.decimal = DECIMAL_POINT;\n       u->flags.encoding = ENCODING_DEFAULT;\n       u->flags.async = ASYNC_NO;\n-      u->flags.round = ROUND_COMPATIBLE;\n+      u->flags.round = ROUND_UNSPECIFIED;\n \n       u->recl = options.default_recl;\n       u->endfile = AT_ENDFILE;\n@@ -603,7 +603,7 @@ init_units (void)\n       u->flags.decimal = DECIMAL_POINT;\n       u->flags.encoding = ENCODING_DEFAULT;\n       u->flags.async = ASYNC_NO;\n-      u->flags.round = ROUND_COMPATIBLE;\n+      u->flags.round = ROUND_UNSPECIFIED;\n \n       u->recl = options.default_recl;\n       u->endfile = AT_ENDFILE;"}, {"sha": "7882c903d7e5c4013fe9468e6552457111ea06e1", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 312, "deletions": 113, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b659dd29908f5b5320f15fbe89f5c560d62464/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b659dd29908f5b5320f15fbe89f5c560d62464/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=37b659dd29908f5b5320f15fbe89f5c560d62464", "patch": "@@ -1,4 +1,5 @@\n-/* Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n+/* Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012 \n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Write float code factoring to this file by Jerry DeLisle   \n    F2003 I/O support contributed by Jerry DeLisle\n@@ -59,11 +60,60 @@ calculate_sign (st_parameter_dt *dtp, int negative_flag)\n }\n \n \n+/* Determine the precision except for EN format. For G format,\n+   determines an upper bound to be used for sizing the buffer. */\n+\n+static int\n+determine_precision (st_parameter_dt * dtp, const fnode * f, int len)\n+{\n+  int precision = f->u.real.d;\n+\n+  switch (f->format)\n+    {\n+    case FMT_F:\n+    case FMT_G:\n+      precision += dtp->u.p.scale_factor;\n+      break;\n+    case FMT_ES:\n+      /* Scale factor has no effect on output.  */\n+      break;\n+    case FMT_E:\n+    case FMT_D:\n+      /* See F2008 10.7.2.3.3.6 */\n+      if (dtp->u.p.scale_factor <= 0)\n+\tprecision += dtp->u.p.scale_factor - 1;\n+      break;\n+    default:\n+      return -1;\n+    }\n+\n+  /* If the scale factor has a large negative value, we must do our\n+     own rounding? Use ROUND='NEAREST', which should be what snprintf\n+     is using as well.  */\n+  if (precision < 0 && \n+      (dtp->u.p.current_unit->round_status == ROUND_UNSPECIFIED \n+       || dtp->u.p.current_unit->round_status == ROUND_PROCDEFINED))\n+    dtp->u.p.current_unit->round_status = ROUND_NEAREST;\n+\n+  /* Add extra guard digits up to at least full precision when we do\n+     our own rounding.  */\n+  if (dtp->u.p.current_unit->round_status != ROUND_UNSPECIFIED\n+      && dtp->u.p.current_unit->round_status != ROUND_PROCDEFINED)\n+    {\n+      precision += 2 * len + 4;\n+      if (precision < 0)\n+\tprecision = 0;\n+    }\n+\n+  return precision;\n+}\n+\n+\n /* Output a real number according to its format which is FMT_G free.  */\n \n static try\n-output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size, \n-\t      int sign_bit, bool zero_flag, int ndigits, int edigits)\n+output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n+\t      int nprinted, int precision, int sign_bit, bool zero_flag)\n {\n   char *out;\n   char *digits;\n@@ -80,6 +130,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n   int nzero_real;\n   int leadzero;\n   int nblanks;\n+  int ndigits, edigits;\n   sign_t sign;\n \n   ft = f->format;\n@@ -96,50 +147,97 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \n   sign = calculate_sign (dtp, sign_bit);\n   \n-  /* The following code checks the given string has punctuation in the correct\n-     places.  Uncomment if needed for debugging.\n-     if (d != 0 && ((buffer[2] != '.' && buffer[2] != ',')\n-\t\t    || buffer[ndigits + 2] != 'e'))\n-       internal_error (&dtp->common, \"printf is broken\");  */\n+  /* Calculate total number of digits.  */\n+  if (ft == FMT_F)\n+    ndigits = nprinted - 2;\n+  else\n+    ndigits = precision + 1;\n \n   /* Read the exponent back in.  */\n-  e = atoi (&buffer[ndigits + 3]) + 1;\n+  if (ft != FMT_F)\n+    e = atoi (&buffer[ndigits + 3]) + 1;\n+  else\n+    e = 0;\n \n   /* Make sure zero comes out as 0.0e0.   */\n   if (zero_flag)\n     e = 0;\n \n   /* Normalize the fractional component.  */\n-  buffer[2] = buffer[1];\n-  digits = &buffer[2];\n+  if (ft != FMT_F)\n+    {\n+      buffer[2] = buffer[1];\n+      digits = &buffer[2];\n+    }\n+  else\n+    digits = &buffer[1];\n \n   /* Figure out where to place the decimal point.  */\n   switch (ft)\n     {\n     case FMT_F:\n-      if (d == 0 && e <= 0 && p == 0)\n+      nbefore = ndigits - precision;\n+      /* Make sure the decimal point is a '.'; depending on the\n+\t locale, this might not be the case otherwise.  */\n+      digits[nbefore] = '.';\n+      if (digits[0] == '0' && nbefore == 1)\n \t{\n-\t  memmove (digits + 1, digits, ndigits - 1);\n-\t  digits[0] = '0';\n-\t  e++;\n+\t  digits++;\n+\t  nbefore--;\n+\t  ndigits--;\n \t}\n-\n-      nbefore = e + p;\n-      if (nbefore < 0)\n+      //printf(\"nbefore: %d, digits: %s\\n\", nbefore, digits);\n+      if (p != 0)\n \t{\n-\t  nzero = -nbefore;\n-          nzero_real = nzero;\n-\t  if (nzero > d)\n-\t    nzero = d;\n-\t  nafter = d - nzero;\n-\t  nbefore = 0;\n+\t  if (p > 0)\n+\t    {\n+\t      \n+\t      memmove (digits + nbefore, digits + nbefore + 1, p);\n+\t      digits[nbefore + p] = '.';\n+\t      nbefore += p;\n+\t      nafter = d - p;\n+\t      if (nafter < 0)\n+\t\tnafter = 0;\n+\t      nafter = d;\n+\t      nzero = nzero_real = 0;\n+\t      //printf(\"digits: %s\\n\", digits);\n+\t    }\n+\t  else /* p < 0  */\n+\t    {\n+\t      if (nbefore + p >= 0)\n+\t\t{\n+\t\t  nzero = 0;\n+\t\t  memmove (digits + nbefore + p + 1, digits + nbefore + p, -p);\n+\t\t  nbefore += p;\n+\t\t  digits[nbefore] = '.';\n+\t\t  nafter = d;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  nzero = -(nbefore + p);\n+\t\t  memmove (digits + 1, digits, nbefore);\n+\t\t  digits++;\n+\t\t  nafter = d + nbefore;\n+\t\t  nbefore = 0;\n+\t\t}\n+\t      nzero_real = nzero;\n+\t      if (nzero > d)\n+\t\tnzero = d;\n+\t    }\n \t}\n       else\n \t{\n-\t  nzero = 0;\n+\t  nzero = nzero_real = 0;\n \t  nafter = d;\n \t}\n+\n       expchar = 0;\n+      /* If we need to do rounding ourselves, get rid of the dot by\n+\t moving the fractional part.  */\n+      if (dtp->u.p.current_unit->round_status != ROUND_UNSPECIFIED\n+\t  && dtp->u.p.current_unit->round_status != ROUND_PROCDEFINED)\n+\tmemmove (digits + nbefore, digits + nbefore + 1, ndigits - nbefore);\n+      //printf(\"nbefore after p handling: %d, digits: %s\\n\", nbefore, digits);\n       break;\n \n     case FMT_E:\n@@ -222,10 +320,16 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n   if (zero_flag)\n     goto skip;\n \n-  /* Round the value.  The value being rounded is an unsigned magnitude.\n-     The ROUND_COMPATIBLE is rounding away from zero when there is a tie.  */\n+  /* Round the value.  The value being rounded is an unsigned magnitude.  */\n   switch (dtp->u.p.current_unit->round_status)\n     {\n+      /* For processor defined and unspecified rounding we use\n+\t snprintf to print the exact number of digits needed, and thus\n+\t let snprintf handle the rounding.  On system claiming support\n+\t for IEEE 754, this ought to be round to nearest, ties to\n+\t even, corresponding to the Fortran ROUND='NEAREST'.  */\n+      case ROUND_PROCDEFINED: \n+      case ROUND_UNSPECIFIED:\n       case ROUND_ZERO: /* Do nothing and truncation occurs.  */\n \tgoto skip;\n       case ROUND_UP:\n@@ -240,6 +344,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \t/* Round compatible unless there is a tie. A tie is a 5 with\n \t   all trailing zero's.  */\n \ti = nafter + nbefore;\n+\t//printf(\"I = %d, digits = %s, nbefore = %d\\n\", i, digits, nbefore);\n \tif (digits[i] == '5')\n \t  {\n \t    for(i++ ; i < ndigits; i++)\n@@ -262,9 +367,8 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \t\t  goto skip;\n \t      }\n \t  }\n-\t /* Fall through.  */ \n-      case ROUND_PROCDEFINED:\n-      case ROUND_UNSPECIFIED:\n+\t/* Fall through.  */\n+\t/* The ROUND_COMPATIBLE is rounding away from zero when there is a tie.  */\n       case ROUND_COMPATIBLE:\n \trchar = '5';\n \tgoto do_rnd;\n@@ -300,6 +404,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n   else if (nbefore + nafter < ndigits)\n     {\n       i = ndigits = nbefore + nafter;\n+      //printf(\"i: %d, digits: %s, nbefore: %d, nafter: %d\\n\", i, digits, nbefore, nafter);\n       if (digits[i] >= rchar)\n \t{\n \t  /* Propagate the carry.  */\n@@ -384,7 +489,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n      rounding completed above.  */\n   for (i = 0; i < ndigits; i++)\n     {\n-      if (digits[i] != '0')\n+      if (digits[i] != '0' && digits[i] != '.')\n \tbreak;\n     }\n \n@@ -502,6 +607,10 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n       /* Output the decimal point.  */\n       *(out4++) = dtp->u.p.current_unit->decimal_status\n \t\t    == DECIMAL_POINT ? '.' : ',';\n+      if (ft == FMT_F \n+\t  && (dtp->u.p.current_unit->round_status == ROUND_UNSPECIFIED \n+\t      || dtp->u.p.current_unit->round_status == ROUND_PROCDEFINED))\n+\tdigits++;\n \n       /* Output leading zeros after the decimal point.  */\n       if (nzero > 0)\n@@ -590,6 +699,10 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \n   /* Output the decimal point.  */\n   *(out++) = dtp->u.p.current_unit->decimal_status == DECIMAL_POINT ? '.' : ',';\n+  if (ft == FMT_F\n+\t  && (dtp->u.p.current_unit->round_status == ROUND_UNSPECIFIED \n+\t      || dtp->u.p.current_unit->round_status == ROUND_PROCDEFINED))\n+    digits++;\n \n   /* Output leading zeros after the decimal point.  */\n   if (nzero > 0)\n@@ -634,9 +747,6 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n       dtp->u.p.no_leading_blank = 0;\n     }\n \n-#undef STR\n-#undef STR1\n-#undef MIN_FIELD_WIDTH\n   return SUCCESS;\n }\n \n@@ -798,6 +908,61 @@ CALCULATE_EXP(16)\n #endif\n #undef CALCULATE_EXP\n \n+\n+/* Define a macro to build code for write_float.  */\n+\n+  /* Note: Before output_float is called, snprintf is used to print to buffer the\n+     number in the format +D.DDDDe+ddd. \n+\n+     #   The result will always contain a decimal point, even if no\n+\t digits follow it\n+\n+     -   The converted value is to be left adjusted on the field boundary\n+\n+     +   A sign (+ or -) always be placed before a number\n+\n+     *   prec is used as the precision\n+\n+     e format: [-]d.ddde\u00c2\u00b1dd where there is one digit before the\n+       decimal-point character and the number of digits after it is\n+       equal to the precision. The exponent always contains at least two\n+       digits; if the value is zero, the exponent is 00.  */\n+\n+\n+#define TOKENPASTE(x, y) TOKENPASTE2(x, y)\n+#define TOKENPASTE2(x, y) x ## y\n+\n+#define DTOA(suff,prec,val) TOKENPASTE(DTOA2,suff)(prec,val)\n+\n+#define DTOA2(prec,val)\t\t\t\t\t\\\n+snprintf (buffer, size, \"%+-#.*e\", (prec), (val))\n+\n+#define DTOA2L(prec,val)\t\t\t\t\\\n+snprintf (buffer, size, \"%+-#.*Le\", (prec), (val))\n+\n+\n+#if defined(GFC_REAL_16_IS_FLOAT128)\n+#define DTOA2Q(prec,val)\t\t\t\t\t\t\t\\\n+__qmath_(quadmath_snprintf) (buffer, size, \"%+-#.*Qe\", (prec), (val))\n+#endif\n+\n+#define FDTOA(suff,prec,val) TOKENPASTE(FDTOA2,suff)(prec,val)\n+\n+/* For F format, we print to the buffer with f format.  */\n+#define FDTOA2(prec,val)\t\t\t\t\t\t\t\\\n+snprintf (buffer, size, \"%+-#.*f\", (prec), (val))\n+\n+#define FDTOA2L(prec,val)\t\t\t\t\t\t\\\n+snprintf (buffer, size, \"%+-#.*Lf\", (prec), (val))\n+\n+\n+#if defined(GFC_REAL_16_IS_FLOAT128)\n+#define FDTOA2Q(prec,val)\t\t\t       \\\n+__qmath_(quadmath_snprintf) (buffer, size, \"%+-#.*Qf\", \\\n+\t\t\t     (prec), (val))\n+#endif\n+\n+\n /* Generate corresponding I/O format for FMT_G and output.\n    The rules to translate FMT_G to FMT_E or FMT_F from DEC fortran\n    LRM (table 11-2, Chapter 11, \"I/O Formatting\", P11-25) is:\n@@ -817,26 +982,25 @@ CALCULATE_EXP(16)\n \t  for rounding modes adjustment, r, See Fortran F2008 10.7.5.2.2\n \t  the asm volatile is required for 32-bit x86 platforms.  */\n \n-#define OUTPUT_FLOAT_FMT_G(x) \\\n+#define OUTPUT_FLOAT_FMT_G(x,y)\t\t\t\\\n static void \\\n output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n \t\t      GFC_REAL_ ## x m, char *buffer, size_t size, \\\n-\t\t      int sign_bit, bool zero_flag, int ndigits, \\\n-                      int edigits, int comp_d) \\\n+\t\t\t  int sign_bit, bool zero_flag, int comp_d) \\\n { \\\n   int e = f->u.real.e;\\\n   int d = f->u.real.d;\\\n   int w = f->u.real.w;\\\n-  fnode *newf;\\\n+  fnode newf;\\\n   GFC_REAL_ ## x rexp_d, r = 0.5;\\\n   int low, high, mid;\\\n   int ubound, lbound;\\\n   char *p, pad = ' ';\\\n   int save_scale_factor, nb = 0;\\\n   try result;\\\n+  int nprinted, precision;\\\n \\\n   save_scale_factor = dtp->u.p.scale_factor;\\\n-  newf = (fnode *) get_mem (sizeof (fnode));\\\n \\\n   switch (dtp->u.p.current_unit->round_status)\\\n     {\\\n@@ -858,11 +1022,13 @@ output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n       || ((m == 0.0) && !(compile_options.allow_std\\\n \t\t\t  & (GFC_STD_F2003 | GFC_STD_F2008))))\\\n     { \\\n-      newf->format = FMT_E;\\\n-      newf->u.real.w = w;\\\n-      newf->u.real.d = d - comp_d;\\\n-      newf->u.real.e = e;\\\n+      newf.format = FMT_E;\\\n+      newf.u.real.w = w;\\\n+      newf.u.real.d = d - comp_d;\\\n+      newf.u.real.e = e;\\\n       nb = 0;\\\n+      precision = determine_precision (dtp, &newf, x);\\\n+      nprinted = DTOA(y,precision,m);\t\t\t     \\\n       goto finish;\\\n     }\\\n \\\n@@ -905,17 +1071,18 @@ output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n \\\n   nb = e <= 0 ? 4 : e + 2;\\\n   nb = nb >= w ? w - 1 : nb;\\\n-  newf->format = FMT_F;\\\n-  newf->u.real.w = w - nb;\\\n-  newf->u.real.d = m == 0.0 ? d - 1 : -(mid - d - 1) ;\\\n+  newf.format = FMT_F;\\\n+  newf.u.real.w = w - nb;\\\n+  newf.u.real.d = m == 0.0 ? d - 1 : -(mid - d - 1) ;\\\n   dtp->u.p.scale_factor = 0;\\\n+  precision = determine_precision (dtp, &newf, x);\t\\\n+  nprinted = FDTOA(y,precision,m);\t\t\t\t\t\\\n \\\n  finish:\\\n-  result = output_float (dtp, newf, buffer, size, sign_bit, zero_flag, \\\n-\t\t\t ndigits, edigits);\\\n+    result = output_float (dtp, &newf, buffer, size, nprinted, precision,\\\n+\t\t\t   sign_bit, zero_flag);\\\n   dtp->u.p.scale_factor = save_scale_factor;\\\n \\\n-  free (newf);\\\n \\\n   if (nb > 0 && !dtp->u.p.g0_no_blanks)\\\n     {\\\n@@ -934,59 +1101,96 @@ output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n     }\\\n }\\\n \n-OUTPUT_FLOAT_FMT_G(4)\n+OUTPUT_FLOAT_FMT_G(4,)\n \n-OUTPUT_FLOAT_FMT_G(8)\n+OUTPUT_FLOAT_FMT_G(8,)\n \n #ifdef HAVE_GFC_REAL_10\n-OUTPUT_FLOAT_FMT_G(10)\n+OUTPUT_FLOAT_FMT_G(10,L)\n #endif\n \n #ifdef HAVE_GFC_REAL_16\n-OUTPUT_FLOAT_FMT_G(16)\n+# ifdef GFC_REAL_16_IS_FLOAT128\n+OUTPUT_FLOAT_FMT_G(16,Q)\n+#else\n+OUTPUT_FLOAT_FMT_G(16,L)\n+#endif\n #endif\n \n #undef OUTPUT_FLOAT_FMT_G\n \n \n-/* Define a macro to build code for write_float.  */\n-\n-  /* Note: Before output_float is called, snprintf is used to print to buffer the\n-     number in the format +D.DDDDe+ddd. For an N digit exponent, this gives us\n-     (MIN_FIELD_WIDTH-5)-N digits after the decimal point, plus another one\n-     before the decimal point.\n-\n-     #   The result will always contain a decimal point, even if no\n-\t digits follow it\n-\n-     -   The converted value is to be left adjusted on the field boundary\n+/* EN format is tricky since the number of significant digits depends\n+   on the magnitude.  Solve it by first printing a temporary value and\n+   figure out the number of significant digits from the printed\n+   exponent.  */\n \n-     +   A sign (+ or -) always be placed before a number\n-\n-     MIN_FIELD_WIDTH  minimum field width\n+#define EN_PREC(x,y)\\\n+{\\\n+    GFC_REAL_ ## x tmp;\t\t\t\t\\\n+    tmp = * (GFC_REAL_ ## x *)source;\t\t\t\t\\\n+    if (isfinite (tmp))\t\t\t\t\t\t\\\n+      nprinted = DTOA(y,0,tmp);\t\t\t\t\t\\\n+    else\\\n+      nprinted = -1;\\\n+}\\\n \n-     *   (ndigits-1) is used as the precision\n+static int\n+determine_en_precision (st_parameter_dt *dtp, const fnode *f, \n+\t\t\tconst char *source, int len)\n+{\n+  int nprinted;\n+  char buffer[10];\n+  const size_t size = 10;\n \n-     e format: [-]d.ddde\u00c2\u00b1dd where there is one digit before the\n-       decimal-point character and the number of digits after it is\n-       equal to the precision. The exponent always contains at least two\n-       digits; if the value is zero, the exponent is 00.  */\n+  switch (len)\n+    {\n+    case 4:\n+      EN_PREC(4,)\n+      break;\n \n-#define DTOA \\\n-snprintf (buffer, size, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n-\t  \"e\", ndigits - 1, tmp);\n+    case 8:\n+      EN_PREC(8,)\n+      break;\n \n-#define DTOAL \\\n-snprintf (buffer, size, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n-\t  \"Le\", ndigits - 1, tmp);\n+#ifdef HAVE_GFC_REAL_10\n+    case 10:\n+      EN_PREC(10,L)\n+      break;\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+    case 16:\n+# ifdef GFC_REAL_16_IS_FLOAT128\n+      EN_PREC(16,Q)\n+# else\n+      EN_PREC(16,L)\n+# endif\n+      break;\n+#endif\n+    default:\n+      internal_error (NULL, \"bad real kind\");\n+    }\n \n+  if (nprinted == -1)\n+    return -1;\n \n-#if defined(GFC_REAL_16_IS_FLOAT128)\n-#define DTOAQ \\\n-__qmath_(quadmath_snprintf) (buffer, sizeof buffer, \\\n-\t\t\t     \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n-\t\t\t     \"Qe\", ndigits - 1, tmp);\n-#endif\n+  int e = atoi (&buffer[5]);\n+  int nbefore; /* digits before decimal point - 1.  */\n+  if (e >= 0)\n+    nbefore = e % 3;\n+  else\n+    {\n+      nbefore = (-e) % 3;\n+      if (nbefore != 0)\n+\tnbefore = 3 - nbefore;\n+    }\n+  int prec = f->u.real.d + nbefore;\n+  if (dtp->u.p.current_unit->round_status != ROUND_UNSPECIFIED\n+      && dtp->u.p.current_unit->round_status != ROUND_PROCDEFINED)\n+    prec += 2 * len + 4;\n+  return prec;\n+}\n+  \n \n #define WRITE_FLOAT(x,y)\\\n {\\\n@@ -1000,15 +1204,18 @@ __qmath_(quadmath_snprintf) (buffer, sizeof buffer, \\\n \t  }\\\n \ttmp = sign_bit ? -tmp : tmp;\\\n \tzero_flag = (tmp == 0.0);\\\n-\\\n-\tDTOA ## y\\\n-\\\n-\tif (f->format != FMT_G)\\\n-\t  output_float (dtp, f, buffer, size, sign_bit, zero_flag, ndigits, \\\n-\t\t\tedigits);\\\n-\telse \\\n+\tif (f->format == FMT_G)\\\n \t  output_float_FMT_G_ ## x (dtp, f, tmp, buffer, size, sign_bit, \\\n-\t\t\t\t    zero_flag, ndigits, edigits, comp_d);\\\n+\t\t\t\t    zero_flag, comp_d);\\\n+\telse\\\n+\t  {\\\n+\t    if (f->format == FMT_F)\\\n+\t      nprinted = FDTOA(y,precision,tmp);\t\t\\\n+\t    else\\\n+\t      nprinted = DTOA(y,precision,tmp);\t\t\t\t\t\\\n+\t    output_float (dtp, f, buffer, size, nprinted, precision,\\\n+\t\t\t  sign_bit, zero_flag);\\\n+\t  }\\\n }\\\n \n /* Output a real number according to its format.  */\n@@ -1017,29 +1224,21 @@ static void\n write_float (st_parameter_dt *dtp, const fnode *f, const char *source, \\\n             int len, int comp_d)\n {\n-\n-#if defined(HAVE_GFC_REAL_16) || __LDBL_DIG__ > 18\n-# define MIN_FIELD_WIDTH 49\n-#else\n-# define MIN_FIELD_WIDTH 32\n-#endif\n-#define STR(x) STR1(x)\n-#define STR1(x) #x\n-\n-  /* This must be large enough to accurately hold any value.  */\n-  char buffer[MIN_FIELD_WIDTH+1];\n-  int sign_bit, ndigits, edigits;\n+  int sign_bit, nprinted;\n+  int precision;  /* Precision for snprintf call.  */\n   bool zero_flag;\n-  size_t size;\n-\n-  size = MIN_FIELD_WIDTH+1;\n \n-  /* printf pads blanks for us on the exponent so we just need it big enough\n-     to handle the largest number of exponent digits expected.  */\n-  edigits=4;\n-\n-  /* Always convert at full precision to avoid double rounding.  */\n-    ndigits = MIN_FIELD_WIDTH - 4 - edigits;\n+  if (f->format != FMT_EN)\n+    precision = determine_precision (dtp, f, len);\n+  else\n+    precision = determine_en_precision (dtp, f, source, len);\n+\n+  /* 4932 is the maximum exponent of long double and quad precision, 3\n+     extra characters for the sign, the decimal point, and the\n+     trailing null, and finally some extra digits depending on the\n+     requested precision.  */\n+  const size_t size = 4932 + 3 + precision;\n+  char buffer[size];\n \n   switch (len)\n     {"}]}