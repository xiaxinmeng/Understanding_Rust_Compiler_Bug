{"sha": "5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRhY2U0YmY5MGVlMzExNDI0YWM2MjVmOWMxZTJhOTY5M2RmMWJhOQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-06-18T18:04:19Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-06-18T18:04:19Z"}, "message": "re PR fortran/52473 (CSHIFT slow - inline it?)\n\n2017-06-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/52473\n\t* m4/cshift0.m4:  For arrays that are contiguous up to\n\tshift, implement blocked algorighm for cshift.\n\t* generated/cshift0_c10.c:  Regenerated.\n\t* generated/cshift0_c16.c:  Regenerated.\n\t* generated/cshift0_c4.c:  Regenerated.\n\t* generated/cshift0_c8.c:  Regenerated.\n\t* generated/cshift0_i1.c:  Regenerated.\n\t* generated/cshift0_i16.c:  Regenerated.\n\t* generated/cshift0_i2.c:  Regenerated.\n\t* generated/cshift0_i4.c:  Regenerated.\n\t* generated/cshift0_i8.c:  Regenerated.\n\t* generated/cshift0_r10.c:  Regenerated.\n\t* generated/cshift0_r16.c:  Regenerated.\n\t* generated/cshift0_r4.c:  Regenerated.\n\t* generated/cshift0_r8.c:  Regenerated.\n\n2017-06-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/52473\n\t* gfortran.dg/cshift_1.f90:  New test.\n\nFrom-SVN: r249350", "tree": {"sha": "852c9d2c93ad852ec9673a736e9bb2af9f66044e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/852c9d2c93ad852ec9673a736e9bb2af9f66044e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/comments", "author": null, "committer": null, "parents": [{"sha": "82aa64e5af95fd64702fec1ecc966d738deed975", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82aa64e5af95fd64702fec1ecc966d738deed975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82aa64e5af95fd64702fec1ecc966d738deed975"}], "stats": {"total": 1770, "additions": 1434, "deletions": 336}, "files": [{"sha": "9200ee89f86f988c782d1cde8b6633c9b03caef5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -1,3 +1,8 @@\n+2017-06-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/52473\n+\t* gfortran.dg/cshift_1.f90:  New test.\n+\n 2017-06-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tRemove dg-skip-if, dg-xfail-if, dg-xfail-run-if default args."}, {"sha": "e2024ea99dddd4c0a362e88d8dbbb229251a54cf", "filename": "gcc/testsuite/gfortran.dg/cshift_1.f90", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_1.f90?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -0,0 +1,108 @@\n+! { dg-do  run }\n+! Take cshift through its paces to make sure no boundary\n+! cases are wrong.\n+\n+module kinds\n+  integer, parameter :: sp = selected_real_kind(6) ! Single precision\n+end module kinds\n+\n+module replacements\n+  use kinds\n+contains\n+  subroutine cshift_sp_3_v1 (array, shift, dim, res)\n+    integer, parameter :: wp = sp\n+    real(kind=wp), dimension(:,:,:), intent(in) :: array\n+    integer, intent(in) :: shift, dim\n+    real(kind=wp), dimension(:,:,:), intent(out) :: res\n+    integer :: i,j,k\n+    integer :: sh, rsh\n+    integer :: n\n+    integer :: n2, n3\n+    res = 0\n+    n3 = size(array,3)\n+    n2 = size(array,2)\n+    n1 = size(array,1)\n+    if (dim == 1) then\n+       n = n1\n+       sh = modulo(shift, n)\n+       rsh = n - sh\n+       do k=1, n3\n+          do j=1, n2\n+             do i=1, rsh\n+                res(i,j,k) = array(i+sh,j,k)\n+             end do\n+             do i=rsh+1,n\n+                res(i,j,k) = array(i-rsh,j,k)\n+             end do\n+          end do\n+       end do\n+    else if (dim == 2) then\n+       n = n2\n+       sh = modulo(shift,n)\n+       rsh = n - sh\n+       do k=1, n3\n+          do j=1, rsh\n+             do i=1, n1\n+                res(i,j,k) = array(i,j+sh, k)\n+             end do\n+          end do\n+          do j=rsh+1, n\n+             do i=1, n1\n+                res(i,j,k) = array(i,j-rsh, k)\n+             end do\n+          end do\n+       end do\n+    else if (dim == 3) then\n+       n = n3\n+       sh = modulo(shift, n)\n+       rsh = n - sh\n+       do k=1, rsh\n+          do j=1, n2\n+             do i=1, n1\n+                res(i,j,k) = array(i, j, k+sh)\n+             end do\n+          end do\n+       end do\n+       do k=rsh+1, n\n+          do j=1, n2\n+             do i=1, n1\n+                res(i,j, k) = array(i, j, k-rsh)\n+             end do\n+          end do          \n+       end do\n+    else\n+       stop \"Wrong argument to dim\"\n+    end if\n+  end subroutine cshift_sp_3_v1\n+end module replacements\n+\n+program testme\n+  use kinds\n+  use replacements\n+  implicit none\n+  integer, parameter :: wp = sp  ! Working precision\n+  INTEGER, PARAMETER :: n = 7\n+  real(kind=wp), dimension(:,:,:), allocatable :: a,b,c\n+  integer i, j, k\n+  real:: t1, t2\n+  integer, parameter :: nrep = 20\n+\n+  allocate (a(n,n,n), b(n,n,n),c(n,n,n))\n+  call random_number(a)\n+  do k = 1,3\n+   do i=-3,3,2\n+     call cshift_sp_3_v1 (a, i, k, b)\n+     c = cshift(a,i,k)\n+     if (any (c /= b)) call abort\n+   end do\n+  end do\n+  deallocate (b,c)\n+  allocate (b(n-1,n-1,n-1),c(n-1,n-1,n-1))\n+  do k=1,3\n+     do i=-3,3,2\n+        call cshift_sp_3_v1 (a(1:n-1,1:n-1,1:n-1), i, k, b)\n+        c = cshift(a(1:n-1,1:n-1,1:n-1), i, k)\n+        if (any (c /= b)) call abort\n+     end do\n+  end do\n+end program testme"}, {"sha": "4f7b79dc12a284e4324b7365eb7b99bed123ef13", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -1,3 +1,22 @@\n+2017-06-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/52473\n+\t* m4/cshift0.m4:  For arrays that are contiguous up to\n+\tshift, implement blocked algorighm for cshift.\n+\t* generated/cshift0_c10.c:  Regenerated.\n+\t* generated/cshift0_c16.c:  Regenerated.\n+\t* generated/cshift0_c4.c:  Regenerated.\n+\t* generated/cshift0_c8.c:  Regenerated.\n+\t* generated/cshift0_i1.c:  Regenerated.\n+\t* generated/cshift0_i16.c:  Regenerated.\n+\t* generated/cshift0_i2.c:  Regenerated.\n+\t* generated/cshift0_i4.c:  Regenerated.\n+\t* generated/cshift0_i8.c:  Regenerated.\n+\t* generated/cshift0_r10.c:  Regenerated.\n+\t* generated/cshift0_r16.c:  Regenerated.\n+\t* generated/cshift0_r4.c:  Regenerated.\n+\t* generated/cshift0_r8.c:  Regenerated.\n+\n 2017-06-06  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/80975"}, {"sha": "120ea91bea764263d0aa47726022f35a8288b369", "filename": "libgfortran/generated/cshift0_c10.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c10.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "821cf29c2d6221e0d3fd92795eacf9da0e984b63", "filename": "libgfortran/generated/cshift0_c16.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c16.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "83c751e2787060fab3eec7b6d22a45eed0779022", "filename": "libgfortran/generated/cshift0_c4.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c4.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "920f05735ad2e248dda2d9437815961b49632190", "filename": "libgfortran/generated/cshift0_c8.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c8.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "320134da22182cfd780847811d323a5771a3d93e", "filename": "libgfortran/generated/cshift0_i1.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i1.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "ca1fa3b82539fdf67b6a9ac021b4d1fba07dfb08", "filename": "libgfortran/generated/cshift0_i16.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i16.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "841ae38292b0e7f2d1b88401000ba93e8bd551bc", "filename": "libgfortran/generated/cshift0_i2.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i2.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "87713655d6a5865cf530a3d45e1f0aecd59c529e", "filename": "libgfortran/generated/cshift0_i4.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i4.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "7c55358fee8a445be7dd8557d816209696188f9f", "filename": "libgfortran/generated/cshift0_i8.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i8.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "c2f5ca687caccc9bab7648eab84765b9b6a125ea", "filename": "libgfortran/generated/cshift0_r10.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r10.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "abbea68a4f852936131a4f9a3c7759feb3f843f6", "filename": "libgfortran/generated/cshift0_r16.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r16.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "0788566096449c52425b15fa091cc2de7332b36c", "filename": "libgfortran/generated/cshift0_r4.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r4.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "13e3a5c02d43553a057c4449c4b33c02d998e0b5", "filename": "libgfortran/generated/cshift0_r8.c", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fgenerated%2Fcshift0_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r8.c?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -51,6 +51,9 @@ cshift0_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -63,33 +66,99 @@ cshift0_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}, {"sha": "04459d72195d023cb9b9cb385b07dc4272771a61", "filename": "libgfortran/m4/cshift0.m4", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fm4%2Fcshift0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dace4bf90ee311424ac625f9c1e2a9693df1ba9/libgfortran%2Fm4%2Fcshift0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fcshift0.m4?ref=5dace4bf90ee311424ac625f9c1e2a9693df1ba9", "patch": "@@ -52,6 +52,9 @@ cshift0_'rtype_code` ('rtype` *ret, const 'rtype` *array, ptrdiff_t shift,\n   index_type len;\n   index_type n;\n \n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n   which = which - 1;\n   sstride[0] = 0;\n   rstride[0] = 0;\n@@ -64,33 +67,99 @@ cshift0_'rtype_code` ('rtype` *ret, const 'rtype` *array, ptrdiff_t shift,\n   soffset = 1;\n   len = 0;\n \n-  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n     {\n-      if (dim == which)\n-        {\n-          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          if (roffset == 0)\n-            roffset = 1;\n-          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          if (soffset == 0)\n-            soffset = 1;\n-          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n-        }\n-      else\n-        {\n-          count[n] = 0;\n-          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n-          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n-          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n-          n++;\n-        }\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n     }\n-  if (sstride[0] == 0)\n-    sstride[0] = 1;\n-  if (rstride[0] == 0)\n-    rstride[0] = 1;\n \n-  dim = GFC_DESCRIPTOR_RANK (array);\n   rstride0 = rstride[0];\n   sstride0 = sstride[0];\n   rptr = ret->base_addr;"}]}