{"sha": "5dce843f32edfd998ae4844d8115a9c9b9c394bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRjZTg0M2YzMmVkZmQ5OThhZTQ4NDRkODExNWE5YzliOWMzOTRiYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-25T07:18:03Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-25T07:25:57Z"}, "message": "Fix wrong assignment to mutable Out parameter of task entry\n\nUnder very specific circumstances the compiler can generate a wrong\nassignment to a mutable record object which contains an array component,\nbecause it does not correctly handle the update of the discriminant.\n\ngcc/ada/ChangeLog\n\t* gcc-interface/gigi.h (operand_type): New static inline function.\n\t* gcc-interface/trans.c (gnat_to_gnu): Do not suppress conversion\n\tto the resulty type at the end for array types.\n\t* gcc-interface/utils2.c (build_binary_op) <MODIFY_EXPR>: Do not\n\tremove conversions between array types on the LHS.\n\ngcc/testsuite/ChangeLog\n\t* gnat.dg/array39.adb: New test.\n\t* gnat.dg/array39_pkg.ads: New helper.\n\t* gnat.dg/array39_pkg.adb: Likewise.", "tree": {"sha": "a8057058326d856b8ee25828bb2fa8e40e7192f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8057058326d856b8ee25828bb2fa8e40e7192f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dce843f32edfd998ae4844d8115a9c9b9c394bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dce843f32edfd998ae4844d8115a9c9b9c394bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dce843f32edfd998ae4844d8115a9c9b9c394bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dce843f32edfd998ae4844d8115a9c9b9c394bc/comments", "author": null, "committer": null, "parents": [{"sha": "94c0409717bf8bf783963c1d50bb8f4a4732dce7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94c0409717bf8bf783963c1d50bb8f4a4732dce7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94c0409717bf8bf783963c1d50bb8f4a4732dce7"}], "stats": {"total": 121, "additions": 90, "deletions": 31}, "files": [{"sha": "e43b3db59a992de7fc5e313182aaeaa44a8f2a0f", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=5dce843f32edfd998ae4844d8115a9c9b9c394bc", "patch": "@@ -1209,3 +1209,11 @@ maybe_padded_object (tree expr)\n \n   return expr;\n }\n+\n+/* Return the type of operand #0 of EXPR.  */\n+\n+static inline tree\n+operand_type (tree expr)\n+{\n+  return TREE_TYPE (TREE_OPERAND (expr, 0));\n+}"}, {"sha": "969a480c3da29d29800f31d9def1639ea59b274c", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=5dce843f32edfd998ae4844d8115a9c9b9c394bc", "patch": "@@ -8821,7 +8821,8 @@ gnat_to_gnu (Node_Id gnat_node)\n        1. If this is the LHS of an assignment or an actual parameter of a\n \t  call, return the result almost unmodified since the RHS will have\n \t  to be converted to our type in that case, unless the result type\n-\t  has a simpler size.  Likewise if there is just a no-op unchecked\n+\t  has a simpler size or for array types because this size might be\n+\t  changed in-between. Likewise if there is just a no-op unchecked\n \t  conversion in-between.  Similarly, don't convert integral types\n \t  that are the operands of an unchecked conversion since we need\n \t  to ignore those conversions (for 'Valid).\n@@ -8856,15 +8857,17 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      && !AGGREGATE_TYPE_P (TREE_TYPE (gnu_result))))\n       && !(TYPE_SIZE (gnu_result_type)\n \t   && TYPE_SIZE (TREE_TYPE (gnu_result))\n-\t   && (AGGREGATE_TYPE_P (gnu_result_type)\n-\t       == AGGREGATE_TYPE_P (TREE_TYPE (gnu_result)))\n+\t   && AGGREGATE_TYPE_P (gnu_result_type)\n+\t      == AGGREGATE_TYPE_P (TREE_TYPE (gnu_result))\n \t   && ((TREE_CODE (TYPE_SIZE (gnu_result_type)) == INTEGER_CST\n \t\t&& (TREE_CODE (TYPE_SIZE (TREE_TYPE (gnu_result)))\n \t\t    != INTEGER_CST))\n \t       || (TREE_CODE (TYPE_SIZE (gnu_result_type)) != INTEGER_CST\n \t\t   && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type))\n \t\t   && (CONTAINS_PLACEHOLDER_P\n-\t\t       (TYPE_SIZE (TREE_TYPE (gnu_result))))))\n+\t\t       (TYPE_SIZE (TREE_TYPE (gnu_result)))))\n+\t       || (TREE_CODE (gnu_result_type) == ARRAY_TYPE\n+\t\t   && TREE_CODE (TREE_TYPE (gnu_result)) == ARRAY_TYPE))\n \t   && !(TREE_CODE (gnu_result_type) == RECORD_TYPE\n \t\t&& TYPE_JUSTIFIED_MODULAR_P (gnu_result_type))))\n     {"}, {"sha": "a18d50f8f00f6cd273b4178f1b16be1520762a4d", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=5dce843f32edfd998ae4844d8115a9c9b9c394bc", "patch": "@@ -875,31 +875,21 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \n       /* If there were integral or pointer conversions on the LHS, remove\n \t them; we'll be putting them back below if needed.  Likewise for\n-\t conversions between array and record types, except for justified\n-\t modular types.  But don't do this if the right operand is not\n-\t BLKmode (for packed arrays) unless we are not changing the mode.  */\n+\t conversions between record types, except for justified modular types.\n+\t But don't do this if the right operand is not BLKmode (for packed\n+\t arrays) unless we are not changing the mode.  */\n       while ((CONVERT_EXPR_P (left_operand)\n \t      || TREE_CODE (left_operand) == VIEW_CONVERT_EXPR)\n \t     && (((INTEGRAL_TYPE_P (left_type)\n \t\t   || POINTER_TYPE_P (left_type))\n-\t\t  && (INTEGRAL_TYPE_P (TREE_TYPE\n-\t\t\t\t       (TREE_OPERAND (left_operand, 0)))\n-\t\t      || POINTER_TYPE_P (TREE_TYPE\n-\t\t\t\t\t (TREE_OPERAND (left_operand, 0)))))\n-\t\t || (((TREE_CODE (left_type) == RECORD_TYPE\n-\t\t       && !TYPE_JUSTIFIED_MODULAR_P (left_type))\n-\t\t      || TREE_CODE (left_type) == ARRAY_TYPE)\n-\t\t     && ((TREE_CODE (TREE_TYPE\n-\t\t\t\t     (TREE_OPERAND (left_operand, 0)))\n-\t\t\t  == RECORD_TYPE)\n-\t\t\t || (TREE_CODE (TREE_TYPE\n-\t\t\t\t\t(TREE_OPERAND (left_operand, 0)))\n-\t\t\t     == ARRAY_TYPE))\n+\t\t  && (INTEGRAL_TYPE_P (operand_type (left_operand))\n+\t\t      || POINTER_TYPE_P (operand_type (left_operand))))\n+\t\t || (TREE_CODE (left_type) == RECORD_TYPE\n+\t\t     && !TYPE_JUSTIFIED_MODULAR_P (left_type)\n+\t\t     && TREE_CODE (operand_type (left_operand)) == RECORD_TYPE\n \t\t     && (TYPE_MODE (right_type) == BLKmode\n-\t\t\t || (TYPE_MODE (left_type)\n-\t\t\t     == TYPE_MODE (TREE_TYPE\n-\t\t\t\t\t   (TREE_OPERAND\n-\t\t\t\t\t    (left_operand, 0))))))))\n+\t\t\t || TYPE_MODE (left_type)\n+\t\t\t    == TYPE_MODE (operand_type (left_operand))))))\n \t{\n \t  left_operand = TREE_OPERAND (left_operand, 0);\n \t  left_type = TREE_TYPE (left_operand);\n@@ -921,8 +911,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t       && TREE_CONSTANT (TYPE_SIZE (left_type))\n \t       && ((TREE_CODE (right_operand) == COMPONENT_REF\n \t\t    && TYPE_MAIN_VARIANT (left_type)\n-\t\t       == TYPE_MAIN_VARIANT\n-\t\t\t  (TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n+\t\t       == TYPE_MAIN_VARIANT (operand_type (right_operand)))\n \t\t   || (TREE_CODE (right_operand) == CONSTRUCTOR\n \t\t       && !CONTAINS_PLACEHOLDER_P\n \t\t\t   (DECL_SIZE (TYPE_FIELDS (left_type)))))\n@@ -976,22 +965,23 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t      || TREE_CODE (result) == ARRAY_RANGE_REF)\n \t    while (handled_component_p (result))\n \t      result = TREE_OPERAND (result, 0);\n+\n \t  else if (TREE_CODE (result) == REALPART_EXPR\n \t\t   || TREE_CODE (result) == IMAGPART_EXPR\n \t\t   || (CONVERT_EXPR_P (result)\n \t\t       && (((TREE_CODE (restype)\n-\t\t\t     == TREE_CODE (TREE_TYPE\n-\t\t\t\t\t   (TREE_OPERAND (result, 0))))\n-\t\t\t     && (TYPE_MODE (TREE_TYPE\n-\t\t\t\t\t    (TREE_OPERAND (result, 0)))\n-\t\t\t\t == TYPE_MODE (restype)))\n+\t\t\t     == TREE_CODE (operand_type (result))\n+\t\t\t     && TYPE_MODE (restype)\n+\t\t\t\t == TYPE_MODE (operand_type (result))))\n \t\t\t   || TYPE_ALIGN_OK (restype))))\n \t    result = TREE_OPERAND (result, 0);\n+\n \t  else if (TREE_CODE (result) == VIEW_CONVERT_EXPR)\n \t    {\n \t      TREE_ADDRESSABLE (result) = 1;\n \t      result = TREE_OPERAND (result, 0);\n \t    }\n+\n \t  else\n \t    break;\n \t}"}, {"sha": "3e886c1f606ab399ba2d59d40da52d974f610878", "filename": "gcc/testsuite/gnat.dg/array39.adb", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Ftestsuite%2Fgnat.dg%2Farray39.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Ftestsuite%2Fgnat.dg%2Farray39.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray39.adb?ref=5dce843f32edfd998ae4844d8115a9c9b9c394bc", "patch": "@@ -0,0 +1,13 @@\n+-- { dg-do run }\n+\n+with Array39_Pkg; use Array39_Pkg;\n+\n+procedure Array39 is\n+  T : Tsk;\n+  R : Rec2;\n+begin\n+  T.E (R, 1);\n+  if R.A (1) /= Val then\n+    raise Program_Error;\n+  end if;\n+end;"}, {"sha": "32fe8e2a55527a1223c7412b31f8d7e36b89dbf2", "filename": "gcc/testsuite/gnat.dg/array39_pkg.adb", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Ftestsuite%2Fgnat.dg%2Farray39_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Ftestsuite%2Fgnat.dg%2Farray39_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray39_pkg.adb?ref=5dce843f32edfd998ae4844d8115a9c9b9c394bc", "patch": "@@ -0,0 +1,20 @@\n+package body Array39_Pkg is\n+\n+  task Body Tsk is\n+  begin\n+    select\n+      accept E (R : out Rec2; L : Index2) do\n+      declare\n+        A  : Arr2 (Index2);\n+        LL : Index2 := L;\n+      begin\n+        for I in 1 .. LL loop\n+          A (I) := Val;\n+        end loop;\n+        R := (D => LL, A => A (1 .. LL));\n+      end;\n+      end E;\n+    end select;\n+  end Tsk;\n+\n+end Array39_Pkg;"}, {"sha": "e5cc4b835e5201c0415840c53a82b2c635ff02b0", "filename": "gcc/testsuite/gnat.dg/array39_pkg.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Ftestsuite%2Fgnat.dg%2Farray39_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dce843f32edfd998ae4844d8115a9c9b9c394bc/gcc%2Ftestsuite%2Fgnat.dg%2Farray39_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray39_pkg.ads?ref=5dce843f32edfd998ae4844d8115a9c9b9c394bc", "patch": "@@ -0,0 +1,25 @@\n+package Array39_Pkg is\n+\n+  subtype Index1 is Natural range 0 .. 2;\n+\n+  type Arr1 is array (Index1 range <>) of Integer;\n+\n+  type Rec1 (D : Index1 := 0) is record\n+    A : Arr1 (1 .. D);\n+  end record;\n+\n+  subtype Index2 is Natural range 0 .. 7;\n+\n+  type Arr2 is array (Index2 range <>) of Rec1;\n+\n+  type Rec2 (D : Index2 := 0) is record\n+    A : Arr2 (1 .. D);\n+  end record;\n+\n+  Val : Rec1 := (D => 1, A => (others => 1));\n+\n+  task type Tsk is\n+    entry E (R : out Rec2; L : Index2);\n+  end Tsk;\n+\n+end Array39_Pkg;"}]}