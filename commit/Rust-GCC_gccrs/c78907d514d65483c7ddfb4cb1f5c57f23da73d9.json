{"sha": "c78907d514d65483c7ddfb4cb1f5c57f23da73d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc4OTA3ZDUxNGQ2NTQ4M2M3ZGRmYjRjYjFmNWM1N2YyM2RhNzNkOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-24T13:49:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-24T17:49:16Z"}, "message": "tree-optimization/95866 - avoid vectorizing uniform SLP subgraphs\n\nThis avoids vectorizing SLP subgraphs that just compute uniform\noperations on all-same operands.  That fixes the less interesting\n(but most embarrasing) part of the testcase in the PR.  On the\nway it also fixed a missing matches[0] reset in the last\nrefactoring touching that place.\n\n2020-06-24  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/95866\n\t* tree-vect-slp.c (vect_slp_tree_uniform_p): New.\n\t(vect_build_slp_tree_2): Properly reset matches[0],\n\tignore uniform constants.\n\n\t* gcc.target/i386/pr95866-1.c: New testcase.", "tree": {"sha": "2936ed9c1ed2cff0e6208f00255916b49aea0377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2936ed9c1ed2cff0e6208f00255916b49aea0377"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c78907d514d65483c7ddfb4cb1f5c57f23da73d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c78907d514d65483c7ddfb4cb1f5c57f23da73d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c78907d514d65483c7ddfb4cb1f5c57f23da73d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c78907d514d65483c7ddfb4cb1f5c57f23da73d9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "796190e538c96c28b5803f6d3dab1add87950c0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/796190e538c96c28b5803f6d3dab1add87950c0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/796190e538c96c28b5803f6d3dab1add87950c0e"}], "stats": {"total": 44, "additions": 42, "deletions": 2}, "files": [{"sha": "991370cf669e459f2471b2ce1212acb51fdf8fe6", "filename": "gcc/testsuite/gcc.target/i386/pr95866-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78907d514d65483c7ddfb4cb1f5c57f23da73d9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95866-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78907d514d65483c7ddfb4cb1f5c57f23da73d9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95866-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95866-1.c?ref=c78907d514d65483c7ddfb4cb1f5c57f23da73d9", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-slp2-details -msse2\" } */\n+\n+int x[4];\n+void foo(int i)\n+{\n+  int j = (i+1) & 31;\n+  x[0] = (x[0] << j) + j;\n+  x[1] = (x[1] << j) + j;\n+  x[2] = (x[2] << j) + j;\n+  x[3] = (x[3] << j) + j;\n+}\n+\n+/* We should not use vector operations for i + 1 and (i + 1) & 31 but\n+   instead use { j, j, j, j }.  */ \n+/* { dg-final { scan-tree-dump-times \"Building parent vector operands from scalars\" 2 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-not \" = \\{i_\" \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \" = \\{j_\" 1 \"slp2\" } } */"}, {"sha": "b2792c76ad2e6b394b0097b65d036e311fd71d3a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c78907d514d65483c7ddfb4cb1f5c57f23da73d9/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c78907d514d65483c7ddfb4cb1f5c57f23da73d9/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c78907d514d65483c7ddfb4cb1f5c57f23da73d9", "patch": "@@ -238,6 +238,26 @@ vect_contains_pattern_stmt_p (vec<stmt_vec_info> stmts)\n   return false;\n }\n \n+/* Return true when all lanes in the external or constant NODE have\n+   the same value.  */\n+\n+static bool\n+vect_slp_tree_uniform_p (slp_tree node)\n+{\n+  gcc_assert (SLP_TREE_DEF_TYPE (node) == vect_constant_def\n+\t      || SLP_TREE_DEF_TYPE (node) == vect_external_def);\n+\n+  unsigned i;\n+  tree op, first = NULL_TREE;\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_OPS (node), i, op)\n+    if (!first)\n+      first = op;\n+    else if (!operand_equal_p (first, op, 0))\n+      return false;\n+\n+  return true;\n+}\n+\n /* Find the place of the data-ref in STMT_INFO in the interleaving chain\n    that starts from FIRST_STMT_INFO.  Return -1 if the data-ref is not a part\n    of the chain.  */\n@@ -1439,7 +1459,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n   vect_free_oprnd_info (oprnds_info);\n \n   /* If we have all children of a non-unary child built up from\n-     scalars then just throw that away, causing it built up\n+     uniform scalars then just throw that away, causing it built up\n      from scalars.  */\n   if (nops > 1\n       && is_a <bb_vec_info> (vinfo)\n@@ -1451,11 +1471,13 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n       slp_tree child;\n       unsigned j;\n       FOR_EACH_VEC_ELT (children, j, child)\n-\tif (SLP_TREE_DEF_TYPE (child) != vect_external_def)\n+\tif (SLP_TREE_DEF_TYPE (child) == vect_internal_def\n+\t    || !vect_slp_tree_uniform_p (child))\n \t  break;\n       if (!child)\n \t{\n \t  /* Roll back.  */\n+\t  matches[0] = false;\n \t  FOR_EACH_VEC_ELT (children, j, child)\n \t    vect_free_slp_tree (child, false);\n "}]}