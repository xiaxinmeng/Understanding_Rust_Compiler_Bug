{"sha": "27c1afd533722e0dbc90562618a136653339cc49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdjMWFmZDUzMzcyMmUwZGJjOTA1NjI2MThhMTM2NjUzMzM5Y2M0OQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@torsion.usersys.redhat.com", "date": "2020-05-07T22:00:08Z"}, "committer": {"name": "Jeff Law", "email": "law@torsion.usersys.redhat.com", "date": "2020-05-07T22:00:41Z"}, "message": "    Drop original H8/300 support.  This should generate identical code for the remaining subtargets.  Defaults to H8/300H codegen\n\n\t* config/h8300/constraints.md (L and N): Simplify now that we're not\n\tlonger supporting the original H8/300 chip.\n\t* config/h8300/elf.h (LINK_SPEC): Likewise.  Default to H8/300H.\n\t* config/h8300/h8300.c (shift_alg_qi): Drop H8/300 support.\n\t(shift_alg_hi, shift_alg_si): Similarly.\n\t(h8300_option_overrides): Similarly.  Default to H8/300H.  If\n\tcompiling for H8/S, then turn off H8/300H.  Do not update the\n\tshift_alg tables for H8/300 port.\n\t(h8300_emit_stack_adjustment): Remove support for H8/300.  Simplify\n\twhere possible.\n\t(push, split_adds_subs, h8300_rtx_costs): Likewise.\n\t(h8300_print_operand, compute_mov_length): Likewise.\n\t(output_plussi, compute_plussi_length): Likewise.\n\t(compute_plussi_cc, output_logical_op): Likewise.\n\t(compute_logical_op_length, compute_logical_op_cc): Likewise.\n\t(get_shift_alg, h8300_shift_needs_scratch): Likewise.\n\t(output_a_shift, compute_a_shift_length): Likewise.\n\t(output_a_rotate, compute_a_rotate_length): Likewise.\n\t(output_simode_bld, h8300_hard_regno_mode_ok): Likewise.\n\t(h8300_modes_tieable_p, h8300_return_in_memory): Likewise.\n\t* config/h8300/h8300.h (TARGET_CPU_CPP_BUILTINS): Likewise.\n\t(attr_cpu, TARGET_H8300): Remove.\n\t(TARGET_DEFAULT): Update.\n\t(UNITS_PER_WORD, PARM_BOUNDARY): Simplify where possible.\n\t(BIGGEST_ALIGNMENT, STACK_BOUNDARY): Likewise.\n\t(CONSTANT_ADDRESS_P, MOVE_MAX, Pmode): Likewise.\n\t(SIZE_TYPE, POINTER_SIZE, ASM_WORD_OP): Likewise.\n\t* config/h8300/h8300.md: Simplify patterns throughout.\n\t* config/h8300/t-h8300: Update multilib configuration.\n\n@@ -82,11 +82,9 @@", "tree": {"sha": "31637bb669b1a91127091202615e69d74cbf37ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31637bb669b1a91127091202615e69d74cbf37ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27c1afd533722e0dbc90562618a136653339cc49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c1afd533722e0dbc90562618a136653339cc49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27c1afd533722e0dbc90562618a136653339cc49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c1afd533722e0dbc90562618a136653339cc49/comments", "author": null, "committer": null, "parents": [{"sha": "b9cb3bb9ad0dd1bc780a857b96e7bd9c82ba58e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9cb3bb9ad0dd1bc780a857b96e7bd9c82ba58e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9cb3bb9ad0dd1bc780a857b96e7bd9c82ba58e6"}], "stats": {"total": 2322, "additions": 683, "deletions": 1639}, "files": [{"sha": "c9a9cc1afa34fed76beb1b6584af198767d0e2b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c1afd533722e0dbc90562618a136653339cc49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c1afd533722e0dbc90562618a136653339cc49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27c1afd533722e0dbc90562618a136653339cc49", "patch": "@@ -1,5 +1,35 @@\n 2020-05-07 Jeff Law  <law@redhat.com>\n \n+\t* config/h8300/constraints.md (L and N): Simplify now that we're not\n+\tlonger supporting the original H8/300 chip.\n+\t* config/h8300/elf.h (LINK_SPEC): Likewise.  Default to H8/300H.\n+\t* config/h8300/h8300.c (shift_alg_qi): Drop H8/300 support.\n+\t(shift_alg_hi, shift_alg_si): Similarly.\n+\t(h8300_option_overrides): Similarly.  Default to H8/300H.  If\n+\tcompiling for H8/S, then turn off H8/300H.  Do not update the\n+\tshift_alg tables for H8/300 port.\n+\t(h8300_emit_stack_adjustment): Remove support for H8/300.  Simplify\n+\twhere possible.\n+\t(push, split_adds_subs, h8300_rtx_costs): Likewise.\n+\t(h8300_print_operand, compute_mov_length): Likewise.\n+\t(output_plussi, compute_plussi_length): Likewise.\n+\t(compute_plussi_cc, output_logical_op): Likewise.\n+\t(compute_logical_op_length, compute_logical_op_cc): Likewise.\n+\t(get_shift_alg, h8300_shift_needs_scratch): Likewise.\n+\t(output_a_shift, compute_a_shift_length): Likewise.\n+\t(output_a_rotate, compute_a_rotate_length): Likewise.\n+\t(output_simode_bld, h8300_hard_regno_mode_ok): Likewise.\n+\t(h8300_modes_tieable_p, h8300_return_in_memory): Likewise.\n+\t* config/h8300/h8300.h (TARGET_CPU_CPP_BUILTINS): Likewise.\n+\t(attr_cpu, TARGET_H8300): Remove.\n+\t(TARGET_DEFAULT): Update.\n+\t(UNITS_PER_WORD, PARM_BOUNDARY): Simplify where possible.\n+\t(BIGGEST_ALIGNMENT, STACK_BOUNDARY): Likewise.\n+\t(CONSTANT_ADDRESS_P, MOVE_MAX, Pmode): Likewise.\n+\t(SIZE_TYPE, POINTER_SIZE, ASM_WORD_OP): Likewise.\n+\t* config/h8300/h8300.md: Simplify patterns throughout.\n+\t* config/h8300/t-h8300: Update multilib configuration.\n+\t\n \t* config/h8300/h8300.h (LINK_SPEC): Remove.\n \t(USER_LABEL_PREFIX): Likewise.\n "}, {"sha": "d24518225f8a720465863e52e0b0191261ddef82", "filename": "gcc/config/h8300/constraints.md", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fconstraints.md?ref=27c1afd533722e0dbc90562618a136653339cc49", "patch": "@@ -82,23 +82,19 @@\n        (match_test \"(ival & 0xff) == 0\")))\n \n (define_constraint \"L\"\n-  \"1, 2 or 4 on the H8300H or S; 1 or 2 otherwise.\"\n+  \"Integer 1, 2 or 4\"\n   (and (match_code \"const_int\")\n-       (if_then_else (match_test \"TARGET_H8300H || TARGET_H8300S\")\n-\t\t     (match_test \"ival == 1 || ival == 2 || ival == 4\")\n-\t\t     (match_test \"ival == 1 || ival == 2\"))))\n+       (match_test \"ival == 1 || ival == 2 || ival == 4\")))\n \n (define_constraint \"M\"\n   \"Integer 1 or 2.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival == 1 || ival == 2\")))\n \n (define_constraint \"N\"\n-  \"-1, -2, or -4 on the H8300H or S; -1 or -2 otherwise.\"\n+  \"Integer -1, -2 or -4\"\n   (and (match_code \"const_int\")\n-       (if_then_else (match_test \"TARGET_H8300H || TARGET_H8300S\")\n-\t\t     (match_test \"ival == -1 || ival == -2 || ival == -4\")\n-\t\t     (match_test \"ival == -1 || ival == -2\"))))\n+       (match_test \"ival == -1 || ival == -2 || ival == -4\")))\n \n (define_constraint \"O\"\n   \"Integer -1 or -2.\""}, {"sha": "06844a590f19cdb94a90d5eddf4a3194e4dd76d5", "filename": "gcc/config/h8300/elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Felf.h?ref=27c1afd533722e0dbc90562618a136653339cc49", "patch": "@@ -39,6 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n #define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)\n \n #undef LINK_SPEC\n-#define LINK_SPEC \"%{mh:%{mn:-m h8300hnelf}} %{mh:%{!mn:-m h8300helf}} %{ms:%{mn:-m h8300snelf}} %{ms:%{!mn:-m h8300self}} %{msx:%{mn:-m h8300sxnelf;:-m h8300sxelf}}\"\n+#define LINK_SPEC \"%{!ms:%{!msx:%{mn:-m h8300hnelf;:-m h8300helf}}} %{ms:%{mn:-m h8300snelf;:-m h8300self}} %{msx:%{mn:-m h8300sxnelf;:-m h8300sxelf}}\"\n \n #endif /* h8300/elf.h */"}, {"sha": "6875cd9b81ad3d6d65afb7be2249005659c909d4", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 334, "deletions": 811, "changes": 1145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=27c1afd533722e0dbc90562618a136653339cc49", "patch": "@@ -179,14 +179,7 @@ enum shift_type\n    QImode, HImode, and SImode, respectively.  Each table is organized\n    by, in the order of indices, machine, shift type, and shift count.  */\n \n-static enum shift_alg shift_alg_qi[3][3][8] = {\n-  {\n-    /* TARGET_H8300  */\n-    /* 0    1    2    3    4    5    6    7  */\n-    { INL, INL, INL, INL, INL, ROT, ROT, ROT }, /* SHIFT_ASHIFT   */\n-    { INL, INL, INL, INL, INL, ROT, ROT, ROT }, /* SHIFT_LSHIFTRT */\n-    { INL, INL, INL, INL, INL, LOP, LOP, SPC }  /* SHIFT_ASHIFTRT */\n-  },\n+static enum shift_alg shift_alg_qi[2][3][8] = {\n   {\n     /* TARGET_H8300H  */\n     /* 0    1    2    3    4    5    6    7  */\n@@ -203,18 +196,7 @@ static enum shift_alg shift_alg_qi[3][3][8] = {\n   }\n };\n \n-static enum shift_alg shift_alg_hi[3][3][16] = {\n-  {\n-    /* TARGET_H8300  */\n-    /*  0    1    2    3    4    5    6    7  */\n-    /*  8    9   10   11   12   13   14   15  */\n-    { INL, INL, INL, INL, INL, INL, INL, SPC,\n-      SPC, SPC, SPC, SPC, SPC, SPC, SPC, SPC }, /* SHIFT_ASHIFT   */\n-    { INL, INL, INL, INL, INL, LOP, LOP, SPC,\n-      SPC, SPC, SPC, SPC, SPC, SPC, SPC, SPC }, /* SHIFT_LSHIFTRT */\n-    { INL, INL, INL, INL, INL, LOP, LOP, SPC,\n-      SPC, SPC, SPC, SPC, SPC, SPC, SPC, SPC }, /* SHIFT_ASHIFTRT */\n-  },\n+static enum shift_alg shift_alg_hi[2][3][16] = {\n   {\n     /* TARGET_H8300H  */\n     /*  0    1    2    3    4    5    6    7  */\n@@ -239,26 +221,7 @@ static enum shift_alg shift_alg_hi[3][3][16] = {\n   }\n };\n \n-static enum shift_alg shift_alg_si[3][3][32] = {\n-  {\n-    /* TARGET_H8300  */\n-    /*  0    1    2    3    4    5    6    7  */\n-    /*  8    9   10   11   12   13   14   15  */\n-    /* 16   17   18   19   20   21   22   23  */\n-    /* 24   25   26   27   28   29   30   31  */\n-    { INL, INL, INL, LOP, LOP, LOP, LOP, LOP,\n-      SPC, LOP, LOP, LOP, LOP, LOP, LOP, LOP,\n-      SPC, SPC, SPC, SPC, SPC, LOP, LOP, LOP,\n-      SPC, SPC, SPC, SPC, LOP, LOP, LOP, SPC }, /* SHIFT_ASHIFT   */\n-    { INL, INL, INL, LOP, LOP, LOP, LOP, LOP,\n-      SPC, SPC, LOP, LOP, LOP, LOP, LOP, SPC,\n-      SPC, SPC, SPC, LOP, LOP, LOP, LOP, LOP,\n-      SPC, SPC, SPC, SPC, SPC, LOP, LOP, SPC }, /* SHIFT_LSHIFTRT */\n-    { INL, INL, INL, LOP, LOP, LOP, LOP, LOP,\n-      SPC, LOP, LOP, LOP, LOP, LOP, LOP, SPC,\n-      SPC, SPC, LOP, LOP, LOP, LOP, LOP, LOP,\n-      SPC, SPC, SPC, LOP, LOP, LOP, LOP, SPC }, /* SHIFT_ASHIFTRT */\n-  },\n+static enum shift_alg shift_alg_si[2][3][32] = {\n   {\n     /* TARGET_H8300H  */\n     /*  0    1    2    3    4    5    6    7  */\n@@ -306,7 +269,6 @@ static enum shift_alg shift_alg_si[3][3][32] = {\n \n enum h8_cpu\n {\n-  H8_300,\n   H8_300H,\n   H8_S\n };\n@@ -320,45 +282,29 @@ h8300_option_override (void)\n   static const char *const h8_pop_ops[2]  = { \"pop\"  , \"pop.l\"  };\n   static const char *const h8_mov_ops[2]  = { \"mov.w\", \"mov.l\"  };\n \n-  if (TARGET_H8300)\n-    {\n-      cpu_type = (int) CPU_H8300;\n-      h8_reg_names = names_big;\n-    }\n-  else\n-    {\n-      /* For this we treat the H8/300H and H8S the same.  */\n-      cpu_type = (int) CPU_H8300H;\n-      h8_reg_names = names_extended;\n-    }\n+  /* For this we treat the H8/300H and H8S the same.  */\n+  cpu_type = (int) CPU_H8300H;\n+  h8_reg_names = names_extended;\n   h8_push_op = h8_push_ops[cpu_type];\n   h8_pop_op = h8_pop_ops[cpu_type];\n   h8_mov_op = h8_mov_ops[cpu_type];\n \n+  /* If we're compiling for the H8/S, then turn off H8/300H.  */\n+  if (TARGET_H8300S)\n+    target_flags &= ~MASK_H8300H;\n+\n   if (!TARGET_H8300S && TARGET_MAC)\n     {\n       error (\"%<-ms2600%> is used without %<-ms%>\");\n       target_flags |= MASK_H8300S_1;\n     }\n \n-  if (TARGET_H8300 && TARGET_NORMAL_MODE)\n-    {\n-      error (\"%<-mn%> is used without %<-mh%> or %<-ms%> or %<-msx%>\");\n-      target_flags ^= MASK_NORMAL_MODE;\n-    }\n-\n   if (! TARGET_H8300S &&  TARGET_EXR)\n     {\n       error (\"%<-mexr%> is used without %<-ms%>\");\n       target_flags |= MASK_H8300S_1;\n     }\n \n-  if (TARGET_H8300 && TARGET_INT32)\n-   {\n-      error (\"%<-mint32%> is not supported for H8300 and H8300L targets\");\n-      target_flags ^= MASK_INT32;\n-   }\n-\n  if ((!TARGET_H8300S  &&  TARGET_EXR) && (!TARGET_H8300SX && TARGET_EXR))\n    {\n       error (\"%<-mexr%> is used without %<-ms%> or %<-msx%>\");\n@@ -385,18 +331,6 @@ h8300_option_override (void)\n      SHIFT_LOOP.  */\n   if (optimize_size)\n     {\n-      /* H8/300 */\n-      shift_alg_hi[H8_300][SHIFT_ASHIFT][5] = SHIFT_LOOP;\n-      shift_alg_hi[H8_300][SHIFT_ASHIFT][6] = SHIFT_LOOP;\n-      shift_alg_hi[H8_300][SHIFT_ASHIFT][13] = SHIFT_LOOP;\n-      shift_alg_hi[H8_300][SHIFT_ASHIFT][14] = SHIFT_LOOP;\n-\n-      shift_alg_hi[H8_300][SHIFT_LSHIFTRT][13] = SHIFT_LOOP;\n-      shift_alg_hi[H8_300][SHIFT_LSHIFTRT][14] = SHIFT_LOOP;\n-\n-      shift_alg_hi[H8_300][SHIFT_ASHIFTRT][13] = SHIFT_LOOP;\n-      shift_alg_hi[H8_300][SHIFT_ASHIFTRT][14] = SHIFT_LOOP;\n-\n       /* H8/300H */\n       shift_alg_hi[H8_300H][SHIFT_ASHIFT][5] = SHIFT_LOOP;\n       shift_alg_hi[H8_300H][SHIFT_ASHIFT][6] = SHIFT_LOOP;\n@@ -524,38 +458,22 @@ h8300_emit_stack_adjustment (int sign, HOST_WIDE_INT size, bool in_prologue)\n   if (size == 0)\n     return;\n \n-  /* H8/300 cannot add/subtract a large constant with a single\n-     instruction.  If a temporary register is available, load the\n-     constant to it and then do the addition.  */\n-  if (TARGET_H8300\n-      && size > 4\n-      && !h8300_current_function_interrupt_function_p ()\n-      && !(cfun->static_chain_decl != NULL && sign < 0))\n+  /* The stack adjustment made here is further optimized by the\n+     splitter.  In case of H8/300, the splitter always splits the\n+     addition emitted here to make the adjustment interrupt-safe.\n+     FIXME: We don't always tag those, because we don't know what\n+     the splitter will do.  */\n+  if (Pmode == HImode)\n     {\n-      rtx r3 = gen_rtx_REG (Pmode, 3);\n-      F (emit_insn (gen_movhi (r3, GEN_INT (sign * size))), in_prologue);\n-      F (emit_insn (gen_addhi3 (stack_pointer_rtx,\n-\t\t\t\tstack_pointer_rtx, r3)), in_prologue);\n+      rtx_insn *x = emit_insn (gen_addhi3 (stack_pointer_rtx,\n+\t\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t\t    GEN_INT (sign * size)));\n+      if (size < 4)\n+        F (x, in_prologue);\n     }\n   else\n-    {\n-      /* The stack adjustment made here is further optimized by the\n-\t splitter.  In case of H8/300, the splitter always splits the\n-\t addition emitted here to make the adjustment interrupt-safe.\n-\t FIXME: We don't always tag those, because we don't know what\n-\t the splitter will do.  */\n-      if (Pmode == HImode)\n-\t{\n-\t  rtx_insn *x = emit_insn (gen_addhi3 (stack_pointer_rtx,\n-\t\t\t\t\t       stack_pointer_rtx,\n-\t\t\t\t\t       GEN_INT (sign * size)));\n-\t  if (size < 4)\n-\t    F (x, in_prologue);\n-\t}\n-      else\n-\tF (emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t  stack_pointer_rtx, GEN_INT (sign * size))), in_prologue);\n-    }\n+    F (emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t      stack_pointer_rtx, GEN_INT (sign * size))), in_prologue);\n }\n \n /* Round up frame size SIZE.  */\n@@ -598,9 +516,7 @@ push (int rn, bool in_prologue)\n   rtx reg = gen_rtx_REG (word_mode, rn);\n   rtx x;\n \n-  if (TARGET_H8300)\n-    x = gen_push_h8300 (reg);\n-  else if (!TARGET_NORMAL_MODE)\n+  if (!TARGET_NORMAL_MODE)\n     x = gen_push_h8300hs_advanced (reg);\n   else\n     x = gen_push_h8300hs_normal (reg);\n@@ -617,9 +533,7 @@ pop (int rn)\n   rtx reg = gen_rtx_REG (word_mode, rn);\n   rtx x;\n \n-  if (TARGET_H8300)\n-    x = gen_pop_h8300 (reg);\n-  else if (!TARGET_NORMAL_MODE)\n+  if (!TARGET_NORMAL_MODE)\n     x = gen_pop_h8300hs_advanced (reg);\n   else\n     x = gen_pop_h8300hs_normal (reg);\n@@ -1038,9 +952,7 @@ split_adds_subs (machine_mode mode, rtx *operands)\n     }\n \n   /* Try different amounts in descending order.  */\n-  for (amount = (TARGET_H8300H || TARGET_H8300S) ? 4 : 2;\n-       amount > 0;\n-       amount /= 2)\n+  for (amount = 4; amount > 0; amount /= 2)\n     {\n       for (; val >= amount; val -= amount)\n \temit_insn (gen_add (reg, reg, GEN_INT (sign * amount)));\n@@ -1262,10 +1174,7 @@ h8300_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n \t\treturn true;\n \t      case 4:\n \t      case -4:\n-\t\tif (TARGET_H8300H || TARGET_H8300S)\n-\t\t  *total = 0 + (outer_code == SET);\n-\t\telse\n-\t\t  *total = 1;\n+\t\t*total = 0 + (outer_code == SET);\n \t\treturn true;\n \t      }\n \t  }\n@@ -1554,10 +1463,7 @@ h8300_print_operand (FILE *file, rtx x, int code)\n       switch (GET_CODE (x))\n \t{\n \tcase REG:\n-\t  if (TARGET_H8300)\n-\t    fprintf (file, \"%s\", names_big[REGNO (x)]);\n-\t  else\n-\t    fprintf (file, \"%s\", names_upper_extended[REGNO (x)]);\n+\t  fprintf (file, \"%s\", names_upper_extended[REGNO (x)]);\n \t  break;\n \tcase MEM:\n \t  h8300_print_operand (file, x, 0);\n@@ -1581,10 +1487,7 @@ h8300_print_operand (FILE *file, rtx x, int code)\n       switch (GET_CODE (x))\n \t{\n \tcase REG:\n-\t  if (TARGET_H8300)\n-\t    fprintf (file, \"%s\", names_big[REGNO (x) + 1]);\n-\t  else\n-\t    fprintf (file, \"%s\", names_big[REGNO (x)]);\n+\t  fprintf (file, \"%s\", names_big[REGNO (x)]);\n \t  break;\n \tcase MEM:\n \t  x = adjust_address (x, HImode, 2);\n@@ -1653,17 +1556,15 @@ h8300_print_operand (FILE *file, rtx x, int code)\n       if (GET_CODE (x) == CONST_INT)\n \tfprintf (file, \"#%ld\", INTVAL (x) & 0xff);\n       else if (GET_CODE (x) == REG)\n-\tfprintf (file, \"%s\",\n-\t\t byte_reg (x, TARGET_H8300 ? 2 : 0));\n+\tfprintf (file, \"%s\", byte_reg (x, 0));\n       else\n \toutput_operand_lossage (\"Expected register or constant integer.\");\n       break;\n     case 'x':\n       if (GET_CODE (x) == CONST_INT)\n \tfprintf (file, \"#%ld\", (INTVAL (x) >> 8) & 0xff);\n       else if (GET_CODE (x) == REG)\n-\tfprintf (file, \"%s\",\n-\t\t byte_reg (x, TARGET_H8300 ? 3 : 1));\n+\tfprintf (file, \"%s\", byte_reg (x, 1));\n       else\n \toutput_operand_lossage (\"Expected register or constant integer.\");\n       break;\n@@ -1859,14 +1760,7 @@ h8300_print_operand_address (FILE *file, machine_mode mode, rtx addr)\n \n     case CONST_INT:\n       {\n-\t/* Since the H8/300 only has 16-bit pointers, negative values are also\n-\t   those >= 32768.  This happens for example with pointer minus a\n-\t   constant.  We don't want to turn (char *p - 2) into\n-\t   (char *p + 65534) because loop unrolling can build upon this\n-\t   (IE: char *p + 131068).  */\n \tint n = INTVAL (addr);\n-\tif (TARGET_H8300)\n-\t  n = (int) (short) n;\n \tfprintf (file, \"%d\", n);\n \tbreak;\n       }\n@@ -2657,237 +2551,128 @@ compute_mov_length (rtx *operands)\n   else\n     addr = NULL_RTX;\n \n-  if (TARGET_H8300)\n-    {\n-      unsigned int base_length;\n+  unsigned int base_length;\n \n-      switch (mode)\n-\t{\n-\tcase E_QImode:\n-\t  if (addr == NULL_RTX)\n-\t    return 2;\n+  switch (mode)\n+    {\n+    case E_QImode:\n+      if (addr == NULL_RTX)\n+\treturn 2;\n \n-\t  /* The eightbit addressing is available only in QImode, so\n-\t     go ahead and take care of it.  */\n-\t  if (h8300_eightbit_constant_address_p (addr))\n-\t    return 2;\n+      /* The eightbit addressing is available only in QImode, so\n+\t go ahead and take care of it.  */\n+      if (h8300_eightbit_constant_address_p (addr))\n+\treturn 2;\n \n-\t  base_length = 4;\n+\t  base_length = 8;\n \t  break;\n \n-\tcase E_HImode:\n-\t  if (addr == NULL_RTX)\n-\t    {\n-\t      if (REG_P (src))\n-\t\treturn 2;\n+    case E_HImode:\n+      if (addr == NULL_RTX)\n+\t{\n+\t  if (REG_P (src))\n+\t    return 2;\n \n-\t      if (src == const0_rtx)\n-\t\treturn 2;\n+\t  if (src == const0_rtx)\n+\t    return 2;\n \n-\t      return 4;\n-\t    }\n+\t  return 4;\n+\t}\n \n-\t  base_length = 4;\n-\t  break;\n+      base_length = 8;\n+\tbreak;\n \n-\tcase E_SImode:\n-\t  if (addr == NULL_RTX)\n+    case E_SImode:\n+      if (addr == NULL_RTX)\n+\t{\n+\t  if (REG_P (src))\n \t    {\n-\t      if (REG_P (src))\n+\t      if (REGNO (src) == MAC_REG || REGNO (dest) == MAC_REG)\n \t\treturn 4;\n-\n-\t      if (GET_CODE (src) == CONST_INT)\n-\t\t{\n-\t\t  if (src == const0_rtx)\n-\t\t    return 4;\n-\n-\t\t  if ((INTVAL (src) & 0xffff) == 0)\n-\t\t    return 6;\n-\n-\t\t  if ((INTVAL (src) & 0xffff) == 0)\n-\t\t    return 6;\n-\n-\t\t  if ((INTVAL (src) & 0xffff)\n-\t\t      == ((INTVAL (src) >> 16) & 0xffff))\n-\t\t    return 6;\n-\t\t}\n-\t      return 8;\n+\t      else\n+\t\treturn 2;\n \t    }\n \n-\t  base_length = 8;\n-\t  break;\n-\n-\tcase E_SFmode:\n-\t  if (addr == NULL_RTX)\n+\t  if (GET_CODE (src) == CONST_INT)\n \t    {\n-\t      if (REG_P (src))\n-\t\treturn 4;\n+\t      int val = INTVAL (src);\n+\n+\t      if (val == 0)\n+\t\treturn 2;\n \n-\t      if (satisfies_constraint_G (src))\n+\t      if (val == (val & 0x00ff) || val == (val & 0xff00))\n \t\treturn 4;\n \n-\t      return 8;\n+\t      switch (val & 0xffffffff)\n+\t\t{\n+\t\tcase 0xffffffff:\n+\t\tcase 0xfffffffe:\n+\t\tcase 0xfffffffc:\n+\t\tcase 0x0000ffff:\n+\t\tcase 0x0000fffe:\n+\t\tcase 0xffff0000:\n+\t\tcase 0xfffe0000:\n+\t\tcase 0x00010000:\n+\t\tcase 0x00020000:\n+\t\t  return 4;\n+\t\t}\n \t    }\n-\n-\t  base_length = 8;\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      /* Adjust the length based on the addressing mode used.\n-\t Specifically, we subtract the difference between the actual\n-\t length and the longest one, which is @(d:16,Rs).  For SImode\n-\t and SFmode, we double the adjustment because two mov.w are\n-\t used to do the job.  */\n-\n-      /* @Rs+ and @-Rd are 2 bytes shorter than the longest.  */\n-      if (GET_CODE (addr) == PRE_DEC\n-\t  || GET_CODE (addr) == POST_INC)\n-\t{\n-\t  if (mode == QImode || mode == HImode)\n-\t    return base_length - 2;\n-\t  else\n-\t    /* In SImode and SFmode, we use two mov.w instructions, so\n-\t       double the adjustment.  */\n-\t    return base_length - 4;\n+\t  return 6;\n \t}\n \n-      /* @Rs and @Rd are 2 bytes shorter than the longest.  Note that\n-\t in SImode and SFmode, the second mov.w involves an address\n-\t with displacement, namely @(2,Rs) or @(2,Rd), so we subtract\n-\t only 2 bytes.  */\n-      if (GET_CODE (addr) == REG)\n-\treturn base_length - 2;\n-\n-      return base_length;\n-    }\n-  else\n-    {\n-      unsigned int base_length;\n+      base_length = 10;\n+      break;\n \n-      switch (mode)\n+    case E_SFmode:\n+      if (addr == NULL_RTX)\n \t{\n-\tcase E_QImode:\n-\t  if (addr == NULL_RTX)\n-\t    return 2;\n+\t  if (REG_P (src))\n+   \t    return 2;\n \n-\t  /* The eightbit addressing is available only in QImode, so\n-\t     go ahead and take care of it.  */\n-\t  if (h8300_eightbit_constant_address_p (addr))\n+\t  if (satisfies_constraint_G (src))\n \t    return 2;\n \n-\t  base_length = 8;\n-\t  break;\n-\n-\tcase E_HImode:\n-\t  if (addr == NULL_RTX)\n-\t    {\n-\t      if (REG_P (src))\n-\t\treturn 2;\n-\n-\t      if (src == const0_rtx)\n-\t\treturn 2;\n-\n-\t      return 4;\n-\t    }\n-\n-\t  base_length = 8;\n-\t  break;\n-\n-\tcase E_SImode:\n-\t  if (addr == NULL_RTX)\n-\t    {\n-\t      if (REG_P (src))\n-\t\t{\n-\t\t  if (REGNO (src) == MAC_REG || REGNO (dest) == MAC_REG)\n-\t\t    return 4;\n-\t\t  else\n-\t\t    return 2;\n-\t\t}\n-\n-\t      if (GET_CODE (src) == CONST_INT)\n-\t\t{\n-\t\t  int val = INTVAL (src);\n-\n-\t\t  if (val == 0)\n-\t\t    return 2;\n+\t  return 6;\n+\t}\n \n-\t\t  if (val == (val & 0x00ff) || val == (val & 0xff00))\n-\t\t    return 4;\n+      base_length = 10;\n+\tbreak;\n \n-\t\t  switch (val & 0xffffffff)\n-\t\t    {\n-\t\t    case 0xffffffff:\n-\t\t    case 0xfffffffe:\n-\t\t    case 0xfffffffc:\n-\t\t    case 0x0000ffff:\n-\t\t    case 0x0000fffe:\n-\t\t    case 0xffff0000:\n-\t\t    case 0xfffe0000:\n-\t\t    case 0x00010000:\n-\t\t    case 0x00020000:\n-\t\t      return 4;\n-\t\t    }\n-\t\t}\n-\t      return 6;\n-\t    }\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-\t  base_length = 10;\n-\t  break;\n+  /* Adjust the length based on the addressing mode used.\n+     Specifically, we subtract the difference between the actual\n+     length and the longest one, which is @(d:24,ERs).  */\n \n-\tcase E_SFmode:\n-\t  if (addr == NULL_RTX)\n-\t    {\n-\t      if (REG_P (src))\n-\t\treturn 2;\n+  /* @ERs+ and @-ERd are 6 bytes shorter than the longest.  */\n+  if (GET_CODE (addr) == PRE_DEC\n+      || GET_CODE (addr) == POST_INC)\n+    return base_length - 6;\n \n-\t      if (satisfies_constraint_G (src))\n-\t\treturn 2;\n+  /* @ERs and @ERd are 6 bytes shorter than the longest.  */\n+  if (GET_CODE (addr) == REG)\n+    return base_length - 6;\n \n-\t      return 6;\n-\t    }\n+  /* @(d:16,ERs) and @(d:16,ERd) are 4 bytes shorter than the\n+     longest.  */\n+  if (GET_CODE (addr) == PLUS\n+      && GET_CODE (XEXP (addr, 0)) == REG\n+      && GET_CODE (XEXP (addr, 1)) == CONST_INT\n+      && INTVAL (XEXP (addr, 1)) > -32768\n+      && INTVAL (XEXP (addr, 1)) < 32767)\n+    return base_length - 4;\n \n-\t  base_length = 10;\n-\t  break;\n+  /* @aa:16 is 4 bytes shorter than the longest.  */\n+  if (h8300_tiny_constant_address_p (addr))\n+    return base_length - 4;\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+  /* @aa:24 is 2 bytes shorter than the longest.  */\n+  if (CONSTANT_P (addr))\n+    return base_length - 2;\n \n-      /* Adjust the length based on the addressing mode used.\n-\t Specifically, we subtract the difference between the actual\n-\t length and the longest one, which is @(d:24,ERs).  */\n-\n-      /* @ERs+ and @-ERd are 6 bytes shorter than the longest.  */\n-      if (GET_CODE (addr) == PRE_DEC\n-\t  || GET_CODE (addr) == POST_INC)\n-\treturn base_length - 6;\n-\n-      /* @ERs and @ERd are 6 bytes shorter than the longest.  */\n-      if (GET_CODE (addr) == REG)\n-\treturn base_length - 6;\n-\n-      /* @(d:16,ERs) and @(d:16,ERd) are 4 bytes shorter than the\n-\t longest.  */\n-      if (GET_CODE (addr) == PLUS\n-\t  && GET_CODE (XEXP (addr, 0)) == REG\n-\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT\n-\t  && INTVAL (XEXP (addr, 1)) > -32768\n-\t  && INTVAL (XEXP (addr, 1)) < 32767)\n-\treturn base_length - 4;\n-\n-      /* @aa:16 is 4 bytes shorter than the longest.  */\n-      if (h8300_tiny_constant_address_p (addr))\n-\treturn base_length - 4;\n-\n-      /* @aa:24 is 2 bytes shorter than the longest.  */\n-      if (CONSTANT_P (addr))\n-\treturn base_length - 2;\n-\n-      return base_length;\n-    }\n+  return base_length;\n }\n \f\n /* Output an addition insn.  */\n@@ -2899,77 +2684,55 @@ output_plussi (rtx *operands)\n \n   gcc_assert (mode == SImode);\n \n-  if (TARGET_H8300)\n-    {\n-      if (GET_CODE (operands[2]) == REG)\n-\treturn \"add.w\\t%f2,%f0\\n\\taddx\\t%y2,%y0\\n\\taddx\\t%z2,%z0\";\n-\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  HOST_WIDE_INT n = INTVAL (operands[2]);\n-\n-\t  if ((n & 0xffffff) == 0)\n-\t    return \"add\\t%z2,%z0\";\n-\t  if ((n & 0xffff) == 0)\n-\t    return \"add\\t%y2,%y0\\n\\taddx\\t%z2,%z0\";\n-\t  if ((n & 0xff) == 0)\n-\t    return \"add\\t%x2,%x0\\n\\taddx\\t%y2,%y0\\n\\taddx\\t%z2,%z0\";\n-\t}\n-\n-      return \"add\\t%w2,%w0\\n\\taddx\\t%x2,%x0\\n\\taddx\\t%y2,%y0\\n\\taddx\\t%z2,%z0\";\n-    }\n-  else\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && register_operand (operands[1], VOIDmode))\n     {\n-      if (GET_CODE (operands[2]) == CONST_INT\n-\t  && register_operand (operands[1], VOIDmode))\n-\t{\n-\t  HOST_WIDE_INT intval = INTVAL (operands[2]);\n+      HOST_WIDE_INT intval = INTVAL (operands[2]);\n \n-\t  if (TARGET_H8300SX && (intval >= 1 && intval <= 7))\n-\t    return \"add.l\\t%S2,%S0\";\n-\t  if (TARGET_H8300SX && (intval >= -7 && intval <= -1))\n-\t    return \"sub.l\\t%G2,%S0\";\n+      if (TARGET_H8300SX && (intval >= 1 && intval <= 7))\n+\treturn \"add.l\\t%S2,%S0\";\n+      if (TARGET_H8300SX && (intval >= -7 && intval <= -1))\n+\treturn \"sub.l\\t%G2,%S0\";\n \n-\t  /* See if we can finish with 2 bytes.  */\n+      /* See if we can finish with 2 bytes.  */\n \n-\t  switch ((unsigned int) intval & 0xffffffff)\n-\t    {\n-\t    case 0x00000001:\n-\t    case 0x00000002:\n-\t    case 0x00000004:\n-\t      return \"adds\\t%2,%S0\";\n-\n-\t    case 0xffffffff:\n-\t    case 0xfffffffe:\n-\t    case 0xfffffffc:\n-\t      return \"subs\\t%G2,%S0\";\n-\n-\t    case 0x00010000:\n-\t    case 0x00020000:\n-\t      operands[2] = GEN_INT (intval >> 16);\n-\t      return \"inc.w\\t%2,%e0\";\n-\n-\t    case 0xffff0000:\n-\t    case 0xfffe0000:\n-\t      operands[2] = GEN_INT (intval >> 16);\n-\t      return \"dec.w\\t%G2,%e0\";\n-\t    }\n-\n-\t  /* See if we can finish with 4 bytes.  */\n-\t  if ((intval & 0xffff) == 0)\n-\t    {\n-\t      operands[2] = GEN_INT (intval >> 16);\n-\t      return \"add.w\\t%2,%e0\";\n-\t    }\n+      switch ((unsigned int) intval & 0xffffffff)\n+\t{\n+\tcase 0x00000001:\n+\tcase 0x00000002:\n+\tcase 0x00000004:\n+\t  return \"adds\\t%2,%S0\";\n+\n+\tcase 0xffffffff:\n+\tcase 0xfffffffe:\n+\tcase 0xfffffffc:\n+\t  return \"subs\\t%G2,%S0\";\n+\n+\tcase 0x00010000:\n+\tcase 0x00020000:\n+\t  operands[2] = GEN_INT (intval >> 16);\n+\t  return \"inc.w\\t%2,%e0\";\n+\n+\tcase 0xffff0000:\n+\tcase 0xfffe0000:\n+\t  operands[2] = GEN_INT (intval >> 16);\n+\t  return \"dec.w\\t%G2,%e0\";\n \t}\n \n-      if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n+      /* See if we can finish with 4 bytes.  */\n+      if ((intval & 0xffff) == 0)\n \t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n-\t  return \"sub.l\\t%S2,%S0\";\n+\t  operands[2] = GEN_INT (intval >> 16);\n+\t  return \"add.w\\t%2,%e0\";\n \t}\n-      return \"add.l\\t%S2,%S0\";\n     }\n+\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n+    {\n+      operands[2] = GEN_INT (-INTVAL (operands[2]));\n+      return \"sub.l\\t%S2,%S0\";\n+    }\n+  return \"add.l\\t%S2,%S0\";\n }\n \n /* ??? It would be much easier to add the h8sx stuff if a single function\n@@ -2983,74 +2746,51 @@ compute_plussi_length (rtx *operands)\n \n   gcc_assert (mode == SImode);\n \n-  if (TARGET_H8300)\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && register_operand (operands[1], VOIDmode))\n     {\n-      if (GET_CODE (operands[2]) == REG)\n-\treturn 6;\n+      HOST_WIDE_INT intval = INTVAL (operands[2]);\n \n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  HOST_WIDE_INT n = INTVAL (operands[2]);\n+      if (TARGET_H8300SX && (intval >= 1 && intval <= 7))\n+\treturn 2;\n+      if (TARGET_H8300SX && (intval >= -7 && intval <= -1))\n+\treturn 2;\n \n-\t  if ((n & 0xffffff) == 0)\n-\t    return 2;\n-\t  if ((n & 0xffff) == 0)\n-\t    return 4;\n-\t  if ((n & 0xff) == 0)\n-\t    return 6;\n-\t}\n+      /* See if we can finish with 2 bytes.  */\n \n-      return 8;\n-    }\n-  else\n-    {\n-      if (GET_CODE (operands[2]) == CONST_INT\n-\t  && register_operand (operands[1], VOIDmode))\n+      switch ((unsigned int) intval & 0xffffffff)\n \t{\n-\t  HOST_WIDE_INT intval = INTVAL (operands[2]);\n-\n-\t  if (TARGET_H8300SX && (intval >= 1 && intval <= 7))\n-\t    return 2;\n-\t  if (TARGET_H8300SX && (intval >= -7 && intval <= -1))\n-\t    return 2;\n-\n-\t  /* See if we can finish with 2 bytes.  */\n-\n-\t  switch ((unsigned int) intval & 0xffffffff)\n-\t    {\n-\t    case 0x00000001:\n-\t    case 0x00000002:\n-\t    case 0x00000004:\n-\t      return 2;\n-\n-\t    case 0xffffffff:\n-\t    case 0xfffffffe:\n-\t    case 0xfffffffc:\n-\t      return 2;\n-\n-\t    case 0x00010000:\n-\t    case 0x00020000:\n-\t      return 2;\n-\n-\t    case 0xffff0000:\n-\t    case 0xfffe0000:\n-\t      return 2;\n-\t    }\n-\n-\t  /* See if we can finish with 4 bytes.  */\n-\t  if ((intval & 0xffff) == 0)\n-\t    return 4;\n+\tcase 0x00000001:\n+\tcase 0x00000002:\n+\tcase 0x00000004:\n+\t  return 2;\n+\n+\tcase 0xffffffff:\n+\tcase 0xfffffffe:\n+\tcase 0xfffffffc:\n+\t  return 2;\n+\n+\tcase 0x00010000:\n+\tcase 0x00020000:\n+\t  return 2;\n+\n+\tcase 0xffff0000:\n+\tcase 0xfffe0000:\n+\t  return 2;\n \t}\n \n-      if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-\treturn h8300_length_from_table (operands[0],\n-\t\t\t\t\tGEN_INT (-INTVAL (operands[2])),\n-\t\t\t\t\t&addl_length_table);\n-      else\n-\treturn h8300_length_from_table (operands[0], operands[2],\n-\t\t\t\t\t&addl_length_table);\n-      return 6;\n+      /* See if we can finish with 4 bytes.  */\n+      if ((intval & 0xffff) == 0)\n+\treturn 4;\n     }\n+\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n+    return h8300_length_from_table (operands[0],\n+\t\t\t\t    GEN_INT (-INTVAL (operands[2])),\n+\t\t\t\t    &addl_length_table);\n+  else\n+    return h8300_length_from_table (operands[0], operands[2],\n+\t\t\t\t    &addl_length_table);\n }\n \n /* Compute which flag bits are valid after an addition insn.  */\n@@ -3062,52 +2802,45 @@ compute_plussi_cc (rtx *operands)\n \n   gcc_assert (mode == SImode);\n \n-  if (TARGET_H8300)\n-    {\n-      return CC_CLOBBER;\n-    }\n-  else\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && register_operand (operands[1], VOIDmode))\n     {\n-      if (GET_CODE (operands[2]) == CONST_INT\n-\t  && register_operand (operands[1], VOIDmode))\n-\t{\n-\t  HOST_WIDE_INT intval = INTVAL (operands[2]);\n+      HOST_WIDE_INT intval = INTVAL (operands[2]);\n \n-\t  if (TARGET_H8300SX && (intval >= 1 && intval <= 7))\n-\t    return CC_SET_ZN;\n-\t  if (TARGET_H8300SX && (intval >= -7 && intval <= -1))\n-\t    return CC_SET_ZN;\n+      if (TARGET_H8300SX && (intval >= 1 && intval <= 7))\n+\treturn CC_SET_ZN;\n+      if (TARGET_H8300SX && (intval >= -7 && intval <= -1))\n+\treturn CC_SET_ZN;\n \n-\t  /* See if we can finish with 2 bytes.  */\n+      /* See if we can finish with 2 bytes.  */\n \n-\t  switch ((unsigned int) intval & 0xffffffff)\n-\t    {\n-\t    case 0x00000001:\n-\t    case 0x00000002:\n-\t    case 0x00000004:\n-\t      return CC_NONE_0HIT;\n-\n-\t    case 0xffffffff:\n-\t    case 0xfffffffe:\n-\t    case 0xfffffffc:\n-\t      return CC_NONE_0HIT;\n-\n-\t    case 0x00010000:\n-\t    case 0x00020000:\n-\t      return CC_CLOBBER;\n-\n-\t    case 0xffff0000:\n-\t    case 0xfffe0000:\n-\t      return CC_CLOBBER;\n-\t    }\n-\n-\t  /* See if we can finish with 4 bytes.  */\n-\t  if ((intval & 0xffff) == 0)\n-\t    return CC_CLOBBER;\n+      switch ((unsigned int) intval & 0xffffffff)\n+\t{\n+\tcase 0x00000001:\n+\tcase 0x00000002:\n+\tcase 0x00000004:\n+\t  return CC_NONE_0HIT;\n+\n+\tcase 0xffffffff:\n+\tcase 0xfffffffe:\n+\tcase 0xfffffffc:\n+\t  return CC_NONE_0HIT;\n+\n+\tcase 0x00010000:\n+\tcase 0x00020000:\n+\t  return CC_CLOBBER;\n+\n+\tcase 0xffff0000:\n+\tcase 0xfffe0000:\n+\t  return CC_CLOBBER;\n \t}\n \n-      return CC_SET_ZN;\n+      /* See if we can finish with 4 bytes.  */\n+      if ((intval & 0xffff) == 0)\n+\treturn CC_CLOBBER;\n     }\n+\n+  return CC_SET_ZN;\n }\n \f\n /* Output a logical insn.  */\n@@ -3132,8 +2865,6 @@ output_logical_op (machine_mode mode, rtx *operands)\n   /* Break up DET into pieces.  */\n   const unsigned HOST_WIDE_INT b0 = (det >>  0) & 0xff;\n   const unsigned HOST_WIDE_INT b1 = (det >>  8) & 0xff;\n-  const unsigned HOST_WIDE_INT b2 = (det >> 16) & 0xff;\n-  const unsigned HOST_WIDE_INT b3 = (det >> 24) & 0xff;\n   const unsigned HOST_WIDE_INT w0 = (det >>  0) & 0xffff;\n   const unsigned HOST_WIDE_INT w1 = (det >> 16) & 0xffff;\n   int lower_half_easy_p = 0;\n@@ -3161,9 +2892,7 @@ output_logical_op (machine_mode mode, rtx *operands)\n     {\n     case E_HImode:\n       /* First, see if we can finish with one insn.  */\n-      if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && b0 != 0\n-\t  && b1 != 0)\n+      if (b0 != 0 && b1 != 0)\n \t{\n \t  sprintf (insn_buf, \"%s.w\\t%%T2,%%T0\", opname);\n \t  output_asm_insn (insn_buf, operands);\n@@ -3185,24 +2914,20 @@ output_logical_op (machine_mode mode, rtx *operands)\n \t}\n       break;\n     case E_SImode:\n-      if (TARGET_H8300H || TARGET_H8300S)\n-\t{\n-\t  /* Determine if the lower half can be taken care of in no more\n-\t     than two bytes.  */\n-\t  lower_half_easy_p = (b0 == 0\n-\t\t\t       || b1 == 0\n-\t\t\t       || (code != IOR && w0 == 0xffff));\n-\n-\t  /* Determine if the upper half can be taken care of in no more\n-\t     than two bytes.  */\n-\t  upper_half_easy_p = ((code != IOR && w1 == 0xffff)\n-\t\t\t       || (code == AND && w1 == 0xff00));\n-\t}\n+      /* Determine if the lower half can be taken care of in no more\n+\t than two bytes.  */\n+      lower_half_easy_p = (b0 == 0\n+\t\t\t   || b1 == 0\n+\t\t\t   || (code != IOR && w0 == 0xffff));\n+\n+       /* Determine if the upper half can be taken care of in no more\n+\t  than two bytes.  */\n+      upper_half_easy_p = ((code != IOR && w1 == 0xffff)\n+\t\t\t   || (code == AND && w1 == 0xff00));\n \n       /* Check if doing everything with one insn is no worse than\n \t using multiple insns.  */\n-      if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && w0 != 0 && w1 != 0\n+      if (w0 != 0 && w1 != 0\n \t  && !(lower_half_easy_p && upper_half_easy_p)\n \t  && !(code == IOR && w1 == 0xffff\n \t       && (w0 & 0x8000) != 0 && lower_half_easy_p))\n@@ -3218,14 +2943,11 @@ output_logical_op (machine_mode mode, rtx *operands)\n \t     1) the special insn (in case of AND or XOR),\n \t     2) the word-wise insn, and\n \t     3) The byte-wise insn.  */\n-\t  if (w0 == 0xffff\n-\t      && (TARGET_H8300 ? (code == AND) : (code != IOR)))\n+\t  if (w0 == 0xffff && (code != IOR))\n \t    output_asm_insn ((code == AND)\n \t\t\t     ? \"sub.w\\t%f0,%f0\" : \"not.w\\t%f0\",\n \t\t\t     operands);\n-\t  else if ((TARGET_H8300H || TARGET_H8300S)\n-\t\t   && (b0 != 0)\n-\t\t   && (b1 != 0))\n+\t  else if ((b0 != 0) && (b1 != 0))\n \t    {\n \t      sprintf (insn_buf, \"%s.w\\t%%f2,%%f0\", opname);\n \t      output_asm_insn (insn_buf, operands);\n@@ -3244,45 +2966,29 @@ output_logical_op (machine_mode mode, rtx *operands)\n \t\t}\n \t    }\n \n-\t  if ((w1 == 0xffff)\n-\t      && (TARGET_H8300 ? (code == AND) : (code != IOR)))\n+\t  if ((w1 == 0xffff) && (code != IOR))\n \t    output_asm_insn ((code == AND)\n \t\t\t     ? \"sub.w\\t%e0,%e0\" : \"not.w\\t%e0\",\n \t\t\t     operands);\n-\t  else if ((TARGET_H8300H || TARGET_H8300S)\n-\t\t   && code == IOR\n+\t  else if (code == IOR\n \t\t   && w1 == 0xffff\n \t\t   && (w0 & 0x8000) != 0)\n \t    {\n \t      output_asm_insn (\"exts.l\\t%S0\", operands);\n \t    }\n-\t  else if ((TARGET_H8300H || TARGET_H8300S)\n-\t\t   && code == AND\n+\t  else if (code == AND\n \t\t   && w1 == 0xff00)\n \t    {\n \t      output_asm_insn (\"extu.w\\t%e0\", operands);\n \t    }\n-\t  else if (TARGET_H8300H || TARGET_H8300S)\n+\t  else\n \t    {\n \t      if (w1 != 0)\n \t\t{\n \t\t  sprintf (insn_buf, \"%s.w\\t%%e2,%%e0\", opname);\n \t\t  output_asm_insn (insn_buf, operands);\n \t\t}\n \t    }\n-\t  else\n-\t    {\n-\t      if (b2 != 0)\n-\t\t{\n-\t\t  sprintf (insn_buf, \"%s\\t%%y2,%%y0\", opname);\n-\t\t  output_asm_insn (insn_buf, operands);\n-\t\t}\n-\t      if (b3 != 0)\n-\t\t{\n-\t\t  sprintf (insn_buf, \"%s\\t%%z2,%%z0\", opname);\n-\t\t  output_asm_insn (insn_buf, operands);\n-\t\t}\n-\t    }\n \t}\n       break;\n     default:\n@@ -3313,8 +3019,6 @@ compute_logical_op_length (machine_mode mode, rtx *operands)\n   /* Break up DET into pieces.  */\n   const unsigned HOST_WIDE_INT b0 = (det >>  0) & 0xff;\n   const unsigned HOST_WIDE_INT b1 = (det >>  8) & 0xff;\n-  const unsigned HOST_WIDE_INT b2 = (det >> 16) & 0xff;\n-  const unsigned HOST_WIDE_INT b3 = (det >> 24) & 0xff;\n   const unsigned HOST_WIDE_INT w0 = (det >>  0) & 0xffff;\n   const unsigned HOST_WIDE_INT w1 = (det >> 16) & 0xffff;\n   int lower_half_easy_p = 0;\n@@ -3326,9 +3030,7 @@ compute_logical_op_length (machine_mode mode, rtx *operands)\n     {\n     case E_HImode:\n       /* First, see if we can finish with one insn.  */\n-      if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && b0 != 0\n-\t  && b1 != 0)\n+      if (b0 != 0 && b1 != 0)\n \t{\n \t  length = h8300_length_from_table (operands[1], operands[2],\n \t\t\t\t\t    &logicw_length_table);\n@@ -3345,24 +3047,20 @@ compute_logical_op_length (machine_mode mode, rtx *operands)\n \t}\n       break;\n     case E_SImode:\n-      if (TARGET_H8300H || TARGET_H8300S)\n-\t{\n-\t  /* Determine if the lower half can be taken care of in no more\n-\t     than two bytes.  */\n-\t  lower_half_easy_p = (b0 == 0\n-\t\t\t       || b1 == 0\n-\t\t\t       || (code != IOR && w0 == 0xffff));\n-\n-\t  /* Determine if the upper half can be taken care of in no more\n-\t     than two bytes.  */\n-\t  upper_half_easy_p = ((code != IOR && w1 == 0xffff)\n-\t\t\t       || (code == AND && w1 == 0xff00));\n-\t}\n+      /* Determine if the lower half can be taken care of in no more\n+\t than two bytes.  */\n+      lower_half_easy_p = (b0 == 0\n+\t\t\t   || b1 == 0\n+\t\t\t   || (code != IOR && w0 == 0xffff));\n+\n+      /* Determine if the upper half can be taken care of in no more\n+\t than two bytes.  */\n+      upper_half_easy_p = ((code != IOR && w1 == 0xffff)\n+\t\t\t   || (code == AND && w1 == 0xff00));\n \n       /* Check if doing everything with one insn is no worse than\n \t using multiple insns.  */\n-      if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && w0 != 0 && w1 != 0\n+      if (w0 != 0 && w1 != 0\n \t  && !(lower_half_easy_p && upper_half_easy_p)\n \t  && !(code == IOR && w1 == 0xffff\n \t       && (w0 & 0x8000) != 0 && lower_half_easy_p))\n@@ -3378,14 +3076,11 @@ compute_logical_op_length (machine_mode mode, rtx *operands)\n \t     1) the special insn (in case of AND or XOR),\n \t     2) the word-wise insn, and\n \t     3) The byte-wise insn.  */\n-\t  if (w0 == 0xffff\n-\t      && (TARGET_H8300 ? (code == AND) : (code != IOR)))\n+\t  if (w0 == 0xffff && (code != IOR))\n \t    {\n \t      length += 2;\n \t    }\n-\t  else if ((TARGET_H8300H || TARGET_H8300S)\n-\t\t   && (b0 != 0)\n-\t\t   && (b1 != 0))\n+\t  else if ((b0 != 0) && (b1 != 0))\n \t    {\n \t      length += 4;\n \t    }\n@@ -3398,37 +3093,25 @@ compute_logical_op_length (machine_mode mode, rtx *operands)\n \t\tlength += 2;\n \t    }\n \n-\t  if (w1 == 0xffff\n-\t      && (TARGET_H8300 ? (code == AND) : (code != IOR)))\n+\t  if (w1 == 0xffff && (code != IOR))\n \t    {\n \t      length += 2;\n \t    }\n-\t  else if ((TARGET_H8300H || TARGET_H8300S)\n-\t\t   && code == IOR\n+\t  else if (code == IOR\n \t\t   && w1 == 0xffff\n \t\t   && (w0 & 0x8000) != 0)\n \t    {\n \t      length += 2;\n \t    }\n-\t  else if ((TARGET_H8300H || TARGET_H8300S)\n-\t\t   && code == AND\n-\t\t   && w1 == 0xff00)\n+\t  else if (code == AND && w1 == 0xff00)\n \t    {\n \t      length += 2;\n \t    }\n-\t  else if (TARGET_H8300H || TARGET_H8300S)\n+\t  else\n \t    {\n \t      if (w1 != 0)\n \t\tlength += 4;\n \t    }\n-\t  else\n-\t    {\n-\t      if (b2 != 0)\n-\t\tlength += 2;\n-\n-\t      if (b3 != 0)\n-\t\tlength += 2;\n-\t    }\n \t}\n       break;\n     default:\n@@ -3470,32 +3153,26 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)\n     {\n     case E_HImode:\n       /* First, see if we can finish with one insn.  */\n-      if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && b0 != 0\n-\t  && b1 != 0)\n+      if (b0 != 0 && b1 != 0)\n \t{\n \t  cc = CC_SET_ZNV;\n \t}\n       break;\n     case E_SImode:\n-      if (TARGET_H8300H || TARGET_H8300S)\n-\t{\n-\t  /* Determine if the lower half can be taken care of in no more\n-\t     than two bytes.  */\n-\t  lower_half_easy_p = (b0 == 0\n-\t\t\t       || b1 == 0\n-\t\t\t       || (code != IOR && w0 == 0xffff));\n-\n-\t  /* Determine if the upper half can be taken care of in no more\n-\t     than two bytes.  */\n-\t  upper_half_easy_p = ((code != IOR && w1 == 0xffff)\n-\t\t\t       || (code == AND && w1 == 0xff00));\n-\t}\n+      /* Determine if the lower half can be taken care of in no more\n+\t than two bytes.  */\n+      lower_half_easy_p = (b0 == 0\n+\t\t\t   || b1 == 0\n+\t\t\t   || (code != IOR && w0 == 0xffff));\n+\n+      /* Determine if the upper half can be taken care of in no more\n+         than two bytes.  */\n+      upper_half_easy_p = ((code != IOR && w1 == 0xffff)\n+\t\t\t   || (code == AND && w1 == 0xff00));\n \n       /* Check if doing everything with one insn is no worse than\n \t using multiple insns.  */\n-      if ((TARGET_H8300H || TARGET_H8300S)\n-\t  && w0 != 0 && w1 != 0\n+      if (w0 != 0 && w1 != 0\n \t  && !(lower_half_easy_p && upper_half_easy_p)\n \t  && !(code == IOR && w1 == 0xffff\n \t       && (w0 & 0x8000) != 0 && lower_half_easy_p))\n@@ -3504,8 +3181,7 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)\n \t}\n       else\n \t{\n-\t  if ((TARGET_H8300H || TARGET_H8300S)\n-\t      && code == IOR\n+\t  if (code == IOR\n \t      && w1 == 0xffff\n \t      && (w0 & 0x8000) != 0)\n \t    {\n@@ -3916,8 +3592,7 @@ static void get_shift_alg (enum shift_type,\n /* Given SHIFT_TYPE, SHIFT_MODE, and shift count COUNT, determine the\n    best algorithm for doing the shift.  The assembler code is stored\n    in the pointers in INFO.  We achieve the maximum efficiency in most\n-   cases when !TARGET_H8300.  In case of TARGET_H8300, shifts in\n-   SImode in particular have a lot of room to optimize.\n+   cases.\n \n    We first determine the strategy of the shift algorithm by a table\n    lookup.  If that tells us to use a hand crafted assembly code, we\n@@ -3931,10 +3606,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n {\n   enum h8_cpu cpu;\n \n-  /* Find the target CPU.  */\n-  if (TARGET_H8300)\n-    cpu = H8_300;\n-  else if (TARGET_H8300S)\n+  if (TARGET_H8300S)\n     cpu = H8_S;\n   else\n     cpu = H8_300H;\n@@ -4008,16 +3680,10 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t  switch (shift_type)\n \t    {\n \t    case SHIFT_ASHIFT:\n-\t      if (TARGET_H8300)\n-\t\tinfo->special = \"shar.b\\t%t0\\n\\tmov.b\\t%s0,%t0\\n\\trotxr.b\\t%t0\\n\\trotr.b\\t%s0\\n\\tand.b\\t#0x80,%s0\";\n-\t      else\n-\t\tinfo->special = \"shar.b\\t%t0\\n\\tmov.b\\t%s0,%t0\\n\\trotxr.w\\t%T0\\n\\tand.b\\t#0x80,%s0\";\n+\t      info->special = \"shar.b\\t%t0\\n\\tmov.b\\t%s0,%t0\\n\\trotxr.w\\t%T0\\n\\tand.b\\t#0x80,%s0\";\n \t      goto end;\n \t    case SHIFT_LSHIFTRT:\n-\t      if (TARGET_H8300)\n-\t\tinfo->special = \"shal.b\\t%s0\\n\\tmov.b\\t%t0,%s0\\n\\trotxl.b\\t%s0\\n\\trotl.b\\t%t0\\n\\tand.b\\t#0x01,%t0\";\n-\t      else\n-\t\tinfo->special = \"shal.b\\t%s0\\n\\tmov.b\\t%t0,%s0\\n\\trotxl.w\\t%T0\\n\\tand.b\\t#0x01,%t0\";\n+\t      info->special = \"shal.b\\t%s0\\n\\tmov.b\\t%t0,%s0\\n\\trotxl.w\\t%T0\\n\\tand.b\\t#0x01,%t0\";\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n \t      info->special = \"shal.b\\t%s0\\n\\tmov.b\\t%t0,%s0\\n\\trotxl.b\\t%s0\\n\\tsubx\\t%t0,%t0\";\n@@ -4035,29 +3701,12 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      info->special = \"mov.b\\t%s0,%t0\\n\\tsub.b\\t%s0,%s0\";\n \t      goto end;\n \t    case SHIFT_LSHIFTRT:\n-\t      if (TARGET_H8300)\n-\t\t{\n-\t\t  info->special = \"mov.b\\t%t0,%s0\\n\\tsub.b\\t%t0,%t0\";\n-\t\t  info->shift1  = \"shlr.b\\t%s0\";\n-\t\t  info->cc_inline = CC_SET_ZNV;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  info->special = \"mov.b\\t%t0,%s0\\n\\textu.w\\t%T0\";\n-\t\t  info->cc_special = CC_SET_ZNV;\n-\t\t}\n+\t      info->special = \"mov.b\\t%t0,%s0\\n\\textu.w\\t%T0\";\n+\t      info->cc_special = CC_SET_ZNV;\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n-\t      if (TARGET_H8300)\n-\t\t{\n-\t\t  info->special = \"mov.b\\t%t0,%s0\\n\\tbld\\t#7,%s0\\n\\tsubx\\t%t0,%t0\";\n-\t\t  info->shift1  = \"shar.b\\t%s0\";\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  info->special = \"mov.b\\t%t0,%s0\\n\\texts.w\\t%T0\";\n-\t\t  info->cc_special = CC_SET_ZNV;\n-\t\t}\n+\t      info->special = \"mov.b\\t%t0,%s0\\n\\texts.w\\t%T0\";\n+\t      info->cc_special = CC_SET_ZNV;\n \t      goto end;\n \t    }\n \t}\n@@ -4066,17 +3715,11 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t  switch (shift_type)\n \t    {\n \t    case SHIFT_ASHIFT:\n-\t      if (TARGET_H8300)\n-\t\tinfo->special = \"mov.b\\t%s0,%t0\\n\\trotr.b\\t%t0\\n\\trotr.b\\t%t0\\n\\tand.b\\t#0xC0,%t0\\n\\tsub.b\\t%s0,%s0\";\n-\t      goto end;\n \t    case SHIFT_LSHIFTRT:\n-\t      if (TARGET_H8300)\n-\t\tinfo->special = \"mov.b\\t%t0,%s0\\n\\trotl.b\\t%s0\\n\\trotl.b\\t%s0\\n\\tand.b\\t#3,%s0\\n\\tsub.b\\t%t0,%t0\";\n+\t      goto end;\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n-\t      if (TARGET_H8300)\n-\t\tinfo->special = \"mov.b\\t%t0,%s0\\n\\tshll.b\\t%s0\\n\\tsubx.b\\t%t0,%t0\\n\\tshll.b\\t%s0\\n\\tmov.b\\t%t0,%s0\\n\\tbst.b\\t#0,%s0\";\n-\t      else if (TARGET_H8300H)\n+\t      if (TARGET_H8300H)\n \t\t{\n \t\t  info->special = \"shll.b\\t%t0\\n\\tsubx.b\\t%s0,%s0\\n\\tshll.b\\t%t0\\n\\trotxl.b\\t%s0\\n\\texts.w\\t%T0\";\n \t\t  info->cc_special = CC_SET_ZNV;\n@@ -4104,25 +3747,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n       gcc_unreachable ();\n \n     case SIshift:\n-      if (TARGET_H8300 && count >= 8 && count <= 9)\n-\t{\n-\t  info->remainder = count - 8;\n-\n-\t  switch (shift_type)\n-\t    {\n-\t    case SHIFT_ASHIFT:\n-\t      info->special = \"mov.b\\t%y0,%z0\\n\\tmov.b\\t%x0,%y0\\n\\tmov.b\\t%w0,%x0\\n\\tsub.b\\t%w0,%w0\";\n-\t      goto end;\n-\t    case SHIFT_LSHIFTRT:\n-\t      info->special = \"mov.b\\t%x0,%w0\\n\\tmov.b\\t%y0,%x0\\n\\tmov.b\\t%z0,%y0\\n\\tsub.b\\t%z0,%z0\";\n-\t      info->shift1  = \"shlr\\t%y0\\n\\trotxr\\t%x0\\n\\trotxr\\t%w0\";\n-\t      goto end;\n-\t    case SHIFT_ASHIFTRT:\n-\t      info->special = \"mov.b\\t%x0,%w0\\n\\tmov.b\\t%y0,%x0\\n\\tmov.b\\t%z0,%y0\\n\\tshll\\t%z0\\n\\tsubx\\t%z0,%z0\";\n-\t      goto end;\n-\t    }\n-\t}\n-      else if (count == 8 && !TARGET_H8300)\n+      if (count == 8)\n \t{\n \t  switch (shift_type)\n \t    {\n@@ -4137,21 +3762,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      goto end;\n \t    }\n \t}\n-      else if (count == 15 && TARGET_H8300)\n-\t{\n-\t  switch (shift_type)\n-\t    {\n-\t    case SHIFT_ASHIFT:\n-\t      gcc_unreachable ();\n-\t    case SHIFT_LSHIFTRT:\n-\t      info->special = \"bld\\t#7,%z0\\n\\tmov.w\\t%e0,%f0\\n\\txor\\t%y0,%y0\\n\\txor\\t%z0,%z0\\n\\trotxl\\t%w0\\n\\trotxl\\t%x0\\n\\trotxl\\t%y0\";\n-\t      goto end;\n-\t    case SHIFT_ASHIFTRT:\n-\t      info->special = \"bld\\t#7,%z0\\n\\tmov.w\\t%e0,%f0\\n\\trotxl\\t%w0\\n\\trotxl\\t%x0\\n\\tsubx\\t%y0,%y0\\n\\tsubx\\t%z0,%z0\";\n-\t      goto end;\n-\t    }\n-\t}\n-      else if (count == 15 && !TARGET_H8300)\n+      else if (count == 15)\n \t{\n \t  switch (shift_type)\n \t    {\n@@ -4167,8 +3778,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      gcc_unreachable ();\n \t    }\n \t}\n-      else if ((TARGET_H8300 && count >= 16 && count <= 20)\n-\t       || (TARGET_H8300H && count >= 16 && count <= 19)\n+      else if ((TARGET_H8300H && count >= 16 && count <= 19)\n \t       || (TARGET_H8300S && count >= 16 && count <= 21))\n \t{\n \t  info->remainder = count - 16;\n@@ -4177,55 +3787,14 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t    {\n \t    case SHIFT_ASHIFT:\n \t      info->special = \"mov.w\\t%f0,%e0\\n\\tsub.w\\t%f0,%f0\";\n-\t      if (TARGET_H8300)\n-\t\tinfo->shift1 = \"add.w\\t%e0,%e0\";\n \t      goto end;\n \t    case SHIFT_LSHIFTRT:\n-\t      if (TARGET_H8300)\n-\t\t{\n-\t\t  info->special = \"mov.w\\t%e0,%f0\\n\\tsub.w\\t%e0,%e0\";\n-\t\t  info->shift1  = \"shlr\\t%x0\\n\\trotxr\\t%w0\";\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  info->special = \"mov.w\\t%e0,%f0\\n\\textu.l\\t%S0\";\n-\t\t  info->cc_special = CC_SET_ZNV;\n-\t\t}\n-\t      goto end;\n-\t    case SHIFT_ASHIFTRT:\n-\t      if (TARGET_H8300)\n-\t\t{\n-\t\t  info->special = \"mov.w\\t%e0,%f0\\n\\tshll\\t%z0\\n\\tsubx\\t%z0,%z0\\n\\tmov.b\\t%z0,%y0\";\n-\t\t  info->shift1  = \"shar\\t%x0\\n\\trotxr\\t%w0\";\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  info->special = \"mov.w\\t%e0,%f0\\n\\texts.l\\t%S0\";\n-\t\t  info->cc_special = CC_SET_ZNV;\n-\t\t}\n-\t      goto end;\n-\t    }\n-\t}\n-      else if (TARGET_H8300 && count >= 24 && count <= 28)\n-\t{\n-\t  info->remainder = count - 24;\n-\n-\t  switch (shift_type)\n-\t    {\n-\t    case SHIFT_ASHIFT:\n-\t      info->special = \"mov.b\\t%w0,%z0\\n\\tsub.b\\t%y0,%y0\\n\\tsub.w\\t%f0,%f0\";\n-\t      info->shift1  = \"shll.b\\t%z0\";\n-\t      info->cc_inline = CC_SET_ZNV;\n-\t      goto end;\n-\t    case SHIFT_LSHIFTRT:\n-\t      info->special = \"mov.b\\t%z0,%w0\\n\\tsub.b\\t%x0,%x0\\n\\tsub.w\\t%e0,%e0\";\n-\t      info->shift1  = \"shlr.b\\t%w0\";\n-\t      info->cc_inline = CC_SET_ZNV;\n+\t      info->special = \"mov.w\\t%e0,%f0\\n\\textu.l\\t%S0\";\n+\t      info->cc_special = CC_SET_ZNV;\n \t      goto end;\n \t    case SHIFT_ASHIFTRT:\n-\t      info->special = \"mov.b\\t%z0,%w0\\n\\tbld\\t#7,%w0\\n\\tsubx\\t%x0,%x0\\n\\tsubx\\t%y0,%y0\\n\\tsubx\\t%z0,%z0\";\n-\t      info->shift1  = \"shar.b\\t%w0\";\n-\t      info->cc_inline = CC_SET_ZNV;\n+\t      info->special = \"mov.w\\t%e0,%f0\\n\\texts.l\\t%S0\";\n+\t      info->cc_special = CC_SET_ZNV;\n \t      goto end;\n \t    }\n \t}\n@@ -4249,7 +3818,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      goto end;\n \t    }\n \t}\n-      else if (!TARGET_H8300 && count == 28)\n+      else if (count == 28)\n \t{\n \t  switch (shift_type)\n \t    {\n@@ -4272,7 +3841,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      gcc_unreachable ();\n \t    }\n \t}\n-      else if (!TARGET_H8300 && count == 29)\n+      else if (count == 29)\n \t{\n \t  switch (shift_type)\n \t    {\n@@ -4298,7 +3867,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      gcc_unreachable ();\n \t    }\n \t}\n-      else if (!TARGET_H8300 && count == 30)\n+      else if (count == 30)\n \t{\n \t  switch (shift_type)\n \t    {\n@@ -4320,38 +3889,20 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t}\n       else if (count == 31)\n \t{\n-\t  if (TARGET_H8300)\n-\t    {\n-\t      switch (shift_type)\n-\t\t{\n-\t\tcase SHIFT_ASHIFT:\n-\t\t  info->special = \"sub.w\\t%e0,%e0\\n\\tshlr\\t%w0\\n\\tmov.w\\t%e0,%f0\\n\\trotxr\\t%z0\";\n-\t\t  goto end;\n-\t\tcase SHIFT_LSHIFTRT:\n-\t\t  info->special = \"sub.w\\t%f0,%f0\\n\\tshll\\t%z0\\n\\tmov.w\\t%f0,%e0\\n\\trotxl\\t%w0\";\n-\t\t  goto end;\n-\t\tcase SHIFT_ASHIFTRT:\n-\t\t  info->special = \"shll\\t%z0\\n\\tsubx\\t%w0,%w0\\n\\tmov.b\\t%w0,%x0\\n\\tmov.w\\t%f0,%e0\";\n-\t\t  goto end;\n-\t\t}\n-\t    }\n-\t  else\n+\t  switch (shift_type)\n \t    {\n-\t      switch (shift_type)\n-\t\t{\n-\t\tcase SHIFT_ASHIFT:\n-\t\t  info->special = \"shlr.l\\t%S0\\n\\txor.l\\t%S0,%S0\\n\\trotxr.l\\t%S0\";\n-\t\t  info->cc_special = CC_SET_ZNV;\n-\t\t  goto end;\n-\t\tcase SHIFT_LSHIFTRT:\n-\t\t  info->special = \"shll.l\\t%S0\\n\\txor.l\\t%S0,%S0\\n\\trotxl.l\\t%S0\";\n-\t\t  info->cc_special = CC_SET_ZNV;\n-\t\t  goto end;\n-\t\tcase SHIFT_ASHIFTRT:\n-\t\t  info->special = \"shll\\t%e0\\n\\tsubx\\t%w0,%w0\\n\\texts.w\\t%T0\\n\\texts.l\\t%S0\";\n-\t\t  info->cc_special = CC_SET_ZNV;\n-\t\t  goto end;\n-\t\t}\n+\t    case SHIFT_ASHIFT:\n+\t      info->special = \"shlr.l\\t%S0\\n\\txor.l\\t%S0,%S0\\n\\trotxr.l\\t%S0\";\n+\t      info->cc_special = CC_SET_ZNV;\n+\t      goto end;\n+\t    case SHIFT_LSHIFTRT:\n+\t      info->special = \"shll.l\\t%S0\\n\\txor.l\\t%S0,%S0\\n\\trotxl.l\\t%S0\";\n+\t      info->cc_special = CC_SET_ZNV;\n+\t      goto end;\n+\t    case SHIFT_ASHIFTRT:\n+\t      info->special = \"shll\\t%e0\\n\\tsubx\\t%w0,%w0\\n\\texts.w\\t%T0\\n\\texts.l\\t%S0\";\n+\t      info->cc_special = CC_SET_ZNV;\n+\t      goto end;\n \t    }\n \t}\n       gcc_unreachable ();\n@@ -4378,9 +3929,7 @@ h8300_shift_needs_scratch_p (int count, machine_mode mode)\n     return 1;\n \n   /* Find out the target CPU.  */\n-  if (TARGET_H8300)\n-    cpu = H8_300;\n-  else if (TARGET_H8300S)\n+  if (TARGET_H8300S)\n     cpu = H8_S;\n   else\n     cpu = H8_300H;\n@@ -4530,7 +4079,6 @@ output_a_shift (rtx *operands)\n \t    break;\n \n \t  case E_HImode:\n-\t    gcc_assert (TARGET_H8300H || TARGET_H8300S);\n \t    sprintf (insn_buf, \"and.w\\t#%d,%%T0\", mask);\n \t    break;\n \n@@ -4704,7 +4252,6 @@ compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n \t\twlength += 2;\n \t\tbreak;\n \t      case E_SImode:\n-\t\tgcc_assert (!TARGET_H8300);\n \t\twlength += 3;\n \t\tbreak;\n \t      default:\n@@ -4970,8 +4517,7 @@ output_a_rotate (enum rtx_code code, rtx *operands)\n \n   /* See if a byte swap (in HImode) or a word swap (in SImode) can\n      boost up the rotation.  */\n-  if ((mode == HImode && TARGET_H8300 && amount >= 5)\n-      || (mode == HImode && TARGET_H8300H && amount >= 6)\n+  if ((mode == HImode && TARGET_H8300H && amount >= 6)\n       || (mode == HImode && TARGET_H8300S && amount == 8)\n       || (mode == SImode && TARGET_H8300H && amount >= 10)\n       || (mode == SImode && TARGET_H8300S && amount >= 13))\n@@ -5044,8 +4590,7 @@ compute_a_rotate_length (rtx *operands)\n \n   /* See if a byte swap (in HImode) or a word swap (in SImode) can\n      boost up the rotation.  */\n-  if ((mode == HImode && TARGET_H8300 && amount >= 5)\n-      || (mode == HImode && TARGET_H8300H && amount >= 6)\n+  if ((mode == HImode && TARGET_H8300H && amount >= 6)\n       || (mode == HImode && TARGET_H8300S && amount == 8)\n       || (mode == SImode && TARGET_H8300H && amount >= 10)\n       || (mode == SImode && TARGET_H8300S && amount >= 13))\n@@ -5061,7 +4606,7 @@ compute_a_rotate_length (rtx *operands)\n \n   /* The H8/300 uses three insns to rotate one bit, taking 6\n      length.  */\n-  length += amount * ((TARGET_H8300 && mode == HImode) ? 6 : 2);\n+  length += amount * 2;\n \n   return length;\n }\n@@ -5395,41 +4940,24 @@ h8300_encode_section_info (tree decl, rtx rtl, int first)\n const char *\n output_simode_bld (int bild, rtx operands[])\n {\n-  if (TARGET_H8300)\n-    {\n-      /* Clear the destination register.  */\n-      output_asm_insn (\"sub.w\\t%e0,%e0\\n\\tsub.w\\t%f0,%f0\", operands);\n+  /* Determine if we can clear the destination first.  */\n+  int clear_first = (REG_P (operands[0]) && REG_P (operands[1])\n+\t\t     && REGNO (operands[0]) != REGNO (operands[1]));\n \n-      /* Now output the bit load or bit inverse load, and store it in\n-\t the destination.  */\n-      if (bild)\n-\toutput_asm_insn (\"bild\\t%Z2,%Y1\", operands);\n-      else\n-\toutput_asm_insn (\"bld\\t%Z2,%Y1\", operands);\n+  if (clear_first)\n+    output_asm_insn (\"sub.l\\t%S0,%S0\", operands);\n \n-      output_asm_insn (\"bst\\t#0,%w0\", operands);\n-    }\n+  /* Output the bit load or bit inverse load.  */\n+  if (bild)\n+    output_asm_insn (\"bild\\t%Z2,%Y1\", operands);\n   else\n-    {\n-      /* Determine if we can clear the destination first.  */\n-      int clear_first = (REG_P (operands[0]) && REG_P (operands[1])\n-\t\t\t && REGNO (operands[0]) != REGNO (operands[1]));\n+    output_asm_insn (\"bld\\t%Z2,%Y1\", operands);\n \n-      if (clear_first)\n-\toutput_asm_insn (\"sub.l\\t%S0,%S0\", operands);\n+  if (!clear_first)\n+    output_asm_insn (\"xor.l\\t%S0,%S0\", operands);\n \n-      /* Output the bit load or bit inverse load.  */\n-      if (bild)\n-\toutput_asm_insn (\"bild\\t%Z2,%Y1\", operands);\n-      else\n-\toutput_asm_insn (\"bld\\t%Z2,%Y1\", operands);\n-\n-      if (!clear_first)\n-\toutput_asm_insn (\"xor.l\\t%S0,%S0\", operands);\n-\n-      /* Perform the bit store.  */\n-      output_asm_insn (\"rotxl.l\\t%S0\", operands);\n-    }\n+  /* Perform the bit store.  */\n+  output_asm_insn (\"rotxl.l\\t%S0\", operands);\n \n   /* All done.  */\n   return \"\";\n@@ -5478,7 +5006,7 @@ h8300_eightbit_constant_address_p (rtx x)\n   addr = INTVAL (x);\n \n   return (0\n-\t  || ((TARGET_H8300 || TARGET_NORMAL_MODE) && IN_RANGE (addr, n1, n2))\n+\t  || (TARGET_NORMAL_MODE && IN_RANGE (addr, n1, n2))\n \t  || (TARGET_H8300H && IN_RANGE (addr, h1, h2))\n \t  || (TARGET_H8300S && IN_RANGE (addr, s1, s2)));\n }\n@@ -5728,14 +5256,9 @@ h8300_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n static bool\n h8300_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n-  if (TARGET_H8300)\n-    /* If an even reg, then anything goes.  Otherwise the mode must be\n-       QI or HI.  */\n-    return ((regno & 1) == 0) || (mode == HImode) || (mode == QImode);\n-  else\n-    /* MAC register can only be of SImode.  Otherwise, anything\n-       goes.  */\n-    return regno == MAC_REG ? mode == SImode : 1;\n+  /* MAC register can only be of SImode.  Otherwise, anything\n+     goes.  */\n+  return regno == MAC_REG ? mode == SImode : 1;\n }\n \n /* Implement TARGET_MODES_TIEABLE_P.  */\n@@ -5746,10 +5269,10 @@ h8300_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n   return (mode1 == mode2\n \t  || ((mode1 == QImode\n \t       || mode1 == HImode\n-\t       || ((TARGET_H8300H || TARGET_H8300S) && mode1 == SImode))\n+\t       || mode1 == SImode)\n \t      && (mode2 == QImode\n \t\t  || mode2 == HImode\n-\t\t  || ((TARGET_H8300H || TARGET_H8300S) && mode2 == SImode))));\n+\t\t  || mode2 == SImode)));\n }\n \n /* Helper function for the move patterns.  Make sure a move is legitimate.  */\n@@ -5835,7 +5358,7 @@ static bool\n h8300_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n {\n   return (TYPE_MODE (type) == BLKmode\n-\t  || GET_MODE_SIZE (TYPE_MODE (type)) > (TARGET_H8300 ? 4 : 8));\n+\t  || GET_MODE_SIZE (TYPE_MODE (type)) > 8);\n }\n \f\n /* We emit the entire trampoline here.  Depending on the pointer size,"}, {"sha": "bf20ce28e24a16d643ecf80b44d6d15f45dbc97b", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=27c1afd533722e0dbc90562618a136653339cc49", "patch": "@@ -23,11 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_H8300_H\n #define GCC_H8300_H\n \n-/* Which CPU to compile for.\n-   We use int for CPU_TYPE to avoid lots of casts.  */\n-#if 0 /* defined in insn-attr.h, here for documentation */\n-enum attr_cpu { CPU_H8300, CPU_H8300H };\n-#endif\n extern int cpu_type;\n \n /* Various globals defined in h8300.c.  */\n@@ -57,7 +52,7 @@ extern const char * const *h8_reg_names;\n \t      builtin_define (\"__NORMAL_MODE__\");\t\\\n \t    }\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n-      else if (TARGET_H8300H)\t\t\t\t\\\n+      else\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\\\n \t  builtin_define (\"__H8300H__\");\t\t\\\n \t  builtin_assert (\"cpu=h8300h\");\t\t\\\n@@ -67,12 +62,6 @@ extern const char * const *h8_reg_names;\n \t      builtin_define (\"__NORMAL_MODE__\");\t\\\n \t    }\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  builtin_define (\"__H8300__\");\t\t\t\\\n-\t  builtin_assert (\"cpu=h8300\");\t\t\t\\\n-\t  builtin_assert (\"machine=h8300\");\t\t\\\n-\t}\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -81,7 +70,6 @@ extern const char * const *h8_reg_names;\n /* Macros used in the machine description to test the flags.  */\n \n /* Select between the H8/300 and H8/300H CPUs.  */\n-#define TARGET_H8300\t(! TARGET_H8300H && ! TARGET_H8300S)\n #define TARGET_H8300S\t(TARGET_H8300S_1 || TARGET_H8300SX)\n /* Some multiply instructions are not available in all H8SX variants.\n    Use this macro instead of TARGET_H8300SX to indicate this, even\n@@ -114,7 +102,7 @@ extern const char * const *h8_reg_names;\n /* Default target_flags if no switches specified.  */\n \n #ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT (MASK_QUICKCALL)\n+#define TARGET_DEFAULT (MASK_H8300H | MASK_QUICKCALL)\n #endif\n \n /* We want dwarf2 info available to gdb.  */\n@@ -154,7 +142,7 @@ extern const char * const *h8_reg_names;\n #define MAX_BITS_PER_WORD\t32\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD\t\t(TARGET_H8300H || TARGET_H8300S ? 4 : 2)\n+#define UNITS_PER_WORD\t\t4\n #define MIN_UNITS_PER_WORD\t2\n \n #define SHORT_TYPE_SIZE\t16\n@@ -168,7 +156,7 @@ extern const char * const *h8_reg_names;\n #define MAX_FIXED_MODE_SIZE\t32\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY (TARGET_H8300H || TARGET_H8300S ? 32 : 16)\n+#define PARM_BOUNDARY 32\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 16\n@@ -182,10 +170,10 @@ extern const char * const *h8_reg_names;\n /* No data type wants to be aligned rounder than this.\n    32-bit values are aligned as such on the H8/300H and H8S for speed.  */\n #define BIGGEST_ALIGNMENT \\\n-(((TARGET_H8300H || TARGET_H8300S) && ! TARGET_ALIGN_300) ? 32 : 16)\n+((! TARGET_ALIGN_300) ? 32 : 16)\n \n-/* The stack goes in 16/32 bit lumps.  */\n-#define STACK_BOUNDARY (TARGET_H8300 ? 16 : 32)\n+/* The stack goes in 32 bit lumps.  */\n+#define STACK_BOUNDARY 32\n \n /* Define this if move instructions will actually fail to work\n    when given unaligned data.  */\n@@ -478,8 +466,8 @@ struct cum_arg\n   (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\\\n    || (GET_CODE (X) == CONST_INT\t\t\t\t\\\n        /* We handle signed and unsigned offsets here.  */\t\\\n-       && INTVAL (X) > (TARGET_H8300 ? -0x10000 : -0x1000000)\t\\\n-       && INTVAL (X) < (TARGET_H8300 ? 0x10000 : 0x1000000))\t\\\n+       && INTVAL (X) > -0x1000000\t\t\t\t\\\n+       && INTVAL (X) < 0x1000000)\t\t\t\t\\\n    || (GET_CODE (X) == HIGH || GET_CODE (X) == CONST))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n@@ -530,7 +518,7 @@ struct cum_arg\n \n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  */\n-#define MOVE_MAX\t(TARGET_H8300H || TARGET_H8300S ? 4 : 2)\n+#define MOVE_MAX\t4\n #define MAX_MOVE_MAX\t4\n \n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n@@ -545,18 +533,18 @@ struct cum_arg\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n #define Pmode\t\t\t\t\t\t\t\t      \\\n-  ((TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE ? SImode : HImode)\n+  (!TARGET_NORMAL_MODE ? SImode : HImode)\n \n /* ANSI C types.\n    We use longs for the H8/300H and the H8S because ints can be 16 or 32.\n    GCC requires SIZE_TYPE to be the same size as pointers.  */\n #define SIZE_TYPE\t\t\t\t\t\t\t\t\\\n-  (TARGET_H8300 || TARGET_NORMAL_MODE ? TARGET_INT32 ? \"short unsigned int\" : \"unsigned int\" : \"long unsigned int\")\n+  (TARGET_NORMAL_MODE ? TARGET_INT32 ? \"short unsigned int\" : \"unsigned int\" : \"long unsigned int\")\n #define PTRDIFF_TYPE\t\t\t\t\t\t\\\n-  (TARGET_H8300 || TARGET_NORMAL_MODE ? TARGET_INT32 ? \"short int\" : \"int\" : \"long int\")\n+  (TARGET_NORMAL_MODE ? TARGET_INT32 ? \"short int\" : \"int\" : \"long int\")\n \n #define POINTER_SIZE\t\t\t\t\t\t\t\\\n-  ((TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE ? 32 : 16)\n+  (!TARGET_NORMAL_MODE ? 32 : 16)\n \n #define WCHAR_TYPE \"short unsigned int\"\n #define WCHAR_TYPE_SIZE 16\n@@ -611,7 +599,7 @@ struct cum_arg\n \n /* The assembler op to get a word, 2 bytes for the H8/300, 4 for H8/300H.  */\n #define ASM_WORD_OP\t\t\t\t\t\t\t\\\n-  (TARGET_H8300 || TARGET_NORMAL_MODE ? \"\\t.word\\t\" : \"\\t.long\\t\")\n+  (TARGET_NORMAL_MODE ? \"\\t.word\\t\" : \"\\t.long\\t\")\n \n #define TEXT_SECTION_ASM_OP \"\\t.section .text\"\n #define DATA_SECTION_ASM_OP \"\\t.section .data\""}, {"sha": "f87b0f7fd2fc3d30f699970f82a000c590b1ee35", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 286, "deletions": 765, "changes": 1051, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=27c1afd533722e0dbc90562618a136653339cc49", "patch": "@@ -167,8 +167,7 @@\n \n (define_asm_attributes\n   [(set (attr \"length\")\n-\t(cond [(match_test \"TARGET_H8300\") (const_int 4)\n-\t       (match_test \"TARGET_H8300H\") (const_int 10)\n+\t(cond [(match_test \"TARGET_H8300H\") (const_int 10)\n \t       (match_test \"TARGET_H8300S\") (const_int 10)]\n \t      (const_int 14)))])\n \n@@ -205,7 +204,7 @@\n (define_insn \"*movqi_h8nosx\"\n   [(set (match_operand:QI 0 \"general_operand_dst\" \"=r,r ,<,r,r,m\")\n \t(match_operand:QI 1 \"general_operand_src\" \" I,r>,r,n,m,r\"))]\n-  \"(TARGET_H8300 || TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\n+  \"!TARGET_H8300SX\n     && h8300_move_ok (operands[0], operands[1])\"\n   \"@\n    sub.b\t%X0,%X0\n@@ -234,13 +233,7 @@\n   \"\"\n   {\n     enum machine_mode mode = <MODE>mode;\n-    if (TARGET_H8300 && (mode == SImode || mode == SFmode))\n-      {\n-\t/* The original H8/300 needs to split up 32 bit moves.  */\n-\tif (h8300_expand_movsi (operands))\n-\t  DONE;\n-      }\n-    else if (!TARGET_H8300SX)\n+    if (!TARGET_H8300SX)\n       {\n \t/* Other H8 chips, except the H8/SX family can only handle a\n \t   single memory operand, which is checked by h8300_move_ok.\n@@ -268,7 +261,7 @@\n (define_insn \"*movhi_h8nosx\"\n   [(set (match_operand:HI 0 \"general_operand_dst\" \"=r,r,<,r,r,m\")\n \t(match_operand:HI 1 \"general_operand_src\" \"I,r>,r,i,m,r\"))]\n-  \"(TARGET_H8300 || TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\n+  \"!TARGET_H8300SX\n     && h8300_move_ok (operands[0], operands[1])\"\n   \"@\n    sub.w\t%T0,%T0\n@@ -308,76 +301,6 @@\n    (set_attr \"cc\" \"set_zn,set_znv,set_znv\")])\n \n ;; movsi\n-\n-(define_insn \"*movsi_h8300\"\n-  [(set (match_operand:SI 0 \"general_operand_dst\" \"=r,r,r,o,<,r\")\n-\t(match_operand:SI 1 \"general_operand_src\" \"I,r,io,r,r,>\"))]\n-  \"TARGET_H8300\n-   && h8300_move_ok (operands[0], operands[1])\"\n-{\n-  unsigned int rn = -1;\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"sub.w\t%e0,%e0\\;sub.w\t%f0,%f0\";\n-    case 1:\n-      if (REGNO (operands[0]) < REGNO (operands[1]))\n-\treturn \"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\";\n-      else\n-\treturn \"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\";\n-    case 2:\n-      /* Make sure we don't trample the register we index with.  */\n-      if (GET_CODE (operands[1]) == MEM)\n-\t{\n-\t  rtx inside = XEXP (operands[1], 0);\n-\t  if (REG_P (inside))\n-\t    {\n-\t      rn = REGNO (inside);\n-\t    }\n-\t  else if (GET_CODE (inside) == PLUS)\n-\t    {\n-\t      rtx lhs = XEXP (inside, 0);\n-\t      rtx rhs = XEXP (inside, 1);\n-\t      if (REG_P (lhs)) rn = REGNO (lhs);\n-\t      if (REG_P (rhs)) rn = REGNO (rhs);\n-\t    }\n-\t}\n-      if (rn == REGNO (operands[0]))\n-\t{\n-\t  /* Move the second word first.  */\n-\t  return \"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\";\n-\t}\n-      else\n-\t{\n-\t  if (GET_CODE (operands[1]) == CONST_INT)\n-\t    {\n-\t      /* If either half is zero, use sub.w to clear that\n-\t\t half.  */\n-\t      if ((INTVAL (operands[1]) & 0xffff) == 0)\n-\t\treturn \"mov.w\t%e1,%e0\\;sub.w\t%f0,%f0\";\n-\t      if (((INTVAL (operands[1]) >> 16) & 0xffff) == 0)\n-\t\treturn \"sub.w\t%e0,%e0\\;mov.w\t%f1,%f0\";\n-\t      /* If the upper half and the lower half are the same,\n-\t\t copy one half to the other.  */\n-\t      if ((INTVAL (operands[1]) & 0xffff)\n-\t\t  == ((INTVAL (operands[1]) >> 16) & 0xffff))\n-\t\treturn \"mov.w\\\\t%e1,%e0\\;mov.w\\\\t%e0,%f0\";\n-\t    }\n-\t  return \"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\";\n-\t}\n-    case 3:\n-      return \"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\";\n-    case 4:\n-      return \"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\";\n-    case 5:\n-      return \"mov.w\t%T1,%e0\\;mov.w\t%T1,%f0\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set (attr \"length\")\n-\t(symbol_ref \"compute_mov_length (operands)\"))])\n-\n (define_insn \"*movsi_h8300hs\"\n   [(set (match_operand:SI 0 \"general_operand_dst\" \"=r,r,r,<,r,r,m,*a,*a,r\")\n \t(match_operand:SI 1 \"general_operand_src\" \"I,r,i,r,>,m,r,I,r,*a\"))]\n@@ -476,65 +399,10 @@\n \n (include \"mova.md\")\n \n-(define_insn \"*movsf_h8300\"\n-  [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,r,r,o,<,r\")\n-\t(match_operand:SF 1 \"general_operand_src\" \"G,r,io,r,r,>\"))]\n-  \"TARGET_H8300\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode))\"\n-{\n-  /* Copy of the movsi stuff.  */\n-  unsigned int rn = -1;\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"sub.w\t%e0,%e0\\;sub.w\t%f0,%f0\";\n-    case 1:\n-      if (REGNO (operands[0]) < REGNO (operands[1]))\n-\treturn \"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\";\n-      else\n-\treturn \"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\";\n-    case 2:\n-      /* Make sure we don't trample the register we index with.  */\n-      if (GET_CODE (operands[1]) == MEM)\n-\t{\n-\t  rtx inside = XEXP (operands[1], 0);\n-\t  if (REG_P (inside))\n-\t    {\n-\t      rn = REGNO (inside);\n-\t    }\n-\t  else if (GET_CODE (inside) == PLUS)\n-\t    {\n-\t      rtx lhs = XEXP (inside, 0);\n-\t      rtx rhs = XEXP (inside, 1);\n-\t      if (REG_P (lhs)) rn = REGNO (lhs);\n-\t      if (REG_P (rhs)) rn = REGNO (rhs);\n-\t    }\n-\t}\n-      if (rn == REGNO (operands[0]))\n-\t/* Move the second word first.  */\n-\treturn \"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\";\n-      else\n-\t/* Move the first word first.  */\n-\treturn \"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\";\n-\n-    case 3:\n-      return \"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\";\n-    case 4:\n-      return \"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\";\n-    case 5:\n-      return \"mov.w\t%T1,%e0\\;mov.w\t%T1,%f0\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set (attr \"length\")\n-\t(symbol_ref \"compute_mov_length (operands)\"))])\n-\n (define_insn \"*movsf_h8300hs\"\n   [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,r,r,m,<,r\")\n \t(match_operand:SF 1 \"general_operand_src\" \"G,r,im,r,r,>\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\n+  \"!TARGET_H8300SX\n     && (register_operand (operands[0], SFmode)\n \t|| register_operand (operands[1], SFmode))\"\n   \"@\n@@ -552,23 +420,13 @@\n ;; PUSH INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"*pushqi1_h8300\"\n-  [(set (mem:QI\n-\t(pre_modify:HI\n-\t  (reg:HI SP_REG)\n-\t  (plus:HI (reg:HI SP_REG) (const_int -2))))\n-\t(match_operand:QI 0 \"register_no_sp_elim_operand\" \"r\"))]\n-  \"TARGET_H8300\"\n-  \"mov.w\\\\t%T0,@-r7\"\n-  [(set_attr \"length\" \"2\")])\n-\n (define_insn \"*push1_h8300hs_<QHI:mode>\"\n   [(set (mem:QHI\n \t(pre_modify:P\n \t  (reg:P SP_REG)\n \t  (plus:P (reg:P SP_REG) (const_int -4))))\n \t(match_operand:QHI 0 \"register_no_sp_elim_operand\" \"r\"))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mov.l\\\\t%S0,@-er7\"\n   [(set_attr \"length\" \"4\")])\n \n@@ -577,25 +435,14 @@\n ;; TEST INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare (zero_extract:QI (match_operand:QI 0 \"bit_memory_operand\" \"r,U\")\n-\t\t\t\t  (const_int 1)\n-\t\t\t\t  (match_operand 1 \"const_int_operand\" \"n,n\"))\n-\t\t (const_int 0)))]\n-  \"TARGET_H8300\"\n-  \"btst\t%Z1,%Y0\"\n-  [(set_attr \"length\" \"2,4\")\n-   (set_attr \"cc\" \"set_zn,set_zn\")])\n-\n (define_insn_and_split \"*tst_extzv_1_n\"\n   [(set (cc0)\n \t(compare (zero_extract:SI (match_operand:QI 0 \"general_operand_src\" \"r,U,mn>\")\n \t\t\t\t  (const_int 1)\n \t\t\t\t  (match_operand 1 \"const_int_operand\" \"n,n,n\"))\n \t\t (const_int 0)))\n    (clobber (match_scratch:QI 2 \"=X,X,&r\"))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"@\n    btst\\\\t%Z1,%Y0\n    btst\\\\t%Z1,%Y0\n@@ -619,8 +466,7 @@\n \t\t\t\t   (const_int 1)\n \t\t\t\t   (match_operand 1 \"const_int_operand\" \"n\"))\n \t\t (const_int 0)))]\n-  \"(TARGET_H8300 || TARGET_H8300H || TARGET_H8300S)\n-    && INTVAL (operands[1]) <= 15\"\n+  \"INTVAL (operands[1]) <= 15\"\n   \"btst\t%Z1,%Y0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_zn\")])\n@@ -632,8 +478,7 @@\n \t\t\t\t  (match_operand 1 \"const_int_operand\" \"n\"))\n \t\t (const_int 0)))\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && INTVAL (operands[1]) >= 16\"\n+  \"INTVAL (operands[1]) >= 16\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2)\n@@ -657,7 +502,7 @@\n \t\t\t\t  (and:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t\t\t  (const_int 7)))\n \t\t (const_int 0)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"btst\t%w1,%w0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_zn\")])\n@@ -670,7 +515,7 @@\n \t\t\t\t\t  (const_int 7)))\n \t\t (const_int 0)))\n    (clobber (match_scratch:QI 2 \"=X,X,&r\"))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"@\n    btst\\\\t%w1,%X0\n    btst\\\\t%w1,%X0\n@@ -719,7 +564,7 @@\n   [(set (cc0)\n \t(compare (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t (const_int 0)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mov.l\t%S0,%S0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n@@ -743,20 +588,11 @@\n   [(set_attr \"length_table\" \"add\")\n    (set_attr \"cc\" \"compare\")])\n \n-(define_insn \"*cmphi_h8300_znvc\"\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"r\")\n-\t\t (match_operand:HI 1 \"register_operand\" \"r\")))]\n-  \"TARGET_H8300\"\n-  \"cmp.w\t%T1,%T0\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"compare\")])\n-\n (define_insn \"*cmphi_h8300hs_znvc\"\n   [(set (cc0)\n \t(compare (match_operand:HI 0 \"h8300_dst_operand\" \"rU,rQ\")\n \t\t (match_operand:HI 1 \"h8300_src_operand\" \"P3>X,rQi\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n {\n   switch (which_alternative)\n     {\n@@ -778,7 +614,7 @@\n   [(set (cc0)\n \t(compare (match_operand:SI 0 \"h8300_dst_operand\" \"r,rQ\")\n \t\t (match_operand:SI 1 \"h8300_src_operand\" \"P3>X,rQi\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n {\n   switch (which_alternative)\n     {\n@@ -817,57 +653,11 @@\n   [(set_attr \"length_table\" \"add\")\n    (set_attr \"cc\" \"set_zn\")])\n \n-(define_insn \"*addhi3_h8300\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r\")\n-\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0\")\n-\t\t (match_operand:HI 2 \"h8300_src_operand\" \"L,N,J,n,r\")))]\n-  \"TARGET_H8300\"\n-  \"@\n-   adds\t%2,%T0\n-   subs\t%G2,%T0\n-   add.b\t%t2,%t0\n-   add.b\t%s2,%s0\\;addx\t%t2,%t0\n-   add.w\t%T2,%T0\"\n-  [(set_attr \"length\" \"2,2,2,4,2\")\n-   (set_attr \"cc\" \"none_0hit,none_0hit,clobber,clobber,set_zn\")])\n-\n-;; This splitter is very important to make the stack adjustment\n-;; interrupt-safe.  The combination of add.b and addx is unsafe!\n-;;\n-;; We apply this split after the peephole2 pass so that we won't end\n-;; up creating too many adds/subs when a scratch register is\n-;; available, which is actually a common case because stack unrolling\n-;; tends to happen immediately after a function call.\n-\n-(define_split\n-  [(set (match_operand:HI 0 \"stack_pointer_operand\" \"\")\n-\t(plus:HI (match_dup 0)\n-\t\t (match_operand 1 \"const_int_gt_2_operand\" \"\")))]\n-  \"TARGET_H8300 && epilogue_completed\"\n-  [(const_int 0)]\n-  {\n-    split_adds_subs (HImode, operands);\n-    DONE;\n-  })\n-\n-(define_peephole2\n-  [(match_scratch:HI 2 \"r\")\n-   (set (match_operand:HI 0 \"stack_pointer_operand\" \"\")\n-\t(plus:HI (match_dup 0)\n-\t\t (match_operand:HI 1 \"const_int_ge_8_operand\" \"\")))]\n-  \"TARGET_H8300\"\n-  [(set (match_dup 2)\n-\t(match_dup 1))\n-   (set (match_dup 0)\n-\t(plus:HI (match_dup 0)\n-\t\t (match_dup 2)))]\n-  \"\")\n-\n (define_insn \"*addhi3_h8300hs\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0\")\n \t\t (match_operand:HI 2 \"h8300_src_operand\" \"L,N,J,n,r\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\"\n+  \"!TARGET_H8300SX\"\n   \"@\n    adds\t%2,%S0\n    subs\t%G2,%S0\n@@ -882,7 +672,7 @@\n \t(unspec:HSI [(match_operand:HSI 1 \"register_operand\" \"0,0\")\n \t\t     (match_operand:HSI 2 \"incdec_operand\" \"M,O\")]\n \t\t    UNSPEC_INCDEC))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   {\n     if (which_alternative == 0)\n       return <MODE>mode == HImode ? \"inc.w\\t%2,%T0\" : \"inc.l\\t%2,%S0\";\n@@ -919,24 +709,11 @@\n   })\n \n \n-(define_insn \"*addsi_h8300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:SI 2 \"h8300_src_operand\" \"n,r\")))]\n-  \"TARGET_H8300\"\n-{\n-  return output_plussi (operands);\n-}\n-  [(set (attr \"length\")\n-\t(symbol_ref \"compute_plussi_length (operands)\"))\n-   (set (attr \"cc\")\n-\t(symbol_ref \"compute_plussi_cc (operands)\"))])\n-\n (define_insn \"*addsi_h8300hs\"\n   [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ,rQ\")\n \t(plus:SI (match_operand:SI 1 \"h8300_dst_operand\" \"%0,0\")\n \t\t (match_operand:SI 2 \"h8300_src_operand\" \"i,rQ\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n+  \"h8300_operands_match_p (operands)\"\n {\n   return output_plussi (operands);\n }\n@@ -949,7 +726,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(plus:SI (match_dup 0)\n \t\t (match_operand:SI 1 \"two_insn_adds_subs_operand\" \"\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   [(const_int 0)]\n   {\n     split_adds_subs (SImode, operands);\n@@ -966,8 +743,6 @@\n \t\t    (match_operand:QHSI 2 \"h8300_src_operand\" \"\")))]\n   \"\"\n   {\n-    if (TARGET_H8300 && <MODE>mode == SImode)\n-      operands[2] = force_reg (SImode, operands[2]);\n   })\n \n (define_insn \"*subqi3\"\n@@ -979,22 +754,11 @@\n   [(set_attr \"length_table\" \"add\")\n    (set_attr \"cc\" \"set_zn\")])\n \n-(define_insn \"*subhi3_h8300\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(minus:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-\t\t  (match_operand:HI 2 \"h8300_src_operand\" \"r,n\")))]\n-  \"TARGET_H8300\"\n-  \"@\n-   sub.w\t%T2,%T0\n-   add.b\t%E2,%s0\\;addx\t%F2,%t0\"\n-  [(set_attr \"length\" \"2,4\")\n-   (set_attr \"cc\" \"set_zn,clobber\")])\n-\n (define_insn \"*sub<mode>3_h8300hs\"\n   [(set (match_operand:HSI 0 \"h8300_dst_operand\" \"=rQ,rQ\")\n \t(minus:HSI (match_operand:HSI 1 \"h8300_dst_operand\" \"0,0\")\n \t\t   (match_operand:HSI 2 \"h8300_src_operand\" \"rQ,i\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n+  \"h8300_operands_match_p (operands)\"\n   { \n     if (<MODE>mode == HImode)\n       return \"sub.w\t%T2,%T0\";\n@@ -1005,14 +769,6 @@\n   [(set_attr \"length_table\" \"add\")\n    (set_attr \"cc\" \"set_zn\")])\n \n-(define_insn \"*subsi3_h8300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n-  \"TARGET_H8300\"\n-  \"sub.w\t%f2,%f0\\;subx\t%y2,%y0\\;subx\t%z2,%z0\"\n-  [(set_attr \"length\" \"6\")])\n-\n \f\n ;; ----------------------------------------------------------------------\n ;; MULTIPLY INSTRUCTIONS\n@@ -1025,7 +781,7 @@\n \t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"\"))\n \t\t ;; intentionally-mismatched modes\n \t\t (match_operand:QI 2 \"reg_or_nibble_operand\" \"\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   {\n     if (GET_MODE (operands[2]) != VOIDmode)\n       operands[2] = gen_rtx_SIGN_EXTEND (HImode, operands[2]);\n@@ -1044,7 +800,7 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n \t\t (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mulxs.b\t%X2,%T0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"set_zn\")])\n@@ -1054,7 +810,7 @@\n \t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n \t\t ;; intentionally-mismatched modes\n \t\t (match_operand:HI 2 \"reg_or_nibble_operand\" \"\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   {\n     if (GET_MODE (operands[2]) != VOIDmode)\n       operands[2] = gen_rtx_SIGN_EXTEND (SImode, operands[2]);\n@@ -1073,7 +829,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n \t\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mulxs.w\t%T2,%S0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"set_zn\")])\n@@ -1083,7 +839,7 @@\n \t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"\"))\n \t\t ;; intentionally-mismatched modes\n \t\t (match_operand:QI 2 \"reg_or_nibble_operand\" \"\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   {\n     if (GET_MODE (operands[2]) != VOIDmode)\n       operands[2] = gen_rtx_ZERO_EXTEND (HImode, operands[2]);\n@@ -1112,7 +868,7 @@\n \t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\"))\n \t\t ;; intentionally-mismatched modes\n \t\t (match_operand:HI 2 \"reg_or_nibble_operand\" \"\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   {\n     if (GET_MODE (operands[2]) != VOIDmode)\n       operands[2] = gen_rtx_ZERO_EXTEND (SImode, operands[2]);\n@@ -1131,7 +887,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n \t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mulxu.w\t%T2,%S0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"none_0hit\")])\n@@ -1259,7 +1015,7 @@\n \t  (mod:HI\n \t    (match_dup 1)\n \t    (sign_extend:HI (match_dup 2)))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n {\n   if (find_reg_note (insn, REG_UNUSED, operands[3]))\n     return \"divxs.b\\\\t%X2,%T0\";\n@@ -1279,7 +1035,7 @@\n \t  (umod:SI\n \t    (match_dup 1)\n \t    (zero_extend:SI (match_dup 2)))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n {\n   if (find_reg_note (insn, REG_UNUSED, operands[3]))\n     return \"divxu.w\\\\t%T2,%S0\";\n@@ -1299,7 +1055,7 @@\n \t  (mod:SI\n \t    (match_dup 1)\n \t    (sign_extend:SI (match_dup 2)))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n {\n   if (find_reg_note (insn, REG_UNUSED, operands[3]))\n     return \"divxs.w\\\\t%T2,%S0\";\n@@ -1460,7 +1216,7 @@\n    || single_one_operand (operands[2], QImode)\"\n   {\n     if (which_alternative == 0)\n-      return <CODE> == IOR ? \"bset\\\\t%V2,%R0\" : \"bnot\\\\t%V2,%R0\"; \n+      return <CODE> == IOR ? \"bset\\\\t%V2,%R0\" : \"bnot\\\\t%V2,%R0\";\n     else if (which_alternative == 1)\n       return <CODE> == IOR ? \"or\\\\t%X2,%X0\" : \"xor\\\\t%X2,%X0\";\n     gcc_unreachable ();\n@@ -1500,24 +1256,7 @@\n   [(set (match_operand:QHSIF 0 \"register_operand\" \"\")\n \t(neg:QHSIF (match_operand:QHSIF 1 \"register_operand\" \"\")))]\n   \"\"\n-  {\n-    enum machine_mode mode = <MODE>mode;\n-    if (TARGET_H8300)\n-      {\n-\tif (mode == QImode || mode == SFmode)\n-\t  ;\n-\telse if (mode == HImode)\n-\t  {\n-\t    emit_insn (gen_neghi2_h8300 (operands[0], operands[1]));\n-\t    DONE;\n-\t  }\n-\telse if (mode == SImode)\n-\t  {\n-\t    emit_insn (gen_negsi2_h8300 (operands[0], operands[1]));\n-\t    DONE;\n-\t  }\n-      }\n-  })\n+  { })\n \n (define_insn \"*negqi2\"\n   [(set (match_operand:QI 0 \"h8300_dst_operand\" \"=rQ\")\n@@ -1541,32 +1280,26 @@\n (define_insn \"*neghi2_h8300hs\"\n   [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rQ\")\n \t(neg:HI (match_operand:HI 1 \"h8300_dst_operand\" \"0\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n+  \"h8300_operands_match_p (operands)\"\n   \"neg.w\t%T0\"\n   [(set_attr \"length_table\" \"unary\")\n    (set_attr \"cc\" \"set_zn\")])\n \n (define_insn \"*negsi2_h8300hs\"\n   [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ\")\n \t(neg:SI (match_operand:SI 1 \"h8300_dst_operand\" \"0\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n+  \"h8300_operands_match_p (operands)\"\n   \"neg.l\t%S0\"\n   [(set_attr \"length_table\" \"unary\")\n    (set_attr \"cc\" \"set_zn\")])\n \n-(define_insn \"*negsf2_h8300\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300\"\n-  \"xor.b\\\\t#128,%z0\"\n-  [(set_attr \"length\" \"2\")])\n-\n (define_insn \"*negsf2_h8300hs\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n+       (neg:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n   \"TARGET_H8300H || TARGET_H8300S\"\n   \"xor.w\\\\t#32768,%e0\"\n   [(set_attr \"length\" \"4\")])\n+\n \f\n ;; ----------------------------------------------------------------------\n ;; ABSOLUTE VALUE INSTRUCTIONS\n@@ -1578,17 +1311,10 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*abssf2_h8300\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300\"\n-  \"and.b\\\\t#127,%z0\"\n-  [(set_attr \"length\" \"2\")])\n-\n (define_insn \"*abssf2_h8300hs\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n \t(abs:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"and.w\\\\t#32767,%e0\"\n   [(set_attr \"length\" \"4\")])\n \f\n@@ -1610,32 +1336,18 @@\n   [(set_attr \"length_table\" \"unary\")\n    (set_attr \"cc\" \"set_znv\")])\n \n-(define_insn \"*one_cmplhi2_h8300\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(not:HI (match_operand:HI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300\"\n-  \"not\t%s0\\;not\t%t0\"\n-  [(set_attr \"length\" \"4\")])\n-\n (define_insn \"*one_cmplhi2_h8300hs\"\n   [(set (match_operand:HI 0 \"h8300_dst_operand\" \"=rQ\")\n \t(not:HI (match_operand:HI 1 \"h8300_dst_operand\" \"0\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n+  \"h8300_operands_match_p (operands)\"\n   \"not.w\t%T0\"\n   [(set_attr \"cc\" \"set_znv\")\n    (set_attr \"length_table\" \"unary\")])\n \n-(define_insn \"*one_cmplsi2_h8300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300\"\n-  \"not\t%w0\\;not\t%x0\\;not\t%y0\\;not\t%z0\"\n-  [(set_attr \"length\" \"8\")])\n-\n (define_insn \"*one_cmplsi2_h8300hs\"\n   [(set (match_operand:SI 0 \"h8300_dst_operand\" \"=rQ\")\n \t(not:SI (match_operand:SI 1 \"h8300_dst_operand\" \"0\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)\"\n+  \"h8300_operands_match_p (operands)\"\n   \"not.l\t%S0\"\n   [(set_attr \"cc\" \"set_znv\")\n    (set_attr \"length_table\" \"unary\")])\n@@ -1664,11 +1376,6 @@\n    (use (match_operand 3 \"\"))]\n   \"\"\n   {\n-    /* Force operand1 into a register if we're compiling\n-       for the H8/300.  */\n-    if ((GET_CODE (operands[2]) != REG && operands[2] != const0_rtx)\n-\t&& TARGET_H8300)\n-      operands[2] = force_reg (HImode, operands[2]);\n     h8300_expand_branch (operands);\n     DONE;\n   })\n@@ -1678,7 +1385,7 @@\n          [(match_operand:SI 1 \"h8300_dst_operand\" \"\")\n           (match_operand:SI 2 \"h8300_src_operand\" \"\")]))\n    (use (match_operand 3 \"\"))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   {\n     h8300_expand_branch (operands);\n     DONE;\n@@ -1843,26 +1550,18 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*tablejump_h8300\"\n-  [(set (pc) (match_operand:HI 0 \"register_operand\" \"r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"TARGET_H8300\"\n-  \"jmp\t@%0\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"2\")])\n-\n (define_insn \"*tablejump_h8300hs_advanced\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE\"\n+  \"!TARGET_NORMAL_MODE\"\n   \"jmp\t@%0\"\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"2\")])\n \n (define_insn \"*tablejump_h8300hs_normal\"\n   [(set (pc) (match_operand:HI 0 \"register_operand\" \"r\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && TARGET_NORMAL_MODE\"\n+  \"TARGET_NORMAL_MODE\"\n   \"jmp @%S0\"\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"2\")])\n@@ -1874,23 +1573,16 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*indirect_jump_h8300\"\n-  [(set (pc) (match_operand:HI 0 \"jump_address_operand\" \"Vr\"))]\n-  \"TARGET_H8300\"\n-  \"jmp\t@%0\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"2\")])\n-\n (define_insn \"*indirect_jump_h8300hs_advanced\"\n   [(set (pc) (match_operand:SI 0 \"jump_address_operand\" \"Vr\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE\"\n+  \"!TARGET_NORMAL_MODE\"\n   \"jmp @%0\"\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"2\")])\n \n (define_insn \"*indirect_jump_h8300hs_normal\"\n   [(set (pc) (match_operand:HI 0 \"jump_address_operand\" \"Vr\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && TARGET_NORMAL_MODE\"\n+  \"TARGET_NORMAL_MODE\"\n   \"jmp @%S0\"\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"2\")])\n@@ -1980,12 +1672,6 @@\n ;; PROLOGUE/EPILOGUE-RELATED INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_expand \"push_h8300\"\n-  [(set (mem:HI (pre_dec:HI (reg:HI SP_REG)))\n-        (match_operand:HI 0 \"register_operand\" \"\"))]\n-  \"TARGET_H8300\"\n-  \"\")\n-\n (define_expand \"push_h8300hs_advanced\"\n   [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n         (match_operand:SI 0 \"register_operand\" \"\"))]\n@@ -1998,12 +1684,6 @@\n   \"TARGET_H8300H && TARGET_H8300S && TARGET_NORMAL_MODE\"\n   \"\")\n \n-(define_expand \"pop_h8300\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(mem:HI (post_inc:HI (reg:HI SP_REG))))]\n-  \"TARGET_H8300\"\n-  \"\")\n-\n (define_expand \"pop_h8300hs_advanced\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(mem:SI (post_inc:SI (reg:SI SP_REG))))]\n@@ -2100,9 +1780,7 @@\n   [(unspec_volatile [(const_int 0)] UNSPEC_MONITOR)]\n   \"\"\n {\n-  if (TARGET_H8300)\n-    return \"subs\\\\t#2,r7\\;mov.w\\\\tr0,@-r7\\;stc\\\\tccr,r0l\\;mov.b\\tr0l,@(2,r7)\\;mov.w\\\\t@r7+,r0\\;orc\\t#128,ccr\";\n-  else if (TARGET_H8300H && TARGET_NORMAL_MODE)\n+  if (TARGET_H8300H && TARGET_NORMAL_MODE)\n     return \"subs\\\\t#2,er7\\;mov.l\\\\ter0,@-er7\\;stc\\\\tccr,r0l\\;mov.b\\\\tr0l,@(4,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\\\t#128,ccr\";\n   else if (TARGET_H8300H)\n     return \"mov.l\\\\ter0,@-er7\\;stc\\\\tccr,r0l\\;mov.b\\\\tr0l,@(4,er7)\\;mov.l\\\\t@er7+,er0\\;orc\\\\t#128,ccr\";\n@@ -2131,19 +1809,10 @@\n       operands[1] = force_reg (QImode, operands[1]);\n   })\n \n-(define_insn \"*zero_extendqihi2_h8300\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:HI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n-  \"TARGET_H8300\"\n-  \"@\n-  mov.b\t#0,%t0\n-  #\"\n-  [(set_attr \"length\" \"2,10\")])\n-\n (define_insn \"*zero_extendqihi2_h8300hs\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:HI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"@\n   extu.w\t%T0\n   #\"\n@@ -2167,26 +1836,16 @@\n     operands[2] = gen_rtx_REG (QImode, REGNO (operands[0]));\n   })\n \n-\n-(define_insn \"*zero_extendqisi2_h8300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n-  \"TARGET_H8300\"\n-  \"@\n-  mov.b\t#0,%x0\\;sub.w\t%e0,%e0\n-  mov.b\t%R1,%w0\\;mov.b\t#0,%x0\\;sub.w\t%e0,%e0\"\n-  [(set_attr \"length\" \"4,8\")])\n-\n (define_insn \"*zero_extendqisi2_h8300hs\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\"\n+  \"!TARGET_H8300SX\"\n   \"#\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\n+  \"!TARGET_H8300SX\n     && reg_overlap_mentioned_p (operands[0], operands[1])\n     && reload_completed\"\n   [(set (match_dup 2)\n@@ -2203,7 +1862,7 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"general_operand_src\" \"\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\n+  \"!TARGET_H8300SX\n     && !reg_overlap_mentioned_p (operands[0], operands[1])\n     && reload_completed\"\n   [(set (match_dup 0)\n@@ -2228,21 +1887,10 @@\n   \"\"\n   \"\")\n \n-;; %e prints the high part of a CONST_INT, not the low part.  Arggh.\n-(define_insn \"*zero_extendhisi2_h8300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"general_operand_src\" \"0,i,g>\")))]\n-  \"TARGET_H8300\"\n-  \"@\n-  sub.w\t%e0,%e0\n-  mov.w\t%f1,%f0\\;sub.w\t%e0,%e0\n-  mov.w\t%e1,%f0\\;sub.w\t%e0,%e0\"\n-  [(set_attr \"length\" \"2,4,6\")])\n-\n (define_insn \"*zero_extendhisi2_h8300hs\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"extu.l\t%S0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n@@ -2253,40 +1901,22 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*extendqihi2_h8300\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n-  \"TARGET_H8300\"\n-  \"@\n-  bld\t#7,%s0\\;subx\t%t0,%t0\n-  mov.b\t%R1,%s0\\;bld\t#7,%s0\\;subx\t%t0,%t0\"\n-  [(set_attr \"length\" \"4,8\")])\n-\n (define_insn \"*extendqihi2_h8300hs\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"exts.w\t%T0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n \n-(define_insn \"*extendqisi2_h8300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"general_operand_src\" \"0,g>\")))]\n-  \"TARGET_H8300\"\n-  \"@\n-  bld\t#7,%w0\\;subx\t%x0,%x0\\;subx\t%y0,%y0\\;subx\t%z0,%z0\n-  mov.b\t%R1,%w0\\;bld\t#7,%w0\\;subx\t%x0,%x0\\;subx\t%y0,%y0\\;subx\t%z0,%z0\"\n-  [(set_attr \"length\" \"8,12\")])\n-\n ;; The following pattern is needed because without the pattern, the\n ;; combiner would split (sign_extend:SI (reg:QI)) into two 24-bit\n ;; shifts, one ashift and one ashiftrt.\n \n (define_insn_and_split \"*extendqisi2_h8300hs\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"0\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX\"\n+  \"!TARGET_H8300SX\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2)\n@@ -2311,19 +1941,10 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*extendhisi2_h8300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"general_operand_src\" \"0,g>\")))]\n-  \"TARGET_H8300\"\n-  \"@\n-  bld\t#7,%x0\\;subx\t%y0,%y0\\;subx\t%z0,%z0\n-  mov.w\t%T1,%f0\\;bld\t#7,%x0\\;subx\t%y0,%y0\\;subx\t%z0,%z0\"\n-  [(set_attr \"length\" \"6,10\")])\n-\n (define_insn \"*extendhisi2_h8300hs\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"exts.l\t%S0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n@@ -2654,7 +2275,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(rotate:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   {\n     if (expand_a_rotate (operands))\n     DONE;\n@@ -2664,7 +2285,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(rotate:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:QI 2 \"immediate_operand\" \"\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n {\n   return output_a_rotate (ROTATE, operands);\n }\n@@ -2684,19 +2305,6 @@\n ;; Combine obviously need some work to better identify this situation and\n ;; canonicalize the form better.\n \n-;;\n-;; Normal loads with a 16bit destination.\n-;;\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n-\t(zero_extract:HI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand:HI 2 \"immediate_operand\" \"n\")))]\n-  \"TARGET_H8300\"\n-  \"sub.w\t%0,%0\\;bld\t%Z2,%Y1\\;bst\t#0,%X0\"\n-  [(set_attr \"length\" \"6\")])\n-\n ;;\n ;; Inverted loads with a 16bit destination.\n ;;\n@@ -2707,7 +2315,7 @@\n \t\t\t\t (match_operand:HI 3 \"const_int_operand\" \"n\"))\n \t\t\t (const_int 1)\n \t\t\t (match_operand:HI 2 \"const_int_operand\" \"n\")))]\n-  \"(TARGET_H8300 || TARGET_H8300SX)\n+  \"(TARGET_H8300SX)\n     && (1 << INTVAL (operands[2])) == INTVAL (operands[3])\"\n   \"sub.w\t%0,%0\\;bild\t%Z2,%Y1\\;bst\t#0,%X0\"\n   [(set_attr \"length\" \"8\")])\n@@ -2716,23 +2324,12 @@\n ;; Normal loads with a 32bit destination.\n ;;\n \n-(define_insn \"*extzv_1_r_h8300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-\t(zero_extract:SI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand 2 \"const_int_operand\" \"n\")))]\n-  \"TARGET_H8300 && INTVAL (operands[2]) < 16\"\n-{\n-  return output_simode_bld (0, operands);\n-}\n-  [(set_attr \"length\" \"8\")])\n-\n (define_insn \"*extzv_1_r_h8300hs\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"?0,r\")\n \t\t\t (const_int 1)\n \t\t\t (match_operand 2 \"const_int_operand\" \"n,n\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && INTVAL (operands[2]) < 16\"\n+  \"INTVAL (operands[2]) < 16\"\n {\n   return output_simode_bld (0, operands);\n }\n@@ -2743,26 +2340,13 @@\n ;; Inverted loads with a 32bit destination.\n ;;\n \n-(define_insn \"*extzv_1_r_inv_h8300\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-\t(zero_extract:SI (xor:HI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t\t\t (match_operand:HI 3 \"const_int_operand\" \"n\"))\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand 2 \"const_int_operand\" \"n\")))]\n-  \"TARGET_H8300 && INTVAL (operands[2]) < 16\n-   && (1 << INTVAL (operands[2])) == INTVAL (operands[3])\"\n-{\n-  return output_simode_bld (1, operands);\n-}\n-  [(set_attr \"length\" \"8\")])\n-\n (define_insn \"*extzv_1_r_inv_h8300hs\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(zero_extract:SI (xor:SI (match_operand:SI 1 \"register_operand\" \"?0,r\")\n \t\t\t\t (match_operand 3 \"const_int_operand\" \"n,n\"))\n \t\t\t (const_int 1)\n \t\t\t (match_operand 2 \"const_int_operand\" \"n,n\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && INTVAL (operands[2]) < 16\n+  \"INTVAL (operands[2]) < 16\n     && (1 << INTVAL (operands[2])) == INTVAL (operands[3])\"\n {\n   return output_simode_bld (1, operands);\n@@ -2775,61 +2359,46 @@\n \t\t\t (match_operand:HI 1 \"general_operand\" \"\")\n \t\t\t (match_operand:HI 2 \"general_operand\" \"\"))\n \t(match_operand:HI 3 \"general_operand\" \"\"))]\n-  \"TARGET_H8300 || TARGET_H8300SX\"\n+  \"TARGET_H8300SX\"\n   {\n-    if (TARGET_H8300SX)\n+    if (GET_CODE (operands[1]) == CONST_INT\n+\t&& GET_CODE (operands[2]) == CONST_INT\n+\t&& INTVAL (operands[1]) <= 8\n+\t&& INTVAL (operands[2]) >= 0\n+\t&& INTVAL (operands[1]) + INTVAL (operands[2]) <= 8\n+\t&& memory_operand (operands[0], GET_MODE (operands[0])))\n       {\n-\tif (GET_CODE (operands[1]) == CONST_INT\n-\t    && GET_CODE (operands[2]) == CONST_INT\n-\t    && INTVAL (operands[1]) <= 8\n-\t    && INTVAL (operands[2]) >= 0\n-\t    && INTVAL (operands[1]) + INTVAL (operands[2]) <= 8\n-\t    && memory_operand (operands[0], GET_MODE (operands[0])))\n+\t/* If the source operand is zero, it's better to use AND rather\n+\t   than BFST.  Likewise OR if the operand is all ones.  */\n+\tif (GET_CODE (operands[3]) == CONST_INT)\n+\t  {\n+\t    HOST_WIDE_INT mask = (1 << INTVAL (operands[1])) - 1;\n+\t    if ((INTVAL (operands[3]) & mask) == 0)\n+\t      FAIL;\n+\t    if ((INTVAL (operands[3]) & mask) == mask)\n+\t      FAIL;\n+\t  }\n+\tif (! bit_memory_operand (operands[0], GET_MODE (operands[0])))\n+\t  {\n+\t    if (!can_create_pseudo_p ())\n+\t      FAIL;\n+\t    operands[0] =  replace_equiv_address (operands[0], force_reg (Pmode,\n+\t\t\t\t\t\t  XEXP (operands[0], 0)));\n+\t  }\n+\toperands[3] = gen_lowpart (QImode, operands[3]);\n+\tif (! operands[3])\n+\t  FAIL;\n+\tif (! register_operand (operands[3], QImode))\n \t  {\n-\t    /* If the source operand is zero, it's better to use AND rather\n-\t       than BFST.  Likewise OR if the operand is all ones.  */\n-\t    if (GET_CODE (operands[3]) == CONST_INT)\n-\t      {\n-\t\tHOST_WIDE_INT mask = (1 << INTVAL (operands[1])) - 1;\n-\t\tif ((INTVAL (operands[3]) & mask) == 0)\n-\t\t  FAIL;\n-\t\tif ((INTVAL (operands[3]) & mask) == mask)\n-\t\t  FAIL;\n-\t      }\n-\t    if (! bit_memory_operand (operands[0], GET_MODE (operands[0])))\n-\t      {\n-\t\tif (!can_create_pseudo_p ())\n-\t\t  FAIL;\n-\t\toperands[0] =  replace_equiv_address (operands[0], force_reg (Pmode,\n-\t\t\t\t\t\t      XEXP (operands[0], 0)));\n-\t      }\n-\t    operands[3] = gen_lowpart (QImode, operands[3]);\n-\t    if (! operands[3])\n+\t    if (!can_create_pseudo_p ())\n \t      FAIL;\n-\t    if (! register_operand (operands[3], QImode))\n-\t      {\n-\t\tif (!can_create_pseudo_p ())\n-\t\t  FAIL;\n-\t\toperands[3] = force_reg (QImode, operands[3]);\n-\t      }\n-\t    emit_insn (gen_bfst (adjust_address (operands[0], QImode, 0),\n-\t\t\t\t\t\t operands[3], operands[1], operands[2]));\n-\t    DONE;\n+\t    operands[3] = force_reg (QImode, operands[3]);\n \t  }\n-\tFAIL;\n+\temit_insn (gen_bfst (adjust_address (operands[0], QImode, 0),\n+\t\t\t\t\t     operands[3], operands[1], operands[2]));\n+\tDONE;\n       }\n-\n-    /* We only have single bit bit-field instructions.  */\n-    if (INTVAL (operands[1]) != 1)\n-      FAIL;\n-\n-    /* For now, we don't allow memory operands.  */\n-    if (GET_CODE (operands[0]) == MEM\n-\t|| GET_CODE (operands[3]) == MEM)\n-      FAIL;\n-\n-    if (GET_CODE (operands[3]) != REG)\n-      operands[3] = force_reg (HImode, operands[3]);\n+    FAIL;\n   })\n \n (define_insn \"\"\n@@ -2846,56 +2415,45 @@\n \t(zero_extract:HI (match_operand:HI 1 \"bit_operand\" \"\")\n \t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n \t\t\t (match_operand:HI 3 \"general_operand\" \"\")))]\n-  \"TARGET_H8300 || TARGET_H8300SX\"\n+  \"TARGET_H8300SX\"\n   {\n-    if (TARGET_H8300SX)\n+    if (GET_CODE (operands[2]) == CONST_INT\n+\t&& GET_CODE (operands[3]) == CONST_INT\n+\t&& INTVAL (operands[2]) <= 8\n+\t&& INTVAL (operands[3]) >= 0\n+\t&& INTVAL (operands[2]) + INTVAL (operands[3]) <= 8\n+\t&& memory_operand (operands[1], QImode))\n       {\n-\tif (GET_CODE (operands[2]) == CONST_INT\n-\t    && GET_CODE (operands[3]) == CONST_INT\n-\t    && INTVAL (operands[2]) <= 8\n-\t    && INTVAL (operands[3]) >= 0\n-\t    && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8\n-\t    && memory_operand (operands[1], QImode))\n+\trtx temp;\n+\n+\t/* Optimize the case where we're extracting into a paradoxical\n+\t   subreg.  It's only necessary to extend to the inner reg.  */\n+\tif (GET_CODE (operands[0]) == SUBREG\n+\t    && subreg_lowpart_p (operands[0])\n+\t    && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (operands[0])))\n+\t\t< GET_MODE_SIZE (GET_MODE (operands[0])))\n+\t    && (GET_MODE_CLASS (GET_MODE (SUBREG_REG (operands[0])))\n+\t\t== MODE_INT))\n+\t   operands[0] = SUBREG_REG (operands[0]);\n+\n+\tif (!can_create_pseudo_p ())\n+\t  temp = gen_lowpart (QImode, operands[0]);\n+\telse\n+\t  temp = gen_reg_rtx (QImode);\n+\tif (! temp)\n+\t  FAIL;\n+        if (! bit_memory_operand (operands[1], QImode))\n \t  {\n-\t    rtx temp;\n-\n-\t    /* Optimize the case where we're extracting into a paradoxical\n-\t       subreg.  It's only necessary to extend to the inner reg.  */\n-\t    if (GET_CODE (operands[0]) == SUBREG\n-\t\t&& subreg_lowpart_p (operands[0])\n-\t\t&& (GET_MODE_SIZE (GET_MODE (SUBREG_REG (operands[0])))\n-\t\t    < GET_MODE_SIZE (GET_MODE (operands[0])))\n-\t\t&& (GET_MODE_CLASS (GET_MODE (SUBREG_REG (operands[0])))\n-\t\t    == MODE_INT))\n-\t      operands[0] = SUBREG_REG (operands[0]);\n-\n \t    if (!can_create_pseudo_p ())\n-\t      temp = gen_lowpart (QImode, operands[0]);\n-\t    else\n-\t      temp = gen_reg_rtx (QImode);\n-\t    if (! temp)\n \t      FAIL;\n-            if (! bit_memory_operand (operands[1], QImode))\n-\t      {\n-\t\tif (!can_create_pseudo_p ())\n-\t\t  FAIL;\n-\t\toperands[1] = replace_equiv_address (operands[1],\n-\t\t\t\t\t\t     force_reg (Pmode, XEXP (operands[1], 0)));\n-\t      }\n-\t    emit_insn (gen_bfld (temp, operands[1], operands[2], operands[3]));\n-\t    convert_move (operands[0], temp, 1);\n-\t    DONE;\n-          }\n-\tFAIL;\n+\t    operands[1] = replace_equiv_address (operands[1],\n+\t\t\t\t\t\t force_reg (Pmode, XEXP (operands[1], 0)));\n+\t  }\n+\temit_insn (gen_bfld (temp, operands[1], operands[2], operands[3]));\n+\tconvert_move (operands[0], temp, 1);\n+\tDONE;\n       }\n-\n-    /* We only have single bit bit-field instructions.  */\n-    if (INTVAL (operands[2]) != 1)\n-      FAIL;\n-\n-    /* For now, we don't allow memory operands.  */\n-    if (GET_CODE (operands[1]) == MEM)\n-      FAIL;\n+    FAIL;\n   })\n \n ;; BAND, BOR, and BXOR patterns\n@@ -3186,7 +2744,7 @@\n \t\t\t (const_int 1)\n \t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\"))\n \t(match_operand:SI 2 \"register_operand\" \"r\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && INTVAL (operands[1]) < 16\"\n+  \"INTVAL (operands[1]) < 16\"\n   \"bld\\\\t#0,%w2\\;bst\\\\t%Z1,%Y0\"\n   [(set_attr \"length\" \"4\")])\n \n@@ -3196,9 +2754,7 @@\n \t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\"))\n \t(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"r\")\n \t\t     (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && INTVAL (operands[1]) < 16\n-    && INTVAL (operands[3]) < 16\"\n+  \"INTVAL (operands[1]) < 16 && INTVAL (operands[3]) < 16\"\n   \"bld\\\\t%Z3,%Y2\\;bst\\\\t%Z1,%Y0\"\n   [(set_attr \"length\" \"4\")])\n \n@@ -3208,7 +2764,7 @@\n \t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\"))\n \t(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"r\")\n \t\t     (const_int 16)))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && INTVAL (operands[1]) < 16\"\n+  \"INTVAL (operands[1]) < 16\"\n   \"rotr.w\\\\t%e2\\;rotl.w\\\\t%e2\\;bst\\\\t%Z1,%Y0\"\n   [(set_attr \"length\" \"6\")])\n \n@@ -3217,7 +2773,7 @@\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n \t(match_operand:SI 1 \"register_operand\" \"r\"))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mov.b\\\\t%w1,%x0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3227,7 +2783,7 @@\n \t\t\t (const_int 8))\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t     (const_int 8)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mov.b\\\\t%x1,%x0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3238,7 +2794,7 @@\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"?0,r\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"@\n    mov.b\\\\t%x1,%w0\\;extu.w\\\\t%f0\\;extu.l\\\\t%S0\n    sub.l\\\\t%S0,%S0\\;mov.b\\\\t%x1,%w0\"\n@@ -3250,7 +2806,7 @@\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 16)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mov.w\\\\t%e1,%f0\\;extu.w\\\\t%f0\\;extu.l\\\\t%S0\"\n   [(set_attr \"cc\" \"set_znv\")\n    (set_attr \"length\" \"6\")])\n@@ -3273,7 +2829,7 @@\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 23)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0)\n@@ -3295,7 +2851,7 @@\n \t(and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t\t   (const_int 15))\n \t\t(const_int 2147450880)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0)\n@@ -3316,10 +2872,9 @@\n \t\t\t   (match_operand:QI 2 \"const_int_operand\" \"S,n\"))\n \t\t(match_operand:SI 3 \"const_int_operand\" \"n,n\")))\n    (clobber (match_scratch:QI 4 \"=X,&r\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && INTVAL (operands[2]) <= 15\n-    && UINTVAL (operands[3]) == ((HOST_WIDE_INT_M1U << INTVAL (operands[2]))\n-\t\t\t\t & 0xffff)\"\n+  \"INTVAL (operands[2]) <= 15\n+   && UINTVAL (operands[3]) == ((HOST_WIDE_INT_M1U << INTVAL (operands[2]))\n+\t\t\t\t& 0xffff)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 5)\n@@ -3339,9 +2894,8 @@\n \t(and:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))\n \t\t(match_operand:SI 3 \"single_one_operand\" \"n\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && exact_log2 (INTVAL (operands[3])) < 16\n-    && INTVAL (operands[2]) + exact_log2 (INTVAL (operands[3])) == 31\"\n+  \"exact_log2 (INTVAL (operands[3])) < 16\n+   && INTVAL (operands[2]) + exact_log2 (INTVAL (operands[3])) == 31\"\n {\n   operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));\n   return \"shll.l\\\\t%S0\\;xor.l\\\\t%S0,%S0\\;bst\\\\t%Z3,%Y0\";\n@@ -3353,7 +2907,7 @@\n \t(and:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t\t     (const_int 9))\n \t\t(const_int 4194304)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0)\n@@ -3373,7 +2927,7 @@\n \t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t  (const_int 65536))\n \t\t (match_operand:SI 2 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"add.w\\\\t%f1,%e0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3382,7 +2936,7 @@\n \t(plus:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t      (const_int 16))\n \t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"0\"))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"add.w\\\\t%e1,%f0\\;xor.w\\\\t%e0,%e0\\;rotxl.w\\\\t%e0\"\n   [(set_attr \"length\" \"6\")])\n \n@@ -3391,7 +2945,7 @@\n \t(plus:SI (and:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (const_int 1))\n \t\t (match_operand:SI 2 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (cc0) (compare (zero_extract:SI (match_dup 1)\n@@ -3416,7 +2970,7 @@\n \t(plus:SI (and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t (const_int 1))\n \t\t (match_operand:SI 2 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (cc0) (compare (zero_extract:SI (match_dup 1)\n@@ -3463,7 +3017,7 @@\n \t(match_operator:SI 1 \"iorxor_operator\"\n \t [(zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))\n \t  (match_operand:SI 3 \"register_operand\" \"0\")]))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"%c1.w\\\\t%T2,%f0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3473,7 +3027,7 @@\n \t [(ashift:SI (match_operand:SI 2 \"register_operand\" \"r\")\n \t\t     (const_int 16))\n \t  (match_operand:SI 3 \"register_operand\" \"0\")]))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"%c1.w\\\\t%f2,%e0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3483,7 +3037,7 @@\n \t [(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"r\")\n \t\t       (const_int 16))\n \t  (match_operand:SI 3 \"register_operand\" \"0\")]))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"%c1.w\\\\t%e2,%f0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3530,9 +3084,8 @@\n \t(ior:HI (zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"\"))\n \t\t(ashift:HI (subreg:HI (match_operand:QI 2 \"memory_operand\" \"\") 0)\n \t\t\t   (const_int 8))))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && reload_completed\n-    && byte_accesses_mergeable_p (XEXP (operands[2], 0), XEXP (operands[1], 0))\"\n+  \"reload_completed\n+   && byte_accesses_mergeable_p (XEXP (operands[2], 0), XEXP (operands[1], 0))\"\n   [(set (match_dup 0)\n \t(match_dup 3))]\n   {\n@@ -3546,7 +3099,7 @@\n \t(ior:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\"))\n \t\t(ashift:SI (match_operand:SI 2 \"register_operand\" \"r\")\n \t\t\t   (const_int 16))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mov.w\\\\t%f2,%e0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3556,7 +3109,7 @@\n \t\t(and:SI (ashift:SI (subreg:SI (match_operand:QI 2 \"memory_operand\" \"m\") 0)\n \t\t\t\t   (const_int 8))\n \t\t\t(const_int 65280))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 3)\n@@ -3575,7 +3128,7 @@\n \t\t\t(const_int -65536))\n \t\t(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"r\")\n \t\t\t     (const_int 16))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mov.w\\\\t%e2,%f0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3584,7 +3137,7 @@\n \t(ior:SI (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"0\"))\n \t\t(ashift:SI (sign_extend:SI (match_operand:QI 2 \"register_operand\" \"r\"))\n \t\t\t   (const_int 8))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 3)\n@@ -3603,7 +3156,7 @@\n \t(ior:SI (and:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n \t\t\t(const_int -256))\n \t\t(zero_extend:SI (match_operand:QI 2 \"general_operand_src\" \"r,g>\"))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mov.b\\\\t%X2,%w0\"\n   [(set_attr \"length\" \"2,8\")])\n \n@@ -3612,7 +3165,7 @@\n \t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t   (const_int 31))\n \t\t(match_operand:SI 2 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"rotxl.l\\\\t%S0\\;bor\\\\t#0,%w1\\;rotxr.l\\\\t%S0\"\n   [(set_attr \"length\" \"6\")\n    (set_attr \"cc\" \"set_znv\")])\n@@ -3623,8 +3176,7 @@\n \t\t\t\t   (match_operand:SI 2 \"const_int_operand\" \"n\"))\n \t\t\t(match_operand:SI 3 \"single_one_operand\" \"n\"))\n \t\t(match_operand:SI 4 \"register_operand\" \"0\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && (INTVAL (operands[3]) & ~0xffff) == 0\"\n+  \"(INTVAL (operands[3]) & ~0xffff) == 0\"\n {\n   rtx srcpos = GEN_INT (exact_log2 (INTVAL (operands[3]))\n \t\t\t- INTVAL (operands[2]));\n@@ -3641,8 +3193,7 @@\n \t\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))\n \t\t\t(match_operand:SI 3 \"single_one_operand\" \"n\"))\n \t\t(match_operand:SI 4 \"register_operand\" \"0\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && ((INTVAL (operands[3]) << INTVAL (operands[2])) & ~0xffff) == 0\"\n+  \"((INTVAL (operands[3]) << INTVAL (operands[2])) & ~0xffff) == 0\"\n {\n   rtx srcpos = GEN_INT (exact_log2 (INTVAL (operands[3]))\n \t\t\t+ INTVAL (operands[2]));\n@@ -3659,7 +3210,7 @@\n \t\t\t\t (const_int 1)\n \t\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n \t\t(match_operand:SI 3 \"register_operand\" \"0\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && INTVAL (operands[2]) < 16\"\n+  \"INTVAL (operands[2]) < 16\"\n   \"bld\\\\t%Z2,%Y1\\;bor\\\\t#0,%w0\\;bst\\\\t#0,%w0\"\n   [(set_attr \"length\" \"6\")])\n \n@@ -3669,7 +3220,7 @@\n \t\t\t\t     (const_int 30))\n \t\t\t(const_int 2))\n \t\t(match_operand:SI 2 \"register_operand\" \"0\")))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"rotl.l\\\\t%S1\\;rotr.l\\\\t%S1\\;bor\\\\t#1,%w0\\;bst\\\\t#1,%w0\"\n   [(set_attr \"length\" \"8\")])\n \n@@ -3680,7 +3231,7 @@\n \t\t\t(const_int 4194304))\n \t\t(match_operand:SI 2 \"register_operand\" \"0\")))\n    (clobber (match_scratch:HI 3 \"=&r\"))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n {\n   if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n     return \"shll.l\\\\t%S1\\;xor.w\\\\t%T3,%T3\\;bst\\\\t#6,%s3\\;or.w\\\\t%T3,%e0\";\n@@ -3697,7 +3248,7 @@\n \t\t\t   (const_int 23))\n \t\t(match_operand:SI 2 \"register_operand\" \"0\")))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"#\")\n \n (define_split\n@@ -3706,10 +3257,9 @@\n \t\t\t   (const_int 23))\n \t\t(match_dup 0)))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && epilogue_completed\n-    && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n-    && REGNO (operands[0]) != REGNO (operands[1])\"\n+  \"epilogue_completed\n+   && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n+   && REGNO (operands[0]) != REGNO (operands[1])\"\n   [(parallel [(set (match_dup 3)\n \t\t   (ashift:HI (match_dup 3)\n \t\t\t      (const_int 7)))\n@@ -3728,10 +3278,9 @@\n \t\t\t   (const_int 23))\n \t\t(match_dup 0)))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && epilogue_completed\n-    && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n-\t && REGNO (operands[0]) != REGNO (operands[1]))\"\n+  \"epilogue_completed\n+   && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n+\t&& REGNO (operands[0]) != REGNO (operands[1]))\"\n   [(set (match_dup 2)\n \t(match_dup 1))\n    (parallel [(set (match_dup 3)\n@@ -3752,7 +3301,7 @@\n \t\t\t(const_int 1))\n \t\t(lshiftrt:SI (match_dup 1)\n \t\t\t     (const_int 1))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"shlr.l\\\\t%S0\\;bor\\\\t#0,%w0\\;bst\\\\t#0,%w0\"\n   [(set_attr \"length\" \"6\")])\n \n@@ -3762,7 +3311,7 @@\n \t\t\t   (const_int 16))\n \t\t(ashift:SI (match_operand:SI 2 \"register_operand\" \"r\")\n \t\t\t   (const_int 24))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 3)\n@@ -3785,7 +3334,7 @@\n \t\t\t(const_int 16711680))\n \t\t(ashift:SI (subreg:SI (match_operand:QI 2 \"memory_operand\" \"m\") 0)\n \t\t\t   (const_int 24))))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 3)\n@@ -3808,7 +3357,7 @@\n \t\t\t  (const_int 8388608))\n \t\t (match_operand:SI 2 \"register_operand\" \"0\")))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"#\")\n \n (define_split\n@@ -3817,10 +3366,9 @@\n \t\t\t  (const_int 8388608))\n \t\t (match_dup 0)))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && epilogue_completed\n-    && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n-    && REGNO (operands[0]) != REGNO (operands[1])\"\n+  \"epilogue_completed\n+   && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n+   && REGNO (operands[0]) != REGNO (operands[1])\"\n   [(parallel [(set (match_dup 3)\n \t\t   (ashift:HI (match_dup 3)\n \t\t\t      (const_int 7)))\n@@ -3839,10 +3387,9 @@\n \t\t\t  (const_int 8388608))\n \t\t (match_dup 0)))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && epilogue_completed\n-    && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n-\t && REGNO (operands[0]) != REGNO (operands[1]))\"\n+  \"epilogue_completed\n+   && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n+\t&& REGNO (operands[0]) != REGNO (operands[1]))\"\n   [(set (match_dup 2)\n \t(match_dup 1))\n    (parallel [(set (match_dup 3)\n@@ -3863,7 +3410,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ashift:SI (sign_extend:SI (match_operand:QI 1 \"register_operand\" \"0\"))\n \t\t   (const_int 7)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 2)\n@@ -3907,7 +3454,7 @@\n \t(subreg:QI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t\t(const_int 16)) 3))\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mov.w\\\\t%e1,%f2\\;mov.b\\\\t%w2,%R0\"\n   [(set_attr \"cc\" \"set_znv\")\n    (set_attr \"length\" \"10\")])\n@@ -3917,7 +3464,7 @@\n \t(subreg:QI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t\t(const_int 24)) 3))\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   \"mov.w\\\\t%e1,%f2\\;mov.b\\\\t%x2,%R0\"\n   [(set_attr \"cc\" \"set_znv\")\n    (set_attr \"length\" \"10\")])\n@@ -4269,11 +3816,10 @@\n    (set (match_dup 0)\n \t(plus:SI (match_dup 0)\n \t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && REG_P (operands[0]) && REG_P (operands[2])\n-    && REGNO (operands[0]) != REGNO (operands[2])\n-    && (satisfies_constraint_L (operands[1])\n-\t|| satisfies_constraint_N (operands[1]))\"\n+  \"REG_P (operands[0]) && REG_P (operands[2])\n+   && REGNO (operands[0]) != REGNO (operands[2])\n+   && (satisfies_constraint_L (operands[1])\n+       || satisfies_constraint_N (operands[1]))\"\n   [(set (match_dup 0)\n \t(match_dup 2))\n    (set (match_dup 0)\n@@ -4298,16 +3844,15 @@\n    (set (match_dup 0)\n \t(plus:SI (match_dup 0)\n \t\t (match_operand:SI 2 \"const_int_operand\" \"\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && operands[0] != stack_pointer_rtx\n-    && REG_P (operands[0]) && REG_P (operands[1])\n-    && REGNO (operands[0]) != REGNO (operands[1])\n-    && !satisfies_constraint_L (operands[2])\n-    && !satisfies_constraint_N (operands[2])\n-    && ((INTVAL (operands[2]) & 0xff) == INTVAL (operands[2])\n-\t|| (INTVAL (operands[2]) & 0xff00) == INTVAL (operands[2])\n-\t|| INTVAL (operands[2]) == 0xffff\n-\t|| INTVAL (operands[2]) == 0xfffe)\"\n+  \"operands[0] != stack_pointer_rtx\n+   && REG_P (operands[0]) && REG_P (operands[1])\n+   && REGNO (operands[0]) != REGNO (operands[1])\n+   && !satisfies_constraint_L (operands[2])\n+   && !satisfies_constraint_N (operands[2])\n+   && ((INTVAL (operands[2]) & 0xff) == INTVAL (operands[2])\n+       || (INTVAL (operands[2]) & 0xff00) == INTVAL (operands[2])\n+       || INTVAL (operands[2]) == 0xffff\n+       || INTVAL (operands[2]) == 0xfffe)\"\n   [(set (match_dup 0)\n \t(match_dup 2))\n    (set (match_dup 0)\n@@ -4337,7 +3882,7 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(unspec:HI [(match_dup 0)\n \t\t    (match_dup 1)]\n@@ -4363,7 +3908,7 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(unspec:SI [(match_dup 0)\n \t\t    (match_dup 1)]\n@@ -4388,7 +3933,7 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   [(set (cc0) (compare (match_dup 0)\n \t\t       (const_int 0)))\n    (set (pc)\n@@ -4418,9 +3963,8 @@\n    (set (match_operand:SI 2 \"register_operand\" \"\")\n \t(and:SI (match_dup 2)\n \t\t(const_int 255)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && !reg_overlap_mentioned_p (operands[2], operands[1])\n-    && REGNO (operands[0]) == REGNO (operands[2])\"\n+  \"!reg_overlap_mentioned_p (operands[2], operands[1])\n+   && REGNO (operands[0]) == REGNO (operands[2])\"\n   [(set (match_dup 2)\n \t(const_int 0))\n    (set (strict_low_part (match_dup 0))\n@@ -4433,10 +3977,9 @@\n    (set (match_dup 0)\n \t(and:SI (match_dup 0)\n \t\t(const_int 255)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && !reg_overlap_mentioned_p (operands[0], operands[1])\n-    && !(GET_CODE (operands[1]) == MEM && !offsettable_memref_p (operands[1]))\n-    && !(GET_CODE (operands[1]) == MEM && MEM_VOLATILE_P (operands[1]))\"\n+  \"!reg_overlap_mentioned_p (operands[0], operands[1])\n+   && !(GET_CODE (operands[1]) == MEM && !offsettable_memref_p (operands[1]))\n+   && !(GET_CODE (operands[1]) == MEM && MEM_VOLATILE_P (operands[1]))\"\n   [(set (match_dup 0)\n \t(const_int 0))\n    (set (strict_low_part (match_dup 2))\n@@ -4452,19 +3995,18 @@\n    (set (match_operand:SI 2 \"register_operand\" \"\")\n \t(and:SI (match_dup 2)\n \t\t(match_operand:SI 3 \"const_int_qi_operand\" \"\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && (GET_MODE (operands[0]) == QImode\n-\t|| GET_MODE (operands[0]) == HImode\n-\t|| GET_MODE (operands[0]) == SImode)\n-    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n-    && REGNO (operands[0]) == REGNO (operands[2])\n-    && !reg_overlap_mentioned_p (operands[2], operands[1])\n-    && !(GET_MODE (operands[1]) != QImode\n-\t && GET_CODE (operands[1]) == MEM\n-\t && !offsettable_memref_p (operands[1]))\n-    && !(GET_MODE (operands[1]) != QImode\n-\t && GET_CODE (operands[1]) == MEM\n-\t && MEM_VOLATILE_P (operands[1]))\"\n+  \"(GET_MODE (operands[0]) == QImode\n+    || GET_MODE (operands[0]) == HImode\n+    || GET_MODE (operands[0]) == SImode)\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\n+   && REGNO (operands[0]) == REGNO (operands[2])\n+   && !reg_overlap_mentioned_p (operands[2], operands[1])\n+   && !(GET_MODE (operands[1]) != QImode\n+\t&& GET_CODE (operands[1]) == MEM\n+\t&& !offsettable_memref_p (operands[1]))\n+   && !(GET_MODE (operands[1]) != QImode\n+\t&& GET_CODE (operands[1]) == MEM\n+\t&& MEM_VOLATILE_P (operands[1]))\"\n   [(set (match_dup 2)\n \t(const_int 0))\n    (set (strict_low_part (match_dup 4))\n@@ -4484,8 +4026,7 @@\n    (set (match_dup 0)\n \t(and:SI (match_dup 0)\n \t\t(const_int 65280)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-   && !reg_overlap_mentioned_p (operands[0], operands[1])\"\n+  \"!reg_overlap_mentioned_p (operands[0], operands[1])\"\n   [(set (match_dup 0)\n \t(const_int 0))\n    (set (zero_extract:SI (match_dup 0)\n@@ -4504,11 +4045,10 @@\n    (set (match_dup 0)\n \t(and:SI (match_dup 0)\n \t\t(match_operand:SI 2 \"const_int_operand\" \"\")))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && !MEM_VOLATILE_P (operands[1])\n-    && offsettable_memref_p (operands[1])\n-    && (INTVAL (operands[2]) & ~0xffff) == 0\n-    && INTVAL (operands[2]) != 255\"\n+  \"!MEM_VOLATILE_P (operands[1])\n+   && offsettable_memref_p (operands[1])\n+   && (INTVAL (operands[2]) & ~0xffff) == 0\n+   && INTVAL (operands[2]) != 255\"\n   [(set (match_dup 3)\n \t(match_dup 4))\n    (set (match_dup 0)\n@@ -4538,7 +4078,7 @@\n    (set (cc0)\n \t(compare (match_operand:HI 0 \"memory_operand\" \"\")\n \t\t (const_int 0)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   [(set (match_dup 1)\n \t(match_dup 0))\n    (set (cc0) (compare (match_dup 1)\n@@ -4550,7 +4090,7 @@\n    (set (cc0)\n \t(compare (match_operand:SI 0 \"memory_operand\" \"\")\n \t\t (const_int 0)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   [(set (match_dup 1)\n \t(match_dup 0))\n    (set (cc0) (compare (match_dup 1)\n@@ -4598,9 +4138,7 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && INTVAL (operands[1]) != 0\n-    && peep2_reg_dead_p (1, operands[0])\"\n+  \"INTVAL (operands[1]) != 0 && peep2_reg_dead_p (1, operands[0])\"\n   [(set (match_dup 0)\n \t(unspec:HI [(match_dup 0)\n \t\t    (match_dup 4)]\n@@ -4634,10 +4172,9 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && peep2_reg_dead_p (1, operands[0])\n-    && (INTVAL (operands[1]) == 1\n-\t|| (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n   [(parallel [(set (match_dup 0)\n \t\t   (ashiftrt:HI (match_dup 0)\n \t\t\t\t(match_dup 4)))\n@@ -4671,10 +4208,9 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && peep2_reg_dead_p (1, operands[0])\n-    && (INTVAL (operands[1]) == 1\n-\t|| (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n   [(parallel [(set (match_dup 0)\n \t\t   (ashiftrt:HI (match_dup 0)\n \t\t\t\t(match_dup 4)))\n@@ -4710,7 +4246,7 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   [(set (cc0) (compare (and:HI (match_dup 0)\n \t\t\t       (const_int -256))\n \t\t       (const_int 0)))\n@@ -4739,7 +4275,7 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   [(set (cc0) (compare (and:HI (match_dup 0)\n \t\t\t       (const_int -256))\n \t\t       (const_int 0)))\n@@ -4833,9 +4369,7 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && INTVAL (operands[1]) != 0\n-    && peep2_reg_dead_p (1, operands[0])\"\n+  \"INTVAL (operands[1]) != 0 && peep2_reg_dead_p (1, operands[0])\"\n   [(set (match_dup 0)\n \t(unspec:SI [(match_dup 0)\n \t\t    (match_dup 4)]\n@@ -4869,12 +4403,11 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && peep2_reg_dead_p (1, operands[0])\n-    && (INTVAL (operands[1]) == -131072\n-\t|| INTVAL (operands[1]) == -65536\n-\t|| INTVAL (operands[1]) == 65536\n-\t|| INTVAL (operands[1]) == 131072)\"\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == -131072\n+       || INTVAL (operands[1]) == -65536\n+       || INTVAL (operands[1]) == 65536\n+       || INTVAL (operands[1]) == 131072)\"\n   [(set (match_dup 0)\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 4)))\n@@ -4908,14 +4441,13 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && peep2_reg_dead_p (1, operands[0])\n-    && ((INTVAL (operands[1]) & 0x00ff) == INTVAL (operands[1])\n-\t|| (INTVAL (operands[1]) & 0xff00) == INTVAL (operands[1])\n-\t|| INTVAL (operands[1]) == 0x0000ffff)\n-    && INTVAL (operands[1]) != 0\n-    && INTVAL (operands[1]) != 1\n-    && INTVAL (operands[1]) != 2\"\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && ((INTVAL (operands[1]) & 0x00ff) == INTVAL (operands[1])\n+       || (INTVAL (operands[1]) & 0xff00) == INTVAL (operands[1])\n+       || INTVAL (operands[1]) == 0x0000ffff)\n+   && INTVAL (operands[1]) != 0\n+   && INTVAL (operands[1]) != 1\n+   && INTVAL (operands[1]) != 2\"\n   [(set (match_dup 0)\n \t(xor:SI (match_dup 0)\n \t\t(match_dup 1)))\n@@ -4947,12 +4479,11 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && peep2_reg_dead_p (1, operands[0])\n-    && ((INTVAL (operands[1]) | 0x00ff) == -1\n-\t|| (INTVAL (operands[1]) | 0xff00) == -1)\n-    && INTVAL (operands[1]) != -1\n-    && INTVAL (operands[1]) != -2\"\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && ((INTVAL (operands[1]) | 0x00ff) == -1\n+       || (INTVAL (operands[1]) | 0xff00) == -1)\n+   && INTVAL (operands[1]) != -1\n+   && INTVAL (operands[1]) != -2\"\n   [(set (match_dup 0)\n \t(xor:SI (match_dup 0)\n \t\t(match_dup 4)))\n@@ -4988,10 +4519,9 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && peep2_reg_dead_p (1, operands[0])\n-    && (INTVAL (operands[1]) == -2147483647 - 1\n-\t|| (TARGET_H8300S && INTVAL (operands[1]) == 1073741824))\"\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == -2147483647 - 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 1073741824))\"\n   [(set (match_dup 0)\n \t(rotate:SI (match_dup 0)\n \t\t   (match_dup 4)))\n@@ -5033,11 +4563,10 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && !peep2_reg_dead_p (1, operands[0])\n-    && (INTVAL (operands[1]) == 1\n-\t|| (TARGET_H8300S && INTVAL (operands[1]) == 3))\n-    && !same_cmp_preceding_p (insn)\"\n+  \"!peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\n+   && !same_cmp_preceding_p (insn)\"\n   [(set (match_dup 4)\n \t(match_dup 0))\n    (parallel [(set (match_dup 4)\n@@ -5078,11 +4607,10 @@\n \t\t         [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && !peep2_reg_dead_p (1, operands[0])\n-    && (INTVAL (operands[1]) == 1\n-\t|| (TARGET_H8300S && INTVAL (operands[1]) == 3))\n-    && !same_cmp_preceding_p (insn)\"\n+  \"!peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\n+   && !same_cmp_preceding_p (insn)\"\n   [(set (match_dup 4)\n \t(match_dup 0))\n    (parallel [(set (match_dup 4)\n@@ -5120,10 +4648,9 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && peep2_reg_dead_p (1, operands[0])\n-    && (INTVAL (operands[1]) == 1\n-        || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n   [(parallel [(set (match_dup 0)\n \t\t   (ashiftrt:SI (match_dup 0)\n \t\t\t\t(match_dup 4)))\n@@ -5157,10 +4684,9 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && peep2_reg_dead_p (1, operands[0])\n-    && (INTVAL (operands[1]) == 1\n-\t|| (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n   [(parallel [(set (match_dup 0)\n \t\t   (ashiftrt:SI (match_dup 0)\n \t\t\t\t(match_dup 4)))\n@@ -5197,15 +4723,14 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && peep2_reg_dead_p (1, operands[0])\n-    && (INTVAL (operands[1]) == 3\n-\t || INTVAL (operands[1]) == 7\n-\t || INTVAL (operands[1]) == 15\n-\t || INTVAL (operands[1]) == 31\n-\t || INTVAL (operands[1]) == 63\n-\t || INTVAL (operands[1]) == 127\n-\t || INTVAL (operands[1]) == 255)\"\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 3\n+       || INTVAL (operands[1]) == 7\n+       || INTVAL (operands[1]) == 15\n+       || INTVAL (operands[1]) == 31\n+       || INTVAL (operands[1]) == 63\n+       || INTVAL (operands[1]) == 127\n+       || INTVAL (operands[1]) == 255)\"\n   [(set (match_dup 0)\n \t(and:SI (match_dup 0)\n \t\t(match_dup 4)))\n@@ -5239,15 +4764,14 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && peep2_reg_dead_p (1, operands[0])\n-    && ((TARGET_H8300H && INTVAL (operands[1]) == 3)\n-\t || INTVAL (operands[1]) == 7\n-\t || INTVAL (operands[1]) == 15\n-\t || INTVAL (operands[1]) == 31\n-\t || INTVAL (operands[1]) == 63\n-\t || INTVAL (operands[1]) == 127\n-\t || INTVAL (operands[1]) == 255)\"\n+  \"peep2_reg_dead_p (1, operands[0])\n+   && ((TARGET_H8300H && INTVAL (operands[1]) == 3)\n+\t|| INTVAL (operands[1]) == 7\n+\t|| INTVAL (operands[1]) == 15\n+\t|| INTVAL (operands[1]) == 31\n+\t|| INTVAL (operands[1]) == 63\n+\t|| INTVAL (operands[1]) == 127\n+\t|| INTVAL (operands[1]) == 255)\"\n   [(set (match_dup 0)\n \t(and:SI (match_dup 0)\n \t\t(match_dup 4)))\n@@ -5282,7 +4806,7 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   [(set (cc0) (compare (and:SI (match_dup 0)\n \t\t\t       (const_int -65536))\n \t\t       (const_int 0)))\n@@ -5311,7 +4835,7 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"\"\n   [(set (cc0) (compare (and:SI (match_dup 0)\n \t\t\t       (const_int -65536))\n \t\t       (const_int 0)))\n@@ -5348,10 +4872,9 @@\n \t\t       [(cc0) (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(TARGET_H8300H || TARGET_H8300S)\n-    && INTVAL (operands[1]) != 0\n-    && !peep2_reg_dead_p (1, operands[0])\n-    && !same_cmp_following_p (insn)\"\n+  \"INTVAL (operands[1]) != 0\n+   && !peep2_reg_dead_p (1, operands[0])\n+   && !same_cmp_following_p (insn)\"\n   [(set (match_dup 4)\n \t(match_dup 0))\n    (set (match_dup 4)\n@@ -5415,8 +4938,7 @@\n \t\t (const_int -4)))\n    (set (mem:SI (reg:SI SP_REG))\n \t(match_operand:SI 0 \"register_operand\" \"\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE\n-    && REGNO (operands[0]) != SP_REG\"\n+  \"!TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n   [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n \t(match_dup 0))]\n   \"\")\n@@ -5432,8 +4954,7 @@\n \t\t (const_int -12)))\n    (set (mem:SI (reg:SI SP_REG))\n \t(match_operand:SI 0 \"register_operand\" \"\"))]\n-  \"(TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE\n-    && REGNO (operands[0]) != SP_REG\"\n+  \"!TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n   [(set (reg:SI SP_REG)\n \t(plus:SI (reg:SI SP_REG)\n \t\t (const_int -4)))"}, {"sha": "6496992dbe8bd190587bd9da54cce7765a9b7725", "filename": "gcc/config/h8300/predicates.md", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fpredicates.md?ref=27c1afd533722e0dbc90562618a136653339cc49", "patch": "@@ -296,30 +296,17 @@\n          the negative case.  */\n       if (value < 0)\n \tvalue = -value;\n-      if (TARGET_H8300H || TARGET_H8300S)\n-\t{\n-\t  /* A constant addition/subtraction takes 2 states in QImode,\n-\t     4 states in HImode, and 6 states in SImode.  Thus, the\n-\t     only case we can win is when SImode is used, in which\n-\t     case, two adds/subs are used, taking 4 states.  */\n-\t  if (mode == SImode\n-\t      && (value == 2 + 1\n-\t\t  || value == 4 + 1\n-\t\t  || value == 4 + 2\n-\t\t  || value == 4 + 4))\n-\t    return 1;\n-\t}\n-      else\n-\t{\n-\t  /* We do not profit directly by splitting addition or\n-\t     subtraction of 3 and 4.  However, since these are\n-\t     implemented as a sequence of adds or subs, they do not\n-\t     clobber (cc0) unlike a sequence of add.b and add.x.  */\n-\t  if (mode == HImode\n-\t      && (value == 2 + 1\n-\t\t  || value == 2 + 2))\n-\t    return 1;\n-\t}\n+\n+      /* A constant addition/subtraction takes 2 states in QImode,\n+\t 4 states in HImode, and 6 states in SImode.  Thus, the\n+\t only case we can win is when SImode is used, in which\n+\t case, two adds/subs are used, taking 4 states.  */\n+      if (mode == SImode\n+\t  && (value == 2 + 1\n+\t      || value == 4 + 1\n+\t      || value == 4 + 2\n+\t      || value == 4 + 4))\n+\treturn 1;\n     }\n \n   return 0;"}, {"sha": "62d270007747443555c0e6e4fe4a7bb4e0a9c0c6", "filename": "gcc/config/h8300/t-h8300", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Ft-h8300", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c1afd533722e0dbc90562618a136653339cc49/gcc%2Fconfig%2Fh8300%2Ft-h8300", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Ft-h8300?ref=27c1afd533722e0dbc90562618a136653339cc49", "patch": "@@ -16,9 +16,8 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-MULTILIB_OPTIONS = mh/ms/msx mn mint32\n-MULTILIB_DIRNAMES = h8300h h8300s h8sx normal int32\n-MULTILIB_EXCEPTIONS = mint32 mn mn/mint32\n+MULTILIB_OPTIONS = ms/msx mn mint32\n+MULTILIB_DIRNAMES = h8300s h8sx normal int32\n \n s-config s-conditions s-flags s-codes s-constants s-emit s-recog \\\n s-opinit s-extract s-peep s-attr s-attrtab s-output: \\"}]}