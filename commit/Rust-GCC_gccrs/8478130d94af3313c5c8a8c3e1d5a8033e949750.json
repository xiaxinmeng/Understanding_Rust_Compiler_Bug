{"sha": "8478130d94af3313c5c8a8c3e1d5a8033e949750", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ3ODEzMGQ5NGFmMzMxM2M1YzhhOGMzZTFkNWE4MDMzZTk0OTc1MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-28T19:11:50Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-28T19:11:50Z"}, "message": "Uniquization of constants at the Tree level\n\n\tUniquization of constants at the Tree level\n\t* tree.h (DECL_IN_CONSTANT_POOL): New macro\n\t(tree_decl_with_vis): Add in_constant_pool bit, move shadowed_for_var_p\n\tbit to the end.\n\t(tree_output_constant_def): Declare.\n\t* gimplify.c (gimplify_init_constructor): When using block copy,\n\tuniquize the constant constructor on the RHS.\n\t* lto-streamer-in.c (unpack_ts_decl_with_vis_value_fields): Deal\n\twith DECL_IN_CONSTANT_POOL flag.\n\t* lto-streamer-out.c (pack_ts_decl_with_vis_value_fields): Likewise.\n\t* varasm.c (make_decl_rtl): Deal with variables belonging to the\n\tglobal constant pool.\n\t(assemble_variable): Deal with symbols belonging to the tree constant\n\tpool.\n\t(get_constant_section): Add ALIGN parameter and simplify.\n\t(build_constant_desc): Build a VAR_DECL and attach it to the symbol.\n\t(assemble_constant_contents): Use the expression of the VAR_DECL.\n\t(output_constant_def_contents): Use the alignment of the VAR_DECL.\n\t(tree_output_constant_def): New global function.\n\t(mark_constant): Use the expression of the VAR_DECL.\n\t(place_block_symbol): Use the alignment of the VAR_DECL and the size\n\tof its expression.\n\t(output_object_block): Likewise and assemble the expression.\nada/\n\t* gcc-interface/trans.c (gnat_gimplify_expr) <ADDR_EXPR>: Uniquize\n\tconstant constructors before taking their address.\n\nFrom-SVN: r158838", "tree": {"sha": "1d892ec6e17c326d149f09c6e7cf245a89024974", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d892ec6e17c326d149f09c6e7cf245a89024974"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8478130d94af3313c5c8a8c3e1d5a8033e949750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8478130d94af3313c5c8a8c3e1d5a8033e949750", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8478130d94af3313c5c8a8c3e1d5a8033e949750", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8478130d94af3313c5c8a8c3e1d5a8033e949750/comments", "author": null, "committer": null, "parents": [{"sha": "331c7fcdd09ca68e53bd5e64cd4b1cdc04416aa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/331c7fcdd09ca68e53bd5e64cd4b1cdc04416aa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/331c7fcdd09ca68e53bd5e64cd4b1cdc04416aa2"}], "stats": {"total": 278, "additions": 207, "deletions": 71}, "files": [{"sha": "2dffe7d2267048a3149793ee69712e8a9467012c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -1,3 +1,29 @@\n+2010-04-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tUniquization of constants at the Tree level\n+\t* tree.h (DECL_IN_CONSTANT_POOL): New macro\n+\t(tree_decl_with_vis): Add in_constant_pool bit, move shadowed_for_var_p\n+\tbit to the end.\n+\t(tree_output_constant_def): Declare.\n+\t* gimplify.c (gimplify_init_constructor): When using block copy,\n+\tuniquize the constant constructor on the RHS.\n+\t* lto-streamer-in.c (unpack_ts_decl_with_vis_value_fields): Deal\n+\twith DECL_IN_CONSTANT_POOL flag.\n+\t* lto-streamer-out.c (pack_ts_decl_with_vis_value_fields): Likewise.\n+\t* varasm.c (make_decl_rtl): Deal with variables belonging to the\n+\tglobal constant pool.\n+\t(assemble_variable): Deal with symbols belonging to the tree constant\n+\tpool.\n+\t(get_constant_section): Add ALIGN parameter and simplify.\n+\t(build_constant_desc): Build a VAR_DECL and attach it to the symbol.\n+\t(assemble_constant_contents): Use the expression of the VAR_DECL.\n+\t(output_constant_def_contents): Use the alignment of the VAR_DECL.\n+\t(tree_output_constant_def): New global function.\n+\t(mark_constant): Use the expression of the VAR_DECL.\n+\t(place_block_symbol): Use the alignment of the VAR_DECL and the size\n+\tof its expression.\n+\t(output_object_block): Likewise and assemble the expression.\n+\n 2010-04-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* lto-streamer.c [LTO_STREAMER_DEBUG] (tree_htab, tree_hash_entry,"}, {"sha": "6303c3927c44905186623b67f54af020a0f45d84", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -1,3 +1,8 @@\n+2010-04-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gnat_gimplify_expr) <ADDR_EXPR>: Uniquize\n+\tconstant constructors before taking their address.\n+\n 2010-04-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exp_dbug.ads: Fix outdated description.  Mention link between XVS"}, {"sha": "743a6521094ce5f4cae5c9c869cb8e6a7c82c05c", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -6036,16 +6036,8 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t     the reference is in an elaboration procedure.  */\n \t  if (TREE_CONSTANT (op))\n \t    {\n-\t      tree new_var = create_tmp_var_raw (TREE_TYPE (op), \"C\");\n-\t      TREE_ADDRESSABLE (new_var) = 1;\n-\t      gimple_add_tmp_var (new_var);\n-\n-\t      TREE_READONLY (new_var) = 1;\n-\t      TREE_STATIC (new_var) = 1;\n-\t      DECL_INITIAL (new_var) = op;\n-\n-\t      TREE_OPERAND (expr, 0) = new_var;\n-\t      recompute_tree_invariant_for_addr_expr (expr);\n+\t      tree addr = build_fold_addr_expr (tree_output_constant_def (op));\n+\t      *expr_p = fold_convert (TREE_TYPE (expr), addr);\n \t    }\n \n \t  /* Otherwise explicitly create the local temporary.  That's required"}, {"sha": "68148a6a7d907cad854892571bcaab9a7f024b20", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -3758,25 +3758,11 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t&& num_nonzero_elements > 1\n \t\t&& !can_move_by_pieces (size, align))\n \t      {\n-\t\ttree new_tree;\n-\n \t\tif (notify_temp_creation)\n \t\t  return GS_ERROR;\n \n-\t\tnew_tree = create_tmp_var_raw (type, \"C\");\n-\n-\t\tgimple_add_tmp_var (new_tree);\n-\t\tTREE_STATIC (new_tree) = 1;\n-\t\tTREE_READONLY (new_tree) = 1;\n-\t\tDECL_INITIAL (new_tree) = ctor;\n-\t\tif (align > DECL_ALIGN (new_tree))\n-\t\t  {\n-\t\t    DECL_ALIGN (new_tree) = align;\n-\t\t    DECL_USER_ALIGN (new_tree) = 1;\n-\t\t  }\n-\t        walk_tree (&DECL_INITIAL (new_tree), force_labels_r, NULL, NULL);\n-\n-\t\tTREE_OPERAND (*expr_p, 1) = new_tree;\n+\t        walk_tree (&ctor, force_labels_r, NULL, NULL);\n+\t\tTREE_OPERAND (*expr_p, 1) = tree_output_constant_def (ctor);\n \n \t\t/* This is no longer an assignment of a CONSTRUCTOR, but\n \t\t   we still may have processing to do on the LHS.  So"}, {"sha": "d5860ea527ff21ea78ca7cf5219215e375e2a574", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -1720,6 +1720,7 @@ unpack_ts_decl_with_vis_value_fields (struct bitpack_d *bp, tree expr)\n     {\n       DECL_HARD_REGISTER (expr) = (unsigned) bp_unpack_value (bp, 1);\n       DECL_IN_TEXT_SECTION (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      DECL_IN_CONSTANT_POOL (expr) = (unsigned) bp_unpack_value (bp, 1);\n       DECL_TLS_MODEL (expr) = (enum tls_model) bp_unpack_value (bp,  3);\n     }\n "}, {"sha": "055ca3a87344ae1db5763ac3dde75e2204ee981f", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -468,6 +468,7 @@ pack_ts_decl_with_vis_value_fields (struct bitpack_d *bp, tree expr)\n     {\n       bp_pack_value (bp, DECL_HARD_REGISTER (expr), 1);\n       bp_pack_value (bp, DECL_IN_TEXT_SECTION (expr), 1);\n+      bp_pack_value (bp, DECL_IN_CONSTANT_POOL (expr), 1);\n       bp_pack_value (bp, DECL_TLS_MODEL (expr),  3);\n     }\n "}, {"sha": "7e3834df916543119348365f0ed18cebcf603b61", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -1,3 +1,8 @@\n+2010-04-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/const-uniq-1.c: New test.\n+\t* gcc.dg/lto/const-uniq_[01].c: Likewise.\n+\n 2010-04-28  Xinliang David Li  <davidxl@google.com>\n \n \t* gcc.dg/uninit-pred-2_b.c: New test."}, {"sha": "6529c5458abef34547a1aa8ed91fd36a27795f90", "filename": "gcc/testsuite/gcc.dg/const-uniq-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-uniq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-uniq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-uniq-1.c?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -0,0 +1,19 @@\n+/* Verify that the 2 constant initializers are uniquized.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -fdump-tree-gimple\" } */\n+\n+int lookup1 (int i)\n+{\n+  int a[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+  return a[i];\n+}\n+\n+int lookup2 (int i)\n+{\n+  int a[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+  return a[i+1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LC0\" 2 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "746167c6517c1b8ca2f225d14b0f7e689855e020", "filename": "gcc/testsuite/gcc.dg/lto/const-uniq_0.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fconst-uniq_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fconst-uniq_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fconst-uniq_0.c?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -0,0 +1,16 @@\n+/* The 3 constant initializers should be uniquized.  */\n+\n+/* { dg-lto-do run } */\n+/* { dg-lto-options {{-Os -flto} {-Os -fwhopr} } } */\n+\n+int lookup1 (int i)\n+{\n+  int a[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+  return a[i];\n+}\n+\n+int lookup2 (int i)\n+{\n+  int a[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+  return a[i+1];\n+}"}, {"sha": "ee1505cc9a70d7d5ba8d8a22ade8a5ebfaebef92", "filename": "gcc/testsuite/gcc.dg/lto/const-uniq_1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fconst-uniq_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fconst-uniq_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fconst-uniq_1.c?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -0,0 +1,23 @@\n+extern int lookup1 (int i);\n+extern int lookup2 (int i);\n+extern void abort (void);\n+\n+int lookup3 (int i)\n+{\n+  int a[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+  return a[i+2];\n+}\n+\n+int main (void)\n+{\n+  if (lookup1(2) != 2)\n+    abort ();\n+\n+  if (lookup2(2) != 3)\n+    abort ();\n+\n+  if (lookup3(2) != 4)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "99bf29b9eb20f350d955382278c643f208394397", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -2963,6 +2963,11 @@ struct GTY(()) tree_parm_decl {\n #define DECL_IN_TEXT_SECTION(NODE) \\\n   (VAR_DECL_CHECK (NODE)->decl_with_vis.in_text_section)\n \n+/* In a VAR_DECL that's static,\n+   nonzero if it belongs to the global constant pool.  */\n+#define DECL_IN_CONSTANT_POOL(NODE) \\\n+  (VAR_DECL_CHECK (NODE)->decl_with_vis.in_constant_pool)\n+\n /* Nonzero for a given ..._DECL node means that this node should be\n    put in .common, if possible.  If a DECL_INITIAL is given, and it\n    is not error_mark_node, then the decl cannot be put in .common.  */\n@@ -3102,9 +3107,8 @@ struct GTY(()) tree_decl_with_vis {\n  unsigned thread_local : 1;\n  unsigned common_flag : 1;\n  unsigned in_text_section : 1;\n+ unsigned in_constant_pool : 1;\n  unsigned dllimport_flag : 1;\n- /* Used by C++.  Might become a generic decl flag.  */\n- unsigned shadowed_for_var_p : 1;\n  /* Don't belong to VAR_DECL exclusively.  */\n  unsigned weak_flag : 1;\n \n@@ -3117,7 +3121,9 @@ struct GTY(()) tree_decl_with_vis {\n \n  /* Belong to FUNCTION_DECL exclusively.  */\n  unsigned init_priority_p : 1;\n- /* 15 unused bits. */\n+ /* Used by C++ only.  Might become a generic decl flag.  */\n+ unsigned shadowed_for_var_p : 1;\n+ /* 14 unused bits. */\n };\n \n extern tree decl_debug_expr_lookup (tree);\n@@ -5184,6 +5190,7 @@ extern void internal_reference_types (void);\n extern unsigned int update_alignment_for_field (record_layout_info, tree,\n                                                 unsigned int);\n /* varasm.c */\n+extern tree tree_output_constant_def (tree);\n extern void make_decl_rtl (tree);\n extern rtx make_decl_rtl_for_debug (tree);\n extern void make_decl_one_only (tree, tree);"}, {"sha": "bcb5b114238d1febca9a4863396bf6353ea2b235", "filename": "gcc/varasm.c", "status": "modified", "additions": 97, "deletions": 42, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8478130d94af3313c5c8a8c3e1d5a8033e949750/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=8478130d94af3313c5c8a8c3e1d5a8033e949750", "patch": "@@ -1354,6 +1354,14 @@ make_decl_rtl (tree decl)\n       return;\n     }\n \n+  /* If this variable belongs to the global constant pool, retrieve the\n+     pre-computed RTL or recompute it in LTO mode.  */\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_IN_CONSTANT_POOL (decl))\n+    {\n+      SET_DECL_RTL (decl, output_constant_def (DECL_INITIAL (decl), 1));\n+      return;\n+    }\n+\n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \n   if (name[0] != '*' && TREE_CODE (decl) != FUNCTION_DECL\n@@ -2198,8 +2206,6 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   if (flag_syntax_only)\n     return;\n \n-  app_disable ();\n-\n   if (! dont_output_data\n       && ! host_integerp (DECL_SIZE_UNIT (decl), 1))\n     {\n@@ -2210,6 +2216,19 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   gcc_assert (MEM_P (decl_rtl));\n   gcc_assert (GET_CODE (XEXP (decl_rtl, 0)) == SYMBOL_REF);\n   symbol = XEXP (decl_rtl, 0);\n+\n+  /* If this symbol belongs to the tree constant pool, output the constant\n+     if it hasn't already been written.  */\n+  if (TREE_CONSTANT_POOL_ADDRESS_P (symbol))\n+    {\n+      tree decl = SYMBOL_REF_DECL (symbol);\n+      if (!TREE_ASM_WRITTEN (DECL_INITIAL (decl)))\n+\toutput_constant_def_contents (symbol);\n+      return;\n+    }\n+\n+  app_disable ();\n+\n   name = XSTR (symbol, 0);\n   if (TREE_PUBLIC (decl) && DECL_NAME (decl))\n     notice_global_symbol (decl);\n@@ -2790,7 +2809,6 @@ decode_addr_const (tree exp, struct addr_const *value)\n     {\n       if (TREE_CODE (target) == COMPONENT_REF\n \t  && host_integerp (byte_position (TREE_OPERAND (target, 1)), 0))\n-\n \t{\n \t  offset += int_byte_position (TREE_OPERAND (target, 1));\n \t  target = TREE_OPERAND (target, 0);\n@@ -2847,7 +2865,6 @@ decode_addr_const (tree exp, struct addr_const *value)\n static GTY((param_is (struct constant_descriptor_tree)))\n      htab_t const_desc_htab;\n \n-static struct constant_descriptor_tree * build_constant_desc (tree);\n static void maybe_output_constant_def_contents (struct constant_descriptor_tree *, int);\n \n /* Constant pool accessor function.  */\n@@ -3236,31 +3253,14 @@ copy_constant (tree exp)\n     }\n }\n \f\n-/* Return the alignment of constant EXP in bits.  */\n-\n-static unsigned int\n-get_constant_alignment (tree exp)\n-{\n-  unsigned int align;\n-\n-  align = TYPE_ALIGN (TREE_TYPE (exp));\n-#ifdef CONSTANT_ALIGNMENT\n-  align = CONSTANT_ALIGNMENT (exp, align);\n-#endif\n-  return align;\n-}\n-\n /* Return the section into which constant EXP should be placed.  */\n \n static section *\n-get_constant_section (tree exp)\n+get_constant_section (tree exp, unsigned int align)\n {\n-  if (IN_NAMED_SECTION (exp))\n-    return get_named_section (exp, NULL, compute_reloc_for_constant (exp));\n-  else\n-    return targetm.asm_out.select_section (exp,\n-\t\t\t\t\t   compute_reloc_for_constant (exp),\n-\t\t\t\t\t   get_constant_alignment (exp));\n+  return targetm.asm_out.select_section (exp,\n+\t\t\t\t\t compute_reloc_for_constant (exp),\n+\t\t\t\t\t align);\n }\n \n /* Return the size of constant EXP in bytes.  */\n@@ -3286,11 +3286,11 @@ get_constant_size (tree exp)\n static struct constant_descriptor_tree *\n build_constant_desc (tree exp)\n {\n-  rtx symbol;\n-  rtx rtl;\n+  struct constant_descriptor_tree *desc;\n+  rtx symbol, rtl;\n   char label[256];\n   int labelno;\n-  struct constant_descriptor_tree *desc;\n+  tree decl;\n \n   desc = GGC_NEW (struct constant_descriptor_tree);\n   desc->value = copy_constant (exp);\n@@ -3303,17 +3303,41 @@ build_constant_desc (tree exp)\n   labelno = const_labelno++;\n   ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", labelno);\n \n-  /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n+  /* Construct the VAR_DECL associated with the constant.  */\n+  decl = build_decl (UNKNOWN_LOCATION, VAR_DECL, get_identifier (label),\n+\t\t     TREE_TYPE (exp));\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n+  TREE_READONLY (decl) = 1;\n+  TREE_STATIC (decl) = 1;\n+  TREE_ADDRESSABLE (decl) = 1;\n+  /* We don't set the RTL yet as this would cause varpool to assume that the\n+     variable is referenced.  Moreover, it would just be dropped in LTO mode.\n+     Instead we set the flag that will be recognized in make_decl_rtl.  */\n+  DECL_IN_CONSTANT_POOL (decl) = 1;\n+  DECL_INITIAL (decl) = desc->value;\n+  /* ??? CONSTANT_ALIGNMENT hasn't been updated for vector types on most\n+     architectures so use DATA_ALIGNMENT as well, except for strings.  */\n+  if (TREE_CODE (exp) == STRING_CST)\n+    {\n+#ifdef CONSTANT_ALIGNMENT\n+      DECL_ALIGN (decl) = CONSTANT_ALIGNMENT (exp, DECL_ALIGN (decl));\n+#endif\n+    }\n+  else\n+    align_variable (decl, 0);\n+\n+  /* Now construct the SYMBOL_REF and the MEM.  */\n   if (use_object_blocks_p ())\n     {\n-      section *sect = get_constant_section (exp);\n+      section *sect = get_constant_section (exp, DECL_ALIGN (decl));\n       symbol = create_block_symbol (ggc_strdup (label),\n \t\t\t\t    get_block_for_section (sect), -1);\n     }\n   else\n     symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));\n   SYMBOL_REF_FLAGS (symbol) |= SYMBOL_FLAG_LOCAL;\n-  SET_SYMBOL_REF_DECL (symbol, desc->value);\n+  SET_SYMBOL_REF_DECL (symbol, decl);\n   TREE_CONSTANT_POOL_ADDRESS_P (symbol) = 1;\n \n   rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)), symbol);\n@@ -3330,7 +3354,6 @@ build_constant_desc (tree exp)\n      ASM_OUTPUT_LABELREF will have to know how to strip this\n      information.  This call might invalidate our local variable\n      SYMBOL; we can't use it afterward.  */\n-\n   targetm.encode_section_info (exp, rtl, true);\n \n   desc->rtl = rtl;\n@@ -3437,7 +3460,8 @@ assemble_constant_contents (tree exp, const char *label, unsigned int align)\n static void\n output_constant_def_contents (rtx symbol)\n {\n-  tree exp = SYMBOL_REF_DECL (symbol);\n+  tree decl = SYMBOL_REF_DECL (symbol);\n+  tree exp = DECL_INITIAL (decl);\n   unsigned int align;\n \n   /* Make sure any other constants whose addresses appear in EXP\n@@ -3454,8 +3478,8 @@ output_constant_def_contents (rtx symbol)\n     place_block_symbol (symbol);\n   else\n     {\n-      switch_to_section (get_constant_section (exp));\n-      align = get_constant_alignment (exp);\n+      align = DECL_ALIGN (decl);\n+      switch_to_section (get_constant_section (exp, align));\n       if (align > BITS_PER_UNIT)\n \tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n       assemble_constant_contents (exp, XSTR (symbol, 0), align);\n@@ -3480,6 +3504,37 @@ lookup_constant_def (tree exp)\n \n   return (desc ? desc->rtl : NULL_RTX);\n }\n+\n+/* Return a tree representing a reference to constant data in memory\n+   for the constant expression EXP.\n+\n+   This is the counterpart of output_constant_def at the Tree level.  */\n+\n+tree\n+tree_output_constant_def (tree exp)\n+{\n+  struct constant_descriptor_tree *desc, key;\n+  void **loc;\n+  tree decl;\n+\n+  /* Look up EXP in the table of constant descriptors.  If we didn't find\n+     it, create a new one.  */\n+  key.value = exp;\n+  key.hash = const_hash_1 (exp);\n+  loc = htab_find_slot_with_hash (const_desc_htab, &key, key.hash, INSERT);\n+\n+  desc = (struct constant_descriptor_tree *) *loc;\n+  if (desc == 0)\n+    {\n+      desc = build_constant_desc (exp);\n+      desc->hash = key.hash;\n+      *loc = desc;\n+    }\n+\n+  decl = SYMBOL_REF_DECL (XEXP (desc->rtl, 0));\n+  varpool_finalize_decl (decl);\n+  return decl;\n+}\n \f\n /* Used in the hash tables to avoid outputting the same constant\n    twice.  Unlike 'struct constant_descriptor_tree', RTX constants\n@@ -3949,8 +4004,8 @@ mark_constant (rtx *current_rtx, void *data ATTRIBUTE_UNUSED)\n     }\n   else if (TREE_CONSTANT_POOL_ADDRESS_P (x))\n     {\n-      tree exp = SYMBOL_REF_DECL (x);\n-      if (!TREE_ASM_WRITTEN (exp))\n+      tree decl = SYMBOL_REF_DECL (x);\n+      if (!TREE_ASM_WRITTEN (DECL_INITIAL (decl)))\n \t{\n \t  n_deferred_constants--;\n \t  output_constant_def_contents (x);\n@@ -6912,8 +6967,8 @@ place_block_symbol (rtx symbol)\n   else if (TREE_CONSTANT_POOL_ADDRESS_P (symbol))\n     {\n       decl = SYMBOL_REF_DECL (symbol);\n-      alignment = get_constant_alignment (decl);\n-      size = get_constant_size (decl);\n+      alignment = DECL_ALIGN (decl);\n+      size = get_constant_size (DECL_INITIAL (decl));\n     }\n   else\n     {\n@@ -7059,9 +7114,9 @@ output_object_block (struct object_block *block)\n       else if (TREE_CONSTANT_POOL_ADDRESS_P (symbol))\n \t{\n \t  decl = SYMBOL_REF_DECL (symbol);\n-\t  assemble_constant_contents (decl, XSTR (symbol, 0),\n-\t\t\t\t      get_constant_alignment (decl));\n-\t  offset += get_constant_size (decl);\n+\t  assemble_constant_contents (DECL_INITIAL (decl), XSTR (symbol, 0),\n+\t\t\t\t      DECL_ALIGN (decl));\n+\t  offset += get_constant_size (DECL_INITIAL (decl));\n \t}\n       else\n \t{"}]}