{"sha": "e956943eb103777c2b54ed46ec567f9f43595fd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk1Njk0M2ViMTAzNzc3YzJiNTRlZDQ2ZWM1NjdmOWY0MzU5NWZkNQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-06-01T12:41:18Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-06-01T12:41:18Z"}, "message": "Change use to type-based pool allocator in df-scan.c.\n\n\t* df-scan.c (struct df_scan_problem_data):Use new type-based pool allocator.\n\t(df_scan_free_internal) Likewise.\n\t(df_scan_alloc) Likewise.\n\t(df_grow_reg_info) Likewise.\n\t(df_free_ref) Likewise.\n\t(df_insn_create_insn_record) Likewise.\n\t(df_mw_hardreg_chain_delete) Likewise.\n\t(df_insn_info_delete) Likewise.\n\t(df_free_collection_rec) Likewise.\n\t(df_mw_hardreg_chain_delete_eq_uses) Likewise.\n\t(df_sort_and_compress_mws) Likewise.\n\t(df_ref_create_structure) Likewise.\n\t(df_ref_record) Likewise.\n\nFrom-SVN: r223954", "tree": {"sha": "091663fb9912cfb32060de95c3f57d6cedb50a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/091663fb9912cfb32060de95c3f57d6cedb50a95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e956943eb103777c2b54ed46ec567f9f43595fd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e956943eb103777c2b54ed46ec567f9f43595fd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e956943eb103777c2b54ed46ec567f9f43595fd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e956943eb103777c2b54ed46ec567f9f43595fd5/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "295e70472859075e8cc0c8b00ff1f13aac57a628", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/295e70472859075e8cc0c8b00ff1f13aac57a628", "html_url": "https://github.com/Rust-GCC/gccrs/commit/295e70472859075e8cc0c8b00ff1f13aac57a628"}], "stats": {"total": 110, "additions": 62, "deletions": 48}, "files": [{"sha": "68b507b4cab2e6ecd3bfeb7d794b5e7d1b2dad9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e956943eb103777c2b54ed46ec567f9f43595fd5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e956943eb103777c2b54ed46ec567f9f43595fd5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e956943eb103777c2b54ed46ec567f9f43595fd5", "patch": "@@ -1,3 +1,19 @@\n+2015-06-01  Martin Liska  <mliska@suse.cz>\n+\n+\t* df-scan.c (struct df_scan_problem_data):Use new type-based pool allocator.\n+\t(df_scan_free_internal) Likewise.\n+\t(df_scan_alloc) Likewise.\n+\t(df_grow_reg_info) Likewise.\n+\t(df_free_ref) Likewise.\n+\t(df_insn_create_insn_record) Likewise.\n+\t(df_mw_hardreg_chain_delete) Likewise.\n+\t(df_insn_info_delete) Likewise.\n+\t(df_free_collection_rec) Likewise.\n+\t(df_mw_hardreg_chain_delete_eq_uses) Likewise.\n+\t(df_sort_and_compress_mws) Likewise.\n+\t(df_ref_create_structure) Likewise.\n+\t(df_ref_record) Likewise.\n+\n 2015-06-01  Martin Liska  <mliska@suse.cz>\n \n \t* df-problems.c (df_chain_create):Use new type-based pool allocator."}, {"sha": "4646bcf59c4d11c004cd29af0572be312b58ca0f", "filename": "gcc/df-scan.c", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e956943eb103777c2b54ed46ec567f9f43595fd5/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e956943eb103777c2b54ed46ec567f9f43595fd5/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=e956943eb103777c2b54ed46ec567f9f43595fd5", "patch": "@@ -159,15 +159,18 @@ static const unsigned int copy_all = copy_defs | copy_uses | copy_eq_uses\n    it gets run.  It also has no need for the iterative solver.\n ----------------------------------------------------------------------------*/\n \n+#define SCAN_PROBLEM_DATA_BLOCK_SIZE 512\n+\n /* Problem data for the scanning dataflow function.  */\n struct df_scan_problem_data\n {\n-  alloc_pool ref_base_pool;\n-  alloc_pool ref_artificial_pool;\n-  alloc_pool ref_regular_pool;\n-  alloc_pool insn_pool;\n-  alloc_pool reg_pool;\n-  alloc_pool mw_reg_pool;\n+  pool_allocator<df_base_ref> *ref_base_pool;\n+  pool_allocator<df_artificial_ref> *ref_artificial_pool;\n+  pool_allocator<df_regular_ref> *ref_regular_pool;\n+  pool_allocator<df_insn_info> *insn_pool;\n+  pool_allocator<df_reg_info> *reg_pool;\n+  pool_allocator<df_mw_hardreg> *mw_reg_pool;\n+\n   bitmap_obstack reg_bitmaps;\n   bitmap_obstack insn_bitmaps;\n };\n@@ -218,12 +221,12 @@ df_scan_free_internal (void)\n   bitmap_clear (&df->insns_to_rescan);\n   bitmap_clear (&df->insns_to_notes_rescan);\n \n-  free_alloc_pool (problem_data->ref_base_pool);\n-  free_alloc_pool (problem_data->ref_artificial_pool);\n-  free_alloc_pool (problem_data->ref_regular_pool);\n-  free_alloc_pool (problem_data->insn_pool);\n-  free_alloc_pool (problem_data->reg_pool);\n-  free_alloc_pool (problem_data->mw_reg_pool);\n+  delete problem_data->ref_base_pool;\n+  delete problem_data->ref_artificial_pool;\n+  delete problem_data->ref_regular_pool;\n+  delete problem_data->insn_pool;\n+  delete problem_data->reg_pool;\n+  delete problem_data->mw_reg_pool;\n   bitmap_obstack_release (&problem_data->reg_bitmaps);\n   bitmap_obstack_release (&problem_data->insn_bitmaps);\n   free (df_scan->problem_data);\n@@ -264,7 +267,6 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   struct df_scan_problem_data *problem_data;\n   unsigned int insn_num = get_max_uid () + 1;\n-  unsigned int block_size = 512;\n   basic_block bb;\n \n   /* Given the number of pools, this is really faster than tearing\n@@ -276,24 +278,18 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   df_scan->problem_data = problem_data;\n   df_scan->computed = true;\n \n-  problem_data->ref_base_pool\n-    = create_alloc_pool (\"df_scan ref base\",\n-\t\t\t sizeof (struct df_base_ref), block_size);\n-  problem_data->ref_artificial_pool\n-    = create_alloc_pool (\"df_scan ref artificial\",\n-\t\t\t sizeof (struct df_artificial_ref), block_size);\n-  problem_data->ref_regular_pool\n-    = create_alloc_pool (\"df_scan ref regular\",\n-\t\t\t sizeof (struct df_regular_ref), block_size);\n-  problem_data->insn_pool\n-    = create_alloc_pool (\"df_scan insn\",\n-\t\t\t sizeof (struct df_insn_info), block_size);\n-  problem_data->reg_pool\n-    = create_alloc_pool (\"df_scan reg\",\n-\t\t\t sizeof (struct df_reg_info), block_size);\n-  problem_data->mw_reg_pool\n-    = create_alloc_pool (\"df_scan mw_reg\",\n-\t\t\t sizeof (struct df_mw_hardreg), block_size / 16);\n+  problem_data->ref_base_pool = new pool_allocator<df_base_ref>\n+    (\"df_scan ref base\", SCAN_PROBLEM_DATA_BLOCK_SIZE);\n+  problem_data->ref_artificial_pool = new pool_allocator<df_artificial_ref>\n+    (\"df_scan ref artificial\", SCAN_PROBLEM_DATA_BLOCK_SIZE);\n+  problem_data->ref_regular_pool = new pool_allocator<df_regular_ref>\n+    (\"df_scan ref regular\", SCAN_PROBLEM_DATA_BLOCK_SIZE);\n+  problem_data->insn_pool = new pool_allocator<df_insn_info>\n+    (\"df_scan insn\", SCAN_PROBLEM_DATA_BLOCK_SIZE);\n+  problem_data->reg_pool = new pool_allocator<df_reg_info>\n+    (\"df_scan reg\", SCAN_PROBLEM_DATA_BLOCK_SIZE);\n+  problem_data->mw_reg_pool = new pool_allocator<df_mw_hardreg>\n+    (\"df_scan mw_reg\", SCAN_PROBLEM_DATA_BLOCK_SIZE / 16);\n \n   bitmap_obstack_initialize (&problem_data->reg_bitmaps);\n   bitmap_obstack_initialize (&problem_data->insn_bitmaps);\n@@ -519,13 +515,14 @@ df_grow_reg_info (void)\n     {\n       struct df_reg_info *reg_info;\n \n-      reg_info = (struct df_reg_info *) pool_alloc (problem_data->reg_pool);\n+      // TODO\n+      reg_info = problem_data->reg_pool->allocate ();\n       memset (reg_info, 0, sizeof (struct df_reg_info));\n       df->def_regs[i] = reg_info;\n-      reg_info = (struct df_reg_info *) pool_alloc (problem_data->reg_pool);\n+      reg_info = problem_data->reg_pool->allocate ();\n       memset (reg_info, 0, sizeof (struct df_reg_info));\n       df->use_regs[i] = reg_info;\n-      reg_info = (struct df_reg_info *) pool_alloc (problem_data->reg_pool);\n+      reg_info = problem_data->reg_pool->allocate ();\n       memset (reg_info, 0, sizeof (struct df_reg_info));\n       df->eq_use_regs[i] = reg_info;\n       df->def_info.begin[i] = 0;\n@@ -740,15 +737,17 @@ df_free_ref (df_ref ref)\n   switch (DF_REF_CLASS (ref))\n     {\n     case DF_REF_BASE:\n-      pool_free (problem_data->ref_base_pool, ref);\n+      problem_data->ref_base_pool->remove ((df_base_ref *) (ref));\n       break;\n \n     case DF_REF_ARTIFICIAL:\n-      pool_free (problem_data->ref_artificial_pool, ref);\n+      problem_data->ref_artificial_pool->remove\n+\t((df_artificial_ref *) (ref));\n       break;\n \n     case DF_REF_REGULAR:\n-      pool_free (problem_data->ref_regular_pool, ref);\n+      problem_data->ref_regular_pool->remove\n+\t((df_regular_ref *) (ref));\n       break;\n     }\n }\n@@ -851,7 +850,7 @@ df_insn_create_insn_record (rtx_insn *insn)\n   insn_rec = DF_INSN_INFO_GET (insn);\n   if (!insn_rec)\n     {\n-      insn_rec = (struct df_insn_info *) pool_alloc (problem_data->insn_pool);\n+      insn_rec = problem_data->insn_pool->allocate ();\n       DF_INSN_INFO_SET (insn, insn_rec);\n     }\n   memset (insn_rec, 0, sizeof (struct df_insn_info));\n@@ -899,7 +898,7 @@ df_mw_hardreg_chain_delete (struct df_mw_hardreg *hardregs)\n   for (; hardregs; hardregs = next)\n     {\n       next = DF_MWS_NEXT (hardregs);\n-      pool_free (problem_data->mw_reg_pool, hardregs);\n+      problem_data->mw_reg_pool->remove (hardregs);\n     }\n }\n \n@@ -940,7 +939,7 @@ df_insn_info_delete (unsigned int uid)\n       df_ref_chain_delete (insn_info->uses);\n       df_ref_chain_delete (insn_info->eq_uses);\n \n-      pool_free (problem_data->insn_pool, insn_info);\n+      problem_data->insn_pool->remove (insn_info);\n       DF_INSN_UID_SET (uid, NULL);\n     }\n }\n@@ -1024,7 +1023,7 @@ df_free_collection_rec (struct df_collection_rec *collection_rec)\n   FOR_EACH_VEC_ELT (collection_rec->eq_use_vec, ix, ref)\n     df_free_ref (ref);\n   FOR_EACH_VEC_ELT (collection_rec->mw_vec, ix, mw)\n-    pool_free (problem_data->mw_reg_pool, mw);\n+    problem_data->mw_reg_pool->remove (mw);\n \n   collection_rec->def_vec.release ();\n   collection_rec->use_vec.release ();\n@@ -1949,7 +1948,7 @@ df_mw_hardreg_chain_delete_eq_uses (struct df_insn_info *insn_info)\n       if (mw->flags & DF_REF_IN_NOTE)\n \t{\n \t  *mw_ptr = DF_MWS_NEXT (mw);\n-\t  pool_free (problem_data->mw_reg_pool, mw);\n+\t  problem_data->mw_reg_pool->remove (mw);\n \t}\n       else\n \tmw_ptr = &DF_MWS_NEXT (mw);\n@@ -2296,8 +2295,7 @@ df_sort_and_compress_mws (vec<df_mw_hardreg_ptr, va_heap> *mw_vec)\n       while (i + dist + 1 < count\n \t     && df_mw_equal_p ((*mw_vec)[i], (*mw_vec)[i + dist + 1]))\n \t{\n-\t  pool_free (problem_data->mw_reg_pool,\n-\t\t     (*mw_vec)[i + dist + 1]);\n+\t  problem_data->mw_reg_pool->remove ((*mw_vec)[i + dist + 1]);\n \t  dist++;\n \t}\n       /* Copy it down to the next position.  */\n@@ -2525,18 +2523,18 @@ df_ref_create_structure (enum df_ref_class cl,\n   switch (cl)\n     {\n     case DF_REF_BASE:\n-      this_ref = (df_ref) pool_alloc (problem_data->ref_base_pool);\n+      this_ref = (df_ref) (problem_data->ref_base_pool->allocate ());\n       gcc_checking_assert (loc == NULL);\n       break;\n \n     case DF_REF_ARTIFICIAL:\n-      this_ref = (df_ref) pool_alloc (problem_data->ref_artificial_pool);\n+      this_ref = (df_ref) (problem_data->ref_artificial_pool->allocate ());\n       this_ref->artificial_ref.bb = bb;\n       gcc_checking_assert (loc == NULL);\n       break;\n \n     case DF_REF_REGULAR:\n-      this_ref = (df_ref) pool_alloc (problem_data->ref_regular_pool);\n+      this_ref = (df_ref) (problem_data->ref_regular_pool->allocate ());\n       this_ref->regular_ref.loc = loc;\n       gcc_checking_assert (loc);\n       break;\n@@ -2638,7 +2636,7 @@ df_ref_record (enum df_ref_class cl,\n \t    ref_flags |= DF_REF_PARTIAL;\n \t  ref_flags |= DF_REF_MW_HARDREG;\n \n-\t  hardreg = (struct df_mw_hardreg *) pool_alloc (problem_data->mw_reg_pool);\n+\t  hardreg = problem_data->mw_reg_pool->allocate ();\n \t  hardreg->type = ref_type;\n \t  hardreg->flags = ref_flags;\n \t  hardreg->mw_reg = reg;"}]}