{"sha": "ce6bfa50fa3131aea4b3506f2fd5fe0f5274840c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U2YmZhNTBmYTMxMzFhZWE0YjM1MDZmMmZkNWZlMGY1Mjc0ODQwYw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-08-08T11:40:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-08T11:40:08Z"}, "message": "tree-vrp.c (extract_range_from_unary_expr_1): New function, split out from ...\n\n2011-08-08  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (extract_range_from_unary_expr_1): New function,\n\tsplit out from ...\n\t(extract_range_from_unary_expr): ... here.  Handle BIT_NOT_EXPR\n\tby composition.\n\nFrom-SVN: r177558", "tree": {"sha": "65f12fa4abf6003772f92f847e92544f5feb030e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65f12fa4abf6003772f92f847e92544f5feb030e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce6bfa50fa3131aea4b3506f2fd5fe0f5274840c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce6bfa50fa3131aea4b3506f2fd5fe0f5274840c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce6bfa50fa3131aea4b3506f2fd5fe0f5274840c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce6bfa50fa3131aea4b3506f2fd5fe0f5274840c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "daae4650a99b2950d3ce823b1dd60840130c1fe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daae4650a99b2950d3ce823b1dd60840130c1fe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daae4650a99b2950d3ce823b1dd60840130c1fe1"}], "stats": {"total": 106, "additions": 60, "deletions": 46}, "files": [{"sha": "3e0391e26b3cb6af0bede05156c2d9b3a3207a9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce6bfa50fa3131aea4b3506f2fd5fe0f5274840c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce6bfa50fa3131aea4b3506f2fd5fe0f5274840c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce6bfa50fa3131aea4b3506f2fd5fe0f5274840c", "patch": "@@ -1,3 +1,10 @@\n+2011-08-08  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (extract_range_from_unary_expr_1): New function,\n+\tsplit out from ...\n+\t(extract_range_from_unary_expr): ... here.  Handle BIT_NOT_EXPR\n+\tby composition.\n+\n 2011-08-08  Mikael Pettersson  <mikpe@it.uu.se>\n \n \tPR tree-optimization/50005"}, {"sha": "2eeb3790984ea39e498b624c275cdcd5daa20d23", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce6bfa50fa3131aea4b3506f2fd5fe0f5274840c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce6bfa50fa3131aea4b3506f2fd5fe0f5274840c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=ce6bfa50fa3131aea4b3506f2fd5fe0f5274840c", "patch": "@@ -2805,60 +2805,40 @@ extract_range_from_binary_expr (value_range_t *vr,\n   extract_range_from_binary_expr_1 (vr, code, expr_type, &vr0, &vr1);\n }\n \n-/* Extract range information from a unary expression EXPR based on\n-   the range of its operand and the expression code.  */\n+/* Extract range information from a unary operation CODE based on\n+   the range of its operand *VR0 with type OP0_TYPE with resulting type TYPE.\n+   The The resulting range is stored in *VR.  */\n \n static void\n-extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n-\t\t\t       tree type, tree op0)\n+extract_range_from_unary_expr_1 (value_range_t *vr,\n+\t\t\t\t enum tree_code code, tree type,\n+\t\t\t\t value_range_t *vr0_, tree op0_type)\n {\n+  value_range_t vr0 = *vr0_;\n   tree min, max;\n   int cmp;\n-  value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+\n+  /* If VR0 is UNDEFINED, so is the result.  */\n+  if (vr0.type == VR_UNDEFINED)\n+    {\n+      set_value_range_to_undefined (vr);\n+      return;\n+    }\n \n   /* Refuse to operate on certain unary expressions for which we\n      cannot easily determine a resulting range.  */\n   if (code == FIX_TRUNC_EXPR\n       || code == FLOAT_EXPR\n-      || code == BIT_NOT_EXPR\n       || code == CONJ_EXPR)\n     {\n-      /* We can still do constant propagation here.  */\n-      if ((op0 = op_with_constant_singleton_value_range (op0)) != NULL_TREE)\n-\t{\n-\t  tree tem = fold_unary (code, type, op0);\n-\t  if (tem\n-\t      && is_gimple_min_invariant (tem)\n-\t      && !is_overflow_infinity (tem))\n-\t    {\n-\t      set_value_range (vr, VR_RANGE, tem, tem, NULL);\n-\t      return;\n-\t    }\n-\t}\n       set_value_range_to_varying (vr);\n       return;\n     }\n \n-  /* Get value ranges for the operand.  For constant operands, create\n-     a new value range with the operand to simplify processing.  */\n-  if (TREE_CODE (op0) == SSA_NAME)\n-    vr0 = *(get_value_range (op0));\n-  else if (is_gimple_min_invariant (op0))\n-    set_value_range_to_value (&vr0, op0, NULL);\n-  else\n-    set_value_range_to_varying (&vr0);\n-\n-  /* If VR0 is UNDEFINED, so is the result.  */\n-  if (vr0.type == VR_UNDEFINED)\n-    {\n-      set_value_range_to_undefined (vr);\n-      return;\n-    }\n-\n   /* Refuse to operate on symbolic ranges, or if neither operand is\n      a pointer or integral type.  */\n-  if ((!INTEGRAL_TYPE_P (TREE_TYPE (op0))\n-       && !POINTER_TYPE_P (TREE_TYPE (op0)))\n+  if ((!INTEGRAL_TYPE_P (op0_type)\n+       && !POINTER_TYPE_P (op0_type))\n       || (vr0.type != VR_VARYING\n \t  && symbolic_range_p (&vr0)))\n     {\n@@ -2868,29 +2848,23 @@ extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n \n   /* If the expression involves pointers, we are only interested in\n      determining if it evaluates to NULL [0, 0] or non-NULL (~[0, 0]).  */\n-  if (POINTER_TYPE_P (type) || POINTER_TYPE_P (TREE_TYPE (op0)))\n+  if (POINTER_TYPE_P (type) || POINTER_TYPE_P (op0_type))\n     {\n-      bool sop;\n-\n-      sop = false;\n-      if (range_is_nonnull (&vr0)\n-\t  || (tree_unary_nonzero_warnv_p (code, type, op0, &sop)\n-\t      && !sop))\n+      if (range_is_nonnull (&vr0))\n \tset_value_range_to_nonnull (vr, type);\n       else if (range_is_null (&vr0))\n \tset_value_range_to_null (vr, type);\n       else\n \tset_value_range_to_varying (vr);\n-\n       return;\n     }\n \n   /* Handle unary expressions on integer ranges.  */\n   if (CONVERT_EXPR_CODE_P (code)\n       && INTEGRAL_TYPE_P (type)\n-      && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n+      && INTEGRAL_TYPE_P (op0_type))\n     {\n-      tree inner_type = TREE_TYPE (op0);\n+      tree inner_type = op0_type;\n       tree outer_type = type;\n \n       /* If VR0 is varying and we increase the type precision, assume\n@@ -3146,6 +3120,16 @@ extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n \t    }\n \t}\n     }\n+  else if (code == BIT_NOT_EXPR)\n+    {\n+      /* ~X is simply -1 - X, so re-use existing code that also handles\n+         anti-ranges fine.  */\n+      value_range_t minusone = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+      set_value_range_to_value (&minusone, build_int_cst (type, -1), NULL);\n+      extract_range_from_binary_expr_1 (vr, MINUS_EXPR,\n+\t\t\t\t\ttype, &minusone, &vr0);\n+      return;\n+    }\n   else\n     {\n       /* Otherwise, operate on each end of the range.  */\n@@ -3212,6 +3196,29 @@ extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n }\n \n \n+/* Extract range information from a unary expression CODE OP0 based on\n+   the range of its operand with resulting type TYPE.\n+   The resulting range is stored in *VR.  */\n+\n+static void\n+extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n+\t\t\t       tree type, tree op0)\n+{\n+  value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+\n+  /* Get value ranges for the operand.  For constant operands, create\n+     a new value range with the operand to simplify processing.  */\n+  if (TREE_CODE (op0) == SSA_NAME)\n+    vr0 = *(get_value_range (op0));\n+  else if (is_gimple_min_invariant (op0))\n+    set_value_range_to_value (&vr0, op0, NULL);\n+  else\n+    set_value_range_to_varying (&vr0);\n+\n+  extract_range_from_unary_expr_1 (vr, code, type, &vr0, TREE_TYPE (op0));\n+}\n+\n+\n /* Extract range information from a conditional expression EXPR based on\n    the ranges of each of its operands and the expression code.  */\n "}]}