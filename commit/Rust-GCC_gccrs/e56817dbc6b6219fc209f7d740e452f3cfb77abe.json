{"sha": "e56817dbc6b6219fc209f7d740e452f3cfb77abe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU2ODE3ZGJjNmI2MjE5ZmMyMDlmN2Q3NDBlNDUyZjNjZmI3N2FiZQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-09-30T20:45:07Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-09-30T20:45:07Z"}, "message": "resolve.c (check_typebound_baseobject): Don't check for abstract types for CLASS.\n\nfortran/\n2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n\n        * resolve.c (check_typebound_baseobject): Don't check for\n        abstract types for CLASS.\n        (resolve_class_assign): Adapt for RHS being a CLASS.\n        * trans-intrinsic.c (gfc_conv_associated): Add component ref\n        if expr is a CLASS.\n\ntestsuite/\n2009-09-30  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/select_type_4.f90: New test.\n\nFrom-SVN: r152346", "tree": {"sha": "810a3eb7f5ed1d7d3752ab8b18044d6423f8e5a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/810a3eb7f5ed1d7d3752ab8b18044d6423f8e5a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e56817dbc6b6219fc209f7d740e452f3cfb77abe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e56817dbc6b6219fc209f7d740e452f3cfb77abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e56817dbc6b6219fc209f7d740e452f3cfb77abe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e56817dbc6b6219fc209f7d740e452f3cfb77abe/comments", "author": null, "committer": null, "parents": [{"sha": "cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf2b3c22a2cbd7f50db530ca9d2b14c70ba0359d"}], "stats": {"total": 237, "additions": 215, "deletions": 22}, "files": [{"sha": "9318bae93a5c3672351880174589cc86ba93133f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56817dbc6b6219fc209f7d740e452f3cfb77abe/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56817dbc6b6219fc209f7d740e452f3cfb77abe/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e56817dbc6b6219fc209f7d740e452f3cfb77abe", "patch": "@@ -1,3 +1,11 @@\n+2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* resolve.c (check_typebound_baseobject): Don't check for\n+\tabstract types for CLASS.\n+\t(resolve_class_assign): Adapt for RHS being a CLASS.\n+\t* trans-intrinsic.c (gfc_conv_associated): Add component ref\n+\tif expr is a CLASS.\n+\n 2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n \n \t* check.c (gfc_check_same_type_as): New function for checking"}, {"sha": "bb803b3475c3150003531e6af585c1fcaed247a8", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56817dbc6b6219fc209f7d740e452f3cfb77abe/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56817dbc6b6219fc209f7d740e452f3cfb77abe/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e56817dbc6b6219fc209f7d740e452f3cfb77abe", "patch": "@@ -4851,7 +4851,8 @@ check_typebound_baseobject (gfc_expr* e)\n     return FAILURE;\n \n   gcc_assert (base->ts.type == BT_DERIVED || base->ts.type == BT_CLASS);\n-  if (base->ts.u.derived->attr.abstract)\n+\n+  if (base->ts.type == BT_DERIVED && base->ts.u.derived->attr.abstract)\n     {\n       gfc_error (\"Base object for type-bound procedure call at %L is of\"\n \t\t \" ABSTRACT type '%s'\", &e->where, base->ts.u.derived->name);\n@@ -7298,30 +7299,34 @@ resolve_class_assign (gfc_code *code)\n {\n   gfc_code *assign_code = gfc_get_code ();\n \n-  /* Insert an additional assignment which sets the vindex.  */\n-  assign_code->next = code->next;\n-  code->next = assign_code;\n-  assign_code->op = EXEC_ASSIGN;\n-  assign_code->expr1 = gfc_copy_expr (code->expr1);\n-  gfc_add_component_ref (assign_code->expr1, \"$vindex\");\n-  if (code->expr2->ts.type == BT_DERIVED)\n-    /* vindex is constant, determined at compile time.  */\n-    assign_code->expr2 = gfc_int_expr (code->expr2->ts.u.derived->vindex);\n-  else if (code->expr2->ts.type == BT_CLASS)\n-    {\n-      /* vindex must be determined at run time.  */\n-      assign_code->expr2 = gfc_copy_expr (code->expr2);\n-      gfc_add_component_ref (assign_code->expr2, \"$vindex\");\n-    }\n-  else if (code->expr2->expr_type == EXPR_NULL)\n-    assign_code->expr2 = gfc_int_expr (0);\n-  else\n-    gcc_unreachable ();\n+  if (code->expr2->ts.type != BT_CLASS)\n+    {\n+      /* Insert an additional assignment which sets the vindex.  */\n+      assign_code->next = code->next;\n+      code->next = assign_code;\n+      assign_code->op = EXEC_ASSIGN;\n+      assign_code->expr1 = gfc_copy_expr (code->expr1);\n+      gfc_add_component_ref (assign_code->expr1, \"$vindex\");\n+      if (code->expr2->ts.type == BT_DERIVED)\n+\t/* vindex is constant, determined at compile time.  */\n+\tassign_code->expr2 = gfc_int_expr (code->expr2->ts.u.derived->vindex);\n+      else if (code->expr2->ts.type == BT_CLASS)\n+\t{\n+\t  /* vindex must be determined at run time.  */\n+\t  assign_code->expr2 = gfc_copy_expr (code->expr2);\n+\t  gfc_add_component_ref (assign_code->expr2, \"$vindex\");\n+\t}\n+      else if (code->expr2->expr_type == EXPR_NULL)\n+\tassign_code->expr2 = gfc_int_expr (0);\n+      else\n+\tgcc_unreachable ();\n+    }\n \n   /* Modify the actual pointer assignment.  */\n-  gfc_add_component_ref (code->expr1, \"$data\");\n   if (code->expr2->ts.type == BT_CLASS)\n-    gfc_add_component_ref (code->expr2, \"$data\");\n+    code->op = EXEC_ASSIGN;\n+  else\n+    gfc_add_component_ref (code->expr1, \"$data\");\n }\n \n "}, {"sha": "1e7b35f5c1789ce8b77b9b1c929195dd3178724e", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56817dbc6b6219fc209f7d740e452f3cfb77abe/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56817dbc6b6219fc209f7d740e452f3cfb77abe/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=e56817dbc6b6219fc209f7d740e452f3cfb77abe", "patch": "@@ -4608,6 +4608,8 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n   gfc_init_se (&arg1se, NULL);\n   gfc_init_se (&arg2se, NULL);\n   arg1 = expr->value.function.actual;\n+  if (arg1->expr->ts.type == BT_CLASS)\n+    gfc_add_component_ref (arg1->expr, \"$data\");\n   arg2 = arg1->next;\n   ss1 = gfc_walk_expr (arg1->expr);\n "}, {"sha": "671f37a47e11668249d32b4ef38541a22a284ddf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56817dbc6b6219fc209f7d740e452f3cfb77abe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56817dbc6b6219fc209f7d740e452f3cfb77abe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e56817dbc6b6219fc209f7d740e452f3cfb77abe", "patch": "@@ -1,3 +1,7 @@\n+2009-09-30  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/select_type_4.f90: New test.\n+\n 2009-09-30  Janus Weil  <janus@gcc.gnu.org>\n \n \t* gfortran.dg/same_type_as_1.f03: New test."}, {"sha": "7e12d935447835a95bc8b02b6e4dc9fb10b0115e", "filename": "gcc/testsuite/gfortran.dg/select_type_4.f90", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56817dbc6b6219fc209f7d740e452f3cfb77abe/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56817dbc6b6219fc209f7d740e452f3cfb77abe/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_4.f90?ref=e56817dbc6b6219fc209f7d740e452f3cfb77abe", "patch": "@@ -0,0 +1,174 @@\n+! { dg-do run }\n+!\n+! Contributed by by Richard Maine\n+! http://coding.derkeiler.com/Archive/Fortran/comp.lang.fortran/2006-10/msg00104.html\n+!\n+module poly_list \n+\n+  !--  Polymorphic lists using type extension. \n+\n+  implicit none \n+\n+  type, public :: node_type \n+    private \n+    class(node_type), pointer :: next => null() \n+  end type node_type \n+\n+  type, public :: list_type \n+    private \n+    class(node_type), pointer :: head => null(), tail => null() \n+  end type list_type \n+\n+contains \n+\n+  subroutine append_node (list, new_node) \n+\n+    !-- Append a node to a list. \n+    !-- Caller is responsible for allocating the node. \n+\n+    !---------- interface. \n+\n+    type(list_type), intent(inout) :: list \n+    class(node_type), target :: new_node \n+\n+    !---------- executable code. \n+\n+    if (.not.associated(list%head)) list%head => new_node \n+    if (associated(list%tail)) list%tail%next => new_node \n+    list%tail => new_node \n+    return \n+  end subroutine append_node \n+\n+  function first_node (list) \n+\n+    !-- Get the first node of a list. \n+\n+    !---------- interface. \n+\n+    type(list_type), intent(in) :: list \n+    class(node_type), pointer :: first_node \n+\n+    !---------- executable code. \n+\n+    first_node => list%head \n+    return \n+  end function first_node \n+\n+  function next_node (node) \n+\n+    !-- Step to the next node of a list. \n+\n+    !---------- interface. \n+\n+    class(node_type), target :: node \n+    class(node_type), pointer :: next_node \n+\n+    !---------- executable code. \n+\n+    next_node => node%next \n+    return \n+  end function next_node \n+\n+  subroutine destroy_list (list) \n+\n+    !-- Delete (and deallocate) all the nodes of a list. \n+\n+    !---------- interface. \n+    type(list_type), intent(inout) :: list \n+\n+    !---------- local. \n+    class(node_type), pointer :: node, next \n+\n+    !---------- executable code. \n+\n+    node => list%head \n+    do while (associated(node)) \n+      next => node%next \n+      deallocate(node) \n+      node => next \n+    end do \n+    nullify(list%head, list%tail) \n+    return \n+  end subroutine destroy_list \n+\n+end module poly_list \n+\n+program main \n+\n+  use poly_list \n+\n+  implicit none \n+  integer :: cnt\n+\n+  type, extends(node_type) :: real_node_type \n+    real :: x \n+  end type real_node_type \n+\n+  type, extends(node_type) :: integer_node_type \n+    integer :: i \n+  end type integer_node_type \n+\n+  type, extends(node_type) :: character_node_type \n+    character(1) :: c \n+  end type character_node_type \n+\n+  type(list_type) :: list \n+  class(node_type), pointer :: node \n+  type(integer_node_type), pointer :: integer_node \n+  type(real_node_type), pointer :: real_node \n+  type(character_node_type), pointer :: character_node \n+\n+  !---------- executable code. \n+\n+  !----- Build the list. \n+\n+  allocate(real_node) \n+  real_node%x = 1.23 \n+  call append_node(list, real_node) \n+\n+  allocate(integer_node) \n+  integer_node%i = 42 \n+  call append_node(list, integer_node) \n+\n+  allocate(node) \n+  call append_node(list, node) \n+\n+  allocate(character_node) \n+  character_node%c = \"z\" \n+  call append_node(list, character_node) \n+\n+  allocate(real_node) \n+  real_node%x = 4.56 \n+  call append_node(list, real_node) \n+\n+  !----- Retrieve from it. \n+\n+  node => first_node(list) \n+\n+  cnt = 0\n+  do while (associated(node)) \n+    cnt = cnt + 1\n+    select type (node) \n+      type is (real_node_type) \n+        write (*,*) node%x\n+        if (.not.(     (cnt == 1 .and. node%x == 1.23)   &\n+                  .or. (cnt == 5 .and. node%x == 4.56))) then\n+          call abort()\n+        end if\n+      type is (integer_node_type) \n+        write (*,*) node%i\n+        if (cnt /= 2 .or. node%i /= 42) call abort()\n+      type is (node_type) \n+        write (*,*) \"Node with no data.\"\n+        if (cnt /= 3) call abort()\n+      class default \n+        Write (*,*) \"Some other node type.\"\n+        if (cnt /= 4) call abort()\n+    end select \n+\n+    node => next_node(node) \n+  end do \n+  if (cnt /= 5) call abort()\n+  call destroy_list(list) \n+  stop \n+end program main "}]}