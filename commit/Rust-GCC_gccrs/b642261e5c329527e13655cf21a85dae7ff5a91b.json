{"sha": "b642261e5c329527e13655cf21a85dae7ff5a91b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY0MjI2MWU1YzMyOTUyN2UxMzY1NWNmMjFhODVkYWU3ZmY1YTkxYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-07-29T23:57:52Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-07-29T23:57:52Z"}, "message": "unroll.c (verify_addresses): Remove.\n\n        * unroll.c (verify_addresses): Remove.\n        (find_splittable_givs): Never split DEST_ADDR givs.\n\nFrom-SVN: r55858", "tree": {"sha": "3c84b2e7aa58404e733c532638e207c0401f11b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c84b2e7aa58404e733c532638e207c0401f11b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b642261e5c329527e13655cf21a85dae7ff5a91b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b642261e5c329527e13655cf21a85dae7ff5a91b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b642261e5c329527e13655cf21a85dae7ff5a91b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b642261e5c329527e13655cf21a85dae7ff5a91b/comments", "author": null, "committer": null, "parents": [{"sha": "cba57c9d40057fa78efc9a404ab4ae7101a59dcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba57c9d40057fa78efc9a404ab4ae7101a59dcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba57c9d40057fa78efc9a404ab4ae7101a59dcb"}], "stats": {"total": 139, "additions": 7, "deletions": 132}, "files": [{"sha": "9f29a385b8806ee467c5c32f4c428aed997d174a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b642261e5c329527e13655cf21a85dae7ff5a91b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b642261e5c329527e13655cf21a85dae7ff5a91b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b642261e5c329527e13655cf21a85dae7ff5a91b", "patch": "@@ -1,3 +1,8 @@\n+2002-07-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* unroll.c (verify_addresses): Remove.\n+\t(find_splittable_givs): Never split DEST_ADDR givs.\n+\n 2002-07-29  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* doc/gty.texi (GGC Roots): Clarify that the list of syntaxes"}, {"sha": "85fd5d23e30ee0eca7290e4c8bd03a9815d1bba2", "filename": "gcc/unroll.c", "status": "modified", "additions": 2, "deletions": 132, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b642261e5c329527e13655cf21a85dae7ff5a91b/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b642261e5c329527e13655cf21a85dae7ff5a91b/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=b642261e5c329527e13655cf21a85dae7ff5a91b", "patch": "@@ -207,7 +207,6 @@ static int find_splittable_givs PARAMS ((const struct loop *,\n \t\t\t\t\t rtx, int));\n static int reg_dead_after_loop PARAMS ((const struct loop *, rtx));\n static rtx fold_rtx_mult_add PARAMS ((rtx, rtx, rtx, enum machine_mode));\n-static int verify_addresses PARAMS ((struct induction *, rtx, int));\n static rtx remap_split_bivs PARAMS ((struct loop *, rtx));\n static rtx find_common_reg_term PARAMS ((rtx, rtx));\n static rtx subtract_reg_term PARAMS ((rtx, rtx));\n@@ -2607,35 +2606,6 @@ find_splittable_regs (loop, unroll_type, unroll_number)\n   return result;\n }\n \n-/* Return 1 if the first and last unrolled copy of the address giv V is valid\n-   for the instruction that is using it.  Do not make any changes to that\n-   instruction.  */\n-\n-static int\n-verify_addresses (v, giv_inc, unroll_number)\n-     struct induction *v;\n-     rtx giv_inc;\n-     int unroll_number;\n-{\n-  int ret = 1;\n-  rtx orig_addr = *v->location;\n-  rtx last_addr = plus_constant (v->dest_reg,\n-\t\t\t\t INTVAL (giv_inc) * (unroll_number - 1));\n-\n-  /* First check to see if either address would fail.   Handle the fact\n-     that we have may have a match_dup.  */\n-  if (! validate_replace_rtx (*v->location, v->dest_reg, v->insn)\n-      || ! validate_replace_rtx (*v->location, last_addr, v->insn))\n-    ret = 0;\n-\n-  /* Now put things back the way they were before.  This should always\n-   succeed.  */\n-  if (! validate_replace_rtx (*v->location, orig_addr, v->insn))\n-    abort ();\n-\n-  return ret;\n-}\n-\n /* For every giv based on the biv BL, check to determine whether it is\n    splittable.  This is a subroutine to find_splittable_regs ().\n \n@@ -2647,7 +2617,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n      struct iv_class *bl;\n      enum unroll_types unroll_type;\n      rtx increment;\n-     int unroll_number;\n+     int unroll_number ATTRIBUTE_UNUSED;\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct induction *v, *v2;\n@@ -2818,107 +2788,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t      splittable_regs[REGNO (v->new_reg)] = value;\n \t    }\n \t  else\n-\t    {\n-\t      /* Splitting address givs is useful since it will often allow us\n-\t\t to eliminate some increment insns for the base giv as\n-\t\t unnecessary.  */\n-\n-\t      /* If the addr giv is combined with a dest_reg giv, then all\n-\t\t references to that dest reg will be remapped, which is NOT\n-\t\t what we want for split addr regs. We always create a new\n-\t\t register for the split addr giv, just to be safe.  */\n-\n-\t      /* If we have multiple identical address givs within a\n-\t\t single instruction, then use a single pseudo reg for\n-\t\t both.  This is necessary in case one is a match_dup\n-\t\t of the other.  */\n-\n-\t      v->const_adjust = 0;\n-\n-\t      if (v->same_insn)\n-\t\t{\n-\t\t  v->dest_reg = v->same_insn->dest_reg;\n-\t\t  if (loop_dump_stream)\n-\t\t    fprintf (loop_dump_stream,\n-\t\t\t     \"Sharing address givs in insn %d\\n\",\n-\t\t\t     INSN_UID (v->insn));\n-\t\t}\n-\t      /* If multiple address GIVs have been combined with the\n-\t\t same dest_reg GIV, do not create a new register for\n-\t\t each.  */\n-\t      else if (unroll_type != UNROLL_COMPLETELY\n-\t\t       && v->giv_type == DEST_ADDR\n-\t\t       && v->same && v->same->giv_type == DEST_ADDR\n-\t\t       && v->same->unrolled\n-\t\t       /* combine_givs_p may return true for some cases\n-\t\t\t  where the add and mult values are not equal.\n-\t\t\t  To share a register here, the values must be\n-\t\t\t  equal.  */\n-\t\t       && rtx_equal_p (v->same->mult_val, v->mult_val)\n-\t\t       && rtx_equal_p (v->same->add_val, v->add_val)\n-\t\t       /* If the memory references have different modes,\n-\t\t\t  then the address may not be valid and we must\n-\t\t\t  not share registers.  */\n-\t\t       && verify_addresses (v, giv_inc, unroll_number))\n-\t\t{\n-\t\t  v->dest_reg = v->same->dest_reg;\n-\t\t  v->shared = 1;\n-\t\t}\n-\t      else if (unroll_type == UNROLL_COMPLETELY)\n-\t\t{\n-\t\t  v->dest_reg = value;\n-\n-\t\t  /* Check the resulting address for validity, and fail\n-\t\t     if the resulting address would be invalid.  */\n-\t\t  if (! verify_addresses (v, giv_inc, unroll_number))\n-\t\t    {\n-\t\t      for (v2 = v->next_iv; v2; v2 = v2->next_iv)\n-\t\t\tif (v2->same_insn == v)\n-\t\t\t  v2->same_insn = 0;\n-\n-\t\t      if (loop_dump_stream)\n-\t\t\tfprintf (loop_dump_stream,\n-\t\t\t\t \"Invalid address for giv at insn %d\\n\",\n-\t\t\t\t INSN_UID (v->insn));\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tcontinue;\n-\n-\t      /* Store the value of dest_reg into the insn.  This sharing\n-\t\t will not be a problem as this insn will always be copied\n-\t\t later.  */\n-\n-\t      *v->location = v->dest_reg;\n-\n-\t      /* If this address giv is combined with a dest reg giv, then\n-\t\t save the base giv's induction pointer so that we will be\n-\t\t able to handle this address giv properly.  The base giv\n-\t\t itself does not have to be splittable.  */\n-\n-\t      if (v->same && v->same->giv_type == DEST_REG)\n-\t\taddr_combined_regs[REGNO (v->same->new_reg)] = v->same;\n-\n-\t      if (GET_CODE (v->new_reg) == REG)\n-\t\t{\n-\t\t  /* This giv maybe hasn't been combined with any others.\n-\t\t     Make sure that it's giv is marked as splittable here.  */\n-\n-\t\t  splittable_regs[REGNO (v->new_reg)] = value;\n-\n-\t\t  /* Make it appear to depend upon itself, so that the\n-\t\t     giv will be properly split in the main loop above.  */\n-\t\t  if (! v->same)\n-\t\t    {\n-\t\t      v->same = v;\n-\t\t      addr_combined_regs[REGNO (v->new_reg)] = v;\n-\t\t    }\n-\t\t}\n-\n-\t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream, \"DEST_ADDR giv being split.\\n\");\n-\t    }\n+\t    continue;\n \t}\n       else\n \t{"}]}