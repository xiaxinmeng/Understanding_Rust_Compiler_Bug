{"sha": "732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMyZGFkOGYzMjE1MmVkN2NiYjJkNGNiOGJhMGZjMjFmNjA4ZmU3MA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2013-11-12T12:53:53Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2013-11-12T12:53:53Z"}, "message": "re PR rtl-optimization/10474 (shrink wrapping for functions)\n\n2013-11-12  Martin Jambor  <mjambor@suse.cz>\n\n\tPR rtl-optimization/10474\n\t* ira.c (interesting_dest_for_shprep): New function.\n\t(split_live_ranges_for_shrink_wrap): Likewise.\n\t(find_moveable_pseudos): Move calculation of dominance info,\n\tdf_analysios and the final anlyses to...\n\t(ira): ...here, call split_live_ranges_for_shrink_wrap.\n\ntestsuite/\n\t* gcc.dg/pr10474.c: New testcase.\n\t* gcc.dg/ira-shrinkwrap-prep-1.c: Likewise.\n\t* gcc.dg/ira-shrinkwrap-prep-2.c: Likewise.\n\nFrom-SVN: r204698", "tree": {"sha": "8204bc7db38fa0de22d6be0af6e5095e7e8aaf5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8204bc7db38fa0de22d6be0af6e5095e7e8aaf5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4c04ff0e8852321a12bd02c520cdecef5dc2ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7"}], "stats": {"total": 315, "additions": 304, "deletions": 11}, "files": [{"sha": "4a8b2e1fe978750df9c3faed93bfac377afedece", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70", "patch": "@@ -1,3 +1,12 @@\n+2013-11-12  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR rtl-optimization/10474\n+\t* ira.c (interesting_dest_for_shprep): New function.\n+\t(split_live_ranges_for_shrink_wrap): Likewise.\n+\t(find_moveable_pseudos): Move calculation of dominance info,\n+\tdf_analysios and the final anlyses to...\n+\t(ira): ...here, call split_live_ranges_for_shrink_wrap.\n+\n 2013-11-12  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (force_expr_to_var_cost): Refactor the code."}, {"sha": "2ef69cb5e6dab24c60a5d1125829a5540a8fc8cc", "filename": "gcc/ira.c", "status": "modified", "additions": 205, "deletions": 11, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70", "patch": "@@ -4515,9 +4515,6 @@ find_moveable_pseudos (void)\n   pseudo_replaced_reg.release ();\n   pseudo_replaced_reg.safe_grow_cleared (max_regs);\n \n-  df_analyze ();\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n   i = 0;\n   bitmap_initialize (&live, 0);\n   bitmap_initialize (&used, 0);\n@@ -4830,14 +4827,196 @@ find_moveable_pseudos (void)\n   free (bb_moveable_reg_sets);\n \n   last_moveable_pseudo = max_reg_num ();\n+}\n \n-  fix_reg_equiv_init ();\n-  expand_reg_info ();\n-  regstat_free_n_sets_and_refs ();\n-  regstat_free_ri ();\n-  regstat_init_n_sets_and_refs ();\n-  regstat_compute_ri ();\n-  free_dominance_info (CDI_DOMINATORS);\n+\n+/* If insn is interesting for parameter range-splitting shring-wrapping\n+   preparation, i.e. it is a single set from a hard register to a pseudo, which\n+   is live at CALL_DOM, return the destination.  Otherwise return NULL.  */\n+\n+static rtx\n+interesting_dest_for_shprep (rtx insn, basic_block call_dom)\n+{\n+  rtx set = single_set (insn);\n+  if (!set)\n+    return NULL;\n+  rtx src = SET_SRC (set);\n+  rtx dest = SET_DEST (set);\n+  if (!REG_P (src) || !HARD_REGISTER_P (src)\n+      || !REG_P (dest) || HARD_REGISTER_P (dest)\n+      || (call_dom && !bitmap_bit_p (df_get_live_in (call_dom), REGNO (dest))))\n+    return NULL;\n+  return dest;\n+}\n+\n+/* Split live ranges of pseudos that are loaded from hard registers in the\n+   first BB in a BB that dominates all non-sibling call if such a BB can be\n+   found and is not in a loop.  Return true if the function has made any\n+   changes.  */\n+\n+static bool\n+split_live_ranges_for_shrink_wrap (void)\n+{\n+  basic_block bb, call_dom = NULL;\n+  basic_block first = single_succ (ENTRY_BLOCK_PTR);\n+  rtx insn, last_interesting_insn = NULL;\n+  bitmap_head need_new, reachable;\n+  vec<basic_block> queue;\n+\n+  if (!flag_shrink_wrap)\n+    return false;\n+\n+  bitmap_initialize (&need_new, 0);\n+  bitmap_initialize (&reachable, 0);\n+  queue.create (n_basic_blocks);\n+\n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS (bb, insn)\n+      if (CALL_P (insn) && !SIBLING_CALL_P (insn))\n+\t{\n+\t  if (bb == first)\n+\t    {\n+\t      bitmap_clear (&need_new);\n+\t      bitmap_clear (&reachable);\n+\t      queue.release ();\n+\t      return false;\n+\t    }\n+\n+\t  bitmap_set_bit (&need_new, bb->index);\n+\t  bitmap_set_bit (&reachable, bb->index);\n+\t  queue.quick_push (bb);\n+\t  break;\n+\t}\n+\n+  if (queue.is_empty ())\n+    {\n+      bitmap_clear (&need_new);\n+      bitmap_clear (&reachable);\n+      queue.release ();\n+      return false;\n+    }\n+\n+  while (!queue.is_empty ())\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      bb = queue.pop ();\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (e->dest != EXIT_BLOCK_PTR\n+\t    && bitmap_set_bit (&reachable, e->dest->index))\n+\t  queue.quick_push (e->dest);\n+    }\n+  queue.release ();\n+\n+  FOR_BB_INSNS (first, insn)\n+    {\n+      rtx dest = interesting_dest_for_shprep (insn, NULL);\n+      if (!dest)\n+\tcontinue;\n+\n+      if (DF_REG_DEF_COUNT (REGNO (dest)) > 1)\n+\t{\n+\t  bitmap_clear (&need_new);\n+\t  bitmap_clear (&reachable);\n+\t  return false;\n+\t}\n+\n+      for (df_ref use = DF_REG_USE_CHAIN (REGNO(dest));\n+\t   use;\n+\t   use = DF_REF_NEXT_REG (use))\n+\t{\n+\t  if (NONDEBUG_INSN_P (DF_REF_INSN (use))\n+\t      && GET_CODE (DF_REF_REG (use)) == SUBREG)\n+\t    {\n+\t      /* This is necessary to avoid hitting an assert at\n+\t\t postreload.c:2294 in libstc++ testcases on x86_64-linux.  I'm\n+\t\t not really sure what the probblem actually is there.  */\n+\t      bitmap_clear (&need_new);\n+\t      bitmap_clear (&reachable);\n+\t      return false;\n+\t    }\n+\n+\t  int ubbi = DF_REF_BB (use)->index;\n+\t  if (bitmap_bit_p (&reachable, ubbi))\n+\t    bitmap_set_bit (&need_new, ubbi);\n+\t}\n+      last_interesting_insn = insn;\n+    }\n+\n+  bitmap_clear (&reachable);\n+  if (!last_interesting_insn)\n+    {\n+      bitmap_clear (&need_new);\n+      return false;\n+    }\n+\n+  call_dom = nearest_common_dominator_for_set (CDI_DOMINATORS, &need_new);\n+  bitmap_clear (&need_new);\n+  if (call_dom == first)\n+    return false;\n+\n+  loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+  while (bb_loop_depth (call_dom) > 0)\n+    call_dom = get_immediate_dominator (CDI_DOMINATORS, call_dom);\n+  loop_optimizer_finalize ();\n+\n+  if (call_dom == first)\n+    return false;\n+\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  if (dominated_by_p (CDI_POST_DOMINATORS, first, call_dom))\n+    {\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      return false;\n+    }\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Will split live ranges of parameters at BB %i\\n\",\n+\t     call_dom->index);\n+\n+  bool ret = false;\n+  FOR_BB_INSNS (first, insn)\n+    {\n+      rtx dest = interesting_dest_for_shprep (insn, call_dom);\n+      if (!dest)\n+\tcontinue;\n+\n+      rtx newreg = NULL_RTX;\n+      df_ref use, next;\n+      for (use = DF_REG_USE_CHAIN (REGNO(dest)); use; use = next)\n+\t{\n+\t  rtx uin = DF_REF_INSN (use);\n+\t  next = DF_REF_NEXT_REG (use);\n+\n+\t  basic_block ubb = BLOCK_FOR_INSN (uin);\n+\t  if (ubb == call_dom\n+\t      || dominated_by_p (CDI_DOMINATORS, ubb, call_dom))\n+\t    {\n+\t      if (!newreg)\n+\t\tnewreg = ira_create_new_reg (dest);\n+\t      validate_change (uin, DF_REF_LOC (use), newreg, true);\n+\t    }\n+\t}\n+\n+      if (newreg)\n+\t{\n+\t  rtx new_move = gen_move_insn (newreg, dest);\n+\t  emit_insn_after (new_move, bb_note (call_dom));\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Split live-range of register \");\n+\t      print_rtl_single (dump_file, dest);\n+\t    }\n+\t  ret = true;\n+\t}\n+\n+      if (insn == last_interesting_insn)\n+\tbreak;\n+    }\n+  apply_change_group ();\n+  return ret;\n }\n \n /* Perform the second half of the transformation started in\n@@ -5049,7 +5228,22 @@ ira (FILE *f)\n      allocation because of -O0 usage or because the function is too\n      big.  */\n   if (ira_conflicts_p)\n-    find_moveable_pseudos ();\n+    {\n+      df_analyze ();\n+      calculate_dominance_info (CDI_DOMINATORS);\n+\n+      find_moveable_pseudos ();\n+      if (split_live_ranges_for_shrink_wrap ())\n+\tdf_analyze ();\n+\n+      fix_reg_equiv_init ();\n+      expand_reg_info ();\n+      regstat_free_n_sets_and_refs ();\n+      regstat_free_ri ();\n+      regstat_init_n_sets_and_refs ();\n+      regstat_compute_ri ();\n+      free_dominance_info (CDI_DOMINATORS);\n+    }\n \n   max_regno_before_ira = max_reg_num ();\n   ira_setup_eliminable_regset (true);"}, {"sha": "e685e6699080c310bdae1020580b81e4e6a3238c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70", "patch": "@@ -1,3 +1,10 @@\n+2013-11-12  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR rtl-optimization/10474\n+\t* gcc.dg/pr10474.c: New testcase.\n+\t* gcc.dg/ira-shrinkwrap-prep-1.c: Likewise.\n+\t* gcc.dg/ira-shrinkwrap-prep-2.c: Likewise.\n+\n 2013-11-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/57734"}, {"sha": "16095e30854ed5d67cbf11e1edb10bef68fbf1e6", "filename": "gcc/testsuite/gcc.dg/ira-shrinkwrap-prep-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-1.c?ref=732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target x86_64-*-* } } */\n+/* { dg-options \"-O3 -fdump-rtl-ira -fdump-rtl-pro_and_epilogue\"  } */\n+\n+int __attribute__((noinline, noclone))\n+foo (int a)\n+{\n+  return a + 5;\n+}\n+\n+static int g;\n+\n+int __attribute__((noinline, noclone))\n+bar (int a)\n+{\n+  int r;\n+\n+  if (a)\n+    {\n+      r = foo (a);\n+      g = r + a;\n+    }\n+  else\n+    r = a+1;\n+  return r;\n+}\n+\n+/* { dg-final { scan-rtl-dump \"Will split live ranges of parameters\" \"ira\"  } } */\n+/* { dg-final { scan-rtl-dump \"Split live-range of register\" \"ira\"  } } */\n+/* { dg-final { scan-rtl-dump \"Performing shrink-wrapping\" \"pro_and_epilogue\"  } } */\n+/* { dg-final { cleanup-rtl-dump \"ira\" } } */\n+/* { dg-final { cleanup-rtl-dump \"pro_and_epilogue\" } } */"}, {"sha": "2b00c5b49975cc4fe21c3b9d1d105406dbe2c2ca", "filename": "gcc/testsuite/gcc.dg/ira-shrinkwrap-prep-2.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-2.c?ref=732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile { target x86_64-*-* } } */\n+/* { dg-options \"-O3 -fdump-rtl-ira -fdump-rtl-pro_and_epilogue\"  } */\n+\n+int __attribute__((noinline, noclone))\n+foo (int a)\n+{\n+  return a + 5;\n+}\n+\n+static int g;\n+\n+int __attribute__((noinline, noclone))\n+bar (int a)\n+{\n+  int r;\n+\n+  if (a)\n+    {\n+      r = a;\n+      while (r < 500)\n+\tif (r % 2)\n+\t  r = foo (r);\n+\telse\n+\t  r = foo (r+1);\n+      g = r + a;\n+    }\n+  else\n+    r = g+1;\n+  return r;\n+}\n+\n+/* { dg-final { scan-rtl-dump \"Will split live ranges of parameters\" \"ira\"  } } */\n+/* { dg-final { scan-rtl-dump \"Split live-range of register\" \"ira\"  } } */\n+/* { dg-final { scan-rtl-dump \"Performing shrink-wrapping\" \"pro_and_epilogue\"  } } */\n+/* { dg-final { cleanup-rtl-dump \"ira\" } } */\n+/* { dg-final { cleanup-rtl-dump \"pro_and_epilogue\" } } */"}, {"sha": "4fcd75deed742dd9e70406340fb81b5043d5d5b9", "filename": "gcc/testsuite/gcc.dg/pr10474.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2Ftestsuite%2Fgcc.dg%2Fpr10474.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70/gcc%2Ftestsuite%2Fgcc.dg%2Fpr10474.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr10474.c?ref=732dad8f32152ed7cbb2d4cb8ba0fc21f608fe70", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target x86_64-*-* } } */\n+/* { dg-options \"-O3 -fdump-rtl-pro_and_epilogue\"  } */\n+\n+void f(int *i)\n+{\n+\tif (!i)\n+\t\treturn;\n+\telse\n+\t{\n+\t\t__builtin_printf(\"Hi\");\n+\t\t*i=0;\n+\t}\n+}\n+\n+/* { dg-final { scan-rtl-dump \"Performing shrink-wrapping\" \"pro_and_epilogue\"  } } */\n+/* { dg-final { cleanup-rtl-dump \"pro_and_epilogue\" } } */"}]}