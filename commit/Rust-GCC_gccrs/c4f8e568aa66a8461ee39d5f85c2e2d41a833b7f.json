{"sha": "c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRmOGU1NjhhYTY2YTg0NjFlZTM5ZDVmODVjMmUyZDQxYTgzM2I3Zg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-11T22:02:27Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-11T22:02:27Z"}, "message": "libstdc++: Add a fallback 128-bit integer class type and use it\n\nThis implements a minimal integer class type that emulates 128-bit\nunsigned arithmetic using a pair of 64-bit integers, which the\nfloating-point std::to_chars implementation then uses as a drop-in\nreplacement for unsigned __int128 on targets that lack the latter.\nAfter this patch, we now fully support formatting of large long double\ntypes on such targets.\n\nSince Ryu performs 128-bit division/modulus only by 2, 5 and 10, this\ninteger class type supports only these divisors rather than general\ndivision/modulus.\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++17/floating_to_chars.cc: Simplify the file as if\n\t__SIZEOF_INT128__ is always defined.\n\t[!defined __SIZEOF_INT128__]: Include \"uint128_t.h\".  Define\n\ta base-10 to_chars overload for the uint128_t class type.\n\t* src/c++17/uint128_t.h: New file.\n\t* testsuite/20_util/to_chars/long_double.cc: No longer expect an\n\texecution FAIL on targets that have a large long double type\n\tbut lack __int128.", "tree": {"sha": "ad21899bd308e7cab9bcf28c7514370a16309350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad21899bd308e7cab9bcf28c7514370a16309350"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f/comments", "author": null, "committer": null, "parents": [{"sha": "349adff208618c7d18d8ab12552a02509aacef47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/349adff208618c7d18d8ab12552a02509aacef47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/349adff208618c7d18d8ab12552a02509aacef47"}], "stats": {"total": 356, "additions": 332, "deletions": 24}, "files": [{"sha": "1a0abb9e80f86127ea947581f3da2dc6dcc7bcc4", "filename": "libstdc++-v3/src/c++17/floating_to_chars.cc", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc?ref=c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f", "patch": "@@ -64,25 +64,19 @@ extern \"C\" int __sprintfieee128(char*, const char*, ...);\n \n #if __LDBL_MANT_DIG__ == __DBL_MANT_DIG__\n # define LONG_DOUBLE_KIND LDK_BINARY64\n-#elif defined(__SIZEOF_INT128__)\n-// The Ryu routines need a 128-bit integer type in order to do shortest\n-// formatting of types larger than 64-bit double, so without __int128 we can't\n-// support any large long double format.  This is the case for e.g. i386.\n-# if __LDBL_MANT_DIG__ == 64\n+#elif __LDBL_MANT_DIG__ == 64\n #  define LONG_DOUBLE_KIND LDK_FLOAT80\n-# elif __LDBL_MANT_DIG__ == 113\n-#  define LONG_DOUBLE_KIND LDK_BINARY128\n-# elif __LDBL_MANT_DIG__ == 106\n-#  define LONG_DOUBLE_KIND LDK_IBM128\n-# endif\n-# if defined _GLIBCXX_USE_FLOAT128 && __FLT128_MANT_DIG__ == 113\n-// Define overloads of std::to_chars for __float128.\n-#  define FLOAT128_TO_CHARS 1\n-# endif\n+#elif __LDBL_MANT_DIG__ == 113\n+# define LONG_DOUBLE_KIND LDK_BINARY128\n+#elif __LDBL_MANT_DIG__ == 106\n+# define LONG_DOUBLE_KIND LDK_IBM128\n+#else\n+# define LONG_DOUBLE_KIND LDK_UNSUPPORTED\n #endif\n \n-#if !defined(LONG_DOUBLE_KIND)\n-# define LONG_DOUBLE_KIND LDK_UNSUPPORTED\n+#if defined _GLIBCXX_USE_FLOAT128 && __FLT128_MANT_DIG__ == 113\n+// Define overloads of std::to_chars for __float128.\n+# define FLOAT128_TO_CHARS 1\n #endif\n \n // For now we only support __float128 when it's the powerpc64 __ieee128 type.\n@@ -100,6 +94,8 @@ namespace\n {\n #if defined __SIZEOF_INT128__\n   using uint128_t = unsigned __int128;\n+#else\n+# include \"uint128_t.h\"\n #endif\n \n   namespace ryu\n@@ -114,7 +110,6 @@ namespace\n #include \"ryu/d2fixed.c\"\n #include \"ryu/f2s.c\"\n \n-#ifdef __SIZEOF_INT128__\n     namespace generic128\n     {\n       // Put the generic Ryu bits in their own namespace to avoid name conflicts.\n@@ -129,7 +124,6 @@ namespace\n     int\n     to_chars(const floating_decimal_128 v, char* const result)\n     { return generic128::generic_to_chars(v, result); }\n-#endif\n   } // namespace ryu\n \n   // A traits class that contains pertinent information about the binary\n@@ -407,10 +401,8 @@ namespace\n \t  return uint32_t{};\n \telse if constexpr (total_bits <= 64)\n \t  return uint64_t{};\n-#ifdef __SIZEOF_INT128__\n \telse if constexpr (total_bits <= 128)\n \t  return uint128_t{};\n-#endif\n       };\n       using uint_t = decltype(get_uint_t());\n       uint_t value_bits = 0;\n@@ -503,7 +495,6 @@ namespace\n \treturn ryu::floating_to_fd32(value);\n       else if constexpr (std::is_same_v<T, double>)\n \treturn ryu::floating_to_fd64(value);\n-#ifdef __SIZEOF_INT128__\n       else if constexpr (std::is_same_v<T, long double>\n \t\t\t || std::is_same_v<T, F128_type>)\n \t{\n@@ -519,7 +510,6 @@ namespace\n \t\t\t\t\t\tmantissa_bits, exponent_bits,\n \t\t\t\t\t\t!has_implicit_leading_bit);\n \t}\n-#endif\n     }\n \n   // This subroutine returns true if the shortest scientific form fd is a\n@@ -558,10 +548,32 @@ namespace\n   get_mantissa_length(const ryu::floating_decimal_64 fd)\n   { return ryu::decimalLength17(fd.mantissa); }\n \n-#ifdef __SIZEOF_INT128__\n   int\n   get_mantissa_length(const ryu::floating_decimal_128 fd)\n   { return ryu::generic128::decimalLength(fd.mantissa); }\n+\n+#if !defined __SIZEOF_INT128__\n+  // An implementation of base-10 std::to_chars for the uint128_t class type,\n+  // used by targets that lack __int128.\n+  std::to_chars_result\n+  to_chars(char* first, char* const last, uint128_t x)\n+  {\n+    const int len = ryu::generic128::decimalLength(x);\n+    if (last - first < len)\n+      return {last, std::errc::value_too_large};\n+    if (x == 0)\n+      {\n+\t*first++ = '0';\n+\treturn {first, std::errc{}};\n+      }\n+    for (int i = 0; i < len; ++i)\n+      {\n+\tfirst[len - 1 - i] = '0' + static_cast<char>(x % 10);\n+\tx /= 10;\n+      }\n+    __glibcxx_assert(x == 0);\n+    return {first + len, std::errc{}};\n+  }\n #endif\n } // anon namespace\n "}, {"sha": "e3c2f1936eb06c6f553616ffaaaf59e14c001189", "filename": "libstdc++-v3/src/c++17/uint128_t.h", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fuint128_t.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fuint128_t.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fuint128_t.h?ref=c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f", "patch": "@@ -0,0 +1,297 @@\n+// A relatively minimal unsigned 128-bit integer class type, used by the\n+// floating-point std::to_chars implementation on targets that lack __int128.\n+\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+struct uint128_t\n+{\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+  uint64_t lo, hi;\n+#else\n+  uint64_t hi, lo;\n+#endif\n+\n+  uint128_t() = default;\n+\n+  constexpr\n+  uint128_t(uint64_t lo, uint64_t hi = 0)\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+    : lo(lo), hi(hi)\n+#else\n+    : hi(hi), lo(lo)\n+#endif\n+  { }\n+\n+  constexpr explicit\n+  operator bool() const\n+  { return *this != 0; }\n+\n+  template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>\n+    constexpr explicit\n+    operator T() const\n+    {\n+      static_assert(sizeof(T) <= sizeof(uint64_t));\n+      return static_cast<T>(lo);\n+    }\n+\n+  friend constexpr uint128_t\n+  operator&(uint128_t x, const uint128_t y)\n+  {\n+    x.lo &= y.lo;\n+    x.hi &= y.hi;\n+    return x;\n+  }\n+\n+  friend constexpr uint128_t\n+  operator|(uint128_t x, const uint128_t y)\n+  {\n+    x.lo |= y.lo;\n+    x.hi |= y.hi;\n+    return x;\n+  }\n+\n+  friend constexpr uint128_t\n+  operator<<(uint128_t x, const uint128_t y)\n+  {\n+    __glibcxx_assert(y < 128);\n+    // TODO: Convince GCC to use shldq on x86 here.\n+    if (y.lo >= 64)\n+      {\n+\tx.hi = x.lo << (y.lo - 64);\n+\tx.lo = 0;\n+      }\n+    else if (y.lo != 0)\n+      {\n+\tx.hi <<= y.lo;\n+\tx.hi |= x.lo >> (64 - y.lo);\n+\tx.lo <<= y.lo;\n+      }\n+    return x;\n+  }\n+\n+  friend constexpr uint128_t\n+  operator>>(uint128_t x, const uint128_t y)\n+  {\n+    __glibcxx_assert(y < 128);\n+    // TODO: Convince GCC to use shrdq on x86 here.\n+    if (y.lo >= 64)\n+      {\n+\tx.lo = x.hi >> (y.lo - 64);\n+\tx.hi = 0;\n+      }\n+    else if (y.lo != 0)\n+      {\n+\tx.lo >>= y.lo;\n+\tx.lo |= x.hi << (64 - y.lo);\n+\tx.hi >>= y.lo;\n+      }\n+    return x;\n+  }\n+\n+  constexpr uint128_t\n+  operator~() const\n+  { return {~lo, ~hi}; }\n+\n+  constexpr uint128_t\n+  operator-() const\n+  { return operator~() + 1; }\n+\n+  friend constexpr uint128_t\n+  operator+(uint128_t x, const uint128_t y)\n+  {\n+    x.hi += __builtin_add_overflow(x.lo, y.lo, &x.lo);\n+    x.hi += y.hi;\n+    return x;\n+  }\n+\n+  friend constexpr uint128_t\n+  operator-(uint128_t x, const uint128_t y)\n+  {\n+    x.hi -= __builtin_sub_overflow(x.lo, y.lo, &x.lo);\n+    x.hi -= y.hi;\n+    return x;\n+  }\n+\n+  static constexpr uint128_t\n+  umul64_64_128(const uint64_t x, const uint64_t y)\n+  {\n+    const uint64_t xl = x & 0xffffffff;\n+    const uint64_t xh = x >> 32;\n+    const uint64_t yl = y & 0xffffffff;\n+    const uint64_t yh = y >> 32;\n+    const uint64_t ll = xl * yl;\n+    const uint64_t lh = xl * yh;\n+    const uint64_t hl = xh * yl;\n+    const uint64_t hh = xh * yh;\n+    const uint64_t m = (ll >> 32) + lh + (hl & 0xffffffff);\n+    const uint64_t l = (ll & 0xffffffff ) | (m << 32);\n+    const uint64_t h = (m >> 32) + (hl >> 32) + hh;\n+    return {l, h};\n+  }\n+\n+  friend constexpr uint128_t\n+  operator*(const uint128_t x, const uint128_t y)\n+  {\n+    uint128_t z = umul64_64_128(x.lo, y.lo);\n+    z.hi += x.lo * y.hi + x.hi * y.lo;\n+    return z;\n+  }\n+\n+  friend constexpr uint128_t\n+  operator/(const uint128_t x, const uint128_t y)\n+  {\n+    // Ryu performs 128-bit division only by 5 and 10, so that's what we\n+    // implement.  The strategy here is to relate division of x with that of\n+    // x.hi and x.lo separately.\n+    __glibcxx_assert(y == 5 || y == 10);\n+    // The following implements division by 5 and 10.  In either case, we\n+    // first compute division by 5:\n+    //   x/5 = (x.hi*2^64 + x.lo)/5\n+    //       = (x.hi*(2^64-1) + x.hi + x.lo)/5\n+    //       = x.hi*((2^64-1)/5) + (x.hi + x.lo)/5 since CST=(2^64-1)/5 is exact\n+    //       = x.hi*CST + x.hi/5 + x.lo/5 + ((x.lo%5) + (x.hi%5) >= 5)\n+    // We go a step further and replace the last adjustment term with a\n+    // lookup table, which we encode as a binary literal.  This seems to\n+    // yield smaller code on x86 at least.\n+    constexpr auto cst = ~uint64_t(0) / 5;\n+    uint128_t q = uint128_t{x.hi}*cst + uint128_t{x.hi/5 + x.lo/5};\n+    constexpr auto lookup = 0b111100000u;\n+    q += (lookup >> ((x.hi % 5) + (x.lo % 5))) & 1;\n+    if (y == 10)\n+      q >>= 1;\n+    return q;\n+  }\n+\n+  friend constexpr uint128_t\n+  operator%(const uint128_t x, const uint128_t y)\n+  {\n+    // Ryu performs 128-bit modulus only by 2, 5 and 10, so that's what we\n+    // implement.  The strategy here is to relate modulus of x with that of\n+    // x.hi and x.lo separately.\n+    if (y == 2)\n+      return x & 1;\n+    __glibcxx_assert(y == 5 || y == 10);\n+    // The following implements modulus by 5 and 10.  In either case,\n+    // we first compute modulus by 5:\n+    //   x (mod 5) = x.hi*2^64 + x.lo (mod 5)\n+    //             = x.hi + x.lo (mod 5) since 2^64 \u2261 1 (mod 5)\n+    // So the straightforward implementation would be\n+    //   ((x.hi % 5) + (x.lo % 5)) % 5\n+    // But we go a step further and replace the outermost % with a\n+    // lookup table:\n+    //             = {0,1,2,3,4,0,1,2,3}[(x.hi % 5) + (x.lo % 5)] (mod 5)\n+    // which we encode as an octal literal.\n+    constexpr auto lookup = 0321043210u;\n+    auto r = (lookup >> 3*((x.hi % 5) + (x.lo % 5))) & 7;\n+    if (y == 10)\n+      // x % 10 = (x % 5)      if x / 5 is even\n+      //          (x % 5) + 5  if x / 5 is odd\n+      // The compiler should be able to CSE the below computation of x/5 and\n+      // the above modulus operations with a nearby inlined computation of x/10.\n+      r += 5 * ((x/5).lo & 1);\n+    return r;\n+  }\n+\n+  friend constexpr bool\n+  operator==(const uint128_t x, const uint128_t y)\n+  { return x.hi == y.hi && x.lo == y.lo; }\n+\n+  friend constexpr bool\n+  operator<(const uint128_t x, const uint128_t y)\n+  { return x.hi < y.hi || (x.hi == y.hi && x.lo < y.lo); }\n+\n+  friend constexpr auto\n+  __bit_width(const uint128_t x)\n+  {\n+    if (auto w = std::__bit_width(x.hi))\n+      return w + 64;\n+    else\n+      return std::__bit_width(x.lo);\n+  }\n+\n+  friend constexpr auto\n+  __countr_zero(const uint128_t x)\n+  {\n+    auto c = std::__countr_zero(x.lo);\n+    if (c == 64)\n+      return 64 + std::__countr_zero(x.hi);\n+    else\n+      return c;\n+  }\n+\n+  constexpr uint128_t&\n+  operator--()\n+  { return *this -= 1; }\n+\n+  constexpr uint128_t&\n+  operator++()\n+  { return *this += 1; }\n+\n+  constexpr uint128_t&\n+  operator+=(const uint128_t y)\n+  { return *this = *this + y; }\n+\n+  constexpr uint128_t&\n+  operator-=(const uint128_t y)\n+  { return *this = *this - y; }\n+\n+  constexpr uint128_t&\n+  operator*=(const uint128_t y)\n+  { return *this = *this * y; }\n+\n+  constexpr uint128_t&\n+  operator<<=(const uint128_t y)\n+  { return *this = *this << y; }\n+\n+  constexpr uint128_t&\n+  operator>>=(const uint128_t y)\n+  { return *this = *this >> y; }\n+\n+  constexpr uint128_t&\n+  operator|=(const uint128_t y)\n+  { return *this = *this | y; }\n+\n+  constexpr uint128_t&\n+  operator&=(const uint128_t y)\n+  { return *this = *this & y; }\n+\n+  constexpr uint128_t&\n+  operator%=(const uint128_t y)\n+  { return *this = *this % y; }\n+\n+  constexpr uint128_t&\n+  operator/=(const uint128_t y)\n+  { return *this = *this / y; }\n+\n+  friend constexpr bool\n+  operator!=(const uint128_t x, const uint128_t y)\n+  { return !(x == y); }\n+\n+  friend constexpr bool\n+  operator>(const uint128_t x, const uint128_t y)\n+  { return y < x; }\n+\n+  friend constexpr bool\n+  operator>=(const uint128_t x, const uint128_t y)\n+  { return !(x < y); }\n+};"}, {"sha": "5c1f7136f21c3e11be4a2187b19e93efe10ba71c", "filename": "libstdc++-v3/testsuite/20_util/to_chars/long_double.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc?ref=c4f8e568aa66a8461ee39d5f85c2e2d41a833b7f", "patch": "@@ -18,7 +18,6 @@\n // <charconv> is supported in C++14 as a GNU extension, but this test uses C++17\n // hexadecimal floating-point literals.\n // { dg-do run { target c++17 } }\n-// { dg-xfail-run-if \"Ryu needs __int128\" { large_long_double && { ! int128 } } }\n // { dg-require-effective-target ieee-floats }\n \n #include <charconv>"}]}