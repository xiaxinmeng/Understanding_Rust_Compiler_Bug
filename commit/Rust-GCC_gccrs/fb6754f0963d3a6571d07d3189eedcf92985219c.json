{"sha": "fb6754f0963d3a6571d07d3189eedcf92985219c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI2NzU0ZjA5NjNkM2E2NTcxZDA3ZDMxODllZWRjZjkyOTg1MjE5Yw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-01-11T17:02:44Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-01-11T17:02:44Z"}, "message": "Partially undo a previous patch\n\nFrom-SVN: r38908", "tree": {"sha": "c1d6a756d2b66bffb76aa47d962ae7bcfcb64074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1d6a756d2b66bffb76aa47d962ae7bcfcb64074"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb6754f0963d3a6571d07d3189eedcf92985219c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb6754f0963d3a6571d07d3189eedcf92985219c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb6754f0963d3a6571d07d3189eedcf92985219c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb6754f0963d3a6571d07d3189eedcf92985219c/comments", "author": null, "committer": null, "parents": [{"sha": "d2796d4ebc4a13a8cc0cbf3b106a680119f569dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2796d4ebc4a13a8cc0cbf3b106a680119f569dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2796d4ebc4a13a8cc0cbf3b106a680119f569dc"}], "stats": {"total": 67, "additions": 30, "deletions": 37}, "files": [{"sha": "cb3295ee50fc37845ffd0914b87f649b623952af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb6754f0963d3a6571d07d3189eedcf92985219c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb6754f0963d3a6571d07d3189eedcf92985219c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb6754f0963d3a6571d07d3189eedcf92985219c", "patch": "@@ -1,3 +1,12 @@\n+2001-01-11  Bernd Schmidt  <bernds@redhat.com>\n+\n+\t* alias.c (throughout): Use REGNO, rather than ORIGINAL_REGNO.\n+\t* sched-deps.c (deps_may_trap_p): Likewise.\n+\t* basic-block.h: Remove a comment.\n+\t* flow.c (PROP_POSTRELOAD): Remove.\n+\t(update_life_info): Don't add it to prop_flags.\n+\t(mark_set_1): Lose the code that was enabled by it.\n+\n 2001-01-11  Michael Hayes  <mhayes@redhat.com>\n \n \t* flow.c (flow_call_edges_add): New."}, {"sha": "235d299f42f6938ad18879e50960cb475be1f1f2", "filename": "gcc/alias.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb6754f0963d3a6571d07d3189eedcf92985219c/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb6754f0963d3a6571d07d3189eedcf92985219c/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=fb6754f0963d3a6571d07d3189eedcf92985219c", "patch": "@@ -148,8 +148,8 @@ static rtx *new_reg_base_value;\n static unsigned int reg_base_value_size; /* size of reg_base_value array */\n \n #define REG_BASE_VALUE(X) \\\n-  (ORIGINAL_REGNO (X) < reg_base_value_size \\\n-   ? reg_base_value[ORIGINAL_REGNO (X)] : 0)\n+  (REGNO (X) < reg_base_value_size \\\n+   ? reg_base_value[REGNO (X)] : 0)\n \n /* Vector of known invariant relationships between registers.  Set in\n    loop unrolling.  Indexed by register number, if nonzero the value\n@@ -668,7 +668,7 @@ find_base_value (src)\n       return src;\n \n     case REG:\n-      regno = ORIGINAL_REGNO (src);\n+      regno = REGNO (src);\n       /* At the start of a function, argument registers have known base\n \t values which may be lost later.  Returning an ADDRESS\n \t expression here allows optimization based on argument values\n@@ -792,7 +792,7 @@ record_set (dest, set, data)\n   if (GET_CODE (dest) != REG)\n     return;\n \n-  regno = ORIGINAL_REGNO (dest);\n+  regno = REGNO (dest);\n \n   if (regno >= reg_base_value_size)\n     abort ();\n@@ -873,8 +873,8 @@ record_base_value (regno, val, invariant)\n \n   if (GET_CODE (val) == REG)\n     {\n-      if (ORIGINAL_REGNO (val) < reg_base_value_size)\n-\treg_base_value[regno] = reg_base_value[ORIGINAL_REGNO (val)];\n+      if (REGNO (val) < reg_base_value_size)\n+\treg_base_value[regno] = reg_base_value[REGNO (val)];\n \n       return;\n     }\n@@ -892,10 +892,10 @@ canon_rtx (x)\n      rtx x;\n {\n   /* Recursively look for equivalences.  */\n-  if (GET_CODE (x) == REG && ORIGINAL_REGNO (x) >= FIRST_PSEUDO_REGISTER\n-      && ORIGINAL_REGNO (x) < reg_known_value_size)\n-    return reg_known_value[ORIGINAL_REGNO (x)] == x\n-      ? x : canon_rtx (reg_known_value[ORIGINAL_REGNO (x)]);\n+  if (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER\n+      && REGNO (x) < reg_known_value_size)\n+    return reg_known_value[REGNO (x)] == x\n+      ? x : canon_rtx (reg_known_value[REGNO (x)]);\n   else if (GET_CODE (x) == PLUS)\n     {\n       rtx x0 = canon_rtx (XEXP (x, 0));\n@@ -2114,7 +2114,6 @@ init_alias_analysis ()\n \t\t\t\t\t reg_base_value_size * sizeof (rtx));\n       memset ((char *)alias_invariant, 0, reg_base_value_size * sizeof (rtx));\n     }\n-    \n \n   /* The basic idea is that each pass through this loop will use the\n      \"constant\" information from the previous pass to propagate alias\n@@ -2211,9 +2210,9 @@ init_alias_analysis ()\n \n \t      if (set != 0\n \t\t  && GET_CODE (SET_DEST (set)) == REG\n-\t\t  && ORIGINAL_REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n+\t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER)\n \t\t{\n-\t\t  unsigned int regno = ORIGINAL_REGNO (SET_DEST (set));\n+\t\t  unsigned int regno = REGNO (SET_DEST (set));\n \t\t  rtx src = SET_SRC (set);\n \n \t\t  if (REG_NOTES (insn) != 0\n@@ -2229,13 +2228,13 @@ init_alias_analysis ()\n \t\t  else if (REG_N_SETS (regno) == 1\n \t\t\t   && GET_CODE (src) == PLUS\n \t\t\t   && GET_CODE (XEXP (src, 0)) == REG\n-\t\t\t   && ORIGINAL_REGNO (XEXP (src, 0)) >= FIRST_PSEUDO_REGISTER\n-\t\t\t   && (reg_known_value[ORIGINAL_REGNO (XEXP (src, 0))])\n+\t\t\t   && REGNO (XEXP (src, 0)) >= FIRST_PSEUDO_REGISTER\n+\t\t\t   && (reg_known_value[REGNO (XEXP (src, 0))])\n \t\t\t   && GET_CODE (XEXP (src, 1)) == CONST_INT)\n \t\t    {\n \t\t      rtx op0 = XEXP (src, 0);\n-\t\t      if (reg_known_value[ORIGINAL_REGNO (op0)])\n-\t\t\top0 = reg_known_value[ORIGINAL_REGNO (op0)];\n+\t\t      if (reg_known_value[REGNO (op0)])\n+\t\t\top0 = reg_known_value[REGNO (op0)];\n \t\t      reg_known_value[regno]\n \t\t\t= plus_constant_for_output (op0,\n \t\t\t\t\t\t    INTVAL (XEXP (src, 1)));\n@@ -2293,7 +2292,7 @@ init_alias_analysis ()\n \t  rtx base = reg_base_value[ui];\n \t  if (base && GET_CODE (base) == REG)\n \t    {\n-\t      unsigned int base_regno = ORIGINAL_REGNO (base);\n+\t      unsigned int base_regno = REGNO (base);\n \t      if (base_regno == ui)\t\t/* register set from itself */\n \t\treg_base_value[ui] = 0;\n \t      else"}, {"sha": "eae8e29ac98b15ccbd26c8fcabd2eb2cc6de7365", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb6754f0963d3a6571d07d3189eedcf92985219c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb6754f0963d3a6571d07d3189eedcf92985219c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=fb6754f0963d3a6571d07d3189eedcf92985219c", "patch": "@@ -481,7 +481,6 @@ enum update_life_extent\n #define PROP_SCAN_DEAD_CODE\t16\t/* Scan for dead code.  */\n #define PROP_AUTOINC\t\t32\t/* Create autoinc mem references.  */\n #define PROP_FINAL\t\t63\t/* All of the above.  */\n-/* Flag number 64 is used internally in flow.c.  */\n \n /* Flags for loop discovery.  */\n "}, {"sha": "734063848d7e07c11408b64e00c2048d6784568d", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb6754f0963d3a6571d07d3189eedcf92985219c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb6754f0963d3a6571d07d3189eedcf92985219c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=fb6754f0963d3a6571d07d3189eedcf92985219c", "patch": "@@ -168,10 +168,6 @@ Boston, MA 02111-1307, USA.  */\n #define EPILOGUE_USES(REGNO)  0\n #endif\n \n-/* Not in basic-block.h, since it is private to this file.  When set, it\n-   causes us to keep REG_N_SETS uptodate for original pseudo registers.  */\n-#define PROP_POSTRELOAD 64\n-\n /* The obstack on which the flow graph components are allocated.  */\n \n struct obstack flow_obstack;\n@@ -3066,9 +3062,6 @@ update_life_info (blocks, extent, prop_flags)\n \n   tmp = INITIALIZE_REG_SET (tmp_head);\n \n-  if (reload_completed)\n-    prop_flags |= PROP_POSTRELOAD;\n-\n   /* For a global update, we go through the relaxation process again.  */\n   if (extent != UPDATE_LIFE_LOCAL)\n     {\n@@ -4643,7 +4636,6 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n      rtx reg, cond, insn;\n      int flags;\n {\n-  int orig_regno = -1;\n   int regno_first = -1, regno_last = -1;\n   int not_dead = 0;\n   int i;\n@@ -4681,7 +4673,6 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n       /* Fall through.  */\n \n     case REG:\n-      orig_regno = ORIGINAL_REGNO (reg);\n       regno_last = regno_first = REGNO (reg);\n       if (regno_first < FIRST_PSEUDO_REGISTER)\n \tregno_last += HARD_REGNO_NREGS (regno_first, GET_MODE (reg)) - 1;\n@@ -4826,7 +4817,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \n       /* Additional data to record if this is the final pass.  */\n       if (flags & (PROP_LOG_LINKS | PROP_REG_INFO\n-\t\t   | PROP_DEATH_NOTES | PROP_AUTOINC | PROP_POSTRELOAD))\n+\t\t   | PROP_DEATH_NOTES | PROP_AUTOINC))\n \t{\n \t  register rtx y;\n \t  register int blocknum = pbi->bb->index;\n@@ -4841,11 +4832,6 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t\tpbi->reg_next_use[i] = 0;\n \t    }\n \n-\t  /* After reload has completed, try to keep REG_N_SETS uptodate for\n-\t     the original pseudos.  */\n-\t  if ((flags & PROP_POSTRELOAD) && orig_regno >= FIRST_PSEUDO_REGISTER)\n-\t    REG_N_SETS (orig_regno) += 1;\n-\n \t  if (flags & PROP_REG_INFO)\n \t    {\n \t      for (i = regno_first; i <= regno_last; ++i)"}, {"sha": "67ea68bedf32c052bb3ae310ec8916d61c749364", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb6754f0963d3a6571d07d3189eedcf92985219c/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb6754f0963d3a6571d07d3189eedcf92985219c/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=fb6754f0963d3a6571d07d3189eedcf92985219c", "patch": "@@ -96,9 +96,9 @@ deps_may_trap_p (mem)\n   rtx addr = XEXP (mem, 0);\n \n   if (REG_P (addr)\n-      && ORIGINAL_REGNO (addr) >= FIRST_PSEUDO_REGISTER\n-      && reg_known_value[ORIGINAL_REGNO (addr)])\n-    addr = reg_known_value[ORIGINAL_REGNO (addr)];\n+      && REGNO (addr) >= FIRST_PSEUDO_REGISTER\n+      && reg_known_value[REGNO (addr)])\n+    addr = reg_known_value[REGNO (addr)];\n   return rtx_addr_can_trap_p (addr);\n }\n \f"}]}