{"sha": "45d8710e5eddf8ff9b12ae8b0081389a7e40683e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVkODcxMGU1ZWRkZjhmZjliMTJhZThiMDA4MTM4OWE3ZTQwNjgzZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-11-29T00:52:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-11-29T00:52:33Z"}, "message": "expr.c (expand_expr_real_1, [...]): Properly fold with non-zero lower bound.\n\n\t* expr.c (expand_expr_real_1, case ARRAY_REF): Properly fold with\n\tnon-zero lower bound.\n\nFrom-SVN: r91446", "tree": {"sha": "2e1401560c33798d96a814b7b6fbcfbaa0345cf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e1401560c33798d96a814b7b6fbcfbaa0345cf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45d8710e5eddf8ff9b12ae8b0081389a7e40683e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d8710e5eddf8ff9b12ae8b0081389a7e40683e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d8710e5eddf8ff9b12ae8b0081389a7e40683e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d8710e5eddf8ff9b12ae8b0081389a7e40683e/comments", "author": null, "committer": null, "parents": [{"sha": "97f8d136d175358a78b71d6d17e1c96a5e5a016b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97f8d136d175358a78b71d6d17e1c96a5e5a016b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97f8d136d175358a78b71d6d17e1c96a5e5a016b"}], "stats": {"total": 33, "additions": 9, "deletions": 24}, "files": [{"sha": "c406d005416697aff293454410c250d34b93e208", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d8710e5eddf8ff9b12ae8b0081389a7e40683e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d8710e5eddf8ff9b12ae8b0081389a7e40683e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45d8710e5eddf8ff9b12ae8b0081389a7e40683e", "patch": "@@ -1,5 +1,8 @@\n 2004-11-28  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* expr.c (expand_expr_real_1, case ARRAY_REF): Properly fold with\n+\tnon-zero lower bound.\n+\n \t* expr.c (categorize_ctor_elements_1, case STRING_CST): New case.\n \n 2004-11-28  Matt Kraai  <kraai@alumni.cmu.edu>"}, {"sha": "122c3e176379ea6e5613d07a848de22f64903883", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d8710e5eddf8ff9b12ae8b0081389a7e40683e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d8710e5eddf8ff9b12ae8b0081389a7e40683e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=45d8710e5eddf8ff9b12ae8b0081389a7e40683e", "patch": "@@ -6744,22 +6744,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n       {\n \ttree array = TREE_OPERAND (exp, 0);\n-\ttree low_bound = array_ref_low_bound (exp);\n-\ttree index = convert (sizetype, TREE_OPERAND (exp, 1));\n-\tHOST_WIDE_INT i;\n-\n-\tgcc_assert (TREE_CODE (TREE_TYPE (array)) == ARRAY_TYPE);\n-\n-\t/* Optimize the special-case of a zero lower bound.\n-\n-\t   We convert the low_bound to sizetype to avoid some problems\n-\t   with constant folding.  (E.g. suppose the lower bound is 1,\n-\t   and its mode is QI.  Without the conversion,  (ARRAY\n-\t   +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1))\n-\t   +INDEX), which becomes (ARRAY+255+INDEX).  Oops!)  */\n-\n-\tif (! integer_zerop (low_bound))\n-\t  index = size_diffop (index, convert (sizetype, low_bound));\n+\ttree index = TREE_OPERAND (exp, 1);\n \n \t/* Fold an expression like: \"foo\"[2].\n \t   This is not done in fold so it won't happen inside &.\n@@ -6786,19 +6771,16 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    && modifier != EXPAND_MEMORY\n \t    && TREE_CODE (array) == CONSTRUCTOR\n \t    && ! TREE_SIDE_EFFECTS (array)\n-\t    && TREE_CODE (index) == INTEGER_CST\n-\t    && 0 > compare_tree_int (index,\n-\t\t\t\t     list_length (CONSTRUCTOR_ELTS\n-\t\t\t\t\t\t  (TREE_OPERAND (exp, 0)))))\n+\t    && TREE_CODE (index) == INTEGER_CST)\n \t  {\n \t    tree elem;\n \n-\t    for (elem = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)),\n-\t\t i = TREE_INT_CST_LOW (index);\n-\t\t elem != 0 && i != 0; i--, elem = TREE_CHAIN (elem))\n+\t    for (elem = CONSTRUCTOR_ELTS (array);\n+\t\t (elem && !tree_int_cst_equal (TREE_PURPOSE (elem), index));\n+\t\t elem = TREE_CHAIN (elem))\n \t      ;\n \n-\t    if (elem)\n+\t    if (elem && !TREE_SIDE_EFFECTS (TREE_VALUE (elem)))\n \t      return expand_expr (fold (TREE_VALUE (elem)), target, tmode,\n \t\t\t\t  modifier);\n \t  }"}]}