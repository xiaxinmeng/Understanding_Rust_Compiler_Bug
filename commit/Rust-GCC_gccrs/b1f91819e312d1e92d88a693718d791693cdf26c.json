{"sha": "b1f91819e312d1e92d88a693718d791693cdf26c", "node_id": "C_kwDOANBUbNoAKGIxZjkxODE5ZTMxMmQxZTkyZDg4YTY5MzcxOGQ3OTE2OTNjZGYyNmM", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-12-17T02:46:06Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-12-17T02:48:04Z"}, "message": "libbacktrace: unpack literals into output buffer\n\n\t* elf.c (elf_fetch_backward_init): New static function.\n\t(ZSTD_TABLE_SIZE): Use huffman scratch space size rather than\n\tliteral size.\n\t(ZSTD_TABLE_WORK_LIT_SIZE): Don't define.\n\t(elf_zstd_read_huff): Use elf_fetch_backward_init.\n\t(elf_zstd_read_literals): New static function.\n\t(ZSTD_LIT_RAW, ZSTD_LIT_RLE, ZSTD_LIT_HUFF): Don't define.\n\t(struct elf_zstd_literals): Don't define.\n\t(elf_zstd_literal_output): Remove static function.\n\t(elf_zstd_decompress): Use elf_fetch_backward_init and\n\telf_zstd_read_literals.  Rewrite literal copying.<", "tree": {"sha": "52a7ea0ea929623dc951b792bf9a6393ef55ba9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52a7ea0ea929623dc951b792bf9a6393ef55ba9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1f91819e312d1e92d88a693718d791693cdf26c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1f91819e312d1e92d88a693718d791693cdf26c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1f91819e312d1e92d88a693718d791693cdf26c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1f91819e312d1e92d88a693718d791693cdf26c/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fb1e67453f40ae6e77b95f7a79a016aec6a1966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fb1e67453f40ae6e77b95f7a79a016aec6a1966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fb1e67453f40ae6e77b95f7a79a016aec6a1966"}], "stats": {"total": 1313, "additions": 672, "deletions": 641}, "files": [{"sha": "135a94245a42bdab1bcc9f45081eca5e1b51ff0e", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 672, "deletions": 641, "changes": 1313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f91819e312d1e92d88a693718d791693cdf26c/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f91819e312d1e92d88a693718d791693cdf26c/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=b1f91819e312d1e92d88a693718d791693cdf26c", "patch": "@@ -1223,6 +1223,57 @@ elf_fetch_bits_backward (const unsigned char **ppin,\n   return 1;\n }\n \n+/* Initialize backward fetching when the bitstream starts with a 1 bit in the\n+   last byte in memory (which is the first one that we read).  This is used by\n+   zstd decompression.  Returns 1 on success, 0 on error.  */\n+\n+static int\n+elf_fetch_backward_init (const unsigned char **ppin,\n+\t\t\t const unsigned char *pinend,\n+\t\t\t uint64_t *pval, unsigned int *pbits)\n+{\n+  const unsigned char *pin;\n+  unsigned int stream_start;\n+  uint64_t val;\n+  unsigned int bits;\n+\n+  pin = *ppin;\n+  stream_start = (unsigned int)*pin;\n+  if (unlikely (stream_start == 0))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  val = 0;\n+  bits = 0;\n+\n+  /* Align to a 32-bit boundary.  */\n+  while ((((uintptr_t)pin) & 3) != 0)\n+    {\n+      val <<= 8;\n+      val |= (uint64_t)*pin;\n+      bits += 8;\n+      --pin;\n+    }\n+\n+  val <<= 8;\n+  val |= (uint64_t)*pin;\n+  bits += 8;\n+\n+  *ppin = pin;\n+  *pval = val;\n+  *pbits = bits;\n+  if (!elf_fetch_bits_backward (ppin, pinend, pval, pbits))\n+    return 0;\n+\n+  *pbits -= __builtin_clz (stream_start) - (sizeof (unsigned int) - 1) * 8 + 1;\n+\n+  if (!elf_fetch_bits_backward (ppin, pinend, pval, pbits))\n+    return 0;\n+\n+  return 1;\n+}\n+\n /* Huffman code tables, like the rest of the zlib format, are defined\n    by RFC 1951.  We store a Huffman code table as a series of tables\n    stored sequentially in memory.  Each entry in a table is 16 bits.\n@@ -2617,14 +2668,13 @@ elf_zlib_inflate_and_verify (const unsigned char *pin, size_t sin,\n    - scratch space, one of\n      - to build an FSE table: 512 uint16_t values == 1024 bytes\n      - to build a Huffman tree: 512 uint16_t + 256 uint32_t == 2048 bytes\n-     - buffer for literal values == 2048 bytes\n */\n \n #define ZSTD_TABLE_SIZE\t\t\t\t\t\\\n   (2 * 512 * sizeof (struct elf_zstd_fse_baseline_entry)\t\\\n    + 256 * sizeof (struct elf_zstd_fse_baseline_entry)\t\t\\\n    + 2048 * sizeof (uint16_t)\t\t\t\t\t\\\n-   + 2048)\n+   + 512 * sizeof (uint16_t) + 256 * sizeof (uint32_t))\n \n #define ZSTD_TABLE_LITERAL_FSE_OFFSET (0)\n \n@@ -2642,8 +2692,6 @@ elf_zlib_inflate_and_verify (const unsigned char *pin, size_t sin,\n #define ZSTD_TABLE_WORK_OFFSET \\\n   (ZSTD_TABLE_HUFFMAN_OFFSET + 2048 * sizeof (uint16_t))\n \n-#define ZSTD_TABLE_WORK_LIT_SIZE 2048\n-\n /* An entry in a zstd FSE table.  */\n \n struct elf_zstd_fse_entry\n@@ -3427,7 +3475,6 @@ elf_zstd_read_huff (const unsigned char **ppin, const unsigned char *pinend,\n       uint16_t *scratch;\n       const unsigned char *pfse;\n       const unsigned char *pback;\n-      unsigned char stream_start;\n       uint64_t val;\n       unsigned int bits;\n       unsigned int state1, state2;\n@@ -3454,31 +3501,8 @@ elf_zstd_read_huff (const unsigned char **ppin, const unsigned char *pinend,\n \t FSE_TABLE.  */\n \n       pback = pin + hdr - 1;\n-      stream_start = *pback;\n-      if (unlikely (stream_start == 0))\n-\t{\n-\t  elf_uncompress_failed ();\n-\t  return 0;\n-\t}\n-      val = 0;\n-      bits = 0;\n-      while ((((uintptr_t)pback) & 3) != 0)\n-\t{\n-\t  val <<= 8;\n-\t  val |= (uint64_t)*pback;\n-\t  bits += 8;\n-\t  --pback;\n-\t}\n-      val <<= 8;\n-      val |= (uint64_t)*pback;\n-      bits += 8;\n-\n-      if (!elf_fetch_bits_backward (&pback, pfse, &val, &bits))\n-\treturn 0;\n-\n-      bits -= __builtin_clz (stream_start) - 24 + 1;\n \n-      if (!elf_fetch_bits_backward (&pback, pfse, &val, &bits))\n+      if (!elf_fetch_backward_init (&pback, pfse, &val, &bits))\n \treturn 0;\n \n       bits -= fse_table_bits;\n@@ -3702,331 +3726,615 @@ elf_zstd_read_huff (const unsigned char **ppin, const unsigned char *pinend,\n   return 1;\n }\n \n-/* The information used to decompress a sequence code, which can be a literal\n-   length, an offset, or a match length.  */\n+/* Read and decompress the literals and store them ending at POUTEND.  This\n+   works because we are going to use all the literals in the output, so they\n+   must fit into the output buffer.  HUFFMAN_TABLE, and PHUFFMAN_TABLE_BITS\n+   store the Huffman table across calls.  SCRATCH is used to read a Huffman\n+   table.  Store the start of the decompressed literals in *PPLIT.  Update\n+   *PPIN.  Return 1 on success, 0 on error.  */\n \n-struct elf_zstd_seq_decode\n+static int\n+elf_zstd_read_literals (const unsigned char **ppin,\n+\t\t\tconst unsigned char *pinend,\n+\t\t\tunsigned char *pout,\n+\t\t\tunsigned char *poutend,\n+\t\t\tuint16_t *scratch,\n+\t\t\tuint16_t *huffman_table,\n+\t\t\tint *phuffman_table_bits,\n+\t\t\tunsigned char **pplit)\n {\n-  const struct elf_zstd_fse_baseline_entry *table;\n-  int table_bits;\n-};\n+  const unsigned char *pin;\n+  unsigned char *plit;\n+  unsigned char hdr;\n+  uint32_t regenerated_size;\n+  uint32_t compressed_size;\n+  int streams;\n+  uint32_t total_streams_size;\n+  unsigned int huffman_table_bits;\n+  uint64_t huffman_mask;\n \n-/* Unpack a sequence code compression mode.  */\n+  pin = *ppin;\n+  if (unlikely (pin >= pinend))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n+  hdr = *pin;\n+  ++pin;\n \n-static int\n-elf_zstd_unpack_seq_decode (int mode,\n-\t\t\t    const unsigned char **ppin,\n-\t\t\t    const unsigned char *pinend,\n-\t\t\t    const struct elf_zstd_fse_baseline_entry *predef,\n-\t\t\t    int predef_bits,\n-\t\t\t    uint16_t *scratch,\n-\t\t\t    int maxidx,\n-\t\t\t    struct elf_zstd_fse_baseline_entry *table,\n-\t\t\t    int table_bits,\n-\t\t\t    int (*conv)(const struct elf_zstd_fse_entry *,\n-\t\t\t\t\tint,\n-\t\t\t\t\tstruct elf_zstd_fse_baseline_entry *),\n-\t\t\t    struct elf_zstd_seq_decode *decode)\n-{\n-  switch (mode)\n+  if ((hdr & 3) == 0 || (hdr & 3) == 1)\n     {\n-    case 0:\n-      decode->table = predef;\n-      decode->table_bits = predef_bits;\n-      break;\n+      int raw;\n \n-    case 1:\n-      {\n-\tstruct elf_zstd_fse_entry entry;\n+      /* Raw_literals_Block or RLE_Literals_Block */\n \n-\tif (unlikely (*ppin >= pinend))\n-\t  {\n-\t    elf_uncompress_failed ();\n-\t    return 0;\n-\t  }\n-\tentry.symbol = **ppin;\n-\t++*ppin;\n-\tentry.bits = 0;\n-\tentry.base = 0;\n-\tdecode->table_bits = 0;\n-\tif (!conv (&entry, 0, table))\n+      raw = (hdr & 3) == 0;\n+\n+      switch ((hdr >> 2) & 3)\n+\t{\n+\tcase 0: case 2:\n+\t  regenerated_size = hdr >> 3;\n+\t  break;\n+\tcase 1:\n+\t  if (unlikely (pin >= pinend))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\t  regenerated_size = (hdr >> 4) + ((uint32_t)(*pin) << 4);\n+\t  ++pin;\n+\t  break;\n+\tcase 3:\n+\t  if (unlikely (pin + 1 >= pinend))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\t  regenerated_size = ((hdr >> 4)\n+\t\t\t      + ((uint32_t)*pin << 4)\n+\t\t\t      + ((uint32_t)pin[1] << 12));\n+\t  pin += 2;\n+\t  break;\n+\tdefault:\n+\t  elf_uncompress_failed ();\n \t  return 0;\n-      }\n-      break;\n+\t}\n \n-    case 2:\n-      {\n-\tstruct elf_zstd_fse_entry *fse_table;\n+      if (unlikely ((size_t)(poutend - pout) < regenerated_size))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n \n-\t/* We use the same space for the simple FSE table and the baseline\n-\t   table.  */\n-\tfse_table = (struct elf_zstd_fse_entry *)table;\n-\tdecode->table_bits = table_bits;\n-\tif (!elf_zstd_read_fse (ppin, pinend, scratch, maxidx, fse_table,\n-\t\t\t\t&decode->table_bits))\n+      plit = poutend - regenerated_size;\n+\n+      if (raw)\n+\t{\n+\t  if (unlikely (pin + regenerated_size >= pinend))\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\t  memcpy (plit, pin, regenerated_size);\n+\t  pin += regenerated_size;\n+\t}\n+      else\n+\t{\n+\t  if (pin >= pinend)\n+\t    {\n+\t      elf_uncompress_failed ();\n+\t      return 0;\n+\t    }\n+\t  memset (plit, *pin, regenerated_size);\n+\t  ++pin;\n+\t}\n+\n+      *ppin = pin;\n+      *pplit = plit;\n+\n+      return 1;\n+    }\n+\n+  /* Compressed_Literals_Block or Treeless_Literals_Block */\n+\n+  switch ((hdr >> 2) & 3)\n+    {\n+    case 0: case 1:\n+      if (unlikely (pin + 1 >= pinend))\n+\t{\n+\t  elf_uncompress_failed ();\n \t  return 0;\n-\tif (!conv (fse_table, decode->table_bits, table))\n+\t}\n+      regenerated_size = (hdr >> 4) | ((uint32_t)(*pin & 0x3f) << 4);\n+      compressed_size = (uint32_t)*pin >> 6 | ((uint32_t)pin[1] << 2);\n+      pin += 2;\n+      streams = ((hdr >> 2) & 3) == 0 ? 1 : 4;\n+      break;\n+    case 2:\n+      if (unlikely (pin + 2 >= pinend))\n+\t{\n+\t  elf_uncompress_failed ();\n \t  return 0;\n-\tdecode->table = table;\n-      }\n+\t}\n+      regenerated_size = (((uint32_t)hdr >> 4)\n+\t\t\t  | ((uint32_t)*pin << 4)\n+\t\t\t  | (((uint32_t)pin[1] & 3) << 12));\n+      compressed_size = (((uint32_t)pin[1] >> 2)\n+\t\t\t | ((uint32_t)pin[2] << 6));\n+      pin += 3;\n+      streams = 4;\n       break;\n-\n     case 3:\n-      if (unlikely (decode->table_bits == -1))\n+      if (unlikely (pin + 3 >= pinend))\n \t{\n \t  elf_uncompress_failed ();\n \t  return 0;\n \t}\n+      regenerated_size = (((uint32_t)hdr >> 4)\n+\t\t\t  | ((uint32_t)*pin << 4)\n+\t\t\t  | (((uint32_t)pin[1] & 0x3f) << 12));\n+      compressed_size = (((uint32_t)pin[1] >> 6)\n+\t\t\t | ((uint32_t)pin[2] << 2)\n+\t\t\t | ((uint32_t)pin[3] << 10));\n+      pin += 4;\n+      streams = 4;\n       break;\n-\n     default:\n       elf_uncompress_failed ();\n       return 0;\n     }\n \n-  return 1;\n-}\n-\n-/* The different ways that the literals are encoded.  */\n-\n-#define ZSTD_LIT_RAW (0)\n-#define ZSTD_LIT_RLE (1)\n-#define ZSTD_LIT_HUFF (2)\n-\n-/* A struct used to decompress the literals.  The order of these fields is\n-   chosen for packing, not for comprehensibility.  */\n-\n-struct elf_zstd_literals\n-{\n-  /* Current bits in Huffman encoded stream.  */\n-  uint64_t val;\n-\n-  /* For RAW, the current position in the byte stream.\n-     For RLE, a pointer to the byte being repeated.\n-     For HUFF, start of encoded streams.\n-  */\n-  const unsigned char *plit;\n+  if (unlikely (pin + compressed_size > pinend))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n \n-  /* Current position of current Huffman encoded stream.  */\n-  const unsigned char *pback;\n+  pinend = pin + compressed_size;\n+  *ppin = pinend;\n \n-  /* End (reading backward) of current Huffman encoded stream.  */\n-  const unsigned char *pbackend;\n+  if (unlikely ((size_t)(poutend - pout) < regenerated_size))\n+    {\n+      elf_uncompress_failed ();\n+      return 0;\n+    }\n \n-  /* The Huffman table.  */\n-  const uint16_t *huffman_table;\n+  plit = poutend - regenerated_size;\n \n-  /* Remaining number of uncompressed bytes.  */\n-  uint32_t regenerated_size;\n+  *pplit = plit;\n \n-  /* Current number of available bits in Huffman encoded stream.  */\n-  unsigned int bits;\n+  total_streams_size = compressed_size;\n+  if ((hdr & 3) == 2)\n+    {\n+      const unsigned char *ptable;\n \n-  /* Number of bits in the Huffman table.  */\n-  int huffman_table_bits;\n+      /* Compressed_Literals_Block.  Read Huffman tree.  */\n \n-  /* Offsets from PLIT to next Huffman encoded streams, 0 if none.  */\n-  uint32_t stream_off[3];\n+      ptable = pin;\n+      if (!elf_zstd_read_huff (&ptable, pinend, scratch, huffman_table,\n+\t\t\t       phuffman_table_bits))\n+\treturn 0;\n \n-  /* Sizes of next Huffman encoded streams, 0 if none.  */\n-  uint32_t stream_size[3];\n+      if (unlikely (total_streams_size < (size_t)(ptable - pin)))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n \n-  /* A ZSTD_LIT_* code.  */\n-  unsigned char type;\n-};\n+      total_streams_size -= ptable - pin;\n+      pin = ptable;\n+    }\n+  else\n+    {\n+      /* Treeless_Literals_Block.  Reuse previous Huffman tree.  */\n+      if (unlikely (*phuffman_table_bits == 0))\n+\t{\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n+\t}\n+    }\n \n-/* Output COUNT bytes from the literal byte stream in LITERALS to POUT.  */\n+  /* Decompress COMPRESSED_SIZE bytes of data at PIN using the huffman table,\n+     storing REGENERATED_SIZE bytes of decompressed data at PLIT.  */\n \n-static int\n-elf_zstd_literal_output (struct elf_zstd_literals *literals,\n-\t\t\t size_t count,\n-\t\t\t unsigned char *pout)\n-{\n-  size_t i;\n-  const unsigned char *pback;\n-  const unsigned char *pbackend;\n-  uint64_t val;\n-  unsigned int bits;\n-  const uint16_t *huffman_table;\n-  unsigned int huffman_table_bits;\n-  uint64_t huffman_mask;\n+  huffman_table_bits = (unsigned int)*phuffman_table_bits;\n+  huffman_mask = ((uint64_t)1 << huffman_table_bits) - 1;\n \n-  if (literals->regenerated_size < count)\n+  if (streams == 1)\n     {\n-      elf_uncompress_failed ();\n-      return 0;\n-    }\n-  literals->regenerated_size -= count;\n+      const unsigned char *pback;\n+      const unsigned char *pbackend;\n+      uint64_t val;\n+      unsigned int bits;\n+      uint32_t i;\n \n-  switch (literals->type)\n-    {\n-    case ZSTD_LIT_RAW:\n-      memcpy (pout, literals->plit, count);\n-      literals->plit += count;\n-      return 1;\n+      pback = pin + compressed_size - 1;\n+      pbackend = pin;\n+      if (!elf_fetch_backward_init (&pback, pbackend, &val, &bits))\n+\treturn 0;\n \n-    case ZSTD_LIT_RLE:\n-      memset (pout, *literals->plit, count);\n-      return 1;\n+      /* This is one of the inner loops of the decompression algorithm, so we\n+\t put some effort into optimization.  We can't get more than 64 bytes\n+\t from a single call to elf_fetch_bits_backward, and we can't subtract\n+\t more than 11 bits at a time.  */\n \n-    case ZSTD_LIT_HUFF:\n-      break;\n+      if (regenerated_size >= 64)\n+\t{\n+\t  unsigned char *plitstart;\n+\t  unsigned char *plitstop;\n \n-    default:\n-      elf_uncompress_failed ();\n-      return 0;\n-    }\n+\t  plitstart = plit;\n+\t  plitstop = plit + regenerated_size - 64;\n+\t  while (plit < plitstop)\n+\t    {\n+\t      uint16_t t;\n \n-  /* The literal string is Huffman encoded.  */\n+\t      if (!elf_fetch_bits_backward (&pback, pbackend, &val, &bits))\n+\t\treturn 0;\n \n-  pback = literals->pback;\n-  pbackend = literals->pbackend;\n-  val = literals->val;\n-  bits = literals->bits;\n+\t      if (bits < 16)\n+\t\tbreak;\n \n-  huffman_table = literals->huffman_table;\n-  huffman_table_bits = literals->huffman_table_bits;\n-  huffman_mask = ((uint64_t)1 << huffman_table_bits) - 1;\n+\t      while (bits >= 33)\n+\t\t{\n+\t\t  t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t\t\t\t    & huffman_mask];\n+\t\t  *plit = t >> 8;\n+\t\t  ++plit;\n+\t\t  bits -= t & 0xff;\n+\n+\t\t  t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t\t\t\t    & huffman_mask];\n+\t\t  *plit = t >> 8;\n+\t\t  ++plit;\n+\t\t  bits -= t & 0xff;\n+\n+\t\t  t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t\t\t\t    & huffman_mask];\n+\t\t  *plit = t >> 8;\n+\t\t  ++plit;\n+\t\t  bits -= t & 0xff;\n+\t\t}\n \n-  /* This is one of the inner loops of the decompression algorithm, so we put\n-     some effort into optimization.  We can't get more than 64 bytes from a\n-     single call to elf_fetch_bits_backward, and we can't subtract more than 11\n-     bits at a time.  */\n+\t      while (bits > 11)\n+\t\t{\n+\t\t  t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t\t\t\t    & huffman_mask];\n+\t\t  *plit = t >> 8;\n+\t\t  ++plit;\n+\t\t  bits -= t & 0xff;\n+\t\t}\n+\t    }\n \n-  if (count >= 64)\n-    {\n-      unsigned char *poutstart;\n-      unsigned char *poutstop;\n+\t  regenerated_size -= plit - plitstart;\n+\t}\n \n-      poutstart = pout;\n-      poutstop = pout + count - 64;\n-      while (pout <= poutstop)\n+      for (i = 0; i < regenerated_size; ++i)\n \t{\n \t  uint16_t t;\n \n \t  if (!elf_fetch_bits_backward (&pback, pbackend, &val, &bits))\n \t    return 0;\n \n-\t  if (bits < 16)\n-\t    break;\n-\n-\t  while (bits >= 33)\n+\t  if (unlikely (bits < huffman_table_bits))\n \t    {\n-\t      t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t      t = huffman_table[(val << (huffman_table_bits - bits))\n \t\t\t\t& huffman_mask];\n-\t      *pout = t >> 8;\n-\t      ++pout;\n-\t      bits -= t & 0xff;\n-\n-\t      t = huffman_table[(val >> (bits - huffman_table_bits))\n-\t\t\t\t& huffman_mask];\n-\t      *pout = t >> 8;\n-\t      ++pout;\n-\t      bits -= t & 0xff;\n-\n-\t      t = huffman_table[(val >> (bits - huffman_table_bits))\n-\t\t\t\t& huffman_mask];\n-\t      *pout = t >> 8;\n-\t      ++pout;\n-\t      bits -= t & 0xff;\n+\t      if (unlikely (bits < (t & 0xff)))\n+\t\t{\n+\t\t  elf_uncompress_failed ();\n+\t\t  return 0;\n+\t\t}\n \t    }\n+\t  else\n+\t    t = huffman_table[(val >> (bits - huffman_table_bits))\n+\t\t\t      & huffman_mask];\n \n-\t  while (bits > 11)\n-\t    {\n-\t      t = huffman_table[(val >> (bits - huffman_table_bits))\n-\t\t\t\t& huffman_mask];\n-\t      *pout = t >> 8;\n-\t      ++pout;\n-\t      bits -= t & 0xff;\n-\t    }\n+\t  *plit = t >> 8;\n+\t  ++plit;\n+\t  bits -= t & 0xff;\n \t}\n \n-      count -= pout - poutstart;\n+      return 1;\n+    }\n \n-      if (!elf_fetch_bits_backward (&pback, pbackend, &val, &bits))\n+  {\n+    uint32_t stream_size1, stream_size2, stream_size3, stream_size4;\n+    uint32_t tot;\n+    const unsigned char *pback1, *pback2, *pback3, *pback4;\n+    const unsigned char *pbackend1, *pbackend2, *pbackend3, *pbackend4;\n+    uint64_t val1, val2, val3, val4;\n+    unsigned int bits1, bits2, bits3, bits4;\n+    unsigned char *plit1, *plit2, *plit3, *plit4;\n+    uint32_t regenerated_stream_size;\n+    uint32_t regenerated_stream_size4;\n+    uint16_t t1, t2, t3, t4;\n+    uint32_t i;\n+    uint32_t limit;\n+\n+    /* Read jump table.  */\n+    if (unlikely (pin + 5 >= pinend))\n+      {\n+\telf_uncompress_failed ();\n \treturn 0;\n-    }\n+      }\n+    stream_size1 = (uint32_t)*pin | ((uint32_t)pin[1] << 8);\n+    pin += 2;\n+    stream_size2 = (uint32_t)*pin | ((uint32_t)pin[1] << 8);\n+    pin += 2;\n+    stream_size3 = (uint32_t)*pin | ((uint32_t)pin[1] << 8);\n+    pin += 2;\n+    tot = stream_size1 + stream_size2 + stream_size3;\n+    if (unlikely (tot > total_streams_size - 6))\n+      {\n+\telf_uncompress_failed ();\n+\treturn 0;\n+      }\n+    stream_size4 = total_streams_size - 6 - tot;\n \n-  for (i = 0; i < count; ++i)\n-    {\n-      uint16_t t;\n+    pback1 = pin + stream_size1 - 1;\n+    pbackend1 = pin;\n \n-      if (unlikely (bits == 0))\n-\t{\n-\t  unsigned char stream_start;\n+    pback2 = pback1 + stream_size2;\n+    pbackend2 = pback1 + 1;\n \n-\t  /* Advance to next stream.  */\n-\t  if (unlikely (literals->stream_off[0] == 0))\n-\t    {\n-\t      elf_uncompress_failed ();\n-\t      return 0;\n-\t    }\n+    pback3 = pback2 + stream_size3;\n+    pbackend3 = pback2 + 1;\n \n-\t  pback = literals->plit + literals->stream_off[0];\n-\t  pbackend = pback;\n-\t  pback += literals->stream_size[0];\n+    pback4 = pback3 + stream_size4;\n+    pbackend4 = pback3 + 1;\n \n-\t  /* Align to a 32-bit boundary.  */\n-\t  val = 0;\n-\t  bits = 0;\n-\t  --pback;\n-\t  stream_start = *pback;\n-\t  if (unlikely (stream_start == 0))\n-\t    {\n-\t      elf_uncompress_failed ();\n+    if (!elf_fetch_backward_init (&pback1, pbackend1, &val1, &bits1))\n+      return 0;\n+    if (!elf_fetch_backward_init (&pback2, pbackend2, &val2, &bits2))\n+      return 0;\n+    if (!elf_fetch_backward_init (&pback3, pbackend3, &val3, &bits3))\n+      return 0;\n+    if (!elf_fetch_backward_init (&pback4, pbackend4, &val4, &bits4))\n+      return 0;\n+\n+    regenerated_stream_size = (regenerated_size + 3) / 4;\n+\n+    plit1 = plit;\n+    plit2 = plit1 + regenerated_stream_size;\n+    plit3 = plit2 + regenerated_stream_size;\n+    plit4 = plit3 + regenerated_stream_size;\n+\n+    regenerated_stream_size4 = regenerated_size - regenerated_stream_size * 3;\n+\n+    /* We can't get more than 64 literal bytes from a single call to\n+       elf_fetch_bits_backward.  The fourth stream can be up to 3 bytes less,\n+       so use as the limit.  */\n+\n+    limit = regenerated_stream_size4 <= 64 ? 0 : regenerated_stream_size4 - 64;\n+    i = 0;\n+    while (i < limit)\n+      {\n+\tif (!elf_fetch_bits_backward (&pback1, pbackend1, &val1, &bits1))\n+\t  return 0;\n+\tif (!elf_fetch_bits_backward (&pback2, pbackend2, &val2, &bits2))\n+\t  return 0;\n+\tif (!elf_fetch_bits_backward (&pback3, pbackend3, &val3, &bits3))\n+\t  return 0;\n+\tif (!elf_fetch_bits_backward (&pback4, pbackend4, &val4, &bits4))\n+\t  return 0;\n+\n+\t/* We can't subtract more than 11 bits at a time.  */\n+\n+\tdo\n+\t  {\n+\t    t1 = huffman_table[(val1 >> (bits1 - huffman_table_bits))\n+\t\t\t       & huffman_mask];\n+\t    t2 = huffman_table[(val2 >> (bits2 - huffman_table_bits))\n+\t\t\t       & huffman_mask];\n+\t    t3 = huffman_table[(val3 >> (bits3 - huffman_table_bits))\n+\t\t\t       & huffman_mask];\n+\t    t4 = huffman_table[(val4 >> (bits4 - huffman_table_bits))\n+\t\t\t       & huffman_mask];\n+\n+\t    *plit1 = t1 >> 8;\n+\t    ++plit1;\n+\t    bits1 -= t1 & 0xff;\n+\n+\t    *plit2 = t2 >> 8;\n+\t    ++plit2;\n+\t    bits2 -= t2 & 0xff;\n+\n+\t    *plit3 = t3 >> 8;\n+\t    ++plit3;\n+\t    bits3 -= t3 & 0xff;\n+\n+\t    *plit4 = t4 >> 8;\n+\t    ++plit4;\n+\t    bits4 -= t4 & 0xff;\n+\n+\t    ++i;\n+\t  }\n+\twhile (bits1 > 11 && bits2 > 11 && bits3 > 11 && bits4 > 11);\n+      }\n+\n+    while (i < regenerated_stream_size)\n+      {\n+\tint use4;\n+\n+\tuse4 = i < regenerated_stream_size4;\n+\n+\tif (!elf_fetch_bits_backward (&pback1, pbackend1, &val1, &bits1))\n+\t  return 0;\n+\tif (!elf_fetch_bits_backward (&pback2, pbackend2, &val2, &bits2))\n+\t  return 0;\n+\tif (!elf_fetch_bits_backward (&pback3, pbackend3, &val3, &bits3))\n+\t  return 0;\n+\tif (use4)\n+\t  {\n+\t    if (!elf_fetch_bits_backward (&pback4, pbackend4, &val4, &bits4))\n \t      return 0;\n-\t    }\n-\t  while ((((uintptr_t) pback) & 3) != 0)\n-\t    {\n-\t      val <<= 8;\n-\t      val |= (uint64_t)*pback;\n-\t      bits += 8;\n-\t      --pback;\n-\t    }\n-\t  val <<= 8;\n-\t  val |= (uint64_t)*pback;\n-\t  bits += 8;\n+\t  }\n \n-\t  if (!elf_fetch_bits_backward (&pback, pbackend, &val, &bits))\n-\t    return 0;\n+\tif (unlikely (bits1 < huffman_table_bits))\n+\t  {\n+\t    t1 = huffman_table[(val1 << (huffman_table_bits - bits1))\n+\t\t\t       & huffman_mask];\n+\t    if (unlikely (bits1 < (t1 & 0xff)))\n+\t      {\n+\t\telf_uncompress_failed ();\n+\t\treturn 0;\n+\t      }\n+\t  }\n+\telse\n+\t  t1 = huffman_table[(val1 >> (bits1 - huffman_table_bits))\n+\t\t\t     & huffman_mask];\n \n-\t  bits -= __builtin_clz (stream_start) - 24 + 1;\n+\tif (unlikely (bits2 < huffman_table_bits))\n+\t  {\n+\t    t2 = huffman_table[(val2 << (huffman_table_bits - bits2))\n+\t\t\t       & huffman_mask];\n+\t    if (unlikely (bits2 < (t2 & 0xff)))\n+\t      {\n+\t\telf_uncompress_failed ();\n+\t\treturn 0;\n+\t      }\n+\t  }\n+\telse\n+\t  t2 = huffman_table[(val2 >> (bits2 - huffman_table_bits))\n+\t\t\t     & huffman_mask];\n \n-\t  literals->stream_off[0] = literals->stream_off[1];\n-\t  literals->stream_off[1] = literals->stream_off[2];\n-\t  literals->stream_off[2] = 0;\n-\t  literals->stream_size[0] = literals->stream_size[1];\n-\t  literals->stream_size[1] = literals->stream_size[2];\n-\t  literals->stream_size[2] = 0;\n-\t}\n+\tif (unlikely (bits3 < huffman_table_bits))\n+\t  {\n+\t    t3 = huffman_table[(val3 << (huffman_table_bits - bits3))\n+\t\t\t       & huffman_mask];\n+\t    if (unlikely (bits3 < (t3 & 0xff)))\n+\t      {\n+\t\telf_uncompress_failed ();\n+\t\treturn 0;\n+\t      }\n+\t  }\n+\telse\n+\t  t3 = huffman_table[(val3 >> (bits3 - huffman_table_bits))\n+\t\t\t     & huffman_mask];\n \n-      if (!elf_fetch_bits_backward (&pback, pbackend, &val, &bits))\n-\treturn 0;\n+\tif (use4)\n+\t  {\n+\t    if (unlikely (bits4 < huffman_table_bits))\n+\t      {\n+\t\tt4 = huffman_table[(val4 << (huffman_table_bits - bits4))\n+\t\t\t\t   & huffman_mask];\n+\t\tif (unlikely (bits4 < (t4 & 0xff)))\n+\t\t  {\n+\t\t    elf_uncompress_failed ();\n+\t\t    return 0;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      t4 = huffman_table[(val4 >> (bits4 - huffman_table_bits))\n+\t\t\t\t & huffman_mask];\n+\n+\t    *plit4 = t4 >> 8;\n+\t    ++plit4;\n+\t    bits4 -= t4 & 0xff;\n+\t  }\n+\n+\t*plit1 = t1 >> 8;\n+\t++plit1;\n+\tbits1 -= t1 & 0xff;\n+\n+\t*plit2 = t2 >> 8;\n+\t++plit2;\n+\tbits2 -= t2 & 0xff;\n+\n+\t*plit3 = t3 >> 8;\n+\t++plit3;\n+\tbits3 -= t3 & 0xff;\n+\n+\t++i;\n+      }\n+  }\n+\n+  return 1;\n+}\n+\n+/* The information used to decompress a sequence code, which can be a literal\n+   length, an offset, or a match length.  */\n+\n+struct elf_zstd_seq_decode\n+{\n+  const struct elf_zstd_fse_baseline_entry *table;\n+  int table_bits;\n+};\n+\n+/* Unpack a sequence code compression mode.  */\n \n-      if (unlikely (bits < huffman_table_bits))\n+static int\n+elf_zstd_unpack_seq_decode (int mode,\n+\t\t\t    const unsigned char **ppin,\n+\t\t\t    const unsigned char *pinend,\n+\t\t\t    const struct elf_zstd_fse_baseline_entry *predef,\n+\t\t\t    int predef_bits,\n+\t\t\t    uint16_t *scratch,\n+\t\t\t    int maxidx,\n+\t\t\t    struct elf_zstd_fse_baseline_entry *table,\n+\t\t\t    int table_bits,\n+\t\t\t    int (*conv)(const struct elf_zstd_fse_entry *,\n+\t\t\t\t\tint,\n+\t\t\t\t\tstruct elf_zstd_fse_baseline_entry *),\n+\t\t\t    struct elf_zstd_seq_decode *decode)\n+{\n+  switch (mode)\n+    {\n+    case 0:\n+      decode->table = predef;\n+      decode->table_bits = predef_bits;\n+      break;\n+\n+    case 1:\n+      {\n+\tstruct elf_zstd_fse_entry entry;\n+\n+\tif (unlikely (*ppin >= pinend))\n+\t  {\n+\t    elf_uncompress_failed ();\n+\t    return 0;\n+\t  }\n+\tentry.symbol = **ppin;\n+\t++*ppin;\n+\tentry.bits = 0;\n+\tentry.base = 0;\n+\tdecode->table_bits = 0;\n+\tif (!conv (&entry, 0, table))\n+\t  return 0;\n+      }\n+      break;\n+\n+    case 2:\n+      {\n+\tstruct elf_zstd_fse_entry *fse_table;\n+\n+\t/* We use the same space for the simple FSE table and the baseline\n+\t   table.  */\n+\tfse_table = (struct elf_zstd_fse_entry *)table;\n+\tdecode->table_bits = table_bits;\n+\tif (!elf_zstd_read_fse (ppin, pinend, scratch, maxidx, fse_table,\n+\t\t\t\t&decode->table_bits))\n+\t  return 0;\n+\tif (!conv (fse_table, decode->table_bits, table))\n+\t  return 0;\n+\tdecode->table = table;\n+      }\n+      break;\n+\n+    case 3:\n+      if (unlikely (decode->table_bits == -1))\n \t{\n-\t  t = huffman_table[(val << (huffman_table_bits - bits))\n-\t\t\t    & huffman_mask];\n-\t  if (unlikely (bits < (t & 0xff)))\n-\t    {\n-\t      elf_uncompress_failed ();\n-\t      return 0;\n-\t    }\n+\t  elf_uncompress_failed ();\n+\t  return 0;\n \t}\n-      else\n-\tt = huffman_table[(val >> (bits - huffman_table_bits)) & huffman_mask];\n-\n-      *pout = t >> 8;\n-      ++pout;\n+      break;\n \n-      bits -= t & 0xff;\n+    default:\n+      elf_uncompress_failed ();\n+      return 0;\n     }\n \n-  literals->pback = pback;\n-  literals->pbackend = pbackend;\n-  literals->val = val;\n-  literals->bits = bits;\n-\n   return 1;\n }\n \n@@ -4250,16 +4558,9 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \tcase 2:\n \t  {\n \t    const unsigned char *pblockend;\n-\t    struct elf_zstd_literals literals;\n-\t    unsigned char lit_hdr;\n-\t    uint32_t lit_section_content;\n-\t    uint32_t lit_compressed_size;\n-\t    uint32_t lit_total_streams_size;\n-\t    const unsigned char *plitend;\n-\t    unsigned char *plitexp;\n-\t    size_t litexp_count;\n-\t    int lit_streams;\n-\t    uint32_t stream_size_1;\n+\t    unsigned char *plitstack;\n+\t    unsigned char *plit;\n+\t    uint32_t literal_count;\n \t    unsigned char seq_hdr;\n \t    size_t seq_count;\n \t    size_t seq;\n@@ -4269,7 +4570,6 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \t    unsigned int literal_state;\n \t    unsigned int offset_state;\n \t    unsigned int match_state;\n-\t    unsigned char stream_start;\n \n \t    /* Compressed_Block */\n \t    if (unlikely ((size_t) block_size > (size_t) (pinend - pin)))\n@@ -4280,248 +4580,16 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \n \t    pblockend = pin + block_size;\n \n-\t    if (unlikely (pin >= pinend))\n-\t      {\n-\t\telf_uncompress_failed ();\n-\t\treturn 0;\n-\t      }\n-\t    lit_hdr = *pin;\n-\t    ++pin;\n-\n-\t    if ((lit_hdr & 3) == 0 || (lit_hdr & 3) == 1)\n-\t      {\n-\t\tif ((lit_hdr & 3) == 0)\n-\t\t  literals.type = ZSTD_LIT_RAW;\n-\t\telse\n-\t\t  literals.type = ZSTD_LIT_RLE;\n-\n-\t\t/* Raw_literals_Block or RLE_Literals_Block */\n-\t\tswitch ((lit_hdr >> 2) & 3)\n-\t\t  {\n-\t\t  case 0: case 2:\n-\t\t    literals.regenerated_size = lit_hdr >> 3;\n-\t\t    break;\n-\t\t  case 1:\n-\t\t    if (unlikely (pin >= pinend))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n-\t\t    literals.regenerated_size = (lit_hdr >> 4) + ((*pin) << 4);\n-\t\t    pin++;\n-\t\t    break;\n-\t\t  case 3:\n-\t\t    if (unlikely (pin + 1 >= pinend))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n-\t\t    literals.regenerated_size = ((lit_hdr >> 4)\n-\t\t\t\t\t\t + (*pin << 4)\n-\t\t\t\t\t\t + (pin[1] << 12));\n-\t\t    pin += 2;\n-\t\t    break;\n-\t\t  default:\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\t\tif (literals.type == ZSTD_LIT_RAW)\n-\t\t  lit_section_content = literals.regenerated_size;\n-\t\telse\n-\t\t  lit_section_content = 1;\n-\t\tlit_compressed_size = 0;\n-\t\tlit_streams = 1;\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Compressed_Literals_Block or Treeless_Literals_Block */\n-\t\tliterals.type = ZSTD_LIT_HUFF;\n-\t\tswitch ((lit_hdr >> 2) & 3)\n-\t\t  {\n-\t\t  case 0: case 1:\n-\t\t    if (unlikely (pin + 1 >= pinend))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n-\t\t    literals.regenerated_size = ((lit_hdr >> 4)\n-\t\t\t\t\t\t | ((*pin & 0x3f) << 4));\n-\t\t    lit_compressed_size = ((*pin >> 6)\n-\t\t\t\t\t   | (pin[1] << 2));\n-\t\t    pin += 2;\n-\t\t    lit_streams = ((lit_hdr >> 2) & 3) == 0 ? 1 : 4;\n-\t\t    break;\n-\t\t  case 2:\n-\t\t    if (unlikely (pin + 2 >= pinend))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n-\t\t    literals.regenerated_size = ((lit_hdr >> 4)\n-\t\t\t\t\t\t | (*pin << 4)\n-\t\t\t\t\t\t | ((pin[1] & 3) << 12));\n-\t\t    lit_compressed_size = ((pin[1] >> 2)\n-\t\t\t\t\t   | (pin[2] << 6));\n-\t\t    pin += 3;\n-\t\t    lit_streams = 4;\n-\t\t    break;\n-\t\t  case 3:\n-\t\t    if (unlikely (pin + 3 >= pinend))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n-\t\t    literals.regenerated_size = ((lit_hdr >> 4)\n-\t\t\t\t\t\t | (*pin << 4)\n-\t\t\t\t\t\t | ((pin[1] & 0x3f) << 12));\n-\t\t    lit_compressed_size = ((pin[1] >> 6)\n-\t\t\t\t\t   | (pin[2] << 2)\n-\t\t\t\t\t   | (pin[3] << 10));\n-\t\t    pin += 4;\n-\t\t    lit_streams = 4;\n-\t\t    break;\n-\t\t  default:\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\n-\t\tlit_section_content = lit_compressed_size;\n-\t      }\n-\n-\t    if (unlikely ((size_t)lit_section_content > (size_t)(pinend - pin)))\n-\t      {\n-\t\telf_uncompress_failed ();\n-\t\treturn 0;\n-\t      }\n-\t    plitend = pin + lit_section_content;\n-\n-\t    lit_total_streams_size = lit_compressed_size;\n-\t    if ((lit_hdr & 3) == 2)\n-\t      {\n-\t\t/* Compressed_Literals_Block.  Read Huffman tree.  */\n-\n-\t\tconst unsigned char *ptable;\n-\n-\t\tptable = pin;\n-\t\tif (!elf_zstd_read_huff (&ptable, pinend, scratch,\n-\t\t\t\t\t huffman_table, &huffman_table_bits))\n-\t\t  return 0;\n-\t\tliterals.huffman_table = huffman_table;\n-\t\tliterals.huffman_table_bits = huffman_table_bits;\n-\n-\t\tlit_total_streams_size -= ptable - pin;\n-\t\tpin = ptable;\n-\t      }\n-\t    else if ((lit_hdr & 3) == 3)\n-\t      {\n-\t\t/* Treeless_Literals_Block.  Reuse previous Huffman tree.  */\n-\t\tif (huffman_table_bits == 0)\n-\t\t  {\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\t\tliterals.huffman_table = huffman_table;\n-\t\tliterals.huffman_table_bits = huffman_table_bits;\n-\t      }\n-\t    else\n-\t      {\n-\t\tliterals.huffman_table = NULL;\n-\t\tliterals.huffman_table_bits = 0;\n-\t      }\n+\t    /* Read the literals into the end of the output space, and leave\n+\t       PLIT pointing at them.  */\n \n-\t    if (lit_streams == 1)\n-\t      {\n-\t\tstream_size_1 = block_size;\n-\t\tliterals.stream_off[0] = 0;\n-\t\tliterals.stream_off[1] = 0;\n-\t\tliterals.stream_off[2] = 0;\n-\t\tliterals.stream_size[0] = 0;\n-\t\tliterals.stream_size[1] = 0;\n-\t\tliterals.stream_size[2] = 0;\n-\t      }\n-\t    else\n-\t      {\n-\t\tuint32_t tot;\n-\n-\t\t/* Read jump table.  */\n-\t\tif (unlikely (pin + 5 >= pinend))\n-\t\t  {\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\t\tstream_size_1 = *pin | (pin[1] << 8);\n-\t\tpin += 2;\n-\t\tliterals.stream_size[0] = *pin | (pin[1] << 8);\n-\t\tpin += 2;\n-\t\tliterals.stream_size[1] = *pin | (pin[1] << 8);\n-\t\tpin += 2;\n-\t\ttot = (stream_size_1\n-\t\t       + literals.stream_size[0]\n-\t\t       + literals.stream_size[1]);\n-\t\tif (unlikely (tot > lit_total_streams_size - 6))\n-\t\t  {\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\t\tliterals.stream_size[2] = lit_total_streams_size - 6 - tot;\n-\n-\t\tliterals.stream_off[0] = stream_size_1;\n-\t\tliterals.stream_off[1] = (literals.stream_off[0]\n-\t\t\t\t\t  + literals.stream_size[0]);\n-\t\tliterals.stream_off[2] = (literals.stream_off[1]\n-\t\t\t\t\t  + literals.stream_size[1]);\n-\t      }\n-\n-\t    literals.plit = pin;\n-\n-\t    if (literals.type == ZSTD_LIT_HUFF)\n-\t      {\n-\t\tconst unsigned char *plback;\n-\n-\t\t/* Set up the first huffman stream.  */\n-\n-\t\tliterals.pbackend = literals.plit;\n-\t\tplback = literals.plit + stream_size_1;\n-\t\tliterals.val = 0;\n-\t\tliterals.bits = 0;\n-\t\t--plback;\n-\t\tstream_start = *plback;\n-\t\tif (unlikely (stream_start == 0))\n-\t\t  {\n-\t\t    elf_uncompress_failed ();\n-\t\t    return 0;\n-\t\t  }\n-\t\twhile ((((uintptr_t) plback) & 3) != 0)\n-\t\t  {\n-\t\t    literals.val <<= 8;\n-\t\t    literals.val |= (uint64_t)*plback;\n-\t\t    literals.bits += 8;\n-\t\t    --plback;\n-\t\t  }\n-\t\tliterals.val <<= 8;\n-\t\tliterals.val |= (uint64_t)*plback;\n-\t\tliterals.bits += 8;\n-\n-\t\tif (!elf_fetch_bits_backward (&plback, literals.pbackend,\n-\t\t\t\t\t      &literals.val, &literals.bits))\n-\t\t  return 0;\n-\n-\t\tliterals.bits -= __builtin_clz (stream_start) - 24 + 1;\n-\n-\t\tliterals.pback = plback;\n-\t      }\n-\t    else\n-\t      {\n-\t\tliterals.val = 0;\n-\t\tliterals.bits = 0;\n-\t\tliterals.pback = NULL;\n-\t\tliterals.pbackend = NULL;\n-\t      }\n-\n-\t    /* We have read all the literal header information.  The literal\n-\t       data starts at LITERALS.PLIT.  Skip ahead to the sequences.  */\n-\n-\t    pin = plitend;\n+\t    if (!elf_zstd_read_literals (&pin, pblockend, pout, poutend,\n+\t\t\t\t\t scratch, huffman_table,\n+\t\t\t\t\t &huffman_table_bits,\n+\t\t\t\t\t &plitstack))\n+\t      return 0;\n+\t    plit = plitstack;\n+\t    literal_count = poutend - plit;\n \n \t    seq_hdr = *pin;\n \t    pin++;\n@@ -4589,53 +4657,10 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \t\t  return 0;\n \t      }\n \n-\t    /* Expand 2048 bytes of literals.  The expanded literals are\n-\t       recorded in PLITEXP and LITEXP_COUNT.  */\n-\n-\t    if (literals.type != ZSTD_LIT_HUFF\n-\t\t|| literals.regenerated_size == 0)\n-\t      {\n-\t\tplitexp = NULL;\n-\t\tlitexp_count = 0;\n-\t      }\n-\t    else\n-\t      {\n-\t\tplitexp = (unsigned char *)scratch;\n-\t\tlitexp_count = ZSTD_TABLE_WORK_LIT_SIZE;\n-\t\tif (litexp_count > literals.regenerated_size)\n-\t\t  litexp_count = literals.regenerated_size;\n-\t\tif (!elf_zstd_literal_output (&literals, litexp_count,\n-\t\t\t\t\t      plitexp))\n-\t\t  return 0;\n-\t      }\n-\n \t    pback = pblockend - 1;\n-\t    val = 0;\n-\t    bits = 0;\n-\t    stream_start = *pback;\n-\t    if (unlikely (stream_start == 0))\n-\t      {\n-\t\telf_uncompress_failed ();\n-\t\treturn 0;\n-\t      }\n-\t    while ((((uintptr_t)pback) & 3) != 0)\n-\t      {\n-\t\tval <<= 8;\n-\t\tval |= (uint64_t)*pback;\n-\t\tbits += 8;\n-\t\t--pback;\n-\t      }\n-\t    val <<= 8;\n-\t    val |= (uint64_t)*pback;\n-\t    bits += 8;\n-\n-\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n+\t    if (!elf_fetch_backward_init (&pback, pin, &val, &bits))\n \t      return 0;\n \n-\t    bits -= __builtin_clz (stream_start) - 24 + 1;\n-\n-\t    if (!elf_fetch_bits_backward (&pback, pin, &val, &bits))\n-\t      return 0;\n \t    bits -= literal_decode.table_bits;\n \t    literal_state = ((val >> bits)\n \t\t\t     & ((1U << literal_decode.table_bits) - 1));\n@@ -4808,66 +4833,71 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \n \t\t/* The next sequence is now in LITERAL, OFFSET, MATCH.  */\n \n-\t\tif (literal > 0)\n+\t\t/* Copy LITERAL bytes from the literals.  */\n+\n+\t\tif (unlikely ((size_t)(poutend - pout) < literal))\n \t\t  {\n-\t\t    /* Copy LITERAL bytes from the literals.  */\n+\t\t    elf_uncompress_failed ();\n+\t\t    return 0;\n+\t\t  }\n \n-\t\t    if (unlikely ((size_t)(poutend - pout) < literal))\n-\t\t      {\n-\t\t\telf_uncompress_failed ();\n-\t\t\treturn 0;\n-\t\t      }\n+\t\tif (unlikely (literal_count < literal))\n+\t\t  {\n+\t\t    elf_uncompress_failed ();\n+\t\t    return 0;\n+\t\t  }\n \n-\t\t    if (literals.type != ZSTD_LIT_HUFF)\n-\t\t      {\n-\t\t\tif (!elf_zstd_literal_output (&literals, literal,\n-\t\t\t\t\t\t      pout))\n-\t\t\t  return 0;\n-\t\t\tpout += literal;\n-\t\t      }\n-\t\t    else if (literal <= litexp_count)\n-\t\t      {\n-\t\t\tmemcpy (pout, plitexp, literal);\n-\t\t\tplitexp += literal;\n-\t\t\tlitexp_count -= literal;\n-\t\t\tpout += literal;\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\tmemcpy (pout, plitexp, litexp_count);\n-\t\t\tpout += litexp_count;\n-\t\t\tliteral -= litexp_count;\n-\t\t\tlitexp_count = 0;\n+\t\tliteral_count -= literal;\n \n-\t\t\tif (unlikely (literal >= ZSTD_TABLE_WORK_LIT_SIZE))\n-\t\t\t  {\n-\t\t\t    if (!elf_zstd_literal_output (&literals, literal,\n-\t\t\t\t\t\t\t  pout))\n-\t\t\t      return 0;\n-\t\t\t    pout += literal;\n-\t\t\t    literal = 0;\n-\t\t\t  }\n+\t\t/* Often LITERAL is small, so handle small cases quickly.  */\n+\t\tswitch (literal)\n+\t\t  {\n+\t\t  case 8:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 7:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 6:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 5:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 4:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 3:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 2:\n+\t\t    *pout++ = *plit++;\n+\t\t    /* FALLTHROUGH */\n+\t\t  case 1:\n+\t\t    *pout++ = *plit++;\n+\t\t    break;\n \n-\t\t\tplitexp = (unsigned char *)scratch;\n-\t\t\tlitexp_count = ZSTD_TABLE_WORK_LIT_SIZE;\n-\t\t\tif (litexp_count > literals.regenerated_size)\n-\t\t\t  litexp_count = literals.regenerated_size;\n-\t\t\tif (!elf_zstd_literal_output (&literals,\n-\t\t\t\t\t\t      litexp_count,\n-\t\t\t\t\t\t      plitexp))\n-\t\t\t  return 0;\n+\t\t  case 0:\n+\t\t    break;\n \n-\t\t\tif (unlikely (literal > litexp_count))\n+\t\t  default:\n+\t\t    if (unlikely ((size_t)(plit - pout) < literal))\n+\t\t      {\n+\t\t\tuint32_t move;\n+\n+\t\t\tmove = plit - pout;\n+\t\t\twhile (literal > move)\n \t\t\t  {\n-\t\t\t    elf_uncompress_failed ();\n-\t\t\t    return 0;\n+\t\t\t    memcpy (pout, plit, move);\n+\t\t\t    pout += move;\n+\t\t\t    plit += move;\n+\t\t\t    literal -= move;\n \t\t\t  }\n-\n-\t\t\tmemcpy (pout, plitexp, literal);\n-\t\t\tplitexp += literal;\n-\t\t\tlitexp_count -= literal;\n-\t\t\tpout += literal;\n \t\t      }\n+\n+\t\t    memcpy (pout, plit, literal);\n+\t\t    pout += literal;\n+\t\t    plit += literal;\n \t\t  }\n \n \t\tif (match > 0)\n@@ -4907,34 +4937,35 @@ elf_zstd_decompress (const unsigned char *pin, size_t sin,\n \n \t\tif (unlikely (seq >= seq_count))\n \t\t  {\n-\t\t    size_t copy;\n-\n \t\t    /* Copy remaining literals.  */\n-\t\t    if (litexp_count > 0)\n+\t\t    if (literal_count > 0 && plit != pout)\n \t\t      {\n-\t\t\tif (unlikely ((size_t)(poutend - pout) < litexp_count))\n+\t\t\tif (unlikely ((size_t)(poutend - pout)\n+\t\t\t\t      < literal_count))\n \t\t\t  {\n \t\t\t    elf_uncompress_failed ();\n \t\t\t    return 0;\n \t\t\t  }\n-\t\t\tmemcpy (pout, plitexp, litexp_count);\n-\t\t\tpout += litexp_count;\n-\t\t      }\n-\t\t    copy = literals.regenerated_size;\n-\t\t    if (copy > 0)\n-\t\t      {\n-\t\t\tif (unlikely ((size_t)(poutend - pout) < copy))\n+\n+\t\t\tif ((size_t)(plit - pout) < literal_count)\n \t\t\t  {\n-\t\t\t    elf_uncompress_failed ();\n-\t\t\t    return 0;\n+\t\t\t    uint32_t move;\n+\n+\t\t\t    move = plit - pout;\n+\t\t\t    while (literal_count > move)\n+\t\t\t      {\n+\t\t\t\tmemcpy (pout, plit, move);\n+\t\t\t\tpout += move;\n+\t\t\t\tplit += move;\n+\t\t\t\tliteral_count -= move;\n+\t\t\t      }\n \t\t\t  }\n \n-\t\t\tif (!elf_zstd_literal_output (&literals, copy, pout))\n-\t\t\t  return 0;\n-\n-\t\t\tpout += copy;\n+\t\t\tmemcpy (pout, plit, literal_count);\n \t\t      }\n \n+\t\t    pout += literal_count;\n+\n \t\t    break;\n \t\t  }\n \t      }"}]}