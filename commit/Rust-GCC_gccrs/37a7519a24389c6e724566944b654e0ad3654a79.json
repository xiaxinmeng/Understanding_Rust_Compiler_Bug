{"sha": "37a7519a24389c6e724566944b654e0ad3654a79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdhNzUxOWEyNDM4OWM2ZTcyNDU2Njk0NGI2NTRlMGFkMzY1NGE3OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-10-06T22:14:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-10-06T22:14:01Z"}, "message": "Fix lookup of initialized captures in unevaluated context.\n\n\t* cp-tree.h (DECL_NORMAL_CAPTURE_P): New.\n\t* name-lookup.c (qualify_lookup): Check it.\n\t* parser.c (cp_parser_lambda_introducer): Pass explicit_init_p\n\tto add_capture.\n\t* semantics.c (add_capture): Set DECL_NORMAL_CAPTURE_P\n\ton captures without explicit init.\n\t(add_default_capture): Pass explicit_init_p.\n\n\tFix capture by copy of types with explicit copy constructor.\n\t* cp-tree.h (TARGET_EXPR_DIRECT_INIT_P): New.\n\t(DIRECT_INIT_EXPR_P): New.\n\t* typeck.c (convert_for_initialization): Just return if\n\tDIRECT_INIT_EXPR_P.\n\t* parser.c (cp_parser_lambda_introducer): Use\n\tTARGET_EXPR_DIRECT_INIT_P for normal captures.\n\nFrom-SVN: r152500", "tree": {"sha": "91a2cc25814e680725f6c140def08bac99194893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91a2cc25814e680725f6c140def08bac99194893"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37a7519a24389c6e724566944b654e0ad3654a79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a7519a24389c6e724566944b654e0ad3654a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37a7519a24389c6e724566944b654e0ad3654a79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a7519a24389c6e724566944b654e0ad3654a79/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ebde32fd2478df9909e07843451956ce89a02b46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebde32fd2478df9909e07843451956ce89a02b46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebde32fd2478df9909e07843451956ce89a02b46"}], "stats": {"total": 111, "additions": 103, "deletions": 8}, "files": [{"sha": "bb800f1b27c0b30b2c404bfa39bb29a8a03fbdd2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=37a7519a24389c6e724566944b654e0ad3654a79", "patch": "@@ -1,3 +1,22 @@\n+2009-10-06  Jason Merrill  <jason@redhat.com>\n+\n+\tFix lookup of initialized captures in unevaluated context.\n+\t* cp-tree.h (DECL_NORMAL_CAPTURE_P): New.\n+\t* name-lookup.c (qualify_lookup): Check it.\n+\t* parser.c (cp_parser_lambda_introducer): Pass explicit_init_p\n+\tto add_capture.\n+\t* semantics.c (add_capture): Set DECL_NORMAL_CAPTURE_P\n+\ton captures without explicit init.\n+\t(add_default_capture): Pass explicit_init_p.\n+\n+\tFix capture by copy of types with explicit copy constructor.\n+\t* cp-tree.h (TARGET_EXPR_DIRECT_INIT_P): New.\n+\t(DIRECT_INIT_EXPR_P): New.\n+\t* typeck.c (convert_for_initialization): Just return if\n+\tDIRECT_INIT_EXPR_P.\n+\t* semantics.c (build_lambda_object): Use\n+\tTARGET_EXPR_DIRECT_INIT_P for normal captures.\n+\n 2009-10-05  Jason Merrill  <jason@redhat.com>\n \n \t* parser.c: Mark lambda_scope and lambda_count for PCH."}, {"sha": "4b273c1221aafb46b77f19514d52de84d7f82201", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=37a7519a24389c6e724566944b654e0ad3654a79", "patch": "@@ -97,6 +97,7 @@ framework extensions, you must include this file before toplev.h, not after.\n       STATEMENT_LIST_TRY_BLOCK (in STATEMENT_LIST)\n       TYPENAME_IS_RESOLVING_P (in TYPE_NAME_TYPE)\n       LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (in LAMBDA_EXPR)\n+      TARGET_EXPR_DIRECT_INIT_P (in TARGET_EXPR)\n    3: (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n@@ -147,6 +148,7 @@ framework extensions, you must include this file before toplev.h, not after.\n       DECL_FIELD_IS_BASE (in FIELD_DECL)\n    7: DECL_DEAD_FOR_LOCAL (in VAR_DECL).\n       DECL_THUNK_P (in a member FUNCTION_DECL)\n+      DECL_NORMAL_CAPTURE_P (in FIELD_DECL)\n \n    Usage of language-independent fields in a language-dependent manner:\n \n@@ -3199,6 +3201,12 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define DECL_FIELD_IS_BASE(NODE) \\\n   DECL_LANG_FLAG_6 (FIELD_DECL_CHECK (NODE))\n \n+/* Nonzero for FIELD_DECL node means that this field is a simple (no\n+   explicit initializer) lambda capture field, making it invisible to\n+   name lookup in unevaluated contexts.  */\n+#define DECL_NORMAL_CAPTURE_P(NODE) \\\n+  DECL_LANG_FLAG_7 (FIELD_DECL_CHECK (NODE))\n+\n /* Nonzero if TYPE is an anonymous union or struct type.  We have to use a\n    flag for this because \"A union for which objects or pointers are\n    declared is not an anonymous union\" [class.union].  */\n@@ -3633,6 +3641,16 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define TARGET_EXPR_LIST_INIT_P(NODE) \\\n   TREE_LANG_FLAG_1 (TARGET_EXPR_CHECK (NODE))\n \n+/* True if this TARGET_EXPR expresses direct-initialization of an object\n+   to be named later.  */\n+#define TARGET_EXPR_DIRECT_INIT_P(NODE) \\\n+  TREE_LANG_FLAG_2 (TARGET_EXPR_CHECK (NODE))\n+\n+/* True if EXPR expresses direct-initialization of a TYPE.  */\n+#define DIRECT_INIT_EXPR_P(TYPE,EXPR)\t\t\t\t\t\\\n+  (TREE_CODE (EXPR) == TARGET_EXPR && TREE_LANG_FLAG_2 (EXPR)\t\t\\\n+   && same_type_ignoring_top_level_qualifiers_p (TYPE, TREE_TYPE (EXPR)))\n+\n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types {\n   none_type = 0, /* Not a tag type.  */\n@@ -5041,7 +5059,7 @@ extern tree lambda_capture_field_type\t\t(tree);\n extern tree lambda_return_type\t\t\t(tree);\n extern tree lambda_function\t\t\t(tree);\n extern void apply_lambda_return_type            (tree, tree);\n-extern tree add_capture                         (tree, tree, tree, bool);\n+extern tree add_capture                         (tree, tree, tree, bool, bool);\n extern tree add_default_capture                 (tree, tree, tree);\n extern tree lambda_expr_this_capture            (tree);\n "}, {"sha": "6e31f8a058a2473ff6e9fe2a758e5988c02379eb", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=37a7519a24389c6e724566944b654e0ad3654a79", "patch": "@@ -3757,10 +3757,9 @@ qualify_lookup (tree val, int flags)\n     return true;\n   if (flags & (LOOKUP_PREFER_NAMESPACES | LOOKUP_PREFER_TYPES))\n     return false;\n-  /* In unevaluated context, look past capture fields.  */\n-  /* FIXME this will cause trouble with the initializer extension.  */\n+  /* In unevaluated context, look past normal capture fields.  */\n   if (cp_unevaluated_operand && TREE_CODE (val) == FIELD_DECL\n-      && LAMBDA_TYPE_P (DECL_CONTEXT (val)))\n+      && DECL_NORMAL_CAPTURE_P (val))\n     return false;\n   return true;\n }"}, {"sha": "44dceb21f745d2276f5cc4aafbd5bc75147503bb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=37a7519a24389c6e724566944b654e0ad3654a79", "patch": "@@ -7125,6 +7125,7 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n       tree capture_id;\n       tree capture_init_expr;\n       cp_id_kind idk = CP_ID_KIND_NONE;\n+      bool explicit_init_p = false;\n \n       enum capture_kind_type\n       {\n@@ -7151,7 +7152,8 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \t  add_capture (lambda_expr,\n \t\t       /*id=*/get_identifier (\"__this\"),\n \t\t       /*initializer=*/finish_this_expr(),\n-\t\t       /*by_reference_p=*/false);\n+\t\t       /*by_reference_p=*/false,\n+\t\t       explicit_init_p);\n \t  continue;\n \t}\n \n@@ -7190,6 +7192,7 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \t  capture_init_expr = cp_parser_assignment_expression (parser,\n \t\t\t\t\t\t\t       /*cast_p=*/true,\n \t\t\t\t\t\t\t       &idk);\n+\t  explicit_init_p = true;\n \t}\n       else\n \t{\n@@ -7231,7 +7234,8 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n       add_capture (lambda_expr,\n \t\t   capture_id,\n \t\t   capture_init_expr,\n-\t\t   /*by_reference_p=*/capture_kind == BY_REFERENCE);\n+\t\t   /*by_reference_p=*/capture_kind == BY_REFERENCE,\n+\t\t   explicit_init_p);\n     }\n \n   cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");"}, {"sha": "391228b02a63f578def4a41a1e5677a3af3f5996", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=37a7519a24389c6e724566944b654e0ad3654a79", "patch": "@@ -5328,6 +5328,20 @@ build_lambda_object (tree lambda_expr)\n \t do some magic to make it work here.  */\n       if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE)\n \tval = build_array_copy (val);\n+      else if (DECL_NORMAL_CAPTURE_P (field)\n+\t       && TREE_CODE (TREE_TYPE (field)) != REFERENCE_TYPE)\n+\t{\n+\t  /* \"the entities that are captured by copy are used to\n+\t     direct-initialize each corresponding non-static data\n+\t     member of the resulting closure object.\"\n+\n+\t     There's normally no way to express direct-initialization\n+\t     from an element of a CONSTRUCTOR, so we build up a special\n+\t     TARGET_EXPR to bypass the usual copy-initialization.  */\n+\t  val = force_rvalue (val);\n+\t  if (TREE_CODE (val) == TARGET_EXPR)\n+\t    TARGET_EXPR_DIRECT_INIT_P (val) = true;\n+\t}\n \n       CONSTRUCTOR_APPEND_ELT (elts, DECL_NAME (field), val);\n     }\n@@ -5545,7 +5559,8 @@ capture_decltype (tree decl)\n    and return it.  */\n \n tree\n-add_capture (tree lambda, tree id, tree initializer, bool by_reference_p)\n+add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n+\t     bool explicit_init_p)\n {\n   tree type;\n   tree member;\n@@ -5560,6 +5575,13 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p)\n \n   /* Make member variable.  */\n   member = build_lang_decl (FIELD_DECL, id, type);\n+  if (!explicit_init_p)\n+    /* Normal captures are invisible to name lookup but uses are replaced\n+       with references to the capture field; we implement this by only\n+       really making them invisible in unevaluated context; see\n+       qualify_lookup.  For now, let's make explicitly initialized captures\n+       always visible.  */\n+    DECL_NORMAL_CAPTURE_P (member) = true;\n \n   /* Add it to the appropriate closure class.  */\n   finish_member_declaration (member);\n@@ -5605,7 +5627,8 @@ add_default_capture (tree lambda_stack, tree id, tree initializer)\n                             /*by_reference_p=*/\n \t\t\t    (!this_capture_p\n \t\t\t     && (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda)\n-\t\t\t\t == CPLD_REFERENCE)));\n+\t\t\t\t == CPLD_REFERENCE)),\n+\t\t\t    /*explicit_init_p=*/false);\n \n       {\n         /* Have to get the old value of current_class_ref.  */"}, {"sha": "79b0201b77ad3c684eebe9c71a252e3332a1038f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=37a7519a24389c6e724566944b654e0ad3654a79", "patch": "@@ -6893,6 +6893,11 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n \n   type = complete_type (type);\n \n+  if (DIRECT_INIT_EXPR_P (type, rhs))\n+    /* Don't try to do copy-initialization if we already have\n+       direct-initialization.  */\n+    return rhs;\n+\n   if (MAYBE_CLASS_TYPE_P (type))\n     return ocp_convert (type, rhs, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n "}, {"sha": "dd18805a6cc683405335d1ac1c72fe2372f32bec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=37a7519a24389c6e724566944b654e0ad3654a79", "patch": "@@ -1,3 +1,8 @@\n+2009-10-06  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/lambda/lambda-init.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-direct-init.C: New.\n+\n 2009-10-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/41502"}, {"sha": "bbc2a1ca52d471bdcb126dc392106ddbbcff9784", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-direct-init.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-direct-init.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-direct-init.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-direct-init.C?ref=37a7519a24389c6e724566944b654e0ad3654a79", "patch": "@@ -0,0 +1,14 @@\n+// Test that capture by copy uses direct-initialization.\n+// { dg-options \"-std=c++0x\" }\n+\n+struct A\n+{\n+  A();\n+  explicit A(const A&);\n+};\n+\n+int main()\n+{\n+  A a;\n+  [a]{};\n+}"}, {"sha": "03c94e95981fb9930e10d09ea06c5928697fa2bf", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-init.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-init.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a7519a24389c6e724566944b654e0ad3654a79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-init.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-init.C?ref=37a7519a24389c6e724566944b654e0ad3654a79", "patch": "@@ -0,0 +1,8 @@\n+// Test for the explicit initializer extension\n+// { dg-options \"-std=c++0x\" }\n+\n+int main()\n+{\n+  int j = [i = 2]{sizeof(i); return i;}();\n+  return (j != 2);\n+}"}]}