{"sha": "96a30b18264771ab63790ae9976105745c2cec66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZhMzBiMTgyNjQ3NzFhYjYzNzkwYWU5OTc2MTA1NzQ1YzJjZWM2Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-08-14T20:55:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-08-14T20:55:56Z"}, "message": "* config/mips/mips-protos.h (mips_symbolic_constant_p)\n\t(mips_atomic_symbolic_constant_p, mips_stack_address_p)\n\t(mips_small_data_pattern_p): Declare.\n\t* config/mips/mips.h (CONST_GP_P): Moved from mips.c.\n\t(PREDICATE_CODES, SPECIAL_MODE_PREDICATES): Delete.\n\t* config/mips/mips.c (mips_symbolic_constant_p): Make global.\n\t(mips_atomic_symbolic_constant_p, mips_stack_address_p): New functions.\n\t(uns_arith_operand, const_arith_operand, arith_operand, sle_operand)\n\t(sleu_operand, small_int, reg_or_0_operand, const_float_1_operand)\n\t(reg_or_const_float_1_operand, hilo_operand, extend_operator)\n\t(macc_msac_operand, equality_op, cmp_op, trap_cmp_op)\n\t(pc_or_label_operand, call_insn_operand, move_operand)\n\t(consttable_operand, symbolic_operand, general_symbolic_operand)\n\t(global_got_operand, local_got_operand, stack_operand)\n\t(fp_register_operand, lo_operand, fcc_register_operand): Delete.\n\t(mips_small_data_pattern_1): Renamed from small_data_pattern_1.\n\t(mips_small_data_pattern_p): Replace previous small_data_pattern\n\tpredicate.  Turn into a bool () (rtx) function.\n\t* config/mips/predicates.md: New file.\n\t* config/mips/mips.md: Include it.  Use the target-independent\n\tcomparison_operator instead of cmp_op.  Rename trap_cmp_op to\n\ttrap_comparison_operator and equality_op to equality_operator.\n\tReplace uses of small_int with the equivalent const_arith_operand.\n\tRename reg_or_const_float_1_operand to reg_or_1_operand.  Rename\n\tconst_float_1_operand to const_1_operand.  Rename fcc_register_operand\n\tto fcc_reload_operand.\n\t* config/mips/sb1.md: Rename fp_register_operand to fpr_operand.\n\nFrom-SVN: r86006", "tree": {"sha": "34fa9bea47a178098fdbc04f6014ac2c6fea1786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34fa9bea47a178098fdbc04f6014ac2c6fea1786"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96a30b18264771ab63790ae9976105745c2cec66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96a30b18264771ab63790ae9976105745c2cec66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96a30b18264771ab63790ae9976105745c2cec66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96a30b18264771ab63790ae9976105745c2cec66/comments", "author": null, "committer": null, "parents": [{"sha": "e41c9fcb1de8e7ee61a6ddbfb2e0c4d9cf4e667d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e41c9fcb1de8e7ee61a6ddbfb2e0c4d9cf4e667d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e41c9fcb1de8e7ee61a6ddbfb2e0c4d9cf4e667d"}], "stats": {"total": 858, "additions": 336, "deletions": 522}, "files": [{"sha": "e2402b3fc519f68d750cd756c3c3abc285cc27e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a30b18264771ab63790ae9976105745c2cec66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a30b18264771ab63790ae9976105745c2cec66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96a30b18264771ab63790ae9976105745c2cec66", "patch": "@@ -1,3 +1,33 @@\n+2004-08-14  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_symbolic_constant_p)\n+\t(mips_atomic_symbolic_constant_p, mips_stack_address_p)\n+\t(mips_small_data_pattern_p): Declare.\n+\t* config/mips/mips.h (CONST_GP_P): Moved from mips.c.\n+\t(PREDICATE_CODES, SPECIAL_MODE_PREDICATES): Delete.\n+\t* config/mips/mips.c (mips_symbolic_constant_p): Make global.\n+\t(mips_atomic_symbolic_constant_p, mips_stack_address_p): New functions.\n+\t(uns_arith_operand, const_arith_operand, arith_operand, sle_operand)\n+\t(sleu_operand, small_int, reg_or_0_operand, const_float_1_operand)\n+\t(reg_or_const_float_1_operand, hilo_operand, extend_operator)\n+\t(macc_msac_operand, equality_op, cmp_op, trap_cmp_op)\n+\t(pc_or_label_operand, call_insn_operand, move_operand)\n+\t(consttable_operand, symbolic_operand, general_symbolic_operand)\n+\t(global_got_operand, local_got_operand, stack_operand)\n+\t(fp_register_operand, lo_operand, fcc_register_operand): Delete.\n+\t(mips_small_data_pattern_1): Renamed from small_data_pattern_1.\n+\t(mips_small_data_pattern_p): Replace previous small_data_pattern\n+\tpredicate.  Turn into a bool () (rtx) function.\n+\t* config/mips/predicates.md: New file.\n+\t* config/mips/mips.md: Include it.  Use the target-independent\n+\tcomparison_operator instead of cmp_op.  Rename trap_cmp_op to\n+\ttrap_comparison_operator and equality_op to equality_operator.\n+\tReplace uses of small_int with the equivalent const_arith_operand.\n+\tRename reg_or_const_float_1_operand to reg_or_1_operand.  Rename\n+\tconst_float_1_operand to const_1_operand.  Rename fcc_register_operand\n+\tto fcc_reload_operand.\n+\t* config/mips/sb1.md: Rename fp_register_operand to fpr_operand.\n+\n 2004-08-14  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR libstdc++/17005 partial fix."}, {"sha": "eec42fce72dc7cdcaef44315ad9156cc4e80bd64", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=96a30b18264771ab63790ae9976105745c2cec66", "patch": "@@ -88,7 +88,10 @@ enum mips_symbol_type {\n };\n #define NUM_SYMBOL_TYPES (SYMBOL_64_LOW + 1)\n \n+extern bool mips_symbolic_constant_p (rtx, enum mips_symbol_type *);\n+extern bool mips_atomic_symbolic_constant_p (rtx);\n extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, int);\n+extern bool mips_stack_address_p (rtx, enum machine_mode);\n extern int mips_address_insns (rtx, enum machine_mode);\n extern int mips_const_insns (rtx);\n extern int mips_fetch_insns (rtx);\n@@ -173,6 +176,7 @@ extern void mips_declare_object (FILE *, const char *, const char *,\n extern void mips_declare_object_name (FILE *, const char *, tree);\n extern void mips_finish_declare_object (FILE *, tree, int, int);\n \n+extern bool mips_small_data_pattern_p (rtx);\n extern rtx mips_rewrite_small_data (rtx);\n extern HOST_WIDE_INT compute_frame_size (HOST_WIDE_INT);\n extern HOST_WIDE_INT mips_initial_elimination_offset (int, int);"}, {"sha": "3ded74101769c2d85b4c7ce8c4e3f022d302a96a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 29, "deletions": 398, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=96a30b18264771ab63790ae9976105745c2cec66", "patch": "@@ -71,13 +71,6 @@ Boston, MA 02111-1307, USA.  */\n #define UNSPEC_ADDRESS_TYPE(X) \\\n   ((enum mips_symbol_type) (XINT (X, 1) - UNSPEC_ADDRESS_FIRST))\n \n-/* True if X is (const (unspec [(const_int 0)] UNSPEC_GP)).  This is used\n-   to initialize the mips16 gp pseudo register.  */\n-#define CONST_GP_P(X) \\\n-  (GET_CODE (X) == CONST\t\t\t\\\n-   && GET_CODE (XEXP (X, 0)) == UNSPEC\t\t\\\n-   && XINT (XEXP (X, 0), 1) == UNSPEC_GP)\n-\n /* The maximum distance between the top of the stack frame and the\n    value $sp has when we save & restore registers.\n \n@@ -154,7 +147,6 @@ struct mips_sim;\n static enum mips_symbol_type mips_classify_symbol (rtx);\n static void mips_split_const (rtx, rtx *, HOST_WIDE_INT *);\n static bool mips_offset_within_object_p (rtx, HOST_WIDE_INT);\n-static bool mips_symbolic_constant_p (rtx, enum mips_symbol_type *);\n static bool mips_valid_base_register_p (rtx, enum machine_mode, int);\n static bool mips_symbolic_address_p (enum mips_symbol_type, enum machine_mode);\n static bool mips_classify_address (struct mips_address_info *, rtx,\n@@ -192,7 +184,7 @@ static bool mips_assemble_integer (rtx, unsigned int, int);\n static void mips_file_start (void);\n static void mips_file_end (void);\n static bool mips_rewrite_small_data_p (rtx);\n-static int small_data_pattern_1 (rtx *, void *);\n+static int mips_small_data_pattern_1 (rtx *, void *);\n static int mips_rewrite_small_data_1 (rtx *, void *);\n static bool mips_function_has_gp_insn (void);\n static unsigned int mips_global_pointer\t(void);\n@@ -841,7 +833,7 @@ mips_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n    the same way as a bare symbol.  If it is, store the type of the\n    symbol in *SYMBOL_TYPE.  */\n \n-static bool\n+bool\n mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n {\n   HOST_WIDE_INT offset;\n@@ -906,6 +898,17 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_type *symbol_type)\n }\n \n \n+/* Return true if X is a symbolic constant whose value is not split\n+   into separate relocations.  */\n+\n+bool\n+mips_atomic_symbolic_constant_p (rtx x)\n+{\n+  enum mips_symbol_type type;\n+  return mips_symbolic_constant_p (x, &type) && !mips_split_p[type];\n+}\n+\n+\n /* This function is used to implement REG_MODE_OK_FOR_BASE_P.  */\n \n int\n@@ -1125,6 +1128,17 @@ mips_symbol_insns (enum mips_symbol_type type)\n   abort ();\n }\n \n+/* Return true if X is a legitimate $sp-based address for mode MDOE.  */\n+\n+bool\n+mips_stack_address_p (rtx x, enum machine_mode mode)\n+{\n+  struct mips_address_info addr;\n+\n+  return (mips_classify_address (&addr, x, mode, false)\n+\t  && addr.type == ADDRESS_REG\n+\t  && addr.reg == stack_pointer_rtx);\n+}\n \n /* Return true if a value at OFFSET bytes from BASE can be accessed\n    using an unextended mips16 instruction.  MODE is the mode of the\n@@ -1289,377 +1303,7 @@ mips_idiv_insns (void)\n     count++;\n   return count;\n }\n-\n-\n-/* Return truth value of whether OP can be used as an operands\n-   where a register or 16 bit unsigned integer is needed.  */\n-\n-int\n-uns_arith_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT && SMALL_INT_UNSIGNED (op))\n-    return 1;\n-\n-  return register_operand (op, mode);\n-}\n-\n-\n-/* True if OP can be treated as a signed 16-bit constant.  */\n-\n-int\n-const_arith_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == CONST_INT && SMALL_INT (op);\n-}\n-\n-\n-/* Return true if OP is a register operand or a signed 16-bit constant.  */\n-\n-int\n-arith_operand (rtx op, enum machine_mode mode)\n-{\n-  return const_arith_operand (op, mode) || register_operand (op, mode);\n-}\n-\n-/* Return true if OP can be used as the second argument to an LE operation.  */\n-\n-int\n-sle_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == CONST_INT && SMALL_OPERAND (INTVAL (op) + 1);\n-}\n-\n-/* Likewise LEU.  */\n-\n-int\n-sleu_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) + 1 != 0\n-\t  && SMALL_OPERAND (INTVAL (op) + 1));\n-}\n-\n-/* Return truth value of whether OP is an integer which fits in 16 bits.  */\n-\n-int\n-small_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n-}\n-\n-/* Return truth value of whether OP is a register or the constant 0.\n-   Do not accept 0 in mips16 mode since $0 is not one of the core 8\n-   registers.  */\n-\n-int\n-reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_INT:\n-      if (TARGET_MIPS16)\n-\treturn 0;\n-      return INTVAL (op) == 0;\n-\n-    case CONST_DOUBLE:\n-      if (TARGET_MIPS16)\n-\treturn 0;\n-      return op == CONST0_RTX (mode);\n-\n-    default:\n-      return register_operand (op, mode);\n-    }\n-}\n-\n-/* Accept a register or the floating point constant 1 in the\n-   appropriate mode.  */\n-\n-int\n-reg_or_const_float_1_operand (rtx op, enum machine_mode mode)\n-{\n-  return const_float_1_operand (op, mode) || register_operand (op, mode);\n-}\n-\n-/* Accept the floating point constant 1 in the appropriate mode.  */\n-\n-int\n-const_float_1_operand (rtx op, enum machine_mode mode)\n-{\n-  REAL_VALUE_TYPE d;\n-\n-  if (GET_CODE (op) != CONST_DOUBLE\n-      || mode != GET_MODE (op)\n-      || (mode != DFmode && mode != SFmode))\n-    return 0;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n-\n-  return REAL_VALUES_EQUAL (d, dconst1);\n-}\n-\n-/* Return true if OP is either the HI or LO register.  */\n-\n-int\n-hilo_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && REG_P (op) && MD_REG_P (REGNO (op)));\n-}\n-\n-/* Return true if OP is an extension operator.  */\n-\n-int\n-extend_operator (rtx op, enum machine_mode mode)\n-{\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND));\n-}\n-\n-/* Return true if X is the right hand side of a \"macc\" or \"msac\" instruction.\n-   This predicate is intended for use in peephole optimizations.  */\n-\n-int\n-macc_msac_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (ISA_HAS_MACC && GET_CODE (x) == PLUS && REG_P (XEXP (x, 1)))\n-    x = XEXP (x, 0);\n-  else if (ISA_HAS_MSAC && GET_CODE (x) == MINUS && REG_P (XEXP (x, 0)))\n-    x = XEXP (x, 1);\n-  else\n-    return false;\n-\n-  return GET_CODE (x) == MULT && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1));\n-}\n-\n-/* Return nonzero if the code of this rtx pattern is EQ or NE.  */\n-\n-int\n-equality_op (rtx op, enum machine_mode mode)\n-{\n-  if (mode != GET_MODE (op))\n-    return 0;\n-\n-  return GET_CODE (op) == EQ || GET_CODE (op) == NE;\n-}\n-\n-/* Return nonzero if the code is a relational operations (EQ, LE, etc.) */\n-\n-int\n-cmp_op (rtx op, enum machine_mode mode)\n-{\n-  if (mode != GET_MODE (op))\n-    return 0;\n-\n-  return COMPARISON_P (op);\n-}\n-\n-/* Return nonzero if the code is a relational operation suitable for a\n-   conditional trap instruction (only EQ, NE, LT, LTU, GE, GEU).\n-   We need this in the insn that expands `trap_if' in order to prevent\n-   combine from erroneously altering the condition.  */\n-\n-int\n-trap_cmp_op (rtx op, enum machine_mode mode)\n-{\n-  if (mode != GET_MODE (op))\n-    return 0;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case EQ:\n-    case NE:\n-    case LT:\n-    case LTU:\n-    case GE:\n-    case GEU:\n-      return 1;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Return nonzero if the operand is either the PC or a label_ref.  */\n-\n-int\n-pc_or_label_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (op == pc_rtx)\n-    return 1;\n-\n-  if (GET_CODE (op) == LABEL_REF)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Test for a valid call address.  */\n-\n-int\n-call_insn_operand (rtx op, enum machine_mode mode)\n-{\n-  enum mips_symbol_type symbol_type;\n-\n-  if (mips_symbolic_constant_p (op, &symbol_type))\n-    switch (symbol_type)\n-      {\n-      case SYMBOL_GENERAL:\n-\t/* If -mlong-calls, force all calls to use register addressing.  */\n-\treturn !TARGET_LONG_CALLS;\n-\n-      case SYMBOL_GOT_GLOBAL:\n-\t/* Without explicit relocs, there is no special syntax for\n-\t   loading the address of a call destination into a register.\n-\t   Using \"la $25,foo; jal $25\" would prevent the lazy binding\n-\t   of \"foo\", so keep the address of global symbols with the\n-\t   jal macro.  */\n-\treturn !TARGET_EXPLICIT_RELOCS;\n-\n-      default:\n-\treturn false;\n-      }\n-  return register_operand (op, mode);\n-}\n-\n-\n-/* Return nonzero if OP is valid as a source operand for a move\n-   instruction.  */\n-\n-int\n-move_operand (rtx op, enum machine_mode mode)\n-{\n-  enum mips_symbol_type symbol_type;\n-\n-  if (!general_operand (op, mode))\n-    return false;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_INT:\n-      /* When generating mips16 code, LEGITIMATE_CONSTANT_P rejects\n-\t CONST_INTs that can't be loaded using simple insns.  */\n-      if (TARGET_MIPS16)\n-\treturn true;\n-\n-      /* When generating 32-bit code, allow DImode move_operands to\n-\t match arbitrary constants.  We split them after reload.  */\n-      if (!TARGET_64BIT && mode == DImode)\n-\treturn true;\n-\n-      /* Otherwise check whether the constant can be loaded in a single\n-\t instruction.  */\n-      return LUI_INT (op) || SMALL_INT (op) || SMALL_INT_UNSIGNED (op);\n-\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      if (CONST_GP_P (op))\n-\treturn true;\n-\n-      return (mips_symbolic_constant_p (op, &symbol_type)\n-\t      && !mips_split_p[symbol_type]);\n-\n-    default:\n-      return true;\n-    }\n-}\n-\n-\n-/* Accept any operand that can appear in a mips16 constant table\n-   instruction.  We can't use any of the standard operand functions\n-   because for these instructions we accept values that are not\n-   accepted by LEGITIMATE_CONSTANT, such as arbitrary SYMBOL_REFs.  */\n-\n-int\n-consttable_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return CONSTANT_P (op);\n-}\n-\n-/* Return 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n-   possibly with an offset.  */\n-\n-int\n-symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum mips_symbol_type symbol_type;\n-\n-  return mips_symbolic_constant_p (op, &symbol_type);\n-}\n-\n-\n-/* Return true if OP is a symbolic constant of type SYMBOL_GENERAL.  */\n-\n-int\n-general_symbolic_operand (rtx op, enum machine_mode mode)\n-{\n-  enum mips_symbol_type symbol_type;\n-\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && mips_symbolic_constant_p (op, &symbol_type)\n-\t  && symbol_type == SYMBOL_GENERAL);\n-}\n-\n-\n-/* Return true if we're generating PIC and OP is a global symbol.  */\n-\n-int\n-global_got_operand (rtx op, enum machine_mode mode)\n-{\n-  enum mips_symbol_type symbol_type;\n-\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && mips_symbolic_constant_p (op, &symbol_type)\n-\t  && symbol_type == SYMBOL_GOT_GLOBAL);\n-}\n-\n-\n-/* Likewise for local symbols.  */\n-\n-int\n-local_got_operand (rtx op, enum machine_mode mode)\n-{\n-  enum mips_symbol_type symbol_type;\n-\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && mips_symbolic_constant_p (op, &symbol_type)\n-\t  && symbol_type == SYMBOL_GOT_LOCAL);\n-}\n-\n-\n-/* Return true if OP is a memory reference that uses the stack pointer\n-   as a base register.  */\n-\n-int\n-stack_operand (rtx op, enum machine_mode mode)\n-{\n-  struct mips_address_info addr;\n-\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && GET_CODE (op) == MEM\n-\t  && mips_classify_address (&addr, XEXP (op, 0), GET_MODE (op), false)\n-\t  && addr.type == ADDRESS_REG\n-\t  && addr.reg == stack_pointer_rtx);\n-}\n-\n-/* Helper function for DFA schedulers.  Return true if OP is a floating\n-   point register.  */\n-\n-int\n-fp_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return REG_P (op) && FP_REG_P (REGNO (op));\n-}\n-\n-/* Helper function for DFA schedulers.  Return true if OP is a LO reg.  */\n-\n-int\n-lo_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return REG_P (op) && REGNO (op) == LO_REGNUM;\n-}\n \f\n-\n /* This function is used to implement GO_IF_LEGITIMATE_ADDRESS.  It\n    returns a nonzero value if X is a legitimate address for a memory\n    operand of the indicated MODE.  STRICT is nonzero if this function\n@@ -3070,18 +2714,6 @@ mips_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n   return TARGET_SIBCALLS;\n }\n \f\n-/* Return true if operand OP is a condition code register.\n-   Only for use during or after reload.  */\n-\n-int\n-fcc_register_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && (reload_in_progress || reload_completed)\n-\t  && (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n-\t  && ST_REG_P (true_regnum (op)));\n-}\n-\n /* Emit code to move general operand SRC into condition-code\n    register DEST.  SCRATCH is a scratch TFmode float register.\n    The sequence is:\n@@ -5741,10 +5373,10 @@ mips_rewrite_small_data_p (rtx x)\n }\n \n \n-/* A for_each_rtx callback for small_data_pattern.  */\n+/* A for_each_rtx callback for mips_small_data_pattern_p.  */\n \n static int\n-small_data_pattern_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n+mips_small_data_pattern_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (*loc) == LO_SUM)\n     return -1;\n@@ -5755,11 +5387,10 @@ small_data_pattern_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n /* Return true if OP refers to small data symbols directly, not through\n    a LO_SUM.  */\n \n-int\n-small_data_pattern (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+bool\n+mips_small_data_pattern_p (rtx op)\n {\n-  return (GET_CODE (op) != SEQUENCE\n-\t  && for_each_rtx (&op, small_data_pattern_1, 0));\n+  return for_each_rtx (&op, mips_small_data_pattern_1, 0);\n }\n \f\n /* A for_each_rtx callback, used by mips_rewrite_small_data.  */"}, {"sha": "e1e45af477df2a533ad22f06414fc3ac6cb3daf8", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 7, "deletions": 61, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=96a30b18264771ab63790ae9976105745c2cec66", "patch": "@@ -1653,6 +1653,13 @@ extern const struct mips_cpu_info *mips_tune_info;\n \n #define FP_REG_RTX_P(X) (GET_CODE (X) == REG && FP_REG_P (REGNO (X)))\n \n+/* True if X is (const (unspec [(const_int 0)] UNSPEC_GP)).  This is used\n+   to initialize the mips16 gp pseudo register.  */\n+#define CONST_GP_P(X)\t\t\t\t\\\n+  (GET_CODE (X) == CONST\t\t\t\\\n+   && GET_CODE (XEXP (X, 0)) == UNSPEC\t\t\\\n+   && XINT (XEXP (X, 0), 1) == UNSPEC_GP)\n+\n /* Return coprocessor number from register number.  */\n \n #define COPNUM_AS_CHAR_FROM_REGNUM(REGNO) \t\t\t\t\\\n@@ -2693,67 +2700,6 @@ typedef struct mips_args {\n    be updated with the correct length of the insn.  */\n #define ADJUST_INSN_LENGTH(INSN, LENGTH) \\\n   ((LENGTH) = mips_adjust_insn_length ((INSN), (LENGTH)))\n-\n-\f\n-/* Optionally define this if you have added predicates to\n-   `MACHINE.c'.  This macro is called within an initializer of an\n-   array of structures.  The first field in the structure is the\n-   name of a predicate and the second field is an array of rtl\n-   codes.  For each predicate, list all rtl codes that can be in\n-   expressions matched by the predicate.  The list should have a\n-   trailing comma.  Here is an example of two entries in the list\n-   for a typical RISC machine:\n-\n-   #define PREDICATE_CODES \\\n-     {\"gen_reg_rtx_operand\", {SUBREG, REG}},  \\\n-     {\"reg_or_short_cint_operand\", {SUBREG, REG, CONST_INT}},\n-\n-   Defining this macro does not affect the generated code (however,\n-   incorrect definitions that omit an rtl code that may be matched\n-   by the predicate can cause the compiler to malfunction).\n-   Instead, it allows the table built by `genrecog' to be more\n-   compact and efficient, thus speeding up the compiler.  The most\n-   important predicates to include in the list specified by this\n-   macro are thoses used in the most insn patterns.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"uns_arith_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n-  {\"symbolic_operand\",\t\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n-  {\"general_symbolic_operand\",\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n-  {\"global_got_operand\",\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n-  {\"local_got_operand\",\t\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n-  {\"const_arith_operand\",\t{ CONST_INT }},\t\t\t\t\\\n-  {\"small_data_pattern\",\t{ SET, PARALLEL, UNSPEC,\t\t\\\n-\t\t\t\t  UNSPEC_VOLATILE }},\t\t\t\\\n-  {\"arith_operand\",\t\t{ REG, CONST_INT, CONST, SUBREG }},\t\\\n-  {\"reg_or_0_operand\",\t\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG }}, \\\n-  {\"sle_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n-  {\"sleu_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n-  {\"small_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n-  {\"const_float_1_operand\",\t{ CONST_DOUBLE }},\t\t\t\\\n-  {\"reg_or_const_float_1_operand\", { CONST_DOUBLE, REG}},               \\\n-  {\"equality_op\",\t\t{ EQ, NE }},\t\t\t\t\\\n-  {\"cmp_op\",\t\t\t{ EQ, NE, GT, GE, GTU, GEU, LT, LE,\t\\\n-\t\t\t\t  LTU, LEU }},\t\t\t\t\\\n-  {\"trap_cmp_op\",\t\t{ EQ, NE, GE, GEU, LT, LTU }},\t\t\\\n-  {\"pc_or_label_operand\",\t{ PC, LABEL_REF }},\t\t\t\\\n-  {\"call_insn_operand\",\t\t{ CONST, SYMBOL_REF, LABEL_REF, REG }},\t\\\n-  {\"move_operand\", \t\t{ CONST_INT, CONST_DOUBLE, CONST,\t\\\n-\t\t\t\t  SYMBOL_REF, LABEL_REF, SUBREG,\t\\\n-\t\t\t\t  REG, MEM}},\t\t\t\t\\\n-  {\"stack_operand\",\t\t{ MEM }},\t\t\t\t\\\n-  {\"consttable_operand\",\t{ LABEL_REF, SYMBOL_REF, CONST_INT,\t\\\n-\t\t\t\t  CONST_DOUBLE, CONST }},\t\t\\\n-  {\"fcc_register_operand\",\t{ REG, SUBREG }},\t\t\t\\\n-  {\"hilo_operand\",\t\t{ REG }},\t\t\t\t\\\n-  {\"macc_msac_operand\",\t\t{ PLUS, MINUS }},\t\t\t\\\n-  {\"extend_operator\",\t\t{ ZERO_EXTEND, SIGN_EXTEND }},\n-\n-/* A list of predicates that do special things with modes, and so\n-   should not elicit warnings for VOIDmode match_operand.  */\n-\n-#define SPECIAL_MODE_PREDICATES \\\n-  \"pc_or_label_operand\",\n \f\n /* Control the assembler format that we output.  */\n "}, {"sha": "38b38de90c32d45e31cce92d3146388e6faaad7c", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 62, "deletions": 61, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=96a30b18264771ab63790ae9976105745c2cec66", "patch": "@@ -53,6 +53,8 @@\n    (UNSPEC_ADDRESS_FIRST\t100)\n \n    (FAKE_CALL_REGNO\t\t79)])\n+\n+(include \"predicates.md\")\n \f\n ;; ....................\n ;;\n@@ -364,7 +366,7 @@\n   [(set_attr \"type\"\t\"trap\")])\n \n (define_expand \"conditional_trap\"\n-  [(trap_if (match_operator 0 \"cmp_op\"\n+  [(trap_if (match_operator 0 \"comparison_operator\"\n \t\t\t    [(match_dup 2) (match_dup 3)])\n \t    (match_operand 1 \"const_int_operand\"))]\n   \"ISA_HAS_COND_TRAP\"\n@@ -379,7 +381,7 @@\n })\n \n (define_insn \"\"\n-  [(trap_if (match_operator 0 \"trap_cmp_op\"\n+  [(trap_if (match_operator 0 \"trap_comparison_operator\"\n                             [(match_operand:SI 1 \"reg_or_0_operand\" \"dJ\")\n                              (match_operand:SI 2 \"arith_operand\" \"dI\")])\n \t    (const_int 0))]\n@@ -388,7 +390,7 @@\n   [(set_attr \"type\"\t\"trap\")])\n \n (define_insn \"\"\n-  [(trap_if (match_operator 0 \"trap_cmp_op\"\n+  [(trap_if (match_operator 0 \"trap_comparison_operator\"\n                             [(match_operand:DI 1 \"reg_or_0_operand\" \"dJ\")\n                              (match_operand:DI 2 \"arith_operand\" \"dI\")])\n \t    (const_int 0))]\n@@ -446,7 +448,7 @@\n (define_insn \"\"\n   [(set (reg:SI 29)\n \t(plus:SI (reg:SI 29)\n-\t\t (match_operand:SI 0 \"small_int\" \"I\")))]\n+\t\t (match_operand:SI 0 \"const_arith_operand\" \"\")))]\n   \"TARGET_MIPS16\"\n   \"addu\\t%$,%$,%0\"\n   [(set_attr \"type\"\t\"arith\")\n@@ -458,7 +460,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(plus:SI (reg:SI 29)\n-\t\t (match_operand:SI 1 \"small_int\" \"I\")))]\n+\t\t (match_operand:SI 1 \"const_arith_operand\" \"\")))]\n   \"TARGET_MIPS16\"\n   \"addu\\t%0,%$,%1\"\n   [(set_attr \"type\"\t\"arith\")\n@@ -581,7 +583,7 @@\n (define_insn \"\"\n   [(set (reg:DI 29)\n \t(plus:DI (reg:DI 29)\n-\t\t (match_operand:DI 0 \"small_int\" \"I\")))]\n+\t\t (match_operand:DI 0 \"const_arith_operand\" \"\")))]\n   \"TARGET_MIPS16 && TARGET_64BIT\"\n   \"daddu\\t%$,%$,%0\"\n   [(set_attr \"type\"\t\"arith\")\n@@ -593,7 +595,7 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(plus:DI (reg:DI 29)\n-\t\t (match_operand:DI 1 \"small_int\" \"I\")))]\n+\t\t (match_operand:DI 1 \"const_arith_operand\" \"\")))]\n   \"TARGET_MIPS16 && TARGET_64BIT\"\n   \"daddu\\t%0,%$,%1\"\n   [(set_attr \"type\"\t\"arith\")\n@@ -1947,11 +1949,11 @@\n \n (define_expand \"divdf3\"\n   [(set (match_operand:DF 0 \"register_operand\")\n-\t(div:DF (match_operand:DF 1 \"reg_or_const_float_1_operand\")\n+\t(div:DF (match_operand:DF 1 \"reg_or_1_operand\")\n \t\t(match_operand:DF 2 \"register_operand\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n {\n-  if (const_float_1_operand (operands[1], DFmode))\n+  if (const_1_operand (operands[1], DFmode))\n     if (!(ISA_HAS_FP4 && flag_unsafe_math_optimizations))\n       operands[1] = force_reg (DFmode, operands[1]);\n })\n@@ -1997,11 +1999,11 @@\n ;; precision is OK (i.e., flag_unsafe_math_optimizations is set).\n (define_expand \"divsf3\"\n   [(set (match_operand:SF 0 \"register_operand\")\n-\t(div:SF (match_operand:SF 1 \"reg_or_const_float_1_operand\")\n+\t(div:SF (match_operand:SF 1 \"reg_or_1_operand\")\n \t\t(match_operand:SF 2 \"register_operand\")))]\n   \"TARGET_HARD_FLOAT && (!TARGET_FIX_SB1 || flag_unsafe_math_optimizations)\"\n {\n-  if (const_float_1_operand (operands[1], SFmode))\n+  if (const_1_operand (operands[1], SFmode))\n     if (!(ISA_HAS_FP4 && flag_unsafe_math_optimizations))\n       operands[1] = force_reg (SFmode, operands[1]);\n })\n@@ -2033,7 +2035,7 @@\n ;; \"divdf3\" comment for details).\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"const_float_1_operand\" \"\")\n+\t(div:DF (match_operand:DF 1 \"const_1_operand\" \"\")\n \t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_unsafe_math_optimizations\"\n {\n@@ -2053,7 +2055,7 @@\n ;; \"divdf3\" comment for details).\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n+\t(div:SF (match_operand:SF 1 \"const_1_operand\" \"\")\n \t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations\"\n {\n@@ -2168,7 +2170,7 @@\n ;; \"divdf3\" comment for details).\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"const_float_1_operand\" \"\")\n+\t(div:DF (match_operand:DF 1 \"const_1_operand\" \"\")\n \t\t(sqrt:DF (match_operand:DF 2 \"register_operand\" \"f\"))))]\n   \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_unsafe_math_optimizations\"\n {\n@@ -2188,7 +2190,7 @@\n ;; \"divdf3\" comment for details).\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n+\t(div:SF (match_operand:SF 1 \"const_1_operand\" \"\")\n \t\t(sqrt:SF (match_operand:SF 2 \"register_operand\" \"f\"))))]\n   \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations\"\n {\n@@ -2208,7 +2210,7 @@\n ;; \"divdf3\" comment for details).\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(sqrt:DF (div:DF (match_operand:DF 1 \"const_float_1_operand\" \"\")\n+\t(sqrt:DF (div:DF (match_operand:DF 1 \"const_1_operand\" \"\")\n \t\t\t (match_operand:DF 2 \"register_operand\" \"f\"))))]\n   \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_unsafe_math_optimizations\"\n {\n@@ -2228,7 +2230,7 @@\n ;; \"divdf3\" comment for details).\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(sqrt:SF (div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n+\t(sqrt:SF (div:SF (match_operand:SF 1 \"const_1_operand\" \"\")\n \t\t\t (match_operand:SF 2 \"register_operand\" \"f\"))))]\n   \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations\"\n {\n@@ -2783,8 +2785,9 @@ dsrl\\t%3,%3,1\\n\\\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (truncate:SI (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-                                  (match_operand:DI 2 \"small_int\" \"I\"))))]\n+        (truncate:SI\n+\t  (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+                       (match_operand:DI 2 \"const_arith_operand\" \"\"))))]\n   \"TARGET_64BIT && !TARGET_MIPS16 && INTVAL (operands[2]) >= 32\"\n   \"dsra\\t%0,%1,%2\"\n   [(set_attr \"type\" \"shift\")\n@@ -4285,7 +4288,7 @@ dsrl\\t%3,%3,1\\n\\\n ;; into a GPR takes a single movcc, moving elsewhere takes\n ;; two.  We can leave these cases to the generic reload code.\n (define_expand \"reload_incc\"\n-  [(set (match_operand:CC 0 \"fcc_register_operand\" \"=z\")\n+  [(set (match_operand:CC 0 \"fcc_reload_operand\" \"=z\")\n \t(match_operand:CC 1 \"general_operand\" \"\"))\n    (clobber (match_operand:TF 2 \"register_operand\" \"=&f\"))]\n   \"ISA_HAS_8CC && TARGET_HARD_FLOAT\"\n@@ -4295,7 +4298,7 @@ dsrl\\t%3,%3,1\\n\\\n })\n \n (define_expand \"reload_outcc\"\n-  [(set (match_operand:CC 0 \"fcc_register_operand\" \"=z\")\n+  [(set (match_operand:CC 0 \"fcc_reload_operand\" \"=z\")\n \t(match_operand:CC 1 \"register_operand\" \"\"))\n    (clobber (match_operand:TF 2 \"register_operand\" \"=&f\"))]\n   \"ISA_HAS_8CC && TARGET_HARD_FLOAT\"\n@@ -5497,7 +5500,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"branch_fp\"\n   [(set (pc)\n         (if_then_else\n-         (match_operator:CC 0 \"cmp_op\"\n+         (match_operator:CC 0 \"comparison_operator\"\n                             [(match_operand:CC 2 \"register_operand\" \"z\")\n \t\t\t     (const_int 0)])\n          (label_ref (match_operand 1 \"\" \"\"))\n@@ -5517,7 +5520,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"branch_fp_inverted\"\n   [(set (pc)\n         (if_then_else\n-         (match_operator:CC 0 \"cmp_op\"\n+         (match_operator:CC 0 \"comparison_operator\"\n                             [(match_operand:CC 2 \"register_operand\" \"z\")\n \t\t\t     (const_int 0)])\n          (pc)\n@@ -5539,7 +5542,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"branch_zero\"\n   [(set (pc)\n \t(if_then_else\n-         (match_operator:SI 0 \"cmp_op\"\n+         (match_operator:SI 0 \"comparison_operator\"\n \t\t\t    [(match_operand:SI 2 \"register_operand\" \"d\")\n \t\t\t     (const_int 0)])\n         (label_ref (match_operand 1 \"\" \"\"))\n@@ -5559,7 +5562,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"branch_zero_inverted\"\n   [(set (pc)\n \t(if_then_else\n-         (match_operator:SI 0 \"cmp_op\"\n+         (match_operator:SI 0 \"comparison_operator\"\n \t\t            [(match_operand:SI 2 \"register_operand\" \"d\")\n \t\t\t     (const_int 0)])\n         (pc)\n@@ -5579,7 +5582,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"branch_zero_di\"\n   [(set (pc)\n \t(if_then_else\n-         (match_operator:DI 0 \"cmp_op\"\n+         (match_operator:DI 0 \"comparison_operator\"\n \t\t            [(match_operand:DI 2 \"register_operand\" \"d\")\n \t\t\t     (const_int 0)])\n         (label_ref (match_operand 1 \"\" \"\"))\n@@ -5599,7 +5602,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"branch_zero_di_inverted\"\n   [(set (pc)\n \t(if_then_else\n-         (match_operator:DI 0 \"cmp_op\"\n+         (match_operator:DI 0 \"comparison_operator\"\n \t\t\t    [(match_operand:DI 2 \"register_operand\" \"d\")\n \t\t\t     (const_int 0)])\n         (pc)\n@@ -5621,7 +5624,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"branch_equality\"\n   [(set (pc)\n \t(if_then_else\n-         (match_operator:SI 0 \"equality_op\"\n+         (match_operator:SI 0 \"equality_operator\"\n \t\t   \t    [(match_operand:SI 2 \"register_operand\" \"d\")\n \t\t\t     (match_operand:SI 3 \"register_operand\" \"d\")])\n          (label_ref (match_operand 1 \"\" \"\"))\n@@ -5641,7 +5644,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"branch_equality_di\"\n   [(set (pc)\n \t(if_then_else\n-         (match_operator:DI 0 \"equality_op\"\n+         (match_operator:DI 0 \"equality_operator\"\n \t\t\t    [(match_operand:DI 2 \"register_operand\" \"d\")\n \t\t\t     (match_operand:DI 3 \"register_operand\" \"d\")])\n         (label_ref (match_operand 1 \"\" \"\"))\n@@ -5661,7 +5664,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"branch_equality_inverted\"\n   [(set (pc)\n \t(if_then_else\n-         (match_operator:SI 0 \"equality_op\"\n+         (match_operator:SI 0 \"equality_operator\"\n \t\t   \t    [(match_operand:SI 2 \"register_operand\" \"d\")\n \t\t\t     (match_operand:SI 3 \"register_operand\" \"d\")])\n          (pc)\n@@ -5681,7 +5684,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"branch_equality_di_inverted\"\n   [(set (pc)\n \t(if_then_else\n-         (match_operator:DI 0 \"equality_op\"\n+         (match_operator:DI 0 \"equality_operator\"\n \t\t\t    [(match_operand:DI 2 \"register_operand\" \"d\")\n \t\t\t     (match_operand:DI 3 \"register_operand\" \"d\")])\n         (pc)\n@@ -5702,9 +5705,10 @@ dsrl\\t%3,%3,1\\n\\\n \n (define_insn \"\"\n   [(set (pc)\n-\t(if_then_else (match_operator:SI 0 \"equality_op\"\n-\t\t\t\t\t [(match_operand:SI 1 \"register_operand\" \"d,t\")\n-\t\t\t\t\t  (const_int 0)])\n+\t(if_then_else\n+\t (match_operator:SI 0 \"equality_operator\"\n+\t\t\t    [(match_operand:SI 1 \"register_operand\" \"d,t\")\n+\t\t\t     (const_int 0)])\n \t(match_operand 2 \"pc_or_label_operand\" \"\")\n \t(match_operand 3 \"pc_or_label_operand\" \"\")))]\n   \"TARGET_MIPS16\"\n@@ -5730,9 +5734,10 @@ dsrl\\t%3,%3,1\\n\\\n \n (define_insn \"\"\n   [(set (pc)\n-\t(if_then_else (match_operator:DI 0 \"equality_op\"\n-\t\t\t\t\t [(match_operand:DI 1 \"register_operand\" \"d,t\")\n-\t\t\t\t\t  (const_int 0)])\n+\t(if_then_else\n+\t (match_operator:DI 0 \"equality_operator\"\n+\t\t\t    [(match_operand:DI 1 \"register_operand\" \"d,t\")\n+\t\t\t     (const_int 0)])\n \t(match_operand 2 \"pc_or_label_operand\" \"\")\n \t(match_operand 3 \"pc_or_label_operand\" \"\")))]\n   \"TARGET_MIPS16\"\n@@ -7305,7 +7310,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n \t(if_then_else:SI\n-\t (match_operator 4 \"equality_op\"\n+\t (match_operator 4 \"equality_operator\"\n \t\t\t [(match_operand:SI 1 \"register_operand\" \"d,d\")\n \t\t\t  (const_int 0)])\n \t (match_operand:SI 2 \"reg_or_0_operand\" \"dJ,0\")\n@@ -7320,7 +7325,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n \t(if_then_else:SI\n-\t (match_operator 4 \"equality_op\"\n+\t (match_operator 4 \"equality_operator\"\n \t\t\t [(match_operand:DI 1 \"register_operand\" \"d,d\")\n \t\t\t  (const_int 0)])\n \t (match_operand:SI 2 \"reg_or_0_operand\" \"dJ,0\")\n@@ -7335,10 +7340,9 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n \t(if_then_else:SI\n-\t (match_operator 3 \"equality_op\" [(match_operand:CC 4\n-\t\t\t\t\t\t\t    \"register_operand\"\n-\t\t\t\t\t\t\t    \"z,z\")\n-\t\t\t\t\t  (const_int 0)])\n+\t (match_operator 3 \"equality_operator\"\n+\t\t\t [(match_operand:CC 4 \"register_operand\" \"z,z\")\n+\t\t\t  (const_int 0)])\n \t (match_operand:SI 1 \"reg_or_0_operand\" \"dJ,0\")\n \t (match_operand:SI 2 \"reg_or_0_operand\" \"0,dJ\")))]\n   \"ISA_HAS_CONDMOVE && TARGET_HARD_FLOAT\"\n@@ -7351,7 +7355,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n \t(if_then_else:DI\n-\t (match_operator 4 \"equality_op\"\n+\t (match_operator 4 \"equality_operator\"\n \t\t\t [(match_operand:SI 1 \"register_operand\" \"d,d\")\n \t\t\t  (const_int 0)])\n \t (match_operand:DI 2 \"reg_or_0_operand\" \"dJ,0\")\n@@ -7366,7 +7370,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n \t(if_then_else:DI\n-\t (match_operator 4 \"equality_op\"\n+\t (match_operator 4 \"equality_operator\"\n \t\t\t [(match_operand:DI 1 \"register_operand\" \"d,d\")\n \t\t\t  (const_int 0)])\n \t (match_operand:DI 2 \"reg_or_0_operand\" \"dJ,0\")\n@@ -7381,10 +7385,9 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n \t(if_then_else:DI\n-\t (match_operator 3 \"equality_op\" [(match_operand:CC 4\n-\t\t\t\t\t\t\t    \"register_operand\"\n-\t\t\t\t\t\t\t    \"z,z\")\n-\t\t\t\t\t  (const_int 0)])\n+\t (match_operator 3 \"equality_operator\"\n+\t\t\t [(match_operand:CC 4 \"register_operand\" \"z,z\")\n+\t\t\t  (const_int 0)])\n \t (match_operand:DI 1 \"reg_or_0_operand\" \"dJ,0\")\n \t (match_operand:DI 2 \"reg_or_0_operand\" \"0,dJ\")))]\n   \"ISA_HAS_CONDMOVE && TARGET_HARD_FLOAT && TARGET_64BIT\"\n@@ -7397,7 +7400,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:SF\n-\t (match_operator 4 \"equality_op\"\n+\t (match_operator 4 \"equality_operator\"\n \t\t\t [(match_operand:SI 1 \"register_operand\" \"d,d\")\n \t\t\t  (const_int 0)])\n \t (match_operand:SF 2 \"register_operand\" \"f,0\")\n@@ -7412,7 +7415,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:SF\n-\t (match_operator 4 \"equality_op\"\n+\t (match_operator 4 \"equality_operator\"\n \t\t\t [(match_operand:DI 1 \"register_operand\" \"d,d\")\n \t\t\t  (const_int 0)])\n \t (match_operand:SF 2 \"register_operand\" \"f,0\")\n@@ -7427,10 +7430,9 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:SF\n-\t (match_operator 3 \"equality_op\" [(match_operand:CC 4\n-\t\t\t\t\t\t\t    \"register_operand\"\n-\t\t\t\t\t\t\t    \"z,z\")\n-\t\t\t\t\t  (const_int 0)])\n+\t (match_operator 3 \"equality_operator\"\n+\t\t\t [(match_operand:CC 4 \"register_operand\" \"z,z\")\n+\t\t\t  (const_int 0)])\n \t (match_operand:SF 1 \"register_operand\" \"f,0\")\n \t (match_operand:SF 2 \"register_operand\" \"0,f\")))]\n   \"ISA_HAS_CONDMOVE && TARGET_HARD_FLOAT\"\n@@ -7443,7 +7445,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:DF\n-\t (match_operator 4 \"equality_op\"\n+\t (match_operator 4 \"equality_operator\"\n \t\t\t [(match_operand:SI 1 \"register_operand\" \"d,d\")\n \t\t\t  (const_int 0)])\n \t (match_operand:DF 2 \"register_operand\" \"f,0\")\n@@ -7458,7 +7460,7 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:DF\n-\t (match_operator 4 \"equality_op\"\n+\t (match_operator 4 \"equality_operator\"\n \t\t\t [(match_operand:DI 1 \"register_operand\" \"d,d\")\n \t\t\t  (const_int 0)])\n \t (match_operand:DF 2 \"register_operand\" \"f,0\")\n@@ -7473,10 +7475,9 @@ dsrl\\t%3,%3,1\\n\\\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:DF\n-\t (match_operator 3 \"equality_op\" [(match_operand:CC 4\n-\t\t\t\t\t\t\t    \"register_operand\"\n-\t\t\t\t\t\t\t    \"z,z\")\n-\t\t\t\t\t  (const_int 0)])\n+\t (match_operator 3 \"equality_operator\"\n+\t\t\t [(match_operand:CC 4 \"register_operand\" \"z,z\")\n+\t\t\t  (const_int 0)])\n \t (match_operand:DF 1 \"register_operand\" \"f,0\")\n \t (match_operand:DF 2 \"register_operand\" \"0,f\")))]\n   \"ISA_HAS_CONDMOVE && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\""}, {"sha": "dfc68875205b80822ffa670f229ef45da1ef59f8", "filename": "gcc/config/mips/predicates.md", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=96a30b18264771ab63790ae9976105745c2cec66", "patch": "@@ -0,0 +1,202 @@\n+;; Predicate definitions for MIPS.\n+;; Copyright (C) 2004 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+(define_predicate \"const_uns_arith_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SMALL_OPERAND_UNSIGNED (INTVAL (op))\")))\n+\n+(define_predicate \"uns_arith_operand\"\n+  (ior (match_operand 0 \"const_uns_arith_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"const_arith_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SMALL_OPERAND (INTVAL (op))\")))\n+\n+(define_predicate \"arith_operand\"\n+  (ior (match_operand 0 \"const_arith_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"sle_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SMALL_OPERAND (INTVAL (op) + 1)\")))\n+\n+(define_predicate \"sleu_operand\"\n+  (and (match_operand 0 \"sle_operand\")\n+       (match_test \"INTVAL (op) + 1 != 0\")))\n+\n+(define_predicate \"const_0_operand\"\n+  (and (match_code \"const_int,const_double\")\n+       (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n+\n+(define_predicate \"reg_or_0_operand\"\n+  (ior (and (match_operand 0 \"const_0_operand\")\n+\t    (match_test \"!TARGET_MIPS16\"))\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"const_1_operand\"\n+  (and (match_code \"const_int,const_double\")\n+       (match_test \"op == CONST1_RTX (GET_MODE (op))\")))\n+\n+(define_predicate \"reg_or_1_operand\"\n+  (ior (match_operand 0 \"const_1_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"fpr_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"FP_REG_P (REGNO (op))\")))\n+\n+(define_predicate \"hilo_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"MD_REG_P (REGNO (op))\")))\n+\n+(define_predicate \"lo_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == LO_REGNUM\")))\n+\n+(define_predicate \"fcc_reload_operand\"\n+  (and (match_code \"reg,subreg\")\n+       (match_test \"ST_REG_P (true_regnum (op))\")))\n+\n+(define_special_predicate \"pc_or_label_operand\"\n+  (match_code \"pc,label_ref\"))\n+\n+(define_predicate \"const_call_insn_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum mips_symbol_type symbol_type;\n+\n+  if (!mips_symbolic_constant_p (op, &symbol_type))\n+    return false;\n+\n+  switch (symbol_type)\n+    {\n+    case SYMBOL_GENERAL:\n+      /* If -mlong-calls, force all calls to use register addressing.  */\n+      return !TARGET_LONG_CALLS;\n+\n+    case SYMBOL_GOT_GLOBAL:\n+      /* Without explicit relocs, there is no special syntax for\n+\t loading the address of a call destination into a register.\n+\t Using \"la $25,foo; jal $25\" would prevent the lazy binding\n+\t of \"foo\", so keep the address of global symbols with the\n+\t jal macro.  */\n+      return !TARGET_EXPLICIT_RELOCS;\n+\n+    default:\n+      return false;\n+    }\n+})\n+\n+(define_predicate \"call_insn_operand\"\n+  (ior (match_operand 0 \"const_call_insn_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"move_operand\"\n+  (match_operand 0 \"general_operand\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+      /* When generating mips16 code, LEGITIMATE_CONSTANT_P rejects\n+\t CONST_INTs that can't be loaded using simple insns.  */\n+      if (TARGET_MIPS16)\n+\treturn true;\n+\n+      /* When generating 32-bit code, allow DImode move_operands to\n+\t match arbitrary constants.  We split them after reload.  */\n+      if (!TARGET_64BIT && mode == DImode)\n+\treturn true;\n+\n+      /* Otherwise check whether the constant can be loaded in a single\n+\t instruction.  */\n+      return LUI_INT (op) || SMALL_INT (op) || SMALL_INT_UNSIGNED (op);\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return CONST_GP_P (op) || mips_atomic_symbolic_constant_p (op);\n+\n+    default:\n+      return true;\n+    }\n+})\n+\n+(define_predicate \"consttable_operand\"\n+  (match_test \"CONSTANT_P (op)\"))\n+\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum mips_symbol_type type;\n+  return mips_symbolic_constant_p (op, &type);\n+})\n+\n+(define_predicate \"general_symbolic_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum mips_symbol_type type;\n+  return mips_symbolic_constant_p (op, &type) && type == SYMBOL_GENERAL;\n+})\n+\n+(define_predicate \"global_got_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum mips_symbol_type type;\n+  return mips_symbolic_constant_p (op, &type) && type == SYMBOL_GOT_GLOBAL;\n+})\n+\n+(define_predicate \"local_got_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum mips_symbol_type type;\n+  return mips_symbolic_constant_p (op, &type) && type == SYMBOL_GOT_LOCAL;\n+})\n+\n+(define_predicate \"stack_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"mips_stack_address_p (XEXP (op, 0), GET_MODE (op))\")))\n+\n+(define_predicate \"macc_msac_operand\"\n+  (ior (and (match_code \"plus\") (match_test \"ISA_HAS_MACC\"))\n+       (and (match_code \"minus\") (match_test \"ISA_HAS_MSAC\")))\n+{\n+  rtx mult = XEXP (op, GET_CODE (op) == PLUS ? 0 : 1);\n+  rtx accum = XEXP (op, GET_CODE (op) == PLUS ? 1 : 0);\n+  return (GET_CODE (mult) == MULT\n+\t  && REG_P (XEXP (mult, 0))\n+\t  && REG_P (XEXP (mult, 1))\n+\t  && REG_P (accum));\n+})\n+\n+\n+(define_predicate \"equality_operator\"\n+  (match_code \"eq,ne\"))\n+\n+(define_predicate \"extend_operator\"\n+  (match_code \"zero_extend,sign_extend\"))\n+\n+(define_predicate \"trap_comparison_operator\"\n+  (match_code \"eq,ne,lt,ltu,ge,geu\"))\n+\n+\n+(define_predicate \"small_data_pattern\"\n+  (and (match_code \"set,parallel,unspec,unspec_volatile\")\n+       (match_test \"mips_small_data_pattern_p (op)\")))"}, {"sha": "620de13d62efdf0f9ca189a40b2cef80e83c0c5c", "filename": "gcc/config/mips/sb1.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fsb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a30b18264771ab63790ae9976105745c2cec66/gcc%2Fconfig%2Fmips%2Fsb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsb1.md?ref=96a30b18264771ab63790ae9976105745c2cec66", "patch": "@@ -390,15 +390,15 @@\n (define_insn_reservation \"ir_sb1_mtxfer\" 5\n   (and (eq_attr \"cpu\" \"sb1\")\n        (and (eq_attr \"type\" \"xfer\")\n-\t    (match_operand 0 \"fp_register_operand\")))\n+\t    (match_operand 0 \"fpr_operand\")))\n   \"sb1_fp0\")\n \n ;; mfc1 latency 1 cycle.  \n \n (define_insn_reservation \"ir_sb1_mfxfer\" 1\n   (and (eq_attr \"cpu\" \"sb1\")\n        (and (eq_attr \"type\" \"xfer\")\n-\t    (not (match_operand 0 \"fp_register_operand\"))))\n+\t    (not (match_operand 0 \"fpr_operand\"))))\n   \"sb1_fp0\")\n \n ;; ??? Can deliver at most 1 result per every 6 cycles because of issue"}]}