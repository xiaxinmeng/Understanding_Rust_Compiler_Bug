{"sha": "5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ2M2EzNWY5ZjFhMWVjMDE3MWFlOTAwM2ZiYTQwZGRjNjBkOGY1MQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-03-28T17:08:25Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-03-28T17:08:25Z"}, "message": "re PR fortran/36703 (ICE  (segfault) in reduce_binary0  (arith.c:1778))\n\n2009-02-13  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/36703\n\tPR fortran/36528\n\t* trans-expr.c (gfc_conv_function_val): Stabilize Cray-pointer\n\tfunction references to ensure that a valid expression is used.\n\t(gfc_conv_function_call): Pass Cray pointers to procedures.\n\n2009-02-13  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/36528\n\t* gfortran.dg/cray_pointers_8.f90: New test.\n\n\tPR fortran/36703\n\t* gfortran.dg/cray_pointers_9.f90: New test.\n\nFrom-SVN: r145196", "tree": {"sha": "9f45ffa189df27ff2584390980d827f3a38d280a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f45ffa189df27ff2584390980d827f3a38d280a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51/comments", "author": null, "committer": null, "parents": [{"sha": "6b02d5f75384dde3f9aa29817a806b797d86e377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b02d5f75384dde3f9aa29817a806b797d86e377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b02d5f75384dde3f9aa29817a806b797d86e377"}], "stats": {"total": 174, "additions": 145, "deletions": 29}, "files": [{"sha": "47ebdce5b4b2c9c1ff9d2959ca366af2c53eaecd", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51", "patch": "@@ -1,3 +1,9 @@\n+2009-03-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+        PR fortran/38538\n+        * trans-array.c (get_elemental_fcn_charlen): Remove.\n+\t(get_array_charlen): New function to replace previous.\n+\n 2009-03-28  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/38765"}, {"sha": "e7b52325495c78c01cc99ec13d01de57eac13ee5", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 85, "deletions": 29, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51", "patch": "@@ -4703,47 +4703,102 @@ gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,\n }\n \n \n-/* gfc_conv_expr_descriptor needs the character length of elemental\n-   functions before the function is called so that the size of the\n-   temporary can be obtained.  The only way to do this is to convert\n-   the expression, mapping onto the actual arguments.  */\n+/* gfc_conv_expr_descriptor needs the string length an expression\n+   so that the size of the temporary can be obtained.  This is done\n+   by adding up the string lengths of all the elements in the\n+   expression.  Function with non-constant expressions have their\n+   string lengths mapped onto the actual arguments using the\n+   interface mapping machinery in trans-expr.c.  */\n static void\n-get_elemental_fcn_charlen (gfc_expr *expr, gfc_se *se)\n+get_array_charlen (gfc_expr *expr, gfc_se *se)\n {\n   gfc_interface_mapping mapping;\n   gfc_formal_arglist *formal;\n   gfc_actual_arglist *arg;\n   gfc_se tse;\n \n-  formal = expr->symtree->n.sym->formal;\n-  arg = expr->value.function.actual;\n-  gfc_init_interface_mapping (&mapping);\n-\n-  /* Set se = NULL in the calls to the interface mapping, to suppress any\n-     backend stuff.  */\n-  for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)\n+  if (expr->ts.cl->length\n+\t&& gfc_is_constant_expr (expr->ts.cl->length))\n     {\n-      if (!arg->expr)\n-\tcontinue;\n-      if (formal->sym)\n-\tgfc_add_interface_mapping (&mapping, formal->sym, NULL, arg->expr);\n+      if (!expr->ts.cl->backend_decl)\n+\tgfc_conv_string_length (expr->ts.cl, expr, &se->pre);\n+      return;\n     }\n \n-  gfc_init_se (&tse, NULL);\n+  switch (expr->expr_type)\n+    {\n+    case EXPR_OP:\n+      get_array_charlen (expr->value.op.op1, se);\n+\n+      /* For parentheses the expression ts.cl is identical.  */\n+      if (expr->value.op.op == INTRINSIC_PARENTHESES)\n+\treturn;\n+\n+     expr->ts.cl->backend_decl =\n+\t\tgfc_create_var (gfc_charlen_type_node, \"sln\");\n+\n+      if (expr->value.op.op2)\n+\t{\n+\t  get_array_charlen (expr->value.op.op2, se);\n+\n+\t  /* Add the string lengths and assign them to the expression\n+\t     string length backend declaration.  */\n+\t  gfc_add_modify (&se->pre, expr->ts.cl->backend_decl,\n+\t\t\t  fold_build2 (PLUS_EXPR, gfc_charlen_type_node,\n+\t\t\t\texpr->value.op.op1->ts.cl->backend_decl,\n+\t\t\t\texpr->value.op.op2->ts.cl->backend_decl));\n+\t}\n+      else\n+\tgfc_add_modify (&se->pre, expr->ts.cl->backend_decl,\n+\t\t\texpr->value.op.op1->ts.cl->backend_decl);\n+      break;\n+\n+    case EXPR_FUNCTION:\n+      if (expr->value.function.esym == NULL\n+\t    || expr->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  gfc_conv_string_length (expr->ts.cl, expr, &se->pre);\n+\t  break;\n+\t}\n+\n+      /* Map expressions involving the dummy arguments onto the actual\n+\t argument expressions.  */\n+      gfc_init_interface_mapping (&mapping);\n+      formal = expr->symtree->n.sym->formal;\n+      arg = expr->value.function.actual;\n+\n+      /* Set se = NULL in the calls to the interface mapping, to suppress any\n+\t backend stuff.  */\n+      for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)\n+\t{\n+\t  if (!arg->expr)\n+\t    continue;\n+\t  if (formal->sym)\n+\t  gfc_add_interface_mapping (&mapping, formal->sym, NULL, arg->expr);\n+\t}\n \n-  /* Build the expression for the character length and convert it.  */\n-  gfc_apply_interface_mapping (&mapping, &tse, expr->ts.cl->length);\n+      gfc_init_se (&tse, NULL);\n \n-  gfc_add_block_to_block (&se->pre, &tse.pre);\n-  gfc_add_block_to_block (&se->post, &tse.post);\n-  tse.expr = fold_convert (gfc_charlen_type_node, tse.expr);\n-  tse.expr = fold_build2 (MAX_EXPR, gfc_charlen_type_node, tse.expr,\n-\t\t\t  build_int_cst (gfc_charlen_type_node, 0));\n-  expr->ts.cl->backend_decl = tse.expr;\n-  gfc_free_interface_mapping (&mapping);\n+      /* Build the expression for the character length and convert it.  */\n+      gfc_apply_interface_mapping (&mapping, &tse, expr->ts.cl->length);\n+\n+      gfc_add_block_to_block (&se->pre, &tse.pre);\n+      gfc_add_block_to_block (&se->post, &tse.post);\n+      tse.expr = fold_convert (gfc_charlen_type_node, tse.expr);\n+      tse.expr = fold_build2 (MAX_EXPR, gfc_charlen_type_node, tse.expr,\n+\t\t\t      build_int_cst (gfc_charlen_type_node, 0));\n+      expr->ts.cl->backend_decl = tse.expr;\n+      gfc_free_interface_mapping (&mapping);\n+      break;\n+\n+    default:\n+      gfc_conv_string_length (expr->ts.cl, expr, &se->pre);\n+      break;\n+    }\n }\n \n \n+\n /* Convert an array for passing as an actual argument.  Expressions and\n    vector subscripts are evaluated and stored in a temporary, which is then\n    passed.  For whole arrays the descriptor is passed.  For array sections\n@@ -4879,7 +4934,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  need_tmp = 1;\n \t  if (expr->ts.type == BT_CHARACTER\n \t\t&& expr->ts.cl->length->expr_type != EXPR_CONSTANT)\n-\t    get_elemental_fcn_charlen (expr, se);\n+\t    get_array_charlen (expr, se);\n \n \t  info = NULL;\n \t}\n@@ -4939,8 +4994,9 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       loop.temp_ss->type = GFC_SS_TEMP;\n       loop.temp_ss->next = gfc_ss_terminator;\n \n-      if (expr->ts.type == BT_CHARACTER && !expr->ts.cl->backend_decl)\n-\tgfc_conv_string_length (expr->ts.cl, expr, &se->pre);\n+      if (expr->ts.type == BT_CHARACTER\n+\t    && !expr->ts.cl->backend_decl)\n+\tget_array_charlen (expr, se);\n \n       loop.temp_ss->data.temp.type = gfc_typenode_for_spec (&expr->ts);\n "}, {"sha": "961d0d6bb1c33d8bf30cde5545cfc857e0d4e64e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51", "patch": "@@ -1,3 +1,8 @@\n+2009-03-28  Paul Thomas  <pault@gcc.gnu.org\n+\n+        PR fortran/38538\n+        * gfortran.dg/char_result_13.f90: New test.\n+\n 2009-03-28  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/38765"}, {"sha": "741d55f166a9504f47fee09066b407221a26618f", "filename": "gcc/testsuite/gfortran.dg/char_result_13.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_result_13.f90?ref=5d63a35f9f1a1ec0171ae9003fba40ddc60d8f51", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! Tests the fix for PR38538, where the character length for the\n+! argument of 'func' was not calculated.\n+!\n+! Contributed by Vivek Rao <vivekrao4@yahoo.com>\n+!\n+module abc\n+  implicit none\n+contains\n+  subroutine xmain (i, j)\n+    integer i, j\n+    call foo (func (\"_\"//bar (i)//\"x\"//bar (j)//\"x\"), \"_abcxabx\")  ! original was elemental\n+    call foo (nfunc(\"_\"//bar (j)//\"x\"//bar (i)//\"x\"), \"_abxabcx\")\n+  end subroutine xmain\n+!\n+  function bar (i) result(yy)\n+    integer i, j, k\n+    character (len = i) :: yy(2)\n+    do j = 1, size (yy, 1)\n+      do k = 1, i\n+        yy(j)(k:k) = char (96+k)\n+      end do\n+    end do\n+  end function bar\n+!\n+  elemental function func (yy) result(xy)\n+    character (len = *), intent(in) :: yy\n+    character (len = len (yy)) :: xy\n+    xy = yy\n+  end function func\n+!\n+  function nfunc (yy) result(xy)\n+    character (len = *), intent(in) :: yy(:)\n+    character (len = len (yy)) :: xy(size (yy))\n+    xy = yy\n+  end function nfunc\n+!\n+  subroutine foo(cc, teststr)\n+    character (len=*), intent(in) :: cc(:)\n+    character (len=*), intent(in) :: teststr\n+    if (any (cc .ne. teststr)) call abort\n+  end subroutine foo\n+end module abc\n+\n+  use abc\n+  call xmain(3, 2)\n+end\n+! { dg-final { cleanup-modules \"abc\" } }\n+"}]}