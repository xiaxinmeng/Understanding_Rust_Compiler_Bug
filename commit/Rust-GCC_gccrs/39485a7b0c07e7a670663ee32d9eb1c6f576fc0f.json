{"sha": "39485a7b0c07e7a670663ee32d9eb1c6f576fc0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk0ODVhN2IwYzA3ZTdhNjcwNjYzZWUzMmQ5ZWIxYzZmNTc2ZmMwZg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-10-31T18:11:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:11:05Z"}, "message": "sprint.adb (Sprint_Node_Actual, [...]): Do not print null exclusion twice in the case of an access definition...\n\n2006-10-31  Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\n\t* sprint.adb (Sprint_Node_Actual, case Parameter_Specification): Do not\n\tprint null exclusion twice in the case of an access definition,\n\tImplement new -gnatL switch\n\tRemove N_Return_Object_Declaration. We now use\n\tN_Object_Declaration instead. Implement the case for\n\tN_Extended_Return_Statement. Alphabetize the cases.\n\tAdd cases for new nodes N_Extended_Return_Statement and\n\tN_Return_Object_Declaration. The code is not yet written.\n\tUpdate the output for N_Formal_Object_Declaration\n\tand N_Object_Renaming_Declaration.\n\t(Write_Itype): Account for the case of a modular integer subtype whose\n\tbase type is private.\n\nFrom-SVN: r118314", "tree": {"sha": "1db24a44a429907b6655c13249e9ab382c0e32b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1db24a44a429907b6655c13249e9ab382c0e32b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39485a7b0c07e7a670663ee32d9eb1c6f576fc0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39485a7b0c07e7a670663ee32d9eb1c6f576fc0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39485a7b0c07e7a670663ee32d9eb1c6f576fc0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39485a7b0c07e7a670663ee32d9eb1c6f576fc0f/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e3da30b2ef2b73e936ee7821aad5a4ea44fbdf16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3da30b2ef2b73e936ee7821aad5a4ea44fbdf16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3da30b2ef2b73e936ee7821aad5a4ea44fbdf16"}], "stats": {"total": 422, "additions": 360, "deletions": 62}, "files": [{"sha": "2343aec98cc3e444b67eeea39902256cfff17a00", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 360, "deletions": 62, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39485a7b0c07e7a670663ee32d9eb1c6f576fc0f/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39485a7b0c07e7a670663ee32d9eb1c6f576fc0f/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=39485a7b0c07e7a670663ee32d9eb1c6f576fc0f", "patch": "@@ -47,11 +47,14 @@ with Uname;    use Uname;\n with Urealp;   use Urealp;\n \n package body Sprint is\n+   Current_Source_File : Source_File_Index;\n+   --  Index of source file whose generated code is being dumped\n \n-   Debug_Node : Node_Id := Empty;\n-   --  If we are in Debug_Generated_Code mode, then this location is set\n-   --  to the current node requiring Sloc fixup, until Set_Debug_Sloc is\n-   --  called to set the proper value. The call clears it back to Empty.\n+   Dump_Node : Node_Id := Empty;\n+   --  This is set to the current node, used for printing line numbers. In\n+   --  Debug_Generated_Code mode, Dump_Node is set to the current node\n+   --  requiring Sloc fixup, until Set_Debug_Sloc is called to set the proper\n+   --  value. The call clears it back to Empty.\n \n    Debug_Sloc : Source_Ptr;\n    --  Sloc of first byte of line currently being written if we are\n@@ -67,20 +70,26 @@ package body Sprint is\n    Dump_Freeze_Null : Boolean;\n    --  Set True if freeze nodes and non-source null statements output\n \n+   Freeze_Indent : Int := 0;\n+   --  Keep track of freeze indent level (controls output of blank lines before\n+   --  procedures within expression freeze actions). Relevant only if we are\n+   --  not in Dump_Source_Text mode, since in Dump_Source_Text mode we don't\n+   --  output these blank lines in any case.\n+\n    Indent : Int := 0;\n    --  Number of columns for current line output indentation\n \n    Indent_Annull_Flag : Boolean := False;\n    --  Set True if subsequent Write_Indent call to be ignored, gets reset\n    --  by this call, so it is only active to suppress a single indent call.\n \n+   Last_Line_Printed : Physical_Line_Number;\n+   --  This keeps track of the physical line number of the last source line\n+   --  that has been output. The value is only valid in Dump_Source_Text mode.\n+\n    Line_Limit : constant := 72;\n    --  Limit value for chopping long lines\n \n-   Freeze_Indent : Int := 0;\n-   --  Keep track of freeze indent level (controls blank lines before\n-   --  procedures within expression freeze actions)\n-\n    -------------------------------\n    -- Operator Precedence Table --\n    -------------------------------\n@@ -139,6 +148,13 @@ package body Sprint is\n    --  then start an extra line with two characters extra indentation for\n    --  continuing text on the next line.\n \n+   procedure Extra_Blank_Line;\n+   --  In some situations we write extra blank lines to separate the generated\n+   --  code to make it more readable. However, these extra blank lines are not\n+   --  generated in Dump_Source_Text mode, since there the source text lines\n+   --  output with preceding blank lines are quite sufficient as separators.\n+   --  This procedure writes a blank line if Dump_Source_Text is False.\n+\n    procedure Indent_Annull;\n    --  Causes following call to Write_Indent to be ignored. This is used when\n    --  a higher level node wants to stop a lower level node from starting a\n@@ -166,10 +182,9 @@ package body Sprint is\n    --  appropriate special syntax characters (# and @).\n \n    procedure Set_Debug_Sloc;\n-   --  If Debug_Node is non-empty, this routine sets the appropriate value\n+   --  If Dump_Node is non-empty, this routine sets the appropriate value\n    --  in its Sloc field, from the current location in the debug source file\n-   --  that is currently being written. Note that Debug_Node is always empty\n-   --  if a debug source file is not being written.\n+   --  that is currently being written.\n \n    procedure Sprint_And_List (List : List_Id);\n    --  Print the given list with items separated by vertical \"and\"\n@@ -194,6 +209,11 @@ package body Sprint is\n    procedure Write_Condition_And_Reason (Node : Node_Id);\n    --  Write Condition and Reason codes of Raise_xxx_Error node\n \n+   procedure Write_Corresponding_Source (S : String);\n+   --  If S is a string with a single keyword (possibly followed by a space),\n+   --  and if the next non-comment non-blank source line matches this keyword,\n+   --  then output all source lines up to this matching line.\n+\n    procedure Write_Discr_Specs (N : Node_Id);\n    --  Ouput discriminant specification for node, which is any of the type\n    --  declarations that can have discriminants.\n@@ -271,6 +291,19 @@ package body Sprint is\n    --  generated code only, since in this case we don't specially mark nodes\n    --  created by rewriting).\n \n+   procedure Write_Source_Line (L : Physical_Line_Number);\n+   --  If writing of interspersed source lines is enabled, then write the given\n+   --  line from the source file, preceded by Eol, then an extra blank line if\n+   --  the line has at least one blank, is not a comment and is not line one,\n+   --  then \"--\" and the line number followed by period followed by text of the\n+   --  source line (without terminating Eol). If interspersed source line\n+   --  output not enabled, then the call has no effect.\n+\n+   procedure Write_Source_Lines (L : Physical_Line_Number);\n+   --  If writing of interspersed source lines is enabled, then writes source\n+   --  lines Last_Line_Printed + 1 .. L, and updates Last_Line_Printed. If\n+   --  interspersed source line output not enabled, then call has no effect.\n+\n    procedure Write_Str_Sloc (S : String);\n    --  Like Write_Str, but sets debug Sloc of current debug node to first\n    --  non-blank character if a current debug node is active.\n@@ -312,6 +345,17 @@ package body Sprint is\n       end if;\n    end Col_Check;\n \n+   ----------------------\n+   -- Extra_Blank_Line --\n+   ----------------------\n+\n+   procedure Extra_Blank_Line is\n+   begin\n+      if not Dump_Source_Text then\n+         Write_Indent;\n+      end if;\n+   end Extra_Blank_Line;\n+\n    -------------------\n    -- Indent_Annull --\n    -------------------\n@@ -371,6 +415,7 @@ package body Sprint is\n    begin\n       Dump_Generated_Only := True;\n       Dump_Original_Only := False;\n+      Current_Source_File := No_Source_File;\n       Sprint_Node (Node);\n       Write_Eol;\n    end pg;\n@@ -383,6 +428,7 @@ package body Sprint is\n    begin\n       Dump_Generated_Only := False;\n       Dump_Original_Only := True;\n+      Current_Source_File := No_Source_File;\n       Sprint_Node (Node);\n       Write_Eol;\n    end po;\n@@ -419,6 +465,7 @@ package body Sprint is\n    begin\n       Dump_Generated_Only := False;\n       Dump_Original_Only := False;\n+      Current_Source_File := No_Source_File;\n       Sprint_Node (Node);\n       Write_Eol;\n    end ps;\n@@ -429,9 +476,9 @@ package body Sprint is\n \n    procedure Set_Debug_Sloc is\n    begin\n-      if Present (Debug_Node) then\n-         Set_Sloc (Debug_Node, Debug_Sloc + Source_Ptr (Column - 1));\n-         Debug_Node := Empty;\n+      if Debug_Generated_Code and then Present (Dump_Node) then\n+         Set_Sloc (Dump_Node, Debug_Sloc + Source_Ptr (Column - 1));\n+         Dump_Node := Empty;\n       end if;\n    end Set_Debug_Sloc;\n \n@@ -444,6 +491,10 @@ package body Sprint is\n       procedure Underline;\n       --  Put underline under string we just printed\n \n+      ---------------\n+      -- Underline --\n+      ---------------\n+\n       procedure Underline is\n          Col : constant Int := Column;\n \n@@ -472,6 +523,7 @@ package body Sprint is\n       --  avoids an infinite loop if an abort occurs during the dump.\n \n       if Debug_Flag_Z then\n+         Current_Source_File := No_Source_File;\n          Debug_Flag_Z := False;\n          Write_Eol;\n          Write_Eol;\n@@ -490,6 +542,7 @@ package body Sprint is\n          --  Dump requested units\n \n          for U in Main_Unit .. Last_Unit loop\n+            Current_Source_File := Source_Index (U);\n \n             --  Dump all units if -gnatdf set, otherwise we dump only\n             --  the source files that are in the extended main source.\n@@ -502,7 +555,10 @@ package body Sprint is\n                if Debug_Generated_Code then\n                   Set_Special_Output (Print_Debug_Line'Access);\n                   Create_Debug_Source (Source_Index (U), Debug_Sloc);\n+                  Write_Source_Line (1);\n+                  Last_Line_Printed := 1;\n                   Sprint_Node (Cunit (U));\n+                  Write_Source_Lines (Last_Source_Line (Current_Source_File));\n                   Write_Eol;\n                   Close_Debug_Source;\n                   Set_Special_Output (null);\n@@ -513,7 +569,10 @@ package body Sprint is\n                   Write_Str (\"Source recreated from tree for \");\n                   Write_Unit_Name (Unit_Name (U));\n                   Underline;\n+                  Write_Source_Line (1);\n+                  Last_Line_Printed := 1;\n                   Sprint_Node (Cunit (U));\n+                  Write_Source_Lines (Last_Source_Line (Current_Source_File));\n                   Write_Eol;\n                   Write_Eol;\n                end if;\n@@ -670,7 +729,7 @@ package body Sprint is\n    ------------------------\n \n    procedure Sprint_Node_Actual (Node : Node_Id) is\n-      Save_Debug_Node : constant Node_Id := Debug_Node;\n+      Save_Dump_Node : constant Node_Id := Dump_Node;\n \n    begin\n       if Node = Empty then\n@@ -681,12 +740,9 @@ package body Sprint is\n          Write_Str_With_Col_Check (\"(\");\n       end loop;\n \n-      --  Setup node for Sloc fixup if writing a debug source file. Note\n-      --  that we take care of any previous node not yet properly set.\n+      --  Setup current dump node\n \n-      if Debug_Generated_Code then\n-         Debug_Node := Node;\n-      end if;\n+      Dump_Node := Node;\n \n       if Nkind (Node) in N_Subexpr\n         and then Do_Range_Check (Node)\n@@ -1388,6 +1444,18 @@ package body Sprint is\n             Write_Char_Sloc ('.');\n             Write_Str_Sloc (\"all\");\n \n+         when N_Extended_Return_Statement =>\n+            Write_Indent_Str_Sloc (\"return \");\n+            Sprint_Node_List (Return_Object_Declarations (Node));\n+\n+            if Present (Handled_Statement_Sequence (Node)) then\n+               Write_Str_With_Col_Check (\" do\");\n+               Sprint_Node (Handled_Statement_Sequence (Node));\n+               Write_Indent_Str (\"end return;\");\n+            else\n+               Write_Indent_Str (\";\");\n+            end if;\n+\n          when N_Extension_Aggregate =>\n             Write_Str_With_Col_Check_Sloc (\"(\");\n             Sprint_Node (Ancestor_Part (Node));\n@@ -1478,11 +1546,27 @@ package body Sprint is\n                   Write_Str_With_Col_Check (\"out \");\n                end if;\n \n-               Sprint_Node (Subtype_Mark (Node));\n+               if Present (Subtype_Mark (Node)) then\n \n-               if Present (Expression (Node)) then\n+                  --  Ada 2005 (AI-423): Formal object with null exclusion\n+\n+                  if Null_Exclusion_Present (Node) then\n+                     Write_Str (\"not null \");\n+                  end if;\n+\n+                  Sprint_Node (Subtype_Mark (Node));\n+\n+               --  Ada 2005 (AI-423): Formal object with access definition\n+\n+               else\n+                  pragma Assert (Present (Access_Definition (Node)));\n+\n+                  Sprint_Node (Access_Definition (Node));\n+               end if;\n+\n+               if Present (Default_Expression (Node)) then\n                   Write_Str (\" := \");\n-                  Sprint_Node (Expression (Node));\n+                  Sprint_Node (Default_Expression (Node));\n                end if;\n \n                Write_Char (';');\n@@ -1550,6 +1634,10 @@ package body Sprint is\n                   Write_Char (']');\n \n                else\n+                  --  Output freeze actions. We increment Freeze_Indent during\n+                  --  this output to avoid generating extra blank lines before\n+                  --  any procedures included in the freeze actions.\n+\n                   Freeze_Indent := Freeze_Indent + 1;\n                   Sprint_Indented_List (Actions (Node));\n                   Freeze_Indent := Freeze_Indent - 1;\n@@ -1615,7 +1703,7 @@ package body Sprint is\n             Write_Char (';');\n \n          when N_Generic_Package_Declaration =>\n-            Write_Indent;\n+            Extra_Blank_Line;\n             Write_Indent_Str_Sloc (\"generic \");\n             Sprint_Indented_List (Generic_Formal_Declarations (Node));\n             Write_Indent;\n@@ -1637,7 +1725,7 @@ package body Sprint is\n             Write_Char (';');\n \n          when N_Generic_Subprogram_Declaration =>\n-            Write_Indent;\n+            Extra_Blank_Line;\n             Write_Indent_Str_Sloc (\"generic \");\n             Sprint_Indented_List (Generic_Formal_Declarations (Node));\n             Write_Indent;\n@@ -1870,6 +1958,13 @@ package body Sprint is\n                Sprint_Node (Access_Definition (Node));\n \n             elsif Present (Subtype_Mark (Node)) then\n+\n+               --  Ada 2005 (AI-423): Object renaming with a null exclusion\n+\n+               if Null_Exclusion_Present (Node) then\n+                  Write_Str (\"not null \");\n+               end if;\n+\n                Sprint_Node (Subtype_Mark (Node));\n \n             else\n@@ -2026,7 +2121,7 @@ package body Sprint is\n             Write_Str_With_Col_Check_Sloc (\"others\");\n \n          when N_Package_Body =>\n-            Write_Indent;\n+            Extra_Blank_Line;\n             Write_Indent_Str_Sloc (\"package body \");\n             Sprint_Node (Defining_Unit_Name (Node));\n             Write_Str (\" is\");\n@@ -2047,13 +2142,13 @@ package body Sprint is\n             Write_Str_With_Col_Check (\" is separate;\");\n \n          when N_Package_Declaration =>\n-            Write_Indent;\n+            Extra_Blank_Line;\n             Write_Indent;\n             Sprint_Node_Sloc (Specification (Node));\n             Write_Char (';');\n \n          when N_Package_Instantiation =>\n-            Write_Indent;\n+            Extra_Blank_Line;\n             Write_Indent_Str_Sloc (\"package \");\n             Sprint_Node (Defining_Unit_Name (Node));\n             Write_Str (\" is new \");\n@@ -2101,9 +2196,15 @@ package body Sprint is\n                   Write_Str_With_Col_Check (\"out \");\n                end if;\n \n-               --  Ada 2005 (AI-231)\n+               --  Ada 2005 (AI-231) parameter specification may carry\n+               --  null exclusion. Do not print it now if this is an\n+               --  access parameter, it is emitted when the access\n+               --  definition is displayed.\n \n-               if Null_Exclusion_Present (Node) then\n+               if Null_Exclusion_Present (Node)\n+                 and then Nkind (Parameter_Type (Node))\n+                   /= N_Access_Definition\n+               then\n                   Write_Str (\"not null \");\n                end if;\n \n@@ -2451,8 +2552,11 @@ package body Sprint is\n             Write_String_Table_Entry (Strval (Node));\n \n          when N_Subprogram_Body =>\n+\n+            --  Output extra blank line unless we are in freeze actions\n+\n             if Freeze_Indent = 0 then\n-               Write_Indent;\n+               Extra_Blank_Line;\n             end if;\n \n             Write_Indent;\n@@ -2525,7 +2629,7 @@ package body Sprint is\n             Write_Indent_Str_Sloc (\"separate (\");\n             Sprint_Node (Name (Node));\n             Write_Char (')');\n-            Write_Eol;\n+            Extra_Blank_Line;\n             Sprint_Node (Proper_Body (Node));\n \n          when N_Task_Body =>\n@@ -2761,8 +2865,7 @@ package body Sprint is\n          Write_Char (')');\n       end loop;\n \n-      pragma Assert (No (Debug_Node));\n-      Debug_Node := Save_Debug_Node;\n+      Dump_Node := Save_Dump_Node;\n    end Sprint_Node_Actual;\n \n    ----------------------\n@@ -2792,9 +2895,9 @@ package body Sprint is\n    begin\n       Sprint_Node (Node);\n \n-      if Present (Debug_Node) then\n-         Set_Sloc (Debug_Node, Sloc (Node));\n-         Debug_Node := Empty;\n+      if Debug_Generated_Code and then Present (Dump_Node) then\n+         Set_Sloc (Dump_Node, Sloc (Node));\n+         Dump_Node := Empty;\n       end if;\n    end Sprint_Node_Sloc;\n \n@@ -2905,17 +3008,45 @@ package body Sprint is\n    --------------------------------\n \n    procedure Write_Condition_And_Reason (Node : Node_Id) is\n-      Image : constant String := RT_Exception_Code'Image\n-                                   (RT_Exception_Code'Val\n-                                     (UI_To_Int (Reason (Node))));\n+      Cond  : constant Node_Id := Condition (Node);\n+      Image : constant String  := RT_Exception_Code'Image\n+                                    (RT_Exception_Code'Val\n+                                       (UI_To_Int (Reason (Node))));\n \n    begin\n-      if Present (Condition (Node)) then\n-         Write_Str_With_Col_Check (\" when \");\n-         Sprint_Node (Condition (Node));\n+      if Present (Cond) then\n+\n+         --  If condition is a single entity, or NOT with a single entity,\n+         --  output all on one line, since it will likely fit just fine.\n+\n+         if Is_Entity_Name (Cond)\n+           or else (Nkind (Cond) = N_Op_Not\n+                     and then Is_Entity_Name (Right_Opnd (Cond)))\n+         then\n+            Write_Str_With_Col_Check (\" when \");\n+            Sprint_Node (Cond);\n+            Write_Char (' ');\n+\n+            --  Otherwise for more complex condition, multiple lines\n+\n+         else\n+            Write_Str_With_Col_Check (\" when\");\n+            Indent := Indent + 2;\n+            Write_Indent;\n+            Sprint_Node (Cond);\n+            Write_Indent;\n+            Indent := Indent - 2;\n+         end if;\n+\n+      --  If no condition, just need a space (all on one line)\n+\n+      else\n+         Write_Char (' ');\n       end if;\n \n-      Write_Str (\" \"\"\");\n+      --  Write the reason\n+\n+      Write_Char ('\"');\n \n       for J in 4 .. Image'Last loop\n          if Image (J) = '_' then\n@@ -2928,6 +3059,93 @@ package body Sprint is\n       Write_Str (\"\"\"]\");\n    end Write_Condition_And_Reason;\n \n+   --------------------------------\n+   -- Write_Corresponding_Source --\n+   --------------------------------\n+\n+   procedure Write_Corresponding_Source (S : String) is\n+      Loc : Source_Ptr;\n+      Src : Source_Buffer_Ptr;\n+\n+   begin\n+      --  Ignore if not in dump source text mode, or if in freeze actions\n+\n+      if Dump_Source_Text and then Freeze_Indent = 0 then\n+\n+         --  Ignore null string\n+\n+         if S = \"\" then\n+            return;\n+         end if;\n+\n+         --  Ignore space or semicolon at end of given string\n+\n+         if S (S'Last) = ' ' or else S (S'Last) = ';' then\n+            Write_Corresponding_Source (S (S'First .. S'Last - 1));\n+            return;\n+         end if;\n+\n+         --  Loop to look at next lines not yet printed in source file\n+\n+         for L in\n+           Last_Line_Printed + 1 .. Last_Source_Line (Current_Source_File)\n+         loop\n+            Src := Source_Text (Current_Source_File);\n+            Loc := Line_Start (L, Current_Source_File);\n+\n+            --  If comment, keep looking\n+\n+            if Src (Loc .. Loc + 1) = \"--\" then\n+               null;\n+\n+            --  Search to first non-blank\n+\n+            else\n+               while Src (Loc) not in Line_Terminator loop\n+\n+                  --  Non-blank found\n+\n+                  if Src (Loc) /= ' ' and then Src (Loc) /= ASCII.HT then\n+\n+                     --  Loop through characters in string to see if we match\n+\n+                     for J in S'Range loop\n+\n+                        --  If mismatch, then not the case we are looking for\n+\n+                        if Src (Loc) /= S (J) then\n+                           return;\n+                        end if;\n+\n+                        Loc := Loc + 1;\n+                     end loop;\n+\n+                     --  If we fall through, string matched, if white space or\n+                     --  semicolon after the matched string, this is the case\n+                     --  we are looking for.\n+\n+                     if Src (Loc) in Line_Terminator\n+                       or else Src (Loc) = ' '\n+                       or else Src (Loc) = ASCII.HT\n+                       or else Src (Loc) = ';'\n+                     then\n+                        --  So output source lines up to and including this one\n+\n+                        Write_Source_Lines (L);\n+                        return;\n+                     end if;\n+                  end if;\n+\n+                  Loc := Loc + 1;\n+               end loop;\n+            end if;\n+\n+         --  Line was all blanks, or a comment line, keep looking\n+\n+         end loop;\n+      end if;\n+   end Write_Corresponding_Source;\n+\n    -----------------------\n    -- Write_Discr_Specs --\n    -----------------------\n@@ -3107,10 +3325,19 @@ package body Sprint is\n    ------------------\n \n    procedure Write_Indent is\n+      Loc : constant Source_Ptr := Sloc (Dump_Node);\n+\n    begin\n       if Indent_Annull_Flag then\n          Indent_Annull_Flag := False;\n       else\n+         if Dump_Source_Text and then Loc > No_Location then\n+            if Get_Source_File_Index (Loc) = Current_Source_File then\n+               Write_Source_Lines\n+                 (Get_Physical_Line_Number (Sloc (Dump_Node)));\n+            end if;\n+         end if;\n+\n          Write_Eol;\n \n          for J in 1 .. Indent loop\n@@ -3177,9 +3404,7 @@ package body Sprint is\n       --  The remainder of the declaration must be printed unless we are\n       --  printing the original tree and this is not the last identifier\n \n-      return\n-         not Dump_Original_Only or else not More_Ids (Node);\n-\n+      return not Dump_Original_Only or else not More_Ids (Node);\n    end Write_Indent_Identifiers_Sloc;\n \n    ----------------------\n@@ -3188,6 +3413,7 @@ package body Sprint is\n \n    procedure Write_Indent_Str (S : String) is\n    begin\n+      Write_Corresponding_Source (S);\n       Write_Indent;\n       Write_Str (S);\n    end Write_Indent_Str;\n@@ -3198,6 +3424,7 @@ package body Sprint is\n \n    procedure Write_Indent_Str_Sloc (S : String) is\n    begin\n+      Write_Corresponding_Source (S);\n       Write_Indent;\n       Write_Str_Sloc (S);\n    end Write_Indent_Str_Sloc;\n@@ -3352,21 +3579,37 @@ package body Sprint is\n \n                      Write_Id (B);\n \n-                     --  Print bounds if not different from base type\n+                     --  Print bounds if different from base type\n \n                      declare\n                         L  : constant Node_Id := Type_Low_Bound (Typ);\n                         H  : constant Node_Id := Type_High_Bound (Typ);\n-                        LE : constant Node_Id := Type_Low_Bound (B);\n-                        HE : constant Node_Id := Type_High_Bound (B);\n+                        LE : Node_Id;\n+                        HE : Node_Id;\n \n                      begin\n-                        if Nkind (L) = N_Integer_Literal\n-                          and then Nkind (H) = N_Integer_Literal\n-                          and then Nkind (LE) = N_Integer_Literal\n-                          and then Nkind (HE) = N_Integer_Literal\n-                          and then UI_Eq (Intval (L), Intval (LE))\n-                          and then UI_Eq (Intval (H), Intval (HE))\n+                        --  B can either be a scalar type, in which case the\n+                        --  declaration of Typ may constrain it with different\n+                        --  bounds, or a private type, in which case we know\n+                        --  that the declaration of Typ cannot have a scalar\n+                        --  constraint.\n+\n+                        if Is_Scalar_Type (B) then\n+                           LE := Type_Low_Bound (B);\n+                           HE := Type_High_Bound (B);\n+                        else\n+                           LE := Empty;\n+                           HE := Empty;\n+                        end if;\n+\n+                        if No (LE)\n+                          or else (True\n+                            and then Nkind (L) = N_Integer_Literal\n+                            and then Nkind (H) = N_Integer_Literal\n+                            and then Nkind (LE) = N_Integer_Literal\n+                            and then Nkind (HE) = N_Integer_Literal\n+                            and then UI_Eq (Intval (L), Intval (LE))\n+                            and then UI_Eq (Intval (H), Intval (HE)))\n                         then\n                            null;\n \n@@ -3659,9 +3902,9 @@ package body Sprint is\n       end if;\n    end Write_Param_Specs;\n \n-   --------------------------\n+   -----------------------\n    -- Write_Rewrite_Str --\n-   --------------------------\n+   -----------------------\n \n    procedure Write_Rewrite_Str (S : String) is\n    begin\n@@ -3674,6 +3917,61 @@ package body Sprint is\n       end if;\n    end Write_Rewrite_Str;\n \n+   -----------------------\n+   -- Write_Source_Line --\n+   -----------------------\n+\n+   procedure Write_Source_Line (L : Physical_Line_Number) is\n+      Loc : Source_Ptr;\n+      Src : Source_Buffer_Ptr;\n+      Scn : Source_Ptr;\n+\n+   begin\n+      if Dump_Source_Text then\n+         Src := Source_Text (Current_Source_File);\n+         Loc := Line_Start (L, Current_Source_File);\n+         Write_Eol;\n+\n+         --  See if line is a comment line, if not, and if not line one,\n+         --  precede with blank line.\n+\n+         Scn := Loc;\n+         while Src (Scn) = ' ' or else Src (Scn) = ASCII.HT loop\n+            Scn := Scn + 1;\n+         end loop;\n+\n+         if (Src (Scn) in Line_Terminator\n+              or else Src (Scn .. Scn + 1) /= \"--\")\n+           and then L /= 1\n+         then\n+            Write_Eol;\n+         end if;\n+\n+         --  Now write the source text of the line\n+\n+         Write_Str (\"-- \");\n+         Write_Int (Int (L));\n+         Write_Str (\": \");\n+\n+         while Src (Loc) not in Line_Terminator loop\n+            Write_Char (Src (Loc));\n+            Loc := Loc + 1;\n+         end loop;\n+      end if;\n+   end Write_Source_Line;\n+\n+   ------------------------\n+   -- Write_Source_Lines --\n+   ------------------------\n+\n+   procedure Write_Source_Lines (L : Physical_Line_Number) is\n+   begin\n+      while Last_Line_Printed < L loop\n+         Last_Line_Printed := Last_Line_Printed + 1;\n+         Write_Source_Line (Last_Line_Printed);\n+      end loop;\n+   end Write_Source_Lines;\n+\n    --------------------\n    -- Write_Str_Sloc --\n    --------------------\n@@ -3694,8 +3992,8 @@ package body Sprint is\n       if Int (S'Last) + Column > Line_Limit then\n          Write_Indent_Str (\"  \");\n \n-         if S (1) = ' ' then\n-            Write_Str (S (2 .. S'Length));\n+         if S (S'First) = ' ' then\n+            Write_Str (S (S'First + 1 .. S'Last));\n          else\n             Write_Str (S);\n          end if;\n@@ -3714,8 +4012,8 @@ package body Sprint is\n       if Int (S'Last) + Column > Line_Limit then\n          Write_Indent_Str (\"  \");\n \n-         if S (1) = ' ' then\n-            Write_Str_Sloc (S (2 .. S'Length));\n+         if S (S'First) = ' ' then\n+            Write_Str_Sloc (S (S'First + 1 .. S'Last));\n          else\n             Write_Str_Sloc (S);\n          end if;"}]}