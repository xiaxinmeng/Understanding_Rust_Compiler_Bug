{"sha": "1d548381aa6ea98a2e15bc1af0d1ad44f9c6adf0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ1NDgzODFhYTZlYTk4YTJlMTViYzFhZjBkMWFkNDRmOWM2YWRmMA==", "commit": {"author": {"name": "Jack Howarth", "email": "howarth@bromo.med.uc.edu", "date": "2012-02-28T15:37:41Z"}, "committer": {"name": "Patrick Marlier", "email": "pmarlier@gcc.gnu.org", "date": "2012-02-28T15:37:41Z"}, "message": "re PR boehm-gc/48299 (FAIL: boehm-gc.c/thread_leak_test.c)\n\n2012-02-27  Jack Howarth  <howarth@bromo.med.uc.edu>\n\t    Patrick Marlier  <patrick.marlier@gmail.com>\n\n\tPR boehm-gc/48299\n\ttestsuite/boehm-gc.c/thread_leak_test.c: Merge upstream changes.\n\n\nCo-Authored-By: Patrick Marlier <patrick.marlier@gmail.com>\n\nFrom-SVN: r184628", "tree": {"sha": "7e7623d8d31253b1520e50eb5e85c092aee12eb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e7623d8d31253b1520e50eb5e85c092aee12eb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d548381aa6ea98a2e15bc1af0d1ad44f9c6adf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d548381aa6ea98a2e15bc1af0d1ad44f9c6adf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d548381aa6ea98a2e15bc1af0d1ad44f9c6adf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d548381aa6ea98a2e15bc1af0d1ad44f9c6adf0/comments", "author": null, "committer": null, "parents": [{"sha": "8eef33ca3d454683efe712356b9845ef00cbaf36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eef33ca3d454683efe712356b9845ef00cbaf36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eef33ca3d454683efe712356b9845ef00cbaf36"}], "stats": {"total": 61, "additions": 50, "deletions": 11}, "files": [{"sha": "da69caf61438495c9a624fe4028fa534cafbe0ad", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d548381aa6ea98a2e15bc1af0d1ad44f9c6adf0/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d548381aa6ea98a2e15bc1af0d1ad44f9c6adf0/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=1d548381aa6ea98a2e15bc1af0d1ad44f9c6adf0", "patch": "@@ -1,3 +1,9 @@\n+2012-02-27  Jack Howarth  <howarth@bromo.med.uc.edu>\n+\t    Patrick Marlier  <patrick.marlier@gmail.com>\n+\n+\tPR boehm-gc/48299\n+\ttestsuite/boehm-gc.c/thread_leak_test.c: Merge upstream changes.\n+\n 2012-02-23  Patrick Marlier  <patrick.marlier@gmail.com>\n \t    Jack Howarth  <howarth@bromo.med.uc.edu>\n "}, {"sha": "89014651261bc02ec30ecf9f14c504af90c21b55", "filename": "boehm-gc/testsuite/boehm-gc.c/thread_leak_test.c", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d548381aa6ea98a2e15bc1af0d1ad44f9c6adf0/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fthread_leak_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d548381aa6ea98a2e15bc1af0d1ad44f9c6adf0/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fthread_leak_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftestsuite%2Fboehm-gc.c%2Fthread_leak_test.c?ref=1d548381aa6ea98a2e15bc1af0d1ad44f9c6adf0", "patch": "@@ -1,37 +1,70 @@\n-#define GC_LINUX_THREADS\n+#ifndef GC_THREADS\n+# define GC_THREADS\n+#endif\n #include \"leak_detector.h\"\n-#include <pthread.h>\n+#ifdef GC_PTHREADS\n+# include <pthread.h>\n+#else\n+# include <windows.h>\n+#endif\n #include <stdio.h>\n \n-void * test(void * arg) {\n+#ifdef GC_PTHREADS\n+  void * test(void * arg)\n+#else\n+  DWORD WINAPI test(LPVOID arg)\n+#endif\n+{\n     int *p[10];\n     int i;\n-    GC_find_leak = 1; /* for new collect versions not compiled  */\n-    /* with -DFIND_LEAK.                                        */\n     for (i = 0; i < 10; ++i) {\n         p[i] = malloc(sizeof(int)+i);\n     }\n     CHECK_LEAKS();\n     for (i = 1; i < 10; ++i) {\n         free(p[i]);\n     }\n-}       \n+#ifdef GC_PTHREADS\n+    return arg;\n+#else\n+    return (DWORD)(GC_word)arg;\n+#endif\n+}\n \n #define NTHREADS 5\n \n-int main() {\n+int main(void) {\n     int i;\n+#ifdef GC_PTHREADS\n     pthread_t t[NTHREADS];\n+#else\n+    HANDLE t[NTHREADS];\n+    DWORD thread_id;\n+#endif\n     int code;\n \n+    GC_find_leak = 1;    /* for new collect versions not compiled       */\n+    GC_INIT();\n     for (i = 0; i < NTHREADS; ++i) {\n-\tif ((code = pthread_create(t + i, 0, test, 0)) != 0) {\n-    \t    printf(\"Thread creation failed %d\\n\", code);\n+#ifdef GC_PTHREADS\n+       code = pthread_create(t + i, 0, test, 0);\n+#else\n+       t[i] = CreateThread(NULL, 0, test, 0, 0, &thread_id);\n+       code = t[i] != NULL ? 0 : (int)GetLastError();\n+#endif\n+       if (code != 0) {\n+          printf(\"Thread creation failed %d\\n\", code);\n         }\n     }\n     for (i = 0; i < NTHREADS; ++i) {\n-\tif ((code = pthread_join(t[i], 0)) != 0) {\n-            printf(\"Thread join failed %lu\\n\", code);\n+#ifdef GC_PTHREADS\n+       code = pthread_join(t[i], 0);\n+#else\n+       code = WaitForSingleObject(t[i], INFINITE) == WAIT_OBJECT_0 ? 0 :\n+                                                        (int)GetLastError();\n+#endif\n+       if (code != 0) {\n+          printf(\"Thread join failed %d\\n\", code);\n         }\n     }\n     CHECK_LEAKS();"}]}