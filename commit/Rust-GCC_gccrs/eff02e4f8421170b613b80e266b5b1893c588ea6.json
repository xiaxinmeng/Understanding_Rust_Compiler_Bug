{"sha": "eff02e4f8421170b613b80e266b5b1893c588ea6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZmMDJlNGY4NDIxMTcwYjYxM2I4MGUyNjZiNWIxODkzYzU4OGVhNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2012-09-17T16:38:38Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-09-17T16:38:38Z"}, "message": "libbacktrace/:\n\n\t* Initial implementation.\n\n./:\n\t* MAINTAINERS (Various Maintainers): Add libbacktrace.\n\t* configure.ac (host_libs): Add libbacktrace.\n\t(target_libraries): Add libbacktrace.\n\t* Makefile.def (host_modules): Add libbacktrace.\n\t(target_modules): Likewise.\n\t* configure, Makefile.in: Rebuild.\n\ngcc/go:\n\t* config-lang.in (target_libs): Add target-libbacktrace.\n\nFrom-SVN: r191397", "tree": {"sha": "faa7758f2b343cc2da8066591b1f81f7833aca15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/faa7758f2b343cc2da8066591b1f81f7833aca15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eff02e4f8421170b613b80e266b5b1893c588ea6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff02e4f8421170b613b80e266b5b1893c588ea6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eff02e4f8421170b613b80e266b5b1893c588ea6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff02e4f8421170b613b80e266b5b1893c588ea6/comments", "author": null, "committer": null, "parents": [{"sha": "142c8954fd43340a3207f26b260f793685d9b3cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/142c8954fd43340a3207f26b260f793685d9b3cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/142c8954fd43340a3207f26b260f793685d9b3cd"}], "stats": {"total": 23003, "additions": 23000, "deletions": 3}, "files": [{"sha": "7ee7b30a3a88989feeb382faaf67d7f8dcf7127d", "filename": "ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -1,3 +1,12 @@\n+2012-09-17  Ian Lance Taylor  <iant@google.com>\n+\n+\t* MAINTAINERS (Various Maintainers): Add libbacktrace.\n+\t* configure.ac (host_libs): Add libbacktrace.\n+\t(target_libraries): Add libbacktrace.\n+\t* Makefile.def (host_modules): Add libbacktrace.\n+\t(target_modules): Likewise.\n+\t* configure, Makefile.in: Rebuild.\n+\n 2012-09-14  David Edelsohn  <dje.gcc@gmail.com>\n \n \tPR target/38607"}, {"sha": "302a58cf3bead3348bc99594ec90c776e15acfda", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -155,6 +155,7 @@ objective-c/c++\t\tStan Shebs\t\tstanshebs@earthlink.net\n \n \t\t\tVarious Maintainers\n \n+libbacktrace\t\tIan Lance Taylor\tian@airs.com\n libcpp\t\t\tPer Bothner\t\tper@bothner.com\n libcpp\t\t\tAll C and C++ front end maintainers\n fp-bit\t\t\tIan Lance Taylor\tian@airs.com"}, {"sha": "f32ffb0f5cae16c4d182dd77e4eaeddef52f3397", "filename": "Makefile.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -80,6 +80,7 @@ host_modules= { module= tcl;\n                 missing=mostlyclean; };\n host_modules= { module= itcl; };\n host_modules= { module= ld; bootstrap=true; };\n+host_modules= { module= libbacktrace; bootstrap=true; };\n host_modules= { module= libcpp; bootstrap=true; };\n host_modules= { module= libdecnumber; bootstrap=true; };\n host_modules= { module= libgui; };\n@@ -121,6 +122,7 @@ target_modules = { module= libmudflap; lib_path=.libs; };\n target_modules = { module= libssp; lib_path=.libs; };\n target_modules = { module= newlib; };\n target_modules = { module= libgcc; bootstrap=true; no_check=true; };\n+target_modules = { module= libbacktrace; };\n target_modules = { module= libquadmath; };\n target_modules = { module= libgfortran; };\n target_modules = { module= libobjc; };"}, {"sha": "4200d5d5307a3cf7b25271f8bdc0adb03dc550dd", "filename": "Makefile.in", "status": "modified", "additions": 1452, "deletions": 0, "changes": 1452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -890,6 +890,7 @@ configure-host:  \\\n     maybe-configure-tcl \\\n     maybe-configure-itcl \\\n     maybe-configure-ld \\\n+    maybe-configure-libbacktrace \\\n     maybe-configure-libcpp \\\n     maybe-configure-libdecnumber \\\n     maybe-configure-libgui \\\n@@ -916,6 +917,7 @@ configure-target:  \\\n     maybe-configure-target-libssp \\\n     maybe-configure-target-newlib \\\n     maybe-configure-target-libgcc \\\n+    maybe-configure-target-libbacktrace \\\n     maybe-configure-target-libquadmath \\\n     maybe-configure-target-libgfortran \\\n     maybe-configure-target-libobjc \\\n@@ -1021,6 +1023,9 @@ all-host: maybe-all-itcl\n @if ld-no-bootstrap\n all-host: maybe-all-ld\n @endif ld-no-bootstrap\n+@if libbacktrace-no-bootstrap\n+all-host: maybe-all-libbacktrace\n+@endif libbacktrace-no-bootstrap\n @if libcpp-no-bootstrap\n all-host: maybe-all-libcpp\n @endif libcpp-no-bootstrap\n@@ -1062,6 +1067,7 @@ all-target: maybe-all-target-newlib\n @if target-libgcc-no-bootstrap\n all-target: maybe-all-target-libgcc\n @endif target-libgcc-no-bootstrap\n+all-target: maybe-all-target-libbacktrace\n all-target: maybe-all-target-libquadmath\n all-target: maybe-all-target-libgfortran\n all-target: maybe-all-target-libobjc\n@@ -1121,6 +1127,7 @@ info-host: maybe-info-intl\n info-host: maybe-info-tcl\n info-host: maybe-info-itcl\n info-host: maybe-info-ld\n+info-host: maybe-info-libbacktrace\n info-host: maybe-info-libcpp\n info-host: maybe-info-libdecnumber\n info-host: maybe-info-libgui\n@@ -1148,6 +1155,7 @@ info-target: maybe-info-target-libmudflap\n info-target: maybe-info-target-libssp\n info-target: maybe-info-target-newlib\n info-target: maybe-info-target-libgcc\n+info-target: maybe-info-target-libbacktrace\n info-target: maybe-info-target-libquadmath\n info-target: maybe-info-target-libgfortran\n info-target: maybe-info-target-libobjc\n@@ -1200,6 +1208,7 @@ dvi-host: maybe-dvi-intl\n dvi-host: maybe-dvi-tcl\n dvi-host: maybe-dvi-itcl\n dvi-host: maybe-dvi-ld\n+dvi-host: maybe-dvi-libbacktrace\n dvi-host: maybe-dvi-libcpp\n dvi-host: maybe-dvi-libdecnumber\n dvi-host: maybe-dvi-libgui\n@@ -1227,6 +1236,7 @@ dvi-target: maybe-dvi-target-libmudflap\n dvi-target: maybe-dvi-target-libssp\n dvi-target: maybe-dvi-target-newlib\n dvi-target: maybe-dvi-target-libgcc\n+dvi-target: maybe-dvi-target-libbacktrace\n dvi-target: maybe-dvi-target-libquadmath\n dvi-target: maybe-dvi-target-libgfortran\n dvi-target: maybe-dvi-target-libobjc\n@@ -1279,6 +1289,7 @@ pdf-host: maybe-pdf-intl\n pdf-host: maybe-pdf-tcl\n pdf-host: maybe-pdf-itcl\n pdf-host: maybe-pdf-ld\n+pdf-host: maybe-pdf-libbacktrace\n pdf-host: maybe-pdf-libcpp\n pdf-host: maybe-pdf-libdecnumber\n pdf-host: maybe-pdf-libgui\n@@ -1306,6 +1317,7 @@ pdf-target: maybe-pdf-target-libmudflap\n pdf-target: maybe-pdf-target-libssp\n pdf-target: maybe-pdf-target-newlib\n pdf-target: maybe-pdf-target-libgcc\n+pdf-target: maybe-pdf-target-libbacktrace\n pdf-target: maybe-pdf-target-libquadmath\n pdf-target: maybe-pdf-target-libgfortran\n pdf-target: maybe-pdf-target-libobjc\n@@ -1358,6 +1370,7 @@ html-host: maybe-html-intl\n html-host: maybe-html-tcl\n html-host: maybe-html-itcl\n html-host: maybe-html-ld\n+html-host: maybe-html-libbacktrace\n html-host: maybe-html-libcpp\n html-host: maybe-html-libdecnumber\n html-host: maybe-html-libgui\n@@ -1385,6 +1398,7 @@ html-target: maybe-html-target-libmudflap\n html-target: maybe-html-target-libssp\n html-target: maybe-html-target-newlib\n html-target: maybe-html-target-libgcc\n+html-target: maybe-html-target-libbacktrace\n html-target: maybe-html-target-libquadmath\n html-target: maybe-html-target-libgfortran\n html-target: maybe-html-target-libobjc\n@@ -1437,6 +1451,7 @@ TAGS-host: maybe-TAGS-intl\n TAGS-host: maybe-TAGS-tcl\n TAGS-host: maybe-TAGS-itcl\n TAGS-host: maybe-TAGS-ld\n+TAGS-host: maybe-TAGS-libbacktrace\n TAGS-host: maybe-TAGS-libcpp\n TAGS-host: maybe-TAGS-libdecnumber\n TAGS-host: maybe-TAGS-libgui\n@@ -1464,6 +1479,7 @@ TAGS-target: maybe-TAGS-target-libmudflap\n TAGS-target: maybe-TAGS-target-libssp\n TAGS-target: maybe-TAGS-target-newlib\n TAGS-target: maybe-TAGS-target-libgcc\n+TAGS-target: maybe-TAGS-target-libbacktrace\n TAGS-target: maybe-TAGS-target-libquadmath\n TAGS-target: maybe-TAGS-target-libgfortran\n TAGS-target: maybe-TAGS-target-libobjc\n@@ -1516,6 +1532,7 @@ install-info-host: maybe-install-info-intl\n install-info-host: maybe-install-info-tcl\n install-info-host: maybe-install-info-itcl\n install-info-host: maybe-install-info-ld\n+install-info-host: maybe-install-info-libbacktrace\n install-info-host: maybe-install-info-libcpp\n install-info-host: maybe-install-info-libdecnumber\n install-info-host: maybe-install-info-libgui\n@@ -1543,6 +1560,7 @@ install-info-target: maybe-install-info-target-libmudflap\n install-info-target: maybe-install-info-target-libssp\n install-info-target: maybe-install-info-target-newlib\n install-info-target: maybe-install-info-target-libgcc\n+install-info-target: maybe-install-info-target-libbacktrace\n install-info-target: maybe-install-info-target-libquadmath\n install-info-target: maybe-install-info-target-libgfortran\n install-info-target: maybe-install-info-target-libobjc\n@@ -1595,6 +1613,7 @@ install-pdf-host: maybe-install-pdf-intl\n install-pdf-host: maybe-install-pdf-tcl\n install-pdf-host: maybe-install-pdf-itcl\n install-pdf-host: maybe-install-pdf-ld\n+install-pdf-host: maybe-install-pdf-libbacktrace\n install-pdf-host: maybe-install-pdf-libcpp\n install-pdf-host: maybe-install-pdf-libdecnumber\n install-pdf-host: maybe-install-pdf-libgui\n@@ -1622,6 +1641,7 @@ install-pdf-target: maybe-install-pdf-target-libmudflap\n install-pdf-target: maybe-install-pdf-target-libssp\n install-pdf-target: maybe-install-pdf-target-newlib\n install-pdf-target: maybe-install-pdf-target-libgcc\n+install-pdf-target: maybe-install-pdf-target-libbacktrace\n install-pdf-target: maybe-install-pdf-target-libquadmath\n install-pdf-target: maybe-install-pdf-target-libgfortran\n install-pdf-target: maybe-install-pdf-target-libobjc\n@@ -1674,6 +1694,7 @@ install-html-host: maybe-install-html-intl\n install-html-host: maybe-install-html-tcl\n install-html-host: maybe-install-html-itcl\n install-html-host: maybe-install-html-ld\n+install-html-host: maybe-install-html-libbacktrace\n install-html-host: maybe-install-html-libcpp\n install-html-host: maybe-install-html-libdecnumber\n install-html-host: maybe-install-html-libgui\n@@ -1701,6 +1722,7 @@ install-html-target: maybe-install-html-target-libmudflap\n install-html-target: maybe-install-html-target-libssp\n install-html-target: maybe-install-html-target-newlib\n install-html-target: maybe-install-html-target-libgcc\n+install-html-target: maybe-install-html-target-libbacktrace\n install-html-target: maybe-install-html-target-libquadmath\n install-html-target: maybe-install-html-target-libgfortran\n install-html-target: maybe-install-html-target-libobjc\n@@ -1753,6 +1775,7 @@ installcheck-host: maybe-installcheck-intl\n installcheck-host: maybe-installcheck-tcl\n installcheck-host: maybe-installcheck-itcl\n installcheck-host: maybe-installcheck-ld\n+installcheck-host: maybe-installcheck-libbacktrace\n installcheck-host: maybe-installcheck-libcpp\n installcheck-host: maybe-installcheck-libdecnumber\n installcheck-host: maybe-installcheck-libgui\n@@ -1780,6 +1803,7 @@ installcheck-target: maybe-installcheck-target-libmudflap\n installcheck-target: maybe-installcheck-target-libssp\n installcheck-target: maybe-installcheck-target-newlib\n installcheck-target: maybe-installcheck-target-libgcc\n+installcheck-target: maybe-installcheck-target-libbacktrace\n installcheck-target: maybe-installcheck-target-libquadmath\n installcheck-target: maybe-installcheck-target-libgfortran\n installcheck-target: maybe-installcheck-target-libobjc\n@@ -1832,6 +1856,7 @@ mostlyclean-host: maybe-mostlyclean-intl\n mostlyclean-host: maybe-mostlyclean-tcl\n mostlyclean-host: maybe-mostlyclean-itcl\n mostlyclean-host: maybe-mostlyclean-ld\n+mostlyclean-host: maybe-mostlyclean-libbacktrace\n mostlyclean-host: maybe-mostlyclean-libcpp\n mostlyclean-host: maybe-mostlyclean-libdecnumber\n mostlyclean-host: maybe-mostlyclean-libgui\n@@ -1859,6 +1884,7 @@ mostlyclean-target: maybe-mostlyclean-target-libmudflap\n mostlyclean-target: maybe-mostlyclean-target-libssp\n mostlyclean-target: maybe-mostlyclean-target-newlib\n mostlyclean-target: maybe-mostlyclean-target-libgcc\n+mostlyclean-target: maybe-mostlyclean-target-libbacktrace\n mostlyclean-target: maybe-mostlyclean-target-libquadmath\n mostlyclean-target: maybe-mostlyclean-target-libgfortran\n mostlyclean-target: maybe-mostlyclean-target-libobjc\n@@ -1911,6 +1937,7 @@ clean-host: maybe-clean-intl\n clean-host: maybe-clean-tcl\n clean-host: maybe-clean-itcl\n clean-host: maybe-clean-ld\n+clean-host: maybe-clean-libbacktrace\n clean-host: maybe-clean-libcpp\n clean-host: maybe-clean-libdecnumber\n clean-host: maybe-clean-libgui\n@@ -1938,6 +1965,7 @@ clean-target: maybe-clean-target-libmudflap\n clean-target: maybe-clean-target-libssp\n clean-target: maybe-clean-target-newlib\n clean-target: maybe-clean-target-libgcc\n+clean-target: maybe-clean-target-libbacktrace\n clean-target: maybe-clean-target-libquadmath\n clean-target: maybe-clean-target-libgfortran\n clean-target: maybe-clean-target-libobjc\n@@ -1990,6 +2018,7 @@ distclean-host: maybe-distclean-intl\n distclean-host: maybe-distclean-tcl\n distclean-host: maybe-distclean-itcl\n distclean-host: maybe-distclean-ld\n+distclean-host: maybe-distclean-libbacktrace\n distclean-host: maybe-distclean-libcpp\n distclean-host: maybe-distclean-libdecnumber\n distclean-host: maybe-distclean-libgui\n@@ -2017,6 +2046,7 @@ distclean-target: maybe-distclean-target-libmudflap\n distclean-target: maybe-distclean-target-libssp\n distclean-target: maybe-distclean-target-newlib\n distclean-target: maybe-distclean-target-libgcc\n+distclean-target: maybe-distclean-target-libbacktrace\n distclean-target: maybe-distclean-target-libquadmath\n distclean-target: maybe-distclean-target-libgfortran\n distclean-target: maybe-distclean-target-libobjc\n@@ -2069,6 +2099,7 @@ maintainer-clean-host: maybe-maintainer-clean-intl\n maintainer-clean-host: maybe-maintainer-clean-tcl\n maintainer-clean-host: maybe-maintainer-clean-itcl\n maintainer-clean-host: maybe-maintainer-clean-ld\n+maintainer-clean-host: maybe-maintainer-clean-libbacktrace\n maintainer-clean-host: maybe-maintainer-clean-libcpp\n maintainer-clean-host: maybe-maintainer-clean-libdecnumber\n maintainer-clean-host: maybe-maintainer-clean-libgui\n@@ -2096,6 +2127,7 @@ maintainer-clean-target: maybe-maintainer-clean-target-libmudflap\n maintainer-clean-target: maybe-maintainer-clean-target-libssp\n maintainer-clean-target: maybe-maintainer-clean-target-newlib\n maintainer-clean-target: maybe-maintainer-clean-target-libgcc\n+maintainer-clean-target: maybe-maintainer-clean-target-libbacktrace\n maintainer-clean-target: maybe-maintainer-clean-target-libquadmath\n maintainer-clean-target: maybe-maintainer-clean-target-libgfortran\n maintainer-clean-target: maybe-maintainer-clean-target-libobjc\n@@ -2203,6 +2235,7 @@ check-host:  \\\n     maybe-check-tcl \\\n     maybe-check-itcl \\\n     maybe-check-ld \\\n+    maybe-check-libbacktrace \\\n     maybe-check-libcpp \\\n     maybe-check-libdecnumber \\\n     maybe-check-libgui \\\n@@ -2230,6 +2263,7 @@ check-target:  \\\n     maybe-check-target-libssp \\\n     maybe-check-target-newlib \\\n     maybe-check-target-libgcc \\\n+    maybe-check-target-libbacktrace \\\n     maybe-check-target-libquadmath \\\n     maybe-check-target-libgfortran \\\n     maybe-check-target-libobjc \\\n@@ -2308,6 +2342,7 @@ install-host-nogcc:  \\\n     maybe-install-tcl \\\n     maybe-install-itcl \\\n     maybe-install-ld \\\n+    maybe-install-libbacktrace \\\n     maybe-install-libcpp \\\n     maybe-install-libdecnumber \\\n     maybe-install-libgui \\\n@@ -2354,6 +2389,7 @@ install-host:  \\\n     maybe-install-tcl \\\n     maybe-install-itcl \\\n     maybe-install-ld \\\n+    maybe-install-libbacktrace \\\n     maybe-install-libcpp \\\n     maybe-install-libdecnumber \\\n     maybe-install-libgui \\\n@@ -2381,6 +2417,7 @@ install-target:  \\\n     maybe-install-target-libssp \\\n     maybe-install-target-newlib \\\n     maybe-install-target-libgcc \\\n+    maybe-install-target-libbacktrace \\\n     maybe-install-target-libquadmath \\\n     maybe-install-target-libgfortran \\\n     maybe-install-target-libobjc \\\n@@ -2453,6 +2490,7 @@ install-strip-host:  \\\n     maybe-install-strip-tcl \\\n     maybe-install-strip-itcl \\\n     maybe-install-strip-ld \\\n+    maybe-install-strip-libbacktrace \\\n     maybe-install-strip-libcpp \\\n     maybe-install-strip-libdecnumber \\\n     maybe-install-strip-libgui \\\n@@ -2480,6 +2518,7 @@ install-strip-target:  \\\n     maybe-install-strip-target-libssp \\\n     maybe-install-strip-target-newlib \\\n     maybe-install-strip-target-libgcc \\\n+    maybe-install-strip-target-libbacktrace \\\n     maybe-install-strip-target-libquadmath \\\n     maybe-install-strip-target-libgfortran \\\n     maybe-install-strip-target-libobjc \\\n@@ -19558,6 +19597,887 @@ maintainer-clean-ld:\n \n \n \n+.PHONY: configure-libbacktrace maybe-configure-libbacktrace\n+maybe-configure-libbacktrace:\n+@if gcc-bootstrap\n+configure-libbacktrace: stage_current\n+@endif gcc-bootstrap\n+@if libbacktrace\n+maybe-configure-libbacktrace: configure-libbacktrace\n+configure-libbacktrace: \n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\ttest ! -f $(HOST_SUBDIR)/libbacktrace/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace ; \\\n+\t$(HOST_EXPORTS)  \\\n+\techo Configuring in $(HOST_SUBDIR)/libbacktrace; \\\n+\tcd \"$(HOST_SUBDIR)/libbacktrace\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/libbacktrace/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libbacktrace\"; \\\n+\tlibsrcdir=\"$$s/libbacktrace\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption}  \\\n+\t  || exit 1\n+@endif libbacktrace\n+\n+\n+\n+.PHONY: configure-stage1-libbacktrace maybe-configure-stage1-libbacktrace\n+maybe-configure-stage1-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-configure-stage1-libbacktrace: configure-stage1-libbacktrace\n+configure-stage1-libbacktrace:\n+\t@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE1_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/libbacktrace/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGE1_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGE1_CXXFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 1 in $(HOST_SUBDIR)/libbacktrace ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace ; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/libbacktrace/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libbacktrace\"; \\\n+\tlibsrcdir=\"$$s/libbacktrace\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  $(STAGE1_CONFIGURE_FLAGS)\n+@endif libbacktrace-bootstrap\n+\n+.PHONY: configure-stage2-libbacktrace maybe-configure-stage2-libbacktrace\n+maybe-configure-stage2-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-configure-stage2-libbacktrace: configure-stage2-libbacktrace\n+configure-stage2-libbacktrace:\n+\t@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE2_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/libbacktrace/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGE2_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGE2_CXXFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(STAGE2_CFLAGS)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 2 in $(HOST_SUBDIR)/libbacktrace ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace ; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/libbacktrace/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libbacktrace\"; \\\n+\tlibsrcdir=\"$$s/libbacktrace\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE2_CONFIGURE_FLAGS)\n+@endif libbacktrace-bootstrap\n+\n+.PHONY: configure-stage3-libbacktrace maybe-configure-stage3-libbacktrace\n+maybe-configure-stage3-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-configure-stage3-libbacktrace: configure-stage3-libbacktrace\n+configure-stage3-libbacktrace:\n+\t@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE3_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/libbacktrace/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGE3_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGE3_CXXFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(STAGE3_CFLAGS)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 3 in $(HOST_SUBDIR)/libbacktrace ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace ; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/libbacktrace/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libbacktrace\"; \\\n+\tlibsrcdir=\"$$s/libbacktrace\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE3_CONFIGURE_FLAGS)\n+@endif libbacktrace-bootstrap\n+\n+.PHONY: configure-stage4-libbacktrace maybe-configure-stage4-libbacktrace\n+maybe-configure-stage4-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-configure-stage4-libbacktrace: configure-stage4-libbacktrace\n+configure-stage4-libbacktrace:\n+\t@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE4_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/libbacktrace/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGE4_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGE4_CXXFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(STAGE4_CFLAGS)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 4 in $(HOST_SUBDIR)/libbacktrace ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace ; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/libbacktrace/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libbacktrace\"; \\\n+\tlibsrcdir=\"$$s/libbacktrace\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE4_CONFIGURE_FLAGS)\n+@endif libbacktrace-bootstrap\n+\n+.PHONY: configure-stageprofile-libbacktrace maybe-configure-stageprofile-libbacktrace\n+maybe-configure-stageprofile-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-configure-stageprofile-libbacktrace: configure-stageprofile-libbacktrace\n+configure-stageprofile-libbacktrace:\n+\t@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEprofile_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/libbacktrace/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGEprofile_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGEprofile_CXXFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(STAGEprofile_CFLAGS)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage profile in $(HOST_SUBDIR)/libbacktrace ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace ; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/libbacktrace/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libbacktrace\"; \\\n+\tlibsrcdir=\"$$s/libbacktrace\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGEprofile_CONFIGURE_FLAGS)\n+@endif libbacktrace-bootstrap\n+\n+.PHONY: configure-stagefeedback-libbacktrace maybe-configure-stagefeedback-libbacktrace\n+maybe-configure-stagefeedback-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-configure-stagefeedback-libbacktrace: configure-stagefeedback-libbacktrace\n+configure-stagefeedback-libbacktrace:\n+\t@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\"; \\\n+\ttest ! -f $(HOST_SUBDIR)/libbacktrace/Makefile || exit 0; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) \\\n+\tCFLAGS=\"$(STAGEfeedback_CFLAGS)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(STAGEfeedback_CXXFLAGS)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(STAGEfeedback_CFLAGS)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage feedback in $(HOST_SUBDIR)/libbacktrace ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/libbacktrace ; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/libbacktrace/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libbacktrace\"; \\\n+\tlibsrcdir=\"$$s/libbacktrace\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGEfeedback_CONFIGURE_FLAGS)\n+@endif libbacktrace-bootstrap\n+\n+\n+\n+\n+\n+.PHONY: all-libbacktrace maybe-all-libbacktrace\n+maybe-all-libbacktrace:\n+@if gcc-bootstrap\n+all-libbacktrace: stage_current\n+@endif gcc-bootstrap\n+@if libbacktrace\n+TARGET-libbacktrace=all\n+maybe-all-libbacktrace: all-libbacktrace\n+all-libbacktrace: configure-libbacktrace\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS)  \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(TARGET-libbacktrace))\n+@endif libbacktrace\n+\n+\n+\n+.PHONY: all-stage1-libbacktrace maybe-all-stage1-libbacktrace\n+.PHONY: clean-stage1-libbacktrace maybe-clean-stage1-libbacktrace\n+maybe-all-stage1-libbacktrace:\n+maybe-clean-stage1-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-all-stage1-libbacktrace: all-stage1-libbacktrace\n+all-stage1: all-stage1-libbacktrace\n+TARGET-stage1-libbacktrace = $(TARGET-libbacktrace)\n+all-stage1-libbacktrace: configure-stage1-libbacktrace\n+\t@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE1_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS)  \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGE1_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGE1_CXXFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS)   \\\n+\t\tTFLAGS=\"$(STAGE1_TFLAGS)\" \\\n+\t\t$(TARGET-stage1-libbacktrace)\n+\n+maybe-clean-stage1-libbacktrace: clean-stage1-libbacktrace\n+clean-stage1: clean-stage1-libbacktrace\n+clean-stage1-libbacktrace:\n+\t@if [ $(current_stage) = stage1 ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/libbacktrace/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stage1-libbacktrace/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage1-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t clean\n+@endif libbacktrace-bootstrap\n+\n+\n+.PHONY: all-stage2-libbacktrace maybe-all-stage2-libbacktrace\n+.PHONY: clean-stage2-libbacktrace maybe-clean-stage2-libbacktrace\n+maybe-all-stage2-libbacktrace:\n+maybe-clean-stage2-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-all-stage2-libbacktrace: all-stage2-libbacktrace\n+all-stage2: all-stage2-libbacktrace\n+TARGET-stage2-libbacktrace = $(TARGET-libbacktrace)\n+all-stage2-libbacktrace: configure-stage2-libbacktrace\n+\t@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE2_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS)  \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGE2_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGE2_CXXFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(STAGE2_CFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\tTFLAGS=\"$(STAGE2_TFLAGS)\" \\\n+\t\t$(TARGET-stage2-libbacktrace)\n+\n+maybe-clean-stage2-libbacktrace: clean-stage2-libbacktrace\n+clean-stage2: clean-stage2-libbacktrace\n+clean-stage2-libbacktrace:\n+\t@if [ $(current_stage) = stage2 ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/libbacktrace/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stage2-libbacktrace/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage2-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t clean\n+@endif libbacktrace-bootstrap\n+\n+\n+.PHONY: all-stage3-libbacktrace maybe-all-stage3-libbacktrace\n+.PHONY: clean-stage3-libbacktrace maybe-clean-stage3-libbacktrace\n+maybe-all-stage3-libbacktrace:\n+maybe-clean-stage3-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-all-stage3-libbacktrace: all-stage3-libbacktrace\n+all-stage3: all-stage3-libbacktrace\n+TARGET-stage3-libbacktrace = $(TARGET-libbacktrace)\n+all-stage3-libbacktrace: configure-stage3-libbacktrace\n+\t@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE3_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS)  \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGE3_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGE3_CXXFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(STAGE3_CFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\tTFLAGS=\"$(STAGE3_TFLAGS)\" \\\n+\t\t$(TARGET-stage3-libbacktrace)\n+\n+maybe-clean-stage3-libbacktrace: clean-stage3-libbacktrace\n+clean-stage3: clean-stage3-libbacktrace\n+clean-stage3-libbacktrace:\n+\t@if [ $(current_stage) = stage3 ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/libbacktrace/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stage3-libbacktrace/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage3-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t clean\n+@endif libbacktrace-bootstrap\n+\n+\n+.PHONY: all-stage4-libbacktrace maybe-all-stage4-libbacktrace\n+.PHONY: clean-stage4-libbacktrace maybe-clean-stage4-libbacktrace\n+maybe-all-stage4-libbacktrace:\n+maybe-clean-stage4-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-all-stage4-libbacktrace: all-stage4-libbacktrace\n+all-stage4: all-stage4-libbacktrace\n+TARGET-stage4-libbacktrace = $(TARGET-libbacktrace)\n+all-stage4-libbacktrace: configure-stage4-libbacktrace\n+\t@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE4_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS)  \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGE4_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGE4_CXXFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(STAGE4_CFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\tTFLAGS=\"$(STAGE4_TFLAGS)\" \\\n+\t\t$(TARGET-stage4-libbacktrace)\n+\n+maybe-clean-stage4-libbacktrace: clean-stage4-libbacktrace\n+clean-stage4: clean-stage4-libbacktrace\n+clean-stage4-libbacktrace:\n+\t@if [ $(current_stage) = stage4 ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/libbacktrace/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stage4-libbacktrace/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage4-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t clean\n+@endif libbacktrace-bootstrap\n+\n+\n+.PHONY: all-stageprofile-libbacktrace maybe-all-stageprofile-libbacktrace\n+.PHONY: clean-stageprofile-libbacktrace maybe-clean-stageprofile-libbacktrace\n+maybe-all-stageprofile-libbacktrace:\n+maybe-clean-stageprofile-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-all-stageprofile-libbacktrace: all-stageprofile-libbacktrace\n+all-stageprofile: all-stageprofile-libbacktrace\n+TARGET-stageprofile-libbacktrace = $(TARGET-libbacktrace)\n+all-stageprofile-libbacktrace: configure-stageprofile-libbacktrace\n+\t@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEprofile_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS)  \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGEprofile_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGEprofile_CXXFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(STAGEprofile_CFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\tTFLAGS=\"$(STAGEprofile_TFLAGS)\" \\\n+\t\t$(TARGET-stageprofile-libbacktrace)\n+\n+maybe-clean-stageprofile-libbacktrace: clean-stageprofile-libbacktrace\n+clean-stageprofile: clean-stageprofile-libbacktrace\n+clean-stageprofile-libbacktrace:\n+\t@if [ $(current_stage) = stageprofile ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/libbacktrace/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stageprofile-libbacktrace/Makefile ] || exit 0; \\\n+\t  $(MAKE) stageprofile-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t clean\n+@endif libbacktrace-bootstrap\n+\n+\n+.PHONY: all-stagefeedback-libbacktrace maybe-all-stagefeedback-libbacktrace\n+.PHONY: clean-stagefeedback-libbacktrace maybe-clean-stagefeedback-libbacktrace\n+maybe-all-stagefeedback-libbacktrace:\n+maybe-clean-stagefeedback-libbacktrace:\n+@if libbacktrace-bootstrap\n+maybe-all-stagefeedback-libbacktrace: all-stagefeedback-libbacktrace\n+all-stagefeedback: all-stagefeedback-libbacktrace\n+TARGET-stagefeedback-libbacktrace = $(TARGET-libbacktrace)\n+all-stagefeedback-libbacktrace: configure-stagefeedback-libbacktrace\n+\t@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\"; \\\n+\t$(HOST_EXPORTS) \\\n+\t$(POSTSTAGE1_HOST_EXPORTS)  \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(STAGEfeedback_CFLAGS)\" \\\n+\t\tCXXFLAGS=\"$(STAGEfeedback_CXXFLAGS)\" \\\n+\t\tLIBCFLAGS=\"$(STAGEfeedback_CFLAGS)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\" \\\n+\t\t$(TARGET-stagefeedback-libbacktrace)\n+\n+maybe-clean-stagefeedback-libbacktrace: clean-stagefeedback-libbacktrace\n+clean-stagefeedback: clean-stagefeedback-libbacktrace\n+clean-stagefeedback-libbacktrace:\n+\t@if [ $(current_stage) = stagefeedback ]; then \\\n+\t  [ -f $(HOST_SUBDIR)/libbacktrace/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(HOST_SUBDIR)/stagefeedback-libbacktrace/Makefile ] || exit 0; \\\n+\t  $(MAKE) stagefeedback-start; \\\n+\tfi; \\\n+\tcd $(HOST_SUBDIR)/libbacktrace && \\\n+\t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n+\t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t clean\n+@endif libbacktrace-bootstrap\n+\n+\n+\n+\n+\n+.PHONY: check-libbacktrace maybe-check-libbacktrace\n+maybe-check-libbacktrace:\n+@if libbacktrace\n+maybe-check-libbacktrace: check-libbacktrace\n+\n+check-libbacktrace:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(FLAGS_TO_PASS)  check)\n+\n+@endif libbacktrace\n+\n+.PHONY: install-libbacktrace maybe-install-libbacktrace\n+maybe-install-libbacktrace:\n+@if libbacktrace\n+maybe-install-libbacktrace: install-libbacktrace\n+\n+install-libbacktrace: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(FLAGS_TO_PASS)  install)\n+\n+@endif libbacktrace\n+\n+.PHONY: install-strip-libbacktrace maybe-install-strip-libbacktrace\n+maybe-install-strip-libbacktrace:\n+@if libbacktrace\n+maybe-install-strip-libbacktrace: install-strip-libbacktrace\n+\n+install-strip-libbacktrace: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(FLAGS_TO_PASS)  install-strip)\n+\n+@endif libbacktrace\n+\n+# Other targets (info, dvi, pdf, etc.)\n+\n+.PHONY: maybe-info-libbacktrace info-libbacktrace\n+maybe-info-libbacktrace:\n+@if libbacktrace\n+maybe-info-libbacktrace: info-libbacktrace\n+\n+info-libbacktrace: \\\n+    configure-libbacktrace \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing info in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          info) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-dvi-libbacktrace dvi-libbacktrace\n+maybe-dvi-libbacktrace:\n+@if libbacktrace\n+maybe-dvi-libbacktrace: dvi-libbacktrace\n+\n+dvi-libbacktrace: \\\n+    configure-libbacktrace \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing dvi in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          dvi) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-pdf-libbacktrace pdf-libbacktrace\n+maybe-pdf-libbacktrace:\n+@if libbacktrace\n+maybe-pdf-libbacktrace: pdf-libbacktrace\n+\n+pdf-libbacktrace: \\\n+    configure-libbacktrace \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing pdf in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          pdf) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-html-libbacktrace html-libbacktrace\n+maybe-html-libbacktrace:\n+@if libbacktrace\n+maybe-html-libbacktrace: html-libbacktrace\n+\n+html-libbacktrace: \\\n+    configure-libbacktrace \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing html in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          html) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-TAGS-libbacktrace TAGS-libbacktrace\n+maybe-TAGS-libbacktrace:\n+@if libbacktrace\n+maybe-TAGS-libbacktrace: TAGS-libbacktrace\n+\n+TAGS-libbacktrace: \\\n+    configure-libbacktrace \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing TAGS in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          TAGS) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-install-info-libbacktrace install-info-libbacktrace\n+maybe-install-info-libbacktrace:\n+@if libbacktrace\n+maybe-install-info-libbacktrace: install-info-libbacktrace\n+\n+install-info-libbacktrace: \\\n+    configure-libbacktrace \\\n+    info-libbacktrace \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing install-info in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          install-info) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-install-pdf-libbacktrace install-pdf-libbacktrace\n+maybe-install-pdf-libbacktrace:\n+@if libbacktrace\n+maybe-install-pdf-libbacktrace: install-pdf-libbacktrace\n+\n+install-pdf-libbacktrace: \\\n+    configure-libbacktrace \\\n+    pdf-libbacktrace \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing install-pdf in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          install-pdf) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-install-html-libbacktrace install-html-libbacktrace\n+maybe-install-html-libbacktrace:\n+@if libbacktrace\n+maybe-install-html-libbacktrace: install-html-libbacktrace\n+\n+install-html-libbacktrace: \\\n+    configure-libbacktrace \\\n+    html-libbacktrace \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing install-html in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          install-html) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-installcheck-libbacktrace installcheck-libbacktrace\n+maybe-installcheck-libbacktrace:\n+@if libbacktrace\n+maybe-installcheck-libbacktrace: installcheck-libbacktrace\n+\n+installcheck-libbacktrace: \\\n+    configure-libbacktrace \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing installcheck in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          installcheck) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-mostlyclean-libbacktrace mostlyclean-libbacktrace\n+maybe-mostlyclean-libbacktrace:\n+@if libbacktrace\n+maybe-mostlyclean-libbacktrace: mostlyclean-libbacktrace\n+\n+mostlyclean-libbacktrace: \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing mostlyclean in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          mostlyclean) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-clean-libbacktrace clean-libbacktrace\n+maybe-clean-libbacktrace:\n+@if libbacktrace\n+maybe-clean-libbacktrace: clean-libbacktrace\n+\n+clean-libbacktrace: \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing clean in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          clean) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-distclean-libbacktrace distclean-libbacktrace\n+maybe-distclean-libbacktrace:\n+@if libbacktrace\n+maybe-distclean-libbacktrace: distclean-libbacktrace\n+\n+distclean-libbacktrace: \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing distclean in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          distclean) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+.PHONY: maybe-maintainer-clean-libbacktrace maintainer-clean-libbacktrace\n+maybe-maintainer-clean-libbacktrace:\n+@if libbacktrace\n+maybe-maintainer-clean-libbacktrace: maintainer-clean-libbacktrace\n+\n+maintainer-clean-libbacktrace: \n+\t@[ -f ./libbacktrace/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(HOST_EXPORTS) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing maintainer-clean in libbacktrace\" ; \\\n+\t(cd $(HOST_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t          maintainer-clean) \\\n+\t  || exit 1\n+\n+@endif libbacktrace\n+\n+\n+\n .PHONY: configure-libcpp maybe-configure-libcpp\n maybe-configure-libcpp:\n @if gcc-bootstrap\n@@ -33309,6 +34229,463 @@ maintainer-clean-target-libgcc:\n \n \n \n+.PHONY: configure-target-libbacktrace maybe-configure-target-libbacktrace\n+maybe-configure-target-libbacktrace:\n+@if gcc-bootstrap\n+configure-target-libbacktrace: stage_current\n+@endif gcc-bootstrap\n+@if target-libbacktrace\n+maybe-configure-target-libbacktrace: configure-target-libbacktrace\n+configure-target-libbacktrace: \n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\techo \"Checking multilib configuration for libbacktrace...\"; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libbacktrace ; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libbacktrace/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libbacktrace/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libbacktrace/multilib.tmp $(TARGET_SUBDIR)/libbacktrace/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libbacktrace/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libbacktrace/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libbacktrace/multilib.tmp $(TARGET_SUBDIR)/libbacktrace/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libbacktrace/multilib.tmp $(TARGET_SUBDIR)/libbacktrace/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libbacktrace/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libbacktrace ; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\techo Configuring in $(TARGET_SUBDIR)/libbacktrace; \\\n+\tcd \"$(TARGET_SUBDIR)/libbacktrace\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libbacktrace/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libbacktrace\"; \\\n+\tlibsrcdir=\"$$s/libbacktrace\"; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption}  \\\n+\t  || exit 1\n+@endif target-libbacktrace\n+\n+\n+\n+\n+\n+.PHONY: all-target-libbacktrace maybe-all-target-libbacktrace\n+maybe-all-target-libbacktrace:\n+@if gcc-bootstrap\n+all-target-libbacktrace: stage_current\n+@endif gcc-bootstrap\n+@if target-libbacktrace\n+TARGET-target-libbacktrace=all\n+maybe-all-target-libbacktrace: all-target-libbacktrace\n+all-target-libbacktrace: configure-target-libbacktrace\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)  \\\n+\t\t$(TARGET-target-libbacktrace))\n+@endif target-libbacktrace\n+\n+\n+\n+\n+\n+.PHONY: check-target-libbacktrace maybe-check-target-libbacktrace\n+maybe-check-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-check-target-libbacktrace: check-target-libbacktrace\n+\n+check-target-libbacktrace:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n+\n+@endif target-libbacktrace\n+\n+.PHONY: install-target-libbacktrace maybe-install-target-libbacktrace\n+maybe-install-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-install-target-libbacktrace: install-target-libbacktrace\n+\n+install-target-libbacktrace: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n+\n+@endif target-libbacktrace\n+\n+.PHONY: install-strip-target-libbacktrace maybe-install-strip-target-libbacktrace\n+maybe-install-strip-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-install-strip-target-libbacktrace: install-strip-target-libbacktrace\n+\n+install-strip-target-libbacktrace: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n+\n+@endif target-libbacktrace\n+\n+# Other targets (info, dvi, pdf, etc.)\n+\n+.PHONY: maybe-info-target-libbacktrace info-target-libbacktrace\n+maybe-info-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-info-target-libbacktrace: info-target-libbacktrace\n+\n+info-target-libbacktrace: \\\n+    configure-target-libbacktrace \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing info in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           info) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-dvi-target-libbacktrace dvi-target-libbacktrace\n+maybe-dvi-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-dvi-target-libbacktrace: dvi-target-libbacktrace\n+\n+dvi-target-libbacktrace: \\\n+    configure-target-libbacktrace \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing dvi in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           dvi) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-pdf-target-libbacktrace pdf-target-libbacktrace\n+maybe-pdf-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-pdf-target-libbacktrace: pdf-target-libbacktrace\n+\n+pdf-target-libbacktrace: \\\n+    configure-target-libbacktrace \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing pdf in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           pdf) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-html-target-libbacktrace html-target-libbacktrace\n+maybe-html-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-html-target-libbacktrace: html-target-libbacktrace\n+\n+html-target-libbacktrace: \\\n+    configure-target-libbacktrace \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing html in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           html) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-TAGS-target-libbacktrace TAGS-target-libbacktrace\n+maybe-TAGS-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-TAGS-target-libbacktrace: TAGS-target-libbacktrace\n+\n+TAGS-target-libbacktrace: \\\n+    configure-target-libbacktrace \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing TAGS in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           TAGS) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-install-info-target-libbacktrace install-info-target-libbacktrace\n+maybe-install-info-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-install-info-target-libbacktrace: install-info-target-libbacktrace\n+\n+install-info-target-libbacktrace: \\\n+    configure-target-libbacktrace \\\n+    info-target-libbacktrace \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-info in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-info) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-install-pdf-target-libbacktrace install-pdf-target-libbacktrace\n+maybe-install-pdf-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-install-pdf-target-libbacktrace: install-pdf-target-libbacktrace\n+\n+install-pdf-target-libbacktrace: \\\n+    configure-target-libbacktrace \\\n+    pdf-target-libbacktrace \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-pdf in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-pdf) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-install-html-target-libbacktrace install-html-target-libbacktrace\n+maybe-install-html-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-install-html-target-libbacktrace: install-html-target-libbacktrace\n+\n+install-html-target-libbacktrace: \\\n+    configure-target-libbacktrace \\\n+    html-target-libbacktrace \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-html in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-html) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-installcheck-target-libbacktrace installcheck-target-libbacktrace\n+maybe-installcheck-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-installcheck-target-libbacktrace: installcheck-target-libbacktrace\n+\n+installcheck-target-libbacktrace: \\\n+    configure-target-libbacktrace \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing installcheck in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           installcheck) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-mostlyclean-target-libbacktrace mostlyclean-target-libbacktrace\n+maybe-mostlyclean-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-mostlyclean-target-libbacktrace: mostlyclean-target-libbacktrace\n+\n+mostlyclean-target-libbacktrace: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           mostlyclean) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-clean-target-libbacktrace clean-target-libbacktrace\n+maybe-clean-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-clean-target-libbacktrace: clean-target-libbacktrace\n+\n+clean-target-libbacktrace: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing clean in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           clean) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-distclean-target-libbacktrace distclean-target-libbacktrace\n+maybe-distclean-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-distclean-target-libbacktrace: distclean-target-libbacktrace\n+\n+distclean-target-libbacktrace: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing distclean in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           distclean) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+.PHONY: maybe-maintainer-clean-target-libbacktrace maintainer-clean-target-libbacktrace\n+maybe-maintainer-clean-target-libbacktrace:\n+@if target-libbacktrace\n+maybe-maintainer-clean-target-libbacktrace: maintainer-clean-target-libbacktrace\n+\n+maintainer-clean-target-libbacktrace: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libbacktrace/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libbacktrace\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libbacktrace && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           maintainer-clean) \\\n+\t  || exit 1\n+\n+@endif target-libbacktrace\n+\n+\n+\n+\n+\n .PHONY: configure-target-libquadmath maybe-configure-target-libquadmath\n maybe-configure-target-libquadmath:\n @if gcc-bootstrap\n@@ -41322,6 +42699,11 @@ stage1-start::\n \t  mkdir stage1-ld; \\\n \tmv stage1-ld ld \n @endif ld\n+@if libbacktrace\n+\t@cd $(HOST_SUBDIR); [ -d stage1-libbacktrace ] || \\\n+\t  mkdir stage1-libbacktrace; \\\n+\tmv stage1-libbacktrace libbacktrace \n+@endif libbacktrace\n @if libcpp\n \t@cd $(HOST_SUBDIR); [ -d stage1-libcpp ] || \\\n \t  mkdir stage1-libcpp; \\\n@@ -41422,6 +42804,11 @@ stage1-end::\n \t  cd $(HOST_SUBDIR); mv ld stage1-ld  ; \\\n \tfi\n @endif ld\n+@if libbacktrace\n+\t@if test -d $(HOST_SUBDIR)/libbacktrace ; then \\\n+\t  cd $(HOST_SUBDIR); mv libbacktrace stage1-libbacktrace  ; \\\n+\tfi\n+@endif libbacktrace\n @if libcpp\n \t@if test -d $(HOST_SUBDIR)/libcpp ; then \\\n \t  cd $(HOST_SUBDIR); mv libcpp stage1-libcpp  ; \\\n@@ -41579,6 +42966,12 @@ stage2-start::\n \tmv stage2-ld ld  ; \\\n \tmv stage1-ld prev-ld || test -f stage1-lean \n @endif ld\n+@if libbacktrace\n+\t@cd $(HOST_SUBDIR); [ -d stage2-libbacktrace ] || \\\n+\t  mkdir stage2-libbacktrace; \\\n+\tmv stage2-libbacktrace libbacktrace  ; \\\n+\tmv stage1-libbacktrace prev-libbacktrace || test -f stage1-lean \n+@endif libbacktrace\n @if libcpp\n \t@cd $(HOST_SUBDIR); [ -d stage2-libcpp ] || \\\n \t  mkdir stage2-libcpp; \\\n@@ -41699,6 +43092,12 @@ stage2-end::\n \t  mv prev-ld stage1-ld ; :  ; \\\n \tfi\n @endif ld\n+@if libbacktrace\n+\t@if test -d $(HOST_SUBDIR)/libbacktrace ; then \\\n+\t  cd $(HOST_SUBDIR); mv libbacktrace stage2-libbacktrace ; \\\n+\t  mv prev-libbacktrace stage1-libbacktrace ; :  ; \\\n+\tfi\n+@endif libbacktrace\n @if libcpp\n \t@if test -d $(HOST_SUBDIR)/libcpp ; then \\\n \t  cd $(HOST_SUBDIR); mv libcpp stage2-libcpp ; \\\n@@ -41885,6 +43284,12 @@ stage3-start::\n \tmv stage3-ld ld  ; \\\n \tmv stage2-ld prev-ld || test -f stage2-lean \n @endif ld\n+@if libbacktrace\n+\t@cd $(HOST_SUBDIR); [ -d stage3-libbacktrace ] || \\\n+\t  mkdir stage3-libbacktrace; \\\n+\tmv stage3-libbacktrace libbacktrace  ; \\\n+\tmv stage2-libbacktrace prev-libbacktrace || test -f stage2-lean \n+@endif libbacktrace\n @if libcpp\n \t@cd $(HOST_SUBDIR); [ -d stage3-libcpp ] || \\\n \t  mkdir stage3-libcpp; \\\n@@ -42005,6 +43410,12 @@ stage3-end::\n \t  mv prev-ld stage2-ld ; :  ; \\\n \tfi\n @endif ld\n+@if libbacktrace\n+\t@if test -d $(HOST_SUBDIR)/libbacktrace ; then \\\n+\t  cd $(HOST_SUBDIR); mv libbacktrace stage3-libbacktrace ; \\\n+\t  mv prev-libbacktrace stage2-libbacktrace ; :  ; \\\n+\tfi\n+@endif libbacktrace\n @if libcpp\n \t@if test -d $(HOST_SUBDIR)/libcpp ; then \\\n \t  cd $(HOST_SUBDIR); mv libcpp stage3-libcpp ; \\\n@@ -42247,6 +43658,12 @@ stage4-start::\n \tmv stage4-ld ld  ; \\\n \tmv stage3-ld prev-ld || test -f stage3-lean \n @endif ld\n+@if libbacktrace\n+\t@cd $(HOST_SUBDIR); [ -d stage4-libbacktrace ] || \\\n+\t  mkdir stage4-libbacktrace; \\\n+\tmv stage4-libbacktrace libbacktrace  ; \\\n+\tmv stage3-libbacktrace prev-libbacktrace || test -f stage3-lean \n+@endif libbacktrace\n @if libcpp\n \t@cd $(HOST_SUBDIR); [ -d stage4-libcpp ] || \\\n \t  mkdir stage4-libcpp; \\\n@@ -42367,6 +43784,12 @@ stage4-end::\n \t  mv prev-ld stage3-ld ; :  ; \\\n \tfi\n @endif ld\n+@if libbacktrace\n+\t@if test -d $(HOST_SUBDIR)/libbacktrace ; then \\\n+\t  cd $(HOST_SUBDIR); mv libbacktrace stage4-libbacktrace ; \\\n+\t  mv prev-libbacktrace stage3-libbacktrace ; :  ; \\\n+\tfi\n+@endif libbacktrace\n @if libcpp\n \t@if test -d $(HOST_SUBDIR)/libcpp ; then \\\n \t  cd $(HOST_SUBDIR); mv libcpp stage4-libcpp ; \\\n@@ -42597,6 +44020,12 @@ stageprofile-start::\n \tmv stageprofile-ld ld  ; \\\n \tmv stage1-ld prev-ld || test -f stage1-lean \n @endif ld\n+@if libbacktrace\n+\t@cd $(HOST_SUBDIR); [ -d stageprofile-libbacktrace ] || \\\n+\t  mkdir stageprofile-libbacktrace; \\\n+\tmv stageprofile-libbacktrace libbacktrace  ; \\\n+\tmv stage1-libbacktrace prev-libbacktrace || test -f stage1-lean \n+@endif libbacktrace\n @if libcpp\n \t@cd $(HOST_SUBDIR); [ -d stageprofile-libcpp ] || \\\n \t  mkdir stageprofile-libcpp; \\\n@@ -42717,6 +44146,12 @@ stageprofile-end::\n \t  mv prev-ld stage1-ld ; :  ; \\\n \tfi\n @endif ld\n+@if libbacktrace\n+\t@if test -d $(HOST_SUBDIR)/libbacktrace ; then \\\n+\t  cd $(HOST_SUBDIR); mv libbacktrace stageprofile-libbacktrace ; \\\n+\t  mv prev-libbacktrace stage1-libbacktrace ; :  ; \\\n+\tfi\n+@endif libbacktrace\n @if libcpp\n \t@if test -d $(HOST_SUBDIR)/libcpp ; then \\\n \t  cd $(HOST_SUBDIR); mv libcpp stageprofile-libcpp ; \\\n@@ -42880,6 +44315,12 @@ stagefeedback-start::\n \tmv stagefeedback-ld ld  ; \\\n \tmv stageprofile-ld prev-ld || test -f stageprofile-lean \n @endif ld\n+@if libbacktrace\n+\t@cd $(HOST_SUBDIR); [ -d stagefeedback-libbacktrace ] || \\\n+\t  mkdir stagefeedback-libbacktrace; \\\n+\tmv stagefeedback-libbacktrace libbacktrace  ; \\\n+\tmv stageprofile-libbacktrace prev-libbacktrace || test -f stageprofile-lean \n+@endif libbacktrace\n @if libcpp\n \t@cd $(HOST_SUBDIR); [ -d stagefeedback-libcpp ] || \\\n \t  mkdir stagefeedback-libcpp; \\\n@@ -43000,6 +44441,12 @@ stagefeedback-end::\n \t  mv prev-ld stageprofile-ld ; :  ; \\\n \tfi\n @endif ld\n+@if libbacktrace\n+\t@if test -d $(HOST_SUBDIR)/libbacktrace ; then \\\n+\t  cd $(HOST_SUBDIR); mv libbacktrace stagefeedback-libbacktrace ; \\\n+\t  mv prev-libbacktrace stageprofile-libbacktrace ; :  ; \\\n+\tfi\n+@endif libbacktrace\n @if libcpp\n \t@if test -d $(HOST_SUBDIR)/libcpp ; then \\\n \t  cd $(HOST_SUBDIR); mv libcpp stagefeedback-libcpp ; \\\n@@ -43152,6 +44599,7 @@ configure-stage3-target-libgcc: maybe-all-stage3-gcc\n configure-stage4-target-libgcc: maybe-all-stage4-gcc\n configure-stageprofile-target-libgcc: maybe-all-stageprofile-gcc\n configure-stagefeedback-target-libgcc: maybe-all-stagefeedback-gcc\n+configure-target-libbacktrace: stage_last\n configure-target-libquadmath: stage_last\n configure-target-libgfortran: stage_last\n configure-target-libobjc: stage_last\n@@ -43181,6 +44629,7 @@ configure-target-libmudflap: maybe-all-gcc\n configure-target-libssp: maybe-all-gcc\n configure-target-newlib: maybe-all-gcc\n configure-target-libgcc: maybe-all-gcc\n+configure-target-libbacktrace: maybe-all-gcc\n configure-target-libquadmath: maybe-all-gcc\n configure-target-libgfortran: maybe-all-gcc\n configure-target-libobjc: maybe-all-gcc\n@@ -43949,6 +45398,7 @@ configure-target-libstdc++-v3: maybe-all-target-libgcc\n configure-target-libmudflap: maybe-all-target-libgcc\n configure-target-libssp: maybe-all-target-libgcc\n configure-target-newlib: maybe-all-target-libgcc\n+configure-target-libbacktrace: maybe-all-target-libgcc\n configure-target-libquadmath: maybe-all-target-libgcc\n configure-target-libgfortran: maybe-all-target-libgcc\n configure-target-libobjc: maybe-all-target-libgcc\n@@ -43976,6 +45426,8 @@ configure-target-libssp: maybe-all-target-newlib maybe-all-target-libgloss\n \n \n \n+configure-target-libbacktrace: maybe-all-target-newlib maybe-all-target-libgloss\n+\n configure-target-libquadmath: maybe-all-target-newlib maybe-all-target-libgloss\n \n configure-target-libgfortran: maybe-all-target-newlib maybe-all-target-libgloss"}, {"sha": "9ace64e6b7a934f5c0ff02fb471dafc0e993d6d6", "filename": "configure", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -2698,7 +2698,7 @@ build_tools=\"build-texinfo build-flex build-bison build-m4 build-fixincludes\"\n \n # these libraries are used by various programs built for the host environment\n #\n-host_libs=\"intl libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp libdecnumber gmp mpfr mpc isl cloog libelf libiconv\"\n+host_libs=\"intl libiberty opcodes bfd readline tcl tk itcl libgui zlib libbacktrace libcpp libdecnumber gmp mpfr mpc isl cloog libelf libiconv\"\n \n # these tools are built for the host environment\n # Note, the powerpc-eabi build depends on sim occurring before gdb in order to\n@@ -2717,6 +2717,7 @@ libgcj=\"target-libffi \\\n # the host libraries and the host tools (which may be a cross compiler)\n # Note that libiberty is not a target library.\n target_libraries=\"target-libgcc \\\n+\t\ttarget-libbacktrace \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\"}, {"sha": "a5a443ded5887ab3528eaa708a35b605966ef0b7", "filename": "configure.ac", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -133,7 +133,7 @@ build_tools=\"build-texinfo build-flex build-bison build-m4 build-fixincludes\"\n \n # these libraries are used by various programs built for the host environment\n #\n-host_libs=\"intl libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp libdecnumber gmp mpfr mpc isl cloog libelf libiconv\"\n+host_libs=\"intl libiberty opcodes bfd readline tcl tk itcl libgui zlib libbacktrace libcpp libdecnumber gmp mpfr mpc isl cloog libelf libiconv\"\n \n # these tools are built for the host environment\n # Note, the powerpc-eabi build depends on sim occurring before gdb in order to\n@@ -152,6 +152,7 @@ libgcj=\"target-libffi \\\n # the host libraries and the host tools (which may be a cross compiler)\n # Note that libiberty is not a target library.\n target_libraries=\"target-libgcc \\\n+\t\ttarget-libbacktrace \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\"}, {"sha": "86ef0c9a9b30c9396681fd6098d4a0d583bfc72b", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -1,3 +1,7 @@\n+2012-09-17  Ian Lance Taylor  <iant@google.com>\n+\n+\t* config-lang.in (target_libs): Add target-libbacktrace.\n+\n 2012-09-16  Ian Lance Taylor  <iant@google.com>\n \n \t* Make-lang.in (go/gogo.o): Depend on filenames.h."}, {"sha": "7ad5736f6616667821c471235acad4343e6a3d2d", "filename": "gcc/go/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/gcc%2Fgo%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/gcc%2Fgo%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fconfig-lang.in?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -28,7 +28,7 @@ language=\"go\"\n \n compilers=\"go1\\$(exeext)\"\n \n-target_libs=\"target-libgo target-libffi\"\n+target_libs=\"target-libgo target-libffi target-libbacktrace\"\n \n # The Go frontend is written in C++, so we need to build the C++\n # compiler during stage 1."}, {"sha": "e8142d2749f16897eaf00c03bf5273df1781deeb", "filename": "libbacktrace/ChangeLog", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,3 @@\n+2012-09-17  Ian Lance Taylor  <iant@google.com>\n+\n+\t* Initial implementation."}, {"sha": "0cbed3b834563d458c94b74f084e8de6f317ab85", "filename": "libbacktrace/Makefile.am", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.am?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,92 @@\n+# Makefile.am -- Backtrace Makefile.\n+# Copyright (C) 2012 Free Software Foundation, Inc.\n+\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are\n+# met:\n+\n+#     (1) Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer. \n+\n+#     (2) Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in\n+#     the documentation and/or other materials provided with the\n+#     distribution.  \n+    \n+#     (3) The name of the author may not be used to\n+#     endorse or promote products derived from this software without\n+#     specific prior written permission.\n+\n+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+\n+AM_CFLAGS = $(WARN_FLAGS) $(PIC_FLAG) -I $(srcdir)/../include -I ../libgcc\n+\n+noinst_LTLIBRARIES = libbacktrace.la\n+\n+libbacktrace_la_SOURCES = \\\n+\tbacktrace.h \\\n+\tdwarf.c \\\n+\tfileline.c \\\n+\tinternal.h \\\n+\tposix.c \\\n+\tprint.c \\\n+\tstate.c\n+\n+BACKTRACE_FILES = \\\n+\tbacktrace.c \\\n+\tsimple.c \\\n+\tnounwind.c\n+\n+FORMAT_FILES = \\\n+\telf.c \\\n+\tunknown.c\n+\n+VIEW_FILES = \\\n+\tread.c \\\n+\tmmapio.c\n+\n+ALLOC_FILES = \\\n+\talloc.c \\\n+\tmmap.c\n+\n+EXTRA_libbacktrace_la_SOURCES = \\\n+\t$(BACKTRACE_FILES) \\\n+\t$(FORMAT_FILES) \\\n+\t$(VIEW_FILES) \\\n+\t$(ALLOC_FILES)\n+\n+libbacktrace_la_LIBADD = \\\n+\t$(BACKTRACE_FILE) \\\n+\t$(FORMAT_FILE) \\\n+\t$(VIEW_FILE) \\\n+\t$(ALLOC_FILE)\n+\n+libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n+\n+# Testsuite.\n+\n+check_PROGRAMS =\n+\n+TESTS = $(check_PROGRAMS)\n+\n+if NATIVE\n+\n+btest_SOURCES = btest.c\n+btest_CFLAGS = $(AM_CFLAGS) -g -O\n+btest_LDADD = libbacktrace.la\n+\n+check_PROGRAMS += btest\n+\n+endif NATIVE"}, {"sha": "d53ea32cc9000fb35f9d78edbb3e55b469841888", "filename": "libbacktrace/Makefile.in", "status": "added", "additions": 740, "deletions": 0, "changes": 740, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.in?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,740 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+# Makefile.am -- Backtrace Makefile.\n+# Copyright (C) 2012 Free Software Foundation, Inc.\n+\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are\n+# met:\n+\n+#     (1) Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer. \n+\n+#     (2) Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in\n+#     the documentation and/or other materials provided with the\n+#     distribution.  \n+\n+#     (3) The name of the author may not be used to\n+#     endorse or promote products derived from this software without\n+#     specific prior written permission.\n+\n+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+check_PROGRAMS = $(am__EXEEXT_1)\n+@NATIVE_TRUE@am__append_1 = btest\n+subdir = .\n+DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \\\n+\t$(srcdir)/Makefile.am $(top_srcdir)/configure \\\n+\t$(am__configure_deps) $(srcdir)/config.h.in \\\n+\t$(srcdir)/../mkinstalldirs $(srcdir)/backtrace-supported.h.in \\\n+\t$(srcdir)/../depcomp\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../config/unwind_ipinfo.m4 \\\n+\t$(top_srcdir)/../config/warnings.m4 \\\n+\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n+\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n+\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n+ configure.lineno config.status.lineno\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_HEADER = config.h\n+CONFIG_CLEAN_FILES = backtrace-supported.h\n+CONFIG_CLEAN_VPATH_FILES =\n+LTLIBRARIES = $(noinst_LTLIBRARIES)\n+am__DEPENDENCIES_1 =\n+am_libbacktrace_la_OBJECTS = dwarf.lo fileline.lo posix.lo print.lo \\\n+\tstate.lo\n+libbacktrace_la_OBJECTS = $(am_libbacktrace_la_OBJECTS)\n+@NATIVE_TRUE@am__EXEEXT_1 = btest$(EXEEXT)\n+@NATIVE_TRUE@am_btest_OBJECTS = btest-btest.$(OBJEXT)\n+btest_OBJECTS = $(am_btest_OBJECTS)\n+@NATIVE_TRUE@btest_DEPENDENCIES = libbacktrace.la\n+btest_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(btest_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/../depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n+\t$(btest_SOURCES)\n+MULTISRCTOP = \n+MULTIBUILDTOP = \n+MULTIDIRS = \n+MULTISUBDIR = \n+MULTIDO = true\n+MULTICLEAN = true\n+ETAGS = etags\n+CTAGS = ctags\n+am__tty_colors = \\\n+red=; grn=; lgn=; blu=; std=\n+ACLOCAL = @ACLOCAL@\n+ALLOC_FILE = @ALLOC_FILE@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+BACKTRACE_FILE = @BACKTRACE_FILE@\n+BACKTRACE_SUPPORTED = @BACKTRACE_SUPPORTED@\n+BACKTRACE_SUPPORTS_THREADS = @BACKTRACE_SUPPORTS_THREADS@\n+BACKTRACE_USES_MALLOC = @BACKTRACE_USES_MALLOC@\n+CC = @CC@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+FORMAT_FILE = @FORMAT_FILE@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+PIC_FLAG = @PIC_FLAG@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+VIEW_FILE = @VIEW_FILE@\n+WARN_FLAGS = @WARN_FLAGS@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+libtool_VERSION = @libtool_VERSION@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+AM_CFLAGS = $(WARN_FLAGS) $(PIC_FLAG) -I $(srcdir)/../include -I ../libgcc\n+noinst_LTLIBRARIES = libbacktrace.la\n+libbacktrace_la_SOURCES = \\\n+\tbacktrace.h \\\n+\tdwarf.c \\\n+\tfileline.c \\\n+\tinternal.h \\\n+\tposix.c \\\n+\tprint.c \\\n+\tstate.c\n+\n+BACKTRACE_FILES = \\\n+\tbacktrace.c \\\n+\tsimple.c \\\n+\tnounwind.c\n+\n+FORMAT_FILES = \\\n+\telf.c \\\n+\tunknown.c\n+\n+VIEW_FILES = \\\n+\tread.c \\\n+\tmmapio.c\n+\n+ALLOC_FILES = \\\n+\talloc.c \\\n+\tmmap.c\n+\n+EXTRA_libbacktrace_la_SOURCES = \\\n+\t$(BACKTRACE_FILES) \\\n+\t$(FORMAT_FILES) \\\n+\t$(VIEW_FILES) \\\n+\t$(ALLOC_FILES)\n+\n+libbacktrace_la_LIBADD = \\\n+\t$(BACKTRACE_FILE) \\\n+\t$(FORMAT_FILE) \\\n+\t$(VIEW_FILE) \\\n+\t$(ALLOC_FILE)\n+\n+libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n+TESTS = $(check_PROGRAMS)\n+@NATIVE_TRUE@btest_SOURCES = btest.c\n+@NATIVE_TRUE@btest_CFLAGS = $(AM_CFLAGS) -g -O\n+@NATIVE_TRUE@btest_LDADD = libbacktrace.la\n+all: config.h\n+\t$(MAKE) $(AM_MAKEFLAGS) all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .c .lo .o .obj\n+am--refresh:\n+\t@:\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n+\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n+\t\t&& exit 0; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    echo ' $(SHELL) ./config.status'; \\\n+\t    $(SHELL) ./config.status;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\t$(am__cd) $(srcdir) && $(AUTOCONF)\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n+$(am__aclocal_m4_deps):\n+\n+config.h: stamp-h1\n+\t@if test ! -f $@; then \\\n+\t  rm -f stamp-h1; \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \\\n+\telse :; fi\n+\n+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n+\t@rm -f stamp-h1\n+\tcd $(top_builddir) && $(SHELL) ./config.status config.h\n+$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n+\t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n+\trm -f stamp-h1\n+\ttouch $@\n+\n+distclean-hdr:\n+\t-rm -f config.h stamp-h1\n+backtrace-supported.h: $(top_builddir)/config.status $(srcdir)/backtrace-supported.h.in\n+\tcd $(top_builddir) && $(SHELL) ./config.status $@\n+\n+clean-noinstLTLIBRARIES:\n+\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n+\t@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libbacktrace.la: $(libbacktrace_la_OBJECTS) $(libbacktrace_la_DEPENDENCIES) \n+\t$(LINK)  $(libbacktrace_la_OBJECTS) $(libbacktrace_la_LIBADD) $(LIBS)\n+\n+clean-checkPROGRAMS:\n+\t@list='$(check_PROGRAMS)'; test -n \"$$list\" || exit 0; \\\n+\techo \" rm -f\" $$list; \\\n+\trm -f $$list || exit $$?; \\\n+\ttest -n \"$(EXEEXT)\" || exit 0; \\\n+\tlist=`for p in $$list; do echo \"$$p\"; done | sed 's/$(EXEEXT)$$//'`; \\\n+\techo \" rm -f\" $$list; \\\n+\trm -f $$list\n+btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES) \n+\t@rm -f btest$(EXEEXT)\n+\t$(btest_LINK) $(btest_OBJECTS) $(btest_LDADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/backtrace.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/btest-btest.Po@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dwarf.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fileline.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mmap.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mmapio.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nounwind.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/posix.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/print.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/read.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/simple.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/state.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unknown.Plo@am__quote@\n+\n+.c.o:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n+\n+.c.obj:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n+\n+.c.lo:\n+@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n+\n+btest-btest.o: btest.c\n+@am__fastdepCC_TRUE@\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -MT btest-btest.o -MD -MP -MF $(DEPDIR)/btest-btest.Tpo -c -o btest-btest.o `test -f 'btest.c' || echo '$(srcdir)/'`btest.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/btest-btest.Tpo $(DEPDIR)/btest-btest.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='btest.c' object='btest-btest.o' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-btest.o `test -f 'btest.c' || echo '$(srcdir)/'`btest.c\n+\n+btest-btest.obj: btest.c\n+@am__fastdepCC_TRUE@\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -MT btest-btest.obj -MD -MP -MF $(DEPDIR)/btest-btest.Tpo -c -o btest-btest.obj `if test -f 'btest.c'; then $(CYGPATH_W) 'btest.c'; else $(CYGPATH_W) '$(srcdir)/btest.c'; fi`\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/btest-btest.Tpo $(DEPDIR)/btest-btest.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='btest.c' object='btest-btest.obj' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-btest.obj `if test -f 'btest.c'; then $(CYGPATH_W) 'btest.c'; else $(CYGPATH_W) '$(srcdir)/btest.c'; fi`\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+distclean-libtool:\n+\t-rm -f libtool config.lt\n+\n+# GNU Make needs to see an explicit $(MAKE) variable in the command it\n+# runs to enable its job server during parallel builds.  Hence the\n+# comments below.\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n+\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+\n+check-TESTS: $(TESTS)\n+\t@failed=0; all=0; xfail=0; xpass=0; skip=0; \\\n+\tsrcdir=$(srcdir); export srcdir; \\\n+\tlist=' $(TESTS) '; \\\n+\t$(am__tty_colors); \\\n+\tif test -n \"$$list\"; then \\\n+\t  for tst in $$list; do \\\n+\t    if test -f ./$$tst; then dir=./; \\\n+\t    elif test -f $$tst; then dir=; \\\n+\t    else dir=\"$(srcdir)/\"; fi; \\\n+\t    if $(TESTS_ENVIRONMENT) $${dir}$$tst; then \\\n+\t      all=`expr $$all + 1`; \\\n+\t      case \" $(XFAIL_TESTS) \" in \\\n+\t      *[\\ \\\t]$$tst[\\ \\\t]*) \\\n+\t\txpass=`expr $$xpass + 1`; \\\n+\t\tfailed=`expr $$failed + 1`; \\\n+\t\tcol=$$red; res=XPASS; \\\n+\t      ;; \\\n+\t      *) \\\n+\t\tcol=$$grn; res=PASS; \\\n+\t      ;; \\\n+\t      esac; \\\n+\t    elif test $$? -ne 77; then \\\n+\t      all=`expr $$all + 1`; \\\n+\t      case \" $(XFAIL_TESTS) \" in \\\n+\t      *[\\ \\\t]$$tst[\\ \\\t]*) \\\n+\t\txfail=`expr $$xfail + 1`; \\\n+\t\tcol=$$lgn; res=XFAIL; \\\n+\t      ;; \\\n+\t      *) \\\n+\t\tfailed=`expr $$failed + 1`; \\\n+\t\tcol=$$red; res=FAIL; \\\n+\t      ;; \\\n+\t      esac; \\\n+\t    else \\\n+\t      skip=`expr $$skip + 1`; \\\n+\t      col=$$blu; res=SKIP; \\\n+\t    fi; \\\n+\t    echo \"$${col}$$res$${std}: $$tst\"; \\\n+\t  done; \\\n+\t  if test \"$$all\" -eq 1; then \\\n+\t    tests=\"test\"; \\\n+\t    All=\"\"; \\\n+\t  else \\\n+\t    tests=\"tests\"; \\\n+\t    All=\"All \"; \\\n+\t  fi; \\\n+\t  if test \"$$failed\" -eq 0; then \\\n+\t    if test \"$$xfail\" -eq 0; then \\\n+\t      banner=\"$$All$$all $$tests passed\"; \\\n+\t    else \\\n+\t      if test \"$$xfail\" -eq 1; then failures=failure; else failures=failures; fi; \\\n+\t      banner=\"$$All$$all $$tests behaved as expected ($$xfail expected $$failures)\"; \\\n+\t    fi; \\\n+\t  else \\\n+\t    if test \"$$xpass\" -eq 0; then \\\n+\t      banner=\"$$failed of $$all $$tests failed\"; \\\n+\t    else \\\n+\t      if test \"$$xpass\" -eq 1; then passes=pass; else passes=passes; fi; \\\n+\t      banner=\"$$failed of $$all $$tests did not behave as expected ($$xpass unexpected $$passes)\"; \\\n+\t    fi; \\\n+\t  fi; \\\n+\t  dashes=\"$$banner\"; \\\n+\t  skipped=\"\"; \\\n+\t  if test \"$$skip\" -ne 0; then \\\n+\t    if test \"$$skip\" -eq 1; then \\\n+\t      skipped=\"($$skip test was not run)\"; \\\n+\t    else \\\n+\t      skipped=\"($$skip tests were not run)\"; \\\n+\t    fi; \\\n+\t    test `echo \"$$skipped\" | wc -c` -le `echo \"$$banner\" | wc -c` || \\\n+\t      dashes=\"$$skipped\"; \\\n+\t  fi; \\\n+\t  report=\"\"; \\\n+\t  if test \"$$failed\" -ne 0 && test -n \"$(PACKAGE_BUGREPORT)\"; then \\\n+\t    report=\"Please report to $(PACKAGE_BUGREPORT)\"; \\\n+\t    test `echo \"$$report\" | wc -c` -le `echo \"$$banner\" | wc -c` || \\\n+\t      dashes=\"$$report\"; \\\n+\t  fi; \\\n+\t  dashes=`echo \"$$dashes\" | sed s/./=/g`; \\\n+\t  if test \"$$failed\" -eq 0; then \\\n+\t    echo \"$$grn$$dashes\"; \\\n+\t  else \\\n+\t    echo \"$$red$$dashes\"; \\\n+\t  fi; \\\n+\t  echo \"$$banner\"; \\\n+\t  test -z \"$$skipped\" || echo \"$$skipped\"; \\\n+\t  test -z \"$$report\" || echo \"$$report\"; \\\n+\t  echo \"$$dashes$$std\"; \\\n+\t  test \"$$failed\" -eq 0; \\\n+\telse :; fi\n+check-am: all-am\n+\t$(MAKE) $(AM_MAKEFLAGS) $(check_PROGRAMS)\n+\t$(MAKE) $(AM_MAKEFLAGS) check-TESTS\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES) all-multi config.h\n+installdirs:\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am clean-multi\n+\n+clean-am: clean-checkPROGRAMS clean-generic clean-libtool \\\n+\tclean-noinstLTLIBRARIES mostlyclean-am\n+\n+distclean: distclean-am distclean-multi\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-hdr distclean-libtool distclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am: install-multi\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am maintainer-clean-multi\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf $(top_srcdir)/autom4te.cache\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am mostlyclean-multi\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am:\n+\n+.MAKE: all all-multi check-am clean-multi distclean-multi install-am \\\n+\tinstall-multi install-strip maintainer-clean-multi \\\n+\tmostlyclean-multi\n+\n+.PHONY: CTAGS GTAGS all all-am all-multi am--refresh check check-TESTS \\\n+\tcheck-am clean clean-checkPROGRAMS clean-generic clean-libtool \\\n+\tclean-multi clean-noinstLTLIBRARIES ctags distclean \\\n+\tdistclean-compile distclean-generic distclean-hdr \\\n+\tdistclean-libtool distclean-multi distclean-tags dvi dvi-am \\\n+\thtml html-am info info-am install install-am install-data \\\n+\tinstall-data-am install-dvi install-dvi-am install-exec \\\n+\tinstall-exec-am install-html install-html-am install-info \\\n+\tinstall-info-am install-man install-multi install-pdf \\\n+\tinstall-pdf-am install-ps install-ps-am install-strip \\\n+\tinstallcheck installcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic maintainer-clean-multi mostlyclean \\\n+\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n+\tmostlyclean-multi pdf pdf-am ps ps-am tags uninstall \\\n+\tuninstall-am\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "e8b225745c9c639e67ea4f6fa0f97041ba978276", "filename": "libbacktrace/README", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FREADME?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,23 @@\n+The libbacktrace library\n+Initially written by Ian Lance Taylor <iant@google.com>\n+\n+The libbacktrace library may be linked into a program or library and\n+used to produce symbolic backtraces.  Sample uses would be to print a\n+detailed backtrace when an error occurs or to gather detailed\n+profiling information.\n+\n+The libbacktrace library is provided under a BSD license.  See the\n+source files for the exact license text.\n+\n+The public functions are declared and documented in the header file\n+backtrace.h, which should be #include'd by a user of the library.\n+\n+Building libbacktrace will generate a file backtrace-supported.h,\n+which a user of the library may use to determine whether backtraces\n+will work.  See the source file backtrace-supported.h.in for the\n+macros that it defines.\n+\n+As of September 2012, libbacktrace only supports ELF executables with\n+DWARF debugging information.  The library is written to make it\n+straightforward to add support for other object file and debugging\n+formats."}, {"sha": "9b2ca61ce80f84d360aabdce32df0bbe90172c46", "filename": "libbacktrace/aclocal.m4", "status": "added", "additions": 981, "deletions": 0, "changes": 981, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Faclocal.m4?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,981 @@\n+# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n+[m4_warning([this file was generated for autoconf 2.64.\n+You have another version of autoconf.  It may work, but is not guaranteed to.\n+If you have problems, you may need to regenerate the build system entirely.\n+To do so, use the procedure documented by the package, typically `autoreconf'.])])\n+\n+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_AUTOMAKE_VERSION(VERSION)\n+# ----------------------------\n+# Automake X.Y traces this macro to ensure aclocal.m4 has been\n+# generated from the m4 files accompanying Automake X.Y.\n+# (This private macro should not be called outside this file.)\n+AC_DEFUN([AM_AUTOMAKE_VERSION],\n+[am__api_version='1.11'\n+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n+dnl require some minimum version.  Point them to the right macro.\n+m4_if([$1], [1.11.1], [],\n+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n+])\n+\n+# _AM_AUTOCONF_VERSION(VERSION)\n+# -----------------------------\n+# aclocal traces this macro to find the Autoconf version.\n+# This is a private macro too.  Using m4_define simplifies\n+# the logic in aclocal, which can simply ignore this definition.\n+m4_define([_AM_AUTOCONF_VERSION], [])\n+\n+# AM_SET_CURRENT_AUTOMAKE_VERSION\n+# -------------------------------\n+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n+[AM_AUTOMAKE_VERSION([1.11.1])dnl\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n+\n+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n+#\n+# Of course, Automake must honor this variable whenever it calls a\n+# tool from the auxiliary directory.  The problem is that $srcdir (and\n+# therefore $ac_aux_dir as well) can be either absolute or relative,\n+# depending on how configure is run.  This is pretty annoying, since\n+# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n+# source directory, any form will work fine, but in subdirectories a\n+# relative path needs to be adjusted first.\n+#\n+# $ac_aux_dir/missing\n+#    fails when called from a subdirectory if $ac_aux_dir is relative\n+# $top_srcdir/$ac_aux_dir/missing\n+#    fails if $ac_aux_dir is absolute,\n+#    fails when called from a subdirectory in a VPATH build with\n+#          a relative $ac_aux_dir\n+#\n+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n+# are both prefixed by $srcdir.  In an in-source build this is usually\n+# harmless because $srcdir is `.', but things will broke when you\n+# start a VPATH build or use an absolute $srcdir.\n+#\n+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n+#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n+# and then we would define $MISSING as\n+#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n+# This will work as long as MISSING is not called from configure, because\n+# unfortunately $(top_srcdir) has no meaning in configure.\n+# However there are other variables, like CC, which are often used in\n+# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n+#\n+# Another solution, used here, is to always expand $ac_aux_dir to an\n+# absolute PATH.  The drawback is that using absolute paths prevent a\n+# configured tree to be moved without reconfiguration.\n+\n+AC_DEFUN([AM_AUX_DIR_EXPAND],\n+[dnl Rely on autoconf to set up CDPATH properly.\n+AC_PREREQ([2.50])dnl\n+# expand $ac_aux_dir to an absolute path\n+am_aux_dir=`cd $ac_aux_dir && pwd`\n+])\n+\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 9\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ(2.52)dnl\n+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])dnl\n+AC_SUBST([$1_FALSE])dnl\n+_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n+_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n+m4_define([_AM_COND_VALUE_$1], [$2])dnl\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 10\n+\n+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n+# written in clear, in which case automake, when reading aclocal.m4,\n+# will think it sees a *use*, and therefore will trigger all it's\n+# C support machinery.  Also note that it means that autoscan, seeing\n+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n+\n+\n+# _AM_DEPENDENCIES(NAME)\n+# ----------------------\n+# See how the compiler implements dependency checking.\n+# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n+# We try a few techniques and use that to set a single cache variable.\n+#\n+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n+# dependency, and given that the user is not expected to run this macro,\n+# just rely on AC_PROG_CC.\n+AC_DEFUN([_AM_DEPENDENCIES],\n+[AC_REQUIRE([AM_SET_DEPDIR])dnl\n+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n+AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n+AC_REQUIRE([AM_DEP_TRACK])dnl\n+\n+ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n+       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n+       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n+       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n+       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n+                   [depcc=\"$$1\"   am_compiler_list=])\n+\n+AC_CACHE_CHECK([dependency style of $depcc],\n+               [am_cv_$1_dependencies_compiler_type],\n+[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n+  # We make a subdir and do the tests there.  Otherwise we can end up\n+  # making bogus files that we don't know about and never remove.  For\n+  # instance it was reported that on HP-UX the gcc test will end up\n+  # making a dummy file named `D' -- because `-MD' means `put the output\n+  # in D'.\n+  mkdir conftest.dir\n+  # Copy depcomp to subdir because otherwise we won't find it if we're\n+  # using a relative directory.\n+  cp \"$am_depcomp\" conftest.dir\n+  cd conftest.dir\n+  # We will build objects and dependencies in a subdirectory because\n+  # it helps to detect inapplicable dependency modes.  For instance\n+  # both Tru64's cc and ICC support -MD to output dependencies as a\n+  # side effect of compilation, but ICC will put the dependencies in\n+  # the current directory while Tru64 will put them in the object\n+  # directory.\n+  mkdir sub\n+\n+  am_cv_$1_dependencies_compiler_type=none\n+  if test \"$am_compiler_list\" = \"\"; then\n+     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n+  fi\n+  am__universal=false\n+  m4_case([$1], [CC],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac],\n+    [CXX],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac])\n+\n+  for depmode in $am_compiler_list; do\n+    # Setup a source with many dependencies, because some compilers\n+    # like to wrap large dependency lists on column 80 (with \\), and\n+    # we should not choose a depcomp mode which is confused by this.\n+    #\n+    # We need to recreate these files for each test, as the compiler may\n+    # overwrite some of them when testing with obscure command lines.\n+    # This happens at least with the AIX C compiler.\n+    : > sub/conftest.c\n+    for i in 1 2 3 4 5 6; do\n+      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n+      # Solaris 8's {/usr,}/bin/sh.\n+      touch sub/conftst$i.h\n+    done\n+    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n+\n+    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n+    # mode.  It turns out that the SunPro C++ compiler does not properly\n+    # handle `-M -o', and we need to detect this.  Also, some Intel\n+    # versions had trouble with output in subdirs\n+    am__obj=sub/conftest.${OBJEXT-o}\n+    am__minus_obj=\"-o $am__obj\"\n+    case $depmode in\n+    gcc)\n+      # This depmode causes a compiler race in universal mode.\n+      test \"$am__universal\" = false || continue\n+      ;;\n+    nosideeffect)\n+      # after this tag, mechanisms are not by side-effect, so they'll\n+      # only be used when explicitly requested\n+      if test \"x$enable_dependency_tracking\" = xyes; then\n+\tcontinue\n+      else\n+\tbreak\n+      fi\n+      ;;\n+    msvisualcpp | msvcmsys)\n+      # This compiler won't grok `-c -o', but also, the minuso test has\n+      # not run yet.  These depmodes are late enough in the game, and\n+      # so weak that their functioning should not be impacted.\n+      am__obj=conftest.${OBJEXT-o}\n+      am__minus_obj=\n+      ;;\n+    none) break ;;\n+    esac\n+    if depmode=$depmode \\\n+       source=sub/conftest.c object=$am__obj \\\n+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n+         >/dev/null 2>conftest.err &&\n+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n+      # icc doesn't choke on unknown options, it will just issue warnings\n+      # or remarks (even with -Werror).  So we grep stderr for any message\n+      # that says an option was ignored or not supported.\n+      # When given -MP, icc 7.0 and 7.1 complain thusly:\n+      #   icc: Command line warning: ignoring option '-M'; no argument required\n+      # The diagnosis changed in icc 8.0:\n+      #   icc: Command line remark: option '-MP' not supported\n+      if (grep 'ignoring option' conftest.err ||\n+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n+        am_cv_$1_dependencies_compiler_type=$depmode\n+        break\n+      fi\n+    fi\n+  done\n+\n+  cd ..\n+  rm -rf conftest.dir\n+else\n+  am_cv_$1_dependencies_compiler_type=none\n+fi\n+])\n+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n+AM_CONDITIONAL([am__fastdep$1], [\n+  test \"x$enable_dependency_tracking\" != xno \\\n+  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n+])\n+\n+\n+# AM_SET_DEPDIR\n+# -------------\n+# Choose a directory name for dependency files.\n+# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n+AC_DEFUN([AM_SET_DEPDIR],\n+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n+])\n+\n+\n+# AM_DEP_TRACK\n+# ------------\n+AC_DEFUN([AM_DEP_TRACK],\n+[AC_ARG_ENABLE(dependency-tracking,\n+[  --disable-dependency-tracking  speeds up one-time build\n+  --enable-dependency-tracking   do not reject slow dependency extractors])\n+if test \"x$enable_dependency_tracking\" != xno; then\n+  am_depcomp=\"$ac_aux_dir/depcomp\"\n+  AMDEPBACKSLASH='\\'\n+fi\n+AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n+AC_SUBST([AMDEPBACKSLASH])dnl\n+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n+])\n+\n+# Generate code to set up dependency tracking.              -*- Autoconf -*-\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+#serial 5\n+\n+# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+# ------------------------------\n+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[{\n+  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n+  # are listed without --file.  Let's play safe and only enable the eval\n+  # if we detect the quoting.\n+  case $CONFIG_FILES in\n+  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n+  *)   set x $CONFIG_FILES ;;\n+  esac\n+  shift\n+  for mf\n+  do\n+    # Strip MF so we end up with the name of the file.\n+    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n+    # Check whether this is an Automake generated Makefile or not.\n+    # We used to match only the files named `Makefile.in', but\n+    # some people rename them; so instead we look at the file content.\n+    # Grep'ing the first line is not enough: some people post-process\n+    # each Makefile.in and add a new line on top of each file to say so.\n+    # Grep'ing the whole file is not good either: AIX grep has a line\n+    # limit of 2048, but all sed's we know have understand at least 4000.\n+    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n+      dirpart=`AS_DIRNAME(\"$mf\")`\n+    else\n+      continue\n+    fi\n+    # Extract the definition of DEPDIR, am__include, and am__quote\n+    # from the Makefile without running `make'.\n+    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n+    test -z \"$DEPDIR\" && continue\n+    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+    test -z \"am__include\" && continue\n+    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n+    # When using ansi2knr, U may be empty or an underscore; expand it\n+    U=`sed -n 's/^U = //p' < \"$mf\"`\n+    # Find all dependency output files, they are included files with\n+    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+    # simplest approach to changing $(DEPDIR) to its actual value in the\n+    # expansion.\n+    for file in `sed -n \"\n+      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n+\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n+      # Make sure the directory exists.\n+      test -f \"$dirpart/$file\" && continue\n+      fdir=`AS_DIRNAME([\"$file\"])`\n+      AS_MKDIR_P([$dirpart/$fdir])\n+      # echo \"creating $dirpart/$file\"\n+      echo '# dummy' > \"$dirpart/$file\"\n+    done\n+  done\n+}\n+])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+\n+\n+# AM_OUTPUT_DEPENDENCY_COMMANDS\n+# -----------------------------\n+# This macro should only be invoked once -- use via AC_REQUIRE.\n+#\n+# This code is only required when automatic dependency tracking\n+# is enabled.  FIXME.  This creates each `.P' file that we will\n+# need in order to bootstrap the dependency handling code.\n+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[AC_CONFIG_COMMANDS([depfiles],\n+     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n+     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n+])\n+\n+# Do all the work for Automake.                             -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 16\n+\n+# This macro actually does too much.  Some checks are only needed if\n+# your package does certain things.  But this isn't really a big deal.\n+\n+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n+# AM_INIT_AUTOMAKE([OPTIONS])\n+# -----------------------------------------------\n+# The call with PACKAGE and VERSION arguments is the old style\n+# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n+# and VERSION should now be passed to AC_INIT and removed from\n+# the call to AM_INIT_AUTOMAKE.\n+# We support both call styles for the transition.  After\n+# the next Automake release, Autoconf can make the AC_INIT\n+# arguments mandatory, and then we can depend on a new Autoconf\n+# release and drop the old call support.\n+AC_DEFUN([AM_INIT_AUTOMAKE],\n+[AC_PREREQ([2.62])dnl\n+dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n+dnl the ones we care about.\n+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n+AC_REQUIRE([AC_PROG_INSTALL])dnl\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n+  # is not polluted with repeated \"-I.\"\n+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n+  # test to see if srcdir already configured\n+  if test -f $srcdir/config.status; then\n+    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+  fi\n+fi\n+\n+# test whether we have cygpath\n+if test -z \"$CYGPATH_W\"; then\n+  if (cygpath --version) >/dev/null 2>/dev/null; then\n+    CYGPATH_W='cygpath -w'\n+  else\n+    CYGPATH_W=echo\n+  fi\n+fi\n+AC_SUBST([CYGPATH_W])\n+\n+# Define the identity of the package.\n+dnl Distinguish between old-style and new-style calls.\n+m4_ifval([$2],\n+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n+ AC_SUBST([PACKAGE], [$1])dnl\n+ AC_SUBST([VERSION], [$2])],\n+[_AM_SET_OPTIONS([$1])dnl\n+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n+\n+_AM_IF_OPTION([no-define],,\n+[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n+ AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n+\n+# Some tools Automake needs.\n+AC_REQUIRE([AM_SANITY_CHECK])dnl\n+AC_REQUIRE([AC_ARG_PROGRAM])dnl\n+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n+AM_MISSING_PROG(AUTOCONF, autoconf)\n+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n+AM_MISSING_PROG(AUTOHEADER, autoheader)\n+AM_MISSING_PROG(MAKEINFO, makeinfo)\n+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n+AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n+# We need awk for the \"check\" target.  The system \"awk\" is bad on\n+# some platforms.\n+AC_REQUIRE([AC_PROG_AWK])dnl\n+AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n+AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t\t\t     [_AM_PROG_TAR([v7])])])\n+_AM_IF_OPTION([no-dependencies],,\n+[AC_PROVIDE_IFELSE([AC_PROG_CC],\n+\t\t  [_AM_DEPENDENCIES(CC)],\n+\t\t  [define([AC_PROG_CC],\n+\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_CXX],\n+\t\t  [_AM_DEPENDENCIES(CXX)],\n+\t\t  [define([AC_PROG_CXX],\n+\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n+\t\t  [_AM_DEPENDENCIES(OBJC)],\n+\t\t  [define([AC_PROG_OBJC],\n+\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n+])\n+_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n+dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n+dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n+dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n+AC_CONFIG_COMMANDS_PRE(dnl\n+[m4_provide_if([_AM_COMPILER_EXEEXT],\n+  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n+])\n+\n+dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n+dnl mangled by Autoconf and run in a shell conditional statement.\n+m4_define([_AC_COMPILER_EXEEXT],\n+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n+\n+\n+# When config.status generates a header, we must update the stamp-h file.\n+# This file resides in the same directory as the config header\n+# that is generated.  The stamp files are numbered to have different names.\n+\n+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n+# loop where config.status creates the headers, so we can generate\n+# our stamp files there.\n+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n+[# Compute $1's index in $config_headers.\n+_am_arg=$1\n+_am_stamp_count=1\n+for _am_header in $config_headers :; do\n+  case $_am_header in\n+    $_am_arg | $_am_arg:* )\n+      break ;;\n+    * )\n+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n+  esac\n+done\n+echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n+\n+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_SH\n+# ------------------\n+# Define $install_sh.\n+AC_DEFUN([AM_PROG_INSTALL_SH],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+if test x\"${install_sh}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n+  *)\n+    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n+  esac\n+fi\n+AC_SUBST(install_sh)])\n+\n+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n+# From Jim Meyering\n+\n+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_MAINTAINER_MODE([DEFAULT-MODE])\n+# ----------------------------------\n+# Control maintainer-specific portions of Makefiles.\n+# Default is to disable them, unless `enable' is passed literally.\n+# For symmetry, `disable' may be passed as well.  Anyway, the user\n+# can override the default with the --enable/--disable switch.\n+AC_DEFUN([AM_MAINTAINER_MODE],\n+[m4_case(m4_default([$1], [disable]),\n+       [enable], [m4_define([am_maintainer_other], [disable])],\n+       [disable], [m4_define([am_maintainer_other], [enable])],\n+       [m4_define([am_maintainer_other], [enable])\n+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n+AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])\n+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n+  AC_ARG_ENABLE([maintainer-mode],\n+[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n+\t\t\t  (and sometimes confusing) to the casual installer],\n+      [USE_MAINTAINER_MODE=$enableval],\n+      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n+  MAINT=$MAINTAINER_MODE_TRUE\n+  AC_SUBST([MAINT])dnl\n+]\n+)\n+\n+AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n+\n+# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# AM_MAKE_INCLUDE()\n+# -----------------\n+# Check to see how make treats includes.\n+AC_DEFUN([AM_MAKE_INCLUDE],\n+[am_make=${MAKE-make}\n+cat > confinc << 'END'\n+am__doit:\n+\t@echo this is the am__doit target\n+.PHONY: am__doit\n+END\n+# If we don't find an include directive, just comment out the code.\n+AC_MSG_CHECKING([for style of include used by $am_make])\n+am__include=\"#\"\n+am__quote=\n+_am_result=none\n+# First try GNU make style include.\n+echo \"include confinc\" > confmf\n+# Ignore all kinds of additional output from `make'.\n+case `$am_make -s -f confmf 2> /dev/null` in #(\n+*the\\ am__doit\\ target*)\n+  am__include=include\n+  am__quote=\n+  _am_result=GNU\n+  ;;\n+esac\n+# Now try BSD make style include.\n+if test \"$am__include\" = \"#\"; then\n+   echo '.include \"confinc\"' > confmf\n+   case `$am_make -s -f confmf 2> /dev/null` in #(\n+   *the\\ am__doit\\ target*)\n+     am__include=.include\n+     am__quote=\"\\\"\"\n+     _am_result=BSD\n+     ;;\n+   esac\n+fi\n+AC_SUBST([am__include])\n+AC_SUBST([am__quote])\n+AC_MSG_RESULT([$_am_result])\n+rm -f confinc confmf\n+])\n+\n+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 6\n+\n+# AM_MISSING_PROG(NAME, PROGRAM)\n+# ------------------------------\n+AC_DEFUN([AM_MISSING_PROG],\n+[AC_REQUIRE([AM_MISSING_HAS_RUN])\n+$1=${$1-\"${am_missing_run}$2\"}\n+AC_SUBST($1)])\n+\n+\n+# AM_MISSING_HAS_RUN\n+# ------------------\n+# Define MISSING if not defined so far and test if it supports --run.\n+# If it does, set am_missing_run to use it, otherwise, to nothing.\n+AC_DEFUN([AM_MISSING_HAS_RUN],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+AC_REQUIRE_AUX_FILE([missing])dnl\n+if test x\"${MISSING+set}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n+  *)\n+    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n+  esac\n+fi\n+# Use eval to expand $SHELL\n+if eval \"$MISSING --run true\"; then\n+  am_missing_run=\"$MISSING --run \"\n+else\n+  am_missing_run=\n+  AC_MSG_WARN([`missing' script is too old or missing])\n+fi\n+])\n+\n+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_MKDIR_P\n+# ---------------\n+# Check for `mkdir -p'.\n+AC_DEFUN([AM_PROG_MKDIR_P],\n+[AC_PREREQ([2.60])dnl\n+AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n+dnl while keeping a definition of mkdir_p for backward compatibility.\n+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n+dnl Makefile.ins that do not define MKDIR_P, so we do our own\n+dnl adjustment using top_builddir (which is defined more often than\n+dnl MKDIR_P).\n+AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n+case $mkdir_p in\n+  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n+  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n+esac\n+])\n+\n+# Helper functions for option handling.                     -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# _AM_MANGLE_OPTION(NAME)\n+# -----------------------\n+AC_DEFUN([_AM_MANGLE_OPTION],\n+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n+\n+# _AM_SET_OPTION(NAME)\n+# ------------------------------\n+# Set option NAME.  Presently that only means defining a flag for this option.\n+AC_DEFUN([_AM_SET_OPTION],\n+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n+\n+# _AM_SET_OPTIONS(OPTIONS)\n+# ----------------------------------\n+# OPTIONS is a space-separated list of Automake options.\n+AC_DEFUN([_AM_SET_OPTIONS],\n+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n+\n+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n+# -------------------------------------------\n+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n+AC_DEFUN([_AM_IF_OPTION],\n+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n+\n+# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_SANITY_CHECK\n+# ---------------\n+AC_DEFUN([AM_SANITY_CHECK],\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Just in case\n+sleep 1\n+echo timestamp > conftest.file\n+# Reject unsafe characters in $srcdir or the absolute working directory\n+# name.  Accept space and tab only in the latter.\n+am_lf='\n+'\n+case `pwd` in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n+    AC_MSG_ERROR([unsafe absolute working directory name]);;\n+esac\n+case $srcdir in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n+    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n+esac\n+\n+# Do `set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n+   if test \"$[*]\" = \"X\"; then\n+      # -L didn't work.\n+      set X `ls -t \"$srcdir/configure\" conftest.file`\n+   fi\n+   rm -f conftest.file\n+   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n+      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n+\n+      # If neither matched, then we have a broken ls.  This can happen\n+      # if, for instance, CONFIG_SHELL is bash and it inherits a\n+      # broken ls alias from the environment.  This has actually\n+      # happened.  Such a system could not be considered \"sane\".\n+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+alias in your environment])\n+   fi\n+\n+   test \"$[2]\" = conftest.file\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+AC_MSG_RESULT(yes)])\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_STRIP\n+# ---------------------\n+# One issue with vendor `install' (even GNU) is that you can't\n+# specify the program used to strip binaries.  This is especially\n+# annoying in cross-compiling environments, where the build's strip\n+# is unlikely to handle the host's binaries.\n+# Fortunately install-sh will honor a STRIPPROG variable, so we\n+# always use install-sh in `make install-strip', and initialize\n+# STRIPPROG with the value of the STRIP variable (set by the user).\n+AC_DEFUN([AM_PROG_INSTALL_STRIP],\n+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+# Installed binaries are usually stripped using `strip' when the user\n+# run `make install-strip'.  However `strip' might not be the right\n+# tool to use in cross-compilation environments, therefore Automake\n+# will honor the `STRIP' environment variable to overrule this program.\n+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n+if test \"$cross_compiling\" != no; then\n+  AC_CHECK_TOOL([STRIP], [strip], :)\n+fi\n+INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n+AC_SUBST([INSTALL_STRIP_PROGRAM])])\n+\n+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n+# This macro is traced by Automake.\n+AC_DEFUN([_AM_SUBST_NOTMAKE])\n+\n+# AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Public sister of _AM_SUBST_NOTMAKE.\n+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n+\n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of `v7', `ustar', or `pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n+m4_if([$1], [v7],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [m4_case([$1], [ustar],, [pax],,\n+              [m4_fatal([Unknown tar format])])\n+AC_MSG_CHECKING([how to create a $1 tar archive])\n+# Loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+# Do not fold the above two line into one, because Tru64 sh and\n+# Solaris sh will not grok spaces in the rhs of `-'.\n+for _am_tool in $_am_tools\n+do\n+  case $_am_tool in\n+  gnutar)\n+    for _am_tar in tar gnutar gtar;\n+    do\n+      AM_RUN_LOG([$_am_tar --version]) && break\n+    done\n+    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+    am__untar=\"$_am_tar -xf -\"\n+    ;;\n+  plaintar)\n+    # Must skip GNU tar: if it does not support --format= it doesn't create\n+    # ustar tarball either.\n+    (tar --version) >/dev/null 2>&1 && continue\n+    am__tar='tar chf - \"$$tardir\"'\n+    am__tar_='tar chf - \"$tardir\"'\n+    am__untar='tar xf -'\n+    ;;\n+  pax)\n+    am__tar='pax -L -x $1 -w \"$$tardir\"'\n+    am__tar_='pax -L -x $1 -w \"$tardir\"'\n+    am__untar='pax -r'\n+    ;;\n+  cpio)\n+    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+    am__untar='cpio -i -H $1 -d'\n+    ;;\n+  none)\n+    am__tar=false\n+    am__tar_=false\n+    am__untar=false\n+    ;;\n+  esac\n+\n+  # If the value was cached, stop now.  We just wanted to have am__tar\n+  # and am__untar set.\n+  test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+  # tar/untar a dummy directory, and stop if the command works\n+  rm -rf conftest.dir\n+  mkdir conftest.dir\n+  echo GrepMe > conftest.dir/file\n+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+  rm -rf conftest.dir\n+  if test -s conftest.tar; then\n+    AM_RUN_LOG([$am__untar <conftest.tar])\n+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+  fi\n+done\n+rm -rf conftest.dir\n+\n+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n+m4_include([../config/depstand.m4])\n+m4_include([../config/lead-dot.m4])\n+m4_include([../config/multi.m4])\n+m4_include([../config/override.m4])\n+m4_include([../config/unwind_ipinfo.m4])\n+m4_include([../config/warnings.m4])\n+m4_include([../libtool.m4])\n+m4_include([../ltoptions.m4])\n+m4_include([../ltsugar.m4])\n+m4_include([../ltversion.m4])\n+m4_include([../lt~obsolete.m4])"}, {"sha": "501f3863fb5ee25fe13a3dfe240e42a852eba464", "filename": "libbacktrace/alloc.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Falloc.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,139 @@\n+/* alloc.c -- Memory allocation without mmap.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Allocation routines to use on systems that do not support anonymous\n+   mmap.  This implementation just uses malloc, which means that the\n+   backtrace functions may not be safely invoked from a signal\n+   handler.  */\n+\n+/* Allocate memory like malloc.  */\n+\n+void *\n+backtrace_alloc (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t size_t size, backtrace_error_callback error_callback,\n+\t\t void *data)\n+{\n+  void *ret;\n+\n+  ret = malloc (size);\n+  if (ret == NULL)\n+    error_callback (data, \"malloc\", errno);\n+  return ret;\n+}\n+\n+/* Free memory.  */\n+\n+void\n+backtrace_free (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\tvoid *p, size_t size ATTRIBUTE_UNUSED,\n+\t\tbacktrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\tvoid *data ATTRIBUTE_UNUSED)\n+{\n+  free (p);\n+}\n+\n+/* Grow VEC by SIZE bytes.  */\n+\n+void *\n+backtrace_vector_grow (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t       size_t size, backtrace_error_callback error_callback,\n+\t\t       void *data, struct backtrace_vector *vec)\n+{\n+  void *ret;\n+\n+  if (size > vec->alc)\n+    {\n+      size_t alc;\n+      void *base;\n+\n+      if (vec->size == 0)\n+\talc = 32 * size;\n+      else if (vec->size >= 4096)\n+\talc = vec->size + 4096;\n+      else\n+\talc = 2 * vec->size;\n+\n+      if (alc < vec->size + size)\n+\talc = vec->size + size;\n+\n+      base = realloc (vec->base, alc);\n+      if (base == NULL)\n+\t{\n+\t  error_callback (data, \"realloc\", errno);\n+\t  return NULL;\n+\t}\n+\n+      vec->base = base;\n+      vec->alc = alc - vec->size;\n+    }\n+\n+  ret = (char *) vec->base + vec->size;\n+  vec->size += size;\n+  vec->alc -= size;\n+  return ret;\n+}\n+\n+/* Finish the current allocation on VEC.  */\n+\n+void\n+backtrace_vector_finish (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t\t struct backtrace_vector *vec)\n+{\n+  vec->base = (char *) vec->base + vec->size;\n+  vec->size = 0;\n+}\n+\n+/* Release any extra space allocated for VEC.  */\n+\n+int\n+backtrace_vector_release (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t\t  struct backtrace_vector *vec,\n+\t\t\t  backtrace_error_callback error_callback,\n+\t\t\t  void *data)\n+{\n+  vec->base = realloc (vec->base, vec->size);\n+  if (vec->base == NULL)\n+    {\n+      error_callback (data, \"realloc\", errno);\n+      return 0;\n+    }\n+  vec->alc = 0;\n+  return 1;\n+}"}, {"sha": "329f4c205a7d36ca520a5ca166db8fc27915b651", "filename": "libbacktrace/backtrace-supported.h.in", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fbacktrace-supported.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fbacktrace-supported.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fbacktrace-supported.h.in?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,61 @@\n+/* backtrace-supported.h.in -- Whether stack backtrace is supported.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* The file backtrace-supported.h.in is used by configure to generate\n+   the file backtrace-supported.h.  The file backtrace-supported.h may\n+   be #include'd to see whether the backtrace library will be able to\n+   get a backtrace and produce symbolic information.  */\n+\n+\n+/* BACKTRACE_SUPPORTED will be #define'd as 1 if the backtrace library\n+   should work, 0 if it will not.  Libraries may #include this to make\n+   other arrangements.  */\n+\n+#define BACKTRACE_SUPPORTED @BACKTRACE_SUPPORTED@\n+\n+/* BACKTRACE_USES_MALLOC will be #define'd as 1 if the backtrace\n+   library will call malloc as it works, 0 if it will call mmap\n+   instead.  This may be used to determine whether it is safe to call\n+   the backtrace functions from a signal handler.  In general this\n+   only applies to calls like backtrace and backtrace_pcinfo.  It does\n+   not apply to backtrace_simple, which never calls malloc.  It does\n+   not apply to backtrace_print, which always calls fprintf and\n+   therefore malloc.  */\n+\n+#define BACKTRACE_USES_MALLOC @BACKTRACE_USES_MALLOC@\n+\n+/* BACKTRACE_SUPPORTS_THREADS will be #define'd as 1 if the backtrace\n+   library is configured with threading support, 0 if not.  If this is\n+   0, the threaded parameter to backtrace_create_state must be passed\n+   as 0.  */\n+\n+#define BACKTRACE_SUPPORTS_THREADS @BACKTRACE_SUPPORTS_THREADS@"}, {"sha": "c16b88328eaad8e5f43d30db04401d86c70aa1ed", "filename": "libbacktrace/backtrace.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fbacktrace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fbacktrace.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,108 @@\n+/* backtrace.c -- Entry point for stack backtrace library.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include \"unwind.h\"\n+#include \"backtrace.h\"\n+\n+/* The main backtrace_full routine.  */\n+\n+/* Data passed through _Unwind_Backtrace.  */\n+\n+struct backtrace_data\n+{\n+  /* Number of frames to skip.  */\n+  int skip;\n+  /* Library state.  */\n+  struct backtrace_state *state;\n+  /* Callback routine.  */\n+  backtrace_full_callback callback;\n+  /* Error callback routine.  */\n+  backtrace_error_callback error_callback;\n+  /* Data to pass to callback routines.  */\n+  void *data;\n+  /* Value to return from backtrace_full.  */\n+  int ret;\n+};\n+\n+/* Unwind library callback routine.  This is passed to\n+   _Unwind_Backtrace.  */\n+\n+static _Unwind_Reason_Code\n+unwind (struct _Unwind_Context *context, void *vdata)\n+{\n+  struct backtrace_data *bdata = (struct backtrace_data *) vdata;\n+  uintptr_t pc;\n+  int ip_before_insn = 0;\n+\n+#ifdef HAVE_GETIPINFO\n+  pc = _Unwind_GetIPInfo (context, &ip_before_insn);\n+#else\n+  pc = _Unwind_GetIP (context);\n+#endif\n+\n+  if (bdata->skip > 0)\n+    {\n+      --bdata->skip;\n+      return _URC_NO_REASON;\n+    }\n+\n+  if (!ip_before_insn)\n+    --pc;\n+\n+  bdata->ret = backtrace_pcinfo (bdata->state, pc, bdata->callback,\n+\t\t\t\t bdata->error_callback, bdata->data);\n+  if (bdata->ret != 0)\n+    return _URC_END_OF_STACK;\n+\n+  return _URC_NO_REASON;\n+}\n+\n+/* Get a stack backtrace.  */\n+\n+int\n+backtrace_full (struct backtrace_state *state, int skip,\n+\t\tbacktrace_full_callback callback,\n+\t\tbacktrace_error_callback error_callback, void *data)\n+{\n+  struct backtrace_data bdata;\n+\n+  bdata.skip = skip + 1;\n+  bdata.state = state;\n+  bdata.callback = callback;\n+  bdata.error_callback = error_callback;\n+  bdata.data = data;\n+  bdata.ret = 0;\n+  _Unwind_Backtrace (unwind, &bdata);\n+  return bdata.ret;\n+}"}, {"sha": "a8d1ffcebeb51dbe68eba9b081c8813f17fecd68", "filename": "libbacktrace/backtrace.h", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fbacktrace.h?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,182 @@\n+/* backtrace.h -- Public header file for stack backtrace library.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#ifndef BACKTRACE_H\n+#define BACKTRACE_H\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* The backtrace state.  This struct is intentionally not defined in\n+   the public interface.  */\n+\n+struct backtrace_state;\n+\n+/* The type of the error callback argument to backtrace functions.\n+   This function, if not NULL, will be called for certain error cases.\n+   The DATA argument is passed to the function that calls this one.\n+   The MSG argument is an error message.  The ERRNUM argument, if\n+   greater than 0, holds an errno value.  The MSG buffer may become\n+   invalid after this function returns.\n+\n+   As a special case, the ERRNUM argument will be passed as -1 if no\n+   debug info can be found for the executable, but the function\n+   requires debug info (e.g., backtrace_full, backtrace_pcinfo).  The\n+   MSG in this case will be something along the lines of \"no debug\n+   info\".  Similarly, ERRNUM will be passed as -1 if there is no\n+   symbol table, but the function requires a symbol table (e.g.,\n+   backtrace_syminfo).  This may be used as a signal that some other\n+   approach should be tried.  */\n+\n+typedef void (*backtrace_error_callback) (void *data, const char *msg,\n+\t\t\t\t\t  int errnum);\n+\n+/* Create state information for the backtrace routines.  This must be\n+   called before any of the other routines, and its return value must\n+   be passed to all of the other routines.  FILENAME is the path name\n+   of the executable file; if it is NULL the library will try\n+   system-specific path names.  If not NULL, FILENAME must point to a\n+   permanent buffer.  If THREADED is non-zero the state may be\n+   accessed by multiple threads simultaneously, and the library will\n+   use appropriate locks (this requires that the library be configured\n+   with --enable-backtrace-threads).  If THREADED is zero the state\n+   may only be accessed by one thread at a time.  This returns a state\n+   pointer on success, NULL on error.  If an error occurs, this will\n+   call the ERROR_CALLBACK routine.  */\n+\n+extern struct backtrace_state *backtrace_create_state (\n+    const char *filename, int threaded,\n+    backtrace_error_callback error_callback, void *data);\n+\n+/* The type of the callback argument to the backtrace_full function.\n+   DATA is the argument passed to backtrace_full.  PC is the program\n+   counter.  FILENAME is the name of the file containing PC, or NULL\n+   if not available.  LINENO is the line number in FILENAME containing\n+   PC, or 0 if not available.  FUNCTION is the name of the function\n+   containing PC, or NULL if not available.  This should return 0 to\n+   continuing tracing.  The FILENAME and FUNCTION buffers may become\n+   invalid after this function returns.  */\n+\n+typedef int (*backtrace_full_callback) (void *data, uintptr_t pc,\n+\t\t\t\t\tconst char *filename, int lineno,\n+\t\t\t\t\tconst char *function);\n+\n+/* Get a full stack backtrace.  SKIP is the number of frames to skip;\n+   passing 0 will start the trace with the function calling\n+   backtrace_full.  DATA is passed to the callback routine.  If any\n+   call to CALLBACK returns a non-zero value, the stack backtrace\n+   stops, and backtrace returns that value; this may be used to limit\n+   the number of stack frames desired.  If all calls to CALLBACK\n+   return 0, backtrace returns 0.  The backtrace_full function will\n+   make at least one call to either CALLBACK or ERROR_CALLBACK.  This\n+   function requires debug info for the executable.  */\n+\n+extern int backtrace_full (struct backtrace_state *state, int skip,\n+\t\t\t   backtrace_full_callback callback,\n+\t\t\t   backtrace_error_callback error_callback,\n+\t\t\t   void *data);\n+\n+/* The type of the callback argument to the backtrace_simple function.\n+   DATA is the argument passed to simple_backtrace.  PC is the program\n+   counter.  This should return 0 to continue tracing.  */\n+\n+typedef int (*backtrace_simple_callback) (void *data, uintptr_t pc);\n+\n+/* Get a simple backtrace.  SKIP is the number of frames to skip, as\n+   in backtrace.  DATA is passed to the callback routine.  If any call\n+   to CALLBACK returns a non-zero value, the stack backtrace stops,\n+   and backtrace_simple returns that value.  Otherwise\n+   backtrace_simple returns 0.  The backtrace_simple function will\n+   make at least one call to either CALLBACK or ERROR_CALLBACK.  This\n+   function does not require any debug info for the executable.  */\n+\n+extern int backtrace_simple (struct backtrace_state *state, int skip,\n+\t\t\t     backtrace_simple_callback callback,\n+\t\t\t     backtrace_error_callback error_callback,\n+\t\t\t     void *data);\n+\n+/* Print the current backtrace in a user readable format to a FILE.\n+   SKIP is the number of frames to skip, as in backtrace_full.  Any\n+   error messages are printed to stderr.  This function requires debug\n+   info for the executable.  */\n+\n+extern void backtrace_print (struct backtrace_state *state, int skip, FILE *);\n+\n+/* Given PC, a program counter in the current program, call the\n+   callback function with filename, line number, and function name\n+   information.  This will normally call the callback function exactly\n+   once.  However, if the PC happens to describe an inlined call, and\n+   the debugging information contains the necessary information, then\n+   this may call the callback function multiple times.  This will make\n+   at least one call to either CALLBACK or ERROR_CALLBACK.  This\n+   returns the first non-zero value returned by CALLBACK, or 0.  */\n+\n+extern int backtrace_pcinfo (struct backtrace_state *state, uintptr_t pc,\n+\t\t\t     backtrace_full_callback callback,\n+\t\t\t     backtrace_error_callback error_callback,\n+\t\t\t     void *data);\n+\n+/* The type of the callback argument to backtrace_syminfo.  DATA and\n+   PC are the arguments passed to backtrace_syminfo.  SYMNAME is the\n+   name of the symbol for the corresponding code.  SYMVAL is the\n+   value.  SYMNAME will be NULL if no error occurred but the symbol\n+   could not be found.  */\n+\n+typedef void (*backtrace_syminfo_callback) (void *data, uintptr_t pc,\n+\t\t\t\t\t    const char *symname,\n+\t\t\t\t\t    uintptr_t symval);\n+\n+/* Given PC, a program counter in the current program, call the\n+   callback information with the symbol name and value describing the\n+   function in which PC may be found.  This will call either CALLBACK\n+   or ERROR_CALLBACK exactly once.  This returns 1 on success, 0 on\n+   failure.  This function requires the symbol table but does not\n+   require the debug info.  Note that if the symbol table is present\n+   but PC could not be found in the table, CALLBACK will be called\n+   with a NULL SYMNAME argument.  Returns 1 on success, 0 on\n+   error.  */\n+\n+extern int backtrace_syminfo (struct backtrace_state *state, uintptr_t pc,\n+\t\t\t      backtrace_syminfo_callback callback,\n+\t\t\t      backtrace_error_callback error_callback,\n+\t\t\t      void *data);\n+\n+#ifdef __cplusplus\n+} /* End extern \"C\".  */\n+#endif\n+\n+#endif"}, {"sha": "e36d3a24e5b5935b9fd08cb92a897e72942424f2", "filename": "libbacktrace/btest.c", "status": "added", "additions": 629, "deletions": 0, "changes": 629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fbtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fbtest.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,629 @@\n+/* btest.c -- Test for libbacktrace library\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* This program tests the externally visible interfaces of the\n+   libbacktrace library.  */\n+\n+#include <assert.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"filenames.h\"\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+/* Portable attribute syntax.  Actually some of these tests probably\n+   won't work if the attributes are not recognized.  */\n+\n+#ifndef GCC_VERSION\n+# define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n+#endif\n+\n+#if (GCC_VERSION < 2007)\n+# define __attribute__(x)\n+#endif\n+\n+#ifndef ATTRIBUTE_UNUSED\n+# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n+#endif\n+\n+/* Used to collect backtrace info.  */\n+\n+struct info\n+{\n+  char *filename;\n+  int lineno;\n+  char *function;\n+};\n+\n+/* Passed to backtrace callback function.  */\n+\n+struct bdata\n+{\n+  struct info *all;\n+  size_t index;\n+  size_t max;\n+  int failed;\n+};\n+\n+/* Passed to backtrace_simple callback function.  */\n+\n+struct sdata\n+{\n+  uintptr_t *addrs;\n+  size_t index;\n+  size_t max;\n+  int failed;\n+};\n+\n+/* Passed to backtrace_syminfo callback function.  */\n+\n+struct symdata\n+{\n+  const char *name;\n+  uintptr_t val;\n+  int failed;\n+};\n+\n+/* The backtrace state.  */\n+\n+static void *state;\n+\n+/* The number of failures.  */\n+\n+static int failures;\n+\n+/* Return the base name in a path.  */\n+\n+static const char *\n+base (const char *p)\n+{\n+  const char *last;\n+  const char *s;\n+\n+  last = NULL;\n+  for (s = p; *s != '\\0'; ++s)\n+    {\n+      if (IS_DIR_SEPARATOR (*s))\n+\tlast = s + 1;\n+    }\n+  return last != NULL ? last : p;\n+}\n+\n+/* Check an entry in a struct info array.  */\n+\n+static void\n+check (const char *name, int index, const struct info *all, int want_lineno,\n+       const char *want_function, int *failed)\n+{\n+  if (*failed)\n+    return;\n+  if (strcmp (base (all[index].filename), \"btest.c\") != 0)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %s expected test.c\\n\", name, index,\n+\t       all[index].filename);\n+      *failed = 1;\n+    }\n+  if (all[index].lineno != want_lineno)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %d expected %d\\n\", name, index,\n+\t       all[index].lineno, want_lineno);\n+      *failed = 1;\n+    }\n+  if (strcmp (all[index].function, want_function) != 0)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %s expected %s\\n\", name, index,\n+\t       all[index].function, want_function);\n+      *failed = 1;\n+    }\n+}\n+\n+/* The backtrace callback function.  */\n+\n+static int\n+callback_one (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n+\t      const char *filename, int lineno, const char *function)\n+{\n+  struct bdata *data = (struct bdata *) vdata;\n+  struct info *p;\n+\n+  if (data->index >= data->max)\n+    {\n+      fprintf (stderr, \"callback_one: callback called too many times\\n\");\n+      data->failed = 1;\n+      return 1;\n+    }\n+\n+  p = &data->all[data->index];\n+  if (filename == NULL)\n+    p->filename = NULL;\n+  else\n+    {\n+      p->filename = strdup (filename);\n+      assert (p->filename != NULL);\n+    }\n+  p->lineno = lineno;\n+  if (function == NULL)\n+    p->function = NULL;\n+  else\n+    {\n+      p->function = strdup (function);\n+      assert (p->function != NULL);\n+    }\n+  ++data->index;\n+\n+  return 0;\n+}\n+\n+/* An error callback passed to backtrace.  */\n+\n+static void\n+error_callback_one (void *vdata, const char *msg, int errnum)\n+{\n+  struct bdata *data = (struct bdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* The backtrace_simple callback function.  */\n+\n+static int\n+callback_two (void *vdata, uintptr_t pc)\n+{\n+  struct sdata *data = (struct sdata *) vdata;\n+\n+  if (data->index >= data->max)\n+    {\n+      fprintf (stderr, \"callback_two: callback called too many times\\n\");\n+      data->failed = 1;\n+      return 1;\n+    }\n+\n+  data->addrs[data->index] = pc;\n+  ++data->index;\n+\n+  return 0;\n+}\n+\n+/* An error callback passed to backtrace_simple.  */\n+\n+static void\n+error_callback_two (void *vdata, const char *msg, int errnum)\n+{\n+  struct sdata *data = (struct sdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* The backtrace_syminfo callback function.  */\n+\n+static void\n+callback_three (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n+\t\tconst char *symname, uintptr_t symval)\n+{\n+  struct symdata *data = (struct symdata *) vdata;\n+\n+  if (symname == NULL)\n+    data->name = NULL;\n+  else\n+    {\n+      data->name = strdup (symname);\n+      assert (data->name != NULL);\n+    }\n+  data->val = symval;\n+}\n+\n+/* The backtrace_syminfo error callback function.  */\n+\n+static void\n+error_callback_three (void *vdata, const char *msg, int errnum)\n+{\n+  struct symdata *data = (struct symdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* Test the backtrace function with non-inlined functions.  */\n+\n+static int test1 (void) __attribute__ ((noinline));\n+static int f2 (int) __attribute__ ((noinline));\n+static int f3 (int, int) __attribute__ ((noinline));\n+\n+static int\n+test1 (void)\n+{\n+  /* Returning a value here and elsewhere avoids a tailcall which\n+     would mess up the backtrace.  */\n+  return f2 (__LINE__) + 1;\n+}\n+\n+static int\n+f2 (int f1line)\n+{\n+  return f3 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f3 (int f1line, int f2line)\n+{\n+  struct info all[20];\n+  struct bdata data;\n+  int f3line;\n+  int i;\n+\n+  data.all = &all[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_full (state, 0, callback_one, error_callback_one, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test1: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  check (\"test1\", 0, all, f3line, \"f3\", &data.failed);\n+  check (\"test1\", 1, all, f2line, \"f2\", &data.failed);\n+  check (\"test1\", 2, all, f1line, \"test1\", &data.failed);\n+\n+  printf (\"%s: backtrace_full noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Test the backtrace function with inlined functions.  */\n+\n+static inline int test2 (void) __attribute__ ((always_inline));\n+static inline int f12 (int) __attribute__ ((always_inline));\n+static inline int f13 (int, int) __attribute__ ((always_inline));\n+\n+static inline int\n+test2 (void)\n+{\n+  return f12 (__LINE__) + 1;\n+}\n+\n+static inline int\n+f12 (int f1line)\n+{\n+  return f13 (f1line, __LINE__) + 2;\n+}\n+\n+static inline int\n+f13 (int f1line, int f2line)\n+{\n+  struct info all[20];\n+  struct bdata data;\n+  int f3line;\n+  int i;\n+\n+  data.all = &all[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_full (state, 0, callback_one, error_callback_one, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test2: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  check (\"test2\", 0, all, f3line, \"f13\", &data.failed);\n+  check (\"test2\", 1, all, f2line, \"f12\", &data.failed);\n+  check (\"test2\", 2, all, f1line, \"test2\", &data.failed);\n+\n+  printf (\"%s: backtrace_full inline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Test the backtrace_simple function with non-inlined functions.  */\n+\n+static int test3 (void) __attribute__ ((noinline));\n+static int f22 (int) __attribute__ ((noinline));\n+static int f23 (int, int) __attribute__ ((noinline));\n+\n+static int\n+test3 (void)\n+{\n+  return f22 (__LINE__) + 1;\n+}\n+\n+static int\n+f22 (int f1line)\n+{\n+  return f23 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f23 (int f1line, int f2line)\n+{\n+  uintptr_t addrs[20];\n+  struct sdata data;\n+  int f3line;\n+  int i;\n+\n+  data.addrs = &addrs[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_simple (state, 0, callback_two, error_callback_two, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test3: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (!data.failed)\n+    {\n+      struct info all[20];\n+      struct bdata bdata;\n+      int j;\n+\n+      bdata.all = &all[0];\n+      bdata.index = 0;\n+      bdata.max = 20;\n+      bdata.failed = 0;\n+\n+      for (j = 0; j < 3; ++j)\n+\t{\n+\t  i = backtrace_pcinfo (state, addrs[j], callback_one,\n+\t\t\t\terror_callback_one, &bdata);\n+\t  if (i != 0)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"test3: unexpected return value \"\n+\t\t\t\"from backtrace_pcinfo %d\\n\"),\n+\t\t       i);\n+\t      bdata.failed = 1;\n+\t    }\n+\t  if (!bdata.failed && bdata.index != (size_t) (j + 1))\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"wrong number of calls from backtrace_pcinfo \"\n+\t\t\t\"got %u expected %d\\n\"),\n+\t\t       (unsigned int) bdata.index, j + 1);\n+\t      bdata.failed = 1;\n+\t    }\n+\t}      \n+\n+      check (\"test3\", 0, all, f3line, \"f23\", &bdata.failed);\n+      check (\"test3\", 1, all, f2line, \"f22\", &bdata.failed);\n+      check (\"test3\", 2, all, f1line, \"test3\", &bdata.failed);\n+\n+      if (bdata.failed)\n+\tdata.failed = 1;\n+\n+      for (j = 0; j < 3; ++j)\n+\t{\n+\t  struct symdata symdata;\n+\n+\t  symdata.name = NULL;\n+\t  symdata.val = 0;\n+\t  symdata.failed = 0;\n+\n+\t  i = backtrace_syminfo (state, addrs[j], callback_three,\n+\t\t\t\t error_callback_three, &symdata);\n+\t  if (i == 0)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"test3: [%d]: unexpected return value \"\n+\t\t\t\"from backtrace_syminfo %d\\n\"),\n+\t\t       j, i);\n+\t      symdata.failed = 1;\n+\t    }\n+\n+\t  if (!symdata.failed)\n+\t    {\n+\t      const char *expected;\n+\n+\t      switch (j)\n+\t\t{\n+\t\tcase 0:\n+\t\t  expected = \"f23\";\n+\t\t  break;\n+\t\tcase 1:\n+\t\t  expected = \"f22\";\n+\t\t  break;\n+\t\tcase 2:\n+\t\t  expected = \"test3\";\n+\t\t  break;\n+\t\tcase 3:\n+\t\t  assert (0);\n+\t\t}\n+\n+\t      if (symdata.name == NULL)\n+\t\t{\n+\t\t  fprintf (stderr, \"test3: [%d]: NULL syminfo name\\n\", j);\n+\t\t  symdata.failed = 1;\n+\t\t}\n+\t      /* Use strncmp, not strcmp, because GCC might create a\n+\t\t clone.  */\n+\t      else if (strncmp (symdata.name, expected, strlen (expected))\n+\t\t       != 0)\n+\t\t{\n+\t\t  fprintf (stderr,\n+\t\t\t   (\"test3: [%d]: unexpected syminfo name \"\n+\t\t\t    \"got %s expected %s\\n\"),\n+\t\t\t   j, symdata.name, expected);\n+\t\t  symdata.failed = 1;\n+\t\t}\n+\t    }\n+\n+\t  if (symdata.failed)\n+\t    data.failed = 1;\n+\t}\n+    }\n+\n+  printf (\"%s: backtrace_simple noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Test the backtrace_simple function with inlined functions.  */\n+\n+static inline int test4 (void) __attribute__ ((always_inline));\n+static inline int f32 (int) __attribute__ ((always_inline));\n+static inline int f33 (int, int) __attribute__ ((always_inline));\n+\n+static inline int\n+test4 (void)\n+{\n+  return f32 (__LINE__) + 1;\n+}\n+\n+static inline int\n+f32 (int f1line)\n+{\n+  return f33 (f1line, __LINE__) + 2;\n+}\n+\n+static inline int\n+f33 (int f1line, int f2line)\n+{\n+  uintptr_t addrs[20];\n+  struct sdata data;\n+  int f3line;\n+  int i;\n+\n+  data.addrs = &addrs[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_simple (state, 0, callback_two, error_callback_two, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test3: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (!data.failed)\n+    {\n+      struct info all[20];\n+      struct bdata bdata;\n+\n+      bdata.all = &all[0];\n+      bdata.index = 0;\n+      bdata.max = 20;\n+      bdata.failed = 0;\n+\n+      i = backtrace_pcinfo (state, addrs[0], callback_one, error_callback_one,\n+\t\t\t    &bdata);\n+      if (i != 0)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   (\"test4: unexpected return value \"\n+\t\t    \"from backtrace_pcinfo %d\\n\"),\n+\t\t   i);\n+\t  bdata.failed = 1;\n+\t}\n+\n+      check (\"test4\", 0, all, f3line, \"f33\", &bdata.failed);\n+      check (\"test4\", 1, all, f2line, \"f32\", &bdata.failed);\n+      check (\"test4\", 2, all, f1line, \"test4\", &bdata.failed);\n+\n+      if (bdata.failed)\n+\tdata.failed = 1;\n+    }\n+\n+  printf (\"%s: backtrace_simple inline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+static void\n+error_callback_create (void *data ATTRIBUTE_UNUSED, const char *msg,\n+\t\t       int errnum)\n+{\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  exit (EXIT_FAILURE);\n+}\n+\n+/* Run all the tests.  */\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+#if BACKTRACE_SUPPORTED\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+#endif\n+\n+  exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"}, {"sha": "c7b534b3e69e96c992e50db7cde7e4090c55cdd6", "filename": "libbacktrace/config.h.in", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfig.h.in?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,68 @@\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* ELF size: 32 or 64 */\n+#undef BACKTRACE_ELF_SIZE\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* Define if _Unwind_GetIPInfo is available. */\n+#undef HAVE_GETIPINFO\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if you have the __sync functions */\n+#undef HAVE_SYNC_FUNCTIONS\n+\n+/* Define to 1 if you have the <sys/mman.h> header file. */\n+#undef HAVE_SYS_MMAN_H\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS"}, {"sha": "d566922a95c893308d9879e25095d7755313585a", "filename": "libbacktrace/configure", "status": "added", "additions": 13507, "deletions": 0, "changes": 13507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=eff02e4f8421170b613b80e266b5b1893c588ea6"}, {"sha": "7a44fdfc7a84398c4222352fdf298b20f73eb936", "filename": "libbacktrace/configure.ac", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,253 @@\n+# configure.ac -- Backtrace configure script.\n+# Copyright (C) 2012 Free Software Foundation, Inc.\n+\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are\n+# met:\n+\n+#     (1) Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer. \n+\n+#     (2) Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in\n+#     the documentation and/or other materials provided with the\n+#     distribution.  \n+    \n+#     (3) The name of the author may not be used to\n+#     endorse or promote products derived from this software without\n+#     specific prior written permission.\n+\n+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+\n+AC_PREREQ(2.64)\n+AC_INIT(package-unused, version-unused,, libbacktrace)\n+AC_CONFIG_SRCDIR(backtrace.h)\n+AC_CONFIG_HEADER(config.h)\n+\n+AC_CANONICAL_SYSTEM\n+target_alias=${target_alias-$host_alias}\n+\n+libtool_VERSION=1:0:0\n+AC_SUBST(libtool_VERSION)\n+\n+AM_INIT_AUTOMAKE([1.11.1 foreign no-dist no-define -Wall -Wno-portability])\n+\n+AM_MAINTAINER_MODE\n+\n+AC_ARG_WITH(target-subdir,\n+[  --with-target-subdir=SUBDIR      Configuring in a subdirectory for target])\n+\n+# We must force CC to /not/ be precious variables; otherwise\n+# the wrong, non-multilib-adjusted value will be used in multilibs.\n+# As a side effect, we have to subst CFLAGS ourselves.\n+m4_rename([_AC_ARG_VAR_PRECIOUS],[backtrace_PRECIOUS])\n+m4_define([_AC_ARG_VAR_PRECIOUS],[])\n+AC_PROG_CC\n+m4_rename_force([backtrace_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])\n+\n+AC_SUBST(CFLAGS)\n+\n+AC_PROG_RANLIB\n+\n+AC_PROG_AWK\n+case \"$AWK\" in\n+\"\") AC_MSG_ERROR([can't build without awk]) ;;\n+esac\n+\n+LT_INIT([disable-shared])\n+AM_PROG_LIBTOOL\n+\n+backtrace_supported=yes\n+\n+if test -n \"${with_target_subdir}\"; then\n+  # We are compiling a GCC library.  We can assume that the unwind\n+  # library exists.\n+  AM_ENABLE_MULTILIB(, ..)\n+  BACKTRACE_FILE=\"backtrace.lo simple.lo\"\n+else\n+  AC_CHECK_HEADER([unwind.h],\n+    [AC_CHECK_FUNC([_Unwind_Backtrace],\n+\t           [BACKTRACE_FILE=\"backtrace.lo simple.lo\"],\n+\t\t   [BACKTRACE_FILE=\"nounwind.lo\"\n+                    backtrace_supported=no])],\n+    [BACKTRACE_FILE=\"nounwind.lo\"\n+     backtrace_supported=no])\n+fi\n+AC_SUBST(BACKTRACE_FILE)\n+\n+ACX_PROG_CC_WARNING_OPTS([-W -Wall -Wwrite-strings -Wstrict-prototypes \\\n+\t\t\t  -Wmissing-prototypes -Wold-style-definition \\\n+\t\t\t  -Wmissing-format-attribute -Wcast-qual],\n+\t\t\t  [WARN_FLAGS])\n+\n+if test \"x$GCC\" = \"xyes\"; then\n+  WARN_FLAGS=\"$WARN_FLAGS -Werror\"\n+fi\n+\n+AC_SUBST(WARN_FLAGS)\n+\n+GCC_CHECK_UNWIND_GETIPINFO\n+\n+# When building as a target library, shared libraries may want to link\n+# this in.  We don't want to provide another shared library to\n+# complicate dependencies.  Instead, we just compile with -fPIC.\n+PIC_FLAG=\n+if test -n \"${with_target_subdir}\"; then\n+  PIC_FLAG=-fPIC\n+fi\n+AC_SUBST(PIC_FLAG)\n+\n+# Test for __sync support.\n+AC_CACHE_CHECK([__sync extensions],\n+[libbacktrace_cv_sys_sync],\n+[if test -n \"${with_target_subdir}\"; then\n+   libbacktrace_cv_sys_sync=yes\n+ else\n+   AC_LINK_IFELSE(\n+     [AC_LANG_PROGRAM([int i;],\n+                      [__sync_bool_compare_and_swap (&i, i, i);\n+                       __sync_lock_test_and_set (&i, 1);\n+                       __sync_lock_release (&i);])],\n+     [libbacktrace_cv_sys_sync=yes],\n+     [libbacktrace_cv_sys_sync=no])\n+ fi])\n+BACKTRACE_SUPPORTS_THREADS=0\n+if test \"$libbacktrace_cv_sys_sync\" = \"yes\"; then\n+  BACKTRACE_SUPPORTS_THREADS=1\n+  AC_DEFINE([HAVE_SYNC_FUNCTIONS], 1,\n+\t    [Define to 1 if you have the __sync functions])\n+fi\n+AC_SUBST(BACKTRACE_SUPPORTS_THREADS)\n+\n+# The library needs to be able to read the executable itself.  Compile\n+# a file to determine the executable format.  The awk script\n+# filetype.awk prints out the file type.\n+AC_CACHE_CHECK([output filetype],\n+[libbacktrace_cv_sys_filetype],\n+[filetype=\n+AC_COMPILE_IFELSE(\n+  [AC_LANG_PROGRAM([int i;], [int j;])],\n+  [filetype=`${AWK} -f $srcdir/filetype.awk conftest.$ac_objext`],\n+  [AC_MSG_FAILURE([compiler failed])])\n+libbacktrace_cv_sys_filetype=$filetype])\n+\n+# Match the file type to decide what files to compile.\n+FORMAT_FILE=\n+case \"$libbacktrace_cv_sys_filetype\" in\n+elf*) FORMAT_FILE=\"elf.lo\" ;;\n+*) AC_MSG_WARN([could not determine output file type])\n+   FORMAT_FILE=\"unknown.lo\"\n+   backtrace_supported=no\n+   ;;\n+esac\n+AC_SUBST(FORMAT_FILE)\n+\n+# ELF defines.\n+elfsize=\n+case \"$libbacktrace_cv_sys_filetype\" in\n+elf32) elfsize=32 ;;\n+elf64) elfsize=64 ;;\n+esac\n+AC_DEFINE_UNQUOTED([BACKTRACE_ELF_SIZE], [$elfsize], [ELF size: 32 or 64])\n+\n+BACKTRACE_SUPPORTED=0\n+if test \"$backtrace_supported\" = \"yes\"; then\n+  BACKTRACE_SUPPORTED=1\n+fi\n+AC_SUBST(BACKTRACE_SUPPORTED)\n+\n+AC_CHECK_HEADERS(sys/mman.h)\n+if test \"$ac_cv_header_sys_mman_h\" = \"no\"; then\n+  have_mmap=no\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+    # When built as a GCC target library, we can't do a link test.  We\n+    # simply assume that if we have mman.h, we have mmap.\n+    have_mmap=yes\n+  else\n+    AC_CHECK_FUNC(mmap, [have_mmap=yes], [have_mmap=no])\n+  fi\n+fi\n+if test \"$have_mmap\" = \"no\"; then\n+  VIEW_FILE=read.lo\n+  ALLOC_FILE=alloc.lo\n+else\n+  VIEW_FILE=mmapio.lo\n+  AC_PREPROC_IFELSE([\n+#include <sys/mman.h>\n+#if !defined(MAP_ANONYMOUS) && !defined(MAP_ANON)\n+  #error no MAP_ANONYMOUS\n+#endif\n+], [ALLOC_FILE=mmap.lo], [ALLOC_FILE=alloc.lo])\n+fi\n+AC_SUBST(VIEW_FILE)\n+AC_SUBST(ALLOC_FILE)\n+\n+BACKTRACE_USES_MALLOC=0\n+if test \"$ALLOC_FILE\" = \"alloc.lo\"; then\n+  BACKTRACE_USES_MALLOC=1\n+fi\n+AC_SUBST(BACKTRACE_USES_MALLOC)\n+\n+AC_CACHE_CHECK([whether tests can run],\n+  [libbacktrace_cv_sys_native],\n+  [AC_RUN_IFELSE([AC_LANG_PROGRAM([], [return 0;])],\n+     [libbacktrace_cv_sys_native=yes],\n+     [libbacktrace_cv_sys_native=no],\n+     [libbacktrace_cv_sys_native=no])])\n+AM_CONDITIONAL(NATIVE, test \"$libbacktrace_cv_sys_native\" = \"yes\")\n+\n+if test \"${multilib}\" = \"yes\"; then\n+  multilib_arg=\"--enable-multilib\"\n+else\n+  multilib_arg=\n+fi\n+\n+AC_CONFIG_FILES(Makefile backtrace-supported.h)\n+\n+# We need multilib support, but only if configuring for the target.\n+AC_CONFIG_COMMANDS([default],\n+[if test -n \"$CONFIG_FILES\"; then\n+   if test -n \"${with_target_subdir}\"; then\n+     # Multilibs need MULTISUBDIR defined correctly in certain makefiles so\n+     # that multilib installs will end up installed in the correct place.\n+     # The testsuite needs it for multilib-aware ABI baseline files.\n+     # To work around this not being passed down from config-ml.in ->\n+     # srcdir/Makefile.am -> srcdir/{src,libsupc++,...}/Makefile.am, manually\n+     # append it here.  Only modify Makefiles that have just been created.\n+     #\n+     # Also, get rid of this simulated-VPATH thing that automake does.\n+     cat > vpsed << \\_EOF\n+  s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+     for i in $SUBDIRS; do\n+      case $CONFIG_FILES in\n+       *${i}/Makefile*)\n+\t #echo \"Adding MULTISUBDIR to $i/Makefile\"\n+\t sed -f vpsed $i/Makefile > tmp\n+\t grep '^MULTISUBDIR =' Makefile >> tmp\n+\t mv tmp $i/Makefile\n+\t ;;\n+      esac\n+     done\n+     rm vpsed\n+   fi\n+ fi\n+],\n+[\n+# Variables needed in config.status (file generation) which aren't already\n+# passed by autoconf.\n+SUBDIRS=\"$SUBDIRS\"\n+])\n+\n+AC_OUTPUT"}, {"sha": "dffd20bb15420e257bf4a522d724d394f3527b61", "filename": "libbacktrace/dwarf.c", "status": "added", "additions": 2742, "deletions": 0, "changes": 2742, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,2742 @@\n+/* dwarf.c -- Get file/line information from DWARF for backtraces.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"dwarf2.h\"\n+#include \"filenames.h\"\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* A buffer to read DWARF info.  */\n+\n+struct dwarf_buf\n+{\n+  /* Buffer name for error messages.  */\n+  const char *name;\n+  /* Start of the buffer.  */\n+  const unsigned char *start;\n+  /* Next byte to read.  */\n+  const unsigned char *buf;\n+  /* The number of bytes remaining.  */\n+  size_t left;\n+  /* Whether the data is big-endian.  */\n+  int is_bigendian;\n+  /* Error callback routine.  */\n+  backtrace_error_callback error_callback;\n+  /* Data for error_callback.  */\n+  void *data;\n+  /* Non-zero if we've reported an underflow error.  */\n+  int reported_underflow;\n+};\n+\n+/* A single attribute in a DWARF abbreviation.  */\n+\n+struct attr\n+{\n+  /* The attribute name.  */\n+  enum dwarf_attribute name;\n+  /* The attribute form.  */\n+  enum dwarf_form form;\n+};\n+\n+/* A single DWARF abbreviation.  */\n+\n+struct abbrev\n+{\n+  /* The abbrev code--the number used to refer to the abbrev.  */\n+  uint64_t code;\n+  /* The entry tag.  */\n+  enum dwarf_tag tag;\n+  /* Non-zero if this abbrev has child entries.  */\n+  int has_children;\n+  /* The number of attributes.  */\n+  size_t num_attrs;\n+  /* The attributes.  */\n+  struct attr *attrs;\n+};\n+\n+/* The DWARF abbreviations for a compilation unit.  This structure\n+   only exists while reading the compilation unit.  Most DWARF readers\n+   seem to a hash table to map abbrev ID's to abbrev entries.\n+   However, we primarily care about GCC, and GCC simply issues ID's in\n+   numerical order starting at 1.  So we simply keep a sorted vector,\n+   and try to just look up the code.  */\n+\n+struct abbrevs\n+{\n+  /* The number of abbrevs in the vector.  */\n+  size_t num_abbrevs;\n+  /* The abbrevs, sorted by the code field.  */\n+  struct abbrev *abbrevs;\n+};\n+\n+/* The different kinds of attribute values.  */\n+\n+enum attr_val_encoding\n+{\n+  /* An address.  */\n+  ATTR_VAL_ADDRESS,\n+  /* A unsigned integer.  */\n+  ATTR_VAL_UINT,\n+  /* A sigd integer.  */\n+  ATTR_VAL_SINT,\n+  /* A string.  */\n+  ATTR_VAL_STRING,\n+  /* An offset to other data in the containing unit.  */\n+  ATTR_VAL_REF_UNIT,\n+  /* An offset to other data within the .dwarf_info section.  */\n+  ATTR_VAL_REF_INFO,\n+  /* An offset to data in some other section.  */\n+  ATTR_VAL_REF_SECTION,\n+  /* A type signature.  */\n+  ATTR_VAL_REF_TYPE,\n+  /* A block of data (not represented).  */\n+  ATTR_VAL_BLOCK,\n+  /* An expression (not represented).  */\n+  ATTR_VAL_EXPR,\n+};\n+\n+/* An attribute value.  */\n+\n+struct attr_val\n+{\n+  /* How the value is stored in the field u.  */\n+  enum attr_val_encoding encoding;\n+  union\n+  {\n+    /* ATTR_VAL_ADDRESS, ATTR_VAL_UINT, ATTR_VAL_REF*.  */\n+    uint64_t uint;\n+    /* ATTR_VAL_SINT.  */\n+    int64_t sint;\n+    /* ATTR_VAL_STRING.  */\n+    const char *string;\n+    /* ATTR_VAL_BLOCK not stored.  */\n+  } u;\n+};\n+\n+/* The line number program header.  */\n+\n+struct line_header\n+{\n+  /* The version of the line number information.  */\n+  int version;\n+  /* The minimum instruction length.  */\n+  unsigned int min_insn_len;\n+  /* The maximum number of ops per instruction.  */\n+  unsigned int max_ops_per_insn;\n+  /* The line base for special opcodes.  */\n+  int line_base;\n+  /* The line range for special opcodes.  */\n+  unsigned int line_range;\n+  /* The opcode base--the first special opcode.  */\n+  unsigned int opcode_base;\n+  /* Opcode lengths, indexed by opcode - 1.  */\n+  const unsigned char *opcode_lengths;\n+  /* The number of directory entries.  */\n+  size_t dirs_count;\n+  /* The directory entries.  */\n+  const char **dirs;\n+  /* The number of filenames.  */\n+  size_t filenames_count;\n+  /* The filenames.  */\n+  const char **filenames;\n+};\n+\n+/* Map a single PC value to a file/line.  We will keep a vector of\n+   these sorted by PC value.  Each file/line will be correct from the\n+   PC up to the PC of the next entry if there is one.  We allocate one\n+   extra entry at the end so that we can use bsearch.  */\n+\n+struct line\n+{\n+  /* PC.  */\n+  uintptr_t pc;\n+  /* File name.  Many entries in the array are expected to point to\n+     the same file name.  */\n+  const char *filename;\n+  /* Line number.  */\n+  int lineno;\n+};\n+\n+/* A growable vector of line number information.  This is used while\n+   reading the line numbers.  */\n+\n+struct line_vector\n+{\n+  /* Memory.  This is an array of struct line.  */\n+  struct backtrace_vector vec;\n+  /* Number of valid mappings.  */\n+  size_t count;\n+};\n+\n+/* A function described in the debug info.  */\n+\n+struct function\n+{\n+  /* The name of the function.  */\n+  const char *name;\n+  /* If this is an inlined function, the filename of the call\n+     site.  */\n+  const char *caller_filename;\n+  /* If this is an inlined function, the line number of the call\n+     site.  */\n+  int caller_lineno;\n+  /* Map PC ranges to inlined functions.  */\n+  struct function_addrs *function_addrs;\n+  size_t function_addrs_count;\n+};\n+\n+/* An address range for a function.  This maps a PC value to a\n+   specific function.  */\n+\n+struct function_addrs\n+{\n+  /* Range is LOW <= PC < HIGH.  */\n+  uint64_t low;\n+  uint64_t high;\n+  /* Function for this address range.  */\n+  struct function *function;\n+};\n+\n+/* A growable vector of function address ranges.  */\n+\n+struct function_vector\n+{\n+  /* Memory.  This is an array of struct function_addrs.  */\n+  struct backtrace_vector vec;\n+  /* Number of address ranges present.  */\n+  size_t count;\n+};\n+\n+/* A DWARF compilation unit.  This only holds the information we need\n+   to map a PC to a file and line.  */\n+\n+struct unit\n+{\n+  /* The first entry for this compilation unit.  */\n+  const unsigned char *unit_data;\n+  /* The length of the data for this compilation unit.  */\n+  size_t unit_data_len;\n+  /* The offset of UNIT_DATA from the start of the information for\n+     this compilation unit.  */\n+  size_t unit_data_offset;\n+  /* DWARF version.  */\n+  int version;\n+  /* Whether unit is DWARF64.  */\n+  int is_dwarf64;\n+  /* Address size.  */\n+  int addrsize;\n+  /* Offset into line number information.  */\n+  off_t lineoff;\n+  /* Compilation command working directory.  */\n+  const char *comp_dir;\n+  /* The abbreviations for this unit.  */\n+  struct abbrevs abbrevs;\n+\n+  /* The fields above this point are read in during initialization and\n+     may be accessed freely.  The fields below this point are read in\n+     as needed, and therefore require care, as different threads may\n+     try to initialize them simultaneously.  */\n+\n+  /* PC to line number mapping.  This is NULL if the values have not\n+     been read.  This is (struct line *) -1 if there was an error\n+     reading the values.  */\n+  struct line *lines;\n+  /* Number of entries in lines.  */\n+  size_t lines_count;\n+  /* PC ranges to function.  */\n+  struct function_addrs *function_addrs;\n+  size_t function_addrs_count;\n+};\n+\n+/* An address range for a compilation unit.  This maps a PC value to a\n+   specific compilation unit.  Note that we invert the representation\n+   in DWARF: instead of listing the units and attaching a list of\n+   ranges, we list the ranges and have each one point to the unit.\n+   This lets us do a binary search to find the unit.  */\n+\n+struct unit_addrs\n+{\n+  /* Range is LOW <= PC < HIGH.  */\n+  uint64_t low;\n+  uint64_t high;\n+  /* Compilation unit for this address range.  */\n+  struct unit *u;\n+};\n+\n+/* A growable vector of compilation unit address ranges.  */\n+\n+struct unit_addrs_vector\n+{\n+  /* Memory.  This is an array of struct unit_addrs.  */\n+  struct backtrace_vector vec;\n+  /* Number of address ranges present.  */\n+  size_t count;\n+};\n+\n+/* The information we need to map a PC to a file and line.  */\n+\n+struct dwarf_data\n+{\n+  /* A sorted list of address ranges.  */\n+  struct unit_addrs *addrs;\n+  /* Number of address ranges in list.  */\n+  size_t addrs_count;\n+  /* The unparsed .debug_info section.  */\n+  const unsigned char *dwarf_info;\n+  size_t dwarf_info_size;\n+  /* The unparsed .debug_line section.  */\n+  const unsigned char *dwarf_line;\n+  size_t dwarf_line_size;\n+  /* The unparsed .debug_ranges section.  */\n+  const unsigned char *dwarf_ranges;\n+  size_t dwarf_ranges_size;\n+  /* The unparsed .debug_str section.  */\n+  const unsigned char *dwarf_str;\n+  size_t dwarf_str_size;\n+  /* Whether the data is big-endian or not.  */\n+  int is_bigendian;\n+  /* A vector used for function addresses.  We keep this here so that\n+     we can grow the vector as we read more functions.  */\n+  struct function_vector fvec;\n+};\n+\n+/* Report an error for a DWARF buffer.  */\n+\n+static void\n+dwarf_buf_error (struct dwarf_buf *buf, const char *msg)\n+{\n+  char b[200];\n+\n+  snprintf (b, sizeof b, \"%s in %s at %d\",\n+\t    msg, buf->name, (int) (buf->buf - buf->start));\n+  buf->error_callback (buf->data, b, 0);\n+}\n+\n+/* Require at least COUNT bytes in BUF.  Return 1 if all is well, 0 on\n+   error.  */\n+\n+static int\n+require (struct dwarf_buf *buf, size_t count)\n+{\n+  if (buf->left >= count)\n+    return 1;\n+\n+  if (!buf->reported_underflow)\n+    {\n+      dwarf_buf_error (buf, \"DWARF underflow\");\n+      buf->reported_underflow = 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Advance COUNT bytes in BUF.  Return 1 if all is well, 0 on\n+   error.  */\n+\n+static int\n+advance (struct dwarf_buf *buf, size_t count)\n+{\n+  if (!require (buf, count))\n+    return 0;\n+  buf->buf += count;\n+  buf->left -= count;\n+  return 1;\n+}\n+\n+/* Read one byte from BUF and advance 1 byte.  */\n+\n+static unsigned char\n+read_byte (struct dwarf_buf *buf)\n+{\n+  const unsigned char *p = buf->buf;\n+\n+  if (!advance (buf, 1))\n+    return 0;\n+  return p[0];\n+}\n+\n+/* Read a signed char from BUF and advance 1 byte.  */\n+\n+static signed char\n+read_sbyte (struct dwarf_buf *buf)\n+{\n+  const unsigned char *p = buf->buf;\n+\n+  if (!advance (buf, 1))\n+    return 0;\n+  return (*p ^ 0x80) - 0x80;\n+}\n+\n+/* Read a uint16 from BUF and advance 2 bytes.  */\n+\n+static uint16_t\n+read_uint16 (struct dwarf_buf *buf)\n+{\n+  const unsigned char *p = buf->buf;\n+\n+  if (!advance (buf, 2))\n+    return 0;\n+  if (buf->is_bigendian)\n+    return ((uint16_t) p[0] << 8) | (uint16_t) p[1];\n+  else\n+    return ((uint16_t) p[1] << 8) | (uint16_t) p[0];\n+}\n+\n+/* Read a uint32 from BUF and advance 4 bytes.  */\n+\n+static uint32_t\n+read_uint32 (struct dwarf_buf *buf)\n+{\n+  const unsigned char *p = buf->buf;\n+\n+  if (!advance (buf, 4))\n+    return 0;\n+  if (buf->is_bigendian)\n+    return (((uint32_t) p[0] << 24) | ((uint32_t) p[1] << 16)\n+\t    | ((uint32_t) p[2] << 8) | (uint32_t) p[3]);\n+  else\n+    return (((uint32_t) p[3] << 24) | ((uint32_t) p[2] << 16)\n+\t    | ((uint32_t) p[1] << 8) | (uint32_t) p[0]);\n+}\n+\n+/* Read a uint64 from BUF and advance 8 bytes.  */\n+\n+static uint64_t\n+read_uint64 (struct dwarf_buf *buf)\n+{\n+  const unsigned char *p = buf->buf;\n+\n+  if (!advance (buf, 8))\n+    return 0;\n+  if (buf->is_bigendian)\n+    return (((uint64_t) p[0] << 56) | ((uint64_t) p[1] << 48)\n+\t    | ((uint64_t) p[2] << 40) | ((uint64_t) p[3] << 32)\n+\t    | ((uint64_t) p[4] << 24) | ((uint64_t) p[5] << 16)\n+\t    | ((uint64_t) p[6] << 8) | (uint64_t) p[7]);\n+  else\n+    return (((uint64_t) p[7] << 56) | ((uint64_t) p[6] << 48)\n+\t    | ((uint64_t) p[5] << 40) | ((uint64_t) p[4] << 32)\n+\t    | ((uint64_t) p[3] << 24) | ((uint64_t) p[2] << 16)\n+\t    | ((uint64_t) p[1] << 8) | (uint64_t) p[0]);\n+}\n+\n+/* Read an offset from BUF and advance the appropriate number of\n+   bytes.  */\n+\n+static uint64_t\n+read_offset (struct dwarf_buf *buf, int is_dwarf64)\n+{\n+  if (is_dwarf64)\n+    return read_uint64 (buf);\n+  else\n+    return read_uint32 (buf);\n+}\n+\n+/* Read an address from BUF and advance the appropriate number of\n+   bytes.  */\n+\n+static uint64_t\n+read_address (struct dwarf_buf *buf, int addrsize)\n+{\n+  switch (addrsize)\n+    {\n+    case 1:\n+      return read_byte (buf);\n+    case 2:\n+      return read_uint16 (buf);\n+    case 4:\n+      return read_uint32 (buf);\n+    case 8:\n+      return read_uint64 (buf);\n+    default:\n+      dwarf_buf_error (buf, \"unrecognized address size\");\n+      return 0;\n+    }\n+}\n+\n+/* Return whether a value is the highest possible address, given the\n+   address size.  */\n+\n+static int\n+is_highest_address (uint64_t address, int addrsize)\n+{\n+  switch (addrsize)\n+    {\n+    case 1:\n+      return address == (unsigned char) -1;\n+    case 2:\n+      return address == (uint16_t) -1;\n+    case 4:\n+      return address == (uint32_t) -1;\n+    case 8:\n+      return address == (uint64_t) -1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Read an unsigned LEB128 number.  */\n+\n+static uint64_t\n+read_uleb128 (struct dwarf_buf *buf)\n+{\n+  uint64_t ret;\n+  unsigned int shift;\n+  unsigned char b;\n+\n+  ret = 0;\n+  shift = 0;\n+  do\n+    {\n+      const unsigned char *p;\n+\n+      p = buf->buf;\n+      if (!advance (buf, 1))\n+\treturn 0;\n+      b = *p;\n+      ret |= ((uint64_t) (b & 0x7f)) << shift;\n+      shift += 7;\n+    }\n+  while ((b & 0x80) != 0);\n+\n+  if (shift > 64)\n+    dwarf_buf_error (buf, \"LEB128 overflows uint64_5\");\n+\n+  return ret;\n+}\n+\n+/* Read a signed LEB128 number.  */\n+\n+static int64_t\n+read_sleb128 (struct dwarf_buf *buf)\n+{\n+  uint64_t val;\n+  unsigned int shift;\n+  unsigned char b;\n+\n+  val = 0;\n+  shift = 0;\n+  do\n+    {\n+      const unsigned char *p;\n+\n+      p = buf->buf;\n+      if (!advance (buf, 1))\n+\treturn 0;\n+      b = *p;\n+      val |= ((uint64_t) (b & 0x7f)) << shift;\n+      shift += 7;\n+    }\n+  while ((b & 0x80) != 0);\n+\n+  if (shift > 64)\n+    dwarf_buf_error (buf, \"signed LEB128 overflows uint64_t\");\n+\n+  if ((b & 0x40) != 0)\n+    val |= ((uint64_t) -1) << shift;\n+\n+  return (int64_t) val;\n+}\n+\n+/* Return the length of an LEB128 number.  */\n+\n+static size_t\n+leb128_len (const unsigned char *p)\n+{\n+  size_t ret;\n+\n+  ret = 1;\n+  while ((*p & 0x80) != 0)\n+    {\n+      ++p;\n+      ++ret;\n+    }\n+  return ret;\n+}\n+\n+/* Free an abbreviations structure.  */\n+\n+static void\n+free_abbrevs (struct backtrace_state *state, struct abbrevs *abbrevs,\n+\t      backtrace_error_callback error_callback, void *data)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < abbrevs->num_abbrevs; ++i)\n+    backtrace_free (state, abbrevs->abbrevs[i].attrs,\n+\t\t    abbrevs->abbrevs[i].num_attrs * sizeof (struct attr),\n+\t\t    error_callback, data);\n+  backtrace_free (state, abbrevs->abbrevs,\n+\t\t  abbrevs->num_abbrevs * sizeof (struct abbrev),\n+\t\t  error_callback, data);\n+  abbrevs->num_abbrevs = 0;\n+  abbrevs->abbrevs = NULL;\n+}\n+\n+/* Read an attribute value.  Returns 1 on success, 0 on failure.  If\n+   the value can be represented as a uint64_t, sets *VAL and sets\n+   *IS_VALID to 1.  We don't try to store the value of other attribute\n+   forms, because we don't care about them.  */\n+\n+static int\n+read_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n+\t\tint is_dwarf64, int version, int addrsize,\n+\t\tconst unsigned char *dwarf_str, size_t dwarf_str_size,\n+\t\tstruct attr_val *val)\n+{\n+  switch (form)\n+    {\n+    case DW_FORM_addr:\n+      val->encoding = ATTR_VAL_ADDRESS;\n+      val->u.uint = read_address (buf, addrsize);\n+      return 1;\n+    case DW_FORM_block2:\n+      val->encoding = ATTR_VAL_BLOCK;\n+      return advance (buf, read_uint16 (buf));\n+    case DW_FORM_block4:\n+      val->encoding = ATTR_VAL_BLOCK;\n+      return advance (buf, read_uint32 (buf));\n+    case DW_FORM_data2:\n+      val->encoding = ATTR_VAL_UINT;\n+      val->u.uint = read_uint16 (buf);\n+      return 1;\n+    case DW_FORM_data4:\n+      val->encoding = ATTR_VAL_UINT;\n+      val->u.uint = read_uint32 (buf);\n+      return 1;\n+    case DW_FORM_data8:\n+      val->encoding = ATTR_VAL_UINT;\n+      val->u.uint = read_uint64 (buf);\n+      return 1;\n+    case DW_FORM_string:\n+      val->encoding = ATTR_VAL_STRING;\n+      val->u.string = (const char *) buf->buf;\n+      return advance (buf, strnlen ((const char *) buf->buf, buf->left) + 1);\n+    case DW_FORM_block:\n+      val->encoding = ATTR_VAL_BLOCK;\n+      return advance (buf, read_uleb128 (buf));\n+    case DW_FORM_block1:\n+      val->encoding = ATTR_VAL_BLOCK;\n+      return advance (buf, read_byte (buf));\n+    case DW_FORM_data1:\n+      val->encoding = ATTR_VAL_UINT;\n+      val->u.uint = read_byte (buf);\n+      return 1;\n+    case DW_FORM_flag:\n+      val->encoding = ATTR_VAL_UINT;\n+      val->u.uint = read_byte (buf);\n+      return 1;\n+    case DW_FORM_sdata:\n+      val->encoding = ATTR_VAL_SINT;\n+      val->u.sint = read_sleb128 (buf);\n+      return 1;\n+    case DW_FORM_strp:\n+      {\n+\tuint64_t offset;\n+\n+\toffset = read_offset (buf, is_dwarf64);\n+\tif (offset >= dwarf_str_size)\n+\t  {\n+\t    dwarf_buf_error (buf, \"DW_FORM_strp out of range\");\n+\t    return 0;\n+\t  }\n+\tval->encoding = ATTR_VAL_STRING;\n+\tval->u.string = (const char *) dwarf_str + offset;\n+\treturn 1;\n+      }\n+    case DW_FORM_udata:\n+      val->encoding = ATTR_VAL_UINT;\n+      val->u.uint = read_uleb128 (buf);\n+      return 1;\n+    case DW_FORM_ref_addr:\n+      val->encoding = ATTR_VAL_REF_INFO;\n+      if (version == 2)\n+\tval->u.uint = read_address (buf, addrsize);\n+      else\n+\tval->u.uint = read_offset (buf, is_dwarf64);\n+      return 1;\n+    case DW_FORM_ref1:\n+      val->encoding = ATTR_VAL_REF_UNIT;\n+      val->u.uint = read_byte (buf);\n+      return 1;\n+    case DW_FORM_ref2:\n+      val->encoding = ATTR_VAL_REF_UNIT;\n+      val->u.uint = read_uint16 (buf);\n+      return 1;\n+    case DW_FORM_ref4:\n+      val->encoding = ATTR_VAL_REF_UNIT;\n+      val->u.uint = read_uint32 (buf);\n+      return 1;\n+    case DW_FORM_ref8:\n+      val->encoding = ATTR_VAL_REF_UNIT;\n+      val->u.uint = read_uint64 (buf);\n+      return 1;\n+    case DW_FORM_ref_udata:\n+      val->encoding = ATTR_VAL_REF_UNIT;\n+      val->u.uint = read_uleb128 (buf);\n+      return 1;\n+    case DW_FORM_indirect:\n+      {\n+\tuint64_t form;\n+\n+\tform = read_uleb128 (buf);\n+\treturn read_attribute ((enum dwarf_form) form, buf, is_dwarf64,\n+\t\t\t       version, addrsize, dwarf_str, dwarf_str_size,\n+\t\t\t       val);\n+      }\n+    case DW_FORM_sec_offset:\n+      val->encoding = ATTR_VAL_REF_SECTION;\n+      val->u.uint = read_offset (buf, is_dwarf64);\n+      return 1;\n+    case DW_FORM_exprloc:\n+      val->encoding = ATTR_VAL_EXPR;\n+      return advance (buf, read_uleb128 (buf));\n+    case DW_FORM_flag_present:\n+      val->encoding = ATTR_VAL_UINT;\n+      val->u.uint = 1;\n+      return 1;\n+    case DW_FORM_ref_sig8:\n+      val->encoding = ATTR_VAL_REF_TYPE;\n+      val->u.uint = read_uint64 (buf);\n+      return 1;\n+    case DW_FORM_GNU_addr_index:\n+      val->encoding = ATTR_VAL_REF_SECTION;\n+      val->u.uint = read_uleb128 (buf);\n+      return 1;\n+    case DW_FORM_GNU_str_index:\n+      val->encoding = ATTR_VAL_REF_SECTION;\n+      val->u.uint = read_uleb128 (buf);\n+      return 1;\n+    case DW_FORM_GNU_ref_alt:\n+      val->encoding = ATTR_VAL_REF_SECTION;\n+      val->u.uint = read_offset (buf, is_dwarf64);\n+      return 1;\n+    case DW_FORM_GNU_strp_alt:\n+      val->encoding = ATTR_VAL_REF_SECTION;\n+      val->u.uint = read_offset (buf, is_dwarf64);\n+      return 1;\n+    default:\n+      dwarf_buf_error (buf, \"unrecognized DWARF form\");\n+      return 0;\n+    }\n+}\n+\n+/* Compare function_addrs for qsort.  When ranges are nested, make the\n+   smallest one sort last.  */\n+\n+static int\n+function_addrs_compare (const void *v1, const void *v2)\n+{\n+  const struct function_addrs *a1 = (const struct function_addrs *) v1;\n+  const struct function_addrs *a2 = (const struct function_addrs *) v2;\n+\n+  if (a1->low < a2->low)\n+    return -1;\n+  if (a1->low > a2->low)\n+    return 1;\n+  if (a1->high < a2->high)\n+    return 1;\n+  if (a1->high > a2->high)\n+    return -1;\n+  return strcmp (a1->function->name, a2->function->name);\n+}\n+\n+/* Compare a PC against a function_addrs for bsearch.  Note that if\n+   there are multiple ranges containing PC, which one will be returned\n+   is unpredictable.  We compensate for that in dwarf_fileline.  */\n+\n+static int\n+function_addrs_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct function_addrs *entry = (const struct function_addrs *) ventry;\n+  uintptr_t pc;\n+\n+  pc = *key;\n+  if (pc < entry->low)\n+    return -1;\n+  else if (pc >= entry->high)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Add a new compilation unit address range to a vector.  Returns 1 on\n+   success, 0 on failure.  */\n+\n+static int\n+add_unit_addr (struct backtrace_state *state, struct unit_addrs addrs,\n+\t       backtrace_error_callback error_callback, void *data,\n+\t       struct unit_addrs_vector *vec)\n+{\n+  struct unit_addrs *p;\n+\n+  /* Try to merge with the last entry.  */\n+  if (vec->count > 0)\n+    {\n+      p = (struct unit_addrs *) vec->vec.base + (vec->count - 1);\n+      if ((addrs.low == p->high || addrs.low == p->high + 1)\n+\t  && addrs.u == p->u)\n+\t{\n+\t  if (addrs.high > p->high)\n+\t    p->high = addrs.high;\n+\t  return 1;\n+\t}\n+    }\n+\n+  p = ((struct unit_addrs *)\n+       backtrace_vector_grow (state, sizeof (struct unit_addrs),\n+\t\t\t      error_callback, data, &vec->vec));\n+  if (p == NULL)\n+    return 0;\n+\n+  *p = addrs;\n+  ++vec->count;\n+  return 1;\n+}\n+\n+/* Free a unit address vector.  */\n+\n+static void\n+free_unit_addrs_vector (struct backtrace_state *state,\n+\t\t\tstruct unit_addrs_vector *vec,\n+\t\t\tbacktrace_error_callback error_callback, void *data)\n+{\n+  struct unit_addrs *addrs;\n+  size_t i;\n+\n+  addrs = (struct unit_addrs *) vec->vec.base;\n+  for (i = 0; i < vec->count; ++i)\n+    free_abbrevs (state, &addrs[i].u->abbrevs, error_callback, data);\n+}\n+\n+/* Compare unit_addrs for qsort.  When ranges are nested, make the\n+   smallest one sort last.  */\n+\n+static int\n+unit_addrs_compare (const void *v1, const void *v2)\n+{\n+  const struct unit_addrs *a1 = (const struct unit_addrs *) v1;\n+  const struct unit_addrs *a2 = (const struct unit_addrs *) v2;\n+\n+  if (a1->low < a2->low)\n+    return -1;\n+  if (a1->low > a2->low)\n+    return 1;\n+  if (a1->high < a2->high)\n+    return 1;\n+  if (a1->high > a2->high)\n+    return -1;\n+  if (a1->u->lineoff < a2->u->lineoff)\n+    return -1;\n+  if (a1->u->lineoff > a2->u->lineoff)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Compare a PC against a unit_addrs for bsearch.  Note that if there\n+   are multiple ranges containing PC, which one will be returned is\n+   unpredictable.  We compensate for that in dwarf_fileline.  */\n+\n+static int\n+unit_addrs_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct unit_addrs *entry = (const struct unit_addrs *) ventry;\n+  uintptr_t pc;\n+\n+  pc = *key;\n+  if (pc < entry->low)\n+    return -1;\n+  else if (pc >= entry->high)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Sort the line vector by PC.  We want a stable sort here.  We know\n+   that the pointers are into the same array, so it is safe to compare\n+   them directly.  */\n+\n+static int\n+line_compare (const void *v1, const void *v2)\n+{\n+  const struct line *ln1 = (const struct line *) v1;\n+  const struct line *ln2 = (const struct line *) v2;\n+\n+  if (ln1->pc < ln2->pc)\n+    return -1;\n+  else if (ln1->pc > ln2->pc)\n+    return 1;\n+  else if (ln1 < ln2)\n+    return -1;\n+  else if (ln1 > ln2)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Find a PC in a line vector.  We always allocate an extra entry at\n+   the end of the lines vector, so that this routine can safely look\n+   at the next entry.  Note that when there are multiple mappings for\n+   the same PC value, this will return the last one.  */\n+\n+static int\n+line_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct line *entry = (const struct line *) ventry;\n+  uintptr_t pc;\n+\n+  pc = *key;\n+  if (pc < entry->pc)\n+    return -1;\n+  else if (pc >= (entry + 1)->pc)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Sort the abbrevs by the abbrev code.  This function is passed to\n+   both qsort and bsearch.  */\n+\n+static int\n+abbrev_compare (const void *v1, const void *v2)\n+{\n+  const struct abbrev *a1 = (const struct abbrev *) v1;\n+  const struct abbrev *a2 = (const struct abbrev *) v2;\n+\n+  if (a1->code < a2->code)\n+    return -1;\n+  else if (a1->code > a2->code)\n+    return 1;\n+  else\n+    {\n+      /* This really shouldn't happen.  It means there are two\n+\t different abbrevs with the same code, and that means we don't\n+\t know which one lookup_abbrev should return.  */\n+      return 0;\n+    }\n+}\n+\n+/* Read the abbreviation table for a compilation unit.  Returns 1 on\n+   success, 0 on failure.  */\n+\n+static int\n+read_abbrevs (struct backtrace_state *state, uint64_t abbrev_offset,\n+\t      const unsigned char *dwarf_abbrev, size_t dwarf_abbrev_size,\n+\t      int is_bigendian, backtrace_error_callback error_callback,\n+\t      void *data, struct abbrevs *abbrevs)\n+{\n+  struct dwarf_buf abbrev_buf;\n+  struct dwarf_buf count_buf;\n+  size_t num_abbrevs;\n+\n+  abbrevs->num_abbrevs = 0;\n+  abbrevs->abbrevs = NULL;\n+\n+  if (abbrev_offset >= dwarf_abbrev_size)\n+    {\n+      error_callback (data, \"abbrev offset out of range\", 0);\n+      return 0;\n+    }\n+\n+  abbrev_buf.name = \".debug_abbrev\";\n+  abbrev_buf.start = dwarf_abbrev;\n+  abbrev_buf.buf = dwarf_abbrev + abbrev_offset;\n+  abbrev_buf.left = dwarf_abbrev_size - abbrev_offset;\n+  abbrev_buf.is_bigendian = is_bigendian;\n+  abbrev_buf.error_callback = error_callback;\n+  abbrev_buf.data = data;\n+  abbrev_buf.reported_underflow = 0;\n+\n+  /* Count the number of abbrevs in this list.  */\n+\n+  count_buf = abbrev_buf;\n+  num_abbrevs = 0;\n+  while (read_uleb128 (&count_buf) != 0)\n+    {\n+      if (count_buf.reported_underflow)\n+\treturn 0;\n+      ++num_abbrevs;\n+      // Skip tag.\n+      read_uleb128 (&count_buf);\n+      // Skip has_children.\n+      read_byte (&count_buf);\n+      // Skip attributes.\n+      while (read_uleb128 (&count_buf) != 0)\n+\tread_uleb128 (&count_buf);\n+      // Skip form of last attribute.\n+      read_uleb128 (&count_buf);\n+    }\n+\n+  if (count_buf.reported_underflow)\n+    return 0;\n+\n+  if (num_abbrevs == 0)\n+    return 1;\n+\n+  abbrevs->num_abbrevs = num_abbrevs;\n+  abbrevs->abbrevs = ((struct abbrev *)\n+\t\t      backtrace_alloc (state,\n+\t\t\t\t       num_abbrevs * sizeof (struct abbrev),\n+\t\t\t\t       error_callback, data));\n+  if (abbrevs->abbrevs == NULL)\n+    return 0;\n+  memset (abbrevs->abbrevs, 0, num_abbrevs * sizeof (struct abbrev));\n+\n+  num_abbrevs = 0;\n+  while (1)\n+    {\n+      uint64_t code;\n+      struct abbrev a;\n+      size_t num_attrs;\n+      struct attr *attrs;\n+\n+      if (abbrev_buf.reported_underflow)\n+\tgoto fail;\n+\n+      code = read_uleb128 (&abbrev_buf);\n+      if (code == 0)\n+\tbreak;\n+\n+      a.code = code;\n+      a.tag = (enum dwarf_tag) read_uleb128 (&abbrev_buf);\n+      a.has_children = read_byte (&abbrev_buf);\n+\n+      count_buf = abbrev_buf;\n+      num_attrs = 0;\n+      while (read_uleb128 (&count_buf) != 0)\n+\t{\n+\t  ++num_attrs;\n+\t  read_uleb128 (&count_buf);\n+\t}\n+\n+      if (num_attrs == 0)\n+\t{\n+\t  attrs = NULL;\n+\t  read_uleb128 (&abbrev_buf);\n+\t  read_uleb128 (&abbrev_buf);\n+\t}\n+      else\n+\t{\n+\t  attrs = ((struct attr *)\n+\t\t   backtrace_alloc (state, num_attrs * sizeof *attrs,\n+\t\t\t\t    error_callback, data));\n+\t  if (attrs == NULL)\n+\t    goto fail;\n+\t  num_attrs = 0;\n+\t  while (1)\n+\t    {\n+\t      uint64_t name;\n+\t      uint64_t form;\n+\n+\t      name = read_uleb128 (&abbrev_buf);\n+\t      form = read_uleb128 (&abbrev_buf);\n+\t      if (name == 0)\n+\t\tbreak;\n+\t      attrs[num_attrs].name = (enum dwarf_attribute) name;\n+\t      attrs[num_attrs].form = (enum dwarf_form) form;\n+\t      ++num_attrs;\n+\t    }\n+\t}\n+\n+      a.num_attrs = num_attrs;\n+      a.attrs = attrs;\n+\n+      abbrevs->abbrevs[num_abbrevs] = a;\n+      ++num_abbrevs;\n+    }\n+\n+  qsort (abbrevs->abbrevs, abbrevs->num_abbrevs, sizeof (struct abbrev),\n+\t abbrev_compare);\n+\n+  return 1;\n+\n+ fail:\n+  free_abbrevs (state, abbrevs, error_callback, data);\n+  return 0;\n+}\n+\n+/* Return the abbrev information for an abbrev code.  */\n+\n+static const struct abbrev *\n+lookup_abbrev (struct abbrevs *abbrevs, uint64_t code,\n+\t       backtrace_error_callback error_callback, void *data)\n+{\n+  struct abbrev key;\n+  void *p;\n+\n+  /* With GCC, where abbrevs are simply numbered in order, we should\n+     be able to just look up the entry.  */\n+  if (code - 1 < abbrevs->num_abbrevs\n+      && abbrevs->abbrevs[code - 1].code == code)\n+    return &abbrevs->abbrevs[code - 1];\n+\n+  /* Otherwise we have to search.  */\n+  memset (&key, 0, sizeof key);\n+  key.code = code;\n+  p = bsearch (&key, abbrevs->abbrevs, abbrevs->num_abbrevs,\n+\t       sizeof (struct abbrev), abbrev_compare);\n+  if (p == NULL)\n+    {\n+      error_callback (data, \"invalid abbreviation code\", 0);\n+      return NULL;\n+    }\n+  return (const struct abbrev *) p;\n+}\n+\n+/* Add non-contiguous address ranges for a compilation unit.  Returns\n+   1 on success, 0 on failure.  */\n+\n+static int\n+add_unit_ranges (struct backtrace_state *state, struct unit *u,\n+\t\t uint64_t ranges, uint64_t base, int is_bigendian,\n+\t\t const unsigned char *dwarf_ranges, size_t dwarf_ranges_size,\n+\t\t backtrace_error_callback error_callback, void *data,\n+\t\t struct unit_addrs_vector *addrs)\n+{\n+  struct dwarf_buf ranges_buf;\n+\n+  if (ranges >= dwarf_ranges_size)\n+    {\n+      error_callback (data, \"ranges offset out of range\", 0);\n+      return 0;\n+    }\n+\n+  ranges_buf.name = \".debug_ranges\";\n+  ranges_buf.start = dwarf_ranges;\n+  ranges_buf.buf = dwarf_ranges + ranges;\n+  ranges_buf.left = dwarf_ranges_size - ranges;\n+  ranges_buf.is_bigendian = is_bigendian;\n+  ranges_buf.error_callback = error_callback;\n+  ranges_buf.data = data;\n+  ranges_buf.reported_underflow = 0;\n+\n+  while (1)\n+    {\n+      uint64_t low;\n+      uint64_t high;\n+\n+      if (ranges_buf.reported_underflow)\n+\treturn 0;\n+\n+      low = read_address (&ranges_buf, u->addrsize);\n+      high = read_address (&ranges_buf, u->addrsize);\n+\n+      if (low == 0 && high == 0)\n+\tbreak;\n+\n+      if (is_highest_address (low, u->addrsize))\n+\tbase = high;\n+      else\n+\t{\n+\t  struct unit_addrs a;\n+\n+\t  a.low = low + base;\n+\t  a.high = high + base;\n+\t  a.u = u;\n+\t  if (!add_unit_addr (state, a, error_callback, data, addrs))\n+\t    return 0;\n+\t}\n+    }\n+\n+  if (ranges_buf.reported_underflow)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Build a mapping from address ranges to the compilation units where\n+   the line number information for that range can be found.  Returns 1\n+   on success, 0 on failure.  */\n+\n+static int\n+build_address_map (struct backtrace_state *state,\n+\t\t   const unsigned char *dwarf_info, size_t dwarf_info_size,\n+\t\t   const unsigned char *dwarf_abbrev, size_t dwarf_abbrev_size,\n+\t\t   const unsigned char *dwarf_ranges, size_t dwarf_ranges_size,\n+\t\t   const unsigned char *dwarf_str, size_t dwarf_str_size,\n+\t\t   int is_bigendian, backtrace_error_callback error_callback,\n+\t\t   void *data, struct unit_addrs_vector *addrs)\n+{\n+  struct dwarf_buf info;\n+  struct abbrevs abbrevs;\n+\n+  memset (&addrs->vec, 0, sizeof addrs->vec);\n+  addrs->count = 0;\n+\n+  /* Read through the .debug_info section.  FIXME: Should we use the\n+     .debug_aranges section?  gdb and addr2line don't use it, but I'm\n+     not sure why.  */\n+\n+  info.name = \".debug_info\";\n+  info.start = dwarf_info;\n+  info.buf = dwarf_info;\n+  info.left = dwarf_info_size;\n+  info.is_bigendian = is_bigendian;\n+  info.error_callback = error_callback;\n+  info.data = data;\n+  info.reported_underflow = 0;\n+\n+  memset (&abbrevs, 0, sizeof abbrevs);\n+  while (info.left > 0)\n+    {\n+      const unsigned char *unit_data_start;\n+      uint64_t len;\n+      int is_dwarf64;\n+      struct dwarf_buf unit_buf;\n+      int version;\n+      uint64_t abbrev_offset;\n+      const struct abbrev *abbrev;\n+      int addrsize;\n+      const unsigned char *unit_data;\n+      size_t unit_data_len;\n+      size_t unit_data_offset;\n+      uint64_t code;\n+      size_t i;\n+      uint64_t lowpc;\n+      int have_lowpc;\n+      uint64_t highpc;\n+      int have_highpc;\n+      int highpc_is_relative;\n+      uint64_t ranges;\n+      int have_ranges;\n+      uint64_t lineoff;\n+      int have_lineoff;\n+      const char *comp_dir;\n+\n+      if (info.reported_underflow)\n+\tgoto fail;\n+\n+      unit_data_start = info.buf;\n+\n+      is_dwarf64 = 0;\n+      len = read_uint32 (&info);\n+      if (len == 0xffffffff)\n+\t{\n+\t  len = read_uint64 (&info);\n+\t  is_dwarf64 = 1;\n+\t}\n+\n+      unit_buf = info;\n+      unit_buf.start = info.buf;\n+      unit_buf.left = len;\n+\n+      if (!advance (&info, len))\n+\tgoto fail;\n+\n+      version = read_uint16 (&unit_buf);\n+      if (version < 2 || version > 4)\n+\t{\n+\t  dwarf_buf_error (&unit_buf, \"unrecognized DWARF version\");\n+\t  goto fail;\n+\t}\n+\n+      abbrev_offset = read_offset (&unit_buf, is_dwarf64);\n+      if (!read_abbrevs (state, abbrev_offset, dwarf_abbrev, dwarf_abbrev_size,\n+\t\t\t is_bigendian, error_callback, data, &abbrevs))\n+\tgoto fail;\n+\n+      addrsize = read_byte (&unit_buf);\n+\n+      unit_data = unit_buf.buf;\n+      unit_data_len = unit_buf.left;\n+      unit_data_offset = unit_buf.buf - unit_data_start;\n+\n+      /* We only look at the first attribute in the compilation unit.\n+\t In practice this will be a DW_TAG_compile_unit which will\n+\t tell us the PC range and where to find the line number\n+\t information.  */\n+\n+      code = read_uleb128 (&unit_buf);\n+      abbrev = lookup_abbrev (&abbrevs, code, error_callback, data);\n+      if (abbrev == NULL)\n+\tgoto fail;\n+\n+      lowpc = 0;\n+      have_lowpc = 0;\n+      highpc = 0;\n+      have_highpc = 0;\n+      highpc_is_relative = 0;\n+      ranges = 0;\n+      have_ranges = 0;\n+      lineoff = 0;\n+      have_lineoff = 0;\n+      comp_dir = NULL;\n+      for (i = 0; i < abbrev->num_attrs; ++i)\n+\t{\n+\t  struct attr_val val;\n+\n+\t  if (!read_attribute (abbrev->attrs[i].form, &unit_buf, is_dwarf64,\n+\t\t\t       version, addrsize, dwarf_str, dwarf_str_size,\n+\t\t\t       &val))\n+\t    goto fail;\n+\n+\t  switch (abbrev->attrs[i].name)\n+\t    {\n+\t    case DW_AT_low_pc:\n+\t      if (val.encoding == ATTR_VAL_ADDRESS)\n+\t\t{\n+\t\t  lowpc = val.u.uint;\n+\t\t  have_lowpc = 1;\n+\t\t}\n+\t      break;\n+\t    case DW_AT_high_pc:\n+\t      if (val.encoding == ATTR_VAL_ADDRESS)\n+\t\t{\n+\t\t  highpc = val.u.uint;\n+\t\t  have_highpc = 1;\n+\t\t}\n+\t      else if (val.encoding == ATTR_VAL_UINT)\n+\t\t{\n+\t\t  highpc = val.u.uint;\n+\t\t  have_highpc = 1;\n+\t\t  highpc_is_relative = 1;\n+\t\t}\n+\t      break;\n+\t    case DW_AT_ranges:\n+\t      if (val.encoding == ATTR_VAL_UINT\n+\t\t  || val.encoding == ATTR_VAL_REF_SECTION)\n+\t\t{\n+\t\t  ranges = val.u.uint;\n+\t\t  have_ranges = 1;\n+\t\t}\n+\t      break;\n+\t    case DW_AT_stmt_list:\n+\t      if (val.encoding == ATTR_VAL_UINT\n+\t\t  || val.encoding == ATTR_VAL_REF_SECTION)\n+\t\t{\n+\t\t  lineoff = val.u.uint;\n+\t\t  have_lineoff = 1;\n+\t\t}\n+\t      break;\n+\t    case DW_AT_comp_dir:\n+\t      if (val.encoding == ATTR_VAL_STRING)\n+\t\tcomp_dir = val.u.string;\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (unit_buf.reported_underflow)\n+\tgoto fail;\n+\n+      if (((have_lowpc && have_highpc) || have_ranges) && have_lineoff)\n+\t{\n+\t  struct unit *u;\n+\t  struct unit_addrs a;\n+\n+\t  u = ((struct unit *)\n+\t       backtrace_alloc (state, sizeof *u, error_callback, data));\n+\t  if (u == NULL)\n+\t    goto fail;\n+\t  u->unit_data = unit_data;\n+\t  u->unit_data_len = unit_data_len;\n+\t  u->unit_data_offset = unit_data_offset;\n+\t  u->version = version;\n+\t  u->is_dwarf64 = is_dwarf64;\n+\t  u->addrsize = addrsize;\n+\t  u->comp_dir = comp_dir;\n+\t  u->lineoff = lineoff;\n+\t  u->abbrevs = abbrevs;\n+\t  memset (&abbrevs, 0, sizeof abbrevs);\n+\n+\t  /* The actual line number mappings will be read as\n+\t     needed.  */\n+\t  u->lines = NULL;\n+\t  u->lines_count = 0;\n+\t  u->function_addrs = NULL;\n+\t  u->function_addrs_count = 0;\n+\n+\t  if (have_ranges)\n+\t    {\n+\t      if (!add_unit_ranges (state, u, ranges, lowpc, is_bigendian,\n+\t\t\t\t    dwarf_ranges, dwarf_ranges_size,\n+\t\t\t\t    error_callback, data, addrs))\n+\t\t{\n+\t\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n+\t\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n+\t\t  goto fail;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (highpc_is_relative)\n+\t\thighpc += lowpc;\n+\t      a.low = lowpc;\n+\t      a.high = highpc;\n+\t      a.u = u;\n+\n+\t      if (!add_unit_addr (state, a, error_callback, data, addrs))\n+\t\t{\n+\t\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n+\t\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n+\t\t  goto fail;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  free_abbrevs (state, &abbrevs, error_callback, data);\n+\t  memset (&abbrevs, 0, sizeof abbrevs);\n+\t}\n+    }\n+  if (info.reported_underflow)\n+    goto fail;\n+\n+  return 1;\n+\n+ fail:\n+  free_abbrevs (state, &abbrevs, error_callback, data);\n+  free_unit_addrs_vector (state, addrs, error_callback, data);\n+  return 0;\n+}\n+\n+/* Add a new mapping to the vector of line mappings that we are\n+   building.  Returns 1 on success, 0 on failure.  */\n+\n+static int\n+add_line (struct backtrace_state *state, uintptr_t pc, const char *filename,\n+\t  int lineno, backtrace_error_callback error_callback, void *data,\n+\t  struct line_vector *vec)\n+{\n+  struct line *ln;\n+\n+  /* If we are adding the same mapping, ignore it.  This can happen\n+     when using discriminators.  */\n+  if (vec->count > 0)\n+    {\n+      ln = (struct line *) vec->vec.base + (vec->count - 1);\n+      if (pc == ln->pc && filename == ln->filename && lineno == ln->lineno)\n+\treturn 1;\n+    }\n+\n+  ln = ((struct line *)\n+\tbacktrace_vector_grow (state, sizeof (struct line), error_callback,\n+\t\t\t       data, &vec->vec));\n+  if (ln == NULL)\n+    return 0;\n+\n+  ln->pc = pc;\n+  ln->filename = filename;\n+  ln->lineno = lineno;\n+\n+  ++vec->count;\n+\n+  return 1;\n+}\n+\n+/* Free the line header information.  If FREE_FILENAMES is true we\n+   free the file names themselves, otherwise we leave them, as there\n+   may be line structures pointing to them.  */\n+\n+static void\n+free_line_header (struct backtrace_state *state, struct line_header *hdr,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  backtrace_free (state, hdr->dirs, hdr->dirs_count * sizeof (const char *),\n+\t\t  error_callback, data);\n+  backtrace_free (state, hdr->filenames,\n+\t\t  hdr->filenames_count * sizeof (char *),\n+\t\t  error_callback, data);\n+}\n+\n+/* Read the line header.  Return 1 on success, 0 on failure.  */\n+\n+static int\n+read_line_header (struct backtrace_state *state, struct unit *u,\n+\t\t  int is_dwarf64, struct dwarf_buf *line_buf,\n+\t\t  struct line_header *hdr)\n+{\n+  uint64_t hdrlen;\n+  struct dwarf_buf hdr_buf;\n+  const unsigned char *p;\n+  const unsigned char *pend;\n+  size_t i;\n+\n+  hdr->version = read_uint16 (line_buf);\n+  if (hdr->version < 2 || hdr->version > 4)\n+    {\n+      dwarf_buf_error (line_buf, \"unsupported line number version\");\n+      return 0;\n+    }\n+\n+  hdrlen = read_offset (line_buf, is_dwarf64);\n+\n+  hdr_buf = *line_buf;\n+  hdr_buf.left = hdrlen;\n+\n+  if (!advance (line_buf, hdrlen))\n+    return 0;\n+  \n+  hdr->min_insn_len = read_byte (&hdr_buf);\n+  if (hdr->version < 4)\n+    hdr->max_ops_per_insn = 1;\n+  else\n+    hdr->max_ops_per_insn = read_byte (&hdr_buf);\n+\n+  /* We don't care about default_is_stmt.  */\n+  read_byte (&hdr_buf);\n+  \n+  hdr->line_base = read_sbyte (&hdr_buf);\n+  hdr->line_range = read_byte (&hdr_buf);\n+\n+  hdr->opcode_base = read_byte (&hdr_buf);\n+  hdr->opcode_lengths = hdr_buf.buf;\n+  if (!advance (&hdr_buf, hdr->opcode_base - 1))\n+    return 0;\n+\n+  /* Count the number of directory entries.  */\n+  hdr->dirs_count = 0;\n+  p = hdr_buf.buf;\n+  pend = p + hdr_buf.left;\n+  while (p < pend && *p != '\\0')\n+    {\n+      p += strnlen((const char *) p, pend - p) + 1;\n+      ++hdr->dirs_count;\n+    }\n+\n+  hdr->dirs = ((const char **)\n+\t       backtrace_alloc (state,\n+\t\t\t\thdr->dirs_count * sizeof (const char *),\n+\t\t\t\tline_buf->error_callback, line_buf->data));\n+  if (hdr->dirs == NULL)\n+    return 0;\n+\n+  i = 0;\n+  while (*hdr_buf.buf != '\\0')\n+    {\n+      if (hdr_buf.reported_underflow)\n+\treturn 0;\n+\n+      hdr->dirs[i] = (const char *) hdr_buf.buf;\n+      ++i;\n+      if (!advance (&hdr_buf,\n+\t\t    strnlen ((const char *) hdr_buf.buf, hdr_buf.left) + 1))\n+\treturn 0;\n+    }\n+  if (!advance (&hdr_buf, 1))\n+    return 0;\n+\n+  /* Count the number of file entries.  */\n+  hdr->filenames_count = 0;\n+  p = hdr_buf.buf;\n+  pend = p + hdr_buf.left;\n+  while (p < pend && *p != '\\0')\n+    {\n+      p += strnlen ((const char *) p, pend - p) + 1;\n+      p += leb128_len (p);\n+      p += leb128_len (p);\n+      p += leb128_len (p);\n+      ++hdr->filenames_count;\n+    }\n+\n+  hdr->filenames = ((const char **)\n+\t\t    backtrace_alloc (state,\n+\t\t\t\t     hdr->filenames_count * sizeof (char *),\n+\t\t\t\t     line_buf->error_callback,\n+\t\t\t\t     line_buf->data));\n+  if (hdr->filenames == NULL)\n+    return 0;\n+  i = 0;\n+  while (*hdr_buf.buf != '\\0')\n+    {\n+      const char *filename;\n+      uint64_t dir_index;\n+\n+      if (hdr_buf.reported_underflow)\n+\treturn 0;\n+\n+      filename = (const char *) hdr_buf.buf;\n+      if (!advance (&hdr_buf,\n+\t\t    strnlen ((const char *) hdr_buf.buf, hdr_buf.left) + 1))\n+\treturn 0;\n+      dir_index = read_uleb128 (&hdr_buf);\n+      if (IS_ABSOLUTE_PATH (filename))\n+\thdr->filenames[i] = filename;\n+      else\n+\t{\n+\t  const char *dir;\n+\t  size_t dir_len;\n+\t  size_t filename_len;\n+\t  char *s;\n+\n+\t  if (dir_index == 0)\n+\t    dir = u->comp_dir;\n+\t  else if (dir_index - 1 < hdr->dirs_count)\n+\t    dir = hdr->dirs[dir_index - 1];\n+\t  else\n+\t    {\n+\t      dwarf_buf_error (line_buf,\n+\t\t\t       (\"invalid directory index in \"\n+\t\t\t\t\"line number program header\"));\n+\t      return 0;\n+\t    }\n+\t  dir_len = strlen (dir);\n+\t  filename_len = strlen (filename);\n+\t  s = ((char *)\n+\t       backtrace_alloc (state, dir_len + filename_len + 2,\n+\t\t\t\tline_buf->error_callback, line_buf->data));\n+\t  if (s == NULL)\n+\t    return 0;\n+\t  memcpy (s, dir, dir_len);\n+\t  /* FIXME: If we are on a DOS-based file system, and the\n+\t     directory or the file name use backslashes, then we\n+\t     should use a backslash here.  */\n+\t  s[dir_len] = '/';\n+\t  memcpy (s + dir_len + 1, filename, filename_len + 1);\n+\t  hdr->filenames[i] = s;\n+\t}\n+\n+      /* Ignore the modification time and size.  */\n+      read_uleb128 (&hdr_buf);\n+      read_uleb128 (&hdr_buf);\n+\n+      ++i;\n+    }\n+\n+  if (hdr_buf.reported_underflow)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Read the line program, adding line mappings to VEC.  Return 1 on\n+   success, 0 on failure.  */\n+\n+static int\n+read_line_program (struct backtrace_state *state, struct unit *u,\n+\t\t   const struct line_header *hdr, struct dwarf_buf *line_buf,\n+\t\t   struct line_vector *vec)\n+{\n+  uint64_t address;\n+  unsigned int op_index;\n+  const char *reset_filename;\n+  const char *filename;\n+  int lineno;\n+\n+  address = 0;\n+  op_index = 0;\n+  if (hdr->filenames_count > 0)\n+    reset_filename = hdr->filenames[0];\n+  else\n+    reset_filename = \"\";\n+  filename = reset_filename;\n+  lineno = 1;\n+  while (line_buf->left > 0)\n+    {\n+      unsigned int op;\n+\n+      op = read_byte (line_buf);\n+      if (op >= hdr->opcode_base)\n+\t{\n+\t  unsigned int advance;\n+\n+\t  /* Special opcode.  */\n+\t  op -= hdr->opcode_base;\n+\t  advance = op / hdr->line_range;\n+\t  address += (hdr->min_insn_len * (op_index + advance)\n+\t\t      / hdr->max_ops_per_insn);\n+\t  op_index = (op_index + advance) % hdr->max_ops_per_insn;\n+\t  lineno += hdr->line_base + (int) (op % hdr->line_range);\n+\t  add_line (state, address, filename, lineno, line_buf->error_callback,\n+\t\t    line_buf->data, vec);\n+\t}\n+      else if (op == DW_LNS_extended_op)\n+\t{\n+\t  uint64_t len;\n+\n+\t  len = read_uleb128 (line_buf);\n+\t  op = read_byte (line_buf);\n+\t  switch (op)\n+\t    {\n+\t    case DW_LNE_end_sequence:\n+\t      /* FIXME: Should we mark the high PC here?  It seems\n+\t\t that we already have that information from the\n+\t\t compilation unit.  */\n+\t      address = 0;\n+\t      op_index = 0;\n+\t      filename = reset_filename;\n+\t      lineno = 1;\n+\t      break;\n+\t    case DW_LNE_set_address:\n+\t      address = read_address (line_buf, u->addrsize);\n+\t      break;\n+\t    case DW_LNE_define_file:\n+\t      {\n+\t\tconst char *f;\n+\t\tunsigned int dir_index;\n+\n+\t\tf = (const char *) line_buf->buf;\n+\t\tif (!advance (line_buf, strnlen (f, line_buf->left) + 1))\n+\t\t  return 0;\n+\t\tdir_index = read_uleb128 (line_buf);\n+\t\t/* Ignore that time and length.  */\n+\t\tread_uleb128 (line_buf);\n+\t\tread_uleb128 (line_buf);\n+\t\tif (IS_ABSOLUTE_PATH (f))\n+\t\t  filename = f;\n+\t\telse\n+\t\t  {\n+\t\t    const char *dir;\n+\t\t    size_t dir_len;\n+\t\t    size_t f_len;\n+\t\t    char *p;\n+\n+\t\t    if (dir_index == 0)\n+\t\t      dir = u->comp_dir;\n+\t\t    else if (dir_index - 1 < hdr->dirs_count)\n+\t\t      dir = hdr->dirs[dir_index - 1];\n+\t\t    else\n+\t\t      {\n+\t\t\tdwarf_buf_error (line_buf,\n+\t\t\t\t\t (\"invalid directory index \"\n+\t\t\t\t\t  \"in line number program\"));\n+\t\t\treturn 0;\n+\t\t      }\n+\t\t    dir_len = strlen (dir);\n+\t\t    f_len = strlen (f);\n+\t\t    p = ((char *)\n+\t\t\t backtrace_alloc (state, dir_len + f_len + 2,\n+\t\t\t\t\t  line_buf->error_callback,\n+\t\t\t\t\t  line_buf->data));\n+\t\t    if (p == NULL)\n+\t\t      return 0;\n+\t\t    memcpy (p, dir, dir_len);\n+\t\t    /* FIXME: If we are on a DOS-based file system,\n+\t\t       and the directory or the file name use\n+\t\t       backslashes, then we should use a backslash\n+\t\t       here.  */\n+\t\t    p[dir_len] = '/';\n+\t\t    memcpy (p + dir_len + 1, f, f_len + 1);\n+\t\t    filename = p;\n+\t\t  }\n+\t      }\n+\t      break;\n+\t    case DW_LNE_set_discriminator:\n+\t      /* We don't care about discriminators.  */\n+\t      read_uleb128 (line_buf);\n+\t      break;\n+\t    default:\n+\t      if (!advance (line_buf, len - 1))\n+\t\treturn 0;\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  switch (op)\n+\t    {\n+\t    case DW_LNS_copy:\n+\t      add_line (state, address, filename, lineno,\n+\t\t\tline_buf->error_callback, line_buf->data, vec);\n+\t      break;\n+\t    case DW_LNS_advance_pc:\n+\t      {\n+\t\tuint64_t advance;\n+\n+\t\tadvance = read_uleb128 (line_buf);\n+\t\taddress += (hdr->min_insn_len * (op_index + advance)\n+\t\t\t    / hdr->max_ops_per_insn);\n+\t\top_index = (op_index + advance) % hdr->max_ops_per_insn;\n+\t      }\n+\t      break;\n+\t    case DW_LNS_advance_line:\n+\t      lineno += (int) read_sleb128 (line_buf);\n+\t      break;\n+\t    case DW_LNS_set_file:\n+\t      {\n+\t\tuint64_t fileno;\n+\n+\t\tfileno = read_uleb128 (line_buf);\n+\t\tif (fileno == 0)\n+\t\t  filename = \"\";\n+\t\telse\n+\t\t  {\n+\t\t    if (fileno - 1 >= hdr->filenames_count)\n+\t\t      {\n+\t\t\tdwarf_buf_error (line_buf,\n+\t\t\t\t\t (\"invalid file number in \"\n+\t\t\t\t\t  \"line number program\"));\n+\t\t\treturn 0;\n+\t\t      }\n+\t\t    filename = hdr->filenames[fileno - 1];\n+\t\t  }\n+\t      }\n+\t      break;\n+\t    case DW_LNS_set_column:\n+\t      read_uleb128 (line_buf);\n+\t      break;\n+\t    case DW_LNS_negate_stmt:\n+\t      break;\n+\t    case DW_LNS_set_basic_block:\n+\t      break;\n+\t    case DW_LNS_const_add_pc:\n+\t      {\n+\t\tunsigned int advance;\n+\n+\t\top = 255 - hdr->opcode_base;\n+\t\tadvance = op / hdr->line_range;\n+\t\taddress += (hdr->min_insn_len * (op_index + advance)\n+\t\t\t    / hdr->max_ops_per_insn);\n+\t\top_index = (op_index + advance) % hdr->max_ops_per_insn;\n+\t      }\n+\t      break;\n+\t    case DW_LNS_fixed_advance_pc:\n+\t      address += read_uint16 (line_buf);\n+\t      op_index = 0;\n+\t      break;\n+\t    case DW_LNS_set_prologue_end:\n+\t      break;\n+\t    case DW_LNS_set_epilogue_begin:\n+\t      break;\n+\t    case DW_LNS_set_isa:\n+\t      read_uleb128 (line_buf);\n+\t      break;\n+\t    default:\n+\t      {\n+\t\tunsigned int i;\n+\n+\t\tfor (i = hdr->opcode_lengths[op - 1]; i > 0; --i)\n+\t\t  read_uleb128 (line_buf);\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  return 1;\n+}\n+\n+/* Read the line number information for a compilation unit.  Returns 1\n+   on success, 0 on failure.  */\n+\n+static int\n+read_line_info (struct backtrace_state *state, struct dwarf_data *ddata,\n+\t\tbacktrace_error_callback error_callback, void *data,\n+\t\tstruct unit *u, struct line_header *hdr, struct line **lines,\n+\t\tsize_t *lines_count)\n+{\n+  struct line_vector vec;\n+  struct dwarf_buf line_buf;\n+  uint64_t len;\n+  int is_dwarf64;\n+  struct line *ln;\n+\n+  memset (&vec.vec, 0, sizeof vec.vec);\n+  vec.count = 0;\n+\n+  memset (hdr, 0, sizeof *hdr);\n+\n+  if (u->lineoff != (off_t) (size_t) u->lineoff\n+      || (size_t) u->lineoff >= ddata->dwarf_line_size)\n+    {\n+      error_callback (data, \"unit line offset out of range\", 0);\n+      goto fail;\n+    }\n+\n+  line_buf.name = \".debug_line\";\n+  line_buf.start = ddata->dwarf_line;\n+  line_buf.buf = ddata->dwarf_line + u->lineoff;\n+  line_buf.left = ddata->dwarf_line_size - u->lineoff;\n+  line_buf.is_bigendian = ddata->is_bigendian;\n+  line_buf.error_callback = error_callback;\n+  line_buf.data = data;\n+  line_buf.reported_underflow = 0;\n+\n+  is_dwarf64 = 0;\n+  len = read_uint32 (&line_buf);\n+  if (len == 0xffffffff)\n+    {\n+      len = read_uint64 (&line_buf);\n+      is_dwarf64 = 1;\n+    }\n+  line_buf.left = len;\n+\n+  if (!read_line_header (state, u, is_dwarf64, &line_buf, hdr))\n+    goto fail;\n+\n+  if (!read_line_program (state, u, hdr, &line_buf, &vec))\n+    goto fail;\n+\n+  if (line_buf.reported_underflow)\n+    goto fail;\n+\n+  if (vec.count == 0)\n+    {\n+      /* This is not a failure in the sense of a generating an error,\n+\t but it is a failure in that sense that we have no useful\n+\t information.  */\n+      goto fail;\n+    }\n+\n+  /* Allocate one extra entry at the end.  */\n+  ln = ((struct line *)\n+\tbacktrace_vector_grow (state, sizeof (struct line), error_callback,\n+\t\t\t       data, &vec.vec));\n+  if (ln == NULL)\n+    goto fail;\n+  ln->pc = (uintptr_t) -1;\n+  ln->filename = NULL;\n+  ln->lineno = 0;\n+\n+  if (!backtrace_vector_release (state, &vec.vec, error_callback, data))\n+    goto fail;\n+\n+  ln = (struct line *) vec.vec.base;\n+  qsort (ln, vec.count, sizeof (struct line), line_compare);\n+\n+  *lines = ln;\n+  *lines_count = vec.count;\n+\n+  return 1;\n+\n+ fail:\n+  vec.vec.alc += vec.vec.size;\n+  vec.vec.size = 0;\n+  backtrace_vector_release (state, &vec.vec, error_callback, data);\n+  free_line_header (state, hdr, error_callback, data);\n+  *lines = (struct line *) (uintptr_t) -1;\n+  *lines_count = 0;\n+  return 0;\n+}\n+\n+/* Read the name of a function from a DIE referenced by a\n+   DW_AT_abstract_origin or DW_AT_specification tag.  OFFSET is within\n+   the same compilation unit.  */\n+\n+static const char *\n+read_referenced_name (struct dwarf_data *ddata, struct unit *u,\n+\t\t      uint64_t offset, backtrace_error_callback error_callback,\n+\t\t      void *data)\n+{\n+  struct dwarf_buf unit_buf;\n+  uint64_t code;\n+  const struct abbrev *abbrev;\n+  const char *ret;\n+  size_t i;\n+\n+  /* OFFSET is from the start of the data for this compilation unit.\n+     U->unit_data is the data, but it starts U->unit_data_offset bytes\n+     from the beginning.  */\n+\n+  if (offset < u->unit_data_offset\n+      || offset - u->unit_data_offset >= u->unit_data_len)\n+    {\n+      error_callback (data,\n+\t\t      \"abstract origin or specification out of range\",\n+\t\t      0);\n+      return NULL;\n+    }\n+\n+  offset -= u->unit_data_offset;\n+\n+  unit_buf.name = \".debug_info\";\n+  unit_buf.start = ddata->dwarf_info;\n+  unit_buf.buf = u->unit_data + offset;\n+  unit_buf.left = u->unit_data_len - offset;\n+  unit_buf.is_bigendian = ddata->is_bigendian;\n+  unit_buf.error_callback = error_callback;\n+  unit_buf.data = data;\n+  unit_buf.reported_underflow = 0;\n+\n+  code = read_uleb128 (&unit_buf);\n+  if (code == 0)\n+    {\n+      dwarf_buf_error (&unit_buf, \"invalid abstract origin or specification\");\n+      return NULL;\n+    }\n+\n+  abbrev = lookup_abbrev (&u->abbrevs, code, error_callback, data);\n+  if (abbrev == NULL)\n+    return NULL;\n+\n+  ret = NULL;\n+  for (i = 0; i < abbrev->num_attrs; ++i)\n+    {\n+      struct attr_val val;\n+\n+      if (!read_attribute (abbrev->attrs[i].form, &unit_buf,\n+\t\t\t   u->is_dwarf64, u->version, u->addrsize,\n+\t\t\t   ddata->dwarf_str, ddata->dwarf_str_size,\n+\t\t\t   &val))\n+\treturn NULL;\n+\n+      switch (abbrev->attrs[i].name)\n+\t{\n+\tcase DW_AT_name:\n+\t  /* We prefer the linkage name if get one.  */\n+\t  if (val.encoding == ATTR_VAL_STRING)\n+\t    ret = val.u.string;\n+\t  break;\n+\n+\tcase DW_AT_linkage_name:\n+\tcase DW_AT_MIPS_linkage_name:\n+\t  if (val.encoding == ATTR_VAL_STRING)\n+\t    return val.u.string;\n+\t  break;\n+\n+\tcase DW_AT_specification:\n+\t  if (abbrev->attrs[i].form == DW_FORM_ref_addr\n+\t      || abbrev->attrs[i].form == DW_FORM_ref_sig8)\n+\t    {\n+\t      /* This refers to a specification defined in some other\n+\t\t compilation unit.  We can handle this case if we\n+\t\t must, but it's harder.  */\n+\t      break;\n+\t    }\n+\t  if (val.encoding == ATTR_VAL_UINT\n+\t      || val.encoding == ATTR_VAL_REF_UNIT)\n+\t    {\n+\t      const char *name;\n+\n+\t      name = read_referenced_name (ddata, u, val.u.uint,\n+\t\t\t\t\t   error_callback, data);\n+\t      if (name != NULL)\n+\t\tret = name;\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n+/* Add a single range to U that maps to function.  Returns 1 on\n+   success, 0 on error.  */\n+\n+static int\n+add_function_range (struct backtrace_state *state, struct function *function,\n+\t\t    uint64_t lowpc, uint64_t highpc,\n+\t\t    backtrace_error_callback error_callback,\n+\t\t    void *data, struct function_vector *vec)\n+{\n+  struct function_addrs *p;\n+\n+  if (vec->count > 0)\n+    {\n+      p = (struct function_addrs *) vec->vec.base + vec->count - 1;\n+      if ((lowpc == p->high || lowpc == p->high + 1)\n+\t  && function == p->function)\n+\t{\n+\t  if (highpc > p->high)\n+\t    p->high = highpc;\n+\t  return 1;\n+\t}\n+    }\n+\n+  p = ((struct function_addrs *)\n+       backtrace_vector_grow (state, sizeof (struct function_addrs),\n+\t\t\t      error_callback, data, &vec->vec));\n+  if (p == NULL)\n+    return 0;\n+\n+  p->low = lowpc;\n+  p->high = highpc;\n+  p->function = function;\n+  ++vec->count;\n+  return 1;\n+}\n+\n+/* Add PC ranges to U that map to FUNCTION.  Returns 1 on success, 0\n+   on error.  */\n+\n+static int\n+add_function_ranges (struct backtrace_state *state, struct dwarf_data *ddata,\n+\t\t     struct unit *u, struct function *function,\n+\t\t     uint64_t ranges, uint64_t base,\n+\t\t     backtrace_error_callback error_callback, void *data,\n+\t\t     struct function_vector *vec)\n+{\n+  struct dwarf_buf ranges_buf;\n+\n+  if (ranges >= ddata->dwarf_ranges_size)\n+    {\n+      error_callback (data, \"function ranges offset out of range\", 0);\n+      return 0;\n+    }\n+\n+  ranges_buf.name = \".debug_ranges\";\n+  ranges_buf.start = ddata->dwarf_ranges;\n+  ranges_buf.buf = ddata->dwarf_ranges + ranges;\n+  ranges_buf.left = ddata->dwarf_ranges_size - ranges;\n+  ranges_buf.is_bigendian = ddata->is_bigendian;\n+  ranges_buf.error_callback = error_callback;\n+  ranges_buf.data = data;\n+  ranges_buf.reported_underflow = 0;\n+\n+  while (1)\n+    {\n+      uint64_t low;\n+      uint64_t high;\n+\n+      if (ranges_buf.reported_underflow)\n+\treturn 0;\n+\n+      low = read_address (&ranges_buf, u->addrsize);\n+      high = read_address (&ranges_buf, u->addrsize);\n+\n+      if (low == 0 && high == 0)\n+\tbreak;\n+\n+      if (is_highest_address (low, u->addrsize))\n+\tbase = high;\n+      else\n+\t{\n+\t  if (!add_function_range (state, function, low + base, high + base,\n+\t\t\t\t   error_callback, data, vec))\n+\t    return 0;\n+\t}\n+    }\n+\n+  if (ranges_buf.reported_underflow)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Read one entry plus all its children.  Add function addresses to\n+   VEC.  Returns 1 on success, 0 on error.  */\n+\n+static int\n+read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n+\t\t     struct unit *u, uint64_t base, struct dwarf_buf *unit_buf,\n+\t\t     const struct line_header *lhdr,\n+\t\t     backtrace_error_callback error_callback, void *data,\n+\t\t     struct function_vector *vec)\n+{\n+  while (unit_buf->left > 0)\n+    {\n+      uint64_t code;\n+      const struct abbrev *abbrev;\n+      int is_function;\n+      struct function *function;\n+      size_t i;\n+      uint64_t lowpc;\n+      int have_lowpc;\n+      uint64_t highpc;\n+      int have_highpc;\n+      int highpc_is_relative;\n+      uint64_t ranges;\n+      int have_ranges;\n+\n+      code = read_uleb128 (unit_buf);\n+      if (code == 0)\n+\treturn 1;\n+\n+      abbrev = lookup_abbrev (&u->abbrevs, code, error_callback, data);\n+      if (abbrev == NULL)\n+\treturn 0;\n+\n+      is_function = (abbrev->tag == DW_TAG_subprogram\n+\t\t     || abbrev->tag == DW_TAG_entry_point\n+\t\t     || abbrev->tag == DW_TAG_inlined_subroutine);\n+\n+      function = NULL;\n+      if (is_function)\n+\t{\n+\t  function = ((struct function *)\n+\t\t      backtrace_alloc (state, sizeof *function,\n+\t\t\t\t       error_callback, data));\n+\t  if (function == NULL)\n+\t    return 0;\n+\t  memset (function, 0, sizeof *function);\n+\t}\n+\n+      lowpc = 0;\n+      have_lowpc = 0;\n+      highpc = 0;\n+      have_highpc = 0;\n+      highpc_is_relative = 0;\n+      ranges = 0;\n+      have_ranges = 0;\n+      for (i = 0; i < abbrev->num_attrs; ++i)\n+\t{\n+\t  struct attr_val val;\n+\n+\t  if (!read_attribute (abbrev->attrs[i].form, unit_buf,\n+\t\t\t       u->is_dwarf64, u->version, u->addrsize,\n+\t\t\t       ddata->dwarf_str, ddata->dwarf_str_size,\n+\t\t\t       &val))\n+\t    return 0;\n+\n+\t  /* The compile unit sets the base address for any address\n+\t     ranges in the function entries.  */\n+\t  if (abbrev->tag == DW_TAG_compile_unit\n+\t      && abbrev->attrs[i].name == DW_AT_low_pc\n+\t      && val.encoding == ATTR_VAL_ADDRESS)\n+\t    base = val.u.uint;\n+\n+\t  if (is_function)\n+\t    {\n+\t      switch (abbrev->attrs[i].name)\n+\t\t{\n+\t\tcase DW_AT_call_file:\n+\t\t  if (val.encoding == ATTR_VAL_UINT)\n+\t\t    {\n+\t\t      if (val.u.uint == 0)\n+\t\t\tfunction->caller_filename = \"\";\n+\t\t      else\n+\t\t\t{\n+\t\t\t  if (val.u.uint - 1 >= lhdr->filenames_count)\n+\t\t\t    {\n+\t\t\t      dwarf_buf_error (unit_buf,\n+\t\t\t\t\t       (\"invalid file number in \"\n+\t\t\t\t\t\t\"DW_AT_call_file attribute\"));\n+\t\t\t      return 0;\n+\t\t\t    }\n+\t\t\t  function->caller_filename =\n+\t\t\t    lhdr->filenames[val.u.uint - 1];\n+\t\t\t}\n+\t\t    }\n+\t\t  break;\n+\n+\t\tcase DW_AT_call_line:\n+\t\t  if (val.encoding == ATTR_VAL_UINT)\n+\t\t    function->caller_lineno = val.u.uint;\n+\t\t  break;\n+\n+\t\tcase DW_AT_abstract_origin:\n+\t\tcase DW_AT_specification:\n+\t\t  if (abbrev->attrs[i].form == DW_FORM_ref_addr\n+\t\t      || abbrev->attrs[i].form == DW_FORM_ref_sig8)\n+\t\t    {\n+\t\t      /* This refers to an abstract origin defined in\n+\t\t\t some other compilation unit.  We can handle\n+\t\t\t this case if we must, but it's harder.  */\n+\t\t      break;\n+\t\t    }\n+\t\t  if (val.encoding == ATTR_VAL_UINT\n+\t\t      || val.encoding == ATTR_VAL_REF_UNIT)\n+\t\t    {\n+\t\t      const char *name;\n+\n+\t\t      name = read_referenced_name (ddata, u, val.u.uint,\n+\t\t\t\t\t\t   error_callback, data);\n+\t\t      if (name != NULL)\n+\t\t\tfunction->name = name;\n+\t\t    }\n+\t\t  break;\n+\n+\t\tcase DW_AT_name:\n+\t\t  if (val.encoding == ATTR_VAL_STRING)\n+\t\t    {\n+\t\t      /* Don't override a name we found in some other\n+\t\t\t way, as it will normally be more\n+\t\t\t useful--e.g., this name is normally not\n+\t\t\t mangled.  */\n+\t\t      if (function->name == NULL)\n+\t\t\tfunction->name = val.u.string;\n+\t\t    }\n+\t\t  break;\n+\n+\t\tcase DW_AT_linkage_name:\n+\t\tcase DW_AT_MIPS_linkage_name:\n+\t\t  if (val.encoding == ATTR_VAL_STRING)\n+\t\t    function->name = val.u.string;\n+\t\t  break;\n+\n+\t\tcase DW_AT_low_pc:\n+\t\t  if (val.encoding == ATTR_VAL_ADDRESS)\n+\t\t    {\n+\t\t      lowpc = val.u.uint;\n+\t\t      have_lowpc = 1;\n+\t\t    }\n+\t\t  break;\n+\n+\t\tcase DW_AT_high_pc:\n+\t\t  if (val.encoding == ATTR_VAL_ADDRESS)\n+\t\t    {\n+\t\t      highpc = val.u.uint;\n+\t\t      have_highpc = 1;\n+\t\t    }\n+\t\t  else if (val.encoding == ATTR_VAL_UINT)\n+\t\t    {\n+\t\t      highpc = val.u.uint;\n+\t\t      have_highpc = 1;\n+\t\t      highpc_is_relative = 1;\n+\t\t    }\n+\t\t  break;\n+\n+\t\tcase DW_AT_ranges:\n+\t\t  if (val.encoding == ATTR_VAL_UINT\n+\t\t      || val.encoding == ATTR_VAL_REF_SECTION)\n+\t\t    {\n+\t\t      ranges = val.u.uint;\n+\t\t      have_ranges = 1;\n+\t\t    }\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* If we couldn't find a name for the function, we have no use\n+\t for it.  */\n+      if (is_function && function->name == NULL)\n+\t{\n+\t  backtrace_free (state, function, sizeof *function,\n+\t\t\t  error_callback, data);\n+\t  is_function = 0;\n+\t}\n+\n+      if (is_function)\n+\t{\n+\t  if (have_ranges)\n+\t    {\n+\t      if (!add_function_ranges (state, ddata, u, function, ranges,\n+\t\t\t\t\tbase, error_callback, data, vec))\n+\t\treturn 0;\n+\t    }\n+\t  else if (have_lowpc && have_highpc)\n+\t    {\n+\t      if (highpc_is_relative)\n+\t\thighpc += lowpc;\n+\t      if (!add_function_range (state, function, lowpc, highpc,\n+\t\t\t\t       error_callback, data, vec))\n+\t\treturn 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      backtrace_free (state, function, sizeof *function,\n+\t\t\t      error_callback, data);\n+\t      is_function = 0;\n+\t    }\n+\t}\n+\n+      if (abbrev->has_children)\n+\t{\n+\t  if (!is_function)\n+\t    {\n+\t      if (!read_function_entry (state, ddata, u, base, unit_buf, lhdr,\n+\t\t\t\t\terror_callback, data, vec))\n+\t\treturn 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      struct function_vector fvec;\n+\n+\t      /* Gather any information for inlined functions in\n+\t\t FVEC.  */\n+\n+\t      memset (&fvec, 0, sizeof fvec);\n+\n+\t      if (!read_function_entry (state, ddata, u, base, unit_buf, lhdr,\n+\t\t\t\t\terror_callback, data, &fvec))\n+\t\treturn 0;\n+\n+\t      if (fvec.count > 0)\n+\t\t{\n+\t\t  struct function_addrs *faddrs;\n+\n+\t\t  if (!backtrace_vector_release (state, &fvec.vec,\n+\t\t\t\t\t\t error_callback, data))\n+\t\t    return 0;\n+\n+\t\t  faddrs = (struct function_addrs *) fvec.vec.base;\n+\t\t  qsort (faddrs, fvec.count,\n+\t\t\t sizeof (struct function_addrs),\n+\t\t\t function_addrs_compare);\n+\n+\t\t  function->function_addrs = faddrs;\n+\t\t  function->function_addrs_count = fvec.count;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return 1;\n+}\n+\n+/* Read function name information for a compilation unit.  We look\n+   through the whole unit looking for function tags.  */\n+\n+static void\n+read_function_info (struct backtrace_state *state, struct dwarf_data *ddata,\n+\t\t    const struct line_header *lhdr,\n+\t\t    backtrace_error_callback error_callback, void *data,\n+\t\t    struct unit *u, struct function_vector *fvec,\n+\t\t    struct function_addrs **ret_addrs,\n+\t\t    size_t *ret_addrs_count)\n+{\n+  struct dwarf_buf unit_buf;\n+  struct function_addrs *addrs;\n+  size_t addrs_count;\n+\n+  unit_buf.name = \".debug_info\";\n+  unit_buf.start = ddata->dwarf_info;\n+  unit_buf.buf = u->unit_data;\n+  unit_buf.left = u->unit_data_len;\n+  unit_buf.is_bigendian = ddata->is_bigendian;\n+  unit_buf.error_callback = error_callback;\n+  unit_buf.data = data;\n+  unit_buf.reported_underflow = 0;\n+\n+  while (unit_buf.left > 0)\n+    {\n+      if (!read_function_entry (state, ddata, u, 0, &unit_buf, lhdr,\n+\t\t\t\terror_callback, data, fvec))\n+\treturn;\n+    }\n+\n+  if (fvec->count == 0)\n+    return;\n+\n+  addrs = (struct function_addrs *) fvec->vec.base;\n+  addrs_count = fvec->count;\n+\n+  /* Finish this list of addresses, but leave the remaining space in\n+     the vector available for the next function unit.  */\n+  backtrace_vector_finish (state, &fvec->vec);\n+  fvec->count = 0;\n+\n+  qsort (addrs, addrs_count, sizeof (struct function_addrs),\n+\t function_addrs_compare);\n+\n+  *ret_addrs = addrs;\n+  *ret_addrs_count = addrs_count;\n+}\n+\n+/* See if PC is inlined in FUNCTION.  If it is, print out the inlined\n+   information, and update FILENAME and LINENO for the caller.\n+   Returns whatever CALLBACK returns, or 0 to keep going.  */\n+\n+static int\n+report_inlined_functions (uintptr_t pc, struct function *function,\n+\t\t\t  backtrace_full_callback callback, void *data,\n+\t\t\t  const char **filename, int *lineno)\n+{\n+  struct function_addrs *function_addrs;\n+  struct function *inlined;\n+  int ret;\n+\n+  if (function->function_addrs_count == 0)\n+    return 0;\n+\n+  function_addrs = ((struct function_addrs *)\n+\t\t    bsearch (&pc, function->function_addrs,\n+\t\t\t     function->function_addrs_count,\n+\t\t\t     sizeof (struct function_addrs),\n+\t\t\t     function_addrs_search));\n+  if (function_addrs == NULL)\n+    return 0;\n+\n+  while (((size_t) (function_addrs - function->function_addrs) + 1\n+\t  < function->function_addrs_count)\n+\t && pc >= (function_addrs + 1)->low\n+\t && pc < (function_addrs + 1)->high)\n+    ++function_addrs;\n+\n+  /* We found an inlined call.  */\n+\n+  inlined = function_addrs->function;\n+\n+  /* Report any calls inlined into this one.  */\n+  ret = report_inlined_functions (pc, inlined, callback, data,\n+\t\t\t\t  filename, lineno);\n+  if (ret != 0)\n+    return ret;\n+\n+  /* Report this inlined call.  */\n+  ret = callback (data, pc, *filename, *lineno, inlined->name);\n+  if (ret != 0)\n+    return ret;\n+\n+  /* Our caller will report the caller of the inlined function; tell\n+     it the appropriate filename and line number.  */\n+  *filename = inlined->caller_filename;\n+  *lineno = inlined->caller_lineno;\n+\n+  return 0;\n+}\n+\n+/* Return the file/line information for a PC using the DWARF mapping\n+   we built earlier.  */\n+\n+static int\n+dwarf_fileline (struct backtrace_state *state, uintptr_t pc,\n+\t\tbacktrace_full_callback callback,\n+\t\tbacktrace_error_callback error_callback, void *data)\n+{\n+  struct dwarf_data *ddata;\n+  struct unit_addrs *entry;\n+  struct unit *u;\n+  int new_data;\n+  struct line *lines;\n+  struct line *ln;\n+  struct function_addrs *function_addrs;\n+  struct function *function;\n+  const char *filename;\n+  int lineno;\n+  int ret;\n+\n+  ddata = (struct dwarf_data *) state->fileline_data;\n+\n+  /* Find an address range that includes PC.  */\n+  entry = bsearch (&pc, ddata->addrs, ddata->addrs_count,\n+\t\t   sizeof (struct unit_addrs), unit_addrs_search);\n+\n+  if (entry == NULL)\n+    return callback (data, pc, NULL, 0, NULL);\n+\n+  /* If there are multiple ranges that contain PC, use the last one,\n+     in order to produce predictable results.  If we assume that all\n+     ranges are properly nested, then the last range will be the\n+     smallest one.  */\n+  while ((size_t) (entry - ddata->addrs) + 1 < ddata->addrs_count\n+\t && pc >= (entry + 1)->low\n+\t && pc < (entry + 1)->high)\n+    ++entry;\n+\n+  /* We need the lines, lines_count, function_addrs,\n+     function_addrs_count fields of u.  If they are not set, we need\n+     to set them.  When running in threaded mode, we need to allow for\n+     the possibility that some other thread is setting them\n+     simultaneously.  */\n+\n+  u = entry->u;\n+  lines = u->lines;\n+\n+  /* Skip units with no useful line number information by walking\n+     backward.  Useless line number information is marked by setting\n+     lines == -1.  */\n+  while (entry > ddata->addrs\n+\t && pc >= (entry - 1)->low\n+\t && pc < (entry - 1)->high)\n+    {\n+      if (state->threaded)\n+\t{\n+\t  /* Use __sync_bool_compare_and_swap to do a\n+\t     load-acquire.  */\n+\t  while (!__sync_bool_compare_and_swap (&u->lines, lines, lines))\n+\t    lines = u->lines;\n+\t}\n+\n+      if (lines != (struct line *) (uintptr_t) -1)\n+\tbreak;\n+\n+      --entry;\n+\n+      u = entry->u;\n+      lines = u->lines;\n+    }\n+\n+  /* Do a load-acquire of u->lines.  */\n+  if (state->threaded)\n+    {\n+      /* Use __sync_bool_compare_and_swap to do an atomic load.  */\n+      while (!__sync_bool_compare_and_swap (&u->lines, lines, lines))\n+\tlines = u->lines;\n+    }\n+\n+  new_data = 0;\n+  if (lines == NULL)\n+    {\n+      size_t function_addrs_count;\n+      struct line_header lhdr;\n+      size_t count;\n+\n+      /* We have never read the line information for this unit.  Read\n+\t it now.  */\n+\n+      function_addrs = NULL;\n+      function_addrs_count = 0;\n+      if (read_line_info (state, ddata, error_callback, data, entry->u, &lhdr,\n+\t\t\t  &lines, &count))\n+\t{\n+\t  read_function_info (state, ddata, &lhdr, error_callback, data,\n+\t\t\t      entry->u, &ddata->fvec, &function_addrs,\n+\t\t\t      &function_addrs_count);\n+\t  free_line_header (state, &lhdr, error_callback, data);\n+\t  new_data = 1;\n+\t}\n+\n+      /* Atomically store the information we just read into the unit.\n+\t If another thread is simultaneously writing, it presumably\n+\t read the same information, and we don't care which one we\n+\t wind up with; we just leak the other one.  We do have to\n+\t write the lines field last, so that the acquire-loads above\n+\t ensure that the other fields are set.  */\n+\n+      if (!state->threaded)\n+\t{\n+\t  u->lines_count = count;\n+\t  u->function_addrs = function_addrs;\n+\t  u->function_addrs_count = function_addrs_count;\n+\t  u->lines = lines;\n+\t}\n+      else\n+\t{\n+\t  __sync_bool_compare_and_swap (&u->lines_count, 0, count);\n+\t  __sync_bool_compare_and_swap (&u->function_addrs, NULL,\n+\t\t\t\t\tfunction_addrs);\n+\t  __sync_bool_compare_and_swap (&u->function_addrs_count, 0,\n+\t\t\t\t\tfunction_addrs_count);\n+\t  __sync_bool_compare_and_swap (&u->lines, NULL, lines);\n+\t}\n+    }\n+\n+  /* Now all fields of U have been initialized.  */\n+\n+  if (lines == (struct line *) (uintptr_t) -1)\n+    {\n+      /* If reading the line number information failed in some way,\n+\t try again to see if there is a better compilation unit for\n+\t this PC.  */\n+      if (new_data)\n+\tdwarf_fileline (state, pc, callback, error_callback, data);\n+      return callback (data, pc, NULL, 0, NULL);\n+    }\n+\n+  /* Search for PC within this unit.  */\n+\n+  ln = (struct line *) bsearch (&pc, lines, entry->u->lines_count,\n+\t\t\t\tsizeof (struct line), line_search);\n+  if (ln == NULL)\n+    {\n+      error_callback (data, \"inconsistent DWARF line number info\", 0);\n+      return 0;\n+    }\n+\n+  /* Search for function name within this unit.  */\n+\n+  if (entry->u->function_addrs_count == 0)\n+    return callback (data, pc, ln->filename, ln->lineno, NULL);\n+\n+  function_addrs = ((struct function_addrs *)\n+\t\t    bsearch (&pc, entry->u->function_addrs,\n+\t\t\t     entry->u->function_addrs_count,\n+\t\t\t     sizeof (struct function_addrs),\n+\t\t\t     function_addrs_search));\n+  if (function_addrs == NULL)\n+    return callback (data, pc, ln->filename, ln->lineno, NULL);\n+\n+  /* If there are multiple function ranges that contain PC, use the\n+     last one, in order to produce predictable results.  */\n+\n+  while (((size_t) (function_addrs - entry->u->function_addrs + 1)\n+\t  < entry->u->function_addrs_count)\n+\t && pc >= (function_addrs + 1)->low\n+\t && pc < (function_addrs + 1)->high)\n+    ++function_addrs;\n+\n+  function = function_addrs->function;\n+\n+  filename = ln->filename;\n+  lineno = ln->lineno;\n+\n+  ret = report_inlined_functions (pc, function, callback, data,\n+\t\t\t\t  &filename, &lineno);\n+  if (ret != 0)\n+    return ret;\n+\n+  return callback (data, pc, filename, lineno, function->name);\n+}\n+\n+/* Build our data structures from the .debug_info and .debug_line\n+   sections.  Set *FILELINE_FN and *FILELINE_DATA.  Return 1 on\n+   success, 0 on failure.  */\n+\n+int\n+backtrace_dwarf_initialize (struct backtrace_state *state,\n+\t\t\t    const unsigned char *dwarf_info,\n+\t\t\t    size_t dwarf_info_size,\n+\t\t\t    const unsigned char *dwarf_line,\n+\t\t\t    size_t dwarf_line_size,\n+\t\t\t    const unsigned char *dwarf_abbrev,\n+\t\t\t    size_t dwarf_abbrev_size,\n+\t\t\t    const unsigned char *dwarf_ranges,\n+\t\t\t    size_t dwarf_ranges_size,\n+\t\t\t    const unsigned char *dwarf_str,\n+\t\t\t    size_t dwarf_str_size,\n+\t\t\t    int is_bigendian,\n+\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t    void *data, fileline *fileline_fn)\n+{\n+  struct unit_addrs_vector addrs_vec;\n+  struct unit_addrs *addrs;\n+  size_t addrs_count;\n+  struct dwarf_data *fdata;\n+\n+  if (!build_address_map (state, dwarf_info, dwarf_info_size, dwarf_abbrev,\n+\t\t\t  dwarf_abbrev_size, dwarf_ranges, dwarf_ranges_size,\n+\t\t\t  dwarf_str, dwarf_str_size, is_bigendian,\n+\t\t\t  error_callback, data, &addrs_vec))\n+    return 0;\n+\n+  if (!backtrace_vector_release (state, &addrs_vec.vec, error_callback, data))\n+    return 0;\n+  addrs = (struct unit_addrs *) addrs_vec.vec.base;\n+  addrs_count = addrs_vec.count;\n+  qsort (addrs, addrs_count, sizeof (struct unit_addrs), unit_addrs_compare);\n+\n+  fdata = ((struct dwarf_data *)\n+\t   backtrace_alloc (state, sizeof (struct dwarf_data),\n+\t\t\t    error_callback, data));\n+  if (fdata == NULL)\n+    return 0;\n+\n+  fdata->addrs = addrs;\n+  fdata->addrs_count = addrs_count;\n+  fdata->dwarf_info = dwarf_info;\n+  fdata->dwarf_info_size = dwarf_info_size;\n+  fdata->dwarf_line = dwarf_line;\n+  fdata->dwarf_line_size = dwarf_line_size;\n+  fdata->dwarf_ranges = dwarf_ranges;\n+  fdata->dwarf_ranges_size = dwarf_ranges_size;\n+  fdata->dwarf_str = dwarf_str;\n+  fdata->dwarf_str_size = dwarf_str_size;\n+  fdata->is_bigendian = is_bigendian;\n+  memset (&fdata->fvec, 0, sizeof fdata->fvec);\n+\n+  state->fileline_data = fdata;\n+\n+  *fileline_fn = dwarf_fileline;\n+\n+  return 1;\n+}"}, {"sha": "0c0c8eb62e6e2a79b3a111629465e95a923888c2", "filename": "libbacktrace/elf.c", "status": "added", "additions": 688, "deletions": 0, "changes": 688, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,688 @@\n+/* elf.c -- Get debug data from an ELF file for backtraces.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* The configure script must tell us whether we are 32-bit or 64-bit\n+   ELF.  We could make this code test and support either possibility,\n+   but there is no point.  This code only works for the currently\n+   running executable, which means that we know the ELF mode at\n+   configure mode.  */\n+\n+#if BACKTRACE_ELF_SIZE != 32 && BACKTRACE_ELF_SIZE != 64\n+#error \"Unknown BACKTRACE_ELF_SIZE\"\n+#endif\n+\n+/* Basic types.  */\n+\n+typedef uint16_t Elf_Half;\n+typedef uint32_t Elf_Word;\n+typedef int32_t  Elf_Sword;\n+\n+#if BACKTRACE_ELF_SIZE == 32\n+\n+typedef uint32_t Elf_Addr;\n+typedef uint32_t Elf_Off;\n+\n+typedef uint32_t Elf_WXword;\n+\n+#else\n+\n+typedef uint64_t Elf_Addr;\n+typedef uint64_t Elf_Off;\n+typedef uint64_t Elf_Xword;\n+typedef int64_t  Elf_Sxword;\n+\n+typedef uint64_t Elf_WXword;\n+\n+#endif\n+\n+/* Data structures and associated constants.  */\n+\n+#define EI_NIDENT 16\n+\n+typedef struct {\n+  unsigned char\te_ident[EI_NIDENT];\t/* ELF \"magic number\" */\n+  Elf_Half\te_type;\t\t\t/* Identifies object file type */\n+  Elf_Half\te_machine;\t\t/* Specifies required architecture */\n+  Elf_Word\te_version;\t\t/* Identifies object file version */\n+  Elf_Addr\te_entry;\t\t/* Entry point virtual address */\n+  Elf_Off\te_phoff;\t\t/* Program header table file offset */\n+  Elf_Off\te_shoff;\t\t/* Section header table file offset */\n+  Elf_Word\te_flags;\t\t/* Processor-specific flags */\n+  Elf_Half\te_ehsize;\t\t/* ELF header size in bytes */\n+  Elf_Half\te_phentsize;\t\t/* Program header table entry size */\n+  Elf_Half\te_phnum;\t\t/* Program header table entry count */\n+  Elf_Half\te_shentsize;\t\t/* Section header table entry size */\n+  Elf_Half\te_shnum;\t\t/* Section header table entry count */\n+  Elf_Half\te_shstrndx;\t\t/* Section header string table index */\n+} Elf_Ehdr;\n+\n+#define EI_MAG0 0\n+#define EI_MAG1 1\n+#define EI_MAG2 2\n+#define EI_MAG3 3\n+#define EI_CLASS 4\n+#define EI_DATA 5\n+#define EI_VERSION 6\n+\n+#define ELFMAG0 0x7f\n+#define ELFMAG1 'E'\n+#define ELFMAG2 'L'\n+#define ELFMAG3 'F'\n+\n+#define ELFCLASS32 1\n+#define ELFCLASS64 2\n+\n+#define ELFDATA2LSB 1\n+#define ELFDATA2MSB 2\n+\n+#define EV_CURRENT 1\n+\n+typedef struct {\n+  Elf_Word\tsh_name;\t\t/* Section name, index in string tbl */\n+  Elf_Word\tsh_type;\t\t/* Type of section */\n+  Elf_WXword\tsh_flags;\t\t/* Miscellaneous section attributes */\n+  Elf_Addr\tsh_addr;\t\t/* Section virtual addr at execution */\n+  Elf_Off\tsh_offset;\t\t/* Section file offset */\n+  Elf_WXword\tsh_size;\t\t/* Size of section in bytes */\n+  Elf_Word\tsh_link;\t\t/* Index of another section */\n+  Elf_Word\tsh_info;\t\t/* Additional section information */\n+  Elf_WXword\tsh_addralign;\t\t/* Section alignment */\n+  Elf_WXword\tsh_entsize;\t\t/* Entry size if section holds table */\n+} Elf_Shdr;\n+\n+#define SHN_LORESERVE\t0xFF00\t\t/* Begin range of reserved indices */\n+#define SHN_XINDEX\t0xFFFF\t\t/* Section index is held elsewhere */\n+\n+#define SHT_SYMTAB 2\n+#define SHT_STRTAB 3\n+#define SHT_DYNSYM 11\n+\n+#if BACKTRACE_ELF_SIZE == 32\n+\n+typedef struct\n+{\n+  Elf_Word\tst_name;\t\t/* Symbol name, index in string tbl */\n+  Elf_Addr\tst_value;\t\t/* Symbol value */\n+  Elf_Word\tst_size;\t\t/* Symbol size */\n+  unsigned char\tst_info;\t\t/* Symbol binding and type */\n+  unsigned char\tst_other;\t\t/* Visibility and other data */\n+  Elf_Half\tst_shndx;\t\t/* Symbol section index */\n+} Elf_Sym;\n+\n+#else /* BACKTRACE_ELF_SIZE != 32 */\n+\n+typedef struct\n+{\n+  Elf_Word\tst_name;\t\t/* Symbol name, index in string tbl */\n+  unsigned char\tst_info;\t\t/* Symbol binding and type */\n+  unsigned char\tst_other;\t\t/* Visibility and other data */\n+  Elf_Half\tst_shndx;\t\t/* Symbol section index */\n+  Elf_Addr\tst_value;\t\t/* Symbol value */\n+  Elf_Xword\tst_size;\t\t/* Symbol size */\n+} Elf_Sym;\n+\n+#endif /* BACKTRACE_ELF_SIZE != 32 */\n+\n+#define STT_FUNC 2\n+\n+/* An index of ELF sections we care about.  */\n+\n+enum debug_section\n+{\n+  DEBUG_INFO,\n+  DEBUG_LINE,\n+  DEBUG_ABBREV,\n+  DEBUG_RANGES,\n+  DEBUG_STR,\n+  DEBUG_MAX\n+};\n+\n+/* Names of sections, indexed by enum elf_section.  */\n+\n+static const char * const debug_section_names[DEBUG_MAX] =\n+{\n+  \".debug_info\",\n+  \".debug_line\",\n+  \".debug_abbrev\",\n+  \".debug_ranges\",\n+  \".debug_str\"\n+};\n+\n+/* Information we gather for the sections we care about.  */\n+\n+struct debug_section_info\n+{\n+  /* Section file offset.  */\n+  off_t offset;\n+  /* Section size.  */\n+  size_t size;\n+  /* Section contents, after read from file.  */\n+  const unsigned char *data;\n+};\n+\n+/* Information we keep for an ELF symbol.  */\n+\n+struct elf_symbol\n+{\n+  /* The name of the symbol.  */\n+  const char *name;\n+  /* The address of the symbol.  */\n+  uintptr_t address;\n+  /* The size of the symbol.  */\n+  size_t size;\n+};\n+\n+/* Information to pass to elf_syminfo.  */\n+\n+struct elf_syminfo_data\n+{\n+  /* The ELF symbols, sorted by address.  */\n+  struct elf_symbol *symbols;\n+  /* The number of symbols.  */\n+  size_t count;\n+};\n+\n+/* A dummy callback function used when we can't find any debug info.  */\n+\n+static int\n+elf_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t     uintptr_t pc ATTRIBUTE_UNUSED,\n+\t     backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t     backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no debug info in ELF executable\", -1);\n+  return 0;\n+}\n+\n+/* A dummy callback function used when we can't find a symbol\n+   table.  */\n+\n+static void\n+elf_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t    uintptr_t pc ATTRIBUTE_UNUSED,\n+\t    backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n+\t    backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no symbol table in ELF executable\", -1);\n+}\n+\n+/* Compare struct elf_symbol for qsort.  */\n+\n+static int\n+elf_symbol_compare (const void *v1, const void *v2)\n+{\n+  const struct elf_symbol *e1 = (const struct elf_symbol *) v1;\n+  const struct elf_symbol *e2 = (const struct elf_symbol *) v2;\n+\n+  if (e1->address < e2->address)\n+    return -1;\n+  else if (e1->address > e2->address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Compare a PC against an elf_symbol for bsearch.  We allocate one\n+   extra entry in the array so that this can look safely at the next\n+   entry.  */\n+\n+static int\n+elf_symbol_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct elf_symbol *entry = (const struct elf_symbol *) ventry;\n+  uintptr_t pc;\n+\n+  pc = *key;\n+  if (pc < entry->address)\n+    return -1;\n+  else if (pc >= entry->address + entry->size)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Initialize the symbol table info for elf_syminfo.  */\n+\n+static int\n+elf_initialize_syminfo (struct backtrace_state *state,\n+\t\t\tconst unsigned char *symtab_data, size_t symtab_size,\n+\t\t\tconst unsigned char *strtab, size_t strtab_size,\n+\t\t\tbacktrace_error_callback error_callback,\n+\t\t\tvoid *data, struct elf_syminfo_data *sdata)\n+{\n+  size_t sym_count;\n+  const Elf_Sym *sym;\n+  size_t elf_symbol_count;\n+  size_t elf_symbol_size;\n+  struct elf_symbol *elf_symbols;\n+  size_t i;\n+  unsigned int j;\n+\n+  sym_count = symtab_size / sizeof (Elf_Sym);\n+\n+  /* We only care about function symbols.  Count them.  */\n+  sym = (const Elf_Sym *) symtab_data;\n+  elf_symbol_count = 0;\n+  for (i = 0; i < sym_count; ++i, ++sym)\n+    {\n+      if ((sym->st_info & 0xf) == STT_FUNC)\n+\t++elf_symbol_count;\n+    }\n+\n+  elf_symbol_size = elf_symbol_count * sizeof (struct elf_symbol);\n+  elf_symbols = ((struct elf_symbol *)\n+\t\t backtrace_alloc (state, elf_symbol_size, error_callback,\n+\t\t\t\t  data));\n+  if (elf_symbols == NULL)\n+    return 0;\n+\n+  sym = (const Elf_Sym *) symtab_data;\n+  j = 0;\n+  for (i = 0; i < sym_count; ++i, ++sym)\n+    {\n+      if ((sym->st_info & 0xf) != STT_FUNC)\n+\tcontinue;\n+      if (sym->st_name >= strtab_size)\n+\t{\n+\t  error_callback (data, \"symbol string index out of range\", 0);\n+\t  backtrace_free (state, elf_symbols, elf_symbol_size, error_callback,\n+\t\t\t  data);\n+\t  return 0;\n+\t}\n+      elf_symbols[j].name = (const char *) strtab + sym->st_name;\n+      elf_symbols[j].address = sym->st_value;\n+      elf_symbols[j].size = sym->st_size;\n+      ++j;\n+    }\n+\n+  qsort (elf_symbols, elf_symbol_count, sizeof (struct elf_symbol),\n+\t elf_symbol_compare);\n+\n+  sdata->symbols = elf_symbols;\n+  sdata->count = elf_symbol_count;\n+\n+  return 1;\n+}\n+\n+/* Return the symbol name and value for a PC.  */\n+\n+static void\n+elf_syminfo (struct backtrace_state *state, uintptr_t pc,\n+\t     backtrace_syminfo_callback callback,\n+\t     backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t     void *data)\n+{\n+  struct elf_syminfo_data *edata;\n+  struct elf_symbol *sym;\n+\n+  edata = (struct elf_syminfo_data *) state->syminfo_data;\n+  sym = ((struct elf_symbol *)\n+\t bsearch (&pc, edata->symbols, edata->count,\n+\t\t  sizeof (struct elf_symbol), elf_symbol_search));\n+  if (sym == NULL)\n+    callback (data, pc, NULL, 0);\n+  else\n+    callback (data, pc, sym->name, sym->address);\n+}\n+\n+/* Initialize the backtrace data we need from an ELF executable.  At\n+   the ELF level, all we need to do is find the debug info\n+   sections.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state, int descriptor,\n+\t\t      backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  struct backtrace_view ehdr_view;\n+  Elf_Ehdr ehdr;\n+  off_t shoff;\n+  unsigned int shnum;\n+  unsigned int shstrndx;\n+  struct backtrace_view shdrs_view;\n+  int shdrs_view_valid;\n+  const Elf_Shdr *shdrs;\n+  const Elf_Shdr *shstrhdr;\n+  size_t shstr_size;\n+  off_t shstr_off;\n+  struct backtrace_view names_view;\n+  int names_view_valid;\n+  const char *names;\n+  unsigned int symtab_shndx;\n+  unsigned int dynsym_shndx;\n+  unsigned int i;\n+  struct debug_section_info sections[DEBUG_MAX];\n+  struct backtrace_view symtab_view;\n+  int symtab_view_valid;\n+  struct backtrace_view strtab_view;\n+  int strtab_view_valid;\n+  off_t min_offset;\n+  off_t max_offset;\n+  struct backtrace_view debug_view;\n+  int debug_view_valid;\n+\n+  shdrs_view_valid = 0;\n+  names_view_valid = 0;\n+  symtab_view_valid = 0;\n+  strtab_view_valid = 0;\n+  debug_view_valid = 0;\n+\n+  if (!backtrace_get_view (state, descriptor, 0, sizeof ehdr, error_callback,\n+\t\t\t   data, &ehdr_view))\n+    goto fail;\n+\n+  memcpy (&ehdr, ehdr_view.data, sizeof ehdr);\n+\n+  backtrace_release_view (state, &ehdr_view, error_callback, data);\n+\n+  if (ehdr.e_ident[EI_MAG0] != ELFMAG0\n+      || ehdr.e_ident[EI_MAG1] != ELFMAG1\n+      || ehdr.e_ident[EI_MAG2] != ELFMAG2\n+      || ehdr.e_ident[EI_MAG3] != ELFMAG3)\n+    {\n+      error_callback (data, \"executable file is not ELF\", 0);\n+      goto fail;\n+    }\n+  if (ehdr.e_ident[EI_VERSION] != EV_CURRENT)\n+    {\n+      error_callback (data, \"executable file is unrecognized ELF version\", 0);\n+      goto fail;\n+    }\n+\n+#if BACKTRACE_ELF_SIZE == 32\n+#define BACKTRACE_ELFCLASS ELFCLASS32\n+#else\n+#define BACKTRACE_ELFCLASS ELFCLASS64\n+#endif\n+\n+  if (ehdr.e_ident[EI_CLASS] != BACKTRACE_ELFCLASS)\n+    {\n+      error_callback (data, \"executable file is unexpected ELF class\", 0);\n+      goto fail;\n+    }\n+\n+  if (ehdr.e_ident[EI_DATA] != ELFDATA2LSB\n+      && ehdr.e_ident[EI_DATA] != ELFDATA2MSB)\n+    {\n+      error_callback (data, \"executable file has unknown endianness\", 0);\n+      goto fail;\n+    }\n+\n+  shoff = ehdr.e_shoff;\n+  shnum = ehdr.e_shnum;\n+  shstrndx = ehdr.e_shstrndx;\n+\n+  if ((shnum == 0 || shstrndx == SHN_XINDEX)\n+      && shoff != 0)\n+    {\n+      struct backtrace_view shdr_view;\n+      const Elf_Shdr *shdr;\n+\n+      if (!backtrace_get_view (state, descriptor, shoff, sizeof shdr,\n+\t\t\t       error_callback, data, &shdr_view))\n+\tgoto fail;\n+\n+      shdr = (const Elf_Shdr *) shdr_view.data;\n+\n+      if (shnum == 0)\n+\tshnum = shdr->sh_size;\n+\n+      if (shstrndx == SHN_XINDEX)\n+\t{\n+\t  shstrndx = shdr->sh_link;\n+\n+\t  /* Versions of the GNU binutils between 2.12 and 2.18 did\n+\t     not handle objects with more than SHN_LORESERVE sections\n+\t     correctly.  All large section indexes were offset by\n+\t     0x100.  There is more information at\n+\t     http://sourceware.org/bugzilla/show_bug.cgi?id-5900 .\n+\t     Fortunately these object files are easy to detect, as the\n+\t     GNU binutils always put the section header string table\n+\t     near the end of the list of sections.  Thus if the\n+\t     section header string table index is larger than the\n+\t     number of sections, then we know we have to subtract\n+\t     0x100 to get the real section index.  */\n+\t  if (shstrndx >= shnum && shstrndx >= SHN_LORESERVE + 0x100)\n+\t    shstrndx -= 0x100;\n+\t}\n+\n+      backtrace_release_view (state, &shdr_view, error_callback, data);\n+    }\n+\n+  /* To translate PC to file/line when using DWARF, we need to find\n+     the .debug_info and .debug_line sections.  */\n+\n+  /* Read the section headers, skipping the first one.  */\n+\n+  if (!backtrace_get_view (state, descriptor, shoff + sizeof (Elf_Shdr),\n+\t\t\t   (shnum - 1) * sizeof (Elf_Shdr),\n+\t\t\t   error_callback, data, &shdrs_view))\n+    goto fail;\n+  shdrs_view_valid = 1;\n+  shdrs = (const Elf_Shdr *) shdrs_view.data;\n+\n+  /* Read the section names.  */\n+\n+  shstrhdr = &shdrs[shstrndx - 1];\n+  shstr_size = shstrhdr->sh_size;\n+  shstr_off = shstrhdr->sh_offset;\n+\n+  if (!backtrace_get_view (state, descriptor, shstr_off, shstr_size,\n+\t\t\t   error_callback, data, &names_view))\n+    goto fail;\n+  names_view_valid = 1;\n+  names = (const char *) names_view.data;\n+\n+  symtab_shndx = 0;\n+  dynsym_shndx = 0;\n+\n+  memset (sections, 0, sizeof sections);\n+  for (i = 1; i < shnum; ++i)\n+    {\n+      const Elf_Shdr *shdr;\n+      unsigned int sh_name;\n+      const char *name;\n+      int j;\n+\n+      shdr = &shdrs[i - 1];\n+\n+      if (shdr->sh_type == SHT_SYMTAB)\n+\tsymtab_shndx = i;\n+      else if (shdr->sh_type == SHT_DYNSYM)\n+\tdynsym_shndx = i;\n+\n+      sh_name = shdr->sh_name;\n+      if (sh_name >= shstr_size)\n+\t{\n+\t  error_callback (data, \"ELF section name out of range\", 0);\n+\t  goto fail;\n+\t}\n+\n+      name = names + sh_name;\n+\n+      for (j = 0; j < (int) DEBUG_MAX; ++j)\n+\t{\n+\t  if (strcmp (name, debug_section_names[j]) == 0)\n+\t    {\n+\t      sections[j].offset = shdr->sh_offset;\n+\t      sections[j].size = shdr->sh_size;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (symtab_shndx == 0)\n+    symtab_shndx = dynsym_shndx;\n+  if (symtab_shndx == 0)\n+    {\n+      state->syminfo_fn = elf_nosyms;\n+      state->syminfo_data = NULL;\n+    }\n+  else\n+    {\n+      const Elf_Shdr *symtab_shdr;\n+      unsigned int strtab_shndx;\n+      const Elf_Shdr *strtab_shdr;\n+      struct elf_syminfo_data *sdata;\n+\n+      symtab_shdr = &shdrs[symtab_shndx - 1];\n+      strtab_shndx = symtab_shdr->sh_link;\n+      if (strtab_shndx >= shnum)\n+\t{\n+\t  error_callback (data,\n+\t\t\t  \"ELF symbol table strtab link out of range\", 0);\n+\t  goto fail;\n+\t}\n+      strtab_shdr = &shdrs[strtab_shndx - 1];\n+\n+      if (!backtrace_get_view (state, descriptor, symtab_shdr->sh_offset,\n+\t\t\t       symtab_shdr->sh_size, error_callback, data,\n+\t\t\t       &symtab_view))\n+\tgoto fail;\n+      symtab_view_valid = 1;\n+\n+      if (!backtrace_get_view (state, descriptor, strtab_shdr->sh_offset,\n+\t\t\t       strtab_shdr->sh_size, error_callback, data,\n+\t\t\t       &strtab_view))\n+\tgoto fail;\n+      strtab_view_valid = 1;\n+\n+      sdata = ((struct elf_syminfo_data *)\n+\t       backtrace_alloc (state, sizeof *sdata, error_callback, data));\n+      if (sdata == NULL)\n+\tgoto fail;\n+\n+      if (!elf_initialize_syminfo (state,\n+\t\t\t\t   symtab_view.data, symtab_shdr->sh_size,\n+\t\t\t\t   strtab_view.data, strtab_shdr->sh_size,\n+\t\t\t\t   error_callback, data, sdata))\n+\t{\n+\t  backtrace_free (state, sdata, sizeof *sdata, error_callback, data);\n+\t  goto fail;\n+\t}\n+\n+      /* We no longer need the symbol table, but we hold on to the\n+\t string table permanently.  */\n+      backtrace_release_view (state, &symtab_view, error_callback, data);\n+\n+      state->syminfo_fn = elf_syminfo;\n+      state->syminfo_data = sdata;\n+    }\n+\n+  /* FIXME: Need to handle compressed debug sections.  */\n+\n+  backtrace_release_view (state, &shdrs_view, error_callback, data);\n+  shdrs_view_valid = 0;\n+  backtrace_release_view (state, &names_view, error_callback, data);\n+  names_view_valid = 0;\n+\n+  /* Read all the debug sections in a single view, since they are\n+     probably adjacent in the file.  We never release this view.  */\n+\n+  min_offset = 0;\n+  max_offset = 0;\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    {\n+      off_t end;\n+\n+      if (min_offset == 0 || sections[i].offset < min_offset)\n+\tmin_offset = sections[i].offset;\n+      end = sections[i].offset + sections[i].size;\n+      if (end > max_offset)\n+\tmax_offset = end;\n+    }\n+  if (min_offset == 0 || max_offset == 0)\n+    {\n+      if (!backtrace_close (descriptor, error_callback, data))\n+\tgoto fail;\n+      state->fileline_fn = elf_nodebug;\n+      state->fileline_data = NULL;\n+      return 1;\n+    }\n+\n+  if (!backtrace_get_view (state, descriptor, min_offset,\n+\t\t\t   max_offset - min_offset,\n+\t\t\t   error_callback, data, &debug_view))\n+    goto fail;\n+  debug_view_valid = 1;\n+\n+  /* We've read all we need from the executable.  */\n+  if (!backtrace_close (descriptor, error_callback, data))\n+    goto fail;\n+  descriptor = -1;\n+\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    sections[i].data = ((const unsigned char *) debug_view.data\n+\t\t\t+ (sections[i].offset - min_offset));\n+\n+  if (!backtrace_dwarf_initialize (state,\n+\t\t\t\t   sections[DEBUG_INFO].data,\n+\t\t\t\t   sections[DEBUG_INFO].size,\n+\t\t\t\t   sections[DEBUG_LINE].data,\n+\t\t\t\t   sections[DEBUG_LINE].size,\n+\t\t\t\t   sections[DEBUG_ABBREV].data,\n+\t\t\t\t   sections[DEBUG_ABBREV].size,\n+\t\t\t\t   sections[DEBUG_RANGES].data,\n+\t\t\t\t   sections[DEBUG_RANGES].size,\n+\t\t\t\t   sections[DEBUG_STR].data,\n+\t\t\t\t   sections[DEBUG_STR].size,\n+\t\t\t\t   ehdr.e_ident[EI_DATA] == ELFDATA2MSB,\n+\t\t\t\t   error_callback, data, fileline_fn))\n+    goto fail;\n+\n+  return 1;\n+\n+ fail:\n+  if (shdrs_view_valid)\n+    backtrace_release_view (state, &shdrs_view, error_callback, data);\n+  if (names_view_valid)\n+    backtrace_release_view (state, &names_view, error_callback, data);\n+  if (symtab_view_valid)\n+    backtrace_release_view (state, &symtab_view, error_callback, data);\n+  if (strtab_view_valid)\n+    backtrace_release_view (state, &strtab_view, error_callback, data);\n+  if (debug_view_valid)\n+    backtrace_release_view (state, &debug_view, error_callback, data);\n+  if (descriptor != -1)\n+    backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}"}, {"sha": "de2a58993eb065e4921ee6cf79b3aa9b9315b1b5", "filename": "libbacktrace/fileline.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Ffileline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Ffileline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Ffileline.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,154 @@\n+/* fileline.c -- Get file and line number information in a backtrace.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Initialize the fileline information from the executable.  Returns 1\n+   on success, 0 on failure.  */\n+\n+static int\n+fileline_initialize (struct backtrace_state *state,\n+\t\t     backtrace_error_callback error_callback, void *data)\n+{\n+  int failed;\n+  fileline fileline_fn;\n+  int descriptor;\n+\n+  failed = state->fileline_initialization_failed;\n+\n+  if (state->threaded)\n+    {\n+      /* Use __sync_bool_compare_and_swap to do an atomic load.  */\n+      while (!__sync_bool_compare_and_swap\n+\t     (&state->fileline_initialization_failed, failed, failed))\n+\tfailed = state->fileline_initialization_failed;\n+    }\n+\n+  if (failed)\n+    {\n+      error_callback (data, \"failed to read executable information\", 0);\n+      return 0;\n+    }\n+\n+  fileline_fn = state->fileline_fn;\n+  if (state->threaded)\n+    {\n+      while (!__sync_bool_compare_and_swap (&state->fileline_fn, fileline_fn,\n+\t\t\t\t\t    fileline_fn))\n+\tfileline_fn = state->fileline_fn;\n+    }\n+  if (fileline_fn != NULL)\n+    return 1;\n+\n+  /* We have not initialized the information.  Do it now.  */\n+\n+  if (state->filename != NULL)\n+    descriptor = backtrace_open (state->filename, error_callback, data);\n+  else\n+    descriptor = backtrace_open (\"/proc/self/exe\", error_callback, data);\n+  if (descriptor < 0)\n+    failed = 1;\n+\n+  if (!failed)\n+    {\n+      if (!backtrace_initialize (state, descriptor, error_callback, data,\n+\t\t\t\t &fileline_fn))\n+\tfailed = 1;\n+    }\n+\n+  if (failed)\n+    {\n+      if (!state->threaded)\n+\tstate->fileline_initialization_failed = 1;\n+      else\n+\t__sync_bool_compare_and_swap (&state->fileline_initialization_failed,\n+\t\t\t\t      0, failed);\n+      return 0;\n+    }\n+\n+  if (!state->threaded)\n+    state->fileline_fn = fileline_fn;\n+  else\n+    {\n+      __sync_bool_compare_and_swap (&state->fileline_fn, NULL, fileline_fn);\n+\n+      /* At this point we know that state->fileline_fn is not NULL.\n+\t Either we stored our value, or some other thread stored its\n+\t value.  If some other thread stored its value, we leak the\n+\t one we just initialized.  Either way, state->fileline_fn is\n+\t initialized.  The compare_and_swap is a full memory barrier,\n+\t so we should have full access to that value even if it was\n+\t created by another thread.  */\n+    }\n+\n+  return 1;\n+}\n+\n+/* Given a PC, find the file name, line number, and function name.  */\n+\n+int\n+backtrace_pcinfo (struct backtrace_state *state, uintptr_t pc,\n+\t\t  backtrace_full_callback callback,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  if (!fileline_initialize (state, error_callback, data))\n+    return 0;\n+\n+  if (state->fileline_initialization_failed)\n+    return 0;\n+\n+  return state->fileline_fn (state, pc, callback, error_callback, data);\n+}\n+\n+/* Given a PC, find the symbol for it, and its value.  */\n+\n+int\n+backtrace_syminfo (struct backtrace_state *state, uintptr_t pc,\n+\t\t   backtrace_syminfo_callback callback,\n+\t\t   backtrace_error_callback error_callback, void *data)\n+{\n+  if (!fileline_initialize (state, error_callback, data))\n+    return 0;\n+\n+  if (state->fileline_initialization_failed)\n+    return 0;\n+\n+  state->syminfo_fn (state, pc, callback, error_callback, data);\n+  return 1;\n+}"}, {"sha": "0a656f75ba1f2e029785eb31427562fdd2162e91", "filename": "libbacktrace/filetype.awk", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Ffiletype.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Ffiletype.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Ffiletype.awk?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,3 @@\n+# An awk script to determine the type of a file.\n+/\\177ELF\\001/ { if (NR == 1) { print \"elf32\"; exit } }\n+/\\177ELF\\002/ { if (NR == 1) { print \"elf64\"; exit } }"}, {"sha": "4a7407a61d23856fe5cffd9dd1cf5923fe80d33c", "filename": "libbacktrace/internal.h", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Finternal.h?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,235 @@\n+/* internal.h -- Internal header file for stack backtrace library.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#ifndef BACKTRACE_INTERNAL_H\n+#define BACKTRACE_INTERNAL_H\n+\n+/* We assume that <sys/types.h> and \"backtrace.h\" have already been\n+   included.  */\n+\n+#ifndef GCC_VERSION\n+# define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n+#endif\n+\n+#if (GCC_VERSION < 2007)\n+# define __attribute__(x)\n+#endif\n+\n+#ifndef ATTRIBUTE_UNUSED\n+# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n+#endif\n+\n+#ifndef ATTRIBUTE_MALLOC\n+# if (GCC_VERSION >= 2096)\n+#  define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))\n+# else\n+#  define ATTRIBUTE_MALLOC\n+# endif\n+#endif\n+\n+#ifndef HAVE_SYNC_FUNCTIONS\n+\n+/* Define out the sync functions.  These should never be called if\n+   they are not available.  */\n+\n+#define __sync_bool_compare_and_swap(A, B, C) (abort(), 1)\n+#define __sync_lock_test_and_set(A, B) (abort(), 0)\n+#define __sync_lock_release(A) abort()\n+\n+#endif /* !defined(HAVE_SYNC_FUNCTIONS) */\n+\n+/* The type of the function that collects file/line information.  This\n+   is like backtrace_pcinfo.  */\n+\n+typedef int (*fileline) (struct backtrace_state *state, uintptr_t pc,\n+\t\t\t backtrace_full_callback callback,\n+\t\t\t backtrace_error_callback error_callback, void *data);\n+\n+/* The type of the function that collects symbol information.  This is\n+   like backtrace_syminfo.  */\n+\n+typedef void (*syminfo) (struct backtrace_state *state, uintptr_t pc,\n+\t\t\t backtrace_syminfo_callback callback,\n+\t\t\t backtrace_error_callback error_callback, void *data);\n+\n+/* What the backtrace state pointer points to.  */\n+\n+struct backtrace_state\n+{\n+  /* The name of the executable.  */\n+  const char *filename;\n+  /* Non-zero if threaded.  */\n+  int threaded;\n+  /* The master lock for fileline_fn, fileline_data, syminfo_fn,\n+     syminfo_data, fileline_initialization_failed and everything the\n+     data pointers point to.  */\n+  void *lock;\n+  /* The function that returns file/line information.  */\n+  fileline fileline_fn;\n+  /* The data to pass to FILELINE_FN.  */\n+  void *fileline_data;\n+  /* The function that returns symbol information.  */\n+  syminfo syminfo_fn;\n+  /* The data to pass to SYMINFO_FN.  */\n+  void *syminfo_data;\n+  /* Whether initializing the file/line information failed.  */\n+  int fileline_initialization_failed;\n+  /* The lock for the freelist.  */\n+  int lock_alloc;\n+  /* The freelist when using mmap.  */\n+  struct backtrace_freelist_struct *freelist;\n+};\n+\n+/* Open a file for reading.  Returns -1 on error.  */\n+extern int backtrace_open (const char *filename,\n+\t\t\t   backtrace_error_callback error_callback,\n+\t\t\t   void *data);\n+\n+/* A view of the contents of a file.  This supports mmap when\n+   available.  A view will remain in memory even after backtrace_close\n+   is called on the file descriptor from which the view was\n+   obtained.  */\n+\n+struct backtrace_view\n+{\n+  /* The data that the caller requested.  */\n+  const void *data;\n+  /* The base of the view.  */\n+  void *base;\n+  /* The total length of the view.  */\n+  size_t len;\n+};\n+\n+/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  Store the\n+   result in *VIEW.  Returns 1 on success, 0 on error.  */\n+extern int backtrace_get_view (struct backtrace_state *state, int descriptor,\n+\t\t\t       off_t offset, size_t size,\n+\t\t\t       backtrace_error_callback error_callback,\n+\t\t\t       void *data, struct backtrace_view *view);\n+\n+/* Release a view created by backtrace_get_view.  */\n+extern void backtrace_release_view (struct backtrace_state *state,\n+\t\t\t\t    struct backtrace_view *view,\n+\t\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t\t    void *data);\n+\n+/* Close a file opened by backtrace_open.  Returns 1 on success, 0 on\n+   error.  */\n+\n+extern int backtrace_close (int descriptor,\n+\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t    void *data);\n+\n+/* Allocate memory.  This is like malloc.  */\n+\n+extern void *backtrace_alloc (struct backtrace_state *state, size_t size,\n+\t\t\t      backtrace_error_callback error_callback,\n+\t\t\t      void *data) ATTRIBUTE_MALLOC;\n+\n+/* Free memory allocated by backtrace_alloc.  */\n+\n+extern void backtrace_free (struct backtrace_state *state, void *mem,\n+\t\t\t    size_t size,\n+\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t    void *data);\n+\n+/* A growable vector of some struct.  This is used for more efficient\n+   allocation when we don't know the final size of some group of data\n+   that we want to represent as an array.  */\n+\n+struct backtrace_vector\n+{\n+  /* The base of the vector.  */\n+  void *base;\n+  /* The number of bytes in the vector.  */\n+  size_t size;\n+  /* The number of bytes available at the current allocation.  */\n+  size_t alc;\n+};\n+\n+/* Grow VEC by SIZE bytes.  Return a pointer to the newly allocated\n+   bytes.  Note that this may move the entire vector to a new memory\n+   location.  Returns NULL on failure.  */\n+\n+extern void *backtrace_vector_grow (struct backtrace_state *state, size_t size,\n+\t\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t\t    void *data,\n+\t\t\t\t    struct backtrace_vector *vec);\n+\n+/* Finish the current allocation on VEC.  Prepare to start a new\n+   allocation.  The finished allocation will never be freed.  */\n+\n+extern void backtrace_vector_finish (struct backtrace_state *state,\n+\t\t\t\t     struct backtrace_vector *vec);\n+\n+/* Release any extra space allocated for VEC.  Returns 1 on success, 0\n+   on failure.  */\n+\n+extern int backtrace_vector_release (struct backtrace_state *state,\n+\t\t\t\t     struct backtrace_vector *vec,\n+\t\t\t\t     backtrace_error_callback error_callback,\n+\t\t\t\t     void *data);\n+\n+/* Read initial debug data from a descriptor, and set the\n+   fileline_data, syminfo_fn, and syminfo_data fields of STATE.\n+   Return the fileln_fn field in *FILELN_FN--this is done this way so\n+   that the synchronization code is only implemented once.  This is\n+   called after the descriptor has first been opened.  It will close\n+   the descriptor if it is no longer needed.  Returns 1 on success, 0\n+   on error.  There will be multiple implementations of this function,\n+   for different file formats.  Each system will compile the\n+   appropriate one.  */\n+\n+extern int backtrace_initialize (struct backtrace_state *state,\n+\t\t\t\t int descriptor,\n+\t\t\t\t backtrace_error_callback error_callback,\n+\t\t\t\t void *data,\n+\t\t\t\t fileline *fileline_fn);\n+\n+/* Prepare to read file/line information from DWARF debug data.  */\n+\n+extern int backtrace_dwarf_initialize (struct backtrace_state *state,\n+\t\t\t\t       const unsigned char* dwarf_info,\n+\t\t\t\t       size_t dwarf_info_size,\n+\t\t\t\t       const unsigned char *dwarf_line,\n+\t\t\t\t       size_t dwarf_line_size,\n+\t\t\t\t       const unsigned char *dwarf_abbrev,\n+\t\t\t\t       size_t dwarf_abbrev_size,\n+\t\t\t\t       const unsigned char *dwarf_ranges,\n+\t\t\t\t       size_t dwarf_range_size,\n+\t\t\t\t       const unsigned char *dwarf_str,\n+\t\t\t\t       size_t dwarf_str_size,\n+\t\t\t\t       int is_bigendian,\n+\t\t\t\t       backtrace_error_callback error_callback,\n+\t\t\t\t       void *data, fileline *fileline_fn);\n+\n+#endif"}, {"sha": "e8e98617d9a3f8badbc0c8099597624d375d6b68", "filename": "libbacktrace/mmap.c", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fmmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fmmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fmmap.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,235 @@\n+/* mmap.c -- Memory allocation with mmap.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <sys/mman.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Memory allocation on systems that provide anonymous mmap.  This\n+   permits the backtrace functions to be invoked from a signal\n+   handler, assuming that mmap is async-signal safe.  */\n+\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+\n+/* A list of free memory blocks.  */\n+\n+struct backtrace_freelist_struct\n+{\n+  /* Next on list.  */\n+  struct backtrace_freelist_struct *next;\n+  /* Size of this block, including this structure.  */\n+  size_t size;\n+};\n+\n+/* Free memory allocated by backtrace_alloc.  */\n+\n+static void\n+backtrace_free_locked (struct backtrace_state *state, void *addr, size_t size)\n+{\n+  /* Just leak small blocks.  We don't have to be perfect.  */\n+  if (size >= sizeof (struct backtrace_freelist_struct))\n+    {\n+      struct backtrace_freelist_struct *p;\n+\n+      p = (struct backtrace_freelist_struct *) addr;\n+      p->next = state->freelist;\n+      p->size = size;\n+      state->freelist = p;\n+    }\n+}\n+\n+/* Allocate memory like malloc.  */\n+\n+void *\n+backtrace_alloc (struct backtrace_state *state,\n+\t\t size_t size, backtrace_error_callback error_callback,\n+\t\t void *data)\n+{\n+  void *ret;\n+  struct backtrace_freelist_struct **pp;\n+  size_t pagesize;\n+  size_t asksize;\n+  void *page;\n+\n+  ret = NULL;\n+\n+  /* If we can acquire the lock, then see if there is space on the\n+     free list.  If we can't acquire the lock, drop straight into\n+     using mmap.  __sync_lock_test_and_set returns the old state of\n+     the lock, so we have acquired it if it returns 0.  */\n+\n+  if (!__sync_lock_test_and_set (&state->lock_alloc, 1))\n+    {\n+      for (pp = &state->freelist; *pp != NULL; pp = &(*pp)->next)\n+\t{\n+\t  if ((*pp)->size >= size)\n+\t    {\n+\t      struct backtrace_freelist_struct *p;\n+\n+\t      p = *pp;\n+\t      *pp = p->next;\n+\n+\t      /* Round for alignment; we assume that no type we care about\n+\t\t is more than 8 bytes.  */\n+\t      size = (size + 7) & ~ (size_t) 7;\n+\t      if (size < p->size)\n+\t\tbacktrace_free_locked (state, (char *) p + size,\n+\t\t\t\t       p->size - size);\n+\n+\t      ret = (void *) p;\n+\n+\t      break;\n+\t    }\n+\t}\n+\n+      __sync_lock_release (&state->lock_alloc);\n+    }\n+\n+  if (ret == NULL)\n+    {\n+      /* Allocate a new page.  */\n+\n+      pagesize = getpagesize ();\n+      asksize = (size + pagesize - 1) & ~ (pagesize - 1);\n+      page = mmap (NULL, asksize, PROT_READ | PROT_WRITE,\n+\t\t   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+      if (page == NULL)\n+\terror_callback (data, \"mmap\", errno);\n+      else\n+\t{\n+\t  size = (size + 7) & ~ (size_t) 7;\n+\t  if (size < asksize)\n+\t    backtrace_free (state, (char *) page + size, asksize - size,\n+\t\t\t    error_callback, data);\n+\n+\t  ret = page;\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n+/* Free memory allocated by backtrace_alloc.  */\n+\n+void\n+backtrace_free (struct backtrace_state *state, void *addr, size_t size,\n+\t\tbacktrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\tvoid *data ATTRIBUTE_UNUSED)\n+{\n+  /* If we can acquire the lock, add the new space to the free list.\n+     If we can't acquire the lock, just leak the memory.\n+     __sync_lock_test_and_set returns the old state of the lock, so we\n+     have acquired it if it returns 0.  */\n+  if (!__sync_lock_test_and_set (&state->lock_alloc, 1))\n+    {\n+      backtrace_free_locked (state, addr, size);\n+\n+      __sync_lock_release (&state->lock_alloc);\n+    }\n+}\n+\n+/* Grow VEC by SIZE bytes.  */\n+\n+void *\n+backtrace_vector_grow (struct backtrace_state *state,size_t size,\n+\t\t       backtrace_error_callback error_callback,\n+\t\t       void *data, struct backtrace_vector *vec)\n+{\n+  void *ret;\n+\n+  if (size > vec->alc)\n+    {\n+      size_t pagesize;\n+      size_t alc;\n+      void *base;\n+\n+      pagesize = getpagesize ();\n+      alc = vec->size + size;\n+      if (vec->size == 0)\n+\talc = 16 * size;\n+      else if (alc < pagesize)\n+\t{\n+\t  alc *= 2;\n+\t  if (alc > pagesize)\n+\t    alc = pagesize;\n+\t}\n+      else\n+\talc = (alc + pagesize - 1) & ~ (pagesize - 1);\n+      base = backtrace_alloc (state, alc, error_callback, data);\n+      if (base == NULL)\n+\treturn NULL;\n+      if (vec->base != NULL)\n+\t{\n+\t  memcpy (base, vec->base, vec->size);\n+\t  backtrace_free (state, vec->base, vec->alc, error_callback, data);\n+\t}\n+      vec->base = base;\n+      vec->alc = alc - vec->size;\n+    }\n+\n+  ret = (char *) vec->base + vec->size;\n+  vec->size += size;\n+  vec->alc -= size;\n+  return ret;\n+}\n+\n+/* Finish the current allocation on VEC.  */\n+\n+void\n+backtrace_vector_finish (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t\t struct backtrace_vector *vec)\n+{\n+  vec->base = (char *) vec->base + vec->size;\n+  vec->size = 0;\n+}\n+\n+/* Release any extra space allocated for VEC.  */\n+\n+int\n+backtrace_vector_release (struct backtrace_state *state,\n+\t\t\t  struct backtrace_vector *vec,\n+\t\t\t  backtrace_error_callback error_callback,\n+\t\t\t  void *data)\n+{\n+  backtrace_free (state, (char *) vec->base + vec->size, vec->alc,\n+\t\t  error_callback, data);\n+  vec->alc = 0;\n+  return 1;\n+}"}, {"sha": "8b46f63919630b7a09fd0c534f2a35e7984c0b47", "filename": "libbacktrace/mmapio.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fmmapio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fmmapio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fmmapio.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,98 @@\n+/* mmapio.c -- File views using mmap.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#define _GNU_SOURCE\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <sys/types.h>\n+#include <sys/mman.h>\n+#include <unistd.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* This file implements file views and memory allocation when mmap is\n+   available.  */\n+\n+/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  */\n+\n+int\n+backtrace_get_view (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t    int descriptor, off_t offset, size_t size,\n+\t\t    backtrace_error_callback error_callback,\n+\t\t    void *data, struct backtrace_view *view)\n+{\n+  size_t pagesize;\n+  unsigned int inpage;\n+  off_t pageoff;\n+  void *map;\n+\n+  pagesize = getpagesize ();\n+  inpage = offset % pagesize;\n+  pageoff = offset - inpage;\n+\n+  size += inpage;\n+  size = (size + (pagesize - 1)) & ~ (pagesize - 1);\n+\n+  map = mmap (NULL, size, PROT_READ, MAP_PRIVATE, descriptor, pageoff);\n+  if (map == MAP_FAILED)\n+    {\n+      error_callback (data, \"mmap\", errno);\n+      return 0;\n+    }\n+\n+  view->data = (char *) map + inpage;\n+  view->base = map;\n+  view->len = size;\n+\n+  return 1;\n+}\n+\n+/* Release a view read by backtrace_get_view.  */\n+\n+void\n+backtrace_release_view (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t\tstruct backtrace_view *view,\n+\t\t\tbacktrace_error_callback error_callback,\n+\t\t\tvoid *data)\n+{\n+  union {\n+    const void *cv;\n+    void *v;\n+  } const_cast;\n+\n+  const_cast.cv = view->base;\n+  if (munmap (const_cast.v, view->len) < 0)\n+    error_callback (data, \"munmap\", errno);\n+}"}, {"sha": "fea3c53d271244310acf60f17fe6c2353c59116e", "filename": "libbacktrace/nounwind.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fnounwind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fnounwind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fnounwind.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,64 @@\n+/* backtrace.c -- Entry point for stack backtrace library.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+\n+#include \"internal.h\"\n+\n+/* This source file is compiled if the unwind library is not\n+   available.  */\n+\n+int\n+backtrace (int skip ATTRIBUTE_UNUSED,\n+\t   backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t   backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data,\n+\t\t  \"no stack trace because unwind library not available\",\n+\t\t  0);\n+  return 0;\n+}\n+\n+int\n+backtrace_simple (int skip ATTRIBUTE_UNUSED,\n+\t\t  backtrace_simple_callback callback ATTRIBUTE_UNUSED,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data,\n+\t\t  \"no stack trace because unwind library not available\",\n+\t\t  0);\n+  return 0;\n+}"}, {"sha": "0b76f1e94a123b30af01aa335fd87130a192e7be", "filename": "libbacktrace/posix.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fposix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fposix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fposix.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,88 @@\n+/* posix.c -- POSIX file I/O routines for the backtrace library.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+#ifndef O_CLOEXEC\n+#define O_CLOEXEC 0\n+#endif\n+\n+#ifndef FD_CLOEXEC\n+#define FD_CLOEXEC 1\n+#endif\n+\n+/* Open a file for reading.  */\n+\n+int\n+backtrace_open (const char *filename, backtrace_error_callback error_callback,\n+\t\tvoid *data)\n+{\n+  int descriptor;\n+\n+  descriptor = open (filename, O_RDONLY | O_CLOEXEC);\n+  if (descriptor < 0)\n+    {\n+      error_callback (data, filename, errno);\n+      return -1;\n+    }\n+\n+  /* Set FD_CLOEXEC just in case the kernel does not support\n+     O_CLOEXEC. It doesn't matter if this fails for some reason.\n+     FIXME: At some point it should be safe to only do this if\n+     O_CLOEXEC == 0.  */\n+  fcntl (descriptor, F_SETFD, FD_CLOEXEC);\n+\n+  return descriptor;\n+}\n+\n+/* Close DESCRIPTOR.  */\n+\n+int\n+backtrace_close (int descriptor, backtrace_error_callback error_callback,\n+\t\t void *data)\n+{\n+  if (close (descriptor) < 0)\n+    {\n+      error_callback (data, \"close\", errno);\n+      return 0;\n+    }\n+  return 1;\n+}"}, {"sha": "2d9d76aeba7223452df0a367cddae32b3e81f73c", "filename": "libbacktrace/print.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fprint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fprint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fprint.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,94 @@\n+/* print.c -- Print the current backtrace.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Passed to callbacks.  */\n+\n+struct print_data\n+{\n+  struct backtrace_state *state;\n+  FILE *f;\n+};\n+\n+/* Print one level of a backtrace.  */\n+\n+static int\n+print_callback (void *data, uintptr_t pc, const char *filename, int lineno,\n+\t\tconst char *function)\n+{\n+  struct print_data *pdata = (struct print_data *) data;\n+\n+  fprintf (pdata->f, \"0x%lx %s\\n\\t%s:%d\\n\",\n+\t   (unsigned long) pc,\n+\t   function == NULL ? \"???\" : function,\n+\t   filename == NULL ? \"???\" : filename,\n+\t   lineno);\n+  return 0;\n+}\n+\n+/* Print errors to stderr.  */\n+\n+static void\n+error_callback (void *data, const char *msg, int errnum)\n+{\n+  struct print_data *pdata = (struct print_data *) data;\n+  const char *name;\n+\n+  name = pdata->state->filename;\n+  if (name == NULL)\n+    name = \"/proc/self/exe\";\n+  fprintf (stderr, \"%s: libbacktrace: %s\", name, msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fputc ('\\n', stderr);\n+}\n+\n+/* Print a backtrace.  */\n+\n+void\n+backtrace_print (struct backtrace_state *state, int skip, FILE *f)\n+{\n+  struct print_data data;\n+\n+  data.state = state;\n+  data.f = f;\n+  backtrace_full (state, skip + 1, print_callback, error_callback,\n+\t\t  (void *) &data);\n+}"}, {"sha": "a1eac5d06c0fbf5c69144ff37f4170f222298cdb", "filename": "libbacktrace/read.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fread.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,96 @@\n+/* read.c -- File views without mmap.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* This file implements file views when mmap is not available.  */\n+\n+/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  */\n+\n+int\n+backtrace_get_view (struct backtrace_state *state, int descriptor,\n+\t\t    off_t offset, size_t size,\n+\t\t    backtrace_error_callback error_callback,\n+\t\t    void *data, struct backtrace_view *view)\n+{\n+  ssize_t got;\n+\n+  if (lseek (descriptor, offset, SEEK_SET) < 0)\n+    {\n+      error_callback (data, \"lseek\", errno);\n+      return 0;\n+    }\n+\n+  view->base = backtrace_alloc (state, size, error_callback, data);\n+  if (view->base == NULL)\n+    return 0;\n+  view->data = view->base;\n+  view->len = size;\n+\n+  got = read (descriptor, view->base, size);\n+  if (got < 0)\n+    {\n+      error_callback (data, \"read\", errno);\n+      free (view->base);\n+      return 0;\n+    }\n+\n+  if ((size_t) got < size)\n+    {\n+      error_callback (data, \"file too short\", 0);\n+      free (view->base);\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Release a view read by backtrace_get_view.  */\n+\n+void\n+backtrace_release_view (struct backtrace_state *state,\n+\t\t\tstruct backtrace_view *view,\n+\t\t\tbacktrace_error_callback error_callback,\n+\t\t\tvoid *data)\n+{\n+  backtrace_free (state, view->base, view->len, error_callback, data);\n+  view->data = NULL;\n+  view->base = NULL;\n+}"}, {"sha": "f4e598fd5bdd6385a1e40e31d53f1dbbc5e6ae47", "filename": "libbacktrace/simple.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fsimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fsimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fsimple.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,108 @@\n+/* simple.c -- The backtrace_simple function.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include \"unwind.h\"\n+#include \"backtrace.h\"\n+\n+/* The simple_backtrace routine.  */\n+\n+/* Data passed through _Unwind_Backtrace.  */\n+\n+struct backtrace_simple_data\n+{\n+  /* Number of frames to skip.  */\n+  int skip;\n+  /* Library state.  */\n+  struct backtrace_state *state;\n+  /* Callback routine.  */\n+  backtrace_simple_callback callback;\n+  /* Error callback routine.  */\n+  backtrace_error_callback error_callback;\n+  /* Data to pass to callback routine.  */\n+  void *data;\n+  /* Value to return from backtrace.  */\n+  int ret;\n+};\n+\n+/* Unwind library callback routine.  This is passd to\n+   _Unwind_Backtrace.  */\n+\n+static _Unwind_Reason_Code\n+simple_unwind (struct _Unwind_Context *context, void *vdata)\n+{\n+  struct backtrace_simple_data *bdata = (struct backtrace_simple_data *) vdata;\n+  uintptr_t pc;\n+  int ip_before_insn = 0;\n+\n+#ifdef HAVE_GETIPINFO\n+  pc = _Unwind_GetIPInfo (context, &ip_before_insn);\n+#else\n+  pc = _Unwind_GetIP (context);\n+#endif\n+\n+  if (bdata->skip > 0)\n+    {\n+      --bdata->skip;\n+      return _URC_NO_REASON;\n+    }\n+\n+  if (!ip_before_insn)\n+    --pc;\n+\n+  bdata->ret = bdata->callback (bdata->data, pc);\n+\n+  if (bdata->ret != 0)\n+    return _URC_END_OF_STACK;\n+\n+  return _URC_NO_REASON;\n+}\n+\n+/* Get a simple stack backtrace.  */\n+\n+int\n+backtrace_simple (struct backtrace_state *state, int skip,\n+\t\t  backtrace_simple_callback callback,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  struct backtrace_simple_data bdata;\n+\n+  bdata.skip = skip + 1;\n+  bdata.state = state;\n+  bdata.callback = callback;\n+  bdata.error_callback = error_callback;\n+  bdata.data = data;\n+  bdata.ret = 0;\n+  _Unwind_Backtrace (simple_unwind, &bdata);\n+  return bdata.ret;\n+}"}, {"sha": "203181e0f7d968bcb72ca6212b72eee517808973", "filename": "libbacktrace/state.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fstate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Fstate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fstate.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,72 @@\n+/* state.c -- Create the backtrace state.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+#include \"internal.h\"\n+\n+/* Create the backtrace state.  This will then be passed to all the\n+   other routines.  */\n+\n+struct backtrace_state *\n+backtrace_create_state (const char *filename, int threaded,\n+\t\t\tbacktrace_error_callback error_callback,\n+\t\t\tvoid *data)\n+{\n+  struct backtrace_state init_state;\n+  struct backtrace_state *state;\n+\n+#ifndef HAVE_SYNC_FUNCTIONS\n+  if (threaded)\n+    {\n+      error_callback (data, \"backtrace library does not support threads\", 0);\n+      return NULL;\n+    }\n+#endif\n+\n+  memset (&init_state, 0, sizeof init_state);\n+  init_state.filename = filename;\n+  init_state.threaded = threaded;\n+\n+  state = ((struct backtrace_state *)\n+\t   backtrace_alloc (&init_state, sizeof *state, error_callback, data));\n+  if (state == NULL)\n+    return NULL;\n+  *state = init_state;\n+\n+  return state;\n+}"}, {"sha": "4ff10b64427c857686038d9a7ccfe673514fe34d", "filename": "libbacktrace/unknown.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Funknown.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff02e4f8421170b613b80e266b5b1893c588ea6/libbacktrace%2Funknown.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Funknown.c?ref=eff02e4f8421170b613b80e266b5b1893c588ea6", "patch": "@@ -0,0 +1,64 @@\n+/* unknown.c -- used when backtrace configury does not know file format.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* A trivial routine that always fails to find fileline data.  */\n+\n+static int\n+unknown_fileline (void *fileline_data ATTRIBUTE_UNUSED,\n+\t\t  uintptr_t pc, backtrace_full_callback callback,\n+\t\t  backtrace_error_callback ATTRIBUTE_UNUSED,\n+\t\t  void *data)\n+\n+{\n+  return callback (data, pc, NULL, 0, NULL);\n+}\n+\n+/* Initialize the backtrace data when we don't know how to read the\n+   debug info.  */\n+\n+int\n+backtrace_initialize (int descriptor ATTRIBUTE_UNUSED,\n+\t\t      backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\t      void *data ATTRIBUTE_UNUSED, fileline *fileline_fn,\n+\t\t      void **fileline_data)\n+{\n+  *fileline_fn = unknown_fileline;\n+  *fileline_data = NULL;\n+  return 1;\n+}"}]}