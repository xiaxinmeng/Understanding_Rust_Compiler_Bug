{"sha": "909a4b4764c4f270f09ccb2a950c91b21ed7b33a", "node_id": "C_kwDOANBUbNoAKDkwOWE0YjQ3NjRjNGYyNzBmMDljY2IyYTk1MGM5MWIyMWVkN2IzM2E", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-01-10T14:47:07Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-01-10T14:47:07Z"}, "message": "ira: Add comments and fix move_spill_restore calculation\n\nThis patch adds comments to describe each use of ira_loop_border_costs.\nI think this highlights that move_spill_restore was using the wrong cost\nin one case, which came from tranposing [0] and [1] in the original\n(pre-ira_loop_border_costs) ira_memory_move_cost expressions.  The\ndifference would only be noticeable on targets that distinguish between\nload and store costs.\n\ngcc/\n\tPR rtl-optimization/98782\n\t* ira-color.c (color_pass): Add comments to describe the spill costs.\n\t(move_spill_restore): Likewise.  Fix reversed calculation.", "tree": {"sha": "a0905da8f76ee15f99e16dbe341d83f601c43e15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0905da8f76ee15f99e16dbe341d83f601c43e15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/909a4b4764c4f270f09ccb2a950c91b21ed7b33a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/909a4b4764c4f270f09ccb2a950c91b21ed7b33a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/909a4b4764c4f270f09ccb2a950c91b21ed7b33a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/909a4b4764c4f270f09ccb2a950c91b21ed7b33a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf37fd35a37985a0e19817f843d0bdd5ad504aa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf37fd35a37985a0e19817f843d0bdd5ad504aa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf37fd35a37985a0e19817f843d0bdd5ad504aa9"}], "stats": {"total": 28, "additions": 27, "deletions": 1}, "files": [{"sha": "e74333126756b2e3ceb70b1dca58b5be2bdd990d", "filename": "gcc/ira-color.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909a4b4764c4f270f09ccb2a950c91b21ed7b33a/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909a4b4764c4f270f09ccb2a950c91b21ed7b33a/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=909a4b4764c4f270f09ccb2a950c91b21ed7b33a", "patch": "@@ -3479,6 +3479,13 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t    }\n \t  else if (hard_regno < 0)\n \t    {\n+\t      /* If we allocate a register to SUBLOOP_ALLOCNO, we'll need\n+\t\t to load the register on entry to the subloop and store\n+\t\t the register back on exit from the subloop.  This incurs\n+\t\t a fixed cost for all registers.  Since UPDATED_MEMORY_COST\n+\t\t is (and should only be) used relative to the register costs\n+\t\t for the same allocno, we can subtract this shared register\n+\t\t cost from the memory cost.  */\n \t      ira_loop_border_costs border_costs (subloop_allocno);\n \t      ALLOCNO_UPDATED_MEMORY_COST (subloop_allocno)\n \t\t-= border_costs.spill_outside_loop_cost ();\n@@ -3503,6 +3510,9 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t\t  > ALLOCNO_UPDATED_HARD_REG_COSTS (subloop_allocno)[index])\n \t\tALLOCNO_UPDATED_CLASS_COST (subloop_allocno)\n \t\t  = ALLOCNO_UPDATED_HARD_REG_COSTS (subloop_allocno)[index];\n+\t      /* If we spill SUBLOOP_ALLOCNO, we'll need to store HARD_REGNO\n+\t\t on entry to the subloop and restore HARD_REGNO on exit from\n+\t\t the subloop.  */\n \t      ALLOCNO_UPDATED_MEMORY_COST (subloop_allocno)\n \t\t+= border_costs.spill_inside_loop_cost ();\n \t    }\n@@ -3601,9 +3611,17 @@ move_spill_restore (void)\n \t\t\t  : ALLOCNO_HARD_REG_COSTS (subloop_allocno)[index]));\n \t      ira_loop_border_costs border_costs (subloop_allocno);\n \t      if ((hard_regno2 = ALLOCNO_HARD_REGNO (subloop_allocno)) < 0)\n-\t\tcost -= border_costs.spill_outside_loop_cost ();\n+\t\t/* The register was spilled in the subloop.  If we spill\n+\t\t   it in the outer loop too then we'll no longer need to\n+\t\t   save the register on entry to the subloop and restore\n+\t\t   the register on exit from the subloop.  */\n+\t\tcost -= border_costs.spill_inside_loop_cost ();\n \t      else\n \t\t{\n+\t\t  /* The register was also allocated in the subloop.  If we\n+\t\t     spill it in the outer loop then we'll need to load the\n+\t\t     register on entry to the subloop and store the register\n+\t\t     back on exit from the subloop.  */\n \t\t  cost += border_costs.spill_outside_loop_cost ();\n \t\t  if (hard_regno2 != hard_regno)\n \t\t    cost -= border_costs.move_between_loops_cost ();\n@@ -3615,9 +3633,17 @@ move_spill_restore (void)\n \t      ira_assert (rclass == ALLOCNO_CLASS (parent_allocno));\n \t      ira_loop_border_costs border_costs (a);\n \t      if ((hard_regno2 = ALLOCNO_HARD_REGNO (parent_allocno)) < 0)\n+\t\t/* The register was spilled in the parent loop.  If we spill\n+\t\t   it in this loop too then we'll no longer need to load the\n+\t\t   register on entry to this loop and save the register back\n+\t\t   on exit from this loop.  */\n \t\tcost -= border_costs.spill_outside_loop_cost ();\n \t      else\n \t\t{\n+\t\t  /* The register was also allocated in the parent loop.\n+\t\t     If we spill it in this loop then we'll need to save\n+\t\t     the register on entry to this loop and restore the\n+\t\t     register on exit from this loop.  */\n \t\t  cost += border_costs.spill_inside_loop_cost ();\n \t\t  if (hard_regno2 != hard_regno)\n \t\t    cost -= border_costs.move_between_loops_cost ();"}]}