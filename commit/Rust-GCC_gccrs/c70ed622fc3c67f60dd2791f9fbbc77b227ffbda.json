{"sha": "c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcwZWQ2MjJmYzNjNjdmNjBkZDI3OTFmOWZiYmM3N2IyMjdmZmJkYQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2015-06-02T03:33:35Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2015-06-02T03:33:35Z"}, "message": "re PR testsuite/52563 (FAIL: gcc.dg/tree-ssa/scev-[3,4].c scan-tree-dump-times optimized \"&a\" 1)\n\n\n\tPR tree-optimization/52563\n\tPR tree-optimization/62173\n\t* tree-ssa-loop-ivopts.c (struct iv): New field.  Reorder fields.\n\t(alloc_iv, set_iv): New parameter.\n\t(determine_biv_step): Delete.\n\t(find_bivs): Inline original determine_biv_step.  Pass new\n\targument to set_iv.\n\t(idx_find_step): Use no_overflow information for conversion.\n\t* tree-scalar-evolution.c (analyze_scalar_evolution_in_loop): Let\n\tresolve_mixers handle folded_casts.\n\t(instantiate_scev_name): Change bool parameter to bool pointer.\n\t(instantiate_scev_poly, instantiate_scev_binary): Ditto.\n\t(instantiate_array_ref, instantiate_scev_not): Ditto.\n\t(instantiate_scev_3, instantiate_scev_2): Ditto.\n\t(instantiate_scev_1, instantiate_scev_r): Ditto.\n\t(instantiate_scev_convert, ): Change parameter.  Pass argument\n\tto chrec_convert_aggressive.\n\t(instantiate_scev): Change argument.\n\t(resolve_mixers): New parameter and set it.\n\t(scev_const_prop): New argument.\n\t* tree-scalar-evolution.h (resolve_mixers): New parameter.\n\t* tree-chrec.c (convert_affine_scev): Call chrec_convert instead\n\tof chrec_conert_1.\n\t(chrec_convert): New parameter.  Move definition below.\n\t(chrec_convert_aggressive): New parameter and set it.  Call\n\tconvert_affine_scev.\n\t* tree-chrec.h (chrec_convert): New parameter.\n\t(chrec_convert_aggressive): Ditto.\n\n\tgcc/testsuite/ChangeLog\n\tPR tree-optimization/52563\n\tPR tree-optimization/62173\n\t* gcc.dg/tree-ssa/scev-3.c: Remove xfail.\n\t* gcc.dg/tree-ssa/scev-4.c: Ditto.\n\nFrom-SVN: r224009", "tree": {"sha": "1f5e020ab5afc1038a6fcaef4aa52021a0090379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f5e020ab5afc1038a6fcaef4aa52021a0090379"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/comments", "author": null, "committer": null, "parents": [{"sha": "81371eff9bc7ef26172c925c923fdd28ac3622ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81371eff9bc7ef26172c925c923fdd28ac3622ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81371eff9bc7ef26172c925c923fdd28ac3622ce"}], "stats": {"total": 348, "additions": 209, "deletions": 139}, "files": [{"sha": "be843a6f399cd81679423cc306ab3d7087d294d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "patch": "@@ -1,3 +1,34 @@\n+2015-06-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/52563\n+\tPR tree-optimization/62173\n+\t* tree-ssa-loop-ivopts.c (struct iv): New field.  Reorder fields.\n+\t(alloc_iv, set_iv): New parameter.\n+\t(determine_biv_step): Delete.\n+\t(find_bivs): Inline original determine_biv_step.  Pass new\n+\targument to set_iv.\n+\t(idx_find_step): Use no_overflow information for conversion.\n+\t* tree-scalar-evolution.c (analyze_scalar_evolution_in_loop): Let\n+\tresolve_mixers handle folded_casts.\n+\t(instantiate_scev_name): Change bool parameter to bool pointer.\n+\t(instantiate_scev_poly, instantiate_scev_binary): Ditto.\n+\t(instantiate_array_ref, instantiate_scev_not): Ditto.\n+\t(instantiate_scev_3, instantiate_scev_2): Ditto.\n+\t(instantiate_scev_1, instantiate_scev_r): Ditto.\n+\t(instantiate_scev_convert, ): Change parameter.  Pass argument\n+\tto chrec_convert_aggressive.\n+\t(instantiate_scev): Change argument.\n+\t(resolve_mixers): New parameter and set it.\n+\t(scev_const_prop): New argument.\n+\t* tree-scalar-evolution.h (resolve_mixers): New parameter.\n+\t* tree-chrec.c (convert_affine_scev): Call chrec_convert instead\n+\tof chrec_conert_1.\n+\t(chrec_convert): New parameter.  Move definition below.\n+\t(chrec_convert_aggressive): New parameter and set it.  Call\n+\tconvert_affine_scev.\n+\t* tree-chrec.h (chrec_convert): New parameter.\n+\t(chrec_convert_aggressive): Ditto.\n+\n 2015-06-01  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gimplify.c (gimplify_modify_expr_rhs): Use simple test on the size."}, {"sha": "2bd0a31bfda5e0f6b0ae83367821501714e74d96", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "patch": "@@ -1,3 +1,10 @@\n+2015-06-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/52563\n+\tPR tree-optimization/62173\n+\t* gcc.dg/tree-ssa/scev-3.c: Remove xfail.\n+\t* gcc.dg/tree-ssa/scev-4.c: Ditto.\n+\n 2015-06-01  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/varsize_return2.ads: New test."}, {"sha": "1346f26d6c156a091ba6d2ef78a2dd6bda1d2778", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-3.c?ref=c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "patch": "@@ -15,4 +15,4 @@ f(int k)\n         }\n }\n \n-/* { dg-final { scan-tree-dump-times \"&a\" 1 \"optimized\" { xfail { lp64 || llp64 } } } } */\n+/* { dg-final { scan-tree-dump-times \"&a\" 1 \"optimized\" } } */"}, {"sha": "99d033709af909d2dc57addd752f2cdb8759253a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-4.c?ref=c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "patch": "@@ -20,4 +20,4 @@ f(int k)\n         }\n }\n \n-/* { dg-final { scan-tree-dump-times \"&a\" 1 \"optimized\" { xfail { lp64 || llp64 } } } } */\n+/* { dg-final { scan-tree-dump-times \"&a\" 1 \"optimized\" } } */"}, {"sha": "9357a56173960927133d46f17fb8b5c42e433c0f", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 63, "deletions": 41, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "patch": "@@ -1178,8 +1178,6 @@ nb_vars_in_chrec (tree chrec)\n     }\n }\n \n-static tree chrec_convert_1 (tree, tree, gimple, bool);\n-\n /* Converts BASE and STEP of affine scev to TYPE.  LOOP is the loop whose iv\n    the scev corresponds to.  AT_STMT is the statement at that the scev is\n    evaluated.  USE_OVERFLOW_SEMANTICS is true if this function should assume that\n@@ -1254,8 +1252,7 @@ convert_affine_scev (struct loop *loop, tree type,\n \t\t\t\tuse_overflow_semantics))\n     return false;\n \n-  new_base = chrec_convert_1 (type, *base, at_stmt,\n-\t\t\t      use_overflow_semantics);\n+  new_base = chrec_convert (type, *base, at_stmt, use_overflow_semantics);\n   /* The step must be sign extended, regardless of the signedness\n      of CT and TYPE.  This only needs to be handled specially when\n      CT is unsigned -- to avoid e.g. unsigned char [100, +, 255]\n@@ -1266,10 +1263,11 @@ convert_affine_scev (struct loop *loop, tree type,\n   if (TYPE_PRECISION (step_type) > TYPE_PRECISION (ct) && TYPE_UNSIGNED (ct))\n     {\n       tree signed_ct = build_nonstandard_integer_type (TYPE_PRECISION (ct), 0);\n-      new_step = chrec_convert_1 (signed_ct, new_step, at_stmt,\n-                                  use_overflow_semantics);\n+      new_step = chrec_convert (signed_ct, new_step, at_stmt,\n+                                use_overflow_semantics);\n     }\n-  new_step = chrec_convert_1 (step_type, new_step, at_stmt, use_overflow_semantics);\n+  new_step = chrec_convert (step_type, new_step, at_stmt,\n+\t\t\t    use_overflow_semantics);\n \n   if (automatically_generated_chrec_p (new_base)\n       || automatically_generated_chrec_p (new_step))\n@@ -1299,36 +1297,6 @@ chrec_convert_rhs (tree type, tree chrec, gimple at_stmt)\n   return chrec_convert (type, chrec, at_stmt);\n }\n \n-/* Convert CHREC to TYPE.  When the analyzer knows the context in\n-   which the CHREC is built, it sets AT_STMT to the statement that\n-   contains the definition of the analyzed variable, otherwise the\n-   conversion is less accurate: the information is used for\n-   determining a more accurate estimation of the number of iterations.\n-   By default AT_STMT could be safely set to NULL_TREE.\n-\n-   The following rule is always true: TREE_TYPE (chrec) ==\n-   TREE_TYPE (CHREC_LEFT (chrec)) == TREE_TYPE (CHREC_RIGHT (chrec)).\n-   An example of what could happen when adding two chrecs and the type\n-   of the CHREC_RIGHT is different than CHREC_LEFT is:\n-\n-   {(uint) 0, +, (uchar) 10} +\n-   {(uint) 0, +, (uchar) 250}\n-\n-   that would produce a wrong result if CHREC_RIGHT is not (uint):\n-\n-   {(uint) 0, +, (uchar) 4}\n-\n-   instead of\n-\n-   {(uint) 0, +, (uint) 260}\n-*/\n-\n-tree\n-chrec_convert (tree type, tree chrec, gimple at_stmt)\n-{\n-  return chrec_convert_1 (type, chrec, at_stmt, true);\n-}\n-\n /* Convert CHREC to TYPE.  When the analyzer knows the context in\n    which the CHREC is built, it sets AT_STMT to the statement that\n    contains the definition of the analyzed variable, otherwise the\n@@ -1420,15 +1388,53 @@ chrec_convert_1 (tree type, tree chrec, gimple at_stmt,\n   return res;\n }\n \n+/* Convert CHREC to TYPE.  When the analyzer knows the context in\n+   which the CHREC is built, it sets AT_STMT to the statement that\n+   contains the definition of the analyzed variable, otherwise the\n+   conversion is less accurate: the information is used for\n+   determining a more accurate estimation of the number of iterations.\n+   By default AT_STMT could be safely set to NULL_TREE.\n+\n+   The following rule is always true: TREE_TYPE (chrec) ==\n+   TREE_TYPE (CHREC_LEFT (chrec)) == TREE_TYPE (CHREC_RIGHT (chrec)).\n+   An example of what could happen when adding two chrecs and the type\n+   of the CHREC_RIGHT is different than CHREC_LEFT is:\n+\n+   {(uint) 0, +, (uchar) 10} +\n+   {(uint) 0, +, (uchar) 250}\n+\n+   that would produce a wrong result if CHREC_RIGHT is not (uint):\n+\n+   {(uint) 0, +, (uchar) 4}\n+\n+   instead of\n+\n+   {(uint) 0, +, (uint) 260}\n+\n+   USE_OVERFLOW_SEMANTICS is true if this function should assume that\n+   the rules for overflow of the given language apply (e.g., that signed\n+   arithmetics in C does not overflow) -- i.e., to use them to avoid unnecessary\n+   tests, but also to enforce that the result follows them.  */\n+\n+tree\n+chrec_convert (tree type, tree chrec, gimple at_stmt,\n+\t       bool use_overflow_semantics)\n+{\n+  return chrec_convert_1 (type, chrec, at_stmt, use_overflow_semantics);\n+}\n+\n /* Convert CHREC to TYPE, without regard to signed overflows.  Returns the new\n    chrec if something else than what chrec_convert would do happens, NULL_TREE\n-   otherwise.  */\n+   otherwise.  This function set TRUE to variable pointed by FOLD_CONVERSIONS\n+   if the result chrec may overflow.  */\n \n tree\n-chrec_convert_aggressive (tree type, tree chrec)\n+chrec_convert_aggressive (tree type, tree chrec, bool *fold_conversions)\n {\n   tree inner_type, left, right, lc, rc, rtype;\n \n+  gcc_assert (fold_conversions != NULL);\n+\n   if (automatically_generated_chrec_p (chrec)\n       || TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n     return NULL_TREE;\n@@ -1437,17 +1443,33 @@ chrec_convert_aggressive (tree type, tree chrec)\n   if (TYPE_PRECISION (type) > TYPE_PRECISION (inner_type))\n     return NULL_TREE;\n \n+  if (useless_type_conversion_p (type, inner_type))\n+    return NULL_TREE;\n+\n+  if (!*fold_conversions && evolution_function_is_affine_p (chrec))\n+    {\n+      tree base, step;\n+      struct loop *loop;\n+\n+      loop = get_chrec_loop (chrec);\n+      base = CHREC_LEFT (chrec);\n+      step = CHREC_RIGHT (chrec);\n+      if (convert_affine_scev (loop, type, &base, &step, NULL, true))\n+\treturn build_polynomial_chrec (loop->num, base, step);\n+    }\n   rtype = POINTER_TYPE_P (type) ? sizetype : type;\n \n   left = CHREC_LEFT (chrec);\n   right = CHREC_RIGHT (chrec);\n-  lc = chrec_convert_aggressive (type, left);\n+  lc = chrec_convert_aggressive (type, left, fold_conversions);\n   if (!lc)\n     lc = chrec_convert (type, left, NULL);\n-  rc = chrec_convert_aggressive (rtype, right);\n+  rc = chrec_convert_aggressive (rtype, right, fold_conversions);\n   if (!rc)\n     rc = chrec_convert (rtype, right, NULL);\n \n+  *fold_conversions = true;\n+\n   return build_polynomial_chrec (CHREC_VARIABLE (chrec), lc, rc);\n }\n "}, {"sha": "144ba2c3979cbc687e02426237e7b2022d997436", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "patch": "@@ -59,9 +59,9 @@ enum ev_direction scev_direction (const_tree);\n extern tree chrec_fold_plus (tree, tree, tree);\n extern tree chrec_fold_minus (tree, tree, tree);\n extern tree chrec_fold_multiply (tree, tree, tree);\n-extern tree chrec_convert (tree, tree, gimple);\n+extern tree chrec_convert (tree, tree, gimple, bool = true);\n extern tree chrec_convert_rhs (tree, tree, gimple);\n-extern tree chrec_convert_aggressive (tree, tree);\n+extern tree chrec_convert_aggressive (tree, tree, bool *);\n \n /* Operations.  */\n extern tree chrec_apply (unsigned, tree, tree);"}, {"sha": "013fc507830569aeef1d45aa6352df42094829d3", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 76, "deletions": 62, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "patch": "@@ -2145,7 +2145,7 @@ analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,\n   /* We cannot just do\n \n      tmp = analyze_scalar_evolution (use_loop, version);\n-     ev = resolve_mixers (wrto_loop, tmp);\n+     ev = resolve_mixers (wrto_loop, tmp, folded_casts);\n \n      as resolve_mixers would query the scalar evolution with respect to\n      wrto_loop.  For example, in the situation described in the function\n@@ -2154,9 +2154,9 @@ analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,\n \n      analyze_scalar_evolution (use_loop, version) = k2\n \n-     and resolve_mixers (loop1, k2) finds that the value of k2 in loop 1\n-     is 100, which is a wrong result, since we are interested in the\n-     value in loop 3.\n+     and resolve_mixers (loop1, k2, folded_casts) finds that the value of\n+     k2 in loop 1 is 100, which is a wrong result, since we are interested\n+     in the value in loop 3.\n \n      Instead, we need to proceed from use_loop to wrto_loop loop by loop,\n      each time checking that there is no evolution in the inner loop.  */\n@@ -2166,10 +2166,7 @@ analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,\n   while (1)\n     {\n       tmp = analyze_scalar_evolution (use_loop, ev);\n-      ev = resolve_mixers (use_loop, tmp);\n-\n-      if (folded_casts && tmp != ev)\n-\t*folded_casts = true;\n+      ev = resolve_mixers (use_loop, tmp, folded_casts);\n \n       if (use_loop == wrto_loop)\n \treturn ev;\n@@ -2292,7 +2289,7 @@ loop_closed_phi_def (tree var)\n }\n \n static tree instantiate_scev_r (basic_block, struct loop *, struct loop *,\n-\t\t\t\ttree, bool, int);\n+\t\t\t\ttree, bool *, int);\n \n /* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n    and EVOLUTION_LOOP, that were left under a symbolic form.\n@@ -2301,9 +2298,10 @@ static tree instantiate_scev_r (basic_block, struct loop *, struct loop *,\n \n    CACHE is the cache of already instantiated values.\n \n-   FOLD_CONVERSIONS should be set to true when the conversions that\n-   may wrap in signed/pointer type are folded, as long as the value of\n-   the chrec is preserved.\n+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n+   conversions that may wrap in signed/pointer type are folded, as long\n+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n+   then we don't do such fold.\n \n    SIZE_EXPR is used for computing the size of the expression to be\n    instantiated, and to stop if it exceeds some limit.  */\n@@ -2312,7 +2310,7 @@ static tree\n instantiate_scev_name (basic_block instantiate_below,\n \t\t       struct loop *evolution_loop, struct loop *inner_loop,\n \t\t       tree chrec,\n-\t\t       bool fold_conversions,\n+\t\t       bool *fold_conversions,\n \t\t       int size_expr)\n {\n   tree res;\n@@ -2406,17 +2404,18 @@ instantiate_scev_name (basic_block instantiate_below,\n \n    CACHE is the cache of already instantiated values.\n \n-   FOLD_CONVERSIONS should be set to true when the conversions that\n-   may wrap in signed/pointer type are folded, as long as the value of\n-   the chrec is preserved.\n+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n+   conversions that may wrap in signed/pointer type are folded, as long\n+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n+   then we don't do such fold.\n \n    SIZE_EXPR is used for computing the size of the expression to be\n    instantiated, and to stop if it exceeds some limit.  */\n \n static tree\n instantiate_scev_poly (basic_block instantiate_below,\n \t\t       struct loop *evolution_loop, struct loop *,\n-\t\t       tree chrec, bool fold_conversions, int size_expr)\n+\t\t       tree chrec, bool *fold_conversions, int size_expr)\n {\n   tree op1;\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n@@ -2450,9 +2449,10 @@ instantiate_scev_poly (basic_block instantiate_below,\n \n    CACHE is the cache of already instantiated values.\n \n-   FOLD_CONVERSIONS should be set to true when the conversions that\n-   may wrap in signed/pointer type are folded, as long as the value of\n-   the chrec is preserved.\n+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n+   conversions that may wrap in signed/pointer type are folded, as long\n+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n+   then we don't do such fold.\n \n    SIZE_EXPR is used for computing the size of the expression to be\n    instantiated, and to stop if it exceeds some limit.  */\n@@ -2462,7 +2462,7 @@ instantiate_scev_binary (basic_block instantiate_below,\n \t\t\t struct loop *evolution_loop, struct loop *inner_loop,\n \t\t\t tree chrec, enum tree_code code,\n \t\t\t tree type, tree c0, tree c1,\n-\t\t\t bool fold_conversions, int size_expr)\n+\t\t\t bool *fold_conversions, int size_expr)\n {\n   tree op1;\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop, inner_loop,\n@@ -2508,17 +2508,18 @@ instantiate_scev_binary (basic_block instantiate_below,\n \n    CACHE is the cache of already instantiated values.\n \n-   FOLD_CONVERSIONS should be set to true when the conversions that\n-   may wrap in signed/pointer type are folded, as long as the value of\n-   the chrec is preserved.\n+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n+   conversions that may wrap in signed/pointer type are folded, as long\n+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n+   then we don't do such fold.\n \n    SIZE_EXPR is used for computing the size of the expression to be\n    instantiated, and to stop if it exceeds some limit.  */\n \n static tree\n instantiate_array_ref (basic_block instantiate_below,\n \t\t       struct loop *evolution_loop, struct loop *inner_loop,\n-\t\t       tree chrec, bool fold_conversions, int size_expr)\n+\t\t       tree chrec, bool *fold_conversions, int size_expr)\n {\n   tree res;\n   tree index = TREE_OPERAND (chrec, 1);\n@@ -2545,9 +2546,10 @@ instantiate_array_ref (basic_block instantiate_below,\n \n    CACHE is the cache of already instantiated values.\n \n-   FOLD_CONVERSIONS should be set to true when the conversions that\n-   may wrap in signed/pointer type are folded, as long as the value of\n-   the chrec is preserved.\n+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n+   conversions that may wrap in signed/pointer type are folded, as long\n+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n+   then we don't do such fold.\n \n    SIZE_EXPR is used for computing the size of the expression to be\n    instantiated, and to stop if it exceeds some limit.  */\n@@ -2556,7 +2558,7 @@ static tree\n instantiate_scev_convert (basic_block instantiate_below,\n \t\t\t  struct loop *evolution_loop, struct loop *inner_loop,\n \t\t\t  tree chrec, tree type, tree op,\n-\t\t\t  bool fold_conversions, int size_expr)\n+\t\t\t  bool *fold_conversions, int size_expr)\n {\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n \t\t\t\t inner_loop, op,\n@@ -2567,19 +2569,21 @@ instantiate_scev_convert (basic_block instantiate_below,\n \n   if (fold_conversions)\n     {\n-      tree tmp = chrec_convert_aggressive (type, op0);\n+      tree tmp = chrec_convert_aggressive (type, op0, fold_conversions);\n       if (tmp)\n \treturn tmp;\n-    }\n \n-  if (chrec && op0 == op)\n-    return chrec;\n+      /* If we used chrec_convert_aggressive, we can no longer assume that\n+\t signed chrecs do not overflow, as chrec_convert does, so avoid\n+\t calling it in that case.  */\n+      if (*fold_conversions)\n+\t{\n+\t  if (chrec && op0 == op)\n+\t    return chrec;\n \n-  /* If we used chrec_convert_aggressive, we can no longer assume that\n-     signed chrecs do not overflow, as chrec_convert does, so avoid\n-     calling it in that case.  */\n-  if (fold_conversions)\n-    return fold_convert (type, op0);\n+\t  return fold_convert (type, op0);\n+\t}\n+    }\n \n   return chrec_convert (type, op0, NULL);\n }\n@@ -2593,9 +2597,10 @@ instantiate_scev_convert (basic_block instantiate_below,\n \n    CACHE is the cache of already instantiated values.\n \n-   FOLD_CONVERSIONS should be set to true when the conversions that\n-   may wrap in signed/pointer type are folded, as long as the value of\n-   the chrec is preserved.\n+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n+   conversions that may wrap in signed/pointer type are folded, as long\n+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n+   then we don't do such fold.\n \n    SIZE_EXPR is used for computing the size of the expression to be\n    instantiated, and to stop if it exceeds some limit.  */\n@@ -2605,7 +2610,7 @@ instantiate_scev_not (basic_block instantiate_below,\n \t\t      struct loop *evolution_loop, struct loop *inner_loop,\n \t\t      tree chrec,\n \t\t      enum tree_code code, tree type, tree op,\n-\t\t      bool fold_conversions, int size_expr)\n+\t\t      bool *fold_conversions, int size_expr)\n {\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n \t\t\t\t inner_loop, op,\n@@ -2643,9 +2648,10 @@ instantiate_scev_not (basic_block instantiate_below,\n \n    CACHE is the cache of already instantiated values.\n \n-   FOLD_CONVERSIONS should be set to true when the conversions that\n-   may wrap in signed/pointer type are folded, as long as the value of\n-   the chrec is preserved.\n+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n+   conversions that may wrap in signed/pointer type are folded, as long\n+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n+   then we don't do such fold.\n \n    SIZE_EXPR is used for computing the size of the expression to be\n    instantiated, and to stop if it exceeds some limit.  */\n@@ -2654,7 +2660,7 @@ static tree\n instantiate_scev_3 (basic_block instantiate_below,\n \t\t    struct loop *evolution_loop, struct loop *inner_loop,\n \t\t    tree chrec,\n-\t\t    bool fold_conversions, int size_expr)\n+\t\t    bool *fold_conversions, int size_expr)\n {\n   tree op1, op2;\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n@@ -2691,9 +2697,10 @@ instantiate_scev_3 (basic_block instantiate_below,\n \n    CACHE is the cache of already instantiated values.\n \n-   FOLD_CONVERSIONS should be set to true when the conversions that\n-   may wrap in signed/pointer type are folded, as long as the value of\n-   the chrec is preserved.\n+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n+   conversions that may wrap in signed/pointer type are folded, as long\n+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n+   then we don't do such fold.\n \n    SIZE_EXPR is used for computing the size of the expression to be\n    instantiated, and to stop if it exceeds some limit.  */\n@@ -2702,7 +2709,7 @@ static tree\n instantiate_scev_2 (basic_block instantiate_below,\n \t\t    struct loop *evolution_loop, struct loop *inner_loop,\n \t\t    tree chrec,\n-\t\t    bool fold_conversions, int size_expr)\n+\t\t    bool *fold_conversions, int size_expr)\n {\n   tree op1;\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n@@ -2731,9 +2738,10 @@ instantiate_scev_2 (basic_block instantiate_below,\n \n    CACHE is the cache of already instantiated values.\n \n-   FOLD_CONVERSIONS should be set to true when the conversions that\n-   may wrap in signed/pointer type are folded, as long as the value of\n-   the chrec is preserved.\n+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n+   conversions that may wrap in signed/pointer type are folded, as long\n+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n+   then we don't do such fold.\n \n    SIZE_EXPR is used for computing the size of the expression to be\n    instantiated, and to stop if it exceeds some limit.  */\n@@ -2742,7 +2750,7 @@ static tree\n instantiate_scev_1 (basic_block instantiate_below,\n \t\t    struct loop *evolution_loop, struct loop *inner_loop,\n \t\t    tree chrec,\n-\t\t    bool fold_conversions, int size_expr)\n+\t\t    bool *fold_conversions, int size_expr)\n {\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n \t\t\t\t inner_loop, TREE_OPERAND (chrec, 0),\n@@ -2764,9 +2772,10 @@ instantiate_scev_1 (basic_block instantiate_below,\n \n    CACHE is the cache of already instantiated values.\n \n-   FOLD_CONVERSIONS should be set to true when the conversions that\n-   may wrap in signed/pointer type are folded, as long as the value of\n-   the chrec is preserved.\n+   Variable pointed by FOLD_CONVERSIONS is set to TRUE when the\n+   conversions that may wrap in signed/pointer type are folded, as long\n+   as the value of the chrec is preserved.  If FOLD_CONVERSIONS is NULL\n+   then we don't do such fold.\n \n    SIZE_EXPR is used for computing the size of the expression to be\n    instantiated, and to stop if it exceeds some limit.  */\n@@ -2775,7 +2784,7 @@ static tree\n instantiate_scev_r (basic_block instantiate_below,\n \t\t    struct loop *evolution_loop, struct loop *inner_loop,\n \t\t    tree chrec,\n-\t\t    bool fold_conversions, int size_expr)\n+\t\t    bool *fold_conversions, int size_expr)\n {\n   /* Give up if the expression is larger than the MAX that we allow.  */\n   if (size_expr++ > PARAM_VALUE (PARAM_SCEV_MAX_EXPR_SIZE))\n@@ -2900,7 +2909,7 @@ instantiate_scev (basic_block instantiate_below, struct loop *evolution_loop,\n     }\n \n   res = instantiate_scev_r (instantiate_below, evolution_loop,\n-\t\t\t    NULL, chrec, false, 0);\n+\t\t\t    NULL, chrec, NULL, 0);\n \n   if (destr)\n     {\n@@ -2924,17 +2933,21 @@ instantiate_scev (basic_block instantiate_below, struct loop *evolution_loop,\n    of an expression.  */\n \n tree\n-resolve_mixers (struct loop *loop, tree chrec)\n+resolve_mixers (struct loop *loop, tree chrec, bool *folded_casts)\n {\n   bool destr = false;\n+  bool fold_conversions = false;\n   if (!global_cache)\n     {\n       global_cache = new instantiate_cache_type;\n       destr = true;\n     }\n \n   tree ret = instantiate_scev_r (block_before_loop (loop), loop, NULL,\n-\t\t\t\t chrec, true, 0);\n+\t\t\t\t chrec, &fold_conversions, 0);\n+\n+  if (folded_casts && !*folded_casts)\n+    *folded_casts = fold_conversions;\n \n   if (destr)\n     {\n@@ -3387,7 +3400,8 @@ scev_const_prop (void)\n \t      && !INTEGRAL_TYPE_P (type))\n \t    continue;\n \n-\t  ev = resolve_mixers (loop, analyze_scalar_evolution (loop, name));\n+\t  ev = resolve_mixers (loop, analyze_scalar_evolution (loop, name),\n+\t\t\t       NULL);\n \t  if (!is_gimple_min_invariant (ev)\n \t      || !may_propagate_copy (name, ev))\n \t    continue;"}, {"sha": "6d312806636f1b462bf9669e2c70ab8d92e24ad5", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "patch": "@@ -31,7 +31,7 @@ extern void scev_reset_htab (void);\n extern void scev_finalize (void);\n extern tree analyze_scalar_evolution (struct loop *, tree);\n extern tree instantiate_scev (basic_block, struct loop *, tree);\n-extern tree resolve_mixers (struct loop *, tree);\n+extern tree resolve_mixers (struct loop *, tree, bool *);\n extern void gather_stats_on_scev_database (void);\n extern unsigned int scev_const_prop (void);\n extern bool expression_expensive_p (tree);"}, {"sha": "a7f09e74ebc9203161439c90c7eb70b966655b20", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70ed622fc3c67f60dd2791f9fbbc77b227ffbda/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=c70ed622fc3c67f60dd2791f9fbbc77b227ffbda", "patch": "@@ -171,9 +171,10 @@ struct iv\n   tree base_object;\t/* A memory object to that the induction variable points.  */\n   tree step;\t\t/* Step of the iv (constant only).  */\n   tree ssa_name;\t/* The ssa name with the value.  */\n+  unsigned use_id;\t/* The identifier in the use if it is the case.  */\n   bool biv_p;\t\t/* Is it a biv?  */\n   bool have_use_for;\t/* Do we already have a use for it?  */\n-  unsigned use_id;\t/* The identifier in the use if it is the case.  */\n+  bool no_overflow;\t/* True if the iv doesn't overflow.  */\n };\n \n /* Per-ssa version information (induction variable descriptions, etc.).  */\n@@ -1005,10 +1006,10 @@ contain_complex_addr_expr (tree expr)\n }\n \n /* Allocates an induction variable with given initial value BASE and step STEP\n-   for loop LOOP.  */\n+   for loop LOOP.  NO_OVERFLOW implies the iv doesn't overflow.  */\n \n static struct iv *\n-alloc_iv (tree base, tree step)\n+alloc_iv (tree base, tree step, bool no_overflow = false)\n {\n   tree expr = base;\n   struct iv *iv = XCNEW (struct iv);\n@@ -1035,21 +1036,24 @@ alloc_iv (tree base, tree step)\n   iv->have_use_for = false;\n   iv->use_id = 0;\n   iv->ssa_name = NULL_TREE;\n+  iv->no_overflow = no_overflow;\n \n   return iv;\n }\n \n-/* Sets STEP and BASE for induction variable IV.  */\n+/* Sets STEP and BASE for induction variable IV.  NO_OVERFLOW implies the IV\n+   doesn't overflow.  */\n \n static void\n-set_iv (struct ivopts_data *data, tree iv, tree base, tree step)\n+set_iv (struct ivopts_data *data, tree iv, tree base, tree step,\n+\tbool no_overflow)\n {\n   struct version_info *info = name_info (data, iv);\n \n   gcc_assert (!info->iv);\n \n   bitmap_set_bit (data->relevant, SSA_NAME_VERSION (iv));\n-  info->iv = alloc_iv (base, step);\n+  info->iv = alloc_iv (base, step, no_overflow);\n   info->iv->ssa_name = iv;\n }\n \n@@ -1071,31 +1075,12 @@ get_iv (struct ivopts_data *data, tree var)\n \n       if (!bb\n \t  || !flow_bb_inside_loop_p (data->current_loop, bb))\n-\tset_iv (data, var, var, build_int_cst (type, 0));\n+\tset_iv (data, var, var, build_int_cst (type, 0), true);\n     }\n \n   return name_info (data, var)->iv;\n }\n \n-/* Determines the step of a biv defined in PHI.  Returns NULL if PHI does\n-   not define a simple affine biv with nonzero step.  */\n-\n-static tree\n-determine_biv_step (gphi *phi)\n-{\n-  struct loop *loop = gimple_bb (phi)->loop_father;\n-  tree name = PHI_RESULT (phi);\n-  affine_iv iv;\n-\n-  if (virtual_operand_p (name))\n-    return NULL_TREE;\n-\n-  if (!simple_iv (loop, loop, name, &iv, true))\n-    return NULL_TREE;\n-\n-  return integer_zerop (iv.step) ? NULL_TREE : iv.step;\n-}\n-\n /* Return the first non-invariant ssa var found in EXPR.  */\n \n static tree\n@@ -1129,6 +1114,7 @@ static bool\n find_bivs (struct ivopts_data *data)\n {\n   gphi *phi;\n+  affine_iv iv;\n   tree step, type, base, stop;\n   bool found = false;\n   struct loop *loop = data->current_loop;\n@@ -1141,10 +1127,16 @@ find_bivs (struct ivopts_data *data)\n       if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (PHI_RESULT (phi)))\n \tcontinue;\n \n-      step = determine_biv_step (phi);\n-      if (!step)\n+      if (virtual_operand_p (PHI_RESULT (phi)))\n \tcontinue;\n \n+      if (!simple_iv (loop, loop, PHI_RESULT (phi), &iv, true))\n+\tcontinue;\n+\n+      if (integer_zerop (iv.step))\n+\tcontinue;\n+\n+      step = iv.step;\n       base = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));\n       /* Stop expanding iv base at the first ssa var referred by iv step.\n \t Ideally we should stop at any ssa var, because that's expensive\n@@ -1167,7 +1159,7 @@ find_bivs (struct ivopts_data *data)\n \t    step = fold_convert (type, step);\n \t}\n \n-      set_iv (data, PHI_RESULT (phi), base, step);\n+      set_iv (data, PHI_RESULT (phi), base, step, iv.no_overflow);\n       found = true;\n     }\n \n@@ -1270,7 +1262,7 @@ find_givs_in_stmt (struct ivopts_data *data, gimple stmt)\n   if (!find_givs_in_stmt_scev (data, stmt, &iv))\n     return;\n \n-  set_iv (data, gimple_assign_lhs (stmt), iv.base, iv.step);\n+  set_iv (data, gimple_assign_lhs (stmt), iv.base, iv.step, iv.no_overflow);\n }\n \n /* Finds general ivs in basic block BB.  */\n@@ -1683,6 +1675,7 @@ idx_find_step (tree base, tree *idx, void *data)\n {\n   struct ifs_ivopts_data *dta = (struct ifs_ivopts_data *) data;\n   struct iv *iv;\n+  bool use_overflow_semantics = false;\n   tree step, iv_base, iv_step, lbound, off;\n   struct loop *loop = dta->ivopts_data->current_loop;\n \n@@ -1742,9 +1735,12 @@ idx_find_step (tree base, tree *idx, void *data)\n \n   iv_base = iv->base;\n   iv_step = iv->step;\n+  if (iv->no_overflow && nowrap_type_p (TREE_TYPE (iv_step)))\n+    use_overflow_semantics = true;\n+\n   if (!convert_affine_scev (dta->ivopts_data->current_loop,\n \t\t\t    sizetype, &iv_base, &iv_step, dta->stmt,\n-\t\t\t    false))\n+\t\t\t    use_overflow_semantics))\n     {\n       /* The index might wrap.  */\n       return false;"}]}