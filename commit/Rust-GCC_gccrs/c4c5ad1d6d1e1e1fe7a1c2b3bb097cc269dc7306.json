{"sha": "c4c5ad1d6d1e1e1fe7a1c2b3bb097cc269dc7306", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRjNWFkMWQ2ZDFlMWUxZmU3YTFjMmIzYmIwOTdjYzI2OWRjNzMwNg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2018-07-30T13:18:17Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-07-30T13:18:17Z"}, "message": "combine: Allow combining two insns to two insns\n\nThis patch allows combine to combine two insns into two.  This helps\nin many cases, by reducing instruction path length, and also allowing\nfurther combinations to happen.  PR85160 is a typical example of code\nthat it can improve.\n\nThis patch does not allow such combinations if either of the original\ninstructions was a simple move instruction.  In those cases combining\nthe two instructions increases register pressure without improving the\ncode.  With this move test register pressure does no longer increase\nnoticably as far as I can tell.\n\n(At first I also didn't allow either of the resulting insns to be a\nmove instruction.  But that is actually a very good thing to have, as\nshould have been obvious).\n\n\n\tPR rtl-optimization/85160\n\t* combine.c (is_just_move): New function.\n\t(try_combine): Allow combining two instructions into two if neither of\n\tthe original instructions was a move.\n\nFrom-SVN: r263067", "tree": {"sha": "db35a1bcff6529550ee3faeeff600824b8b1840d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db35a1bcff6529550ee3faeeff600824b8b1840d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4c5ad1d6d1e1e1fe7a1c2b3bb097cc269dc7306", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4c5ad1d6d1e1e1fe7a1c2b3bb097cc269dc7306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4c5ad1d6d1e1e1fe7a1c2b3bb097cc269dc7306", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4c5ad1d6d1e1e1fe7a1c2b3bb097cc269dc7306/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b74159752d6c1f955660e829a17e1aad1cead348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b74159752d6c1f955660e829a17e1aad1cead348", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b74159752d6c1f955660e829a17e1aad1cead348"}], "stats": {"total": 29, "additions": 27, "deletions": 2}, "files": [{"sha": "6a3a05b8ac034010668dee8699504a0ccfce3db5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4c5ad1d6d1e1e1fe7a1c2b3bb097cc269dc7306/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4c5ad1d6d1e1e1fe7a1c2b3bb097cc269dc7306/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4c5ad1d6d1e1e1fe7a1c2b3bb097cc269dc7306", "patch": "@@ -1,3 +1,10 @@\n+2018-07-30  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\tPR rtl-optimization/85160\n+\t* combine.c (is_just_move): New function.\n+\t(try_combine): Allow combining two instructions into two if neither of\n+\tthe original instructions was a move.\n+\n 2018-07-30  Alexander Monakov  <amonakov@ispras.ru>\n \n \tPR target/86673"}, {"sha": "3a5883a4c756d12939134e7f97684d5bad4dedaf", "filename": "gcc/combine.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4c5ad1d6d1e1e1fe7a1c2b3bb097cc269dc7306/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4c5ad1d6d1e1e1fe7a1c2b3bb097cc269dc7306/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c4c5ad1d6d1e1e1fe7a1c2b3bb097cc269dc7306", "patch": "@@ -2604,6 +2604,17 @@ can_split_parallel_of_n_reg_sets (rtx_insn *insn, int n)\n   return true;\n }\n \n+/* Return whether X is just a single set, with the source\n+   a general_operand.  */\n+static bool\n+is_just_move (rtx x)\n+{\n+  if (INSN_P (x))\n+    x = PATTERN (x);\n+\n+  return (GET_CODE (x) == SET && general_operand (SET_SRC (x), VOIDmode));\n+}\n+\n /* Try to combine the insns I0, I1 and I2 into I3.\n    Here I0, I1 and I2 appear earlier than I3.\n    I0 and I1 can be zero; then we combine just I2 into I3, or I1 and I2 into\n@@ -2668,6 +2679,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n   int swap_i2i3 = 0;\n   int split_i2i3 = 0;\n   int changed_i3_dest = 0;\n+  bool i2_was_move = false, i3_was_move = false;\n \n   int maxreg;\n   rtx_insn *temp_insn;\n@@ -3059,6 +3071,10 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       return 0;\n     }\n \n+  /* Record whether i2 and i3 are trivial moves.  */\n+  i2_was_move = is_just_move (i2);\n+  i3_was_move = is_just_move (i3);\n+\n   /* Record whether I2DEST is used in I2SRC and similarly for the other\n      cases.  Knowing this will help in register status updating below.  */\n   i2dest_in_i2src = reg_overlap_mentioned_p (i2dest, i2src);\n@@ -4014,8 +4030,10 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t   && XVECLEN (newpat, 0) == 2\n \t   && GET_CODE (XVECEXP (newpat, 0, 0)) == SET\n \t   && GET_CODE (XVECEXP (newpat, 0, 1)) == SET\n-\t   && (i1 || set_noop_p (XVECEXP (newpat, 0, 0))\n-\t\t  || set_noop_p (XVECEXP (newpat, 0, 1)))\n+\t   && (i1\n+\t       || set_noop_p (XVECEXP (newpat, 0, 0))\n+\t       || set_noop_p (XVECEXP (newpat, 0, 1))\n+\t       || (!i2_was_move && !i3_was_move))\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 0))) != ZERO_EXTRACT\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 0))) != STRICT_LOW_PART\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != ZERO_EXTRACT"}]}