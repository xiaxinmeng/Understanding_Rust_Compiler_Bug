{"sha": "60f5ed26b3f6935f26df139c7be127024eedd2c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBmNWVkMjZiM2Y2OTM1ZjI2ZGYxMzljN2JlMTI3MDI0ZWVkZDJjNQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-10-26T09:08:03Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-10-26T09:08:03Z"}, "message": "re PR fortran/41714 ([OOP] ALLOCATE SOURCE= does not properly copy the value from SOURCE)\n\n2009-10-26  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41714\n\t* gimple.h (tree_annotate_all_with_location): Remove prototype.\n\t* gimplify.c (tree_should_carry_location_p,\n\ttree_annotate_one_with_location,tree_annotate_all_with_location):\n\tRemove obsolete functions.\n\n\n2009-10-26  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41714\n\t* trans.c (gfc_trans_code): Remove call to\n\t'tree_annotate_all_with_location'. Location should already be set.\n\t* trans-openmp.c (gfc_trans_omp_workshare): Ditto.\n\t* trans-stmt.c (gfc_trans_allocate): Do correct data initialization for\n\tCLASS variables with SOURCE tag, plus some cleanup.\n\n\n2009-10-26  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41714\n\t* gfortran.dg/class_allocate_4.f03: New test.\n\nFrom-SVN: r153547", "tree": {"sha": "68e7035f44ef5bedcb6aab787fc1a8b286a0a8e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68e7035f44ef5bedcb6aab787fc1a8b286a0a8e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60f5ed26b3f6935f26df139c7be127024eedd2c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f5ed26b3f6935f26df139c7be127024eedd2c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60f5ed26b3f6935f26df139c7be127024eedd2c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f5ed26b3f6935f26df139c7be127024eedd2c5/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0418319a0bbb73569df8a266d36f9558fb8e1e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0418319a0bbb73569df8a266d36f9558fb8e1e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0418319a0bbb73569df8a266d36f9558fb8e1e2"}], "stats": {"total": 175, "additions": 67, "deletions": 108}, "files": [{"sha": "4ce99eb4e96160fa597b914ef7eee94a4e428021", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60f5ed26b3f6935f26df139c7be127024eedd2c5", "patch": "@@ -1,3 +1,11 @@\n+2009-10-26  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41714\n+\t* gimple.h (tree_annotate_all_with_location): Remove prototype.\n+\t* gimplify.c (tree_should_carry_location_p,\n+\ttree_annotate_one_with_location,tree_annotate_all_with_location):\n+\tRemove obsolete functions.\n+\n 2009-10-25  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR target/41813"}, {"sha": "8c333d8ca18e59395f5edc01cd6339498d7ff311", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=60f5ed26b3f6935f26df139c7be127024eedd2c5", "patch": "@@ -1,3 +1,12 @@\n+2009-10-26  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41714\n+\t* trans.c (gfc_trans_code): Remove call to\n+\t'tree_annotate_all_with_location'. Location should already be set.\n+\t* trans-openmp.c (gfc_trans_omp_workshare): Ditto.\n+\t* trans-stmt.c (gfc_trans_allocate): Do correct data initialization for\n+\tCLASS variables with SOURCE tag, plus some cleanup.\n+\n 2009-10-24  Janus Weil  <janus@gcc.gnu.org>\n \t    Paul Thomas  <pault@gcc.gnu.org>\n "}, {"sha": "4d461cfa488b3390f41478d15e207e580a781e7b", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=60f5ed26b3f6935f26df139c7be127024eedd2c5", "patch": "@@ -1641,11 +1641,6 @@ gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n \n       if (res != NULL_TREE && ! IS_EMPTY_STMT (res))\n \t{\n-\t  if (TREE_CODE (res) == STATEMENT_LIST)\n-\t    tree_annotate_all_with_location (&res, input_location);\n-\t  else\n-\t    SET_EXPR_LOCATION (res, input_location);\n-\n \t  if (prev_singleunit)\n \t    {\n \t      if (ompws_flags & OMPWS_CURR_SINGLEUNIT)"}, {"sha": "9b2a6230853086b1605b08b02311836e4555a713", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 21, "deletions": 49, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=60f5ed26b3f6935f26df139c7be127024eedd2c5", "patch": "@@ -3983,12 +3983,13 @@ gfc_trans_allocate (gfc_code * code)\n   tree stat;\n   tree pstat;\n   tree error_label;\n+  tree memsz;\n   stmtblock_t block;\n \n   if (!code->ext.alloc.list)\n     return NULL_TREE;\n \n-  pstat = stat = error_label = tmp = NULL_TREE;\n+  pstat = stat = error_label = tmp = memsz = NULL_TREE;\n \n   gfc_start_block (&block);\n \n@@ -4032,19 +4033,19 @@ gfc_trans_allocate (gfc_code * code)\n \t      gfc_init_se (&se_sz, NULL);\n \t      gfc_conv_expr (&se_sz, sz);\n \t      gfc_free_expr (sz);\n-\t      tmp = se_sz.expr;\n+\t      memsz = se_sz.expr;\n \t    }\n \t  else if (code->expr3 && code->expr3->ts.type != BT_CLASS)\n-\t    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->expr3->ts));\n+\t    memsz = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->expr3->ts));\n \t  else if (code->ext.alloc.ts.type != BT_UNKNOWN)\n-\t    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->ext.alloc.ts));\n+\t    memsz = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->ext.alloc.ts));\n \t  else\n-\t    tmp = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (se.expr)));\n+\t    memsz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (se.expr)));\n \n-\t  if (expr->ts.type == BT_CHARACTER && tmp == NULL_TREE)\n-\t    tmp = se.string_length;\n+\t  if (expr->ts.type == BT_CHARACTER && memsz == NULL_TREE)\n+\t    memsz = se.string_length;\n \n-\t  tmp = gfc_allocate_with_status (&se.pre, tmp, pstat);\n+\t  tmp = gfc_allocate_with_status (&se.pre, memsz, pstat);\n \t  tmp = fold_build2 (MODIFY_EXPR, void_type_node, se.expr,\n \t\t\t     fold_convert (TREE_TYPE (se.expr), tmp));\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n@@ -4075,21 +4076,17 @@ gfc_trans_allocate (gfc_code * code)\n       if (code->expr3)\n \t{\n \t  gfc_expr *rhs = gfc_copy_expr (code->expr3);\n-\t  if (rhs->ts.type == BT_CLASS)\n+\t  if (al->expr->ts.type == BT_CLASS)\n \t    {\n-\t      gfc_se dst,src,len;\n-\t      gfc_expr *sz;\n-\t      gfc_add_component_ref (rhs, \"$data\");\n-\t      sz = gfc_copy_expr (code->expr3);\n-\t      gfc_add_component_ref (sz, \"$size\");\n+\t      gfc_se dst,src;\n+\t      if (rhs->ts.type == BT_CLASS)\n+\t\tgfc_add_component_ref (rhs, \"$data\");\n \t      gfc_init_se (&dst, NULL);\n \t      gfc_init_se (&src, NULL);\n-\t      gfc_init_se (&len, NULL);\n \t      gfc_conv_expr (&dst, expr);\n \t      gfc_conv_expr (&src, rhs);\n-\t      gfc_conv_expr (&len, sz);\n-\t      gfc_free_expr (sz);\n-\t      tmp = gfc_build_memcpy_call (dst.expr, src.expr, len.expr);\n+\t      gfc_add_block_to_block (&block, &src.pre);\n+\t      tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz);\n \t    }\n \t  else\n \t    tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr),\n@@ -4108,8 +4105,7 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_conv_expr (&dst, expr);\n \t  gfc_conv_expr (&src, init_e);\n \t  gfc_add_block_to_block (&block, &src.pre);\n-\t  tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->ext.alloc.ts));\n-\t  tmp = gfc_build_memcpy_call (dst.expr, src.expr, tmp);\n+\t  tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n       /* Add default initializer for those derived types that need them.  */\n@@ -4127,6 +4123,7 @@ gfc_trans_allocate (gfc_code * code)\n       if (expr->ts.type == BT_CLASS)\n \t{\n \t  gfc_expr *lhs,*rhs;\n+\t  gfc_se lse;\n \t  /* Initialize VINDEX for CLASS objects.  */\n \t  lhs = gfc_expr_to_initialize (expr);\n \t  gfc_add_component_ref (lhs, \"$vindex\");\n@@ -4158,36 +4155,11 @@ gfc_trans_allocate (gfc_code * code)\n \t  /* Initialize SIZE for CLASS objects.  */\n \t  lhs = gfc_expr_to_initialize (expr);\n \t  gfc_add_component_ref (lhs, \"$size\");\n-\t  rhs = NULL;\n-\t  if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n-\t    {\n-\t      /* Size must be determined at run time.  */\n-\t      rhs = gfc_copy_expr (code->expr3);\n-\t      gfc_add_component_ref (rhs, \"$size\");\n-\t      tmp = gfc_trans_assignment (lhs, rhs, false);\n-\t      gfc_add_expr_to_block (&block, tmp);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Size is fixed at compile time.  */\n-\t      gfc_typespec *ts;\n-\t      gfc_se lse;\n-\t      gfc_init_se (&lse, NULL);\n-\t      gfc_conv_expr (&lse, lhs);\n-\t      if (code->expr3)\n-\t\tts = &code->expr3->ts;\n-\t      else if (code->ext.alloc.ts.type == BT_DERIVED)\n-\t\tts = &code->ext.alloc.ts;\n-\t      else if (expr->ts.type == BT_CLASS)\n-\t\tts = &expr->ts.u.derived->components->ts;\n-\t      else\n-\t\tts = &expr->ts;\n-\t      tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (ts));\n-\t      gfc_add_modify (&block, lse.expr,\n-\t\t\t      fold_convert (TREE_TYPE (lse.expr), tmp));\n-\t    }\n+\t  gfc_init_se (&lse, NULL);\n+\t  gfc_conv_expr (&lse, lhs);\n+\t  gfc_add_modify (&block, lse.expr,\n+\t\t\t  fold_convert (TREE_TYPE (lse.expr), memsz));\n \t  gfc_free_expr (lhs);\n-\t  gfc_free_expr (rhs);\n \t}\n \n     }"}, {"sha": "42d22388105383fcb386c747330585e06f9b0347", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=60f5ed26b3f6935f26df139c7be127024eedd2c5", "patch": "@@ -1281,9 +1281,7 @@ gfc_trans_code (gfc_code * code)\n \n       if (res != NULL_TREE && ! IS_EMPTY_STMT (res))\n \t{\n-\t  if (TREE_CODE (res) == STATEMENT_LIST)\n-\t    tree_annotate_all_with_location (&res, input_location);\n-\t  else\n+\t  if (TREE_CODE (res) != STATEMENT_LIST)\n \t    SET_EXPR_LOCATION (res, input_location);\n \t    \n \t  /* Add the new statement to the block.  */"}, {"sha": "8f6b3522098e549531bd6f81bdf07ce401dc74a6", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=60f5ed26b3f6935f26df139c7be127024eedd2c5", "patch": "@@ -939,7 +939,6 @@ extern tree create_tmp_var (tree, const char *);\n extern tree get_initialized_tmp_var (tree, gimple_seq *, gimple_seq *);\n extern tree get_formal_tmp_var (tree, gimple_seq *);\n extern void declare_vars (tree, gimple, bool);\n-extern void tree_annotate_all_with_location (tree *, location_t);\n extern void annotate_all_with_location (gimple_seq, location_t);\n \n /* Validation of GIMPLE expressions.  Note that these predicates only check"}, {"sha": "d68aacd04f39c6a601d9258cdee80335352617a5", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=60f5ed26b3f6935f26df139c7be127024eedd2c5", "patch": "@@ -777,23 +777,6 @@ should_carry_location_p (gimple gs)\n   return true;\n }\n \n-/* Same, but for a tree.  */\n-\n-static bool\n-tree_should_carry_location_p (const_tree stmt)\n-{\n-  /* Don't emit a line note for a label.  We particularly don't want to\n-     emit one for the break label, since it doesn't actually correspond\n-     to the beginning of the loop/switch.  */\n-  if (TREE_CODE (stmt) == LABEL_EXPR)\n-    return false;\n-\n-  /* Do not annotate empty statements, since it confuses gcov.  */\n-  if (!TREE_SIDE_EFFECTS (stmt))\n-    return false;\n-\n-  return true;\n-}\n \n /* Return true if a location should not be emitted for this statement\n    by annotate_one_with_location.  */\n@@ -826,16 +809,6 @@ annotate_one_with_location (gimple gs, location_t location)\n     gimple_set_location (gs, location);\n }\n \n-/* Same, but for tree T.  */\n-\n-static void\n-tree_annotate_one_with_location (tree t, location_t location)\n-{\n-  if (CAN_HAVE_LOCATION_P (t)\n-      && ! EXPR_HAS_LOCATION (t) && tree_should_carry_location_p (t))\n-    SET_EXPR_LOCATION (t, location);\n-}\n-\n \n /* Set LOCATION for all the statements after iterator GSI in sequence\n    SEQ.  If GSI is pointing to the end of the sequence, start with the\n@@ -872,29 +845,6 @@ annotate_all_with_location (gimple_seq stmt_p, location_t location)\n     }\n }\n \n-/* Same, but for statement or statement list in *STMT_P.  */\n-\n-void\n-tree_annotate_all_with_location (tree *stmt_p, location_t location)\n-{\n-  tree_stmt_iterator i;\n-\n-  if (!*stmt_p)\n-    return;\n-\n-  for (i = tsi_start (*stmt_p); !tsi_end_p (i); tsi_next (&i))\n-    {\n-      tree t = tsi_stmt (i);\n-\n-      /* Assuming we've already been gimplified, we shouldn't\n-\t  see nested chaining constructs anymore.  */\n-      gcc_assert (TREE_CODE (t) != STATEMENT_LIST\n-\t\t  && TREE_CODE (t) != COMPOUND_EXPR);\n-\n-      tree_annotate_one_with_location (t, location);\n-    }\n-}\n-\n \n /* Similar to copy_tree_r() but do not copy SAVE_EXPR or TARGET_EXPR nodes.\n    These nodes model computations that should only be done once.  If we"}, {"sha": "db1124b57dab8a81f29862aa3b2459cb22aa6719", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60f5ed26b3f6935f26df139c7be127024eedd2c5", "patch": "@@ -1,3 +1,8 @@\n+2009-10-26  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41714\n+\t* gfortran.dg/class_allocate_4.f03: New test.\n+\n 2009-10-24  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* gcc.target/mips/mult-1.c: New test."}, {"sha": "d1ebf8cc91595a31e35bbd9e2c3286d30fa4ca26", "filename": "gcc/testsuite/gfortran.dg/class_allocate_4.f03", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f5ed26b3f6935f26df139c7be127024eedd2c5/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_4.f03?ref=60f5ed26b3f6935f26df139c7be127024eedd2c5", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+!\n+! PR 41714: [OOP] ALLOCATE SOURCE= does not properly copy the value from SOURCE\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+type t\n+  integer :: i\n+end type t\n+type, extends(t) :: t2\n+  integer :: j\n+end type t2\n+\n+class(t), allocatable :: a\n+allocate(a, source=t2(1,2))\n+print *,a%i\n+if(a%i /= 1) call abort()\n+select type (a)\n+  type is (t2)\n+     print *,a%j\n+     if(a%j /= 2) call abort()\n+end select\n+end"}]}