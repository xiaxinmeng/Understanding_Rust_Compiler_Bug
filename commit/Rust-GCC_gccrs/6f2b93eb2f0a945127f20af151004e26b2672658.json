{"sha": "6f2b93eb2f0a945127f20af151004e26b2672658", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYyYjkzZWIyZjBhOTQ1MTI3ZjIwYWYxNTEwMDRlMjZiMjY3MjY1OA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-01-05T22:22:10Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-01-05T22:22:10Z"}, "message": "Class.h (_getMethods): Declare.\n\n\t* java/lang/Class.h (_getMethods): Declare.\n\t* java/lang/Class.java (_getMethods): Declare.\n\t* java/lang/natClass.cc (getDeclaringClass): Always return NULL.\n\t(getDeclaredClasses): Always return empty array.\n\t(_getMethods): New method.\n\t(getMethods): Wrote.\n\t(getDeclaredMethod): Return `rmethod'.\n\t(finit_name): New global.\n\t(getDeclaredMethods): Check for finit_name.\n\t(_getMethods): Likewise.\n\t(getMethod): Only return public methods.\n\nFrom-SVN: r31245", "tree": {"sha": "711ec302633170d1f9b65a055721609700aa5fbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/711ec302633170d1f9b65a055721609700aa5fbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f2b93eb2f0a945127f20af151004e26b2672658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f2b93eb2f0a945127f20af151004e26b2672658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f2b93eb2f0a945127f20af151004e26b2672658", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f2b93eb2f0a945127f20af151004e26b2672658/comments", "author": null, "committer": null, "parents": [{"sha": "cb3ca04ee18428f3c08b36f97ee0184449bcb6c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb3ca04ee18428f3c08b36f97ee0184449bcb6c6"}], "stats": {"total": 151, "additions": 143, "deletions": 8}, "files": [{"sha": "f0d0957c0695879b139a64861e28aa1928f14529", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2b93eb2f0a945127f20af151004e26b2672658/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2b93eb2f0a945127f20af151004e26b2672658/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6f2b93eb2f0a945127f20af151004e26b2672658", "patch": "@@ -1,5 +1,17 @@\n 2000-01-05  Tom Tromey  <tromey@cygnus.com>\n \n+\t* java/lang/Class.h (_getMethods): Declare.\n+\t* java/lang/Class.java (_getMethods): Declare.\n+\t* java/lang/natClass.cc (getDeclaringClass): Always return NULL.\n+\t(getDeclaredClasses): Always return empty array.\n+\t(_getMethods): New method.\n+\t(getMethods): Wrote.\n+\t(getDeclaredMethod): Return `rmethod'.\n+\t(finit_name): New global.\n+\t(getDeclaredMethods): Check for finit_name.\n+\t(_getMethods): Likewise.\n+\t(getMethod): Only return public methods.\n+\n \t* java/lang/reflect/natMethod.cc (get_ffi_type): Test size of\n \tjboolean and select correct ffi type on that basis.\n \t(_Jv_CallNonvirtualMethodA): Handle `void' return type."}, {"sha": "573683de215067d154dbc00a0adc39f61857350a", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2b93eb2f0a945127f20af151004e26b2672658/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2b93eb2f0a945127f20af151004e26b2672658/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=6f2b93eb2f0a945127f20af151004e26b2672658", "patch": "@@ -105,6 +105,8 @@ class java::lang::Class : public java::lang::Object\n   void getSignature (java::lang::StringBuffer *buffer);\n   static jstring getSignature (JArray<jclass> *, jboolean is_constructor);\n   java::lang::reflect::Method *getMethod (jstring, JArray<jclass> *);\n+  jint _getMethods (JArray<java::lang::reflect::Method *> *result,\n+\t\t    jint offset);\n   JArray<java::lang::reflect::Method *> *getMethods (void);\n \n   jint getModifiers (void)"}, {"sha": "127cc52457da6272e133d050948899c7caba312e", "filename": "libjava/java/lang/Class.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2b93eb2f0a945127f20af151004e26b2672658/libjava%2Fjava%2Flang%2FClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2b93eb2f0a945127f20af151004e26b2672658/libjava%2Fjava%2Flang%2FClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.java?ref=6f2b93eb2f0a945127f20af151004e26b2672658", "patch": "@@ -94,6 +94,7 @@ private static final native String getSignature (Class[] parameterTypes,\n \n   public native Method getMethod (String methodName, Class[] parameterTypes)\n     throws NoSuchMethodException, SecurityException;\n+  private native int _getMethods (Method[] result, int offset);\n   public native Method[] getMethods () throws SecurityException;\n \n   public native int getModifiers ();"}, {"sha": "8362dcc079e25d82a178a1a92bb5b12248294ad8", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 128, "deletions": 8, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2b93eb2f0a945127f20af151004e26b2672658/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2b93eb2f0a945127f20af151004e26b2672658/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=6f2b93eb2f0a945127f20af151004e26b2672658", "patch": "@@ -63,6 +63,7 @@ extern java::lang::Class ConstructorClass;\n static _Jv_Utf8Const *void_signature = _Jv_makeUtf8Const (\"()V\", 3);\n static _Jv_Utf8Const *clinit_name = _Jv_makeUtf8Const (\"<clinit>\", 8);\n static _Jv_Utf8Const *init_name = _Jv_makeUtf8Const (\"<init>\", 6);\n+static _Jv_Utf8Const *finit_name = _Jv_makeUtf8Const (\"$finit$\", 7);\n \n \f\n \n@@ -310,6 +311,7 @@ java::lang::Class::getDeclaredMethod (jstring name,\n \t  Method *rmethod = new Method ();\n \t  rmethod->offset = (char*) (&methods[i]) - (char*) methods;\n \t  rmethod->declaringClass = this;\n+\t  return rmethod;\n \t}\n     }\n   JvThrow (new java::lang::NoSuchMethodException);\n@@ -326,7 +328,8 @@ java::lang::Class::getDeclaredMethods (void)\n       _Jv_Method *method = &methods[i];\n       if (method->name == NULL\n \t  || _Jv_equalUtf8Consts (method->name, clinit_name)\n-\t  || _Jv_equalUtf8Consts (method->name, init_name))\n+\t  || _Jv_equalUtf8Consts (method->name, init_name)\n+\t  || _Jv_equalUtf8Consts (method->name, finit_name))\n \tcontinue;\n       numMethods++;\n     }\n@@ -339,7 +342,8 @@ java::lang::Class::getDeclaredMethods (void)\n       _Jv_Method *method = &methods[i];\n       if (method->name == NULL\n \t  || _Jv_equalUtf8Consts (method->name, clinit_name)\n-\t  || _Jv_equalUtf8Consts (method->name, init_name))\n+\t  || _Jv_equalUtf8Consts (method->name, init_name)\n+\t  || _Jv_equalUtf8Consts (method->name, finit_name))\n \tcontinue;\n       java::lang::reflect::Method* rmethod\n \t= new java::lang::reflect::Method ();\n@@ -370,16 +374,19 @@ JArray<jclass> *\n java::lang::Class::getDeclaredClasses (void)\n {\n   checkMemberAccess (java::lang::reflect::Member::DECLARED);\n-  JvFail (\"java::lang::Class::getDeclaredClasses not implemented\");\n-  return NULL;\t\t\t// Placate compiler.\n+  // Until we have inner classes, it always makes sense to return an\n+  // empty array.\n+  JArray<jclass> *result\n+    = (JArray<jclass> *) JvNewObjectArray (0, &ClassClass, NULL);\n+  return result;\n }\n \n-// This is marked as unimplemented in the JCL book.\n jclass\n java::lang::Class::getDeclaringClass (void)\n {\n-  JvFail (\"java::lang::Class::getDeclaringClass unimplemented\");\n-  return NULL;\t\t\t// Placate compiler.\n+  // Until we have inner classes, it makes sense to always return\n+  // NULL.\n+  return NULL;\n }\n \n jint\n@@ -463,6 +470,11 @@ java::lang::Class::getMethod (jstring name, JArray<jclass> *param_types)\n \t    {\n \t      // Found it.\n \t      using namespace java::lang::reflect;\n+\n+\t      // Method must be public.\n+\t      if (! Modifier::isPublic (methods[i].accflags))\n+\t\tbreak;\n+\n \t      Method *rmethod = new Method ();\n \t      rmethod->offset = (char*) (&klass->methods[i]) - (char*) methods;\n \t      rmethod->declaringClass = klass;\n@@ -473,10 +485,118 @@ java::lang::Class::getMethod (jstring name, JArray<jclass> *param_types)\n   JvThrow (new java::lang::NoSuchMethodException);\n }\n \n+// This is a very slow implementation, since it re-scans all the\n+// methods we've already listed to make sure we haven't duplicated a\n+// method.  It also over-estimates the required size, so we have to\n+// shrink the result array later.\n+jint\n+java::lang::Class::_getMethods (JArray<java::lang::reflect::Method *> *result,\n+\t\t\t\tjint offset)\n+{\n+  jint count = 0;\n+\n+  // First examine all local methods\n+  for (int i = isPrimitive () ? 0 : method_count; --i >= 0; )\n+    {\n+      _Jv_Method *method = &methods[i];\n+      if (method->name == NULL\n+\t  || _Jv_equalUtf8Consts (method->name, clinit_name)\n+\t  || _Jv_equalUtf8Consts (method->name, init_name)\n+\t  || _Jv_equalUtf8Consts (method->name, finit_name))\n+\tcontinue;\n+      // Only want public methods.\n+      if (! java::lang::reflect::Modifier::isPublic (method->accflags))\n+\tcontinue;\n+\n+      // This is where we over-count the slots required if we aren't\n+      // filling the result for real.\n+      if (result != NULL)\n+\t{\n+\t  jboolean add = true;\n+\t  java::lang::reflect::Method **mp = elements (result);\n+\t  // If we already have a method with this name and signature,\n+\t  // then ignore this one.  This can happen with virtual\n+\t  // methods.\n+\t  for (int j = 0; j < offset; ++j)\n+\t    {\n+\t      _Jv_Method *meth_2 = _Jv_FromReflectedMethod (mp[j]);\n+\t      if (_Jv_equalUtf8Consts (method->name, meth_2->name)\n+\t\t  && _Jv_equalUtf8Consts (method->signature,\n+\t\t\t\t\t  meth_2->signature))\n+\t\t{\n+\t\t  add = false;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (! add)\n+\t    continue;\n+\t}\n+\n+      if (result != NULL)\n+\t{\n+\t  using namespace java::lang::reflect;\n+\t  Method *rmethod = new Method ();\n+\t  rmethod->offset = (char *) method - (char *) methods;\n+\t  rmethod->declaringClass = this;\n+\t  Method **mp = elements (result);\n+\t  mp[offset + count] = rmethod;\n+\t}\n+      ++count;\n+    }\n+  offset += count;\n+\n+  // Now examine superclasses.\n+  if (getSuperclass () != NULL)\n+    {\n+      jint s_count = getSuperclass()->_getMethods (result, offset);\n+      offset += s_count;\n+      count += s_count;\n+    }\n+\n+  // Finally, examine interfaces.\n+  for (int i = 0; i < interface_count; ++i)\n+    {\n+      int f_count = interfaces[i]->_getMethods (result, offset);\n+      count += f_count;\n+      offset += f_count;\n+    }\n+\n+  return count;\n+}\n+\n JArray<java::lang::reflect::Method *> *\n java::lang::Class::getMethods (void)\n {\n-  JvFail (\"java::lang::Class::getMethods not implemented\");\n+  using namespace java::lang::reflect;\n+\n+  // FIXME: security checks.\n+\n+  // This will overestimate the size we need.\n+  jint count = _getMethods (NULL, 0);\n+\n+  JArray<Method *> *result\n+    = ((JArray<Method *> *) JvNewObjectArray (count, &MethodClass, NULL));\n+\n+  // When filling the array for real, we get the actual count.  Then\n+  // we resize the array.\n+  jint real_count = _getMethods (result, 0);\n+\n+  if (real_count != count)\n+    {\n+      JArray<Method *> *r2\n+\t= ((JArray<Method *> *) JvNewObjectArray (real_count, &MethodClass,\n+\t\t\t\t\t\t  NULL));\n+      \n+      Method **destp = elements (r2);\n+      Method **srcp = elements (result);\n+\n+      for (int i = 0; i < real_count; ++i)\n+\t*destp++ = *srcp++;\n+\n+      result = r2;\n+    }\n+\n+  return result;\n }\n \n jboolean"}]}