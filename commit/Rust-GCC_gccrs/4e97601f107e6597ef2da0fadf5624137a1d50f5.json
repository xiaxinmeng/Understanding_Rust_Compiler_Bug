{"sha": "4e97601f107e6597ef2da0fadf5624137a1d50f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU5NzYwMWYxMDdlNjU5N2VmMmRhMGZhZGY1NjI0MTM3YTFkNTBmNQ==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-11-08T22:03:06Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-11-08T22:03:06Z"}, "message": "(compare_for_stack_reg, subst_stack_regs_pat):\n\nFrom-SVN: r13113", "tree": {"sha": "6b482f73b67b8d343cb6bc404ced2a98f4bb7e88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b482f73b67b8d343cb6bc404ced2a98f4bb7e88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e97601f107e6597ef2da0fadf5624137a1d50f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e97601f107e6597ef2da0fadf5624137a1d50f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e97601f107e6597ef2da0fadf5624137a1d50f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e97601f107e6597ef2da0fadf5624137a1d50f5/comments", "author": null, "committer": null, "parents": [{"sha": "7a976aea15ceb44578d5e0e883e4dbb74e60078a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a976aea15ceb44578d5e0e883e4dbb74e60078a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a976aea15ceb44578d5e0e883e4dbb74e60078a"}], "stats": {"total": 66, "additions": 66, "deletions": 0}, "files": [{"sha": "ea72b3aa351207c27955ddd584f250cf7e0b1861", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e97601f107e6597ef2da0fadf5624137a1d50f5/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e97601f107e6597ef2da0fadf5624137a1d50f5/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=4e97601f107e6597ef2da0fadf5624137a1d50f5", "patch": "@@ -2017,9 +2017,26 @@ compare_for_stack_reg (insn, regstack, pat)\n {\n   rtx *src1, *src2;\n   rtx src1_note, src2_note;\n+  rtx cc0_user;\n \n   src1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n   src2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n+  cc0_user = next_cc0_user (insn);\n+\n+  /* If the insn that uses cc0 is a conditional move, then the destination\n+     must be the top of stack */\n+  if (GET_CODE (PATTERN (cc0_user)) == SET\n+      && SET_DEST (PATTERN (cc0_user)) != pc_rtx\n+      && GET_CODE (SET_SRC (PATTERN (cc0_user))) == IF_THEN_ELSE)\n+    {\n+      rtx *dest, src_note;\n+      \n+      dest = get_true_reg (&SET_DEST (PATTERN (cc0_user)));\n+      if (REGNO (*dest) != regstack->reg[regstack->top])\n+\t{\n+\t  emit_swap_insn (insn, regstack, *dest);\t\n+\t}\n+    }\n \n   /* ??? If fxch turns out to be cheaper than fstp, give priority to\n      registers that die in this insn - move those to stack top first.  */\n@@ -2336,6 +2353,55 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t  }\n \tbreak;\n \n+      case IF_THEN_ELSE:\n+\t/* This insn requires the top of stack to be the destination. */\n+\n+\tsrc1 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n+\tsrc2 = get_true_reg (&XEXP (SET_SRC (pat), 2));\n+\n+\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\tsrc2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n+\n+\t{\n+\t  rtx src_note [] = {0, src1_note, src2_note};\n+\t  int i;\n+\n+\t  if (STACK_REG_P (*src1))\n+\t    replace_reg (src1, get_hard_regnum (regstack, *src1));\n+\t  if (STACK_REG_P (*src2))\n+\t    replace_reg (src2, get_hard_regnum (regstack, *src2));\n+\n+\t  for (i = 1; i <= 2; i++)\n+\t    if (src_note [i])\n+\t      {\n+\t\tint regno = get_hard_regnum (regstack, XEXP (src_note [i], 0));\n+\n+\t\t/* If the register that dies is not at the top of stack, then\n+\t\t   move the top of stack to the dead reg */\n+\t\tif (REGNO (XEXP (src_note[i], 0))\n+\t\t    != regstack->reg[regstack->top])\n+\t\t  {\n+\t\t    remove_regno_note (insn, REG_DEAD,\n+\t\t\t\t       REGNO (XEXP (src_note [i], 0)));\n+\t\t    emit_pop_insn (insn, regstack, XEXP (src_note[i], 0),\n+\t\t\t\t   emit_insn_after);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    CLEAR_HARD_REG_BIT (regstack->reg_set,\n+\t\t\t\t\tREGNO (XEXP (src_note[i], 0)));\n+\t\t    replace_reg (&XEXP (src_note[i], 0), FIRST_STACK_REG);\n+\t\t    regstack->top--;\n+\t\t  }\n+\t\t\n+\t      }\n+\n+\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t  replace_reg (dest, FIRST_STACK_REG);\n+\t}\n+\n+\tbreak;\n+\n       default:\n \tabort ();\n       }"}]}