{"sha": "d355361573c6be211721cc5c945dd5cecdd33c6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM1NTM2MTU3M2M2YmUyMTE3MjFjYzVjOTQ1ZGQ1Y2VjZGQzM2M2Yg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-10-18T09:04:54Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-10-18T09:04:54Z"}, "message": "tree-ssa-alias.h (struct pt_solution): Remove vars_contains_restrict member.\n\n2011-10-18  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-alias.h (struct pt_solution): Remove\n\tvars_contains_restrict member.\n\t(pt_solutions_same_restrict_base): Remove.\n\t(pt_solution_set): Adjust.\n\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Remove\n\tvars_contains_restrict handling.\n\t(dump_points_to_solution): Likewise.\n\t(ptr_derefs_may_alias_p): Do not call pt_solutions_same_restrict_base.\n\t* tree-ssa-structalias.c (struct variable_info): Remove is_restrict_var\n\tfield.\n\t(new_var_info): Do not initialize it.\n\t(ipa_escaped_pt): Adjust.\n\t(make_constraint_from_restrict): Make the tag global.\n\t(make_constraint_from_global_restrict): New function.\n\t(make_constraint_from_heapvar): Remove.\n\t(create_variable_info_for): Do not make restrict vars point\n\tto NONLOCAL.\n\t(intra_create_variable_infos): Likewise.\n\t(find_what_var_points_to): Remove vars_contains_restrict handling.\n\t(pt_solution_set): Adjust.\n\t(pt_solution_ior_into): Likewise.\n\t(pt_solutions_same_restrict_base): Remove.\n\t(compute_points_to_sets): Do not test is_restrict_var.\n\t* cfgexpand.c (update_alias_info_with_stack_vars): Adjust.\n\t* gimple-pretty-print.c (pp_points_to_solution): Likewise.\n\n\t* gcc.dg/torture/restrict-1.c: New testcase.\n\nFrom-SVN: r180127", "tree": {"sha": "ad64e7e5ce1fd4cc1b53fc1e3855b9d08b561592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad64e7e5ce1fd4cc1b53fc1e3855b9d08b561592"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d355361573c6be211721cc5c945dd5cecdd33c6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d355361573c6be211721cc5c945dd5cecdd33c6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d355361573c6be211721cc5c945dd5cecdd33c6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d355361573c6be211721cc5c945dd5cecdd33c6b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "266fbb797168bffea7bf23c20c2a5562d73bb8ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266fbb797168bffea7bf23c20c2a5562d73bb8ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266fbb797168bffea7bf23c20c2a5562d73bb8ca"}], "stats": {"total": 171, "additions": 87, "deletions": 84}, "files": [{"sha": "6b32e2731e49c967727e618d982e1a3722ae758b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d355361573c6be211721cc5c945dd5cecdd33c6b", "patch": "@@ -1,3 +1,31 @@\n+2011-10-18  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-alias.h (struct pt_solution): Remove\n+\tvars_contains_restrict member.\n+\t(pt_solutions_same_restrict_base): Remove.\n+\t(pt_solution_set): Adjust.\n+\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Remove\n+\tvars_contains_restrict handling.\n+\t(dump_points_to_solution): Likewise.\n+\t(ptr_derefs_may_alias_p): Do not call pt_solutions_same_restrict_base.\n+\t* tree-ssa-structalias.c (struct variable_info): Remove is_restrict_var\n+\tfield.\n+\t(new_var_info): Do not initialize it.\n+\t(ipa_escaped_pt): Adjust.\n+\t(make_constraint_from_restrict): Make the tag global.\n+\t(make_constraint_from_global_restrict): New function.\n+\t(make_constraint_from_heapvar): Remove.\n+\t(create_variable_info_for): Do not make restrict vars point\n+\tto NONLOCAL.\n+\t(intra_create_variable_infos): Likewise.\n+\t(find_what_var_points_to): Remove vars_contains_restrict handling.\n+\t(pt_solution_set): Adjust.\n+\t(pt_solution_ior_into): Likewise.\n+\t(pt_solutions_same_restrict_base): Remove.\n+\t(compute_points_to_sets): Do not test is_restrict_var.\n+\t* cfgexpand.c (update_alias_info_with_stack_vars): Adjust.\n+\t* gimple-pretty-print.c (pp_points_to_solution): Likewise.\n+\n 2011-10-18  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/50672"}, {"sha": "ddf3fd1d305ef7a9912903722dccfb0099010b39", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=d355361573c6be211721cc5c945dd5cecdd33c6b", "patch": "@@ -530,7 +530,7 @@ update_alias_info_with_stack_vars (void)\n \n       /* Make the SSA name point to all partition members.  */\n       pi = get_ptr_info (name);\n-      pt_solution_set (&pi->pt, part, false, false);\n+      pt_solution_set (&pi->pt, part, false);\n     }\n \n   /* Make all points-to sets that contain one member of a partition"}, {"sha": "8120158772cf67404dd3f81f29a1837ccd9cbdd9", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=d355361573c6be211721cc5c945dd5cecdd33c6b", "patch": "@@ -610,8 +610,6 @@ pp_points_to_solution (pretty_printer *buffer, struct pt_solution *pt)\n       pp_character (buffer, '}');\n       if (pt->vars_contains_global)\n \tpp_string (buffer, \" (glob)\");\n-      if (pt->vars_contains_restrict)\n-\tpp_string (buffer, \" (restr)\");\n     }\n }\n "}, {"sha": "fb5b8fd04b09abc9ea5b0418f282f6f07f86ce7a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d355361573c6be211721cc5c945dd5cecdd33c6b", "patch": "@@ -1,3 +1,7 @@\n+2011-10-18  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/torture/restrict-1.c: New testcase.\n+\n 2011-10-17  Michael Spertus  <mike_spertus@symantec.com>\n \n \t* g++.dg/ext/bases.C: New test."}, {"sha": "e7af4f538ced6785105d951320d86933622147a7", "filename": "gcc/testsuite/gcc.dg/torture/restrict-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Frestrict-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Frestrict-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Frestrict-1.c?ref=d355361573c6be211721cc5c945dd5cecdd33c6b", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+void __attribute__((noinline,noclone))\n+foo (int ** __restrict__ p, int ** __restrict__ q)\n+{\n+  **p = **q;\n+}\n+int main()\n+{\n+  int x = 0, y = 1, *i = &x, *j = &y;\n+  foo (&i, &j);\n+  if (x != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "57fc7341c5405815c3136bae7c4390a26caccb01", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=d355361573c6be211721cc5c945dd5cecdd33c6b", "patch": "@@ -219,13 +219,6 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n   if (!pi)\n     return true;\n \n-  /* If the decl can be used as a restrict tag and we have a restrict\n-     pointer and that pointers points-to set doesn't contain this decl\n-     then they can't alias.  */\n-  if (DECL_RESTRICTED_P (decl)\n-      && pi->pt.vars_contains_restrict)\n-    return bitmap_bit_p (pi->pt.vars, DECL_PT_UID (decl));\n-\n   return pt_solution_includes (&pi->pt, decl);\n }\n \n@@ -316,11 +309,6 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n   if (!pi1 || !pi2)\n     return true;\n \n-  /* If both pointers are restrict-qualified try to disambiguate\n-     with restrict information.  */\n-  if (!pt_solutions_same_restrict_base (&pi1->pt, &pi2->pt))\n-    return false;\n-\n   /* ???  This does not use TBAA to prune decls from the intersection\n      that not both pointers may access.  */\n   return pt_solutions_intersect (&pi1->pt, &pi2->pt);\n@@ -426,8 +414,6 @@ dump_points_to_solution (FILE *file, struct pt_solution *pt)\n       dump_decl_set (file, pt->vars);\n       if (pt->vars_contains_global)\n \tfprintf (file, \" (includes global vars)\");\n-      if (pt->vars_contains_restrict)\n-\tfprintf (file, \" (includes restrict tags)\");\n     }\n }\n "}, {"sha": "7492123104527b72d6d8d0c7fe031f2a3841a922", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=d355361573c6be211721cc5c945dd5cecdd33c6b", "patch": "@@ -54,8 +54,6 @@ struct GTY(()) pt_solution\n   /* Nonzero if the pt_vars bitmap includes a global variable.  */\n   unsigned int vars_contains_global : 1;\n \n-  /* Nonzero if the pt_vars bitmap includes a restrict tag variable.  */\n-  unsigned int vars_contains_restrict : 1;\n \n   /* Set of variables that this pointer may point to.  */\n   bitmap vars;\n@@ -130,10 +128,8 @@ extern bool pt_solution_singleton_p (struct pt_solution *, unsigned *);\n extern bool pt_solution_includes_global (struct pt_solution *);\n extern bool pt_solution_includes (struct pt_solution *, const_tree);\n extern bool pt_solutions_intersect (struct pt_solution *, struct pt_solution *);\n-extern bool pt_solutions_same_restrict_base (struct pt_solution *,\n-\t\t\t\t\t     struct pt_solution *);\n extern void pt_solution_reset (struct pt_solution *);\n-extern void pt_solution_set (struct pt_solution *, bitmap, bool, bool);\n+extern void pt_solution_set (struct pt_solution *, bitmap, bool);\n extern void pt_solution_set_var (struct pt_solution *, tree);\n \n extern void dump_pta_stats (FILE *);"}, {"sha": "51f2aa1bf7cab34cf62249476d8bb7a46109e2a6", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 37, "deletions": 62, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355361573c6be211721cc5c945dd5cecdd33c6b/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=d355361573c6be211721cc5c945dd5cecdd33c6b", "patch": "@@ -261,9 +261,6 @@ struct variable_info\n   /* True if this is a heap variable.  */\n   unsigned int is_heap_var : 1;\n \n-  /* True if this is a variable tracking a restrict pointer source.  */\n-  unsigned int is_restrict_var : 1;\n-\n   /* True if this field may contain pointers.  */\n   unsigned int may_have_pointers : 1;\n \n@@ -350,7 +347,6 @@ new_var_info (tree t, const char *name)\n   ret->is_unknown_size_var = false;\n   ret->is_full_var = (t == NULL_TREE);\n   ret->is_heap_var = false;\n-  ret->is_restrict_var = false;\n   ret->may_have_pointers = true;\n   ret->only_restrict_pointers = false;\n   ret->is_global_var = (t == NULL_TREE);\n@@ -3643,30 +3639,30 @@ make_heapvar (const char *name)\n }\n \n /* Create a new artificial heap variable with NAME and make a\n-   constraint from it to LHS.  Return the created variable.  */\n+   constraint from it to LHS.  Set flags according to a tag used\n+   for tracking restrict pointers.  */\n \n static varinfo_t\n-make_constraint_from_heapvar (varinfo_t lhs, const char *name)\n+make_constraint_from_restrict (varinfo_t lhs, const char *name)\n {\n   varinfo_t vi = make_heapvar (name);\n+  vi->is_global_var = 1;\n+  vi->may_have_pointers = 1;\n   make_constraint_from (lhs, vi->id);\n-\n   return vi;\n }\n \n /* Create a new artificial heap variable with NAME and make a\n    constraint from it to LHS.  Set flags according to a tag used\n-   for tracking restrict pointers.  */\n+   for tracking restrict pointers and make the artificial heap\n+   point to global memory.  */\n \n-static void\n-make_constraint_from_restrict (varinfo_t lhs, const char *name)\n+static varinfo_t\n+make_constraint_from_global_restrict (varinfo_t lhs, const char *name)\n {\n-  varinfo_t vi;\n-  vi = make_constraint_from_heapvar (lhs, name);\n-  vi->is_restrict_var = 1;\n-  vi->is_global_var = 0;\n-  vi->is_special_var = 1;\n-  vi->may_have_pointers = 0;\n+  varinfo_t vi = make_constraint_from_restrict (lhs, name);\n+  make_copy_constraint (vi, nonlocal_id);\n+  return vi;\n }\n \n /* In IPA mode there are varinfos for different aspects of reach\n@@ -5504,13 +5500,18 @@ create_variable_info_for (tree decl, const char *name)\n       if ((POINTER_TYPE_P (TREE_TYPE (decl))\n \t   && TYPE_RESTRICT (TREE_TYPE (decl)))\n \t  || vi->only_restrict_pointers)\n-\tmake_constraint_from_restrict (vi, \"GLOBAL_RESTRICT\");\n+\t{\n+\t  make_constraint_from_global_restrict (vi, \"GLOBAL_RESTRICT\");\n+\t  continue;\n+\t}\n \n       /* In non-IPA mode the initializer from nonlocal is all we need.  */\n       if (!in_ipa_mode\n \t  || DECL_HARD_REGISTER (decl))\n \tmake_copy_constraint (vi, nonlocal_id);\n \n+      /* In IPA mode parse the initializer and generate proper constraints\n+\t for it.  */\n       else\n \t{\n \t  struct varpool_node *vnode = varpool_get_node (decl);\n@@ -5595,7 +5596,7 @@ intra_create_variable_infos (void)\n      passed-by-reference argument.  */\n   for (t = DECL_ARGUMENTS (current_function_decl); t; t = DECL_CHAIN (t))\n     {\n-      varinfo_t p;\n+      varinfo_t p = get_vi_for_tree (t);\n \n       /* For restrict qualified pointers to objects passed by\n          reference build a real representative for the pointed-to object.\n@@ -5610,34 +5611,37 @@ intra_create_variable_infos (void)\n \t  DECL_EXTERNAL (heapvar) = 1;\n \t  vi = create_variable_info_for_1 (heapvar, \"PARM_NOALIAS\");\n \t  insert_vi_for_tree (heapvar, vi);\n-\t  lhsc.var = get_vi_for_tree (t)->id;\n+\t  lhsc.var = p->id;\n \t  lhsc.type = SCALAR;\n \t  lhsc.offset = 0;\n \t  rhsc.var = vi->id;\n \t  rhsc.type = ADDRESSOF;\n \t  rhsc.offset = 0;\n \t  process_constraint (new_constraint (lhsc, rhsc));\n-\t  vi->is_restrict_var = 1;\n \t  for (; vi; vi = vi->next)\n \t    if (vi->may_have_pointers)\n \t      {\n \t\tif (vi->only_restrict_pointers)\n-\t\t  make_constraint_from_restrict (vi, \"GLOBAL_RESTRICT\");\n-\t\tmake_copy_constraint (vi, nonlocal_id);\n+\t\t  make_constraint_from_global_restrict (vi, \"GLOBAL_RESTRICT\");\n+\t\telse\n+\t\t  make_copy_constraint (vi, nonlocal_id);\n \t      }\n \t  continue;\n \t}\n \n-      for (p = get_vi_for_tree (t); p; p = p->next)\n-\t{\n-\t  if (p->may_have_pointers)\n-\t    make_constraint_from (p, nonlocal_id);\n-\t  if (p->only_restrict_pointers)\n-\t    make_constraint_from_restrict (p, \"PARM_RESTRICT\");\n-\t}\n       if (POINTER_TYPE_P (TREE_TYPE (t))\n \t  && TYPE_RESTRICT (TREE_TYPE (t)))\n-\tmake_constraint_from_restrict (get_vi_for_tree (t), \"PARM_RESTRICT\");\n+\tmake_constraint_from_global_restrict (p, \"PARM_RESTRICT\");\n+      else\n+\t{\n+\t  for (; p; p = p->next)\n+\t    {\n+\t      if (p->only_restrict_pointers)\n+\t\tmake_constraint_from_global_restrict (p, \"PARM_RESTRICT\");\n+\t      else if (p->may_have_pointers)\n+\t\tmake_constraint_from (p, nonlocal_id);\n+\t    }\n+\t}\n     }\n \n   /* Add a constraint for a result decl that is passed by reference.  */\n@@ -5813,15 +5817,11 @@ find_what_var_points_to (varinfo_t orig_vi, struct pt_solution *pt)\n \t\t   || vi->id == integer_id)\n \t    pt->anything = 1;\n \t}\n-      if (vi->is_restrict_var)\n-\tpt->vars_contains_restrict = true;\n     }\n \n   /* Instead of doing extra work, simply do not create\n      elaborate points-to information for pt_anything pointers.  */\n-  if (pt->anything\n-      && (orig_vi->is_artificial_var\n-\t  || !pt->vars_contains_restrict))\n+  if (pt->anything)\n     return;\n \n   /* Share the final set of variables when possible.  */\n@@ -5912,13 +5912,11 @@ pt_solution_reset (struct pt_solution *pt)\n    it contains restrict tag variables.  */\n \n void\n-pt_solution_set (struct pt_solution *pt, bitmap vars,\n-\t\t bool vars_contains_global, bool vars_contains_restrict)\n+pt_solution_set (struct pt_solution *pt, bitmap vars, bool vars_contains_global)\n {\n   memset (pt, 0, sizeof (struct pt_solution));\n   pt->vars = vars;\n   pt->vars_contains_global = vars_contains_global;\n-  pt->vars_contains_restrict = vars_contains_restrict;\n }\n \n /* Set the points-to solution *PT to point only to the variable VAR.  */\n@@ -5953,7 +5951,6 @@ pt_solution_ior_into (struct pt_solution *dest, struct pt_solution *src)\n   dest->ipa_escaped |= src->ipa_escaped;\n   dest->null |= src->null;\n   dest->vars_contains_global |= src->vars_contains_global;\n-  dest->vars_contains_restrict |= src->vars_contains_restrict;\n   if (!src->vars)\n     return;\n \n@@ -6141,27 +6138,6 @@ pt_solutions_intersect (struct pt_solution *pt1, struct pt_solution *pt2)\n   return res;\n }\n \n-/* Return true if both points-to solutions PT1 and PT2 for two restrict\n-   qualified pointers are possibly based on the same pointer.  */\n-\n-bool\n-pt_solutions_same_restrict_base (struct pt_solution *pt1,\n-\t\t\t\t struct pt_solution *pt2)\n-{\n-  /* If we deal with points-to solutions of two restrict qualified\n-     pointers solely rely on the pointed-to variable bitmap intersection.\n-     For two pointers that are based on each other the bitmaps will\n-     intersect.  */\n-  if (pt1->vars_contains_restrict\n-      && pt2->vars_contains_restrict)\n-    {\n-      gcc_assert (pt1->vars && pt2->vars);\n-      return bitmap_intersect_p (pt1->vars, pt2->vars);\n-    }\n-\n-  return true;\n-}\n-\n \n /* Dump points-to information to OUTFILE.  */\n \n@@ -6574,7 +6550,6 @@ compute_points_to_sets (void)\n   /* Mark escaped HEAP variables as global.  */\n   FOR_EACH_VEC_ELT (varinfo_t, varmap, i, vi)\n     if (vi->is_heap_var\n-\t&& !vi->is_restrict_var\n \t&& !vi->is_global_var)\n       DECL_EXTERNAL (vi->decl) = vi->is_global_var\n \t= pt_solution_includes (&cfun->gimple_df->escaped, vi->decl);\n@@ -6794,7 +6769,7 @@ gate_ipa_pta (void)\n \n /* IPA PTA solutions for ESCAPED.  */\n struct pt_solution ipa_escaped_pt\n-  = { true, false, false, false, false, false, false, NULL };\n+  = { true, false, false, false, false, false, NULL };\n \n /* Associate node with varinfo DATA. Worker for\n    cgraph_for_node_and_aliases.  */"}]}