{"sha": "63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNmYmY1ODY1YTVmYzQ4YTI1ZmY0NDEwZTdjMjc1N2JiMjRjMzZjOA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-07-21T11:02:47Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-07-21T11:02:47Z"}, "message": "re PR fortran/48820 (TR 29113: Implement parts needed for MPI 3)\n\n2012-07-21  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/48820\n        * trans-intrinsic.c (gfc_conv_intrinsic_bound): Support\n        lbound/ubound with dim= for assumed-rank arrays.\n        * array.c (gfc_set_array_spec): Reject coarrays with\n        assumed shape.\n        * decl.c (merge_array_spec): Ditto. Return gfc_try.\n        (match_attr_spec, match_attr_spec): Update call.\n\n2012-07-21  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/48820\n        * gfortran.dg/assumed_rank_3.f90: New.\n        * gfortran.dg/assumed_rank_11.f90: New.\n        * gfortran.dg/assumed_rank_1.f90: Update dg-error.\n        * gfortran.dg/assumed_rank_2.f90: Update dg-error.\n        * gfortran.dg/assumed_rank_7.f90: Update dg-error.\n\nFrom-SVN: r189743", "tree": {"sha": "33f73a98fbea8e542783998243400448f3ba8051", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33f73a98fbea8e542783998243400448f3ba8051"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aea21190650881b9b17580a55f61393eb78f33a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea21190650881b9b17580a55f61393eb78f33a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aea21190650881b9b17580a55f61393eb78f33a4"}], "stats": {"total": 233, "additions": 183, "deletions": 50}, "files": [{"sha": "b388efc22c5820359f57e41fbf2633f9846179de", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "patch": "@@ -1,3 +1,13 @@\n+2012-07-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/48820\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Support\n+\tlbound/ubound with dim= for assumed-rank arrays.\n+\t* array.c (gfc_set_array_spec): Reject coarrays with\n+\tassumed shape.\n+\t* decl.c (merge_array_spec): Ditto. Return gfc_try.\n+\t(match_attr_spec, match_attr_spec): Update call.\n+\n 2012-07-21  Tobias Burnus  <burnus@net-b.de>\n \n \t* resolve.c (resolve_formal_arglist): Put variable"}, {"sha": "1b700b81109def13f7eae4784af9a9ddab57c004", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "patch": "@@ -750,6 +750,14 @@ gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)\n       return SUCCESS;\n     }\n \n+  if ((sym->as->type == AS_ASSUMED_RANK && as->corank)\n+      || (as->type == AS_ASSUMED_RANK && sym->as->corank))\n+    {\n+      gfc_error (\"The assumed-rank array '%s' at %L shall not have a \"\n+\t\t \"codimension\", sym->name, error_loc);\n+      return FAILURE;\n+    }\n+\n   if (as->corank)\n     {\n       /* The \"sym\" has no corank (checked via gfc_add_codimension). Thus"}, {"sha": "5d234e600e6a5f43ad001e43994ed16698835149", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "patch": "@@ -589,13 +589,17 @@ gfc_match_data (void)\n \n /* Auxiliary function to merge DIMENSION and CODIMENSION array specs.  */\n \n-static void\n+static gfc_try\n merge_array_spec (gfc_array_spec *from, gfc_array_spec *to, bool copy)\n {\n   int i;\n \n-  gcc_assert (from->rank != -1 || to->corank == 0);\n-  gcc_assert (to->rank != -1 || from->corank == 0);\n+  if ((from->type == AS_ASSUMED_RANK && to->corank)\n+      || (to->type == AS_ASSUMED_RANK && from->corank))\n+    {\n+      gfc_error (\"The assumed-rank array at %C shall not have a codimension\");\n+      return FAILURE;\n+    }\n \n   if (to->rank == 0 && from->rank > 0)\n     {\n@@ -642,6 +646,8 @@ merge_array_spec (gfc_array_spec *from, gfc_array_spec *to, bool copy)\n \t    }\n \t}\n     }\n+\n+  return SUCCESS;\n }\n \n \n@@ -1799,8 +1805,12 @@ variable_decl (int elem)\n \n   if (m == MATCH_NO)\n     as = gfc_copy_array_spec (current_as);\n-  else if (current_as)\n-    merge_array_spec (current_as, as, true);\n+  else if (current_as\n+\t   && merge_array_spec (current_as, as, true) == FAILURE)\n+    {\n+      m = MATCH_ERROR;\n+      goto cleanup;\n+    }\n \n   if (gfc_option.flag_cray_pointer)\n     cp_as = gfc_copy_array_spec (as);\n@@ -3512,7 +3522,8 @@ match_attr_spec (void)\n \t    current_as = as;\n \t  else if (m == MATCH_YES)\n \t    {\n-\t      merge_array_spec (as, current_as, false);\n+\t      if (merge_array_spec (as, current_as, false) == FAILURE)\n+\t\tm = MATCH_ERROR;\n \t      free (as);\n \t    }\n "}, {"sha": "7bcfda9301d3f9d44a42340503a3befc03a92cc8", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "patch": "@@ -1367,6 +1367,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   gfc_se argse;\n   gfc_ss *ss;\n   gfc_array_spec * as;\n+  bool assumed_rank_lb_one;\n \n   arg = expr->value.function.actual;\n   arg2 = arg->next;\n@@ -1408,39 +1409,56 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \n   desc = argse.expr;\n \n+  as = gfc_get_full_arrayspec_from_expr (arg->expr);\n+\n   if (INTEGER_CST_P (bound))\n     {\n       int hi, low;\n \n       hi = TREE_INT_CST_HIGH (bound);\n       low = TREE_INT_CST_LOW (bound);\n-      if (hi || low < 0 || low >= GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc)))\n+      if (hi || low < 0\n+\t  || ((!as || as->type != AS_ASSUMED_RANK)\n+\t      && low >= GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc)))\n+\t  || low > GFC_MAX_DIMENSIONS)\n \tgfc_error (\"'dim' argument of %s intrinsic at %L is not a valid \"\n \t\t   \"dimension index\", upper ? \"UBOUND\" : \"LBOUND\",\n \t\t   &expr->where);\n     }\n-  else\n+\n+  if (!INTEGER_CST_P (bound) || (as && as->type == AS_ASSUMED_RANK))\n     {\n       if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n         {\n           bound = gfc_evaluate_now (bound, &se->pre);\n           cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n \t\t\t\t  bound, build_int_cst (TREE_TYPE (bound), 0));\n-          tmp = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))];\n+\t  if (as && as->type == AS_ASSUMED_RANK)\n+\t    tmp = get_rank_from_desc (desc);\n+\t  else\n+\t    tmp = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))];\n           tmp = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n-\t\t\t\t bound, tmp);\n+\t\t\t\t bound, fold_convert(TREE_TYPE (bound), tmp));\n           cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n \t\t\t\t  boolean_type_node, cond, tmp);\n           gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t\t   gfc_msg_fault);\n         }\n     }\n \n+  /* Take care of the lbound shift for assumed-rank arrays, which are\n+     nonallocatable and nonpointers. Those has a lbound of 1.  */\n+  assumed_rank_lb_one = as && as->type == AS_ASSUMED_RANK\n+\t\t\t&& ((arg->expr->ts.type != BT_CLASS\n+\t\t\t     && !arg->expr->symtree->n.sym->attr.allocatable\n+\t\t\t     && !arg->expr->symtree->n.sym->attr.pointer)\n+\t\t\t    || (arg->expr->ts.type == BT_CLASS\n+\t\t\t     && !CLASS_DATA (arg->expr)->attr.allocatable\n+\t\t\t     && !CLASS_DATA (arg->expr)->attr.class_pointer));\n+\n   ubound = gfc_conv_descriptor_ubound_get (desc, bound);\n   lbound = gfc_conv_descriptor_lbound_get (desc, bound);\n   \n-  as = gfc_get_full_arrayspec_from_expr (arg->expr);\n-\n   /* 13.14.53: Result value for LBOUND\n \n      Case (i): For an array section or for an array expression other than a\n@@ -1462,7 +1480,9 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n                not have size zero and has value zero if dimension DIM has\n                size zero.  */\n \n-  if (as)\n+  if (!upper && assumed_rank_lb_one)\n+    se->expr = gfc_index_one_node;\n+  else if (as)\n     {\n       tree stride = gfc_conv_descriptor_stride_get (desc, bound);\n \n@@ -1488,9 +1508,19 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \t  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n \t\t\t\t  boolean_type_node, cond, cond5);\n \n+\t  if (assumed_rank_lb_one)\n+\t    {\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t       gfc_array_index_type, ubound, lbound);\n+\t      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t       gfc_array_index_type, tmp, gfc_index_one_node);\n+\t    }\n+          else\n+            tmp = ubound;\n+\n \t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t      gfc_array_index_type, cond,\n-\t\t\t\t      ubound, gfc_index_zero_node);\n+\t\t\t\t      tmp, gfc_index_zero_node);\n \t}\n       else\n \t{"}, {"sha": "75aa11414049299c8a68736418897aa707afeb30", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "patch": "@@ -1,3 +1,12 @@\n+2012-07-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/48820\n+\t* gfortran.dg/assumed_rank_3.f90: New.\n+\t* gfortran.dg/assumed_rank_11.f90: New.\n+\t* gfortran.dg/assumed_rank_1.f90: Update dg-error.\n+\t* gfortran.dg/assumed_rank_2.f90: Update dg-error.\n+\t* gfortran.dg/assumed_rank_7.f90: Update dg-error.\n+\n 2012-07-21  Andrew Pinski  <apinski@cavium.com>\n \n \t* gcc.target/mips/unaligned-1.c: New testcase."}, {"sha": "44e278c37f617235a6c431c1ed22076bdff9e8bb", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_1.f90", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_1.f90?ref=63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "patch": "@@ -5,8 +5,6 @@\n !\n ! Assumed-rank tests\n !\n-! FIXME: The ubound/lbound checks have to be re-enabled when\n-! after they are supported\n \n implicit none\n \n@@ -106,14 +104,14 @@ subroutine foo2(a, rnk, low, high, val)\n     if (size(a) /= product (high - low +1)) call abort()\n \n     if (rnk > 0) then\n-!      if (1 /= lbound(a,1)) call abort()\n-!      if (high(1)-low(1)+1 /= ubound(a,1)) call abort()\n+      if (1 /= lbound(a,1)) call abort()\n+      if (high(1)-low(1)+1 /= ubound(a,1)) call abort()\n       if (size (a,1) /= high(1)-low(1)+1) call abort()\n     end if\n \n     do i = 1, rnk\n-!      if (1 /= lbound(a,i)) call abort()\n-!      if (high(i)-low(i)+1 /= ubound(a,i)) call abort()\n+      if (1 /= lbound(a,i)) call abort()\n+      if (high(i)-low(i)+1 /= ubound(a,i)) call abort()\n       if (size (a,i) /= high(i)-low(i)+1) call abort()\n     end do\n     call check_value (a, rnk, val)\n@@ -131,14 +129,14 @@ subroutine foo3 (a, rnk, low, high, val)\n     if (size(a) /= product (high - low +1)) call abort()\n \n     if (rnk > 0) then\n-!      if (low(1) /= lbound(a,1)) call abort()\n-!      if (high(1) /= ubound(a,1)) call abort()\n+      if (low(1) /= lbound(a,1)) call abort()\n+      if (high(1) /= ubound(a,1)) call abort()\n       if (size (a,1) /= high(1)-low(1)+1) call abort()\n     end if\n \n     do i = 1, rnk\n-!      if (low(i) /= lbound(a,i)) call abort()\n-!      if (high(i) /= ubound(a,i)) call abort()\n+      if (low(i) /= lbound(a,i)) call abort()\n+      if (high(i) /= ubound(a,i)) call abort()\n       if (size (a,i) /= high(i)-low(i)+1) call abort()\n     end do\n     call check_value (a, rnk, val)"}, {"sha": "46dffd0740bc3ca6afbb82b359cf993d405b69e7", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_11.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_11.f90?ref=63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! PR fortran/48820\n+!\n+! Assumed-rank tests\n+subroutine foo(X)\n+ integer :: x(..)\n+ codimension :: x[*] ! { dg-error \"The assumed-rank array 'x' at .1. shall not have a codimension\" }\n+end\n+\n+subroutine foo2(X)\n+ integer, dimension(..) :: x[*] ! { dg-error \"The assumed-rank array at .1. shall not have a codimension\" }\n+end\n+\n+subroutine foo3(X)\n+ integer, codimension[*] :: x(..) ! { dg-error \"The assumed-rank array at .1. shall not have a codimension\" }\n+end\n+\n+subroutine foo4(X)\n+ integer, codimension[*], dimension(..) :: x ! { dg-error \"The assumed-rank array at .1. shall not have a codimension\" }\n+end\n+\n+subroutine bar(X)\n+ integer :: x[*]\n+ dimension :: x(..) ! { dg-error \"The assumed-rank array 'x' at .1. shall not have a codimension\" }\n+end\n+\n+subroutine foobar(X)\n+ integer :: x\n+ codimension :: x[*]\n+ dimension :: x(..) ! { dg-error \"The assumed-rank array 'x' at .1. shall not have a codimension\" }\n+end\n+\n+subroutine barfoo(X)\n+ integer :: x\n+ dimension :: x(..)\n+ codimension :: x[*] ! { dg-error \"The assumed-rank array 'x' at .1. shall not have a codimension\" }\n+end\n+\n+subroutine orig(X) ! { dg-error \"may not have the VALUE or CODIMENSION attribute\" }\n+ integer :: x(..)[*]\n+end\n+\n+subroutine val1(X)\n+ integer, value :: x(..)  ! { dg-error \"VALUE attribute conflicts with DIMENSION attribute\" }\n+end\n+\n+subroutine val2(X)\n+ integer, value :: x\n+ dimension :: x(..)  ! { dg-error \"VALUE attribute conflicts with DIMENSION attribute\" }\n+end"}, {"sha": "344278e163217469542c61cefd29fe7709195851", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_2.f90", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_2.f90?ref=63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "patch": "@@ -6,8 +6,6 @@\n ! Assumed-rank tests - same as assumed_rank_1.f90,\n ! but with bounds checks and w/o call to C function\n !\n-! FIXME: The ubound/lbound checks have to be re-enabled when\n-! after they are supported\n \n implicit none\n \n@@ -73,14 +71,14 @@ subroutine foo(a, rnk, low, high, val)\n     if (size(a) /= product (high - low +1)) call abort()\n \n     if (rnk > 0) then\n-!      if (low(1) /= lbound(a,1)) call abort()\n-!      if (high(1) /= ubound(a,1)) call abort()\n+      if (low(1) /= lbound(a,1)) call abort()\n+      if (high(1) /= ubound(a,1)) call abort()\n       if (size (a,1) /= high(1)-low(1)+1) call abort()\n     end if\n \n     do i = 1, rnk\n-!      if (low(i) /= lbound(a,i)) call abort()\n-!      if (high(i) /= ubound(a,i)) call abort()\n+      if (low(i) /= lbound(a,i)) call abort()\n+      if (high(i) /= ubound(a,i)) call abort()\n       if (size (a,i) /= high(i)-low(i)+1) call abort()\n     end do\n     call foo2(a, rnk, low, high, val)\n@@ -98,14 +96,14 @@ subroutine foo2(a, rnk, low, high, val)\n     if (size(a) /= product (high - low +1)) call abort()\n \n     if (rnk > 0) then\n-!      if (1 /= lbound(a,1)) call abort()\n-!      if (high(1)-low(1)+1 /= ubound(a,1)) call abort()\n+      if (1 /= lbound(a,1)) call abort()\n+      if (high(1)-low(1)+1 /= ubound(a,1)) call abort()\n       if (size (a,1) /= high(1)-low(1)+1) call abort()\n     end if\n \n     do i = 1, rnk\n-!      if (1 /= lbound(a,i)) call abort()\n-!      if (high(i)-low(i)+1 /= ubound(a,i)) call abort()\n+      if (1 /= lbound(a,i)) call abort()\n+      if (high(i)-low(i)+1 /= ubound(a,i)) call abort()\n       if (size (a,i) /= high(i)-low(i)+1) call abort()\n     end do\n   end subroutine foo2\n@@ -122,14 +120,14 @@ subroutine foo3 (a, rnk, low, high, val)\n     if (size(a) /= product (high - low +1)) call abort()\n \n     if (rnk > 0) then\n-!      if (low(1) /= lbound(a,1)) call abort()\n-!      if (high(1) /= ubound(a,1)) call abort()\n+      if (low(1) /= lbound(a,1)) call abort()\n+      if (high(1) /= ubound(a,1)) call abort()\n       if (size (a,1) /= high(1)-low(1)+1) call abort()\n     end if\n \n     do i = 1, rnk\n-!      if (low(i) /= lbound(a,i)) call abort()\n-!      if (high(i) /= ubound(a,i)) call abort()\n+      if (low(i) /= lbound(a,i)) call abort()\n+      if (high(i) /= ubound(a,i)) call abort()\n       if (size (a,i) /= high(i)-low(i)+1) call abort()\n     end do\n     call foo(a, rnk, low, high, val)"}, {"sha": "ab5c0d90b397e38bbd81b1329b94b64b57238e6d", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_3.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_3.f90?ref=63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=bounds\" }\n+! { dg-shouldfail \"Array reference out of bounds\" }\n+!\n+! PR fortran/48820\n+!\n+! Do assumed-rank bound checking\n+\n+implicit none\n+integer :: a(4,4)\n+call bar(a)\n+contains\n+  subroutine bar(x)\n+    integer :: x(..)\n+    print *, ubound(x,dim=3)  ! << wrong dim\n+  end subroutine\n+end\n+\n+! { dg-output \"Fortran runtime error: Array reference out of bounds\" }"}, {"sha": "86da3f853c3a05df6cc6988e518a06c987e08b62", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_6.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_6.f90?ref=63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "patch": "@@ -30,8 +30,8 @@ subroutine valid3(y)\n   end subroutine\n end subroutine\n \n-subroutine foo4(x) ! { dg-error \"may not have the VALUE or CODIMENSION attribute\" }\n-  integer, codimension[*] :: x(..)\n+subroutine foo4(x)\n+  integer, codimension[*] :: x(..) ! { dg-error \"The assumed-rank array at .1. shall not have a codimension\" }\n end subroutine\n \n subroutine foo5(y) ! { dg-error \"may not have the VALUE or CODIMENSION attribute\" }"}, {"sha": "f9ff3b9aa424531d9cf6a4526fba72e751d38ff1", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_7.f90", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63fbf5865a5fc48a25ff4410e7c2757bb24c36c8/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_7.f90?ref=63fbf5865a5fc48a25ff4410e7c2757bb24c36c8", "patch": "@@ -4,8 +4,6 @@\n !\n ! Handle type/class for assumed-rank arrays\n !\n-! FIXME: The ubound/lbound checks have to be re-enabled when\n-! after they are supported.\n ! FIXME: Passing a CLASS to a CLASS has to be re-enabled.\n implicit none\n type t\n@@ -29,38 +27,38 @@\n contains\n   subroutine bar(x)\n     type(t) :: x(..)\n-!    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n+    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n     if (size(x) /= 6) call abort()\n     if (size(x,1) /= 2 .or. size(x,2) /= 3) call abort()\n-!    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n+    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n     i = i + 1\n     call foo(x)\n     call bar2(x)\n   end subroutine\n   subroutine bar2(x)\n     type(t) :: x(..)\n-!    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n+    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n     if (size(x) /= 6) call abort()\n     if (size(x,1) /= 2 .or. size(x,2) /= 3) call abort()\n-!    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n+    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n     i = i + 1\n   end subroutine\n   subroutine foo(x)\n     class(t) :: x(..)\n-!    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n+    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n     if (size(x) /= 6) call abort()\n     if (size(x,1) /= 2 .or. size(x,2) /= 3) call abort()\n-!    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n+    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n     i = i + 1\n     call foo2(x)\n !    call bar2(x) ! Passing a CLASS to a TYPE does not yet work\n   end subroutine\n   subroutine foo2(x)\n     class(t) :: x(..)\n-!    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n+    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n     if (size(x) /= 6) call abort()\n     if (size(x,1) /= 2 .or. size(x,2) /= 3) call abort()\n-!    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n+    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n     i = i + 1\n   end subroutine\n end "}]}