{"sha": "6ff66d1ea48960fe96bb51a750c01135e65fe452", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZmNjZkMWVhNDg5NjBmZTk2YmI1MWE3NTBjMDExMzVlNjVmZTQ1Mg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-07T12:53:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-26T11:58:25Z"}, "message": "tree-optimization/99956 - improve loop interchange\n\nWhen we apply store motion and DSE manually to the bwaves kernel\nin gfortran.dg/pr81303.f loop interchange no longer happens because\nthe perfect nest considered covers outer loops we cannot analyze\nstrides for.  The following compensates for this by shrinking the\nnest in this analysis which was already possible but on a too coarse\ngranularity.  It shares the shrinked nest with the rest of the DRs\nso the complexity overhead should be negligible.\n\n2021-04-07  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/99956\n\t* gimple-loop-interchange.cc (compute_access_stride):\n\tTry instantiating the access in a shallower loop nest\n\tif instantiating failed.\n\t(compute_access_strides): Pass adjustable loop_nest\n\tto compute_access_stride.\n\n\t* gfortran.dg/pr99956.f: New testcase.", "tree": {"sha": "52ce17cfd5c33f0958a342ac2018ffb53b286755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52ce17cfd5c33f0958a342ac2018ffb53b286755"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ff66d1ea48960fe96bb51a750c01135e65fe452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff66d1ea48960fe96bb51a750c01135e65fe452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff66d1ea48960fe96bb51a750c01135e65fe452", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff66d1ea48960fe96bb51a750c01135e65fe452/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a38b1a59f8eb6f41a885f8a7c8838378be717b02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38b1a59f8eb6f41a885f8a7c8838378be717b02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a38b1a59f8eb6f41a885f8a7c8838378be717b02"}], "stats": {"total": 113, "additions": 85, "deletions": 28}, "files": [{"sha": "80f749b60719a54c61e9287f66d5644552e08f84", "filename": "gcc/gimple-loop-interchange.cc", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff66d1ea48960fe96bb51a750c01135e65fe452/gcc%2Fgimple-loop-interchange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff66d1ea48960fe96bb51a750c01135e65fe452/gcc%2Fgimple-loop-interchange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-interchange.cc?ref=6ff66d1ea48960fe96bb51a750c01135e65fe452", "patch": "@@ -1280,12 +1280,15 @@ tree_loop_interchange::move_code_to_inner_loop (class loop *outer,\n \t   arr[i][j - 1][k] = 0;  */\n \n static void\n-compute_access_stride (class loop *loop_nest, class loop *loop,\n+compute_access_stride (class loop *&loop_nest, class loop *loop,\n \t\t       data_reference_p dr)\n {\n   vec<tree> *strides = new vec<tree> ();\n-  basic_block bb = gimple_bb (DR_STMT (dr));\n+  dr->aux = strides;\n \n+  basic_block bb = gimple_bb (DR_STMT (dr));\n+  if (!flow_bb_inside_loop_p (loop_nest, bb))\n+    return;\n   while (!flow_bb_inside_loop_p (loop, bb))\n     {\n       strides->safe_push (build_int_cst (sizetype, 0));\n@@ -1313,39 +1316,47 @@ compute_access_stride (class loop *loop_nest, class loop *loop,\n \t}\n       /* Otherwise punt.  */\n       else\n-\t{\n-\t  dr->aux = strides;\n-\t  return;\n-\t}\n+\treturn;\n     }\n   tree scev_base = build_fold_addr_expr (ref);\n   tree scev = analyze_scalar_evolution (loop, scev_base);\n-  scev = instantiate_scev (loop_preheader_edge (loop_nest), loop, scev);\n-  if (! chrec_contains_undetermined (scev))\n+  if (chrec_contains_undetermined (scev))\n+    return;\n+\n+  tree orig_scev = scev;\n+  do\n+    {\n+      scev = instantiate_scev (loop_preheader_edge (loop_nest),\n+\t\t\t       loop, orig_scev);\n+      if (! chrec_contains_undetermined (scev))\n+\tbreak;\n+\n+      /* If we couldn't instantiate for the desired nest, shrink it.  */\n+      if (loop_nest == loop)\n+\treturn;\n+      loop_nest = loop_nest->inner;\n+    } while (1);\n+\n+  tree sl = scev;\n+  class loop *expected = loop;\n+  while (TREE_CODE (sl) == POLYNOMIAL_CHREC)\n     {\n-      tree sl = scev;\n-      class loop *expected = loop;\n-      while (TREE_CODE (sl) == POLYNOMIAL_CHREC)\n+      class loop *sl_loop = get_chrec_loop (sl);\n+      while (sl_loop != expected)\n \t{\n-\t  class loop *sl_loop = get_chrec_loop (sl);\n-\t  while (sl_loop != expected)\n-\t    {\n-\t      strides->safe_push (size_int (0));\n-\t      expected = loop_outer (expected);\n-\t    }\n-\t  strides->safe_push (CHREC_RIGHT (sl));\n-\t  sl = CHREC_LEFT (sl);\n+\t  strides->safe_push (size_int (0));\n \t  expected = loop_outer (expected);\n \t}\n-      if (! tree_contains_chrecs (sl, NULL))\n-\twhile (expected != loop_outer (loop_nest))\n-\t  {\n-\t    strides->safe_push (size_int (0));\n-\t    expected = loop_outer (expected);\n-\t  }\n+      strides->safe_push (CHREC_RIGHT (sl));\n+      sl = CHREC_LEFT (sl);\n+      expected = loop_outer (expected);\n     }\n-\n-  dr->aux = strides;\n+  if (! tree_contains_chrecs (sl, NULL))\n+    while (expected != loop_outer (loop_nest))\n+      {\n+\tstrides->safe_push (size_int (0));\n+\texpected = loop_outer (expected);\n+      }\n }\n \n /* Given loop nest LOOP_NEST with innermost LOOP, the function computes\n@@ -1363,9 +1374,10 @@ compute_access_strides (class loop *loop_nest, class loop *loop,\n   data_reference_p dr;\n   vec<tree> *stride;\n \n+  class loop *interesting_loop_nest = loop_nest;\n   for (i = 0; datarefs.iterate (i, &dr); ++i)\n     {\n-      compute_access_stride (loop_nest, loop, dr);\n+      compute_access_stride (interesting_loop_nest, loop, dr);\n       stride = DR_ACCESS_STRIDE (dr);\n       if (stride->length () < num_loops)\n \t{"}, {"sha": "b5c0be3912d58cc692ed833582a7319e6e1918a2", "filename": "gcc/testsuite/gfortran.dg/pr99956.f", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff66d1ea48960fe96bb51a750c01135e65fe452/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99956.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff66d1ea48960fe96bb51a750c01135e65fe452/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99956.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr99956.f?ref=6ff66d1ea48960fe96bb51a750c01135e65fe452", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -ffast-math -floop-interchange -fdump-tree-linterchange-details\" }\n+\n+        subroutine mat_times_vec(y,x,a,axp,ayp,azp,axm,aym,azm,\n+     $  nb,nx,ny,nz)\n+        implicit none\n+        integer nb,nx,ny,nz,i,j,k,m,l,kit,im1,ip1,jm1,jp1,km1,kp1\n+\n+        real*8 y(nb,nx,ny,nz),x(nb,nx,ny,nz),tem\n+\n+        real*8 a(nb,nb,nx,ny,nz),\n+     1  axp(nb,nb,nx,ny,nz),ayp(nb,nb,nx,ny,nz),azp(nb,nb,nx,ny,nz),\n+     2  axm(nb,nb,nx,ny,nz),aym(nb,nb,nx,ny,nz),azm(nb,nb,nx,ny,nz)\n+\n+\n+      do k=1,nz\n+         km1=mod(k+nz-2,nz)+1\n+         kp1=mod(k,nz)+1\n+         do j=1,ny\n+            jm1=mod(j+ny-2,ny)+1\n+            jp1=mod(j,ny)+1\n+            do i=1,nx\n+               im1=mod(i+nx-2,nx)+1\n+               ip1=mod(i,nx)+1\n+               do l=1,nb\n+                  tem=0.0\n+                  do m=1,nb\n+                     tem=tem+\n+     1               a(l,m,i,j,k)*x(m,i,j,k)+\n+     2               axp(l,m,i,j,k)*x(m,ip1,j,k)+\n+     3               ayp(l,m,i,j,k)*x(m,i,jp1,k)+\n+     4               azp(l,m,i,j,k)*x(m,i,j,kp1)+\n+     5               axm(l,m,i,j,k)*x(m,im1,j,k)+\n+     6               aym(l,m,i,j,k)*x(m,i,jm1,k)+\n+     7               azm(l,m,i,j,k)*x(m,i,j,km1)\n+                  enddo\n+                  y(l,i,j,k)=tem\n+               enddo\n+            enddo\n+         enddo\n+        enddo          \n+        return\n+        end\n+\n+! { dg-final { scan-tree-dump-times \"is interchanged\" 1 \"linterchange\" } }"}]}