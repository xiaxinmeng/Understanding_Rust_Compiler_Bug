{"sha": "3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY3M2RjZjZkNmJhZWI2N2JiNzBmZjAzZDRjYjNmOTJiZWVkMDA3NQ==", "commit": {"author": {"name": "Jiufu Guo", "email": "guojiufu@linux.ibm.com", "date": "2021-07-07T05:41:01Z"}, "committer": {"name": "Jiufu Guo", "email": "guojiufu@linux.ibm.com", "date": "2021-08-25T08:38:12Z"}, "message": "Analyze niter for until-wrap condition [PR101145]\n\nFor code like:\nunsigned foo(unsigned val, unsigned start)\n{\n  unsigned cnt = 0;\n  for (unsigned i = start; i > val; ++i)\n    cnt++;\n  return cnt;\n}\n\nThe number of iterations should be about UINT_MAX - start.\n\nThere is function adjust_cond_for_loop_until_wrap which\nhandles similar work for const bases.\nLike adjust_cond_for_loop_until_wrap, this patch enhance\nfunction number_of_iterations_cond/number_of_iterations_lt\nto analyze number of iterations for this kind of loop.\n\ngcc/ChangeLog:\n\n2021-08-25  Jiufu Guo  <guojiufu@linux.ibm.com>\n\n\tPR tree-optimization/101145\n\t* tree-ssa-loop-niter.c (number_of_iterations_until_wrap):\n\tNew function.\n\t(number_of_iterations_lt): Invoke above function.\n\t(adjust_cond_for_loop_until_wrap):\n\tMerge to number_of_iterations_until_wrap.\n\t(number_of_iterations_cond): Update invokes for\n\tadjust_cond_for_loop_until_wrap and number_of_iterations_lt.\n\ngcc/testsuite/ChangeLog:\n\n2021-08-25  Jiufu Guo  <guojiufu@linux.ibm.com>\n\n\tPR tree-optimization/101145\n\t* gcc.dg/vect/pr101145.c: New test.\n\t* gcc.dg/vect/pr101145.inc: New test.\n\t* gcc.dg/vect/pr101145_1.c: New test.\n\t* gcc.dg/vect/pr101145_2.c: New test.\n\t* gcc.dg/vect/pr101145_3.c: New test.\n\t* gcc.dg/vect/pr101145inf.c: New test.\n\t* gcc.dg/vect/pr101145inf.inc: New test.\n\t* gcc.dg/vect/pr101145inf_1.c: New test.", "tree": {"sha": "157286b07183d186b343dac748c54407a9e6c908", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/157286b07183d186b343dac748c54407a9e6c908"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/comments", "author": null, "committer": null, "parents": [{"sha": "db3d4129b6f4cff685713da514b64ff7bbc401fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3d4129b6f4cff685713da514b64ff7bbc401fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db3d4129b6f4cff685713da514b64ff7bbc401fc"}], "stats": {"total": 524, "additions": 459, "deletions": 65}, "files": [{"sha": "74031b031cf25ad132dc6a50a3adcd8a10705ef9", "filename": "gcc/testsuite/gcc.dg/vect/pr101145.c", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145.c?ref=3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "patch": "@@ -0,0 +1,187 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-options \"-O3 -fdump-tree-vect-details\" } */\n+#include <limits.h>\n+\n+unsigned __attribute__ ((noinline))\n+foo (int *__restrict__ a, int *__restrict__ b, unsigned l, unsigned n)\n+{\n+  while (n < ++l)\n+    *a++ = *b++ + 1;\n+  return l;\n+}\n+\n+unsigned __attribute__ ((noinline))\n+foo_1 (int *__restrict__ a, int *__restrict__ b, unsigned l, unsigned)\n+{\n+  while (UINT_MAX - 64 < ++l)\n+    *a++ = *b++ + 1;\n+  return l;\n+}\n+\n+unsigned __attribute__ ((noinline))\n+foo_2 (int *__restrict__ a, int *__restrict__ b, unsigned l, unsigned n)\n+{\n+  l = UINT_MAX - 32;\n+  while (n < ++l)\n+    *a++ = *b++ + 1;\n+  return l;\n+}\n+\n+unsigned __attribute__ ((noinline))\n+foo_3 (int *__restrict__ a, int *__restrict__ b, unsigned l, unsigned n)\n+{\n+  while (n <= ++l)\n+    *a++ = *b++ + 1;\n+  return l;\n+}\n+\n+unsigned __attribute__ ((noinline))\n+foo_4 (int *__restrict__ a, int *__restrict__ b, unsigned l, unsigned n)\n+{  // infininate \n+  while (0 <= ++l)\n+    *a++ = *b++ + 1;\n+  return l;\n+}\n+\n+unsigned __attribute__ ((noinline))\n+foo_5 (int *__restrict__ a, int *__restrict__ b, unsigned l, unsigned n)\n+{\n+  //no loop\n+  l = UINT_MAX;\n+  while (n < ++l)\n+    *a++ = *b++ + 1;\n+  return l;\n+}\n+\n+unsigned __attribute__ ((noinline))\n+bar (int *__restrict__ a, int *__restrict__ b, unsigned l, unsigned n)\n+{\n+  while (--l < n)\n+    *a++ = *b++ + 1;\n+  return l;\n+}\n+\n+unsigned __attribute__ ((noinline))\n+bar_1 (int *__restrict__ a, int *__restrict__ b, unsigned l, unsigned)\n+{\n+  while (--l < 64)\n+    *a++ = *b++ + 1;\n+  return l;\n+}\n+\n+unsigned __attribute__ ((noinline))\n+bar_2 (int *__restrict__ a, int *__restrict__ b, unsigned l, unsigned n)\n+{\n+  l = 32;\n+  while (--l < n)\n+    *a++ = *b++ + 1;\n+  return l;\n+}\n+\n+\n+int a[3200], b[3200];\n+int fail;\n+\n+int\n+main ()\n+{\n+  unsigned l, n;\n+  unsigned res;\n+  /* l > n*/\n+  n = UINT_MAX - 64;\n+  l = n + 32;\n+  res = foo (a, b, l, n);\n+  if (res != 0)\n+    fail++;\n+\n+  l = n;\n+  res = foo (a, b, l, n);\n+  if (res != 0)\n+    fail++;\n+\n+  l = n - 1;\n+  res = foo (a, b, l, n);\n+  if (res != l + 1)\n+    fail++;\n+  \n+  l = n - 32;\n+  res = foo (a, b, l, n);\n+  if (res != l + 1)\n+    fail++;\n+\n+  l = UINT_MAX;\n+  res = foo (a, b, l, n);\n+  if (res != 0)\n+    fail++;\n+\n+  l = n + 32;\n+  res = foo_1 (a, b, l, n);\n+  if (res != 0)\n+    fail++;\n+\n+  l = n + 32;\n+  res = foo_2 (a, b, l, n);\n+  if (res != 0)\n+    fail++;\n+\n+  l = n;\n+  res = foo_3 (a, b, l, n);\n+  if (res != 0)\n+    fail++;\n+\n+  l = n - 1;\n+  res = foo_3 (a, b, l, n);\n+  if (res != 0)\n+    fail++;\n+\n+  l = n - 2;\n+  res = foo_3 (a, b, l, n);\n+  if (res != l + 1)\n+    fail++;\n+\n+  res = foo_5 (a, b, l, n);\n+  if (res != 0)\n+    fail++;\n+\n+  n = 64;\n+  l = n - 32;\n+  res = bar (a, b, l, n);\n+  res++;\n+  if (res != 0)\n+    fail++;\n+\n+  l = n;\n+  res = bar (a, b, l, n);\n+  res++;\n+  if (res != 0)\n+    fail++;\n+\n+  l = n + 1;\n+  res = bar (a, b, l, n);\n+  res++;\n+  if (res != l)\n+    fail++;\n+\n+  l = 0;\n+  res = bar (a, b, l, n);\n+  res++;\n+  if (res != l)\n+    fail++;\n+\n+  l = 32;\n+  res = bar_1 (a, b, l, n);\n+  res++;\n+  if (res != 0)\n+    fail++;  \n+\n+  res = bar_1 (a, b, l, n);\n+  res++;\n+  if (res != 0)\n+    fail++;  \n+\n+  if (fail)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 7 \"vect\" } } */"}, {"sha": "615d2e5e55276b891dc3248e87fb7fb754f75b2b", "filename": "gcc/testsuite/gcc.dg/vect/pr101145.inc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145.inc?ref=3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "patch": "@@ -0,0 +1,65 @@\n+TYPE __attribute__ ((noinline))\n+foo_sign (int *__restrict__ a, int *__restrict__ b, TYPE l, TYPE n)\n+{\n+  TYPE i;\n+  for (i = l; n < i; i += C)\n+    *a++ = *b++ + 1;\n+  return i;\n+}\n+\n+TYPE __attribute__ ((noinline))\n+bar_sign (int *__restrict__ a, int *__restrict__ b, TYPE l, TYPE n)\n+{\n+  TYPE i;\n+  for (i = l; i < n; i -= C)\n+    *a++ = *b++ + 1;\n+  return i;\n+}\n+\n+int __attribute__ ((noinline)) neq (int a, int b) { return a != b; }\n+\n+int a[1000], b[1000];\n+int fail;\n+\n+int\n+main ()\n+{\n+  TYPE res;\n+  TYPE l;\n+  TYPE n;\n+  n = N_BASE;\n+  l = n - C;\n+  res = foo_sign (a, b, l, n);\n+  if (res != l)\n+    fail++;\n+\n+  l = n;\n+  res = foo_sign (a, b, l, n);\n+  if (res != l)\n+    fail++;\n+\n+  l = n + C;\n+  res = foo_sign (a, b, l, n);\n+  if (neq ((res - MIN) / C, 0))\n+    fail++;\n+\n+  n = N_BASE_DOWN;\n+  l = n - C;\n+  res = bar_sign (a, b, l, n);\n+  if (neq ((MAX - res) / C, 0))\n+    fail++;\n+\n+  l = n;\n+  res = bar_sign (a, b, l, n);\n+  if (res != l)\n+    fail++;\n+\n+  l = n + C;\n+  res = bar_sign (a, b, l, n);\n+  if (res != l)\n+    fail++;\n+\n+  if (fail)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "8bc26e2436e84783d2c76379a84176624bf83e28", "filename": "gcc/testsuite/gcc.dg/vect/pr101145_1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145_1.c?ref=3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-options \"-O3 -fdump-tree-vect-details\" } */\n+#define TYPE signed char\n+#define MIN -128\n+#define MAX 127\n+#define N_BASE (MAX - 32)\n+#define N_BASE_DOWN (MIN + 32)\n+\n+#define C 3\n+\n+#include \"pr101145.inc\"\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */"}, {"sha": "b14c4b4b5196a2c85ab5c2f53a585ba5d9c55e24", "filename": "gcc/testsuite/gcc.dg/vect/pr101145_2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145_2.c?ref=3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-options \"-O3 -fdump-tree-vect-details\" } */\n+#define TYPE unsigned char\n+#define MIN 0\n+#define MAX 255\n+#define N_BASE (MAX - 32 + 1)\n+#define N_BASE_DOWN (MIN + 32)\n+\n+#define C 2\n+\n+#include \"pr101145.inc\"\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */"}, {"sha": "99289afec0b110b25f54723c8765d395275aeece", "filename": "gcc/testsuite/gcc.dg/vect/pr101145_3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145_3.c?ref=3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-options \"-O3 -fdump-tree-vect-details\" } */\n+#define TYPE int *\n+#define MIN ((TYPE)0)\n+#define MAX ((TYPE)((long long)-1))\n+#define N_BASE (MIN - 32)\n+#define N_BASE_DOWN (MIN + 32)\n+\n+#define C 1\n+\n+#include \"pr101145.inc\"\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */"}, {"sha": "ed49f5670b5b2634101aaaa895cee27c8451bbae", "filename": "gcc/testsuite/gcc.dg/vect/pr101145inf.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145inf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145inf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145inf.c?ref=3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run { target *-*-linux* *-*-gnu* *-*-uclinux* } } */\n+/* { dg-options \"-O3\" } */\n+#include <limits.h>\n+#include \"pr101145inf.inc\"\n+\n+__attribute__ ((noinline))\n+unsigned foo(unsigned val, unsigned start)\n+{\n+  unsigned cnt = 0;\n+  for (unsigned i = start; val <= i; i+=16)\n+    cnt++;\n+  return cnt;\n+}\n+\n+void test_finite ()\n+{\n+  unsigned n = foo (16, UINT_MAX - 32);\n+  if (n != 3)\n+    __builtin_abort ();\n+}\n+\n+void test_infinite ()\n+{\n+ foo (15, UINT_MAX - 32);\n+}"}, {"sha": "4aa3d0491878ff0a96e7e08d695b9a294c6e01ea", "filename": "gcc/testsuite/gcc.dg/vect/pr101145inf.inc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145inf.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145inf.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145inf.inc?ref=3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "patch": "@@ -0,0 +1,28 @@\n+#include <unistd.h>\n+#include <signal.h>\n+#include <stdlib.h>\n+\n+void test_finite ();\n+void test_infinite ();\n+\n+void do_exit (int i)\n+{\n+  exit (0);\n+}\n+\n+int main(void)\n+{\n+  test_finite ();\n+  struct sigaction s;\n+  sigemptyset (&s.sa_mask);\n+  s.sa_handler = do_exit;\n+  s.sa_flags = 0;\n+  sigaction (SIGALRM, &s, NULL);\n+  alarm (1);\n+\n+  test_infinite ();\n+\n+  __builtin_abort ();\n+  return 1;\n+}\n+"}, {"sha": "4ee3e31c7fe96fd56dba8024fe295e823424c2fa", "filename": "gcc/testsuite/gcc.dg/vect/pr101145inf_1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145inf_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145inf_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr101145inf_1.c?ref=3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run { target *-*-linux* *-*-gnu* *-*-uclinux* } } */\n+/* { dg-options \"-O3\" } */\n+#include <limits.h>\n+#include \"pr101145inf.inc\"\n+\n+__attribute__ ((noinline))\n+unsigned foo(unsigned val, unsigned start)\n+{\n+  unsigned cnt = 0;\n+  for (unsigned i = start; i < val; i-=16)\n+    cnt++;\n+  return cnt;\n+}\n+\n+void test_finite ()\n+{\n+  foo (UINT_MAX - 15, 32);\n+}\n+\n+void test_infinite ()\n+{\n+  foo (UINT_MAX - 14, 32);\n+}"}, {"sha": "7af92d1c893321a7acd44aecf744b462aed17dc3", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 92, "deletions": 65, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3673dcf6d6baeb67bb70ff03d4cb3f92beed0075/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=3673dcf6d6baeb67bb70ff03d4cb3f92beed0075", "patch": "@@ -1473,6 +1473,93 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n     }\n }\n \n+/* Determines number of iterations of loop whose ending condition\n+   is IV0 < IV1 which likes:  {base, -C} < n,  or n < {base, C}.\n+   The number of iterations is stored to NITER.  */\n+\n+static bool\n+number_of_iterations_until_wrap (class loop *, tree type, affine_iv *iv0,\n+\t\t\t\t affine_iv *iv1, class tree_niter_desc *niter)\n+{\n+  tree niter_type = unsigned_type_for (type);\n+  tree step, num, assumptions, may_be_zero;\n+  wide_int high, low, max, min;\n+\n+  may_be_zero = fold_build2 (LE_EXPR, boolean_type_node, iv1->base, iv0->base);\n+  if (integer_onep (may_be_zero))\n+    return false;\n+\n+  int prec = TYPE_PRECISION (type);\n+  signop sgn = TYPE_SIGN (type);\n+  min = wi::min_value (prec, sgn);\n+  max = wi::max_value (prec, sgn);\n+\n+  /* n < {base, C}. */\n+  if (integer_zerop (iv0->step) && !tree_int_cst_sign_bit (iv1->step))\n+    {\n+      step = iv1->step;\n+      /* MIN + C - 1 <= n.  */\n+      tree last = wide_int_to_tree (type, min + wi::to_wide (step) - 1);\n+      assumptions = fold_build2 (LE_EXPR, boolean_type_node, last, iv0->base);\n+      if (integer_zerop (assumptions))\n+\treturn false;\n+\n+      num = fold_build2 (MINUS_EXPR, niter_type, wide_int_to_tree (type, max),\n+\t\t\t iv1->base);\n+      high = max;\n+      if (TREE_CODE (iv1->base) == INTEGER_CST)\n+\tlow = wi::to_wide (iv1->base) - 1;\n+      else if (TREE_CODE (iv0->base) == INTEGER_CST)\n+\tlow = wi::to_wide (iv0->base);\n+      else\n+\tlow = min;\n+    }\n+  /* {base, -C} < n.  */\n+  else if (tree_int_cst_sign_bit (iv0->step) && integer_zerop (iv1->step))\n+    {\n+      step = fold_build1 (NEGATE_EXPR, TREE_TYPE (iv0->step), iv0->step);\n+      /* MAX - C + 1 >= n.  */\n+      tree last = wide_int_to_tree (type, max - wi::to_wide (step) + 1);\n+      assumptions = fold_build2 (GE_EXPR, boolean_type_node, last, iv1->base);\n+      if (integer_zerop (assumptions))\n+\treturn false;\n+\n+      num = fold_build2 (MINUS_EXPR, niter_type, iv0->base,\n+\t\t\t wide_int_to_tree (type, min));\n+      low = min;\n+      if (TREE_CODE (iv0->base) == INTEGER_CST)\n+\thigh = wi::to_wide (iv0->base) + 1;\n+      else if (TREE_CODE (iv1->base) == INTEGER_CST)\n+\thigh = wi::to_wide (iv1->base);\n+      else\n+\thigh = max;\n+    }\n+  else\n+    return false;\n+\n+  /* (delta + step - 1) / step */\n+  step = fold_convert (niter_type, step);\n+  num = fold_convert (niter_type, num);\n+  num = fold_build2 (PLUS_EXPR, niter_type, num, step);\n+  niter->niter = fold_build2 (FLOOR_DIV_EXPR, niter_type, num, step);\n+\n+  widest_int delta, s;\n+  delta = widest_int::from (high, sgn) - widest_int::from (low, sgn);\n+  s = wi::to_widest (step);\n+  delta = delta + s - 1;\n+  niter->max = wi::udiv_floor (delta, s);\n+\n+  niter->may_be_zero = may_be_zero;\n+\n+  if (!integer_nonzerop (assumptions))\n+    niter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t      niter->assumptions, assumptions);\n+\n+  niter->control.no_overflow = false;\n+\n+  return true;\n+}\n+\n /* Determines number of iterations of loop whose ending condition\n    is IV0 < IV1.  TYPE is the type of the iv.  The number of\n    iterations is stored to NITER.  BNDS bounds the difference\n@@ -1501,6 +1588,11 @@ number_of_iterations_lt (class loop *loop, tree type, affine_iv *iv0,\n       niter->bound = iv0->base;\n     }\n \n+  /* {base, -C} < n,  or n < {base, C} */\n+  if (tree_int_cst_sign_bit (iv0->step)\n+      || (!integer_zerop (iv1->step) && !tree_int_cst_sign_bit (iv1->step)))\n+    return number_of_iterations_until_wrap (loop, type, iv0, iv1, niter);\n+\n   delta = fold_build2 (MINUS_EXPR, niter_type,\n \t\t       fold_convert (niter_type, iv1->base),\n \t\t       fold_convert (niter_type, iv0->base));\n@@ -1665,62 +1757,6 @@ dump_affine_iv (FILE *file, affine_iv *iv)\n     }\n }\n \n-/* Given exit condition IV0 CODE IV1 in TYPE, this function adjusts\n-   the condition for loop-until-wrap cases.  For example:\n-     (unsigned){8, -1}_loop < 10        => {0, 1} != 9\n-     10 < (unsigned){0, max - 7}_loop   => {0, 1} != 8\n-   Return true if condition is successfully adjusted.  */\n-\n-static bool\n-adjust_cond_for_loop_until_wrap (tree type, affine_iv *iv0, tree_code *code,\n-\t\t\t\t affine_iv *iv1)\n-{\n-  /* Only support simple cases for the moment.  */\n-  if (TREE_CODE (iv0->base) != INTEGER_CST\n-      || TREE_CODE (iv1->base) != INTEGER_CST)\n-    return false;\n-\n-  tree niter_type = unsigned_type_for (type), high, low;\n-  /* Case: i-- < 10.  */\n-  if (integer_zerop (iv1->step))\n-    {\n-      /* TODO: Should handle case in which abs(step) != 1.  */\n-      if (!integer_minus_onep (iv0->step))\n-\treturn false;\n-      /* Give up on infinite loop.  */\n-      if (*code == LE_EXPR\n-\t  && tree_int_cst_equal (iv1->base, TYPE_MAX_VALUE (type)))\n-\treturn false;\n-      high = fold_build2 (PLUS_EXPR, niter_type,\n-\t\t\t  fold_convert (niter_type, iv0->base),\n-\t\t\t  build_int_cst (niter_type, 1));\n-      low = fold_convert (niter_type, TYPE_MIN_VALUE (type));\n-    }\n-  else if (integer_zerop (iv0->step))\n-    {\n-      /* TODO: Should handle case in which abs(step) != 1.  */\n-      if (!integer_onep (iv1->step))\n-\treturn false;\n-      /* Give up on infinite loop.  */\n-      if (*code == LE_EXPR\n-\t  && tree_int_cst_equal (iv0->base, TYPE_MIN_VALUE (type)))\n-\treturn false;\n-      high = fold_convert (niter_type, TYPE_MAX_VALUE (type));\n-      low = fold_build2 (MINUS_EXPR, niter_type,\n-\t\t\t fold_convert (niter_type, iv1->base),\n-\t\t\t build_int_cst (niter_type, 1));\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  iv0->base = low;\n-  iv0->step = fold_convert (niter_type, integer_one_node);\n-  iv1->base = high;\n-  iv1->step = build_int_cst (niter_type, 0);\n-  *code = NE_EXPR;\n-  return true;\n-}\n-\n /* Determine the number of iterations according to condition (for staying\n    inside loop) which compares two induction variables using comparison\n    operator CODE.  The induction variable on left side of the comparison\n@@ -1855,15 +1891,6 @@ number_of_iterations_cond (class loop *loop,\n       return true;\n     }\n \n-  /* Handle special case loops: while (i-- < 10) and while (10 < i++) by\n-     adjusting iv0, iv1 and code.  */\n-  if (code != NE_EXPR\n-      && (tree_int_cst_sign_bit (iv0->step)\n-\t  || (!integer_zerop (iv1->step)\n-\t      && !tree_int_cst_sign_bit (iv1->step)))\n-      && !adjust_cond_for_loop_until_wrap (type, iv0, &code, iv1))\n-    return false;\n-\n   /* OK, now we know we have a senseful loop.  Handle several cases, depending\n      on what comparison operator is used.  */\n   bound_difference (loop, iv1->base, iv0->base, &bnds);"}]}