{"sha": "bc51e7261200de6aa426185513de950e278ab51f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM1MWU3MjYxMjAwZGU2YWE0MjYxODU1MTNkZTk1MGUyNzhhYjUxZg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-02-14T08:28:50Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-02-14T08:28:50Z"}, "message": "re PR fortran/32382 (missed optimization in internal read)\n\n2010-02-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/32382\n\t* trans-stmt.h: Add prototype for gfc_trans_code_cond. Add tree cond to\n\tgfc_trans_do prototype.\n\t* trans-stmt.c (gfc_trans_simple_do): Add optional argument to pass in\n\ta loop exit condition.  If exit condition is given, build the loop exit\n\tcode, checking IO results of implied do loops in READ and WRITE.\n\t(gfc_trans_do): Likewise.\n\t* trans.c (trans_code): New static work function, previously\n\tgfc_trans_code. Passes exit condition to gfc_trans_do.\n\t(gfc_trans_code): Calls trans_code with NULL_TREE condition.\n\t(gfc_trans_code_cond): Calls trans_code with loop exit condition.\n\t* trans-io.c (build_dt): Build an exit condition to allow checking IO\n\tresult status bits in the dtparm structure. Use this condition in call\n\tto gfc_trans_code_cond.\n\nFrom-SVN: r156755", "tree": {"sha": "6a9abd645ffe346f04c5f9e2b9e35c9d59448034", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a9abd645ffe346f04c5f9e2b9e35c9d59448034"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc51e7261200de6aa426185513de950e278ab51f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc51e7261200de6aa426185513de950e278ab51f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc51e7261200de6aa426185513de950e278ab51f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc51e7261200de6aa426185513de950e278ab51f/comments", "author": null, "committer": null, "parents": [{"sha": "89fdbef28dab9e7c56781b17cd50d6894d6f425e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89fdbef28dab9e7c56781b17cd50d6894d6f425e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89fdbef28dab9e7c56781b17cd50d6894d6f425e"}], "stats": {"total": 97, "additions": 86, "deletions": 11}, "files": [{"sha": "b498dc4ad7be4ac3d74e93cf25dfb8c3fda02e21", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc51e7261200de6aa426185513de950e278ab51f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc51e7261200de6aa426185513de950e278ab51f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bc51e7261200de6aa426185513de950e278ab51f", "patch": "@@ -1,3 +1,20 @@\n+2010-02-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/32382\n+\t* trans-stmt.h: Add prototype for gfc_trans_code_cond. Add tree cond to\n+\tgfc_trans_do prototype.\n+\t* trans-stmt.c (gfc_trans_simple_do): Add optional argument to pass in\n+\ta loop exit condition.  If exit condition is given, build the loop exit\n+\tcode, checking IO results of implied do loops in READ and WRITE.\n+\t(gfc_trans_do): Likewise.\n+\t* trans.c (trans_code): New static work function, previously\n+\tgfc_trans_code. Passes exit condition to gfc_trans_do.\n+\t(gfc_trans_code): Calls trans_code with NULL_TREE condition.\n+\t(gfc_trans_code_cond): Calls trans_code with loop exit condition.\n+\t* trans-io.c (build_dt): Build an exit condition to allow checking IO\n+\tresult status bits in the dtparm structure. Use this condition in call\n+\tto gfc_trans_code_cond.\n+\n 2010-02-13  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/41113"}, {"sha": "fd8a806d7d08594650b370761cf733bd2d59b7f9", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc51e7261200de6aa426185513de950e278ab51f/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc51e7261200de6aa426185513de950e278ab51f/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=bc51e7261200de6aa426185513de950e278ab51f", "patch": "@@ -1811,7 +1811,23 @@ build_dt (tree function, gfc_code * code)\n   dt_parm = var;\n   dt_post_end_block = &post_end_block;\n \n-  gfc_add_expr_to_block (&block, gfc_trans_code (code->block->next));\n+  /* Set implied do loop exit condition.  */\n+  if (last_dt == READ || last_dt == WRITE)\n+    {\n+      gfc_st_parameter_field *p = &st_parameter_field[IOPARM_common_flags];\n+\n+      tmp = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\t\t dt_parm, TYPE_FIELDS (TREE_TYPE (dt_parm)), NULL_TREE);\n+      tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t\t  tmp, p->field, NULL_TREE);\n+      tmp = fold_build2 (BIT_AND_EXPR, TREE_TYPE (tmp),\n+\t\t\t  tmp, build_int_cst (TREE_TYPE (tmp),\n+\t\t\t  IOPARM_common_libreturn_mask));\n+    }\n+  else /* IOLENGTH */\n+    tmp = NULL_TREE;\n+\n+  gfc_add_expr_to_block (&block, gfc_trans_code_cond (code->block->next, tmp));\n \n   gfc_add_block_to_block (&block, &post_iu_block);\n "}, {"sha": "60bffdf96d6f8e79a71c45996a20b8b2ac6f6d72", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc51e7261200de6aa426185513de950e278ab51f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc51e7261200de6aa426185513de950e278ab51f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=bc51e7261200de6aa426185513de950e278ab51f", "patch": "@@ -831,7 +831,7 @@ gfc_trans_block_construct (gfc_code* code)\n \n static tree\n gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n-\t\t     tree from, tree to, tree step)\n+\t\t     tree from, tree to, tree step, tree exit_cond)\n {\n   stmtblock_t body;\n   tree type;\n@@ -864,7 +864,7 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   gfc_start_block (&body);\n \n   /* Main loop body.  */\n-  tmp = gfc_trans_code (code->block->next);\n+  tmp = gfc_trans_code_cond (code->block->next, exit_cond);\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Label for cycle statements (if needed).  */\n@@ -882,6 +882,15 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n \t\t\t       \"Loop variable has been modified\");\n     }\n \n+  /* Exit the loop if there is an I/O result condition or error.  */\n+  if (exit_cond)\n+    {\n+      tmp = build1_v (GOTO_EXPR, exit_label);\n+      tmp = fold_build3 (COND_EXPR, void_type_node, exit_cond, tmp,\n+\t\t\t build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n   /* Evaluate the loop condition.  */\n   cond = fold_build2 (EQ_EXPR, boolean_type_node, dovar, to);\n   cond = gfc_evaluate_now (cond, &body);\n@@ -955,7 +964,7 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n    because the loop count itself can overflow.  */\n \n tree\n-gfc_trans_do (gfc_code * code)\n+gfc_trans_do (gfc_code * code, tree exit_cond)\n {\n   gfc_se se;\n   tree dovar;\n@@ -1010,7 +1019,7 @@ gfc_trans_do (gfc_code * code)\n   if (TREE_CODE (type) == INTEGER_TYPE\n       && (integer_onep (step)\n \t|| tree_int_cst_equal (step, integer_minus_one_node)))\n-    return gfc_trans_simple_do (code, &block, dovar, from, to, step);\n+    return gfc_trans_simple_do (code, &block, dovar, from, to, step, exit_cond);\n \n   pos_step = fold_build2 (GT_EXPR, boolean_type_node, step,\n \t\t\t  fold_convert (type, integer_zero_node));\n@@ -1125,7 +1134,7 @@ gfc_trans_do (gfc_code * code)\n   code->block->backend_decl = tree_cons (cycle_label, exit_label, NULL);\n \n   /* Main loop body.  */\n-  tmp = gfc_trans_code (code->block->next);\n+  tmp = gfc_trans_code_cond (code->block->next, exit_cond);\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Label for cycle statements (if needed).  */\n@@ -1143,6 +1152,15 @@ gfc_trans_do (gfc_code * code)\n \t\t\t       \"Loop variable has been modified\");\n     }\n \n+  /* Exit the loop if there is an I/O result condition or error.  */\n+  if (exit_cond)\n+    {\n+      tmp = build1_v (GOTO_EXPR, exit_label);\n+      tmp = fold_build3 (COND_EXPR, void_type_node, exit_cond, tmp,\n+\t\t\t build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n   /* Increment the loop variable.  */\n   tmp = fold_build2 (PLUS_EXPR, type, dovar, step);\n   gfc_add_modify (&body, dovar, tmp);"}, {"sha": "46abc09a09864c81c67b871617da00dc63babc82", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc51e7261200de6aa426185513de950e278ab51f/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc51e7261200de6aa426185513de950e278ab51f/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=bc51e7261200de6aa426185513de950e278ab51f", "patch": "@@ -23,6 +23,9 @@ along with GCC; see the file COPYING3.  If not see\n    Calls gfc_trans_*.  */\n tree gfc_trans_code (gfc_code *);\n \n+/* Wrapper function used to pass a check condition for implied DO loops.  */\n+tree gfc_trans_code_cond (gfc_code *, tree);\n+\n /* All other gfc_trans_* should only need be called by gfc_trans_code */\n \n /* trans-expr.c */\n@@ -45,7 +48,7 @@ tree gfc_trans_return (gfc_code *);\n tree gfc_trans_if (gfc_code *);\n tree gfc_trans_arithmetic_if (gfc_code *);\n tree gfc_trans_block_construct (gfc_code *);\n-tree gfc_trans_do (gfc_code *);\n+tree gfc_trans_do (gfc_code *, tree);\n tree gfc_trans_do_while (gfc_code *);\n tree gfc_trans_select (gfc_code *);\n tree gfc_trans_forall (gfc_code *);"}, {"sha": "535e639faad44ae7d266d652b5851e2a4b431590", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc51e7261200de6aa426185513de950e278ab51f/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc51e7261200de6aa426185513de950e278ab51f/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=bc51e7261200de6aa426185513de950e278ab51f", "patch": "@@ -1048,10 +1048,12 @@ gfc_set_backend_locus (locus * loc)\n }\n \n \n-/* Translate an executable statement.  */\n+/* Translate an executable statement. The tree cond is used by gfc_trans_do.\n+   This static function is wrapped by gfc_trans_code_cond and\n+   gfc_trans_code.  */\n \n-tree\n-gfc_trans_code (gfc_code * code)\n+static tree\n+trans_code (gfc_code * code, tree cond)\n {\n   stmtblock_t block;\n   tree res;\n@@ -1172,7 +1174,7 @@ gfc_trans_code (gfc_code * code)\n \t  break;\n \n \tcase EXEC_DO:\n-\t  res = gfc_trans_do (code);\n+\t  res = gfc_trans_do (code, cond);\n \t  break;\n \n \tcase EXEC_DO_WHILE:\n@@ -1298,6 +1300,25 @@ gfc_trans_code (gfc_code * code)\n }\n \n \n+/* Translate an executable statement with condition, cond.  The condition is\n+   used by gfc_trans_do to test for IO result conditions inside implied\n+   DO loops of READ and WRITE statements.  See build_dt in trans-io.c.  */\n+\n+tree\n+gfc_trans_code_cond (gfc_code * code, tree cond)\n+{\n+  return trans_code (code, cond);\n+}\n+\n+/* Translate an executable statement without condition.  */\n+\n+tree\n+gfc_trans_code (gfc_code * code)\n+{\n+  return trans_code (code, NULL_TREE);\n+}\n+\n+\n /* This function is called after a complete program unit has been parsed\n    and resolved.  */\n "}]}