{"sha": "c727b835139299adc623951aff782cdfaff655d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcyN2I4MzUxMzkyOTlhZGM2MjM5NTFhZmY3ODJjZGZhZmY2NTVkOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-10-11T12:59:56Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-10-11T12:59:56Z"}, "message": "x86-tune-costs.h (bdver?_memcpy, [...]): Unify to ...\n\n2018-10-11  Richard Biener  <rguenther@suse.de>\n\n\t* config/i386/x86-tune-costs.h (bdver?_memcpy, bdver?_memset,\n\tbdver?_cost): Unify to ...\n\t(bdver_memcpy, bdver_memset, bdver_cost): ... this.\n\t* config/i386/i386.c (processor_cost_table): Adjust.\n\nFrom-SVN: r265038", "tree": {"sha": "22e1fc78856420b88c46c9864f4bc1c1d7af758d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22e1fc78856420b88c46c9864f4bc1c1d7af758d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c727b835139299adc623951aff782cdfaff655d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c727b835139299adc623951aff782cdfaff655d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c727b835139299adc623951aff782cdfaff655d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c727b835139299adc623951aff782cdfaff655d9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c1b48b29294ed58e72129db4db42adab3d0d1a9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1b48b29294ed58e72129db4db42adab3d0d1a9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1b48b29294ed58e72129db4db42adab3d0d1a9a"}], "stats": {"total": 333, "additions": 17, "deletions": 316}, "files": [{"sha": "8f1f735ea7daabc86bc8c885d384e5f994dd832a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c727b835139299adc623951aff782cdfaff655d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c727b835139299adc623951aff782cdfaff655d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c727b835139299adc623951aff782cdfaff655d9", "patch": "@@ -1,3 +1,10 @@\n+2018-10-11  Richard Biener  <rguenther@suse.de>\n+\n+\t* config/i386/x86-tune-costs.h (bdver?_memcpy, bdver?_memset,\n+\tbdver?_cost): Unify to ...\n+\t(bdver_memcpy, bdver_memset, bdver_cost): ... this.\n+\t* config/i386/i386.c (processor_cost_table): Adjust.\n+\n 2018-10-10  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/87574"}, {"sha": "3ab6b205eb6179dde669ec71eca9367cfacc76ba", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c727b835139299adc623951aff782cdfaff655d9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c727b835139299adc623951aff782cdfaff655d9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c727b835139299adc623951aff782cdfaff655d9", "patch": "@@ -861,10 +861,10 @@ static const struct processor_costs *processor_cost_table[PROCESSOR_max] =\n   &athlon_cost,\n   &k8_cost,\n   &amdfam10_cost,\n-  &bdver1_cost,\n-  &bdver2_cost,\n-  &bdver3_cost,\n-  &bdver4_cost,\n+  &bdver_cost,\n+  &bdver_cost,\n+  &bdver_cost,\n+  &bdver_cost,\n   &btver1_cost,\n   &btver2_cost,\n   &znver1_cost,"}, {"sha": "dbf9eb504027fb25d677edde5de9fae6257b3a3f", "filename": "gcc/config/i386/x86-tune-costs.h", "status": "modified", "additions": 6, "deletions": 312, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c727b835139299adc623951aff782cdfaff655d9/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c727b835139299adc623951aff782cdfaff655d9/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h?ref=c727b835139299adc623951aff782cdfaff655d9", "patch": "@@ -1047,21 +1047,21 @@ struct processor_costs amdfam10_cost = {\n   \"32\",\t\t\t\t\t/* Func alignment.  */\n };\n \n-/*  BDVER1 has optimized REP instruction for medium sized blocks, but for\n+/*  BDVER has optimized REP instruction for medium sized blocks, but for\n     very small blocks it is better to use loop. For large blocks, libcall\n     can do nontemporary accesses and beat inline considerably.  */\n-static stringop_algs bdver1_memcpy[2] = {\n+static stringop_algs bdver_memcpy[2] = {\n   {libcall, {{6, loop, false}, {14, unrolled_loop, false},\n              {-1, rep_prefix_4_byte, false}}},\n   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n              {-1, libcall, false}}}};\n-static stringop_algs bdver1_memset[2] = {\n+static stringop_algs bdver_memset[2] = {\n   {libcall, {{8, loop, false}, {24, unrolled_loop, false},\n              {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n              {-1, libcall, false}}}};\n \n-const struct processor_costs bdver1_cost = {\n+const struct processor_costs bdver_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -1139,314 +1139,8 @@ const struct processor_costs bdver1_cost = {\n   COSTS_N_INSNS (15),\t\t\t/* cost of SQRTSS instruction.  */\n   COSTS_N_INSNS (26),\t\t\t/* cost of SQRTSD instruction.  */\n   1, 2, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n-  bdver1_memcpy,\n-  bdver1_memset,\n-  COSTS_N_INSNS (4),\t\t\t/* cond_taken_branch_cost.  */\n-  COSTS_N_INSNS (2),\t\t\t/* cond_not_taken_branch_cost.  */\n-  \"16:11:8\",\t\t\t\t/* Loop alignment.  */\n-  \"16:8:8\",\t\t\t\t/* Jump alignment.  */\n-  \"0:0:8\",\t\t\t\t/* Label alignment.  */\n-  \"11\",\t\t\t\t\t/* Func alignment.  */\n-};\n-\n-/*  BDVER2 has optimized REP instruction for medium sized blocks, but for\n-    very small blocks it is better to use loop. For large blocks, libcall\n-    can do nontemporary accesses and beat inline considerably.  */\n-\n-static stringop_algs bdver2_memcpy[2] = {\n-  {libcall, {{6, loop, false}, {14, unrolled_loop, false},\n-             {-1, rep_prefix_4_byte, false}}},\n-  {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n-             {-1, libcall, false}}}};\n-static stringop_algs bdver2_memset[2] = {\n-  {libcall, {{8, loop, false}, {24, unrolled_loop, false},\n-             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-  {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n-             {-1, libcall, false}}}};\n-\n-const struct processor_costs bdver2_cost = {\n-  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n-  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n-  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n-  {COSTS_N_INSNS (4),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t SI */\n-   COSTS_N_INSNS (6),\t\t\t/*\t\t\t\t DI */\n-   COSTS_N_INSNS (6)},\t\t\t/*\t\t\t      other */\n-  0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {COSTS_N_INSNS (19),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (35),\t\t\t/*\t\t\t    HI */\n-   COSTS_N_INSNS (51),\t\t\t/*\t\t\t    SI */\n-   COSTS_N_INSNS (83),\t\t\t/*\t\t\t    DI */\n-   COSTS_N_INSNS (83)},\t\t\t/*\t\t\t    other */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n-  8,\t\t\t\t\t/* \"large\" insn */\n-  9,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n-  {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n-\t\t\t\t\t   in QImode, HImode and SImode.\n-\t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {8, 8, 8},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n-\t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  {10, 10, 18},\t\t\t\t/* cost of storing fp registers\n- \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  4,\t\t\t\t\t/* cost of moving MMX register */\n-  {12, 12},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {10, 10},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {12, 12, 10, 20, 30},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n-  {12, 12, 10, 20, 30},\t\t\t/* cost of unaligned loads.  */\n-  {10, 10, 10, 20, 30},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n-  {10, 10, 10, 20, 30},\t\t\t/* cost of unaligned stores.  */\n-  16, 20,\t\t\t\t/* SSE->integer and integer->SSE moves */\n-  12, 12,\t\t\t\t/* Gather load static, per_elt.  */\n-  10, 10,\t\t\t\t/* Gather store static, per_elt.  */\n-  16,\t\t\t\t\t/* size of l1 cache.  */\n-  2048,\t\t\t\t\t/* size of l2 cache.  */\n-  64,\t\t\t\t\t/* size of prefetch block */\n-  /* New AMD processors never drop prefetches; if they cannot be performed\n-     immediately, they are queued.  We set number of simultaneous prefetches\n-     to a large constant to reflect this (it probably is not a good idea not\n-     to limit number of prefetches at all, as their execution also takes some\n-     time).  */\n-  100,\t\t\t\t\t/* number of parallel prefetches */\n-  2,\t\t\t\t\t/* Branch cost */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FADD and FSUB insns.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FMUL instruction.  */\n-  COSTS_N_INSNS (42),\t\t\t/* cost of FDIV instruction.  */\n-  COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n-  COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n-  COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n-\n-  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of MULSS instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of MULSD instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n-  /* 9-24  */\n-  COSTS_N_INSNS (24),\t\t\t/* cost of DIVSS instruction.  */\n-  /* 9-27  */\n-  COSTS_N_INSNS (27),\t\t\t/* cost of DIVSD instruction.  */\n-  COSTS_N_INSNS (15),\t\t\t/* cost of SQRTSS instruction.  */\n-  COSTS_N_INSNS (26),\t\t\t/* cost of SQRTSD instruction.  */\n-  1, 2, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n-  bdver2_memcpy,\n-  bdver2_memset,\n-  COSTS_N_INSNS (4),\t\t\t/* cond_taken_branch_cost.  */\n-  COSTS_N_INSNS (2),\t\t\t/* cond_not_taken_branch_cost.  */\n-  \"16:11:8\",\t\t\t\t/* Loop alignment.  */\n-  \"16:8:8\",\t\t\t\t/* Jump alignment.  */\n-  \"0:0:8\",\t\t\t\t/* Label alignment.  */\n-  \"11\",\t\t\t\t\t/* Func alignment.  */\n-};\n-\n-\n-  /*  BDVER3 has optimized REP instruction for medium sized blocks, but for\n-      very small blocks it is better to use loop. For large blocks, libcall\n-      can do nontemporary accesses and beat inline considerably.  */\n-static stringop_algs bdver3_memcpy[2] = {\n-  {libcall, {{6, loop, false}, {14, unrolled_loop, false},\n-             {-1, rep_prefix_4_byte, false}}},\n-  {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n-             {-1, libcall, false}}}};\n-static stringop_algs bdver3_memset[2] = {\n-  {libcall, {{8, loop, false}, {24, unrolled_loop, false},\n-             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-  {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n-             {-1, libcall, false}}}};\n-struct processor_costs bdver3_cost = {\n-  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n-  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n-  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n-  {COSTS_N_INSNS (4),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t SI */\n-   COSTS_N_INSNS (6),\t\t\t/*\t\t\t\t DI */\n-   COSTS_N_INSNS (6)},\t\t\t/*\t\t\t      other */\n-  0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {COSTS_N_INSNS (19),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (35),\t\t\t/*\t\t\t    HI */\n-   COSTS_N_INSNS (51),\t\t\t/*\t\t\t    SI */\n-   COSTS_N_INSNS (83),\t\t\t/*\t\t\t    DI */\n-   COSTS_N_INSNS (83)},\t\t\t/*\t\t\t    other */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n-  8,\t\t\t\t\t/* \"large\" insn */\n-  9,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n-  {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n-\t\t\t\t\t   in QImode, HImode and SImode.\n-\t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {8, 8, 8},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n-\t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  {10, 10, 18},\t\t\t\t/* cost of storing fp registers\n- \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  4,\t\t\t\t\t/* cost of moving MMX register */\n-  {12, 12},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {10, 10},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {12, 12, 10, 20, 30},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n-  {12, 12, 10, 20, 30},\t\t\t/* cost of unaligned loads.  */\n-  {10, 10, 10, 20, 30},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n-  {10, 10, 10, 20, 30},\t\t\t/* cost of unaligned stores.  */\n-  16, 20,\t\t\t\t/* SSE->integer and integer->SSE moves */\n-  12, 12,\t\t\t\t/* Gather load static, per_elt.  */\n-  10, 10,\t\t\t\t/* Gather store static, per_elt.  */\n-  16,\t\t\t\t\t/* size of l1 cache.  */\n-  2048,\t\t\t\t\t/* size of l2 cache.  */\n-  64,\t\t\t\t\t/* size of prefetch block */\n-  /* New AMD processors never drop prefetches; if they cannot be performed\n-     immediately, they are queued.  We set number of simultaneous prefetches\n-     to a large constant to reflect this (it probably is not a good idea not\n-     to limit number of prefetches at all, as their execution also takes some\n-     time).  */\n-  100,\t\t\t\t\t/* number of parallel prefetches */\n-  2,\t\t\t\t\t/* Branch cost */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FADD and FSUB insns.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FMUL instruction.  */\n-  COSTS_N_INSNS (42),\t\t\t/* cost of FDIV instruction.  */\n-  COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n-  COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n-  COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n-\n-  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of MULSS instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of MULSD instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n-  /* 9-24  */\n-  COSTS_N_INSNS (24),\t\t\t/* cost of DIVSS instruction.  */\n-  /* 9-27  */\n-  COSTS_N_INSNS (27),\t\t\t/* cost of DIVSD instruction.  */\n-  COSTS_N_INSNS (15),\t\t\t/* cost of SQRTSS instruction.  */\n-  COSTS_N_INSNS (26),\t\t\t/* cost of SQRTSD instruction.  */\n-  1, 2, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n-  bdver3_memcpy,\n-  bdver3_memset,\n-  COSTS_N_INSNS (4),\t\t\t/* cond_taken_branch_cost.  */\n-  COSTS_N_INSNS (2),\t\t\t/* cond_not_taken_branch_cost.  */\n-  \"16:11:8\",\t\t\t\t/* Loop alignment.  */\n-  \"16:8:8\",\t\t\t\t/* Jump alignment.  */\n-  \"0:0:8\",\t\t\t\t/* Label alignment.  */\n-  \"11\",\t\t\t\t\t/* Func alignment.  */\n-};\n-\n-/*  BDVER4 has optimized REP instruction for medium sized blocks, but for\n-    very small blocks it is better to use loop. For large blocks, libcall\n-    can do nontemporary accesses and beat inline considerably.  */\n-static stringop_algs bdver4_memcpy[2] = {\n-  {libcall, {{6, loop, false}, {14, unrolled_loop, false},\n-             {-1, rep_prefix_4_byte, false}}},\n-  {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n-             {-1, libcall, false}}}};\n-static stringop_algs bdver4_memset[2] = {\n-  {libcall, {{8, loop, false}, {24, unrolled_loop, false},\n-             {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n-  {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n-             {-1, libcall, false}}}};\n-struct processor_costs bdver4_cost = {\n-  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction */\n-  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n-  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n-  {COSTS_N_INSNS (4),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t SI */\n-   COSTS_N_INSNS (6),\t\t\t/*\t\t\t\t DI */\n-   COSTS_N_INSNS (6)},\t\t\t/*\t\t\t      other */\n-  0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {COSTS_N_INSNS (19),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (35),\t\t\t/*\t\t\t    HI */\n-   COSTS_N_INSNS (51),\t\t\t/*\t\t\t    SI */\n-   COSTS_N_INSNS (83),\t\t\t/*\t\t\t    DI */\n-   COSTS_N_INSNS (83)},\t\t\t/*\t\t\t    other */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n-  8,\t\t\t\t\t/* \"large\" insn */\n-  9,\t\t\t\t\t/* MOVE_RATIO */\n-\n-  /* All move costs are relative to integer->integer move times 2 and thus\n-     they are latency*2. */\n-  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n-  {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n-\t\t\t\t\t   in QImode, HImode and SImode.\n-\t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {8, 8, 8},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n-\t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  {10, 10, 18},\t\t\t\t/* cost of storing fp registers\n- \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  4,\t\t\t\t\t/* cost of moving MMX register */\n-  {12, 12},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {10, 10},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n-  {12, 12, 10, 20, 30},\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n-  {12, 12, 10, 20, 30},\t\t\t/* cost of unaligned loads.  */\n-  {10, 10, 10, 20, 30},\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n-  {10, 10, 10, 20, 30},\t\t\t/* cost of unaligned stores.  */\n-  16, 20,\t\t\t\t/* SSE->integer and integer->SSE moves */\n-  12, 12,\t\t\t\t/* Gather load static, per_elt.  */\n-  10, 10,\t\t\t\t/* Gather store static, per_elt.  */\n-  16,\t\t\t\t\t/* size of l1 cache.  */\n-  2048,\t\t\t\t\t/* size of l2 cache.  */\n-  64,\t\t\t\t\t/* size of prefetch block */\n-  /* New AMD processors never drop prefetches; if they cannot be performed\n-     immediately, they are queued.  We set number of simultaneous prefetches\n-     to a large constant to reflect this (it probably is not a good idea not\n-     to limit number of prefetches at all, as their execution also takes some\n-     time).  */\n-  100,\t\t\t\t\t/* number of parallel prefetches */\n-  2,\t\t\t\t\t/* Branch cost */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FADD and FSUB insns.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FMUL instruction.  */\n-  COSTS_N_INSNS (42),\t\t\t/* cost of FDIV instruction.  */\n-  COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n-  COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n-  COSTS_N_INSNS (52),\t\t\t/* cost of FSQRT instruction.  */\n-\n-  COSTS_N_INSNS (2),\t\t\t/* cost of cheap SSE instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of MULSS instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of MULSD instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SS instruction.  */\n-  COSTS_N_INSNS (6),\t\t\t/* cost of FMA SD instruction.  */\n-  /* 9-24  */\n-  COSTS_N_INSNS (24),\t\t\t/* cost of DIVSS instruction.  */\n-  /* 9-27  */\n-  COSTS_N_INSNS (27),\t\t\t/* cost of DIVSD instruction.  */\n-  COSTS_N_INSNS (15),\t\t\t/* cost of SQRTSS instruction.  */\n-  COSTS_N_INSNS (26),\t\t\t/* cost of SQRTSD instruction.  */\n-  1, 2, 1, 1,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n-  bdver4_memcpy,\n-  bdver4_memset,\n+  bdver_memcpy,\n+  bdver_memset,\n   COSTS_N_INSNS (4),\t\t\t/* cond_taken_branch_cost.  */\n   COSTS_N_INSNS (2),\t\t\t/* cond_not_taken_branch_cost.  */\n   \"16:11:8\",\t\t\t\t/* Loop alignment.  */"}]}