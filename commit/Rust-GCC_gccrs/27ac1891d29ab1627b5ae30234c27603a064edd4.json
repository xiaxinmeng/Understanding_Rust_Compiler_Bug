{"sha": "27ac1891d29ab1627b5ae30234c27603a064edd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdhYzE4OTFkMjlhYjE2MjdiNWFlMzAyMzRjMjc2MDNhMDY0ZWRkNA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "dosreis@cmla.ens-cachan.fr", "date": "1999-06-04T19:35:36Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "1999-06-04T19:35:36Z"}, "message": "std_valarray.h: New file.\n\n\t* std/std_valarray.h: New file.\n \t* std/slice.h: New file.\n\t* std/slice_array.h: New file.\n\t* std/gslice.h: New file.\n\t* std/gslice_array.h: New file.\n\t* std/mask_array.h: New file.\n\t* std/indirect_array.h: New file.\n\t* std/valarray_array.h: New file.\n\t* std/valarray_array.tcc: New file.\n\t* std/valarray_meta.h: New file.\n\t* valarray.cc: New file.\n\t* valarray: New file\n\t* Makefile.in (OBJS): add valarray.o\n\t(HEADERS): add valarray\n\t(valarray.o): define dependency on valarray.cc\n\t(install): make it possible to install valarray files.\n\nFrom-SVN: r27354", "tree": {"sha": "9e997615b80cf29c9d5d29dac7105038bc90622b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e997615b80cf29c9d5d29dac7105038bc90622b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27ac1891d29ab1627b5ae30234c27603a064edd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27ac1891d29ab1627b5ae30234c27603a064edd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27ac1891d29ab1627b5ae30234c27603a064edd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27ac1891d29ab1627b5ae30234c27603a064edd4/comments", "author": null, "committer": null, "parents": [{"sha": "5c5d086f8518a95e294d8af02174f035e9588db3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5d086f8518a95e294d8af02174f035e9588db3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c5d086f8518a95e294d8af02174f035e9588db3"}], "stats": {"total": 3133, "additions": 3130, "deletions": 3}, "files": [{"sha": "a5811cf0c6c2dd44f7fbe7ab326ac2b61d507f6d", "filename": "libstdc++/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2FChangeLog?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -1,3 +1,23 @@\n+1999-06-06  Gabriel Dos Reis  <dosreis@cmla.ens-cachan.fr>\n+\n+\t* std/std_valarray.h: New file.\n+ \t* std/slice.h: New file.\n+\t* std/slice_array.h: New file.\n+\t* std/gslice.h: New file.\n+\t* std/gslice_array.h: New file.\n+\t* std/mask_array.h: New file.\n+\t* std/indirect_array.h: New file.\n+\t* std/valarray_array.h: New file.\n+\t* std/valarray_array.tcc: New file.\n+\t* std/valarray_meta.h: New file.\n+\t* valarray.cc: New file.\n+\t* valarray: New file\n+\n+\t* Makefile.in (OBJS): add valarray.o\n+\t(HEADERS): add valarray\n+\t(valarray.o): define dependency on valarray.cc\n+\t(install): make it possible to install valarray file.\n+\t\n Wed Jun  2 00:21:54 1999  Robert Lipe  <robertlipe@usa.net>\n \n \t* std/bastring.h (class basic_string:Rep): Encode xlock opcode"}, {"sha": "6d2fcba662d25e0562d641ef4c2aa0178ad0e762", "filename": "libstdc++/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2FMakefile.in?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -19,7 +19,7 @@ INTERFACE = 2\n \n gxx_include_dir=${includedir}/g++\n \n-OBJS  = cstringi.o stdexcepti.o cstdlibi.o cmathi.o stlinst.o\n+OBJS  = cstringi.o stdexcepti.o cstdlibi.o cmathi.o stlinst.o valarray.o\n SUBLIBS = $(STAMP)-string $(STAMP)-complx\n \n # C++ headers with no extension\n@@ -28,7 +28,7 @@ HEADERS= cassert cctype cerrno cfloat ciso646 climits clocale cmath complex \\\n \t cwchar cwctype string stdexcept \\\n \t algorithm deque functional hash_map hash_set iterator list map \\\n \t memory numeric pthread_alloc queue rope set slist stack utility \\\n-\t vector fstream iomanip iostream strstream iosfwd bitset\n+\t vector fstream iomanip iostream strstream iosfwd bitset valarray\n \n ARLIB   = libstdc++.a.$(VERSION)\n ARLINK  = libstdc++.a\n@@ -130,6 +130,7 @@ cstdlibi.o: cstdlibi.cc\n cmathi.o: cmathi.cc\n stdexcepti.o: stdexcepti.cc\n stlinst.o: stlinst.cc\n+valarray.o: valarray.cc\n \n # Later do wide strings, too.\n stmp-string: ${srcdir}/sinst.cc ${srcdir}/std/bastring.h \\\n@@ -269,7 +270,7 @@ install:\n \t    fi ; \\\n \t    chmod a-x $(gxx_include_dir)/$$FILE ; \\\n \t  done ; \\\n-\t  for FILE in *.h std/*.h std/*.cc; do \\\n+\t  for FILE in *.h std/*.h std/*.cc std/*.tcc; do \\\n \t    rm -f $(gxx_include_dir)/$$FILE ; \\\n \t    $(INSTALL_DATA) $$FILE $(gxx_include_dir)/$$FILE ; \\\n \t    chmod a-x $(gxx_include_dir)/$$FILE ; \\"}, {"sha": "4f6e854a14c0fc7c0e14dedc890232784454f7ae", "filename": "libstdc++/std/gslice.h", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fgslice.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fgslice.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fgslice.h?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,111 @@\n+// The template and inlines for the -*- C++ -*- gslice class.\n+\n+// Copyright (C) 1997-1999 Cygnus Solutions\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef __GSLICE__\n+#define __GSLICE__\n+\n+extern \"C++\" {\n+\n+struct _Indexer {\n+    size_t _M_count;\n+    size_t _M_start;\n+    valarray<size_t> _M_size;\n+    valarray<size_t> _M_stride;\n+    valarray<size_t> _M_index;\n+    _Indexer(size_t, const valarray<size_t>&, const valarray<size_t>&);\n+    void _M_increment_use() { ++_M_count; }\n+    size_t _M_decrement_use() { return --_M_count; }\n+};\n+\n+    \n+class gslice\n+{\n+public:\n+    gslice ();\n+    gslice (size_t, const valarray<size_t>&, const valarray<size_t>&);\n+    gslice(const gslice&);\n+    ~gslice();\n+\n+    gslice& operator= (const gslice&);\n+    size_t           start () const;\n+    valarray<size_t> size () const;\n+    valarray<size_t> stride () const;\n+    \n+private:\n+    _Indexer* _M_index;\n+    \n+    template<typename _Tp> friend class valarray;\n+};\n+    \n+inline size_t\n+gslice::start () const\n+{ return _M_index ? _M_index->_M_start : 0; }\n+\n+inline valarray<size_t>\n+gslice::size () const\n+{ return _M_index ? _M_index->_M_size : valarray<size_t>(); }\n+\n+inline valarray<size_t>\n+gslice::stride () const\n+{ return _M_index ? _M_index->_M_stride : valarray<size_t>(); }\n+\n+inline gslice::gslice () : _M_index(0) {}\n+\n+inline\n+gslice::gslice(size_t __o, const valarray<size_t>& __l,\n+               const valarray<size_t>& __s)\n+        : _M_index(new _Indexer(__o, __l, __s)) {}\n+\n+inline\n+gslice::gslice(const gslice& __g) : _M_index(__g._M_index)\n+{ if (_M_index) _M_index->_M_increment_use(); }\n+\n+inline\n+gslice::~gslice()\n+{ if (_M_index && _M_index->_M_decrement_use() == 0) delete _M_index; }\n+\n+inline gslice&\n+gslice::operator= (const gslice& __g)\n+{\n+    if (__g._M_index) __g._M_index->_M_increment_use();\n+    if (_M_index && _M_index->_M_decrement_use() == 0) delete _M_index;\n+    _M_index = __g._M_index;\n+    return *this;\n+}\n+\n+\n+} // extern \"C++\"\n+\n+#endif // __GSLICE__\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "8a67cac90502bf954162a460c7e100734e91bbd6", "filename": "libstdc++/std/gslice_array.h", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fgslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fgslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fgslice_array.h?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,170 @@\n+// The template and inlines for the -*- C++ -*- gslice_array class.\n+\n+// Copyright (C) 1997-1999 Cygnus Solutions\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef __GSLICE_ARRAY__\n+#define __GSLICE_ARRAY__\n+\n+extern \"C++\" {\n+\n+template<typename _Tp> class gslice_array\n+{\n+public:\n+    typedef _Tp value_type;\n+    \n+    void operator=  (const valarray<_Tp>&) const;\n+    void operator*= (const valarray<_Tp>&) const;\n+    void operator/= (const valarray<_Tp>&) const;\n+    void operator%= (const valarray<_Tp>&) const;\n+    void operator+= (const valarray<_Tp>&) const;\n+    void operator-= (const valarray<_Tp>&) const;\n+    void operator^= (const valarray<_Tp>&) const;\n+    void operator&= (const valarray<_Tp>&) const;\n+    void operator|= (const valarray<_Tp>&) const;\n+    void operator<<=(const valarray<_Tp>&) const;\n+    void operator>>=(const valarray<_Tp>&) const;\n+    void operator=(const _Tp&);\n+    \n+    template<class _Dom>\n+    void operator= (const _Expr<_Dom,_Tp>&) const;\n+    template<class _Dom>\n+    void operator*= (const _Expr<_Dom,_Tp>&) const;\n+    template<class _Dom>\n+    void operator/= (const _Expr<_Dom,_Tp>&) const;\n+    template<class _Dom>\n+    void operator%= (const _Expr<_Dom,_Tp>&) const;\n+    template<class _Dom>\n+    void operator+= (const _Expr<_Dom,_Tp>&) const;\n+    template<class _Dom>\n+    void operator-= (const _Expr<_Dom,_Tp>&) const;\n+    template<class _Dom>\n+    void operator^= (const _Expr<_Dom,_Tp>&) const;\n+    template<class _Dom>\n+    void operator&= (const _Expr<_Dom,_Tp>&) const;\n+    template<class _Dom>\n+    void operator|= (const _Expr<_Dom,_Tp>&) const;\n+    template<class _Dom>\n+    void operator<<= (const _Expr<_Dom,_Tp>&) const;\n+    template<class _Dom>\n+    void operator>>= (const _Expr<_Dom,_Tp>&) const;\n+    \n+private:\n+    _Array<_Tp>    _M_array;\n+    const valarray<size_t>& _M_index;\n+    \n+    friend class valarray<_Tp>;\n+    \n+    gslice_array (_Array<_Tp>, const valarray<size_t>&);\n+    \n+    // this constructor needs to be implemented.\n+    gslice_array (const gslice_array&);\n+    \n+    // not implemented\n+    gslice_array();\n+    gslice_array& operator= (const gslice_array&);\n+};\n+\n+template<typename _Tp>\n+inline\n+gslice_array<_Tp>::gslice_array (_Array<_Tp> __a,\n+                                 const valarray<size_t>& __i)\n+        : _M_array (__a), _M_index (__i) {}\n+\n+\n+template<typename _Tp>\n+inline\n+gslice_array<_Tp>::gslice_array (const gslice_array<_Tp>& __a)\n+        : _M_array (__a._M_array), _M_index (__a._M_index) {}\n+\n+\n+template<typename _Tp>\n+inline void\n+gslice_array<_Tp>::operator= (const _Tp& __t) \n+{ \n+    __valarray_fill (_M_array, _Array<size_t>(_M_index),\n+                     _M_index.size(), __t); \n+}\n+\n+template<typename _Tp>\n+inline void\n+gslice_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n+{\n+    __valarray_copy (_Array<_Tp> (__v), __v.size (),\n+                     _M_array, _Array<size_t>(_M_index));\n+}\n+\n+template<typename _Tp>\n+template<class E>\n+inline void\n+gslice_array<_Tp>::operator= (const _Expr<E, _Tp>& __e) const\n+{\n+    __valarray_copy (__e, _M_index.size(), _M_array,\n+                     _Array<size_t>(_M_index));\n+}\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+gslice_array<_Tp>::operator##op##= (const valarray<_Tp>& __v) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##name (_M_array, _Array<size_t>(_M_index),\t\\\n+                              _Array<_Tp> (__v), __v.size ());\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp> template<class E>        \t\t\t\\\n+inline void \t\t\t\t\t\t\t\t\\\n+gslice_array<_Tp>::operator##op##= (const _Expr<E, _Tp>& __e) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##name (_M_array, _Array<size_t>(_M_index), __e,\t\\\n+                              _M_index.size());\t\t\t\t\\\n+}\n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)    \n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)    \n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+\n+} // extern \"C++\"\n+\n+    \n+#endif // __GSLICE_ARRAY__\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "bb5b79fb834d1bc46aa09559286922556f512258", "filename": "libstdc++/std/indirect_array.h", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Findirect_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Findirect_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Findirect_array.h?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,157 @@\n+// The template and inlines for the -*- C++ -*- indirect_array class.\n+\n+// Copyright (C) 1997-1999 Cygnus Solutions\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef __INDIRECT_ARRAY__\n+#define __INDIRECT_ARRAY__\n+\n+extern \"C++\" {\n+\n+template <class _Tp> class indirect_array\n+{\n+public:\n+    typedef _Tp value_type;\n+    \n+    void operator=  (const valarray<_Tp>&) const;\n+    void operator*= (const valarray<_Tp>&) const;\n+    void operator/= (const valarray<_Tp>&) const;\n+    void operator%= (const valarray<_Tp>&) const; \n+    void operator+= (const valarray<_Tp>&) const;\n+    void operator-= (const valarray<_Tp>&) const;  \n+    void operator^= (const valarray<_Tp>&) const;\n+    void operator&= (const valarray<_Tp>&) const;\n+    void operator|= (const valarray<_Tp>&) const;\n+    void operator<<= (const valarray<_Tp>&) const;\n+    void operator>>= (const valarray<_Tp>&) const; \n+    void operator= (const _Tp&);\n+    \n+    template<class _Dom>\n+    void operator=  (const _Expr<_Dom, _Tp>&) const;\n+    template<class _Dom>\n+    void operator*= (const _Expr<_Dom, _Tp>&) const;\n+    template<class _Dom>\n+    void operator/= (const _Expr<_Dom, _Tp>&) const;\n+    template<class _Dom>\n+    void operator%= (const _Expr<_Dom, _Tp>&) const;\n+    template<class _Dom>\n+    void operator+= (const _Expr<_Dom, _Tp>&) const;\n+    template<class _Dom>\n+    void operator-= (const _Expr<_Dom, _Tp>&) const;\n+    template<class _Dom>\n+    void operator^= (const _Expr<_Dom, _Tp>&) const;\n+    template<class _Dom>\n+    void operator&= (const _Expr<_Dom, _Tp>&) const;\n+    template<class _Dom>\n+    void operator|= (const _Expr<_Dom, _Tp>&) const;\n+    template<class _Dom>\n+    void operator<<= (const _Expr<_Dom, _Tp>&) const;\n+    template<class _Dom>\n+    void operator>>= (const _Expr<_Dom, _Tp>&) const; \n+    \n+private:\n+    indirect_array (const indirect_array&);\n+    indirect_array (_Array<_Tp>, size_t, _Array<size_t>);\n+    \n+    friend class valarray<_Tp>;\n+    friend class gslice_array<_Tp>;\n+    \n+    const size_t \t _M_sz;\n+    const _Array<size_t> _M_index;\n+    const _Array<_Tp> \t _M_array;\n+    \n+    // not implemented\n+    indirect_array ();\n+    indirect_array& operator= (const indirect_array&);\n+};\n+\n+template<typename _Tp>\n+inline indirect_array<_Tp>::indirect_array(const indirect_array<_Tp>& __a)\n+        : _M_sz (__a._M_sz), _M_index (__a._M_index),\n+          _M_array (__a._M_array) {}\n+\n+template<typename _Tp>\n+inline\n+indirect_array<_Tp>::indirect_array (_Array<_Tp> __a, size_t __s, \n+                                     _Array<size_t> __i)\n+        : _M_sz (__s), _M_index (__i), _M_array (__a) {}\n+\n+\n+template<typename _Tp>\n+inline void\n+indirect_array<_Tp>::operator= (const _Tp& __t)\n+{ __valarray_fill(_M_array, _M_index, _M_sz, __t); }\n+\n+template<typename _Tp>\n+inline void\n+indirect_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n+{ __valarray_copy (_Array<_Tp> (__v), _M_sz, _M_array, _M_index); }\n+\n+template<typename _Tp>\n+template<class _Dom>\n+inline void\n+indirect_array<_Tp>::operator= (const _Expr<_Dom,_Tp>& __e) const\n+{ __valarray_copy (__e, _M_sz, _M_array, _M_index); }\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+indirect_array<_Tp>::operator##op##= (const valarray<_Tp>& __v) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_index, _Array<_Tp> (__v), _M_sz); \\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp> template<class _Dom>\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+indirect_array<_Tp>::operator##op##= (const _Expr<_Dom,_Tp>& __e) const \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_index, __e, _M_sz);\t\t\\\n+}\n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)\n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)\n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+\n+} // extern \"C++\"\n+\n+#endif // __INDIRECT_ARRAY__\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "d431be4e97fd45ac30e181f4b8fdc1956cd27ff1", "filename": "libstdc++/std/mask_array.h", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fmask_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fmask_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fmask_array.h?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,154 @@\n+// The template and inlines for the -*- C++ -*- mask_array class.\n+\n+// Copyright (C) 1997-1999 Cygnus Solutions\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef __MASK_ARRAY__\n+#define __MASK_ARRAY__\n+\n+extern \"C++\" {\n+\n+template <class _T> class mask_array\n+{ \n+public:\n+    typedef _T value_type;\n+    \n+    void operator=  (const valarray<_T>&) const;\n+    void operator*= (const valarray<_T>&) const;\n+    void operator/= (const valarray<_T>&) const;\n+    void operator%= (const valarray<_T>&) const;\n+    void operator+= (const valarray<_T>&) const; \n+    void operator-= (const valarray<_T>&) const;\n+    void operator^= (const valarray<_T>&) const;  \n+    void operator&= (const valarray<_T>&) const;\n+    void operator|= (const valarray<_T>&) const;\n+    void operator<<=(const valarray<_T>&) const;  \n+    void operator>>=(const valarray<_T>&) const; \n+    void operator= (const _T&);\n+    \n+    template<class _Dom>\n+    void operator=  (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator*= (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator/= (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator%= (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator+= (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator-= (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator^= (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator&= (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator|= (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator<<=(const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator>>=(const _Expr<_Dom,_T>&) const; \n+    \n+private:\n+    mask_array (_Array<_T>, size_t, _Array<bool>);\n+    friend class valarray<_T>;\n+    \n+    const size_t       _M_sz;\n+    const _Array<bool> _M_mask;\n+    const _Array<_T>   _M_array;\n+    \n+    mask_array (const mask_array&);\n+    \n+    // not implemented\n+    mask_array ();\n+    mask_array& operator= (const mask_array&);\n+};\n+\n+template<typename _Tp>\n+inline mask_array<_Tp>::mask_array (const mask_array<_Tp>& a)\n+        : _M_sz (a._M_sz), _M_mask (a._M_mask), _M_array (a._M_array) {}\n+\n+template<typename _T>\n+inline \n+mask_array<_T>::mask_array (_Array<_T> __a, size_t __s, _Array<bool> __m)\n+        : _M_sz (__s), _M_mask (__m), _M_array (__a) {}\n+\n+template<typename _T>\n+inline void\n+mask_array<_T>::operator= (const _T& __t)\n+{ __valarray_fill (_M_array, _M_sz, _M_mask, __t); }\n+    \n+template<typename _T>\n+inline void\n+mask_array<_T>::operator= (const valarray<_T>& __v) const\n+{ __valarray_copy (_Array<_T> (__v), __v.size (), _M_array, _M_mask); }\n+\n+template<typename _T>\n+template<class E>\n+inline void\n+mask_array<_T>::operator= (const _Expr<E, _T>& __e) const\n+{ __valarray_copy (__e, __e.size (), _M_array, _M_mask); }\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _T>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+mask_array<_T>::operator##op##= (const valarray<_T>& __v) const\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_mask, \t\t\t\t\\\n+                           _Array<_T> (__v), __v.size ());\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _T> template<class E>\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+mask_array<_T>::operator##op##= (const _Expr<E, _T>& __e) const\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_mask, __e, __e.size ());\t\\\n+}\n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)\n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)\n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR    \n+\n+} // extern \"C++\"\n+    \n+#endif // __MASK_ARRAY__ \n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "cf2fb283de95a69183fe9c2bcb19f1ba89f25b90", "filename": "libstdc++/std/slice.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fslice.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fslice.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fslice.h?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,76 @@\n+// The template and inlines for the -*- C++ -*- slice class.\n+\n+// Copyright (C) 1997-1999 Cygnus Solutions\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef __SLICE__\n+#define __SLICE__\n+\n+extern \"C++\" {\n+\n+class slice\n+{\n+public:\n+    slice ();\n+    slice (size_t, size_t, size_t);\n+\n+    size_t start () const;\n+    size_t size () const;\n+    size_t stride () const;\n+\n+private:\n+    size_t _M_off;                      // offset\n+    size_t _M_sz;\t\t\t// size\n+    size_t _M_st;\t\t\t// stride unit\n+};\n+\n+inline slice::slice () {}\n+\n+inline slice::slice (size_t __o, size_t __d, size_t __s)\n+        : _M_off (__o), _M_sz (__d), _M_st (__s) {}\n+\n+inline size_t\n+slice::start () const\n+  { return _M_off; }\n+\n+inline size_t\n+slice::size () const\n+  { return _M_sz; }\n+\n+inline size_t\n+slice::stride () const\n+  { return _M_st; }\n+\n+} // extern \"C++\"\n+    \n+#endif // __SLICE__\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "dc1aa34d35561819bc51bc31a2465777a5e207a7", "filename": "libstdc++/std/slice_array.h", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fslice_array.h?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,156 @@\n+// The template and inlines for the -*- C++ -*- slice_array class.\n+\n+// Copyright (C) 1997-1999 Cygnus Solutions\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef __SLICE_ARRAY__\n+#define __SLICE_ARRAY__\n+\n+extern \"C++\" {\n+\n+template<typename _T>\n+class slice_array\n+{\n+public:\n+    typedef _T value_type;\n+    \n+    void operator=   (const valarray<_T>&) const;\n+    void operator*=  (const valarray<_T>&) const;\n+    void operator/=  (const valarray<_T>&) const;\n+    void operator%=  (const valarray<_T>&) const;\n+    void operator+=  (const valarray<_T>&) const;\n+    void operator-=  (const valarray<_T>&) const;\n+    void operator^=  (const valarray<_T>&) const;\n+    void operator&=  (const valarray<_T>&) const;\n+    void operator|=  (const valarray<_T>&) const;\n+    void operator<<= (const valarray<_T>&) const;\n+    void operator>>= (const valarray<_T>&) const;\n+    void operator= (const _T &);\n+    \n+    template<class _Dom>\n+    void operator=   (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator*=  (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator/=  (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator%=  (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator+=  (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator-=  (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator^=  (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator&=  (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator|=  (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator<<= (const _Expr<_Dom,_T>&) const;\n+    template<class _Dom>\n+    void operator>>= (const _Expr<_Dom,_T>&) const;\n+    \n+private:\n+    friend class valarray<_T>;\n+    slice_array(_Array<_T>, const slice&);\n+    \n+    const size_t     _M_sz;\n+    const size_t     _M_stride;\n+    const _Array<_T> _M_array;\n+    \n+    // this constructor is implemented since we need to return a value.\n+    slice_array (const slice_array&);\n+    \n+    // not implemented\n+    slice_array ();\n+    slice_array& operator= (const slice_array&);\n+};\n+\n+template<typename _T>\n+inline slice_array<_T>::slice_array (_Array<_T> __a, const slice& __s)\n+        : _M_sz (__s.size ()), _M_stride (__s.stride ()),\n+          _M_array (__a.begin () + __s.start ()) {}\n+\n+template<typename _Tp>\n+inline slice_array<_Tp>::slice_array(const slice_array<_Tp>& a)\n+        : _M_sz(a._M_sz), _M_stride(a._M_stride), _M_array(a._M_array) {}\n+\n+template<typename _T>\n+inline void\n+slice_array<_T>::operator= (const _T& __t) \n+{ __valarray_fill (_M_array, _M_sz, _M_stride, __t); }\n+\n+template<typename _T>\n+inline void\n+slice_array<_T>::operator= (const valarray<_T>& __v) const\n+{ __valarray_copy (_Array<_T> (__v), _M_array, _M_sz, _M_stride); }\n+\n+template<typename _T>\n+template<class _Dom>\n+inline void\n+slice_array<_T>::operator= (const _Expr<_Dom,_T>& __e) const\n+{ __valarray_copy (__e, _M_sz, _M_array, _M_stride); }\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _T>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+slice_array<_T>::operator##op##= (const valarray<_T>& __v) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_sz, _M_stride, _Array<_T> (__v));\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _T> template<class _Dom>\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+slice_array<_T>::operator##op##= (const _Expr<_Dom,_T>& __e) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##name (_M_array, _M_stride, __e, _M_sz);\t\t\\\n+}\n+        \n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)\n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)\n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+\n+} // extern \"C++\"\n+    \n+#endif // __SLICE_ARRAY__\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "2ac0237141367c6052d4a72e241452a6b10b86ef", "filename": "libstdc++/std/std_valarray.h", "status": "added", "additions": 703, "deletions": 0, "changes": 703, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fstd_valarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fstd_valarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fstd_valarray.h?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,703 @@\n+// The template and inlines for the -*- C++ -*- valarray class.\n+\n+// Copyright (C) 1997-1999 Cygnus Solutions\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef __STD_VALARRAY__\n+#define __STD_VALARRAY__\n+#define _G_NO_VALARRAY_TEMPLATE_EXPORT 1\n+\n+#include <cstddef>\n+#include <cmath>\n+#include <cstdlib>\n+#include <numeric>\n+#include <functional>\n+#include <algorithm>\n+\n+#include <alloca.h>  // XXX non-standard.\n+\n+extern \"C++\" {\n+\n+template<class _Clos, typename _Tp> class _Expr;\n+\n+template<typename _Tp1, typename _Tp2> class _ValArray;    \n+\n+template<template<class> class _Oper,\n+    template<class, class> class _Meta, class _Dom> struct _UnClos;\n+\n+template<template<class> class _Oper,\n+    template<class, class> class _Meta1,\n+    template<class, class> class _Meta2,\n+    class _Dom1, class _Dom2> class _BinClos;\n+\n+template<template<class, class> class _Meta, class _Dom> class _SClos;\n+\n+template<template<class, class> class _Meta, class _Dom> class _GClos;\n+    \n+template<template<class, class> class _Meta, class _Dom> class _IClos;\n+    \n+template<template<class, class> class _Meta, class _Dom> class _ValFunClos;\n+\n+template<template<class, class> class _Meta, class _Dom> class _RefFunClos;\n+\n+template<class _Tp> struct _Unary_plus;\n+template<class _Tp> struct _Bitwise_and;\n+template<class _Tp> struct _Bitwise_or;\n+template<class _Tp> struct _Bitwise_xor;  \n+template<class _Tp> struct _Bitwise_not;\n+template<class _Tp> struct _Shift_left;\n+template<class _Tp> struct _Shift_right;\n+\n+template<class _Tp> class valarray;   // An array of type _Tp\n+class slice;                          // BLAS-like slice out of an array\n+template<class _Tp> class slice_array;\n+class gslice;                         // generalized slice out of an array\n+template<class _Tp> class gslice_array;\n+template<class _Tp> class mask_array;     // masked array\n+template<class _Tp> class indirect_array; // indirected array\n+\n+} // extern \"C++\"\n+\n+#include <std/valarray_array.h>\n+#include <std/valarray_meta.h>\n+\n+extern \"C++\" {\n+\n+template<class _Tp> class valarray\n+{\n+public:\n+    typedef _Tp value_type;\n+    \n+    // _lib.valarray.cons_ construct/destroy:\n+    valarray();\n+    explicit valarray(size_t);\n+    valarray(const _Tp&, size_t);\n+    valarray(const _Tp* __restrict__, size_t);\n+    valarray(const valarray&);\n+    valarray(const slice_array<_Tp>&);\n+    valarray(const gslice_array<_Tp>&);\n+    valarray(const mask_array<_Tp>&);\n+    valarray(const indirect_array<_Tp>&);\n+    template<class _Dom>\n+    valarray(const _Expr<_Dom,_Tp>& __e);\n+    ~valarray();\n+    \n+    // _lib.valarray.assign_ assignment:\n+    valarray<_Tp>& operator=(const valarray<_Tp>&);\n+    valarray<_Tp>& operator=(const _Tp&);\n+    valarray<_Tp>& operator=(const slice_array<_Tp>&);\n+    valarray<_Tp>& operator=(const gslice_array<_Tp>&);\n+    valarray<_Tp>& operator=(const mask_array<_Tp>&);\n+    valarray<_Tp>& operator=(const indirect_array<_Tp>&);\n+    \n+    template<class _Dom> valarray<_Tp>&\n+    operator= (const _Expr<_Dom,_Tp>&);\n+    \n+    // _lib.valarray.access_ element access:\n+    _Tp                 operator[](size_t) const;\n+    _Tp&                operator[](size_t);\t\t\n+    // _lib.valarray.sub_ subset operations:\n+    _Expr<_SClos<_ValArray,_Tp>, _Tp> operator[](slice) const;\n+    slice_array<_Tp>    operator[](slice);\n+    _Expr<_GClos<_ValArray,_Tp>, _Tp> operator[](const gslice&) const;\n+    gslice_array<_Tp>   operator[](const gslice&);\n+    valarray<_Tp>     \t operator[](const valarray<bool>&) const;\n+    mask_array<_Tp>     operator[](const valarray<bool>&);\n+    _Expr<_IClos<_ValArray, _Tp>, _Tp>\n+    operator[](const valarray<size_t>&) const;\n+    indirect_array<_Tp> operator[](const valarray<size_t>&);\n+    \n+    // _lib.valarray.unary_ unary operators:\n+    _Expr<_UnClos<_Unary_plus,_ValArray,_Tp>,_Tp>  operator+ () const;\n+    _Expr<_UnClos<negate,_ValArray,_Tp>,_Tp> operator- () const;\n+    _Expr<_UnClos<_Bitwise_not,_ValArray,_Tp>,_Tp> operator~ () const;\n+    _Expr<_UnClos<logical_not,_ValArray,_Tp>,bool> operator! () const;\n+    \n+    // _lib.valarray.cassign_ computed assignment:\n+    valarray<_Tp>& operator*= (const _Tp&);\n+    valarray<_Tp>& operator/= (const _Tp&);\n+    valarray<_Tp>& operator%= (const _Tp&);\n+    valarray<_Tp>& operator+= (const _Tp&);\n+    valarray<_Tp>& operator-= (const _Tp&);\n+    valarray<_Tp>& operator^= (const _Tp&);\n+    valarray<_Tp>& operator&= (const _Tp&);\n+    valarray<_Tp>& operator|= (const _Tp&);\n+    valarray<_Tp>& operator<<=(const _Tp&);\n+    valarray<_Tp>& operator>>=(const _Tp&);\n+    valarray<_Tp>& operator*= (const valarray<_Tp>&);\n+    valarray<_Tp>& operator/= (const valarray<_Tp>&);\n+    valarray<_Tp>& operator%= (const valarray<_Tp>&);\n+    valarray<_Tp>& operator+= (const valarray<_Tp>&);\n+    valarray<_Tp>& operator-= (const valarray<_Tp>&);\n+    valarray<_Tp>& operator^= (const valarray<_Tp>&);\n+    valarray<_Tp>& operator|= (const valarray<_Tp>&);\n+    valarray<_Tp>& operator&= (const valarray<_Tp>&);\n+    valarray<_Tp>& operator<<=(const valarray<_Tp>&);\n+    valarray<_Tp>& operator>>=(const valarray<_Tp>&);\n+\n+    template<class _Dom>\n+    valarray<_Tp>& operator*= (const _Expr<_Dom,_Tp>&);\n+    template<class _Dom>\n+       valarray<_Tp>& operator/= (const _Expr<_Dom,_Tp>&);\n+    template<class _Dom>\n+       valarray<_Tp>& operator%= (const _Expr<_Dom,_Tp>&);\n+    template<class _Dom>\n+       valarray<_Tp>& operator+= (const _Expr<_Dom,_Tp>&);\n+    template<class _Dom>\n+       valarray<_Tp>& operator-= (const _Expr<_Dom,_Tp>&);\n+    template<class _Dom>\n+       valarray<_Tp>& operator^= (const _Expr<_Dom,_Tp>&);\n+    template<class _Dom>\n+       valarray<_Tp>& operator|= (const _Expr<_Dom,_Tp>&);\n+    template<class _Dom>\n+       valarray<_Tp>& operator&= (const _Expr<_Dom,_Tp>&);\n+    template<class _Dom>\n+       valarray<_Tp>& operator<<=(const _Expr<_Dom,_Tp>&);\n+    template<class _Dom>\n+       valarray<_Tp>& operator>>=(const _Expr<_Dom,_Tp>&);\n+\n+      \n+    // _lib.valarray.members_ member functions:\n+    size_t size() const;\n+    _Tp    sum() const;\t\n+    _Tp    min() const;\t\n+    _Tp    max() const;\t\n+    \n+    // FIXME: Extension\n+    _Tp    product () const;\n+\n+    valarray<_Tp> shift (int) const;\n+    valarray<_Tp> cshift(int) const;\n+    _Expr<_ValFunClos<_ValArray,_Tp>,_Tp> apply(_Tp func(_Tp)) const;\n+    _Expr<_RefFunClos<_ValArray,_Tp>,_Tp> apply(_Tp func(const _Tp&)) const;\n+    void resize(size_t __size, _Tp __c = _Tp());\n+    \n+private:\n+    size_t _M_size;\n+    _Tp* __restrict__ _M_data;\n+\n+    friend class _Array<_Tp>;\n+};\n+\n+\n+template<typename _Tp> struct _Unary_plus : unary_function<_Tp,_Tp> {\n+    _Tp operator() (const _Tp& __t) const { return __t; }\n+};\n+\n+template<typename _Tp> struct _Bitwise_and : binary_function<_Tp,_Tp,_Tp> {\n+    _Tp operator() (_Tp __x, _Tp __y) const { return __x & __y; }\n+};\n+\n+template<typename _Tp> struct _Bitwise_or : binary_function<_Tp,_Tp,_Tp> {\n+    _Tp operator() (_Tp __x, _Tp __y) const { return __x | __y; }\n+};\n+\n+template<typename _Tp> struct _Bitwise_xor : binary_function<_Tp,_Tp,_Tp> {\n+    _Tp operator() (_Tp __x, _Tp __y) const { return __x ^ __y; }\n+};\n+\n+template<typename _Tp> struct _Bitwise_not : unary_function<_Tp,_Tp> {\n+    _Tp operator() (_Tp __t) const { return ~__t; }\n+};\n+\n+template<typename _Tp> struct _Shift_left : unary_function<_Tp,_Tp> {\n+    _Tp operator() (_Tp __x, _Tp __y) const { return __x << __y; }\n+};\n+\n+template<typename _Tp> struct _Shift_right : unary_function<_Tp,_Tp> {\n+    _Tp operator() (_Tp __x, _Tp __y) const { return __x >> __y; }\n+};\n+\n+  \n+template<typename _Tp>\n+inline _Tp\n+valarray<_Tp>::operator[] (size_t __i) const\n+{ return _M_data[__i]; }\n+\n+template<typename _Tp>\n+inline _Tp&\n+valarray<_Tp>::operator[] (size_t __i)\n+{ return _M_data[__i]; }\n+\n+} // extern \"C++\"\n+\n+#include <std/slice.h>\n+#include <std/slice_array.h>\n+#include <std/gslice.h>\n+#include <std/gslice_array.h>\n+#include <std/mask_array.h>\n+#include <std/indirect_array.h>\n+\n+extern \"C++\" {\n+\n+template<typename _Tp>\n+inline valarray<_Tp>::valarray () : _M_size (0), _M_data (0) {}\n+\n+template<typename _Tp>\n+inline valarray<_Tp>::valarray (size_t __n) \n+        : _M_size (__n), _M_data (new _Tp[__n]) {}\n+\n+template<typename _Tp>\n+inline valarray<_Tp>::valarray (const _Tp& __t, size_t __n)\n+        : _M_size (__n), _M_data (new _Tp[__n])\n+{ __valarray_fill (_M_data, _M_size, __t); }\n+\n+template<typename _Tp>\n+inline valarray<_Tp>::valarray (const _Tp* __restrict__ __pT, size_t __n)\n+        : _M_size (__n), _M_data (new _Tp[__n])\n+{ __valarray_copy (__pT, __n, _M_data); }\n+\n+template<typename _Tp>\n+inline valarray<_Tp>::valarray (const valarray<_Tp>& __v)\n+        : _M_size (__v._M_size), _M_data (new _Tp[__v._M_size])\n+{ __valarray_copy (__v._M_data, _M_size, _M_data); }\n+\n+template<typename _Tp>\n+inline valarray<_Tp>::valarray (const slice_array<_Tp>& __sa)\n+        : _M_size (__sa._M_sz), _M_data (new _Tp[__sa._M_sz])\n+{ __valarray_copy (__sa._M_array, __sa._M_sz, __sa._M_stride,\n+                   _Array<_Tp>(_M_data)); }\n+\n+template<typename _Tp>\n+inline valarray<_Tp>::valarray (const gslice_array<_Tp>& __ga)\n+        : _M_size (__ga._M_index.size()), _M_data (new _Tp[_M_size])\n+{ __valarray_copy (__ga._M_array, _Array<size_t>(__ga._M_index), \n+                   _Array<_Tp>(_M_data), _M_size); }\n+\n+template<typename _Tp>\n+inline valarray<_Tp>::valarray (const mask_array<_Tp>& __ma)\n+        : _M_size (__ma._M_sz), _M_data (new _Tp[__ma._M_sz])\n+{ __valarray_copy (__ma._M_array, __ma._M_mask,\n+                   _Array<_Tp>(_M_data), _M_size); }\n+\n+template<typename _Tp>\n+inline valarray<_Tp>::valarray (const indirect_array<_Tp>& __ia)\n+        : _M_size (__ia._M_sz), _M_data (new _Tp[__ia._M_sz])\n+{ __valarray_copy (__ia._M_array, __ia._M_index, \n+                   _Array<_Tp>(_M_data), _M_size); }\n+\n+template<typename _Tp> template<class _Dom>\n+inline valarray<_Tp>::valarray (const _Expr<_Dom, _Tp>& __e)\n+        : _M_size (__e.size ()), _M_data (new _Tp[_M_size])\n+{ __valarray_copy (__e, _M_size, _Array<_Tp>(_M_data)); }\n+\n+template<typename _Tp>\n+inline valarray<_Tp>::~valarray () { delete[] _M_data; }\n+\n+template<typename _Tp>\n+inline valarray<_Tp>&\n+valarray<_Tp>::operator= (const valarray<_Tp>& __v)\n+{\n+    __valarray_copy(__v._M_data, _M_size, _M_data);\n+    return *this;\n+}\n+\n+template<typename _Tp>\n+inline valarray<_Tp>&\n+valarray<_Tp>::operator= (const _Tp& __t)\n+{\n+    __valarray_fill (_M_data, _M_size, __t);\n+    return *this;\n+}\n+\n+template<typename _Tp>\n+inline valarray<_Tp>&\n+valarray<_Tp>::operator= (const slice_array<_Tp>& __sa)\n+{\n+    __valarray_copy (__sa._M_array, __sa._M_sz,\n+                     __sa._M_stride, _Array<_Tp>(_M_data));\n+    return *this;\n+}\n+\n+template<typename _Tp>\n+inline valarray<_Tp>&\n+valarray<_Tp>::operator= (const gslice_array<_Tp>& __ga)\n+{\n+    __valarray_copy (__ga._M_array, _Array<size_t>(__ga._M_index),\n+                     _Array<_Tp>(_M_data), _M_size);\n+    return *this;\n+}\n+\n+template<typename _Tp>\n+inline valarray<_Tp>&\n+valarray<_Tp>::operator= (const mask_array<_Tp>& __ma)\n+{\n+    __valarray_copy (__ma._M_array, __ma._M_mask,\n+                     _Array<_Tp>(_M_data), _M_size);\n+    return *this;\n+}\n+\n+template<typename _Tp>\n+inline valarray<_Tp>&\n+valarray<_Tp>::operator= (const indirect_array<_Tp>& __ia)\n+{\n+    __valarray_copy (__ia._M_array, __ia._M_index,\n+                     _Array<_Tp>(_M_data), _M_size);\n+    return *this;\n+}\n+\n+template<typename _Tp> template<class _Dom>\n+inline valarray<_Tp>&\n+valarray<_Tp>::operator= (const _Expr<_Dom, _Tp>& __e)\n+{\n+    __valarray_copy (__e, _M_size, _Array<_Tp>(_M_data));\n+    return *this;\n+}\n+\n+template<typename _Tp>\n+inline _Expr<_SClos<_ValArray,_Tp>, _Tp>\n+valarray<_Tp>::operator[] (slice __s) const\n+{\n+    typedef _SClos<_ValArray,_Tp> _Closure;\n+    return _Expr<_Closure, _Tp> (_Closure (_Array<_Tp>(_M_data), __s));\n+}\n+\n+template<typename _Tp>\n+inline slice_array<_Tp>\n+valarray<_Tp>::operator[] (slice __s)\n+{\n+    return slice_array<_Tp> (_Array<_Tp>(_M_data), __s);\n+}\n+\n+template<typename _Tp>\n+inline _Expr<_GClos<_ValArray,_Tp>, _Tp>\n+valarray<_Tp>::operator[] (const gslice& __gs) const\n+{\n+    typedef _GClos<_ValArray,_Tp> _Closure;\n+    return _Expr<_Closure, _Tp>\n+        (_Closure (_Array<_Tp>(_M_data), __gs._M_index->_M_index));\n+}\n+\n+template<typename _Tp>\n+inline gslice_array<_Tp>\n+valarray<_Tp>::operator[] (const gslice& __gs)\n+{\n+    return gslice_array<_Tp>\n+        (_Array<_Tp>(_M_data), __gs._M_index->_M_index);\n+}\n+\n+template<typename _Tp>\n+inline valarray<_Tp>\n+valarray<_Tp>::operator[] (const valarray<bool>& __m) const\n+{\n+    size_t __s (0);\n+    size_t __e (__m.size ());\n+    for (size_t __i=0; __i<__e; ++__i)\n+        if (__m[__i]) ++__s;\n+    return valarray<_Tp> (mask_array<_Tp> (_Array<_Tp>(_M_data), __s,\n+                                           _Array<bool> (__m)));\n+}\n+\n+template<typename _Tp>\n+inline mask_array<_Tp>\n+valarray<_Tp>::operator[] (const valarray<bool>& __m)\n+{\n+    size_t __s (0);\n+    size_t __e (__m.size ());\n+    for (size_t __i=0; __i<__e; ++__i)\n+        if (__m[__i]) ++__s;\n+    return mask_array<_Tp> (_Array<_Tp>(_M_data), __s, _Array<bool> (__m));\n+}\n+\n+template<typename _Tp>\n+inline _Expr<_IClos<_ValArray,_Tp>, _Tp>\n+valarray<_Tp>::operator[] (const valarray<size_t>& __i) const\n+{\n+    typedef _IClos<_ValArray,_Tp> _Closure;\n+    return _Expr<_Closure, _Tp> (_Closure (*this, __i));\n+}\n+\n+template<typename _Tp>\n+inline indirect_array<_Tp>\n+valarray<_Tp>::operator[] (const valarray<size_t>& __i)\n+{\n+    return indirect_array<_Tp> (_Array<_Tp>(_M_data), __i.size(),\n+                                _Array<size_t> (__i));\n+}\n+\n+template<class _Tp>\n+inline size_t valarray<_Tp>::size () const { return _M_size; }\n+\n+template<class _Tp>\n+inline _Tp\n+valarray<_Tp>::sum () const\n+{\n+    return accumulate (_M_data, _M_data + _M_size, _Tp ());\n+}\n+\n+template<typename _Tp>\n+inline _Tp\n+valarray<_Tp>::product () const\n+{\n+    return accumulate (_M_data, _M_data+_M_size, _Tp(1), multiplies<_Tp> ());\n+}\n+\n+template <class _Tp>\n+inline valarray<_Tp>\n+valarray<_Tp>::shift (int __n) const\n+{\n+    _Tp* const __a = static_cast<_Tp*> (alloca (sizeof(_Tp) * _M_size));\n+    if (! __n)                          // __n == 0: no shift\n+        __valarray_copy (_M_data, _M_size, __a);\n+    else if (__n > 0) {                  // __n > 0: shift left\n+        if (__n > _M_size)\n+            __valarray_fill(__a, __n, _Tp());\n+        else {\n+            __valarray_copy (_M_data+__n, _M_size-__n, __a);\n+            __valarray_fill (__a+_M_size-__n, __n, _Tp());\n+        }\n+    }\n+    else {                             // __n < 0: shift right\n+        __valarray_copy (_M_data, _M_size+__n, __a-__n);\n+        __valarray_fill(__a, -__n, _Tp());\n+    }\n+    return valarray<_Tp> (__a, _M_size);\n+}\n+\n+template <class _Tp>\n+inline valarray<_Tp>\n+valarray<_Tp>::cshift (int __n) const\n+{\n+    _Tp* const __a = static_cast<_Tp*> (alloca (sizeof(_Tp) * _M_size));\n+    if (! __n)                          // __n == 0: no cshift\n+        __valarray_copy(_M_data, _M_size, __a);\n+    else if (__n > 0) {                 // __n > 0: cshift left\n+        __valarray_copy (_M_data, __n, __a + _M_size-__n);\n+        __valarray_copy (_M_data + __n, _M_size-__n, __a);\n+    }\n+    else {                            // __n < 0: cshift right\n+        __valarray_copy (_M_data + _M_size + __n, -__n, __a);\n+        __valarray_copy (_M_data, _M_size + __n, __a - __n);\n+    }\n+    return valarray<_Tp> (__a, _M_size);\n+}\n+\n+template <class _Tp>\n+inline void\n+valarray<_Tp>::resize (size_t __n, _Tp __c)\n+{\n+    if (_M_size != __n) {\n+        delete[] _M_data;\n+        _M_size = __n;\n+        _M_data = new _Tp[_M_size];\n+    }\n+    __valarray_fill (_M_data, _M_size, __c);\n+}\n+\n+template<typename _Tp>\n+inline _Tp\n+valarray<_Tp>::min() const\n+{\n+    return *min_element (_M_data, _M_data+_M_size);\n+}\n+\n+template<typename _Tp>\n+inline _Tp\n+valarray<_Tp>::max() const\n+{\n+    return *max_element (_M_data, _M_data+_M_size);\n+}\n+\n+template<class _Tp>\n+inline _Expr<_ValFunClos<_ValArray,_Tp>,_Tp>\n+valarray<_Tp>::apply (_Tp func (_Tp)) const\n+{\n+    typedef _ValFunClos<_ValArray,_Tp> _Closure;\n+    return _Expr<_Closure,_Tp> (_Closure (*this, func));\n+}\n+\n+template<class _Tp>\n+inline _Expr<_RefFunClos<_ValArray,_Tp>,_Tp>\n+valarray<_Tp>::apply (_Tp func (const _Tp &)) const\n+{\n+    typedef _RefFunClos<_ValArray,_Tp> _Closure;\n+    return _Expr<_Closure,_Tp> (_Closure (*this, func));\n+}\n+\n+#define _DEFINE_VALARRAY_UNARY_OPERATOR(_Op, _Name)                     \\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+  inline _Expr<_UnClos<_Name,_ValArray,_Tp>, _Tp>               \t\\\n+  valarray<_Tp>::operator##_Op() const\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+      typedef _UnClos<_Name,_ValArray,_Tp> _Closure;\t                \\\n+      return _Expr<_Closure, _Tp> (_Closure (*this));\t\t\t\\\n+  }\n+\n+    _DEFINE_VALARRAY_UNARY_OPERATOR(+, _Unary_plus)\n+    _DEFINE_VALARRAY_UNARY_OPERATOR(-, negate)\n+    _DEFINE_VALARRAY_UNARY_OPERATOR(~, _Bitwise_not)\n+\n+#undef _DEFINE_VALARRAY_UNARY_OPERATOR\n+  \n+  template<typename _Tp>\n+  inline _Expr<_UnClos<logical_not,_ValArray,_Tp>, bool>\n+  valarray<_Tp>::operator!() const\n+  {\n+      typedef _UnClos<logical_not,_ValArray,_Tp> _Closure;\n+      return _Expr<_Closure, bool> (_Closure (*this));\n+  }\n+\n+#define _DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(_Op, _Name)               \\\n+  template<class _Tp>\t\t\t\t\t\t\t\\\n+  inline valarray<_Tp> &\t\t\t\t\t\t\\\n+  valarray<_Tp>::operator##_Op##= (const _Tp &__t)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+      _Array_augmented_##_Name (_Array<_Tp>(_M_data), _M_size, __t);\t\\\n+      return *this;\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template<class _Tp>\t\t\t\t\t\t\t\\\n+  inline valarray<_Tp> &\t\t\t\t\t\t\\\n+  valarray<_Tp>::operator##_Op##= (const valarray<_Tp> &__v)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+      _Array_augmented_##_Name (_Array<_Tp>(_M_data), _M_size, \t\t\\\n+                               _Array<_Tp>(__v._M_data));\t\t\\\n+      return *this;\t\t\t\t\t\t\t\\\n+  }\n+\n+_DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(+, plus)\n+_DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(-, minus)\n+_DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(*, multiplies)\n+_DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(/, divides)\n+_DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(%, modulus)\n+_DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(^, xor)\n+_DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(&, and)\n+_DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(|, or)\n+_DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(<<, shift_left)\n+_DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT\n+\n+\n+#define _DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(_Op, _Name)          \\\n+  template<class _Tp> template<class _Dom>\t\t\t\t\\\n+  inline valarray<_Tp> &\t\t\t\t\t\t\\\n+  valarray<_Tp>::operator##_Op##= (const _Expr<_Dom,_Tp> &__e)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+      _Array_augmented_##_Name (_Array<_Tp>(_M_data), __e, _M_size);\t\\\n+      return *this;\t\t\t\t\t\t\t\\\n+  }\n+\n+_DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(+, plus)\n+_DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(-, minus)\n+_DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(*, multiplies)\n+_DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(/, divides)\n+_DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(%, modulus)\n+_DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(^, xor)\n+_DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(&, and)\n+_DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(|, or)\n+_DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(<<, shift_left)\n+_DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT\n+    \n+\n+#define _DEFINE_BINARY_OPERATOR(_Op, _Name)\t\t\t\t\\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+  inline _Expr<_BinClos<_Name,_ValArray,_ValArray,_Tp,_Tp>, _Tp>        \\\n+  operator##_Op (const valarray<_Tp> &__v, const valarray<_Tp> &__w)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+      typedef _BinClos<_Name,_ValArray,_ValArray,_Tp,_Tp> _Closure;     \\\n+      return _Expr<_Closure, _Tp> (_Closure (__v, __w));\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+  inline _Expr<_BinClos<_Name,_ValArray,_Constant,_Tp,_Tp>,_Tp>         \\\n+  operator##_Op (const valarray<_Tp> &__v, const _Tp &__t)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+      typedef _BinClos<_Name,_ValArray,_Constant,_Tp,_Tp> _Closure;\t\\\n+      return _Expr<_Closure, _Tp> (_Closure (__v, __t));\t        \\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+  inline _Expr<_BinClos<_Name,_Constant,_ValArray,_Tp,_Tp>,_Tp>         \\\n+  operator##_Op (const _Tp &__t, const valarray<_Tp> &__v)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+      typedef _BinClos<_Name,_Constant,_ValArray,_Tp,_Tp> _Closure;     \\\n+      return _Expr<_Closure, _Tp> (_Closure (__t, __v));        \t\\\n+  }\n+\n+_DEFINE_BINARY_OPERATOR(+, plus)\n+_DEFINE_BINARY_OPERATOR(-, minus)\n+_DEFINE_BINARY_OPERATOR(*, multiplies)\n+_DEFINE_BINARY_OPERATOR(/, divides)\n+_DEFINE_BINARY_OPERATOR(%, modulus)\n+_DEFINE_BINARY_OPERATOR(^, _Bitwise_xor)\n+_DEFINE_BINARY_OPERATOR(&, _Bitwise_and)\n+_DEFINE_BINARY_OPERATOR(|, _Bitwise_or)\n+_DEFINE_BINARY_OPERATOR(<<, _Shift_left)\n+_DEFINE_BINARY_OPERATOR(>>, _Shift_right)\n+\n+#undef _DEFINE_BINARY_OPERATOR\n+\n+#define _DEFINE_LOGICAL_OPERATOR(_Op, _Name)\t\t\t\t\\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+  inline _Expr<_BinClos<_Name,_ValArray,_ValArray,_Tp,_Tp>,bool>        \\\n+  operator##_Op (const valarray<_Tp> &__v, const valarray<_Tp> &__w)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+      typedef _BinClos<_Name,_ValArray,_ValArray,_Tp,_Tp> _Closure;     \\\n+      return _Expr<_Closure, bool> (_Closure (__v, __w));               \\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template<class _Tp>\t\t\t\t\t\t\t\\\n+  inline _Expr<_BinClos<_Name,_ValArray,_Constant,_Tp,_Tp>,bool>        \\\n+  operator##_Op (const valarray<_Tp> &__v, const _Tp &__t)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+      typedef _BinClos<_Name,_ValArray,_Constant,_Tp,_Tp> _Closure;     \\\n+      return _Expr<_Closure, bool> (_Closure (__v, __t));       \t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template<class _Tp>\t\t\t\t\t\t\t\\\n+  inline _Expr<_BinClos<_Name,_Constant,_ValArray,_Tp,_Tp>,bool>        \\\n+  operator##_Op (const _Tp &__t, const valarray<_Tp> &__v)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+      typedef _BinClos<_Name,_Constant,_ValArray,_Tp,_Tp> _Closure;     \\\n+      return _Expr<_Closure, bool> (_Closure (__t, __v));\t        \\\n+  }\n+\n+_DEFINE_LOGICAL_OPERATOR(&&, logical_and)\n+_DEFINE_LOGICAL_OPERATOR(||, logical_or)\n+_DEFINE_LOGICAL_OPERATOR(==, equal_to)\n+_DEFINE_LOGICAL_OPERATOR(!=, not_equal_to)\n+_DEFINE_LOGICAL_OPERATOR(<, less)\n+_DEFINE_LOGICAL_OPERATOR(>, greater)\n+_DEFINE_LOGICAL_OPERATOR(<=, less_equal)\n+_DEFINE_LOGICAL_OPERATOR(>=, greater_equal)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+\n+#undef _G_NO_VALARRAY_TEMPLATE_EXPORT\n+\n+} // extern \"C++\"\n+\n+#endif // __STD_VALARRAY__\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "f711e52a1650e7088f868adf331600fa024c861e", "filename": "libstdc++/std/valarray_array.h", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fvalarray_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fvalarray_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fvalarray_array.h?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,346 @@\n+// The template and inlines for the -*- C++ -*- internal _Array helper class.\n+\n+// Copyright (C) 1997-1999 Cygnus Solutions\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef __VALARRAY_ARRAY__\n+#define __VALARRAY_ARRAY__\n+\n+#include <cstdlib>\n+#include <cstring>\n+\n+extern \"C++\" {\n+\n+//\n+// Helper functions on raw pointers\n+//\n+\n+// fill plain array __a[<__n>] with __t\n+template<typename _Tp>\n+inline void\n+__valarray_fill (_Tp* __restrict__ __a, size_t __n, const _Tp& __t)\n+{ while (__n--) *__a++ = __t; }\n+\n+// fill strided array __a[<__n-1 : __s>] with __t\n+template<typename _Tp>\n+inline void\n+__valarray_fill (_Tp* __restrict__ __a, size_t __n,\n+                 size_t __s, const _Tp& __t)\n+{ for (size_t __i=0; __i<__n; ++__i, __a+=__s) *__a = __t; }\n+\n+// fill indirect array __a[__i[<__n>]] with __i\n+template<typename _Tp>\n+inline void\n+__valarray_fill(_Tp* __restrict__ __a, const size_t* __restrict__ __i,\n+                size_t __n, const _Tp& __t)\n+{ for (size_t __j=0; __j<__n; ++__j, ++__i) __a[*__i] = __t; }\n+\n+// copy plain array __a[<__n>] in __b[<__n>]\n+template<typename _Tp>\n+inline void\n+__valarray_copy (const _Tp* __restrict__ __a, size_t __n,\n+                 _Tp* __restrict__ __b)\n+{ memcpy (__b, __a, __n * sizeof(_Tp)); }\n+\n+// copy strided array __a[<__n : __s>] in plain __b[<__n>]\n+template<typename _Tp>\n+inline void\n+__valarray_copy (const _Tp* __restrict__ __a, size_t __n, size_t __s,\n+                 _Tp* __restrict__ __b)\n+{ for (size_t __i=0; __i<__n; ++__i, ++__b, __a += __s) *__b += *__a; }\n+\n+// copy plain __a[<__n>] in strided __b[<__n : __s>]\n+template<typename _Tp>\n+inline void\n+__valarray_copy (const _Tp* __restrict__ __a, _Tp* __restrict__ __b,\n+                 size_t __n, size_t __s)\n+{ for (size_t __i=0; __i<__n; ++__i, ++__a, __b+=__s) *__b = *__a; }\n+\n+// copy indexed __a[__i[<__n>]] in plain __b[<__n>]\n+template<typename _Tp>\n+inline void\n+__valarray_copy (const _Tp* __restrict__ __a,\n+                 const size_t* __restrict__ __i,\n+                 _Tp* __restrict__ __b, size_t __n)\n+{ for (size_t __j=0; __j<__n; ++__j, ++__b, ++__i) *__b = __a[*__i]; }\n+\n+// copy plain __a[<__n>] in indexed __b[__i[<__n>]]\n+template<typename _Tp>\n+inline void\n+__valarray_copy (const _Tp* __restrict__ __a, size_t __n,\n+                 _Tp* __restrict__ __b, const size_t* __restrict__ __i)\n+{ for (size_t __j=0; __j<__n; ++__j, ++__a, ++__i) __b[*__i] = *__a; }\n+\n+//\n+// Helper class _Array, first layer of valarray abstraction.\n+// All operations on valarray should be forwarded to this class\n+// whenever possible. -- gdr\n+//\n+\n+template<typename _Tp> struct _Array {\n+    \n+    explicit _Array (size_t);\n+    explicit _Array (_Tp* const __restrict__);\n+    explicit _Array (const valarray<_Tp>&);\n+    _Array (const _Tp* __restrict__, size_t);\n+    \n+    void free_data() const;\n+    _Tp* begin () const;\n+    \n+    _Tp* const __restrict__ _M_data;\n+};\n+\n+template<typename _Tp>\n+inline void\n+__valarray_fill (_Array<_Tp> __a, size_t __n, const _Tp& __t)\n+{ __valarray_fill (__a._M_data, __n, __t); }\n+\n+template<typename _Tp>\n+inline void\n+__valarray_fill (_Array<_Tp> __a, size_t __n, size_t __s, const _Tp& __t)\n+{ __valarray_fill (__a._M_data, __n, __s, __t); }\n+\n+template<typename _Tp>\n+inline void\n+__valarray_fill (_Array<_Tp> __a, _Array<size_t> __i, \n+                 size_t __n, const _Tp& __t)\n+{ __valarray_fill (__a._M_data, __i._M_data, __n, __t); }\n+\n+template<typename _Tp>\n+inline void\n+__valarray_copy (_Array<_Tp> __a, size_t __n, _Array<_Tp> __b)\n+{ __valarray_copy (__a._M_data, __n, __b._M_data); }\n+\n+template<typename _Tp>\n+inline void\n+__valarray_copy (_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b)\n+{ __valarray_copy(__a._M_data, __n, __s, __b._M_data); }\n+\n+template<typename _Tp>\n+inline void\n+__valarray_copy (_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s)\n+{ __valarray_copy (__a._M_data, __b._M_data, __n, __s); }\n+\n+template<typename _Tp>\n+inline void\n+__valarray_copy (_Array<_Tp> __a, _Array<size_t> __i, \n+                 _Array<_Tp> __b, size_t __n)\n+{ __valarray_copy (__a._M_data, __i._M_data, __b._M_data, __n); }\n+\n+template<typename _Tp>\n+inline void\n+__valarray_copy (_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, \n+                 _Array<size_t> __i)\n+{ __valarray_copy (__a._M_data, __n, __b._M_data, __i._M_data); }\n+\n+template<typename _Tp>\n+inline\n+_Array<_Tp>::_Array (size_t __n) : _M_data (new _Tp[__n]) {}\n+\n+template<typename _Tp>\n+inline\n+_Array<_Tp>::_Array (_Tp* const __restrict__ __p) : _M_data (__p) {}\n+\n+template<typename _Tp>\n+inline _Array<_Tp>::_Array (const valarray<_Tp>& __v) \n+        : _M_data (__v._M_data) {}\n+\n+template<typename _Tp>\n+inline\n+_Array<_Tp>::_Array (const _Tp* __restrict__ __b, size_t __s) \n+        : _M_data (new _Tp[__s]) { __valarray_copy (__b, __s, _M_data); }\n+\n+template<typename _Tp>\n+inline void\n+_Array<_Tp>::free_data() const { delete[] _M_data; }\n+\n+template<typename _Tp>\n+inline _Tp*\n+_Array<_Tp>::begin () const\n+{ return _M_data; }\n+\n+#define _DEFINE_ARRAY_FUNCTION(_Op, _Name)\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, size_t __n, const _Tp& __t)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    for (_Tp* __p=__a._M_data; __p<__a._M_data+__n; ++__p) \t\t\\\n+      *__p _Op##= __t;\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, size_t __n, _Array<_Tp> __b)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Tp* __p (__a._M_data);\t\t\t\t\t\t\\\n+    for (_Tp* __q=__b._M_data; __q<__b._M_data+__n; ++__p, ++__q) \t\\\n+      *__p _Op##= *__q;\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp, class _Dom>\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, \t\t\t\t\\\n+                         const _Expr<_Dom,_Tp>& __e, size_t __n)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Tp* __p (__a._M_data);\t\t\t\t\t\t\\\n+    for (size_t __i=0; __i<__n; ++__i, ++__p) *__p _Op##= __e[__i];\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, size_t __n, size_t __s, \t\\\n+\t\t\t _Array<_Tp> __b)\t\t\t\t\\\n+{\t\t\t\t\t       \t\t\t\t\\\n+    _Tp* __q (__b._M_data);\t\t\t\t\t\t\\\n+    for (_Tp* __p=__a._M_data; __p<__a._M_data+__s*__n; __p+=__s, ++__q) \\\n+      *__p _Op##= *__q;\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, _Array<_Tp> __b, \t\t\\\n+\t\t\t size_t __n, size_t __s)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Tp* __q (__b._M_data);\t\t\t\t\t\t\\\n+    for (_Tp* __p=__a._M_data; __p<__a._M_data+__n; ++__p, __q+=__s)\t\\\n+      *__p _Op##= *__q;\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp, class _Dom>\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, size_t __s,\t\t\t\\\n+                          const _Expr<_Dom,_Tp>& __e, size_t __n)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Tp* __p (__a._M_data);\t\t\t\t\t\t\\\n+    for (size_t __i=0; __i<__n; ++__i, __p+=__s) *__p _Op##= __e[__i];\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, _Array<size_t> __i,\t\t\\\n+                          _Array<_Tp> __b, size_t __n)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Tp* __q (__b._M_data);\t\t\t\t\t\t\\\n+    for (size_t* __j=__i._M_data; __j<__i._M_data+__n; ++__j, ++__q)\t\\\n+        __a._M_data[*__j] _Op##= *__q;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, size_t __n,\t\t\t\\\n+                          _Array<_Tp> __b, _Array<size_t> __i)\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Tp* __p (__a._M_data);\t\t\t\t\t\t\\\n+    for (size_t* __j=__i._M_data; __j<__i._M_data+__n; ++__j, ++__p)\t\\\n+        *__p _Op##= __b._M_data[*__j];\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp, class _Dom>\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, _Array<size_t> __i,\t\t\\\n+                          const _Expr<_Dom, _Tp>& __e, size_t __n)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    size_t* __j (__i._M_data);\t\t\t\t\t\t\\\n+    for (size_t __k=0; __k<__n; ++__k, ++__j) \t\t\t\t\\\n+      __a._M_data[*__j] _Op##= __e[__k];\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, _Array<bool> __m,\t\t\\\n+                          _Array<_Tp> __b, size_t __n)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    bool* ok (__m._M_data);\t\t\t\t\t\t\\\n+    _Tp* __p (__a._M_data);\t\t\t\t\t\t\\\n+    for (_Tp* __q=__b._M_data; __q<__b._M_data+__n; ++__q, ++ok, ++__p) { \\\n+        while (! *ok) {\t\t\t\t\t\t\t\\\n+            ++ok;\t\t\t\t\t\t\t\\\n+            ++__p;\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+        *__p _Op##= *__q;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, size_t __n,\t\t\t\\\n+                         _Array<_Tp> __b, _Array<bool> __m)\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    bool* ok (__m._M_data);\t\t\t\t\t\t\\\n+    _Tp* __q (__b._M_data);\t\t\t\t\t\t\\\n+    for (_Tp* __p=__a._M_data; __p<__a._M_data+__n; ++__p, ++ok, ++__q) { \\\n+        while (! *ok) {\t\t\t\t\t\t\t\\\n+            ++ok;\t\t\t\t\t\t\t\\\n+            ++__q;\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+        *__p _Op##= *__q;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp, class _Dom>\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+_Array_augmented_##_Name (_Array<_Tp> __a, _Array<bool> __m,\t\t\\\n+                          const _Expr<_Dom, _Tp>& __e, size_t __n)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    bool* ok(__m._M_data);\t\t\t\t\t\t\\\n+    _Tp* __p (__a._M_data);\t\t\t\t\t\t\\\n+    for (size_t __i=0; __i<__n; ++__i, ++ok, ++__p) {\t\t\t\\\n+        while (! *ok) {\t\t\t\t\t\t\t\\\n+            ++ok;\t\t\t\t\t\t\t\\\n+            ++__p;\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+        *__p _Op##= __e[__i];\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+_DEFINE_ARRAY_FUNCTION(+, plus)\n+_DEFINE_ARRAY_FUNCTION(-, minus)\n+_DEFINE_ARRAY_FUNCTION(*, multiplies)\n+_DEFINE_ARRAY_FUNCTION(/, divides)\n+_DEFINE_ARRAY_FUNCTION(%, modulus)\n+_DEFINE_ARRAY_FUNCTION(^, xor)\n+_DEFINE_ARRAY_FUNCTION(|, or)\n+_DEFINE_ARRAY_FUNCTION(&, and)    \n+_DEFINE_ARRAY_FUNCTION(<<, shift_left)\n+_DEFINE_ARRAY_FUNCTION(>>, shift_right)\n+\n+#undef _DEFINE_ARRAY_FUNCTION    \n+\n+} // extern \"C++\"\n+    \n+#ifdef _G_NO_VALARRAY_TEMPLATE_EXPORT\n+# define export \n+# include <std/valarray_array.tcc>    \n+#endif\n+           \n+#endif // __VALARRAY_ARRAY__\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "bd6692571fdd551bac0e7b8f116db14466f8b23c", "filename": "libstdc++/std/valarray_array.tcc", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fvalarray_array.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fvalarray_array.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fvalarray_array.tcc?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,130 @@\n+// The template and inlines for the -*- C++ -*- internal _Array helper class.\n+\n+// Copyright (C) 1997-1999 Cygnus Solutions\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef __VALARRAY_ARRAY_TCC__\n+#define __VALARRAY_ARRAY_TCC__\n+\n+extern \"C++\" {\n+\n+export template<typename _Tp>\n+void\n+__valarray_fill (_Array<_Tp> __a, size_t __n, _Array<bool> __m, const _Tp& __t)\n+{\n+    _Tp* __p = __a._M_data;\n+    bool* __ok (__m._M_data);\n+    for (size_t __i=0; __i<__n; ++__i, ++__ok, ++__p) {\n+        while (! *__ok) {\n+            ++__ok;\n+            ++__p;\n+        }\n+        *__p = __t;\n+    }\n+}\n+\n+export template<typename _Tp>\n+void\n+__valarray_copy (_Array<_Tp> __a, _Array<bool> __m, _Array<_Tp> __b, size_t __n)\n+{\n+    _Tp* __p (__a._M_data);\n+    bool* __ok (__m._M_data);\n+    for (_Tp* __q=__b._M_data; __q<__b._M_data+__n; ++__q, ++__ok, ++__p) {\n+        while (! *__ok) {\n+            ++__ok;\n+            ++__p;\n+        }\n+        *__q = *__p;\n+    }\n+}\n+\n+export template<typename _Tp>\n+void\n+__valarray_copy (_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, _Array<bool> __m)\n+{\n+    _Tp* __q (__b._M_data);\n+    bool* __ok (__m._M_data);\n+    for (_Tp* __p=__a._M_data; __p<__a._M_data+__n; ++__p, ++__ok, ++__q) {\n+        while (! *__ok) {\n+            ++__ok;\n+            ++__q;\n+        }\n+        *__q = *__p;\n+    }\n+}\n+\n+export template<typename _Tp, class _Dom>\n+void\n+__valarray_copy (const _Expr<_Dom, _Tp>& __e, size_t __n, _Array<_Tp> __a)\n+{\n+    _Tp* __p (__a._M_data);\n+    for (size_t __i=0; __i<__n; ++__i, ++__p) *__p = __e[__i];\n+}\n+\n+export template<typename _Tp, class _Dom>\n+void\n+__valarray_copy (const _Expr<_Dom, _Tp>& __e, size_t __n, \n+                 _Array<_Tp> __a, size_t __s)\n+{\n+    _Tp* __p (__a._M_data);\n+    for (size_t __i=0; __i<__n; ++__i, __p+=__s) *__p = __e[__i];\n+}\n+\n+export template<typename _Tp, class _Dom>\n+void\n+__valarray_copy (const _Expr<_Dom, _Tp>& __e, size_t __n, \n+                 _Array<_Tp> __a, _Array<size_t> __i)\n+{\n+    size_t* __j (__i._M_data);\n+    for (size_t __k=0; __k<__n; ++__k, ++__j) __a._M_data[*__j] = __e[__k];\n+}\n+\n+export template<typename _Tp, class _Dom>\n+void\n+__valarray_copy (const _Expr<_Dom, _Tp>& __e, size_t __n, \n+                 _Array<_Tp> __a, _Array<bool> __m)\n+{\n+    bool* __ok (__m._M_data);\n+    _Tp* __p (__a._M_data);\n+    for (size_t __i=0; __i<__n; ++__i, ++__ok, ++__p) {\n+        while (! *__ok) {\n+            ++__ok;\n+            ++__p;\n+        }\n+        *__p = __e[__i];\n+    }\n+}\n+\n+} // extern \"C++\"\n+\n+#endif // __VALARRAY_ARRAY_TCC__\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "f799111c7bcc1c7dc30335b067387258e5f26dd0", "filename": "libstdc++/std/valarray_meta.h", "status": "added", "additions": 1045, "deletions": 0, "changes": 1045, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fvalarray_meta.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fstd%2Fvalarray_meta.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstd%2Fvalarray_meta.h?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,1045 @@\n+// The template and inlines for the -*- C++ -*- internal _Meta class.\n+\n+// Copyright (C) 1997-1999 Cygnus Solutions\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@cmla.ens-cachan.fr>\n+\n+#ifndef _CPP_VALARRAY_META_H\n+#define _CPP_VALARRAY_META_H 1\n+\n+//\n+// Implementing a loosened valarray return value is tricky.\n+// First we need to meet 26.3.1/3: we should not add more than\n+// two levels of template nesting. Therefore we resort to template\n+// template to \"flatten\" loosened return value types.\n+// At some point we use partial specialization to remove one level\n+// template nesting due to _Expr<>\n+//\n+    \n+\n+// This class is NOT defined. It doesn't need to.\n+template<typename _Tp1, typename _Tp2> class _Constant;\n+\n+//\n+// Unary function application closure.\n+//\n+template<class _Dom> class _UnFunBase {\n+public:\n+    typedef typename _Dom::value_type value_type;\n+    typedef value_type _Vt;\n+    \n+    _UnFunBase (const _Dom& __e, _Vt __f(_Vt))\n+            : _M_expr(__e), _M_func(__f) {}\n+    \n+    _Vt operator[] (size_t __i) const { return _M_func(_M_expr[__i]); }\n+    size_t size () const { return _M_expr.size(); }\n+    \n+private:\n+    const _Dom& _M_expr;\n+    _Vt (*_M_func)(_Vt);\n+};\n+\n+template<template<class, class> class _Meta, class _Dom> class _UnFunClos;\n+\n+template<class _Dom>\n+struct _UnFunClos<_Expr,_Dom> : _UnFunBase<_Dom> {\n+    typedef _UnFunBase<_Dom> _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _UnFunClos (const _Dom& __e, value_type __f(value_type))\n+            : _Base (__e, __f) {}\n+};\n+\n+template<typename _Tp>\n+struct _UnFunClos<_ValArray,_Tp> : _UnFunBase<valarray<_Tp> > {\n+    typedef _UnFunBase<valarray<_Tp> > _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _UnFunClos (const valarray<_Tp>& __v, _Tp __f(_Tp))\n+            : _Base (__v, __f) {}\n+};\n+\n+//\n+// Binary function application closure.\n+//\n+template<template<class, class> class _Meta1,\n+    template<class, class> class Meta2,\n+    class _Dom1, class _Dom2> class _BinFunClos;\n+\n+template<class _Dom1, class _Dom2> class _BinFunBase {\n+public:\n+    typedef typename _Dom1::value_type value_type;\n+    typedef value_type _Vt;\n+    \n+    _BinFunBase (const _Dom1& __e1, const _Dom2& __e2,\n+                 _Vt __f (_Vt, _Vt))\n+            : _M_expr1 (__e1), _M_expr2 (__e2), _M_func (__f) {}\n+    \n+    value_type operator[] (size_t __i) const\n+    { return _M_func (_M_expr1[__i], _M_expr2[__i]); }\n+    size_t size () const { return _M_expr1.size (); }\n+    \n+private:\n+    const _Dom1& _M_expr1;\n+    const _Dom2& _M_expr2;\n+    _Vt (*_M_func)(_Vt, _Vt);\n+};\n+\n+template<class _Dom> class _BinFunBase1 {\n+public:\n+    typedef typename _Dom::value_type value_type ;\n+    typedef value_type _Vt;\n+    \n+    _BinFunBase1 (const _Vt& __c, const _Dom& __e, _Vt __f(_Vt, _Vt))\n+            : _M_expr1 (__c), _M_expr2 (__e), _M_func (__f) {}\n+    \n+    value_type operator[] (size_t __i) const\n+    { return _M_func (_M_expr1, _M_expr2[__i]); }\n+    size_t size () const { return _M_expr2.size (); }\n+    \n+private:\n+    const _Vt& _M_expr1;\n+    const _Dom& _M_expr2;\n+    _Vt (*_M_func)(_Vt, _Vt);\n+};\n+\n+template<class _Dom> class _BinFunBase2 {\n+public:\n+    typedef typename _Dom::value_type value_type;\n+    typedef value_type _Vt;\n+    \n+    _BinFunBase2 (const _Dom& __e, const _Vt& __c, _Vt __f(_Vt, _Vt))\n+            : _M_expr1 (__e), _M_expr2 (__c), _M_func (__f) {}\n+    \n+    value_type operator[] (size_t __i) const\n+    { return _M_func (_M_expr1[__i], _M_expr2); }\n+    size_t size () const { return _M_expr1.size (); }\n+    \n+private:\n+    const _Dom& _M_expr1;\n+    const _Vt& _M_expr2;\n+    _Vt (*_M_func)(_Vt, _Vt);\n+};\n+\n+template<class _Dom1, class _Dom2>\n+struct _BinFunClos<_Expr,_Expr,_Dom1,_Dom2> : _BinFunBase<_Dom1,_Dom2> {\n+    typedef _BinFunBase<_Dom1,_Dom2> _Base;\n+    typedef typename _Base::value_type value_type;\n+    typedef value_type _Tp;\n+    \n+    _BinFunClos (const _Dom1& __e1, const _Dom2& __e2,\n+                 _Tp __f(_Tp, _Tp))\n+            : _Base (__e1, __e2, __f) {}\n+};\n+\n+template<typename _Tp>\n+struct _BinFunClos<_ValArray,_ValArray,_Tp,_Tp>\n+    : _BinFunBase<valarray<_Tp>, valarray<_Tp> > {\n+    typedef _BinFunBase<valarray<_Tp>, valarray<_Tp> > _Base;\n+    typedef _Tp value_type;\n+    \n+    _BinFunClos (const valarray<_Tp>& __v, const valarray<_Tp>& __w,\n+                 _Tp __f(_Tp, _Tp))\n+            : _Base (__v, __w, __f) {}\n+};\n+\n+template<class _Dom>\n+struct _BinFunClos<_Expr,_ValArray,_Dom,typename _Dom::value_type>\n+    : _BinFunBase<_Dom,valarray<typename _Dom::value_type> > {\n+    typedef typename _Dom::value_type _Tp;\n+    typedef _BinFunBase<_Dom,valarray<_Tp> > _Base;\n+    typedef _Tp value_type;\n+    \n+    _BinFunClos (const _Dom& __e, const valarray<_Tp>& __v,\n+                 _Tp __f(_Tp, _Tp))\n+            : _Base (__e, __v, __f) {}\n+};\n+\n+template<class _Dom>\n+struct _BinFunClos<_ValArray,_Expr,typename _Dom::value_type,_Dom>\n+    : _BinFunBase<valarray<typename _Dom::value_type>,_Dom> {\n+    typedef typename _Dom::value_type _Tp;\n+    typedef _BinFunBase<_Dom,valarray<_Tp> > _Base;\n+    typedef _Tp value_type;\n+    \n+    _BinFunClos (const valarray<_Tp>& __v, const _Dom& __e,\n+                 _Tp __f(_Tp, _Tp))\n+            : _Base (__v, __e, __f) {}\n+};\n+\n+template<class _Dom>\n+struct _BinFunClos<_Expr,_Constant,_Dom,typename _Dom::value_type>\n+    : _BinFunBase2<_Dom> {\n+    typedef typename _Dom::value_type _Tp;\n+    typedef _Tp value_type;\n+    typedef _BinFunBase2<_Dom> _Base;\n+    \n+    _BinFunClos (const _Dom& __e, const _Tp& __t, _Tp __f (_Tp, _Tp))\n+            : _Base (__e, __t, __f) {}\n+};\n+\n+template<class _Dom>\n+struct _BinFunClos<_Constant,_Expr,_Dom,typename _Dom::value_type>\n+    : _BinFunBase1<_Dom> {\n+    typedef typename _Dom::value_type _Tp;\n+    typedef _Tp value_type;\n+    typedef _BinFunBase1<_Dom> _Base;\n+    \n+    _BinFunClos (const _Tp& __t, const _Dom& __e, _Tp __f (_Tp, _Tp))\n+            : _Base (__t, __e, __f) {}\n+};\n+\n+template<typename _Tp>\n+struct _BinFunClos<_ValArray,_Constant,_Tp,_Tp>\n+    : _BinFunBase2<valarray<_Tp> > {\n+    typedef _BinFunBase2<valarray<_Tp> > _Base;\n+    typedef _Tp value_type;\n+    \n+    _BinFunClos (const valarray<_Tp>& __v, const _Tp& __t,\n+                 _Tp __f(_Tp, _Tp))\n+            : _Base (__v, __t, __f) {}\n+};\n+\n+template<typename _Tp>\n+struct _BinFunClos<_Constant,_ValArray,_Tp,_Tp>\n+    : _BinFunBase1<valarray<_Tp> > {\n+    typedef _BinFunBase1<valarray<_Tp> > _Base;\n+    typedef _Tp value_type;\n+    \n+    _BinFunClos (const _Tp& __t, const valarray<_Tp>& __v,\n+                 _Tp __f (_Tp, _Tp))\n+            : _Base (__t, __v, __f) {}\n+};\n+\n+//\n+// Apply function taking a value/const reference closure\n+//\n+\n+template<typename _Dom, typename _Arg> class _FunBase {\n+public:\n+    typedef typename _Dom::value_type value_type;\n+    \n+    _FunBase (const _Dom& __e, value_type __f(_Arg))\n+            : _M_expr (__e), _M_func (__f) {}\n+    \n+    value_type operator[] (size_t __i) const\n+    { return _M_func (_M_expr[__i]); }\n+    size_t size() const { return _M_expr.size ();}\n+    \n+private:\n+    const _Dom& _M_expr;\n+    value_type (*_M_func)(_Arg);\n+};\n+\n+template<class _Dom>\n+struct _ValFunClos<_Expr,_Dom>\n+    : _FunBase<_Dom, typename _Dom::value_type> {\n+    typedef _FunBase<_Dom, typename _Dom::value_type> _Base;\n+    typedef typename _Base::value_type value_type;\n+    typedef value_type _Tp;\n+    \n+    _ValFunClos (const _Dom& __e, _Tp __f (_Tp)) : _Base (__e, __f) {}\n+};\n+\n+template<typename _Tp>\n+struct _ValFunClos<_ValArray,_Tp>\n+    : _FunBase<valarray<_Tp>, _Tp> {\n+    typedef _FunBase<valarray<_Tp>, _Tp> _Base;\n+    typedef _Tp value_type;\n+    \n+    _ValFunClos (const valarray<_Tp>& __v, _Tp __f(_Tp))\n+            : _Base (__v, __f) {}\n+};\n+\n+template<class _Dom>\n+struct _RefFunClos<_Expr,_Dom> :\n+    _FunBase<_Dom, const typename _Dom::value_type&> {\n+    typedef _FunBase<_Dom, const typename _Dom::value_type&> _Base;\n+    typedef typename _Base::value_type value_type;\n+    typedef value_type _Tp;\n+    \n+    _RefFunClos (const _Dom& __e, _Tp __f (const _Tp&))\n+            : _Base (__e, __f) {}\n+};\n+\n+template<typename _Tp>\n+struct _RefFunClos<_ValArray,_Tp>\n+    : _FunBase<valarray<_Tp>, const _Tp&> {\n+    typedef _FunBase<valarray<_Tp>, const _Tp&> _Base;\n+    typedef _Tp value_type;\n+    \n+    _RefFunClos (const valarray<_Tp>& __v, _Tp __f(const _Tp&))\n+            : _Base (__v, __f) {}\n+};\n+\n+//\n+// Unary expression closure.\n+//\n+\n+template<template<class> class _Oper, typename _Arg>\n+class _UnBase {\n+public:\n+    typedef _Oper<typename _Arg::value_type> _Op;\n+    typedef typename _Op::result_type value_type;\n+    \n+    _UnBase (const _Arg& __e) : _M_expr(__e) {}\n+    value_type operator[] (size_t) const;\n+    size_t size () const { return _M_expr.size (); }\n+    \n+private:\n+    const _Arg& _M_expr;\n+};\n+\n+template<template<class> class _Oper, typename _Arg>\n+inline typename _UnBase<_Oper, _Arg>::value_type\n+_UnBase<_Oper, _Arg>::operator[] (size_t __i) const\n+{ return _Op() (_M_expr[__i]); }\n+\n+template<template<class> class _Oper, class _Dom>\n+struct _UnClos<_Oper, _Expr, _Dom> :  _UnBase<_Oper, _Dom> {\n+    typedef _Dom _Arg;\n+    typedef _UnBase<_Oper, _Dom> _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _UnClos (const _Arg& __e) : _Base(__e) {}\n+};\n+\n+template<template<class> class _Oper, typename _Tp>\n+struct _UnClos<_Oper, _ValArray, _Tp> : _UnBase<_Oper, valarray<_Tp> > {\n+    typedef valarray<_Tp> _Arg;\n+    typedef _UnBase<_Oper, valarray<_Tp> > _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _UnClos (const _Arg& __e) : _Base(__e) {}\n+};\n+\n+\n+//\n+// Binary expression closure.\n+//\n+\n+template<template<class> class _Oper, typename _FirstArg, typename _SecondArg>\n+class _BinBase {\n+public:\n+    typedef _Oper<typename _FirstArg::value_type> _Op;\n+    typedef typename _Op::result_type value_type;\n+    \n+    _BinBase (const _FirstArg& __e1, const _SecondArg& __e2)\n+            : _M_expr1 (__e1), _M_expr2 (__e2) {}\n+    value_type operator[] (size_t) const;\n+    size_t size () const { return _M_expr1.size (); }\n+    \n+private:\n+    const _FirstArg& _M_expr1;\n+    const _SecondArg& _M_expr2;\n+};\n+\n+template<template<class> class _Oper, typename _FirstArg, typename _SecondArg>\n+inline typename _BinBase<_Oper,_FirstArg,_SecondArg>::value_type\n+_BinBase<_Oper,_FirstArg,_SecondArg>::operator[] (size_t __i) const\n+{ return _Op() (_M_expr1[__i], _M_expr2[__i]); }\n+\n+\n+template<template<class> class _Oper, class _Clos>\n+class _BinBase2 {\n+public:\n+        typedef typename _Clos::value_type _Vt;\n+    typedef _Oper<_Vt> _Op;\n+    typedef typename _Op::result_type value_type;\n+    \n+    _BinBase2 (const _Clos& __e, const _Vt& __t)\n+            : _M_expr1 (__e), _M_expr2 (__t) {}\n+    value_type operator[] (size_t) const;\n+    size_t size () const { return _M_expr1.size (); }\n+    \n+private:\n+    const _Clos& _M_expr1;\n+    const _Vt& _M_expr2;\n+};\n+\n+template<template<class> class _Oper, class _Clos>\n+inline typename _BinBase2<_Oper,_Clos>::value_type\n+_BinBase2<_Oper,_Clos>::operator[] (size_t __i) const\n+{ return _Op() (_M_expr1[__i], _M_expr2); }\n+\n+\n+template<template<class> class _Oper, class _Clos>\n+class _BinBase1 {\n+public:\n+    typedef typename _Clos::value_type _Vt;\n+    typedef _Oper<_Vt> _Op;\n+    typedef typename _Op::result_type value_type;\n+    \n+    _BinBase1 (const _Vt& __t, const _Clos& __e)\n+            : _M_expr1 (__t), _M_expr2 (__e) {}\n+    value_type operator[] (size_t) const;\n+    size_t size () const { return _M_expr2.size (); }\n+    \n+private:\n+    const _Vt& _M_expr1;\n+    const _Clos& _M_expr2;\n+};\n+\n+template<template<class> class _Oper, class _Clos>\n+inline typename\n+_BinBase1<_Oper,_Clos>::value_type\n+_BinBase1<_Oper,_Clos>:: operator[] (size_t __i) const\n+{ return _Op() (_M_expr1, _M_expr2[__i]); }\n+\n+\n+template<template<class> class _Oper, class _Dom1, class _Dom2>\n+struct  _BinClos<_Oper, _Expr, _Expr, _Dom1, _Dom2>\n+    : _BinBase<_Oper,_Dom1,_Dom2> {\n+    typedef _BinBase<_Oper,_Dom1,_Dom2> _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _BinClos(const _Dom1& __e1, const _Dom2& __e2) : _Base(__e1, __e2) {}\n+};\n+\n+template<template<class> class _Oper, typename _Tp>\n+struct _BinClos<_Oper,_ValArray,_ValArray,_Tp,_Tp>\n+    : _BinBase<_Oper,valarray<_Tp>,valarray<_Tp> > {\n+    typedef _BinBase<_Oper,valarray<_Tp>,valarray<_Tp> > _Base;\n+    typedef _Tp value_type;\n+    \n+    _BinClos (const valarray<_Tp>& __v, const valarray<_Tp>& __w)\n+            : _Base (__v, __w) {}\n+};\n+\n+template<template<class> class _Oper, class _Dom>\n+struct  _BinClos<_Oper,_Expr,_ValArray,_Dom,typename _Dom::value_type>\n+    : _BinBase<_Oper,_Dom,valarray<typename _Dom::value_type> > {\n+        typedef typename _Dom::value_type _Tp;\n+    typedef _BinBase<_Oper,_Dom,valarray<_Tp> > _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _BinClos(const _Dom& __e1, const valarray<_Tp>& __e2)\n+            : _Base (__e1, __e2) {}\n+};\n+\n+template<template<class> class _Oper, class _Dom>\n+struct  _BinClos<_Oper,_ValArray,_Expr,typename _Dom::value_type,_Dom>\n+    : _BinBase<_Oper,valarray<typename _Dom::value_type>,_Dom> {\n+    typedef typename _Dom::value_type _Tp;\n+    typedef _BinBase<_Oper,valarray<_Tp>,_Dom> _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _BinClos (const valarray<_Tp> __e1, const _Dom& __e2)\n+            : _Base (__e1, __e2) {}\n+};\n+\n+template<template<class> class _Oper, class _Dom>\n+struct _BinClos<_Oper,_Expr,_Constant,_Dom,typename _Dom::value_type>\n+    : _BinBase2<_Oper,_Dom> {\n+    typedef typename _Dom::value_type _Tp;\n+    typedef _BinBase2<_Oper,_Dom> _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _BinClos (const _Dom& __e1, const _Tp& __e2) : _Base (__e1, __e2) {}\n+};\n+\n+template<template<class> class _Oper, class _Dom>\n+struct _BinClos<_Oper,_Constant,_Expr,typename _Dom::value_type,_Dom>\n+    : _BinBase1<_Oper,_Dom> {\n+    typedef typename _Dom::value_type _Tp;\n+    typedef _BinBase1<_Oper,_Dom> _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _BinClos (const _Tp& __e1, const _Dom& __e2) : _Base (__e1, __e2) {}\n+};\n+\n+template<template<class> class _Oper, typename _Tp>\n+struct _BinClos<_Oper,_ValArray,_Constant,_Tp,_Tp>\n+    : _BinBase2<_Oper,valarray<_Tp> > {\n+    typedef _BinBase2<_Oper,valarray<_Tp> > _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _BinClos (const valarray<_Tp>& __v, const _Tp& __t)\n+            : _Base (__v, __t) {}\n+};\n+\n+template<template<class> class _Oper, typename _Tp>\n+struct _BinClos<_Oper,_Constant,_ValArray,_Tp,_Tp>\n+    : _BinBase1<_Oper,valarray<_Tp> > {\n+    typedef _BinBase1<_Oper,valarray<_Tp> > _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _BinClos (const _Tp& __t, const valarray<_Tp>& __v)\n+            : _Base (__t, __v) {}\n+};\n+\n+\n+//\n+// slice_array closure.\n+//\n+template<typename _Dom>  class _SBase {\n+public:\n+    typedef typename _Dom::value_type value_type;\n+    \n+    _SBase (const _Dom& __e, const slice& __s)\n+            : _M_expr (__e), _M_slice (__s) {}\n+    value_type operator[] (size_t __i) const\n+    { return _M_expr[_M_slice.start () + __i * _M_slice.stride ()]; }\n+    size_t size() const { return _M_slice.size (); }\n+    \n+private:\n+    const _Dom& _M_expr;\n+    const slice& _M_slice;\n+};\n+\n+template<typename _Tp> class _SBase<_Array<_Tp> > {\n+public:\n+    typedef _Tp value_type;\n+    \n+    _SBase (_Array<_Tp> __a, const slice& __s)\n+            : _M_array (__a._M_data+__s.start()), _M_size (__s.size()),\n+              _M_stride (__s.stride()) {}\n+    value_type operator[] (size_t __i) const\n+    { return _M_array._M_data[__i * _M_stride]; }\n+    size_t size() const { return _M_size; }\n+    \n+private:\n+    const _Array<_Tp> _M_array;\n+    const size_t _M_size;\n+    const size_t _M_stride;\n+};\n+\n+template<class _Dom> struct  _SClos<_Expr,_Dom> : _SBase<_Dom> {\n+    typedef _SBase<_Dom> _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _SClos (const _Dom& __e, const slice& __s) : _Base (__e, __s) {}\n+};\n+\n+template<typename _Tp>\n+struct _SClos<_ValArray,_Tp> : _SBase<_Array<_Tp> > {\n+    typedef  _SBase<_Array<_Tp> > _Base;\n+    typedef _Tp value_type;\n+    \n+    _SClos (_Array<_Tp> __a, const slice& __s) : _Base (__a, __s) {}\n+};\n+\n+//\n+// gslice_array closure.\n+//\n+template<class _Dom> class _GBase {\n+public:\n+    typedef typename _Dom::value_type value_type;\n+    \n+    _GBase (const _Dom& __e, const valarray<size_t>& __i)\n+            : _M_expr (__e), _M_index(__i) {}\n+    value_type operator[] (size_t __i) const\n+    { return _M_expr[_M_index[__i]]; }\n+    size_t size () const { return _M_index.size(); }\n+    \n+private:\n+    const _Dom&\t _M_expr;\n+    const valarray<size_t>& _M_index;\n+};\n+\n+template<typename _Tp> class _GBase<_Array<_Tp> > {\n+public:\n+    typedef _Tp value_type;\n+    \n+    _GBase (_Array<_Tp> __a, const valarray<size_t>& __i)\n+            : _M_array (__a), _M_index(__i) {}\n+    value_type operator[] (size_t __i) const\n+    { return _M_array._M_data[_M_index[__i]]; }\n+    size_t size () const { return _M_index.size(); }\n+    \n+private:\n+    const _Array<_Tp>     _M_array;\n+    const valarray<size_t>& _M_index;\n+};\n+\n+template<class _Dom> struct _GClos<_Expr,_Dom> : _GBase<_Dom> {\n+    typedef _GBase<_Dom> _Base;\n+    typedef typename _Base::value_type value_type;\n+\n+    _GClos (const _Dom& __e, const valarray<size_t>& __i)\n+            : _Base (__e, __i) {}\n+};\n+\n+template<typename _Tp>\n+struct _GClos<_ValArray,_Tp> : _GBase<_Array<_Tp> > {\n+    typedef _GBase<_Array<_Tp> > _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _GClos (_Array<_Tp> __a, const valarray<size_t>& __i)\n+            : _Base (__a, __i) {}\n+};\n+\n+//\n+// indirect_array closure\n+//\n+\n+template<class _Dom> class _IBase {\n+public:\n+    typedef typename _Dom::value_type value_type;\n+\n+    _IBase (const _Dom& __e, const valarray<size_t>& __i)\n+            : _M_expr (__e), _M_index (__i) {}\n+    value_type operator[] (size_t __i) const\n+    { return _M_expr[_M_index[__i]]; }\n+    size_t size() const { return _M_index.size(); }\n+    \n+private:\n+    const _Dom& \t    _M_expr;\n+    const valarray<size_t>& _M_index;\n+};\n+\n+template<class _Dom> struct _IClos<_Expr,_Dom> : _IBase<_Dom> {\n+    typedef _IBase<_Dom> _Base;\n+    typedef typename _Base::value_type value_type;\n+    \n+    _IClos (const _Dom& __e, const valarray<size_t>& __i)\n+            : _Base (__e, __i) {}\n+};\n+\n+template<typename _Tp>\n+struct _IClos<_ValArray,_Tp>  : _IBase<valarray<_Tp> > {\n+    typedef _IBase<valarray<_Tp> > _Base;\n+    typedef _Tp value_type;\n+    \n+    _IClos (const valarray<_Tp>& __a, const valarray<size_t>& __i)\n+            : _Base (__a, __i) {}\n+};\n+\n+//\n+// class _Expr\n+//      \n+template<class _Clos, typename _Tp> class _Expr {\n+public:\n+    typedef _Tp value_type;\n+    \n+    _Expr (const _Clos&);\n+    \n+    const _Clos& operator() () const;\n+    \n+    value_type operator[] (size_t) const;\n+    valarray<value_type> operator[] (slice) const;\n+    valarray<value_type> operator[] (const gslice&) const;\n+    valarray<value_type> operator[] (const valarray<bool>&) const;\n+    valarray<value_type> operator[] (const valarray<size_t>&) const;\n+    \n+    _Expr<_UnClos<_Unary_plus,_Expr,_Clos>, value_type>\n+    operator+ () const;\n+    \n+    _Expr<_UnClos<negate,_Expr,_Clos>, value_type>\n+    operator- () const;\n+    \n+    _Expr<_UnClos<_Bitwise_not,_Expr,_Clos>, value_type>\n+    operator~ () const;\n+    \n+    _Expr<_UnClos<logical_not,_Expr,_Clos>, bool>\n+    operator! () const;\n+    \n+    size_t size () const;\n+    value_type sum () const;\n+    \n+    valarray<value_type> shift (int) const;\n+    valarray<value_type> cshift (int) const;\n+//     _Meta<_ApplyFunctionWithValue<_Expr>, value_type>\n+//     apply (value_type _M_func (value_type)) const;\n+//     _Meta<_ApplyFunctionWithConstRef<_Expr>, value_type>\n+//     apply (value_type _M_func (const value_type&)) const;\n+        \n+private:\n+    const _Clos _M_closure;\n+};\n+    \n+template<class _Clos, typename _Tp>\n+inline\n+_Expr<_Clos,_Tp>::_Expr (const _Clos& __c) : _M_closure(__c) {}\n+\n+template<class _Clos, typename _Tp>\n+inline const _Clos&\n+_Expr<_Clos,_Tp>::operator() () const\n+{ return _M_closure; }\n+\n+template<class _Clos, typename _Tp>\n+inline _Tp\n+_Expr<_Clos,_Tp>::operator[] (size_t __i) const\n+{ return _M_closure[__i]; }\n+\n+template<class _Clos, typename _Tp>\n+inline valarray<_Tp>\n+_Expr<_Clos,_Tp>::operator[] (slice __s) const\n+{ return _M_closure[__s]; }\n+\n+template<class _Clos, typename _Tp>\n+inline valarray<_Tp>\n+_Expr<_Clos,_Tp>::operator[] (const gslice& __gs) const\n+{ return _M_closure[__gs]; }\n+\n+template<class _Clos, typename _Tp>\n+inline valarray<_Tp>\n+_Expr<_Clos,_Tp>::operator[] (const valarray<bool>& __m) const\n+{ return _M_closure[__m]; }\n+\n+template<class _Clos, typename _Tp>\n+inline valarray<_Tp>\n+_Expr<_Clos,_Tp>::operator[] (const valarray<size_t>& __i) const\n+{ return _M_closure[__i]; }\n+\n+template<class _Clos, typename _Tp>\n+inline size_t\n+_Expr<_Clos,_Tp>::size () const  { return _M_closure.size (); }\n+\n+// XXX: replace this with a more robust summation algorithm.\n+template<class _Clos, typename _Tp>\n+inline _Tp\n+_Expr<_Clos,_Tp>::sum () const\n+{\n+        _Tp __s(_Tp());\n+        size_t __n (_M_closure.size ());\n+        for (size_t __i=0; __i<__n; ++__i) __s += _M_closure[__i];\n+        return __s;\n+}\n+\n+template<class _Dom, typename _Tp>\n+inline _Tp\n+min (const _Expr<_Dom,_Tp>& __e)\n+{\n+    size_t __s (__e.size ());\n+    _Tp  __m (__e[0]);\n+    for (size_t __i=1; __i<__s; ++__i)\n+        if (__m > __e[__i]) __m = __e[__i];\n+    return __m;\n+}\n+\n+template<class _Dom, typename _Tp>\n+inline _Tp\n+max (const _Expr<_Dom,_Tp>& __e)\n+{\n+    size_t __s (__e.size());\n+    _Tp __m (__e[0]);\n+    for (size_t __i=1; __i<__s; ++__i)\n+        if (__m < __e[__i]) __m = __e[__i];\n+    return __m;\n+}\n+\n+template<class _Dom, typename _Tp>\n+inline _Expr<_UnClos<logical_not,_Expr,_Dom>, bool>\n+_Expr<_Dom,_Tp>::operator! () const\n+{\n+    typedef _UnClos<logical_not,_Expr,_Dom> _Closure;\n+    return _Expr<_Closure,_Tp> (_Closure(this->_M_closure));\n+}\n+\n+#define _DEFINE_EXPR_UNARY_OPERATOR(_Op, _Name)                         \\\n+template<class _Dom, typename _Tp>                                      \\\n+inline _Expr<_UnClos<_Name,_Expr,_Dom>,_Tp>                             \\\n+_Expr<_Dom,_Tp>::operator##_Op () const                                 \\\n+{                                                                       \\\n+    typedef _UnClos<_Name,_Expr,_Dom> _Closure;                         \\\n+    return _Expr<_Closure,_Tp> (_Closure (this->_M_closure));           \\\n+}\n+\n+    _DEFINE_EXPR_UNARY_OPERATOR(+, _Unary_plus)\n+    _DEFINE_EXPR_UNARY_OPERATOR(-, negate)\n+    _DEFINE_EXPR_UNARY_OPERATOR(~, _Bitwise_not)\n+\n+#undef _DEFINE_EXPR_UNARY_OPERATOR\n+\n+\n+#define _DEFINE_EXPR_BINARY_OPERATOR(_Op, _Name)                        \\\n+template<class _Dom1, class _Dom2>\t\t\t\t\t\\\n+inline _Expr<_BinClos<_Name,_Expr,_Expr,_Dom1,_Dom2>,                   \\\n+             typename _Name<typename _Dom1::value_type>::result_type>   \\\n+operator##_Op (const _Expr<_Dom1,typename _Dom1::value_type>& __v,      \\\n+              const _Expr<_Dom2,typename _Dom2::value_type>& __w)       \\\n+{                                                                       \\\n+    typedef typename _Dom1::value_type _Arg;                            \\\n+    typedef typename _Name<_Arg>::result_type _Value;                   \\\n+    typedef _BinClos<_Name,_Expr,_Expr,_Dom1,_Dom2> _Closure;           \\\n+    return _Expr<_Closure,_Value> (_Closure (__v (), __w ()));          \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinClos<_Name,_Expr,_Constant,_Dom,typename _Dom::value_type>, \\\n+             typename _Name<typename _Dom::value_type>::result_type>    \\\n+operator##_Op (const _Expr<_Dom,typename _Dom::value_type>& __v,        \\\n+              const typename _Dom::value_type& __t)                     \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Arg;                             \\\n+    typedef typename _Name<_Arg>::result_type _Value;                   \\\n+    typedef _BinClos<_Name,_Expr,_Constant,_Dom,_Arg> _Closure;         \\\n+    return _Expr<_Closure,_Value> (_Closure (__v (), __t));             \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinClos<_Name,_Constant,_Expr,typename _Dom::value_type,_Dom>, \\\n+             typename _Name<typename _Dom::value_type>::result_type>    \\\n+operator##_Op (const typename _Dom::value_type& __t,                    \\\n+               const _Expr<_Dom,typename _Dom::value_type>& __v)        \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Arg;                             \\\n+    typedef typename _Name<_Arg>::result_type _Value;                   \\\n+    typedef _BinClos<_Name,_Constant,_Expr,_Arg,_Dom> _Closure;         \\\n+    return _Expr<_Closure,_Value> (_Closure (__t, __v ()));             \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinClos<_Name,_Expr,_ValArray,_Dom,typename _Dom::value_type>, \\\n+             typename _Name<typename _Dom::value_type>::result_type>    \\\n+operator##_Op (const _Expr<_Dom,typename _Dom::value_type>& __e,        \\\n+               const valarray<typename _Dom::value_type>& __v)          \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Arg;                             \\\n+    typedef typename _Name<_Arg>::result_type _Value;                   \\\n+    typedef _BinClos<_Name,_Expr,_ValArray,_Dom,_Arg> _Closure;         \\\n+    return  _Expr<_Closure,_Value> (_Closure (__e (), __v));            \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinClos<_Name,_ValArray,_Expr,typename _Dom::value_type,_Dom>, \\\n+             typename _Name<typename _Dom::value_type>::result_type>    \\\n+operator##_Op (const valarray<typename _Dom::value_type>& __v,          \\\n+               const _Expr<_Dom,typename _Dom::value_type>& __e)        \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Tp;                              \\\n+    typedef typename _Name<_Tp>::result_type _Value;                    \\\n+    typedef _BinClos<_Name,_ValArray,_Expr,_Tp,_Dom> _Closure;          \\\n+    return _Expr<_Closure,_Value> (_Closure (__v, __e ()));             \\\n+}\n+\n+    _DEFINE_EXPR_BINARY_OPERATOR(+, plus)\n+    _DEFINE_EXPR_BINARY_OPERATOR(-, minus)\n+    _DEFINE_EXPR_BINARY_OPERATOR(*, multiplies)\n+    _DEFINE_EXPR_BINARY_OPERATOR(/, divides)\n+    _DEFINE_EXPR_BINARY_OPERATOR(%, modulus)\n+    _DEFINE_EXPR_BINARY_OPERATOR(^, _Bitwise_xor)\n+    _DEFINE_EXPR_BINARY_OPERATOR(&, _Bitwise_and)\n+    _DEFINE_EXPR_BINARY_OPERATOR(|, _Bitwise_or)\n+    _DEFINE_EXPR_BINARY_OPERATOR(<<, _Shift_left)\n+    _DEFINE_EXPR_BINARY_OPERATOR(>>, _Shift_right)\n+\n+#undef _DEFINE_EXPR_BINARY_OPERATOR\n+    \n+#define _DEFINE_EXPR_RELATIONAL_OPERATOR(_Op, _Name)                    \\\n+template<class _Dom1, class _Dom2>\t\t\t\t\t\\\n+inline _Expr<_BinClos<_Name,_Expr,_Expr,_Dom1,_Dom2>, bool>             \\\n+operator##_Op (const _Expr<_Dom1,typename _Dom1::value_type>& __v,      \\\n+              const _Expr<_Dom2,typename _Dom2::value_type>& __w)       \\\n+{                                                                       \\\n+    typedef typename _Dom1::value_type _Arg;                            \\\n+    typedef _BinClos<_Name,_Expr,_Expr,_Dom1,_Dom2> _Closure;           \\\n+    return _Expr<_Closure,bool> (_Closure (__v (), __w ()));            \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinClos<_Name,_Expr,_Constant,_Dom,typename _Dom::value_type>, \\\n+             bool>                                                      \\\n+operator##_Op (const _Expr<_Dom,typename _Dom::value_type>& __v,        \\\n+              const typename _Dom::value_type& __t)                     \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Arg;                             \\\n+    typedef _BinClos<_Name,_Expr,_Constant,_Dom,_Arg> _Closure;         \\\n+    return _Expr<_Closure,bool> (_Closure (__v (), __t));               \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinClos<_Name,_Constant,_Expr,typename _Dom::value_type,_Dom>, \\\n+             bool>                                                      \\\n+operator##_Op (const typename _Dom::value_type& __t,                    \\\n+               const _Expr<_Dom,typename _Dom::value_type>& __v)        \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Arg;                             \\\n+    typedef _BinClos<_Name,_Constant,_Expr,_Arg,_Dom> _Closure;         \\\n+    return _Expr<_Closure,bool> (_Closure (__t, __v ()));               \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinClos<_Name,_Expr,_ValArray,_Dom,typename _Dom::value_type>, \\\n+             bool>                                                      \\\n+operator##_Op (const _Expr<_Dom,typename _Dom::value_type>& __e,        \\\n+               const valarray<typename _Dom::value_type>& __v)          \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Tp;                              \\\n+    typedef _BinClos<_Name,_Expr,_ValArray,_Dom,_Tp> _Closure;          \\\n+    return  _Expr<_Closure,bool> (_Closure (__e (), __v));              \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinClos<_Name,_ValArray,_Expr,typename _Dom::value_type,_Dom>, \\\n+             bool>                                                      \\\n+operator##_Op (const valarray<typename _Dom::value_type>& __v,          \\\n+               const _Expr<_Dom,typename _Dom::value_type>& __e)        \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Tp;                              \\\n+    typedef _BinClos<_Name,_ValArray,_Expr,_Tp,_Dom> _Closure;          \\\n+    return _Expr<_Closure,bool> (_Closure (__v, __e ()));               \\\n+}\n+\n+    _DEFINE_EXPR_RELATIONAL_OPERATOR(&&, logical_and)\n+    _DEFINE_EXPR_RELATIONAL_OPERATOR(||, logical_or)\n+    _DEFINE_EXPR_RELATIONAL_OPERATOR(==, equal_to)\n+    _DEFINE_EXPR_RELATIONAL_OPERATOR(!=, not_equal_to)\n+    _DEFINE_EXPR_RELATIONAL_OPERATOR(<, less)\n+    _DEFINE_EXPR_RELATIONAL_OPERATOR(>, greater)\n+    _DEFINE_EXPR_RELATIONAL_OPERATOR(<=, less_equal)\n+    _DEFINE_EXPR_RELATIONAL_OPERATOR(>=, greater_equal)\n+\n+#undef _DEFINE_EXPR_RELATIONAL_OPERATOR\n+\n+\n+\n+#define _DEFINE_EXPR_UNARY_FUNCTION(_Name)                              \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_UnFunClos<_Expr,_Dom>,typename _Dom::value_type>          \\\n+_Name(const _Expr<_Dom,typename _Dom::value_type>& __e)                 \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Tp;                              \\\n+    typedef _UnFunClos<_Expr,_Dom> _Closure;                            \\\n+    return _Expr<_Closure,_Tp> (_Closure (__e, (_Tp(*)(_Tp))(&_Name))); \\\n+}                                                                       \\\n+                                                                        \\\n+template<typename _Tp>                                                  \\\n+inline _Expr<_UnFunClos<_ValArray,_Tp>,_Tp>                             \\\n+_Name(const valarray<_Tp>& __v)                                         \\\n+{                                                                       \\\n+    typedef _UnFunClos<_ValArray,_Tp> _Closure;                         \\\n+    return _Expr<_Closure,_Tp> (_Closure (__v, (_Tp(*)(_Tp))(&_Name))); \\\n+}\n+\n+\n+    _DEFINE_EXPR_UNARY_FUNCTION(abs)\n+    _DEFINE_EXPR_UNARY_FUNCTION(cos)\n+    _DEFINE_EXPR_UNARY_FUNCTION(acos)\n+    _DEFINE_EXPR_UNARY_FUNCTION(cosh)    \n+    _DEFINE_EXPR_UNARY_FUNCTION(sin)\n+    _DEFINE_EXPR_UNARY_FUNCTION(asin)\n+    _DEFINE_EXPR_UNARY_FUNCTION(sinh)    \n+    _DEFINE_EXPR_UNARY_FUNCTION(tan)    \n+    _DEFINE_EXPR_UNARY_FUNCTION(atan)\n+    _DEFINE_EXPR_UNARY_FUNCTION(exp)    \n+    _DEFINE_EXPR_UNARY_FUNCTION(log)\n+    _DEFINE_EXPR_UNARY_FUNCTION(log10)\n+    _DEFINE_EXPR_UNARY_FUNCTION(sqrt)\n+\n+#undef _DEFINE_EXPR_UNARY_FUNCTION\n+\n+\n+#define _DEFINE_EXPR_BINARY_FUNCTION(_Name)                             \\\n+template<class _Dom1, class _Dom2>                                      \\\n+inline _Expr<_BinFunClos<_Expr,_Expr,_Dom1,_Dom2>,typename _Dom1::value_type>\\\n+_Name (const _Expr<_Dom1,typename _Dom1::value_type>& __e1,             \\\n+       const _Expr<_Dom2,typename _Dom2::value_type>& __e2)             \\\n+{                                                                       \\\n+    typedef typename _Dom1::value_type _Tp;                             \\\n+    typedef _BinFunClos<_Expr,_Expr,_Dom1,_Dom2> _Closure;              \\\n+    return _Expr<_Closure,_Tp>                                          \\\n+        (_Closure (__e1 (), __e2 (), (_Tp(*)(_Tp, _Tp))(&_Name)));      \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinFunClos<_Expr,_ValArray,_Dom,typename _Dom::value_type>, \\\n+             typename _Dom::value_type>                                 \\\n+_Name (const _Expr<_Dom,typename _Dom::value_type>& __e,                \\\n+       const valarray<typename _Dom::value_type>& __v)                  \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Tp;                              \\\n+    typedef _BinFunClos<_Expr,_ValArray,_Dom,_Tp> _Closure;             \\\n+    return _Expr<_Closure,_Tp>                                          \\\n+        (_Closure (__e (), __v, (_Tp(*)(_Tp, _Tp))(&_Name)));           \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinFunClos<_ValArray,_Expr,typename _Dom::value_type,_Dom>, \\\n+             typename _Dom::value_type>                                 \\\n+_Name (const valarray<typename _Dom::valarray>& __v,                    \\\n+       const _Expr<_Dom,typename _Dom::value_type>& __e)                \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Tp;                              \\\n+    typedef _BinFunClos<_ValArray,_Expr,_Tp,_Dom> _Closure;             \\\n+    return _Expr<_Closure,_Tp>                                          \\\n+        (_Closure (__v, __e (), (_Tp(*)(_Tp, _Tp))(&_Name)));           \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinFunClos<_Expr,_Constant,_Dom,typename _Dom::value_type>, \\\n+             typename _Dom::value_type>                                 \\\n+_Name (const _Expr<_Dom, typename _Dom::value_type>& __e,               \\\n+       const typename _Dom::value_type& __t)                            \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Tp;                              \\\n+    typedef _BinFunClos<_Expr,_Constant,_Dom,_Tp> _Closure;             \\\n+    return _Expr<_Closure,_Tp>                                          \\\n+        (_Closure (__e (), __t, (_Tp(*)(_Tp, _Tp))(&_Name)));           \\\n+}                                                                       \\\n+                                                                        \\\n+template<class _Dom>                                                    \\\n+inline _Expr<_BinFunClos<_Constant,_Expr,typename _Dom::value_type,_Dom>, \\\n+             typename _Dom::value_type>                                 \\\n+_Name (const typename _Dom::value_type& __t,                            \\\n+       const _Expr<_Dom,typename _Dom::value_type>& __e)                \\\n+{                                                                       \\\n+    typedef typename _Dom::value_type _Tp;                              \\\n+    typedef _BinFunClos<_Constant,_Expr,_Tp,_Dom> _Closure;             \\\n+    return _Expr<_Closure,_Tp>                                          \\\n+        (_Closure (__t, __e (), (_Tp(*)(_Tp, _Tp))(&_Name)));           \\\n+}                                                                       \\\n+                                                                        \\\n+template<typename _Tp>                                                  \\\n+inline _Expr<_BinFunClos<_ValArray,_ValArray,_Tp,_Tp>, _Tp>             \\\n+_Name (const valarray<_Tp>& __v, const valarray<_Tp>& __w)              \\\n+{                                                                       \\\n+    typedef _BinFunClos<_ValArray,_ValArray,_Tp,_Tp> _Closure;          \\\n+    return _Expr<_Closure,_Tp>                                          \\\n+        (_Closure (__v, __w, (_Tp(*)(_Tp,_Tp))(&_Name)));               \\\n+}                                                                       \\\n+                                                                        \\\n+template<typename _Tp>                                                  \\\n+inline _Expr<_BinFunClos<_ValArray,_Constant,_Tp,_Tp>,_Tp>              \\\n+_Name (const valarray<_Tp>& __v, const _Tp& __t)                        \\\n+{                                                                       \\\n+    typedef _BinFunClos<_ValArray,_Constant,_Tp,_Tp> _Closure;          \\\n+    return _Expr<_Closure,_Tp>                                          \\\n+        (_Closure (__v, __t, (_Tp(*)(_Tp,_Tp))(&_Name)));               \\\n+}                                                                       \\\n+                                                                        \\\n+template<typename _Tp>                                                  \\\n+inline _Expr<_BinFunClos<_Constant,_ValArray,_Tp,_Tp>,_Tp>              \\\n+_Name (const _Tp& __t, const valarray<_Tp>& __v)                        \\\n+{                                                                       \\\n+    typedef _BinFunClos<_Constant,_ValArray,_Tp,_Tp> _Closure;          \\\n+    return _Expr<_Closure,_Tp>                                          \\\n+        (_Closure (__t, __v, (_Tp(*)(_Tp,_Tp))(&_Name)));               \\\n+}\n+\n+_DEFINE_EXPR_BINARY_FUNCTION(atan2)\n+_DEFINE_EXPR_BINARY_FUNCTION(pow)\n+\n+#undef _DEFINE_EXPR_BINARY_FUNCTION\n+\n+#endif // _CPP_VALARRAY_META_H \n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "a938b6a68639caddb9210478df0197668747c0c9", "filename": "libstdc++/valarray", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fvalarray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fvalarray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fvalarray?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,8 @@\n+// Main header for -*- C++ -*- valarray classes.\n+\n+#ifndef __VALARRAY__\n+#define __VALARRAY__\n+\n+#include <std/std_valarray.h>\n+\n+#endif"}, {"sha": "5e7fe0cf05f7664a08e620414bc1db4ffefc6f36", "filename": "libstdc++/valarray.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fvalarray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ac1891d29ab1627b5ae30234c27603a064edd4/libstdc%2B%2B%2Fvalarray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fvalarray.cc?ref=27ac1891d29ab1627b5ae30234c27603a064edd4", "patch": "@@ -0,0 +1,50 @@\n+#include <std/std_valarray.h>\n+\n+// Some Explicit Instanciations.\n+template class multiplies<size_t>;\n+template size_t accumulate(size_t*, size_t*, size_t, multiplies<size_t>);\n+\n+template void\n+   __valarray_fill(size_t* __restrict__, size_t, const size_t&);\n+\n+template void\n+   __valarray_copy(const size_t* __restrict__, size_t, size_t* __restrict__);\n+\n+template valarray<size_t>::valarray(size_t);\n+template valarray<size_t>::~valarray();\n+template valarray<size_t>::valarray(const valarray<size_t>&);\n+template size_t valarray<size_t>::size() const;\n+template size_t& valarray<size_t>::operator[](size_t);\n+template size_t valarray<size_t>::product() const;\n+\n+\n+void __gslice_to_index(size_t __o, const valarray<size_t>& __l,\n+                       const valarray<size_t>& __s,\n+                       valarray<size_t>& __i)\n+{\n+    const size_t __n = __l.size();\n+    size_t* const __t = static_cast<size_t*>(alloca(__n*sizeof(size_t)));\n+    __valarray_fill(__t, __n, size_t(0));\n+    const size_t __z = __i.size();\n+    __valarray_fill(&__i[0], __z, __o);\n+    for (size_t __j=0; __j<__z; ++__j) {\n+        for (size_t __k=0; __k<__n; ++__k)\n+            __i[__j] += __s[__k]*__t[__k];\n+        ++__t[__n-1];\n+        for (size_t __k=__n-1; __k; --__k) {\n+            if (__t[__k] >= __l[__k]) {\n+                __t[__k] = 0;\n+                ++__t[__k-1];\n+            }\n+        }\n+    }\n+}\n+\n+_Indexer::_Indexer(size_t __o, const valarray<size_t>& __l,\n+                   const valarray<size_t>& __s)\n+        : _M_count(1), _M_start(__o), _M_size(__l), _M_stride(__s),\n+          _M_index(__l.size() ? __l.product() : 0)\n+{ __gslice_to_index(__o, __l, __s, _M_index); }\n+\n+\n+"}]}