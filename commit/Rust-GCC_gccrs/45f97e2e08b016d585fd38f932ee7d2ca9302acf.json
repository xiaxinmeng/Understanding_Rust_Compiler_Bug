{"sha": "45f97e2e08b016d585fd38f932ee7d2ca9302acf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVmOTdlMmUwOGIwMTZkNTg1ZmQzOGY5MzJlZTdkMmNhOTMwMmFjZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-07-17T14:46:06Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-07-17T14:46:06Z"}, "message": "loop.h (struct induction): Add no_const_addval.\n\n        * loop.h (struct induction): Add no_const_addval.\n        * loop.c (the_movables, reg_address_cost): New variables.\n        (init_loop): Init reg_address_cost.\n        (loop_optimize): Call end_alias_analysis.\n        (scan_loop): Init the_movables.\n        (record_giv): Init induction->no_const_addval.\n        (basic_induction_var) [PLUS]: Use rtx_equal_p instead of ==.\n        [REG]: Rearrange loop search test to catch more cases.\n        (general_induction_var): Return success not benefit; take an extra\n        argument for that.  Change all callers.\n        (simplify_giv_expr) [PLUS]: Always combine invariants.  Use sge_plus.\n        [MULT]: Use rtx_equal_p instead of ==.  Combine simple invariants.\n        [default]: Search the_movables for additional combinations.\n        (sge_plus_constant, sge_plus): New functions.\n        (express_from_1): New function.\n        (express_from): Always define.  Rewrite using express_from_1.\n        (combine_givs_p): Handle more cases.  Ignore address cost.\n        (cmp_combine_givs_stats): New function.\n        (combine_givs_used_once, combine_givs_benefit_from): New functions.\n        (combine_givs): Rewrite to do best-fit combination.\n        * fold-const.c (operand_equal_p): Handle RTL_EXPR.\n        (fold): Do a complete (A*C)+(B*C) association check.\n\nFrom-SVN: r21263", "tree": {"sha": "adf0dd2a995e73cabb5b041099bb2f890e671cc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adf0dd2a995e73cabb5b041099bb2f890e671cc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45f97e2e08b016d585fd38f932ee7d2ca9302acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f97e2e08b016d585fd38f932ee7d2ca9302acf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45f97e2e08b016d585fd38f932ee7d2ca9302acf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f97e2e08b016d585fd38f932ee7d2ca9302acf/comments", "author": null, "committer": null, "parents": [{"sha": "d4c011bca5e830092dd9d694f1dd53665349cf46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4c011bca5e830092dd9d694f1dd53665349cf46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4c011bca5e830092dd9d694f1dd53665349cf46"}], "stats": {"total": 870, "additions": 669, "deletions": 201}, "files": [{"sha": "d788138f7293c0192a4dc36149570c793787bbc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f97e2e08b016d585fd38f932ee7d2ca9302acf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f97e2e08b016d585fd38f932ee7d2ca9302acf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45f97e2e08b016d585fd38f932ee7d2ca9302acf", "patch": "@@ -1,3 +1,29 @@\n+Fri Jul 17 14:18:14 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* loop.h (struct induction): Add no_const_addval.\n+\t* loop.c (the_movables, reg_address_cost): New variables.\n+\t(init_loop): Init reg_address_cost.\n+\t(loop_optimize): Call end_alias_analysis.\n+\t(scan_loop): Init the_movables.\n+\t(record_giv): Init induction->no_const_addval.\n+\t(basic_induction_var) [PLUS]: Use rtx_equal_p instead of ==.\n+\t[REG]: Rearrange loop search test to catch more cases.\n+\t(general_induction_var): Return success not benefit; take an extra\n+\targument for that.  Change all callers.\n+\t(simplify_giv_expr) [PLUS]: Always combine invariants.  Use sge_plus.\n+\t[MULT]: Use rtx_equal_p instead of ==.  Combine simple invariants.\n+\t[default]: Search the_movables for additional combinations.\n+\t(sge_plus_constant, sge_plus): New functions.\n+\t(express_from_1): New function.\n+\t(express_from): Always define.  Rewrite using express_from_1.\n+\t(combine_givs_p): Handle more cases.  Ignore address cost.\n+\t(cmp_combine_givs_stats): New function.\n+\t(combine_givs_used_once, combine_givs_benefit_from): New functions.\n+\t(combine_givs): Rewrite to do best-fit combination.\n+\n+\t* fold-const.c (operand_equal_p): Handle RTL_EXPR.\n+\t(fold): Do a complete (A*C)+(B*C) association check.\n+\n Fri Jul 17 11:21:55 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* function.c (fixup_var_refs_insns): Handle CLOBBER of a CONCAT."}, {"sha": "4fe689944542ead5f959422b45d5e6542c2bbd0b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f97e2e08b016d585fd38f932ee7d2ca9302acf/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f97e2e08b016d585fd38f932ee7d2ca9302acf/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=45f97e2e08b016d585fd38f932ee7d2ca9302acf", "patch": "@@ -1928,6 +1928,11 @@ operand_equal_p (arg0, arg1, only_const)\n \tdefault:\n \t  return 0;\n \t}\n+\n+    case 'e':\n+      if (TREE_CODE (arg0) == RTL_EXPR)\n+\treturn rtx_equal_p (RTL_EXPR_RTL (arg0), RTL_EXPR_RTL (arg1));\n+      return 0;\n       \n     default:\n       return 0;\n@@ -4413,18 +4418,36 @@ fold (expr)\n \t      goto bit_ior;\n \t    }\n \n-\t  /* (A * C) + (B * C) -> (A+B) * C.  Since we are most concerned\n-\t     about the case where C is a constant, just try one of the\n-\t     four possibilities.  */\n-\n-\t  if (TREE_CODE (arg0) == MULT_EXPR && TREE_CODE (arg1) == MULT_EXPR\n-\t      && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t  TREE_OPERAND (arg1, 1), 0))\n-\t    return fold (build (MULT_EXPR, type,\n-\t\t\t\tfold (build (PLUS_EXPR, type,\n-\t\t\t\t\t     TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t     TREE_OPERAND (arg1, 0))),\n-\t\t\t\tTREE_OPERAND (arg0, 1)));\n+\t  if (TREE_CODE (arg0) == MULT_EXPR && TREE_CODE (arg1) == MULT_EXPR)\n+\t    {\n+\t      tree arg00, arg01, arg10, arg11;\n+\t      tree alt0, alt1, same;\n+\n+\t      /* (A * C) + (B * C) -> (A+B) * C.\n+\t\t We are most concerned about the case where C is a constant,\n+\t\t but other combinations show up during loop reduction.  Since\n+\t\t it is not difficult, try all four possibilities.  */\n+\n+\t      arg00 = TREE_OPERAND (arg0, 0);\n+\t      arg01 = TREE_OPERAND (arg0, 1);\n+\t      arg10 = TREE_OPERAND (arg1, 0);\n+\t      arg11 = TREE_OPERAND (arg1, 1);\n+\t      same = NULL_TREE;\n+\n+\t      if (operand_equal_p (arg01, arg11, 0))\n+\t\tsame = arg01, alt0 = arg00, alt1 = arg10;\n+\t      else if (operand_equal_p (arg00, arg10, 0))\n+\t\tsame = arg00, alt0 = arg01, alt1 = arg11;\n+\t      else if (operand_equal_p (arg00, arg11, 0))\n+\t\tsame = arg00, alt0 = arg01, alt1 = arg10;\n+\t      else if (operand_equal_p (arg01, arg10, 0))\n+\t\tsame = arg01, alt0 = arg00, alt1 = arg11;\n+\n+\t      if (same)\n+\t        return fold (build (MULT_EXPR, type,\n+\t\t\t\t    fold (build (PLUS_EXPR, type, alt0, alt1)),\n+\t\t\t\t    same));\n+\t    }\n \t}\n       /* In IEEE floating point, x+0 may not equal x.  */\n       else if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT"}, {"sha": "c9c986947d96364461df80a7efc87abd2b1314d7", "filename": "gcc/loop.c", "status": "modified", "additions": 607, "deletions": 189, "changes": 796, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f97e2e08b016d585fd38f932ee7d2ca9302acf/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f97e2e08b016d585fd38f932ee7d2ca9302acf/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=45f97e2e08b016d585fd38f932ee7d2ca9302acf", "patch": "@@ -272,6 +272,8 @@ struct movable\n   struct movable *next;\n };\n \n+static struct movable *the_movables;\n+\n FILE *loop_dump_stream;\n \n /* Forward declarations.  */\n@@ -310,16 +312,12 @@ static void record_giv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx, int,\n static void update_giv_derive PROTO((rtx));\n static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, rtx *, rtx *));\n static rtx simplify_giv_expr PROTO((rtx, int *));\n-static int general_induction_var PROTO((rtx, rtx *, rtx *, rtx *));\n+static int general_induction_var PROTO((rtx, rtx *, rtx *, rtx *, int, int *));\n static int consec_sets_giv PROTO((int, rtx, rtx, rtx, rtx *, rtx *));\n static int check_dbra_loop PROTO((rtx, int, rtx));\n-#ifdef ADDRESS_COST\n+static rtx express_from_1 PROTO((rtx, rtx, rtx));\n static rtx express_from PROTO((struct induction *, struct induction *));\n-#endif\n-static int combine_givs_p PROTO((struct induction *, struct induction *));\n-#ifdef GIV_SORT_CRITERION\n-static int giv_sort PROTO((struct induction **, struct induction **));\n-#endif\n+static rtx combine_givs_p PROTO((struct induction *, struct induction *));\n static void combine_givs PROTO((struct iv_class *));\n static int product_cheap_p PROTO((rtx, rtx));\n static int maybe_eliminate_biv PROTO((struct iv_class *, rtx, rtx, int, int, int));\n@@ -349,15 +347,19 @@ static int indirect_jump_in_function_p PROTO((rtx));\n \n \f\n /* Relative gain of eliminating various kinds of operations.  */\n-int add_cost;\n+static int add_cost;\n #if 0\n-int shift_cost;\n-int mult_cost;\n+static int shift_cost;\n+static int mult_cost;\n #endif\n \n /* Benefit penalty, if a giv is not replaceable, i.e. must emit an insn to\n    copy the value of the strength reduced giv to its original register.  */\n-int copy_cost;\n+static int copy_cost;\n+\n+/* Cost of using a register, to normalize the benefits of a giv.  */\n+static int reg_address_cost;\n+\n \n void\n init_loop ()\n@@ -367,6 +369,12 @@ init_loop ()\n \n   add_cost = rtx_cost (gen_rtx_PLUS (word_mode, reg, reg), SET);\n \n+#ifdef ADDRESS_COST\n+  reg_address_cost = ADDRESS_COST (reg);\n+#else\n+  reg_address_cost = rtx_cost (reg, MEM);\n+#endif\n+\n   /* We multiply by 2 to reconcile the difference in scale between\n      these two ways of computing costs.  Otherwise the cost of a copy\n      will be far less than the cost of an add.  */\n@@ -542,6 +550,8 @@ loop_optimize (f, dumpfile, unroll_p)\n      to one mapping will remain.  */\n   if (unroll_p && write_symbols != NO_DEBUG)\n     unroll_block_trees ();\n+\n+  end_alias_analysis ();\n }\n \f\n /* Optimize one loop whose start is LOOP_START and end is END.\n@@ -1084,8 +1094,11 @@ scan_loop (loop_start, end, nregs, unroll_p)\n       n_times_set[i] = n_times_used[i];\n \n   if (flag_strength_reduce)\n-    strength_reduce (scan_start, end, loop_top,\n-\t\t     insn_count, loop_start, end, unroll_p);\n+    {\n+      the_movables = movables;\n+      strength_reduce (scan_start, end, loop_top,\n+\t\t       insn_count, loop_start, end, unroll_p);\n+    }\n }\n \f\n /* Add elements to *OUTPUT to record all the pseudo-regs\n@@ -3318,7 +3331,7 @@ loop_reg_used_before_p (set, insn, loop_start, scan_start, loop_end)\n    value is a linear function of a biv.  */\n \n /* Bivs are recognized by `basic_induction_var';\n-   Givs by `general_induct_var'.  */\n+   Givs by `general_induction_var'.  */\n \n /* Indexed by register number, indicates whether or not register is an\n    induction variable, and if so what type.  */\n@@ -3789,14 +3802,13 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t    continue;\n \n \t  if (/* SET_SRC is a giv.  */\n-\t      ((benefit = general_induction_var (SET_SRC (set),\n-\t\t\t\t\t\t &src_reg, &add_val,\n-\t\t\t\t\t\t &mult_val))\n+\t      (general_induction_var (SET_SRC (set), &src_reg, &add_val,\n+\t\t\t\t      &mult_val, 0, &benefit)\n \t       /* Equivalent expression is a giv.  */\n \t       || ((regnote = find_reg_note (p, REG_EQUAL, NULL_RTX))\n-\t\t   && (benefit = general_induction_var (XEXP (regnote, 0),\n-\t\t\t\t\t\t\t&src_reg,\n-\t\t\t\t\t\t\t&add_val, &mult_val))))\n+\t\t   && general_induction_var (XEXP (regnote, 0), &src_reg,\n+\t\t\t\t\t     &add_val, &mult_val, 0,\n+\t\t\t\t\t     &benefit)))\n \t      /* Don't try to handle any regs made by loop optimization.\n \t\t We have nothing on them in regno_first_uid, etc.  */\n \t      && REGNO (dest_reg) < max_reg_before_loop\n@@ -4540,12 +4552,13 @@ find_mem_givs (x, insn, not_every_iteration, loop_start, loop_end)\n \trtx mult_val;\n \tint benefit;\n \n-\tbenefit = general_induction_var (XEXP (x, 0),\n-\t\t\t\t\t &src_reg, &add_val, &mult_val);\n+\t/* This code used to disable creating GIVs with mult_val == 1 and\n+\t   add_val == 0.  However, this leads to lost optimizations when \n+\t   it comes time to combine a set of related DEST_ADDR GIVs, since\n+\t   this one would not be seen.   */\n \n-\t/* Don't make a DEST_ADDR giv with mult_val == 1 && add_val == 0.\n-\t   Such a giv isn't useful.  */\n-\tif (benefit > 0 && (mult_val != const1_rtx || add_val != const0_rtx))\n+\tif (general_induction_var (XEXP (x, 0), &src_reg, &add_val,\n+\t\t\t\t   &mult_val, 1, &benefit))\n \t  {\n \t    /* Found one; record it.  */\n \t    struct induction *v\n@@ -4858,6 +4871,32 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n \t}\n     }\n \n+  /* Record whether the add_val contains a const_int, for later use by\n+     combine_givs.  */\n+  {\n+    rtx tem = add_val;\n+\n+    v->no_const_addval = 1;\n+    if (tem == const0_rtx)\n+      ;\n+    else if (GET_CODE (tem) == CONST_INT)\n+      v->no_const_addval = 0;\n+    else if (GET_CODE (tem) == PLUS)\n+      {\n+        while (1)\n+\t  {\n+\t    if (GET_CODE (XEXP (tem, 0)) == PLUS)\n+\t      tem = XEXP (tem, 0);\n+\t    else if (GET_CODE (XEXP (tem, 1)) == PLUS)\n+\t      tem = XEXP (tem, 1);\n+\t    else\n+\t      break;\n+\t  }\n+        if (GET_CODE (XEXP (tem, 1)) == CONST_INT)\n+          v->no_const_addval = 0;\n+      }\n+  }\n+\n   if (loop_dump_stream)\n     {\n       if (type == DEST_REG)\n@@ -4875,6 +4914,9 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n       if (v->replaceable)\n  \tfprintf (loop_dump_stream, \" replaceable\");\n \n+      if (v->no_const_addval)\n+\tfprintf (loop_dump_stream, \" ncav\");\n+\n       if (GET_CODE (mult_val) == CONST_INT)\n \t{\n \t  fprintf (loop_dump_stream, \" mult \");\n@@ -5197,12 +5239,12 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val)\n   switch (code)\n     {\n     case PLUS:\n-      if (XEXP (x, 0) == dest_reg\n+      if (rtx_equal_p (XEXP (x, 0), dest_reg)\n \t  || (GET_CODE (XEXP (x, 0)) == SUBREG\n \t      && SUBREG_PROMOTED_VAR_P (XEXP (x, 0))\n \t      && SUBREG_REG (XEXP (x, 0)) == dest_reg))\n  \targ = XEXP (x, 1);\n-      else if (XEXP (x, 1) == dest_reg\n+      else if (rtx_equal_p (XEXP (x, 1), dest_reg)\n \t       || (GET_CODE (XEXP (x, 1)) == SUBREG\n \t\t   && SUBREG_PROMOTED_VAR_P (XEXP (x, 1))\n \t\t   && SUBREG_REG (XEXP (x, 1)) == dest_reg))\n@@ -5226,30 +5268,36 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val)\n       return 0;\n \n     case REG:\n-      /* If this register is assigned in the previous insn, look at its\n+      /* If this register is assigned in a previous insn, look at its\n \t source, but don't go outside the loop or past a label.  */\n \n-      for (insn = PREV_INSN (p);\n-\t   (insn && GET_CODE (insn) == NOTE\n-\t    && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG);\n-\t   insn = PREV_INSN (insn))\n-\t;\n+      insn = p;\n+      while (1)\n+\t{\n+\t  do {\n+\t    insn = PREV_INSN (insn);\n+\t  } while (insn && GET_CODE (insn) == NOTE\n+\t           && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG);\n \n-      if (insn)\n-\tset = single_set (insn);\n+          if (!insn)\n+\t    break;\n+\t  set = single_set (insn);\n+\t  if (set == 0)\n+\t    break;\n \n-      if (set != 0\n-\t  && (SET_DEST (set) == x\n-\t      || (GET_CODE (SET_DEST (set)) == SUBREG\n-\t\t  && (GET_MODE_SIZE (GET_MODE (SET_DEST (set)))\n-\t\t      <= UNITS_PER_WORD)\n-\t\t  && SUBREG_REG (SET_DEST (set)) == x)))\n-\treturn basic_induction_var (SET_SRC (set),\n-\t\t\t\t    (GET_MODE (SET_SRC (set)) == VOIDmode\n-\t\t\t\t     ? GET_MODE (x)\n-\t\t\t\t     : GET_MODE (SET_SRC (set))),\n-\t\t\t\t    dest_reg, insn,\n-\t\t\t\t    inc_val, mult_val);\n+\t  if ((SET_DEST (set) == x\n+\t       || (GET_CODE (SET_DEST (set)) == SUBREG\n+\t\t   && (GET_MODE_SIZE (GET_MODE (SET_DEST (set)))\n+\t\t       <= UNITS_PER_WORD)\n+\t\t   && SUBREG_REG (SET_DEST (set)) == x))\n+\t      && basic_induction_var (SET_SRC (set),\n+\t\t\t\t      (GET_MODE (SET_SRC (set)) == VOIDmode\n+\t\t\t\t       ? GET_MODE (x)\n+\t\t\t\t       : GET_MODE (SET_SRC (set))),\n+\t\t\t\t      dest_reg, insn,\n+\t\t\t\t      inc_val, mult_val))\n+\t    return 1;\n+\t}\n       /* ... fall through ...  */\n \n       /* Can accept constant setting of biv only when inside inner most loop.\n@@ -5280,6 +5328,7 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val)\n     case SIGN_EXTEND:\n       return basic_induction_var (XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n \t\t\t\t  dest_reg, p, inc_val, mult_val);\n+\n     case ASHIFTRT:\n       /* Similar, since this can be a sign extension.  */\n       for (insn = PREV_INSN (p);\n@@ -5321,14 +5370,15 @@ basic_induction_var (x, mode, dest_reg, p, inc_val, mult_val)\n      such that the value of X is biv * mult + add;  */\n \n static int\n-general_induction_var (x, src_reg, add_val, mult_val)\n+general_induction_var (x, src_reg, add_val, mult_val, is_addr, pbenefit)\n      rtx x;\n      rtx *src_reg;\n      rtx *add_val;\n      rtx *mult_val;\n+     int is_addr;\n+     int *pbenefit;\n {\n   rtx orig_x = x;\n-  int benefit = 0;\n   char *storage;\n \n   /* If this is an invariant, forget it, it isn't a giv.  */\n@@ -5338,7 +5388,8 @@ general_induction_var (x, src_reg, add_val, mult_val)\n   /* See if the expression could be a giv and get its form.\n      Mark our place on the obstack in case we don't find a giv.  */\n   storage = (char *) oballoc (0);\n-  x = simplify_giv_expr (x, &benefit);\n+  *pbenefit = 0;\n+  x = simplify_giv_expr (x, pbenefit);\n   if (x == 0)\n     {\n       obfree (storage);\n@@ -5398,12 +5449,21 @@ general_induction_var (x, src_reg, add_val, mult_val)\n   if (GET_CODE (*mult_val) == USE)\n     *mult_val = XEXP (*mult_val, 0);\n \n-  benefit += rtx_cost (orig_x, SET);\n+  if (is_addr)\n+    {\n+#ifdef ADDRESS_COST\n+      *pbenefit += ADDRESS_COST (orig_x) - reg_address_cost;\n+#else\n+      *pbenefit += rtx_cost (orig_x, MEM) - reg_address_cost;\n+#endif\n+    }\n+  else\n+    *pbenefit += rtx_cost (orig_x, SET);\n \n-  /* Always return some benefit if this is a giv so it will be detected\n-     as such.  This allows elimination of bivs that might otherwise\n-     not be eliminated.  */\n-  return benefit == 0 ? 1 : benefit;\n+  /* Always return true if this is a giv so it will be detected as such,\n+     even if the benefit is zero or negative.  This allows elimination  \n+     of bivs that might otherwise not be eliminated.  */                \n+  return 1;                                                             \n }\n \f\n /* Given an expression, X, try to form it as a linear function of a biv.\n@@ -5426,6 +5486,9 @@ general_induction_var (x, src_reg, add_val, mult_val)\n \n    *BENEFIT will be incremented by the benefit of any sub-giv encountered.  */\n \n+static rtx sge_plus PROTO ((enum machine_mode, rtx, rtx));\n+static rtx sge_plus_constant PROTO ((rtx, rtx));\n+\n static rtx\n simplify_giv_expr (x, benefit)\n      rtx x;\n@@ -5440,20 +5503,22 @@ simplify_giv_expr (x, benefit)\n   if (mode != VOIDmode\n       && (GET_MODE_CLASS (mode) != MODE_INT\n \t  || GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT))\n-    return 0;\n+    return NULL_RTX;\n \n   switch (GET_CODE (x))\n     {\n     case PLUS:\n       arg0 = simplify_giv_expr (XEXP (x, 0), benefit);\n       arg1 = simplify_giv_expr (XEXP (x, 1), benefit);\n       if (arg0 == 0 || arg1 == 0)\n-\treturn 0;\n+\treturn NULL_RTX;\n \n       /* Put constant last, CONST_INT last if both constant.  */\n       if ((GET_CODE (arg0) == USE\n \t   || GET_CODE (arg0) == CONST_INT)\n-\t  && GET_CODE (arg1) != CONST_INT)\n+\t  && ! ((GET_CODE (arg0) == USE\n+\t\t && GET_CODE (arg1) == USE)\n+\t\t|| GET_CODE (arg1) == CONST_INT))\n \ttem = arg0, arg0 = arg1, arg1 = tem;\n \n       /* Handle addition of zero, then addition of an invariant.  */\n@@ -5464,29 +5529,22 @@ simplify_giv_expr (x, benefit)\n \t  {\n \t  case CONST_INT:\n \t  case USE:\n-\t    /* Both invariant.  Only valid if sum is machine operand.\n-\t       First strip off possible USE on the operands.  */\n+\t    /* Adding two invariants must result in an invariant, so enclose\n+ \t       addition operation inside a USE and return it.  */\n \t    if (GET_CODE (arg0) == USE)\n \t      arg0 = XEXP (arg0, 0);\n-\n \t    if (GET_CODE (arg1) == USE)\n \t      arg1 = XEXP (arg1, 0);\n \n-\t    tem = 0;\n-\t    if (CONSTANT_P (arg0) && GET_CODE (arg1) == CONST_INT)\n-\t      {\n-\t\ttem = plus_constant (arg0, INTVAL (arg1));\n-\t\tif (GET_CODE (tem) != CONST_INT)\n-\t\t  tem = gen_rtx_USE (mode, tem);\n-\t      }\n+\t    if (GET_CODE (arg0) == CONST_INT)\n+\t      tem = arg0, arg0 = arg1, arg1 = tem;\n+\t    if (GET_CODE (arg1) == CONST_INT)\n+\t      tem = sge_plus_constant (arg0, arg1);\n \t    else\n-\t      {\n-\t\t/* Adding two invariants must result in an invariant,\n-\t\t   so enclose addition operation inside a USE and\n-\t\t   return it.  */\n-\t\ttem = gen_rtx_USE (mode, gen_rtx_PLUS (mode, arg0, arg1));\n-\t      }\n+\t      tem = sge_plus (mode, arg0, arg1);\n \n+\t    if (GET_CODE (tem) != CONST_INT)\n+\t      tem = gen_rtx_USE (mode, tem);\n \t    return tem;\n \n \t  case REG:\n@@ -5496,11 +5554,10 @@ simplify_giv_expr (x, benefit)\n \n \t  case PLUS:\n \t    /* (a + invar_1) + invar_2.  Associate.  */\n-\t    return simplify_giv_expr (gen_rtx_PLUS (mode,\n-\t\t\t\t\t\t    XEXP (arg0, 0),\n-\t\t\t\t\t\t    gen_rtx_PLUS (mode,\n-\t\t\t\t\t\t\t\t  XEXP (arg0, 1), arg1)),\n-\t\t\t\t      benefit);\n+\t    return simplify_giv_expr (\n+\t\tgen_rtx_PLUS (mode, XEXP (arg0, 0),\n+\t\t\t      gen_rtx_PLUS (mode, XEXP (arg0, 1), arg1)),\n+\t\tbenefit);\n \n \t  default:\n \t    abort ();\n@@ -5528,10 +5585,10 @@ simplify_giv_expr (x, benefit)\n \n       /* Now must have MULT + MULT.  Distribute if same biv, else not giv.  */\n       if (GET_CODE (arg0) != MULT || GET_CODE (arg1) != MULT)\n-\tabort ();\n+\treturn NULL_RTX;\n \n-      if (XEXP (arg0, 0) != XEXP (arg1, 0))\n-\treturn 0;\n+      if (!rtx_equal_p (arg0, arg1))\n+\treturn NULL_RTX;\n \n       return simplify_giv_expr (gen_rtx_MULT (mode,\n \t\t\t\t\t      XEXP (arg0, 0),\n@@ -5552,7 +5609,7 @@ simplify_giv_expr (x, benefit)\n       arg0 = simplify_giv_expr (XEXP (x, 0), benefit);\n       arg1 = simplify_giv_expr (XEXP (x, 1), benefit);\n       if (arg0 == 0 || arg1 == 0)\n-\treturn 0;\n+\treturn NULL_RTX;\n \n       /* Put constant last, CONST_INT last if both constant.  */\n       if ((GET_CODE (arg0) == USE || GET_CODE (arg0) == CONST_INT)\n@@ -5561,7 +5618,7 @@ simplify_giv_expr (x, benefit)\n \n       /* If second argument is not now constant, not giv.  */\n       if (GET_CODE (arg1) != USE && GET_CODE (arg1) != CONST_INT)\n-\treturn 0;\n+\treturn NULL_RTX;\n \n       /* Handle multiply by 0 or 1.  */\n       if (arg1 == const0_rtx)\n@@ -5581,8 +5638,25 @@ simplify_giv_expr (x, benefit)\n \t  return GEN_INT (INTVAL (arg0) * INTVAL (arg1));\n \n \tcase USE:\n-\t  /* invar * invar.  Not giv.  */\n-\t  return 0;\n+\t  /* invar * invar.  It is a giv, but very few of these will \n+\t     actually pay off, so limit to simple registers.  */\n+\t  if (GET_CODE (arg1) != CONST_INT)\n+\t    return NULL_RTX;\n+\n+\t  arg0 = XEXP (arg0, 0);\n+\t  if (GET_CODE (arg0) == REG)\n+\t    tem = gen_rtx_MULT (mode, arg0, arg1);\n+\t  else if (GET_CODE (arg0) == MULT\n+\t\t   && GET_CODE (XEXP (arg0, 0)) == REG\n+\t\t   && GET_CODE (XEXP (arg0, 1)) == CONST_INT)\n+\t    {\n+\t      tem = gen_rtx_MULT (mode, XEXP (arg0, 0), \n+\t\t\t\t  GEN_INT (INTVAL (XEXP (arg0, 1))\n+\t\t\t\t\t   * INTVAL (arg1)));\n+\t    }\n+\t  else\n+\t    return NULL_RTX;\n+\t  return gen_rtx_USE (mode, tem);\n \n \tcase MULT:\n \t  /* (a * invar_1) * invar_2.  Associate.  */\n@@ -5663,6 +5737,72 @@ simplify_giv_expr (x, benefit)\n \t  }\n \n \tdefault:\n+\t  /* If it isn't an induction variable, and it is invariant, we\n+\t     may be able to simplify things further by looking through\n+\t     the bits we just moved outside the loop.  */\n+\t  if (invariant_p (x) == 1)\n+\t    {\n+\t      struct movable *m;\n+\n+\t      for (m = the_movables; m ; m = m->next)\n+\t\tif (rtx_equal_p (x, m->set_dest))\n+\t\t  {\n+\t\t    /* Ok, we found a match.  Substitute and simplify.  */\n+\n+\t\t    /* If we match another movable, we must use that, as \n+\t\t       this one is going away.  */\n+\t\t    if (m->match)\n+\t\t      return simplify_giv_expr (m->match->set_dest, benefit);\n+\n+\t\t    /* If consec is non-zero, this is a member of a group of\n+\t\t       instructions that were moved together.  We handle this\n+\t\t       case only to the point of seeking to the last insn and\n+\t\t       looking for a REG_EQUAL.  Fail if we don't find one.  */\n+\t\t    if (m->consec != 0)\n+\t\t      {\n+\t\t\tint i = m->consec;\n+\t\t\ttem = m->insn;\n+\t\t\tdo { tem = NEXT_INSN (tem); } while (--i > 0);\n+\n+\t\t\ttem = find_reg_note (tem, REG_EQUAL, NULL_RTX);\n+\t\t\tif (tem)\n+\t\t\t  tem = XEXP (tem, 0);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t        tem = single_set (m->insn);\n+\t\t        if (tem)\n+\t\t\t  tem = SET_SRC (tem);\n+\t\t      }\n+\n+\t\t    if (tem)\n+\t\t      {\n+\t\t\t/* What we are most interested in is pointer\n+\t\t\t   arithmetic on invariants -- only take\n+\t\t\t   patterns we may be able to do something with.  */\n+\t\t\tif (GET_CODE (tem) == PLUS\n+\t\t\t    || GET_CODE (tem) == MULT\n+\t\t\t    || GET_CODE (tem) == ASHIFT\n+\t\t\t    || GET_CODE (tem) == CONST_INT\n+\t\t\t    || GET_CODE (tem) == SYMBOL_REF)\n+\t\t\t  {\n+\t\t\t    tem = simplify_giv_expr (tem, benefit);\n+\t\t\t    if (tem)\n+\t\t\t      return tem;\n+\t\t\t  }\n+\t\t\telse if (GET_CODE (tem) == CONST\n+\t\t\t    && GET_CODE (XEXP (tem, 0)) == PLUS\n+\t\t\t    && GET_CODE (XEXP (XEXP (tem, 0), 0)) == SYMBOL_REF\n+\t\t\t    && GET_CODE (XEXP (XEXP (tem, 0), 1)) == CONST_INT)\n+\t\t\t  {\n+\t\t\t    tem = simplify_giv_expr (XEXP (tem, 0), benefit);\n+\t\t\t    if (tem)\n+\t\t\t      return tem;\n+\t\t\t  }\n+\t\t      }\n+\t\t    break;\n+\t\t  }\n+\t    }\n \t  break;\n \t}\n \n@@ -5677,13 +5817,67 @@ simplify_giv_expr (x, benefit)\n \t{\n \t  if (GET_CODE (x) == CONST_INT)\n \t    return x;\n-\t  else\n-\t    return gen_rtx_USE (mode, x);\n+\t  if (GET_CODE (x) == CONST\n+\t      && GET_CODE (XEXP (x, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+\t    x = XEXP (x, 0);\n+\t  return gen_rtx_USE (mode, x);\n \t}\n       else\n \treturn 0;\n     }\n }\n+\n+/* This routine folds invariants such that there is only ever one\n+   CONST_INT in the summation.  It is only used by simplify_giv_expr.  */\n+\n+static rtx\n+sge_plus_constant (x, c)\n+     rtx x, c;\n+{\n+  if (GET_CODE (x) == CONST_INT)\n+    return GEN_INT (INTVAL (x) + INTVAL (c));\n+  else if (GET_CODE (x) != PLUS)\n+    return gen_rtx_PLUS (GET_MODE (x), x, c);\n+  else if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      return gen_rtx_PLUS (GET_MODE (x), XEXP (x, 0),\n+\t\t\t   GEN_INT (INTVAL (XEXP (x, 1)) + INTVAL (c)));\n+    }\n+  else if (GET_CODE (XEXP (x, 0)) == PLUS\n+\t   || GET_CODE (XEXP (x, 1)) != PLUS)\n+    {\n+      return gen_rtx_PLUS (GET_MODE (x),\n+\t\t\t   sge_plus_constant (XEXP (x, 0), c), XEXP (x, 1));\n+    }\n+  else\n+    {\n+      return gen_rtx_PLUS (GET_MODE (x),\n+\t\t\t   sge_plus_constant (XEXP (x, 1), c), XEXP (x, 0));\n+    }\n+}\n+\n+static rtx\n+sge_plus (mode, x, y)\n+     enum machine_mode mode;\n+     rtx x, y;\n+{\n+  while (GET_CODE (y) == PLUS)\n+    {\n+      rtx a = XEXP (y, 0);\n+      if (GET_CODE (a) == CONST_INT)\n+\tx = sge_plus_constant (x, a);\n+      else\n+\tx = gen_rtx_PLUS (mode, x, a);\n+      y = XEXP (y, 1);\n+    }\n+  if (GET_CODE (y) == CONST_INT)\n+    x = sge_plus_constant (x, y);\n+  else\n+    x = gen_rtx_PLUS (mode, x, y);\n+  return x;\n+}\n \f\n /* Help detect a giv that is calculated by several consecutive insns;\n    for example,\n@@ -5754,12 +5948,12 @@ consec_sets_giv (first_benefit, p, src_reg, dest_reg,\n \t  && (set = single_set (p))\n \t  && GET_CODE (SET_DEST (set)) == REG\n \t  && SET_DEST (set) == dest_reg\n-\t  && ((benefit = general_induction_var (SET_SRC (set), &src_reg,\n-\t\t\t\t\t\tadd_val, mult_val))\n+\t  && (general_induction_var (SET_SRC (set), &src_reg,\n+\t\t\t\t     add_val, mult_val, 0, &benefit)\n \t      /* Giv created by equivalent expression.  */\n \t      || ((temp = find_reg_note (p, REG_EQUAL, NULL_RTX))\n-\t\t  && (benefit = general_induction_var (XEXP (temp, 0), &src_reg,\n-\t\t\t\t\t\t       add_val, mult_val))))\n+\t\t  && general_induction_var (XEXP (temp, 0), &src_reg,\n+\t\t\t\t\t    add_val, mult_val, 0, &benefit)))\n \t  && src_reg == v->src_reg)\n \t{\n \t  if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n@@ -5794,13 +5988,110 @@ consec_sets_giv (first_benefit, p, src_reg, dest_reg,\n    it cannot possibly be a valid address, 0 is returned. \n \n    To perform the computation, we note that\n-   \tG1 = a * v + b\t\tand\n-\tG2 = c * v + d\n+   \tG1 = x * v + a\t\tand\n+\tG2 = y * v + b\n    where `v' is the biv.\n \n-   So G2 = (c/a) * G1 + (d - b*c/a)  */\n+   So G2 = (y/b) * G1 + (b - a*y/x).\n+\n+   Note that MULT = y/x.\n+\n+   Update: A and B are now allowed to be additive expressions such that\n+   B contains all variables in A.  That is, computing B-A will not require\n+   subtracting variables.  */\n+\n+static rtx\n+express_from_1 (a, b, mult)\n+     rtx a, b, mult;\n+{\n+  /* If MULT is zero, then A*MULT is zero, and our expression is B.  */\n+\n+  if (mult == const0_rtx)\n+    return b;\n+\n+  /* If MULT is not 1, we cannot handle A with non-constants, since we\n+     would then be required to subtract multiples of the registers in A.\n+     This is theoretically possible, and may even apply to some Fortran\n+     constructs, but it is a lot of work and we do not attempt it here.  */\n+\n+  if (mult != const1_rtx && GET_CODE (a) != CONST_INT)\n+    return NULL_RTX;\n+\n+  /* In general these structures are sorted top to bottom (down the PLUS\n+     chain), but not left to right across the PLUS.  If B is a higher\n+     order giv than A, we can strip one level and recurse.  If A is higher\n+     order, we'll eventually bail out, but won't know that until the end.\n+     If they are the same, we'll strip one level around this loop.  */\n+\n+  while (GET_CODE (a) == PLUS && GET_CODE (b) == PLUS)\n+    {\n+      rtx ra, rb, oa, ob, tmp;\n+\n+      ra = XEXP (a, 0), oa = XEXP (a, 1);\n+      if (GET_CODE (ra) == PLUS)\n+        tmp = ra, ra = oa, oa = tmp;\n+\n+      rb = XEXP (b, 0), ob = XEXP (b, 1);\n+      if (GET_CODE (rb) == PLUS)\n+        tmp = rb, rb = ob, ob = tmp;\n+\n+      if (rtx_equal_p (ra, rb))\n+\t/* We matched: remove one reg completely.  */\n+\ta = oa, b = ob;\n+      else if (GET_CODE (ob) != PLUS && rtx_equal_p (ra, ob))\n+\t/* An alternate match.  */\n+\ta = oa, b = rb;\n+      else if (GET_CODE (oa) != PLUS && rtx_equal_p (oa, rb))\n+\t/* An alternate match.  */\n+\ta = ra, b = ob;\n+      else\n+\t{\n+          /* Indicates an extra register in B.  Strip one level from B and \n+\t     recurse, hoping B was the higher order expression.  */\n+\t  ob = express_from_1 (a, ob, mult);\n+\t  if (ob == NULL_RTX)\n+\t    return NULL_RTX;\n+\t  return gen_rtx_PLUS (GET_MODE (b), rb, ob);\n+\t}\n+    }\n+\n+  /* Here we are at the last level of A, go through the cases hoping to\n+     get rid of everything but a constant.  */\n+\n+  if (GET_CODE (a) == PLUS)\n+    {\n+      rtx ra, oa, tmp;\n+\n+      ra = XEXP (a, 0), oa = XEXP (a, 1);\n+      if (rtx_equal_p (oa, b))\n+\toa = ra;\n+      else if (!rtx_equal_p (ra, b))\n+\treturn NULL_RTX;\n+\n+      if (GET_CODE (oa) != CONST_INT)\n+\treturn NULL_RTX;\n+\n+      return GEN_INT (-INTVAL (oa) * INTVAL (mult));\n+    }\n+  else if (GET_CODE (a) == CONST_INT)\n+    {\n+      return plus_constant (b, -INTVAL (a) * INTVAL (mult));\n+    }\n+  else if (GET_CODE (b) == PLUS)\n+    {\n+      if (rtx_equal_p (a, XEXP (b, 0)))\n+\treturn XEXP (b, 1);\n+      else if (rtx_equal_p (a, XEXP (b, 1)))\n+\treturn XEXP (b, 0);\n+      else\n+\treturn NULL_RTX;\n+    }\n+  else if (rtx_equal_p (a, b))\n+    return const0_rtx;\n+\n+  return NULL_RTX;\n+}\n \n-#ifdef ADDRESS_COST\n static rtx\n express_from (g1, g2)\n      struct induction *g1, *g2;\n@@ -5810,15 +6101,25 @@ express_from (g1, g2)\n   /* The value that G1 will be multiplied by must be a constant integer.  Also,\n      the only chance we have of getting a valid address is if b*c/a (see above\n      for notation) is also an integer.  */\n-  if (GET_CODE (g1->mult_val) != CONST_INT\n-      || GET_CODE (g2->mult_val) != CONST_INT\n-      || GET_CODE (g1->add_val) != CONST_INT\n-      || g1->mult_val == const0_rtx\n-      || INTVAL (g2->mult_val) % INTVAL (g1->mult_val) != 0)\n-    return 0;\n+  if (GET_CODE (g1->mult_val) == CONST_INT\n+      && GET_CODE (g2->mult_val) == CONST_INT)\n+    {\n+      if (g1->mult_val == const0_rtx\n+          || INTVAL (g2->mult_val) % INTVAL (g1->mult_val) != 0)\n+        return NULL_RTX;\n+      mult = GEN_INT (INTVAL (g2->mult_val) / INTVAL (g1->mult_val));\n+    }\n+  else if (rtx_equal_p (g1->mult_val, g2->mult_val))\n+    mult = const1_rtx;\n+  else\n+    {\n+      /* ??? Find out if the one is a multiple of the other?  */\n+      return NULL_RTX;\n+    }\n \n-  mult = GEN_INT (INTVAL (g2->mult_val) / INTVAL (g1->mult_val));\n-  add = plus_constant (g2->add_val, - INTVAL (g1->add_val) * INTVAL (mult));\n+  add = express_from_1 (g1->add_val, g2->add_val, mult);\n+  if (add == NULL_RTX)\n+    return NULL_RTX;\n \n   /* Form simplified final result.  */\n   if (mult == const0_rtx)\n@@ -5833,59 +6134,101 @@ express_from (g1, g2)\n   else\n     return gen_rtx_PLUS (g2->mode, mult, add);\n }\n-#endif\n \f\n /* Return 1 if giv G2 can be combined with G1.  This means that G2 can use\n    (either directly or via an address expression) a register used to represent\n    G1.  Set g2->new_reg to a represtation of G1 (normally just\n    g1->dest_reg).  */\n \n-static int\n+static rtx\n combine_givs_p (g1, g2)\n      struct induction *g1, *g2;\n {\n-#ifdef ADDRESS_COST\n-  rtx tem;\n-#endif\n+  rtx tem = express_from (g1, g2);\n \n-  /* If these givs are identical, they can be combined.  */\n-  if (rtx_equal_p (g1->mult_val, g2->mult_val)\n-      && rtx_equal_p (g1->add_val, g2->add_val))\n+  /* If these givs are identical, they can be combined.  We use the results\n+     of express_from because the addends are not in a canonical form, so\n+     rtx_equal_p is a weaker test.  */\n+  if (tem == const0_rtx)\n     {\n-      g2->new_reg = g1->dest_reg;\n-      return 1;\n+      return g1->dest_reg;\n     }\n \n-#ifdef ADDRESS_COST\n   /* If G2 can be expressed as a function of G1 and that function is valid\n      as an address and no more expensive than using a register for G2,\n      the expression of G2 in terms of G1 can be used.  */\n-  if (g2->giv_type == DEST_ADDR\n-      && (tem = express_from (g1, g2)) != 0\n+  if (tem != NULL_RTX\n+      && g2->giv_type == DEST_ADDR\n       && memory_address_p (g2->mem_mode, tem)\n-      && ADDRESS_COST (tem) <= ADDRESS_COST (*g2->location))\n+      /* ??? Looses, especially with -fforce-addr, where *g2->location\n+\t will always be a register, and so anything more complicated\n+\t gets discarded.  */\n+#if 0\n+#ifdef ADDRESS_COST\n+      && ADDRESS_COST (tem) <= ADDRESS_COST (*g2->location)\n+#else\n+      && rtx_cost (tem, MEM) <= rtx_cost (*g2->location, MEM)\n+#endif\n+#endif\n+      )\n     {\n-      g2->new_reg = tem;\n-      return 1;\n+      return tem;\n     }\n-#endif\n \n-  return 0;\n+  return NULL_RTX;\n }\n \f\n-#ifdef GIV_SORT_CRITERION\n-/* Compare two givs and sort the most desirable one for combinations first.\n-   This is used only in one qsort call below.  */\n+struct combine_givs_stats\n+{\n+  int giv_number;\n+  int total_benefit;\n+};\n+\n+static int\n+cmp_combine_givs_stats (x, y)\n+     struct combine_givs_stats *x, *y;\n+{\n+  int d;\n+  d = y->total_benefit - x->total_benefit;\n+  /* Stabilize the sort.  */\n+  if (!d)\n+    d = x->giv_number - y->giv_number;\n+  return d;\n+}\n+\n+/* If one of these givs is a DEST_REG that was only used once, by the\n+   other giv, this is actually a single use.  Return 0 if this is not\n+   the case, -1 if g1 is the DEST_REG involved, and 1 if it was g2.  */\n \n static int\n-giv_sort (x, y)\n-     struct induction **x, **y;\n+combine_givs_used_once (g1, g2)\n+     struct induction *g1, *g2;\n {\n-  GIV_SORT_CRITERION (*x, *y);\n+  if (g1->giv_type == DEST_REG\n+      && n_times_used[REGNO (g1->dest_reg)] == 1\n+      && reg_mentioned_p (g1->dest_reg, PATTERN (g2->insn)))\n+    return -1;\n+\n+  if (g2->giv_type == DEST_REG\n+      && n_times_used[REGNO (g2->dest_reg)] == 1\n+      && reg_mentioned_p (g2->dest_reg, PATTERN (g1->insn)))\n+    return 1;\n \n   return 0;\n }\n-#endif\n+ \n+static int\n+combine_givs_benefit_from (g1, g2)\n+     struct induction *g1, *g2;\n+{\n+  int tmp = combine_givs_used_once (g1, g2);\n+  if (tmp < 0)\n+    return 0;\n+  else if (tmp > 0)\n+    return g2->benefit - g1->benefit;\n+  else\n+    return g2->benefit;\n+}\n \n /* Check all pairs of givs for iv_class BL and see if any can be combined with\n    any other.  If so, point SAME to the giv combined with and set NEW_REG to\n@@ -5897,80 +6240,155 @@ combine_givs (bl)\n      struct iv_class *bl;\n {\n   struct induction *g1, *g2, **giv_array;\n-  int i, j, giv_count, pass;\n+  int i, j, k, giv_count;\n+  struct combine_givs_stats *stats;\n+  rtx *can_combine;\n \n   /* Count givs, because bl->giv_count is incorrect here.  */\n   giv_count = 0;\n   for (g1 = bl->giv; g1; g1 = g1->next_iv)\n-    giv_count++;\n+    if (!g1->ignore)\n+      giv_count++;\n \n   giv_array\n     = (struct induction **) alloca (giv_count * sizeof (struct induction *));\n   i = 0;\n   for (g1 = bl->giv; g1; g1 = g1->next_iv)\n-    giv_array[i++] = g1;\n+    if (!g1->ignore)\n+      giv_array[i++] = g1;\n \n-#ifdef GIV_SORT_CRITERION\n-  /* Sort the givs if GIV_SORT_CRITERION is defined.\n-     This is usually defined for processors which lack\n-     negative register offsets so more givs may be combined.  */\n+  stats = (struct combine_givs_stats *) alloca (giv_count * sizeof (*stats));\n+  bzero (stats, giv_count * sizeof (*stats));\n \n-  if (loop_dump_stream)\n-    fprintf (loop_dump_stream, \"%d givs counted, sorting...\\n\", giv_count);\n-\n-  qsort (giv_array, giv_count, sizeof (struct induction *), giv_sort);\n-#endif\n+  can_combine = (rtx *) alloca (giv_count * giv_count * sizeof(rtx));\n+  bzero (can_combine, giv_count * giv_count * sizeof(rtx));\n \n   for (i = 0; i < giv_count; i++)\n     {\n+      int this_benefit;\n+\n       g1 = giv_array[i];\n-      for (pass = 0; pass <= 1; pass++)\n-\tfor (j = 0; j < giv_count; j++)\n-\t  {\n-\t    g2 = giv_array[j];\n-\t    if (g1 != g2\n-\t\t/* First try to combine with replaceable givs, then all givs.  */\n-\t\t&& (g1->replaceable || pass == 1)\n-\t\t/* If either has already been combined or is to be ignored, can't\n-\t\t   combine.  */\n-\t\t&& ! g1->ignore && ! g2->ignore && ! g1->same && ! g2->same\n-\t\t/* If something has been based on G2, G2 cannot itself be based\n-\t\t   on something else.  */\n-\t\t&& ! g2->combined_with\n-\t\t&& combine_givs_p (g1, g2))\n-\t      {\n-\t\t/* g2->new_reg set by `combine_givs_p'  */\n-\t\tg2->same = g1;\n-\t\tg1->combined_with = 1;\n-\n-\t\t/* If one of these givs is a DEST_REG that was only used\n-\t\t   once, by the other giv, this is actually a single use.\n-\t\t   The DEST_REG has the correct cost, while the other giv\n-\t\t   counts the REG use too often.  */\n-\t\tif (g2->giv_type == DEST_REG\n-\t\t    && n_times_used[REGNO (g2->dest_reg)] == 1\n-\t\t    && reg_mentioned_p (g2->dest_reg, PATTERN (g1->insn)))\n-\t\t  g1->benefit = g2->benefit;\n-\t\telse if (g1->giv_type != DEST_REG\n-\t\t\t || n_times_used[REGNO (g1->dest_reg)] != 1\n-\t\t\t || ! reg_mentioned_p (g1->dest_reg,\n-\t\t\t\t\t       PATTERN (g2->insn)))\n-\t\t  {\n-\t\t    g1->benefit += g2->benefit;\n-\t\t    g1->times_used += g2->times_used;\n-\t\t  }\n-\t\t/* ??? The new final_[bg]iv_value code does a much better job\n-\t\t   of finding replaceable giv's, and hence this code may no\n-\t\t   longer be necessary.  */\n-\t\tif (! g2->replaceable && REG_USERVAR_P (g2->dest_reg))\n-\t\t  g1->benefit -= copy_cost;\n-\t\tg1->lifetime += g2->lifetime;\n+\n+      this_benefit = g1->benefit;\n+      /* Add an additional weight for zero addends.  */\n+      if (g1->no_const_addval)\n+\tthis_benefit += 1;\n+      for (j = 0; j < giv_count; j++)\n+\t{\n+\t  rtx this_combine;\n+\n+\t  g2 = giv_array[j];\n+\t  if (g1 != g2\n+\t      && (this_combine = combine_givs_p (g1, g2)) != NULL_RTX)\n+\t    {\n+\t      can_combine[i*giv_count + j] = this_combine;\n+\t      this_benefit += combine_givs_benefit_from (g1, g2);\n+\t      /* Add an additional weight for being reused more times.  */\n+\t      this_benefit += 3;\n+\t    }\n+\t}\n+      stats[i].giv_number = i;\n+      stats[i].total_benefit = this_benefit;\n+    }\n+\n+  /* Iterate, combining until we can't.  */\n+restart:\n+  qsort (stats, giv_count, sizeof(*stats), cmp_combine_givs_stats);\n+\n+  if (loop_dump_stream)\n+    {\n+      fprintf (loop_dump_stream, \"Sorted combine statistics:\\n\");\n+      for (k = 0; k < giv_count; k++)\n+\t{\n+\t  g1 = giv_array[stats[k].giv_number];\n+\t  if (!g1->combined_with && !g1->same)\n+\t    fprintf (loop_dump_stream, \" {%d, %d}\", \n+\t\t     INSN_UID (giv_array[stats[k].giv_number]->insn),\n+\t\t     stats[k].total_benefit);\n+\t}\n+      putc ('\\n', loop_dump_stream);\n+    }\n+\n+  for (k = 0; k < giv_count; k++)\n+    {\n+      int g1_add_benefit = 0;\n+\n+      i = stats[k].giv_number;\n+      g1 = giv_array[i];\n+\n+      /* If it has already been combined, skip.  */\n+      if (g1->combined_with || g1->same)\n+\tcontinue;\n+\n+      for (j = 0; j < giv_count; j++)\n+\t{\n+\t  g2 = giv_array[j];\n+\t  if (g1 != g2 && can_combine[i*giv_count + j]\n+\t      /* If it has already been combined, skip.  */\n+\t      && ! g2->same && ! g2->combined_with)\n+\t    {\n+\t      int l;\n+\n+\t      g2->new_reg = can_combine[i*giv_count + j];\n+\t      g2->same = g1;\n+\t      g1->combined_with = 1;\n+\t      if (!combine_givs_used_once (g1, g2))\n+\t\tg1->times_used += 1;\n+\t      g1->lifetime += g2->lifetime;\n+\n+\t      g1_add_benefit += combine_givs_benefit_from (g1, g2);\n+\n+\t      /* ??? The new final_[bg]iv_value code does a much better job\n+\t\t of finding replaceable giv's, and hence this code may no\n+\t\t longer be necessary.  */\n+\t      if (! g2->replaceable && REG_USERVAR_P (g2->dest_reg))\n+\t\tg1_add_benefit -= copy_cost;\n \t\t\n-\t\tif (loop_dump_stream)\n-\t\t  fprintf (loop_dump_stream, \"giv at %d combined with giv at %d\\n\",\n-\t\t\t   INSN_UID (g2->insn), INSN_UID (g1->insn));\n-\t      }\n-\t  }\n+\t      /* To help optimize the next set of combinations, remove\n+\t\t this giv from the benefits of other potential mates.  */\n+\t      for (l = 0; l < giv_count; ++l)\n+\t\t{\n+\t\t  int m = stats[l].giv_number;\n+\t\t  if (can_combine[m*giv_count + j])\n+\t\t    {\n+\t\t      /* Remove additional weight for being reused.  */\n+\t\t      stats[l].total_benefit -= 3 + \n+\t\t\tcombine_givs_benefit_from (giv_array[m], g2);\n+\t\t    }\n+\t\t}\n+\n+\t      if (loop_dump_stream)\n+\t\tfprintf (loop_dump_stream,\n+\t\t\t \"giv at %d combined with giv at %d\\n\",\n+\t\t\t INSN_UID (g2->insn), INSN_UID (g1->insn));\n+\t    }\n+\t}\n+\n+      /* To help optimize the next set of combinations, remove\n+\t this giv from the benefits of other potential mates.  */\n+      if (g1->combined_with)\n+\t{\n+\t  for (j = 0; j < giv_count; ++j)\n+\t    {\n+\t      int m = stats[j].giv_number;\n+\t      if (can_combine[m*giv_count + j])\n+\t\t{\n+\t\t  /* Remove additional weight for being reused.  */\n+\t\t  stats[j].total_benefit -= 3 + \n+\t\t    combine_givs_benefit_from (giv_array[m], g1);\n+\t\t}\n+\t    }\n+\n+\t  g1->benefit += g1_add_benefit;\n+\n+\t  /* We've finished with this giv, and everything it touched.\n+\t     Restart the combination so that proper weights for the \n+\t     rest of the givs are properly taken into account.  */\n+\t  /* ??? Ideally we would compact the arrays at this point, so\n+\t     as to not cover old ground.  But sanely compacting\n+\t     can_combine is tricky.  */\n+\t  goto restart;\n+\t}\n     }\n }\n \f\n@@ -7262,8 +7680,8 @@ get_condition_for_loop (x)\n     loop_comparison_code[loop_num] */\n \n #ifdef HAVE_decrement_and_branch_on_count\n-static\n-void analyze_loop_iterations (loop_start, loop_end)\n+static void\n+analyze_loop_iterations (loop_start, loop_end)\n   rtx loop_start, loop_end;\n {\n   rtx comparison, comparison_value;"}, {"sha": "6851aa78f0df6287c05bc62de2636b8f6cc915f0", "filename": "gcc/loop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f97e2e08b016d585fd38f932ee7d2ca9302acf/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f97e2e08b016d585fd38f932ee7d2ca9302acf/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=45f97e2e08b016d585fd38f932ee7d2ca9302acf", "patch": "@@ -95,6 +95,7 @@ struct induction\n   unsigned unrolled : 1;\t/* 1 if new register has been allocated and\n \t\t\t\t   initialized in unrolled loop.  */\n   unsigned shared : 1;\n+  unsigned no_const_addval : 1; /* 1 if add_val does not contain a const. */\n   int lifetime;\t\t\t/* Length of life of this giv */\n   int times_used;\t\t/* # times this giv is used. */\n   rtx derive_adjustment;\t/* If nonzero, is an adjustment to be"}]}