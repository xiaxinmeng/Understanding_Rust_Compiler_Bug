{"sha": "0e1b1222af5e5346df9431df817f2e7dca01bee6", "node_id": "C_kwDOANBUbNoAKDBlMWIxMjIyYWY1ZTUzNDZkZjk0MzFkZjgxN2YyZTdkY2EwMWJlZTY", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-08-31T14:00:07Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-09-01T09:22:07Z"}, "message": "libstdc++: Optimize array traits\n\nImprove compile times by avoiding unnecessary class template\ninstantiations.\n\n__is_array_known_bounds and __is_array_unknown_bounds can be defined\nwithout instantiating extent, by providing partial specializations for\nthe true cases.\n\nstd::extent can avoid recursing down through a multidimensional array,\nso it stops after providing the result. Previously extent<T[n][m], 0>\nwould instantiate extent<T[n], -1u> and extent<T, -2u> as well.\n\nstd::is_array_v can use partial specializations to avoid instantiating\nstd::is_array, and similarly for std::rank_v and std::extent_v.\n\nstd::is_bounded_array_v and std::is_unbounded_array_v can also use\npartial specializations, and then the class templates can be defined in\nterms of the variable templates. This makes sense for these traits,\nbecause they are new in C++20 and so the variable templates are always\navailable, which isn't true in general for C++11 and C++14 traits.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/type_traits (__is_array_known_bounds): Add partial\n\tspecialization instead of using std::extent.\n\t(__is_array_unknown_bounds): Likewise.\n\t(extent): Add partial specializations to stop recursion after\n\tthe result is found.\n\t(is_array_v): Add partial specializations instead of\n\tinstantiating the class template.\n\t(rank_v, extent_v): Likewise.\n\t(is_bounded_array_v, is_unbounded_array_v): Likewise.\n\t(is_bounded_array, is_unbounded_array): Define in terms of the\n\tvariable templates.", "tree": {"sha": "7457f84773265393ceeacfe8ba85473e7c5f6422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7457f84773265393ceeacfe8ba85473e7c5f6422"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e1b1222af5e5346df9431df817f2e7dca01bee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e1b1222af5e5346df9431df817f2e7dca01bee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e1b1222af5e5346df9431df817f2e7dca01bee6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e1b1222af5e5346df9431df817f2e7dca01bee6/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "953e08fde44a596e4ec2491efd15cd645e1ddc48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953e08fde44a596e4ec2491efd15cd645e1ddc48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/953e08fde44a596e4ec2491efd15cd645e1ddc48"}], "stats": {"total": 98, "additions": 67, "deletions": 31}, "files": [{"sha": "5984442c0aa8e49fd2e2eec2882bd856fdc88f23", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 67, "deletions": 31, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1b1222af5e5346df9431df817f2e7dca01bee6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1b1222af5e5346df9431df817f2e7dca01bee6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=0e1b1222af5e5346df9431df817f2e7dca01bee6", "patch": "@@ -867,21 +867,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     auto declval() noexcept -> decltype(__declval<_Tp>(0));\n \n-  template<typename, unsigned = 0>\n-    struct extent;\n-\n   template<typename>\n     struct remove_all_extents;\n \n   /// @cond undocumented\n   template<typename _Tp>\n     struct __is_array_known_bounds\n-    : public integral_constant<bool, (extent<_Tp>::value > 0)>\n+    : public false_type\n+    { };\n+\n+  template<typename _Tp, size_t _Size>\n+    struct __is_array_known_bounds<_Tp[_Size]>\n+    : public true_type\n     { };\n \n   template<typename _Tp>\n     struct __is_array_unknown_bounds\n-    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>\n+    : public false_type\n+    { };\n+\n+  template<typename _Tp>\n+    struct __is_array_unknown_bounds<_Tp[]>\n+    : public true_type\n     { };\n \n   // Destructible and constructible type properties.\n@@ -1430,23 +1437,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n \n   /// extent\n-  template<typename, unsigned _Uint>\n+  template<typename, unsigned _Uint = 0>\n     struct extent\n-    : public integral_constant<std::size_t, 0> { };\n+    : public integral_constant<size_t, 0> { };\n \n-  template<typename _Tp, unsigned _Uint, std::size_t _Size>\n+  template<typename _Tp, size_t _Size>\n+    struct extent<_Tp[_Size], 0>\n+    : public integral_constant<size_t, _Size> { };\n+\n+  template<typename _Tp, unsigned _Uint, size_t _Size>\n     struct extent<_Tp[_Size], _Uint>\n-    : public integral_constant<std::size_t,\n-\t\t\t       _Uint == 0 ? _Size : extent<_Tp,\n-\t\t\t\t\t\t\t   _Uint - 1>::value>\n-    { };\n+    : public extent<_Tp, _Uint - 1>::type { };\n+\n+  template<typename _Tp>\n+    struct extent<_Tp[], 0>\n+    : public integral_constant<size_t, 0> { };\n \n   template<typename _Tp, unsigned _Uint>\n     struct extent<_Tp[], _Uint>\n-    : public integral_constant<std::size_t,\n-\t\t\t       _Uint == 0 ? 0 : extent<_Tp,\n-\t\t\t\t\t\t       _Uint - 1>::value>\n-    { };\n+    : public extent<_Tp, _Uint - 1>::type { };\n \n \n   // Type relations.\n@@ -3133,8 +3142,14 @@ template <typename _Tp>\n   inline constexpr bool is_integral_v = is_integral<_Tp>::value;\n template <typename _Tp>\n   inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;\n+\n+template <typename _Tp>\n+  inline constexpr bool is_array_v = false;\n template <typename _Tp>\n-  inline constexpr bool is_array_v = is_array<_Tp>::value;\n+  inline constexpr bool is_array_v<_Tp[]> = true;\n+template <typename _Tp, size_t _Num>\n+  inline constexpr bool is_array_v<_Tp[_Num]> = true;\n+\n template <typename _Tp>\n   inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;\n template <typename _Tp>\n@@ -3276,10 +3291,25 @@ template <typename _Tp>\n     has_virtual_destructor<_Tp>::value;\n template <typename _Tp>\n   inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;\n+\n+template <typename _Tp>\n+  inline constexpr size_t rank_v = 0;\n+template <typename _Tp, size_t _Size>\n+  inline constexpr size_t rank_v<_Tp[_Size]> = 1 + rank_v<_Tp>;\n template <typename _Tp>\n-  inline constexpr size_t rank_v = rank<_Tp>::value;\n+  inline constexpr size_t rank_v<_Tp[]> = 1 + rank_v<_Tp>;\n+\n template <typename _Tp, unsigned _Idx = 0>\n-  inline constexpr size_t extent_v = extent<_Tp, _Idx>::value;\n+  inline constexpr size_t extent_v = 0;\n+template <typename _Tp, size_t _Size>\n+  inline constexpr size_t extent_v<_Tp[_Size], 0> = _Size;\n+template <typename _Tp, unsigned _Idx, size_t _Size>\n+  inline constexpr size_t extent_v<_Tp[_Size], _Idx> = extent_v<_Tp, _Idx - 1>;\n+template <typename _Tp>\n+  inline constexpr size_t extent_v<_Tp[], 0> = 0;\n+template <typename _Tp, unsigned _Idx>\n+  inline constexpr size_t extent_v<_Tp[], _Idx> = extent_v<_Tp, _Idx - 1>;\n+\n #ifdef _GLIBCXX_HAVE_BUILTIN_IS_SAME\n template <typename _Tp, typename _Up>\n   inline constexpr bool is_same_v = __is_same(_Tp, _Up);\n@@ -3408,30 +3438,36 @@ template<typename _Ret, typename _Fn, typename... _Args>\n #define __cpp_lib_bounded_array_traits 201902L\n \n   /// True for a type that is an array of known bound.\n+  /// @ingroup variable_templates\n   /// @since C++20\n   template<typename _Tp>\n-    struct is_bounded_array\n-    : public __is_array_known_bounds<_Tp>\n-    { };\n+    inline constexpr bool is_bounded_array_v = false;\n+\n+  template<typename _Tp, size_t _Size>\n+    inline constexpr bool is_bounded_array_v<_Tp[_Size]> = true;\n \n   /// True for a type that is an array of unknown bound.\n+  /// @ingroup variable_templates\n   /// @since C++20\n   template<typename _Tp>\n-    struct is_unbounded_array\n-    : public __is_array_unknown_bounds<_Tp>\n-    { };\n+    inline constexpr bool is_unbounded_array_v = false;\n \n-  /// @ingroup variable_templates\n+  template<typename _Tp>\n+    inline constexpr bool is_unbounded_array_v<_Tp[]> = true;\n+\n+  /// True for a type that is an array of known bound.\n   /// @since C++20\n   template<typename _Tp>\n-    inline constexpr bool is_bounded_array_v\n-      = is_bounded_array<_Tp>::value;\n+    struct is_bounded_array\n+    : public bool_constant<is_bounded_array_v<_Tp>>\n+    { };\n \n-  /// @ingroup variable_templates\n+  /// True for a type that is an array of unknown bound.\n   /// @since C++20\n   template<typename _Tp>\n-    inline constexpr bool is_unbounded_array_v\n-      = is_unbounded_array<_Tp>::value;\n+    struct is_unbounded_array\n+    : public bool_constant<is_unbounded_array_v<_Tp>>\n+    { };\n \n #if __has_builtin(__is_layout_compatible)\n "}]}