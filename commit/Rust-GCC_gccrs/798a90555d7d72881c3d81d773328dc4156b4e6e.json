{"sha": "798a90555d7d72881c3d81d773328dc4156b4e6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk4YTkwNTU1ZDdkNzI4ODFjM2Q4MWQ3NzMzMjhkYzQxNTZiNGU2ZQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-03-15T15:52:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T15:52:27Z"}, "message": "a-stzunb.adb, [...]: Move Realloc_For_Chunk to private part of package.\n\n2005-03-08  Robert Dewar  <dewar@adacore.com>\n\n\t* a-stzunb.adb, a-stzunb.adb a-stzunb.ads, a-stzunb.ads,\n\ta-stwiun.ads, a-stwiun.adb, a-strunb.ads, a-strunb.adb: Move\n\tRealloc_For_Chunk to private part of package.\n\tNew subprograms for AI-301\n\n\t* a-szuzti.adb, a-suteio.adb, a-swuwti.adb: Improve efficiency of\n\tGet_Line procedure.\n\tAvoid unnecessary use of Get/Set_Wide_String\n\nFrom-SVN: r96487", "tree": {"sha": "7a7289c9b2877f87a4a78f1c91b483f803aa6e9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a7289c9b2877f87a4a78f1c91b483f803aa6e9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/798a90555d7d72881c3d81d773328dc4156b4e6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/798a90555d7d72881c3d81d773328dc4156b4e6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/798a90555d7d72881c3d81d773328dc4156b4e6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/798a90555d7d72881c3d81d773328dc4156b4e6e/comments", "author": null, "committer": null, "parents": [{"sha": "f122ea71af3376a7d84f7a28a8fdb52b4111ad95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f122ea71af3376a7d84f7a28a8fdb52b4111ad95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f122ea71af3376a7d84f7a28a8fdb52b4111ad95"}], "stats": {"total": 998, "additions": 671, "deletions": 327}, "files": [{"sha": "bf492ebedd004005f1b6f9931d17682c94beb6da", "filename": "gcc/ada/a-strunb.adb", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-strunb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-strunb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strunb.adb?ref=798a90555d7d72881c3d81d773328dc4156b4e6e", "patch": "@@ -39,16 +39,6 @@ package body Ada.Strings.Unbounded is\n \n    use Ada.Finalization;\n \n-   procedure Realloc_For_Chunk\n-     (Source     : in out Unbounded_String;\n-      Chunk_Size : Natural);\n-   pragma Inline (Realloc_For_Chunk);\n-   --  Adjust the size allocated for the string. Add at least Chunk_Size so it\n-   --  is safe to add a string of this size at the end of the current content.\n-   --  The real size allocated for the string is Chunk_Size + x of the current\n-   --  string size. This buffered handling makes the Append unbounded string\n-   --  routines very fast.\n-\n    ---------\n    -- \"&\" --\n    ---------\n@@ -202,7 +192,7 @@ package body Ada.Strings.Unbounded is\n       Result.Reference := new String (1 .. Result.Last);\n \n       K := 1;\n-      for I in 1 .. Left loop\n+      for J in 1 .. Left loop\n          Result.Reference (K .. K + Len - 1) :=\n            Right.Reference (1 .. Right.Last);\n          K := K + Len;\n@@ -363,7 +353,7 @@ package body Ada.Strings.Unbounded is\n    procedure Adjust (Object : in out Unbounded_String) is\n    begin\n       --  Copy string, except we do not copy the statically allocated null\n-      --  string, since it can never be deallocated. Note that we do not copy\n+      --  string since it can never be deallocated. Note that we do not copy\n       --  extra string room here to avoid dragging unused allocated memory.\n \n       if Object.Reference /= Null_String'Access then"}, {"sha": "9c7ffcf9506ec2173f412a0faf19307c65b2e56e", "filename": "gcc/ada/a-strunb.ads", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-strunb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-strunb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strunb.ads?ref=798a90555d7d72881c3d81d773328dc4156b4e6e", "patch": "@@ -405,18 +405,31 @@ private\n    pragma Stream_Convert (Unbounded_String, To_Unbounded, To_String);\n \n    pragma Finalize_Storage_Only (Unbounded_String);\n+   --  Finalization is required only for freeing storage\n \n    procedure Initialize (Object : in out Unbounded_String);\n    procedure Adjust     (Object : in out Unbounded_String);\n    procedure Finalize   (Object : in out Unbounded_String);\n \n-   --  Note: the following declaration is illegal since library level\n-   --  controlled objects are not allowed in preelaborated units. See\n-   --  AI-161 for a discussion of this issue and an attempt to address it.\n-   --  Meanwhile, what happens in GNAT is that this check is omitted for\n-   --  internal implementation units (see check in sem_cat.adb).\n+   procedure Realloc_For_Chunk\n+     (Source     : in out Unbounded_String;\n+      Chunk_Size : Natural);\n+   pragma Inline (Realloc_For_Chunk);\n+   --  Adjust the size allocated for the string. Add at least Chunk_Size so it\n+   --  is safe to add a string of this size at the end of the current content.\n+   --  The real size allocated for the string is Chunk_Size + x of the current\n+   --  string size. This buffered handling makes the Append unbounded string\n+   --  routines very fast. This spec is in the private part so that it can be\n+   --  accessed from children (e.g. from Unbounded.Text_IO).\n \n    Null_Unbounded_String : constant Unbounded_String :=\n-     (AF.Controlled with Reference => Null_String'Access, Last => 0);\n+                             (AF.Controlled with\n+                                Reference => Null_String'Access,\n+                                Last => 0);\n+   --  Note: this declaration is illegal since library level controlled\n+   --  objects are not allowed in preelaborated units. See AI-161 for a\n+   --  discussion of this issue and an attempt to address it. Meanwhile,\n+   --  what happens in GNAT is that this check is omitted for internal\n+   --  implementation units (see check in sem_cat.adb).\n \n end Ada.Strings.Unbounded;"}, {"sha": "e722111c8db383d6d95d24c6b2a8dfa7ace03f49", "filename": "gcc/ada/a-stwiun.adb", "status": "modified", "additions": 183, "deletions": 82, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-stwiun.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-stwiun.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiun.adb?ref=798a90555d7d72881c3d81d773328dc4156b4e6e", "patch": "@@ -39,16 +39,6 @@ package body Ada.Strings.Wide_Unbounded is\n \n    use Ada.Finalization;\n \n-   procedure Realloc_For_Chunk\n-     (Source     : in out Unbounded_Wide_String;\n-      Chunk_Size : Natural);\n-   pragma Inline (Realloc_For_Chunk);\n-   --  Adjust the size allocated for the string. Add at least Chunk_Size so it\n-   --  is safe to add a string of this size at the end of the current\n-   --  content. The real size allocated for the string is Chunk_Size + x %\n-   --  of the current string size. This buffered handling makes the Append\n-   --  unbounded wide string routines very fast.\n-\n    ---------\n    -- \"&\" --\n    ---------\n@@ -142,7 +132,6 @@ package body Ada.Strings.Wide_Unbounded is\n       Result.Reference (1) := Left;\n       Result.Reference (2 .. Result.Last) :=\n         Right.Reference (1 .. Right.Last);\n-\n       return Result;\n    end \"&\";\n \n@@ -157,7 +146,7 @@ package body Ada.Strings.Wide_Unbounded is\n       Result : Unbounded_Wide_String;\n \n    begin\n-      Result.Last := Left;\n+      Result.Last   := Left;\n \n       Result.Reference := new Wide_String (1 .. Left);\n       for J in Result.Reference'Range loop\n@@ -195,15 +184,15 @@ package body Ada.Strings.Wide_Unbounded is\n    is\n       Len    : constant Natural := Right.Last;\n       K      : Positive;\n-      Result   : Unbounded_Wide_String;\n+      Result : Unbounded_Wide_String;\n \n    begin\n       Result.Last := Left * Len;\n \n       Result.Reference := new Wide_String (1 .. Result.Last);\n \n       K := 1;\n-      for I in 1 .. Left loop\n+      for J in 1 .. Left loop\n          Result.Reference (K .. K + Len - 1) :=\n            Right.Reference (1 .. Right.Last);\n          K := K + Len;\n@@ -363,10 +352,9 @@ package body Ada.Strings.Wide_Unbounded is\n \n    procedure Adjust (Object : in out Unbounded_Wide_String) is\n    begin\n-      --  Copy string, except we do not copy the statically allocated\n-      --  null string, since it can never be deallocated.\n-      --  Note that we do not copy extra string room here to avoid dragging\n-      --  unused allocated memory.\n+      --  Copy string, except we do not copy the statically allocated null\n+      --  string, since it can never be deallocated. Note that we do not copy\n+      --  extra string room here to avoid dragging unused allocated memory.\n \n       if Object.Reference /= Null_Wide_String'Access then\n          Object.Reference :=\n@@ -417,13 +405,13 @@ package body Ada.Strings.Wide_Unbounded is\n    function Count\n      (Source  : Unbounded_Wide_String;\n       Pattern : Wide_String;\n-      Mapping : Wide_Maps.Wide_Character_Mapping :=\n-                  Wide_Maps.Identity)\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n       return Natural\n    is\n    begin\n-      return Wide_Search.Count\n-        (Source.Reference (1 .. Source.Last), Pattern, Mapping);\n+      return\n+        Wide_Search.Count\n+          (Source.Reference (1 .. Source.Last), Pattern, Mapping);\n    end Count;\n \n    function Count\n@@ -432,16 +420,19 @@ package body Ada.Strings.Wide_Unbounded is\n       Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n    is\n    begin\n-      return Wide_Search.Count\n-        (Source.Reference (1 .. Source.Last), Pattern, Mapping);\n+      return\n+        Wide_Search.Count\n+          (Source.Reference (1 .. Source.Last), Pattern, Mapping);\n    end Count;\n \n    function Count\n      (Source : Unbounded_Wide_String;\n       Set    : Wide_Maps.Wide_Character_Set) return Natural\n    is\n    begin\n-      return Wide_Search.Count (Source.Reference (1 .. Source.Last), Set);\n+      return\n+        Wide_Search.Count\n+        (Source.Reference (1 .. Source.Last), Set);\n    end Count;\n \n    ------------\n@@ -454,9 +445,10 @@ package body Ada.Strings.Wide_Unbounded is\n       Through : Natural) return Unbounded_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_String\n-        (Wide_Fixed.Delete\n-           (Source.Reference (1 .. Source.Last), From, Through));\n+      return\n+        To_Unbounded_Wide_String\n+          (Wide_Fixed.Delete\n+             (Source.Reference (1 .. Source.Last), From, Through));\n    end Delete;\n \n    procedure Delete\n@@ -505,14 +497,15 @@ package body Ada.Strings.Wide_Unbounded is\n \n    procedure Finalize (Object : in out Unbounded_Wide_String) is\n       procedure Deallocate is\n-        new Ada.Unchecked_Deallocation (Wide_String, Wide_String_Access);\n+         new Ada.Unchecked_Deallocation (Wide_String, Wide_String_Access);\n \n    begin\n       --  Note: Don't try to free statically allocated null string\n \n       if Object.Reference /= Null_Wide_String'Access then\n          Deallocate (Object.Reference);\n          Object.Reference := Null_Unbounded_Wide_String.Reference;\n+         Object.Last := 0;\n       end if;\n    end Finalize;\n \n@@ -539,6 +532,7 @@ package body Ada.Strings.Wide_Unbounded is\n    procedure Free (X : in out Wide_String_Access) is\n       procedure Deallocate is\n          new Ada.Unchecked_Deallocation (Wide_String, Wide_String_Access);\n+\n    begin\n       --  Note: Do not try to free statically allocated null string\n \n@@ -557,9 +551,8 @@ package body Ada.Strings.Wide_Unbounded is\n       Pad    : Wide_Character := Wide_Space) return Unbounded_Wide_String\n    is\n    begin\n-      return\n-        To_Unbounded_Wide_String\n-          (Wide_Fixed.Head (Source.Reference (1 .. Source.Last), Count, Pad));\n+      return To_Unbounded_Wide_String\n+        (Wide_Fixed.Head (Source.Reference (1 .. Source.Last), Count, Pad));\n    end Head;\n \n    procedure Head\n@@ -568,10 +561,10 @@ package body Ada.Strings.Wide_Unbounded is\n       Pad    : Wide_Character := Wide_Space)\n    is\n       Old : Wide_String_Access := Source.Reference;\n-\n    begin\n-      Source.Reference := new Wide_String'\n-        (Wide_Fixed.Head (Source.Reference (1 .. Source.Last), Count, Pad));\n+      Source.Reference :=\n+        new Wide_String'\n+          (Wide_Fixed.Head (Source.Reference (1 .. Source.Last), Count, Pad));\n       Source.Last := Source.Reference'Length;\n       Free (Old);\n    end Head;\n@@ -584,12 +577,13 @@ package body Ada.Strings.Wide_Unbounded is\n      (Source  : Unbounded_Wide_String;\n       Pattern : Wide_String;\n       Going   : Strings.Direction := Strings.Forward;\n-      Mapping : Wide_Maps.Wide_Character_Mapping :=\n-                        Wide_Maps.Identity) return Natural\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural\n    is\n    begin\n-      return Wide_Search.Index\n-        (Source.Reference (1 .. Source.Last), Pattern, Going, Mapping);\n+      return\n+        Wide_Search.Index\n+          (Source.Reference (1 .. Source.Last), Pattern, Going, Mapping);\n    end Index;\n \n    function Index\n@@ -599,8 +593,9 @@ package body Ada.Strings.Wide_Unbounded is\n       Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n    is\n    begin\n-      return Wide_Search.Index\n-        (Source.Reference (1 .. Source.Last), Pattern, Going, Mapping);\n+      return\n+        Wide_Search.Index\n+          (Source.Reference (1 .. Source.Last), Pattern, Going, Mapping);\n    end Index;\n \n    function Index\n@@ -614,13 +609,66 @@ package body Ada.Strings.Wide_Unbounded is\n         (Source.Reference (1 .. Source.Last), Set, Test, Going);\n    end Index;\n \n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural\n+   is\n+   begin\n+      return\n+        Wide_Search.Index\n+          (Source.Reference (1 .. Source.Last), Pattern, From, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n+   is\n+   begin\n+      return\n+        Wide_Search.Index\n+          (Source.Reference (1 .. Source.Last), Pattern, From, Going, Mapping);\n+   end Index;\n+\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Set     : Wide_Maps.Wide_Character_Set;\n+      From    : Positive;\n+      Test    : Membership := Inside;\n+      Going   : Direction := Forward) return Natural\n+   is\n+   begin\n+      return\n+        Wide_Search.Index\n+          (Source.Reference (1 .. Source.Last), Set, From, Test, Going);\n+   end Index;\n+\n    function Index_Non_Blank\n      (Source : Unbounded_Wide_String;\n       Going  : Strings.Direction := Strings.Forward) return Natural\n    is\n    begin\n-      return Wide_Search.Index_Non_Blank\n-        (Source.Reference (1 .. Source.Last), Going);\n+      return\n+        Wide_Search.Index_Non_Blank\n+          (Source.Reference (1 .. Source.Last), Going);\n+   end Index_Non_Blank;\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_String;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural\n+   is\n+   begin\n+      return\n+        Wide_Search.Index_Non_Blank\n+          (Source.Reference (1 .. Source.Last), From, Going);\n    end Index_Non_Blank;\n \n    ----------------\n@@ -643,9 +691,10 @@ package body Ada.Strings.Wide_Unbounded is\n       New_Item : Wide_String) return Unbounded_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_String\n-        (Wide_Fixed.Insert\n-           (Source.Reference (1 .. Source.Last), Before, New_Item));\n+      return\n+        To_Unbounded_Wide_String\n+          (Wide_Fixed.Insert\n+             (Source.Reference (1 .. Source.Last), Before, New_Item));\n    end Insert;\n \n    procedure Insert\n@@ -687,9 +736,10 @@ package body Ada.Strings.Wide_Unbounded is\n       New_Item : Wide_String) return Unbounded_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_String\n-        (Wide_Fixed.Overwrite\n-           (Source.Reference (1 .. Source.Last), Position, New_Item));\n+      return\n+        To_Unbounded_Wide_String\n+          (Wide_Fixed.Overwrite\n+            (Source.Reference (1 .. Source.Last), Position, New_Item));\n    end Overwrite;\n \n    procedure Overwrite\n@@ -698,15 +748,12 @@ package body Ada.Strings.Wide_Unbounded is\n       New_Item  : Wide_String)\n    is\n       NL : constant Natural := New_Item'Length;\n-\n    begin\n       if Position <= Source.Last - NL + 1 then\n          Source.Reference (Position .. Position + NL - 1) := New_Item;\n-\n       else\n          declare\n             Old : Wide_String_Access := Source.Reference;\n-\n          begin\n             Source.Reference := new Wide_String'\n               (Wide_Fixed.Overwrite\n@@ -734,7 +781,6 @@ package body Ada.Strings.Wide_Unbounded is\n             Alloc_Chunk_Size : constant Positive :=\n                                  Chunk_Size + (S_Length / Growth_Factor);\n             Tmp : Wide_String_Access;\n-\n          begin\n             Tmp := new Wide_String (1 .. S_Length + Alloc_Chunk_Size);\n             Tmp (1 .. Source.Last) := Source.Reference (1 .. Source.Last);\n@@ -772,20 +818,18 @@ package body Ada.Strings.Wide_Unbounded is\n       By     : Wide_String) return Unbounded_Wide_String\n    is\n    begin\n-      return\n-        To_Unbounded_Wide_String\n+      return To_Unbounded_Wide_String\n         (Wide_Fixed.Replace_Slice\n            (Source.Reference (1 .. Source.Last), Low, High, By));\n    end Replace_Slice;\n \n    procedure Replace_Slice\n-     (Source   : in out Unbounded_Wide_String;\n-      Low      : Positive;\n-      High     : Natural;\n-      By       : Wide_String)\n+     (Source : in out Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_String)\n    is\n       Old : Wide_String_Access := Source.Reference;\n-\n    begin\n       Source.Reference := new Wide_String'\n         (Wide_Fixed.Replace_Slice\n@@ -794,6 +838,20 @@ package body Ada.Strings.Wide_Unbounded is\n       Free (Old);\n    end Replace_Slice;\n \n+   -------------------------------\n+   -- Set_Unbounded_Wide_String --\n+   -------------------------------\n+\n+   procedure Set_Unbounded_Wide_String\n+     (Target : out Unbounded_Wide_String;\n+      Source : Wide_String)\n+   is\n+   begin\n+      Target.Last          := Source'Length;\n+      Target.Reference     := new Wide_String (1 .. Source'Length);\n+      Target.Reference.all := Source;\n+   end Set_Unbounded_Wide_String;\n+\n    -----------\n    -- Slice --\n    -----------\n@@ -808,7 +866,6 @@ package body Ada.Strings.Wide_Unbounded is\n \n       if Low > Source.Last + 1 or else High > Source.Last then\n          raise Index_Error;\n-\n       else\n          return Source.Reference (Low .. High);\n       end if;\n@@ -821,8 +878,7 @@ package body Ada.Strings.Wide_Unbounded is\n    function Tail\n      (Source : Unbounded_Wide_String;\n       Count  : Natural;\n-      Pad    : Wide_Character := Wide_Space) return Unbounded_Wide_String\n-   is\n+      Pad    : Wide_Character := Wide_Space) return Unbounded_Wide_String is\n    begin\n       return To_Unbounded_Wide_String\n         (Wide_Fixed.Tail (Source.Reference (1 .. Source.Last), Count, Pad));\n@@ -834,7 +890,6 @@ package body Ada.Strings.Wide_Unbounded is\n       Pad    : Wide_Character := Wide_Space)\n    is\n       Old : Wide_String_Access := Source.Reference;\n-\n    begin\n       Source.Reference := new Wide_String'\n         (Wide_Fixed.Tail (Source.Reference (1 .. Source.Last), Count, Pad));\n@@ -847,7 +902,8 @@ package body Ada.Strings.Wide_Unbounded is\n    ------------------------------\n \n    function To_Unbounded_Wide_String\n-     (Source : Wide_String) return Unbounded_Wide_String\n+     (Source : Wide_String)\n+      return Unbounded_Wide_String\n    is\n       Result : Unbounded_Wide_String;\n    begin\n@@ -867,28 +923,33 @@ package body Ada.Strings.Wide_Unbounded is\n       return Result;\n    end To_Unbounded_Wide_String;\n \n-   --------------------\n+   -------------------\n    -- To_Wide_String --\n    --------------------\n \n    function To_Wide_String\n-     (Source : Unbounded_Wide_String) return Wide_String\n+     (Source : Unbounded_Wide_String)\n+      return Wide_String\n    is\n    begin\n       return Source.Reference (1 .. Source.Last);\n    end To_Wide_String;\n \n+\n    ---------------\n    -- Translate --\n    ---------------\n \n    function Translate\n      (Source  : Unbounded_Wide_String;\n-      Mapping : Wide_Maps.Wide_Character_Mapping) return Unbounded_Wide_String\n+      Mapping : Wide_Maps.Wide_Character_Mapping)\n+      return Unbounded_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_String\n-        (Wide_Fixed.Translate (Source.Reference (1 .. Source.Last), Mapping));\n+      return\n+        To_Unbounded_Wide_String\n+          (Wide_Fixed.Translate\n+             (Source.Reference (1 .. Source.Last), Mapping));\n    end Translate;\n \n    procedure Translate\n@@ -905,8 +966,10 @@ package body Ada.Strings.Wide_Unbounded is\n       return Unbounded_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_String\n-        (Wide_Fixed.Translate (Source.Reference (1 .. Source.Last), Mapping));\n+      return\n+        To_Unbounded_Wide_String\n+          (Wide_Fixed.Translate\n+            (Source.Reference (1 .. Source.Last), Mapping));\n    end Translate;\n \n    procedure Translate\n@@ -926,8 +989,9 @@ package body Ada.Strings.Wide_Unbounded is\n       Side   : Trim_End) return Unbounded_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_String\n-        (Wide_Fixed.Trim (Source.Reference (1 .. Source.Last), Side));\n+      return\n+        To_Unbounded_Wide_String\n+          (Wide_Fixed.Trim (Source.Reference (1 .. Source.Last), Side));\n    end Trim;\n \n    procedure Trim\n@@ -936,20 +1000,24 @@ package body Ada.Strings.Wide_Unbounded is\n    is\n       Old : Wide_String_Access := Source.Reference;\n    begin\n-      Source.Reference := new Wide_String'\n-        (Wide_Fixed.Trim (Source.Reference (1 .. Source.Last), Side));\n+      Source.Reference :=\n+        new Wide_String'\n+          (Wide_Fixed.Trim (Source.Reference (1 .. Source.Last), Side));\n       Source.Last      := Source.Reference'Length;\n       Free (Old);\n    end Trim;\n \n    function Trim\n      (Source : Unbounded_Wide_String;\n       Left   : Wide_Maps.Wide_Character_Set;\n-      Right  : Wide_Maps.Wide_Character_Set) return Unbounded_Wide_String\n+      Right  : Wide_Maps.Wide_Character_Set)\n+      return Unbounded_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_String\n-        (Wide_Fixed.Trim (Source.Reference (1 .. Source.Last), Left, Right));\n+      return\n+        To_Unbounded_Wide_String\n+          (Wide_Fixed.Trim\n+             (Source.Reference (1 .. Source.Last), Left, Right));\n    end Trim;\n \n    procedure Trim\n@@ -958,12 +1026,45 @@ package body Ada.Strings.Wide_Unbounded is\n       Right  : Wide_Maps.Wide_Character_Set)\n    is\n       Old : Wide_String_Access := Source.Reference;\n-\n    begin\n-      Source.Reference := new Wide_String'\n-        (Wide_Fixed.Trim (Source.Reference (1 .. Source.Last), Left, Right));\n+      Source.Reference :=\n+        new Wide_String'\n+          (Wide_Fixed.Trim\n+             (Source.Reference (1 .. Source.Last), Left, Right));\n       Source.Last      := Source.Reference'Length;\n       Free (Old);\n    end Trim;\n \n+   ---------------------\n+   -- Unbounded_Slice --\n+   ---------------------\n+\n+   function Unbounded_Slice\n+     (Source : Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Unbounded_Wide_String\n+   is\n+   begin\n+      if Low > Source.Last + 1 or else High > Source.Last then\n+         raise Index_Error;\n+      else\n+         return To_Unbounded_Wide_String (Source.Reference.all (Low .. High));\n+      end if;\n+   end Unbounded_Slice;\n+\n+   procedure Unbounded_Slice\n+     (Source : Unbounded_Wide_String;\n+      Target : out Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural)\n+   is\n+   begin\n+      if Low > Source.Last + 1 or else High > Source.Last then\n+         raise Index_Error;\n+      else\n+         Target :=\n+           To_Unbounded_Wide_String (Source.Reference.all (Low .. High));\n+      end if;\n+   end Unbounded_Slice;\n+\n end Ada.Strings.Wide_Unbounded;"}, {"sha": "037109c687881d86a739f60451be8c3dde317315", "filename": "gcc/ada/a-stwiun.ads", "status": "modified", "additions": 82, "deletions": 14, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-stwiun.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-stwiun.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiun.ads?ref=798a90555d7d72881c3d81d773328dc4156b4e6e", "patch": "@@ -40,7 +40,6 @@ with Ada.Finalization;\n \n package Ada.Strings.Wide_Unbounded is\n pragma Preelaborate (Wide_Unbounded);\n-\n    type Unbounded_Wide_String is private;\n \n    Null_Unbounded_Wide_String : constant Unbounded_Wide_String;\n@@ -62,7 +61,13 @@ pragma Preelaborate (Wide_Unbounded);\n      (Length : Natural) return Unbounded_Wide_String;\n \n    function To_Wide_String\n-     (Source : Unbounded_Wide_String) return Wide_String;\n+     (Source : Unbounded_Wide_String)\n+      return Wide_String;\n+\n+   procedure Set_Unbounded_Wide_String\n+     (Target : out Unbounded_Wide_String;\n+      Source : Wide_String);\n+   pragma Ada_05 (Set_Unbounded_Wide_String);\n \n    procedure Append\n      (Source   : in out Unbounded_Wide_String;\n@@ -77,7 +82,8 @@ pragma Preelaborate (Wide_Unbounded);\n       New_Item : Wide_Character);\n \n    function \"&\"\n-     (Left, Right : Unbounded_Wide_String) return Unbounded_Wide_String;\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String;\n \n    function \"&\"\n      (Left  : Unbounded_Wide_String;\n@@ -109,6 +115,19 @@ pragma Preelaborate (Wide_Unbounded);\n       Low    : Positive;\n       High   : Natural) return Wide_String;\n \n+   function Unbounded_Slice\n+     (Source : Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Unbounded_Wide_String;\n+   pragma Ada_05 (Unbounded_Slice);\n+\n+   procedure Unbounded_Slice\n+     (Source : Unbounded_Wide_String;\n+      Target : out Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural);\n+   pragma Ada_05 (Unbounded_Slice);\n+\n    function \"=\"\n      (Left  : Unbounded_Wide_String;\n       Right : Unbounded_Wide_String) return Boolean;\n@@ -192,10 +211,41 @@ pragma Preelaborate (Wide_Unbounded);\n       Test   : Membership := Inside;\n       Going  : Direction  := Forward) return Natural;\n \n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Set     : Wide_Maps.Wide_Character_Set;\n+      From    : Positive;\n+      Test    : Membership := Inside;\n+      Going   : Direction := Forward) return Natural;\n+   pragma Ada_05 (Index);\n+\n    function Index_Non_Blank\n      (Source : Unbounded_Wide_String;\n       Going  : Direction := Forward) return Natural;\n \n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_String;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural;\n+   pragma Ada_05 (Index_Non_Blank);\n+\n    function Count\n      (Source  : Unbounded_Wide_String;\n       Pattern : Wide_String;\n@@ -219,12 +269,13 @@ pragma Preelaborate (Wide_Unbounded);\n       Last   : out Natural);\n \n    ------------------------------------\n-   -- Wide_String Translation Subprograms --\n+   -- String Translation Subprograms --\n    ------------------------------------\n \n    function Translate\n      (Source  : Unbounded_Wide_String;\n-      Mapping : Wide_Maps.Wide_Character_Mapping) return Unbounded_Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping)\n+      return Unbounded_Wide_String;\n \n    procedure Translate\n      (Source  : in out Unbounded_Wide_String;\n@@ -240,7 +291,7 @@ pragma Preelaborate (Wide_Unbounded);\n       Mapping : Wide_Maps.Wide_Character_Mapping_Function);\n \n    ---------------------------------------\n-   -- Wide_String Transformation Subprograms --\n+   -- String Transformation Subprograms --\n    ---------------------------------------\n \n    function Replace_Slice\n@@ -250,10 +301,10 @@ pragma Preelaborate (Wide_Unbounded);\n       By     : Wide_String) return Unbounded_Wide_String;\n \n    procedure Replace_Slice\n-     (Source   : in out Unbounded_Wide_String;\n-      Low      : Positive;\n-      High     : Natural;\n-      By       : Wide_String);\n+     (Source : in out Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_String);\n \n    function Insert\n      (Source   : Unbounded_Wide_String;\n@@ -271,9 +322,9 @@ pragma Preelaborate (Wide_Unbounded);\n       New_Item : Wide_String) return Unbounded_Wide_String;\n \n    procedure Overwrite\n-     (Source    : in out Unbounded_Wide_String;\n-      Position  : Positive;\n-      New_Item  : Wide_String);\n+     (Source   : in out Unbounded_Wide_String;\n+      Position : Positive;\n+      New_Item : Wide_String);\n \n    function Delete\n      (Source  : Unbounded_Wide_String;\n@@ -361,12 +412,29 @@ private\n      (Unbounded_Wide_String, To_Unbounded_Wide, To_Wide_String);\n \n    pragma Finalize_Storage_Only (Unbounded_Wide_String);\n+   --  Finalization is required only for freeing storage\n \n    procedure Initialize (Object : in out Unbounded_Wide_String);\n    procedure Adjust     (Object : in out Unbounded_Wide_String);\n    procedure Finalize   (Object : in out Unbounded_Wide_String);\n \n+   procedure Realloc_For_Chunk\n+     (Source     : in out Unbounded_Wide_String;\n+      Chunk_Size : Natural);\n+   --  Adjust the size allocated for the string. Add at least Chunk_Size so it\n+   --  is safe to add a string of this size at the end of the current content.\n+   --  The real size allocated for the string is Chunk_Size + x of the current\n+   --  string size. This buffered handling makes the Append unbounded string\n+   --  routines very fast.\n+\n    Null_Unbounded_Wide_String : constant Unbounded_Wide_String :=\n-     (AF.Controlled with Reference => Null_Wide_String'Access, Last => 0);\n+                                  (AF.Controlled with\n+                                     Reference => Null_Wide_String'Access,\n+                                     Last => 0);\n+   --  Note: this declaration is illegal since library level controlled\n+   --  objects are not allowed in preelaborated units. See AI-161 for a\n+   --  discussion of this issue and an attempt to address it. Meanwhile,\n+   --  what happens in GNAT is that this check is omitted for internal\n+   --  implementation units (see check in sem_cat.adb).\n \n end Ada.Strings.Wide_Unbounded;"}, {"sha": "8717bb375777325b91bd7560f0d375039e360806", "filename": "gcc/ada/a-stzunb.adb", "status": "modified", "additions": 178, "deletions": 81, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-stzunb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-stzunb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzunb.adb?ref=798a90555d7d72881c3d81d773328dc4156b4e6e", "patch": "@@ -39,16 +39,6 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n \n    use Ada.Finalization;\n \n-   procedure Realloc_For_Chunk\n-     (Source     : in out Unbounded_Wide_Wide_String;\n-      Chunk_Size : Natural);\n-   pragma Inline (Realloc_For_Chunk);\n-   --  Adjust the size allocated for the string. Add at least Chunk_Size so it\n-   --  is safe to add a string of this size at the end of the current content.\n-   --  The real size allocated for the string is Chunk_Size + x of the current\n-   --  string size. This buffered handling makes the Append unbounded wide\n-   --  string routines very fast.\n-\n    ---------\n    -- \"&\" --\n    ---------\n@@ -142,7 +132,6 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       Result.Reference (1) := Left;\n       Result.Reference (2 .. Result.Last) :=\n         Right.Reference (1 .. Right.Last);\n-\n       return Result;\n    end \"&\";\n \n@@ -157,7 +146,7 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       Result : Unbounded_Wide_Wide_String;\n \n    begin\n-      Result.Last := Left;\n+      Result.Last   := Left;\n \n       Result.Reference := new Wide_Wide_String (1 .. Left);\n       for J in Result.Reference'Range loop\n@@ -195,15 +184,15 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n    is\n       Len    : constant Natural := Right.Last;\n       K      : Positive;\n-      Result   : Unbounded_Wide_Wide_String;\n+      Result : Unbounded_Wide_Wide_String;\n \n    begin\n       Result.Last := Left * Len;\n \n       Result.Reference := new Wide_Wide_String (1 .. Result.Last);\n \n       K := 1;\n-      for I in 1 .. Left loop\n+      for J in 1 .. Left loop\n          Result.Reference (K .. K + Len - 1) :=\n            Right.Reference (1 .. Right.Last);\n          K := K + Len;\n@@ -417,11 +406,13 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n      (Source  : Unbounded_Wide_Wide_String;\n       Pattern : Wide_Wide_String;\n       Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n-                        Wide_Wide_Maps.Identity) return Natural\n+                  Wide_Wide_Maps.Identity)\n+      return Natural\n    is\n    begin\n-      return Wide_Wide_Search.Count\n-        (Source.Reference (1 .. Source.Last), Pattern, Mapping);\n+      return\n+        Wide_Wide_Search.Count\n+          (Source.Reference (1 .. Source.Last), Pattern, Mapping);\n    end Count;\n \n    function Count\n@@ -431,17 +422,19 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       return Natural\n    is\n    begin\n-      return Wide_Wide_Search.Count\n-        (Source.Reference (1 .. Source.Last), Pattern, Mapping);\n+      return\n+        Wide_Wide_Search.Count\n+          (Source.Reference (1 .. Source.Last), Pattern, Mapping);\n    end Count;\n \n    function Count\n      (Source : Unbounded_Wide_Wide_String;\n       Set    : Wide_Wide_Maps.Wide_Wide_Character_Set) return Natural\n    is\n    begin\n-      return Wide_Wide_Search.Count\n-               (Source.Reference (1 .. Source.Last), Set);\n+      return\n+        Wide_Wide_Search.Count\n+        (Source.Reference (1 .. Source.Last), Set);\n    end Count;\n \n    ------------\n@@ -454,9 +447,10 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       Through : Natural) return Unbounded_Wide_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_Wide_String\n-        (Wide_Wide_Fixed.Delete\n-           (Source.Reference (1 .. Source.Last), From, Through));\n+      return\n+        To_Unbounded_Wide_Wide_String\n+          (Wide_Wide_Fixed.Delete\n+             (Source.Reference (1 .. Source.Last), From, Through));\n    end Delete;\n \n    procedure Delete\n@@ -506,14 +500,15 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n    procedure Finalize (Object : in out Unbounded_Wide_Wide_String) is\n       procedure Deallocate is\n         new Ada.Unchecked_Deallocation\n-              (Wide_Wide_String, Wide_Wide_String_Access);\n+          (Wide_Wide_String, Wide_Wide_String_Access);\n \n    begin\n       --  Note: Don't try to free statically allocated null string\n \n       if Object.Reference /= Null_Wide_Wide_String'Access then\n          Deallocate (Object.Reference);\n          Object.Reference := Null_Unbounded_Wide_Wide_String.Reference;\n+         Object.Last := 0;\n       end if;\n    end Finalize;\n \n@@ -540,7 +535,8 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n    procedure Free (X : in out Wide_Wide_String_Access) is\n       procedure Deallocate is\n         new Ada.Unchecked_Deallocation\n-              (Wide_Wide_String, Wide_Wide_String_Access);\n+          (Wide_Wide_String, Wide_Wide_String_Access);\n+\n    begin\n       --  Note: Do not try to free statically allocated null string\n \n@@ -560,10 +556,9 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       return Unbounded_Wide_Wide_String\n    is\n    begin\n-      return\n-        To_Unbounded_Wide_Wide_String\n-          (Wide_Wide_Fixed.Head\n-             (Source.Reference (1 .. Source.Last), Count, Pad));\n+      return To_Unbounded_Wide_Wide_String\n+        (Wide_Wide_Fixed.Head\n+           (Source.Reference (1 .. Source.Last), Count, Pad));\n    end Head;\n \n    procedure Head\n@@ -572,11 +567,11 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       Pad    : Wide_Wide_Character := Wide_Wide_Space)\n    is\n       Old : Wide_Wide_String_Access := Source.Reference;\n-\n    begin\n-      Source.Reference := new Wide_Wide_String'\n-        (Wide_Wide_Fixed.Head\n-           (Source.Reference (1 .. Source.Last), Count, Pad));\n+      Source.Reference :=\n+        new Wide_Wide_String'\n+          (Wide_Wide_Fixed.Head\n+             (Source.Reference (1 .. Source.Last), Count, Pad));\n       Source.Last := Source.Reference'Length;\n       Free (Old);\n    end Head;\n@@ -590,11 +585,13 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       Pattern : Wide_Wide_String;\n       Going   : Strings.Direction := Strings.Forward;\n       Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n-                        Wide_Wide_Maps.Identity) return Natural\n+                  Wide_Wide_Maps.Identity)\n+      return Natural\n    is\n    begin\n-      return Wide_Wide_Search.Index\n-        (Source.Reference (1 .. Source.Last), Pattern, Going, Mapping);\n+      return\n+        Wide_Wide_Search.Index\n+          (Source.Reference (1 .. Source.Last), Pattern, Going, Mapping);\n    end Index;\n \n    function Index\n@@ -605,8 +602,9 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       return Natural\n    is\n    begin\n-      return Wide_Wide_Search.Index\n-        (Source.Reference (1 .. Source.Last), Pattern, Going, Mapping);\n+      return\n+        Wide_Wide_Search.Index\n+          (Source.Reference (1 .. Source.Last), Pattern, Going, Mapping);\n    end Index;\n \n    function Index\n@@ -620,13 +618,68 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n         (Source.Reference (1 .. Source.Last), Set, Test, Going);\n    end Index;\n \n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n+                  Wide_Wide_Maps.Identity)\n+      return Natural\n+   is\n+   begin\n+      return\n+        Wide_Wide_Search.Index\n+          (Source.Reference (1 .. Source.Last), Pattern, From, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n+      return Natural\n+   is\n+   begin\n+      return\n+        Wide_Wide_Search.Index\n+          (Source.Reference (1 .. Source.Last), Pattern, From, Going, Mapping);\n+   end Index;\n+\n+\n+   function Index\n+     (Source : Unbounded_Wide_Wide_String;\n+      Set    : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      From   : Positive;\n+      Test   : Membership := Inside;\n+      Going  : Direction := Forward) return Natural\n+   is\n+   begin\n+      return\n+        Wide_Wide_Search.Index\n+          (Source.Reference (1 .. Source.Last), Set, From, Test, Going);\n+   end Index;\n+\n    function Index_Non_Blank\n      (Source : Unbounded_Wide_Wide_String;\n       Going  : Strings.Direction := Strings.Forward) return Natural\n    is\n    begin\n-      return Wide_Wide_Search.Index_Non_Blank\n-        (Source.Reference (1 .. Source.Last), Going);\n+      return\n+        Wide_Wide_Search.Index_Non_Blank\n+          (Source.Reference (1 .. Source.Last), Going);\n+   end Index_Non_Blank;\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_Wide_String;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural\n+   is\n+   begin\n+      return\n+        Wide_Wide_Search.Index_Non_Blank\n+          (Source.Reference (1 .. Source.Last), From, Going);\n    end Index_Non_Blank;\n \n    ----------------\n@@ -649,9 +702,10 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       New_Item : Wide_Wide_String) return Unbounded_Wide_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_Wide_String\n-        (Wide_Wide_Fixed.Insert\n-           (Source.Reference (1 .. Source.Last), Before, New_Item));\n+      return\n+        To_Unbounded_Wide_Wide_String\n+          (Wide_Wide_Fixed.Insert\n+             (Source.Reference (1 .. Source.Last), Before, New_Item));\n    end Insert;\n \n    procedure Insert\n@@ -693,9 +747,10 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       New_Item : Wide_Wide_String) return Unbounded_Wide_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_Wide_String\n-        (Wide_Wide_Fixed.Overwrite\n-           (Source.Reference (1 .. Source.Last), Position, New_Item));\n+      return\n+        To_Unbounded_Wide_Wide_String\n+          (Wide_Wide_Fixed.Overwrite\n+            (Source.Reference (1 .. Source.Last), Position, New_Item));\n    end Overwrite;\n \n    procedure Overwrite\n@@ -704,15 +759,12 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       New_Item  : Wide_Wide_String)\n    is\n       NL : constant Natural := New_Item'Length;\n-\n    begin\n       if Position <= Source.Last - NL + 1 then\n          Source.Reference (Position .. Position + NL - 1) := New_Item;\n-\n       else\n          declare\n             Old : Wide_Wide_String_Access := Source.Reference;\n-\n          begin\n             Source.Reference := new Wide_Wide_String'\n               (Wide_Wide_Fixed.Overwrite\n@@ -740,7 +792,6 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n             Alloc_Chunk_Size : constant Positive :=\n                                  Chunk_Size + (S_Length / Growth_Factor);\n             Tmp : Wide_Wide_String_Access;\n-\n          begin\n             Tmp := new Wide_Wide_String (1 .. S_Length + Alloc_Chunk_Size);\n             Tmp (1 .. Source.Last) := Source.Reference (1 .. Source.Last);\n@@ -778,20 +829,18 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       By     : Wide_Wide_String) return Unbounded_Wide_Wide_String\n    is\n    begin\n-      return\n-        To_Unbounded_Wide_Wide_String\n+      return To_Unbounded_Wide_Wide_String\n         (Wide_Wide_Fixed.Replace_Slice\n            (Source.Reference (1 .. Source.Last), Low, High, By));\n    end Replace_Slice;\n \n    procedure Replace_Slice\n-     (Source   : in out Unbounded_Wide_Wide_String;\n-      Low      : Positive;\n-      High     : Natural;\n-      By       : Wide_Wide_String)\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_Wide_String)\n    is\n       Old : Wide_Wide_String_Access := Source.Reference;\n-\n    begin\n       Source.Reference := new Wide_Wide_String'\n         (Wide_Wide_Fixed.Replace_Slice\n@@ -800,6 +849,20 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       Free (Old);\n    end Replace_Slice;\n \n+   ------------------------------------\n+   -- Set_Unbounded_Wide_Wide_String --\n+   ------------------------------------\n+\n+   procedure Set_Unbounded_Wide_Wide_String\n+     (Target : out Unbounded_Wide_Wide_String;\n+      Source : Wide_Wide_String)\n+   is\n+   begin\n+      Target.Last          := Source'Length;\n+      Target.Reference     := new Wide_Wide_String (1 .. Source'Length);\n+      Target.Reference.all := Source;\n+   end Set_Unbounded_Wide_Wide_String;\n+\n    -----------\n    -- Slice --\n    -----------\n@@ -814,7 +877,6 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n \n       if Low > Source.Last + 1 or else High > Source.Last then\n          raise Index_Error;\n-\n       else\n          return Source.Reference (Low .. High);\n       end if;\n@@ -828,8 +890,7 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n      (Source : Unbounded_Wide_Wide_String;\n       Count  : Natural;\n       Pad    : Wide_Wide_Character := Wide_Wide_Space)\n-      return Unbounded_Wide_Wide_String\n-   is\n+      return Unbounded_Wide_Wide_String is\n    begin\n       return To_Unbounded_Wide_Wide_String\n         (Wide_Wide_Fixed.Tail\n@@ -842,7 +903,6 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       Pad    : Wide_Wide_Character := Wide_Wide_Space)\n    is\n       Old : Wide_Wide_String_Access := Source.Reference;\n-\n    begin\n       Source.Reference := new Wide_Wide_String'\n         (Wide_Wide_Fixed.Tail\n@@ -876,7 +936,7 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       return Result;\n    end To_Unbounded_Wide_Wide_String;\n \n-   --------------------\n+   -------------------\n    -- To_Wide_Wide_String --\n    --------------------\n \n@@ -887,6 +947,7 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       return Source.Reference (1 .. Source.Last);\n    end To_Wide_Wide_String;\n \n+\n    ---------------\n    -- Translate --\n    ---------------\n@@ -897,18 +958,18 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       return Unbounded_Wide_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_Wide_String\n-        (Wide_Wide_Fixed.Translate\n-           (Source.Reference (1 .. Source.Last), Mapping));\n+      return\n+        To_Unbounded_Wide_Wide_String\n+          (Wide_Wide_Fixed.Translate\n+             (Source.Reference (1 .. Source.Last), Mapping));\n    end Translate;\n \n    procedure Translate\n      (Source  : in out Unbounded_Wide_Wide_String;\n       Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping)\n    is\n    begin\n-      Wide_Wide_Fixed.Translate\n-        (Source.Reference (1 .. Source.Last), Mapping);\n+      Wide_Wide_Fixed.Translate (Source.Reference (1 .. Source.Last), Mapping);\n    end Translate;\n \n    function Translate\n@@ -917,18 +978,18 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       return Unbounded_Wide_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_Wide_String\n-        (Wide_Wide_Fixed.Translate\n-           (Source.Reference (1 .. Source.Last), Mapping));\n+      return\n+        To_Unbounded_Wide_Wide_String\n+          (Wide_Wide_Fixed.Translate\n+            (Source.Reference (1 .. Source.Last), Mapping));\n    end Translate;\n \n    procedure Translate\n      (Source  : in out Unbounded_Wide_Wide_String;\n       Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n    is\n    begin\n-      Wide_Wide_Fixed.Translate\n-        (Source.Reference (1 .. Source.Last), Mapping);\n+      Wide_Wide_Fixed.Translate (Source.Reference (1 .. Source.Last), Mapping);\n    end Translate;\n \n    ----------\n@@ -940,8 +1001,9 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       Side   : Trim_End) return Unbounded_Wide_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_Wide_String\n-        (Wide_Wide_Fixed.Trim (Source.Reference (1 .. Source.Last), Side));\n+      return\n+        To_Unbounded_Wide_Wide_String\n+          (Wide_Wide_Fixed.Trim (Source.Reference (1 .. Source.Last), Side));\n    end Trim;\n \n    procedure Trim\n@@ -964,9 +1026,10 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n       return Unbounded_Wide_Wide_String\n    is\n    begin\n-      return To_Unbounded_Wide_Wide_String\n-        (Wide_Wide_Fixed.Trim\n-           (Source.Reference (1 .. Source.Last), Left, Right));\n+      return\n+        To_Unbounded_Wide_Wide_String\n+          (Wide_Wide_Fixed.Trim\n+             (Source.Reference (1 .. Source.Last), Left, Right));\n    end Trim;\n \n    procedure Trim\n@@ -976,11 +1039,45 @@ package body Ada.Strings.Wide_Wide_Unbounded is\n    is\n       Old : Wide_Wide_String_Access := Source.Reference;\n    begin\n-      Source.Reference := new Wide_Wide_String'\n-        (Wide_Wide_Fixed.Trim\n-           (Source.Reference (1 .. Source.Last), Left, Right));\n+      Source.Reference :=\n+        new Wide_Wide_String'\n+          (Wide_Wide_Fixed.Trim\n+             (Source.Reference (1 .. Source.Last), Left, Right));\n       Source.Last      := Source.Reference'Length;\n       Free (Old);\n    end Trim;\n \n+   ---------------------\n+   -- Unbounded_Slice --\n+   ---------------------\n+\n+   function Unbounded_Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Unbounded_Wide_Wide_String\n+   is\n+   begin\n+      if Low > Source.Last + 1 or else High > Source.Last then\n+         raise Index_Error;\n+      else\n+         return\n+           To_Unbounded_Wide_Wide_String (Source.Reference.all (Low .. High));\n+      end if;\n+   end Unbounded_Slice;\n+\n+   procedure Unbounded_Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Target : out Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural)\n+   is\n+   begin\n+      if Low > Source.Last + 1 or else High > Source.Last then\n+         raise Index_Error;\n+      else\n+         Target :=\n+           To_Unbounded_Wide_Wide_String (Source.Reference.all (Low .. High));\n+      end if;\n+   end Unbounded_Slice;\n+\n end Ada.Strings.Wide_Wide_Unbounded;"}, {"sha": "f32a4b63182de74cbcb1bb137dfc0857a746cd02", "filename": "gcc/ada/a-stzunb.ads", "status": "modified", "additions": 86, "deletions": 17, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-stzunb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-stzunb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzunb.ads?ref=798a90555d7d72881c3d81d773328dc4156b4e6e", "patch": "@@ -40,7 +40,6 @@ with Ada.Finalization;\n \n package Ada.Strings.Wide_Wide_Unbounded is\n pragma Preelaborate (Wide_Wide_Unbounded);\n-\n    type Unbounded_Wide_Wide_String is private;\n \n    Null_Unbounded_Wide_Wide_String : constant Unbounded_Wide_Wide_String;\n@@ -64,6 +63,11 @@ pragma Preelaborate (Wide_Wide_Unbounded);\n    function To_Wide_Wide_String\n      (Source : Unbounded_Wide_Wide_String) return Wide_Wide_String;\n \n+   procedure Set_Unbounded_Wide_Wide_String\n+     (Target : out Unbounded_Wide_Wide_String;\n+      Source : Wide_Wide_String);\n+   pragma Ada_05 (Set_Unbounded_Wide_Wide_String);\n+\n    procedure Append\n      (Source   : in out Unbounded_Wide_Wide_String;\n       New_Item : Unbounded_Wide_Wide_String);\n@@ -77,8 +81,8 @@ pragma Preelaborate (Wide_Wide_Unbounded);\n       New_Item : Wide_Wide_Character);\n \n    function \"&\"\n-     (Left, Right : Unbounded_Wide_Wide_String)\n-     return Unbounded_Wide_Wide_String;\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Unbounded_Wide_Wide_String;\n \n    function \"&\"\n      (Left  : Unbounded_Wide_Wide_String;\n@@ -110,6 +114,19 @@ pragma Preelaborate (Wide_Wide_Unbounded);\n       Low    : Positive;\n       High   : Natural) return Wide_Wide_String;\n \n+   function Unbounded_Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Unbounded_Wide_Wide_String;\n+      pragma Ada_05 (Unbounded_Slice);\n+\n+   procedure Unbounded_Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Target : out Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural);\n+      pragma Ada_05 (Unbounded_Slice);\n+\n    function \"=\"\n      (Left  : Unbounded_Wide_Wide_String;\n       Right : Unbounded_Wide_Wide_String) return Boolean;\n@@ -179,7 +196,8 @@ pragma Preelaborate (Wide_Wide_Unbounded);\n       Pattern : Wide_Wide_String;\n       Going   : Direction := Forward;\n       Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n-                   Wide_Wide_Maps.Identity) return Natural;\n+                  Wide_Wide_Maps.Identity)\n+      return Natural;\n \n    function Index\n      (Source  : Unbounded_Wide_Wide_String;\n@@ -194,15 +212,49 @@ pragma Preelaborate (Wide_Wide_Unbounded);\n       Test   : Membership := Inside;\n       Going  : Direction  := Forward) return Natural;\n \n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n+                  Wide_Wide_Maps.Identity)\n+      return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n+      return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index\n+     (Source : Unbounded_Wide_Wide_String;\n+      Set    : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      From   : Positive;\n+      Test   : Membership := Inside;\n+      Going  : Direction := Forward) return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_Wide_String;\n+      Going  : Direction := Forward) return Natural;\n+\n    function Index_Non_Blank\n      (Source : Unbounded_Wide_Wide_String;\n+      From   : Positive;\n       Going  : Direction := Forward) return Natural;\n+   pragma Ada_05 (Index_Non_Blank);\n \n    function Count\n      (Source  : Unbounded_Wide_Wide_String;\n       Pattern : Wide_Wide_String;\n       Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n-                  Wide_Wide_Maps.Identity) return Natural;\n+                  Wide_Wide_Maps.Identity)\n+      return Natural;\n \n    function Count\n      (Source  : Unbounded_Wide_Wide_String;\n@@ -222,7 +274,7 @@ pragma Preelaborate (Wide_Wide_Unbounded);\n       Last   : out Natural);\n \n    ------------------------------------\n-   -- Wide_Wide_String Translation Subprograms --\n+   -- String Translation Subprograms --\n    ------------------------------------\n \n    function Translate\n@@ -244,7 +296,7 @@ pragma Preelaborate (Wide_Wide_Unbounded);\n       Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function);\n \n    ---------------------------------------\n-   -- Wide_Wide_String Transformation Subprograms --\n+   -- String Transformation Subprograms --\n    ---------------------------------------\n \n    function Replace_Slice\n@@ -254,10 +306,10 @@ pragma Preelaborate (Wide_Wide_Unbounded);\n       By     : Wide_Wide_String) return Unbounded_Wide_Wide_String;\n \n    procedure Replace_Slice\n-     (Source   : in out Unbounded_Wide_Wide_String;\n-      Low      : Positive;\n-      High     : Natural;\n-      By       : Wide_Wide_String);\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_Wide_String);\n \n    function Insert\n      (Source   : Unbounded_Wide_Wide_String;\n@@ -275,9 +327,9 @@ pragma Preelaborate (Wide_Wide_Unbounded);\n       New_Item : Wide_Wide_String) return Unbounded_Wide_Wide_String;\n \n    procedure Overwrite\n-     (Source    : in out Unbounded_Wide_Wide_String;\n-      Position  : Positive;\n-      New_Item  : Wide_Wide_String);\n+     (Source   : in out Unbounded_Wide_Wide_String;\n+      Position : Positive;\n+      New_Item : Wide_Wide_String);\n \n    function Delete\n      (Source  : Unbounded_Wide_Wide_String;\n@@ -351,11 +403,11 @@ private\n \n    function To_Unbounded_Wide\n      (S : Wide_Wide_String) return Unbounded_Wide_Wide_String\n-      renames To_Unbounded_Wide_Wide_String;\n+     renames To_Unbounded_Wide_Wide_String;\n \n    type Unbounded_Wide_Wide_String is new AF.Controlled with record\n       Reference : Wide_Wide_String_Access := Null_Wide_Wide_String'Access;\n-      Last      : Natural := 0;\n+      Last      : Natural            := 0;\n    end record;\n \n    --  The Unbounded_Wide_Wide_String is using a buffered implementation to\n@@ -369,12 +421,29 @@ private\n      (Unbounded_Wide_Wide_String, To_Unbounded_Wide, To_Wide_Wide_String);\n \n    pragma Finalize_Storage_Only (Unbounded_Wide_Wide_String);\n+   --  Finalization is required only for freeing storage\n \n    procedure Initialize (Object : in out Unbounded_Wide_Wide_String);\n    procedure Adjust     (Object : in out Unbounded_Wide_Wide_String);\n    procedure Finalize   (Object : in out Unbounded_Wide_Wide_String);\n+   procedure Realloc_For_Chunk\n+     (Source     : in out Unbounded_Wide_Wide_String;\n+      Chunk_Size : Natural);\n+   --  Adjust the size allocated for the string. Add at least Chunk_Size so it\n+   --  is safe to add a string of this size at the end of the current content.\n+   --  The real size allocated for the string is Chunk_Size + x of the current\n+   --  string size. This buffered handling makes the Append unbounded string\n+   --  routines very fast.\n \n    Null_Unbounded_Wide_Wide_String : constant Unbounded_Wide_Wide_String :=\n-     (AF.Controlled with Reference => Null_Wide_Wide_String'Access, Last => 0);\n+                                       (AF.Controlled with\n+                                          Reference =>\n+                                            Null_Wide_Wide_String'Access,\n+                                          Last => 0);\n+   --  Note: this declaration is illegal since library level controlled\n+   --  objects are not allowed in preelaborated units. See AI-161 for a\n+   --  discussion of this issue and an attempt to address it. Meanwhile,\n+   --  what happens in GNAT is that this check is omitted for internal\n+   --  implementation units (see check in sem_cat.adb).\n \n end Ada.Strings.Wide_Wide_Unbounded;"}, {"sha": "41d5ead70ac58b141e9a6593d07feedfa543bdfa", "filename": "gcc/ada/a-suteio.adb", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-suteio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-suteio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suteio.adb?ref=798a90555d7d72881c3d81d773328dc4156b4e6e", "patch": "@@ -31,8 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Strings.Unbounded.Aux; use Ada.Strings.Unbounded.Aux;\n-with Ada.Text_IO;               use Ada.Text_IO;\n+with Ada.Text_IO; use Ada.Text_IO;\n \n package body Ada.Strings.Unbounded.Text_IO is\n \n@@ -57,7 +56,8 @@ package body Ada.Strings.Unbounded.Text_IO is\n          Str1 := Str2;\n       end loop;\n \n-      Set_String (Result, Str1);\n+      Result.Reference := Str1;\n+      Result.Last      := Str1'Length;\n       return Result;\n    end Get_Line;\n \n@@ -78,49 +78,52 @@ package body Ada.Strings.Unbounded.Text_IO is\n          Str1 := Str2;\n       end loop;\n \n-      Set_String (Result, Str1);\n+      Result.Reference := Str1;\n+      Result.Last      := Str1'Length;\n       return Result;\n    end Get_Line;\n \n    procedure Get_Line (Item : out Unbounded_String) is\n-      Buffer : String (1 .. 1000);\n-      Last   : Natural;\n-      Str1   : String_Access;\n-      Str2   : String_Access;\n-\n    begin\n-      Get_Line (Buffer, Last);\n-      Str1 := new String'(Buffer (1 .. Last));\n-      while Last = Buffer'Last loop\n-         Get_Line (Buffer, Last);\n-         Str2 := new String'(Str1.all & Buffer (1 .. Last));\n-         Free (Str1);\n-         Str1 := Str2;\n-      end loop;\n-\n-      Set_String (Item, Str1);\n+      Get_Line (Current_Input, Item);\n    end Get_Line;\n \n    procedure Get_Line\n      (File : Ada.Text_IO.File_Type;\n       Item : out Unbounded_String)\n    is\n-      Buffer : String (1 .. 1000);\n-      Last   : Natural;\n-      Str1   : String_Access;\n-      Str2   : String_Access;\n-\n    begin\n-      Get_Line (File, Buffer, Last);\n-      Str1 := new String'(Buffer (1 .. Last));\n-      while Last = Buffer'Last loop\n-         Get_Line (Buffer, Last);\n-         Str2 := new String'(Str1.all & Buffer (1 .. Last));\n-         Free (Str1);\n-         Str1 := Str2;\n-      end loop;\n+      --  We are going to read into the string that is already there and\n+      --  allocated. Hopefully it is big enough now, if not, we will extend\n+      --  it in the usual manner using Realloc_For_Chunk.\n \n-      Set_String (Item, Str1);\n+      --  Make sure we start with at least 80 characters\n+\n+      if Item.Reference'Last < 80 then\n+         Realloc_For_Chunk (Item, 80);\n+      end if;\n+\n+      --  Loop to read data, filling current string as far as possible.\n+      --  Item.Last holds the number of characters read so far.\n+\n+      Item.Last := 0;\n+      loop\n+         Get_Line\n+           (File,\n+            Item.Reference (Item.Last + 1 .. Item.Reference'Last),\n+            Item.Last);\n+\n+         --  If we hit the end of the line before the end of the buffer, then\n+         --  we are all done, and the result length is properly set.\n+\n+         if Item.Last < Item.Reference'Last then\n+            return;\n+         end if;\n+\n+         --  If not enough room, double it and keep reading\n+\n+         Realloc_For_Chunk (Item, Item.Last);\n+      end loop;\n    end Get_Line;\n \n    ---------\n@@ -129,12 +132,12 @@ package body Ada.Strings.Unbounded.Text_IO is\n \n    procedure Put (U : Unbounded_String) is\n    begin\n-      Put (Get_String (U).all);\n+      Put (U.Reference (1 .. U.Last));\n    end Put;\n \n    procedure Put (File : File_Type; U : Unbounded_String) is\n    begin\n-      Put (File, Get_String (U).all);\n+      Put (File, U.Reference (1 .. U.Last));\n    end Put;\n \n    --------------\n@@ -143,12 +146,12 @@ package body Ada.Strings.Unbounded.Text_IO is\n \n    procedure Put_Line (U : Unbounded_String) is\n    begin\n-      Put_Line (Get_String (U).all);\n+      Put_Line (U.Reference (1 .. U.Last));\n    end Put_Line;\n \n    procedure Put_Line (File : File_Type; U : Unbounded_String) is\n    begin\n-      Put_Line (File, Get_String (U).all);\n+      Put_Line (File, U.Reference (1 .. U.Last));\n    end Put_Line;\n \n end Ada.Strings.Unbounded.Text_IO;"}, {"sha": "68cba087e7f61055bf81c36287a51e3e1133cd5a", "filename": "gcc/ada/a-swuwti.adb", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-swuwti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-swuwti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swuwti.adb?ref=798a90555d7d72881c3d81d773328dc4156b4e6e", "patch": "@@ -31,8 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Strings.Wide_Unbounded.Aux; use Ada.Strings.Wide_Unbounded.Aux;\n-with Ada.Wide_Text_IO;               use Ada.Wide_Text_IO;\n+with Ada.Wide_Text_IO; use Ada.Wide_Text_IO;\n \n package body Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n \n@@ -57,7 +56,8 @@ package body Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n          Str1 := Str2;\n       end loop;\n \n-      Set_Wide_String (Result, Str1);\n+      Result.Reference := Str1;\n+      Result.Last      := Str1'Length;\n       return Result;\n    end Get_Line;\n \n@@ -81,49 +81,52 @@ package body Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n          Str1 := Str2;\n       end loop;\n \n-      Set_Wide_String (Result, Str1);\n+      Result.Reference := Str1;\n+      Result.Last      := Str1'Length;\n       return Result;\n    end Get_Line;\n \n    procedure Get_Line (Item : out Unbounded_Wide_String) is\n-      Buffer : Wide_String (1 .. 1000);\n-      Last   : Natural;\n-      Str1   : Wide_String_Access;\n-      Str2   : Wide_String_Access;\n-\n    begin\n-      Get_Line (Buffer, Last);\n-      Str1 := new Wide_String'(Buffer (1 .. Last));\n-      while Last = Buffer'Last loop\n-         Get_Line (Buffer, Last);\n-         Str2 := new Wide_String'(Str1.all & Buffer (1 .. Last));\n-         Free (Str1);\n-         Str1 := Str2;\n-      end loop;\n-\n-      Set_Wide_String (Item, Str1);\n+      Get_Line (Current_Input, Item);\n    end Get_Line;\n \n    procedure Get_Line\n      (File : Ada.Wide_Text_IO.File_Type;\n       Item : out Unbounded_Wide_String)\n    is\n-      Buffer : Wide_String (1 .. 1000);\n-      Last   : Natural;\n-      Str1   : Wide_String_Access;\n-      Str2   : Wide_String_Access;\n-\n    begin\n-      Get_Line (File, Buffer, Last);\n-      Str1 := new Wide_String'(Buffer (1 .. Last));\n-      while Last = Buffer'Last loop\n-         Get_Line (Buffer, Last);\n-         Str2 := new Wide_String'(Str1.all & Buffer (1 .. Last));\n-         Free (Str1);\n-         Str1 := Str2;\n-      end loop;\n+      --  We are going to read into the string that is already there and\n+      --  allocated. Hopefully it is big enough now, if not, we will extend\n+      --  it in the usual manner using Realloc_For_Chunk.\n \n-      Set_Wide_String (Item, Str1);\n+      --  Make sure we start with at least 80 characters\n+\n+      if Item.Reference'Last < 80 then\n+         Realloc_For_Chunk (Item, 80);\n+      end if;\n+\n+      --  Loop to read data, filling current string as far as possible.\n+      --  Item.Last holds the number of characters read so far.\n+\n+      Item.Last := 0;\n+      loop\n+         Get_Line\n+           (File,\n+            Item.Reference (Item.Last + 1 .. Item.Reference'Last),\n+            Item.Last);\n+\n+         --  If we hit the end of the line before the end of the buffer, then\n+         --  we are all done, and the result length is properly set.\n+\n+         if Item.Last < Item.Reference'Last then\n+            return;\n+         end if;\n+\n+         --  If not enough room, double it and keep reading\n+\n+         Realloc_For_Chunk (Item, Item.Last);\n+      end loop;\n    end Get_Line;\n \n    ---------\n@@ -132,12 +135,12 @@ package body Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n \n    procedure Put (U : Unbounded_Wide_String) is\n    begin\n-      Put (Get_Wide_String (U).all);\n+      Put (U.Reference (1 .. U.Last));\n    end Put;\n \n    procedure Put (File : File_Type; U : Unbounded_Wide_String) is\n    begin\n-      Put (File, Get_Wide_String (U).all);\n+      Put (File, U.Reference (1 .. U.Last));\n    end Put;\n \n    --------------\n@@ -146,12 +149,12 @@ package body Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n \n    procedure Put_Line (U : Unbounded_Wide_String) is\n    begin\n-      Put_Line (Get_Wide_String (U).all);\n+      Put_Line (U.Reference (1 .. U.Last));\n    end Put_Line;\n \n    procedure Put_Line (File : File_Type; U : Unbounded_Wide_String) is\n    begin\n-      Put_Line (File, Get_Wide_String (U).all);\n+      Put_Line (File, U.Reference (1 .. U.Last));\n    end Put_Line;\n \n end Ada.Strings.Wide_Unbounded.Wide_Text_IO;"}, {"sha": "037a5ed820b1ba27984d32ba6a660d098f397b06", "filename": "gcc/ada/a-szuzti.adb", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-szuzti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798a90555d7d72881c3d81d773328dc4156b4e6e/gcc%2Fada%2Fa-szuzti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szuzti.adb?ref=798a90555d7d72881c3d81d773328dc4156b4e6e", "patch": "@@ -31,10 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Strings.Wide_Wide_Unbounded.Aux;\n-use Ada.Strings.Wide_Wide_Unbounded.Aux;\n-with Ada.Wide_Wide_Text_IO;\n-use Ada.Wide_Wide_Text_IO;\n+with Ada.Wide_Wide_Text_IO; use Ada.Wide_Wide_Text_IO;\n \n package body Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO is\n \n@@ -59,13 +56,13 @@ package body Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO is\n          Str1 := Str2;\n       end loop;\n \n-      Set_Wide_Wide_String (Result, Str1);\n+      Result.Reference := Str1;\n+      Result.Last      := Str1'Length;\n       return Result;\n    end Get_Line;\n \n    function Get_Line\n-     (File : Ada.Wide_Wide_Text_IO.File_Type)\n-      return Unbounded_Wide_Wide_String\n+     (File : Ada.Wide_Wide_Text_IO.File_Type) return Unbounded_Wide_Wide_String\n    is\n       Buffer : Wide_Wide_String (1 .. 1000);\n       Last   : Natural;\n@@ -84,49 +81,52 @@ package body Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO is\n          Str1 := Str2;\n       end loop;\n \n-      Set_Wide_Wide_String (Result, Str1);\n+      Result.Reference := Str1;\n+      Result.Last      := Str1'Length;\n       return Result;\n    end Get_Line;\n \n    procedure Get_Line (Item : out Unbounded_Wide_Wide_String) is\n-      Buffer : Wide_Wide_String (1 .. 1000);\n-      Last   : Natural;\n-      Str1   : Wide_Wide_String_Access;\n-      Str2   : Wide_Wide_String_Access;\n-\n    begin\n-      Get_Line (Buffer, Last);\n-      Str1 := new Wide_Wide_String'(Buffer (1 .. Last));\n-      while Last = Buffer'Last loop\n-         Get_Line (Buffer, Last);\n-         Str2 := new Wide_Wide_String'(Str1.all & Buffer (1 .. Last));\n-         Free (Str1);\n-         Str1 := Str2;\n-      end loop;\n-\n-      Set_Wide_Wide_String (Item, Str1);\n+      Get_Line (Current_Input, Item);\n    end Get_Line;\n \n    procedure Get_Line\n      (File : Ada.Wide_Wide_Text_IO.File_Type;\n       Item : out Unbounded_Wide_Wide_String)\n    is\n-      Buffer : Wide_Wide_String (1 .. 1000);\n-      Last   : Natural;\n-      Str1   : Wide_Wide_String_Access;\n-      Str2   : Wide_Wide_String_Access;\n-\n    begin\n-      Get_Line (File, Buffer, Last);\n-      Str1 := new Wide_Wide_String'(Buffer (1 .. Last));\n-      while Last = Buffer'Last loop\n-         Get_Line (Buffer, Last);\n-         Str2 := new Wide_Wide_String'(Str1.all & Buffer (1 .. Last));\n-         Free (Str1);\n-         Str1 := Str2;\n-      end loop;\n+      --  We are going to read into the string that is already there and\n+      --  allocated. Hopefully it is big enough now, if not, we will extend\n+      --  it in the usual manner using Realloc_For_Chunk.\n \n-      Set_Wide_Wide_String (Item, Str1);\n+      --  Make sure we start with at least 80 characters\n+\n+      if Item.Reference'Last < 80 then\n+         Realloc_For_Chunk (Item, 80);\n+      end if;\n+\n+      --  Loop to read data, filling current string as far as possible.\n+      --  Item.Last holds the number of characters read so far.\n+\n+      Item.Last := 0;\n+      loop\n+         Get_Line\n+           (File,\n+            Item.Reference (Item.Last + 1 .. Item.Reference'Last),\n+            Item.Last);\n+\n+         --  If we hit the end of the line before the end of the buffer, then\n+         --  we are all done, and the result length is properly set.\n+\n+         if Item.Last < Item.Reference'Last then\n+            return;\n+         end if;\n+\n+         --  If not enough room, double it and keep reading\n+\n+         Realloc_For_Chunk (Item, Item.Last);\n+      end loop;\n    end Get_Line;\n \n    ---------\n@@ -135,12 +135,12 @@ package body Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO is\n \n    procedure Put (U : Unbounded_Wide_Wide_String) is\n    begin\n-      Put (Get_Wide_Wide_String (U).all);\n+      Put (U.Reference (1 .. U.Last));\n    end Put;\n \n    procedure Put (File : File_Type; U : Unbounded_Wide_Wide_String) is\n    begin\n-      Put (File, Get_Wide_Wide_String (U).all);\n+      Put (File, U.Reference (1 .. U.Last));\n    end Put;\n \n    --------------\n@@ -149,12 +149,12 @@ package body Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO is\n \n    procedure Put_Line (U : Unbounded_Wide_Wide_String) is\n    begin\n-      Put_Line (Get_Wide_Wide_String (U).all);\n+      Put_Line (U.Reference (1 .. U.Last));\n    end Put_Line;\n \n    procedure Put_Line (File : File_Type; U : Unbounded_Wide_Wide_String) is\n    begin\n-      Put_Line (File, Get_Wide_Wide_String (U).all);\n+      Put_Line (File, U.Reference (1 .. U.Last));\n    end Put_Line;\n \n end Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO;"}]}