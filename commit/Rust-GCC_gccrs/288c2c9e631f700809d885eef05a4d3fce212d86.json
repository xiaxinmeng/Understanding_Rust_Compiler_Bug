{"sha": "288c2c9e631f700809d885eef05a4d3fce212d86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg4YzJjOWU2MzFmNzAwODA5ZDg4NWVlZjA1YTRkM2ZjZTIxMmQ4Ng==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-12-19T16:52:23Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-12-19T16:52:23Z"}, "message": "Flow fixes for cond_exec on ia64\n\nFrom-SVN: r38380", "tree": {"sha": "b96b042fc1d8bee20f8d52690b884ab696077e1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b96b042fc1d8bee20f8d52690b884ab696077e1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/288c2c9e631f700809d885eef05a4d3fce212d86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/288c2c9e631f700809d885eef05a4d3fce212d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/288c2c9e631f700809d885eef05a4d3fce212d86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/288c2c9e631f700809d885eef05a4d3fce212d86/comments", "author": null, "committer": null, "parents": [{"sha": "6a69653af2efb61defd912709eac5d2612c857a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a69653af2efb61defd912709eac5d2612c857a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a69653af2efb61defd912709eac5d2612c857a8"}], "stats": {"total": 344, "additions": 243, "deletions": 101}, "files": [{"sha": "a5d3171b5c9c086e780fa43c994595631e4e296e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/288c2c9e631f700809d885eef05a4d3fce212d86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/288c2c9e631f700809d885eef05a4d3fce212d86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=288c2c9e631f700809d885eef05a4d3fce212d86", "patch": "@@ -1,3 +1,16 @@\n+2000-12-19  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* flow.c (ior_reg_cond, nand_reg_cond, not_reg_cond): Rewrite\n+\tto use different representation.  All callers changed.\n+\t(and_reg_cond): Renamed from nand_reg_cond; caller changed.\n+\t(init_propagate_block_info): Don't test flags to determine\n+\twhether to compute conditional lifetimes.\n+\tAdjust code for new representation of conditional lifetimes.\n+\t(mark_regno_cond_dead): Similar adjustment.\n+\t(free_reg_cond_life_info): Similar adjustment.\n+\t(elim_reg_cond): New function.\n+\t(flush_reg_cond_1): Use it.\n+\n 2000-12-19  Catherine Moore  <clm@redhat.com>\n \n \t* reload1.c (reload_combine): Take multi-hard-regs into account"}, {"sha": "725f63fc8215e489e082ba30072991c18670eba2", "filename": "gcc/flow.c", "status": "modified", "additions": 230, "deletions": 101, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/288c2c9e631f700809d885eef05a4d3fce212d86/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/288c2c9e631f700809d885eef05a4d3fce212d86/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=288c2c9e631f700809d885eef05a4d3fce212d86", "patch": "@@ -392,9 +392,10 @@ static void free_reg_cond_life_info\tPARAMS ((splay_tree_value));\n static int flush_reg_cond_reg_1\t\tPARAMS ((splay_tree_node, void *));\n static void flush_reg_cond_reg\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t int));\n-static rtx ior_reg_cond\t\t\tPARAMS ((rtx, rtx));\n+static rtx elim_reg_cond\t\tPARAMS ((rtx, unsigned int));\n+static rtx ior_reg_cond\t\t\tPARAMS ((rtx, rtx, int));\n static rtx not_reg_cond\t\t\tPARAMS ((rtx));\n-static rtx nand_reg_cond\t\tPARAMS ((rtx, rtx));\n+static rtx and_reg_cond\t\t\tPARAMS ((rtx, rtx, int));\n #endif\n #ifdef AUTO_INC_DEC\n static void attempt_auto_inc\t\tPARAMS ((struct propagate_block_info *,\n@@ -3894,8 +3895,7 @@ init_propagate_block_info (bb, live, local_set, cond_local_set, flags)\n   /* If this block ends in a conditional branch, for each register live\n      from one side of the branch and not the other, record the register\n      as conditionally dead.  */\n-  if ((flags & (PROP_DEATH_NOTES | PROP_SCAN_DEAD_CODE))\n-      && GET_CODE (bb->end) == JUMP_INSN\n+  if (GET_CODE (bb->end) == JUMP_INSN\n       && any_condjump_p (bb->end))\n     {\n       regset_head diff_head;\n@@ -3969,7 +3969,7 @@ init_propagate_block_info (bb, live, local_set, cond_local_set, flags)\n \t\t cond = cond_false;\n \t       else\n \t\t cond = cond_true;\n-\t       rcli->condition = alloc_EXPR_LIST (0, cond, NULL_RTX);\n+\t       rcli->condition = cond;\n \n \t       splay_tree_insert (pbi->reg_cond_dead, i,\n \t\t\t\t  (splay_tree_value) rcli);\n@@ -4898,7 +4898,7 @@ mark_regno_cond_dead (pbi, regno, cond)\n \t     Record the current condition as the condition under\n \t     which it is dead.  */\n \t  rcli = (struct reg_cond_life_info *) xmalloc (sizeof (*rcli));\n-\t  rcli->condition = alloc_EXPR_LIST (0, cond, NULL_RTX);\n+\t  rcli->condition = cond;\n \t  splay_tree_insert (pbi->reg_cond_dead, regno,\n \t\t\t     (splay_tree_value) rcli);\n \n@@ -4913,7 +4913,7 @@ mark_regno_cond_dead (pbi, regno, cond)\n \t     Add the new condition to the old.  */\n \t  rcli = (struct reg_cond_life_info *) node->value;\n \t  ncond = rcli->condition;\n-\t  ncond = ior_reg_cond (ncond, cond);\n+\t  ncond = ior_reg_cond (ncond, cond, 1);\n \n \t  /* If the register is now unconditionally dead,\n \t     remove the entry in the splay_tree.  */\n@@ -4941,7 +4941,6 @@ free_reg_cond_life_info (value)\n      splay_tree_value value;\n {\n   struct reg_cond_life_info *rcli = (struct reg_cond_life_info *) value;\n-  free_EXPR_LIST_list (&rcli->condition);\n   free (rcli);\n }\n \n@@ -4955,36 +4954,26 @@ flush_reg_cond_reg_1 (node, data)\n   struct reg_cond_life_info *rcli;\n   int *xdata = (int *) data;\n   unsigned int regno = xdata[0];\n-  rtx c, *prev;\n \n   /* Don't need to search if last flushed value was farther on in\n      the in-order traversal.  */\n   if (xdata[1] >= (int) node->key)\n     return 0;\n-\n+  \n   /* Splice out portions of the expression that refer to regno.  */\n   rcli = (struct reg_cond_life_info *) node->value;\n-  c = *(prev = &rcli->condition);\n-  while (c)\n-    {\n-      if (regno == REGNO (XEXP (XEXP (c, 0), 0)))\n-\t{\n-\t  rtx next = XEXP (c, 1);\n-\t  free_EXPR_LIST_node (c);\n-\t  c = *prev = next;\n-\t}\n-      else\n-\tc = *(prev = &XEXP (c, 1));\n-    }\n+  rcli->condition = elim_reg_cond (rcli->condition, regno);\n \n-  /* If the entire condition is now NULL, signal the node to be removed.  */\n-  if (! rcli->condition)\n+  /* If the entire condition is now false, signal the node to be removed.  */\n+  if (rcli->condition == const0_rtx)\n     {\n       xdata[1] = node->key;\n       return -1;\n     }\n-  else\n-    return 0;\n+  else if (rcli->condition == const1_rtx)\n+    abort ();\n+\n+  return 0;\n }\n \n /* Flush all (sub) expressions referring to REGNO from REG_COND_LIVE.  */\n@@ -5005,111 +4994,251 @@ flush_reg_cond_reg (pbi, regno)\n   CLEAR_REGNO_REG_SET (pbi->reg_cond_reg, regno);\n }\n \n-/* Logical arithmetic on predicate conditions.  IOR, NOT and NAND.\n-   We actually use EXPR_LIST to chain the sub-expressions together\n-   instead of IOR because it's easier to manipulate and we have\n-   the lists.c functions to reuse nodes.\n-\n-   Return a new rtl expression as appropriate.  */\n+/* Logical arithmetic on predicate conditions.  IOR, NOT and AND.\n+   For ior/and, the ADD flag determines whether we want to add the new\n+   condition X to the old one unconditionally.  If it is zero, we will\n+   only return a new expression if X allows us to simplify part of\n+   OLD, otherwise we return OLD unchanged to the caller.\n+   If ADD is nonzero, we will return a new condition in all cases.  The\n+   toplevel caller of one of these functions should always pass 1 for\n+   ADD.  */\n \n static rtx\n-ior_reg_cond (old, x)\n+ior_reg_cond (old, x, add)\n      rtx old, x;\n+     int add;\n {\n-  enum rtx_code x_code;\n-  rtx x_reg;\n-  rtx c;\n-\n-  /* We expect these conditions to be of the form (eq reg 0).  */\n-  x_code = GET_CODE (x);\n-  if (GET_RTX_CLASS (x_code) != '<'\n-      || GET_CODE (x_reg = XEXP (x, 0)) != REG\n-      || XEXP (x, 1) != const0_rtx)\n-    abort ();\n+  rtx op0, op1;\n \n-  /* Search the expression for an existing sub-expression of X_REG.  */\n-  for (c = old; c; c = XEXP (c, 1))\n+  switch (GET_CODE (old))\n     {\n-      rtx y = XEXP (c, 0);\n-      if (REGNO (XEXP (y, 0)) == REGNO (x_reg))\n+    case IOR:\n+      op0 = ior_reg_cond (XEXP (old, 0), x, 0);\n+      op1 = ior_reg_cond (XEXP (old, 1), x, 0);\n+      if (op0 != XEXP (old, 0) || op1 != XEXP (old, 1))\n \t{\n-\t  /* If we find X already present in OLD, we need do nothing.  */\n-\t  if (GET_CODE (y) == x_code)\n-\t    return old;\n-\n-\t  /* If we find X being a compliment of a condition in OLD,\n-\t     then the entire condition is true.  */\n-\t  if (GET_CODE (y) == reverse_condition (x_code))\n+\t  if (op0 == const0_rtx)\n+\t    return op1;\n+\t  if (op1 == const0_rtx)\n+\t    return op0;\n+\t  if (op0 == const1_rtx || op1 == const1_rtx)\n \t    return const1_rtx;\n+\t  if (op0 == XEXP (old, 0))\n+\t    op0 = gen_rtx_IOR (0, op0, x);\n+\t  else\n+\t    op1 = gen_rtx_IOR (0, op1, x);\n+\t  return gen_rtx_IOR (0, op0, op1);\n \t}\n-    }\n+      if (! add)\n+\treturn old;\n+      return gen_rtx_IOR (0, old, x);\n+\n+    case AND:\n+      op0 = ior_reg_cond (XEXP (old, 0), x, 0);\n+      op1 = ior_reg_cond (XEXP (old, 1), x, 0);\n+      if (op0 != XEXP (old, 0) || op1 != XEXP (old, 1))\n+\t{\n+\t  if (op0 == const1_rtx)\n+\t    return op1;\n+\t  if (op1 == const1_rtx)\n+\t    return op0;\n+\t  if (op0 == const0_rtx || op1 == const0_rtx)\n+\t    return const0_rtx;\n+\t  if (op0 == XEXP (old, 0))\n+\t    op0 = gen_rtx_IOR (0, op0, x);\n+\t  else\n+\t    op1 = gen_rtx_IOR (0, op1, x);\n+\t  return gen_rtx_AND (0, op0, op1);\n+\t}\n+      if (! add)\n+\treturn old;\n+      return gen_rtx_IOR (0, old, x);\n+\n+    case NOT:\n+      op0 = and_reg_cond (XEXP (old, 0), not_reg_cond (x), 0);\n+      if (op0 != XEXP (old, 0))\n+\treturn not_reg_cond (op0);\n+      if (! add)\n+\treturn old;\n+      return gen_rtx_IOR (0, old, x);\n+\n+    case EQ:\n+    case NE:\n+      if ((GET_CODE (x) == EQ || GET_CODE (x) == NE)\n+\t  && GET_CODE (x) != GET_CODE (old)\n+\t  && REGNO (XEXP (x, 0)) == REGNO (XEXP (old, 0)))\n+\treturn const1_rtx;\n+      if (GET_CODE (x) == GET_CODE (old)\n+\t  && REGNO (XEXP (x, 0)) == REGNO (XEXP (old, 0)))\n+\treturn old;\n+      if (! add)\n+\treturn old;\n+      return gen_rtx_IOR (0, old, x);\n \n-  /* Otherwise just add to the chain.  */\n-  return alloc_EXPR_LIST (0, x, old);\n+    default:\n+      abort ();\n+    }\n }\n \n static rtx\n not_reg_cond (x)\n      rtx x;\n {\n   enum rtx_code x_code;\n-  rtx x_reg;\n \n-  /* We expect these conditions to be of the form (eq reg 0).  */\n+  if (x == const0_rtx)\n+    return const1_rtx;\n+  else if (x == const1_rtx)\n+    return const0_rtx;\n   x_code = GET_CODE (x);\n-  if (GET_RTX_CLASS (x_code) != '<'\n-      || GET_CODE (x_reg = XEXP (x, 0)) != REG\n-      || XEXP (x, 1) != const0_rtx)\n-    abort ();\n+  if (x_code == NOT)\n+    return XEXP (x, 0);\n+  if (GET_RTX_CLASS (x_code) == '<'\n+      && GET_CODE (XEXP (x, 0)) == REG)\n+    {\n+      if (XEXP (x, 1) != const0_rtx)\n+\tabort ();\n \n-  return alloc_EXPR_LIST (0, gen_rtx_fmt_ee (reverse_condition (x_code),\n-\t\t\t\t\t     VOIDmode, x_reg, const0_rtx),\n-\t\t\t  NULL_RTX);\n+      return gen_rtx_fmt_ee (reverse_condition (x_code),\n+\t\t\t     VOIDmode, XEXP (x, 0), const0_rtx);\n+    }\n+  return gen_rtx_NOT (0, x);\n }\n \n static rtx\n-nand_reg_cond (old, x)\n+and_reg_cond (old, x, add)\n      rtx old, x;\n+     int add;\n {\n-  enum rtx_code x_code;\n-  rtx x_reg;\n-  rtx c, *prev;\n-\n-  /* We expect these conditions to be of the form (eq reg 0).  */\n-  x_code = GET_CODE (x);\n-  if (GET_RTX_CLASS (x_code) != '<'\n-      || GET_CODE (x_reg = XEXP (x, 0)) != REG\n-      || XEXP (x, 1) != const0_rtx)\n-    abort ();\n+  rtx op0, op1;\n \n-  /* Search the expression for an existing sub-expression of X_REG.  */\n-\n-  for (c = *(prev = &old); c; c = *(prev = &XEXP (c, 1)))\n+  switch (GET_CODE (old))\n     {\n-      rtx y = XEXP (c, 0);\n-      if (REGNO (XEXP (y, 0)) == REGNO (x_reg))\n+    case IOR:\n+      op0 = and_reg_cond (XEXP (old, 0), x, 0);\n+      op1 = and_reg_cond (XEXP (old, 1), x, 0);\n+      if (op0 != XEXP (old, 0) || op1 != XEXP (old, 1))\n \t{\n-\t  /* If we find X already present in OLD, then we need to\n-\t     splice it out.  */\n-\t  if (GET_CODE (y) == x_code)\n-\t    {\n-\t      *prev = XEXP (c, 1);\n-\t      free_EXPR_LIST_node (c);\n-\t      return old ? old : const0_rtx;\n-\t    }\n-\n-\t  /* If we find X being a compliment of a condition in OLD,\n-\t     then we need do nothing.  */\n-\t  if (GET_CODE (y) == reverse_condition (x_code))\n-\t    return old;\n+\t  if (op0 == const0_rtx)\n+\t    return op1;\n+\t  if (op1 == const0_rtx)\n+\t    return op0;\n+\t  if (op0 == const1_rtx || op1 == const1_rtx)\n+\t    return const1_rtx;\n+\t  if (op0 == XEXP (old, 0))\n+\t    op0 = gen_rtx_AND (0, op0, x);\n+\t  else\n+\t    op1 = gen_rtx_AND (0, op1, x);\n+\t  return gen_rtx_IOR (0, op0, op1);\n \t}\n+      if (! add)\n+\treturn old;\n+      return gen_rtx_AND (0, old, x);\n+\n+    case AND:\n+      op0 = and_reg_cond (XEXP (old, 0), x, 0);\n+      op1 = and_reg_cond (XEXP (old, 1), x, 0);\n+      if (op0 != XEXP (old, 0) || op1 != XEXP (old, 1))\n+\t{\n+\t  if (op0 == const1_rtx)\n+\t    return op1;\n+\t  if (op1 == const1_rtx)\n+\t    return op0;\n+\t  if (op0 == const0_rtx || op1 == const0_rtx)\n+\t    return const0_rtx;\n+\t  if (op0 == XEXP (old, 0))\n+\t    op0 = gen_rtx_AND (0, op0, x);\n+\t  else\n+\t    op1 = gen_rtx_AND (0, op1, x);\n+\t  return gen_rtx_AND (0, op0, op1);\n+\t}\n+      if (! add)\n+\treturn old;\n+      return gen_rtx_AND (0, old, x);\n+\n+    case NOT:\n+      op0 = ior_reg_cond (XEXP (old, 0), not_reg_cond (x), 0);\n+      if (op0 != XEXP (old, 0))\n+\treturn not_reg_cond (op0);\n+      if (! add)\n+\treturn old;\n+      return gen_rtx_AND (0, old, x);\n+\n+    case EQ:\n+    case NE:\n+      if ((GET_CODE (x) == EQ || GET_CODE (x) == NE)\n+\t  && GET_CODE (x) != GET_CODE (old)\n+\t  && REGNO (XEXP (x, 0)) == REGNO (XEXP (old, 0)))\n+\treturn const0_rtx;\n+      if (GET_CODE (x) == GET_CODE (old)\n+\t  && REGNO (XEXP (x, 0)) == REGNO (XEXP (old, 0)))\n+\treturn old;\n+      if (! add)\n+\treturn old;\n+      return gen_rtx_AND (0, old, x);\n+\n+    default:\n+      abort ();\n     }\n+}\n+\n+/* Given a condition X, remove references to reg REGNO and return the\n+   new condition.  The removal will be done so that all conditions\n+   involving REGNO are considered to evaluate to false.  This function\n+   is used when the value of REGNO changes.  */\n \n-  /* Otherwise, by implication, the register in question is now live for\n-     the inverse of the condition X.  */\n-  return alloc_EXPR_LIST (0, gen_rtx_fmt_ee (reverse_condition (x_code),\n-\t\t\t\t\t     VOIDmode, x_reg, const0_rtx),\n-\t\t\t  old);\n+static rtx\n+elim_reg_cond (x, regno)\n+     rtx x;\n+     unsigned int regno;\n+{\n+  rtx op0, op1;\n+  switch (GET_CODE (x))\n+    {\n+    case AND:\n+      op0 = elim_reg_cond (XEXP (x, 0), regno);\n+      op1 = elim_reg_cond (XEXP (x, 1), regno);\n+      if (op0 == const0_rtx || op1 == const0_rtx)\n+\treturn const0_rtx;\n+      if (op0 == const1_rtx)\n+\treturn op1;\n+      if (op1 == const1_rtx)\n+\treturn op0;\n+      if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n+\treturn x;\n+      return gen_rtx_AND (0, op0, op1);\n+\n+    case IOR:\n+      op0 = elim_reg_cond (XEXP (x, 0), regno);\n+      op1 = elim_reg_cond (XEXP (x, 1), regno);\n+      if (op0 == const1_rtx || op1 == const1_rtx)\n+\treturn const1_rtx;\n+      if (op0 == const0_rtx)\n+\treturn op1;\n+      if (op1 == const0_rtx)\n+\treturn op0;\n+      if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n+\treturn x;\n+      return gen_rtx_IOR (0, op0, op1);\n+\n+    case NOT:\n+      op0 = elim_reg_cond (XEXP (x, 0), regno);\n+      if (op0 == const0_rtx)\n+\treturn const1_rtx;\n+      if (op0 == const1_rtx)\n+\treturn const0_rtx;\n+      if (op0 != XEXP (x, 0))\n+\treturn not_reg_cond (op0);\n+      return x;\n+\n+    case EQ:\n+    case NE:\n+      if (REGNO (XEXP (x, 0)) == regno)\n+\treturn const0_rtx;\n+      return x;\n+    default:\n+      abort ();\n+    }\n }\n #endif /* HAVE_conditional_execution */\n \f\n@@ -5513,7 +5642,7 @@ mark_used_reg (pbi, reg, cond, insn)\n \t\t Subtract the new life cond from the old death cond.  */\n \t      rcli = (struct reg_cond_life_info *) node->value;\n \t      ncond = rcli->condition;\n-\t      ncond = nand_reg_cond (ncond, cond);\n+\t      ncond = and_reg_cond (ncond, not_reg_cond (cond), 1);\n \n \t      /* If the register is now unconditionally live, remove the\n \t\t entry in the splay_tree.  */"}]}