{"sha": "c3af9fc81e69cbbe49f33268669d60bfab2e00d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNhZjlmYzgxZTY5Y2JiZTQ5ZjMzMjY4NjY5ZDYwYmZhYjJlMDBkNg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-03-15T19:48:38Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-03-15T19:48:38Z"}, "message": "(reg_known_equiv_p): New variable.\n\n(init_alias_analysis): Allocate and compute reg_known_equiv_p.\n(sched_analyze_1): Reenable code for REG_EQUIV notes, using\nreg_known_equiv_p so that it is only used on REG_EQUIV notes.\n(sched_analyze_2): Likewise.  Only pass memory addresses to the\nsched_analyze_2 call.\n\nFrom-SVN: r3746", "tree": {"sha": "1c1a31a5bd738c831ebb50f75accf361b2820c63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c1a31a5bd738c831ebb50f75accf361b2820c63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3af9fc81e69cbbe49f33268669d60bfab2e00d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3af9fc81e69cbbe49f33268669d60bfab2e00d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3af9fc81e69cbbe49f33268669d60bfab2e00d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3af9fc81e69cbbe49f33268669d60bfab2e00d6/comments", "author": null, "committer": null, "parents": [{"sha": "581c26f9461f19f9e63fb05cd9a034c15d272293", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581c26f9461f19f9e63fb05cd9a034c15d272293", "html_url": "https://github.com/Rust-GCC/gccrs/commit/581c26f9461f19f9e63fb05cd9a034c15d272293"}], "stats": {"total": 69, "additions": 36, "deletions": 33}, "files": [{"sha": "dc944e46ab96a38e72209608244ef50b248e2023", "filename": "gcc/sched.c", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3af9fc81e69cbbe49f33268669d60bfab2e00d6/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3af9fc81e69cbbe49f33268669d60bfab2e00d6/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=c3af9fc81e69cbbe49f33268669d60bfab2e00d6", "patch": "@@ -294,6 +294,19 @@ void schedule_insns ();\n    for pseudo-register N.  */\n static rtx *reg_known_value;\n \n+/* Vector recording for each reg_known_value whether it is due to a\n+   REG_EQUIV note.  Future passes (viz., reload) may replace the\n+   pseudo with the equivalent expression and so we account for the\n+   dependences that would be introduced if that happens. */\n+/* ??? This is a problem only on the Convex.  The REG_EQUIV notes created in\n+   assign_parms mention the arg pointer, and there are explicit insns in the\n+   RTL that modify the arg pointer.  Thus we must ensure that such insns don't\n+   get scheduled across each other because that would invalidate the REG_EQUIV\n+   notes.  One could argue that the REG_EQUIV notes are wrong, but solving\n+   the problem in the scheduler will likely give better code, so we do it\n+   here.  */\n+static char *reg_known_equiv_p;\n+\n /* Indicates number of valid entries in reg_known_value.  */\n static int reg_known_value_size;\n \n@@ -341,6 +354,12 @@ init_alias_analysis ()\n   bzero (reg_known_value+FIRST_PSEUDO_REGISTER,\n \t (maxreg-FIRST_PSEUDO_REGISTER) * sizeof (rtx));\n \n+  reg_known_equiv_p\n+    = (char *) oballoc ((maxreg-FIRST_PSEUDO_REGISTER) * sizeof (char))\n+      - FIRST_PSEUDO_REGISTER;\n+  bzero (reg_known_equiv_p+FIRST_PSEUDO_REGISTER,\n+\t (maxreg-FIRST_PSEUDO_REGISTER) * sizeof (char));\n+\n   /* Fill in the entries with known constant values.  */\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if ((set = single_set (insn)) != 0\n@@ -350,7 +369,11 @@ init_alias_analysis ()\n \t     && reg_n_sets[REGNO (SET_DEST (set))] == 1)\n \t    || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n \t&& GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n-      reg_known_value[REGNO (SET_DEST (set))] = XEXP (note, 0);\n+      {\n+\tint regno = REGNO (SET_DEST (set));\n+\treg_known_value[regno] = XEXP (note, 0);\n+\treg_known_equiv_p[regno] = REG_NOTE_KIND (note) == REG_EQUIV;\n+      }\n \n   /* Fill in the remaining entries.  */\n   while (--maxreg >= FIRST_PSEUDO_REGISTER)\n@@ -1622,24 +1645,13 @@ sched_analyze_1 (x, insn)\n \t    add_dependence (insn, reg_last_sets[regno], REG_DEP_OUTPUT);\n \t  reg_last_sets[regno] = insn;\n \n-#if 0\n-\t  /* ??? This code has two serious problems:\n-\t     1) It can cause an infinite loop if regno is mentioned in\n-\t        its reg_known_value.\n-\t     2) It can cause execution time exponential in the size of the\n-\t        input if there are long chains of reg_known_values pointing\n-\t\tto other reg_known_values.\n-\t     This code was specifically added to handle fake argument pointers.\n-\t     It may need to be rewritten to just handle that specific case.  */\n-\n \t  /* Pseudos that are REG_EQUIV to something may be replaced\n-\t     by that during reloading, so we can potentially read\n-\t     quantities mentioned in those addresses. */\n-\t  if (! reload_completed)\n-\t    if (reg_known_value[regno] != regno_reg_rtx[regno])\n-\t      if (GET_CODE (reg_known_value[regno]) == MEM)\n-\t\tsched_analyze_2 (XEXP (reg_known_value[regno], 0), insn);\n-#endif\n+\t     by that during reloading.  We need only add dependencies for\n+\t     the address in the REG_EQUIV note.  */\n+\t  if (! reload_completed\n+\t      && reg_known_equiv_p[regno]\n+\t      && GET_CODE (reg_known_value[regno]) == MEM)\n+\t    sched_analyze_2 (XEXP (reg_known_value[regno], 0), insn);\n \n \t  /* Don't let it cross a call after scheduling if it doesn't\n \t     already cross one.  */\n@@ -1793,22 +1805,13 @@ sched_analyze_2 (x, insn)\n \t    if (reg_last_sets[regno])\n \t      add_dependence (insn, reg_last_sets[regno], 0);\n \n-#if 0\n-\t  /* ??? This code has two serious problems:\n-\t     1) It can cause an infinite loop if regno is mentioned in\n-\t        its reg_known_value.\n-\t     2) It can cause execution time exponential in the size of the\n-\t        input if there are long chains of reg_known_values pointing\n-\t\tto other reg_known_values.\n-\t     This code was specifically added to handle fake argument pointers.\n-\t     It may need to be rewritten to just handle that specific case.  */\n-\n \t    /* Pseudos that are REG_EQUIV to something may be replaced\n-\t       by that, so we depend on anything mentioned there too. */\n-\t    if (! reload_completed)\n-\t      if (reg_known_value[regno] != regno_reg_rtx[regno])\n-\t\tsched_analyze_2 (reg_known_value[regno], insn);\n-#endif\n+\t       by that during reloading.  We need only add dependencies for\n+\t       the address in the REG_EQUIV note.  */\n+\t    if (! reload_completed\n+\t\t&& reg_known_equiv_p[regno]\n+\t\t&& GET_CODE (reg_known_value[regno]) == MEM)\n+\t      sched_analyze_2 (XEXP (reg_known_value[regno], 0), insn);\n \n \t    /* If the register does not already cross any calls, then add this\n \t       insn to the sched_before_next_call list so that it will still"}]}