{"sha": "f35a733d3718e953065fa366bfcef1d95dfb2a10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM1YTczM2QzNzE4ZTk1MzA2NWZhMzY2YmZjZWYxZDk1ZGZiMmExMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-25T12:51:30Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-25T12:51:30Z"}, "message": "cp-tree.h (LOOKUP_SEEN_P, [...]): New.\n\n\tgcc/cp/\n\t* cp-tree.h (LOOKUP_SEEN_P, LOOKUP_FOUND_P): New.\n\t* name-lookup.h (lookup_arg_dependent): Return plain tree.\n\t* name-lookup.c (arg_lookup, arg_assoc, arg_assoc_args)\n\targ_assoc_args_vec, arg_assoc_type, add_function,\n\targ_assoc_namespace, arg_assoc_class_only, arg_assoc_bases,\n\targ_assoc_class, arg_assoc_template_arg, arg_assoc,\n\tlookup_arg_dependent_1): Delete.\n\t(name_lookup): New lookup object.\n\t(name_lookup::preserve_state, name_lookup::restore_state)\n\tname_lookup::mark_seen, name_lookup::find_and_mark,\n\tname_lookup::add_fns, name_lookup::adl_namespace_only,\n\tname_lookup::adl_namespace, name_lookup::adl_class_only,\n\tname_lookup::adl_bases, name_lookup::adl_class,\n\tname_lookup::adl_expr, name_lookup::adl_type,\n\tname_lookup::adl_template_arg, name_lookup::search_adl): New.\n\t(lookup_arg_dependent): Return a plain tree.  Adjust.\n\t(is_associated_namespace): Move later.\n\tgcc/cp/\n\t* g++.dg/lookup/koenig14.C: New.\n\nFrom-SVN: r248457", "tree": {"sha": "e620817e8d290cda07164b13a24b2371effe7961", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e620817e8d290cda07164b13a24b2371effe7961"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f35a733d3718e953065fa366bfcef1d95dfb2a10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35a733d3718e953065fa366bfcef1d95dfb2a10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f35a733d3718e953065fa366bfcef1d95dfb2a10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35a733d3718e953065fa366bfcef1d95dfb2a10/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8442a5fbf0a061a9cec06118218218c12e499095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8442a5fbf0a061a9cec06118218218c12e499095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8442a5fbf0a061a9cec06118218218c12e499095"}], "stats": {"total": 869, "additions": 494, "deletions": 375}, "files": [{"sha": "8d4fc605e58ccfee88fbd44f67bed91d1d7832c0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f35a733d3718e953065fa366bfcef1d95dfb2a10", "patch": "@@ -1,3 +1,23 @@\n+2017-05-25  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (LOOKUP_SEEN_P, LOOKUP_FOUND_P): New.\n+\t* name-lookup.h (lookup_arg_dependent): Return plain tree.\n+\t* name-lookup.c (arg_lookup, arg_assoc, arg_assoc_args,\n+\targ_assoc_args_vec, arg_assoc_type, add_function,\n+\targ_assoc_namespace, arg_assoc_class_only, arg_assoc_bases,\n+\targ_assoc_class, arg_assoc_template_arg, arg_assoc,\n+\tlookup_arg_dependent_1): Delete.\n+\t(name_lookup): New lookup object.\n+\t(name_lookup::preserve_state, name_lookup::restore_state,\n+\tname_lookup::mark_seen, name_lookup::find_and_mark,\n+\tname_lookup::add_fns, name_lookup::adl_namespace_only,\n+\tname_lookup::adl_namespace, name_lookup::adl_class_only,\n+\tname_lookup::adl_bases, name_lookup::adl_class,\n+\tname_lookup::adl_expr, name_lookup::adl_type,\n+\tname_lookup::adl_template_arg, name_lookup::search_adl): New.\n+\t(lookup_arg_dependent): Return a plain tree.  Adjust.\n+\t(is_associated_namespace): Move later.\n+\t\n 2017-05-24  Nathan Sidwell  <nathan@acm.org>\n \n \t* friend.c (do_friend): Remove check for existing decl."}, {"sha": "66bf376584c22afa37280cb142f87d75f95b1902", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f35a733d3718e953065fa366bfcef1d95dfb2a10", "patch": "@@ -395,6 +395,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       DECL_TINFO_P (in VAR_DECL)\n       FUNCTION_REF_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n       OVL_LOOKUP_P (in OVERLOAD)\n+      LOOKUP_FOUND_P (in RECORD_TYPE, UNION_TYPE, NAMESPACE_DECL)\n    5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)\n       DECL_VTABLE_OR_VTT_P (in VAR_DECL)\n       FUNCTION_RVALUE_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n@@ -648,10 +649,17 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n     && MAIN_NAME_P (DECL_NAME (NODE))\t\t\t\\\n     && flag_hosted)\n \n-/* The overloaded FUNCTION_DECL.  */\n+/* Lookup walker marking.  */\n+#define LOOKUP_SEEN_P(NODE) TREE_VISITED(NODE)\n+#define LOOKUP_FOUND_P(NODE) \\\n+  TREE_LANG_FLAG_4 (TREE_CHECK3(NODE,RECORD_TYPE,UNION_TYPE,NAMESPACE_DECL))\n+\n+/* These two accessors should only be used by OVL manipulators.\n+   Other users should use iterators and convenience functions.  */\n #define OVL_FUNCTION(NODE) \\\n   (((struct tree_overload*)OVERLOAD_CHECK (NODE))->function)\n #define OVL_CHAIN(NODE)      TREE_CHAIN (NODE)\n+\n /* Polymorphic access to FUNCTION and CHAIN.  */\n #define OVL_CURRENT(NODE)\t\\\n   ((TREE_CODE (NODE) == OVERLOAD) ? OVL_FUNCTION (NODE) : (NODE))"}, {"sha": "dd930ac5c4a29bc9f4261eca8d13a4fbf3d776bd", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 430, "deletions": 373, "changes": 803, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=f35a733d3718e953065fa366bfcef1d95dfb2a10", "patch": "@@ -160,208 +160,274 @@ find_local_binding (cp_binding_level *b, tree name)\n   return NULL;\n }\n \n-/* [basic.lookup.koenig] */\n-/* A nonzero return value in the functions below indicates an error.  */\n-\n-struct arg_lookup\n-{\n-  tree name;\n-  vec<tree, va_gc> *args;\n-  vec<tree, va_gc> *namespaces;\n-  vec<tree, va_gc> *classes;\n-  tree functions;\n+struct name_lookup\n+{\n+public:\n+  tree name;\t/* The identifier being looked for.  */\n+  tree value;\t/* A (possibly ambiguous) set of things found.  */\n+  tree type;\t/* A type that has been found.  */\n+  vec<tree, va_heap, vl_embed> *scopes;\n+  name_lookup *previous; /* Previously active lookup.  */\n   hash_set<tree> *fn_set;\n-};\n \n-static bool arg_assoc (struct arg_lookup*, tree);\n-static bool arg_assoc_args (struct arg_lookup*, tree);\n-static bool arg_assoc_args_vec (struct arg_lookup*, vec<tree, va_gc> *);\n-static bool arg_assoc_type (struct arg_lookup*, tree);\n-static bool add_function (struct arg_lookup *, tree);\n-static bool arg_assoc_namespace (struct arg_lookup *, tree);\n-static bool arg_assoc_class_only (struct arg_lookup *, tree);\n-static bool arg_assoc_bases (struct arg_lookup *, tree);\n-static bool arg_assoc_class (struct arg_lookup *, tree);\n-static bool arg_assoc_template_arg (struct arg_lookup*, tree);\n-\n-/* Add a function to the lookup structure.\n-   Returns true on error.  */\n+protected:\n+  /* Marked scope stack for outermost name lookup.  */\n+  static vec<tree, va_heap, vl_embed> *shared_scopes;\n+  /* Currently active lookup.  */\n+  static name_lookup *active;\n \n-static bool\n-add_function (struct arg_lookup *k, tree fn)\n-{\n-  if (!is_overloaded_fn (fn))\n-    /* All names except those of (possibly overloaded) functions and\n-       function templates are ignored.  */;\n-  else if (k->fn_set && k->fn_set->add (fn))\n-    /* It's already in the list.  */;\n-  else if (!k->functions && TREE_CODE (fn) != TEMPLATE_DECL)\n-    k->functions = fn;\n-  else if (fn == k->functions)\n-    ;\n-  else\n-    k->functions = lookup_add (fn, k->functions);\n+public:\n+  name_lookup (tree n)\n+  : name (n), value (NULL_TREE), type (NULL_TREE),\n+    scopes (NULL), previous (NULL), fn_set (NULL)\n+  {\n+    preserve_state ();\n+  }\n+  ~name_lookup ()\n+  {\n+    gcc_checking_assert (!fn_set);\n+    restore_state ();\n+  }\n \n-  return false;\n-}\n+private: /* Uncopyable, unmovable, unassignable. I am a rock. */\n+  name_lookup (const name_lookup &);\n+  name_lookup &operator= (const name_lookup &);\n \n-/* Returns true iff CURRENT has declared itself to be an associated\n-   namespace of SCOPE via a strong using-directive (or transitive chain\n-   thereof).  Both are namespaces.  */\n+protected:\n+  static bool seen_p (tree scope)\n+  {\n+    return LOOKUP_SEEN_P (scope);\n+  }\n+  static bool found_p (tree scope)\n+  {\n+    return LOOKUP_FOUND_P (scope);\n+  }\n+  \n+  void mark_seen (tree scope); /* Mark and add to scope vector. */\n+  static void mark_found (tree scope)\n+  {\n+    gcc_checking_assert (seen_p (scope));\n+    LOOKUP_FOUND_P (scope) = true;\n+  }\n+  bool see_and_mark (tree scope)\n+  {\n+    bool ret = seen_p (scope);\n+    if (!ret)\n+      mark_seen (scope);\n+    return ret;\n+  }\n+  bool find_and_mark (tree scope);\n+\n+private:\n+  void preserve_state ();\n+  void restore_state ();\n+\n+ private:\n+  void add_fns (tree);\n+\n+  void adl_expr (tree);\n+  void adl_type (tree);\n+  void adl_template_arg (tree);\n+  void adl_class (tree);\n+  void adl_bases (tree);\n+  void adl_class_only (tree);\n+  void adl_namespace (tree);\n+  void adl_namespace_only (tree);\n+\n+public:\n+  tree search_adl (tree fns, vec<tree, va_gc> *args);\n+};\n \n-bool\n-is_associated_namespace (tree current, tree scope)\n-{\n-  vec<tree, va_gc> *seen = make_tree_vector ();\n-  vec<tree, va_gc> *todo = make_tree_vector ();\n-  tree t;\n-  bool ret;\n+/* Scope stack shared by all outermost lookups.  This avoids us\n+   allocating and freeing on every single lookup.  */\n+vec<tree, va_heap, vl_embed> *name_lookup::shared_scopes;\n \n-  while (1)\n+/* Currently active lookup.  */\n+name_lookup *name_lookup::active;\n+\n+/* Name lookup is recursive, becase ADL can cause template\n+   instatiation.  This is of course a rare event, so we optimize for\n+   it not happening.  When we discover an active name-lookup, which\n+   must be an ADL lookup,  we need to unmark the marked scopes and also\n+   unmark the lookup we might have been accumulating.  */\n+\n+void\n+name_lookup::preserve_state ()\n+{\n+  previous = active;\n+  if (previous)\n     {\n-      if (scope == current)\n-\t{\n-\t  ret = true;\n-\t  break;\n-\t}\n-      vec_safe_push (seen, scope);\n-      for (t = DECL_NAMESPACE_ASSOCIATIONS (scope); t; t = TREE_CHAIN (t))\n-\tif (!vec_member (TREE_PURPOSE (t), seen))\n-\t  vec_safe_push (todo, TREE_PURPOSE (t));\n-      if (!todo->is_empty ())\n+      unsigned length = vec_safe_length (previous->scopes);\n+      vec_safe_reserve (previous->scopes, length * 2);\n+      for (unsigned ix = length; ix--;)\n \t{\n-\t  scope = todo->last ();\n-\t  todo->pop ();\n-\t}\n-      else\n-\t{\n-\t  ret = false;\n-\t  break;\n-\t}\n-    }\n+\t  tree decl = (*previous->scopes)[ix];\n \n-  release_tree_vector (seen);\n-  release_tree_vector (todo);\n+\t  gcc_checking_assert (LOOKUP_SEEN_P (decl));\n+\t  LOOKUP_SEEN_P (decl) = false;\n \n-  return ret;\n+\t  /* Preserve the FOUND_P state on the interrupted lookup's\n+\t     stack.  */\n+\t  if (LOOKUP_FOUND_P (decl))\n+\t    {\n+\t      LOOKUP_FOUND_P (decl) = false;\n+\t      previous->scopes->quick_push (decl);\n+\t    }\n+\t}\n+    }\n+  else\n+    scopes = shared_scopes;\n+  active = this;\n }\n \n-/* Add functions of a namespace to the lookup structure.\n-   Returns true on error.  */\n+/* Restore the marking state of a lookup we interrupted.  */\n \n-static bool\n-arg_assoc_namespace (struct arg_lookup *k, tree scope)\n+void\n+name_lookup::restore_state ()\n {\n-  tree value;\n+  /* Unmark and empty this lookup's scope stack.  */\n+  for (unsigned ix = vec_safe_length (scopes); ix--;)\n+    {\n+      tree decl = scopes->pop ();\n+      gcc_checking_assert (LOOKUP_SEEN_P (decl));\n+      LOOKUP_SEEN_P (decl) = false;\n+      LOOKUP_FOUND_P (decl) = false;\n+    }\n \n-  if (vec_member (scope, k->namespaces))\n-    return false;\n-  vec_safe_push (k->namespaces, scope);\n+  active = previous;\n+  if (previous)\n+    {\n+      unsigned length = vec_safe_length (previous->scopes);\n+      for (unsigned ix = 0; ix != length; ix++)\n+\t{\n+\t  tree decl = (*previous->scopes)[ix];\n+\t  if (LOOKUP_SEEN_P (decl))\n+\t    {\n+\t      /* The remainder of the scope stack must be recording\n+\t\t FOUND_P decls, which we want to pop off.  */\n+\t      do\n+\t\t{\n+\t\t  tree decl = previous->scopes->pop ();\n+\t\t  gcc_checking_assert (LOOKUP_SEEN_P (decl)\n+\t\t\t\t       && !LOOKUP_FOUND_P (decl));\n+\t\t  LOOKUP_FOUND_P (decl) = true;\n+\t\t}\n+\t      while (++ix != length);\n+\t      break;\n+\t    }\n \n-  /* Check out our super-users.  */\n-  for (value = DECL_NAMESPACE_ASSOCIATIONS (scope); value;\n-       value = TREE_CHAIN (value))\n-    if (arg_assoc_namespace (k, TREE_PURPOSE (value)))\n-      return true;\n+\t  gcc_checking_assert (!LOOKUP_FOUND_P (decl));\n+\t  LOOKUP_SEEN_P (decl) = true;\n+\t}\n \n-  /* Also look down into inline namespaces.  */\n-  for (value = DECL_NAMESPACE_USING (scope); value;\n-       value = TREE_CHAIN (value))\n-    if (is_associated_namespace (scope, TREE_PURPOSE (value)))\n-      if (arg_assoc_namespace (k, TREE_PURPOSE (value)))\n-\treturn true;\n+      free (scopes);\n+    }\n+  else\n+    shared_scopes = scopes;\n+}\n \n-  value = get_namespace_binding (scope, k->name);\n-  if (!value)\n-    return false;\n+void\n+name_lookup::mark_seen (tree scope)\n+{\n+  gcc_checking_assert (!seen_p (scope));\n+  LOOKUP_SEEN_P (scope) = true;\n+  vec_safe_push (scopes, scope);\n+}\n \n-  value = ovl_skip_hidden (value);\n-  \n-  for (; value; value = OVL_NEXT (value))\n+bool\n+name_lookup::find_and_mark (tree scope)\n+{\n+  bool result = LOOKUP_FOUND_P (scope);\n+  if (!result)\n     {\n-      if (add_function (k, OVL_CURRENT (value)))\n-\treturn true;\n+      LOOKUP_FOUND_P (scope) = true;\n+      if (!LOOKUP_SEEN_P (scope))\n+\tvec_safe_push (scopes, scope);\n     }\n \n-  return false;\n+  return result;\n }\n \n-/* Adds everything associated with a template argument to the lookup\n-   structure.  Returns true on error.  */\n+/* FNS is a value binding.  If it is a (set of overloaded) functions,\n+   add them into the current value.  */\n \n-static bool\n-arg_assoc_template_arg (struct arg_lookup *k, tree arg)\n+void\n+name_lookup::add_fns (tree fns)\n {\n-  /* [basic.lookup.koenig]\n+  if (!fns)\n+    return;\n+  else if (TREE_CODE (fns) == OVERLOAD)\n+    {\n+      if (TREE_TYPE (fns) != unknown_type_node)\n+\tfns = OVL_FUNCTION (fns);\n+    }\n+  else if (!DECL_DECLARES_FUNCTION_P (fns))\n+    return;\n \n-     If T is a template-id, its associated namespaces and classes are\n-     ... the namespaces and classes associated with the types of the\n-     template arguments provided for template type parameters\n-     (excluding template template parameters); the namespaces in which\n-     any template template arguments are defined; and the classes in\n-     which any member templates used as template template arguments\n-     are defined.  [Note: non-type template arguments do not\n-     contribute to the set of associated namespaces.  ]  */\n+  /* Only add those that aren't already there.  */\n+  for (ovl_iterator iter (fns); iter; ++iter)\n+    if (!fn_set->add (*iter))\n+      value = lookup_add (*iter, value);\n+}\n \n-  /* Consider first template template arguments.  */\n-  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n-      || TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE)\n-    return false;\n-  else if (TREE_CODE (arg) == TEMPLATE_DECL)\n-    {\n-      tree ctx = CP_DECL_CONTEXT (arg);\n+/* Add functions of a namespace to the lookup structure.  */\n \n-      /* It's not a member template.  */\n-      if (TREE_CODE (ctx) == NAMESPACE_DECL)\n-\treturn arg_assoc_namespace (k, ctx);\n-      /* Otherwise, it must be member template.  */\n-      else\n-\treturn arg_assoc_class_only (k, ctx);\n-    }\n-  /* It's an argument pack; handle it recursively.  */\n-  else if (ARGUMENT_PACK_P (arg))\n-    {\n-      tree args = ARGUMENT_PACK_ARGS (arg);\n-      int i, len = TREE_VEC_LENGTH (args);\n-      for (i = 0; i < len; ++i) \n-\tif (arg_assoc_template_arg (k, TREE_VEC_ELT (args, i)))\n-\t  return true;\n+void\n+name_lookup::adl_namespace_only (tree scope)\n+{\n+  mark_seen (scope);\n \n-      return false;\n-    }\n-  /* It's not a template template argument, but it is a type template\n-     argument.  */\n-  else if (TYPE_P (arg))\n-    return arg_assoc_type (k, arg);\n-  /* It's a non-type template argument.  */\n-  else\n-    return false;\n+  /* Look down into inline namespaces.  */\n+  for (tree inner = NAMESPACE_LEVEL (scope)->namespaces;\n+       inner; inner = TREE_CHAIN (inner))\n+    if (DECL_NAMESPACE_INLINE_P (inner))\n+      adl_namespace_only (inner);\n+\n+  if (cxx_binding *binding = find_namespace_binding (scope, name))\n+    add_fns (ovl_skip_hidden (binding->value));\n }\n \n-/* Adds the class and its friends to the lookup structure.\n-   Returns true on error.  */\n+/* Find the containing non-inlined namespace, add it and all its\n+   inlinees.  */\n \n-static bool\n-arg_assoc_class_only (struct arg_lookup *k, tree type)\n+void\n+name_lookup::adl_namespace (tree scope)\n {\n-  tree list, friends, context;\n+  if (seen_p (scope))\n+    return;\n+\n+  /* Find the containing non-inline namespace.  */\n+  while (DECL_NAMESPACE_INLINE_P (scope))\n+    scope = CP_DECL_CONTEXT (scope);\n+\n+  adl_namespace_only (scope);\n+}\n \n+/* Adds the class and its friends to the lookup structure.  */\n+\n+void\n+name_lookup::adl_class_only (tree type)\n+{\n   /* Backend-built structures, such as __builtin_va_list, aren't\n      affected by all this.  */\n   if (!CLASS_TYPE_P (type))\n-    return false;\n+    return;\n \n-  context = decl_namespace_context (type);\n-  if (arg_assoc_namespace (k, context))\n-    return true;\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  if (see_and_mark (type))\n+    return;\n+\n+  tree context = decl_namespace_context (type);\n+  adl_namespace (context);\n \n   complete_type (type);\n \n-  /* Process friends.  */\n-  for (list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list;\n+  /* Add friends.  */\n+  for (tree list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list;\n        list = TREE_CHAIN (list))\n-    if (k->name == FRIEND_NAME (list))\n-      for (friends = FRIEND_DECLS (list); friends;\n+    if (name == FRIEND_NAME (list))\n+      for (tree friends = FRIEND_DECLS (list); friends;\n \t   friends = TREE_CHAIN (friends))\n \t{\n \t  tree fn = TREE_VALUE (friends);\n@@ -370,40 +436,34 @@ arg_assoc_class_only (struct arg_lookup *k, tree type)\n \t     (i.e. unqualified) declarations.  */\n \t  if (CP_DECL_CONTEXT (fn) != context)\n \t    continue;\n+\n \t  /* Template specializations are never found by name lookup.\n \t     (Templates themselves can be found, but not template\n \t     specializations.)  */\n \t  if (TREE_CODE (fn) == FUNCTION_DECL && DECL_USE_TEMPLATE (fn))\n \t    continue;\n-\t  if (add_function (k, fn))\n-\t    return true;\n-\t}\n \n-  return false;\n+\t  add_fns (fn);\n+\t}\n }\n \n /* Adds the class and its bases to the lookup structure.\n    Returns true on error.  */\n \n-static bool\n-arg_assoc_bases (struct arg_lookup *k, tree type)\n+void\n+name_lookup::adl_bases (tree type)\n {\n-  if (arg_assoc_class_only (k, type))\n-    return true;\n+  adl_class_only (type);\n \n-  if (TYPE_BINFO (type))\n+  /* Process baseclasses.  */\n+  if (tree binfo = TYPE_BINFO (type))\n     {\n-      /* Process baseclasses.  */\n-      tree binfo, base_binfo;\n+      tree base_binfo;\n       int i;\n \n-      for (binfo = TYPE_BINFO (type), i = 0;\n-\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-\tif (arg_assoc_bases (k, BINFO_TYPE (base_binfo)))\n-\t  return true;\n+      for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\tadl_bases (BINFO_TYPE (base_binfo));\n     }\n-\n-  return false;\n }\n \n /* Adds everything associated with a class argument type to the lookup\n@@ -422,271 +482,268 @@ arg_assoc_bases (struct arg_lookup *k, tree type)\n    non-type template arguments do not contribute to the set of associated\n    namespaces.  --end note] */\n \n-static bool\n-arg_assoc_class (struct arg_lookup *k, tree type)\n+void\n+name_lookup::adl_class (tree type)\n {\n-  tree list;\n-  int i;\n-\n   /* Backend build structures, such as __builtin_va_list, aren't\n      affected by all this.  */\n   if (!CLASS_TYPE_P (type))\n-    return false;\n+    return;\n \n-  if (vec_member (type, k->classes))\n-    return false;\n-  vec_safe_push (k->classes, type);\n+  type = TYPE_MAIN_VARIANT (type);\n+  /* We don't set found here because we have to have set seen first,\n+     which is done in the adl_bases walk.  */\n+  if (found_p (type))\n+    return;\n \n-  if (TYPE_CLASS_SCOPE_P (type)\n-      && arg_assoc_class_only (k, TYPE_CONTEXT (type)))\n-    return true;\n+  adl_bases (type);\n+  mark_found (type);\n \n-  if (arg_assoc_bases (k, type))\n-    return true;\n+  if (TYPE_CLASS_SCOPE_P (type))\n+    adl_class_only (TYPE_CONTEXT (type));\n \n   /* Process template arguments.  */\n   if (CLASSTYPE_TEMPLATE_INFO (type)\n       && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (type)))\n     {\n-      list = INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type));\n-      for (i = 0; i < TREE_VEC_LENGTH (list); ++i)\n-\tif (arg_assoc_template_arg (k, TREE_VEC_ELT (list, i)))\n-\t  return true;\n+      tree list = INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type));\n+      for (int i = 0; i < TREE_VEC_LENGTH (list); ++i)\n+\tadl_template_arg (TREE_VEC_ELT (list, i));\n     }\n-\n-  return false;\n }\n \n-/* Adds everything associated with a given type.\n-   Returns 1 on error.  */\n+void\n+name_lookup::adl_expr (tree expr)\n+{\n+  if (!expr)\n+    return;\n \n-static bool\n-arg_assoc_type (struct arg_lookup *k, tree type)\n+  gcc_assert (!TYPE_P (expr));\n+\n+  if (TREE_TYPE (expr) != unknown_type_node)\n+    {\n+      adl_type (TREE_TYPE (expr));\n+      return;\n+    }\n+\n+  if (TREE_CODE (expr) == ADDR_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+  if (TREE_CODE (expr) == COMPONENT_REF\n+      || TREE_CODE (expr) == OFFSET_REF)\n+    expr = TREE_OPERAND (expr, 1);\n+  expr = MAYBE_BASELINK_FUNCTIONS (expr);\n+\n+  if (OVL_P (expr))\n+    for (lkp_iterator iter (expr); iter; ++iter)\n+      adl_type (TREE_TYPE (*iter));\n+  else if (TREE_CODE (expr) == TEMPLATE_ID_EXPR)\n+    {\n+      /* The working paper doesn't currently say how to handle\n+\t template-id arguments.  The sensible thing would seem to be\n+\t to handle the list of template candidates like a normal\n+\t overload set, and handle the template arguments like we do\n+\t for class template specializations.  */\n+\n+      /* First the templates.  */\n+      adl_expr (TREE_OPERAND (expr, 0));\n+\n+      /* Now the arguments.  */\n+      if (tree args = TREE_OPERAND (expr, 1))\n+\tfor (int ix = TREE_VEC_LENGTH (args); ix--;)\n+\t  adl_template_arg (TREE_VEC_ELT (args, ix));\n+    }\n+}\n+\n+void\n+name_lookup::adl_type (tree type)\n {\n-  /* As we do not get the type of non-type dependent expressions\n-     right, we can end up with such things without a type.  */\n   if (!type)\n-    return false;\n+    return;\n \n   if (TYPE_PTRDATAMEM_P (type))\n     {\n       /* Pointer to member: associate class type and value type.  */\n-      if (arg_assoc_type (k, TYPE_PTRMEM_CLASS_TYPE (type)))\n-\treturn true;\n-      return arg_assoc_type (k, TYPE_PTRMEM_POINTED_TO_TYPE (type));\n+      adl_type (TYPE_PTRMEM_CLASS_TYPE (type));\n+      adl_type (TYPE_PTRMEM_POINTED_TO_TYPE (type));\n+      return;\n     }\n-  else switch (TREE_CODE (type))\n+\n+  switch (TREE_CODE (type))\n     {\n-    case ERROR_MARK:\n-      return false;\n-    case VOID_TYPE:\n-    case INTEGER_TYPE:\n-    case REAL_TYPE:\n-    case COMPLEX_TYPE:\n-    case VECTOR_TYPE:\n-    case BOOLEAN_TYPE:\n-    case FIXED_POINT_TYPE:\n-    case DECLTYPE_TYPE:\n-    case NULLPTR_TYPE:\n-      return false;\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (type))\n-\treturn arg_assoc_type (k, TYPE_PTRMEMFUNC_FN_TYPE (type));\n+\t{\n+\t  adl_type (TYPE_PTRMEMFUNC_FN_TYPE (type));\n+\t  return;\n+\t}\n       /* FALLTHRU */\n     case UNION_TYPE:\n-      return arg_assoc_class (k, type);\n-    case POINTER_TYPE:\n-    case REFERENCE_TYPE:\n-    case ARRAY_TYPE:\n-      return arg_assoc_type (k, TREE_TYPE (type));\n-    case ENUMERAL_TYPE:\n-      if (TYPE_CLASS_SCOPE_P (type)\n-\t  && arg_assoc_class_only (k, TYPE_CONTEXT (type)))\n-\treturn true;\n-      return arg_assoc_namespace (k, decl_namespace_context (type));\n+      adl_class (type);\n+      return;\n+\n     case METHOD_TYPE:\n       /* The basetype is referenced in the first arg type, so just\n \t fall through.  */\n     case FUNCTION_TYPE:\n       /* Associate the parameter types.  */\n-      if (arg_assoc_args (k, TYPE_ARG_TYPES (type)))\n-\treturn true;\n-      /* Associate the return type.  */\n-      return arg_assoc_type (k, TREE_TYPE (type));\n-    case TEMPLATE_TYPE_PARM:\n-    case BOUND_TEMPLATE_TEMPLATE_PARM:\n-      return false;\n-    case TYPENAME_TYPE:\n-      return false;\n+      for (tree args = TYPE_ARG_TYPES (type); args; args = TREE_CHAIN (args))\n+\tadl_type (TREE_VALUE (args));\n+      /* FALLTHROUGH */\n+\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+    case ARRAY_TYPE:\n+      adl_type (TREE_TYPE (type));\n+      return;\n+\n+    case ENUMERAL_TYPE:\n+      if (TYPE_CLASS_SCOPE_P (type))\n+\tadl_class_only (TYPE_CONTEXT (type));\n+      adl_namespace (decl_namespace_context (type));\n+      return;\n+\n     case LANG_TYPE:\n       gcc_assert (type == unknown_type_node\n \t\t  || type == init_list_type_node);\n-      return false;\n+      return;\n+\n     case TYPE_PACK_EXPANSION:\n-      return arg_assoc_type (k, PACK_EXPANSION_PATTERN (type));\n+      adl_type (PACK_EXPANSION_PATTERN (type));\n+      return;\n \n     default:\n-      gcc_unreachable ();\n+      break;\n     }\n-  return false;\n-}\n-\n-/* Adds everything associated with arguments.  Returns true on error.  */\n-\n-static bool\n-arg_assoc_args (struct arg_lookup *k, tree args)\n-{\n-  for (; args; args = TREE_CHAIN (args))\n-    if (arg_assoc (k, TREE_VALUE (args)))\n-      return true;\n-  return false;\n }\n \n-/* Adds everything associated with an argument vector.  Returns true\n-   on error.  */\n-\n-static bool\n-arg_assoc_args_vec (struct arg_lookup *k, vec<tree, va_gc> *args)\n-{\n-  unsigned int ix;\n-  tree arg;\n-\n-  FOR_EACH_VEC_SAFE_ELT (args, ix, arg)\n-    if (arg_assoc (k, arg))\n-      return true;\n-  return false;\n-}\n-\n-/* Adds everything associated with a given tree_node.  Returns 1 on error.  */\n+/* Adds everything associated with a template argument to the lookup\n+   structure.  */\n \n-static bool\n-arg_assoc (struct arg_lookup *k, tree n)\n+void\n+name_lookup::adl_template_arg (tree arg)\n {\n-  if (n == error_mark_node)\n-    return false;\n+  /* [basic.lookup.koenig]\n \n-  if (TYPE_P (n))\n-    return arg_assoc_type (k, n);\n-\n-  if (! type_unknown_p (n))\n-    return arg_assoc_type (k, TREE_TYPE (n));\n-\n-  if (TREE_CODE (n) == ADDR_EXPR)\n-    n = TREE_OPERAND (n, 0);\n-  if (TREE_CODE (n) == COMPONENT_REF)\n-    n = TREE_OPERAND (n, 1);\n-  if (TREE_CODE (n) == OFFSET_REF)\n-    n = TREE_OPERAND (n, 1);\n-  while (TREE_CODE (n) == TREE_LIST)\n-    n = TREE_VALUE (n);\n-  if (BASELINK_P (n))\n-    n = BASELINK_FUNCTIONS (n);\n-\n-  if (TREE_CODE (n) == FUNCTION_DECL)\n-    return arg_assoc_type (k, TREE_TYPE (n));\n-  if (TREE_CODE (n) == TEMPLATE_ID_EXPR)\n-    {\n-      /* The working paper doesn't currently say how to handle template-id\n-\t arguments.  The sensible thing would seem to be to handle the list\n-\t of template candidates like a normal overload set, and handle the\n-\t template arguments like we do for class template\n-\t specializations.  */\n-      tree templ = TREE_OPERAND (n, 0);\n-      tree args = TREE_OPERAND (n, 1);\n-      int ix;\n+     If T is a template-id, its associated namespaces and classes are\n+     ... the namespaces and classes associated with the types of the\n+     template arguments provided for template type parameters\n+     (excluding template template parameters); the namespaces in which\n+     any template template arguments are defined; and the classes in\n+     which any member templates used as template template arguments\n+     are defined.  [Note: non-type template arguments do not\n+     contribute to the set of associated namespaces.  ]  */\n \n-      /* First the templates.  */\n-      if (arg_assoc (k, templ))\n-\treturn true;\n+  /* Consider first template template arguments.  */\n+  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n+      || TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE)\n+    ;\n+  else if (TREE_CODE (arg) == TEMPLATE_DECL)\n+    {\n+      tree ctx = CP_DECL_CONTEXT (arg);\n \n-      /* Now the arguments.  */\n-      if (args)\n-\tfor (ix = TREE_VEC_LENGTH (args); ix--;)\n-\t  if (arg_assoc_template_arg (k, TREE_VEC_ELT (args, ix)) == 1)\n-\t    return true;\n+      /* It's not a member template.  */\n+      if (TREE_CODE (ctx) == NAMESPACE_DECL)\n+\tadl_namespace (ctx);\n+      /* Otherwise, it must be member template.  */\n+      else\n+\tadl_class_only (ctx);\n     }\n-  else if (TREE_CODE (n) == OVERLOAD)\n+  /* It's an argument pack; handle it recursively.  */\n+  else if (ARGUMENT_PACK_P (arg))\n     {\n-      for (; n; n = OVL_NEXT (n))\n-\tif (arg_assoc_type (k, TREE_TYPE (OVL_CURRENT (n))))\n-\t  return true;\n+      tree args = ARGUMENT_PACK_ARGS (arg);\n+      int i, len = TREE_VEC_LENGTH (args);\n+      for (i = 0; i < len; ++i) \n+\tadl_template_arg (TREE_VEC_ELT (args, i));\n     }\n-\n-  return false;\n+  /* It's not a template template argument, but it is a type template\n+     argument.  */\n+  else if (TYPE_P (arg))\n+    adl_type (arg);\n }\n \n-/* Performs Koenig lookup depending on arguments, where fns\n-   are the functions found in normal lookup.  */\n+/* Perform ADL lookup.  FNS is the existing lookup result and ARGS are\n+   the call arguments.  */\n \n-static cp_expr\n-lookup_arg_dependent_1 (tree name, tree fns, vec<tree, va_gc> *args)\n+tree\n+name_lookup::search_adl (tree fns, vec<tree, va_gc> *args)\n {\n-  struct arg_lookup k;\n+  value = fns;\n \n-  /* Remove any hidden friend functions from the list of functions\n-     found so far.  They will be added back by arg_assoc_class as\n-     appropriate.  */\n-  fns = ovl_skip_hidden (fns);\n+  /* Add the current overload set into the hash table.  */\n+  fn_set = new hash_set<tree>;\n+  for (lkp_iterator iter (fns); iter; ++iter)\n+    fn_set->add (*iter);\n \n-  k.name = name;\n-  k.args = args;\n-  k.functions = fns;\n-  k.classes = make_tree_vector ();\n-\n-  /* We previously performed an optimization here by setting\n-     NAMESPACES to the current namespace when it was safe. However, DR\n-     164 says that namespaces that were already searched in the first\n-     stage of template processing are searched again (potentially\n-     picking up later definitions) in the second stage. */\n-  k.namespaces = make_tree_vector ();\n+  unsigned ix;\n+  tree arg;\n \n-  /* We used to allow duplicates and let joust discard them, but\n-     since the above change for DR 164 we end up with duplicates of\n-     all the functions found by unqualified lookup.  So keep track\n-     of which ones we've seen.  */\n-  if (fns)\n-    {\n-      tree ovl;\n-      /* We shouldn't be here if lookup found something other than\n-\t namespace-scope functions.  */\n-      gcc_assert (DECL_NAMESPACE_SCOPE_P (OVL_CURRENT (fns)));\n-      k.fn_set = new hash_set<tree>;\n-      for (ovl = fns; ovl; ovl = OVL_NEXT (ovl))\n-\tk.fn_set->add (OVL_CURRENT (ovl));\n-    }\n-  else\n-    k.fn_set = NULL;\n+  FOR_EACH_VEC_ELT_REVERSE (*args, ix, arg)\n+    /* OMP reduction operators put a type as the first arg.  I don't\n+       suppose we should ADL on that?  */\n+    if (!TYPE_P (arg))\n+      adl_expr (arg);\n \n-  arg_assoc_args_vec (&k, args);\n+  delete fn_set;\n+  fn_set = NULL;\n \n-  fns = k.functions;\n-  \n-  if (fns\n-      && !VAR_P (fns)\n-      && !is_overloaded_fn (fns))\n-    {\n-      error (\"argument dependent lookup finds %q+D\", fns);\n-      error (\"  in call to %qD\", name);\n-      fns = error_mark_node;\n-    }\n+  fns = value;\n \n-  release_tree_vector (k.classes);\n-  release_tree_vector (k.namespaces);\n-  delete k.fn_set;\n-    \n   return fns;\n }\n \n-/* Wrapper for lookup_arg_dependent_1.  */\n+/* ADL lookup of NAME.  FNS is the result of regular lookup, and we\n+   don't add duplicates to it.  ARGS is the vector of call\n+   arguments (which will not be empty).  */\n \n-cp_expr\n+tree\n lookup_arg_dependent (tree name, tree fns, vec<tree, va_gc> *args)\n {\n-  cp_expr ret;\n-  bool subtime;\n-  subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = lookup_arg_dependent_1 (name, fns, args);\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  name_lookup lookup (name);\n+  fns = lookup.search_adl (fns, args);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return fns;\n+}\n+\n+/* Returns true iff CURRENT has declared itself to be an associated\n+   namespace of SCOPE via a strong using-directive (or transitive chain\n+   thereof).  Both are namespaces.  */\n+\n+bool\n+is_associated_namespace (tree current, tree scope)\n+{\n+  vec<tree, va_gc> *seen = make_tree_vector ();\n+  vec<tree, va_gc> *todo = make_tree_vector ();\n+  tree t;\n+  bool ret;\n+\n+  while (1)\n+    {\n+      if (scope == current)\n+\t{\n+\t  ret = true;\n+\t  break;\n+\t}\n+      vec_safe_push (seen, scope);\n+      for (t = DECL_NAMESPACE_ASSOCIATIONS (scope); t; t = TREE_CHAIN (t))\n+\tif (!vec_member (TREE_PURPOSE (t), seen))\n+\t  vec_safe_push (todo, TREE_PURPOSE (t));\n+      if (!todo->is_empty ())\n+\t{\n+\t  scope = todo->last ();\n+\t  todo->pop ();\n+\t}\n+      else\n+\t{\n+\t  ret = false;\n+\t  break;\n+\t}\n+    }\n+\n+  release_tree_vector (seen);\n+  release_tree_vector (todo);\n+\n   return ret;\n }\n "}, {"sha": "a2454bbcf45d52a886dd1a76817ae3154531531f", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=f35a733d3718e953065fa366bfcef1d95dfb2a10", "patch": "@@ -324,7 +324,7 @@ extern void pop_decl_namespace (void);\n extern void do_namespace_alias (tree, tree);\n extern tree do_class_using_decl (tree, tree);\n extern void do_using_directive (tree);\n-extern cp_expr lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n+extern tree lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n extern bool is_associated_namespace (tree, tree);\n extern tree innermost_non_namespace_value (tree);\n extern cxx_binding *outer_binding (tree, cxx_binding *, bool);"}, {"sha": "a0f81818395c12828069b8974864e36ff0018705", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f35a733d3718e953065fa366bfcef1d95dfb2a10", "patch": "@@ -1,3 +1,7 @@\n+2017-05-25  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/lookup/koenig14.C: New.\n+\n 2017-05-25  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/79583"}, {"sha": "d901591053ee35657c88139d6f91c0e67a373b08", "filename": "gcc/testsuite/g++.dg/lookup/koenig14.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35a733d3718e953065fa366bfcef1d95dfb2a10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig14.C?ref=f35a733d3718e953065fa366bfcef1d95dfb2a10", "patch": "@@ -0,0 +1,30 @@\n+// ADL can be recursive (via instantiation), make sure that works.\n+\n+namespace X\n+{\n+  class B {};\n+  \n+  void frob ();\n+  int frob (B); // Inner ADL resolves here\n+}\n+\n+void frob (int);\n+void frob (float);\n+\n+namespace Y\n+{\n+  struct A {};\n+  void frob (void*, void *, void *); // Outer ADL resolves here\n+}\n+\n+template <typename T, typename U>\n+struct C : U\n+{\n+  int ary[sizeof frob(T())]; // ADL occurs here during instantiation\n+};\n+\n+void Foo (C<X::B, Y::A> *p, X::B *q)\n+{\n+  frob(q, p, q); // ADL causes instantation of C<...>\n+  // We will have already searched X by the time the instantation happens\n+}"}]}