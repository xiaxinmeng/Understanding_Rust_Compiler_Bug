{"sha": "2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRiZTU2YmRmYmY2YzU3MGNmMjMwNzNmMGM1OTZkYTZiZDE1MzFjOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2016-09-22T13:58:49Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2016-09-22T13:58:49Z"}, "message": "Implement C++17 node extraction and insertion (P0083R5)\n\n\t* doc/xml/manual/status_cxx2017.xml: Document status.\n\t* doc/html/*: Regenerate.\n\t* include/Makefile.am: Add bits/node_handle.h and reorder.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/hashtable.h (_Hashtable::node_type)\n\t(_Hashtable::insert_return_type, _Hashtable::_M_reinsert_node)\n\t(_Hashtable::_M_reinsert_node_multi, _Hashtable::extract)\n\t(_Hashtable::_M_merge_unique, _Hashtable::_M_merge_multi): Define.\n\t(_Hash_merge_helper): Define primary template.\n\t* include/bits/node_handle.h: New header.\n\t* include/bits/stl_map.h (map): Declare _Rb_tree_merge_helper as\n\tfriend.\n\t(map::node_type, map::insert_return_type, map::extract, map::merge)\n\t(map::insert(node_type&&), map::insert(const_iterator, node_type&&)):\n\tDefine new members.\n\t(_Rb_tree_merge_helper): Specialize for map.\n\t* include/bits/stl_multimap.h (multimap): Declare _Rb_tree_merge_helper\n\tas friend.\n\t(multimap::node_type, multimap::extract, multimap::merge)\n\t(multimap::insert(node_type&&))\n\t(multimap::insert(const_iterator, node_type&&)): Define.\n\t(_Rb_tree_merge_helper): Specialize for multimap.\n\t* include/bits/stl_multiset.h (multiset): Declare _Rb_tree_merge_helper\n\tas friend.\n\t(multiset::node_type, multiset::extract, multiset::merge)\n\t(multiset::insert(node_type&&))\n\t(multiset::insert(const_iterator, node_type&&)): Define.\n\t* include/bits/stl_set.h (set): Declare _Rb_tree_merge_helper as\n\tfriend.\n\t(set::node_type, set::insert_return_type, set::extract, set::merge)\n\t(set::insert(node_type&&), set::insert(const_iterator, node_type&&)):\n\tDefine.\n\t(_Rb_tree_merge_helper): Specialize for set.\n\t* include/bits/stl_tree.h (_Rb_tree): Declare _Rb_tree<> as friend.\n\t(_Rb_tree::node_type, _Rb_tree::insert_return_type)\n\t(_Rb_tree::_M_reinsert_node_unique, _Rb_tree::_M_reinsert_node_equal)\n\t(_Rb_tree::_M_reinsert_node_hint_unique)\n\t(_Rb_tree::_M_reinsert_node_hint_equal, _Rb_tree::extract)\n\t(_Rb_tree::_M_merge_unique, _Rb_tree::_M_merge_equal): Define.\n\t(_Rb_tree_merge_helper): Specialize for multiset.\n\t* include/bits/unordered_map.h (unordered_map): Declare\n\tunordered_map<> and unordered_multimap<> as friends.\n\t(unordered_map::node_type, unordered_map::insert_return_type)\n\t(unordered_map::extract, unordered_map::merge)\n\t(unordered_map::insert(node_type&&))\n\t(unordered_map::insert(const_iterator, node_type&&))\n\t(unordered_multimap): Declare _Hash_merge_helper as friend.\n\t(unordered_multimap::node_type, unordered_multimap::extract)\n\t(unordered_multimap::merge, unordered_multimap::insert(node_type&&))\n\t(unordered_multimap::insert(const_iterator, node_type&&)): Define.\n\t(_Hash_merge_helper): Specialize for unordered maps and multimaps.\n\t* include/bits/unordered_set.h (unordered_set, unordered_multiset):\n\tDeclare _Hash_merge_helper as friend.\n\t(unordered_set::node_type, unordered_set::insert_return_type)\n\t(unordered_set::extract, unordered_set::merge)\n\t(unordered_set::insert(node_type&&))\n\t(unordered_set::insert(const_iterator, node_type&&)): Define.\n\t(unordered_multiset::node_type, unordered_multiset::extract)\n\t(unordered_multiset::merge, unordered_multiset::insert(node_type&&))\n\t(unordered_multiset::insert(const_iterator, node_type&&)): Define.\n\t(_Hash_merge_helper): Specialize for unordered sets and multisets.\n\t* include/debug/map.h (map): Add using declarations or forwarding\n\tfunctions for new members.\n\t* include/debug/map.h (multimap): Likewise.\n\t* include/debug/map.h (multiset): Likewise.\n\t* include/debug/map.h (set): Likewise.\n\t* include/debug/unordered_map (unordered_map, unordered_multimap):\n\tLikewise.\n\t* include/debug/unordered_set( unordered_set, unordered_multiset):\n\tLikewise.\n\t* python/libstdcxx/v6/printers.py (get_value_from_aligned_membuf): New\n\thelper function.\n\t(get_value_from_list_node, get_value_from_Rb_tree_node): Use helper.\n\t(StdNodeHandlePrinter): Define printer for node handles.\n\t(build_libstdcxx_dictionary): Register StdNodeHandlePrinter.\n\t* testsuite/23_containers/map/modifiers/extract.cc: New.\n\t* testsuite/23_containers/map/modifiers/merge.cc: New.\n\t* testsuite/23_containers/multimap/modifiers/extract.cc: New.\n\t* testsuite/23_containers/multimap/modifiers/merge.cc: New.\n\t* testsuite/23_containers/multiset/modifiers/extract.cc: New.\n\t* testsuite/23_containers/multiset/modifiers/merge.cc: New.\n\t* testsuite/23_containers/set/modifiers/extract.cc: New.\n\t* testsuite/23_containers/set/modifiers/merge.cc: New.\n\t* testsuite/23_containers/unordered_map/modifiers/extract.cc: New.\n\t* testsuite/23_containers/unordered_map/modifiers/merge.cc: New.\n\t* testsuite/23_containers/unordered_multimap/modifiers/extract.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_multimap/modifiers/merge.cc: New.\n\t* testsuite/23_containers/unordered_multiset/modifiers/extract.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_multiset/modifiers/merge.cc: New.\n\t* testsuite/23_containers/unordered_set/modifiers/extract.cc: New.\n\t* testsuite/23_containers/unordered_set/modifiers/merge.cc: New.\n\t* testsuite/23_containers/unordered_set/instantiation_neg.cc: Adjust\n\tdg-error lineno.\n\t* testsuite/libstdc++-prettyprinters/cxx17.cc: Test node handles.\n\nFrom-SVN: r240363", "tree": {"sha": "fdd84b89ea80dae4b238001d73f5a4a72fc86913", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdd84b89ea80dae4b238001d73f5a4a72fc86913"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "475edec07057725e0ace3868590ce7dbcef1f822", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/475edec07057725e0ace3868590ce7dbcef1f822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/475edec07057725e0ace3868590ce7dbcef1f822"}], "stats": {"total": 4041, "additions": 4019, "deletions": 22}, "files": [{"sha": "9376bfbdf2f8ede27803b5d11a2c97be35240f07", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -1,3 +1,103 @@\n+2016-09-22  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tImplement C++17 node extraction and insertion (P0083R5)\n+\t* doc/xml/manual/status_cxx2017.xml: Document status.\n+\t* doc/html/*: Regenerate.\n+\t* include/Makefile.am: Add bits/node_handle.h and reorder.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/hashtable.h (_Hashtable::node_type)\n+\t(_Hashtable::insert_return_type, _Hashtable::_M_reinsert_node)\n+\t(_Hashtable::_M_reinsert_node_multi, _Hashtable::extract)\n+\t(_Hashtable::_M_merge_unique, _Hashtable::_M_merge_multi): Define.\n+\t(_Hash_merge_helper): Define primary template.\n+\t* include/bits/node_handle.h: New header.\n+\t* include/bits/stl_map.h (map): Declare _Rb_tree_merge_helper as\n+\tfriend.\n+\t(map::node_type, map::insert_return_type, map::extract, map::merge)\n+\t(map::insert(node_type&&), map::insert(const_iterator, node_type&&)):\n+\tDefine new members.\n+\t(_Rb_tree_merge_helper): Specialize for map.\n+\t* include/bits/stl_multimap.h (multimap): Declare _Rb_tree_merge_helper\n+\tas friend.\n+\t(multimap::node_type, multimap::extract, multimap::merge)\n+\t(multimap::insert(node_type&&))\n+\t(multimap::insert(const_iterator, node_type&&)): Define.\n+\t(_Rb_tree_merge_helper): Specialize for multimap.\n+\t* include/bits/stl_multiset.h (multiset): Declare _Rb_tree_merge_helper\n+\tas friend.\n+\t(multiset::node_type, multiset::extract, multiset::merge)\n+\t(multiset::insert(node_type&&))\n+\t(multiset::insert(const_iterator, node_type&&)): Define.\n+\t* include/bits/stl_set.h (set): Declare _Rb_tree_merge_helper as\n+\tfriend.\n+\t(set::node_type, set::insert_return_type, set::extract, set::merge)\n+\t(set::insert(node_type&&), set::insert(const_iterator, node_type&&)):\n+\tDefine.\n+\t(_Rb_tree_merge_helper): Specialize for set.\n+\t* include/bits/stl_tree.h (_Rb_tree): Declare _Rb_tree<> as friend.\n+\t(_Rb_tree::node_type, _Rb_tree::insert_return_type)\n+\t(_Rb_tree::_M_reinsert_node_unique, _Rb_tree::_M_reinsert_node_equal)\n+\t(_Rb_tree::_M_reinsert_node_hint_unique)\n+\t(_Rb_tree::_M_reinsert_node_hint_equal, _Rb_tree::extract)\n+\t(_Rb_tree::_M_merge_unique, _Rb_tree::_M_merge_equal): Define.\n+\t(_Rb_tree_merge_helper): Specialize for multiset.\n+\t* include/bits/unordered_map.h (unordered_map): Declare\n+\tunordered_map<> and unordered_multimap<> as friends.\n+\t(unordered_map::node_type, unordered_map::insert_return_type)\n+\t(unordered_map::extract, unordered_map::merge)\n+\t(unordered_map::insert(node_type&&))\n+\t(unordered_map::insert(const_iterator, node_type&&))\n+\t(unordered_multimap): Declare _Hash_merge_helper as friend.\n+\t(unordered_multimap::node_type, unordered_multimap::extract)\n+\t(unordered_multimap::merge, unordered_multimap::insert(node_type&&))\n+\t(unordered_multimap::insert(const_iterator, node_type&&)): Define.\n+\t(_Hash_merge_helper): Specialize for unordered maps and multimaps.\n+\t* include/bits/unordered_set.h (unordered_set, unordered_multiset):\n+\tDeclare _Hash_merge_helper as friend.\n+\t(unordered_set::node_type, unordered_set::insert_return_type)\n+\t(unordered_set::extract, unordered_set::merge)\n+\t(unordered_set::insert(node_type&&))\n+\t(unordered_set::insert(const_iterator, node_type&&)): Define.\n+\t(unordered_multiset::node_type, unordered_multiset::extract)\n+\t(unordered_multiset::merge, unordered_multiset::insert(node_type&&))\n+\t(unordered_multiset::insert(const_iterator, node_type&&)): Define.\n+\t(_Hash_merge_helper): Specialize for unordered sets and multisets.\n+\t* include/debug/map.h (map): Add using declarations or forwarding\n+\tfunctions for new members.\n+\t* include/debug/map.h (multimap): Likewise.\n+\t* include/debug/map.h (multiset): Likewise.\n+\t* include/debug/map.h (set): Likewise.\n+\t* include/debug/unordered_map (unordered_map, unordered_multimap):\n+\tLikewise.\n+\t* include/debug/unordered_set( unordered_set, unordered_multiset):\n+\tLikewise.\n+\t* python/libstdcxx/v6/printers.py (get_value_from_aligned_membuf): New\n+\thelper function.\n+\t(get_value_from_list_node, get_value_from_Rb_tree_node): Use helper.\n+\t(StdNodeHandlePrinter): Define printer for node handles.\n+\t(build_libstdcxx_dictionary): Register StdNodeHandlePrinter.\n+\t* testsuite/23_containers/map/modifiers/extract.cc: New.\n+\t* testsuite/23_containers/map/modifiers/merge.cc: New.\n+\t* testsuite/23_containers/multimap/modifiers/extract.cc: New.\n+\t* testsuite/23_containers/multimap/modifiers/merge.cc: New.\n+\t* testsuite/23_containers/multiset/modifiers/extract.cc: New.\n+\t* testsuite/23_containers/multiset/modifiers/merge.cc: New.\n+\t* testsuite/23_containers/set/modifiers/extract.cc: New.\n+\t* testsuite/23_containers/set/modifiers/merge.cc: New.\n+\t* testsuite/23_containers/unordered_map/modifiers/extract.cc: New.\n+\t* testsuite/23_containers/unordered_map/modifiers/merge.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/modifiers/extract.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_multimap/modifiers/merge.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/modifiers/extract.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_multiset/modifiers/merge.cc: New.\n+\t* testsuite/23_containers/unordered_set/modifiers/extract.cc: New.\n+\t* testsuite/23_containers/unordered_set/modifiers/merge.cc: New.\n+\t* testsuite/23_containers/unordered_set/instantiation_neg.cc: Adjust\n+\tdg-error lineno.\n+\t* testsuite/libstdc++-prettyprinters/cxx17.cc: Test node handles.\n+\n 2016-09-22  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tFix tests on old arm platforms for optional."}, {"sha": "db96f989b2491a036fe21a25263f81d52eaa7b00", "filename": "libstdc++-v3/doc/html/manual/profile_mode_devel.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fprofile_mode_devel.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fprofile_mode_devel.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fprofile_mode_devel.html?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -64,4 +64,4 @@\n    <code class=\"code\">include/profile/impl/profiler_trace.h</code>.  Use\n    <code class=\"code\">__trace_vector_to_list</code> as an example.\n   </p><p>Add documentation in file <code class=\"code\">doc/xml/manual/profile_mode.xml</code>.\n-  </p></div></div><div class=\"navfooter\"><hr /><table width=\"100%\" summary=\"Navigation footer\"><tr><td width=\"40%\" align=\"left\"><a accesskey=\"p\" href=\"profile_mode_impl.html\">Prev</a>\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"u\" href=\"profile_mode.html\">Up</a></td><td width=\"40%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"profile_mode_diagnostics.html\">Next</a></td></tr><tr><td width=\"40%\" align=\"left\" valign=\"top\">Implementation Issues\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"h\" href=\"../index.html\">Home</a></td><td width=\"40%\" align=\"right\" valign=\"top\">\u00a0Diagnostics</td></tr></table></div></body></html>\n+  </p></div></div><div class=\"navfooter\"><hr /><table width=\"100%\" summary=\"Navigation footer\"><tr><td width=\"40%\" align=\"left\"><a accesskey=\"p\" href=\"profile_mode_impl.html\">Prev</a>\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"u\" href=\"profile_mode.html\">Up</a></td><td width=\"40%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"profile_mode_diagnostics.html\">Next</a></td></tr><tr><td width=\"40%\" align=\"left\" valign=\"top\">Implementation Issues\u00a0</td><td width=\"20%\" align=\"center\"><a accesskey=\"h\" href=\"../index.html\">Home</a></td><td width=\"40%\" align=\"right\" valign=\"top\">\u00a0Diagnostics</td></tr></table></div></body></html>\n\\ No newline at end of file"}, {"sha": "3c589791b5026adf744363b6a52cc6f6cc8a372d", "filename": "libstdc++-v3/doc/html/manual/status.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fstatus.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fstatus.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fstatus.html?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -666,11 +666,11 @@\n \t</a>\n       </td><td align=\"center\"> 6.1 </td><td align=\"left\"><code class=\"code\"> __cpp_lib_map_try_emplace &gt;= 201411</code>,\n \t     <code class=\"code\"> __cpp_lib_unordered_map_try_emplace &gt;= 201411</code>\n-      </td></tr><tr bgcolor=\"#C8B0B0\"><td align=\"left\"> Splicing Maps and Sets </td><td align=\"left\">\n+      </td></tr><tr><td align=\"left\"> Splicing Maps and Sets </td><td align=\"left\">\n \t<a class=\"link\" href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf\" target=\"_top\">\n \tP0083R3\n \t</a>\n-      </td><td align=\"center\"> No </td><td align=\"left\"><code class=\"code\"> __cpp_lib_node_extract &gt;= 201606 </code></td></tr><tr><td align=\"left\">Non-member <code class=\"code\">size()</code> and more</td><td align=\"left\">\n+      </td><td align=\"center\"> 7 </td><td align=\"left\"><code class=\"code\"> __cpp_lib_node_extract &gt;= 201606 </code></td></tr><tr><td align=\"left\">Non-member <code class=\"code\">size()</code> and more</td><td align=\"left\">\n \t<a class=\"link\" href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4280.pdf\" target=\"_top\">\n \t  N4280\n \t</a>"}, {"sha": "76eaaa0fa2299918843bd35d444fe30869a1723f", "filename": "libstdc++-v3/doc/xml/manual/status_cxx2017.xml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2017.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2017.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2017.xml?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -562,14 +562,13 @@ Feature-testing recommendations for C++</link>.\n     </row>\n \n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n       <entry> Splicing Maps and Sets </entry>\n       <entry>\n \t<link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf\">\n \tP0083R3\n \t</link>\n       </entry>\n-      <entry align=\"center\"> No </entry>\n+      <entry align=\"center\"> 7 </entry>\n       <entry><code> __cpp_lib_node_extract >= 201606 </code></entry>\n     </row>\n "}, {"sha": "778225899c3948cefaf9c75caf842a79c31f9166", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -129,7 +129,7 @@ bits_headers = \\\n \t${bits_srcdir}/specfun.h \\\n \t${bits_srcdir}/memoryfwd.h \\\n \t${bits_srcdir}/move.h \\\n-\t${bits_srcdir}/std_mutex.h \\\n+\t${bits_srcdir}/node_handle.h \\\n \t${bits_srcdir}/ostream.tcc \\\n \t${bits_srcdir}/ostream_insert.h \\\n \t${bits_srcdir}/parse_numbers.h \\\n@@ -159,6 +159,7 @@ bits_headers = \\\n \t${bits_srcdir}/shared_ptr_base.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\\n+\t${bits_srcdir}/std_mutex.h \\\n \t${bits_srcdir}/stl_algo.h \\\n \t${bits_srcdir}/stl_algobase.h \\\n \t${bits_srcdir}/stl_bvector.h \\"}, {"sha": "502a89e1fb0963010edabdeddc4dc0f4501ecc9f", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -419,7 +419,7 @@ bits_headers = \\\n \t${bits_srcdir}/specfun.h \\\n \t${bits_srcdir}/memoryfwd.h \\\n \t${bits_srcdir}/move.h \\\n-\t${bits_srcdir}/std_mutex.h \\\n+\t${bits_srcdir}/node_handle.h \\\n \t${bits_srcdir}/ostream.tcc \\\n \t${bits_srcdir}/ostream_insert.h \\\n \t${bits_srcdir}/parse_numbers.h \\\n@@ -449,6 +449,7 @@ bits_headers = \\\n \t${bits_srcdir}/shared_ptr_base.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\\n+\t${bits_srcdir}/std_mutex.h \\\n \t${bits_srcdir}/stl_algo.h \\\n \t${bits_srcdir}/stl_algobase.h \\\n \t${bits_srcdir}/stl_bvector.h \\"}, {"sha": "be67741ab5a5c9ef61e129c875f202d6ef0d3bf1", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -33,6 +33,9 @@\n #pragma GCC system_header\n \n #include <bits/hashtable_policy.h>\n+#if __cplusplus > 201402L\n+# include <bits/node_handle.h>\n+#endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -308,6 +311,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using const_local_iterator = typename __hashtable_base::\n \t\t\t\t   const_local_iterator;\n \n+#if __cplusplus > 201402L\n+      using node_type = _Node_handle<_Key, _Value, __node_alloc_type>;\n+      using insert_return_type = _Node_insert_return<iterator, node_type>;\n+#endif\n+\n     private:\n       __bucket_type*\t\t_M_buckets\t\t= &_M_single_bucket;\n       size_type\t\t\t_M_bucket_count\t\t= 1;\n@@ -762,6 +770,135 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // DR 1189.\n       // reserve, if present, comes from _Rehash_base.\n \n+#if __cplusplus > 201402L\n+      /// Re-insert an extracted node into a container with unique keys.\n+      insert_return_type\n+      _M_reinsert_node(node_type&& __nh)\n+      {\n+\tinsert_return_type __ret;\n+\tif (__nh.empty())\n+\t  __ret.position = end();\n+\telse\n+\t  {\n+\t    __glibcxx_assert(get_allocator() == __nh.get_allocator());\n+\n+\t    const key_type& __k = __nh._M_key();\n+\t    __hash_code __code = this->_M_hash_code(__k);\n+\t    size_type __bkt = _M_bucket_index(__k, __code);\n+\t    if (__node_type* __n = _M_find_node(__bkt, __k, __code))\n+\t      {\n+\t\t__ret.node = std::move(__nh);\n+\t\t__ret.position = iterator(__n);\n+\t\t__ret.inserted = false;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.position\n+\t\t  = _M_insert_unique_node(__bkt, __code, __nh._M_ptr);\n+\t\t__nh._M_ptr = nullptr;\n+\t\t__ret.inserted = true;\n+\t      }\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      /// Re-insert an extracted node into a container with equivalent keys.\n+      iterator\n+      _M_reinsert_node_multi(const_iterator __hint, node_type&& __nh)\n+      {\n+\titerator __ret;\n+\tif (__nh.empty())\n+\t  __ret = end();\n+\telse\n+\t  {\n+\t    __glibcxx_assert(get_allocator() == __nh.get_allocator());\n+\n+\t    auto __code = this->_M_hash_code(__nh._M_key());\n+\t    auto __node = std::exchange(__nh._M_ptr, nullptr);\n+\t    // FIXME: this deallocates the node on exception.\n+\t    __ret = _M_insert_multi_node(__hint._M_cur, __code, __node);\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const_iterator __pos)\n+      {\n+\t__node_type* __n = __pos._M_cur;\n+\tsize_t __bkt = _M_bucket_index(__n);\n+\n+\t// Look for previous node to unlink it from the erased one, this\n+\t// is why we need buckets to contain the before begin to make\n+\t// this search fast.\n+\t__node_base* __prev_n = _M_get_previous_node(__bkt, __n);\n+\n+\tif (__prev_n == _M_buckets[__bkt])\n+\t  _M_remove_bucket_begin(__bkt, __n->_M_next(),\n+\t     __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);\n+\telse if (__n->_M_nxt)\n+\t  {\n+\t    size_type __next_bkt = _M_bucket_index(__n->_M_next());\n+\t    if (__next_bkt != __bkt)\n+\t      _M_buckets[__next_bkt] = __prev_n;\n+\t  }\n+\n+\t__prev_n->_M_nxt = __n->_M_nxt;\n+\t__n->_M_nxt = nullptr;\n+\t--_M_element_count;\n+\treturn { __n, this->_M_node_allocator() };\n+      }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const _Key& __k)\n+      {\n+\tnode_type __nh;\n+\tauto __pos = find(__k);\n+\tif (__pos != end())\n+\t  __nh = extract(const_iterator(__pos));\n+\treturn __nh;\n+      }\n+\n+      /// Merge from a compatible container into one with unique keys.\n+      template<typename _Compatible_Hashtable>\n+\tvoid\n+\t_M_merge_unique(_Compatible_Hashtable& __src) noexcept\n+\t{\n+\t  static_assert(is_same_v<typename _Compatible_Hashtable::node_type,\n+\t      node_type>, \"Node types are compatible\");\n+\t  __glibcxx_assert(get_allocator() == __src.get_allocator());\n+\n+\t  for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)\n+\t    {\n+\t      auto __pos = __i++;\n+\t      const key_type& __k = this->_M_extract()(__pos._M_cur->_M_v());\n+\t      __hash_code __code = this->_M_hash_code(__k);\n+\t      size_type __bkt = _M_bucket_index(__k, __code);\n+\t      if (_M_find_node(__bkt, __k, __code) == nullptr)\n+\t\t{\n+\t\t  auto __nh = __src.extract(__pos);\n+\t\t  _M_insert_unique_node(__bkt, __code, __nh._M_ptr);\n+\t\t  __nh._M_ptr = nullptr;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /// Merge from a compatible container into one with equivalent keys.\n+      template<typename _Compatible_Hashtable>\n+\tvoid\n+\t_M_merge_multi(_Compatible_Hashtable& __src) noexcept\n+\t{\n+\t  static_assert(is_same_v<typename _Compatible_Hashtable::node_type,\n+\t      node_type>, \"Node types are compatible\");\n+\t  __glibcxx_assert(get_allocator() == __src.get_allocator());\n+\n+\t  this->reserve(size() + __src.size());\n+\t  for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)\n+\t    _M_reinsert_node_multi(cend(), __src.extract(__i++));\n+\t}\n+#endif // C++17\n+\n     private:\n       // Helper rehash method used when keys are unique.\n       void _M_rehash_aux(size_type __n, std::true_type);\n@@ -2078,6 +2215,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_buckets = __new_buckets;\n     }\n \n+#if __cplusplus > 201402L\n+  template<typename, typename, typename> class _Hash_merge_helper { };\n+#endif // C++17\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}, {"sha": "60c28838820d291bb686357bc04fe0eed35c0145", "filename": "libstdc++-v3/include/bits/node_handle.h", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnode_handle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnode_handle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnode_handle.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,330 @@\n+// Node handles for containers -*- C++ -*-\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/node_handle.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly.\n+ *  @headername{map,set,unordered_map,unordered_set}\n+ */\n+\n+#ifndef _NODE_HANDLE\n+#define _NODE_HANDLE 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus > 201402L\n+# define __cpp_lib_node_extract 201606\n+\n+#include <optional>\n+#include <tuple>\n+#include <bits/alloc_traits.h>\n+#include <bits/ptr_traits.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /// Base class for node handle types of maps and sets.\n+  template<typename _Val, typename _NodeAlloc>\n+    class _Node_handle_common\n+    {\n+      using _AllocTraits = allocator_traits<_NodeAlloc>;\n+\n+    public:\n+      using allocator_type = __alloc_rebind<_NodeAlloc, _Val>;\n+\n+      allocator_type\n+      get_allocator() const noexcept\n+      {\n+\t__glibcxx_assert(!this->empty());\n+\treturn allocator_type(*_M_alloc);\n+      }\n+\n+      explicit operator bool() const noexcept { return _M_ptr != nullptr; }\n+\n+      bool empty() const noexcept { return _M_ptr == nullptr; }\n+\n+    protected:\n+      constexpr _Node_handle_common() noexcept : _M_ptr(), _M_alloc() {}\n+\n+      ~_Node_handle_common() { _M_destroy(); }\n+\n+      _Node_handle_common(_Node_handle_common&& __nh) noexcept\n+      : _M_ptr(__nh._M_ptr), _M_alloc(std::move(__nh._M_alloc))\n+      {\n+\t__nh._M_ptr = nullptr;\n+\t__nh._M_alloc = nullopt;\n+      }\n+\n+      _Node_handle_common&\n+      operator=(_Node_handle_common&& __nh) noexcept\n+      {\n+\t_M_destroy();\n+\t_M_ptr = __nh._M_ptr;\n+\tif constexpr (is_move_assignable_v<_NodeAlloc>)\n+\t  {\n+\t    if (_AllocTraits::propagate_on_container_move_assignment::value\n+\t\t|| !this->_M_alloc)\n+\t      this->_M_alloc = std::move(__nh._M_alloc);\n+\t    else\n+\t      __glibcxx_assert(this->_M_alloc == __nh._M_alloc);\n+\t  }\n+\telse\n+\t  __glibcxx_assert(_M_alloc);\n+\t__nh._M_ptr = nullptr;\n+\t__nh._M_alloc = nullopt;\n+\treturn *this;\n+      }\n+\n+      _Node_handle_common(typename _AllocTraits::pointer __ptr,\n+\t\t\t  const _NodeAlloc& __alloc)\n+      : _M_ptr(__ptr), _M_alloc(__alloc) { }\n+\n+      void\n+      _M_swap(_Node_handle_common& __nh) noexcept\n+      {\n+\tusing std::swap;\n+\tswap(_M_ptr, __nh._M_ptr);\n+\tif (_AllocTraits::propagate_on_container_swap\n+\t    || !_M_alloc || !__nh._M_alloc)\n+\t  _M_alloc.swap(__nh._M_alloc);\n+\telse\n+\t  __glibcxx_assert(_M_alloc == __nh._M_alloc);\n+      }\n+\n+    private:\n+      void\n+      _M_destroy() noexcept\n+      {\n+\tif (_M_ptr != nullptr)\n+\t  {\n+\t    allocator_type __alloc(*_M_alloc);\n+\t    allocator_traits<allocator_type>::destroy(__alloc,\n+\t\t\t\t\t\t      _M_ptr->_M_valptr());\n+\t    _AllocTraits::deallocate(*_M_alloc, _M_ptr, 1);\n+\t  }\n+      }\n+\n+    protected:\n+      typename _AllocTraits::pointer\t_M_ptr;\n+    private:\n+      optional<_NodeAlloc>\t\t_M_alloc;\n+\n+      template<typename _Key2, typename _Value2, typename _KeyOfValue,\n+\t       typename _Compare, typename _ValueAlloc>\n+\tfriend class _Rb_tree;\n+    };\n+\n+  /// Node handle type for maps.\n+  template<typename _Key, typename _Value, typename _NodeAlloc>\n+    class _Node_handle : public _Node_handle_common<_Value, _NodeAlloc>\n+    {\n+    public:\n+      constexpr _Node_handle() noexcept = default;\n+      ~_Node_handle() = default;\n+      _Node_handle(_Node_handle&&) noexcept = default;\n+\n+      _Node_handle&\n+      operator=(_Node_handle&&) noexcept = default;\n+\n+      using key_type = _Key;\n+      using mapped_type = typename _Value::second_type;\n+\n+      key_type&\n+      key() const noexcept\n+      {\n+\t__glibcxx_assert(!this->empty());\n+\treturn *_M_pkey;\n+      }\n+\n+      mapped_type&\n+      mapped() const noexcept\n+      {\n+\t__glibcxx_assert(!this->empty());\n+\treturn *_M_pmapped;\n+      }\n+\n+      void\n+      swap(_Node_handle& __nh) noexcept\n+      {\n+\tthis->_M_swap(__nh);\n+\tusing std::swap;\n+\tswap(_M_pkey, __nh._M_pkey);\n+\tswap(_M_pmapped, __nh._M_pmapped);\n+      }\n+\n+      friend void\n+      swap(_Node_handle& __x, _Node_handle& __y)\n+      noexcept(noexcept(__x.swap(__y)))\n+      { __x.swap(__y); }\n+\n+    private:\n+      using _AllocTraits = allocator_traits<_NodeAlloc>;\n+\n+      using _PtrTraits = pointer_traits<typename _NodeAlloc::pointer>;\n+\n+      _Node_handle(typename _AllocTraits::pointer __ptr,\n+\t\t\t   const _NodeAlloc& __alloc)\n+      : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc)\n+      {\n+\tif (__ptr)\n+\t  {\n+\t    auto& __key = const_cast<_Key&>(__ptr->_M_valptr()->first);\n+\t    _M_pkey = _S_pointer_to(__key);\n+\t    _M_pmapped = _S_pointer_to(__ptr->_M_valptr()->second);\n+\t  }\n+\telse\n+\t  {\n+\t    _M_pkey = nullptr;\n+\t    _M_pmapped = nullptr;\n+\t  }\n+      }\n+\n+      template<typename _Tp>\n+\tusing __pointer = __ptr_rebind<typename _AllocTraits::pointer, _Tp>;\n+\n+      __pointer<_Key>\t\t\t\t_M_pkey = nullptr;\n+      __pointer<typename _Value::second_type>\t_M_pmapped = nullptr;\n+\n+      template<typename _Tp>\n+\t__pointer<_Tp>\n+\t_S_pointer_to(_Tp& __obj)\n+\t{ return pointer_traits<__pointer<_Tp>>::pointer_to(__obj); }\n+\n+      const key_type&\n+      _M_key() const noexcept { return key(); }\n+\n+      template<typename _Key2, typename _Value2, typename _KeyOfValue,\n+\t       typename _Compare, typename _ValueAlloc>\n+\tfriend class _Rb_tree;\n+\n+      template<typename _Key2, typename _Value2, typename _ValueAlloc,\n+\t       typename _ExtractKey, typename _Equal,\n+\t       typename _H1, typename _H2, typename _Hash,\n+\t       typename _RehashPolicy, typename _Traits>\n+\tfriend class _Hashtable;\n+    };\n+\n+  /// Node handle type for sets.\n+  template<typename _Value, typename _NodeAlloc>\n+    class _Node_handle<_Value, _Value, _NodeAlloc>\n+    : public _Node_handle_common<_Value, _NodeAlloc>\n+    {\n+    public:\n+      constexpr _Node_handle() noexcept = default;\n+      ~_Node_handle() = default;\n+      _Node_handle(_Node_handle&&) noexcept = default;\n+\n+      _Node_handle&\n+      operator=(_Node_handle&&) noexcept = default;\n+\n+      using value_type = _Value;\n+\n+      value_type&\n+      value() const noexcept\n+      {\n+\t__glibcxx_assert(!this->empty());\n+\treturn *this->_M_ptr->_M_valptr();\n+      }\n+\n+      void\n+      swap(_Node_handle& __nh) noexcept\n+      { this->_M_swap(__nh); }\n+\n+      friend void\n+      swap(_Node_handle& __x, _Node_handle& __y)\n+      noexcept(noexcept(__x.swap(__y)))\n+      { __x.swap(__y); }\n+\n+    private:\n+      using _AllocTraits = allocator_traits<_NodeAlloc>;\n+\n+      _Node_handle(typename _AllocTraits::pointer __ptr,\n+\t\t\t   const _NodeAlloc& __alloc)\n+      : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc) { }\n+\n+      const value_type&\n+      _M_key() const noexcept { return value(); }\n+\n+      template<typename _Key, typename _Val, typename _KeyOfValue,\n+\t       typename _Compare, typename _Alloc>\n+\tfriend class _Rb_tree;\n+\n+      template<typename _Key2, typename _Value2, typename _ValueAlloc,\n+\t       typename _ExtractKey, typename _Equal,\n+\t       typename _H1, typename _H2, typename _Hash,\n+\t       typename _RehashPolicy, typename _Traits>\n+\tfriend class _Hashtable;\n+    };\n+\n+  /// Return type of insert(node_handle&&) on unique maps/sets.\n+  template<typename _Iterator, typename _NodeHandle>\n+    struct _Node_insert_return\n+    {\n+      bool\t\tinserted = false;\n+      _Iterator\t\tposition = _Iterator();\n+      _NodeHandle\tnode;\n+\n+      template<size_t _Idx>\n+\tdecltype(auto) get() &\n+\t{ return std::get<_Idx>(std::tie(inserted, position, node)); }\n+\n+      template<size_t _Idx>\n+\tdecltype(auto) get() const &\n+\t{ return std::get<_Idx>(std::tie(inserted, position, node)); }\n+\n+      template<size_t _Idx>\n+\tdecltype(auto) get() &&\n+\t{\n+\t  return std::move(std::get<_Idx>(std::tie(inserted, position, node)));\n+\t}\n+\n+      template<size_t _Idx>\n+\tdecltype(auto) get() const &&\n+\t{\n+\t  return std::move(std::get<_Idx>(std::tie(inserted, position, node)));\n+\t}\n+    };\n+\n+  template<typename _Iterator, typename _NodeHandle>\n+    struct tuple_size<_Node_insert_return<_Iterator, _NodeHandle>>\n+    : integral_constant<size_t, 3> { };\n+\n+  template<typename _Iterator, typename _NodeHandle>\n+    struct tuple_element<0, _Node_insert_return<_Iterator, _NodeHandle>>\n+    { using type = bool; };\n+\n+  template<typename _Iterator, typename _NodeHandle>\n+    struct tuple_element<1, _Node_insert_return<_Iterator, _NodeHandle>>\n+    { using type = _Iterator; };\n+\n+  template<typename _Iterator, typename _NodeHandle>\n+    struct tuple_element<2, _Node_insert_return<_Iterator, _NodeHandle>>\n+    { using type = _NodeHandle; };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++17\n+#endif"}, {"sha": "f9482e29579682f168a0004d1c58c971fcc57b23", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -67,6 +67,9 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    class multimap;\n+\n   /**\n    *  @brief A standard container made up of (key,value) pairs, which can be\n    *  retrieved based on a key, in logarithmic time.\n@@ -153,6 +156,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef typename _Rep_type::reverse_iterator       reverse_iterator;\n       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Rep_type::node_type;\n+      using insert_return_type = typename _Rep_type::insert_return_type;\n+#endif\n+\n       // [23.3.1.1] construct/copy/destroy\n       // (get_allocator() is also listed in this section)\n \n@@ -593,6 +601,57 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t}\n #endif\n \n+#if __cplusplus > 201402L\n+      /// Extract a node.\n+      node_type\n+      extract(const_iterator __pos)\n+      { return _M_t.extract(__pos); }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const key_type& __x)\n+      { return _M_t.extract(__x); }\n+\n+      /// Re-insert an extracted node.\n+      insert_return_type\n+      insert(node_type&& __nh)\n+      { return _M_t._M_reinsert_node_unique(std::move(__nh)); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      { return _M_t._M_reinsert_node_hint_unique(__hint, std::move(__nh)); }\n+\n+      template<typename, typename>\n+\tfriend class _Rb_tree_merge_helper;\n+\n+      template<typename _C2>\n+\tvoid\n+\tmerge(map<_Key, _Tp, _C2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Rb_tree_merge_helper<map, _C2>;\n+\t  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));\n+\t}\n+\n+      template<typename _C2>\n+\tvoid\n+\tmerge(map<_Key, _Tp, _C2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+\n+      template<typename _C2>\n+\tvoid\n+\tmerge(multimap<_Key, _Tp, _C2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Rb_tree_merge_helper<map, _C2>;\n+\t  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));\n+\t}\n+\n+      template<typename _C2>\n+\tvoid\n+\tmerge(multimap<_Key, _Tp, _C2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+#endif // C++17\n+\n #if __cplusplus > 201402L\n #define __cpp_lib_map_try_emplace 201411\n       /**\n@@ -1365,6 +1424,30 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { __x.swap(__y); }\n \n _GLIBCXX_END_NAMESPACE_CONTAINER\n+\n+#if __cplusplus > 201402L\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  // Allow std::map access to internals of compatible maps.\n+  template<typename _Key, typename _Val, typename _Cmp1, typename _Alloc,\n+\t   typename _Cmp2>\n+    struct\n+    _Rb_tree_merge_helper<_GLIBCXX_STD_C::map<_Key, _Val, _Cmp1, _Alloc>,\n+\t\t\t  _Cmp2>\n+    {\n+    private:\n+      friend class _GLIBCXX_STD_C::map<_Key, _Val, _Cmp1, _Alloc>;\n+\n+      static auto&\n+      _S_get_tree(_GLIBCXX_STD_C::map<_Key, _Val, _Cmp2, _Alloc>& __map)\n+      { return __map._M_t; }\n+\n+      static auto&\n+      _S_get_tree(_GLIBCXX_STD_C::multimap<_Key, _Val, _Cmp2, _Alloc>& __map)\n+      { return __map._M_t; }\n+    };\n+_GLIBCXX_END_NAMESPACE_VERSION\n+#endif // C++17\n+\n } // namespace std\n \n #endif /* _STL_MAP_H */"}, {"sha": "2b56824b4494478d8bca4981b41a8c57d6e5b9b5", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -65,6 +65,9 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n+  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    class map;\n+\n   /**\n    *  @brief A standard container made up of (key,value) pairs, which can be\n    *  retrieved based on a key, in logarithmic time.\n@@ -151,6 +154,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef typename _Rep_type::reverse_iterator       reverse_iterator;\n       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Rep_type::node_type;\n+#endif\n+\n       // [23.3.2] construct/copy/destroy\n       // (get_allocator() is also listed in this section)\n \n@@ -595,6 +602,57 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { this->insert(__l.begin(), __l.end()); }\n #endif\n \n+#if __cplusplus > 201402L\n+      /// Extract a node.\n+      node_type\n+      extract(const_iterator __pos)\n+      { return _M_t.extract(__pos); }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const key_type& __x)\n+      { return _M_t.extract(__x); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(node_type&& __nh)\n+      { return _M_t._M_reinsert_node_equal(std::move(__nh)); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      { return _M_t._M_reinsert_node_hint_equal(__hint, std::move(__nh)); }\n+\n+      template<typename, typename>\n+\tfriend class _Rb_tree_merge_helper;\n+\n+      template<typename _C2>\n+\tvoid\n+\tmerge(multimap<_Key, _Tp, _C2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Rb_tree_merge_helper<multimap, _C2>;\n+\t  _M_t._M_merge_equal(_Merge_helper::_S_get_tree(__source));\n+\t}\n+\n+      template<typename _C2>\n+\tvoid\n+\tmerge(multimap<_Key, _Tp, _C2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+\n+      template<typename _C2>\n+\tvoid\n+\tmerge(map<_Key, _Tp, _C2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Rb_tree_merge_helper<multimap, _C2>;\n+\t  _M_t._M_merge_equal(_Merge_helper::_S_get_tree(__source));\n+\t}\n+\n+      template<typename _C2>\n+\tvoid\n+\tmerge(map<_Key, _Tp, _C2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+#endif // C++17\n+\n #if __cplusplus >= 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 130. Associative erase should return an iterator.\n@@ -1030,6 +1088,30 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { __x.swap(__y); }\n \n _GLIBCXX_END_NAMESPACE_CONTAINER\n+\n+#if __cplusplus > 201402L\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  // Allow std::multimap access to internals of compatible maps.\n+  template<typename _Key, typename _Val, typename _Cmp1, typename _Alloc,\n+\t   typename _Cmp2>\n+    struct\n+    _Rb_tree_merge_helper<_GLIBCXX_STD_C::multimap<_Key, _Val, _Cmp1, _Alloc>,\n+\t\t\t  _Cmp2>\n+    {\n+    private:\n+      friend class _GLIBCXX_STD_C::multimap<_Key, _Val, _Cmp1, _Alloc>;\n+\n+      static auto&\n+      _S_get_tree(_GLIBCXX_STD_C::map<_Key, _Val, _Cmp2, _Alloc>& __map)\n+      { return __map._M_t; }\n+\n+      static auto&\n+      _S_get_tree(_GLIBCXX_STD_C::multimap<_Key, _Val, _Cmp2, _Alloc>& __map)\n+      { return __map._M_t; }\n+    };\n+_GLIBCXX_END_NAMESPACE_VERSION\n+#endif // C++17\n+\n } // namespace std\n \n #endif /* _STL_MULTIMAP_H */"}, {"sha": "d7312dff621dee9b639bb7426d00e79a8bfd405f", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -65,6 +65,9 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    class set;\n+\n   /**\n    *  @brief A standard container made up of elements, which can be retrieved\n    *  in logarithmic time.\n@@ -133,6 +136,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef typename _Rep_type::size_type                 size_type;\n       typedef typename _Rep_type::difference_type           difference_type;\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Rep_type::node_type;\n+#endif\n+\n       // allocation/deallocation\n       /**\n        *  @brief  Default constructor creates no elements.\n@@ -538,6 +545,57 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { this->insert(__l.begin(), __l.end()); }\n #endif\n \n+#if __cplusplus > 201402L\n+      /// Extract a node.\n+      node_type\n+      extract(const_iterator __pos)\n+      { return _M_t.extract(__pos); }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const key_type& __x)\n+      { return _M_t.extract(__x); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(node_type&& __nh)\n+      { return _M_t._M_reinsert_node_equal(std::move(__nh)); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      { return _M_t._M_reinsert_node_hint_equal(__hint, std::move(__nh)); }\n+\n+      template<typename, typename>\n+\tfriend class _Rb_tree_merge_helper;\n+\n+      template<typename _Compare1>\n+\tvoid\n+\tmerge(multiset<_Key, _Compare1, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Rb_tree_merge_helper<multiset, _Compare1>;\n+\t  _M_t._M_merge_equal(_Merge_helper::_S_get_tree(__source));\n+\t}\n+\n+      template<typename _Compare1>\n+\tvoid\n+\tmerge(multiset<_Key, _Compare1, _Alloc>&& __source)\n+\t{ merge(__source); }\n+\n+      template<typename _Compare1>\n+\tvoid\n+\tmerge(set<_Key, _Compare1, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Rb_tree_merge_helper<multiset, _Compare1>;\n+\t  _M_t._M_merge_equal(_Merge_helper::_S_get_tree(__source));\n+\t}\n+\n+      template<typename _Compare1>\n+\tvoid\n+\tmerge(set<_Key, _Compare1, _Alloc>&& __source)\n+\t{ merge(__source); }\n+#endif // C++17\n+\n #if __cplusplus >= 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 130. Associative erase should return an iterator.\n@@ -881,6 +939,29 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { __x.swap(__y); }\n \n _GLIBCXX_END_NAMESPACE_CONTAINER\n+\n+#if __cplusplus > 201402L\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  // Allow std::multiset access to internals of compatible sets.\n+  template<typename _Val, typename _Cmp1, typename _Alloc, typename _Cmp2>\n+    struct\n+    _Rb_tree_merge_helper<_GLIBCXX_STD_C::multiset<_Val, _Cmp1, _Alloc>,\n+\t\t\t  _Cmp2>\n+    {\n+    private:\n+      friend class _GLIBCXX_STD_C::multiset<_Val, _Cmp1, _Alloc>;\n+\n+      static auto&\n+      _S_get_tree(_GLIBCXX_STD_C::set<_Val, _Cmp2, _Alloc>& __set)\n+      { return __set._M_t; }\n+\n+      static auto&\n+      _S_get_tree(_GLIBCXX_STD_C::multiset<_Val, _Cmp2, _Alloc>& __set)\n+      { return __set._M_t; }\n+    };\n+_GLIBCXX_END_NAMESPACE_VERSION\n+#endif // C++17\n+\n } // namespace std\n \n #endif /* _STL_MULTISET_H */"}, {"sha": "fd96dd4bb583a2b9fec86963c9d507823db3fffd", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -65,6 +65,9 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    class multiset;\n+\n   /**\n    *  @brief A standard container made up of unique keys, which can be\n    *  retrieved in logarithmic time.\n@@ -135,6 +138,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef typename _Rep_type::difference_type           difference_type;\n       //@}\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Rep_type::node_type;\n+      using insert_return_type = typename _Rep_type::insert_return_type;\n+#endif\n+\n       // allocation/deallocation\n       /**\n        *  @brief  Default constructor creates no elements.\n@@ -553,6 +561,57 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { this->insert(__l.begin(), __l.end()); }\n #endif\n \n+#if __cplusplus > 201402L\n+      /// Extract a node.\n+      node_type\n+      extract(const_iterator __pos)\n+      { return _M_t.extract(__pos); }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const key_type& __x)\n+      { return _M_t.extract(__x); }\n+\n+      /// Re-insert an extracted node.\n+      insert_return_type\n+      insert(node_type&& __nh)\n+      { return _M_t._M_reinsert_node_unique(std::move(__nh)); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      { return _M_t._M_reinsert_node_hint_unique(__hint, std::move(__nh)); }\n+\n+      template<typename, typename>\n+\tfriend class _Rb_tree_merge_helper;\n+\n+      template<typename _Compare1>\n+\tvoid\n+\tmerge(set<_Key, _Compare1, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Rb_tree_merge_helper<set, _Compare1>;\n+\t  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));\n+\t}\n+\n+      template<typename _Compare1>\n+\tvoid\n+\tmerge(set<_Key, _Compare1, _Alloc>&& __source)\n+\t{ merge(__source); }\n+\n+      template<typename _Compare1>\n+\tvoid\n+\tmerge(multiset<_Key, _Compare1, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Rb_tree_merge_helper<set, _Compare1>;\n+\t  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));\n+\t}\n+\n+      template<typename _Compare1>\n+\tvoid\n+\tmerge(multiset<_Key, _Compare1, _Alloc>&& __source)\n+\t{ merge(__source); }\n+#endif // C++17\n+\n #if __cplusplus >= 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 130. Associative erase should return an iterator.\n@@ -897,5 +956,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { __x.swap(__y); }\n \n _GLIBCXX_END_NAMESPACE_CONTAINER\n+\n+#if __cplusplus > 201402L\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  // Allow std::set access to internals of compatible sets.\n+  template<typename _Val, typename _Cmp1, typename _Alloc, typename _Cmp2>\n+    struct\n+    _Rb_tree_merge_helper<_GLIBCXX_STD_C::set<_Val, _Cmp1, _Alloc>, _Cmp2>\n+    {\n+    private:\n+      friend class _GLIBCXX_STD_C::set<_Val, _Cmp1, _Alloc>;\n+\n+      static auto&\n+      _S_get_tree(_GLIBCXX_STD_C::set<_Val, _Cmp2, _Alloc>& __set)\n+      { return __set._M_t; }\n+\n+      static auto&\n+      _S_get_tree(_GLIBCXX_STD_C::multiset<_Val, _Cmp2, _Alloc>& __set)\n+      { return __set._M_t; }\n+    };\n+_GLIBCXX_END_NAMESPACE_VERSION\n+#endif // C++17\n+\n } //namespace std\n #endif /* _STL_SET_H */"}, {"sha": "32da609e38dcff34f964f42494762dbd0b8901ec", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 196, "deletions": 1, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -66,7 +66,10 @@\n #include <bits/cpp_type_traits.h>\n #include <ext/alloc_traits.h>\n #if __cplusplus >= 201103L\n-#include <ext/aligned_buffer.h>\n+# include <ext/aligned_buffer.h>\n+#endif\n+#if __cplusplus > 201402L\n+# include <bits/node_handle.h>\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -356,6 +359,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { typedef void type; };\n #endif\n \n+#if __cplusplus > 201402L\n+  template<typename _Tree1, typename _Cmp2>\n+    struct _Rb_tree_merge_helper { };\n+#endif\n+\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc = allocator<_Val> >\n     class _Rb_tree\n@@ -735,6 +743,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef std::reverse_iterator<iterator>       reverse_iterator;\n       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n \n+#if __cplusplus > 201402L\n+      using node_type = _Node_handle<_Key, _Val, _Node_allocator>;\n+      using insert_return_type = _Node_insert_return<iterator, node_type>;\n+#endif\n+\n       pair<_Base_ptr, _Base_ptr>\n       _M_get_insert_unique_pos(const key_type& __k);\n \n@@ -1274,6 +1287,172 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_move_assign(_Rb_tree&, std::false_type);\n #endif\n+\n+#if __cplusplus > 201402L\n+    public:\n+      /// Re-insert an extracted node.\n+      insert_return_type\n+      _M_reinsert_node_unique(node_type&& __nh)\n+      {\n+\tinsert_return_type __ret;\n+\tif (__nh.empty())\n+\t  __ret.position = end();\n+\telse\n+\t  {\n+\t    __glibcxx_assert(_M_get_Node_allocator() == *__nh._M_alloc);\n+\n+\t    auto __res = _M_get_insert_unique_pos(__nh._M_key());\n+\t    if (__res.second)\n+\t      {\n+\t\t__ret.position\n+\t\t  = _M_insert_node(__res.first, __res.second, __nh._M_ptr);\n+\t\t__nh._M_ptr = nullptr;\n+\t\t__ret.inserted = true;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.node = std::move(__nh);\n+\t\t__ret.position = iterator(__res.first);\n+\t\t__ret.inserted = false;\n+\t      }\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      _M_reinsert_node_equal(node_type&& __nh)\n+      {\n+\titerator __ret;\n+\tif (__nh.empty())\n+\t  __ret = end();\n+\telse\n+\t  {\n+\t    __glibcxx_assert(_M_get_Node_allocator() == *__nh._M_alloc);\n+\t    auto __res = _M_get_insert_equal_pos(__nh._M_key());\n+\t    if (__res.second)\n+\t      __ret = _M_insert_node(__res.first, __res.second, __nh._M_ptr);\n+\t    else\n+\t      __ret = _M_insert_equal_lower_node(__nh._M_ptr);\n+\t    __nh._M_ptr = nullptr;\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      _M_reinsert_node_hint_unique(const_iterator __hint, node_type&& __nh)\n+      {\n+\titerator __ret;\n+\tif (__nh.empty())\n+\t  __ret = end();\n+\telse\n+\t  {\n+\t    __glibcxx_assert(_M_get_Node_allocator() == *__nh._M_alloc);\n+\t    auto __res = _M_get_insert_hint_unique_pos(__hint, __nh._M_key());\n+\t    if (__res.second)\n+\t      {\n+\t\t__ret = _M_insert_node(__res.first, __res.second, __nh._M_ptr);\n+\t\t__nh._M_ptr = nullptr;\n+\t      }\n+\t    else\n+\t      __ret = iterator(__res.first);\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      _M_reinsert_node_hint_equal(const_iterator __hint, node_type&& __nh)\n+      {\n+\titerator __ret;\n+\tif (__nh.empty())\n+\t  __ret = end();\n+\telse\n+\t  {\n+\t    __glibcxx_assert(_M_get_Node_allocator() == *__nh._M_alloc);\n+\t    auto __res = _M_get_insert_hint_equal_pos(__hint, __nh._M_key());\n+\t    if (__res.second)\n+\t      __ret = _M_insert_node(__res.first, __res.second, __nh._M_ptr);\n+\t    else\n+\t      __ret = _M_insert_equal_lower_node(__nh._M_ptr);\n+\t    __nh._M_ptr = nullptr;\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const_iterator __pos)\n+      {\n+\tauto __ptr = _Rb_tree_rebalance_for_erase(\n+\t    __pos._M_const_cast()._M_node, _M_impl._M_header);\n+\t--_M_impl._M_node_count;\n+\treturn { static_cast<_Link_type>(__ptr), _M_get_Node_allocator() };\n+      }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const key_type& __k)\n+      {\n+\tnode_type __nh;\n+\tauto __pos = find(__k);\n+\tif (__pos != end())\n+\t  __nh = extract(const_iterator(__pos));\n+\treturn __nh;\n+      }\n+\n+      template<typename _Compare2>\n+\tusing _Compatible_tree\n+\t  = _Rb_tree<_Key, _Val, _KeyOfValue, _Compare2, _Alloc>;\n+\n+      template<typename, typename>\n+\tfriend class _Rb_tree_merge_helper;\n+\n+      /// Merge from a compatible container into one with unique keys.\n+      template<typename _Compare2>\n+\tvoid\n+\t_M_merge_unique(_Compatible_tree<_Compare2>& __src) noexcept\n+\t{\n+\t  using _Merge_helper = _Rb_tree_merge_helper<_Rb_tree, _Compare2>;\n+\t  for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)\n+\t    {\n+\t      auto __pos = __i++;\n+\t      auto __res = _M_get_insert_unique_pos(_KeyOfValue()(*__pos));\n+\t      if (__res.second)\n+\t\t{\n+\t\t  auto& __src_impl = _Merge_helper::_S_get_impl(__src);\n+\t\t  auto __ptr = _Rb_tree_rebalance_for_erase(\n+\t\t      __pos._M_node, __src_impl._M_header);\n+\t\t  --__src_impl._M_node_count;\n+\t\t  _M_insert_node(__res.first, __res.second,\n+\t\t\t\t static_cast<_Link_type>(__ptr));\n+\t\t}\n+\t    }\n+\t}\n+\n+      /// Merge from a compatible container into one with equivalent keys.\n+      template<typename _Compare2>\n+\tvoid\n+\t_M_merge_equal(_Compatible_tree<_Compare2>& __src) noexcept\n+\t{\n+\t  using _Merge_helper = _Rb_tree_merge_helper<_Rb_tree, _Compare2>;\n+\t  for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)\n+\t    {\n+\t      auto __pos = __i++;\n+\t      auto __res = _M_get_insert_equal_pos(_KeyOfValue()(*__pos));\n+\t      if (__res.second)\n+\t\t{\n+\t\t  auto& __src_impl = _Merge_helper::_S_get_impl(__src);\n+\t\t  auto __ptr = _Rb_tree_rebalance_for_erase(\n+\t\t      __pos._M_node, __src_impl._M_header);\n+\t\t  --__src_impl._M_node_count;\n+\t\t  _M_insert_node(__res.first, __res.second,\n+\t\t\t\t static_cast<_Link_type>(__ptr));\n+\t\t}\n+\t    }\n+\t}\n+#endif // C++17\n     };\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -2390,6 +2569,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return true;\n     }\n \n+#if __cplusplus > 201402L\n+  // Allow access to internals of compatible _Rb_tree specializations.\n+  template<typename _Key, typename _Val, typename _Sel, typename _Cmp1,\n+\t   typename _Alloc, typename _Cmp2>\n+    struct _Rb_tree_merge_helper<_Rb_tree<_Key, _Val, _Sel, _Cmp1, _Alloc>,\n+\t\t\t\t _Cmp2>\n+    {\n+    private:\n+      friend class _Rb_tree<_Key, _Val, _Sel, _Cmp1, _Alloc>;\n+\n+      static auto&\n+      _S_get_impl(_Rb_tree<_Key, _Val, _Sel, _Cmp2, _Alloc>& __tree)\n+      { return __tree._M_impl; }\n+    };\n+#endif // C++17\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n "}, {"sha": "ab8a7621e0dfba7b17a7a577ee7acc1ac2c160e6", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 174, "deletions": 4, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -68,6 +68,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t\t\t __detail::_Default_ranged_hash,\n \t\t\t\t\t __detail::_Prime_rehash_policy, _Tr>;\n \n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n+    class unordered_multimap;\n+\n   /**\n    *  @brief A standard container composed of unique keys (containing\n    *  at most one of each key value) that associates values of another type\n@@ -126,6 +129,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef typename _Hashtable::difference_type\tdifference_type;\n       //@}\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Hashtable::node_type;\n+      using insert_return_type = typename _Hashtable::insert_return_type;\n+#endif\n+\n       //construct/destroy/copy\n \n       /// Default constructor.\n@@ -409,8 +417,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \templace_hint(const_iterator __pos, _Args&&... __args)\n \t{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }\n \n-\n #if __cplusplus > 201402L\n+      /// Extract a node.\n+      node_type\n+      extract(const_iterator __pos)\n+      { return _M_h.extract(__pos); }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const key_type& __key)\n+      { return _M_h.extract(__key); }\n+\n+      /// Re-insert an extracted node.\n+      insert_return_type\n+      insert(node_type&& __nh)\n+      { return _M_h._M_reinsert_node(std::move(__nh)); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(const_iterator, node_type&& __nh)\n+      { return _M_h._M_reinsert_node(std::move(__nh)).position; }\n+\n #define __cpp_lib_unordered_map_try_emplace 201411\n       /**\n        *  @brief Attempts to build and insert a std::pair into the\n@@ -524,7 +551,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n                                  std::forward<_Args>(__args)...));\n           return __i;\n         }\n-#endif\n+#endif // C++17\n \n       //@{\n       /**\n@@ -817,6 +844,37 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       noexcept( noexcept(_M_h.swap(__x._M_h)) )\n       { _M_h.swap(__x._M_h); }\n \n+#if __cplusplus > 201402L\n+      template<typename, typename, typename>\n+\tfriend class _Hash_merge_helper;\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Hash_merge_helper<unordered_map, _H2, _P2>;\n+\t  _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));\n+\t}\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Hash_merge_helper<unordered_map, _H2, _P2>;\n+\t  _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));\n+\t}\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+#endif // C++17\n+\n       // observers.\n \n       ///  Returns the hash functor object with which the %unordered_map was\n@@ -1052,8 +1110,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,\n \t       typename _Alloc1>\n         friend bool\n-      operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,\n-\t\t const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);\n+\toperator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,\n+\t\t   const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);\n     };\n \n   /**\n@@ -1114,6 +1172,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef typename _Hashtable::difference_type\tdifference_type;\n       //@}\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Hashtable::node_type;\n+#endif\n+\n       //construct/destroy/copy\n \n       /// Default constructor.\n@@ -1468,6 +1530,28 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(initializer_list<value_type> __l)\n       { _M_h.insert(__l); }\n \n+#if __cplusplus > 201402L\n+      /// Extract a node.\n+      node_type\n+      extract(const_iterator __pos)\n+      { return _M_h.extract(__pos); }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const key_type& __key)\n+      { return _M_h.extract(__key); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(node_type&& __nh)\n+      { return _M_h._M_reinsert_node_multi(cend(), std::move(__nh)); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }\n+#endif // C++17\n+\n       //@{\n       /**\n        *  @brief Erases an element from an %unordered_multimap.\n@@ -1551,6 +1635,39 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       noexcept( noexcept(_M_h.swap(__x._M_h)) )\n       { _M_h.swap(__x._M_h); }\n \n+#if __cplusplus > 201402L\n+      template<typename, typename, typename>\n+\tfriend class _Hash_merge_helper;\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper\n+\t    = _Hash_merge_helper<unordered_multimap, _H2, _P2>;\n+\t  _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));\n+\t}\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper\n+\t    = _Hash_merge_helper<unordered_multimap, _H2, _P2>;\n+\t  _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));\n+\t}\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+#endif // C++17\n+\n       // observers.\n \n       ///  Returns the hash functor object with which the %unordered_multimap\n@@ -1786,6 +1903,59 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { return !(__x == __y); }\n \n _GLIBCXX_END_NAMESPACE_CONTAINER\n+\n+#if __cplusplus > 201402L\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  // Allow std::unordered_map access to internals of compatible maps.\n+  template<typename _Key, typename _Val, typename _Hash1, typename _Eq1,\n+\t   typename _Alloc, typename _Hash2, typename _Eq2>\n+    struct _Hash_merge_helper<\n+      _GLIBCXX_STD_C::unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>,\n+      _Hash2, _Eq2>\n+    {\n+    private:\n+      template<typename... _Tp>\n+\tusing unordered_map = _GLIBCXX_STD_C::unordered_map<_Tp...>;\n+      template<typename... _Tp>\n+\tusing unordered_multimap = _GLIBCXX_STD_C::unordered_multimap<_Tp...>;\n+\n+      friend unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>;\n+\n+      static auto&\n+      _S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)\n+      { return __map._M_h; }\n+\n+      static auto&\n+      _S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)\n+      { return __map._M_h; }\n+    };\n+\n+  // Allow std::unordered_multimap access to internals of compatible maps.\n+  template<typename _Key, typename _Val, typename _Hash1, typename _Eq1,\n+\t   typename _Alloc, typename _Hash2, typename _Eq2>\n+    struct _Hash_merge_helper<\n+      _GLIBCXX_STD_C::unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>,\n+      _Hash2, _Eq2>\n+    {\n+    private:\n+      template<typename... _Tp>\n+\tusing unordered_map = _GLIBCXX_STD_C::unordered_map<_Tp...>;\n+      template<typename... _Tp>\n+\tusing unordered_multimap = _GLIBCXX_STD_C::unordered_multimap<_Tp...>;\n+\n+      friend unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>;\n+\n+      static auto&\n+      _S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)\n+      { return __map._M_h; }\n+\n+      static auto&\n+      _S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)\n+      { return __map._M_h; }\n+    };\n+_GLIBCXX_END_NAMESPACE_VERSION\n+#endif // C++17\n+\n } // namespace std\n \n #endif /* _UNORDERED_MAP_H */"}, {"sha": "e5bb2beb80da01ef05ff3367989f137bc345fbed", "filename": "libstdc++-v3/include/bits/unordered_set.h", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_set.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -65,6 +65,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t\t\t __detail::_Default_ranged_hash,\n \t\t\t\t\t __detail::_Prime_rehash_policy, _Tr>;\n \n+  template<class _Value, class _Hash, class _Pred, class _Alloc>\n+    class unordered_multiset;\n+\n   /**\n    *  @brief A standard container composed of unique keys (containing\n    *  at most one of each key value) in which the elements' keys are\n@@ -120,6 +123,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef typename _Hashtable::difference_type\tdifference_type;\n       //@}\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Hashtable::node_type;\n+      using insert_return_type = typename _Hashtable::insert_return_type;\n+#endif\n+\n       // construct/destroy/copy\n \n       /// Default constructor.\n@@ -470,6 +478,28 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(initializer_list<value_type> __l)\n       { _M_h.insert(__l); }\n \n+#if __cplusplus > 201402L\n+      /// Extract a node.\n+      node_type\n+      extract(const_iterator __pos)\n+      { return _M_h.extract(__pos); }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const key_type& __key)\n+      { return _M_h.extract(__key); }\n+\n+      /// Re-insert an extracted node.\n+      insert_return_type\n+      insert(node_type&& __nh)\n+      { return _M_h._M_reinsert_node(std::move(__nh)); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(const_iterator, node_type&& __nh)\n+      { return _M_h._M_reinsert_node(std::move(__nh)).position; }\n+#endif // C++17\n+\n       //@{\n       /**\n        *  @brief Erases an element from an %unordered_set.\n@@ -552,6 +582,37 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       noexcept( noexcept(_M_h.swap(__x._M_h)) )\n       { _M_h.swap(__x._M_h); }\n \n+#if __cplusplus > 201402L\n+      template<typename, typename, typename>\n+\tfriend class _Hash_merge_helper;\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_set<_Value, _H2, _P2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Hash_merge_helper<unordered_set, _H2, _P2>;\n+\t  _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));\n+\t}\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_set<_Value, _H2, _P2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_multiset<_Value, _H2, _P2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper = _Hash_merge_helper<unordered_set, _H2, _P2>;\n+\t  _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));\n+\t}\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_multiset<_Value, _H2, _P2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+#endif // C++17\n+\n       // observers.\n \n       ///  Returns the hash functor object with which the %unordered_set was\n@@ -793,6 +854,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef typename _Hashtable::difference_type\tdifference_type;\n       //@}\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Hashtable::node_type;\n+#endif\n+\n       // construct/destroy/copy\n \n       /// Default constructor.\n@@ -1121,6 +1186,28 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(initializer_list<value_type> __l)\n       { _M_h.insert(__l); }\n \n+#if __cplusplus > 201402L\n+      /// Extract a node.\n+      node_type\n+      extract(const_iterator __pos)\n+      { return _M_h.extract(__pos); }\n+\n+      /// Extract a node.\n+      node_type\n+      extract(const key_type& __key)\n+      { return _M_h.extract(__key); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(node_type&& __nh)\n+      { return _M_h._M_reinsert_node_multi(cend(), std::move(__nh)); }\n+\n+      /// Re-insert an extracted node.\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }\n+#endif // C++17\n+\n       //@{\n       /**\n        *  @brief Erases an element from an %unordered_multiset.\n@@ -1208,6 +1295,39 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       noexcept( noexcept(_M_h.swap(__x._M_h)) )\n       { _M_h.swap(__x._M_h); }\n \n+#if __cplusplus > 201402L\n+      template<typename, typename, typename>\n+\tfriend class _Hash_merge_helper;\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_multiset<_Value, _H2, _P2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper\n+\t    = _Hash_merge_helper<unordered_multiset, _H2, _P2>;\n+\t  _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));\n+\t}\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_multiset<_Value, _H2, _P2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_set<_Value, _H2, _P2, _Alloc>& __source)\n+\t{\n+\t  using _Merge_helper\n+\t    = _Hash_merge_helper<unordered_multiset, _H2, _P2>;\n+\t  _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));\n+\t}\n+\n+      template<typename _H2, typename _P2>\n+\tvoid\n+\tmerge(unordered_set<_Value, _H2, _P2, _Alloc>&& __source)\n+\t{ merge(__source); }\n+#endif // C++17\n+\n       // observers.\n \n       ///  Returns the hash functor object with which the %unordered_multiset\n@@ -1429,6 +1549,58 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { return !(__x == __y); }\n \n _GLIBCXX_END_NAMESPACE_CONTAINER\n+\n+#if __cplusplus > 201402L\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  // Allow std::unordered_set access to internals of compatible sets.\n+  template<typename _Val, typename _Hash1, typename _Eq1, typename _Alloc,\n+\t   typename _Hash2, typename _Eq2>\n+    struct _Hash_merge_helper<\n+      _GLIBCXX_STD_C::unordered_set<_Val, _Hash1, _Eq1, _Alloc>, _Hash2, _Eq2>\n+    {\n+    private:\n+      template<typename... _Tp>\n+\tusing unordered_set = _GLIBCXX_STD_C::unordered_set<_Tp...>;\n+      template<typename... _Tp>\n+\tusing unordered_multiset = _GLIBCXX_STD_C::unordered_multiset<_Tp...>;\n+\n+      friend unordered_set<_Val, _Hash1, _Eq1, _Alloc>;\n+\n+      static auto&\n+      _S_get_table(unordered_set<_Val, _Hash2, _Eq2, _Alloc>& __set)\n+      { return __set._M_h; }\n+\n+      static auto&\n+      _S_get_table(unordered_multiset<_Val, _Hash2, _Eq2, _Alloc>& __set)\n+      { return __set._M_h; }\n+    };\n+\n+  // Allow std::unordered_multiset access to internals of compatible sets.\n+  template<typename _Val, typename _Hash1, typename _Eq1, typename _Alloc,\n+\t   typename _Hash2, typename _Eq2>\n+    struct _Hash_merge_helper<\n+      _GLIBCXX_STD_C::unordered_multiset<_Val, _Hash1, _Eq1, _Alloc>,\n+      _Hash2, _Eq2>\n+    {\n+    private:\n+      template<typename... _Tp>\n+\tusing unordered_set = _GLIBCXX_STD_C::unordered_set<_Tp...>;\n+      template<typename... _Tp>\n+\tusing unordered_multiset = _GLIBCXX_STD_C::unordered_multiset<_Tp...>;\n+\n+      friend unordered_multiset<_Val, _Hash1, _Eq1, _Alloc>;\n+\n+      static auto&\n+      _S_get_table(unordered_set<_Val, _Hash2, _Eq2, _Alloc>& __set)\n+      { return __set._M_h; }\n+\n+      static auto&\n+      _S_get_table(unordered_multiset<_Val, _Hash2, _Eq2, _Alloc>& __set)\n+      { return __set._M_h; }\n+    };\n+_GLIBCXX_END_NAMESPACE_VERSION\n+#endif // C++17\n+\n } // namespace std\n \n #endif /* _UNORDERED_SET_H */"}, {"sha": "51cd140a1227835c4e15769e5cc24eb9243250e5", "filename": "libstdc++-v3/include/debug/map.h", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -397,8 +397,52 @@ namespace __debug\n \t\t\t\t\t\t  std::forward<_Obj>(__obj)),\n \t\t\t  this);\n \t}\n-#endif\n+#endif // C++17\n+\n+#if __cplusplus > 201402L\n+      using node_type = typename _Base::node_type;\n+\n+      struct insert_return_type\n+      {\n+\tbool inserted;\n+\titerator position;\n+\tnode_type node;\n+      };\n+\n+      node_type\n+      extract(const_iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n+\treturn _Base::extract(__position.base());\n+      }\n+\n+      node_type\n+      extract(const key_type& __key)\n+      {\n+\tconst auto __position = find(__key);\n+\tif (__position != end())\n+\t  return extract(__position);\n+\treturn {};\n+      }\n+\n+      insert_return_type\n+      insert(node_type&& __nh)\n+      {\n+\tauto __ret = _Base::insert(std::move(__nh));\n+\titerator __pos = iterator(__ret.position, this);\n+\treturn { __ret.inserted, __pos, std::move(__ret.node) };\n+      }\n+\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      {\n+\t__glibcxx_check_insert(__hint);\n+\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+      }\n \n+      using _Base::merge;\n+#endif // C++17\n \n #if __cplusplus >= 201103L\n       iterator"}, {"sha": "0cecedb5b386b83f90e466231c9fdc9db87f3bca", "filename": "libstdc++-v3/include/debug/multimap.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -296,6 +296,40 @@ namespace __debug\n \t    _Base::insert(__first, __last);\n \t}\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Base::node_type;\n+\n+      node_type\n+      extract(const_iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n+\treturn _Base::extract(__position.base());\n+      }\n+\n+      node_type\n+      extract(const key_type& __key)\n+      {\n+\tconst auto __position = find(__key);\n+\tif (__position != end())\n+\t  return extract(__position);\n+\treturn {};\n+      }\n+\n+      iterator\n+      insert(node_type&& __nh)\n+      { return iterator(_Base::insert(std::move(__nh)), this); }\n+\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      {\n+\t__glibcxx_check_insert(__hint);\n+\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+      }\n+\n+      using _Base::merge;\n+#endif // C++17\n+\n #if __cplusplus >= 201103L\n       iterator\n       erase(const_iterator __position)"}, {"sha": "2d68a3df92c4972befc0967b5a8ebf6aef3c287c", "filename": "libstdc++-v3/include/debug/multiset.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -287,6 +287,40 @@ namespace __debug\n       { _Base::insert(__l); }\n #endif\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Base::node_type;\n+\n+      node_type\n+      extract(const_iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n+\treturn _Base::extract(__position.base());\n+      }\n+\n+      node_type\n+      extract(const key_type& __key)\n+      {\n+\tconst auto __position = find(__key);\n+\tif (__position != end())\n+\t  return extract(__position);\n+\treturn {};\n+      }\n+\n+      iterator\n+      insert(node_type&& __nh)\n+      { return iterator(_Base::insert(std::move(__nh)), this); }\n+\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      {\n+\t__glibcxx_check_insert(__hint);\n+\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+      }\n+\n+      using _Base::merge;\n+#endif // C++17\n+\n #if __cplusplus >= 201103L\n       iterator\n       erase(const_iterator __position)"}, {"sha": "8937638445824e9d41c3d813b4c4b39d22520e2a", "filename": "libstdc++-v3/include/debug/set.h", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -296,6 +296,51 @@ namespace __debug\n       { _Base::insert(__l); }\n #endif\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Base::node_type;\n+\n+      struct insert_return_type\n+      {\n+\tbool inserted;\n+\titerator position;\n+\tnode_type node;\n+      };\n+\n+      node_type\n+      extract(const_iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n+\treturn _Base::extract(__position.base());\n+      }\n+\n+      node_type\n+      extract(const key_type& __key)\n+      {\n+\tconst auto __position = find(__key);\n+\tif (__position != end())\n+\t  return extract(__position);\n+\treturn {};\n+      }\n+\n+      insert_return_type\n+      insert(node_type&& __nh)\n+      {\n+\tauto __ret = _Base::insert(std::move(__nh));\n+\titerator __pos = iterator(__ret.position, this);\n+\treturn { __ret.inserted, __pos, std::move(__ret.node) };\n+      }\n+\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      {\n+\t__glibcxx_check_insert(__hint);\n+\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+      }\n+\n+      using _Base::merge;\n+#endif // C++17\n+\n #if __cplusplus >= 201103L\n       iterator\n       erase(const_iterator __position)"}, {"sha": "4a834c67ebab350f010d7077c4f6c7017c0412ca", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -458,8 +458,59 @@ namespace __debug\n \t\t\t\t\t\t  std::forward<_Obj>(__obj)),\n \t\t\t  this);\n \t}\n-#endif\n+#endif // C++17\n+\n+#if __cplusplus > 201402L\n+      using node_type = typename _Base::node_type;\n+\n+      struct insert_return_type\n+      {\n+\tbool inserted;\n+\titerator position;\n+\tnode_type node;\n+      };\n \n+      node_type\n+      extract(const_iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\t_Base_const_iterator __victim = __position.base();\n+\tthis->_M_invalidate_if(\n+\t    [__victim](_Base_const_iterator __it) { return __it == __victim; }\n+\t    );\n+\tthis->_M_invalidate_local_if(\n+\t    [__victim](_Base_const_local_iterator __it) {\n+\t\treturn __it._M_curr() == __victim._M_cur;\n+\t    });\n+\treturn _Base::extract(__position.base());\n+      }\n+\n+      node_type\n+      extract(const key_type& __key)\n+      {\n+\tconst auto __position = find(__key);\n+\tif (__position != end())\n+\t  return extract(__position);\n+\treturn {};\n+      }\n+\n+      insert_return_type\n+      insert(node_type&& __nh)\n+      {\n+\tauto __ret = _Base::insert(std::move(__nh));\n+\titerator __pos = iterator(__ret.position, this);\n+\treturn { __ret.inserted, __pos, std::move(__ret.node) };\n+      }\n+\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      {\n+\t__glibcxx_check_insert(__hint);\n+\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+      }\n+\n+      using _Base::merge;\n+#endif // C++17\n \n       iterator\n       find(const key_type& __key)\n@@ -913,6 +964,47 @@ namespace __debug\n \t  _M_check_rehashed(__bucket_count);\n \t}\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Base::node_type;\n+\n+      node_type\n+      extract(const_iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\t_Base_const_iterator __victim = __position.base();\n+\tthis->_M_invalidate_if(\n+\t    [__victim](_Base_const_iterator __it) { return __it == __victim; }\n+\t    );\n+\tthis->_M_invalidate_local_if(\n+\t    [__victim](_Base_const_local_iterator __it) {\n+\t\treturn __it._M_curr() == __victim._M_cur;\n+\t    });\n+\treturn _Base::extract(__position.base());\n+      }\n+\n+      node_type\n+      extract(const key_type& __key)\n+      {\n+\tconst auto __position = find(__key);\n+\tif (__position != end())\n+\t  return extract(__position);\n+\treturn {};\n+      }\n+\n+      iterator\n+      insert(node_type&& __nh)\n+      { return iterator(_Base::insert(std::move(__nh)), this); }\n+\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      {\n+\t__glibcxx_check_insert(__hint);\n+\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+      }\n+\n+      using _Base::merge;\n+#endif // C++17\n+\n       iterator\n       find(const key_type& __key)\n       { return iterator(_Base::find(__key), this); }"}, {"sha": "f8587c06bfc7bcb5f132327cc332c515aac77827", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -370,6 +370,58 @@ namespace __debug\n \t  _M_check_rehashed(__bucket_count);\n \t}\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Base::node_type;\n+\n+      struct insert_return_type\n+      {\n+\tbool inserted;\n+\titerator position;\n+\tnode_type node;\n+      };\n+\n+      node_type\n+      extract(const_iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\t_Base_const_iterator __victim = __position.base();\n+\tthis->_M_invalidate_if(\n+\t    [__victim](_Base_const_iterator __it) { return __it == __victim; }\n+\t    );\n+\tthis->_M_invalidate_local_if(\n+\t    [__victim](_Base_const_local_iterator __it) {\n+\t\treturn __it._M_curr() == __victim._M_cur;\n+\t    });\n+\treturn _Base::extract(__position.base());\n+      }\n+\n+      node_type\n+      extract(const key_type& __key)\n+      {\n+\tconst auto __position = find(__key);\n+\tif (__position != end())\n+\t  return extract(__position);\n+\treturn {};\n+      }\n+\n+      insert_return_type\n+      insert(node_type&& __nh)\n+      {\n+\tauto __ret = _Base::insert(std::move(__nh));\n+\titerator __pos = iterator(__ret.position, this);\n+\treturn { __ret.inserted, __pos, std::move(__ret.node) };\n+      }\n+\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      {\n+\t__glibcxx_check_insert(__hint);\n+\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+      }\n+\n+      using _Base::merge;\n+#endif // C++17\n+\n       iterator\n       find(const key_type& __key)\n       { return iterator(_Base::find(__key), this); }\n@@ -821,6 +873,47 @@ namespace __debug\n \t  _M_check_rehashed(__bucket_count);\n \t}\n \n+#if __cplusplus > 201402L\n+      using node_type = typename _Base::node_type;\n+\n+      node_type\n+      extract(const_iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\t_Base_const_iterator __victim = __position.base();\n+\tthis->_M_invalidate_if(\n+\t    [__victim](_Base_const_iterator __it) { return __it == __victim; }\n+\t    );\n+\tthis->_M_invalidate_local_if(\n+\t    [__victim](_Base_const_local_iterator __it) {\n+\t\treturn __it._M_curr() == __victim._M_cur;\n+\t    });\n+\treturn _Base::extract(__position.base());\n+      }\n+\n+      node_type\n+      extract(const key_type& __key)\n+      {\n+\tconst auto __position = find(__key);\n+\tif (__position != end())\n+\t  return extract(__position);\n+\treturn {};\n+      }\n+\n+      iterator\n+      insert(node_type&& __nh)\n+      { return iterator(_Base::insert(std::move(__nh)), this); }\n+\n+      iterator\n+      insert(const_iterator __hint, node_type&& __nh)\n+      {\n+\t__glibcxx_check_insert(__hint);\n+\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+      }\n+\n+      using _Base::merge;\n+#endif // C++17\n+\n       iterator\n       find(const key_type& __key)\n       { return iterator(_Base::find(__key), this); }"}, {"sha": "b5fc2a02aa5a7add19b53270ad7cc2adb874eba9", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -130,6 +130,10 @@ def to_string (self):\n         return ('std::unique_ptr<%s> containing %s' % (str(v.type.target()),\n                                                        str(v)))\n \n+def get_value_from_aligned_membuf(buf, valtype):\n+    \"\"\"Returns the value held in a __gnu_cxx::__aligned_membuf.\"\"\"\n+    return buf['_M_storage'].address.cast(valtype.pointer()).dereference()\n+\n def get_value_from_list_node(node):\n     \"\"\"Returns the value held in an _List_node<_Val>\"\"\"\n     try:\n@@ -139,9 +143,8 @@ def get_value_from_list_node(node):\n             return node['_M_data']\n         elif member == '_M_storage':\n             # C++11 implementation, node stores value in __aligned_membuf\n-            p = node['_M_storage']['_M_storage'].address\n-            p = p.cast(node.type.template_argument(0).pointer())\n-            return p.dereference()\n+            valtype = node.type.template_argument(0)\n+            return get_value_from_aligned_membuf(node['_M_storage'], valtype)\n     except:\n         pass\n     raise ValueError(\"Unsupported implementation for %s\" % str(node.type))\n@@ -461,9 +464,8 @@ def get_value_from_Rb_tree_node(node):\n             return node['_M_value_field']\n         elif member == '_M_storage':\n             # C++11 implementation, node stores value in __aligned_membuf\n-            p = node['_M_storage']['_M_storage'].address\n-            p = p.cast(node.type.template_argument(0).pointer())\n-            return p.dereference()\n+            valtype = node.type.template_argument(0)\n+            return get_value_from_aligned_membuf(node['_M_storage'], valtype)\n     except:\n         pass\n     raise ValueError(\"Unsupported implementation for %s\" % str(node.type))\n@@ -1017,6 +1019,48 @@ def to_string(self):\n             return \"%s [index %d] containing %s\" % (self.typename, self.index, self.visualizer.to_string())\n         return \"%s [index %d]\" % (self.typename, self.index)\n \n+class StdNodeHandlePrinter(SingleObjContainerPrinter):\n+    \"Print a container node handle\"\n+\n+    def __init__(self, typename, val):\n+        self.value_type = val.type.template_argument(1)\n+        nodetype = val.type.template_argument(2).template_argument(0)\n+        self.is_rb_tree_node = nodetype.name.startswith('std::_Rb_tree_node')\n+        self.is_map_node = val.type.template_argument(0) != self.value_type\n+        nodeptr = val['_M_ptr']\n+        if nodeptr:\n+            if self.is_rb_tree_node:\n+                contained_value = get_value_from_Rb_tree_node(nodeptr.dereference())\n+            else:\n+                contained_value = get_value_from_aligned_membuf(nodeptr['_M_storage'],\n+                                                                self.value_type)\n+            visualizer = gdb.default_visualizer(contained_value)\n+        else:\n+            contained_value = None\n+            visualizer = None\n+        optalloc = val['_M_alloc']\n+        self.alloc = optalloc['_M_payload'] if optalloc['_M_engaged'] else None\n+        super(StdNodeHandlePrinter, self).__init__(contained_value, visualizer,\n+                                                   'array')\n+\n+    def to_string(self):\n+\n+        desc = 'node handle for '\n+        if not self.is_rb_tree_node:\n+            desc += 'unordered '\n+        if self.is_map_node:\n+            desc += 'map';\n+        else:\n+            desc += 'set';\n+\n+        if self.contained_value:\n+            desc += ' with element'\n+            if hasattr(self.visualizer, 'children'):\n+                return \"%s = %s\" % (desc, self.visualizer.to_string())\n+            return desc\n+        else:\n+            return 'empty %s' % desc\n+\n class StdExpStringViewPrinter:\n     \"Print a std::basic_string_view or std::experimental::basic_string_view\"\n \n@@ -1491,6 +1535,8 @@ def build_libstdcxx_dictionary ():\n                                   'basic_string_view', StdExpStringViewPrinter)\n     libstdcxx_printer.add_version('std::',\n                                   'variant', StdVariantPrinter)\n+    libstdcxx_printer.add_version('std::',\n+                                  '_Node_handle', StdNodeHandlePrinter)\n \n     # Extensions.\n     libstdcxx_printer.add_version('__gnu_cxx::', 'slist', StdSlistPrinter)"}, {"sha": "dbbcc803ba7fa5dc26720158abd71e1da790f823", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/extract.cc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fextract.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fextract.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fextract.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,147 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <map>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::map<int, int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ {1, 10}, {2, 20}, {3, 30} };\n+  test_type::node_type node;\n+  test_type::insert_return_type ins;\n+  test_type::iterator pos;\n+\n+  node = c.extract(0);\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( !ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position == c.end() );\n+\n+  node = c.extract(1);\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 2 );\n+  VERIFY( c.count(1) == 0 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.key() == 1 );\n+  VERIFY( node.mapped() == 10 );\n+\n+  node.key() = 4;\n+  node.mapped() = 40;\n+  VERIFY( node.key() == 4 );\n+  VERIFY( node.mapped() == 40 );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( ins.position->first == 4 );\n+  VERIFY( ins.position->second == 40 );\n+  VERIFY( c.count(1) == 0 );\n+  VERIFY( c.count(4) == 1 );\n+  VERIFY( std::is_sorted(c.begin(), c.end()) );\n+\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( pos == c.end() );\n+\n+  node = c.extract(2);\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( c.size() == 3 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( pos->first == 2 );\n+  VERIFY( pos->second == 20 );\n+\n+  test_type c2 = c;\n+  node = c2.extract(3);\n+  ins = c.insert(std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( !ins.inserted );\n+  VERIFY( !ins.node.empty() );\n+  VERIFY( ins.node.key() == 3 );\n+  VERIFY( ins.node.mapped() == 30 );\n+  VERIFY( ins.position->first == ins.node.key() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ {1, 10}, {2, 20}, {3, 30} };\n+  test_type::node_type node;\n+  test_type::insert_return_type ins;\n+\n+  node = c.extract(c.begin());\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 2 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.key() == 1 );\n+  VERIFY( node.mapped() == 10 );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( ins.position->first == 1 );\n+  VERIFY( ins.position->second == 10 );\n+}\n+\n+void\n+test03()\n+{\n+  struct less : std::less<int> { };\n+  using std::is_same_v;\n+  using compat_type1 = std::map<int, int, less>;\n+  static_assert( is_same_v<test_type::node_type, compat_type1::node_type> );\n+  using compat_type2 = std::multimap<int, int>;\n+  static_assert( is_same_v<test_type::node_type, compat_type2::node_type> );\n+  using compat_type3 = std::multimap<int, int, less>;\n+  static_assert( is_same_v<test_type::node_type, compat_type3::node_type> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "c978ed21e0725860aa445a734ed4cc1d4159a0d3", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/merge.cc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fmerge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fmerge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fmerge.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,147 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <map>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::map<int, int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {2, 20}, {3, 30} };\n+  test_type c1 = c0, c2 = c0;\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2 == c0 );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(std::move(c1));\n+  VERIFY( c1.empty() );\n+  VERIFY( c2 == c0 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {2, 20}, {3, 30} };\n+  test_type c1 = c0;\n+  std::map<int, int, std::less<>> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( std::equal(c2.begin(), c2.end(), c0.begin(), c0.end()) );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(std::move(c1));\n+  VERIFY( c1.empty() );\n+  VERIFY( std::equal(c2.begin(), c2.end(), c0.begin(), c0.end()) );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {2, 20}, {3, 30} };\n+  test_type c1 = c0;\n+  std::map<int, int, std::greater<>> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test04()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {2, 20}, {3, 30} };\n+  test_type c1 = c0;\n+  std::multimap<int, int, std::greater<>> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1 = c0;\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( c2.size() == (2 * c0.size()) );\n+  VERIFY( std::is_sorted(c2.begin(), c2.end(), c2.value_comp()) );\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1.clear();\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "cad131ceadf24b35fd7f04da0175bae95c7e32b7", "filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/extract.cc", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fextract.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fextract.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fextract.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,141 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <map>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::multimap<int, int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ {1, 10}, { 1, 11 }, {2, 20}, { 2, 21}, {3, 30}, { 3, 31 } };\n+  test_type::node_type node;\n+  test_type::iterator pos;\n+\n+  node = c.extract(0);\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+\n+  pos = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos == c.end() );\n+\n+  node = c.extract(1);\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 5 );\n+  VERIFY( c.count(1) == 1 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.key() == 1 );\n+  int mapped = node.mapped();\n+  VERIFY( mapped == 10 || mapped == 11 );\n+\n+  node.key() = 4;\n+  node.mapped() = 40;\n+  VERIFY( node.key() == 4 );\n+  VERIFY( node.mapped() == 40 );\n+\n+  pos = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( pos->first == 4 );\n+  VERIFY( pos->second == 40 );\n+  VERIFY( c.count(1) == 1 );\n+  VERIFY( c.count(4) == 1 );\n+  VERIFY( std::is_sorted(c.begin(), c.end()) );\n+\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos == c.end() );\n+\n+  node = c.extract(1);\n+  mapped = node.mapped();\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( pos->first == 1 );\n+  VERIFY( pos->second == mapped );\n+\n+  test_type c2 = c;\n+  node = c2.extract(1);\n+  mapped = node.mapped();\n+  pos = c.insert(std::move(node));\n+  VERIFY( pos != c.end() );\n+  VERIFY( node.empty() );\n+  VERIFY( pos->first == 1 );\n+  VERIFY( pos->second == mapped );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ {1, 10}, { 1, 11 }, {2, 20}, { 2, 21}, {3, 30}, { 3, 31 } };\n+  test_type::node_type node;\n+  test_type::iterator pos;\n+\n+  node = c.extract(c.begin());\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 5 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.key() == 1 );\n+  VERIFY( node.mapped() == 10 );\n+\n+  pos = c.insert(std::next(c.begin()), std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( pos->first == 1 );\n+  VERIFY( pos->second == 10 );\n+  VERIFY( pos == std::next(c.begin()) );\n+}\n+\n+void\n+test03()\n+{\n+  struct less : std::less<int> { };\n+  using std::is_same_v;\n+  using compat_type1 = std::multimap<int, int, less>;\n+  static_assert( is_same_v<test_type::node_type, compat_type1::node_type> );\n+  using compat_type2 = std::map<int, int>;\n+  static_assert( is_same_v<test_type::node_type, compat_type2::node_type> );\n+  using compat_type3 = std::map<int, int, less>;\n+  static_assert( is_same_v<test_type::node_type, compat_type3::node_type> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "70541ff7fbe12031f84f49e69d49744e02925d9a", "filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/merge.cc", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fmerge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fmerge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fmerge.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,119 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <map>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::multimap<int, int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {1, 11}, {2, 20}, {2, 21}, {3, 30}, {3, 31} };\n+  test_type c1 = c0, c2 = c0;\n+\n+  c1.merge(c2);\n+  for (auto& i : c1)\n+    VERIFY( c1.count(i.first) == (2 * c0.count(i.first)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2 = c0;\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {1, 11}, {2, 20}, {2, 21}, {3, 30}, {3, 31} };\n+  test_type c1 = c0;\n+  std::multimap<int, int, std::less<>> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (2 * c0.size()) );\n+  for (auto& i : c1)\n+    VERIFY( c1.count(i.first) == (2 * c0.count(i.first)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {1, 11}, {2, 20}, {2, 21}, {3, 30}, {3, 31} };\n+  test_type c1 = c0;\n+  std::multimap<int, int, std::greater<>> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (2 * c0.size()) );\n+  for (auto& i : c1)\n+    VERIFY( c1.count(i.first) == (2 * c0.count(i.first)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test04()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {1, 11}, {2, 20}, {2, 21}, {3, 30}, {3, 31} };\n+  test_type c1 = c0;\n+  std::map<int, int, std::greater<>> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (1.5 * c0.size()) );\n+  for (auto& i : c1)\n+    VERIFY( c1.count(i.first) == (1.5 * c0.count(i.first)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1.size() == (0.5 * c0.size()) );\n+  VERIFY( c2.empty() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "56c2a286f45a09d5eeaf91cded67df35b3e5cf29", "filename": "libstdc++-v3/testsuite/23_containers/multiset/modifiers/extract.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fextract.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fextract.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fextract.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,129 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <set>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::multiset<int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ 1, 1, 2, 2, 3, 3 };\n+  test_type::node_type node;\n+  test_type::iterator pos;\n+\n+  node = c.extract(0);\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+\n+  pos = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos == c.end() );\n+\n+  node = c.extract(1);\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 5 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.value() == 1 );\n+\n+  node.value() = 4;\n+  VERIFY( node.value() == 4 );\n+\n+  pos = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( *pos == 4 );\n+  VERIFY( c.count(1) == 1 );\n+  VERIFY( c.count(4) == 1 );\n+  VERIFY( std::is_sorted(c.begin(), c.end()) );\n+\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos == c.end() );\n+\n+  node = c.extract(1);\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( *pos == 1 );\n+\n+  test_type c2 = c;\n+  node = c2.extract(1);\n+  pos = c.insert(std::move(node));\n+  VERIFY( pos != c.end() );\n+  VERIFY( node.empty() );\n+  VERIFY( *pos == 1 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ 1, 1, 2, 2, 3, 3 };\n+  test_type::node_type node;\n+  test_type::iterator pos;\n+\n+  node = c.extract(c.begin());\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 5 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.value() == 1 );\n+\n+  pos = c.insert(std::next(c.begin()), std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( *pos == 1 );\n+  VERIFY( pos == std::next(c.begin()) );\n+}\n+\n+void\n+test03()\n+{\n+  struct less : std::less<int> { };\n+  using std::is_same_v;\n+  using compat_type1 = std::multiset<int, less>;\n+  static_assert( is_same_v<test_type::node_type, compat_type1::node_type> );\n+  using compat_type2 = std::set<int>;\n+  static_assert( is_same_v<test_type::node_type, compat_type2::node_type> );\n+  using compat_type3 = std::set<int, less>;\n+  static_assert( is_same_v<test_type::node_type, compat_type3::node_type> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "ba422b889c4a055a60cabed8e71aa14dd6c98ce1", "filename": "libstdc++-v3/testsuite/23_containers/multiset/modifiers/merge.cc", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fmerge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fmerge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fmerge.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,117 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <set>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::multiset<int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c0{ 1, 1, 2, 2, 3, 3 };\n+  test_type c1 = c0, c2 = c0;\n+\n+  c1.merge(c2);\n+  for (auto i : c1)\n+    VERIFY( c1.count(i) == (2 * c0.count(i)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2 = c0;\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c0{ 1, 1, 2, 2, 3, 3 };\n+  test_type c1 = c0;\n+  std::multiset<int, std::less<>> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (2 * c0.size()) );\n+  for (auto i : c1)\n+    VERIFY( c1.count(i) == (2 * c0.count(i)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test03()\n+{\n+  const test_type c0{ 1, 1, 2, 2, 3, 3 };\n+  test_type c1 = c0;\n+  std::multiset<int, std::greater<>> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (2 * c0.size()) );\n+  for (auto i : c1)\n+    VERIFY( c1.count(i) == (2 * c0.count(i)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test04()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ 1, 1, 2, 2, 3, 3 };\n+  test_type c1 = c0;\n+  std::set<int, std::greater<>> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (1.5 * c0.size()) );\n+  for (auto& i : c1)\n+    VERIFY( c1.count(i) == (1.5 * c0.count(i)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1.size() == (0.5 * c0.size()) );\n+  VERIFY( c2.empty() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "db5872a499a9ab9b18a1221cb782e9dea63028d8", "filename": "libstdc++-v3/testsuite/23_containers/set/modifiers/extract.cc", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fextract.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fextract.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fextract.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,138 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <set>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::set<int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ 1, 2, 3 };\n+  test_type::node_type node;\n+  test_type::insert_return_type ins;\n+  test_type::iterator pos;\n+\n+  node = c.extract(0);\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( !ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position == c.end() );\n+\n+  node = c.extract(1);\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 2 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.value() == 1 );\n+\n+  node.value() = 4;\n+  VERIFY( node.value() == 4 );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( *ins.position == 4 );\n+  VERIFY( c.count(1) == 0 );\n+  VERIFY( c.count(4) == 1 );\n+  VERIFY( std::is_sorted(c.begin(), c.end()) );\n+\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( pos == c.end() );\n+\n+  node = c.extract(2);\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( c.size() == 3 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( *pos == 2 );\n+\n+  test_type c2 = c;\n+  node = c2.extract(3);\n+  ins = c.insert(std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( !ins.inserted );\n+  VERIFY( !ins.node.empty() );\n+  VERIFY( ins.node.value() == 3 );\n+  VERIFY( *ins.position == ins.node.value() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ 1, 2, 3 };\n+  test_type::node_type node;\n+  test_type::insert_return_type ins;\n+\n+  node = c.extract(c.begin());\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 2 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.value() == 1 );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( *ins.position == 1 );\n+}\n+\n+void\n+test03()\n+{\n+  struct less : std::less<int> { };\n+  using std::is_same_v;\n+  using compat_type1 = std::set<int, less>;\n+  static_assert( is_same_v<test_type::node_type, compat_type1::node_type> );\n+  using compat_type2 = std::multiset<int>;\n+  static_assert( is_same_v<test_type::node_type, compat_type2::node_type> );\n+  using compat_type3 = std::multiset<int, less>;\n+  static_assert( is_same_v<test_type::node_type, compat_type3::node_type> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "b1e06937b647e1f2f2e7b764f3bc33bc191c9db6", "filename": "libstdc++-v3/testsuite/23_containers/set/modifiers/merge.cc", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fmerge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fmerge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fmerge.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,143 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <set>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::set<int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ 1, 2, 3 };\n+  test_type c1 = c0, c2 = c0;\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2 == c0 );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(std::move(c1));\n+  VERIFY( c1.empty() );\n+  VERIFY( c2 == c0 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ 1, 2, 3 };\n+  test_type c1 = c0;\n+  std::set<int, std::less<>> c2( c0.begin(), c0.end() );\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( std::equal(c2.begin(), c2.end(), c0.begin(), c0.end()) );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(std::move(c1));\n+  VERIFY( c1.empty() );\n+  VERIFY( std::equal(c2.begin(), c2.end(), c0.begin(), c0.end()) );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ 1, 2, 3 };\n+  test_type c1 = c0;\n+  std::set<int, std::greater<>> c2( c0.begin(), c0.end() );\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test04()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ 1, 2, 3 };\n+  test_type c1 = c0;\n+  std::multiset<int, std::greater<>> c2( c0.begin(), c0.end() );\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1 = c0;\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( c2.size() == (2 * c0.size()) );\n+  VERIFY( std::is_sorted(c2.begin(), c2.end(), c2.value_comp()) );\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( std::equal(c2.rbegin(), c2.rend(), c0.begin(), c0.end()) );\n+\n+  c1.clear();\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "9d9c43ef9054a0d7b6c99fcc1169a2e5c0cda0e8", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/extract.cc", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Fextract.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Fextract.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Fextract.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,148 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::unordered_map<int, int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ {1, 10}, {2, 20}, {3, 30} };\n+  test_type::node_type node;\n+  test_type::insert_return_type ins;\n+  test_type::iterator pos;\n+\n+  node = c.extract(0);\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( !ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position == c.end() );\n+\n+  node = c.extract(1);\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 2 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.key() == 1 );\n+  VERIFY( node.mapped() == 10 );\n+\n+  node.key() = 4;\n+  node.mapped() = 40;\n+  VERIFY( node.key() == 4 );\n+  VERIFY( node.mapped() == 40 );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( ins.position->first == 4 );\n+  VERIFY( ins.position->second == 40 );\n+  VERIFY( c.count(1) == 0 );\n+  VERIFY( c.count(4) == 1 );\n+\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( pos == c.end() );\n+\n+  pos = c.insert(c.begin(), c.extract(2));\n+  VERIFY( c.size() == 3 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( pos->first == 2 );\n+  VERIFY( pos->second == 20 );\n+\n+  test_type c2 = c;\n+  node = c2.extract(3);\n+  ins = c.insert(std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( !ins.inserted );\n+  VERIFY( !ins.node.empty() );\n+  VERIFY( ins.node.key() == 3 );\n+  VERIFY( ins.node.mapped() == 30 );\n+  auto hasher = c.hash_function();\n+  VERIFY( hasher(ins.position->first) == hasher(ins.node.key()) );\n+  auto eq = c.key_eq();\n+  VERIFY( eq(ins.position->first, ins.node.key()) );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ {1, 10}, {2, 20}, {3, 30} };\n+  test_type::node_type node;\n+  test_type::insert_return_type ins;\n+\n+  const int key = c.begin()->first;\n+  node = c.extract(c.begin());\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 2 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.key() == key );\n+  VERIFY( node.mapped() == (key * 10) );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( ins.position->first == key );\n+  VERIFY( ins.position->second == (key * 10) );\n+}\n+\n+void\n+test03()\n+{\n+  struct hash : std::hash<int> { };\n+  struct equal : std::equal_to<int> { };\n+  using std::is_same_v;\n+  using compat_type1 = std::unordered_map<int, int, hash, equal>;\n+  static_assert( is_same_v<test_type::node_type, compat_type1::node_type> );\n+  using compat_type2 = std::unordered_multimap<int, int>;\n+  static_assert( is_same_v<test_type::node_type, compat_type2::node_type> );\n+  using compat_type3 = std::unordered_multimap<int, int, hash, equal>;\n+  static_assert( is_same_v<test_type::node_type, compat_type3::node_type> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "f0035d2eb84f5896a301b2ac1697a42aef6d5e31", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/merge.cc", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Fmerge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Fmerge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Fmerge.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,140 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <unordered_map>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::unordered_map<int, int>;\n+\n+struct hash {\n+  auto operator()(int i) const noexcept { return ~std::hash<int>()(i); }\n+};\n+struct equal : std::equal_to<> { };\n+\n+template<typename C1, typename C2>\n+bool equal_elements(const C1& c1, const C2& c2)\n+{\n+  if (c2.size() != c1.size())\n+    return false;\n+  for (auto& i : c1)\n+    if (c2.count(i.first) != c1.count(i.first))\n+      return false;\n+  return true;\n+}\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {2, 20}, {3, 30} };\n+  test_type c1 = c0, c2 = c0;\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2 == c0 );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(std::move(c1));\n+  VERIFY( c1.empty() );\n+  VERIFY( c2 == c0 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {2, 20}, {3, 30} };\n+  test_type c1 = c0;\n+  std::unordered_map<int, int, hash, equal> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.merge(std::move(c2));\n+  VERIFY( c2.empty() );\n+  VERIFY( c1 == c0 );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {2, 20}, {3, 30} };\n+  test_type c1 = c0;\n+  std::unordered_multimap<int, int, hash, equal> c2( c0.begin(), c0.end() );\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1 = c0;\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( c2.size() == (2 * c0.size()) );\n+  VERIFY( c2.count(1) == 2 );\n+  VERIFY( c2.count(2) == 2 );\n+  VERIFY( c2.count(3) == 2 );\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.clear();\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "635e7d0acd3e4a20f3237ff602a7fe7c203714ba", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/modifiers/extract.cc", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2Fextract.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2Fextract.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2Fextract.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,138 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::unordered_multimap<int, int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ {1, 10}, { 1, 11 }, {2, 20}, { 2, 21}, {3, 30}, { 3, 31 } };\n+  test_type::node_type node;\n+  test_type::iterator pos;\n+\n+  node = c.extract(0);\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+\n+  pos = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos == c.end() );\n+\n+  node = c.extract(1);\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 5 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.key() == 1 );\n+  int mapped = node.mapped();\n+  VERIFY( mapped == 10 || mapped == 11 );\n+\n+  node.key() = 4;\n+  node.mapped() = 40;\n+  VERIFY( node.key() == 4 );\n+  VERIFY( node.mapped() == 40 );\n+\n+  pos = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( pos->first == 4 );\n+  VERIFY( pos->second == 40 );\n+\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos == c.end() );\n+\n+  node = c.extract(1);\n+  mapped = node.mapped();\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( pos->first == 1 );\n+  VERIFY( pos->second == mapped );\n+\n+  test_type c2 = c;\n+  node = c2.extract(1);\n+  mapped = node.mapped();\n+  pos = c.insert(std::move(node));\n+  VERIFY( pos != c.end() );\n+  VERIFY( node.empty() );\n+  VERIFY( pos->first == 1 );\n+  VERIFY( pos->second == mapped );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ {1, 10}, { 1, 11 }, {2, 20}, { 2, 21}, {3, 30}, { 3, 31 } };\n+  test_type::node_type node;\n+  test_type::iterator pos;\n+\n+  const int key = c.begin()->first;\n+  const int mapped = c.begin()->second;\n+  node = c.extract(c.begin());\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 5 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.key() == key );\n+  VERIFY( node.mapped() == mapped );\n+\n+  pos = c.insert(std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( pos->first == key );\n+  VERIFY( pos->second == mapped );\n+}\n+\n+void\n+test03()\n+{\n+  struct hash : std::hash<int> { };\n+  struct equal : std::equal_to<int> { };\n+  using std::is_same_v;\n+  using compat_type1 = std::unordered_multimap<int, int, hash, equal>;\n+  static_assert( is_same_v<test_type::node_type, compat_type1::node_type> );\n+  using compat_type2 = std::unordered_map<int, int>;\n+  static_assert( is_same_v<test_type::node_type, compat_type2::node_type> );\n+  using compat_type3 = std::unordered_map<int, int, hash, equal>;\n+  static_assert( is_same_v<test_type::node_type, compat_type3::node_type> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "3c67e3c28dae9fb7d6c8fc38c1e66d45681f2c74", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/modifiers/merge.cc", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2Fmerge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2Fmerge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2Fmerge.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,123 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <unordered_map>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::unordered_multimap<int, int>;\n+struct hash {\n+  auto operator()(int i) const noexcept { return ~std::hash<int>()(i); }\n+};\n+struct equal : std::equal_to<> { };\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {1, 11}, {2, 20}, {2, 21}, {3, 30}, {3, 31} };\n+  test_type c1 = c0, c2 = c0;\n+\n+  c1.merge(c2);\n+  for (auto& i : c1)\n+    VERIFY( c1.count(i.first) == (2 * c0.count(i.first)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2 = c0;\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {1, 11}, {2, 20}, {2, 21}, {3, 30}, {3, 31} };\n+  test_type c1 = c0;\n+  std::unordered_multimap<int, int, hash, equal> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (2 * c0.size()) );\n+  for (auto& i : c1)\n+    VERIFY( c1.count(i.first) == (2 * c0.count(i.first)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {1, 11}, {2, 20}, {2, 21}, {3, 30}, {3, 31} };\n+  test_type c1 = c0;\n+  std::unordered_multimap<int, int, hash, equal> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (2 * c0.size()) );\n+  for (auto& i : c1)\n+    VERIFY( c1.count(i.first) == (2 * c0.count(i.first)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test04()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ {1, 10}, {1, 11}, {2, 20}, {2, 21}, {3, 30}, {3, 31} };\n+  test_type c1 = c0;\n+  std::unordered_map<int, int, hash, equal> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (1.5 * c0.size()) );\n+  for (auto& i : c1)\n+    VERIFY( c1.count(i.first) == (1.5 * c0.count(i.first)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1.size() == (0.5 * c0.size()) );\n+  VERIFY( c2.empty() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "e703dc41ca0b1a2ea1abe6361096094f1c18e434", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/modifiers/extract.cc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Fextract.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Fextract.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Fextract.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,128 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::unordered_multiset<int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ 1, 1, 2, 2, 3, 3 };\n+  test_type::node_type node;\n+  test_type::iterator pos;\n+\n+  node = c.extract(0);\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+\n+  pos = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos == c.end() );\n+\n+  node = c.extract(1);\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 5 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.value() == 1 );\n+\n+  node.value() = 4;\n+  VERIFY( node.value() == 4 );\n+\n+  pos = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( *pos == 4 );\n+  VERIFY( c.count(1) == 1 );\n+  VERIFY( c.count(4) == 1 );\n+\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos == c.end() );\n+\n+  node = c.extract(1);\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( *pos == 1 );\n+\n+  test_type c2 = c;\n+  node = c2.extract(1);\n+  pos = c.insert(std::move(node));\n+  VERIFY( pos != c.end() );\n+  VERIFY( node.empty() );\n+  VERIFY( *pos == 1 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ 1, 1, 2, 2, 3, 3 };\n+  test_type::node_type node;\n+  test_type::iterator pos;\n+\n+  const int val = *c.begin();\n+  node = c.extract(c.begin());\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 5 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.value() == val );\n+\n+  pos = c.insert(std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 6 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( *pos == val );\n+}\n+\n+void\n+test03()\n+{\n+  struct hash : std::hash<int> { };\n+  struct equal : std::equal_to<int> { };\n+  using std::is_same_v;\n+  using compat_type1 = std::unordered_multiset<int, hash, equal>;\n+  static_assert( is_same_v<test_type::node_type, compat_type1::node_type> );\n+  using compat_type2 = std::unordered_set<int>;\n+  static_assert( is_same_v<test_type::node_type, compat_type2::node_type> );\n+  using compat_type3 = std::unordered_set<int, hash, equal>;\n+  static_assert( is_same_v<test_type::node_type, compat_type3::node_type> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "4ce4b84d717f4bd7e5890ab0fb61b1bd23d22736", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/modifiers/merge.cc", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Fmerge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Fmerge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Fmerge.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,121 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <unordered_set>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::unordered_multiset<int>;\n+struct hash {\n+  auto operator()(int i) const noexcept { return ~std::hash<int>()(i); }\n+};\n+struct equal : std::equal_to<> { };\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c0{ 1, 1, 2, 2, 3, 3 };\n+  test_type c1 = c0, c2 = c0;\n+\n+  c1.merge(c2);\n+  for (auto i : c1)\n+    VERIFY( c1.count(i) == (2 * c0.count(i)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2 = c0;\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c0{ 1, 1, 2, 2, 3, 3 };\n+  test_type c1 = c0;\n+  std::unordered_multiset<int, hash, equal> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (2 * c0.size()) );\n+  for (auto i : c1)\n+    VERIFY( c1.count(i) == (2 * c0.count(i)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test03()\n+{\n+  const test_type c0{ 1, 1, 2, 2, 3, 3 };\n+  test_type c1 = c0;\n+  std::unordered_multiset<int, hash, equal> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (2 * c0.size()) );\n+  for (auto i : c1)\n+    VERIFY( c1.count(i) == (2 * c0.count(i)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+void\n+test04()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ 1, 1, 2, 2, 3, 3 };\n+  test_type c1 = c0;\n+  std::unordered_set<int, hash, equal> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (1.5 * c0.size()) );\n+  for (auto& i : c1)\n+    VERIFY( c1.count(i) == (1.5 * c0.count(i)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1.size() == (0.5 * c0.size()) );\n+  VERIFY( c2.empty() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "5e8de37c440703a0c393415d86c6dcb7f840988e", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/instantiation_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -18,7 +18,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"with noexcept\" \"\" { target *-*-* } 265 }\n+// { dg-error \"with noexcept\" \"\" { target *-*-* } 268 }\n \n #include <unordered_set>\n "}, {"sha": "cb48cbcef4e05786a4c9dfacae0382a767e321a7", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/modifiers/extract.cc", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fextract.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fextract.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fextract.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,140 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::unordered_set<int>;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ 1, 2, 3 };\n+  test_type::node_type node;\n+  test_type::insert_return_type ins;\n+  test_type::iterator pos;\n+\n+  node = c.extract(0);\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( !ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position == c.end() );\n+\n+  node = c.extract(1);\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 2 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.value() == 1 );\n+\n+  node.value() = 4;\n+  VERIFY( node.value() == 4 );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( *ins.position == 4 );\n+  VERIFY( c.count(1) == 0 );\n+  VERIFY( c.count(4) == 1 );\n+\n+  pos = c.insert(c.begin(), std::move(node));\n+  VERIFY( !node );\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( pos == c.end() );\n+\n+  pos = c.insert(c.begin(), c.extract(2));\n+  VERIFY( c.size() == 3 );\n+  VERIFY( pos != c.end() );\n+  VERIFY( *pos == 2 );\n+\n+  test_type c2 = c;\n+  node = c2.extract(3);\n+  ins = c.insert(std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( !ins.inserted );\n+  VERIFY( !ins.node.empty() );\n+  VERIFY( ins.node.value() == 3 );\n+  auto hasher = c.hash_function();\n+  VERIFY( hasher(*ins.position) == hasher(ins.node.value()) );\n+  auto eq = c.key_eq();\n+  VERIFY( eq(*ins.position, ins.node.value()) );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  test_type c{ 1, 2, 3 };\n+  test_type::node_type node;\n+  test_type::insert_return_type ins;\n+\n+  const int val = *c.begin();\n+  node = c.extract(c.begin());\n+  VERIFY( (bool)node );\n+  VERIFY( !node.empty() );\n+  VERIFY( c.size() == 2 );\n+  VERIFY( node.get_allocator() == c.get_allocator() );\n+  VERIFY( node.value() == val );\n+\n+  ins = c.insert(std::move(node));\n+  VERIFY( node.empty() );\n+  VERIFY( c.size() == 3 );\n+  VERIFY( ins.inserted );\n+  VERIFY( !ins.node );\n+  VERIFY( ins.position != c.end() );\n+  VERIFY( *ins.position == val );\n+}\n+\n+void\n+test03()\n+{\n+  struct hash : std::hash<int> { };\n+  struct equal : std::equal_to<int> { };\n+  using std::is_same_v;\n+  using compat_type1 = std::unordered_set<int, hash, equal>;\n+  static_assert( is_same_v<test_type::node_type, compat_type1::node_type> );\n+  using compat_type2 = std::unordered_multiset<int>;\n+  static_assert( is_same_v<test_type::node_type, compat_type2::node_type> );\n+  using compat_type3 = std::unordered_multiset<int, hash, equal>;\n+  static_assert( is_same_v<test_type::node_type, compat_type3::node_type> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "29387dd21f69126190559991f109ee63dce013de", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/modifiers/merge.cc", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fmerge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fmerge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fmerge.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -0,0 +1,140 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <unordered_set>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using test_type = std::unordered_set<int>;\n+\n+struct hash {\n+  auto operator()(int i) const noexcept { return ~std::hash<int>()(i); }\n+};\n+struct equal : std::equal_to<> { };\n+\n+template<typename C1, typename C2>\n+bool equal_elements(const C1& c1, const C2& c2)\n+{\n+  if (c2.size() != c1.size())\n+    return false;\n+  for (auto& i : c1)\n+    if (c2.count(i) != c1.count(i))\n+      return false;\n+  return true;\n+}\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ 1, 2, 3, };\n+  test_type c1 = c0, c2 = c0;\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2 == c0 );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(std::move(c1));\n+  VERIFY( c1.empty() );\n+  VERIFY( c2 == c0 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ 1, 2, 3, };\n+  test_type c1 = c0;\n+  std::unordered_set<int, hash, equal> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.merge(std::move(c2));\n+  VERIFY( c2.empty() );\n+  VERIFY( c1 == c0 );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const test_type c0{ 1, 2, 3, };\n+  test_type c1 = c0;\n+  std::unordered_multiset<int, hash, equal> c2( c0.begin(), c0.end() );\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1 = c0;\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( c2.size() == (2 * c0.size()) );\n+  VERIFY( c2.count(1) == 2 );\n+  VERIFY( c2.count(2) == 2 );\n+  VERIFY( c2.count(3) == 2 );\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.clear();\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "bc9b26a74f958b2351c6afec55010a6094ccafb6", "filename": "libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx17.cc", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fcxx17.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbe56bdfbf6c570cf23073f0c596da6bd1531c8/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fcxx17.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fcxx17.cc?ref=2dbe56bdfbf6c570cf23073f0c596da6bd1531c8", "patch": "@@ -27,12 +27,15 @@\n #include <string_view>\n #include <string>\n #include <map>\n+#include <unordered_set>\n #include <iostream>\n \n using std::any;\n using std::optional;\n using std::variant;\n using std::string_view;\n+using std::map;\n+using std::unordered_set;\n \n int\n main()\n@@ -83,10 +86,21 @@ main()\n // { dg-final { note-test v3 {std::variant<float, int, std::string_view> [index 1] = {3}} } }\n   variant<float, int, string_view> v4{ str };\n // { dg-final { note-test v4 {std::variant<float, int, std::string_view> [index 2] = {\"string\"}} } }\n-\n   variant<string_view&> vref{str};\n // { dg-final { note-test vref {std::variant<std::basic_string_view<char, std::char_traits<char> > &> [index 0] = {\"string\"}} } }\n \n+  map<int, string_view> m{ {1, \"one\"} };\n+  map<int, string_view>::node_type n0;\n+// { dg-final { note-test n0 {empty node handle for map}}}\n+  map<int, string_view>::node_type n1 = m.extract(1);\n+// { dg-final { note-test n1 {node handle for map with element = {{first = 1, second = \"two\"}}}}}\n+\n+  unordered_set<int> s{ 3, 4 };\n+  unordered_set<int>::node_type n2;\n+// { dg-final { note-test n2 {empty node handle for unordered set}}}\n+  unordered_set<int>::node_type n3 = s.extract(3);\n+// { dg-final { note-test n1 {node handle for unordered set with element = {3}}}}\n+\n   std::cout << \"\\n\";\n   return 0;\t\t\t// Mark SPOT\n }"}]}