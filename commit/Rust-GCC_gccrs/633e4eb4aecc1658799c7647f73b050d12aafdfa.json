{"sha": "633e4eb4aecc1658799c7647f73b050d12aafdfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMzZTRlYjRhZWNjMTY1ODc5OWM3NjQ3ZjczYjA1MGQxMmFhZmRmYQ==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2003-05-29T00:08:36Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2003-05-29T00:08:36Z"}, "message": "xtensa-protos.h (smalloffset_double_mem_p): Delete.\n\n        * config/xtensa/xtensa-protos.h (smalloffset_double_mem_p): Delete.\n        (xtensa_split_operand_pair): New proto.\n        * config/xtensa/xtensa.c (move_operand): Handle DFmode and DImode.\n        (smalloffset_double_mem_p): Delete.\n        (gen_float_relational, printx, print_operand, xtensa_va_arg):\n        Fix whitespace.\n        (xtensa_split_operand_pair): New.\n        (xtensa_dbx_register_number): Fix formatting.\n        * config/xtensa/xtensa.h (EXTRA_CONSTRAINT): Remove 'S' constraint.\n        * config/xtensa/xtensa.md (movdi, movdf): Force constants to memory\n        instead of splitting them into single-word moves.  Remove unnecessary\n        checks for reload_in_progress and reload_completed.\n        (movdi_internal, movdf_internal): Change to post-reload split patterns.\n        Add constraints to allow constant operands.\n        (movsf_internal): Allow CONST_INT operands.\n\nFrom-SVN: r67215", "tree": {"sha": "8f7556214a765d1d4d045594d3ee023ac5d2179b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f7556214a765d1d4d045594d3ee023ac5d2179b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/633e4eb4aecc1658799c7647f73b050d12aafdfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/633e4eb4aecc1658799c7647f73b050d12aafdfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/633e4eb4aecc1658799c7647f73b050d12aafdfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/633e4eb4aecc1658799c7647f73b050d12aafdfa/comments", "author": null, "committer": null, "parents": [{"sha": "358bdeeec758236bd004def191cdf947f88a45b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358bdeeec758236bd004def191cdf947f88a45b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/358bdeeec758236bd004def191cdf947f88a45b4"}], "stats": {"total": 337, "additions": 156, "deletions": 181}, "files": [{"sha": "3998831dc96ccc9c2e7d1c43f3ef6a4421ad4ca6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/633e4eb4aecc1658799c7647f73b050d12aafdfa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/633e4eb4aecc1658799c7647f73b050d12aafdfa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=633e4eb4aecc1658799c7647f73b050d12aafdfa", "patch": "@@ -1,3 +1,21 @@\n+2003-05-28  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* config/xtensa/xtensa-protos.h (smalloffset_double_mem_p): Delete.\n+\t(xtensa_split_operand_pair): New proto.\n+\t* config/xtensa/xtensa.c (move_operand): Handle DFmode and DImode.\n+\t(smalloffset_double_mem_p): Delete.\n+\t(gen_float_relational, printx, print_operand, xtensa_va_arg):\n+\tFix whitespace.\n+\t(xtensa_split_operand_pair): New.\n+\t(xtensa_dbx_register_number): Fix formatting.\n+\t* config/xtensa/xtensa.h (EXTRA_CONSTRAINT): Remove 'S' constraint.\n+\t* config/xtensa/xtensa.md (movdi, movdf): Force constants to memory\n+\tinstead of splitting them into single-word moves.  Remove unnecessary\n+\tchecks for reload_in_progress and reload_completed.\n+\t(movdi_internal, movdf_internal): Change to post-reload split patterns.\n+\tAdd constraints to allow constant operands.\n+\t(movsf_internal): Allow CONST_INT operands.\n+\n 2003-05-27  Danny Smith   <dannysmith@users.sourceforge.net>\n \n \t* config.gcc (i[34567]86-*-mingw32*): Add host makefile"}, {"sha": "7800f0f31776a286d642cea90f16b2181da272b7", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/633e4eb4aecc1658799c7647f73b050d12aafdfa/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/633e4eb4aecc1658799c7647f73b050d12aafdfa/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=633e4eb4aecc1658799c7647f73b050d12aafdfa", "patch": "@@ -54,7 +54,6 @@ extern int ubranch_operand PARAMS ((rtx, enum machine_mode));\n extern int call_insn_operand PARAMS ((rtx, enum machine_mode));\n extern int move_operand PARAMS ((rtx, enum machine_mode));\n extern int smalloffset_mem_p PARAMS ((rtx));\n-extern int smalloffset_double_mem_p PARAMS ((rtx));\n extern int constantpool_address_p PARAMS ((rtx));\n extern int constantpool_mem_p PARAMS ((rtx));\n extern int const_float_1_operand PARAMS ((rtx, enum machine_mode));\n@@ -67,6 +66,7 @@ extern void xtensa_expand_conditional_branch PARAMS ((rtx *, enum rtx_code));\n extern int xtensa_expand_conditional_move PARAMS ((rtx *, int));\n extern int xtensa_expand_scc PARAMS ((rtx *));\n extern int xtensa_expand_block_move PARAMS ((rtx *));\n+extern void xtensa_split_operand_pair PARAMS ((rtx *, enum machine_mode));\n extern int xtensa_emit_move_sequence PARAMS ((rtx *, enum machine_mode));\n extern bool xtensa_copy_incoming_a7 PARAMS ((rtx *, enum machine_mode));\n extern void xtensa_emit_block_move PARAMS ((rtx *, rtx *, int));"}, {"sha": "d3ec724b165ad675814edb265a9c45516623d9e0", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 95, "deletions": 42, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/633e4eb4aecc1658799c7647f73b050d12aafdfa/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/633e4eb4aecc1658799c7647f73b050d12aafdfa/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=633e4eb4aecc1658799c7647f73b050d12aafdfa", "patch": "@@ -599,19 +599,32 @@ move_operand (op, mode)\n       || memory_operand (op, mode))\n     return TRUE;\n \n-  if (mode == SFmode)\n-    return TARGET_CONST16 && CONSTANT_P (op);\n+  switch (mode)\n+    {\n+    case DFmode:\n+    case SFmode:\n+      return TARGET_CONST16 && CONSTANT_P (op);\n \n-  /* Accept CONSTANT_P_RTX, since it will be gone by CSE1 and\n-     result in 0/1.  */\n-  if (GET_CODE (op) == CONSTANT_P_RTX)\n-    return TRUE;\n+    case DImode:\n+    case SImode:\n+      if (TARGET_CONST16)\n+\treturn CONSTANT_P (op);\n+      /* fall through */\n \n-  if (GET_CODE (op) == CONST_INT && xtensa_simm12b (INTVAL (op)))\n-    return TRUE;\n+    case HImode:\n+    case QImode:\n+      /* Accept CONSTANT_P_RTX, since it will be gone by CSE1 and\n+\t result in 0/1.  */\n+      if (GET_CODE (op) == CONSTANT_P_RTX)\n+\treturn TRUE;\n+\n+      if (GET_CODE (op) == CONST_INT && xtensa_simm12b (INTVAL (op)))\n+\treturn TRUE;\n+      break;\n \n-  if (mode == SImode)\n-    return TARGET_CONST16 && CONSTANT_P (op);\n+    default:\n+      break;\n+    }\n \n   return FALSE;\n }\n@@ -640,16 +653,6 @@ smalloffset_mem_p (op)\n }\n \n \n-int\n-smalloffset_double_mem_p (op)\n-     rtx op;\n-{\n-  if (!smalloffset_mem_p (op))\n-    return FALSE;\n-  return smalloffset_mem_p (adjust_address (op, GET_MODE (op), 4));\n-}\n-\n-\n int\n constantpool_address_p (addr)\n      rtx addr;\n@@ -1014,7 +1017,7 @@ gen_float_relational (test_code, cmp0, cmp1)\n     case GT: reverse_regs = 1; invert = 0; gen_fn = gen_slt_sf; break;\n     case LT: reverse_regs = 0; invert = 0; gen_fn = gen_slt_sf; break;\n     case GE: reverse_regs = 1; invert = 0; gen_fn = gen_sle_sf; break;\n-    default: \n+    default:\n       fatal_insn (\"bad test\", gen_rtx (test_code, VOIDmode, cmp0, cmp1));\n       reverse_regs = 0; invert = 0; gen_fn = 0; /* avoid compiler warnings */\n     }\n@@ -1207,6 +1210,53 @@ xtensa_expand_scc (operands)\n }\n \n \n+/* Split OP[1] into OP[2,3] and likewise for OP[0] into OP[0,1].  MODE is\n+   for the output, i.e., the input operands are twice as big as MODE.  */\n+\n+void\n+xtensa_split_operand_pair (operands, mode)\n+     rtx operands[4];\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (operands[1]))\n+    {\n+    case REG:\n+      operands[3] = gen_rtx_REG (mode, REGNO (operands[1]) + 1);\n+      operands[2] = gen_rtx_REG (mode, REGNO (operands[1]));\n+      break;\n+\n+    case MEM:\n+      operands[3] = adjust_address (operands[1], mode, GET_MODE_SIZE (mode));\n+      operands[2] = adjust_address (operands[1], mode, 0);\n+      break;\n+\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+      split_double (operands[1], &operands[2], &operands[3]);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  switch (GET_CODE (operands[0]))\n+    {\n+    case REG:\n+      operands[1] = gen_rtx_REG (mode, REGNO (operands[0]) + 1);\n+      operands[0] = gen_rtx_REG (mode, REGNO (operands[0]));\n+      break;\n+\n+    case MEM:\n+      operands[1] = adjust_address (operands[0], mode, GET_MODE_SIZE (mode));\n+      operands[0] = adjust_address (operands[0], mode, 0);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+\n /* Emit insns to move operands[1] into operands[0].\n    Return 1 if we have written out everything that needs to be done to\n    do the move.  Otherwise, return 0 and the caller will emit the move\n@@ -1658,24 +1708,27 @@ xtensa_dbx_register_number (regno)\n      int regno;\n {\n   int first = -1;\n-  \n-  if (GP_REG_P (regno)) {\n-    regno -= GP_REG_FIRST;\n-    first = 0;\n-  }\n-  else if (BR_REG_P (regno)) {\n-    regno -= BR_REG_FIRST;\n-    first = 16;\n-  }\n-  else if (FP_REG_P (regno)) {\n-    regno -= FP_REG_FIRST;\n-    /* The current numbering convention is that TIE registers are\n-       numbered in libcc order beginning with 256.  We can't guarantee\n-       that the FP registers will come first, so the following is just\n-       a guess.  It seems like we should make a special case for FP\n-       registers and give them fixed numbers < 256.  */\n-    first = 256;\n-  }\n+\n+  if (GP_REG_P (regno))\n+    {\n+      regno -= GP_REG_FIRST;\n+      first = 0;\n+    }\n+  else if (BR_REG_P (regno))\n+    {\n+      regno -= BR_REG_FIRST;\n+      first = 16;\n+    }\n+  else if (FP_REG_P (regno))\n+    {\n+      regno -= FP_REG_FIRST;\n+      /* The current numbering convention is that TIE registers are\n+\t numbered in libcc order beginning with 256.  We can't guarantee\n+\t that the FP registers will come first, so the following is just\n+\t a guess.  It seems like we should make a special case for FP\n+\t registers and give them fixed numbers < 256.  */\n+      first = 256;\n+    }\n   else if (ACC_REG_P (regno))\n     {\n       first = 0;\n@@ -1885,7 +1938,7 @@ override_options ()\n    a null pointer for X and the punctuation character for CODE.\n \n    'a', 'c', 'l', and 'n' are reserved.\n-   \n+\n    The Xtensa specific codes are:\n \n    'd'  CONST_INT, print as signed decimal\n@@ -2041,7 +2094,7 @@ print_operand (file, x, letter)\n \t  print_operand (file, XEXP (XEXP (x, 0), 1), 0);\n \t}\n       else\n-\t{ \n+\t{\n \t  output_addr_const (file, x);\n \t  fputs (letter == 't' ? \"@h\" : \"@l\", file);\n \t}\n@@ -2608,7 +2661,7 @@ xtensa_va_arg (valist, type)\n \n   size = gen_reg_rtx (SImode);\n   emit_move_insn (size, va_size);\n-  \n+\n   if (BYTES_BIG_ENDIAN)\n     {\n       rtx lab_use_va_size = gen_label_rtx ();"}, {"sha": "0322109bb1985f74f057cc2cb7823d8bfacbc4f8", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/633e4eb4aecc1658799c7647f73b050d12aafdfa/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/633e4eb4aecc1658799c7647f73b050d12aafdfa/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=633e4eb4aecc1658799c7647f73b050d12aafdfa", "patch": "@@ -691,7 +691,6 @@ extern enum reg_class xtensa_char_to_class[256];\n    operand types.\n \n    R = memory that can be accessed with a 4-bit unsigned offset\n-   S = memory where the second word can be addressed with a 4-bit offset\n    T = memory in a constant pool (addressable with a pc-relative load)\n    U = memory *NOT* in a constant pool\n \n@@ -713,7 +712,6 @@ extern enum reg_class xtensa_char_to_class[256];\n \t&& reload_in_progress && GET_CODE (OP) == REG\t\t\t\\\n         && REGNO (OP) >= FIRST_PSEUDO_REGISTER)\t\t\t\t\\\n    : ((CODE) == 'R') ? smalloffset_mem_p (OP)\t\t\t\t\\\n-   : ((CODE) == 'S') ? smalloffset_double_mem_p (OP)\t\t\t\\\n    : ((CODE) == 'T') ? !TARGET_CONST16 && constantpool_mem_p (OP)\t\\\n    : ((CODE) == 'U') ? !constantpool_mem_p (OP)\t\t\t\t\\\n    : FALSE)"}, {"sha": "26bad87cf7fa862f4c2856fc54653aff6109f22f", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 42, "deletions": 136, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/633e4eb4aecc1658799c7647f73b050d12aafdfa/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/633e4eb4aecc1658799c7647f73b050d12aafdfa/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=633e4eb4aecc1658799c7647f73b050d12aafdfa", "patch": "@@ -922,83 +922,35 @@\n   \"\"\n   \"\n {\n-  if (CONSTANT_P (operands[1])\n-      && register_operand (operands[0], DImode))\n-    {\n-      rtx src0, src1, dst0, dst1;\n-      dst0 = operand_subword (operands[0], 0, 1, DImode);\n-      src0 = operand_subword (operands[1], 0, 1, DImode);\n-      dst1 = operand_subword (operands[0], 1, 1, DImode);\n-      src1 = operand_subword (operands[1], 1, 1, DImode);\n-      if (!dst0 || !src0 || !dst1 || !src1)\n-        abort ();\n-      emit_insn (gen_movsi (dst0, src0));\n-      emit_insn (gen_movsi (dst1, src1));\n-      DONE;\n-    }\n+  if (CONSTANT_P (operands[1]) && !TARGET_CONST16)\n+    operands[1] = force_const_mem (DImode, operands[1]);\n \n-  if (!(reload_in_progress | reload_completed))\n-    {\n-      if (!register_operand (operands[0], DImode)\n-\t  && !register_operand (operands[1], DImode))\n-\toperands[1] = force_reg (DImode, operands[1]);\n+  if (!register_operand (operands[0], DImode)\n+      && !register_operand (operands[1], DImode))\n+    operands[1] = force_reg (DImode, operands[1]);\n \n-      if (xtensa_copy_incoming_a7 (operands, DImode))\n-\tDONE;\n-    }\n+  if (xtensa_copy_incoming_a7 (operands, DImode))\n+    DONE;\n }\")\n \n-(define_insn \"movdi_internal\"\n-  [(set (match_operand:DI 0 \"nonimmed_operand\" \"=D,D,S,a,a,U\")\n-\t(match_operand:DI 1 \"nonimmed_operand\" \"d,S,d,r,U,r\"))]\n+(define_insn_and_split \"movdi_internal\"\n+  [(set (match_operand:DI 0 \"nonimmed_operand\" \"=a,W,a,a,U\")\n+\t(match_operand:DI 1 \"move_operand\" \"r,i,T,U,r\"))]\n   \"register_operand (operands[0], DImode)\n    || register_operand (operands[1], DImode)\"\n-  \"*\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 1) (match_dup 3))]\n {\n-  rtx dstreg;\n-  switch (which_alternative)\n+  xtensa_split_operand_pair (operands, SImode);\n+  if (reg_overlap_mentioned_p (operands[0], operands[3]))\n     {\n-    case 0: return \\\"mov.n\\\\t%0, %1\\;mov.n\\\\t%D0, %D1\\\";\n-    case 2: return \\\"%v0s32i.n\\\\t%1, %0\\;s32i.n\\\\t%D1, %N0\\\";\n-    case 3: return \\\"mov\\\\t%0, %1\\;mov\\\\t%D0, %D1\\\";\n-    case 5: return \\\"%v0s32i\\\\t%1, %0\\;s32i\\\\t%D1, %N0\\\";\n-\n-    case 1:\n-    case 4:\n-      /* Check if the first half of the destination register is used\n-\t in the source address.  If so, reverse the order of the loads\n-\t so that the source address doesn't get clobbered until it is\n-\t no longer needed. */\n-\n-      dstreg = operands[0];\n-      if (GET_CODE (dstreg) == SUBREG)\n-\tdstreg = SUBREG_REG (dstreg);\n-      if (GET_CODE (dstreg) != REG)\n-\tabort();\n-\n-      if (reg_mentioned_p (dstreg, operands[1]))\n-\t{\n-\t  switch (which_alternative)\n-\t    {\n-\t    case 1: return \\\"%v1l32i.n\\\\t%D0, %N1\\;l32i.n\\\\t%0, %1\\\";\n-\t    case 4: return \\\"%v1l32i\\\\t%D0, %N1\\;l32i\\\\t%0, %1\\\";\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  switch (which_alternative)\n-\t    {\n-\t    case 1: return \\\"%v1l32i.n\\\\t%0, %1\\;l32i.n\\\\t%D0, %N1\\\";\n-\t    case 4: return \\\"%v1l32i\\\\t%0, %1\\;l32i\\\\t%D0, %N1\\\";\n-\t    }\n-\t}\n+      rtx tmp;\n+      tmp = operands[0], operands[0] = operands[1], operands[1] = tmp;\n+      tmp = operands[2], operands[2] = operands[3], operands[3] = tmp;\n     }\n-  abort ();\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\"\t\"move,load,store,move,load,store\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4,4,4,6,6,6\")])\n+})\n \n \n ;; 32-bit Integer moves\n@@ -1122,7 +1074,7 @@\n \n (define_insn \"movsf_internal\"\n   [(set (match_operand:SF 0 \"nonimmed_operand\" \"=f,f,U,D,D,R,a,f,a,W,a,a,U\")\n-\t(match_operand:SF 1 \"move_operand\" \"f,U,f,d,R,d,r,r,f,F,T,U,r\"))]\n+\t(match_operand:SF 1 \"move_operand\" \"f,U,f,d,R,d,r,r,f,iF,T,U,r\"))]\n   \"((register_operand (operands[0], SFmode)\n      || register_operand (operands[1], SFmode))\n     && !(FP_REG_P (xt_true_regnum (operands[0]))\n@@ -1187,82 +1139,36 @@\n   \"\"\n   \"\n {\n-  if (CONSTANT_P (operands[1]))\n-    {\n-      rtx src0, src1, dst0, dst1;\n-      dst0 = operand_subword (operands[0], 0, 1, DFmode);\n-      src0 = operand_subword (operands[1], 0, 1, DFmode);\n-      dst1 = operand_subword (operands[0], 1, 1, DFmode);\n-      src1 = operand_subword (operands[1], 1, 1, DFmode);\n-      if (!dst0 || !src0 || !dst1 || !src1)\n-        abort ();\n-      emit_insn (gen_movsi (dst0, src0));\n-      emit_insn (gen_movsi (dst1, src1));\n-      DONE;\n-    }\n+  if (CONSTANT_P (operands[1]) && !TARGET_CONST16)\n+    operands[1] = force_const_mem (DFmode, operands[1]);\n \n-  if (!(reload_in_progress | reload_completed))\n-    {\n-      if (!register_operand (operands[0], DFmode)\n-\t  && !register_operand (operands[1], DFmode))\n-\toperands[1] = force_reg (DFmode, operands[1]);\n+  if (!register_operand (operands[0], DFmode)\n+      && !register_operand (operands[1], DFmode))\n+    operands[1] = force_reg (DFmode, operands[1]);\n \n-      if (xtensa_copy_incoming_a7 (operands, DFmode))\n-\tDONE;\n-    }\n+  if (xtensa_copy_incoming_a7 (operands, DFmode))\n+    DONE;\n }\")\n \n-(define_insn \"movdf_internal\"\n-  [(set (match_operand:DF 0 \"nonimmed_operand\" \"=D,D,S,a,a,U\")\n-\t(match_operand:DF 1 \"nonimmed_operand\" \"d,S,d,r,U,r\"))]\n+(define_insn_and_split \"movdf_internal\"\n+  [(set (match_operand:DF 0 \"nonimmed_operand\" \"=a,W,a,a,U\")\n+\t(match_operand:DF 1 \"move_operand\" \"r,iF,T,U,r\"))]\n   \"register_operand (operands[0], DFmode)\n    || register_operand (operands[1], DFmode)\"\n-  \"*\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 1) (match_dup 3))]\n {\n-  rtx dstreg;\n-  switch (which_alternative)\n+  xtensa_split_operand_pair (operands, SFmode);\n+  if (reg_overlap_mentioned_p (operands[0], operands[3]))\n     {\n-    case 0: return \\\"mov.n\\\\t%0, %1\\;mov.n\\\\t%D0, %D1\\\";\n-    case 2: return \\\"%v0s32i.n\\\\t%1, %0\\;s32i.n\\\\t%D1, %N0\\\";\n-    case 3: return \\\"mov\\\\t%0, %1\\;mov\\\\t%D0, %D1\\\";\n-    case 5: return \\\"%v0s32i\\\\t%1, %0\\;s32i\\\\t%D1, %N0\\\";\n-\n-    case 1:\n-    case 4:\n-      /* Check if the first half of the destination register is used\n-\t in the source address.  If so, reverse the order of the loads\n-\t so that the source address doesn't get clobbered until it is\n-\t no longer needed.  */\n-\n-      dstreg = operands[0];\n-      if (GET_CODE (dstreg) == SUBREG)\n-\tdstreg = SUBREG_REG (dstreg);\n-      if (GET_CODE (dstreg) != REG)\n-\tabort ();\n-\n-      if (reg_mentioned_p (dstreg, operands[1]))\n-\t{\n-\t  switch (which_alternative)\n-\t    {\n-\t    case 1: return \\\"%v1l32i.n\\\\t%D0, %N1\\;l32i.n\\\\t%0, %1\\\";\n-\t    case 4: return \\\"%v1l32i\\\\t%D0, %N1\\;l32i\\\\t%0, %1\\\";\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  switch (which_alternative)\n-\t    {\n-\t    case 1: return \\\"%v1l32i.n\\\\t%0, %1\\;l32i.n\\\\t%D0, %N1\\\";\n-\t    case 4: return \\\"%v1l32i\\\\t%0, %1\\;l32i\\\\t%D0, %N1\\\";\n-\t    }\n-\t}\n+      rtx tmp;\n+      tmp = operands[0], operands[0] = operands[1], operands[1] = tmp;\n+      tmp = operands[2], operands[2] = operands[3], operands[3] = tmp;\n     }\n-  abort ();\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\"\t\"move,load,store,move,load,store\")\n-   (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"4,4,4,6,6,6\")])\n+})\n+ \n \n ;; Block moves\n "}]}