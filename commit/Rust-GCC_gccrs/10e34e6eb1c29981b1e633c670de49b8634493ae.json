{"sha": "10e34e6eb1c29981b1e633c670de49b8634493ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBlMzRlNmViMWMyOTk4MWIxZTYzM2M2NzBkZTQ5Yjg2MzQ0OTNhZQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-11T18:58:43Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-11T18:58:43Z"}, "message": "In gcc/objc/: 2010-11-11 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-11-11  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc-act.c (objc_add_property_declaration): Check that the type\n        of a property and of an inherited property match.\n        (objc_maybe_build_component_ref): Tidied up indentation and\n        comments.\n        (objc_common_type): Added new type of check (-5).  If an unknown\n        class is involved in a comparison, try to look up its interface.\n        (objc_add_synthesize_declaration_for_property): Check that the\n        property to synthesize and the instance variable to use have the\n        same type.\n\nIn gcc/testsuite/:\n2010-11-11  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/property/at-property-20.m: New.\n        * objc.dg/property/synthesize-8.m: New.\n        * obj-c++.dg/property/at-property-20.m: New.\n        * obj-c++.dg/property/synthesize-8.mm: New.\n\nFrom-SVN: r166612", "tree": {"sha": "9caffb5656c139686769f77c990dd121c19d4c86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9caffb5656c139686769f77c990dd121c19d4c86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10e34e6eb1c29981b1e633c670de49b8634493ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e34e6eb1c29981b1e633c670de49b8634493ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e34e6eb1c29981b1e633c670de49b8634493ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e34e6eb1c29981b1e633c670de49b8634493ae/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a1d8aa4b1fc433931788b63d51e652969509e4cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d8aa4b1fc433931788b63d51e652969509e4cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1d8aa4b1fc433931788b63d51e652969509e4cd"}], "stats": {"total": 488, "additions": 439, "deletions": 49}, "files": [{"sha": "b34b619ee8f2d07a8f32feff8972ddf945c55ba7", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=10e34e6eb1c29981b1e633c670de49b8634493ae", "patch": "@@ -1,3 +1,14 @@\n+2010-11-11  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (objc_add_property_declaration): Check that the type\n+\tof a property and of an inherited property match.\n+\t(objc_maybe_build_component_ref): Tidied up indentation and\n+\tcomments.\n+\t(objc_common_type): Added new type of check (-5).\n+\t(objc_add_synthesize_declaration_for_property): Check that the\n+\tproperty to synthesize and the instance variable to use have the\n+\tsame type.\n+\t\n 2010-11-10  Joseph Myers  <joseph@codesourcery.com>\n \n \t* objc-act.c (objc_init): Use %' in diagnostic."}, {"sha": "715623f379f3202198d9e3bb1b1b04b4360143f5", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 98, "deletions": 49, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=10e34e6eb1c29981b1e633c670de49b8634493ae", "patch": "@@ -1184,22 +1184,41 @@ objc_add_property_declaration (location_t location, tree decl,\n \t  return;\n \t}\n \n-      if (property_readonly)\n-\t{\n-\t  /* If the property is readonly, it is Ok if the property\n-\t     type is a specialization of the previously declared one.\n-\t     Eg, the superclass returns 'NSArray' while the subclass\n-\t     returns 'NSMutableArray'.  */\n-\t  \n-\t  /* TODO: Check that the types are the same, or more specialized.  */\n-\t  ;\n-\t}\n-      else\n-\t{\n-\t  /* Else, the types must match exactly.  */\n-\n-\t  /* TODO: Check that property types are identical.  */\n-\t  ;\n+      /* We now check that the new and old property declarations have\n+\t the same types (or compatible one).  In the Objective-C\n+\t tradition of loose type checking, we do type-checking but\n+\t only generate warnings (not errors) if they do not match.\n+\t For non-readonly properties, the types must match exactly;\n+\t for readonly properties, it is allowed to use a \"more\n+\t specialized\" type in the new property declaration.  Eg, the\n+\t superclass has a getter returning (NSArray *) and the\n+\t subclass a getter returning (NSMutableArray *).  The object's\n+\t getter returns an (NSMutableArray *); but if you cast the\n+\t object to the superclass, which is allowed, you'd still\n+\t expect the getter to return an (NSArray *), which works since\n+\t an (NSMutableArray *) is an (NSArray *) too.  So, the set of\n+\t objects belonging to the type of the new @property should be\n+\t a subset of the set of objects belonging to the type of the\n+\t old @property.  This is what \"specialization\" means.  And the\n+\t reason it only applies to readonly properties is that for a\n+\t readwrite property the setter would have the opposite\n+\t requirement - ie that the superclass type is more specialized\n+\t then the subclass one; hence the only way to satisfy both\n+\t constraints is that the types match.  */\n+\n+      /* If the types are not the same in the C sense, we warn ...  */\n+      if (!comptypes (TREE_TYPE (x), TREE_TYPE (decl))\n+\t  /* ... unless the property is readonly, in which case we\n+\t     allow a new, more specialized, declaration.  */\n+\t  && (!property_readonly \n+\t      || !objc_compare_types (TREE_TYPE (x),\n+\t\t\t\t      TREE_TYPE (decl), -5, NULL_TREE)))\n+\t{\n+\t  warning_at (location, 0,\n+\t\t      \"type of property %qD conflicts with previous declaration\", decl);\n+\t  if (original_location != UNKNOWN_LOCATION)\n+\t    inform (original_location, \"originally specified here\");\n+\t  return;\n \t}\n     }\n \n@@ -1445,15 +1464,10 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t  else if (t == self_decl)\n \t    interface_type = lookup_interface (CLASS_NAME (implementation_template));\n \n-\t  /* TODO: Protocols.  */\n-\n \t  if (interface_type)\n \t    {\n \t      if (TREE_CODE (objc_method_context) != CLASS_METHOD_DECL)\n-\t\t{\n-\t\t  x = lookup_property (interface_type, property_ident);\n-\t\t  /* TODO: Protocols.  */\n-\t\t}\n+\t\tx = lookup_property (interface_type, property_ident);\n \t\n \t      if (x == NULL_TREE)\n \t\t{\n@@ -1468,8 +1482,6 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t  if (t == self_decl)\n \t\t    implementation = objc_implementation_context;\n \t\t  \n-\t\t  /* TODO: Protocols.  */\n-\n \t\t  x = maybe_make_artificial_property_decl \n \t\t    (interface_type, implementation, NULL_TREE,\n \t\t     property_ident,\n@@ -1544,8 +1556,6 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t}\n     }\n \n-  /* TODO: Fix compiling super.accessor.  */\n-\n   if (x)\n     {\n       tree expression;\n@@ -2121,17 +2131,20 @@ objc_common_type (tree type1, tree type2)\n    returning 'true', this routine may issue warnings related to, e.g.,\n    protocol conformance.  When returning 'false', the routine must\n    produce absolutely no warnings; the C or C++ front-end will do so\n-   instead, if needed.  If either LTYP or RTYP is not an Objective-C type,\n-   the routine must return 'false'.\n+   instead, if needed.  If either LTYP or RTYP is not an Objective-C\n+   type, the routine must return 'false'.\n \n    The ARGNO parameter is encoded as follows:\n      >= 1\tParameter number (CALLEE contains function being called);\n      0\t\tReturn value;\n      -1\t\tAssignment;\n      -2\t\tInitialization;\n      -3\t\tComparison (LTYP and RTYP may match in either direction);\n-     -4\t\tSilent comparison (for C++ overload resolution).\n-  */\n+     -4\t\tSilent comparison (for C++ overload resolution);\n+     -5\t\tSilent \"specialization\" comparison for RTYP to be a \"specialization\" \n+                of LTYP (a specialization means that RTYP is LTYP plus some constraints, \n+                so that each object of type RTYP is also of type LTYP).  This is used\n+                when comparing property types.  */\n \n bool\n objc_compare_types (tree ltyp, tree rtyp, int argno, tree callee)\n@@ -2216,11 +2229,24 @@ objc_compare_types (tree ltyp, tree rtyp, int argno, tree callee)\n   if (rcls && TREE_CODE (rcls) == IDENTIFIER_NODE)\n     rcls = NULL_TREE;\n \n-  /* If either type is an unqualified 'id', we're done.  */\n-  if ((!lproto && objc_is_object_id (ltyp))\n-      || (!rproto && objc_is_object_id (rtyp)))\n-    return true;\n-\n+  /* If either type is an unqualified 'id', we're done.  This is because\n+     an 'id' can be assigned to or from any type with no warnings.  */\n+  if (argno != -5)\n+    {\n+      if ((!lproto && objc_is_object_id (ltyp))\n+\t  || (!rproto && objc_is_object_id (rtyp)))\n+\treturn true;\n+    }\n+  else\n+    {\n+      /* For property checks, though, an 'id' is considered the most\n+\t general type of object, hence if you try to specialize an\n+\t 'NSArray *' (ltyp) property with an 'id' (rtyp) one, we need\n+\t to warn.  */\n+      if (!lproto && objc_is_object_id (ltyp))\n+\treturn true;\n+    }\n+  \n   pointers_compatible = (TYPE_MAIN_VARIANT (ltyp) == TYPE_MAIN_VARIANT (rtyp));\n \n   /* If the underlying types are the same, and at most one of them has\n@@ -2236,13 +2262,22 @@ objc_compare_types (tree ltyp, tree rtyp, int argno, tree callee)\n   else\n     {\n       if (!pointers_compatible)\n-\tpointers_compatible\n-\t  = (objc_is_object_id (ltyp) || objc_is_object_id (rtyp));\n+\t{\n+\t  /* Again, if any of the two is an 'id', we're satisfied,\n+\t     unless we're comparing properties, in which case only an\n+\t     'id' on the left-hand side (old property) is good\n+\t     enough.  */\n+\t  if (argno != -5)\n+\t    pointers_compatible\n+\t      = (objc_is_object_id (ltyp) || objc_is_object_id (rtyp));\n+\t  else\n+\t    pointers_compatible = objc_is_object_id (ltyp);\t    \n+\t}\n \n       if (!pointers_compatible)\n \tpointers_compatible = DERIVED_FROM_P (ltyp, rtyp);\n \n-      if (!pointers_compatible && argno <= -3)\n+      if (!pointers_compatible && (argno == -3 || argno == -4))\n \tpointers_compatible = DERIVED_FROM_P (rtyp, ltyp);\n     }\n \n@@ -2268,6 +2303,7 @@ objc_compare_types (tree ltyp, tree rtyp, int argno, tree callee)\n \t ObjC-specific.  */\n       switch (argno)\n \t{\n+\tcase -5:\n \tcase -4:\n \t  return false;\n \n@@ -9797,19 +9833,32 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n   if (ivar_name == NULL_TREE)\n     ivar_name = property_name;\n \n-  /* Check that the instance variable exists.  You can only use a\n-     non-private instance variable from the same class, not one from\n-     the superclass (this makes sense as it allows us to check that an\n+  /* Check that the instance variable exists.  You can only use an\n+     instance variable from the same class, not one from the\n+     superclass (this makes sense as it allows us to check that an\n      instance variable is only used in one synthesized property).  */\n-  if (!is_ivar (CLASS_IVARS (interface), ivar_name))\n-    {\n-      error_at (location, \"ivar %qs used by %<@synthesize%> declaration must be an existing ivar\", \n-\t\tIDENTIFIER_POINTER (property_name));\n-      return;\n-    }\n+  {\n+    tree ivar = is_ivar (CLASS_IVARS (interface), ivar_name);\n+    if (!ivar)\n+      {\n+\terror_at (location, \"ivar %qs used by %<@synthesize%> declaration must be an existing ivar\", \n+\t\t  IDENTIFIER_POINTER (property_name));\n+\treturn;\n+      }\n \n-  /* TODO: Check that the types of the instance variable and of the\n-     property match.  */\n+    /* If the instance variable has a different C type, we warn.  */\n+    if (!comptypes (TREE_TYPE (property), TREE_TYPE (ivar)))\n+      {\n+\tlocation_t original_location = DECL_SOURCE_LOCATION (ivar);\n+\t\n+\terror_at (location, \"property %qs is using instance variable %qs of incompatible type\",\n+\t\t  IDENTIFIER_POINTER (property_name),\n+\t\t  IDENTIFIER_POINTER (ivar_name));\n+\t\n+\tif (original_location != UNKNOWN_LOCATION)\n+\t  inform (original_location, \"originally specified here\");\n+      }\n+  }\n \n   /* Check that no other property is using the same instance\n      variable.  */"}, {"sha": "315660166fc8b7a75f9c3fc7de72cdfc68ede064", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10e34e6eb1c29981b1e633c670de49b8634493ae", "patch": "@@ -1,3 +1,10 @@\n+2010-11-11  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/property/at-property-20.m: New.\n+\t* objc.dg/property/synthesize-8.m: New.\t\n+\t* obj-c++.dg/property/at-property-20.m: New.\n+\t* obj-c++.dg/property/synthesize-8.mm: New.\n+\t\n 2010-11-11  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/cpp/warn-normalized-3.c: Update expected note text."}, {"sha": "0fae36b70887704b045452378ab5337e655df369", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-20.mm", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-20.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-20.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-20.mm?ref=10e34e6eb1c29981b1e633c670de49b8634493ae", "patch": "@@ -0,0 +1,82 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that if you have a property declared in a class and a\n+   sub-class, the types match (unless it's a readonly property, in\n+   which case a \"specialization\" is enough).  */\n+\n+@protocol MyProtocolA\n+- (void) doNothingA;\n+@end\n+\n+@protocol MyProtocolB\n+- (void) doNothingB;\n+@end\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@end\n+\n+@interface MySubClass1 : MyRootClass\n+@end\n+\n+@interface MySubClass2 : MyRootClass\n+@end\n+\n+@interface MySubClass3 : MyRootClass <MyProtocolA>\n+@end\n+\n+@interface MySubClass4 : MySubClass1\n+@end\n+\n+/* Now, the test.  */\n+\n+@interface MyClass : MyRootClass\n+{ }\n+@property (assign) id <MyProtocolA> a;        /* { dg-warning \"originally specified here\" } */\n+@property int b;                              /* { dg-warning \"originally specified here\" } */\n+@property float c;                            /* { dg-warning \"originally specified here\" } */\n+@property (assign) MyRootClass *d;            /* { dg-warning \"originally specified here\" } */\n+@property (assign) MySubClass1 *e;            /* { dg-warning \"originally specified here\" } */\n+/* FIXME: The compiler seems to generate messages correctly, but the testsuite still fails the test.  */\n+/*@property (assign, readonly) MySubClass1 *f; */ /*  dg-warning \"originally specified here\"  */\n+@property (assign) MySubClass3 *g;            /* { dg-warning \"originally specified here\" } */\n+/*@property (assign, readonly) MySubClass3 *h; */ /*  dg-warning \"originally specified here\"  */\n+@end\n+\n+/* The following are all OK because they are identical.  */\n+@interface MyClass2 : MyClass\n+{ }\n+@property (assign) id a;\n+@property int b;\n+@property float c;\n+@property (assign) MyRootClass *d;\n+@property (assign) MySubClass1 *e;\n+@property (assign, readonly) MySubClass1 *f;\n+@property (assign) MySubClass3 *g;\n+@property (assign, readonly) MySubClass3 *h;\n+@end\n+\n+/* The following are not OK.  */\n+@interface MyClass3 : MyClass\n+{ }\n+@property (assign) MySubClass1 *a;            /* { dg-warning \"type of property .a. conflicts with previous declaration\" } */\n+@property float b;                            /* { dg-warning \"type of property .b. conflicts with previous declaration\" } */\n+@property int c;                              /* { dg-warning \"type of property .c. conflicts with previous declaration\" } */\n+@property (assign) id d;                      /* { dg-warning \"type of property .d. conflicts with previous declaration\" } */\n+@property (assign) MyRootClass *e;            /* { dg-warning \"type of property .e. conflicts with previous declaration\" } */\n+/*@property (assign, readonly) MyRootClass *f; */ /*  dg-warning \"type of property .f. conflicts with previous declaration\"  */\n+@property (assign) MySubClass2 *g;            /* { dg-warning \"type of property .g. conflicts with previous declaration\" } */\n+/*@property (assign, readonly) MySubClass2 *h; */ /*  dg-warning \"type of property .h. conflicts with previous declaration\"  */\n+@end\n+\n+/* The following are OK.  */\n+@interface MyClass4 : MyClass\n+{ }\n+@property (assign, readonly) MySubClass4 *f;\n+@property (assign, readonly) MySubClass3 <MyProtocolB> *h;\n+@end"}, {"sha": "071f6f2ad2a048c8c17b10309475978f4742f424", "filename": "gcc/testsuite/obj-c++.dg/property/synthesize-8.mm", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-8.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-8.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-8.mm?ref=10e34e6eb1c29981b1e633c670de49b8634493ae", "patch": "@@ -0,0 +1,80 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test that when using @synthesize the instance variable and the\n+   property have exactly the same type.  */\n+\n+#include <objc/objc.h>\n+\n+@protocol MyProtocol\n+- (void)aMethod;\n+@end\n+\n+@interface ClassA\n+@end\n+\n+@interface ClassB : ClassA\n+@end\n+\n+\n+/* This is all OK.  */\n+@interface Test\n+{\n+  int v;\n+  float w;\n+  id x;\n+  Test *y;\n+  id <MyProtocol> *z;\n+  ClassA *a;\n+  ClassB *b;\n+  ClassA <MyProtocol> *c;\n+}\n+@property (assign) int v;\n+@property (assign) float w;\n+@property (assign) id x;\n+@property (assign) Test *y;\n+@property (assign) id <MyProtocol> *z;\n+@property (assign) ClassA *a;\n+@property (assign) ClassB *b;\n+@end\n+\n+@implementation Test\n+@synthesize v;\n+@synthesize w;\n+@synthesize x;\n+@synthesize y;\n+@synthesize z;\n+@synthesize a;\n+@synthesize b;\n+@end\n+\n+\n+/* This is not OK.  */\n+@interface Test2\n+{\n+  int v;                   /* { dg-warning \"originally specified here\" } */\n+  float w;                 /* { dg-warning \"originally specified here\" } */\n+  id x;                    /* { dg-warning \"originally specified here\" } */\n+  Test *y;                 /* { dg-warning \"originally specified here\" } */\n+  id <MyProtocol> *z;      /* { dg-warning \"originally specified here\" } */\n+  ClassA *a;               /* { dg-warning \"originally specified here\" } */\n+  ClassB *b;               /* { dg-warning \"originally specified here\" } */\n+}\n+@property (assign) float v;\n+@property (assign) id w;\n+@property (assign) int x;\n+@property (assign) id y;\n+@property (assign) Test *z;\n+@property (assign) ClassB *a;\n+@property (assign) ClassA *b;\n+@end\n+\n+@implementation Test2\n+@synthesize v; /* { dg-error \"property .v. is using instance variable .v. of incompatible type\" } */\n+@synthesize w; /* { dg-error \"property .w. is using instance variable .w. of incompatible type\" } */\n+@synthesize x; /* { dg-error \"property .x. is using instance variable .x. of incompatible type\" } */\n+@synthesize y; /* { dg-error \"property .y. is using instance variable .y. of incompatible type\" } */\n+@synthesize z; /* { dg-error \"property .z. is using instance variable .z. of incompatible type\" } */\n+@synthesize a; /* { dg-error \"property .a. is using instance variable .a. of incompatible type\" } */\n+@synthesize b; /* { dg-error \"property .b. is using instance variable .b. of incompatible type\" } */\n+@end"}, {"sha": "1bb49da2b78d7723469f8b9392d85047c5ab370d", "filename": "gcc/testsuite/objc.dg/property/at-property-20.m", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-20.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-20.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-20.m?ref=10e34e6eb1c29981b1e633c670de49b8634493ae", "patch": "@@ -0,0 +1,81 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that if you have a property declared in a class and a\n+   sub-class, the types match (unless it's a readonly property, in\n+   which case a \"specialization\" is enough).  */\n+\n+@protocol MyProtocolA\n+- (void) doNothingA;\n+@end\n+\n+@protocol MyProtocolB\n+- (void) doNothingB;\n+@end\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@end\n+\n+@interface MySubClass1 : MyRootClass\n+@end\n+\n+@interface MySubClass2 : MyRootClass\n+@end\n+\n+@interface MySubClass3 : MyRootClass <MyProtocolA>\n+@end\n+\n+@interface MySubClass4 : MySubClass1\n+@end\n+\n+/* Now, the test.  */\n+\n+@interface MyClass : MyRootClass\n+{ }\n+@property (assign) id <MyProtocolA> a;        /* { dg-message \"originally specified here\" } */\n+@property int b;                              /* { dg-message \"originally specified here\" } */\n+@property float c;                            /* { dg-message \"originally specified here\" } */\n+@property (assign) MyRootClass *d;            /* { dg-message \"originally specified here\" } */\n+@property (assign) MySubClass1 *e;            /* { dg-message \"originally specified here\" } */\n+@property (assign, readonly) MySubClass1 *f;  /* { dg-message \"originally specified here\" } */\n+@property (assign) MySubClass3 *g;            /* { dg-message \"originally specified here\" } */\n+@property (assign, readonly) MySubClass3 *h;  /* { dg-message \"originally specified here\" } */\n+@end\n+\n+/* The following are all OK because they are identical.  */\n+@interface MyClass2 : MyClass\n+{ }\n+@property (assign) id a;\n+@property int b;\n+@property float c;\n+@property (assign) MyRootClass *d;\n+@property (assign) MySubClass1 *e;\n+@property (assign, readonly) MySubClass1 *f;\n+@property (assign) MySubClass3 *g;\n+@property (assign, readonly) MySubClass3 *h;\n+@end\n+\n+/* The following are not OK.  */\n+@interface MyClass3 : MyClass\n+{ }\n+@property (assign) MySubClass1 *a;            /* { dg-warning \"type of property .a. conflicts with previous declaration\" } */\n+@property float b;                            /* { dg-warning \"type of property .b. conflicts with previous declaration\" } */\n+@property int c;                              /* { dg-warning \"type of property .c. conflicts with previous declaration\" } */\n+@property (assign) id d;                      /* { dg-warning \"type of property .d. conflicts with previous declaration\" } */\n+@property (assign) MyRootClass *e;            /* { dg-warning \"type of property .e. conflicts with previous declaration\" } */\n+@property (assign, readonly) MyRootClass *f;  /* { dg-warning \"type of property .f. conflicts with previous declaration\" } */\n+@property (assign) MySubClass2 *g;            /* { dg-warning \"type of property .g. conflicts with previous declaration\" } */\n+@property (assign, readonly) MySubClass2 *h;  /* { dg-warning \"type of property .h. conflicts with previous declaration\" } */\n+@end\n+\n+/* The following are OK.  */\n+@interface MyClass4 : MyClass\n+{ }\n+@property (assign, readonly) MySubClass4 *f;\n+@property (assign, readonly) MySubClass3 <MyProtocolB> *h;\n+@end"}, {"sha": "4af3ecc742f2bfd509646ccfaed2438d67c334ae", "filename": "gcc/testsuite/objc.dg/property/synthesize-8.m", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-8.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e34e6eb1c29981b1e633c670de49b8634493ae/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-8.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-8.m?ref=10e34e6eb1c29981b1e633c670de49b8634493ae", "patch": "@@ -0,0 +1,80 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test that when using @synthesize the instance variable and the\n+   property have exactly the same type.  */\n+\n+#include <objc/objc.h>\n+\n+@protocol MyProtocol\n+- (void)aMethod;\n+@end\n+\n+@interface ClassA\n+@end\n+\n+@interface ClassB : ClassA\n+@end\n+\n+\n+/* This is all OK.  */\n+@interface Test\n+{\n+  int v;\n+  float w;\n+  id x;\n+  Test *y;\n+  id <MyProtocol> *z;\n+  ClassA *a;\n+  ClassB *b;\n+  ClassA <MyProtocol> *c;\n+}\n+@property (assign) int v;\n+@property (assign) float w;\n+@property (assign) id x;\n+@property (assign) Test *y;\n+@property (assign) id <MyProtocol> *z;\n+@property (assign) ClassA *a;\n+@property (assign) ClassB *b;\n+@end\n+\n+@implementation Test\n+@synthesize v;\n+@synthesize w;\n+@synthesize x;\n+@synthesize y;\n+@synthesize z;\n+@synthesize a;\n+@synthesize b;\n+@end\n+\n+\n+/* This is not OK.  */\n+@interface Test2\n+{\n+  int v;                   /* { dg-message \"originally specified here\" } */\n+  float w;                 /* { dg-message \"originally specified here\" } */\n+  id x;                    /* { dg-message \"originally specified here\" } */\n+  Test *y;                 /* { dg-message \"originally specified here\" } */\n+  id <MyProtocol> *z;      /* { dg-message \"originally specified here\" } */\n+  ClassA *a;               /* { dg-message \"originally specified here\" } */\n+  ClassB *b;               /* { dg-message \"originally specified here\" } */\n+}\n+@property (assign) float v;\n+@property (assign) id w;\n+@property (assign) int x;\n+@property (assign) id y;\n+@property (assign) Test *z;\n+@property (assign) ClassB *a;\n+@property (assign) ClassA *b;\n+@end\n+\n+@implementation Test2\n+@synthesize v; /* { dg-error \"property .v. is using instance variable .v. of incompatible type\" } */\n+@synthesize w; /* { dg-error \"property .w. is using instance variable .w. of incompatible type\" } */\n+@synthesize x; /* { dg-error \"property .x. is using instance variable .x. of incompatible type\" } */\n+@synthesize y; /* { dg-error \"property .y. is using instance variable .y. of incompatible type\" } */\n+@synthesize z; /* { dg-error \"property .z. is using instance variable .z. of incompatible type\" } */\n+@synthesize a; /* { dg-error \"property .a. is using instance variable .a. of incompatible type\" } */\n+@synthesize b; /* { dg-error \"property .b. is using instance variable .b. of incompatible type\" } */\n+@end"}]}