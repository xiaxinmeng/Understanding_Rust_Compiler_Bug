{"sha": "296916261846a9eaab03335d5e12a31271f2cf76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk2OTE2MjYxODQ2YTllYWFiMDMzMzVkNWUxMmEzMTI3MWYyY2Y3Ng==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-14T07:09:08Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-14T07:09:08Z"}, "message": "Improved use tree parsing", "tree": {"sha": "7e022a1cb28249e17124675bc981011485fe29ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e022a1cb28249e17124675bc981011485fe29ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/296916261846a9eaab03335d5e12a31271f2cf76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/296916261846a9eaab03335d5e12a31271f2cf76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/296916261846a9eaab03335d5e12a31271f2cf76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/296916261846a9eaab03335d5e12a31271f2cf76/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d9b6db945ec25b51bff8b04e151973788149f3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9b6db945ec25b51bff8b04e151973788149f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d9b6db945ec25b51bff8b04e151973788149f3d"}], "stats": {"total": 427, "additions": 245, "deletions": 182}, "files": [{"sha": "187f8215d4c4b14b023f4bcec23009062172fbbf", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 245, "deletions": 182, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296916261846a9eaab03335d5e12a31271f2cf76/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296916261846a9eaab03335d5e12a31271f2cf76/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=296916261846a9eaab03335d5e12a31271f2cf76", "patch": "@@ -523,14 +523,39 @@ Parser<ManagedTokenSource>::parse_attribute_body ()\n   return AST::Attribute (std::move (attr_path), std::move (attr_input), locus);\n }\n \n-// Parses a SimplePath AST node\n+/* Determines whether token is a valid simple path segment. This does not\n+ * include scope resolution operators. */\n+inline bool\n+is_simple_path_segment (TokenId id)\n+{\n+  switch (id)\n+    {\n+    case IDENTIFIER:\n+    case SUPER:\n+    case SELF:\n+    case CRATE:\n+      return true;\n+    case DOLLAR_SIGN:\n+      // assume that dollar sign leads to $crate\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n+// Parses a SimplePath AST node, if it exists. Does nothing otherwise.\n template <typename ManagedTokenSource>\n AST::SimplePath\n Parser<ManagedTokenSource>::parse_simple_path ()\n {\n   bool has_opening_scope_resolution = false;\n   Location locus = Linemap::unknown_location ();\n \n+  // don't parse anything if not a path upfront\n+  if (!is_simple_path_segment (lexer.peek_token ()->get_id ())\n+      && !is_simple_path_segment (lexer.peek_token (1)->get_id ()))\n+    return AST::SimplePath::create_empty ();\n+\n   /* Checks for opening scope resolution (i.e. global scope fully-qualified\n    * path) */\n   if (lexer.peek_token ()->get_id () == SCOPE_RESOLUTION)\n@@ -586,6 +611,8 @@ Parser<ManagedTokenSource>::parse_simple_path ()\n \n   return AST::SimplePath (std::move (segments), has_opening_scope_resolution,\n \t\t\t  locus);\n+  /* TODO: now that is_simple_path_segment exists, could probably start\n+   * actually making errors upon parse failure of segments and whatever */\n }\n \n /* Parses a single SimplePathSegment (does not handle the scope resolution\n@@ -604,22 +631,21 @@ Parser<ManagedTokenSource>::parse_simple_path_segment ()\n     case SUPER:\n       lexer.skip_token ();\n \n-      return AST::SimplePathSegment (std::string (\"super\"), t->get_locus ());\n+      return AST::SimplePathSegment (\"super\", t->get_locus ());\n     case SELF:\n       lexer.skip_token ();\n \n-      return AST::SimplePathSegment (std::string (\"self\"), t->get_locus ());\n+      return AST::SimplePathSegment (\"self\", t->get_locus ());\n     case CRATE:\n       lexer.skip_token ();\n \n-      return AST::SimplePathSegment (std::string (\"crate\"), t->get_locus ());\n+      return AST::SimplePathSegment (\"crate\", t->get_locus ());\n     case DOLLAR_SIGN:\n       if (lexer.peek_token (1)->get_id () == CRATE)\n \t{\n \t  lexer.skip_token (1);\n \n-\t  return AST::SimplePathSegment (std::string (\"$crate\"),\n-\t\t\t\t\t t->get_locus ());\n+\t  return AST::SimplePathSegment (\"$crate\", t->get_locus ());\n \t}\n       gcc_fallthrough ();\n     default:\n@@ -653,25 +679,25 @@ Parser<ManagedTokenSource>::parse_path_ident_segment ()\n     case SUPER:\n       lexer.skip_token ();\n \n-      return AST::PathIdentSegment (std::string (\"super\"));\n+      return AST::PathIdentSegment (\"super\");\n     case SELF:\n       lexer.skip_token ();\n \n-      return AST::PathIdentSegment (std::string (\"self\"));\n+      return AST::PathIdentSegment (\"self\");\n     case SELF_ALIAS:\n       lexer.skip_token ();\n \n-      return AST::PathIdentSegment (std::string (\"Self\"));\n+      return AST::PathIdentSegment (\"Self\");\n     case CRATE:\n       lexer.skip_token ();\n \n-      return AST::PathIdentSegment (std::string (\"crate\"));\n+      return AST::PathIdentSegment (\"crate\");\n     case DOLLAR_SIGN:\n       if (lexer.peek_token (1)->get_id () == CRATE)\n \t{\n \t  lexer.skip_token (1);\n \n-\t  return AST::PathIdentSegment (std::string (\"$crate\"));\n+\t  return AST::PathIdentSegment (\"$crate\");\n \t}\n       gcc_fallthrough ();\n     default:\n@@ -1265,8 +1291,7 @@ Parser<ManagedTokenSource>::parse_macro_item (\n   /* dodgy way of detecting macro due to weird context-dependence thing.\n    * probably can be improved */\n   // TODO: ensure that string compare works properly\n-  if (t->get_id () == IDENTIFIER\n-      && t->get_str () == std::string (\"macro_rules\"))\n+  if (t->get_id () == IDENTIFIER && t->get_str () == \"macro_rules\")\n     {\n       return parse_macro_rules_def (std::move (outer_attrs));\n     }\n@@ -2081,7 +2106,7 @@ Parser<ManagedTokenSource>::parse_extern_crate (\n       lexer.skip_token ();\n       break;\n     case SELF:\n-      crate_name = std::string (\"self\");\n+      crate_name = \"self\";\n       lexer.skip_token ();\n       break;\n     default:\n@@ -2120,7 +2145,7 @@ Parser<ManagedTokenSource>::parse_extern_crate (\n       lexer.skip_token ();\n       break;\n     case UNDERSCORE:\n-      as_name = std::string (\"_\");\n+      as_name = \"_\";\n       lexer.skip_token ();\n       break;\n     default:\n@@ -2216,17 +2241,14 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n     {\n       // has no path, so must be glob or nested tree UseTree type\n \n-      /* due to implementation issues, parsing simple path removes any trailing\n-       * scope resolutions (or any, actually, if the use tree has no path\n-       * given), so we'll just assume that there's one there. */\n-      // Check anyway, but optional.\n+      bool is_global = false;\n+\n+      // check for global scope resolution operator\n       if (lexer.peek_token ()->get_id () == SCOPE_RESOLUTION)\n \t{\n \t  lexer.skip_token ();\n+\t  is_global = true;\n \t}\n-      /* Note that this implementation issue also makes it impossible to\n-       * determine at the moment whether the tree has GLOBAL or NO_PATH path\n-       * type. */\n \n       const_TokenPtr t = lexer.peek_token ();\n       switch (t->get_id ())\n@@ -2235,11 +2257,14 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t  // glob UseTree type\n \t  lexer.skip_token ();\n \n-\t  // TODO: find way to determine whether GLOBAL or NO_PATH path type -\n-\t  // placeholder\n-\t  return std::unique_ptr<AST::UseTreeGlob> (\n-\t    new AST::UseTreeGlob (AST::UseTreeGlob::NO_PATH,\n-\t\t\t\t  AST::SimplePath::create_empty (), locus));\n+\t  if (is_global)\n+\t    return std::unique_ptr<AST::UseTreeGlob> (\n+\t      new AST::UseTreeGlob (AST::UseTreeGlob::GLOBAL,\n+\t\t\t\t    AST::SimplePath::create_empty (), locus));\n+\t  else\n+\t    return std::unique_ptr<AST::UseTreeGlob> (\n+\t      new AST::UseTreeGlob (AST::UseTreeGlob::NO_PATH,\n+\t\t\t\t    AST::SimplePath::create_empty (), locus));\n \t  case LEFT_CURLY: {\n \t    // nested tree UseTree type\n \t    lexer.skip_token ();\n@@ -2258,11 +2283,9 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t\tuse_trees.push_back (std::move (use_tree));\n \n \t\tif (lexer.peek_token ()->get_id () != COMMA)\n-\t\t  {\n-\t\t    break;\n-\t\t  }\n-\t\tlexer.skip_token ();\n+\t\t  break;\n \n+\t\tlexer.skip_token ();\n \t\tt = lexer.peek_token ();\n \t      }\n \n@@ -2273,24 +2296,30 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t\treturn nullptr;\n \t      }\n \n-\t    /* TODO: find way to determine whether GLOBAL or NO_PATH path type -\n-\t     * placeholder */\n-\t    return std::unique_ptr<AST::UseTreeList> (\n-\t      new AST::UseTreeList (AST::UseTreeList::NO_PATH,\n-\t\t\t\t    AST::SimplePath::create_empty (),\n-\t\t\t\t    std::move (use_trees), locus));\n+\t    if (is_global)\n+\t      return std::unique_ptr<AST::UseTreeList> (\n+\t\tnew AST::UseTreeList (AST::UseTreeList::GLOBAL,\n+\t\t\t\t      AST::SimplePath::create_empty (),\n+\t\t\t\t      std::move (use_trees), locus));\n+\t    else\n+\t      return std::unique_ptr<AST::UseTreeList> (\n+\t\tnew AST::UseTreeList (AST::UseTreeList::NO_PATH,\n+\t\t\t\t      AST::SimplePath::create_empty (),\n+\t\t\t\t      std::move (use_trees), locus));\n \t  }\n \tcase AS:\n \t  // this is not allowed\n-\t  rust_error_at (t->get_locus (),\n-\t\t\t \"use declaration with rebind %<as%> requires a valid \"\n-\t\t\t \"simple path - none found\");\n+\t  rust_error_at (\n+\t    t->get_locus (),\n+\t    \"use declaration with rebind %<as%> requires a valid simple path - \"\n+\t    \"none found\");\n \t  skip_after_semicolon ();\n \t  return nullptr;\n \tdefault:\n \t  rust_error_at (t->get_locus (),\n \t\t\t \"unexpected token %qs in use tree with no valid \"\n-\t\t\t \"simple path (i.e. list or glob use tree)\",\n+\t\t\t \"simple path (i.e. list\"\n+\t\t\t \" or glob use tree)\",\n \t\t\t t->get_token_description ());\n \t  skip_after_semicolon ();\n \t  return nullptr;\n@@ -2299,7 +2328,8 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n   else\n     {\n       /* Due to aforementioned implementation issues, the trailing :: token is\n-       * consumed by the path, so it can not be used as a disambiguator. */\n+       * consumed by the path, so it can not be used as a disambiguator.\n+       * NOPE, not true anymore - TODO what are the consequences of this? */\n \n       const_TokenPtr t = lexer.peek_token ();\n       switch (t->get_id ())\n@@ -2330,11 +2360,9 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t\tuse_trees.push_back (std::move (use_tree));\n \n \t\tif (lexer.peek_token ()->get_id () != COMMA)\n-\t\t  {\n-\t\t    break;\n-\t\t  }\n-\t\tlexer.skip_token ();\n+\t\t  break;\n \n+\t\tlexer.skip_token ();\n \t\tt = lexer.peek_token ();\n \t      }\n \n@@ -2371,14 +2399,13 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \n \t\treturn std::unique_ptr<AST::UseTreeRebind> (\n \t\t  new AST::UseTreeRebind (AST::UseTreeRebind::WILDCARD,\n-\t\t\t\t\t  std::move (path), locus,\n-\t\t\t\t\t  std::string (\"_\")));\n+\t\t\t\t\t  std::move (path), locus, \"_\"));\n \t      default:\n-\t\trust_error_at (t->get_locus (),\n-\t\t\t       \"unexpected token %qs in use tree with as \"\n-\t\t\t       \"clause - expected \"\n-\t\t\t       \"identifier or %<_%>\",\n-\t\t\t       t->get_token_description ());\n+\t\trust_error_at (\n+\t\t  t->get_locus (),\n+\t\t  \"unexpected token %qs in use tree with as clause - expected \"\n+\t\t  \"identifier or %<_%>\",\n+\t\t  t->get_token_description ());\n \t\tskip_after_semicolon ();\n \t\treturn nullptr;\n \t      }\n@@ -2445,7 +2472,8 @@ Parser<ManagedTokenSource>::parse_function (\n   // parse function parameters (only if next token isn't right paren)\n   std::vector<AST::FunctionParam> function_params;\n   if (lexer.peek_token ()->get_id () != RIGHT_PAREN)\n-      function_params = parse_function_params ([](TokenId id) { return id == RIGHT_PAREN; });\n+    function_params\n+      = parse_function_params ([] (TokenId id) { return id == RIGHT_PAREN; });\n \n   if (!skip_token (RIGHT_PAREN))\n     {\n@@ -3241,7 +3269,7 @@ Parser<ManagedTokenSource>::parse_type_param ()\n \t\t\tstd::move (outer_attr)));\n }\n \n-/* Parses regular (i.e. non-generic) parameters in functions or methods. Also \n+/* Parses regular (i.e. non-generic) parameters in functions or methods. Also\n  * has end token handling. */\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n@@ -3251,12 +3279,12 @@ Parser<ManagedTokenSource>::parse_function_params (EndTokenPred is_end_token)\n   std::vector<AST::FunctionParam> params;\n \n   if (is_end_token (lexer.peek_token ()->get_id ()))\n-      return params;\n+    return params;\n \n   AST::FunctionParam initial_param = parse_function_param ();\n \n   // Return empty parameter list if no parameter there\n-  if (initial_param.is_error ()) \n+  if (initial_param.is_error ())\n     {\n       // TODO: is this an error?\n       return params;\n@@ -3275,7 +3303,7 @@ Parser<ManagedTokenSource>::parse_function_params (EndTokenPred is_end_token)\n \n       // TODO: strictly speaking, shouldn't there be no trailing comma?\n       if (is_end_token (lexer.peek_token ()->get_id ()))\n-\t  break;\n+\tbreak;\n \n       // now, as right paren would break, function param is required\n       AST::FunctionParam param = parse_function_param ();\n@@ -3340,7 +3368,7 @@ std::unique_ptr<AST::Type>\n Parser<ManagedTokenSource>::parse_function_return_type ()\n {\n   if (lexer.peek_token ()->get_id () != RETURN_TYPE)\n-      return nullptr;\n+    return nullptr;\n \n   // skip return type, as it now obviously exists\n   lexer.skip_token ();\n@@ -4639,12 +4667,13 @@ Parser<ManagedTokenSource>::parse_trait_item ()\n \t    /* skip comma so function and method regular params can be parsed in\n \t     * same way */\n \t    if (lexer.peek_token ()->get_id () == COMMA)\n-\t\tlexer.skip_token ();\n+\t      lexer.skip_token ();\n \t  }\n \n \t// parse trait function params\n \tstd::vector<AST::FunctionParam> function_params\n-\t  = parse_function_params ([](TokenId id) { return id == RIGHT_PAREN; });\n+\t  = parse_function_params (\n+\t    [] (TokenId id) { return id == RIGHT_PAREN; });\n \n \tif (!skip_token (RIGHT_PAREN))\n \t  {\n@@ -5164,11 +5193,12 @@ Parser<ManagedTokenSource>::parse_inherent_impl_function_or_method (\n       /* skip comma so function and method regular params can be parsed in same\n        * way */\n       if (lexer.peek_token ()->get_id () == COMMA)\n-\t  lexer.skip_token ();\n+\tlexer.skip_token ();\n     }\n \n   // parse trait function params\n-  std::vector<AST::FunctionParam> function_params = parse_function_params ([](TokenId id) { return id == RIGHT_PAREN; });\n+  std::vector<AST::FunctionParam> function_params\n+    = parse_function_params ([] (TokenId id) { return id == RIGHT_PAREN; });\n \n   if (!skip_token (RIGHT_PAREN))\n     {\n@@ -5413,7 +5443,8 @@ Parser<ManagedTokenSource>::parse_trait_impl_function_or_method (\n   std::vector<AST::FunctionParam> function_params;\n   if (lexer.peek_token ()->get_id () != RIGHT_PAREN)\n     {\n-      function_params = parse_function_params ([](TokenId id) { return id == RIGHT_PAREN; });\n+      function_params\n+\t= parse_function_params ([] (TokenId id) { return id == RIGHT_PAREN; });\n \n       if (function_params.empty ())\n \t{\n@@ -5547,7 +5578,7 @@ Parser<ManagedTokenSource>::parse_extern_block (\n       // skip somewhere\n       return nullptr;\n     }\n-  \n+\n   extern_items.shrink_to_fit ();\n \n   return std::unique_ptr<AST::ExternBlock> (\n@@ -5647,51 +5678,60 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \t// parse parameters\n \tstd::vector<AST::NamedFunctionParam> function_params;\n \tbool is_variadic = false;\n-  std::vector<AST::Attribute> variadic_attrs;\n+\tstd::vector<AST::Attribute> variadic_attrs;\n \n \tconst_TokenPtr t = lexer.peek_token ();\n-\twhile (t->get_id () != RIGHT_PAREN) {\n-      std::vector<AST::Attribute> maybe_variadic_attrs = parse_outer_attributes ();\n-      if (lexer.peek_token ()->get_id () == ELLIPSIS) {\n-        // variadic - use attrs for this\n-        lexer.skip_token ();\n-\t\t    is_variadic = true;\n-        variadic_attrs = std::move (maybe_variadic_attrs);\n-\t\t    t = lexer.peek_token ();\n-\n-        if (t->get_id() != RIGHT_PAREN) {\n-          rust_error_at (t->get_locus (),\n-\t\t\t\t   \"expected right parentheses after variadic in named function \"\n-           \"parameters, found %qs\",\n-\t\t\t\t   t->get_token_description ());\n-          skip_after_semicolon ();\n-\t\t      return nullptr;\n-        }\n-\n-        break;\n-      }\n+\twhile (t->get_id () != RIGHT_PAREN)\n+\t  {\n+\t    std::vector<AST::Attribute> maybe_variadic_attrs\n+\t      = parse_outer_attributes ();\n+\t    if (lexer.peek_token ()->get_id () == ELLIPSIS)\n+\t      {\n+\t\t// variadic - use attrs for this\n+\t\tlexer.skip_token ();\n+\t\tis_variadic = true;\n+\t\tvariadic_attrs = std::move (maybe_variadic_attrs);\n+\t\tt = lexer.peek_token ();\n \n-\t    AST::NamedFunctionParam param = parse_named_function_param (std::move (maybe_variadic_attrs));\n-\t    if (param.is_error ()) {\n+\t\tif (t->get_id () != RIGHT_PAREN)\n+\t\t  {\n \t\t    rust_error_at (t->get_locus (),\n-\t\t\t       \"could not parse named function parameter in external function\");\n+\t\t\t\t   \"expected right parentheses after variadic \"\n+\t\t\t\t   \"in named function \"\n+\t\t\t\t   \"parameters, found %qs\",\n+\t\t\t\t   t->get_token_description ());\n \t\t    skip_after_semicolon ();\n \t\t    return nullptr;\n-\t    }\n+\t\t  }\n+\n+\t\tbreak;\n+\t      }\n+\n+\t    AST::NamedFunctionParam param\n+\t      = parse_named_function_param (std::move (maybe_variadic_attrs));\n+\t    if (param.is_error ())\n+\t      {\n+\t\trust_error_at (t->get_locus (),\n+\t\t\t       \"could not parse named function parameter in \"\n+\t\t\t       \"external function\");\n+\t\tskip_after_semicolon ();\n+\t\treturn nullptr;\n+\t      }\n \t    function_params.push_back (std::move (param));\n \n-\t    if (lexer.peek_token ()->get_id () != COMMA) \n-\t\t    break;\n-      \n+\t    if (lexer.peek_token ()->get_id () != COMMA)\n+\t      break;\n+\n \t    // skip comma\n \t    lexer.skip_token ();\n \t    t = lexer.peek_token ();\n-\t}\n+\t  }\n \n-\tif (!skip_token (RIGHT_PAREN)) {\n+\tif (!skip_token (RIGHT_PAREN))\n+\t  {\n \t    skip_after_semicolon ();\n \t    return nullptr;\n-\t}\n+\t  }\n \n \t// parse (optional) return type\n \tstd::unique_ptr<AST::Type> return_type = parse_function_return_type ();\n@@ -5704,14 +5744,15 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \t    // skip somewhere?\n \t    return nullptr;\n \t  }\n-  \n-  function_params.shrink_to_fit ();\n+\n+\tfunction_params.shrink_to_fit ();\n \n \treturn std::unique_ptr<AST::ExternalFunctionItem> (\n \t  new AST::ExternalFunctionItem (\n \t    std::move (ident), std::move (generic_params),\n \t    std::move (return_type), std::move (where_clause),\n-\t    std::move (function_params), is_variadic, std::move (variadic_attrs), std::move (vis),\n+\t    std::move (function_params), is_variadic,\n+\t    std::move (variadic_attrs), std::move (vis),\n \t    std::move (outer_attrs), locus));\n       }\n     default:\n@@ -5728,7 +5769,8 @@ Parser<ManagedTokenSource>::parse_external_item ()\n  * identifier). */\n template <typename ManagedTokenSource>\n AST::NamedFunctionParam\n-Parser<ManagedTokenSource>::parse_named_function_param (std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_named_function_param (\n+  std::vector<AST::Attribute> outer_attrs)\n {\n   // parse identifier/_\n   std::string name;\n@@ -5766,7 +5808,8 @@ Parser<ManagedTokenSource>::parse_named_function_param (std::vector<AST::Attribu\n       return AST::NamedFunctionParam::create_error ();\n     }\n \n-  return AST::NamedFunctionParam (std::move (name), std::move (param_type), std::move (outer_attrs));\n+  return AST::NamedFunctionParam (std::move (name), std::move (param_type),\n+\t\t\t\t  std::move (outer_attrs));\n }\n \n // Parses a statement (will further disambiguate any statement).\n@@ -6687,7 +6730,8 @@ Parser<ManagedTokenSource>::parse_method ()\n     lexer.skip_token ();\n \n   // parse function parameters\n-  std::vector<AST::FunctionParam> function_params = parse_function_params ([](TokenId id) { return id == RIGHT_PAREN; });\n+  std::vector<AST::FunctionParam> function_params\n+    = parse_function_params ([] (TokenId id) { return id == RIGHT_PAREN; });\n \n   if (!skip_token (RIGHT_PAREN))\n     {\n@@ -7294,12 +7338,12 @@ Parser<ManagedTokenSource>::parse_literal_expr (\n     // use true and false keywords rather than \"bool literal\" Rust terminology\n     case TRUE_LITERAL:\n       type = AST::Literal::BOOL;\n-      literal_value = std::string (\"true\");\n+      literal_value = \"true\";\n       lexer.skip_token ();\n       break;\n     case FALSE_LITERAL:\n       type = AST::Literal::BOOL;\n-      literal_value = std::string (\"false\");\n+      literal_value = \"false\";\n       lexer.skip_token ();\n       break;\n     default:\n@@ -8431,7 +8475,7 @@ Parser<ManagedTokenSource>::parse_array_expr (\n \t      return nullptr;\n \t    }\n \n-    skip_token (RIGHT_SQUARE);\n+\t  skip_token (RIGHT_SQUARE);\n \n \t  std::unique_ptr<AST::ArrayElemsCopied> copied_array_elems (\n \t    new AST::ArrayElemsCopied (std::move (initial_expr),\n@@ -8449,7 +8493,7 @@ Parser<ManagedTokenSource>::parse_array_expr (\n \t  exprs.push_back (std::move (initial_expr));\n \t  exprs.shrink_to_fit ();\n \n-    skip_token (RIGHT_SQUARE);\n+\t  skip_token (RIGHT_SQUARE);\n \n \t  std::unique_ptr<AST::ArrayElemsValues> array_elems (\n \t    new AST::ArrayElemsValues (std::move (exprs)));\n@@ -8543,7 +8587,8 @@ Parser<ManagedTokenSource>::parse_closure_param ()\n \t}\n     }\n \n-  return AST::ClosureParam (std::move (pattern), std::move (type), std::move (outer_attrs));\n+  return AST::ClosureParam (std::move (pattern), std::move (type),\n+\t\t\t    std::move (outer_attrs));\n }\n \n // Parses a grouped or tuple expression (disambiguates).\n@@ -9209,7 +9254,8 @@ Parser<ManagedTokenSource>::parse_for_prefixed_type ()\n // Parses a maybe named param used in bare function types.\n template <typename ManagedTokenSource>\n AST::MaybeNamedParam\n-Parser<ManagedTokenSource>::parse_maybe_named_param (std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_maybe_named_param (\n+  std::vector<AST::Attribute> outer_attrs)\n {\n   /* Basically guess that param is named if first token is identifier or\n    * underscore and second token is semicolon. This should probably have no\n@@ -9262,58 +9308,62 @@ Parser<ManagedTokenSource>::parse_bare_function_type (\n   AST::FunctionQualifiers qualifiers = parse_function_qualifiers ();\n \n   if (!skip_token (FN_TOK))\n-      return nullptr;\n+    return nullptr;\n \n   if (!skip_token (LEFT_PAREN))\n-      return nullptr;\n+    return nullptr;\n \n   // parse function params, if they exist\n   std::vector<AST::MaybeNamedParam> params;\n   bool is_variadic = false;\n   std::vector<AST::Attribute> variadic_attrs;\n \n   const_TokenPtr t = lexer.peek_token ();\n-  while (t->get_id () != RIGHT_PAREN) \n-  {\n-    std::vector<AST::Attribute> temp_attrs = parse_outer_attributes ();\n-\n-    if (lexer.peek_token ()->get_id () == ELLIPSIS) \n+  while (t->get_id () != RIGHT_PAREN)\n     {\n-      lexer.skip_token ();\n-      is_variadic = true;\n-      variadic_attrs = std::move (temp_attrs);\n+      std::vector<AST::Attribute> temp_attrs = parse_outer_attributes ();\n \n-      t = lexer.peek_token ();\n+      if (lexer.peek_token ()->get_id () == ELLIPSIS)\n+\t{\n+\t  lexer.skip_token ();\n+\t  is_variadic = true;\n+\t  variadic_attrs = std::move (temp_attrs);\n \n-      if (t->get_id() != RIGHT_PAREN) \n-      {\n-          rust_error_at (t->get_locus (),\n-\t\t\t\t   \"expected right parentheses after variadic in maybe named function \"\n-           \"parameters, found %qs\",\n-\t\t\t\t   t->get_token_description ());\n-\t\t      return nullptr;\n-      }\n+\t  t = lexer.peek_token ();\n \n-      break;\n-    }\n+\t  if (t->get_id () != RIGHT_PAREN)\n+\t    {\n+\t      rust_error_at (t->get_locus (),\n+\t\t\t     \"expected right parentheses after variadic in \"\n+\t\t\t     \"maybe named function \"\n+\t\t\t     \"parameters, found %qs\",\n+\t\t\t     t->get_token_description ());\n+\t      return nullptr;\n+\t    }\n \n-    AST::MaybeNamedParam param = parse_maybe_named_param (std::move (temp_attrs));\n-    if (param.is_error ()) \n-    {\n-      rust_error_at (lexer.peek_token ()->get_locus (), \"failed to parse maybe named param in bare function type\");\n-      return nullptr;\n-    }\n-    params.push_back (std::move (param));\n+\t  break;\n+\t}\n \n-    if (lexer.peek_token ()->get_id () != COMMA)\n-\t    break;\n+      AST::MaybeNamedParam param\n+\t= parse_maybe_named_param (std::move (temp_attrs));\n+      if (param.is_error ())\n+\t{\n+\t  rust_error_at (\n+\t    lexer.peek_token ()->get_locus (),\n+\t    \"failed to parse maybe named param in bare function type\");\n+\t  return nullptr;\n+\t}\n+      params.push_back (std::move (param));\n \n-    lexer.skip_token ();\n-    t = lexer.peek_token ();\n-  }\n+      if (lexer.peek_token ()->get_id () != COMMA)\n+\tbreak;\n+\n+      lexer.skip_token ();\n+      t = lexer.peek_token ();\n+    }\n \n   if (!skip_token (RIGHT_PAREN))\n-      return nullptr;\n+    return nullptr;\n \n   // bare function return type, if exists\n   std::unique_ptr<AST::TypeNoBounds> return_type = nullptr;\n@@ -9332,9 +9382,11 @@ Parser<ManagedTokenSource>::parse_bare_function_type (\n \t}\n     }\n \n-  return std::unique_ptr<AST::BareFunctionType> (new AST::BareFunctionType (\n-    std::move (for_lifetimes), std::move (qualifiers), std::move (params),\n-    is_variadic, std::move (variadic_attrs), std::move (return_type), best_try_locus));\n+  return std::unique_ptr<AST::BareFunctionType> (\n+    new AST::BareFunctionType (std::move (for_lifetimes),\n+\t\t\t       std::move (qualifiers), std::move (params),\n+\t\t\t       is_variadic, std::move (variadic_attrs),\n+\t\t\t       std::move (return_type), best_try_locus));\n }\n \n // Parses a reference type (mutable or immutable, with given lifetime).\n@@ -10149,13 +10201,13 @@ Parser<ManagedTokenSource>::parse_pattern ()\n \t      // tuple struct\n \t      lexer.skip_token ();\n \n-        // check if empty tuple\n-        if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n-          {\n-            lexer.skip_token ();\n-            return std::unique_ptr<AST::TupleStructPattern> (\n-\t        new AST::TupleStructPattern (std::move (path), nullptr));\n-          }\n+\t      // check if empty tuple\n+\t      if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n+\t\t{\n+\t\t  lexer.skip_token ();\n+\t\t  return std::unique_ptr<AST::TupleStructPattern> (\n+\t\t    new AST::TupleStructPattern (std::move (path), nullptr));\n+\t\t}\n \n \t      // parse items\n \t      std::unique_ptr<AST::TupleStructItems> items\n@@ -10581,13 +10633,13 @@ Parser<ManagedTokenSource>::parse_ident_leading_pattern ()\n \t// DEBUG\n \tfprintf (stderr, \"parsing tuple struct pattern\\n\");\n \n-  // check if empty tuple\n-  if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n-    {\n-      lexer.skip_token ();\n-      return std::unique_ptr<AST::TupleStructPattern> (\n-\t  new AST::TupleStructPattern (std::move (path), nullptr));\n-    }\n+\t// check if empty tuple\n+\tif (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n+\t  {\n+\t    lexer.skip_token ();\n+\t    return std::unique_ptr<AST::TupleStructPattern> (\n+\t      new AST::TupleStructPattern (std::move (path), nullptr));\n+\t  }\n \n \t// parse items\n \tstd::unique_ptr<AST::TupleStructItems> items\n@@ -10841,34 +10893,36 @@ Parser<ManagedTokenSource>::parse_struct_pattern_elems ()\n       std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n \n       // parse etc (must be last in struct pattern, so breaks)\n-      if (lexer.peek_token ()->get_id () == DOT_DOT) \n-      {\n-        lexer.skip_token ();\n-        etc_attrs = std::move (outer_attrs);\n-        has_etc = true;\n-        break;\n-      }\n+      if (lexer.peek_token ()->get_id () == DOT_DOT)\n+\t{\n+\t  lexer.skip_token ();\n+\t  etc_attrs = std::move (outer_attrs);\n+\t  has_etc = true;\n+\t  break;\n+\t}\n \n       std::unique_ptr<AST::StructPatternField> field\n \t= parse_struct_pattern_field_partial (std::move (outer_attrs));\n       if (field == nullptr)\n \t{\n-    rust_error_at (lexer.peek_token ()->get_locus (), \"failed to parse struct pattern field\");\n-    // skip after somewhere?\n-    return AST::StructPatternElements::create_empty ();\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse struct pattern field\");\n+\t  // skip after somewhere?\n+\t  return AST::StructPatternElements::create_empty ();\n \t}\n       fields.push_back (std::move (field));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t  break;\n+\tbreak;\n \n       // skip comma\n       lexer.skip_token ();\n       t = lexer.peek_token ();\n     }\n \n   if (has_etc)\n-    return AST::StructPatternElements (std::move (fields), std::move (etc_attrs));\n+    return AST::StructPatternElements (std::move (fields),\n+\t\t\t\t       std::move (etc_attrs));\n   else\n     return AST::StructPatternElements (std::move (fields));\n }\n@@ -10889,7 +10943,8 @@ Parser<ManagedTokenSource>::parse_struct_pattern_field ()\n  * identifier), with outer attributes passed in. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::StructPatternField>\n-Parser<ManagedTokenSource>::parse_struct_pattern_field_partial (std::vector<AST::Attribute> outer_attrs)\n+Parser<ManagedTokenSource>::parse_struct_pattern_field_partial (\n+  std::vector<AST::Attribute> outer_attrs)\n {\n   // branch based on next token\n   const_TokenPtr t = lexer.peek_token ();\n@@ -11509,7 +11564,8 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n \n \t  return std::unique_ptr<AST::StructExprFieldIdentifierValue> (\n \t    new AST::StructExprFieldIdentifierValue (std::move (ident),\n-\t\t\t\t\t\t     std::move (expr), t->get_locus ()));\n+\t\t\t\t\t\t     std::move (expr),\n+\t\t\t\t\t\t     t->get_locus ()));\n \t}\n       else\n \t{\n@@ -11518,7 +11574,8 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n \t  lexer.skip_token ();\n \n \t  return std::unique_ptr<AST::StructExprFieldIdentifier> (\n-\t    new AST::StructExprFieldIdentifier (std::move (ident), t->get_locus ()));\n+\t    new AST::StructExprFieldIdentifier (std::move (ident),\n+\t\t\t\t\t\tt->get_locus ()));\n \t}\n       case INT_LITERAL: {\n \t// parse tuple index field\n@@ -11542,18 +11599,20 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n \t  }\n \n \treturn std::unique_ptr<AST::StructExprFieldIndexValue> (\n-\t  new AST::StructExprFieldIndexValue (index, std::move (expr), t->get_locus ()));\n+\t  new AST::StructExprFieldIndexValue (index, std::move (expr),\n+\t\t\t\t\t      t->get_locus ()));\n       }\n     case DOT_DOT:\n       /* this is a struct base and can't be parsed here, so just return nothing\n        * without erroring */\n \n       return nullptr;\n     default:\n-      rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token %qs as first token of struct expr field - \"\n-         \"expected identifier or int literal\",\n-\t\t     t->get_token_description ());\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"unrecognised token %qs as first token of struct expr field - \"\n+\t\"expected identifier or int literal\",\n+\tt->get_token_description ());\n       return nullptr;\n     }\n }\n@@ -13686,7 +13745,8 @@ Parser<ManagedTokenSource>::parse_index_expr (\n {\n   // parse RHS (as tok has already been consumed in parse_expression)\n   /*std::unique_ptr<AST::Expr> index_expr\n-    = parse_expr (LBP_ARRAY_REF, std::vector<AST::Attribute> (), restrictions);*/\n+    = parse_expr (LBP_ARRAY_REF, std::vector<AST::Attribute> (),\n+    restrictions);*/\n   // TODO: conceptually, should treat [] as brackets, so just parse all expr\n   std::unique_ptr<AST::Expr> index_expr = parse_expr ();\n   if (index_expr == nullptr)\n@@ -14000,7 +14060,10 @@ Parser<ManagedTokenSource>::parse_struct_expr_struct_partial (\n }\n \n /* Parses a struct expr tuple with a path in expression already parsed (but not\n- * '(' token). */\n+ * '(' token).\n+ * FIXME: this currently outputs a call expr, as they cannot be disambiguated.\n+ * A better solution would be to just get this to call that function directly.\n+ * */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::CallExpr>\n Parser<ManagedTokenSource>::parse_struct_expr_tuple_partial (\n@@ -14294,7 +14357,7 @@ Parser<ManagedTokenSource>::parse_tuple_index_expr_float (\n {\n   // only works on float literals\n   if (tok->get_id () != FLOAT_LITERAL)\n-      return nullptr;\n+    return nullptr;\n \n   // DEBUG:\n   fprintf (stderr, \"exact string form of float: '%s'\\n\","}]}