{"sha": "5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUyYmExOGJjMWUyYTlhNDBmNGRmNDQwM2IxNTVjZDAzYmQ4YjZmOQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-09-25T06:43:52Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-09-25T06:43:52Z"}, "message": "ByteBufferHelper.java: New file.\n\n2003-09-25  Michael Koch  <konqueror@gmx.de>\n\n\t* java/nio/ByteBufferHelper.java:\n\tNew file.\n\t* java/nio/ByteBufferImpl.java,\n\tjava/nio/DirectByteBufferImpl.java,\n\tjava/nio/MappedByteBufferImpl.java\n\t(getType,putType): Use new helper class ByteBufferHelper.\n\t* Makefile.am (ordinary_java_source_files):\n\tAdded java/nio/ByteBufferHelper.java.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r71757", "tree": {"sha": "81dd0bd87f7a397bb4e30b0626a55e4d1459be1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81dd0bd87f7a397bb4e30b0626a55e4d1459be1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9/comments", "author": null, "committer": null, "parents": [{"sha": "e30297734180690f3db8352edc4a6abca305485b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e30297734180690f3db8352edc4a6abca305485b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e30297734180690f3db8352edc4a6abca305485b"}], "stats": {"total": 1106, "additions": 711, "deletions": 395}, "files": [{"sha": "79e8d797d42a89c6241b388c16fc469fbb05afc7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9", "patch": "@@ -1,3 +1,15 @@\n+2003-09-25  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/nio/ByteBufferHelper.java:\n+\tNew file.\n+\t* java/nio/ByteBufferImpl.java,\n+\tjava/nio/DirectByteBufferImpl.java,\n+\tjava/nio/MappedByteBufferImpl.java\n+\t(getType,putType): Use new helper class ByteBufferHelper.\n+\t* Makefile.am (ordinary_java_source_files):\n+\tAdded java/nio/ByteBufferHelper.java.\n+\t* Makefile.in: Regenerated.\n+\n 2003-09-25  Bryce McKinlay  <bryce@mckinlay.net.nz>\n \n \t* gnu/java/net/natPlainSocketImplWin32.cc: Add missing #includes."}, {"sha": "609c38f68e53ba9041311d93e118b2053f39f826", "filename": "libjava/java/nio/ByteBufferHelper.java", "status": "added", "additions": 589, "deletions": 0, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9/libjava%2Fjava%2Fnio%2FByteBufferHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9/libjava%2Fjava%2Fnio%2FByteBufferHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FByteBufferHelper.java?ref=5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9", "patch": "@@ -0,0 +1,589 @@\n+/* ByteBufferImpl.java -- \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio;\n+\n+/**\n+ * @author Michael Koch <konqueror@gmx.de>\n+ */\n+final class ByteBufferHelper\n+{\n+  private static final void checkRemainingForRead (ByteBuffer buffer, int bytes)\n+  {\n+    if (buffer.remaining() < bytes)\n+      throw new BufferUnderflowException();\n+  }\n+  \n+  private static final void checkRemainingForWrite (ByteBuffer buffer, int bytes)\n+  {\n+    if (buffer.remaining() < bytes)\n+      throw new BufferOverflowException();\n+  }\n+\n+  private static final void checkAvailableForRead (ByteBuffer buffer,\n+                                                   int index, int bytes)\n+  {\n+    if (buffer.limit() < (index + bytes))\n+      throw new BufferUnderflowException();\n+  }\n+  \n+  private static final void checkAvailableForWrite (ByteBuffer buffer,\n+                                                    int index, int bytes)\n+  {\n+    if (buffer.limit() < (index + bytes))\n+      throw new BufferOverflowException();\n+  }\n+  \n+  public static final char getChar (ByteBuffer buffer)\n+  {\n+    checkRemainingForRead (buffer, 2);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (char) ((buffer.get() & 0xff)\n+                       + ((buffer.get() & 0xff) << 8));\n+      }\n+    \n+    return (char) (((buffer.get() & 0xff) << 8)\n+                   + (buffer.get() & 0xff));\n+  }\n+  \n+  public static final ByteBuffer putChar (ByteBuffer buffer, char value)\n+  {\n+    checkRemainingForWrite (buffer, 2);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put ((byte) (((int) value) & 0x00ff));\n+        buffer.put ((byte) ((((int) value) & 0xff00) >> 8));\n+      }\n+    else\n+      {\n+        buffer.put ((byte) ((((int) value) & 0xff00) >> 8));\n+        buffer.put ((byte) (((int) value) & 0x00ff));\n+      }\n+\n+    return buffer;\n+  }\n+  \n+  public static final char getChar (ByteBuffer buffer, int index)\n+  {\n+    checkAvailableForRead (buffer, index, 2);\n+    \n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (char) (((buffer.get (index + 1) & 0xff) << 8)\n+                       + (buffer.get (index) & 0xff));\n+      }\n+\n+    return (char) (((buffer.get (index) & 0xff) << 8)\n+                   + (buffer.get (index + 1) & 0xff));\n+  }\n+  \n+  public static final ByteBuffer putChar (ByteBuffer buffer, int index,\n+                                          char value)\n+  {\n+    checkAvailableForWrite (buffer, index, 2);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put (index + 1, (byte) ((((int) value) & 0x00ff) >> 8));\n+        buffer.put (index, (byte) (((int) value) & 0xff00));\n+      }\n+    else\n+      {\n+        buffer.put (index, (byte) ((((int) value) & 0xff00) >> 8));\n+        buffer.put (index + 1, (byte) (((int) value) & 0x00ff));\n+      }\n+    \n+    return buffer;\n+  }\n+\n+  public static final short getShort (ByteBuffer buffer)\n+  {\n+    checkRemainingForRead (buffer, 2);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (short) ((buffer.get() & 0xff)\n+                        + ((buffer.get() & 0xff) << 8));\n+      }\n+\n+    return (short) (((buffer.get() & 0xff) << 8)\n+                    + (buffer.get() & 0xff));\n+  }\n+  \n+  public static final ByteBuffer putShort (ByteBuffer buffer, short value)\n+  {\n+    checkRemainingForWrite (buffer, 2);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put ((byte) (((int) value) & 0x00ff));\n+        buffer.put ((byte) ((((int) value) & 0xff00) >> 8));\n+      }\n+    else\n+      {\n+        buffer.put ((byte) ((((int) value) & 0xff00) >> 8));\n+        buffer.put ((byte) (((int) value) & 0x00ff));\n+      }\n+\n+    return buffer;\n+  }\n+  \n+  public static final short getShort (ByteBuffer buffer, int index)\n+  {\n+    checkAvailableForRead (buffer, index, 2);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (short) ((buffer.get (index) & 0xff)\n+                        + ((buffer.get (index + 1) & 0xff) << 8));\n+      }\n+\n+    return (short) (((buffer.get (index) & 0xff) << 8)\n+                    + (buffer.get (index + 1) & 0xff));\n+  }\n+  \n+  public static final ByteBuffer putShort (ByteBuffer buffer, int index,\n+                                           short value)\n+  {\n+    checkAvailableForWrite (buffer, index, 2);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put (index + 1, (byte) ((((int) value) & 0xff00) >> 8));\n+        buffer.put (index, (byte) (((int) value) & 0x00ff));\n+      }\n+    else\n+      {\n+        buffer.put (index, (byte) ((((int) value) & 0xff00) >> 8));\n+        buffer.put (index + 1, (byte) (((int) value) & 0x00ff));\n+      }\n+    \n+    return buffer;\n+  }\n+\n+  public static final int getInt (ByteBuffer buffer)\n+  {\n+    checkRemainingForRead (buffer, 4);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (int) ((buffer.get() & 0xff)\n+                      + ((buffer.get() & 0xff) << 8)\n+                      + ((buffer.get() & 0xff) << 16)\n+                      + ((buffer.get() & 0xff) << 24));\n+      }\n+\n+    return (int) (((buffer.get() & 0xff) << 24)\n+                  + ((buffer.get() & 0xff) << 16)\n+                  + ((buffer.get() & 0xff) << 8)\n+                  + (buffer.get() & 0xff));\n+  }\n+  \n+  public static final ByteBuffer putInt (ByteBuffer buffer, int value)\n+  {\n+    checkRemainingForWrite (buffer, 4);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put ((byte) (value & 0x000000ff));\n+        buffer.put ((byte) ((value & 0x0000ff00) >> 8));\n+        buffer.put ((byte) ((value & 0x00ff0000) >> 16));\n+        buffer.put ((byte) ((value & 0xff000000) >> 24));\n+      }\n+    else\n+      {\n+        buffer.put ((byte) ((value & 0xff000000) >> 24));\n+        buffer.put ((byte) ((value & 0x00ff0000) >> 16));\n+        buffer.put ((byte) ((value & 0x0000ff00) >> 8));\n+        buffer.put ((byte) (value & 0x000000ff));\n+      }\n+    \n+    return buffer;\n+  }\n+  \n+  public static final int getInt (ByteBuffer buffer, int index)\n+  {\n+    checkAvailableForRead (buffer, index, 4);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (int) ((buffer.get (index) & 0xff))\n+                      + ((buffer.get (index + 1) & 0xff) << 8)\n+                      + ((buffer.get (index + 2) & 0xff) << 16)\n+                      + ((buffer.get (index + 3) & 0xff) << 24);\n+      }\n+\n+    return (int) (((buffer.get (index) & 0xff) << 24)\n+                  + ((buffer.get (index + 1) & 0xff) << 16)\n+                  + ((buffer.get (index + 2) & 0xff) << 8)\n+                  + (buffer.get (index + 3) & 0xff));\n+  }\n+  \n+  public static final ByteBuffer putInt (ByteBuffer buffer, int index,\n+                                         int value)\n+  {\n+    checkAvailableForWrite (buffer, index, 4);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put (index + 3, (byte) ((value & 0xff000000) >> 24));\n+        buffer.put (index + 2, (byte) ((value & 0x00ff0000) >> 16));\n+        buffer.put (index + 1, (byte) ((value & 0x0000ff00) >> 8));\n+        buffer.put (index, (byte) (value & 0x000000ff));\n+      }\n+    else\n+      {\n+        buffer.put (index, (byte) ((value & 0xff000000) >> 24));\n+        buffer.put (index + 1, (byte) ((value & 0x00ff0000) >> 16));\n+        buffer.put (index + 2, (byte) ((value & 0x0000ff00) >> 8));\n+        buffer.put (index + 3, (byte) (value & 0x000000ff));\n+      }\n+  \n+    return buffer;\n+  }\n+\n+  public static final long getLong (ByteBuffer buffer)\n+  {\n+    checkRemainingForRead (buffer, 8);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (long) (((buffer.get() & 0xff))\n+                       + ((buffer.get() & 0xff) << 8)\n+                       + ((buffer.get() & 0xff) << 16)\n+                       + ((buffer.get() & 0xff) << 24)\n+                       + ((buffer.get() & 0xff) << 32)\n+                       + ((buffer.get() & 0xff) << 40)\n+                       + ((buffer.get() & 0xff) << 48)\n+                       + ((buffer.get() & 0xff) << 56));\n+      }\n+\n+    return (long) (((buffer.get() & 0xff) << 56)\n+                   + ((buffer.get() & 0xff) << 48)\n+                   + ((buffer.get() & 0xff) << 40)\n+                   + ((buffer.get() & 0xff) << 32)\n+                   + ((buffer.get() & 0xff) << 24)\n+                   + ((buffer.get() & 0xff) << 16)\n+                   + ((buffer.get() & 0xff) << 8)\n+                   + (buffer.get() & 0xff));\n+  }\n+  \n+  public static final ByteBuffer putLong (ByteBuffer buffer, long value)\n+  {\n+    checkRemainingForWrite (buffer, 8);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put ((byte) (value & 0xff00000000000000L));\n+        buffer.put ((byte) ((value & 0x00ff000000000000L) >> 8));\n+        buffer.put ((byte) ((value & 0x0000ff0000000000L) >> 16));\n+        buffer.put ((byte) ((value & 0x000000ff00000000L) >> 24));\n+        buffer.put ((byte) ((value & 0x00000000ff000000L) >> 32));\n+        buffer.put ((byte) ((value & 0x0000000000ff0000L) >> 40));\n+        buffer.put ((byte) ((value & 0x000000000000ff00L) >> 48));\n+        buffer.put ((byte) ((value & 0x00000000000000ffL) >> 56));\n+      }\n+    else\n+      {\n+        buffer.put ((byte) ((value & 0xff00000000000000L) >> 56));\n+        buffer.put ((byte) ((value & 0x00ff000000000000L) >> 48));\n+        buffer.put ((byte) ((value & 0x0000ff0000000000L) >> 40));\n+        buffer.put ((byte) ((value & 0x000000ff00000000L) >> 32));\n+        buffer.put ((byte) ((value & 0x00000000ff000000L) >> 24));\n+        buffer.put ((byte) ((value & 0x0000000000ff0000L) >> 16));\n+        buffer.put ((byte) ((value & 0x000000000000ff00L) >> 8));\n+        buffer.put ((byte) (value & 0x00000000000000ffL));\n+      }\n+    \n+    return buffer;\n+  }\n+  \n+  public static final long getLong (ByteBuffer buffer, int index)\n+  {\n+    checkAvailableForRead (buffer, index, 8);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (long) ((buffer.get (index) & 0xff)\n+                       + ((buffer.get (index + 1) & 0xff) << 8)\n+                       + ((buffer.get (index + 2) & 0xff) << 16)\n+                       + ((buffer.get (index + 3) & 0xff) << 24)\n+                       + ((buffer.get (index + 4) & 0xff) << 32)\n+                       + ((buffer.get (index + 5) & 0xff) << 40)\n+                       + ((buffer.get (index + 6) & 0xff) << 48)\n+                       + ((buffer.get (index + 7) & 0xff) << 56));\n+      }\n+\n+    return (long) (((buffer.get (index) & 0xff) << 56)\n+                   + ((buffer.get (index + 1) & 0xff) << 48)\n+                   + ((buffer.get (index + 2) & 0xff) << 40)\n+                   + ((buffer.get (index + 3) & 0xff) << 32)\n+                   + ((buffer.get (index + 4) & 0xff) << 24)\n+                   + ((buffer.get (index + 5) & 0xff) << 16)\n+                   + ((buffer.get (index + 6) & 0xff) << 8)\n+                   + (buffer.get (index + 7) & 0xff));\n+  }\n+  \n+  public static final ByteBuffer putLong (ByteBuffer buffer, int index,\n+                                          long value)\n+  {\n+    checkAvailableForWrite (buffer, index, 8);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put (index + 7, (byte) ((value & 0xff00000000000000L) >> 56));\n+        buffer.put (index + 6, (byte) ((value & 0x00ff000000000000L) >> 48));\n+        buffer.put (index + 5, (byte) ((value & 0x0000ff0000000000L) >> 40));\n+        buffer.put (index + 4, (byte) ((value & 0x000000ff00000000L) >> 32));\n+        buffer.put (index + 3, (byte) ((value & 0x00000000ff000000L) >> 24));\n+        buffer.put (index + 2, (byte) ((value & 0x0000000000ff0000L) >> 16));\n+        buffer.put (index + 1, (byte) ((value & 0x000000000000ff00L) >> 8));\n+        buffer.put (index, (byte) (value & 0x00000000000000ffL));\n+      }\n+    else\n+      {\n+        buffer.put (index, (byte) ((value & 0xff00000000000000L) >> 56));\n+        buffer.put (index + 1, (byte) ((value & 0x00ff000000000000L) >> 48));\n+        buffer.put (index + 2, (byte) ((value & 0x0000ff0000000000L) >> 40));\n+        buffer.put (index + 3, (byte) ((value & 0x000000ff00000000L) >> 32));\n+        buffer.put (index + 4, (byte) ((value & 0x00000000ff000000L) >> 24));\n+        buffer.put (index + 5, (byte) ((value & 0x0000000000ff0000L) >> 16));\n+        buffer.put (index + 6, (byte) ((value & 0x000000000000ff00L) >> 8));\n+        buffer.put (index + 7, (byte) (value & 0x00000000000000ffL));\n+      }\n+    \n+    return buffer;\n+  }\n+\n+  public static final float getFloat (ByteBuffer buffer)\n+  {\n+    checkRemainingForRead (buffer, 4);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (float) ((buffer.get() & 0xff)\n+                        + ((buffer.get() & 0xff) << 8)\n+                        + ((buffer.get() & 0xff) << 16)\n+                        + ((buffer.get() & 0xff) << 24));\n+      }\n+\n+    return (float) (((buffer.get() & 0xff) << 24)\n+                    + ((buffer.get() & 0xff) << 16)\n+                    + ((buffer.get() & 0xff) << 8)\n+                    + (buffer.get() & 0xff));\n+  }\n+  \n+  public static final ByteBuffer putFloat (ByteBuffer buffer, float value)\n+  {\n+    checkRemainingForWrite (buffer, 4);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put ((byte) (((int) value) & 0xff000000));\n+        buffer.put ((byte) ((((int) value) & 0x00ff0000) >> 8));\n+        buffer.put ((byte) ((((int) value) & 0x0000ff00) >> 16));\n+        buffer.put ((byte) ((((int) value) & 0x000000ff) >> 24));\n+      }\n+    else\n+      {\n+        buffer.put ((byte) ((((int) value) & 0xff000000) >> 24));\n+        buffer.put ((byte) ((((int) value) & 0x00ff0000) >> 16));\n+        buffer.put ((byte) ((((int) value) & 0x0000ff00) >> 8));\n+        buffer.put ((byte) (((int) value) & 0x000000ff));\n+      }\n+\n+    return buffer;\n+  }\n+  \n+  public static final float getFloat (ByteBuffer buffer, int index)\n+  {\n+    checkAvailableForRead (buffer, index, 4);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (float) ((buffer.get (index) & 0xff)\n+                        + ((buffer.get (index + 1) & 0xff) << 8)\n+                        + ((buffer.get (index + 2) & 0xff) << 16)\n+                        + ((buffer.get (index + 3) & 0xff) << 24));\n+      }\n+\n+    return (float) (((buffer.get (index) & 0xff) << 24)\n+                    + ((buffer.get (index + 1) & 0xff) << 16)\n+                    + ((buffer.get (index + 2) & 0xff) << 8)\n+                    + (buffer.get (index + 3) & 0xff));\n+  }\n+\n+  public static final ByteBuffer putFloat (ByteBuffer buffer, int index,\n+                                           float value)\n+  {\n+    checkAvailableForWrite (buffer, index, 4);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put (index + 3, (byte) ((((int) value) & 0xff000000) >> 24));\n+        buffer.put (index + 2, (byte) ((((int) value) & 0x00ff0000) >> 16));\n+        buffer.put (index + 1, (byte) ((((int) value) & 0x0000ff00) >> 8));\n+        buffer.put (index, (byte) (((int) value) & 0x000000ff));\n+      }\n+    else\n+      {\n+        buffer.put (index, (byte) ((((int) value) & 0xff000000) >> 24));\n+        buffer.put (index + 1, (byte) ((((int) value) & 0x00ff0000) >> 16));\n+        buffer.put (index + 2, (byte) ((((int) value) & 0x0000ff00) >> 8));\n+        buffer.put (index + 3, (byte) (((int) value) & 0x000000ff));\n+      }\n+\n+    return buffer;\n+  }\n+\n+  public static final double getDouble (ByteBuffer buffer)\n+  {\n+    checkRemainingForRead (buffer, 8);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (double) ((buffer.get() & 0xff)\n+                         + ((buffer.get() & 0xff) << 8)\n+                         + ((buffer.get() & 0xff) << 16)\n+                         + ((buffer.get() & 0xff) << 24)\n+                         + ((buffer.get() & 0xff) << 32)\n+                         + ((buffer.get() & 0xff) << 40)\n+                         + ((buffer.get() & 0xff) << 48)\n+                         + ((buffer.get() & 0xff) << 56));\n+      }\n+\n+    return (double) (((buffer.get() & 0xff) << 56)\n+                     + ((buffer.get() & 0xff) << 48)\n+                     + ((buffer.get() & 0xff) << 40)\n+                     + ((buffer.get() & 0xff) << 32)\n+                     + ((buffer.get() & 0xff) << 24)\n+                     + ((buffer.get() & 0xff) << 16)\n+                     + ((buffer.get() & 0xff) << 8)\n+                     + (buffer.get() & 0xff));\n+  }\n+\n+  public static final ByteBuffer putDouble (ByteBuffer buffer, double value)\n+  {\n+    checkRemainingForWrite (buffer, 8);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put ((byte) (((long) value) & 0xff00000000000000L));\n+        buffer.put ((byte) ((((long) value) & 0x00ff000000000000L) >> 8));\n+        buffer.put ((byte) ((((long) value) & 0x0000ff0000000000L) >> 16));\n+        buffer.put ((byte) ((((long) value) & 0x000000ff00000000L) >> 24));\n+        buffer.put ((byte) ((((long) value) & 0x00000000ff000000L) >> 32));\n+        buffer.put ((byte) ((((long) value) & 0x0000000000ff0000L) >> 40));\n+        buffer.put ((byte) ((((long) value) & 0x000000000000ff00L) >> 48));\n+        buffer.put ((byte) ((((long) value) & 0x00000000000000ffL) >> 56));\n+      }\n+    else\n+      {\n+        buffer.put ((byte) ((((long) value) & 0xff00000000000000L) >> 56));\n+        buffer.put ((byte) ((((long) value) & 0x00ff000000000000L) >> 48));\n+        buffer.put ((byte) ((((long) value) & 0x0000ff0000000000L) >> 40));\n+        buffer.put ((byte) ((((long) value) & 0x000000ff00000000L) >> 32));\n+        buffer.put ((byte) ((((long) value) & 0x00000000ff000000L) >> 24));\n+        buffer.put ((byte) ((((long) value) & 0x0000000000ff0000L) >> 16));\n+        buffer.put ((byte) ((((long) value) & 0x000000000000ff00L) >> 8));\n+        buffer.put ((byte) (((long) value) & 0x00000000000000ffL));\n+      }\n+    \n+    return buffer;\n+  }\n+  \n+  public static final double getDouble (ByteBuffer buffer, int index)\n+  {\n+    checkAvailableForRead (buffer, index, 8);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        return (double) ((buffer.get (index) & 0xff)\n+                         + ((buffer.get (index + 1) & 0xff) << 8)\n+                         + ((buffer.get (index + 2) & 0xff) << 16)\n+                         + ((buffer.get (index + 3) & 0xff) << 24)\n+                         + ((buffer.get (index + 4) & 0xff) << 32)\n+                         + ((buffer.get (index + 5) & 0xff) << 40)\n+                         + ((buffer.get (index + 6) & 0xff) << 48)\n+                         + ((buffer.get (index + 7) & 0xff) << 56));\n+      }\n+\n+    return (double) (((buffer.get (index) & 0xff) << 56)\n+                     + ((buffer.get (index + 1) & 0xff) << 48)\n+                     + ((buffer.get (index + 2) & 0xff) << 40)\n+                     + ((buffer.get (index + 3) & 0xff) << 32)\n+                     + ((buffer.get (index + 4) & 0xff) << 24)\n+                     + ((buffer.get (index + 5) & 0xff) << 16)\n+                     + ((buffer.get (index + 6) & 0xff) << 8)\n+                     + (buffer.get (index + 7) & 0xff));\n+  }\n+  \n+  public static final ByteBuffer putDouble (ByteBuffer buffer, int index,\n+                                            double value)\n+  {\n+    checkAvailableForWrite (buffer, index, 8);\n+\n+    if (buffer.order() == ByteOrder.LITTLE_ENDIAN)\n+      {\n+        buffer.put (index + 7, (byte) ((((long) value) & 0xff00000000000000L) >> 56));\n+        buffer.put (index + 6, (byte) ((((long) value) & 0x00ff000000000000L) >> 48));\n+        buffer.put (index + 5, (byte) ((((long) value) & 0x0000ff0000000000L) >> 40));\n+        buffer.put (index + 4, (byte) ((((long) value) & 0x000000ff00000000L) >> 32));\n+        buffer.put (index + 3, (byte) ((((long) value) & 0x00000000ff000000L) >> 24));\n+        buffer.put (index + 2, (byte) ((((long) value) & 0x0000000000ff0000L) >> 16));\n+        buffer.put (index + 1, (byte) ((((long) value) & 0x000000000000ff00L) >> 8));\n+        buffer.put (index, (byte) (((long) value) & 0x00000000000000ffL));\n+      }\n+    else\n+      {\n+        buffer.put (index, (byte) ((((long) value) & 0xff00000000000000L) >> 56));\n+        buffer.put (index + 1, (byte) ((((long) value) & 0x00ff000000000000L) >> 48));\n+        buffer.put (index + 2, (byte) ((((long) value) & 0x0000ff0000000000L) >> 40));\n+        buffer.put (index + 3, (byte) ((((long) value) & 0x000000ff00000000L) >> 32));\n+        buffer.put (index + 4, (byte) ((((long) value) & 0x00000000ff000000L) >> 24));\n+        buffer.put (index + 5, (byte) ((((long) value) & 0x0000000000ff0000L) >> 16));\n+        buffer.put (index + 6, (byte) ((((long) value) & 0x000000000000ff00L) >> 8));\n+        buffer.put (index + 7, (byte) (((long) value) & 0x00000000000000ffL));\n+      }\n+    \n+    return buffer;\n+  }\n+\n+} // ByteBufferHelper"}, {"sha": "76c965d73224152a99248f82b6ad39ace0143411", "filename": "libjava/java/nio/ByteBufferImpl.java", "status": "modified", "additions": 25, "deletions": 217, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9/libjava%2Fjava%2Fnio%2FByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9/libjava%2Fjava%2Fnio%2FByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FByteBufferImpl.java?ref=5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9", "patch": "@@ -182,313 +182,121 @@ final public ByteBuffer put (int index, byte value)\n   \n   final public char getChar ()\n   {\n-    if (remaining() < 2)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (char) (((get () & 0xff) << 8)\n-                   + (get () & 0xff));\n+    return ByteBufferHelper.getChar (this);\n   }\n   \n   final public ByteBuffer putChar (char value)\n   {\n-    if (remaining() < 2)\n-      throw new BufferOverflowException();\n-\n-    // FIXME: this handles little endian only\n-    put ((byte) ((((int) value) & 0xff00) >> 8));\n-    put ((byte) (((int) value) & 0x00ff));\n-    return this;\n+    return ByteBufferHelper.putChar (this, value);\n   }\n   \n   final public char getChar (int index)\n   {\n-    if (remaining() < 2)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (char) (((get (index) & 0xff) << 8) + (get (index + 1) & 0xff));\n+    return ByteBufferHelper.getChar (this, index);\n   }\n   \n   final public ByteBuffer putChar (int index, char value)\n   {\n-    if (remaining() < 2)\n-      throw new BufferOverflowException();\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((((int) value) & 0xff00) >> 8));\n-    put (index + 1, (byte) (((int) value) & 0x00ff));\n-    return this;\n+    return ByteBufferHelper.putChar (this, index, value);\n   }\n \n   final public short getShort ()\n   {\n-    if (remaining() < 2)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (short) (((get () & 0xff) << 8) + (get () & 0xff));\n+    return ByteBufferHelper.getShort (this);\n   }\n   \n   final public ByteBuffer putShort (short value)\n   {\n-    if (remaining() < 2)\n-      throw new BufferOverflowException();\n-\n-    // FIXME: this handles little endian only\n-    put ((byte) ((((int) value) & 0xff00) >> 8));\n-    put ((byte) (((int) value) & 0x00ff));\n-    return this;\n+    return ByteBufferHelper.putShort (this, value);\n   }\n   \n   final public short getShort (int index)\n   {\n-    if (remaining() < 2)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (short) (((get (index) & 0xff) << 8) + (get (index + 1) & 0xff));\n+    return ByteBufferHelper.getShort (this, index);\n   }\n   \n   final public ByteBuffer putShort (int index, short value)\n   {\n-    if (remaining() < 2)\n-      throw new BufferOverflowException();\n-\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((((int) value) & 0xff00) >> 8));\n-    put (index + 1, (byte) (((int) value) & 0x00ff));\n-    return this;\n+    return ByteBufferHelper.putShort (this, index, value);\n   }\n \n   final public int getInt ()\n   {\n-    if (remaining() < 4)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (int) (((get () & 0xff) << 24)\n-                  + ((get () & 0xff) << 16)\n-                  + ((get () & 0xff) << 8)\n-                  + (get () & 0xff));\n+    return ByteBufferHelper.getInt (this);\n   }\n   \n   final public ByteBuffer putInt (int value)\n   {\n-    if (remaining() < 4)\n-      throw new BufferOverflowException();\n-\n-    // FIXME: this handles little endian only\n-    put ((byte) ((value & 0xff000000) >> 24));\n-    put ((byte) ((value & 0x00ff0000) >> 16));\n-    put ((byte) ((value & 0x0000ff00) >> 8));\n-    put ((byte) (value & 0x000000ff));\n-    return this;\n+    return ByteBufferHelper.putInt (this, value);\n   }\n   \n   final public int getInt (int index)\n   {\n-    if (remaining() < 4)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (int) (((get (index) & 0xff) << 24)\n-                  + ((get (index + 1) & 0xff) << 16)\n-                  + ((get (index + 2) & 0xff) << 8)\n-                  + (get (index + 3) & 0xff));\n+    return ByteBufferHelper.getInt (this, index);\n   }\n   \n   final public ByteBuffer putInt (int index, int value)\n   {\n-    if (remaining() < 4)\n-      throw new BufferOverflowException();\n-\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((value & 0xff000000) >> 24));\n-    put (index + 1, (byte) ((value & 0x00ff0000) >> 16));\n-    put (index + 2, (byte) ((value & 0x0000ff00) >> 8));\n-    put (index + 3, (byte) (value & 0x000000ff));\n-    return this;\n+    return ByteBufferHelper.putInt (this, index, value);\n   }\n \n   final public long getLong ()\n   {\n-    if (remaining() < 8)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (long) (((get () & 0xff) << 56)\n-                   + ((get () & 0xff) << 48)\n-                   + ((get () & 0xff) << 40)\n-                   + ((get () & 0xff) << 32)\n-                   + ((get () & 0xff) << 24)\n-                   + ((get () & 0xff) << 16)\n-                   + ((get () & 0xff) << 8)\n-                   + (get () & 0xff));\n+    return ByteBufferHelper.getLong (this);\n   }\n   \n   final public ByteBuffer putLong (long value)\n   {\n-    if (remaining() < 8)\n-      throw new BufferOverflowException();\n-\n-    // FIXME: this handles little endian only\n-    put ((byte) ((value & 0xff00000000000000L) >> 56));\n-    put ((byte) ((value & 0x00ff000000000000L) >> 48));\n-    put ((byte) ((value & 0x0000ff0000000000L) >> 40));\n-    put ((byte) ((value & 0x000000ff00000000L) >> 32));\n-    put ((byte) ((value & 0x00000000ff000000L) >> 24));\n-    put ((byte) ((value & 0x0000000000ff0000L) >> 16));\n-    put ((byte) ((value & 0x000000000000ff00L) >> 8));\n-    put ((byte) (value & 0x00000000000000ffL));\n-    return this;\n+    return ByteBufferHelper.putLong (this, value);\n   }\n   \n   final public long getLong (int index)\n   {\n-    if (remaining() < 8)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (long) (((get (index) & 0xff) << 56)\n-                   + ((get (index + 1) & 0xff) << 48)\n-                   + ((get (index + 2) & 0xff) << 40)\n-                   + ((get (index + 3) & 0xff) << 32)\n-                   + ((get (index + 4) & 0xff) << 24)\n-                   + ((get (index + 5) & 0xff) << 16)\n-                   + ((get (index + 6) & 0xff) << 8)\n-                   + (get (index + 7) & 0xff));\n+    return ByteBufferHelper.getLong (this, index);\n   }\n   \n   final public ByteBuffer putLong (int index, long value)\n   {\n-    if (remaining() < 8)\n-      throw new BufferOverflowException();\n-\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((value & 0xff00000000000000L) >> 56));\n-    put (index + 1, (byte) ((value & 0x00ff000000000000L) >> 48));\n-    put (index + 2, (byte) ((value & 0x0000ff0000000000L) >> 40));\n-    put (index + 3, (byte) ((value & 0x000000ff00000000L) >> 32));\n-    put (index + 4, (byte) ((value & 0x00000000ff000000L) >> 24));\n-    put (index + 5, (byte) ((value & 0x0000000000ff0000L) >> 16));\n-    put (index + 6, (byte) ((value & 0x000000000000ff00L) >> 8));\n-    put (index + 7, (byte) (value & 0x00000000000000ffL));\n-    return this;\n+    return ByteBufferHelper.putLong (this, index, value);\n   }\n \n   final public float getFloat ()\n   {\n-    if (remaining() < 4)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (float) (((get () & 0xff) << 24)\n-                    + ((get () & 0xff) << 16)\n-                    + ((get () & 0xff) << 8)\n-                    + (get () & 0xff));\n+    return ByteBufferHelper.getFloat (this);\n   }\n   \n   final public ByteBuffer putFloat (float value)\n   {\n-    if (remaining() < 4)\n-      throw new BufferOverflowException();\n-\n-    // FIXME: this handles little endian only\n-    put ((byte) ((((int) value) & 0xff000000) >> 24));\n-    put ((byte) ((((int) value) & 0x00ff0000) >> 16));\n-    put ((byte) ((((int) value) & 0x0000ff00) >> 8));\n-    put ((byte) (((int) value) & 0x000000ff));\n-    return this;\n+    return ByteBufferHelper.putFloat (this, value);\n   }\n   \n   final public float getFloat (int index)\n   {\n-    if (remaining() < 4)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (float) (((get (index) & 0xff) << 24)\n-                    + ((get (index + 1) & 0xff) << 16)\n-                    + ((get (index + 2) & 0xff) << 8)\n-                    + (get (index + 3) & 0xff));\n+    return ByteBufferHelper.getFloat (this, index);\n   }\n \n-  final public ByteBuffer putFloat (int index, float value)\n+  public final ByteBuffer putFloat (int index, float value)\n   {\n-    if (remaining() < 4)\n-      throw new BufferOverflowException();\n-\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((((int) value) & 0xff000000) >> 24));\n-    put (index + 1, (byte) ((((int) value) & 0x00ff0000) >> 16));\n-    put (index + 2, (byte) ((((int) value) & 0x0000ff00) >> 8));\n-    put (index + 3, (byte) (((int) value) & 0x000000ff));\n-    return this;\n+    return ByteBufferHelper.putFloat (this, index, value);\n   }\n \n   final public double getDouble ()\n   {\n-    if (remaining() < 8)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (double) (((get () & 0xff) << 56)\n-                     + ((get () & 0xff) << 48)\n-                     + ((get () & 0xff) << 40)\n-                     + ((get () & 0xff) << 32)\n-                     + ((get () & 0xff) << 24)\n-                     + ((get () & 0xff) << 16)\n-                     + ((get () & 0xff) << 8)\n-                     + (get () & 0xff));\n+    return ByteBufferHelper.getDouble (this);\n   }\n \n   final public ByteBuffer putDouble (double value)\n   {\n-    if (remaining() < 8)\n-      throw new BufferOverflowException();\n-\n-    // FIXME: this handles little endian only\n-    put ((byte) ((((long) value) & 0xff00000000000000L) >> 56));\n-    put ((byte) ((((long) value) & 0x00ff000000000000L) >> 48));\n-    put ((byte) ((((long) value) & 0x0000ff0000000000L) >> 40));\n-    put ((byte) ((((long) value) & 0x000000ff00000000L) >> 32));\n-    put ((byte) ((((long) value) & 0x00000000ff000000L) >> 24));\n-    put ((byte) ((((long) value) & 0x0000000000ff0000L) >> 16));\n-    put ((byte) ((((long) value) & 0x000000000000ff00L) >> 8));\n-    put ((byte) (((long) value) & 0x00000000000000ffL));\n-    return this;\n+    return ByteBufferHelper.putDouble (this, value);\n   }\n   \n   final public double getDouble (int index)\n   {\n-    if (remaining() < 8)\n-      throw new BufferUnderflowException();\n-\n-    // FIXME: this handles little endian only\n-    return (double) (((get (index) & 0xff) << 56)\n-                     + ((get (index + 1) & 0xff) << 48)\n-                     + ((get (index + 2) & 0xff) << 40)\n-                     + ((get (index + 3) & 0xff) << 32)\n-                     + ((get (index + 4) & 0xff) << 24)\n-                     + ((get (index + 5) & 0xff) << 16)\n-                     + ((get (index + 6) & 0xff) << 8)\n-                     + (get (index + 7) & 0xff));\n+    return ByteBufferHelper.getDouble (this, index);\n   }\n   \n   final public ByteBuffer putDouble (int index, double value)\n   {\n-    if (remaining() < 8)\n-      throw new BufferOverflowException();\n-\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((((long) value) & 0xff00000000000000L) >> 56));\n-    put (index + 1, (byte) ((((long) value) & 0x00ff000000000000L) >> 48));\n-    put (index + 2, (byte) ((((long) value) & 0x0000ff0000000000L) >> 40));\n-    put (index + 3, (byte) ((((long) value) & 0x000000ff00000000L) >> 32));\n-    put (index + 4, (byte) ((((long) value) & 0x00000000ff000000L) >> 24));\n-    put (index + 5, (byte) ((((long) value) & 0x0000000000ff0000L) >> 16));\n-    put (index + 6, (byte) ((((long) value) & 0x000000000000ff00L) >> 8));\n-    put (index + 7, (byte) (((long) value) & 0x00000000000000ffL));\n-    return this;\n+    return ByteBufferHelper.putDouble (this, index, value);\n   }\n }"}, {"sha": "4028b545d2591d83aa04e70dfaaf17765a01f081", "filename": "libjava/java/nio/DirectByteBufferImpl.java", "status": "modified", "additions": 12, "deletions": 90, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java?ref=5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9", "patch": "@@ -292,134 +292,56 @@ final public long getLong ()\n   \n   final public ByteBuffer putLong (long value)\n   {\n-    // FIXME: this handles little endian only\n-    put ((byte) ((value & 0xff00000000000000L) >> 56));\n-    put ((byte) ((value & 0x00ff000000000000L) >> 48));\n-    put ((byte) ((value & 0x0000ff0000000000L) >> 40));\n-    put ((byte) ((value & 0x000000ff00000000L) >> 32));\n-    put ((byte) ((value & 0x00000000ff000000L) >> 24));\n-    put ((byte) ((value & 0x0000000000ff0000L) >> 16));\n-    put ((byte) ((value & 0x000000000000ff00L) >> 8));\n-    put ((byte) (value & 0x00000000000000ffL));\n-    return this;\n+    return ByteBufferHelper.putLong (this, value);\n   }\n   \n   final public long getLong (int index)\n   {\n-    // FIXME: this handles little endian only\n-    return (long) (((get (index) & 0xff) << 56)\n-                   + ((get (index + 1) & 0xff) << 48)\n-                   + ((get (index + 2) & 0xff) << 40)\n-                   + ((get (index + 3) & 0xff) << 32)\n-                   + ((get (index + 4) & 0xff) << 24)\n-                   + ((get (index + 5) & 0xff) << 16)\n-                   + ((get (index + 6) & 0xff) << 8)\n-                   + (get (index + 7) & 0xff));\n+    return ByteBufferHelper.getLong (this, index);\n   }\n   \n   final public ByteBuffer putLong (int index, long value)\n   {\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((value & 0xff00000000000000L) >> 56));\n-    put (index + 1, (byte) ((value & 0x00ff000000000000L) >> 48));\n-    put (index + 2, (byte) ((value & 0x0000ff0000000000L) >> 40));\n-    put (index + 3, (byte) ((value & 0x000000ff00000000L) >> 32));\n-    put (index + 4, (byte) ((value & 0x00000000ff000000L) >> 24));\n-    put (index + 5, (byte) ((value & 0x0000000000ff0000L) >> 16));\n-    put (index + 6, (byte) ((value & 0x000000000000ff00L) >> 8));\n-    put (index + 7, (byte) (value & 0x00000000000000ffL));\n-    return this;\n+    return ByteBufferHelper.putLong (this, index, value);\n   }\n \n   final public float getFloat ()\n   {\n-    // FIXME: this handles little endian only\n-    return (float) (((get () & 0xff) << 24)\n-                    + ((get () & 0xff) << 16)\n-                    + ((get () & 0xff) << 8)\n-                    + (get () & 0xff));\n+    return ByteBufferHelper.getFloat (this);\n   }\n   \n   final public ByteBuffer putFloat (float value)\n   {\n-    // FIXME: this handles little endian only\n-    put ((byte) ((((int) value) & 0xff000000) >> 24));\n-    put ((byte) ((((int) value) & 0x00ff0000) >> 16));\n-    put ((byte) ((((int) value) & 0x0000ff00) >> 8));\n-    put ((byte) (((int) value) & 0x000000ff));\n-    return this;\n+    return ByteBufferHelper.putFloat (this, value);\n   }\n   \n-  final public float getFloat (int index)\n+  public final float getFloat (int index)\n   {\n-    // FIXME: this handles little endian only\n-    return (float) (((get (index) & 0xff) << 24)\n-                    + ((get (index + 1) & 0xff) << 16)\n-                    + ((get (index + 2) & 0xff) << 8)\n-                    + (get (index + 3) & 0xff));\n+    return ByteBufferHelper.getFloat (this, index);\n   }\n \n   final public ByteBuffer putFloat (int index, float value)\n   {\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((((int) value) & 0xff000000) >> 24));\n-    put (index + 1, (byte) ((((int) value) & 0x00ff0000) >> 16));\n-    put (index + 2, (byte) ((((int) value) & 0x0000ff00) >> 8));\n-    put (index + 3, (byte) (((int) value) & 0x000000ff));\n-    return this;\n+    return ByteBufferHelper.putFloat (this, index, value);\n   }\n \n   final public double getDouble ()\n   {\n-    // FIXME: this handles little endian only\n-    return (double) (((get () & 0xff) << 56)\n-                     + ((get () & 0xff) << 48)\n-                     + ((get () & 0xff) << 40)\n-                     + ((get () & 0xff) << 32)\n-                     + ((get () & 0xff) << 24)\n-                     + ((get () & 0xff) << 16)\n-                     + ((get () & 0xff) << 8)\n-                     + (get () & 0xff));\n+    return ByteBufferHelper.getDouble (this);\n   }\n \n   final public ByteBuffer putDouble (double value)\n   {\n-    // FIXME: this handles little endian only\n-    put ((byte) ((((long) value) & 0xff00000000000000L) >> 56));\n-    put ((byte) ((((long) value) & 0x00ff000000000000L) >> 48));\n-    put ((byte) ((((long) value) & 0x0000ff0000000000L) >> 40));\n-    put ((byte) ((((long) value) & 0x000000ff00000000L) >> 32));\n-    put ((byte) ((((long) value) & 0x00000000ff000000L) >> 24));\n-    put ((byte) ((((long) value) & 0x0000000000ff0000L) >> 16));\n-    put ((byte) ((((long) value) & 0x000000000000ff00L) >> 8));\n-    put ((byte) (((long) value) & 0x00000000000000ffL));\n-    return this;\n+    return ByteBufferHelper.putDouble (this, value);\n   }\n   \n   final public double getDouble (int index)\n   {\n-    // FIXME: this handles little endian only\n-    return (double) (((get (index) & 0xff) << 56)\n-                     + ((get (index + 1) & 0xff) << 48)\n-                     + ((get (index + 2) & 0xff) << 40)\n-                     + ((get (index + 3) & 0xff) << 32)\n-                     + ((get (index + 4) & 0xff) << 24)\n-                     + ((get (index + 5) & 0xff) << 16)\n-                     + ((get (index + 6) & 0xff) << 8)\n-                     + (get (index + 7) & 0xff));\n+    return ByteBufferHelper.getDouble (this, index);\n   }\n   \n   final public ByteBuffer putDouble (int index, double value)\n   {\n-    // FIXME: this handles little endian only\n-    put (index, (byte) ((((long) value) & 0xff00000000000000L) >> 56));\n-    put (index + 1, (byte) ((((long) value) & 0x00ff000000000000L) >> 48));\n-    put (index + 2, (byte) ((((long) value) & 0x0000ff0000000000L) >> 40));\n-    put (index + 3, (byte) ((((long) value) & 0x000000ff00000000L) >> 32));\n-    put (index + 4, (byte) ((((long) value) & 0x00000000ff000000L) >> 24));\n-    put (index + 5, (byte) ((((long) value) & 0x0000000000ff0000L) >> 16));\n-    put (index + 6, (byte) ((((long) value) & 0x000000000000ff00L) >> 8));\n-    put (index + 7, (byte) (((long) value) & 0x00000000000000ffL));\n-    return this;\n+    return ByteBufferHelper.putDouble (this, index, value);\n   }\n }"}, {"sha": "47673c66aa4080c38b1469634a00a6cb7c0a9623", "filename": "libjava/java/nio/MappedByteBufferImpl.java", "status": "modified", "additions": 73, "deletions": 88, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java?ref=5e2ba18bc1e2a9a40f4df4403b155cd03bd8b6f9", "patch": "@@ -58,6 +58,15 @@ public MappedByteBufferImpl (FileChannelImpl ch) throws IOException\n     limit ((int) si);\n   }\n \n+  public MappedByteBufferImpl (FileChannelImpl ch, int offset, int capacity, int limit, int position, int mark, boolean readOnly)\n+  {\n+    super (capacity, limit, position, mark);\n+\n+    this.ch = ch;\n+    this.array_offset = offset;\n+    this.readOnly = readOnly;\n+  }\n+  \n   public boolean isReadOnly ()\n   {\n     return readOnly;\n@@ -164,147 +173,123 @@ public DoubleBuffer asDoubleBuffer ()\n     return new DoubleViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n   }\n \n-  public char getChar ()\n+  public final char getChar()\n   {\n-    char value = getChar (position());\n-    position (position() + 2);\n-    return value;\n+    return ByteBufferHelper.getChar (this);\n   }\n-\n-  public char getChar (int index)\n+  \n+  public final ByteBuffer putChar (char value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putChar (this, value);\n   }\n-\n-  public ByteBuffer putChar (char value)\n+  \n+  public final char getChar (int index)\n   {\n-    putChar (position(), value);\n-    position (position() + 2);\n-    return this;\n+    return ByteBufferHelper.getChar (this, index);\n   }\n-\n-  public ByteBuffer putChar (int index, char value)\n+  \n+  public final ByteBuffer putChar (int index, char value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putChar (this, index, value);\n   }\n \n-  public double getDouble ()\n+  public final short getShort()\n   {\n-    double value = getDouble (position());\n-    position (position() + 8);\n-    return value;\n+    return ByteBufferHelper.getShort (this);\n   }\n-\n-  public double getDouble (int index)\n+  \n+  public final ByteBuffer putShort (short value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putShort (this, value);\n   }\n-\n-  public ByteBuffer putDouble (double value)\n+  \n+  public final short getShort (int index)\n   {\n-    putDouble (position(), value);\n-    position (position() + 8);\n-    return this;\n+    return ByteBufferHelper.getShort (this, index);\n   }\n-\n-  public ByteBuffer putDouble (int index, double value)\n+  \n+  public final ByteBuffer putShort (int index, short value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putShort (this, index, value);\n   }\n \n-  public float getFloat ()\n+  public final int getInt()\n   {\n-    float value = getFloat (position ());\n-    position (position() + 4);\n-    return value;\n+    return ByteBufferHelper.getInt (this);\n   }\n-\n-  public float getFloat (int index)\n+  \n+  public final ByteBuffer putInt (int value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putInt (this, value);\n   }\n-\n-  public ByteBuffer putFloat (float value)\n+  \n+  public final int getInt (int index)\n   {\n-    putFloat (position(), value);\n-    position (position() + 4);\n-    return this;\n+    return ByteBufferHelper.getInt (this, index);\n   }\n-\n-  public ByteBuffer putFloat (int index, float value)\n+  \n+  public final ByteBuffer putInt (int index, int value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putInt (this, index, value);\n   }\n \n-  public int getInt ()\n+  public final long getLong()\n   {\n-    int value = getInt (position());\n-    position (position() + 8);\n-    return value;\n+    return ByteBufferHelper.getLong (this);\n   }\n-\n-  public int getInt (int index)\n+  \n+  public final ByteBuffer putLong (long value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putLong (this, value);\n   }\n-\n-  public ByteBuffer putInt (int value)\n+  \n+  public final long getLong (int index)\n   {\n-    putInt (position(), value);\n-    position (position() + 4);\n-    return this;\n+    return ByteBufferHelper.getLong (this, index);\n   }\n-\n-  public ByteBuffer putInt (int index, int value)\n+  \n+  public final ByteBuffer putLong (int index, long value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putLong (this, index, value);\n   }\n \n-  public long getLong ()\n+  public final float getFloat()\n   {\n-    long value = getLong (position());\n-    position (position() + 8);\n-    return value;\n+    return ByteBufferHelper.getFloat (this);\n   }\n-\n-  public long getLong (int index)\n+  \n+  public final ByteBuffer putFloat (float value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putFloat (this, value);\n   }\n-\n-  public ByteBuffer putLong (long value)\n+  \n+  public final float getFloat (int index)\n   {\n-    putLong (position(), value);\n-    position (position() + 8);\n-    return this;\n+    return ByteBufferHelper.getFloat (this, index);\n   }\n \n-  public ByteBuffer putLong (int index, long value)\n+  public final ByteBuffer putFloat (int index, float value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putFloat (this, index, value);\n   }\n \n-  public short getShort ()\n+  public final double getDouble()\n   {\n-    short value = getShort (position());\n-    position (position() + 2);\n-    return value;\n+    return ByteBufferHelper.getDouble (this);\n   }\n \n-  public short getShort (int index)\n+  public final ByteBuffer putDouble (double value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putDouble (this, value);\n   }\n-\n-  public ByteBuffer putShort (short value)\n+  \n+  public final double getDouble (int index)\n   {\n-    putShort (position(), value);\n-    position (position() + 2);\n-    return this;\n+    return ByteBufferHelper.getDouble (this, index);\n   }\n-\n-  public ByteBuffer putShort (int index, short value)\n+  \n+  public final ByteBuffer putDouble (int index, double value)\n   {\n-    throw new Error (\"Not implemented\");\n+    return ByteBufferHelper.putDouble (this, index, value);\n   }\n }"}]}