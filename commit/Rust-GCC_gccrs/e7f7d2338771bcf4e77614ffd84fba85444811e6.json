{"sha": "e7f7d2338771bcf4e77614ffd84fba85444811e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdmN2QyMzM4NzcxYmNmNGU3NzYxNGZmZDg0ZmJhODU0NDQ4MTFlNg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-10-18T23:17:04Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-10-18T23:17:04Z"}, "message": "register2.java: New file.\n\n\n\t* testsuite/libjava.jni/register2.java: New file.\n\t* testsuite/libjava.jni/register2.out: New file.\n\t* testsuite/libjava.jni/register2.c: New file.\n\t* java/lang/natClass.cc (_Jv_GetClassNameUtf8): New function.\n\t* java/lang/Class.h (_Jv_GetClassNameUtf8): Declare.\n\t* jni.cc (struct NativeMethodCacheEntry): New struct.\n\t(nathash): Changed type.\n\t(hash): Updated.\n\t(nathash_find_slot): Likewise.\n\t(nathash_find): Likewise.\n\t(natrehash): Likewise.\n\t(nathash_add): Likewise.\n\t(_Jv_JNI_RegisterNatives): Likewise.\n\t(_Jv_LookupJNIMethod): Likewise.\n\tIdea from Juerg Lehni <juerg@scratchdisk.com>\n\nCo-Authored-By: Bryce McKinlay <mckinlay@redhat.com>\n\nFrom-SVN: r117867", "tree": {"sha": "090a052b333feb86cf809ba60ebdc7a86794ff1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/090a052b333feb86cf809ba60ebdc7a86794ff1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7f7d2338771bcf4e77614ffd84fba85444811e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f7d2338771bcf4e77614ffd84fba85444811e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f7d2338771bcf4e77614ffd84fba85444811e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f7d2338771bcf4e77614ffd84fba85444811e6/comments", "author": null, "committer": null, "parents": [{"sha": "9e7fc6b946e8a9f616ce12a458017bad8357247e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7fc6b946e8a9f616ce12a458017bad8357247e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e7fc6b946e8a9f616ce12a458017bad8357247e"}], "stats": {"total": 159, "additions": 140, "deletions": 19}, "files": [{"sha": "9dc48337bfef4d550967cebe48a72aebc1222a87", "filename": "libjava/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e7f7d2338771bcf4e77614ffd84fba85444811e6", "patch": "@@ -1,3 +1,22 @@\n+2006-10-18  Tom Tromey  <tromey@redhat.com>\n+\t    Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* testsuite/libjava.jni/register2.java: New file.\n+\t* testsuite/libjava.jni/register2.out: New file.\n+\t* testsuite/libjava.jni/register2.c: New file.\n+\t* java/lang/natClass.cc (_Jv_GetClassNameUtf8): New function.\n+\t* java/lang/Class.h (_Jv_GetClassNameUtf8): Declare.\n+\t* jni.cc (struct NativeMethodCacheEntry): New struct.\n+\t(nathash): Changed type.\n+\t(hash): Updated.\n+\t(nathash_find_slot): Likewise.\n+\t(nathash_find): Likewise.\n+\t(natrehash): Likewise.\n+\t(nathash_add): Likewise.\n+\t(_Jv_JNI_RegisterNatives): Likewise.\n+\t(_Jv_LookupJNIMethod): Likewise.\n+\tIdea from Juerg Lehni <juerg@scratchdisk.com>\n+\n 2006-10-16  Geoffrey Keating  <geoffk@apple.com>\n \n \t* testsuite/libjava.jvmti/natevents.cc (env): Delete."}, {"sha": "a884cd6c59b765c52d00a915a741be8d67ddbdf8", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=e7f7d2338771bcf4e77614ffd84fba85444811e6", "patch": "@@ -231,6 +231,7 @@ jmethodID _Jv_FromReflectedMethod (java::lang::reflect::Method *);\n jmethodID _Jv_FromReflectedConstructor (java::lang::reflect::Constructor *);\n jint JvNumMethods (jclass);\n jmethodID JvGetFirstMethod (jclass);\n+_Jv_Utf8Const *_Jv_GetClassNameUtf8 (jclass);\n \n #ifdef INTERPRETER\n // Finds a desired interpreter method in the given class or NULL if not found\n@@ -474,6 +475,7 @@ class java::lang::Class : public java::lang::Object\n   friend jmethodID (::_Jv_FromReflectedConstructor) (java::lang::reflect::Constructor *);\n   friend jint (::JvNumMethods) (jclass);\n   friend jmethodID (::JvGetFirstMethod) (jclass);\n+  friend _Jv_Utf8Const *::_Jv_GetClassNameUtf8 (jclass);\n #ifdef INTERPRETER\n   friend _Jv_MethodBase *(::_Jv_FindInterpreterMethod) (jclass klass,\n \t\t\t\t\t\t\tjmethodID desired_method);"}, {"sha": "12984291ee1179269f013c97b52131d8ba919745", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=e7f7d2338771bcf4e77614ffd84fba85444811e6", "patch": "@@ -1259,3 +1259,11 @@ _Jv_FindInterpreterMethod (jclass klass, jmethodID desired_method)\n   return NULL;\n }\n #endif\n+\n+// Return Utf8 name of a class. This function is here for code that\n+// can't access klass->name directly.\n+_Jv_Utf8Const*\n+_Jv_GetClassNameUtf8 (jclass klass)\n+{\n+  return klass->name;\n+}"}, {"sha": "c5c2b0ff3cd9c1179bc8f2ac6edbff25db0e7e14", "filename": "libjava/jni.cc", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=e7f7d2338771bcf4e77614ffd84fba85444811e6", "patch": "@@ -1789,8 +1789,13 @@ _Jv_JNI_GetDirectBufferCapacity (JNIEnv *, jobject buffer)\n \n \f\n \n+struct NativeMethodCacheEntry : public JNINativeMethod\n+{\n+  char *className;\n+};\n+\n // Hash table of native methods.\n-static JNINativeMethod *nathash;\n+static NativeMethodCacheEntry *nathash;\n // Number of slots used.\n static int nathash_count = 0;\n // Number of slots available.  Must be power of 2.\n@@ -1800,11 +1805,15 @@ static int nathash_size = 0;\n \n // Compute a hash value for a native method descriptor.\n static int\n-hash (const JNINativeMethod *method)\n+hash (const NativeMethodCacheEntry *method)\n {\n   char *ptr;\n   int hash = 0;\n \n+  ptr = method->className;\n+  while (*ptr)\n+    hash = (31 * hash) + *ptr++;\n+\n   ptr = method->name;\n   while (*ptr)\n     hash = (31 * hash) + *ptr++;\n@@ -1817,8 +1826,8 @@ hash (const JNINativeMethod *method)\n }\n \n // Find the slot where a native method goes.\n-static JNINativeMethod *\n-nathash_find_slot (const JNINativeMethod *method)\n+static NativeMethodCacheEntry *\n+nathash_find_slot (const NativeMethodCacheEntry *method)\n {\n   jint h = hash (method);\n   int step = (h ^ (h >> 16)) | 1;\n@@ -1827,7 +1836,7 @@ nathash_find_slot (const JNINativeMethod *method)\n \n   for (;;)\n     {\n-      JNINativeMethod *slotp = &nathash[w];\n+      NativeMethodCacheEntry *slotp = &nathash[w];\n       if (slotp->name == NULL)\n \t{\n \t  if (del >= 0)\n@@ -1838,19 +1847,20 @@ nathash_find_slot (const JNINativeMethod *method)\n       else if (slotp->name == DELETED_ENTRY)\n \tdel = w;\n       else if (! strcmp (slotp->name, method->name)\n-\t       && ! strcmp (slotp->signature, method->signature))\n+\t       && ! strcmp (slotp->signature, method->signature)\n+\t       && ! strcmp (slotp->className, method->className))\n \treturn slotp;\n       w = (w + step) & (nathash_size - 1);\n     }\n }\n \n // Find a method.  Return NULL if it isn't in the hash table.\n static void *\n-nathash_find (JNINativeMethod *method)\n+nathash_find (NativeMethodCacheEntry *method)\n {\n   if (nathash == NULL)\n     return NULL;\n-  JNINativeMethod *slot = nathash_find_slot (method);\n+  NativeMethodCacheEntry *slot = nathash_find_slot (method);\n   if (slot->name == NULL || slot->name == DELETED_ENTRY)\n     return NULL;\n   return slot->fnPtr;\n@@ -1863,40 +1873,41 @@ natrehash ()\n     {\n       nathash_size = 1024;\n       nathash =\n-\t(JNINativeMethod *) _Jv_AllocBytes (nathash_size\n-\t\t\t\t\t    * sizeof (JNINativeMethod));\n+\t(NativeMethodCacheEntry *) _Jv_AllocBytes (nathash_size\n+\t\t\t\t\t\t   * sizeof (NativeMethodCacheEntry));\n     }\n   else\n     {\n       int savesize = nathash_size;\n-      JNINativeMethod *savehash = nathash;\n+      NativeMethodCacheEntry *savehash = nathash;\n       nathash_size *= 2;\n       nathash =\n-\t(JNINativeMethod *) _Jv_AllocBytes (nathash_size\n-\t\t\t\t\t    * sizeof (JNINativeMethod));\n+\t(NativeMethodCacheEntry *) _Jv_AllocBytes (nathash_size\n+\t\t\t\t\t\t   * sizeof (NativeMethodCacheEntry));\n \n       for (int i = 0; i < savesize; ++i)\n \t{\n \t  if (savehash[i].name != NULL && savehash[i].name != DELETED_ENTRY)\n \t    {\n-\t      JNINativeMethod *slot = nathash_find_slot (&savehash[i]);\n+\t      NativeMethodCacheEntry *slot = nathash_find_slot (&savehash[i]);\n \t      *slot = savehash[i];\n \t    }\n \t}\n     }\n }\n \n static void\n-nathash_add (const JNINativeMethod *method)\n+nathash_add (const NativeMethodCacheEntry *method)\n {\n   if (3 * nathash_count >= 2 * nathash_size)\n     natrehash ();\n-  JNINativeMethod *slot = nathash_find_slot (method);\n+  NativeMethodCacheEntry *slot = nathash_find_slot (method);\n   // If the slot has a real entry in it, then there is no work to do.\n   if (slot->name != NULL && slot->name != DELETED_ENTRY)\n     return;\n-  // FIXME\n+  // FIXME: memory leak?\n   slot->name = strdup (method->name);\n+  slot->className = strdup (method->className);\n   // This was already strduped in _Jv_JNI_RegisterNatives.\n   slot->signature = method->signature;\n   slot->fnPtr = method->fnPtr;\n@@ -1912,7 +1923,7 @@ _Jv_JNI_RegisterNatives (JNIEnv *env, jclass klass,\n   // the nathash table.\n   JvSynchronize sync (global_ref_table);\n \n-  JNINativeMethod dottedMethod;\n+  NativeMethodCacheEntry dottedMethod;\n \n   // Look at each descriptor given us, and find the corresponding\n   // method in the class.\n@@ -1928,8 +1939,11 @@ _Jv_JNI_RegisterNatives (JNIEnv *env, jclass klass,\n \t  // Copy this JNINativeMethod and do a slash to dot\n \t  // conversion on the signature.\n \t  dottedMethod.name = methods[j].name;\n+\t  // FIXME: we leak a little memory here if the method\n+\t  // is not found.\n \t  dottedMethod.signature = strdup (methods[j].signature);\n \t  dottedMethod.fnPtr = methods[j].fnPtr;\n+\t  dottedMethod.className = _Jv_GetClassNameUtf8 (klass)->chars();\n \t  char *c = dottedMethod.signature;\n \t  while (*c)\n \t    {\n@@ -2172,9 +2186,10 @@ _Jv_LookupJNIMethod (jclass klass, _Jv_Utf8Const *name,\n   buf[name_length] = '\\0';\n   strncpy (buf + name_length + 1, signature->chars (), sig_length);\n   buf[name_length + sig_length + 1] = '\\0';\n-  JNINativeMethod meth;\n+  NativeMethodCacheEntry meth;\n   meth.name = buf;\n   meth.signature = buf + name_length + 1;\n+  meth.className = _Jv_GetClassNameUtf8(klass)->chars();\n   function = nathash_find (&meth);\n   if (function != NULL)\n     return function;"}, {"sha": "1ed10a88a238ca5955a4953938351adaf4dff17e", "filename": "libjava/testsuite/libjava.jni/register2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Ftestsuite%2Flibjava.jni%2Fregister2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Ftestsuite%2Flibjava.jni%2Fregister2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jni%2Fregister2.c?ref=e7f7d2338771bcf4e77614ffd84fba85444811e6", "patch": "@@ -0,0 +1,48 @@\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <register2.h>\n+\n+static int\n+twentythree (JNIEnv *env, jclass k)\n+{\n+  return 23;\n+}\n+\n+static int\n+oneninetyseven (JNIEnv *env, jclass k)\n+{\n+  return 197;\n+}\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad (JavaVM *vm, void *nothing)\n+{\n+  JNIEnv *env;\n+  JNINativeMethod meth;\n+  jclass k;\n+  jint r;\n+\n+  r = (*vm)->GetEnv (vm, (void **) &env, JNI_VERSION_1_2);\n+  assert (r == JNI_OK);\n+  k = (*env)->FindClass (env, \"register2$I1\");\n+  assert (k != NULL);\n+\n+  meth.name = \"doit\";\n+  meth.signature = \"()I\";\n+  meth.fnPtr = twentythree;\n+\n+  r = (*env)->RegisterNatives (env, k, &meth, 1);\n+  assert (r == JNI_OK);\n+\n+  k = (*env)->FindClass (env, \"register2$I2\");\n+  assert (k != NULL);\n+\n+  meth.name = \"doit\";\n+  meth.signature = \"()I\";\n+  meth.fnPtr = oneninetyseven;\n+\n+  r = (*env)->RegisterNatives (env, k, &meth, 1);\n+  assert (r == JNI_OK);\n+\n+  return JNI_VERSION_1_2;\n+}"}, {"sha": "2d6c56a3b02a4cd9879bae36b1d9283a12f68dea", "filename": "libjava/testsuite/libjava.jni/register2.java", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Ftestsuite%2Flibjava.jni%2Fregister2.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Ftestsuite%2Flibjava.jni%2Fregister2.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jni%2Fregister2.java?ref=e7f7d2338771bcf4e77614ffd84fba85444811e6", "patch": "@@ -0,0 +1,27 @@\n+// Another test of RegisterNatives.\n+// We neglected to track the class name in our internal hash table.\n+// This is a regression test for the fix.\n+\n+public class register2\n+{\n+  static\n+  {\n+    System.loadLibrary (\"register2\");\n+  }\n+\n+  static class I1\n+  {\n+    public static native int doit ();\n+  }\n+\n+  static class I2\n+  {\n+    public static native int doit ();\n+  }\n+\n+  public static void main (String[] args)\n+  {\n+    System.out.println (new I1().doit());\n+    System.out.println (new I2().doit());\n+  }\n+}"}, {"sha": "5b90358a22bcf37548c2f79585435da6f52d8d98", "filename": "libjava/testsuite/libjava.jni/register2.out", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Ftestsuite%2Flibjava.jni%2Fregister2.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f7d2338771bcf4e77614ffd84fba85444811e6/libjava%2Ftestsuite%2Flibjava.jni%2Fregister2.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jni%2Fregister2.out?ref=e7f7d2338771bcf4e77614ffd84fba85444811e6", "patch": "@@ -0,0 +1,2 @@\n+23\n+197"}]}