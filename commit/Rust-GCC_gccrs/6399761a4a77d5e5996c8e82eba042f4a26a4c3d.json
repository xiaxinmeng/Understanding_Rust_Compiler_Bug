{"sha": "6399761a4a77d5e5996c8e82eba042f4a26a4c3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM5OTc2MWE0YTc3ZDVlNTk5NmM4ZTgyZWJhMDQyZjRhMjZhNGMzZA==", "commit": {"author": {"name": "Tom de Vries", "email": "vries@codesourcery.com", "date": "2012-06-20T00:59:08Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2012-06-20T00:59:08Z"}, "message": "constraints.md (ZR): New constraint.\n\n2012-06-19  Tom de Vries  <vries@codesourcery.com>\n            Maxim Kuvyrkov  <maxim@codesourcery.com>\n\n\t* config/mips/constraints.md (ZR): New constraint.\n\t* config/mips/predicates.md (mem_noofs_operand): New predicate.\n\t* config/mips/mips.c (mips_print_operand): Handle new print modifier.\n        * config/mips/mips.h (TARGET_XLP): Define.\n\t(TARGET_SYNC_AFTER_SC): Update.\n\t(ISA_HAS_SWAP, ISA_HAS_LDADD): Define.\n\t* config/mips/sync.md (atomic_exchange, atomic_fetch_add): Use\n\tXLP-specific swap and ldadd patterns.\n\t(atomic_exchange_swap, atomic_fetch_add_ldadd): New patterns.\n\nCo-Authored-By: Maxim Kuvyrkov <maxim@codesourcery.com>\n\nFrom-SVN: r188804", "tree": {"sha": "f1219ec201306c17b838cace3e3d9e84db7b1af8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1219ec201306c17b838cace3e3d9e84db7b1af8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6399761a4a77d5e5996c8e82eba042f4a26a4c3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6399761a4a77d5e5996c8e82eba042f4a26a4c3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6399761a4a77d5e5996c8e82eba042f4a26a4c3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/comments", "author": null, "committer": null, "parents": [{"sha": "01c196ea91cce2665bc7e8df7edfd7dca0352d86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c196ea91cce2665bc7e8df7edfd7dca0352d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01c196ea91cce2665bc7e8df7edfd7dca0352d86"}], "stats": {"total": 96, "additions": 90, "deletions": 6}, "files": [{"sha": "0b679ae5d8ba67dc3b44ddd36d1a209cf1248aff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6399761a4a77d5e5996c8e82eba042f4a26a4c3d", "patch": "@@ -1,3 +1,16 @@\n+2012-06-19  Tom de Vries  <vries@codesourcery.com>\n+            Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* config/mips/constraints.md (ZR): New constraint.\n+\t* config/mips/predicates.md (mem_noofs_operand): New predicate.\n+\t* config/mips/mips.c (mips_print_operand): Handle new print modifier.\n+        * config/mips/mips.h (TARGET_XLP): Define.\n+\t(TARGET_SYNC_AFTER_SC): Update.\n+\t(ISA_HAS_SWAP, ISA_HAS_LDADD): Define.\n+\t* config/mips/sync.md (atomic_exchange, atomic_fetch_add): Use\n+\tXLP-specific swap and ldadd patterns.\n+\t(atomic_exchange_swap, atomic_fetch_add_ldadd): New patterns.\n+\n 2012-06-19  Tom de Vries  <vries@codesourcery.com>\n \t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n "}, {"sha": "b543217c43ab6babc9c3c08ef35fd9c35bc42812", "filename": "gcc/config/mips/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2Fconfig%2Fmips%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2Fconfig%2Fmips%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fconstraints.md?ref=6399761a4a77d5e5996c8e82eba042f4a26a4c3d", "patch": "@@ -231,3 +231,8 @@\n (define_constraint \"Yx\"\n    \"@internal\"\n    (match_operand 0 \"low_bitmask_operand\"))\n+\n+(define_memory_constraint \"ZR\"\n+ \"@internal\n+  An address valid for loading/storing register exclusive\"\n+ (match_operand 0 \"mem_noofs_operand\"))"}, {"sha": "64b486d1d0b683f0644d835b84a51818cb8940cd", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6399761a4a77d5e5996c8e82eba042f4a26a4c3d", "patch": "@@ -7806,7 +7806,8 @@ mips_print_operand_punct_valid_p (unsigned char code)\n    'D'\tPrint the second part of a double-word register or memory operand.\n    'L'\tPrint the low-order register in a double-word register operand.\n    'M'\tPrint high-order register in a double-word register operand.\n-   'z'\tPrint $0 if OP is zero, otherwise print OP normally.  */\n+   'z'\tPrint $0 if OP is zero, otherwise print OP normally.\n+   'b'\tPrint the address of a memory operand, without offset.  */\n \n static void\n mips_print_operand (FILE *file, rtx op, int letter)\n@@ -7935,6 +7936,11 @@ mips_print_operand (FILE *file, rtx op, int letter)\n \tcase MEM:\n \t  if (letter == 'D')\n \t    output_address (plus_constant (Pmode, XEXP (op, 0), 4));\n+\t  else if (letter == 'b')\n+\t    {\n+\t      gcc_assert (REG_P (XEXP (op, 0)));\n+\t      mips_print_operand (file, XEXP (op, 0), 0);\n+\t    }\n \t  else if (letter && letter != 'z')\n \t    output_operand_lossage (\"invalid use of '%%%c'\", letter);\n \t  else"}, {"sha": "d8b0c6384e2f2e4b19af1d46ff68d1e64485ad48", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=6399761a4a77d5e5996c8e82eba042f4a26a4c3d", "patch": "@@ -223,6 +223,7 @@ struct mips_cpu_info {\n #define TARGET_SB1                  (mips_arch == PROCESSOR_SB1\t\t\\\n \t\t\t\t     || mips_arch == PROCESSOR_SB1A)\n #define TARGET_SR71K                (mips_arch == PROCESSOR_SR71000)\n+#define TARGET_XLP                  (mips_arch == PROCESSOR_XLP)\n \n /* Scheduling target defines.  */\n #define TUNE_20KC\t\t    (mips_tune == PROCESSOR_20KC)\n@@ -311,7 +312,7 @@ struct mips_cpu_info {\n    stores.  It does not tell anything about ordering of loads and\n    stores prior to and following the SC, only about the SC itself and\n    those loads and stores follow it.  */\n-#define TARGET_SYNC_AFTER_SC (!TARGET_OCTEON)\n+#define TARGET_SYNC_AFTER_SC (!TARGET_OCTEON && !TARGET_XLP)\n \n /* Define preprocessor macros for the -march and -mtune options.\n    PREFIX is either _MIPS_ARCH or _MIPS_TUNE, INFO is the selected\n@@ -1054,6 +1055,9 @@ struct mips_cpu_info {\n    ? TARGET_LLSC && !TARGET_MIPS16\t\\\n    : ISA_HAS_LL_SC)\n \n+#define ISA_HAS_SWAP (TARGET_XLP)\n+#define ISA_HAS_LDADD (TARGET_XLP)\n+\n /* ISA includes the baddu instruction.  */\n #define ISA_HAS_BADDU\t\t(TARGET_OCTEON && !TARGET_MIPS16)\n "}, {"sha": "97971e9a205fba4e34bfdfe8ef8044068705c249", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=6399761a4a77d5e5996c8e82eba042f4a26a4c3d", "patch": "@@ -370,3 +370,7 @@\n (define_predicate \"small_data_pattern\"\n   (and (match_code \"set,parallel,unspec,unspec_volatile,prefetch\")\n        (match_test \"mips_small_data_pattern_p (op)\")))\n+\n+(define_predicate \"mem_noofs_operand\"\n+  (and (match_code \"mem\")\n+       (match_code \"reg\" \"0\")))"}, {"sha": "0a7905a3300e62477053d00c93eee2fe118242b7", "filename": "gcc/config/mips/sync.md", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2Fconfig%2Fmips%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399761a4a77d5e5996c8e82eba042f4a26a4c3d/gcc%2Fconfig%2Fmips%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsync.md?ref=6399761a4a77d5e5996c8e82eba042f4a26a4c3d", "patch": "@@ -607,8 +607,22 @@\n    (match_operand:GPR 1 \"memory_operand\")\n    (match_operand:GPR 2 \"arith_operand\")\n    (match_operand:SI 3 \"const_int_operand\")]\n-  \"GENERATE_LL_SC\"\n+  \"GENERATE_LL_SC || ISA_HAS_SWAP\"\n {\n+  if (ISA_HAS_SWAP)\n+    {\n+      if (!mem_noofs_operand (operands[1], <MODE>mode))\n+        {\n+\t  rtx addr;\n+\n+\t  addr = force_reg (Pmode, XEXP (operands[1], 0));\n+\t  operands[1] = replace_equiv_address (operands[1], addr);\n+\t}\n+      operands[2] = force_reg (<MODE>mode, operands[2]);\n+      emit_insn (gen_atomic_exchange<mode>_swap (operands[0], operands[1],\n+\t\t\t\t\t\t operands[2]));\n+    }\n+  else\n     emit_insn (gen_atomic_exchange<mode>_llsc (operands[0], operands[1],\n \t\t\t\t\t       operands[2], operands[3]));\n   DONE;\n@@ -623,21 +637,46 @@\n \t UNSPEC_ATOMIC_EXCHANGE))\n    (unspec_volatile:GPR [(match_operand:SI 3 \"const_int_operand\")]\n     UNSPEC_ATOMIC_EXCHANGE)]\n-  \"GENERATE_LL_SC\"\n+  \"GENERATE_LL_SC && !ISA_HAS_SWAP\"\n   { return mips_output_sync_loop (insn, operands); }\n   [(set_attr \"sync_insn1\" \"li,move\")\n    (set_attr \"sync_oldval\" \"0\")\n    (set_attr \"sync_mem\" \"1\")\n    (set_attr \"sync_insn1_op2\" \"2\")\n    (set_attr \"sync_memmodel\" \"3\")])\n \n+;; XLP issues implicit sync for SWAP/LDADD, so no need for an explicit one.\n+(define_insn \"atomic_exchange<mode>_swap\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n+\t(unspec_volatile:GPR [(match_operand:GPR 1 \"mem_noofs_operand\" \"+ZR\")]\n+\t UNSPEC_ATOMIC_EXCHANGE))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"register_operand\" \"0\")]\n+\t UNSPEC_ATOMIC_EXCHANGE))]\n+  \"ISA_HAS_SWAP\"\n+  \"swap<size>\\t%0,%b1\")\n+\n (define_expand \"atomic_fetch_add<mode>\"\n   [(match_operand:GPR 0 \"register_operand\")\n    (match_operand:GPR 1 \"memory_operand\")\n    (match_operand:GPR 2 \"arith_operand\")\n    (match_operand:SI 3 \"const_int_operand\")]\n-  \"GENERATE_LL_SC\"\n+  \"GENERATE_LL_SC || ISA_HAS_LDADD\"\n {\n+  if (ISA_HAS_LDADD)\n+    {\n+      if (!mem_noofs_operand (operands[1], <MODE>mode))\n+        {\n+\t  rtx addr;\n+\n+\t  addr = force_reg (Pmode, XEXP (operands[1], 0));\n+\t  operands[1] = replace_equiv_address (operands[1], addr);\n+\t}\n+      operands[2] = force_reg (<MODE>mode, operands[2]);\n+      emit_insn (gen_atomic_fetch_add<mode>_ldadd (operands[0], operands[1],\n+\t\t\t\t\t\t   operands[2]));\n+    }\n+  else\n     emit_insn (gen_atomic_fetch_add<mode>_llsc (operands[0], operands[1],\n \t\t\t\t\t\toperands[2], operands[3]));\n   DONE;\n@@ -654,10 +693,23 @@\n \t UNSPEC_ATOMIC_FETCH_OP))\n    (unspec_volatile:GPR [(match_operand:SI 3 \"const_int_operand\")]\n     UNSPEC_ATOMIC_FETCH_OP)]\n-  \"GENERATE_LL_SC\"\n+  \"GENERATE_LL_SC && !ISA_HAS_LDADD\"\n   { return mips_output_sync_loop (insn, operands); }\n   [(set_attr \"sync_insn1\" \"addiu,addu\")\n    (set_attr \"sync_oldval\" \"0\")\n    (set_attr \"sync_mem\" \"1\")\n    (set_attr \"sync_insn1_op2\" \"2\")\n    (set_attr \"sync_memmodel\" \"3\")])\n+\n+;; XLP issues implicit sync for SWAP/LDADD, so no need for an explicit one.\n+(define_insn \"atomic_fetch_add<mode>_ldadd\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n+\t(unspec_volatile:GPR [(match_operand:GPR 1 \"mem_noofs_operand\" \"+ZR\")]\n+\t UNSPEC_ATOMIC_FETCH_OP))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR\n+\t [(plus:GPR (match_dup 1)\n+\t\t    (match_operand:GPR 2 \"register_operand\" \"0\"))]\n+\t UNSPEC_ATOMIC_FETCH_OP))]\n+  \"ISA_HAS_LDADD\"\n+  \"ldadd<size>\\t%0,%b1\")"}]}