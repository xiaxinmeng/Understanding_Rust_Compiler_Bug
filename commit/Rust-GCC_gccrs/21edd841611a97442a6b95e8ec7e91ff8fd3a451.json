{"sha": "21edd841611a97442a6b95e8ec7e91ff8fd3a451", "node_id": "C_kwDOANBUbNoAKDIxZWRkODQxNjExYTk3NDQyYTZiOTVlOGVjN2U5MWZmOGZkM2E0NTE", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2023-03-03T18:59:36Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2023-03-03T19:06:44Z"}, "message": "link pthread_join from std::thread ctor\n\nLike pthread_create, pthread_join may fail to be statically linked in\nabsent strong uses, so add to user code strong references to both when\nstd::thread objects are created.\n\n\nfor  libstdc++-v3/ChangeLog\n\n\tPR libstdc++/104852\n\tPR libstdc++/95989\n\tPR libstdc++/52590\n\t* include/bits/std_thread.h (thread::_M_thread_deps): New\n\tstatic implicitly-inline member function.\n\t(std::thread template ctor): Pass it to _M_start_thread.\n\t* src/c++11/thread.cc (thread::_M_start_thread): Name depend\n\tparameter, force it live on entry.", "tree": {"sha": "34a5e4e93347abfb81d949c23d0115bfc2e51c9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34a5e4e93347abfb81d949c23d0115bfc2e51c9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21edd841611a97442a6b95e8ec7e91ff8fd3a451", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21edd841611a97442a6b95e8ec7e91ff8fd3a451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21edd841611a97442a6b95e8ec7e91ff8fd3a451", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21edd841611a97442a6b95e8ec7e91ff8fd3a451/comments", "author": null, "committer": null, "parents": [{"sha": "fdac2bea53bf5e7214352e2afd5542254c3156cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdac2bea53bf5e7214352e2afd5542254c3156cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdac2bea53bf5e7214352e2afd5542254c3156cb"}], "stats": {"total": 34, "additions": 25, "deletions": 9}, "files": [{"sha": "e88c07fbd4f0fb254873a77e7ec8b01e0c0c30af", "filename": "libstdc++-v3/include/bits/std_thread.h", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21edd841611a97442a6b95e8ec7e91ff8fd3a451/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21edd841611a97442a6b95e8ec7e91ff8fd3a451/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_thread.h?ref=21edd841611a97442a6b95e8ec7e91ff8fd3a451", "patch": "@@ -132,6 +132,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     thread() noexcept = default;\n \n #ifdef _GLIBCXX_HAS_GTHREADS\n+  private:\n+    // This adds to user code that creates std:thread objects (because\n+    // it is called by the template ctor below) strong references to\n+    // pthread_create and pthread_join, which ensures they are both\n+    // linked in even during static linking.  We can't depend on\n+    // gthread calls to bring them in, because those may use weak\n+    // references.\n+    static void\n+    _M_thread_deps_never_run() {\n+#ifdef GTHR_ACTIVE_PROXY\n+      reinterpret_cast<void (*)(void)>(&pthread_create)();\n+      reinterpret_cast<void (*)(void)>(&pthread_join)();\n+#endif\n+    }\n+\n+  public:\n     template<typename _Callable, typename... _Args,\n \t     typename = _Require<__not_same<_Callable>>>\n       explicit\n@@ -142,18 +158,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  \"std::thread arguments must be invocable after conversion to rvalues\"\n \t  );\n \n-#ifdef GTHR_ACTIVE_PROXY\n-\t// Create a reference to pthread_create, not just the gthr weak symbol.\n-\tauto __depend = reinterpret_cast<void(*)()>(&pthread_create);\n-#else\n-\tauto __depend = nullptr;\n-#endif\n \tusing _Wrapper = _Call_wrapper<_Callable, _Args...>;\n \t// Create a call wrapper with DECAY_COPY(__f) as its target object\n \t// and DECAY_COPY(__args)... as its bound argument entities.\n \t_M_start_thread(_State_ptr(new _State_impl<_Wrapper>(\n \t      std::forward<_Callable>(__f), std::forward<_Args>(__args)...)),\n-\t    __depend);\n+\t    _M_thread_deps_never_run);\n       }\n #endif // _GLIBCXX_HAS_GTHREADS\n "}, {"sha": "c91f7b02e1f3f6702726cdbe4fa7c4f5bebd0284", "filename": "libstdc++-v3/src/c++11/thread.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21edd841611a97442a6b95e8ec7e91ff8fd3a451/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21edd841611a97442a6b95e8ec7e91ff8fd3a451/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc?ref=21edd841611a97442a6b95e8ec7e91ff8fd3a451", "patch": "@@ -154,8 +154,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   }\n \n   void\n-  thread::_M_start_thread(_State_ptr state, void (*)())\n+  thread::_M_start_thread(_State_ptr state, void (*depend)())\n   {\n+    // Make sure it's not optimized out, not even with LTO.\n+    asm (\"\" : : \"rm\" (depend));\n+\n     if (!__gthread_active_p())\n       {\n #if __cpp_exceptions\n@@ -190,8 +193,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   }\n \n   void\n-  thread::_M_start_thread(__shared_base_type __b, void (*)())\n+  thread::_M_start_thread(__shared_base_type __b, void (*depend)())\n   {\n+    // Make sure it's not optimized out, not even with LTO.\n+    asm (\"\" : : \"rm\" (depend));\n+\n     auto ptr = __b.get();\n     // Create a reference cycle that will be broken in the new thread.\n     ptr->_M_this_ptr = std::move(__b);"}]}