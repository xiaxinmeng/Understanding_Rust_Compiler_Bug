{"sha": "ba23e045fcb820e8d32dee361c4d048604d8d599", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEyM2UwNDVmY2I4MjBlOGQzMmRlZTM2MWM0ZDA0ODYwNGQ4ZDU5OQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-01-22T16:55:54Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-11-20T21:25:04Z"}, "message": "libstdc++: Limit memory allocation in stable_sort/inplace_merge (PR 83938)\n\nReduce memory allocation in stable_sort/inplace_merge algorithms to what is needed\nby the implementation.\n\nCo-authored-by: John Chang  <john.chang@samba.tv>\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/83938\n\t* include/bits/stl_tempbuf.h (get_temporary_buffer): Change __len\n\tcomputation in the loop to avoid truncation.\n\t* include/bits/stl_algo.h:\n\t(__inplace_merge): Take temporary buffer length from smallest range.\n\t(__stable_sort): Limit temporary buffer length.\n\t* testsuite/25_algorithms/inplace_merge/1.cc (test4): New.\n\t* testsuite/performance/25_algorithms/stable_sort.cc: Test stable_sort\n\tunder different heap memory conditions.\n\t* testsuite/performance/25_algorithms/inplace_merge.cc: New test.", "tree": {"sha": "d35174a854f07c7952fdf742c5aa6367dc5b20a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d35174a854f07c7952fdf742c5aa6367dc5b20a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba23e045fcb820e8d32dee361c4d048604d8d599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba23e045fcb820e8d32dee361c4d048604d8d599", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba23e045fcb820e8d32dee361c4d048604d8d599", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba23e045fcb820e8d32dee361c4d048604d8d599/comments", "author": null, "committer": null, "parents": [{"sha": "9e071b6e5ed5a07a4ce621382904c084431f9d47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e071b6e5ed5a07a4ce621382904c084431f9d47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e071b6e5ed5a07a4ce621382904c084431f9d47"}], "stats": {"total": 435, "additions": 412, "deletions": 23}, "files": [{"sha": "cb748418e0e738da806dfb3d60af9d823a8823b6", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba23e045fcb820e8d32dee361c4d048604d8d599/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba23e045fcb820e8d32dee361c4d048604d8d599/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=ba23e045fcb820e8d32dee361c4d048604d8d599", "patch": "@@ -2523,15 +2523,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _ValueType;\n       typedef typename iterator_traits<_BidirectionalIterator>::difference_type\n \t  _DistanceType;\n+      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;\n \n       if (__first == __middle || __middle == __last)\n \treturn;\n \n       const _DistanceType __len1 = std::distance(__first, __middle);\n       const _DistanceType __len2 = std::distance(__middle, __last);\n \n-      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;\n-      _TmpBuf __buf(__first, __len1 + __len2);\n+      // __merge_adaptive will use a buffer for the smaller of\n+      // [first,middle) and [middle,last).\n+      _TmpBuf __buf(__first, std::min(__len1, __len2));\n \n       if (__buf.begin() == 0)\n \tstd::__merge_without_buffer\n@@ -2740,6 +2742,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);\n \t  std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);\n \t}\n+\n       std::__merge_adaptive(__first, __middle, __last,\n \t\t\t    _Distance(__middle - __first),\n \t\t\t    _Distance(__last - __middle),\n@@ -5005,9 +5008,14 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n \t_ValueType;\n       typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n \t_DistanceType;\n-\n       typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;\n-      _TmpBuf __buf(__first, std::distance(__first, __last));\n+\n+      if (__first == __last)\n+\treturn;\n+\n+      // __stable_sort_adaptive sorts the range in two halves,\n+      // so the buffer only needs to fit half the range at once.\n+      _TmpBuf __buf(__first, (__last - __first + 1) / 2);\n \n       if (__buf.begin() == 0)\n \tstd::__inplace_stable_sort(__first, __last, __comp);"}, {"sha": "d76ed7f7ea6573b42393117f83d6a8ad88e2b7a8", "filename": "libstdc++-v3/include/bits/stl_tempbuf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba23e045fcb820e8d32dee361c4d048604d8d599/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba23e045fcb820e8d32dee361c4d048604d8d599/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h?ref=ba23e045fcb820e8d32dee361c4d048604d8d599", "patch": "@@ -110,7 +110,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t\t\tstd::nothrow));\n \t  if (__tmp != 0)\n \t    return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);\n-\t  __len /= 2;\n+\t  __len = __len == 1 ? 0 : ((__len + 1) / 2);\n \t}\n       return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);\n     }"}, {"sha": "bfdff77e0a739d618f71685200d3b46909149817", "filename": "libstdc++-v3/testsuite/25_algorithms/inplace_merge/1.cc", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba23e045fcb820e8d32dee361c4d048604d8d599/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Finplace_merge%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba23e045fcb820e8d32dee361c4d048604d8d599/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Finplace_merge%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Finplace_merge%2F1.cc?ref=ba23e045fcb820e8d32dee361c4d048604d8d599", "patch": "@@ -28,7 +28,7 @@ using std::inplace_merge;\n \n typedef test_container<int, bidirectional_iterator_wrapper> container;\n \n-void \n+void\n test1()\n {\n   int array[] = { 1 };\n@@ -39,7 +39,7 @@ test1()\n   inplace_merge(con2.begin(), con2.begin(), con2.end());\n }\n \n-void \n+void\n test2()\n {\n   int array[] = { 0, 2, 4, 1, 3, 5 };\n@@ -86,6 +86,36 @@ test3()\n   VERIFY( s[0].b == 0 && s[1].b == 4 && s[2].b == 1 && s[3].b == 5 );\n }\n \n+void\n+test4()\n+{\n+  S s[8];\n+  for (int pivot_idx = 0; pivot_idx < 8; ++pivot_idx)\n+    {\n+      int bval = 0;\n+      for (int i = 0; i != pivot_idx; ++i)\n+\t{\n+\t  s[i].a = i;\n+\t  s[i].b = bval++;\n+\t}\n+\n+      for (int i = pivot_idx; i != 8; ++i)\n+\t{\n+\t  s[i].a = i - pivot_idx;\n+\t  s[i].b = bval++;\n+\t}\n+\n+      inplace_merge(s, s + pivot_idx, s + 8);\n+\n+      for (int i = 1; i < 8; ++i)\n+\t{\n+\t  VERIFY( !(s[i] < s[i - 1]) );\n+\t  if (s[i - 1].a == s[i].a)\n+\t    VERIFY( s[i - 1].b < s[i].b );\n+\t}\n+    }\n+}\n+\n int \n main()\n {\n@@ -95,12 +125,15 @@ main()\n \n   __gnu_test::set_new_limit(sizeof(S) * 4);\n   test3();\n+  test4();\n \n   __gnu_test::set_new_limit(sizeof(S));\n   test3();\n+  test4();\n \n   __gnu_test::set_new_limit(0);\n   test3();\n+  test4();\n \n   return 0;\n }"}, {"sha": "780c21912c7b9955fbb4491e7e8da95758699592", "filename": "libstdc++-v3/testsuite/performance/25_algorithms/inplace_merge.cc", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba23e045fcb820e8d32dee361c4d048604d8d599/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Finplace_merge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba23e045fcb820e8d32dee361c4d048604d8d599/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Finplace_merge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Finplace_merge.cc?ref=ba23e045fcb820e8d32dee361c4d048604d8d599", "patch": "@@ -0,0 +1,290 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <vector>\n+#include <algorithm>\n+#include <cmath>\n+\n+#include <testsuite_new_operators.h>\n+#include <testsuite_performance.h>\n+\n+const int max_size = 10000000;\n+const int small_size = 200000;\n+const int front_pivot_idx = 10000;\n+int middle_pivot_idx = max_size / 2;\n+int back_pivot_idx = max_size - front_pivot_idx;\n+\n+void bench(int mem_threshold, int pivot_index,\n+\t   std::vector<int> revv,\n+\t   std::vector<int> fwdv,\n+\t   std::vector<int> wstv,\n+\t   std::vector<int> rndv)\n+{\n+  using namespace __gnu_test;\n+\n+  time_counter time;\n+  resource_counter resource;\n+\n+  set_new_limit(mem_threshold);\n+\n+  start_counters(time, resource);\n+  std::inplace_merge(revv.begin(), revv.begin() + pivot_index, revv.end());\n+  stop_counters(time, resource);\n+\n+  set_new_limit(~size_t(0));\n+\n+  report_performance(__FILE__, \"reverse\", time, resource);\n+  clear_counters(time, resource);\n+\n+  set_new_limit(mem_threshold);\n+\n+  start_counters(time, resource);\n+  std::inplace_merge(fwdv.begin(), fwdv.begin() + pivot_index, fwdv.end());\n+  stop_counters(time, resource);\n+\n+  set_new_limit(~size_t(0));\n+\n+  report_performance(__FILE__, \"forward\", time, resource);\n+  clear_counters(time, resource);\n+\n+  set_new_limit(mem_threshold);\n+\n+  start_counters(time, resource);\n+  std::inplace_merge(wstv.begin(), wstv.begin() + pivot_index, wstv.end());\n+  stop_counters(time, resource);\n+\n+  set_new_limit(~size_t(0));\n+\n+  report_performance(__FILE__, \"worst\", time, resource);\n+  clear_counters(time, resource);\n+\n+  set_new_limit(mem_threshold);\n+\n+  start_counters(time, resource);\n+  std::inplace_merge(rndv.begin(), rndv.begin() + pivot_index, rndv.end());\n+  stop_counters(time, resource);\n+\n+  set_new_limit(~size_t(0));\n+  report_performance(__FILE__, \"random\", time, resource);\n+}\n+\n+void mem_bench(double mem_ratio,\n+\t       const std::vector<int>& front_revv,\n+\t       const std::vector<int>& middle_revv,\n+\t       const std::vector<int>& back_revv,\n+\t       const std::vector<int>& fwdv,\n+\t       const std::vector<int>& front_wstv,\n+\t       const std::vector<int>& middle_wstv,\n+\t       const std::vector<int>& back_wstv,\n+\t       const std::vector<int>& front_rndv,\n+\t       const std::vector<int>& middle_rndv,\n+\t       const std::vector<int>& back_rndv)\n+{\n+  using namespace __gnu_test;\n+\n+  time_counter time;\n+  resource_counter resource;\n+\n+  int max_mem = (int)std::ceil(front_pivot_idx * mem_ratio) * sizeof(int);\n+  start_counters(time, resource);\n+  bench(max_mem, front_pivot_idx, front_revv, fwdv, front_wstv, front_rndv);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"front pivot\", time, resource);\n+  clear_counters(time, resource);\n+\n+  max_mem = (int)std::ceil(middle_pivot_idx * mem_ratio) * sizeof(int);\n+  start_counters(time, resource);\n+  bench(max_mem, middle_pivot_idx, middle_revv, fwdv, middle_wstv, middle_rndv);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"middle pivot\", time, resource);\n+  clear_counters(time, resource);\n+\n+  max_mem = (int)std::ceil(front_pivot_idx * mem_ratio) * sizeof(int);\n+  start_counters(time, resource);\n+  bench(max_mem, back_pivot_idx, back_revv, fwdv, back_wstv, back_rndv);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"back pivot\", time, resource);\n+}\n+\n+void init_reverse(std::vector<int>& v, size_t pivot_index)\n+{\n+  int val = 0;\n+  for (size_t i = pivot_index; i != v.size(); ++i)\n+    v[i] = val++;\n+  for (size_t i = 0; i != pivot_index; ++i)\n+    v[i] = val++;\n+}\n+\n+void init_forward(std::vector<int>& v)\n+{\n+  int val = 0;\n+  for (size_t i = 0; i != v.size(); ++i)\n+    v[i] = val++;\n+}\n+\n+void init_worst(std::vector<int>& v, size_t pivot_index)\n+{\n+  int val = 0;\n+  if (pivot_index + 1 > v.size() / 2)\n+    {\n+      for (size_t i = 0; i != pivot_index; val += 2, ++i)\n+\tv[i] = val;\n+      val = 1;\n+    }\n+  else\n+    {\n+      for (size_t i = pivot_index; i != v.size(); val += 2, ++i)\n+\tv[i] = val;\n+      val -= pivot_index * 2 + 1;\n+    }\n+\n+  if (pivot_index + 1 > v.size() / 2)\n+    for (size_t i = pivot_index; i != v.size(); val += 2, ++i)\n+      v[i] = val;\n+  else\n+    for (size_t i = 0; i != pivot_index; val += 2, ++i)\n+      v[i] = val;\n+}\n+\n+void init_random(std::vector<int>& v)\n+{\n+  // a simple pseudo-random series which does not rely on rand() and friends\n+  v[0] = 0;\n+  for (size_t i = 1; i != v.size(); ++i)\n+    v[i] = (v[i-1] + 110211473) * 745988807;\n+}\n+\n+void reduce_size(std::vector<int>& front_v,\n+\t\t std::vector<int>& middle_v,\n+\t\t std::vector<int>& back_v)\n+{\n+  front_v.erase(front_v.begin() + front_pivot_idx,\n+\t\tfront_v.end() - back_pivot_idx);\n+  middle_v.erase(middle_v.begin() + small_size / 2,\n+\t\t middle_v.end() - small_size / 2);\n+  back_v.erase(back_v.begin() + back_pivot_idx,\n+\t       back_v.end() - front_pivot_idx);\n+}\n+\n+int main()\n+{\n+  using namespace __gnu_test;\n+\n+  // No constraint to build vectors.\n+  set_new_limit(~size_t(0));\n+\n+  std::vector<int> front_revv(max_size);\n+  init_reverse(front_revv, front_pivot_idx);\n+\n+  std::vector<int> middle_revv(max_size);\n+  init_reverse(middle_revv, middle_pivot_idx);\n+\n+  std::vector<int> back_revv(max_size);\n+  init_reverse(back_revv, back_pivot_idx);\n+\n+  std::vector<int> fwdv(max_size);\n+  init_forward(fwdv);\n+\n+  std::vector<int> front_wstv(max_size);\n+  init_worst(front_wstv, front_pivot_idx);\n+\n+  std::vector<int> middle_wstv(max_size);\n+  init_worst(middle_wstv, middle_pivot_idx);\n+\n+  std::vector<int> back_wstv(max_size);\n+  init_worst(back_wstv, back_pivot_idx);\n+\n+  std::vector<int> front_rndv(max_size);\n+  init_random(front_rndv);\n+  std::vector<int> middle_rndv(front_rndv);\n+  std::vector<int> back_rndv(front_rndv);\n+\n+  sort(front_rndv.begin(), front_rndv.begin() + front_pivot_idx);\n+  sort(front_rndv.begin() + front_pivot_idx, front_rndv.end());\n+\n+  sort(middle_rndv.begin(), middle_rndv.begin() + middle_pivot_idx);\n+  sort(middle_rndv.begin() + middle_pivot_idx, middle_rndv.end());\n+\n+  sort(back_rndv.begin(), back_rndv.begin() + back_pivot_idx);\n+  sort(back_rndv.begin() + back_pivot_idx, back_rndv.end());\n+\n+  time_counter time;\n+  resource_counter resource;\n+\n+  start_counters(time, resource);\n+\n+  // No limit.\n+  mem_bench(1.0,\n+\t    front_revv, middle_revv, back_revv,\n+\t    fwdv,\n+\t    front_wstv, middle_wstv, back_wstv,\n+\t    front_rndv, middle_rndv, back_rndv);\n+\n+  stop_counters(time, resource);\n+\n+  report_performance(__FILE__, \"bench 1 / 1 memory\", time, resource);\n+  clear_counters(time, resource);\n+\n+  start_counters(time, resource);\n+\n+  // Limit to the fourth.\n+  mem_bench(1.0 / 4,\n+\t    front_revv, middle_revv, back_revv,\n+\t    fwdv,\n+\t    front_wstv, middle_wstv, back_wstv,\n+\t    front_rndv, middle_rndv, back_rndv);\n+\n+  stop_counters(time, resource);\n+\n+  report_performance(__FILE__, \"bench 1 / 4 memory\", time, resource);\n+  clear_counters(time, resource);\n+\n+  start_counters(time, resource);\n+\n+  // Really limit allocation.\n+  mem_bench(1.0 / 64,\n+\t    front_revv, middle_revv, back_revv,\n+\t    fwdv,\n+\t    front_wstv, middle_wstv, back_wstv,\n+\t    front_rndv, middle_rndv, back_rndv);\n+\n+  stop_counters(time, resource);\n+\n+  report_performance(__FILE__, \"bench 1 /64 memory\", time, resource);\n+  clear_counters(time, resource);\n+\n+  middle_pivot_idx = small_size / 2;\n+  back_pivot_idx = small_size - front_pivot_idx;\n+  reduce_size(front_revv, middle_revv, back_revv);\n+  fwdv.resize(small_size);\n+  reduce_size(front_wstv, middle_wstv, back_wstv);\n+  reduce_size(front_rndv, middle_rndv, back_rndv);\n+\n+  start_counters(time, resource);\n+\n+  // No memory.\n+  mem_bench(0.0,\n+\t    front_revv, middle_revv, back_revv,\n+\t    fwdv,\n+\t    front_wstv, middle_wstv, back_wstv,\n+\t    front_rndv, middle_rndv, back_rndv);\n+\n+  stop_counters(time, resource);\n+\n+  report_performance(__FILE__, \"bench 0 / 1 memory\", time, resource);\n+  return 0;\n+}"}, {"sha": "fe526638aaf4fde610092552aa05cd7ca520d677", "filename": "libstdc++-v3/testsuite/performance/25_algorithms/stable_sort.cc", "status": "modified", "additions": 74, "deletions": 16, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba23e045fcb820e8d32dee361c4d048604d8d599/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fstable_sort.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba23e045fcb820e8d32dee361c4d048604d8d599/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fstable_sort.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fstable_sort.cc?ref=ba23e045fcb820e8d32dee361c4d048604d8d599", "patch": "@@ -17,49 +17,107 @@\n \n #include <vector>\n #include <algorithm>\n+\n+#include <testsuite_new_operators.h>\n #include <testsuite_performance.h>\n \n-int main()\n+const int max_size = 10000000;\n+const int small_size = 200000;\n+\n+void bench(size_t mem_threshold,\n+\t   std::vector<int> revv,\n+\t   std::vector<int> fwdv,\n+\t   std::vector<int> rndv)\n {\n   using namespace __gnu_test;\n \n   time_counter time;\n   resource_counter resource;\n \n-  const int max_size = 10000000;\n-\n-  std::vector<int> v(max_size);\n-\n-  for (int i = 0; i < max_size; ++i)\n-    v[i] = -i;\n+  set_new_limit(mem_threshold);\n \n   start_counters(time, resource);\n-  std::stable_sort(v.begin(), v.end());\n+  std::stable_sort(revv.begin(), revv.end());\n   stop_counters(time, resource);\n \n+  set_new_limit(~size_t(0));\n   report_performance(__FILE__, \"reverse\", time, resource);\n   clear_counters(time, resource);\n \n-  for (int i = 0; i < max_size; ++i)\n-    v[i] = i;\n+  set_new_limit(mem_threshold);\n \n   start_counters(time, resource);\n-  std::stable_sort(v.begin(), v.end());\n+  std::stable_sort(fwdv.begin(), fwdv.end());\n   stop_counters(time, resource);\n \n+  set_new_limit(~size_t(0));\n   report_performance(__FILE__, \"forwards\", time, resource);\n   clear_counters(time, resource);\n \n-  // a simple psuedo-random series which does not rely on rand() and friends\n-  v[0] = 0;\n+  start_counters(time, resource);\n+  std::stable_sort(rndv.begin(), rndv.end());\n+  stop_counters(time, resource);\n+\n+  set_new_limit(~size_t(0));\n+  report_performance(__FILE__, \"random\", time, resource);\n+}\n+\n+int main()\n+{\n+  using namespace __gnu_test;\n+\n+  // No memory constraint.\n+  set_new_limit(~size_t(0));\n+\n+  std::vector<int> revv(max_size);\n+  for (int i = 0; i < max_size; ++i)\n+    revv[i] = -i;\n+\n+  std::vector<int> fwdv(max_size);\n+  for (int i = 0; i < max_size; ++i)\n+    fwdv[i] = i;\n+\n+  // a simple pseudo-random series which does not rely on rand() and friends\n+  std::vector<int> rndv(max_size);\n+  rndv[0] = 0;\n   for (int i = 1; i < max_size; ++i)\n-    v[i] = (v[i-1] + 110211473) * 745988807;\n+    rndv[i] = (rndv[i-1] + 110211473) * 745988807;\n+\n+  time_counter time;\n+  resource_counter resource;\n \n   start_counters(time, resource);\n-  std::stable_sort(v.begin(), v.end());\n+  bench(~size_t(0), revv, fwdv, rndv);\n   stop_counters(time, resource);\n \n-  report_performance(__FILE__, \"random\", time, resource);\n+  report_performance(__FILE__, \"bench 1 / 1 memory\", time, resource);\n+  clear_counters(time, resource);\n+\n+  start_counters(time, resource);\n+  // Limit to fourth the expected size of the sorted array.\n+  bench(max_size * sizeof(int) / 4, revv, fwdv, rndv);\n+  stop_counters(time, resource);\n+\n+  report_performance(__FILE__, \"bench 1 / 4 memory\", time, resource);\n+  clear_counters(time, resource);\n+\n+  start_counters(time, resource);\n+  // Limit to 1/64 of range size.\n+  bench(max_size * sizeof(int) / 64, revv, fwdv, rndv);\n+  stop_counters(time, resource);\n+\n+  report_performance(__FILE__, \"bench 1 /64 memory\", time, resource);\n+  clear_counters(time, resource);\n+\n+  revv.resize(small_size);\n+  fwdv.resize(small_size);\n+  rndv.resize(small_size);\n+\n+  start_counters(time, resource);\n+  // Forbid any allocation.\n+  bench(0, revv, fwdv, rndv);\n+  stop_counters(time, resource);\n \n+  report_performance(__FILE__, \"bench 0 / 1 memory\", time, resource);\n   return 0;\n }"}]}