{"sha": "155e5d5f559fc3639da157b4c3a7ee41f62f43cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU1ZTVkNWY1NTlmYzM2MzlkYTE1N2I0YzNhN2VlNDFmNjJmNDNjYg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-04-11T15:50:47Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-04-11T15:50:47Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-04-11  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * simplify.c (simplify_bound_dim): Exit for\n        ucobound's last dimension unless -fcoarray=single.\n        * trans-array (gfc_conv_descriptor_size_1): Renamed from\n        gfc_conv_descriptor_size, made static, has now from_dim and\n        to_dim arguments.\n        (gfc_conv_descriptor_size): Call gfc_conv_descriptor_size.\n        (gfc_conv_descriptor_cosize): New function.\n        * trans-array.h (gfc_conv_descriptor_cosize): New prototype.\n        * trans-intrinsic.c (conv_intrinsic_cobound): Add input_location\n        and handle last codim of ucobound for when -fcoarray is not \"single\".\n\nFrom-SVN: r172262", "tree": {"sha": "387fbb7b6688f4fd0d88a06fd23809e5f79095f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/387fbb7b6688f4fd0d88a06fd23809e5f79095f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/155e5d5f559fc3639da157b4c3a7ee41f62f43cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155e5d5f559fc3639da157b4c3a7ee41f62f43cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/155e5d5f559fc3639da157b4c3a7ee41f62f43cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155e5d5f559fc3639da157b4c3a7ee41f62f43cb/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e6313a7840a9266bb5777cd29b86885b63b3b24f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6313a7840a9266bb5777cd29b86885b63b3b24f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6313a7840a9266bb5777cd29b86885b63b3b24f"}], "stats": {"total": 130, "additions": 107, "deletions": 23}, "files": [{"sha": "68440f4c840758362ea33f92ce91fa1fb3e729af", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155e5d5f559fc3639da157b4c3a7ee41f62f43cb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155e5d5f559fc3639da157b4c3a7ee41f62f43cb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=155e5d5f559fc3639da157b4c3a7ee41f62f43cb", "patch": "@@ -1,3 +1,17 @@\n+2011-04-11  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* simplify.c (simplify_bound_dim): Exit for\n+\tucobound's last dimension unless -fcoarray=single.\n+\t* trans-array (gfc_conv_descriptor_size_1): Renamed from\n+\tgfc_conv_descriptor_size, made static, has now from_dim and\n+\tto_dim arguments.\n+\t(gfc_conv_descriptor_size): Call gfc_conv_descriptor_size.\n+\t(gfc_conv_descriptor_cosize): New function.\n+\t* trans-array.h (gfc_conv_descriptor_cosize): New prototype.\n+\t* trans-intrinsic.c (conv_intrinsic_cobound): Add input_location\n+\tand handle last codim of ucobound for when -fcoarray is not \"single\".\n+\n 2011-04-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/48448"}, {"sha": "abc33837e6cbbb1206dbe3cfe857549866e02814", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155e5d5f559fc3639da157b4c3a7ee41f62f43cb/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155e5d5f559fc3639da157b4c3a7ee41f62f43cb/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=155e5d5f559fc3639da157b4c3a7ee41f62f43cb", "patch": "@@ -3298,7 +3298,8 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n \n   /* The last dimension of an assumed-size array is special.  */\n   if ((!coarray && d == as->rank && as->type == AS_ASSUMED_SIZE && !upper)\n-      || (coarray && d == as->rank + as->corank))\n+      || (coarray && d == as->rank + as->corank\n+\t  && (!upper || gfc_option.coarray == GFC_FCOARRAY_SINGLE)))\n     {\n       if (as->lower[d-1]->expr_type == EXPR_CONSTANT)\n \t{"}, {"sha": "f8e26b0992e16e697f9abee05c01a93b4f176b44", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155e5d5f559fc3639da157b4c3a7ee41f62f43cb/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155e5d5f559fc3639da157b4c3a7ee41f62f43cb/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=155e5d5f559fc3639da157b4c3a7ee41f62f43cb", "patch": "@@ -4055,17 +4055,17 @@ gfc_conv_array_extent_dim (tree lbound, tree ubound, tree* or_expr)\n \n \n /* For an array descriptor, get the total number of elements.  This is just\n-   the product of the extents along all dimensions.  */\n+   the product of the extents along from_dim to to_dim.  */\n \n-tree\n-gfc_conv_descriptor_size (tree desc, int rank)\n+static tree\n+gfc_conv_descriptor_size_1 (tree desc, int from_dim, int to_dim)\n {\n   tree res;\n   int dim;\n \n   res = gfc_index_one_node;\n \n-  for (dim = 0; dim < rank; ++dim)\n+  for (dim = from_dim; dim < to_dim; ++dim)\n     {\n       tree lbound;\n       tree ubound;\n@@ -4083,6 +4083,24 @@ gfc_conv_descriptor_size (tree desc, int rank)\n }\n \n \n+/* Full size of an array.  */\n+\n+tree\n+gfc_conv_descriptor_size (tree desc, int rank)\n+{\n+  return gfc_conv_descriptor_size_1 (desc, 0, rank);\n+}\n+\n+\n+/* Size of a coarray for all dimensions but the last.  */\n+\n+tree\n+gfc_conv_descriptor_cosize (tree desc, int rank, int corank)\n+{\n+  return gfc_conv_descriptor_size_1 (desc, rank, rank + corank - 1);\n+}\n+\n+\n /* Helper function for marking a boolean expression tree as unlikely.  */\n \n static tree"}, {"sha": "fef56ae8535b14da14ff35cd504ba0b70ff2209c", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155e5d5f559fc3639da157b4c3a7ee41f62f43cb/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155e5d5f559fc3639da157b4c3a7ee41f62f43cb/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=155e5d5f559fc3639da157b4c3a7ee41f62f43cb", "patch": "@@ -164,3 +164,4 @@ void gfc_trans_string_copy (stmtblock_t *, tree, tree, int, tree, tree, int);\n /* Calculate extent / size of an array.  */\n tree gfc_conv_array_extent_dim (tree, tree, tree*);\n tree gfc_conv_descriptor_size (tree, int);\n+tree gfc_conv_descriptor_cosize (tree, int, int);"}, {"sha": "b4cc360706de342fa371e404a8ed192b9326c9c3", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 68, "deletions": 18, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155e5d5f559fc3639da157b4c3a7ee41f62f43cb/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155e5d5f559fc3639da157b4c3a7ee41f62f43cb/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=155e5d5f559fc3639da157b4c3a7ee41f62f43cb", "patch": "@@ -1170,10 +1170,10 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n       tree_rank = gfc_conv_mpz_to_tree (mpz_rank, gfc_index_integer_kind);\n \n       bound = se->loop->loopvar[0];\n-      bound = fold_build2 (PLUS_EXPR, gfc_array_index_type, bound,\n-\t\t\t   se->ss->data.info.delta[0]);\n-      bound = fold_build2 (PLUS_EXPR, gfc_array_index_type, bound,\n-\t\t\t   tree_rank);\n+      bound = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t       bound, se->ss->data.info.delta[0]);\n+      bound = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t       bound, tree_rank);\n       gfc_advance_se_ss_chain (se);\n     }\n   else\n@@ -1199,11 +1199,13 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n       else if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n         {\n \t  bound = gfc_evaluate_now (bound, &se->pre);\n-\t  cond = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t      bound, build_int_cst (TREE_TYPE (bound), 1));\n+\t  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t\t  bound, build_int_cst (TREE_TYPE (bound), 1));\n \t  tmp = gfc_rank_cst[GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc))];\n-\t  tmp = fold_build2 (GT_EXPR, boolean_type_node, bound, tmp);\n-\t  cond = fold_build2 (TRUTH_ORIF_EXPR, boolean_type_node, cond, tmp);\n+\t  tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t\t bound, tmp);\n+\t  cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t\t  boolean_type_node, cond, tmp);\n \t  gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t\t   gfc_msg_fault);\n \t}\n@@ -1213,26 +1215,74 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n       switch (arg->expr->rank)\n \t{\n \tcase 0:\n-\t  bound = fold_build2 (MINUS_EXPR, gfc_array_index_type, bound,\n-\t\t\t       gfc_index_one_node);\n+\t  bound = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t   gfc_array_index_type, bound,\n+\t\t\t\t   gfc_index_one_node);\n \tcase 1:\n \t  break;\n \tdefault:\n-\t  bound = fold_build2 (PLUS_EXPR, gfc_array_index_type, bound,\n-\t\t\t       gfc_rank_cst[arg->expr->rank - 1]);\n+\t  bound = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t   gfc_array_index_type, bound,\n+\t\t\t\t   gfc_rank_cst[arg->expr->rank - 1]);\n \t}\n     }\n \n   resbound = gfc_conv_descriptor_lbound_get (desc, bound);\n \n+  /* Handle UCOBOUND with special handling of the last codimension.  */\n   if (expr->value.function.isym->id == GFC_ISYM_UCOBOUND)\n     {\n-      cond = fold_build2 (EQ_EXPR, boolean_type_node, bound,\n-\t\t\t  build_int_cst (TREE_TYPE (bound),\n-\t\t\t  arg->expr->rank + corank - 1));\n-      resbound2 = gfc_conv_descriptor_ubound_get (desc, bound);\n-      se->expr = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n-\t\t\t      resbound, resbound2);\n+      /* Last codimension: For -fcoarray=single just return\n+\t the lcobound - otherwise add\n+\t   ceiling (real (num_images ()) / real (size)) - 1\n+\t = (num_images () + size - 1) / size - 1\n+\t = (num_images - 1) / size(),\n+         where size is the product of the extend of all but the last\n+\t codimension.  */\n+\n+      if (gfc_option.coarray != GFC_FCOARRAY_SINGLE && corank > 1)\n+\t{\n+          tree cosize;\n+\n+\t  gfc_init_coarray_decl ();\n+\t  cosize = gfc_conv_descriptor_cosize (desc, arg->expr->rank, corank);\n+\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t gfort_gvar_caf_num_images,\n+\t\t\t\t build_int_cst (gfc_array_index_type, 1));\n+\t  tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp,\n+\t\t\t\t fold_convert (gfc_array_index_type, cosize));\n+\t  resbound = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t      gfc_array_index_type, resbound, tmp);\n+\t}\n+      else if (gfc_option.coarray != GFC_FCOARRAY_SINGLE)\n+\t{\n+\t  /* ubound = lbound + num_images() - 1.  */\n+\t  gfc_init_coarray_decl ();\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t gfort_gvar_caf_num_images,\n+\t\t\t\t build_int_cst (gfc_array_index_type, 1));\n+\t  resbound = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t      gfc_array_index_type, resbound, tmp);\n+\t}\n+\n+      if (corank > 1)\n+\t{\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t  bound,\n+\t\t\t\t  build_int_cst (TREE_TYPE (bound),\n+\t\t\t\t\t\t arg->expr->rank + corank - 1));\n+\n+\t  resbound2 = gfc_conv_descriptor_ubound_get (desc, bound);\n+\t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t      gfc_array_index_type, cond,\n+\t\t\t\t      resbound, resbound2);\n+\t}\n+      else\n+\tse->expr = resbound;\n     }\n   else\n     se->expr = resbound;"}]}