{"sha": "09861cbee63a833e24b235a82432f2086f993624", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk4NjFjYmVlNjNhODMzZTI0YjIzNWE4MjQzMmYyMDg2Zjk5MzYyNA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-10-18T04:04:07Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-10-18T04:04:07Z"}, "message": "re PR fortran/29277 (Formated stream output: Translate \"\\n\" / achar(10) into \"\\r\\n\" on some platforms)\n\n2006-10-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/29277\n\t* io/list_read.c (next_char): Update strm_pos.\n\t(eat_separator): Delete extra call to unget_char.\n\t* io/transfer.c (read_block): Use read_sf for formatted stream I/O.\n\t(next_record_r): Update strm_pos for formatted stream I/O and handle\n\tend-of-record correctly.\n\t(next_record_w): Ditto.\n\t(next_record): Enable next record (r/w) functions and update strm_pos.\n\t(finalize_transfer): Call next_record to finish the record.\n\nFrom-SVN: r117846", "tree": {"sha": "32a8585b113c945c9bf5f0685a23c94df5622e73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32a8585b113c945c9bf5f0685a23c94df5622e73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09861cbee63a833e24b235a82432f2086f993624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09861cbee63a833e24b235a82432f2086f993624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09861cbee63a833e24b235a82432f2086f993624", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09861cbee63a833e24b235a82432f2086f993624/comments", "author": null, "committer": null, "parents": [{"sha": "6bc222ff7454812e7dd043f42b6724c283d3d689", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bc222ff7454812e7dd043f42b6724c283d3d689", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bc222ff7454812e7dd043f42b6724c283d3d689"}], "stats": {"total": 80, "additions": 54, "deletions": 26}, "files": [{"sha": "ff0e2468e68b9f4a1fe6f89ca0cd51f9f21fa492", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09861cbee63a833e24b235a82432f2086f993624/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09861cbee63a833e24b235a82432f2086f993624/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=09861cbee63a833e24b235a82432f2086f993624", "patch": "@@ -1,3 +1,15 @@\n+2006-10-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/29277\n+\t* io/list_read.c (next_char): Update strm_pos.\n+\t(eat_separator): Delete extra call to unget_char.\n+\t* io/transfer.c (read_block): Use read_sf for formatted stream I/O.\n+\t(next_record_r): Update strm_pos for formatted stream I/O and handle\n+\tend-of-record correctly.\n+\t(next_record_w): Ditto.\n+\t(next_record): Enable next record (r/w) functions and update strm_pos.\n+\t(finalize_transfer): Call next_record to finish the record.\n+\n 2006-10-13  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* m4/spacing.m4: Use scalbn[f,l] if ldexp[f,l] is unavailable."}, {"sha": "47ceb4727de8e982e6a45b20192a65b4d754b944", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09861cbee63a833e24b235a82432f2086f993624/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09861cbee63a833e24b235a82432f2086f993624/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=09861cbee63a833e24b235a82432f2086f993624", "patch": "@@ -187,6 +187,9 @@ next_char (st_parameter_dt *dtp)\n   length = 1;\n \n   p = salloc_r (dtp->u.p.current_unit->s, &length);\n+  \n+  if (is_stream_io (dtp))\n+    dtp->u.p.current_unit->strm_pos++;\n \n   if (is_internal_unit(dtp))\n     {\n@@ -294,10 +297,7 @@ eat_separator (st_parameter_dt *dtp)\n       if (n == '\\n')\n \tdtp->u.p.at_eol = 1;\n       else\n-        {\n-\t  unget_char (dtp, n);\n-\t  unget_char (dtp, c);\n-        } \n+\tunget_char (dtp, n);\n       break;\n \n     case '\\n':"}, {"sha": "b680d20c68497724d2f88d03fabbe521ec61cb3a", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09861cbee63a833e24b235a82432f2086f993624/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09861cbee63a833e24b235a82432f2086f993624/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=09861cbee63a833e24b235a82432f2086f993624", "patch": "@@ -324,6 +324,13 @@ read_block (st_parameter_dt *dtp, int *length)\n \t  return NULL;\n \t}\n \n+      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED)\n+\t{\n+\t  source = read_sf (dtp, length, 0);\n+\t  dtp->u.p.current_unit->strm_pos +=\n+\t    (gfc_offset) (*length + dtp->u.p.sf_seen_eor);\n+\t  return source;\n+\t}\n       nread = *length;\n       source = salloc_r (dtp->u.p.current_unit->s, &nread);\n \n@@ -1921,8 +1928,7 @@ next_record_r (st_parameter_dt *dtp)\n \n   switch (current_mode (dtp))\n     {\n-    /* No records in STREAM I/O.  */\n-    case FORMATTED_STREAM:\n+    /* No records in unformatted STREAM I/O.  */\n     case UNFORMATTED_STREAM:\n       return;\n     \n@@ -1970,6 +1976,7 @@ next_record_r (st_parameter_dt *dtp)\n \t}\n       break;\n \n+    case FORMATTED_STREAM:\n     case FORMATTED_SEQUENTIAL:\n       length = 1;\n       /* sf_read has already terminated input because of an '\\n'  */\n@@ -2019,6 +2026,9 @@ next_record_r (st_parameter_dt *dtp)\n \t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n \t      break;\n \t    }\n+\n+\t  if (is_stream_io (dtp))\n+\t    dtp->u.p.current_unit->strm_pos++;\n \t}\n       while (*p != '\\n');\n \n@@ -2116,8 +2126,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \n   switch (current_mode (dtp))\n     {\n-    /* No records in STREAM I/O.  */\n-    case FORMATTED_STREAM:\n+    /* No records in unformatted STREAM I/O.  */\n     case UNFORMATTED_STREAM:\n       return;\n \n@@ -2168,6 +2177,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \n       break;\n \n+    case FORMATTED_STREAM:\n     case FORMATTED_SEQUENTIAL:\n \n       if (is_internal_unit (dtp))\n@@ -2241,8 +2251,6 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t}\n       else\n \t{\n-\t  if (dtp->u.p.current_unit->bytes_left == 0)\n-\t    break;\n \n \t  /* If this is the last call to next_record move to the farthest\n \t  position reached in preparation for completing the record.\n@@ -2266,6 +2274,9 @@ next_record_w (st_parameter_dt *dtp, int done)\n #endif\n \t  if (swrite (dtp->u.p.current_unit->s, &crlf[2-len], &len) != 0)\n \t    goto io_error;\n+\t  \n+\t  if (is_stream_io (dtp))\n+\t    dtp->u.p.current_unit->strm_pos += len;\n \t}\n \n       break;\n@@ -2284,9 +2295,6 @@ next_record_w (st_parameter_dt *dtp, int done)\n void\n next_record (st_parameter_dt *dtp, int done)\n {\n-  if (is_stream_io (dtp))\n-    return;\n-\n   gfc_offset fp; /* File position.  */\n \n   dtp->u.p.current_unit->read_bad = 0;\n@@ -2296,18 +2304,22 @@ next_record (st_parameter_dt *dtp, int done)\n   else\n     next_record_w (dtp, done);\n \n-  /* keep position up to date for INQUIRE */\n-  dtp->u.p.current_unit->flags.position = POSITION_ASIS;\n-  dtp->u.p.current_unit->current_record = 0;\n-  if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n-   {\n-    fp = file_position (dtp->u.p.current_unit->s);\n-    /* Calculate next record, rounding up partial records.  */\n-    dtp->u.p.current_unit->last_record = (fp + dtp->u.p.current_unit->recl - 1)\n-\t\t\t\t/ dtp->u.p.current_unit->recl;\n-   }\n-  else\n-    dtp->u.p.current_unit->last_record++;\n+  if (!is_stream_io (dtp))\n+    {\n+      /* keep position up to date for INQUIRE */\n+      dtp->u.p.current_unit->flags.position = POSITION_ASIS;\n+      dtp->u.p.current_unit->current_record = 0;\n+      if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n+\t{\n+\t  fp = file_position (dtp->u.p.current_unit->s);\n+\t  /* Calculate next record, rounding up partial records.  */\n+\t  dtp->u.p.current_unit->last_record =\n+\t    (fp + dtp->u.p.current_unit->recl - 1) /\n+\t      dtp->u.p.current_unit->recl;\n+\t}\n+      else\n+\tdtp->u.p.current_unit->last_record++;\n+    }\n \n   if (!done)\n     pre_position (dtp);\n@@ -2373,7 +2385,11 @@ finalize_transfer (st_parameter_dt *dtp)\n       next_record (dtp, 1);\n     }\n   else\n-    flush (dtp->u.p.current_unit->s);\n+    {\n+      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED)\n+\tnext_record (dtp, 1);\n+      flush (dtp->u.p.current_unit->s);\n+    }\n \n   sfree (dtp->u.p.current_unit->s);\n }"}]}