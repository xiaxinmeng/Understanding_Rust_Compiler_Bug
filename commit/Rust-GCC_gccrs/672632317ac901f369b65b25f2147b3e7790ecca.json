{"sha": "672632317ac901f369b65b25f2147b3e7790ecca", "node_id": "C_kwDOANBUbNoAKDY3MjYzMjMxN2FjOTAxZjM2OWI2NWIyNWYyMTQ3YjNlNzc5MGVjY2E", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-08T06:11:43Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-08T10:56:16Z"}, "message": "Implement known/maybe fpclassify like API for frange.\n\ngcc/ChangeLog:\n\n\t* gimple-range-fold.cc\n\t(fold_using_range::range_of_builtin_int_call): Use fpclassify like API.\n\t* range-op-float.cc (finite_operand_p): Same.\n\t(finite_operands_p): Same.\n\t(foperator_lt::fold_range): Same.\n\t(foperator_le::fold_range): Same.\n\t(foperator_gt::fold_range): Same.\n\t(foperator_ge::fold_range): Same.\n\t(foperator_unordered::fold_range): Same.\n\t(foperator_unordered::op1_range): Same.\n\t(foperator_ordered::fold_range): Same.\n\t* value-range.cc (frange::set_nan): Same.\n\t(frange::set_signbit): Same.\n\t(frange::union_): Same.\n\t(frange::intersect): Same.\n\t(frange::operator==): Same.\n\t(frange::singleton_p): Same.\n\t(frange::verify_range): Same.\n\t(range_tests_nan): Same.\n\t(range_tests_floats): Same.\n\t* value-range.h(frange::known_finite): New.\n\t(frange::maybe_inf): New.\n\t(frange::known_inf): New.\n\t(frange::maybe_nan): New.\n\t(frange::known_nan): New.\n\t(frange::known_signbit): New.", "tree": {"sha": "caeeeee430d82a2e4122005babb4c0a96224810c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caeeeee430d82a2e4122005babb4c0a96224810c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/672632317ac901f369b65b25f2147b3e7790ecca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672632317ac901f369b65b25f2147b3e7790ecca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/672632317ac901f369b65b25f2147b3e7790ecca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672632317ac901f369b65b25f2147b3e7790ecca/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7852bd30a19d29ff7986869453786d460d17877", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7852bd30a19d29ff7986869453786d460d17877", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7852bd30a19d29ff7986869453786d460d17877"}], "stats": {"total": 249, "additions": 170, "deletions": 79}, "files": [{"sha": "85ed6f9d47e96fafe13c8dd40dabbd2b82412981", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672632317ac901f369b65b25f2147b3e7790ecca/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672632317ac901f369b65b25f2147b3e7790ecca/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=672632317ac901f369b65b25f2147b3e7790ecca", "patch": "@@ -1029,15 +1029,16 @@ fold_using_range::range_of_builtin_int_call (irange &r, gcall *call,\n \tfrange tmp;\n \tif (src.get_operand (tmp, arg))\n \t  {\n-\t    if (tmp.get_signbit ().varying_p ()\n-\t\t// FIXME: We don't support signed NANs yet.\n-\t\t|| !tmp.get_nan ().no_p ())\n-\t      return false;\n-\t    if (tmp.get_signbit ().yes_p ())\n-\t      r.set_nonzero (type);\n-\t    else\n-\t      r.set_zero (type);\n-\t    return true;\n+\t    bool signbit;\n+\t    if (tmp.known_signbit (signbit))\n+\t      {\n+\t\tif (signbit)\n+\t\t  r.set_nonzero (type);\n+\t\telse\n+\t\t  r.set_zero (type);\n+\t\treturn true;\n+\t      }\n+\t    return false;\n \t  }\n \tbreak;\n       }"}, {"sha": "0f928b6c098cbe043af2d0514867a1d274b784f1", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672632317ac901f369b65b25f2147b3e7790ecca/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672632317ac901f369b65b25f2147b3e7790ecca/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=672632317ac901f369b65b25f2147b3e7790ecca", "patch": "@@ -167,17 +167,15 @@ frange_set_nan (frange &r, tree type)\n static inline bool\n finite_operand_p (const frange &op1)\n {\n-  return flag_finite_math_only || op1.get_nan ().no_p ();\n+  return flag_finite_math_only || !op1.maybe_nan ();\n }\n \n // Return TRUE if OP1 and OP2 are known to be free of NANs.\n \n static inline bool\n finite_operands_p (const frange &op1, const frange &op2)\n {\n-  return (flag_finite_math_only\n-\t  || (op1.get_nan ().no_p ()\n-\t      && op2.get_nan ().no_p ()));\n+  return flag_finite_math_only || (!op1.maybe_nan () && !op2.maybe_nan ());\n }\n \n // Floating version of relop_early_resolve that takes into account NAN\n@@ -546,7 +544,7 @@ foperator_lt::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+  else if (op1.known_nan () || op2.known_nan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n@@ -648,7 +646,7 @@ foperator_le::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+  else if (op1.known_nan () || op2.known_nan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n@@ -742,7 +740,7 @@ foperator_gt::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+  else if (op1.known_nan () || op2.known_nan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n@@ -844,7 +842,7 @@ foperator_ge::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+  else if (op1.known_nan () || op2.known_nan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n@@ -927,10 +925,10 @@ foperator_unordered::fold_range (irange &r, tree type,\n \t\t\t\t relation_kind) const\n {\n   // UNORDERED is TRUE if either operand is a NAN.\n-  if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+  if (op1.known_nan () || op2.known_nan ())\n     r = range_true (type);\n   // UNORDERED is FALSE if neither operand is a NAN.\n-  else if (op1.get_nan ().no_p () && op2.get_nan ().no_p ())\n+  else if (!op1.maybe_nan () && !op2.maybe_nan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n@@ -949,7 +947,7 @@ foperator_unordered::op1_range (frange &r, tree type,\n       r.set_varying (type);\n       // Since at least one operand must be NAN, if one of them is\n       // not, the other must be.\n-      if (op2.get_nan ().no_p ())\n+      if (!op2.maybe_nan ())\n \tfrange_set_nan (r, type);\n       break;\n \n@@ -993,11 +991,9 @@ foperator_ordered::fold_range (irange &r, tree type,\n \t\t\t       const frange &op1, const frange &op2,\n \t\t\t       relation_kind) const\n {\n-  // ORDERED is TRUE if neither operand is a NAN.\n-  if (op1.get_nan ().no_p () && op2.get_nan ().no_p ())\n+  if (!op1.maybe_nan () && !op2.maybe_nan ())\n     r = range_true (type);\n-  // ORDERED is FALSE if either operand is a NAN.\n-  else if (op1.get_nan ().yes_p () || op2.get_nan ().yes_p ())\n+  else if (op1.known_nan () || op2.known_nan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);"}, {"sha": "adcaaa2a69a0f941168b6afffd5fdc8665cd8585", "filename": "gcc/value-range.cc", "status": "modified", "additions": 73, "deletions": 53, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672632317ac901f369b65b25f2147b3e7790ecca/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672632317ac901f369b65b25f2147b3e7790ecca/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=672632317ac901f369b65b25f2147b3e7790ecca", "patch": "@@ -274,7 +274,7 @@ frange::set_nan (fp_prop::kind k)\n {\n   if (k == fp_prop::YES)\n     {\n-      if (get_nan ().no_p ())\n+      if (!maybe_nan ())\n \t{\n \t  set_undefined ();\n \t  return;\n@@ -284,7 +284,7 @@ frange::set_nan (fp_prop::kind k)\n       return;\n     }\n \n-  if (k == fp_prop::NO && get_nan ().yes_p ())\n+  if (k == fp_prop::NO && known_nan ())\n     {\n       set_undefined ();\n       return;\n@@ -308,39 +308,41 @@ frange::set_signbit (fp_prop::kind k)\n   gcc_checking_assert (m_type);\n \n   // No additional adjustments are needed for a NAN.\n-  if (get_nan ().yes_p ())\n+  if (known_nan ())\n     {\n       m_props.set_signbit (k);\n       return;\n     }\n   // Ignore sign changes when they're set correctly.\n-  if (real_less (&m_max, &dconst0))\n-    {\n-      gcc_checking_assert (get_signbit ().yes_p ());\n-      return;\n-    }\n-  if (real_less (&dconst0, &m_min))\n+  if (!maybe_nan ())\n     {\n-      gcc_checking_assert (get_signbit ().no_p ());\n-      return;\n+      if (real_less (&m_max, &dconst0))\n+\treturn;\n+      if (real_less (&dconst0, &m_min))\n+\treturn;\n     }\n   // Adjust the range depending on the sign bit.\n   if (k == fp_prop::YES)\n     {\n       // Crop the range to [-INF, 0].\n       frange crop (m_type, dconstninf, dconst0);\n       intersect (crop);\n-      m_props.set_signbit (fp_prop::YES);\n+      if (!undefined_p ())\n+\tm_props.set_signbit (fp_prop::YES);\n     }\n   else if (k == fp_prop::NO)\n     {\n       // Crop the range to [0, +INF].\n       frange crop (m_type, dconst0, dconstinf);\n       intersect (crop);\n-      m_props.set_signbit (fp_prop::NO);\n+      if (!undefined_p ())\n+\tm_props.set_signbit (fp_prop::NO);\n     }\n   else\n-    m_props.set_signbit (fp_prop::VARYING);\n+    {\n+      m_props.set_signbit (fp_prop::VARYING);\n+      normalize_kind ();\n+    }\n \n   if (flag_checking)\n     verify_range ();\n@@ -467,7 +469,7 @@ frange::union_ (const vrange &v)\n \n   // If one side has a NAN, the union is the other side, plus the union\n   // of the properties and the possibility of a NAN.\n-  if (get_nan ().yes_p ())\n+  if (known_nan ())\n     {\n       frange_props save = m_props;\n       *this = r;\n@@ -478,7 +480,7 @@ frange::union_ (const vrange &v)\n \tverify_range ();\n       return true;\n     }\n-  if (r.get_nan ().yes_p ())\n+  if (r.known_nan ())\n     {\n       m_props.union_ (r.m_props);\n       set_nan (fp_prop::VARYING);\n@@ -525,7 +527,7 @@ frange::intersect (const vrange &v)\n \n   // If two NANs are not exactly the same, drop to an unknown NAN,\n   // otherwise there's nothing to do.\n-  if (get_nan ().yes_p () && r.get_nan ().yes_p ())\n+  if (known_nan () && r.known_nan ())\n     {\n       if (m_props == r.m_props)\n \treturn false;\n@@ -534,7 +536,7 @@ frange::intersect (const vrange &v)\n       return true;\n     }\n   // ?? Perhaps the intersection of a NAN and anything is a NAN ??.\n-  if (get_nan ().yes_p () || r.get_nan ().yes_p ())\n+  if (known_nan () || r.known_nan ())\n     {\n       set_varying (m_type);\n       return true;\n@@ -590,8 +592,7 @@ frange::operator== (const frange &src) const\n       if (varying_p ())\n \treturn types_compatible_p (m_type, src.m_type);\n \n-      if (m_props.get_nan ().yes_p ()\n-\t  || src.m_props.get_nan ().yes_p ())\n+      if (known_nan () || src.known_nan ())\n \treturn false;\n \n       return (real_identical (&m_min, &src.m_min)\n@@ -621,6 +622,9 @@ frange::contains_p (tree cst) const\n     {\n       if (HONOR_SIGNED_ZEROS (m_type) && real_iszero (rv))\n \t{\n+\t  // FIXME: This is still using get_signbit() instead of\n+\t  // known_signbit() because the latter bails on possible NANs\n+\t  // (for now).\n \t  if (get_signbit ().yes_p ())\n \t    return real_isneg (rv);\n \t  else if (get_signbit ().no_p ())\n@@ -644,22 +648,25 @@ frange::singleton_p (tree *result) const\n   if (m_kind == VR_RANGE && real_identical (&m_min, &m_max))\n     {\n       // Return false for any singleton that may be a NAN.\n-      if (HONOR_NANS (m_type) && !get_nan ().no_p ())\n+      if (HONOR_NANS (m_type) && maybe_nan ())\n \treturn false;\n \n       // Return the appropriate zero if known.\n       if (HONOR_SIGNED_ZEROS (m_type) && zero_p ())\n \t{\n-\t  if (get_signbit ().no_p ())\n+\t  bool signbit;\n+\t  if (known_signbit (signbit))\n \t    {\n-\t      if (result)\n-\t\t*result = build_real (m_type, dconst0);\n-\t      return true;\n-\t    }\n-\t  if (get_signbit ().yes_p ())\n-\t    {\n-\t      if (result)\n-\t\t*result = build_real (m_type, real_value_negate (&dconst0));\n+\t      if (signbit)\n+\t\t{\n+\t\t  if (result)\n+\t\t    *result = build_real (m_type, real_value_negate (&dconst0));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (result)\n+\t\t    *result = build_real (m_type, dconst0);\n+\t\t}\n \t      return true;\n \t    }\n \t  return false;\n@@ -701,7 +708,7 @@ frange::verify_range ()\n     {\n       // If either is a NAN, both must be a NAN.\n       gcc_checking_assert (real_identical (&m_min, &m_max));\n-      gcc_checking_assert (get_nan ().yes_p ());\n+      gcc_checking_assert (known_nan ());\n     }\n   else\n     // Make sure we don't have swapped ranges.\n@@ -710,18 +717,22 @@ frange::verify_range ()\n   // If we're absolutely sure we have a NAN, the endpoints should\n   // reflect this, otherwise we'd have more than one way to represent\n   // a NAN.\n-  if (m_props.get_nan ().yes_p ())\n+  if (known_nan ())\n     {\n       gcc_checking_assert (real_isnan (&m_min));\n       gcc_checking_assert (real_isnan (&m_max));\n     }\n   else\n     {\n       // Make sure the signbit and range agree.\n-      if (m_props.get_signbit ().yes_p ())\n-\tgcc_checking_assert (real_compare (LE_EXPR, &m_max, &dconst0));\n-      else if (m_props.get_signbit ().no_p ())\n-\tgcc_checking_assert (real_compare (GE_EXPR, &m_min, &dconst0));\n+      bool signbit;\n+      if (known_signbit (signbit))\n+\t{\n+\t  if (signbit)\n+\t    gcc_checking_assert (real_compare (LE_EXPR, &m_max, &dconst0));\n+\t  else\n+\t    gcc_checking_assert (real_compare (GE_EXPR, &m_min, &dconst0));\n+\t}\n     }\n \n   // If all the properties are clear, we better not span the entire\n@@ -3637,7 +3648,7 @@ range_tests_nan ()\n   ASSERT_FALSE (r0 == r0);\n   ASSERT_TRUE (r0 != r0);\n \n-  // [5,6] U NAN is [5,6] with an unknown NAN bit.\n+  // [5,6] U NAN.\n   r0 = frange_float (\"5\", \"6\");\n   r0.set_nan (fp_prop::NO);\n   r1 = frange_nan (float_type_node);\n@@ -3646,15 +3657,15 @@ range_tests_nan ()\n   real_from_string (&r, \"6\");\n   ASSERT_TRUE (real_identical (&q, &r0.lower_bound ()));\n   ASSERT_TRUE (real_identical (&r, &r0.upper_bound ()));\n-  ASSERT_TRUE (r0.get_nan ().varying_p ());\n+  ASSERT_TRUE (r0.maybe_nan ());\n \n   // NAN U NAN = NAN\n   r0 = frange_nan (float_type_node);\n   r1 = frange_nan (float_type_node);\n   r0.union_ (r1);\n   ASSERT_TRUE (real_isnan (&r0.lower_bound ()));\n   ASSERT_TRUE (real_isnan (&r1.upper_bound ()));\n-  ASSERT_TRUE (r0.get_nan ().yes_p ());\n+  ASSERT_TRUE (r0.known_nan ());\n \n   // [INF, INF] ^ NAN = VARYING\n   r0 = frange_nan (float_type_node);\n@@ -3666,18 +3677,18 @@ range_tests_nan ()\n   r0 = frange_nan (float_type_node);\n   r1 = frange_nan (float_type_node);\n   r0.intersect (r1);\n-  ASSERT_TRUE (r0.get_nan ().yes_p ());\n+  ASSERT_TRUE (r0.known_nan ());\n \n   // VARYING ^ NAN = NAN.\n   r0 = frange_nan (float_type_node);\n   r1.set_varying (float_type_node);\n   r0.intersect (r1);\n-  ASSERT_TRUE (r0.get_nan ().yes_p ());\n+  ASSERT_TRUE (r0.known_nan ());\n \n   // Setting the NAN bit to yes, forces to range to [NAN, NAN].\n   r0.set_varying (float_type_node);\n   r0.set_nan (fp_prop::YES);\n-  ASSERT_TRUE (r0.get_nan ().yes_p ());\n+  ASSERT_TRUE (r0.known_nan ());\n   ASSERT_TRUE (real_isnan (&r0.lower_bound ()));\n   ASSERT_TRUE (real_isnan (&r0.upper_bound ()));\n }\n@@ -3689,6 +3700,7 @@ range_tests_signed_zeros ()\n   tree neg_zero = fold_build1 (NEGATE_EXPR, float_type_node, zero);\n   REAL_VALUE_TYPE q, r;\n   frange r0, r1;\n+  bool signbit;\n \n   // Since -0.0 == +0.0, a range of [-0.0, -0.0] should contain +0.0\n   // and vice versa.\n@@ -3722,7 +3734,7 @@ range_tests_signed_zeros ()\n   r1 = frange (zero, zero);\n   r1.set_signbit (fp_prop::YES);\n   r0.union_ (r1);\n-  ASSERT_TRUE (r0.zero_p () && r0.get_signbit ().varying_p ());\n+  ASSERT_TRUE (r0.zero_p () && !r0.known_signbit (signbit));\n \n   // NAN U [5,6] should be [5,6] with no sign info.\n   r0 = frange_nan (float_type_node);\n@@ -3732,13 +3744,14 @@ range_tests_signed_zeros ()\n   real_from_string (&r, \"6\");\n   ASSERT_TRUE (real_identical (&q, &r0.lower_bound ()));\n   ASSERT_TRUE (real_identical (&r, &r0.upper_bound ()));\n-  ASSERT_TRUE (r0.get_signbit ().varying_p ());\n+  ASSERT_TRUE (!r0.known_signbit (signbit));\n }\n \n static void\n range_tests_signbit ()\n {\n   frange r0, r1;\n+  bool signbit;\n \n   // Setting the signbit drops the range to [-INF, 0].\n   r0.set_varying (float_type_node);\n@@ -3750,35 +3763,42 @@ range_tests_signbit ()\n   // the signbit property set.\n   r0 = frange_float (\"-5\", \"10\");\n   r0.set_signbit (fp_prop::YES);\n-  ASSERT_TRUE (r0.get_signbit ().yes_p ());\n+  r0.set_nan (fp_prop::NO);\n+  ASSERT_TRUE (r0.known_signbit (signbit) && signbit);\n   r1 = frange_float (\"-5\", \"0\");\n   ASSERT_TRUE (real_identical (&r0.lower_bound (), &r1.lower_bound ()));\n   ASSERT_TRUE (real_identical (&r0.upper_bound (), &r1.upper_bound ()));\n \n   // Negative numbers should have the SIGNBIT set.\n   r0 = frange_float (\"-5\", \"-1\");\n-  ASSERT_TRUE (r0.get_signbit ().yes_p ());\n+  r0.set_nan (fp_prop::NO);\n+  ASSERT_TRUE (r0.known_signbit (signbit) && signbit);\n   // Positive numbers should have the SIGNBIT clear.\n   r0 = frange_float (\"1\", \"10\");\n-  ASSERT_TRUE (r0.get_signbit ().no_p ());\n+  r0.set_nan (fp_prop::NO);\n+  ASSERT_TRUE (r0.known_signbit (signbit) && !signbit);\n   // Numbers containing zero should have an unknown SIGNBIT.\n   r0 = frange_float (\"0\", \"10\");\n-  ASSERT_TRUE (r0.get_signbit ().varying_p ());\n+  r0.set_nan (fp_prop::NO);\n+  ASSERT_TRUE (!r0.known_signbit (signbit));\n   // Numbers spanning both positive and negative should have an\n   // unknown SIGNBIT.\n   r0 = frange_float (\"-10\", \"10\");\n-  ASSERT_TRUE (r0.get_signbit ().varying_p ());\n+  r0.set_nan (fp_prop::NO);\n+  ASSERT_TRUE (!r0.known_signbit (signbit));\n   r0.set_varying (float_type_node);\n-  ASSERT_TRUE (r0.get_signbit ().varying_p ());\n+  ASSERT_TRUE (!r0.known_signbit (signbit));\n \n   // Ignore signbit changes when the sign bit is obviously known from\n   // the range.\n   r0 = frange_float (\"5\", \"10\");\n+  r0.set_nan (fp_prop::NO);\n   r0.set_signbit (fp_prop::VARYING);\n-  ASSERT_TRUE (r0.get_signbit ().no_p ());\n+  ASSERT_TRUE (r0.known_signbit (signbit) && !signbit);\n   r0 = frange_float (\"-5\", \"-1\");\n   r0.set_signbit (fp_prop::NO);\n-  ASSERT_TRUE (r0.get_signbit ().yes_p ());\n+  r0.set_nan (fp_prop::NO);\n+  ASSERT_TRUE (r0.undefined_p ());\n }\n \n static void\n@@ -3795,7 +3815,7 @@ range_tests_floats ()\n   // A range of [-INF,+INF] is actually VARYING if no other properties\n   // are set.\n   r0 = frange_float (\"-Inf\", \"+Inf\");\n-  if (r0.get_nan ().varying_p ())\n+  if (r0.maybe_nan ())\n     ASSERT_TRUE (r0.varying_p ());\n   // ...unless it has some special property...\n   r0.set_nan (fp_prop::NO);"}, {"sha": "f9a01ee7a0593f2e1d4a045419617e1b6844b9d1", "filename": "gcc/value-range.h", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672632317ac901f369b65b25f2147b3e7790ecca/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672632317ac901f369b65b25f2147b3e7790ecca/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=672632317ac901f369b65b25f2147b3e7790ecca", "patch": "@@ -330,6 +330,7 @@ class frange_props\n class frange : public vrange\n {\n   friend class frange_storage_slot;\n+  friend class vrange_printer;\n public:\n   frange ();\n   frange (const frange &);\n@@ -366,12 +367,20 @@ class frange : public vrange\n   const REAL_VALUE_TYPE &lower_bound () const;\n   const REAL_VALUE_TYPE &upper_bound () const;\n \n+  // fpclassify like API\n+  bool known_finite () const;\n+  bool maybe_inf () const;\n+  bool known_inf () const;\n+  bool maybe_nan () const;\n+  bool known_nan () const;\n+  bool known_signbit (bool &signbit) const;\n+\n   // Accessors for FP properties.\n-  fp_prop get_nan () const { return m_props.get_nan (); }\n   void set_nan (fp_prop::kind f);\n-  fp_prop get_signbit () const { return m_props.get_signbit (); }\n   void set_signbit (fp_prop::kind);\n private:\n+  fp_prop get_nan () const { return m_props.get_nan (); }\n+  fp_prop get_signbit () const { return m_props.get_signbit (); }\n   void verify_range ();\n   bool normalize_kind ();\n \n@@ -1187,4 +1196,69 @@ frange_nan (tree type)\n   return frange (type, r, r);\n }\n \n+// Return TRUE if range is known to be finite.\n+\n+inline bool\n+frange::known_finite () const\n+{\n+  if (undefined_p () || varying_p () || m_kind == VR_ANTI_RANGE)\n+    return false;\n+  return (!real_isnan (&m_min)\n+\t  && !real_isinf (&m_min)\n+\t  && !real_isinf (&m_max));\n+}\n+\n+// Return TRUE if range may be infinite.\n+\n+inline bool\n+frange::maybe_inf () const\n+{\n+  if (undefined_p () || m_kind == VR_ANTI_RANGE)\n+    return false;\n+  if (varying_p ())\n+    return true;\n+  return real_isinf (&m_min) || real_isinf (&m_max);\n+}\n+\n+// Return TRUE if range is known to be the [-INF,-INF] or [+INF,+INF].\n+\n+inline bool\n+frange::known_inf () const\n+{\n+  return (m_kind == VR_RANGE\n+\t  && real_identical (&m_min, &m_max)\n+\t  && real_isinf (&m_min));\n+}\n+\n+// Return TRUE if range is possibly a NAN.\n+\n+inline bool\n+frange::maybe_nan () const\n+{\n+  return !get_nan ().no_p ();\n+}\n+\n+// Return TRUE if range is a +NAN or -NAN.\n+\n+inline bool\n+frange::known_nan () const\n+{\n+  return get_nan ().yes_p ();\n+}\n+\n+// If the signbit for the range is known, set it in SIGNBIT and return\n+// TRUE.\n+\n+inline bool\n+frange::known_signbit (bool &signbit) const\n+{\n+  // FIXME: Signed NANs are not supported yet.\n+  if (maybe_nan ())\n+    return false;\n+  if (get_signbit ().varying_p ())\n+    return false;\n+  signbit = get_signbit ().yes_p ();\n+  return true;\n+}\n+\n #endif // GCC_VALUE_RANGE_H"}]}