{"sha": "88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhjZTgwMzE2ZmJiNGQwMDFmMDhlYjRjNjVkYmI3YWU4OGUwNDc0Zg==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-07-13T06:57:17Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-07-13T06:57:17Z"}, "message": "re PR fortran/44434 ([OOP] ICE in in gfc_add_component_ref)\n\n2010-07-13  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/44434\n\tPR fortran/44565\n\tPR fortran/43945\n\tPR fortran/44869\n\t* gfortran.h (gfc_find_derived_vtab): Modified prototype.\n\t* class.c (gfc_build_class_symbol): Modified call to\n\t'gfc_find_derived_vtab'.\n\t(add_proc_component): Removed, moved code into 'add_proc_comp'.\n\t(add_proc_comps): Renamed to 'add_proc_comp', removed treatment of\n\tgenerics.\n\t(add_procs_to_declared_vtab1): Removed unnecessary argument 'resolved'.\n\tRemoved treatment of generics.\n\t(copy_vtab_proc_comps): Removed unnecessary argument 'resolved'.\n\tCall 'add_proc_comp' instead of duplicating code.\n\t(add_procs_to_declared_vtab): Removed unnecessary arguments 'resolved'\n\tand 'declared'.\n\t(add_generic_specifics,add_generics_to_declared_vtab): Removed.\n\t(gfc_find_derived_vtab): Removed unnecessary argument 'resolved'.\n\tRemoved treatment of generics.\n\t* iresolve.c (gfc_resolve_extends_type_of): Modified call to\n\t'gfc_find_derived_vtab'.\n\t* resolve.c (resolve_typebound_function,resolve_typebound_subroutine):\n\tRemoved treatment of generics.\n\t(resolve_select_type,resolve_fl_derived): Modified call to\n\t'gfc_find_derived_vtab'.\n\t* trans-decl.c (gfc_get_symbol_decl): Ditto.\n\t* trans-expr.c (gfc_conv_derived_to_class,gfc_trans_class_assign):\n\tDitto.\n\t* trans-stmt.c (gfc_trans_allocate): Ditto.\n\n2010-07-13  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/44434\n\tPR fortran/44565\n\tPR fortran/43945\n\tPR fortran/44869\n\t* gfortran.dg/dynamic_dispatch_1.f03: Fixed invalid test case.\n\t* gfortran.dg/dynamic_dispatch_2.f03: Ditto.\n\t* gfortran.dg/dynamic_dispatch_3.f03: Ditto.\n\t* gfortran.dh/typebound_call_16.f03: New.\n\t* gfortran.dg/typebound_generic_6.f03: New.\n\t* gfortran.dg/typebound_generic_7.f03: New.\n\t* gfortran.dg/typebound_generic_8.f03: New.\n\nFrom-SVN: r162125", "tree": {"sha": "7689fad89ebad1266a4bfa1f56e3f71d86faafdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7689fad89ebad1266a4bfa1f56e3f71d86faafdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1743e3754feb057b0019d46b1aadbd571afe657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1743e3754feb057b0019d46b1aadbd571afe657", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1743e3754feb057b0019d46b1aadbd571afe657"}], "stats": {"total": 640, "additions": 286, "deletions": 354}, "files": [{"sha": "b4a6f1b9f3bb5ffb4524c316b5d2bf43faf44e97", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -1,3 +1,35 @@\n+2010-07-13  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/44434\n+\tPR fortran/44565\n+\tPR fortran/43945\n+\tPR fortran/44869\n+\t* gfortran.h (gfc_find_derived_vtab): Modified prototype.\n+\t* class.c (gfc_build_class_symbol): Modified call to\n+\t'gfc_find_derived_vtab'.\n+\t(add_proc_component): Removed, moved code into 'add_proc_comp'.\n+\t(add_proc_comps): Renamed to 'add_proc_comp', removed treatment of\n+\tgenerics.\n+\t(add_procs_to_declared_vtab1): Removed unnecessary argument 'resolved'.\n+\tRemoved treatment of generics.\n+\t(copy_vtab_proc_comps): Removed unnecessary argument 'resolved'.\n+\tCall 'add_proc_comp' instead of duplicating code.\n+\t(add_procs_to_declared_vtab): Removed unnecessary arguments 'resolved'\n+\tand 'declared'.\n+\t(add_generic_specifics,add_generics_to_declared_vtab): Removed.\n+\t(gfc_find_derived_vtab): Removed unnecessary argument 'resolved'.\n+\tRemoved treatment of generics.\n+\t* iresolve.c (gfc_resolve_extends_type_of): Modified call to\n+\t'gfc_find_derived_vtab'.\n+\t* resolve.c (resolve_typebound_function,resolve_typebound_subroutine):\n+\tRemoved treatment of generics.\n+\t(resolve_select_type,resolve_fl_derived): Modified call to\n+\t'gfc_find_derived_vtab'.\n+\t* trans-decl.c (gfc_get_symbol_decl): Ditto.\n+\t* trans-expr.c (gfc_conv_derived_to_class,gfc_trans_class_assign):\n+\tDitto.\n+\t* trans-stmt.c (gfc_trans_allocate): Ditto.\n+\n 2010-07-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/37077"}, {"sha": "b5e17f4e2f63530517ce676d632c48d724f87eed", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 66, "deletions": 293, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -174,7 +174,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n \tc->ts.u.derived = NULL;\n       else\n \t{\n-\t  vtab = gfc_find_derived_vtab (ts->u.derived, false);\n+\t  vtab = gfc_find_derived_vtab (ts->u.derived);\n \t  gcc_assert (vtab);\n \t  c->ts.u.derived = vtab->ts.u.derived;\n \t}\n@@ -199,344 +199,126 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n }\n \n \n+/* Add a procedure pointer component to the vtype\n+   to represent a specific type-bound procedure.  */\n+\n static void\n-add_proc_component (gfc_component *c, gfc_symbol *vtype,\n-\t\t    gfc_symtree *st, gfc_symbol *specific,\n-\t\t    bool is_generic, bool is_generic_specific)\n+add_proc_comp (gfc_symbol *vtype, const char *name, gfc_typebound_proc *tb)\n {\n-  /* Add procedure component.  */\n-  if (is_generic)\n-    {\n-      if (gfc_add_component (vtype, specific->name, &c) == FAILURE)\n-\treturn;\n-      c->ts.interface = specific;\n-    }\n-  else if (c && is_generic_specific)\n-    {\n-      c->ts.interface = st->n.tb->u.specific->n.sym;\n-    }\n-  else\n+  gfc_component *c;\n+  c = gfc_find_component (vtype, name, true, true);\n+\n+  if (c == NULL)\n     {\n-      c = gfc_find_component (vtype, st->name, true, true);\n-      if (!c && gfc_add_component (vtype, st->name, &c) == FAILURE)\n+      /* Add procedure component.  */\n+      if (gfc_add_component (vtype, name, &c) == FAILURE)\n \treturn;\n-      c->ts.interface = st->n.tb->u.specific->n.sym;\n-    }\n-\n-  if (!c->tb)\n-    c->tb = XCNEW (gfc_typebound_proc);\n-  *c->tb = *st->n.tb;\n-  c->tb->ppc = 1;\n-  c->attr.procedure = 1;\n-  c->attr.proc_pointer = 1;\n-  c->attr.flavor = FL_PROCEDURE;\n-  c->attr.access = ACCESS_PRIVATE;\n-  c->attr.external = 1;\n-  c->attr.untyped = 1;\n-  c->attr.if_source = IFSRC_IFBODY;\n-\n-  /* A static initializer cannot be used here because the specific\n-     function is not a constant; internal compiler error: in\n-     output_constant, at varasm.c:4623  */\n-  c->initializer = NULL;\n-}\n+      if (tb->u.specific)\n+\tc->ts.interface = tb->u.specific->n.sym;\n \n+      if (!c->tb)\n+\tc->tb = XCNEW (gfc_typebound_proc);\n+      *c->tb = *tb;\n+      c->tb->ppc = 1;\n+      c->attr.procedure = 1;\n+      c->attr.proc_pointer = 1;\n+      c->attr.flavor = FL_PROCEDURE;\n+      c->attr.access = ACCESS_PRIVATE;\n+      c->attr.external = 1;\n+      c->attr.untyped = 1;\n+      c->attr.if_source = IFSRC_IFBODY;\n \n-static void\n-add_proc_comps (gfc_component *c, gfc_symbol *vtype,\n-\t\tgfc_symtree *st, bool is_generic)\n-{\n-  if (c == NULL && !is_generic)\n-    {\n-      add_proc_component (c, vtype, st, NULL, false, false);\n-    }\n-  else if (is_generic && st->n.tb && vtype->components == NULL)\n-    {\n-      gfc_tbp_generic* g;\n-      gfc_symbol * specific;\n-      for (g = st->n.tb->u.generic; g; g = g->next)\n-\t{\n-\t  if (!g->specific)\n-\t    continue;\n-\t  specific = g->specific->u.specific->n.sym;\n-\t  add_proc_component (NULL, vtype, st, specific, true, false);\n-\t}\n+      /* A static initializer cannot be used here because the specific\n+\tfunction is not a constant; internal compiler error: in\n+\toutput_constant, at varasm.c:4623  */\n+      c->initializer = NULL;\n     }\n   else if (c->attr.proc_pointer && c->tb)\n     {\n-      *c->tb = *st->n.tb;\n+      *c->tb = *tb;\n       c->tb->ppc = 1;\n-      c->ts.interface = st->n.tb->u.specific->n.sym;\t  \n+      c->ts.interface = tb->u.specific->n.sym;\t  \n     }\n }\n \n+\n+/* Add all specific type-bound procedures in the symtree 'st' to a vtype.  */\n+\n static void\n-add_procs_to_declared_vtab1 (gfc_symtree *st, gfc_symbol *vtype,\n-\t\t\t     bool resolved)\n+add_procs_to_declared_vtab1 (gfc_symtree *st, gfc_symbol *vtype)\n {\n-  gfc_component *c;\n-  gfc_symbol *generic;\n-  char name[3 * GFC_MAX_SYMBOL_LEN + 10];\n-\n   if (!st)\n     return;\n \n   if (st->left)\n-    add_procs_to_declared_vtab1 (st->left, vtype, resolved);\n+    add_procs_to_declared_vtab1 (st->left, vtype);\n \n   if (st->right)\n-    add_procs_to_declared_vtab1 (st->right, vtype, resolved);\n+    add_procs_to_declared_vtab1 (st->right, vtype);\n \n   if (!st->n.tb)\n     return;\n \n   if (!st->n.tb->is_generic && st->n.tb->u.specific)\n-    {\n-      c = gfc_find_component (vtype, st->name, true, true);\n-      add_proc_comps (c, vtype, st, false);\n-    }\n-  else if (st->n.tb->is_generic)\n-    {\n-      c = gfc_find_component (vtype, st->name, true, true);\n-\n-      if (c == NULL)\n-\t{\n-\t  /* Add derived type component with generic name.  */\n-\t  if (gfc_add_component (vtype, st->name, &c) == FAILURE)\n-\t    return;\n-\t  c->ts.type = BT_DERIVED;\n-\t  c->attr.flavor = FL_VARIABLE;\n-\t  c->attr.pointer = 1;\n-\n-\t  /* Add a special empty derived type as a placeholder.  */\n-\t  sprintf (name, \"$empty\");\n-\t  gfc_find_symbol (name, vtype->ns, 0, &generic);\n-\t  if (generic == NULL)\n-\t    {\n-\t      gfc_get_symbol (name, vtype->ns, &generic);\n-\t      generic->attr.flavor = FL_DERIVED;\n-\t      generic->refs++;\n-\t      gfc_set_sym_referenced (generic);\n-\t      generic->ts.type = BT_UNKNOWN;\n-\t      generic->attr.zero_comp = 1;\n-\t    }\n-\n-\t  c->ts.u.derived = generic;\n-\t}\n-    }\n+    add_proc_comp (vtype, st->name, st->n.tb);\n }\n \n \n+/* Copy procedure pointers components from the parent type.  */\n+\n static void\n-copy_vtab_proc_comps (gfc_symbol *declared, gfc_symbol *vtype,\n-\t\t      bool resolved)\n+copy_vtab_proc_comps (gfc_symbol *declared, gfc_symbol *vtype)\n {\n-  gfc_component *c, *cmp;\n+  gfc_component *cmp;\n   gfc_symbol *vtab;\n \n-  vtab = gfc_find_derived_vtab (declared, resolved);\n+  vtab = gfc_find_derived_vtab (declared);\n \n   for (cmp = vtab->ts.u.derived->components; cmp; cmp = cmp->next)\n     {\n       if (gfc_find_component (vtype, cmp->name, true, true))\n \tcontinue;\n \n-      if (gfc_add_component (vtype, cmp->name, &c) == FAILURE)\n-\treturn;\n-\n-      if (cmp->ts.type == BT_DERIVED)\n-\t{\n-\t  c->ts = cmp->ts;\n-\t  c->ts.u.derived = cmp->ts.u.derived;\n-\t  c->attr.flavor = FL_VARIABLE;\n-\t  c->attr.pointer = 1;\n-\t  c->initializer = NULL;\n-\t  continue;\n-\t}\n-\n-      c->tb = XCNEW (gfc_typebound_proc);\n-      *c->tb = *cmp->tb;\n-      c->attr.procedure = 1;\n-      c->attr.proc_pointer = 1;\n-      c->attr.flavor = FL_PROCEDURE;\n-      c->attr.access = ACCESS_PRIVATE;\n-      c->attr.external = 1;\n-      c->ts.interface = cmp->ts.interface;\n-      c->attr.untyped = 1;\n-      c->attr.if_source = IFSRC_IFBODY;\n-      c->initializer = NULL;\n+      add_proc_comp (vtype, cmp->name, cmp->tb);\n     }\n }\n \n-static void\n-add_procs_to_declared_vtab (gfc_symbol *declared, gfc_symbol *vtype,\n-\t\t\t    gfc_symbol *derived, bool resolved)\n-{\n-  gfc_symbol* super_type;\n-\n-  super_type = gfc_get_derived_super_type (declared);\n-\n-  if (super_type && (super_type != declared))\n-    add_procs_to_declared_vtab (super_type, vtype, derived, resolved);\n-\n-  if (declared != derived)\n-    copy_vtab_proc_comps (declared, vtype, resolved);\n-\n-  if (declared->f2k_derived && declared->f2k_derived->tb_sym_root)\n-    add_procs_to_declared_vtab1 (declared->f2k_derived->tb_sym_root,\n-\t\t\t\t vtype, resolved);\n-\n-  if (declared->f2k_derived && declared->f2k_derived->tb_uop_root)\n-    add_procs_to_declared_vtab1 (declared->f2k_derived->tb_uop_root,\n-\t\t\t\t vtype, resolved);\n-}\n-\n-\n-static\n-void add_generic_specifics (gfc_symbol *declared, gfc_symbol *vtab,\n-\t\t\t    const char *name)\n-{\n-  gfc_tbp_generic* g;\n-  gfc_symbol * specific1;\n-  gfc_symbol * specific2;\n-  gfc_symtree *st = NULL;\n-  gfc_component *c;\n-\n-  /* Find the generic procedure using the component name.  */\n-  st = gfc_find_typebound_proc (declared, NULL, name, true, NULL);\n-  if (st == NULL)\n-    st = gfc_find_typebound_user_op (declared, NULL, name, true, NULL);\n-\n-  if (st == NULL)\n-    return;\n-\n-  /* Add procedure pointer components for the specific procedures. */\n-  for (g = st->n.tb->u.generic; g; g = g->next)\n-    {\n-      if (!g->specific)\n-\tcontinue;\n-      specific1 = g->specific_st->n.tb->u.specific->n.sym;\n-\n-      c = vtab->ts.u.derived->components;\n-      specific2 = NULL;\n-\n-      /* Override identical specific interface.  */\n-      if (vtab->ts.u.derived->components)\n-\t{\n-\t  for (; c; c= c->next)\n-\t    {\n-\t      specific2 = c->ts.interface;\n-\t      if (gfc_compare_interfaces (specific2, specific1,\n-\t\t\t\t\t  specific1->name, 0, 0, NULL, 0))\n-\t\tbreak;\n-\t    }\n-\t}\n-\n-      add_proc_component (c, vtab->ts.u.derived, g->specific_st,\n-\t\t\t  NULL, false, true);\n-      vtab->ts.u.derived->attr.zero_comp = 0;\n-    }\n-}\n \n+/* Add procedure pointers for all type-bound procedures to a vtab.  */\n \n static void\n-add_generics_to_declared_vtab (gfc_symbol *declared, gfc_symbol *vtype,\n-\t\t\t       gfc_symbol *derived, bool resolved)\n+add_procs_to_declared_vtab (gfc_symbol *derived, gfc_symbol *vtype)\n {\n-  gfc_component *cmp;\n-  gfc_symtree *st = NULL;\n-  gfc_symbol * vtab;\n-  char name[2 * GFC_MAX_SYMBOL_LEN + 8];\n   gfc_symbol* super_type;\n \n-  gcc_assert (resolved);\n+  super_type = gfc_get_derived_super_type (derived);\n \n-  for (cmp = vtype->components; cmp; cmp = cmp->next)\n+  if (super_type && (super_type != derived))\n     {\n-      if (cmp->ts.type != BT_DERIVED)\n-\tcontinue;\n-\n-      /* The only derived type that does not represent a generic\n-\t procedure is the pointer to the parent vtab.  */\n-      if (cmp->ts.u.derived\n-\t    && strcmp (cmp->ts.u.derived->name, \"$extends\") == 0)\n-\tcontinue;\n-\n-      /* Find the generic procedure using the component name.  */\n-      st = gfc_find_typebound_proc (declared, NULL, cmp->name,\n-\t\t\t\t    true, NULL);\n-      if (st == NULL)\n-\tst = gfc_find_typebound_user_op (declared, NULL, cmp->name,\n-\t\t\t\t\t true, NULL);\n-\n-      /* Should be an error but we pass on it for now.  */\n-      if (st == NULL || !st->n.tb->is_generic)\n-\tcontinue;\n-\n-      vtab = NULL;\n-\n-      /* Build a vtab and a special vtype, with only the procedure\n-\t pointer fields, to carry the pointers to the specific\n-\t procedures.  Should this name ever be changed, the same\n-\t should be done in trans-expr.c(gfc_trans_assign_vtab_procs). */\n-      sprintf (name, \"vtab$%s$%s\", vtype->name, cmp->name);\n-      gfc_find_symbol (name, derived->ns, 0, &vtab);\n-      if (vtab == NULL)\n-\t{\n-\t  gfc_get_symbol (name, derived->ns, &vtab);\n-\t  vtab->ts.type = BT_DERIVED;\n-\t  vtab->attr.flavor = FL_VARIABLE;\n-\t  vtab->attr.target = 1;\n-\t  vtab->attr.save = SAVE_EXPLICIT;\n-\t  vtab->attr.vtab = 1;\n-\t  vtab->refs++;\n-\t  gfc_set_sym_referenced (vtab);\n-\t  sprintf (name, \"%s$%s\", vtype->name, cmp->name);\n-\t  \n-\t  gfc_find_symbol (name, derived->ns, 0, &cmp->ts.u.derived);\n-\t  if (cmp->ts.u.derived == NULL\n-\t\t|| (strcmp (cmp->ts.u.derived->name, \"$empty\") == 0))\n-\t    {\n-\t      gfc_get_symbol (name, derived->ns, &cmp->ts.u.derived);\n-\t      if (gfc_add_flavor (&cmp->ts.u.derived->attr, FL_DERIVED,\n-\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n-\t\treturn;\n-\t      cmp->ts.u.derived->refs++;\n-\t      gfc_set_sym_referenced (cmp->ts.u.derived);\n-\t      cmp->ts.u.derived->attr.vtype = 1;\n-\t      cmp->ts.u.derived->attr.zero_comp = 1;\n-\t    }\n-\t  vtab->ts.u.derived = cmp->ts.u.derived;\n-\t}\n-\n-      /* Store this for later use in setting the pointer.  */\n-      cmp->ts.interface = vtab;\n-\n-      if (vtab->ts.u.derived->components)\n-\tcontinue;\n-\n-      super_type = gfc_get_derived_super_type (declared);\n+      /* Make sure that the PPCs appear in the same order as in the parent.  */\n+      copy_vtab_proc_comps (super_type, vtype);\n+      /* Only needed to get the PPC interfaces right.  */\n+      add_procs_to_declared_vtab (super_type, vtype);\n+    }\n \n-      if (super_type && (super_type != declared))\n-\tadd_generic_specifics (super_type, vtab, cmp->name);\n+  if (derived->f2k_derived && derived->f2k_derived->tb_sym_root)\n+    add_procs_to_declared_vtab1 (derived->f2k_derived->tb_sym_root, vtype);\n \n-      add_generic_specifics (declared, vtab, cmp->name);\n-    }\n+  if (derived->f2k_derived && derived->f2k_derived->tb_uop_root)\n+    add_procs_to_declared_vtab1 (derived->f2k_derived->tb_uop_root, vtype);\n }\n \n \n-/* Find the symbol for a derived type's vtab.  A vtab has the following\n-   fields:\n-   $hash\ta hash value used to identify the derived type\n-   $size\tthe size in bytes of the derived type\n-   $extends\ta pointer to the vtable of the parent derived type\n-   then:\n-   procedure pointer components for the specific typebound procedures\n-   structure pointers to reduced vtabs that contain procedure\n-   pointers to the specific procedures.  */\n+/* Find the symbol for a derived type's vtab.\n+   A vtab has the following fields:\n+    * $hash\ta hash value used to identify the derived type\n+    * $size\tthe size in bytes of the derived type\n+    * $extends\ta pointer to the vtable of the parent derived type\n+   After these follow procedure pointer components for the\n+   specific type-bound procedures.  */\n \n gfc_symbol *\n-gfc_find_derived_vtab (gfc_symbol *derived, bool resolved)\n+gfc_find_derived_vtab (gfc_symbol *derived)\n {\n   gfc_namespace *ns;\n   gfc_symbol *vtab = NULL, *vtype = NULL;\n@@ -608,7 +390,7 @@ gfc_find_derived_vtab (gfc_symbol *derived, bool resolved)\n \t      parent = gfc_get_derived_super_type (derived);\n \t      if (parent)\n \t\t{\n-\t\t  parent_vtab = gfc_find_derived_vtab (parent, resolved);\n+\t\t  parent_vtab = gfc_find_derived_vtab (parent);\n \t\t  c->ts.type = BT_DERIVED;\n \t\t  c->ts.u.derived = parent_vtab->ts.u.derived;\n \t\t  c->initializer = gfc_get_expr ();\n@@ -623,7 +405,7 @@ gfc_find_derived_vtab (gfc_symbol *derived, bool resolved)\n \t\t  c->initializer = gfc_get_null_expr (NULL);\n \t\t}\n \n-\t      add_procs_to_declared_vtab (derived, vtype, derived, resolved);\n+\t      add_procs_to_declared_vtab (derived, vtype);\n \t      vtype->attr.vtype = 1;\n \t    }\n \n@@ -632,15 +414,6 @@ gfc_find_derived_vtab (gfc_symbol *derived, bool resolved)\n \t}\n     }\n \n-  /* Catch the call just before the backend declarations are built, so that\n-     the generic procedures have been resolved and the specific procedures\n-     have formal interfaces that can be compared.  */\n-  if (resolved\n-\t&& vtab->ts.u.derived\n-\t&& vtab->ts.u.derived->backend_decl == NULL)\n-    add_generics_to_declared_vtab (derived, vtab->ts.u.derived,\n-\t\t\t\t   derived, resolved);\n-\n   return vtab;\n }\n "}, {"sha": "cf14bb46af2f0203b6779dcd63c47fe45957519a", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -2820,7 +2820,7 @@ void gfc_add_component_ref (gfc_expr *, const char *);\n gfc_expr *gfc_class_null_initializer (gfc_typespec *);\n gfc_try gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,\n \t\t\t\tgfc_array_spec **, bool);\n-gfc_symbol *gfc_find_derived_vtab (gfc_symbol *, bool);\n+gfc_symbol *gfc_find_derived_vtab (gfc_symbol *);\n gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, gfc_try*,\n \t\t\t\t      const char*, bool, locus*);\n gfc_symtree* gfc_find_typebound_user_op (gfc_symbol*, gfc_try*,"}, {"sha": "9bf767dbaf6f9fc460de62f7bc4cbbf26555cfe0", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -854,7 +854,7 @@ gfc_resolve_extends_type_of (gfc_expr *f, gfc_expr *a, gfc_expr *mo)\n     gfc_add_component_ref (a, \"$vptr\");\n   else if (a->ts.type == BT_DERIVED)\n     {\n-      vtab = gfc_find_derived_vtab (a->ts.u.derived, false);\n+      vtab = gfc_find_derived_vtab (a->ts.u.derived);\n       /* Clear the old expr.  */\n       gfc_free_ref_list (a->ref);\n       memset (a, '\\0', sizeof (gfc_expr));\n@@ -870,7 +870,7 @@ gfc_resolve_extends_type_of (gfc_expr *f, gfc_expr *a, gfc_expr *mo)\n     gfc_add_component_ref (mo, \"$vptr\");\n   else if (mo->ts.type == BT_DERIVED)\n     {\n-      vtab = gfc_find_derived_vtab (mo->ts.u.derived, false);\n+      vtab = gfc_find_derived_vtab (mo->ts.u.derived);\n       /* Clear the old expr.  */\n       gfc_free_ref_list (mo->ref);\n       memset (mo, '\\0', sizeof (gfc_expr));"}, {"sha": "640a4d89fe188fb432547b52d2adc4c0d3cc3356", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -5477,7 +5477,6 @@ resolve_typebound_function (gfc_expr* e)\n   gfc_ref *class_ref;\n   gfc_symtree *st;\n   const char *name;\n-  const char *genname;\n   gfc_typespec ts;\n \n   st = e->symtree;\n@@ -5501,11 +5500,6 @@ resolve_typebound_function (gfc_expr* e)\n   c = gfc_find_component (declared, \"$data\", true, true);\n   declared = c->ts.u.derived;\n \n-  /* Keep the generic name so that the vtab reference can be made.  */\n-  genname = NULL; \n-  if (e->value.compcall.tbp->is_generic)\n-    genname = e->value.compcall.name;\n-\n   /* Treat the call as if it is a typebound procedure, in order to roll\n      out the correct name for the specific function.  */\n   if (resolve_compcall (e, &name) == FAILURE)\n@@ -5521,15 +5515,6 @@ resolve_typebound_function (gfc_expr* e)\n \n   /* '$vptr' points to the vtab, which contains the procedure pointers.  */\n   gfc_add_component_ref (e, \"$vptr\");\n-  if (genname)\n-    {\n-      /* A generic procedure needs the subsidiary vtabs and vtypes for\n-\t the specific procedures to have been build.  */\n-      gfc_symbol *vtab;\n-      vtab = gfc_find_derived_vtab (declared, true);\n-      gcc_assert (vtab);\n-      gfc_add_component_ref (e, genname);\n-    }\n   gfc_add_component_ref (e, name);\n \n   /* Recover the typespec for the expression.  This is really only\n@@ -5552,7 +5537,6 @@ resolve_typebound_subroutine (gfc_code *code)\n   gfc_ref *new_ref;\n   gfc_ref *class_ref;\n   gfc_symtree *st;\n-  const char *genname;\n   const char *name;\n   gfc_typespec ts;\n \n@@ -5577,11 +5561,6 @@ resolve_typebound_subroutine (gfc_code *code)\n   c = gfc_find_component (declared, \"$data\", true, true);\n   declared = c->ts.u.derived;\n \n-  /* Keep the generic name so that the vtab reference can be made.  */\n-  genname = NULL; \n-  if (code->expr1->value.compcall.tbp->is_generic)\n-    genname = code->expr1->value.compcall.name;\n-\n   if (resolve_typebound_call (code, &name) == FAILURE)\n     return FAILURE;\n   ts = code->expr1->ts;\n@@ -5595,15 +5574,6 @@ resolve_typebound_subroutine (gfc_code *code)\n \n   /* '$vptr' points to the vtab, which contains the procedure pointers.  */\n   gfc_add_component_ref (code->expr1, \"$vptr\");\n-  if (genname)\n-    {\n-      /* A generic procedure needs the subsidiary vtabs and vtypes for\n-\t the specific procedures to have been build.  */\n-      gfc_symbol *vtab;\n-      vtab = gfc_find_derived_vtab (declared, true);\n-      gcc_assert (vtab);\n-      gfc_add_component_ref (code->expr1, genname);\n-    }\n   gfc_add_component_ref (code->expr1, name);\n \n   /* Recover the typespec for the expression.  This is really only\n@@ -7505,7 +7475,7 @@ resolve_select_type (gfc_code *code)\n \t  new_st->expr1->value.function.actual = gfc_get_actual_arglist ();\n \t  new_st->expr1->value.function.actual->expr = gfc_get_variable_expr (code->expr1->symtree);\n \t  gfc_add_component_ref (new_st->expr1->value.function.actual->expr, \"$vptr\");\n-\t  vtab = gfc_find_derived_vtab (body->ext.case_list->ts.u.derived, true);\n+\t  vtab = gfc_find_derived_vtab (body->ext.case_list->ts.u.derived);\n \t  st = gfc_find_symtree (vtab->ns->sym_root, vtab->name);\n \t  new_st->expr1->value.function.actual->next = gfc_get_actual_arglist ();\n \t  new_st->expr1->value.function.actual->next->expr = gfc_get_variable_expr (st);\n@@ -10777,7 +10747,7 @@ resolve_fl_derived (gfc_symbol *sym)\n       gfc_component *vptr = gfc_find_component (sym, \"$vptr\", true, true);\n       if (vptr->ts.u.derived == NULL)\n \t{\n-\t  gfc_symbol *vtab = gfc_find_derived_vtab (data->ts.u.derived, false);\n+\t  gfc_symbol *vtab = gfc_find_derived_vtab (data->ts.u.derived);\n \t  gcc_assert (vtab);\n \t  vptr->ts.u.derived = vtab->ts.u.derived;\n \t}"}, {"sha": "5fee6e23cfc8b36b129d64e1c112e59b56f5318b", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -1077,7 +1077,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n     {\n       gfc_component *c = CLASS_DATA (sym);\n       if (!c->ts.u.derived->backend_decl)\n-\tgfc_find_derived_vtab (c->ts.u.derived, true);\n+\tgfc_find_derived_vtab (c->ts.u.derived);\n     }\n \n   if ((sym->attr.dummy && ! sym->attr.function) || (sym->attr.result && byref))"}, {"sha": "ff250fdbfee463d69d6edba2ad96f02590f71ce2", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -2478,8 +2478,8 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \t\t       var, cmp->backend_decl, NULL_TREE);\n \n   /* Remember the vtab corresponds to the derived type\n-    not to the class declared type.  */\n-  vtab = gfc_find_derived_vtab (e->ts.u.derived, true);\n+     not to the class declared type.  */\n+  vtab = gfc_find_derived_vtab (e->ts.u.derived);\n   gcc_assert (vtab);\n   gfc_trans_assign_vtab_procs (&parmse->pre, e->ts.u.derived, vtab);\n   tmp = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtab));\n@@ -5641,7 +5641,7 @@ gfc_trans_class_assign (gfc_code *code)\n \t{\n \t  gfc_symbol *vtab;\n \t  gfc_symtree *st;\n-\t  vtab = gfc_find_derived_vtab (code->expr2->ts.u.derived, true);\n+\t  vtab = gfc_find_derived_vtab (code->expr2->ts.u.derived);\n \t  gcc_assert (vtab);\n \t  gfc_trans_assign_vtab_procs (&block, code->expr2->ts.u.derived, vtab);\n \t  rhs = gfc_get_expr ();"}, {"sha": "8bd0f91517f1300b6513388223b680721961404f", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -4295,7 +4295,7 @@ gfc_trans_allocate (gfc_code * code)\n \n \t      if (ts->type == BT_DERIVED)\n \t\t{\n-\t\t  vtab = gfc_find_derived_vtab (ts->u.derived, true);\n+\t\t  vtab = gfc_find_derived_vtab (ts->u.derived);\n \t\t  gcc_assert (vtab);\n \t\t  gfc_trans_assign_vtab_procs (&block, ts->u.derived, vtab);\n \t\t  gfc_init_se (&lse, NULL);"}, {"sha": "9f4bd1e14773f03808e783c9ab44bfffbf969fe1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -1,3 +1,17 @@\n+2010-07-13  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/44434\n+\tPR fortran/44565\n+\tPR fortran/43945\n+\tPR fortran/44869\n+\t* gfortran.dg/dynamic_dispatch_1.f03: Fixed invalid test case.\n+\t* gfortran.dg/dynamic_dispatch_2.f03: Ditto.\n+\t* gfortran.dg/dynamic_dispatch_3.f03: Ditto.\n+\t* gfortran.dh/typebound_call_16.f03: New.\n+\t* gfortran.dg/typebound_generic_6.f03: New.\n+\t* gfortran.dg/typebound_generic_7.f03: New.\n+\t* gfortran.dg/typebound_generic_8.f03: New.\n+\n 2010-07-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/37077"}, {"sha": "2182dce3e4f7ec66a0ed2d485161df4b91bd244c", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_1.f03", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_1.f03?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -12,16 +12,14 @@ module m\n     procedure, pass :: make_integer\n     procedure, pass :: prod => i_m_j\n     generic, public :: extract => real, make_integer\n-    generic, public :: base_extract => real, make_integer\n   end type t1\n \n   type, extends(t1) :: t2\n     integer :: j = 99\n   contains\n     procedure, pass :: real => make_real2\n-    procedure, pass :: make_integer_2\n+    procedure, pass :: make_integer => make_integer_2\n     procedure, pass :: prod => i_m_j_2\n-    generic, public :: extract => real, make_integer_2\n   end type t2\n contains\n   real function make_real (arg)\n@@ -69,16 +67,13 @@ end module m\n   if (a%real() .ne. real (42)) call abort\n   if (a%prod() .ne. 42) call abort\n   if (a%extract (2) .ne. 84) call abort\n-  if (a%base_extract (2) .ne. 84) call abort\n   a => c                                   ! extension in module\n   if (a%real() .ne. real (99)) call abort\n   if (a%prod() .ne. 99) call abort\n   if (a%extract (3) .ne. 297) call abort\n-  if (a%base_extract (3) .ne. 126) call abort\n   a => d                                   ! extension in main\n   if (a%real() .ne. real (42)) call abort\n   if (a%prod() .ne. 42) call abort\n   if (a%extract (4) .ne. 168) call abort\n-  if (a%base_extract (4) .ne. 168) call abort\n end\n ! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "95ce8372325c2526d04ec614ee885e2fcc5fbcbe", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_2.f03", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_2.f03?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -12,16 +12,14 @@ module m\n     procedure, pass :: make_integer\n     procedure, pass :: prod => i_m_j\n     generic, public :: extract => real, make_integer\n-    generic, public :: base_extract => real, make_integer\n   end type t1\n \n   type, extends(t1) :: t2\n     integer :: j = 99\n   contains\n     procedure, pass :: real => make_real2\n-    procedure, pass :: make_integer_2\n+    procedure, pass :: make_integer => make_integer_2\n     procedure, pass :: prod => i_m_j_2\n-    generic, public :: extract => real, make_integer_2\n   end type t2\n contains\n   subroutine make_real (arg, arg2)\n@@ -79,8 +77,6 @@ end module m\n   if (i .ne. 42) call abort\n   call a%extract (2, i)\n   if (i .ne. 84) call abort\n-  call a%base_extract (2, i)\n-  if (i .ne. 84) call abort\n \n   a => c                                   ! extension in module\n   call a%real(r)\n@@ -89,8 +85,6 @@ end module m\n   if (i .ne. 99) call abort\n   call a%extract (3, i)\n   if (i .ne. 297) call abort\n-  call a%base_extract (3, i)\n-  if (i .ne. 126) call abort\n \n   a => d                                   ! extension in main\n   call a%real(r)\n@@ -99,7 +93,5 @@ end module m\n   if (i .ne. 42) call abort\n   call a%extract (4, i)\n   if (i .ne. 168) call abort\n-  call a%extract (4, i)\n-  if (i .ne. 168) call abort\n end\n ! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "884d3426039dd15b7f493ab409ae779de87d645c", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_3.f03", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_3.f03?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -15,7 +15,6 @@ module m1\n     procedure, pass :: make_integer\n     procedure, pass :: prod => i_m_j\n     generic, public :: extract => real, make_integer\n-    generic, public :: base_extract => real, make_integer\n   end type t1\n contains\n   real function make_real (arg)\n@@ -41,9 +40,8 @@ module m2\n     integer :: j = 99\n   contains\n     procedure, pass :: real => make_real2\n-    procedure, pass :: make_integer_2\n+    procedure, pass :: make_integer => make_integer_2\n     procedure, pass :: prod => i_m_j_2\n-    generic, public :: extract => real, make_integer_2\n   end type t2\n contains\n   real function make_real2 (arg)\n@@ -76,16 +74,13 @@ end module m2\n   if (a%real() .ne. real (42)) call abort\n   if (a%prod() .ne. 42) call abort\n   if (a%extract (2) .ne. 84) call abort\n-  if (a%base_extract (2) .ne. 84) call abort\n   a => c                                   ! extension in module m2\n   if (a%real() .ne. real (99)) call abort\n   if (a%prod() .ne. 99) call abort\n   if (a%extract (3) .ne. 297) call abort\n-  if (a%base_extract (3) .ne. 126) call abort\n   a => d                                   ! extension in main\n   if (a%real() .ne. real (42)) call abort\n   if (a%prod() .ne. 42) call abort\n   if (a%extract (4) .ne. 168) call abort\n-  if (a%base_extract (4) .ne. 168) call abort\n end\n ! { dg-final { cleanup-modules \"m1, m2\" } }"}, {"sha": "fdd60c603cce7e5b80b7107c3b4362b87e2662c8", "filename": "gcc/testsuite/gfortran.dg/typebound_call_16.f03", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_16.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_16.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_16.f03?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+!\n+! PR 41685: [OOP] internal compiler error: verify_flow_info failed\n+!\n+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+\n+module base_mat_mod\n+\n+  type  :: base_sparse_mat\n+  contains \n+    procedure, pass(a) :: get_nrows\n+  end type base_sparse_mat\n+  \n+contains\n+\n+  integer function get_nrows(a)\n+    implicit none \n+    class(base_sparse_mat), intent(in) :: a\n+  end function get_nrows\n+\n+end module  base_mat_mod\n+\n+\n+  use base_mat_mod\n+\n+  type, extends(base_sparse_mat) :: s_coo_sparse_mat\n+  end type s_coo_sparse_mat\n+\n+  class(s_coo_sparse_mat), pointer :: a\n+  Integer :: m\n+  m = a%get_nrows()\n+\n+end\n+\n+! { dg-final { cleanup-modules \"base_mat_mod\" } }"}, {"sha": "973e10a35e394e4acd0de534fe02667628927965", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_6.f03", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_6.f03?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do run }\n+!\n+! PR 43945: [OOP] Derived type with GENERIC: resolved to the wrong specific TBP\n+!\n+! Contributed by by Salvatore Filippone <sfilippone@uniroma2.it>\n+\n+module foo_mod\n+  type foo\n+    integer :: i\n+  contains\n+    procedure, pass(a) :: doit\n+    procedure, pass(a) :: getit\n+    generic, public :: do  => doit\n+    generic, public :: get => getit\n+  end type foo\n+  private doit,getit\n+contains\n+  subroutine  doit(a)\n+    class(foo) :: a\n+    a%i = 1\n+    write(*,*) 'FOO%DOIT base version'\n+  end subroutine doit\n+  function getit(a) result(res)\n+    class(foo) :: a\n+    integer :: res\n+    res = a%i\n+  end function getit\n+end module foo_mod\n+\n+module foo2_mod\n+  use foo_mod\n+  type, extends(foo) :: foo2\n+    integer :: j\n+  contains\n+    procedure, pass(a) :: doit  => doit2\n+    procedure, pass(a) :: getit => getit2\n+  end type foo2\n+  private doit2, getit2\n+\n+contains\n+\n+  subroutine  doit2(a)\n+    class(foo2) :: a\n+    a%i = 2\n+    a%j = 3\n+  end subroutine doit2\n+  function getit2(a) result(res)\n+    class(foo2) :: a\n+    integer :: res\n+    res = a%j\n+  end function getit2\n+end module foo2_mod\n+\n+program testd15\n+  use foo2_mod\n+  type(foo2) :: af2\n+  class(foo), allocatable :: afab \n+\n+  allocate(foo2 :: afab)\n+  call af2%do()\n+  if (af2%i .ne. 2) call abort\n+  if (af2%get() .ne. 3) call abort\n+  call afab%do()\n+  if (afab%i .ne. 2) call abort\n+  if (afab%get() .ne. 3) call abort\n+\n+end program testd15\n+\n+! { dg-final { cleanup-modules \"foo_mod foo2_mod\" } }"}, {"sha": "2519ab09416bce548c142ca3f6e7b22be0c8c403", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_7.f03", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_7.f03?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+!\n+! PR 44434: [OOP] ICE in in gfc_add_component_ref\n+!\n+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+\n+module foo_mod\n+  type foo\n+  contains\n+    procedure :: doit\n+    generic :: do => doit\n+  end type\n+contains\n+  subroutine  doit(a) \n+    class(foo) :: a\n+  end subroutine\n+end module\n+\n+program testd15\n+contains\n+  subroutine dodo(x)\n+    use foo_mod\n+    class(foo) :: x\n+    call x%do()\n+  end subroutine\n+end \n+\n+! { dg-final { cleanup-modules \"foo_mod\" } }"}, {"sha": "0ee6610e1733ef6d1e0ae88526a1ddd2e6c01121", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_8.f03", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ce80316fbb4d001f08eb4c65dbb7ae88e0474f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_8.f03?ref=88ce80316fbb4d001f08eb4c65dbb7ae88e0474f", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+!\n+! PR 44565: [4.6 Regression] [OOP] ICE in gimplify_expr with array-valued generic TBP\n+!\n+! Contributed by Hans-Werner Boschmann <boschmann@tp1.physik.uni-siegen.de>\n+\n+module ice6\n+\n+  type :: t\n+   contains\n+     procedure :: get_array\n+     generic :: get_something => get_array\n+  end type\n+\n+contains\n+\n+  function get_array(this)\n+    class(t) :: this\n+    real,dimension(2) :: get_array\n+  end function get_array\n+\n+  subroutine do_something(this)\n+    class(t) :: this\n+    print *,this%get_something()\n+  end subroutine do_something\n+\n+end module ice6 \n+\n+! { dg-final { cleanup-modules \"ice6\" } }"}]}