{"sha": "b66377c173ecd444f4fb4f9737ee10a97084ad9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY2Mzc3YzE3M2VjZDQ0NGY0ZmI0Zjk3MzdlZTEwYTk3MDg0YWQ5YQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-06-13T21:16:00Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-13T21:16:00Z"}, "message": "cpphash.h (_cpp_lex_identifier_trad): Remove.\n\n\t* cpphash.h (_cpp_lex_identifier_trad): Remove.\n\t* cpplib.c (end_directive): Don't skip, always remove overlay\n\tapart from #define.\n\t(prepare_directive_trad): Handle NULL pfile->directive.\n\t(_cpp_handle_directive): Always call prepare_directive_trad\n\tif traditional.\n\t* cppmain.c (check_multiline_token): Rename account_for_newlines,\n\tgeneralize inputs.\n\t(scan_translation_unit_trad): Use it.\n\t* cpptrad.c (skip_comment): Rename copy_comment, copy comment to\n\toutput, get escaped newline in comment close correct.\n\t(check_output_buffer, skip_whitespace): Update.\n\t(_cpp_lex_identifier_trad): Remove.\n\t(scan_out_logical_line): Handle -C and comments in directives\n\tproperly.\n\nFrom-SVN: r54599", "tree": {"sha": "84d2f1068a69ffbe2208c366f6d8d1f3c43b05d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84d2f1068a69ffbe2208c366f6d8d1f3c43b05d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b66377c173ecd444f4fb4f9737ee10a97084ad9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66377c173ecd444f4fb4f9737ee10a97084ad9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b66377c173ecd444f4fb4f9737ee10a97084ad9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66377c173ecd444f4fb4f9737ee10a97084ad9a/comments", "author": null, "committer": null, "parents": [{"sha": "8bc6e1018593f8525674f79fac6a80d23cb25efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bc6e1018593f8525674f79fac6a80d23cb25efb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bc6e1018593f8525674f79fac6a80d23cb25efb"}], "stats": {"total": 171, "additions": 105, "deletions": 66}, "files": [{"sha": "d5270c8fbf7668186068e3dc18ccae0894066dec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66377c173ecd444f4fb4f9737ee10a97084ad9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66377c173ecd444f4fb4f9737ee10a97084ad9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b66377c173ecd444f4fb4f9737ee10a97084ad9a", "patch": "@@ -1,3 +1,21 @@\n+2002-06-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (_cpp_lex_identifier_trad): Remove.\n+\t* cpplib.c (end_directive): Don't skip, always remove overlay\n+\tapart from #define.\n+\t(prepare_directive_trad): Handle NULL pfile->directive.\n+\t(_cpp_handle_directive): Always call prepare_directive_trad\n+\tif traditional.\n+\t* cppmain.c (check_multiline_token): Rename account_for_newlines,\n+\tgeneralize inputs.\n+\t(scan_translation_unit_trad): Use it.\n+\t* cpptrad.c (skip_comment): Rename copy_comment, copy comment to\n+\toutput, get escaped newline in comment close correct.\n+\t(check_output_buffer, skip_whitespace): Update.\n+\t(_cpp_lex_identifier_trad): Remove.\n+\t(scan_out_logical_line): Handle -C and comments in directives\n+\tproperly.\n+\n Thu Jun 13 20:18:38 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* config.gcc: Add support for sh[234]*-*-elf*, sh[2346lbe]*-*-linux*."}, {"sha": "24b5ef7fcccbc797f7df695e27b7e96752c2068f", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66377c173ecd444f4fb4f9737ee10a97084ad9a/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66377c173ecd444f4fb4f9737ee10a97084ad9a/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=b66377c173ecd444f4fb4f9737ee10a97084ad9a", "patch": "@@ -522,7 +522,6 @@ extern bool _cpp_read_logical_line_trad PARAMS ((cpp_reader *));\n extern void _cpp_overlay_buffer PARAMS ((cpp_reader *pfile, const uchar *,\n \t\t\t\t\t size_t));\n extern void _cpp_remove_overlay PARAMS ((cpp_reader *));\n-extern cpp_hashnode *_cpp_lex_identifier_trad PARAMS ((cpp_reader *));\n extern void _cpp_set_trad_context PARAMS ((cpp_reader *));\n extern bool _cpp_create_trad_definition PARAMS ((cpp_reader *, cpp_macro *));\n extern bool _cpp_expansions_different_trad PARAMS ((const cpp_macro *,"}, {"sha": "aecfbaf0edd8862edec5f5991b791d3f2d572ecd", "filename": "gcc/cpplib.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66377c173ecd444f4fb4f9737ee10a97084ad9a/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66377c173ecd444f4fb4f9737ee10a97084ad9a/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=b66377c173ecd444f4fb4f9737ee10a97084ad9a", "patch": "@@ -256,14 +256,11 @@ end_directive (pfile, skip_line)\n {\n   if (CPP_OPTION (pfile, traditional))\n     {\n-      if (!pfile->directive || pfile->directive == &dtable[T_DEFINE])\n-\tskip_line = false;\n-      else\n+      if (pfile->directive != &dtable[T_DEFINE])\n \t_cpp_remove_overlay (pfile);\n     }\n-\n   /* We don't skip for an assembler #.  */\n-  if (skip_line)\n+  else if (skip_line)\n     {\n       skip_rest_of_line (pfile);\n       if (!pfile->keep_tokens)\n@@ -289,7 +286,8 @@ prepare_directive_trad (pfile)\n     CUR (pfile->context) = pfile->buffer->cur;\n   else\n     {\n-      bool no_expand = ! (pfile->directive->flags & EXPAND);\n+      bool no_expand = (pfile->directive\n+\t\t\t&& ! (pfile->directive->flags & EXPAND));\n       bool was_skipping = pfile->state.skipping;\n \n       pfile->state.skipping = false;\n@@ -382,6 +380,10 @@ _cpp_handle_directive (pfile, indented)\n \t\t   \"style of line directive is a GCC extension\");\n     }\n \n+  pfile->directive = dir;\n+  if (CPP_OPTION (pfile, traditional))\n+    prepare_directive_trad (pfile);\n+\n   if (dir)\n     {\n       /* If we have a directive that is not an opening conditional,\n@@ -441,9 +443,6 @@ _cpp_handle_directive (pfile, indented)\n \tpfile->state.save_comments =\n \t  ! CPP_OPTION (pfile, discard_comments_in_macro_exp);\n \n-      pfile->directive = dir;\n-      if (CPP_OPTION (pfile, traditional))\n-\tprepare_directive_trad (pfile);\n       (*pfile->directive->handler) (pfile);\n     }\n   else if (skip == 0)"}, {"sha": "7ebc1ad2c5aea82b9fd8dfac9185f668cd90a7fb", "filename": "gcc/cppmain.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66377c173ecd444f4fb4f9737ee10a97084ad9a/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66377c173ecd444f4fb4f9737ee10a97084ad9a/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=b66377c173ecd444f4fb4f9737ee10a97084ad9a", "patch": "@@ -43,7 +43,7 @@ static void setup_callbacks PARAMS ((cpp_reader *));\n /* General output routines.  */\n static void scan_translation_unit PARAMS ((cpp_reader *));\n static void scan_translation_unit_trad PARAMS ((cpp_reader *));\n-static void check_multiline_token PARAMS ((const cpp_string *));\n+static void account_for_newlines PARAMS ((const uchar *, size_t));\n static int dump_macro PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n \n static void print_line PARAMS ((const struct line_map *, unsigned int,\n@@ -208,19 +208,18 @@ scan_translation_unit (pfile)\n       cpp_output_token (token, print.outf);\n \n       if (token->type == CPP_COMMENT)\n-\tcheck_multiline_token (&token->val.str);\n+\taccount_for_newlines (token->val.str.text, token->val.str.len);\n     }\n }\n \n-/* Adjust print.line for newlines embedded in tokens.  */\n+/* Adjust print.line for newlines embedded in output.  */\n static void\n-check_multiline_token (str)\n-     const cpp_string *str;\n+account_for_newlines (str, len)\n+     const uchar *str;\n+     size_t len;\n {\n-  unsigned int i;\n-\n-  for (i = 0; i < str->len; i++)\n-    if (str->text[i] == '\\n')\n+  while (len--)\n+    if (*str++ == '\\n')\n       print.line++;\n }\n \n@@ -239,6 +238,8 @@ scan_translation_unit_trad (pfile)\n       maybe_print_line (print.map, pfile->out.first_line);\n       fwrite (pfile->out.base, 1, len, print.outf);\n       print.printed = 1;\n+      if (!CPP_OPTION (pfile, discard_comments))\n+\taccount_for_newlines (pfile->out.base, len);\n     }\n }\n "}, {"sha": "4765be2273afc51f18a22c349da90cd459e4bb8a", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 69, "deletions": 47, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66377c173ecd444f4fb4f9737ee10a97084ad9a/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66377c173ecd444f4fb4f9737ee10a97084ad9a/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=b66377c173ecd444f4fb4f9737ee10a97084ad9a", "patch": "@@ -22,17 +22,13 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpphash.h\"\n \n /* The replacement text of a function-like macro is stored as a\n-   contiguous sequence of aligned blocks.  Each block represents the\n-   portion of text from the start of the previous block (or the start\n-   of the macro replacement text in the case of the first block) to\n-   the next parameter, or the end of the replacement list if there\n-   are none left.\n-\n-   Each block consists of an unsigned int, which is the length of text\n-   contained in the third part, an unsigned short, which is the\n+   contiguous sequence of aligned blocks, each representing the text\n+   between subsequent parameters in that text.\n+\n+   Each block comprises the length of text contained therein, the\n    one-based index of the argument that immediately follows that text,\n    and the text itself.  The final block in the macro expansion is\n-   recognizable as it has an argument index of zero.  */\n+   easily recognizable as it has an argument index of zero.  */\n \n struct block\n {\n@@ -67,17 +63,16 @@ struct fun_macro\n   unsigned int argc;\n };\n \n-/* Lexing TODO: Handle -C, maybe -CC, and space in escaped newlines.\n-   Stop cpplex.c from recognizing comments and directives during its\n-   lexing pass.  Get rid of line_base usage - seems pointless?  Do we\n-   get escaped newline at EOF correct?  */\n+/* Lexing TODO: Maybe handle -CC and space in escaped newlines.  Stop\n+   cpplex.c from recognizing comments and directives during its lexing\n+   pass.  Get rid of line_base usage - seems pointless?  */\n \n static const uchar *handle_newline PARAMS ((cpp_reader *, const uchar *));\n static const uchar *skip_escaped_newlines PARAMS ((cpp_reader *,\n \t\t\t\t\t\t   const uchar *));\n static const uchar *skip_whitespace PARAMS ((cpp_reader *, const uchar *));\n static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *, const uchar *));\n-static const uchar *skip_comment PARAMS ((cpp_reader *, const uchar *));\n+static const uchar *copy_comment PARAMS ((cpp_reader *, const uchar *));\n static void scan_out_logical_line PARAMS ((cpp_reader *pfile, cpp_macro *));\n static void check_output_buffer PARAMS ((cpp_reader *, size_t));\n static void push_replacement_text PARAMS ((cpp_reader *, cpp_hashnode *));\n@@ -99,6 +94,10 @@ check_output_buffer (pfile, n)\n      cpp_reader *pfile;\n      size_t n;\n {\n+  /* We might need two bytes to terminate an unterminated comment, and\n+     one more to terminate with a NUL.  */\n+  n += 2 + 1;\n+\n   if (n > (size_t) (pfile->out.limit - pfile->out.cur))\n     {\n       size_t size = pfile->out.cur - pfile->out.base;\n@@ -134,45 +133,70 @@ skip_escaped_newlines (pfile, cur)\n      cpp_reader *pfile;\n      const uchar *cur;\n {\n-  while (*cur == '\\\\' && is_vspace (cur[1]))\n-    cur = handle_newline (pfile, cur + 1);\n+  if (*cur == '\\\\' && is_vspace (cur[1]))\n+    {\n+      do\n+\tcur = handle_newline (pfile, cur + 1);\n+      while (*cur == '\\\\' && is_vspace (cur[1]));\n+\n+      if (cur == RLIMIT (pfile->context))\n+\tcpp_error (pfile, DL_PEDWARN,\n+\t\t   \"backslash-newline at end of file\");\n+    }\n \n   return cur;\n }\n \n /* CUR points to the character after the asterisk introducing a\n-   comment.  Returns the position after the comment.  */\n+   comment in the input buffer.  The remaining comment is copied to\n+   the buffer pointed to by pfile->out.cur, which must be of\n+   sufficient size, and pfile->out.cur is updated.  Unterminated\n+   comments are diagnosed, and correctly terminated in the output.\n+\n+   Returns a pointer to the first character after the comment in the\n+   input buffer.  */\n static const uchar *\n-skip_comment (pfile, cur)\n+copy_comment (pfile, cur)\n      cpp_reader *pfile;\n      const uchar *cur;\n {\n   unsigned int from_line = pfile->line;\n-  unsigned int c = 0, prevc = 0;\n   const uchar *limit = RLIMIT (pfile->context);\n+  uchar *out = pfile->out.cur;\n \n   while (cur < limit)\n     {\n-      prevc = c;\n-      c = *cur++;\n+      unsigned int c = *cur++;\n+      *out++ = c;\n \n       if (c == '/')\n \t{\n-\t  if (prevc == '*')\n-\t    break;\n+\t  /* An immediate slash does not terminate the comment.  */\n+\t  if (out[-2] == '*' && out > pfile->out.cur + 1)\n+\t    goto done;\n+\n \t  if (*cur == '*' && cur[1] != '/'\n \t      && CPP_OPTION (pfile, warn_comments))\n \t    cpp_error_with_line (pfile, DL_WARNING, pfile->line, 0,\n \t\t\t\t \"\\\"/*\\\" within comment\");\n \t}\n       else if (is_vspace (c))\n-\tcur = handle_newline (pfile, cur - 1);\n+\t{\n+\t  cur = handle_newline (pfile, cur - 1);\n+\t  /* Canonicalize newline sequences and skip escaped ones.  */\n+\t  if (out[-2] == '\\\\')\n+\t    out -= 2;\n+\t  else\n+\t    out[-1] = '\\n';\n+\t}\n     }\n \n-  if (c != '/' || prevc != '*')\n-    cpp_error_with_line (pfile, DL_ERROR, from_line, 0,\n-\t\t\t \"unterminated comment\");\n+  cpp_error_with_line (pfile, DL_ERROR, from_line, 0, \"unterminated comment\");\n+  *out++ = '*';\n+  *out++ = '/';\n \n+ done:\n+  pfile->out.cur = out;\n   return cur;\n }\n \n@@ -206,7 +230,7 @@ skip_whitespace (pfile, cur)\n \t  tmp = skip_escaped_newlines (pfile, cur + 1);\n \t  if (*tmp == '*')\n \t    {\n-\t      cur = skip_comment (pfile, tmp + 1);\n+\t      cur = copy_comment (pfile, tmp + 1);\n \t      continue;\n \t    }\n \t}\n@@ -246,23 +270,6 @@ lex_identifier (pfile, cur)\n   return result;\n }\n \n-/* Reads an identifier, returning its hashnode.  If the next token is\n-   not an identifier, returns NULL.  */\n-cpp_hashnode *\n-_cpp_lex_identifier_trad (pfile)\n-     cpp_reader *pfile;\n-{\n-  const uchar *cur = skip_whitespace (pfile, CUR (pfile->context));\n-\n-  if (!is_idstart (*cur))\n-    {\n-      CUR (pfile->context) = cur;\n-      return NULL;\n-    }\n-\n-  return lex_identifier (pfile, cur);\n-}\n-\n /* Overlays the true file buffer temporarily with text of length LEN\n    starting at START.  The true buffer is restored upon calling\n    restore_buff().  */\n@@ -381,7 +388,7 @@ scan_out_logical_line (pfile, macro)\n {\n   cpp_context *context;\n   const uchar *cur;\n-  unsigned int c, paren_depth, quote = 0;\n+  unsigned int c, paren_depth = 0, quote = 0;\n   uchar *out;\n   struct fun_macro fmacro;\n \n@@ -466,7 +473,22 @@ scan_out_logical_line (pfile, macro)\n \t    {\n \t      cur = skip_escaped_newlines (pfile, cur);\n \t      if (*cur == '*')\n-\t\tout--, cur = skip_comment (pfile, cur + 1);\n+\t\t{\n+\t\t  *out = '*';\n+\t\t  pfile->out.cur = out + 1;\n+\t\t  cur = copy_comment (pfile, cur + 1);\n+\n+\t\t  /* Comments in directives become spaces so that\n+\t\t     tokens are properly separated when the ISO\n+\t\t     preprocessor re-lexes the line.  The exception\n+\t\t     is #define.  */\n+\t\t  if (pfile->state.in_directive && !macro)\n+\t\t    out[-1] = ' ';\n+\t\t  else if (CPP_OPTION (pfile, discard_comments))\n+\t\t    out -= 1;\n+\t\t  else\n+\t\t    out = pfile->out.cur;\n+\t\t}\n \t    }\n \t  break;\n "}]}