{"sha": "64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRlYTRlMTUxYjQwZmRlMzdlYjJiMzE5MDczMWYwM2M0YTY1ZGNmMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-05-10T08:20:43Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-05-10T08:20:43Z"}, "message": "re PR tree-optimization/70497 (Missed CSE of subregs on GIMPLE)\n\n2016-05-10  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/70497\n\tPR tree-optimization/28367\n\t* tree-ssa-sccvn.c (vn_nary_build_or_lookup): New function\n\tsplit out from ...\n\t(visit_reference_op_load): ... here.\n\t(vn_reference_lookup_3): Use it to handle subreg-like accesses\n\twith simplified BIT_FIELD_REFs.\n\t* tree-ssa-pre.c (eliminate_insert): Handle inserting BIT_FIELD_REFs.\n\t* tree-complex.c (extract_component): Handle BIT_FIELD_REFs\n\tcorrectly.\n\n\t* gcc.dg/torture/20160404-1.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-fre-54.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-55.c: Likewise.\n\nFrom-SVN: r236066", "tree": {"sha": "b05b58da2c9cc46b7fbde8e9ef7b5966d8ea1a1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b05b58da2c9cc46b7fbde8e9ef7b5966d8ea1a1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a96dae3efa97317540aee2a55f717aab1efe064", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a96dae3efa97317540aee2a55f717aab1efe064", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a96dae3efa97317540aee2a55f717aab1efe064"}], "stats": {"total": 413, "additions": 282, "deletions": 131}, "files": [{"sha": "2365d851407ef0eecc0723377aad1876fb88c34c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "patch": "@@ -1,3 +1,16 @@\n+2016-05-10  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/70497\n+\tPR tree-optimization/28367\n+\t* tree-ssa-sccvn.c (vn_nary_build_or_lookup): New function\n+\tsplit out from ...\n+\t(visit_reference_op_load): ... here.\n+\t(vn_reference_lookup_3): Use it to handle subreg-like accesses\n+\twith simplified BIT_FIELD_REFs.\n+\t* tree-ssa-pre.c (eliminate_insert): Handle inserting BIT_FIELD_REFs.\n+\t* tree-complex.c (extract_component): Handle BIT_FIELD_REFs\n+\tcorrectly.\n+\n 2016-05-10  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* dwarf2out.c (add_abstract_origin_attribute): Adjust"}, {"sha": "08392c708007083b88aaac8387d83cfa9f4c388e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "patch": "@@ -1,3 +1,11 @@\n+2016-05-10  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/70497\n+\tPR tree-optimization/28367\n+\t* gcc.dg/torture/20160404-1.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-fre-54.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-55.c: Likewise.\n+\n 2016-05-10  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* gcc.dg/debug/dwarf2/nested_fun.c: New testcase."}, {"sha": "b3a85b55ad7cbad1aec5d3140eea033932414f04", "filename": "gcc/testsuite/gcc.dg/torture/20160404-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20160404-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20160404-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20160404-1.c?ref=64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+typedef __UINT64_TYPE__ UINT64;\n+typedef union {\n+    struct {\n+\tunsigned short lo4;\n+\tunsigned short lo3;\n+\tunsigned short lo2;\n+\tunsigned short lo1;\n+    } i;\n+    long double f;\n+} BID_BINARY80LDOUBLE;\n+UINT64 __binary80_to_bid32 (long double x)\n+{\n+  BID_BINARY80LDOUBLE x_in;\n+  x_in.f = x;\n+  return (x_in.i.lo4\n+\t  + ((UINT64)x_in.i.lo3 << 16)\n+\t  + ((UINT64)x_in.i.lo2 << 32)\n+\t  + ((UINT64)x_in.i.lo1 << 48));\n+}"}, {"sha": "be7537e80c1c2420a86ba8e395a18326b0fb708a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-54.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-54.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-54.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-54.c?ref=64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target int32plus } */\n+/* { dg-options \"-O -fdump-tree-fre1 -fdump-tree-dse1\" } */\n+\n+extern void abort (void);\n+\n+union U { int i; char c[4]; short s[2]; };\n+\n+char __attribute__((noinline,noclone)) foo(int i)\n+{\n+  union U u;\n+  u.i = i;\n+  /* This should be equivalent to (char) i.  */\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+  return u.c[0];\n+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+  return u.c[3];\n+#else\n+  return 0x04;\n+#endif\n+}\n+\n+short __attribute__((noinline,noclone)) baz(int i)\n+{\n+  union U u;\n+  u.i = i;\n+  /* This should be equivalent to (char) i.  */\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+  return u.s[0];\n+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+  return u.s[1];\n+#else\n+  return 0x0304;\n+#endif\n+}\n+\n+char __attribute__((noinline,noclone)) bar(int j)\n+{\n+  union U u;\n+  u.i = j;\n+  /* This gets simplified to a BIT_FIELD_REF.  */\n+  return u.c[2];\n+}\n+\n+int main()\n+{\n+  if (foo (0x01020304) != 0x04)\n+    abort ();\n+  if (baz (0x01020304) != 0x0304)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"\\\\(char\\\\) i_\" \"fre1\" } } */\n+/* { dg-final { scan-tree-dump \"\\\\(short int\\\\) i_\" \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-not \"u.i =\" \"dse1\" } } */"}, {"sha": "7bfa2847878b16ec6038ddc6816129fb94739cc3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-55.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-55.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-55.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-55.c?ref=64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+\n+int f(v4si t)\n+{\n+  union {\n+      v4si t1;\n+      int t2[4];\n+  } u;\n+  u.t1 = t;\n+  return u.t2[1];\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"u;\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 1 \"optimized\" } } */"}, {"sha": "d7baf227c7dd7878d8a9017506ae7ce41a6d28c1", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "patch": "@@ -604,6 +604,21 @@ extract_component (gimple_stmt_iterator *gsi, tree t, bool imagpart_p,\n     case COMPLEX_EXPR:\n       gcc_unreachable ();\n \n+    case BIT_FIELD_REF:\n+      {\n+\ttree inner_type = TREE_TYPE (TREE_TYPE (t));\n+\tt = unshare_expr (t);\n+\tTREE_TYPE (t) = inner_type;\n+\tTREE_OPERAND (t, 1) = TYPE_SIZE (inner_type);\n+\tif (imagpart_p)\n+\t  TREE_OPERAND (t, 2) = size_binop (PLUS_EXPR, TREE_OPERAND (t, 2),\n+\t\t\t\t\t    TYPE_SIZE (inner_type));\n+\tif (gimple_p)\n+\t  t = force_gimple_operand_gsi (gsi, t, true, NULL, true,\n+\t\t\t\t\tGSI_SAME_STMT);\n+\treturn t;\n+      }\n+\n     case VAR_DECL:\n     case RESULT_DECL:\n     case PARM_DECL:"}, {"sha": "4a771d3b0be8ec297617e140087baa1805bb84f9", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "patch": "@@ -3855,19 +3855,28 @@ eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n   gimple *stmt = gimple_seq_first_stmt (VN_INFO (val)->expr);\n   if (!is_gimple_assign (stmt)\n       || (!CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n-\t  && gimple_assign_rhs_code (stmt) != VIEW_CONVERT_EXPR))\n+\t  && gimple_assign_rhs_code (stmt) != VIEW_CONVERT_EXPR\n+\t  && gimple_assign_rhs_code (stmt) != BIT_FIELD_REF))\n     return NULL_TREE;\n \n   tree op = gimple_assign_rhs1 (stmt);\n-  if (gimple_assign_rhs_code (stmt) == VIEW_CONVERT_EXPR)\n+  if (gimple_assign_rhs_code (stmt) == VIEW_CONVERT_EXPR\n+      || gimple_assign_rhs_code (stmt) == BIT_FIELD_REF)\n     op = TREE_OPERAND (op, 0);\n   tree leader = TREE_CODE (op) == SSA_NAME ? eliminate_avail (op) : op;\n   if (!leader)\n     return NULL_TREE;\n \n   gimple_seq stmts = NULL;\n-  tree res = gimple_build (&stmts, gimple_assign_rhs_code (stmt),\n-\t\t\t   TREE_TYPE (val), leader);\n+  tree res;\n+  if (gimple_assign_rhs_code (stmt) == BIT_FIELD_REF)\n+    res = gimple_build (&stmts, BIT_FIELD_REF,\n+\t\t\tTREE_TYPE (val), leader,\n+\t\t\tTREE_OPERAND (gimple_assign_rhs1 (stmt), 1),\n+\t\t\tTREE_OPERAND (gimple_assign_rhs1 (stmt), 2));\n+  else\n+    res = gimple_build (&stmts, gimple_assign_rhs_code (stmt),\n+\t\t\tTREE_TYPE (val), leader);\n   gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n   VN_INFO_GET (res)->valnum = val;\n "}, {"sha": "63441178deaa28b84fb51771fd9ad79232bd899e", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 139, "deletions": 127, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ea4e151b40fde37eb2b3190731f03c4a65dcf3/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=64ea4e151b40fde37eb2b3190731f03c4a65dcf3", "patch": "@@ -1610,6 +1610,105 @@ vn_reference_lookup_or_insert_for_pieces (tree vuse,\n \t\t\t\t     operands.copy (), value, value_id);\n }\n \n+static vn_nary_op_t vn_nary_op_insert_stmt (gimple *stmt, tree result);\n+\n+/* Hook for maybe_push_res_to_seq, lookup the expression in the VN tables.  */\n+\n+static tree\n+vn_lookup_simplify_result (code_helper rcode, tree type, tree *ops)\n+{\n+  if (!rcode.is_tree_code ())\n+    return NULL_TREE;\n+  vn_nary_op_t vnresult = NULL;\n+  return vn_nary_op_lookup_pieces (TREE_CODE_LENGTH ((tree_code) rcode),\n+\t\t\t\t   (tree_code) rcode, type, ops, &vnresult);\n+}\n+\n+/* Return a value-number for RCODE OPS... either by looking up an existing\n+   value-number for the simplified result or by inserting the operation.  */\n+\n+static tree\n+vn_nary_build_or_lookup (code_helper rcode, tree type, tree *ops)\n+{\n+  tree result = NULL_TREE;\n+  /* We will be creating a value number for\n+       ROCDE (OPS...).\n+     So first simplify and lookup this expression to see if it\n+     is already available.  */\n+  mprts_hook = vn_lookup_simplify_result;\n+  bool res = false;\n+  switch (TREE_CODE_LENGTH ((tree_code) rcode))\n+    {\n+    case 1:\n+      res = gimple_resimplify1 (NULL, &rcode, type, ops, vn_valueize);\n+      break;\n+    case 2:\n+      res = gimple_resimplify2 (NULL, &rcode, type, ops, vn_valueize);\n+      break;\n+    case 3:\n+      res = gimple_resimplify3 (NULL, &rcode, type, ops, vn_valueize);\n+      break;\n+    }\n+  mprts_hook = NULL;\n+  gimple *new_stmt = NULL;\n+  if (res\n+      && gimple_simplified_result_is_gimple_val (rcode, ops))\n+    /* The expression is already available.  */\n+    result = ops[0];\n+  else\n+    {\n+      tree val = vn_lookup_simplify_result (rcode, type, ops);\n+      if (!val)\n+\t{\n+\t  gimple_seq stmts = NULL;\n+\t  result = maybe_push_res_to_seq (rcode, type, ops, &stmts);\n+\t  if (result)\n+\t    {\n+\t      gcc_assert (gimple_seq_singleton_p (stmts));\n+\t      new_stmt = gimple_seq_first_stmt (stmts);\n+\t    }\n+\t}\n+      else\n+\t/* The expression is already available.  */\n+\tresult = val;\n+    }\n+  if (new_stmt)\n+    {\n+      /* The expression is not yet available, value-number lhs to\n+\t the new SSA_NAME we created.  */\n+      /* Initialize value-number information properly.  */\n+      VN_INFO_GET (result)->valnum = result;\n+      VN_INFO (result)->value_id = get_next_value_id ();\n+      gimple_seq_add_stmt_without_update (&VN_INFO (result)->expr,\n+\t\t\t\t\t  new_stmt);\n+      VN_INFO (result)->needs_insertion = true;\n+      /* As all \"inserted\" statements are singleton SCCs, insert\n+\t to the valid table.  This is strictly needed to\n+\t avoid re-generating new value SSA_NAMEs for the same\n+\t expression during SCC iteration over and over (the\n+\t optimistic table gets cleared after each iteration).\n+\t We do not need to insert into the optimistic table, as\n+\t lookups there will fall back to the valid table.  */\n+      if (current_info == optimistic_info)\n+\t{\n+\t  current_info = valid_info;\n+\t  vn_nary_op_insert_stmt (new_stmt, result);\n+\t  current_info = optimistic_info;\n+\t}\n+      else\n+\tvn_nary_op_insert_stmt (new_stmt, result);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Inserting name \");\n+\t  print_generic_expr (dump_file, result, 0);\n+\t  fprintf (dump_file, \" for expression \");\n+\t  print_gimple_expr (dump_file, new_stmt, 0, TDF_SLIM);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+  return result;\n+}\n+\n /* Callback for walk_non_aliased_vuses.  Tries to perform a lookup\n    from the statement defining VUSE and if not successful tries to\n    translate *REFP and VR_ through an aggregate copy at the definition\n@@ -1772,15 +1871,16 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \n   /* 3) Assignment from a constant.  We can use folds native encode/interpret\n      routines to extract the assigned bits.  */\n-  else if (vn_walk_kind == VN_WALKREWRITE\n-\t   && CHAR_BIT == 8 && BITS_PER_UNIT == 8\n-\t   && ref->size == maxsize\n-\t   && maxsize % BITS_PER_UNIT == 0\n-\t   && offset % BITS_PER_UNIT == 0\n+  else if (ref->size == maxsize\n \t   && is_gimple_reg_type (vr->type)\n \t   && !contains_storage_order_barrier_p (vr->operands)\n \t   && gimple_assign_single_p (def_stmt)\n-\t   && is_gimple_min_invariant (gimple_assign_rhs1 (def_stmt)))\n+\t   && CHAR_BIT == 8 && BITS_PER_UNIT == 8\n+\t   && maxsize % BITS_PER_UNIT == 0\n+\t   && offset % BITS_PER_UNIT == 0\n+\t   && (is_gimple_min_invariant (gimple_assign_rhs1 (def_stmt))\n+\t       || (TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME\n+\t\t   && is_gimple_min_invariant (SSA_VAL (gimple_assign_rhs1 (def_stmt))))))\n     {\n       tree base2;\n       HOST_WIDE_INT offset2, size2, maxsize2;\n@@ -1800,6 +1900,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t  unsigned char buffer[64];\n \t  int len;\n \n+\t  tree rhs = gimple_assign_rhs1 (def_stmt);\n+\t  if (TREE_CODE (rhs) == SSA_NAME)\n+\t    rhs = SSA_VAL (rhs);\n \t  len = native_encode_expr (gimple_assign_rhs1 (def_stmt),\n \t\t\t\t    buffer, sizeof (buffer));\n \t  if (len > 0)\n@@ -1824,56 +1927,37 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t   && gimple_assign_single_p (def_stmt)\n \t   && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)\n     {\n-      tree rhs1 = gimple_assign_rhs1 (def_stmt);\n-      gimple *def_stmt2 = SSA_NAME_DEF_STMT (rhs1);\n-      if (is_gimple_assign (def_stmt2)\n-\t  && (gimple_assign_rhs_code (def_stmt2) == COMPLEX_EXPR\n-\t      || gimple_assign_rhs_code (def_stmt2) == CONSTRUCTOR)\n-\t  && types_compatible_p (vr->type, TREE_TYPE (TREE_TYPE (rhs1))))\n+      tree base2;\n+      HOST_WIDE_INT offset2, size2, maxsize2;\n+      bool reverse;\n+      base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n+\t\t\t\t       &offset2, &size2, &maxsize2,\n+\t\t\t\t       &reverse);\n+      if (!reverse\n+\t  && maxsize2 != -1\n+\t  && maxsize2 == size2\n+\t  && operand_equal_p (base, base2, 0)\n+\t  && offset2 <= offset\n+\t  && offset2 + size2 >= offset + maxsize\n+\t  /* ???  We can't handle bitfield precision extracts without\n+\t     either using an alternate type for the BIT_FIELD_REF and\n+\t     then doing a conversion or possibly adjusting the offset\n+\t     according to endianess.  */\n+\t  && (! INTEGRAL_TYPE_P (vr->type)\n+\t      || ref->size == TYPE_PRECISION (vr->type))\n+\t  && ref->size % BITS_PER_UNIT == 0)\n \t{\n-\t  tree base2;\n-\t  HOST_WIDE_INT offset2, size2, maxsize2, off;\n-\t  bool reverse;\n-\t  base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n-\t\t\t\t\t   &offset2, &size2, &maxsize2,\n-\t\t\t\t\t   &reverse);\n-\t  off = offset - offset2;\n-\t  if (!reverse\n-\t      && maxsize2 != -1\n-\t      && maxsize2 == size2\n-\t      && operand_equal_p (base, base2, 0)\n-\t      && offset2 <= offset\n-\t      && offset2 + size2 >= offset + maxsize)\n+\t  code_helper rcode = BIT_FIELD_REF;\n+\t  tree ops[3];\n+\t  ops[0] = SSA_VAL (gimple_assign_rhs1 (def_stmt));\n+\t  ops[1] = bitsize_int (ref->size);\n+\t  ops[2] = bitsize_int (offset - offset2);\n+\t  tree val = vn_nary_build_or_lookup (rcode, vr->type, ops);\n+\t  if (val)\n \t    {\n-\t      tree val = NULL_TREE;\n-\t      HOST_WIDE_INT elsz\n-\t\t= TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (TREE_TYPE (rhs1))));\n-\t      if (gimple_assign_rhs_code (def_stmt2) == COMPLEX_EXPR)\n-\t\t{\n-\t\t  if (off == 0)\n-\t\t    val = gimple_assign_rhs1 (def_stmt2);\n-\t\t  else if (off == elsz)\n-\t\t    val = gimple_assign_rhs2 (def_stmt2);\n-\t\t}\n-\t      else if (gimple_assign_rhs_code (def_stmt2) == CONSTRUCTOR\n-\t\t       && off % elsz == 0)\n-\t\t{\n-\t\t  tree ctor = gimple_assign_rhs1 (def_stmt2);\n-\t\t  unsigned i = off / elsz;\n-\t\t  if (i < CONSTRUCTOR_NELTS (ctor))\n-\t\t    {\n-\t\t      constructor_elt *elt = CONSTRUCTOR_ELT (ctor, i);\n-\t\t      if (TREE_CODE (TREE_TYPE (rhs1)) == VECTOR_TYPE)\n-\t\t\t{\n-\t\t\t  if (TREE_CODE (TREE_TYPE (elt->value))\n-\t\t\t      != VECTOR_TYPE)\n-\t\t\t    val = elt->value;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      if (val)\n-\t\treturn vn_reference_lookup_or_insert_for_pieces\n-\t\t         (vuse, vr->set, vr->type, vr->operands, val);\n+\t      vn_reference_t res = vn_reference_lookup_or_insert_for_pieces\n+\t\t  (vuse, vr->set, vr->type, vr->operands, val);\n+\t      return res;\n \t    }\n \t}\n     }\n@@ -2611,18 +2695,6 @@ vn_nary_op_lookup_stmt (gimple *stmt, vn_nary_op_t *vnresult)\n   return vn_nary_op_lookup_1 (vno1, vnresult);\n }\n \n-/* Hook for maybe_push_res_to_seq, lookup the expression in the VN tables.  */\n-\n-static tree\n-vn_lookup_simplify_result (code_helper rcode, tree type, tree *ops)\n-{\n-  if (!rcode.is_tree_code ())\n-    return NULL_TREE;\n-  vn_nary_op_t vnresult = NULL;\n-  return vn_nary_op_lookup_pieces (TREE_CODE_LENGTH ((tree_code) rcode),\n-\t\t\t\t   (tree_code) rcode, type, ops, &vnresult);\n-}\n-\n /* Allocate a vn_nary_op_t with LENGTH operands on STACK.  */\n \n static vn_nary_op_t\n@@ -3371,69 +3443,9 @@ visit_reference_op_load (tree lhs, tree op, gimple *stmt)\n \t of VIEW_CONVERT_EXPR <TREE_TYPE (result)> (result).\n \t So first simplify and lookup this expression to see if it\n \t is already available.  */\n-      mprts_hook = vn_lookup_simplify_result;\n       code_helper rcode = VIEW_CONVERT_EXPR;\n       tree ops[3] = { result };\n-      bool res = gimple_resimplify1 (NULL, &rcode, TREE_TYPE (op), ops,\n-\t\t\t\t     vn_valueize);\n-      mprts_hook = NULL;\n-      gimple *new_stmt = NULL;\n-      if (res\n-\t  && gimple_simplified_result_is_gimple_val (rcode, ops))\n-\t/* The expression is already available.  */\n-\tresult = ops[0];\n-      else\n-\t{\n-\t  tree val = vn_lookup_simplify_result (rcode, TREE_TYPE (op), ops);\n-\t  if (!val)\n-\t    {\n-\t      gimple_seq stmts = NULL;\n-\t      result = maybe_push_res_to_seq (rcode, TREE_TYPE (op), ops,\n-\t\t\t\t\t      &stmts);\n-\t      if (result)\n-\t\t{\n-\t\t  gcc_assert (gimple_seq_singleton_p (stmts));\n-\t\t  new_stmt = gimple_seq_first_stmt (stmts);\n-\t\t}\n-\t    }\n-\t  else\n-\t    /* The expression is already available.  */\n-\t    result = val;\n-\t}\n-      if (new_stmt)\n-\t{\n-\t  /* The expression is not yet available, value-number lhs to\n-\t     the new SSA_NAME we created.  */\n-\t  /* Initialize value-number information properly.  */\n-\t  VN_INFO_GET (result)->valnum = result;\n-\t  VN_INFO (result)->value_id = get_next_value_id ();\n-\t  gimple_seq_add_stmt_without_update (&VN_INFO (result)->expr,\n-\t\t\t\t\t      new_stmt);\n-\t  VN_INFO (result)->needs_insertion = true;\n-\t  /* As all \"inserted\" statements are singleton SCCs, insert\n-\t     to the valid table.  This is strictly needed to\n-\t     avoid re-generating new value SSA_NAMEs for the same\n-\t     expression during SCC iteration over and over (the\n-\t     optimistic table gets cleared after each iteration).\n-\t     We do not need to insert into the optimistic table, as\n-\t     lookups there will fall back to the valid table.  */\n-\t  if (current_info == optimistic_info)\n-\t    {\n-\t      current_info = valid_info;\n-\t      vn_nary_op_insert_stmt (new_stmt, result);\n-\t      current_info = optimistic_info;\n-\t    }\n-\t  else\n-\t    vn_nary_op_insert_stmt (new_stmt, result);\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Inserting name \");\n-\t      print_generic_expr (dump_file, result, 0);\n-\t      fprintf (dump_file, \" for expression \");\n-\t      print_gimple_expr (dump_file, new_stmt, 0, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t}\n+      result = vn_nary_build_or_lookup (rcode, TREE_TYPE (op), ops);\n     }\n \n   if (result)"}]}