{"sha": "8d9fdb4941deac5766d3f2b6e76557ac4d8905c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ5ZmRiNDk0MWRlYWM1NzY2ZDNmMmI2ZTc2NTU3YWM0ZDg5MDVjNQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2016-01-05T20:24:02Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2016-01-05T20:24:02Z"}, "message": "re PR c/69104 (invalid atomic memory order not diagnosed)\n\n\tPR c/69104\n\t* builtins.c (get_memmodel): Use expansion point location rather than\n\tthe input location.  Call warning_at rather than warning.\n\t(expand_builtin_atomic_compare_exchange): Likewise.\n\t(expand_builtin_atomic_load): Likewise.\n\t(expand_builtin_atomic_store): Likewise.\n\t(expand_builtin_atomic_clear): Likewise.\n\n\t* gcc.dg/atomic-invalid-2.c: New.\n\nFrom-SVN: r232090", "tree": {"sha": "b620986733c4411751b0a819e3cace757494303f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b620986733c4411751b0a819e3cace757494303f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66f49f07d85b002777c45e8f3d1c529ecb65c1cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66f49f07d85b002777c45e8f3d1c529ecb65c1cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66f49f07d85b002777c45e8f3d1c529ecb65c1cf"}], "stats": {"total": 175, "additions": 159, "deletions": 16}, "files": [{"sha": "71dd7077812cb7093b5b3bf4caacf452f58eca50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d9fdb4941deac5766d3f2b6e76557ac4d8905c5", "patch": "@@ -1,3 +1,13 @@\n+2016-01-05  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/69104\n+\t* builtins.c (get_memmodel): Use expansion point location rather than\n+\tthe input location.  Call warning_at rather than warning.\n+\t(expand_builtin_atomic_compare_exchange): Likewise.\n+\t(expand_builtin_atomic_load): Likewise.\n+\t(expand_builtin_atomic_store): Likewise.\n+\t(expand_builtin_atomic_clear): Likewise.\n+\n 2016-01-05  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/68991"}, {"sha": "eec4a587943f0ff6a214dc9cf3fd92c25460a004", "filename": "gcc/builtins.c", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8d9fdb4941deac5766d3f2b6e76557ac4d8905c5", "patch": "@@ -5037,6 +5037,8 @@ get_memmodel (tree exp)\n {\n   rtx op;\n   unsigned HOST_WIDE_INT val;\n+  source_location loc\n+    = expansion_point_location_if_in_system_header (input_location);\n \n   /* If the parameter is not a constant, it's a run time value so we'll just\n      convert it to MEMMODEL_SEQ_CST to avoid annoying runtime checking.  */\n@@ -5050,16 +5052,16 @@ get_memmodel (tree exp)\n     val = targetm.memmodel_check (val);\n   else if (val & ~MEMMODEL_MASK)\n     {\n-      warning (OPT_Winvalid_memory_model,\n-\t       \"Unknown architecture specifier in memory model to builtin.\");\n+      warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t  \"unknown architecture specifier in memory model to builtin\");\n       return MEMMODEL_SEQ_CST;\n     }\n \n   /* Should never see a user explicit SYNC memodel model, so >= LAST works. */\n   if (memmodel_base (val) >= MEMMODEL_LAST)\n     {\n-      warning (OPT_Winvalid_memory_model,\n-\t       \"invalid memory model argument to builtin\");\n+      warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t  \"invalid memory model argument to builtin\");\n       return MEMMODEL_SEQ_CST;\n     }\n \n@@ -5111,23 +5113,25 @@ expand_builtin_atomic_compare_exchange (machine_mode mode, tree exp,\n   enum memmodel success, failure;\n   tree weak;\n   bool is_weak;\n+  source_location loc\n+    = expansion_point_location_if_in_system_header (input_location);\n \n   success = get_memmodel (CALL_EXPR_ARG (exp, 4));\n   failure = get_memmodel (CALL_EXPR_ARG (exp, 5));\n \n   if (failure > success)\n     {\n-      warning (OPT_Winvalid_memory_model,\n-\t       \"failure memory model cannot be stronger than success memory \"\n-\t       \"model for %<__atomic_compare_exchange%>\");\n+      warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t  \"failure memory model cannot be stronger than success \"\n+\t\t  \"memory model for %<__atomic_compare_exchange%>\");\n       success = MEMMODEL_SEQ_CST;\n     }\n  \n   if (is_mm_release (failure) || is_mm_acq_rel (failure))\n     {\n-      warning (OPT_Winvalid_memory_model,\n-\t       \"invalid failure memory model for \"\n-\t       \"%<__atomic_compare_exchange%>\");\n+      warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t  \"invalid failure memory model for \"\n+\t\t  \"%<__atomic_compare_exchange%>\");\n       failure = MEMMODEL_SEQ_CST;\n       success = MEMMODEL_SEQ_CST;\n     }\n@@ -5188,8 +5192,10 @@ expand_builtin_atomic_load (machine_mode mode, tree exp, rtx target)\n   model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n   if (is_mm_release (model) || is_mm_acq_rel (model))\n     {\n-      warning (OPT_Winvalid_memory_model,\n-\t       \"invalid memory model for %<__atomic_load%>\");\n+      source_location loc\n+\t= expansion_point_location_if_in_system_header (input_location);\n+      warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t  \"invalid memory model for %<__atomic_load%>\");\n       model = MEMMODEL_SEQ_CST;\n     }\n \n@@ -5218,8 +5224,10 @@ expand_builtin_atomic_store (machine_mode mode, tree exp)\n   if (!(is_mm_relaxed (model) || is_mm_seq_cst (model)\n \t|| is_mm_release (model)))\n     {\n-      warning (OPT_Winvalid_memory_model,\n-\t       \"invalid memory model for %<__atomic_store%>\");\n+      source_location loc\n+\t= expansion_point_location_if_in_system_header (input_location);\n+      warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t  \"invalid memory model for %<__atomic_store%>\");\n       model = MEMMODEL_SEQ_CST;\n     }\n \n@@ -5319,8 +5327,10 @@ expand_builtin_atomic_clear (tree exp)\n \n   if (is_mm_consume (model) || is_mm_acquire (model) || is_mm_acq_rel (model))\n     {\n-      warning (OPT_Winvalid_memory_model,\n-\t       \"invalid memory model for %<__atomic_store%>\");\n+      source_location loc\n+\t= expansion_point_location_if_in_system_header (input_location);\n+      warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t  \"invalid memory model for %<__atomic_store%>\");\n       model = MEMMODEL_SEQ_CST;\n     }\n "}, {"sha": "53219fea924808d9da48acbedff4c49e4f4b4d4c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d9fdb4941deac5766d3f2b6e76557ac4d8905c5", "patch": "@@ -1,3 +1,8 @@\n+2016-01-05  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/69104\n+\t* gcc.dg/atomic-invalid-2.c: New.\n+\n 2016-01-05  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/68991"}, {"sha": "6bf5c96c442f7bb460dcdc8c337e56144a9388ba", "filename": "gcc/testsuite/gcc.dg/atomic-invalid-2.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9fdb4941deac5766d3f2b6e76557ac4d8905c5/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid-2.c?ref=8d9fdb4941deac5766d3f2b6e76557ac4d8905c5", "patch": "@@ -0,0 +1,118 @@\n+/* PR c/69104.  Test atomic routines for invalid memory model errors.  This\n+   only needs to be tested on a single size.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+#include <stdatomic.h>\n+\n+/* atomic_store_explicit():\n+   The order argument shall not be memory_order_acquire,\n+   memory_order_consume, nor memory_order_acq_rel.  */\n+\n+void\n+store (atomic_int *i)\n+{\n+  atomic_store_explicit (i, 0, memory_order_consume); /* { dg-warning \"invalid memory model\" } */\n+  atomic_store_explicit (i, 0, memory_order_acquire); /* { dg-warning \"invalid memory model\" } */\n+  atomic_store_explicit (i, 0, memory_order_acq_rel); /* { dg-warning \"invalid memory model\" } */\n+}\n+\n+/* atomic_load_explicit():\n+   The order argument shall not be memory_order_release nor\n+   memory_order_acq_rel.  */\n+\n+void\n+load (atomic_int *i)\n+{\n+  atomic_int j = atomic_load_explicit (i, memory_order_release); /* { dg-warning \"invalid memory model\" } */\n+  atomic_int k = atomic_load_explicit (i, memory_order_acq_rel); /* { dg-warning \"invalid memory model\" } */\n+}\n+\n+/* atomic_compare_exchange():\n+   The failure argument shall not be memory_order_release nor\n+   memory_order_acq_rel.  The failure argument shall be no stronger than the\n+   success argument.  */\n+\n+void\n+exchange (atomic_int *i)\n+{\n+  int r;\n+\n+  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_seq_cst, memory_order_release); /* { dg-warning \"invalid failure memory\" } */\n+  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_seq_cst, memory_order_acq_rel); /* { dg-warning \"invalid failure memory\" } */\n+  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_relaxed, memory_order_consume); /* { dg-warning \"failure memory model cannot be stronger\" } */\n+\n+  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_seq_cst, memory_order_release); /* { dg-warning \"invalid failure memory\" } */\n+  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_seq_cst, memory_order_acq_rel); /* { dg-warning \"invalid failure memory\" } */\n+  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_relaxed, memory_order_consume); /* { dg-warning \"failure memory model cannot be stronger\" } */\n+}\n+\n+/* atomic_flag_clear():\n+   The order argument shall not be memory_order_acquire nor\n+   memory_order_acq_rel.  */\n+\n+void\n+clear (atomic_int *i)\n+{\n+  atomic_flag_clear_explicit (i, memory_order_acquire); /* { dg-warning \"invalid memory model\" } */\n+  atomic_flag_clear_explicit (i, memory_order_acq_rel); /* { dg-warning \"invalid memory model\" } */\n+}\n+/* PR c/69104.  Test atomic routines for invalid memory model errors.  This\n+   only needs to be tested on a single size.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+#include <stdatomic.h>\n+\n+/* atomic_store_explicit():\n+   The order argument shall not be memory_order_acquire,\n+   memory_order_consume, nor memory_order_acq_rel.  */\n+\n+void\n+store (atomic_int *i)\n+{\n+  atomic_store_explicit (i, 0, memory_order_consume); /* { dg-warning \"invalid memory model\" } */\n+  atomic_store_explicit (i, 0, memory_order_acquire); /* { dg-warning \"invalid memory model\" } */\n+  atomic_store_explicit (i, 0, memory_order_acq_rel); /* { dg-warning \"invalid memory model\" } */\n+}\n+\n+/* atomic_load_explicit():\n+   The order argument shall not be memory_order_release nor\n+   memory_order_acq_rel.  */\n+\n+void\n+load (atomic_int *i)\n+{\n+  atomic_int j = atomic_load_explicit (i, memory_order_release); /* { dg-warning \"invalid memory model\" } */\n+  atomic_int k = atomic_load_explicit (i, memory_order_acq_rel); /* { dg-warning \"invalid memory model\" } */\n+}\n+\n+/* atomic_compare_exchange():\n+   The failure argument shall not be memory_order_release nor\n+   memory_order_acq_rel.  The failure argument shall be no stronger than the\n+   success argument.  */\n+\n+void\n+exchange (atomic_int *i)\n+{\n+  int r;\n+\n+  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_seq_cst, memory_order_release); /* { dg-warning \"invalid failure memory\" } */\n+  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_seq_cst, memory_order_acq_rel); /* { dg-warning \"invalid failure memory\" } */\n+  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_relaxed, memory_order_consume); /* { dg-warning \"failure memory model cannot be stronger\" } */\n+\n+  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_seq_cst, memory_order_release); /* { dg-warning \"invalid failure memory\" } */\n+  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_seq_cst, memory_order_acq_rel); /* { dg-warning \"invalid failure memory\" } */\n+  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_relaxed, memory_order_consume); /* { dg-warning \"failure memory model cannot be stronger\" } */\n+}\n+\n+/* atomic_flag_clear():\n+   The order argument shall not be memory_order_acquire nor\n+   memory_order_acq_rel.  */\n+\n+void\n+clear (atomic_int *i)\n+{\n+  atomic_flag_clear_explicit (i, memory_order_acquire); /* { dg-warning \"invalid memory model\" } */\n+  atomic_flag_clear_explicit (i, memory_order_acq_rel); /* { dg-warning \"invalid memory model\" } */\n+}"}]}