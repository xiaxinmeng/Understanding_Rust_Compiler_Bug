{"sha": "b36a5f8404d7c3681435b497ef6b27d69cba0a14", "node_id": "C_kwDOANBUbNoAKGIzNmE1Zjg0MDRkN2MzNjgxNDM1YjQ5N2VmNmIyN2Q2OWNiYTBhMTQ", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-20T18:00:00Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-20T18:00:00Z"}, "message": "c++: remove coerce_innermost_template_parms\n\nThe only practical difference between coerce_innermost_template_parms\nand the main function coerce_template_parms is that the former accepts\na potentially multi-level parameter list and returns an argument vector\nof the same depth, whereas the latter accepts only a single level of\nparameters and only returns only a single level of arguments.  Both\nfunctions accept a multi-level argument vector.\n\nIn light of this, it seems more natural to just overload the behavior of\nthe main function according to whether the given parameter list is\nmulti-level or not.  And it turns out we can assume the given parms and\nargs have the same depth in the multi-level case, which simplifies the\noverloading logic.\n\nBesides the simplification benefit, another benefit of this unification\nis that it avoids an extra copy of a multi-level args since now we can\nreturn new_args directly from c_t_p.  (And because of this, we need to\nturn new_inner_args into a reference so that overwriting it also updates\nnew_args.)\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (coerce_template_parms): Salvage part of the function\n\tcomment from c_innermost_t_p.  Handle parms being a full\n\ttemplate parameter list.\n\t(coerce_innermost_template_parms): Remove.\n\t(lookup_template_class): Use c_t_p instead of c_innermost_t_p.\n\t(finish_template_variable): Likewise.\n\t(tsubst_decl): Likewise.\n\t(instantiate_alias_template): Likewise.", "tree": {"sha": "c6f71d25985fe197a7a860950832921a5a921323", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6f71d25985fe197a7a860950832921a5a921323"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b36a5f8404d7c3681435b497ef6b27d69cba0a14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b36a5f8404d7c3681435b497ef6b27d69cba0a14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b36a5f8404d7c3681435b497ef6b27d69cba0a14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b36a5f8404d7c3681435b497ef6b27d69cba0a14/comments", "author": null, "committer": null, "parents": [{"sha": "6b5c98c1c0003bd470a4428bede6c862637a94b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5c98c1c0003bd470a4428bede6c862637a94b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b5c98c1c0003bd470a4428bede6c862637a94b8"}], "stats": {"total": 92, "additions": 27, "deletions": 65}, "files": [{"sha": "fbf498ad16a97c9753c0a68f1de7b8db2d805046", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 27, "deletions": 65, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36a5f8404d7c3681435b497ef6b27d69cba0a14/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36a5f8404d7c3681435b497ef6b27d69cba0a14/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=b36a5f8404d7c3681435b497ef6b27d69cba0a14", "patch": "@@ -148,8 +148,6 @@ static void add_pending_template (tree);\n static tree reopen_tinst_level (struct tinst_level *);\n static tree tsubst_initializer_list (tree, tree);\n static tree get_partial_spec_bindings (tree, tree, tree);\n-static tree coerce_innermost_template_parms (tree, tree, tree, tsubst_flags_t,\n-\t\t\t\t\t     bool = true);\n static void tsubst_enum\t(tree, tree, tree);\n static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n static int check_non_deducible_conversion (tree, tree, unification_kind_t, int,\n@@ -8842,6 +8840,14 @@ pack_expansion_args_count (tree args)\n    arguments.  If any error occurs, return error_mark_node. Error and\n    warning messages are issued under control of COMPLAIN.\n \n+   If PARMS represents all template parameters levels, this function\n+   returns a vector of vectors representing all the resulting argument\n+   levels.  Note that in this case, only the innermost arguments are\n+   coerced because the outermost ones are supposed to have been coerced\n+   already.  Otherwise, if PARMS represents only (the innermost) vector\n+   of parameters, this function returns a vector containing just the\n+   innermost resulting arguments.\n+\n    If REQUIRE_ALL_ARGS is false, argument deduction will be performed\n    for arguments not specified in ARGS.  If REQUIRE_ALL_ARGS is true,\n    arguments not specified in ARGS must have default arguments which\n@@ -8857,8 +8863,6 @@ coerce_template_parms (tree parms,\n   int nparms, nargs, parm_idx, arg_idx, lost = 0;\n   tree orig_inner_args;\n   tree inner_args;\n-  tree new_args;\n-  tree new_inner_args;\n \n   /* When used as a boolean value, indicates whether this is a\n      variadic template parameter list. Since it's an int, we can also\n@@ -8879,6 +8883,17 @@ coerce_template_parms (tree parms,\n   if (args == error_mark_node)\n     return error_mark_node;\n \n+  bool return_full_args = false;\n+  if (TREE_CODE (parms) == TREE_LIST)\n+    {\n+      if (TMPL_PARMS_DEPTH (parms) > 1)\n+\t{\n+\t  gcc_assert (TMPL_PARMS_DEPTH (parms) == TMPL_ARGS_DEPTH (args));\n+\t  return_full_args = true;\n+\t}\n+      parms = INNERMOST_TEMPLATE_PARMS (parms);\n+    }\n+\n   nparms = TREE_VEC_LENGTH (parms);\n \n   /* Determine if there are any parameter packs or default arguments.  */\n@@ -8976,8 +8991,8 @@ coerce_template_parms (tree parms,\n      template-id may be nested within a \"sizeof\".  */\n   cp_evaluated ev;\n \n-  new_inner_args = make_tree_vec (nparms);\n-  new_args = add_outermost_template_args (args, new_inner_args);\n+  tree new_args = add_outermost_template_args (args, make_tree_vec (nparms));\n+  tree& new_inner_args = TMPL_ARGS_LEVEL (new_args, TMPL_ARGS_DEPTH (new_args));\n   int pack_adjust = 0;\n   for (parm_idx = 0, arg_idx = 0; parm_idx < nparms; parm_idx++, arg_idx++)\n     {\n@@ -9179,59 +9194,7 @@ coerce_template_parms (tree parms,\n     SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args,\n \t\t\t\t\t TREE_VEC_LENGTH (new_inner_args));\n \n-  return new_inner_args;\n-}\n-\n-/* Like coerce_template_parms.  If PARMS represents all template\n-   parameters levels, this function returns a vector of vectors\n-   representing all the resulting argument levels.  Note that in this\n-   case, only the innermost arguments are coerced because the\n-   outermost ones are supposed to have been coerced already.\n-\n-   Otherwise, if PARMS represents only (the innermost) vector of\n-   parameters, this function returns a vector containing just the\n-   innermost resulting arguments.  */\n-\n-static tree\n-coerce_innermost_template_parms (tree parms,\n-\t\t\t\t tree args,\n-\t\t\t\t tree in_decl,\n-\t\t\t\t tsubst_flags_t complain,\n-\t\t\t\t bool require_all_args /* = true */)\n-{\n-  int parms_depth = TMPL_PARMS_DEPTH (parms);\n-  int args_depth = TMPL_ARGS_DEPTH (args);\n-  tree coerced_args;\n-\n-  if (parms_depth > 1)\n-    {\n-      coerced_args = make_tree_vec (parms_depth);\n-      tree level;\n-      int cur_depth;\n-\n-      for (level = parms, cur_depth = parms_depth;\n-\t   parms_depth > 0 && level != NULL_TREE;\n-\t   level = TREE_CHAIN (level), --cur_depth)\n-\t{\n-\t  tree l;\n-\t  if (cur_depth == args_depth)\n-\t    l = coerce_template_parms (TREE_VALUE (level),\n-\t\t\t\t       args, in_decl, complain,\n-\t\t\t\t       require_all_args);\n-\t  else\n-\t    l = TMPL_ARGS_LEVEL (args, cur_depth);\n-\n-\t  if (l == error_mark_node)\n-\t    return error_mark_node;\n-\n-\t  SET_TMPL_ARGS_LEVEL (coerced_args, cur_depth, l);\n-\t}\n-    }\n-  else\n-    coerced_args = coerce_template_parms (INNERMOST_TEMPLATE_PARMS (parms),\n-\t\t\t\t\t  args, in_decl, complain,\n-\t\t\t\t\t  require_all_args);\n-  return coerced_args;\n+  return return_full_args ? new_args : new_inner_args;\n }\n \n /* Returns true if T is a wrapper to make a C++20 template parameter\n@@ -9924,8 +9887,7 @@ lookup_template_class (tree d1, tree arglist, tree in_decl, tree context,\n       /* Calculate the BOUND_ARGS.  These will be the args that are\n \t actually tsubst'd into the definition to create the\n \t instantiation.  */\n-      arglist = coerce_innermost_template_parms (parmlist, arglist, gen_tmpl,\n-\t\t\t\t\t\t complain);\n+      arglist = coerce_template_parms (parmlist, arglist, gen_tmpl, complain);\n \n       if (arglist == error_mark_node)\n \t/* We were unable to bind the arguments.  */\n@@ -10341,7 +10303,7 @@ finish_template_variable (tree var, tsubst_flags_t complain)\n   tree arglist = TREE_OPERAND (var, 1);\n \n   tree parms = DECL_TEMPLATE_PARMS (templ);\n-  arglist = coerce_innermost_template_parms (parms, arglist, templ, complain);\n+  arglist = coerce_template_parms (parms, arglist, templ, complain);\n   if (arglist == error_mark_node)\n     return error_mark_node;\n \n@@ -15088,7 +15050,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t  /* We're fully specializing a template declaration, so\n \t\t     we need to coerce the innermost arguments corresponding to\n \t\t     the template.  */\n-\t\t  argvec = (coerce_innermost_template_parms\n+\t\t  argvec = (coerce_template_parms\n \t\t\t    (DECL_TEMPLATE_PARMS (gen_tmpl),\n \t\t\t     argvec, t, complain));\n \t\tif (argvec == error_mark_node)\n@@ -21941,8 +21903,8 @@ instantiate_alias_template (tree tmpl, tree args, tsubst_flags_t complain)\n   if (tmpl == error_mark_node || args == error_mark_node)\n     return error_mark_node;\n \n-  args = coerce_innermost_template_parms (DECL_TEMPLATE_PARMS (tmpl),\n-\t\t\t\t\t  args, tmpl, complain);\n+  args = coerce_template_parms (DECL_TEMPLATE_PARMS (tmpl),\n+\t\t\t\targs, tmpl, complain);\n \n   /* FIXME check for satisfaction in check_instantiated_args.  */\n   if (flag_concepts"}]}