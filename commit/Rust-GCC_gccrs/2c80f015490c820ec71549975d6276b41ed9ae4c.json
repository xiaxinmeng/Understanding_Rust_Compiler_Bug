{"sha": "2c80f015490c820ec71549975d6276b41ed9ae4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4MGYwMTU0OTBjODIwZWM3MTU0OTk3NWQ2Mjc2YjQxZWQ5YWU0Yw==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2005-04-29T18:43:25Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2005-04-29T18:43:25Z"}, "message": "re PR java/19285 (Interfaces not initialized by static field access)\n\n2005-04-28  Andrew Haley  <aph@redhat.com>\n\n        PR java/19285\n        * java-tree.h (soft_resolvepoolentry_node): New.\n        (alloc_constant_fieldref): Declare.\n        * expr.c (expand_java_field_op): Don't call class_init for\n        accesses to static fields with indirect dispatch.\n        * builtins.c (initialize_builtins): Add \"__builtin_expect\".\n        * decl.c (soft_resolvepoolentry_node): New variable.\n        (java_init_decl_processing): Create a decl for\n        \"_Jv_ResolvePoolEntry\".\n        * class.c (build_fieldref_cache_entry): New function.\n        (build_static_field_ref): Rewrite for indirect dispatch.\n        * constants.c (find_name_and_type_constant_tree): New function.\n        (alloc_constant_fieldref): Likewise.\n        (build_constants_constructor): Handle CONSTANT_Fieldref and\n        CONSTANT_NameAndType.\n\n        PR java/21115\n        * expr.c (force_evaluation_order): Convert outgoing args smaller\n        than integer.\n\nFrom-SVN: r99010", "tree": {"sha": "158742ad984de1e20c807a73f81b51044ae5edee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/158742ad984de1e20c807a73f81b51044ae5edee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c80f015490c820ec71549975d6276b41ed9ae4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c80f015490c820ec71549975d6276b41ed9ae4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c80f015490c820ec71549975d6276b41ed9ae4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c80f015490c820ec71549975d6276b41ed9ae4c/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a68b179c86764d41292502567a7b1252f4e57eae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a68b179c86764d41292502567a7b1252f4e57eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a68b179c86764d41292502567a7b1252f4e57eae"}], "stats": {"total": 249, "additions": 185, "deletions": 64}, "files": [{"sha": "deaaa3132ce2cac040ce3759efccb703336241a6", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=2c80f015490c820ec71549975d6276b41ed9ae4c", "patch": "@@ -1,3 +1,25 @@\n+2005-04-28  Andrew Haley  <aph@redhat.com>\n+\n+\tPR java/19285\n+\t* java-tree.h (soft_resolvepoolentry_node): New.\n+\t(alloc_constant_fieldref): Declare.\n+\t* expr.c (expand_java_field_op): Don't call class_init for\n+\taccesses to static fields with indirect dispatch.\n+\t* builtins.c (initialize_builtins): Add \"__builtin_expect\".\n+\t* decl.c (soft_resolvepoolentry_node): New variable.\n+\t(java_init_decl_processing): Create a decl for\n+\t\"_Jv_ResolvePoolEntry\".\n+\t* class.c (build_fieldref_cache_entry): New function.\n+\t(build_static_field_ref): Rewrite for indirect dispatch.\n+\t* constants.c (find_name_and_type_constant_tree): New function.\n+\t(alloc_constant_fieldref): Likewise.\n+\t(build_constants_constructor): Handle CONSTANT_Fieldref and\n+\tCONSTANT_NameAndType.\n+\n+\tPR java/21115\n+\t* expr.c (force_evaluation_order): Convert outgoing args smaller\n+\tthan integer.\n+\n 2005-04-27  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* gcj.texi (libgcj Runtime Properties): Remove obsolete"}, {"sha": "dcfff1c1ef50c65321ecf8f5d021bd02f7d0cd28", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=2c80f015490c820ec71549975d6276b41ed9ae4c", "patch": "@@ -161,6 +161,7 @@ initialize_builtins (void)\n {\n   tree double_ftype_double, double_ftype_double_double;\n   tree float_ftype_float, float_ftype_float_float;\n+  tree boolean_ftype_boolean_boolean;\n   tree t;\n   int i;\n \n@@ -216,7 +217,14 @@ initialize_builtins (void)\n \t\t  double_ftype_double, \"_ZN4java4lang4Math4sqrtEd\");\n   define_builtin (BUILT_IN_TAN, \"__builtin_tan\",\n \t\t  double_ftype_double, \"_ZN4java4lang4Math3tanEd\");\n-\n+  \n+  t = tree_cons (NULL_TREE, boolean_type_node, end_params_node);\n+  t = tree_cons (NULL_TREE, boolean_type_node, t);\n+  boolean_ftype_boolean_boolean = build_function_type (boolean_type_node, t);\n+  define_builtin (BUILT_IN_EXPECT, \"__builtin_expect\", \n+\t\t  boolean_ftype_boolean_boolean,\n+\t\t  \"__builtin_expect\");\n+\t\t  \n   build_common_builtin_nodes ();\n }\n "}, {"sha": "321c1e495542fa0d707d644a1ffd47100ad01ae9", "filename": "gcc/java/class.c", "status": "modified", "additions": 64, "deletions": 51, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=2c80f015490c820ec71549975d6276b41ed9ae4c", "patch": "@@ -1037,6 +1037,31 @@ build_class_ref (tree type)\n     return build_indirect_class_ref (type);\n }\n \n+/* Create a local statically allocated variable that will hold a\n+   pointer to a static field.  */\n+\n+static tree\n+build_fieldref_cache_entry (int index, tree fdecl ATTRIBUTE_UNUSED)\n+{\n+  tree decl, decl_name;\n+  const char *name = IDENTIFIER_POINTER (mangled_classname (\"_cpool_\", output_class));\n+  char *buf = alloca (strlen (name) + 20);\n+  sprintf (buf, \"%s_%d_ref\", name, index);\n+  decl_name = get_identifier (buf);\n+  decl = IDENTIFIER_GLOBAL_VALUE (decl_name);\n+  if (decl == NULL_TREE)\n+    {\n+      decl = build_decl (VAR_DECL, decl_name, ptr_type_node);\n+      TREE_STATIC (decl) = 1;\n+      TREE_PUBLIC (decl) = 0;\n+      DECL_EXTERNAL (decl) = 0;\n+      DECL_ARTIFICIAL (decl) = 1;\n+      make_decl_rtl (decl);\n+      pushdecl_top_level (decl);\n+    }\n+  return decl;\n+}\n+\n tree\n build_static_field_ref (tree fdecl)\n {\n@@ -1062,59 +1087,47 @@ build_static_field_ref (tree fdecl)\n \t    DECL_EXTERNAL (fdecl) = 1;\n \t  make_decl_rtl (fdecl);\n \t}\n-      return fdecl;\n     }\n-\n-  if (flag_indirect_dispatch)\n+  else\n     {\n-      tree table_index \n-\t= build_int_cst (NULL_TREE, get_symbol_table_index \n-\t\t\t (fdecl, &TYPE_ATABLE_METHODS (output_class)));\n-      tree field_address\n-\t= build4 (ARRAY_REF, \n-\t\t  TREE_TYPE (TREE_TYPE (TYPE_ATABLE_DECL (output_class))), \n-\t\t  TYPE_ATABLE_DECL (output_class), table_index,\n-\t\t  NULL_TREE, NULL_TREE);\n-      field_address = convert (build_pointer_type (TREE_TYPE (fdecl)),\n-\t\t\t       field_address);\n-      return fold (build1 (INDIRECT_REF, TREE_TYPE (fdecl), \n-\t\t\t   field_address));\n-    }\n-  else  \n-    {\n-      /* Compile as:\n-       *(FTYPE*)build_class_ref(FCLASS)->fields[INDEX].info.addr */\n-      tree ref = build_class_ref (fclass);\n-      tree fld;\n-      int field_index = 0;\n-      ref = build1 (INDIRECT_REF, class_type_node, ref);\n-      ref = build3 (COMPONENT_REF, field_ptr_type_node, ref,\n-\t\t    lookup_field (&class_type_node, fields_ident),\n-\t\t    NULL_TREE);\n-\n-      for (fld = TYPE_FIELDS (fclass); ; fld = TREE_CHAIN (fld))\n-\t{\n-\t  if (fld == fdecl)\n-\t    break;\n-\t  if (fld == NULL_TREE)\n-\t    fatal_error (\"field '%s' not found in class\",\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (fdecl)));\n-\t  if (FIELD_STATIC (fld))\n-\t    field_index++;\n-\t}\n-      field_index *= int_size_in_bytes (field_type_node);\n-      ref = fold (build2 (PLUS_EXPR, field_ptr_type_node,\n-\t\t\t  ref, build_int_cst (NULL_TREE, field_index)));\n-      ref = build1 (INDIRECT_REF, field_type_node, ref);\n-      ref = build3 (COMPONENT_REF, field_info_union_node,\n-\t\t    ref, lookup_field (&field_type_node, info_ident), \n-\t\t    NULL_TREE);\n-      ref = build3 (COMPONENT_REF, ptr_type_node,\n-\t\t    ref, TREE_CHAIN (TYPE_FIELDS (field_info_union_node)),\n-\t\t    NULL_TREE);\n-      ref = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (fdecl)), ref);\n-      return fold (build1 (INDIRECT_REF, TREE_TYPE(fdecl), ref));\n-    }\n+      /* Generate a CONSTANT_FieldRef for FDECL in the constant pool\n+\t and a class local static variable CACHE_ENTRY, then\n+      \n+      *(fdecl **)((__builtin_expect (cache_entry == null, false)) \n+\t\t  ? cache_entry = _Jv_ResolvePoolEntry (output_class, cpool_index)\n+\t\t  : cache_entry)\n+\n+      This can mostly be optimized away, so that the usual path is a\n+      load followed by a test and branch.  _Jv_ResolvePoolEntry is\n+      only called once for each constant pool entry.\n+\n+      There is an optimization that we don't do: at the start of a\n+      method, create a local copy of CACHE_ENTRY and use that instead.\n+\n+      */\n+\n+      int cpool_index = alloc_constant_fieldref (output_class, fdecl);\n+      tree cache_entry = build_fieldref_cache_entry (cpool_index, fdecl);\n+      tree test \n+\t= build3 (CALL_EXPR, boolean_type_node, \n+\t\t  build_address_of (built_in_decls[BUILT_IN_EXPECT]),\n+\t\t  tree_cons (NULL_TREE, build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t\t\tcache_entry, null_pointer_node),\n+\t\t\t     build_tree_list (NULL_TREE, boolean_false_node)),\n+\t\t  NULL_TREE);\n+      tree cpool_index_cst = build_int_cst (NULL_TREE, cpool_index);\n+      tree init\n+\t= build3 (CALL_EXPR, ptr_type_node,\n+\t\t  build_address_of (soft_resolvepoolentry_node),\n+\t\t  tree_cons (NULL_TREE, build_class_ref (output_class),\n+\t\t\t     build_tree_list (NULL_TREE, cpool_index_cst)),\n+\t\t  NULL_TREE);\n+      init = build2 (MODIFY_EXPR, ptr_type_node, cache_entry, init);\n+      init = build3 (COND_EXPR, ptr_type_node, test, init, cache_entry);\n+      init = fold_convert (build_pointer_type (TREE_TYPE (fdecl)), init);\n+      fdecl = build1 (INDIRECT_REF, TREE_TYPE (fdecl), init);\n+    }\n+  return fdecl;\n }\n \n int"}, {"sha": "ff58b87852dfdc505f45ab4c8b9e257ccb936866", "filename": "gcc/java/constants.c", "status": "modified", "additions": 63, "deletions": 9, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=2c80f015490c820ec71549975d6276b41ed9ae4c", "patch": "@@ -356,6 +356,41 @@ alloc_name_constant (int tag, tree name)\n   return find_tree_constant (outgoing_cpool, tag, name);\n }\n \n+/* Create a constant pool entry for a name_and_type.  This one has '.'\n+   rather than '/' because it isn't going into a class file, it's\n+   going into a compiled object.  We don't use the '/' separator in\n+   compiled objects.  */\n+\n+static int\n+find_name_and_type_constant_tree (CPool *cpool, tree name, tree type)\n+{\n+  int name_index = find_utf8_constant (cpool, name);\n+  int type_index \n+    = find_utf8_constant (cpool, \n+\t\t\t  identifier_subst (build_java_signature (type), \n+\t\t\t\t\t    \"\", '/', '.', \"\"));\n+  return find_constant1 (cpool, CONSTANT_NameAndType,\n+\t\t\t (name_index << 16) | type_index);\n+}\n+\n+/* Look for a field ref that matches DECL in the constant pool of\n+   CLASS.  \n+   Return the index of the entry.  */\n+\n+int\n+alloc_constant_fieldref (tree class, tree decl)\n+{\n+  CPool *outgoing_cpool = cpool_for_class (class);\n+  int class_index \n+    = find_tree_constant (outgoing_cpool, CONSTANT_Class, \n+\t\t\t  DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl))));\n+  int name_type_index\n+    = find_name_and_type_constant_tree (outgoing_cpool, DECL_NAME (decl), \n+\t\t\t\t\tTREE_TYPE (decl));\n+  return find_constant1 (outgoing_cpool, CONSTANT_Fieldref,\n+\t\t\t (class_index << 16) | name_type_index);\n+}\n+\n /* Build an identifier for the internal name of reference type TYPE. */\n \n tree\n@@ -442,14 +477,33 @@ build_constants_constructor (void)\n   tree data_list = NULL_TREE;\n   int i;\n   for (i = outgoing_cpool->count;  --i > 0; )\n-    {\n-      tags_list\n-\t= tree_cons (NULL_TREE, get_tag_node (outgoing_cpool->tags[i]),\n-\t\t     tags_list);\n-      data_list\n-\t= tree_cons (NULL_TREE, build_utf8_ref (outgoing_cpool->data[i].t),\n-\t\t     data_list);\n-    }\n+    switch (outgoing_cpool->tags[i])\n+      {\n+      case CONSTANT_Fieldref:\n+      case CONSTANT_NameAndType:\n+\t{\n+\t  jword temp = outgoing_cpool->data[i].w;\n+\n+\t  tags_list\n+\t    = tree_cons (NULL_TREE, \n+\t\t\t build_int_cst (NULL_TREE, outgoing_cpool->tags[i]),\n+\t\t\t tags_list);\n+\t  data_list\n+\t    = tree_cons (NULL_TREE, \n+\t\t\t fold_convert (ptr_type_node, \n+\t\t\t\t       (build_int_cst (NULL_TREE, temp))),\n+\t\t\t data_list);\n+\t}\n+\tbreak;\n+      default:\n+\ttags_list\n+\t  = tree_cons (NULL_TREE, get_tag_node (outgoing_cpool->tags[i]),\n+\t\t       tags_list);\n+\tdata_list\n+\t  = tree_cons (NULL_TREE, build_utf8_ref (outgoing_cpool->data[i].t),\n+\t\t       data_list);\n+\tbreak;\n+      }\n   if (outgoing_cpool->count > 0)\n     {\n       tree data_decl, tags_decl, tags_type;\n@@ -461,7 +515,7 @@ build_constants_constructor (void)\n       data_list = tree_cons (NULL_TREE, null_pointer_node, data_list);\n   \n       data_decl = build_constant_data_ref ();\n-      TREE_TYPE (data_decl) = build_array_type (ptr_type_node, index_type), \n+      TREE_TYPE (data_decl) = build_array_type (ptr_type_node, index_type);\n       DECL_INITIAL (data_decl) = build_constructor (TREE_TYPE (data_decl),\n \t\t\t\t\t\t    data_list);\n       DECL_SIZE (data_decl) = TYPE_SIZE (TREE_TYPE (data_decl));"}, {"sha": "204a674b1754e10daa9d04628cb69695c8c22c8f", "filename": "gcc/java/decl.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=2c80f015490c820ec71549975d6276b41ed9ae4c", "patch": "@@ -104,6 +104,9 @@ static int uniq;\n \n static GTY(()) tree pending_local_decls;\n \n+/* The decl for \"_Jv_ResolvePoolEntry\".  */\n+tree soft_resolvepoolentry_node;\n+\n #if defined(DEBUG_JAVA_BINDING_LEVELS)\n int binding_depth = 0;\n int is_class_level = 0;\n@@ -1015,7 +1018,13 @@ java_init_decl_processing (void)\n \t\t\t\t\t  build_function_type (void_type_node,\n \t\t\t\t\t\t\t       t),\n \t\t\t\t\t  0, NOT_BUILT_IN, NULL, NULL_TREE);\n-\n+  t = tree_cons (NULL_TREE, class_ptr_type,\n+\t\t tree_cons (NULL_TREE, int_type_node, endlink));\n+  soft_resolvepoolentry_node \n+    = builtin_function (\"_Jv_ResolvePoolEntry\", \n+\t\t\tbuild_function_type (ptr_type_node, t),\n+\t\t\t0,NOT_BUILT_IN, NULL, NULL_TREE);\n+  DECL_IS_PURE (soft_resolvepoolentry_node) = 1;\n   throw_node = builtin_function (\"_Jv_Throw\",\n \t\t\t\t build_function_type (void_type_node, t),\n \t\t\t\t 0, NOT_BUILT_IN, NULL, NULL_TREE);"}, {"sha": "3cc33aed68da109bebf31acf46d49eaad6c47a68", "filename": "gcc/java/expr.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=2c80f015490c820ec71549975d6276b41ed9ae4c", "patch": "@@ -2715,7 +2715,8 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n     }\n \n   field_ref = build_field_ref (field_ref, self_type, field_name);\n-  if (is_static)\n+  if (is_static\n+      && ! flag_indirect_dispatch)\n     field_ref = build_class_init (self_type, field_ref);\n   if (is_putting)\n     {\n@@ -3484,7 +3485,8 @@ maybe_adjust_start_pc (struct JCF *jcf, int code_offset,\n    For method invocation, we modify the arguments so that a\n    left-to-right order evaluation is performed. Saved expressions\n    will, in CALL_EXPR order, be reused when the call will be expanded.\n-*/\n+\n+   We also promote outgoing args if needed.  */\n \n tree\n force_evaluation_order (tree node)\n@@ -3518,6 +3520,15 @@ force_evaluation_order (tree node)\n       /* This reverses the evaluation order. This is a desired effect. */\n       for (cmp = NULL_TREE; arg; arg = TREE_CHAIN (arg))\n \t{\n+\t  /* Promote types smaller than integer.  This is required by\n+\t     some ABIs.  */\n+\t  tree type = TREE_TYPE (TREE_VALUE (arg));\n+\t  if (targetm.calls.promote_prototypes (type)\n+\t      && INTEGRAL_TYPE_P (type)\n+\t      && INT_CST_LT_UNSIGNED (TYPE_SIZE (type),\n+\t\t\t\t      TYPE_SIZE (integer_type_node)))\n+\t    TREE_VALUE (arg) = fold_convert (integer_type_node, TREE_VALUE (arg));\n+\n \t  tree saved = save_expr (force_evaluation_order (TREE_VALUE (arg)));\n \t  cmp = (cmp == NULL_TREE ? saved :\n \t\t build2 (COMPOUND_EXPR, void_type_node, cmp, saved));"}, {"sha": "a55e9ab476b2a7126ebdda0b9a57df8f40b82645", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c80f015490c820ec71549975d6276b41ed9ae4c/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=2c80f015490c820ec71549975d6276b41ed9ae4c", "patch": "@@ -686,6 +686,9 @@ extern GTY(()) tree java_global_trees[JTI_MAX];\n #define wfl_operator \\\n   java_global_trees[JTI_WFL_OPERATOR]\n \n+/* The decl for \"_Jv_ResolvePoolEntry\".  */\n+extern GTY(()) tree soft_resolvepoolentry_node;\n+\n extern const char *cyclic_inheritance_report;\n \n struct lang_identifier GTY(())\n@@ -1285,6 +1288,7 @@ extern tree get_method_index (tree decl);\n extern void make_class_data (tree);\n extern void register_class (void);\n extern int alloc_name_constant (int, tree);\n+extern int alloc_constant_fieldref (tree, tree);\n extern void emit_register_classes (tree *);\n extern tree emit_symbol_table (tree, tree, tree, tree, tree, int);\n extern void lang_init_source (int);"}]}