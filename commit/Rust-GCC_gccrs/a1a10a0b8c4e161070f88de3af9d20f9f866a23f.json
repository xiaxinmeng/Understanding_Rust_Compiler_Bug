{"sha": "a1a10a0b8c4e161070f88de3af9d20f9f866a23f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFhMTBhMGI4YzRlMTYxMDcwZjg4ZGUzYWY5ZDIwZjlmODY2YTIzZg==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2020-10-07T14:51:21Z"}, "committer": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2020-10-12T10:18:53Z"}, "message": "IBM Z: Change vector copysign to use bitwise operations\n\nThe vector copysign pattern incorrectly assumes that vector\nif_then_else operates on bits, not on elements.  This can theoretically\nmislead the optimizers.  Fix by changing it to use bitwise operations,\nlike commit 2930bb321794 (\"PR94613: Fix vec_sel builtin for IBM Z\") did\nfor vec_sel builtin.\n\ngcc/ChangeLog:\n\n2020-10-07  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\t* config/s390/s390-protos.h (s390_build_signbit_mask): New\n\tfunction.\n\t* config/s390/s390.c (s390_contiguous_bitmask_vector_p):\n\tBitcast the argument to an integral mode.\n\t(s390_expand_vec_init): Do not call\n\ts390_contiguous_bitmask_vector_p with a scalar argument.\n\t(s390_build_signbit_mask): New function.\n\t* config/s390/vector.md (copysign<mode>3): Use bitwise\n\toperations.", "tree": {"sha": "2bdc90abfa45dffb4990e0adaa86750b9674305d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bdc90abfa45dffb4990e0adaa86750b9674305d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1a10a0b8c4e161070f88de3af9d20f9f866a23f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1a10a0b8c4e161070f88de3af9d20f9f866a23f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1a10a0b8c4e161070f88de3af9d20f9f866a23f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1a10a0b8c4e161070f88de3af9d20f9f866a23f/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edafa96b8210227b0c6a2d539aa41ce529805441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edafa96b8210227b0c6a2d539aa41ce529805441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edafa96b8210227b0c6a2d539aa41ce529805441"}], "stats": {"total": 73, "additions": 45, "deletions": 28}, "files": [{"sha": "029f7289fac755ce6917c62a4b755015a9a19c9a", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a10a0b8c4e161070f88de3af9d20f9f866a23f/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a10a0b8c4e161070f88de3af9d20f9f866a23f/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=a1a10a0b8c4e161070f88de3af9d20f9f866a23f", "patch": "@@ -121,6 +121,7 @@ extern void s390_expand_vec_compare_cc (rtx, enum rtx_code, rtx, rtx, bool);\n extern enum rtx_code s390_reverse_condition (machine_mode, enum rtx_code);\n extern void s390_expand_vcond (rtx, rtx, rtx, enum rtx_code, rtx, rtx);\n extern void s390_expand_vec_init (rtx, rtx);\n+extern rtx s390_build_signbit_mask (machine_mode);\n extern rtx s390_return_addr_rtx (int, rtx);\n extern rtx s390_back_chain_rtx (void);\n extern rtx_insn *s390_emit_call (rtx, rtx, rtx, rtx);"}, {"sha": "dbb541bbea71a033468f1a13e59677e19e5da7ab", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a10a0b8c4e161070f88de3af9d20f9f866a23f/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a10a0b8c4e161070f88de3af9d20f9f866a23f/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=a1a10a0b8c4e161070f88de3af9d20f9f866a23f", "patch": "@@ -2467,6 +2467,9 @@ s390_contiguous_bitmask_vector_p (rtx op, int *start, int *end)\n   rtx elt;\n   bool b;\n \n+  /* Handle floats by bitcasting them to ints.  */\n+  op = gen_lowpart (related_int_vector_mode (GET_MODE (op)).require (), op);\n+\n   gcc_assert (!!start == !!end);\n   if (!const_vec_duplicate_p (op, &elt)\n       || !CONST_INT_P (elt))\n@@ -6863,15 +6866,16 @@ s390_expand_vec_init (rtx target, rtx vals)\n     }\n \n   /* Use vector gen mask or vector gen byte mask if possible.  */\n-  if (all_same && all_const_int\n-      && (XVECEXP (vals, 0, 0) == const0_rtx\n-\t  || s390_contiguous_bitmask_vector_p (XVECEXP (vals, 0, 0),\n-\t\t\t\t\t       NULL, NULL)\n-\t  || s390_bytemask_vector_p (XVECEXP (vals, 0, 0), NULL)))\n+  if (all_same && all_const_int)\n     {\n-      emit_insn (gen_rtx_SET (target,\n-\t\t\t      gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0))));\n-      return;\n+      rtx vec = gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0));\n+      if (XVECEXP (vals, 0, 0) == const0_rtx\n+\t  || s390_contiguous_bitmask_vector_p (vec, NULL, NULL)\n+\t  || s390_bytemask_vector_p (vec, NULL))\n+\t{\n+\t  emit_insn (gen_rtx_SET (target, vec));\n+\t  return;\n+\t}\n     }\n \n   /* Use vector replicate instructions.  vlrep/vrepi/vrep  */\n@@ -6949,6 +6953,30 @@ s390_expand_vec_init (rtx target, rtx vals)\n     }\n }\n \n+/* Emit a vector constant that contains 1s in each element's sign bit position\n+   and 0s in other positions.  MODE is the desired constant's mode.  */\n+extern rtx\n+s390_build_signbit_mask (machine_mode mode)\n+{\n+  /* Generate the integral element mask value.  */\n+  machine_mode inner_mode = GET_MODE_INNER (mode);\n+  int inner_bitsize = GET_MODE_BITSIZE (inner_mode);\n+  wide_int mask_val = wi::set_bit_in_zero (inner_bitsize - 1, inner_bitsize);\n+\n+  /* Emit the element mask rtx.  Use gen_lowpart in order to cast the integral\n+     value to the desired mode.  */\n+  machine_mode int_mode = related_int_vector_mode (mode).require ();\n+  rtx mask = immed_wide_int_const (mask_val, GET_MODE_INNER (int_mode));\n+  mask = gen_lowpart (inner_mode, mask);\n+\n+  /* Emit the vector mask rtx by mode the element mask rtx.  */\n+  int nunits = GET_MODE_NUNITS (mode);\n+  rtvec v = rtvec_alloc (nunits);\n+  for (int i = 0; i < nunits; i++)\n+    RTVEC_ELT (v, i) = mask;\n+  return gen_rtx_CONST_VECTOR (mode, v);\n+}\n+\n /* Structure to hold the initial parameters for a compare_and_swap operation\n    in HImode and QImode.  */\n "}, {"sha": "e9332bad0fd26956601acb99c4ca786a557dec77", "filename": "gcc/config/s390/vector.md", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a10a0b8c4e161070f88de3af9d20f9f866a23f/gcc%2Fconfig%2Fs390%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a10a0b8c4e161070f88de3af9d20f9f866a23f/gcc%2Fconfig%2Fs390%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvector.md?ref=a1a10a0b8c4e161070f88de3af9d20f9f866a23f", "patch": "@@ -1425,28 +1425,16 @@\n \n ; Vector copysign, implement using vector select\n (define_expand \"copysign<mode>3\"\n-  [(set (match_operand:VFT 0 \"register_operand\" \"\")\n-\t(if_then_else:VFT\n-\t (eq (match_dup 3)\n-\t     (match_dup 4))\n-\t (match_operand:VFT 1 \"register_operand\"  \"\")\n-\t (match_operand:VFT 2 \"register_operand\"  \"\")))]\n+  [(set (match_operand:VFT            0 \"register_operand\" \"\")\n+\t(ior:VFT\n+\t (and:VFT (match_operand:VFT  2 \"register_operand\" \"\")\n+\t\t  (match_dup 3))\n+\t (and:VFT (not:VFT (match_dup 3))\n+\t\t  (match_operand:VFT  1 \"register_operand\" \"\"))))]\n   \"TARGET_VX\"\n {\n-  int sz = GET_MODE_BITSIZE (GET_MODE_INNER (<MODE>mode));\n-  int prec = GET_MODE_PRECISION (GET_MODE_INNER (<tointvec>mode));\n-  wide_int mask_val = wi::shwi (1l << (sz - 1), prec);\n-\n-  rtx mask = gen_reg_rtx (<tointvec>mode);\n-\n-  int nunits = GET_MODE_NUNITS (<tointvec>mode);\n-  rtvec v = rtvec_alloc (nunits);\n-  for (int i = 0; i < nunits; i++)\n-    RTVEC_ELT (v, i) = GEN_INT (mask_val.to_shwi ());\n-\n-  mask = gen_rtx_CONST_VECTOR (<tointvec>mode, v);\n-  operands[3] = force_reg (<tointvec>mode, mask);\n-  operands[4] = CONST0_RTX (<tointvec>mode);\n+  rtx mask = s390_build_signbit_mask (<MODE>mode);\n+  operands[3] = force_reg (<MODE>mode, mask);\n })\n \n ;;"}]}