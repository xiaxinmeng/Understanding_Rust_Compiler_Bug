{"sha": "61a3961538a6b911e8010eb68332875f61dbbf57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFhMzk2MTUzOGE2YjkxMWU4MDEwZWI2ODMzMjg3NWY2MWRiYmY1Nw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-01-28T21:48:53Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-01-28T21:48:53Z"}, "message": "re PR fortran/38852 ([4.3] UBOUND fails for negative stride triplets)\n\n2009-01-28  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/38852\n\tPR fortran/39006\n\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Use the array\n\tdescriptor ubound for UBOUND, when the array lbound == 1.\n\n2009-01-28  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/38852\n\tPR fortran/39006\n\t* gfortran.dg/bound_6.f90: New test.\n\nFrom-SVN: r143743", "tree": {"sha": "e13e8efea1b864dfafd2a18c470041a2c15dd1b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e13e8efea1b864dfafd2a18c470041a2c15dd1b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61a3961538a6b911e8010eb68332875f61dbbf57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a3961538a6b911e8010eb68332875f61dbbf57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61a3961538a6b911e8010eb68332875f61dbbf57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a3961538a6b911e8010eb68332875f61dbbf57/comments", "author": null, "committer": null, "parents": [{"sha": "001b9eb6b19df30cceb3e9bddeb7fbec526ff958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/001b9eb6b19df30cceb3e9bddeb7fbec526ff958", "html_url": "https://github.com/Rust-GCC/gccrs/commit/001b9eb6b19df30cceb3e9bddeb7fbec526ff958"}], "stats": {"total": 91, "additions": 90, "deletions": 1}, "files": [{"sha": "1186064d02936b3119623d1d2188c5dbb537c9e8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a3961538a6b911e8010eb68332875f61dbbf57/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a3961538a6b911e8010eb68332875f61dbbf57/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=61a3961538a6b911e8010eb68332875f61dbbf57", "patch": "@@ -1,3 +1,10 @@\n+2009-01-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/38852\n+\tPR fortran/39006\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Use the array\n+\tdescriptor ubound for UBOUND, when the array lbound == 1.\n+\n 2009-01-27  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/38883"}, {"sha": "50b429368b1905b4a60f87c29d5061eb2311bf3e", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a3961538a6b911e8010eb68332875f61dbbf57/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a3961538a6b911e8010eb68332875f61dbbf57/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=61a3961538a6b911e8010eb68332875f61dbbf57", "patch": "@@ -972,12 +972,17 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \n       cond4 = fold_build2 (LT_EXPR, boolean_type_node, stride,\n \t\t\t   gfc_index_zero_node);\n-      cond4 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond4, cond2);\n \n       if (upper)\n \t{\n+\t  tree cond5;\n \t  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond3, cond4);\n \n+\t  cond5 = fold_build2 (EQ_EXPR, boolean_type_node, gfc_index_one_node, lbound);\n+\t  cond5 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond4, cond5);\n+\n+\t  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond, cond5);\n+\n \t  se->expr = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n \t\t\t\t  ubound, gfc_index_zero_node);\n \t}"}, {"sha": "06585cd57f342a91eac79391569ab2839ebd3aa8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a3961538a6b911e8010eb68332875f61dbbf57/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a3961538a6b911e8010eb68332875f61dbbf57/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=61a3961538a6b911e8010eb68332875f61dbbf57", "patch": "@@ -1,3 +1,9 @@\n+2009-01-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/38852\n+\tPR fortran/39006\n+\t* gfortran.dg/bound_6.f90: New test.\n+\n 2009-01-28  Pat Haugen  <pthaugen@us.ibm.com>\n \n \t* gcc.target/powerpc/avoid-indexed-addresses.c: New test."}, {"sha": "5e0e3f7dc55fbaae7217dada62372d9413f1ed8d", "filename": "gcc/testsuite/gfortran.dg/bound_6.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a3961538a6b911e8010eb68332875f61dbbf57/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a3961538a6b911e8010eb68332875f61dbbf57/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbound_6.f90?ref=61a3961538a6b911e8010eb68332875f61dbbf57", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do run }\r\n+! Test the fix for PR38852 and PR39006 in which LBOUND did not work\r\n+! for some arrays with negative strides.\r\n+!\r\n+! Contributed by Dick Hendrickson  <dick.hendrickson@gmail.com>\r\n+!                Clive Page        <clivegpage@googlemail.com>\r\n+!            and Mikael Morin      <mikael.morin@tele2.fr>\r\n+!\r\n+program try_je0031\r\n+  integer ida(4)\r\n+  real dda(5,5,5,5,5)\r\n+  integer, parameter :: nx = 4, ny = 3\r\n+  interface\r\n+    SUBROUTINE PR38852(IDA,DDA,nf2,nf5,mf2)\r\n+      INTEGER IDA(4)\r\n+      REAL DDA(5,5,5,5,5)\r\n+      TARGET DDA\r\n+    END SUBROUTINE\r\n+  end interface\r\n+  integer :: array1(nx,ny), array2(nx,ny) \r\n+  data array2 / 1,2,3,4, 10,20,30,40, 100,200,300,400 /\r\n+  array1 = array2\r\n+  call PR38852(IDA,DDA,2,5,-2)\r\n+  call PR39006(array1, array2(:,ny:1:-1))\r\n+  call mikael         ! http://gcc.gnu.org/ml/fortran/2009-01/msg00342.html\r\n+contains\r\n+  subroutine PR39006(array1, array2)\r\n+    integer, intent(in) :: array1(:,:), array2(:,:)\r\n+    integer :: j\r\n+    do j = 1, ubound(array2,2)\r\n+      if (any (array1(:,j) .ne. array2(:,4-j))) call abort\r\n+    end do\r\n+  end subroutine\r\n+end \r\n+\r\n+SUBROUTINE PR38852(IDA,DDA,nf2,nf5,mf2)\r\n+  INTEGER IDA(4)\r\n+  REAL DLA(:,:,:,:)\r\n+  REAL DDA(5,5,5,5,5)\r\n+  POINTER DLA\r\n+  TARGET DDA\r\n+  DLA => DDA(2:3, 1:3:2, 5:4:-1, NF2, NF5:NF2:MF2)\r\n+  IDA = UBOUND(DLA)\r\n+  if (any(ida /= 2)) call abort\r\n+  DLA => DDA(2:3, 1:3:2, 5:4:-1, 2, 5:2:-2)\r\n+  IDA = UBOUND(DLA)\r\n+  if (any(ida /= 2)) call abort\r\n+!\r\n+! These worked.\r\n+!\r\n+  DLA => DDA(2:3, 1:3:2, 5:4:-1, 2, 5:2:-2)\r\n+  IDA = shape(DLA)\r\n+  if (any(ida /= 2)) call abort\r\n+  DLA => DDA(2:3, 1:3:2, 5:4:-1, 2, 5:2:-2)\r\n+  IDA = LBOUND(DLA)\r\n+  if (any(ida /= 1)) call abort\r\n+END SUBROUTINE\r\n+\r\n+subroutine mikael\r\n+  implicit none\r\n+  call test (1,  3, 3)\r\n+  call test (2,  3, 3)\r\n+  call test (2, -1, 0)\r\n+  call test (1, -1, 0)\r\n+contains\r\n+  subroutine test (a, b, expect)\r\n+    integer :: a, b, expect\r\n+    integer :: c(a:b)\r\n+    if (ubound (c, 1) .ne. expect) call abort\r\n+  end subroutine test\r\n+end subroutine\r"}]}