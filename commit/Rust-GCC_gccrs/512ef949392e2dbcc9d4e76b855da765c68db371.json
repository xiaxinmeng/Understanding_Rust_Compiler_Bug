{"sha": "512ef949392e2dbcc9d4e76b855da765c68db371", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEyZWY5NDkzOTJlMmRiY2M5ZDRlNzZiODU1ZGE3NjVjNjhkYjM3MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-01-06T20:29:54Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-01-06T20:29:54Z"}, "message": "re PR target/64505 (Powerpc compiler generates insn not found for -m32 -mpowerpc64)\n\n[gcc]\n2015-01-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/64505\n\t* config/rs6000/rs6000.c (rs6000_secondary_reload): Return the\n\tcorrect reload handler if -m32 -mpowerpc64 is used.\n\n[gcc/testsuite]\n2015-01-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/64505\n\t* gcc.target/powerpc/pr64505.c: New file to test -m32 -mpowerpc64\n\tfix is correct.\n\nFrom-SVN: r219264", "tree": {"sha": "48146d2c93eca17252b5f9c0e7865680b8eebca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48146d2c93eca17252b5f9c0e7865680b8eebca5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/512ef949392e2dbcc9d4e76b855da765c68db371", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/512ef949392e2dbcc9d4e76b855da765c68db371", "html_url": "https://github.com/Rust-GCC/gccrs/commit/512ef949392e2dbcc9d4e76b855da765c68db371", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/512ef949392e2dbcc9d4e76b855da765c68db371/comments", "author": null, "committer": null, "parents": [{"sha": "861393acbf02bf74884d5ac771ad931b8fce58d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861393acbf02bf74884d5ac771ad931b8fce58d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/861393acbf02bf74884d5ac771ad931b8fce58d9"}], "stats": {"total": 249, "additions": 247, "deletions": 2}, "files": [{"sha": "1b4cfe9c507224c85f2959538b20921f0ffc9318", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512ef949392e2dbcc9d4e76b855da765c68db371/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512ef949392e2dbcc9d4e76b855da765c68db371/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=512ef949392e2dbcc9d4e76b855da765c68db371", "patch": "@@ -1,3 +1,9 @@\n+2015-01-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/64505\n+\t* config/rs6000/rs6000.c (rs6000_secondary_reload): Return the\n+\tcorrect reload handler if -m32 -mpowerpc64 is used.\n+\n 2015-01-06  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-ssa-tail-merge.c: Fix typo in struct same_succ_def comment."}, {"sha": "9eeb805ce0feb68fe9fffbb3699128879dca10f4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512ef949392e2dbcc9d4e76b855da765c68db371/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512ef949392e2dbcc9d4e76b855da765c68db371/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=512ef949392e2dbcc9d4e76b855da765c68db371", "patch": "@@ -17080,10 +17080,13 @@ rs6000_secondary_reload (bool in_p,\n \t      : (offset + 0x8000 < 0x10000 - extra /* legitimate_address_p */\n \t\t && (offset & 3) != 0))\n \t    {\n+\t      /* -m32 -mpowerpc64 needs to use a 32-bit scratch register.  */\n \t      if (in_p)\n-\t\tsri->icode = CODE_FOR_reload_di_load;\n+\t\tsri->icode = ((TARGET_32BIT) ? CODE_FOR_reload_si_load\n+\t\t\t      : CODE_FOR_reload_di_load);\n \t      else\n-\t\tsri->icode = CODE_FOR_reload_di_store;\n+\t\tsri->icode = ((TARGET_32BIT) ? CODE_FOR_reload_si_store\n+\t\t\t      : CODE_FOR_reload_di_store);\n \t      sri->extra_cost = 2;\n \t      ret = NO_REGS;\n \t      done_p = true;"}, {"sha": "5e0d7d52181ff3d6c21a7ceefee8e927b7d49476", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512ef949392e2dbcc9d4e76b855da765c68db371/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512ef949392e2dbcc9d4e76b855da765c68db371/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=512ef949392e2dbcc9d4e76b855da765c68db371", "patch": "@@ -1,3 +1,9 @@\n+2015-01-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/64505\n+\t* gcc.target/powerpc/pr64505.c: New file to test -m32 -mpowerpc64\n+\tfix is correct.\n+\n 2015-01-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* lib/tsan-dg.exp (check_effective_target_fsanitize_thread):"}, {"sha": "81c3f579c11b5e63d472e7c15249510c04af27af", "filename": "gcc/testsuite/gcc.target/powerpc/pr64505.c", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512ef949392e2dbcc9d4e76b855da765c68db371/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr64505.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512ef949392e2dbcc9d4e76b855da765c68db371/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr64505.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr64505.c?ref=512ef949392e2dbcc9d4e76b855da765c68db371", "patch": "@@ -0,0 +1,230 @@\n+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */\n+/* { dg-options \"-O2 -mpowerpc64\" } */\n+\n+/*\n+ * (below is inlined and simplified from previously included headers)\n+ */\n+\n+struct fltcom_st {\n+    short fltbuf[950];\n+} fltcom_  __attribute__((common))  ;\n+#define CM_PLIBOR (*(((double *)&fltcom_ + 1)))\n+#define CM_QMRG (*(((double *)&fltcom_ + 2)))\n+\n+struct fltcom2_st {\n+    short fltbuf2[56];\n+} fltcom2_  __attribute__((common))  ;\n+#define CM_FLPRV ((short *)&fltcom2_ + 17)\n+#define CM_FLNXT ((short *)&fltcom2_ + 20)\n+#define CM_FLCPN (*(((double *)&fltcom2_)))\n+#define CM_FLCNT (*(((short *)&fltcom2_ + 12)))\n+\n+struct aidatcm_st {\n+    double cm_aid, cm_ext, cm_basis;\n+    short cm_aiday, cm_exday, cm_dperd, cm_aiexf, cm_aidex, cm_aiok,\n+            cm_aigdo, cm_aildo, cm_prev[3], cm_next[3], cm_aid_pad[2];\n+    double cm_rvgfact, cm_ai1st, cm_ai2nd;\n+    int cm_aieurok;\n+} aidatcm_  __attribute__((common))  ;\n+#define CM_EXDAY aidatcm_.cm_exday\n+#define CM_BASIS aidatcm_.cm_basis\n+#define CM_PREV aidatcm_.cm_prev\n+\n+struct cshfcm_st {\n+    short bufff[10862];\n+} cshfcm_  __attribute__((common))  ;\n+#define CM_FNUM (*(((short *)&cshfcm_ + 9038)))\n+#define CM_FIFLX ((double *)&cshfcm_ + 1)\n+#define CM_FEXTX ((double *)&cshfcm_ + 1201)\n+#define CM_FSHDT ((short *)&cshfcm_ + 7230)\n+\n+struct calctsdb_st {\n+    short calctsdbbuff[115];\n+} calctsdb_  __attribute__((common))  ;\n+#define CM_CTUP_GOOD_TO_GO (*(((short *)&calctsdb_ + 16)))\n+#define CM_PAYMENT_FREQUENCY (*(((short *)&calctsdb_ + 61)))\n+#define CM_DISCOUNTING_DAYTYP (*(((short *)&calctsdb_ + 59)))\n+\n+struct cf600cm_st {\n+    short bufcf[14404];\n+} cf600cm_  __attribute__((common)) ;\n+#define CM_FLT_RFIXRATES ((double *)&cf600cm_ + 600)\n+\n+typedef struct { int id; int type; const char *name; } bregdb_bitinfo_t;\n+\n+int\n+bregdb_eval_bbitcxt_bool_rv(const bregdb_bitinfo_t * const bbit,\n+                            const int bbit_default,\n+                            const void * const bregucxt);\n+\n+static const bregdb_bitinfo_t bbit_calc_dr_d33 =\n+  { 160667, 5, \"bbit_calc_dr_d33\" };\n+#define bbit_calc_dr_d33__value() \\\n+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d33, 0, 0)\n+static const bregdb_bitinfo_t bbit_calc_sx_b24 =\n+  { 158854, 5, \"bbit_calc_sx_b24\" };\n+#define bbit_calc_sx_b24__value() \\\n+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_sx_b24, 0, 0)\n+static const bregdb_bitinfo_t bbit_calc_dr_d36 =\n+  { 161244, 5, \"bbit_calc_dr_d36\" };\n+#define bbit_calc_dr_d36__value() \\\n+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d36, 0, 0)\n+static const bregdb_bitinfo_t bbit_calc_dr_d37 =\n+  { 161315, 5, \"bbit_calc_dr_d37\" };\n+#define bbit_calc_dr_d37__value() \\\n+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d37, 0, 0)\n+static const bregdb_bitinfo_t bbit_calc_dr_d47 =\n+  { 163259, 5, \"bbit_calc_dr_d47\" };\n+#define bbit_calc_dr_d47__value() \\\n+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d47, 0, 0)\n+static const bregdb_bitinfo_t bbit_calc_dr_d46 =\n+  { 163239, 5, \"bbit_calc_dr_d46\" };\n+#define bbit_calc_dr_d46__value() \\\n+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d46, 0, 0)\n+static const bregdb_bitinfo_t bbit_calc_dr_d62 =\n+  { 166603, 5, \"bbit_calc_dr_d62\" };\n+#define bbit_calc_dr_d62__value() \\\n+  bregdb_eval_bbitcxt_bool_rv(&bbit_calc_dr_d62, 0, 0)\n+\n+\n+\n+int dtyp_is_actact_(short *daytyp);\n+double rnd_trunc_numb(double in, short num_digits, short rnd_or_trunc);\n+void datetrn_(const short* dt, short* dt2);\n+short difday_(short* daytyp_in, short* srtdti, short* enddti, short* ercode);\n+\n+\n+double pow(double x, double y);\n+\n+\n+/*\n+ * (above is inlined and simplified from previously included headers)\n+ */\n+\n+\n+void calc_1566(\n+  short  sCalcType,\n+  short  sDayType,\n+  short  sFreq,\n+  short  asSettleDt[3],\n+  short  asMtyDt[3],\n+  short  asIssueDt[3],\n+  short  asFCpnDt[3],\n+  double dCpn,\n+  short  *psNoPer,\n+  double *pdExt,\n+  double *pdAI,\n+  double *pdAI2,\n+  double *pdFCpn,\n+  short  *psRcode)\n+{\n+\n+    short ercode = 0;\n+    int isactact;\n+    short days_to_next_cpn = 0;\n+    const short discDaytype = CM_DISCOUNTING_DAYTYP;\n+\n+    if(bbit_calc_sx_b24__value())\n+        isactact = (dtyp_is_actact_(&sDayType) != 0);\n+    else\n+        isactact = (sDayType == 1 || sDayType == 10);\n+\n+    short days_in_current_period = difday_(&sDayType,CM_FLPRV,CM_FLNXT,&ercode);\n+    const short sfreq1 = (CM_CTUP_GOOD_TO_GO == 1 && CM_PAYMENT_FREQUENCY == 1);\n+\n+    for (int j = 0; j < CM_FNUM; j++) {\n+\n+        if(j == 0) {\n+            days_to_next_cpn = difday_(&sDayType,asSettleDt,CM_FLNXT,&ercode);\n+\n+            if(isactact) {\n+                CM_FIFLX[j] = CM_FLCPN / sFreq;\n+                CM_FEXTX[j] = (double)days_to_next_cpn / (double)days_in_current_period;\n+            }\n+            else {\n+                CM_FIFLX[j] = CM_FLCPN * days_in_current_period;\n+                CM_FEXTX[j] = (double)days_to_next_cpn / (double)(1/sfreq1);\n+            }\n+\n+            if(CM_FNUM == 1) {\n+                CM_FEXTX[j] = (double)days_to_next_cpn / ((double)1/sfreq1);\n+            }\n+        }\n+        else {\n+\n+            short days_from_settle, days_in_period;\n+\n+            if(bbit_calc_dr_d46__value()){\n+             days_from_settle = difday_(&sDayType,asSettleDt,\n+                                             &CM_FSHDT[j*3],&ercode);\n+             days_in_period =  difday_(&sDayType,&CM_FSHDT[(j-1)*3],\n+                                            &CM_FSHDT[j*3],&ercode);\n+            }\n+\n+            double cpn_rate = CM_PLIBOR;\n+\n+            if(bbit_calc_dr_d62__value()) {\n+              if(j < CM_FLCNT && CM_FLT_RFIXRATES[j] != 0) cpn_rate = CM_FLT_RFIXRATES[j];\n+            }\n+            else {\n+              if(j < CM_FLCNT ) cpn_rate = CM_FLT_RFIXRATES[j];\n+            }\n+\n+            if(bbit_calc_dr_d37__value()&& j >= CM_FLCNT && sCalcType == 1570) {\n+                cpn_rate = CM_PLIBOR + CM_QMRG;\n+\n+                if(bbit_calc_dr_d36__value()){\n+                double projected_rate = pow((1 + CM_PLIBOR/100.0),\n+                                            (days_in_period)) - 1;\n+\n+                projected_rate = projected_rate + CM_QMRG/100.0 * days_in_period;\n+                cpn_rate = 100 * projected_rate * (1/days_in_period);\n+                }\n+            }\n+\n+\n+            if(isactact) {\n+                CM_FIFLX[j] = cpn_rate / sFreq;\n+                CM_FEXTX[j] = CM_FEXTX[j-1] + 1;\n+\n+                if(bbit_calc_dr_d46__value() && discDaytype != 0) {\n+                    CM_FEXTX[j] = (double)days_from_settle / (double)(1/sfreq1);\n+                }\n+            }\n+            else {\n+                if(!bbit_calc_dr_d46__value()){\n+                days_from_settle = difday_(&sDayType,asSettleDt,\n+                                               &CM_FSHDT[j*3],&ercode);\n+                days_in_period =  difday_(&sDayType,&CM_FSHDT[(j-1)*3],\n+                                               &CM_FSHDT[j*3],&ercode);\n+\n+                }\n+\n+                CM_FIFLX[j] = cpn_rate * days_in_period;\n+                CM_FEXTX[j] = (double)days_from_settle / (double)(1/sfreq1);\n+            }\n+\n+        }\n+\n+        if(bbit_calc_dr_d33__value() && CM_CTUP_GOOD_TO_GO != 0) {\n+            CM_FIFLX[j] = rnd_trunc_numb (CM_FIFLX[j], 0, 0);\n+        }\n+\n+    }\n+\n+\n+    short accrued_days = difday_(&sDayType,CM_FLPRV,asSettleDt,&ercode);\n+\n+    if(!bbit_calc_dr_d47__value()) {\n+    if(isactact) {\n+        *pdAI = (CM_FLCPN / sFreq)* accrued_days / ((double)days_in_current_period);\n+    }\n+    else{\n+        *pdAI = (CM_FLCPN / sFreq)* accrued_days / ((double)1/sFreq);\n+    }\n+    }\n+\n+    CM_EXDAY = days_to_next_cpn;\n+    CM_BASIS = days_in_current_period;\n+    datetrn_(CM_FLPRV,CM_PREV);\n+}"}]}