{"sha": "bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYyNGY0ZWM3M2I2NTQ1NGVhMGVkY2Q2YWI1NjE2ZjA0OTU4ZDQxZQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-01-22T02:51:35Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-03-31T12:28:32Z"}, "message": "x86: Update memcpy/memset inline strategies for Ice Lake\n\nSimply memcpy and memset inline strategies to avoid branches for\n-mtune=icelake:\n\n1. With MOVE_RATIO and CLEAR_RATIO == 17, GCC will use integer/vector\n   load and store for up to 16 * 16 (256) bytes when the data size is\n   fixed and known.\n2. Inline only if data size is known to be <= 256.\n   a. Use \"rep movsb/stosb\" with simple code sequence if the data size\n      is a constant.\n   b. Use loop if data size is not a constant.\n3. Use memcpy/memset libray function if data size is unknown or > 256.\n\nOn Ice Lake processor with -march=native -Ofast -flto,\n\n1.  Performance impacts of SPEC CPU 2017 rate are:\n\n500.perlbench_r -0.93%\n502.gcc_r        0.36%\n505.mcf_r        0.31%\n520.omnetpp_r   -0.07%\n523.xalancbmk_r -0.53%\n525.x264_r      -0.09%\n531.deepsjeng_r -0.19%\n541.leela_r      0.16%\n548.exchange2_r  0.22%\n557.xz_r        -1.64%\nGeomean         -0.24%\n\n503.bwaves_r    -0.01%\n507.cactuBSSN_r  0.00%\n508.namd_r       0.12%\n510.parest_r     0.07%\n511.povray_r     0.29%\n519.lbm_r        0.00%\n521.wrf_r       -0.38%\n526.blender_r    0.16%\n527.cam4_r       0.18%\n538.imagick_r    0.76%\n544.nab_r       -0.84%\n549.fotonik3d_r -0.07%\n554.roms_r      -0.01%\nGeomean          0.02%\n\n2. Significant impacts on eembc benchmarks are:\n\neembc/nnet_test      9.90%\neembc/mp2decoddata2  16.42%\neembc/textv2data3   -4.86%\neembc/qos            12.90%\n\ngcc/\n\n\t* config/i386/i386-expand.c (expand_set_or_cpymem_via_rep):\n\tFor TARGET_PREFER_KNOWN_REP_MOVSB_STOSB, don't convert QImode\n\tto SImode.\n\t(decide_alg): For TARGET_PREFER_KNOWN_REP_MOVSB_STOSB, use\n\t\"rep movsb/stosb\" only for known sizes.\n\t* config/i386/i386-options.c (processor_cost_table): Use Ice\n\tLake cost for Cannon Lake, Ice Lake, Tiger Lake, Sapphire\n\tRapids and Alder Lake.\n\t* config/i386/i386.h (TARGET_PREFER_KNOWN_REP_MOVSB_STOSB): New.\n\t* config/i386/x86-tune-costs.h (icelake_memcpy): New.\n\t(icelake_memset): Likewise.\n\t(icelake_cost): Likewise.\n\t* config/i386/x86-tune.def (X86_TUNE_PREFER_KNOWN_REP_MOVSB_STOSB):\n\tNew.\n\ngcc/testsuite/\n\n\t* gcc.target/i386/memcpy-strategy-5.c: New test.\n\t* gcc.target/i386/memcpy-strategy-6.c: Likewise.\n\t* gcc.target/i386/memcpy-strategy-7.c: Likewise.\n\t* gcc.target/i386/memcpy-strategy-8.c: Likewise.\n\t* gcc.target/i386/memset-strategy-3.c: Likewise.\n\t* gcc.target/i386/memset-strategy-4.c: Likewise.\n\t* gcc.target/i386/memset-strategy-5.c: Likewise.\n\t* gcc.target/i386/memset-strategy-6.c: Likewise.", "tree": {"sha": "fec9c1991dec8ed9d18e1287bc87a31e9c6ccba0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fec9c1991dec8ed9d18e1287bc87a31e9c6ccba0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1393938e4c7dab9306cdce5a73d93b242fc246ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1393938e4c7dab9306cdce5a73d93b242fc246ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1393938e4c7dab9306cdce5a73d93b242fc246ec"}], "stats": {"total": 266, "additions": 259, "deletions": 7}, "files": [{"sha": "dda08ff67f23d1eb552c85ad766bca13f4dfa271", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -5976,6 +5976,7 @@ expand_set_or_cpymem_via_rep (rtx destmem, rtx srcmem,\n   /* If possible, it is shorter to use rep movs.\n      TODO: Maybe it is better to move this logic to decide_alg.  */\n   if (mode == QImode && CONST_INT_P (count) && !(INTVAL (count) & 3)\n+      && !TARGET_PREFER_KNOWN_REP_MOVSB_STOSB\n       && (!issetmem || orig_value == const0_rtx))\n     mode = SImode;\n \n@@ -6984,7 +6985,12 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size,\n \t\t  else if (!any_alg_usable_p)\n \t\t    break;\n \t\t}\n-\t      else if (alg_usable_p (candidate, memset, have_as))\n+\t      else if (alg_usable_p (candidate, memset, have_as)\n+\t\t       && !(TARGET_PREFER_KNOWN_REP_MOVSB_STOSB\n+\t\t\t    && candidate == rep_prefix_1_byte\n+\t\t\t    /* NB: If min_size != max_size, size is\n+\t\t\t       unknown.  */\n+\t\t\t    && min_size != max_size))\n \t\t{\n \t\t  *noalign = algs->size[i].noalign;\n \t\t  return candidate;"}, {"sha": "a8d06735d79a235a7079eaa072e1b096fb0676a5", "filename": "gcc/config/i386/i386-options.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Fconfig%2Fi386%2Fi386-options.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Fconfig%2Fi386%2Fi386-options.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-options.c?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -721,14 +721,14 @@ static const struct processor_costs *processor_cost_table[] =\n   &slm_cost,\n   &skylake_cost,\n   &skylake_cost,\n+  &icelake_cost,\n+  &icelake_cost,\n+  &icelake_cost,\n   &skylake_cost,\n+  &icelake_cost,\n   &skylake_cost,\n-  &skylake_cost,\n-  &skylake_cost,\n-  &skylake_cost,\n-  &skylake_cost,\n-  &skylake_cost,\n-  &skylake_cost,\n+  &icelake_cost,\n+  &icelake_cost,\n   &intel_cost,\n   &geode_cost,\n   &k6_cost,"}, {"sha": "b4001d21b70b586e8766570c1196482bf2ec9e8a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -523,6 +523,8 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n #define TARGET_PROMOTE_QImode\tix86_tune_features[X86_TUNE_PROMOTE_QIMODE]\n #define TARGET_FAST_PREFIX\tix86_tune_features[X86_TUNE_FAST_PREFIX]\n #define TARGET_SINGLE_STRINGOP\tix86_tune_features[X86_TUNE_SINGLE_STRINGOP]\n+#define TARGET_PREFER_KNOWN_REP_MOVSB_STOSB \\\n+  ix86_tune_features[X86_TUNE_PREFER_KNOWN_REP_MOVSB_STOSB]\n #define TARGET_MISALIGNED_MOVE_STRING_PRO_EPILOGUES \\\n \tix86_tune_features[X86_TUNE_MISALIGNED_MOVE_STRING_PRO_EPILOGUES]\n #define TARGET_QIMODE_MATH\tix86_tune_features[X86_TUNE_QIMODE_MATH]"}, {"sha": "0e00ff99df320a921dd0c1bb8e0abd1bb5810022", "filename": "gcc/config/i386/x86-tune-costs.h", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -1936,6 +1936,133 @@ struct processor_costs skylake_cost = {\n   \"0:0:8\",\t\t\t\t/* Label alignment.  */\n   \"16\",\t\t\t\t\t/* Func alignment.  */\n };\n+\n+/* icelake_cost should produce code tuned for Icelake family of CPUs.\n+   NB: rep_prefix_1_byte is used only for known size. */\n+\n+static stringop_algs icelake_memcpy[2] =   {\n+  {libcall,\n+   {{256, rep_prefix_1_byte, true},\n+    {256, loop, false},\n+    {-1, libcall, false}}},\n+  {libcall,\n+   {{256, rep_prefix_1_byte, true},\n+    {256, loop, false},\n+    {-1, libcall, false}}}};\n+\n+static stringop_algs icelake_memset[2] = {\n+  {libcall,\n+   {{256, rep_prefix_1_byte, true},\n+    {256, loop, false},\n+    {-1, libcall, false}}},\n+  {libcall,\n+   {{256, rep_prefix_1_byte, true},\n+    {256, loop, false},\n+    {-1, libcall, false}}}};\n+\n+static const\n+struct processor_costs icelake_cost = {\n+  {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {6, 6, 8},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 10},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {6, 6},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {6, 6},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2, 2, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {6, 6, 6, 10, 20},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {8, 8, 8, 12, 24},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  6, 6,\t\t\t\t/* SSE->integer and integer->SSE moves */\n+  5, 5,\t\t\t\t/* mask->integer and integer->mask moves */\n+  {8, 8, 8},\t\t\t\t/* cost of loading mask register\n+\t\t\t\t\t   in QImode, HImode, SImode.  */\n+  {6, 6, 6},\t\t\t\t/* cost if storing mask register\n+\t\t\t\t\t   in QImode, HImode, SImode.  */\n+  3,\t\t\t\t\t/* cost of moving mask register.  */\n+  /* End of register allocator costs.  */\n+  },\n+\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (1)+1,\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (3)},\t\t\t/*\t\t\t      other */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  /* Expanding div/mod currently doesn't consider parallelism. So the cost\n+     model is not realistic. We compensate by increasing the latencies a bit.  */\n+  {COSTS_N_INSNS (11),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (11),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (14),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (76),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (76)},\t\t\t/*\t\t\t    other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (0),\t\t\t/* cost of movzx */\n+  8,\t\t\t\t\t/* \"large\" insn */\n+  17,\t\t\t\t\t/* MOVE_RATIO */\n+  17,\t\t\t\t\t/* CLEAR_RATIO */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n+  {6, 6, 6, 10, 20},\t\t\t/* cost of loading SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {8, 8, 8, 12, 24},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {6, 6, 6, 10, 20},\t\t\t/* cost of unaligned loads.  */\n+  {8, 8, 8, 8, 16},\t\t\t/* cost of unaligned stores.  */\n+  2, 2, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  6,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n+  20, 8,\t\t\t\t/* Gather load static, per_elt.  */\n+  22, 10,\t\t\t\t/* Gather store static, per_elt.  */\n+  64,\t\t\t\t\t/* size of l1 cache.  */\n+  512,\t\t\t\t\t/* size of l2 cache.  */\n+  64,\t\t\t\t\t/* size of prefetch block */\n+  6,\t\t\t\t\t/* number of parallel prefetches */\n+  3,\t\t\t\t\t/* Branch cost */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (20),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (20),\t\t\t/* cost of FSQRT instruction.  */\n+\n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of MULSS instruction.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FMA SD instruction.  */\n+  COSTS_N_INSNS (11),\t\t\t/* cost of DIVSS instruction.  */\n+  COSTS_N_INSNS (14),\t\t\t/* cost of DIVSD instruction.  */\n+  COSTS_N_INSNS (12),\t\t\t/* cost of SQRTSS instruction.  */\n+  COSTS_N_INSNS (18),\t\t\t/* cost of SQRTSD instruction.  */\n+  1, 4, 2, 2,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n+  icelake_memcpy,\n+  icelake_memset,\n+  COSTS_N_INSNS (3),\t\t\t/* cond_taken_branch_cost.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cond_not_taken_branch_cost.  */\n+  \"16:11:8\",\t\t\t\t/* Loop alignment.  */\n+  \"16:11:8\",\t\t\t\t/* Jump alignment.  */\n+  \"0:0:8\",\t\t\t\t/* Label alignment.  */\n+  \"16\",\t\t\t\t\t/* Func alignment.  */\n+};\n+\n   /* BTVER1 has optimized REP instruction for medium sized blocks, but for\n      very small blocks it is better to use loop. For large blocks, libcall can\n      do nontemporary accesses and beat inline considerably.  */"}, {"sha": "134916cc9723a4949bf4637841aa541990e80157", "filename": "gcc/config/i386/x86-tune.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune.def?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -269,6 +269,13 @@ DEF_TUNE (X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE, \"avoid_mem_opnd_for_cmove\",\n    as MOVS and STOS (without a REP prefix) to move/set sequences of bytes.  */\n DEF_TUNE (X86_TUNE_SINGLE_STRINGOP, \"single_stringop\", m_386 | m_P4_NOCONA)\n \n+/* X86_TUNE_PREFER_KNOWN_REP_MOVSB_STOSB: Enable use of REP MOVSB/STOSB to\n+   move/set sequences of bytes with known size.  */\n+DEF_TUNE (X86_TUNE_PREFER_KNOWN_REP_MOVSB_STOSB,\n+\t  \"prefer_known_rep_movsb_stosb\",\n+\t  m_CANNONLAKE | m_ICELAKE_CLIENT | m_ICELAKE_SERVER | m_TIGERLAKE\n+\t  | m_ALDERLAKE | m_SAPPHIRERAPIDS)\n+\n /* X86_TUNE_MISALIGNED_MOVE_STRING_PRO_EPILOGUES: Enable generation of\n    compact prologues and epilogues by issuing a misaligned moves.  This\n    requires target to handle misaligned moves and partial memory stalls"}, {"sha": "83c333b551d294cd7b96298e603aaa0ec7945997", "filename": "gcc/testsuite/gcc.target/i386/memcpy-strategy-5.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-5.c?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=tigerlake -mno-sse\" } */\n+/* { dg-final { scan-assembler \"jmp\\tmemcpy\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"call\\tmemcpy\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"rep movsb\" } } */\n+\n+void\n+foo (char *dest, char *src)\n+{\n+  __builtin_memcpy (dest, src, 257);\n+}"}, {"sha": "ed963dec853fb1071c1b42e200156521ac33b798", "filename": "gcc/testsuite/gcc.target/i386/memcpy-strategy-6.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-6.c?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mtune=generic\" } */\n+/* { dg-final { scan-assembler-not \"jmp\\tmemcpy\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"call\\tmemcpy\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"rep movsb\" } } */\n+\n+typedef unsigned char e_u8;\n+\n+#define MAXBC 8\n+\n+void MixColumn(e_u8 a[4][MAXBC], e_u8 BC)\n+{\n+  e_u8 b[4][MAXBC];\n+  int i, j;\n+\n+  for(i = 0; i < 4; i++)\n+    for(j = 0; j < BC; j++) a[i][j] = b[i][j];\n+}"}, {"sha": "be66d6b8426f42c757ceb1e722efa442c15528f8", "filename": "gcc/testsuite/gcc.target/i386/memcpy-strategy-7.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-7.c?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=tigerlake -mno-sse\" } */\n+/* { dg-final { scan-assembler \"rep movsb\" } } */\n+\n+void\n+foo (char *dest, char *src)\n+{\n+  __builtin_memcpy (dest, src, 256);\n+}"}, {"sha": "e8fe0a66c98339256366dd9fe2ce6870369047ea", "filename": "gcc/testsuite/gcc.target/i386/memcpy-strategy-8.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-strategy-8.c?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=tigerlake\" } */\n+/* { dg-final { scan-assembler-not \"jmp\\tmemcpy\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"call\\tmemcpy\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"rep movsb\" } } */\n+\n+typedef unsigned char e_u8;\n+\n+#define MAXBC 8\n+\n+void MixColumn(e_u8 a[4][MAXBC], e_u8 BC)\n+{\n+  e_u8 b[4][MAXBC];\n+  int i, j;\n+\n+  for(i = 0; i < 4; i++)\n+    for(j = 0; j < BC; j++) a[i][j] = b[i][j];\n+}"}, {"sha": "9ea1e1ae7c2b5503ee3993b99343c752fc43eb1e", "filename": "gcc/testsuite/gcc.target/i386/memset-strategy-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-3.c?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mtune=generic\" } */\n+/* { dg-final { scan-assembler-not \"jmp\\tmemset\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"call\\tmemset\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"rep stosb\" } } */\n+\n+typedef unsigned char e_u8;\n+\n+#define MAXBC 8\n+\n+void MixColumn(e_u8 a[4][MAXBC], e_u8 BC)\n+{\n+  int i, j;\n+\n+  for(i = 0; i < 4; i++)\n+    for(j = 0; j < BC; j++) a[i][j] = 1;\n+}"}, {"sha": "00d82f13ff801e374a7d48030a80825edbf72790", "filename": "gcc/testsuite/gcc.target/i386/memset-strategy-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-4.c?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=tigerlake\" } */\n+/* { dg-final { scan-assembler-not \"jmp\\tmemset\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"call\\tmemset\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"rep stosb\" } } */\n+\n+typedef unsigned char e_u8;\n+\n+#define MAXBC 8\n+\n+void MixColumn(e_u8 a[4][MAXBC], e_u8 BC)\n+{\n+  int i, j;\n+\n+  for(i = 0; i < 4; i++)\n+    for(j = 0; j < BC; j++) a[i][j] = 1;\n+}"}, {"sha": "dc1de8e79c213dd151a841a1e01c87d8b5e75058", "filename": "gcc/testsuite/gcc.target/i386/memset-strategy-5.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-5.c?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=tigerlake -mno-sse\" } */\n+/* { dg-final { scan-assembler \"jmp\\tmemset\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"call\\tmemset\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"rep stosb\" } } */\n+\n+void\n+foo (char *dest)\n+{\n+  __builtin_memset (dest, 0, 257);\n+}"}, {"sha": "e51af3b730fc235a92b0a414b8b8cdf08c5979b3", "filename": "gcc/testsuite/gcc.target/i386/memset-strategy-6.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf24f4ec73b65454ea0edcd6ab5616f04958d41e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-strategy-6.c?ref=bf24f4ec73b65454ea0edcd6ab5616f04958d41e", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=tigerlake -mno-sse\" } */\n+/* { dg-final { scan-assembler \"rep stosb\" } } */\n+\n+void\n+foo (char *dest)\n+{\n+  __builtin_memset (dest, 0, 256);\n+}"}]}