{"sha": "3be57c5600901c958769daf63d88264249afee7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JlNTdjNTYwMDkwMWM5NTg3NjlkYWY2M2Q4ODI2NDI0OWFmZWU3Yw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-05T11:51:22Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-05T11:51:22Z"}, "message": "tree-loop-distribution.c (bb_top_order_index): New.\n\n\t* tree-loop-distribution.c (bb_top_order_index): New.\n\t(bb_top_order_index_size, bb_top_order_cmp): New.\n\t(stmts_from_loop): Use topological order.\n\t(pass_loop_distribution::execute): Compute and release topological\n\torder for basic blocks.\n\nFrom-SVN: r249985", "tree": {"sha": "f56d41b17137857818e93ae7a0944c7632a8c3a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f56d41b17137857818e93ae7a0944c7632a8c3a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3be57c5600901c958769daf63d88264249afee7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3be57c5600901c958769daf63d88264249afee7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3be57c5600901c958769daf63d88264249afee7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3be57c5600901c958769daf63d88264249afee7c/comments", "author": null, "committer": null, "parents": [{"sha": "773d92175e93bbd071ed83cf5d043b9e44bcabb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/773d92175e93bbd071ed83cf5d043b9e44bcabb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/773d92175e93bbd071ed83cf5d043b9e44bcabb0"}], "stats": {"total": 66, "additions": 60, "deletions": 6}, "files": [{"sha": "49bacf55c1fff0b036aefac749b1fa14040806fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3be57c5600901c958769daf63d88264249afee7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3be57c5600901c958769daf63d88264249afee7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3be57c5600901c958769daf63d88264249afee7c", "patch": "@@ -1,3 +1,11 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-loop-distribution.c (bb_top_order_index): New.\n+\t(bb_top_order_index_size, bb_top_order_cmp): New.\n+\t(stmts_from_loop): Use topological order.\n+\t(pass_loop_distribution::execute): Compute and release topological\n+\torder for basic blocks.\n+\n 2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-loop-distribution.c (pass_loop_distribution::execute): Skip"}, {"sha": "887e8702589429c6c3f166a3e906d99e35f2c7c9", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3be57c5600901c958769daf63d88264249afee7c/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3be57c5600901c958769daf63d88264249afee7c/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=3be57c5600901c958769daf63d88264249afee7c", "patch": "@@ -373,16 +373,39 @@ create_rdg_vertices (struct graph *rdg, vec<gimple *> stmts, loop_p loop,\n   return true;\n }\n \n-/* Initialize STMTS with all the statements of LOOP.  The order in\n-   which we discover statements is important as\n-   generate_loops_for_partition is using the same traversal for\n-   identifying statements in loop copies.  */\n+/* Array mapping basic block's index to its topological order.  */\n+static int *bb_top_order_index;\n+/* And size of the array.  */\n+static int bb_top_order_index_size;\n+\n+/* If X has a smaller topological sort number than Y, returns -1;\n+   if greater, returns 1.  */\n+\n+static int\n+bb_top_order_cmp (const void *x, const void *y)\n+{\n+  basic_block bb1 = *(const basic_block *) x;\n+  basic_block bb2 = *(const basic_block *) y;\n+\n+  gcc_assert (bb1->index < bb_top_order_index_size\n+\t      && bb2->index < bb_top_order_index_size);\n+  gcc_assert (bb1 == bb2\n+\t      || bb_top_order_index[bb1->index]\n+\t\t != bb_top_order_index[bb2->index]);\n+\n+  return (bb_top_order_index[bb1->index] - bb_top_order_index[bb2->index]);\n+}\n+\n+/* Initialize STMTS with all the statements of LOOP.  We use topological\n+   order to discover all statements.  The order is important because\n+   generate_loops_for_partition is using the same traversal for identifying\n+   statements in loop copies.  */\n \n static void\n stmts_from_loop (struct loop *loop, vec<gimple *> *stmts)\n {\n   unsigned int i;\n-  basic_block *bbs = get_loop_body_in_dom_order (loop);\n+  basic_block *bbs = get_loop_body_in_custom_order (loop, bb_top_order_cmp);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n@@ -1761,6 +1784,22 @@ pass_loop_distribution::execute (function *fun)\n   if (number_of_loops (fun) <= 1)\n     return 0;\n \n+  /* Compute topological order for basic blocks.  Topological order is\n+     needed because data dependence is computed for data references in\n+     lexicographical order.  */\n+  if (bb_top_order_index == NULL)\n+    {\n+      int *rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+\n+      bb_top_order_index = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+      bb_top_order_index_size\n+\t= pre_and_rev_post_order_compute_fn (cfun, NULL, rpo, true);\n+      for (int i = 0; i < bb_top_order_index_size; i++)\n+\tbb_top_order_index[rpo[i]] = i;\n+\n+      free (rpo);\n+    }\n+\n   FOR_ALL_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator gsi;\n@@ -1868,13 +1907,20 @@ pass_loop_distribution::execute (function *fun)\n   if (cd)\n     delete cd;\n \n+  if (bb_top_order_index != NULL)\n+    {\n+      free (bb_top_order_index);\n+      bb_top_order_index = NULL;\n+      bb_top_order_index_size = 0;\n+    }\n+\n   if (changed)\n     {\n       /* Destroy loop bodies that could not be reused.  Do this late as we\n \t otherwise can end up refering to stale data in control dependences.  */\n       unsigned i;\n       FOR_EACH_VEC_ELT (loops_to_be_destroyed, i, loop)\n-\t  destroy_loop (loop);\n+\tdestroy_loop (loop);\n \n       /* Cached scalar evolutions now may refer to wrong or non-existing\n \t loops.  */"}]}