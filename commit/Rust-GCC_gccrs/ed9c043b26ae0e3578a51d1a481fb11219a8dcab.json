{"sha": "ed9c043b26ae0e3578a51d1a481fb11219a8dcab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ5YzA0M2IyNmFlMGUzNTc4YTUxZDFhNDgxZmIxMTIxOWE4ZGNhYg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-05-12T19:41:10Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-05-12T19:41:10Z"}, "message": "tree-ssa-loop-im.c (struct mem_ref): Add field \"next\".\n\n\t* tree-ssa-loop-im.c (struct mem_ref): Add field \"next\".\n\t(struct hmr_data, hoist_memory_reference, memref_del,\n\tstruct fmrv_data): Removed.\n\t(hoist_memory_references, free_mem_ref, free_mem_refs): New functions.\n\t(gather_mem_refs, gather_mem_refs_stmt): Add new references to the\n\tlist.\n\t(find_more_ref_vops): Traverse the list of memory references.\n\t(determine_lsm_loop): Work with the list of memory references instead\n\tof traversing the hashtable.\n\nFrom-SVN: r99627", "tree": {"sha": "53f7cb67f549b178dd2eec38caa2b53ec19db573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53f7cb67f549b178dd2eec38caa2b53ec19db573"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed9c043b26ae0e3578a51d1a481fb11219a8dcab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9c043b26ae0e3578a51d1a481fb11219a8dcab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed9c043b26ae0e3578a51d1a481fb11219a8dcab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9c043b26ae0e3578a51d1a481fb11219a8dcab/comments", "author": null, "committer": null, "parents": [{"sha": "dbaef7e22b947b3b8aaa226d6dbc4bb05a6c40de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbaef7e22b947b3b8aaa226d6dbc4bb05a6c40de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbaef7e22b947b3b8aaa226d6dbc4bb05a6c40de"}], "stats": {"total": 169, "additions": 93, "deletions": 76}, "files": [{"sha": "2a0bfe0db15c4fa421e98cc2a1b2113a669c8375", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c043b26ae0e3578a51d1a481fb11219a8dcab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c043b26ae0e3578a51d1a481fb11219a8dcab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed9c043b26ae0e3578a51d1a481fb11219a8dcab", "patch": "@@ -1,3 +1,15 @@\n+2005-05-12  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-im.c (struct mem_ref): Add field \"next\".\n+\t(struct hmr_data, hoist_memory_reference, memref_del,\n+\tstruct fmrv_data): Removed.\n+\t(hoist_memory_references, free_mem_ref, free_mem_refs): New functions.\n+\t(gather_mem_refs, gather_mem_refs_stmt): Add new references to the\n+\tlist.\n+\t(find_more_ref_vops): Traverse the list of memory references.\n+\t(determine_lsm_loop): Work with the list of memory references instead\n+\tof traversing the hashtable.\n+\n 2005-05-12  Steven Bosscher  <stevenb@suse.de>\n \t    Stuart Hastings <stuart@apple.com>\n \t    Jan Hubicka  <jh@suse.cz>"}, {"sha": "26244ce2aeed074a11212bda992e668b08e33bcf", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 81, "deletions": 76, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c043b26ae0e3578a51d1a481fb11219a8dcab/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c043b26ae0e3578a51d1a481fb11219a8dcab/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=ed9c043b26ae0e3578a51d1a481fb11219a8dcab", "patch": "@@ -124,6 +124,13 @@ struct mem_ref\n   struct mem_ref_loc *locs;\t/* The locations where it is found.  */\n   bitmap vops;\t\t\t/* Vops corresponding to this memory\n \t\t\t\t   location.  */\n+  struct mem_ref *next;\t\t/* Next memory reference in the list.\n+\t\t\t\t   Memory references are stored in a hash\n+\t\t\t\t   table, but the hash function depends\n+\t\t\t\t   on values of pointers. Thus we cannot use\n+\t\t\t\t   htab_traverse, since then we would get\n+\t\t\t\t   misscompares during bootstrap (although the\n+\t\t\t\t   produced code would be correct).  */\n };\n \n /* Minimum cost of an expensive expression.  */\n@@ -1018,28 +1025,18 @@ determine_lsm_ref (struct loop *loop, edge *exits, unsigned n_exits,\n   schedule_sm (loop, exits, n_exits, ref->mem, ref->locs);\n }\n \n-/* Attempts to hoist memory reference described in SLOT out of loop\n-   described in DATA.  Callback for htab_traverse.  */\n+/* Hoists memory references MEM_REFS out of LOOP.  CLOBBERED_VOPS is the list\n+   of vops clobbered by call in loop or accessed by multiple memory references.\n+   EXITS is the list of N_EXITS exit edges of the LOOP.  */\n \n-struct hmr_data\n-{\n-  struct loop *loop;\t/* Loop from that the reference should be hoisted.  */\n-  edge *exits;\t\t/* Exits of the loop.  */\n-  unsigned n_exits;\t/* Length of the exits array.  */\n-  bitmap clobbered_vops;/* The vops clobbered by call in loop or accessed by\n-\t\t\t   multiple memory references.  */\n-};\n-\n-static int\n-hoist_memory_reference (void **slot, void *data)\n+static void\n+hoist_memory_references (struct loop *loop, struct mem_ref *mem_refs,\n+\t\t\t bitmap clobbered_vops, edge *exits, unsigned n_exits)\n {\n-  struct mem_ref *ref = *slot;\n-  struct hmr_data *hmr_data = data;\n+  struct mem_ref *ref;\n \n-  determine_lsm_ref (hmr_data->loop, hmr_data->exits, hmr_data->n_exits,\n-\t\t     hmr_data->clobbered_vops, ref);\n-\n-  return 1;\n+  for (ref = mem_refs; ref; ref = ref->next)\n+    determine_lsm_ref (loop, exits, n_exits, clobbered_vops, ref);\n }\n \n /* Checks whether LOOP (with N_EXITS exits stored in EXITS array) is suitable\n@@ -1080,25 +1077,15 @@ memref_eq (const void *obj1, const void *obj2)\n   return operand_equal_p (mem1->mem, (tree) obj2, 0);\n }\n \n-/* A function to free the struct mem_ref object OBJ.  */\n-\n-static void\n-memref_del (void *obj)\n-{\n-  struct mem_ref *mem = obj;\n-\n-  free_mem_ref_locs (mem->locs);\n-  BITMAP_FREE (mem->vops);\n-  free (mem);\n-}\n-\n /* Gathers memory references in statement STMT in LOOP, storing the\n    information about them in MEM_REFS hash table.  Note vops accessed through\n-   unrecognized statements in CLOBBERED_VOPS.  */\n+   unrecognized statements in CLOBBERED_VOPS.  The newly created references\n+   are also stored to MEM_REF_LIST.  */\n \n static void\n gather_mem_refs_stmt (struct loop *loop, htab_t mem_refs,\n-\t\t      bitmap clobbered_vops, tree stmt)\n+\t\t      bitmap clobbered_vops, tree stmt,\n+\t\t      struct mem_ref **mem_ref_list)\n {\n   tree *lhs, *rhs, *mem = NULL;\n   hashval_t hash;\n@@ -1157,6 +1144,8 @@ gather_mem_refs_stmt (struct loop *loop, htab_t mem_refs,\n       ref->locs = NULL;\n       ref->is_stored = false;\n       ref->vops = BITMAP_ALLOC (NULL);\n+      ref->next = *mem_ref_list;\n+      *mem_ref_list = ref;\n       *slot = ref;\n     }\n   ref->is_stored |= is_stored;\n@@ -1179,53 +1168,80 @@ gather_mem_refs_stmt (struct loop *loop, htab_t mem_refs,\n     }\n }\n \n-/* Gathers memory references in LOOP, storing the information about them\n-   in MEM_REFS hash table.  Note vops accessed through unrecognized\n-   statements in CLOBBERED_VOPS.  */\n+/* Gathers memory references in LOOP.  Notes vops accessed through unrecognized\n+   statements in CLOBBERED_VOPS.  The list of the references found by\n+   the function is returned.  */\n \n-static void\n-gather_mem_refs (struct loop *loop, htab_t mem_refs, bitmap clobbered_vops)\n+static struct mem_ref *\n+gather_mem_refs (struct loop *loop, bitmap clobbered_vops)\n {\n   basic_block *body = get_loop_body (loop);\n   block_stmt_iterator bsi;\n   unsigned i;\n+  struct mem_ref *mem_ref_list = NULL;\n+  htab_t mem_refs = htab_create (100, memref_hash, memref_eq, NULL);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       for (bsi = bsi_start (body[i]); !bsi_end_p (bsi); bsi_next (&bsi))\n-\tgather_mem_refs_stmt (loop, mem_refs, clobbered_vops, bsi_stmt (bsi));\n+\tgather_mem_refs_stmt (loop, mem_refs, clobbered_vops, bsi_stmt (bsi),\n+\t\t\t      &mem_ref_list);\n     }\n \n   free (body);\n+\n+  htab_delete (mem_refs);\n+  return mem_ref_list;\n }\n \n-/* Finds the vops accessed by memory reference described in SLOT as well as\n-   some other reference(s) and marks them in DATA->clobbered_vops.\n-   Callback for htab_traverse.  */\n+/* Finds the vops accessed by more than one of the memory references described\n+   in MEM_REFS and marks them in CLOBBERED_VOPS.  */\n \n-struct fmrv_data\n+static void\n+find_more_ref_vops (struct mem_ref *mem_refs, bitmap clobbered_vops)\n {\n-  bitmap clobbered_vops;\t/* The vops clobbered by call in loop or accessed by\n-\t\t\t   multiple memory references.  */\n-  bitmap all_vops;\t/* All vops referenced in the loop.  */\n-};\n+  bitmap_head tmp, all_vops;\n+  struct mem_ref *ref;\n \n-static int\n-find_more_ref_vops (void **slot, void *data)\n+  bitmap_initialize (&tmp, &bitmap_default_obstack);\n+  bitmap_initialize (&all_vops, &bitmap_default_obstack);\n+\n+  for (ref = mem_refs; ref; ref = ref->next)\n+    {\n+      /* The vops that are already in all_vops are accessed by more than\n+\t one memory reference.  */\n+      bitmap_and (&tmp, &all_vops, ref->vops);\n+      bitmap_ior_into (clobbered_vops, &tmp);\n+      bitmap_clear (&tmp);\n+\n+      bitmap_ior_into (&all_vops, ref->vops);\n+    }\n+\n+  bitmap_clear (&all_vops);\n+}\n+\n+/* Releases the memory occupied by REF.  */\n+\n+static void\n+free_mem_ref (struct mem_ref *ref)\n {\n-  struct mem_ref *ref = *slot;\n-  struct fmrv_data *fmrv_data = data;\n-  bitmap_head tmp;\n+  free_mem_ref_locs (ref->locs);\n+  BITMAP_FREE (ref->vops);\n+  free (ref);\n+}\n \n-  /* The vops that are already in all_vops are accessed by more than\n-     one memory reference.  */\n-  bitmap_initialize (&tmp, &bitmap_default_obstack);\n-  bitmap_and (&tmp, fmrv_data->all_vops, ref->vops);\n-  bitmap_ior_into (fmrv_data->clobbered_vops, &tmp);\n-  bitmap_clear (&tmp);\n+/* Releases the memory occupied by REFS.  */\n+\n+static void\n+free_mem_refs (struct mem_ref *refs)\n+{\n+  struct mem_ref *ref, *next;\n \n-  bitmap_ior_into (fmrv_data->all_vops, ref->vops);\n-  return 1;\n+  for (ref = refs; ref; ref = next)\n+    {\n+      next = ref->next;\n+      free_mem_ref (ref);\n+    }\n }\n \n /* Try to perform store motion for all memory references modified inside\n@@ -1236,37 +1252,26 @@ determine_lsm_loop (struct loop *loop)\n {\n   unsigned n_exits;\n   edge *exits = get_loop_exit_edges (loop, &n_exits);\n-  htab_t mem_refs;\n-  struct hmr_data hmr_data;\n-  struct fmrv_data fmrv_data;\n   bitmap clobbered_vops;\n+  struct mem_ref *mem_refs;\n \n   if (!loop_suitable_for_sm (loop, exits, n_exits))\n     {\n       free (exits);\n       return;\n     }\n \n-  mem_refs = htab_create (100, memref_hash, memref_eq, memref_del);\n-\n   /* Find the memory references in LOOP.  */\n   clobbered_vops = BITMAP_ALLOC (NULL);\n-  gather_mem_refs (loop, mem_refs, clobbered_vops);\n+  mem_refs = gather_mem_refs (loop, clobbered_vops);\n \n   /* Find the vops that are used for more than one reference.  */\n-  fmrv_data.all_vops = BITMAP_ALLOC (NULL);\n-  fmrv_data.clobbered_vops = clobbered_vops;\n-  htab_traverse (mem_refs, find_more_ref_vops, &fmrv_data);\n-  BITMAP_FREE (fmrv_data.all_vops);\n+  find_more_ref_vops (mem_refs, clobbered_vops);\n \n   /* Hoist all suitable memory references.  */\n-  hmr_data.loop = loop;\n-  hmr_data.exits = exits;\n-  hmr_data.n_exits = n_exits;\n-  hmr_data.clobbered_vops = clobbered_vops;\n-  htab_traverse (mem_refs, hoist_memory_reference, &hmr_data);\n+  hoist_memory_references (loop, mem_refs, clobbered_vops, exits, n_exits);\n \n-  htab_delete (mem_refs);\n+  free_mem_refs (mem_refs);\n   free (exits);\n   BITMAP_FREE (clobbered_vops);\n }"}]}