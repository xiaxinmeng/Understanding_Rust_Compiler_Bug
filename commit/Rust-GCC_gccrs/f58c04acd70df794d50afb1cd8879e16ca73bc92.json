{"sha": "f58c04acd70df794d50afb1cd8879e16ca73bc92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU4YzA0YWNkNzBkZjc5NGQ1MGFmYjFjZDg4NzllMTZjYTczYmM5Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-02-22T21:46:06Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-02-22T21:46:06Z"}, "message": "mangle.c (write_encoding): Pass write_function_type the FUNCTION_DECL for the function being encoded.\n\n\t* mangle.c (write_encoding): Pass write_function_type the\n\tFUNCTION_DECL for the function being encoded.\n\t(write_function_type): Pass it along to write_bare_function_type.\n\t(write_bare_function_type): Pass it along to write_method_parms.\n\t(write_method_parms): Don't mangle the compiler-generated\n\tparameters to a constructor or destructor.\n\nFrom-SVN: r39985", "tree": {"sha": "d70002c227d31ea58a034c1d945755f80f550a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d70002c227d31ea58a034c1d945755f80f550a52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f58c04acd70df794d50afb1cd8879e16ca73bc92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f58c04acd70df794d50afb1cd8879e16ca73bc92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f58c04acd70df794d50afb1cd8879e16ca73bc92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f58c04acd70df794d50afb1cd8879e16ca73bc92/comments", "author": null, "committer": null, "parents": [{"sha": "3844cd2e43cc40dbbaedc6e900be59ad5f4b3cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3844cd2e43cc40dbbaedc6e900be59ad5f4b3cfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3844cd2e43cc40dbbaedc6e900be59ad5f4b3cfc"}], "stats": {"total": 74, "additions": 52, "deletions": 22}, "files": [{"sha": "26899a55a9e7e591dede16fe1f62ef0a4c5727f3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f58c04acd70df794d50afb1cd8879e16ca73bc92/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f58c04acd70df794d50afb1cd8879e16ca73bc92/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f58c04acd70df794d50afb1cd8879e16ca73bc92", "patch": "@@ -1,3 +1,12 @@\n+2001-02-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* mangle.c (write_encoding): Pass write_function_type the\n+\tFUNCTION_DECL for the function being encoded.\n+\t(write_function_type): Pass it along to write_bare_function_type.\n+\t(write_bare_function_type): Pass it along to write_method_parms.\n+\t(write_method_parms): Don't mangle the compiler-generated\n+\tparameters to a constructor or destructor.\n+\n 2001-02-22  Andreas Jaeger  <aj@suse.de>\n \n \t* optimize.c: Include toplev.h for"}, {"sha": "6736d1e674302e9c3bd5eeef2950563877e6c2ea", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f58c04acd70df794d50afb1cd8879e16ca73bc92/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f58c04acd70df794d50afb1cd8879e16ca73bc92/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=f58c04acd70df794d50afb1cd8879e16ca73bc92", "patch": "@@ -163,8 +163,8 @@ static void write_type PARAMS ((tree));\n static int write_CV_qualifiers_for_type PARAMS ((tree));\n static void write_builtin_type PARAMS ((tree));\n static void write_function_type PARAMS ((tree));\n-static void write_bare_function_type PARAMS ((tree, int));\n-static void write_method_parms PARAMS ((tree, int));\n+static void write_bare_function_type PARAMS ((tree, int, tree));\n+static void write_method_parms PARAMS ((tree, int, tree));\n static void write_class_enum_type PARAMS ((tree));\n static void write_template_args PARAMS ((tree));\n static void write_expression PARAMS ((tree));\n@@ -653,7 +653,8 @@ write_encoding (decl)\n \t\t\t\t(!DECL_CONSTRUCTOR_P (decl)\n \t\t\t\t && !DECL_DESTRUCTOR_P (decl)\n \t\t\t\t && !DECL_CONV_FN_P (decl)\n-\t\t\t\t && decl_is_template_id (decl, NULL)));\n+\t\t\t\t && decl_is_template_id (decl, NULL)),\n+\t\t\t\tdecl);\n     }\n }\n \n@@ -1530,20 +1531,23 @@ write_function_type (type)\n        extern \"C\" function_t f; // Vice versa.\n \n      See [dcl.link].  */\n-  write_bare_function_type (type, /*include_return_type_p=*/1);\n+  write_bare_function_type (type, /*include_return_type_p=*/1, \n+\t\t\t    /*decl=*/NULL);\n   write_char ('E');\n }\n \n-/* Non-terminal <bare-function-type>.  NODE is a FUNCTION_DECL or a\n+/* Non-terminal <bare-function-type>.  TYPE is a FUNCTION_TYPE or\n    METHOD_TYPE.  If INCLUDE_RETURN_TYPE is non-zero, the return value\n-   is mangled before the parameter types.\n+   is mangled before the parameter types.  If non-NULL, DECL is\n+   FUNCTION_DECL for the function whose type is being emitted.\n \n      <bare-function-type> ::= </signature/ type>+  */\n \n static void\n-write_bare_function_type (type, include_return_type_p)\n+write_bare_function_type (type, include_return_type_p, decl)\n      tree type;\n      int include_return_type_p;\n+     tree decl;\n {\n   MANGLE_TRACE_TREE (\"bare-function-type\", type);\n \n@@ -1553,48 +1557,65 @@ write_bare_function_type (type, include_return_type_p)\n \n   /* Now mangle the types of the arguments.  */\n   write_method_parms (TYPE_ARG_TYPES (type), \n-\t\t      TREE_CODE (type) == METHOD_TYPE);\n+\t\t      TREE_CODE (type) == METHOD_TYPE,\n+\t\t      decl);\n }\n \n /* Write the mangled representation of a method parameter list of\n-   types given in PARM_LIST.  If METHOD_P is non-zero, the function is \n-   considered a non-static method, and the this parameter is omitted.  */\n+   types given in PARM_TYPES.  If METHOD_P is non-zero, the function is \n+   considered a non-static method, and the this parameter is omitted.\n+   If non-NULL, DECL is the FUNCTION_DECL for the function whose\n+   parameters are being emitted.  */\n \n static void\n-write_method_parms (parm_list, method_p)\n-     tree parm_list;\n+write_method_parms (parm_types, method_p, decl)\n+     tree decl;\n+     tree parm_types;\n      int method_p;\n {\n-  tree first_parm;\n+  tree first_parm_type;\n+  tree parm_decl = decl ? DECL_ARGUMENTS (decl) : NULL_TREE;\n+\n   /* Assume this parameter type list is variable-length.  If it ends\n      with a void type, then it's not.  */\n   int varargs_p = 1;\n \n   /* If this is a member function, skip the first arg, which is the\n      this pointer.  \n        \"Member functions do not encode the type of their implicit this\n-       parameter.\"  */\n+       parameter.\"  \n+  \n+     Similarly, there's no need to mangle artificial parameters, like\n+     the VTT parameters for constructors and destructors.  */\n   if (method_p)\n-    parm_list = TREE_CHAIN (parm_list);\n-\n-  for (first_parm = parm_list; \n-       parm_list; \n-       parm_list = TREE_CHAIN (parm_list))\n     {\n-      tree parm = TREE_VALUE (parm_list);\n+      parm_types = TREE_CHAIN (parm_types);\n+      parm_decl = parm_decl ? TREE_CHAIN (parm_decl) : NULL_TREE;\n \n+      while (parm_decl && DECL_ARTIFICIAL (parm_decl))\n+\t{\n+\t  parm_types = TREE_CHAIN (parm_types);\n+\t  parm_decl = TREE_CHAIN (parm_decl);\n+\t}\n+    }\n+\n+  for (first_parm_type = parm_types; \n+       parm_types; \n+       parm_types = TREE_CHAIN (parm_types))\n+    {\n+      tree parm = TREE_VALUE (parm_types);\n       if (parm == void_type_node)\n \t{\n \t  /* \"Empty parameter lists, whether declared as () or\n \t     conventionally as (void), are encoded with a void parameter\n \t     (v).\"  */\n-\t  if (parm_list == first_parm)\n+\t  if (parm_types == first_parm_type)\n \t    write_type (parm);\n \t  /* If the parm list is terminated with a void type, it's\n \t     fixed-length.  */\n \t  varargs_p = 0;\n \t  /* A void type better be the last one.  */\n-\t  my_friendly_assert (TREE_CHAIN (parm_list) == NULL, 20000523);\n+\t  my_friendly_assert (TREE_CHAIN (parm_types) == NULL, 20000523);\n \t}\n       else\n \twrite_type (parm);"}]}