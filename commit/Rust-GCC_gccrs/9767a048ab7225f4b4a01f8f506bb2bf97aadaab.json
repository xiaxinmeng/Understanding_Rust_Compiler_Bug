{"sha": "9767a048ab7225f4b4a01f8f506bb2bf97aadaab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc2N2EwNDhhYjcyMjVmNGI0YTAxZjhmNTA2YmIyYmY5N2FhZGFhYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-04-08T23:58:31Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-04-08T23:58:31Z"}, "message": "hashtable.h (erase): Correctly handle erasing a reference to an entry in the hash table.\n\n\t* include/backward/hashtable.h (erase): Correctly handle erasing a\n\treference to an entry in the hash table.\n\t* testsuite/backward/hash_map/25896.cc: New.\n\t* testsuite/backward/hash_set/25896.cc: New.\n\nFrom-SVN: r145788", "tree": {"sha": "9eda1fdbd680a5746db750c5fe831efce5cbd3ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9eda1fdbd680a5746db750c5fe831efce5cbd3ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9767a048ab7225f4b4a01f8f506bb2bf97aadaab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9767a048ab7225f4b4a01f8f506bb2bf97aadaab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9767a048ab7225f4b4a01f8f506bb2bf97aadaab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9767a048ab7225f4b4a01f8f506bb2bf97aadaab/comments", "author": null, "committer": null, "parents": [{"sha": "0b83c44bdf9431f7933eb8aa28f9a33efe453722", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b83c44bdf9431f7933eb8aa28f9a33efe453722", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b83c44bdf9431f7933eb8aa28f9a33efe453722"}], "stats": {"total": 358, "additions": 352, "deletions": 6}, "files": [{"sha": "831de204fb47c2db176ad6ea92453eadcd75dbda", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9767a048ab7225f4b4a01f8f506bb2bf97aadaab/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9767a048ab7225f4b4a01f8f506bb2bf97aadaab/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9767a048ab7225f4b4a01f8f506bb2bf97aadaab", "patch": "@@ -1,3 +1,10 @@\n+2009-04-08  Ian Lance Taylor  <iant@google.com>\n+\n+\t* include/backward/hashtable.h (erase): Correctly handle erasing a\n+\treference to an entry in the hash table.\n+\t* testsuite/backward/hash_map/25896.cc: New.\n+\t* testsuite/backward/hash_set/25896.cc: New.\n+\n 2009-04-08  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* config/abi/post/mips64-linux-gnu/baseline_symbols.txt:"}, {"sha": "cfa6f06a913e6d82a1e203c5572a347bdf5063c2", "filename": "libstdc++-v3/include/backward/hashtable.h", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9767a048ab7225f4b4a01f8f506bb2bf97aadaab/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9767a048ab7225f4b4a01f8f506bb2bf97aadaab/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h?ref=9767a048ab7225f4b4a01f8f506bb2bf97aadaab", "patch": "@@ -869,8 +869,9 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     {\n       const size_type __n = _M_bkt_num_key(__key);\n       _Node* __first = _M_buckets[__n];\n+      _Node* __saved_slot = 0;\n       size_type __erased = 0;\n-      \n+\n       if (__first)\n \t{\n \t  _Node* __cur = __first;\n@@ -879,11 +880,20 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t    {\n \t      if (_M_equals(_M_get_key(__next->_M_val), __key))\n \t\t{\n-\t\t  __cur->_M_next = __next->_M_next;\n-\t\t  _M_delete_node(__next);\n-\t\t  __next = __cur->_M_next;\n-\t\t  ++__erased;\n-\t\t  --_M_num_elements;\n+\t\t  if (&_M_get_key(__next->_M_val) != &__key)\n+\t\t    {\n+\t\t      __cur->_M_next = __next->_M_next;\n+\t\t      _M_delete_node(__next);\n+\t\t      __next = __cur->_M_next;\n+\t\t      ++__erased;\n+\t\t      --_M_num_elements;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      __saved_slot = __cur;\n+\t\t      __cur = __next;\n+\t\t      __next = __cur->_M_next;\n+\t\t    }\n \t\t}\n \t      else\n \t\t{\n@@ -898,6 +908,14 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t      ++__erased;\n \t      --_M_num_elements;\n \t    }\n+\t  if (__saved_slot)\n+\t    {\n+\t      __next = __saved_slot->_M_next;\n+\t      __saved_slot->_M_next = __next->_M_next;\n+\t      _M_delete_node(__next);\n+\t      ++__erased;\n+\t      --_M_num_elements;\n+\t    }\n \t}\n       return __erased;\n     }"}, {"sha": "e7d1f84837d69712b002afbb2e84d39f5edfa53c", "filename": "libstdc++-v3/testsuite/backward/hash_map/25896.cc", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9767a048ab7225f4b4a01f8f506bb2bf97aadaab/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F25896.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9767a048ab7225f4b4a01f8f506bb2bf97aadaab/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F25896.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_map%2F25896.cc?ref=9767a048ab7225f4b4a01f8f506bb2bf97aadaab", "patch": "@@ -0,0 +1,161 @@\n+// { dg-options \"-Wno-deprecated\" }\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// This is a copy of tr1/6_containers/unordered_map/erase/1.cc, using\n+// hash_map instead of unordered_map.\n+\n+#include <hash_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+namespace __gnu_cxx\n+{\n+  using std::string;\n+\n+  inline size_t hash_string(const char* s)\n+  {\n+    unsigned long h;\n+    for (h=0; *s; ++s) {\n+      h = 5*h + *s;\n+    }\n+    return size_t(h);\n+  }\n+\n+  template<class T> struct hash<T *>\n+  {\n+    size_t operator()(const T *const & s) const\n+      { return reinterpret_cast<size_t>(s); }\n+  };\n+\n+  template<> struct hash<string>\n+  {\n+    size_t operator()(const string &s) const { return hash_string(s.c_str()); }\n+  };\n+\n+  template<> struct hash<const string>\n+  {\n+    size_t operator()(const string &s) const { return hash_string(s.c_str()); }\n+  };\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_cxx::hash_map<std::string, int> Map;\n+  typedef Map::iterator       iterator;\n+  typedef Map::const_iterator const_iterator;\n+  typedef Map::value_type     value_type;\n+\n+  Map m1;\n+\n+  m1.insert(value_type(\"because to why\", 1));\n+  m1.insert(value_type(\"the stockholm syndrome\", 2));\n+  m1.insert(value_type(\"a cereous night\", 3));\n+  m1.insert(value_type(\"eeilo\", 4));\n+  m1.insert(value_type(\"protean\", 5));\n+  m1.insert(value_type(\"the way you are when\", 6));\n+  m1.insert(value_type(\"tillsammans\", 7));\n+  m1.insert(value_type(\"umbra/penumbra\", 8));\n+  m1.insert(value_type(\"belonging (no longer mix)\", 9));\n+  m1.insert(value_type(\"one line behind\", 10));\n+  VERIFY( m1.size() == 10 );\n+\n+  VERIFY( m1.erase(\"eeilo\") == 1 );\n+  VERIFY( m1.size() == 9 );\n+  iterator it1 = m1.find(\"eeilo\");\n+  VERIFY( it1 == m1.end() );\n+\n+  VERIFY( m1.erase(\"tillsammans\") == 1 );\n+  VERIFY( m1.size() == 8 );\n+  iterator it2 = m1.find(\"tillsammans\");\n+  VERIFY( it2 == m1.end() );\n+\n+  // Must work (see DR 526)\n+  iterator it3 = m1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 != m1.end() );\n+  VERIFY( m1.erase(it3->first) == 1 );\n+  VERIFY( m1.size() == 7 );\n+  it3 = m1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 == m1.end() );\n+\n+  VERIFY( !m1.erase(\"abra\") );\n+  VERIFY( m1.size() == 7 );\n+\n+  VERIFY( !m1.erase(\"eeilo\") );\n+  VERIFY( m1.size() == 7 );\n+\n+  VERIFY( m1.erase(\"because to why\") == 1 );\n+  VERIFY( m1.size() == 6 );\n+  iterator it4 = m1.find(\"because to why\");\n+  VERIFY( it4 == m1.end() );\n+\n+  iterator it5 = m1.find(\"umbra/penumbra\");\n+  iterator it6 = m1.find(\"one line behind\");\n+  VERIFY( it5 != m1.end() );\n+  VERIFY( it6 != m1.end() );\n+\n+  VERIFY( m1.find(\"the stockholm syndrome\") != m1.end() );\n+  VERIFY( m1.find(\"a cereous night\") != m1.end() );\n+  VERIFY( m1.find(\"the way you are when\") != m1.end() );\n+  VERIFY( m1.find(\"a cereous night\") != m1.end() );\n+\n+  VERIFY( m1.erase(it5->first) == 1 );\n+  VERIFY( m1.size() == 5 );\n+  it5 = m1.find(\"umbra/penumbra\");\n+  VERIFY( it5 == m1.end() );\n+\n+  VERIFY( m1.erase(it6->first) == 1 );\n+  VERIFY( m1.size() == 4 );\n+  it6 = m1.find(\"one line behind\");\n+  VERIFY( it6 == m1.end() );\n+\n+  iterator it7 = m1.begin();\n+  iterator it8 = it7;\n+  ++it8;\n+  iterator it9 = it8;\n+  ++it9;\n+\n+  VERIFY( m1.erase(it8->first) == 1 );\n+  VERIFY( m1.size() == 3 );\n+  VERIFY( ++it7 == it9 );\n+\n+  iterator it10 = it9;\n+  ++it10;\n+  iterator it11 = it10;\n+\n+  VERIFY( m1.erase(it9->first) == 1 );\n+  VERIFY( m1.size() == 2 );\n+  VERIFY( ++it10 == m1.end() );\n+\n+  m1.erase(m1.begin());\n+  VERIFY( m1.size() == 1 );\n+  VERIFY( m1.begin() == it11 );\n+\n+  VERIFY( m1.erase(m1.begin()->first) == 1 );\n+  VERIFY( m1.size() == 0 );\n+  VERIFY( m1.begin() == m1.end() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "9baa6f1f7d6c656d4d389ce90b612c161dce14b8", "filename": "libstdc++-v3/testsuite/backward/hash_set/25896.cc", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9767a048ab7225f4b4a01f8f506bb2bf97aadaab/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2F25896.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9767a048ab7225f4b4a01f8f506bb2bf97aadaab/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2F25896.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fhash_set%2F25896.cc?ref=9767a048ab7225f4b4a01f8f506bb2bf97aadaab", "patch": "@@ -0,0 +1,160 @@\n+// { dg-options \"-Wno-deprecated\" }\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// This is a copy of tr1/6_containers/unordered_set/erase/1.cc, using\n+// hash_set instead of unordered_set.\n+\n+#include <hash_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+namespace __gnu_cxx\n+{\n+  using std::string;\n+\n+  inline size_t hash_string(const char* s)\n+  {\n+    unsigned long h;\n+    for (h=0; *s; ++s) {\n+      h = 5*h + *s;\n+    }\n+    return size_t(h);\n+  }\n+\n+  template<class T> struct hash<T *>\n+  {\n+    size_t operator()(const T *const & s) const\n+      { return reinterpret_cast<size_t>(s); }\n+  };\n+\n+  template<> struct hash<string>\n+  {\n+    size_t operator()(const string &s) const { return hash_string(s.c_str()); }\n+  };\n+\n+  template<> struct hash<const string>\n+  {\n+    size_t operator()(const string &s) const { return hash_string(s.c_str()); }\n+  };\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef __gnu_cxx::hash_set<std::string> Set;\n+  typedef Set::iterator       iterator;\n+  typedef Set::const_iterator const_iterator;\n+\n+  Set s1;\n+\n+  s1.insert(\"because to why\");\n+  s1.insert(\"the stockholm syndrome\");\n+  s1.insert(\"a cereous night\");\n+  s1.insert(\"eeilo\");\n+  s1.insert(\"protean\");\n+  s1.insert(\"the way you are when\");\n+  s1.insert(\"tillsammans\");\n+  s1.insert(\"umbra/penumbra\");\n+  s1.insert(\"belonging (no longer mix)\");\n+  s1.insert(\"one line behind\");\n+  VERIFY( s1.size() == 10 );\n+\n+  VERIFY( s1.erase(\"eeilo\") == 1 );\n+  VERIFY( s1.size() == 9 );\n+  iterator it1 = s1.find(\"eeilo\");\n+  VERIFY( it1 == s1.end() );\n+\n+  VERIFY( s1.erase(\"tillsammans\") == 1 );\n+  VERIFY( s1.size() == 8 );\n+  iterator it2 = s1.find(\"tillsammans\");\n+  VERIFY( it2 == s1.end() );\n+\n+  // Must work (see DR 526)\n+  iterator it3 = s1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 != s1.end() );\n+  VERIFY( s1.erase(*it3) == 1 );\n+  VERIFY( s1.size() == 7 );\n+  it3 = s1.find(\"belonging (no longer mix)\");\n+  VERIFY( it3 == s1.end() );\n+\n+  VERIFY( !s1.erase(\"abra\") );\n+  VERIFY( s1.size() == 7 );\n+\n+  VERIFY( !s1.erase(\"eeilo\") );\n+  VERIFY( s1.size() == 7 );\n+\n+  VERIFY( s1.erase(\"because to why\") == 1 );\n+  VERIFY( s1.size() == 6 );\n+  iterator it4 = s1.find(\"because to why\");\n+  VERIFY( it4 == s1.end() );\n+\n+  iterator it5 = s1.find(\"umbra/penumbra\");\n+  iterator it6 = s1.find(\"one line behind\");\n+  VERIFY( it5 != s1.end() );\n+  VERIFY( it6 != s1.end() );\n+\n+  VERIFY( s1.find(\"the stockholm syndrome\") != s1.end() );\n+  VERIFY( s1.find(\"a cereous night\") != s1.end() );\n+  VERIFY( s1.find(\"the way you are when\") != s1.end() );\n+  VERIFY( s1.find(\"a cereous night\") != s1.end() );\n+\n+  VERIFY( s1.erase(*it5) == 1 );\n+  VERIFY( s1.size() == 5 );\n+  it5 = s1.find(\"umbra/penumbra\");\n+  VERIFY( it5 == s1.end() );\n+\n+  VERIFY( s1.erase(*it6) == 1 );\n+  VERIFY( s1.size() == 4 );\n+  it6 = s1.find(\"one line behind\");\n+  VERIFY( it6 == s1.end() );\n+\n+  iterator it7 = s1.begin();\n+  iterator it8 = it7;\n+  ++it8;\n+  iterator it9 = it8;\n+  ++it9;\n+\n+  VERIFY( s1.erase(*it8) == 1 );\n+  VERIFY( s1.size() == 3 );\n+  VERIFY( ++it7 == it9 );\n+\n+  iterator it10 = it9;\n+  ++it10;\n+  iterator it11 = it10;\n+\n+  VERIFY( s1.erase(*it9) == 1 );\n+  VERIFY( s1.size() == 2 );\n+  VERIFY( ++it10 == s1.end() );\n+\n+  s1.erase(s1.begin());\n+  VERIFY( s1.size() == 1 );\n+  VERIFY( s1.begin() == it11 );\n+\n+  VERIFY( s1.erase(*s1.begin()) == 1 );\n+  VERIFY( s1.size() == 0 );\n+  VERIFY( s1.begin() == s1.end() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}