{"sha": "e0672441623392903e5cc34bc22116bbd01dfeb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA2NzI0NDE2MjMzOTI5MDNlNWNjMzRiYzIyMTE2YmJkMDFkZmViMg==", "commit": {"author": {"name": "Adam Butcher", "email": "adam@jessamine.co.uk", "date": "2014-03-17T20:02:26Z"}, "committer": {"name": "Adam Butcher", "email": "abutcher@gcc.gnu.org", "date": "2014-03-17T20:02:26Z"}, "message": "re PR c++/60390 ([c++1y] ICE with declaring function with auto parameter as friend)\n\nFix PR c++/60390\n\n\tPR c++/60390\n\t* parser.c (cp_parser_member_declaration): Don't allow\n\tfinish_fully_implicit_template to consider friend declarations to be\n\tclass member templates.\n\t(synthesize_implicit_template_parm): Handling winding back through class\n\tscope to the class being defined in order to inject a template argument\n\tlist.\n\n\tPR c++/60390\n\t* g++.dg/cpp1y/pr60390.C: New testcase.\n\nFrom-SVN: r208625", "tree": {"sha": "5450646a5e8452e3dfb7f016d866c6aa8a69e4f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5450646a5e8452e3dfb7f016d866c6aa8a69e4f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0672441623392903e5cc34bc22116bbd01dfeb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0672441623392903e5cc34bc22116bbd01dfeb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0672441623392903e5cc34bc22116bbd01dfeb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0672441623392903e5cc34bc22116bbd01dfeb2/comments", "author": {"login": "abutcher-gh", "id": 10379705, "node_id": "MDQ6VXNlcjEwMzc5NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/10379705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abutcher-gh", "html_url": "https://github.com/abutcher-gh", "followers_url": "https://api.github.com/users/abutcher-gh/followers", "following_url": "https://api.github.com/users/abutcher-gh/following{/other_user}", "gists_url": "https://api.github.com/users/abutcher-gh/gists{/gist_id}", "starred_url": "https://api.github.com/users/abutcher-gh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abutcher-gh/subscriptions", "organizations_url": "https://api.github.com/users/abutcher-gh/orgs", "repos_url": "https://api.github.com/users/abutcher-gh/repos", "events_url": "https://api.github.com/users/abutcher-gh/events{/privacy}", "received_events_url": "https://api.github.com/users/abutcher-gh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c66f2ba1ba6bf0b3ca6b092ee964461d6c7bb93f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c66f2ba1ba6bf0b3ca6b092ee964461d6c7bb93f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c66f2ba1ba6bf0b3ca6b092ee964461d6c7bb93f"}], "stats": {"total": 79, "additions": 70, "deletions": 9}, "files": [{"sha": "3cf68583fcce305c97c4a68285d5431fe31057d1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0672441623392903e5cc34bc22116bbd01dfeb2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0672441623392903e5cc34bc22116bbd01dfeb2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e0672441623392903e5cc34bc22116bbd01dfeb2", "patch": "@@ -1,5 +1,13 @@\n 2014-03-17  Adam Butcher  <adam@jessamine.co.uk>\n \n+\tPR c++/60390\n+\t* parser.c (cp_parser_member_declaration): Don't allow\n+\tfinish_fully_implicit_template to consider friend declarations to be\n+\tclass member templates.\n+\t(synthesize_implicit_template_parm): Handling winding back through class\n+\tscope to the class being defined in order to inject a template argument\n+\tlist.\n+\n \tPR c++/60391\n \t* parser.c (cp_parser_skip_to_end_of_block_or_statement): Unwind generic\n \tfunction scope as per cp_parser_skip_to_end_of_statement."}, {"sha": "46e2453e51b47c9a2d576f303a1cd5c600a2beaf", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0672441623392903e5cc34bc22116bbd01dfeb2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0672441623392903e5cc34bc22116bbd01dfeb2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e0672441623392903e5cc34bc22116bbd01dfeb2", "patch": "@@ -20527,8 +20527,13 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      decl = grokfield (declarator, &decl_specifiers,\n \t\t\t\tinitializer, /*init_const_expr_p=*/true,\n \t\t\t\tasm_specification, attributes);\n-\t\tif (parser->fully_implicit_function_template_p)\n-\t\t  decl = finish_fully_implicit_template (parser, decl);\n+\t      if (parser->fully_implicit_function_template_p)\n+\t\t{\n+\t\t  if (friend_p)\n+\t\t    finish_fully_implicit_template (parser, 0);\n+\t\t  else\n+\t\t    decl = finish_fully_implicit_template (parser, decl);\n+\t\t}\n \t    }\n \n \t  cp_finalize_omp_declare_simd (parser, decl);\n@@ -31982,13 +31987,32 @@ synthesize_implicit_template_parm  (cp_parser *parser)\n \t  parent_scope = scope;\n \t  scope = scope->level_chain;\n \t}\n-      if (current_class_type && !LAMBDA_TYPE_P (current_class_type)\n-\t  && parser->num_classes_being_defined == 0)\n-\twhile (scope->kind == sk_class)\n-\t  {\n-\t    parent_scope = scope;\n-\t    scope = scope->level_chain;\n-\t  }\n+      if (current_class_type && !LAMBDA_TYPE_P (current_class_type))\n+\t{\n+\t  /* If not defining a class, then any class scope is a scope level in\n+\t     an out-of-line member definition.  In this case simply wind back\n+\t     beyond the first such scope to inject the template argument list.\n+\t     Otherwise wind back to the class being defined.  The latter can\n+\t     occur in class member friend declarations such as:\n+\n+\t       class A {\n+\t\t void foo (auto);\n+\t       };\n+\t       class B {\n+\t\t friend void A::foo (auto);\n+\t       };\n+\n+\t    The template argument list synthesized for the friend declaration\n+\t    must be injected in the scope of 'B', just beyond the scope of 'A'\n+\t    introduced by 'A::'.  */\n+\n+\t  while (scope->kind == sk_class\n+\t\t && !TYPE_BEING_DEFINED (scope->this_entity))\n+\t    {\n+\t      parent_scope = scope;\n+\t      scope = scope->level_chain;\n+\t    }\n+\t}\n \n       current_binding_level = scope;\n "}, {"sha": "49bc00155cba4b4d04a61fa882fd34533fbaa55d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0672441623392903e5cc34bc22116bbd01dfeb2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0672441623392903e5cc34bc22116bbd01dfeb2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e0672441623392903e5cc34bc22116bbd01dfeb2", "patch": "@@ -1,5 +1,8 @@\n 2014-03-17  Adam Butcher  <adam@jessamine.co.uk>\n \n+\tPR c++/60390\n+\t* g++.dg/cpp1y/pr60390.C: New testcase.\n+\n \tPR c++/60391\n \t* g++.dg/cpp1y/pr60391.C: New testcase.\n "}, {"sha": "5cd5539f82e81bb92cd87592ef5fc686d34958d6", "filename": "gcc/testsuite/g++.dg/cpp1y/pr60390.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0672441623392903e5cc34bc22116bbd01dfeb2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr60390.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0672441623392903e5cc34bc22116bbd01dfeb2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr60390.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr60390.C?ref=e0672441623392903e5cc34bc22116bbd01dfeb2", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/60390\n+// { dg-do compile { target c++1y } }\n+// { dg-options \"\" }\n+\n+struct A\n+{\n+  void foo (auto);\n+};\n+\n+class B\n+{\n+  int m;\n+  friend void A::foo (auto);\n+};\n+\n+void A::foo (auto i)\n+{\n+  B b;\n+  b.m = i;\n+}\n+\n+int main ()\n+{\n+  A a;\n+  a.foo (7);\n+}"}]}