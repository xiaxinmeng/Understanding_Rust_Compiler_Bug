{"sha": "db3acfa5476e5af834fee38ad8e1b193a8f018dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIzYWNmYTU0NzZlNWFmODM0ZmVlMzhhZDhlMWIxOTNhOGYwMThkYw==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-12-04T22:55:40Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-12-04T22:55:40Z"}, "message": "re PR c/4787 (Different anonymous variables declared but only one allocated when the initialization is the same)\n\n\t* c-common.def (COMPOUND_LITERAL_EXPR): New.\n\t* c-common.c (c_expand_expr): Handle COMPOUND_LITERAL_EXPR.\n\t(c_staticp): New function.\n\t* c-common.h (COMPOUND_LITERAL_EXPR_DECL): New.\n\t(c_staticp): Declare.\n\t* c-typeck.c (default_function_array_conversion, build_unary_op):\n\tDon't handle CONSTRUCTOR specially.\n\t(lvalue_p, mark_addressable): Handle COMPOUND_LITERAL_EXPR.\n\t* c-decl.c (build_compound_literal): New function.\n\t* c-tree.h (build_compound_literal): Declare.\n\t* c-parse.in (primary): Use build_compound_literal.\n\t* c-lang.c (LANG_HOOKS_STATICP): Define.\n\t* objc/objc-lang.c (LANG_HOOKS_STATICP): Likewise.\n\t* doc/c-tree.texi: Document COMPOUND_LITERAL_EXPR.\n\t* doc/extend.texi: Update documentation of compound literals.\n\tFixes PR c/4787.\n\ntestsuite:\n\t* gcc.c-torture/execute/20000722-1.x,\n\tgcc.c-torture/execute/20010123-1.x: Remove.\n\t* gcc.c-torture/compile/init-3.c: Don't use a compound literal.\n\t* gcc.dg/c90-complit-1.c, gcc.dg/c99-complit-1.c,\n\tgcc.dg/c99-complit-2.c: New tests.\n\nFrom-SVN: r47629", "tree": {"sha": "47e4fa29a6462438cb5aea8ae3e2c690243e3f52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47e4fa29a6462438cb5aea8ae3e2c690243e3f52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db3acfa5476e5af834fee38ad8e1b193a8f018dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3acfa5476e5af834fee38ad8e1b193a8f018dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db3acfa5476e5af834fee38ad8e1b193a8f018dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3acfa5476e5af834fee38ad8e1b193a8f018dc/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d062a680ab959bc09d0f2572ac16e444b5396aa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d062a680ab959bc09d0f2572ac16e444b5396aa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d062a680ab959bc09d0f2572ac16e444b5396aa4"}], "stats": {"total": 389, "additions": 339, "deletions": 50}, "files": [{"sha": "95ae31275afda63999567ecfdd8e249abe1fdbfc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -1,3 +1,22 @@\n+2001-12-04  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.def (COMPOUND_LITERAL_EXPR): New.\n+\t* c-common.c (c_expand_expr): Handle COMPOUND_LITERAL_EXPR.\n+\t(c_staticp): New function.\n+\t* c-common.h (COMPOUND_LITERAL_EXPR_DECL): New.\n+\t(c_staticp): Declare.\n+\t* c-typeck.c (default_function_array_conversion, build_unary_op):\n+\tDon't handle CONSTRUCTOR specially.\n+\t(lvalue_p, mark_addressable): Handle COMPOUND_LITERAL_EXPR.\n+\t* c-decl.c (build_compound_literal): New function.\n+\t* c-tree.h (build_compound_literal): Declare.\n+\t* c-parse.in (primary): Use build_compound_literal.\n+\t* c-lang.c (LANG_HOOKS_STATICP): Define.\n+\t* objc/objc-lang.c (LANG_HOOKS_STATICP): Likewise.\n+\t* doc/c-tree.texi: Document COMPOUND_LITERAL_EXPR.\n+\t* doc/extend.texi: Update documentation of compound literals.\n+\tFixes PR c/4787.\n+\n 2001-12-04  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* langhooks.h (struct lang_hooks): Add staticp."}, {"sha": "f5fc0d348f5ded7b92610fa0a07bacb9e908bfbb", "filename": "gcc/c-common.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -3432,6 +3432,15 @@ c_expand_expr (exp, target, tmode, modifier)\n       }\n       break;\n \n+    case COMPOUND_LITERAL_EXPR:\n+      {\n+\t/* Initialize the anonymous variable declared in the compound\n+\t   literal, then return the variable.  */\n+\ttree decl = COMPOUND_LITERAL_EXPR_DECL (exp);\n+\temit_local_var (decl);\n+\treturn expand_expr (decl, target, tmode, modifier);\n+      }\n+\n     default:\n       abort ();\n     }\n@@ -3482,6 +3491,18 @@ c_unsafe_for_reeval (exp)\n   return -1;\n }\n \n+/* Hook used by staticp to handle language-specific tree codes.  */\n+\n+int\n+c_staticp (exp)\n+     tree exp;\n+{\n+  if (TREE_CODE (exp) == COMPOUND_LITERAL_EXPR\n+      && TREE_STATIC (COMPOUND_LITERAL_EXPR_DECL (exp)))\n+    return 1;\n+  return 0;\n+}\n+\n /* Tree code classes.  */\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,"}, {"sha": "7840ce81610e9eed86f6d6dbedfa31efb16bd192", "filename": "gcc/c-common.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -101,3 +101,9 @@ DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 3)\n /* A STMT_EXPR represents a statement-expression.  The\n    STMT_EXPR_STMT is the statement given by the expression.  */\n DEFTREECODE (STMT_EXPR, \"stmt_expr\", 'e', 1)\n+\n+/* A COMPOUND_LITERAL_EXPR represents a C99 compound literal.  The\n+   COMPOND_LITERAL_EXPR_DECL is the decl for the anonymous object\n+   represented by the COMPOUND_LITERAL; the DECL_INITIAL of that\n+   decl is the CONSTRUCTOR that initializes the compound literal.  */\n+DEFTREECODE (COMPOUND_LITERAL_EXPR, \"compound_literal_expr\", 'e', 1)"}, {"sha": "4ab415c1f1e922f55ab59683f53734c7803c98b3", "filename": "gcc/c-common.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -630,6 +630,10 @@ extern tree strip_array_types                   PARAMS ((tree));\n    the given label statement.  */\n #define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (LABEL_STMT_CHECK (NODE), 0)\n \n+/* COMPOUND_LITERAL_EXPR accessor.  */\n+#define COMPOUND_LITERAL_EXPR_DECL(NODE)\t\t\\\n+  TREE_OPERAND (COMPOUND_LITERAL_EXPR_CHECK (NODE), 0)\n+\n /* Nonzero if this SCOPE_STMT is for the beginning of a scope.  */\n #define SCOPE_BEGIN_P(NODE) \\\n   (TREE_LANG_FLAG_0 (SCOPE_STMT_CHECK (NODE)))\n@@ -813,6 +817,8 @@ extern rtx c_expand_expr            PARAMS ((tree, rtx, enum machine_mode,\n \n extern int c_safe_from_p                        PARAMS ((rtx, tree));\n \n+extern int c_staticp                            PARAMS ((tree));\n+\n extern int c_unsafe_for_reeval\t\t\tPARAMS ((tree));\n \n /* Information recorded about each file examined during compilation.  */"}, {"sha": "b5597f98dadd222805e5f96567a06078b5066e60", "filename": "gcc/c-decl.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -3793,6 +3793,59 @@ clear_parm_order ()\n   current_binding_level->parm_order = NULL_TREE;\n }\n \f\n+/* Build a COMPOUND_LITERAL_EXPR.  TYPE is the type given in the compound\n+   literal, which may be an incomplete array type completed by the\n+   initializer; INIT is a CONSTRUCTOR that initializes the compound\n+   literal.  */\n+\n+tree\n+build_compound_literal (type, init)\n+     tree type;\n+     tree init;\n+{\n+  /* We do not use start_decl here because we have a type, not a declarator;\n+     and do not use finish_decl because the decl should be stored inside\n+     the COMPOUND_LITERAL_EXPR rather than added elsewhere as a DECL_STMT.  */\n+  tree decl = build_decl (VAR_DECL, NULL_TREE, type);\n+  tree complit;\n+  DECL_EXTERNAL (decl) = 0;\n+  TREE_PUBLIC (decl) = 0;\n+  TREE_STATIC (decl) = (current_binding_level == global_binding_level);\n+  DECL_CONTEXT (decl) = current_function_decl;\n+  TREE_USED (decl) = 1;\n+  TREE_TYPE (decl) = type;\n+  store_init_value (decl, init);\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n+    {\n+      int failure = complete_array_type (type, DECL_INITIAL (decl), 1);\n+      if (failure)\n+\tabort ();\n+    }\n+\n+  type = TREE_TYPE (decl);\n+  if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n+    return error_mark_node;\n+\n+  complit = build1 (COMPOUND_LITERAL_EXPR, TREE_TYPE (decl), decl);\n+  TREE_SIDE_EFFECTS (complit) = 1;\n+\n+  layout_decl (decl, 0);\n+\n+  if (TREE_STATIC (decl))\n+    {\n+      /* This decl needs a name for the assembler output.  We also need\n+\t a unique suffix to be added to the name, for which DECL_CONTEXT\n+\t must be set.  */\n+      DECL_NAME (decl) = get_identifier (\"__compound_literal\");\n+      DECL_CONTEXT (decl) = complit;\n+      rest_of_decl_compilation (decl, NULL, 1, 0);\n+      DECL_CONTEXT (decl) = NULL_TREE;\n+    }\n+\n+  return complit;\n+}\n+\f\n /* Make TYPE a complete type based on INITIAL_VALUE.\n    Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,\n    2 if there was no information (in which case assume 1 if DO_DEFAULT).  */"}, {"sha": "c2056c5b46418b90dd72ba26a825570e70ff5845", "filename": "gcc/c-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -56,6 +56,8 @@ static void c_post_options PARAMS ((void));\n #define LANG_HOOKS_GET_ALIAS_SET c_common_get_alias_set\n #undef LANG_HOOKS_SAFE_FROM_P\n #define LANG_HOOKS_SAFE_FROM_P c_safe_from_p\n+#undef LANG_HOOKS_STATICP\n+#define LANG_HOOKS_STATICP c_staticp\n #undef LANG_HOOKS_PRINT_IDENTIFIER\n #define LANG_HOOKS_PRINT_IDENTIFIER c_print_identifier\n #undef LANG_HOOKS_SET_YYDEBUG"}, {"sha": "e0457b2af6751513f0bc97f96f5457660f956419", "filename": "gcc/c-parse.in", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -627,29 +627,13 @@ primary:\n \t\t  $2 = groktypename ($2);\n \t\t  really_start_incremental_init ($2); }\n \t  initlist_maybe_comma '}'  %prec UNARY\n-\t\t{ const char *name;\n-\t\t  tree result = pop_init_level (0);\n+\t\t{ tree constructor = pop_init_level (0);\n \t\t  tree type = $2;\n \t\t  finish_init ();\n \n \t\t  if (pedantic && ! flag_isoc99)\n \t\t    pedwarn (\"ISO C89 forbids compound literals\");\n-\t\t  if (TYPE_NAME (type) != 0)\n-\t\t    {\n-\t\t      if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-\t\t\tname = IDENTIFIER_POINTER (TYPE_NAME (type));\n-\t\t      else\n-\t\t\tname = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-\t\t    }\n-\t\t  else\n-\t\t    name = \"\";\n-\t\t  $$ = result;\n-\t\t  if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n-\t\t    {\n-\t\t      int failure = complete_array_type (type, $$, 1);\n-\t\t      if (failure)\n-\t\t\tabort ();\n-\t\t    }\n+\t\t  $$ = build_compound_literal (type, constructor);\n \t\t}\n \t| '(' expr ')'\n \t\t{ char class = TREE_CODE_CLASS (TREE_CODE ($2));"}, {"sha": "a304b7ebff79c1bedd47d698feb8c85533c82b7a", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -261,6 +261,7 @@ extern tree pop_init_level\t\t\tPARAMS ((int));\n extern void set_init_index\t\t\tPARAMS ((tree, tree));\n extern void set_init_label\t\t\tPARAMS ((tree));\n extern void process_init_element\t\tPARAMS ((tree));\n+extern tree build_compound_literal\t\tPARAMS ((tree, tree));\n extern void pedwarn_c99\t\t\t\tPARAMS ((const char *, ...))\n \t\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n extern tree c_start_case                        PARAMS ((tree));"}, {"sha": "297afad8ce8881b63668b5fb98ebeeeeac9d37f9", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -910,8 +910,7 @@ default_function_array_conversion (exp)\n \t}\n \n       lvalue_array_p = !not_lvalue && lvalue_p (exp);\n-      if (!flag_isoc99 && !lvalue_array_p\n-\t  && !(TREE_CODE (exp) == CONSTRUCTOR && TREE_STATIC (exp)))\n+      if (!flag_isoc99 && !lvalue_array_p)\n \t{\n \t  /* Before C99, non-lvalue arrays do not decay to pointers.\n \t     Normally, using such an array would be invalid; but it can\n@@ -3141,10 +3140,6 @@ build_unary_op (code, xarg, flag)\n \t}\n #endif\n \n-      /* Allow the address of a constructor if all the elements\n-\t are constant.  */\n-      if (TREE_CODE (arg) == CONSTRUCTOR && TREE_CONSTANT (arg))\n-\t;\n       /* Anything not already handled and not a true memory reference\n \t or a non-lvalue array is an error.  */\n       else if (typecode != FUNCTION_TYPE && !flag\n@@ -3256,6 +3251,7 @@ lvalue_p (ref)\n     case COMPONENT_REF:\n       return lvalue_p (TREE_OPERAND (ref, 0));\n \n+    case COMPOUND_LITERAL_EXPR:\n     case STRING_CST:\n       return 1;\n \n@@ -3411,6 +3407,7 @@ mark_addressable (exp)\n \tx = TREE_OPERAND (x, 0);\n \tbreak;\n \n+      case COMPOUND_LITERAL_EXPR:\n       case CONSTRUCTOR:\n \tTREE_ADDRESSABLE (x) = 1;\n \treturn 1;"}, {"sha": "3db3d7f10ff794c936c36f0628a28b7a232a8854", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -1738,6 +1738,7 @@ This macro returns the attributes on the type @var{type}.\n @tindex COND_EXPR\n @tindex CALL_EXPR\n @tindex CONSTRUCTOR\n+@tindex COMPOUND_LITERAL_EXPR\n @tindex STMT_EXPR\n @tindex BIND_EXPR\n @tindex LOOP_EXPR\n@@ -2201,6 +2202,15 @@ next available array element.\n Conceptually, before any initialization is done, the entire area of\n storage is initialized to zero.\n \n+@item COMPOUND_LITERAL_EXPR\n+@findex COMPOUND_LITERAL_EXPR_DECL\n+These nodes represent ISO C99 compound literals.  The\n+@code{COMPOUND_LITERAL_EXPR_DECL} is an anonymous @code{VAR_DECL} for\n+the unnamed object represented by the compound literal; the\n+@code{DECL_INITIAL} of that @code{VAR_DECL} is a @code{CONSTRUCTOR}\n+representing the brace-enclosed list of initializers in the compound\n+literal.\n+\n @item SAVE_EXPR\n \n A @code{SAVE_EXPR} represents an expression (possibly involving"}, {"sha": "cf275f1ecc9990a15916046c5387d75bc64b4069", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -1608,9 +1608,8 @@ foo (float f, float g)\n ISO C99 supports compound literals.  A compound literal looks like\n a cast containing an initializer.  Its value is an object of the\n type specified in the cast, containing the elements specified in\n-the initializer.  (GCC does not yet implement the full ISO C99 semantics\n-for compound literals.)  As an extension, GCC supports compound literals\n-in C89 mode and in C++.\n+the initializer; it is an lvalue.  As an extension, GCC supports\n+compound literals in C89 mode and in C++.\n \n Usually, the specified type is a structure.  Assume that\n @code{struct foo} and @code{structure} are declared as shown:\n@@ -1638,28 +1637,14 @@ This is equivalent to writing the following:\n \n You can also construct an array.  If all the elements of the compound literal\n are (made up of) simple constant expressions, suitable for use in\n-initializers, then the compound literal is an lvalue and can be coerced to a\n-pointer to its first element, as shown here:\n+initializers of objects of static storage duration, then the compound\n+literal can be coerced to a pointer to its first element and used in\n+such an initializer, as shown here:\n \n @example\n char **foo = (char *[]) @{ \"x\", \"y\", \"z\" @};\n @end example\n \n-Array compound literals whose elements are not simple constants are\n-not very useful, because the compound literal is not an lvalue; ISO C99\n-specifies that it is, being a temporary object with automatic storage\n-duration associated with the enclosing block, but GCC does not yet\n-implement this.  There are currently only two valid ways to use it with\n-GCC: to subscript it, or initialize\n-an array variable with it.  The former is probably slower than a\n-@code{switch} statement, while the latter does the same thing an\n-ordinary C initializer would do.  Here is an example of\n-subscripting an array compound literal:\n-\n-@example\n-output = ((int[]) @{ 2, x, 28 @}) [input];\n-@end example\n-\n Compound literals for scalar types and union types are is\n also allowed, but then the compound literal is equivalent\n to a cast."}, {"sha": "7e2cae7bf008209da099bc71057e1796742eb393", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -44,6 +44,8 @@ static void objc_post_options                   PARAMS ((void));\n #define LANG_HOOKS_DECODE_OPTION objc_decode_option\n #undef LANG_HOOKS_POST_OPTIONS\n #define LANG_HOOKS_POST_OPTIONS objc_post_options\n+#undef LANG_HOOKS_STATICP\n+#define LANG_HOOKS_STATICP c_staticp\n #undef LANG_HOOKS_PRINT_IDENTIFIER\n #define LANG_HOOKS_PRINT_IDENTIFIER c_print_identifier\n #undef LANG_HOOKS_SET_YYDEBUG"}, {"sha": "d22c31dc4bb743d7a0b7dfe97c5140866229f9b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -1,3 +1,11 @@\n+2001-12-04  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc.c-torture/execute/20000722-1.x,\n+\tgcc.c-torture/execute/20010123-1.x: Remove.\n+\t* gcc.c-torture/compile/init-3.c: Don't use a compound literal.\n+\t* gcc.dg/c90-complit-1.c, gcc.dg/c99-complit-1.c,\n+\tgcc.dg/c99-complit-2.c: New tests.\n+\n 2001-12-04  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/inherit/base1.C: New test."}, {"sha": "be3d9b49679a282b3b1aa35b603cad6a2db54039", "filename": "gcc/testsuite/gcc.c-torture/compile/init-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Finit-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Finit-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Finit-3.c?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -6,6 +6,6 @@ struct something {\n };\n \n struct something X = {\n-\tfoo: (struct empty) { },\n+\tfoo: { },\n \tbar: 1,\n };"}, {"sha": "bbad3bb394a9e27316f2b5eb644c2b70e6a3b94d", "filename": "gcc/testsuite/gcc.c-torture/execute/20000722-1.x", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d062a680ab959bc09d0f2572ac16e444b5396aa4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000722-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d062a680ab959bc09d0f2572ac16e444b5396aa4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000722-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000722-1.x?ref=d062a680ab959bc09d0f2572ac16e444b5396aa4", "patch": "@@ -1,3 +0,0 @@\n-# Doesn't work.  Hasn't worked ever, I think.\n-set torture_execute_xfail \"*-*-*\"\n-return 0"}, {"sha": "2f397b96e51b8dd77baecd30d403a01dfab48caf", "filename": "gcc/testsuite/gcc.c-torture/execute/20010123-1.x", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d062a680ab959bc09d0f2572ac16e444b5396aa4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20010123-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d062a680ab959bc09d0f2572ac16e444b5396aa4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20010123-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20010123-1.x?ref=d062a680ab959bc09d0f2572ac16e444b5396aa4", "patch": "@@ -1,2 +0,0 @@\n-set torture_execute_xfail \"*-*-*\"\n-return 0"}, {"sha": "4cd910fa8663839c7b7063abef240aa5a4ad0160", "filename": "gcc/testsuite/gcc.dg/c90-complit-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-complit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-complit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-complit-1.c?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -0,0 +1,20 @@\n+/* Test for compound literals: in C99 only.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+struct s { int a; int b; };\n+union u { int c; int d; };\n+\n+void\n+foo (void)\n+{\n+  (int) { 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"compound literal\" \"scalar\" { target *-*-* } 12 } */\n+  (struct s) { 1, 2 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"compound literal\" \"struct\" { target *-*-* } 14 } */\n+  (union u) { 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"compound literal\" \"union\" { target *-*-* } 16 } */\n+  (int [1]) { 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"compound literal\" \"array\" { target *-*-* } 18 } */\n+}"}, {"sha": "94e15db6d2aad91abf6935716e5cefa551e3683a", "filename": "gcc/testsuite/gcc.dg/c99-complit-1.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-complit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-complit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-complit-1.c?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -0,0 +1,112 @@\n+/* Test for compound literals: in C99 only.  Test for valid uses.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do run } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+struct s { int a; int b; };\n+union u { int c; int d; };\n+\n+int *i0a = &(int) { 0 };\n+int *i0b = &(int) { 0 };\n+int *i1a = &(int) { 1 };\n+int *i1b = &(int) { 1 };\n+const int *i0c = &(const int) { 0 };\n+\n+struct s *s0 = &(struct s) { 1, 2 };\n+struct s *s1 = &(struct s) { 1, 2 };\n+const struct s *s2 = &(const struct s) { 1, 2 };\n+\n+union u *u0 = &(union u) { 3 };\n+union u *u1 = &(union u) { 3 };\n+const union u *u2 = &(const union u) { 3 };\n+\n+int *a0 = (int []) { 1, 2, 3 };\n+const int *a1 = (const int []) { 1, 2, 3 };\n+\n+char *p = (char []){ \"foo\" };\n+\n+int\n+main (void)\n+{\n+  if (i0a == i0b || i0a == i0c || i0b == i0c)\n+    abort ();\n+  if (i1a == i1b)\n+    abort ();\n+  if (*i0a != 0 || *i0b != 0 || *i1a != 1 || *i1b != 1 || *i0c != 0)\n+    abort ();\n+  *i0a = 1;\n+  *i1a = 0;\n+  if (*i0a != 1 || *i0b != 0 || *i1a != 0 || *i1b != 1 || *i0c != 0)\n+    abort ();\n+  if (s0 == s1 || s1 == s2 || s2 == s0)\n+    abort ();\n+  if (s0->a != 1 || s0->b != 2 || s1->a != 1 || s1->b != 2\n+      || s2->a != 1 || s2->b != 2)\n+    abort ();\n+  s0->a = 2;\n+  s1->b = 1;\n+  if (s0->a != 2 || s0->b != 2 || s1->a != 1 || s1->b != 1\n+      || s2->a != 1 || s2->b != 2)\n+    abort ();\n+  if (u0 == u1 || u1 == u2 || u2 == u0)\n+    abort ();\n+  if (u0->c != 3 || u1->c != 3 || u2->c != 3)\n+    abort ();\n+  u0->d = 2;\n+  if (u0->d != 2 || u1->c != 3 || u2->c != 3)\n+    abort ();\n+  if (a0 == a1)\n+    abort ();\n+  if (a0[0] != 1 || a0[1] != 2 || a0[2] != 3\n+      || a1[0] != 1 || a1[1] != 2 || a1[2] != 3)\n+    abort ();\n+  a0[0] = 3;\n+  if (a0[0] != 3 || a0[1] != 2 || a0[2] != 3\n+      || a1[0] != 1 || a1[1] != 2 || a1[2] != 3)\n+    abort ();\n+  if (p[0] != 'f' || p[1] != 'o' || p[2] != 'o' || p[3] != 0)\n+    abort ();\n+  p[0] = 'g';\n+  if (p[0] != 'g' || p[1] != 'o' || p[2] != 'o' || p[3] != 0)\n+    abort ();\n+  if (sizeof((int []) { 1, 2 ,3 }) != 3 * sizeof(int))\n+    abort ();\n+  if (sizeof((int []) { [3] = 4 }) != 4 * sizeof(int))\n+    abort ();\n+  struct s *y;\n+  for (int i = 0; i < 3; i++) {\n+    struct s *x = &(struct s) { 1, i };\n+    if (x->a != 1 || x->b != i)\n+      abort ();\n+    x->a++;\n+    x->b--;\n+    if (x->a != 2 || x->b != i - 1)\n+      abort ();\n+    if (i && y != x)\n+      abort ();\n+    y = x;\n+  }\n+  int *z;\n+  for (int i = 0; i < 4; i++) {\n+    int *x = (int []){ 0, i, i + 2, i - 3 };\n+    if (x[0] != 0 || x[1] != i || x[2] != i + 2 || x[3] != i - 3)\n+      abort ();\n+    x[0] = x[1];\n+    x[1] *= x[2];\n+    x[2] -= x[3];\n+    x[3] += 7;\n+    if (x[0] != i || x[1] != i * (i + 2) || x[2] != 5 || x[3] != i + 4)\n+      abort ();\n+    if (i && z != x)\n+      abort ();\n+    z = x;\n+  }\n+  (int) { 0 } = 1;\n+  (struct s) { 0, 1 }.a = 3;\n+  (union u) { 3 }.c = 4;\n+  (int []){ 1, 2 }[0] = 0;\n+  exit (0);\n+}"}, {"sha": "faf44b2376e34e232e1f14cbded010cda26331ed", "filename": "gcc/testsuite/gcc.dg/c99-complit-2.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-complit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3acfa5476e5af834fee38ad8e1b193a8f018dc/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-complit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-complit-2.c?ref=db3acfa5476e5af834fee38ad8e1b193a8f018dc", "patch": "@@ -0,0 +1,68 @@\n+/* Test for compound literals: in C99 only.  Test for invalid uses.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+struct s { int a; int b; };\n+union u { int c; int d; };\n+\n+struct si;\n+union ui;\n+\n+void\n+foo (int a)\n+{\n+  /* The type name must not be incomplete (apart from arrays of unknown\n+     size), or a function type, or a VLA type.  */\n+  (void) { 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"init\" \"void type\" { target *-*-* } 17 } */\n+  &(struct si) { 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"init\" \"incomplete struct type\" { target *-*-* } 19 } */\n+  &(union ui) { 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"init\" \"incomplete union type\" { target *-*-* } 21 } */\n+  (void (void)) { 0 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"init\" \"function type\" { target *-*-* } 23 } */\n+  (int [a]) { 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"init|variable\" \"VLA type\" { target *-*-* } 25 } */\n+  /* Initializers must not attempt to initialize outside the object\n+     declared.  */\n+  (int [1]) { [1] = 2 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"init\" \"value outside array\" { target *-*-* } 29 } */\n+  (int [1]) { [-1] = 2 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"init\" \"value outside array\" { target *-*-* } 31 } */\n+  (int [1]) { 0, 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"init\" \"value outside array\" { target *-*-* } 33 } */\n+}\n+\n+int z;\n+\n+/* Outside a function, initializers must be constant.  */\n+struct s *s0 = &(struct s) { 0, z }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"init\" \"non-const\" { target *-*-* } 40 } */\n+int sz = sizeof((struct s) { 0, z }); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"init\" \"non-const\" { target *-*-* } 42 } */\n+\n+/* Compound literals aren't themselves constant expressions.  */\n+int x = (int) { 0 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"init\" \"non-const\" { target *-*-* } 46 } */\n+\n+/* Nor are they suitable structure or union initializers\n+   outside a function.  */\n+struct s s1 = (struct s) { 0, 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"init\" \"struct bad init\" { target *-*-* } 51 } */\n+union u u1 = (union u) { 0 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"init\" \"union bad init\" { target *-*-* } 53 } */\n+\n+/* They aren't suitable for array initializers, either inside or outside\n+   a function.  */\n+int y[2] = (int [2]) { 0, 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"init\" \"array bad init\" { target *-*-* } 58 } */\n+\n+void\n+bar (void)\n+{\n+  struct s s2 = (struct s) { 0, 1 };\n+  union u u2 = (union u) { 0 };\n+  int z[2] = (int [2]) { 0, 1 }; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  /* { dg-error \"init\" \"array bad init\" { target *-*-* } 66 } */\n+}"}]}