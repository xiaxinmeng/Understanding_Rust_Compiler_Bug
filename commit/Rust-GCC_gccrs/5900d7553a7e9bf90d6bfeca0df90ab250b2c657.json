{"sha": "5900d7553a7e9bf90d6bfeca0df90ab250b2c657", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkwMGQ3NTUzYTdlOWJmOTBkNmJmZWNhMGRmOTBhYjI1MGIyYzY1Nw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-21T16:00:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-21T16:00:50Z"}, "message": "compiler: Remove obsolete hidden_fields_are_ok code.\n\nThe language used to forbid assigning structs with hidden\nfields, but that was changed before the Go 1 release.  At the\ntime the change was experimental, so I left the old code in\nthe compiler.  At this point it's clearly not experimental, so\nthis removes the unused code.\n\nFrom-SVN: r216519", "tree": {"sha": "4bb0fd6c1318f67884148c8e8cbf581528fbefb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bb0fd6c1318f67884148c8e8cbf581528fbefb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5900d7553a7e9bf90d6bfeca0df90ab250b2c657", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5900d7553a7e9bf90d6bfeca0df90ab250b2c657", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5900d7553a7e9bf90d6bfeca0df90ab250b2c657", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/comments", "author": null, "committer": null, "parents": [{"sha": "dd637013f6c780d6ae06607f5188002359ac9f4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd637013f6c780d6ae06607f5188002359ac9f4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd637013f6c780d6ae06607f5188002359ac9f4a"}], "stats": {"total": 305, "additions": 31, "deletions": 274}, "files": [{"sha": "a835ee8378fd97b4c8388ff40c4b7a4348b2ea14", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=5900d7553a7e9bf90d6bfeca0df90ab250b2c657", "patch": "@@ -9305,13 +9305,7 @@ Call_expression::check_argument_type(int i, const Type* parameter_type,\n \t\t\t\t     bool issued_error)\n {\n   std::string reason;\n-  bool ok;\n-  if (this->are_hidden_fields_ok_)\n-    ok = Type::are_assignable_hidden_ok(parameter_type, argument_type,\n-\t\t\t\t\t&reason);\n-  else\n-    ok = Type::are_assignable(parameter_type, argument_type, &reason);\n-  if (!ok)\n+  if (!Type::are_assignable(parameter_type, argument_type, &reason))\n     {\n       if (!issued_error)\n \t{\n@@ -9359,13 +9353,11 @@ Call_expression::do_check_types(Gogo*)\n       go_assert(this->args_ != NULL && !this->args_->empty());\n       Type* rtype = fntype->receiver()->type();\n       Expression* first_arg = this->args_->front();\n-      // The language permits copying hidden fields for a method\n-      // receiver.  We dereference the values since receivers are\n-      // always passed as pointers.\n+      // We dereference the values since receivers are always passed\n+      // as pointers.\n       std::string reason;\n-      if (!Type::are_assignable_hidden_ok(rtype->deref(),\n-\t\t\t\t\t  first_arg->type()->deref(),\n-\t\t\t\t\t  &reason))\n+      if (!Type::are_assignable(rtype->deref(), first_arg->type()->deref(),\n+\t\t\t\t&reason))\n \t{\n \t  if (reason.empty())\n \t    this->report_error(_(\"incompatible type for receiver\"));"}, {"sha": "c6b163e715d0829bd4810697e0282e394e389c91", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=5900d7553a7e9bf90d6bfeca0df90ab250b2c657", "patch": "@@ -1617,8 +1617,8 @@ class Call_expression : public Expression\n     : Expression(EXPRESSION_CALL, location),\n       fn_(fn), args_(args), type_(NULL), results_(NULL), call_(NULL),\n       call_temp_(NULL), expected_result_count_(0), is_varargs_(is_varargs),\n-      are_hidden_fields_ok_(false), varargs_are_lowered_(false),\n-      types_are_determined_(false), is_deferred_(false), issued_error_(false)\n+      varargs_are_lowered_(false), types_are_determined_(false),\n+      is_deferred_(false), issued_error_(false)\n   { }\n \n   // The function to call.\n@@ -1674,12 +1674,6 @@ class Call_expression : public Expression\n   set_varargs_are_lowered()\n   { this->varargs_are_lowered_ = true; }\n \n-  // Note that it is OK for this call to set hidden fields when\n-  // passing arguments.\n-  void\n-  set_hidden_fields_are_ok()\n-  { this->are_hidden_fields_ok_ = true; }\n-\n   // Whether this call is being deferred.\n   bool\n   is_deferred() const\n@@ -1788,9 +1782,6 @@ class Call_expression : public Expression\n   size_t expected_result_count_;\n   // True if the last argument is a varargs argument (f(a...)).\n   bool is_varargs_;\n-  // True if this statement may pass hidden fields in the arguments.\n-  // This is used for generated method stubs.\n-  bool are_hidden_fields_ok_;\n   // True if varargs have already been lowered.\n   bool varargs_are_lowered_;\n   // True if types have been determined."}, {"sha": "183aaf4f8ab516f5c05594751cc0d23cffc59517", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 9, "deletions": 66, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=5900d7553a7e9bf90d6bfeca0df90ab250b2c657", "patch": "@@ -409,13 +409,7 @@ Temporary_statement::do_check_types(Gogo*)\n   if (this->type_ != NULL && this->init_ != NULL)\n     {\n       std::string reason;\n-      bool ok;\n-      if (this->are_hidden_fields_ok_)\n-\tok = Type::are_assignable_hidden_ok(this->type_, this->init_->type(),\n-\t\t\t\t\t    &reason);\n-      else\n-\tok = Type::are_assignable(this->type_, this->init_->type(), &reason);\n-      if (!ok)\n+      if (!Type::are_assignable(this->type_, this->init_->type(), &reason))\n \t{\n \t  if (reason.empty())\n \t    error_at(this->location(), \"incompatible types in assignment\");\n@@ -511,15 +505,9 @@ class Assignment_statement : public Statement\n   Assignment_statement(Expression* lhs, Expression* rhs,\n \t\t       Location location)\n     : Statement(STATEMENT_ASSIGNMENT, location),\n-      lhs_(lhs), rhs_(rhs), are_hidden_fields_ok_(false)\n+      lhs_(lhs), rhs_(rhs)\n   { }\n \n-  // Note that it is OK for this assignment statement to set hidden\n-  // fields.\n-  void\n-  set_hidden_fields_are_ok()\n-  { this->are_hidden_fields_ok_ = true; }\n-\n  protected:\n   int\n   do_traverse(Traverse* traverse);\n@@ -544,9 +532,6 @@ class Assignment_statement : public Statement\n   Expression* lhs_;\n   // Right hand side--the rvalue.\n   Expression* rhs_;\n-  // True if this statement may set hidden fields in the assignment\n-  // statement.  This is used for generated method stubs.\n-  bool are_hidden_fields_ok_;\n };\n \n // Traversal.\n@@ -607,12 +592,7 @@ Assignment_statement::do_check_types(Gogo*)\n     }\n \n   std::string reason;\n-  bool ok;\n-  if (this->are_hidden_fields_ok_)\n-    ok = Type::are_assignable_hidden_ok(lhs_type, rhs_type, &reason);\n-  else\n-    ok = Type::are_assignable(lhs_type, rhs_type, &reason);\n-  if (!ok)\n+  if (!Type::are_assignable(lhs_type, rhs_type, &reason))\n     {\n       if (reason.empty())\n \terror_at(this->location(), \"incompatible types in assignment\");\n@@ -905,15 +885,9 @@ class Tuple_assignment_statement : public Statement\n   Tuple_assignment_statement(Expression_list* lhs, Expression_list* rhs,\n \t\t\t     Location location)\n     : Statement(STATEMENT_TUPLE_ASSIGNMENT, location),\n-      lhs_(lhs), rhs_(rhs), are_hidden_fields_ok_(false)\n+      lhs_(lhs), rhs_(rhs)\n   { }\n \n-  // Note that it is OK for this assignment statement to set hidden\n-  // fields.\n-  void\n-  set_hidden_fields_are_ok()\n-  { this->are_hidden_fields_ok_ = true; }\n-\n  protected:\n   int\n   do_traverse(Traverse* traverse);\n@@ -937,9 +911,6 @@ class Tuple_assignment_statement : public Statement\n   Expression_list* lhs_;\n   // Right hand side--a list of rvalues.\n   Expression_list* rhs_;\n-  // True if this statement may set hidden fields in the assignment\n-  // statement.  This is used for generated method stubs.\n-  bool are_hidden_fields_ok_;\n };\n \n // Traversal.\n@@ -998,8 +969,6 @@ Tuple_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n \n       Temporary_statement* temp = Statement::make_temporary((*plhs)->type(),\n \t\t\t\t\t\t\t    *prhs, loc);\n-      if (this->are_hidden_fields_ok_)\n-\ttemp->set_hidden_fields_are_ok();\n       b->add_statement(temp);\n       temps.push_back(temp);\n \n@@ -1022,13 +991,7 @@ Tuple_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n \tcontinue;\n \n       Expression* ref = Expression::make_temporary_reference(*ptemp, loc);\n-      Statement* s = Statement::make_assignment(*plhs, ref, loc);\n-      if (this->are_hidden_fields_ok_)\n-\t{\n-\t  Assignment_statement* as = static_cast<Assignment_statement*>(s);\n-\t  as->set_hidden_fields_are_ok();\n-\t}\n-      b->add_statement(s);\n+      b->add_statement(Statement::make_assignment(*plhs, ref, loc));\n       ++ptemp;\n     }\n   go_assert(ptemp == temps.end() || saw_errors());\n@@ -2736,12 +2699,7 @@ Return_statement::do_lower(Gogo*, Named_object* function, Block* enclosing,\n       e->determine_type(&type_context);\n \n       std::string reason;\n-      bool ok;\n-      if (this->are_hidden_fields_ok_)\n-\tok = Type::are_assignable_hidden_ok(rvtype, e->type(), &reason);\n-      else\n-\tok = Type::are_assignable(rvtype, e->type(), &reason);\n-      if (ok)\n+      if (Type::are_assignable(rvtype, e->type(), &reason))\n \t{\n \t  Expression* ve = Expression::make_var_reference(rv, e->location());\n \t  lhs->push_back(ve);\n@@ -2763,28 +2721,13 @@ Return_statement::do_lower(Gogo*, Named_object* function, Block* enclosing,\n     ;\n   else if (lhs->size() == 1)\n     {\n-      Statement* s = Statement::make_assignment(lhs->front(), rhs->front(),\n-\t\t\t\t\t\tloc);\n-      if (this->are_hidden_fields_ok_)\n-\t{\n-\t  Assignment_statement* as = static_cast<Assignment_statement*>(s);\n-\t  as->set_hidden_fields_are_ok();\n-\t}\n-      b->add_statement(s);\n+      b->add_statement(Statement::make_assignment(lhs->front(), rhs->front(),\n+\t\t\t\t\t\t  loc));\n       delete lhs;\n       delete rhs;\n     }\n   else\n-    {\n-      Statement* s = Statement::make_tuple_assignment(lhs, rhs, loc);\n-      if (this->are_hidden_fields_ok_)\n-\t{\n-\t  Tuple_assignment_statement* tas =\n-\t    static_cast<Tuple_assignment_statement*>(s);\n-\t  tas->set_hidden_fields_are_ok();\n-\t}\n-      b->add_statement(s);\n-    }\n+    b->add_statement(Statement::make_tuple_assignment(lhs, rhs, loc));\n \n   b->add_statement(this);\n "}, {"sha": "9bb0fb5aa8df0de3c471777175804f4cb12da290", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=5900d7553a7e9bf90d6bfeca0df90ab250b2c657", "patch": "@@ -514,8 +514,7 @@ class Temporary_statement : public Statement\n  public:\n   Temporary_statement(Type* type, Expression* init, Location location)\n     : Statement(STATEMENT_TEMPORARY, location),\n-      type_(type), init_(init), bvariable_(NULL), are_hidden_fields_ok_(false),\n-      is_address_taken_(false)\n+      type_(type), init_(init), bvariable_(NULL), is_address_taken_(false)\n   { }\n \n   // Return the type of the temporary variable.\n@@ -527,11 +526,6 @@ class Temporary_statement : public Statement\n   init() const\n   { return this->init_; }\n \n-  // Note that it is OK for this statement to set hidden fields.\n-  void\n-  set_hidden_fields_are_ok()\n-  { this->are_hidden_fields_ok_ = true; }\n-\n   // Record that something takes the address of this temporary\n   // variable.\n   void\n@@ -569,9 +563,6 @@ class Temporary_statement : public Statement\n   Expression* init_;\n   // The backend representation of the temporary variable.\n   Bvariable* bvariable_;\n-  // True if this statement may set hidden fields when assigning the\n-  // value to the temporary.  This is used for generated method stubs.\n-  bool are_hidden_fields_ok_;\n   // True if something takes the address of this temporary variable.\n   bool is_address_taken_;\n };\n@@ -619,20 +610,14 @@ class Return_statement : public Statement\n  public:\n   Return_statement(Expression_list* vals, Location location)\n     : Statement(STATEMENT_RETURN, location),\n-      vals_(vals), are_hidden_fields_ok_(false), is_lowered_(false)\n+      vals_(vals), is_lowered_(false)\n   { }\n \n   // The list of values being returned.  This may be NULL.\n   const Expression_list*\n   vals() const\n   { return this->vals_; }\n \n-  // Note that it is OK for this return statement to set hidden\n-  // fields.\n-  void\n-  set_hidden_fields_are_ok()\n-  { this->are_hidden_fields_ok_ = true; }\n-\n  protected:\n   int\n   do_traverse(Traverse* traverse)\n@@ -657,9 +642,6 @@ class Return_statement : public Statement\n  private:\n   // Return values.  This may be NULL.\n   Expression_list* vals_;\n-  // True if this statement may pass hidden fields in the return\n-  // value.  This is used for generated method stubs.\n-  bool are_hidden_fields_ok_;\n   // True if this statement has been lowered.\n   bool is_lowered_;\n };"}, {"sha": "0d66abf50813e9311fc9e72438fccc872432bcec", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 9, "deletions": 125, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=5900d7553a7e9bf90d6bfeca0df90ab250b2c657", "patch": "@@ -594,14 +594,11 @@ Type::are_compatible_for_comparison(bool is_equality_op, const Type *t1,\n }\n \n // Return true if a value with type RHS may be assigned to a variable\n-// with type LHS.  If CHECK_HIDDEN_FIELDS is true, check whether any\n-// hidden fields are modified.  If REASON is not NULL, set *REASON to\n-// the reason the types are not assignable.\n+// with type LHS.  If REASON is not NULL, set *REASON to the reason\n+// the types are not assignable.\n \n bool\n-Type::are_assignable_check_hidden(const Type* lhs, const Type* rhs,\n-\t\t\t\t  bool check_hidden_fields,\n-\t\t\t\t  std::string* reason)\n+Type::are_assignable(const Type* lhs, const Type* rhs, std::string* reason)\n {\n   // Do some checks first.  Make sure the types are defined.\n   if (rhs != NULL && !rhs->is_undefined())\n@@ -621,21 +618,11 @@ Type::are_assignable_check_hidden(const Type* lhs, const Type* rhs,\n \t}\n     }\n \n-  if (lhs != NULL && !lhs->is_undefined())\n-    {\n-      // Any value may be assigned to the blank identifier.\n-      if (lhs->is_sink_type())\n-\treturn true;\n-\n-      // All fields of a struct must be exported, or the assignment\n-      // must be in the same package.\n-      if (check_hidden_fields && rhs != NULL && !rhs->is_undefined())\n-\t{\n-\t  if (lhs->has_hidden_fields(NULL, reason)\n-\t      || rhs->has_hidden_fields(NULL, reason))\n-\t    return false;\n-\t}\n-    }\n+  // Any value may be assigned to the blank identifier.\n+  if (lhs != NULL\n+      && !lhs->is_undefined()\n+      && lhs->is_sink_type())\n+    return true;\n \n   // Identical types are assignable.\n   if (Type::are_identical(lhs, rhs, true, reason))\n@@ -720,25 +707,6 @@ Type::are_assignable_check_hidden(const Type* lhs, const Type* rhs,\n   return false;\n }\n \n-// Return true if a value with type RHS may be assigned to a variable\n-// with type LHS.  If REASON is not NULL, set *REASON to the reason\n-// the types are not assignable.\n-\n-bool\n-Type::are_assignable(const Type* lhs, const Type* rhs, std::string* reason)\n-{\n-  return Type::are_assignable_check_hidden(lhs, rhs, false, reason);\n-}\n-\n-// Like are_assignable but don't check for hidden fields.\n-\n-bool\n-Type::are_assignable_hidden_ok(const Type* lhs, const Type* rhs,\n-\t\t\t       std::string* reason)\n-{\n-  return Type::are_assignable_check_hidden(lhs, rhs, false, reason);\n-}\n-\n // Return true if a value with type RHS may be converted to type LHS.\n // If REASON is not NULL, set *REASON to the reason the types are not\n // convertible.\n@@ -833,25 +801,6 @@ Type::are_convertible(const Type* lhs, const Type* rhs, std::string* reason)\n   return false;\n }\n \n-// Return whether this type has any hidden fields.  This is only a\n-// possibility for a few types.\n-\n-bool\n-Type::has_hidden_fields(const Named_type* within, std::string* reason) const\n-{\n-  switch (this->forwarded()->classification_)\n-    {\n-    case TYPE_NAMED:\n-      return this->named_type()->named_type_has_hidden_fields(reason);\n-    case TYPE_STRUCT:\n-      return this->struct_type()->struct_has_hidden_fields(within, reason);\n-    case TYPE_ARRAY:\n-      return this->array_type()->array_has_hidden_fields(within, reason);\n-    default:\n-      return false;\n-    }\n-}\n-\n // Return a hash code for the type to be used for method lookup.\n \n unsigned int\n@@ -4828,49 +4777,6 @@ Struct_type::is_identical(const Struct_type* t,\n   return true;\n }\n \n-// Whether this struct type has any hidden fields.\n-\n-bool\n-Struct_type::struct_has_hidden_fields(const Named_type* within,\n-\t\t\t\t      std::string* reason) const\n-{\n-  const Struct_field_list* fields = this->fields();\n-  if (fields == NULL)\n-    return false;\n-  const Package* within_package = (within == NULL\n-\t\t\t\t   ? NULL\n-\t\t\t\t   : within->named_object()->package());\n-  for (Struct_field_list::const_iterator pf = fields->begin();\n-       pf != fields->end();\n-       ++pf)\n-    {\n-      if (within_package != NULL\n-\t  && !pf->is_anonymous()\n-\t  && Gogo::is_hidden_name(pf->field_name()))\n-\t{\n-\t  if (reason != NULL)\n-\t    {\n-\t      std::string within_name = within->named_object()->message_name();\n-\t      std::string name = Gogo::message_name(pf->field_name());\n-\t      size_t bufsize = 200 + within_name.length() + name.length();\n-\t      char* buf = new char[bufsize];\n-\t      snprintf(buf, bufsize,\n-\t\t       _(\"implicit assignment of %s%s%s hidden field %s%s%s\"),\n-\t\t       open_quote, within_name.c_str(), close_quote,\n-\t\t       open_quote, name.c_str(), close_quote);\n-\t      reason->assign(buf);\n-\t      delete[] buf;\n-\t    }\n-\t  return true;\n-\t}\n-\n-      if (pf->type()->has_hidden_fields(within, reason))\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n // Whether comparisons of this struct type are simple identity\n // comparisons.\n \n@@ -8633,19 +8539,6 @@ Named_type::interface_method_table(Interface_type* interface, bool is_pointer)\n                                       &this->pointer_interface_method_tables_);\n }\n \n-// Return whether a named type has any hidden fields.\n-\n-bool\n-Named_type::named_type_has_hidden_fields(std::string* reason) const\n-{\n-  if (this->seen_)\n-    return false;\n-  this->seen_ = true;\n-  bool ret = this->type_->has_hidden_fields(this, reason);\n-  this->seen_ = false;\n-  return ret;\n-}\n-\n // Look for a use of a complete type within another type.  This is\n // used to check that we don't try to use a type within itself.\n \n@@ -9772,17 +9665,8 @@ Type::build_one_stub_method(Gogo* gogo, Method* method,\n   go_assert(func != NULL);\n   Call_expression* call = Expression::make_call(func, arguments, is_varargs,\n \t\t\t\t\t\tlocation);\n-  call->set_hidden_fields_are_ok();\n \n-  Statement* s = Statement::make_return_from_call(call, location);\n-  Return_statement* retstat = s->return_statement();\n-  if (retstat != NULL)\n-    {\n-      // We can return values with hidden fields from a stub.  This is\n-      // necessary if the method is itself hidden.\n-      retstat->set_hidden_fields_are_ok();\n-    }\n-  gogo->add_statement(s);\n+  gogo->add_statement(Statement::make_return_from_call(call, location));\n }\n \n // Apply FIELD_INDEXES to EXPR.  The field indexes have to be applied"}, {"sha": "60de22e1fe148818821cc1e3a83e30f95322fbdd", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 4, "deletions": 39, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5900d7553a7e9bf90d6bfeca0df90ab250b2c657/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=5900d7553a7e9bf90d6bfeca0df90ab250b2c657", "patch": "@@ -611,27 +611,12 @@ class Type\n   static bool\n   are_assignable(const Type* lhs, const Type* rhs, std::string* reason);\n \n-  // Return true if a value with type RHS is assignable to a variable\n-  // with type LHS, ignoring any assignment of hidden fields\n-  // (unexported fields of a type imported from another package).\n-  // This is like the are_assignable method.\n-  static bool\n-  are_assignable_hidden_ok(const Type* lhs, const Type* rhs,\n-\t\t\t   std::string* reason);\n-\n   // Return true if a value with type RHS may be converted to type\n   // LHS.  If this returns false, and REASON is not NULL, it sets\n   // *REASON.\n   static bool\n   are_convertible(const Type* lhs, const Type* rhs, std::string* reason);\n \n-  // Whether this type has any hidden fields which are not visible in\n-  // the current compilation, such as a field whose name begins with a\n-  // lower case letter in a struct imported from a different package.\n-  // WITHIN is not NULL if we are looking at fields in a named type.\n-  bool\n-  has_hidden_fields(const Named_type* within, std::string* reason) const;\n-\n   // Return true if values of this type can be compared using an\n   // identity function which gets nothing but a pointer to the value\n   // and a size.\n@@ -1160,11 +1145,6 @@ class Type\n \t    : NULL);\n   }\n \n-  // Support for are_assignable and are_assignable_hidden_ok.\n-  static bool\n-  are_assignable_check_hidden(const Type* lhs, const Type* rhs,\n-\t\t\t      bool check_hidden_fields, std::string* reason);\n-\n   // Map unnamed types to type descriptor decls.\n   typedef Unordered_map_hash(const Type*, Bvariable*, Type_hash_identical,\n \t\t\t     Type_identical) Type_descriptor_vars;\n@@ -2236,12 +2216,6 @@ class Struct_type : public Type\n   bool\n   is_identical(const Struct_type* t, bool errors_are_identical) const;\n \n-  // Whether this struct type has any hidden fields.  This returns\n-  // true if any fields have hidden names, or if any non-pointer\n-  // anonymous fields have types with hidden fields.\n-  bool\n-  struct_has_hidden_fields(const Named_type* within, std::string*) const;\n-\n   // Return whether NAME is a local field which is not exported.  This\n   // is only used for better error reporting.\n   bool\n@@ -2403,11 +2377,6 @@ class Array_type : public Type\n   bool\n   is_identical(const Array_type* t, bool errors_are_identical) const;\n \n-  // Whether this type has any hidden fields.\n-  bool\n-  array_has_hidden_fields(const Named_type* within, std::string* reason) const\n-  { return this->element_type_->has_hidden_fields(within, reason); }\n-\n   // Return an expression for the pointer to the values in an array.\n   Expression*\n   get_value_pointer(Gogo*, Expression* array) const;\n@@ -3037,10 +3006,6 @@ class Named_type : public Type\n   Expression*\n   interface_method_table(Interface_type* interface, bool is_pointer);\n \n-  // Whether this type has any hidden fields.\n-  bool\n-  named_type_has_hidden_fields(std::string* reason) const;\n-\n   // Note that a type must be converted to the backend representation\n   // before we convert this type.\n   void\n@@ -3160,10 +3125,10 @@ class Named_type : public Type\n   bool is_circular_;\n   // Whether this type has been verified.\n   bool is_verified_;\n-  // In a recursive operation such as has_hidden_fields, this flag is\n-  // used to prevent infinite recursion when a type refers to itself.\n-  // This is mutable because it is always reset to false when the\n-  // function exits.\n+  // In a recursive operation such as has_pointer, this flag is used\n+  // to prevent infinite recursion when a type refers to itself.  This\n+  // is mutable because it is always reset to false when the function\n+  // exits.\n   mutable bool seen_;\n   // Like seen_, but used only by do_compare_is_identity.\n   bool seen_in_compare_is_identity_;"}]}