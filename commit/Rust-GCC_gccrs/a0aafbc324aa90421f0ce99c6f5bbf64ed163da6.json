{"sha": "a0aafbc324aa90421f0ce99c6f5bbf64ed163da6", "node_id": "C_kwDOANBUbNoAKGEwYWFmYmMzMjRhYTkwNDIxZjBjZTk5YzZmNWJiZjY0ZWQxNjNkYTY", "commit": {"author": {"name": "Jose E. Marchesi", "email": "jose.marchesi@oracle.com", "date": "2022-08-04T19:16:10Z"}, "committer": {"name": "Jose E. Marchesi", "email": "jose.marchesi@oracle.com", "date": "2022-09-29T10:39:04Z"}, "message": "place `const volatile' objects in read-only sections\n\nIt is common for C BPF programs to use variables that are implicitly\nset by the BPF loader and run-time.  It is also necessary for these\nvariables to be stored in read-only storage so the BPF verifier\nrecognizes them as such.  This leads to declarations using both\n`const' and `volatile' qualifiers, like this:\n\n  const volatile unsigned char is_allow_list = 0;\n\nWhere `volatile' is used to avoid the compiler to optimize out the\nvariable, or turn it into a constant, and `const' to make sure it is\nplaced in .rodata.\n\nNow, it happens that:\n\n- GCC places `const volatile' objects in the .data section, under the\n  assumption that `volatile' somehow voids the `const'.\n\n- LLVM places `const volatile' objects in .rodata, under the\n  assumption that `volatile' is orthogonal to `const'.\n\nSo there is a divergence, that has practical consequences: it makes\nBPF programs compiled with GCC to not work properly.\n\nWhen looking into this, I found this bugzilla:\n\n  https://gcc.gnu.org/bugzilla/show_bug.cgi?id=25521\n  \"change semantics of const volatile variables\"\n\nwhich was filed back in 2005, long ago.  This report was already\nasking to put `const volatile' objects in .rodata, questioning the\ncurrent behavior.\n\nWhile discussing this in the #gcc IRC channel I was pointed out to the\nfollowing excerpt from the C18 spec:\n\n   6.7.3 Type qualifiers / 5 The properties associated with qualified\n         types are meaningful only for expressions that are\n         lval-values [note 135]\n\n   135) The implementation may place a const object that is not\n        volatile in a read-only region of storage. Moreover, the\n        implementation need not allocate storage for such an object if\n        its $ address is never used.\n\nThis footnote may be interpreted as if const objects that are volatile\nshouldn't be put in read-only storage.  Even if I personally was not\nvery convinced of that interpretation (see my earlier comment in BZ\n25521) I filed the following issue in the LLVM tracker in order to\ndiscuss the matter:\n\n  https://github.com/llvm/llvm-project/issues/56468\n\nAs you can see, Aaron Ballman, one of the LLVM hackers, asked the WG14\nreflectors about this.  He reported that the reflectors don't think\nfootnote 135 has any normative value.\n\nSo, not having a normative mandate on either direction, there are two\noptions:\n\na) To change GCC to place `const volatile' objects in .rodata instead\n   of .data.\n\nb) To change LLVM to place `const volatile' objects in .data instead\n   of .rodata.\n\nConsidering that:\n\n- One target (bpf-unknown-none) breaks with the current GCC behavior.\n\n- No target/platform relies on the GCC behavior, that we know.\n\n- Changing the LLVM behavior at this point would be very severely\n  traumatic for the BPF people and their users.\n\nI think the right thing to do at this point is a).\nTherefore this patch.\n\nRegtested in x86_64-linux-gnu and bpf-unknown-none.\nNo regressions observed.\n\ngcc/ChangeLog:\n\n\tPR middle-end/25521\n\t* varasm.cc (categorize_decl_for_section): Place `const volatile'\n\tobjects in read-only sections.\n\t(default_select_section): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/25521\n\t* lib/target-supports.exp (check_effective_target_elf): Define.\n\t* gcc.dg/pr25521.c: New test.", "tree": {"sha": "eddc12edd861ec7ab122bcf751afd114ba650fcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eddc12edd861ec7ab122bcf751afd114ba650fcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0aafbc324aa90421f0ce99c6f5bbf64ed163da6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0aafbc324aa90421f0ce99c6f5bbf64ed163da6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0aafbc324aa90421f0ce99c6f5bbf64ed163da6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0aafbc324aa90421f0ce99c6f5bbf64ed163da6/comments", "author": {"login": "jemarch", "id": 7061875, "node_id": "MDQ6VXNlcjcwNjE4NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jemarch", "html_url": "https://github.com/jemarch", "followers_url": "https://api.github.com/users/jemarch/followers", "following_url": "https://api.github.com/users/jemarch/following{/other_user}", "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions", "organizations_url": "https://api.github.com/users/jemarch/orgs", "repos_url": "https://api.github.com/users/jemarch/repos", "events_url": "https://api.github.com/users/jemarch/events{/privacy}", "received_events_url": "https://api.github.com/users/jemarch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jemarch", "id": 7061875, "node_id": "MDQ6VXNlcjcwNjE4NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jemarch", "html_url": "https://github.com/jemarch", "followers_url": "https://api.github.com/users/jemarch/followers", "following_url": "https://api.github.com/users/jemarch/following{/other_user}", "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions", "organizations_url": "https://api.github.com/users/jemarch/orgs", "repos_url": "https://api.github.com/users/jemarch/repos", "events_url": "https://api.github.com/users/jemarch/events{/privacy}", "received_events_url": "https://api.github.com/users/jemarch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f52c8caa312d0b2ae2f36df1b6164a508d5feaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f52c8caa312d0b2ae2f36df1b6164a508d5feaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f52c8caa312d0b2ae2f36df1b6164a508d5feaf"}], "stats": {"total": 23, "additions": 20, "deletions": 3}, "files": [{"sha": "74fe2ae662675d60c654aa140959e62ec1bbd271", "filename": "gcc/testsuite/gcc.dg/pr25521.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0aafbc324aa90421f0ce99c6f5bbf64ed163da6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25521.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0aafbc324aa90421f0ce99c6f5bbf64ed163da6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25521.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr25521.c?ref=a0aafbc324aa90421f0ce99c6f5bbf64ed163da6", "patch": "@@ -0,0 +1,10 @@\n+/* PR middle-end/25521 - place `const volatile' objects in read-only\n+   sections.\n+\n+   { dg-require-effective-target elf }\n+   { dg-do compile } */\n+\n+const volatile int foo = 30;\n+\n+\n+/* { dg-final { scan-assembler \"\\\\.rodata\" } } */"}, {"sha": "2a2dd05db1eab519d519e8b104081eaea4d51e34", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0aafbc324aa90421f0ce99c6f5bbf64ed163da6/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0aafbc324aa90421f0ce99c6f5bbf64ed163da6/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=a0aafbc324aa90421f0ce99c6f5bbf64ed163da6", "patch": "@@ -477,6 +477,16 @@ proc check_effective_target_alias { } {\n     }\n }\n \n+# Returns 1 if the target uses the ELF object format, 0 otherwise.\n+\n+proc check_effective_target_elf { } {\n+    if { [gcc_target_object_format] == \"elf\" } {\n+\treturn 1;\n+    } else {\n+\treturn 0;\n+    }\n+}\n+\n # Returns 1 if the target toolchain supports ifunc, 0 otherwise.\n \n proc check_ifunc_available { } {"}, {"sha": "423f3f91af8a4c111019df1a72c245f803b0e4d9", "filename": "gcc/varasm.cc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0aafbc324aa90421f0ce99c6f5bbf64ed163da6/gcc%2Fvarasm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0aafbc324aa90421f0ce99c6f5bbf64ed163da6/gcc%2Fvarasm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.cc?ref=a0aafbc324aa90421f0ce99c6f5bbf64ed163da6", "patch": "@@ -6967,7 +6967,6 @@ default_select_section (tree decl, int reloc,\n     {\n       if (! ((flag_pic && reloc)\n \t     || !TREE_READONLY (decl)\n-\t     || TREE_SIDE_EFFECTS (decl)\n \t     || !TREE_CONSTANT (decl)))\n \treturn readonly_data_section;\n     }\n@@ -7001,7 +7000,6 @@ categorize_decl_for_section (const_tree decl, int reloc)\n       if (bss_initializer_p (decl))\n \tret = SECCAT_BSS;\n       else if (! TREE_READONLY (decl)\n-\t       || TREE_SIDE_EFFECTS (decl)\n \t       || (DECL_INITIAL (decl)\n \t\t   && ! TREE_CONSTANT (DECL_INITIAL (decl))))\n \t{\n@@ -7042,7 +7040,6 @@ categorize_decl_for_section (const_tree decl, int reloc)\n   else if (TREE_CODE (decl) == CONSTRUCTOR)\n     {\n       if ((reloc & targetm.asm_out.reloc_rw_mask ())\n-\t  || TREE_SIDE_EFFECTS (decl)\n \t  || ! TREE_CONSTANT (decl))\n \tret = SECCAT_DATA;\n       else"}]}