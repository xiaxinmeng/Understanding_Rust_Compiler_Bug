{"sha": "e7c8ff569c1183610a1ff25c8fb4756be078dc75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdjOGZmNTY5YzExODM2MTBhMWZmMjVjOGZiNDc1NmJlMDc4ZGM3NQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-07-10T05:11:00Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-07-10T05:11:00Z"}, "message": "re PR fortran/32157 (intrinsic function name conflicts with subroutine if present in the same file)\n\n2007-07-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/32157\n\t* resolve.c (is_external_proc): New function.  Adds test that\n\tthe symbol is not an intrinsic procedure.\n\t* (resolve_function, resolve_call): Replace logical statements\n\twith call to is_external_proc.\n\n\tPR fortran/32689\n\t* simplify.c (gfc_simplify_transfer): If mold has rank, the\n\tresult is an array.\n\n\tPR fortran/32634\n\t* module.c (write_generic): Write the local name of the\n\tinterface. \n\n\n2007-07-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/32157\n\t* gfortran.dg/overload_2.f90: New test.\n\n\tPR fortran/32689\n\t* gfortran.dg/transfer_simplify_5.f90\n\n\tPR fortran/32634\n\t* gfortran.dg/interface_15.f90: New test.\n\nFrom-SVN: r126509", "tree": {"sha": "1cdd07b79dbb5fed84581b617a6a44a8f7aa043b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cdd07b79dbb5fed84581b617a6a44a8f7aa043b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7c8ff569c1183610a1ff25c8fb4756be078dc75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c8ff569c1183610a1ff25c8fb4756be078dc75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7c8ff569c1183610a1ff25c8fb4756be078dc75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c8ff569c1183610a1ff25c8fb4756be078dc75/comments", "author": null, "committer": null, "parents": [{"sha": "89ab46599d72839cb0b823baaaad4b76b384a543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ab46599d72839cb0b823baaaad4b76b384a543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ab46599d72839cb0b823baaaad4b76b384a543"}], "stats": {"total": 223, "additions": 209, "deletions": 14}, "files": [{"sha": "d7c4e706958f77c16631c2f5a2ebc63f8b606c33", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e7c8ff569c1183610a1ff25c8fb4756be078dc75", "patch": "@@ -1,3 +1,19 @@\n+2007-07-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/32157\n+\t* resolve.c (is_external_proc): New function.  Adds test that\n+\tthe symbol is not an intrinsic procedure.\n+\t* (resolve_function, resolve_call): Replace logical statements\n+\twith call to is_external_proc.\n+\n+\tPR fortran/32689\n+\t* simplify.c (gfc_simplify_transfer): If mold has rank, the\n+\tresult is an array.\n+\n+\tPR fortran/32634\n+\t* module.c (write_generic): Write the local name of the\n+\tinterface. \n+\n 2007-07-09  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/29459"}, {"sha": "1471b8bf5805ef8c65bda9088b979eb2f63b2ef4", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=e7c8ff569c1183610a1ff25c8fb4756be078dc75", "patch": "@@ -3947,14 +3947,30 @@ write_operator (gfc_user_op *uop)\n static void\n write_generic (gfc_symbol *sym)\n {\n+  const char *p;\n+  int nuse, j;\n+\n   if (sym->generic == NULL\n       || !gfc_check_access (sym->attr.access, sym->ns->default_access))\n     return;\n \n   if (sym->module == NULL)\n     sym->module = gfc_get_string (module_name);\n \n-  mio_symbol_interface (&sym->name, &sym->module, &sym->generic);\n+  /* See how many use names there are.  If none, go through the loop\n+     at least once.  */\n+  nuse = number_use_names (sym->name);\n+  if (nuse == 0)\n+    nuse = 1;\n+\n+  for (j = 1; j <= nuse; j++)\n+    {\n+      /* Get the jth local name for this symbol.  */\n+      p = find_use_name_n (sym->name, &j);\n+\n+      /* Make an interface with that name.  */\n+      mio_symbol_interface (&p, &sym->module, &sym->generic);\n+    }\n }\n \n "}, {"sha": "911d5ecd3aefd3057934319be49c0a70968ec7de", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e7c8ff569c1183610a1ff25c8fb4756be078dc75", "patch": "@@ -1552,6 +1552,22 @@ resolve_unknown_f (gfc_expr *expr)\n }\n \n \n+/* Return true, if the symbol is an external procedure.  */\n+static bool\n+is_external_proc (gfc_symbol *sym)\n+{\n+  if (!sym->attr.dummy && !sym->attr.contained\n+\t&& !(sym->attr.intrinsic\n+\t      || gfc_intrinsic_name (sym->name, sym->attr.subroutine))\n+\t&& sym->attr.proc != PROC_ST_FUNCTION\n+\t&& !sym->attr.use_assoc\n+\t&& sym->name)\n+    return true;\n+  else\n+    return false;\n+}\n+\n+\n /* Figure out if a function reference is pure or not.  Also set the name\n    of the function for a potential error message.  Return nonzero if the\n    function is PURE, zero if not.  */\n@@ -1893,12 +1909,8 @@ resolve_function (gfc_expr *expr)\n       return FAILURE;\n     }\n \n-  /* If the procedure is not internal, a statement function or a module\n-     procedure,it must be external and should be checked for usage.  */\n-  if (sym && !sym->attr.dummy && !sym->attr.contained\n-      && sym->attr.proc != PROC_ST_FUNCTION\n-      && !sym->attr.use_assoc\n-      && sym->name  )\n+  /* If the procedure is external, check for usage.  */\n+  if (sym && is_external_proc (sym))\n     resolve_global_procedure (sym, &expr->where, 0);\n \n   /* Switch off assumed size checking and do this again for certain kinds\n@@ -2490,12 +2502,8 @@ resolve_call (gfc_code *c)\n       return FAILURE;\n     }\n \n-  /* If the procedure is not internal or module, it must be external and\n-     should be checked for usage.  */\n-  if (c->symtree && c->symtree->n.sym\n-      && !c->symtree->n.sym->attr.dummy\n-      && !c->symtree->n.sym->attr.contained\n-      && !c->symtree->n.sym->attr.use_assoc)\n+  /* If external, check for usage.  */\n+  if (c->symtree && is_external_proc (c->symtree->n.sym))\n     resolve_global_procedure (c->symtree->n.sym, &c->loc, 1);\n \n   /* Subroutines without the RECURSIVE attribution are not allowed to"}, {"sha": "6b8eb43c6b08849a8de2dde6e10c13e0b8ce4339", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=e7c8ff569c1183610a1ff25c8fb4756be078dc75", "patch": "@@ -3924,7 +3924,7 @@ gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n   \n   /* Set the number of elements in the result, and determine its size.  */\n   result_elt_size = gfc_target_expr_size (mold_element);\n-  if (mold->expr_type == EXPR_ARRAY || size)\n+  if (mold->expr_type == EXPR_ARRAY || mold->rank || size)\n     {\n       int result_length;\n "}, {"sha": "20ec01f753f120605c99e32540c171a7da616570", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e7c8ff569c1183610a1ff25c8fb4756be078dc75", "patch": "@@ -1,3 +1,14 @@\n+2007-07-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/32157\n+\t* gfortran.dg/overload_2.f90: New test.\n+\n+\tPR fortran/32689\n+\t* gfortran.dg/transfer_simplify_5.f90\n+\n+\tPR fortran/32634\n+\t* gfortran.dg/interface_15.f90: New test.\n+\n 2007-07-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR libfortran/32336"}, {"sha": "8be9d684a66269a73ea29c2fb43626f09af231fe", "filename": "gcc/testsuite/gfortran.dg/interface_16.f90", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_16.f90?ref=e7c8ff569c1183610a1ff25c8fb4756be078dc75", "patch": "@@ -0,0 +1,101 @@\n+! { dg-do compile }\n+! This tests the fix for PR32634, in which the generic interface\n+! in foo_pr_mod was given the original rather than the local name.\n+! This meant that the original name had to be used in the calll\n+! in foo_sub.\n+!\n+! Contributed by Salvatore Filippone <salvatore.filippone@uniroma2.it>\n+\n+module foo_base_mod\n+  type foo_dmt\n+    real(kind(1.d0)), allocatable  :: rv(:)\n+    integer, allocatable :: iv1(:), iv2(:)\n+  end type foo_dmt\n+  type foo_zmt\n+    complex(kind(1.d0)), allocatable  :: rv(:)\n+    integer, allocatable  :: iv1(:), iv2(:)\n+  end type foo_zmt\n+  type foo_cdt\n+     integer, allocatable :: md(:)\n+     integer, allocatable :: hi(:), ei(:)\n+  end type foo_cdt\n+end module foo_base_mod\n+\n+module bar_prt\n+  use foo_base_mod, only : foo_dmt, foo_zmt, foo_cdt\n+  type bar_dbprt\n+    type(foo_dmt), allocatable :: av(:) \n+    real(kind(1.d0)), allocatable      :: d(:)  \n+    type(foo_cdt)                :: cd \n+  end type bar_dbprt\n+  type bar_dprt\n+    type(bar_dbprt), allocatable  :: bpv(:) \n+  end type bar_dprt\n+  type bar_zbprt\n+    type(foo_zmt), allocatable :: av(:) \n+    complex(kind(1.d0)), allocatable   :: d(:)  \n+    type(foo_cdt)                :: cd \n+  end type bar_zbprt\n+  type bar_zprt\n+    type(bar_zbprt), allocatable  :: bpv(:) \n+  end type bar_zprt\n+end module bar_prt\n+\n+module bar_pr_mod\n+  use bar_prt\n+  interface bar_pwrk\n+    subroutine bar_dppwrk(pr,x,y,cd,info,trans,work)\n+      use foo_base_mod\n+      use bar_prt\n+      type(foo_cdt),intent(in)    :: cd\n+      type(bar_dprt), intent(in)  :: pr\n+      real(kind(0.d0)),intent(inout)    :: x(:), y(:)\n+      integer, intent(out)              :: info\n+      character(len=1), optional        :: trans\n+      real(kind(0.d0)),intent(inout), optional, target :: work(:)\n+    end subroutine bar_dppwrk\n+    subroutine bar_zppwrk(pr,x,y,cd,info,trans,work)\n+      use foo_base_mod\n+      use bar_prt\n+      type(foo_cdt),intent(in)    :: cd\n+      type(bar_zprt), intent(in)  :: pr\n+      complex(kind(0.d0)),intent(inout) :: x(:), y(:)\n+      integer, intent(out)              :: info\n+      character(len=1), optional        :: trans\n+      complex(kind(0.d0)),intent(inout), optional, target :: work(:)\n+    end subroutine bar_zppwrk\n+  end interface\n+end module bar_pr_mod\n+\n+module foo_pr_mod\n+  use bar_prt, &\n+       & foo_dbprt  => bar_dbprt,&\n+       & foo_zbprt  => bar_zbprt,&\n+       & foo_dprt   => bar_dprt,&\n+       & foo_zprt   => bar_zprt \n+  use bar_pr_mod, &\n+       & foo_pwrk  => bar_pwrk\n+end module foo_pr_mod\n+\n+Subroutine foo_sub(a,pr,b,x,eps,cd,info)\n+  use foo_base_mod\n+  use foo_pr_mod\n+  Implicit None\n+!!$  parameters \n+  Type(foo_dmt), Intent(in)  :: a\n+  Type(foo_dprt), Intent(in)   :: pr \n+  Type(foo_cdt), Intent(in)    :: cd\n+  Real(Kind(1.d0)), Intent(in)       :: b(:)\n+  Real(Kind(1.d0)), Intent(inout)    :: x(:)\n+  Real(Kind(1.d0)), Intent(in)       :: eps\n+  integer, intent(out)               :: info\n+!!$   Local data\n+  Real(Kind(1.d0)), allocatable, target   :: aux(:),wwrk(:,:)\n+  Real(Kind(1.d0)), allocatable   :: p(:), f(:)\n+  info = 0\n+  Call foo_pwrk(pr,p,f,cd,info,work=aux)  ! This worked if bar_pwrk was called!\n+  return\n+End Subroutine foo_sub\n+\n+! { dg-final { cleanup-modules \"foo_base_mod foo_pr_mod bar_pr_mod bar_prt\" } }\n+"}, {"sha": "feefb4607228cf4e424c6bb239bcb7341eab64bb", "filename": "gcc/testsuite/gfortran.dg/overload_2.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ftestsuite%2Fgfortran.dg%2Foverload_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ftestsuite%2Fgfortran.dg%2Foverload_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Foverload_2.f90?ref=e7c8ff569c1183610a1ff25c8fb4756be078dc75", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+! Test the fix for PR32157, in which overloading 'LEN', as\n+! in 'test' below would cause a compile error.\n+!\n+! Contributed by Michael Richmond <michael.a.richmond@nasa.gov>\n+!\n+subroutine len(c)\n+  implicit none\n+  character :: c\n+  c = \"X\"\n+end subroutine len\n+\n+subroutine test()\n+  implicit none\n+  character :: str\n+  external len\n+  call len(str)\n+  if(str /= \"X\") call abort()\n+end subroutine test\n+\n+PROGRAM VAL\n+ implicit none\n+ external test\n+ intrinsic len\n+ call test()\n+ if(len(\" \") /= 1) call abort()\n+END"}, {"sha": "65905b87a564a4b91b9ef37afca480ca4341186b", "filename": "gcc/testsuite/gfortran.dg/transfer_simplify_5.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c8ff569c1183610a1ff25c8fb4756be078dc75/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_5.f90?ref=e7c8ff569c1183610a1ff25c8fb4756be078dc75", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+! Tests the fix for PR32689, in which the TRANSFER with MOLD\n+! an array variable, as below, did not simplify.\n+!\n+! Contributed by Harald Anlauf <anlauf@gmx.de>\n+!\n+program gfcbug67\n+  implicit none\n+\n+  type mytype\n+     integer, pointer :: i(:) => NULL ()\n+  end type mytype\n+  type(mytype) :: t\n+\n+  print *, size (transfer (1, t% i))\n+end program gfcbug67"}]}