{"sha": "91b1ca65f39ecca8525536d3f4dfa80144e68afd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFiMWNhNjVmMzllY2NhODUyNTUzNmQzZjRkZmE4MDE0NGU2OGFmZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-11-14T01:45:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-11-14T01:45:19Z"}, "message": "re PR c++/20293 (Wrong diagnostic for ambiguous access)\n\n\tPR c++/20293\n\t* cxx-pretty-print.c (pp_cxx_statement): Print qualifying scopes\n\tfor namespaces.\n\t(pp_cxx_original_namespace_definition): Likewise.\n\t* name-lookup.c (ambiguous_decl): Don't issue error messages;\n\tinstead return lists of ambiguous candidates.\n\t(select_decl): Handle ambiguous namespace lookups.\n\t* parser.c (cp_token): Add ambiguous_p.\n\t(cp_lexer_get_preprocessor_token): Set it.\n\t(cp_parser_diagnose_invalid_type_name): Avoid duplicate messages\n\twhen a qualified name uses an invalid scope. \n\t(cp_parser_primary_expression): Print ambiguous candidates.\n\t(cp_parser_type_parameter): Adjust comment to reflect new\n\tparameter name for cp_parser_lookup_name.\n\t(cp_parser_template_argument): Likewise.\n\t(cp_parser_elaborated_type_specifier): Likewise.\n\t(cp_parser_namespace_name): Likewise.\n\t(cp_parser_class_name): Print ambiguous candidates.\n\t(cp_parser_lookup_name): Rename ambiguous_p parameter to\n\tambiguous_decls.  Use it to return a list of ambiguous candiates\n\twhen a lookup is ambiguous.\n\t(cp_parser_lookup_name_simple): Adjust comment to reflect new\n\tparameter name for cp_parser_lookup_name.\n\t\n\tPR c++/20293\n\t* g++.dg/parse/ambig4.C: New test.\n\t* g++.dg/tc1/dr101.C: Adjust error markers.\n\t* g++.dg/lookup/strong-using-2.C: Likewise.\n\t* g++.dg/lookup/ambig5.C: Likewise.\n\t* g++.dg/lookup/ambig4.C: Likewise.\n\t* g++.dg/parse/crash22.C: Likewise.\n\nFrom-SVN: r106879", "tree": {"sha": "773dff07d2e51d7d8497844932653849d2201ca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/773dff07d2e51d7d8497844932653849d2201ca9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91b1ca65f39ecca8525536d3f4dfa80144e68afd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b1ca65f39ecca8525536d3f4dfa80144e68afd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91b1ca65f39ecca8525536d3f4dfa80144e68afd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b1ca65f39ecca8525536d3f4dfa80144e68afd/comments", "author": null, "committer": null, "parents": [{"sha": "43258b67a9f414823ec75d2b9c2d9596c6317824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43258b67a9f414823ec75d2b9c2d9596c6317824", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43258b67a9f414823ec75d2b9c2d9596c6317824"}], "stats": {"total": 240, "additions": 171, "deletions": 69}, "files": [{"sha": "4fafe495d2e68e2cf3f4924c1cc2d39e2bffabe4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=91b1ca65f39ecca8525536d3f4dfa80144e68afd", "patch": "@@ -1,3 +1,29 @@\n+2005-11-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/20293\n+\t* cxx-pretty-print.c (pp_cxx_statement): Print qualifying scopes\n+\tfor namespaces.\n+\t(pp_cxx_original_namespace_definition): Likewise.\n+\t* name-lookup.c (ambiguous_decl): Don't issue error messages;\n+\tinstead return lists of ambiguous candidates.\n+\t(select_decl): Handle ambiguous namespace lookups.\n+\t* parser.c (cp_token): Add ambiguous_p.\n+\t(cp_lexer_get_preprocessor_token): Set it.\n+\t(cp_parser_diagnose_invalid_type_name): Avoid duplicate messages\n+\twhen a qualified name uses an invalid scope. \n+\t(cp_parser_primary_expression): Print ambiguous candidates.\n+\t(cp_parser_type_parameter): Adjust comment to reflect new\n+\tparameter name for cp_parser_lookup_name.\n+\t(cp_parser_template_argument): Likewise.\n+\t(cp_parser_elaborated_type_specifier): Likewise.\n+\t(cp_parser_namespace_name): Likewise.\n+\t(cp_parser_class_name): Print ambiguous candidates.\n+\t(cp_parser_lookup_name): Rename ambiguous_p parameter to\n+\tambiguous_decls.  Use it to return a list of ambiguous candiates\n+\twhen a lookup is ambiguous.\n+\t(cp_parser_lookup_name_simple): Adjust comment to reflect new\n+\tparameter name for cp_parser_lookup_name.\n+\t\n 2005-11-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/24780"}, {"sha": "cdaf470ce26e2336ffbb3a111f917e8813c566ac", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=91b1ca65f39ecca8525536d3f4dfa80144e68afd", "patch": "@@ -1514,6 +1514,8 @@ pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n     case USING_STMT:\n       pp_cxx_identifier (pp, \"using\");\n       pp_cxx_identifier (pp, \"namespace\");\n+      if (DECL_CONTEXT (t))\n+\tpp_cxx_nested_name_specifier (pp, DECL_CONTEXT (t));\n       pp_cxx_qualified_id (pp, USING_STMT_NAMESPACE (t));\n       break;\n \n@@ -1701,6 +1703,8 @@ static void\n pp_cxx_original_namespace_definition (cxx_pretty_printer *pp, tree t)\n {\n   pp_cxx_identifier (pp, \"namespace\");\n+  if (DECL_CONTEXT (t))\n+    pp_cxx_nested_name_specifier (pp, DECL_CONTEXT (t));\n   if (DECL_NAME (t))\n     pp_cxx_unqualified_id (pp, t);\n   pp_cxx_whitespace (pp);\n@@ -1723,10 +1727,15 @@ static void\n pp_cxx_namespace_alias_definition (cxx_pretty_printer *pp, tree t)\n {\n   pp_cxx_identifier (pp, \"namespace\");\n+  if (DECL_CONTEXT (t))\n+    pp_cxx_nested_name_specifier (pp, DECL_CONTEXT (t));\n   pp_cxx_unqualified_id (pp, t);\n   pp_cxx_whitespace (pp);\n   pp_equal (pp);\n   pp_cxx_whitespace (pp);\n+  if (DECL_CONTEXT (DECL_NAMESPACE_ALIAS (t)))\n+    pp_cxx_nested_name_specifier (pp, \n+\t\t\t\t  DECL_CONTEXT (DECL_NAMESPACE_ALIAS (t)));\n   pp_cxx_qualified_id (pp, DECL_NAMESPACE_ALIAS (t));\n   pp_cxx_semicolon (pp);\n }"}, {"sha": "20ea311196fa25bbb8816c78b422e6442021ce73", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=91b1ca65f39ecca8525536d3f4dfa80144e68afd", "patch": "@@ -3400,20 +3400,9 @@ ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n \told->value = merge_functions (old->value, val);\n       else\n \t{\n-\t  /* Some declarations are functions, some are not.  */\n-\t  if (flags & LOOKUP_COMPLAIN)\n-\t    {\n-\t      /* If we've already given this error for this lookup,\n-\t\t old->value is error_mark_node, so let's not\n-\t\t repeat ourselves.  */\n-\t      if (old->value != error_mark_node)\n-\t\t{\n-\t\t  error (\"use of %qD is ambiguous\", name);\n-\t\t  error (\"  first declared as %q+#D here\", old->value);\n-\t\t}\n-\t      error (\"  also declared as %q+#D here\", val);\n-\t    }\n-\t  old->value = error_mark_node;\n+\t  old->value = tree_cons (NULL_TREE, old->value,\n+\t\t\t\t  build_tree_list (NULL_TREE, new->value));\n+\t  TREE_TYPE (old->value) = error_mark_node;\n \t}\n     }\n   /* ... and copy the type.  */\n@@ -3609,7 +3598,8 @@ select_decl (const struct scope_binding *binding, int flags)\n   if (LOOKUP_NAMESPACES_ONLY (flags))\n     {\n       /* We are not interested in types.  */\n-      if (val && TREE_CODE (val) == NAMESPACE_DECL)\n+      if (val && (TREE_CODE (val) == NAMESPACE_DECL\n+\t\t  || TREE_CODE (val) == TREE_LIST))\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n     }"}, {"sha": "2b850c0d197ea339f1d9393af4ea7afdf64de975", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 90, "deletions": 41, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=91b1ca65f39ecca8525536d3f4dfa80144e68afd", "patch": "@@ -59,6 +59,10 @@ typedef struct cp_token GTY (())\n   BOOL_BITFIELD in_system_header : 1;\n   /* True if this token is from a context where it is implicitly extern \"C\" */\n   BOOL_BITFIELD implicit_extern_c : 1;\n+  /* True for a CPP_NAME token that is not a keyword (i.e., for which\n+     KEYWORD is RID_MAX) iff this name was looked up and found to be\n+     ambiguous.  An error has already been reported.  */\n+  BOOL_BITFIELD ambiguous_p : 1;\n   /* The value associated with this token, if any.  */\n   tree value;\n   /* The location at which this token was found.  */\n@@ -401,18 +405,22 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n   token->implicit_extern_c = is_extern_c > 0;\n \n   /* Check to see if this token is a keyword.  */\n-  if (token->type == CPP_NAME\n-      && C_IS_RESERVED_WORD (token->value))\n+  if (token->type == CPP_NAME)\n     {\n-      /* Mark this token as a keyword.  */\n-      token->type = CPP_KEYWORD;\n-      /* Record which keyword.  */\n-      token->keyword = C_RID_CODE (token->value);\n-      /* Update the value.  Some keywords are mapped to particular\n-\t entities, rather than simply having the value of the\n-\t corresponding IDENTIFIER_NODE.  For example, `__const' is\n-\t mapped to `const'.  */\n-      token->value = ridpointers[token->keyword];\n+      if (C_IS_RESERVED_WORD (token->value))\n+\t{\n+\t  /* Mark this token as a keyword.  */\n+\t  token->type = CPP_KEYWORD;\n+\t  /* Record which keyword.  */\n+\t  token->keyword = C_RID_CODE (token->value);\n+\t  /* Update the value.  Some keywords are mapped to particular\n+\t     entities, rather than simply having the value of the\n+\t     corresponding IDENTIFIER_NODE.  For example, `__const' is\n+\t     mapped to `const'.  */\n+\t  token->value = ridpointers[token->keyword];\n+\t}\n+      else\n+\ttoken->ambiguous_p = false;\n     }\n   /* Handle Objective-C++ keywords.  */\n   else if (token->type == CPP_AT_NAME)\n@@ -1699,7 +1707,7 @@ static tree cp_parser_objc_statement\n /* Utility Routines */\n \n static tree cp_parser_lookup_name\n-  (cp_parser *, tree, enum tag_types, bool, bool, bool, bool *);\n+  (cp_parser *, tree, enum tag_types, bool, bool, bool, tree *);\n static tree cp_parser_lookup_name_simple\n   (cp_parser *, tree);\n static tree cp_parser_maybe_treat_template_as_class\n@@ -2052,7 +2060,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree scope, tree id)\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     error (\"invalid use of template-name %qE without an argument list\",\n       decl);\n-  else if (!parser->scope || parser->scope == error_mark_node)\n+  else if (!parser->scope)\n     {\n       /* Issue an error message.  */\n       error (\"%qE does not name a type\", id);\n@@ -2099,7 +2107,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree scope, tree id)\n     }\n   /* Here we diagnose qualified-ids where the scope is actually correct,\n      but the identifier does not resolve to a valid type name.  */\n-  else\n+  else if (parser->scope != error_mark_node)\n     {\n       if (TREE_CODE (parser->scope) == NAMESPACE_DECL)\n \terror (\"%qE in namespace %qE does not name a type\",\n@@ -2994,17 +3002,17 @@ cp_parser_primary_expression (cp_parser *parser,\n \t/* Look up the name.  */\n \telse\n \t  {\n-\t    bool ambiguous_p;\n+\t    tree ambiguous_decls;\n \n \t    decl = cp_parser_lookup_name (parser, id_expression,\n \t\t\t\t\t  none_type,\n \t\t\t\t\t  template_p,\n \t\t\t\t\t  /*is_namespace=*/false,\n \t\t\t\t\t  /*check_dependency=*/true,\n-\t\t\t\t\t  &ambiguous_p);\n+\t\t\t\t\t  &ambiguous_decls);\n \t    /* If the lookup was ambiguous, an error will already have\n \t       been issued.  */\n-\t    if (ambiguous_p)\n+\t    if (ambiguous_decls)\n \t      return error_mark_node;\n \n \t    /* In Objective-C++, an instance variable (ivar) may be preferred\n@@ -3610,16 +3618,32 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t      token = cp_lexer_consume_token (parser->lexer);\n \t      if (!error_p)\n \t\t{\n-\t\t  tree decl;\n-\n-\t\t  decl = cp_parser_lookup_name_simple (parser, token->value);\n-\t\t  if (TREE_CODE (decl) == TEMPLATE_DECL)\n-\t\t    error (\"%qD used without template parameters\", decl);\n-\t\t  else\n-\t\t    cp_parser_name_lookup_error\n-\t\t      (parser, token->value, decl,\n-\t\t       \"is not a class or namespace\");\n-\t\t  parser->scope = NULL_TREE;\n+\t\t  if (!token->ambiguous_p)\n+\t\t    {\n+\t\t      tree decl;\n+\t\t      tree ambiguous_decls;\n+\n+\t\t      decl = cp_parser_lookup_name (parser, token->value,\n+\t\t\t\t\t\t    none_type,\n+\t\t\t\t\t\t    /*is_template=*/false,\n+\t\t\t\t\t\t    /*is_namespace=*/false,\n+\t\t\t\t\t\t    /*check_dependency=*/true,\n+\t\t\t\t\t\t    &ambiguous_decls);\n+\t\t      if (TREE_CODE (decl) == TEMPLATE_DECL)\n+\t\t\terror (\"%qD used without template parameters\", decl);\n+\t\t      else if (ambiguous_decls)\n+\t\t\t{\n+\t\t\t  error (\"reference to %qD is ambiguous\", \n+\t\t\t\t token->value);\n+\t\t\t  print_candidates (ambiguous_decls);\n+\t\t\t  decl = error_mark_node;\n+\t\t\t}\n+\t\t      else\n+\t\t\tcp_parser_name_lookup_error\n+\t\t\t  (parser, token->value, decl,\n+\t\t\t   \"is not a class or namespace\");\n+\t\t    }\n+\t\t  parser->scope = error_mark_node;\n \t\t  error_p = true;\n \t\t  /* Treat this as a successful nested-name-specifier\n \t\t     due to:\n@@ -8457,7 +8481,7 @@ cp_parser_type_parameter (cp_parser* parser)\n \t\t\t\t\t /*is_template=*/is_template,\n \t\t\t\t\t /*is_namespace=*/false,\n \t\t\t\t\t /*check_dependency=*/true,\n-\t\t\t\t\t /*ambiguous_p=*/NULL);\n+\t\t\t\t\t /*ambiguous_decls=*/NULL);\n \t    /* See if the default argument is valid.  */\n \t    default_argument\n \t      = check_template_template_default_arg (default_argument);\n@@ -8813,7 +8837,7 @@ cp_parser_template_name (cp_parser* parser,\n \t\t\t\t/*is_template=*/false,\n \t\t\t\t/*is_namespace=*/false,\n \t\t\t\tcheck_dependency_p,\n-\t\t\t\t/*ambiguous_p=*/NULL);\n+\t\t\t\t/*ambiguous_decls=*/NULL);\n   decl = maybe_get_template_decl_from_type_decl (decl);\n \n   /* If DECL is a template, then the name was a template-name.  */\n@@ -9014,7 +9038,7 @@ cp_parser_template_argument (cp_parser* parser)\n \t\t\t\t\t  /*is_template=*/template_p,\n \t\t\t\t\t  /*is_namespace=*/false,\n \t\t\t\t\t  /*check_dependency=*/true,\n-\t\t\t\t\t  /*ambiguous_p=*/NULL);\n+\t\t\t\t\t  /*ambiguous_decls=*/NULL);\n       if (TREE_CODE (argument) != TEMPLATE_DECL\n \t  && TREE_CODE (argument) != UNBOUND_CLASS_TEMPLATE)\n \tcp_parser_error (parser, \"expected template-name\");\n@@ -9937,7 +9961,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t\t\t\t\t/*is_template=*/false,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\t/*check_dependency=*/true,\n-\t\t\t\t\t/*ambiguous_p=*/NULL);\n+\t\t\t\t\t/*ambiguous_decls=*/NULL);\n \n \t  /* If we are parsing friend declaration, DECL may be a\n \t     TEMPLATE_DECL tree node here.  However, we need to check\n@@ -10233,7 +10257,7 @@ cp_parser_namespace_name (cp_parser* parser)\n \t\t\t\t\t  /*is_template=*/false,\n \t\t\t\t\t  /*is_namespace=*/true,\n \t\t\t\t\t  /*check_dependency=*/true,\n-\t\t\t\t\t  /*ambiguous_p=*/NULL);\n+\t\t\t\t\t  /*ambiguous_decls=*/NULL);\n   /* If it's not a namespace, issue an error.  */\n   if (namespace_decl == error_mark_node\n       || TREE_CODE (namespace_decl) != NAMESPACE_DECL)\n@@ -12469,9 +12493,13 @@ cp_parser_class_name (cp_parser *parser,\n   if (token->type == CPP_NAME\n       && !cp_parser_nth_token_starts_template_argument_list_p (parser, 2))\n     {\n+      cp_token *identifier_token;\n       tree identifier;\n+      bool ambiguous_p;\n \n       /* Look for the identifier.  */\n+      identifier_token = cp_lexer_peek_token (parser->lexer);\n+      ambiguous_p = identifier_token->ambiguous_p;\n       identifier = cp_parser_identifier (parser);\n       /* If the next token isn't an identifier, we are certainly not\n \t looking at a class-name.  */\n@@ -12483,6 +12511,15 @@ cp_parser_class_name (cp_parser *parser,\n \tdecl = identifier;\n       else\n \t{\n+\t  tree ambiguous_decls;\n+\t  /* If we already know that this lookup is ambiguous, then\n+\t     we've already issued an error message; there's no reason\n+\t     to check again.  */\n+\t  if (ambiguous_p)\n+\t    {\n+\t      cp_parser_simulate_error (parser);\n+\t      return error_mark_node;\n+\t    }\n \t  /* If the next token is a `::', then the name must be a type\n \t     name.\n \n@@ -12499,7 +12536,18 @@ cp_parser_class_name (cp_parser *parser,\n \t\t\t\t\t/*is_template=*/false,\n \t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\tcheck_dependency_p,\n-\t\t\t\t\t/*ambiguous_p=*/NULL);\n+\t\t\t\t\t&ambiguous_decls);\n+\t  if (ambiguous_decls)\n+\t    {\n+\t      error (\"reference to %qD is ambiguous\", identifier);\n+\t      print_candidates (ambiguous_decls);\n+\t      if (cp_parser_parsing_tentatively (parser))\n+\t\t{\n+\t\t  identifier_token->ambiguous_p = true;\n+\t\t  cp_parser_simulate_error (parser);\n+\t\t}\n+\t      return error_mark_node;\n+\t    }\n \t}\n     }\n   else\n@@ -14438,16 +14486,17 @@ cp_parser_label_declaration (cp_parser* parser)\n    If CHECK_DEPENDENCY is TRUE, names are not looked up in dependent\n    types.\n \n-   If AMBIGUOUS_P is non-NULL, it is set to true if name-lookup\n-   results in an ambiguity, and false otherwise.  */\n+   If AMBIGUOUS_DECLS is non-NULL, *AMBIGUOUS_DECLS is set to a\n+   TREE_LIST of candiates if name-lookup results in an ambiguity, and\n+   NULL_TREE otherwise.  */ \n \n static tree\n cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t       enum tag_types tag_type,\n \t\t       bool is_template, \n \t\t       bool is_namespace,\n \t\t       bool check_dependency,\n-\t\t       bool *ambiguous_p)\n+\t\t       tree *ambiguous_decls)\n {\n   int flags = 0;\n   tree decl;\n@@ -14457,8 +14506,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n     flags |= LOOKUP_COMPLAIN;\n \n   /* Assume that the lookup will be unambiguous.  */\n-  if (ambiguous_p)\n-    *ambiguous_p = false;\n+  if (ambiguous_decls)\n+    *ambiguous_decls = NULL_TREE;\n \n   /* Now that we have looked up the name, the OBJECT_TYPE (if any) is\n      no longer valid.  Note that if we are parsing tentatively, and\n@@ -14615,8 +14664,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n   /* If it's a TREE_LIST, the result of the lookup was ambiguous.  */\n   if (TREE_CODE (decl) == TREE_LIST)\n     {\n-      if (ambiguous_p)\n-\t*ambiguous_p = true;\n+      if (ambiguous_decls)\n+\t*ambiguous_decls = decl;\n       /* The error message we have to print is too complicated for\n \t cp_parser_error, so we incorporate its actions directly.  */\n       if (!cp_parser_simulate_error (parser))\n@@ -14658,7 +14707,7 @@ cp_parser_lookup_name_simple (cp_parser* parser, tree name)\n \t\t\t\t/*is_template=*/false,\n \t\t\t\t/*is_namespace=*/false,\n \t\t\t\t/*check_dependency=*/true,\n-\t\t\t\t/*ambiguous_p=*/NULL);\n+\t\t\t\t/*ambiguous_decls=*/NULL);\n }\n \n /* If DECL is a TEMPLATE_DECL that can be treated like a TYPE_DECL in"}, {"sha": "8480b51cc590f391587530421fc727437a36bff2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91b1ca65f39ecca8525536d3f4dfa80144e68afd", "patch": "@@ -1,3 +1,13 @@\n+2005-11-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/20293\n+\t* g++.dg/parse/ambig4.C: New test.\n+\t* g++.dg/tc1/dr101.C: Adjust error markers.\n+\t* g++.dg/lookup/strong-using-2.C: Likewise.\n+\t* g++.dg/lookup/ambig5.C: Likewise.\n+\t* g++.dg/lookup/ambig4.C: Likewise.\n+\t* g++.dg/parse/crash22.C: Likewise.\n+\n 2005-11-14  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* gcc.dg/pr19340.c: Skip for mmix-*-* and cris-*-*."}, {"sha": "3a74f7d1c767be43952c63d60ce9aea2ccfe4815", "filename": "gcc/testsuite/g++.dg/lookup/ambig4.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig4.C?ref=91b1ca65f39ecca8525536d3f4dfa80144e68afd", "patch": "@@ -4,11 +4,11 @@\n \n namespace N\n {\n-  int i;            // { dg-error \"declared\" }\n+  int i;            // { dg-error \"i\" }\n }\n \n-int i;              // { dg-error \"declared\" }\n+int i;              // { dg-error \"i\" }\n \n using namespace N;\n \n-void foo() { i; }   // { dg-error \"in this scope|ambiguous\" }\n+void foo() { i; }   // { dg-error \"ambiguous\" }"}, {"sha": "cebec277910785a14018f610bf02751e2ed1f947", "filename": "gcc/testsuite/g++.dg/lookup/ambig5.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig5.C?ref=91b1ca65f39ecca8525536d3f4dfa80144e68afd", "patch": "@@ -4,10 +4,10 @@\n \n namespace N\n {\n-  namespace M {}    // { dg-error \"declared\" }\n+  namespace M {}    // { dg-error \"M\" }\n }\n \n-namespace M {}      // { dg-error \"declared\" }\n+namespace M {}      // { dg-error \"M\" }\n \n using namespace N;\n using namespace M;  // { dg-error \"namespace-name|ambiguous\" }"}, {"sha": "f8b5f64fbd24d9c941db2e465d6723e9ce9a6758", "filename": "gcc/testsuite/g++.dg/lookup/strong-using-2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fstrong-using-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fstrong-using-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fstrong-using-2.C?ref=91b1ca65f39ecca8525536d3f4dfa80144e68afd", "patch": "@@ -3,10 +3,10 @@\n // { dg-do compile }\n \n namespace foo_impl {\n-  class T; // { dg-error \"first declared\" \"\" }\n+  class T; // { dg-error \"T\" \"\" }\n }\n namespace bar_impl {\n-  class T; // { dg-error \"also declared\" \"\" }\n+  class T; // { dg-error \"T\" \"\" }\n }\n namespace foo {\n   using namespace foo_impl __attribute__((strong));"}, {"sha": "868f07cf783eb4fc328807ff7653ca37894c1923", "filename": "gcc/testsuite/g++.dg/parse/ambig4.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig4.C?ref=91b1ca65f39ecca8525536d3f4dfa80144e68afd", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/20293\n+\n+namespace hide { // { dg-error \"hide\" }\n+  int k;\n+}\n+\n+namespace {\n+  int i; \n+  namespace hide { // { dg-error \"hide\" }\n+    int j; \n+  }\n+}\n+\n+void F(int) {}\n+\n+int main() {\n+  F(hide::j); // { dg-error \"ambiguous\" }\n+}"}, {"sha": "eaf4d1a5c08e4f0603783c3c8fa4fcb965ef6c1d", "filename": "gcc/testsuite/g++.dg/parse/crash22.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash22.C?ref=91b1ca65f39ecca8525536d3f4dfa80144e68afd", "patch": "@@ -4,17 +4,17 @@\n // PR 19030: ICE\n // Origin: Volker Reichelt <reichelt@gcc.gnu.org>\n \n-struct A;\n+struct A; // { dg-error \"A\" }\n \n namespace N\n {\n-  struct A;\n+  struct A; // { dg-error \"A\" }\n }\n \n using namespace N;\n \n-int A::i; // { dg-error \"not been declared|declared here\" \"\" }\n-int A::i; // { dg-error \"not been declared|redefinition of\" \"\" }\n+int A::i; // { dg-error \"ambiguous|declared here\" \"\" }\n+int A::i; // { dg-error \"ambiguous|redefinition of\" \"\" }\n \n namespace N\n {"}, {"sha": "c5b34a472a98611ab26dacb9d3f28d21e586ceb8", "filename": "gcc/testsuite/g++.dg/tc1/dr101.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftc1%2Fdr101.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b1ca65f39ecca8525536d3f4dfa80144e68afd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftc1%2Fdr101.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftc1%2Fdr101.C?ref=91b1ca65f39ecca8525536d3f4dfa80144e68afd", "patch": "@@ -17,10 +17,10 @@ namespace Test1 {\n \n namespace Test2 {\n \n-  typedef unsigned int X;   // { dg-bogus \"declared\" \"\" { xfail *-*-* } }\n+  typedef unsigned int X;   // { dg-bogus \"X\" \"\" { xfail *-*-* } }\n   extern \"C\" int f2();\n   namespace N {\n-    typedef unsigned int X; // { dg-bogus \"declared\" \"\" { xfail *-*-* } }\n+    typedef unsigned int X; // { dg-bogus \"X\" \"\" { xfail *-*-* } }\n     extern \"C\" int f2();\n   }\n   using namespace N;"}]}