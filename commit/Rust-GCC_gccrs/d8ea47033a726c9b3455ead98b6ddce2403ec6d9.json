{"sha": "d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhlYTQ3MDMzYTcyNmM5YjM0NTVlYWQ5OGI2ZGRjZTI0MDNlYzZkOQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-21T17:26:21Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-04-30T16:17:17Z"}, "message": "Jump threader refactor.\n\nThis is an overall refactor of the jump threader, both for the low level\nbits in tree-ssa-threadupdate.* and the high level bits in\ntree-ssa-threadedge.*.\n\nThere should be no functional changes.\n\nSome of the benefits of the refactor are:\n\na) Eliminates some icky global state (for example the x_vr_values hack).\n\nb) Provides some semblance of an API for the threader.\n\nc) Makes it clearer to see what parts are from the high level\nthreader, and what parts belong in the low level path registry and\nBB threading mechanism.\n\nd) Avoids passing a ton of variables around.\n\ne) Provides for easier sharing with the backward threader.\n\nf) Merged simplify stmt code in VRP and DOM as they were nearly\nidentical.\n\nThis has been bootstrapped and regression tested on x86-64 Linux.\nJeff had also been testing this path as part of his Fedora throughout the\noff-season.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-dom.c (class dom_jump_threader_simplifier): New.\n\t(class dom_opt_dom_walker): Initialize some class variables.\n\t(pass_dominator::execute): Pass evrp_range_analyzer and\n\tdom_jump_threader_simplifier to dom_opt_dom_walker.\n\tAdjust for some functions moving into classes.\n\t(simplify_stmt_for_jump_threading): Adjust and move to...\n\t(jump_threader_simplifier::simplify): ...here.\n\t(dom_opt_dom_walker::before_dom_children): Adjust for\n\tm_evrp_range_analyzer.\n\t(dom_opt_dom_walker::after_dom_children): Remove x_vr_values hack.\n\t(test_for_singularity): Place in dom_opt_dom_walker class.\n\t(dom_opt_dom_walker::optimize_stmt): The argument\n\tevrp_range_analyzer is now a class field.\n\t* tree-ssa-threadbackward.c (class thread_jumps): Add m_registry.\n\t(thread_jumps::thread_through_all_blocks): New.\n\t(thread_jumps::convert_and_register_current_path): Use m_registry.\n\t(pass_thread_jumps::execute): Adjust for thread_through_all_blocks\n\tbeing in the threader class.\n\t(pass_early_thread_jumps::execute): Same.\n\t* tree-ssa-threadedge.c (threadedge_initialize_values): Move...\n\t(jump_threader::jump_threader): ...here.\n\t(threadedge_finalize_values): Move...\n\t(jump_threader::~jump_threader): ...here.\n\t(jump_threader::remove_jump_threads_including): New.\n\t(jump_threader::thread_through_all_blocks): New.\n\t(record_temporary_equivalences_from_phis): Move...\n\t(jump_threader::record_temporary_equivalences_from_phis): ...here.\n\t(record_temporary_equivalences_from_stmts_at_dest): Move...\n\t(jump_threader::record_temporary_equivalences_from_stmts_at_dest):\n\tHere...\n\t(simplify_control_stmt_condition_1): Move to jump_threader class.\n\t(simplify_control_stmt_condition): Move...\n\t(jump_threader::simplify_control_stmt_condition): ...here.\n\t(thread_around_empty_blocks): Move...\n\t(jump_threader::thread_around_empty_blocks): ...here.\n\t(thread_through_normal_block): Move...\n\t(jump_threader::thread_through_normal_block): ...here.\n\t(thread_across_edge): Move...\n\t(jump_threader::thread_across_edge): ...here.\n\t(thread_outgoing_edges): Move...\n\t(jump_threader::thread_outgoing_edges): ...here.\n\t* tree-ssa-threadedge.h: Move externally facing functings...\n\t(class jump_threader): ...here...\n\t(class jump_threader_simplifier): ...and here.\n\t* tree-ssa-threadupdate.c (struct redirection_data): Remove comment.\n\t(jump_thread_path_allocator::jump_thread_path_allocator): New.\n\t(jump_thread_path_allocator::~jump_thread_path_allocator): New.\n\t(jump_thread_path_allocator::allocate_thread_edge): New.\n\t(jump_thread_path_allocator::allocate_thread_path): New.\n\t(jump_thread_path_registry::jump_thread_path_registry): New.\n\t(jump_thread_path_registry::~jump_thread_path_registry): New.\n\t(jump_thread_path_registry::allocate_thread_edge): New.\n\t(jump_thread_path_registry::allocate_thread_path): New.\n\t(dump_jump_thread_path): Make extern.\n\t(debug (const vec<jump_thread_edge *> &path)): New.\n\t(struct removed_edges): Move to tree-ssa-threadupdate.h.\n\t(struct thread_stats_d): Remove.\n\t(remove_ctrl_stmt_and_useless_edges): Make static.\n\t(lookup_redirection_data): Move...\n\t(jump_thread_path_registry::lookup_redirection_data): ...here.\n\t(ssa_redirect_edges): Make static.\n\t(thread_block_1): Move...\n\t(jump_thread_path_registry::thread_block_1): ...here.\n\t(thread_block): Move...\n\t(jump_thread_path_registry::thread_block): ...here.\n\t(thread_through_loop_header):  Move...\n\t(jump_thread_path_registry::thread_through_loop_header): ...here.\n\t(mark_threaded_blocks): Move...\n\t(jump_thread_path_registry::mark_threaded_blocks): ...here.\n\t(debug_path): Move...\n\t(jump_thread_path_registry::debug_path): ...here.\n\t(debug_all_paths): Move...\n\t(jump_thread_path_registry::dump): ..here.\n\t(rewire_first_differing_edge): Move...\n\t(jump_thread_path_registry::rewire_first_differing_edge): ...here.\n\t(adjust_paths_after_duplication): Move...\n\t(jump_thread_path_registry::adjust_paths_after_duplication): ...here.\n\t(duplicate_thread_path): Move...\n\t(jump_thread_path_registry::duplicate_thread_path): ..here.\n\t(remove_jump_threads_including): Move...\n\t(jump_thread_path_registry::remove_jump_threads_including): ...here.\n\t(thread_through_all_blocks): Move to...\n\t(jump_thread_path_registry::thread_through_all_blocks): ...here.\n\t(delete_jump_thread_path): Remove.\n\t(register_jump_thread): Move...\n\t(jump_thread_path_registry::register_jump_thread): ...here.\n\t* tree-ssa-threadupdate.h: Move externally facing functions...\n\t(class jump_thread_path_allocator): ...here...\n\t(class jump_thread_path_registry): ...and here.\n\t(thread_through_all_blocks): Remove.\n\t(struct removed_edges): New.\n\t(register_jump_thread): Remove.\n\t(remove_jump_threads_including): Remove.\n\t(delete_jump_thread_path): Remove.\n\t(remove_ctrl_stmt_and_useless_edges): Remove.\n\t(free_dom_edge_info): New prototype.\n\t* tree-vrp.c: Remove x_vr_values hack.\n\t(class vrp_jump_threader_simplifier): New.\n\t(vrp_jump_threader_simplifier::simplify): New.\n\t(vrp_jump_threader::vrp_jump_threader): Adjust method signature.\n\tRemove m_dummy_cond.\n\tInstantiate m_simplifier and m_threader.\n\t(vrp_jump_threader::thread_through_all_blocks): New.\n\t(vrp_jump_threader::simplify_stmt): Remove.\n\t(vrp_jump_threader::after_dom_children): Do not set m_dummy_cond.\n\tRemove x_vr_values hack.\n\t(execute_vrp): Adjust for thread_through_all_blocks being in a\n\tclass.", "tree": {"sha": "c9a74b07b091406b717571a92bbbc06ae7599584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9a74b07b091406b717571a92bbbc06ae7599584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71834be5b68e0c9839f0647e1bbf1eec4e4bbf49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71834be5b68e0c9839f0647e1bbf1eec4e4bbf49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71834be5b68e0c9839f0647e1bbf1eec4e4bbf49"}], "stats": {"total": 1258, "additions": 648, "deletions": 610}, "files": [{"sha": "11b86b2a326114b70e4377393790475c3f4234c5", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 71, "deletions": 112, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "patch": "@@ -585,19 +585,48 @@ record_edge_info (basic_block bb)\n     }\n }\n \n+class dom_jump_threader_simplifier : public jump_threader_simplifier\n+{\n+public:\n+  dom_jump_threader_simplifier (vr_values *v,\n+\t\t\t\tavail_exprs_stack *avails)\n+    : jump_threader_simplifier (v, avails) {}\n+\n+private:\n+  tree simplify (gimple *, gimple *, basic_block);\n+};\n+\n+tree\n+dom_jump_threader_simplifier::simplify (gimple *stmt,\n+\t\t\t\t\tgimple *within_stmt,\n+\t\t\t\t\tbasic_block bb)\n+{\n+  /* First see if the conditional is in the hash table.  */\n+  tree cached_lhs =  m_avail_exprs_stack->lookup_avail_expr (stmt,\n+\t\t\t\t\t\t\t     false, true);\n+  if (cached_lhs)\n+    return cached_lhs;\n+\n+  return jump_threader_simplifier::simplify (stmt, within_stmt, bb);\n+}\n \n class dom_opt_dom_walker : public dom_walker\n {\n public:\n   dom_opt_dom_walker (cdi_direction direction,\n-\t\t      class const_and_copies *const_and_copies,\n-\t\t      class avail_exprs_stack *avail_exprs_stack,\n-\t\t      gcond *dummy_cond)\n-    : dom_walker (direction, REACHABLE_BLOCKS),\n-      m_const_and_copies (const_and_copies),\n-      m_avail_exprs_stack (avail_exprs_stack),\n-      evrp_range_analyzer (true),\n-      m_dummy_cond (dummy_cond) { }\n+\t\t      jump_threader *threader,\n+\t\t      evrp_range_analyzer *analyzer,\n+\t\t      const_and_copies *const_and_copies,\n+\t\t      avail_exprs_stack *avail_exprs_stack)\n+    : dom_walker (direction, REACHABLE_BLOCKS)\n+    {\n+      m_evrp_range_analyzer = analyzer;\n+      m_dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,\n+\t\t\t\t\tinteger_zero_node, NULL, NULL);\n+      m_const_and_copies = const_and_copies;\n+      m_avail_exprs_stack = avail_exprs_stack;\n+      m_threader = threader;\n+    }\n \n   virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n@@ -608,9 +637,6 @@ class dom_opt_dom_walker : public dom_walker\n   class const_and_copies *m_const_and_copies;\n   class avail_exprs_stack *m_avail_exprs_stack;\n \n-  /* VRP data.  */\n-  class evrp_range_analyzer evrp_range_analyzer;\n-\n   /* Dummy condition to avoid creating lots of throw away statements.  */\n   gcond *m_dummy_cond;\n \n@@ -619,6 +645,13 @@ class dom_opt_dom_walker : public dom_walker\n      the statement is a conditional with a statically determined\n      value.  */\n   edge optimize_stmt (basic_block, gimple_stmt_iterator *, bool *);\n+\n+\n+  void test_for_singularity (gimple *, avail_exprs_stack *);\n+\n+  dom_jump_threader_simplifier *m_simplifier;\n+  jump_threader *m_threader;\n+  evrp_range_analyzer *m_evrp_range_analyzer;\n };\n \n /* Jump threading, redundancy elimination and const/copy propagation.\n@@ -697,9 +730,6 @@ pass_dominator::execute (function *fun)\n      LOOPS_HAVE_PREHEADERS won't be needed here.  */\n   loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);\n \n-  /* Initialize the value-handle array.  */\n-  threadedge_initialize_values ();\n-\n   /* We need accurate information regarding back edges in the CFG\n      for jump threading; this may include back edges that are not part of\n      a single loop.  */\n@@ -715,12 +745,16 @@ pass_dominator::execute (function *fun)\n   FOR_EACH_BB_FN (bb, fun)\n     record_edge_info (bb);\n \n-  gcond *dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,\n-\t\t\t\t\t integer_zero_node, NULL, NULL);\n-\n   /* Recursively walk the dominator tree optimizing statements.  */\n-  dom_opt_dom_walker walker (CDI_DOMINATORS, const_and_copies,\n-\t\t\t     avail_exprs_stack, dummy_cond);\n+  evrp_range_analyzer analyzer (true);\n+  dom_jump_threader_simplifier simplifier (&analyzer, avail_exprs_stack);\n+  jump_threader threader (const_and_copies, avail_exprs_stack,\n+\t\t\t  &simplifier, &analyzer);\n+  dom_opt_dom_walker walker (CDI_DOMINATORS,\n+\t\t\t     &threader,\n+\t\t\t     &analyzer,\n+\t\t\t     const_and_copies,\n+\t\t\t     avail_exprs_stack);\n   walker.walk (fun->cfg->x_entry_block_ptr);\n \n   /* Look for blocks where we cleared EDGE_EXECUTABLE on an outgoing\n@@ -749,7 +783,7 @@ pass_dominator::execute (function *fun)\n \t     containing any edge leaving BB.  */\n \t  if (found)\n \t    FOR_EACH_EDGE (e, ei, bb->succs)\n-\t      remove_jump_threads_including (e);\n+\t      threader.remove_jump_threads_including (e);\n \t}\n     }\n \n@@ -773,7 +807,7 @@ pass_dominator::execute (function *fun)\n   free_all_edge_infos ();\n \n   /* Thread jumps, creating duplicate blocks as needed.  */\n-  cfg_altered |= thread_through_all_blocks (may_peel_loop_headers_p);\n+  cfg_altered |= threader.thread_through_all_blocks (may_peel_loop_headers_p);\n \n   if (cfg_altered)\n     free_dominance_info (CDI_DOMINATORS);\n@@ -849,9 +883,6 @@ pass_dominator::execute (function *fun)\n   delete avail_exprs_stack;\n   delete const_and_copies;\n \n-  /* Free the value-handle array.  */\n-  threadedge_finalize_values ();\n-\n   return 0;\n }\n \n@@ -863,72 +894,6 @@ make_pass_dominator (gcc::context *ctxt)\n   return new pass_dominator (ctxt);\n }\n \n-/* A hack until we remove threading from tree-vrp.c and bring the\n-   simplification routine into the dom_opt_dom_walker class.  */\n-static class vr_values *x_vr_values;\n-\n-/* A trivial wrapper so that we can present the generic jump\n-   threading code with a simple API for simplifying statements.\n-\n-   ?? This should be cleaned up.  There's a virtually identical copy\n-   of this function in tree-vrp.c.  */\n-\n-static tree\n-simplify_stmt_for_jump_threading (gimple *stmt,\n-\t\t\t\t  gimple *within_stmt ATTRIBUTE_UNUSED,\n-\t\t\t\t  class avail_exprs_stack *avail_exprs_stack,\n-\t\t\t\t  basic_block bb ATTRIBUTE_UNUSED)\n-{\n-  /* First query our hash table to see if the expression is available\n-     there.  A non-NULL return value will be either a constant or another\n-     SSA_NAME.  */\n-  tree cached_lhs =  avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n-  if (cached_lhs)\n-    return cached_lhs;\n-\n-  /* If the hash table query failed, query VRP information.  This is\n-     essentially the same as tree-vrp's simplification routine.  The\n-     copy in tree-vrp is scheduled for removal in gcc-9.  */\n-  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n-    {\n-      simplify_using_ranges simplifier (x_vr_values);\n-      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n-\t\t\t\t\t\t  gimple_cond_lhs (cond_stmt),\n-\t\t\t\t\t\t  gimple_cond_rhs (cond_stmt),\n-\t\t\t\t\t\t  within_stmt);\n-    }\n-\n-  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n-    {\n-      tree op = gimple_switch_index (switch_stmt);\n-      if (TREE_CODE (op) != SSA_NAME)\n-\treturn NULL_TREE;\n-\n-      const value_range_equiv *vr = x_vr_values->get_value_range (op);\n-      return find_case_label_range (switch_stmt, vr);\n-    }\n-\n-  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n-    {\n-      tree lhs = gimple_assign_lhs (assign_stmt);\n-      if (TREE_CODE (lhs) == SSA_NAME\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\t  && stmt_interesting_for_vrp (stmt))\n-\t{\n-\t  edge dummy_e;\n-\t  tree dummy_tree;\n-\t  value_range_equiv new_vr;\n-\t  x_vr_values->extract_range_from_stmt (stmt, &dummy_e,\n-\t\t\t\t\t\t&dummy_tree, &new_vr);\n-\t  tree singleton;\n-\t  if (new_vr.singleton_p (&singleton))\n-\t    return singleton;\n-\t}\n-    }\n-  return NULL;\n-}\n-\n /* Valueize hook for gimple_fold_stmt_to_constant_1.  */\n \n static tree\n@@ -1417,7 +1382,7 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n\\nOptimizing block #%d\\n\\n\", bb->index);\n \n-  evrp_range_analyzer.enter (bb);\n+  m_evrp_range_analyzer->enter (bb);\n \n   /* Push a marker on the stacks of local information so that we know how\n      far to unwind when we finalize this block.  */\n@@ -1455,7 +1420,7 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n \t}\n \n       /* Compute range information and optimize the stmt.  */\n-      evrp_range_analyzer.record_ranges_from_stmt (gsi_stmt (gsi), false);\n+      m_evrp_range_analyzer->record_ranges_from_stmt (gsi_stmt (gsi), false);\n       bool removed_p = false;\n       taken_edge = this->optimize_stmt (bb, &gsi, &removed_p);\n       if (!removed_p)\n@@ -1500,17 +1465,10 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n void\n dom_opt_dom_walker::after_dom_children (basic_block bb)\n {\n-  x_vr_values = &evrp_range_analyzer;\n-  thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,\n-\t\t\t m_avail_exprs_stack,\n-\t\t\t &evrp_range_analyzer,\n-\t\t\t simplify_stmt_for_jump_threading);\n-  x_vr_values = NULL;\n-\n-  /* These remove expressions local to BB from the tables.  */\n+  m_threader->thread_outgoing_edges (bb);\n   m_avail_exprs_stack->pop_to_marker ();\n   m_const_and_copies->pop_to_marker ();\n-  evrp_range_analyzer.leave (bb);\n+  m_evrp_range_analyzer->leave (bb);\n }\n \n /* Search for redundant computations in STMT.  If any are found, then\n@@ -1849,9 +1807,9 @@ cprop_into_stmt (gimple *stmt, vr_values *vr_values)\n \n    This is similar to code in VRP.  */\n \n-static void\n-test_for_singularity (gimple *stmt, gcond *dummy_cond,\n-\t\t      avail_exprs_stack *avail_exprs_stack)\n+void\n+dom_opt_dom_walker::test_for_singularity (gimple *stmt,\n+\t\t\t\t\t  avail_exprs_stack *avail_exprs_stack)\n {\n   /* We want to support gimple conditionals as well as assignments\n      where the RHS contains a conditional.  */\n@@ -1897,11 +1855,12 @@ test_for_singularity (gimple *stmt, gcond *dummy_cond,\n \t    test_code = GE_EXPR;\n \n \t  /* Update the dummy statement so we can query the hash tables.  */\n-\t  gimple_cond_set_code (dummy_cond, test_code);\n-\t  gimple_cond_set_lhs (dummy_cond, lhs);\n-\t  gimple_cond_set_rhs (dummy_cond, rhs);\n+\t  gimple_cond_set_code (m_dummy_cond, test_code);\n+\t  gimple_cond_set_lhs (m_dummy_cond, lhs);\n+\t  gimple_cond_set_rhs (m_dummy_cond, rhs);\n \t  tree cached_lhs\n-\t    = avail_exprs_stack->lookup_avail_expr (dummy_cond, false, false);\n+\t    = avail_exprs_stack->lookup_avail_expr (m_dummy_cond,\n+\t\t\t\t\t\t    false, false);\n \n \t  /* If the lookup returned 1 (true), then the expression we\n \t     queried was in the hash table.  As a result there is only\n@@ -1970,7 +1929,7 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,\n   opt_stats.num_stmts++;\n \n   /* Const/copy propagate into USES, VUSES and the RHS of VDEFs.  */\n-  cprop_into_stmt (stmt, &evrp_range_analyzer);\n+  cprop_into_stmt (stmt, m_evrp_range_analyzer);\n \n   /* If the statement has been modified with constant replacements,\n      fold its RHS before checking for redundant computations.  */\n@@ -2068,8 +2027,8 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,\n \t\t SSA_NAMES.  */\n \t      update_stmt_if_modified (stmt);\n \t      edge taken_edge = NULL;\n-\t      evrp_range_analyzer.vrp_visit_cond_stmt (as_a <gcond *> (stmt),\n-\t\t\t\t\t\t       &taken_edge);\n+\t      m_evrp_range_analyzer->vrp_visit_cond_stmt\n+\t\t(as_a <gcond *> (stmt), &taken_edge);\n \t      if (taken_edge)\n \t\t{\n \t\t  if (taken_edge->flags & EDGE_TRUE_VALUE)\n@@ -2136,7 +2095,7 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,\n       /* If this statement was not redundant, we may still be able to simplify\n \t it, which may in turn allow other part of DOM or other passes to do\n \t a better job.  */\n-      test_for_singularity (stmt, m_dummy_cond, m_avail_exprs_stack);\n+      test_for_singularity (stmt, m_avail_exprs_stack);\n     }\n \n   /* Record any additional equivalences created by this statement.  */"}, {"sha": "428cf0767c637b6608ee099b01abb3b5d19f5bbe", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "patch": "@@ -39,9 +39,11 @@ along with GCC; see the file COPYING3.  If not see\n \n class thread_jumps\n {\n- public:\n+public:\n   void find_jump_threads_backwards (basic_block bb, bool speed_p);\n- private:\n+  bool thread_through_all_blocks ();\n+\n+private:\n   edge profitable_jump_thread_path (basic_block bbi, tree name, tree arg,\n \t\t\t\t    bool *creates_irreducible_loop);\n   void convert_and_register_current_path (edge taken_edge);\n@@ -65,8 +67,16 @@ class thread_jumps\n   /* Indicate that we could increase code size to improve the\n      code path.  */\n   bool m_speed_p;\n+\n+  jump_thread_path_registry m_registry;\n };\n \n+bool\n+thread_jumps::thread_through_all_blocks ()\n+{\n+  return m_registry.thread_through_all_blocks (true);\n+}\n+\n /* Simple helper to get the last statement from BB, which is assumed\n    to be a control statement.   Return NULL if the last statement is\n    not a control statement.  */\n@@ -459,7 +469,7 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n void\n thread_jumps::convert_and_register_current_path (edge taken_edge)\n {\n-  vec<jump_thread_edge *> *jump_thread_path = new vec<jump_thread_edge *> ();\n+  vec<jump_thread_edge *> *path = m_registry.allocate_thread_path ();\n \n   /* Record the edges between the blocks in PATH.  */\n   for (unsigned int j = 0; j + 1 < m_path.length (); j++)\n@@ -469,16 +479,17 @@ thread_jumps::convert_and_register_current_path (edge taken_edge)\n \n       edge e = find_edge (bb1, bb2);\n       gcc_assert (e);\n-      jump_thread_edge *x = new jump_thread_edge (e, EDGE_FSM_THREAD);\n-      jump_thread_path->safe_push (x);\n+      jump_thread_edge *x\n+\t= m_registry.allocate_thread_edge (e, EDGE_FSM_THREAD);\n+      path->safe_push (x);\n     }\n \n   /* Add the edge taken when the control variable has value ARG.  */\n   jump_thread_edge *x\n-    = new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n-  jump_thread_path->safe_push (x);\n+    = m_registry.allocate_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n+  path->safe_push (x);\n \n-  register_jump_thread (jump_thread_path);\n+  m_registry.register_jump_thread (path);\n   --m_max_threaded_paths;\n }\n \n@@ -827,7 +838,7 @@ pass_thread_jumps::execute (function *fun)\n       if (EDGE_COUNT (bb->succs) > 1)\n \tthreader.find_jump_threads_backwards (bb, true);\n     }\n-  bool changed = thread_through_all_blocks (true);\n+  bool changed = threader.thread_through_all_blocks ();\n \n   loop_optimizer_finalize ();\n   return changed ? TODO_cleanup_cfg : 0;\n@@ -888,7 +899,7 @@ pass_early_thread_jumps::execute (function *fun)\n       if (EDGE_COUNT (bb->succs) > 1)\n \tthreader.find_jump_threads_backwards (bb, false);\n     }\n-  thread_through_all_blocks (true);\n+  threader.thread_through_all_blocks ();\n \n   loop_optimizer_finalize ();\n   return 0;"}, {"sha": "6ce32644aa598eb1090223ab3275d224a2073301", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 181, "deletions": 235, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "patch": "@@ -49,10 +49,6 @@ static int stmt_count;\n /* Array to record value-handles per SSA_NAME.  */\n vec<tree> ssa_name_values;\n \n-typedef tree (pfn_simplify) (gimple *, gimple *,\n-\t\t\t     class avail_exprs_stack *,\n-\t\t\t     basic_block);\n-\n /* Set the value for the SSA name NAME to VALUE.  */\n \n void\n@@ -65,25 +61,48 @@ set_ssa_name_value (tree name, tree value)\n   ssa_name_values[SSA_NAME_VERSION (name)] = value;\n }\n \n-/* Initialize the per SSA_NAME value-handles array.  Returns it.  */\n-void\n-threadedge_initialize_values (void)\n+jump_threader::jump_threader (const_and_copies *copies,\n+\t\t\t      avail_exprs_stack *avails,\n+\t\t\t      jump_threader_simplifier *simplifier,\n+\t\t\t      evrp_range_analyzer *analyzer)\n {\n+  /* Initialize the per SSA_NAME value-handles array.  */\n   gcc_assert (!ssa_name_values.exists ());\n   ssa_name_values.create (num_ssa_names);\n+\n+  dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,\n+\t\t\t\t  integer_zero_node, NULL, NULL);\n+\n+  m_const_and_copies = copies;\n+  m_avail_exprs_stack = avails;\n+  m_registry = new jump_thread_path_registry ();\n+  m_simplifier = simplifier;\n+  m_evrp_range_analyzer = analyzer;\n }\n \n-/* Free the per SSA_NAME value-handle array.  */\n-void\n-threadedge_finalize_values (void)\n+jump_threader::~jump_threader (void)\n {\n   ssa_name_values.release ();\n+  ggc_free (dummy_cond);\n+  delete m_registry;\n+}\n+\n+void\n+jump_threader::remove_jump_threads_including (edge_def *e)\n+{\n+  m_registry->remove_jump_threads_including (e);\n+}\n+\n+bool\n+jump_threader::thread_through_all_blocks (bool may_peel_loop_headers)\n+{\n+  return m_registry->thread_through_all_blocks (may_peel_loop_headers);\n }\n \n /* Return TRUE if we may be able to thread an incoming edge into\n    BB to an outgoing edge from BB.  Return FALSE otherwise.  */\n \n-bool\n+static bool\n potentially_threadable_block (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n@@ -116,16 +135,13 @@ potentially_threadable_block (basic_block bb)\n }\n \n /* Record temporary equivalences created by PHIs at the target of the\n-   edge E.  Record unwind information for the equivalences into\n-   CONST_AND_COPIES and EVRP_RANGE_DATA.\n+   edge E.\n \n    If a PHI which prevents threading is encountered, then return FALSE\n    indicating we should not thread this edge, else return TRUE.  */\n \n-static bool\n-record_temporary_equivalences_from_phis (edge e,\n-    const_and_copies *const_and_copies,\n-    evrp_range_analyzer *evrp_range_analyzer)\n+bool\n+jump_threader::record_temporary_equivalences_from_phis (edge e)\n {\n   gphi_iterator gsi;\n \n@@ -152,19 +168,19 @@ record_temporary_equivalences_from_phis (edge e,\n       if (!virtual_operand_p (dst))\n \tstmt_count++;\n \n-      const_and_copies->record_const_or_copy (dst, src);\n+      m_const_and_copies->record_const_or_copy (dst, src);\n \n       /* Also update the value range associated with DST, using\n \t the range from SRC.\n \n \t Note that even if SRC is a constant we need to set a suitable\n \t output range so that VR_UNDEFINED ranges do not leak through.  */\n-      if (evrp_range_analyzer)\n+      if (m_evrp_range_analyzer)\n \t{\n \t  /* Get an empty new VR we can pass to update_value_range and save\n \t     away in the VR stack.  */\n \t  value_range_equiv *new_vr\n-\t\t\t  = evrp_range_analyzer->allocate_value_range_equiv ();\n+\t    = m_evrp_range_analyzer->allocate_value_range_equiv ();\n \t  new (new_vr) value_range_equiv ();\n \n \t  /* There are three cases to consider:\n@@ -178,14 +194,14 @@ record_temporary_equivalences_from_phis (edge e,\n \t       Otherwise set NEW_VR to varying.  This may be overly\n \t       conservative.  */\n \t  if (TREE_CODE (src) == SSA_NAME)\n-\t    new_vr->deep_copy (evrp_range_analyzer->get_value_range (src));\n+\t    new_vr->deep_copy (m_evrp_range_analyzer->get_value_range (src));\n \t  else if (TREE_CODE (src) == INTEGER_CST)\n \t    new_vr->set (src);\n \t  else\n \t    new_vr->set_varying (TREE_TYPE (src));\n \n \t  /* This is a temporary range for DST, so push it.  */\n-\t  evrp_range_analyzer->push_value_range (dst, new_vr);\n+\t  m_evrp_range_analyzer->push_value_range (dst, new_vr);\n \t}\n     }\n   return true;\n@@ -210,8 +226,8 @@ threadedge_valueize (tree t)\n \n    Record unwind information for temporary equivalences onto STACK.\n \n-   Use SIMPLIFY (a pointer to a callback function) to further simplify\n-   statements using pass specific information.\n+   Uses M_SIMPLIFIER to further simplify statements using pass specific\n+   information.\n \n    We might consider marking just those statements which ultimately\n    feed the COND_EXPR.  It's not clear if the overhead of bookkeeping\n@@ -222,12 +238,8 @@ threadedge_valueize (tree t)\n    a context sensitive equivalence which may help us simplify\n    later statements in E->dest.  */\n \n-static gimple *\n-record_temporary_equivalences_from_stmts_at_dest (edge e,\n-    const_and_copies *const_and_copies,\n-    avail_exprs_stack *avail_exprs_stack,\n-    evrp_range_analyzer *evrp_range_analyzer,\n-    pfn_simplify simplify)\n+gimple *\n+jump_threader::record_temporary_equivalences_from_stmts_at_dest (edge e)\n {\n   gimple *stmt = NULL;\n   gimple_stmt_iterator gsi;\n@@ -294,8 +306,8 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \n       /* These are temporary ranges, do nto reflect them back into\n \t the global range data.  */\n-      if (evrp_range_analyzer)\n-\tevrp_range_analyzer->record_ranges_from_stmt (stmt, true);\n+      if (m_evrp_range_analyzer)\n+\tm_evrp_range_analyzer->record_ranges_from_stmt (stmt, true);\n \n       /* If this is not a statement that sets an SSA_NAME to a new\n \t value, then do not try to simplify this statement as it will\n@@ -396,7 +408,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t\t    SET_USE (use_p, tmp);\n \t\t}\n \n-\t      cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack, e->src);\n+\t      cached_lhs = m_simplifier->simplify (stmt, stmt, e->src);\n \n \t      /* Restore the statement's original uses/defs.  */\n \t      i = 0;\n@@ -410,38 +422,23 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n       if (cached_lhs\n \t  && (TREE_CODE (cached_lhs) == SSA_NAME\n \t      || is_gimple_min_invariant (cached_lhs)))\n-\tconst_and_copies->record_const_or_copy (gimple_get_lhs (stmt),\n-\t\t\t\t\t\tcached_lhs);\n+\tm_const_and_copies->record_const_or_copy (gimple_get_lhs (stmt),\n+\t\t\t\t\t\t  cached_lhs);\n     }\n   return stmt;\n }\n \n-static tree simplify_control_stmt_condition_1 (edge, gimple *,\n-\t\t\t\t\t       class avail_exprs_stack *,\n-\t\t\t\t\t       tree, enum tree_code, tree,\n-\t\t\t\t\t       gcond *, pfn_simplify,\n-\t\t\t\t\t       unsigned);\n-\n /* Simplify the control statement at the end of the block E->dest.\n \n-   To avoid allocating memory unnecessarily, a scratch GIMPLE_COND\n-   is available to use/clobber in DUMMY_COND.\n-\n    Use SIMPLIFY (a pointer to a callback function) to further simplify\n    a condition using pass specific information.\n \n    Return the simplified condition or NULL if simplification could\n    not be performed.  When simplifying a GIMPLE_SWITCH, we may return\n-   the CASE_LABEL_EXPR that will be taken.\n+   the CASE_LABEL_EXPR that will be taken.  */\n \n-   The available expression table is referenced via AVAIL_EXPRS_STACK.  */\n-\n-static tree\n-simplify_control_stmt_condition (edge e,\n-\t\t\t\t gimple *stmt,\n-\t\t\t\t class avail_exprs_stack *avail_exprs_stack,\n-\t\t\t\t gcond *dummy_cond,\n-\t\t\t\t pfn_simplify simplify)\n+tree\n+jump_threader::simplify_control_stmt_condition (edge e, gimple *stmt)\n {\n   tree cond, cached_lhs;\n   enum gimple_code code = gimple_code (stmt);\n@@ -485,9 +482,7 @@ simplify_control_stmt_condition (edge e,\n       const unsigned recursion_limit = 4;\n \n       cached_lhs\n-\t= simplify_control_stmt_condition_1 (e, stmt, avail_exprs_stack,\n-\t\t\t\t\t     op0, cond_code, op1,\n-\t\t\t\t\t     dummy_cond, simplify,\n+\t= simplify_control_stmt_condition_1 (e, stmt, op0, cond_code, op1,\n \t\t\t\t\t     recursion_limit);\n \n       /* If we were testing an integer/pointer against a constant, then\n@@ -557,12 +552,11 @@ simplify_control_stmt_condition (edge e,\n \t\t the label that is proven to be taken.  */\n \t      gswitch *dummy_switch = as_a<gswitch *> (gimple_copy (stmt));\n \t      gimple_switch_set_index (dummy_switch, cached_lhs);\n-\t      cached_lhs = (*simplify) (dummy_switch, stmt,\n-\t\t\t\t\tavail_exprs_stack, e->src);\n+\t      cached_lhs = m_simplifier->simplify (dummy_switch, stmt, e->src);\n \t      ggc_free (dummy_switch);\n \t    }\n \t  else\n-\t    cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack, e->src);\n+\t    cached_lhs = m_simplifier->simplify (stmt, stmt, e->src);\n \t}\n \n       /* We couldn't find an invariant.  But, callers of this\n@@ -579,16 +573,14 @@ simplify_control_stmt_condition (edge e,\n \n /* Recursive helper for simplify_control_stmt_condition.  */\n \n-static tree\n-simplify_control_stmt_condition_1 (edge e,\n-\t\t\t\t   gimple *stmt,\n-\t\t\t\t   class avail_exprs_stack *avail_exprs_stack,\n-\t\t\t\t   tree op0,\n-\t\t\t\t   enum tree_code cond_code,\n-\t\t\t\t   tree op1,\n-\t\t\t\t   gcond *dummy_cond,\n-\t\t\t\t   pfn_simplify simplify,\n-\t\t\t\t   unsigned limit)\n+tree\n+jump_threader::simplify_control_stmt_condition_1\n+\t\t\t\t\t(edge e,\n+\t\t\t\t\t gimple *stmt,\n+\t\t\t\t\t tree op0,\n+\t\t\t\t\t enum tree_code cond_code,\n+\t\t\t\t\t tree op1,\n+\t\t\t\t\t unsigned limit)\n {\n   if (limit == 0)\n     return NULL_TREE;\n@@ -623,9 +615,8 @@ simplify_control_stmt_condition_1 (edge e,\n \n \t  /* Is A != 0 ?  */\n \t  const tree res1\n-\t    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,\n+\t    = simplify_control_stmt_condition_1 (e, def_stmt,\n \t\t\t\t\t\t rhs1, NE_EXPR, op1,\n-\t\t\t\t\t\t dummy_cond, simplify,\n \t\t\t\t\t\t limit - 1);\n \t  if (res1 == NULL_TREE)\n \t    ;\n@@ -650,9 +641,8 @@ simplify_control_stmt_condition_1 (edge e,\n \n \t  /* Is B != 0 ?  */\n \t  const tree res2\n-\t    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,\n+\t    = simplify_control_stmt_condition_1 (e, def_stmt,\n \t\t\t\t\t\t rhs2, NE_EXPR, op1,\n-\t\t\t\t\t\t dummy_cond, simplify,\n \t\t\t\t\t\t limit - 1);\n \t  if (res2 == NULL_TREE)\n \t    ;\n@@ -715,9 +705,8 @@ simplify_control_stmt_condition_1 (edge e,\n \t    new_cond = invert_tree_comparison (new_cond, false);\n \n \t  tree res\n-\t    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,\n+\t    = simplify_control_stmt_condition_1 (e, def_stmt,\n \t\t\t\t\t\t rhs1, new_cond, rhs2,\n-\t\t\t\t\t\t dummy_cond, simplify,\n \t\t\t\t\t\t limit - 1);\n \t  if (res != NULL_TREE && is_gimple_min_invariant (res))\n \t    return res;\n@@ -744,7 +733,7 @@ simplify_control_stmt_condition_1 (edge e,\n      then use the pass specific callback to simplify the condition.  */\n   if (!res\n       || !is_gimple_min_invariant (res))\n-    res = (*simplify) (dummy_cond, stmt, avail_exprs_stack, e->src);\n+    res = m_simplifier->simplify (dummy_cond, stmt, e->src);\n \n   return res;\n }\n@@ -893,18 +882,12 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n    returning TRUE from the toplevel call.   Otherwise do nothing and\n    return false.\n \n-   DUMMY_COND, SIMPLIFY are used to try and simplify the condition at the\n-   end of TAKEN_EDGE->dest.\n-\n    The available expression table is referenced via AVAIL_EXPRS_STACK.  */\n \n-static bool\n-thread_around_empty_blocks (edge taken_edge,\n-\t\t\t    gcond *dummy_cond,\n-\t\t\t    class avail_exprs_stack *avail_exprs_stack,\n-\t\t\t    pfn_simplify simplify,\n-\t\t\t    bitmap visited,\n-\t\t\t    vec<jump_thread_edge *> *path)\n+bool\n+jump_threader::thread_around_empty_blocks (vec<jump_thread_edge *> *path,\n+\t\t\t\t\t   edge taken_edge,\n+\t\t\t\t\t   bitmap visited)\n {\n   basic_block bb = taken_edge->dest;\n   gimple_stmt_iterator gsi;\n@@ -946,15 +929,11 @@ thread_around_empty_blocks (edge taken_edge,\n \t  if (!bitmap_bit_p (visited, taken_edge->dest->index))\n \t    {\n \t      jump_thread_edge *x\n-\t\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n+\t\t= m_registry->allocate_thread_edge (taken_edge,\n+\t\t\t\t\t\t    EDGE_NO_COPY_SRC_BLOCK);\n \t      path->safe_push (x);\n \t      bitmap_set_bit (visited, taken_edge->dest->index);\n-\t      return thread_around_empty_blocks (taken_edge,\n-\t\t\t\t\t\t dummy_cond,\n-\t\t\t\t\t\t avail_exprs_stack,\n-\t\t\t\t\t\t simplify,\n-\t\t\t\t\t\t visited,\n-\t\t\t\t\t\t path);\n+\t      return thread_around_empty_blocks (path, taken_edge, visited);\n \t    }\n \t}\n \n@@ -971,9 +950,7 @@ thread_around_empty_blocks (edge taken_edge,\n     return false;\n \n   /* Extract and simplify the condition.  */\n-  cond = simplify_control_stmt_condition (taken_edge, stmt,\n-\t\t\t\t\t  avail_exprs_stack, dummy_cond,\n-\t\t\t\t\t  simplify);\n+  cond = simplify_control_stmt_condition (taken_edge, stmt);\n \n   /* If the condition can be statically computed and we have not already\n      visited the destination edge, then add the taken edge to our thread\n@@ -996,15 +973,11 @@ thread_around_empty_blocks (edge taken_edge,\n       bitmap_set_bit (visited, taken_edge->dest->index);\n \n       jump_thread_edge *x\n-\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n+\t= m_registry->allocate_thread_edge (taken_edge,\n+\t\t\t\t\t    EDGE_NO_COPY_SRC_BLOCK);\n       path->safe_push (x);\n \n-      thread_around_empty_blocks (taken_edge,\n-\t\t\t\t  dummy_cond,\n-\t\t\t\t  avail_exprs_stack,\n-\t\t\t\t  simplify,\n-\t\t\t\t  visited,\n-\t\t\t\t  path);\n+      thread_around_empty_blocks (path, taken_edge, visited);\n       return true;\n     }\n \n@@ -1024,14 +997,9 @@ thread_around_empty_blocks (edge taken_edge,\n    limited in that case to avoid short-circuiting the loop\n    incorrectly.\n \n-   DUMMY_COND is a shared cond_expr used by condition simplification as scratch,\n-   to avoid allocating memory.\n-\n    STACK is used to undo temporary equivalences created during the walk of\n    E->dest.\n \n-   SIMPLIFY is a pass-specific function used to simplify statements.\n-\n    Our caller is responsible for restoring the state of the expression\n    and const_and_copies stacks.\n \n@@ -1040,34 +1008,23 @@ thread_around_empty_blocks (edge taken_edge,\n    negative indicates the block should not be duplicated and thus is not\n    suitable for a joiner in a jump threading path.  */\n \n-static int\n-thread_through_normal_block (edge e,\n-\t\t\t     gcond *dummy_cond,\n-\t\t\t     const_and_copies *const_and_copies,\n-\t\t\t     avail_exprs_stack *avail_exprs_stack,\n-\t\t\t     evrp_range_analyzer *evrp_range_analyzer,\n-\t\t\t     pfn_simplify simplify,\n-\t\t\t     vec<jump_thread_edge *> *path,\n-\t\t\t     bitmap visited)\n+int\n+jump_threader::thread_through_normal_block (vec<jump_thread_edge *> *path,\n+\t\t\t\t\t    edge e, bitmap visited)\n {\n   /* We want to record any equivalences created by traversing E.  */\n-  record_temporary_equivalences (e, const_and_copies, avail_exprs_stack);\n+  record_temporary_equivalences (e, m_const_and_copies, m_avail_exprs_stack);\n \n   /* PHIs create temporary equivalences.\n      Note that if we found a PHI that made the block non-threadable, then\n      we need to bubble that up to our caller in the same manner we do\n      when we prematurely stop processing statements below.  */\n-  if (!record_temporary_equivalences_from_phis (e, const_and_copies,\n-\t\t\t\t\t        evrp_range_analyzer))\n+  if (!record_temporary_equivalences_from_phis (e))\n     return -1;\n \n   /* Now walk each statement recording any context sensitive\n      temporary equivalences we can detect.  */\n-  gimple *stmt\n-    = record_temporary_equivalences_from_stmts_at_dest (e, const_and_copies,\n-\t\t\t\t\t\t\tavail_exprs_stack,\n-\t\t\t\t\t\t\tevrp_range_analyzer,\n-\t\t\t\t\t\t\tsimplify);\n+  gimple *stmt = record_temporary_equivalences_from_stmts_at_dest (e);\n \n   /* There's two reasons STMT might be null, and distinguishing\n      between them is important.\n@@ -1104,8 +1061,7 @@ thread_through_normal_block (edge e,\n       tree cond;\n \n       /* Extract and simplify the condition.  */\n-      cond = simplify_control_stmt_condition (e, stmt, avail_exprs_stack,\n-\t\t\t\t\t      dummy_cond, simplify);\n+      cond = simplify_control_stmt_condition (e, stmt);\n \n       if (!cond)\n \treturn 0;\n@@ -1135,12 +1091,13 @@ thread_through_normal_block (edge e,\n \t  if (path->length () == 0)\n \t    {\n               jump_thread_edge *x\n-\t        = new jump_thread_edge (e, EDGE_START_JUMP_THREAD);\n+\t\t= m_registry->allocate_thread_edge (e, EDGE_START_JUMP_THREAD);\n \t      path->safe_push (x);\n \t    }\n \n \t  jump_thread_edge *x\n-\t    = new jump_thread_edge (taken_edge, EDGE_COPY_SRC_BLOCK);\n+\t    = m_registry->allocate_thread_edge (taken_edge,\n+\t\t\t\t\t\tEDGE_COPY_SRC_BLOCK);\n \t  path->safe_push (x);\n \n \t  /* See if we can thread through DEST as well, this helps capture\n@@ -1151,12 +1108,7 @@ thread_through_normal_block (edge e,\n  \t     visited.  This may be overly conservative.  */\n \t  bitmap_set_bit (visited, dest->index);\n \t  bitmap_set_bit (visited, e->dest->index);\n-\t  thread_around_empty_blocks (taken_edge,\n-\t\t\t\t      dummy_cond,\n-\t\t\t\t      avail_exprs_stack,\n-\t\t\t\t      simplify,\n-\t\t\t\t      visited,\n-\t\t\t\t      path);\n+\t  thread_around_empty_blocks (path, taken_edge, visited);\n \t  return 1;\n \t}\n     }\n@@ -1225,62 +1177,43 @@ edge_forwards_cmp_to_conditional_jump_through_empty_bb_p (edge e)\n   return true;\n }\n \n-/* We are exiting E->src, see if E->dest ends with a conditional\n-   jump which has a known value when reached via E.\n-\n-   DUMMY_COND is a shared cond_expr used by condition simplification as scratch,\n-   to avoid allocating memory.\n-\n-   CONST_AND_COPIES is used to undo temporary equivalences created during the\n-   walk of E->dest.\n+/* We are exiting E->src, see if E->dest ends with a conditional jump\n+   which has a known value when reached via E.  If so, thread the\n+   edge.  */\n \n-   The available expression table is referenced vai AVAIL_EXPRS_STACK.\n-\n-   SIMPLIFY is a pass-specific function used to simplify statements.  */\n-\n-static void\n-thread_across_edge (gcond *dummy_cond,\n-\t\t    edge e,\n-\t\t    class const_and_copies *const_and_copies,\n-\t\t    class avail_exprs_stack *avail_exprs_stack,\n-\t\t    class evrp_range_analyzer *evrp_range_analyzer,\n-\t\t    pfn_simplify simplify)\n+void\n+jump_threader::thread_across_edge (edge e)\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n \n-  const_and_copies->push_marker ();\n-  avail_exprs_stack->push_marker ();\n-  if (evrp_range_analyzer)\n-    evrp_range_analyzer->push_marker ();\n+  m_const_and_copies->push_marker ();\n+  m_avail_exprs_stack->push_marker ();\n+  if (m_evrp_range_analyzer)\n+    m_evrp_range_analyzer->push_marker ();\n \n   stmt_count = 0;\n \n-  vec<jump_thread_edge *> *path = new vec<jump_thread_edge *> ();\n+  vec<jump_thread_edge *> *path = m_registry->allocate_thread_path ();\n   bitmap_clear (visited);\n   bitmap_set_bit (visited, e->src->index);\n   bitmap_set_bit (visited, e->dest->index);\n \n   int threaded;\n   if ((e->flags & EDGE_DFS_BACK) == 0)\n-    threaded = thread_through_normal_block (e, dummy_cond,\n-\t\t\t\t\t    const_and_copies,\n-\t\t\t\t\t    avail_exprs_stack,\n-\t\t\t\t\t    evrp_range_analyzer,\n-\t\t\t\t\t    simplify, path,\n-\t\t\t\t\t    visited);\n+    threaded = thread_through_normal_block (path, e, visited);\n   else\n     threaded = 0;\n \n   if (threaded > 0)\n     {\n       propagate_threaded_block_debug_into (path->last ()->e->dest,\n \t\t\t\t\t   e->dest);\n-      const_and_copies->pop_to_marker ();\n-      avail_exprs_stack->pop_to_marker ();\n-      if (evrp_range_analyzer)\n-\tevrp_range_analyzer->pop_to_marker ();\n+      m_const_and_copies->pop_to_marker ();\n+      m_avail_exprs_stack->pop_to_marker ();\n+      if (m_evrp_range_analyzer)\n+\tm_evrp_range_analyzer->pop_to_marker ();\n       BITMAP_FREE (visited);\n-      register_jump_thread (path);\n+      m_registry->register_jump_thread (path);\n       return;\n     }\n   else\n@@ -1290,7 +1223,6 @@ thread_across_edge (gcond *dummy_cond,\n \t through the vector entries.  */\n       gcc_assert (path->length () == 0);\n       path->release ();\n-      delete path;\n \n       /* A negative status indicates the target block was deemed too big to\n \t duplicate.  Just quit now rather than trying to use the block as\n@@ -1302,10 +1234,10 @@ thread_across_edge (gcond *dummy_cond,\n       if (threaded < 0)\n \t{\n \t  BITMAP_FREE (visited);\n-\t  const_and_copies->pop_to_marker ();\n-          avail_exprs_stack->pop_to_marker ();\n-\t  if (evrp_range_analyzer)\n-\t    evrp_range_analyzer->pop_to_marker ();\n+\t  m_const_and_copies->pop_to_marker ();\n+\t  m_avail_exprs_stack->pop_to_marker ();\n+\t  if (m_evrp_range_analyzer)\n+\t    m_evrp_range_analyzer->pop_to_marker ();\n \t  return;\n \t}\n     }\n@@ -1331,10 +1263,10 @@ thread_across_edge (gcond *dummy_cond,\n     FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)\n       if (taken_edge->flags & EDGE_COMPLEX)\n \t{\n-\t  const_and_copies->pop_to_marker ();\n-          avail_exprs_stack->pop_to_marker ();\n-\t  if (evrp_range_analyzer)\n-\t    evrp_range_analyzer->pop_to_marker ();\n+\t  m_const_and_copies->pop_to_marker ();\n+\t  m_avail_exprs_stack->pop_to_marker ();\n+\t  if (m_evrp_range_analyzer)\n+\t    m_evrp_range_analyzer->pop_to_marker ();\n \t  BITMAP_FREE (visited);\n \t  return;\n \t}\n@@ -1348,39 +1280,32 @@ thread_across_edge (gcond *dummy_cond,\n \n \t/* Push a fresh marker so we can unwind the equivalences created\n \t   for each of E->dest's successors.  */\n-\tconst_and_copies->push_marker ();\n-\tavail_exprs_stack->push_marker ();\n-\tif (evrp_range_analyzer)\n-\t  evrp_range_analyzer->push_marker ();\n+\tm_const_and_copies->push_marker ();\n+\tm_avail_exprs_stack->push_marker ();\n+\tif (m_evrp_range_analyzer)\n+\t  m_evrp_range_analyzer->push_marker ();\n \n \t/* Avoid threading to any block we have already visited.  */\n \tbitmap_clear (visited);\n \tbitmap_set_bit (visited, e->src->index);\n \tbitmap_set_bit (visited, e->dest->index);\n \tbitmap_set_bit (visited, taken_edge->dest->index);\n-        vec<jump_thread_edge *> *path = new vec<jump_thread_edge *> ();\n+\tvec<jump_thread_edge *> *path = m_registry->allocate_thread_path ();\n \n \t/* Record whether or not we were able to thread through a successor\n \t   of E->dest.  */\n-        jump_thread_edge *x = new jump_thread_edge (e, EDGE_START_JUMP_THREAD);\n+\tjump_thread_edge *x\n+\t  = m_registry->allocate_thread_edge (e, EDGE_START_JUMP_THREAD);\n \tpath->safe_push (x);\n \n-        x = new jump_thread_edge (taken_edge, EDGE_COPY_SRC_JOINER_BLOCK);\n+\tx = m_registry->allocate_thread_edge (taken_edge,\n+\t\t\t\t\t      EDGE_COPY_SRC_JOINER_BLOCK);\n \tpath->safe_push (x);\n-\tfound = thread_around_empty_blocks (taken_edge,\n-\t\t\t\t\t    dummy_cond,\n-\t\t\t\t\t    avail_exprs_stack,\n-\t\t\t\t\t    simplify,\n-\t\t\t\t\t    visited,\n-\t\t\t\t\t    path);\n+\tfound = thread_around_empty_blocks (path, taken_edge, visited);\n \n \tif (!found)\n-\t  found = thread_through_normal_block (path->last ()->e, dummy_cond,\n-\t\t\t\t\t       const_and_copies,\n-\t\t\t\t\t       avail_exprs_stack,\n-\t\t\t\t\t       evrp_range_analyzer,\n-\t\t\t\t\t       simplify, path,\n-\t\t\t\t\t       visited) > 0;\n+\t  found = thread_through_normal_block (path,\n+\t\t\t\t\t       path->last ()->e, visited) > 0;\n \n \t/* If we were able to thread through a successor of E->dest, then\n \t   record the jump threading opportunity.  */\n@@ -1390,47 +1315,31 @@ thread_across_edge (gcond *dummy_cond,\n \t    if (taken_edge->dest != path->last ()->e->dest)\n \t      propagate_threaded_block_debug_into (path->last ()->e->dest,\n \t\t\t\t\t\t   taken_edge->dest);\n-\t    register_jump_thread (path);\n+\t    m_registry->register_jump_thread (path);\n \t  }\n \telse\n-\t  delete_jump_thread_path (path);\n+\t  path->release ();\n \n \t/* And unwind the equivalence table.  */\n-\tif (evrp_range_analyzer)\n-\t  evrp_range_analyzer->pop_to_marker ();\n-\tavail_exprs_stack->pop_to_marker ();\n-\tconst_and_copies->pop_to_marker ();\n+\tif (m_evrp_range_analyzer)\n+\t  m_evrp_range_analyzer->pop_to_marker ();\n+\tm_avail_exprs_stack->pop_to_marker ();\n+\tm_const_and_copies->pop_to_marker ();\n       }\n     BITMAP_FREE (visited);\n   }\n \n-  if (evrp_range_analyzer)\n-    evrp_range_analyzer->pop_to_marker ();\n-  const_and_copies->pop_to_marker ();\n-  avail_exprs_stack->pop_to_marker ();\n+  if (m_evrp_range_analyzer)\n+    m_evrp_range_analyzer->pop_to_marker ();\n+  m_const_and_copies->pop_to_marker ();\n+  m_avail_exprs_stack->pop_to_marker ();\n }\n \n /* Examine the outgoing edges from BB and conditionally\n-   try to thread them.\n-\n-   DUMMY_COND is a shared cond_expr used by condition simplification as scratch,\n-   to avoid allocating memory.\n-\n-   CONST_AND_COPIES is used to undo temporary equivalences created during the\n-   walk of E->dest.\n-\n-   The available expression table is referenced vai AVAIL_EXPRS_STACK.\n-\n-   SIMPLIFY is a pass-specific function used to simplify statements.  */\n+   try to thread them.  */\n \n void\n-thread_outgoing_edges (basic_block bb, gcond *dummy_cond,\n-\t\t       class const_and_copies *const_and_copies,\n-\t\t       class avail_exprs_stack *avail_exprs_stack,\n-\t\t       class evrp_range_analyzer *evrp_range_analyzer,\n-\t\t       tree (*simplify) (gimple *, gimple *,\n-\t\t\t\t\t class avail_exprs_stack *,\n-\t\t\t\t\t basic_block))\n+jump_threader::thread_outgoing_edges (basic_block bb)\n {\n   int flags = (EDGE_IGNORE | EDGE_COMPLEX | EDGE_ABNORMAL);\n   gimple *last;\n@@ -1443,9 +1352,7 @@ thread_outgoing_edges (basic_block bb, gcond *dummy_cond,\n       && (single_succ_edge (bb)->flags & flags) == 0\n       && potentially_threadable_block (single_succ (bb)))\n     {\n-      thread_across_edge (dummy_cond, single_succ_edge (bb),\n-\t\t\t  const_and_copies, avail_exprs_stack,\n-\t\t\t  evrp_range_analyzer, simplify);\n+      thread_across_edge (single_succ_edge (bb));\n     }\n   else if ((last = last_stmt (bb))\n \t   && gimple_code (last) == GIMPLE_COND\n@@ -1460,14 +1367,53 @@ thread_outgoing_edges (basic_block bb, gcond *dummy_cond,\n       /* Only try to thread the edge if it reaches a target block with\n \t more than one predecessor and more than one successor.  */\n       if (potentially_threadable_block (true_edge->dest))\n-\tthread_across_edge (dummy_cond, true_edge,\n-\t\t\t    const_and_copies, avail_exprs_stack,\n-\t\t\t    evrp_range_analyzer, simplify);\n+\tthread_across_edge (true_edge);\n \n       /* Similarly for the ELSE arm.  */\n       if (potentially_threadable_block (false_edge->dest))\n-\tthread_across_edge (dummy_cond, false_edge,\n-\t\t\t    const_and_copies, avail_exprs_stack,\n-\t\t\t    evrp_range_analyzer, simplify);\n+\tthread_across_edge (false_edge);\n+    }\n+}\n+\n+tree\n+jump_threader_simplifier::simplify (gimple *stmt,\n+\t\t\t\t    gimple *within_stmt,\n+\t\t\t\t    basic_block)\n+{\n+  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n+    {\n+      simplify_using_ranges simplifier (m_vr_values);\n+      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t\t\t  gimple_cond_lhs (cond_stmt),\n+\t\t\t\t\t\t  gimple_cond_rhs (cond_stmt),\n+\t\t\t\t\t\t  within_stmt);\n+    }\n+  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n+    {\n+      tree op = gimple_switch_index (switch_stmt);\n+      if (TREE_CODE (op) != SSA_NAME)\n+\treturn NULL_TREE;\n+\n+      const value_range_equiv *vr = m_vr_values->get_value_range (op);\n+      return find_case_label_range (switch_stmt, vr);\n+    }\n+   if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n+    {\n+      tree lhs = gimple_assign_lhs (assign_stmt);\n+      if (TREE_CODE (lhs) == SSA_NAME\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t  && stmt_interesting_for_vrp (stmt))\n+\t{\n+\t  edge dummy_e;\n+\t  tree dummy_tree;\n+\t  value_range_equiv new_vr;\n+\t  m_vr_values->extract_range_from_stmt (stmt, &dummy_e, &dummy_tree,\n+\t\t\t\t\t\t&new_vr);\n+\t  tree singleton;\n+\t  if (new_vr.singleton_p (&singleton))\n+\t    return singleton;\n+\t}\n     }\n+   return NULL;\n }"}, {"sha": "48735f2bc27d93acc77ab364b6958f8ccc1d69a4", "filename": "gcc/tree-ssa-threadedge.h", "status": "modified", "additions": 69, "deletions": 11, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "patch": "@@ -20,22 +20,80 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_SSA_THREADEDGE_H\n #define GCC_TREE_SSA_THREADEDGE_H\n \n+// This is the high level threader.  The entry point is\n+// thread_outgoing_edges(), which calculates and registers paths to be\n+// threaded.  When all candidates have been registered,\n+// thread_through_all_blocks() is called to actually change the CFG.\n+\n+class jump_threader\n+{\n+public:\n+  jump_threader (class const_and_copies *,\n+\t\t avail_exprs_stack *,\n+\t\t class jump_threader_simplifier *,\n+\t\t class evrp_range_analyzer * = NULL);\n+  ~jump_threader ();\n+  void thread_outgoing_edges (basic_block);\n+  void remove_jump_threads_including (edge_def *);\n+  bool thread_through_all_blocks (bool may_peel_loop_headers);\n+\n+private:\n+  tree simplify_control_stmt_condition (edge, gimple *);\n+  tree simplify_control_stmt_condition_1 (edge,\n+\t\t\t\t\t  gimple *,\n+\t\t\t\t\t  tree op0,\n+\t\t\t\t\t  tree_code cond_code,\n+\t\t\t\t\t  tree op1,\n+\t\t\t\t\t  unsigned limit);\n+\n+  bool thread_around_empty_blocks (vec<class jump_thread_edge *> *path,\n+\t\t\t\t   edge, bitmap visited);\n+  int thread_through_normal_block (vec<jump_thread_edge *> *path,\n+\t\t\t\t   edge, bitmap visited);\n+  void thread_across_edge (edge);\n+  bool record_temporary_equivalences_from_phis (edge);\n+  gimple *record_temporary_equivalences_from_stmts_at_dest (edge);\n+\n+  // Dummy condition to avoid creating lots of throw away statements.\n+  gcond *dummy_cond;\n+\n+  const_and_copies *m_const_and_copies;\n+  avail_exprs_stack *m_avail_exprs_stack;\n+  class jump_thread_path_registry *m_registry;\n+  jump_threader_simplifier *m_simplifier;\n+  evrp_range_analyzer *m_evrp_range_analyzer;\n+};\n+\n+// Statement simplifier callback for the jump threader.\n+\n+class jump_threader_simplifier\n+{\n+public:\n+  jump_threader_simplifier (class vr_values *v,\n+\t\t\t    avail_exprs_stack *avails)\n+    : m_vr_values (v),\n+      m_avail_exprs_stack (avails)\n+  { }\n+  virtual ~jump_threader_simplifier () { }\n+  virtual tree simplify (gimple *, gimple *, basic_block);\n+\n+protected:\n+  vr_values *m_vr_values;\n+  avail_exprs_stack *m_avail_exprs_stack;\n+};\n+\n+extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n+\n+// ?? All this ssa_name_values stuff is the store of values for\n+// avail_exprs_stack and const_and_copies, so it really belongs in the\n+// jump_threader class.  However, it's probably not worth touching\n+// this, since all this windable state is slated to go with the\n+// ranger.\n extern vec<tree> ssa_name_values;\n #define SSA_NAME_VALUE(x) \\\n     (SSA_NAME_VERSION (x) < ssa_name_values.length () \\\n      ? ssa_name_values[SSA_NAME_VERSION (x)] \\\n      : NULL_TREE)\n extern void set_ssa_name_value (tree, tree);\n-extern void threadedge_initialize_values (void);\n-extern void threadedge_finalize_values (void);\n-extern bool potentially_threadable_block (basic_block);\n-extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n-class evrp_range_analyzer;\n-extern void thread_outgoing_edges (basic_block, gcond *,\n-\t\t\t\t   const_and_copies *,\n-\t\t\t\t   avail_exprs_stack *,\n-\t\t\t\t   evrp_range_analyzer *,\n-\t\t\t\t   tree (*) (gimple *, gimple *,\n-\t\t\t\t\t     avail_exprs_stack *, basic_block));\n \n #endif /* GCC_TREE_SSA_THREADEDGE_H */"}, {"sha": "a86302be18e352d3e8a8cf9fc81679643766a15d", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 165, "deletions": 141, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "patch": "@@ -128,7 +128,6 @@ struct redirection_data : free_ptr_hash<redirection_data>\n      which they appear in the jump thread path.  */\n   basic_block dup_blocks[2];\n \n-  /* The jump threading path.  */\n   vec<jump_thread_edge *> *path;\n \n   /* A list of incoming edges which we want to thread to the\n@@ -140,11 +139,66 @@ struct redirection_data : free_ptr_hash<redirection_data>\n   static inline int equal (const redirection_data *, const redirection_data *);\n };\n \n+jump_thread_path_allocator::jump_thread_path_allocator ()\n+{\n+  obstack_init (&m_obstack);\n+}\n+\n+jump_thread_path_allocator::~jump_thread_path_allocator ()\n+{\n+  obstack_free (&m_obstack, NULL);\n+}\n+\n+jump_thread_edge *\n+jump_thread_path_allocator::allocate_thread_edge (edge e,\n+\t\t\t\t\t\t  jump_thread_edge_type type)\n+{\n+  void *r = obstack_alloc (&m_obstack, sizeof (jump_thread_edge));\n+  return new (r) jump_thread_edge (e, type);\n+}\n+\n+vec<jump_thread_edge *> *\n+jump_thread_path_allocator::allocate_thread_path ()\n+{\n+  // ?? Since the paths live in an obstack, we should be able to remove all\n+  // references to path->release() throughout the code.\n+  void *r = obstack_alloc (&m_obstack, sizeof (vec <jump_thread_edge *>));\n+  return new (r) vec<jump_thread_edge *> ();\n+}\n+\n+jump_thread_path_registry::jump_thread_path_registry ()\n+{\n+  m_paths.create (5);\n+  m_removed_edges = new hash_table<struct removed_edges> (17);\n+  m_num_threaded_edges = 0;\n+  m_redirection_data = NULL;\n+}\n+\n+jump_thread_path_registry::~jump_thread_path_registry ()\n+{\n+  m_paths.release ();\n+  delete m_removed_edges;\n+}\n+\n+jump_thread_edge *\n+jump_thread_path_registry::allocate_thread_edge (edge e,\n+\t\t\t\t\t\t jump_thread_edge_type t)\n+{\n+  return m_allocator.allocate_thread_edge (e, t);\n+}\n+\n+vec<jump_thread_edge *> *\n+jump_thread_path_registry::allocate_thread_path ()\n+{\n+  return m_allocator.allocate_thread_path ();\n+}\n+\n /* Dump a jump threading path, including annotations about each\n    edge in the path.  */\n \n-static void\n-dump_jump_thread_path (FILE *dump_file, vec<jump_thread_edge *> path,\n+void\n+dump_jump_thread_path (FILE *dump_file,\n+\t\t       const vec<jump_thread_edge *> path,\n \t\t       bool registering)\n {\n   fprintf (dump_file,\n@@ -178,6 +232,12 @@ dump_jump_thread_path (FILE *dump_file, vec<jump_thread_edge *> path,\n   fputc ('\\n', dump_file);\n }\n \n+DEBUG_FUNCTION void\n+debug (const vec<jump_thread_edge *> &path)\n+{\n+  dump_jump_thread_path (stderr, path, true);\n+}\n+\n /* Simple hashing function.  For any given incoming edge E, we're going\n    to be most concerned with the final destination of its jump thread\n    path.  So hash on the block index of the final edge in the path.  */\n@@ -210,18 +270,6 @@ redirection_data::equal (const redirection_data *p1, const redirection_data *p2)\n   return true;\n }\n \n-/* Rather than search all the edges in jump thread paths each time\n-   DOM is able to simply if control statement, we build a hash table\n-   with the deleted edges.  We only care about the address of the edge,\n-   not its contents.  */\n-struct removed_edges : nofree_ptr_hash<edge_def>\n-{\n-  static hashval_t hash (edge e) { return htab_hash_pointer (e); }\n-  static bool equal (edge e1, edge e2) { return e1 == e2; }\n-};\n-\n-static hash_table<removed_edges> *removed_edges;\n-\n /* Data structure of information to pass to hash table traversal routines.  */\n struct ssa_local_info_t\n {\n@@ -251,34 +299,21 @@ struct ssa_local_info_t\n      final destinations, then we may need to correct for potential\n      profile insanities.  */\n   bool need_profile_correction;\n-};\n \n-/* Passes which use the jump threading code register jump threading\n-   opportunities as they are discovered.  We keep the registered\n-   jump threading opportunities in this vector as edge pairs\n-   (original_edge, target_edge).  */\n-static vec<vec<jump_thread_edge *> *> paths;\n+  // Jump threading statistics.\n+  unsigned long num_threaded_edges;\n+};\n \n /* When we start updating the CFG for threading, data necessary for jump\n    threading is attached to the AUX field for the incoming edge.  Use these\n    macros to access the underlying structure attached to the AUX field.  */\n #define THREAD_PATH(E) ((vec<jump_thread_edge *> *)(E)->aux)\n \n-/* Jump threading statistics.  */\n-\n-struct thread_stats_d\n-{\n-  unsigned long num_threaded_edges;\n-};\n-\n-struct thread_stats_d thread_stats;\n-\n-\n /* Remove the last statement in block BB if it is a control statement\n    Also remove all outgoing edges except the edge which reaches DEST_BB.\n    If DEST_BB is NULL, then remove all outgoing edges.  */\n \n-void\n+static void\n remove_ctrl_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n {\n   gimple_stmt_iterator gsi;\n@@ -360,18 +395,15 @@ create_block_for_threading (basic_block bb,\n     bitmap_set_bit (*duplicate_blocks, rd->dup_blocks[count]->index);\n }\n \n-/* Main data structure to hold information for duplicates of BB.  */\n-\n-static hash_table<redirection_data> *redirection_data;\n-\n /* Given an outgoing edge E lookup and return its entry in our hash table.\n \n    If INSERT is true, then we insert the entry into the hash table if\n    it is not already present.  INCOMING_EDGE is added to the list of incoming\n    edges associated with E in the hash table.  */\n \n-static struct redirection_data *\n-lookup_redirection_data (edge e, enum insert_option insert)\n+redirection_data *\n+jump_thread_path_registry::lookup_redirection_data (edge e,\n+\t\t\t\t\t\t    enum insert_option insert)\n {\n   struct redirection_data **slot;\n   struct redirection_data *elt;\n@@ -385,7 +417,7 @@ lookup_redirection_data (edge e, enum insert_option insert)\n   elt->dup_blocks[1] = NULL;\n   elt->incoming_edges = NULL;\n \n-  slot = redirection_data->find_slot (elt, insert);\n+  slot = m_redirection_data->find_slot (elt, insert);\n \n   /* This will only happen if INSERT is false and the entry is not\n      in the hash table.  */\n@@ -1253,7 +1285,7 @@ ssa_fixup_template_block (struct redirection_data **slot,\n /* Hash table traversal callback to redirect each incoming edge\n    associated with this hash table element to its new destination.  */\n \n-int\n+static int\n ssa_redirect_edges (struct redirection_data **slot,\n \t\t    ssa_local_info_t *local_info)\n {\n@@ -1273,7 +1305,7 @@ ssa_redirect_edges (struct redirection_data **slot,\n       next = el->next;\n       free (el);\n \n-      thread_stats.num_threaded_edges++;\n+      local_info->num_threaded_edges++;\n \n       if (rd->dup_blocks[0])\n \t{\n@@ -1292,7 +1324,7 @@ ssa_redirect_edges (struct redirection_data **slot,\n \n       /* Go ahead and clear E->aux.  It's not needed anymore and failure\n \t to clear it will cause all kinds of unpleasant problems later.  */\n-      delete_jump_thread_path (path);\n+      path->release ();\n       e->aux = NULL;\n \n     }\n@@ -1356,8 +1388,10 @@ redirection_block_p (basic_block bb)\n \n    If JOINERS is true, then thread through joiner blocks as well.  */\n \n-static bool\n-thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n+bool\n+jump_thread_path_registry::thread_block_1 (basic_block bb,\n+\t\t\t\t\t   bool noloop_only,\n+\t\t\t\t\t   bool joiners)\n {\n   /* E is an incoming edge into BB that we may or may not want to\n      redirect to a duplicate of BB.  */\n@@ -1367,12 +1401,13 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n \n   local_info.duplicate_blocks = BITMAP_ALLOC (NULL);\n   local_info.need_profile_correction = false;\n+  local_info.num_threaded_edges = 0;\n \n   /* To avoid scanning a linear array for the element we need we instead\n      use a hash table.  For normal code there should be no noticeable\n      difference.  However, if we have a block with a large number of\n      incoming and outgoing edges such linear searches can get expensive.  */\n-  redirection_data\n+  m_redirection_data\n     = new hash_table<struct redirection_data> (EDGE_COUNT (bb->succs));\n \n   /* Record each unique threaded destination into a hash table for\n@@ -1407,7 +1442,7 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n \t      /* Since this case is not handled by our special code\n \t\t to thread through a loop header, we must explicitly\n \t\t cancel the threading request here.  */\n-\t      delete_jump_thread_path (path);\n+\t      path->release ();\n \t      e->aux = NULL;\n \t      continue;\n \t    }\n@@ -1446,7 +1481,7 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n \n \t      if (i != path->length ())\n \t\t{\n-\t\t  delete_jump_thread_path (path);\n+\t\t  path->release ();\n \t\t  e->aux = NULL;\n \t\t  continue;\n \t\t}\n@@ -1491,27 +1526,27 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n   local_info.template_block = NULL;\n   local_info.bb = bb;\n   local_info.jumps_threaded = false;\n-  redirection_data->traverse <ssa_local_info_t *, ssa_create_duplicates>\n+  m_redirection_data->traverse <ssa_local_info_t *, ssa_create_duplicates>\n \t\t\t    (&local_info);\n \n   /* The template does not have an outgoing edge.  Create that outgoing\n      edge and update PHI nodes as the edge's target as necessary.\n \n      We do this after creating all the duplicates to avoid creating\n      unnecessary edges.  */\n-  redirection_data->traverse <ssa_local_info_t *, ssa_fixup_template_block>\n+  m_redirection_data->traverse <ssa_local_info_t *, ssa_fixup_template_block>\n \t\t\t    (&local_info);\n \n   /* The hash table traversals above created the duplicate blocks (and the\n      statements within the duplicate blocks).  This loop creates PHI nodes for\n      the duplicated blocks and redirects the incoming edges into BB to reach\n      the duplicates of BB.  */\n-  redirection_data->traverse <ssa_local_info_t *, ssa_redirect_edges>\n+  m_redirection_data->traverse <ssa_local_info_t *, ssa_redirect_edges>\n \t\t\t    (&local_info);\n \n   /* Done with this block.  Clear REDIRECTION_DATA.  */\n-  delete redirection_data;\n-  redirection_data = NULL;\n+  delete m_redirection_data;\n+  m_redirection_data = NULL;\n \n   if (noloop_only\n       && bb == bb->loop_father->header)\n@@ -1520,6 +1555,8 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n   BITMAP_FREE (local_info.duplicate_blocks);\n   local_info.duplicate_blocks = NULL;\n \n+  m_num_threaded_edges += local_info.num_threaded_edges;\n+\n   /* Indicate to our caller whether or not any jumps were threaded.  */\n   return local_info.jumps_threaded;\n }\n@@ -1532,8 +1569,8 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n    not worry that copying a joiner block will create a jump threading\n    opportunity.  */\n \n-static bool\n-thread_block (basic_block bb, bool noloop_only)\n+bool\n+jump_thread_path_registry::thread_block (basic_block bb, bool noloop_only)\n {\n   bool retval;\n   retval = thread_block_1 (bb, noloop_only, false);\n@@ -1613,8 +1650,10 @@ determine_bb_domination_status (class loop *loop, basic_block bb)\n    If MAY_PEEL_LOOP_HEADERS is false, we avoid threading from entry edges\n    to the inside of the loop.  */\n \n-static bool\n-thread_through_loop_header (class loop *loop, bool may_peel_loop_headers)\n+bool\n+jump_thread_path_registry::thread_through_loop_header\n+\t\t\t\t(class loop *loop,\n+\t\t\t\t bool may_peel_loop_headers)\n {\n   basic_block header = loop->header;\n   edge e, tgt_edge, latch = loop_latch_edge (loop);\n@@ -1801,7 +1840,7 @@ thread_through_loop_header (class loop *loop, bool may_peel_loop_headers)\n \n       if (path)\n \t{\n-\t  delete_jump_thread_path (path);\n+\t  path->release ();\n \t  e->aux = NULL;\n \t}\n     }\n@@ -1868,8 +1907,8 @@ count_stmts_and_phis_in_block (basic_block bb)\n    discover blocks which need processing and avoids unnecessary\n    hash table lookups to map from threaded edge to new target.  */\n \n-static void\n-mark_threaded_blocks (bitmap threaded_blocks)\n+void\n+jump_thread_path_registry::mark_threaded_blocks (bitmap threaded_blocks)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n@@ -1892,9 +1931,9 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \n      So first convert the jump thread requests which do not require a\n      joiner block.  */\n-  for (i = 0; i < paths.length (); i++)\n+  for (i = 0; i < m_paths.length (); i++)\n     {\n-      vec<jump_thread_edge *> *path = paths[i];\n+      vec<jump_thread_edge *> *path = m_paths[i];\n \n       if (path->length () > 1\n \t  && (*path)[1]->type != EDGE_COPY_SRC_JOINER_BLOCK)\n@@ -1913,9 +1952,9 @@ mark_threaded_blocks (bitmap threaded_blocks)\n      cases where the second path starts at a downstream edge on the same\n      path).  First record all joiner paths, deleting any in the unexpected\n      case where there is already a path for that incoming edge.  */\n-  for (i = 0; i < paths.length ();)\n+  for (i = 0; i < m_paths.length ();)\n     {\n-      vec<jump_thread_edge *> *path = paths[i];\n+      vec<jump_thread_edge *> *path = m_paths[i];\n \n       if (path->length () > 1\n \t  && (*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n@@ -1928,10 +1967,10 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \t    }\n \t  else\n \t    {\n-\t      paths.unordered_remove (i);\n+\t      m_paths.unordered_remove (i);\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tdump_jump_thread_path (dump_file, *path, false);\n-\t      delete_jump_thread_path (path);\n+\t      path->release ();\n \t    }\n \t}\n       else\n@@ -1942,9 +1981,9 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \n   /* Second, look for paths that have any other jump thread attached to\n      them, and either finish converting them or cancel them.  */\n-  for (i = 0; i < paths.length ();)\n+  for (i = 0; i < m_paths.length ();)\n     {\n-      vec<jump_thread_edge *> *path = paths[i];\n+      vec<jump_thread_edge *> *path = m_paths[i];\n       edge e = (*path)[0]->e;\n \n       if (path->length () > 1\n@@ -1965,10 +2004,10 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \t  else\n \t    {\n \t      e->aux = NULL;\n-\t      paths.unordered_remove (i);\n+\t      m_paths.unordered_remove (i);\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tdump_jump_thread_path (dump_file, *path, false);\n-\t      delete_jump_thread_path (path);\n+\t      path->release ();\n \t    }\n \t}\n       else\n@@ -2015,8 +2054,8 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \t\tif (j != path->length ())\n \t\t  {\n \t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t      dump_jump_thread_path (dump_file, *path, 0);\n-\t\t    delete_jump_thread_path (path);\n+\t\t      dump_jump_thread_path (dump_file, *path, false);\n+\t\t    path->release ();\n \t\t    e->aux = NULL;\n \t\t  }\n \t\telse\n@@ -2063,7 +2102,7 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \n \t\t  if (e2 && !phi_args_equal_on_edges (e2, final_edge))\n \t\t    {\n-\t\t      delete_jump_thread_path (path);\n+\t\t      path->release ();\n \t\t      e->aux = NULL;\n \t\t    }\n \t\t}\n@@ -2137,21 +2176,21 @@ bb_in_bbs (basic_block bb, basic_block *bbs, int n)\n   return false;\n }\n \n-DEBUG_FUNCTION void\n-debug_path (FILE *dump_file, int pathno)\n+void\n+jump_thread_path_registry::debug_path (FILE *dump_file, int pathno)\n {\n-  vec<jump_thread_edge *> *p = paths[pathno];\n+  vec<jump_thread_edge *> *p = m_paths[pathno];\n   fprintf (dump_file, \"path: \");\n   for (unsigned i = 0; i < p->length (); ++i)\n     fprintf (dump_file, \"%d -> %d, \",\n \t     (*p)[i]->e->src->index, (*p)[i]->e->dest->index);\n   fprintf (dump_file, \"\\n\");\n }\n \n-DEBUG_FUNCTION void\n-debug_all_paths ()\n+void\n+jump_thread_path_registry::dump ()\n {\n-  for (unsigned i = 0; i < paths.length (); ++i)\n+  for (unsigned i = 0; i < m_paths.length (); ++i)\n     debug_path (stderr, i);\n }\n \n@@ -2163,10 +2202,11 @@ debug_all_paths ()\n \n    Returns TRUE if we were able to successfully rewire the edge.  */\n \n-static bool\n-rewire_first_differing_edge (unsigned path_num, unsigned edge_num)\n+bool\n+jump_thread_path_registry::rewire_first_differing_edge (unsigned path_num,\n+\t\t\t\t\t\t\tunsigned edge_num)\n {\n-  vec<jump_thread_edge *> *path = paths[path_num];\n+  vec<jump_thread_edge *> *path = m_paths[path_num];\n   edge &e = (*path)[edge_num]->e;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"rewiring edge candidate: %d -> %d\\n\",\n@@ -2208,10 +2248,11 @@ rewire_first_differing_edge (unsigned path_num, unsigned edge_num)\n    CURR_PATH_NUM is an index into the global paths table.  It\n    specifies the path that was just threaded.  */\n \n-static void\n-adjust_paths_after_duplication (unsigned curr_path_num)\n+void\n+jump_thread_path_registry::adjust_paths_after_duplication\n+\t(unsigned curr_path_num)\n {\n-  vec<jump_thread_edge *> *curr_path = paths[curr_path_num];\n+  vec<jump_thread_edge *> *curr_path = m_paths[curr_path_num];\n   gcc_assert ((*curr_path)[0]->type == EDGE_FSM_THREAD);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2221,7 +2262,7 @@ adjust_paths_after_duplication (unsigned curr_path_num)\n     }\n \n   /* Iterate through all the other paths and adjust them.  */\n-  for (unsigned cand_path_num = 0; cand_path_num < paths.length (); )\n+  for (unsigned cand_path_num = 0; cand_path_num < m_paths.length (); )\n     {\n       if (cand_path_num == curr_path_num)\n \t{\n@@ -2230,7 +2271,7 @@ adjust_paths_after_duplication (unsigned curr_path_num)\n \t}\n       /* Make sure the candidate to adjust starts with the same path\n \t as the recently threaded path and is an FSM thread.  */\n-      vec<jump_thread_edge *> *cand_path = paths[cand_path_num];\n+      vec<jump_thread_edge *> *cand_path = m_paths[cand_path_num];\n       if ((*cand_path)[0]->type != EDGE_FSM_THREAD\n \t  || (*cand_path)[0]->e != (*curr_path)[0]->e)\n \t{\n@@ -2284,8 +2325,8 @@ adjust_paths_after_duplication (unsigned curr_path_num)\n \t    remove_candidate_from_list:\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"adjusted candidate: [EMPTY]\\n\");\n-\t      delete_jump_thread_path (cand_path);\n-\t      paths.unordered_remove (cand_path_num);\n+\t      cand_path->release ();\n+\t      m_paths.unordered_remove (cand_path_num);\n \t      continue;\n \t    }\n \t  /* Otherwise, just remove the redundant sub-path.  */\n@@ -2312,9 +2353,12 @@ adjust_paths_after_duplication (unsigned curr_path_num)\n \n    Returns false if it is unable to copy the region, true otherwise.  */\n \n-static bool\n-duplicate_thread_path (edge entry, edge exit, basic_block *region,\n-\t\t       unsigned n_region, unsigned current_path_no)\n+bool\n+jump_thread_path_registry::duplicate_thread_path (edge entry,\n+\t\t\t\t\t\t  edge exit,\n+\t\t\t\t\t\t  basic_block *region,\n+\t\t\t\t\t\t  unsigned n_region,\n+\t\t\t\t\t\t  unsigned current_path_no)\n {\n   unsigned i;\n   class loop *loop = entry->dest->loop_father;\n@@ -2489,15 +2533,12 @@ valid_jump_thread_path (vec<jump_thread_edge *> *path)\n    DOM/VRP rather than for every case where DOM optimizes away a COND_EXPR.  */\n \n void\n-remove_jump_threads_including (edge_def *e)\n+jump_thread_path_registry::remove_jump_threads_including (edge_def *e)\n {\n-  if (!paths.exists ())\n+  if (!m_paths.exists ())\n     return;\n \n-  if (!removed_edges)\n-    removed_edges = new hash_table<struct removed_edges> (17);\n-\n-  edge *slot = removed_edges->find_slot (e, INSERT);\n+  edge *slot = m_removed_edges->find_slot (e, INSERT);\n   *slot = e;\n }\n \n@@ -2513,49 +2554,50 @@ remove_jump_threads_including (edge_def *e)\n    Returns true if one or more edges were threaded, false otherwise.  */\n \n bool\n-thread_through_all_blocks (bool may_peel_loop_headers)\n+jump_thread_path_registry::thread_through_all_blocks\n+\t(bool may_peel_loop_headers)\n {\n   bool retval = false;\n   unsigned int i;\n   class loop *loop;\n   auto_bitmap threaded_blocks;\n   hash_set<edge> visited_starting_edges;\n \n-  if (!paths.exists ())\n+  if (!m_paths.exists ())\n     {\n       retval = false;\n       goto out;\n     }\n \n-  memset (&thread_stats, 0, sizeof (thread_stats));\n+  m_num_threaded_edges = 0;\n \n   /* Remove any paths that referenced removed edges.  */\n-  if (removed_edges)\n-    for (i = 0; i < paths.length (); )\n+  if (m_removed_edges)\n+    for (i = 0; i < m_paths.length (); )\n       {\n \tunsigned int j;\n-\tvec<jump_thread_edge *> *path = paths[i];\n+\tvec<jump_thread_edge *> *path = m_paths[i];\n \n \tfor (j = 0; j < path->length (); j++)\n \t  {\n \t    edge e = (*path)[j]->e;\n-\t    if (removed_edges->find_slot (e, NO_INSERT))\n+\t    if (m_removed_edges->find_slot (e, NO_INSERT))\n \t      break;\n \t  }\n \n \tif (j != path->length ())\n \t  {\n-\t    delete_jump_thread_path (path);\n-\t    paths.unordered_remove (i);\n+\t    path->release ();\n+\t    m_paths.unordered_remove (i);\n \t    continue;\n \t  }\n \ti++;\n       }\n \n   /* Jump-thread all FSM threads before other jump-threads.  */\n-  for (i = 0; i < paths.length ();)\n+  for (i = 0; i < m_paths.length ();)\n     {\n-      vec<jump_thread_edge *> *path = paths[i];\n+      vec<jump_thread_edge *> *path = m_paths[i];\n       edge entry = (*path)[0]->e;\n \n       /* Only code-generate FSM jump-threads in this loop.  */\n@@ -2579,8 +2621,8 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n \t  || !valid_jump_thread_path (path))\n \t{\n \t  /* Remove invalid FSM jump-thread paths.  */\n-\t  delete_jump_thread_path (path);\n-\t  paths.unordered_remove (i);\n+\t  path->release ();\n+\t  m_paths.unordered_remove (i);\n \t  continue;\n \t}\n \n@@ -2597,26 +2639,26 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n \t  free_dominance_info (CDI_DOMINATORS);\n \t  visited_starting_edges.add (entry);\n \t  retval = true;\n-\t  thread_stats.num_threaded_edges++;\n+\t  m_num_threaded_edges++;\n \t}\n \n-      delete_jump_thread_path (path);\n-      paths.unordered_remove (i);\n+      path->release ();\n+      m_paths.unordered_remove (i);\n       free (region);\n     }\n \n   /* Remove from PATHS all the jump-threads starting with an edge already\n      jump-threaded.  */\n-  for (i = 0; i < paths.length ();)\n+  for (i = 0; i < m_paths.length ();)\n     {\n-      vec<jump_thread_edge *> *path = paths[i];\n+      vec<jump_thread_edge *> *path = m_paths[i];\n       edge entry = (*path)[0]->e;\n \n       /* Do not jump-thread twice from the same block.  */\n       if (visited_starting_edges.contains (entry))\n \t{\n-\t  delete_jump_thread_path (path);\n-\t  paths.unordered_remove (i);\n+\t  path->release ();\n+\t  m_paths.unordered_remove (i);\n \t}\n       else\n \ti++;\n@@ -2678,34 +2720,19 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n \tgcc_assert (e->aux == NULL);\n     }\n \n-  statistics_counter_event (cfun, \"Jumps threaded\",\n-\t\t\t    thread_stats.num_threaded_edges);\n+  statistics_counter_event (cfun, \"Jumps threaded\", m_num_threaded_edges);\n \n   free_original_copy_tables ();\n \n-  paths.release ();\n+  m_paths.release ();\n \n   if (retval)\n     loops_state_set (LOOPS_NEED_FIXUP);\n \n  out:\n-  delete removed_edges;\n-  removed_edges = NULL;\n   return retval;\n }\n \n-/* Delete the jump threading path PATH.  We have to explicitly delete\n-   each entry in the vector, then the container.  */\n-\n-void\n-delete_jump_thread_path (vec<jump_thread_edge *> *path)\n-{\n-  for (unsigned int i = 0; i < path->length (); i++)\n-    delete (*path)[i];\n-  path->release();\n-  delete path;\n-}\n-\n /* Register a jump threading opportunity.  We queue up all the jump\n    threading opportunities discovered by a pass and update the CFG\n    and SSA form all at once.\n@@ -2715,11 +2742,11 @@ delete_jump_thread_path (vec<jump_thread_edge *> *path)\n    after fixing the SSA graph.  */\n \n void\n-register_jump_thread (vec<jump_thread_edge *> *path)\n+jump_thread_path_registry::register_jump_thread (vec<jump_thread_edge *> *path)\n {\n   if (!dbg_cnt (registered_jump_thread))\n     {\n-      delete_jump_thread_path (path);\n+      path->release ();\n       return;\n     }\n \n@@ -2736,7 +2763,7 @@ register_jump_thread (vec<jump_thread_edge *> *path)\n \t      dump_jump_thread_path (dump_file, *path, false);\n \t    }\n \n-\t  delete_jump_thread_path (path);\n+\t  path->release ();\n \t  return;\n \t}\n \n@@ -2750,10 +2777,7 @@ register_jump_thread (vec<jump_thread_edge *> *path)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_jump_thread_path (dump_file, *path, true);\n \n-  if (!paths.exists ())\n-    paths.create (5);\n-\n-  paths.safe_push (path);\n+  m_paths.safe_push (path);\n }\n \n /* Return how many uses of T there are within BB, as long as there"}, {"sha": "b806caee5817fd66a35400bae2c44df472315bb8", "filename": "gcc/tree-ssa-threadupdate.h", "status": "modified", "additions": 75, "deletions": 10, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-threadupdate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-ssa-threadupdate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.h?ref=d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "patch": "@@ -21,8 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef _TREE_SSA_THREADUPDATE_H\n #define _TREE_SSA_THREADUPDATE_H 1\n \n-/* In tree-ssa-threadupdate.c.  */\n-extern bool thread_through_all_blocks (bool);\n enum jump_thread_edge_type\n {\n   EDGE_START_JUMP_THREAD,\n@@ -32,21 +30,85 @@ enum jump_thread_edge_type\n   EDGE_NO_COPY_SRC_BLOCK\n };\n \n+// We keep the registered jump threading opportunities in this\n+// vector as edge pairs (original_edge, target_edge).\n+\n class jump_thread_edge\n {\n public:\n-  jump_thread_edge (edge e, enum jump_thread_edge_type type)\n-    : e (e), type (type) {}\n+  jump_thread_edge (edge e, jump_thread_edge_type t) : e (e), type (t) {}\n \n   edge e;\n-  enum jump_thread_edge_type type;\n+  jump_thread_edge_type type;\n+};\n+\n+class jump_thread_path_allocator\n+{\n+public:\n+  jump_thread_path_allocator ();\n+  ~jump_thread_path_allocator ();\n+  jump_thread_edge *allocate_thread_edge (edge, jump_thread_edge_type);\n+  vec<jump_thread_edge *> *allocate_thread_path ();\n+private:\n+  DISABLE_COPY_AND_ASSIGN (jump_thread_path_allocator);\n+  obstack m_obstack;\n+};\n+\n+// This is the underlying jump thread registry.  When all candidates\n+// have been registered with register_jump_thread(),\n+// thread_through_all_blocks() is called to actually change the CFG.\n+\n+class jump_thread_path_registry\n+{\n+public:\n+  jump_thread_path_registry ();\n+  ~jump_thread_path_registry ();\n+  void register_jump_thread (vec<jump_thread_edge *> *);\n+  void remove_jump_threads_including (edge);\n+  bool thread_through_all_blocks (bool);\n+  jump_thread_edge *allocate_thread_edge (edge e, jump_thread_edge_type t);\n+  vec<jump_thread_edge *> *allocate_thread_path ();\n+  void dump ();\n+\n+private:\n+  void debug_path (FILE *, int pathno);\n+  void mark_threaded_blocks (bitmap threaded_blocks);\n+  bool rewire_first_differing_edge (unsigned path_num, unsigned edge_num);\n+  void adjust_paths_after_duplication (unsigned curr_path_num);\n+  bool duplicate_thread_path (edge entry,\n+\t\t\t      edge exit,\n+\t\t\t      basic_block *region,\n+\t\t\t      unsigned n_region,\n+\t\t\t      unsigned current_path_no);\n+  bool thread_block_1 (basic_block, bool noloop_only, bool joiners);\n+  bool thread_block (basic_block, bool noloop_only);\n+  bool thread_through_loop_header (class loop *loop,\n+\t\t\t\t   bool may_peel_loop_headers);\n+  class redirection_data *lookup_redirection_data (edge e, enum insert_option);\n+\n+  vec<vec<jump_thread_edge *> *> m_paths;\n+\n+  hash_table<struct removed_edges> *m_removed_edges;\n+\n+  // Main data structure to hold information for duplicates of BB.\n+  hash_table<redirection_data> *m_redirection_data;\n+\n+  // Jump threading statistics.\n+  unsigned long m_num_threaded_edges;\n+\n+  jump_thread_path_allocator m_allocator;\n+};\n+\n+// Rather than search all the edges in jump thread paths each time DOM\n+// is able to simply if control statement, we build a hash table with\n+// the deleted edges.  We only care about the address of the edge, not\n+// its contents.\n+struct removed_edges : nofree_ptr_hash<edge_def>\n+{\n+  static hashval_t hash (edge e) { return htab_hash_pointer (e); }\n+  static bool equal (edge e1, edge e2) { return e1 == e2; }\n };\n \n-extern void register_jump_thread (vec <class jump_thread_edge *> *);\n-extern void remove_jump_threads_including (edge);\n-extern void delete_jump_thread_path (vec <class jump_thread_edge *> *);\n-extern void remove_ctrl_stmt_and_useless_edges (basic_block, basic_block);\n-extern void free_dom_edge_info (edge);\n extern unsigned int estimate_threading_killed_stmts (basic_block);\n \n enum bb_dom_status\n@@ -61,4 +123,7 @@ enum bb_dom_status\n \n enum bb_dom_status determine_bb_domination_status (class loop *, basic_block);\n \n+// In tree-ssa-dom.c.\n+extern void free_dom_edge_info (edge);\n+\n #endif"}, {"sha": "12e6e6f3e22fa0baca2aef25336ba6a9ac559299", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 66, "deletions": 91, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ea47033a726c9b3455ead98b6ddce2403ec6d9/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "patch": "@@ -2373,9 +2373,6 @@ lhs_of_dominating_assert (tree op, basic_block bb, gimple *stmt)\n   return op;\n }\n \n-/* A hack.  */\n-static class vr_values *x_vr_values;\n-\n /* Searches the case label vector VEC for the index *IDX of the CASE_LABEL\n    that includes the value VAL.  The search is restricted to the range\n    [START_IDX, n - 1] where n is the size of VEC.\n@@ -4163,6 +4160,54 @@ vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n   return simplifier.simplify (si);\n }\n \n+class vrp_jump_threader_simplifier : public jump_threader_simplifier\n+{\n+public:\n+  vrp_jump_threader_simplifier (vr_values *v, avail_exprs_stack *avails)\n+    : jump_threader_simplifier (v, avails) {}\n+\n+private:\n+  tree simplify (gimple *, gimple *, basic_block) OVERRIDE;\n+};\n+\n+tree\n+vrp_jump_threader_simplifier::simplify (gimple *stmt,\n+\t\t\t\t\tgimple *within_stmt,\n+\t\t\t\t\tbasic_block bb)\n+{\n+  /* First see if the conditional is in the hash table.  */\n+  tree cached_lhs = m_avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n+  if (cached_lhs && is_gimple_min_invariant (cached_lhs))\n+    return cached_lhs;\n+\n+  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n+    {\n+      tree op0 = gimple_cond_lhs (cond_stmt);\n+      op0 = lhs_of_dominating_assert (op0, bb, stmt);\n+\n+      tree op1 = gimple_cond_rhs (cond_stmt);\n+      op1 = lhs_of_dominating_assert (op1, bb, stmt);\n+\n+      simplify_using_ranges simplifier (m_vr_values);\n+      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t\t\t  op0, op1, within_stmt);\n+    }\n+\n+  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n+    {\n+      tree op = gimple_switch_index (switch_stmt);\n+      if (TREE_CODE (op) != SSA_NAME)\n+\treturn NULL_TREE;\n+\n+      op = lhs_of_dominating_assert (op, bb, stmt);\n+\n+      const value_range_equiv *vr = m_vr_values->get_value_range (op);\n+      return find_case_label_range (switch_stmt, vr);\n+    }\n+\n+  return jump_threader_simplifier::simplify (stmt, within_stmt, bb);\n+}\n+\n /* Blocks which have more than one predecessor and more than\n    one successor present jump threading opportunities, i.e.,\n    when the block is reached from a specific predecessor, we\n@@ -4186,17 +4231,21 @@ vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n class vrp_jump_threader : public dom_walker\n {\n public:\n-  vrp_jump_threader (struct function *, vr_values *);\n+  vrp_jump_threader (function *, vr_values *);\n   ~vrp_jump_threader ();\n \n   void thread_jumps ()\n   {\n     walk (m_fun->cfg->x_entry_block_ptr);\n   }\n \n+  void thread_through_all_blocks ()\n+  {\n+    // FIXME: Put this in the destructor?\n+    m_threader->thread_through_all_blocks (false);\n+  }\n+\n private:\n-  static tree simplify_stmt (gimple *stmt, gimple *within_stmt,\n-\t\t\t     avail_exprs_stack *, basic_block);\n   virtual edge before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n \n@@ -4205,7 +4254,8 @@ class vrp_jump_threader : public dom_walker\n   const_and_copies *m_const_and_copies;\n   avail_exprs_stack *m_avail_exprs_stack;\n   hash_table<expr_elt_hasher> *m_avail_exprs;\n-  gcond *m_dummy_cond;\n+  vrp_jump_threader_simplifier *m_simplifier;\n+  jump_threader *m_threader;\n };\n \n vrp_jump_threader::vrp_jump_threader (struct function *fun, vr_values *v)\n@@ -4227,11 +4277,15 @@ vrp_jump_threader::vrp_jump_threader (struct function *fun, vr_values *v)\n      that might be recorded.  */\n   m_const_and_copies = new const_and_copies ();\n \n-  m_dummy_cond = NULL;\n   m_fun = fun;\n   m_vr_values = v;\n   m_avail_exprs = new hash_table<expr_elt_hasher> (1024);\n   m_avail_exprs_stack = new avail_exprs_stack (m_avail_exprs);\n+\n+  m_simplifier = new vrp_jump_threader_simplifier (m_vr_values,\n+\t\t\t\t\t\t   m_avail_exprs_stack);\n+  m_threader = new jump_threader (m_const_and_copies, m_avail_exprs_stack,\n+\t\t\t\t  m_simplifier);\n }\n \n vrp_jump_threader::~vrp_jump_threader ()\n@@ -4242,6 +4296,8 @@ vrp_jump_threader::~vrp_jump_threader ()\n   delete m_const_and_copies;\n   delete m_avail_exprs;\n   delete m_avail_exprs_stack;\n+  delete m_simplifier;\n+  delete m_threader;\n }\n \n /* Called before processing dominator children of BB.  We want to look\n@@ -4284,89 +4340,12 @@ vrp_jump_threader::before_dom_children (basic_block bb)\n   return NULL;\n }\n \n-/* A trivial wrapper so that we can present the generic jump threading\n-   code with a simple API for simplifying statements.  STMT is the\n-   statement we want to simplify, WITHIN_STMT provides the location\n-   for any overflow warnings.\n-\n-   ?? This should be cleaned up.  There's a virtually identical copy\n-   of this function in tree-ssa-dom.c.  */\n-\n-tree\n-vrp_jump_threader::simplify_stmt (gimple *stmt,\n-\t\t\t\t  gimple *within_stmt,\n-\t\t\t\t  avail_exprs_stack *avail_exprs_stack,\n-\t\t\t\t  basic_block bb)\n-{\n-  /* First see if the conditional is in the hash table.  */\n-  tree cached_lhs = avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n-  if (cached_lhs && is_gimple_min_invariant (cached_lhs))\n-    return cached_lhs;\n-\n-  class vr_values *vr_values = x_vr_values;\n-  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n-    {\n-      tree op0 = gimple_cond_lhs (cond_stmt);\n-      op0 = lhs_of_dominating_assert (op0, bb, stmt);\n-\n-      tree op1 = gimple_cond_rhs (cond_stmt);\n-      op1 = lhs_of_dominating_assert (op1, bb, stmt);\n-\n-      simplify_using_ranges simplifier (vr_values);\n-      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n-\t\t\t\t\t\t  op0, op1, within_stmt);\n-    }\n-\n-  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n-    {\n-      tree op = gimple_switch_index (switch_stmt);\n-      if (TREE_CODE (op) != SSA_NAME)\n-\treturn NULL_TREE;\n-\n-      op = lhs_of_dominating_assert (op, bb, stmt);\n-\n-      const value_range_equiv *vr = vr_values->get_value_range (op);\n-      return find_case_label_range (switch_stmt, vr);\n-    }\n-\n-  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n-    {\n-      tree lhs = gimple_assign_lhs (assign_stmt);\n-      if (TREE_CODE (lhs) == SSA_NAME\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\t  && stmt_interesting_for_vrp (stmt))\n-\t{\n-\t  edge dummy_e;\n-\t  tree dummy_tree;\n-\t  value_range_equiv new_vr;\n-\t  vr_values->extract_range_from_stmt (stmt, &dummy_e,\n-\t\t\t\t\t      &dummy_tree, &new_vr);\n-\t  tree singleton;\n-\t  if (new_vr.singleton_p (&singleton))\n-\t    return singleton;\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Called after processing dominator children of BB.  This is where we\n    actually call into the threader.  */\n void\n vrp_jump_threader::after_dom_children (basic_block bb)\n {\n-  if (!m_dummy_cond)\n-    m_dummy_cond = gimple_build_cond (NE_EXPR,\n-\t\t\t\t      integer_zero_node, integer_zero_node,\n-\t\t\t\t      NULL, NULL);\n-\n-  x_vr_values = m_vr_values;\n-  thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,\n-\t\t\t m_avail_exprs_stack, NULL,\n-\t\t\t simplify_stmt);\n-  x_vr_values = NULL;\n-\n+  m_threader->thread_outgoing_edges (bb);\n   m_avail_exprs_stack->pop_to_marker ();\n   m_const_and_copies->pop_to_marker ();\n }\n@@ -4500,8 +4479,6 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n   vrp_asserts assert_engine (fun);\n   assert_engine.insert_range_assertions ();\n \n-  threadedge_initialize_values ();\n-\n   /* For visiting PHI nodes we need EDGE_DFS_BACK computed.  */\n   mark_dfs_back_edges ();\n \n@@ -4577,9 +4554,7 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n \n      Note the SSA graph update will occur during the normal TODO\n      processing by the pass manager.  */\n-  thread_through_all_blocks (false);\n-\n-  threadedge_finalize_values ();\n+  threader.thread_through_all_blocks ();\n \n   scev_finalize ();\n   loop_optimizer_finalize ();"}]}