{"sha": "0b5b2bbc71dfb621df534b9cc16536eb083046ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI1YjJiYmM3MWRmYjYyMWRmNTM0YjljYzE2NTM2ZWIwODMwNDZjZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-15T10:22:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-15T10:22:54Z"}, "message": "[multiple changes]\n\n2011-09-15  Robert Dewar  <dewar@adacore.com>\n\n\t* a-cdlili.adb, a-coinve.adb, a-stzunb-shared.ads, a-suezst.adb,\n\ta-suenco.adb, a-stwiun-shared.ads, a-cobove.adb, a-convec.adb,\n\ta-btgbso.adb, a-cbdlli.adb, a-suewst.adb: Minor reformatting.\n\n2011-09-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): Code cleanup:\n\tif the expression function is not a completion, create a\n\tnew specification for the generated declaration, and keep the\n\toriginal specification in the generated body. Shorter code also\n\tensures that proper warnings are generated for unused formals\n\tin all cases.\n\n2011-09-15  Sergey Rybin  <rybin@adacore.com>\n\n\t* tree_io.ads: Update ASIS_Version_Number because of the changes\n\tin the tree structures for expression functions.\n\n2011-09-15  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-osinte-aix.ads, s-osinte-darwin.ads, s-osinte-freebsd.ads,\n\ts-osinte-hpux.ads, s-osinte-lynxos.ads, s-osinte-solaris-posix.ads,\n\ts-taprop-posix.adb (CLOCK_MONOTONIC): New constant.\n\t(CLOCK_REALTIME): Fix wrong value on some OSes.\n\t* s-taprop-posix.adb (Monotonic_Clock): Use CLOCK_MONOTONIC.\n\nFrom-SVN: r178877", "tree": {"sha": "02b448f73c0093fbfe3345e763787607a8a726b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02b448f73c0093fbfe3345e763787607a8a726b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b5b2bbc71dfb621df534b9cc16536eb083046ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b5b2bbc71dfb621df534b9cc16536eb083046ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b5b2bbc71dfb621df534b9cc16536eb083046ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b5b2bbc71dfb621df534b9cc16536eb083046ce/comments", "author": null, "committer": null, "parents": [{"sha": "21f1e8ce7288b853f431202fa3b61e12f823ae7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21f1e8ce7288b853f431202fa3b61e12f823ae7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21f1e8ce7288b853f431202fa3b61e12f823ae7d"}], "stats": {"total": 491, "additions": 293, "deletions": 198}, "files": [{"sha": "36d466137c4e386473d498de6cf552bd3f43fa8a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -1,3 +1,31 @@\n+2011-09-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-cdlili.adb, a-coinve.adb, a-stzunb-shared.ads, a-suezst.adb,\n+\ta-suenco.adb, a-stwiun-shared.ads, a-cobove.adb, a-convec.adb,\n+\ta-btgbso.adb, a-cbdlli.adb, a-suewst.adb: Minor reformatting.\n+\n+2011-09-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): Code cleanup:\n+\tif the expression function is not a completion, create a\n+\tnew specification for the generated declaration, and keep the\n+\toriginal specification in the generated body. Shorter code also\n+\tensures that proper warnings are generated for unused formals\n+\tin all cases.\n+\n+2011-09-15  Sergey Rybin  <rybin@adacore.com>\n+\n+\t* tree_io.ads: Update ASIS_Version_Number because of the changes\n+\tin the tree structures for expression functions.\n+\n+2011-09-15  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-osinte-aix.ads, s-osinte-darwin.ads, s-osinte-freebsd.ads,\n+\ts-osinte-hpux.ads, s-osinte-lynxos.ads, s-osinte-solaris-posix.ads,\n+\ts-taprop-posix.adb (CLOCK_MONOTONIC): New constant.\n+\t(CLOCK_REALTIME): Fix wrong value on some OSes.\n+\t* s-taprop-posix.adb (Monotonic_Clock): Use CLOCK_MONOTONIC.\n+\n 2011-09-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (maybe_unconstrained_array): In the reference"}, {"sha": "b62007aafb3960c43cbba7c58fb25ad8a64e3786", "filename": "gcc/ada/a-btgbso.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-btgbso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-btgbso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-btgbso.adb?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -546,11 +546,10 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n            \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n-      --  Note that there's no way to decide a priori whether the\n-      --  target has enough capacity for the union with source.\n-      --  We cannot simply compare the sum of the existing lengths\n-      --  to the capacity of the target, because equivalent items\n-      --  from source are not included in the union.\n+      --  Note that there's no way to decide a priori whether the target has\n+      --  enough capacity for the union with source. We cannot simply compare\n+      --  the sum of the existing lengths to the capacity of the target,\n+      --  because equivalent items from source are not included in the union.\n \n       Iterate (Source);\n    end Set_Union;"}, {"sha": "1b10d42b4a36ccce921d599463d9832e7c33ae81", "filename": "gcc/ada/a-cbdlli.adb", "status": "modified", "additions": 54, "deletions": 51, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -582,64 +582,65 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       --  The list container actually contains two lists: one for the \"active\"\n       --  nodes that contain elements that have been inserted onto the list,\n       --  and another for the \"inactive\" nodes for the free store.\n-      --\n+\n       --  We desire that merely declaring an object should have only minimal\n       --  cost; specially, we want to avoid having to initialize the free\n       --  store (to fill in the links), especially if the capacity is large.\n-      --\n+\n       --  The head of the free list is indicated by Container.Free. If its\n-      --  value is non-negative, then the free store has been initialized\n-      --  in the \"normal\" way: Container.Free points to the head of the list\n-      --  of free (inactive) nodes, and the value 0 means the free list is\n-      --  empty. Each node on the free list has been initialized to point\n-      --  to the next free node (via its Next component), and the value 0\n-      --  means that this is the last free node.\n-      --\n-      --  If Container.Free is negative, then the links on the free store\n-      --  have not been initialized. In this case the link values are\n-      --  implied: the free store comprises the components of the node array\n-      --  started with the absolute value of Container.Free, and continuing\n-      --  until the end of the array (Nodes'Last).\n-      --\n-      --  If the list container is manipulated on one end only (for example\n-      --  if the container were being used as a stack), then there is no\n-      --  need to initialize the free store, since the inactive nodes are\n-      --  physically contiguous (in fact, they lie immediately beyond the\n-      --  logical end being manipulated). The only time we need to actually\n-      --  initialize the nodes in the free store is if the node that becomes\n-      --  inactive is not at the end of the list. The free store would then\n-      --  be discontiguous and so its nodes would need to be linked in the\n-      --  traditional way.\n-      --\n+      --  value is non-negative, then the free store has been initialized in\n+      --  the \"normal\" way: Container.Free points to the head of the list of\n+      --  free (inactive) nodes, and the value 0 means the free list is empty.\n+      --  Each node on the free list has been initialized to point to the next\n+      --  free node (via its Next component), and the value 0 means that this\n+      --  is the last free node.\n+\n+      --  If Container.Free is negative, then the links on the free store have\n+      --  not been initialized. In this case the link values are implied: the\n+      --  free store comprises the components of the node array started with\n+      --  the absolute value of Container.Free, and continuing until the end of\n+      --  the array (Nodes'Last).\n+\n+      --  If the list container is manipulated on one end only (for example if\n+      --  the container were being used as a stack), then there is no need to\n+      --  initialize the free store, since the inactive nodes are physically\n+      --  contiguous (in fact, they lie immediately beyond the logical end\n+      --  being manipulated). The only time we need to actually initialize the\n+      --  nodes in the free store is if the node that becomes inactive is not\n+      --  at the end of the list. The free store would then be discontiguous\n+      --  and so its nodes would need to be linked in the traditional way.\n+\n       --  ???\n       --  It might be possible to perform an optimization here. Suppose that\n-      --  the free store can be represented as having two parts: one\n-      --  comprising the non-contiguous inactive nodes linked together\n-      --  in the normal way, and the other comprising the contiguous\n-      --  inactive nodes (that are not linked together, at the end of the\n-      --  nodes array). This would allow us to never have to initialize\n-      --  the free store, except in a lazy way as nodes become inactive.\n-\n-      --  When an element is deleted from the list container, its node\n-      --  becomes inactive, and so we set its Prev component to a negative\n-      --  value, to indicate that it is now inactive. This provides a useful\n-      --  way to detect a dangling cursor reference.\n+      --  the free store can be represented as having two parts: one comprising\n+      --  the non-contiguous inactive nodes linked together in the normal way,\n+      --  and the other comprising the contiguous inactive nodes (that are not\n+      --  linked together, at the end of the nodes array). This would allow us\n+      --  to never have to initialize the free store, except in a lazy way as\n+      --  nodes become inactive.\n+\n+      --  When an element is deleted from the list container, its node becomes\n+      --  inactive, and so we set its Prev component to a negative value, to\n+      --  indicate that it is now inactive. This provides a useful way to\n+      --  detect a dangling cursor reference.\n \n       N (X).Prev := -1;  -- Node is deallocated (not on active list)\n \n       if Container.Free >= 0 then\n+\n          --  The free store has previously been initialized. All we need to\n          --  do here is link the newly-free'd node onto the free list.\n \n          N (X).Next := Container.Free;\n          Container.Free := X;\n \n       elsif X + 1 = abs Container.Free then\n+\n          --  The free store has not been initialized, and the node becoming\n          --  inactive immediately precedes the start of the free store. All\n          --  we need to do is move the start of the free store back by one.\n \n-         N (X).Next := 0;  -- Not strictly necessary, but marginally safer\n+         N (X).Next := 0;  -- not strictly necessary, but marginally safer\n          Container.Free := Container.Free + 1;\n \n       else\n@@ -650,11 +651,10 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          --  node onto the head of the free store.\n \n          --  ???\n-         --  See the comments above for an optimization opportunity. If\n-         --  the next link for a node on the free store is negative, then\n-         --  this means the remaining nodes on the free store are\n-         --  physically contiguous, starting as the absolute value of\n-         --  that index value.\n+         --  See the comments above for an optimization opportunity. If the\n+         --  next link for a node on the free store is negative, then this\n+         --  means the remaining nodes on the free store are physically\n+         --  contiguous, starting as the absolute value of that index value.\n \n          Container.Free := abs Container.Free;\n \n@@ -689,7 +689,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          Node  : Count_Type := Container.First;\n \n       begin\n-         for I in 2 .. Container.Length loop\n+         for J in 2 .. Container.Length loop\n             if Nodes (Nodes (Node).Next).Element < Nodes (Node).Element then\n                return False;\n             end if;\n@@ -766,17 +766,20 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          N : Node_Array renames Container.Nodes;\n \n          procedure Partition (Pivot, Back : Count_Type);\n+         --  What does this do ???\n \n          procedure Sort (Front, Back : Count_Type);\n+         --  Internal procedure, what does it do??? rename it???\n \n          ---------------\n          -- Partition --\n          ---------------\n \n          procedure Partition (Pivot, Back : Count_Type) is\n-            Node : Count_Type := N (Pivot).Next;\n+            Node : Count_Type;\n \n          begin\n+            Node := N (Pivot).Next;\n             while Node /= Back loop\n                if N (Node).Element < N (Pivot).Element then\n                   declare\n@@ -2066,21 +2069,21 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n             return False;\n          end if;\n \n-         if Position.Node = L.First then  -- eliminates earlier disjunct\n+         --  Eliminate earlier disjunct\n+\n+         if Position.Node = L.First then\n             return True;\n          end if;\n \n-         --  If we get here, we know, per disjunctive syllogism (modus\n-         --  tollendo ponens), that this predicate is true:\n-         --  N (Position.Node).Prev /= 0\n+         --  If we get here, we know (disjunctive syllogism) that this\n+         --  predicate is true: N (Position.Node).Prev /= 0\n \n          if Position.Node = L.Last then  -- eliminates earlier disjunct\n             return True;\n          end if;\n \n-         --  If we get here, we know, per disjunctive syllogism (modus\n-         --  tollendo ponens), that this predicate is true:\n-         --  N (Position.Node).Next /= 0\n+         --  If we get here, we know (disjunctive syllogism) that this\n+         --  predicate is true: N (Position.Node).Next /= 0\n \n          if N (N (Position.Node).Next).Prev /= Position.Node then\n             return False;"}, {"sha": "497a1112d435b1c3fdc8f75d294b4f9bff323118", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -1890,21 +1890,23 @@ package body Ada.Containers.Doubly_Linked_Lists is\n             return False;\n          end if;\n \n-         if Position.Node = L.First then  -- eliminates earlier disjunct\n+         --  Eliminate earlier disjunct\n+\n+         if Position.Node = L.First then\n             return True;\n          end if;\n \n-         --  If we get here, we know, per disjunctive syllogism (modus\n-         --  tollendo ponens), that this predicate is true:\n-         --  Position.Node.Prev /= null\n+         --  If we get here, we know (disjunctive syllogism) that this\n+         --  predicate is true: Position.Node.Prev /= null\n+\n+         --  Eliminate earlier disjunct\n \n-         if Position.Node = L.Last then  -- eliminates earlier disjunct\n+         if Position.Node = L.Last then\n             return True;\n          end if;\n \n-         --  If we get here, we know, per disjunctive syllogism (modus\n-         --  tollendo ponens), that this predicate is true:\n-         --  Position.Node.Next /= null\n+         --  If we get here, we know (disjunctive syllogism) that this\n+         --  predicate is true: Position.Node.Next /= null\n \n          if Position.Node.Next.Prev /= Position.Node then\n             return False;"}, {"sha": "16d465d5f0ec48492f8d69e4cb3f264f4a52db06", "filename": "gcc/ada/a-cobove.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-cobove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-cobove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.adb?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -1394,8 +1394,8 @@ package body Ada.Containers.Bounded_Vectors is\n \n       --  There are two constraints we need to satisfy. The first constraint is\n       --  that a container cannot have more than Count_Type'Last elements, so\n-      --  we must check the sum of the current length and the insertion\n-      --  count. Note that we cannot simply add these values, because of the\n+      --  we must check the sum of the current length and the insertion count.\n+      --  Note that we cannot simply add these values, because of the\n       --  possibility of overflow.\n \n       if Old_Length > Count_Type'Last - Count then"}, {"sha": "3172bd2c7b530cee96691ccafc160a101543866d", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 102, "deletions": 57, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -651,6 +651,41 @@ package body Ada.Containers.Indefinite_Vectors is\n       end loop;\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : Vector;\n+      Position  : Cursor) return Constant_Reference_Type\n+   is\n+   begin\n+      pragma Unreferenced (Container);\n+\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      if Position.Index > Position.Container.Last then\n+         raise Constraint_Error with \"Position cursor is out of range\";\n+      end if;\n+\n+      return\n+       (Element => Position.Container.Elements.EA (Position.Index).all'Access);\n+   end Constant_Reference;\n+\n+   function Constant_Reference\n+     (Container : Vector;\n+      Position  : Index_Type) return Constant_Reference_Type\n+   is\n+   begin\n+      if (Position) > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      return (Element => Container.Elements.EA (Position).all'Access);\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1365,8 +1400,8 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       --  There are two constraints we need to satisfy. The first constraint is\n       --  that a container cannot have more than Count_Type'Last elements, so\n-      --  we must check the sum of the current length and the insertion\n-      --  count. Note that we cannot simply add these values, because of the\n+      --  we must check the sum of the current length and the insertion count.\n+      --  Note that we cannot simply add these values, because of the\n       --  possibility of overflow.\n \n       if Old_Length > Count_Type'Last - Count then\n@@ -1385,17 +1420,20 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  acceptable, then we compute the new last index from that.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We have to handle the case when there might be more values in the\n          --  range of Index_Type than in the range of Count_Type.\n \n          if Index_Type'First <= 0 then\n+\n             --  We know that No_Index (the same as Index_Type'First - 1) is\n             --  less than 0, so it is safe to compute the following sum without\n             --  fear of overflow.\n \n             Index := No_Index + Index_Type'Base (Count_Type'Last);\n \n             if Index <= Index_Type'Last then\n+\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -1420,13 +1458,15 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  We know that No_Index (the same as Index_Type'First - 1) is less\n          --  than 0, so it is safe to compute the following sum without fear of\n          --  overflow.\n \n          J := Count_Type'Base (No_Index) + Count_Type'Last;\n \n          if J <= Count_Type'Base (Index_Type'Last) then\n+\n             --  We have determined that range of Index_Type has at least as\n             --  many values as in Count_Type, so Count_Type'Last is the maximum\n             --  number of items that are allowed.\n@@ -1491,6 +1531,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          --  allocate the elements.\n \n          for Idx in Container.Elements.EA'Range loop\n+\n             --  In order to preserve container invariants, we always attempt\n             --  the element allocation first, before setting the Last index\n             --  value, in case the allocation fails (either because there is no\n@@ -1519,6 +1560,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if New_Length <= Container.Elements.EA'Length then\n+\n          --  In this case, we're inserting elements into a vector that has\n          --  already allocated an internal array, and the existing array has\n          --  enough unused storage for the new items.\n@@ -1529,10 +1571,12 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          begin\n             if Before > Container.Last then\n+\n                --  The new items are being appended to the vector, so no\n                --  sliding of existing elements is required.\n \n                for Idx in Before .. New_Last loop\n+\n                   --  In order to preserve container invariants, we always\n                   --  attempt the element allocation first, before setting the\n                   --  Last index value, in case the allocation fails (either\n@@ -1556,7 +1600,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n                if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n                   Index := Before + Index_Type'Base (Count);\n-\n                else\n                   Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n                end if;\n@@ -1622,6 +1665,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end loop;\n \n       if New_Capacity > Max_Length then\n+\n          --  We have reached the limit of capacity, so no further expansion\n          --  will occur. (This is not a problem, as there is never a need to\n          --  have more capacity than the maximum container length.)\n@@ -1659,6 +1703,7 @@ package body Ada.Containers.Indefinite_Vectors is\n            Src.EA (Index_Type'First .. Before - 1);\n \n          if Before > Container.Last then\n+\n             --  The new items are being appended to the vector, so no\n             --  sliding of existing elements is required.\n \n@@ -1672,6 +1717,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  Now we append the new items.\n \n             for Idx in Before .. New_Last loop\n+\n                --  In order to preserve container invariants, we always\n                --  attempt the element allocation first, before setting the\n                --  Last index value, in case the allocation fails (either\n@@ -1712,6 +1758,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  items.\n \n             for Idx in Before .. Index - 1 loop\n+\n                --  Note that container invariants have already been satisfied\n                --  (in particular, the Last index value of the vector has\n                --  already been updated), so if this allocation fails we simply\n@@ -1738,13 +1785,15 @@ package body Ada.Containers.Indefinite_Vectors is\n       Insert_Space (Container, Before, Count => N);\n \n       if N = 0 then\n+\n          --  There's nothing else to do here (vetting of parameters was\n          --  performed already in Insert_Space), so we simply return.\n \n          return;\n       end if;\n \n       if Container'Address /= New_Item'Address then\n+\n          --  This is the simple case.  New_Item denotes an object different\n          --  from Container, so there's nothing special we need to do to copy\n          --  the source items to their destination, because all of the source\n@@ -1812,6 +1861,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          end loop;\n \n          if Src'Length = N then\n+\n             --  The new items were effectively appended to the container, so we\n             --  have already copied all of the items that need to be copied.\n             --  We return early here, even though the source slice below is\n@@ -1824,12 +1874,11 @@ package body Ada.Containers.Indefinite_Vectors is\n       end;\n \n       --  Index value J is the first index of the second source slice. (It is\n-      --  also 1 greater than the last index of the destination slice.) Note\n-      --  that we want to avoid computing J, if J is greater than\n-      --  Index_Type'Base'Last, in order to avoid overflow. We prevent that by\n-      --  returning early above, immediately after copying the first slice of\n-      --  the source, and determining that this second slice of the source is\n-      --  empty.\n+      --  also 1 greater than the last index of the destination slice.) Note:\n+      --  avoid computing J if J is greater than Index_Type'Base'Last, in order\n+      --  to avoid overflow. Prevent that by returning early above, immediately\n+      --  after copying the first slice of the source, and determining that\n+      --  this second slice of the source is empty.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          J := Before + Index_Type'Base (N);\n@@ -1850,11 +1899,10 @@ package body Ada.Containers.Indefinite_Vectors is\n          Dst_Index : Index_Type'Base;\n \n       begin\n-         --  We next copy the source items that follow the space we\n-         --  inserted. Index value Dst_Index is the first index of that portion\n-         --  of the destination that receives this slice of the source. (For\n-         --  the reasons given above, this slice is guaranteed to be\n-         --  non-empty.)\n+         --  We next copy the source items that follow the space we inserted.\n+         --  Index value Dst_Index is the first index of that portion of the\n+         --  destination that receives this slice of the source. (For the\n+         --  reasons given above, this slice is guaranteed to be non-empty.)\n \n          if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n             Dst_Index := J - Index_Type'Base (Src'Length);\n@@ -2122,13 +2170,15 @@ package body Ada.Containers.Indefinite_Vectors is\n          --  range of Index_Type than in the range of Count_Type.\n \n          if Index_Type'First <= 0 then\n+\n             --  We know that No_Index (the same as Index_Type'First - 1) is\n             --  less than 0, so it is safe to compute the following sum without\n             --  fear of overflow.\n \n             Index := No_Index + Index_Type'Base (Count_Type'Last);\n \n             if Index <= Index_Type'Last then\n+\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -2153,13 +2203,15 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  We know that No_Index (the same as Index_Type'First - 1) is less\n          --  than 0, so it is safe to compute the following sum without fear of\n          --  overflow.\n \n          J := Count_Type'Base (No_Index) + Count_Type'Last;\n \n          if J <= Count_Type'Base (Index_Type'Last) then\n+\n             --  We have determined that range of Index_Type has at least as\n             --  many values as in Count_Type, so Count_Type'Last is the maximum\n             --  number of items that are allowed.\n@@ -2216,9 +2268,9 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          --  In an indefinite vector, elements are allocated individually, and\n          --  stored as access values on the internal array (the length of which\n-         --  represents the vector \"capacity\"), which is separately\n-         --  allocated. We have no elements here (because we're inserting\n-         --  \"space\"), so all we need to do is allocate the backbone.\n+         --  represents the vector \"capacity\"), which is separately allocated.\n+         --  We have no elements here (because we're inserting \"space\"), so all\n+         --  we need to do is allocate the backbone.\n \n          Container.Elements := new Elements_Type (New_Last);\n          Container.Last := New_Last;\n@@ -2228,9 +2280,9 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       --  The tampering bits exist to prevent an item from being harmfully\n       --  manipulated while it is being visited. Query, Update, and Iterate\n-      --  increment the busy count on entry, and decrement the count on\n-      --  exit. Insert checks the count to determine whether it is being called\n-      --  while the associated callback procedure is executing.\n+      --  increment the busy count on entry, and decrement the count on exit.\n+      --  Insert checks the count to determine whether it is being called while\n+      --  the associated callback procedure is executing.\n \n       if Container.Busy > 0 then\n          raise Program_Error with\n@@ -2247,6 +2299,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          begin\n             if Before <= Container.Last then\n+\n                --  The new space is being inserted before some existing\n                --  elements, so we must slide the existing elements up to their\n                --  new home. We use the wider of Index_Type'Base and\n@@ -2288,6 +2341,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end loop;\n \n       if New_Capacity > Max_Length then\n+\n          --  We have reached the limit of capacity, so no further expansion\n          --  will occur. (This is not a problem, as there is never a need to\n          --  have more capacity than the maximum container length.)\n@@ -2325,6 +2379,7 @@ package body Ada.Containers.Indefinite_Vectors is\n            Src.EA (Index_Type'First .. Before - 1);\n \n          if Before <= Container.Last then\n+\n             --  The new items are being inserted before some existing elements,\n             --  so we must slide the existing elements up to their new home.\n \n@@ -2778,37 +2833,10 @@ package body Ada.Containers.Indefinite_Vectors is\n    -- Reference --\n    ---------------\n \n-   function Constant_Reference\n-     (Container : Vector; Position : Cursor)    --  SHOULD BE ALIASED\n-   return Constant_Reference_Type is\n-   begin\n-      pragma Unreferenced (Container);\n-\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      if Position.Index > Position.Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n-      end if;\n-\n-      return\n-       (Element => Position.Container.Elements.EA (Position.Index).all'Access);\n-   end Constant_Reference;\n-\n-   function Constant_Reference\n-     (Container : Vector; Position : Index_Type)\n-   return Constant_Reference_Type is\n-   begin\n-      if (Position) > Container.Last then\n-         raise Constraint_Error with \"Index is out of range\";\n-      end if;\n-\n-      return (Element => Container.Elements.EA (Position).all'Access);\n-   end Constant_Reference;\n-\n-   function Reference (Container : Vector; Position : Cursor)\n-   return Reference_Type is\n+   function Reference\n+     (Container : Vector;\n+      Position  : Cursor) return Reference_Type\n+   is\n    begin\n       pragma Unreferenced (Container);\n \n@@ -2825,8 +2853,10 @@ package body Ada.Containers.Indefinite_Vectors is\n            Position.Container.Elements.EA (Position.Index).all'Access);\n    end Reference;\n \n-   function Reference (Container : Vector; Position : Index_Type)\n-   return Reference_Type is\n+   function Reference\n+     (Container : Vector;\n+      Position  : Index_Type) return Reference_Type\n+   is\n    begin\n       if Position > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n@@ -2916,17 +2946,20 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  container length.\n \n       if Capacity = 0 then\n+\n          --  This is a request to trim back storage, to the minimum amount\n          --  possible given the current state of the container.\n \n          if N = 0 then\n+\n             --  The container is empty, so in this unique case we can\n             --  deallocate the entire internal array. Note that an empty\n             --  container can never be busy, so there's no need to check the\n             --  tampering bits.\n \n             declare\n                X : Elements_Access := Container.Elements;\n+\n             begin\n                --  First we remove the internal array from the container, to\n                --  handle the case when the deallocation raises an exception\n@@ -2942,6 +2975,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             end;\n \n          elsif N < Container.Elements.EA'Length then\n+\n             --  The container is not empty, and the current length is less than\n             --  the current capacity, so there's storage available to trim. In\n             --  this case, we allocate a new internal array having a length\n@@ -2994,6 +3028,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  any possibility of overflow.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n          --  determine whether it lies in the range of the index (sub)type.\n@@ -3022,6 +3057,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  Here we can compute Last directly, in the normal way. We know that\n          --  No_Index is less than 0, so there is no danger of overflow when\n          --  adding the (positive) value of Capacity.\n@@ -3060,6 +3096,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  this is a request for expansion or contraction of storage.\n \n       if Container.Elements = null then\n+\n          --  The container is empty (it doesn't even have an internal array),\n          --  so this represents a request to allocate storage having the given\n          --  capacity.\n@@ -3069,17 +3106,19 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Capacity <= N then\n+\n          --  This is a request to trim back storage, but only to the limit of\n          --  what's already in the container. (Reserve_Capacity never deletes\n          --  active elements, it only reclaims excess storage.)\n \n          if N < Container.Elements.EA'Length then\n+\n             --  The container is not empty (because the requested capacity is\n             --  positive, and less than or equal to the container length), and\n-            --  the current length is less than the current capacity, so\n-            --  there's storage available to trim. In this case, we allocate a\n-            --  new internal array having a length that exactly matches the\n-            --  number of items in the container.\n+            --  the current length is less than the current capacity, so there\n+            --  is storage available to trim. In this case, we allocate a new\n+            --  internal array having a length that exactly matches the number\n+            --  of items in the container.\n \n             if Container.Busy > 0 then\n                raise Program_Error with\n@@ -3122,6 +3161,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  current capacity is.\n \n       if Capacity = Container.Elements.EA'Length then\n+\n          --  The requested capacity matches the existing capacity, so there's\n          --  nothing to do here. We treat this case as a no-op, and simply\n          --  return without checking the busy bit.\n@@ -3441,6 +3481,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  create a Last index value greater than Index_Type'Last.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n          --  determine whether it lies in the range of the index (sub)type.\n@@ -3469,6 +3510,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  Here we can compute Last directly, in the normal way. We know that\n          --  No_Index is less than 0, so there is no danger of overflow when\n          --  adding the (positive) value of Length.\n@@ -3529,6 +3571,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  create a Last index value greater than Index_Type'Last.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n          --  determine whether it lies in the range of the index (sub)type.\n@@ -3557,6 +3600,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  Here we can compute Last directly, in the normal way. We know that\n          --  No_Index is less than 0, so there is no danger of overflow when\n          --  adding the (positive) value of Length.\n@@ -3603,6 +3647,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  initialized when the handler executes. So here we initialize our loop\n       --  variable earlier than we prefer, before entering the block, so there\n       --  is no ambiguity.\n+\n       Last := Index_Type'First;\n \n       begin"}, {"sha": "a357cec8e89477a29fda4a7f7a361f3a36aa2c45", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -1022,9 +1022,9 @@ package body Ada.Containers.Vectors is\n \n       --  There are two constraints we need to satisfy. The first constraint is\n       --  that a container cannot have more than Count_Type'Last elements, so\n-      --  we must check the sum of the current length and the insertion\n-      --  count. Note that we cannot simply add these values, because of the\n-      --  possibility of overflow.\n+      --  we must check the sum of the current length and the insertion count.\n+      --  Note: we cannot simply add these values, because of the possibility\n+      --  of overflow.\n \n       if Old_Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"Count is out of range\";\n@@ -1130,7 +1130,6 @@ package body Ada.Containers.Vectors is\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          New_Last := No_Index + Index_Type'Base (New_Length);\n-\n       else\n          New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n       end if;\n@@ -1690,9 +1689,9 @@ package body Ada.Containers.Vectors is\n \n       --  There are two constraints we need to satisfy. The first constraint is\n       --  that a container cannot have more than Count_Type'Last elements, so\n-      --  we must check the sum of the current length and the insertion\n-      --  count. Note that we cannot simply add these values, because of the\n-      --  possibility of overflow.\n+      --  we must check the sum of the current length and the insertion count.\n+      --  Note: we cannot simply add these values, because of the possibility\n+      --  of overflow.\n \n       if Old_Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"Count is out of range\";"}, {"sha": "4c05d7309ec4bb4a07df00ddcdc30a7154e57dcd", "filename": "gcc/ada/a-stwiun-shared.ads", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-stwiun-shared.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-stwiun-shared.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiun-shared.ads?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -410,10 +410,10 @@ private\n \n    type Shared_Wide_String (Max_Length : Natural) is limited record\n       Counter : System.Atomic_Counters.Atomic_Counter;\n-      --  Reference counter.\n+      --  Reference counter\n \n-      Last    : Natural                        := 0;\n-      Data    : Wide_String (1 .. Max_Length);\n+      Last : Natural := 0;\n+      Data : Wide_String (1 .. Max_Length);\n       --  Last is the index of last significant element of the Data. All\n       --  elements with larger indices are just an extra room.\n    end record;\n@@ -424,8 +424,7 @@ private\n    --  Increment reference counter.\n \n    procedure Unreference (Item : not null Shared_Wide_String_Access);\n-   --  Decrement reference counter. Deallocate Item when reference counter is\n-   --  zero.\n+   --  Decrement reference counter. Deallocate Item when ref counter is zero\n \n    function Can_Be_Reused\n      (Item   : Shared_Wide_String_Access;\n@@ -445,30 +444,33 @@ private\n \n    function To_Unbounded (S : Wide_String) return Unbounded_Wide_String\n      renames To_Unbounded_Wide_String;\n-   --  This renames are here only to be used in the pragma Stream_Convert.\n+   --  This renames are here only to be used in the pragma Stream_Convert\n \n    type Unbounded_Wide_String is new AF.Controlled with record\n       Reference : Shared_Wide_String_Access := Empty_Shared_Wide_String'Access;\n    end record;\n \n    --  The Unbounded_Wide_String uses several techniques to increase speed of\n    --  the application:\n+\n    --   - implicit sharing or copy-on-write. Unbounded_Wide_String contains\n    --     only the reference to the data which is shared between several\n    --     instances. The shared data is reallocated only when its value is\n    --     changed and the object mutation can't be used or it is inefficient to\n    --     use it;\n+\n    --   - object mutation. Shared data object can be reused without memory\n    --     reallocation when all of the following requirements are meat:\n    --      - shared data object don't used anywhere longer;\n    --      - its size is sufficient to store new value;\n    --      - the gap after reuse is less then some threshold.\n+\n    --   - memory preallocation. Most of used memory allocation algorithms\n    --     aligns allocated segment on the some boundary, thus some amount of\n    --     additional memory can be preallocated without any impact. Such\n    --     preallocated memory can used later by Append/Insert operations\n    --     without reallocation.\n-   --\n+\n    --  Reference counting uses GCC builtin atomic operations, which allows to\n    --  safely share internal data between Ada tasks. Nevertheless, this not\n    --  make objects of Unbounded_Wide_String thread-safe, so each instance\n@@ -485,7 +487,8 @@ private\n    overriding procedure Finalize   (Object : in out Unbounded_Wide_String);\n \n    Null_Unbounded_Wide_String : constant Unbounded_Wide_String :=\n-                             (AF.Controlled with\n-                                Reference => Empty_Shared_Wide_String'Access);\n+                                  (AF.Controlled with\n+                                     Reference =>\n+                                       Empty_Shared_Wide_String'Access);\n \n end Ada.Strings.Wide_Unbounded;"}, {"sha": "f8d3816a623c9579ac33ee55e5541c0a2135d81a", "filename": "gcc/ada/a-stzunb-shared.ads", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-stzunb-shared.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-stzunb-shared.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzunb-shared.ads?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -419,10 +419,10 @@ private\n \n    type Shared_Wide_Wide_String (Max_Length : Natural) is limited record\n       Counter : System.Atomic_Counters.Atomic_Counter;\n-      --  Reference counter.\n+      --  Reference counter\n \n-      Last    : Natural                        := 0;\n-      Data    : Wide_Wide_String (1 .. Max_Length);\n+      Last : Natural := 0;\n+      Data : Wide_Wide_String (1 .. Max_Length);\n       --  Last is the index of last significant element of the Data. All\n       --  elements with larger indices are just an extra room.\n    end record;\n@@ -466,22 +466,25 @@ private\n \n    --  The Unbounded_Wide_Wide_String uses several techniques to increase speed\n    --  of the application:\n+\n    --   - implicit sharing or copy-on-write. Unbounded_Wide_Wide_String\n    --     contains only the reference to the data which is shared between\n    --     several instances. The shared data is reallocated only when its value\n    --     is changed and the object mutation can't be used or it is inefficient\n    --     to use it;\n+\n    --   - object mutation. Shared data object can be reused without memory\n    --     reallocation when all of the following requirements are meat:\n    --      - shared data object don't used anywhere longer;\n    --      - its size is sufficient to store new value;\n    --      - the gap after reuse is less then some threshold.\n+\n    --   - memory preallocation. Most of used memory allocation algorithms\n    --     aligns allocated segment on the some boundary, thus some amount of\n    --     additional memory can be preallocated without any impact. Such\n    --     preallocated memory can used later by Append/Insert operations\n    --     without reallocation.\n-   --\n+\n    --  Reference counting uses GCC builtin atomic operations, which allows to\n    --  safely share internal data between Ada tasks. Nevertheless, this not\n    --  make objects of Unbounded_Wide_Wide_String thread-safe, so each instance\n@@ -502,8 +505,9 @@ private\n      (Object : in out Unbounded_Wide_Wide_String);\n \n    Null_Unbounded_Wide_Wide_String : constant Unbounded_Wide_Wide_String :=\n-                             (AF.Controlled with\n-                                Reference =>\n-                                  Empty_Shared_Wide_Wide_String'Access);\n+                                       (AF.Controlled with\n+                                          Reference =>\n+                                            Empty_Shared_Wide_Wide_String'\n+                                              Access);\n \n end Ada.Strings.Wide_Wide_Unbounded;"}, {"sha": "abf8677148c55ed599a0e5adbe626998a4f1c097", "filename": "gcc/ada/a-suenco.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-suenco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-suenco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suenco.adb?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2010, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2010-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -92,10 +92,10 @@ package body Ada.Strings.UTF_Encoding.Conversions is\n       --  Output UTF-16 code\n \n       procedure Get_Continuation;\n-      --  Reads a continuation byte of the form 10xxxxxx, shifts R left\n-      --  by 6 bits, and or's in the xxxxxx to the low order 6 bits. On\n-      --  return Ptr is incremented. Raises exception if continuation\n-      --  byte does not exist or is invalid.\n+      --  Reads a continuation byte of the form 10xxxxxx, shifts R left by 6\n+      --  bits, and or's in the xxxxxx to the low order 6 bits. On return Ptr\n+      --  is incremented. Raises exception if continuation byte does not exist\n+      --  or is invalid.\n \n       ----------------------\n       -- Get_Continuation --\n@@ -114,8 +114,8 @@ package body Ada.Strings.UTF_Encoding.Conversions is\n                Raise_Encoding_Error (Iptr - 1);\n \n             else\n-               R := Shift_Left (R, 6) or\n-                 Unsigned_16 (C and 2#00_111111#);\n+               R :=\n+                 Shift_Left (R, 6) or Unsigned_16 (C and 2#00_111111#);\n             end if;\n          end if;\n       end Get_Continuation;"}, {"sha": "3725c5e6391a775e4d379fb79e7ab79feec7d69e", "filename": "gcc/ada/a-suewst.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-suewst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-suewst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suewst.adb?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2010, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2010-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -66,10 +66,10 @@ package body Ada.Strings.UTF_Encoding.Wide_Strings is\n       R : Unsigned_16;\n \n       procedure Get_Continuation;\n-      --  Reads a continuation byte of the form 10xxxxxx, shifts R left\n-      --  by 6 bits, and or's in the xxxxxx to the low order 6 bits. On\n-      --  return Ptr is incremented. Raises exception if continuation\n-      --  byte does not exist or is invalid.\n+      --  Reads a continuation byte of the form 10xxxxxx, shifts R left by 6\n+      --  bits, and or's in the xxxxxx to the low order 6 bits. On return Ptr\n+      --  is incremented. Raises exception if continuation byte does not exist\n+      --  or is invalid.\n \n       ----------------------\n       -- Get_Continuation --"}, {"sha": "4bfd717539920c250d1c3a77727e80d9612de935", "filename": "gcc/ada/a-suezst.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-suezst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fa-suezst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suezst.adb?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2010, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2010-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -66,10 +66,10 @@ package body Ada.Strings.UTF_Encoding.Wide_Wide_Strings is\n       R : Unsigned_32;\n \n       procedure Get_Continuation;\n-      --  Reads a continuation byte of the form 10xxxxxx, shifts R left\n-      --  by 6 bits, and or's in the xxxxxx to the low order 6 bits. On\n-      --  return Ptr is incremented. Raises exception if continuation\n-      --  byte does not exist or is invalid.\n+      --  Reads a continuation byte of the form 10xxxxxx, shifts R left by 6\n+      --  bits, and or's in the xxxxxx to the low order 6 bits. On return Ptr\n+      --  is incremented. Raises exception if continuation byte does not exist\n+      --  or is invalid.\n \n       ----------------------\n       -- Get_Continuation --"}, {"sha": "586d42f8f0a799b14996b2aa21aad5a20667bc5d", "filename": "gcc/ada/s-osinte-aix.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-aix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-aix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-aix.ads?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -199,7 +199,8 @@ package System.OS_Interface is\n \n    type clockid_t is private;\n \n-   CLOCK_REALTIME : constant clockid_t;\n+   CLOCK_REALTIME  : constant clockid_t;\n+   CLOCK_MONOTONIC : constant clockid_t;\n \n    function clock_gettime\n      (clock_id : clockid_t;\n@@ -539,7 +540,8 @@ private\n    pragma Convention (C, timespec);\n \n    type clockid_t is new int;\n-   CLOCK_REALTIME : constant clockid_t := 0;\n+   CLOCK_REALTIME  : constant clockid_t := 9;\n+   CLOCK_MONOTONIC : constant clockid_t := 10;\n \n    type pthread_attr_t is new System.Address;\n    pragma Convention (C, pthread_attr_t);"}, {"sha": "391866c3c4e7eeb1b2072b6185d1d7996e138bdb", "filename": "gcc/ada/s-osinte-darwin.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-darwin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-darwin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-darwin.ads?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -185,7 +185,8 @@ package System.OS_Interface is\n \n    type clockid_t is private;\n \n-   CLOCK_REALTIME : constant clockid_t;\n+   CLOCK_REALTIME  : constant clockid_t;\n+   CLOCK_MONOTONIC : constant clockid_t;\n \n    function clock_gettime\n      (clock_id : clockid_t;\n@@ -516,7 +517,8 @@ private\n    pragma Convention (C, timespec);\n \n    type clockid_t is new int;\n-   CLOCK_REALTIME : constant clockid_t := 0;\n+   CLOCK_REALTIME  : constant clockid_t := 0;\n+   CLOCK_MONOTONIC : constant clockid_t := CLOCK_REALTIME;\n \n    --\n    --  Darwin specific signal implementation"}, {"sha": "5c46c29b983a0f8895170b2314d08f824b97ec74", "filename": "gcc/ada/s-osinte-freebsd.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-freebsd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-freebsd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-freebsd.ads?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -7,7 +7,7 @@\n --                                   S p e c                                --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -202,7 +202,8 @@ package System.OS_Interface is\n \n    type clockid_t is private;\n \n-   CLOCK_REALTIME : constant clockid_t;\n+   CLOCK_REALTIME  : constant clockid_t;\n+   CLOCK_MONOTONIC : constant clockid_t;\n \n    function clock_gettime\n      (clock_id : clockid_t;\n@@ -635,7 +636,8 @@ private\n    pragma Convention (C, timespec);\n \n    type clockid_t is new int;\n-   CLOCK_REALTIME : constant clockid_t := 0;\n+   CLOCK_REALTIME  : constant clockid_t := 0;\n+   CLOCK_MONOTONIC : constant clockid_t := 4;\n \n    type pthread_t           is new System.Address;\n    type pthread_attr_t      is new System.Address;"}, {"sha": "716d821654a02d8b1aba47bdb25ae7b008a82a37", "filename": "gcc/ada/s-osinte-hpux.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-hpux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-hpux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-hpux.ads?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --               Copyright (C) 1991-1994, Florida State University          --\n---            Copyright (C) 1995-2010, Free Software Foundation, Inc.       --\n+--            Copyright (C) 1995-2011, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -182,7 +182,8 @@ package System.OS_Interface is\n \n    type clockid_t is private;\n \n-   CLOCK_REALTIME : constant clockid_t;\n+   CLOCK_REALTIME  : constant clockid_t;\n+   CLOCK_MONOTONIC : constant clockid_t;\n \n    function clock_gettime\n      (clock_id : clockid_t;\n@@ -521,7 +522,8 @@ private\n    pragma Convention (C, timespec);\n \n    type clockid_t is new int;\n-   CLOCK_REALTIME : constant clockid_t := 1;\n+   CLOCK_REALTIME  : constant clockid_t := 1;\n+   CLOCK_MONOTONIC : constant clockid_t := CLOCK_REALTIME;\n \n    type pthread_attr_t is new int;\n    type pthread_condattr_t is new int;"}, {"sha": "8b998bcfdf65a4431fd3b98043951b50febd4dbd", "filename": "gcc/ada/s-osinte-lynxos.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-lynxos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-lynxos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos.ads?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -199,7 +199,8 @@ package System.OS_Interface is\n \n    type clockid_t is private;\n \n-   CLOCK_REALTIME : constant clockid_t;\n+   CLOCK_REALTIME  : constant clockid_t;\n+   CLOCK_MONOTONIC : constant clockid_t;\n \n    function clock_gettime\n      (clock_id : clockid_t;\n@@ -517,7 +518,8 @@ private\n    pragma Convention (C, timespec);\n \n    type clockid_t is new unsigned_char;\n-   CLOCK_REALTIME : constant clockid_t := 0;\n+   CLOCK_REALTIME  : constant clockid_t := 1;\n+   CLOCK_MONOTONIC : constant clockid_t := CLOCK_REALTIME;\n \n    type st_attr_t is record\n       stksize      : int;"}, {"sha": "6c266f9babfb56a56a57b7b3ba415d3d7d18f19d", "filename": "gcc/ada/s-osinte-solaris-posix.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-solaris-posix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-osinte-solaris-posix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-solaris-posix.ads?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -189,7 +189,8 @@ package System.OS_Interface is\n \n    type clockid_t is private;\n \n-   CLOCK_REALTIME : constant clockid_t;\n+   CLOCK_REALTIME  : constant clockid_t;\n+   CLOCK_MONOTONIC : constant clockid_t;\n \n    function clock_gettime\n      (clock_id : clockid_t;\n@@ -512,7 +513,8 @@ private\n    pragma Convention (C, timespec);\n \n    type clockid_t is new int;\n-   CLOCK_REALTIME : constant clockid_t := 0;\n+   CLOCK_REALTIME  : constant clockid_t := 3;\n+   CLOCK_MONOTONIC : constant clockid_t := CLOCK_REALTIME;\n \n    type pthread_attr_t is record\n       pthread_attrp : System.Address;"}, {"sha": "af0a597e5fc36766b953bb7834b466a206f7fafc", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -666,7 +666,7 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n    begin\n       Result := clock_gettime\n-        (clock_id => CLOCK_REALTIME, tp => TS'Unchecked_Access);\n+        (clock_id => CLOCK_MONOTONIC, tp => TS'Unchecked_Access);\n       pragma Assert (Result = 0);\n       return To_Duration (TS);\n    end Monotonic_Clock;"}, {"sha": "c1d8767010d54e1ebf63fc7dbd5936ce44907673", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -268,6 +268,7 @@ package body Sem_Ch6 is\n       Loc      : constant Source_Ptr := Sloc (N);\n       LocX     : constant Source_Ptr := Sloc (Expression (N));\n       Def_Id   : constant Entity_Id  := Defining_Entity (Specification (N));\n+      Expr     : constant Node_Id    := Expression (N);\n       New_Body : Node_Id;\n       New_Decl : Node_Id;\n \n@@ -315,31 +316,28 @@ package body Sem_Ch6 is\n          Set_Is_Inlined (Prev);\n          Analyze (N);\n \n-      --  If this is not a completion, create both a declaration and a body,\n-      --  so that the expression can be inlined whenever possible.\n+      --  If this is not a completion, create both a declaration and a body, so\n+      --  that the expression can be inlined whenever possible. The spec of the\n+      --  new subprogram declaration is a copy of the original specification,\n+      --  which is now part of the subprogram body.\n \n       else\n          New_Decl :=\n            Make_Subprogram_Declaration (Loc,\n-             Specification => Specification (N));\n+             Specification => Copy_Separate_Tree (Specification (N)));\n          Rewrite (N, New_Decl);\n          Analyze (N);\n          Set_Is_Inlined (Defining_Entity (New_Decl));\n \n-         --  Create new set of formals for specification in body.\n-\n-         Set_Specification (New_Body,\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name =>\n-               Make_Defining_Identifier (Loc, Chars (Defining_Entity (N))),\n-             Parameter_Specifications =>\n-               Copy_Parameter_List (Defining_Entity (New_Decl)),\n-             Result_Definition =>\n-               New_Copy_Tree (Result_Definition (Specification (New_Decl)))));\n-\n          Insert_After (N, New_Body);\n          Analyze (New_Body);\n       end if;\n+\n+      --  If the return expression is a static constant, we suppress warning\n+      --  messages on unused formals, which in most cases will be noise.\n+\n+      Set_Is_Trivial_Subprogram (Defining_Entity (New_Body),\n+        Is_OK_Static_Expression (Expr));\n    end Analyze_Expression_Function;\n \n    ----------------------------------------"}, {"sha": "2afae45d910e8c8036286760819dcaf0b2cc9510", "filename": "gcc/ada/tree_io.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Ftree_io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b5b2bbc71dfb621df534b9cc16536eb083046ce/gcc%2Fada%2Ftree_io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_io.ads?ref=0b5b2bbc71dfb621df534b9cc16536eb083046ce", "patch": "@@ -47,12 +47,14 @@ package Tree_IO is\n    Tree_Format_Error : exception;\n    --  Raised if a format error is detected in the input file\n \n-   ASIS_Version_Number : constant := 26;\n+   ASIS_Version_Number : constant := 27;\n    --  ASIS Version. This is used to check for consistency between the compiler\n    --  used to generate trees and an ASIS application that is reading the\n    --  trees. It must be incremented whenever a change is made to the tree\n    --  format that would result in the compiler being incompatible with an\n    --  older version of ASIS.\n+   --\n+   --  27  2011-09-06  Changes in the tree structures for expression functions\n \n    procedure Tree_Read_Initialize (Desc : File_Descriptor);\n    --  Called to initialize reading of a tree file. This call must be made"}]}