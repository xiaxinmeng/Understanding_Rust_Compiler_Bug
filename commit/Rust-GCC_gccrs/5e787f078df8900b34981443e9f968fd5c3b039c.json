{"sha": "5e787f078df8900b34981443e9f968fd5c3b039c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU3ODdmMDc4ZGY4OTAwYjM0OTgxNDQzZTlmOTY4ZmQ1YzNiMDM5Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-19T10:08:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-19T10:08:22Z"}, "message": "loop.c (check_insn_for_bivs, [...]): Break out from ...\n\n\t* loop.c (check_insn_for_bivs, for_every_insn_in_loop,\n\tcheck_insn_for_givs): Break out from ...\n\t(strength_reduce) ... here; use for_every_insn_in_loop to call\n\tcheck_insn_for_givs.\n\t* loop.h (for_every_insn_in_loop): Declare.\n\t(loop_insn_callback): New type.\n\nFrom-SVN: r33250", "tree": {"sha": "364d01592638bbedac4b328c1fdd042e919e7542", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/364d01592638bbedac4b328c1fdd042e919e7542"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e787f078df8900b34981443e9f968fd5c3b039c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e787f078df8900b34981443e9f968fd5c3b039c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e787f078df8900b34981443e9f968fd5c3b039c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e787f078df8900b34981443e9f968fd5c3b039c/comments", "author": null, "committer": null, "parents": [{"sha": "21c076f989c6b8a06440077528944c61d3eccad0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21c076f989c6b8a06440077528944c61d3eccad0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21c076f989c6b8a06440077528944c61d3eccad0"}], "stats": {"total": 604, "additions": 266, "deletions": 338}, "files": [{"sha": "efdf7746069ea3332a235146b35c56ee92f1b132", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e787f078df8900b34981443e9f968fd5c3b039c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e787f078df8900b34981443e9f968fd5c3b039c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e787f078df8900b34981443e9f968fd5c3b039c", "patch": "@@ -1,3 +1,12 @@\n+Wed Apr 19 12:02:37 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* loop.c (check_insn_for_bivs, for_every_insn_in_loop,\n+\tcheck_insn_for_givs): Break out from ...\n+\t(strength_reduce) ... here; use for_every_insn_in_loop to call\n+\tcheck_insn_for_givs.\n+\t* loop.h (for_every_insn_in_loop): Declare.\n+\t(loop_insn_callback): New type.\n+\n 2000-04-18  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpplib.c (do_pragma_poison):  Strings in the token buffer are"}, {"sha": "ac19372ee2a0d3140457e06b3621b42704bf3633", "filename": "gcc/loop.c", "status": "modified", "additions": 255, "deletions": 338, "changes": 593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e787f078df8900b34981443e9f968fd5c3b039c/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e787f078df8900b34981443e9f968fd5c3b039c/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=5e787f078df8900b34981443e9f968fd5c3b039c", "patch": "@@ -308,6 +308,8 @@ static int replace_loop_reg PARAMS ((rtx *, void *));\n static void note_reg_stored PARAMS ((rtx, rtx, void *));\n static void try_copy_prop PARAMS ((const struct loop *, rtx, unsigned int));\n static int replace_label PARAMS ((rtx *, void *));\n+static void check_insn_for_givs PARAMS((struct loop *, rtx, int, int));\n+static void check_insn_for_bivs PARAMS((struct loop *, rtx, int, int));\n \n typedef struct rtx_and_int {\n   rtx r;\n@@ -3694,127 +3696,47 @@ static rtx addr_placeholder;\n    was rerun in loop_optimize whenever a register was added or moved.\n    Also, some of the optimizations could be a little less conservative.  */\n \f\n-/* Perform strength reduction and induction variable elimination.  \n-\n-   Pseudo registers created during this function will be beyond the last\n-   valid index in several tables including n_times_set and regno_last_uid.\n-   This does not cause a problem here, because the added registers cannot be\n-   givs outside of their loop, and hence will never be reconsidered.\n-   But scan_loop must check regnos to make sure they are in bounds.   */\n-\n-static void\n-strength_reduce (loop, insn_count, unroll_p, bct_p)\n+/* Scan the loop body and call FNCALL for each insn.  In the addition to the\n+   LOOP and INSN parameters pass MAYBE_MULTIPLE and NOT_EVERY_ITERATION to the\n+   callback.\n+ \n+   NOT_EVERY_ITERATION if current insn is not executed at least once for every\n+   loop iteration except for the last one.\n+\n+   MAYBE_MULTIPLE is 1 if current insn may be executed more than once for every\n+   loop iteration.\n+ */\n+void\n+for_each_insn_in_loop (loop, fncall)\n      struct loop *loop;\n-     int insn_count;\n-     int unroll_p, bct_p ATTRIBUTE_UNUSED;\n+     loop_insn_callback fncall;\n {\n-  rtx p;\n-  rtx set;\n-  rtx inc_val;\n-  rtx mult_val;\n-  rtx dest_reg;\n-  rtx *location;\n   /* This is 1 if current insn is not executed at least once for every loop\n      iteration.  */\n   int not_every_iteration = 0;\n-  /* This is 1 if current insn may be executed more than once for every\n-     loop iteration.  */\n   int maybe_multiple = 0;\n-  /* This is 1 if we have past a branch back to the top of the loop\n-     (aka a loop latch).  */\n   int past_loop_latch = 0;\n-  /* Temporary list pointers for traversing loop_iv_list.  */\n-  struct iv_class *bl, **backbl;\n-  struct loop_info *loop_info = LOOP_INFO (loop);\n-  /* Ratio of extra register life span we can justify\n-     for saving an instruction.  More if loop doesn't call subroutines\n-     since in that case saving an insn makes more difference\n-     and more registers are available.  */\n-  /* ??? could set this to last value of threshold in move_movables */\n-  int threshold = (loop_info->has_call ? 1 : 2) * (3 + n_non_fixed_regs);\n-  /* Map of pseudo-register replacements.  */\n-  rtx *reg_map = NULL;\n-  int reg_map_size;\n-  int call_seen;\n-  rtx test;\n-  rtx end_insert_before;\n   int loop_depth = 0;\n-  int n_extra_increment;\n-  int unrolled_insn_copies = 0;\n-  rtx loop_start = loop->start;\n-  rtx loop_end = loop->end;\n-  rtx loop_scan_start = loop->scan_start;\n-  rtx loop_top = loop->top;\n-  rtx loop_cont = loop->cont;\n+  rtx p;\n \n   /* If loop_scan_start points to the loop exit test, we have to be wary of\n      subversive use of gotos inside expression statements.  */\n-  if (prev_nonnote_insn (loop_scan_start) != prev_nonnote_insn (loop_start))\n-    maybe_multiple = back_branch_in_range_p (loop, loop_scan_start);\n-\n-  VARRAY_INT_INIT (reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n-  VARRAY_GENERIC_PTR_INIT (reg_iv_info, max_reg_before_loop, \"reg_iv_info\");\n-  reg_biv_class = (struct iv_class **)\n-    xcalloc (max_reg_before_loop, sizeof (struct iv_class *));\n-\n-  loop_iv_list = 0;\n-  addr_placeholder = gen_reg_rtx (Pmode);\n-\n-  /* Save insn immediately after the loop_end.  Insns inserted after loop_end\n-     must be put before this insn, so that they will appear in the right\n-     order (i.e. loop order). \n-\n-     If loop_end is the end of the current function, then emit a \n-     NOTE_INSN_DELETED after loop_end and set end_insert_before to the\n-     dummy note insn.  */\n-  if (NEXT_INSN (loop_end) != 0)\n-    end_insert_before = NEXT_INSN (loop_end);\n-  else\n-    end_insert_before = emit_note_after (NOTE_INSN_DELETED, loop_end);\n+  if (prev_nonnote_insn (loop->scan_start) != prev_nonnote_insn (loop->start))\n+    maybe_multiple = back_branch_in_range_p (loop, loop->scan_start);\n \n   /* Scan through loop to find all possible bivs.  */\n \n-  for (p = next_insn_in_loop (loop, loop_scan_start);\n+  for (p = next_insn_in_loop (loop, loop->scan_start);\n        p != NULL_RTX;\n        p = next_insn_in_loop (loop, p))\n     {\n-      if (GET_CODE (p) == INSN\n-\t  && (set = single_set (p))\n-\t  && GET_CODE (SET_DEST (set)) == REG)\n-\t{\n-\t  dest_reg = SET_DEST (set);\n-\t  if (REGNO (dest_reg) < max_reg_before_loop\n-\t      && REGNO (dest_reg) >= FIRST_PSEUDO_REGISTER\n-\t      && REG_IV_TYPE (REGNO (dest_reg)) != NOT_BASIC_INDUCT)\n-\t    {\n-\t      int multi_insn_incr = 0;\n-\n-\t      if (basic_induction_var (loop, SET_SRC (set),\n-\t\t\t\t       GET_MODE (SET_SRC (set)),\n-\t\t\t\t       dest_reg, p, &inc_val, &mult_val,\n-\t\t\t\t       &location, &multi_insn_incr))\n-\t\t{\n-\t\t  /* It is a possible basic induction variable.\n-\t\t     Create and initialize an induction structure for it.  */\n-\n-\t\t  struct induction *v\n-\t\t    = (struct induction *) alloca (sizeof (struct induction));\n-\n-\t\t  record_biv (v, p, dest_reg, inc_val, mult_val, location,\n-\t\t\t      not_every_iteration, maybe_multiple, \n-\t\t\t      multi_insn_incr);\n-\t\t  REG_IV_TYPE (REGNO (dest_reg)) = BASIC_INDUCT;\n-\t\t}\n-\t      else if (REGNO (dest_reg) < max_reg_before_loop)\n-\t\tREG_IV_TYPE (REGNO (dest_reg)) = NOT_BASIC_INDUCT;\n-\t    }\n-\t}\n+      fncall (loop, p, maybe_multiple, not_every_iteration);\n \n       /* Past CODE_LABEL, we get to insns that may be executed multiple\n-\t times.  The only way we can be sure that they can't is if every\n-\t jump insn between here and the end of the loop either\n-\t returns, exits the loop, is a jump to a location that is still\n-\t behind the label, or is a jump to the loop start.  */\n+         times.  The only way we can be sure that they can't is if every\n+         jump insn between here and the end of the loop either\n+         returns, exits the loop, is a jump to a location that is still\n+         behind the label, or is a jump to the loop start.  */\n \n       if (GET_CODE (p) == CODE_LABEL)\n \t{\n@@ -3825,24 +3747,24 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t  while (1)\n \t    {\n \t      insn = NEXT_INSN (insn);\n-\t      if (insn == loop_scan_start)\n+\t      if (insn == loop->scan_start)\n \t\tbreak;\n-\t      if (insn == loop_end)\n+\t      if (insn == loop->end)\n \t\t{\n-\t\t  if (loop_top != 0)\n-\t\t    insn = loop_top;\n+\t\t  if (loop->top != 0)\n+\t\t    insn = loop->top;\n \t\t  else\n \t\t    break;\n-\t\t  if (insn == loop_scan_start)\n+\t\t  if (insn == loop->scan_start)\n \t\t    break;\n \t\t}\n \n \t      if (GET_CODE (insn) == JUMP_INSN\n \t\t  && GET_CODE (PATTERN (insn)) != RETURN\n-\t\t  && (! condjump_p (insn)\n+\t\t  && (!condjump_p (insn)\n \t\t      || (JUMP_LABEL (insn) != 0\n-\t\t\t  && JUMP_LABEL (insn) != loop_scan_start\n-\t\t\t  && ! loop_insn_first_p (p, JUMP_LABEL (insn)))))\n+\t\t\t  && JUMP_LABEL (insn) != loop->scan_start\n+\t\t\t  && !loop_insn_first_p (p, JUMP_LABEL (insn)))))\n \t\t{\n \t\t  maybe_multiple = 1;\n \t\t  break;\n@@ -3851,29 +3773,29 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t}\n \n       /* Past a jump, we get to insns for which we can't count\n-\t on whether they will be executed during each iteration.  */\n+         on whether they will be executed during each iteration.  */\n       /* This code appears twice in strength_reduce.  There is also similar\n-\t code in scan_loop.  */\n+         code in scan_loop.  */\n       if (GET_CODE (p) == JUMP_INSN\n-\t  /* If we enter the loop in the middle, and scan around to the\n-\t     beginning, don't set not_every_iteration for that.\n-\t     This can be any kind of jump, since we want to know if insns\n-\t     will be executed if the loop is executed.  */\n-\t  && ! (JUMP_LABEL (p) == loop_top\n-\t\t&& ((NEXT_INSN (NEXT_INSN (p)) == loop_end && simplejump_p (p))\n-\t\t    || (NEXT_INSN (p) == loop_end && condjump_p (p)))))\n+      /* If we enter the loop in the middle, and scan around to the\n+         beginning, don't set not_every_iteration for that.\n+         This can be any kind of jump, since we want to know if insns\n+         will be executed if the loop is executed.  */\n+\t  && !(JUMP_LABEL (p) == loop->top\n+\t     && ((NEXT_INSN (NEXT_INSN (p)) == loop->end && simplejump_p (p))\n+\t\t || (NEXT_INSN (p) == loop->end && condjump_p (p)))))\n \t{\n \t  rtx label = 0;\n \n \t  /* If this is a jump outside the loop, then it also doesn't\n \t     matter.  Check to see if the target of this branch is on the\n \t     loop->exits_labels list.  */\n-\t     \n+\n \t  for (label = loop->exit_labels; label; label = LABEL_NEXTREF (label))\n \t    if (XEXP (label, 0) == JUMP_LABEL (p))\n \t      break;\n \n-\t  if (! label)\n+\t  if (!label)\n \t    not_every_iteration = 1;\n \t}\n \n@@ -3896,34 +3818,93 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \t}\n \n       /* Note if we pass a loop latch.  If we do, then we can not clear\n-\t NOT_EVERY_ITERATION below when we pass the last CODE_LABEL in\n-\t a loop since a jump before the last CODE_LABEL may have started\n-\t a new loop iteration.\n-\n-\t Note that LOOP_TOP is only set for rotated loops and we need\n-\t this check for all loops, so compare against the CODE_LABEL\n-\t which immediately follows LOOP_START.  */\n-      if (GET_CODE (p) == JUMP_INSN \n-\t  && JUMP_LABEL (p) == NEXT_INSN (loop_start))\n+         NOT_EVERY_ITERATION below when we pass the last CODE_LABEL in\n+         a loop since a jump before the last CODE_LABEL may have started\n+         a new loop iteration.\n+\n+         Note that LOOP_TOP is only set for rotated loops and we need\n+         this check for all loops, so compare against the CODE_LABEL\n+         which immediately follows LOOP_START.  */\n+      if (GET_CODE (p) == JUMP_INSN\n+\t  && JUMP_LABEL (p) == NEXT_INSN (loop->start))\n \tpast_loop_latch = 1;\n \n       /* Unlike in the code motion pass where MAYBE_NEVER indicates that\n-\t an insn may never be executed, NOT_EVERY_ITERATION indicates whether\n-\t or not an insn is known to be executed each iteration of the\n-\t loop, whether or not any iterations are known to occur.\n+         an insn may never be executed, NOT_EVERY_ITERATION indicates whether\n+         or not an insn is known to be executed each iteration of the\n+         loop, whether or not any iterations are known to occur.\n \n-\t Therefore, if we have just passed a label and have no more labels\n-\t between here and the test insn of the loop, and we have not passed\n-\t a jump to the top of the loop, then we know these insns will be\n-\t executed each iteration.  */\n+         Therefore, if we have just passed a label and have no more labels\n+         between here and the test insn of the loop, and we have not passed\n+         a jump to the top of the loop, then we know these insns will be\n+         executed each iteration.  */\n \n-      if (not_every_iteration \n-\t  && ! past_loop_latch\n+      if (not_every_iteration\n+\t  && !past_loop_latch\n \t  && GET_CODE (p) == CODE_LABEL\n-\t  && no_labels_between_p (p, loop_end)\n-\t  && loop_insn_first_p (p, loop_cont))\n+\t  && no_labels_between_p (p, loop->end)\n+\t  && loop_insn_first_p (p, loop->cont))\n \tnot_every_iteration = 0;\n     }\n+}\n+\f\n+/* Perform strength reduction and induction variable elimination.  \n+\n+   Pseudo registers created during this function will be beyond the last\n+   valid index in several tables including n_times_set and regno_last_uid.\n+   This does not cause a problem here, because the added registers cannot be\n+   givs outside of their loop, and hence will never be reconsidered.\n+   But scan_loop must check regnos to make sure they are in bounds.   */\n+\n+static void\n+strength_reduce (loop, insn_count, unroll_p, bct_p)\n+     struct loop *loop;\n+     int insn_count;\n+     int unroll_p, bct_p ATTRIBUTE_UNUSED;\n+{\n+  rtx p;\n+  /* Temporary list pointers for traversing loop_iv_list.  */\n+  struct iv_class *bl, **backbl;\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n+  /* Ratio of extra register life span we can justify\n+     for saving an instruction.  More if loop doesn't call subroutines\n+     since in that case saving an insn makes more difference\n+     and more registers are available.  */\n+  /* ??? could set this to last value of threshold in move_movables */\n+  int threshold = (loop_info->has_call ? 1 : 2) * (3 + n_non_fixed_regs);\n+  /* Map of pseudo-register replacements.  */\n+  rtx *reg_map = NULL;\n+  int reg_map_size;\n+  int call_seen;\n+  rtx test;\n+  rtx end_insert_before;\n+  int n_extra_increment;\n+  int unrolled_insn_copies = 0;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n+  rtx loop_scan_start = loop->scan_start;\n+\n+  VARRAY_INT_INIT (reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n+  VARRAY_GENERIC_PTR_INIT (reg_iv_info, max_reg_before_loop, \"reg_iv_info\");\n+  reg_biv_class = (struct iv_class **)\n+    xcalloc (max_reg_before_loop, sizeof (struct iv_class *));\n+\n+  loop_iv_list = 0;\n+  addr_placeholder = gen_reg_rtx (Pmode);\n+\n+  /* Save insn immediately after the loop_end.  Insns inserted after loop_end\n+     must be put before this insn, so that they will appear in the right\n+     order (i.e. loop order). \n+\n+     If loop_end is the end of the current function, then emit a \n+     NOTE_INSN_DELETED after loop_end and set end_insert_before to the\n+     dummy note insn.  */\n+  if (NEXT_INSN (loop_end) != 0)\n+    end_insert_before = NEXT_INSN (loop_end);\n+  else\n+    end_insert_before = emit_note_after (NOTE_INSN_DELETED, loop_end);\n+\n+  for_each_insn_in_loop (loop, check_insn_for_bivs);\n \n   /* Scan loop_iv_list to remove all regs that proved not to be bivs.\n      Make a sanity check against n_times_set.  */\n@@ -4430,203 +4411,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n \n   /* Search the loop for general induction variables.  */\n \n-  /* A register is a giv if: it is only set once, it is a function of a\n-     biv and a constant (or invariant), and it is not a biv.  */\n-\n-  not_every_iteration = 0;\n-  loop_depth = 0;\n-  maybe_multiple = 0;\n-  p = loop_scan_start;\n-  while (1)\n-    {\n-      p = NEXT_INSN (p);\n-      /* At end of a straight-in loop, we are done.\n-\t At end of a loop entered at the bottom, scan the top.  */\n-      if (p == loop_scan_start)\n-\tbreak;\n-      if (p == loop_end)\n-\t{\n-\t  if (loop_top != 0)\n-\t    p = loop_top;\n-\t  else\n-\t    break;\n-\t  if (p == loop_scan_start)\n-\t    break;\n-\t}\n-\n-      /* Look for a general induction variable in a register.  */\n-      if (GET_CODE (p) == INSN\n-\t  && (set = single_set (p))\n-\t  && GET_CODE (SET_DEST (set)) == REG\n-\t  && ! VARRAY_CHAR (may_not_optimize, REGNO (SET_DEST (set))))\n-\t{\n-\t  rtx src_reg;\n-\t  rtx add_val;\n-\t  rtx mult_val;\n-\t  int benefit;\n-\t  rtx regnote = 0;\n-\t  rtx last_consec_insn;\n-\n-\t  dest_reg = SET_DEST (set);\n-\t  if (REGNO (dest_reg) < FIRST_PSEUDO_REGISTER)\n-\t    continue;\n-\n-\t  if (/* SET_SRC is a giv.  */\n-\t      (general_induction_var (loop, SET_SRC (set), &src_reg, &add_val,\n-\t\t\t\t      &mult_val, 0, &benefit)\n-\t       /* Equivalent expression is a giv.  */\n-\t       || ((regnote = find_reg_note (p, REG_EQUAL, NULL_RTX))\n-\t\t   && general_induction_var (loop, XEXP (regnote, 0), &src_reg,\n-\t\t\t\t\t     &add_val, &mult_val, 0,\n-\t\t\t\t\t     &benefit)))\n-\t      /* Don't try to handle any regs made by loop optimization.\n-\t\t We have nothing on them in regno_first_uid, etc.  */\n-\t      && REGNO (dest_reg) < max_reg_before_loop\n-\t      /* Don't recognize a BASIC_INDUCT_VAR here.  */\n-\t      && dest_reg != src_reg\n-\t      /* This must be the only place where the register is set.  */\n-\t      && (VARRAY_INT (n_times_set, REGNO (dest_reg)) == 1\n-\t\t  /* or all sets must be consecutive and make a giv.  */\n-\t\t  || (benefit = consec_sets_giv (loop, benefit, p,\n-\t\t\t\t\t\t src_reg, dest_reg,\n-\t\t\t\t\t\t &add_val, &mult_val,\n-\t\t\t\t\t\t &last_consec_insn))))\n-\t    {\n-\t      struct induction *v\n-\t\t= (struct induction *) alloca (sizeof (struct induction));\n-\n-\t      /* If this is a library call, increase benefit.  */\n-\t      if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n-\t\tbenefit += libcall_benefit (p);\n-\n-\t      /* Skip the consecutive insns, if there are any.  */\n-\t      if (VARRAY_INT (n_times_set, REGNO (dest_reg)) != 1)\n-\t\tp = last_consec_insn;\n-\n-\t      record_giv (loop, v, p, src_reg, dest_reg, mult_val, add_val,\n-\t\t\t  benefit, DEST_REG, not_every_iteration,\n-\t\t\t  maybe_multiple, NULL_PTR);\n-\n-\t    }\n-\t}\n-\n-#ifndef DONT_REDUCE_ADDR\n-      /* Look for givs which are memory addresses.  */\n-      /* This resulted in worse code on a VAX 8600.  I wonder if it\n-\t still does.  */\n-      if (GET_CODE (p) == INSN)\n-\tfind_mem_givs (loop, PATTERN (p), p, not_every_iteration,\n-\t\t       maybe_multiple);\n-#endif\n-\n-      /* Update the status of whether giv can derive other givs.  This can\n-\t change when we pass a label or an insn that updates a biv.  */\n-      if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n-\t|| GET_CODE (p) == CODE_LABEL)\n-\tupdate_giv_derive (loop, p);\n-\n-      /* Past CODE_LABEL, we get to insns that may be executed multiple\n-\t times.  The only way we can be sure that they can't is if every\n-\t every jump insn between here and the end of the loop either\n-\t returns, exits the loop, is a forward jump, or is a jump\n-\t to the loop start.  */\n-\n-      if (GET_CODE (p) == CODE_LABEL)\n-\t{\n-\t  rtx insn = p;\n-\n-\t  maybe_multiple = 0;\n-\n-\t  while (1)\n-\t    {\n-\t      insn = NEXT_INSN (insn);\n-\t      if (insn == loop_scan_start)\n-\t\tbreak;\n-\t      if (insn == loop_end)\n-\t\t{\n-\t\t  if (loop_top != 0)\n-\t\t    insn = loop_top;\n-\t\t  else\n-\t\t    break;\n-\t\t  if (insn == loop_scan_start)\n-\t\t    break;\n-\t\t}\n-\n-\t      if (GET_CODE (insn) == JUMP_INSN\n-\t\t  && GET_CODE (PATTERN (insn)) != RETURN\n-\t\t  && (! condjump_p (insn)\n-\t\t      || (JUMP_LABEL (insn) != 0\n-\t\t\t  && JUMP_LABEL (insn) != loop_scan_start\n-\t\t\t  && (INSN_UID (JUMP_LABEL (insn)) >= max_uid_for_loop\n-\t\t\t      || INSN_UID (insn) >= max_uid_for_loop\n-\t\t\t      || (INSN_LUID (JUMP_LABEL (insn))\n-\t\t\t\t  < INSN_LUID (insn))))))\n-\t\t{\n-\t\t  maybe_multiple = 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Past a jump, we get to insns for which we can't count\n-\t on whether they will be executed during each iteration.  */\n-      /* This code appears twice in strength_reduce.  There is also similar\n-\t code in scan_loop.  */\n-      if (GET_CODE (p) == JUMP_INSN\n-\t  /* If we enter the loop in the middle, and scan around to the\n-\t     beginning, don't set not_every_iteration for that.\n-\t     This can be any kind of jump, since we want to know if insns\n-\t     will be executed if the loop is executed.  */\n-\t  && ! (JUMP_LABEL (p) == loop_top\n-\t\t&& ((NEXT_INSN (NEXT_INSN (p)) == loop_end && simplejump_p (p))\n-\t\t    || (NEXT_INSN (p) == loop_end && condjump_p (p)))))\n-\t{\n-\t  rtx label = 0;\n-\n-\t  /* If this is a jump outside the loop, then it also doesn't\n-\t     matter.  Check to see if the target of this branch is on the\n-\t     loop->exits_labels list.  */\n-\t     \n-\t  for (label = loop->exit_labels; label; label = LABEL_NEXTREF (label))\n-\t    if (XEXP (label, 0) == JUMP_LABEL (p))\n-\t      break;\n-\n-\t  if (! label)\n-\t    not_every_iteration = 1;\n-\t}\n-\n-      else if (GET_CODE (p) == NOTE)\n-\t{\n-\t  /* At the virtual top of a converted loop, insns are again known to\n-\t     be executed each iteration: logically, the loop begins here\n-\t     even though the exit code has been duplicated.\n-\n-\t     Insns are also again known to be executed each iteration at\n-\t     the LOOP_CONT note.  */\n-\t  if ((NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_VTOP\n-\t       || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_CONT)\n-\t      && loop_depth == 0)\n-\t    not_every_iteration = 0;\n-\t  else if (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG)\n-\t    loop_depth++;\n-\t  else if (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)\n-\t    loop_depth--;\n-\t}\n-\n-      /* Unlike in the code motion pass where MAYBE_NEVER indicates that\n-\t an insn may never be executed, NOT_EVERY_ITERATION indicates whether\n-\t or not an insn is known to be executed each iteration of the\n-\t loop, whether or not any iterations are known to occur.\n-\n-\t Therefore, if we have just passed a label and have no more labels\n-\t between here and the test insn of the loop, we know these insns\n-\t will be executed each iteration.  */\n-\n-      if (not_every_iteration && GET_CODE (p) == CODE_LABEL\n-\t  && no_labels_between_p (p, loop_end)\n-\t  && loop_insn_first_p (p, loop_cont))\n-\tnot_every_iteration = 0;\n-    }\n+  for_each_insn_in_loop (loop, check_insn_for_givs);\n \n   /* Try to calculate and save the number of loop iterations.  This is\n      set to zero if the actual number can not be calculated.  This must\n@@ -5282,6 +5067,138 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n     free (reg_map);\n }\n \f\n+/*Record all basic induction variables calculated in the insn.  */\n+static void\n+check_insn_for_bivs (loop, p, not_every_iteration, maybe_multiple)\n+     struct loop *loop;\n+     rtx p;\n+     int not_every_iteration;\n+     int maybe_multiple;\n+{\n+  rtx set;\n+  rtx dest_reg;\n+  rtx inc_val;\n+  rtx mult_val;\n+  rtx *location;\n+\n+  if (GET_CODE (p) == INSN\n+      && (set = single_set (p))\n+      && GET_CODE (SET_DEST (set)) == REG)\n+    {\n+      dest_reg = SET_DEST (set);\n+      if (REGNO (dest_reg) < max_reg_before_loop\n+\t  && REGNO (dest_reg) >= FIRST_PSEUDO_REGISTER\n+\t  && REG_IV_TYPE (REGNO (dest_reg)) != NOT_BASIC_INDUCT)\n+\t{\n+\t  int multi_insn_incr = 0;\n+\n+\t  if (basic_induction_var (loop, SET_SRC (set),\n+\t\t\t\t   GET_MODE (SET_SRC (set)),\n+\t\t\t\t   dest_reg, p, &inc_val, &mult_val,\n+\t\t\t\t   &location, &multi_insn_incr))\n+\t    {\n+\t      /* It is a possible basic induction variable.\n+\t         Create and initialize an induction structure for it.  */\n+\n+\t      struct induction *v\n+\t      = (struct induction *) oballoc (sizeof (struct induction));\n+\n+\t      record_biv (v, p, dest_reg, inc_val, mult_val, location,\n+\t\t\t  not_every_iteration, maybe_multiple,\n+\t\t\t  multi_insn_incr);\n+\t      REG_IV_TYPE (REGNO (dest_reg)) = BASIC_INDUCT;\n+\t    }\n+\t  else if (REGNO (dest_reg) < max_reg_before_loop)\n+\t    REG_IV_TYPE (REGNO (dest_reg)) = NOT_BASIC_INDUCT;\n+\t}\n+    }\n+}\n+\f\n+/* Record all givs calculated in the insn.  \n+   A register is a giv if: it is only set once, it is a function of a\n+   biv and a constant (or invariant), and it is not a biv.  */\n+static void\n+check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n+     struct loop *loop;\n+     rtx p;\n+     int not_every_iteration;\n+     int maybe_multiple;\n+{\n+  rtx set;\n+  /* Look for a general induction variable in a register.  */\n+  if (GET_CODE (p) == INSN\n+      && (set = single_set (p))\n+      && GET_CODE (SET_DEST (set)) == REG\n+      && ! VARRAY_CHAR (may_not_optimize, REGNO (SET_DEST (set))))\n+    {\n+      rtx src_reg;\n+      rtx dest_reg;\n+      rtx add_val;\n+      rtx mult_val;\n+      int benefit;\n+      rtx regnote = 0;\n+      rtx last_consec_insn;\n+\n+      dest_reg = SET_DEST (set);\n+      if (REGNO (dest_reg) < FIRST_PSEUDO_REGISTER)\n+\treturn;\n+\n+      if (/* SET_SRC is a giv.  */\n+\t  (general_induction_var (loop, SET_SRC (set), &src_reg, &add_val,\n+\t\t\t\t  &mult_val, 0, &benefit)\n+\t   /* Equivalent expression is a giv.  */\n+\t   || ((regnote = find_reg_note (p, REG_EQUAL, NULL_RTX))\n+\t       && general_induction_var (loop, XEXP (regnote, 0), &src_reg,\n+\t\t\t\t\t &add_val, &mult_val, 0,\n+\t\t\t\t\t &benefit)))\n+\t  /* Don't try to handle any regs made by loop optimization.\n+\t     We have nothing on them in regno_first_uid, etc.  */\n+\t  && REGNO (dest_reg) < max_reg_before_loop\n+\t  /* Don't recognize a BASIC_INDUCT_VAR here.  */\n+\t  && dest_reg != src_reg\n+\t  /* This must be the only place where the register is set.  */\n+\t  && (VARRAY_INT (n_times_set, REGNO (dest_reg)) == 1\n+\t      /* or all sets must be consecutive and make a giv.  */\n+\t      || (benefit = consec_sets_giv (loop, benefit, p,\n+\t\t\t\t\t     src_reg, dest_reg,\n+\t\t\t\t\t     &add_val, &mult_val,\n+\t\t\t\t\t     &last_consec_insn))))\n+\t{\n+\t  struct induction *v\n+\t    = (struct induction *) oballoc (sizeof (struct induction));\n+\n+\t  /* If this is a library call, increase benefit.  */\n+\t  if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n+\t    benefit += libcall_benefit (p);\n+\n+\t  /* Skip the consecutive insns, if there are any.  */\n+\t  if (VARRAY_INT (n_times_set, REGNO (dest_reg)) != 1)\n+\t    p = last_consec_insn;\n+\n+\t  record_giv (loop, v, p, src_reg, dest_reg, mult_val, add_val,\n+\t\t      benefit, DEST_REG, not_every_iteration,\n+\t\t      maybe_multiple, NULL_PTR);\n+\n+\t}\n+    }\n+\n+#ifndef DONT_REDUCE_ADDR\n+  /* Look for givs which are memory addresses.  */\n+  /* This resulted in worse code on a VAX 8600.  I wonder if it\n+     still does.  */\n+  if (GET_CODE (p) == INSN)\n+    find_mem_givs (loop, PATTERN (p), p, not_every_iteration,\n+\t\t   maybe_multiple);\n+#endif\n+\n+  /* Update the status of whether giv can derive other givs.  This can\n+     change when we pass a label or an insn that updates a biv.  */\n+  if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n+    || GET_CODE (p) == CODE_LABEL)\n+    update_giv_derive (loop, p);\n+\n+}\n+\f\n /* Return 1 if X is a valid source for an initial value (or as value being\n    compared against in an initial test).\n "}, {"sha": "390c1ce4b7c355a9aef74cd4a62b30d42b01d255", "filename": "gcc/loop.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e787f078df8900b34981443e9f968fd5c3b039c/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e787f078df8900b34981443e9f968fd5c3b039c/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=5e787f078df8900b34981443e9f968fd5c3b039c", "patch": "@@ -247,4 +247,6 @@ void emit_unrolled_add PARAMS ((rtx, rtx, rtx));\n int back_branch_in_range_p PARAMS ((const struct loop *, rtx));\n \n int loop_insn_first_p PARAMS ((rtx, rtx));\n+typedef void (*loop_insn_callback ) PARAMS ((struct loop *, rtx, int, int));\n+void for_each_insn_in_loop PARAMS ((struct loop *, loop_insn_callback));\n "}]}