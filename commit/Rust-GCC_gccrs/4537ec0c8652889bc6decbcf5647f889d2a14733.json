{"sha": "4537ec0c8652889bc6decbcf5647f889d2a14733", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUzN2VjMGM4NjUyODg5YmM2ZGVjYmNmNTY0N2Y4ODlkMmExNDczMw==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2009-09-03T04:07:12Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2009-09-03T04:07:12Z"}, "message": "[multiple changes]\n\n2009-09-01  Diego Novillo  <dnovillo@google.com>\n\n\t* c-lang.c (lang_hooks): Remove const qualifier.\n\njava/ChangeLog\n\n\t* lang.c (lang_hooks): Remove const qualifier.\n\nobjc/ChangeLog\n\n\t* objc-lang.c (lang_hooks): Remove const qualifier.\n\nobjcp/ChangeLog\n\n\t* objcp-lang.c (lang_hooks): Remove const qualifier.\n\nada/ChangeLog\n\n\t* gcc-interface/misc.c (lang_hooks): Remove const qualifier.\n\nfortran/ChangeLog\n\n\t* f95-lang.c (lang_hooks): Remove const qualifier.\n\ncp/ChangeLog\n\n\t* cp-lang.c (lang_hooks): Remove const qualifier.\n\n2009-09-01  Diego Novillo  <dnovillo@google.com>\n\n\t* cgraph.c (cgraph_node_for_decl): New.\n\t* cgraph.h (cgraph_node_for_decl): Declare.\n\t* tree.c (host_integerp): Return 0 if T is NULL.\n\n\n2009-09-01  Diego Novillo  <dnovillo@google.com>\n\n\t* tree.h (struct alias_pair): Move from varasm.c.\n\t(alias_pairs): Likewise.\n\t(TYPE_MAXVAL): Define.\n\t(TYPE_MINVAL): Define.\n\t(iterative_hash_host_wide_int): Declare.\n\t(remove_unreachable_alias_pairs): Declare.\n\t* tree-pass.h (pass_ipa_free_lang_data): Declare.\n\t* diagnostic.c (default_diagnostic_starter): Make extern.\n\t(default_diagnostic_finalizer): Make extern.\n\t* diagnostic.h (default_diagnostic_starter): Declare.\n\t(default_diagnostic_finalizer): Declare.\n\t(default_tree_printer): Declare.\n\t* toplev.c (default_tree_printer): Make extern.\n\n\n2009-09-01  Richard Guenther  <rguenther@suse.de>\n\t    Diego Novillo  <dnovillo@google.com>\n\n\t* cgraph.c (cgraph_add_new_function): Remove gimplification.\n\t* cgraphunit.c (cgraph_expand_function): Do not emit\n\tassociated thunks from here.\n\t(cgraph_emit_thunks): New.\n\t(cgraph_optimize): Call it.\n\tReturn if any IPA pass finds an error.\n\t* varasm.c (finish_aliases_1): Ignore errorneous aliases used\n\tby thunks.\n\n\n2009-09-01  Simon Baldwin  <simonb@google.com>\n\t    Rafael Espindola  <espindola@google.com>\n\t    Richard Guenther  <rguenther@suse.de>\n\t    Doug Kwan  <dougkwan@google.com>\n\t    Diego Novillo  <dnovillo@google.com>\n\n\t* tree.c: Include tree-pass.h, langhooks-def.h,\n\tdiagnostic.h, cgraph.h, timevar.h, except.h and debug.h.\n\t(free_lang_data_in_type): New.\n\t(need_assembler_name_p): New.\n\t(free_lang_data_in_block): New.\n\t(free_lang_data_in_decl): New.\n\t(struct free_lang_data_d): New.\n\t(add_tree_to_fld_list): New.\n\t(find_decls_types_r): New.\n\t(get_eh_types_for_runtime): New.\n\t(find_decls_types_in_eh_region): New.\n\t(find_decls_types_in_node): New.\n\t(find_decls_types_in_var): New.\n\t(free_lang_data_in_cgraph): New.\n\t(free_lang_data): New.\n\t(gate_free_lang_data): New.\n\t(pass_ipa_free_lang_data): New.\n\n2009-09-01  Diego Novillo  <dnovillo@google.com>\n\n\t* timevar.def (TV_IPA_FREE_LANG_DATA): Define.\n\t* langhooks.h (struct lang_hooks): Add field free_lang_data.\n\t(lang_hooks): Remove const qualifier.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Call\n\tremove_unreachable_alias_pairs.\n\t* except.c (add_type_for_runtime): Check if TYPE has\n\talready been converted.\n\t(lookup_type_for_runtime): Likewise.\n\t(check_handled): Handle converted types.\n\t* varasm.c (remove_unreachable_alias_pairs): New.\n\t* gimple.c: Include demangle.h.\n\t(gimple_decl_printable_name): New.\n\t(gimple_fold_obj_type_ref): New.\n\t* gimple.h (gimple_decl_printable_name): Declare.\n\t(gimple_fold_obj_type_ref): Declare.\n\t* passes.c (init_optimization_passes): Add pass\n\tpass_ipa_free_lang_data.\n\t* langhooks-def.h (LANG_HOOKS_FREE_LANG_DATA): Define.\n\t(LANG_HOOKS_INITIALIZER): Add LANG_HOOKS_FREE_LANG_DATA.\n\ntestsuite/ChangeLog\n\n2009-09-01  Diego Novillo  <dnovillo@google.com>\n\n\t* gcc.dg/gomp/combined-1.c: Adjust expected pattern.\n\t* g++.dg/tree-prof/inline_mismatch_args.C: Likewise.\n\t* g++.dg/warn/unit-1.C: Likewise.\n\t* g++.dg/ipa/iinline-1.C: Likewise.\n\t* g++.dg/template/cond2.C: Adjust expected line location for the\n\terror.\n\t* g++.dg/template/pr35240.C: Likewise.\n\n\ncp/ChangeLog\n\n2009-09-01  Doug Kwan  <dougkwan@google.com>\n\n\t* tree.c (cp_fix_function_decl_p): New.\n\t(cp_free_lang_data): New.\n\n2009-09-01  Diego Novillo  <dnovillo@google.com>\n\n\t* Make-lang.in (decl2.o): Add dependency on $(POINTER_SET_H).\n\t* decl2.c: Include pointer-set.h.\n\t(collect_candidates_for_java_method_aliases): New.\n\t(cp_write_global_declarations): Call it.\n\tAdd local variable CANDIDATES.  If set, call\n\tbuild_java_method_aliases.\n\t(build_java_method_aliases): Add argument CANDIDATES.\n\tUse it to determine if FNDECL should get a hidden alias.\n\t* cp-objcp-common.h (LANG_HOOKS_FREE_LANG_DATA): Define.\n\t* cp-tree.h (cp_free_lang_data): Declare.\n\n2009-09-03  Richard Guenther  <rguenther@suse.de>\n\n\t* method.c (use_thunk): Use cgraph_finalize_function to hand\n\toff thunks to the cgraph.\n\t* semantics.c (emit_associated_thunks): Do not emit thunks\n\tfor really extern functions.\n\nFrom-SVN: r151360", "tree": {"sha": "1a56a7d77636c5b967ccca276324809f1b6251a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a56a7d77636c5b967ccca276324809f1b6251a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4537ec0c8652889bc6decbcf5647f889d2a14733", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4537ec0c8652889bc6decbcf5647f889d2a14733", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4537ec0c8652889bc6decbcf5647f889d2a14733", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4537ec0c8652889bc6decbcf5647f889d2a14733/comments", "author": null, "committer": null, "parents": [{"sha": "e25ea117b5a436eac4112d495a413b906f6bca8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25ea117b5a436eac4112d495a413b906f6bca8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e25ea117b5a436eac4112d495a413b906f6bca8f"}], "stats": {"total": 1381, "additions": 1319, "deletions": 62}, "files": [{"sha": "b0abc837876b084fb688b6d669f4c70c79e6dea5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -1,3 +1,87 @@\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* cgraph.c (cgraph_node_for_decl): New.\n+\t* cgraph.h (cgraph_node_for_decl): Declare.\n+\t* tree.c (host_integerp): Return 0 if T is NULL.\n+\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* tree.h (struct alias_pair): Move from varasm.c.\n+\t(alias_pairs): Likewise.\n+\t(TYPE_MAXVAL): Define.\n+\t(TYPE_MINVAL): Define.\n+\t(iterative_hash_host_wide_int): Declare.\n+\t(remove_unreachable_alias_pairs): Declare.\n+\t* tree-pass.h (pass_ipa_free_lang_data): Declare.\n+\t* diagnostic.c (default_diagnostic_starter): Make extern.\n+\t(default_diagnostic_finalizer): Make extern.\n+\t* diagnostic.h (default_diagnostic_starter): Declare.\n+\t(default_diagnostic_finalizer): Declare.\n+\t(default_tree_printer): Declare.\n+\t* toplev.c (default_tree_printer): Make extern.\n+\n+2009-09-03  Richard Guenther  <rguenther@suse.de>\n+\t    Diego Novillo  <dnovillo@google.com>\n+\n+\t* cgraph.c (cgraph_add_new_function): Remove gimplification.\n+\t* cgraphunit.c (cgraph_expand_function): Do not emit\n+\tassociated thunks from here.\n+\t(cgraph_emit_thunks): New.\n+\t(cgraph_optimize): Call it.\n+\tReturn if any IPA pass finds an error.\n+\t* varasm.c (finish_aliases_1): Ignore errorneous aliases used\n+\tby thunks.\n+\n+2009-09-03  Simon Baldwin  <simonb@google.com>\n+\t    Rafael Espindola  <espindola@google.com>\n+\t    Richard Guenther  <rguenther@suse.de>\n+\t    Doug Kwan  <dougkwan@google.com>\n+\t    Diego Novillo  <dnovillo@google.com>\n+\n+\t* tree.c: Include tree-pass.h, langhooks-def.h,\n+\tdiagnostic.h, cgraph.h, timevar.h, except.h and debug.h.\n+\t(free_lang_data_in_type): New.\n+\t(need_assembler_name_p): New.\n+\t(free_lang_data_in_block): New.\n+\t(free_lang_data_in_decl): New.\n+\t(struct free_lang_data_d): New.\n+\t(add_tree_to_fld_list): New.\n+\t(find_decls_types_r): New.\n+\t(get_eh_types_for_runtime): New.\n+\t(find_decls_types_in_eh_region): New.\n+\t(find_decls_types_in_node): New.\n+\t(find_decls_types_in_var): New.\n+\t(free_lang_data_in_cgraph): New.\n+\t(free_lang_data): New.\n+\t(gate_free_lang_data): New.\n+\t(pass_ipa_free_lang_data): New.\n+\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* timevar.def (TV_IPA_FREE_LANG_DATA): Define.\n+\t* langhooks.h (struct lang_hooks): Add field free_lang_data.\n+\t(lang_hooks): Remove const qualifier.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Call\n+\tremove_unreachable_alias_pairs.\n+\t* except.c (add_type_for_runtime): Check if TYPE has\n+\talready been converted.\n+\t(lookup_type_for_runtime): Likewise.\n+\t(check_handled): Handle converted types.\n+\t* varasm.c (remove_unreachable_alias_pairs): New.\n+\t* gimple.c: Include demangle.h.\n+\t(gimple_decl_printable_name): New.\n+\t(gimple_fold_obj_type_ref): New.\n+\t* gimple.h (gimple_decl_printable_name): Declare.\n+\t(gimple_fold_obj_type_ref): Declare.\n+\t* passes.c (init_optimization_passes): Add pass\n+\tpass_ipa_free_lang_data.\n+\t* langhooks-def.h (LANG_HOOKS_FREE_LANG_DATA): Define.\n+\t(LANG_HOOKS_INITIALIZER): Add LANG_HOOKS_FREE_LANG_DATA.\n+\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* c-lang.c (lang_hooks): Remove const qualifier.\n+\n 2009-09-02  Loren James Rittle  <ljrittle@acm.org>\n \n \t* doc/install.texi (*-*-freebsd*): Update target information."}, {"sha": "526ec70de03a72c9cc3c8c46ec00cd28cb81da55", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -2164,7 +2164,8 @@ tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    all-tree.def $(FLAGS_H) $(FUNCTION_H) $(PARAMS_H) \\\n    $(TOPLEV_H) $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \\\n    $(REAL_H) gt-tree.h $(TREE_INLINE_H) tree-iterator.h $(BASIC_BLOCK_H) \\\n-   $(TREE_FLOW_H) $(OBSTACK_H) pointer-set.h fixed-value.h\n+   $(TREE_FLOW_H) $(OBSTACK_H) pointer-set.h fixed-value.h tree-pass.h \\\n+   langhooks-def.h $(DIAGNOSTIC_H) $(CGRAPH_H) $(TIMEVAR_H) except.h debug.h\n tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TOPLEV_H) $(SPLAY_TREE_H) $(TREE_DUMP_H) \\\n    tree-iterator.h $(TREE_PASS_H) $(DIAGNOSTIC_H) $(REAL_H) fixed-value.h"}, {"sha": "9b92ce5f4df2f15319c57213a120c4d9773bb766", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -1,3 +1,7 @@\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* gcc-interface/misc.c (lang_hooks): Remove const qualifier.\n+\n 2009-09-02  Richard Henderson  <rth@redhat.com>\n \n \t* tb-gcc.c (__gnat_backtrace): Mark all arguments unused."}, {"sha": "f39a60eb4cc62eab7aa54dde57996f6afdbdca1b", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -131,7 +131,7 @@ static void gnat_get_subrange_bounds\t(const_tree, tree *, tree *);\n #undef  LANG_HOOKS_BUILTIN_FUNCTION\n #define LANG_HOOKS_BUILTIN_FUNCTION        gnat_builtin_function\n \n-const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n /* How much we want of our DWARF extensions.  Some of our dwarf+ extensions\n    are incompatible with regular GDB versions, so we must make sure to only"}, {"sha": "7e0236d3c2ee21135bf74d8750a11d8a2cee9d9c", "filename": "gcc/c-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -46,7 +46,7 @@ enum c_language_kind c_language = clk_c;\n #define LANG_HOOKS_INIT c_objc_common_init\n \n /* Each front end provides its own lang hook initializer.  */\n-const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n /* Final processing of file-scope data.  The Objective-C version of\n    this function still does something.  */"}, {"sha": "2f5bd2a34a6407e1f01ca73bc16829df61113723", "filename": "gcc/cgraph.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -404,6 +404,33 @@ hash_node (const void *p)\n   return (hashval_t) DECL_UID (n->decl);\n }\n \n+\n+/* Return the cgraph node associated with function DECL.  If none\n+   exists, return NULL.  */\n+\n+struct cgraph_node *\n+cgraph_node_for_decl (tree decl)\n+{\n+  struct cgraph_node *node;\n+  void **slot;\n+\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n+\n+  node = NULL;\n+  if (cgraph_hash)\n+    {\n+      struct cgraph_node key;\n+\n+      key.decl = decl;\n+      slot = htab_find_slot (cgraph_hash, &key, NO_INSERT);\n+      if (slot && *slot)\n+\tnode = (struct cgraph_node *) *slot;\n+    }\n+\n+  return node;\n+}\n+\n+\n /* Returns nonzero if P1 and P2 are equal.  */\n \n static int\n@@ -1893,9 +1920,6 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \t    push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \t    current_function_decl = fndecl;\n \t    gimple_register_cfg_hooks ();\n-\t    /* C++ Thunks are emitted late via this function, gimplify them.  */\n-\t    if (!gimple_body (fndecl))\n-\t      gimplify_function_tree (fndecl);\n \t    tree_lowering_passes (fndecl);\n \t    bitmap_obstack_initialize (NULL);\n \t    if (!gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))"}, {"sha": "67670ef4b77dc8a55925f4d10fc7407415377b52", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -391,7 +391,8 @@ struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n \n struct cgraph_node * cgraph_get_node (tree);\n struct cgraph_node *cgraph_node (tree);\n-struct cgraph_node *cgraph_node_for_asm (tree asmname);\n+struct cgraph_node *cgraph_node_for_asm (tree);\n+struct cgraph_node *cgraph_node_for_decl (tree);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, gimple);\n void cgraph_set_call_stmt (struct cgraph_edge *, gimple);\n void cgraph_set_call_stmt_including_clones (struct cgraph_node *, gimple, gimple);"}, {"sha": "1505b56c141ed110e7c54e5e36729caa544316e3", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -1108,9 +1108,6 @@ cgraph_expand_function (struct cgraph_node *node)\n   gcc_assert (node->lowered);\n \n   /* Generate RTL for the body of DECL.  */\n-  if (lang_hooks.callgraph.emit_associated_thunks\n-      && node->finalized_by_frontend)\n-    lang_hooks.callgraph.emit_associated_thunks (decl);\n   tree_rest_of_compilation (decl);\n \n   /* Make sure that BE didn't give up on compiling.  */\n@@ -1324,6 +1321,30 @@ ipa_passes (void)\n   bitmap_obstack_release (NULL);\n }\n \n+\n+/* Emit thunks for every node in the cgraph.\n+   FIXME: We really ought to emit thunks only for functions that are needed.  */\n+\n+static void\n+cgraph_emit_thunks (void)\n+{\n+  struct cgraph_node *n;\n+\n+  for (n = cgraph_nodes; n; n = n->next)\n+    {\n+      /* Only emit thunks on functions defined in this TU.\n+\t Note that this may emit more thunks than strictly necessary.\n+\t During optimization some nodes may disappear.  It would be\n+\t nice to only emit thunks only for the functions that will be\n+\t emitted, but we cannot know that until the inliner and other\n+\t IPA passes have run (see the sequencing of the call to\n+\t cgraph_mark_functions_to_output in cgraph_optimize).  */\n+      if (!DECL_EXTERNAL (n->decl))\n+\tlang_hooks.callgraph.emit_associated_thunks (n->decl);\n+    }\n+}\n+\n+\n /* Perform simple optimizations based on callgraph.  */\n \n static void\n@@ -1336,6 +1357,14 @@ cgraph_optimize (void)\n   verify_cgraph ();\n #endif\n \n+  /* Emit thunks, if needed.  */\n+  if (lang_hooks.callgraph.emit_associated_thunks)\n+    {\n+      cgraph_emit_thunks ();\n+      if (errorcount || sorrycount)\n+\treturn;\n+    }\n+\n   /* Call functions declared with the \"constructor\" or \"destructor\"\n      attribute.  */\n   cgraph_build_cdtor_fns ();\n@@ -1359,6 +1388,10 @@ cgraph_optimize (void)\n   if (errorcount == 0 && sorrycount == 0)\n     ipa_passes ();\n \n+  /* Do nothing else if any IPA pass found errors.  */\n+  if (errorcount || sorrycount)\n+    return;\n+\n   /* This pass remove bodies of extern inline functions we never inlined.\n      Do this later so other IPA passes see what is really going on.  */\n   cgraph_remove_unreachable_nodes (false, dump_file);\n@@ -1428,6 +1461,8 @@ cgraph_optimize (void)\n     }\n #endif\n }\n+\n+\n /* Generate and emit a static constructor or destructor.  WHICH must\n    be one of 'I' (for a constructor) or 'D' (for a destructor).  BODY\n    is a STATEMENT_LIST containing GENERIC statements.  PRIORITY is the"}, {"sha": "bac7098db72bf0d082218f8efa257562bf897dbf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -1,3 +1,32 @@\n+2009-09-03  Doug Kwan  <dougkwan@google.com>\n+\n+\t* tree.c (cp_fix_function_decl_p): New.\n+\t(cp_free_lang_data): New.\n+\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* Make-lang.in (decl2.o): Add dependency on $(POINTER_SET_H).\n+\t* decl2.c: Include pointer-set.h.\n+\t(collect_candidates_for_java_method_aliases): New.\n+\t(cp_write_global_declarations): Call it.\n+\tAdd local variable CANDIDATES.  If set, call\n+\tbuild_java_method_aliases.\n+\t(build_java_method_aliases): Add argument CANDIDATES.\n+\tUse it to determine if FNDECL should get a hidden alias.\n+\t* cp-objcp-common.h (LANG_HOOKS_FREE_LANG_DATA): Define.\n+\t* cp-tree.h (cp_free_lang_data): Declare.\n+\n+2009-09-03  Richard Guenther  <rguenther@suse.de>\n+\n+\t* method.c (use_thunk): Use cgraph_finalize_function to hand\n+\toff thunks to the cgraph.\n+\t* semantics.c (emit_associated_thunks): Do not emit thunks\n+\tfor really extern functions.\n+\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* cp-lang.c (lang_hooks): Remove const qualifier.\n+\n 2009-09-02  Jason Merrill  <jason@redhat.com>\n \n \t* semantics.c (describable_type): Don't pretend to be in a template."}, {"sha": "356565f75e5e9d588cfbc14e0d7cf7f3553c8ae0", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -257,7 +257,7 @@ cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) cp/decl.h \\\n   debug.h gt-cp-decl.h $(TIMEVAR_H) $(TREE_FLOW_H) $(TARGET_H) $(PLUGIN_H)\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(RTL_H) $(C_COMMON_H) gt-cp-decl2.h $(CGRAPH_H) \\\n-  $(C_PRAGMA_H) $(TREE_DUMP_H) intl.h $(TARGET_H) $(GIMPLE_H)\n+  $(C_PRAGMA_H) $(TREE_DUMP_H) intl.h $(TARGET_H) $(GIMPLE_H) $(POINTER_SET_H)\n cp/cp-objcp-common.o : cp/cp-objcp-common.c $(CONFIG_H) $(SYSTEM_H) \\\n   coretypes.h $(TM_H) $(TREE_H) $(CXX_TREE_H) $(C_COMMON_H) toplev.h \\\n   langhooks.h $(LANGHOOKS_DEF_H) $(DIAGNOSTIC_H) debug.h \\"}, {"sha": "f818e5bb0602e1efb48b636e4328078196c61ee2", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -73,7 +73,7 @@ static enum classify_record cp_classify_record (tree type);\n #define LANG_HOOKS_INIT_TS cp_init_ts\n \n /* Each front end provides its own lang hook initializer.  */\n-const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n /* Lang hook routines common to C++ and ObjC++ appear in cp/cp-objcp-common.c;\n    there should be very few routines below.  */"}, {"sha": "818540c219471fe94369ce11e11f58855176ef5e", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -32,6 +32,8 @@ extern bool cp_function_decl_explicit_p (tree decl);\n    specific to C++ or ObjC++ go in cp/cp-lang.c and objcp/objcp-lang.c,\n    respectively.  */\n \n+#undef LANG_HOOKS_FREE_LANG_DATA\n+#define LANG_HOOKS_FREE_LANG_DATA cp_free_lang_data\n #undef LANG_HOOKS_TREE_SIZE\n #define LANG_HOOKS_TREE_SIZE cp_tree_size\n #undef LANG_HOOKS_FINISH"}, {"sha": "23b41d3b62bee153b44661fae885b23a1c335530", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -4891,6 +4891,7 @@ extern tree finish_decltype_type                (tree, bool);\n extern tree finish_trait_expr\t\t\t(enum cp_trait_kind, tree, tree);\n \n /* in tree.c */\n+void cp_free_lang_data \t\t\t\t(tree t);\n extern tree force_target_expr\t\t\t(tree, tree);\n extern tree build_target_expr_with_type\t\t(tree, tree);\n extern void lang_check_failed\t\t\t(const char *, int,"}, {"sha": "cc4317aa7b4fda0e6c0315cdc55cbd9901089b51", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dump.h\"\n #include \"intl.h\"\n #include \"gimple.h\"\n+#include \"pointer-set.h\"\n \n extern cpp_reader *parse_in;\n \n@@ -3288,26 +3289,59 @@ cxx_callgraph_analyze_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED)\n \n /* Java requires that we be able to reference a local address for a\n    method, and not be confused by PLT entries.  If hidden aliases are\n-   supported, emit one for each java function that we've emitted.  */\n+   supported, collect and return all the functions for which we should\n+   emit a hidden alias.  */\n \n-static void\n-build_java_method_aliases (void)\n+static struct pointer_set_t *\n+collect_candidates_for_java_method_aliases (void)\n {\n   struct cgraph_node *node;\n+  struct pointer_set_t *candidates = NULL;\n \n #ifndef HAVE_GAS_HIDDEN\n-  return;\n+  return candidates;\n #endif\n \n   for (node = cgraph_nodes; node ; node = node->next)\n     {\n       tree fndecl = node->decl;\n \n-      if (TREE_ASM_WRITTEN (fndecl)\n-\t  && DECL_CONTEXT (fndecl)\n+      if (DECL_CONTEXT (fndecl)\n \t  && TYPE_P (DECL_CONTEXT (fndecl))\n \t  && TYPE_FOR_JAVA (DECL_CONTEXT (fndecl))\n \t  && TARGET_USE_LOCAL_THUNK_ALIAS_P (fndecl))\n+\t{\n+\t  if (candidates == NULL)\n+\t    candidates = pointer_set_create ();\n+\t  pointer_set_insert (candidates, fndecl);\n+\t}\n+    }\n+\n+  return candidates;\n+}\n+\n+\n+/* Java requires that we be able to reference a local address for a\n+   method, and not be confused by PLT entries.  If hidden aliases are\n+   supported, emit one for each java function that we've emitted.\n+   CANDIDATES is the set of FUNCTION_DECLs that were gathered\n+   by collect_candidates_for_java_method_aliases.  */\n+\n+static void\n+build_java_method_aliases (struct pointer_set_t *candidates)\n+{\n+  struct cgraph_node *node;\n+\n+#ifndef HAVE_GAS_HIDDEN\n+  return;\n+#endif\n+\n+  for (node = cgraph_nodes; node ; node = node->next)\n+    {\n+      tree fndecl = node->decl;\n+\n+      if (TREE_ASM_WRITTEN (fndecl)\n+\t  && pointer_set_contains (candidates, fndecl))\n \t{\n \t  /* Mangle the name in a predictable way; we need to reference\n \t     this from a java compiled object file.  */\n@@ -3379,6 +3413,7 @@ cp_write_global_declarations (void)\n   unsigned ssdf_count = 0;\n   int retries = 0;\n   tree decl;\n+  struct pointer_set_t *candidates;\n \n   locus = input_location;\n   at_eof = 1;\n@@ -3676,6 +3711,9 @@ cp_write_global_declarations (void)\n      linkage now.  */\n   pop_lang_context ();\n \n+  /* Collect candidates for Java hidden aliases.  */\n+  candidates = collect_candidates_for_java_method_aliases ();\n+\n   cgraph_finalize_compilation_unit ();\n \n   /* Now, issue warnings about static, but not defined, functions,\n@@ -3690,7 +3728,11 @@ cp_write_global_declarations (void)\n     }\n \n   /* Generate hidden aliases for Java.  */\n-  build_java_method_aliases ();\n+  if (candidates)\n+    {\n+      build_java_method_aliases (candidates);\n+      pointer_set_destroy (candidates);\n+    }\n \n   finish_repo ();\n "}, {"sha": "477140c4472184494f5f44f241ba381288b08d09", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -3186,7 +3186,9 @@ emit_associated_thunks (tree fn)\n      is so that you can know statically the entire set of thunks that\n      will ever be needed for a given virtual function, thereby\n      enabling you to output all the thunks with the function itself.  */\n-  if (DECL_VIRTUAL_P (fn))\n+  if (DECL_VIRTUAL_P (fn)\n+      /* Do not emit thunks for extern template instantiations.  */\n+      && ! DECL_REALLY_EXTERN (fn))\n     {\n       tree thunk;\n "}, {"sha": "808a18a48ada8eb48911b7d905eb2f488e729475", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -3030,6 +3030,53 @@ cast_valid_in_integral_constant_expression_p (tree type)\n \t  || type == error_mark_node);\n }\n \n+/* Return true if we need to fix linkage information of DECL.  */\n+\n+static bool\n+cp_fix_function_decl_p (tree decl)\n+{\n+  /* Skip if DECL is not externally visible.  */\n+  if (!TREE_PUBLIC (decl))\n+    return false;\n+\n+  /* We need to fix DECL if it a appears to be exported but with no\n+     function body.  Thunks do not have CFGs and we may need to\n+     handle them specially later.   */\n+  if (!gimple_has_body_p (decl)\n+      && !DECL_THUNK_P (decl)\n+      && !DECL_EXTERNAL (decl))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Clean the C++ specific parts of the tree T. */\n+\n+void\n+cp_free_lang_data (tree t)\n+{\n+  if (TREE_CODE (t) == METHOD_TYPE\n+      || TREE_CODE (t) == FUNCTION_TYPE)\n+    {\n+      /* Default args are not interesting anymore.  */\n+      tree argtypes = TYPE_ARG_TYPES (t);\n+      while (argtypes)\n+        {\n+\t  TREE_PURPOSE (argtypes) = 0;\n+\t  argtypes = TREE_CHAIN (argtypes);\n+\t}\n+    }\n+  else if (TREE_CODE (t) == FUNCTION_DECL\n+\t   && cp_fix_function_decl_p (t))\n+    {\n+      /* If T is used in this translation unit at all,  the definition\n+\t must exist somewhere else since we have decided to not emit it\n+\t in this TU.  So make it an external reference.  */\n+      DECL_EXTERNAL (t) = 1;\n+      TREE_STATIC (t) = 0;\n+    }\n+}\n+\n \f\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n /* Complain that some language-specific thing hanging off a tree"}, {"sha": "bca7478329180af2b6c00fd9552ceb37654e00ab", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -48,11 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n /* Prototypes.  */\n static char *build_message_string (const char *, ...) ATTRIBUTE_PRINTF_1;\n \n-static void default_diagnostic_starter (diagnostic_context *,\n-\t\t\t\t\tdiagnostic_info *);\n-static void default_diagnostic_finalizer (diagnostic_context *,\n-\t\t\t\t\t  diagnostic_info *);\n-\n static void error_recursion (diagnostic_context *) ATTRIBUTE_NORETURN;\n \n static void diagnostic_action_after_output (diagnostic_context *,\n@@ -266,15 +261,15 @@ diagnostic_report_current_module (diagnostic_context *context)\n     }\n }\n \n-static void\n+void\n default_diagnostic_starter (diagnostic_context *context,\n \t\t\t    diagnostic_info *diagnostic)\n {\n   diagnostic_report_current_function (context, diagnostic);\n   pp_set_prefix (context->printer, diagnostic_build_prefix (diagnostic));\n }\n \n-static void\n+void\n default_diagnostic_finalizer (diagnostic_context *context,\n \t\t\t      diagnostic_info *diagnostic ATTRIBUTE_UNUSED)\n {"}, {"sha": "c2c08bc849671e3ec4f823986acec18ea73fc7fe", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -213,6 +213,8 @@ extern bool emit_diagnostic (diagnostic_t, location_t, int,\n \t\t\t     const char *, ...) ATTRIBUTE_GCC_DIAG(4,5);\n #endif\n extern char *diagnostic_build_prefix (diagnostic_info *);\n+void default_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n+void default_diagnostic_finalizer (diagnostic_context *, diagnostic_info *);\n \n /* Pure text formatting support functions.  */\n extern char *file_name_as_prefix (const char *);\n@@ -239,4 +241,8 @@ extern void print_gimple_stmt (FILE *, gimple, int, int);\n extern void print_gimple_expr (FILE *, gimple, int, int);\n extern void dump_gimple_stmt (pretty_printer *, gimple, int, int);\n \n+/* In toplev.c  */\n+extern bool default_tree_printer (pretty_printer *, text_info *, const char *,\n+\t\t\t\t  int, bool, bool, bool);\n+\n #endif /* ! GCC_DIAGNOSTIC_H */"}, {"sha": "c97928eadf17b55e61abb11bf534c98e632b2dea", "filename": "gcc/except.c", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -1688,6 +1688,10 @@ add_type_for_runtime (tree type)\n {\n   tree *slot;\n \n+  /* If TYPE is NOP_EXPR, it means that it already is a runtime type.  */\n+  if (TREE_CODE (type) == NOP_EXPR)\n+    return;\n+\n   slot = (tree *) htab_find_slot_with_hash (type_to_runtime_map, type,\n \t\t\t\t\t    TREE_HASH (type), INSERT);\n   if (*slot == NULL)\n@@ -1702,6 +1706,10 @@ lookup_type_for_runtime (tree type)\n {\n   tree *slot;\n \n+  /* If TYPE is NOP_EXPR, it means that it already is a runtime type.  */\n+  if (TREE_CODE (type) == NOP_EXPR)\n+    return type;\n+\n   slot = (tree *) htab_find_slot_with_hash (type_to_runtime_map, type,\n \t\t\t\t\t    TREE_HASH (type), NO_INSERT);\n \n@@ -2881,8 +2889,33 @@ check_handled (tree handled, tree type)\n   if (! lang_eh_type_covers)\n     {\n       for (t = handled; t ; t = TREE_CHAIN (t))\n-\tif (TREE_VALUE (t) == type)\n-\t  return 1;\n+\t{\n+\t  tree t1 = TREE_VALUE (t);\n+\t  tree t2 = type;\n+\n+\t  /* If the types have been converted to runtime types (i.e.,\n+\t     when the IL is being read from disk in an LTO\n+\t     compilation), then T1 and T2 will be pointers to the\n+\t     runtime type of the form '(void *) &<runtime_type>' (See\n+\t     cp/except.c:build_eh_type_type).  Strip the conversion\n+\t     and the address.  */\n+\t  if (CONVERT_EXPR_P (t1))\n+\t    {\n+\t      STRIP_NOPS (t1);\n+\t      gcc_assert (TREE_CODE (t1) == ADDR_EXPR);\n+\t      t1 = TREE_OPERAND (t1, 0);\n+\t    }\n+\n+\t  if (CONVERT_EXPR_P (t2))\n+\t    {\n+\t      STRIP_NOPS (t2);\n+\t      gcc_assert (TREE_CODE (t2) == ADDR_EXPR);\n+\t      t2 = TREE_OPERAND (t2, 0);\n+\t    }\n+\n+\t  if (t1 == t2)\n+\t    return 1;\n+\t}\n     }\n   else\n     {"}, {"sha": "aeae2835f3a9b75e0651fd9c1e08503a47b87ebc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -1,3 +1,7 @@\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* f95-lang.c (lang_hooks): Remove const qualifier.\n+\n 2009-09-01  Richard Guenther  <rguenther@suse.de>\n \n \t* f95-lang.c (gfc_mark_addressable): Remove."}, {"sha": "e061538878f90ba221127d9f186adb91cb1ebb90", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -154,7 +154,7 @@ static void gfc_init_ts (void);\n #define LANG_HOOKS_BUILTIN_FUNCTION          gfc_builtin_function\n #define LANG_HOOKS_GET_ARRAY_DESCR_INFO\t     gfc_get_array_descr_info\n \n-const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n #define NULL_BINDING_LEVEL (struct binding_level *) NULL\n "}, {"sha": "9223aaa8824372cf54ef0b980a6176088515608a", "filename": "gcc/gimple.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"value-prof.h\"\n #include \"flags.h\"\n+#include \"demangle.h\"\n \n #define DEFGSCODE(SYM, NAME, STRUCT)\tNAME,\n const char *const gimple_code_name[] = {\n@@ -3427,4 +3428,75 @@ gimple_ior_addresses_taken (bitmap addresses_taken, gimple stmt)\n \t\t\t\t\tgimple_ior_addresses_taken_1);\n }\n \n+\n+/* Return a printable name for symbol DECL.  */\n+\n+const char *\n+gimple_decl_printable_name (tree decl, int verbosity)\n+{\n+  gcc_assert (decl && DECL_NAME (decl));\n+\n+  if (DECL_ASSEMBLER_NAME_SET_P (decl))\n+    {\n+      const char *str, *mangled_str;\n+      int dmgl_opts = DMGL_NO_OPTS;\n+\n+      if (verbosity >= 2)\n+\t{\n+\t  dmgl_opts = DMGL_VERBOSE\n+\t\t      | DMGL_TYPES\n+\t\t      | DMGL_ANSI\n+\t\t      | DMGL_GNU_V3\n+\t\t      | DMGL_RET_POSTFIX;\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t    dmgl_opts |= DMGL_PARAMS;\n+\t}\n+\n+      mangled_str = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+      str = cplus_demangle_v3 (mangled_str, dmgl_opts);\n+      return (str) ? str : mangled_str;\n+    }\n+\n+  return IDENTIFIER_POINTER (DECL_NAME (decl));\n+}\n+\n+\n+/* Fold a OBJ_TYPE_REF expression to the address of a function.\n+   KNOWN_TYPE carries the true type of OBJ_TYPE_REF_OBJECT(REF).  Adapted\n+   from cp_fold_obj_type_ref, but it tolerates types with no binfo\n+   data.  */\n+\n+tree\n+gimple_fold_obj_type_ref (tree ref, tree known_type)\n+{\n+  HOST_WIDE_INT index;\n+  HOST_WIDE_INT i;\n+  tree v;\n+  tree fndecl;\n+\n+  if (TYPE_BINFO (known_type) == NULL_TREE)\n+    return NULL_TREE;\n+\n+  v = BINFO_VIRTUALS (TYPE_BINFO (known_type));\n+  index = tree_low_cst (OBJ_TYPE_REF_TOKEN (ref), 1);\n+  i = 0;\n+  while (i != index)\n+    {\n+      i += (TARGET_VTABLE_USES_DESCRIPTORS\n+\t    ? TARGET_VTABLE_USES_DESCRIPTORS : 1);\n+      v = TREE_CHAIN (v);\n+    }\n+\n+  fndecl = TREE_VALUE (v);\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (tree_int_cst_equal (OBJ_TYPE_REF_TOKEN (ref),\n+\t\t\t\t  DECL_VINDEX (fndecl)));\n+#endif\n+\n+  cgraph_node (fndecl)->local.vtable_method = true;\n+\n+  return build_fold_addr_expr (fndecl);\n+}\n+\n #include \"gt-gimple.h\""}, {"sha": "97d2c3789ac987fa5f1aaa6f956d1c488c2cc801", "filename": "gcc/gimple.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -836,6 +836,8 @@ bool gimple_assign_rhs_could_trap_p (gimple);\n void gimple_regimplify_operands (gimple, gimple_stmt_iterator *);\n bool empty_body_p (gimple_seq);\n unsigned get_gimple_rhs_num_ops (enum tree_code);\n+const char *gimple_decl_printable_name (tree, int);\n+tree gimple_fold_obj_type_ref (tree, tree);\n \n /* Returns true iff T is a valid GIMPLE statement.  */\n extern bool is_gimple_stmt (tree);"}, {"sha": "9204caae77bc3b5fa7a646754f4fb189d5c2338d", "filename": "gcc/ipa.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -240,6 +240,11 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();\n #endif\n+\n+  /* Reclaim alias pairs for functions that have disappeared from the\n+     call graph.  */\n+  remove_unreachable_alias_pairs ();\n+\n   return changed;\n }\n "}, {"sha": "569b5fe16fe1fc7e64f310f576852fec419f9013", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -1,3 +1,7 @@\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* lang.c (lang_hooks): Remove const qualifier.\n+\n 2009-09-01  Jakub Jelinek  <jakub@redhat.com>\n \n \t* boehm.c (mark_reference_fields): Compute % in HOST_WIDE_INT"}, {"sha": "d97b508b707be3851a520c793b9861a773beb55d", "filename": "gcc/java/lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -159,7 +159,7 @@ struct GTY(()) language_function {\n #define LANG_HOOKS_ATTRIBUTE_TABLE java_attribute_table\n \n /* Each front end provides its own.  */\n-const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n /*\n  * process java-specific compiler command-line options"}, {"sha": "63a0dcde20dc6739550c7660864bbb339b4673d9", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -99,6 +99,7 @@ extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n #define LANG_HOOKS_PRINT_ERROR_FUNCTION lhd_print_error_function\n #define LANG_HOOKS_DECL_PRINTABLE_NAME\tlhd_decl_printable_name\n #define LANG_HOOKS_DWARF_NAME\t\tlhd_dwarf_name\n+#define LANG_HOOKS_FREE_LANG_DATA\tlhd_do_nothing_t\n #define LANG_HOOKS_TREE_SIZE\t\tlhd_tree_size\n #define LANG_HOOKS_TYPES_COMPATIBLE_P\tlhd_types_compatible_p\n #define LANG_HOOKS_BUILTIN_FUNCTION\tlhd_builtin_function\n@@ -229,6 +230,7 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_INITIALIZER { \\\n   LANG_HOOKS_NAME, \\\n   LANG_HOOKS_IDENTIFIER_SIZE, \\\n+  LANG_HOOKS_FREE_LANG_DATA, \\\n   LANG_HOOKS_TREE_SIZE, \\\n   LANG_HOOKS_INIT_OPTIONS, \\\n   LANG_HOOKS_INITIALIZE_DIAGNOSTICS, \\"}, {"sha": "8342004be966fbe5acf5be5c3a34e1e916804113", "filename": "gcc/langhooks.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -235,6 +235,9 @@ struct lang_hooks\n      identifier nodes long enough for the language-specific slots.  */\n   size_t identifier_size;\n \n+  /* Remove any parts of the tree that are used only by the FE. */\n+  void (*free_lang_data) (tree);\n+\n   /* Determines the size of any language-specific tcc_constant or\n      tcc_exceptional nodes.  Since it is called from make_node, the\n      only information available is the tree code.  Expected to die\n@@ -416,7 +419,7 @@ struct lang_hooks\n };\n \n /* Each front end provides its own.  */\n-extern const struct lang_hooks lang_hooks;\n+extern struct lang_hooks lang_hooks;\n extern tree add_builtin_function (const char *name, tree type,\n \t\t\t\t  int function_code, enum built_in_class cl,\n \t\t\t\t  const char *library_name,"}, {"sha": "d499f0a55c9b3672ef48203564661ed614d0e6a6", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -1,3 +1,7 @@\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* objc-lang.c (lang_hooks): Remove const qualifier.\n+\n 2009-08-20  Richard Guenther  <rguenther@suse.de>\n \n \t* objc-act.c: Include c-lang.h"}, {"sha": "98f46d741abf8b1a75f6c664b79b5dce0750044e", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -52,7 +52,7 @@ static void objc_init_ts (void);\n #define LANG_HOOKS_INIT_TS objc_init_ts\n \n /* Each front end provides its own lang hook initializer.  */\n-const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n /* Lang hook routines common to C and ObjC appear in c-objc-common.c;\n    there should be very few (if any) routines below.  */"}, {"sha": "9acf08b3e4dfef945efc74417e8e9215dd1bb9d2", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -1,3 +1,7 @@\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* objcp-lang.c (lang_hooks): Remove const qualifier.\n+\n 2009-07-14  Taras Glek  <tglek@mozilla.com>\n \t    Rafael Espindola  <espindola@google.com>\n "}, {"sha": "1b54ba817542e8ee231ca7d352d060478db63eaa", "filename": "gcc/objcp/objcp-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fobjcp%2Fobjcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fobjcp%2Fobjcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-lang.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -52,7 +52,7 @@ static void objcxx_init_ts (void);\n #define LANG_HOOKS_INIT_TS objcxx_init_ts\n \n /* Each front end provides its own lang hook initializer.  */\n-const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n /* Lang hook routines common to C++ and ObjC++ appear in cp/cp-objcp-common.c;\n    there should be very few (if any) routines below.  */"}, {"sha": "531dc602739792ed7a73a0d86ca35e2745700d22", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -535,6 +535,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_inline_parameters);\n       NEXT_PASS (pass_rebuild_cgraph_edges);\n     }\n+  NEXT_PASS (pass_ipa_free_lang_data);\n   NEXT_PASS (pass_early_local_passes);\n     {\n       struct opt_pass **p = &pass_early_local_passes.pass.sub;"}, {"sha": "277bcc7a4de18638e88a97850b4e7cafb5e78b47", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -1,3 +1,13 @@\n+2009-09-03  Diego Novillo  <dnovillo@google.com>\n+\n+\t* gcc.dg/gomp/combined-1.c: Adjust expected pattern.\n+\t* g++.dg/tree-prof/inline_mismatch_args.C: Likewise.\n+\t* g++.dg/warn/unit-1.C: Likewise.\n+\t* g++.dg/ipa/iinline-1.C: Likewise.\n+\t* g++.dg/template/cond2.C: Adjust expected line location for the\n+\terror.\n+\t* g++.dg/template/pr35240.C: Likewise.\n+\n 2009-09-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/tree-ssa/inline-3.c: Add -fpie when pic."}, {"sha": "1453c7e46584d9cd1a8afba095828f6e9fb25170", "filename": "gcc/testsuite/g++.dg/ipa/iinline-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fiinline-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fiinline-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fiinline-1.C?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -44,5 +44,5 @@ int main (int argc, char *argv[])\n   return 0;\n }\n \n-/* { dg-final { scan-ipa-dump \"String::funcOne\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"String::funcOne\\[^\\\\n\\]*inline copy in main\"  \"inline\"  } } */\n /* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "e6bd19d40fa85a33d2cb458a0ed72639a6f47acf", "filename": "gcc/testsuite/g++.dg/template/cond2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcond2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcond2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcond2.C?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -3,8 +3,8 @@\n \n template<int X> class c;\n \n-template<int X, int Y> int test(c<X ? : Y>&);\n+template<int X, int Y> int test(c<X ? : Y>&); // { dg-error \"omitted\" }\n \n void test(c<2>*c2) {\n-\ttest<0, 2>(*c2); // { dg-error \"omitted\" }\n+\ttest<0, 2>(*c2);\n }"}, {"sha": "1972cf73b87fea4ee5088cc6c5a655a9ad05b56a", "filename": "gcc/testsuite/g++.dg/template/pr35240.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr35240.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr35240.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr35240.C?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -4,9 +4,9 @@\n \n template<int> struct A {};\n \n-template<int N> A<sizeof(new int[N][N])> foo();\n+template<int N> A<sizeof(new int[N][N])> foo();\t// { dg-message \"unimplemented\" }\n \n void bar()\n {\n-  foo<1>();\t// { dg-message \"unimplemented\" }\n+  foo<1>();\n }"}, {"sha": "352e176a95c478e7f0e8eb85a3c44f4dc25ea69e", "filename": "gcc/testsuite/g++.dg/tree-prof/inline_mismatch_args.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Finline_mismatch_args.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Finline_mismatch_args.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Finline_mismatch_args.C?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -31,6 +31,6 @@ int main(void)\n  baz.Bar(&baz, gid);\n  return 0;\n }\n-/* { dg-final-use { scan-tree-dump \"Inlining virtual void Super::Foo\" \"einline2\"} } */                                                                                \n+/* { dg-final-use { scan-tree-dump \"Inlining .*Super::Foo\" \"einline2\"} } */                                                                                \n /* { dg-final-use { scan-tree-dump-not \"mismatched arguments\" \"einline2\"} } */                                                                 \n /* { dg-final-use { cleanup-tree-dump \"einline2\" } } */"}, {"sha": "49bc23136f4a6201bb6143596b1250db2af96c85", "filename": "gcc/testsuite/g++.dg/warn/unit-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funit-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funit-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funit-1.C?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -4,7 +4,7 @@\n struct a { int mode; };\n int sys_msgctl (void)\n {\n-  struct a setbuf;  /* { dg-warning \"'setbuf\\.a::mode' is used\" \"\" { xfail *-*-* } } */\n+  struct a setbuf;  /* { dg-warning \"'setbuf.mode' is used\" \"\" { xfail *-*-* } } */\n   return setbuf.mode;\n }\n "}, {"sha": "dfed647371f5ba39e84ed6857734ef1609f8add4", "filename": "gcc/testsuite/gcc.dg/gomp/combined-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -20,5 +20,5 @@ int foo (void)\n       }\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin_GOMP_parallel_loop_runtime_start\" 3 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_runtime_start\" 3 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "7e3d702dd5ad142dc5a0a2c648cd00f2c957e323", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -46,6 +46,7 @@ DEFTIMEVAR (TV_IPA_REFERENCE         , \"ipa reference\")\n DEFTIMEVAR (TV_IPA_PURE_CONST        , \"ipa pure const\")\n DEFTIMEVAR (TV_IPA_TYPE_ESCAPE       , \"ipa type escape\")\n DEFTIMEVAR (TV_IPA_PTA               , \"ipa points-to\")\n+DEFTIMEVAR (TV_IPA_FREE_LANG_DATA    , \"ipa free lang data\")\n /* Time spent by constructing CFG.  */\n DEFTIMEVAR (TV_CFG                   , \"cfg construction\")\n /* Time spent by cleaning up CFG.  */"}, {"sha": "1eaa893c0dfbded0d6334ac111b00bd3d3981269", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -1576,8 +1576,8 @@ default_pch_valid_p (const void *data_p, size_t len)\n }\n \n /* Default tree printer.   Handles declarations only.  */\n-static bool\n-default_tree_printer (pretty_printer * pp, text_info *text, const char *spec,\n+bool\n+default_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n \t\t      int precision, bool wide, bool set_locus, bool hash)\n {\n   tree t;"}, {"sha": "4bb3364039ee9ab3dcb59adf092d9850bf35d4ba", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -409,6 +409,7 @@ extern struct gimple_opt_pass pass_warn_unused_result;\n \n /* IPA Passes */\n extern struct ipa_opt_pass_d pass_ipa_inline;\n+extern struct simple_ipa_opt_pass pass_ipa_free_lang_data;\n extern struct ipa_opt_pass_d pass_ipa_cp;\n extern struct ipa_opt_pass_d pass_ipa_reference;\n extern struct ipa_opt_pass_d pass_ipa_pure_const;"}, {"sha": "1db7d0a86c33b97bac93b0f7e9f61863fdfba136", "filename": "gcc/tree.c", "status": "modified", "additions": 793, "deletions": 0, "changes": 793, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -52,6 +52,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"pointer-set.h\"\n #include \"fixed-value.h\"\n+#include \"tree-pass.h\"\n+#include \"langhooks-def.h\"\n+#include \"diagnostic.h\"\n+#include \"cgraph.h\"\n+#include \"timevar.h\"\n+#include \"except.h\"\n+#include \"debug.h\"\n \n /* Tree code classes.  */\n \n@@ -4124,6 +4131,789 @@ build_type_attribute_variant (tree ttype, tree attribute)\n \t\t\t\t\t    TYPE_QUALS (ttype));\n }\n \n+/* Reset all language specific information still present in TYPE.  */\n+\n+static void\n+free_lang_data_in_type (tree type)\n+{\n+  gcc_assert (TYPE_P (type));\n+\n+  /* Fill in the alias-set.  We need to at least track zeroness here\n+     for correctness.  */\n+  if (lang_hooks.get_alias_set (type) == 0)\n+    TYPE_ALIAS_SET (type) = 0;\n+\n+  /* Give the FE a chance to remove its own data first.  */\n+  lang_hooks.free_lang_data (type);\n+\n+  TREE_LANG_FLAG_0 (type) = 0;\n+  TREE_LANG_FLAG_1 (type) = 0;\n+  TREE_LANG_FLAG_2 (type) = 0;\n+  TREE_LANG_FLAG_3 (type) = 0;\n+  TREE_LANG_FLAG_4 (type) = 0;\n+  TREE_LANG_FLAG_5 (type) = 0;\n+  TREE_LANG_FLAG_6 (type) = 0;\n+\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    {\n+      /* Remove the const and volatile qualifiers from arguments.  The\n+\t C++ front end removes them, but the C front end does not,\n+\t leading to false ODR violation errors when merging two\n+\t instances of the same function signature compiled by\n+\t different front ends.  */\n+      tree p;\n+\n+      for (p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))\n+\t{\n+\t  tree arg_type = TREE_VALUE (p);\n+\n+\t  if (TYPE_READONLY (arg_type) || TYPE_VOLATILE (arg_type))\n+\t    {\n+\t      int quals = TYPE_QUALS (arg_type)\n+\t\t\t  & ~TYPE_QUAL_CONST\n+\t\t\t  & ~TYPE_QUAL_VOLATILE;\n+\t      TREE_VALUE (p) = build_qualified_type (arg_type, quals);\n+\t      free_lang_data_in_type (TREE_VALUE (p));\n+\t    }\n+\t}\n+    }\n+\t      \n+  /* Remove members that are not actually FIELD_DECLs from the field\n+     list of an aggregate.  These occur in C++.  */\n+  if (TREE_CODE (type) == RECORD_TYPE\n+      || TREE_CODE (type) == UNION_TYPE\n+      || TREE_CODE (type) == QUAL_UNION_TYPE)\n+    {\n+      tree prev, member;\n+\n+      /* Note that TYPE_FIELDS can be shared across distinct\n+\t TREE_TYPEs.  Therefore, if the first field of TYPE_FIELDS is\n+\t to be removed, we cannot set its TREE_CHAIN to NULL.\n+\t Otherwise, we would not be able to find all the other fields\n+\t in the other instances of this TREE_TYPE.\n+\t \n+\t This was causing an ICE in testsuite/g++.dg/lto/20080915.C.  */\n+      prev = NULL_TREE;\n+      member = TYPE_FIELDS (type);\n+      while (member)\n+\t{\n+\t  if (TREE_CODE (member) == FIELD_DECL)\n+\t    {\n+\t      if (prev)\n+\t\tTREE_CHAIN (prev) = member;\n+\t      else\n+\t\tTYPE_FIELDS (type) = member;\n+\t      prev = member;\n+\t    }\n+\n+\t  member = TREE_CHAIN (member);\n+\t}\n+\n+      if (prev)\n+\tTREE_CHAIN (prev) = NULL_TREE;\n+      else\n+\tTYPE_FIELDS (type) = NULL_TREE;\n+\n+      TYPE_METHODS (type) = NULL_TREE;\n+      if (TYPE_BINFO (type))\n+\t{\n+\t  tree binfo = TYPE_BINFO (type);\n+\n+\t  if (BINFO_VIRTUALS (binfo))\n+\t    {\n+\t      /* If the virtual function table for BINFO contains\n+\t\t entries, these may be useful for folding OBJ_TYPE_REF\n+\t\t expressions (see gimple_fold_obj_type_ref).  In that\n+\t\t case, we only clear the unused fields in the BINFO\n+\t\t structure.  */\n+\t      BINFO_OFFSET (binfo) = NULL_TREE;\n+\t      BINFO_VTABLE (binfo) = NULL_TREE;\n+\t      BINFO_VPTR_FIELD (binfo) = NULL_TREE;\n+\t      BINFO_BASE_ACCESSES (binfo) = NULL;\n+\t      BINFO_INHERITANCE_CHAIN (binfo) = NULL_TREE;\n+\t      BINFO_SUBVTT_INDEX (binfo) = NULL_TREE;\n+\t      BINFO_VPTR_FIELD (binfo) = NULL_TREE;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, get rid of the whole binfo data.  */\n+\t      TYPE_BINFO (type) = NULL_TREE;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* For non-aggregate types, clear out the language slot (which\n+\t overloads TYPE_BINFO).  */\n+      TYPE_LANG_SLOT_1 (type) = NULL_TREE;\n+    }\n+\n+  TYPE_CONTEXT (type) = NULL_TREE;\n+  TYPE_STUB_DECL (type) = NULL_TREE;\n+\n+  /* Remove type variants other than the main variant.  This is both\n+     wasteful and it may introduce infinite loops when the types are\n+     read from disk and merged (since the variant will be the same\n+     type as the main variant, traversing type variants will get into\n+     an infinite loop).  */\n+  if (TYPE_MAIN_VARIANT (type))\n+    TYPE_NEXT_VARIANT (TYPE_MAIN_VARIANT (type)) = NULL_TREE;\n+\n+  TYPE_NEXT_VARIANT (type) = NULL_TREE;\n+}\n+\n+\n+/* Return true if DECL may need an assembler name to be set.  */\n+\n+static inline bool\n+need_assembler_name_p (tree decl)\n+{\n+  /* Only FUNCTION_DECLs and VAR_DECLs are considered.  */\n+  if (TREE_CODE (decl) != FUNCTION_DECL\n+      && TREE_CODE (decl) != VAR_DECL)\n+    return false;\n+\n+  /* If DECL already has its assembler name set, it does not need a\n+     new one.  */\n+  if (!HAS_DECL_ASSEMBLER_NAME_P (decl)\n+      || DECL_ASSEMBLER_NAME_SET_P (decl))\n+    return false;\n+\n+  /* For VAR_DECLs, only static, public and external symbols need an\n+     assembler name.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && !TREE_STATIC (decl)\n+      && !TREE_PUBLIC (decl)\n+      && !DECL_EXTERNAL (decl))\n+    return false;\n+\n+  /* Do not set assembler name on builtins.  Allow RTL expansion to\n+     decide whether to expand inline or via a regular call.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && DECL_BUILT_IN (decl)\n+      && DECL_BUILT_IN_CLASS (decl) != BUILT_IN_FRONTEND)\n+    return false;\n+\n+  /* For FUNCTION_DECLs, only used functions and functions\n+     represented in the callgraph need an assembler name.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && cgraph_node_for_decl (decl) == NULL\n+      && !TREE_USED (decl))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n+/* Remove all the non-variable decls from BLOCK.  LOCALS is the set of\n+   variables in DECL_STRUCT_FUNCTION (FN)->local_decls.  Every decl\n+   in BLOCK that is not in LOCALS is removed.  */\n+\n+static void\n+free_lang_data_in_block (tree fn, tree block, struct pointer_set_t *locals)\n+{\n+  tree *tp, t;\n+\n+  tp = &BLOCK_VARS (block);\n+  while (*tp)\n+    {\n+      if (!pointer_set_contains (locals, *tp))\n+\t*tp = TREE_CHAIN (*tp);\n+      else\n+\ttp = &TREE_CHAIN (*tp);\n+    }\n+\n+  for (t = BLOCK_SUBBLOCKS (block); t; t = BLOCK_CHAIN (t))\n+    free_lang_data_in_block (fn, t, locals);\n+}\n+\n+\n+/* Reset all language specific information still present in symbol\n+   DECL.  */\n+\n+static void\n+free_lang_data_in_decl (tree decl)\n+{\n+  gcc_assert (DECL_P (decl));\n+\n+  /* Give the FE a chance to remove its own data first.  */\n+  lang_hooks.free_lang_data (decl);\n+\n+  TREE_LANG_FLAG_0 (decl) = 0;\n+  TREE_LANG_FLAG_1 (decl) = 0;\n+  TREE_LANG_FLAG_2 (decl) = 0;\n+  TREE_LANG_FLAG_3 (decl) = 0;\n+  TREE_LANG_FLAG_4 (decl) = 0;\n+  TREE_LANG_FLAG_5 (decl) = 0;\n+  TREE_LANG_FLAG_6 (decl) = 0;\n+\n+  /* Identifiers need not have a type.  */\n+  if (DECL_NAME (decl))\n+    TREE_TYPE (DECL_NAME (decl)) = NULL_TREE;\n+\n+  if (TREE_CODE (decl) == CONST_DECL)\n+    DECL_CONTEXT (decl) = NULL_TREE;\n+\n+  /* Ignore any intervening types, because we are going to clear their\n+     TYPE_CONTEXT fields.  */\n+  if (TREE_CODE (decl) != FIELD_DECL)\n+    DECL_CONTEXT (decl) = decl_function_context (decl);\n+\n+  if (DECL_CONTEXT (decl)\n+      && TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL)\n+    DECL_CONTEXT (decl) = NULL_TREE;\n+\n+ if (TREE_CODE (decl) == VAR_DECL)\n+   {\n+     tree context = DECL_CONTEXT (decl);\n+\n+     if (context)\n+       {\n+\t enum tree_code code = TREE_CODE (context);\n+\t if (code == FUNCTION_DECL && DECL_ABSTRACT (context))\n+\t   {\n+\t     /* Do not clear the decl context here, that will promote\n+\t        all vars to global ones.  */\n+\t     DECL_INITIAL (decl) = NULL_TREE;\n+\t   }\n+\n+\t if (TREE_STATIC (decl))\n+\t   DECL_CONTEXT (decl) = NULL_TREE;\n+       }\n+   }\n+\n+  if (TREE_CODE (decl) == PARM_DECL\n+      || TREE_CODE (decl) == FIELD_DECL\n+      || TREE_CODE (decl) == RESULT_DECL)\n+    {\n+      tree unit_size = DECL_SIZE_UNIT (decl);\n+      tree size = DECL_SIZE (decl);\n+      if ((unit_size && TREE_CODE (unit_size) != INTEGER_CST)\n+\t  || (size && TREE_CODE (size) != INTEGER_CST))\n+\t{\n+\t  DECL_SIZE_UNIT (decl) = NULL_TREE;\n+\t  DECL_SIZE (decl) = NULL_TREE;\n+\t}\n+\n+      if (TREE_CODE (decl) == FIELD_DECL\n+\t  && DECL_FIELD_OFFSET (decl)\n+\t  && TREE_CODE (DECL_FIELD_OFFSET (decl)) != INTEGER_CST)\n+\tDECL_FIELD_OFFSET (decl) = NULL_TREE;\n+    }\n+  else if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      if (gimple_has_body_p (decl))\n+\t{\n+\t  tree t;\n+\t  struct pointer_set_t *locals;\n+\n+\t  /* If DECL has a gimple body, then the context for its\n+\t     arguments must be DECL.  Otherwise, it doesn't really\n+\t     matter, as we will not be emitting any code for DECL.  In\n+\t     general, there may be other instances of DECL created by\n+\t     the front end and since PARM_DECLs are generally shared,\n+\t     their DECL_CONTEXT changes as the replicas of DECL are\n+\t     created.  The only time where DECL_CONTEXT is important\n+\t     is for the FUNCTION_DECLs that have a gimple body (since\n+\t     the PARM_DECL will be used in the function's body).  */\n+\t  for (t = DECL_ARGUMENTS (decl); t; t = TREE_CHAIN (t))\n+\t    DECL_CONTEXT (t) = decl;\n+\n+\t  /* Collect all the symbols declared in DECL.  */\n+\t  locals = pointer_set_create ();\n+\t  t = DECL_STRUCT_FUNCTION (decl)->local_decls;\n+\t  for (; t; t = TREE_CHAIN (t))\n+\t    {\n+\t      pointer_set_insert (locals, TREE_VALUE (t));\n+\n+\t      /* All the local symbols should have DECL as their\n+\t\t context.  */\n+\t      DECL_CONTEXT (TREE_VALUE (t)) = decl;\n+\t    }\n+\n+\t  /* Get rid of any decl not in local_decls.  */\n+\t  free_lang_data_in_block (decl, DECL_INITIAL (decl), locals);\n+\n+\t  pointer_set_destroy (locals);\n+\t}\n+\n+      /* DECL_SAVED_TREE holds the GENERIC representation for DECL.\n+\t At this point, it is not needed anymore.  */\n+      DECL_SAVED_TREE (decl) = NULL_TREE;\n+    }\n+  else if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      tree expr = DECL_DEBUG_EXPR (decl);\n+      if (expr\n+\t  && TREE_CODE (expr) == VAR_DECL\n+\t  && !TREE_STATIC (expr) && !DECL_EXTERNAL (expr))\n+\tSET_DECL_DEBUG_EXPR (decl, NULL_TREE);\n+\n+      if (DECL_EXTERNAL (decl))\n+\tDECL_INITIAL (decl) = NULL_TREE;\n+    }\n+  else if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      DECL_INITIAL (decl) = NULL_TREE;\n+  \n+      /* DECL_CONTEXT is overloaded as DECL_FIELD_CONTEXT for\n+\t FIELD_DECLs, which should be preserved.  Otherwise,\n+\t we shouldn't be concerned with source-level lexical\n+\t nesting beyond this point. */\n+      DECL_CONTEXT (decl) = NULL_TREE;\n+    }\n+}\n+\n+\n+/* Data used when collecting DECLs and TYPEs for language data removal.  */\n+\n+struct free_lang_data_d\n+{\n+  /* Set of traversed objects.  Used to avoid duplicate visits.  */\n+  struct pointer_set_t *pset;\n+\n+  /* Array of symbols to process with free_lang_data_in_decl.  */\n+  VEC(tree,heap) *decls;\n+\n+  /* Array of types to process with free_lang_data_in_type.  */\n+  VEC(tree,heap) *types;\n+};\n+\n+\n+/* Save all language fields needed to generate proper debug information\n+   for DECL.  This saves most fields cleared out by free_lang_data_in_decl.  */\n+\n+static void\n+save_debug_info_for_decl (tree t)\n+{\n+  /*struct saved_debug_info_d *sdi;*/\n+\n+  gcc_assert (debug_info_level > DINFO_LEVEL_TERSE && t && DECL_P (t));\n+\n+  /* FIXME.  Partial implementation for saving debug info removed.  */\n+}\n+\n+\n+/* Save all language fields needed to generate proper debug information\n+   for TYPE.  This saves most fields cleared out by free_lang_data_in_type.  */\n+\n+static void\n+save_debug_info_for_type (tree t)\n+{\n+  /*struct saved_debug_info_d *sdi;*/\n+\n+  gcc_assert (debug_info_level > DINFO_LEVEL_TERSE && t && TYPE_P (t));\n+\n+  /* FIXME.  Partial implementation for saving debug info removed.  */\n+}\n+\n+\n+/* Add type or decl T to one of the list of tree nodes that need their\n+   language data removed.  The lists are held inside FLD.  */\n+\n+static void\n+add_tree_to_fld_list (tree t, struct free_lang_data_d *fld)\n+{\n+  if (DECL_P (t))\n+    {\n+      VEC_safe_push (tree, heap, fld->decls, t);\n+      if (debug_info_level > DINFO_LEVEL_TERSE)\n+\tsave_debug_info_for_decl (t);\n+    }\n+  else if (TYPE_P (t))\n+    {\n+      VEC_safe_push (tree, heap, fld->types, t);\n+      if (debug_info_level > DINFO_LEVEL_TERSE)\n+\tsave_debug_info_for_type (t);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+\n+/* Operand callback helper for free_lang_data_in_node.  *TP is the\n+   subtree operand being considered.  */\n+\n+static tree\n+find_decls_types_r (tree *tp, int *ws ATTRIBUTE_UNUSED, void *data)\n+{\n+  tree t = *tp;\n+  struct free_lang_data_d *fld = (struct free_lang_data_d *) data;\n+\n+  if (DECL_P (t))\n+    {\n+      /* Note that walk_tree does not traverse every possible field in\n+\t decls, so we have to do our own traversals here.  */\n+      add_tree_to_fld_list (t, fld);\n+\n+      walk_tree (&DECL_NAME (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&DECL_CONTEXT (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&DECL_SIZE (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&DECL_SIZE_UNIT (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&DECL_INITIAL (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&DECL_ATTRIBUTES (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&DECL_ABSTRACT_ORIGIN (t), find_decls_types_r, fld, fld->pset);\n+\n+      if (TREE_CODE (t) == FUNCTION_DECL)\n+\t{\n+\t  walk_tree (&DECL_ARGUMENTS (t), find_decls_types_r, fld, fld->pset);\n+\t  walk_tree (&DECL_RESULT (t), find_decls_types_r, fld, fld->pset);\n+\t}\n+      else if (TREE_CODE (t) == TYPE_DECL)\n+\t{\n+\t  walk_tree (&DECL_ARGUMENT_FLD (t), find_decls_types_r, fld,\n+\t\t     fld->pset);\n+\t  walk_tree (&DECL_VINDEX (t), find_decls_types_r, fld, fld->pset);\n+\t}\n+      else if (TREE_CODE (t) == FIELD_DECL)\n+\t{\n+\t  walk_tree (&DECL_FIELD_OFFSET (t), find_decls_types_r, fld,\n+\t\t     fld->pset);\n+\t  walk_tree (&DECL_BIT_FIELD_TYPE (t), find_decls_types_r, fld,\n+\t\t     fld->pset);\n+\t  walk_tree (&DECL_QUALIFIER (t), find_decls_types_r, fld, fld->pset);\n+\t  walk_tree (&DECL_FIELD_BIT_OFFSET (t), find_decls_types_r, fld,\n+\t\t     fld->pset);\n+\t  walk_tree (&DECL_FCONTEXT (t), find_decls_types_r, fld, fld->pset);\n+\t}\n+      else if (TREE_CODE (t) == VAR_DECL)\n+\t{\n+\t  walk_tree (&DECL_SECTION_NAME (t), find_decls_types_r, fld,\n+\t\t     fld->pset);\n+\t  walk_tree (&DECL_COMDAT_GROUP (t), find_decls_types_r, fld,\n+\t\t     fld->pset);\n+\t}\n+    }\n+  else if (TYPE_P (t))\n+    {\n+      /* Note that walk_tree does not traverse every possible field in\n+\t types, so we have to do our own traversals here.  */\n+      add_tree_to_fld_list (t, fld);\n+\n+      walk_tree (&TYPE_CACHED_VALUES (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_SIZE (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_SIZE_UNIT (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_ATTRIBUTES (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_POINTER_TO (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_REFERENCE_TO (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_NAME (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_MINVAL (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_MAXVAL (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_NEXT_VARIANT (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_MAIN_VARIANT (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_CONTEXT (t), find_decls_types_r, fld, fld->pset);\n+      walk_tree (&TYPE_CANONICAL (t), find_decls_types_r, fld, fld->pset);\n+    }\n+\n+  if (TREE_TYPE (t))\n+    walk_tree (&TREE_TYPE (t), find_decls_types_r, fld, fld->pset);\n+\n+  /* Do not recurse into TREE_CHAIN to avoid blowing up the stack.  */\n+  for (tp = &TREE_CHAIN (t); *tp; tp = &TREE_CHAIN (*tp))\n+    {\n+      tree saved_chain = TREE_CHAIN (*tp);\n+      TREE_CHAIN (*tp) = NULL_TREE;\n+      walk_tree (tp, find_decls_types_r, fld, fld->pset);\n+      TREE_CHAIN (*tp) = saved_chain;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Translate all the types in LIST with the corresponding runtime\n+   types.  */\n+\n+static tree\n+get_eh_types_for_runtime (tree list)\n+{\n+  tree head, prev;\n+\n+  if (list == NULL_TREE)\n+    return NULL_TREE;\n+\n+  head = build_tree_list (0, lookup_type_for_runtime (TREE_VALUE (list)));\n+  prev = head;\n+  list = TREE_CHAIN (list);\n+  while (list)\n+    {\n+      tree n = build_tree_list (0, lookup_type_for_runtime (TREE_VALUE (list)));\n+      TREE_CHAIN (prev) = n;\n+      prev = TREE_CHAIN (prev);\n+      list = TREE_CHAIN (list);\n+    }\n+\n+  return head;\n+}\n+\n+\n+/* Find decls and types referenced in EH region R and store them in\n+   FLD->DECLS and FLD->TYPES.  */\n+\n+static void\n+find_decls_types_in_eh_region (eh_region r, struct free_lang_data_d *fld)\n+{\n+  if (r == NULL)\n+    return;\n+\n+  /* The types referenced in R must first be changed to the EH types\n+     used at runtime.  This removes references to FE types in the\n+     region.  */\n+  if (r->type == ERT_CATCH)\n+    {\n+      tree list = r->u.eh_catch.type_list;\n+      r->u.eh_catch.type_list = get_eh_types_for_runtime (list);\n+      walk_tree (&r->u.eh_catch.type_list, find_decls_types_r, fld, fld->pset);\n+    }\n+  else if (r->type == ERT_ALLOWED_EXCEPTIONS)\n+    {\n+      tree list = r->u.allowed.type_list;\n+      r->u.allowed.type_list = get_eh_types_for_runtime (list);\n+      walk_tree (&r->u.allowed.type_list, find_decls_types_r, fld, fld->pset);\n+    }\n+}\n+\n+\n+/* Find decls and types referenced in cgraph node N and store them in\n+   FLD->DECLS and FLD->TYPES.  Unlike pass_referenced_vars, this will\n+   look for *every* kind of DECL and TYPE node reachable from N,\n+   including those embedded inside types and decls (i.e,, TYPE_DECLs,\n+   NAMESPACE_DECLs, etc).  */\n+\n+static void\n+find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n+{\n+  basic_block bb;\n+  struct function *fn;\n+  tree t;\n+\n+  walk_tree (&n->decl, find_decls_types_r, fld, fld->pset);\n+\n+  if (!gimple_has_body_p (n->decl))\n+    return;\n+\n+  gcc_assert (current_function_decl == NULL_TREE && cfun == NULL);\n+\n+  fn = DECL_STRUCT_FUNCTION (n->decl);\n+\n+  /* Traverse locals. */\n+  for (t = fn->local_decls; t; t = TREE_CHAIN (t))\n+    {\n+      tree *tp = &TREE_VALUE (t);\n+      tree saved_chain = TREE_CHAIN (*tp);\n+      TREE_CHAIN (*tp) = NULL_TREE;\n+      walk_tree (tp, find_decls_types_r, fld, fld->pset);\n+      TREE_CHAIN (*tp) = saved_chain;\n+    }\n+\n+  /* Traverse EH regions in FN.  */\n+  if (fn->eh->region_array)\n+    {\n+      unsigned i;\n+      eh_region r;\n+\n+      for (i = 0; VEC_iterate (eh_region, fn->eh->region_array, i, r); i++)\n+\tfind_decls_types_in_eh_region (r, fld);\n+    }\n+\n+  /* Traverse every statement in FN.  */\n+  FOR_EACH_BB_FN (bb, fn)\n+    {\n+      gimple_stmt_iterator si;\n+      unsigned i;\n+\n+      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  gimple phi = gsi_stmt (si);\n+\n+\t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+\t    {\n+\t      tree *arg_p = gimple_phi_arg_def_ptr (phi, i);\n+\t      walk_tree (arg_p, find_decls_types_r, fld, fld->pset);\n+\t    }\n+\t}\n+\n+      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  gimple stmt = gsi_stmt (si);\n+\n+\t  for (i = 0; i < gimple_num_ops (stmt); i++)\n+\t    {\n+\t      tree *arg_p = gimple_op_ptr (stmt, i);\n+\t      walk_tree (arg_p, find_decls_types_r, fld, fld->pset);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Find decls and types referenced in varpool node N and store them in\n+   FLD->DECLS and FLD->TYPES.  Unlike pass_referenced_vars, this will\n+   look for *every* kind of DECL and TYPE node reachable from N,\n+   including those embedded inside types and decls (i.e,, TYPE_DECLs,\n+   NAMESPACE_DECLs, etc).  */\n+\n+static void\n+find_decls_types_in_var (struct varpool_node *v, struct free_lang_data_d *fld)\n+{\n+  walk_tree (&v->decl, find_decls_types_r, fld, fld->pset);\n+}\n+\n+\n+/* Free language specific information for every operand and expression\n+   in every node of the call graph.  This process operates in three stages:\n+\n+   1- Every callgraph node and varpool node is traversed looking for\n+      decls and types embedded in them.  This is a more exhaustive\n+      search than that done by find_referenced_vars, because it will\n+      also collect individual fields, decls embedded in types, etc.\n+\n+   2- All the decls found are sent to free_lang_data_in_decl.\n+\n+   3- All the types found are sent to free_lang_data_in_type.\n+\n+   The ordering between decls and types is important because\n+   free_lang_data_in_decl sets assembler names, which includes\n+   mangling.  So types cannot be freed up until assembler names have\n+   been set up.  */\n+\n+static void\n+free_lang_data_in_cgraph (void)\n+{\n+  struct cgraph_node *n;\n+  struct varpool_node *v;\n+  struct free_lang_data_d fld;\n+  tree t;\n+  unsigned i;\n+  alias_pair *p;\n+\n+  /* Initialize sets and arrays to store referenced decls and types.  */\n+  fld.pset = pointer_set_create ();\n+  fld.decls = VEC_alloc (tree, heap, 100);\n+  fld.types = VEC_alloc (tree, heap, 100);\n+\n+  /* Find decls and types in the body of every function in the callgraph.  */\n+  for (n = cgraph_nodes; n; n = n->next)\n+    find_decls_types_in_node (n, &fld);\n+\n+  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n+    walk_tree (&p->decl, find_decls_types_r, &fld, fld.pset);\n+\n+  /* Find decls and types in every varpool symbol.  */\n+  for (v = varpool_nodes_queue; v; v = v->next_needed)\n+    find_decls_types_in_var (v, &fld);\n+\n+  /* Set the assembler name on every decl found.  We need to do this\n+     now because free_lang_data_in_decl will invalidate data needed\n+     for mangling.  This breaks mangling on interdependent decls.  */\n+  for (i = 0; VEC_iterate (tree, fld.decls, i, t); i++)\n+    if (need_assembler_name_p (t))\n+      {\n+\t/* When setting DECL_ASSEMBLER_NAME, the C++ mangler may emit\n+\t   diagnostics that use input_location to show locus\n+\t   information.  The problem here is that, at this point,\n+\t   input_location is generally anchored to the end of the file\n+\t   (since the parser is long gone), so we don't have a good\n+\t   position to pin it to.\n+\n+\t   To alleviate this problem, this uses the location of T's\n+\t   declaration.  Examples of this are\n+\t   testsuite/g++.dg/template/cond2.C and\n+\t   testsuite/g++.dg/template/pr35240.C.  */\n+\tlocation_t saved_location = input_location;\n+\tinput_location = DECL_SOURCE_LOCATION (t);\n+\n+\tdecl_assembler_name (t);\n+\n+\tinput_location = saved_location;\n+      }\n+\n+  /* Traverse every decl found freeing its language data.  */\n+  for (i = 0; VEC_iterate (tree, fld.decls, i, t); i++)\n+    free_lang_data_in_decl (t);\n+\n+  /* Traverse every type found freeing its language data.  */\n+  for (i = 0; VEC_iterate (tree, fld.types, i, t); i++)\n+    free_lang_data_in_type (t);\n+\n+  pointer_set_destroy (fld.pset);\n+  VEC_free (tree, heap, fld.decls);\n+  VEC_free (tree, heap, fld.types);\n+}\n+\n+\n+/* Free resources that are used by FE but are not needed once they are done. */\n+\n+static unsigned\n+free_lang_data (void)\n+{\n+  /* Traverse the IL resetting language specific information for\n+     operands, expressions, etc.  */\n+  free_lang_data_in_cgraph ();\n+\n+  /* Create gimple variants for common types.  */\n+  ptrdiff_type_node = integer_type_node;\n+  fileptr_type_node = ptr_type_node;\n+  if (TREE_CODE (boolean_type_node) != BOOLEAN_TYPE\n+      || (TYPE_MODE (boolean_type_node)\n+\t  != mode_for_size (BOOL_TYPE_SIZE, MODE_INT, 0))\n+      || TYPE_PRECISION (boolean_type_node) != 1\n+      || !TYPE_UNSIGNED (boolean_type_node))\n+    {\n+      boolean_type_node = make_unsigned_type (BOOL_TYPE_SIZE);\n+      TREE_SET_CODE (boolean_type_node, BOOLEAN_TYPE);\n+      TYPE_MAX_VALUE (boolean_type_node) = build_int_cst (boolean_type_node, 1);\n+      TYPE_PRECISION (boolean_type_node) = 1;\n+      boolean_false_node = TYPE_MIN_VALUE (boolean_type_node);\n+      boolean_true_node = TYPE_MAX_VALUE (boolean_type_node);\n+    }\n+\n+  /* Reset some langhooks.  */\n+  lang_hooks.callgraph.analyze_expr = NULL;\n+  lang_hooks.types_compatible_p = NULL;\n+  lang_hooks.dwarf_name = lhd_dwarf_name;\n+  lang_hooks.decl_printable_name = gimple_decl_printable_name;\n+  lang_hooks.set_decl_assembler_name = lhd_set_decl_assembler_name;\n+  lang_hooks.fold_obj_type_ref = gimple_fold_obj_type_ref;\n+\n+  /* Reset diagnostic machinery.  */\n+  diagnostic_starter (global_dc) = default_diagnostic_starter;\n+  diagnostic_finalizer (global_dc) = default_diagnostic_finalizer;\n+  diagnostic_format_decoder (global_dc) = default_tree_printer;\n+\n+  return 0;\n+}\n+\n+\n+/* Gate function for free_lang_data.  */\n+\n+static bool\n+gate_free_lang_data (void)\n+{\n+  /* FIXME.  Remove after save_debug_info is working.  */\n+  return !flag_gtoggle && debug_info_level <= DINFO_LEVEL_TERSE;\n+}\n+\n+\n+struct simple_ipa_opt_pass pass_ipa_free_lang_data = \n+{\n+ {\n+  SIMPLE_IPA_PASS,\n+  NULL,\t\t\t\t\t/* name */\n+  gate_free_lang_data,\t\t\t/* gate */\n+  free_lang_data,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_IPA_FREE_LANG_DATA,\t\t/* tv_id */\n+  0,\t                                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0\t\t\t\t\t/* todo_flags_finish */\n+ }\n+};\n+\n /* Return nonzero if IDENT is a valid name for attribute ATTR,\n    or zero if not.\n \n@@ -5292,6 +6082,9 @@ tree_int_cst_compare (const_tree t1, const_tree t2)\n int\n host_integerp (const_tree t, int pos)\n {\n+  if (t == NULL_TREE)\n+    return 0;\n+\n   return (TREE_CODE (t) == INTEGER_CST\n \t  && ((TREE_INT_CST_HIGH (t) == 0\n \t       && (HOST_WIDE_INT) TREE_INT_CST_LOW (t) >= 0)"}, {"sha": "880f71d9f177e0f21ee9d000a7b7d172b5cdde66", "filename": "gcc/tree.h", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -183,6 +183,22 @@ DEF_VEC_P(tree);\n DEF_VEC_ALLOC_P(tree,gc);\n DEF_VEC_ALLOC_P(tree,heap);\n \n+/* We have to be able to tell cgraph about the needed-ness of the target\n+   of an alias.  This requires that the decl have been defined.  Aliases\n+   that precede their definition have to be queued for later processing.  */\n+\n+typedef struct GTY(()) alias_pair\n+{\n+  tree decl;\n+  tree target;\n+} alias_pair;\n+\n+/* Define gc'd vector type.  */\n+DEF_VEC_O(alias_pair);\n+DEF_VEC_ALLOC_O(alias_pair,gc);\n+\n+extern GTY(()) VEC(alias_pair,gc) * alias_pairs;\n+\n \f\n /* Classify which part of the compiler has defined a given builtin function.\n    Note that we assume below that this is no more than two bits.  */\n@@ -1259,7 +1275,7 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    This is interesting in an inline function, since it might not need\n    to be compiled separately.\n    Nonzero in a RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE or ENUMERAL_TYPE\n-   if the sdb debugging info for the type has been written.\n+   if the debugging info for the type has been written.\n    In a BLOCK node, nonzero if reorder_blocks has already seen this block.\n    In an SSA_NAME node, nonzero if the SSA_NAME occurs in an abnormal\n    PHI node.  */\n@@ -2035,6 +2051,8 @@ struct GTY(()) tree_block {\n #define TYPE_NEXT_VARIANT(NODE) (TYPE_CHECK (NODE)->type.next_variant)\n #define TYPE_MAIN_VARIANT(NODE) (TYPE_CHECK (NODE)->type.main_variant)\n #define TYPE_CONTEXT(NODE) (TYPE_CHECK (NODE)->type.context)\n+#define TYPE_MAXVAL(NODE) (TYPE_CHECK (NODE)->type.maxval)\n+#define TYPE_MINVAL(NODE) (TYPE_CHECK (NODE)->type.minval)\n \n /* Vector types need to check target flags to determine type.  */\n extern enum machine_mode vector_type_mode (const_tree);\n@@ -2439,9 +2457,9 @@ struct function;\n \n /*  For FIELD_DECLs, this is the RECORD_TYPE, UNION_TYPE, or\n     QUAL_UNION_TYPE node that the field is a member of.  For VAR_DECL,\n-    PARM_DECL, FUNCTION_DECL, LABEL_DECL, and CONST_DECL nodes, this\n-    points to either the FUNCTION_DECL for the containing function,\n-    the RECORD_TYPE or UNION_TYPE for the containing type, or\n+    PARM_DECL, FUNCTION_DECL, LABEL_DECL, RESULT_DECL, and CONST_DECL\n+    nodes, this points to either the FUNCTION_DECL for the containing\n+    function, the RECORD_TYPE or UNION_TYPE for the containing type, or\n     NULL_TREE or a TRANSLATION_UNIT_DECL if the given decl has \"file\n     scope\".  */\n #define DECL_CONTEXT(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.context)\n@@ -4889,6 +4907,7 @@ extern hashval_t iterative_hash_exprs_commutative (const_tree,\n                                                    const_tree, hashval_t);\n extern hashval_t iterative_hash_host_wide_int (HOST_WIDE_INT, hashval_t);\n extern hashval_t iterative_hash_hashval_t (hashval_t, hashval_t);\n+extern hashval_t iterative_hash_host_wide_int (HOST_WIDE_INT, hashval_t);\n extern int compare_tree_int (const_tree, unsigned HOST_WIDE_INT);\n extern int type_list_equal (const_tree, const_tree);\n extern int chain_member (const_tree, const_tree);\n@@ -5047,6 +5066,7 @@ extern void process_pending_assemble_externals (void);\n extern void finish_aliases_1 (void);\n extern void finish_aliases_2 (void);\n extern tree emutls_decl (tree);\n+extern void remove_unreachable_alias_pairs (void);\n \n /* In stmt.c */\n extern void expand_computed_goto (tree);"}, {"sha": "d7f861195ff1c3807a7d90cb1a9a569e67e500c7", "filename": "gcc/varasm.c", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4537ec0c8652889bc6decbcf5647f889d2a14733/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=4537ec0c8652889bc6decbcf5647f889d2a14733", "patch": "@@ -5369,20 +5369,7 @@ globalize_decl (tree decl)\n   targetm.asm_out.globalize_decl_name (asm_out_file, decl);\n }\n \n-/* We have to be able to tell cgraph about the needed-ness of the target\n-   of an alias.  This requires that the decl have been defined.  Aliases\n-   that precede their definition have to be queued for later processing.  */\n-\n-typedef struct GTY(()) alias_pair {\n-  tree decl;\n-  tree target;\n-} alias_pair;\n-\n-/* Define gc'd vector type.  */\n-DEF_VEC_O(alias_pair);\n-DEF_VEC_ALLOC_O(alias_pair,gc);\n-\n-static GTY(()) VEC(alias_pair,gc) *alias_pairs;\n+VEC(alias_pair,gc) *alias_pairs;\n \n /* Given an assembly name, find the decl it is associated with.  At the\n    same time, mark it needed for cgraph.  */\n@@ -5526,6 +5513,39 @@ do_assemble_alias (tree decl, tree target)\n #endif\n }\n \n+\n+/* Remove the alias pairing for functions that are no longer in the call\n+   graph.  */\n+\n+void\n+remove_unreachable_alias_pairs (void)\n+{\n+  unsigned i;\n+  alias_pair *p;\n+\n+  if (alias_pairs == NULL)\n+    return;\n+\n+  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); )\n+    {\n+      if (!DECL_EXTERNAL (p->decl))\n+\t{\n+\t  struct cgraph_node *fnode = NULL;\n+\t  struct varpool_node *vnode = NULL;\n+\t  fnode = cgraph_node_for_asm (p->target);\n+\t  vnode = (fnode == NULL) ? varpool_node_for_asm (p->target) : NULL;\n+\t  if (fnode == NULL && vnode == NULL)\n+\t    {\n+\t      VEC_unordered_remove (alias_pair, alias_pairs, i);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      i++;\n+    }\n+}\n+\n+\n /* First pass of completing pending aliases.  Make sure that cgraph knows\n    which symbols will be required.  */\n \n@@ -5547,6 +5567,11 @@ finish_aliases_1 (void)\n \t\t   p->decl, p->target);\n \t}\n       else if (DECL_EXTERNAL (target_decl)\n+ \t       /* We use local aliases for C++ thunks to force the tailcall\n+ \t\t  to bind locally.  Of course this is a hack - to keep it\n+ \t\t  working do the following (which is not strictly correct).  */\n+ \t       && (! TREE_CODE (target_decl) == FUNCTION_DECL\n+ \t\t   || ! TREE_STATIC (target_decl))\n \t       && ! lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)))\n \terror (\"%q+D aliased to external symbol %qE\",\n \t       p->decl, p->target);"}]}