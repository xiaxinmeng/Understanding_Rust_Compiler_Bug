{"sha": "0f8594eee973eb004228f171b4649cb3cb9aa536", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY4NTk0ZWVlOTczZWIwMDQyMjhmMTcxYjQ2NDljYjNjYjlhYTUzNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-09-29T03:31:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-09-29T03:31:23Z"}, "message": "re PR middle-end/17886 (variable rotate and unsigned long long rotate should be better optimized)\n\n\tPR 17886\n\t* expmed.c (expand_shift): Move logic to reverse rotation\n\tdirection when \trotating by constants ...\n\t* optabs.c (expand_binop): ... here.\n\t* config/i386/i386.md (rotrdi3): Handle 32-bit mode.\n\t(ix86_rotrdi3): New pattern.\n\t(rotldi3): Handle 32-bit mode.\n\t(ix86_rotldi3): New pattern.\n\nFrom-SVN: r104761", "tree": {"sha": "31982fcfb5affaad07795757ddfef347ec078819", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31982fcfb5affaad07795757ddfef347ec078819"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f8594eee973eb004228f171b4649cb3cb9aa536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f8594eee973eb004228f171b4649cb3cb9aa536", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f8594eee973eb004228f171b4649cb3cb9aa536", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f8594eee973eb004228f171b4649cb3cb9aa536/comments", "author": null, "committer": null, "parents": [{"sha": "4bc7cba79582442c601bf69094b351833ad61b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bc7cba79582442c601bf69094b351833ad61b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bc7cba79582442c601bf69094b351833ad61b76"}], "stats": {"total": 133, "additions": 111, "deletions": 22}, "files": [{"sha": "fdbecf6c7091f9e83786459c370ca0947f5dde55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8594eee973eb004228f171b4649cb3cb9aa536/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8594eee973eb004228f171b4649cb3cb9aa536/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f8594eee973eb004228f171b4649cb3cb9aa536", "patch": "@@ -1,3 +1,14 @@\n+2005-09-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR 17886\n+\t* expmed.c (expand_shift): Move logic to reverse rotation\n+\tdirection when \trotating by constants ...\n+\t* optabs.c (expand_binop): ... here.\n+\t* config/i386/i386.md (rotrdi3): Handle 32-bit mode.\n+\t(ix86_rotrdi3): New pattern.\n+\t(rotldi3): Handle 32-bit mode.\n+\t(ix86_rotldi3): New pattern.\n+\n 2005-09-29  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/24102"}, {"sha": "6b1beaf020412a15f73a0c8ea39179dce5160b91", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 81, "deletions": 9, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8594eee973eb004228f171b4649cb3cb9aa536/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8594eee973eb004228f171b4649cb3cb9aa536/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0f8594eee973eb004228f171b4649cb3cb9aa536", "patch": "@@ -12004,13 +12004,49 @@\n ;; Rotate instructions\n \n (define_expand \"rotldi3\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(rotate:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+  [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n+\t(rotate:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  \"ix86_expand_binary_operator (ROTATE, DImode, operands); DONE;\")\n+ \"\"\n+{\n+  if (TARGET_64BIT)\n+    {\n+      ix86_expand_binary_operator (ROTATE, DImode, operands);\n+      DONE;\n+    }\n+  if (!const_1_to_31_operand (operands[2], VOIDmode))\n+    FAIL;\n+  emit_insn (gen_ix86_rotldi3 (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n \n+;; Implement rotation using two double-precision shift instructions\n+;; and a scratch register.   \n+(define_insn_and_split \"ix86_rotldi3\"\n+ [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+       (rotate:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+                  (match_operand:QI 2 \"const_1_to_31_operand\" \"I\")))\n+  (clobber (reg:CC FLAGS_REG))\n+  (clobber (match_scratch:SI 3 \"=&r\"))]\n+ \"!TARGET_64BIT\"\n+ \"\" \n+ \"&& reload_completed\"\n+ [(set (match_dup 3) (match_dup 4))\n+  (parallel\n+   [(set (match_dup 4)\n+         (ior:SI (ashift:SI (match_dup 4) (match_dup 2))\n+                 (lshiftrt:SI (match_dup 5)\n+                              (minus:QI (const_int 32) (match_dup 2)))))\n+    (clobber (reg:CC FLAGS_REG))])\n+  (parallel\n+   [(set (match_dup 5)\n+         (ior:SI (ashift:SI (match_dup 5) (match_dup 2))\n+                 (lshiftrt:SI (match_dup 3)\n+                              (minus:QI (const_int 32) (match_dup 2)))))\n+    (clobber (reg:CC FLAGS_REG))])]\n+ \"split_di (operands, 1, operands + 4, operands + 5);\")\n+ \n (define_insn \"*rotlsi3_1_one_bit_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n \t(rotate:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n@@ -12192,12 +12228,48 @@\n    (set_attr \"mode\" \"QI\")])\n \n (define_expand \"rotrdi3\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(rotatert:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+  [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n+\t(rotate:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  \"ix86_expand_binary_operator (ROTATERT, DImode, operands); DONE;\")\n+ \"\"\n+{\n+  if (TARGET_64BIT)\n+    {\n+      ix86_expand_binary_operator (ROTATERT, DImode, operands);\n+      DONE;\n+    }\n+  if (!const_1_to_31_operand (operands[2], VOIDmode))\n+    FAIL;\n+  emit_insn (gen_ix86_rotrdi3 (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+  \n+;; Implement rotation using two double-precision shift instructions\n+;; and a scratch register.   \n+(define_insn_and_split \"ix86_rotrdi3\"\n+ [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+       (rotatert:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+                    (match_operand:QI 2 \"const_1_to_31_operand\" \"I\")))\n+  (clobber (reg:CC FLAGS_REG))\n+  (clobber (match_scratch:SI 3 \"=&r\"))]\n+ \"!TARGET_64BIT\"\n+ \"\"\n+ \"&& reload_completed\"\n+ [(set (match_dup 3) (match_dup 4))\n+  (parallel\n+   [(set (match_dup 4)\n+         (ior:SI (ashiftrt:SI (match_dup 4) (match_dup 2))\n+                 (ashift:SI (match_dup 5)\n+                            (minus:QI (const_int 32) (match_dup 2)))))\n+    (clobber (reg:CC FLAGS_REG))])\n+  (parallel\n+   [(set (match_dup 5)\n+         (ior:SI (ashiftrt:SI (match_dup 5) (match_dup 2))\n+                 (ashift:SI (match_dup 3)\n+                            (minus:QI (const_int 32) (match_dup 2)))))\n+    (clobber (reg:CC FLAGS_REG))])]\n+ \"split_di (operands, 1, operands + 4, operands + 5);\")\n \n (define_insn \"*rotrdi3_1_one_bit_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")"}, {"sha": "19d972d2ad38c8367c8503486b5d471d014c907d", "filename": "gcc/expmed.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8594eee973eb004228f171b4649cb3cb9aa536/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8594eee973eb004228f171b4649cb3cb9aa536/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0f8594eee973eb004228f171b4649cb3cb9aa536", "patch": "@@ -2237,19 +2237,6 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n \t  temp = expand_binop (mode,\n \t\t\t       left ? rotl_optab : rotr_optab,\n \t\t\t       shifted, op1, target, unsignedp, methods);\n-\n-\t  /* If we don't have the rotate, but we are rotating by a constant\n-\t     that is in range, try a rotate in the opposite direction.  */\n-\n-\t  if (temp == 0 && GET_CODE (op1) == CONST_INT\n-\t      && INTVAL (op1) > 0\n-\t      && (unsigned int) INTVAL (op1) < GET_MODE_BITSIZE (mode))\n-\t    temp = expand_binop (mode,\n-\t\t\t\t left ? rotr_optab : rotl_optab,\n-\t\t\t\t shifted,\n-\t\t\t\t GEN_INT (GET_MODE_BITSIZE (mode)\n-\t\t\t\t\t  - INTVAL (op1)),\n-\t\t\t\t target, unsignedp, methods);\n \t}\n       else if (unsignedp)\n \ttemp = expand_binop (mode,"}, {"sha": "bc859205279639f69ac1f1be276db52c83719e8d", "filename": "gcc/optabs.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8594eee973eb004228f171b4649cb3cb9aa536/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8594eee973eb004228f171b4649cb3cb9aa536/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=0f8594eee973eb004228f171b4649cb3cb9aa536", "patch": "@@ -1049,6 +1049,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t\t  || binoptab->code == ROTATERT);\n   rtx entry_last = get_last_insn ();\n   rtx last;\n+  bool first_pass_p;\n \n   class = GET_MODE_CLASS (mode);\n \n@@ -1098,6 +1099,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t}\n     }\n \n+ retry:\n+\n   /* If we can do it with a three-operand insn, do so.  */\n \n   if (methods != OPTAB_MUST_WIDEN\n@@ -1183,6 +1186,22 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \tdelete_insns_since (last);\n     }\n \n+  /* If we were trying to rotate by a constant value, and that didn't\n+     work, try rotating the other direction before falling back to\n+     shifts and bitwise-or.  */\n+  if (first_pass_p\n+      && (binoptab == rotl_optab || binoptab == rotr_optab)\n+      && class == MODE_INT\n+      && GET_CODE (op1) == CONST_INT\n+      && INTVAL (op1) > 0\n+      && (unsigned int) INTVAL (op1) < GET_MODE_BITSIZE (mode))\n+    {\n+      first_pass_p = false;\n+      op1 = GEN_INT (GET_MODE_BITSIZE (mode) - INTVAL (op1));\n+      binoptab = binoptab == rotl_optab ? rotr_optab : rotl_optab;\n+      goto retry;\n+    }\n+\n   /* If this is a multiply, see if we can do a widening operation that\n      takes operands of this mode and makes a wider mode.  */\n "}]}