{"sha": "4bf7ff7ebdbceb27859d3ffdee82535c967a97c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJmN2ZmN2ViZGJjZWIyNzg1OWQzZmZkZWU4MjUzNWM5NjdhOTdjNg==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2011-02-18T17:41:59Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2011-02-18T17:41:59Z"}, "message": "m32r.h (REG_OK_FOR_BASE_P, [...]): Remove macros.\n\n\t* config/m32r/m32r.h (REG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P,\n\tRTX_OK_FOR_BASE_P, RTX_OK_FOR_OFFSET_P, LEGITIMATE_OFFSET_ADDRESS_P,\n\tLEGITIMATE_LO_SUM_ADDRESS_P, LOAD_POSTINC_P, STORE_PREINC_PREDEC_P,\n\tGO_IF_LEGITIMATE_ADDRESS): Remove macros.\n\t* config/m32r/m32r.c (TARGET_LEGITIMATE_ADDRESS_P): Define.\n\t(m32r_rtx_ok_for_base_p, m32r_rtx_ok_for_offset_p,\n\tm32r_legitimate_offset_addres_p, m32r_legitimate_lo_sum_addres_p,\n\tm32r_load_postinc_p, m32r_store_preinc_predec_p,\n\tm32r_legitimate_address_p): New functions.\n\t* config/m32r/constraints.md (constraint \"S\"): Don't use\n\tSTORE_PREINC_PREDEC_P.\n\t(constraint \"U\"): Don't use LOAD_POSTINC_P.\n\nFrom-SVN: r170278", "tree": {"sha": "cc4a50e396c1ab32555eef6fdcf1fd9652b7380f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc4a50e396c1ab32555eef6fdcf1fd9652b7380f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6/comments", "author": null, "committer": null, "parents": [{"sha": "7efcf910eeb14928a4230e835a126784e9e196b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7efcf910eeb14928a4230e835a126784e9e196b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7efcf910eeb14928a4230e835a126784e9e196b0"}], "stats": {"total": 230, "additions": 133, "deletions": 97}, "files": [{"sha": "a6c34f4facdc552e99c26c9f89cee831936f8305", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bf7ff7ebdbceb27859d3ffdee82535c967a97c6", "patch": "@@ -1,3 +1,18 @@\n+2011-02-18  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/m32r/m32r.h (REG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P,\n+\tRTX_OK_FOR_BASE_P, RTX_OK_FOR_OFFSET_P, LEGITIMATE_OFFSET_ADDRESS_P,\n+\tLEGITIMATE_LO_SUM_ADDRESS_P, LOAD_POSTINC_P, STORE_PREINC_PREDEC_P,\n+\tGO_IF_LEGITIMATE_ADDRESS): Remove macros.\n+\t* config/m32r/m32r.c (TARGET_LEGITIMATE_ADDRESS_P): Define.\n+\t(m32r_rtx_ok_for_base_p, m32r_rtx_ok_for_offset_p,\n+\tm32r_legitimate_offset_addres_p, m32r_legitimate_lo_sum_addres_p,\n+\tm32r_load_postinc_p, m32r_store_preinc_predec_p,\n+\tm32r_legitimate_address_p): New functions.\n+\t* config/m32r/constraints.md (constraint \"S\"): Don't use\n+\tSTORE_PREINC_PREDEC_P.\n+\t(constraint \"U\"): Don't use LOAD_POSTINC_P.\n+\n 2011-02-18  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \tPR rtl-optimization/46178"}, {"sha": "350d48407d6ef5c6da43bbcc3034ec70ae73708f", "filename": "gcc/config/m32r/constraints.md", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6/gcc%2Fconfig%2Fm32r%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6/gcc%2Fconfig%2Fm32r%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fconstraints.md?ref=4bf7ff7ebdbceb27859d3ffdee82535c967a97c6", "patch": "@@ -1,5 +1,5 @@\n ;; Constraint definitions for Renesas M32R cpu for GNU C compiler\n-;; Copyright (C) 2007 Free Software Foundation, Inc.\n+;; Copyright (C) 2007, 2011 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -118,7 +118,12 @@\n (define_constraint \"S\"\n   \"A store with pre {inc,dec}rement.\"\n   (and (match_code \"mem\")\n-       (match_test \"STORE_PREINC_PREDEC_P (GET_MODE (op), XEXP (op, 0))\")))\n+       (match_test \"mode == SImode || mode == SFmode\")\n+       (match_code \"pre_inc,pre_dec\" \"0\")\n+       (match_code \"reg\" \"00\")\n+       (match_test \"GPR_P (REGNO (XEXP (XEXP (op, 0), 0)))\n+\t\t    || REGNO (XEXP (XEXP (op, 0), 0)) == ARG_POINTER_REGNUM\n+\t\t    || ! HARD_REGISTER_P (XEXP (XEXP (op, 0), 0))\")))\n \n (define_constraint \"T\"\n   \"An indirect of a pointer.\"\n@@ -128,7 +133,12 @@\n (define_constraint \"U\"\n   \"A load with post increment.\"\n   (and (match_code \"mem\")\n-       (match_test \"LOAD_POSTINC_P (GET_MODE (op), XEXP (op, 0))\")))\n+       (match_test \"mode == SImode || mode == SFmode\")\n+       (match_code \"post_inc\" \"0\")\n+       (match_code \"reg\" \"00\")\n+       (match_test \"GPR_P (REGNO (XEXP (XEXP (op, 0), 0)))\n+\t\t    || REGNO (XEXP (XEXP (op, 0), 0)) == ARG_POINTER_REGNUM\n+\t\t    || ! HARD_REGISTER_P (XEXP (XEXP (op, 0), 0))\")))\n \n (define_constraint \"W\"\n   \"zero immediate.\""}, {"sha": "444f16efbbea939c58691c9d8c1165cb5a99a4ee", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=4bf7ff7ebdbceb27859d3ffdee82535c967a97c6", "patch": "@@ -66,6 +66,7 @@ static void  m32r_option_override (void);\n static void  init_reg_tables (void);\n static void  block_move_call (rtx, rtx, rtx);\n static int   m32r_is_insn (rtx);\n+static bool  m32r_legitimate_address_p (enum machine_mode, rtx, bool);\n static rtx   m32r_legitimize_address (rtx, rtx, enum machine_mode);\n static bool  m32r_mode_dependent_address_p (const_rtx);\n static tree  m32r_handle_model_attribute (tree *, tree, tree, int, bool *);\n@@ -124,6 +125,8 @@ static const struct default_options m32r_option_optimization_table[] =\n #undef  TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE m32r_attribute_table\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P m32r_legitimate_address_p\n #undef TARGET_LEGITIMIZE_ADDRESS\n #define TARGET_LEGITIMIZE_ADDRESS m32r_legitimize_address\n #undef TARGET_MODE_DEPENDENT_ADDRESS_P\n@@ -2844,6 +2847,107 @@ m32r_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \t\t       GEN_INT (3), SImode);\n }\n \n+/* True if X is a reg that can be used as a base reg.  */\n+\n+static bool\n+m32r_rtx_ok_for_base_p (const_rtx x, bool strict)\n+{\n+  if (! REG_P (x))\n+    return false;\n+\n+  if (strict)\n+    {\n+      if (GPR_P (REGNO (x)))\n+\treturn true;\n+    }\n+  else\n+    {\n+      if (GPR_P (REGNO (x))\n+\t  || REGNO (x) == ARG_POINTER_REGNUM\n+\t  || ! HARD_REGISTER_P (x))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+static inline bool\n+m32r_rtx_ok_for_offset_p (const_rtx x)\n+{\n+  return (CONST_INT_P (x) && INT16_P (INTVAL (x)));\n+}\n+\n+static inline bool\n+m32r_legitimate_offset_addres_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t const_rtx x, bool strict)\n+{\n+  if (GET_CODE (x) == PLUS\n+      && m32r_rtx_ok_for_base_p (XEXP (x, 0), strict)\n+      && m32r_rtx_ok_for_offset_p (XEXP (x, 1)))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* For LO_SUM addresses, do not allow them if the MODE is > 1 word,\n+   since more than one instruction will be required.  */\n+\n+static inline bool\n+m32r_legitimate_lo_sum_addres_p (enum machine_mode mode, const_rtx x,\n+\t\t\t\t bool strict)\n+{\n+  if (GET_CODE (x) == LO_SUM\n+      && (mode != BLKmode && GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n+      && m32r_rtx_ok_for_base_p (XEXP (x, 0), strict)\n+      && CONSTANT_P (XEXP (x, 1)))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Is this a load and increment operation.  */\n+\n+static inline bool\n+m32r_load_postinc_p (enum machine_mode mode, const_rtx x, bool strict)\n+{\n+  if ((mode == SImode || mode == SFmode)\n+      && GET_CODE (x) == POST_INC\n+      && REG_P (XEXP (x, 0))\n+      && m32r_rtx_ok_for_base_p (XEXP (x, 0), strict))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Is this an increment/decrement and store operation.  */\n+\n+static inline bool\n+m32r_store_preinc_predec_p (enum machine_mode mode, const_rtx x, bool strict)\n+{\n+  if ((mode == SImode || mode == SFmode)\n+      && (GET_CODE (x) == PRE_INC || GET_CODE (x) == PRE_DEC)\n+      && REG_P (XEXP (x, 0))                           \\\n+      && m32r_rtx_ok_for_base_p (XEXP (x, 0), strict))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Implement  TARGET_LEGITIMATE_ADDRESS_P.  */\n+\n+static bool\n+m32r_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+{\n+  if (m32r_rtx_ok_for_base_p (x, strict)\n+      || m32r_legitimate_offset_addres_p (mode, x, strict)\n+      || m32r_legitimate_lo_sum_addres_p (mode, x, strict)\n+      || m32r_load_postinc_p (mode, x, strict)\n+      || m32r_store_preinc_predec_p (mode, x, strict))\n+    return true;\n+\n+  return false;\n+}\n+\n static void\n m32r_conditional_register_usage (void)\n {"}, {"sha": "ef24ec1090c0351494ab7583117cdd1f8fb429eb", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 1, "deletions": 94, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf7ff7ebdbceb27859d3ffdee82535c967a97c6/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=4bf7ff7ebdbceb27859d3ffdee82535c967a97c6", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, Renesas M32R cpu.\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -858,99 +858,6 @@ L2:     .word STATIC\n       && (GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF || GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF) \\\n       && CONST_INT_P (XEXP (XEXP (X, 0), 1))\t\t\t\\\n       && (unsigned HOST_WIDE_INT) INTVAL (XEXP (XEXP (X, 0), 1)) > 32767))\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifdef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) GPR_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X)\t\t\\\n-  (GPR_P (REGNO (X))\t\t\t\\\n-   || (REGNO (X)) == ARG_POINTER_REGNUM\t\\\n-   || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n-\n-#endif\n-\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.  */\n-\n-/* Local to this file.  */\n-#define RTX_OK_FOR_BASE_P(X) (REG_P (X) && REG_OK_FOR_BASE_P (X))\n-\n-/* Local to this file.  */\n-#define RTX_OK_FOR_OFFSET_P(X) \\\n-  (CONST_INT_P (X) && INT16_P (INTVAL (X)))\n-\n-/* Local to this file.  */\n-#define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X)\t\t\t\\\n-  (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-   && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-   && RTX_OK_FOR_OFFSET_P (XEXP (X, 1)))\n-\n-/* Local to this file.  */\n-/* For LO_SUM addresses, do not allow them if the MODE is > 1 word,\n-   since more than one instruction will be required.  */\n-#define LEGITIMATE_LO_SUM_ADDRESS_P(MODE, X)\t\t\t\\\n-  (GET_CODE (X) == LO_SUM\t\t\t\t\t\\\n-   && (MODE != BLKmode && GET_MODE_SIZE (MODE) <= UNITS_PER_WORD)\\\n-   && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-   && CONSTANT_P (XEXP (X, 1)))\n-\n-/* Local to this file.  */\n-/* Is this a load and increment operation.  */\n-#define LOAD_POSTINC_P(MODE, X)\t\t\t\t\t\\\n-  (((MODE) == SImode || (MODE) == SFmode)\t\t\t\\\n-   && GET_CODE (X) == POST_INC\t\t\t\t\t\\\n-   && REG_P (XEXP (X, 0))\t\t\t\t\\\n-   && RTX_OK_FOR_BASE_P (XEXP (X, 0)))\n-\n-/* Local to this file.  */\n-/* Is this an increment/decrement and store operation.  */\n-#define STORE_PREINC_PREDEC_P(MODE, X)\t\t\t\t\\\n-  (((MODE) == SImode || (MODE) == SFmode)\t\t\t\\\n-   && (GET_CODE (X) == PRE_INC || GET_CODE (X) == PRE_DEC)\t\\\n-   && REG_P (XEXP (X, 0))\t\t\t\t\\\n-   && RTX_OK_FOR_BASE_P (XEXP (X, 0)))\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\\\n-      if (LEGITIMATE_OFFSET_ADDRESS_P ((MODE), (X)))\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\\\n-      if (LEGITIMATE_LO_SUM_ADDRESS_P ((MODE), (X)))\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\\\n-      if (LOAD_POSTINC_P ((MODE), (X)))\t\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\\\n-      if (STORE_PREINC_PREDEC_P ((MODE), (X)))\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n \f\n /* Condition code usage.  */\n "}]}