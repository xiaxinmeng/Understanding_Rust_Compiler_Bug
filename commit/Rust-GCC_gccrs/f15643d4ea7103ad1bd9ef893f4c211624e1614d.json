{"sha": "f15643d4ea7103ad1bd9ef893f4c211624e1614d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE1NjQzZDRlYTcxMDNhZDFiZDllZjg5M2Y0YzIxMTYyNGUxNjE0ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-13T17:05:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-13T17:05:16Z"}, "message": "Turn SECONDARY_MEMORY_NEEDED into a hook\n\nSince the patch is going through all the definitions anyway, it seemed\nlike a good opportunity to put the mode argument first, to match the\norder for register_move_cost.\n\n2017-09-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (secondary_memory_needed): New hook.\n\t(secondary_reload): Refer to TARGET_SECONDARY_MEMORY_NEEDED\n\tinstead of SECONDARY_MEMORY_NEEDED.\n\t(secondary_memory_needed_mode): Likewise.\n\t* hooks.h (hook_bool_mode_reg_class_t_reg_class_t_false): Declare.\n\t* hooks.c (hook_bool_mode_reg_class_t_reg_class_t_false): New function.\n\t* doc/tm.texi.in (SECONDARY_MEMORY_NEEDED): Replace with...\n\t(TARGET_SECONDARY_MEMORY_NEEDED): ...this.\n\t(SECONDARY_MEMORY_NEEDED_RTX): Update reference accordingly.\n\t* doc/tm.texi: Regenerate.\n\t* config/alpha/alpha.h (SECONDARY_MEMORY_NEEDED): Delete.\n\t* config/alpha/alpha.c (alpha_secondary_memory_needed): New function.\n\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n\t* config/i386/i386.h (SECONDARY_MEMORY_NEEDED): Delete.\n\t* config/i386/i386-protos.h (ix86_secondary_memory_needed): Delete.\n\t* config/i386/i386.c (inline_secondary_memory_needed): Put the\n\tmode argument first and change the reg_class arguments to reg_class_t.\n\t(ix86_secondary_memory_needed): Likewise.  Remove the strict parameter.\n\tMake static.  Update the call to inline_secondary_memory_needed.\n\t(ix86_register_move_cost): Update the call to\n\tinline_secondary_memory_needed.\n\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n\t* config/ia64/ia64.h (SECONDARY_MEMORY_NEEDED): Delete commented-out\n\tdefinition.\n\t* config/ia64/ia64.c (spill_xfmode_rfmode_operand): Refer to\n\tTARGET_SECONDARY_MEMORY_NEEDED rather than SECONDARY_MEMORY_NEEDED\n\tin comment.\n\t* config/mips/mips.h (SECONDARY_MEMORY_NEEDED): Delete.\n\t* config/mips/mips-protos.h (mips_secondary_memory_needed): Delete.\n\t* config/mips/mips.c (mips_secondary_memory_needed): Make static\n\tand match hook interface.  Add comment from mips.h.\n\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n\t* config/mmix/mmix.md (truncdfsf2): Refer to\n\tTARGET_SECONDARY_MEMORY_NEEDED rather than SECONDARY_MEMORY_NEEDED\n\tin comment.\n\t* config/pa/pa-64.h (SECONDARY_MEMORY_NEEDED): Rename to...\n\t(PA_SECONDARY_MEMORY_NEEDED): ...this, and put the mode argument first.\n\t* config/pa/pa.c (TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n\t(pa_secondary_memory_needed): New function.\n\t* config/pdp11/pdp11.h (SECONDARY_MEMORY_NEEDED): Delete.\n\t* config/pdp11/pdp11-protos.h (pdp11_secondary_memory_needed): Delete.\n\t* config/pdp11/pdp11.c (TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n\t(pdp11_secondary_memory_needed): Make static and match hook interface.\n\t* config/powerpcspe/powerpcspe.h (SECONDARY_MEMORY_NEEDED): Delete.\n\t* config/powerpcspe/powerpcspe-protos.h\n\t(rs6000_secondary_memory_needed_ptr): Delete.\n\t* config/powerpcspe/powerpcspe.c (rs6000_secondary_memory_needed_ptr):\n\tDelete.\n\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n\t(rs6000_option_override_internal): Assign to\n\ttargetm.secondary_memory_needed rather than\n\trs6000_secondary_memory_needed_ptr.\n\t(rs6000_secondary_memory_needed): Match hook interface.\n\t(rs6000_debug_secondary_memory_needed): Likewise.\n\t* config/riscv/riscv.h (SECONDARY_MEMORY_NEEDED): Delete.\n\t* config/riscv/riscv.c (riscv_secondary_memory_needed): New function.\n\t(riscv_register_move_cost): Use it instead of SECONDARY_MEMORY_NEEDED.\n\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n\t* config/rs6000/rs6000.h (SECONDARY_MEMORY_NEEDED): Delete.\n\t* config/rs6000/rs6000-protos.h (rs6000_secondary_memory_needed_ptr):\n\tDelete.\n\t* config/rs6000/rs6000.c (rs6000_secondary_memory_needed_ptr): Delete.\n\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n\t(rs6000_option_override_internal): Assign to\n\ttargetm.secondary_memory_needed rather than\n\trs6000_secondary_memory_needed_ptr.\n\t(rs6000_secondary_memory_needed): Match hook interface.\n\t(rs6000_debug_secondary_memory_needed): Likewise.\n\t* config/s390/s390.h (SECONDARY_MEMORY_NEEDED): Delete.\n\t* config/s390/s390.c (s390_secondary_memory_needed): New function.\n\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n\t* config/sparc/sparc.h (SECONDARY_MEMORY_NEEDED): Delete.\n\t* config/sparc/sparc.c (TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n\t(sparc_secondary_memory_needed): New function.\n\t* lra-constraints.c (check_and_process_move): Refer to\n\tTARGET_SECONDARY_MEMORY_NEEDED rather than SECONDARY_MEMORY_NEEDED\n\tin comment.\n\t(curr_insn_transform): Likewise.\n\t(process_alt_operands): Use targetm.secondary_memory_needed\n\tinstead of TARGET_SECONDARY_MEMORY_NEEDED.\n\t(check_secondary_memory_needed_p): Likewise.\n\t(choose_split_class): Likewise.\n\t* reload.c: Unconditionally include code that was previously\n\tconditional on SECONDARY_MEMORY_NEEDED.\n\t(push_secondary_reload): Use targetm.secondary_memory_needed\n\tinstead of TARGET_SECONDARY_MEMORY_NEEDED.\n\t(push_reload): Likewise.\n\t* reload1.c: Unconditionally include code that was previously\n\tconditional on SECONDARY_MEMORY_NEEDED.\n\t(choose_reload_regs): Use targetm.secondary_memory_needed\n\tinstead of TARGET_SECONDARY_MEMORY_NEEDED.\n\t(gen_reload): Likewise.\n\t* system.h (SECONDARY_MEMORY_NEEDED): Poison.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r252461", "tree": {"sha": "794d8c949f2b13fdb15f7c1b2d4cacb4b7a6f2e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/794d8c949f2b13fdb15f7c1b2d4cacb4b7a6f2e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f15643d4ea7103ad1bd9ef893f4c211624e1614d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15643d4ea7103ad1bd9ef893f4c211624e1614d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f15643d4ea7103ad1bd9ef893f4c211624e1614d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15643d4ea7103ad1bd9ef893f4c211624e1614d/comments", "author": null, "committer": null, "parents": [{"sha": "94e23f53d700769c453d31881c089d06cde823dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e23f53d700769c453d31881c089d06cde823dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94e23f53d700769c453d31881c089d06cde823dd"}], "stats": {"total": 604, "additions": 333, "deletions": 271}, "files": [{"sha": "7bba8a938faa14660a1f629e141a7260e54c63db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -1,3 +1,101 @@\n+2017-09-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (secondary_memory_needed): New hook.\n+\t(secondary_reload): Refer to TARGET_SECONDARY_MEMORY_NEEDED\n+\tinstead of SECONDARY_MEMORY_NEEDED.\n+\t(secondary_memory_needed_mode): Likewise.\n+\t* hooks.h (hook_bool_mode_reg_class_t_reg_class_t_false): Declare.\n+\t* hooks.c (hook_bool_mode_reg_class_t_reg_class_t_false): New function.\n+\t* doc/tm.texi.in (SECONDARY_MEMORY_NEEDED): Replace with...\n+\t(TARGET_SECONDARY_MEMORY_NEEDED): ...this.\n+\t(SECONDARY_MEMORY_NEEDED_RTX): Update reference accordingly.\n+\t* doc/tm.texi: Regenerate.\n+\t* config/alpha/alpha.h (SECONDARY_MEMORY_NEEDED): Delete.\n+\t* config/alpha/alpha.c (alpha_secondary_memory_needed): New function.\n+\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n+\t* config/i386/i386.h (SECONDARY_MEMORY_NEEDED): Delete.\n+\t* config/i386/i386-protos.h (ix86_secondary_memory_needed): Delete.\n+\t* config/i386/i386.c (inline_secondary_memory_needed): Put the\n+\tmode argument first and change the reg_class arguments to reg_class_t.\n+\t(ix86_secondary_memory_needed): Likewise.  Remove the strict parameter.\n+\tMake static.  Update the call to inline_secondary_memory_needed.\n+\t(ix86_register_move_cost): Update the call to\n+\tinline_secondary_memory_needed.\n+\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n+\t* config/ia64/ia64.h (SECONDARY_MEMORY_NEEDED): Delete commented-out\n+\tdefinition.\n+\t* config/ia64/ia64.c (spill_xfmode_rfmode_operand): Refer to\n+\tTARGET_SECONDARY_MEMORY_NEEDED rather than SECONDARY_MEMORY_NEEDED\n+\tin comment.\n+\t* config/mips/mips.h (SECONDARY_MEMORY_NEEDED): Delete.\n+\t* config/mips/mips-protos.h (mips_secondary_memory_needed): Delete.\n+\t* config/mips/mips.c (mips_secondary_memory_needed): Make static\n+\tand match hook interface.  Add comment from mips.h.\n+\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n+\t* config/mmix/mmix.md (truncdfsf2): Refer to\n+\tTARGET_SECONDARY_MEMORY_NEEDED rather than SECONDARY_MEMORY_NEEDED\n+\tin comment.\n+\t* config/pa/pa-64.h (SECONDARY_MEMORY_NEEDED): Rename to...\n+\t(PA_SECONDARY_MEMORY_NEEDED): ...this, and put the mode argument first.\n+\t* config/pa/pa.c (TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n+\t(pa_secondary_memory_needed): New function.\n+\t* config/pdp11/pdp11.h (SECONDARY_MEMORY_NEEDED): Delete.\n+\t* config/pdp11/pdp11-protos.h (pdp11_secondary_memory_needed): Delete.\n+\t* config/pdp11/pdp11.c (TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n+\t(pdp11_secondary_memory_needed): Make static and match hook interface.\n+\t* config/powerpcspe/powerpcspe.h (SECONDARY_MEMORY_NEEDED): Delete.\n+\t* config/powerpcspe/powerpcspe-protos.h\n+\t(rs6000_secondary_memory_needed_ptr): Delete.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_secondary_memory_needed_ptr):\n+\tDelete.\n+\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n+\t(rs6000_option_override_internal): Assign to\n+\ttargetm.secondary_memory_needed rather than\n+\trs6000_secondary_memory_needed_ptr.\n+\t(rs6000_secondary_memory_needed): Match hook interface.\n+\t(rs6000_debug_secondary_memory_needed): Likewise.\n+\t* config/riscv/riscv.h (SECONDARY_MEMORY_NEEDED): Delete.\n+\t* config/riscv/riscv.c (riscv_secondary_memory_needed): New function.\n+\t(riscv_register_move_cost): Use it instead of SECONDARY_MEMORY_NEEDED.\n+\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n+\t* config/rs6000/rs6000.h (SECONDARY_MEMORY_NEEDED): Delete.\n+\t* config/rs6000/rs6000-protos.h (rs6000_secondary_memory_needed_ptr):\n+\tDelete.\n+\t* config/rs6000/rs6000.c (rs6000_secondary_memory_needed_ptr): Delete.\n+\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n+\t(rs6000_option_override_internal): Assign to\n+\ttargetm.secondary_memory_needed rather than\n+\trs6000_secondary_memory_needed_ptr.\n+\t(rs6000_secondary_memory_needed): Match hook interface.\n+\t(rs6000_debug_secondary_memory_needed): Likewise.\n+\t* config/s390/s390.h (SECONDARY_MEMORY_NEEDED): Delete.\n+\t* config/s390/s390.c (s390_secondary_memory_needed): New function.\n+\t(TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n+\t* config/sparc/sparc.h (SECONDARY_MEMORY_NEEDED): Delete.\n+\t* config/sparc/sparc.c (TARGET_SECONDARY_MEMORY_NEEDED): Redefine.\n+\t(sparc_secondary_memory_needed): New function.\n+\t* lra-constraints.c (check_and_process_move): Refer to\n+\tTARGET_SECONDARY_MEMORY_NEEDED rather than SECONDARY_MEMORY_NEEDED\n+\tin comment.\n+\t(curr_insn_transform): Likewise.\n+\t(process_alt_operands): Use targetm.secondary_memory_needed\n+\tinstead of TARGET_SECONDARY_MEMORY_NEEDED.\n+\t(check_secondary_memory_needed_p): Likewise.\n+\t(choose_split_class): Likewise.\n+\t* reload.c: Unconditionally include code that was previously\n+\tconditional on SECONDARY_MEMORY_NEEDED.\n+\t(push_secondary_reload): Use targetm.secondary_memory_needed\n+\tinstead of TARGET_SECONDARY_MEMORY_NEEDED.\n+\t(push_reload): Likewise.\n+\t* reload1.c: Unconditionally include code that was previously\n+\tconditional on SECONDARY_MEMORY_NEEDED.\n+\t(choose_reload_regs): Use targetm.secondary_memory_needed\n+\tinstead of TARGET_SECONDARY_MEMORY_NEEDED.\n+\t(gen_reload): Likewise.\n+\t* system.h (SECONDARY_MEMORY_NEEDED): Poison.\n+\n 2017-09-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "bb81f8e5f61d18a4aa0cc1d2b6562215133a0fcb", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -1689,6 +1689,20 @@ alpha_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   return NO_REGS;\n }\n \n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED.\n+\n+   If we are copying between general and FP registers, we need a memory\n+   location unless the FIX extension is available.  */\n+\n+static bool\n+alpha_secondary_memory_needed (machine_mode, reg_class_t class1,\n+\t\t\t       reg_class_t class2)\n+{\n+  return (!TARGET_FIX\n+\t  && ((class1 == FLOAT_REGS && class2 != FLOAT_REGS)\n+\t      || (class2 == FLOAT_REGS && class1 != FLOAT_REGS)));\n+}\n+\n /* Implement TARGET_SECONDARY_MEMORY_NEEDED_MODE.  If MODE is\n    floating-point, use it.  Otherwise, widen to a word like the default.\n    This is needed because we always store integers in FP registers in\n@@ -10077,6 +10091,8 @@ alpha_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD alpha_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED\n+#define TARGET_SECONDARY_MEMORY_NEEDED alpha_secondary_memory_needed\n #undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n #define TARGET_SECONDARY_MEMORY_NEEDED_MODE alpha_secondary_memory_needed_mode\n "}, {"sha": "e42b64985e8692c93e3c205a55fafa20768f07af", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -479,13 +479,6 @@ enum reg_class {\n \n #define PREFERRED_RELOAD_CLASS  alpha_preferred_reload_class\n \n-/* If we are copying between general and FP registers, we need a memory\n-   location unless the FIX extension is available.  */\n-\n-#define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE) \\\n- (! TARGET_FIX && (((CLASS1) == FLOAT_REGS && (CLASS2) != FLOAT_REGS) \\\n-                   || ((CLASS2) == FLOAT_REGS && (CLASS1) != FLOAT_REGS)))\n-\n /* Return the class of registers that cannot change mode from FROM to TO.  */\n \n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\\"}, {"sha": "ecb0a4c9682e7978df09baae169080b9eda8fc9e", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -167,8 +167,6 @@ extern int ix86_reg_parm_stack_space (const_tree);\n \n extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,\n \t\t\t\t  rtx, rtx, rtx);\n-extern bool ix86_secondary_memory_needed (enum reg_class, enum reg_class,\n-\t\t\t\t\t  machine_mode, int);\n extern bool ix86_cannot_change_mode_class (machine_mode,\n \t\t\t\t\t   machine_mode, enum reg_class);\n "}, {"sha": "b2b02acc58ad1387f8d0128d3e2cc36136d7d656", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -41102,8 +41102,8 @@ ix86_class_likely_spilled_p (reg_class_t rclass)\n    To optimize register_move_cost performance, define inline variant.  */\n \n static inline bool\n-inline_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n-\t\t\t\tmachine_mode mode, int strict)\n+inline_secondary_memory_needed (machine_mode mode, reg_class_t class1,\n+\t\t\t\treg_class_t class2, int strict)\n {\n   if (lra_in_progress && (class1 == NO_REGS || class2 == NO_REGS))\n     return false;\n@@ -41155,11 +41155,13 @@ inline_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n   return false;\n }\n \n-bool\n-ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n-\t\t\t      machine_mode mode, int strict)\n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED.  */\n+\n+static bool\n+ix86_secondary_memory_needed (machine_mode mode, reg_class_t class1,\n+\t\t\t      reg_class_t class2)\n {\n-  return inline_secondary_memory_needed (class1, class2, mode, strict);\n+  return inline_secondary_memory_needed (mode, class1, class2, true);\n }\n \n /* Implement TARGET_SECONDARY_MEMORY_NEEDED_MODE.\n@@ -41380,7 +41382,7 @@ ix86_register_move_cost (machine_mode mode, reg_class_t class1_i,\n      by load.  In order to avoid bad register allocation choices, we need\n      for this to be *at least* as high as the symmetric MEMORY_MOVE_COST.  */\n \n-  if (inline_secondary_memory_needed (class1, class2, mode, 0))\n+  if (inline_secondary_memory_needed (mode, class1, class2, false))\n     {\n       int cost = 1;\n \n@@ -53220,6 +53222,8 @@ ix86_run_selftests (void)\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD ix86_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED\n+#define TARGET_SECONDARY_MEMORY_NEEDED ix86_secondary_memory_needed\n #undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n #define TARGET_SECONDARY_MEMORY_NEEDED_MODE ix86_secondary_memory_needed_mode\n "}, {"sha": "cbd6a111f57054b1ca3bcad7b06c411405de1306", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -1519,11 +1519,6 @@ enum reg_class\n #define INDEX_REG_CLASS INDEX_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n \n-/* If we are copying between general and FP registers, we need a memory\n-   location. The same is true for SSE and MMX registers.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n-  ix86_secondary_memory_needed ((CLASS1), (CLASS2), (MODE), 1)\n-\n /* Return a class of registers that cannot change FROM mode to TO mode.  */\n \n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\"}, {"sha": "b9b85a019258cb6b86072cf27dab109026b7eb7a", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -1626,8 +1626,8 @@ ia64_split_tmode_move (rtx operands[])\n \n /* ??? Fixing GR->FR XFmode moves during reload is hard.  You need to go\n    through memory plus an extra GR scratch register.  Except that you can\n-   either get the first from SECONDARY_MEMORY_NEEDED or the second from\n-   SECONDARY_RELOAD_CLASS, but not both.\n+   either get the first from TARGET_SECONDARY_MEMORY_NEEDED or the second\n+   from SECONDARY_RELOAD_CLASS, but not both.\n \n    We got into problems in the first place by allowing a construct like\n    (subreg:XF (reg:TI)), which we got from a union containing a long double."}, {"sha": "7eefa444a21a89e618b3d3100c3b8aa76557e68d", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -767,24 +767,6 @@ enum reg_class\n #define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) \\\n  ia64_secondary_reload_class (CLASS, MODE, X)\n \n-/* Certain machines have the property that some registers cannot be copied to\n-   some other registers without using memory.  Define this macro on those\n-   machines to be a C expression that is nonzero if objects of mode M in\n-   registers of CLASS1 can only be copied to registers of class CLASS2 by\n-   storing a register of CLASS1 into memory and loading that memory location\n-   into a register of CLASS2.  */\n-\n-#if 0\n-/* ??? May need this, but since we've disallowed XFmode in GR_REGS,\n-   I'm not quite sure how it could be invoked.  The normal problems\n-   with unions should be solved with the addressof fiddling done by\n-   movxf and friends.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n-  (((MODE) == XFmode || (MODE) == XCmode)\t\t\t\t\\\n-   && (((CLASS1) == GR_REGS && (CLASS2) == FR_REGS)\t\t\t\\\n-       || ((CLASS1) == FR_REGS && (CLASS2) == GR_REGS)))\n-#endif\n-\n /* A C expression for the maximum number of consecutive registers of\n    class CLASS needed to hold a value of mode MODE.\n    This is closely related to TARGET_HARD_REGNO_NREGS.  */"}, {"sha": "d487f6f93ee41c6b149a4bfe615f2aa11422a979", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -294,8 +294,6 @@ extern bool mips_const_vector_bitimm_set_p (rtx, machine_mode);\n extern bool mips_const_vector_bitimm_clr_p (rtx, machine_mode);\n extern rtx mips_msa_vec_parallel_const_half (machine_mode, bool);\n extern rtx mips_gen_const_int_vector (machine_mode, HOST_WIDE_INT);\n-extern bool mips_secondary_memory_needed (enum reg_class, enum reg_class,\n-\t\t\t\t\t  machine_mode);\n extern bool mips_cannot_change_mode_class (machine_mode,\n \t\t\t\t\t   machine_mode, enum reg_class);\n extern bool mips_dangerous_for_la25_p (rtx);"}, {"sha": "20051a7e291b36a3b83e2e51d06237ea56713bc2", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -13201,11 +13201,22 @@ mips_memory_move_cost (machine_mode mode, reg_class_t rclass, bool in)\n \t  + memory_move_secondary_cost (mode, rclass, in));\n } \n \n-/* Implement SECONDARY_MEMORY_NEEDED.  */\n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED.\n+\n+   When targeting the o32 FPXX ABI, all moves with a length of doubleword\n+   or greater must be performed by FR-mode-aware instructions.\n+   This can be achieved using MFHC1/MTHC1 when these instructions are\n+   available but otherwise moves must go via memory.\n+   For the o32 FP64A ABI, all odd-numbered moves with a length of\n+   doubleword or greater are required to use memory.  Using MTC1/MFC1\n+   to access the lower-half of these registers would require a forbidden\n+   single-precision access.  We require all double-word moves to use\n+   memory because adding even and odd floating-point registers classes\n+   would have a significant impact on the backend.  */\n \n-bool\n-mips_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n-\t\t\t      machine_mode mode)\n+static bool\n+mips_secondary_memory_needed (machine_mode mode, reg_class_t class1,\n+\t\t\t      reg_class_t class2)\n {\n   /* Ignore spilled pseudos.  */\n   if (lra_in_progress && (class1 == NO_REGS || class2 == NO_REGS))\n@@ -22607,6 +22618,9 @@ mips_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 2\n \n+#undef TARGET_SECONDARY_MEMORY_NEEDED\n+#define TARGET_SECONDARY_MEMORY_NEEDED mips_secondary_memory_needed\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-mips.h\""}, {"sha": "1a54dc624b16781e8acda5f7f510fe3c06426c08", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -2298,19 +2298,6 @@ enum reg_class\n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\\\n   mips_secondary_reload_class (CLASS, MODE, X, false)\n \n-/* When targeting the o32 FPXX ABI, all moves with a length of doubleword\n-   or greater must be performed by FR-mode-aware instructions.\n-   This can be achieved using MFHC1/MTHC1 when these instructions are\n-   available but otherwise moves must go via memory.\n-   For the o32 FP64A ABI, all odd-numbered moves with a length of\n-   doubleword or greater are required to use memory.  Using MTC1/MFC1\n-   to access the lower-half of these registers would require a forbidden\n-   single-precision access.  We require all double-word moves to use\n-   memory because adding even and odd floating-point registers classes\n-   would have a significant impact on the backend.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n-  mips_secondary_memory_needed ((CLASS1), (CLASS2), (MODE))\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n "}, {"sha": "27251079b77df04be5e5dbdb11691e9a2d36b944", "filename": "gcc/config/mmix/mmix.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -623,7 +623,7 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n ;; possible to do that?  Bug in GCC?  Anyway, this used to be a simple\n ;; pattern with a memory_operand predicate, but was split up with a\n ;; define_expand with the old pattern as \"anonymous\".\n-;; FIXME: Perhaps with SECONDARY_MEMORY_NEEDED?\n+;; FIXME: Perhaps with TARGET_SECONDARY_MEMORY_NEEDED?\n (define_expand \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\")\n \t(float_truncate:SF (match_operand:DF 1 \"register_operand\")))]"}, {"sha": "e10cbb3b331b414188d86183d18f28bf6d7f0c69", "filename": "gcc/config/pa/pa-64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpa%2Fpa-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpa%2Fpa-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-64.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -97,7 +97,7 @@ along with GCC; see the file COPYING3.  If not see\n    function which has no frame and this function might also use SP-16.\n    We have 14-bit immediates on the 64-bit port, so we use secondary\n    memory for the copies.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n+#define PA_SECONDARY_MEMORY_NEEDED(MODE, CLASS1, CLASS2) \\\n   (MAYBE_FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2)\t\t\\\n    || MAYBE_FP_REG_CLASS_P (CLASS2) != FP_REG_CLASS_P (CLASS1))\n "}, {"sha": "f39b6721d2440c1e3e2c7476f1eec8d1be2f7eb9", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -178,6 +178,8 @@ static struct machine_function * pa_init_machine_status (void);\n static reg_class_t pa_secondary_reload (bool, rtx, reg_class_t,\n \t\t\t\t\tmachine_mode,\n \t\t\t\t\tsecondary_reload_info *);\n+static bool pa_secondary_memory_needed (machine_mode,\n+\t\t\t\t\treg_class_t, reg_class_t);\n static void pa_extra_live_on_entry (bitmap);\n static machine_mode pa_promote_function_mode (const_tree,\n \t\t\t\t\t\t   machine_mode, int *,\n@@ -377,6 +379,8 @@ static size_t n_deferred_plabels = 0;\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD pa_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED\n+#define TARGET_SECONDARY_MEMORY_NEEDED pa_secondary_memory_needed\n \n #undef TARGET_EXTRA_LIVE_ON_ENTRY\n #define TARGET_EXTRA_LIVE_ON_ENTRY pa_extra_live_on_entry\n@@ -6189,6 +6193,20 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   return NO_REGS;\n }\n \n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED.  */\n+\n+static bool\n+pa_secondary_memory_needed (machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t    reg_class_t class1 ATTRIBUTE_UNUSED,\n+\t\t\t    reg_class_t class2 ATTRIBUTE_UNUSED)\n+{\n+#ifdef PA_SECONDARY_MEMORY_NEEDED\n+  return PA_SECONDARY_MEMORY_NEEDED (mode, class1, class2);\n+#else\n+  return false;\n+#endif\n+}\n+\n /* Implement TARGET_EXTRA_LIVE_ON_ENTRY.  The argument pointer\n    is only marked as live on entry by df-scan when it is a fixed\n    register.  It isn't a fixed register in the 64-bit runtime,"}, {"sha": "2fe138634e65b71c5888afe9beda2485cbc278c0", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -31,8 +31,6 @@ extern const char *output_jump (enum rtx_code, int, int);\n extern void print_operand_address (FILE *, rtx);\n extern bool pdp11_cannot_change_mode_class (machine_mode,\n                                             machine_mode, enum reg_class);\n-extern bool pdp11_secondary_memory_needed (reg_class_t, reg_class_t, \n-\t\t\t\t\t   machine_mode);\n typedef enum { no_action, dec_before, inc_after } pdp11_action;\n typedef enum { little, either, big } pdp11_partorder;\n extern bool pdp11_expand_operands (rtx *, rtx [][2], int, "}, {"sha": "5364b47451cfb5da4c0b10310784a60ed4b87f66", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -243,6 +243,9 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n \n #undef  TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P pdp11_modes_tieable_p\n+\n+#undef  TARGET_SECONDARY_MEMORY_NEEDED\n+#define TARGET_SECONDARY_MEMORY_NEEDED pdp11_secondary_memory_needed\n \f\n /* A helper function to determine if REGNO should be saved in the\n    current function's stack frame.  */\n@@ -1453,14 +1456,13 @@ pdp11_secondary_reload (bool in_p ATTRIBUTE_UNUSED,\n   return LOAD_FPU_REGS;\n }\n \n-/* Target routine to check if register to register move requires memory.\n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED.\n \n    The answer is yes if we're going between general register and FPU \n    registers.  The mode doesn't matter in making this check.\n */\n-bool \n-pdp11_secondary_memory_needed (reg_class_t c1, reg_class_t c2, \n-\t\t\t       machine_mode mode ATTRIBUTE_UNUSED)\n+static bool\n+pdp11_secondary_memory_needed (machine_mode, reg_class_t c1, reg_class_t c2)\n {\n   int fromfloat = (c1 == LOAD_FPU_REGS || c1 == NO_LOAD_FPU_REGS || \n \t\t   c1 == FPU_REGS);"}, {"sha": "d220697f30b5399ce2cb276190a71ae54c0ebda5", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -236,10 +236,6 @@ enum reg_class { NO_REGS, MUL_REGS, GENERAL_REGS, LOAD_FPU_REGS, NO_LOAD_FPU_REG\n #define INDEX_REG_CLASS GENERAL_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n \n-/* Hook for testing if memory is needed for moving between registers.  */\n-#define SECONDARY_MEMORY_NEEDED(class1, class2, m) \\\n-  pdp11_secondary_memory_needed (class1, class2, m)\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\"}, {"sha": "c87a6a08bd9c17805f80d8adbebe910e85e08228", "filename": "gcc/config/powerpcspe/powerpcspe-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -109,9 +109,6 @@ extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n \t\t\t\t\t\t\t    machine_mode,\n \t\t\t\t\t\t\t    rtx);\n-extern bool (*rs6000_secondary_memory_needed_ptr) (enum reg_class,\n-\t\t\t\t\t\t   enum reg_class,\n-\t\t\t\t\t\t   machine_mode);\n extern bool (*rs6000_cannot_change_mode_class_ptr) (machine_mode,\n \t\t\t\t\t\t    machine_mode,\n \t\t\t\t\t\t    enum reg_class);"}, {"sha": "499dc1d694d4c134cf56f32a460d33341d6aa1cd", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -1384,11 +1384,9 @@ static enum reg_class rs6000_debug_secondary_reload_class (enum reg_class,\n static enum reg_class rs6000_preferred_reload_class (rtx, enum reg_class);\n static enum reg_class rs6000_debug_preferred_reload_class (rtx,\n \t\t\t\t\t\t\t   enum reg_class);\n-static bool rs6000_secondary_memory_needed (enum reg_class, enum reg_class,\n-\t\t\t\t\t    machine_mode);\n-static bool rs6000_debug_secondary_memory_needed (enum reg_class,\n-\t\t\t\t\t\t  enum reg_class,\n-\t\t\t\t\t\t  machine_mode);\n+static bool rs6000_debug_secondary_memory_needed (machine_mode,\n+\t\t\t\t\t\t  reg_class_t,\n+\t\t\t\t\t\t  reg_class_t);\n static bool rs6000_cannot_change_mode_class (machine_mode,\n \t\t\t\t\t     machine_mode,\n \t\t\t\t\t     enum reg_class);\n@@ -1412,10 +1410,6 @@ enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx, enum reg_class)\n   = rs6000_preferred_reload_class;\n \n-bool (*rs6000_secondary_memory_needed_ptr) (enum reg_class, enum reg_class,\n-\t\t\t\t\t    machine_mode)\n-  = rs6000_secondary_memory_needed;\n-\n bool (*rs6000_cannot_change_mode_class_ptr) (machine_mode,\n \t\t\t\t\t     machine_mode,\n \t\t\t\t\t     enum reg_class)\n@@ -1897,6 +1891,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD rs6000_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED\n+#define TARGET_SECONDARY_MEMORY_NEEDED rs6000_secondary_memory_needed\n #undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n #define TARGET_SECONDARY_MEMORY_NEEDED_MODE rs6000_secondary_memory_needed_mode\n \n@@ -5098,7 +5094,7 @@ rs6000_option_override_internal (bool global_init_p)\n \t  targetm.legitimize_address = rs6000_debug_legitimize_address;\n \t  rs6000_secondary_reload_class_ptr\n \t    = rs6000_debug_secondary_reload_class;\n-\t  rs6000_secondary_memory_needed_ptr\n+\t  targetm.secondary_memory_needed\n \t    = rs6000_debug_secondary_memory_needed;\n \t  rs6000_cannot_change_mode_class_ptr\n \t    = rs6000_debug_cannot_change_mode_class;\n@@ -23149,9 +23145,9 @@ rs6000_debug_preferred_reload_class (rtx x, enum reg_class rclass)\n    set and vice versa.  */\n \n static bool\n-rs6000_secondary_memory_needed (enum reg_class from_class,\n-\t\t\t\tenum reg_class to_class,\n-\t\t\t\tmachine_mode mode)\n+rs6000_secondary_memory_needed (machine_mode mode,\n+\t\t\t\treg_class_t from_class,\n+\t\t\t\treg_class_t to_class)\n {\n   enum rs6000_reg_type from_type, to_type;\n   bool altivec_p = ((from_class == ALTIVEC_REGS)\n@@ -23175,11 +23171,11 @@ rs6000_secondary_memory_needed (enum reg_class from_class,\n \n /* Debug version of rs6000_secondary_memory_needed.  */\n static bool\n-rs6000_debug_secondary_memory_needed (enum reg_class from_class,\n-\t\t\t\t      enum reg_class to_class,\n-\t\t\t\t      machine_mode mode)\n+rs6000_debug_secondary_memory_needed (machine_mode mode,\n+\t\t\t\t      reg_class_t from_class,\n+\t\t\t\t      reg_class_t to_class)\n {\n-  bool ret = rs6000_secondary_memory_needed (from_class, to_class, mode);\n+  bool ret = rs6000_secondary_memory_needed (mode, from_class, to_class);\n \n   fprintf (stderr,\n \t   \"rs6000_secondary_memory_needed, return: %s, from_class = %s, \""}, {"sha": "be3d0e887e8dc51790a8e05d5cd12c18953fd036", "filename": "gcc/config/powerpcspe/powerpcspe.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -1596,14 +1596,6 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n   rs6000_secondary_reload_class_ptr (CLASS, MODE, IN)\n \n-/* If we are copying between FP or AltiVec registers and anything\n-   else, we need a memory location.  The exception is when we are\n-   targeting ppc64 and the move to/from fpr to gpr instructions\n-   are available.*/\n-\n-#define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE)\t\t\t\\\n-  rs6000_secondary_memory_needed_ptr (CLASS1, CLASS2, MODE)\n-\n /* For cpus that cannot load/store SDmode values from the 64-bit\n    FP registers without using a full 64-bit load/store, we need\n    to allocate a full 64-bit stack slot for them.  */"}, {"sha": "c6390aaec95f2e95b22724fe84abb3f1503aadbf", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -3510,13 +3510,26 @@ riscv_can_use_return_insn (void)\n   return reload_completed && cfun->machine->frame.total_size == 0;\n }\n \n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED.\n+\n+   When floating-point registers are wider than integer ones, moves between\n+   them must go through memory.  */\n+\n+static bool\n+riscv_secondary_memory_needed (machine_mode mode, reg_class_t class1,\n+\t\t\t       reg_class_t class2)\n+{\n+  return (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+\t  && (class1 == FP_REGS) != (class2 == FP_REGS));\n+}\n+\n /* Implement TARGET_REGISTER_MOVE_COST.  */\n \n static int\n riscv_register_move_cost (machine_mode mode,\n \t\t\t  reg_class_t from, reg_class_t to)\n {\n-  return SECONDARY_MEMORY_NEEDED (from, to, mode) ? 8 : 2;\n+  return riscv_secondary_memory_needed (mode, from, to) ? 8 : 2;\n }\n \n /* Implement TARGET_HARD_REGNO_NREGS.  */\n@@ -4115,6 +4128,9 @@ riscv_slow_unaligned_access (machine_mode, unsigned int)\n #undef TARGET_SLOW_UNALIGNED_ACCESS\n #define TARGET_SLOW_UNALIGNED_ACCESS riscv_slow_unaligned_access\n \n+#undef TARGET_SECONDARY_MEMORY_NEEDED\n+#define TARGET_SECONDARY_MEMORY_NEEDED riscv_secondary_memory_needed\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-riscv.h\""}, {"sha": "0a5ae406605319fbfe324b0d13f67c78d254cae9", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -221,12 +221,6 @@ along with GCC; see the file COPYING3.  If not see\n    Extensions of pointers to word_mode must be signed.  */\n #define POINTERS_EXTEND_UNSIGNED false\n \n-/* When floating-point registers are wider than integer ones, moves between\n-   them must go through memory.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE)\t\\\n-  (GET_MODE_SIZE (MODE) > UNITS_PER_WORD\t\t\\\n-   && ((CLASS1) == FP_REGS) != ((CLASS2) == FP_REGS))\n-\n /* Define if loading short immediate values into registers sign extends.  */\n #define SHORT_IMMEDIATES_SIGN_EXTEND 1\n "}, {"sha": "6e80396b80b9c6a64e15b341477697f738bdb50d", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -110,9 +110,6 @@ extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n \t\t\t\t\t\t\t    machine_mode,\n \t\t\t\t\t\t\t    rtx);\n-extern bool (*rs6000_secondary_memory_needed_ptr) (enum reg_class,\n-\t\t\t\t\t\t   enum reg_class,\n-\t\t\t\t\t\t   machine_mode);\n extern bool (*rs6000_cannot_change_mode_class_ptr) (machine_mode,\n \t\t\t\t\t\t    machine_mode,\n \t\t\t\t\t\t    enum reg_class);"}, {"sha": "3fee22836feedfb8eecf8a041683278f6a890f06", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -1389,11 +1389,9 @@ static enum reg_class rs6000_debug_secondary_reload_class (enum reg_class,\n static enum reg_class rs6000_preferred_reload_class (rtx, enum reg_class);\n static enum reg_class rs6000_debug_preferred_reload_class (rtx,\n \t\t\t\t\t\t\t   enum reg_class);\n-static bool rs6000_secondary_memory_needed (enum reg_class, enum reg_class,\n-\t\t\t\t\t    machine_mode);\n-static bool rs6000_debug_secondary_memory_needed (enum reg_class,\n-\t\t\t\t\t\t  enum reg_class,\n-\t\t\t\t\t\t  machine_mode);\n+static bool rs6000_debug_secondary_memory_needed (machine_mode,\n+\t\t\t\t\t\t  reg_class_t,\n+\t\t\t\t\t\t  reg_class_t);\n static bool rs6000_cannot_change_mode_class (machine_mode,\n \t\t\t\t\t     machine_mode,\n \t\t\t\t\t     enum reg_class);\n@@ -1417,10 +1415,6 @@ enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx, enum reg_class)\n   = rs6000_preferred_reload_class;\n \n-bool (*rs6000_secondary_memory_needed_ptr) (enum reg_class, enum reg_class,\n-\t\t\t\t\t    machine_mode)\n-  = rs6000_secondary_memory_needed;\n-\n bool (*rs6000_cannot_change_mode_class_ptr) (machine_mode,\n \t\t\t\t\t     machine_mode,\n \t\t\t\t\t     enum reg_class)\n@@ -1876,6 +1870,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD rs6000_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED\n+#define TARGET_SECONDARY_MEMORY_NEEDED rs6000_secondary_memory_needed\n #undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n #define TARGET_SECONDARY_MEMORY_NEEDED_MODE rs6000_secondary_memory_needed_mode\n \n@@ -4716,7 +4712,7 @@ rs6000_option_override_internal (bool global_init_p)\n \t  targetm.legitimize_address = rs6000_debug_legitimize_address;\n \t  rs6000_secondary_reload_class_ptr\n \t    = rs6000_debug_secondary_reload_class;\n-\t  rs6000_secondary_memory_needed_ptr\n+\t  targetm.secondary_memory_needed\n \t    = rs6000_debug_secondary_memory_needed;\n \t  rs6000_cannot_change_mode_class_ptr\n \t    = rs6000_debug_cannot_change_mode_class;\n@@ -20491,9 +20487,9 @@ rs6000_debug_preferred_reload_class (rtx x, enum reg_class rclass)\n    set and vice versa.  */\n \n static bool\n-rs6000_secondary_memory_needed (enum reg_class from_class,\n-\t\t\t\tenum reg_class to_class,\n-\t\t\t\tmachine_mode mode)\n+rs6000_secondary_memory_needed (machine_mode mode,\n+\t\t\t\treg_class_t from_class,\n+\t\t\t\treg_class_t to_class)\n {\n   enum rs6000_reg_type from_type, to_type;\n   bool altivec_p = ((from_class == ALTIVEC_REGS)\n@@ -20517,11 +20513,11 @@ rs6000_secondary_memory_needed (enum reg_class from_class,\n \n /* Debug version of rs6000_secondary_memory_needed.  */\n static bool\n-rs6000_debug_secondary_memory_needed (enum reg_class from_class,\n-\t\t\t\t      enum reg_class to_class,\n-\t\t\t\t      machine_mode mode)\n+rs6000_debug_secondary_memory_needed (machine_mode mode,\n+\t\t\t\t      reg_class_t from_class,\n+\t\t\t\t      reg_class_t to_class)\n {\n-  bool ret = rs6000_secondary_memory_needed (from_class, to_class, mode);\n+  bool ret = rs6000_secondary_memory_needed (mode, from_class, to_class);\n \n   fprintf (stderr,\n \t   \"rs6000_secondary_memory_needed, return: %s, from_class = %s, \""}, {"sha": "8ec192ea70012053f4a1de0283650d1c2e71f38d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -1506,14 +1506,6 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n   rs6000_secondary_reload_class_ptr (CLASS, MODE, IN)\n \n-/* If we are copying between FP or AltiVec registers and anything\n-   else, we need a memory location.  The exception is when we are\n-   targeting ppc64 and the move to/from fpr to gpr instructions\n-   are available.*/\n-\n-#define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE)\t\t\t\\\n-  rs6000_secondary_memory_needed_ptr (CLASS1, CLASS2, MODE)\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n "}, {"sha": "f62d740ec642686dba0c963f78f8800818d906ca", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -4409,6 +4409,35 @@ s390_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   return NO_REGS;\n }\n \n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED.\n+\n+   We need secondary memory to move data between GPRs and FPRs.\n+\n+   - With DFP the ldgr lgdr instructions are available.  Due to the\n+     different alignment we cannot use them for SFmode.  For 31 bit a\n+     64 bit value in GPR would be a register pair so here we still\n+     need to go via memory.\n+\n+   - With z13 we can do the SF/SImode moves with vlgvf.  Due to the\n+     overlapping of FPRs and VRs we still disallow TF/TD modes to be\n+     in full VRs so as before also on z13 we do these moves via\n+     memory.\n+\n+     FIXME: Should we try splitting it into two vlgvg's/vlvg's instead?  */\n+\n+static bool\n+s390_secondary_memory_needed (machine_mode mode,\n+\t\t\t      reg_class_t class1, reg_class_t class2)\n+{\n+  return (((reg_classes_intersect_p (class1, VEC_REGS)\n+\t    && reg_classes_intersect_p (class2, GENERAL_REGS))\n+\t   || (reg_classes_intersect_p (class1, GENERAL_REGS)\n+\t       && reg_classes_intersect_p (class2, VEC_REGS)))\n+\t  && (!TARGET_DFP || !TARGET_64BIT || GET_MODE_SIZE (mode) != 8)\n+\t  && (!TARGET_VX || (SCALAR_FLOAT_MODE_P (mode)\n+\t\t\t     && GET_MODE_SIZE (mode) > 8)));\n+}\n+\n /* Implement TARGET_SECONDARY_MEMORY_NEEDED_MODE.\n \n    get_secondary_mem widens its argument to BITS_PER_WORD which loses on 64bit\n@@ -15972,6 +16001,8 @@ s390_asan_shadow_offset (void)\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD s390_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED\n+#define TARGET_SECONDARY_MEMORY_NEEDED s390_secondary_memory_needed\n #undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n #define TARGET_SECONDARY_MEMORY_NEEDED_MODE s390_secondary_memory_needed_mode\n "}, {"sha": "09325918da35477a09a70c8c97e51ff69bc87cfd", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -577,29 +577,6 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n #define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P (REGNO)\n \n \n-/* We need secondary memory to move data between GPRs and FPRs.\n-\n-   - With DFP the ldgr lgdr instructions are available.  Due to the\n-     different alignment we cannot use them for SFmode.  For 31 bit a\n-     64 bit value in GPR would be a register pair so here we still\n-     need to go via memory.\n-\n-   - With z13 we can do the SF/SImode moves with vlgvf.  Due to the\n-     overlapping of FPRs and VRs we still disallow TF/TD modes to be\n-     in full VRs so as before also on z13 we do these moves via\n-     memory.\n-\n-     FIXME: Should we try splitting it into two vlgvg's/vlvg's instead?  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n-  (((reg_classes_intersect_p ((CLASS1), VEC_REGS)\t\t\t\\\n-     && reg_classes_intersect_p ((CLASS2), GENERAL_REGS))\t\t\\\n-    || (reg_classes_intersect_p ((CLASS1), GENERAL_REGS)\t\t\\\n-\t&& reg_classes_intersect_p ((CLASS2), VEC_REGS)))\t\t\\\n-   && (!TARGET_DFP || !TARGET_64BIT || GET_MODE_SIZE (MODE) != 8)\t\\\n-   && (!TARGET_VX || (SCALAR_FLOAT_MODE_P (MODE)\t\t\t\\\n-\t\t\t  && GET_MODE_SIZE (MODE) > 8)))\n-\n-\n /* Stack layout and calling conventions.  */\n \n /* Our stack grows from higher to lower addresses.  However, local variables"}, {"sha": "aa66f24f1b3d32383da0144e3fa6464dede12e0f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -672,6 +672,8 @@ static void sparc_print_operand_address (FILE *, machine_mode, rtx);\n static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,\n \t\t\t\t\t   machine_mode,\n \t\t\t\t\t   secondary_reload_info *);\n+static bool sparc_secondary_memory_needed (machine_mode, reg_class_t,\n+\t\t\t\t\t   reg_class_t);\n static machine_mode sparc_secondary_memory_needed_mode (machine_mode);\n static scalar_int_mode sparc_cstore_mode (enum insn_code icode);\n static void sparc_atomic_assign_expand_fenv (tree *, tree *, tree *);\n@@ -860,6 +862,8 @@ char sparc_hard_reg_printed[8];\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD sparc_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED\n+#define TARGET_SECONDARY_MEMORY_NEEDED sparc_secondary_memory_needed\n #undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n #define TARGET_SECONDARY_MEMORY_NEEDED_MODE sparc_secondary_memory_needed_mode\n \n@@ -13053,6 +13057,21 @@ sparc_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   return NO_REGS;\n }\n \n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED.\n+\n+   On SPARC when not VIS3 it is not possible to directly move data\n+   between GENERAL_REGS and FP_REGS.  */\n+\n+static bool\n+sparc_secondary_memory_needed (machine_mode mode, reg_class_t class1,\n+\t\t\t       reg_class_t class2)\n+{\n+  return ((FP_REG_CLASS_P (class1) != FP_REG_CLASS_P (class2))\n+\t  && (! TARGET_VIS3\n+\t      || GET_MODE_SIZE (mode) > 8\n+\t      || GET_MODE_SIZE (mode) < 4));\n+}\n+\n /* Implement TARGET_SECONDARY_MEMORY_NEEDED_MODE.\n \n    get_secondary_mem widens its argument to BITS_PER_WORD which loses on v9"}, {"sha": "a9672e3bf1ce4c6e1ee03930fb565ae03d3ebd3f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -1047,14 +1047,6 @@ extern char leaf_reg_remap[];\n #define SPARC_SETHI32_P(X) \\\n   (SPARC_SETHI_P ((unsigned HOST_WIDE_INT) (X) & GET_MODE_MASK (SImode)))\n \n-/* On SPARC when not VIS3 it is not possible to directly move data\n-   between GENERAL_REGS and FP_REGS.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n-  ((FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2)) \\\n-   && (! TARGET_VIS3 \\\n-       || GET_MODE_SIZE (MODE) > 8 \\\n-       || GET_MODE_SIZE (MODE) < 4))\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n /* On SPARC, this is the size of MODE in words.  */"}, {"sha": "04038015e8cccd51d8aa315b99a444d2831d1e52", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -2656,7 +2656,7 @@ in memory and the hard register number if it is in a register.\n \n Scratch operands in memory (constraint @code{\"=m\"} / @code{\"=&m\"}) are\n currently not supported.  For the time being, you will have to continue\n-to use @code{SECONDARY_MEMORY_NEEDED} for that purpose.\n+to use @code{TARGET_SECONDARY_MEMORY_NEEDED} for that purpose.\n \n @code{copy_cost} also uses this target hook to find out how values are\n copied.  If you want it to include some extra cost for the need to allocate\n@@ -2726,29 +2726,28 @@ intermediate storage.  This case often occurs between floating-point and\n general registers.\n @end defmac\n \n-@defmac SECONDARY_MEMORY_NEEDED (@var{class1}, @var{class2}, @var{m})\n+@deftypefn {Target Hook} bool TARGET_SECONDARY_MEMORY_NEEDED (machine_mode @var{mode}, reg_class_t @var{class1}, reg_class_t @var{class2})\n Certain machines have the property that some registers cannot be copied\n-to some other registers without using memory.  Define this macro on\n-those machines to be a C expression that is nonzero if objects of mode\n-@var{m} in registers of @var{class1} can only be copied to registers of\n-class @var{class2} by storing a register of @var{class1} into memory\n-and loading that memory location into a register of @var{class2}.\n-\n-Do not define this macro if its value would always be zero.\n-@end defmac\n+to some other registers without using memory.  Define this hook on\n+those machines to return true if objects of mode @var{m} in registers\n+of @var{class1} can only be copied to registers of class @var{class2} by\n+ storing a register of @var{class1} into memory and loading that memory\n+location into a register of @var{class2}.  The default definition returns\n+false for all inputs.\n+@end deftypefn\n \n @defmac SECONDARY_MEMORY_NEEDED_RTX (@var{mode})\n-Normally when @code{SECONDARY_MEMORY_NEEDED} is defined, the compiler\n+Normally when @code{TARGET_SECONDARY_MEMORY_NEEDED} is defined, the compiler\n allocates a stack slot for a memory location needed for register copies.\n If this macro is defined, the compiler instead uses the memory location\n defined by this macro.\n \n Do not define this macro if you do not define\n-@code{SECONDARY_MEMORY_NEEDED}.\n+@code{TARGET_SECONDARY_MEMORY_NEEDED}.\n @end defmac\n \n @deftypefn {Target Hook} machine_mode TARGET_SECONDARY_MEMORY_NEEDED_MODE (machine_mode @var{mode})\n-If @code{SECONDARY_MEMORY_NEEDED} tells the compiler to use memory\n+If @code{TARGET_SECONDARY_MEMORY_NEEDED} tells the compiler to use memory\n when moving between two particular registers of mode @var{mode},\n this hook specifies the mode that the memory should have.\n "}, {"sha": "f6a0d09f1887f8377296de1c27d562b3e45b0413", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -2303,25 +2303,16 @@ intermediate storage.  This case often occurs between floating-point and\n general registers.\n @end defmac\n \n-@defmac SECONDARY_MEMORY_NEEDED (@var{class1}, @var{class2}, @var{m})\n-Certain machines have the property that some registers cannot be copied\n-to some other registers without using memory.  Define this macro on\n-those machines to be a C expression that is nonzero if objects of mode\n-@var{m} in registers of @var{class1} can only be copied to registers of\n-class @var{class2} by storing a register of @var{class1} into memory\n-and loading that memory location into a register of @var{class2}.\n-\n-Do not define this macro if its value would always be zero.\n-@end defmac\n+@hook TARGET_SECONDARY_MEMORY_NEEDED\n \n @defmac SECONDARY_MEMORY_NEEDED_RTX (@var{mode})\n-Normally when @code{SECONDARY_MEMORY_NEEDED} is defined, the compiler\n+Normally when @code{TARGET_SECONDARY_MEMORY_NEEDED} is defined, the compiler\n allocates a stack slot for a memory location needed for register copies.\n If this macro is defined, the compiler instead uses the memory location\n defined by this macro.\n \n Do not define this macro if you do not define\n-@code{SECONDARY_MEMORY_NEEDED}.\n+@code{TARGET_SECONDARY_MEMORY_NEEDED}.\n @end defmac\n \n @hook TARGET_SECONDARY_MEMORY_NEEDED_MODE"}, {"sha": "44ebd6f5c857bcca75489d17f9c1829638250338", "filename": "gcc/hooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -495,3 +495,12 @@ hook_bool_reg_class_t_false (reg_class_t regclass ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+/* Generic hook that takes a machine_mode and 2 register classes\n+   and returns false.  */\n+bool\n+hook_bool_mode_reg_class_t_reg_class_t_false (machine_mode, reg_class_t,\n+\t\t\t\t\t      reg_class_t)\n+{\n+  return false;\n+}\n+"}, {"sha": "e5741df7f1cb862d92460355c61e7b6539108f4a", "filename": "gcc/hooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -59,6 +59,9 @@ extern bool hook_bool_rtx_false (rtx);\n extern bool hook_bool_rtx_insn_int_false (rtx_insn *, int);\n extern bool hook_bool_uintp_uintp_false (unsigned int *, unsigned int *);\n extern bool hook_bool_reg_class_t_false (reg_class_t regclass);\n+extern bool hook_bool_mode_reg_class_t_reg_class_t_false (machine_mode,\n+\t\t\t\t\t\t\t  reg_class_t,\n+\t\t\t\t\t\t\t  reg_class_t);\n extern bool hook_bool_rtx_mode_int_int_intp_bool_false (rtx, machine_mode,\n \t\t\t\t\t\t\tint, int, int *, bool);\n extern bool hook_bool_tree_tree_false (tree, tree);"}, {"sha": "d90bde2817aa0b4b29e6af27a462a79424a77cb9", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -1159,8 +1159,8 @@ emit_spill_move (bool to_p, rtx mem_pseudo, rtx val)\n \n /* Process a special case insn (register move), return true if we\n    don't need to process it anymore.  INSN should be a single set\n-   insn.  Set up that RTL was changed through CHANGE_P and macro\n-   SECONDARY_MEMORY_NEEDED says to use secondary memory through\n+   insn.  Set up that RTL was changed through CHANGE_P and that hook\n+   TARGET_SECONDARY_MEMORY_NEEDED says to use secondary memory through\n    SEC_MEM_P.  */\n static bool\n check_and_process_move (bool *change_p, bool *sec_mem_p ATTRIBUTE_UNUSED)\n@@ -1201,16 +1201,14 @@ check_and_process_move (bool *change_p, bool *sec_mem_p ATTRIBUTE_UNUSED)\n     return false;\n   if (sclass == NO_REGS && dclass == NO_REGS)\n     return false;\n-#ifdef SECONDARY_MEMORY_NEEDED\n-  if (SECONDARY_MEMORY_NEEDED (sclass, dclass, GET_MODE (src))\n+  if (targetm.secondary_memory_needed (GET_MODE (src), sclass, dclass)\n       && ((sclass != NO_REGS && dclass != NO_REGS)\n \t  || (GET_MODE (src)\n \t      != targetm.secondary_memory_needed_mode (GET_MODE (src)))))\n     {\n       *sec_mem_p = true;\n       return false;\n     }\n-#endif\n   if (! REG_P (dreg) || ! REG_P (sreg))\n     return false;\n   sri.prev_sri = NULL;\n@@ -2739,19 +2737,18 @@ process_alt_operands (int only_alternative)\n \t\t  reject += 3;\n \t\t}\n \t      \n-#ifdef SECONDARY_MEMORY_NEEDED\n \t      /* If reload requires moving value through secondary\n \t\t memory, it will need one more insn at least.  */\n \t      if (this_alternative != NO_REGS \n \t\t  && REG_P (op) && (cl = get_reg_class (REGNO (op))) != NO_REGS\n \t\t  && ((curr_static_id->operand[nop].type != OP_OUT\n-\t\t       && SECONDARY_MEMORY_NEEDED (cl, this_alternative,\n-\t\t\t\t\t\t   GET_MODE (op)))\n+\t\t       && targetm.secondary_memory_needed (GET_MODE (op), cl,\n+\t\t\t\t\t\t\t   this_alternative))\n \t\t      || (curr_static_id->operand[nop].type != OP_IN\n-\t\t\t  && SECONDARY_MEMORY_NEEDED (this_alternative, cl,\n-\t\t\t\t\t\t      GET_MODE (op)))))\n+\t\t\t  && (targetm.secondary_memory_needed\n+\t\t\t      (GET_MODE (op), this_alternative, cl)))))\n \t\tlosers++;\n-#endif\n+\n \t      /* Input reloads can be inherited more often than output\n \t\t reloads can be removed, so penalize output\n \t\t reloads.  */\n@@ -3716,9 +3713,7 @@ curr_insn_transform (bool check_only_p)\n   /* Flag that the insn has been changed through a transformation.  */\n   bool change_p;\n   bool sec_mem_p;\n-#ifdef SECONDARY_MEMORY_NEEDED\n   bool use_sec_mem_p;\n-#endif\n   int max_regno_before;\n   int reused_alternative_num;\n \n@@ -3899,8 +3894,7 @@ curr_insn_transform (bool check_only_p)\n       change_p = true;\n     }\n \n-#ifdef SECONDARY_MEMORY_NEEDED\n-  /* Some target macros SECONDARY_MEMORY_NEEDED (e.g. x86) are defined\n+  /* Some targets' TARGET_SECONDARY_MEMORY_NEEDED (e.g. x86) are defined\n      too conservatively.  So we use the secondary memory only if there\n      is no any alternative without reloads.  */\n   use_sec_mem_p = false;\n@@ -3985,7 +3979,6 @@ curr_insn_transform (bool check_only_p)\n       lra_update_insn_regno_info (curr_insn);\n       return true;\n     }\n-#endif\n \n   lra_assert (goal_alt_number >= 0);\n   lra_set_used_insn_alternative (curr_insn, goal_alt_number);\n@@ -5084,9 +5077,6 @@ static bool\n check_secondary_memory_needed_p (enum reg_class inher_cl ATTRIBUTE_UNUSED,\n \t\t\t\t rtx usage_insns ATTRIBUTE_UNUSED)\n {\n-#ifndef SECONDARY_MEMORY_NEEDED\n-  return false;\n-#else\n   rtx_insn *insn;\n   rtx set, dest;\n   enum reg_class cl;\n@@ -5103,8 +5093,7 @@ check_secondary_memory_needed_p (enum reg_class inher_cl ATTRIBUTE_UNUSED,\n   lra_assert (inher_cl != NO_REGS);\n   cl = get_reg_class (REGNO (dest));\n   return (cl != NO_REGS && cl != ALL_REGS\n-\t  && SECONDARY_MEMORY_NEEDED (inher_cl, cl, GET_MODE (dest)));\n-#endif\n+\t  && targetm.secondary_memory_needed (GET_MODE (dest), inher_cl, cl));\n }\n \n /* Registers involved in inheritance/split in the current EBB\n@@ -5364,28 +5353,24 @@ choose_split_class (enum reg_class allocno_class,\n \t\t    int hard_regno ATTRIBUTE_UNUSED,\n \t\t    machine_mode mode ATTRIBUTE_UNUSED)\n {\n-#ifndef SECONDARY_MEMORY_NEEDED\n-  return allocno_class;\n-#else\n   int i;\n   enum reg_class cl, best_cl = NO_REGS;\n   enum reg_class hard_reg_class ATTRIBUTE_UNUSED\n     = REGNO_REG_CLASS (hard_regno);\n \n-  if (! SECONDARY_MEMORY_NEEDED (allocno_class, allocno_class, mode)\n+  if (! targetm.secondary_memory_needed (mode, allocno_class, allocno_class)\n       && TEST_HARD_REG_BIT (reg_class_contents[allocno_class], hard_regno))\n     return allocno_class;\n   for (i = 0;\n        (cl = reg_class_subclasses[allocno_class][i]) != LIM_REG_CLASSES;\n        i++)\n-    if (! SECONDARY_MEMORY_NEEDED (cl, hard_reg_class, mode)\n-\t&& ! SECONDARY_MEMORY_NEEDED (hard_reg_class, cl, mode)\n+    if (! targetm.secondary_memory_needed (mode, cl, hard_reg_class)\n+\t&& ! targetm.secondary_memory_needed (mode, hard_reg_class, cl)\n \t&& TEST_HARD_REG_BIT (reg_class_contents[cl], hard_regno)\n \t&& (best_cl == NO_REGS\n \t    || ira_class_hard_regs_num[best_cl] < ira_class_hard_regs_num[cl]))\n       best_cl = cl;\n   return best_cl;\n-#endif\n }\n \n /* Copy any equivalence information from ORIGINAL_REGNO to NEW_REGNO."}, {"sha": "c9b946134f3ef450697a56d4b1864240acef2ada", "filename": "gcc/reload.c", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -172,8 +172,6 @@ struct decomposition\n   HOST_WIDE_INT end;\t/* Ending offset or register number.  */\n };\n \n-#ifdef SECONDARY_MEMORY_NEEDED\n-\n /* Save MEMs needed to copy from one class of registers to another.  One MEM\n    is used per mode, but normally only one or two modes are ever used.\n \n@@ -185,7 +183,6 @@ struct decomposition\n static rtx secondary_memlocs[NUM_MACHINE_MODES];\n static rtx secondary_memlocs_elim[NUM_MACHINE_MODES][MAX_RECOG_OPERANDS];\n static int secondary_memlocs_elim_used = 0;\n-#endif\n \n /* The instruction we are doing reloads for;\n    so we can test whether a register dies in it.  */\n@@ -456,22 +453,20 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \n   if (s_reload == n_reloads)\n     {\n-#ifdef SECONDARY_MEMORY_NEEDED\n       /* If we need a memory location to copy between the two reload regs,\n \t set it up now.  Note that we do the input case before making\n \t the reload and the output case after.  This is due to the\n \t way reloads are output.  */\n \n       if (in_p && icode == CODE_FOR_nothing\n-\t  && SECONDARY_MEMORY_NEEDED (rclass, reload_class, mode))\n+\t  && targetm.secondary_memory_needed (mode, rclass, reload_class))\n \t{\n \t  get_secondary_mem (x, reload_mode, opnum, type);\n \n \t  /* We may have just added new reloads.  Make sure we add\n \t     the new reload at the end.  */\n \t  s_reload = n_reloads;\n \t}\n-#endif\n \n       /* We need to make a new secondary reload for this register class.  */\n       rld[s_reload].in = rld[s_reload].out = 0;\n@@ -497,11 +492,9 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \n       n_reloads++;\n \n-#ifdef SECONDARY_MEMORY_NEEDED\n       if (! in_p && icode == CODE_FOR_nothing\n-\t  && SECONDARY_MEMORY_NEEDED (reload_class, rclass, mode))\n+\t  && targetm.secondary_memory_needed (mode, reload_class, rclass))\n \tget_secondary_mem (x, mode, opnum, type);\n-#endif\n     }\n \n   *picode = icode;\n@@ -556,8 +549,6 @@ scratch_reload_class (enum insn_code icode)\n   return rclass;\n }\n \f\n-#ifdef SECONDARY_MEMORY_NEEDED\n-\n /* Return a memory location that will be used to copy X in mode MODE.\n    If we haven't already made a location for this mode in this insn,\n    call find_reloads_address on the location being returned.  */\n@@ -634,7 +625,6 @@ clear_secondary_mem (void)\n {\n   memset (secondary_memlocs, 0, sizeof secondary_memlocs);\n }\n-#endif /* SECONDARY_MEMORY_NEEDED */\n \f\n \n /* Find the largest class which has at least one register valid in\n@@ -1353,7 +1343,6 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       /* We found no existing reload suitable for re-use.\n \t So add an additional reload.  */\n \n-#ifdef SECONDARY_MEMORY_NEEDED\n       if (subreg_in_class == NO_REGS\n \t  && in != 0\n \t  && (REG_P (in)\n@@ -1362,9 +1351,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \tsubreg_in_class = REGNO_REG_CLASS (reg_or_subregno (in));\n       /* If a memory location is needed for the copy, make one.  */\n       if (subreg_in_class != NO_REGS\n-\t  && SECONDARY_MEMORY_NEEDED (subreg_in_class, rclass, inmode))\n+\t  && targetm.secondary_memory_needed (inmode, subreg_in_class, rclass))\n \tget_secondary_mem (in, inmode, opnum, type);\n-#endif\n \n       i = n_reloads;\n       rld[i].in = in;\n@@ -1388,16 +1376,13 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n       n_reloads++;\n \n-#ifdef SECONDARY_MEMORY_NEEDED\n       if (out != 0\n           && (REG_P (out)\n \t      || (GET_CODE (out) == SUBREG && REG_P (SUBREG_REG (out))))\n \t  && reg_or_subregno (out) < FIRST_PSEUDO_REGISTER\n-\t  && SECONDARY_MEMORY_NEEDED (rclass,\n-\t\t\t\t      REGNO_REG_CLASS (reg_or_subregno (out)),\n-\t\t\t\t      outmode))\n+\t  && (targetm.secondary_memory_needed\n+\t      (outmode, rclass, REGNO_REG_CLASS (reg_or_subregno (out)))))\n \tget_secondary_mem (out, outmode, opnum, type);\n-#endif\n     }\n   else\n     {\n@@ -1797,14 +1782,12 @@ combine_reloads (void)\n \t\t\t\t       [(int) rld[output_reload].outmode])\n \t&& rld[i].inc == 0\n \t&& rld[i].reg_rtx == 0\n-#ifdef SECONDARY_MEMORY_NEEDED\n \t/* Don't combine two reloads with different secondary\n \t   memory locations.  */\n \t&& (secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[i].opnum] == 0\n \t    || secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum] == 0\n \t    || rtx_equal_p (secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[i].opnum],\n \t\t\t    secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum]))\n-#endif\n \t&& (targetm.small_register_classes_for_mode_p (VOIDmode)\n \t    ? (rld[i].rclass == rld[output_reload].rclass)\n \t    : (reg_class_subset_p (rld[i].rclass,\n@@ -1854,12 +1837,10 @@ combine_reloads (void)\n \t      = rld[output_reload].secondary_out_icode;\n \t  }\n \n-#ifdef SECONDARY_MEMORY_NEEDED\n \t/* Copy any secondary MEM.  */\n \tif (secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum] != 0)\n \t  secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[i].opnum]\n \t    = secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum];\n-#endif\n \t/* If required, minimize the register class.  */\n \tif (reg_class_subset_p (rld[output_reload].rclass,\n \t\t\t\trld[i].rclass))\n@@ -2668,7 +2649,6 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n   if (HAVE_cc0 && reg_set_p (cc0_rtx, PATTERN (insn)))\n     no_output_reloads = 1;\n \n-#ifdef SECONDARY_MEMORY_NEEDED\n   /* The eliminated forms of any secondary memory locations are per-insn, so\n      clear them out here.  */\n \n@@ -2678,7 +2658,6 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t      sizeof (secondary_memlocs_elim[0]) * secondary_memlocs_elim_used);\n       secondary_memlocs_elim_used = 0;\n     }\n-#endif\n \n   /* Dispose quickly of (set (reg..) (reg..)) if both have hard regs and it\n      is cheap to move between them.  If it is not, there may not be an insn"}, {"sha": "1ad4b63e09e4922603acbf29506a8bccc845d93d", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -768,10 +768,8 @@ reload (rtx_insn *first, int global)\n   /* Enable find_equiv_reg to distinguish insns made by reload.  */\n   reload_first_uid = get_max_uid ();\n \n-#ifdef SECONDARY_MEMORY_NEEDED\n   /* Initialize the secondary memory table.  */\n   clear_secondary_mem ();\n-#endif\n \n   /* We don't have a stack slot for any spill reg yet.  */\n   memset (spill_stack_slot, 0, sizeof spill_stack_slot);\n@@ -6331,7 +6329,6 @@ choose_reload_regs_init (struct insn_chain *chain, rtx *save_reload_reg_rtx)\n \t\t\t      rld[i].when_needed, rld[i].mode);\n }\n \n-#ifdef SECONDARY_MEMORY_NEEDED\n /* If X is not a subreg, return it unmodified.  If it is a subreg,\n    look up whether we made a replacement for the SUBREG_REG.  Return\n    either the replacement or the SUBREG_REG.  */\n@@ -6343,7 +6340,6 @@ replaced_subreg (rtx x)\n     return find_replacement (&SUBREG_REG (x));\n   return x;\n }\n-#endif\n \n /* Compute the offset to pass to subreg_regno_offset, for a pseudo of\n    mode OUTERMODE that is available in a hard reg of mode INNERMODE.\n@@ -6593,12 +6589,8 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t\t      && (secondary_reload_class (1, rclass, mode,\n \t\t\t\t\t\t\t  last_reg)\n \t\t\t\t  == NO_REGS)\n-#ifdef SECONDARY_MEMORY_NEEDED\n-\t\t\t      && ! SECONDARY_MEMORY_NEEDED (last_class, rclass,\n-\t\t\t\t\t\t\t    mode)\n-#endif\n-\t\t\t      ))\n-\n+\t\t\t      && !(targetm.secondary_memory_needed\n+\t\t\t\t   (mode, last_class, rclass))))\n \t\t      && (rld[r].nregs == max_group_size\n \t\t\t  || ! TEST_HARD_REG_BIT (reg_class_contents[(int) group_class],\n \t\t\t\t\t\t  i))\n@@ -6973,9 +6965,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t{\n \t  int r = reload_order[j];\n \t  rtx check_reg;\n-#ifdef SECONDARY_MEMORY_NEEDED\n \t  rtx tem;\n-#endif\n \t  if (reload_inherited[r] && rld[r].reg_rtx)\n \t    check_reg = rld[r].reg_rtx;\n \t  else if (reload_override_in[r]\n@@ -7014,23 +7004,22 @@ choose_reload_regs (struct insn_chain *chain)\n \t      if (pass)\n \t        pass = 2;\n \t    }\n-#ifdef SECONDARY_MEMORY_NEEDED\n \t  /* If we needed a memory location for the reload, we also have to\n \t     remove its related reloads.  */\n \t  else if (rld[r].in\n \t\t   && rld[r].out != rld[r].in\n \t\t   && (tem = replaced_subreg (rld[r].in), REG_P (tem))\t\t   \n \t\t   && REGNO (tem) < FIRST_PSEUDO_REGISTER\n-\t\t   && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (REGNO (tem)),\n-\t\t\t\t\t       rld[r].rclass, rld[r].inmode)\n+\t\t   && (targetm.secondary_memory_needed\n+\t\t       (rld[r].inmode, REGNO_REG_CLASS (REGNO (tem)),\n+\t\t\trld[r].rclass))\n \t\t   && remove_address_replacements\n \t\t      (get_secondary_mem (tem, rld[r].inmode, rld[r].opnum,\n \t\t\t\t\t  rld[r].when_needed)))\n \t    {\n \t      if (pass)\n \t        pass = 2;\n \t    }\n-#endif\n \t}\n     }\n \n@@ -8535,9 +8524,7 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n {\n   rtx_insn *last = get_last_insn ();\n   rtx_insn *tem;\n-#ifdef SECONDARY_MEMORY_NEEDED\n   rtx tem1, tem2;\n-#endif\n \n   /* If IN is a paradoxical SUBREG, remove it and try to put the\n      opposite SUBREG on OUT.  Likewise for a paradoxical SUBREG on OUT.  */\n@@ -8673,15 +8660,14 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n       set_dst_reg_note (insn, REG_EQUIV, in, out);\n     }\n \n-#ifdef SECONDARY_MEMORY_NEEDED\n   /* If we need a memory location to do the move, do it that way.  */\n   else if ((tem1 = replaced_subreg (in), tem2 = replaced_subreg (out),\n \t    (REG_P (tem1) && REG_P (tem2)))\n \t   && REGNO (tem1) < FIRST_PSEUDO_REGISTER\n \t   && REGNO (tem2) < FIRST_PSEUDO_REGISTER\n-\t   && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (REGNO (tem1)),\n-\t\t\t\t       REGNO_REG_CLASS (REGNO (tem2)),\n-\t\t\t\t       GET_MODE (out)))\n+\t   && targetm.secondary_memory_needed (GET_MODE (out),\n+\t\t\t\t\t       REGNO_REG_CLASS (REGNO (tem1)),\n+\t\t\t\t\t       REGNO_REG_CLASS (REGNO (tem2))))\n     {\n       /* Get the memory to use and rewrite both registers to its mode.  */\n       rtx loc = get_secondary_mem (in, GET_MODE (out), opnum, type);\n@@ -8695,7 +8681,6 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n       gen_reload (loc, in, opnum, type);\n       gen_reload (out, loc, opnum, type);\n     }\n-#endif\n   else if (REG_P (out) && UNARY_P (in))\n     {\n       rtx op1;"}, {"sha": "95a7195f5c83b6ebf50db7bcc1bf651b5664795c", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -913,7 +913,8 @@ extern void fancy_abort (const char *, int, const char *)\n \tSTORE_BY_PIECES_P TARGET_FLT_EVAL_METHOD\t\t\t\\\n \tHARD_REGNO_CALL_PART_CLOBBERED HARD_REGNO_MODE_OK\t\t\\\n \tMODES_TIEABLE_P FUNCTION_ARG_PADDING SLOW_UNALIGNED_ACCESS\t\\\n-\tHARD_REGNO_NREGS SECONDARY_MEMORY_NEEDED_MODE\n+\tHARD_REGNO_NREGS SECONDARY_MEMORY_NEEDED_MODE\t\t\t\\\n+\tSECONDARY_MEMORY_NEEDED\n \n /* Target macros only used for code built for the target, that have\n    moved to libgcc-tm.h or have never been present elsewhere.  */"}, {"sha": "350d98425d8ba3e320bbed021f4a857705675354", "filename": "gcc/target.def", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15643d4ea7103ad1bd9ef893f4c211624e1614d/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=f15643d4ea7103ad1bd9ef893f4c211624e1614d", "patch": "@@ -5252,7 +5252,7 @@ in memory and the hard register number if it is in a register.\\n\\\n \\n\\\n Scratch operands in memory (constraint @code{\\\"=m\\\"} / @code{\\\"=&m\\\"}) are\\n\\\n currently not supported.  For the time being, you will have to continue\\n\\\n-to use @code{SECONDARY_MEMORY_NEEDED} for that purpose.\\n\\\n+to use @code{TARGET_SECONDARY_MEMORY_NEEDED} for that purpose.\\n\\\n \\n\\\n @code{copy_cost} also uses this target hook to find out how values are\\n\\\n copied.  If you want it to include some extra cost for the need to allocate\\n\\\n@@ -5265,9 +5265,21 @@ forwarding logic, you can set @code{sri->extra_cost} to a negative amount.\",\n   secondary_reload_info *sri),\n  default_secondary_reload)\n \n+DEFHOOK\n+(secondary_memory_needed,\n+ \"Certain machines have the property that some registers cannot be copied\\n\\\n+to some other registers without using memory.  Define this hook on\\n\\\n+those machines to return true if objects of mode @var{m} in registers\\n\\\n+of @var{class1} can only be copied to registers of class @var{class2} by\\n\\\n+ storing a register of @var{class1} into memory and loading that memory\\n\\\n+location into a register of @var{class2}.  The default definition returns\\n\\\n+false for all inputs.\",\n+ bool, (machine_mode mode, reg_class_t class1, reg_class_t class2),\n+ hook_bool_mode_reg_class_t_reg_class_t_false)\n+\n DEFHOOK\n (secondary_memory_needed_mode,\n- \"If @code{SECONDARY_MEMORY_NEEDED} tells the compiler to use memory\\n\\\n+ \"If @code{TARGET_SECONDARY_MEMORY_NEEDED} tells the compiler to use memory\\n\\\n when moving between two particular registers of mode @var{mode},\\n\\\n this hook specifies the mode that the memory should have.\\n\\\n \\n\\"}]}