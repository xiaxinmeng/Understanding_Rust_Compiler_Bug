{"sha": "f8e1995a5bd72a8578902d05841537e7a34c27c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhlMTk5NWE1YmQ3MmE4NTc4OTAyZDA1ODQxNTM3ZTdhMzRjMjdjMA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2010-07-08T16:31:30Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-07-08T16:31:30Z"}, "message": "i386.c: Use short syntax for function calls through function pointers.\n\n\t* config/i386/i386.c: Use short syntax for function calls\n\tthrough function pointers.\n\t* config/i386/i386.md: Ditto.\n\nFrom-SVN: r161962", "tree": {"sha": "3f485e5efbfc0dd9a4edb2bef7c4333c1f63ea74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f485e5efbfc0dd9a4edb2bef7c4333c1f63ea74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8e1995a5bd72a8578902d05841537e7a34c27c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e1995a5bd72a8578902d05841537e7a34c27c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e1995a5bd72a8578902d05841537e7a34c27c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e1995a5bd72a8578902d05841537e7a34c27c0/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a80903ff487fc462b96e9ae461a107a05eaacd64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a80903ff487fc462b96e9ae461a107a05eaacd64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a80903ff487fc462b96e9ae461a107a05eaacd64"}], "stats": {"total": 172, "additions": 89, "deletions": 83}, "files": [{"sha": "7cdc860a34e8a0c4a30025198c61897bc59335ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e1995a5bd72a8578902d05841537e7a34c27c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e1995a5bd72a8578902d05841537e7a34c27c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8e1995a5bd72a8578902d05841537e7a34c27c0", "patch": "@@ -1,3 +1,9 @@\n+2010-07-08  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c: Use short syntax for function calls\n+\tthrough function pointers.\n+\t* config/i386/i386.md: Ditto.\n+\n 2010-07-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* emit-rtl.c (set_mem_attributes_minus_bitpos): Fix formatting issues.\n@@ -441,7 +447,7 @@\n 2010-07-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (immediate_operand): New mode attribute.\n-\t\n+\n \t(pro_epilogue_adjust_stack_<mode>_1): Macroize insn from\n \tpro_epilogue_adjust_stack  and pro_epilogue_adjust_stack_rex64\n \tusing P mode iterator."}, {"sha": "83bf4c114f7649707aa6ac838f7566688549929b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e1995a5bd72a8578902d05841537e7a34c27c0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e1995a5bd72a8578902d05841537e7a34c27c0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f8e1995a5bd72a8578902d05841537e7a34c27c0", "patch": "@@ -6937,7 +6937,7 @@ ix86_build_builtin_va_list_abi (enum calling_abi abi)\n   if (!TARGET_64BIT || abi == MS_ABI)\n     return build_pointer_type (char_type_node);\n \n-  record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  record = lang_hooks.types.make_type (RECORD_TYPE);\n   type_decl = build_decl (BUILTINS_LOCATION,\n \t\t\t  TYPE_DECL, get_identifier (\"__va_list_tag\"), record);\n \n@@ -7926,10 +7926,10 @@ ix86_code_end (void)\n \t{\n \t  DECL_COMDAT_GROUP (decl) = DECL_ASSEMBLER_NAME (decl);\n \n-\t  (*targetm.asm_out.unique_section) (decl, 0);\n+\t  targetm.asm_out.unique_section (decl, 0);\n \t  switch_to_section (get_named_section (decl, NULL, 0));\n \n-\t  (*targetm.asm_out.globalize_label) (asm_out_file, name);\n+\t  targetm.asm_out.globalize_label (asm_out_file, name);\n \t  fputs (\"\\t.hidden\\t\", asm_out_file);\n \t  assemble_name (asm_out_file, name);\n \t  putc ('\\n', asm_out_file);\n@@ -8020,8 +8020,8 @@ output_set_got (rtx dest, rtx label ATTRIBUTE_UNUSED)\n \tASM_OUTPUT_LABEL (asm_out_file, MACHOPIC_FUNCTION_BASE_NAME);\n #endif\n \n-      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t CODE_LABEL_NUMBER (XEXP (xops[2], 0)));\n+      targetm.asm_out.internal_label (asm_out_file, \"L\",\n+\t\t\t\t      CODE_LABEL_NUMBER (XEXP (xops[2], 0)));\n \n       if (flag_pic)\n \t{\n@@ -9191,7 +9191,7 @@ ix86_expand_prologue (void)\n \t   the base pointer again, align the stack, and later regenerate\n \t   the frame pointer setup.  The frame pointer generated by the\n \t   hook prologue is not aligned, so it can't be used.  */\n-\tinsn = emit_insn ((*ix86_gen_pop1) (hard_frame_pointer_rtx));\n+\tinsn = emit_insn (ix86_gen_pop1 (hard_frame_pointer_rtx));\n     }\n \n   /* The first insn of a function that accepts its static chain on the\n@@ -9246,9 +9246,9 @@ ix86_expand_prologue (void)\n       ix86_cfa_state->reg = crtl->drap_reg;\n \n       /* Align the stack.  */\n-      insn = emit_insn ((*ix86_gen_andsp) (stack_pointer_rtx,\n-\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t   GEN_INT (-align_bytes)));\n+      insn = emit_insn (ix86_gen_andsp (stack_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (-align_bytes)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n       /* Replicate the return address on the stack so that return\n@@ -9283,9 +9283,9 @@ ix86_expand_prologue (void)\n       gcc_assert (align_bytes > MIN_STACK_BOUNDARY / BITS_PER_UNIT);\n \n       /* Align the stack.  */\n-      insn = emit_insn ((*ix86_gen_andsp) (stack_pointer_rtx,\n-\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t   GEN_INT (-align_bytes)));\n+      insn = emit_insn (ix86_gen_andsp (stack_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (-align_bytes)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n@@ -9360,7 +9360,7 @@ ix86_expand_prologue (void)\n \n       emit_move_insn (eax, GEN_INT (allocate));\n \n-      insn = emit_insn ((*ix86_gen_allocate_stack_worker) (eax, eax));\n+      insn = emit_insn (ix86_gen_allocate_stack_worker (eax, eax));\n \n       if (ix86_cfa_state->reg == stack_pointer_rtx)\n \t{\n@@ -19785,7 +19785,7 @@ ix86_expand_strlensi_unroll_1 (rtx out, rtx src, rtx align_rtx)\n \t\t\t       QImode, 1, end_0_label);\n \n       /* Increment the address.  */\n-      emit_insn ((*ix86_gen_add3) (out, out, const1_rtx));\n+      emit_insn (ix86_gen_add3 (out, out, const1_rtx));\n \n       /* Not needed with an alignment of 2 */\n       if (align != 2)\n@@ -19795,15 +19795,15 @@ ix86_expand_strlensi_unroll_1 (rtx out, rtx src, rtx align_rtx)\n \t  emit_cmp_and_jump_insns (mem, const0_rtx, EQ, NULL, QImode, 1,\n \t\t\t\t   end_0_label);\n \n-\t  emit_insn ((*ix86_gen_add3) (out, out, const1_rtx));\n+\t  emit_insn (ix86_gen_add3 (out, out, const1_rtx));\n \n \t  emit_label (align_3_label);\n \t}\n \n       emit_cmp_and_jump_insns (mem, const0_rtx, EQ, NULL, QImode, 1,\n \t\t\t       end_0_label);\n \n-      emit_insn ((*ix86_gen_add3) (out, out, const1_rtx));\n+      emit_insn (ix86_gen_add3 (out, out, const1_rtx));\n     }\n \n   /* Generate loop to check 4 bytes at a time.  It is not a good idea to\n@@ -19813,7 +19813,7 @@ ix86_expand_strlensi_unroll_1 (rtx out, rtx src, rtx align_rtx)\n \n   mem = change_address (src, SImode, out);\n   emit_move_insn (scratch, mem);\n-  emit_insn ((*ix86_gen_add3) (out, out, GEN_INT (4)));\n+  emit_insn (ix86_gen_add3 (out, out, GEN_INT (4)));\n \n   /* This formula yields a nonzero result iff one of the bytes is zero.\n      This saves three branches inside loop and many cycles.  */\n@@ -19868,7 +19868,7 @@ ix86_expand_strlensi_unroll_1 (rtx out, rtx src, rtx align_rtx)\n \n        /* Not in the first two.  Move two bytes forward.  */\n        emit_insn (gen_lshrsi3 (tmpreg, tmpreg, GEN_INT (16)));\n-       emit_insn ((*ix86_gen_add3) (out, out, const2_rtx));\n+       emit_insn (ix86_gen_add3 (out, out, const2_rtx));\n \n        emit_label (end_2_label);\n \n@@ -19879,7 +19879,7 @@ ix86_expand_strlensi_unroll_1 (rtx out, rtx src, rtx align_rtx)\n   emit_insn (gen_addqi3_cc (tmpreg, tmpreg, tmpreg));\n   tmp = gen_rtx_REG (CCmode, FLAGS_REG);\n   cmp = gen_rtx_LTU (VOIDmode, tmp, const0_rtx);\n-  emit_insn ((*ix86_gen_sub3_carry) (out, out, GEN_INT (3), tmp, cmp));\n+  emit_insn (ix86_gen_sub3_carry (out, out, GEN_INT (3), tmp, cmp));\n \n   emit_label (end_0_label);\n }\n@@ -19921,7 +19921,7 @@ ix86_expand_strlen (rtx out, rtx src, rtx eoschar, rtx align)\n       /* strlensi_unroll_1 returns the address of the zero at the end of\n          the string, like memchr(), so compute the length by subtracting\n          the start address.  */\n-      emit_insn ((*ix86_gen_sub3) (out, out, addr));\n+      emit_insn (ix86_gen_sub3 (out, out, addr));\n     }\n   else\n     {\n@@ -19944,8 +19944,8 @@ ix86_expand_strlen (rtx out, rtx src, rtx eoschar, rtx align)\n       unspec = gen_rtx_UNSPEC (Pmode, gen_rtvec (4, src, eoschar, align,\n \t\t\t\t\t\t scratch4), UNSPEC_SCAS);\n       emit_insn (gen_strlenqi_1 (scratch1, scratch3, unspec));\n-      emit_insn ((*ix86_gen_one_cmpl2) (scratch2, scratch1));\n-      emit_insn ((*ix86_gen_add3) (out, scratch2, constm1_rtx));\n+      emit_insn (ix86_gen_one_cmpl2 (scratch2, scratch1));\n+      emit_insn (ix86_gen_add3 (out, scratch2, constm1_rtx));\n     }\n   return 1;\n }\n@@ -23557,13 +23557,13 @@ ix86_init_builtin_types (void)\n       TYPE_PRECISION (float80_type_node) = 80;\n       layout_type (float80_type_node);\n     }\n-  (*lang_hooks.types.register_builtin_type) (float80_type_node, \"__float80\");\n+  lang_hooks.types.register_builtin_type (float80_type_node, \"__float80\");\n \n   /* The __float128 type.  */\n   float128_type_node = make_node (REAL_TYPE);\n   TYPE_PRECISION (float128_type_node) = 128;\n   layout_type (float128_type_node);\n-  (*lang_hooks.types.register_builtin_type) (float128_type_node, \"__float128\");\n+  lang_hooks.types.register_builtin_type (float128_type_node, \"__float128\");\n \n   /* This macro is built by i386-builtin-types.awk.  */\n   DEFINE_BUILTIN_PRIMITIVE_TYPES;\n@@ -23645,7 +23645,7 @@ ix86_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n \n   if (optimize || !target\n       || GET_MODE (target) != tmode\n-      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+      || !insn_data[icode].operand[0].predicate (target, tmode))\n     target = gen_reg_rtx (tmode);\n \n   if (GET_MODE (op1) == SImode && mode1 == TImode)\n@@ -23655,9 +23655,9 @@ ix86_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n       op1 = gen_lowpart (TImode, x);\n     }\n \n-  if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n+  if (!insn_data[icode].operand[1].predicate (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n-  if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n+  if (!insn_data[icode].operand[2].predicate (op1, mode1))\n     op1 = copy_to_mode_reg (mode1, op1);\n \n   pat = GEN_FCN (icode) (target, op0, op1);\n@@ -23775,7 +23775,7 @@ ix86_expand_multi_arg_builtin (enum insn_code icode, tree exp, rtx target,\n \n   if (optimize || !target\n       || GET_MODE (target) != tmode\n-      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+      || !insn_data[icode].operand[0].predicate (target, tmode))\n     target = gen_reg_rtx (tmode);\n \n   gcc_assert (nargs <= 4);\n@@ -23808,7 +23808,7 @@ ix86_expand_multi_arg_builtin (enum insn_code icode, tree exp, rtx target,\n \t  gcc_assert (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode);\n \n \t  if (optimize\n-\t      || ! (*insn_data[icode].operand[i+adjust+1].predicate) (op, mode)\n+\t      || !insn_data[icode].operand[i+adjust+1].predicate (op, mode)\n \t      || num_memory > 1)\n \t    op = force_reg (mode, op);\n \t}\n@@ -23873,18 +23873,18 @@ ix86_expand_unop_vec_merge_builtin (enum insn_code icode, tree exp,\n \n   if (optimize || !target\n       || GET_MODE (target) != tmode\n-      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+      || !insn_data[icode].operand[0].predicate (target, tmode))\n     target = gen_reg_rtx (tmode);\n \n   if (VECTOR_MODE_P (mode0))\n     op0 = safe_vector_operand (op0, mode0);\n \n   if ((optimize && !register_operand (op0, mode0))\n-      || ! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+      || !insn_data[icode].operand[1].predicate (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n \n   op1 = op0;\n-  if (! (*insn_data[icode].operand[2].predicate) (op1, mode0))\n+  if (!insn_data[icode].operand[2].predicate (op1, mode0))\n     op1 = copy_to_mode_reg (mode0, op1);\n \n   pat = GEN_FCN (icode) (target, op0, op1);\n@@ -23928,14 +23928,14 @@ ix86_expand_sse_compare (const struct builtin_description *d,\n \n   if (optimize || !target\n       || GET_MODE (target) != tmode\n-      || ! (*insn_data[d->icode].operand[0].predicate) (target, tmode))\n+      || !insn_data[d->icode].operand[0].predicate (target, tmode))\n     target = gen_reg_rtx (tmode);\n \n   if ((optimize && !register_operand (op0, mode0))\n-      || ! (*insn_data[d->icode].operand[1].predicate) (op0, mode0))\n+      || !insn_data[d->icode].operand[1].predicate (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n   if ((optimize && !register_operand (op1, mode1))\n-      || ! (*insn_data[d->icode].operand[2].predicate) (op1, mode1))\n+      || !insn_data[d->icode].operand[2].predicate (op1, mode1))\n     op1 = copy_to_mode_reg (mode1, op1);\n \n   op2 = gen_rtx_fmt_ee (comparison, mode0, op0, op1);\n@@ -23980,10 +23980,10 @@ ix86_expand_sse_comi (const struct builtin_description *d, tree exp,\n   target = gen_rtx_SUBREG (QImode, target, 0);\n \n   if ((optimize && !register_operand (op0, mode0))\n-      || !(*insn_data[d->icode].operand[0].predicate) (op0, mode0))\n+      || !insn_data[d->icode].operand[0].predicate (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n   if ((optimize && !register_operand (op1, mode1))\n-      || !(*insn_data[d->icode].operand[1].predicate) (op1, mode1))\n+      || !insn_data[d->icode].operand[1].predicate (op1, mode1))\n     op1 = copy_to_mode_reg (mode1, op1);\n \n   pat = GEN_FCN (d->icode) (op0, op1);\n@@ -24024,10 +24024,10 @@ ix86_expand_sse_ptest (const struct builtin_description *d, tree exp,\n   target = gen_rtx_SUBREG (QImode, target, 0);\n \n   if ((optimize && !register_operand (op0, mode0))\n-      || !(*insn_data[d->icode].operand[0].predicate) (op0, mode0))\n+      || !insn_data[d->icode].operand[0].predicate (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n   if ((optimize && !register_operand (op1, mode1))\n-      || !(*insn_data[d->icode].operand[1].predicate) (op1, mode1))\n+      || !insn_data[d->icode].operand[1].predicate (op1, mode1))\n     op1 = copy_to_mode_reg (mode1, op1);\n \n   pat = GEN_FCN (d->icode) (op0, op1);\n@@ -24076,17 +24076,17 @@ ix86_expand_sse_pcmpestr (const struct builtin_description *d,\n   if (VECTOR_MODE_P (modev4))\n     op2 = safe_vector_operand (op2, modev4);\n \n-  if (! (*insn_data[d->icode].operand[2].predicate) (op0, modev2))\n+  if (!insn_data[d->icode].operand[2].predicate (op0, modev2))\n     op0 = copy_to_mode_reg (modev2, op0);\n-  if (! (*insn_data[d->icode].operand[3].predicate) (op1, modei3))\n+  if (!insn_data[d->icode].operand[3].predicate (op1, modei3))\n     op1 = copy_to_mode_reg (modei3, op1);\n   if ((optimize && !register_operand (op2, modev4))\n-      || !(*insn_data[d->icode].operand[4].predicate) (op2, modev4))\n+      || !insn_data[d->icode].operand[4].predicate (op2, modev4))\n     op2 = copy_to_mode_reg (modev4, op2);\n-  if (! (*insn_data[d->icode].operand[5].predicate) (op3, modei5))\n+  if (!insn_data[d->icode].operand[5].predicate (op3, modei5))\n     op3 = copy_to_mode_reg (modei5, op3);\n \n-  if (! (*insn_data[d->icode].operand[6].predicate) (op4, modeimm))\n+  if (!insn_data[d->icode].operand[6].predicate (op4, modeimm))\n     {\n       error (\"the fifth argument must be a 8-bit immediate\");\n       return const0_rtx;\n@@ -24096,7 +24096,7 @@ ix86_expand_sse_pcmpestr (const struct builtin_description *d,\n     {\n       if (optimize || !target\n \t  || GET_MODE (target) != tmode0\n-\t  || ! (*insn_data[d->icode].operand[0].predicate) (target, tmode0))\n+\t  || !insn_data[d->icode].operand[0].predicate (target, tmode0))\n \ttarget = gen_reg_rtx (tmode0);\n \n       scratch1 = gen_reg_rtx (tmode1);\n@@ -24107,7 +24107,7 @@ ix86_expand_sse_pcmpestr (const struct builtin_description *d,\n     {\n       if (optimize || !target\n \t  || GET_MODE (target) != tmode1\n-\t  || ! (*insn_data[d->icode].operand[1].predicate) (target, tmode1))\n+\t  || !insn_data[d->icode].operand[1].predicate (target, tmode1))\n \ttarget = gen_reg_rtx (tmode1);\n \n       scratch0 = gen_reg_rtx (tmode0);\n@@ -24175,13 +24175,13 @@ ix86_expand_sse_pcmpistr (const struct builtin_description *d,\n   if (VECTOR_MODE_P (modev3))\n     op1 = safe_vector_operand (op1, modev3);\n \n-  if (! (*insn_data[d->icode].operand[2].predicate) (op0, modev2))\n+  if (!insn_data[d->icode].operand[2].predicate (op0, modev2))\n     op0 = copy_to_mode_reg (modev2, op0);\n   if ((optimize && !register_operand (op1, modev3))\n-      || !(*insn_data[d->icode].operand[3].predicate) (op1, modev3))\n+      || !insn_data[d->icode].operand[3].predicate (op1, modev3))\n     op1 = copy_to_mode_reg (modev3, op1);\n \n-  if (! (*insn_data[d->icode].operand[4].predicate) (op2, modeimm))\n+  if (!insn_data[d->icode].operand[4].predicate (op2, modeimm))\n     {\n       error (\"the third argument must be a 8-bit immediate\");\n       return const0_rtx;\n@@ -24191,7 +24191,7 @@ ix86_expand_sse_pcmpistr (const struct builtin_description *d,\n     {\n       if (optimize || !target\n \t  || GET_MODE (target) != tmode0\n-\t  || ! (*insn_data[d->icode].operand[0].predicate) (target, tmode0))\n+\t  || !insn_data[d->icode].operand[0].predicate (target, tmode0))\n \ttarget = gen_reg_rtx (tmode0);\n \n       scratch1 = gen_reg_rtx (tmode1);\n@@ -24202,7 +24202,7 @@ ix86_expand_sse_pcmpistr (const struct builtin_description *d,\n     {\n       if (optimize || !target\n \t  || GET_MODE (target) != tmode1\n-\t  || ! (*insn_data[d->icode].operand[1].predicate) (target, tmode1))\n+\t  || !insn_data[d->icode].operand[1].predicate (target, tmode1))\n \ttarget = gen_reg_rtx (tmode1);\n \n       scratch0 = gen_reg_rtx (tmode0);\n@@ -24497,7 +24497,7 @@ ix86_expand_args_builtin (const struct builtin_description *d,\n       if (optimize\n \t  || target == 0\n \t  || GET_MODE (target) != tmode\n-\t  || ! (*insn_p->operand[0].predicate) (target, tmode))\n+\t  || !insn_p->operand[0].predicate (target, tmode))\n \ttarget = gen_reg_rtx (tmode);\n       real_target = target;\n     }\n@@ -24512,7 +24512,7 @@ ix86_expand_args_builtin (const struct builtin_description *d,\n       tree arg = CALL_EXPR_ARG (exp, i);\n       rtx op = expand_normal (arg);\n       enum machine_mode mode = insn_p->operand[i + 1].mode;\n-      bool match = (*insn_p->operand[i + 1].predicate) (op, mode);\n+      bool match = insn_p->operand[i + 1].predicate (op, mode);\n \n       if (last_arg_count && (i + 1) == nargs)\n \t{\n@@ -24522,7 +24522,7 @@ ix86_expand_args_builtin (const struct builtin_description *d,\n \t  if (!match)\n \t    {\n \t      op = simplify_gen_subreg (SImode, op, GET_MODE (op), 0);\n-\t      if (!(*insn_p->operand[i + 1].predicate) (op, mode))\n+\t      if (!insn_p->operand[i + 1].predicate (op, mode))\n \t\top = copy_to_reg (op);\n \t    }\n \t}\n@@ -24767,7 +24767,7 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n       if (optimize\n \t  || target == 0\n \t  || GET_MODE (target) != tmode\n-\t  || ! (*insn_p->operand[0].predicate) (target, tmode))\n+\t  || !insn_p->operand[0].predicate (target, tmode))\n \ttarget = gen_reg_rtx (tmode);\n     }\n \n@@ -24778,7 +24778,7 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n \n       arg = CALL_EXPR_ARG (exp, i + arg_adjust);\n       op = expand_normal (arg);\n-      match = (*insn_p->operand[i + 1].predicate) (op, mode);\n+      match = insn_p->operand[i + 1].predicate (op, mode);\n \n       if (last_arg_constant && (i + 1) == nargs)\n \t{\n@@ -25028,11 +25028,11 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       op0 = force_reg (Pmode, op0);\n       op0 = gen_rtx_MEM (mode1, op0);\n \n-      if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n+      if (!insn_data[icode].operand[0].predicate (op0, mode0))\n \top0 = copy_to_mode_reg (mode0, op0);\n-      if (! (*insn_data[icode].operand[1].predicate) (op1, mode1))\n+      if (!insn_data[icode].operand[1].predicate (op1, mode1))\n \top1 = copy_to_mode_reg (mode1, op1);\n-      if (! (*insn_data[icode].operand[2].predicate) (op2, mode2))\n+      if (!insn_data[icode].operand[2].predicate (op2, mode2))\n \top2 = copy_to_mode_reg (mode2, op2);\n       pat = GEN_FCN (icode) (op0, op1, op2);\n       if (! pat)\n@@ -25056,7 +25056,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \targ0 = CALL_EXPR_ARG (exp, 0);\n \top0 = expand_normal (arg0);\n \ticode = CODE_FOR_sse2_clflush;\n-\tif (! (*insn_data[icode].operand[0].predicate) (op0, Pmode))\n+\tif (!insn_data[icode].operand[0].predicate (op0, Pmode))\n \t    op0 = copy_to_mode_reg (Pmode, op0);\n \n \temit_insn (gen_sse2_clflush (op0));\n@@ -25075,7 +25075,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \top1 = copy_to_mode_reg (SImode, op1);\n       if (!REG_P (op2))\n \top2 = copy_to_mode_reg (SImode, op2);\n-      emit_insn ((*ix86_gen_monitor) (op0, op1, op2));\n+      emit_insn (ix86_gen_monitor (op0, op1, op2));\n       return 0;\n \n     case IX86_BUILTIN_MWAIT:\n@@ -25149,15 +25149,15 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       arg0 = CALL_EXPR_ARG (exp, 0);\n       op0 = expand_normal (arg0);\n       icode = CODE_FOR_lwp_llwpcb;\n-      if (! (*insn_data[icode].operand[0].predicate) (op0, Pmode))\n+      if (!insn_data[icode].operand[0].predicate (op0, Pmode))\n \top0 = copy_to_mode_reg (Pmode, op0);\n       emit_insn (gen_lwp_llwpcb (op0));\n       return 0;\n \n     case IX86_BUILTIN_SLWPCB:\n       icode = CODE_FOR_lwp_slwpcb;\n       if (!target\n-\t  || ! (*insn_data[icode].operand[0].predicate) (target, Pmode))\n+\t  || !insn_data[icode].operand[0].predicate (target, Pmode))\n \ttarget = gen_reg_rtx (Pmode);\n       emit_insn (gen_lwp_slwpcb (target));\n       return target;\n@@ -25278,8 +25278,8 @@ ix86_builtin_vectorized_function (tree fndecl, tree type_out,\n \n   /* Dispatch to a handler for a vectorization library.  */\n   if (ix86_veclib_handler)\n-    return (*ix86_veclib_handler) ((enum built_in_function) fn, type_out,\n-\t\t\t\t   type_in);\n+    return ix86_veclib_handler ((enum built_in_function) fn, type_out,\n+\t\t\t\ttype_in);\n \n   return NULL_TREE;\n }\n@@ -26786,7 +26786,7 @@ machopic_output_stub (FILE *file, const char *symb, const char *stub)\n   gcc_assert (!TARGET_64BIT);\n \n   /* Lose our funky encoding stuff so it doesn't contaminate the stub.  */\n-  symb = (*targetm.strip_name_encoding) (symb);\n+  symb = targetm.strip_name_encoding (symb);\n \n   length = strlen (stub);\n   binder_name = XALLOCAVEC (char, length + 32);\n@@ -27071,7 +27071,7 @@ x86_can_output_mi_thunk (const_tree thunk ATTRIBUTE_UNUSED,\n     return false;\n \n   /* Need a free register for GOT references.  */\n-  if (flag_pic && !(*targetm.binds_local_p) (function))\n+  if (flag_pic && !targetm.binds_local_p (function))\n     return false;\n \n   /* Otherwise ok.  */\n@@ -27181,7 +27181,7 @@ x86_output_mi_thunk (FILE *file,\n   xops[0] = XEXP (DECL_RTL (function), 0);\n   if (TARGET_64BIT)\n     {\n-      if (!flag_pic || (*targetm.binds_local_p) (function))\n+      if (!flag_pic || targetm.binds_local_p (function))\n \toutput_asm_insn (\"jmp\\t%P0\", xops);\n       /* All thunks should be in the same object as their target,\n \t and thus binds_local_p should be true.  */\n@@ -27198,7 +27198,7 @@ x86_output_mi_thunk (FILE *file,\n     }\n   else\n     {\n-      if (!flag_pic || (*targetm.binds_local_p) (function))\n+      if (!flag_pic || targetm.binds_local_p (function))\n \toutput_asm_insn (\"jmp\\t%P0\", xops);\n       else\n #if TARGET_MACHO\n@@ -28252,10 +28252,10 @@ ix86_expand_vector_init_interleave (enum machine_mode mode,\n       emit_move_insn (op0, gen_lowpart (mode, op1));\n \n       /* Load even elements into the second positon.  */\n-      emit_insn ((*gen_load_even) (op0,\n-\t\t\t\t   force_reg (inner_mode,\n-\t\t\t\t\t      ops [i + i + 1]),\n-\t\t\t\t   const1_rtx));\n+      emit_insn (gen_load_even (op0,\n+\t\t\t\tforce_reg (inner_mode,\n+\t\t\t\t\t   ops [i + i + 1]),\n+\t\t\t\tconst1_rtx));\n \n       /* Cast vector to FIRST_IMODE vector.  */\n       ops[i] = gen_reg_rtx (first_imode);\n@@ -28266,7 +28266,7 @@ ix86_expand_vector_init_interleave (enum machine_mode mode,\n   for (i = j = 0; i < n; i += 2, j++)\n     {\n       op0 = gen_reg_rtx (first_imode);\n-      emit_insn ((*gen_interleave_first_low) (op0, ops[i], ops[i + 1]));\n+      emit_insn (gen_interleave_first_low (op0, ops[i], ops[i + 1]));\n \n       /* Cast FIRST_IMODE vector to SECOND_IMODE vector.  */\n       ops[j] = gen_reg_rtx (second_imode);\n@@ -28280,8 +28280,8 @@ ix86_expand_vector_init_interleave (enum machine_mode mode,\n       for (i = j = 0; i < n / 2; i += 2, j++)\n \t{\n \t  op0 = gen_reg_rtx (second_imode);\n-\t  emit_insn ((*gen_interleave_second_low) (op0, ops[i],\n-\t\t\t\t\t\t   ops[i + 1]));\n+\t  emit_insn (gen_interleave_second_low (op0, ops[i],\n+\t\t\t\t\t\tops[i + 1]));\n \n \t  /* Cast the SECOND_IMODE vector to the THIRD_IMODE\n \t     vector.  */\n@@ -28294,8 +28294,8 @@ ix86_expand_vector_init_interleave (enum machine_mode mode,\n \n     case V2DImode:\n       op0 = gen_reg_rtx (second_imode);\n-      emit_insn ((*gen_interleave_second_low) (op0, ops[0],\n-\t\t\t\t\t       ops[1]));\n+      emit_insn (gen_interleave_second_low (op0, ops[0],\n+\t\t\t\t\t    ops[1]));\n \n       /* Cast the SECOND_IMODE vector back to a vector on original\n \t mode.  */\n@@ -28726,13 +28726,13 @@ ix86_expand_vector_set (bool mmx_ok, rtx target, rtx val, int elt)\n \n       /* Extract the half.  */\n       tmp = gen_reg_rtx (half_mode);\n-      emit_insn ((*gen_extract[j][i]) (tmp, target));\n+      emit_insn (gen_extract[j][i] (tmp, target));\n \n       /* Put val in tmp at elt.  */\n       ix86_expand_vector_set (false, tmp, val, elt);\n \n       /* Put it back.  */\n-      emit_insn ((*gen_insert[j][i]) (target, target, tmp));\n+      emit_insn (gen_insert[j][i] (target, target, tmp));\n       return;\n \n     default:"}, {"sha": "88b40295d66e17934ae867ce80a94cc38ea2b6a8", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8e1995a5bd72a8578902d05841537e7a34c27c0/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8e1995a5bd72a8578902d05841537e7a34c27c0/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f8e1995a5bd72a8578902d05841537e7a34c27c0", "patch": "@@ -17981,8 +17981,8 @@\n       else\n         output_asm_insn (\"%vmovaps\\t{%5, %4|%4, %5}\", operands);\n     }\n-  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t     CODE_LABEL_NUMBER (operands[3]));\n+  targetm.asm_out.internal_label (asm_out_file, \"L\",\n+\t\t\t\t  CODE_LABEL_NUMBER (operands[3]));\n   return \"\";\n }\n   [(set_attr \"type\" \"other\")"}]}