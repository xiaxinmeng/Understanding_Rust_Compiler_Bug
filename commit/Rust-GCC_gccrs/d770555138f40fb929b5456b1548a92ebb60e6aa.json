{"sha": "d770555138f40fb929b5456b1548a92ebb60e6aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc3MDU1NTEzOGY0MGZiOTI5YjU0NTZiMTU0OGE5MmViYjYwZTZhYQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2007-11-13T15:20:40Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2007-11-13T15:20:40Z"}, "message": "pr 33870\n\n\n\tpr 33870\n\t* tree.h (strcut tree_memory_tag): add field unpartitionable.\n\tremove field in_nested_struct.\n\t(struct tree_struct_field_tag): add field nesting_level.\n\t(sft_in_nested_struct): remove.\n\t(sft_nesting_level): define.\n\t(sft_unpartitionable_p): define.\n\t* tree-ssa-alias.c (mem_sym_score): if mp->var is not\n\tpartitionable, return long_max.\n\t(compute_memory_partitions): do not partition sfts marked\n\tunpartitionable.\n\t(create_sft): add argument nesting_level.  set\n\tsft_nesting_level with it.  update all users.\n\t(create_overlap_variables_for): show nesting level.\n\t* tree-dfa.c (dump_subvars_for): likewise.\n\t(dump_variable): likewise.\n\tshow whether the sft is partitionable or not.\n\t* tree-flow.h (struct fieldoff): remove field\n\tin_nested_struct.\n\tadd field nesting_level.\n\t* tree-ssa-structalias.c (struct variable_info): remove\n\tfield in_nested_struct.\n\t(push_fields_onto_fieldstack): add argument\n\tnesting_level.  update all users.\n\tupdate documentation.\n\tupdate pair->nesting_level with nesting_level.\n\tmake recursive calls with nesting_level + 1.\n\t(set_uids_in_ptset): if an sft is added to the points-to\n\tset, mark it as unpartitionable.\n\t* tree-ssa-operands.c (ref_nesting_level): new.\n\t(add_vars_for_offset): call it.\n\tadd argument full_ref.  update\n\tcallers.\n\tif var is inside a nested structure and the nesting level\n\tof full_ref is lower than the nesting level of var,\n\tadjust offset by the offset of var.\n\ntestsuite/ChangeLog\n\t\n\tPR 33870\n\t* gcc.c-torture/execute/pr33870-1.c: New test.\n\t* gcc.dg/tree-ssa/alias-16.c: New test.\n\nFrom-SVN: r130141", "tree": {"sha": "b04ec56bade931807b6ed40c6d251c05aa588f0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b04ec56bade931807b6ed40c6d251c05aa588f0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d770555138f40fb929b5456b1548a92ebb60e6aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d770555138f40fb929b5456b1548a92ebb60e6aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d770555138f40fb929b5456b1548a92ebb60e6aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d770555138f40fb929b5456b1548a92ebb60e6aa/comments", "author": null, "committer": null, "parents": [{"sha": "0e506c4b4f1efe03e05b80fbc09bb77f474372a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e506c4b4f1efe03e05b80fbc09bb77f474372a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e506c4b4f1efe03e05b80fbc09bb77f474372a1"}], "stats": {"total": 385, "additions": 318, "deletions": 67}, "files": [{"sha": "ffff6ccaa2cad7b39410e9df4dcce7b6958ed5c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d770555138f40fb929b5456b1548a92ebb60e6aa", "patch": "@@ -1,3 +1,42 @@\n+2007-11-13  diego novillo  <dnovillo@google.com>\n+\n+\tpr 33870\n+\t* tree.h (strcut tree_memory_tag): add field unpartitionable.\n+\tremove field in_nested_struct.\n+\t(struct tree_struct_field_tag): add field nesting_level.\n+\t(sft_in_nested_struct): remove.\n+\t(sft_nesting_level): define.\n+\t(sft_unpartitionable_p): define.\n+\t* tree-ssa-alias.c (mem_sym_score): if mp->var is not\n+\tpartitionable, return long_max.\n+\t(compute_memory_partitions): do not partition sfts marked\n+\tunpartitionable.\n+\t(create_sft): add argument nesting_level.  set\n+\tsft_nesting_level with it.  update all users.\n+\t(create_overlap_variables_for): show nesting level.\n+\t* tree-dfa.c (dump_subvars_for): likewise.\n+\t(dump_variable): likewise.\n+\tshow whether the sft is partitionable or not.\n+\t* tree-flow.h (struct fieldoff): remove field\n+\tin_nested_struct.\n+\tadd field nesting_level.\n+\t* tree-ssa-structalias.c (struct variable_info): remove\n+\tfield in_nested_struct.\n+\t(push_fields_onto_fieldstack): add argument\n+\tnesting_level.  update all users.\n+\tupdate documentation.\n+\tupdate pair->nesting_level with nesting_level.\n+\tmake recursive calls with nesting_level + 1.\n+\t(set_uids_in_ptset): if an sft is added to the points-to\n+\tset, mark it as unpartitionable.\n+\t* tree-ssa-operands.c (ref_nesting_level): new.\n+\t(add_vars_for_offset): call it.\n+\tadd argument full_ref.  update\n+\tcallers.\n+\tif var is inside a nested structure and the nesting level\n+\tof full_ref is lower than the nesting level of var,\n+\tadjust offset by the offset of var.\n+\n 2007-11-13  Victor Kaplansky  <victork@il.ibm.com>\n \n \tPR tree-optimization/32582"}, {"sha": "a1166ece4a98679e479a62e3227ab7066d5fe8c2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d770555138f40fb929b5456b1548a92ebb60e6aa", "patch": "@@ -1,3 +1,9 @@\n+2007-11-13  Diego Novillo  <dnovillo@google.com>\n+\n+\tPR 33870\n+\t* gcc.c-torture/execute/pr33870-1.c: New test.\n+\t* gcc.dg/tree-ssa/alias-16.c: New test.\n+\n 2007-11-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/29225"}, {"sha": "af5a40db66b995c2ada21f8616412dbbaa5e9dec", "filename": "gcc/testsuite/gcc.c-torture/execute/pr33870-1.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr33870-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr33870-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr33870-1.c?ref=d770555138f40fb929b5456b1548a92ebb60e6aa", "patch": "@@ -0,0 +1,94 @@\n+extern void abort (void);\n+\n+typedef struct PgHdr PgHdr;\n+typedef unsigned char u8;\n+struct PgHdr {\n+int y;\n+struct {\n+ unsigned int pgno;\n+ PgHdr *pNextHash, *pPrevHash;\n+ PgHdr *pNextFree, *pPrevFree;\n+ PgHdr *pNextAll;\n+ u8 inJournal;\n+ short int nRef;\n+ PgHdr *pDirty, *pPrevDirty;\n+ unsigned int notUsed;\n+} x;\n+};\n+PgHdr **xx;\n+volatile int vx;\n+static inline PgHdr *merge_pagelist(PgHdr *pA, PgHdr *pB)\n+{\n+ PgHdr result;\n+ PgHdr *pTail;\n+ xx = &result.x.pDirty;\n+ pTail = &result;\n+ while( pA && pB ){\n+   if( pA->x.pgno<pB->x.pgno ){\n+     pTail->x.pDirty = pA;\n+     pTail = pA;\n+     pA = pA->x.pDirty;\n+   }else{\n+     pTail->x.pDirty = pB;\n+     pTail = pB;\n+     pB = pB->x.pDirty;\n+   }\n+   vx = (*xx)->y;\n+ }\n+ if( pA ){\n+   pTail->x.pDirty = pA;\n+ }else if( pB ){\n+   pTail->x.pDirty = pB;\n+ }else{\n+   pTail->x.pDirty = 0;\n+ }\n+ return result.x.pDirty;\n+}\n+\n+PgHdr * __attribute__((noinline)) sort_pagelist(PgHdr *pIn)\n+{\n+ PgHdr *a[25], *p;\n+ int i;\n+ __builtin_memset (a, 0, sizeof (a));\n+ while( pIn ){\n+   p = pIn;\n+   pIn = p->x.pDirty;\n+   p->x.pDirty = 0;\n+   for(i=0; i<25 -1; i++){\n+     if( a[i]==0 ){\n+       a[i] = p;\n+       break;\n+     }else{\n+       p = merge_pagelist(a[i], p);\n+       a[i] = 0;\n+       a[i] = 0;\n+     }\n+   }\n+   if( i==25 -1 ){\n+     a[i] = merge_pagelist(a[i], p);\n+   }\n+ }\n+ p = a[0];\n+ for(i=1; i<25; i++){\n+   p = merge_pagelist (p, a[i]);\n+ }\n+ return p;\n+}\n+\n+int main()\n+{\n+ PgHdr a[5];\n+ PgHdr *p;\n+ a[0].x.pgno = 5;\n+ a[0].x.pDirty = &a[1];\n+ a[1].x.pgno = 4;\n+ a[1].x.pDirty = &a[2];\n+ a[2].x.pgno = 1;\n+ a[2].x.pDirty = &a[3];\n+ a[3].x.pgno = 3;\n+ a[3].x.pDirty = 0;\n+ p = sort_pagelist (&a[0]);\n+ if (p->x.pDirty == p)\n+   abort ();\n+ return 0;\n+}"}, {"sha": "cf10fa913ce2a361db72a4a9916f830b37589157", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-16.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-16.c?ref=d770555138f40fb929b5456b1548a92ebb60e6aa", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O --param max-aliased-vops=1\" } */\n+\n+/* Compile with -O --param max-aliased-vops=1.  This partitions all\n+   the initial SFTs for 'm' which was causing the operand scanner to\n+   miss adding the right SFTs to p->b[2].  */\n+extern void abort (void);\n+\n+struct X {\n+    int a;\n+    struct Y {\n+\tint b[4];\n+    } b;\n+    struct Y c;\n+} m;\n+\n+struct X n;\n+\n+foo (int i)\n+{\n+  struct Y *p = (i > 10) ? &m.b : &n.c;\n+  p->b[2] = 10;\n+  m.b.b[3] = 6;\n+  n.c.b[2] = 3;\n+  return p->b[2] + n.c.b[2] + m.b.b[3];\n+}\n+\n+main()\n+{\n+  if (foo (3) != 12)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "65a32d935d1abdce0c6d4ceb024914fe2b668d29", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=d770555138f40fb929b5456b1548a92ebb60e6aa", "patch": "@@ -287,7 +287,9 @@ dump_subvars_for (FILE *file, tree var)\n   for (i = 0; VEC_iterate (tree, sv, i, subvar); ++i)\n     {\n       print_generic_expr (file, subvar, dump_flags);\n-      fprintf (file, \"@\" HOST_WIDE_INT_PRINT_UNSIGNED \" \", SFT_OFFSET (subvar));\n+      fprintf (file, \"@\" HOST_WIDE_INT_PRINT_UNSIGNED, SFT_OFFSET (subvar));\n+      fprintf (file, \"[%u]\", SFT_NESTING_LEVEL (subvar));\n+      fprintf (file, \" \");\n     }\n \n   fprintf (file, \"}\");\n@@ -417,6 +419,15 @@ dump_variable (FILE *file, tree var)\n \t  fprintf (file, \", partition symbols: \");\n \t  dump_decl_set (file, MPT_SYMBOLS (var));\n \t}\n+\n+      if (TREE_CODE (var) == STRUCT_FIELD_TAG)\n+\t{\n+\t  fprintf (file, \", offset: \" HOST_WIDE_INT_PRINT_UNSIGNED,\n+\t\t   SFT_OFFSET (var));\n+\t  fprintf (file, \", nesting: %u\", SFT_NESTING_LEVEL (var));\n+\t  fprintf (file, \", partitionable: %s\",\n+\t\t   SFT_UNPARTITIONABLE_P (var) ? \"NO\" : \"YES\");\n+\t}\n     }\n \n   fprintf (file, \"\\n\");"}, {"sha": "83761951859e1e50ad9267ef3190a3883bf38aea", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d770555138f40fb929b5456b1548a92ebb60e6aa", "patch": "@@ -1159,9 +1159,9 @@ struct fieldoff\n   /* Field.  */\n   tree decl;\n \n-  /* True if this field is inside a structure nested inside the base\n-     containing object.  */\n-  unsigned int in_nested_struct : 1;\n+  /* Nesting level.  This number represents how many structures are\n+     wrapping this field.  */\n+  unsigned nesting_level;\n \n   /* Offset from the base of the base containing object to this field.  */\n   HOST_WIDE_INT offset;  \n@@ -1173,8 +1173,8 @@ typedef struct fieldoff fieldoff_s;\n \n DEF_VEC_O(fieldoff_s);\n DEF_VEC_ALLOC_O(fieldoff_s,heap);\n-int push_fields_onto_fieldstack (tree, VEC(fieldoff_s,heap) **,\n-\t\t\t\t HOST_WIDE_INT, bool *, tree);\n+int push_fields_onto_fieldstack (tree, VEC(fieldoff_s,heap) **, HOST_WIDE_INT,\n+\t\t\t\t bool *, tree, unsigned);\n void sort_fieldstack (VEC(fieldoff_s,heap) *);\n \n void init_alias_heapvars (void);"}, {"sha": "31e04bcca29ef2b92131d6ae1cb3a54277021d73", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=d770555138f40fb929b5456b1548a92ebb60e6aa", "patch": "@@ -828,6 +828,13 @@ count_mem_refs (long *num_vuses_p, long *num_vdefs_p,\n static inline long\n mem_sym_score (mem_sym_stats_t mp)\n {\n+  /* Unpartitionable SFTs are automatically thrown to the bottom of\n+     the list.  They are not stored in partitions, but they are used\n+     for computing overall statistics.  */\n+  if (TREE_CODE (mp->var) == STRUCT_FIELD_TAG\n+      && SFT_UNPARTITIONABLE_P (mp->var))\n+    return LONG_MAX;\n+\n   return mp->frequency_writes * 64 + mp->frequency_reads * 32\n          + mp->num_direct_writes * 16 + mp->num_direct_reads * 8\n \t + mp->num_indirect_writes * 4 + mp->num_indirect_reads * 2\n@@ -1392,8 +1399,8 @@ update_reference_counts (struct mem_ref_stats_d *mem_ref_stats)\n \n static void\n build_mp_info (struct mem_ref_stats_d *mem_ref_stats,\n-                 VEC(mem_sym_stats_t,heap) **mp_info_p,\n-\t\t VEC(tree,heap) **tags_p)\n+               VEC(mem_sym_stats_t,heap) **mp_info_p,\n+\t       VEC(tree,heap) **tags_p)\n {\n   tree var;\n   referenced_var_iterator rvi;\n@@ -1591,6 +1598,15 @@ compute_memory_partitions (void)\n       if (!need_to_partition_p (mem_ref_stats))\n \tbreak;\n \n+      /* SFTs that are marked unpartitionable should not be added to\n+\t partitions.  These SFTs are special because they mark the\n+\t first SFT into a structure where a pointer is pointing to.\n+\t This is needed by the operand scanner to find adjacent\n+\t fields.  See add_vars_for_offset for details.  */\n+      if (TREE_CODE (mp_p->var) == STRUCT_FIELD_TAG\n+\t  && SFT_UNPARTITIONABLE_P (mp_p->var))\n+\tcontinue;\n+\n       mpt = find_partition_for (mp_p);\n       estimate_vop_reduction (mem_ref_stats, mp_p, mpt);\n     }\n@@ -3774,7 +3790,8 @@ get_or_create_used_part_for (size_t uid)\n \n static tree\n create_sft (tree var, tree field, unsigned HOST_WIDE_INT offset,\n-\t    unsigned HOST_WIDE_INT size, alias_set_type alias_set)\n+\t    unsigned HOST_WIDE_INT size, alias_set_type alias_set,\n+\t    unsigned nesting_level)\n {\n   tree subvar = create_tag_raw (STRUCT_FIELD_TAG, field, \"SFT\");\n \n@@ -3794,6 +3811,8 @@ create_sft (tree var, tree field, unsigned HOST_WIDE_INT offset,\n   SFT_OFFSET (subvar) = offset;\n   SFT_SIZE (subvar) = size;\n   SFT_ALIAS_SET (subvar) = alias_set;\n+  SFT_NESTING_LEVEL (subvar) = nesting_level;\n+\n   return subvar;\n }\n \n@@ -3814,7 +3833,7 @@ create_overlap_variables_for (tree var)\n     return;\n \n   push_fields_onto_fieldstack (TREE_TYPE (var), &fieldstack, 0, NULL,\n-\t\t\t       TREE_TYPE (var));\n+\t\t\t       TREE_TYPE (var), 0);\n   if (VEC_length (fieldoff_s, fieldstack) != 0)\n     {\n       subvar_t *subvars;\n@@ -3897,7 +3916,6 @@ create_overlap_variables_for (tree var)\n \t     field, skip it.  Note that we always need the field at\n \t     offset 0 so we can properly handle pointers to the\n \t     structure.  */\n-\n \t  if ((fo->offset != 0\n \t       && ((fo->offset <= up->minused\n \t\t    && fo->offset + fosize <= up->minused)\n@@ -3906,8 +3924,9 @@ create_overlap_variables_for (tree var)\n \t\t  && fosize == lastfosize\n \t\t  && currfotype == lastfotype))\n \t    continue;\n-\t  subvar = create_sft (var, fo->type, fo->offset,\n-\t\t\t       fosize, fo->alias_set);\n+\n+\t  subvar = create_sft (var, fo->type, fo->offset, fosize,\n+\t\t\t       fo->alias_set, fo->nesting_level);\n \t  VEC_quick_push (tree, *subvars, subvar);\n \n \t  if (dump_file)\n@@ -3918,7 +3937,8 @@ create_overlap_variables_for (tree var)\n \t\t       SFT_OFFSET (subvar));\n \t      fprintf (dump_file, \" size \" HOST_WIDE_INT_PRINT_DEC,\n \t\t       SFT_SIZE (subvar));\n-\t      fprintf (dump_file, \"\\n\");\n+\t      fprintf (dump_file, \" nesting level %d\\n\",\n+\t\t       SFT_NESTING_LEVEL (subvar));\n \t    }\n \t  \n \t  lastfotype = currfotype;"}, {"sha": "cd8ade686393c0d06b6faa978b093eeb71cf8402", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=d770555138f40fb929b5456b1548a92ebb60e6aa", "patch": "@@ -1367,8 +1367,33 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n   return true;\n }\n \n+\n+/* Given an aggregate expression FULL_REF, return the number of\n+   aggregates that are containing FULL_REF.  So, given a structure\n+   reference a.b.c.d, the nesting level for this expression is 2 (the\n+   number of '.' in the expression minus 1).  */\n+\n+static unsigned\n+ref_nesting_level (tree full_ref)\n+{\n+  unsigned nesting_level = 0;\n+\n+  if (!handled_component_p (full_ref))\n+    return 0;\n+\n+  full_ref = TREE_OPERAND (full_ref, 0);\n+  while (handled_component_p (full_ref))\n+    {\n+      nesting_level++;\n+      full_ref = TREE_OPERAND (full_ref, 0);\n+    }\n+\n+  return nesting_level;\n+}\n+\n+\n /* Add the actual variables FULL_REF can access, given a member of\n-   full_ref's points-to set VAR, where FULL_REF is an access of SIZE at\n+   FULL_REF's points-to set VAR, where FULL_REF is an access of SIZE at\n    OFFSET from var. IS_CALL_SITE is true if this is a call, and IS_DEF\n    is true if this is supposed to be a vdef, and false if this should\n    be a VUSE.\n@@ -1386,25 +1411,34 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n    This is necessary because foop only actually points to foo's first\n    member, so that is all the points-to set contains.  However, an access\n    to foop->a may be touching some single SFT if we have created some\n-   SFT's for a structure.  */\n+   SFT's for a structure.\n+\n+   FULL_REF is the original memory expression being analyzed.  */\n \n static bool\n-add_vars_for_offset (tree var, unsigned HOST_WIDE_INT offset,\n+add_vars_for_offset (tree full_ref, tree var, unsigned HOST_WIDE_INT offset,\n \t\t     unsigned HOST_WIDE_INT size, bool is_def)\n {\n   bool added = false;\n   tree subvar;\n   subvar_t sv;\n   unsigned int i;\n \n-  if (SFT_IN_NESTED_STRUCT (var))\n+  if (full_ref\n+      && SFT_NESTING_LEVEL (var) > 0\n+      && ref_nesting_level (full_ref) < SFT_NESTING_LEVEL (var))\n     {\n       /* Since VAR is an SFT inside a nested structure, the OFFSET\n \t computed by get_ref_base_and_extent is the offset from the\n-\t start of the immediately containing structure.  However, to\n-\t find out what other SFTs are affected by this reference, we\n-\t need to know the offsets starting at the root structure in\n-\t the nesting hierarchy.\n+\t start of the immediately containing structure.  If VAR is an\n+\t SFT inside a nested structure, then FULL_REF may be a\n+\t reference to the structure immediately enclosing SFT, and so\n+\t OFFSET will be the offset from the start of the immediately\n+\t enclosing structure.\n+\n+\t However, to find out what other SFTs are affected by this\n+\t reference, we need to know the offsets starting at the root\n+\t structure in the nesting hierarchy.\n \n \t For instance, given the following structure:\n \n@@ -1541,7 +1575,7 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t     if it is a potential points-to location.  */\n \t  if (TREE_CODE (al) == STRUCT_FIELD_TAG\n \t      && TREE_CODE (var) == NAME_MEMORY_TAG)\n-\t    none_added &= !add_vars_for_offset (al, offset, size,\n+\t    none_added &= !add_vars_for_offset (full_ref, al, offset, size,\n \t\t\t\t\t        flags & opf_def);\n \t  else\n \t    {"}, {"sha": "479145ab6e9ab2ef7486df4c3e070b623b23b8fe", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 46, "deletions": 39, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=d770555138f40fb929b5456b1548a92ebb60e6aa", "patch": "@@ -253,15 +253,6 @@ struct variable_info\n      variable.  This is used for C++ placement new.  */\n   unsigned int no_tbaa_pruning : 1;\n \n-  /* True if this variable is inside a structure nested in the\n-     structure for the base variable.  For instance, in \n-     struct X { int a; struct Y { int b; int c; } }, the variables for\n-     fields 'b' and 'c' are inside a nested structure.  We are not\n-     interested in tracking how many levels of nesting, just whether\n-     there is nesting at all.  This is later used to adjust offsets\n-     for pointers pointing into sub-structures.  */\n-  unsigned int in_nested_struct : 1;\n-\n   /* Points-to set for this variable.  */\n   bitmap solution;\n \n@@ -4050,19 +4041,28 @@ sort_fieldstack (VEC(fieldoff_s,heap) *fieldstack)\n \t fieldoff_compare);\n }\n \n-/* Given a TYPE, and a vector of field offsets FIELDSTACK, push all the fields\n-   of TYPE onto fieldstack, recording their offsets along the way.\n-   OFFSET is used to keep track of the offset in this entire structure, rather\n-   than just the immediately containing structure.  Returns the number\n-   of fields pushed.\n+/* Given a TYPE, and a vector of field offsets FIELDSTACK, push all\n+   the fields of TYPE onto fieldstack, recording their offsets along\n+   the way.\n+\n+   OFFSET is used to keep track of the offset in this entire\n+   structure, rather than just the immediately containing structure.\n+   Returns the number of fields pushed.\n+\n    HAS_UNION is set to true if we find a union type as a field of\n-   TYPE.  ADDRESSABLE_TYPE is the type of the outermost object that could have\n-   its address taken.  */\n+   TYPE.\n+\n+   ADDRESSABLE_TYPE is the type of the outermost object that could\n+   have its address taken.\n+\n+   NESTING_LEVEL indicates whether TYPE is a structure nested inside\n+   another, it starts at 0 and it is incremented by one on every\n+   structure recursed into.  */\n \n int\n push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t\t\t     HOST_WIDE_INT offset, bool *has_union,\n-\t\t\t     tree addressable_type)\n+\t\t\t     tree addressable_type, unsigned nesting_level)\n {\n   tree field;\n   int count = 0;\n@@ -4119,11 +4119,14 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t  if (!AGGREGATE_TYPE_P (TREE_TYPE (type))) /* var_can_have_subvars */\n \t    push = true;\n \t  else if (!(pushed = push_fields_onto_fieldstack\n-\t\t     (TREE_TYPE (type), fieldstack,\n-\t\t      offset + i * TREE_INT_CST_LOW (elsz), has_union,\n+\t\t     (TREE_TYPE (type),\n+\t\t      fieldstack,\n+\t\t      offset + i * TREE_INT_CST_LOW (elsz),\n+\t\t      has_union,\n \t\t      (TYPE_NONALIASED_COMPONENT (type)\n \t\t       ? addressable_type\n-\t\t       : TREE_TYPE (type)))))\n+\t\t       : TREE_TYPE (type)),\n+\t\t      nesting_level + 1)))\n \t    /* Empty structures may have actual size, like in C++. So\n \t       see if we didn't push any subfields and the size is\n \t       nonzero, push the field onto the stack */\n@@ -4142,12 +4145,7 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t\tpair->alias_set = get_alias_set (addressable_type);\n \t      else\n \t\tpair->alias_set = -1;\n-\n-\t      /* If the base offset is positive, this field belongs to\n-\t\t a structure nested inside the base structure.  */\n-\t      if (offset > 0)\n-\t\tpair->in_nested_struct = true;\n-\n+\t      pair->nesting_level = nesting_level;\n \t      count++;\n \t    }\n \t  else\n@@ -4171,11 +4169,14 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \tif (!var_can_have_subvars (field))\n \t  push = true;\n \telse if (!(pushed = push_fields_onto_fieldstack\n-\t\t   (TREE_TYPE (field), fieldstack,\n-\t\t    offset + bitpos_of_field (field), has_union,\n+\t\t   (TREE_TYPE (field),\n+\t\t    fieldstack,\n+\t\t    offset + bitpos_of_field (field),\n+\t\t    has_union,\n \t\t    (DECL_NONADDRESSABLE_P (field)\n \t\t     ? addressable_type\n-\t\t     : TREE_TYPE (field))))\n+\t\t     : TREE_TYPE (field)),\n+\t\t    nesting_level + 1))\n \t\t && DECL_SIZE (field)\n \t\t && !integer_zerop (DECL_SIZE (field)))\n \t  /* Empty structures may have actual size, like in C++. So\n@@ -4196,12 +4197,7 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t      pair->alias_set = get_alias_set (addressable_type);\n \t    else\n \t      pair->alias_set = -1;\n-\n-\t    /* If the base offset is positive, this field belongs to\n-\t       a structure nested inside the base structure.  */\n-\t    if (offset > 0)\n-\t      pair->in_nested_struct = true;\n-\n+\t    pair->nesting_level = nesting_level;\n \t    count++;\n \t  }\n \telse\n@@ -4401,7 +4397,7 @@ create_variable_info_for (tree decl, const char *name)\n   if (var_can_have_subvars (decl) && use_field_sensitive && !hasunion)\n     {\n       push_fields_onto_fieldstack (decltype, &fieldstack, 0, &hasunion,\n-\t\t\t\t   decltype);\n+\t\t\t\t   decltype, 0);\n       if (hasunion)\n \t{\n \t  VEC_free (fieldoff_s, heap, fieldstack);\n@@ -4512,7 +4508,6 @@ create_variable_info_for (tree decl, const char *name)\n \t  newvi->offset = fo->offset;\n \t  newvi->size = TREE_INT_CST_LOW (fo->size);\n \t  newvi->fullsize = vi->fullsize;\n-\t  newvi->in_nested_struct = fo->in_nested_struct;\n \t  insert_into_field_list (vi, newvi);\n \t  VEC_safe_push (varinfo_t, heap, varmap, newvi);\n \t  if (is_global && (!flag_whole_program || !in_ipa_mode))\n@@ -4764,8 +4759,20 @@ set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed,\n \t\t  if (no_tbaa_pruning\n \t\t      || (!is_derefed && !vi->directly_dereferenced)\n \t\t      || alias_sets_conflict_p (ptr_alias_set, var_alias_set))\n-\t\t    bitmap_set_bit (into, DECL_UID (sft));\n-\t\t  SFT_IN_NESTED_STRUCT (sft) = vi->in_nested_struct;\n+\t\t    {\n+\t\t      bitmap_set_bit (into, DECL_UID (sft));\n+\t\t      \n+\t\t      /* If SFT is inside a nested structure, it will\n+\t\t\t be needed by the operand scanner to adjust\n+\t\t\t offsets when adding operands to memory\n+\t\t\t expressions that dereference PTR.  This means\n+\t\t\t that memory partitioning may not partition\n+\t\t\t this SFT because the operand scanner will not\n+\t\t\t be able to find the other SFTs next to this\n+\t\t\t one.  */\n+\t\t      if (SFT_NESTING_LEVEL (sft) > 0)\n+\t\t\tSFT_UNPARTITIONABLE_P (sft) = true;\n+\t\t    }\n \t\t}\n \t    }\n \t  else"}, {"sha": "00b193fd77faf4d0cebe216302c86c31a5d8fc4b", "filename": "gcc/tree.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d770555138f40fb929b5456b1548a92ebb60e6aa/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d770555138f40fb929b5456b1548a92ebb60e6aa", "patch": "@@ -2555,10 +2555,10 @@ struct tree_memory_tag GTY(())\n   bitmap GTY ((skip)) aliases;\n \n   /* True if this tag has global scope.  */\n-  unsigned int is_global:1;\n+  unsigned int is_global : 1;\n \n-  /* True if this SFT is for a field in a nested structure.  */\n-  unsigned int in_nested_struct : 1;\n+  /* True if this tag should not be grouped into a memory partition.  */\n+  unsigned int unpartitionable : 1;\n };\n \n #define MTAG_GLOBAL(NODE) (TREE_MEMORY_TAG_CHECK (NODE)->mtag.is_global)\n@@ -2579,6 +2579,11 @@ struct tree_struct_field_tag GTY(())\n \n   /* Alias set for a DECL_NONADDRESSABLE_P field.  Otherwise -1.  */\n   alias_set_type alias_set;\n+\n+  /* Nesting level for this subvariable.  This indicates how many\n+     structures are wrapping this field.  Fields at the top level have\n+     a nesting level of 0.  */\n+  unsigned int nesting_level;\n };\n \n #define SFT_PARENT_VAR(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.parent_var)\n@@ -2587,8 +2592,10 @@ struct tree_struct_field_tag GTY(())\n #define SFT_NONADDRESSABLE_P(NODE) \\\n   (STRUCT_FIELD_TAG_CHECK (NODE)->sft.alias_set != -1)\n #define SFT_ALIAS_SET(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.alias_set)\n-#define SFT_IN_NESTED_STRUCT(NODE) \\\n-  (STRUCT_FIELD_TAG_CHECK (NODE)->sft.common.in_nested_struct)\n+#define SFT_NESTING_LEVEL(NODE) \\\n+  (STRUCT_FIELD_TAG_CHECK (NODE)->sft.nesting_level)\n+#define SFT_UNPARTITIONABLE_P(NODE) \\\n+  (STRUCT_FIELD_TAG_CHECK (NODE)->sft.common.unpartitionable)\n \n /* Memory Partition Tags (MPTs) group memory symbols under one\n    common name for the purposes of placing memory PHI nodes.  */"}]}