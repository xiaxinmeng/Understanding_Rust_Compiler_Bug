{"sha": "ae9fd815db6b778af865526a491ab7c02691543e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU5ZmQ4MTVkYjZiNzc4YWY4NjU1MjZhNDkxYWI3YzAyNjkxNTQzZQ==", "commit": {"author": {"name": "Ralf Wildenhues", "email": "Ralf.Wildenhues@gmx.de", "date": "2011-01-10T19:00:10Z"}, "committer": {"name": "Ralf Wildenhues", "email": "rwild@gcc.gnu.org", "date": "2011-01-10T19:00:10Z"}, "message": "doc: fix deftypefn markup in gccint manual.\n\ngcc/:\n\t* doc/gimple.texi: Fix quoting of multi-word return values in\n\t@deftypefn statements.  Ensure presence of return value.  Wrap\n\toverlong @deftypefn lines.\n\t(is_gimple_operand, is_gimple_min_invariant_address): Remove\n\tdescriptions of removed functions.\n\t* doc/hostconfig.texi (Host Common): Wrap long line, fix quoting\n\tof multi-word return value in @deftypefn statement.\n\nFrom-SVN: r168637", "tree": {"sha": "f56cc6af4ddb8cc8f41f01afef8376ae90b99b82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f56cc6af4ddb8cc8f41f01afef8376ae90b99b82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae9fd815db6b778af865526a491ab7c02691543e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9fd815db6b778af865526a491ab7c02691543e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae9fd815db6b778af865526a491ab7c02691543e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9fd815db6b778af865526a491ab7c02691543e/comments", "author": null, "committer": null, "parents": [{"sha": "0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d"}], "stats": {"total": 206, "additions": 114, "deletions": 92}, "files": [{"sha": "d7ffbef94c81779adbe0053ca1824f109e4fe376", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9fd815db6b778af865526a491ab7c02691543e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9fd815db6b778af865526a491ab7c02691543e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae9fd815db6b778af865526a491ab7c02691543e", "patch": "@@ -1,3 +1,13 @@\n+2011-01-10  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n+\n+\t* doc/gimple.texi: Fix quoting of multi-word return values in\n+\t@deftypefn statements.  Ensure presence of return value.  Wrap\n+\toverlong @deftypefn lines.\n+\t(is_gimple_operand, is_gimple_min_invariant_address): Remove\n+\tdescriptions of removed functions.\n+\t* doc/hostconfig.texi (Host Common): Wrap long line, fix quoting\n+\tof multi-word return value in @deftypefn statement.\n+\n 2011-01-10  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* doc/gimple.texi (Temporaries, Operands, Compound Lvalues)"}, {"sha": "2cb81c81f6e048ab148b79b40d6bf436f3c767a7", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 100, "deletions": 90, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9fd815db6b778af865526a491ab7c02691543e/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9fd815db6b778af865526a491ab7c02691543e/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=ae9fd815db6b778af865526a491ab7c02691543e", "patch": "@@ -613,7 +613,7 @@ Returns the number of operands in statement G.\n Returns operand @code{I} from statement @code{G}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_ops (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_ops (gimple g)\n Returns a pointer into the operand vector for statement @code{G}.  This\n is computed using an internal table called @code{gimple_ops_offset_}[].\n This table is indexed by the gimple code of @code{G}.\n@@ -638,86 +638,75 @@ vector.  These predicates are called by the\n @code{gimple_@var{name}_set_...()}.  Each tuple will use one of the\n following predicates (Note, this list is not exhaustive):\n \n-@deftypefn {GIMPLE function} is_gimple_operand (tree t)\n-This is the most permissive of the predicates.  It essentially\n-checks whether t has a @code{gimple_rhs_class} of @code{GIMPLE_SINGLE_RHS}.\n-@end deftypefn\n-\n-\n-@deftypefn {GIMPLE function} is_gimple_val (tree t)\n+@deftypefn {GIMPLE function} bool is_gimple_val (tree t)\n Returns true if t is a \"GIMPLE value\", which are all the\n non-addressable stack variables (variables for which\n @code{is_gimple_reg} returns true) and constants (expressions for which\n @code{is_gimple_min_invariant} returns true).\n @end deftypefn\n \n-@deftypefn {GIMPLE function} is_gimple_addressable (tree t)\n+@deftypefn {GIMPLE function} bool is_gimple_addressable (tree t)\n Returns true if t is a symbol or memory reference whose address\n can be taken.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} is_gimple_asm_val (tree t)\n+@deftypefn {GIMPLE function} bool is_gimple_asm_val (tree t)\n Similar to @code{is_gimple_val} but it also accepts hard registers.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} is_gimple_call_addr (tree t)\n+@deftypefn {GIMPLE function} bool is_gimple_call_addr (tree t)\n Return true if t is a valid expression to use as the function\n called by a @code{GIMPLE_CALL}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} is_gimple_mem_ref_addr (tree t)\n+@deftypefn {GIMPLE function} bool is_gimple_mem_ref_addr (tree t)\n Return true if t is a valid expression to use as first operand\n of a @code{MEM_REF} expression.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} is_gimple_constant (tree t)\n+@deftypefn {GIMPLE function} bool is_gimple_constant (tree t)\n Return true if t is a valid gimple constant.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} is_gimple_min_invariant (tree t)\n+@deftypefn {GIMPLE function} bool is_gimple_min_invariant (tree t)\n Return true if t is a valid minimal invariant.  This is different\n from constants, in that the specific value of t may not be known\n at compile time, but it is known that it doesn't change (e.g.,\n the address of a function local variable).\n @end deftypefn\n \n-@deftypefn {GIMPLE function} is_gimple_min_invariant_address (tree t)\n-Return true if t is an @code{ADDR_EXPR} that does not change once a\n-function is running.\n-@end deftypefn\n-\n-@deftypefn {GIMPLE function} is_gimple_ip_invariant (tree t)\n+@deftypefn {GIMPLE function} bool is_gimple_ip_invariant (tree t)\n Return true if t is an interprocedural invariant.  This means that t\n is a valid invariant in all functions (e.g. it can be an address of a\n global variable but not of a local one).\n @end deftypefn\n \n-@deftypefn {GIMPLE function} is_gimple_ip_invariant_address (tree t)\n+@deftypefn {GIMPLE function} bool is_gimple_ip_invariant_address (tree t)\n Return true if t is an @code{ADDR_EXPR} that does not change once the\n program is running (and which is valid in all functions).\n @end deftypefn\n \n \n @subsection Statement validation\n \n-@deftypefn {GIMPLE function} is_gimple_assign (gimple g)\n+@deftypefn {GIMPLE function} bool is_gimple_assign (gimple g)\n Return true if the code of g is @code{GIMPLE_ASSIGN}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} is_gimple_call (gimple g)\n+@deftypefn {GIMPLE function} bool is_gimple_call (gimple g)\n Return true if the code of g is @code{GIMPLE_CALL}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} is_gimple_debug (gimple g)\n+@deftypefn {GIMPLE function} bool is_gimple_debug (gimple g)\n Return true if the code of g is @code{GIMPLE_DEBUG}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple_assign_cast_p (gimple g)\n+@deftypefn {GIMPLE function} bool gimple_assign_cast_p (gimple g)\n Return true if g is a @code{GIMPLE_ASSIGN} that performs a type cast\n operation.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple_debug_bind_p (gimple g)\n+@deftypefn {GIMPLE function} bool gimple_debug_bind_p (gimple g)\n Return true if g is a @code{GIMPLE_DEBUG} that binds the value of an\n expression to a variable.\n @end deftypefn\n@@ -732,7 +721,7 @@ of the GIMPLE instructions.\n @subsection Common accessors \n The following are common accessors for gimple statements.\n \n-@deftypefn {GIMPLE function} enum gimple_code gimple_code (gimple g)\n+@deftypefn {GIMPLE function} {enum gimple_code} gimple_code (gimple g)\n Return the code for statement @code{G}.\n @end deftypefn\n  \n@@ -752,7 +741,7 @@ something meaningful for @code{GIMPLE_ASSIGN}, @code{GIMPLE_COND} and\n @code{void_type_node}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} enum tree_code gimple_expr_code (gimple stmt)\n+@deftypefn {GIMPLE function} {enum tree_code} gimple_expr_code (gimple stmt)\n Return the tree code for the expression computed by @code{STMT}.  This\n is only meaningful for @code{GIMPLE_CALL}, @code{GIMPLE_ASSIGN} and\n @code{GIMPLE_COND}.  If @code{STMT} is @code{GIMPLE_CALL}, it will return @code{CALL_EXPR}.\n@@ -793,7 +782,7 @@ Return the visited status on statement @code{STMT}.\n Set pass local flag @code{PLF} on statement @code{STMT} to @code{VAL_P}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} unsigned int gimple_plf (gimple stmt, enum plf_mask plf)\n+@deftypefn {GIMPLE function} {unsigned int} gimple_plf (gimple stmt, enum plf_mask plf)\n Return the value of pass local flag @code{PLF} on statement @code{STMT}.\n @end deftypefn\n  \n@@ -809,15 +798,15 @@ Return true if statement @code{G} has memory operands.\n Return the number of operands for statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} tree *gimple_ops (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_ops (gimple g)\n Return the array of operands for statement @code{G}.\n @end deftypefn\n  \n @deftypefn {GIMPLE function} tree gimple_op (gimple g, unsigned i)\n Return operand @code{I} for statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} tree *gimple_op_ptr (gimple g, unsigned i)\n+@deftypefn {GIMPLE function} {tree *} gimple_op_ptr (gimple g, unsigned i)\n Return a pointer to operand @code{I} for statement @code{G}.\n @end deftypefn\n  \n@@ -830,31 +819,31 @@ Return the set of symbols that have had their address taken by\n @code{STMT}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} struct def_optype_d *gimple_def_ops (gimple g)\n+@deftypefn {GIMPLE function} {struct def_optype_d *} gimple_def_ops (gimple g)\n Return the set of @code{DEF} operands for statement @code{G}.\n @end deftypefn\n  \n @deftypefn {GIMPLE function} void gimple_set_def_ops (gimple g, struct def_optype_d *def)\n Set @code{DEF} to be the set of @code{DEF} operands for statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} struct use_optype_d *gimple_use_ops (gimple g)\n+@deftypefn {GIMPLE function} {struct use_optype_d *} gimple_use_ops (gimple g)\n Return the set of @code{USE} operands for statement @code{G}.\n @end deftypefn\n  \n @deftypefn {GIMPLE function} void gimple_set_use_ops (gimple g, struct use_optype_d *use)\n Set @code{USE} to be the set of @code{USE} operands for statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} struct voptype_d *gimple_vuse_ops (gimple g)\n+@deftypefn {GIMPLE function} {struct voptype_d *} gimple_vuse_ops (gimple g)\n Return the set of @code{VUSE} operands for statement @code{G}.\n @end deftypefn\n  \n @deftypefn {GIMPLE function} void gimple_set_vuse_ops (gimple g, struct voptype_d *ops)\n Set @code{OPS} to be the set of @code{VUSE} operands for statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} struct voptype_d *gimple_vdef_ops (gimple g)\n+@deftypefn {GIMPLE function} {struct voptype_d *} gimple_vdef_ops (gimple g)\n Return the set of @code{VDEF} operands for statement @code{G}.\n @end deftypefn\n  \n@@ -951,15 +940,15 @@ Identical to gimple_build_asm, but the arguments are passed in\n VECs.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple_asm_ninputs (gimple g)\n+@deftypefn {GIMPLE function} unsigned gimple_asm_ninputs (gimple g)\n Return the number of input operands for @code{GIMPLE_ASM} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple_asm_noutputs (gimple g)\n+@deftypefn {GIMPLE function} unsigned gimple_asm_noutputs (gimple g)\n Return the number of output operands for @code{GIMPLE_ASM} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple_asm_nclobbers (gimple g)\n+@deftypefn {GIMPLE function} unsigned gimple_asm_nclobbers (gimple g)\n Return the number of clobber operands for @code{GIMPLE_ASM} @code{G}. \n @end deftypefn\n \n@@ -988,7 +977,7 @@ Return clobber operand @code{INDEX} of @code{GIMPLE_ASM} @code{G}.\n Set @code{CLOBBER_OP} to be clobber operand @code{INDEX} in @code{GIMPLE_ASM} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} const char *gimple_asm_string (gimple g)\n+@deftypefn {GIMPLE function} {const char *} gimple_asm_string (gimple g)\n Return the string representing the assembly instruction in\n @code{GIMPLE_ASM} @code{G}. \n @end deftypefn\n@@ -1047,13 +1036,13 @@ are the operands.  If op2 is null, subcode must be a @code{tree_code}\n for a unary expression.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} enum tree_code gimple_assign_rhs_code (gimple g)\n+@deftypefn {GIMPLE function} {enum tree_code} gimple_assign_rhs_code (gimple g)\n Return the code of the expression computed on the @code{RHS} of\n assignment statement @code{G}.\n @end deftypefn\n  \n \n-@deftypefn {GIMPLE function} enum gimple_rhs_class gimple_assign_rhs_class (gimple g)\n+@deftypefn {GIMPLE function} {enum gimple_rhs_class} gimple_assign_rhs_class (gimple g)\n Return the gimple rhs class of the code for the expression\n computed on the rhs of assignment statement @code{G}.  This will never\n return @code{GIMPLE_INVALID_RHS}.\n@@ -1063,15 +1052,15 @@ return @code{GIMPLE_INVALID_RHS}.\n Return the @code{LHS} of assignment statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} tree *gimple_assign_lhs_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_assign_lhs_ptr (gimple g)\n Return a pointer to the @code{LHS} of assignment statement @code{G}.\n @end deftypefn\n  \n @deftypefn {GIMPLE function} tree gimple_assign_rhs1 (gimple g)\n Return the first operand on the @code{RHS} of assignment statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} tree *gimple_assign_rhs1_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_assign_rhs1_ptr (gimple g)\n Return the address of the first operand on the @code{RHS} of assignment\n statement @code{G}.\n @end deftypefn\n@@ -1080,7 +1069,7 @@ statement @code{G}.\n Return the second operand on the @code{RHS} of assignment statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} tree *gimple_assign_rhs2_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_assign_rhs2_ptr (gimple g)\n Return the address of the second operand on the @code{RHS} of assignment\n statement @code{G}.\n @end deftypefn\n@@ -1089,7 +1078,7 @@ statement @code{G}.\n Return the third operand on the @code{RHS} of assignment statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} tree *gimple_assign_rhs3_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_assign_rhs3_ptr (gimple g)\n Return the address of the third operand on the @code{RHS} of assignment\n statement @code{G}.\n @end deftypefn\n@@ -1202,7 +1191,7 @@ Identical to @code{gimple_build_call} but the arguments are stored in a\n Return the @code{LHS} of call statement @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} tree *gimple_call_lhs_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_call_lhs_ptr (gimple g)\n Return a pointer to the @code{LHS} of call statement @code{G}.\n @end deftypefn\n  \n@@ -1243,7 +1232,7 @@ Return the static chain for call statement @code{G}.\n Set @code{CHAIN} to be the static chain for call statement @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple_call_num_args (gimple g)\n+@deftypefn {GIMPLE function} unsigned gimple_call_num_args (gimple g)\n Return the number of arguments used by call statement @code{G}. \n @end deftypefn\n \n@@ -1252,7 +1241,7 @@ Return the argument at position @code{INDEX} for call statement @code{G}.  The\n first argument is 0.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} tree *gimple_call_arg_ptr (gimple g, unsigned index)\n+@deftypefn {GIMPLE function} {tree *} gimple_call_arg_ptr (gimple g, unsigned index)\n Return a pointer to the argument at position @code{INDEX} for call\n statement @code{G}. \n @end deftypefn\n@@ -1304,7 +1293,7 @@ for the handler.\n Return the types handled by @code{GIMPLE_CATCH} statement @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_catch_types_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_catch_types_ptr (gimple g)\n Return a pointer to the types handled by @code{GIMPLE_CATCH} statement\n @code{G}. \n @end deftypefn\n@@ -1341,7 +1330,7 @@ Build a @code{GIMPLE_COND} statement from the conditional expression\n tree @code{COND}.  @code{T_LABEL} and @code{F_LABEL} are as in @code{gimple_build_cond}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} enum tree_code gimple_cond_code (gimple g)\n+@deftypefn {GIMPLE function} {enum tree_code} gimple_cond_code (gimple g)\n Return the code of the predicate computed by conditional\n statement @code{G}. \n @end deftypefn\n@@ -1452,7 +1441,7 @@ Return the value expression that is bound to a user variable at\n @code{stmt}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_debug_bind_get_value_ptr (gimple stmt)\n+@deftypefn {GIMPLE function} {tree *} gimple_debug_bind_get_value_ptr (gimple stmt)\n Return a pointer to the value expression that is bound to a user\n variable at @code{stmt}.\n @end deftypefn\n@@ -1489,7 +1478,7 @@ types.  @code{FAILURE} is a sequence with the filter's failure action.\n Return the types handled by @code{GIMPLE_EH_FILTER} statement @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_eh_filter_types_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_eh_filter_types_ptr (gimple g)\n Return a pointer to the types handled by @code{GIMPLE_EH_FILTER}\n statement @code{G}. \n @end deftypefn\n@@ -1658,7 +1647,7 @@ optional identifier for this critical block.\n Return the name associated with @code{OMP_CRITICAL} statement @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_omp_critical_name_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_critical_name_ptr (gimple g)\n Return a pointer to the name associated with @code{OMP} critical\n statement @code{G}. \n @end deftypefn\n@@ -1688,7 +1677,7 @@ compare @code{INDEX} and @code{FINAL}.  @code{INCR} is the increment expression.\n Return the clauses associated with @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_omp_for_clauses_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_for_clauses_ptr (gimple g)\n Return a pointer to the @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n@@ -1700,7 +1689,7 @@ Set @code{CLAUSES} to be the list of clauses associated with @code{OMP_FOR} @cod\n Return the index variable for @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_omp_for_index_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_for_index_ptr (gimple g)\n Return a pointer to the index variable for @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n@@ -1712,7 +1701,7 @@ Set @code{INDEX} to be the index variable for @code{OMP_FOR} @code{G}.\n Return the initial value for @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_omp_for_initial_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_for_initial_ptr (gimple g)\n Return a pointer to the initial value for @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n@@ -1724,7 +1713,7 @@ Set @code{INITIAL} to be the initial value for @code{OMP_FOR} @code{G}.\n Return the final value for @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_omp_for_final_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_for_final_ptr (gimple g)\n turn a pointer to the final value for @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n@@ -1736,7 +1725,7 @@ Set @code{FINAL} to be the final value for @code{OMP_FOR} @code{G}.\n Return the increment value for @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_omp_for_incr_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_for_incr_ptr (gimple g)\n Return a pointer to the increment value for @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n@@ -1758,7 +1747,7 @@ the @code{OMP_FOR} statement @code{G} starts.\n Set @code{COND} to be the condition code for @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} enum tree_code gimple_omp_for_cond (gimple g)\n+@deftypefn {GIMPLE function} {enum tree_code} gimple_omp_for_cond (gimple g)\n Return the condition code associated with @code{OMP_FOR} @code{G}. \n @end deftypefn\n \n@@ -1789,7 +1778,8 @@ executed in sequence.\n @subsection @code{GIMPLE_OMP_PARALLEL}\n @cindex @code{GIMPLE_OMP_PARALLEL}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_omp_parallel (gimple_seq body, tree clauses, tree child_fn, tree data_arg)\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_parallel (gimple_seq @\n+body, tree clauses, tree child_fn, tree data_arg)\n Build a @code{GIMPLE_OMP_PARALLEL} statement.\n @end deftypefn\n \n@@ -1820,7 +1810,7 @@ Set @code{BODY} to be the body for the @code{OMP} statement @code{G}.\n Return the clauses associated with @code{OMP_PARALLEL} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_omp_parallel_clauses_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_parallel_clauses_ptr (gimple g)\n Return a pointer to the clauses associated with @code{OMP_PARALLEL} @code{G}. \n @end deftypefn\n \n@@ -1834,7 +1824,7 @@ Return the child function used to hold the body of @code{OMP_PARALLEL}\n @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_omp_parallel_child_fn_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_parallel_child_fn_ptr (gimple g)\n Return a pointer to the child function used to hold the body of\n @code{OMP_PARALLEL} @code{G}. \n @end deftypefn\n@@ -1848,7 +1838,7 @@ Return the artificial argument used to send variables and values\n from the parent to the children threads in @code{OMP_PARALLEL} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_omp_parallel_data_arg_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_parallel_data_arg_ptr (gimple g)\n Return a pointer to the data argument for @code{OMP_PARALLEL} @code{G}. \n @end deftypefn\n \n@@ -1921,7 +1911,7 @@ Return the control variable associated with the\n @code{GIMPLE_OMP_SECTIONS} in @code{G}.\n @end deftypefn\n  \n-@deftypefn {GIMPLE function} tree *gimple_omp_sections_control_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_sections_control_ptr (gimple g)\n Return a pointer to the clauses associated with the\n @code{GIMPLE_OMP_SECTIONS} in @code{G}.\n @end deftypefn\n@@ -1935,7 +1925,7 @@ Set @code{CONTROL} to be the set of clauses associated with the\n Return the clauses associated with @code{OMP_SECTIONS} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_omp_sections_clauses_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_sections_clauses_ptr (gimple g)\n Return a pointer to the clauses associated with @code{OMP_SECTIONS} @code{G}. \n @end deftypefn\n \n@@ -1960,7 +1950,7 @@ copyprivate, nowait.\n Return the clauses associated with @code{OMP_SINGLE} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_omp_single_clauses_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_omp_single_clauses_ptr (gimple g)\n Return a pointer to the clauses associated with @code{OMP_SINGLE} @code{G}. \n @end deftypefn\n \n@@ -1991,15 +1981,15 @@ holding @code{G}.\n Return the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} tree *gimple_phi_result_ptr (gimple g)\n+@deftypefn {GIMPLE function} {tree *} gimple_phi_result_ptr (gimple g)\n Return a pointer to the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}. \n @end deftypefn\n \n @deftypefn {GIMPLE function} void gimple_phi_set_result (gimple g, tree result)\n Set @code{RESULT} to be the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} struct phi_arg_d *gimple_phi_arg (gimple g, index)\n+@deftypefn {GIMPLE function} {struct phi_arg_d *} gimple_phi_arg (gimple g, index)\n Return the @code{PHI} argument corresponding to incoming edge @code{INDEX} for\n @code{GIMPLE_PHI} @code{G}. \n @end deftypefn\n@@ -2048,15 +2038,17 @@ Set @code{RETVAL} to be the return value for @code{GIMPLE_RETURN} @code{G}.\n @subsection @code{GIMPLE_SWITCH}\n @cindex @code{GIMPLE_SWITCH}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_switch ( nlabels, tree index, tree default_label, ...)\n+@deftypefn {GIMPLE function} gimple gimple_build_switch (unsigned nlabels, @\n+tree index, tree default_label, ...)\n Build a @code{GIMPLE_SWITCH} statement.  @code{NLABELS} are the number of\n labels excluding the default label.  The default label is passed\n in @code{DEFAULT_LABEL}.  The rest of the arguments are trees\n representing the labels.  Each label is a tree of code\n @code{CASE_LABEL_EXPR}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple gimple_build_switch_vec (tree index, tree default_label, @code{VEC}(tree,heap) *args)\n+@deftypefn {GIMPLE function} gimple gimple_build_switch_vec (tree index, tree @\n+default_label, @code{VEC}(tree,heap) *args)\n This function is an alternate way of building @code{GIMPLE_SWITCH}\n statements.  @code{INDEX} and @code{DEFAULT_LABEL} are as in\n gimple_build_switch.  @code{ARGS} is a vector of @code{CASE_LABEL_EXPR} trees\n@@ -2068,7 +2060,8 @@ Return the number of labels associated with the switch statement\n @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_switch_set_num_labels (gimple g, unsigned nlabels)\n+@deftypefn {GIMPLE function} void gimple_switch_set_num_labels (gimple g, @\n+unsigned nlabels)\n Set @code{NLABELS} to be the number of labels for the switch statement\n @code{G}. \n @end deftypefn\n@@ -2086,7 +2079,8 @@ Return the label numbered @code{INDEX}. The default label is 0, followed\n by any labels in a switch statement. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_switch_set_label (gimple g, unsigned index, tree label)\n+@deftypefn {GIMPLE function} void gimple_switch_set_label (gimple g, unsigned @\n+index, tree label)\n Set the label number @code{INDEX} to @code{LABEL}. 0 is always the default\n label. \n @end deftypefn\n@@ -2095,7 +2089,8 @@ label.\n Return the default label for a switch statement. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_switch_set_default_label (gimple g, tree label)\n+@deftypefn {GIMPLE function} void gimple_switch_set_default_label (gimple g, @\n+tree label)\n Set the default label for a switch statement. \n @end deftypefn\n \n@@ -2104,7 +2099,8 @@ Set the default label for a switch statement.\n @subsection @code{GIMPLE_TRY}\n @cindex @code{GIMPLE_TRY}\n \n-@deftypefn {GIMPLE function} gimple gimple_build_try (gimple_seq eval, gimple_seq cleanup, unsigned int kind)\n+@deftypefn {GIMPLE function} gimple gimple_build_try (gimple_seq eval, @\n+gimple_seq cleanup, unsigned int kind)\n Build a @code{GIMPLE_TRY} statement.  @code{EVAL} is a sequence with the\n expression to evaluate.  @code{CLEANUP} is a sequence of statements to\n run at clean-up time.  @code{KIND} is the enumeration value\n@@ -2113,7 +2109,7 @@ or @code{GIMPLE_TRY_FINALLY} if this statement denotes a try/finally\n construct.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} enum gimple_try_flags gimple_try_kind (gimple g)\n+@deftypefn {GIMPLE function} {enum gimple_try_flags} gimple_try_kind (gimple g)\n Return the kind of try block represented by @code{GIMPLE_TRY} @code{G}. This is\n either @code{GIMPLE_TRY_CATCH} or @code{GIMPLE_TRY_FINALLY}. \n @end deftypefn\n@@ -2132,7 +2128,8 @@ Return the sequence of statements used as the cleanup body for\n @code{GIMPLE_TRY} @code{G}. \n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gimple_try_set_catch_is_cleanup (gimple g, bool catch_is_cleanup)\n+@deftypefn {GIMPLE function} void gimple_try_set_catch_is_cleanup (gimple g, @\n+bool catch_is_cleanup)\n Set the @code{GIMPLE_TRY_CATCH_IS_CLEANUP} flag. \n @end deftypefn\n \n@@ -2353,7 +2350,7 @@ Return a block statement iterator that points to the first\n non-label statement in block @code{BB}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} gimple *gsi_stmt_ptr (gimple_stmt_iterator *i)\n+@deftypefn {GIMPLE function} {gimple *} gsi_stmt_ptr (gimple_stmt_iterator *i)\n Return a pointer to the current stmt.\n @end deftypefn\n \n@@ -2385,12 +2382,14 @@ Links statement @code{G} before the statement pointed-to by iterator @code{I}.\n Updates iterator @code{I} according to @code{MODE}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gsi_link_seq_after (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)\n+@deftypefn {GIMPLE function} void gsi_link_seq_after (gimple_stmt_iterator *i, @\n+gimple_seq seq, enum gsi_iterator_update mode)\n Links sequence @code{SEQ} after the statement pointed-to by iterator @code{I}.\n @code{MODE} is as in @code{gsi_insert_after}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gsi_link_after (gimple_stmt_iterator *i, gimple g, enum gsi_iterator_update mode)\n+@deftypefn {GIMPLE function} void gsi_link_after (gimple_stmt_iterator *i, @\n+gimple g, enum gsi_iterator_update mode)\n Links statement @code{G} after the statement pointed-to by iterator @code{I}.\n @code{MODE} is as in @code{gsi_insert_after}.\n @end deftypefn\n@@ -2405,49 +2404,57 @@ Move all statements in the sequence before @code{I} to a new sequence.\n Return this new sequence.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gsi_replace (gimple_stmt_iterator *i, gimple stmt, bool update_eh_info)\n+@deftypefn {GIMPLE function} void gsi_replace (gimple_stmt_iterator *i, @\n+gimple stmt, bool update_eh_info)\n Replace the statement pointed-to by @code{I} to @code{STMT}.  If @code{UPDATE_EH_INFO}\n is true, the exception handling information of the original\n statement is moved to the new statement.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gsi_insert_before (gimple_stmt_iterator *i, gimple stmt, enum gsi_iterator_update mode)\n+@deftypefn {GIMPLE function} void gsi_insert_before (gimple_stmt_iterator *i, @\n+gimple stmt, enum gsi_iterator_update mode)\n Insert statement @code{STMT} before the statement pointed-to by iterator\n @code{I}, update @code{STMT}'s basic block and scan it for new operands.  @code{MODE}\n specifies how to update iterator @code{I} after insertion (see enum\n @code{gsi_iterator_update}).\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gsi_insert_seq_before (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)\n+@deftypefn {GIMPLE function} void gsi_insert_seq_before (gimple_stmt_iterator *i, @\n+gimple_seq seq, enum gsi_iterator_update mode)\n Like @code{gsi_insert_before}, but for all the statements in @code{SEQ}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gsi_insert_after (gimple_stmt_iterator *i, gimple stmt, enum gsi_iterator_update mode)\n+@deftypefn {GIMPLE function} void gsi_insert_after (gimple_stmt_iterator *i, @\n+gimple stmt, enum gsi_iterator_update mode)\n Insert statement @code{STMT} after the statement pointed-to by iterator\n @code{I}, update @code{STMT}'s basic block and scan it for new operands.  @code{MODE}\n specifies how to update iterator @code{I} after insertion (see enum\n @code{gsi_iterator_update}).\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gsi_insert_seq_after (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)\n+@deftypefn {GIMPLE function} void gsi_insert_seq_after (gimple_stmt_iterator *i, @\n+gimple_seq seq, enum gsi_iterator_update mode)\n Like @code{gsi_insert_after}, but for all the statements in @code{SEQ}.\n @end deftypefn\n \n @deftypefn {GIMPLE function} gimple_stmt_iterator gsi_for_stmt (gimple stmt)\n Finds iterator for @code{STMT}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gsi_move_after (gimple_stmt_iterator *from, gimple_stmt_iterator *to)\n+@deftypefn {GIMPLE function} void gsi_move_after (gimple_stmt_iterator *from, @\n+gimple_stmt_iterator *to)\n Move the statement at @code{FROM} so it comes right after the statement\n at @code{TO}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gsi_move_before (gimple_stmt_iterator *from, gimple_stmt_iterator *to)\n+@deftypefn {GIMPLE function} void gsi_move_before (gimple_stmt_iterator *from, @\n+gimple_stmt_iterator *to)\n Move the statement at @code{FROM} so it comes right before the statement\n at @code{TO}.\n @end deftypefn\n \n-@deftypefn {GIMPLE function} void gsi_move_to_bb_end (gimple_stmt_iterator *from, basic_block bb)\n+@deftypefn {GIMPLE function} void gsi_move_to_bb_end (gimple_stmt_iterator *from, @\n+basic_block bb)\n Move the statement at @code{FROM} to the end of basic block @code{BB}.\n @end deftypefn\n \n@@ -2515,7 +2522,8 @@ sequences: @code{walk_gimple_stmt} and @code{walk_gimple_seq},\n accordingly, and a third function for walking the operands in a\n statement: @code{walk_gimple_op}.\n \n-@deftypefn {GIMPLE function} tree walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)\n+@deftypefn {GIMPLE function} tree walk_gimple_stmt (gimple_stmt_iterator *gsi, @\n+  walk_stmt_fn callback_stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)\n This function is used to walk the current statement in @code{GSI},\n optionally using traversal state stored in @code{WI}.  If @code{WI} is @code{NULL}, no\n state is kept during the traversal.\n@@ -2535,7 +2543,8 @@ The return value is that returned by the last call to\n @end deftypefn\n \n \n-@deftypefn {GIMPLE function} tree walk_gimple_op (gimple stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)\n+@deftypefn {GIMPLE function} tree walk_gimple_op (gimple stmt, @\n+  walk_tree_fn callback_op, struct walk_stmt_info *wi)\n Use this function to walk the operands of statement @code{STMT}.  Every\n operand is walked via @code{walk_tree} with optional state information\n in @code{WI}.\n@@ -2555,7 +2564,8 @@ specified.\n @end deftypefn\n \n \n-@deftypefn {GIMPLE function} tree walk_gimple_seq (gimple_seq seq, walk_stmt_fn callback_stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)\n+@deftypefn {GIMPLE function} tree walk_gimple_seq (gimple_seq seq, @\n+  walk_stmt_fn callback_stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)\n This function walks all the statements in the sequence @code{SEQ}\n calling @code{walk_gimple_stmt} on each one.  @code{WI} is as in\n @code{walk_gimple_stmt}.  If @code{walk_gimple_stmt} returns non-@code{NULL}, the walk"}, {"sha": "b00cc54ab1b58ed9ebef2f8c726c6cc3632873de", "filename": "gcc/doc/hostconfig.texi", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9fd815db6b778af865526a491ab7c02691543e/gcc%2Fdoc%2Fhostconfig.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9fd815db6b778af865526a491ab7c02691543e/gcc%2Fdoc%2Fhostconfig.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fhostconfig.texi?ref=ae9fd815db6b778af865526a491ab7c02691543e", "patch": "@@ -43,7 +43,8 @@ This host hook is used to set up handling for extra signals.  The most\n common thing to do in this hook is to detect stack overflow.\n @end deftypefn\n \n-@deftypefn {Host Hook} void * HOST_HOOKS_GT_PCH_GET_ADDRESS (size_t @var{size}, int @var{fd})\n+@deftypefn {Host Hook} {void *} HOST_HOOKS_GT_PCH_GET_ADDRESS (size_t @\n+  @var{size}, int @var{fd})\n This host hook returns the address of some space that is likely to be\n free in some subsequent invocation of the compiler.  We intend to load\n the PCH data at this address such that the data need not be relocated.\n@@ -52,7 +53,8 @@ The area should be able to hold @var{size} bytes.  If the host uses\n probing.\n @end deftypefn\n \n-@deftypefn {Host Hook} int HOST_HOOKS_GT_PCH_USE_ADDRESS (void * @var{address}, size_t @var{size}, int @var{fd}, size_t @var{offset})\n+@deftypefn {Host Hook} int HOST_HOOKS_GT_PCH_USE_ADDRESS (void * @var{address}, @\n+  size_t @var{size}, int @var{fd}, size_t @var{offset})\n This host hook is called when a PCH file is about to be loaded.\n We want to load @var{size} bytes from @var{fd} at @var{offset}\n into memory at @var{address}.  The given address will be the result of"}]}