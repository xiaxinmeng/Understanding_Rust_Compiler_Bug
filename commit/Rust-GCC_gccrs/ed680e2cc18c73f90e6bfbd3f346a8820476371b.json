{"sha": "ed680e2cc18c73f90e6bfbd3f346a8820476371b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ2ODBlMmNjMThjNzNmOTBlNmJmYmQzZjM0NmE4ODIwNDc2MzcxYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-07-01T08:58:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-07-01T08:58:23Z"}, "message": "Make ira_get_dup_out_num handle more cases\n\nSVE has a prefix instruction (MOVPRFX) that acts as a move but is\ndesigned to be easily fusible with the following instruction.  The SVE\nport therefore has lots of patterns with constraints of the form:\n\n  A: operand 0: =w,?w\n     ...\n     operand n:  0, w\n\nwhere the first alternative is a single instruction and the second\nalternative uses MOVPRFX.\n\nIdeally we want operand n to be allocated to the same register as\noperand 0 in this case.\n\nadd_insn_allocno_copies is the main IRA routine that deals with tied\noperands.  It is (rightly) very conservative, and only handles cases in\nwhich we're confident about saving a full move.  So for a pattern like:\n\n  B: operand 0: =w,w\n     ...\n     operand n:  0,w\n\nwe don't (and shouldn't) assume that tying operands 0 and n would\nsave the cost of a move.\n\nBut in A, the second alternative has a ? marker, which makes it more\nexpensive than the first alternative by a full reload.  So I think for\ncopy elision we should ignore the untied operand n in the second\nalternative of A.\n\nOne approach would be to add '*' markers to each pattern and make\nira_get_dup_out_num honour them.  But I think the rule applies on\nfirst principles, so marking with '*' shouldn't be necessary.\n\nThis patch instead makes ira_get_dup_out_num ignore expensive\nalternatives if there are other alternatives that match exactly.\nThe cheapest way of doing that seemed to be to take expensive\nalternatives out of consideration in ira_setup_alts, which provides\na bitmask of alternatives and has all the information available.\nadd_insn_allocno_copies is the only current user of ira_setup_alts,\nso no other code should be affected.\n\nIf all available alternatives are disparaged or need a reload,\nthere's not much we can do to cut them down at this stage,\nsince it's hard to predict which operands will be reloaded and\nwhich registers will need to be spilled.\n\nAn interesting case is patterns like this msp430 one:\n\n;; Alternatives 2 and 3 are to handle cases generated by reload.\n(define_insn \"subqi3\"\n  [(set (match_operand:QI           0 \"nonimmediate_operand\" \"=rYs,  rm,  &?r, ?&r\")\n\t(minus:QI (match_operand:QI 1 \"general_operand\"       \"0,    0,    !r,  !i\")\n\t\t  (match_operand:QI 2 \"general_operand\"      \" riYs, rmi, rmi,   r\")))]\n  \"\"\n  \"@\n  SUB.B\\t%2, %0\n  SUB%X0.B\\t%2, %0\n  MOV%X0.B\\t%1, %0 { SUB%X0.B\\t%2, %0\n  MOV%X0.B\\t%1, %0 { SUB%X0.B\\t%2, %0\"\n)\n\nHere alternative 3 is significantly more expensive then alternative 0\n(reject costs 0 and 606 respectively).  But if operand 1 is an integer\nconstant, we'll still use alternative 3 if operand 2 is an allocated\nregister.  On the other hand, if operand 1 is an integer constant but\noperand 2 is spilled to memory, we'll move the constant into a register\nand use the first alternative.\n\nSo in this case, if operand 1 is a register, we should consider\nonly the first two alternatives and thus try to tie operand 1\nto operand 0 (which we didn't do previously).  If operand 1 is a\nconstant integer, we should consider at least alternatives 0, 1 and 3.\nWe could exclude alternative 2, but I don't have any evidence that\nthat's useful.\n\n2019-07-01  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* ira.c (ira_setup_alts): If any valid alternatives have zero cost,\n\texclude any others that are disparaged or that are bound to need\n\ta reload or spill.\n\t(ira_get_dup_out_num): Expand comment.\n\nFrom-SVN: r272849", "tree": {"sha": "1c5d951f6264dd3d03b7bc637dddbd8af08cfd70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c5d951f6264dd3d03b7bc637dddbd8af08cfd70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed680e2cc18c73f90e6bfbd3f346a8820476371b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed680e2cc18c73f90e6bfbd3f346a8820476371b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed680e2cc18c73f90e6bfbd3f346a8820476371b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed680e2cc18c73f90e6bfbd3f346a8820476371b/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "06a65e803ed06f3ad1fd8e5f90db03aa0a7e5414", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a65e803ed06f3ad1fd8e5f90db03aa0a7e5414", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06a65e803ed06f3ad1fd8e5f90db03aa0a7e5414"}], "stats": {"total": 62, "additions": 51, "deletions": 11}, "files": [{"sha": "8f70d1b385e1a3dcdc336c7fef36dd7f51911950", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed680e2cc18c73f90e6bfbd3f346a8820476371b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed680e2cc18c73f90e6bfbd3f346a8820476371b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed680e2cc18c73f90e6bfbd3f346a8820476371b", "patch": "@@ -1,3 +1,10 @@\n+2019-07-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* ira.c (ira_setup_alts): If any valid alternatives have zero cost,\n+\texclude any others that are disparaged or that are bound to need\n+\ta reload or spill.\n+\t(ira_get_dup_out_num): Expand comment.\n+\n 2019-07-01  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* ira.c (ira_setup_alts): Use preprocess_constraints to get the"}, {"sha": "d9327db4e8fa54f6225b7760d5c975c8f5ba63b5", "filename": "gcc/ira.c", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed680e2cc18c73f90e6bfbd3f346a8820476371b/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed680e2cc18c73f90e6bfbd3f346a8820476371b/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=ed680e2cc18c73f90e6bfbd3f346a8820476371b", "patch": "@@ -1787,7 +1787,9 @@ setup_prohibited_mode_move_regs (void)\n /* Extract INSN and return the set of alternatives that we should consider.\n    This excludes any alternatives whose constraints are obviously impossible\n    to meet (e.g. because the constraint requires a constant and the operand\n-   is nonconstant).  */\n+   is nonconstant).  It also excludes alternatives that are bound to need\n+   a spill or reload, as long as we have other alternatives that match\n+   exactly.  */\n alternative_mask\n ira_setup_alts (rtx_insn *insn)\n {\n@@ -1800,6 +1802,7 @@ ira_setup_alts (rtx_insn *insn)\n   preprocess_constraints (insn);\n   alternative_mask preferred = get_preferred_alternatives (insn);\n   alternative_mask alts = 0;\n+  alternative_mask exact_alts = 0;\n   /* Check that the hard reg set is enough for holding all\n      alternatives.  It is hard to imagine the situation when the\n      assertion is wrong.  */\n@@ -1816,20 +1819,24 @@ ira_setup_alts (rtx_insn *insn)\n     {\n       for (nalt = 0; nalt < recog_data.n_alternatives; nalt++)\n \t{\n-\t  if (!TEST_BIT (preferred, nalt) || TEST_BIT (alts, nalt))\n+\t  if (!TEST_BIT (preferred, nalt) || TEST_BIT (exact_alts, nalt))\n \t    continue;\n \n \t  const operand_alternative *op_alt\n \t    = &recog_op_alt[nalt * recog_data.n_operands];\n+\t  int this_reject = 0;\n \t  for (nop = 0; nop < recog_data.n_operands; nop++)\n \t    {\n \t      int c, len;\n \n+\t      this_reject += op_alt[nop].reject;\n+\n \t      rtx op = recog_data.operand[nop];\n \t      p = op_alt[nop].constraint;\n \t      if (*p == 0 || *p == ',')\n \t\tcontinue;\n-\t      \n+\n+\t      bool win_p = false;\n \t      do\n \t\tswitch (c = *p, len = CONSTRAINT_LEN (c, p), c)\n \t\t  {\n@@ -1847,7 +1854,14 @@ ira_setup_alts (rtx_insn *insn)\n \n \t\t  case '0':  case '1':  case '2':  case '3':  case '4':\n \t\t  case '5':  case '6':  case '7':  case '8':  case '9':\n-\t\t    goto op_success;\n+\t\t    {\n+\t\t      rtx other = recog_data.operand[c - '0'];\n+\t\t      if (MEM_P (other)\n+\t\t\t  ? rtx_equal_p (other, op)\n+\t\t\t  : REG_P (op) || SUBREG_P (op))\n+\t\t\tgoto op_success;\n+\t\t      win_p = true;\n+\t\t    }\n \t\t    break;\n \t\t    \n \t\t  case 'g':\n@@ -1861,7 +1875,11 @@ ira_setup_alts (rtx_insn *insn)\n \t\t\t{\n \t\t\tcase CT_REGISTER:\n \t\t\t  if (reg_class_for_constraint (cn) != NO_REGS)\n-\t\t\t    goto op_success;\n+\t\t\t    {\n+\t\t\t      if (REG_P (op) || SUBREG_P (op))\n+\t\t\t\tgoto op_success;\n+\t\t\t      win_p = true;\n+\t\t\t    }\n \t\t\t  break;\n \n \t\t\tcase CT_CONST_INT:\n@@ -1872,9 +1890,14 @@ ira_setup_alts (rtx_insn *insn)\n \t\t\t  break;\n \n \t\t\tcase CT_ADDRESS:\n+\t\t\t  goto op_success;\n+\n \t\t\tcase CT_MEMORY:\n \t\t\tcase CT_SPECIAL_MEMORY:\n-\t\t\t  goto op_success;\n+\t\t\t  if (MEM_P (op))\n+\t\t\t    goto op_success;\n+\t\t\t  win_p = true;\n+\t\t\t  break;\n \n \t\t\tcase CT_FIXED_FORM:\n \t\t\t  if (constraint_satisfied_p (op, cn))\n@@ -1885,12 +1908,22 @@ ira_setup_alts (rtx_insn *insn)\n \t\t    }\n \t\t  }\n \t      while (p += len, c);\n-\t      break;\n+\t      if (!win_p)\n+\t\tbreak;\n+\t      /* We can make the alternative match by spilling a register\n+\t\t to memory or loading something into a register.  Count a\n+\t\t cost of one reload (the equivalent of the '?' constraint).  */\n+\t      this_reject += 6;\n \t    op_success:\n \t      ;\n \t    }\n+\n \t  if (nop >= recog_data.n_operands)\n-\t    alts |= ALTERNATIVE_BIT (nalt);\n+\t    {\n+\t      alts |= ALTERNATIVE_BIT (nalt);\n+\t      if (this_reject == 0)\n+\t\texact_alts |= ALTERNATIVE_BIT (nalt);\n+\t    }\n \t}\n       if (commutative < 0)\n \tbreak;\n@@ -1900,13 +1933,13 @@ ira_setup_alts (rtx_insn *insn)\n       if (curr_swapped)\n \tbreak;\n     }\n-  return alts;\n+  return exact_alts ? exact_alts : alts;\n }\n \n /* Return the number of the output non-early clobber operand which\n    should be the same in any case as operand with number OP_NUM (or\n-   negative value if there is no such operand).  The function takes\n-   only really possible alternatives into consideration.  */\n+   negative value if there is no such operand).  ALTS is the mask\n+   of alternatives that we should consider.  */\n int\n ira_get_dup_out_num (int op_num, alternative_mask alts)\n {"}]}