{"sha": "6cfc7210fa88997c7b22415241c1b325b25bcb7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNmYzcyMTBmYTg4OTk3YzdiMjI0MTUyNDFjMWIzMjViMjViY2I3Yg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-07-17T13:44:35Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-07-17T13:44:35Z"}, "message": "General tidyup of header files.\n\nFrom-SVN: r28138", "tree": {"sha": "3b52d8d7c13371005d2b44baaab9abe49e1622a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b52d8d7c13371005d2b44baaab9abe49e1622a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cfc7210fa88997c7b22415241c1b325b25bcb7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cfc7210fa88997c7b22415241c1b325b25bcb7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cfc7210fa88997c7b22415241c1b325b25bcb7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cfc7210fa88997c7b22415241c1b325b25bcb7b/comments", "author": null, "committer": null, "parents": [{"sha": "8f7cbf16355cc9550397eb949f2d1ecbf8791040", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f7cbf16355cc9550397eb949f2d1ecbf8791040", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f7cbf16355cc9550397eb949f2d1ecbf8791040"}], "stats": {"total": 852, "additions": 489, "deletions": 363}, "files": [{"sha": "8bc56e41ae848cd685f06806c5cd42816df106a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cfc7210fa88997c7b22415241c1b325b25bcb7b", "patch": "@@ -1,3 +1,42 @@\n+Sat Jul 17 14:25:46 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/aout.h: Reformat for improved readability.\n+\t\n+\t* config/arm/arm.h: Reformat for improved readability.\n+\tReplace uses of fprintf with asm_fprintf where appropriate.\n+\t(ARM_DECLARE_FUNCTION_NAME): New macro:  Perform any generic ARM\n+\tfunction declaration assembler actions.\n+\t(NUM_INTS): New macro: Convert from bytes to words.\n+\t(NUM_REGS): New macro: Compute number of registers required to\n+\thold a quanitity of tyep MODE.\n+\t(NUM_REGS2): New macro: Like NUM_REGS but also copes with BLKmode\n+\ttypes.\n+\t(NUM_ARG_REGS): New macro: The number of argument registers\n+\tavailable.\n+\t(ARG_REGISTER): New macro: Compute the register number of the Nth\n+\targument register.\n+\t(LAST_ARG_REGNUM): New macro: The number of the last argument\n+\tregister.\n+\t(SP_REGNUM): New macro: Register number of the stack pointer.\n+\t(FP_REGNUM): New macro: Register number of the frame pointer.\n+\t(FUNCTION_ARG, FUNCTION_ARG_PARTIAL_NREGS, INIT_CUMULATIVE_AGS,\n+\tFUNCTION_ARG_ADVANCE, SETUP_INCOMING_VARARGS): Change\n+\tCUMULATIVE_ARGS so that it counts registers not bytes.\n+\t\n+\t* config/arm/arm.c: Rename TARGET_THUMB_INTERWORK to\n+\tTARGET_INTERWORK.\n+\tReplace uses of fprintf with asm_fprintf where appropriate.\n+\t(output_ascii_pseudo_op): Replace with version from thumb.c\n+\n+\t* config/arm/coff.h (ASM_FILE_START): Emit ASM_APP_OFF.\n+\n+\t* config/arm/elf.h (CPP_PREDEFINES): Replace with\n+\tSUBTARGET_CPP_SPEC.\n+\t(ASM_DECLARE_FUNCTION_NAME): Use ARM_DECLARE_FUNCTION_NAME.\n+\t(ASM_FILE_START): Emit ASM_APP_OFF.\n+\t\n+\t\n+\t\n Fri Jul 16 13:48:09 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* pa.c (compute_frame_size): Round frame according to "}, {"sha": "1f3ee79596b96a84f7d8eb5dae9cd701463b69e2", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 130, "deletions": 100, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=6cfc7210fa88997c7b22415241c1b325b25bcb7b", "patch": "@@ -100,7 +100,7 @@ Boston, MA 02111-1307, USA.  */\n /* Arm Assembler barfs on dollars */\n #define DOLLARS_IN_IDENTIFIERS 0\n \n-#define NO_DOLLAR_IN_LABEL\n+#define NO_DOLLAR_IN_LABEL 1\n \n /* DBX register number for a given compiler register number */\n #define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n@@ -118,39 +118,48 @@ Boston, MA 02111-1307, USA.  */\n \n /* Output a source filename for the debugger. RISCiX dbx insists that the\n    ``desc'' field is set to compiler version number >= 315 (sic).  */\n-#define DBX_OUTPUT_MAIN_SOURCE_FILENAME(STREAM,NAME) \t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \".stabs \");\t\t\t\t\t\t\\\n-  output_quoted_string (STREAM, NAME);\t\t\t\t\t\\\n-  fprintf (STREAM, \",%d,0,315,%s\\n\", N_SO, &ltext_label_name[1]);\t\\\n-  text_section ();\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_INTERNAL_LABEL (STREAM, \"Ltext\", 0);\t\t\t\\\n-} while (0)\n+#define DBX_OUTPUT_MAIN_SOURCE_FILENAME(STREAM, NAME)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \".stabs \");\t\t\t\t\t\\\n+      output_quoted_string (STREAM, NAME);\t\t\t\t\\\n+      fprintf (STREAM, \",%d,0,315,%s\\n\", N_SO, &ltext_label_name[1]);\t\\\n+      text_section ();\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_INTERNAL_LABEL (STREAM, \"Ltext\", 0);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n   \n /* Output a function label definition.  */\n #ifndef ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL)\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (TARGET_POKE_FUNCTION_NAME)\t\t\t\\\n-    arm_poke_function_name ((STREAM), (NAME));\t\t\\\n-  ASM_OUTPUT_LABEL (STREAM, NAME);\t\t\t\\\n-}\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      ARM_DECLARE_FUNCTION_NAME (STREAM, NAME, DECL);   \\\n+      ASM_OUTPUT_LABEL (STREAM, NAME);\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n #ifndef ASM_OUTPUT_LABEL\n-#define ASM_OUTPUT_LABEL(STREAM,NAME)\t\\\n-do {\t\t\t\t\t\\\n-  assemble_name (STREAM,NAME);\t\t\\\n-  fputs (\":\\n\", STREAM);\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_LABEL(STREAM, NAME)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      assemble_name (STREAM,NAME);\t\t\\\n+      fputs (\":\\n\", STREAM);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n #endif\n      \n /* Output a globalising directive for a label.  */\n #ifndef ASM_GLOBALIZE_LABEL\n-#define ASM_GLOBALIZE_LABEL(STREAM,NAME)  \\\n-  (fprintf (STREAM, \"\\t.global\\t\"),\t  \\\n-   assemble_name (STREAM, NAME),\t  \\\n-   fputc ('\\n',STREAM))                   \n+#define ASM_GLOBALIZE_LABEL(STREAM, NAME)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.global\\t\");\t\t\\\n+      assemble_name (STREAM, NAME);\t\t\\\n+      fputc ('\\n',STREAM);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n /* Make an internal label into a string.  */\n@@ -159,122 +168,143 @@ do {\t\t\t\t\t\\\n   sprintf (STRING, \"*%s%s%u\", LOCAL_LABEL_PREFIX, PREFIX, (unsigned int)(NUM))\n #endif\n      \n-/* Nothing special is done about jump tables */\n-/* #define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE)   */\n-/* #define ASM_OUTPUT_CASE_END(STREAM,NUM,TABLE)\t    */\n-\n /* Construct a private name.  */\n-#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)  \\\n+#define ASM_FORMAT_PRIVATE_NAME(OUTVAR, NAME, NUMBER)  \\\n   ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),  \\\n-   sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n+   sprintf (OUTVAR, \"%s.%d\", NAME, NUMBER))\n \n /* Output an element of a dispatch table.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \\\n-   fprintf (STREAM, \"\\t.word\\t%sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE)\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)  \\\n+  asm_fprintf (STREAM, \"\\t.word\\t%LL%d\\n\", VALUE)\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)  \\\n-   fprintf (STREAM, \"\\tb\\t%sL%d\\n\", LOCAL_LABEL_PREFIX, (VALUE))\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)  \\\n+  asm_fprintf (STREAM, \"\\tb\\t%LL%d\\n\", VALUE)\n \n /* Output various types of constants.  For real numbers we output hex, with\n    a comment containing the \"human\" value, this allows us to pass NaN's which\n    the riscix assembler doesn't understand (it also makes cross-assembling\n    less likely to fail). */\n \n-#define ASM_OUTPUT_LONG_DOUBLE(STREAM,VALUE)\t\t\t\t\\\n-do { char dstr[30];\t\t\t\t\t\t\t\\\n-     long l[3];\t\t\t\t\t\t\t\t\\\n-     REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n-     fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\t%s long double %s\\n\", \\\n-\t      l[0], l[1], l[2], ASM_COMMENT_START, dstr);\t\t\\\n-   } while (0)\n-\n-    \n-#define ASM_OUTPUT_DOUBLE(STREAM, VALUE)  \t\t\t\t\\\n-do { char dstr[30];\t\t\t\t\t\t\t\\\n-     long l[2];\t\t\t\t\t\t\t\t\\\n-     REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL (VALUE, \"%.14g\", dstr);\t\t\t\\\n-     fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t%s double %s\\n\", l[0],\t\\\n-\t      l[1], ASM_COMMENT_START, dstr);\t\t\t\t\\\n-   } while (0)\n-\n-#define ASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\t\t\\\n-do { char dstr[30];\t\t\t\t\t\t\t\\\n-     long l;\t\t\t\t\t\t\t\t\\\n-     REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL (VALUE, \"%.7g\", dstr);\t\t\t\\\n-     fprintf (STREAM, \"\\t.word 0x%lx\\t%s float %s\\n\", l,\t\t\\\n-\t      ASM_COMMENT_START, dstr);\t\t\t\t\t\\\n-   } while (0);\n+#define ASM_OUTPUT_LONG_DOUBLE(STREAM, VALUE)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\t\\\n+      char dstr[30];\t\t\t\t\t\t\t\t\\\n+      long l[3];\t\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\t%s long double %s\\n\",\t\\\n+\t       l[0], l[1], l[2], ASM_COMMENT_START, dstr);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_DOUBLE(STREAM, VALUE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      char dstr[30];\t\t\t\t\t\t\t\\\n+      long l[2];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (VALUE, \"%.14g\", dstr);\t\t\t\\\n+      fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t%s double %s\\n\", l[0],\t\\\n+\t       l[1], ASM_COMMENT_START, dstr);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char dstr[30];\t\t\t\t\t\t\\\n+      long l;\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (VALUE, \"%.7g\", dstr);\t\t\\\n+      fprintf (STREAM, \"\\t.word 0x%lx\\t%s float %s\\n\", l,\t\\\n+\t       ASM_COMMENT_START, dstr);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n #define ASM_OUTPUT_INT(STREAM, EXP)\t\t\\\n-  {\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.word\\t\");\t\t\\\n-    OUTPUT_INT_ADDR_CONST (STREAM, (EXP));\t\\\n-    fputc ('\\n', STREAM);\t\t\t\\\n-  }\n-\n-#define ASM_OUTPUT_SHORT(STREAM, EXP)  \\\n-  (fprintf (STREAM, \"\\t.short\\t\"),     \\\n-   output_addr_const (STREAM, (EXP)),  \\\n-   fputc ('\\n', STREAM))\n-\n-#define ASM_OUTPUT_CHAR(STREAM, EXP)  \\\n-  (fprintf (STREAM, \"\\t.byte\\t\"),      \\\n-   output_addr_const (STREAM, (EXP)),  \\\n-   fputc ('\\n', STREAM))\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.word\\t\");\t\t\\\n+      OUTPUT_INT_ADDR_CONST (STREAM, EXP);\t\\\n+      fputc ('\\n', STREAM);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_SHORT(STREAM, EXP)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.short\\t\");\t\t\\\n+      output_addr_const (STREAM, EXP);\t\t\\\n+      fputc ('\\n', STREAM);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_CHAR(STREAM, EXP)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.byte\\t\");\t\t\\\n+      output_addr_const (STREAM, EXP);\t\t\\\n+      fputc ('\\n', STREAM);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n #define ASM_OUTPUT_BYTE(STREAM, VALUE)  \t\\\n   fprintf (STREAM, \"\\t.byte\\t%d\\n\", VALUE)\n \n #define ASM_OUTPUT_ASCII(STREAM, PTR, LEN)  \\\n-  output_ascii_pseudo_op ((STREAM), (unsigned char *)(PTR), (LEN))\n+  output_ascii_pseudo_op (STREAM, (unsigned char *)(PTR), LEN)\n \n /* Output a gap.  In fact we fill it with nulls.  */\n #define ASM_OUTPUT_SKIP(STREAM, NBYTES) \t\\\n-   fprintf (STREAM, \"\\t.space\\t%d\\n\", NBYTES)\n+  fprintf (STREAM, \"\\t.space\\t%d\\n\", NBYTES)\n \n /* Align output to a power of two.  Horrible /bin/as.  */\n #ifndef ASM_OUTPUT_ALIGN  \n-#define ASM_OUTPUT_ALIGN(STREAM, POWER)  \\\n-  do                                                           \\\n-    {                                                          \\\n-      register int amount = 1 << (POWER);                      \\\n-                                                               \\\n-      if (amount == 2)                                         \\\n-\tfprintf (STREAM, \"\\t.even\\n\");                         \\\n-      else if (amount != 1)                                    \\\n-\tfprintf (STREAM, \"\\t.align\\t%d\\n\", amount - 4);        \\\n-    }\t\t\t\t\t\t\t       \\\n+#define ASM_OUTPUT_ALIGN(STREAM, POWER)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      register int amount = 1 << (POWER);\t\t\\\n+\t\t\t\t\t\t\t\\\n+      if (amount == 2)\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\t.even\\n\");\t\t\t\\\n+      else if (amount != 1)\t\t\t\t\\\n+\tfprintf (STREAM, \"\\t.align\\t%d\\n\", amount - 4);\t\\\n+    }\t\t\t\t\t\t\t\\\n   while (0)\n #endif\n \n /* Output a common block */\n #ifndef ASM_OUTPUT_COMMON\n-#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)  \t\t\\\n-  (fprintf (STREAM, \"\\t.comm\\t\"), \t\t     \t\t\t\\\n-   assemble_name ((STREAM), (NAME)),\t\t     \t\t\t\\\n-   fprintf (STREAM, \", %d\\t%s %d\\n\", ROUNDED, ASM_COMMENT_START, SIZE))\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.comm\\t\");\t\t\t\\\n+      assemble_name (STREAM, NAME);\t\t\t\\\n+      fprintf (STREAM, \", %d\\t%s %d\\n\", ROUNDED,\t\\\n+\t       ASM_COMMENT_START, SIZE);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n      \n /* Output a local common block.  /bin/as can't do this, so hack a\n    `.space' into the bss segment.  Note that this is *bad* practice,\n    which is guaranteed NOT to work since it doesn't define STATIC\n    COMMON space but merely STATIC BSS space.  */\n #ifndef ASM_OUTPUT_ALIGNED_LOCAL\n-#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM,NAME,SIZE,ALIGN)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    bss_section ();\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_ALIGN (STREAM, floor_log2 (ALIGN / BITS_PER_UNIT));\t\\\n-    ASM_OUTPUT_LABEL (STREAM, NAME);\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.space\\t%d\\n\", SIZE);\t\t\t\t\\\n-  } while (0)\n+#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGN)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      bss_section ();\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_ALIGN (STREAM, floor_log2 (ALIGN / BITS_PER_UNIT));\t\\\n+      ASM_OUTPUT_LABEL (STREAM, NAME);\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.space\\t%d\\n\", SIZE);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n      \n /* Output a zero-initialized block.  */\n #ifndef ASM_OUTPUT_ALIGNED_BSS\n-#define ASM_OUTPUT_ALIGNED_BSS(STREAM,DECL,NAME,SIZE,ALIGN) \\\n+#define ASM_OUTPUT_ALIGNED_BSS(STREAM, DECL, NAME, SIZE, ALIGN) \\\n   asm_output_aligned_bss (STREAM, DECL, NAME, SIZE, ALIGN)\n #endif\n      "}, {"sha": "a0945b302ef10299b04dbcd361b5784e1b6c191c", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 119, "deletions": 91, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6cfc7210fa88997c7b22415241c1b325b25bcb7b", "patch": "@@ -144,9 +144,6 @@ int current_function_anonymous_args;\n /* The register number to be used for the PIC offset register.  */\n int arm_pic_register = 9;\n \n-/* Location counter of .text segment.  */\n-int arm_text_location = 0;\n-\n /* Set to one if we think that lr is only saved because of subroutine calls,\n    but all of these can be `put after' return insns */\n int lr_save_eliminated;\n@@ -366,7 +363,7 @@ arm_override_options ()\n \t switch that require certain abilities from the cpu.  */\n       sought = 0;\n       \n-      if (TARGET_THUMB_INTERWORK)\n+      if (TARGET_INTERWORK)\n \t{\n \t  sought |= (FL_THUMB | FL_MODE32);\n \t  \n@@ -456,14 +453,14 @@ arm_override_options ()\n       target_flags |= ARM_FLAG_APCS_32;\n     }\n   \n-  if (TARGET_THUMB_INTERWORK && !(insn_flags & FL_THUMB))\n+  if (TARGET_INTERWORK && !(insn_flags & FL_THUMB))\n     {\n       warning (\"target CPU does not support interworking\" );\n-      target_flags &= ~ARM_FLAG_THUMB;\n+      target_flags &= ~ARM_FLAG_INTERWORK;\n     }\n   \n   /* If interworking is enabled then APCS-32 must be selected as well.  */\n-  if (TARGET_THUMB_INTERWORK)\n+  if (TARGET_INTERWORK)\n     {\n       if (! TARGET_APCS_32)\n \twarning (\"interworking forces APCS-32 to be used\" );\n@@ -476,9 +473,6 @@ arm_override_options ()\n       target_flags |= ARM_FLAG_APCS_FRAME;\n     }\n   \n-  if (write_symbols != NO_DEBUG && flag_omit_frame_pointer)\n-    warning (\"-g with -fomit-frame-pointer may not give sensible debugging\");\n-  \n   if (TARGET_POKE_FUNCTION_NAME)\n     target_flags |= ARM_FLAG_APCS_FRAME;\n   \n@@ -488,6 +482,9 @@ arm_override_options ()\n   if (TARGET_APCS_REENT)\n     warning (\"APCS reentrant code not supported.  Ignored\");\n   \n+  if (write_symbols != NO_DEBUG && flag_omit_frame_pointer)\n+    warning (\"-g with -fomit-frame-pointer may not give sensible debugging\");\n+  \n   /* If stack checking is disabled, we can use r10 as the PIC register,\n      which keeps r9 available.  */\n   if (flag_pic && ! TARGET_APCS_STACK)\n@@ -583,7 +580,7 @@ use_return_insn (iscond)\n   if (iscond && arm_is_strong && frame_pointer_needed)\n     return 0;\n   if ((iscond && arm_is_strong)\n-      || TARGET_THUMB_INTERWORK)\n+      || TARGET_INTERWORK)\n     {\n       for (regno = 0; regno < 16; regno++)\n \tif (regs_ever_live[regno] && ! call_used_regs[regno])\n@@ -4409,7 +4406,7 @@ print_multi_reg (stream, instr, mask, hat)\n \tif (not_first)\n \t  fprintf (stream, \", \");\n \t\n-\tfprintf (stream, \"%s%s\", REGISTER_PREFIX, reg_names[i]);\n+\tasm_fprintf (stream, \"%R%s\", reg_names[i]);\n \tnot_first = TRUE;\n       }\n \n@@ -4432,7 +4429,7 @@ output_call (operands)\n   \n   output_asm_insn (\"mov%?\\t%|lr, %|pc\", operands);\n   \n-  if (TARGET_THUMB_INTERWORK)\n+  if (TARGET_INTERWORK)\n     output_asm_insn (\"bx%?\\t%0\", operands);\n   else\n     output_asm_insn (\"mov%?\\t%|pc, %0\", operands);\n@@ -4486,7 +4483,7 @@ output_call_mem (operands)\n   if (eliminate_lr2ip (&operands[0]))\n     output_asm_insn (\"mov%?\\t%|ip, %|lr\", operands);\n \n-  if (TARGET_THUMB_INTERWORK)\n+  if (TARGET_INTERWORK)\n     {\n       output_asm_insn (\"ldr%?\\t%|ip, %0\", operands);\n       output_asm_insn (\"mov%?\\t%|lr, %|pc\", operands);\n@@ -4653,9 +4650,9 @@ output_move_double (operands)\n \n \t  /* Ensure the second source is not overwritten */\n \t  if (reg1 == reg0 + (WORDS_BIG_ENDIAN ? -1 : 1))\n-\t    output_asm_insn(\"mov%?\\t%Q0, %Q1\\n\\tmov%?\\t%R0, %R1\", operands);\n+\t    output_asm_insn (\"mov%?\\t%Q0, %Q1\\n\\tmov%?\\t%R0, %R1\", operands);\n \t  else\n-\t    output_asm_insn(\"mov%?\\t%R0, %R1\\n\\tmov%?\\t%Q0, %Q1\", operands);\n+\t    output_asm_insn (\"mov%?\\t%R0, %R1\\n\\tmov%?\\t%Q0, %Q1\", operands);\n \t}\n       else if (code1 == CONST_DOUBLE)\n \t{\n@@ -4684,6 +4681,7 @@ output_move_double (operands)\n \t      otherops[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n \t      operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n \t    }\n+\t  \n \t  output_mov_immediate (operands);\n \t  output_mov_immediate (otherops);\n \t}\n@@ -4779,6 +4777,7 @@ output_move_double (operands)\n \t\t    }\n \t\t  else\n \t\t    output_asm_insn (\"sub%?\\t%0, %1, %2\", otherops);\n+\t\t  \n \t\t  return \"ldm%?ia\\t%0, %M0\";\n                 }\n               else\n@@ -5105,6 +5104,7 @@ int_log2 (power)\n \n /* Output a .ascii pseudo-op, keeping track of lengths.  This is because\n    /bin/as is horribly restrictive.  */\n+#define MAX_ASCII_LEN 51\n \n void\n output_ascii_pseudo_op (stream, p, len)\n@@ -5113,40 +5113,72 @@ output_ascii_pseudo_op (stream, p, len)\n      int len;\n {\n   int i;\n-  int len_so_far = 1000;\n-  int chars_so_far = 0;\n+  int len_so_far = 0;\n \n+  fputs (\"\\t.ascii\\t\\\"\", stream);\n+  \n   for (i = 0; i < len; i++)\n     {\n       register int c = p[i];\n \n-      if (len_so_far > 50)\n+      if (len_so_far >= MAX_ASCII_LEN)\n \t{\n-\t  if (chars_so_far)\n-\t    fputs (\"\\\"\\n\", stream);\n-\t  fputs (\"\\t.ascii\\t\\\"\", stream);\n+\t  fputs (\"\\\"\\n\\t.ascii\\t\\\"\", stream);\n \t  len_so_far = 0;\n-\t  chars_so_far = 0;\n \t}\n \n-      if (c == '\\\"' || c == '\\\\')\n+      switch (c)\n \t{\n-\t  putc('\\\\', stream);\n-\t  len_so_far++;\n-\t}\n+\tcase TARGET_TAB:\t\t\n+\t  fputs (\"\\\\t\", stream);\n+\t  len_so_far += 2;\t\t\t\n+\t  break;\n+\t  \n+\tcase TARGET_FF:\n+\t  fputs (\"\\\\f\", stream);\n+\t  len_so_far += 2;\n+\t  break;\n+\t  \n+\tcase TARGET_BS:\n+\t  fputs (\"\\\\b\", stream);\n+\t  len_so_far += 2;\n+\t  break;\n+\t  \n+\tcase TARGET_CR:\n+\t  fputs (\"\\\\r\", stream);\n+\t  len_so_far += 2;\n+\t  break;\n+\t  \n+\tcase TARGET_NEWLINE:\n+\t  fputs (\"\\\\n\", stream);\n+\t  c = p [i + 1];\n+\t  if ((c >= ' ' && c <= '~')\n+\t      || c == TARGET_TAB)\n+\t    /* This is a good place for a line break.  */\n+\t    len_so_far = MAX_ASCII_LEN;\n+\t  else\n+\t    len_so_far += 2;\n+\t  break;\n+\t  \n+\tcase '\\\"':\n+\tcase '\\\\':\n+\t  putc ('\\\\', stream);\n+\t  len_so_far ++;\n+\t  /* drop through.  */\n \n-      if (c >= ' ' && c < 0177)\n-\t{\n-\t  putc (c, stream);\n-\t  len_so_far++;\n-\t}\n-      else\n-\t{\n-\t  fprintf (stream, \"\\\\%03o\", c);\n-\t  len_so_far +=4;\n+\tdefault:\n+\t  if (c >= ' ' && c <= '~')\n+\t    {\n+\t      putc (c, stream);\n+\t      len_so_far ++;\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf (stream, \"\\\\%03o\", c);\n+\t      len_so_far += 4;\n+\t    }\n+\t  break;\n \t}\n-\n-      chars_so_far++;\n     }\n \n   fputs (\"\\\"\\n\", stream);\n@@ -5376,21 +5408,21 @@ output_return_instruction (operand, really_return, reverse)\n           strcat (instr, reg_names[13]);\n           strcat (instr, \", \");\n \t  strcat (instr, \"%|\");\n-\t  strcat (instr, TARGET_THUMB_INTERWORK || (! really_return)\n+\t  strcat (instr, TARGET_INTERWORK || (! really_return)\n \t\t  ? reg_names[LR_REGNUM] : reg_names[PC_REGNUM] );\n         }\n       else\n \t{\n \t  strcat (instr, \"%|\");\n-\t  if (TARGET_THUMB_INTERWORK && really_return)\n+\t  if (TARGET_INTERWORK && really_return)\n \t    strcat (instr, reg_names[IP_REGNUM]);\n \t  else\n \t    strcat (instr, really_return ? reg_names[PC_REGNUM] : reg_names[LR_REGNUM]);\n \t}\n       strcat (instr, (TARGET_APCS_32 || !really_return) ? \"}\" : \"}^\");\n       output_asm_insn (instr, &operand);\n \n-      if (TARGET_THUMB_INTERWORK && really_return)\n+      if (TARGET_INTERWORK && really_return)\n \t{\n \t  strcpy (instr, \"bx%?\");\n \t  strcat (instr, reverse ? \"%D0\" : \"%d0\");\n@@ -5402,7 +5434,7 @@ output_return_instruction (operand, really_return, reverse)\n     }\n   else if (really_return)\n     {\n-      if (TARGET_THUMB_INTERWORK)\n+      if (TARGET_INTERWORK)\n \tsprintf (instr, \"bx%%?%%%s0\\t%%|lr\", reverse ? \"D\" : \"d\");\n       else\n \tsprintf (instr, \"mov%%?%%%s0%s\\t%%|pc, %%|lr\",\n@@ -5463,7 +5495,7 @@ arm_poke_function_name (stream, name)\n   rtx           x;\n \n   length = strlen (name);\n-  alignlength = (length + 1) + 3 & ~3;\n+  alignlength = NUM_INTS (length + 1);\n   \n   ASM_OUTPUT_ASCII (stream, name, length + 1);\n   ASM_OUTPUT_ALIGN (stream, 2);\n@@ -5482,7 +5514,7 @@ arm_poke_function_name (stream, name)\n    \n void\n output_func_prologue (f, frame_size)\n-     FILE *f;\n+     FILE * f;\n      int frame_size;\n {\n   int reg, live_regs_mask = 0;\n@@ -5551,8 +5583,8 @@ output_func_prologue (f, frame_size)\n \n #ifdef AOF_ASSEMBLER\n   if (flag_pic)\n-    fprintf (f, \"\\tmov\\t%sip, %s%s\\n\", REGISTER_PREFIX, REGISTER_PREFIX,\n-\t     reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+    asm_fprintf (f, \"\\tmov\\t%R%s, %R%s\\n\", reg_names [IP_REGNUM],\n+\t\t reg_names[PIC_OFFSET_TABLE_REGNUM]);\n #endif\n }\n \n@@ -5612,8 +5644,8 @@ output_func_epilogue (f, frame_size)\n \t    if (regs_ever_live[reg] && ! call_used_regs[reg])\n \t      {\n \t\tfloats_offset += 12;\n-\t\tfprintf (f, \"\\tldfe\\t%s%s, [%sfp, #-%d]\\n\", REGISTER_PREFIX,\n-\t\t\t reg_names[reg], REGISTER_PREFIX, floats_offset);\n+\t\tasm_fprintf (f, \"\\tldfe\\t%R%s, [%R%s, #-%d]\\n\", \n+\t\t\t reg_names[reg], reg_names [FP_REGNUM], floats_offset);\n \t      }\n \t}\n       else\n@@ -5625,38 +5657,38 @@ output_func_epilogue (f, frame_size)\n \t      if (regs_ever_live[reg] && ! call_used_regs[reg])\n \t\t{\n \t\t  floats_offset += 12;\n+\t\t  \n \t\t  /* We can't unstack more than four registers at once */\n \t\t  if (start_reg - reg == 3)\n \t\t    {\n-\t\t      fprintf (f, \"\\tlfm\\t%s%s, 4, [%sfp, #-%d]\\n\",\n-\t\t\t       REGISTER_PREFIX, reg_names[reg],\n-\t\t\t       REGISTER_PREFIX, floats_offset);\n+\t\t      asm_fprintf (f, \"\\tlfm\\t%R%s, 4, [%R%s, #-%d]\\n\",\n+\t\t\t           reg_names[reg], reg_names [FP_REGNUM],\n+\t\t\t\t   floats_offset);\n \t\t      start_reg = reg - 1;\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n \t\t  if (reg != start_reg)\n-\t\t    fprintf (f, \"\\tlfm\\t%s%s, %d, [%sfp, #-%d]\\n\",\n-\t\t\t     REGISTER_PREFIX, reg_names[reg + 1],\n-\t\t\t     start_reg - reg, REGISTER_PREFIX, floats_offset);\n-\n+\t\t    asm_fprintf (f, \"\\tlfm\\t%R%s, %d, [%R%s, #-%d]\\n\",\n+\t\t\t\t reg_names [reg + 1], start_reg - reg,\n+\t\t\t\t reg_names [FP_REGNUM], floats_offset);\n \t\t  start_reg = reg - 1;\n \t\t}\n \t    }\n \n \t  /* Just in case the last register checked also needs unstacking.  */\n \t  if (reg != start_reg)\n-\t    fprintf (f, \"\\tlfm\\t%s%s, %d, [%sfp, #-%d]\\n\",\n-\t\t     REGISTER_PREFIX, reg_names[reg + 1],\n-\t\t     start_reg - reg, REGISTER_PREFIX, floats_offset);\n+\t    asm_fprintf (f, \"\\tlfm\\t%R%s, %d, [%R%s, #-%d]\\n\",\n+\t\t\t reg_names [reg + 1], start_reg - reg,\n+\t\t\t reg_names [FP_REGNUM], floats_offset);\n \t}\n       \n-      if (TARGET_THUMB_INTERWORK)\n+      if (TARGET_INTERWORK)\n \t{\n \t  live_regs_mask |= 0x6800;\n \t  print_multi_reg (f, \"ldmea\\t%sfp\", live_regs_mask, FALSE);\n-\t  fprintf (f, \"\\tbx\\t%slr\\n\", REGISTER_PREFIX);\n+\t  asm_fprintf (f, \"\\tbx\\t%R%s\\n\", reg_names [LR_REGNUM]);\n \t}\n       else\n \t{\n@@ -5680,8 +5712,8 @@ output_func_epilogue (f, frame_size)\n \t{\n \t  for (reg = 16; reg < 24; reg++)\n \t    if (regs_ever_live[reg] && ! call_used_regs[reg])\n-\t      fprintf (f, \"\\tldfe\\t%s%s, [%ssp], #12\\n\", REGISTER_PREFIX,\n-\t\t       reg_names[reg], REGISTER_PREFIX);\n+\t      asm_fprintf (f, \"\\tldfe\\t%R%s, [%R%s], #12\\n\",\n+\t\t\t   reg_names[reg], reg_names [SP_REGNUM]);\n \t}\n       else\n \t{\n@@ -5693,46 +5725,45 @@ output_func_epilogue (f, frame_size)\n \t\t{\n \t\t  if (reg - start_reg == 3)\n \t\t    {\n-\t\t      fprintf (f, \"\\tlfmfd\\t%s%s, 4, [%ssp]!\\n\",\n-\t\t\t       REGISTER_PREFIX, reg_names[start_reg],\n-\t\t\t       REGISTER_PREFIX);\n+\t\t      asm_fprintf (f, \"\\tlfmfd\\t%R%s, 4, [%R%s]!\\n\",\n+\t\t\t\t   reg_names[start_reg], reg_names [SP_REGNUM]);\n \t\t      start_reg = reg + 1;\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n \t\t  if (reg != start_reg)\n-\t\t    fprintf (f, \"\\tlfmfd\\t%s%s, %d, [%ssp]!\\n\",\n-\t\t\t     REGISTER_PREFIX, reg_names[start_reg],\n-\t\t\t     reg - start_reg, REGISTER_PREFIX);\n-\n+\t\t    asm_fprintf (f, \"\\tlfmfd\\t%R%s, %d, [%R%s]!\\n\",\n+\t\t\t\t reg_names [start_reg], reg - start_reg,\n+\t\t\t\t reg_names [SP_REGNUM]);\n+\t\t  \n \t\t  start_reg = reg + 1;\n \t\t}\n \t    }\n \n \t  /* Just in case the last register checked also needs unstacking.  */\n \t  if (reg != start_reg)\n-\t    fprintf (f, \"\\tlfmfd\\t%s%s, %d, [%ssp]!\\n\",\n-\t\t     REGISTER_PREFIX, reg_names[start_reg],\n-\t\t     reg - start_reg, REGISTER_PREFIX);\n+\t    asm_fprintf (f, \"\\tlfmfd\\t%R%s, %d, [%R%s]!\\n\",\n+\t\t\t reg_names [start_reg], reg - start_reg,\n+\t\t\t reg_names [SP_REGNUM]);\n \t}\n \n       if (current_function_pretend_args_size == 0 && regs_ever_live[LR_REGNUM])\n \t{\n-\t  if (TARGET_THUMB_INTERWORK)\n+\t  if (TARGET_INTERWORK)\n \t    {\n \t      if (! lr_save_eliminated)\n \t\tlive_regs_mask |= 1 << LR_REGNUM;\n \n \t      if (live_regs_mask != 0)\n \t\tprint_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask, FALSE);\n-\n-\t      fprintf (f, \"\\tbx\\t%slr\\n\", REGISTER_PREFIX);\n+\t      \n+\t      asm_fprintf (f, \"\\tbx\\t%R%s\\n\", reg_names [LR_REGNUM]);\n \t    }\n \t  else if (lr_save_eliminated)\n-\t    fprintf (f, (TARGET_APCS_32 ? \"\\tmov\\t%spc, %slr\\n\"\n-\t\t\t : \"\\tmovs\\t%spc, %slr\\n\"),\n-\t\t     REGISTER_PREFIX, REGISTER_PREFIX, f);\n+\t    asm_fprintf (f, \"\\tmov%c\\t%r, %r\\n\",\n+\t\t\t TARGET_APCS_32 ? ' ' : 's',\n+\t\t\t reg_names [PC_REGNUM], reg_names [LR_REGNUM]);\n \t  else\n \t    print_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask | 0x8000,\n \t\t\t     TARGET_APCS_32 ? FALSE : TRUE);\n@@ -5757,12 +5788,12 @@ output_func_epilogue (f, frame_size)\n \t      output_add_immediate (operands);\n \t    }\n \t  /* And finally, go home */\n-\t  if (TARGET_THUMB_INTERWORK)\n-\t    fprintf (f, \"\\tbx\\t%slr\\n\", REGISTER_PREFIX);\n+\t  if (TARGET_INTERWORK)\n+\t    asm_fprintf (f, \"\\tbx\\t%R%s\\n\", reg_names [LR_REGNUM]);\n \t  else if (TARGET_APCS_32)\n-\t    fprintf (f, \"\\tmov\\t%spc, %slr\\n\", REGISTER_PREFIX, REGISTER_PREFIX );\n+\t    asm_fprintf (f, \"\\tmov\\t%R%s, %R%s\\n\",  reg_names [PC_REGNUM], reg_names [LR_REGNUM]);\n \t  else\n-\t    fprintf (f, \"\\tmovs\\t%spc, %slr\\n\", REGISTER_PREFIX, REGISTER_PREFIX );\n+\t    asm_fprintf (f, \"\\tmovs\\t%R%s, %R%s\\n\", reg_names [PC_REGNUM], reg_names [LR_REGNUM]);\n \t}\n     }\n \n@@ -6071,11 +6102,9 @@ arm_print_operand (stream, x, code)\n       return;\n \n     case 'M':\n-      fprintf (stream, \"{%s%s-%s%s}\", REGISTER_PREFIX, reg_names[REGNO (x)],\n-\t       REGISTER_PREFIX, reg_names[REGNO (x) - 1\n-\t\t\t\t\t + ((GET_MODE_SIZE (GET_MODE (x))\n-\t\t\t\t\t     + GET_MODE_SIZE (SImode) - 1)\n-\t\t\t\t\t    / GET_MODE_SIZE (SImode))]);\n+      asm_fprintf (stream, \"{%R%s-%R%s}\",\n+\t\t   reg_names[REGNO (x)],\n+\t\t   reg_names[REGNO (x) + NUM_INTS (GET_MODE (x)) - 1]);\n       return;\n \n     case 'd':\n@@ -6116,7 +6145,6 @@ arm_print_operand (stream, x, code)\n \t}\n     }\n }\n-\n \f\n /* A finite state machine takes care of noticing whether or not instructions\n    can be conditionally executed, and thus decrease execution time and code\n@@ -6643,9 +6671,9 @@ aof_dump_pic_table (f)\n   if (aof_pic_chain == NULL)\n     return;\n \n-  fprintf (f, \"\\tAREA |%s$$adcons|, BASED %s%s\\n\",\n-\t   reg_names[PIC_OFFSET_TABLE_REGNUM], REGISTER_PREFIX,\n-\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+  asm_fprintf (f, \"\\tAREA |%R%s$$adcons|, BASED %R%s\\n\",\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM],\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM]);\n   fputs (\"|x$adcons|\\n\", f);\n   \n   for (chain = aof_pic_chain; chain; chain = chain->next)"}, {"sha": "6cabbb45844eeef5c8fe712d2c85f4c1c21c673c", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 195, "deletions": 167, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=6cfc7210fa88997c7b22415241c1b325b25bcb7b", "patch": "@@ -3,7 +3,8 @@\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    and Martin Simmons (@harleqn.co.uk).\n    More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n-   \n+   Minor hacks by Nick Clifton (nickc@cygnus.com)\n+\n This file is part of GNU CC.\n \n GNU CC is free software; you can redistribute it and/or modify\n@@ -64,13 +65,22 @@ enum arm_cond_code\n   ARM_EQ = 0, ARM_NE, ARM_CS, ARM_CC, ARM_MI, ARM_PL, ARM_VS, ARM_VC,\n   ARM_HI, ARM_LS, ARM_GE, ARM_LT, ARM_GT, ARM_LE, ARM_AL, ARM_NV\n };\n+\n extern enum arm_cond_code arm_current_cc;\n extern char * arm_condition_codes[];\n \n #define ARM_INVERSE_CONDITION_CODE(X)  ((enum arm_cond_code) (((int)X) ^ 1))\n \n+extern int arm_target_label;\n+extern int arm_ccfsm_state;\n+extern struct rtx_def * arm_target_insn;\n+extern int lr_save_eliminated;\n /* This is needed by the tail-calling peepholes */\n extern int frame_pointer_needed;\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+extern int target_flags;\n+/* The floating point instruction architecture, can be 2 or 3 */\n+extern const char * target_fp_name;\n \n \f\n /* Just in case configure has failed to define anything. */\n@@ -206,11 +216,11 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #define CPP_FLOAT_DEFAULT_SPEC \"\"\n \n #define CPP_ENDIAN_SPEC \"\\\n-%{mbig-endian: \\\n-  %{mlittle-endian: \\\n-    %e-mbig-endian and -mlittle-endian may not be used together} \\\n-  -D__ARMEB__ %{mwords-little-endian:-D__ARMWEL__}} \\\n-%{!mlittle-endian:%{!mbig-endian:%(cpp_endian_default)}} \\\n+%{mbig-endian:\t\t\t\t\t\t\t\t\\\n+  %{mlittle-endian:\t\t\t\t\t\t\t\\\n+    %e-mbig-endian and -mlittle-endian may not be used together}\t\\\n+  -D__ARMEB__ %{mwords-little-endian:-D__ARMWEL__}}\t\t\t\\\n+%{!mlittle-endian:%{!mbig-endian:%(cpp_endian_default)}}\t\t\\\n \"\n \n /* Default is little endian, which doesn't define anything. */\n@@ -240,79 +250,74 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n   SUBTARGET_EXTRA_SPECS\n \n #define SUBTARGET_EXTRA_SPECS\n+#ifndef SUBTARGET_CPP_SPEC\n #define SUBTARGET_CPP_SPEC      \"\"\n+#endif\n \n \f\n /* Run-time Target Specification.  */\n #ifndef TARGET_VERSION\n-#define TARGET_VERSION  \\\n-  fputs (\" (ARM/generic)\", stderr);\n+#define TARGET_VERSION fputs (\" (ARM/generic)\", stderr);\n #endif\n \n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-extern int target_flags;\n-\n-/* The floating point instruction architecture, can be 2 or 3 */\n-extern const char * target_fp_name;\n-\n /* Nonzero if the function prologue (and epilogue) should obey\n    the ARM Procedure Call Standard.  */\n-#define ARM_FLAG_APCS_FRAME\t(0x0001)\n+#define ARM_FLAG_APCS_FRAME\t(1 << 0)\n \n /* Nonzero if the function prologue should output the function name to enable\n    the post mortem debugger to print a backtrace (very useful on RISCOS,\n    unused on RISCiX).  Specifying this flag also enables\n    -fno-omit-frame-pointer.\n    XXX Must still be implemented in the prologue.  */\n-#define ARM_FLAG_POKE         (0x0002)\n+#define ARM_FLAG_POKE\t\t(1 << 1)\n \n /* Nonzero if floating point instructions are emulated by the FPE, in which\n    case instruction scheduling becomes very uninteresting.  */\n-#define ARM_FLAG_FPE          (0x0004)\n+#define ARM_FLAG_FPE\t\t(1 << 2)\n \n /* Nonzero if destined for a processor in 32-bit program mode.  Takes out bit\n    that assume restoration of the condition flags when returning from a\n    branch and link (ie a function).  */\n-#define ARM_FLAG_APCS_32      (0x0020)\n+#define ARM_FLAG_APCS_32\t(1 << 3)\n \n /* FLAGS 0x0008 and 0x0010 are now spare (used to be arm3/6 selection).  */\n \n /* Nonzero if stack checking should be performed on entry to each function\n    which allocates temporary variables on the stack.  */\n-#define ARM_FLAG_APCS_STACK   (0x0040)\n+#define ARM_FLAG_APCS_STACK\t(1 << 4)\n \n /* Nonzero if floating point parameters should be passed to functions in\n    floating point registers.  */\n-#define ARM_FLAG_APCS_FLOAT   (0x0080)\n+#define ARM_FLAG_APCS_FLOAT\t(1 << 5)\n \n /* Nonzero if re-entrant, position independent code should be generated.\n    This is equivalent to -fpic.  */\n-#define ARM_FLAG_APCS_REENT   (0x0100)\n+#define ARM_FLAG_APCS_REENT\t(1 << 6)\n \n /* Nonzero if the MMU will trap unaligned word accesses, so shorts must be\n    loaded byte-at-a-time.  */\n-#define ARM_FLAG_SHORT_BYTE   (0x0200)\n+#define ARM_FLAG_SHORT_BYTE\t(1 << 7)\n \n /* Nonzero if all floating point instructions are missing (and there is no\n    emulator either).  Generate function calls for all ops in this case.  */\n-#define ARM_FLAG_SOFT_FLOAT   (0x0400)\n+#define ARM_FLAG_SOFT_FLOAT\t(1 << 8)\n \n /* Nonzero if we should compile with BYTES_BIG_ENDIAN set to 1.  */\n-#define ARM_FLAG_BIG_END      (0x0800)\n+#define ARM_FLAG_BIG_END\t(1 << 9)\n \n /* Nonzero if we should compile for Thumb interworking.  */\n-#define ARM_FLAG_THUMB          (0x1000)\n+#define ARM_FLAG_INTERWORK\t(1 << 10)\n \n /* Nonzero if we should have little-endian words even when compiling for\n    big-endian (for backwards compatibility with older versions of GCC).  */\n-#define ARM_FLAG_LITTLE_WORDS\t(0x2000)\n+#define ARM_FLAG_LITTLE_WORDS\t(1 << 11)\n \n /* Nonzero if we need to protect the prolog from scheduling */\n-#define ARM_FLAG_NO_SCHED_PRO\t(0x4000)\n+#define ARM_FLAG_NO_SCHED_PRO\t(1 << 12)\n \n /* Nonzero if a call to abort should be generated if a noreturn \n function tries to return. */\n-#define ARM_FLAG_ABORT_NORETURN (0x8000)\n+#define ARM_FLAG_ABORT_NORETURN\t(1 << 13)\n \n #define TARGET_APCS\t\t\t(target_flags & ARM_FLAG_APCS_FRAME)\n #define TARGET_POKE_FUNCTION_NAME\t(target_flags & ARM_FLAG_POKE)\n@@ -332,7 +337,7 @@ function tries to return. */\n #define TARGET_SOFT_FLOAT\t\t(target_flags & ARM_FLAG_SOFT_FLOAT)\n #define TARGET_HARD_FLOAT\t\t(! TARGET_SOFT_FLOAT)\n #define TARGET_BIG_END\t\t\t(target_flags & ARM_FLAG_BIG_END)\n-#define TARGET_THUMB_INTERWORK\t\t(target_flags & ARM_FLAG_THUMB)\n+#define TARGET_INTERWORK\t\t(target_flags & ARM_FLAG_INTERWORK)\n #define TARGET_LITTLE_WORDS\t\t(target_flags & ARM_FLAG_LITTLE_WORDS)\n #define TARGET_NO_SCHED_PRO\t\t(target_flags & ARM_FLAG_NO_SCHED_PRO)\n #define TARGET_ABORT_NORETURN           (target_flags & ARM_FLAG_ABORT_NORETURN)\n@@ -343,55 +348,55 @@ function tries to return. */\n #define SUBTARGET_SWITCHES\n #endif\n \n-#define TARGET_SWITCHES  \t\t\t\t\\\n-{                         \t\t\t\t\\\n-  {\"apcs\",\t\t\tARM_FLAG_APCS_FRAME, \"\" }, \\\n-  {\"apcs-frame\",\t\tARM_FLAG_APCS_FRAME, \t\\\n-     \"Generate APCS conformant stack frames\" },\t\t\\\n-  {\"no-apcs-frame\",\t       -ARM_FLAG_APCS_FRAME, \"\" }, \\\n-  {\"poke-function-name\",\tARM_FLAG_POKE, \t\t\\\n-     \"Store function names in object code\" },\t\t\\\n-  {\"no-poke-function-name\",    -ARM_FLAG_POKE, \"\" },\t\\\n-  {\"fpe\",\t\t\tARM_FLAG_FPE,  \"\" },\t\\\n-  {\"apcs-32\",\t\t\tARM_FLAG_APCS_32, \t\\\n-     \"Use the 32bit version of the APCS\" },\t\t\\\n-  {\"apcs-26\",\t\t       -ARM_FLAG_APCS_32, \t\\\n-     \"Use the 26bit version of the APCS\" },\t\t\\\n-  {\"apcs-stack-check\",\t\tARM_FLAG_APCS_STACK, \"\" }, \\\n-  {\"no-apcs-stack-check\",      -ARM_FLAG_APCS_STACK, \"\" }, \\\n-  {\"apcs-float\",\t\tARM_FLAG_APCS_FLOAT, \t\\\n-     \"Pass FP arguments in FP registers\" },\t\t\\\n-  {\"no-apcs-float\",\t       -ARM_FLAG_APCS_FLOAT, \"\" }, \\\n-  {\"apcs-reentrant\",\t\tARM_FLAG_APCS_REENT, \t\\\n-     \"Generate re-entrant, PIC code\" },\t\t\t\\\n-  {\"no-apcs-reentrant\",\t       -ARM_FLAG_APCS_REENT, \"\" }, \\\n-  {\"short-load-bytes\",\t\tARM_FLAG_SHORT_BYTE, \t\\\n-     \"Load shorts a byte at a time\" },\t\t\t\\\n-  {\"no-short-load-bytes\",      -ARM_FLAG_SHORT_BYTE, \"\" }, \\\n-  {\"short-load-words\",\t       -ARM_FLAG_SHORT_BYTE, \t\\\n-     \"Load words a byte at a time\" },\t\t\t\\\n-  {\"no-short-load-words\",\tARM_FLAG_SHORT_BYTE, \"\" }, \\\n-  {\"soft-float\",\t\tARM_FLAG_SOFT_FLOAT, \t\\\n-     \"Use library calls to perform FP operations\" },\t\\\n-  {\"hard-float\",\t       -ARM_FLAG_SOFT_FLOAT, \t\\\n-     \"Use hardware floating point instructions\" },\t\\\n-  {\"big-endian\",\t\tARM_FLAG_BIG_END, \t\\\n-     \"Assume target CPU is configured as big endian\" },\t\\\n-  {\"little-endian\",\t       -ARM_FLAG_BIG_END, \t\\\n-     \"Assume target CPU is configured as little endian\" }, \\\n-  {\"words-little-endian\",       ARM_FLAG_LITTLE_WORDS, \t\\\n-     \"Assume big endian bytes, little endian words\" },\t\\\n-  {\"thumb-interwork\",\t\tARM_FLAG_THUMB, \t\\\n+#define TARGET_SWITCHES\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  {\"apcs\",\t\t\tARM_FLAG_APCS_FRAME, \"\" },\t\\\n+  {\"apcs-frame\",\t\tARM_FLAG_APCS_FRAME,\t\t\\\n+     \"Generate APCS conformant stack frames\" },\t\t\t\\\n+  {\"no-apcs-frame\",\t       -ARM_FLAG_APCS_FRAME, \"\" },\t\\\n+  {\"poke-function-name\",\tARM_FLAG_POKE,\t\t\t\\\n+     \"Store function names in object code\" },\t\t\t\\\n+  {\"no-poke-function-name\",    -ARM_FLAG_POKE, \"\" },\t\t\\\n+  {\"fpe\",\t\t\tARM_FLAG_FPE,  \"\" },\t\t\\\n+  {\"apcs-32\",\t\t\tARM_FLAG_APCS_32,\t\t\\\n+     \"Use the 32bit version of the APCS\" },\t\t\t\\\n+  {\"apcs-26\",\t\t       -ARM_FLAG_APCS_32,\t\t\\\n+     \"Use the 26bit version of the APCS\" },\t\t\t\\\n+  {\"apcs-stack-check\",\t\tARM_FLAG_APCS_STACK, \"\" },\t\\\n+  {\"no-apcs-stack-check\",      -ARM_FLAG_APCS_STACK, \"\" },\t\\\n+  {\"apcs-float\",\t\tARM_FLAG_APCS_FLOAT,\t\t\\\n+     \"Pass FP arguments in FP registers\" },\t\t\t\\\n+  {\"no-apcs-float\",\t       -ARM_FLAG_APCS_FLOAT, \"\" },\t\\\n+  {\"apcs-reentrant\",\t\tARM_FLAG_APCS_REENT,\t\t\\\n+     \"Generate re-entrant, PIC code\" },\t\t\t\t\\\n+  {\"no-apcs-reentrant\",\t       -ARM_FLAG_APCS_REENT, \"\" },\t\\\n+  {\"short-load-bytes\",\t\tARM_FLAG_SHORT_BYTE,\t\t\\\n+     \"Load shorts a byte at a time\" },\t\t\t\t\\\n+  {\"no-short-load-bytes\",      -ARM_FLAG_SHORT_BYTE, \"\" },\t\\\n+  {\"short-load-words\",\t       -ARM_FLAG_SHORT_BYTE,\t\t\\\n+     \"Load words a byte at a time\" },\t\t\t\t\\\n+  {\"no-short-load-words\",\tARM_FLAG_SHORT_BYTE, \"\" },\t\\\n+  {\"soft-float\",\t\tARM_FLAG_SOFT_FLOAT,\t\t\\\n+     \"Use library calls to perform FP operations\" },\t\t\\\n+  {\"hard-float\",\t       -ARM_FLAG_SOFT_FLOAT,\t\t\\\n+     \"Use hardware floating point instructions\" },\t\t\\\n+  {\"big-endian\",\t\tARM_FLAG_BIG_END,\t\t\\\n+     \"Assume target CPU is configured as big endian\" },\t\t\\\n+  {\"little-endian\",\t       -ARM_FLAG_BIG_END,\t\t\\\n+     \"Assume target CPU is configured as little endian\" },\t\\\n+  {\"words-little-endian\",       ARM_FLAG_LITTLE_WORDS,\t\t\\\n+     \"Assume big endian bytes, little endian words\" },\t\t\\\n+  {\"thumb-interwork\",\t\tARM_FLAG_INTERWORK,\t\t\\\n      \"Support calls between THUMB and ARM instructions sets\" },\t\\\n-  {\"no-thumb-interwork\",       -ARM_FLAG_THUMB, \"\" },\t\\\n-  {\"abort-on-noreturn\",         ARM_FLAG_ABORT_NORETURN,     \\\n-   \"Generate a call to abort if a noreturn function returns\"}, \\\n-  {\"no-abort-on-noreturn\",      -ARM_FLAG_ABORT_NORETURN, \"\"}, \\\n-  {\"sched-prolog\",             -ARM_FLAG_NO_SCHED_PRO, \t\\\n-     \"Do not move instructions into a function's prologue\" }, \\\n-  {\"no-sched-prolog\",           ARM_FLAG_NO_SCHED_PRO, \"\" }, \\\n-  SUBTARGET_SWITCHES\t\t\t\t\t\\\n-  {\"\",\t\t\t\tTARGET_DEFAULT }\t\\\n+  {\"no-thumb-interwork\",       -ARM_FLAG_INTERWORK, \"\" },\t\\\n+  {\"abort-on-noreturn\",         ARM_FLAG_ABORT_NORETURN,\t\\\n+   \"Generate a call to abort if a noreturn function returns\"},\t\\\n+  {\"no-abort-on-noreturn\",      -ARM_FLAG_ABORT_NORETURN, \"\"},\t\\\n+  {\"sched-prolog\",             -ARM_FLAG_NO_SCHED_PRO,\t\t\\\n+     \"Do not move instructions into a function's prologue\" },\t\\\n+  {\"no-sched-prolog\",           ARM_FLAG_NO_SCHED_PRO, \"\" },\t\\\n+  SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n+  {\"\",\t\t\t\tTARGET_DEFAULT }\t\t\\\n }\n \n #define TARGET_OPTIONS\t\t\t\t\t\t\\\n@@ -518,7 +523,7 @@ extern int arm_is_6_or_7;\n \n /* It is far faster to zero extend chars than to sign extend them */\n \n-#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \\\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n   if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n       && GET_MODE_SIZE (MODE) < 4)      \t\\\n     {\t\t\t\t\t\t\\\n@@ -743,17 +748,38 @@ extern const char * structure_size_string;\n   SUBTARGET_CONDITIONAL_REGISTER_USAGE \t\t        \\\n }\n \n+/* Convert fron bytes to ints.  */\n+#define NUM_INTS(X) (((X) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* The number of (integer) registers required to hold a quantity of type MODE.  */\n+#define NUM_REGS(MODE)\t\t\t\t\\\n+  NUM_INTS (GET_MODE_SIZE (MODE))\n+\n+/* The number of (integer) registers required to hold a quantity of TYPE MODE.  */\n+#define NUM_REGS2(MODE, TYPE)                   \\\n+  NUM_INTS ((MODE) == BLKmode ? int_size_in_bytes (TYPE) : GET_MODE_SIZE (MODE))\n+\n+/* The number of (integer) argument register available.  */\n+#define NUM_ARG_REGS   4\n+\n+/* Return the regiser number of the N'th (integer) argument.  */\n+#define ARG_REGISTER(N) (N - 1)\n+\n+/* The number of the last argument register.  */\n+#define LAST_ARG_REGNUM ARG_REGISTER (NUM_ARG_REGS)\n+\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n    On the ARM regs are UNITS_PER_WORD bits wide; FPU regs can hold any FP\n    mode.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)  \t\t\t\t\t\\\n-    (((REGNO) >= 16 && REGNO != FRAME_POINTER_REGNUM\t\t\t\\\n-      && (REGNO) != ARG_POINTER_REGNUM) ? 1\t\t\t\t\\\n-     : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+#define HARD_REGNO_NREGS(REGNO, MODE)  \t\\\n+  ((   REGNO >= 16\t\t\t\\\n+    && REGNO != FRAME_POINTER_REGNUM\t\\\n+    && REGNO != ARG_POINTER_REGNUM)\t\\\n+   ? 1 : NUM_REGS (MODE))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    This is TRUE for ARM regs since they can hold anything, and TRUE for FPU\n@@ -779,6 +805,7 @@ extern const char * structure_size_string;\n \n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM\t13\n+#define SP_REGNUM\t        STACK_POINTER_REGNUM\n \n /* Base register for access to local variables of the function.  */\n #define FRAME_POINTER_REGNUM\t25\n@@ -788,6 +815,7 @@ extern const char * structure_size_string;\n    until after register allocation has taken place.  FRAME_POINTER_REGNUM\n    should point to a special register that we will make sure is eliminated. */\n #define HARD_FRAME_POINTER_REGNUM 11\n+#define FP_REGNUM\t\tHARD_FRAME_POINTER_REGNUM\n \n /* Register which holds return address from a subroutine call.  */\n #define LR_REGNUM\t\t14\n@@ -1006,8 +1034,7 @@ enum reg_class\n    needed to represent mode MODE in a register of class CLASS.\n    ARM regs are UNITS_PER_WORD bits while FPU regs can hold any FP mode */\n #define CLASS_MAX_NREGS(CLASS, MODE)  \\\n-    ((CLASS) == FPU_REGS ? 1\t\t\t\t\t       \\\n-     : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+  ((CLASS) == FPU_REGS ? 1 : NUM_REGS (MODE))\n \n /* Moves between FPU_REGS and GENERAL_REGS are two memory insns.  */\n #define REGISTER_MOVE_COST(CLASS1, CLASS2)  \\\n@@ -1041,7 +1068,7 @@ enum reg_class\n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n    found in the variable current_function_outgoing_args_size.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Offset of first parameter from the argument pointer register value.  */\n #define FIRST_PARM_OFFSET(FNDECL)  4\n@@ -1055,16 +1082,7 @@ enum reg_class\n \n    On the ARM, the caller does not pop any of its arguments that were passed\n    on the stack.  */\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)  0\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  (GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT && TARGET_HARD_FLOAT \\\n-   ? gen_rtx_REG (TYPE_MODE (VALTYPE), 16) \\\n-   : gen_rtx_REG (TYPE_MODE (VALTYPE), 0))\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, SIZE)  0\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n@@ -1073,6 +1091,13 @@ enum reg_class\n    ? gen_rtx_REG (MODE, 16) \\\n    : gen_rtx_REG (MODE, 0))\n \n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n+\n /* 1 if N is a possible register number for a function value.\n    On the ARM, only r0 and f0 can return results.  */\n #define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n@@ -1106,19 +1131,18 @@ enum reg_class\n    only in assign_parms, since SETUP_INCOMING_VARARGS is defined), say it is\n    passed in the stack (function_prologue will indeed make it pass in the\n    stack if necessary).  */\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)  \\\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\\\n   ((NAMED)\t\t\t\t\t\t\\\n-   ? ((CUM) >= 16 ? 0 : gen_rtx_REG (MODE, (CUM) / 4))\t\\\n+   ? ((CUM) >= NUM_ARG_REGS ? 0 : gen_rtx_REG (MODE, CUM))\\\n    : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)  \\\n-  ((CUM) < 16 && 16 < (CUM) + ((MODE) != BLKmode            \\\n-\t\t\t       ? GET_MODE_SIZE (MODE)       \\\n-\t\t\t       : int_size_in_bytes (TYPE))  \\\n-   ? 4 - (CUM) / 4 : 0)\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n+  (    NUM_ARG_REGS > (CUM)\t\t\t\t\t\\\n+   && (NUM_ARG_REGS < ((CUM) + NUM_REGS2 (MODE, TYPE)))\t\t\\\n+   ?   NUM_ARG_REGS - (CUM) : 0)\n \n /* A C type for declaring a variable that is used as the first argument of\n    `FUNCTION_ARG' and other related values.  For some target machines, the\n@@ -1132,15 +1156,13 @@ enum reg_class\n    For a library call, FNTYPE is 0.\n    On the ARM, the offset starts at 0.  */\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)  \\\n-  ((CUM) = (((FNTYPE) && aggregate_value_p (TREE_TYPE ((FNTYPE)))) ? 4 : 0))\n+  ((CUM) = (((FNTYPE) && aggregate_value_p (TREE_TYPE ((FNTYPE)))) ? 1 : 0))\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)  \\\n-  (CUM) += ((MODE) != BLKmode                       \\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3       \\\n-\t    : (int_size_in_bytes (TYPE) + 3) & ~3)  \\\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+  (CUM) += NUM_REGS2 (MODE, TYPE)\n \n /* 1 if N is a possible register number for function argument passing.\n    On the ARM, r0-r3 are used to pass args.  */\n@@ -1160,12 +1182,12 @@ enum reg_class\n    named arg and all anonymous args onto the stack.\n    XXX I know the prologue shouldn't be pushing registers, but it is faster\n    that way.  */\n-#define SETUP_INCOMING_VARARGS(CUM, MODE, TYPE, PRETEND_SIZE, NO_RTL)  \\\n+#define SETUP_INCOMING_VARARGS(CUM, MODE, TYPE, PRETEND_SIZE, NO_RTL)\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   extern int current_function_anonymous_args;\t\t\t\t\\\n   current_function_anonymous_args = 1;\t\t\t\t\t\\\n-  if ((CUM) < 16)\t\t\t\t\t\t\t\\\n-    (PRETEND_SIZE) = 16 - (CUM);\t\t\t\t\t\\\n+  if ((CUM) < NUM_ARG_REGS)\t\t\t\t\t\t\\\n+    (PRETEND_SIZE) = (NUM_ARG_REGS - (CUM)) * UNITS_PER_WORD;\t\t\\\n }\n \n /* Generate assembly output for the start of a function.  */\n@@ -1195,19 +1217,19 @@ enum reg_class\n \n    The ``mov ip,lr'' seems like a good idea to stick with cc convention.\n    ``prof'' doesn't seem to mind about this!  */\n-#define FUNCTION_PROFILER(STREAM,LABELNO)  \t\t\t\t    \\\n-{\t\t\t\t\t\t\t\t\t    \\\n-  char temp[20];\t\t\t\t\t\t\t    \\\n-  rtx sym;\t\t\t\t\t\t\t\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-  fprintf ((STREAM), \"\\tmov\\t%s%s, %s%s\\n\\tbl\\t\",\t\t\t    \\\n-\t   REGISTER_PREFIX, reg_names[IP_REGNUM] /* ip */,\t\t    \\\n-\t   REGISTER_PREFIX, reg_names[LR_REGNUM] /* lr */);\t\t    \\\n-  assemble_name ((STREAM), ARM_MCOUNT_NAME);\t\t\t\t    \\\n-  fputc ('\\n', (STREAM));\t\t\t\t\t\t    \\\n-  ASM_GENERATE_INTERNAL_LABEL (temp, \"LP\", (LABELNO));\t\t\t    \\\n-  sym = gen_rtx (SYMBOL_REF, Pmode, temp);\t\t\t\t    \\\n-  ASM_OUTPUT_INT ((STREAM), sym);\t\t\t\t\t    \\\n+#define FUNCTION_PROFILER(STREAM, LABELNO)  \t\t\\\n+{\t\t\t\t\t\t\t\\\n+  char temp[20];\t\t\t\t\t\\\n+  rtx sym;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  asm_fprintf (STREAM, \"\\tmov\\t%R%s, %R%s\\n\\tbl\\t\",\t\\\n+\t       reg_names[IP_REGNUM] /* ip */,\t\t\\\n+\t       reg_names[LR_REGNUM] /* lr */);\t\t\\\n+  assemble_name (STREAM, ARM_MCOUNT_NAME);\t\t\\\n+  fputc ('\\n', STREAM);\t\t\t\t\t\\\n+  ASM_GENERATE_INTERNAL_LABEL (temp, \"LP\", LABELNO);\t\\\n+  sym = gen_rtx (SYMBOL_REF, Pmode, temp);\t\t\\\n+  ASM_OUTPUT_INT (STREAM, sym);\t\t\t\t\\\n }\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n@@ -1221,7 +1243,7 @@ enum reg_class\n \n /* Generate the assembly code for function exit. */\n #define FUNCTION_EPILOGUE(STREAM, SIZE)  \\\n-  output_func_epilogue ((STREAM), (SIZE))\n+  output_func_epilogue (STREAM, SIZE)\n \n /* Determine if the epilogue should be output as RTL.\n    You should override this if you define FUNCTION_EXTRA_EPILOGUE.  */\n@@ -1241,10 +1263,10 @@ enum reg_class\n    pointer. */\n \n #define ELIMINABLE_REGS\t\t\t\t\t\\\n-{{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n- {ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\\\n- {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n- {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM      },\t\\\n+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM },\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM      },\t\\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM }}\n \n /* Given FROM and TO register numbers, say whether this elimination is allowed.\n    Frame pointer elimination is automatically handled.\n@@ -1266,7 +1288,7 @@ enum reg_class\n   else if ((FROM) == FRAME_POINTER_REGNUM\t\t\t\t\\\n \t   && (TO) == STACK_POINTER_REGNUM)\t\t\t\t\\\n     (OFFSET) = (current_function_outgoing_args_size\t\t\t\\\n-\t\t+ ((get_frame_size () + 3) & ~3));\t\t\t\\\n+\t\t+ NUM_INTS (get_frame_size ()));\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       int regno;\t\t\t\t\t\t\t\\\n@@ -1295,7 +1317,7 @@ enum reg_class\n \t       && (regs_ever_live[LR_REGNUM] || saved_hard_reg))\t\\\n \t     offset += 4;\t\t\t\t\t\t\\\n \t   offset += current_function_outgoing_args_size;\t\t\\\n-\t   (OFFSET) = ((get_frame_size () + 3) & ~3) + offset;\t\t\\\n+\t   (OFFSET) = NUM_INTS (get_frame_size ()) + offset;\t\t\\\n          }\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n@@ -1343,9 +1365,9 @@ enum reg_class\n /* Addressing modes, and classification of registers for them.  */\n \n #define HAVE_POST_INCREMENT  1\n-#define HAVE_PRE_INCREMENT  1\n+#define HAVE_PRE_INCREMENT   1\n #define HAVE_POST_DECREMENT  1\n-#define HAVE_PRE_DECREMENT  1\n+#define HAVE_PRE_DECREMENT   1\n \n /* Macros to check register numbers against specific register classes.  */\n \n@@ -1780,7 +1802,7 @@ enum reg_class\n    || (X) == arg_pointer_rtx)\n \n #define DEFAULT_RTX_COSTS(X, CODE, OUTER_CODE)\t\t\\\n-   return arm_rtx_costs (X, CODE);\n+  return arm_rtx_costs (X, CODE);\n \n /* Moves to and from memory are quite expensive */\n #define MEMORY_MOVE_COST(MODE,CLASS,IN)  10\n@@ -1804,17 +1826,15 @@ enum reg_class\n \t\t\t   || GET_RTX_CLASS (GET_CODE (XEXP (X, 1))) == 'c') \\\n \t\t\t  ? 1 : 0))\t\t\t\t\t     \\\n \t\t: 4)))))\n-\t \n-   \n \n /* Try to generate sequences that don't involve branches, we can then use\n    conditional instructions */\n #define BRANCH_COST 4\n \n /* A C statement to update the variable COST based on the relationship\n    between INSN that is dependent on DEP through dependence LINK.  */\n-#define ADJUST_COST(INSN,LINK,DEP,COST) \\\n-  (COST) = arm_adjust_cost ((INSN), (LINK), (DEP), (COST))\n+#define ADJUST_COST(INSN, LINK, DEP, COST) \\\n+  (COST) = arm_adjust_cost (INSN, LINK, DEP, COST)\n \f\n /* Position Independent Code.  */\n /* We decide which register to use based on the compilation options and\n@@ -1932,8 +1952,6 @@ extern struct rtx_def * arm_compare_op1;\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       char * s = (char *) alloca (40 + strlen (PREFIX));\t\\\n-      extern int arm_target_label, arm_ccfsm_state;\t\t\\\n-      extern rtx arm_target_insn;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n       if (arm_ccfsm_state == 3 && arm_target_label == (NUM)\t\\\n \t  && !strcmp (PREFIX, \"L\"))\t\t\t\t\\\n@@ -1948,13 +1966,21 @@ extern struct rtx_def * arm_compare_op1;\n #endif\n \n /* Output a push or a pop instruction (only used when profiling).  */\n-#define ASM_OUTPUT_REG_PUSH(STREAM,REGNO) \\\n-  fprintf (STREAM,\"\\tstmfd\\t%ssp!,{%s%s}\\n\", \\\n-\t  REGISTER_PREFIX, REGISTER_PREFIX, reg_names [REGNO])\n+#define ASM_OUTPUT_REG_PUSH(STREAM, REGNO) \\\n+  asm_fprintf (STREAM,\"\\tstmfd\\t%Rsp!,{%R%s}\\n\", \\\n+\t       reg_names [REGNO])\n+\n+#define ASM_OUTPUT_REG_POP(STREAM, REGNO) \\\n+  asm_fprintf (STREAM,\"\\tldmfd\\t%Rsp!,{%R%s}\\n\", \\\n+\t       reg_names [REGNO])\n \n-#define ASM_OUTPUT_REG_POP(STREAM,REGNO) \\\n-  fprintf (STREAM,\"\\tldmfd\\t%ssp!,{%s%s}\\n\", \\\n-\t  REGISTER_PREFIX, REGISTER_PREFIX, reg_names [REGNO])\n+#define ARM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL) \t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (TARGET_POKE_FUNCTION_NAME)\t\t\t\\\n+        arm_poke_function_name (STREAM, NAME);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Target characters.  */\n #define TARGET_BELL\t007\n@@ -1973,6 +1999,7 @@ extern struct rtx_def * arm_compare_op1;\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\\\n   ((CODE) == '?' || (CODE) == '|' || (CODE) == '@')\n+\n /* Output an operand of an instruction.  */\n #define PRINT_OPERAND(STREAM, X, CODE)  \\\n   arm_print_operand (STREAM, X, CODE)\n@@ -1991,8 +2018,7 @@ extern struct rtx_def * arm_compare_op1;\n     int is_minus = GET_CODE (X) == MINUS;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"[%s%s, #0]\", REGISTER_PREFIX,\t\t\t\\\n-\t\t reg_names[REGNO (X)]);\t\t\t\t\t\\\n+      asm_fprintf (STREAM, \"[%R%s, #0]\", reg_names[REGNO (X)]);\t\t\\\n     else if (GET_CODE (X) == PLUS || is_minus)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \trtx base = XEXP (X, 0);\t\t\t\t\t\t\\\n@@ -2013,14 +2039,13 @@ extern struct rtx_def * arm_compare_op1;\n \t    offset = INTVAL (index);\t\t\t\t\t\\\n \t    if (is_minus)\t\t\t\t\t\t\\\n \t      offset = -offset;\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s%s, #%d]\", REGISTER_PREFIX,\t\t\\\n-\t\t     base_reg_name, offset);\t\t\t\t\\\n+\t    asm_fprintf (STREAM, \"[%R%s, #%d]\", base_reg_name, offset);\t\\\n \t    break;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  case REG:\t\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s%s, %s%s%s]\", REGISTER_PREFIX,\t\t\\\n-\t\t     base_reg_name, is_minus ? \"-\" : \"\",\t\t\\\n-\t\t     REGISTER_PREFIX, reg_names[REGNO (index)] );\t\\\n+\t    asm_fprintf (STREAM, \"[%R%s, %s%R%s]\", \t\t\t\\\n+\t\t         base_reg_name, is_minus ? \"-\" : \"\",\t\t\\\n+\t\t         reg_names[REGNO (index)] );\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  case MULT:\t\t\t\t\t\t\t\\\n@@ -2029,9 +2054,9 @@ extern struct rtx_def * arm_compare_op1;\n \t  case ASHIFT:\t\t\t\t\t\t\t\\\n \t  case ROTATERT:\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s%s, %s%s%s\", REGISTER_PREFIX,\t\t\\\n-\t\t     base_reg_name, is_minus ? \"-\" : \"\", REGISTER_PREFIX,\\\n-\t\t     reg_names[REGNO (XEXP (index, 0))]);\t\t\\\n+\t    asm_fprintf (STREAM, \"[%R%s, %s%R%s\", \t\t\t\\\n+\t\t         base_reg_name, is_minus ? \"-\" : \"\", \t\t\\\n+\t\t         reg_names[REGNO (XEXP (index, 0))]);\t\t\\\n \t    arm_print_operand (STREAM, index, 'S');\t\t\t\\\n \t    fputs (\"]\", STREAM);\t\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n@@ -2050,15 +2075,15 @@ extern struct rtx_def * arm_compare_op1;\n \tabort ();\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (GET_CODE (X) == PRE_DEC || GET_CODE (X) == PRE_INC)\t\t\\\n-\tfprintf (STREAM, \"[%s%s, #%s%d]!\", REGISTER_PREFIX,\t\t\\\n-\t\t reg_names[REGNO (XEXP (X, 0))],\t\t\t\\\n-\t\t GET_CODE (X) == PRE_DEC ? \"-\" : \"\",\t\t\t\\\n-\t\t GET_MODE_SIZE (output_memory_reference_mode));\t\t\\\n+\tasm_fprintf (STREAM, \"[%R%s, #%s%d]!\", \t\t\t\t\\\n+\t\t     reg_names[REGNO (XEXP (X, 0))],\t\t\t\\\n+\t\t     GET_CODE (X) == PRE_DEC ? \"-\" : \"\",\t\t\\\n+\t\t     GET_MODE_SIZE (output_memory_reference_mode));\t\\\n       else\t\t\t\t\t\t\t\t\\\n-\tfprintf (STREAM, \"[%s%s], #%s%d\", REGISTER_PREFIX,\t\t\\\n-\t\t reg_names[REGNO (XEXP (X, 0))],\t\t\t\\\n-\t\t GET_CODE (X) == POST_DEC ? \"-\" : \"\",\t\t\t\\\n-\t\t GET_MODE_SIZE (output_memory_reference_mode));\t\t\\\n+\tasm_fprintf (STREAM, \"[%R%s], #%s%d\", \t\t\t\t\\\n+\t\t     reg_names[REGNO (XEXP (X, 0))],\t\t\t\\\n+\t\t     GET_CODE (X) == POST_DEC ? \"-\" : \"\",\t\t\\\n+\t\t     GET_MODE_SIZE (output_memory_reference_mode));\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else output_addr_const (STREAM, X);\t\t\t\t\t\\\n }\n@@ -2106,10 +2131,10 @@ extern struct rtx_def * arm_compare_op1;\n \t    shift += 2;\t\t\t\t\t\t\t\t\\\n           else\t\t\t\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\t\\\n-\t      fprintf (FILE, \"\\t%s\\t%s%s, %s%s, #%d\\n\",\t\t\t\t\\\n-\t\t       mi_op, REGISTER_PREFIX, reg_names[this_regno],\t\t\\\n-\t\t       REGISTER_PREFIX, reg_names[this_regno],\t\t\t\\\n-\t\t       mi_delta & (0xff << shift));\t\t\t\t\\\n+\t      asm_fprintf (FILE, \"\\t%s\\t%R%s, %R%s, #%d\\n\",\t\t\t\\\n+\t\t           mi_op, reg_names[this_regno],\t\t\t\\\n+\t\t           reg_names[this_regno],\t\t\t\t\\\n+\t\t           mi_delta & (0xff << shift));\t\t\t\t\\\n \t      mi_delta &= ~(0xff << shift);\t\t\t\t\t\\\n \t      shift += 8;\t\t\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\t\t\\\n@@ -2168,18 +2193,21 @@ struct rtx_def;\n #ifndef HOST_WIDE_INT\n #include \"hwint.h\"\n #endif\n+\n #define Hint HOST_WIDE_INT\n \n #ifndef HAVE_MACHINE_MODES\n #include \"machmode.h\"\n #endif\n+\n #define Mmode enum machine_mode\n \n #ifdef RTX_CODE\n #define RTX_CODE_PROTO(ARGS) PROTO (ARGS)\n #else\n #define RTX_CODE_PROTO(ARGS) ()\n #endif\n+\n #define Rcode enum rtx_code\n \n void   arm_override_options PROTO ((void));"}, {"sha": "cb4bd9b597c3e7d701d85bf5c35dcb522103f91a", "filename": "gcc/config/arm/coff.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2Fconfig%2Farm%2Fcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2Fconfig%2Farm%2Fcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcoff.h?ref=6cfc7210fa88997c7b22415241c1b325b25bcb7b", "patch": "@@ -79,6 +79,7 @@ extern int arm_structure_size_boundary;\n       extern char * version_string;\t\t\t\t\\\n       fprintf (STREAM, \"%s Generated by gcc %s for ARM/coff\\n\",\t\\\n \t       ASM_COMMENT_START, version_string);\t\t\\\n+      fprintf (STREAM, ASM_APP_OFF);\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n "}, {"sha": "376453552350a7d24e1d17dd756a5cc3f2c513f0", "filename": "gcc/config/arm/elf.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2Fconfig%2Farm%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cfc7210fa88997c7b22415241c1b325b25bcb7b/gcc%2Fconfig%2Farm%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Felf.h?ref=6cfc7210fa88997c7b22415241c1b325b25bcb7b", "patch": "@@ -32,8 +32,8 @@ Boston, MA 02111-1307, USA.  */\n #define USER_LABEL_PREFIX \"\"\n #endif\n \n-#ifndef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Darm -Darm_elf -Acpu(arm) -Amachine(arm) -D__ELF__\"\n+#ifndef SUBTARGET_CPP_SPEC\n+#define SUBTARGET_CPP_SPEC  \"-Darm_elf -D__ELF__\"\n #endif\n \n /* The following macro defines the format used to output the second\n@@ -63,8 +63,7 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      if (TARGET_POKE_FUNCTION_NAME)\t\t\t\\\n-        arm_poke_function_name (FILE, NAME);\t\t\\\n+      ARM_DECLARE_FUNCTION_NAME (FILE, NAME, DECL);     \\\n       fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\\\n       assemble_name (FILE, NAME);\t\t\t\\\n       putc (',', FILE);\t\t\t\t\t\\\n@@ -211,7 +210,8 @@ extern int arm_structure_size_boundary;\n       extern char * version_string;\t\t\t\t\\\n       fprintf (STREAM, \"%s Generated by gcc %s for ARM/elf\\n\",\t\\\n \t       ASM_COMMENT_START, version_string);\t\t\\\n-      output_file_directive ((STREAM), main_input_filename);\t\\\n+      output_file_directive (STREAM, main_input_filename);\t\\\n+      fprintf (STREAM, ASM_APP_OFF);\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n #endif"}]}