{"sha": "89cfc2c663f6fef2ca8e7462ca798d22a2bdfa3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODljZmMyYzY2M2Y2ZmVmMmNhOGU3NDYyY2E3OThkMjJhMmJkZmEzYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-16T11:05:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-16T11:05:47Z"}, "message": "(override_options): Handle VAX format floating-point.\n\n(print_operand, case ',', '-'): New cases.\n(alpha_builtin_saveregs): Handle VMS convention.\n(alpha_sa_{mask,size}, alpha_pv_save_size, alpha_using_fp):\nNew versions for VMS.\n(output_{pro,epi}logue, function_arg): Likewise.\n(direct_return): Never true on VMS.\n(check_float_value): Return 0 for VMS.\n(vmskrunch, alpha_{need,write}_linkage): New function.\n\nFrom-SVN: r13183", "tree": {"sha": "3d53ebf7e9f27938935d9052d516d3aab73148a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d53ebf7e9f27938935d9052d516d3aab73148a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89cfc2c663f6fef2ca8e7462ca798d22a2bdfa3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89cfc2c663f6fef2ca8e7462ca798d22a2bdfa3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89cfc2c663f6fef2ca8e7462ca798d22a2bdfa3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89cfc2c663f6fef2ca8e7462ca798d22a2bdfa3c/comments", "author": null, "committer": null, "parents": [{"sha": "1c3abd61fb123fc7b34467d123084bf115a1f567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c3abd61fb123fc7b34467d123084bf115a1f567", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c3abd61fb123fc7b34467d123084bf115a1f567"}], "stats": {"total": 812, "additions": 785, "deletions": 27}, "files": [{"sha": "9bab904a5c411833c461726617f0c8dcbf9a5677", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 785, "deletions": 27, "changes": 812, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89cfc2c663f6fef2ca8e7462ca798d22a2bdfa3c/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89cfc2c663f6fef2ca8e7462ca798d22a2bdfa3c/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=89cfc2c663f6fef2ca8e7462ca798d22a2bdfa3c", "patch": "@@ -91,6 +91,14 @@ static void alpha_set_memflags_1  PROTO((rtx, int, int, int));\n static rtx alpha_emit_set_const_1 PROTO((rtx, enum machine_mode,\n \t\t\t\t\t HOST_WIDE_INT, int));\n static void add_long_const\tPROTO((FILE *, HOST_WIDE_INT, int, int, int));\n+\n+/* Compute the size of the save area in the stack.  */\n+static void alpha_sa_mask\tPROTO((unsigned long *imaskP,\n+\t\t\t\t       unsigned long *fmaskP));\n+/* Strip type information.  */\n+#define CURRENT_FUNCTION_ARGS_INFO  \\\n+(TARGET_OPEN_VMS ? current_function_args_info & 0xff \\\n+ : current_function_args_info)\n \f\n /* Parse target option strings. */\n \n@@ -176,6 +184,20 @@ override_options ()\n       warning (\"fp software completion requires -mtrap-precision=i\");\n       alpha_tp = ALPHA_TP_INSN;\n     }\n+\n+  if (TARGET_FLOAT_VAX)\n+    {\n+      if (alpha_fprm == ALPHA_FPRM_MINF || alpha_fprm == ALPHA_FPRM_DYN)\n+\t{\n+\t  warning (\"rounding mode not supported for VAX floats\");\n+\t  alpha_fprm = ALPHA_FPRM_NORM;\n+\t}\n+      if (alpha_fptm == ALPHA_FPTM_SUI)\n+\t{\n+\t  warning (\"trap mode not supported for VAX floats\");\n+\t  alpha_fptm = ALPHA_FPTM_SU;\n+\t}\n+    }\n }\n \f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n@@ -485,7 +507,7 @@ call_operand (op, mode)\n     return 0;\n \n   return (GET_CODE (op) == SYMBOL_REF\n-\t  || (GET_CODE (op) == REG && REGNO (op) == 27));\n+\t  || (GET_CODE (op) == REG && (TARGET_OPEN_VMS || REGNO (op) == 27)));\n }\n \n /* Return 1 if OP is a valid Alpha comparison operator.  Here we know which\n@@ -1281,6 +1303,16 @@ print_operand (file, x, code)\n \t}\n       break;\n \n+    case ',':\n+      /* Generates single precision instruction suffix.  */\n+      fprintf (file, \"%c\", (TARGET_FLOAT_VAX?'f':'s'));\n+      break;\n+\n+    case '-':\n+      /* Generates double precision instruction suffix.  */\n+      fprintf (file, \"%c\", (TARGET_FLOAT_VAX?'g':'t'));\n+      break;\n+\n     case 'r':\n       /* If this operand is the constant zero, write it as \"$31\".  */\n       if (GET_CODE (x) == REG)\n@@ -1506,9 +1538,9 @@ alpha_builtin_saveregs (arglist)\n      both registers and memory.  Both of these are already included in\n      current_function_args_info.  */\n \n-  argsize = GEN_INT (current_function_args_info * UNITS_PER_WORD);\n+  argsize = GEN_INT (CURRENT_FUNCTION_ARGS_INFO * UNITS_PER_WORD);\n \n-  /* SETUP_INCOMING_VARARGS moves the starting address base up by 48,\n+  /* For Unix, SETUP_INCOMING_VARARGS moves the starting address base up by 48,\n      storing fp arg registers in the first 48 bytes, and the integer arg\n      registers in the next 48 bytes.  This is only done, however, if any\n      integer registers need to be stored.\n@@ -1517,42 +1549,183 @@ alpha_builtin_saveregs (arglist)\n      order to account for the integer arg registers which are counted in\n      argsize above, but which are not actually stored on the stack.  */\n \n-  addr = (current_function_args_info <= 5 + stdarg\n-\t  ? plus_constant (virtual_incoming_args_rtx, 6 * UNITS_PER_WORD)\n-\t  : plus_constant (virtual_incoming_args_rtx, - (6 * UNITS_PER_WORD)));\n-\n-  addr = force_operand (addr, NULL_RTX);\n+  if (TARGET_OPEN_VMS)\n+    addr = plus_constant (virtual_incoming_args_rtx,\n+\t\t\t  CURRENT_FUNCTION_ARGS_INFO <= 5 + stdarg\n+\t\t\t  ? UNITS_PER_WORD : - 6 * UNITS_PER_WORD);\n+  else\n+    addr = (CURRENT_FUNCTION_ARGS_INFO <= 5 + stdarg\n+\t    ? plus_constant (virtual_incoming_args_rtx,\n+\t\t\t     6 * UNITS_PER_WORD)\n+\t    : plus_constant (virtual_incoming_args_rtx,\n+\t\t\t     - (6 * UNITS_PER_WORD)));\n \n-  /* Allocate the va_list constructor */\n-  block = assign_stack_local (BLKmode, 2 * UNITS_PER_WORD, BITS_PER_WORD);\n-  RTX_UNCHANGING_P (block) = 1;\n-  RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n+  /* For VMS, we include the argsize, while on Unix, it's handled as\n+     a separate field.  */\n+  if (TARGET_OPEN_VMS)\n+    addr = plus_constant (addr, INTVAL (argsize));\n \n-  /* Store the address of the first integer register in the __base member.  */\n+  addr = force_operand (addr, NULL_RTX);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n   addr = convert_memory_address (ptr_mode, addr);\n #endif\n \n-  emit_move_insn (change_address (block, ptr_mode, XEXP (block, 0)), addr);\n-\n-  /* Store the argsize as the __va_offset member.  */\n-  emit_move_insn (change_address (block, TYPE_MODE (integer_type_node),\n-\t\t\t\t  plus_constant (XEXP (block, 0),\n-\t\t\t\t\t\t POINTER_SIZE/BITS_PER_UNIT)),\n-\t\t  argsize);\n-\n-  /* Return the address of the va_list constructor, but don't put it in a\n-     register.  Doing so would fail when not optimizing and produce worse\n-     code when optimizing.  */\n-  return XEXP (block, 0);\n+  if (TARGET_OPEN_VMS)\n+    return addr;\n+  else\n+    {\n+      /* Allocate the va_list constructor */\n+      block = assign_stack_local (BLKmode, 2 * UNITS_PER_WORD, BITS_PER_WORD);\n+      RTX_UNCHANGING_P (block) = 1;\n+      RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n+\n+      /* Store the address of the first integer register in the __base\n+\t member.  */\n+\n+      emit_move_insn (change_address (block, ptr_mode, XEXP (block, 0)), addr);\n+\n+      /* Store the argsize as the __va_offset member.  */\n+      emit_move_insn\n+\t(change_address (block, TYPE_MODE (integer_type_node),\n+\t\t\t plus_constant (XEXP (block, 0),\n+\t\t\t\t\tPOINTER_SIZE/BITS_PER_UNIT)),\n+\t argsize);\n+\n+      /* Return the address of the va_list constructor, but don't put it in a\n+\t register.  Doing so would fail when not optimizing and produce worse\n+\t code when optimizing.  */\n+      return XEXP (block, 0);\n+    }\n }\n \f\n /* This page contains routines that are used to determine what the function\n    prologue and epilogue code will do and write them out.  */\n \n /* Compute the size of the save area in the stack.  */\n \n+#if OPEN_VMS\n+\n+#define REG_PV 27\n+#define REG_RA 26\n+\n+/* These variables are used for communication between the following functions.\n+   They indicate various things about the current function being compiled\n+   that are used to tell what kind of prologue, epilogue and procedure\n+   descriptior to generate. */\n+\n+/* Nonzero if we need a stack procedure.  */\n+static int is_stack_procedure;\n+\n+/* Register number (either FP or SP) that is used to unwind the frame.  */\n+static int unwind_regno;\n+\n+/* Register number used to save FP.  We need not have one for RA since\n+   we don't modify it for register procedures.  This is only defined\n+   for register frame procedures.  */\n+static int save_fp_regno;\n+\n+/* Register number used to reference objects off our PV.  */\n+static int base_regno;\n+\n+/*  Compute register masks for saved registers.  */\n+\n+static void\n+alpha_sa_mask (imaskP, fmaskP)\n+    unsigned long *imaskP;\n+    unsigned long *fmaskP;\n+{\n+  unsigned long imask = 0;\n+  unsigned long fmask = 0;\n+  int i;\n+\n+  if (is_stack_procedure)\n+    imask |= (1L << HARD_FRAME_POINTER_REGNUM);\n+\n+  /* One for every register we have to save.  */\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i])\n+      {\n+\tif (i < 32)\n+\t  imask |= (1L << i);\n+\telse\n+\t  fmask |= (1L << (i - 32));\n+      }\n+\n+  *imaskP = imask;\n+  *fmaskP = fmask;\n+\n+  return;\n+}\n+\n+int\n+alpha_sa_size ()\n+{\n+  int sa_size = 0;\n+  HOST_WIDE_INT stack_needed;\n+  int i;\n+\n+  /* One for every register we have to save.  */\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i])\n+      sa_size++;\n+\n+  /* Start by assuming we can use a register procedure if we don't make any\n+     calls (REG_RA not used) or need to save any registers and a stack\n+     procedure if we do.  */\n+  is_stack_procedure = regs_ever_live[REG_RA] || sa_size != 0;\n+\n+  /* Decide whether to refer to objects off our PV via FP or PV.\n+     If we need need FP for something else or if we receive a nonlocal\n+     goto (which expects PV to contain the value), we must use PV.\n+     Otherwise, start by assuming we can use FP.  */\n+  base_regno = (frame_pointer_needed || current_function_has_nonlocal_label\n+\t\t|| is_stack_procedure\n+\t\t|| current_function_outgoing_args_size\n+\t\t? REG_PV : HARD_FRAME_POINTER_REGNUM);\n+\n+  /* If we want to copy PV into FP, we need to find some register in which to\n+     save FP.  */\n+\n+  save_fp_regno = -1;\n+\n+  if (base_regno == HARD_FRAME_POINTER_REGNUM)\n+    for (i = 0; i < 32; i++)\n+      if (! fixed_regs[i] && call_used_regs[i] && ! regs_ever_live[i])\n+\tsave_fp_regno = i;\n+\n+  if (save_fp_regno == -1)\n+    base_regno = REG_PV, is_stack_procedure = 1;\n+\n+  /* Stack unwinding should be done via FP unless we use it for PV.  */\n+  unwind_regno\n+    = base_regno == REG_PV ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM;\n+\n+  /* If this is a stack procedure, allow space for saving FP and RA.  */\n+  if (is_stack_procedure)\n+    sa_size += 2;\n+\n+  return sa_size * 8;\n+}\n+\n+int\n+alpha_pv_save_size ()\n+{\n+  alpha_sa_size ();\n+  return is_stack_procedure ? 8 : 0;\n+}\n+\n+int\n+alpha_using_fp ()\n+{\n+  alpha_sa_size ();\n+  return unwind_regno == HARD_FRAME_POINTER_REGNUM;\n+}\n+\n+#else /* ! OPEN_VMS */\n+\n int\n alpha_sa_size ()\n {\n@@ -1575,12 +1748,14 @@ alpha_sa_size ()\n   return size * 8;\n }\n \n+#endif /* ! OPEN_VMS */\n+\n /* Return 1 if this function can directly return via $26.  */\n \n int\n direct_return ()\n {\n-  return (reload_completed && alpha_sa_size () == 0\n+  return (! TARGET_OPEN_VMS && reload_completed && alpha_sa_size () == 0\n \t  && get_frame_size () == 0\n \t  && current_function_outgoing_args_size == 0\n \t  && current_function_pretend_args_size == 0);\n@@ -1589,7 +1764,7 @@ direct_return ()\n /* Write a version stamp.  Don't write anything if we are running as a\n    cross-compiler.  Otherwise, use the versions in /usr/include/stamp.h.  */\n \n-#if !defined(CROSS_COMPILE) && !defined(_WIN32) && !defined(__linux__)\n+#if !defined(CROSS_COMPILE) && !defined(_WIN32) && !defined(__linux__) && !defined(VMS)\n #include <stamp.h>\n #endif\n \n@@ -1662,6 +1837,438 @@ add_long_const (file, c, in_reg, out_reg, temp_reg)\n \n /* Write function prologue.  */\n \n+#if OPEN_VMS\n+\n+/* \n+   Quick and dirty vmskrunch routine to ensure symbols are within the\n+   64 bytes limit imposed by VMS.\n+\n+   This is written specifically for GNAT, and may not work for C++.\n+\n+   This routine duplicates every symbol passed to it whether it is too\n+   long or not, which is a waste of space, fix later.\n+*/\n+#include <string.h>\n+char*\n+vmskrunch (name)\n+     char *name;\n+{\n+  char *foo;\n+  int max = 60; /* Allow for the ..xx extension */\n+  int len, tlen;\n+\n+  if (name[0] == '*')\n+    return (&name[1]);\n+\n+  len = tlen = strlen (name);\n+  foo = xstrdup (name);\n+\n+  /* Don't muck with the ..xx extenstion */\n+  if ((foo [tlen-4] == '.') && (foo [tlen-3] == '.'))\n+    {\n+      max = max + 4;\n+      if (tlen > max)\n+\t{\n+\t  foo [tlen-4] = 0;\n+\t  len = len - 4;\n+\t  max = max - 4;\n+\t}\n+    }\n+\n+  if (len > max)\n+    {\n+      char *bar;\n+      int i, j, slen, nlen, xlen, chopchar;\n+\n+      nlen = len;\n+\n+      /* Change all _ and . characters to spaces, if thats enough then quit.\n+\t For example: \"foobar__foo__bar\" becomes \"foobar  foo  bar\" */\n+\n+      for (i = 0; bar = index (foo, '_'); i++)\n+\t*bar = ' ';\n+      nlen = nlen - i;\n+\n+      for (i = 0; bar = index (foo, '.'); i++)\n+\t*bar = ' ';\n+      nlen = nlen - i;\n+\n+      for (i = 0; bar = index (foo, '$'); i++)\n+\t*bar = ' ';\n+      nlen = nlen - i;\n+\n+      /* Iteratively make blank the rightmost non-blank character on the\n+\t longest leftmost substring delmited by blanks, until it's short\n+\t enough. For example: \"foobar  foo  bar\" becomes, successively:\n+\t \"fooba   foo bar\"\n+\t \"foob    foo bar\"\n+\t \"foo     foo bar\"\n+\t \"fo      foo bar\"\n+\t \"fo      fo  bar\"\n+\t \"fo      fo  ba \"\n+\t \"f       fo  ba \"\n+\t \"f       f   ba \"\n+\t \"f       f   b  \"\n+\t etc.  */\n+\n+      while (nlen > max)\n+\t{\n+\t  j = 0;\n+\t  xlen = 0;\n+\n+\t  while (foo[j])\n+\t    {\n+\t      /* Find first non-blank */\n+\t      if (foo[j])\n+\t\tfor (i = j; foo[i]==' ' && foo[i]; i++)\n+\t\t  ;\n+\n+\t      j = i;\n+\t      if (foo[j])\n+\t\tfor (i = j + 1; foo[i] != ' ' && foo[i]; i++)\n+\t\t  ;\n+\n+\t      slen = i - j;\n+\t      if (slen > xlen)\n+\t\t{\n+\t\t  chopchar = i - 1;\n+\t\t  xlen = slen;\n+\t\t}\n+\n+\t      j = i;\n+\t    }\n+\n+\t  foo [chopchar] = ' ';\n+\t  nlen--;\n+\t}\n+\n+      /* Put the ..xx extension back */\n+      if (len != tlen)\n+\t{\n+\t  foo [len] = '.';\n+\t  len = len + 4;\n+\t}\n+\n+      /* Collapse all the blanks */\n+      j = 0;\n+      for (i = 0; foo[i]; i++)\n+\tif (foo[i] != ' ')\n+\t  foo[j++] = foo[i];\n+      foo[j] = 0;\n+\n+      return foo;\n+    }\n+\n+  /* Put back the ..xx extension */\n+  if (len != tlen)\n+    {\n+      foo [len] = '.';\n+      len = len + 4;\n+    }\n+\n+  free (foo);\n+  return name;\n+}\n+\n+/* On vms we have two kinds of functions:\n+\n+   - stack frame (PROC_STACK)\n+\tthese are 'normal' functions with local vars and which are\n+\tcalling other functions\n+   - register frame (PROC_REGISTER)\n+\tkeeps all data in registers, needs no stack\n+\n+   We must pass this to the assembler so it can generate the\n+   proper pdsc (procedure descriptor)\n+   This is done with the '.pdesc' command.\n+\n+   size is the stack size needed for local variables.  */\n+\n+void\n+output_prolog (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  unsigned long imask = 0;\n+  unsigned long fmask = 0;\n+  /* Stack space needed for pushing registers clobbered by us.  */\n+  HOST_WIDE_INT sa_size;\n+  /* Complete stack size needed.  */\n+  HOST_WIDE_INT frame_size;\n+  /* Offset from base reg to register save area.  */\n+  int rsa_offset = 8;\n+  /* Offset during register save.  */\n+  int reg_offset;\n+  /* Label for the procedure entry.  */\n+  char entry_label[70];\n+  int i;\n+\n+  sa_size = alpha_sa_size ();\n+  frame_size\n+    = ALPHA_ROUND (sa_size \n+\t\t   + (is_stack_procedure ? 8 : 0)\n+\t\t   + size + current_function_pretend_args_size);\n+\n+  fprintf (file, \"# size %d, current_function_pretend_args_size %d, current_function_outgoing_args_size %d\\n\",\n+\tsize, current_function_pretend_args_size, current_function_outgoing_args_size);\n+  fprintf (file, \"# sa_size %d, frame_size %d\\n\", sa_size, frame_size);\n+\n+  /* Issue function start and label.  */\n+  fprintf (file, \"\\t.ent \");\n+  assemble_name (file, alpha_function_name);\n+  fprintf (file, \"\\n\");\n+  sprintf (entry_label, \"%.64s..en\", alpha_function_name);\n+  ASM_OUTPUT_LABEL (file, entry_label);\n+  inside_function = TRUE;\n+\n+  fprintf (file, \"\\t.base $%d\\n\", base_regno);\n+\n+  /* Calculate register masks for clobbered registers.  */\n+\n+  if (is_stack_procedure)\n+    alpha_sa_mask (&imask, &fmask);\n+\n+  /* Adjust the stack by the frame size.  If the frame size is > 4096\n+     bytes, we need to be sure we probe somewhere in the first and last\n+     4096 bytes (we can probably get away without the latter test) and\n+     every 8192 bytes in between.  If the frame size is > 32768, we\n+     do this in a loop.  Otherwise, we generate the explicit probe\n+     instructions. \n+\n+     Note that we are only allowed to adjust sp once in the prologue.  */\n+\n+  if (frame_size < 32768)\n+    {\n+      if (frame_size > 4096)\n+\t{\n+\t  int probed = 4096;\n+\n+\t  fprintf (file, \"\\tstq $31,-%d($30)\\n\", probed);\n+\n+\t  while (probed + 8192 < frame_size)\n+\t    fprintf (file, \"\\tstq $31,-%d($30)\\n\", probed += 8192);\n+\n+\t  /* We only have to do this probe if we aren't saving registers.  */\n+\t  if (sa_size == 0 && probed + 4096 < frame_size)\n+\t    fprintf (file, \"\\tstq $31,-%d($30)\\n\", frame_size);\n+\t}\n+\n+      if (frame_size != 0)\n+\t  fprintf (file, \"\\tlda $30,-%d($30)\\n\", frame_size);\n+    }\n+  else\n+    {\n+      /* Here we generate code to set R4 to SP + 4096 and set R23 to the\n+\t number of 8192 byte blocks to probe.  We then probe each block\n+\t in the loop and then set SP to the proper location.  If the\n+\t amount remaining is > 4096, we have to do one more probe if we\n+\t are not saving any registers.  */\n+\n+      HOST_WIDE_INT blocks = (frame_size + 4096) / 8192;\n+      HOST_WIDE_INT leftover = frame_size + 4096 - blocks * 8192;\n+\n+      add_long_const (file, blocks, 31, 23, 23);\n+\n+      fprintf (file, \"\\tlda $22,4096($30)\\n\");\n+\n+      assemble_name (file, alpha_function_name);\n+      fprintf (file, \"..sc:\\n\");\n+\n+      fprintf (file, \"\\tstq $31,-8192($22)\\n\");\n+      fprintf (file, \"\\tsubq $23,1,$23\\n\");\n+      fprintf (file, \"\\tlda $22,-8192($22)\\n\");\n+\n+      fprintf (file, \"\\tbne $23,\");\n+      assemble_name (file, alpha_function_name);\n+      fprintf (file, \"..sc\\n\");\n+\n+      if (leftover > 4096 && sa_size == 0)\n+\tfprintf (file, \"\\tstq $31,-%d($22)\\n\", leftover);\n+\n+      fprintf (file, \"\\tlda $30,-%d($22)\\n\", leftover);\n+    }\n+\n+  if (is_stack_procedure)\n+    {\n+      int reg_offset = rsa_offset;\n+\n+      /* Store R26 (RA) first.  */\n+      fprintf (file, \"\\tstq $26,%d($30)\\n\", reg_offset);\n+      reg_offset += 8;\n+\n+      /* Store integer regs. according to mask.  */\n+      for (i = 0; i < 32; i++)\n+        if (imask & (1L<<i))\n+\t  {\n+\t    fprintf (file, \"\\tstq $%d,%d($30)\\n\", i, reg_offset);\n+\t    reg_offset += 8;\n+\t  }\n+\n+      /* Print the register mask and do floating-point saves.  */\n+\n+      if (imask)\n+\tfprintf (file, \"\\t.mask 0x%x,0\\n\", imask);\n+\n+      for (i = 0; i < 32; i++)\n+\t{\n+\t  if (fmask & (1L << i))\n+\t    {\n+\t      fprintf (file, \"\\tstt $f%d,%d($30)\\n\", i, reg_offset);\n+\t      reg_offset += 8;\n+\t    }\n+\t}\n+\n+      /* Print the floating-point mask, if we've saved any fp register.  */\n+      if (fmask)\n+\tfprintf (file, \"\\t.fmask 0x%x,0\\n\", fmask);\n+\n+      fprintf (file, \"\\tstq $27,0($30)\\n\");\n+    }\n+  else \n+    {\n+      fprintf (file, \"\\t.fp_save $%d\\n\", save_fp_regno);\n+      fprintf (file, \"\\tbis $%d,$%d,$%d\\n\", HARD_FRAME_POINTER_REGNUM,\n+\t       HARD_FRAME_POINTER_REGNUM, save_fp_regno);\n+    }\n+\n+  if (base_regno != REG_PV)\n+    fprintf (file, \"\\tbis $%d,$%d,$%d\\n\", REG_PV, REG_PV, base_regno);\n+\n+  if (unwind_regno == HARD_FRAME_POINTER_REGNUM)\n+    fprintf (file, \"\\tbis $%d,$%d,$%d\\n\", STACK_POINTER_REGNUM,\n+\t     STACK_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM);\n+\n+  /* Describe our frame.  */\n+  fprintf (file, \"\\t.frame $%d,%d,$26,%d\\n\", \n+\t   unwind_regno, frame_size, rsa_offset);\n+\n+  /* If we have to allocate space for outgoing args, do it now.  */\n+  if (current_function_outgoing_args_size != 0)\n+    fprintf (file, \"\\tlda $%d,%d($%d)\\n\", STACK_POINTER_REGNUM,\n+\t     - ALPHA_ROUND (current_function_outgoing_args_size),\n+\t     HARD_FRAME_POINTER_REGNUM);\n+\n+  fprintf (file, \"\\t.prologue\\n\");\n+\n+  link_section ();\n+  fprintf (file, \"\\t.align 3\\n\");\n+  ASM_OUTPUT_LABEL (file, alpha_function_name);\n+  fprintf (file, \"\\t.pdesc \");\n+  assemble_name (file, alpha_function_name);\n+  fprintf (file, \"..en,%s\\n\", is_stack_procedure ? \"stack\" : \"reg\");\n+  alpha_need_linkage (alpha_function_name, 1);\n+  text_section ();\n+\n+  return;\n+}\n+\n+/* Write function epilogue.  */\n+\n+void\n+output_epilog (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  unsigned long imask = 0;\n+  unsigned long fmask = 0;\n+  /* Stack space needed for pushing registers clobbered by us.  */\n+  HOST_WIDE_INT sa_size = alpha_sa_size ();\n+  /* Complete stack size needed.  */\n+  HOST_WIDE_INT frame_size\n+    = ALPHA_ROUND (sa_size\n+\t\t   + (is_stack_procedure ? 8 : 0)\n+\t\t   + size + current_function_pretend_args_size);\n+  int i;\n+  rtx insn = get_last_insn ();\n+\n+  /* If the last insn was a BARRIER, we don't have to write anything except\n+     the .end pseudo-op.  */\n+\n+  if (GET_CODE (insn) == NOTE)\n+    insn = prev_nonnote_insn (insn);\n+\n+  if (insn == 0 || GET_CODE (insn) != BARRIER)\n+    {\n+      /* Restore clobbered registers, load FP last.  */\n+\n+      if (is_stack_procedure)\n+\t{\n+\t  int rsa_offset = 8;\n+\t  int reg_offset;\n+\t  int fp_offset;\n+\n+\t  if (unwind_regno == HARD_FRAME_POINTER_REGNUM)\n+\t    fprintf (file, \"\\tbis $%d,$%d,$%d\\n\", HARD_FRAME_POINTER_REGNUM,\n+\t\t     HARD_FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM);\n+\n+\t  alpha_sa_mask (&imask, &fmask);\n+\n+\t  /* Start reloading registers after RA.  */\n+\t  reg_offset = rsa_offset + 8;\n+\n+\t  for (i = 0; i < 32; i++)\n+\t    if (imask & (1L<<i))\n+\t      {\n+\t\tif (i == HARD_FRAME_POINTER_REGNUM)\n+\t\t  fp_offset = reg_offset;\n+\t\telse\n+\t\t  fprintf (file, \"\\tldq $%d,%d($30)\\n\",\n+\t\t\t\t  i, reg_offset);\n+\t\treg_offset += 8;\n+\t      }\n+\n+\t  for (i = 0; i < 32; i++)\n+\t    if (fmask & (1L << i))\n+\t      {\n+\t\tfprintf (file, \"\\tldt $f%d,%d($30)\\n\", i, reg_offset);\n+\t\treg_offset += 8;\n+\t      }\n+\n+\t  /* Restore R26 (RA).  */\n+\t  fprintf (file, \"\\tldq $26,%d($30)\\n\", rsa_offset);\n+\n+\t  /* Restore R29 (FP).  */\n+\t  fprintf (file, \"\\tldq $29,%d($30)\\n\", fp_offset);\n+\t}\n+      else\n+\tfprintf (file, \"\\tbis $%d,$%d,$%d\\n\", save_fp_regno, save_fp_regno,\n+\t\t HARD_FRAME_POINTER_REGNUM);\n+\n+      if (frame_size != 0)\n+\t{\n+\t  if (frame_size < 32768)\n+\t    fprintf (file, \"\\tlda $30,%d($30)\\n\", frame_size);\n+\t  else\n+\t    {\n+\t      long high = frame_size >> 16;\n+\t      long low = frame_size & 0xffff;\n+\t      if (low & 0x8000)\n+\t\t{\n+\t\t  high++;\n+\t\t  low = -32768 + (low & 0x7fff);\n+\t\t}\n+\t      fprintf (file, \"\\tldah $2,%ld($31)\\n\", high);\n+\t      fprintf (file, \"\\tlda $2,%ld($2)\\n\", low);\n+\t      fprintf (file, \"\\taddq $30,$2,$30\\n\");\n+\t    }\n+\t}\n+\n+      /* Finally return to the caller.  */\n+      fprintf (file, \"\\tret $31,($26),1\\n\");\n+    }\n+\n+  /* End the function.  */\n+  fprintf (file, \"\\t.end \");\n+  assemble_name (file,  alpha_function_name);\n+  fprintf (file, \"\\n\");\n+  inside_function = FALSE;\n+\n+  /* Show that we know this function if it is called again.  */\n+  SYMBOL_REF_FLAG (XEXP (DECL_RTL (current_function_decl), 0)) = 1;\n+}\n+\n+#else /* !OPEN_VMS */\n+\n void\n output_prolog (file, size)\n      FILE *file;\n@@ -1981,6 +2588,7 @@ output_epilog (file, size)\n   /* Show that we know this function if it is called again.  */\n   SYMBOL_REF_FLAG (XEXP (DECL_RTL (current_function_decl), 0)) = 1;\n }\n+#endif /* !OPEN_VMS */\n \f\n /* Debugging support.  */\n \n@@ -2360,6 +2968,9 @@ check_float_value (mode, d, overflow)\n   if (TARGET_IEEE || TARGET_IEEE_CONFORMANT || TARGET_IEEE_WITH_INEXACT)\n     return 0;\n \n+  if (TARGET_FLOAT_VAX)\n+    return 0;\n+\n   if (inited_float_values == 0)\n     {\n       int i;\n@@ -2402,3 +3013,150 @@ check_float_value (mode, d, overflow)\n \n   return 0;\n }\n+\n+#if OPEN_VMS\n+\n+void *\n+function_arg (cum, mode, type, named)\n+    CUMULATIVE_ARGS *cum;\n+    enum machine_mode mode;\n+    tree type;\n+    int named;\n+{\n+  int arg;\n+\n+  if (mode == VOIDmode)\t\t/* final call, return argument information  */\n+    {\n+      return GEN_INT (*cum);\n+    }\n+\n+  arg = *cum & 0xff;\n+\n+  switch (mode)\n+    {\n+      case SFmode:\n+\t*cum |= (((TARGET_FLOAT_VAX)?1:4) << ((arg * 3)+8));      /* 4 = AI$K_AR_FS, IEEE single */\n+        break;\n+      case DFmode:\n+        *cum |= (((TARGET_FLOAT_VAX)?3:5) << ((arg * 3)+8));      /* 5 = AI$K_AR_FT, IEEE double */\n+        break;\n+      case TFmode:\n+        *cum |= (7 << ((arg * 3)+8));        /* 5 = AI$K_AR_FT, IEEE double */\n+        break;\n+      default:\n+        break;\n+    }\n+\n+  return (arg < 6 && ! MUST_PASS_IN_STACK (mode, type)\n+\t ? gen_rtx(REG, mode,\n+\t\t   (*cum & 0xff) + 16 + ((TARGET_FPREGS\n+\t\t\t  && (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+\t\t\t      || GET_MODE_CLASS (mode) == MODE_FLOAT))\n+\t\t\t * 32))\n+\t : 0);\n+}\n+\n+/* Structure to collect function names for final output\n+   in link section.  */\n+\n+enum links_kind {KIND_UNUSED, KIND_LOCAL, KIND_EXTERN};\n+\n+\n+struct alpha_links {\n+  struct alpha_links *next;\n+  char *name;\n+  enum links_kind kind;\n+};\n+\n+static struct alpha_links *alpha_links_base = 0;\n+\n+/* Make (or fake) .linkage entry for function call.\n+\n+   IS_LOCAL is 0 if name is used in call, 1 if name is used in definition.  */\n+\n+void\n+alpha_need_linkage (name, is_local)\n+    char *name;\n+    int is_local;\n+{\n+  rtx x;\n+  struct alpha_links *lptr, *nptr;\n+\n+  if (name[0] == '*')\n+    name++;\n+\n+  /* Is this name already defined ?  */\n+\n+  for (lptr = alpha_links_base; lptr; lptr = lptr->next)\n+    if (strcmp (lptr->name, name) == 0)\n+      {\n+\tif (is_local)\n+\t  {\n+\t    /* defined here but external assumed.  */\n+\t    if (lptr->kind == KIND_EXTERN)\n+\t      lptr->kind = KIND_LOCAL;\n+\t  }\n+\telse\n+\t  {\n+\t    /* used here but unused assumed.  */\n+\t    if (lptr->kind == KIND_UNUSED)\n+\t      lptr->kind = KIND_LOCAL;\n+\t  }\n+\treturn;\n+      }\n+\n+  nptr = (struct alpha_links *) xmalloc (sizeof (struct alpha_links));\n+  nptr->next = alpha_links_base;\n+  nptr->name = xstrdup (name);\n+\n+  /* Assume external if no definition.  */\n+  nptr->kind = (is_local ? KIND_UNUSED : KIND_EXTERN);\n+\n+  alpha_links_base = nptr;\n+\n+  return;\n+}\n+\n+\n+void\n+alpha_write_linkage (stream)\n+    FILE *stream;\n+{\n+  struct alpha_links *lptr, *nptr;\n+\n+  readonly_section ();\n+\n+  fprintf (stream, \"\\t.align 3\\n\");\n+\n+  for (lptr = alpha_links_base; lptr; lptr = nptr)\n+    {\n+      nptr = lptr->next;\n+\n+      if (lptr->kind == KIND_UNUSED\n+\t  || ! TREE_SYMBOL_REFERENCED (get_identifier (lptr->name)))\n+\tcontinue;\n+\n+      fprintf (stream, \"%s..lk:\\n\", lptr->name);\n+      if (lptr->kind == KIND_LOCAL)   \n+\t{\n+\t  /*  Local and used, build linkage pair.  */\n+\t  fprintf (stream, \"\\t.quad %s..en\\n\", lptr->name);\n+\t  fprintf (stream, \"\\t.quad %s\\n\", lptr->name);\n+\t}\n+      else\n+\t/* External and used, request linkage pair.  */\n+\tfprintf (stream, \"\\t.linkage %s\\n\", lptr->name);\n+    }\n+}\n+\n+#else\n+\n+void\n+alpha_need_linkage (name, is_local)\n+     char *name;\n+     int is_local;\n+{\n+}\n+\n+#endif /* OPEN_VMS */\n+"}]}