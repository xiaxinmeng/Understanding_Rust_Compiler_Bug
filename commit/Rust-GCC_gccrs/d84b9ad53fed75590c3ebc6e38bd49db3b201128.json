{"sha": "d84b9ad53fed75590c3ebc6e38bd49db3b201128", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg0YjlhZDUzZmVkNzU1OTBjM2ViYzZlMzhiZDQ5ZGIzYjIwMTEyOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-31T16:04:53Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-31T16:04:53Z"}, "message": "[arm] Pattern match insns for a + ~b + Carry\n\nOn ARM, the SBC instruction is defined as\n\n  Ra - Rb - ~C\n\nwhere C is the carry flag.  But -Rb = ~Rb + 1, so this is equivalent to\n\n  Ra + ~Rb + 1 - ~C\n\nwhich then simplifies to\n\n  Ra + ~Rb + C\n\nwhich is essentially an add-with-carry with one operand inverted.  We\ncan define RTL patterns to match this.  In thumb2 we can only match\nwhen the operands are both registers, but in Arm state we can also use\nRSC to match when Rn is either a constant or a shifted operand.\n\nThis overall simplifies some cases of 64-bit arithmetic, for example, \n\nint64_t f (int64_t a, int64_t b) { return a + ~b; }\n\nwill now compile to\n\n  MVN  R2, R2\n  ADDS R0, R0, R2\n  SBC  R1, R1, R3\n\n\t* config/arm/arm.md (add_not_cin): New insn.\n\t(add_not_shift_cin): Likewise.\n\nFrom-SVN: r277676", "tree": {"sha": "ce3b64c8ef2a81cef3e94d237f672cb1df5004d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce3b64c8ef2a81cef3e94d237f672cb1df5004d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d84b9ad53fed75590c3ebc6e38bd49db3b201128", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d84b9ad53fed75590c3ebc6e38bd49db3b201128", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d84b9ad53fed75590c3ebc6e38bd49db3b201128", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d84b9ad53fed75590c3ebc6e38bd49db3b201128/comments", "author": null, "committer": null, "parents": [{"sha": "946b4a68b3766ddbdb2290855c5167bd30c933a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/946b4a68b3766ddbdb2290855c5167bd30c933a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/946b4a68b3766ddbdb2290855c5167bd30c933a0"}], "stats": {"total": 40, "additions": 40, "deletions": 0}, "files": [{"sha": "e520cf054036f875eedc22e074a0d8ee96448fa5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84b9ad53fed75590c3ebc6e38bd49db3b201128/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84b9ad53fed75590c3ebc6e38bd49db3b201128/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d84b9ad53fed75590c3ebc6e38bd49db3b201128", "patch": "@@ -1,3 +1,8 @@\n+2019-10-31  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.md (add_not_cin): New insn.\n+\t(add_not_shift_cin): Likewise.\n+\n 2019-10-31  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-icf-gimple.c (func_checker::compare_tree_ssa_label): Remove."}, {"sha": "4f035cbfddd574c86cd907b579ddaf93be179943", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84b9ad53fed75590c3ebc6e38bd49db3b201128/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84b9ad53fed75590c3ebc6e38bd49db3b201128/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d84b9ad53fed75590c3ebc6e38bd49db3b201128", "patch": "@@ -1662,6 +1662,41 @@\n    (set_attr \"type\" \"adc_imm\")]\n )\n \n+;; SBC performs Rn - Rm - ~C, but -Rm = ~Rm + 1 => Rn + ~Rm + 1 - ~C\n+;; => Rn + ~Rm + C, which is essentially ADC Rd, Rn, ~Rm\n+(define_insn \"*add_not_cin\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(plus:SI\n+\t (plus:SI (not:SI (match_operand:SI 1 \"s_register_operand\" \"r,r\"))\n+\t\t  (match_operand:SI 3 \"arm_carry_operation\" \"\"))\n+\t (match_operand:SI 2 \"arm_rhs_operand\" \"r,I\")))]\n+  \"TARGET_ARM || (TARGET_THUMB2 && !CONST_INT_P (operands[2]))\"\n+  \"@\n+   sbc%?\\\\t%0, %2, %1\n+   rsc%?\\\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"use\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"arch\" \"*,a\")\n+   (set_attr \"type\" \"adc_reg,adc_imm\")]\n+)\n+\n+;; On Arm we can also use the same trick when the non-inverted operand is\n+;; shifted, using RSC.\n+(define_insn \"add_not_shift_cin\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(plus:SI\n+\t (plus:SI (match_operator:SI 3 \"shift_operator\"\n+\t\t   [(match_operand:SI 1 \"s_register_operand\" \"r,r\")\n+\t\t    (match_operand:SI 2 \"shift_amount_operand\" \"M,r\")])\n+\t\t  (not:SI (match_operand:SI 4 \"s_register_operand\" \"r,r\")))\n+\t (match_operand:SI 5 \"arm_carry_operation\" \"\")))]\n+  \"TARGET_ARM\"\n+  \"rsc%?\\\\t%0, %4, %1%S3\"\n+  [(set_attr \"conds\" \"use\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"alu_shift_imm,alu_shift_reg\")]\n+)\n+\n (define_insn \"cmpsi3_carryin_<CC_EXTEND>out\"\n   [(set (reg:<CC_EXTEND> CC_REGNUM)\n \t(compare:<CC_EXTEND>"}]}