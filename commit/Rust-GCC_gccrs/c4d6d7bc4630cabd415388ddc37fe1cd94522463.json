{"sha": "c4d6d7bc4630cabd415388ddc37fe1cd94522463", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRkNmQ3YmM0NjMwY2FiZDQxNTM4OGRkYzM3ZmUxY2Q5NDUyMjQ2Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-05-18T17:14:11Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-05-18T17:14:11Z"}, "message": "DR 1391\n\n\tDR 1391\n\t* pt.c (type_unification_real): Check convertibility here.\n\t(unify_one_argument): Not here.\n\nFrom-SVN: r223301", "tree": {"sha": "d46415ab407e3f252d9f85324cd17bba2440ed81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d46415ab407e3f252d9f85324cd17bba2440ed81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4d6d7bc4630cabd415388ddc37fe1cd94522463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4d6d7bc4630cabd415388ddc37fe1cd94522463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4d6d7bc4630cabd415388ddc37fe1cd94522463", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4d6d7bc4630cabd415388ddc37fe1cd94522463/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f56fadc243818bb1b89ac6f53c042d81eb03599", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f56fadc243818bb1b89ac6f53c042d81eb03599", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f56fadc243818bb1b89ac6f53c042d81eb03599"}], "stats": {"total": 193, "additions": 150, "deletions": 43}, "files": [{"sha": "957dc1deed50392f39598ae92b8839c6e6415320", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c4d6d7bc4630cabd415388ddc37fe1cd94522463", "patch": "@@ -1,5 +1,9 @@\n 2015-05-18  Jason Merrill  <jason@redhat.com>\n \n+\tDR 1391\n+\t* pt.c (type_unification_real): Check convertibility here.\n+\t(unify_one_argument): Not here.\n+\n \t* tree.c (strip_typedefs_expr) [TRAIT_EXPR]: Fix typo.\n \t(strip_typedefs) [DECLTYPE_TYPE]: Fix typedef of decltype.\n \t[TREE_LIST]: Fix no-change case."}, {"sha": "2cd36c9c9fff6e96f0a917b25d43e12ea3cb3a4b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 93, "deletions": 41, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c4d6d7bc4630cabd415388ddc37fe1cd94522463", "patch": "@@ -16678,7 +16678,7 @@ uses_deducible_template_parms (tree type)\n \n static int\n unify_one_argument (tree tparms, tree targs, tree parm, tree arg,\n-\t\t    int subr, unification_kind_t strict, int flags,\n+\t\t    int subr, unification_kind_t strict,\n \t\t    bool explain_p)\n {\n   tree arg_expr = NULL_TREE;\n@@ -16695,16 +16695,10 @@ unify_one_argument (tree tparms, tree targs, tree parm, tree arg,\n      argument to convert it to the type of the corresponding function\n      parameter if the parameter type contains no template-parameters that\n      participate in template argument deduction.  */\n-  if (TYPE_P (parm) && !uses_template_parms (parm))\n-    /* For function parameters that contain no template-parameters at all,\n-       we have historically checked for convertibility in order to shortcut\n-       consideration of this candidate.  */\n-    return check_non_deducible_conversion (parm, arg, strict, flags,\n-\t\t\t\t\t   explain_p);\n-  else if (strict == DEDUCE_CALL\n-\t   && TYPE_P (parm) && !uses_deducible_template_parms (parm))\n-    /* For function parameters with only non-deducible template parameters,\n-       just return.  */\n+  if (strict != DEDUCE_EXACT\n+      && TYPE_P (parm) && !uses_deducible_template_parms (parm))\n+    /* For function parameters with no deducible template parameters,\n+       just return.  We'll check non-dependent conversions later.  */\n     return unify_success (explain_p);\n \n   switch (strict)\n@@ -16843,7 +16837,7 @@ type_unification_real (tree tparms,\n       ++ia;\n \n       if (unify_one_argument (tparms, targs, parm, arg, subr, strict,\n-\t\t\t      flags, explain_p))\n+\t\t\t      explain_p))\n \treturn 1;\n     }\n \n@@ -16925,8 +16919,11 @@ type_unification_real (tree tparms,\n \t     this parameter can be deduced.  */\n \t  if (TREE_CODE (tparm) == PARM_DECL\n \t      && uses_template_parms (TREE_TYPE (tparm))\n-\t      && !saw_undeduced++)\n-\t    goto again;\n+\t      && saw_undeduced < 2)\n+\t    {\n+\t      saw_undeduced = 1;\n+\t      continue;\n+\t    }\n \n \t  /* Core issue #226 (C++0x) [temp.deduct]:\n \n@@ -16937,32 +16934,9 @@ type_unification_real (tree tparms,\n \t     be NULL_TREE or ERROR_MARK_NODE, so we do not need\n \t     to explicitly check cxx_dialect here.  */\n \t  if (TREE_PURPOSE (TREE_VEC_ELT (tparms, i)))\n-\t    {\n-\t      tree parm = TREE_VALUE (TREE_VEC_ELT (tparms, i));\n-\t      tree arg = TREE_PURPOSE (TREE_VEC_ELT (tparms, i));\n-\t      reopen_deferring_access_checks (*checks);\n-\t      location_t save_loc = input_location;\n-\t      if (DECL_P (parm))\n-\t\tinput_location = DECL_SOURCE_LOCATION (parm);\n-\t      arg = tsubst_template_arg (arg, targs, complain, NULL_TREE);\n-\t      arg = convert_template_argument (parm, arg, targs, complain,\n-\t\t\t\t\t       i, NULL_TREE);\n-\t      input_location = save_loc;\n-\t      *checks = get_deferred_access_checks ();\n-\t      pop_deferring_access_checks ();\n-\t      if (arg == error_mark_node)\n-\t\treturn 1;\n-\t      else\n-\t\t{\n-\t\t  TREE_VEC_ELT (targs, i) = arg;\n-\t\t  /* The position of the first default template argument,\n-\t\t     is also the number of non-defaulted arguments in TARGS.\n-\t\t     Record that.  */\n-\t\t  if (!NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs))\n-\t\t    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs, i);\n-\t\t  continue;\n-\t\t}\n-\t    }\n+\t    /* OK, there is a default argument.  Wait until after the\n+\t       conversion check to do substitution.  */\n+\t    continue;\n \n \t  /* If the type parameter is a parameter pack, then it will\n \t     be deduced to an empty parameter pack.  */\n@@ -16987,6 +16961,84 @@ type_unification_real (tree tparms,\n \n \t  return unify_parameter_deduction_failure (explain_p, tparm);\n \t}\n+\n+      /* DR 1391: All parameters have args, now check non-dependent parms for\n+\t convertibility.  */\n+      if (saw_undeduced < 2)\n+\tfor (ia = 0, parms = xparms, args = xargs, nargs = xnargs;\n+\t     parms && parms != void_list_node && ia < nargs; )\n+\t  {\n+\t    parm = TREE_VALUE (parms);\n+\n+\t    if (TREE_CODE (parm) == TYPE_PACK_EXPANSION\n+\t\t&& (!TREE_CHAIN (parms)\n+\t\t    || TREE_CHAIN (parms) == void_list_node))\n+\t      /* For a function parameter pack that occurs at the end of the\n+\t\t parameter-declaration-list, the type A of each remaining\n+\t\t argument of the call is compared with the type P of the\n+\t\t declarator-id of the function parameter pack.  */\n+\t      break;\n+\n+\t    parms = TREE_CHAIN (parms);\n+\n+\t    if (TREE_CODE (parm) == TYPE_PACK_EXPANSION)\n+\t      /* For a function parameter pack that does not occur at the\n+\t\t end of the parameter-declaration-list, the type of the\n+\t\t parameter pack is a non-deduced context.  */\n+\t      continue;\n+\n+\t    arg = args[ia];\n+\t    ++ia;\n+\n+\t    if (uses_template_parms (parm))\n+\t      continue;\n+\t    if (check_non_deducible_conversion (parm, arg, strict, flags,\n+\t\t\t\t\t\texplain_p))\n+\t      return 1;\n+\t  }\n+\n+      /* Now substitute into the default template arguments.  */\n+      for (i = 0; i < ntparms; i++)\n+\t{\n+\t  tree targ = TREE_VEC_ELT (targs, i);\n+\t  tree tparm = TREE_VEC_ELT (tparms, i);\n+\n+\t  if (targ || tparm == error_mark_node)\n+\t    continue;\n+\t  tree parm = TREE_VALUE (tparm);\n+\n+\t  if (TREE_CODE (parm) == PARM_DECL\n+\t      && uses_template_parms (TREE_TYPE (parm))\n+\t      && saw_undeduced < 2)\n+\t    continue;\n+\n+\t  tree arg = TREE_PURPOSE (tparm);\n+\t  reopen_deferring_access_checks (*checks);\n+\t  location_t save_loc = input_location;\n+\t  if (DECL_P (parm))\n+\t    input_location = DECL_SOURCE_LOCATION (parm);\n+\t  arg = tsubst_template_arg (arg, targs, complain, NULL_TREE);\n+\t  arg = convert_template_argument (parm, arg, targs, complain,\n+\t\t\t\t\t   i, NULL_TREE);\n+\t  input_location = save_loc;\n+\t  *checks = get_deferred_access_checks ();\n+\t  pop_deferring_access_checks ();\n+\t  if (arg == error_mark_node)\n+\t    return 1;\n+\t  else\n+\t    {\n+\t      TREE_VEC_ELT (targs, i) = arg;\n+\t      /* The position of the first default template argument,\n+\t\t is also the number of non-defaulted arguments in TARGS.\n+\t\t Record that.  */\n+\t      if (!NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs))\n+\t\tSET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs, i);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (saw_undeduced++ == 1)\n+\tgoto again;\n     }\n #ifdef ENABLE_CHECKING\n   if (!NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs))\n@@ -17601,7 +17653,7 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n \n       /* Unify the pattern with the current argument.  */\n       if (unify_one_argument (tparms, targs, parm, arg, subr, strict,\n-\t\t\t      LOOKUP_IMPLICIT, explain_p))\n+\t\t\t      explain_p))\n \treturn 1;\n \n       /* For each parameter pack, collect the deduced value.  */"}, {"sha": "705e4e602dd4caeb15cbb2437298ba8bb40de77c", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic118.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic118.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic118.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic118.C?ref=c4d6d7bc4630cabd415388ddc37fe1cd94522463", "patch": "@@ -1,8 +1,7 @@\n-// This should fail deduction, before it produces a candidate.\n // { dg-do compile { target c++11 } }\n \n template <class... T>\n-void f(T... ts);\t\t// { dg-message \"deduction\" }\n+void f(T... ts);\n \n struct B { };\n int main()"}, {"sha": "0b99f5d4a91c9c4782a2fa7ace59caebcea6b898", "filename": "gcc/testsuite/g++.dg/template/dr1391-1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdr1391-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdr1391-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdr1391-1.C?ref=c4d6d7bc4630cabd415388ddc37fe1cd94522463", "patch": "@@ -0,0 +1,17 @@\n+// DR 1391\n+\n+template<class T> struct A {\n+  typename T::N n;\n+};\n+template<class T> struct B { };\n+\n+template<class T, class T2>\n+void foo(const A<T>& r); // #1\n+template<class T>\n+void foo(const B<T>& r); // #2\n+\n+void baz() {\n+  B<char> b;\n+  foo(b); // OK\n+  foo<char>(b); // error\n+}"}, {"sha": "1af71f0d33309c1f4cf3fe7b1e90214ad06eb7bc", "filename": "gcc/testsuite/g++.dg/template/dr1391-2.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdr1391-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdr1391-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdr1391-2.C?ref=c4d6d7bc4630cabd415388ddc37fe1cd94522463", "patch": "@@ -0,0 +1,22 @@\n+// DR 1391\n+// { dg-do compile { target c++11 } }\n+\n+template<class T>\n+struct A {\n+  typename T::N n;\n+};\n+\n+template<class T>\n+struct B { };\n+\n+template <class T, class... U>\n+typename A<T>::value_t bar(int, T, U...);\n+\n+template <class T>\n+T bar(T, T);\n+\n+void baz()\n+{\n+  B<char> b;\n+  bar(b, b);\n+}"}, {"sha": "0f5879704c1d1a767d612e9104efe511201853a3", "filename": "gcc/testsuite/g++.dg/template/dr1391-3.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdr1391-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4d6d7bc4630cabd415388ddc37fe1cd94522463/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdr1391-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdr1391-3.C?ref=c4d6d7bc4630cabd415388ddc37fe1cd94522463", "patch": "@@ -0,0 +1,13 @@\n+// DR 1391\n+\n+template <class T> struct Z {\n+  typedef typename T::x xx;\n+};\n+template <class T> typename Z<T>::xx f(void *, T);\n+template <class T> void f(int, T);\n+struct A {} a;\n+int main() {\n+  f(1, a); // If the implementation rules out the first overload\n+  // because of the invalid conversion from int to void*,\n+  // the error instantiating Z<A> will be avoided\n+}"}]}