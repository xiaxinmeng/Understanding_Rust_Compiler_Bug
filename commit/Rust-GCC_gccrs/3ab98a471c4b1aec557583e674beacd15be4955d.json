{"sha": "3ab98a471c4b1aec557583e674beacd15be4955d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FiOThhNDcxYzRiMWFlYzU1NzU4M2U2NzRiZWFjZDE1YmU0OTU1ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-02-15T18:55:09Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-02-15T18:55:09Z"}, "message": "runtime: Do not reserve huge amount of swap on 32 bit architectures.\n\nThe mmap() call which reserves the arena should have MAP_NORESERVE\nflag as in typical cases this memory will never be (fully) needed.\nThis matters in environments which do not do Linux style memory\novercommit, such as OpenIndiana/OpenSolaris/Solaris.\n\nThe MAP_NORESERVE flag does not exist on all operating systems\n(for example FreeBSD). Therefore we define it to zero value in\ncase it does not exist.\n\nFixes issue 21.\n\nFrom-SVN: r196088", "tree": {"sha": "69367e678dd8ce0bf0495ccdf1a1712913949390", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69367e678dd8ce0bf0495ccdf1a1712913949390"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ab98a471c4b1aec557583e674beacd15be4955d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ab98a471c4b1aec557583e674beacd15be4955d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ab98a471c4b1aec557583e674beacd15be4955d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ab98a471c4b1aec557583e674beacd15be4955d/comments", "author": null, "committer": null, "parents": [{"sha": "4dddfc74f331653b453b9123ecf3c93a58a9aade", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dddfc74f331653b453b9123ecf3c93a58a9aade", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dddfc74f331653b453b9123ecf3c93a58a9aade"}], "stats": {"total": 10, "additions": 9, "deletions": 1}, "files": [{"sha": "e606bdd4d2452e8667aef22e1b8dcd70d777e59c", "filename": "libgo/runtime/mem.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ab98a471c4b1aec557583e674beacd15be4955d/libgo%2Fruntime%2Fmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ab98a471c4b1aec557583e674beacd15be4955d/libgo%2Fruntime%2Fmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmem.c?ref=3ab98a471c4b1aec557583e674beacd15be4955d", "patch": "@@ -18,6 +18,10 @@\n #endif\n #endif\n \n+#ifndef MAP_NORESERVE\n+#define MAP_NORESERVE 0\n+#endif\n+\n #ifdef USE_DEV_ZERO\n static int dev_zero = -1;\n #endif\n@@ -134,7 +138,11 @@ runtime_SysReserve(void *v, uintptr n)\n \t\treturn v;\n \t}\n \t\n-\tp = runtime_mmap(v, n, PROT_NONE, MAP_ANON|MAP_PRIVATE, fd, 0);\n+\t// Use the MAP_NORESERVE mmap() flag here because typically most of\n+\t// this reservation will never be used. It does not make sense\n+\t// reserve a huge amount of unneeded swap space. This is important on\n+\t// systems which do not overcommit memory by default.\n+\tp = runtime_mmap(v, n, PROT_NONE, MAP_ANON|MAP_PRIVATE|MAP_NORESERVE, fd, 0);\n \tif(p == MAP_FAILED)\n \t\treturn nil;\n \treturn p;"}]}