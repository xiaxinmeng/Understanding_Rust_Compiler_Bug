{"sha": "e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgxNTg4N2Y0ZDdlM2FhYThlNjg1ODQ3MjljMThjOWIzYzVmZWYwNQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-04-28T00:21:06Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-04-28T00:21:06Z"}, "message": "re GNATS gcj/2 (Method call on null instance should throw NullPointerException)\n\n\tFix for PR gcj/2:\n\t* expr.c (expand_invoke): Generate check to see if object pointer\n\tis null in nonvirtual invocation case.\n\t* java-tree.h (soft_nullpointer_node): Declare.\n\t* decl.c (soft_nullpointer_node): New global.\n\t(init_decl_processing): Initialize soft_nullpointer_node.\n\t* parse.y (invocation_mode): Return INVOKE_NONVIRTUAL for `final'\n\tor `private' methods.\n\t(patch_invoke): Handle INVOKE_NONVIRTUAL case.\n\nFrom-SVN: r33495", "tree": {"sha": "8b68598e702242c042747ef9d9b00aed4e7d7ab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b68598e702242c042747ef9d9b00aed4e7d7ab0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/comments", "author": null, "committer": null, "parents": [{"sha": "db6a1df0e0f18a86827e97092fa1293adcc2e89e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db6a1df0e0f18a86827e97092fa1293adcc2e89e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db6a1df0e0f18a86827e97092fa1293adcc2e89e"}], "stats": {"total": 577, "additions": 326, "deletions": 251}, "files": [{"sha": "2f9190e109683e7f885c93c33549c1435a6dc16a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "patch": "@@ -1,3 +1,15 @@\n+2000-04-27  Tom Tromey  <tromey@cygnus.com>\n+\n+\tFix for PR gcj/2:\n+\t* expr.c (expand_invoke): Generate check to see if object pointer\n+\tis null in nonvirtual invocation case.\n+\t* java-tree.h (soft_nullpointer_node): Declare.\n+\t* decl.c (soft_nullpointer_node): New global.\n+\t(init_decl_processing): Initialize soft_nullpointer_node.\n+\t* parse.y (invocation_mode): Return INVOKE_NONVIRTUAL for `final'\n+\tor `private' methods.\n+\t(patch_invoke): Handle INVOKE_NONVIRTUAL case.\n+\n Wed Apr 26 14:29:33 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* decl.c (complete_start_java_method): Don't call _Jv_InitClass"}, {"sha": "385a8aa03ffdd4410c882a3d8d7357bd30840cda", "filename": "gcc/java/decl.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "patch": "@@ -375,6 +375,7 @@ tree soft_newarray_node;\n tree soft_anewarray_node;\n tree soft_multianewarray_node;\n tree soft_badarrayindex_node;\n+tree soft_nullpointer_node;\n tree throw_node [2];\n tree soft_checkarraystore_node;\n tree soft_monitorenter_node;\n@@ -813,6 +814,15 @@ init_decl_processing ()\n   TREE_THIS_VOLATILE (soft_badarrayindex_node) = 1;\n   TREE_SIDE_EFFECTS (soft_badarrayindex_node) = 1;\n \n+  soft_nullpointer_node\n+    = builtin_function (\"_Jv_ThrowNullPointerException\",\n+\t\t\tbuild_function_type (void_type_node, endlink),\n+\t\t\t0, NOT_BUILT_IN, NULL_PTR);\n+  /* Mark soft_nullpointer_node as a `noreturn' function with side\n+     effects.  */\n+  TREE_THIS_VOLATILE (soft_nullpointer_node) = 1;\n+  TREE_SIDE_EFFECTS (soft_nullpointer_node) = 1;\n+\n   t = tree_cons (NULL_TREE, class_ptr_type,\n \t\t tree_cons (NULL_TREE, object_ptr_type_node, endlink));\n   soft_checkcast_node"}, {"sha": "5666502605ef4a161ca9f8a3bd95ad4b6477c1eb", "filename": "gcc/java/expr.c", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "patch": "@@ -1719,6 +1719,7 @@ expand_invoke (opcode, method_ref_index, nargs)\n     (current_jcf, COMPONENT_REF_CLASS_INDEX(&current_jcf->cpool, method_ref_index));\n   const char *self_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n   tree call, func, method, arg_list, method_type;\n+  tree cond = NULL_TREE;\n \n   if (! CLASS_LOADED_P (self_type))\n     {\n@@ -1781,13 +1782,29 @@ expand_invoke (opcode, method_ref_index, nargs)\n   flush_quick_stack ();\n \n   func = NULL_TREE;\n-  if (opcode == OPCODE_invokestatic || opcode == OPCODE_invokespecial\n-      || (opcode == OPCODE_invokevirtual\n-\t  && (METHOD_PRIVATE (method)\n-\t      || METHOD_FINAL (method) \n-\t      || CLASS_FINAL (TYPE_NAME (self_type)))))\n+  if (opcode == OPCODE_invokestatic)\n     func = build_known_method_ref (method, method_type, self_type,\n \t\t\t\t   method_signature, arg_list);\n+  else if (opcode == OPCODE_invokespecial\n+\t   || (opcode == OPCODE_invokevirtual\n+\t       && (METHOD_PRIVATE (method)\n+\t\t   || METHOD_FINAL (method) \n+\t\t   || CLASS_FINAL (TYPE_NAME (self_type)))))\n+    {\n+      /* If the object for the method call is null, we throw an\n+\t exception.  We don't do this if the object is the current\n+\t method's `this'.  In other cases we just rely on an\n+\t optimization pass to eliminate redundant checks.  FIXME:\n+\t Unfortunately there doesn't seem to be a way to determine\n+\t what the current method is right now.  */\n+      /* We use a SAVE_EXPR here to make sure we only evaluate\n+\t the new `self' expression once.  */\n+      tree save_arg = save_expr (TREE_VALUE (arg_list));\n+      TREE_VALUE (arg_list) = save_arg;\n+      cond = build (EQ_EXPR, boolean_type_node, save_arg, null_pointer_node);\n+      func = build_known_method_ref (method, method_type, self_type,\n+\t\t\t\t     method_signature, arg_list);\n+    }\n   else\n     {\n       tree dtable = invoke_build_dtable (opcode == OPCODE_invokeinterface, \n@@ -1801,6 +1818,23 @@ expand_invoke (opcode, method_ref_index, nargs)\n   call = build (CALL_EXPR, TREE_TYPE (method_type), func, arg_list, NULL_TREE);\n   TREE_SIDE_EFFECTS (call) = 1;\n \n+  if (cond != NULL_TREE)\n+    {\n+      /* We have to make the `then' branch a compound expression to\n+\t make the types turn out right.  This seems bizarre.  */\n+      call = build (COND_EXPR, TREE_TYPE (call), cond,\n+\t\t    build (COMPOUND_EXPR, TREE_TYPE (call),\n+\t\t\t   build (CALL_EXPR, void_type_node,\n+\t\t\t\t  build_address_of (soft_nullpointer_node),\n+\t\t\t\t  NULL_TREE, NULL_TREE),\n+\t\t\t   (FLOAT_TYPE_P (TREE_TYPE (call))\n+\t\t\t    ? build_real (TREE_TYPE (call), dconst0)\n+\t\t\t    : build1 (CONVERT_EXPR, TREE_TYPE (call),\n+\t\t\t\t      integer_zero_node))),\n+\t\t    call);\n+      TREE_SIDE_EFFECTS (call) = 1;\n+    }\n+\n   if (TREE_CODE (TREE_TYPE (method_type)) == VOID_TYPE)\n     expand_expr_stmt (call);\n   else"}, {"sha": "5e56a17da3299a585398a14dae461ff15ac00eab", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "patch": "@@ -290,6 +290,7 @@ extern tree soft_newarray_node;\n extern tree soft_anewarray_node;\n extern tree soft_multianewarray_node;\n extern tree soft_badarrayindex_node;\n+extern tree soft_nullpointer_node;\n extern tree throw_node[];\n extern tree soft_checkarraystore_node;\n extern tree soft_monitorenter_node;"}, {"sha": "f426eb984b1d5955e62061d36fdd8e84b6d8f3c7", "filename": "gcc/java/parse.c", "status": "modified", "additions": 214, "deletions": 238, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "patch": "@@ -1,6 +1,7 @@\n \n /*  A Bison parser, made from ./parse.y\n-    by GNU Bison version 1.28  */\n+ by  GNU Bison version 1.25\n+  */\n \n #define YYBISON 1  /* Identify Bison output.  */\n \n@@ -11,113 +12,113 @@\n #define yychar java_char\n #define yydebug java_debug\n #define yynerrs java_nerrs\n-#define\tPLUS_TK\t257\n-#define\tMINUS_TK\t258\n-#define\tMULT_TK\t259\n-#define\tDIV_TK\t260\n-#define\tREM_TK\t261\n-#define\tLS_TK\t262\n-#define\tSRS_TK\t263\n-#define\tZRS_TK\t264\n-#define\tAND_TK\t265\n-#define\tXOR_TK\t266\n-#define\tOR_TK\t267\n-#define\tBOOL_AND_TK\t268\n-#define\tBOOL_OR_TK\t269\n-#define\tEQ_TK\t270\n-#define\tNEQ_TK\t271\n-#define\tGT_TK\t272\n-#define\tGTE_TK\t273\n-#define\tLT_TK\t274\n-#define\tLTE_TK\t275\n-#define\tPLUS_ASSIGN_TK\t276\n-#define\tMINUS_ASSIGN_TK\t277\n-#define\tMULT_ASSIGN_TK\t278\n-#define\tDIV_ASSIGN_TK\t279\n-#define\tREM_ASSIGN_TK\t280\n-#define\tLS_ASSIGN_TK\t281\n-#define\tSRS_ASSIGN_TK\t282\n-#define\tZRS_ASSIGN_TK\t283\n-#define\tAND_ASSIGN_TK\t284\n-#define\tXOR_ASSIGN_TK\t285\n-#define\tOR_ASSIGN_TK\t286\n-#define\tPUBLIC_TK\t287\n-#define\tPRIVATE_TK\t288\n-#define\tPROTECTED_TK\t289\n-#define\tSTATIC_TK\t290\n-#define\tFINAL_TK\t291\n-#define\tSYNCHRONIZED_TK\t292\n-#define\tVOLATILE_TK\t293\n-#define\tTRANSIENT_TK\t294\n-#define\tNATIVE_TK\t295\n-#define\tPAD_TK\t296\n-#define\tABSTRACT_TK\t297\n-#define\tMODIFIER_TK\t298\n-#define\tDECR_TK\t299\n-#define\tINCR_TK\t300\n-#define\tDEFAULT_TK\t301\n-#define\tIF_TK\t302\n-#define\tTHROW_TK\t303\n-#define\tBOOLEAN_TK\t304\n-#define\tDO_TK\t305\n-#define\tIMPLEMENTS_TK\t306\n-#define\tTHROWS_TK\t307\n-#define\tBREAK_TK\t308\n-#define\tIMPORT_TK\t309\n-#define\tELSE_TK\t310\n-#define\tINSTANCEOF_TK\t311\n-#define\tRETURN_TK\t312\n-#define\tVOID_TK\t313\n-#define\tCATCH_TK\t314\n-#define\tINTERFACE_TK\t315\n-#define\tCASE_TK\t316\n-#define\tEXTENDS_TK\t317\n-#define\tFINALLY_TK\t318\n-#define\tSUPER_TK\t319\n-#define\tWHILE_TK\t320\n-#define\tCLASS_TK\t321\n-#define\tSWITCH_TK\t322\n-#define\tCONST_TK\t323\n-#define\tTRY_TK\t324\n-#define\tFOR_TK\t325\n-#define\tNEW_TK\t326\n-#define\tCONTINUE_TK\t327\n-#define\tGOTO_TK\t328\n-#define\tPACKAGE_TK\t329\n-#define\tTHIS_TK\t330\n-#define\tBYTE_TK\t331\n-#define\tSHORT_TK\t332\n-#define\tINT_TK\t333\n-#define\tLONG_TK\t334\n-#define\tCHAR_TK\t335\n-#define\tINTEGRAL_TK\t336\n-#define\tFLOAT_TK\t337\n-#define\tDOUBLE_TK\t338\n-#define\tFP_TK\t339\n-#define\tID_TK\t340\n-#define\tREL_QM_TK\t341\n-#define\tREL_CL_TK\t342\n-#define\tNOT_TK\t343\n-#define\tNEG_TK\t344\n-#define\tASSIGN_ANY_TK\t345\n-#define\tASSIGN_TK\t346\n-#define\tOP_TK\t347\n-#define\tCP_TK\t348\n-#define\tOCB_TK\t349\n-#define\tCCB_TK\t350\n-#define\tOSB_TK\t351\n-#define\tCSB_TK\t352\n-#define\tSC_TK\t353\n-#define\tC_TK\t354\n-#define\tDOT_TK\t355\n-#define\tSTRING_LIT_TK\t356\n-#define\tCHAR_LIT_TK\t357\n-#define\tINT_LIT_TK\t358\n-#define\tFP_LIT_TK\t359\n-#define\tTRUE_TK\t360\n-#define\tFALSE_TK\t361\n-#define\tBOOL_LIT_TK\t362\n-#define\tNULL_TK\t363\n+#define\tPLUS_TK\t258\n+#define\tMINUS_TK\t259\n+#define\tMULT_TK\t260\n+#define\tDIV_TK\t261\n+#define\tREM_TK\t262\n+#define\tLS_TK\t263\n+#define\tSRS_TK\t264\n+#define\tZRS_TK\t265\n+#define\tAND_TK\t266\n+#define\tXOR_TK\t267\n+#define\tOR_TK\t268\n+#define\tBOOL_AND_TK\t269\n+#define\tBOOL_OR_TK\t270\n+#define\tEQ_TK\t271\n+#define\tNEQ_TK\t272\n+#define\tGT_TK\t273\n+#define\tGTE_TK\t274\n+#define\tLT_TK\t275\n+#define\tLTE_TK\t276\n+#define\tPLUS_ASSIGN_TK\t277\n+#define\tMINUS_ASSIGN_TK\t278\n+#define\tMULT_ASSIGN_TK\t279\n+#define\tDIV_ASSIGN_TK\t280\n+#define\tREM_ASSIGN_TK\t281\n+#define\tLS_ASSIGN_TK\t282\n+#define\tSRS_ASSIGN_TK\t283\n+#define\tZRS_ASSIGN_TK\t284\n+#define\tAND_ASSIGN_TK\t285\n+#define\tXOR_ASSIGN_TK\t286\n+#define\tOR_ASSIGN_TK\t287\n+#define\tPUBLIC_TK\t288\n+#define\tPRIVATE_TK\t289\n+#define\tPROTECTED_TK\t290\n+#define\tSTATIC_TK\t291\n+#define\tFINAL_TK\t292\n+#define\tSYNCHRONIZED_TK\t293\n+#define\tVOLATILE_TK\t294\n+#define\tTRANSIENT_TK\t295\n+#define\tNATIVE_TK\t296\n+#define\tPAD_TK\t297\n+#define\tABSTRACT_TK\t298\n+#define\tMODIFIER_TK\t299\n+#define\tDECR_TK\t300\n+#define\tINCR_TK\t301\n+#define\tDEFAULT_TK\t302\n+#define\tIF_TK\t303\n+#define\tTHROW_TK\t304\n+#define\tBOOLEAN_TK\t305\n+#define\tDO_TK\t306\n+#define\tIMPLEMENTS_TK\t307\n+#define\tTHROWS_TK\t308\n+#define\tBREAK_TK\t309\n+#define\tIMPORT_TK\t310\n+#define\tELSE_TK\t311\n+#define\tINSTANCEOF_TK\t312\n+#define\tRETURN_TK\t313\n+#define\tVOID_TK\t314\n+#define\tCATCH_TK\t315\n+#define\tINTERFACE_TK\t316\n+#define\tCASE_TK\t317\n+#define\tEXTENDS_TK\t318\n+#define\tFINALLY_TK\t319\n+#define\tSUPER_TK\t320\n+#define\tWHILE_TK\t321\n+#define\tCLASS_TK\t322\n+#define\tSWITCH_TK\t323\n+#define\tCONST_TK\t324\n+#define\tTRY_TK\t325\n+#define\tFOR_TK\t326\n+#define\tNEW_TK\t327\n+#define\tCONTINUE_TK\t328\n+#define\tGOTO_TK\t329\n+#define\tPACKAGE_TK\t330\n+#define\tTHIS_TK\t331\n+#define\tBYTE_TK\t332\n+#define\tSHORT_TK\t333\n+#define\tINT_TK\t334\n+#define\tLONG_TK\t335\n+#define\tCHAR_TK\t336\n+#define\tINTEGRAL_TK\t337\n+#define\tFLOAT_TK\t338\n+#define\tDOUBLE_TK\t339\n+#define\tFP_TK\t340\n+#define\tID_TK\t341\n+#define\tREL_QM_TK\t342\n+#define\tREL_CL_TK\t343\n+#define\tNOT_TK\t344\n+#define\tNEG_TK\t345\n+#define\tASSIGN_ANY_TK\t346\n+#define\tASSIGN_TK\t347\n+#define\tOP_TK\t348\n+#define\tCP_TK\t349\n+#define\tOCB_TK\t350\n+#define\tCCB_TK\t351\n+#define\tOSB_TK\t352\n+#define\tCSB_TK\t353\n+#define\tSC_TK\t354\n+#define\tC_TK\t355\n+#define\tDOT_TK\t356\n+#define\tSTRING_LIT_TK\t357\n+#define\tCHAR_LIT_TK\t358\n+#define\tINT_LIT_TK\t359\n+#define\tFP_LIT_TK\t360\n+#define\tTRUE_TK\t361\n+#define\tFALSE_TK\t362\n+#define\tBOOL_LIT_TK\t363\n+#define\tNULL_TK\t364\n \n #line 48 \"./parse.y\"\n \n@@ -516,7 +517,7 @@ typedef union {\n #define\tYYFLAG\t\t-32768\n #define\tYYNTBASE\t110\n \n-#define YYTRANSLATE(x) ((unsigned)(x) <= 363 ? yytranslate[x] : 272)\n+#define YYTRANSLATE(x) ((unsigned)(x) <= 364 ? yytranslate[x] : 272)\n \n static const char yytranslate[] = {     0,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n@@ -544,18 +545,18 @@ static const char yytranslate[] = {     0,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,\n-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,\n-    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,\n-    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n-    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,\n-    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n-    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,\n-    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,\n-    77,    78,    79,    80,    81,    82,    83,    84,    85,    86,\n-    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,\n-    97,    98,    99,   100,   101,   102,   103,   104,   105,   106,\n-   107,   108,   109\n+     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,\n+     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,\n+    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,\n+    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,\n+    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,\n+    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,\n+    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,\n+    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,\n+    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,\n+    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,\n+    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,\n+   106,   107,   108,   109\n };\n \n #if YYDEBUG != 0\n@@ -2386,8 +2387,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/lib/bison.simple\"\n-/* This file comes from bison-1.28.  */\n+#line 3 \"/usr/share/misc/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2404,66 +2404,46 @@ static const short yycheck[] = {     3,\n \n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n-   Foundation, Inc., 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n /* As a special exception, when this file is copied by Bison into a\n    Bison output file, you may use that output file without restriction.\n    This special exception was added by the Free Software Foundation\n    in version 1.24 of Bison.  */\n \n-/* This is the parser code that is written into each bison parser\n-  when the %semantic_parser declaration is not specified in the grammar.\n-  It was written by Richard Stallman by simplifying the hairy parser\n-  used when %semantic_parser is specified.  */\n-\n-#ifndef YYSTACK_USE_ALLOCA\n-#ifdef alloca\n-#define YYSTACK_USE_ALLOCA\n-#else /* alloca not defined */\n+#ifndef alloca\n #ifdef __GNUC__\n-#define YYSTACK_USE_ALLOCA\n #define alloca __builtin_alloca\n #else /* not GNU C.  */\n-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))\n-#define YYSTACK_USE_ALLOCA\n+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)\n #include <alloca.h>\n #else /* not sparc */\n-/* We think this test detects Watcom and Microsoft C.  */\n-/* This used to test MSDOS, but that is a bad idea\n-   since that symbol is in the user namespace.  */\n-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)\n-#if 0 /* No need for malloc.h, which pollutes the namespace;\n-\t instead, just don't use alloca.  */\n+#if defined (MSDOS) && !defined (__TURBOC__)\n #include <malloc.h>\n-#endif\n #else /* not MSDOS, or __TURBOC__ */\n #if defined(_AIX)\n-/* I don't know what this was needed for, but it pollutes the namespace.\n-   So I turned it off.   rms, 2 May 1997.  */\n-/* #include <malloc.h>  */\n+#include <malloc.h>\n  #pragma alloca\n-#define YYSTACK_USE_ALLOCA\n-#else /* not MSDOS, or __TURBOC__, or _AIX */\n-#if 0\n-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,\n-\t\t and on HPUX 10.  Eventually we can turn this on.  */\n-#define YYSTACK_USE_ALLOCA\n-#define alloca __builtin_alloca\n+#else /* not MSDOS, __TURBOC__, or _AIX */\n+#ifdef __hpux\n+#ifdef __cplusplus\n+extern \"C\" {\n+void *alloca (unsigned int);\n+};\n+#else /* not __cplusplus */\n+void *alloca ();\n+#endif /* not __cplusplus */\n #endif /* __hpux */\n-#endif\n #endif /* not _AIX */\n #endif /* not MSDOS, or __TURBOC__ */\n-#endif /* not sparc */\n-#endif /* not GNU C */\n-#endif /* alloca not defined */\n-#endif /* YYSTACK_USE_ALLOCA not defined */\n+#endif /* not sparc.  */\n+#endif /* not GNU C.  */\n+#endif /* alloca not defined.  */\n \n-#ifdef YYSTACK_USE_ALLOCA\n-#define YYSTACK_ALLOC alloca\n-#else\n-#define YYSTACK_ALLOC malloc\n-#endif\n+/* This is the parser code that is written into each bison parser\n+  when the %semantic_parser declaration is not specified in the grammar.\n+  It was written by Richard Stallman by simplifying the hairy parser\n+  used when %semantic_parser is specified.  */\n \n /* Note: there must be only one dollar sign in this file.\n    It is replaced by the list of actions, each action\n@@ -2473,8 +2453,8 @@ static const short yycheck[] = {     3,\n #define yyclearin\t(yychar = YYEMPTY)\n #define YYEMPTY\t\t-2\n #define YYEOF\t\t0\n-#define YYACCEPT\tgoto yyacceptlab\n-#define YYABORT \tgoto yyabortlab\n+#define YYACCEPT\treturn(0)\n+#define YYABORT \treturn(1)\n #define YYERROR\t\tgoto yyerrlab1\n /* Like YYERROR except do call yyerror.\n    This remains here temporarily to ease the\n@@ -2555,12 +2535,14 @@ int yydebug;\t\t\t/*  nonzero means print parse trace\t*/\n #ifndef YYMAXDEPTH\n #define YYMAXDEPTH 10000\n #endif\n-\f\n-/* Define __yy_memcpy.  Note that the size argument\n-   should be passed with type unsigned int, because that is what the non-GCC\n-   definitions require.  With GCC, __builtin_memcpy takes an arg\n-   of type size_t, but it can handle unsigned int.  */\n \n+/* Prevent warning if -Wstrict-prototypes.  */\n+#ifdef __GNUC__\n+#ifndef YYPARSE_PARAM\n+int yyparse (void);\n+#endif\n+#endif\n+\f\n #if __GNUC__ > 1\t\t/* GNU C and GNU C++ define this.  */\n #define __yy_memcpy(TO,FROM,COUNT)\t__builtin_memcpy(TO,FROM,COUNT)\n #else\t\t\t\t/* not GNU C or C++ */\n@@ -2572,7 +2554,7 @@ static void\n __yy_memcpy (to, from, count)\n      char *to;\n      char *from;\n-     unsigned int count;\n+     int count;\n {\n   register char *f = from;\n   register char *t = to;\n@@ -2587,10 +2569,10 @@ __yy_memcpy (to, from, count)\n /* This is the most reliable way to avoid incompatibilities\n    in available built-in functions on various systems.  */\n static void\n-__yy_memcpy (char *to, char *from, unsigned int count)\n+__yy_memcpy (char *to, char *from, int count)\n {\n-  register char *t = to;\n   register char *f = from;\n+  register char *t = to;\n   register int i = count;\n \n   while (i-- > 0)\n@@ -2600,7 +2582,7 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #endif\n #endif\n \f\n-#line 217 \"/usr/lib/bison.simple\"\n+#line 196 \"/usr/share/misc/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -2621,15 +2603,6 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #define YYPARSE_PARAM_DECL\n #endif /* not YYPARSE_PARAM */\n \n-/* Prevent warning if -Wstrict-prototypes.  */\n-#ifdef __GNUC__\n-#ifdef YYPARSE_PARAM\n-int yyparse (void *);\n-#else\n-int yyparse (void);\n-#endif\n-#endif\n-\n int\n yyparse(YYPARSE_PARAM_ARG)\n      YYPARSE_PARAM_DECL\n@@ -2658,7 +2631,6 @@ yyparse(YYPARSE_PARAM_ARG)\n #endif\n \n   int yystacksize = YYINITDEPTH;\n-  int yyfree_stacks = 0;\n \n #ifdef YYPURE\n   int yychar;\n@@ -2743,32 +2715,18 @@ yyparse(YYPARSE_PARAM_ARG)\n       if (yystacksize >= YYMAXDEPTH)\n \t{\n \t  yyerror(\"parser stack overflow\");\n-\t  if (yyfree_stacks)\n-\t    {\n-\t      free (yyss);\n-\t      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-\t      free (yyls);\n-#endif\n-\t    }\n \t  return 2;\n \t}\n       yystacksize *= 2;\n       if (yystacksize > YYMAXDEPTH)\n \tyystacksize = YYMAXDEPTH;\n-#ifndef YYSTACK_USE_ALLOCA\n-      yyfree_stacks = 1;\n-#endif\n-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));\n-      __yy_memcpy ((char *)yyss, (char *)yyss1,\n-\t\t   size * (unsigned int) sizeof (*yyssp));\n-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));\n-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,\n-\t\t   size * (unsigned int) sizeof (*yyvsp));\n+      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));\n+      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));\n+      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));\n+      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));\n #ifdef YYLSP_NEEDED\n-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));\n-      __yy_memcpy ((char *)yyls, (char *)yyls1,\n-\t\t   size * (unsigned int) sizeof (*yylsp));\n+      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));\n+      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));\n #endif\n #endif /* no yyoverflow */\n \n@@ -5020,7 +4978,7 @@ case 503:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 543 \"/usr/lib/bison.simple\"\n+#line 498 \"/usr/share/misc/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -5215,30 +5173,6 @@ case 503:\n \n   yystate = yyn;\n   goto yynewstate;\n-\n- yyacceptlab:\n-  /* YYACCEPT comes here.  */\n-  if (yyfree_stacks)\n-    {\n-      free (yyss);\n-      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-      free (yyls);\n-#endif\n-    }\n-  return 0;\n-\n- yyabortlab:\n-  /* YYABORT comes here.  */\n-  if (yyfree_stacks)\n-    {\n-      free (yyss);\n-      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-      free (yyls);\n-#endif\n-    }\n-  return 1;\n }\n #line 2546 \"./parse.y\"\n \n@@ -12360,10 +12294,11 @@ patch_invoke (patch, method, args)\n {\n   tree dtable, func;\n   tree original_call, t, ta;\n+  tree cond = NULL_TREE;\n \n   /* Last step for args: convert build-in types. If we're dealing with\n      a new TYPE() type call, the first argument to the constructor\n-     isn't found in the incomming argument list, but delivered by\n+     isn't found in the incoming argument list, but delivered by\n      `new' */\n   t = TYPE_ARG_TYPES (TREE_TYPE (method));\n   if (TREE_CODE (patch) == NEW_CLASS_EXPR)\n@@ -12391,6 +12326,22 @@ patch_invoke (patch, method, args)\n \t  func = build_invokevirtual (dtable, method);\n \t  break;\n \n+\tcase INVOKE_NONVIRTUAL:\n+\t  /* If the object for the method call is null, we throw an\n+\t     exception.  We don't do this if the object is the current\n+\t     method's `this'.  In other cases we just rely on an\n+\t     optimization pass to eliminate redundant checks.  */\n+\t  if (TREE_VALUE (args) != current_this)\n+\t    {\n+\t      /* We use a SAVE_EXPR here to make sure we only evaluate\n+\t\t the new `self' expression once.  */\n+\t      tree save_arg = save_expr (TREE_VALUE (args));\n+\t      TREE_VALUE (args) = save_arg;\n+\t      cond = build (EQ_EXPR, boolean_type_node, save_arg,\n+\t\t\t    null_pointer_node);\n+\t    }\n+\t  /* Fall through.  */\n+\n \tcase INVOKE_SUPER:\n \tcase INVOKE_STATIC:\n \t  func = build_known_method_ref (method, TREE_TYPE (method),\n@@ -12416,7 +12367,7 @@ patch_invoke (patch, method, args)\n   TREE_OPERAND (patch, 1) = args;\n   original_call = patch;\n \n-  /* We're processing a `new TYPE ()' form. New is called an its\n+  /* We're processing a `new TYPE ()' form. New is called and its\n      returned value is the first argument to the constructor. We build\n      a COMPOUND_EXPR and use saved expression so that the overall NEW\n      expression value is a pointer to a newly created and initialized\n@@ -12446,6 +12397,26 @@ patch_invoke (patch, method, args)\n       TREE_SET_CODE (original_call, CALL_EXPR);\n       patch = build (COMPOUND_EXPR, TREE_TYPE (new), patch, saved_new);\n     }\n+\n+  /* If COND is set, then we are building a check to see if the object\n+     is NULL.  */\n+  if (cond != NULL_TREE)\n+    {\n+      /* We have to make the `then' branch a compound expression to\n+\t make the types turn out right.  This seems bizarre.  */\n+      patch = build (COND_EXPR, TREE_TYPE (patch), cond,\n+\t\t     build (COMPOUND_EXPR, TREE_TYPE (patch),\n+\t\t\t    build (CALL_EXPR, void_type_node,\n+\t\t\t\t   build_address_of (soft_nullpointer_node),\n+\t\t\t\t   NULL_TREE, NULL_TREE),\n+\t\t\t    (FLOAT_TYPE_P (TREE_TYPE (patch))\n+\t\t\t     ? build_real (TREE_TYPE (patch), dconst0)\n+\t\t\t     : build1 (CONVERT_EXPR, TREE_TYPE (patch),\n+\t\t\t\t       integer_zero_node))),\n+\t\t     patch);\n+      TREE_SIDE_EFFECTS (patch) = 1;\n+    }\n+\n   return patch;\n }\n \n@@ -12459,17 +12430,22 @@ invocation_mode (method, super)\n   if (super)\n     return INVOKE_SUPER;\n \n-  if (access & ACC_STATIC || access & ACC_FINAL || access & ACC_PRIVATE)\n+  if (access & ACC_STATIC)\n     return INVOKE_STATIC;\n \n-  if (CLASS_FINAL (TYPE_NAME (DECL_CONTEXT (method))))\n+  /* We have to look for a constructor before we handle nonvirtual\n+     calls; otherwise the constructor will look nonvirtual.  */\n+  if (DECL_CONSTRUCTOR_P (method))\n     return INVOKE_STATIC;\n-  \n+\n+  if (access & ACC_FINAL || access & ACC_PRIVATE)\n+    return INVOKE_NONVIRTUAL;\n+\n+  if (CLASS_FINAL (TYPE_NAME (DECL_CONTEXT (method))))\n+    return INVOKE_NONVIRTUAL;\n+\n   if (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))))\n     return INVOKE_INTERFACE;\n-  \n-  if (DECL_CONSTRUCTOR_P (method))\n-    return INVOKE_STATIC;\n \n   return INVOKE_VIRTUAL;\n }"}, {"sha": "576e624c9ff5f1a744dc208fa95790fc286a4050", "filename": "gcc/java/parse.y", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e815887f4d7e3aaa8e68584729c18c9b3c5fef05/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=e815887f4d7e3aaa8e68584729c18c9b3c5fef05", "patch": "@@ -9662,10 +9662,11 @@ patch_invoke (patch, method, args)\n {\n   tree dtable, func;\n   tree original_call, t, ta;\n+  tree cond = NULL_TREE;\n \n   /* Last step for args: convert build-in types. If we're dealing with\n      a new TYPE() type call, the first argument to the constructor\n-     isn't found in the incomming argument list, but delivered by\n+     isn't found in the incoming argument list, but delivered by\n      `new' */\n   t = TYPE_ARG_TYPES (TREE_TYPE (method));\n   if (TREE_CODE (patch) == NEW_CLASS_EXPR)\n@@ -9693,6 +9694,22 @@ patch_invoke (patch, method, args)\n \t  func = build_invokevirtual (dtable, method);\n \t  break;\n \n+\tcase INVOKE_NONVIRTUAL:\n+\t  /* If the object for the method call is null, we throw an\n+\t     exception.  We don't do this if the object is the current\n+\t     method's `this'.  In other cases we just rely on an\n+\t     optimization pass to eliminate redundant checks.  */\n+\t  if (TREE_VALUE (args) != current_this)\n+\t    {\n+\t      /* We use a SAVE_EXPR here to make sure we only evaluate\n+\t\t the new `self' expression once.  */\n+\t      tree save_arg = save_expr (TREE_VALUE (args));\n+\t      TREE_VALUE (args) = save_arg;\n+\t      cond = build (EQ_EXPR, boolean_type_node, save_arg,\n+\t\t\t    null_pointer_node);\n+\t    }\n+\t  /* Fall through.  */\n+\n \tcase INVOKE_SUPER:\n \tcase INVOKE_STATIC:\n \t  func = build_known_method_ref (method, TREE_TYPE (method),\n@@ -9718,7 +9735,7 @@ patch_invoke (patch, method, args)\n   TREE_OPERAND (patch, 1) = args;\n   original_call = patch;\n \n-  /* We're processing a `new TYPE ()' form. New is called an its\n+  /* We're processing a `new TYPE ()' form. New is called and its\n      returned value is the first argument to the constructor. We build\n      a COMPOUND_EXPR and use saved expression so that the overall NEW\n      expression value is a pointer to a newly created and initialized\n@@ -9748,6 +9765,26 @@ patch_invoke (patch, method, args)\n       TREE_SET_CODE (original_call, CALL_EXPR);\n       patch = build (COMPOUND_EXPR, TREE_TYPE (new), patch, saved_new);\n     }\n+\n+  /* If COND is set, then we are building a check to see if the object\n+     is NULL.  */\n+  if (cond != NULL_TREE)\n+    {\n+      /* We have to make the `then' branch a compound expression to\n+\t make the types turn out right.  This seems bizarre.  */\n+      patch = build (COND_EXPR, TREE_TYPE (patch), cond,\n+\t\t     build (COMPOUND_EXPR, TREE_TYPE (patch),\n+\t\t\t    build (CALL_EXPR, void_type_node,\n+\t\t\t\t   build_address_of (soft_nullpointer_node),\n+\t\t\t\t   NULL_TREE, NULL_TREE),\n+\t\t\t    (FLOAT_TYPE_P (TREE_TYPE (patch))\n+\t\t\t     ? build_real (TREE_TYPE (patch), dconst0)\n+\t\t\t     : build1 (CONVERT_EXPR, TREE_TYPE (patch),\n+\t\t\t\t       integer_zero_node))),\n+\t\t     patch);\n+      TREE_SIDE_EFFECTS (patch) = 1;\n+    }\n+\n   return patch;\n }\n \n@@ -9761,17 +9798,22 @@ invocation_mode (method, super)\n   if (super)\n     return INVOKE_SUPER;\n \n-  if (access & ACC_STATIC || access & ACC_FINAL || access & ACC_PRIVATE)\n+  if (access & ACC_STATIC)\n     return INVOKE_STATIC;\n \n-  if (CLASS_FINAL (TYPE_NAME (DECL_CONTEXT (method))))\n+  /* We have to look for a constructor before we handle nonvirtual\n+     calls; otherwise the constructor will look nonvirtual.  */\n+  if (DECL_CONSTRUCTOR_P (method))\n     return INVOKE_STATIC;\n-  \n+\n+  if (access & ACC_FINAL || access & ACC_PRIVATE)\n+    return INVOKE_NONVIRTUAL;\n+\n+  if (CLASS_FINAL (TYPE_NAME (DECL_CONTEXT (method))))\n+    return INVOKE_NONVIRTUAL;\n+\n   if (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))))\n     return INVOKE_INTERFACE;\n-  \n-  if (DECL_CONSTRUCTOR_P (method))\n-    return INVOKE_STATIC;\n \n   return INVOKE_VIRTUAL;\n }"}]}