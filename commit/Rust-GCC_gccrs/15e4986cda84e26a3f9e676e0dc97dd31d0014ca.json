{"sha": "15e4986cda84e26a3f9e676e0dc97dd31d0014ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlNDk4NmNkYTg0ZTI2YTNmOWU2NzZlMGRjOTdkZDMxZDAwMTRjYQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2008-07-31T12:46:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-07-31T12:46:35Z"}, "message": "sem_type.adb (Has_Compatible_Type): Complete support for synchronized types when...\n\n2008-07-31  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_type.adb (Has_Compatible_Type): Complete support for synchronized\n\ttypes when the candidate type is a synchronized type.\n\t\n\t* sem_res.adb (Resolve_Actuals): Reorganize code handling synchronized\n\ttypes, and complete management of synchronized types adding missing\n\tcode to handle formal that is a synchronized type.\n\t\n\t* sem_ch4.adb (Try_Primitive_Operation): Avoid testing attributes that\n\tare not available and cause the compiler to blowup. Found compiling\n\ttest with switch -gnatc\n\t\n\t* sem_ch6.adb (Check_Synchronized_Overriding): Remove local subprogram\n\tHas_Correct_Formal_Mode plus code cleanup.\n\nFrom-SVN: r138400", "tree": {"sha": "d8ab650bb620688a5d3cac9758d6014e6c92838c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8ab650bb620688a5d3cac9758d6014e6c92838c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15e4986cda84e26a3f9e676e0dc97dd31d0014ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e4986cda84e26a3f9e676e0dc97dd31d0014ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e4986cda84e26a3f9e676e0dc97dd31d0014ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e4986cda84e26a3f9e676e0dc97dd31d0014ca/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e84e11ba0a57e5a319504d4f0197aad385f85e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e84e11ba0a57e5a319504d4f0197aad385f85e80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e84e11ba0a57e5a319504d4f0197aad385f85e80"}], "stats": {"total": 193, "additions": 100, "deletions": 93}, "files": [{"sha": "4994ac8d45e4d63f964ccc3343bebf6177c05be6", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e4986cda84e26a3f9e676e0dc97dd31d0014ca/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e4986cda84e26a3f9e676e0dc97dd31d0014ca/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=15e4986cda84e26a3f9e676e0dc97dd31d0014ca", "patch": "@@ -6414,6 +6414,10 @@ package body Sem_Ch4 is\n          --  corresponding record (base) type.\n \n          if Is_Concurrent_Type (Obj_Type) then\n+            if not Present (Corresponding_Record_Type (Obj_Type)) then\n+               return False;\n+            end if;\n+\n             Corr_Type := Base_Type (Corresponding_Record_Type (Obj_Type));\n             Elmt := First_Elmt (Primitive_Operations (Corr_Type));\n "}, {"sha": "33cb73d9a569d7a9941b7a5988941711a51da5cb", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 47, "deletions": 83, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e4986cda84e26a3f9e676e0dc97dd31d0014ca/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e4986cda84e26a3f9e676e0dc97dd31d0014ca/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=15e4986cda84e26a3f9e676e0dc97dd31d0014ca", "patch": "@@ -6599,12 +6599,6 @@ package body Sem_Ch6 is\n          In_Scope    : Boolean;\n          Typ         : Entity_Id;\n \n-         function Has_Correct_Formal_Mode\n-           (Tag_Typ : Entity_Id;\n-            Subp    : Entity_Id) return Boolean;\n-         --  For an overridden subprogram Subp, check whether the mode of its\n-         --  first parameter is correct depending on the kind of Tag_Typ.\n-\n          function Matches_Prefixed_View_Profile\n            (Prim_Params  : List_Id;\n             Iface_Params : List_Id) return Boolean;\n@@ -6613,39 +6607,6 @@ package body Sem_Ch6 is\n          --  Iface_Params. Also determine if the type of first parameter of\n          --  Iface_Params is an implemented interface.\n \n-         -----------------------------\n-         -- Has_Correct_Formal_Mode --\n-         -----------------------------\n-\n-         function Has_Correct_Formal_Mode\n-           (Tag_Typ : Entity_Id;\n-            Subp    : Entity_Id) return Boolean\n-         is\n-            Formal : constant Node_Id := First_Formal (Subp);\n-\n-         begin\n-            --  In order for an entry or a protected procedure to override, the\n-            --  first parameter of the overridden routine must be of mode\n-            --  \"out\", \"in out\" or access-to-variable.\n-\n-            if (Ekind (Subp) = E_Entry\n-                  or else Ekind (Subp) = E_Procedure)\n-              and then Is_Protected_Type (Tag_Typ)\n-              and then Ekind (Formal) /= E_In_Out_Parameter\n-              and then Ekind (Formal) /= E_Out_Parameter\n-              and then Nkind (Parameter_Type (Parent (Formal))) /=\n-                         N_Access_Definition\n-            then\n-               return False;\n-            end if;\n-\n-            --  All other cases are OK since a task entry or routine does not\n-            --  have a restriction on the mode of the first parameter of the\n-            --  overridden interface routine.\n-\n-            return True;\n-         end Has_Correct_Formal_Mode;\n-\n          -----------------------------------\n          -- Matches_Prefixed_View_Profile --\n          -----------------------------------\n@@ -6723,15 +6684,15 @@ package body Sem_Ch6 is\n                Iface_Id  := Defining_Identifier (Iface_Param);\n                Iface_Typ := Find_Parameter_Type (Iface_Param);\n \n-               if Is_Access_Type (Iface_Typ) then\n-                  Iface_Typ := Directly_Designated_Type (Iface_Typ);\n-               end if;\n-\n                Prim_Id  := Defining_Identifier (Prim_Param);\n                Prim_Typ := Find_Parameter_Type (Prim_Param);\n \n-               if Is_Access_Type (Prim_Typ) then\n-                  Prim_Typ := Directly_Designated_Type (Prim_Typ);\n+               if Ekind (Iface_Typ) = E_Anonymous_Access_Type\n+                 and then Ekind (Prim_Typ) = E_Anonymous_Access_Type\n+                 and then Is_Concurrent_Type (Designated_Type (Prim_Typ))\n+               then\n+                  Iface_Typ := Designated_Type (Iface_Typ);\n+                  Prim_Typ := Designated_Type (Prim_Typ);\n                end if;\n \n                --  Case of multiple interface types inside a parameter profile\n@@ -6864,60 +6825,63 @@ package body Sem_Ch6 is\n             while Present (Hom) loop\n                Subp := Hom;\n \n-               --  Entries can override abstract or null interface\n-               --  procedures\n-\n-               if Ekind (Def_Id) = E_Entry\n-                 and then Ekind (Subp) = E_Procedure\n-                 and then Nkind (Parent (Subp)) = N_Procedure_Specification\n-                 and then (Is_Abstract_Subprogram (Subp)\n-                             or else Null_Present (Parent (Subp)))\n+               if Subp = Def_Id\n+                 or else not Is_Overloadable (Subp)\n+                 or else not Is_Primitive (Subp)\n+                 or else not Is_Dispatching_Operation (Subp)\n+                 or else not Is_Interface (Find_Dispatching_Type (Subp))\n                then\n-                  while Present (Alias (Subp)) loop\n-                     Subp := Alias (Subp);\n-                  end loop;\n-\n-                  if Matches_Prefixed_View_Profile\n-                       (Parameter_Specifications (Parent (Def_Id)),\n-                        Parameter_Specifications (Parent (Subp)))\n-                  then\n-                     Candidate := Subp;\n-\n-                     --  Absolute match\n-\n-                     if Has_Correct_Formal_Mode (Typ, Candidate) then\n-                        Overridden_Subp := Candidate;\n-                        return;\n-                     end if;\n-                  end if;\n+                  null;\n \n-               --  Procedures can override abstract or null interface\n-               --  procedures\n+               --  Entries and procedures can override abstract or null\n+               --  interface procedures\n \n-               elsif Ekind (Def_Id) = E_Procedure\n+               elsif (Ekind (Def_Id) = E_Procedure\n+                        or else Ekind (Def_Id) = E_Entry)\n                  and then Ekind (Subp) = E_Procedure\n-                 and then Nkind (Parent (Subp)) = N_Procedure_Specification\n-                 and then (Is_Abstract_Subprogram (Subp)\n-                             or else Null_Present (Parent (Subp)))\n                  and then Matches_Prefixed_View_Profile\n                             (Parameter_Specifications (Parent (Def_Id)),\n                              Parameter_Specifications (Parent (Subp)))\n                then\n                   Candidate := Subp;\n \n-                  --  Absolute match\n+                  --  For an overridden subprogram Subp, check whether the mode\n+                  --  of its first parameter is correct depending on the kind\n+                  --  of synchronized type.\n \n-                  if Has_Correct_Formal_Mode (Typ, Candidate) then\n-                     Overridden_Subp := Candidate;\n-                     return;\n-                  end if;\n+                  declare\n+                     Formal : constant Node_Id := First_Formal (Candidate);\n+\n+                  begin\n+                     --  In order for an entry or a protected procedure to\n+                     --  override, the first parameter of the overridden\n+                     --  routine must be of mode \"out\", \"in out\" or\n+                     --  access-to-variable.\n+\n+                     if (Ekind (Candidate) = E_Entry\n+                         or else Ekind (Candidate) = E_Procedure)\n+                       and then Is_Protected_Type (Typ)\n+                       and then Ekind (Formal) /= E_In_Out_Parameter\n+                       and then Ekind (Formal) /= E_Out_Parameter\n+                       and then Nkind (Parameter_Type (Parent (Formal)))\n+                                  /= N_Access_Definition\n+                     then\n+                        null;\n+\n+                     --  All other cases are OK since a task entry or routine\n+                     --  does not have a restriction on the mode of the first\n+                     --  parameter of the overridden interface routine.\n+\n+                     else\n+                        Overridden_Subp := Candidate;\n+                        return;\n+                     end if;\n+                  end;\n \n                --  Functions can override abstract interface functions\n \n                elsif Ekind (Def_Id) = E_Function\n                  and then Ekind (Subp) = E_Function\n-                 and then Nkind (Parent (Subp)) = N_Function_Specification\n-                 and then Is_Abstract_Subprogram (Subp)\n                  and then Matches_Prefixed_View_Profile\n                             (Parameter_Specifications (Parent (Def_Id)),\n                              Parameter_Specifications (Parent (Subp)))"}, {"sha": "e0118685ea0c5575571e4575ab7dda4701045781", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e4986cda84e26a3f9e676e0dc97dd31d0014ca/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e4986cda84e26a3f9e676e0dc97dd31d0014ca/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=15e4986cda84e26a3f9e676e0dc97dd31d0014ca", "patch": "@@ -3218,16 +3218,48 @@ package body Sem_Res is\n                --   or because it is a generic actual, so use base type to\n                --   locate concurrent type.\n \n-               if Is_Concurrent_Type (Etype (A))\n-                 and then Etype (F) =\n-                            Corresponding_Record_Type (Base_Type (Etype (A)))\n-               then\n-                  Rewrite (A,\n-                    Unchecked_Convert_To\n-                      (Corresponding_Record_Type (Etype (A)), A));\n-               end if;\n+               A_Typ := Base_Type (Etype (A));\n+               F_Typ := Base_Type (Etype (F));\n+\n+               declare\n+                  Full_A_Typ : Entity_Id;\n+\n+               begin\n+                  if Present (Full_View (A_Typ)) then\n+                     Full_A_Typ := Base_Type (Full_View (A_Typ));\n+                  else\n+                     Full_A_Typ := A_Typ;\n+                  end if;\n \n-               Resolve (A, Etype (F));\n+                  --  Tagged synchronized type (case 1): the actual is a\n+                  --  concurrent type\n+\n+                  if Is_Concurrent_Type (A_Typ)\n+                    and then Corresponding_Record_Type (A_Typ) = F_Typ\n+                  then\n+                     Rewrite (A,\n+                       Unchecked_Convert_To\n+                         (Corresponding_Record_Type (A_Typ), A));\n+                     Resolve (A, Etype (F));\n+\n+                  --  Tagged synchronized type (case 2): the formal is a\n+                  --  concurrent type\n+\n+                  elsif Ekind (Full_A_Typ) = E_Record_Type\n+                    and then Present\n+                               (Corresponding_Concurrent_Type (Full_A_Typ))\n+                    and then Is_Concurrent_Type (F_Typ)\n+                    and then Present (Corresponding_Record_Type (F_Typ))\n+                    and then Full_A_Typ = Corresponding_Record_Type (F_Typ)\n+                  then\n+                     Resolve (A, Corresponding_Record_Type (F_Typ));\n+\n+                  --  Common case\n+\n+                  else\n+                     Resolve (A, Etype (F));\n+                  end if;\n+               end;\n             end if;\n \n             A_Typ := Etype (A);"}, {"sha": "aae54d1f67e19e05d7cf6d0756ebe0f4cbd625a6", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e4986cda84e26a3f9e676e0dc97dd31d0014ca/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e4986cda84e26a3f9e676e0dc97dd31d0014ca/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=15e4986cda84e26a3f9e676e0dc97dd31d0014ca", "patch": "@@ -2106,10 +2106,17 @@ package body Sem_Type is\n             --  to check whether it is a proper descendant.\n \n            or else\n-             (Is_Concurrent_Type (Etype (N))\n+             (Is_Record_Type (Typ)\n+                and then Is_Concurrent_Type (Etype (N))\n                 and then Present (Corresponding_Record_Type (Etype (N)))\n                 and then Covers (Typ, Corresponding_Record_Type (Etype (N))))\n \n+           or else\n+             (Is_Concurrent_Type (Typ)\n+                and then Is_Record_Type (Etype (N))\n+                and then Present (Corresponding_Record_Type (Typ))\n+                and then Covers (Corresponding_Record_Type (Typ), Etype (N)))\n+\n            or else\n              (not Is_Tagged_Type (Typ)\n                 and then Ekind (Typ) /= E_Anonymous_Access_Type"}]}