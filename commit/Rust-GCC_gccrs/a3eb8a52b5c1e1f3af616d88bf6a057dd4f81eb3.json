{"sha": "a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNlYjhhNTJiNWMxZTFmM2FmNjE2ZDg4YmY2YTA1N2RkNGY4MWViMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-12-04T11:52:04Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-12-04T11:52:04Z"}, "message": "re PR middle-end/65958 (-fstack-check breaks alloca on architectures using generic stack checking)\n\n\tPR middle-end/65958\n\t* config/aarch64/aarch64-protos.h (aarch64_output_probe_stack-range):\n\tDeclare.\n\t* config/aarch64/aarch64.md: Declare UNSPECV_BLOCKAGE and\n\tUNSPEC_PROBE_STACK_RANGE.\n\t(blockage): New instruction.\n\t(probe_stack_range_<PTR:mode>): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_emit_probe_stack_range): New\n\tfunction.\n\t(aarch64_output_probe_stack_range): Likewise.\n\t(aarch64_expand_prologue): Invoke aarch64_emit_probe_stack_range if\n\tstatic builtin stack checking is enabled.\n\t* config/aarch64/aarch64-linux.h (STACK_CHECK_STATIC_BUILTIN):\n\tDefine to 1.\n\nCo-Authored-By: Tristan Gingold <gingold@adacore.com>\n\nFrom-SVN: r231259", "tree": {"sha": "9c22be8f3e7de778b5123484e09162b8e9151c87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c22be8f3e7de778b5123484e09162b8e9151c87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/comments", "author": null, "committer": null, "parents": [{"sha": "9b8b2f672df18d38e37033a4842fd43a94ae62ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b8b2f672df18d38e37033a4842fd43a94ae62ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b8b2f672df18d38e37033a4842fd43a94ae62ad"}], "stats": {"total": 258, "additions": 258, "deletions": 0}, "files": [{"sha": "c05a96b5e73d35a8ebc92d85c8fc9789edaee4a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "patch": "@@ -1,3 +1,21 @@\n+2015-12-04  Eric Botcazou  <ebotcazou@adacore.com>\n+            Tristan Gingold  <gingold@adacore.com>\n+\n+\tPR middle-end/65958\n+\t* config/aarch64/aarch64-protos.h (aarch64_output_probe_stack-range):\n+\tDeclare.\n+\t* config/aarch64/aarch64.md: Declare UNSPECV_BLOCKAGE and\n+\tUNSPEC_PROBE_STACK_RANGE.\n+\t(blockage): New instruction.\n+\t(probe_stack_range_<PTR:mode>): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_emit_probe_stack_range): New\n+\tfunction.\n+\t(aarch64_output_probe_stack_range): Likewise.\n+\t(aarch64_expand_prologue): Invoke aarch64_emit_probe_stack_range if\n+\tstatic builtin stack checking is enabled.\n+\t* config/aarch64/aarch64-linux.h (STACK_CHECK_STATIC_BUILTIN):\n+\tDefine to 1.\n+\n 2015-12-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/68214"}, {"sha": "f2b4d415aa9fe055be7d56912f624dc6f52fac25", "filename": "gcc/config/aarch64/aarch64-linux.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Fconfig%2Faarch64%2Faarch64-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Fconfig%2Faarch64%2Faarch64-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-linux.h?ref=a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "patch": "@@ -88,4 +88,7 @@\n #undef TARGET_BINDS_LOCAL_P\n #define TARGET_BINDS_LOCAL_P default_binds_local_p_2\n \n+/* Define this to be nonzero if static stack checking is supported.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1\n+\n #endif  /* GCC_AARCH64_LINUX_H */"}, {"sha": "1e0fb4e97e8144173b0e5a0b89f59973ee40e190", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "patch": "@@ -340,6 +340,7 @@ void aarch64_asm_output_labelref (FILE *, const char *);\n void aarch64_cpu_cpp_builtins (cpp_reader *);\n void aarch64_elf_asm_named_section (const char *, unsigned, tree);\n const char * aarch64_gen_far_branch (rtx *, int, const char *, const char *);\n+const char * aarch64_output_probe_stack_range (rtx, rtx);\n void aarch64_err_no_fpadvsimd (machine_mode, const char *);\n void aarch64_expand_epilogue (bool);\n void aarch64_expand_mov_immediate (rtx, rtx);"}, {"sha": "5e3b5e04bd6e0fb15cb195c62f2ce6bcb135a19a", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "patch": "@@ -62,6 +62,7 @@\n #include \"sched-int.h\"\n #include \"cortex-a57-fma-steering.h\"\n #include \"target-globals.h\"\n+#include \"common/common-target.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -2249,6 +2250,179 @@ aarch64_libgcc_cmp_return_mode (void)\n   return SImode;\n }\n \n+#define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)\n+\n+/* We use the 12-bit shifted immediate arithmetic instructions so values\n+   must be multiple of (1 << 12), i.e. 4096.  */\n+#define ARITH_FACTOR 4096\n+\n+#if (PROBE_INTERVAL % ARITH_FACTOR) != 0\n+#error Cannot use simple address calculation for stack probing\n+#endif\n+\n+/* The pair of scratch registers used for stack probing.  */\n+#define PROBE_STACK_FIRST_REG  9\n+#define PROBE_STACK_SECOND_REG 10\n+\n+/* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,\n+   inclusive.  These are offsets from the current stack pointer.  */\n+\n+static void\n+aarch64_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n+{\n+  rtx reg1 = gen_rtx_REG (ptr_mode, PROBE_STACK_FIRST_REG);\n+\n+  /* See the same assertion on PROBE_INTERVAL above.  */\n+  gcc_assert ((first % ARITH_FACTOR) == 0);\n+\n+  /* See if we have a constant small number of probes to generate.  If so,\n+     that's the easy case.  */\n+  if (size <= PROBE_INTERVAL)\n+    {\n+      const HOST_WIDE_INT base = ROUND_UP (size, ARITH_FACTOR);\n+\n+      emit_set_insn (reg1,\n+\t\t     plus_constant (ptr_mode,\n+\t\t\t\t    stack_pointer_rtx, -(first + base)));\n+      emit_stack_probe (plus_constant (ptr_mode, reg1, base - size));\n+    }\n+\n+  /* The run-time loop is made up of 8 insns in the generic case while the\n+     compile-time loop is made up of 4+2*(n-2) insns for n # of intervals.  */\n+  else if (size <= 4 * PROBE_INTERVAL)\n+    {\n+      HOST_WIDE_INT i, rem;\n+\n+      emit_set_insn (reg1,\n+\t\t     plus_constant (ptr_mode,\n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    -(first + PROBE_INTERVAL)));\n+      emit_stack_probe (reg1);\n+\n+      /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 2 until\n+\t it exceeds SIZE.  If only two probes are needed, this will not\n+\t generate any code.  Then probe at FIRST + SIZE.  */\n+      for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n+\t{\n+\t  emit_set_insn (reg1,\n+\t\t\t plus_constant (ptr_mode, reg1, -PROBE_INTERVAL));\n+\t  emit_stack_probe (reg1);\n+\t}\n+\n+      rem = size - (i - PROBE_INTERVAL);\n+      if (rem > 256)\n+\t{\n+\t  const HOST_WIDE_INT base = ROUND_UP (rem, ARITH_FACTOR);\n+\n+\t  emit_set_insn (reg1, plus_constant (ptr_mode, reg1, -base));\n+\t  emit_stack_probe (plus_constant (ptr_mode, reg1, base - rem));\n+\t}\n+      else\n+\temit_stack_probe (plus_constant (ptr_mode, reg1, -rem));\n+    }\n+\n+  /* Otherwise, do the same as above, but in a loop.  Note that we must be\n+     extra careful with variables wrapping around because we might be at\n+     the very top (or the very bottom) of the address space and we have\n+     to be able to handle this case properly; in particular, we use an\n+     equality test for the loop condition.  */\n+  else\n+    {\n+      rtx reg2 = gen_rtx_REG (ptr_mode, PROBE_STACK_SECOND_REG);\n+\n+      /* Step 1: round SIZE to the previous multiple of the interval.  */\n+\n+      HOST_WIDE_INT rounded_size = size & -PROBE_INTERVAL;\n+\n+\n+      /* Step 2: compute initial and final value of the loop counter.  */\n+\n+      /* TEST_ADDR = SP + FIRST.  */\n+      emit_set_insn (reg1,\n+\t\t     plus_constant (ptr_mode, stack_pointer_rtx, -first));\n+\n+      /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */\n+      emit_set_insn (reg2,\n+\t\t     plus_constant (ptr_mode, stack_pointer_rtx,\n+\t\t\t\t    -(first + rounded_size)));\n+\n+\n+      /* Step 3: the loop\n+\n+\t do\n+\t   {\n+\t     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL\n+\t     probe at TEST_ADDR\n+\t   }\n+\t while (TEST_ADDR != LAST_ADDR)\n+\n+\t probes at FIRST + N * PROBE_INTERVAL for values of N from 1\n+\t until it is equal to ROUNDED_SIZE.  */\n+\n+      if (ptr_mode == DImode)\n+\temit_insn (gen_probe_stack_range_di (reg1, reg1, reg2));\n+      else\n+\temit_insn (gen_probe_stack_range_si (reg1, reg1, reg2));\n+\n+\n+      /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time\n+\t that SIZE is equal to ROUNDED_SIZE.  */\n+\n+      if (size != rounded_size)\n+\t{\n+\t  HOST_WIDE_INT rem = size - rounded_size;\n+\n+\t  if (rem > 256)\n+\t    {\n+\t      const HOST_WIDE_INT base = ROUND_UP (rem, ARITH_FACTOR);\n+\n+\t      emit_set_insn (reg2, plus_constant (ptr_mode, reg2, -base));\n+\t      emit_stack_probe (plus_constant (ptr_mode, reg2, base - rem));\n+\t    }\n+\t  else\n+\t    emit_stack_probe (plus_constant (ptr_mode, reg2, -rem));\n+\t}\n+    }\n+\n+  /* Make sure nothing is scheduled before we are done.  */\n+  emit_insn (gen_blockage ());\n+}\n+\n+/* Probe a range of stack addresses from REG1 to REG2 inclusive.  These are\n+   absolute addresses.  */\n+\n+const char *\n+aarch64_output_probe_stack_range (rtx reg1, rtx reg2)\n+{\n+  static int labelno = 0;\n+  char loop_lab[32];\n+  rtx xops[2];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno++);\n+\n+  /* Loop.  */\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n+\n+  /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n+  xops[0] = reg1;\n+  xops[1] = GEN_INT (PROBE_INTERVAL);\n+  output_asm_insn (\"sub\\t%0, %0, %1\", xops);\n+\n+  /* Probe at TEST_ADDR.  */\n+  output_asm_insn (\"str\\txzr, [%0]\", xops);\n+\n+  /* Test if TEST_ADDR == LAST_ADDR.  */\n+  xops[1] = reg2;\n+  output_asm_insn (\"cmp\\t%0, %1\", xops);\n+\n+  /* Branch.  */\n+  fputs (\"\\tb.ne\\t\", asm_out_file);\n+  assemble_name_raw (asm_out_file, loop_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  return \"\";\n+}\n+\n static bool\n aarch64_frame_pointer_required (void)\n {\n@@ -2649,6 +2823,18 @@ aarch64_expand_prologue (void)\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = frame_size;\n \n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n+    {\n+      if (crtl->is_leaf && !cfun->calls_alloca)\n+\t{\n+\t  if (frame_size > PROBE_INTERVAL && frame_size > STACK_CHECK_PROTECT)\n+\t    aarch64_emit_probe_stack_range (STACK_CHECK_PROTECT,\n+\t\t\t\t\t    frame_size - STACK_CHECK_PROTECT);\n+\t}\n+      else if (frame_size > 0)\n+\taarch64_emit_probe_stack_range (STACK_CHECK_PROTECT, frame_size);\n+    }\n+\n   /* Store pairs and load pairs have a range only -512 to 504.  */\n   if (offset >= 512)\n     {"}, {"sha": "f5a8ae7900a6bb35c63d7f833aa2183325848df1", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "patch": "@@ -104,6 +104,7 @@\n     UNSPEC_MB\n     UNSPEC_NOP\n     UNSPEC_PRLG_STK\n+    UNSPEC_PROBE_STACK_RANGE\n     UNSPEC_RBIT\n     UNSPEC_SISD_NEG\n     UNSPEC_SISD_SSHL\n@@ -137,6 +138,7 @@\n     UNSPECV_SET_FPCR\t\t; Represent assign of FPCR content.\n     UNSPECV_GET_FPSR\t\t; Represent fetch of FPSR content.\n     UNSPECV_SET_FPSR\t\t; Represent assign of FPSR content.\n+    UNSPECV_BLOCKAGE\t\t; Represent a blockage\n   ]\n )\n \n@@ -4951,6 +4953,29 @@\n   [(set_attr \"length\" \"0\")]\n )\n \n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"type\" \"block\")]\n+)\n+\n+(define_insn \"probe_stack_range_<PTR:mode>\"\n+  [(set (match_operand:PTR 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:PTR [(match_operand:PTR 1 \"register_operand\" \"0\")\n+\t\t\t      (match_operand:PTR 2 \"register_operand\" \"r\")]\n+\t\t\t       UNSPEC_PROBE_STACK_RANGE))]\n+  \"\"\n+{\n+  return aarch64_output_probe_stack_range (operands[0], operands[2]);\n+}\n+  [(set_attr \"length\" \"32\")]\n+)\n+\n ;; Named pattern for expanding thread pointer reference.\n (define_expand \"get_thread_pointerdi\"\n   [(match_operand:DI 0 \"register_operand\" \"=r\")]"}, {"sha": "20a392ee42e9e1b1ac853803b45ca09b65cd6775", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "patch": "@@ -1,3 +1,7 @@\n+2015-12-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/aarch64/stack-checking.c: New test.\n+\n 2015-12-04  Richard Biener  <rguenther@suse.de>\n \n \tPR testsuite/68681"}, {"sha": "1d1530df62b4eeae889d407fe21ef217e717dd38", "filename": "gcc/testsuite/gcc.target/aarch64/stack-checking.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-checking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-checking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-checking.c?ref=a3eb8a52b5c1e1f3af616d88bf6a057dd4f81eb3", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run { target { *-*-linux* } } } */\n+/* { dg-options \"-fstack-check\" } */\n+\n+int main(void)\n+{\n+  char *p;\n+  if (1)\n+    {\n+      char i[48];\n+      p = __builtin_alloca(8);\n+      p[0] = 1;\n+    }\n+\n+  if (1)\n+    {\n+      char i[48], j[64];\n+      j[32] = 0;\n+    }\n+\n+  return !p[0];\n+}"}]}