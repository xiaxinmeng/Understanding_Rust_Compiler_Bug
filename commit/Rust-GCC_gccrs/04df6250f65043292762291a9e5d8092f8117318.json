{"sha": "04df6250f65043292762291a9e5d8092f8117318", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRkZjYyNTBmNjUwNDMyOTI3NjIyOTFhOWU1ZDgwOTJmODExNzMxOA==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2007-08-14T08:38:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:38:48Z"}, "message": "exp_ch3.ads, [...] (Add_Final_Chain): New subprogram.\n\n2007-08-14  Thomas Quinot  <quinot@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch3.ads, exp_ch3.adb (Add_Final_Chain): New subprogram.\n\t(Freeze_Array_Type, Freeze_Record_Type): For the case of a component\n\ttype that is an anonymous access to controlled object, establish\n\tan associated finalization chain to avoid corrupting the global\n\tfinalization list when a dynamically allocated object designated\n\tby such a component is deallocated.\n\t(Make_Controlling_Function_Wrappers): Create wrappers for constructor\n\tfunctions that need it, even when not marked Requires_Overriding.\n\t(Initialize_Tag): Replace call to has_discriminants by call to\n\tIs_Variable_Size_Record in the circuitry that handles the\n\tinitialization of secondary tags.\n\t(Is_Variable_Size_Record): New implementation.\n\t(Expand_N_Object_Declaration): Suppress call to init proc if there is a\n\tSuppress_Initialization pragma for a derived type.\n\t(Is_Variable_Size_Record): New subprogram.\n\t(Build_Offset_To_Top_Functions): New implementation that simplifies the\n\tinitial version of this routine and also fixes problems causing\n\tincomplete initialization of the table of interfaces.\n\t(Build_Init_Procedure): Improve the generation of code to initialize the\n\tthe tag components of secondary dispatch tables.\n\t(Init_Secondary_Tags): New implementation that simplifies the previous\n\tversion of this routine.\n\t(Make_DT): Add parameter to indicate when type has been frozen by an\n\tobject declaration, for diagnostic purposes.\n\t(Check_Premature_Freezing): New subsidiary procedure of Make_DT, to\n\tdiagnose attemps to freeze a subprogram when some untagged type of its\n\tprofile is a private type whose full view has not been analyzed yet.\n\t(Freeze_Array_Type): Generate init proc for packed array if either\n\tInitialize or Normalize_Scalars is set.\n\t(Make_Controlling_Function_Wrappers, Make_Null_Procedure_Specs): when\n\tconstructing the new profile, copy the null_exclusion indicator for each\n\tparameter, to ensure full conformance of the new body with the spec.\n\n\t* sem_type.ads, sem_type.adb (Make_Controlling_Function_Wrappers):\n\tCreate wrappers for constructor functions that need it, even when not\n\tmarked Requires_Overriding.\n\t(Covers): Handle properly designated types of anonymous access types,\n\twhose non-limited views are themselves incomplete types.\n\t(Add_Entry): Use an entity to store the abstract operation which hides\n\tan interpretation.\n\t(Binary_Op_May_Be_Hidden): Rename to Binary_Op_Interp_Has_Abstract_Op.\n\t(Collect_Interps): Use Empty as an actual for Abstract_Op in the\n\tinitialization aggregate.\n\t(Function_Interp_May_Be_Hidden): Rename to\n\tFunction_Interp_Has_Abstract_Op.\n\t(Has_Compatible_Type): Remove machinery that skips interpretations if\n\tthey are labeled as potentially hidden by an abstract operator.\n\t(Has_Hidden_Interp): Rename to Has_Abstract_Op.\n\t(Set_May_Be_Hidden): Rename to Set_Abstract_Op.\n\t(Write_Overloads): Output the abstract operator if present.\n\t(Add_Entry): Before inserting a new entry into the interpretation table\n\tfor a node, determine whether the entry will be disabled by an abstract\n\toperator.\n\t(Binary_Op_Interp_May_Be_Hidden): New routine.\n\t(Collect_Interps): Add value for flag May_Be_Hidden in initialization\n\taggregate.\n\t(Function_Interp_May_Be_Hidden): New routine.\n\t(Has_Compatible_Type): Do not consider interpretations hidden by\n\tabstract operators when trying to determine whether two types are\n\tcompatible.\n\t(Has_Hidden_Interp): New routine.\n\t(Set_May_Be_Hidden_Interp): New routine.\n\t(Write_Overloads): Write the status of flag May_Be_Hidden.\n\nFrom-SVN: r127417", "tree": {"sha": "e581f2fb2ea5e6fcdd2668fe9c743828c5d5f74a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e581f2fb2ea5e6fcdd2668fe9c743828c5d5f74a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04df6250f65043292762291a9e5d8092f8117318", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04df6250f65043292762291a9e5d8092f8117318", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04df6250f65043292762291a9e5d8092f8117318", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04df6250f65043292762291a9e5d8092f8117318/comments", "author": null, "committer": null, "parents": [{"sha": "3e8ee849e158dffe379771f62ddc0edb094ddf44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e8ee849e158dffe379771f62ddc0edb094ddf44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e8ee849e158dffe379771f62ddc0edb094ddf44"}], "stats": {"total": 1344, "additions": 816, "deletions": 528}, "files": [{"sha": "a178833afdf3ef45657f0cb23c9b84ae8696ea34", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 605, "deletions": 472, "changes": 1077, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04df6250f65043292762291a9e5d8092f8117318/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04df6250f65043292762291a9e5d8092f8117318/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=04df6250f65043292762291a9e5d8092f8117318", "patch": "@@ -73,6 +73,10 @@ package body Exp_Ch3 is\n    -- Local Subprograms --\n    -----------------------\n \n+   function Add_Final_Chain (Def_Id : Entity_Id) return Entity_Id;\n+   --  Add the declaration of a finalization list to the freeze actions for\n+   --  Def_Id, and return its defining identifier.\n+\n    procedure Adjust_Discriminants (Rtype : Entity_Id);\n    --  This is used when freezing a record type. It attempts to construct\n    --  more restrictive subtypes for discriminants so that the max size of\n@@ -103,7 +107,7 @@ package body Exp_Ch3 is\n    function Build_Equivalent_Record_Aggregate (T : Entity_Id) return Node_Id;\n    --  This function builds a static aggregate that can serve as the initial\n    --  value for a record type whose components are scalar and initialized\n-   --  with compile-time values, or arrays with similarc initialization or\n+   --  with compile-time values, or arrays with similar initialization or\n    --  defaults. When possible, initialization of an object of the type can\n    --  be achieved by using a copy of the aggregate as an initial value, thus\n    --  removing the implicit call that would otherwise constitute elaboration\n@@ -206,6 +210,9 @@ package body Exp_Ch3 is\n    --  Check if E is defined in the RTL (in a child of Ada or System). Used\n    --  to avoid to bring in the overhead of _Input, _Output for tagged types.\n \n+   function Is_Variable_Size_Record (E : Entity_Id) return Boolean;\n+   --  Returns true if E has variable size components\n+\n    function Make_Eq_Case\n      (E     : Entity_Id;\n       CL    : Node_Id;\n@@ -341,6 +348,28 @@ package body Exp_Ch3 is\n    --  the generation of these operations, as a useful optimization or for\n    --  certification purposes.\n \n+   ---------------------\n+   -- Add_Final_Chain --\n+   ---------------------\n+\n+   function Add_Final_Chain (Def_Id : Entity_Id) return Entity_Id is\n+      Loc   : constant Source_Ptr := Sloc (Def_Id);\n+      Flist : Entity_Id;\n+\n+   begin\n+      Flist :=\n+        Make_Defining_Identifier (Loc,\n+          New_External_Name (Chars (Def_Id), 'L'));\n+\n+      Append_Freeze_Action (Def_Id,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Flist,\n+          Object_Definition   =>\n+            New_Reference_To (RTE (RE_List_Controller), Loc)));\n+\n+      return Flist;\n+   end Add_Final_Chain;\n+\n    --------------------------\n    -- Adjust_Discriminants --\n    --------------------------\n@@ -874,7 +903,7 @@ package body Exp_Ch3 is\n                end loop;\n \n                Return_Node :=\n-                 Make_Return_Statement (Loc,\n+                 Make_Simple_Return_Statement (Loc,\n                    Expression =>\n                      Make_Function_Call (Loc,\n                        Name =>\n@@ -884,7 +913,7 @@ package body Exp_Ch3 is\n \n             else\n                Return_Node :=\n-                 Make_Return_Statement (Loc,\n+                 Make_Simple_Return_Statement (Loc,\n                    Expression =>\n                      New_Reference_To (Standard_False, Loc));\n             end if;\n@@ -898,7 +927,7 @@ package body Exp_Ch3 is\n          Set_Discrete_Choices (Case_Alt_Node, Choice_List);\n \n          Return_Node :=\n-           Make_Return_Statement (Loc,\n+           Make_Simple_Return_Statement (Loc,\n              Expression =>\n                New_Reference_To (Standard_True, Loc));\n \n@@ -1762,7 +1791,7 @@ package body Exp_Ch3 is\n          if Ada_Version >= Ada_05\n            and then Can_Never_Be_Null (Etype (Id))            -- Lhs\n          then\n-            if Nkind (Exp) = N_Null then\n+            if Known_Null (Exp) then\n                return New_List (\n                  Make_Raise_Constraint_Error (Sloc (Exp),\n                    Reason => CE_Null_Not_Allowed));\n@@ -1996,136 +2025,120 @@ package body Exp_Ch3 is\n       -----------------------------------\n \n       procedure Build_Offset_To_Top_Functions is\n-         ADT       : Elmt_Id;\n-         Body_Node : Node_Id;\n-         Func_Id   : Entity_Id;\n-         Spec_Node : Node_Id;\n-         E         : Entity_Id;\n \n-         procedure Build_Offset_To_Top_Internal (Typ : Entity_Id);\n-         --  Internal subprogram used to recursively traverse all the ancestors\n+         procedure Build_Offset_To_Top_Function (Iface_Comp : Entity_Id);\n+         --  Generate:\n+         --    function Fxx (O : in Rec_Typ) return Storage_Offset is\n+         --    begin\n+         --       return O.Iface_Comp'Position;\n+         --    end Fxx;\n \n-         ----------------------------------\n-         -- Build_Offset_To_Top_Internal --\n-         ----------------------------------\n+         ------------------------------\n+         -- Build_Offset_To_Top_Body --\n+         ------------------------------\n+\n+         procedure Build_Offset_To_Top_Function (Iface_Comp : Entity_Id) is\n+            Body_Node : Node_Id;\n+            Func_Id   : Entity_Id;\n+            Spec_Node : Node_Id;\n \n-         procedure Build_Offset_To_Top_Internal (Typ : Entity_Id) is\n          begin\n-            --  Climb to the ancestor (if any) handling synchronized interface\n-            --  derivations and private types\n+            Func_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('F'));\n \n-            if Is_Concurrent_Record_Type (Typ) then\n-               declare\n-                  Iface_List : constant List_Id :=\n-                                 Abstract_Interface_List (Typ);\n-               begin\n-                  if Is_Non_Empty_List (Iface_List) then\n-                     Build_Offset_To_Top_Internal (Etype (First (Iface_List)));\n-                  end if;\n-               end;\n+            Set_DT_Offset_To_Top_Func (Iface_Comp, Func_Id);\n \n-            elsif Present (Full_View (Etype (Typ))) then\n-               if Full_View (Etype (Typ)) /= Typ then\n-                  Build_Offset_To_Top_Internal (Full_View (Etype (Typ)));\n-               end if;\n+            --  Generate\n+            --    function Fxx (O : in Rec_Typ) return Storage_Offset;\n \n-            elsif Etype (Typ) /= Typ then\n-               Build_Offset_To_Top_Internal (Etype (Typ));\n+            Spec_Node := New_Node (N_Function_Specification, Loc);\n+            Set_Defining_Unit_Name (Spec_Node, Func_Id);\n+            Set_Parameter_Specifications (Spec_Node, New_List (\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => Make_Defining_Identifier (Loc, Name_uO),\n+                In_Present          => True,\n+                Parameter_Type      => New_Reference_To (Rec_Type, Loc))));\n+            Set_Result_Definition (Spec_Node,\n+              New_Reference_To (RTE (RE_Storage_Offset), Loc));\n+\n+            --  Generate\n+            --    function Fxx (O : in Rec_Typ) return Storage_Offset is\n+            --    begin\n+            --       return O.Iface_Comp'Position;\n+            --    end Fxx;\n+\n+            Body_Node := New_Node (N_Subprogram_Body, Loc);\n+            Set_Specification (Body_Node, Spec_Node);\n+            Set_Declarations (Body_Node, New_List);\n+            Set_Handled_Statement_Sequence (Body_Node,\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => New_List (\n+                  Make_Simple_Return_Statement (Loc,\n+                    Expression =>\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix =>\n+                          Make_Selected_Component (Loc,\n+                            Prefix => Make_Identifier (Loc, Name_uO),\n+                            Selector_Name => New_Reference_To\n+                                               (Iface_Comp, Loc)),\n+                        Attribute_Name => Name_Position)))));\n+\n+            Set_Ekind       (Func_Id, E_Function);\n+            Set_Mechanism   (Func_Id, Default_Mechanism);\n+            Set_Is_Internal (Func_Id, True);\n+\n+            if not Debug_Generated_Code then\n+               Set_Debug_Info_Off (Func_Id);\n             end if;\n \n-            if Present (Abstract_Interfaces (Typ))\n-              and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n-            then\n-               E := First_Entity (Typ);\n-               while Present (E) loop\n-                  if Is_Tag (E)\n-                    and then Chars (E) /= Name_uTag\n-                  then\n-                     if Typ = Rec_Type then\n-                        Body_Node := New_Node (N_Subprogram_Body, Loc);\n-\n-                        Func_Id :=\n-                          Make_Defining_Identifier (Loc,\n-                            Chars => New_Internal_Name ('F'));\n-\n-                        Set_DT_Offset_To_Top_Func (E, Func_Id);\n-\n-                        Spec_Node := New_Node (N_Function_Specification, Loc);\n-                        Set_Defining_Unit_Name (Spec_Node, Func_Id);\n-                        Set_Parameter_Specifications (Spec_Node, New_List (\n-                           Make_Parameter_Specification (Loc,\n-                             Defining_Identifier =>\n-                               Make_Defining_Identifier (Loc, Name_uO),\n-                             In_Present => True,\n-                             Parameter_Type => New_Reference_To (Typ, Loc))));\n-                        Set_Result_Definition (Spec_Node,\n-                          New_Reference_To (RTE (RE_Storage_Offset), Loc));\n-\n-                        Set_Specification (Body_Node, Spec_Node);\n-                        Set_Declarations (Body_Node, New_List);\n-                        Set_Handled_Statement_Sequence (Body_Node,\n-                          Make_Handled_Sequence_Of_Statements (Loc,\n-                            Statements => New_List (\n-                              Make_Return_Statement (Loc,\n-                                Expression =>\n-                                  Make_Attribute_Reference (Loc,\n-                                    Prefix =>\n-                                      Make_Selected_Component (Loc,\n-                                        Prefix => Make_Identifier (Loc,\n-                                                    Name_uO),\n-                                        Selector_Name => New_Reference_To\n-                                                           (E, Loc)),\n-                                    Attribute_Name => Name_Position)))));\n-\n-                        Set_Ekind       (Func_Id, E_Function);\n-                        Set_Mechanism   (Func_Id, Default_Mechanism);\n-                        Set_Is_Internal (Func_Id, True);\n-\n-                        if not Debug_Generated_Code then\n-                           Set_Debug_Info_Off (Func_Id);\n-                        end if;\n-\n-                        Analyze (Body_Node);\n+            Analyze (Body_Node);\n \n-                        Append_Freeze_Action (Rec_Type, Body_Node);\n-                     end if;\n+            Append_Freeze_Action (Rec_Type, Body_Node);\n+         end Build_Offset_To_Top_Function;\n \n-                     Next_Elmt (ADT);\n-                  end if;\n+         --  Local variables\n \n-                  Next_Entity (E);\n-               end loop;\n-            end if;\n-         end Build_Offset_To_Top_Internal;\n+         Ifaces_List      : Elist_Id;\n+         Ifaces_Comp_List : Elist_Id;\n+         Ifaces_Tag_List  : Elist_Id;\n+         Iface_Elmt       : Elmt_Id;\n+         Comp_Elmt        : Elmt_Id;\n \n       --  Start of processing for Build_Offset_To_Top_Functions\n \n       begin\n-         if Is_Concurrent_Record_Type (Rec_Type)\n-           and then Is_Empty_List (Abstract_Interface_List (Rec_Type))\n-         then\n-            return;\n+         --  Offset_To_Top_Functions are built only for derivations of types\n+         --  with discriminants that cover interface types.\n \n-         elsif Etype (Rec_Type) = Rec_Type\n+         if not Is_Tagged_Type (Rec_Type)\n+           or else Etype (Rec_Type) = Rec_Type\n            or else not Has_Discriminants (Etype (Rec_Type))\n-           or else No (Abstract_Interfaces (Rec_Type))\n-           or else Is_Empty_Elmt_List (Abstract_Interfaces (Rec_Type))\n          then\n             return;\n          end if;\n \n-         --  Skip the first _Tag, which is the main tag of the tagged type.\n-         --  Following tags correspond with abstract interfaces.\n+         Collect_Interfaces_Info (Rec_Type,\n+           Ifaces_List, Ifaces_Comp_List, Ifaces_Tag_List);\n \n-         ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Rec_Type)));\n+         --  For each interface type with secondary dispatch table we generate\n+         --  the Offset_To_Top_Functions (required to displace the pointer in\n+         --  interface conversions)\n \n-         --  Handle private types\n+         Iface_Elmt := First_Elmt (Ifaces_List);\n+         Comp_Elmt  := First_Elmt (Ifaces_Comp_List);\n+         while Present (Iface_Elmt) loop\n \n-         if Present (Full_View (Rec_Type)) then\n-            Build_Offset_To_Top_Internal (Full_View (Rec_Type));\n-         else\n-            Build_Offset_To_Top_Internal (Rec_Type);\n-         end if;\n+            --  If the interface is a parent of Rec_Type it shares the primary\n+            --  dispatch table and hence there is no need to build the function\n+\n+            if not Is_Parent (Node (Iface_Elmt), Rec_Type) then\n+               Build_Offset_To_Top_Function (Iface_Comp => Node (Comp_Elmt));\n+            end if;\n+\n+            Next_Elmt (Iface_Elmt);\n+            Next_Elmt (Comp_Elmt);\n+         end loop;\n       end Build_Offset_To_Top_Functions;\n \n       --------------------------\n@@ -2139,7 +2152,7 @@ package body Exp_Ch3 is\n          Proc_Spec_Node        : Node_Id;\n          Body_Stmts            : List_Id;\n          Record_Extension_Node : Node_Id;\n-         Init_Tag              : Node_Id;\n+         Init_Tags_List        : List_Id;\n \n       begin\n          Body_Stmts := New_List;\n@@ -2241,7 +2254,9 @@ package body Exp_Ch3 is\n            and then VM_Target = No_VM\n            and then not No_Run_Time_Mode\n          then\n-            Init_Tag :=\n+            --  Initialize the primary tag\n+\n+            Init_Tags_List := New_List (\n               Make_Assignment_Statement (Loc,\n                 Name =>\n                   Make_Selected_Component (Loc,\n@@ -2251,7 +2266,23 @@ package body Exp_Ch3 is\n \n                 Expression =>\n                   New_Reference_To\n-                    (Node (First_Elmt (Access_Disp_Table (Rec_Type))), Loc));\n+                    (Node (First_Elmt (Access_Disp_Table (Rec_Type))), Loc)));\n+\n+            --  Ada 2005 (AI-251): Initialize the secondary tags components\n+            --  located at fixed positions (tags whose position depends on\n+            --  variable size components are initialized later ---see below).\n+\n+            if Ada_Version >= Ada_05\n+              and then not Is_Interface (Rec_Type)\n+              and then Has_Abstract_Interfaces (Rec_Type)\n+            then\n+               Init_Secondary_Tags\n+                 (Typ            => Rec_Type,\n+                  Target         => Make_Identifier (Loc, Name_uInit),\n+                  Stmts_List     => Init_Tags_List,\n+                  Fixed_Comps    => True,\n+                  Variable_Comps => False);\n+            end if;\n \n             --  The tag must be inserted before the assignments to other\n             --  components,  because the initial value of the component may\n@@ -2266,25 +2297,23 @@ package body Exp_Ch3 is\n             --  after the calls to initialize the parent.\n \n             if not Is_CPP_Class (Etype (Rec_Type)) then\n-               Init_Tag :=\n+               Prepend_To (Body_Stmts,\n                  Make_If_Statement (Loc,\n                    Condition => New_Occurrence_Of (Set_Tag, Loc),\n-                   Then_Statements => New_List (Init_Tag));\n-\n-               Prepend_To (Body_Stmts, Init_Tag);\n+                   Then_Statements => Init_Tags_List));\n \n             --  CPP_Class: In this case the dispatch table of the parent was\n             --  built in the C++ side and we copy the table of the parent to\n             --  initialize the new dispatch table.\n \n             else\n                declare\n-                  Nod   : Node_Id := First (Body_Stmts);\n-                  New_N : Node_Id;\n+                  Nod : Node_Id;\n \n                begin\n                   --  We assume the first init_proc call is for the parent\n \n+                  Nod := First (Body_Stmts);\n                   while Present (Next (Nod))\n                     and then (Nkind (Nod) /= N_Procedure_Call_Statement\n                                or else not Is_Init_Proc (Name (Nod)))\n@@ -2299,28 +2328,29 @@ package body Exp_Ch3 is\n                   --        _init._tag := new_dt;\n                   --     end if;\n \n-                  New_N :=\n+                  Prepend_To (Init_Tags_List,\n                     Build_Inherit_Prims (Loc,\n+                      Typ          => Rec_Type,\n                       Old_Tag_Node =>\n                         Make_Selected_Component (Loc,\n-                          Prefix => Make_Identifier (Loc, Name_uInit),\n+                          Prefix        =>\n+                            Make_Identifier (Loc,\n+                              Chars => Name_uInit),\n                           Selector_Name =>\n                             New_Reference_To\n                               (First_Tag_Component (Rec_Type), Loc)),\n                       New_Tag_Node =>\n                         New_Reference_To\n                           (Node (First_Elmt (Access_Disp_Table (Rec_Type))),\n                            Loc),\n-                      Num_Prims =>\n+                      Num_Prims    =>\n                         UI_To_Int\n-                          (DT_Entry_Count (First_Tag_Component (Rec_Type))));\n+                          (DT_Entry_Count (First_Tag_Component (Rec_Type)))));\n \n-                  Init_Tag :=\n+                  Insert_After (Nod,\n                     Make_If_Statement (Loc,\n                       Condition => New_Occurrence_Of (Set_Tag, Loc),\n-                      Then_Statements => New_List (New_N, Init_Tag));\n-\n-                  Insert_After (Nod, Init_Tag);\n+                      Then_Statements => Init_Tags_List));\n \n                   --  We have inherited table of the parent from the CPP side.\n                   --  Now we fill the slots associated with Ada primitives.\n@@ -2343,7 +2373,7 @@ package body Exp_Ch3 is\n                         then\n                            Register_Primitive (Loc,\n                              Prim    => Prim,\n-                             Ins_Nod => Init_Tag);\n+                             Ins_Nod => Last (Init_Tags_List));\n                         end if;\n \n                         Next_Elmt (E);\n@@ -2352,18 +2382,31 @@ package body Exp_Ch3 is\n                end;\n             end if;\n \n-            --  Ada 2005 (AI-251): Initialization of all the tags corresponding\n-            --  with abstract interfaces\n+            --  Ada 2005 (AI-251): Initialize the secondary tag components\n+            --  located at variable positions. We delay the generation of this\n+            --  code until here because the value of the attribute 'Position\n+            --  applied to variable size components of the parent type that\n+            --  depend on discriminants is only safely read at runtime after\n+            --  the parent components have been initialized.\n \n-            if VM_Target = No_VM\n-              and then Ada_Version >= Ada_05\n+            if Ada_Version >= Ada_05\n               and then not Is_Interface (Rec_Type)\n               and then Has_Abstract_Interfaces (Rec_Type)\n+              and then Has_Discriminants (Etype (Rec_Type))\n+              and then Is_Variable_Size_Record (Etype (Rec_Type))\n             then\n+               Init_Tags_List := New_List;\n+\n                Init_Secondary_Tags\n-                 (Typ        => Rec_Type,\n-                  Target     => Make_Identifier (Loc, Name_uInit),\n-                  Stmts_List => Body_Stmts);\n+                 (Typ            => Rec_Type,\n+                  Target         => Make_Identifier (Loc, Name_uInit),\n+                  Stmts_List     => Init_Tags_List,\n+                  Fixed_Comps    => False,\n+                  Variable_Comps => True);\n+\n+               if Is_Non_Empty_List (Init_Tags_List) then\n+                  Append_List_To (Body_Stmts, Init_Tags_List);\n+               end if;\n             end if;\n          end if;\n \n@@ -3498,7 +3541,7 @@ package body Exp_Ch3 is\n                     Left_Opnd => New_Reference_To (A, Loc),\n                     Right_Opnd => New_Reference_To (B, Loc)),\n                 Then_Statements => New_List (\n-                  Make_Return_Statement (Loc,\n+                  Make_Simple_Return_Statement (Loc,\n                     Expression => New_Occurrence_Of (Standard_False, Loc)))));\n \n             --  Generate component-by-component comparison. Note that we must\n@@ -3522,7 +3565,7 @@ package body Exp_Ch3 is\n       end if;\n \n       Append_To (Stmts,\n-        Make_Return_Statement (Loc,\n+        Make_Simple_Return_Statement (Loc,\n           Expression => New_Reference_To (Standard_True, Loc)));\n \n       Set_TSS (Typ, F);\n@@ -3944,6 +3987,33 @@ package body Exp_Ch3 is\n          return;\n       end if;\n \n+      --  Force construction of dispatch tables of library level tagged types\n+\n+      if VM_Target = No_VM\n+        and then Static_Dispatch_Tables\n+        and then Is_Library_Level_Entity (Def_Id)\n+        and then Is_Library_Level_Tagged_Type (Typ)\n+        and then (Ekind (Typ) = E_Record_Type\n+                    or else Ekind (Typ) = E_Protected_Type\n+                    or else Ekind (Typ) = E_Task_Type)\n+        and then not Has_Dispatch_Table (Typ)\n+      then\n+         declare\n+            New_Nodes : List_Id := No_List;\n+\n+         begin\n+            if Is_Concurrent_Type (Typ) then\n+               New_Nodes := Make_DT (Corresponding_Record_Type (Typ), N);\n+            else\n+               New_Nodes := Make_DT (Typ, N);\n+            end if;\n+\n+            if not Is_Empty_List (New_Nodes) then\n+               Insert_List_Before (N, New_Nodes);\n+            end if;\n+         end;\n+      end if;\n+\n       --  Make shared memory routines for shared passive variable\n \n       if Is_Shared_Passive (Def_Id) then\n@@ -3960,10 +4030,15 @@ package body Exp_Ch3 is\n          Build_Master_Entity (Def_Id);\n       end if;\n \n-      --  Build a list controller for declarations of the form\n-      --    Obj : access Some_Type [:= Expression];\n+      --  Build a list controller for declarations where the type is anonymous\n+      --  access and the designated type is controlled. Only declarations from\n+      --  source files receive such controllers in order to provide the same\n+      --  lifespan for any potential coextensions that may be associated with\n+      --  the object. Finalization lists of internal controlled anonymous\n+      --  access objects are already handled in Expand_N_Allocator.\n \n-      if Ekind (Typ) = E_Anonymous_Access_Type\n+      if Comes_From_Source (N)\n+        and then Ekind (Typ) = E_Anonymous_Access_Type\n         and then Is_Controlled (Directly_Designated_Type (Typ))\n         and then No (Associated_Final_Chain (Typ))\n       then\n@@ -4040,12 +4115,26 @@ package body Exp_Ch3 is\n          --  Call type initialization procedure if there is one. We build the\n          --  call and put it immediately after the object declaration, so that\n          --  it will be expanded in the usual manner. Note that this will\n-         --  result in proper handling of defaulted discriminants. The call\n-         --  to the Init_Proc is suppressed if No_Initialization is set.\n+         --  result in proper handling of defaulted discriminants.\n+\n+         --  Need call if there is a base init proc\n \n          if Has_Non_Null_Base_Init_Proc (Typ)\n-           and then not No_Initialization (N)\n-           and then not Is_Value_Type (Typ)\n+\n+            --  Suppress call if No_Initialization set on declaration\n+\n+            and then not No_Initialization (N)\n+\n+            --  Suppress call for special case of value type for VM\n+\n+            and then not Is_Value_Type (Typ)\n+\n+            --  Suppress call if Suppress_Init_Proc set on the type. This is\n+            --  needed for the derived type case, where Suppress_Initialization\n+            --  may be set for the derived type, even if there is an init proc\n+            --  defined for the root type.\n+\n+            and then not Suppress_Init_Proc (Typ)\n          then\n             --  The call to the initialization procedure does NOT freeze the\n             --  object being initialized. This is because the call is not a\n@@ -4556,9 +4645,9 @@ package body Exp_Ch3 is\n                --  Ada 2005 (AI-251): The following condition covers secondary\n                --  tags but also the adjacent component contanining the offset\n                --  to the base of the object (component generated if the parent\n-               --  has discriminants ---see Add_Interface_Tag_Components). This\n-               --  is required to avoid the addition of the controller between\n-               --  the secondary tag and its adjacent component.\n+               --  has discriminants --- see Add_Interface_Tag_Components).\n+               --  This is required to avoid the addition of the controller\n+               --  between the secondary tag and its adjacent component.\n \n                    or else Present\n                              (Related_Interface\n@@ -4695,8 +4784,9 @@ package body Exp_Ch3 is\n    -----------------------\n \n    procedure Freeze_Array_Type (N : Node_Id) is\n-      Typ  : constant Entity_Id  := Entity (N);\n-      Base : constant Entity_Id  := Base_Type (Typ);\n+      Typ      : constant Entity_Id  := Entity (N);\n+      Comp_Typ : constant Entity_Id := Component_Type (Typ);\n+      Base     : constant Entity_Id  := Base_Type (Typ);\n \n    begin\n       if not Is_Bit_Packed_Array (Typ) then\n@@ -4706,10 +4796,10 @@ package body Exp_Ch3 is\n          --  been a private type at the point of definition. Same if component\n          --  type is controlled.\n \n-         Set_Has_Task (Base, Has_Task (Component_Type (Typ)));\n+         Set_Has_Task (Base, Has_Task (Comp_Typ));\n          Set_Has_Controlled_Component (Base,\n-           Has_Controlled_Component (Component_Type (Typ))\n-             or else Is_Controlled (Component_Type (Typ)));\n+           Has_Controlled_Component (Comp_Typ)\n+             or else Is_Controlled (Comp_Typ));\n \n          if No (Init_Proc (Base)) then\n \n@@ -4746,22 +4836,30 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n-         if Typ = Base and then Has_Controlled_Component (Base) then\n-            Build_Controlling_Procs (Base);\n+         if Typ = Base then\n+            if Has_Controlled_Component (Base) then\n+               Build_Controlling_Procs (Base);\n \n-            if not Is_Limited_Type (Component_Type (Typ))\n-              and then Number_Dimensions (Typ) = 1\n+               if not Is_Limited_Type (Comp_Typ)\n+                 and then Number_Dimensions (Typ) = 1\n+               then\n+                  Build_Slice_Assignment (Typ);\n+               end if;\n+\n+            elsif Ekind (Comp_Typ) = E_Anonymous_Access_Type\n+              and then Controlled_Type (Directly_Designated_Type (Comp_Typ))\n             then\n-               Build_Slice_Assignment (Typ);\n+               Set_Associated_Final_Chain (Comp_Typ, Add_Final_Chain (Typ));\n             end if;\n          end if;\n \n-      --  For packed case, there is a default initialization, except if the\n-      --  component type is itself a packed structure with an initialization\n-      --  procedure.\n+      --  For packed case, default initialization, except if the component type\n+      --  is itself a packed structure with an initialization procedure, or\n+      --  initialize/normalize scalars active, and we have a base type.\n \n-      elsif Present (Init_Proc (Component_Type (Base)))\n-        and then No (Base_Init_Proc (Base))\n+      elsif (Present (Init_Proc (Component_Type (Base)))\n+               and then No (Base_Init_Proc (Base)))\n+        or else (Init_Or_Norm_Scalars and then Base = Typ)\n       then\n          Build_Array_Init_Proc (Base, N);\n       end if;\n@@ -4788,14 +4886,14 @@ package body Exp_Ch3 is\n       pragma Warnings (Off, Func);\n \n    begin\n-      --  Various optimization are possible if the given representation is\n-      --  contiguous.\n+      --  Various optimizations possible if given representation is contiguous\n \n       Is_Contiguous := True;\n+\n       Ent := First_Literal (Typ);\n       Last_Repval := Enumeration_Rep (Ent);\n-      Next_Literal (Ent);\n \n+      Next_Literal (Ent);\n       while Present (Ent) loop\n          if Enumeration_Rep (Ent) - Last_Repval /= 1 then\n             Is_Contiguous := False;\n@@ -4968,7 +5066,7 @@ package body Exp_Ch3 is\n                       Make_Integer_Literal (Loc, Intval => Last_Repval))),\n \n                 Statements => New_List (\n-                  Make_Return_Statement (Loc,\n+                  Make_Simple_Return_Statement (Loc,\n                     Expression => Pos_Expr))));\n \n       else\n@@ -4981,7 +5079,7 @@ package body Exp_Ch3 is\n                     Intval => Enumeration_Rep (Ent))),\n \n                 Statements => New_List (\n-                  Make_Return_Statement (Loc,\n+                  Make_Simple_Return_Statement (Loc,\n                     Expression =>\n                       Make_Integer_Literal (Loc,\n                         Intval => Enumeration_Pos (Ent))))));\n@@ -5000,7 +5098,7 @@ package body Exp_Ch3 is\n                Make_Raise_Constraint_Error (Loc,\n                  Condition => Make_Identifier (Loc, Name_uF),\n                  Reason    => CE_Invalid_Data),\n-               Make_Return_Statement (Loc,\n+               Make_Simple_Return_Statement (Loc,\n                  Expression =>\n                    Make_Integer_Literal (Loc, -1)))));\n \n@@ -5013,7 +5111,7 @@ package body Exp_Ch3 is\n            Make_Case_Statement_Alternative (Loc,\n              Discrete_Choices => New_List (Make_Others_Choice (Loc)),\n              Statements => New_List (\n-               Make_Return_Statement (Loc,\n+               Make_Simple_Return_Statement (Loc,\n                  Expression =>\n                    Make_Integer_Literal (Loc, -1)))));\n       end if;\n@@ -5068,12 +5166,18 @@ package body Exp_Ch3 is\n    ------------------------\n \n    procedure Freeze_Record_Type (N : Node_Id) is\n-      Comp        : Entity_Id;\n-      Def_Id      : constant Node_Id := Entity (N);\n-      Predef_List : List_Id;\n-      Type_Decl   : constant Node_Id := Parent (Def_Id);\n-\n-      Renamed_Eq  : Node_Id := Empty;\n+      Def_Id        : constant Node_Id := Entity (N);\n+      Type_Decl     : constant Node_Id := Parent (Def_Id);\n+      Comp          : Entity_Id;\n+      Comp_Typ      : Entity_Id;\n+      Has_Static_DT : Boolean := False;\n+      Predef_List   : List_Id;\n+\n+      Flist : Entity_Id := Empty;\n+      --  Finalization list allocated for the case of a type with anonymous\n+      --  access components whose designated type is potentially controlled.\n+\n+      Renamed_Eq : Node_Id := Empty;\n       --  Could use some comments ???\n \n       Wrapper_Decl_List   : List_Id := No_List;\n@@ -5082,11 +5186,11 @@ package body Exp_Ch3 is\n \n    begin\n       --  Build discriminant checking functions if not a derived type (for\n-      --  derived types that are not tagged types, we always use the\n-      --  discriminant checking functions of the parent type). However, for\n-      --  untagged types the derivation may have taken place before the\n-      --  parent was frozen, so we copy explicitly the discriminant checking\n-      --  functions from the parent into the components of the derived type.\n+      --  derived types that are not tagged types, always use the discriminant\n+      --  checking functions of the parent type). However, for untagged types\n+      --  the derivation may have taken place before the parent was frozen, so\n+      --  we copy explicitly the discriminant checking functions from the\n+      --  parent into the components of the derived type.\n \n       if not Is_Derived_Type (Def_Id)\n         or else Has_New_Non_Standard_Rep (Def_Id)\n@@ -5139,14 +5243,25 @@ package body Exp_Ch3 is\n       Comp := First_Component (Def_Id);\n \n       while Present (Comp) loop\n-         if Has_Task (Etype (Comp)) then\n+         Comp_Typ := Etype (Comp);\n+\n+         if Has_Task (Comp_Typ) then\n             Set_Has_Task (Def_Id);\n \n-         elsif Has_Controlled_Component (Etype (Comp))\n+         elsif Has_Controlled_Component (Comp_Typ)\n            or else (Chars (Comp) /= Name_uParent\n-                     and then Is_Controlled (Etype (Comp)))\n+                     and then Is_Controlled (Comp_Typ))\n          then\n             Set_Has_Controlled_Component (Def_Id);\n+\n+         elsif Ekind (Comp_Typ) = E_Anonymous_Access_Type\n+           and then Controlled_Type (Directly_Designated_Type (Comp_Typ))\n+         then\n+            if No (Flist) then\n+               Flist := Add_Final_Chain (Def_Id);\n+            end if;\n+\n+            Set_Associated_Final_Chain (Comp_Typ, Flist);\n          end if;\n \n          Next_Component (Comp);\n@@ -5159,31 +5274,28 @@ package body Exp_Ch3 is\n       --  just use it.\n \n       if Is_Tagged_Type (Def_Id) then\n+         Has_Static_DT :=\n+           Static_Dispatch_Tables\n+             and then Is_Library_Level_Tagged_Type (Def_Id);\n \n-         if Is_CPP_Class (Def_Id) then\n-\n-            --  Because of the new C++ ABI compatibility we now allow the\n-            --  programmer to use the Ada tag (and in this case we must do\n-            --  the normal expansion of the tag)\n+         --  Add the _Tag component\n \n-            if Etype (First_Component (Def_Id)) = RTE (RE_Tag)\n-              and then Underlying_Type (Etype (Def_Id)) = Def_Id\n-            then\n-               Expand_Tagged_Root (Def_Id);\n-            end if;\n+         if Underlying_Type (Etype (Def_Id)) = Def_Id then\n+            Expand_Tagged_Root (Def_Id);\n+         end if;\n \n+         if Is_CPP_Class (Def_Id) then\n             Set_All_DT_Position (Def_Id);\n             Set_Default_Constructor (Def_Id);\n \n-            --  With CPP_Class types Make_DT does a minimum decoration of the\n-            --  Access_Disp_Table list.\n+            --  Create the tag entities with a minimum decoration\n \n             if VM_Target = No_VM then\n-               Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n+               Append_Freeze_Actions (Def_Id, Make_Tags (Def_Id));\n             end if;\n \n          else\n-            if not Static_Dispatch_Tables then\n+            if not Has_Static_DT then\n \n                --  Usually inherited primitives are not delayed but the first\n                --  Ada extension of a CPP_Class is an exception since the\n@@ -5221,10 +5333,6 @@ package body Exp_Ch3 is\n                end;\n             end if;\n \n-            if Underlying_Type (Etype (Def_Id)) = Def_Id then\n-               Expand_Tagged_Root (Def_Id);\n-            end if;\n-\n             --  Unfreeze momentarily the type to add the predefined primitives\n             --  operations. The reason we unfreeze is so that these predefined\n             --  operations will indeed end up as primitive operations (which\n@@ -5280,12 +5388,22 @@ package body Exp_Ch3 is\n                Expand_Record_Controller (Def_Id);\n             end if;\n \n-            --  Build the dispatch table. Suppress its creation when VM_Target\n-            --  because the dispatching mechanism is handled internally by the\n-            --  VMs.\n+            --  Create and decorate the tags. Suppress their creation when\n+            --  VM_Target because the dispatching mechanism is handled\n+            --  internally by the VMs.\n \n             if VM_Target = No_VM then\n-               Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n+               Append_Freeze_Actions (Def_Id, Make_Tags (Def_Id));\n+\n+               --  Generate dispatch table of locally defined tagged type.\n+               --  Dispatch tables of library level tagged types are built\n+               --  later (see Analyze_Declarations).\n+\n+               if VM_Target = No_VM\n+                 and then not Has_Static_DT\n+               then\n+                  Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n+               end if;\n             end if;\n \n             --  Make sure that the primitives Initialize, Adjust and Finalize\n@@ -5409,19 +5527,6 @@ package body Exp_Ch3 is\n          if Present (Wrapper_Body_List) then\n             Append_Freeze_Actions (Def_Id, Wrapper_Body_List);\n          end if;\n-\n-         --  Populate the two auxiliary tables used for dispatching\n-         --  asynchronous, conditional and timed selects for synchronized\n-         --  types that implement a limited interface.\n-\n-         if Ada_Version >= Ada_05\n-           and then not Restriction_Active (No_Dispatching_Calls)\n-           and then Is_Concurrent_Record_Type (Def_Id)\n-           and then Has_Abstract_Interfaces (Def_Id)\n-         then\n-            Append_Freeze_Actions (Def_Id,\n-              Make_Select_Specific_Data_Table (Def_Id));\n-         end if;\n       end if;\n    end Freeze_Record_Type;\n \n@@ -5786,15 +5891,7 @@ package body Exp_Ch3 is\n \n               or else Has_Controlled_Coextensions (Desig_Type)\n             then\n-               Set_Associated_Final_Chain (Def_Id,\n-                 Make_Defining_Identifier (Loc,\n-                   New_External_Name (Chars (Def_Id), 'L')));\n-\n-               Append_Freeze_Action (Def_Id,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Associated_Final_Chain (Def_Id),\n-                   Object_Definition   =>\n-                     New_Reference_To (RTE (RE_List_Controller), Loc)));\n+               Set_Associated_Final_Chain (Def_Id, Add_Final_Chain (Def_Id));\n             end if;\n          end;\n \n@@ -6337,33 +6434,58 @@ package body Exp_Ch3 is\n    -------------------------\n \n    procedure Init_Secondary_Tags\n-     (Typ        : Entity_Id;\n-      Target     : Node_Id;\n-      Stmts_List : List_Id)\n+     (Typ            : Entity_Id;\n+      Target         : Node_Id;\n+      Stmts_List     : List_Id;\n+      Fixed_Comps    : Boolean := True;\n+      Variable_Comps : Boolean := True)\n    is\n-      Loc         : constant Source_Ptr := Sloc (Target);\n-      ADT         : Elmt_Id;\n-      Full_Typ    : Entity_Id;\n-      AI_Tag_Comp : Entity_Id;\n+      Loc : constant Source_Ptr := Sloc (Target);\n \n-      Is_Synch_Typ : Boolean := False;\n-      --  In case of non concurrent-record-types each parent-type has the\n-      --  tags associated with the interface types that are not implemented\n-      --  by the ancestors; concurrent-record-types have their whole list of\n-      --  interface tags (and this case requires some special management).\n+      procedure Inherit_CPP_Tag\n+        (Typ       : Entity_Id;\n+         Iface     : Entity_Id;\n+         Tag_Comp  : Entity_Id;\n+         Iface_Tag : Node_Id);\n+      --  Inherit the C++ tag of the secondary dispatch table of Typ associated\n+      --  with Iface. Tag_Comp is the component of Typ that stores Iface_Tag.\n \n       procedure Initialize_Tag\n         (Typ       : Entity_Id;\n          Iface     : Entity_Id;\n-         Tag_Comp  : in out Entity_Id;\n+         Tag_Comp  : Entity_Id;\n          Iface_Tag : Node_Id);\n       --  Initialize the tag of the secondary dispatch table of Typ associated\n       --  with Iface. Tag_Comp is the component of Typ that stores Iface_Tag.\n+      --  Compiling under the CPP full ABI compatibility mode, if the ancestor\n+      --  of Typ CPP tagged type we generate code to inherit the contents of\n+      --  the dispatch table directly from the ancestor.\n \n-      procedure Init_Secondary_Tags_Internal (Typ : Entity_Id);\n-      --  Internal subprogram used to recursively climb to the root type.\n-      --  We assume that all the primitives of the imported C++ class are\n-      --  defined in the C side.\n+      ---------------------\n+      -- Inherit_CPP_Tag --\n+      ---------------------\n+\n+      procedure Inherit_CPP_Tag\n+        (Typ       : Entity_Id;\n+         Iface     : Entity_Id;\n+         Tag_Comp  : Entity_Id;\n+         Iface_Tag : Node_Id)\n+      is\n+      begin\n+         pragma Assert (Is_CPP_Class (Etype (Typ)));\n+\n+         Append_To (Stmts_List,\n+           Build_Inherit_Prims (Loc,\n+             Typ          => Iface,\n+             Old_Tag_Node =>\n+               Make_Selected_Component (Loc,\n+                 Prefix        => New_Copy_Tree (Target),\n+                 Selector_Name => New_Reference_To (Tag_Comp, Loc)),\n+             New_Tag_Node =>\n+               New_Reference_To (Iface_Tag, Loc),\n+             Num_Prims    =>\n+               UI_To_Int (DT_Entry_Count (First_Tag_Component (Iface)))));\n+      end Inherit_CPP_Tag;\n \n       --------------------\n       -- Initialize_Tag --\n@@ -6372,261 +6494,166 @@ package body Exp_Ch3 is\n       procedure Initialize_Tag\n         (Typ       : Entity_Id;\n          Iface     : Entity_Id;\n-         Tag_Comp  : in out Entity_Id;\n+         Tag_Comp  : Entity_Id;\n          Iface_Tag : Node_Id)\n       is\n-         Prev_E : Entity_Id;\n+         Comp_Typ           : Entity_Id;\n+         Offset_To_Top_Comp : Entity_Id := Empty;\n \n       begin\n-         --  If we are compiling under the CPP full ABI compatibility mode and\n-         --  the ancestor is a CPP_Pragma tagged type then we generate code to\n-         --  inherit the contents of the dispatch table directly from the\n-         --  ancestor.\n+         --  Initialize the pointer to the secondary DT associated with the\n+         --  interface.\n \n-         if Is_CPP_Class (Etype (Typ)) then\n+         if not Is_Parent (Iface, Typ) then\n             Append_To (Stmts_List,\n-              Build_Inherit_Prims (Loc,\n-                Old_Tag_Node =>\n+              Make_Assignment_Statement (Loc,\n+                Name =>\n                   Make_Selected_Component (Loc,\n-                    Prefix        => New_Copy_Tree (Target),\n+                    Prefix => New_Copy_Tree (Target),\n                     Selector_Name => New_Reference_To (Tag_Comp, Loc)),\n-                New_Tag_Node =>\n-                  New_Reference_To (Iface_Tag, Loc),\n-                Num_Prims =>\n-                  UI_To_Int\n-                    (DT_Entry_Count (First_Tag_Component (Iface)))));\n+                Expression =>\n+                  New_Reference_To (Iface_Tag, Loc)));\n          end if;\n \n-         --  Initialize the pointer to the secondary DT associated with the\n-         --  interface.\n-\n-         Append_To (Stmts_List,\n-           Make_Assignment_Statement (Loc,\n-             Name =>\n-               Make_Selected_Component (Loc,\n-                 Prefix => New_Copy_Tree (Target),\n-                 Selector_Name => New_Reference_To (Tag_Comp, Loc)),\n-             Expression =>\n-               New_Reference_To (Iface_Tag, Loc)));\n+         --  Issue error if Set_Offset_To_Top is not available in a\n+         --  configurable run-time environment.\n \n-         --  If the ancestor is CPP_Class, nothing else to do here\n-\n-         if Is_CPP_Class (Etype (Typ)) then\n-            null;\n-\n-         --  Otherwise, comment required ???\n-\n-         else\n-            --  Issue error if Set_Offset_To_Top is not available in a\n-            --  configurable run-time environment.\n-\n-            if not RTE_Available (RE_Set_Offset_To_Top) then\n-               Error_Msg_CRT (\"abstract interface types\", Typ);\n-               return;\n-            end if;\n+         if not RTE_Available (RE_Set_Offset_To_Top) then\n+            Error_Msg_CRT (\"abstract interface types\", Typ);\n+            return;\n+         end if;\n \n-            --  We generate a different call when the parent of the type has\n-            --  discriminants.\n+         Comp_Typ := Scope (Tag_Comp);\n \n-            if Typ /= Etype (Typ)\n-              and then Has_Discriminants (Etype (Typ))\n-            then\n-               pragma Assert\n-                 (Present (DT_Offset_To_Top_Func (Tag_Comp)));\n-\n-               --  Generate:\n-               --    Set_Offset_To_Top\n-               --      (This         => Init,\n-               --       Interface_T  => Iface'Tag,\n-               --       Is_Constant  => False,\n-               --       Offset_Value => n,\n-               --       Offset_Func  => Fn'Address)\n-\n-               Append_To (Stmts_List,\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Reference_To\n-                             (RTE (RE_Set_Offset_To_Top), Loc),\n-                   Parameter_Associations => New_List (\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix => New_Copy_Tree (Target),\n-                       Attribute_Name => Name_Address),\n+         --  Initialize the entries of the table of interfaces. We generate a\n+         --  different call when the parent of the type has variable size\n+         --  components.\n \n-                     Unchecked_Convert_To (RTE (RE_Tag),\n-                       New_Reference_To\n-                         (Node (First_Elmt (Access_Disp_Table (Iface))),\n-                          Loc)),\n+         if Comp_Typ /= Etype (Comp_Typ)\n+           and then Is_Variable_Size_Record (Etype (Comp_Typ))\n+           and then Chars (Tag_Comp) /= Name_uTag\n+         then\n+            pragma Assert\n+              (Present (DT_Offset_To_Top_Func (Tag_Comp)));\n \n-                     New_Occurrence_Of (Standard_False, Loc),\n+            --  Generate:\n+            --    Set_Offset_To_Top\n+            --      (This         => Init,\n+            --       Interface_T  => Iface'Tag,\n+            --       Is_Constant  => False,\n+            --       Offset_Value => n,\n+            --       Offset_Func  => Fn'Address)\n \n-                     Unchecked_Convert_To\n-                       (RTE (RE_Storage_Offset),\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix         =>\n-                            Make_Selected_Component (Loc,\n-                              Prefix => New_Copy_Tree (Target),\n-                              Selector_Name =>\n-                                New_Reference_To (Tag_Comp, Loc)),\n-                          Attribute_Name => Name_Position)),\n-\n-                     Unchecked_Convert_To (RTE (RE_Offset_To_Top_Function_Ptr),\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix => New_Reference_To\n-                                     (DT_Offset_To_Top_Func (Tag_Comp), Loc),\n-                         Attribute_Name => Name_Address)))));\n+            Append_To (Stmts_List,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Reference_To (RTE (RE_Set_Offset_To_Top), Loc),\n+                Parameter_Associations => New_List (\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix => New_Copy_Tree (Target),\n+                    Attribute_Name => Name_Address),\n \n-               --  In this case the next component stores the value of the\n-               --  offset to the top.\n+                  Unchecked_Convert_To (RTE (RE_Tag),\n+                    New_Reference_To\n+                      (Node (First_Elmt (Access_Disp_Table (Iface))),\n+                       Loc)),\n \n-               Prev_E := Tag_Comp;\n-               Next_Entity (Tag_Comp);\n-               pragma Assert (Present (Tag_Comp));\n+                  New_Occurrence_Of (Standard_False, Loc),\n \n-               Append_To (Stmts_List,\n-                 Make_Assignment_Statement (Loc,\n-                   Name =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix => New_Copy_Tree (Target),\n-                       Selector_Name => New_Reference_To (Tag_Comp, Loc)),\n-                   Expression =>\n+                  Unchecked_Convert_To\n+                    (RTE (RE_Storage_Offset),\n                      Make_Attribute_Reference (Loc,\n                        Prefix         =>\n                          Make_Selected_Component (Loc,\n                            Prefix => New_Copy_Tree (Target),\n                            Selector_Name =>\n-                             New_Reference_To (Prev_E, Loc)),\n-                     Attribute_Name => Name_Position)));\n+                             New_Reference_To (Tag_Comp, Loc)),\n+                       Attribute_Name => Name_Position)),\n \n-            --  Normal case: No discriminants in the parent type\n-\n-            else\n-               --  Generate:\n-               --    Set_Offset_To_Top\n-               --      (This         => Init,\n-               --       Interface_T  => Iface'Tag,\n-               --       Is_Constant  => True,\n-               --       Offset_Value => n,\n-               --       Offset_Func  => null);\n-\n-               Append_To (Stmts_List,\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Reference_To\n-                             (RTE (RE_Set_Offset_To_Top), Loc),\n-                   Parameter_Associations => New_List (\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix => New_Copy_Tree (Target),\n-                       Attribute_Name => Name_Address),\n-\n-                     Unchecked_Convert_To (RTE (RE_Tag),\n-                       New_Reference_To\n-                         (Node (First_Elmt\n-                                (Access_Disp_Table (Iface))),\n-                          Loc)),\n-\n-                     New_Occurrence_Of (Standard_True, Loc),\n-\n-                     Unchecked_Convert_To\n-                       (RTE (RE_Storage_Offset),\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix =>\n-                            Make_Selected_Component (Loc,\n-                              Prefix => New_Copy_Tree (Target),\n-                              Selector_Name  =>\n-                                New_Reference_To (Tag_Comp, Loc)),\n-                         Attribute_Name => Name_Position)),\n-\n-                     Make_Null (Loc))));\n-            end if;\n-         end if;\n-      end Initialize_Tag;\n-\n-      ----------------------------------\n-      -- Init_Secondary_Tags_Internal --\n-      ----------------------------------\n-\n-      procedure Init_Secondary_Tags_Internal (Typ : Entity_Id) is\n-         AI_Elmt : Elmt_Id;\n-\n-      begin\n-         --  Climb to the ancestor (if any) handling synchronized interface\n-         --  derivations and private types\n+                  Unchecked_Convert_To (RTE (RE_Offset_To_Top_Function_Ptr),\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix => New_Reference_To\n+                                  (DT_Offset_To_Top_Func (Tag_Comp), Loc),\n+                      Attribute_Name => Name_Address)))));\n \n-         if Is_Concurrent_Record_Type (Typ) then\n-            declare\n-               Iface_List : constant List_Id := Abstract_Interface_List (Typ);\n+            --  In this case the next component stores the value of the\n+            --  offset to the top.\n \n-            begin\n-               if Is_Non_Empty_List (Iface_List) then\n-                  Init_Secondary_Tags_Internal (Etype (First (Iface_List)));\n-               end if;\n-            end;\n+            Offset_To_Top_Comp := Next_Entity (Tag_Comp);\n+            pragma Assert (Present (Offset_To_Top_Comp));\n \n-         elsif Present (Full_View (Etype (Typ))) then\n-            if Full_View (Etype (Typ)) /= Typ then\n-               Init_Secondary_Tags_Internal (Full_View (Etype (Typ)));\n-            end if;\n+            Append_To (Stmts_List,\n+              Make_Assignment_Statement (Loc,\n+                Name =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix => New_Copy_Tree (Target),\n+                    Selector_Name => New_Reference_To\n+                                       (Offset_To_Top_Comp, Loc)),\n+                Expression =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         =>\n+                      Make_Selected_Component (Loc,\n+                        Prefix => New_Copy_Tree (Target),\n+                        Selector_Name =>\n+                          New_Reference_To (Tag_Comp, Loc)),\n+                  Attribute_Name => Name_Position)));\n \n-         elsif Etype (Typ) /= Typ then\n-            Init_Secondary_Tags_Internal (Etype (Typ));\n-         end if;\n+         --  Normal case: No discriminants in the parent type\n \n-         if Is_Interface (Typ) then\n+         else\n             --  Generate:\n             --    Set_Offset_To_Top\n             --      (This         => Init,\n             --       Interface_T  => Iface'Tag,\n             --       Is_Constant  => True,\n-            --       Offset_Value => 0,\n-            --       Offset_Func  => null)\n+            --       Offset_Value => n,\n+            --       Offset_Func  => null);\n \n             Append_To (Stmts_List,\n               Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (RTE (RE_Set_Offset_To_Top), Loc),\n+                Name => New_Reference_To\n+                          (RTE (RE_Set_Offset_To_Top), Loc),\n                 Parameter_Associations => New_List (\n                   Make_Attribute_Reference (Loc,\n                     Prefix => New_Copy_Tree (Target),\n                     Attribute_Name => Name_Address),\n+\n                   Unchecked_Convert_To (RTE (RE_Tag),\n                     New_Reference_To\n-                      (Node (First_Elmt (Access_Disp_Table (Typ))),\n+                      (Node (First_Elmt\n+                             (Access_Disp_Table (Iface))),\n                        Loc)),\n+\n                   New_Occurrence_Of (Standard_True, Loc),\n-                  Make_Integer_Literal (Loc, Uint_0),\n-                  Make_Null (Loc))));\n-         end if;\n \n-         if Present (Abstract_Interfaces (Typ))\n-           and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n-         then\n-            if not Is_Synch_Typ then\n-               AI_Tag_Comp := Next_Tag_Component (First_Tag_Component (Typ));\n-               pragma Assert (Present (AI_Tag_Comp));\n-            end if;\n+                  Unchecked_Convert_To\n+                    (RTE (RE_Storage_Offset),\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix =>\n+                         Make_Selected_Component (Loc,\n+                           Prefix => New_Copy_Tree (Target),\n+                           Selector_Name  =>\n+                             New_Reference_To (Tag_Comp, Loc)),\n+                      Attribute_Name => Name_Position)),\n \n-            AI_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n-            while Present (AI_Elmt) loop\n-               pragma Assert (Present (Node (ADT)));\n+                  Make_Null (Loc))));\n+         end if;\n+      end Initialize_Tag;\n \n-               Initialize_Tag\n-                 (Typ       => Typ,\n-                  Iface     => Node (AI_Elmt),\n-                  Tag_Comp  => AI_Tag_Comp,\n-                  Iface_Tag => Node (ADT));\n+      --  Local variables\n \n-               Next_Elmt (ADT);\n-               AI_Tag_Comp := Next_Tag_Component (AI_Tag_Comp);\n-               Next_Elmt (AI_Elmt);\n-            end loop;\n-         end if;\n-      end Init_Secondary_Tags_Internal;\n+      Full_Typ         : Entity_Id;\n+      Ifaces_List      : Elist_Id;\n+      Ifaces_Comp_List : Elist_Id;\n+      Ifaces_Tag_List  : Elist_Id;\n+      Iface_Elmt       : Elmt_Id;\n+      Iface_Comp_Elmt  : Elmt_Id;\n+      Iface_Tag_Elmt   : Elmt_Id;\n+      Tag_Comp         : Node_Id;\n+      In_Variable_Pos  : Boolean;\n \n    --  Start of processing for Init_Secondary_Tags\n \n    begin\n-      --  Skip the first _Tag, which is the main tag of the tagged type.\n-      --  Following tags correspond with abstract interfaces.\n-\n-      ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n-\n       --  Handle private types\n \n       if Present (Full_View (Typ)) then\n@@ -6635,14 +6662,106 @@ package body Exp_Ch3 is\n          Full_Typ := Typ;\n       end if;\n \n-      if Is_Concurrent_Record_Type (Typ) then\n-         Is_Synch_Typ := True;\n-         AI_Tag_Comp  := Next_Tag_Component (First_Tag_Component (Typ));\n-      end if;\n+      Collect_Interfaces_Info\n+        (Full_Typ, Ifaces_List, Ifaces_Comp_List, Ifaces_Tag_List);\n \n-      Init_Secondary_Tags_Internal (Full_Typ);\n+      Iface_Elmt      := First_Elmt (Ifaces_List);\n+      Iface_Comp_Elmt := First_Elmt (Ifaces_Comp_List);\n+      Iface_Tag_Elmt  := First_Elmt (Ifaces_Tag_List);\n+      while Present (Iface_Elmt) loop\n+         Tag_Comp := Node (Iface_Comp_Elmt);\n+\n+         --  If we are compiling under the CPP full ABI compatibility mode and\n+         --  the ancestor is a CPP_Pragma tagged type then we generate code to\n+         --  inherit the contents of the dispatch table directly from the\n+         --  ancestor.\n+\n+         if Is_CPP_Class (Etype (Full_Typ)) then\n+            Inherit_CPP_Tag (Full_Typ,\n+              Iface     => Node (Iface_Elmt),\n+              Tag_Comp  => Tag_Comp,\n+              Iface_Tag => Node (Iface_Tag_Elmt));\n+\n+         --  Otherwise we generate code to initialize the tag\n+\n+         else\n+            --  Check if the parent of the record type has variable size\n+            --  components.\n+\n+            In_Variable_Pos := Scope (Tag_Comp) /= Etype (Scope (Tag_Comp))\n+              and then Is_Variable_Size_Record (Etype (Scope (Tag_Comp)));\n+\n+            if (In_Variable_Pos and then Variable_Comps)\n+              or else (not In_Variable_Pos and then Fixed_Comps)\n+            then\n+               Initialize_Tag (Full_Typ,\n+                 Iface     => Node (Iface_Elmt),\n+                 Tag_Comp  => Tag_Comp,\n+                 Iface_Tag => Node (Iface_Tag_Elmt));\n+            end if;\n+         end if;\n+\n+         Next_Elmt (Iface_Elmt);\n+         Next_Elmt (Iface_Comp_Elmt);\n+         Next_Elmt (Iface_Tag_Elmt);\n+      end loop;\n    end Init_Secondary_Tags;\n \n+   -----------------------------\n+   -- Is_Variable_Size_Record --\n+   -----------------------------\n+\n+   function Is_Variable_Size_Record (E : Entity_Id) return Boolean is\n+      Comp     : Entity_Id;\n+      Comp_Typ : Entity_Id;\n+      Idx      : Node_Id;\n+\n+   begin\n+      pragma Assert (Is_Record_Type (E));\n+\n+      Comp := First_Entity (E);\n+      while Present (Comp) loop\n+         Comp_Typ := Etype (Comp);\n+\n+         if Is_Record_Type (Comp_Typ) then\n+\n+            --  Recursive call if the record type has discriminants\n+\n+            if Has_Discriminants (Comp_Typ)\n+              and then Is_Variable_Size_Record (Comp_Typ)\n+            then\n+               return True;\n+            end if;\n+\n+         elsif Is_Array_Type (Comp_Typ) then\n+\n+            --  Check if some index is initialized with a non-constant value\n+\n+            Idx := First_Index (Comp_Typ);\n+            while Present (Idx) loop\n+               if Nkind (Idx) = N_Range then\n+                  if (Nkind (Low_Bound (Idx)) = N_Identifier\n+                      and then Present (Entity (Low_Bound (Idx)))\n+                      and then Ekind (Entity (Low_Bound (Idx))) /= E_Constant)\n+                    or else\n+                     (Nkind (High_Bound (Idx)) = N_Identifier\n+                      and then Present (Entity (High_Bound (Idx)))\n+                      and then Ekind (Entity (High_Bound (Idx))) /= E_Constant)\n+                  then\n+                     return True;\n+                  end if;\n+               end if;\n+\n+               Idx := Next_Index (Idx);\n+            end loop;\n+         end if;\n+\n+         Next_Entity (Comp);\n+      end loop;\n+\n+      return False;\n+   end Is_Variable_Size_Record;\n+\n    ----------------------------------------\n    -- Make_Controlling_Function_Wrappers --\n    ----------------------------------------\n@@ -6684,19 +6803,28 @@ package body Exp_Ch3 is\n          --  Input constructed by the expander. The test for Comes_From_Source\n          --  is needed to distinguish inherited operations from renamings\n          --  (which also have Alias set).\n+\n          --  The function may be abstract, or require_Overriding may be set\n          --  for it, because tests for null extensions may already have reset\n-         --  the Is_Abstract_Subprogram_Flag.\n-\n-         if (Is_Abstract_Subprogram (Subp)\n-               or else Requires_Overriding (Subp))\n-           and then Present (Alias (Subp))\n-           and then not Is_Abstract_Subprogram (Alias (Subp))\n-           and then not Comes_From_Source (Subp)\n-           and then Ekind (Subp) = E_Function\n-           and then Has_Controlling_Result (Subp)\n-           and then not Is_Access_Type (Etype (Subp))\n-           and then not Is_TSS (Subp, TSS_Stream_Input)\n+         --  the Is_Abstract_Subprogram_Flag. If Requires_Overriding is not\n+         --  set, functions that need wrappers are recognized by having an\n+         --  alias that returns the parent type.\n+\n+         if Comes_From_Source (Subp)\n+           or else No (Alias (Subp))\n+           or else Ekind (Subp) /= E_Function\n+           or else not Has_Controlling_Result (Subp)\n+           or else Is_Access_Type (Etype (Subp))\n+           or else Is_Abstract_Subprogram (Alias (Subp))\n+           or else Is_TSS (Subp, TSS_Stream_Input)\n+         then\n+            goto Next_Prim;\n+\n+         elsif Is_Abstract_Subprogram (Subp)\n+           or else Requires_Overriding (Subp)\n+           or else\n+             (Is_Null_Extension (Etype (Subp))\n+               and then Etype (Alias (Subp)) /= Etype (Subp))\n          then\n             Formal_List := No_List;\n             Formal := First_Formal (Subp);\n@@ -6713,6 +6841,8 @@ package body Exp_Ch3 is\n                             Chars => Chars (Formal)),\n                         In_Present  => In_Present (Parent (Formal)),\n                         Out_Present => Out_Present (Parent (Formal)),\n+                        Null_Exclusion_Present =>\n+                          Null_Exclusion_Present (Parent (Formal)),\n                         Parameter_Type =>\n                           New_Reference_To (Etype (Formal), Loc),\n                         Expression =>\n@@ -6725,11 +6855,11 @@ package body Exp_Ch3 is\n \n             Func_Spec :=\n               Make_Function_Specification (Loc,\n-                Defining_Unit_Name =>\n-                  Make_Defining_Identifier (Loc, Chars (Subp)),\n-                Parameter_Specifications =>\n-                  Formal_List,\n-                Result_Definition =>\n+                Defining_Unit_Name       =>\n+                  Make_Defining_Identifier (Loc,\n+                    Chars => Chars (Subp)),\n+                Parameter_Specifications => Formal_List,\n+                Result_Definition        =>\n                   New_Reference_To (Etype (Subp), Loc));\n \n             Func_Decl := Make_Subprogram_Declaration (Loc, Func_Spec);\n@@ -6775,7 +6905,7 @@ package body Exp_Ch3 is\n             end loop;\n \n             Return_Stmt :=\n-              Make_Return_Statement (Loc,\n+              Make_Simple_Return_Statement (Loc,\n                 Expression =>\n                   Make_Extension_Aggregate (Loc,\n                     Ancestor_Part =>\n@@ -6805,6 +6935,7 @@ package body Exp_Ch3 is\n               (Tag_Typ, Subp, New_Op => Defining_Unit_Name (Func_Spec));\n          end if;\n \n+      <<Next_Prim>>\n          Next_Elmt (Prim_Elmt);\n       end loop;\n    end Make_Controlling_Function_Wrappers;\n@@ -6951,7 +7082,7 @@ package body Exp_Ch3 is\n               Make_Implicit_If_Statement (E,\n                 Condition => Cond,\n                 Then_Statements => New_List (\n-                  Make_Return_Statement (Loc,\n+                  Make_Simple_Return_Statement (Loc,\n                     Expression => New_Occurrence_Of (Standard_False, Loc))));\n          end if;\n       end if;\n@@ -7021,6 +7152,8 @@ package body Exp_Ch3 is\n                            Chars => Chars (Formal)),\n                        In_Present  => In_Present (Parent (Formal)),\n                        Out_Present => Out_Present (Parent (Formal)),\n+                       Null_Exclusion_Present =>\n+                         Null_Exclusion_Present (Parent (Formal)),\n                        Parameter_Type =>\n                          New_Reference_To (Etype (Formal), Loc),\n                        Expression =>\n@@ -7591,7 +7724,7 @@ package body Exp_Ch3 is\n \n       Set_Handled_Statement_Sequence (Decl,\n         Make_Handled_Sequence_Of_Statements (Loc, New_List (\n-          Make_Return_Statement (Loc,\n+          Make_Simple_Return_Statement (Loc,\n             Expression =>\n               Make_Attribute_Reference (Loc,\n                 Prefix => Make_Identifier (Loc, Name_X),\n@@ -7614,7 +7747,7 @@ package body Exp_Ch3 is\n \n       Set_Handled_Statement_Sequence (Decl,\n         Make_Handled_Sequence_Of_Statements (Loc, New_List (\n-          Make_Return_Statement (Loc,\n+          Make_Simple_Return_Statement (Loc,\n             Expression =>\n               Make_Attribute_Reference (Loc,\n                 Prefix => Make_Identifier (Loc, Name_X),\n@@ -7741,12 +7874,12 @@ package body Exp_Ch3 is\n                     Make_Eq_If (Tag_Typ, Discriminant_Specifications (Def)));\n                   Append_List_To (Stmts, Make_Eq_Case (Tag_Typ, Comps));\n                   Append_To (Stmts,\n-                    Make_Return_Statement (Loc,\n+                    Make_Simple_Return_Statement (Loc,\n                       Expression => New_Reference_To (Standard_True, Loc)));\n \n                else\n                   Append_To (Stmts,\n-                    Make_Return_Statement (Loc,\n+                    Make_Simple_Return_Statement (Loc,\n                       Expression =>\n                         Expand_Record_Equality (Tag_Typ,\n                           Typ => Tag_Typ,"}, {"sha": "64858c0d50a8ca58659e4972c6e87d38d92ad821", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04df6250f65043292762291a9e5d8092f8117318/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04df6250f65043292762291a9e5d8092f8117318/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=04df6250f65043292762291a9e5d8092f8117318", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -111,12 +111,17 @@ package Exp_Ch3 is\n    --  since it would confuse any remaining processing of the freeze node.\n \n    procedure Init_Secondary_Tags\n-     (Typ        : Entity_Id;\n-      Target     : Node_Id;\n-      Stmts_List : List_Id);\n-   --  Ada 2005 (AI-251): Initialize the tags of all the secondary tables\n-   --  associated with the abstract interfaces of Typ. The generated code\n-   --  referencing tag fields of Target is appended to Stmts_List.\n+     (Typ            : Entity_Id;\n+      Target         : Node_Id;\n+      Stmts_List     : List_Id;\n+      Fixed_Comps    : Boolean := True;\n+      Variable_Comps : Boolean := True);\n+   --  Ada 2005 (AI-251): Initialize the tags of the secondary dispatch tables\n+   --  of Typ. The generated code referencing tag fields of Target is appended\n+   --  to Stmts_List. If Fixed_Comps is True then the tag components located at\n+   --  fixed positions of Target are initialized; if Variable_Comps is True\n+   --  then tags components located at variable positions of Target are\n+   --  initialized.\n \n    function Needs_Simple_Initialization (T : Entity_Id) return Boolean;\n    --  Certain types need initialization even though there is no specific"}, {"sha": "077240ca131454b547a8a94d62b7c0b4bd0ef4dc", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 178, "deletions": 36, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04df6250f65043292762291a9e5d8092f8117318/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04df6250f65043292762291a9e5d8092f8117318/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=04df6250f65043292762291a9e5d8092f8117318", "patch": "@@ -161,6 +161,29 @@ package body Sem_Type is\n    pragma Warnings (Off, All_Overloads);\n    --  Debugging procedure: list full contents of Overloads table\n \n+   function Binary_Op_Interp_Has_Abstract_Op\n+     (N : Node_Id;\n+      E : Entity_Id) return Entity_Id;\n+   --  Given the node and entity of a binary operator, determine whether the\n+   --  actuals of E contain an abstract interpretation with regards to the\n+   --  types of their corresponding formals. Return the abstract operation or\n+   --  Empty.\n+\n+   function Function_Interp_Has_Abstract_Op\n+     (N : Node_Id;\n+      E : Entity_Id) return Entity_Id;\n+   --  Given the node and entity of a function call, determine whether the\n+   --  actuals of E contain an abstract interpretation with regards to the\n+   --  types of their corresponding formals. Return the abstract operation or\n+   --  Empty.\n+\n+   function Has_Abstract_Op\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Entity_Id;\n+   --  Subsidiary routine to Binary_Op_Interp_Has_Abstract_Op and Function_\n+   --  Interp_Has_Abstract_Op. Determine whether an overloaded node has an\n+   --  abstract interpretation which yields type Typ.\n+\n    procedure New_Interps (N : Node_Id);\n    --  Initialize collection of interpretations for the given node, which is\n    --  either an overloaded entity, or an operation whose arguments have\n@@ -183,10 +206,10 @@ package body Sem_Type is\n    is\n       Vis_Type : Entity_Id;\n \n-      procedure Add_Entry (Name :  Entity_Id; Typ : Entity_Id);\n-      --  Add one interpretation to node. Node is already known to be\n-      --  overloaded. Add new interpretation if not hidden by previous\n-      --  one, and remove previous one if hidden by new one.\n+      procedure Add_Entry (Name : Entity_Id; Typ : Entity_Id);\n+      --  Add one interpretation to an overloaded node. Add a new entry if\n+      --  not hidden by previous one, and remove previous one if hidden by\n+      --  new one.\n \n       function Is_Universal_Operation (Op : Entity_Id) return Boolean;\n       --  True if the entity is a predefined operator and the operands have\n@@ -196,12 +219,26 @@ package body Sem_Type is\n       -- Add_Entry --\n       ---------------\n \n-      procedure Add_Entry (Name :  Entity_Id; Typ : Entity_Id) is\n-         Index : Interp_Index;\n-         It    : Interp;\n+      procedure Add_Entry (Name : Entity_Id; Typ : Entity_Id) is\n+         Abstr_Op : Entity_Id := Empty;\n+         I        : Interp_Index;\n+         It       : Interp;\n+\n+      --  Start of processing for Add_Entry\n \n       begin\n-         Get_First_Interp (N, Index, It);\n+         --  Find out whether the new entry references interpretations that\n+         --  are abstract or disabled by abstract operators.\n+\n+         if Ada_Version >= Ada_05 then\n+            if Nkind (N) in N_Binary_Op then\n+               Abstr_Op := Binary_Op_Interp_Has_Abstract_Op (N, Name);\n+            elsif Nkind (N) = N_Function_Call then\n+               Abstr_Op := Function_Interp_Has_Abstract_Op (N, Name);\n+            end if;\n+         end if;\n+\n+         Get_First_Interp (N, I, It);\n          while Present (It.Nam) loop\n \n             --  A user-defined subprogram hides another declared at an outer\n@@ -254,7 +291,7 @@ package body Sem_Type is\n                   end if;\n \n                else\n-                  All_Interp.Table (Index).Nam := Name;\n+                  All_Interp.Table (I).Nam := Name;\n                   return;\n                end if;\n \n@@ -268,15 +305,12 @@ package body Sem_Type is\n             --  Otherwise keep going\n \n             else\n-               Get_Next_Interp (Index, It);\n+               Get_Next_Interp (I, It);\n             end if;\n \n          end loop;\n \n-         --  On exit, enter new interpretation. The context, or a preference\n-         --  rule, will resolve the ambiguity on the second pass.\n-\n-         All_Interp.Table (All_Interp.Last) := (Name, Typ);\n+         All_Interp.Table (All_Interp.Last) := (Name, Typ, Abstr_Op);\n          All_Interp.Increment_Last;\n          All_Interp.Table (All_Interp.Last) := No_Interp;\n       end Add_Entry;\n@@ -501,6 +535,27 @@ package body Sem_Type is\n       end loop;\n    end All_Overloads;\n \n+   --------------------------------------\n+   -- Binary_Op_Interp_Has_Abstract_Op --\n+   --------------------------------------\n+\n+   function Binary_Op_Interp_Has_Abstract_Op\n+     (N : Node_Id;\n+      E : Entity_Id) return Entity_Id\n+   is\n+      Abstr_Op : Entity_Id;\n+      E_Left   : constant Node_Id := First_Formal (E);\n+      E_Right  : constant Node_Id := Next_Formal (E_Left);\n+\n+   begin\n+      Abstr_Op := Has_Abstract_Op (Left_Opnd (N), Etype (E_Left));\n+      if Present (Abstr_Op) then\n+         return Abstr_Op;\n+      end if;\n+\n+      return Has_Abstract_Op (Right_Opnd (N), Etype (E_Right));\n+   end Binary_Op_Interp_Has_Abstract_Op;\n+\n    ---------------------\n    -- Collect_Interps --\n    ---------------------\n@@ -567,7 +622,8 @@ package body Sem_Type is\n                         and then In_Instance\n                         and then not Is_Inherited_Operation (H)\n                      then\n-                        All_Interp.Table (All_Interp.Last) := (H, Etype (H));\n+                        All_Interp.Table (All_Interp.Last) :=\n+                          (H, Etype (H), Empty);\n                         All_Interp.Increment_Last;\n                         All_Interp.Table (All_Interp.Last) := No_Interp;\n                         goto Next_Homograph;\n@@ -821,9 +877,11 @@ package body Sem_Type is\n          return True;\n \n       --  If the expected type is an anonymous access, the designated type must\n-      --  cover that of the expression.\n+      --  cover that of the expression. Use the base type for this check: even\n+      --  though access subtypes are rare in sources, they are generated for\n+      --  actuals in instantiations.\n \n-      elsif Ekind (T1) = E_Anonymous_Access_Type\n+      elsif Ekind (BT1) = E_Anonymous_Access_Type\n         and then Is_Access_Type (T2)\n         and then Covers (Designated_Type (T1), Designated_Type (T2))\n       then\n@@ -987,10 +1045,11 @@ package body Sem_Type is\n       elsif From_With_Type (T1) then\n \n          --  If the expected type is the non-limited view of a type, the\n-         --  expression may have the limited view.\n+         --  expression may have the limited view. If that one in turn is\n+         --  incomplete, get full view if available.\n \n          if Is_Incomplete_Type (T1) then\n-            return Covers (Non_Limited_View (T1), T2);\n+            return Covers (Get_Full_View (Non_Limited_View (T1)), T2);\n \n          elsif Ekind (T1) = E_Class_Wide_Type then\n             return\n@@ -1006,7 +1065,7 @@ package body Sem_Type is\n          --  verify that the context type is the non-limited view.\n \n          if Is_Incomplete_Type (T2) then\n-            return Covers (T1, Non_Limited_View (T2));\n+            return Covers (T1, Get_Full_View (Non_Limited_View (T2)));\n \n          elsif Ekind (T2) = E_Class_Wide_Type then\n             return\n@@ -1471,7 +1530,7 @@ package body Sem_Type is\n       --  then we must check whether the user-defined entity hides the prede-\n       --  fined one.\n \n-      if Chars (Nam1) in  Any_Operator_Name\n+      if Chars (Nam1) in Any_Operator_Name\n         and then Standard_Operator\n       then\n          if        Typ = Universal_Integer\n@@ -1677,7 +1736,7 @@ package body Sem_Type is\n          end if;\n       end if;\n \n-      --  an implicit concatenation operator on a string type cannot be\n+      --  An implicit concatenation operator on a string type cannot be\n       --  disambiguated from the predefined concatenation. This can only\n       --  happen with concatenation of string literals.\n \n@@ -1687,7 +1746,7 @@ package body Sem_Type is\n       then\n          return No_Interp;\n \n-      --  If the user-defined operator is in  an open scope, or in the scope\n+      --  If the user-defined operator is in an open scope, or in the scope\n       --  of the resulting type, or given by an expanded name that names its\n       --  scope, it hides the predefined operator for the type. Exponentiation\n       --  has to be special-cased because the implicit operator does not have\n@@ -1904,9 +1963,48 @@ package body Sem_Type is\n       else\n          return Specific_Type (T, Etype (R));\n       end if;\n-\n    end Find_Unique_Type;\n \n+   -------------------------------------\n+   -- Function_Interp_Has_Abstract_Op --\n+   -------------------------------------\n+\n+   function Function_Interp_Has_Abstract_Op\n+     (N : Node_Id;\n+      E : Entity_Id) return Entity_Id\n+   is\n+      Abstr_Op  : Entity_Id;\n+      Act       : Node_Id;\n+      Act_Parm  : Node_Id;\n+      Form_Parm : Node_Id;\n+\n+   begin\n+      if Is_Overloaded (N) then\n+         Act_Parm  := First_Actual (N);\n+         Form_Parm := First_Formal (E);\n+         while Present (Act_Parm)\n+           and then Present (Form_Parm)\n+         loop\n+            Act := Act_Parm;\n+\n+            if Nkind (Act) = N_Parameter_Association then\n+               Act := Explicit_Actual_Parameter (Act);\n+            end if;\n+\n+            Abstr_Op := Has_Abstract_Op (Act, Etype (Form_Parm));\n+\n+            if Present (Abstr_Op) then\n+               return Abstr_Op;\n+            end if;\n+\n+            Next_Actual (Act_Parm);\n+            Next_Formal (Form_Parm);\n+         end loop;\n+      end if;\n+\n+      return Empty;\n+   end Function_Interp_Has_Abstract_Op;\n+\n    ----------------------\n    -- Get_First_Interp --\n    ----------------------\n@@ -1916,8 +2014,8 @@ package body Sem_Type is\n       I  : out Interp_Index;\n       It : out Interp)\n    is\n-      Map_Ptr : Int;\n       Int_Ind : Interp_Index;\n+      Map_Ptr : Int;\n       O_N     : Node_Id;\n \n    begin\n@@ -2030,6 +2128,34 @@ package body Sem_Type is\n       end if;\n    end Has_Compatible_Type;\n \n+   ---------------------\n+   -- Has_Abstract_Op --\n+   ---------------------\n+\n+   function Has_Abstract_Op\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Entity_Id\n+   is\n+      I  : Interp_Index;\n+      It : Interp;\n+\n+   begin\n+      if Is_Overloaded (N) then\n+         Get_First_Interp (N, I, It);\n+         while Present (It.Nam) loop\n+            if Present (It.Abstract_Op)\n+              and then Etype (It.Abstract_Op) = Typ\n+            then\n+               return It.Abstract_Op;\n+            end if;\n+\n+            Get_Next_Interp (I, It);\n+         end loop;\n+      end if;\n+\n+      return Empty;\n+   end Has_Abstract_Op;\n+\n    ----------\n    -- Hash --\n    ----------\n@@ -2384,18 +2510,17 @@ package body Sem_Type is\n       then\n          return False;\n \n-      else return\n-        Is_Numeric_Type (T)\n-          and then not In_Open_Scopes (Scope (T))\n-          and then not Is_Potentially_Use_Visible (T)\n-          and then not In_Use (T)\n-          and then not In_Use (Scope (T))\n-          and then\n+      else\n+         return Is_Numeric_Type (T)\n+           and then not In_Open_Scopes (Scope (T))\n+           and then not Is_Potentially_Use_Visible (T)\n+           and then not In_Use (T)\n+           and then not In_Use (Scope (T))\n+           and then\n             (Nkind (Orig_Node) /= N_Function_Call\n               or else Nkind (Name (Orig_Node)) /= N_Expanded_Name\n               or else Entity (Prefix (Name (Orig_Node))) /= Scope (T))\n-\n-          and then not In_Instance;\n+           and then not In_Instance;\n       end if;\n    end Is_Invisible_Operator;\n \n@@ -2866,6 +2991,15 @@ package body Sem_Type is\n       end if;\n    end Specific_Type;\n \n+   ---------------------\n+   -- Set_Abstract_Op --\n+   ---------------------\n+\n+   procedure Set_Abstract_Op (I : Interp_Index; V : Entity_Id) is\n+   begin\n+      All_Interp.Table (I).Abstract_Op := V;\n+   end Set_Abstract_Op;\n+\n    -----------------------\n    -- Valid_Boolean_Arg --\n    -----------------------\n@@ -2956,9 +3090,9 @@ package body Sem_Type is\n          Get_First_Interp (N, I, It);\n          Write_Str (\"Overloaded entity \");\n          Write_Eol;\n-         Write_Str (\"      Name           Type\");\n+         Write_Str (\"      Name           Type           Abstract Op\");\n          Write_Eol;\n-         Write_Str (\"===============================\");\n+         Write_Str (\"===============================================\");\n          Write_Eol;\n          Nam := It.Nam;\n \n@@ -2970,6 +3104,14 @@ package body Sem_Type is\n             Write_Int (Int (It.Typ));\n             Write_Str (\"   \");\n             Write_Name (Chars (It.Typ));\n+\n+            if Present (It.Abstract_Op) then\n+               Write_Str (\"   \");\n+               Write_Int (Int (It.Abstract_Op));\n+               Write_Str (\"   \");\n+               Write_Name (Chars (It.Abstract_Op));\n+            end if;\n+\n             Write_Eol;\n             Get_Next_Interp (I, It);\n             Nam := It.Nam;"}, {"sha": "0cc5e5d43f34c3de964a3f0c58d41ffea8b96851", "filename": "gcc/ada/sem_type.ads", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04df6250f65043292762291a9e5d8092f8117318/gcc%2Fada%2Fsem_type.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04df6250f65043292762291a9e5d8092f8117318/gcc%2Fada%2Fsem_type.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.ads?ref=04df6250f65043292762291a9e5d8092f8117318", "patch": "@@ -41,13 +41,13 @@ package Sem_Type is\n    --  the visibility rules find such a potential ambiguity, the set of\n    --  possible interpretations must be attached to the identifier, and\n    --  overload resolution must be performed over the innermost enclosing\n-   --  complete context. At the end of the resolution,  either a single\n+   --  complete context. At the end of the resolution, either a single\n    --  interpretation is found for all identifiers in the context, or else a\n    --  type error (invalid type or ambiguous reference) must be signalled.\n \n    --  The set of interpretations of a given name is stored in a data structure\n    --  that is separate from the syntax tree, because it corresponds to\n-   --  transient information.  The interpretations themselves are stored in\n+   --  transient information. The interpretations themselves are stored in\n    --  table All_Interp. A mapping from tree nodes to sets of interpretations\n    --  called Interp_Map, is maintained by the overload resolution routines.\n    --  Both these structures are initialized at the beginning of every complete\n@@ -64,11 +64,15 @@ package Sem_Type is\n    --  only one interpretation is present anyway.\n \n    type Interp is record\n-      Nam : Entity_Id;\n-      Typ : Entity_Id;\n+      Nam         : Entity_Id;\n+      Typ         : Entity_Id;\n+      Abstract_Op : Entity_Id := Empty;\n    end record;\n \n-   No_Interp : constant Interp := (Empty, Empty);\n+   --  Entity Abstract_Op is set to the abstract operation which potentially\n+   --  disables the interpretation in Ada 2005 mode.\n+\n+   No_Interp : constant Interp := (Empty, Empty, Empty);\n \n    subtype Interp_Index is Int;\n \n@@ -122,8 +126,9 @@ package Sem_Type is\n    --  E is an overloadable entity, and T is its type. For constructs such\n    --  as indexed expressions, the caller sets E equal to T, because the\n    --  overloading comes from other fields, and the node itself has no name\n-   --  to resolve. Add_One_Interp includes the semantic processing to deal\n-   --  with adding entries that hide one another etc.\n+   --  to resolve. Hidden denotes whether an interpretation has been disabled\n+   --  by an abstract operator. Add_One_Interp includes semantic processing to\n+   --  deal with adding entries that hide one another etc.\n \n    --  For operators, the legality of the operation depends on the visibility\n    --  of T and its scope. If the operator is an equality or comparison, T is\n@@ -172,7 +177,7 @@ package Sem_Type is\n       I1, I2 : Interp_Index;\n       Typ    : Entity_Id)\n       return   Interp;\n-   --  If more than one interpretation  of a name in a call is legal, apply\n+   --  If more than one interpretation of a name in a call is legal, apply\n    --  preference rules (universal types first) and operator visibility in\n    --  order to remove ambiguity. I1 and I2 are the first two interpretations\n    --  that are compatible with the context, but there may be others.\n@@ -216,19 +221,22 @@ package Sem_Type is\n    --  interpretations is universal, choose the non-universal one. If either\n    --  node is overloaded, find single common interpretation.\n \n-   function Is_Subtype_Of (T1 : Entity_Id; T2 : Entity_Id) return Boolean;\n-   --  Checks whether T1 is any subtype of T2 directly or indirectly. Applies\n-   --  only to scalar subtypes ???\n-\n    function Is_Ancestor (T1, T2 : Entity_Id) return Boolean;\n    --  T1 is a tagged type (not class-wide). Verify that it is one of the\n    --  ancestors of type T2 (which may or not be class-wide)\n \n-   function Operator_Matches_Spec (Op,  New_S : Entity_Id) return Boolean;\n+   function Is_Subtype_Of (T1 : Entity_Id; T2 : Entity_Id) return Boolean;\n+   --  Checks whether T1 is any subtype of T2 directly or indirectly. Applies\n+   --  only to scalar subtypes ???\n+\n+   function Operator_Matches_Spec (Op, New_S : Entity_Id) return Boolean;\n    --  Used to resolve subprograms renaming operators, and calls to user\n    --  defined operators. Determines whether a given operator Op, matches\n    --  a specification, New_S.\n \n+   procedure Set_Abstract_Op (I : Interp_Index; V : Entity_Id);\n+   --  Set the abstract operation field of an interpretation\n+\n    function Valid_Comparison_Arg (T : Entity_Id) return Boolean;\n    --  A valid argument to an ordering operator must be a discrete type, a\n    --  real type, or a one dimensional array with a discrete component type."}]}