{"sha": "dc884a86d3ffa4108b66a232d18eb3fa35000863", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM4ODRhODZkM2ZmYTQxMDhiNjZhMjMyZDE4ZWIzZmEzNTAwMDg2Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-05-06T15:27:19Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-05-06T15:27:19Z"}, "message": "invoke.texi: Document -mvr4130-align.\n\n\t* doc/invoke.texi: Document -mvr4130-align.\n\t* config/mips/mips.h (MASK_VR4130_ALIGN, TARGET_VR4130_ALIGN)\n\t(TUNE_MIPS4120, TUNE_MIPS4130): New macros.\n\t(TUNE_MACC_CHAINS): Include TUNE_MIPS4120 and TUNE_MIPS4130.\n\t(TARGET_SWITCHES): Add -mvr4130-align and -mno-vr4130-align.\n\t* config/mips/mips.md: Include sched-int.h.\n\t(USEFUL_INSN_P, SEQ_BEGIN, SEQ_END, FOR_EACH_SUBINSN): New macros.\n\t(mips_rtx_costs): Set integer multiplication costs for TUNE_MIPS4130.\n\t(override_options): Enable -mvr4130-align at -O3 and above.\n\t(mips_sim_insn): New variable.\n\t(mips_sim): New structure.\n\t(mips_sim_reset, mips_sim_init, mips_sim_next_cycle, mips_sim_wait_reg)\n\t(mips_sim_wait_regs_2, mips_sim_wait_regs_1, mips_sim_wait_regs)\n\t(mips_sim_wait_units, mips_sim_wait_insn, mips_sim_record_set)\n\t(mips_sim_issue_insn, mips_sim_issue_nop, mips_sim_finish_insn)\n\t(vr4130_avoid_branch_rt_conflict, vr4130_align_insns): New functions.\n\t(mips_reorg): Call vr4130_align_insns.\n\t(vr4130_last_insn): New variable.\n\t(vr4130_true_reg_dependence_p_1, vr4130_true_reg_dependence_p)\n\t(vr4130_swap_insns_p, vr4130_reorder): New functions.\n\t(mips_sched_reorder, mips_variable_issue): Hook in vr4130 code.\n\t(mips_issue_rate): Return 2 for PROCESSOR_R4130.\n\t(mips_use_dfa_pipeline_interface): Return true for the same.\n\t* config/mips/4130.md: New file.\n\t* config/mips/mips.md: Include it.  Add a peephole2 to convert\n\t\"mult;mflo\" into \"mtlo;macc\".\n\t(*macc, *umul_acc_di, *smul_acc_di): Use $1 rather than $0 as the\n\ttarget of maccs.\n\t(*msac_using_macc): New pattern.\n\nFrom-SVN: r81567", "tree": {"sha": "dc72d15b86329f3634e41b3ca914b9982b3a4a25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc72d15b86329f3634e41b3ca914b9982b3a4a25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc884a86d3ffa4108b66a232d18eb3fa35000863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc884a86d3ffa4108b66a232d18eb3fa35000863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc884a86d3ffa4108b66a232d18eb3fa35000863", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc884a86d3ffa4108b66a232d18eb3fa35000863/comments", "author": null, "committer": null, "parents": [{"sha": "e51f7aeb7ba0496ed2fb1a158255cbc41c5a2d08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e51f7aeb7ba0496ed2fb1a158255cbc41c5a2d08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e51f7aeb7ba0496ed2fb1a158255cbc41c5a2d08"}], "stats": {"total": 795, "additions": 789, "deletions": 6}, "files": [{"sha": "3ea323e341c39dbc5b51ac7dcd821a3b1b50a388", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc884a86d3ffa4108b66a232d18eb3fa35000863", "patch": "@@ -1,3 +1,35 @@\n+2004-05-06  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* doc/invoke.texi: Document -mvr4130-align.\n+\t* config/mips/mips.h (MASK_VR4130_ALIGN, TARGET_VR4130_ALIGN)\n+\t(TUNE_MIPS4120, TUNE_MIPS4130): New macros.\n+\t(TUNE_MACC_CHAINS): Include TUNE_MIPS4120 and TUNE_MIPS4130.\n+\t(TARGET_SWITCHES): Add -mvr4130-align and -mno-vr4130-align.\n+\t* config/mips/mips.md: Include sched-int.h.\n+\t(USEFUL_INSN_P, SEQ_BEGIN, SEQ_END, FOR_EACH_SUBINSN): New macros.\n+\t(mips_rtx_costs): Set integer multiplication costs for TUNE_MIPS4130.\n+\t(override_options): Enable -mvr4130-align at -O3 and above.\n+\t(mips_sim_insn): New variable.\n+\t(mips_sim): New structure.\n+\t(mips_sim_reset, mips_sim_init, mips_sim_next_cycle, mips_sim_wait_reg)\n+\t(mips_sim_wait_regs_2, mips_sim_wait_regs_1, mips_sim_wait_regs)\n+\t(mips_sim_wait_units, mips_sim_wait_insn, mips_sim_record_set)\n+\t(mips_sim_issue_insn, mips_sim_issue_nop, mips_sim_finish_insn)\n+\t(vr4130_avoid_branch_rt_conflict, vr4130_align_insns): New functions.\n+\t(mips_reorg): Call vr4130_align_insns.\n+\t(vr4130_last_insn): New variable.\n+\t(vr4130_true_reg_dependence_p_1, vr4130_true_reg_dependence_p)\n+\t(vr4130_swap_insns_p, vr4130_reorder): New functions.\n+\t(mips_sched_reorder, mips_variable_issue): Hook in vr4130 code.\n+\t(mips_issue_rate): Return 2 for PROCESSOR_R4130.\n+\t(mips_use_dfa_pipeline_interface): Return true for the same.\n+\t* config/mips/4130.md: New file.\n+\t* config/mips/mips.md: Include it.  Add a peephole2 to convert\n+\t\"mult;mflo\" into \"mtlo;macc\".\n+\t(*macc, *umul_acc_di, *smul_acc_di): Use $1 rather than $0 as the\n+\ttarget of maccs.\n+\t(*msac_using_macc): New pattern.\n+\n 2004-05-06  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/5500.md (ir_vr55_store): Set latency to 0."}, {"sha": "eddc405de34fe557aba6e9e1e9aac0cae86e021b", "filename": "gcc/config/mips/4130.md", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2Fconfig%2Fmips%2F4130.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2Fconfig%2Fmips%2F4130.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2F4130.md?ref=dc884a86d3ffa4108b66a232d18eb3fa35000863", "patch": "@@ -0,0 +1,136 @@\n+;;\n+;; Pipeline description for the VR4130 family.\n+;;\n+;; The processor issues each 8-byte aligned pair of instructions together,\n+;; stalling the second instruction if it depends on the first.  Thus, if we\n+;; want two instructions to issue in parallel, we need to make sure that the\n+;; first one is 8-byte aligned.\n+;;\n+;; For the purposes of this pipeline description, we treat the processor\n+;; like a standard two-way superscalar architecture.  If scheduling were\n+;; the last pass to run, we could use the scheduler hooks to vary the\n+;; issue rate depending on whether an instruction is at an aligned or\n+;; unaligned address.  Unfortunately, delayed branch scheduling and\n+;; hazard avoidance are done after the final scheduling pass, and they\n+;; can change the addresses of many instructions.\n+;;\n+;; We get around this in two ways:\n+;;\n+;;   (1) By running an extra pass at the end of compilation.  This pass goes\n+;;\t through the function looking for pairs of instructions that could\n+;;\t execute in parallel.  It makes sure that the first instruction in\n+;;\t each pair is suitably aligned, inserting nops if necessary.  Doing\n+;;\t this gives the same kind of pipeline behavior we would see on a\n+;;\t normal superscalar target.\n+;;\n+;;\t This pass is generally a speed improvement, but the extra nops will\n+;;\t obviously make the program bigger.  It is therefore unsuitable for\n+;;\t -Os (at the very least).\n+;;\n+;;   (2) By modifying the scheduler hooks so that, where possible:\n+;;\n+;;\t (a) dependent instructions are separated by a non-dependent\n+;;\t     instruction;\n+;;\n+;;\t (b) instructions that use the multiplication unit are separated\n+;;\t     by non-multiplication instructions; and\n+;;\n+;;\t (c) memory access instructions are separated by non-memory\n+;;\t     instructions.\n+;;\n+;;\t The idea is to keep conflicting instructions apart wherever possible\n+;;\t and thus make the schedule less dependent on alignment.\n+\n+(define_automaton \"vr4130_main, vr4130_muldiv, vr4130_mulpre\")\n+\n+(define_cpu_unit \"vr4130_alu1, vr4130_alu2, vr4130_dcache\" \"vr4130_main\")\n+(define_cpu_unit \"vr4130_muldiv\" \"vr4130_muldiv\")\n+\n+;; This is a fake unit for pre-reload scheduling of multiplications.\n+;; It enforces the true post-reload repeat rate.\n+(define_cpu_unit \"vr4130_mulpre\" \"vr4130_mulpre\")\n+\n+;; The scheduling hooks use this attribute for (b) above.\n+(define_attr \"vr4130_class\" \"mul,mem,alu\"\n+  (cond [(eq_attr \"type\" \"load,store\")\n+\t (const_string \"mem\")\n+\n+\t (eq_attr \"type\" \"mfhilo,mthilo,imul,imadd,idiv\")\n+\t (const_string \"mul\")]\n+\t(const_string \"alu\")))\n+\n+(define_insn_reservation \"vr4130_multi\" 1\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (eq_attr \"type\" \"multi,unknown\"))\n+  \"vr4130_alu1 + vr4130_alu2 + vr4130_dcache + vr4130_muldiv\")\n+\n+(define_insn_reservation \"vr4130_int\" 1\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (eq_attr \"type\" \"const,arith,shift,slt,nop\"))\n+  \"vr4130_alu1 | vr4130_alu2\")\n+\n+(define_insn_reservation \"vr4130_load\" 3\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (eq_attr \"type\" \"load\"))\n+  \"vr4130_dcache\")\n+\n+(define_insn_reservation \"vr4130_store\" 1\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (eq_attr \"type\" \"store\"))\n+  \"vr4130_dcache\")\n+\n+(define_insn_reservation \"vr4130_mfhilo\" 3\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (eq_attr \"type\" \"mfhilo\"))\n+  \"vr4130_muldiv\")\n+\n+(define_insn_reservation \"vr4130_mthilo\" 1\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (eq_attr \"type\" \"mthilo\"))\n+  \"vr4130_muldiv\")\n+\n+;; The product is available in LO & HI after one cycle.  Moving the result\n+;; into an integer register will take an additional three cycles, see mflo\n+;; & mfhi above.  Note that the same latencies and repeat rates apply if we\n+;; use \"mtlo; macc\" instead of \"mult; mflo\".\n+(define_insn_reservation \"vr4130_mulsi\" 4\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"mode\" \"SI\")))\n+  \"vr4130_muldiv + (vr4130_mulpre * 2)\")\n+\n+;; As for vr4130_mulsi, but the product is available in LO and HI\n+;; after 3 cycles.\n+(define_insn_reservation \"vr4130_muldi\" 6\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"mode\" \"DI\")))\n+  \"(vr4130_muldiv * 3) + (vr4130_mulpre * 4)\")\n+\n+;; maccs can execute in consecutive cycles without stalling, but it\n+;; is 3 cycles before the integer destination can be read.\n+(define_insn_reservation \"vr4130_macc\" 3\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (eq_attr \"type\" \"imadd\"))\n+  \"vr4130_muldiv\")\n+\n+(define_bypass 1 \"vr4130_mulsi,vr4130_macc\" \"vr4130_macc\" \"mips_linked_madd_p\")\n+(define_bypass 1 \"vr4130_mulsi,vr4130_macc\" \"vr4130_mfhilo\")\n+(define_bypass 3 \"vr4130_muldi\" \"vr4130_mfhilo\")\n+\n+(define_insn_reservation \"vr4130_divsi\" 36\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (and (eq_attr \"type\" \"idiv\")\n+\t    (eq_attr \"mode\" \"SI\")))\n+  \"vr4130_muldiv * 36\")\n+\n+(define_insn_reservation \"vr4130_divdi\" 72\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (and (eq_attr \"type\" \"idiv\")\n+\t    (eq_attr \"mode\" \"DI\")))\n+  \"vr4130_muldiv * 72\")\n+\n+(define_insn_reservation \"vr4130_branch\" 0\n+  (and (eq_attr \"cpu\" \"r4130\")\n+       (eq_attr \"type\" \"branch,jump,call\"))\n+  \"vr4130_alu1 | vr4130_alu2\")"}, {"sha": "598120fd409f4ef47eeb32c4610cdd2266197b6a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 531, "deletions": 0, "changes": 531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=dc884a86d3ffa4108b66a232d18eb3fa35000863", "patch": "@@ -54,6 +54,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"integrate.h\"\n #include \"langhooks.h\"\n #include \"cfglayout.h\"\n+#include \"sched-int.h\"\n \n /* Enumeration for all of the relational tests, so that we can build\n    arrays indexed by the test type, and not worry about the order\n@@ -107,6 +108,33 @@ enum internal_test {\n    multi-instruction addu sequence.  Use 0x7fe0 to work around this.  */\n #define MIPS_MAX_FIRST_STACK_STEP (TARGET_MIPS16 ? 0x100 : 0x7fe0)\n \n+/* True if INSN is a mips.md pattern or asm statement.  */\n+#define USEFUL_INSN_P(INSN)\t\t\t\t\t\t\\\n+  (INSN_P (INSN)\t\t\t\t\t\t\t\\\n+   && GET_CODE (PATTERN (INSN)) != USE\t\t\t\t\t\\\n+   && GET_CODE (PATTERN (INSN)) != CLOBBER\t\t\t\t\\\n+   && GET_CODE (PATTERN (INSN)) != ADDR_VEC\t\t\t\t\\\n+   && GET_CODE (PATTERN (INSN)) != ADDR_DIFF_VEC)\n+\n+/* If INSN is a delayed branch sequence, return the first instruction\n+   in the sequence, otherwise return INSN itself.  */\n+#define SEQ_BEGIN(INSN)\t\t\t\t\t\t\t\\\n+  (INSN_P (INSN) && GET_CODE (PATTERN (INSN)) == SEQUENCE\t\t\\\n+   ? XVECEXP (PATTERN (INSN), 0, 0)\t\t\t\t\t\\\n+   : (INSN))\n+\n+/* Likewise for the last instruction in a delayed branch sequence.  */\n+#define SEQ_END(INSN)\t\t\t\t\t\t\t\\\n+  (INSN_P (INSN) && GET_CODE (PATTERN (INSN)) == SEQUENCE\t\t\\\n+   ? XVECEXP (PATTERN (INSN), 0, XVECLEN (PATTERN (INSN), 0) - 1)\t\\\n+   : (INSN))\n+\n+/* Execute the following loop body with SUBINSN set to each instruction\n+   between SEQ_BEGIN (INSN) and SEQ_END (INSN) inclusive.  */\n+#define FOR_EACH_SUBINSN(SUBINSN, INSN)\t\t\t\t\t\\\n+  for ((SUBINSN) = SEQ_BEGIN (INSN);\t\t\t\t\t\\\n+       (SUBINSN) != NEXT_INSN (SEQ_END (INSN));\t\t\t\t\\\n+       (SUBINSN) = NEXT_INSN (SUBINSN))\n \n /* Classifies an address.\n \n@@ -138,6 +166,7 @@ struct mips16_constant;\n struct mips_arg_info;\n struct mips_address_info;\n struct mips_integer_op;\n+struct mips_sim;\n \n static enum mips_symbol_type mips_classify_symbol (rtx);\n static void mips_split_const (rtx, rtx *, HOST_WIDE_INT *);\n@@ -219,6 +248,21 @@ static void dump_constants (struct mips16_constant *, rtx);\n static int mips16_insn_length (rtx);\n static int mips16_rewrite_pool_refs (rtx *, void *);\n static void mips16_lay_out_constants (void);\n+static void mips_sim_reset (struct mips_sim *);\n+static void mips_sim_init (struct mips_sim *, state_t);\n+static void mips_sim_next_cycle (struct mips_sim *);\n+static void mips_sim_wait_reg (struct mips_sim *, rtx, rtx);\n+static int mips_sim_wait_regs_2 (rtx *, void *);\n+static void mips_sim_wait_regs_1 (rtx *, void *);\n+static void mips_sim_wait_regs (struct mips_sim *, rtx);\n+static void mips_sim_wait_units (struct mips_sim *, rtx);\n+static void mips_sim_wait_insn (struct mips_sim *, rtx);\n+static void mips_sim_record_set (rtx, rtx, void *);\n+static void mips_sim_issue_insn (struct mips_sim *, rtx);\n+static void mips_sim_issue_nop (struct mips_sim *);\n+static void mips_sim_finish_insn (struct mips_sim *, rtx);\n+static void vr4130_avoid_branch_rt_conflict (rtx);\n+static void vr4130_align_insns (void);\n static void mips_avoid_hazard (rtx, rtx, int *, rtx *, rtx);\n static void mips_avoid_hazards (void);\n static void mips_reorg (void);\n@@ -230,6 +274,10 @@ static bool mips_return_in_memory (tree, tree);\n static bool mips_strict_argument_naming (CUMULATIVE_ARGS *);\n static void mips_macc_chains_record (rtx);\n static void mips_macc_chains_reorder (rtx *, int);\n+static void vr4130_true_reg_dependence_p_1 (rtx, rtx, void *);\n+static bool vr4130_true_reg_dependence_p (rtx);\n+static bool vr4130_swap_insns_p (rtx, rtx);\n+static void vr4130_reorder (rtx *, int);\n static void mips_promote_ready (rtx *, int, int);\n static int mips_sched_reorder (FILE *, int, rtx *, int *, int);\n static int mips_variable_issue (FILE *, int, rtx, int);\n@@ -2347,6 +2395,8 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n         *total = COSTS_N_INSNS (12);\n       else if (TUNE_MIPS3900)\n         *total = COSTS_N_INSNS (2);\n+      else if (TUNE_MIPS4130)\n+\t*total = COSTS_N_INSNS (mode == DImode ? 6 : 4);\n       else if (TUNE_MIPS5400 || TUNE_SB1)\n         *total = COSTS_N_INSNS (mode == DImode ? 4 : 3);\n       else if (TUNE_MIPS5500 || TUNE_MIPS7000)\n@@ -4788,6 +4838,12 @@ override_options (void)\n   if (TARGET_NAME_REGS)\n     memcpy (mips_reg_names, mips_sw_reg_names, sizeof (mips_reg_names));\n \n+  /* -mvr4130-align is a \"speed over size\" optimization: it usually produces\n+     faster code, but at the expense of more nops.  Enable it at -O3 and\n+     above.  */\n+  if (optimize > 2 && (target_flags_explicit & MASK_VR4130_ALIGN) == 0)\n+    target_flags |= MASK_VR4130_ALIGN;\n+\n   /* When compiling for the mips16, we can not use floating point.  We\n      record the original hard float value in mips16_hard_float.  */\n   if (TARGET_MIPS16)\n@@ -8367,8 +8423,373 @@ mips16_lay_out_constants (void)\n     }\n   dump_constants (pool.first, get_last_insn ());\n }\n+\f\n+/* A temporary variable used by for_each_rtx callbacks, etc.  */\n+static rtx mips_sim_insn;\n+\n+/* A structure representing the state of the processor pipeline.\n+   Used by the mips_sim_* family of functions.  */\n+struct mips_sim {\n+  /* The maximum number of instructions that can be issued in a cycle.\n+     (Caches mips_issue_rate.)  */\n+  unsigned int issue_rate;\n+\n+  /* The current simulation time.  */\n+  unsigned int time;\n+\n+  /* How many more instructions can be issued in the current cycle.  */\n+  unsigned int insns_left;\n+\n+  /* LAST_SET[X].INSN is the last instruction to set register X.\n+     LAST_SET[X].TIME is the time at which that instruction was issued.\n+     INSN is null if no instruction has yet set register X.  */\n+  struct {\n+    rtx insn;\n+    unsigned int time;\n+  } last_set[FIRST_PSEUDO_REGISTER];\n+\n+  /* The pipeline's current DFA state.  */\n+  state_t dfa_state;\n+};\n+\n+/* Reset STATE to the initial simulation state.  */\n+\n+static void\n+mips_sim_reset (struct mips_sim *state)\n+{\n+  state->time = 0;\n+  state->insns_left = state->issue_rate;\n+  memset (&state->last_set, 0, sizeof (state->last_set));\n+  state_reset (state->dfa_state);\n+}\n+\n+/* Initialize STATE before its first use.  DFA_STATE points to an\n+   allocated but uninitialized DFA state.  */\n+\n+static void\n+mips_sim_init (struct mips_sim *state, state_t dfa_state)\n+{\n+  state->issue_rate = mips_issue_rate ();\n+  state->dfa_state = dfa_state;\n+  mips_sim_reset (state);\n+}\n+\n+/* Advance STATE by one clock cycle.  */\n+\n+static void\n+mips_sim_next_cycle (struct mips_sim *state)\n+{\n+  state->time++;\n+  state->insns_left = state->issue_rate;\n+  state_transition (state->dfa_state, 0);\n+}\n+\n+/* Advance simulation state STATE until instruction INSN can read\n+   register REG.  */\n+\n+static void\n+mips_sim_wait_reg (struct mips_sim *state, rtx insn, rtx reg)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)); i++)\n+    if (state->last_set[REGNO (reg) + i].insn != 0)\n+      {\n+\tunsigned int t;\n+\n+\tt = state->last_set[REGNO (reg) + i].time;\n+\tt += insn_latency (state->last_set[REGNO (reg) + i].insn, insn);\n+\twhile (state->time < t)\n+\t  mips_sim_next_cycle (state);\n+    }\n+}\n+\n+/* A for_each_rtx callback.  If *X is a register, advance simulation state\n+   DATA until mips_sim_insn can read the register's value.  */\n+\n+static int\n+mips_sim_wait_regs_2 (rtx *x, void *data)\n+{\n+  if (REG_P (*x))\n+    mips_sim_wait_reg (data, mips_sim_insn, *x);\n+  return 0;\n+}\n+\n+/* Call mips_sim_wait_regs_2 (R, DATA) for each register R mentioned in *X.  */\n+\n+static void\n+mips_sim_wait_regs_1 (rtx *x, void *data)\n+{\n+  for_each_rtx (x, mips_sim_wait_regs_2, data);\n+}\n+\n+/* Advance simulation state STATE until all of INSN's register\n+   dependencies are satisfied.  */\n+\n+static void\n+mips_sim_wait_regs (struct mips_sim *state, rtx insn)\n+{\n+  mips_sim_insn = insn;\n+  note_uses (&PATTERN (insn), mips_sim_wait_regs_1, state);\n+}\n+\n+/* Advance simulation state STATE until the units required by\n+   instruction INSN are available.  */\n+\n+static void\n+mips_sim_wait_units (struct mips_sim *state, rtx insn)\n+{\n+  state_t tmp_state;\n+\n+  tmp_state = alloca (state_size ());\n+  while (state->insns_left == 0\n+\t || (memcpy (tmp_state, state->dfa_state, state_size ()),\n+\t     state_transition (tmp_state, insn) >= 0))\n+    mips_sim_next_cycle (state);\n+}\n+\n+/* Advance simulation state STATE until INSN is ready to issue.  */\n+\n+static void\n+mips_sim_wait_insn (struct mips_sim *state, rtx insn)\n+{\n+  mips_sim_wait_regs (state, insn);\n+  mips_sim_wait_units (state, insn);\n+}\n+\n+/* mips_sim_insn has just set X.  Update the LAST_SET array\n+   in simulation state DATA.  */\n+\n+static void\n+mips_sim_record_set (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n+{\n+  struct mips_sim *state;\n+  unsigned int i;\n+\n+  state = data;\n+  if (REG_P (x))\n+    for (i = 0; i < HARD_REGNO_NREGS (REGNO (x), GET_MODE (x)); i++)\n+      {\n+\tstate->last_set[REGNO (x) + i].insn = mips_sim_insn;\n+\tstate->last_set[REGNO (x) + i].time = state->time;\n+      }\n+}\n+\n+/* Issue instruction INSN in scheduler state STATE.  Assume that INSN\n+   can issue immediately (i.e., that mips_sim_wait_insn has already\n+   been called).  */\n+\n+static void\n+mips_sim_issue_insn (struct mips_sim *state, rtx insn)\n+{\n+  state_transition (state->dfa_state, insn);\n+  state->insns_left--;\n+\n+  mips_sim_insn = insn;\n+  note_stores (PATTERN (insn), mips_sim_record_set, state);\n+}\n+\n+/* Simulate issuing a NOP in state STATE.  */\n+\n+static void\n+mips_sim_issue_nop (struct mips_sim *state)\n+{\n+  if (state->insns_left == 0)\n+    mips_sim_next_cycle (state);\n+  state->insns_left--;\n+}\n+\n+/* Update simulation state STATE so that it's ready to accept the instruction\n+   after INSN.  INSN should be part of the main rtl chain, not a member of a\n+   SEQUENCE.  */\n+\n+static void\n+mips_sim_finish_insn (struct mips_sim *state, rtx insn)\n+{\n+  /* If INSN is a jump with an implicit delay slot, simulate a nop.  */\n+  if (JUMP_P (insn))\n+    mips_sim_issue_nop (state);\n+\n+  switch (GET_CODE (SEQ_BEGIN (insn)))\n+    {\n+    case CODE_LABEL:\n+    case CALL_INSN:\n+      /* We can't predict the processor state after a call or label.  */\n+      mips_sim_reset (state);\n+      break;\n+\n+    case JUMP_INSN:\n+      /* The delay slots of branch likely instructions are only executed\n+\t when the branch is taken.  Therefore, if the caller has simulated\n+\t the delay slot instruction, STATE does not really reflect the state\n+\t of the pipeline for the instruction after the delay slot.  Also,\n+\t branch likely instructions tend to incur a penalty when not taken,\n+\t so there will probably be an extra delay between the branch and\n+\t the instruction after the delay slot.  */\n+      if (INSN_ANNULLED_BRANCH_P (SEQ_BEGIN (insn)))\n+\tmips_sim_reset (state);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\f\n+/* The VR4130 pipeline issues aligned pairs of instructions together,\n+   but it stalls the second instruction if it depends on the first.\n+   In order to cut down the amount of logic required, this dependence\n+   check is not based on a full instruction decode.  Instead, any non-SPECIAL\n+   instruction is assumed to modify the register specified by bits 20-16\n+   (which is usually the \"rt\" field).\n+\n+   In beq, beql, bne and bnel instructions, the rt field is actually an\n+   input, so we can end up with a false dependence between the branch\n+   and its delay slot.  If this situation occurs in instruction INSN,\n+   try to avoid it by swapping rs and rt.  */\n+\n+static void\n+vr4130_avoid_branch_rt_conflict (rtx insn)\n+{\n+  rtx first, second;\n+\n+  first = SEQ_BEGIN (insn);\n+  second = SEQ_END (insn);\n+  if (GET_CODE (first) == JUMP_INSN\n+      && GET_CODE (second) == INSN\n+      && GET_CODE (PATTERN (first)) == SET\n+      && GET_CODE (SET_DEST (PATTERN (first))) == PC\n+      && GET_CODE (SET_SRC (PATTERN (first))) == IF_THEN_ELSE)\n+    {\n+      /* Check for the right kind of condition.  */\n+      rtx cond = XEXP (SET_SRC (PATTERN (first)), 0);\n+      if ((GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n+\t  && REG_P (XEXP (cond, 0))\n+\t  && REG_P (XEXP (cond, 1))\n+\t  && reg_referenced_p (XEXP (cond, 1), PATTERN (second))\n+\t  && !reg_referenced_p (XEXP (cond, 0), PATTERN (second)))\n+\t{\n+\t  /* SECOND mentions the rt register but not the rs register.  */\n+\t  rtx tmp = XEXP (cond, 0);\n+\t  XEXP (cond, 0) = XEXP (cond, 1);\n+\t  XEXP (cond, 1) = tmp;\n+\t}\n+    }\n+}\n+\n+/* Implement -mvr4130-align.  Go through each basic block and simulate the\n+   processor pipeline.  If we find that a pair of instructions could execute\n+   in parallel, and the first of those instruction is not 8-byte aligned,\n+   insert a nop to make it aligned.  */\n \n+static void\n+vr4130_align_insns (void)\n+{\n+  struct mips_sim state;\n+  rtx insn, subinsn, last, last2, next;\n+  bool aligned_p;\n+\n+  dfa_start ();\n+\n+  /* LAST is the last instruction before INSN to have a nonzero length.\n+     LAST2 is the last such instruction before LAST.  */\n+  last = 0;\n+  last2 = 0;\n+\n+  /* ALIGNED_P is true if INSN is known to be at an aligned address.  */\n+  aligned_p = true;\n+\n+  mips_sim_init (&state, alloca (state_size ()));\n+  for (insn = get_insns (); insn != 0; insn = next)\n+    {\n+      unsigned int length;\n+\n+      next = NEXT_INSN (insn);\n+\n+      /* See the comment above vr4130_avoid_branch_rt_conflict for details.\n+\t This isn't really related to the alignment pass, but we do it on\n+\t the fly to avoid a separate instruction walk.  */\n+      vr4130_avoid_branch_rt_conflict (insn);\n+\n+      if (USEFUL_INSN_P (insn))\n+\tFOR_EACH_SUBINSN (subinsn, insn)\n+\t  {\n+\t    mips_sim_wait_insn (&state, subinsn);\n+\n+\t    /* If we want this instruction to issue in parallel with the\n+\t       previous one, make sure that the previous instruction is\n+\t       aligned.  There are several reasons why this isn't worthwhile\n+\t       when the second instruction is a call:\n+\n+\t          - Calls are less likely to be performance critical,\n+\t\t  - There's a good chance that the delay slot can execute\n+\t\t    in parallel with the call.\n+\t          - The return address would then be unaligned.\n+\n+\t       In general, if we're going to insert a nop between instructions\n+\t       X and Y, it's better to insert it immediately after X.  That\n+\t       way, if the nop makes Y aligned, it will also align any labels\n+\t       between X and Y.  */\n+\t    if (state.insns_left != state.issue_rate\n+\t\t&& GET_CODE (subinsn) != CALL_INSN)\n+\t      {\n+\t\tif (subinsn == SEQ_BEGIN (insn) && aligned_p)\n+\t\t  {\n+\t\t    /* SUBINSN is the first instruction in INSN and INSN is\n+\t\t       aligned.  We want to align the previous instruction\n+\t\t       instead, so insert a nop between LAST2 and LAST.\n+\n+\t\t       Note that LAST could be either a single instruction\n+\t\t       or a branch with a delay slot.  In the latter case,\n+\t\t       LAST, like INSN, is already aligned, but the delay\n+\t\t       slot must have some extra delay that stops it from\n+\t\t       issuing at the same time as the branch.  We therefore\n+\t\t       insert a nop before the branch in order to align its\n+\t\t       delay slot.  */\n+\t\t    emit_insn_after (gen_nop (), last2);\n+\t\t    aligned_p = false;\n+\t\t  }\n+\t\telse if (subinsn != SEQ_BEGIN (insn) && !aligned_p)\n+\t\t  {\n+\t\t    /* SUBINSN is the delay slot of INSN, but INSN is\n+\t\t       currently unaligned.  Insert a nop between\n+\t\t       LAST and INSN to align it.  */\n+\t\t    emit_insn_after (gen_nop (), last);\n+\t\t    aligned_p = true;\n+\t\t  }\n+\t      }\n+\t    mips_sim_issue_insn (&state, subinsn);\n+\t  }\n+      mips_sim_finish_insn (&state, insn);\n+\n+      /* Update LAST, LAST2 and ALIGNED_P for the next instruction.  */\n+      length = get_attr_length (insn);\n+      if (length > 0)\n+\t{\n+\t  /* If the instruction is an asm statement or multi-instruction\n+\t     mips.md patern, the length is only an estimate.  Insert an\n+\t     8 byte alignment after it so that the following instructions\n+\t     can be handled correctly.  */\n+\t  if (GET_CODE (SEQ_BEGIN (insn)) == INSN\n+\t      && (recog_memoized (insn) < 0 || length >= 8))\n+\t    {\n+\t      next = emit_insn_after (gen_align (GEN_INT (3)), insn);\n+\t      next = NEXT_INSN (next);\n+\t      mips_sim_next_cycle (&state);\n+\t      aligned_p = true;\n+\t    }\n+\t  else if (length & 4)\n+\t    aligned_p = !aligned_p;\n+\t  last2 = last;\n+\t  last = insn;\n+\t}\n \n+      /* See whether INSN is an aligned label.  */\n+      if (LABEL_P (insn) && label_to_alignment (insn) >= 3)\n+\taligned_p = true;\n+    }\n+  dfa_finish ();\n+}\n+\f\n /* Subroutine of mips_reorg.  If there is a hazard between INSN\n    and a previous instruction, avoid it by inserting nops after\n    instruction AFTER.\n@@ -8499,6 +8920,8 @@ mips_reorg (void)\n       if (mips_flag_delayed_branch)\n \tdbr_schedule (get_insns (), dump_file);\n       mips_avoid_hazards ();\n+      if (TUNE_MIPS4130 && TARGET_VR4130_ALIGN)\n+\tvr4130_align_insns ();\n     }\n }\n \n@@ -9266,6 +9689,104 @@ mips_macc_chains_reorder (rtx *ready, int nready)\n \t}\n }\n \f\n+/* The last instruction to be scheduled.  */\n+\n+static rtx vr4130_last_insn;\n+\n+/* A note_stores callback used by vr4130_true_reg_dependence_p.  DATA\n+   points to an rtx that is initially an instruction.  Nullify the rtx\n+   if the instruction uses the value of register X.  */\n+\n+static void\n+vr4130_true_reg_dependence_p_1 (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n+{\n+  rtx *insn_ptr = data;\n+  if (REG_P (x)\n+      && *insn_ptr != 0\n+      && reg_referenced_p (x, PATTERN (*insn_ptr)))\n+    *insn_ptr = 0;\n+}\n+\n+/* Return true if there is true register dependence between vr4130_last_insn\n+   and INSN.  */\n+\n+static bool\n+vr4130_true_reg_dependence_p (rtx insn)\n+{\n+  note_stores (PATTERN (vr4130_last_insn),\n+\t       vr4130_true_reg_dependence_p_1, &insn);\n+  return insn == 0;\n+}\n+\n+/* A TUNE_MIPS4130 helper function.  Given that INSN1 is at the head of\n+   the ready queue and that INSN2 is the instruction after it, return\n+   true if it is worth promoting INSN2 ahead of INSN1.  Look for cases\n+   in which INSN1 and INSN2 can probably issue in parallel, but for\n+   which (INSN2, INSN1) should be less sensitive to instruction\n+   alignment than (INSN1, INSN2).  See 4130.md for more details.  */\n+\n+static bool\n+vr4130_swap_insns_p (rtx insn1, rtx insn2)\n+{\n+  rtx dep;\n+\n+  /* Check for the following case:\n+\n+     1) there is some other instruction X with an anti dependence on INSN1;\n+     2) X has a higher priority than INSN2; and\n+     3) X is an arithmetic instruction (and thus has no unit restrictions).\n+\n+     If INSN1 is the last instruction blocking X, it would better to\n+     choose (INSN1, X) over (INSN2, INSN1).  */\n+  for (dep = INSN_DEPEND (insn1); dep != 0; dep = XEXP (dep, 1))\n+    if (REG_NOTE_KIND (dep) == REG_DEP_ANTI\n+\t&& INSN_PRIORITY (XEXP (dep, 0)) > INSN_PRIORITY (insn2)\n+\t&& recog_memoized (XEXP (dep, 0)) >= 0\n+\t&& get_attr_vr4130_class (XEXP (dep, 0)) == VR4130_CLASS_ALU)\n+      return false;\n+\n+  if (vr4130_last_insn != 0\n+      && recog_memoized (insn1) >= 0\n+      && recog_memoized (insn2) >= 0)\n+    {\n+      /* See whether INSN1 and INSN2 use different execution units,\n+\t or if they are both ALU-type instructions.  If so, they can\n+\t probably execute in parallel.  */\n+      enum attr_vr4130_class class1 = get_attr_vr4130_class (insn1);\n+      enum attr_vr4130_class class2 = get_attr_vr4130_class (insn2);\n+      if (class1 != class2 || class1 == VR4130_CLASS_ALU)\n+\t{\n+\t  /* If only one of the instructions has a dependence on\n+\t     vr4130_last_insn, prefer to schedule the other one first.  */\n+\t  bool dep1 = vr4130_true_reg_dependence_p (insn1);\n+\t  bool dep2 = vr4130_true_reg_dependence_p (insn2);\n+\t  if (dep1 != dep2)\n+\t    return dep1;\n+\n+\t  /* Prefer to schedule INSN2 ahead of INSN1 if vr4130_last_insn\n+\t     is not an ALU-type instruction and if INSN1 uses the same\n+\t     execution unit.  (Note that if this condition holds, we already\n+\t     know that INSN2 uses a different execution unit.)  */\n+\t  if (class1 != VR4130_CLASS_ALU\n+\t      && recog_memoized (vr4130_last_insn) >= 0\n+\t      && class1 == get_attr_vr4130_class (vr4130_last_insn))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* A TUNE_MIPS4130 helper function.  (READY, NREADY) describes a ready\n+   queue with at least two instructions.  Swap the first two if\n+   vr4130_swap_insns_p says that it could be worthwhile.  */\n+\n+static void\n+vr4130_reorder (rtx *ready, int nready)\n+{\n+  if (vr4130_swap_insns_p (ready[nready - 1], ready[nready - 2]))\n+    mips_promote_ready (ready, nready - 2, nready - 1);\n+}\n+\f\n /* Remove the instruction at index LOWER from ready queue READY and\n    reinsert it in front of the instruction at index HIGHER.  LOWER must\n    be <= HIGHER.  */\n@@ -9295,6 +9816,13 @@ mips_sched_reorder (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n       if (*nreadyp > 0)\n \tmips_macc_chains_reorder (ready, *nreadyp);\n     }\n+  if (reload_completed && TUNE_MIPS4130 && !TARGET_VR4130_ALIGN)\n+    {\n+      if (cycle == 0)\n+\tvr4130_last_insn = 0;\n+      if (*nreadyp > 1)\n+\tvr4130_reorder (ready, *nreadyp);\n+    }\n   return mips_issue_rate ();\n }\n \n@@ -9315,6 +9843,7 @@ mips_variable_issue (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n       more--;\n       if (!reload_completed && TUNE_MACC_CHAINS)\n \tmips_macc_chains_record (insn);\n+      vr4130_last_insn = insn;\n       break;\n     }\n   return more;\n@@ -9339,6 +9868,7 @@ mips_issue_rate (void)\n {\n   switch (mips_tune)\n     {\n+    case PROCESSOR_R4130:\n     case PROCESSOR_R5400:\n     case PROCESSOR_R5500:\n     case PROCESSOR_R7000:\n@@ -9368,6 +9898,7 @@ mips_use_dfa_pipeline_interface (void)\n {\n   switch (mips_tune)\n     {\n+    case PROCESSOR_R4130:\n     case PROCESSOR_R5400:\n     case PROCESSOR_R5500:\n     case PROCESSOR_R7000:"}, {"sha": "e23abf1658d952526a300e8f57a0cb9e503e2210", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=dc884a86d3ffa4108b66a232d18eb3fa35000863", "patch": "@@ -171,7 +171,7 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define MASK_FIX_R4400\t   0x01000000\t/* Work around R4400 errata.  */\n #define MASK_FIX_SB1\t   0x02000000\t/* Work around SB-1 errata.  */\n #define MASK_FIX_VR4120\t   0x04000000   /* Work around VR4120 errata.  */\n-\n+#define MASK_VR4130_ALIGN  0x08000000\t/* Perform VR4130 alignment opts.  */\n #define MASK_FP_EXCEPTIONS 0x10000000   /* FP exceptions are enabled.  */\n \n \t\t\t\t\t/* Debug switches, not documented */\n@@ -253,6 +253,7 @@ extern const struct mips_cpu_info *mips_tune_info;\n \t\t\t\t\t/* Work around R4400 errata.  */\n #define TARGET_FIX_R4400\t(target_flags & MASK_FIX_R4400)\n #define TARGET_FIX_VR4120\t(target_flags & MASK_FIX_VR4120)\n+#define TARGET_VR4130_ALIGN\t(target_flags & MASK_VR4130_ALIGN)\n \n #define TARGET_FP_EXCEPTIONS\t(target_flags & MASK_FP_EXCEPTIONS)\n \n@@ -332,6 +333,8 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define TUNE_MIPS3000               (mips_tune == PROCESSOR_R3000)\n #define TUNE_MIPS3900               (mips_tune == PROCESSOR_R3900)\n #define TUNE_MIPS4000               (mips_tune == PROCESSOR_R4000)\n+#define TUNE_MIPS4120               (mips_tune == PROCESSOR_R4120)\n+#define TUNE_MIPS4130               (mips_tune == PROCESSOR_R4130)\n #define TUNE_MIPS5000               (mips_tune == PROCESSOR_R5000)\n #define TUNE_MIPS5400               (mips_tune == PROCESSOR_R5400)\n #define TUNE_MIPS5500               (mips_tune == PROCESSOR_R5500)\n@@ -371,7 +374,9 @@ extern const struct mips_cpu_info *mips_tune_info;\n \n    Multiply-accumulate instructions are a bigger win for some targets\n    than others, so this macro is defined on an opt-in basis.  */\n-#define TUNE_MACC_CHAINS\t    TUNE_MIPS5500\n+#define TUNE_MACC_CHAINS\t    (TUNE_MIPS5500\t\t\\\n+\t\t\t\t     || TUNE_MIPS4120\t\t\\\n+\t\t\t\t     || TUNE_MIPS4130)\n \n #define TARGET_OLDABI\t\t    (mips_abi == ABI_32 || mips_abi == ABI_O64)\n #define TARGET_NEWABI\t\t    (mips_abi == ABI_N32 || mips_abi == ABI_64)\n@@ -619,6 +624,10 @@ extern const struct mips_cpu_info *mips_tune_info;\n      N_(\"Don't generate fused multiply/add instructions\")},\t\t\\\n   {\"fused-madd\",         -MASK_NO_FUSED_MADD,                           \\\n      N_(\"Generate fused multiply/add instructions\")},\t\t\t\\\n+  {\"vr4130-align\",\t  MASK_VR4130_ALIGN,\t\t\t\t\\\n+     N_(\"Perform VR4130-specific alignment optimizations\")},\t\t\\\n+  {\"no-vr4130-align\",\t -MASK_VR4130_ALIGN,\t\t\t\t\\\n+     N_(\"Don't perform VR4130-specific alignment optimizations\")},\t\\\n   {\"fix4300\",             MASK_4300_MUL_FIX,\t\t\t\t\\\n      N_(\"Work around early 4300 hardware bug\")},\t\t\t\\\n   {\"no-fix4300\",         -MASK_4300_MUL_FIX,\t\t\t\t\\"}, {"sha": "e9682464a465408d971cdaca8cb03bd7b32cfc6b", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=dc884a86d3ffa4108b66a232d18eb3fa35000863", "patch": "@@ -631,6 +631,7 @@\n \f\n ;; Include scheduling descriptions.\n \n+(include \"4130.md\")\n (include \"5400.md\")\n (include \"5500.md\")\n (include \"7000.md\")\n@@ -1584,6 +1585,37 @@\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"   \"8\")])\n \n+;; On the VR4120 and VR4130, it is better to use \"mtlo $0; macc\" instead\n+;; of \"mult; mflo\".  They have the same latency, but the first form gives\n+;; us an extra cycle to compute the operands.\n+\n+;; Operand 0: LO\n+;; Operand 1: GPR (1st multiplication operand)\n+;; Operand 2: GPR (2nd multiplication operand)\n+;; Operand 3: HI\n+;; Operand 4: GPR (destination)\n+(define_peephole2\n+  [(parallel\n+       [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t     (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"\")))\n+        (clobber (match_operand:SI 3 \"register_operand\" \"\"))])\n+   (set (match_operand:SI 4 \"register_operand\" \"\")\n+\t(unspec:SI [(match_dup 0) (match_dup 3)] UNSPEC_MFHILO))]\n+  \"ISA_HAS_MACC && !GENERATE_MULT3_SI\"\n+  [(set (match_dup 0)\n+\t(const_int 0))\n+   (parallel\n+       [(set (match_dup 0)\n+\t     (plus:SI (mult:SI (match_dup 1)\n+\t\t\t       (match_dup 2))\n+\t\t      (match_dup 0)))\n+\t(set (match_dup 4)\n+\t     (plus:SI (mult:SI (match_dup 1)\n+\t\t\t       (match_dup 2))\n+\t\t      (match_dup 0)))\n+        (clobber (match_dup 3))])])\n+\n ;; Multiply-accumulate patterns\n \n ;; For processors that can copy the output to a general register:\n@@ -1673,7 +1705,10 @@\n   else if (TARGET_MIPS5500)\n     return \"madd\\t%1,%2\";\n   else\n-    return \"macc\\t%.,%1,%2\";\n+    /* The VR4130 assumes that there is a two-cycle latency between a macc\n+       that \"writes\" to $0 and an instruction that reads from it.  We avoid\n+       this by assigning to $1 instead.  */\n+    return \"%[macc\\t%@,%1,%2%]\";\n }\n   [(set_attr \"type\" \"imadd\")\n    (set_attr \"mode\" \"SI\")])\n@@ -1697,6 +1732,31 @@\n   [(set_attr \"type\"     \"imadd\")\n    (set_attr \"mode\"     \"SI\")])\n \n+;; An msac-like instruction implemented using negation and a macc.\n+(define_insn_and_split \"*msac_using_macc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,d\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"0,l\")\n+                  (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d\")\n+                           (match_operand:SI 3 \"register_operand\" \"d,d\"))))\n+   (clobber (match_scratch:SI 4 \"=h,h\"))\n+   (clobber (match_scratch:SI 5 \"=X,1\"))\n+   (clobber (match_scratch:SI 6 \"=d,d\"))]\n+  \"ISA_HAS_MACC && !ISA_HAS_MSAC\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 6)\n+\t(neg:SI (match_dup 3)))\n+   (parallel\n+       [(set (match_dup 0)\n+\t     (plus:SI (mult:SI (match_dup 2)\n+\t\t\t       (match_dup 6))\n+\t\t      (match_dup 1)))\n+\t(clobber (match_dup 4))\n+\t(clobber (match_dup 5))])]\n+  \"\"\n+  [(set_attr \"type\"     \"imadd\")\n+   (set_attr \"length\"\t\"8\")])\n+\n ;; Patterns generated by the define_peephole2 below.\n \n (define_insn \"*macc2\"\n@@ -2367,7 +2427,8 @@\n   else if (TARGET_MIPS5500)\n     return \"maddu\\t%1,%2\";\n   else\n-    return \"maccu\\t%.,%1,%2\";\n+    /* See comment in *macc.  */\n+    return \"%[maccu\\t%@,%1,%2%]\";\n }\n   [(set_attr \"type\"   \"imadd\")\n    (set_attr \"mode\"   \"SI\")])\n@@ -2387,7 +2448,8 @@\n   else if (TARGET_MIPS5500)\n     return \"madd\\t%1,%2\";\n   else\n-    return \"macc\\t%.,%1,%2\";\n+    /* See comment in *macc.  */\n+    return \"%[macc\\t%@,%1,%2%]\";\n }\n   [(set_attr \"type\"   \"imadd\")\n    (set_attr \"mode\"   \"SI\")])"}, {"sha": "ea27ed0cc3d6a3aae39600941fe291ba3a8b8044", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc884a86d3ffa4108b66a232d18eb3fa35000863/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=dc884a86d3ffa4108b66a232d18eb3fa35000863", "patch": "@@ -483,7 +483,8 @@ in the following sections.\n -mfix-vr4120  -mno-fix-vr4120  -mfix-sb1  -mno-fix-sb1 @gol\n -mflush-func=@var{func}  -mno-flush-func @gol\n -mbranch-likely  -mno-branch-likely @gol\n--mfp-exceptions -mno-fp-exceptions}\n+-mfp-exceptions -mno-fp-exceptions @gol\n+-mvr4130-align -mno-vr4130-align}\n \n @emph{i386 and x86-64 Options}\n @gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} @gol\n@@ -8245,6 +8246,18 @@ enabled.\n For instance, on the SB-1, if FP exceptions are disabled, and we are emitting\n 64-bit code, then we can use both FP pipes.  Otherwise, we can only use one\n FP pipe.\n+\n+@item -mvr4130-align\n+@itemx -mno-vr4130-align\n+@opindex mvr4130-align\n+The VR4130 pipeline is two-way superscalar, but can only issue two\n+instructions together if the first one is 8-byte aligned.  When this\n+option is enabled, GCC will align pairs of instructions that it\n+thinks should execute in parallel.\n+\n+This option only has an effect when optimizing for the VR4130.\n+It normally makes code faster, but at the expense of making it bigger.\n+It is enabled by default at optimization level @option{-O3}.\n @end table\n \n @node i386 and x86-64 Options"}]}