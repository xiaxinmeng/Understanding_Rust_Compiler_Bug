{"sha": "28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhiMjFlYmJkYjdiYzQ4YTFmM2RlMzZiZjRmOThhNThhMDBjNTRlYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-09T15:38:54Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-09T15:38:54Z"}, "message": "rs6000.c (rs6000_output_function_prologue): Don't try to insert an rtl prologue here.\n\n\t* config/rs6000/rs6000.c (rs6000_output_function_prologue): Don't\n\ttry to insert an rtl prologue here.\n\t(rs6000_output_function_epilogue): Similarly.\n\t* config/rs6000/rs6000.md (prologue): Emit a barrier to\n\tsatisfy !TARGET_SCHED_PROLOG.\n\t(epilogue, sibcall_epilogue): Likewise.\n\nFrom-SVN: r176081", "tree": {"sha": "1a583bd73cbd8f60abb61f707a38a9b9f8be16da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a583bd73cbd8f60abb61f707a38a9b9f8be16da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec/comments", "author": null, "committer": null, "parents": [{"sha": "41de45c6a0d599a3913afffb9c3288663094a55a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41de45c6a0d599a3913afffb9c3288663094a55a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41de45c6a0d599a3913afffb9c3288663094a55a"}], "stats": {"total": 116, "additions": 29, "deletions": 87}, "files": [{"sha": "9291ee814d67996321857012e4a2c240d8e4a734", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec", "patch": "@@ -1,3 +1,12 @@\n+2011-07-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_output_function_prologue): Don't\n+\ttry to insert an rtl prologue here.\n+\t(rs6000_output_function_epilogue): Similarly.\n+\t* config/rs6000/rs6000.md (prologue): Emit a barrier to\n+\tsatisfy !TARGET_SCHED_PROLOG.\n+\t(epilogue, sibcall_epilogue): Likewise.\n+\n 2011-07-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc.h (STACK_SAVEAREA_MODE): Move around.\n@@ -864,10 +873,10 @@\n \tPR tree-optimization/49580\n \t* tree-cfg.c (gimple_duplicate_sese_tail): Remove handling of \n \tthe loop's number of iterations.\n-        * tree-parloops.c (transform_to_exit_first_loop): Add the \n+\t* tree-parloops.c (transform_to_exit_first_loop): Add the \n \thandling of the loop's number of iterations before the call \n \tto gimple_duplicate_sese_tail.\n-        Insert the stmt caclculating the new rhs of the loop's\n+\tInsert the stmt caclculating the new rhs of the loop's\n \tcondition stmt to the preheader instead of iters_bb.\n \n 2011-07-05  H.J. Lu  <hongjiu.lu@intel.com>"}, {"sha": "a25e5af488b651a30a80c563e43d801b7ce6c0a4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec", "patch": "@@ -20570,39 +20570,6 @@ rs6000_output_function_prologue (FILE *file,\n       common_mode_defined = 1;\n     }\n \n-  if (! HAVE_prologue)\n-    {\n-      rtx prologue;\n-\n-      start_sequence ();\n-\n-      /* A NOTE_INSN_DELETED is supposed to be at the start and end of\n-\t the \"toplevel\" insn chain.  */\n-      emit_note (NOTE_INSN_DELETED);\n-      rs6000_emit_prologue ();\n-      emit_note (NOTE_INSN_DELETED);\n-\n-      /* Expand INSN_ADDRESSES so final() doesn't crash.  */\n-      {\n-\trtx insn;\n-\tunsigned addr = 0;\n-\tfor (insn = get_insns (); insn != 0; insn = NEXT_INSN (insn))\n-\t  {\n-\t    INSN_ADDRESSES_NEW (insn, addr);\n-\t    addr += 4;\n-\t  }\n-      }\n-\n-      prologue = get_insns ();\n-      end_sequence ();\n-\n-      if (TARGET_DEBUG_STACK)\n-\tdebug_rtx_list (prologue, 100);\n-\n-      emit_insn_before_noloc (prologue, BB_HEAD (ENTRY_BLOCK_PTR->next_bb),\n-\t\t\t      ENTRY_BLOCK_PTR);\n-    }\n-\n   rs6000_pic_labelno++;\n }\n \n@@ -21413,43 +21380,6 @@ static void\n rs6000_output_function_epilogue (FILE *file,\n \t\t\t\t HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  if (! HAVE_epilogue)\n-    {\n-      rtx insn = get_last_insn ();\n-      /* If the last insn was a BARRIER, we don't have to write anything except\n-\t the trace table.  */\n-      if (GET_CODE (insn) == NOTE)\n-\tinsn = prev_nonnote_insn (insn);\n-      if (insn == 0 ||  GET_CODE (insn) != BARRIER)\n-\t{\n-\t  /* This is slightly ugly, but at least we don't have two\n-\t     copies of the epilogue-emitting code.  */\n-\t  start_sequence ();\n-\n-\t  /* A NOTE_INSN_DELETED is supposed to be at the start\n-\t     and end of the \"toplevel\" insn chain.  */\n-\t  emit_note (NOTE_INSN_DELETED);\n-\t  rs6000_emit_epilogue (FALSE);\n-\t  emit_note (NOTE_INSN_DELETED);\n-\n-\t  /* Expand INSN_ADDRESSES so final() doesn't crash.  */\n-\t  {\n-\t    rtx insn;\n-\t    unsigned addr = 0;\n-\t    for (insn = get_insns (); insn != 0; insn = NEXT_INSN (insn))\n-\t      {\n-\t\tINSN_ADDRESSES_NEW (insn, addr);\n-\t\taddr += 4;\n-\t      }\n-\t  }\n-\n-\t  if (TARGET_DEBUG_STACK)\n-\t    debug_rtx_list (get_insns (), 100);\n-\t  final (get_insns (), file, FALSE);\n-\t  end_sequence ();\n-\t}\n-    }\n-\n #if TARGET_MACHO\n   macho_branch_islands ();\n   /* Mach-O doesn't support labels at the end of objects, so if"}, {"sha": "a40444896926d699364b80aa8cf7ebe307a27b6d", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=28b21ebbdb7bc48a1f3de36bf4f98a58a00c54ec", "patch": "@@ -13025,12 +13025,13 @@\n \n (define_expand \"sibcall_epilogue\"\n   [(use (const_int 0))]\n-  \"TARGET_SCHED_PROLOG\"\n-  \"\n+  \"\"\n {\n-      rs6000_emit_epilogue (TRUE);\n-      DONE;\n-}\")\n+  if (!TARGET_SCHED_PROLOG)\n+    emit_insn (gen_blockage ());\n+  rs6000_emit_epilogue (TRUE);\n+  DONE;\n+})\n \n ;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n ;; all of memory.  This blocks insns from being moved across this point.\n@@ -15791,12 +15792,13 @@\n \n (define_expand \"prologue\"\n   [(use (const_int 0))]\n-  \"TARGET_SCHED_PROLOG\"\n-  \"\n+  \"\"\n {\n-      rs6000_emit_prologue ();\n-      DONE;\n-}\")\n+  rs6000_emit_prologue ();\n+  if (!TARGET_SCHED_PROLOG)\n+    emit_insn (gen_blockage ());\n+  DONE;\n+})\n \n (define_insn \"*movesi_from_cr_one\"\n   [(match_parallel 0 \"mfcr_operation\"\n@@ -15946,12 +15948,13 @@\n \n (define_expand \"epilogue\"\n   [(use (const_int 0))]\n-  \"TARGET_SCHED_PROLOG\"\n-  \"\n+  \"\"\n {\n-      rs6000_emit_epilogue (FALSE);\n-      DONE;\n-}\")\n+  if (!TARGET_SCHED_PROLOG)\n+    emit_insn (gen_blockage ());\n+  rs6000_emit_epilogue (FALSE);\n+  DONE;\n+})\n \n ; On some processors, doing the mtcrf one CC register at a time is\n ; faster (like on the 604e).  On others, doing them all at once is"}]}