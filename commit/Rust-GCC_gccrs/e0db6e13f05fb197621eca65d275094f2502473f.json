{"sha": "e0db6e13f05fb197621eca65d275094f2502473f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBkYjZlMTNmMDVmYjE5NzYyMWVjYTY1ZDI3NTA5NGYyNTAyNDczZg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-09-10T14:22:06Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:21Z"}, "message": "Converted Parser to template in preparation for macro expansion", "tree": {"sha": "87292b66be33f12c44eafb75b326c9275f27ce7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87292b66be33f12c44eafb75b326c9275f27ce7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0db6e13f05fb197621eca65d275094f2502473f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0db6e13f05fb197621eca65d275094f2502473f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0db6e13f05fb197621eca65d275094f2502473f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0db6e13f05fb197621eca65d275094f2502473f/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daedbe3476556f0b39f595debeea6979382d296b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daedbe3476556f0b39f595debeea6979382d296b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daedbe3476556f0b39f595debeea6979382d296b"}], "stats": {"total": 28326, "additions": 14220, "deletions": 14106}, "files": [{"sha": "1e300477af9bd977ad588a6a787b441a72ec4436", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "added", "additions": 13692, "deletions": 0, "changes": 13692, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=e0db6e13f05fb197621eca65d275094f2502473f"}, {"sha": "883735f43c2342fba9689ce911a308021e603508", "filename": "gcc/rust/parse/rust-parse.cc", "status": "modified", "additions": 3, "deletions": 13571, "changes": 13574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=e0db6e13f05fb197621eca65d275094f2502473f"}, {"sha": "2cf503a9226434dedeb4919997f0053e7c92760a", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 336, "deletions": 331, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=e0db6e13f05fb197621eca65d275094f2502473f", "patch": "@@ -10,34 +10,34 @@ namespace Rust {\n  * probably take up the same amount of space. */\n struct ExprOrStmt\n {\n-  ::std::unique_ptr<AST::ExprWithoutBlock> expr;\n-  ::std::unique_ptr<AST::Stmt> stmt;\n+  std::unique_ptr<AST::ExprWithoutBlock> expr;\n+  std::unique_ptr<AST::Stmt> stmt;\n \n   /* I was going to resist the urge to make this a real class and make it POD,\n    * but construction in steps is too difficult. So it'll just also have a\n    * constructor. */\n \n   // expression constructor\n-  ExprOrStmt (::std::unique_ptr<AST::ExprWithoutBlock> expr)\n-    : expr (::std::move (expr))\n+  ExprOrStmt (std::unique_ptr<AST::ExprWithoutBlock> expr)\n+    : expr (std::move (expr))\n   {}\n \n   // statement constructor\n-  ExprOrStmt (::std::unique_ptr<AST::Stmt> stmt) : stmt (::std::move (stmt)) {}\n+  ExprOrStmt (std::unique_ptr<AST::Stmt> stmt) : stmt (std::move (stmt)) {}\n \n   // Returns whether this object is in an error state.\n-  inline bool is_error () const\n+  bool is_error () const\n   {\n-    return (expr == NULL && stmt == NULL) || (expr != NULL && stmt != NULL);\n+    return (expr == nullptr && stmt == nullptr) || (expr != nullptr && stmt != nullptr);\n   }\n \n   // Returns an error state object.\n-  static ExprOrStmt create_error () { return ExprOrStmt (NULL, NULL); }\n+  static ExprOrStmt create_error () { return ExprOrStmt (nullptr, nullptr); }\n \n   ~ExprOrStmt () = default;\n \n-  // no copy constructors/assignment copy as simple object like this shouldn't\n-  // require it\n+  /* no copy constructors/assignment as simple object like this shouldn't\n+   * require it */\n \n   // move constructors\n   ExprOrStmt (ExprOrStmt &&other) = default;\n@@ -58,7 +58,7 @@ struct ExprOrStmt\n };\n \n /* Restrictions on parsing used to signal that certain ambiguous grammar\n- * features should be parsed in a certain way.*/\n+ * features should be parsed in a certain way. */\n struct ParseRestrictions\n {\n   bool can_be_struct_expr = true;\n@@ -68,6 +68,8 @@ struct ParseRestrictions\n };\n \n // Parser implementation for gccrs.\n+// TODO: if updated to C++20, ManagedTokenSource would be useful as a concept\n+template <typename ManagedTokenSource> \n class Parser\n {\n private:\n@@ -85,18 +87,18 @@ class Parser\n   void parse_statement_seq (bool (Parser::*done) ());\n \n   // AST-related stuff - maybe move or something?\n-  ::std::vector<AST::Attribute> parse_inner_attributes ();\n+  std::vector<AST::Attribute> parse_inner_attributes ();\n   AST::Attribute parse_inner_attribute ();\n-  ::std::vector<AST::Attribute> parse_outer_attributes ();\n+  std::vector<AST::Attribute> parse_outer_attributes ();\n   AST::Attribute parse_outer_attribute ();\n   AST::Attribute parse_attribute_body ();\n-  ::std::unique_ptr<AST::AttrInput> parse_attr_input ();\n+  std::unique_ptr<AST::AttrInput> parse_attr_input ();\n \n   // Path-related\n   AST::SimplePath parse_simple_path ();\n   AST::SimplePathSegment parse_simple_path_segment ();\n   AST::TypePath parse_type_path ();\n-  ::std::unique_ptr<AST::TypePathSegment> parse_type_path_segment ();\n+  std::unique_ptr<AST::TypePathSegment> parse_type_path_segment ();\n   AST::PathIdentSegment parse_path_ident_segment ();\n   AST::GenericArgs parse_path_generic_args ();\n   AST::GenericArgsBinding parse_generic_args_binding ();\n@@ -110,436 +112,436 @@ class Parser\n \n   // Token tree or macro related\n   AST::DelimTokenTree parse_delim_token_tree ();\n-  ::std::unique_ptr<AST::TokenTree> parse_token_tree ();\n-  ::std::unique_ptr<AST::MacroRulesDefinition>\n-  parse_macro_rules_def (::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::MacroInvocationSemi>\n-  parse_macro_invocation_semi (::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::MacroInvocation>\n-  parse_macro_invocation (::std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::TokenTree> parse_token_tree ();\n+  std::unique_ptr<AST::MacroRulesDefinition>\n+  parse_macro_rules_def (std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::MacroInvocationSemi>\n+  parse_macro_invocation_semi (std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::MacroInvocation>\n+  parse_macro_invocation (std::vector<AST::Attribute> outer_attrs);\n   AST::MacroRule parse_macro_rule ();\n   AST::MacroMatcher parse_macro_matcher ();\n-  ::std::unique_ptr<AST::MacroMatch> parse_macro_match ();\n-  ::std::unique_ptr<AST::MacroMatchFragment> parse_macro_match_fragment ();\n-  ::std::unique_ptr<AST::MacroMatchRepetition> parse_macro_match_repetition ();\n+  std::unique_ptr<AST::MacroMatch> parse_macro_match ();\n+  std::unique_ptr<AST::MacroMatchFragment> parse_macro_match_fragment ();\n+  std::unique_ptr<AST::MacroMatchRepetition> parse_macro_match_repetition ();\n \n   // Top-level item-related\n-  ::std::vector< ::std::unique_ptr<AST::Item> > parse_items ();\n-  ::std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n-  ::std::unique_ptr<AST::VisItem>\n-  parse_vis_item (::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::MacroItem>\n-  parse_macro_item (::std::vector<AST::Attribute> outer_attrs);\n+  std::vector< std::unique_ptr<AST::Item> > parse_items ();\n+  std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n+  std::unique_ptr<AST::VisItem>\n+  parse_vis_item (std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::MacroItem>\n+  parse_macro_item (std::vector<AST::Attribute> outer_attrs);\n   AST::Visibility parse_visibility ();\n \n   // VisItem subclass-related\n-  ::std::unique_ptr<AST::Module>\n-  parse_module (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::ExternCrate>\n+  std::unique_ptr<AST::Module>\n+  parse_module (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::ExternCrate>\n   parse_extern_crate (AST::Visibility vis,\n-\t\t      ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::UseDeclaration>\n+\t\t      std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::UseDeclaration>\n   parse_use_decl (AST::Visibility vis,\n-\t\t  ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::UseTree> parse_use_tree ();\n-  ::std::unique_ptr<AST::Function>\n+\t\t  std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::UseTree> parse_use_tree ();\n+  std::unique_ptr<AST::Function>\n   parse_function (AST::Visibility vis,\n-\t\t  ::std::vector<AST::Attribute> outer_attrs);\n+\t\t  std::vector<AST::Attribute> outer_attrs);\n   AST::FunctionQualifiers parse_function_qualifiers ();\n-  ::std::vector< ::std::unique_ptr<AST::GenericParam> >\n+  std::vector< std::unique_ptr<AST::GenericParam> >\n   parse_generic_params_in_angles ();\n-  ::std::vector< ::std::unique_ptr<AST::GenericParam> > parse_generic_params ();\n-  ::std::vector< ::std::unique_ptr<AST::LifetimeParam> >\n+  std::vector< std::unique_ptr<AST::GenericParam> > parse_generic_params ();\n+  std::vector< std::unique_ptr<AST::LifetimeParam> >\n   parse_lifetime_params ();\n-  ::std::vector<AST::LifetimeParam> parse_lifetime_params_objs ();\n+  std::vector<AST::LifetimeParam> parse_lifetime_params_objs ();\n   AST::LifetimeParam parse_lifetime_param ();\n-  ::std::vector< ::std::unique_ptr<AST::TypeParam> > parse_type_params ();\n-  ::std::unique_ptr<AST::TypeParam> parse_type_param ();\n-  ::std::vector<AST::FunctionParam> parse_function_params ();\n+  std::vector< std::unique_ptr<AST::TypeParam> > parse_type_params ();\n+  std::unique_ptr<AST::TypeParam> parse_type_param ();\n+  std::vector<AST::FunctionParam> parse_function_params ();\n   AST::FunctionParam parse_function_param ();\n-  ::std::unique_ptr<AST::Type> parse_function_return_type ();\n+  std::unique_ptr<AST::Type> parse_function_return_type ();\n   AST::WhereClause parse_where_clause ();\n-  ::std::unique_ptr<AST::WhereClauseItem> parse_where_clause_item ();\n-  ::std::unique_ptr<AST::LifetimeWhereClauseItem>\n+  std::unique_ptr<AST::WhereClauseItem> parse_where_clause_item ();\n+  std::unique_ptr<AST::LifetimeWhereClauseItem>\n   parse_lifetime_where_clause_item ();\n-  ::std::unique_ptr<AST::TypeBoundWhereClauseItem>\n+  std::unique_ptr<AST::TypeBoundWhereClauseItem>\n   parse_type_bound_where_clause_item ();\n-  ::std::vector<AST::LifetimeParam> parse_for_lifetimes ();\n-  ::std::vector< ::std::unique_ptr<AST::TypeParamBound> >\n+  std::vector<AST::LifetimeParam> parse_for_lifetimes ();\n+  std::vector< std::unique_ptr<AST::TypeParamBound> >\n   parse_type_param_bounds ();\n-  ::std::unique_ptr<AST::TypeParamBound> parse_type_param_bound ();\n-  ::std::unique_ptr<AST::TraitBound> parse_trait_bound ();\n-  ::std::vector<AST::Lifetime> parse_lifetime_bounds ();\n+  std::unique_ptr<AST::TypeParamBound> parse_type_param_bound ();\n+  std::unique_ptr<AST::TraitBound> parse_trait_bound ();\n+  std::vector<AST::Lifetime> parse_lifetime_bounds ();\n   AST::Lifetime parse_lifetime ();\n-  ::std::unique_ptr<AST::TypeAlias>\n+  std::unique_ptr<AST::TypeAlias>\n   parse_type_alias (AST::Visibility vis,\n-\t\t    ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::Struct>\n-  parse_struct (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::vector<AST::StructField> parse_struct_fields ();\n+\t\t    std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::Struct>\n+  parse_struct (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::vector<AST::StructField> parse_struct_fields ();\n   AST::StructField parse_struct_field ();\n-  ::std::vector<AST::TupleField> parse_tuple_fields ();\n+  std::vector<AST::TupleField> parse_tuple_fields ();\n   AST::TupleField parse_tuple_field ();\n-  ::std::unique_ptr<AST::Enum>\n-  parse_enum (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::vector< ::std::unique_ptr<AST::EnumItem> > parse_enum_items ();\n-  ::std::unique_ptr<AST::EnumItem> parse_enum_item ();\n-  ::std::unique_ptr<AST::Union>\n-  parse_union (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::ConstantItem>\n+  std::unique_ptr<AST::Enum>\n+  parse_enum (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::vector< std::unique_ptr<AST::EnumItem> > parse_enum_items ();\n+  std::unique_ptr<AST::EnumItem> parse_enum_item ();\n+  std::unique_ptr<AST::Union>\n+  parse_union (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::ConstantItem>\n   parse_const_item (AST::Visibility vis,\n-\t\t    ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::StaticItem>\n+\t\t    std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::StaticItem>\n   parse_static_item (AST::Visibility vis,\n-\t\t     ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::Trait>\n-  parse_trait (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::TraitItem> parse_trait_item ();\n-  ::std::unique_ptr<AST::TraitItemType>\n-  parse_trait_type (::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::TraitItemConst>\n-  parse_trait_const (::std::vector<AST::Attribute> outer_attrs);\n+\t\t     std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::Trait>\n+  parse_trait (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::TraitItem> parse_trait_item ();\n+  std::unique_ptr<AST::TraitItemType>\n+  parse_trait_type (std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::TraitItemConst>\n+  parse_trait_const (std::vector<AST::Attribute> outer_attrs);\n   AST::SelfParam parse_self_param ();\n-  ::std::unique_ptr<AST::Impl>\n-  parse_impl (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item ();\n-  ::std::unique_ptr<AST::InherentImplItem>\n+  std::unique_ptr<AST::Impl>\n+  parse_impl (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item ();\n+  std::unique_ptr<AST::InherentImplItem>\n   parse_inherent_impl_function_or_method (\n-    AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::TraitImplItem> parse_trait_impl_item ();\n-  ::std::unique_ptr<AST::TraitImplItem> parse_trait_impl_function_or_method (\n-    AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::ExternBlock>\n+    AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::TraitImplItem> parse_trait_impl_item ();\n+  std::unique_ptr<AST::TraitImplItem> parse_trait_impl_function_or_method (\n+    AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::ExternBlock>\n   parse_extern_block (AST::Visibility vis,\n-\t\t      ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::ExternalItem> parse_external_item ();\n+\t\t      std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::ExternalItem> parse_external_item ();\n   AST::NamedFunctionParam parse_named_function_param ();\n   AST::Method parse_method ();\n \n   // Expression-related (Pratt parsed)\n-  ::std::unique_ptr<AST::Expr>\n-  parse_expr (::std::vector<AST::Attribute> outer_attrs\n-\t      = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::Expr>\n+  parse_expr (std::vector<AST::Attribute> outer_attrs\n+\t      = std::vector<AST::Attribute> (),\n \t      ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::Expr>\n+  std::unique_ptr<AST::Expr>\n   parse_expr (int right_binding_power,\n-\t      ::std::vector<AST::Attribute> outer_attrs\n-\t      = ::std::vector<AST::Attribute> (),\n+\t      std::vector<AST::Attribute> outer_attrs\n+\t      = std::vector<AST::Attribute> (),\n \t      ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::Expr>\n-  null_denotation_NEW (const_TokenPtr t,\n-\t\t       ::std::vector<AST::Attribute> outer_attrs\n-\t\t       = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::Expr>\n+  null_denotation (const_TokenPtr t,\n+\t\t       std::vector<AST::Attribute> outer_attrs\n+\t\t       = std::vector<AST::Attribute> (),\n \t\t       ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::Expr>\n-  left_denotation (const_TokenPtr t, ::std::unique_ptr<AST::Expr> left,\n-\t\t   ::std::vector<AST::Attribute> outer_attrs\n-\t\t   = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::Expr>\n+  left_denotation (const_TokenPtr t, std::unique_ptr<AST::Expr> left,\n+\t\t   std::vector<AST::Attribute> outer_attrs\n+\t\t   = std::vector<AST::Attribute> (),\n \t\t   ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n-  parse_binary_plus_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_plus_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  std::vector<AST::Attribute> outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_minus_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_minus_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n-  parse_binary_mult_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_mult_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  std::vector<AST::Attribute> outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n-  parse_binary_div_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_div_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t std::vector<AST::Attribute> outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n-  parse_binary_mod_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_mod_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t std::vector<AST::Attribute> outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n-  parse_bitwise_and_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_bitwise_and_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  std::vector<AST::Attribute> outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n-  parse_bitwise_or_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_bitwise_or_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t std::vector<AST::Attribute> outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n-  parse_bitwise_xor_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_bitwise_xor_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  std::vector<AST::Attribute> outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n-  parse_left_shift_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_left_shift_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t std::vector<AST::Attribute> outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n-  parse_right_shift_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_right_shift_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  std::vector<AST::Attribute> outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_equal_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ComparisonExpr> parse_binary_equal_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_not_equal_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ComparisonExpr> parse_binary_not_equal_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_than_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_than_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_less_than_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ComparisonExpr> parse_binary_less_than_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_equal_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_equal_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_less_equal_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ComparisonExpr> parse_binary_less_equal_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::LazyBooleanExpr>\n-  parse_lazy_or_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t      ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::LazyBooleanExpr>\n+  parse_lazy_or_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t      std::vector<AST::Attribute> outer_attrs,\n \t\t      ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::LazyBooleanExpr>\n-  parse_lazy_and_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t       ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::LazyBooleanExpr>\n+  parse_lazy_and_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t       std::vector<AST::Attribute> outer_attrs,\n \t\t       ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::TypeCastExpr>\n+  std::unique_ptr<AST::TypeCastExpr>\n   parse_type_cast_expr (const_TokenPtr tok,\n-\t\t\t::std::unique_ptr<AST::Expr> expr_to_cast,\n-\t\t\t::std::vector<AST::Attribute> outer_attrs,\n+\t\t\tstd::unique_ptr<AST::Expr> expr_to_cast,\n+\t\t\tstd::vector<AST::Attribute> outer_attrs,\n \t\t\tParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::AssignmentExpr>\n-  parse_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::AssignmentExpr>\n+  parse_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t    std::vector<AST::Attribute> outer_attrs,\n \t\t    ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n-  parse_plus_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_plus_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t std::vector<AST::Attribute> outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n-  parse_minus_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_minus_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  std::vector<AST::Attribute> outer_attrs,\n \t\t\t  ParseRestrictions restrictions\n \t\t\t  = ParseRestrictions ());\n-  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n-  parse_mult_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_mult_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t std::vector<AST::Attribute> outer_attrs,\n \t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n-  parse_div_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_div_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\tstd::vector<AST::Attribute> outer_attrs,\n \t\t\tParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n-  parse_mod_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_mod_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\tstd::vector<AST::Attribute> outer_attrs,\n \t\t\tParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n-  parse_and_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_and_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\tstd::vector<AST::Attribute> outer_attrs,\n \t\t\tParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n-  parse_or_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t       ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_or_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t       std::vector<AST::Attribute> outer_attrs,\n \t\t       ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n-  parse_xor_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-\t\t\t::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_xor_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\tstd::vector<AST::Attribute> outer_attrs,\n \t\t\tParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_left_shift_assig_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::CompoundAssignmentExpr> parse_left_shift_assig_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_right_shift_assig_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::CompoundAssignmentExpr> parse_right_shift_assig_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::AwaitExpr>\n+  std::unique_ptr<AST::AwaitExpr>\n   parse_await_expr (const_TokenPtr tok,\n-\t\t    ::std::unique_ptr<AST::Expr> expr_to_await,\n-\t\t    ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::MethodCallExpr> parse_method_call_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> receiver_expr,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+\t\t    std::unique_ptr<AST::Expr> expr_to_await,\n+\t\t    std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::MethodCallExpr> parse_method_call_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> receiver_expr,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::CallExpr> parse_function_call_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> function_expr,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::CallExpr> parse_function_call_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> function_expr,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::RangeExpr> parse_led_range_exclusive_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::RangeExpr> parse_led_range_exclusive_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::RangeExpr>\n+  std::unique_ptr<AST::RangeExpr>\n   parse_nud_range_exclusive_expr (const_TokenPtr tok,\n-\t\t\t\t  ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::RangeFromToInclExpr> parse_range_inclusive_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t\t  std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::RangeFromToInclExpr> parse_range_inclusive_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::RangeToInclExpr>\n+  std::unique_ptr<AST::RangeToInclExpr>\n   parse_range_to_inclusive_expr (const_TokenPtr tok,\n-\t\t\t\t ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> tuple_expr,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t\t std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> tuple_expr,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::FieldAccessExpr> parse_field_access_expr (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> struct_expr,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::FieldAccessExpr> parse_field_access_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> struct_expr,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::ArrayIndexExpr>\n-  parse_index_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> array_expr,\n-\t\t    ::std::vector<AST::Attribute> outer_attrs,\n+  std::unique_ptr<AST::ArrayIndexExpr>\n+  parse_index_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> array_expr,\n+\t\t    std::vector<AST::Attribute> outer_attrs,\n \t\t    ParseRestrictions restrictions = ParseRestrictions ());\n-  ::std::unique_ptr<AST::MacroInvocation>\n+  std::unique_ptr<AST::MacroInvocation>\n   parse_macro_invocation_partial (AST::PathInExpression path,\n-\t\t\t\t  ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::StructExprStruct>\n+\t\t\t\t  std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::StructExprStruct>\n   parse_struct_expr_struct_partial (AST::PathInExpression path,\n-\t\t\t\t    ::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::CallExpr>\n+\t\t\t\t    std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::CallExpr>\n   parse_struct_expr_tuple_partial (AST::PathInExpression path,\n-\t\t\t\t   ::std::vector<AST::Attribute> outer_attrs);\n+\t\t\t\t   std::vector<AST::Attribute> outer_attrs);\n   AST::PathInExpression parse_path_in_expression_pratt (const_TokenPtr tok);\n-  ::std::unique_ptr<AST::ClosureExpr>\n+  std::unique_ptr<AST::ClosureExpr>\n   parse_closure_expr_pratt (const_TokenPtr tok,\n-\t\t\t    ::std::vector<AST::Attribute> outer_attrs\n-\t\t\t    = ::std::vector<AST::Attribute> ());\n-  ::std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr_float (\n-    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> tuple_expr,\n-    ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t    std::vector<AST::Attribute> outer_attrs\n+\t\t\t    = std::vector<AST::Attribute> ());\n+  std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr_float (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> tuple_expr,\n+    std::vector<AST::Attribute> outer_attrs,\n     ParseRestrictions restrictions = ParseRestrictions ());\n \n   // Expression-related (non-Pratt parsed)\n-  ::std::unique_ptr<AST::ExprWithoutBlock>\n-  parse_expr_without_block (::std::vector<AST::Attribute> outer_attrs\n-\t\t\t    = ::std::vector<AST::Attribute> ());\n-  ::std::unique_ptr<AST::BlockExpr>\n-  parse_block_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t    = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::ExprWithoutBlock>\n+  parse_expr_without_block (std::vector<AST::Attribute> outer_attrs\n+\t\t\t    = std::vector<AST::Attribute> ());\n+  std::unique_ptr<AST::BlockExpr>\n+  parse_block_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t    = std::vector<AST::Attribute> (),\n \t\t    bool pratt_parse = false);\n-  ::std::unique_ptr<AST::IfExpr>\n-  parse_if_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t = ::std::vector<AST::Attribute> ());\n-  ::std::unique_ptr<AST::IfLetExpr>\n-  parse_if_let_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t     = ::std::vector<AST::Attribute> ());\n-  ::std::unique_ptr<AST::LoopExpr>\n-  parse_loop_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t   = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::IfExpr>\n+  parse_if_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t = std::vector<AST::Attribute> ());\n+  std::unique_ptr<AST::IfLetExpr>\n+  parse_if_let_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t     = std::vector<AST::Attribute> ());\n+  std::unique_ptr<AST::LoopExpr>\n+  parse_loop_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t   = std::vector<AST::Attribute> (),\n \t\t   AST::LoopLabel label = AST::LoopLabel::error ());\n-  ::std::unique_ptr<AST::WhileLoopExpr>\n-  parse_while_loop_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t\t = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::WhileLoopExpr>\n+  parse_while_loop_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t\t = std::vector<AST::Attribute> (),\n \t\t\t AST::LoopLabel label = AST::LoopLabel::error ());\n-  ::std::unique_ptr<AST::WhileLetLoopExpr>\n-  parse_while_let_loop_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t\t     = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::WhileLetLoopExpr>\n+  parse_while_let_loop_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t\t     = std::vector<AST::Attribute> (),\n \t\t\t     AST::LoopLabel label = AST::LoopLabel::error ());\n-  ::std::unique_ptr<AST::ForLoopExpr>\n-  parse_for_loop_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t       = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::ForLoopExpr>\n+  parse_for_loop_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t       = std::vector<AST::Attribute> (),\n \t\t       AST::LoopLabel label = AST::LoopLabel::error ());\n-  ::std::unique_ptr<AST::MatchExpr>\n-  parse_match_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t    = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::MatchExpr>\n+  parse_match_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t    = std::vector<AST::Attribute> (),\n \t\t    bool pratt_parse = false);\n   AST::MatchArm parse_match_arm ();\n-  ::std::vector< ::std::unique_ptr<AST::Pattern> >\n+  std::vector< std::unique_ptr<AST::Pattern> >\n   parse_match_arm_patterns (TokenId end_token_id);\n-  ::std::unique_ptr<AST::BaseLoopExpr>\n-  parse_labelled_loop_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t\t    = ::std::vector<AST::Attribute> ());\n+  std::unique_ptr<AST::BaseLoopExpr>\n+  parse_labelled_loop_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t\t    = std::vector<AST::Attribute> ());\n   AST::LoopLabel parse_loop_label ();\n-  ::std::unique_ptr<AST::AsyncBlockExpr>\n-  parse_async_block_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t\t  = ::std::vector<AST::Attribute> ());\n-  ::std::unique_ptr<AST::UnsafeBlockExpr>\n-  parse_unsafe_block_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t\t   = ::std::vector<AST::Attribute> ());\n-  ::std::unique_ptr<AST::GroupedExpr>\n-  parse_grouped_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t      = ::std::vector<AST::Attribute> ());\n-  ::std::unique_ptr<AST::ClosureExpr>\n-  parse_closure_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t      = ::std::vector<AST::Attribute> ());\n+  std::unique_ptr<AST::AsyncBlockExpr>\n+  parse_async_block_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t\t  = std::vector<AST::Attribute> ());\n+  std::unique_ptr<AST::UnsafeBlockExpr>\n+  parse_unsafe_block_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t\t   = std::vector<AST::Attribute> ());\n+  std::unique_ptr<AST::GroupedExpr>\n+  parse_grouped_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t      = std::vector<AST::Attribute> ());\n+  std::unique_ptr<AST::ClosureExpr>\n+  parse_closure_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t      = std::vector<AST::Attribute> ());\n   AST::ClosureParam parse_closure_param ();\n-  ::std::unique_ptr<AST::LiteralExpr>\n-  parse_literal_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t      = ::std::vector<AST::Attribute> ());\n-  ::std::unique_ptr<AST::ReturnExpr>\n-  parse_return_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t     = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::LiteralExpr>\n+  parse_literal_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t      = std::vector<AST::Attribute> ());\n+  std::unique_ptr<AST::ReturnExpr>\n+  parse_return_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t     = std::vector<AST::Attribute> (),\n \t\t     bool pratt_parse = false);\n-  ::std::unique_ptr<AST::BreakExpr>\n-  parse_break_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t    = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::BreakExpr>\n+  parse_break_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t    = std::vector<AST::Attribute> (),\n \t\t    bool pratt_parse = false);\n-  ::std::unique_ptr<AST::ContinueExpr>\n-  parse_continue_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t       = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::ContinueExpr>\n+  parse_continue_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t       = std::vector<AST::Attribute> (),\n \t\t       bool pratt_parse = false);\n-  ::std::unique_ptr<AST::ArrayExpr>\n-  parse_array_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t    = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::ArrayExpr>\n+  parse_array_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t    = std::vector<AST::Attribute> (),\n \t\t    bool pratt_parse = false);\n-  ::std::unique_ptr<AST::ExprWithoutBlock>\n-  parse_grouped_or_tuple_expr (::std::vector<AST::Attribute> outer_attrs\n-\t\t\t       = ::std::vector<AST::Attribute> (),\n+  std::unique_ptr<AST::ExprWithoutBlock>\n+  parse_grouped_or_tuple_expr (std::vector<AST::Attribute> outer_attrs\n+\t\t\t       = std::vector<AST::Attribute> (),\n \t\t\t       bool pratt_parse = false);\n-  ::std::unique_ptr<AST::StructExprField> parse_struct_expr_field ();\n+  std::unique_ptr<AST::StructExprField> parse_struct_expr_field ();\n \n   // Type-related\n-  ::std::unique_ptr<AST::Type> parse_type ();\n-  ::std::unique_ptr<AST::TypeNoBounds> parse_type_no_bounds ();\n-  ::std::unique_ptr<AST::TypeNoBounds> parse_slice_or_array_type ();\n-  ::std::unique_ptr<AST::RawPointerType> parse_raw_pointer_type ();\n-  ::std::unique_ptr<AST::ReferenceType> parse_reference_type ();\n-  ::std::unique_ptr<AST::BareFunctionType>\n-  parse_bare_function_type (::std::vector<AST::LifetimeParam> for_lifetimes);\n-  ::std::unique_ptr<AST::Type> parse_paren_prefixed_type ();\n-  ::std::unique_ptr<AST::TypeNoBounds> parse_paren_prefixed_type_no_bounds ();\n-  ::std::unique_ptr<AST::Type> parse_for_prefixed_type ();\n+  std::unique_ptr<AST::Type> parse_type ();\n+  std::unique_ptr<AST::TypeNoBounds> parse_type_no_bounds ();\n+  std::unique_ptr<AST::TypeNoBounds> parse_slice_or_array_type ();\n+  std::unique_ptr<AST::RawPointerType> parse_raw_pointer_type ();\n+  std::unique_ptr<AST::ReferenceType> parse_reference_type ();\n+  std::unique_ptr<AST::BareFunctionType>\n+  parse_bare_function_type (std::vector<AST::LifetimeParam> for_lifetimes);\n+  std::unique_ptr<AST::Type> parse_paren_prefixed_type ();\n+  std::unique_ptr<AST::TypeNoBounds> parse_paren_prefixed_type_no_bounds ();\n+  std::unique_ptr<AST::Type> parse_for_prefixed_type ();\n   AST::MaybeNamedParam parse_maybe_named_param ();\n \n   // Statement-related\n-  ::std::unique_ptr<AST::Stmt> parse_stmt ();\n-  ::std::unique_ptr<AST::LetStmt>\n-  parse_let_stmt (::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::ExprStmt>\n-  parse_expr_stmt (::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::ExprStmtWithBlock>\n-  parse_expr_stmt_with_block (::std::vector<AST::Attribute> outer_attrs);\n-  ::std::unique_ptr<AST::ExprStmtWithoutBlock>\n-  parse_expr_stmt_without_block (::std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::Stmt> parse_stmt ();\n+  std::unique_ptr<AST::LetStmt>\n+  parse_let_stmt (std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::ExprStmt>\n+  parse_expr_stmt (std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::ExprStmtWithBlock>\n+  parse_expr_stmt_with_block (std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::ExprStmtWithoutBlock>\n+  parse_expr_stmt_without_block (std::vector<AST::Attribute> outer_attrs);\n   ExprOrStmt parse_stmt_or_expr_without_block ();\n   ExprOrStmt\n-  parse_macro_invocation_maybe_semi (::std::vector<AST::Attribute> outer_attrs);\n+  parse_macro_invocation_maybe_semi (std::vector<AST::Attribute> outer_attrs);\n   ExprOrStmt\n-  parse_path_based_stmt_or_expr (::std::vector<AST::Attribute> outer_attrs);\n+  parse_path_based_stmt_or_expr (std::vector<AST::Attribute> outer_attrs);\n \n   // Pattern-related\n-  ::std::unique_ptr<AST::Pattern> parse_pattern ();\n-  ::std::unique_ptr<AST::Pattern> parse_literal_or_range_pattern ();\n-  ::std::unique_ptr<AST::RangePatternBound> parse_range_pattern_bound ();\n-  ::std::unique_ptr<AST::ReferencePattern> parse_reference_pattern ();\n-  ::std::unique_ptr<AST::Pattern> parse_grouped_or_tuple_pattern ();\n-  ::std::unique_ptr<AST::SlicePattern> parse_slice_pattern ();\n-  ::std::unique_ptr<AST::IdentifierPattern> parse_identifier_pattern ();\n-  ::std::unique_ptr<AST::Pattern> parse_ident_leading_pattern ();\n-  ::std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items ();\n+  std::unique_ptr<AST::Pattern> parse_pattern ();\n+  std::unique_ptr<AST::Pattern> parse_literal_or_range_pattern ();\n+  std::unique_ptr<AST::RangePatternBound> parse_range_pattern_bound ();\n+  std::unique_ptr<AST::ReferencePattern> parse_reference_pattern ();\n+  std::unique_ptr<AST::Pattern> parse_grouped_or_tuple_pattern ();\n+  std::unique_ptr<AST::SlicePattern> parse_slice_pattern ();\n+  std::unique_ptr<AST::IdentifierPattern> parse_identifier_pattern ();\n+  std::unique_ptr<AST::Pattern> parse_ident_leading_pattern ();\n+  std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items ();\n   AST::StructPatternElements parse_struct_pattern_elems ();\n-  ::std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field ();\n+  std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field ();\n \n   int left_binding_power (const_TokenPtr token);\n \n@@ -548,8 +550,8 @@ class Parser\n   bool done_end_of_file ();\n \n public:\n-  // Construct parser with specified lexer reference.\n-  Parser (Lexer &parLexer) : lexer (parLexer) {}\n+  // Construct parser with specified \"managed\" token source.\n+  Parser (ManagedTokenSource tokenSource) : lexer (std::move(tokenSource)) {}\n \n   // Main entry point for parser.\n   AST::Crate parse_crate ();\n@@ -559,9 +561,12 @@ class Parser\n   void debug_dump_ast_output (AST::Crate &crate);\n \n private:\n-  // The lexer associated with the parser.\n-  Lexer &lexer;\n+  // The token source (usually lexer) associated with the parser.\n+  ManagedTokenSource lexer;\n };\n } // namespace Rust\n \n+// as now template, include implementations of all methods\n+#include \"rust-parse-impl.h\"\n+\n #endif // RUST_PARSE_H"}, {"sha": "275249748f4bf4025f80f0178a965e33ed94da18", "filename": "gcc/rust/rust-lang.cc", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=e0db6e13f05fb197621eca65d275094f2502473f", "patch": "@@ -34,17 +34,11 @@\n // TODO: is this best way to do it? Is it allowed? (should be)\n \n /* General TODOs:\n- *  - maybe convert all raw pointer-returning/passing functions that\n- * conceptually return a unique pointer actually return a unique pointer. i.e.\n- * parse methods and constructors for AST objects. make_unique should probably\n- * be avoided to keep C++11 compatibility.\n  *  - convert all copies of expensive-to-copy (deep copy) AST objects into\n- * moves, if possible. Don't\n- *    remove clone functionality - it may be required for e.g. HIR conversion.\n+ * moves, if possible. Don't remove clone functionality - it may be required for e.g. HIR conversion.\n  */\n \n #include \"rust-system.h\"\n-#include \"rust-parse.h\"\n #include \"rust-session-manager.h\"\n \n #include \"rust-target.h\""}, {"sha": "f6d8ac9138e594dd6052b3a502dfa07a7c3f10ed", "filename": "gcc/rust/rust-linemap.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Frust-linemap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Frust-linemap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-linemap.h?ref=e0db6e13f05fb197621eca65d275094f2502473f", "patch": "@@ -1,6 +1,6 @@\n-// go-linemap.h -- interface to location tracking   -*- C++ -*-\n+// rust-linemap.h -- interface to location tracking   -*- C++ -*-\n \n-// Copyright 2011 The Rust Authors. All rights reserved.\n+// Copyright 2020 The Rust Authors. All rights reserved.\n // Use of this source code is rustverned by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "d75204a7b0498b37e20ceadd2697089cefc9eb27", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 138, "deletions": 142, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=e0db6e13f05fb197621eca65d275094f2502473f", "patch": "@@ -11,7 +11,8 @@\n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n #include \"rust-scan.h\"\n-#include \"rust-resolution.h\"\n+#include \"rust-name-resolution.h\"\n+#include \"rust-type-resolution.h\"\n #include \"rust-compile.h\"\n \n #include \"rust-target.h\"\n@@ -33,7 +34,7 @@ Session::implicitly_enable_feature (std::string feature_name)\n   // TODO: is this really required since features added would be complete via\n   // target spec?\n \n-  if (!options.target_data.has_key_value_pair (\"target_data\", feature_name))\n+  if (!options.target_data.has_key_value_pair (\"target_feature\", feature_name))\n     {\n       // if feature has dependencies, enable them\n       if (feature_name == \"aes\")\n@@ -234,47 +235,45 @@ void\n Session::init ()\n {\n #ifndef TARGET_RUST_OS_INFO\n-#define TARGET_RUST_OS_INFO()\n+# define TARGET_RUST_OS_INFO()\n #endif\n //#define builtin_rust_info(KEY, VALUE) rust_add_target_info (KEY, VALUE)\n // might as well use c++ stuff\n-#define builtin_rust_info(KEY, VALUE)                                          \\\n-  options.target_data.insert_key_value_pair (KEY, VALUE)\n-\n-  // initialise target hooks\n-  // targetrustm.rust_cpu_info();\n-  // targetrustm.rust_os_info();\n-  // ok, that's not working too well TODO - see if can salvage old\n-  // implementation\n-  TARGET_RUST_CPU_INFO ();\n-  TARGET_RUST_OS_INFO ();\n-\n+#define builtin_rust_info(KEY, VALUE) options.target_data.insert_key_value_pair(KEY, VALUE)\n+\n+    // initialise target hooks\n+    //targetrustm.rust_cpu_info();\n+    //targetrustm.rust_os_info();\n+    // ok, that's not working too well TODO - see if can salvage old implementation \n+    TARGET_RUST_CPU_INFO ();\n+    TARGET_RUST_OS_INFO ();\n+\n+    /* note that due to issues with gcc targets, some implementations of those two macros above \n+     * (TARGET_RUST_CPU_INFO and TARGET_RUST_OS_INFO) are not function calls, but actually inline \n+     * substitutions. As such, they can't be stored with a function pointer in a \"real\" target hook. \n+     * At least, that's my current understanding of it. */\n+        \n #undef builtin_rust_info\n \n-  // target-independent values that should exist in all targets\n-  options.target_data.insert_key_value_pair (\"target_pointer_width\",\n-\t\t\t\t\t     std::to_string (POINTER_SIZE));\n-  options.target_data.insert_key_value_pair (\"target_endian\", BYTES_BIG_ENDIAN\n-\t\t\t\t\t\t\t\t? \"big\"\n-\t\t\t\t\t\t\t\t: \"little\");\n+    // target-independent values that should exist in all targets\n+    options.target_data.insert_key_value_pair (\"target_pointer_width\", std::to_string (POINTER_SIZE));\n+    options.target_data.insert_key_value_pair (\"target_endian\", BYTES_BIG_ENDIAN ? \"big\" : \"little\");\n \n-  // TODO: find min atomic width and max atomic width\n-  // from it, add atomic-related stuff for sizes 8, 16, 32, 64, and 128 (if\n-  // inside bounds) in rustc, min atomic width is a known quantity (or 8 if not\n-  // known), and max is also a known quantity (or is pointer size if not known)\n-  // TODO: add atomic pointer if some criteria is satisfied\n+    // TODO: find min atomic width and max atomic width\n+    // from it, add atomic-related stuff for sizes 8, 16, 32, 64, and 128 (if inside bounds)\n+    // in rustc, min atomic width is a known quantity (or 8 if not known), and max is also a known quantity (or is pointer size if not known)\n+    // TODO: add atomic pointer if some criteria is satisfied\n \n-  // TODO: find whether target has \"atomic cas\"\n+    // TODO: find whether target has \"atomic cas\"\n \n-  // add debug_assertions if enabled and proc_macro if crate type has it or\n-  // whatever\n+    // add debug_assertions if enabled and proc_macro if crate type has it or whatever\n \n-  // derived values from hook\n-  options.target_data.init_derived_values ();\n+    // derived values from hook\n+    options.target_data.init_derived_values ();\n }\n \n-// Initialise default options. Actually called before handle_option, unlike init\n-// itself.\n+/* Initialise default options. Actually called before handle_option, unlike init\n+ * itself. */\n void\n Session::init_options ()\n {\n@@ -302,7 +301,7 @@ Session::handle_option (\n       break;\n     case OPT_frust_dump_:\n       // enable dump and return whether this was successful\n-      if (arg != NULL)\n+      if (arg != nullptr)\n \t{\n \t  ret = enable_dump (std::string (arg));\n \t}\n@@ -325,12 +324,12 @@ Session::handle_option (\n bool\n Session::enable_dump (std::string arg)\n {\n-  // FIXME: change dumping algorithm when new non-inhibiting dump system is\n-  // created\n+  /* FIXME: change dumping algorithm when new non-inhibiting dump system is\n+   * created */\n   if (arg == \"all\")\n     {\n-      error_at (\n-\tUNKNOWN_LOCATION,\n+      rust_error_at (\n+\tLocation (),\n \t\"dumping all is not supported as of now. choose 'lex', 'parse', or 'target_options\");\n       return false;\n     }\n@@ -357,25 +356,23 @@ Session::enable_dump (std::string arg)\n   else if (arg == \"resolution\")\n     {\n       options.dump_option = CompileOptions::RESOLUTION_DUMP;\n-    }\n-  else if (arg == \"target_options\")\n-    {\n+    } \n+  else if (arg == \"target_options\") {\n       // special case - dump all target options, and then quit compilation\n-      // nope, option handling called before init, so have to make this an\n-      // actual compile option\n-      // options.target_data.dump_target_options();\n-      // return false;\n+      // nope, option handling called before init, so have to make this an actual compile option\n+      //options.target_data.dump_target_options();\n+      //return false;\n       options.dump_option = CompileOptions::TARGET_OPTION_DUMP;\n     }\n   else if (arg == \"\")\n     {\n-      error_at (UNKNOWN_LOCATION,\n+      rust_error_at (Location (),\n \t\t\"dump option was not given a name. choose 'lex', 'parse', or 'target_options'\");\n       return false;\n     }\n   else\n     {\n-      error_at (UNKNOWN_LOCATION,\n+      rust_error_at (Location (),\n \t\t\"dump option '%s' was unrecognised. choose 'lex', 'parse', or 'target_options\",\n \t\targ.c_str ());\n       return false;\n@@ -392,8 +389,8 @@ Session::parse_files (int num_files, const char **files)\n     {\n       parse_file (files[i]);\n     }\n-  // TODO: should semantic analysis be dealed with here? or per file? for now,\n-  // per-file.\n+  /* TODO: should semantic analysis be dealed with here? or per file? for now,\n+   * per-file. */\n }\n \n // Parses a single file with filename filename.\n@@ -402,18 +399,18 @@ Session::parse_file (const char *filename)\n {\n   RAIIFile file_wrap (filename);\n \n-  if (file_wrap.get_raw() == NULL)\n+  if (file_wrap.get_raw() == nullptr)\n     {\n-      fatal_error (UNKNOWN_LOCATION, \"cannot open filename %s: %m\", filename);\n+      rust_fatal_error (Location (), \"cannot open filename %s: %m\", filename);\n     }\n \n   Backend *backend = rust_get_backend ();\n \n   // parse file here\n   /* create lexer and parser - these are file-specific and so aren't instance\n    * variables */\n-  Rust::Lexer lex (filename, std::move (file_wrap), rust_get_linemap ());\n-  Rust::Parser parser (/*std::move (*/lex/*)*/);\n+  Lexer lex (filename, std::move (file_wrap), rust_get_linemap ());\n+  Parser<Lexer> parser (std::move (lex));\n \n   // generate crate from parser\n   auto parsed_crate = parser.parse_crate ();\n@@ -423,10 +420,14 @@ Session::parse_file (const char *filename)\n     {\n     case CompileOptions::LEXER_DUMP:\n       parser.debug_dump_lex_output ();\n+      // TODO: rewrite lexer dump or something so that it allows for the crate to already be parsed\n       break;\n     case CompileOptions::PARSER_AST_DUMP:\n       parser.debug_dump_ast_output (parsed_crate);\n       break;\n+    case CompileOptions::TARGET_OPTION_DUMP:\n+      options.target_data.dump_target_options ();\n+      return;\n     default:\n       break;\n     }\n@@ -533,7 +534,7 @@ load_extern_crate (std::string crate_name ATTRIBUTE_UNUSED)\n // TODO: lots of this code is probably actually useful outside of dumping, so\n // maybe split off function\n void\n-Session::debug_dump_load_crates (Parser &parser)\n+Session::debug_dump_load_crates (Parser<Lexer> &parser)\n {\n   // parse crate as AST\n   AST::Crate crate = parser.parse_crate ();\n@@ -582,9 +583,7 @@ contains_name (const std::vector<AST::Attribute> &attrs, std::string name)\n   for (const auto &attr : attrs)\n     {\n       if (attr.get_path () == name)\n-\t{\n-\t  return true;\n-\t}\n+\t    return true;\n     }\n \n   return false;\n@@ -677,7 +676,7 @@ Session::injection (AST::Crate &crate)\n     {\n       // create \"macro use\" attribute for use on extern crate item to enable\n       // loading macros from it\n-      AST::Attribute attr (AST::SimplePath::from_str (\"macro_use\"), NULL);\n+      AST::Attribute attr (AST::SimplePath::from_str (\"macro_use\"), nullptr);\n \n       // create \"extern crate\" item with the name\n       std::unique_ptr<AST::ExternCrate> extern_crate (\n@@ -700,7 +699,7 @@ Session::injection (AST::Crate &crate)\n \t\t\t  AST::SimplePath (std::move (segments)),\n \t\t\t  Location ()));\n   AST::Attribute prelude_attr (AST::SimplePath::from_str (\"prelude_import\"),\n-\t\t\t       NULL);\n+\t\t\t       nullptr);\n   std::unique_ptr<AST::UseDeclaration> use_decl (\n     new AST::UseDeclaration (std::move (use_tree),\n \t\t\t     AST::Visibility::create_error (),\n@@ -750,96 +749,93 @@ Session::resolution (AST::Crate &crate)\n   fprintf (stderr, \"started name resolution\\n\");\n   Analysis::TopLevelScan toplevel (crate);\n   // Name resolution must be in front of type resolution\n-  Analysis::TypeResolution::ResolveNamesAndTypes (crate, toplevel);\n+  Analysis::NameResolution::Resolve (crate, toplevel);\n+  Analysis::TypeResolution::Resolve (crate, toplevel);\n   fprintf (stderr, \"finished name resolution\\n\");\n }\n \n-void\n-TargetOptions::dump_target_options () const\n-{\n-  fprintf (stderr,\n-\t   \"\\033[0;31m--PREPARING TO DUMP ALL TARGET OPTIONS--\\n\\033[0m\");\n-  for (const auto &pairs : features)\n-    {\n-      for (const auto &value : pairs.second)\n-\t{\n-\t  fprintf (stderr, \"%s: \\\"%s\\\"\\n\", pairs.first.c_str (),\n-\t\t   value.c_str ());\n-\t}\n-      if (pairs.second.empty ())\n-\t{\n-\t  fprintf (stderr, \"%s\\n\", pairs.first.c_str ());\n-\t}\n-    }\n-  if (features.empty ())\n-    {\n-      fprintf (stderr, \"No target options available!\\n\");\n-    }\n+void \n+TargetOptions::dump_target_options () const \n+  {\n+    fprintf (stderr, \"\\033[0;31m--PREPARING TO DUMP ALL TARGET OPTIONS--\\n\\033[0m\");\n+    for (const auto& pairs : features) \n+      {\n+        for (const auto& value : pairs.second)\n+            fprintf (stderr, \"%s: \\\"%s\\\"\\n\", pairs.first.c_str (), value.c_str ());\n+        \n+        if (pairs.second.empty ())\n+            fprintf (stderr, \"%s\\n\", pairs.first.c_str ());\n+      }\n+    if (features.empty ())\n+        fprintf (stderr, \"No target options available!\\n\");\n \n-  fprintf (stderr, \"\\033[0;31m--END OF TARGET OPTION DUMP--\\n\\033[0m\");\n-}\n+    fprintf (stderr, \"\\033[0;31m--END OF TARGET OPTION DUMP--\\n\\033[0m\");\n+  }\n \n-void\n-TargetOptions::init_derived_values ()\n-{\n-  // enable derived values based on target families\n-  if (has_key_value_pair (\"target_family\", \"unix\"))\n-    insert_key (\"unix\");\n-  if (has_key_value_pair (\"target_family\", \"windows\"))\n-    insert_key (\"windows\");\n-\n-  // implicitly enable features\n-  if (has_key_value_pair (\"target_feature\", \"aes\"))\n-    enable_implicit_feature_reqs (\"aes\");\n-  if (has_key_value_pair (\"target_feature\", \"avx\"))\n-    enable_implicit_feature_reqs (\"sse4.2\");\n-  if (has_key_value_pair (\"target_feature\", \"avx2\"))\n-    enable_implicit_feature_reqs (\"avx\");\n-  if (has_key_value_pair (\"target_feature\", \"pclmulqdq\"))\n-    enable_implicit_feature_reqs (\"sse2\");\n-  if (has_key_value_pair (\"target_feature\", \"sha\"))\n-    enable_implicit_feature_reqs (\"sse2\");\n-  if (has_key_value_pair (\"target_feature\", \"sse2\"))\n-    enable_implicit_feature_reqs (\"sse\");\n-  if (has_key_value_pair (\"target_feature\", \"sse3\"))\n-    enable_implicit_feature_reqs (\"sse2\");\n-  if (has_key_value_pair (\"target_feature\", \"sse4.1\"))\n-    enable_implicit_feature_reqs (\"sse3\");\n-  if (has_key_value_pair (\"target_feature\", \"sse4.2\"))\n-    enable_implicit_feature_reqs (\"sse4.1\");\n-  if (has_key_value_pair (\"target_feature\", \"ssse3\"))\n-    enable_implicit_feature_reqs (\"sse3\");\n-}\n+void \n+TargetOptions::init_derived_values () \n+  {\n+    // enable derived values based on target families\n+    if (has_key_value_pair (\"target_family\", \"unix\"))\n+        insert_key (\"unix\");\n+    if (has_key_value_pair (\"target_family\", \"windows\"))\n+        insert_key (\"windows\");\n+        \n+    // implicitly enable features - this should not be required in general\n+    if (has_key_value_pair (\"target_feature\", \"aes\")) \n+        enable_implicit_feature_reqs (\"aes\");\n+    if (has_key_value_pair (\"target_feature\", \"avx\"))\n+        enable_implicit_feature_reqs (\"sse4.2\");\n+    if (has_key_value_pair (\"target_feature\", \"avx2\"))\n+        enable_implicit_feature_reqs (\"avx\");\n+    if (has_key_value_pair (\"target_feature\", \"pclmulqdq\"))\n+        enable_implicit_feature_reqs (\"sse2\");\n+    if (has_key_value_pair (\"target_feature\", \"sha\"))\n+        enable_implicit_feature_reqs (\"sse2\");\n+    if (has_key_value_pair (\"target_feature\", \"sse2\"))\n+        enable_implicit_feature_reqs (\"sse\");\n+    if (has_key_value_pair (\"target_feature\", \"sse3\"))\n+        enable_implicit_feature_reqs (\"sse2\");\n+    if (has_key_value_pair (\"target_feature\", \"sse4.1\"))\n+        enable_implicit_feature_reqs (\"sse3\");\n+    if (has_key_value_pair (\"target_feature\", \"sse4.2\"))\n+        enable_implicit_feature_reqs (\"sse4.1\");\n+    if (has_key_value_pair (\"target_feature\", \"ssse3\"))\n+        enable_implicit_feature_reqs (\"sse3\");\n+  }\n \n-void\n-TargetOptions::enable_implicit_feature_reqs (std::string feature)\n-{\n-  if (feature == \"aes\")\n-    enable_implicit_feature_reqs (\"sse2\");\n-  else if (feature == \"avx\")\n-    enable_implicit_feature_reqs (\"sse4.2\");\n-  else if (feature == \"avx2\")\n-    enable_implicit_feature_reqs (\"avx\");\n-  else if (feature == \"fma\")\n-    enable_implicit_feature_reqs (\"avx\");\n-  else if (feature == \"pclmulqdq\")\n-    enable_implicit_feature_reqs (\"sse2\");\n-  else if (feature == \"sha\")\n-    enable_implicit_feature_reqs (\"sse2\");\n-  else if (feature == \"sse2\")\n-    enable_implicit_feature_reqs (\"sse\");\n-  else if (feature == \"sse3\")\n-    enable_implicit_feature_reqs (\"sse2\");\n-  else if (feature == \"sse4.1\")\n-    enable_implicit_feature_reqs (\"sse3\");\n-  else if (feature == \"sse4.2\")\n-    enable_implicit_feature_reqs (\"sse4.1\");\n-  else if (feature == \"ssse3\")\n-    enable_implicit_feature_reqs (\"sse3\");\n-\n-  if (!has_key_value_pair (\"target_feature\", feature))\n-    insert_key_value_pair (\"target_feature\", feature);\n-}\n+void \n+TargetOptions::enable_implicit_feature_reqs (std::string feature) \n+  {\n+    if (feature == \"aes\") \n+        enable_implicit_feature_reqs (\"sse2\");\n+    else if (feature == \"avx\")\n+        enable_implicit_feature_reqs (\"sse4.2\");\n+    else if (feature == \"avx2\")\n+        enable_implicit_feature_reqs (\"avx\");\n+    else if (feature == \"fma\")\n+        enable_implicit_feature_reqs (\"avx\");\n+    else if (feature == \"pclmulqdq\") \n+        enable_implicit_feature_reqs (\"sse2\");\n+    else if (feature == \"sha\")\n+        enable_implicit_feature_reqs (\"sse2\");\n+    else if (feature == \"sse2\")\n+        enable_implicit_feature_reqs (\"sse\");\n+    else if (feature == \"sse3\")\n+        enable_implicit_feature_reqs (\"sse2\");\n+    else if (feature == \"sse4.1\")\n+        enable_implicit_feature_reqs (\"sse3\");\n+    else if (feature == \"sse4.2\")\n+        enable_implicit_feature_reqs (\"sse4.1\");\n+    else if (feature == \"ssse3\")\n+        enable_implicit_feature_reqs (\"sse3\");\n+\n+    if (!has_key_value_pair (\"target_feature\", feature)) {\n+        insert_key_value_pair (\"target_feature\", feature);\n+\n+        fprintf (stderr, \"had to implicitly enable feature '%s'!\", feature.c_str ());\n+    }\n+  }\n \n // NOTEs:\n /* mrustc compile pipeline:"}, {"sha": "bdeeeec11a3d9af41e37809f372435f0eeae3969", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 48, "deletions": 53, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0db6e13f05fb197621eca65d275094f2502473f/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=e0db6e13f05fb197621eca65d275094f2502473f", "patch": "@@ -19,19 +19,20 @@\n \n namespace Rust {\n // parser forward decl\n-class Parser;\n+template <typename ManagedTokenSource> class Parser;\n+class Lexer;\n // crate forward decl\n namespace AST {\n struct Crate;\n }\n \n-// Data related to target, most useful for conditional compilation and\n-// whatever.\n+/* Data related to target, most useful for conditional compilation and\n+ * whatever. */\n struct TargetOptions\n {\n-  // TODO: maybe make private and access through helpers to allow changes to\n-  // impl\n-  std::unordered_map<std::string, std::unordered_set<std::string> > features;\n+  /* TODO: maybe make private and access through helpers to allow changes to\n+   * impl */\n+  std::unordered_map<std::string, std::unordered_set<std::string>> features;\n \n public:\n   // Returns whether a key is defined in the feature set.\n@@ -54,8 +55,8 @@ struct TargetOptions\n     return false;\n   }\n \n-  // Returns the singular value from the key, or if the key has multiple, an\n-  // empty string.\n+  /* Returns the singular value from the key, or if the key has multiple, an\n+   * empty string. */\n   std::string get_singular_value (std::string key) const\n   {\n     auto it = features.find (key);\n@@ -68,22 +69,19 @@ struct TargetOptions\n     return \"\";\n   }\n \n-  // Returns all values associated with a key (including none), or an empty set\n-  // if no key is found.\n-  std::unordered_set< ::std::string> get_values_for_key (std::string key) const\n+  /* Returns all values associated with a key (including none), or an empty\n+   * set if no key is found. */\n+  std::unordered_set<std::string> get_values_for_key (std::string key) const\n   {\n     auto it = features.find (key);\n     if (it != features.end ())\n-      {\n-\treturn it->second;\n-      }\n+      return it->second;\n     return {};\n   }\n \n-  /* Inserts a key (no value) into the feature set. This will do nothing if the\n-   * key already exists.\n-   * This returns whether the insertion was successful (i.e. whether key already\n-   * existed). */\n+  /* Inserts a key (no value) into the feature set. This will do nothing if\n+   * the key already exists. This returns whether the insertion was successful\n+   * (i.e. whether key already existed). */\n   bool insert_key (std::string key)\n   {\n     return features\n@@ -102,37 +100,36 @@ struct TargetOptions\n   // Dump all target options to stderr.\n   void dump_target_options () const;\n \n-  // Creates derived values and implicit enables after all target info is added\n-  // (e.g. \"unix\").\n+  /* Creates derived values and implicit enables after all target info is added\n+   * (e.g. \"unix\"). */\n   void init_derived_values ();\n \n-  // Enables all requirements for the feature given, and will enable feature\n-  // itself if not enabled.\n+  /* Enables all requirements for the feature given, and will enable feature\n+   * itself if not enabled. */\n   void enable_implicit_feature_reqs (std::string feature);\n \n   /* According to reference, Rust uses either multi-map key-values or just\n    * values (although values may be aliases for a key-value value). This seems\n    * like overkill. Thus, depending on whether the attributes used in cfg are\n    * fixed or not, I think I'll either put each non-multimap \"key-value\" as a\n-   * separate field and have the multimap \"key-values\" in a regular map for that\n-   * one key, or actually use a multimap.\n+   * separate field and have the multimap \"key-values\" in a regular map for\n+   * that one key, or actually use a multimap.\n    *\n-   * rustc itself uses a set of key-value tuples where the second tuple element\n-   * is optional. This gets rid of the requirement to make a multi-map, I guess,\n-   * but seems like it might make\n-   * search slow (unless all \"is defined\"-only ones have empty string as second\n-   * element). */\n+   * rustc itself uses a set of key-value tuples where the second tuple\n+   * element is optional. This gets rid of the requirement to make a\n+   * multi-map, I guess, but seems like it might make search slow (unless all\n+   * \"is defined\"-only ones have empty string as second element). */\n   /* cfg attributes:\n    * - target_arch: single value\n    * - target_feature: multiple values possible\n    * - target_os: single value\n    * - target_family: single value (or no value?)\n    * - unix: set when target_family = \"unix\"\n    * - windows: set when target_family = \"windows\"\n-   *  - if these are just syntactic sugar, then maybe have a separate set or map\n-   * for this kind of stuff\n-   * - target_env: set when needed for disambiguation about ABI - usually empty\n-   * string for GNU, complicated\n+   *  - if these are just syntactic sugar, then maybe have a separate set or\n+   * map for this kind of stuff\n+   * - target_env: set when needed for disambiguation about ABI - usually\n+   * empty string for GNU, complicated\n    *  - seems to be a single value (if any)\n    * - target_endian: single value; \"little\" or \"big\"\n    * - target_pointer_width: single value, \"32\" for 32-bit pointers, etc.\n@@ -141,7 +138,8 @@ struct TargetOptions\n    *  - again, seems similar to a \"is defined\" rather than \"is equal to\" like\n    * unix\n    * - debug_assertions: seems to \"is defined\"\n-   * - proc_macro: no idea, bad docs. seems to be boolean, so maybe \"is defined\"\n+   * - proc_macro: no idea, bad docs. seems to be boolean, so maybe \"is\n+   * defined\"\n    */\n };\n \n@@ -150,8 +148,8 @@ struct CompileOptions\n {\n   // TODO: use bitfield for smaller memory requirements?\n \n-  // FIXME: this is set up for \"instead of\" dumping - in future, dumps should\n-  // not inhibit compilation\n+  /* FIXME: this is set up for \"instead of\" dumping - in future, dumps should\n+   * not inhibit compilation */\n   enum DumpOptions\n   {\n     NO_DUMP,\n@@ -160,15 +158,14 @@ struct CompileOptions\n     REGISTER_PLUGINS_DUMP,\n     INJECTION_DUMP,\n     EXPANSION_DUMP,\n-    NAME_RESOLUTION_DUMP,\n-    TARGET_OPTION_DUMP,\n     RESOLUTION_DUMP,\n+    TARGET_OPTION_DUMP,\n     // TODO: add more?\n   } dump_option;\n \n-  // configuration options - actually useful for conditional compilation and\n-  // whatever data related to target arch, features, os, family, env, endian,\n-  // pointer width, vendor\n+  /* configuration options - actually useful for conditional compilation and\n+   * whatever data related to target arch, features, os, family, env, endian,\n+   * pointer width, vendor */\n   TargetOptions target_data;\n   bool enable_test = false;\n   bool debug_assertions = false;\n@@ -180,9 +177,9 @@ struct CompileOptions\n struct Session\n {\n   CompileOptions options;\n-  // This should really be in a per-crate storage area but it is wiped with\n-  // every file so eh.\n-  ::std::string injected_crate_name;\n+  /* This should really be in a per-crate storage area but it is wiped with\n+   * every file so eh. */\n+  std::string injected_crate_name;\n \n   // backend wrapper to GCC GENERIC\n   Backend *backend;\n@@ -205,18 +202,18 @@ struct Session\n private:\n   // TODO: should this be private or public?\n   void parse_file (const char *filename);\n-  bool enable_dump (::std::string arg);\n+  bool enable_dump (std::string arg);\n \n-  void debug_dump_load_crates (Parser &parser);\n+  void debug_dump_load_crates (Parser<Lexer> &parser);\n \n-  void implicitly_enable_feature (::std::string feature_name);\n+  void implicitly_enable_feature (std::string feature_name);\n   void enable_features ();\n \n   // pipeline stages - TODO maybe move?\n   /* Register plugins pipeline stage. TODO maybe move to another object?\n-   * Currently dummy stage. In future will handle attribute injection (top-level\n-   * inner attribute creation from command line arguments), setting options\n-   * maybe, registering lints maybe, loading plugins maybe. */\n+   * Currently dummy stage. In future will handle attribute injection\n+   * (top-level inner attribute creation from command line arguments), setting\n+   * options maybe, registering lints maybe, loading plugins maybe. */\n   void register_plugins (AST::Crate &crate);\n   /* Injection pipeline stage. TODO maybe move to another object? Maybe have\n    * some lint checks (in future, obviously), register builtin macros, crate\n@@ -226,11 +223,9 @@ struct Session\n    * macros, maybe build test harness in future, AST validation, maybe create\n    * macro crate (if not rustdoc).*/\n   void expansion (AST::Crate &crate);\n-\n   /* Resolution pipeline stage. TODO maybe move to another object.\n    * Performs name resolution and type resolution, maybe complete gated\n-   * feature checking, maybe create buffered lints in future.\n-   */\n+   * feature checking, maybe create buffered lints in future. */\n   void resolution (AST::Crate &crate);\n };\n } // namespace Rust"}]}