{"sha": "de4af523c5a6790873770f4d1248bedc4dd6e56a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU0YWY1MjNjNWE2NzkwODczNzcwZjRkMTI0OGJlZGM0ZGQ2ZTU2YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-01-16T13:41:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-01-16T13:41:13Z"}, "message": "re PR middle-end/34668 (ICE in find_compatible_field with -combine)\n\n2008-01-16  Jakub Jelinek  <jakub@redhat.com>\n\tRichard Guenther  <rguenther@suse.de>\n\n\tPR c/34668\n\t* gimplify.c (fold_indirect_ref_rhs): Rename to ...\n\t(gimple_fold_indirect_ref_rhs): ... this.\n\t(gimple_fold_indirect_ref): New function with foldings\n\tthat preserve lvalueness.\n\t(gimplify_modify_expr_rhs): Call gimple_fold_indirect_ref_rhs.\n\t* tree-flow.h (gimple_fold_indirect_ref): Declare.\n\t* tree-inline.c (copy_body_r): Use gimple_fold_indirect_ref\n\tto fold an INDIRECT_REF, fall back to the old use of\n\tfold_indirect_ref_1.\n\n\t* gcc.dg/pr34668-1.c: New test.\n\t* gcc.dg/pr34668-2.c: Likewise.\n\nCo-Authored-By: Richard Guenther <rguenther@suse.de>\n\nFrom-SVN: r131572", "tree": {"sha": "85a0b59e6028d56e1f2946e68d742d5259cd6aff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85a0b59e6028d56e1f2946e68d742d5259cd6aff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de4af523c5a6790873770f4d1248bedc4dd6e56a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de4af523c5a6790873770f4d1248bedc4dd6e56a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de4af523c5a6790873770f4d1248bedc4dd6e56a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de4af523c5a6790873770f4d1248bedc4dd6e56a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6935bae779717b8563011478a79ea5832c6fd135", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6935bae779717b8563011478a79ea5832c6fd135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6935bae779717b8563011478a79ea5832c6fd135"}], "stats": {"total": 92, "additions": 79, "deletions": 13}, "files": [{"sha": "909008b3fa950d67770a831aac28fd50e1744f7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de4af523c5a6790873770f4d1248bedc4dd6e56a", "patch": "@@ -1,3 +1,17 @@\n+2008-01-16  Jakub Jelinek  <jakub@redhat.com>\n+\tRichard Guenther  <rguenther@suse.de>\n+\n+\tPR c/34668\n+\t* gimplify.c (fold_indirect_ref_rhs): Rename to ...\n+\t(gimple_fold_indirect_ref_rhs): ... this.\n+\t(gimple_fold_indirect_ref): New function with foldings\n+\tthat preserve lvalueness.\n+\t(gimplify_modify_expr_rhs): Call gimple_fold_indirect_ref_rhs.\n+\t* tree-flow.h (gimple_fold_indirect_ref): Declare.\n+\t* tree-inline.c (copy_body_r): Use gimple_fold_indirect_ref\n+\tto fold an INDIRECT_REF, fall back to the old use of\n+\tfold_indirect_ref_1.\n+\n 2008-01-16  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* tree-data-ref.c (subscript_dependence_tester_1): Call "}, {"sha": "1075d6544275c2d76f16b45d44f85a2ba52f5608", "filename": "gcc/gimplify.c", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=de4af523c5a6790873770f4d1248bedc4dd6e56a", "patch": "@@ -1,6 +1,6 @@\n /* Tree lowering pass.  This pass converts the GENERIC functions-as-trees\n    tree representation into the GIMPLE form.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Major work done by Sebastian Pop <s.pop@laposte.net>,\n    Diego Novillo <dnovillo@redhat.com> and Jason Merrill <jason@redhat.com>.\n@@ -3449,13 +3449,12 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \n /* Given a pointer value OP0, return a simplified version of an\n    indirection through OP0, or NULL_TREE if no simplification is\n-   possible.  This may only be applied to a rhs of an expression.\n-   Note that the resulting type may be different from the type pointed\n-   to in the sense that it is still compatible from the langhooks\n-   point of view. */\n+   possible.  Note that the resulting type may be different from\n+   the type pointed to in the sense that it is still compatible\n+   from the langhooks point of view. */\n \n-static tree\n-fold_indirect_ref_rhs (tree t)\n+tree\n+gimple_fold_indirect_ref (tree t)\n {\n   tree type = TREE_TYPE (TREE_TYPE (t));\n   tree sub = t;\n@@ -3473,9 +3472,10 @@ fold_indirect_ref_rhs (tree t)\n       /* *&p => p */\n       if (useless_type_conversion_p (type, optype))\n         return op;\n+\n       /* *(foo *)&fooarray => fooarray[0] */\n-      else if (TREE_CODE (optype) == ARRAY_TYPE\n-\t       && useless_type_conversion_p (type, TREE_TYPE (optype)))\n+      if (TREE_CODE (optype) == ARRAY_TYPE\n+\t  && useless_type_conversion_p (type, TREE_TYPE (optype)))\n        {\n          tree type_domain = TYPE_DOMAIN (optype);\n          tree min_val = size_zero_node;\n@@ -3492,7 +3492,7 @@ fold_indirect_ref_rhs (tree t)\n       tree type_domain;\n       tree min_val = size_zero_node;\n       tree osub = sub;\n-      sub = fold_indirect_ref_rhs (sub);\n+      sub = gimple_fold_indirect_ref (sub);\n       if (! sub)\n \tsub = build1 (INDIRECT_REF, TREE_TYPE (subtype), osub);\n       type_domain = TYPE_DOMAIN (TREE_TYPE (sub));\n@@ -3504,6 +3504,19 @@ fold_indirect_ref_rhs (tree t)\n   return NULL_TREE;\n }\n \n+/* Given a pointer value OP0, return a simplified version of an\n+   indirection through OP0, or NULL_TREE if no simplification is\n+   possible.  This may only be applied to a rhs of an expression.\n+   Note that the resulting type may be different from the type pointed\n+   to in the sense that it is still compatible from the langhooks\n+   point of view. */\n+\n+static tree\n+gimple_fold_indirect_ref_rhs (tree t)\n+{\n+  return gimple_fold_indirect_ref (t);\n+}\n+\n /* Subroutine of gimplify_modify_expr to do simplifications of\n    MODIFY_EXPRs based on the code of the RHS.  We loop for as long as\n    something changes.  */\n@@ -3557,7 +3570,7 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \t     This kind of code arises in C++ when an object is bound\n \t     to a const reference, and if \"x\" is a TARGET_EXPR we want\n \t     to take advantage of the optimization below.  */\n-\t  tree t = fold_indirect_ref_rhs (TREE_OPERAND (*from_p, 0));\n+\t  tree t = gimple_fold_indirect_ref_rhs (TREE_OPERAND (*from_p, 0));\n \t  if (t)\n \t    {\n \t      *from_p = t;"}, {"sha": "c0e2196f027f240d4984ffa4ff02d8a45fd19212", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=de4af523c5a6790873770f4d1248bedc4dd6e56a", "patch": "@@ -1,3 +1,10 @@\n+2008-01-16  Jakub Jelinek  <jakub@redhat.com>\n+\tRichard Guenther  <rguenther@suse.de>\n+\n+\tPR c/34668\n+\t* gcc.dg/pr34668-1.c: New test.\n+\t* gcc.dg/pr34668-2.c: Likewise.\n+\n 2008-01-16  Richard Guenther  <rguenther@suse.de>\n \n \tPR c++/33819"}, {"sha": "5763bb61027ede02b9d3c825fb3b13577df7afc8", "filename": "gcc/testsuite/gcc.dg/pr34668-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34668-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34668-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34668-1.c?ref=de4af523c5a6790873770f4d1248bedc4dd6e56a", "patch": "@@ -0,0 +1,19 @@\n+/* PR c/34668 */\n+/* { dg-do compile } */\n+/* { dg-options \"--combine -O2\" } */\n+/* { dg-additional-sources \"pr34668-2.c\" } */\n+\n+struct optab { unsigned code; };\n+extern struct optab optab_table[1];\n+\n+void\n+init_optab (struct optab *op)\n+{\n+  op->code = 0xdead;\n+}\n+\n+void\n+set_conv_libfunc (void)\n+{\n+  init_optab (&optab_table[0]);\n+}"}, {"sha": "fab8f173fd3aff01e5660338f0992fb0efbe6ef1", "filename": "gcc/testsuite/gcc.dg/pr34668-2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34668-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34668-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34668-2.c?ref=de4af523c5a6790873770f4d1248bedc4dd6e56a", "patch": "@@ -0,0 +1,5 @@\n+/* PR c/34668 */\n+/* { dg-do compile } */\n+\n+struct optab { unsigned code; };\n+extern struct optab optab_table[1];"}, {"sha": "a96f8b2e0837d7448dd302a659f6c4be8d108ee8", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=de4af523c5a6790873770f4d1248bedc4dd6e56a", "patch": "@@ -1125,6 +1125,7 @@ extern void register_jump_thread (edge, edge);\n tree force_gimple_operand (tree, tree *, bool, tree);\n tree force_gimple_operand_bsi (block_stmt_iterator *, tree, bool, tree,\n \t\t\t       bool, enum bsi_iterator_update);\n+tree gimple_fold_indirect_ref (tree);\n \n /* In tree-ssa-structalias.c */\n bool find_what_p_points_to (tree);"}, {"sha": "6ac367ef0cee5da6e5a4139c4da73a1a1dd6c208", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4af523c5a6790873770f4d1248bedc4dd6e56a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=de4af523c5a6790873770f4d1248bedc4dd6e56a", "patch": "@@ -696,11 +696,18 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t      tree type = TREE_TYPE (TREE_TYPE (*n));\n \t      new = unshare_expr (*n);\n \t      old = *tp;\n-\t      *tp = fold_indirect_ref_1 (type, new);\n+\t      *tp = gimple_fold_indirect_ref (new);\n \t      if (! *tp)\n \t        {\n \t\t  if (TREE_CODE (new) == ADDR_EXPR)\n-\t\t    *tp = TREE_OPERAND (new, 0);\n+\t\t    {\n+\t\t      *tp = fold_indirect_ref_1 (type, new);\n+\t\t      /* ???  We should either assert here or build\n+\t\t\t a VIEW_CONVERT_EXPR instead of blindly leaking\n+\t\t\t incompatible types to our IL.  */\n+\t\t      if (! *tp)\n+\t\t\t*tp = TREE_OPERAND (new, 0);\n+\t\t    }\n \t          else\n \t\t    {\n \t              *tp = build1 (INDIRECT_REF, type, new);"}]}