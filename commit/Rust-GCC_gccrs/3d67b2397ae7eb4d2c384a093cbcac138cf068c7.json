{"sha": "3d67b2397ae7eb4d2c384a093cbcac138cf068c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q2N2IyMzk3YWU3ZWI0ZDJjMzg0YTA5M2NiY2FjMTM4Y2YwNjhjNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-24T14:44:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-24T14:44:32Z"}, "message": "[multiple changes]\n\n2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_attr.adb (Expand_Loop_Entry_Attribute): Clarify the\n\textraction of the declarative part of the conditional block. Move\n\tthe processing of simple infinite loops to the start of the\n\texpansion logic. Correct the check which determines whether the\n\tproper scope is installed in visibility.\n\t* sem_attr.adb (Analyze_Attribute): Add local variable Attr\n\tto keep track of the attribute in case the enclosing indexed\n\tcomponent has to be rewritten. When searching for the enclosing\n\tloop, start from the proper attribute reference in case of a\n\trewriting. Do not allow for 'Loop_Entry to appear in pragma\n\tAssert. Replace loop variable J with Index. Set the type of the\n\tproper attribute.\n\t* sem_ch5.adb (Check_Unreachable_Code): Detect a specialized\n\tblock that services a loop statement subject to at least one\n\t'Loop_Entry attribute.\n\n2013-04-24  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_type.adb (Disambiguate): In Ada 2012 mode, when trying to\n\tresolve a fixed point operation, use first subtype to determine\n\twhether type and operator are declared in the same list of\n\tdeclarations.\n\n2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* par-ch6.adb (P_Subprogram): Detect an illegal\n\tplacement of the aspect specification list in the context of\n\texpression functions.\n\n2013-04-24  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Allocator):  If the designated object\n\thas tasks, and the pointer type is an itype that has no master\n\tid, create a master renaming in the current context, which can\n\tonly be an init_proc.\n\nFrom-SVN: r198242", "tree": {"sha": "3b202f46bafef86ce2f45e4a6dc26e99e5d90341", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b202f46bafef86ce2f45e4a6dc26e99e5d90341"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d67b2397ae7eb4d2c384a093cbcac138cf068c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d67b2397ae7eb4d2c384a093cbcac138cf068c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d67b2397ae7eb4d2c384a093cbcac138cf068c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/comments", "author": null, "committer": null, "parents": [{"sha": "7086115738d507d23077076d076499c02791c703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7086115738d507d23077076d076499c02791c703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7086115738d507d23077076d076499c02791c703"}], "stats": {"total": 173, "additions": 132, "deletions": 41}, "files": [{"sha": "3a1a5f64314f4584b468eb3e32b7113a492bf2f6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3d67b2397ae7eb4d2c384a093cbcac138cf068c7", "patch": "@@ -1,3 +1,41 @@\n+2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_attr.adb (Expand_Loop_Entry_Attribute): Clarify the\n+\textraction of the declarative part of the conditional block. Move\n+\tthe processing of simple infinite loops to the start of the\n+\texpansion logic. Correct the check which determines whether the\n+\tproper scope is installed in visibility.\n+\t* sem_attr.adb (Analyze_Attribute): Add local variable Attr\n+\tto keep track of the attribute in case the enclosing indexed\n+\tcomponent has to be rewritten. When searching for the enclosing\n+\tloop, start from the proper attribute reference in case of a\n+\trewriting. Do not allow for 'Loop_Entry to appear in pragma\n+\tAssert. Replace loop variable J with Index. Set the type of the\n+\tproper attribute.\n+\t* sem_ch5.adb (Check_Unreachable_Code): Detect a specialized\n+\tblock that services a loop statement subject to at least one\n+\t'Loop_Entry attribute.\n+\n+2013-04-24  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_type.adb (Disambiguate): In Ada 2012 mode, when trying to\n+\tresolve a fixed point operation, use first subtype to determine\n+\twhether type and operator are declared in the same list of\n+\tdeclarations.\n+\n+2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* par-ch6.adb (P_Subprogram): Detect an illegal\n+\tplacement of the aspect specification list in the context of\n+\texpression functions.\n+\n+2013-04-24  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Allocator):  If the designated object\n+\thas tasks, and the pointer type is an itype that has no master\n+\tid, create a master renaming in the current context, which can\n+\tonly be an init_proc.\n+\n 2013-04-24  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb, sem_ch7.adb: Minor reformatting."}, {"sha": "c009222221670fefe123707829d3a5471074b756", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=3d67b2397ae7eb4d2c384a093cbcac138cf068c7", "patch": "@@ -782,11 +782,23 @@ package body Exp_Attr is\n       --  'Loop_Entry attribute. Retrieve the declarative list of the block.\n \n       if Has_Loop_Entry_Attributes (Loop_Id) then\n+\n+         --  When the related loop name appears as the argument of attribute\n+         --  Loop_Entry, the corresponding label construct is the generated\n+         --  block statement. This happens because the expander reuses the\n+         --  label.\n+\n          if Nkind (Loop_Stmt) = N_Block_Statement then\n             Decls := Declarations (Loop_Stmt);\n+\n+         --  In all other cases, the loop must appear in the handled sequence\n+         --  of statements of the generated block.\n+\n          else\n-            --  What is going on here??? comments/assertions needed to explain\n-            --  the assumption being made about the tree???\n+            pragma Assert\n+              (Nkind (Parent (Loop_Stmt)) = N_Handled_Sequence_Of_Statements\n+                 and then Nkind (Parent (Parent (Loop_Stmt))) =\n+                            N_Block_Statement);\n \n             Decls := Declarations (Parent (Parent (Loop_Stmt)));\n          end if;\n@@ -799,6 +811,27 @@ package body Exp_Attr is\n          Set_Has_Loop_Entry_Attributes (Loop_Id);\n          Scheme := Iteration_Scheme (Loop_Stmt);\n \n+         --  Infinite loops are transformed into:\n+\n+         --    declare\n+         --       Temp1 : constant <type of Pref1> := <Pref1>;\n+         --       . . .\n+         --       TempN : constant <type of PrefN> := <PrefN>;\n+         --    begin\n+         --       loop\n+         --          <original source statements with attribute rewrites>\n+         --       end loop;\n+         --    end;\n+\n+         if No (Scheme) then\n+            Build_Conditional_Block (Loc,\n+              Cond      => Empty,\n+              Loop_Stmt => Relocate_Node (Loop_Stmt),\n+              If_Stmt   => Result,\n+              Blk_Stmt  => Blk);\n+\n+            Result := Blk;\n+\n          --  While loops are transformed into:\n \n          --    if <Condition> then\n@@ -817,7 +850,7 @@ package body Exp_Attr is\n          --  Note that loops over iterators and containers are already\n          --  converted into while loops.\n \n-         if Present (Condition (Scheme)) then\n+         elsif Present (Condition (Scheme)) then\n             declare\n                Cond : constant Node_Id := Condition (Scheme);\n \n@@ -947,27 +980,6 @@ package body Exp_Attr is\n                  If_Stmt   => Result,\n                  Blk_Stmt  => Blk);\n             end;\n-\n-         --  Infinite loops are transformed into:\n-\n-         --    declare\n-         --       Temp1 : constant <type of Pref1> := <Pref1>;\n-         --       . . .\n-         --       TempN : constant <type of PrefN> := <PrefN>;\n-         --    begin\n-         --       loop\n-         --          <original source statements with attribute rewrites>\n-         --       end loop;\n-         --    end;\n-\n-         else\n-            Build_Conditional_Block (Loc,\n-              Cond      => Empty,\n-              Loop_Stmt => Relocate_Node (Loop_Stmt),\n-              If_Stmt   => Result,\n-              Blk_Stmt  => Blk);\n-\n-            Result := Blk;\n          end if;\n \n          Decls := Declarations (Blk);\n@@ -993,7 +1005,7 @@ package body Exp_Attr is\n \n       Rewrite (Attr, New_Reference_To (Temp_Id, Loc));\n \n-      Installed := Current_Scope = Loop_Id;\n+      Installed := Current_Scope = Scope (Loop_Id);\n \n       --  Depending on the pracement of attribute 'Loop_Entry relative to the\n       --  associated loop, ensure the proper visibility for analysis."}, {"sha": "85a6496ca6766411ee1cf1ac7ce96186b7a96d96", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=3d67b2397ae7eb4d2c384a093cbcac138cf068c7", "patch": "@@ -4577,9 +4577,19 @@ package body Exp_Ch4 is\n                      --  access type did not get expanded. Salvage it now.\n \n                      if not Restriction_Active (No_Task_Hierarchy) then\n-                        pragma Assert (Present (Parent (Base_Type (PtrT))));\n-                        Expand_N_Full_Type_Declaration\n-                          (Parent (Base_Type (PtrT)));\n+                        if Present (Parent (Base_Type (PtrT))) then\n+                           Expand_N_Full_Type_Declaration\n+                             (Parent (Base_Type (PtrT)));\n+\n+                        else\n+                           --  If the type of the allocator is an itype,\n+                           --  the master must exist in the context. This\n+                           --  is the case when the allocator initializes\n+                           --  an access component in an init-proc.\n+\n+                           pragma Assert (Is_Itype (PtrT));\n+                           Build_Master_Renaming (PtrT, N);\n+                        end if;\n                      end if;\n                   end if;\n "}, {"sha": "7531f405fe108da51cef99b036024ee974712d10", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=3d67b2397ae7eb4d2c384a093cbcac138cf068c7", "patch": "@@ -838,6 +838,22 @@ package body Ch6 is\n                        (\"\\unit must be compiled with -gnat2012 switch!\");\n                   end if;\n \n+                  --  Catch an illegal placement of the aspect specification\n+                  --  list:\n+\n+                  --    function_specification\n+                  --      [aspect_specification] is (expression);\n+\n+                  --  This case is correctly processed by the parser because\n+                  --  the expression function first appears as a subprogram\n+                  --  declaration to the parser.\n+\n+                  if Is_Non_Empty_List (Aspects) then\n+                     Error_Msg\n+                       (\"aspect specifications must come after parenthesized \"\n+                        & \"expression\", Sloc (First (Aspects)));\n+                  end if;\n+\n                   --  Parse out expression and build expression function\n \n                   Body_Node :="}, {"sha": "762015f692cbdfdac9405f49d968531438b942a6", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=3d67b2397ae7eb4d2c384a093cbcac138cf068c7", "patch": "@@ -3698,6 +3698,7 @@ package body Sem_Attr is\n          --  Local variables\n \n          Context           : constant Node_Id := Parent (N);\n+         Attr              : Node_Id;\n          Enclosing_Loop    : Node_Id;\n          In_Loop_Assertion : Boolean   := False;\n          Loop_Id           : Entity_Id := Empty;\n@@ -3707,6 +3708,13 @@ package body Sem_Attr is\n       --  Start of processing for Loop_Entry\n \n       begin\n+         Attr := N;\n+\n+         --  Set the type of the attribute now to ensure the successfull\n+         --  continuation of analysis even if the attribute is misplaced.\n+\n+         Set_Etype (Attr, P_Type);\n+\n          --  Attribute 'Loop_Entry may appear in several flavors:\n \n          --    * Prefix'Loop_Entry - in this form, the attribute applies to the\n@@ -3775,6 +3783,8 @@ package body Sem_Attr is\n                   Set_Expressions (N, Expressions (Context));\n                   Rewrite   (Context, N);\n                   Set_Etype (Context, P_Type);\n+\n+                  Attr := Context;\n                end if;\n             end if;\n          end if;\n@@ -3796,17 +3806,14 @@ package body Sem_Attr is\n          --  Climb the parent chain to verify the location of the attribute and\n          --  find the enclosing loop.\n \n-         Stmt := N;\n+         Stmt := Attr;\n          while Present (Stmt) loop\n \n-            --  Locate the enclosing Loop_Invariant / Loop_Variant pragma (if\n-            --  any). Note that when these two are expanded, we must look for\n-            --  an Assertion pragma.\n+            --  Locate the enclosing Loop_Invariant / Loop_Variant pragma\n \n             if Nkind (Original_Node (Stmt)) = N_Pragma\n               and then\n                 Nam_In (Pragma_Name (Original_Node (Stmt)),\n-                        Name_Assert,\n                         Name_Loop_Invariant,\n                         Name_Loop_Variant)\n             then\n@@ -3852,8 +3859,8 @@ package body Sem_Attr is\n          --  appear within a body of accept statement, if this construct is\n          --  itself enclosed by the given loop statement.\n \n-         for J in reverse 0 .. Scope_Stack.Last loop\n-            Scop := Scope_Stack.Table (J).Entity;\n+         for Index in reverse 0 .. Scope_Stack.Last loop\n+            Scop := Scope_Stack.Table (Index).Entity;\n \n             if Ekind (Scop) = E_Loop and then Scop = Loop_Id then\n                exit;\n@@ -3883,8 +3890,6 @@ package body Sem_Attr is\n          then\n             Error_Attr_P (\"prefix of attribute % must denote an entity\");\n          end if;\n-\n-         Set_Etype (N, P_Type);\n       end Loop_Entry;\n \n       -------------"}, {"sha": "2e48721383de5f80c6e034904913bb5d18af16fa", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=3d67b2397ae7eb4d2c384a093cbcac138cf068c7", "patch": "@@ -2958,7 +2958,16 @@ package body Sem_Ch5 is\n                elsif Nkind (P) = N_Handled_Sequence_Of_Statements\n                  and then Nkind (Parent (P)) = N_Block_Statement\n                then\n-                  null;\n+                  --  The original loop is now placed inside a block statement\n+                  --  due to the expansion of attribute 'Loop_Entry. Return as\n+                  --  this is not a \"real\" block for the purposes of exit\n+                  --  counting.\n+\n+                  if Nkind (N) = N_Loop_Statement\n+                    and then Subject_To_Loop_Entry_Attributes (N)\n+                  then\n+                     return;\n+                  end if;\n \n                --  Statements in exception handler in a block\n "}, {"sha": "c6ad39170d912c1ebbca16294ecc7bae41837108", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d67b2397ae7eb4d2c384a093cbcac138cf068c7/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=3d67b2397ae7eb4d2c384a093cbcac138cf068c7", "patch": "@@ -2048,8 +2048,8 @@ package body Sem_Type is\n       --  Ditto in Ada 2012, where an ambiguity may arise for an operation\n       --  on a partial view that is completed with a fixed point type. See\n       --  AI05-0020 and AI05-0209. The ambiguity is resolved in favor of the\n-      --  user-defined subprogram so that a client of the package has the\n-      --  same resulution as the body of the package.\n+      --  user-defined type and subprogram, so that a client of the package\n+      --  has the same resolution as the body of the package.\n \n       else\n          if (In_Open_Scopes (Scope (User_Subp))\n@@ -2064,7 +2064,8 @@ package body Sem_Type is\n                    (Ada_Version >= Ada_2012\n                      and then\n                        In_Same_Declaration_List\n-                         (Typ, Unit_Declaration_Node (User_Subp))))\n+                         (First_Subtype (Typ),\n+                            Unit_Declaration_Node (User_Subp))))\n             then\n                if It2.Nam = Predef_Subp then\n                   return It1;"}]}