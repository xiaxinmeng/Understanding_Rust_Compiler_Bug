{"sha": "570a374aa5f8281b261a7e4152492061d8786a2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcwYTM3NGFhNWY4MjgxYjI2MWE3ZTQxNTI0OTIwNjFkODc4NmEyZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2012-05-09T08:17:09Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2012-05-09T08:17:09Z"}, "message": "re PR target/53271 (powerpc-eabispe build fails with ice on unwind-dw2.c)\n\n\tPR target/53271\n\t* config/rs6000/rs6000.c (gen_frame_set): New function.\n\t(gen_frame_load, gen_frame_store): New functions.\n\t(rs6000_savres_rtx): Use the above.\n\t(rs6000_emit_epilogue, rs6000_emit_prologue): Here too.\n\tCorrect mode used for CR2 in save/restore_world patterns.\n\tDon't emit instructions for eh_return frame unwind reg info.\n\nFrom-SVN: r187316", "tree": {"sha": "f2646d37acac9795cbe535776a1e7b7c2e4cbc39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2646d37acac9795cbe535776a1e7b7c2e4cbc39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/570a374aa5f8281b261a7e4152492061d8786a2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570a374aa5f8281b261a7e4152492061d8786a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/570a374aa5f8281b261a7e4152492061d8786a2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570a374aa5f8281b261a7e4152492061d8786a2e/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99b113f9789e6fd7aa0f7fe1cc7cccc22d7d2fc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99b113f9789e6fd7aa0f7fe1cc7cccc22d7d2fc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99b113f9789e6fd7aa0f7fe1cc7cccc22d7d2fc1"}], "stats": {"total": 232, "additions": 104, "deletions": 128}, "files": [{"sha": "3894d41deaf0490e28412a4e22b2b6b68e5799f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a374aa5f8281b261a7e4152492061d8786a2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a374aa5f8281b261a7e4152492061d8786a2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=570a374aa5f8281b261a7e4152492061d8786a2e", "patch": "@@ -1,3 +1,13 @@\n+2012-05-09  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/53271\n+\t* config/rs6000/rs6000.c (gen_frame_set): New function.\n+\t(gen_frame_load, gen_frame_store): New functions.\n+\t(rs6000_savres_rtx): Use the above.\n+\t(rs6000_emit_epilogue, rs6000_emit_prologue): Here too.\n+\tCorrect mode used for CR2 in save/restore_world patterns.\n+\tDon't emit instructions for eh_return frame unwind reg info.\n+\n 2012-05-08  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphbuild.c (build_cgraph_edges): Do not finalize vars"}, {"sha": "c3331dce213c1a8ccf628aefd0ee3f3caf4e67e8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 94, "deletions": 128, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570a374aa5f8281b261a7e4152492061d8786a2e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570a374aa5f8281b261a7e4152492061d8786a2e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=570a374aa5f8281b261a7e4152492061d8786a2e", "patch": "@@ -18961,6 +18961,28 @@ generate_set_vrsave (rtx reg, rs6000_stack_t *info, int epiloguep)\n   return insn;\n }\n \n+static rtx\n+gen_frame_set (rtx reg, rtx frame_reg, int offset, bool store)\n+{\n+  rtx addr, mem;\n+\n+  addr = gen_rtx_PLUS (Pmode, frame_reg, GEN_INT (offset));\n+  mem = gen_frame_mem (GET_MODE (reg), addr);\n+  return gen_rtx_SET (VOIDmode, store ? mem : reg, store ? reg : mem);\n+}\n+\n+static rtx\n+gen_frame_load (rtx reg, rtx frame_reg, int offset)\n+{\n+  return gen_frame_set (reg, frame_reg, offset, false);\n+}\n+\n+static rtx\n+gen_frame_store (rtx reg, rtx frame_reg, int offset)\n+{\n+  return gen_frame_set (reg, frame_reg, offset, true);\n+}\n+\n /* Save a register into the frame, and emit RTX_FRAME_RELATED_P notes.\n    Save REGNO into [FRAME_REG + OFFSET] in mode MODE.  */\n \n@@ -19301,27 +19323,14 @@ rs6000_emit_savres_rtx (rs6000_stack_t *info,\n       = gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, use_reg));\n \n   for (i = 0; i < end_reg - start_reg; i++)\n-    {\n-      rtx addr, reg, mem;\n-      reg = gen_rtx_REG (reg_mode, start_reg + i);\n-      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t   GEN_INT (save_area_offset + reg_size * i));\n-      mem = gen_frame_mem (reg_mode, addr);\n-\n-      RTVEC_ELT (p, i + offset) = gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t       (sel & SAVRES_SAVE) ? mem : reg,\n-\t\t\t\t\t       (sel & SAVRES_SAVE) ? reg : mem);\n-    }\n+    RTVEC_ELT (p, i + offset)\n+      = gen_frame_set (gen_rtx_REG (reg_mode, start_reg + i),\n+\t\t       frame_reg_rtx, save_area_offset + reg_size * i,\n+\t\t       (sel & SAVRES_SAVE) != 0);\n \n   if ((sel & SAVRES_SAVE) && (sel & SAVRES_LR))\n-    {\n-      rtx addr, reg, mem;\n-      reg = gen_rtx_REG (Pmode, 0);\n-      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t   GEN_INT (lr_offset));\n-      mem = gen_frame_mem (Pmode, addr);\n-      RTVEC_ELT (p, i + offset) = gen_rtx_SET (VOIDmode, mem, reg);\n-    }\n+    RTVEC_ELT (p, i + offset)\n+      = gen_frame_store (gen_rtx_REG (Pmode, 0), frame_reg_rtx, lr_offset);\n \n   par = gen_rtx_PARALLEL (VOIDmode, p);\n \n@@ -19479,59 +19488,33 @@ rs6000_emit_prologue (void)\n       /* We do floats first so that the instruction pattern matches\n \t properly.  */\n       for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-\t{\n-\t  rtx reg = gen_rtx_REG ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n-\t\t\t\t  ? DFmode : SFmode),\n-\t\t\t\t info->first_fp_reg_save + i);\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t   GEN_INT (info->fp_save_offset\n-\t\t\t\t\t    + frame_off + 8 * i));\n-\t  rtx mem = gen_frame_mem ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n-\t\t\t\t    ? DFmode : SFmode), addr);\n-\n-\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n-\t}\n+\tRTVEC_ELT (p, j++)\n+\t  = gen_frame_store (gen_rtx_REG (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n+\t\t\t\t\t  ? DFmode : SFmode,\n+\t\t\t\t\t  info->first_fp_reg_save + i),\n+\t\t\t     frame_reg_rtx,\n+\t\t\t     info->fp_save_offset + frame_off + 8 * i);\n       for (i = 0; info->first_altivec_reg_save + i <= LAST_ALTIVEC_REGNO; i++)\n-\t{\n-\t  rtx reg = gen_rtx_REG (V4SImode, info->first_altivec_reg_save + i);\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t   GEN_INT (info->altivec_save_offset\n-\t\t\t\t\t    + frame_off + 16 * i));\n-\t  rtx mem = gen_frame_mem (V4SImode, addr);\n-\n-\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n-\t}\n+\tRTVEC_ELT (p, j++)\n+\t  = gen_frame_store (gen_rtx_REG (V4SImode,\n+\t\t\t\t\t  info->first_altivec_reg_save + i),\n+\t\t\t     frame_reg_rtx,\n+\t\t\t     info->altivec_save_offset + frame_off + 16 * i);\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-\t{\n-\t  rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t   GEN_INT (info->gp_save_offset\n-\t\t\t\t\t    + frame_off + reg_size * i));\n-\t  rtx mem = gen_frame_mem (reg_mode, addr);\n-\n-\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n-\t}\n-\n-      {\n-\t/* CR register traditionally saved as CR2.  */\n-\trtx reg = gen_rtx_REG (reg_mode, CR2_REGNO);\n-\trtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t GEN_INT (info->cr_save_offset\n-\t\t\t\t\t  + frame_off));\n-\trtx mem = gen_frame_mem (reg_mode, addr);\n+\tRTVEC_ELT (p, j++)\n+\t  = gen_frame_store (gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n+\t\t\t     frame_reg_rtx,\n+\t\t\t     info->gp_save_offset + frame_off + reg_size * i);\n \n-\tRTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n-      }\n+      /* CR register traditionally saved as CR2.  */\n+      RTVEC_ELT (p, j++)\n+\t= gen_frame_store (gen_rtx_REG (SImode, CR2_REGNO),\n+\t\t\t   frame_reg_rtx, info->cr_save_offset + frame_off);\n       /* Explain about use of R0.  */\n       if (info->lr_save_p)\n-\t{\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t   GEN_INT (info->lr_save_offset\n-\t\t\t\t\t    + frame_off));\n-\t  rtx mem = gen_frame_mem (reg_mode, addr);\n-\n-\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg0);\n-\t}\n+\tRTVEC_ELT (p, j++)\n+\t  = gen_frame_store (reg0,\n+\t\t\t     frame_reg_rtx, info->lr_save_offset + frame_off);\n       /* Explain what happens to the stack pointer.  */\n       {\n \trtx newval = gen_rtx_PLUS (Pmode, sp_reg_rtx, treg);\n@@ -19834,17 +19817,10 @@ rs6000_emit_prologue (void)\n       int i;\n       p = rtvec_alloc (32 - info->first_gp_reg_save);\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-\t{\n-\t  rtx addr, reg, mem;\n-\t  reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n-\t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t       GEN_INT (info->gp_save_offset\n-\t\t\t\t\t+ frame_off\n-\t\t\t\t\t+ reg_size * i));\n-\t  mem = gen_frame_mem (reg_mode, addr);\n-\n-\t  RTVEC_ELT (p, i) = gen_rtx_SET (VOIDmode, mem, reg);\n-\t}\n+\tRTVEC_ELT (p, i)\n+\t  = gen_frame_store (gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n+\t\t\t     frame_reg_rtx,\n+\t\t\t     info->gp_save_offset + frame_off + reg_size * i);\n       insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n       rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n \t\t\t    NULL_RTX, NULL_RTX);\n@@ -19860,22 +19836,37 @@ rs6000_emit_prologue (void)\n \t\t\t   sp_off - frame_off);\n     }\n \n-  /* ??? There's no need to emit actual instructions here, but it's the\n-     easiest way to get the frame unwind information emitted.  */\n   if (crtl->calls_eh_return)\n     {\n-      unsigned int i, regno;\n+      unsigned int i;\n+      rtvec p;\n \n       for (i = 0; ; ++i)\n \t{\n-\t  regno = EH_RETURN_DATA_REGNO (i);\n+\t  unsigned int regno = EH_RETURN_DATA_REGNO (i);\n \t  if (regno == INVALID_REGNUM)\n \t    break;\n+\t}\n \n-\t  emit_frame_save (frame_reg_rtx, reg_mode, regno,\n-\t\t\t   info->ehrd_offset + frame_off + reg_size * (int) i,\n-\t\t\t   sp_off - frame_off);\n+      p = rtvec_alloc (i);\n+\n+      for (i = 0; ; ++i)\n+\t{\n+\t  unsigned int regno = EH_RETURN_DATA_REGNO (i);\n+\t  if (regno == INVALID_REGNUM)\n+\t    break;\n+\n+\t  insn\n+\t    = gen_frame_store (gen_rtx_REG (reg_mode, regno),\n+\t\t\t       sp_reg_rtx,\n+\t\t\t       info->ehrd_offset + sp_off + reg_size * (int) i);\n+\t  RTVEC_ELT (p, i) = insn;\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n+\n+      insn = emit_insn (gen_blockage ());\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, gen_rtx_PARALLEL (VOIDmode, p));\n     }\n \n   /* In AIX ABI we need to make sure r2 is really saved.  */\n@@ -20522,13 +20513,9 @@ rs6000_emit_epilogue (int sibcall)\n \n       {\n \t/* CR register traditionally saved as CR2.  */\n-\trtx reg = gen_rtx_REG (reg_mode, CR2_REGNO);\n-\trtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t GEN_INT (info->cr_save_offset));\n-\trtx mem = gen_frame_mem (reg_mode, addr);\n-\n-\tRTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n-\n+\trtx reg = gen_rtx_REG (SImode, CR2_REGNO);\n+\tRTVEC_ELT (p, j++)\n+\t  = gen_frame_load (reg, frame_reg_rtx, info->cr_save_offset);\n \tif (flag_shrink_wrap)\n \t  {\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n@@ -20541,24 +20528,18 @@ rs6000_emit_epilogue (int sibcall)\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n \t{\n \t  rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t   GEN_INT (info->gp_save_offset\n-\t\t\t\t\t    + reg_size * i));\n-\t  rtx mem = gen_frame_mem (reg_mode, addr);\n-\n-\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t  RTVEC_ELT (p, j++)\n+\t    = gen_frame_load (reg,\n+\t\t\t      frame_reg_rtx, info->gp_save_offset + reg_size * i);\n \t  if (flag_shrink_wrap)\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n       for (i = 0; info->first_altivec_reg_save + i <= LAST_ALTIVEC_REGNO; i++)\n \t{\n \t  rtx reg = gen_rtx_REG (V4SImode, info->first_altivec_reg_save + i);\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t   GEN_INT (info->altivec_save_offset\n-\t\t\t\t\t    + 16 * i));\n-\t  rtx mem = gen_frame_mem (V4SImode, addr);\n-\n-\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t  RTVEC_ELT (p, j++)\n+\t    = gen_frame_load (reg,\n+\t\t\t      frame_reg_rtx, info->altivec_save_offset + 16 * i);\n \t  if (flag_shrink_wrap)\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n@@ -20567,13 +20548,8 @@ rs6000_emit_epilogue (int sibcall)\n \t  rtx reg = gen_rtx_REG ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n \t\t\t\t  ? DFmode : SFmode),\n \t\t\t\t info->first_fp_reg_save + i);\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t   GEN_INT (info->fp_save_offset\n-\t\t\t\t\t    + 8 * i));\n-\t  rtx mem = gen_frame_mem ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n-\t\t\t\t    ? DFmode : SFmode), addr);\n-\n-\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t  RTVEC_ELT (p, j++)\n+\t    = gen_frame_load (reg, frame_reg_rtx, info->fp_save_offset + 8 * i);\n \t  if (flag_shrink_wrap)\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}\n@@ -21076,16 +21052,10 @@ rs6000_emit_epilogue (int sibcall)\n       rtvec p;\n       p = rtvec_alloc (32 - info->first_gp_reg_save);\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-\t{\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t   GEN_INT (info->gp_save_offset\n-\t\t\t\t\t    + frame_off\n-\t\t\t\t\t    + reg_size * i));\n-\t  rtx mem = gen_frame_mem (reg_mode, addr);\n-\t  rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n-\n-\t  RTVEC_ELT (p, i) = gen_rtx_SET (VOIDmode, reg, mem);\n-\t}\n+\tRTVEC_ELT (p, i)\n+\t  = gen_frame_load (gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n+\t\t\t    frame_reg_rtx,\n+\t\t\t    info->gp_save_offset + frame_off + reg_size * i);\n       emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n     }\n   else\n@@ -21277,14 +21247,10 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t\t\t\t       ? 1 : 11));\n \t  for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n \t    {\n-\t      rtx addr, mem, reg;\n-\n-\t      addr = gen_rtx_PLUS (Pmode, sp_reg_rtx,\n-\t\t\t\t   GEN_INT (info->fp_save_offset + 8 * i));\n-\t      mem = gen_frame_mem (DFmode, addr);\n-\t      reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n+\t      rtx reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n \n-\t      RTVEC_ELT (p, i + 4) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t      RTVEC_ELT (p, i + 4)\n+\t\t= gen_frame_load (reg, sp_reg_rtx, info->fp_save_offset + 8 * i);\n \t      if (flag_shrink_wrap)\n \t\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n \t\t\t\t\t       cfa_restores);"}]}