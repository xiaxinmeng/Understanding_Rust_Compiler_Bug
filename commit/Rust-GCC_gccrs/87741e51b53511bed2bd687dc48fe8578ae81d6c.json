{"sha": "87741e51b53511bed2bd687dc48fe8578ae81d6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc3NDFlNTFiNTM1MTFiZWQyYmQ2ODdkYzQ4ZmU4NTc4YWU4MWQ2Yw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-07-03T08:36:54Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-07-03T08:36:54Z"}, "message": "Add zstd support for LTO bytecode compression.\n\n2019-07-03  Martin Liska  <mliska@suse.cz>\n\n\t* Makefile.in: Define ZSTD_LIB.\n\t* common.opt: Adjust compression level\n\tto support also zstd levels.\n\t* config.in: Regenerate.\n\t* configure: Likewise.\n\t* configure.ac: Add --with-zstd and --with-zstd-include options\n\tand detect ZSTD.\n\t* doc/install.texi: Mention zstd dependency.\n\t* gcc.c: Print supported LTO compression algorithms.\n\t* lto-compress.c (lto_normalized_zstd_level): Likewise.\n\t(lto_compression_zstd): Likewise.\n\t(lto_uncompression_zstd): Likewise.\n\t(lto_end_compression): Dispatch in between zlib and zstd.\n\t(lto_compression_zlib): Mark with ATTRIBUTE_UNUSED.\n\t(lto_uncompression_zlib): Make it static.\n\t* lto-compress.h (lto_end_uncompression): Fix GNU coding style.\n\t* lto-section-in.c (lto_get_section_data): Pass info\n\tabout used compression.\n\t* lto-streamer-out.c: By default use zstd when possible.\n\t* timevar.def (TV_IPA_LTO_DECOMPRESS): Rename to decompression\n\t(TV_IPA_LTO_COMPRESS): Likewise for compression.\n\nFrom-SVN: r272996", "tree": {"sha": "e230e0bcb2b3cceb4f9d73ecbd46d47f7fa7ffd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e230e0bcb2b3cceb4f9d73ecbd46d47f7fa7ffd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87741e51b53511bed2bd687dc48fe8578ae81d6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87741e51b53511bed2bd687dc48fe8578ae81d6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87741e51b53511bed2bd687dc48fe8578ae81d6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87741e51b53511bed2bd687dc48fe8578ae81d6c/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "88614dfa2bb5a40566bef00a85b13c4b167dc3c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88614dfa2bb5a40566bef00a85b13c4b167dc3c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88614dfa2bb5a40566bef00a85b13c4b167dc3c5"}], "stats": {"total": 432, "additions": 402, "deletions": 30}, "files": [{"sha": "5b255adaa16a51a52a326157665dba47757829fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -1,3 +1,27 @@\n+2019-07-03  Martin Liska  <mliska@suse.cz>\n+\n+\t* Makefile.in: Define ZSTD_LIB.\n+\t* common.opt: Adjust compression level\n+\tto support also zstd levels.\n+\t* config.in: Regenerate.\n+\t* configure: Likewise.\n+\t* configure.ac: Add --with-zstd and --with-zstd-include options\n+\tand detect ZSTD.\n+\t* doc/install.texi: Mention zstd dependency.\n+\t* gcc.c: Print supported LTO compression algorithms.\n+\t* lto-compress.c (lto_normalized_zstd_level): Likewise.\n+\t(lto_compression_zstd): Likewise.\n+\t(lto_uncompression_zstd): Likewise.\n+\t(lto_end_compression): Dispatch in between zlib and zstd.\n+\t(lto_compression_zlib): Mark with ATTRIBUTE_UNUSED.\n+\t(lto_uncompression_zlib): Make it static.\n+\t* lto-compress.h (lto_end_uncompression): Fix GNU coding style.\n+\t* lto-section-in.c (lto_get_section_data): Pass info\n+\tabout used compression.\n+\t* lto-streamer-out.c: By default use zstd when possible.\n+\t* timevar.def (TV_IPA_LTO_DECOMPRESS): Rename to decompression\n+\t(TV_IPA_LTO_COMPRESS): Likewise for compression.\n+\n 2019-07-03  Martin Liska  <mliska@suse.cz>\n \n \t* lto-section-in.c (lto_get_section_data): Add \"lto\" section."}, {"sha": "597dc01328b5ee094487f0ef38267e77a1978ddf", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -1065,7 +1065,7 @@ BUILD_LIBDEPS= $(BUILD_LIBIBERTY)\n LIBS = @LIBS@ libcommon.a $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBBACKTRACE) \\\n \t$(LIBIBERTY) $(LIBDECNUMBER) $(HOST_LIBS)\n BACKENDLIBS = $(ISLLIBS) $(GMPLIBS) $(PLUGINLIBS) $(HOST_LIBS) \\\n-\t$(ZLIB)\n+\t$(ZLIB) $(ZSTD_LIB)\n # Any system libraries needed just for GNAT.\n SYSLIBS = @GNAT_LIBEXC@\n \n@@ -1076,6 +1076,8 @@ GNATMAKE = @GNATMAKE@\n # Libs needed (at present) just for jcf-dump.\n LDEXP_LIB = @LDEXP_LIB@\n \n+ZSTD_LIB = @ZSTD_LIB@\n+\n # Likewise, for use in the tools that must run on this machine\n # even if we are cross-building GCC.\n BUILD_LIBS = $(BUILD_LIBIBERTY)"}, {"sha": "41514df68a8a355fc31c71f973ff871e904b74df", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -1888,8 +1888,8 @@ Specify the algorithm to partition symbols and vars at linktime.\n \n ; The initial value of -1 comes from Z_DEFAULT_COMPRESSION in zlib.h.\n flto-compression-level=\n-Common Joined RejectNegative UInteger Var(flag_lto_compression_level) Init(-1) IntegerRange(0, 9)\n--flto-compression-level=<number>\tUse zlib compression level <number> for IL.\n+Common Joined RejectNegative UInteger Var(flag_lto_compression_level) Init(-1) IntegerRange(0, 19)\n+-flto-compression-level=<number>\tUse zlib/zstd compression level <number> for IL.\n \n flto-odr-type-merging\n Common Ignore"}, {"sha": "13fd7959dd763564cc2a33d3ffe48edbe5925fbe", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -1926,6 +1926,12 @@\n #endif\n \n \n+/* Define if you have a working <zstd.h> header file. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_ZSTD_H\n+#endif\n+\n+\n /* Define if isl is in use. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_isl"}, {"sha": "8c9f7742ac7aa75be93c67ace664f608c7f11594", "filename": "gcc/configure", "status": "modified", "additions": 161, "deletions": 2, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -782,6 +782,8 @@ manext\n LIBICONV_DEP\n LTLIBICONV\n LIBICONV\n+ZSTD_LIB\n+ZSTD_INCLUDE\n DL_LIB\n LDEXP_LIB\n EXTRA_GCC_LIBS\n@@ -959,6 +961,9 @@ with_pkgversion\n with_bugurl\n enable_languages\n with_multilib_list\n+with_zstd\n+with_zstd_include\n+with_zstd_lib\n enable_rpath\n with_libiconv_prefix\n enable_sjlj_exceptions\n@@ -1783,6 +1788,12 @@ Optional Packages:\n   --with-pkgversion=PKG   Use PKG in the version string in place of \"GCC\"\n   --with-bugurl=URL       Direct users to URL to report a bug\n   --with-multilib-list    select multilibs (AArch64, SH and x86-64 only)\n+  --with-zstd=PATH        specify prefix directory for installed zstd library.\n+                          Equivalent to --with-zstd-include=PATH/include plus\n+                          --with-zstd-lib=PATH/lib\n+  --with-zstd-include=PATH\n+                          specify directory for installed zstd include files\n+  --with-zstd-lib=PATH    specify directory for the installed zstd library\n   --with-gnu-ld           assume the C compiler uses GNU ld default=no\n   --with-libiconv-prefix[=DIR]  search for libiconv in DIR/include and DIR/lib\n   --without-libiconv-prefix     don't search for libiconv in includedir and libdir\n@@ -9838,6 +9849,154 @@ $as_echo \"#define HAVE_INTTYPES_H 1\" >>confdefs.h\n \n fi\n \n+# Look for the ZSTD package.\n+ZSTD_INCLUDE=\n+ZSTD_LIB=\n+\n+\n+ZSTD_CPPFLAGS=\n+ZSTD_LDFLAGS=\n+\n+# Check whether --with-zstd was given.\n+if test \"${with_zstd+set}\" = set; then :\n+  withval=$with_zstd;\n+fi\n+\n+\n+# Check whether --with-zstd-include was given.\n+if test \"${with_zstd_include+set}\" = set; then :\n+  withval=$with_zstd_include;\n+fi\n+\n+\n+# Check whether --with-zstd-lib was given.\n+if test \"${with_zstd_lib+set}\" = set; then :\n+  withval=$with_zstd_lib;\n+fi\n+\n+case \"x$with_zstd\" in\n+  x) ;;\n+  xno)\n+    ZSTD_INCLUDE=no\n+    ZSTD_LIB=no\n+    ;;\n+  *) ZSTD_INCLUDE=$with_zstd/include\n+     ZSTD_LIB=$with_zstd/lib\n+     ;;\n+esac\n+if test \"x$with_zstd_include\" != x; then\n+  ZSTD_INCLUDE=$with_zstd_include\n+fi\n+if test \"x$with_zstd_lib\" != x; then\n+  ZSTD_LIB=$with_zstd_lib\n+fi\n+if test \"x$ZSTD_INCLUDE\" != x \\\n+   && test \"x$ZSTD_INCLUDE\" != xno; then\n+  ZSTD_CPPFLAGS=-I$ZSTD_INCLUDE\n+fi\n+if test \"x$ZSTD_LIB\" != x \\\n+   && test \"x$ZSTD_LIB\" != xno; then\n+  ZSTD_LDFLAGS=-L$ZSTD_LIB\n+fi\n+\n+CXXFLAGS=\"$CXXFLAGS $ZSTD_CPPFLAGS\"\n+LDFLAGS=\"$LDFLAGS $ZSTD_LDFLAGS\"\n+\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for zstd.h\" >&5\n+$as_echo_n \"checking for zstd.h... \" >&6; }\n+if ${gcc_cv_header_zstd_h+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <zstd.h>\n+int\n+main ()\n+{\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  gcc_cv_header_zstd_h=yes\n+else\n+  gcc_cv_header_zstd_h=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_header_zstd_h\" >&5\n+$as_echo \"$gcc_cv_header_zstd_h\" >&6; }\n+if test $gcc_cv_header_zstd_h = yes; then\n+\n+$as_echo \"#define HAVE_ZSTD_H 1\" >>confdefs.h\n+\n+fi\n+\n+# LTO can use zstd compression algorithm\n+save_LIBS=\"$LIBS\"\n+LIBS=\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing ZSTD_compress\" >&5\n+$as_echo_n \"checking for library containing ZSTD_compress... \" >&6; }\n+if ${ac_cv_search_ZSTD_compress+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_func_search_save_LIBS=$LIBS\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+/* Override any GCC internal prototype to avoid an error.\n+   Use char because int might match the return type of a GCC\n+   builtin and then its argument prototype would still apply.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+char ZSTD_compress ();\n+int\n+main ()\n+{\n+return ZSTD_compress ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+for ac_lib in '' zstd; do\n+  if test -z \"$ac_lib\"; then\n+    ac_res=\"none required\"\n+  else\n+    ac_res=-l$ac_lib\n+    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n+  fi\n+  if ac_fn_cxx_try_link \"$LINENO\"; then :\n+  ac_cv_search_ZSTD_compress=$ac_res\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext\n+  if ${ac_cv_search_ZSTD_compress+:} false; then :\n+  break\n+fi\n+done\n+if ${ac_cv_search_ZSTD_compress+:} false; then :\n+\n+else\n+  ac_cv_search_ZSTD_compress=no\n+fi\n+rm conftest.$ac_ext\n+LIBS=$ac_func_search_save_LIBS\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_ZSTD_compress\" >&5\n+$as_echo \"$ac_cv_search_ZSTD_compress\" >&6; }\n+ac_res=$ac_cv_search_ZSTD_compress\n+if test \"$ac_res\" != no; then :\n+  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n+\n+fi\n+\n+ZSTD_LIB=\"$LIBS\"\n+LIBS=\"$save_LIBS\"\n+\n+\n \n \n for ac_func in times clock kill getrlimit setrlimit atoq \\\n@@ -18655,7 +18814,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 18658 \"configure\"\n+#line 18817 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -18761,7 +18920,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 18764 \"configure\"\n+#line 18923 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "137d5b469c34af0de68c3cf99bd315df95c85235", "filename": "gcc/configure.ac", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -1258,6 +1258,72 @@ if test $gcc_cv_header_inttypes_h = yes; then\n \t[Define if you have a working <inttypes.h> header file.])\n fi\n \n+# Look for the ZSTD package.\n+ZSTD_INCLUDE=\n+ZSTD_LIB=\n+AC_SUBST(ZSTD_INCLUDE)\n+AC_SUBST(ZSTD_LIB)\n+ZSTD_CPPFLAGS=\n+ZSTD_LDFLAGS=\n+AC_ARG_WITH(zstd,\n+\t[AS_HELP_STRING([--with-zstd=PATH],\n+\t\t[specify prefix directory for installed zstd library.\n+\t\t Equivalent to --with-zstd-include=PATH/include\n+\t\t plus --with-zstd-lib=PATH/lib])])\n+AC_ARG_WITH(zstd-include,\n+\t[AS_HELP_STRING([--with-zstd-include=PATH],\n+\t\t[specify directory for installed zstd include files])])\n+AC_ARG_WITH(zstd-lib,\n+\t[AS_HELP_STRING([--with-zstd-lib=PATH],\n+\t\t[specify directory for the installed zstd library])])\n+case \"x$with_zstd\" in\n+  x) ;;\n+  xno)\n+    ZSTD_INCLUDE=no\n+    ZSTD_LIB=no\n+    ;;\n+  *) ZSTD_INCLUDE=$with_zstd/include\n+     ZSTD_LIB=$with_zstd/lib\n+     ;;\n+esac\n+if test \"x$with_zstd_include\" != x; then\n+  ZSTD_INCLUDE=$with_zstd_include\n+fi\n+if test \"x$with_zstd_lib\" != x; then\n+  ZSTD_LIB=$with_zstd_lib\n+fi\n+if test \"x$ZSTD_INCLUDE\" != x \\\n+   && test \"x$ZSTD_INCLUDE\" != xno; then\n+  ZSTD_CPPFLAGS=-I$ZSTD_INCLUDE\n+fi\n+if test \"x$ZSTD_LIB\" != x \\\n+   && test \"x$ZSTD_LIB\" != xno; then\n+  ZSTD_LDFLAGS=-L$ZSTD_LIB\n+fi\n+\n+CXXFLAGS=\"$CXXFLAGS $ZSTD_CPPFLAGS\"\n+LDFLAGS=\"$LDFLAGS $ZSTD_LDFLAGS\"\n+\n+AC_MSG_CHECKING(for zstd.h)\n+AC_CACHE_VAL(gcc_cv_header_zstd_h,\n+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n+[[#include <zstd.h>]])],\n+  [gcc_cv_header_zstd_h=yes],\n+  [gcc_cv_header_zstd_h=no])])\n+AC_MSG_RESULT($gcc_cv_header_zstd_h)\n+if test $gcc_cv_header_zstd_h = yes; then\n+  AC_DEFINE(HAVE_ZSTD_H, 1,\n+\t[Define if you have a working <zstd.h> header file.])\n+fi\n+\n+# LTO can use zstd compression algorithm\n+save_LIBS=\"$LIBS\"\n+LIBS=\n+AC_SEARCH_LIBS(ZSTD_compress, zstd)\n+ZSTD_LIB=\"$LIBS\"\n+LIBS=\"$save_LIBS\"\n+AC_SUBST(ZSTD_LIB)\n+\n dnl Disabled until we have a complete test for buggy enum bitfields.\n dnl gcc_AC_C_ENUM_BF_UNSIGNED\n "}, {"sha": "852aa8f6dae25c95b561d09f81000bba1c6a676d", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -396,6 +396,12 @@ built together with GCC.  Alternatively, the @option{--with-isl} configure\n option should be used if isl is not installed in your default library\n search path.\n \n+@item zstd Library.\n+\n+Necessary to build GCC with zstd compression used for LTO bytecode.\n+The library is searched in your default library patch search.\n+Alternatively, the @option{--with-zstd} configure option should be used.\n+\n @end table\n \n @heading Tools/packages necessary for modifying GCC"}, {"sha": "0c0a686eb9c53fce8ca063aa6029fab68e4396e3", "filename": "gcc/gcc.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -6791,6 +6791,11 @@ print_configuration (FILE *file)\n #endif\n \n   fnotice (file, \"Thread model: %s\\n\", thrmod);\n+  fnotice (file, \"Supported LTO compression algorithms: zlib\");\n+#ifdef HAVE_ZSTD_H\n+  fnotice (file, \" zstd\");\n+#endif\n+  fnotice (file, \"\\n\");\n \n   /* compiler_version is truncated at the first space when initialized\n   from version string, so truncate version_string at the first space"}, {"sha": "b925363ac7117d91e49569900a3b1cf201141583", "filename": "gcc/lto-compress.c", "status": "modified", "additions": 120, "deletions": 21, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Flto-compress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Flto-compress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-compress.c?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -35,6 +35,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-compress.h\"\n #include \"timevar.h\"\n \n+#ifdef HAVE_ZSTD_H\n+#include <zstd.h>\n+#endif\n+\n /* Compression stream structure, holds the flush callback and opaque token,\n    the buffered data, and a note of whether compressing or uncompressing.  */\n \n@@ -92,6 +96,91 @@ lto_normalized_zlib_level (void)\n   return level;\n }\n \n+/* Free the buffer and memory associated with STREAM.  */\n+\n+static void\n+lto_destroy_compression_stream (struct lto_compression_stream *stream)\n+{\n+  free (stream->buffer);\n+  free (stream);\n+}\n+\n+#ifdef HAVE_ZSTD_H\n+/* Return a zstd compression level that zstd will not reject.  Normalizes\n+   the compression level from the command line flag, clamping non-default\n+   values to the appropriate end of their valid range.  */\n+\n+static int\n+lto_normalized_zstd_level (void)\n+{\n+  int level = flag_lto_compression_level;\n+\n+  if (level != ZSTD_CLEVEL_DEFAULT)\n+    {\n+      if (level < 1)\n+\tlevel = 1;\n+      else if (level > ZSTD_maxCLevel ())\n+\tlevel = ZSTD_maxCLevel ();\n+    }\n+\n+  return level;\n+}\n+\n+/* Compress STREAM using ZSTD algorithm.  */\n+\n+static void\n+lto_compression_zstd (struct lto_compression_stream *stream)\n+{\n+  unsigned char *cursor = (unsigned char *) stream->buffer;\n+  size_t size = stream->bytes;\n+\n+  timevar_push (TV_IPA_LTO_COMPRESS);\n+  size_t const outbuf_length = ZSTD_compressBound (size);\n+  char *outbuf = (char *) xmalloc (outbuf_length);\n+\n+  size_t const csize = ZSTD_compress (outbuf, outbuf_length, cursor, size,\n+\t\t\t\t      lto_normalized_zstd_level ());\n+\n+  if (ZSTD_isError (csize))\n+    internal_error (\"compressed stream: %s\", ZSTD_getErrorName (csize));\n+\n+  stream->callback (outbuf, csize, NULL);\n+\n+  lto_destroy_compression_stream (stream);\n+  free (outbuf);\n+  timevar_pop (TV_IPA_LTO_COMPRESS);\n+}\n+\n+/* Uncompress STREAM using ZSTD algorithm.  */\n+\n+static void\n+lto_uncompression_zstd (struct lto_compression_stream *stream)\n+{\n+  unsigned char *cursor = (unsigned char *) stream->buffer;\n+  size_t size = stream->bytes;\n+\n+  timevar_push (TV_IPA_LTO_DECOMPRESS);\n+  unsigned long long const rsize = ZSTD_getFrameContentSize (cursor, size);\n+  if (rsize == ZSTD_CONTENTSIZE_ERROR)\n+    internal_error (\"original not compressed with zstd\");\n+  else if (rsize == ZSTD_CONTENTSIZE_UNKNOWN)\n+    internal_error (\"original size unknown\");\n+\n+  char *outbuf = (char *) xmalloc (rsize);\n+  size_t const dsize = ZSTD_decompress (outbuf, rsize, cursor, size);\n+\n+  if (ZSTD_isError (dsize))\n+    internal_error (\"decompressed stream: %s\", ZSTD_getErrorName (dsize));\n+\n+  stream->callback (outbuf, dsize, stream->opaque);\n+\n+  lto_destroy_compression_stream (stream);\n+  free (outbuf);\n+  timevar_pop (TV_IPA_LTO_DECOMPRESS);\n+}\n+\n+#endif\n+\n /* Create a new compression stream, with CALLBACK flush function passed\n    OPAQUE token, IS_COMPRESSION indicates if compressing or uncompressing.  */\n \n@@ -132,15 +221,6 @@ lto_append_to_compression_stream (struct lto_compression_stream *stream,\n   stream->bytes += num_chars;\n }\n \n-/* Free the buffer and memory associated with STREAM.  */\n-\n-static void\n-lto_destroy_compression_stream (struct lto_compression_stream *stream)\n-{\n-  free (stream->buffer);\n-  free (stream);\n-}\n-\n /* Return a new compression stream, with CALLBACK flush function passed\n    OPAQUE token.  */\n \n@@ -163,10 +243,8 @@ lto_compress_block (struct lto_compression_stream *stream,\n   lto_stats.num_output_il_bytes += num_chars;\n }\n \n-/* Finalize STREAM compression, and free stream allocations.  */\n-\n-void\n-lto_end_compression (struct lto_compression_stream *stream)\n+static void ATTRIBUTE_UNUSED\n+lto_compression_zlib (struct lto_compression_stream *stream)\n {\n   unsigned char *cursor = (unsigned char *) stream->buffer;\n   size_t remaining = stream->bytes;\n@@ -226,6 +304,16 @@ lto_end_compression (struct lto_compression_stream *stream)\n   timevar_pop (TV_IPA_LTO_COMPRESS);\n }\n \n+void\n+lto_end_compression (struct lto_compression_stream *stream)\n+{\n+#ifdef HAVE_ZSTD_H\n+  lto_compression_zstd (stream);\n+#else\n+  lto_compression_zlib (stream);\n+#endif\n+}\n+\n /* Return a new uncompression stream, with CALLBACK flush function passed\n    OPAQUE token.  */\n \n@@ -248,14 +336,8 @@ lto_uncompress_block (struct lto_compression_stream *stream,\n   lto_stats.num_input_il_bytes += num_chars;\n }\n \n-/* Finalize STREAM uncompression, and free stream allocations.\n-\n-   Because of the way LTO IL streams are compressed, there may be several\n-   concatenated compressed segments in the accumulated data, so for this\n-   function we iterate decompressions until no data remains.  */\n-\n-void\n-lto_end_uncompression (struct lto_compression_stream *stream)\n+static void\n+lto_uncompression_zlib (struct lto_compression_stream *stream)\n {\n   unsigned char *cursor = (unsigned char *) stream->buffer;\n   size_t remaining = stream->bytes;\n@@ -318,3 +400,20 @@ lto_end_uncompression (struct lto_compression_stream *stream)\n   free (outbuf);\n   timevar_pop (TV_IPA_LTO_DECOMPRESS);\n }\n+\n+void\n+lto_end_uncompression (struct lto_compression_stream *stream,\n+\t\t       lto_compression compression)\n+{\n+#ifdef HAVE_ZSTD_H\n+  if (compression == ZSTD)\n+    {\n+      lto_uncompression_zstd (stream);\n+      return;\n+    }\n+#endif\n+  if (compression == ZSTD)\n+    internal_error (\"compiler does not support ZSTD LTO compression\");\n+\n+  lto_uncompression_zlib (stream);\n+}"}, {"sha": "564b17e9f983b317467f031e8cbe5606e264df9f", "filename": "gcc/lto-compress.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Flto-compress.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Flto-compress.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-compress.h?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -37,6 +37,7 @@ extern struct lto_compression_stream\n \t\t\t    void *opaque);\n extern void lto_uncompress_block (struct lto_compression_stream *stream,\n \t\t\t\t  const char *base, size_t num_chars);\n-extern void lto_end_uncompression (struct lto_compression_stream *stream);\n+extern void lto_end_uncompression (struct lto_compression_stream *stream,\n+\t\t\t\t  lto_compression compression);\n \n #endif /* GCC_LTO_COMPRESS_H  */"}, {"sha": "80fdb03f4d4b937bb27587ef80d1631a294be59c", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -161,7 +161,7 @@ lto_get_section_data (struct lto_file_decl_data *file_data,\n \n       stream = lto_start_uncompression (lto_append_data, &buffer);\n       lto_uncompress_block (stream, data, *len);\n-      lto_end_uncompression (stream);\n+      lto_end_uncompression (stream, file_data->lto_section_header.compression);\n \n       *len = buffer.length - header_length;\n       data = buffer.data + header_length;"}, {"sha": "49ca5cecad11e4a8b302dae88457d617d32d4129", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -2395,7 +2395,11 @@ produce_lto_section ()\n   lto_begin_section (section_name, false);\n   free (section_name);\n \n+#ifdef HAVE_ZSTD_H\n+  lto_compression compression = ZSTD;\n+#else\n   lto_compression compression = ZLIB;\n+#endif\n \n   bool slim_object = flag_generate_lto && !flag_fat_lto_objects;\n   lto_section s"}, {"sha": "626ce493b76e42f8db9482b8a02acf14beba2e34", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87741e51b53511bed2bd687dc48fe8578ae81d6c/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=87741e51b53511bed2bd687dc48fe8578ae81d6c", "patch": "@@ -78,8 +78,8 @@ DEFTIMEVAR (TV_IPA_INLINING          , \"ipa inlining heuristics\")\n DEFTIMEVAR (TV_IPA_FNSPLIT           , \"ipa function splitting\")\n DEFTIMEVAR (TV_IPA_COMDATS\t     , \"ipa comdats\")\n DEFTIMEVAR (TV_IPA_OPT\t\t     , \"ipa various optimizations\")\n-DEFTIMEVAR (TV_IPA_LTO_DECOMPRESS    , \"lto stream inflate\")\n-DEFTIMEVAR (TV_IPA_LTO_COMPRESS      , \"lto stream deflate\")\n+DEFTIMEVAR (TV_IPA_LTO_DECOMPRESS    , \"lto stream decompression\")\n+DEFTIMEVAR (TV_IPA_LTO_COMPRESS      , \"lto stream compression\")\n DEFTIMEVAR (TV_IPA_LTO_OUTPUT        , \"lto stream output\")\n DEFTIMEVAR (TV_IPA_LTO_GIMPLE_IN     , \"ipa lto gimple in\")\n DEFTIMEVAR (TV_IPA_LTO_GIMPLE_OUT    , \"ipa lto gimple out\")"}]}