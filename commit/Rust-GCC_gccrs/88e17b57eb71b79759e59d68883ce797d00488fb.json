{"sha": "88e17b57eb71b79759e59d68883ce797d00488fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhlMTdiNTdlYjcxYjc5NzU5ZTU5ZDY4ODgzY2U3OTdkMDA0ODhmYg==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@cygnus.com", "date": "1998-09-21T01:22:07Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "1998-09-21T01:22:07Z"}, "message": "1998-09-21  Ben Elliston  <bje@cygnus.com>\n        * New directory.  Moved files from ../gcc/objc.\n\nFrom-SVN: r22514", "tree": {"sha": "74295f11944f5c930aca90bb544749afb89e227c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74295f11944f5c930aca90bb544749afb89e227c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88e17b57eb71b79759e59d68883ce797d00488fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e17b57eb71b79759e59d68883ce797d00488fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88e17b57eb71b79759e59d68883ce797d00488fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e17b57eb71b79759e59d68883ce797d00488fb/comments", "author": null, "committer": null, "parents": [{"sha": "2325c774f8fdb0cabad328aba994a8224bb1c021", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2325c774f8fdb0cabad328aba994a8224bb1c021", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2325c774f8fdb0cabad328aba994a8224bb1c021"}], "stats": {"total": 12625, "additions": 12625, "deletions": 0}, "files": [{"sha": "28d7554f76f488170adfe1922209e1fc5d3a8524", "filename": "libobjc/ChangeLog", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,4 @@\n+1998-09-21  Ben Elliston  <bje@cygnus.com>\n+\n+\t* New directory.  Moved files from ../gcc/objc.\n+"}, {"sha": "c9799544a029095a0772468d986ee82c7391105d", "filename": "libobjc/NXConstStr.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FNXConstStr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FNXConstStr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FNXConstStr.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,44 @@\n+/* Interface for the NXConstantString class for Objective-C.\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Contributed by Pieter J. Schoenmakers <tiggr@es.ele.tue.nl>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+ \n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __nxconstantstring_INCLUDE_GNU\n+#define __nxconstantstring_INCLUDE_GNU\n+\n+#include \"objc/Object.h\"\n+\n+@interface NXConstantString: Object\n+{\n+  char *c_string;\n+  unsigned int len;\n+}\n+\n+-(const char *) cString;\n+-(unsigned int) length;\n+\n+@end\n+\n+#endif"}, {"sha": "4d2f3e1d7fc0166f8f287cabc851ea522ee0ae25", "filename": "libobjc/NXConstStr.m", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FNXConstStr.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FNXConstStr.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FNXConstStr.m?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,42 @@\n+/* Implementation of the NXConstantString class for Objective-C.\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Contributed by Pieter J. Schoenmakers <tiggr@es.ele.tue.nl>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+ \n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#include \"objc/NXConstStr.h\"\n+\n+@implementation NXConstantString\n+\n+-(const char *) cString\n+{\n+  return (c_string);\n+} /* -cString */\n+\n+-(unsigned int) length\n+{\n+  return (len);\n+} /* -length */\n+\n+@end"}, {"sha": "a762acc3f7dbf99271ca9ff9e9db0ecf60c83d62", "filename": "libobjc/Object.h", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FObject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FObject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FObject.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,124 @@\n+/* Interface for the Object class for Objective-C.\n+   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled\n+   with GCC to produce an executable, this does not cause the resulting\n+   executable to be covered by the GNU General Public License.  This\n+   exception does not however invalidate any other reasons why the\n+   executable file might be covered by the GNU General Public License. */\n+\n+#ifndef __object_INCLUDE_GNU\n+#define __object_INCLUDE_GNU\n+\n+#include <objc/objc.h>\n+#include <objc/typedstream.h>\n+\n+/*\n+ * All classes are derived from Object.  As such,\n+ * this is the overhead tacked onto those objects.\n+ */\n+@interface Object\n+{\n+    Class\tisa;\t/* A pointer to the instance's class structure */\n+}\n+\n+        /* Initializing classes and instances */\n++ initialize;\n+- init;\n+\n+        /* Creating, freeing, and copying instances */\n++ new;\n++ alloc;\n+- free;\n+- copy;\n+- shallowCopy;\n+- deepen;\n+- deepCopy;\n+\n+        /* Identifying classes */\n+- (Class)class;\n+- (Class)superClass;\n+- (MetaClass)metaClass;\n+- (const char *)name;\n+\n+        /* Identifying and comparing objects */\n+- self;\n+- (unsigned int)hash;\n+- (BOOL)isEqual:anObject;\n+- (int)compare:anotherObject;\n+\n+        /* Testing object type */\n+- (BOOL)isMetaClass;\n+- (BOOL)isClass;\n+- (BOOL)isInstance;\n+\n+        /* Testing inheritance relationships */\n+- (BOOL)isKindOf:(Class)aClassObject;\n+- (BOOL)isMemberOf:(Class)aClassObject;\n+- (BOOL)isKindOfClassNamed:(const char *)aClassName;\n+- (BOOL)isMemberOfClassNamed:(const char *)aClassName;\n+\n+        /* Testing class functionality */\n++ (BOOL)instancesRespondTo:(SEL)aSel;\n+- (BOOL)respondsTo:(SEL)aSel;\n+\n+\t/* Testing protocol conformance */\n+- (BOOL)conformsTo:(Protocol*)aProtocol;\n+\n+        /* Introspection */\n++ (IMP)instanceMethodFor:(SEL)aSel;\n+- (IMP)methodFor:(SEL)aSel;\n++ (struct objc_method_description *)descriptionForInstanceMethod:(SEL)aSel;\n+- (struct objc_method_description *)descriptionForMethod:(SEL)aSel;\n+\n+        /* Sending messages determined at run time */\n+- perform:(SEL)aSel;\n+- perform:(SEL)aSel with:anObject;\n+- perform:(SEL)aSel with:anObject1 with:anObject2;\n+\n+        /* Forwarding */\n+- (retval_t)forward:(SEL)aSel :(arglist_t)argFrame;\n+- (retval_t)performv:(SEL)aSel :(arglist_t)argFrame;\n+\n+        /* Posing */\n++ poseAs:(Class)aClassObject;\n+- (Class)transmuteClassTo:(Class)aClassObject;\n+\n+        /* Enforcing intentions */\n+- subclassResponsibility:(SEL)aSel;\n+- notImplemented:(SEL)aSel;\n+- shouldNotImplement:(SEL)aSel;\n+\n+        /* Error handling */\n+- doesNotRecognize:(SEL)aSel;\n+- error:(const char *)aString, ...;\n+\n+        /* Archiving */\n++ (int)version;\n++ setVersion:(int)aVersion;\n++ (int)streamVersion: (TypedStream*)aStream;\n+\n+- read: (TypedStream*)aStream;\n+- write: (TypedStream*)aStream;\n+- awake;\n+\n+@end\n+\n+#endif"}, {"sha": "64b52f48368708c8c855356e423d3f35e993c942", "filename": "libobjc/Object.m", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FObject.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FObject.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FObject.m?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,387 @@\n+/* The implementation of class Object for Objective-C.\n+   Copyright (C) 1993, 1994, 1995, 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled\n+   with GCC to produce an executable, this does not cause the resulting\n+   executable to be covered by the GNU General Public License.  This\n+   exception does not however invalidate any other reasons why the\n+   executable file might be covered by the GNU General Public License. */\n+\n+#include <stdarg.h>\n+#include \"objc/Object.h\"\n+#include \"objc/Protocol.h\"\n+#include \"objc/objc-api.h\"\n+\n+extern int errno;\n+\n+#define MAX_CLASS_NAME_LEN 256\n+\n+@implementation Object\n+\n++ initialize\n+{\n+  return self;\n+}\n+\n+- init\n+{\n+  return self;\n+}\n+\n++ new\n+{\n+  return [[self alloc] init];\n+}\n+\n++ alloc\n+{\n+  return class_create_instance(self);\n+}\n+\n+- free\n+{\n+  return object_dispose(self);\n+}\n+\n+- copy\n+{\n+  return [[self shallowCopy] deepen];\n+}\n+\n+- shallowCopy\n+{\n+  return object_copy(self);\n+}\n+\n+- deepen\n+{\n+  return self;\n+}\n+\n+- deepCopy\n+{\n+  return [self copy];\n+}\n+\n+- (Class)class\n+{\n+  return object_get_class(self);\n+}\n+\n+- (Class)superClass\n+{\n+  return object_get_super_class(self);\n+}\n+\n+- (MetaClass)metaClass\n+{\n+  return object_get_meta_class(self);\n+}\n+\n+- (const char *)name\n+{\n+  return object_get_class_name(self);\n+}\n+\n+- self\n+{\n+  return self;\n+}\n+\n+- (unsigned int)hash\n+{\n+  return (size_t)self;\n+}\n+\n+- (BOOL)isEqual:anObject\n+{\n+  return self==anObject;\n+}\n+\n+- (int)compare:anotherObject;\n+{\n+  if ([self isEqual:anotherObject])\n+    return 0;\n+  // Ordering objects by their address is pretty useless, \n+  // so subclasses should override this is some useful way.\n+  else if (self > anotherObject)\n+    return 1;\n+  else \n+    return -1;\n+}\n+\n+- (BOOL)isMetaClass\n+{\n+  return NO;\n+}\n+\n+- (BOOL)isClass\n+{\n+  return object_is_class(self);\n+}\n+\n+- (BOOL)isInstance\n+{\n+  return object_is_instance(self);\n+}\n+\n+- (BOOL)isKindOf:(Class)aClassObject\n+{\n+  Class class;\n+\n+  for (class = self->isa; class!=Nil; class = class_get_super_class(class))\n+    if (class==aClassObject)\n+      return YES;\n+  return NO;\n+}\n+\n+- (BOOL)isMemberOf:(Class)aClassObject\n+{\n+  return self->isa==aClassObject;\n+}\n+\n+- (BOOL)isKindOfClassNamed:(const char *)aClassName\n+{\n+  Class class;\n+\n+  if (aClassName!=NULL)\n+    for (class = self->isa; class!=Nil; class = class_get_super_class(class))\n+      if (!strcmp(class_get_class_name(class), aClassName))\n+        return YES;\n+  return NO;\n+}\n+\n+- (BOOL)isMemberOfClassNamed:(const char *)aClassName\n+{\n+  return ((aClassName!=NULL)\n+          &&!strcmp(class_get_class_name(self->isa), aClassName));\n+}\n+\n++ (BOOL)instancesRespondTo:(SEL)aSel\n+{\n+  return class_get_instance_method(self, aSel)!=METHOD_NULL;\n+}\n+\n+- (BOOL)respondsTo:(SEL)aSel\n+{\n+  return ((object_is_instance(self)\n+           ?class_get_instance_method(self->isa, aSel)\n+           :class_get_class_method(self->isa, aSel))!=METHOD_NULL);\n+}\n+\n++ (IMP)instanceMethodFor:(SEL)aSel\n+{\n+  return method_get_imp(class_get_instance_method(self, aSel));\n+}\n+\n+// Indicates if the receiving class or instance conforms to the given protocol\n+// not usually overridden by subclasses\n+//\n+// Modified 9/5/94 to always search the class object's protocol list, rather\n+// than the meta class.\n+\n++ (BOOL) conformsTo: (Protocol*)aProtocol\n+{\n+  int i;\n+  struct objc_protocol_list* proto_list;\n+  id parent;\n+\n+  for (proto_list = ((Class)self)->protocols;\n+       proto_list; proto_list = proto_list->next)\n+    {\n+      for (i=0; i < proto_list->count; i++)\n+      {\n+        if ([proto_list->list[i] conformsTo: aProtocol])\n+          return YES;\n+      }\n+    }\n+\n+  if ((parent = [self superClass]))\n+    return [parent conformsTo: aProtocol];\n+  else\n+    return NO;\n+}\n+\n+- (BOOL) conformsTo: (Protocol*)aProtocol\n+{\n+  return [[self class] conformsTo:aProtocol];\n+}\n+\n+- (IMP)methodFor:(SEL)aSel\n+{\n+  return (method_get_imp(object_is_instance(self)\n+                         ?class_get_instance_method(self->isa, aSel)\n+                         :class_get_class_method(self->isa, aSel)));\n+}\n+\n++ (struct objc_method_description *)descriptionForInstanceMethod:(SEL)aSel\n+{\n+  return ((struct objc_method_description *)\n+           class_get_instance_method(self, aSel));\n+}\n+\n+- (struct objc_method_description *)descriptionForMethod:(SEL)aSel\n+{\n+  return ((struct objc_method_description *)\n+           (object_is_instance(self)\n+            ?class_get_instance_method(self->isa, aSel)\n+            :class_get_class_method(self->isa, aSel)));\n+}\n+\n+- perform:(SEL)aSel\n+{\n+  IMP msg = objc_msg_lookup(self, aSel);\n+  if (!msg)\n+    return [self error:\"invalid selector passed to %s\", sel_get_name(_cmd)];\n+  return (*msg)(self, aSel);\n+}\n+\n+- perform:(SEL)aSel with:anObject\n+{\n+  IMP msg = objc_msg_lookup(self, aSel);\n+  if (!msg)\n+    return [self error:\"invalid selector passed to %s\", sel_get_name(_cmd)];\n+  return (*msg)(self, aSel, anObject);\n+}\n+\n+- perform:(SEL)aSel with:anObject1 with:anObject2\n+{\n+  IMP msg = objc_msg_lookup(self, aSel);\n+  if (!msg)\n+    return [self error:\"invalid selector passed to %s\", sel_get_name(_cmd)];\n+  return (*msg)(self, aSel, anObject1, anObject2);\n+}\n+\n+- (retval_t)forward:(SEL)aSel :(arglist_t)argFrame\n+{\n+  return (retval_t)[self doesNotRecognize: aSel];\n+}\n+\n+- (retval_t)performv:(SEL)aSel :(arglist_t)argFrame\n+{\n+  return objc_msg_sendv(self, aSel, argFrame);\n+}\n+\n++ poseAs:(Class)aClassObject\n+{\n+  return class_pose_as(self, aClassObject);\n+}\n+\n+- (Class)transmuteClassTo:(Class)aClassObject\n+{\n+  if (object_is_instance(self))\n+    if (class_is_class(aClassObject))\n+      if (class_get_instance_size(aClassObject)==class_get_instance_size(isa))\n+        if ([self isKindOf:aClassObject])\n+          {\n+            Class old_isa = isa;\n+            isa = aClassObject;\n+            return old_isa;\n+          }\n+  return nil;\n+}\n+\n+- subclassResponsibility:(SEL)aSel\n+{\n+  return [self error:\"subclass should override %s\", sel_get_name(aSel)];\n+}\n+\n+- notImplemented:(SEL)aSel\n+{\n+  return [self error:\"method %s not implemented\", sel_get_name(aSel)];\n+}\n+\n+- shouldNotImplement:(SEL)aSel\n+{\n+  return [self error:\"%s should not implement %s\", \n+\t             object_get_class_name(self), sel_get_name(aSel)];\n+}\n+\n+- doesNotRecognize:(SEL)aSel\n+{\n+  return [self error:\"%s does not recognize %s\",\n+                     object_get_class_name(self), sel_get_name(aSel)];\n+}\n+\n+#ifdef __alpha__\n+extern size_t strlen(const char*);\n+#endif\n+\n+- error:(const char *)aString, ...\n+{\n+#define FMT \"error: %s (%s)\\n%s\\n\"\n+  char fmt[(strlen((char*)FMT)+strlen((char*)object_get_class_name(self))\n+            +((aString!=NULL)?strlen((char*)aString):0)+8)];\n+  va_list ap;\n+\n+  sprintf(fmt, FMT, object_get_class_name(self),\n+                    object_is_instance(self)?\"instance\":\"class\",\n+                    (aString!=NULL)?aString:\"\");\n+  va_start(ap, aString);\n+  objc_verror(self, OBJC_ERR_UNKNOWN, fmt, ap);\n+  va_end(ap);\n+  return nil;\n+#undef FMT\n+}\n+\n++ (int)version\n+{\n+  return class_get_version(self);\n+}\n+\n++ setVersion:(int)aVersion\n+{\n+  class_set_version(self, aVersion);\n+  return self;\n+}\n+\n++ (int)streamVersion: (TypedStream*)aStream\n+{\n+  if (aStream->mode == OBJC_READONLY)\n+    return objc_get_stream_class_version (aStream, self);\n+  else\n+    return class_get_version (self);\n+}\n+\n+// These are used to write or read the instance variables \n+// declared in this particular part of the object.  Subclasses\n+// should extend these, by calling [super read/write: aStream]\n+// before doing their own archiving.  These methods are private, in\n+// the sense that they should only be called from subclasses.\n+\n+- read: (TypedStream*)aStream\n+{\n+  // [super read: aStream];  \n+  return self;\n+}\n+\n+- write: (TypedStream*)aStream\n+{\n+  // [super write: aStream];\n+  return self;\n+}\n+\n+- awake\n+{\n+  // [super awake];\n+  return self;\n+}\n+\n+@end"}, {"sha": "c7464cf17a9addde9e9534c932627329584e08b8", "filename": "libobjc/Protocol.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FProtocol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FProtocol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FProtocol.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,58 @@\n+/* Declare the class Protocol for Objective C programs.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __Protocol_INCLUDE_GNU\n+#define __Protocol_INCLUDE_GNU\n+\n+#include \"objc/Object.h\"\n+\n+@interface Protocol : Object\n+{\n+@private\n+        char *protocol_name;\n+        struct objc_protocol_list *protocol_list;\n+        struct objc_method_description_list *instance_methods, *class_methods; \n+}\n+\n+/* Obtaining attributes intrinsic to the protocol */\n+\n+- (const char *)name;\n+\n+/* Testing protocol conformance */\n+\n+- (BOOL) conformsTo: (Protocol *)aProtocolObject;\n+\n+/* Looking up information specific to a protocol */\n+\n+- (struct objc_method_description *) descriptionForInstanceMethod:(SEL)aSel;\n+- (struct objc_method_description *) descriptionForClassMethod:(SEL)aSel;\n+\n+@end\n+\n+\n+\n+\n+#endif __Protocol_INCLUDE_GNU"}, {"sha": "43ba44eaf4f7eb51de70187910b7a20320b43381", "filename": "libobjc/Protocol.m", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FProtocol.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2FProtocol.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FProtocol.m?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,128 @@\n+/* This file contains the implementation of class Protocol.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC. \n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+ \n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#include \"objc/Protocol.h\"\n+#include \"objc/objc-api.h\"\n+\n+/* Method description list */\n+struct objc_method_description_list {\n+        int count;\n+        struct objc_method_description list[1];\n+};\n+\n+\n+@implementation Protocol\n+{\n+@private\n+        char *protocol_name;\n+        struct objc_protocol_list *protocol_list;\n+        struct objc_method_description_list *instance_methods, *class_methods; \n+}\n+\n+/* Obtaining attributes intrinsic to the protocol */\n+\n+- (const char *)name\n+{\n+  return protocol_name;\n+}\n+\n+/* Testing protocol conformance */\n+\n+- (BOOL) conformsTo: (Protocol *)aProtocolObject\n+{\n+  int i;\n+  struct objc_protocol_list* proto_list;\n+\n+  if (!strcmp(aProtocolObject->protocol_name, self->protocol_name))\n+    return YES;\n+\n+  for (proto_list = protocol_list; proto_list; proto_list = proto_list->next)\n+    {\n+      for (i=0; i < proto_list->count; i++)\n+\t{\n+\t  if ([proto_list->list[i] conformsTo: aProtocolObject])\n+\t    return YES;\n+\t}\n+    }\n+\n+  return NO;\n+}\n+\n+/* Looking up information specific to a protocol */\n+\n+- (struct objc_method_description *) descriptionForInstanceMethod:(SEL)aSel\n+{\n+  int i;\n+  struct objc_protocol_list* proto_list;\n+  const char* name = sel_get_name (aSel);\n+  struct objc_method_description *result;\n+\n+  for (i = 0; i < instance_methods->count; i++)\n+    {\n+      if (!strcmp ((char*)instance_methods->list[i].name, name))\n+\treturn &(instance_methods->list[i]);\n+    }\n+\n+  for (proto_list = protocol_list; proto_list; proto_list = proto_list->next)\n+    {\n+      for (i=0; i < proto_list->count; i++)\n+\t{\n+\t  if ((result = [proto_list->list[i]\n+\t\t\t descriptionForInstanceMethod: aSel]))\n+\t    return result;\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+- (struct objc_method_description *) descriptionForClassMethod:(SEL)aSel;\n+{\n+  int i;\n+  struct objc_protocol_list* proto_list;\n+  const char* name = sel_get_name (aSel);\n+  struct objc_method_description *result;\n+\n+  for (i = 0; i < class_methods->count; i++)\n+    {\n+      if (!strcmp ((char*)class_methods->list[i].name, name))\n+\treturn &(class_methods->list[i]);\n+    }\n+\n+  for (proto_list = protocol_list; proto_list; proto_list = proto_list->next)\n+    {\n+      for (i=0; i < proto_list->count; i++)\n+\t{\n+\t  if ((result = [proto_list->list[i]\n+\t\t\t descriptionForClassMethod: aSel]))\n+\t    return result;\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+@end"}, {"sha": "c762fe6186e53666f55f2ab1c822824fb3b0e29b", "filename": "libobjc/archive.c", "status": "added", "additions": 1651, "deletions": 0, "changes": 1651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Farchive.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Farchive.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Farchive.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,1651 @@\n+/* GNU Objective C Runtime archiving\n+   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"config.h\"\n+#include \"runtime.h\"\n+#include \"typedstream.h\"\n+#include \"encoding.h\"\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+extern int fflush(FILE*);\n+\n+#define ROUND(V, A) \\\n+  ({ typeof(V) __v=(V); typeof(A) __a=(A);  \\\n+     __a*((__v+__a-1)/__a); })\n+\n+#define PTR2LONG(P) (((char*)(P))-(char*)0)\n+#define LONG2PTR(L) (((char*)0)+(L))\n+\n+/* Declare some functions... */\n+\n+static int\n+objc_read_class (struct objc_typed_stream* stream, Class* class);\n+\n+int objc_sizeof_type(const char* type);\n+\n+static int\n+objc_write_use_common (struct objc_typed_stream* stream, unsigned long key);\n+\n+static int\n+objc_write_register_common (struct objc_typed_stream* stream,\n+\t\t\t    unsigned long key);\n+\n+static int \n+objc_write_class (struct objc_typed_stream* stream,\n+\t\t\t struct objc_class* class);\n+\n+const char* objc_skip_type (const char* type);\n+\n+static void __objc_finish_write_root_object(struct objc_typed_stream*);\n+static void __objc_finish_read_root_object(struct objc_typed_stream*);\n+\n+static __inline__ int\n+__objc_code_unsigned_char (unsigned char* buf, unsigned char val)\n+{\n+  if ((val&_B_VALUE) == val)\n+    {\n+      buf[0] = val|_B_SINT;\n+      return 1;\n+    }\n+  else\n+    {\n+      buf[0] = _B_NINT|0x01;\n+      buf[1] = val;\n+      return 2;\n+    }\n+}\n+\n+int\n+objc_write_unsigned_char (struct objc_typed_stream* stream,\n+\t\t\t  unsigned char value)\n+{\n+  unsigned char buf[sizeof (unsigned char)+1];\n+  int len = __objc_code_unsigned_char (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+\n+static __inline__ int\n+__objc_code_char (unsigned char* buf, char val)\n+{\n+  if (val >= 0)\n+    return __objc_code_unsigned_char (buf, val);\n+  else\n+    {\n+      buf[0] = _B_NINT|_B_SIGN|0x01;\n+      buf[1] = -val;\n+      return 2;\n+    }\n+}\n+\n+int\n+objc_write_char (struct objc_typed_stream* stream, char value)\n+{\n+  unsigned char buf[sizeof (char)+1];\n+  int len = __objc_code_char (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+\n+static __inline__ int\n+__objc_code_unsigned_short (unsigned char* buf, unsigned short val)\n+{\n+  if ((val&_B_VALUE) == val)\n+    {\n+      buf[0] = val|_B_SINT;\n+      return 1;\n+    }\n+  else \n+    {\n+      int c, b;\n+\n+      buf[0] = _B_NINT;\n+\n+      for (c= sizeof(short); c != 0; c -= 1)\n+\tif (((val>>(8*(c-1)))%0x100) != 0)\n+\t  break;\n+\n+      buf[0] |= c;\n+\n+      for (b = 1; c != 0; c--, b++)\n+\t{\n+\t  buf[b] = (val >> (8*(c-1)))%0x100;\n+\t}\n+\n+      return b;\n+    }\n+}\n+\n+int\n+objc_write_unsigned_short (struct objc_typed_stream* stream, \n+\t\t\t   unsigned short value)\n+{\n+  unsigned char buf[sizeof (unsigned short)+1];\n+  int len = __objc_code_unsigned_short (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+      \n+static __inline__ int\n+__objc_code_short (unsigned char* buf, short val)\n+{\n+  int sign = (val < 0);\n+  int size = __objc_code_unsigned_short (buf, sign ? -val : val);\n+  if (sign)\n+    buf[0] |= _B_SIGN;\n+  return size;\n+}\n+\n+int\n+objc_write_short (struct objc_typed_stream* stream, short value)\n+{\n+  unsigned char buf[sizeof (short)+1];\n+  int len = __objc_code_short (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+      \n+\n+static __inline__ int\n+__objc_code_unsigned_int (unsigned char* buf, unsigned int val)\n+{\n+  if ((val&_B_VALUE) == val)\n+    {\n+      buf[0] = val|_B_SINT;\n+      return 1;\n+    }\n+  else \n+    {\n+      int c, b;\n+\n+      buf[0] = _B_NINT;\n+\n+      for (c= sizeof(int); c != 0; c -= 1)\n+\tif (((val>>(8*(c-1)))%0x100) != 0)\n+\t  break;\n+\n+      buf[0] |= c;\n+\n+      for (b = 1; c != 0; c--, b++)\n+\t{\n+\t  buf[b] = (val >> (8*(c-1)))%0x100;\n+\t}\n+\n+      return b;\n+    }\n+}\n+\n+int\n+objc_write_unsigned_int (struct objc_typed_stream* stream, unsigned int value)\n+{\n+  unsigned char buf[sizeof(unsigned int)+1];\n+  int len = __objc_code_unsigned_int (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+\n+static __inline__ int\n+__objc_code_int (unsigned char* buf, int val)\n+{\n+  int sign = (val < 0);\n+  int size = __objc_code_unsigned_int (buf, sign ? -val : val);\n+  if (sign)\n+    buf[0] |= _B_SIGN;\n+  return size;\n+}\n+\n+int\n+objc_write_int (struct objc_typed_stream* stream, int value)\n+{\n+  unsigned char buf[sizeof(int)+1];\n+  int len = __objc_code_int (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+\n+static __inline__ int\n+__objc_code_unsigned_long (unsigned char* buf, unsigned long val)\n+{\n+  if ((val&_B_VALUE) == val)\n+    {\n+      buf[0] = val|_B_SINT;\n+      return 1;\n+    }\n+  else \n+    {\n+      int c, b;\n+\n+      buf[0] = _B_NINT;\n+\n+      for (c= sizeof(long); c != 0; c -= 1)\n+\tif (((val>>(8*(c-1)))%0x100) != 0)\n+\t  break;\n+\n+      buf[0] |= c;\n+\n+      for (b = 1; c != 0; c--, b++)\n+\t{\n+\t  buf[b] = (val >> (8*(c-1)))%0x100;\n+\t}\n+\n+      return b;\n+    }\n+}\n+\n+int\n+objc_write_unsigned_long (struct objc_typed_stream* stream, \n+\t\t\t  unsigned long value)\n+{\n+  unsigned char buf[sizeof(unsigned long)+1];\n+  int len = __objc_code_unsigned_long (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+\n+static __inline__ int\n+__objc_code_long (unsigned char* buf, long val)\n+{\n+  int sign = (val < 0);\n+  int size = __objc_code_unsigned_long (buf, sign ? -val : val);\n+  if (sign)\n+    buf[0] |= _B_SIGN;\n+  return size;\n+}\n+\n+int\n+objc_write_long (struct objc_typed_stream* stream, long value)\n+{\n+  unsigned char buf[sizeof(long)+1];\n+  int len = __objc_code_long (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+\n+\n+int\n+objc_write_string (struct objc_typed_stream* stream,\n+\t\t   const unsigned char* string, unsigned int nbytes)\n+{\n+  unsigned char buf[sizeof(unsigned int)+1];\n+  int len = __objc_code_unsigned_int (buf, nbytes);\n+  \n+  if ((buf[0]&_B_CODE) == _B_SINT)\n+    buf[0] = (buf[0]&_B_VALUE)|_B_SSTR;\n+\n+  else /* _B_NINT */\n+    buf[0] = (buf[0]&_B_VALUE)|_B_NSTR;\n+\n+  if ((*stream->write)(stream->physical, buf, len) != 0)\n+    return (*stream->write)(stream->physical, string, nbytes);\n+  else\n+    return 0;\n+}\n+\n+int\n+objc_write_string_atomic (struct objc_typed_stream* stream,\n+\t\t\t  unsigned char* string, unsigned int nbytes)\n+{\n+  unsigned long key;\n+  if ((key = PTR2LONG(hash_value_for_key (stream->stream_table, string))))\n+    return objc_write_use_common (stream, key);\n+  else\n+    {\n+      int length;\n+      hash_add (&stream->stream_table, LONG2PTR(key=PTR2LONG(string)), string);\n+      if ((length = objc_write_register_common (stream, key)))\n+\treturn objc_write_string (stream, string, nbytes);\n+      return length;\n+    }\n+}\n+\n+static int\n+objc_write_register_common (struct objc_typed_stream* stream, \n+\t\t\t    unsigned long key)\n+{\n+  unsigned char buf[sizeof (unsigned long)+2];\n+  int len = __objc_code_unsigned_long (buf+1, key);\n+  if (len == 1)\n+    {\n+      buf[0] = _B_RCOMM|0x01;\n+      buf[1] &= _B_VALUE;\n+      return (*stream->write)(stream->physical, buf, len+1);\n+    }\n+  else\n+    {\n+      buf[1] = (buf[1]&_B_VALUE)|_B_RCOMM;\n+      return (*stream->write)(stream->physical, buf+1, len);\n+    }\n+}\n+\n+static int\n+objc_write_use_common (struct objc_typed_stream* stream, unsigned long key)\n+{\n+  unsigned char buf[sizeof (unsigned long)+2];\n+  int len = __objc_code_unsigned_long (buf+1, key);\n+  if (len == 1)\n+    {\n+      buf[0] = _B_UCOMM|0x01;\n+      buf[1] &= _B_VALUE;\n+      return (*stream->write)(stream->physical, buf, 2);\n+    }\n+  else\n+    {\n+      buf[1] = (buf[1]&_B_VALUE)|_B_UCOMM;\n+      return (*stream->write)(stream->physical, buf+1, len);\n+    }\n+}\n+\n+static __inline__ int\n+__objc_write_extension (struct objc_typed_stream* stream, unsigned char code)\n+{\n+  if (code <= _B_VALUE)\n+    {\n+      unsigned char buf = code|_B_EXT;\n+      return (*stream->write)(stream->physical, &buf, 1);\n+    }\n+  else \n+    {\n+      objc_error(nil, OBJC_ERR_BAD_OPCODE,\n+\t\t \"__objc_write_extension: bad opcode %c\\n\", code);\n+      return -1;\n+    }\n+}\n+\n+__inline__ int\n+__objc_write_object (struct objc_typed_stream* stream, id object)\n+{\n+  unsigned char buf = '\\0';\n+  SEL write_sel = sel_get_any_uid (\"write:\");\n+  if (object)\n+    {\n+      __objc_write_extension (stream, _BX_OBJECT);\n+      objc_write_class (stream, object->class_pointer);\n+      (*objc_msg_lookup(object, write_sel))(object, write_sel, stream);\n+      return (*stream->write)(stream->physical, &buf, 1);\n+    }\n+  else\n+    return objc_write_use_common(stream, 0);\n+}\n+\n+int \n+objc_write_object_reference (struct objc_typed_stream* stream, id object)\n+{\n+  unsigned long key;\n+  if ((key = PTR2LONG(hash_value_for_key (stream->object_table, object))))\n+    return objc_write_use_common (stream, key);\n+\n+  __objc_write_extension (stream, _BX_OBJREF);\n+  return objc_write_unsigned_long (stream, PTR2LONG (object));\n+}\n+\n+int \n+objc_write_root_object (struct objc_typed_stream* stream, id object)\n+{\n+  int len = 0;\n+  if (stream->writing_root_p)\n+    objc_error (nil, OBJC_ERR_RECURSE_ROOT, \n+\t\t\"objc_write_root_object called recursively\");\n+  else\n+    {\n+      stream->writing_root_p = 1;\n+      __objc_write_extension (stream, _BX_OBJROOT);\n+      if((len = objc_write_object (stream, object)))\n+\t__objc_finish_write_root_object(stream);\n+      stream->writing_root_p = 0;\n+    }\n+  return len;\n+}\n+\n+int \n+objc_write_object (struct objc_typed_stream* stream, id object)\n+{\n+  unsigned long key;\n+  if ((key = PTR2LONG(hash_value_for_key (stream->object_table, object))))\n+    return objc_write_use_common (stream, key);\n+\n+  else if (object == nil)\n+    return objc_write_use_common(stream, 0);\n+\n+  else\n+    {\n+      int length;\n+      hash_add (&stream->object_table, LONG2PTR(key=PTR2LONG(object)), object);\n+      if ((length = objc_write_register_common (stream, key)))\n+\treturn __objc_write_object (stream, object);\n+      return length;\n+    }\n+}\n+\n+__inline__ int\n+__objc_write_class (struct objc_typed_stream* stream, struct objc_class* class)\n+{\n+  __objc_write_extension (stream, _BX_CLASS);\n+  objc_write_string_atomic(stream, (char*)class->name,\n+\t\t\t   strlen((char*)class->name));\n+  return objc_write_unsigned_long (stream, class->version);\n+}\n+\n+\n+static int \n+objc_write_class (struct objc_typed_stream* stream,\n+\t\t\t struct objc_class* class)\n+{\n+  unsigned long key;\n+  if ((key = PTR2LONG(hash_value_for_key (stream->stream_table, class))))\n+    return objc_write_use_common (stream, key);\n+  else\n+    {\n+      int length;\n+      hash_add (&stream->stream_table, LONG2PTR(key=PTR2LONG(class)), class);\n+      if ((length = objc_write_register_common (stream, key)))\n+\treturn __objc_write_class (stream, class);\n+      return length;\n+    }\n+}\n+\n+\n+__inline__ int \n+__objc_write_selector (struct objc_typed_stream* stream, SEL selector)\n+{\n+  const char* sel_name;\n+  __objc_write_extension (stream, _BX_SEL);\n+  /* to handle NULL selectors */\n+  if ((SEL)0 == selector)\n+    return objc_write_string (stream, \"\", 0);\n+  sel_name = sel_get_name (selector);\n+  return objc_write_string (stream, sel_name, strlen ((char*)sel_name));\n+}\n+\n+int \n+objc_write_selector (struct objc_typed_stream* stream, SEL selector)\n+{\n+  const char* sel_name;\n+  unsigned long key;\n+\n+  /* to handle NULL selectors */\n+  if ((SEL)0 == selector)\n+    return __objc_write_selector (stream, selector);\n+\n+  sel_name = sel_get_name (selector);\n+  if ((key = PTR2LONG(hash_value_for_key (stream->stream_table, sel_name))))\n+    return objc_write_use_common (stream, key);\n+  else\n+    {\n+      int length;\n+      hash_add (&stream->stream_table, \n+\t\tLONG2PTR(key=PTR2LONG(sel_name)), (char*)sel_name);\n+      if ((length = objc_write_register_common (stream, key)))\n+\treturn __objc_write_selector (stream, selector);\n+      return length;\n+    }\n+}\n+\n+\n+\n+/*\n+** Read operations \n+*/\n+\n+__inline__ int\n+objc_read_char (struct objc_typed_stream* stream, char* val)\n+{\n+  unsigned char buf;\n+  int len;\n+  len = (*stream->read)(stream->physical, &buf, 1);\n+  if (len != 0)\n+    {\n+      if ((buf & _B_CODE) == _B_SINT)\n+\t(*val) = (buf & _B_VALUE);\n+\n+      else if ((buf & _B_NUMBER) == 1)\n+\t{\n+\t  len = (*stream->read)(stream->physical, val, 1);\n+\t  if (buf&_B_SIGN)\n+\t    (*val) = -1*(*val);\n+\t}\n+\n+      else\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected 8bit signed int, got %dbit int\",\n+\t\t   (int)(buf&_B_NUMBER)*8);\n+    }\n+  return len;\n+}\n+\n+\n+__inline__ int\n+objc_read_unsigned_char (struct objc_typed_stream* stream, unsigned char* val)\n+{\n+  unsigned char buf;\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, &buf, 1)))\n+    {\n+      if ((buf & _B_CODE) == _B_SINT)\n+\t(*val) = (buf & _B_VALUE);\n+\n+      else if ((buf & _B_NUMBER) == 1)\n+\tlen = (*stream->read)(stream->physical, val, 1);\n+\n+      else\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected 8bit unsigned int, got %dbit int\",\n+\t\t   (int)(buf&_B_NUMBER)*8);\n+    }\n+  return len;\n+}\n+\n+__inline__ int\n+objc_read_short (struct objc_typed_stream* stream, short* value)\n+{\n+  unsigned char buf[sizeof(short)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\t{\n+\t  int pos = 1;\n+\t  int nbytes = buf[0] & _B_NUMBER;\n+\t  if (nbytes > sizeof (short))\n+\t    objc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t       \"expected short, got bigger (%dbits)\", nbytes*8);\n+\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t  (*value) = 0;\n+\t  while (pos <= nbytes)\n+\t    (*value) = ((*value)*0x100) + buf[pos++];\n+\t  if (buf[0] & _B_SIGN)\n+\t    (*value) = -(*value);\n+\t}\n+    }\n+  return len;\n+}\n+\n+__inline__ int\n+objc_read_unsigned_short (struct objc_typed_stream* stream,\n+\t\t\t  unsigned short* value)\n+{\n+  unsigned char buf[sizeof(unsigned short)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\t{\n+\t  int pos = 1;\n+\t  int nbytes = buf[0] & _B_NUMBER;\n+\t  if (nbytes > sizeof (short))\n+\t    objc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t       \"expected short, got int or bigger\");\n+\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t  (*value) = 0;\n+\t  while (pos <= nbytes)\n+\t    (*value) = ((*value)*0x100) + buf[pos++];\n+\t}\n+    }\n+  return len;\n+}\n+\n+\n+__inline__ int\n+objc_read_int (struct objc_typed_stream* stream, int* value)\n+{\n+  unsigned char buf[sizeof(int)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\t{\n+\t  int pos = 1;\n+\t  int nbytes = buf[0] & _B_NUMBER;\n+\t  if (nbytes > sizeof (int))\n+\t    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected int, got bigger\");\n+\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t  (*value) = 0;\n+\t  while (pos <= nbytes)\n+\t    (*value) = ((*value)*0x100) + buf[pos++];\n+\t  if (buf[0] & _B_SIGN)\n+\t    (*value) = -(*value);\n+\t}\n+    }\n+  return len;\n+}\n+\n+__inline__ int\n+objc_read_long (struct objc_typed_stream* stream, long* value)\n+{\n+  unsigned char buf[sizeof(long)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\t{\n+\t  int pos = 1;\n+\t  int nbytes = buf[0] & _B_NUMBER;\n+\t  if (nbytes > sizeof (long))\n+\t    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected long, got bigger\");\n+\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t  (*value) = 0;\n+\t  while (pos <= nbytes)\n+\t    (*value) = ((*value)*0x100) + buf[pos++];\n+\t  if (buf[0] & _B_SIGN)\n+\t    (*value) = -(*value);\n+\t}\n+    }\n+  return len;\n+}\n+\n+__inline__ int\n+__objc_read_nbyte_uint (struct objc_typed_stream* stream,\n+\t\t       unsigned int nbytes, unsigned int* val)\n+{\n+  int len, pos = 0;\n+  unsigned char buf[sizeof(unsigned int)+1];\n+\n+  if (nbytes > sizeof (int))\n+    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected int, got bigger\");\n+\n+  len = (*stream->read)(stream->physical, buf, nbytes);\n+  (*val) = 0;\n+  while (pos < nbytes)\n+    (*val) = ((*val)*0x100) + buf[pos++];\n+  return len;\n+}\n+  \n+\n+__inline__ int\n+objc_read_unsigned_int (struct objc_typed_stream* stream,\n+\t\t\tunsigned int* value)\n+{\n+  unsigned char buf[sizeof(unsigned int)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\tlen = __objc_read_nbyte_uint (stream, (buf[0] & _B_VALUE), value);\n+\n+    }\n+  return len;\n+}\n+\n+int\n+__objc_read_nbyte_ulong (struct objc_typed_stream* stream,\n+\t\t       unsigned int nbytes, unsigned long* val)\n+{\n+  int len, pos = 0;\n+  unsigned char buf[sizeof(unsigned long)+1];\n+\n+  if (nbytes > sizeof (long))\n+    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected long, got bigger\");\n+\n+  len = (*stream->read)(stream->physical, buf, nbytes);\n+  (*val) = 0;\n+  while (pos < nbytes)\n+    (*val) = ((*val)*0x100) + buf[pos++];\n+  return len;\n+}\n+  \n+\n+__inline__ int\n+objc_read_unsigned_long (struct objc_typed_stream* stream,\n+\t\t\tunsigned long* value)\n+{\n+  unsigned char buf[sizeof(unsigned long)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\tlen = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), value);\n+\n+    }\n+  return len;\n+}\n+\n+__inline__ int\n+objc_read_string (struct objc_typed_stream* stream,\n+\t\t  char** string)\n+{\n+  unsigned char buf[sizeof(unsigned int)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      unsigned long key = 0;\n+\n+      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n+\t{\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t}\n+\n+      switch (buf[0]&_B_CODE) {\n+      case _B_SSTR:\n+\t{\n+\t  int length = buf[0]&_B_VALUE;\n+\t  (*string) = (char*)objc_malloc(length+1);\n+\t  if (key)\n+\t    hash_add (&stream->stream_table, LONG2PTR(key), *string);\n+\t  len = (*stream->read)(stream->physical, *string, length);\n+\t  (*string)[length] = '\\0';\n+\t}\n+\tbreak;\n+\n+      case _B_UCOMM:\n+\t{\n+\t  char *tmp;\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  tmp = hash_value_for_key (stream->stream_table, LONG2PTR (key));\n+\t  *string = objc_malloc (strlen(tmp) + 1);\n+\t  strcpy (*string, tmp);\n+\t}\n+\tbreak;\n+\n+      case _B_NSTR:\n+\t{\n+\t  unsigned int nbytes = buf[0]&_B_VALUE;\n+\t  len = __objc_read_nbyte_uint(stream, nbytes, &nbytes);\n+\t  if (len) {\n+\t    (*string) = (char*)objc_malloc(nbytes+1);\n+\t    if (key)\n+\t      hash_add (&stream->stream_table, LONG2PTR(key), *string);\n+\t    len = (*stream->read)(stream->physical, *string, nbytes);\n+\t    (*string)[nbytes] = '\\0';\n+\t  }\n+\t}\n+\tbreak;\n+\t\n+      default:\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected string, got opcode %c\\n\", (buf[0]&_B_CODE));\n+      }\n+    }\n+\n+  return len;\n+}\n+\n+\n+int\n+objc_read_object (struct objc_typed_stream* stream, id* object)\n+{\n+  unsigned char buf[sizeof (unsigned int)];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      SEL read_sel = sel_get_any_uid (\"read:\");\n+      unsigned long key = 0;\n+\n+      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register common */\n+\t{\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t}\n+\n+      if (buf[0] == (_B_EXT | _BX_OBJECT))\n+\t{\n+\t  Class class;\n+\n+\t  /* get class */\n+\t  len = objc_read_class (stream, &class);\n+\n+\t  /* create instance */\n+\t  (*object) = class_create_instance(class);\n+\n+\t  /* register? */\n+\t  if (key)\n+\t    hash_add (&stream->object_table, LONG2PTR(key), *object);\n+\n+\t  /* send -read: */\n+\t  if (__objc_responds_to (*object, read_sel))\n+\t    (*get_imp(class, read_sel))(*object, read_sel, stream);\n+\n+\t  /* check null-byte */\n+\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t  if (buf[0] != '\\0')\n+\t    objc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t       \"expected null-byte, got opcode %c\", buf[0]);\n+\t}\n+\n+      else if ((buf[0]&_B_CODE) == _B_UCOMM)\n+\t{\n+\t  if (key)\n+\t    objc_error(nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  (*object) = hash_value_for_key (stream->object_table, LONG2PTR(key));\n+\t}\n+\n+      else if (buf[0] == (_B_EXT | _BX_OBJREF))\t/* a forward reference */\n+\t{\n+\t  struct objc_list* other;\n+\t  len = objc_read_unsigned_long (stream, &key);\n+\t  other = (struct objc_list*)hash_value_for_key (stream->object_refs, \n+\t\t\t\t\t\t\t LONG2PTR(key));\n+\t  hash_add (&stream->object_refs, LONG2PTR(key), \n+\t\t    (void*)list_cons(object, other));\n+\t}\n+\n+      else if (buf[0] == (_B_EXT | _BX_OBJROOT)) /* a root object */\n+\t{\n+\t  if (key)\n+\t    objc_error(nil, OBJC_ERR_BAD_KEY,\n+\t\t       \"cannot register root object...\");\n+\t  len = objc_read_object (stream, object);\n+\t  __objc_finish_read_root_object (stream);\n+\t}\n+\n+      else\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected object, got opcode %c\", buf[0]);\n+    }\n+  return len;\n+}\n+\n+static int\n+objc_read_class (struct objc_typed_stream* stream, Class* class)\n+{\n+  unsigned char buf[sizeof (unsigned int)];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      unsigned long key = 0;\n+\n+      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n+\t{\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t}\n+\n+      if (buf[0] == (_B_EXT | _BX_CLASS))\n+\t{\n+\t  char* class_name;\n+\t  unsigned long version;\n+\n+\t  /* get class */\n+\t  len = objc_read_string (stream, &class_name);\n+\t  (*class) = objc_get_class(class_name);\n+\t  objc_free(class_name);\n+\n+\t  /* register */\n+\t  if (key)\n+\t    hash_add (&stream->stream_table, LONG2PTR(key), *class);\n+\n+\t  objc_read_unsigned_long(stream, &version);\n+\t  hash_add (&stream->class_table, (*class)->name, (void*)version);\n+\t}\n+\n+      else if ((buf[0]&_B_CODE) == _B_UCOMM)\n+\t{\n+\t  if (key)\n+\t    objc_error(nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  (*class) = hash_value_for_key (stream->stream_table, LONG2PTR(key));\n+\t  if (!*class)\n+\t    objc_error(nil, OBJC_ERR_BAD_CLASS,\n+\t\t       \"cannot find class for key %lu\", key);\n+\t}\n+\n+      else\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected class, got opcode %c\", buf[0]);\n+    }\n+  return len;\n+}\n+\n+int\n+objc_read_selector (struct objc_typed_stream* stream, SEL* selector)\n+{\n+  unsigned char buf[sizeof (unsigned int)];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      unsigned long key = 0;\n+\n+      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n+\t{\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t}\n+\n+      if (buf[0] == (_B_EXT|_BX_SEL)) /* selector! */\n+\t{\n+\t  char* selector_name;\n+\n+\t  /* get selector */\n+\t  len = objc_read_string (stream, &selector_name);\n+\t  /* To handle NULL selectors */\n+\t  if (0 == strlen(selector_name))\n+\t    {\n+\t      (*selector) = (SEL)0;\n+\t      return 0;\n+\t    }\n+\t  else \n+\t    (*selector) = sel_get_any_uid(selector_name);\n+\t  objc_free(selector_name);\n+\n+\t  /* register */\n+\t  if (key)\n+\t    hash_add (&stream->stream_table, LONG2PTR(key), (void*)*selector);\n+\t}\n+\n+      else if ((buf[0]&_B_CODE) == _B_UCOMM)\n+\t{\n+\t  if (key)\n+\t    objc_error(nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  (*selector) = hash_value_for_key (stream->stream_table, \n+\t\t\t\t\t    LONG2PTR(key));\n+\t}\n+\n+      else\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected selector, got opcode %c\", buf[0]);\n+    }\n+  return len;\n+}\n+\n+/*\n+** USER LEVEL FUNCTIONS\n+*/\n+\n+/*\n+** Write one object, encoded in TYPE and pointed to by DATA to the\n+** typed stream STREAM.  \n+*/\n+\n+int\n+objc_write_type(TypedStream* stream, const char* type, const void* data)\n+{\n+  switch(*type) {\n+  case _C_ID:\n+    return objc_write_object (stream, *(id*)data);\n+    break;\n+\n+  case _C_CLASS:\n+    return objc_write_class (stream, *(Class*)data);\n+    break;\n+\n+  case _C_SEL:\n+    return objc_write_selector (stream, *(SEL*)data);\n+    break;\n+\n+  case _C_CHR:\n+    return objc_write_char(stream, *(char*)data);\n+    break;\n+    \n+  case _C_UCHR:\n+    return objc_write_unsigned_char(stream, *(unsigned char*)data);\n+    break;\n+\n+  case _C_SHT:\n+    return objc_write_short(stream, *(short*)data);\n+    break;\n+\n+  case _C_USHT:\n+    return objc_write_unsigned_short(stream, *(unsigned short*)data);\n+    break;\n+\n+  case _C_INT:\n+    return objc_write_int(stream, *(int*)data);\n+    break;\n+\n+  case _C_UINT:\n+    return objc_write_unsigned_int(stream, *(unsigned int*)data);\n+    break;\n+\n+  case _C_LNG:\n+    return objc_write_long(stream, *(long*)data);\n+    break;\n+\n+  case _C_ULNG:\n+    return objc_write_unsigned_long(stream, *(unsigned long*)data);\n+    break;\n+\n+  case _C_CHARPTR:\n+    return objc_write_string (stream, *(char**)data, strlen(*(char**)data));\n+    break;\n+\n+  case _C_ATOM:\n+    return objc_write_string_atomic (stream, *(char**)data, \n+\t\t\t\t     strlen(*(char**)data));\n+    break;\n+\n+  case _C_ARY_B:\n+    {\n+      int len = atoi(type+1);\n+      while (isdigit(*++type))\n+\t;\n+      return objc_write_array (stream, type, len, data);\n+    }\n+    break; \n+\n+  case _C_STRUCT_B:\n+    {\n+      int acc_size = 0;\n+      int align;\n+      while (*type != _C_STRUCT_E && *type++ != '=')\n+\t; /* skip \"<name>=\" */\n+      while (*type != _C_STRUCT_E)\n+\t{\n+\t  align = objc_alignof_type (type);       /* padd to alignment */\n+\t  acc_size += ROUND (acc_size, align);\n+\t  objc_write_type (stream, type, ((char*)data)+acc_size);\n+\t  acc_size += objc_sizeof_type (type);   /* add component size */\n+\t  type = objc_skip_typespec (type);\t /* skip component */\n+\t}\n+      return 1;\n+    }\n+\n+  default:\n+    {\n+      objc_error(nil, OBJC_ERR_BAD_TYPE,\n+\t\t \"objc_write_type: cannot parse typespec: %s\\n\", type);\n+      return 0;\n+    }\n+  }\n+}\n+\n+/*\n+** Read one object, encoded in TYPE and pointed to by DATA to the\n+** typed stream STREAM.  DATA specifies the address of the types to\n+** read.  Expected type is checked against the type actually present\n+** on the stream. \n+*/\n+\n+int\n+objc_read_type(TypedStream* stream, const char* type, void* data)\n+{\n+  char c;\n+  switch(c = *type) {\n+  case _C_ID:\n+    return objc_read_object (stream, (id*)data);\n+    break;\n+\n+  case _C_CLASS:\n+    return objc_read_class (stream, (Class*)data);\n+    break;\n+\n+  case _C_SEL:\n+    return objc_read_selector (stream, (SEL*)data);\n+    break;\n+\n+  case _C_CHR:\n+    return objc_read_char (stream, (char*)data);\n+    break;\n+    \n+  case _C_UCHR:\n+    return objc_read_unsigned_char (stream, (unsigned char*)data);\n+    break;\n+\n+  case _C_SHT:\n+    return objc_read_short (stream, (short*)data);\n+    break;\n+\n+  case _C_USHT:\n+    return objc_read_unsigned_short (stream, (unsigned short*)data);\n+    break;\n+\n+  case _C_INT:\n+    return objc_read_int (stream, (int*)data);\n+    break;\n+\n+  case _C_UINT:\n+    return objc_read_unsigned_int (stream, (unsigned int*)data);\n+    break;\n+\n+  case _C_LNG:\n+    return objc_read_long (stream, (long*)data);\n+    break;\n+\n+  case _C_ULNG:\n+    return objc_read_unsigned_long (stream, (unsigned long*)data);\n+    break;\n+\n+  case _C_CHARPTR:\n+  case _C_ATOM:\n+    return objc_read_string (stream, (char**)data);\n+    break;\n+\n+  case _C_ARY_B:\n+    {\n+      int len = atoi(type+1);\n+      while (isdigit(*++type))\n+\t;\n+      return objc_read_array (stream, type, len, data);\n+    }\n+    break; \n+\n+  case _C_STRUCT_B:\n+    {\n+      int acc_size = 0;\n+      int align;\n+      while (*type != _C_STRUCT_E && *type++ != '=')\n+\t; /* skip \"<name>=\" */\n+      while (*type != _C_STRUCT_E)\n+\t{\n+\t  align = objc_alignof_type (type);       /* padd to alignment */\n+\t  acc_size += ROUND (acc_size, align);\n+\t  objc_read_type (stream, type, ((char*)data)+acc_size);\n+\t  acc_size += objc_sizeof_type (type);   /* add component size */\n+\t  type = objc_skip_typespec (type);\t /* skip component */\n+\t}\n+      return 1;\n+    }\n+\n+  default:\n+    {\n+      objc_error(nil, OBJC_ERR_BAD_TYPE,\n+\t\t \"objc_read_type: cannot parse typespec: %s\\n\", type);\n+      return 0;\n+    }\n+  }\n+}\n+\n+/*\n+** Write the object specified by the template TYPE to STREAM.  Last\n+** arguments specify addresses of values to be written.  It might \n+** seem surprising to specify values by address, but this is extremely\n+** convenient for copy-paste with objc_read_types calls.  A more\n+** down-to-the-earth cause for this passing of addresses is that values\n+** of arbitrary size is not well supported in ANSI C for functions with\n+** variable number of arguments.\n+*/\n+\n+int \n+objc_write_types (TypedStream* stream, const char* type, ...)\n+{\n+  va_list args;\n+  const char *c;\n+  int res = 0;\n+\n+  va_start(args, type);\n+\n+  for (c = type; *c; c = objc_skip_typespec (c))\n+    {\n+      switch(*c) {\n+      case _C_ID:\n+\tres = objc_write_object (stream, *va_arg (args, id*));\n+\tbreak;\n+\n+      case _C_CLASS:\n+\tres = objc_write_class (stream, *va_arg(args, Class*));\n+\tbreak;\n+\n+      case _C_SEL:\n+\tres = objc_write_selector (stream, *va_arg(args, SEL*));\n+\tbreak;\n+\t\n+      case _C_CHR:\n+\tres = objc_write_char (stream, *va_arg (args, char*));\n+\tbreak;\n+\t\n+      case _C_UCHR:\n+\tres = objc_write_unsigned_char (stream,\n+\t\t\t\t\t*va_arg (args, unsigned char*));\n+\tbreak;\n+\t\n+      case _C_SHT:\n+\tres = objc_write_short (stream, *va_arg(args, short*));\n+\tbreak;\n+\n+      case _C_USHT:\n+\tres = objc_write_unsigned_short (stream,\n+\t\t\t\t\t *va_arg(args, unsigned short*));\n+\tbreak;\n+\n+      case _C_INT:\n+\tres = objc_write_int(stream, *va_arg(args, int*));\n+\tbreak;\n+\t\n+      case _C_UINT:\n+\tres = objc_write_unsigned_int(stream, *va_arg(args, unsigned int*));\n+\tbreak;\n+\n+      case _C_LNG:\n+\tres = objc_write_long(stream, *va_arg(args, long*));\n+\tbreak;\n+\t\n+      case _C_ULNG:\n+\tres = objc_write_unsigned_long(stream, *va_arg(args, unsigned long*));\n+\tbreak;\n+\n+      case _C_CHARPTR:\n+\t{\n+\t  char** str = va_arg(args, char**);\n+\t  res = objc_write_string (stream, *str, strlen(*str));\n+\t}\n+\tbreak;\n+\n+      case _C_ATOM:\n+\t{\n+\t  char** str = va_arg(args, char**);\n+\t  res = objc_write_string_atomic (stream, *str, strlen(*str));\n+\t}\n+\tbreak;\n+\n+      case _C_ARY_B:\n+\t{\n+\t  int len = atoi(c+1);\n+\t  const char* t = c;\n+\t  while (isdigit(*++t))\n+\t    ;\n+\t  res = objc_write_array (stream, t, len, va_arg(args, void*));\n+\t  t = objc_skip_typespec (t);\n+\t  if (*t != _C_ARY_E)\n+\t    objc_error(nil, OBJC_ERR_BAD_TYPE, \"expected `]', got: %s\", t);\n+\t}\n+\tbreak; \n+\t\n+      default:\n+\tobjc_error(nil, OBJC_ERR_BAD_TYPE, \n+\t\t   \"objc_write_types: cannot parse typespec: %s\\n\", type);\n+      }\n+    }\n+  va_end(args);\n+  return res;\n+}\n+\n+\n+/* \n+** Last arguments specify addresses of values to be read.  Expected\n+** type is checked against the type actually present on the stream. \n+*/\n+\n+int \n+objc_read_types(TypedStream* stream, const char* type, ...)\n+{\n+  va_list args;\n+  const char *c;\n+  int res = 0;\n+\n+  va_start(args, type);\n+\n+  for (c = type; *c; c = objc_skip_typespec(c))\n+    {\n+      switch(*c) {\n+      case _C_ID:\n+\tres = objc_read_object(stream, va_arg(args, id*));\n+\tbreak;\n+\n+      case _C_CLASS:\n+\tres = objc_read_class(stream, va_arg(args, Class*));\n+\tbreak;\n+\n+      case _C_SEL:\n+\tres = objc_read_selector(stream, va_arg(args, SEL*));\n+\tbreak;\n+\t\n+      case _C_CHR:\n+\tres = objc_read_char(stream, va_arg(args, char*));\n+\tbreak;\n+\t\n+      case _C_UCHR:\n+\tres = objc_read_unsigned_char(stream, va_arg(args, unsigned char*));\n+\tbreak;\n+\t\n+      case _C_SHT:\n+\tres = objc_read_short(stream, va_arg(args, short*));\n+\tbreak;\n+\n+      case _C_USHT:\n+\tres = objc_read_unsigned_short(stream, va_arg(args, unsigned short*));\n+\tbreak;\n+\n+      case _C_INT:\n+\tres = objc_read_int(stream, va_arg(args, int*));\n+\tbreak;\n+\t\n+      case _C_UINT:\n+\tres = objc_read_unsigned_int(stream, va_arg(args, unsigned int*));\n+\tbreak;\n+\n+      case _C_LNG:\n+\tres = objc_read_long(stream, va_arg(args, long*));\n+\tbreak;\n+\t\n+      case _C_ULNG:\n+\tres = objc_read_unsigned_long(stream, va_arg(args, unsigned long*));\n+\tbreak;\n+\n+      case _C_CHARPTR:\n+      case _C_ATOM:\n+\t{\n+\t  char** str = va_arg(args, char**);\n+\t  res = objc_read_string (stream, str);\n+\t}\n+\tbreak;\n+\n+      case _C_ARY_B:\n+\t{\n+\t  int len = atoi(c+1);\n+\t  const char* t = c;\n+\t  while (isdigit(*++t))\n+\t    ;\n+\t  res = objc_read_array (stream, t, len, va_arg(args, void*));\n+\t  t = objc_skip_typespec (t);\n+\t  if (*t != _C_ARY_E)\n+\t    objc_error(nil, OBJC_ERR_BAD_TYPE, \"expected `]', got: %s\", t);\n+\t}\n+\tbreak; \n+\t\n+      default:\n+\tobjc_error(nil, OBJC_ERR_BAD_TYPE, \n+\t\t   \"objc_read_types: cannot parse typespec: %s\\n\", type);\n+      }\n+    }\n+  va_end(args);\n+  return res;\n+}\n+\n+/*\n+** Write an array of COUNT elements of TYPE from the memory address DATA.\n+** This is equivalent of objc_write_type (stream, \"[N<type>]\", data)\n+*/\n+\n+int\n+objc_write_array (TypedStream* stream, const char* type,\n+\t\t  int count, const void* data)\n+{\n+  int off = objc_sizeof_type(type);\n+  const char* where = data;\n+\n+  while (count-- > 0)\n+    {\n+      objc_write_type(stream, type, where);\n+      where += off;\n+    }\n+  return 1;\n+}\n+\n+/*\n+** Read an array of COUNT elements of TYPE into the memory address\n+** DATA.  The memory pointed to by data is supposed to be allocated\n+** by the callee.  This is equivalent of \n+**   objc_read_type (stream, \"[N<type>]\", data)\n+*/\n+\n+int\n+objc_read_array (TypedStream* stream, const char* type,\n+\t\t int count, void* data)\n+{\n+  int off = objc_sizeof_type(type);\n+  char* where = (char*)data;\n+\n+  while (count-- > 0)\n+    {\n+      objc_read_type(stream, type, where);\n+      where += off;\n+    }\n+  return 1;\n+}\n+\n+static int \n+__objc_fread(FILE* file, char* data, int len)\n+{\n+  return fread(data, len, 1, file);\n+}\n+\n+static int \n+__objc_fwrite(FILE* file, char* data, int len)\n+{\n+  return fwrite(data, len, 1, file);\n+}\n+\n+static int\n+__objc_feof(FILE* file)\n+{\n+  return feof(file);\n+}\n+\n+static int \n+__objc_no_write(FILE* file, char* data, int len)\n+{\n+  objc_error (nil, OBJC_ERR_NO_WRITE, \"TypedStream not open for writing\");\n+  return 0;\n+}\n+\n+static int \n+__objc_no_read(FILE* file, char* data, int len)\n+{\n+  objc_error (nil, OBJC_ERR_NO_READ, \"TypedStream not open for reading\");\n+  return 0;\n+}\n+\n+static int\n+__objc_read_typed_stream_signature (TypedStream* stream)\n+{\n+  char buffer[80];\n+  int pos = 0;\n+  do\n+    (*stream->read)(stream->physical, buffer+pos, 1);\n+  while (buffer[pos++] != '\\0')\n+    ;\n+  sscanf (buffer, \"GNU TypedStream %d\", &stream->version);\n+  if (stream->version != OBJC_TYPED_STREAM_VERSION)\n+    objc_error (nil, OBJC_ERR_STREAM_VERSION,\n+\t\t\"cannot handle TypedStream version %d\", stream->version);\n+  return 1;\n+}\n+\n+static int\n+__objc_write_typed_stream_signature (TypedStream* stream)\n+{\n+  char buffer[80];\n+  sprintf(buffer, \"GNU TypedStream %d\", OBJC_TYPED_STREAM_VERSION);\n+  stream->version = OBJC_TYPED_STREAM_VERSION;\n+  (*stream->write)(stream->physical, buffer, strlen(buffer)+1);\n+  return 1;\n+}\n+\n+static void __objc_finish_write_root_object(struct objc_typed_stream* stream)\n+{\n+  hash_delete (stream->object_table);\n+  stream->object_table = hash_new(64,\n+\t\t\t\t  (hash_func_type)hash_ptr,\n+\t\t\t\t  (compare_func_type)compare_ptrs);\n+}\n+\n+static void __objc_finish_read_root_object(struct objc_typed_stream* stream)\n+{\n+  node_ptr node;\n+  SEL awake_sel = sel_get_any_uid (\"awake\");\n+  cache_ptr free_list = hash_new (64,\n+\t\t\t\t  (hash_func_type) hash_ptr,\n+\t\t\t\t  (compare_func_type) compare_ptrs);\n+\n+  /* resolve object forward references */\n+  for (node = hash_next (stream->object_refs, NULL); node;\n+       node = hash_next (stream->object_refs, node))\n+    {\n+      struct objc_list* reflist = node->value;\n+      const void* key = node->key;\n+      id object = hash_value_for_key (stream->object_table, key);\n+      while(reflist)\n+\t{\n+\t  *((id*)reflist->head) = object;\n+\t  if (hash_value_for_key (free_list,reflist) == NULL)\n+\t    hash_add (&free_list,reflist,reflist);\n+\n+\t  reflist = reflist->tail;\n+\t}\n+    }\n+    \n+  /* apply __objc_free to all objects stored in free_list */\n+  for (node = hash_next (free_list, NULL); node;\n+       node = hash_next (free_list, node))\n+    objc_free ((void *) node->key);\n+\n+  hash_delete (free_list);\n+\n+  /* empty object reference table */\n+  hash_delete (stream->object_refs);\n+  stream->object_refs = hash_new(8, (hash_func_type)hash_ptr,\n+\t\t\t\t (compare_func_type)compare_ptrs);\n+  \n+  /* call -awake for all objects read  */\n+  if (awake_sel)\n+    {\n+      for (node = hash_next (stream->object_table, NULL); node;\n+\t   node = hash_next (stream->object_table, node))\n+\t{\n+\t  id object = node->value;\n+\t  if (__objc_responds_to (object, awake_sel))\n+\t    (*objc_msg_lookup(object, awake_sel))(object, awake_sel);\n+\t}\n+    }\n+\n+  /* empty object table */\n+  hash_delete (stream->object_table);\n+  stream->object_table = hash_new(64,\n+\t\t\t\t  (hash_func_type)hash_ptr,\n+\t\t\t\t  (compare_func_type)compare_ptrs);\n+}\n+\n+/*\n+** Open the stream PHYSICAL in MODE\n+*/\n+\n+TypedStream* \n+objc_open_typed_stream (FILE* physical, int mode)\n+{\n+  TypedStream* s = (TypedStream*)objc_malloc(sizeof(TypedStream));\n+\n+  s->mode = mode;\n+  s->physical = physical;\n+  s->stream_table = hash_new(64,\n+\t\t\t     (hash_func_type)hash_ptr,\n+\t\t\t     (compare_func_type)compare_ptrs);\n+  s->object_table = hash_new(64,\n+\t\t\t     (hash_func_type)hash_ptr,\n+\t\t\t     (compare_func_type)compare_ptrs);\n+  s->eof = (objc_typed_eof_func)__objc_feof;\n+  s->flush = (objc_typed_flush_func)fflush;\n+  s->writing_root_p = 0;\n+  if (mode == OBJC_READONLY)\n+    {\n+      s->class_table = hash_new(8, (hash_func_type)hash_string,\n+\t\t\t\t(compare_func_type)compare_strings);\n+      s->object_refs = hash_new(8, (hash_func_type)hash_ptr,\n+\t\t\t\t(compare_func_type)compare_ptrs);\n+      s->read = (objc_typed_read_func)__objc_fread;\n+      s->write = (objc_typed_write_func)__objc_no_write;\n+      __objc_read_typed_stream_signature (s);\n+    }\n+  else if (mode == OBJC_WRITEONLY)\n+    {\n+      s->class_table = 0;\n+      s->object_refs = 0;\n+      s->read = (objc_typed_read_func)__objc_no_read;\n+      s->write = (objc_typed_write_func)__objc_fwrite;\n+      __objc_write_typed_stream_signature (s);\n+    }      \n+  else\n+    {\n+      objc_close_typed_stream (s);\n+      return NULL;\n+    }\n+  s->type = OBJC_FILE_STREAM;\n+  return s;\n+}\n+\n+/*\n+** Open the file named by FILE_NAME in MODE\n+*/\n+\n+TypedStream*\n+objc_open_typed_stream_for_file (const char* file_name, int mode)\n+{\n+  FILE* file = NULL;\n+  TypedStream* s;\n+\n+  if (mode == OBJC_READONLY)\n+    file = fopen (file_name, \"r\");\n+  else\n+    file = fopen (file_name, \"w\");\n+\n+  if (file)\n+    {\n+      s = objc_open_typed_stream (file, mode);\n+      if (s)\n+\ts->type |= OBJC_MANAGED_STREAM;\n+      return s;\n+    }\n+  else\n+    return NULL;\n+}\n+\n+/*\n+** Close STREAM freeing the structure it self.  If it was opened with \n+** objc_open_typed_stream_for_file, the file will also be closed.\n+*/\n+\n+void\n+objc_close_typed_stream (TypedStream* stream)\n+{\n+  if (stream->mode == OBJC_READONLY)\n+    {\n+      __objc_finish_read_root_object (stream); /* Just in case... */\n+      hash_delete (stream->class_table);\n+      hash_delete (stream->object_refs);\n+    }\n+\n+  hash_delete (stream->stream_table);\n+  hash_delete (stream->object_table);\n+\n+  if (stream->type == (OBJC_MANAGED_STREAM | OBJC_FILE_STREAM))\n+    fclose ((FILE*)stream->physical);\n+\n+  objc_free(stream);\n+}\n+\n+BOOL\n+objc_end_of_typed_stream (TypedStream* stream)\n+{\n+  return (*stream->eof)(stream->physical);\n+}\n+\n+void\n+objc_flush_typed_stream (TypedStream* stream)\n+{\n+  (*stream->flush)(stream->physical);\n+}\n+\n+long\n+objc_get_stream_class_version (TypedStream* stream, Class class)\n+{\n+  if (stream->class_table)\n+    return PTR2LONG(hash_value_for_key (stream->class_table, class->name));\n+  else\n+    return class_get_version (class);\n+}\n+"}, {"sha": "44aa1b9f98eb9a85bce985d955073a56fd8636ca", "filename": "libobjc/class.c", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fclass.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,358 @@\n+/* GNU Objective C Runtime class related functions\n+   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup and Dennis Glatting.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"runtime.h\"\t\t/* the kitchen sink */\n+#include \"sarray.h\"\n+\n+/* The table of classname->class.  Used for objc_lookup_class and friends */\n+static cache_ptr __objc_class_hash = 0;                 /* !T:MUTEX */\n+\n+/* This is a hook which is called by objc_get_class and \n+   objc_lookup_class if the runtime is not able to find the class.\n+   This may e.g. try to load in the class using dynamic loading */\n+Class (*_objc_lookup_class)(const char* name) = 0;      /* !T:SAFE */\n+\n+\n+/* True when class links has been resolved */     \n+BOOL __objc_class_links_resolved = NO;                  /* !T:UNUSED */\n+\n+\n+/* Initial number of buckets size of class hash table. */\n+#define CLASS_HASH_SIZE 32\n+\n+void __objc_init_class_tables()\n+{\n+  /* Allocate the class hash table */\n+\n+  if(__objc_class_hash)\n+    return;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  __objc_class_hash\n+    =  hash_new (CLASS_HASH_SIZE,\n+\t\t (hash_func_type) hash_string,\n+\t\t (compare_func_type) compare_strings);\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}  \n+\n+/* This function adds a class to the class hash table, and assigns the \n+   class a number, unless it's already known */\n+void\n+__objc_add_class_to_hash(Class class)\n+{\n+  Class h_class;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  /* make sure the table is there */\n+  assert(__objc_class_hash);\n+\n+  /* make sure it's not a meta class */  \n+  assert(CLS_ISCLASS(class));\n+\n+  /* Check to see if the class is already in the hash table.  */\n+  h_class = hash_value_for_key (__objc_class_hash, class->name);\n+  if (!h_class)\n+    {\n+      /* The class isn't in the hash table.  Add the class and assign a class\n+         number.  */\n+      static unsigned int class_number = 1;\n+\n+      CLS_SETNUMBER(class, class_number);\n+      CLS_SETNUMBER(class->class_pointer, class_number);\n+\n+      ++class_number;\n+      hash_add (&__objc_class_hash, class->name, class);\n+    }\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}\n+\n+/* Get the class object for the class named NAME.  If NAME does not\n+   identify a known class, the hook _objc_lookup_class is called.  If\n+   this fails, nil is returned */\n+Class objc_lookup_class (const char* name)\n+{\n+  Class class;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  /* Make sure the class hash table exists.  */\n+  assert (__objc_class_hash);\n+\n+  class = hash_value_for_key (__objc_class_hash, name);\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n+  if (class)\n+    return class;\n+\n+  if (_objc_lookup_class)\n+    return (*_objc_lookup_class)(name);\n+  else\n+    return 0;\n+}\n+\n+/* Get the class object for the class named NAME.  If NAME does not\n+   identify a known class, the hook _objc_lookup_class is called.  If\n+   this fails,  an error message is issued and the system aborts */\n+Class\n+objc_get_class (const char *name)\n+{\n+  Class class;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  /* Make sure the class hash table exists.  */\n+  assert (__objc_class_hash);\n+\n+  class = hash_value_for_key (__objc_class_hash, name);\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n+  if (class)\n+    return class;\n+\n+  if (_objc_lookup_class)\n+    class = (*_objc_lookup_class)(name);\n+\n+  if(class)\n+    return class;\n+  \n+  objc_error(nil, OBJC_ERR_BAD_CLASS, \n+\t     \"objc runtime: cannot find class %s\\n\", name);\n+  return 0;\n+}\n+\n+MetaClass\n+objc_get_meta_class(const char *name)\n+{\n+  return objc_get_class(name)->class_pointer;\n+}\n+\n+/* This function provides a way to enumerate all the classes in the\n+   executable.  Pass *ENUM_STATE == NULL to start the enumeration.  The\n+   function will return 0 when there are no more classes.  \n+   For example: \n+       id class; \n+       void *es = NULL;\n+       while ((class = objc_next_class(&es)))\n+         ... do something with class; \n+*/\n+Class\n+objc_next_class(void **enum_state)\n+{\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  /* make sure the table is there */\n+  assert(__objc_class_hash);\n+\n+  *(node_ptr*)enum_state = \n+    hash_next(__objc_class_hash, *(node_ptr*)enum_state);\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n+  if (*(node_ptr*)enum_state)\n+    return (*(node_ptr*)enum_state)->value;\n+  return (Class)0;\n+}\n+\n+/* Resolve super/subclass links for all classes.  The only thing we \n+   can be sure of is that the class_pointer for class objects point \n+   to the right meta class objects */\n+void __objc_resolve_class_links()\n+{\n+  node_ptr node;\n+  Class object_class = objc_get_class (\"Object\");\n+\n+  assert(object_class);\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  /* Assign subclass links */\n+  for (node = hash_next (__objc_class_hash, NULL); node;\n+       node = hash_next (__objc_class_hash, node))\n+    {\n+      Class class1 = node->value;\n+\n+      /* Make sure we have what we think we have.  */\n+      assert (CLS_ISCLASS(class1));\n+      assert (CLS_ISMETA(class1->class_pointer));\n+\n+      /* The class_pointer of all meta classes point to Object's meta class. */\n+      class1->class_pointer->class_pointer = object_class->class_pointer;\n+\n+      if (!(CLS_ISRESOLV(class1)))\n+        {\n+          CLS_SETRESOLV(class1);\n+          CLS_SETRESOLV(class1->class_pointer);\n+              \n+          if(class1->super_class)\n+            {   \n+              Class a_super_class \n+                = objc_get_class ((char *) class1->super_class);\n+              \n+              assert (a_super_class);\n+              \n+              DEBUG_PRINTF (\"making class connections for: %s\\n\",\n+                            class1->name);\n+              \n+              /* assign subclass links for superclass */\n+              class1->sibling_class = a_super_class->subclass_list;\n+              a_super_class->subclass_list = class1;\n+              \n+              /* Assign subclass links for meta class of superclass */\n+              if (a_super_class->class_pointer)\n+                {\n+                  class1->class_pointer->sibling_class\n+                    = a_super_class->class_pointer->subclass_list;\n+                  a_super_class->class_pointer->subclass_list \n+                    = class1->class_pointer;\n+                }\n+            }\n+          else                  /* a root class, make its meta object */\n+                                /* be a subclass of Object */\n+            {\n+              class1->class_pointer->sibling_class \n+                = object_class->subclass_list;\n+              object_class->subclass_list = class1->class_pointer;\n+            }\n+        }\n+    }\n+\n+  /* Assign superclass links */\n+  for (node = hash_next (__objc_class_hash, NULL); node;\n+       node = hash_next (__objc_class_hash, node))\n+    {\n+      Class class1 = node->value;\n+      Class sub_class;\n+      for (sub_class = class1->subclass_list; sub_class;\n+           sub_class = sub_class->sibling_class)\n+        {\n+          sub_class->super_class = class1;\n+          if(CLS_ISCLASS(sub_class))\n+            sub_class->class_pointer->super_class = class1->class_pointer;\n+        }\n+    }\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}\n+\n+\n+\n+#define CLASSOF(c) ((c)->class_pointer)\n+\n+Class\n+class_pose_as (Class impostor, Class super_class)\n+{\n+  node_ptr node;\n+  Class class1;\n+\n+  if (!CLS_ISRESOLV (impostor))\n+    __objc_resolve_class_links ();\n+\n+  /* preconditions */\n+  assert (impostor);\n+  assert (super_class);\n+  assert (impostor->super_class == super_class);\n+  assert (CLS_ISCLASS (impostor));\n+  assert (CLS_ISCLASS (super_class));\n+  assert (impostor->instance_size == super_class->instance_size);\n+\n+  {\n+    Class *subclass = &(super_class->subclass_list);\n+\n+    /* move subclasses of super_class to impostor */\n+    while (*subclass)\n+      {\n+\tClass nextSub = (*subclass)->sibling_class;\n+\n+\tif (*subclass != impostor)\n+\t  {\n+\t    Class sub = *subclass;\n+\n+\t    /* classes */\n+\t    sub->sibling_class = impostor->subclass_list;\n+\t    sub->super_class = impostor;\n+\t    impostor->subclass_list = sub;\n+\n+\t    /* It will happen that SUB is not a class object if it is \n+\t       the top of the meta class hierarchy chain.  (root\n+\t       meta-class objects inherit their class object)  If that is\n+\t       the case... don't mess with the meta-meta class. */ \n+\t    if (CLS_ISCLASS (sub))\n+\t      {\n+\t\t/* meta classes */\n+\t\tCLASSOF (sub)->sibling_class = \n+\t\t  CLASSOF (impostor)->subclass_list;\n+\t\tCLASSOF (sub)->super_class = CLASSOF (impostor);\n+\t\tCLASSOF (impostor)->subclass_list = CLASSOF (sub);\n+\t      }\n+\t  }\n+\n+\t*subclass = nextSub;\n+      }\n+\n+    /* set subclasses of superclass to be impostor only */\n+    super_class->subclass_list = impostor;\n+    CLASSOF (super_class)->subclass_list = CLASSOF (impostor);\n+    \n+    /* set impostor to have no sibling classes */\n+    impostor->sibling_class = 0;\n+    CLASSOF (impostor)->sibling_class = 0;\n+  }\n+  \n+  /* check relationship of impostor and super_class is kept. */\n+  assert (impostor->super_class == super_class);\n+  assert (CLASSOF (impostor)->super_class == CLASSOF (super_class));\n+\n+  /* This is how to update the lookup table. Regardless of\n+     what the keys of the hashtable is, change all values that are\n+     superclass into impostor. */\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  for (node = hash_next (__objc_class_hash, NULL); node;\n+       node = hash_next (__objc_class_hash, node))\n+    {\n+      class1 = (Class)node->value;\n+      if (class1 == super_class)\n+\t{\n+\t  node->value = impostor; /* change hash table value */\n+\t}\n+    }      \n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n+  /* next, we update the dispatch tables... */\n+  __objc_update_dispatch_table_for_class (CLASSOF (impostor));\n+  __objc_update_dispatch_table_for_class (impostor);\n+\n+  return impostor;\n+}\n+  \n+"}, {"sha": "ab47e9c4bf47caec7b411dffaef5866c5ed28507", "filename": "libobjc/encoding.c", "status": "added", "additions": 912, "deletions": 0, "changes": 912, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fencoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fencoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fencoding.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,912 @@\n+/* Encoding of types for Objective C.\n+   Copyright (C) 1993, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup\n+   Bitfield support by Ovidiu Predescu\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#include \"tconfig.h\"\n+#include \"objc-api.h\"\n+#include \"encoding.h\"\n+\n+#define MAX(X, Y)                    \\\n+  ({ typeof(X) __x = (X), __y = (Y); \\\n+     (__x > __y ? __x : __y); })\n+\n+#define MIN(X, Y)                    \\\n+  ({ typeof(X) __x = (X), __y = (Y); \\\n+     (__x < __y ? __x : __y); })\n+\n+#define ROUND(V, A) \\\n+  ({ typeof(V) __v=(V); typeof(A) __a=(A); \\\n+     __a*((__v+__a-1)/__a); })\n+\n+\n+/* Various hacks for objc_layout_record. These are used by the target\n+   macros. */\n+\n+#define TREE_CODE(TYPE) *TYPE\n+#define RECORD_TYPE     _C_STRUCT_B\n+#define UNION_TYPE      _C_UNION_B\n+#define QUAL_UNION_TYPE _C_UNION_B\n+\n+#define TYPE_FIELDS(TYPE)     objc_skip_typespec (TYPE)\n+\n+#define DECL_MODE(TYPE)         *(TYPE)\n+\n+#define DFmode          _C_DBL\n+\n+\n+\n+static inline int\n+atoi (const char* str)\n+{\n+  int res = 0;\n+  \n+  while (isdigit (*str))\n+    res *= 10, res += (*str++ - '0');\n+\n+  return res;\n+}\n+\n+/*\n+  return the size of an object specified by type \n+*/\n+\n+int\n+objc_sizeof_type (const char* type)\n+{\n+  /* Skip the variable name if any */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  switch(*type) {\n+  case _C_ID:\n+    return sizeof(id);\n+    break;\n+\n+  case _C_CLASS:\n+    return sizeof(Class);\n+    break;\n+\n+  case _C_SEL:\n+    return sizeof(SEL);\n+    break;\n+\n+  case _C_CHR:\n+    return sizeof(char);\n+    break;\n+    \n+  case _C_UCHR:\n+    return sizeof(unsigned char);\n+    break;\n+\n+  case _C_SHT:\n+    return sizeof(short);\n+    break;\n+\n+  case _C_USHT:\n+    return sizeof(unsigned short);\n+    break;\n+\n+  case _C_INT:\n+    return sizeof(int);\n+    break;\n+\n+  case _C_UINT:\n+    return sizeof(unsigned int);\n+    break;\n+\n+  case _C_LNG:\n+    return sizeof(long);\n+    break;\n+\n+  case _C_ULNG:\n+    return sizeof(unsigned long);\n+    break;\n+\n+  case _C_LNG_LNG:\n+    return sizeof(long long);\n+    break;\n+\n+  case _C_ULNG_LNG:\n+    return sizeof(unsigned long long);\n+    break;\n+\n+  case _C_FLT:\n+    return sizeof(float);\n+    break;\n+\n+  case _C_DBL:\n+    return sizeof(double);\n+    break;\n+\n+  case _C_VOID:\n+    return sizeof(void);\n+    break;\n+  case _C_PTR:\n+  case _C_ATOM:\n+  case _C_CHARPTR:\n+    return sizeof(char*);\n+    break;\n+\n+  case _C_ARY_B:\n+    {\n+      int len = atoi(type+1);\n+      while (isdigit(*++type));\n+      return len*objc_aligned_size (type);\n+    }\n+    break; \n+\n+  case _C_BFLD:\n+    {\n+      /* The new encoding of bitfields is: b 'position' 'type' 'size' */\n+      int position, size;\n+      int startByte, endByte;\n+\n+      position = atoi (type + 1);\n+      while (isdigit (*++type));\n+      size = atoi (type + 1);\n+\n+      startByte = position / BITS_PER_UNIT;\n+      endByte = (position + size) / BITS_PER_UNIT;\n+      return endByte - startByte;\n+    }\n+\n+  case _C_STRUCT_B:\n+    {\n+      struct objc_struct_layout layout;\n+      unsigned int size;\n+\n+      objc_layout_structure (type, &layout);\n+      while (objc_layout_structure_next_member (&layout))\n+        /* do nothing */ ;\n+      objc_layout_finish_structure (&layout, &size, NULL);\n+\n+      return size;\n+    }\n+\n+  case _C_UNION_B:\n+    {\n+      int max_size = 0;\n+      while (*type != _C_UNION_E && *type++ != '=') /* do nothing */;\n+      while (*type != _C_UNION_E)\n+\t{\n+\t  /* Skip the variable name if any */\n+\t  if (*type == '\"')\n+\t    {\n+\t      for (type++; *type++ != '\"';)\n+\t\t/* do nothing */;\n+\t    }\n+\t  max_size = MAX (max_size, objc_sizeof_type (type));\n+\t  type = objc_skip_typespec (type);\n+\t}\n+      return max_size;\n+    }\n+    \n+  default:\n+    {\n+      objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+      return 0;\n+    }\n+  }\n+}\n+\n+\n+/*\n+  Return the alignment of an object specified by type \n+*/\n+\n+int\n+objc_alignof_type(const char* type)\n+{\n+  /* Skip the variable name if any */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+  switch(*type) {\n+  case _C_ID:\n+    return __alignof__(id);\n+    break;\n+\n+  case _C_CLASS:\n+    return __alignof__(Class);\n+    break;\n+    \n+  case _C_SEL:\n+    return __alignof__(SEL);\n+    break;\n+\n+  case _C_CHR:\n+    return __alignof__(char);\n+    break;\n+    \n+  case _C_UCHR:\n+    return __alignof__(unsigned char);\n+    break;\n+\n+  case _C_SHT:\n+    return __alignof__(short);\n+    break;\n+\n+  case _C_USHT:\n+    return __alignof__(unsigned short);\n+    break;\n+\n+  case _C_INT:\n+    return __alignof__(int);\n+    break;\n+\n+  case _C_UINT:\n+    return __alignof__(unsigned int);\n+    break;\n+\n+  case _C_LNG:\n+    return __alignof__(long);\n+    break;\n+\n+  case _C_ULNG:\n+    return __alignof__(unsigned long);\n+    break;\n+\n+  case _C_LNG_LNG:\n+    return __alignof__(long long);\n+    break;\n+\n+  case _C_ULNG_LNG:\n+    return __alignof__(unsigned long long);\n+    break;\n+\n+  case _C_FLT:\n+    return __alignof__(float);\n+    break;\n+\n+  case _C_DBL:\n+    return __alignof__(double);\n+    break;\n+\n+  case _C_PTR:\n+  case _C_ATOM:\n+  case _C_CHARPTR:\n+    return __alignof__(char*);\n+    break;\n+\n+  case _C_ARY_B:\n+    while (isdigit(*++type)) /* do nothing */;\n+    return objc_alignof_type (type);\n+\n+  case _C_STRUCT_B:\n+    {\n+      struct objc_struct_layout layout;\n+      unsigned int align;\n+\n+      objc_layout_structure (type, &layout);\n+      while (objc_layout_structure_next_member (&layout))\n+        /* do nothing */;\n+      objc_layout_finish_structure (&layout, NULL, &align);\n+\n+      return align;\n+    }\n+\n+  case _C_UNION_B:\n+    {\n+      int maxalign = 0;\n+      while (*type != _C_UNION_E && *type++ != '=') /* do nothing */;\n+      while (*type != _C_UNION_E)\n+\t{\n+\t  /* Skip the variable name if any */\n+\t  if (*type == '\"')\n+\t    {\n+\t      for (type++; *type++ != '\"';)\n+\t\t/* do nothing */;\n+\t    }\n+\t  maxalign = MAX (maxalign, objc_alignof_type (type));\n+\t  type = objc_skip_typespec (type);\n+\t}\n+      return maxalign;\n+    }\n+\n+  default:\n+    {\n+      objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+      return 0;\n+    }\n+  }\n+}\n+\n+/*\n+  The aligned size if the size rounded up to the nearest alignment.\n+*/\n+\n+int\n+objc_aligned_size (const char* type)\n+{\n+  int size, align;\n+\n+  /* Skip the variable name */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  size = objc_sizeof_type (type);\n+  align = objc_alignof_type (type);\n+\n+  return ROUND (size, align);\n+}\n+\n+/*\n+  The size rounded up to the nearest integral of the wordsize, taken\n+  to be the size of a void*.\n+*/\n+\n+int \n+objc_promoted_size (const char* type)\n+{\n+  int size, wordsize;\n+\n+  /* Skip the variable name */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  size = objc_sizeof_type (type);\n+  wordsize = sizeof (void*);\n+\n+  return ROUND (size, wordsize);\n+}\n+\n+/*\n+  Skip type qualifiers.  These may eventually precede typespecs\n+  occurring in method prototype encodings.\n+*/\n+\n+inline const char*\n+objc_skip_type_qualifiers (const char* type)\n+{\n+  while (*type == _C_CONST\n+\t || *type == _C_IN \n+\t || *type == _C_INOUT\n+\t || *type == _C_OUT \n+\t || *type == _C_BYCOPY\n+\t || *type == _C_ONEWAY\n+\t || *type == _C_GCINVISIBLE)\n+    {\n+      type += 1;\n+    }\n+  return type;\n+}\n+\n+  \n+/*\n+  Skip one typespec element.  If the typespec is prepended by type\n+  qualifiers, these are skipped as well.\n+*/\n+\n+const char* \n+objc_skip_typespec (const char* type)\n+{\n+  /* Skip the variable name if any */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  type = objc_skip_type_qualifiers (type);\n+  \n+  switch (*type) {\n+\n+  case _C_ID:\n+    /* An id may be annotated by the actual type if it is known\n+       with the @\"ClassName\" syntax */\n+\n+    if (*++type != '\"')\n+      return type;\n+    else\n+      {\n+\twhile (*++type != '\"') /* do nothing */;\n+\treturn type + 1;\n+      }\n+\n+    /* The following are one character type codes */\n+  case _C_CLASS:\n+  case _C_SEL:\n+  case _C_CHR:\n+  case _C_UCHR:\n+  case _C_CHARPTR:\n+  case _C_ATOM:\n+  case _C_SHT:\n+  case _C_USHT:\n+  case _C_INT:\n+  case _C_UINT:\n+  case _C_LNG:\n+  case _C_ULNG:\n+  case _C_LNG_LNG:\n+  case _C_ULNG_LNG:\n+  case _C_FLT:\n+  case _C_DBL:\n+  case _C_VOID:\n+  case _C_UNDEF:\n+    return ++type;\n+    break;\n+\n+  case _C_ARY_B:\n+    /* skip digits, typespec and closing ']' */\n+    \n+    while(isdigit(*++type));\n+    type = objc_skip_typespec(type);\n+    if (*type == _C_ARY_E)\n+      return ++type;\n+    else\n+      {\n+\tobjc_error(nil, OBJC_ERR_BAD_TYPE, \"bad array type %s\\n\", type);\n+\treturn 0;\n+      }\n+\n+  case _C_BFLD:\n+    /* The new encoding of bitfields is: b 'position' 'type' 'size' */\n+    while (isdigit (*++type));\t/* skip position */\n+    while (isdigit (*++type));\t/* skip type and size */\n+    return type;\n+\n+  case _C_STRUCT_B:\n+    /* skip name, and elements until closing '}'  */\n+    \n+    while (*type != _C_STRUCT_E && *type++ != '=');\n+    while (*type != _C_STRUCT_E) { type = objc_skip_typespec (type); }\n+    return ++type;\n+\n+  case _C_UNION_B:\n+    /* skip name, and elements until closing ')'  */\n+    \n+    while (*type != _C_UNION_E && *type++ != '=');\n+    while (*type != _C_UNION_E) { type = objc_skip_typespec (type); }\n+    return ++type;\n+\n+  case _C_PTR:\n+    /* Just skip the following typespec */\n+    \n+    return objc_skip_typespec (++type);\n+    \n+  default:\n+    {\n+      objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+      return 0;\n+    }\n+  }\n+}\n+\n+/*\n+  Skip an offset as part of a method encoding.  This is prepended by a\n+  '+' if the argument is passed in registers.\n+*/\n+inline const char* \n+objc_skip_offset (const char* type)\n+{\n+  if (*type == '+') type++;\n+  while(isdigit(*++type));\n+  return type;\n+}\n+\n+/*\n+  Skip an argument specification of a method encoding.\n+*/\n+const char*\n+objc_skip_argspec (const char* type)\n+{\n+  type = objc_skip_typespec (type);\n+  type = objc_skip_offset (type);\n+  return type;\n+}\n+\n+/*\n+  Return the number of arguments that the method MTH expects.\n+  Note that all methods need two implicit arguments `self' and\n+  `_cmd'. \n+*/\n+int\n+method_get_number_of_arguments (struct objc_method* mth)\n+{\n+  int i = 0;\n+  const char* type = mth->method_types;\n+  while (*type)\n+    {\n+      type = objc_skip_argspec (type);\n+      i += 1;\n+    }\n+  return i - 1;\n+}\n+\n+/*\n+  Return the size of the argument block needed on the stack to invoke\n+  the method MTH.  This may be zero, if all arguments are passed in\n+  registers.\n+*/\n+\n+int\n+method_get_sizeof_arguments (struct objc_method* mth)\n+{\n+  const char* type = objc_skip_typespec (mth->method_types);\n+  return atoi (type);\n+}\n+\n+/*\n+  Return a pointer to the next argument of ARGFRAME.  type points to\n+  the last argument.  Typical use of this look like:\n+\n+  {\n+    char *datum, *type; \n+    for (datum = method_get_first_argument (method, argframe, &type);\n+         datum; datum = method_get_next_argument (argframe, &type))\n+      {\n+        unsigned flags = objc_get_type_qualifiers (type);\n+        type = objc_skip_type_qualifiers (type);\n+\tif (*type != _C_PTR)\n+          [portal encodeData: datum ofType: type];\n+\telse\n+\t  {\n+\t    if ((flags & _F_IN) == _F_IN)\n+              [portal encodeData: *(char**)datum ofType: ++type];\n+\t  }\n+      }\n+  }\n+*/  \n+\n+char*\n+method_get_next_argument (arglist_t argframe,\n+\t\t\t  const char **type)\n+{\n+  const char *t = objc_skip_argspec (*type);\n+\n+  if (*t == '\\0')\n+    return 0;\n+\n+  *type = t;\n+  t = objc_skip_typespec (t);\n+\n+  if (*t == '+')\n+    return argframe->arg_regs + atoi (++t);\n+  else\n+    return argframe->arg_ptr + atoi (t);\n+}\n+\n+/*\n+  Return a pointer to the value of the first argument of the method \n+  described in M with the given argumentframe ARGFRAME.  The type\n+  is returned in TYPE.  type must be passed to successive calls of \n+  method_get_next_argument.\n+*/\n+char*\n+method_get_first_argument (struct objc_method* m,\n+\t\t\t   arglist_t argframe, \n+\t\t\t   const char** type)\n+{\n+  *type = m->method_types;\n+  return method_get_next_argument (argframe, type);\n+}\n+\n+/*\n+   Return a pointer to the ARGth argument of the method\n+   M from the frame ARGFRAME.  The type of the argument\n+   is returned in the value-result argument TYPE \n+*/\n+\n+char*\n+method_get_nth_argument (struct objc_method* m,\n+\t\t\t arglist_t argframe, int arg, \n+\t\t\t const char **type)\n+{\n+  const char* t = objc_skip_argspec (m->method_types);\n+\n+  if (arg > method_get_number_of_arguments (m))\n+    return 0;\n+\n+  while (arg--)\n+    t = objc_skip_argspec (t);\n+  \n+  *type = t;\n+  t = objc_skip_typespec (t);\n+\n+  if (*t == '+')\n+    return argframe->arg_regs + atoi (++t);\n+  else\n+    return argframe->arg_ptr + atoi (t);\n+}\n+\n+unsigned\n+objc_get_type_qualifiers (const char* type)\n+{\n+  unsigned res = 0;\n+  BOOL flag = YES;\n+\n+  while (flag)\n+    switch (*type++)\n+      {\n+      case _C_CONST:\tres |= _F_CONST; break;\n+      case _C_IN:\tres |= _F_IN; break;\n+      case _C_INOUT:\tres |= _F_INOUT; break;\n+      case _C_OUT:\tres |= _F_OUT; break;\n+      case _C_BYCOPY:\tres |= _F_BYCOPY; break;\n+      case _C_ONEWAY:\tres |= _F_ONEWAY; break;\n+      case _C_GCINVISIBLE: res |= _F_GCINVISIBLE; break;\n+      default: flag = NO;\n+    }\n+\n+  return res;\n+}\n+\n+\n+/* The following three functions can be used to determine how a\n+   structure is laid out by the compiler. For example:\n+\n+  struct objc_struct_layout layout;\n+  int i;\n+\n+  objc_layout_structure (type, &layout);\n+  while (objc_layout_structure_next_member (&layout))\n+    {\n+      int position, align;\n+      const char *type;\n+\n+      objc_layout_structure_get_info (&layout, &position, &align, &type);\n+      printf (\"element %d has offset %d, alignment %d\\n\",\n+              i++, position, align);\n+    }\n+\n+  These functions are used by objc_sizeof_type and objc_alignof_type\n+  functions to compute the size and alignment of structures. The\n+  previous method of computing the size and alignment of a structure\n+  was not working on some architectures, particulary on AIX, and in\n+  the presence of bitfields inside the structure. */\n+void\n+objc_layout_structure (const char *type,\n+                           struct objc_struct_layout *layout)\n+{\n+  const char *ntype;\n+\n+  if (*type++ != _C_STRUCT_B)\n+    {\n+      objc_error(nil, OBJC_ERR_BAD_TYPE,\n+                 \"record type expected in objc_layout_structure, got %s\\n\",\n+                 type);\n+    }\n+\n+  layout->original_type = type;\n+\n+  /* Skip \"<name>=\" if any. Avoid embedded structures and unions. */\n+  ntype = type;\n+  while (*ntype != _C_STRUCT_E && *ntype != _C_STRUCT_B && *ntype != _C_UNION_B\n+         && *ntype++ != '=')\n+    /* do nothing */;\n+\n+  /* If there's a \"<name>=\", ntype - 1 points to '='; skip the the name */\n+  if (*(ntype - 1) == '=')\n+    type = ntype;\n+\n+  layout->type = type;\n+  layout->prev_type = NULL;\n+  layout->record_size = 0;\n+  layout->record_align = BITS_PER_UNIT;\n+\n+#ifdef STRUCTURE_SIZE_BOUNDARY\n+  layout->record_align = MAX (layout->record_align, STRUCTURE_SIZE_BOUNDARY);\n+#endif\n+}\n+\n+\n+BOOL\n+objc_layout_structure_next_member (struct objc_struct_layout *layout)\n+{\n+  register int known_align = layout->record_size;\n+  register int desired_align = 0;\n+\n+  /* The following are used only if the field is a bitfield */\n+  register const char *bfld_type;\n+  register int bfld_type_size, bfld_type_align, bfld_field_size;\n+\n+  /* The current type without the type qualifiers */\n+  const char *type;\n+\n+#if 1\n+  if (layout->prev_type == NULL)\n+    {\n+      layout->prev_type = layout->type;\n+      layout->type = objc_skip_typespec (layout->prev_type);\n+      return YES;\n+    }\n+#endif\n+\n+  /* Add the size of the previous field to the size of the record.  */\n+  if (layout->prev_type)\n+    {\n+      type = objc_skip_type_qualifiers (layout->prev_type);\n+\n+      if (*type != _C_BFLD)\n+        layout->record_size += objc_sizeof_type (type) * BITS_PER_UNIT;\n+      else {\n+        desired_align = 1;\n+        /* Get the bitfield's type */\n+        for (bfld_type = type + 1;\n+             isdigit(*bfld_type);\n+             bfld_type++)\n+          /* do nothing */;\n+\n+        bfld_type_size = objc_sizeof_type (bfld_type) * BITS_PER_UNIT;\n+        bfld_type_align = objc_alignof_type (bfld_type) * BITS_PER_UNIT;\n+        bfld_field_size = atoi (objc_skip_typespec (bfld_type));\n+        layout->record_size += bfld_field_size;\n+      }\n+    }\n+\n+  if (*layout->type == _C_STRUCT_E)\n+    return NO;\n+\n+  /* Skip the variable name if any */\n+  if (*layout->type == '\"')\n+    {\n+      for (layout->type++; *layout->type++ != '\"';)\n+        /* do nothing */;\n+    }\n+\n+  type = objc_skip_type_qualifiers (layout->type);\n+\n+  if (*type != _C_BFLD)\n+    desired_align = objc_alignof_type(type) * BITS_PER_UNIT;\n+  else\n+    {\n+      desired_align = 1;\n+      /* Skip the bitfield's offset */\n+      for (bfld_type = type + 1; isdigit(*bfld_type); bfld_type++)\n+        /* do nothing */;\n+\n+      bfld_type_size = objc_sizeof_type (bfld_type) * BITS_PER_UNIT;\n+      bfld_type_align = objc_alignof_type (bfld_type) * BITS_PER_UNIT;\n+      bfld_field_size = atoi (objc_skip_typespec (bfld_type));\n+    }\n+\n+#ifdef BIGGEST_FIELD_ALIGNMENT\n+  desired_align = MIN (desired_align, BIGGEST_FIELD_ALIGNMENT);\n+#endif\n+#ifdef ADJUST_FIELD_ALIGN\n+  desired_align = ADJUST_FIELD_ALIGN (type, desired_align);\n+#endif\n+\n+  /* Record must have at least as much alignment as any field.\n+     Otherwise, the alignment of the field within the record\n+     is meaningless.  */\n+#ifndef PCC_BITFIELD_TYPE_MATTERS\n+  layout->record_align = MAX (layout->record_align, desired_align);\n+#else\n+  if (*type == _C_BFLD)\n+    {\n+      /* For these machines, a zero-length field does not\n+         affect the alignment of the structure as a whole.\n+         It does, however, affect the alignment of the next field\n+         within the structure.  */\n+      if (bfld_field_size)\n+        layout->record_align = MAX (layout->record_align, desired_align);\n+      else\n+        desired_align = objc_alignof_type (bfld_type) * BITS_PER_UNIT;\n+\n+      /* A named bit field of declared type `int'\n+         forces the entire structure to have `int' alignment.\n+         Q1: How is encoded this thing and how to check for it?\n+         Q2: How to determine maximum_field_alignment at runtime? */\n+\n+/*\t  if (DECL_NAME (field) != 0) */\n+      {\n+        int type_align = bfld_type_align;\n+#if 0\n+        if (maximum_field_alignment != 0)\n+          type_align = MIN (type_align, maximum_field_alignment);\n+        else if (DECL_PACKED (field))\n+          type_align = MIN (type_align, BITS_PER_UNIT);\n+#endif\n+\n+        layout->record_align = MAX (layout->record_align, type_align);\n+      }\n+    }\n+  else\n+    layout->record_align = MAX (layout->record_align, desired_align);\n+#endif\n+\n+  /* Does this field automatically have alignment it needs\n+     by virtue of the fields that precede it and the record's\n+     own alignment?  */\n+\n+  if (*type == _C_BFLD)\n+    layout->record_size = atoi (type + 1);\n+  else if (layout->record_size % desired_align != 0)\n+    {\n+      /* No, we need to skip space before this field.\n+         Bump the cumulative size to multiple of field alignment.  */\n+      layout->record_size = ROUND (layout->record_size, desired_align);\n+    }\n+  \n+  /* Jump to the next field in record. */\n+\n+  layout->prev_type = layout->type;\n+  layout->type = objc_skip_typespec (layout->type);      /* skip component */\n+\n+  return YES;\n+}\n+\n+\n+void objc_layout_finish_structure (struct objc_struct_layout *layout,\n+                                   unsigned int *size,\n+                                   unsigned int *align)\n+{\n+  if (layout->type && *layout->type == _C_STRUCT_E)\n+    {\n+      /* Work out the alignment of the record as one expression and store\n+         in the record type.  Round it up to a multiple of the record's\n+         alignment. */\n+\n+#ifdef ROUND_TYPE_ALIGN\n+      layout->record_align = ROUND_TYPE_ALIGN (layout->original_type,\n+                                               1,\n+                                               layout->record_align);\n+#else\n+      layout->record_align = MAX (1, layout->record_align);\n+#endif\n+\n+#ifdef ROUND_TYPE_SIZE\n+      layout->record_size = ROUND_TYPE_SIZE (layout->original_type,\n+                                             layout->record_size,\n+                                             layout->record_align);\n+#else\n+      /* Round the size up to be a multiple of the required alignment */\n+      layout->record_size = ROUND (layout->record_size, layout->record_align);\n+#endif\n+\n+      layout->type = NULL;\n+    }\n+  if (size)\n+    *size = layout->record_size / BITS_PER_UNIT;\n+  if (align)\n+    *align = layout->record_align / BITS_PER_UNIT;\n+}\n+\n+\n+void objc_layout_structure_get_info (struct objc_struct_layout *layout,\n+                                     unsigned int *offset,\n+                                     unsigned int *align,\n+                                     const char **type)\n+{\n+  if (offset)\n+    *offset = layout->record_size / BITS_PER_UNIT;\n+  if (align)\n+    *align = layout->record_align / BITS_PER_UNIT;\n+  if (type)\n+    *type = layout->prev_type;\n+}"}, {"sha": "cbbc8de7ef5ce76d8ad970f6c550264d4dfd7ba7", "filename": "libobjc/encoding.h", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fencoding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fencoding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fencoding.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,97 @@\n+/* Encoding of types for Objective C.\n+   Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __encoding_INCLUDE_GNU\n+#define __encoding_INCLUDE_GNU\n+\n+#include <ctype.h>\n+#include \"objc/objc-api.h\"\n+\n+#define _C_CONST\t'r'\n+#define _C_IN\t\t'n'\n+#define _C_INOUT\t'N'\n+#define _C_OUT      \t'o'\n+#define _C_BYCOPY\t'O'\n+#define _C_ONEWAY\t'V'\n+#define _C_GCINVISIBLE\t'!'\n+\n+#define _F_CONST\t0x01\n+#define _F_IN\t\t0x01\n+#define _F_OUT\t\t0x02\n+#define _F_INOUT\t0x03\n+#define _F_BYCOPY\t0x04\n+#define _F_ONEWAY\t0x08\n+#define _F_GCINVISIBLE\t0x10\n+\n+int objc_aligned_size (const char* type);\n+int objc_sizeof_type (const char* type);\n+int objc_alignof_type (const char* type);\n+int objc_aligned_size (const char* type);\n+int objc_promoted_size (const char* type);\n+\n+const char* objc_skip_type_qualifiers (const char* type);\n+const char* objc_skip_typespec (const char* type);\n+const char* objc_skip_offset (const char* type);\n+const char* objc_skip_argspec (const char* type);\n+int method_get_number_of_arguments (struct objc_method*);\n+int method_get_sizeof_arguments (struct objc_method*);\n+\n+char* method_get_first_argument (struct objc_method*,\n+\t\t\t\t arglist_t argframe, \n+\t\t\t\t const char** type);\n+char* method_get_next_argument (arglist_t argframe, \n+\t\t\t\tconst char **type);\n+char* method_get_nth_argument (struct objc_method* m, \n+\t\t\t       arglist_t argframe,\n+\t\t\t       int arg, \n+\t\t\t       const char **type);\n+\n+unsigned objc_get_type_qualifiers (const char* type);\n+\n+\n+struct objc_struct_layout \n+{\n+  const char *original_type;\n+  const char *type;\n+  const char *prev_type;\n+  unsigned int record_size;\n+  unsigned int record_align;\n+};\n+\n+void objc_layout_structure (const char *type,\n+                            struct objc_struct_layout *layout);\n+BOOL  objc_layout_structure_next_member (struct objc_struct_layout *layout);\n+void objc_layout_finish_structure (struct objc_struct_layout *layout,\n+                                   unsigned int *size,\n+                                   unsigned int *align);\n+void objc_layout_structure_get_info (struct objc_struct_layout *layout,\n+                                     unsigned int *offset,\n+                                     unsigned int *align,\n+                                     const char **type);\n+\n+#endif /* __encoding_INCLUDE_GNU */"}, {"sha": "8abf493e20a8106389ebc1e7c794b982ba3b1d6a", "filename": "libobjc/gc.c", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fgc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fgc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fgc.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,458 @@\n+/* Basic data types for Objective C.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Contributed by Ovidiu Predescu.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#include \"../tconfig.h\"\n+#include \"objc.h\"\n+#include \"encoding.h\"\n+\n+#include <assert.h>\n+#include <string.h>\n+\n+#if OBJC_WITH_GC\n+\n+#include <gc.h>\n+\n+/* gc_typed.h uses the following but doesn't declare them */\n+typedef GC_word word;\n+typedef GC_signed_word signed_word;\n+\n+#if BITS_PER_WORD == 32\n+# define LOGWL\t5\n+# define modWORDSZ(n) ((n) & 0x1f)        /* n mod size of word\t    */\n+#endif\n+\n+#if BITS_PER_WORD == 64\n+# define LOGWL 6\n+# define modWORDSZ(n) ((n) & 0x3f)        /* n mod size of word\t    */\n+#endif\n+\n+#define divWORDSZ(n) ((n) >> LOGWL)\t   /* divide n by size of word      */\n+\n+#include <gc_typed.h>\n+\n+/* The following functions set up in `mask` the corresponding pointers.\n+   The offset is incremented with the size of the type.  */\n+\n+#define ROUND(V, A) \\\n+  ({ typeof(V) __v=(V); typeof(A) __a=(A); \\\n+     __a*((__v+__a-1)/__a); })\n+\n+#define SET_BIT_FOR_OFFSET(mask, offset) \\\n+  GC_set_bit(mask, offset / sizeof (void*))\n+\n+/* Some prototypes */\n+static void\n+__objc_gc_setup_struct (GC_bitmap mask, const char *type, int offset);\n+static void\n+__objc_gc_setup_union (GC_bitmap mask, const char *type, int offset);\n+\n+\n+static void\n+__objc_gc_setup_array (GC_bitmap mask, const char *type, int offset)\n+{\n+  int i, len = atoi(type + 1);\n+\n+  while (isdigit(*++type))\n+    /* do nothing */;\t\t/* skip the size of the array */\n+\n+  switch (*type) {\n+  case _C_ARY_B:\n+    for (i = 0; i < len; i++)\n+      __objc_gc_setup_array (mask, type, offset);\n+    break;\n+\n+  case _C_STRUCT_B:\n+    for (i = 0; i < len; i++)\n+      __objc_gc_setup_struct (mask, type, offset);\n+    break;\n+\n+  case _C_UNION_B:\n+    for (i = 0; i < len; i++)\n+      __objc_gc_setup_union (mask, type, offset);\n+    break;\n+\n+  default:\n+    break;\n+  }\n+}\n+\n+static void\n+__objc_gc_setup_struct (GC_bitmap mask, const char *type, int offset)\n+{\n+  struct objc_struct_layout layout;\n+  unsigned int position;\n+  const char *mtype;\n+\n+  objc_layout_structure (type, &layout);\n+\n+  while (objc_layout_structure_next_member (&layout))\n+    {\n+      BOOL gc_invisible = NO;\n+\n+      objc_layout_structure_get_info (&layout, &position, NULL, &mtype);\n+\n+      /* Skip the variable name */\n+      if (*mtype == '\"')\n+\t{\n+\t  for (mtype++; *mtype++ != '\"';)\n+\t    /* do nothing */;\n+\t}\n+\n+      if (*mtype == _C_GCINVISIBLE)\n+\t{\n+\t  gc_invisible = YES;\n+\t  mtype++;\n+\t}\n+\n+      /* Add to position the offset of this structure */\n+      position += offset;\n+\n+      switch (*mtype) {\n+      case _C_ID:\n+      case _C_CLASS:\n+      case _C_SEL:\n+      case _C_PTR:\n+      case _C_CHARPTR:\n+      case _C_ATOM:\n+\tif (!gc_invisible)\n+\t  SET_BIT_FOR_OFFSET(mask, position);\n+\tbreak;\n+\n+      case _C_ARY_B:\n+\t__objc_gc_setup_array (mask, mtype, position);\n+\tbreak;\n+\n+      case _C_STRUCT_B:\n+\t__objc_gc_setup_struct (mask, mtype, position);\n+\tbreak;\n+\n+      case _C_UNION_B:\n+\t__objc_gc_setup_union (mask, mtype, position);\n+\tbreak;\n+\n+      default:\n+        break;\n+      }\n+    }\n+}\n+\n+static void\n+__objc_gc_setup_union (GC_bitmap mask, const char *type, int offset)\n+{\n+  /* Sub-optimal, quick implementation: assume the union is made of\n+     pointers, set up the mask accordingly. */\n+\n+  int i, size, align;\n+\n+  /* Skip the variable name */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  size = objc_sizeof_type (type);\n+  align = objc_alignof_type (type);\n+\n+  offset = ROUND(offset, align);\n+  for (i = 0; i < size; i += sizeof (void*))\n+    {\n+      SET_BIT_FOR_OFFSET(mask, offset);\n+      offset += sizeof (void*);\n+    }\n+}\n+\n+\n+/* Iterates over the types in the structure that represents the class\n+   encoding and sets the bits in mask according to each ivar type.  */\n+static void\n+__objc_gc_type_description_from_type (GC_bitmap mask, const char *type)\n+{\n+  struct objc_struct_layout layout;\n+  unsigned int offset, align;\n+  const char *ivar_type;\n+\n+  objc_layout_structure (type, &layout);\n+\n+  while (objc_layout_structure_next_member (&layout))\n+    {\n+      BOOL gc_invisible = NO;\n+\n+      objc_layout_structure_get_info (&layout, &offset, &align, &ivar_type);\n+\n+      /* Skip the variable name */\n+      if (*ivar_type == '\"')\n+\t{\n+\t  for (ivar_type++; *ivar_type++ != '\"';)\n+\t    /* do nothing */;\n+\t}\n+\n+      if (*ivar_type == _C_GCINVISIBLE)\n+\t{\n+\t  gc_invisible = YES;\n+\t  ivar_type++;\n+\t}\n+\n+      switch (*ivar_type) {\n+      case _C_ID:\n+      case _C_CLASS:\n+      case _C_SEL:\n+      case _C_PTR:\n+      case _C_CHARPTR:\n+        if (!gc_invisible)\n+          SET_BIT_FOR_OFFSET(mask, offset);\n+\tbreak;\n+\n+      case _C_ARY_B:\n+\t__objc_gc_setup_array (mask, ivar_type, offset);\n+\tbreak;\n+\n+      case _C_STRUCT_B:\n+\t__objc_gc_setup_struct (mask, ivar_type, offset);\n+\tbreak;\n+\n+      case _C_UNION_B:\n+\t__objc_gc_setup_union (mask, ivar_type, offset);\n+\tbreak;\n+\n+      default:\n+        break;\n+      }\n+    }\n+}\n+\n+/* Computes in *type the full type encoding of this class including\n+   its super classes. '*size' gives the total number of bytes allocated\n+   into *type, '*current' the number of bytes used so far by the\n+   encoding. */\n+static void\n+__objc_class_structure_encoding (Class class, char **type, int *size,\n+                                 int *current)\n+{\n+  int i, ivar_count;\n+  struct objc_ivar_list* ivars;\n+\n+  if (!class)\n+    {\n+      strcat (*type, \"{\");\n+      *current++;\n+      return;\n+    }\n+\n+  /* Add the type encodings of the super classes */\n+  __objc_class_structure_encoding (class->super_class, type, size, current);\n+\n+  ivars = class->ivars;\n+  if (!ivars)\n+    return;\n+\n+  ivar_count = ivars->ivar_count;\n+\n+  for (i = 0; i < ivar_count; i++)\n+    {\n+      struct objc_ivar *ivar = &(ivars->ivar_list[i]);\n+      const char *ivar_type = ivar->ivar_type;\n+      int len = strlen (ivar_type);\n+\n+      if (*current + len + 1 >= *size)\n+        {\n+          /* Increase the size of the encoding string so that it\n+             contains this ivar's type. */\n+          *size = ROUND(*current + len + 1, 10);\n+          *type = objc_realloc (*type, *size);\n+        }\n+      strcat (*type + *current, ivar_type);\n+      *current += len;\n+    }\n+}\n+\n+\n+/* Allocates the memory that will hold the type description for class\n+   and calls the __objc_class_structure_encoding that generates this\n+   value. */\n+void\n+__objc_generate_gc_type_description (Class class)\n+{\n+  GC_bitmap mask;\n+  int bits_no, size;\n+  int type_size = 10, current;\n+  char *class_structure_type;\n+\n+  if (!CLS_ISCLASS(class))\n+    return;\n+\n+  /* We have to create a mask in which each bit counts for a pointer member.\n+     We take into consideration all the non-pointer instance variables and we\n+     round them up to the alignment. */\n+\n+  /* The number of bits in the mask is the size of an instance in bytes divided\n+     by the size of a pointer. */\n+  bits_no = (ROUND(class_get_instance_size (class), sizeof(void*))\n+             / sizeof (void*));\n+  size = ROUND(bits_no, BITS_PER_WORD) / BITS_PER_WORD;\n+  mask = objc_atomic_malloc (size * sizeof (int));\n+  memset (mask, 0, size * sizeof (int));\n+\n+  class_structure_type = objc_atomic_malloc (type_size);\n+  *class_structure_type = current = 0;\n+  __objc_class_structure_encoding (class, &class_structure_type,\n+                                   &type_size, &current);\n+  if (current + 1 == type_size)\n+    class_structure_type = objc_realloc (class_structure_type, ++type_size);\n+  strcat (class_structure_type + current, \"}\");\n+//  printf (\"type description for '%s' is %s\\n\", class->name, class_structure_type);\n+  \n+  __objc_gc_type_description_from_type (mask, class_structure_type);\n+  objc_free (class_structure_type);\n+\n+#define DEBUG 1\n+#ifdef DEBUG\n+  printf (\"  mask for '%s', type '%s' (bits %d, mask size %d) is:\",\n+\t  class_structure_type, class->name, bits_no, size);\n+  {\n+    int i;\n+    for (i = 0; i < size; i++)\n+      printf (\" %lx\", mask[i]);\n+  }\n+  puts (\"\");\n+#endif\n+\n+  class->gc_object_type = (void*)GC_make_descriptor (mask, bits_no);\n+}\n+\n+\n+/* Returns YES if type denotes a pointer type, NO otherwise */\n+static inline BOOL\n+__objc_ivar_pointer (const char *type)\n+{\n+  type = objc_skip_type_qualifiers (type);\n+\n+  return (*type == _C_ID\n+          || *type == _C_CLASS\n+          || *type == _C_SEL\n+          || *type == _C_PTR\n+          || *type == _C_CHARPTR\n+          || *type == _C_ATOM);\n+}\n+\n+\n+/* Mark the instance variable whose name is given by ivarname as a\n+   weak pointer (a pointer hidden to the garbage collector) if\n+   gc_invisible is true. If gc_invisible is false it unmarks the\n+   instance variable and makes it a normal pointer, visible to the\n+   garbage collector.\n+\n+   This operation only makes sense on instance variables that are\n+   pointers.  */\n+void\n+class_ivar_set_gcinvisible (Class class, const char* ivarname,\n+                            BOOL gc_invisible)\n+{\n+  int i, ivar_count;\n+  struct objc_ivar_list* ivars;\n+\n+  if (!class || !ivarname)\n+    return;\n+\n+  ivars = class->ivars;\n+  if (!ivars)\n+    return;\n+\n+  ivar_count = ivars->ivar_count;\n+\n+  for (i = 0; i < ivar_count; i++)\n+    {\n+      struct objc_ivar *ivar = &(ivars->ivar_list[i]);\n+      const char *type;\n+\n+      if (!ivar->ivar_name || strcmp (ivar->ivar_name, ivarname))\n+\tcontinue;\n+\n+      assert (ivar->ivar_type);\n+      type = ivar->ivar_type;\n+\n+      /* Skip the variable name */\n+      if (*type == '\"')\n+\t{\n+\t  for (type++; *type++ != '\"';)\n+\t    /* do nothing */;\n+\t}\n+\n+      if (*type == _C_GCINVISIBLE)\n+\t{\n+\t  char *new_type;\n+\n+\t  if (gc_invisible || !__objc_ivar_pointer (type))\n+\t    return;\t/* The type of the variable already matches the\n+\t\t\t   requested gc_invisible type */\n+\n+\t  /* The variable is gc_invisible and we have to reverse it */\n+\t  new_type = objc_atomic_malloc (strlen (ivar->ivar_type));\n+\t  strncpy (new_type, ivar->ivar_type,\n+\t\t   (size_t)(type - ivar->ivar_type));\n+\t  strcat (new_type, type + 1);\n+\t  ivar->ivar_type = new_type;\n+\t}\n+      else\n+\t{\n+\t  char *new_type;\n+\n+\t  if (!gc_invisible || !__objc_ivar_pointer (type))\n+\t    return;\t/* The type of the variable already matches the\n+\t\t\t   requested gc_invisible type */\n+\n+\t  /* The variable is gc visible and we have to make it gc_invisible */\n+\t  new_type = objc_malloc (strlen (ivar->ivar_type) + 2);\n+\t  strncpy (new_type, ivar->ivar_type,\n+\t\t   (size_t)(type - ivar->ivar_type));\n+\t  strcat (new_type, \"!\");\n+\t  strcat (new_type, type);\n+\t  ivar->ivar_type = new_type;\n+\t}\n+\n+      __objc_generate_gc_type_description (class);\n+      return;\n+    }\n+\n+  /* Search the instance variable in the superclasses */\n+  class_ivar_set_gcinvisible (class->super_class, ivarname, gc_invisible);\n+}\n+\n+#else /* !OBJC_WITH_GC */\n+\n+void\n+__objc_generate_gc_type_description (Class class)\n+{\n+}\n+\n+void class_ivar_set_gcinvisible (Class class,\n+\t\t\t\t const char* ivarname,\n+\t\t\t\t BOOL gc_invisible)\n+{\n+}\n+\n+#endif /* OBJC_WITH_GC */"}, {"sha": "7534330fa1c786fc425f6c68d3c650f00a1e7092", "filename": "libobjc/hash.c", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fhash.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,283 @@\n+/* Hash tables for Objective C internal structures\n+   Copyright (C) 1993, 1996, 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#include \"assert.h\"\n+\n+#include \"objc/hash.h\"\n+\n+#include \"runtime.h\"\t\t/* for DEBUG_PRINTF */\n+\n+/* These two macros determine when a hash table is full and\n+   by how much it should be expanded respectively.\n+\n+   These equations are percentages.  */\n+#define FULLNESS(cache) \\\n+   ((((cache)->size * 75) / 100) <= (cache)->used)\n+#define EXPANSION(cache) \\\n+  ((cache)->size * 2)\n+\n+cache_ptr\n+hash_new (unsigned int size, hash_func_type hash_func,\n+\t  compare_func_type compare_func)\n+{\n+  cache_ptr cache;\n+\n+  /* Pass me a value greater than 0 and a power of 2.  */\n+  assert (size);\n+  assert (!(size & (size - 1)));\n+\n+  /* Allocate the cache structure.  calloc insures\n+     its initialization for default values.  */\n+  cache = (cache_ptr) objc_calloc (1, sizeof (struct cache));\n+  assert (cache);\n+\n+  /* Allocate the array of buckets for the cache.\n+     calloc initializes all of the pointers to NULL.  */\n+  cache->node_table\n+    = (node_ptr *) objc_calloc (size, sizeof (node_ptr));\n+  assert (cache->node_table);\n+\n+  cache->size  = size;\n+\n+  /* This should work for all processor architectures? */\n+  cache->mask = (size - 1);\n+\t\n+  /* Store the hashing function so that codes can be computed.  */\n+  cache->hash_func = hash_func;\n+\n+  /* Store the function that compares hash keys to\n+     determine if they are equal.  */\n+  cache->compare_func = compare_func;\n+\n+  return cache;\n+}\n+\n+\n+void\n+hash_delete (cache_ptr cache)\n+{\n+  node_ptr node;\n+  node_ptr next_node;\n+  unsigned int i;\n+\n+  /* Purge all key/value pairs from the table.  */\n+  /* Step through the nodes one by one and remove every node WITHOUT\n+     using hash_next. this makes hash_delete much more efficient. */\n+  for (i = 0;i < cache->size;i++) {\n+    if ((node = cache->node_table[i])) {\n+      /* an entry in the hash table has been found, now step through the\n+\t nodes next in the list and free them. */\n+      while ((next_node = node->next)) {\n+\thash_remove (cache,node->key);\n+\tnode = next_node;\n+      }\n+\n+      hash_remove (cache,node->key);\n+    }\n+  }\n+\n+  /* Release the array of nodes and the cache itself.  */\n+  objc_free(cache->node_table);\n+  objc_free(cache);\n+}\n+\n+\n+void\n+hash_add (cache_ptr *cachep, const void *key, void *value)\n+{\n+  size_t indx = (*(*cachep)->hash_func)(*cachep, key);\n+  node_ptr node = (node_ptr) objc_calloc (1, sizeof (struct cache_node));\n+\n+\n+  assert (node);\n+\n+  /* Initialize the new node.  */\n+  node->key    = key;\n+  node->value  = value;\n+  node->next  = (*cachep)->node_table[indx];\n+\n+  /* Debugging.\n+     Check the list for another key.  */\n+#ifdef DEBUG\n+  { node_ptr node1 = (*cachep)->node_table[indx];\n+\n+    while (node1) {\n+\n+      assert (node1->key != key);\n+      node1 = node1->next;\n+    }\n+  }\n+#endif\n+\n+  /* Install the node as the first element on the list.  */\n+  (*cachep)->node_table[indx] = node;\n+\n+  /* Bump the number of entries in the cache.  */\n+  ++(*cachep)->used;\n+\n+  /* Check the hash table's fullness.   We're going\n+     to expand if it is above the fullness level.  */\n+  if (FULLNESS (*cachep)) {\n+\n+    /* The hash table has reached its fullness level.  Time to\n+       expand it.\n+\n+       I'm using a slow method here but is built on other\n+       primitive functions thereby increasing its\n+       correctness.  */\n+    node_ptr node1 = NULL;\n+    cache_ptr new = hash_new (EXPANSION (*cachep),\n+\t\t\t      (*cachep)->hash_func,\n+\t\t\t      (*cachep)->compare_func);\n+\n+    DEBUG_PRINTF (\"Expanding cache %#x from %d to %d\\n\",\n+\t\t  *cachep, (*cachep)->size, new->size);\n+\n+    /* Copy the nodes from the first hash table to the new one.  */\n+    while ((node1 = hash_next (*cachep, node1)))\n+      hash_add (&new, node1->key, node1->value);\n+\n+    /* Trash the old cache.  */\n+    hash_delete (*cachep);\n+\n+    /* Return a pointer to the new hash table.  */\n+    *cachep = new;\n+  }\n+}\n+\n+\n+void\n+hash_remove (cache_ptr cache, const void *key)\n+{\n+  size_t indx = (*cache->hash_func)(cache, key);\n+  node_ptr node = cache->node_table[indx];\n+\n+\n+  /* We assume there is an entry in the table.  Error if it is not.  */\n+  assert (node);\n+\n+  /* Special case.  First element is the key/value pair to be removed.  */\n+  if ((*cache->compare_func)(node->key, key)) {\n+    cache->node_table[indx] = node->next;\n+    objc_free(node);\n+  } else {\n+\n+    /* Otherwise, find the hash entry.  */\n+    node_ptr prev = node;\n+    BOOL removed = NO;\n+\n+    do {\n+\n+      if ((*cache->compare_func)(node->key, key)) {\n+        prev->next = node->next, removed = YES;\n+        objc_free(node);\n+      } else\n+        prev = node, node = node->next;\n+    } while (!removed && node);\n+    assert (removed);\n+  }\n+\n+  /* Decrement the number of entries in the hash table.  */\n+  --cache->used;\n+}\n+\n+\n+node_ptr\n+hash_next (cache_ptr cache, node_ptr node)\n+{\n+  /* If the scan is being started then reset the last node\n+     visitied pointer and bucket index.  */\n+  if (!node)\n+    cache->last_bucket  = 0;\n+\n+  /* If there is a node visited last then check for another\n+     entry in the same bucket;  Otherwise step to the next bucket.  */\n+  if (node) {\n+    if (node->next)\n+      /* There is a node which follows the last node\n+\t returned.  Step to that node and retun it.  */\n+      return node->next;\n+    else\n+      ++cache->last_bucket;\n+  }\n+\n+  /* If the list isn't exhausted then search the buckets for\n+     other nodes.  */\n+  if (cache->last_bucket < cache->size) {\n+    /*  Scan the remainder of the buckets looking for an entry\n+\tat the head of the list.  Return the first item found.  */\n+    while (cache->last_bucket < cache->size)\n+      if (cache->node_table[cache->last_bucket])\n+        return cache->node_table[cache->last_bucket];\n+      else\n+        ++cache->last_bucket;\n+\n+    /* No further nodes were found in the hash table.  */\n+    return NULL;\n+  } else\n+    return NULL;\n+}\n+\n+\n+/* Given KEY, return corresponding value for it in CACHE.\n+   Return NULL if the KEY is not recorded.  */\n+\n+void *\n+hash_value_for_key (cache_ptr cache, const void *key)\n+{\n+  node_ptr node = cache->node_table[(*cache->hash_func)(cache, key)];\n+  void *retval = NULL;\n+\n+  if (node)\n+    do {\n+      if ((*cache->compare_func)(node->key, key)) {\n+        retval = node->value;\n+              break;\n+      } else\n+        node = node->next;\n+    } while (!retval && node);\n+\n+  return retval;\n+}\n+\n+/* Given KEY, return YES if it exists in the CACHE.\n+   Return NO if it does not */\n+\n+BOOL\n+hash_is_key_in_hash (cache_ptr cache, const void *key)\n+{\n+  node_ptr node = cache->node_table[(*cache->hash_func)(cache, key)];\n+\n+  if (node)\n+    do {\n+      if ((*cache->compare_func)(node->key, key))\n+\t  return YES;\n+      else\n+        node = node->next;\n+    } while (node);\n+\n+  return NO;\n+}"}, {"sha": "bddb791c820ca156df9aa6a271e51360353aad09", "filename": "libobjc/hash.h", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fhash.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,206 @@\n+/* Hash tables for Objective C method dispatch.\n+   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+\n+#ifndef __hash_INCLUDE_GNU\n+#define __hash_INCLUDE_GNU\n+\n+#include <stddef.h>\n+#include <objc/objc.h>\n+\n+/*\n+ * This data structure is used to hold items\n+ *  stored in a hash table.  Each node holds \n+ *  a key/value pair.\n+ *\n+ * Items in the cache are really of type void *.\n+ */\n+typedef struct cache_node\n+{\n+  struct cache_node *next;\t/* Pointer to next entry on the list.\n+\t\t\t\t   NULL indicates end of list. */\n+  const void *key;\t\t/* Key used to locate the value.  Used\n+\t\t\t\t   to locate value when more than one\n+\t\t\t\t   key computes the same hash\n+\t\t\t\t   value. */\n+  void *value;\t\t\t/* Value stored for the key. */\n+} *node_ptr;\n+\n+\n+/*\n+ * This data type is the function that computes a hash code given a key.\n+ * Therefore, the key can be a pointer to anything and the function specific\n+ * to the key type. \n+ *\n+ * Unfortunately there is a mutual data structure reference problem with this\n+ * typedef.  Therefore, to remove compiler warnings the functions passed to\n+ * hash_new will have to be casted to this type. \n+ */\n+typedef unsigned int (*hash_func_type)(void *, const void *);\n+\n+/*\n+ * This data type is the function that compares two hash keys and returns an\n+ * integer greater than, equal to, or less than 0, according as the first\n+ * parameter is lexicographically greater than, equal to, or less than the\n+ * second. \n+ */\n+\n+typedef int (*compare_func_type)(const void *, const void *);\n+\n+\n+/*\n+ * This data structure is the cache.\n+ *\n+ * It must be passed to all of the hashing routines\n+ *   (except for new).\n+ */\n+typedef struct cache\n+{\n+  /* Variables used to implement the hash itself.  */\n+  node_ptr *node_table; /* Pointer to an array of hash nodes.  */\n+  /* Variables used to track the size of the hash table so to determine\n+    when to resize it.  */\n+  unsigned int size; /* Number of buckets allocated for the hash table\n+\t\t\t(number of array entries allocated for\n+\t\t\t\"node_table\").  Must be a power of two.  */\n+  unsigned int used; /* Current number of entries in the hash table.  */\n+  unsigned int mask; /* Precomputed mask.  */\n+\n+  /* Variables used to implement indexing through the hash table.  */\n+\n+  unsigned int last_bucket; /* Tracks which entry in the array where\n+\t\t\t       the last value was returned.  */\n+  /* Function used to compute a hash code given a key. \n+     This function is specified when the hash table is created.  */\n+  hash_func_type    hash_func;\n+  /* Function used to compare two hash keys to see if they are equal.  */\n+  compare_func_type compare_func;\n+} *cache_ptr;\n+\n+\n+/* Two important hash tables.  */\n+extern cache_ptr module_hash_table, class_hash_table;\n+\n+/* Allocate and initialize a hash table.  */ \n+\n+cache_ptr hash_new (unsigned int size,\n+\t\t    hash_func_type hash_func,\n+\t\t    compare_func_type compare_func);\n+                       \n+/* Deallocate all of the hash nodes and the cache itself.  */\n+\n+void hash_delete (cache_ptr cache);\n+\n+/* Add the key/value pair to the hash table.  If the\n+   hash table reaches a level of fullness then it will be resized. \n+                                                   \n+   assert if the key is already in the hash.  */\n+\n+void hash_add (cache_ptr *cachep, const void *key, void *value);\n+     \n+/* Remove the key/value pair from the hash table.  \n+   assert if the key isn't in the table.  */\n+\n+void hash_remove (cache_ptr cache, const void *key);\n+\n+/* Used to index through the hash table.  Start with NULL\n+   to get the first entry.\n+                                                  \n+   Successive calls pass the value returned previously.\n+   ** Don't modify the hash during this operation *** \n+                                                  \n+   Cache nodes are returned such that key or value can\n+   be extracted.  */\n+\n+node_ptr hash_next (cache_ptr cache, node_ptr node);\n+\n+/* Used to return a value from a hash table using a given key.  */\n+\n+void *hash_value_for_key (cache_ptr cache, const void *key);\n+\n+/* Used to determine if the given key exists in the hash table */\n+\n+BOOL hash_is_key_in_hash (cache_ptr cache, const void *key);\n+\n+/************************************************\n+\n+        Useful hashing functions.  \n+        \n+        Declared inline for your pleasure.\n+        \n+************************************************/\n+\n+/* Calculate a hash code by performing some \n+   manipulation of the key pointer.  (Use the lowest bits\n+   except for those likely to be 0 due to alignment.)  */\n+\n+static inline unsigned int\n+hash_ptr (cache_ptr cache, const void *key)\n+{\n+  return ((size_t)key / sizeof (void *)) & cache->mask;\n+}\n+\n+\n+/* Calculate a hash code by iterating over a NULL \n+   terminate string.  */\n+static inline unsigned int \n+hash_string (cache_ptr cache, const void *key)\n+{\n+  unsigned int ret = 0;\n+  unsigned int ctr = 0;\n+        \n+        \n+  while (*(char*)key) {\n+    ret ^= *(char*)key++ << ctr;\n+    ctr = (ctr + 1) % sizeof (void *);\n+  }\n+\n+  return ret & cache->mask;\n+}\n+\n+\n+/* Compare two pointers for equality.  */\n+static inline int \n+compare_ptrs (const void *k1, const void *k2)\n+{\n+  return !(k1 - k2);\n+}\n+\n+\n+/* Compare two strings.  */\n+static inline int \n+compare_strings (const void *k1, const void *k2)\n+{\n+  if (k1 == k2)\n+    return 1;\n+  else if (k1 == 0 || k2 == 0)\n+    return 0;\n+  else\n+    return !strcmp (k1, k2);\n+}\n+\n+\n+#endif /* not __hash_INCLUDE_GNU */"}, {"sha": "f1fea8123186370aee124ba5d8714bfb9b5e49bf", "filename": "libobjc/init.c", "status": "added", "additions": 834, "deletions": 0, "changes": 834, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,834 @@\n+/* GNU Objective C Runtime initialization \n+   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup\n+   +load support contributed by Ovidiu Predescu <ovidiu@net-community.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"runtime.h\"\n+\n+/* The version number of this runtime.  This must match the number \n+   defined in gcc (objc-act.c) */\n+#define OBJC_VERSION 8\n+#define PROTOCOL_VERSION 2\n+\n+/* This list contains all modules currently loaded into the runtime */\n+static struct objc_list* __objc_module_list = 0; \t/* !T:MUTEX */\n+\n+/* This list contains all proto_list's not yet assigned class links */\n+static struct objc_list* unclaimed_proto_list = 0; \t/* !T:MUTEX */\n+\n+/* List of unresolved static instances.  */\n+static struct objc_list *uninitialized_statics = 0; \t/* !T:MUTEX */\n+\n+/* Global runtime \"write\" mutex. */\n+objc_mutex_t __objc_runtime_mutex = 0;\n+\n+/* Number of threads that are alive. */\n+int __objc_runtime_threads_alive = 1;\t\t\t/* !T:MUTEX */\n+\n+/* Check compiler vs runtime version */\n+static void init_check_module_version (Module_t);\n+\n+/* Assign isa links to protos */\n+static void __objc_init_protocols (struct objc_protocol_list* protos);\n+\n+/* Add protocol to class */\n+static void __objc_class_add_protocols (Class, struct objc_protocol_list*);\n+\n+/* This is a hook which is called by __objc_exec_class every time a class\n+   or a category is loaded into the runtime.  This may e.g. help a\n+   dynamic loader determine the classes that have been loaded when\n+   an object file is dynamically linked in */\n+void (*_objc_load_callback)(Class class, Category* category); /* !T:SAFE */\n+\n+/* Is all categories/classes resolved? */\n+BOOL __objc_dangling_categories = NO;           /* !T:UNUSED */\n+\n+extern SEL\n+__sel_register_typed_name (const char *name, const char *types, \n+\t\t\t   struct objc_selector *orig, BOOL is_const);\n+\n+/* Sends +load to all classes and categories in certain situations. */\n+static void objc_send_load (void);\n+\n+/* Inserts all the classes defined in module in a tree of classes that\n+   resembles the class hierarchy. This tree is traversed in preorder and the\n+   classes in its nodes receive the +load message if these methods were not\n+   executed before. The algorithm ensures that when the +load method of a class\n+   is executed all the superclasses have been already received the +load\n+   message. */\n+static void __objc_create_classes_tree (Module_t module);\n+\n+static void __objc_call_callback (Module_t module);\n+\n+/* A special version that works only before the classes are completely\n+   installed in the runtime. */\n+static BOOL class_is_subclass_of_class (Class class, Class superclass);\n+\n+typedef struct objc_class_tree {\n+  Class class;\n+  struct objc_list *subclasses; /* `head' is pointer to an objc_class_tree */\n+} objc_class_tree;\n+\n+/* This is a linked list of objc_class_tree trees. The head of these trees\n+   are root classes (their super class is Nil). These different trees\n+   represent different class hierarchies. */\n+static struct objc_list *__objc_class_tree_list = NULL;\n+\n+/* Keeps the +load methods who have been already executed. This hash should\n+   not be destroyed during the execution of the program. */\n+static cache_ptr __objc_load_methods = NULL;\n+\n+/* Creates a tree of classes whose topmost class is directly inherited from\n+   `upper' and the bottom class in this tree is `bottom_class'. The classes\n+   in this tree are super classes of `bottom_class'. `subclasses' member\n+   of each tree node point to the next subclass tree node. */\n+static objc_class_tree *\n+create_tree_of_subclasses_inherited_from (Class bottom_class, Class upper)\n+{\n+  Class superclass = bottom_class->super_class ?\n+\t\t\tobjc_lookup_class ((char*)bottom_class->super_class)\n+\t\t      : Nil;\n+\t\t\t\t\t\n+  objc_class_tree *tree, *prev;\n+\n+  DEBUG_PRINTF (\"create_tree_of_subclasses_inherited_from:\");\n+  DEBUG_PRINTF (\"bottom_class = %s, upper = %s\\n\",\n+\t\t(bottom_class ? bottom_class->name : NULL),\n+\t\t(upper ? upper->name : NULL));\n+\n+  tree = prev = objc_calloc (1, sizeof (objc_class_tree));\n+  prev->class = bottom_class;\n+\n+  while (superclass != upper)\n+    {\n+      tree = objc_calloc (1, sizeof (objc_class_tree));\n+      tree->class = superclass;\n+      tree->subclasses = list_cons (prev, tree->subclasses);\n+      superclass = (superclass->super_class ?\n+\t\t\tobjc_lookup_class ((char*)superclass->super_class)\n+\t\t      : Nil);\n+      prev = tree;\n+    }\n+\n+  return tree;\n+}\n+\n+/* Insert the `class' into the proper place in the `tree' class hierarchy. This\n+   function returns a new tree if the class has been successfully inserted into\n+   the tree or NULL if the class is not part of the classes hierarchy described\n+   by `tree'. This function is private to objc_tree_insert_class(), you should\n+   not call it directly. */\n+static objc_class_tree *\n+__objc_tree_insert_class (objc_class_tree *tree, Class class)\n+{\n+  DEBUG_PRINTF (\"__objc_tree_insert_class: tree = %x, class = %s\\n\",\n+\t\ttree, class->name);\n+\n+  if (tree == NULL)\n+    return create_tree_of_subclasses_inherited_from (class, NULL);\n+  else if (class == tree->class)\n+    {\n+      /* `class' has been already inserted */\n+      DEBUG_PRINTF (\"1. class %s was previously inserted\\n\", class->name);\n+      return tree;\n+    }\n+  else if ((class->super_class ?\n+\t\t    objc_lookup_class ((char*)class->super_class)\n+\t\t  : Nil)\n+\t    == tree->class)\n+    {\n+      /* If class is a direct subclass of tree->class then add class to the\n+\t list of subclasses. First check to see if it wasn't already\n+\t inserted. */\n+      struct objc_list *list = tree->subclasses;\n+      objc_class_tree *node;\n+\n+      while (list)\n+\t{\n+\t  /* Class has been already inserted; do nothing just return\n+\t     the tree. */\n+\t  if (((objc_class_tree*)list->head)->class == class)\n+\t    {\n+\t      DEBUG_PRINTF (\"2. class %s was previously inserted\\n\",\n+\t\t\t    class->name);\n+\t      return tree;\n+\t    }\n+\t  list = list->tail;\n+\t}\n+\n+      /* Create a new node class and insert it into the list of subclasses */\n+      node = objc_calloc (1, sizeof (objc_class_tree));\n+      node->class = class;\n+      tree->subclasses = list_cons (node, tree->subclasses);\n+      DEBUG_PRINTF (\"3. class %s inserted\\n\", class->name);\n+      return tree;\n+    }\n+  else\n+    {\n+      /* The class is not a direct subclass of tree->class. Search for class's\n+         superclasses in the list of subclasses. */\n+      struct objc_list *subclasses = tree->subclasses;\n+\n+      /* Precondition: the class must be a subclass of tree->class; otherwise\n+         return NULL to indicate our caller that it must take the next tree. */\n+      if (!class_is_subclass_of_class (class, tree->class))\n+\treturn NULL;\n+\n+      for (; subclasses != NULL; subclasses = subclasses->tail)\n+\t{\n+\t  Class aClass = ((objc_class_tree*)(subclasses->head))->class;\n+\n+\t  if (class_is_subclass_of_class (class, aClass))\n+\t    {\n+\t      /* If we found one of class's superclasses we insert the class\n+\t         into its subtree and return the original tree since nothing\n+\t\t has been changed. */\n+\t      subclasses->head\n+\t\t  = __objc_tree_insert_class (subclasses->head, class);\n+ \t      DEBUG_PRINTF (\"4. class %s inserted\\n\", class->name);\n+\t      return tree;\n+\t    }\n+\t}\n+\n+      /* We haven't found a subclass of `class' in the `subclasses' list.\n+         Create a new tree of classes whose topmost class is a direct subclass\n+\t of tree->class. */\n+      {\n+\tobjc_class_tree *new_tree\n+\t    = create_tree_of_subclasses_inherited_from (class, tree->class);\n+\ttree->subclasses = list_cons (new_tree, tree->subclasses);\n+ \tDEBUG_PRINTF (\"5. class %s inserted\\n\", class->name);\n+\treturn tree;\n+      }\n+    }\n+}\n+\n+/* This function inserts `class' in the right tree hierarchy classes. */\n+static void\n+objc_tree_insert_class (Class class)\n+{\n+  struct objc_list *list_node;\n+  objc_class_tree *tree;\n+\n+  list_node = __objc_class_tree_list;\n+  while (list_node)\n+    {\n+      tree = __objc_tree_insert_class (list_node->head, class);\n+      if (tree)\n+\t{\n+\t  list_node->head = tree;\n+\t  break;\n+\t}\n+      else\n+\tlist_node = list_node->tail;\n+    }\n+\n+  /* If the list was finished but the class hasn't been inserted, insert it\n+     here. */\n+  if (!list_node)\n+    {\n+      __objc_class_tree_list = list_cons (NULL, __objc_class_tree_list);\n+      __objc_class_tree_list->head = __objc_tree_insert_class (NULL, class);\n+    }\n+}\n+\n+/* Traverse tree in preorder. Used to send +load. */\n+static void\n+objc_preorder_traverse (objc_class_tree *tree,\n+\t\t\tint level,\n+\t\t\tvoid (*function)(objc_class_tree*, int))\n+{\n+  struct objc_list *node;\n+\n+  (*function) (tree, level);\n+  for (node = tree->subclasses; node; node = node->tail)\n+    objc_preorder_traverse (node->head, level + 1, function);\n+}\n+\n+/* Traverse tree in postorder. Used to destroy a tree. */\n+static void\n+objc_postorder_traverse (objc_class_tree *tree,\n+\t\t\tint level,\n+\t\t\tvoid (*function)(objc_class_tree*, int))\n+{\n+  struct objc_list *node;\n+\n+  for (node = tree->subclasses; node; node = node->tail)\n+    objc_postorder_traverse (node->head, level + 1, function);\n+  (*function) (tree, level);\n+}\n+\n+/* Used to print a tree class hierarchy. */\n+#ifdef DEBUG\n+static void\n+__objc_tree_print (objc_class_tree *tree, int level)\n+{\n+  int i;\n+\n+  for (i = 0; i < level; i++)\n+    printf (\"  \");\n+  printf (\"%s\\n\", tree->class->name);\n+}\n+#endif\n+\n+/* Walks on a linked list of methods in the reverse order and executes all\n+   the methods corresponding to `op' selector. Walking in the reverse order\n+   assures the +load of class is executed first and then +load of categories\n+   because of the way in which categories are added to the class methods. */\n+static void\n+__objc_send_message_in_list (MethodList_t method_list, Class class, SEL op)\n+{\n+  int i;\n+\n+  if (!method_list)\n+    return;\n+\n+  /* First execute the `op' message in the following method lists */\n+  __objc_send_message_in_list (method_list->method_next, class, op);\n+\n+  /* Search the method list. */\n+  for (i = 0; i < method_list->method_count; i++)\n+    {\n+      Method_t mth = &method_list->method_list[i];\n+\n+      if (mth->method_name && sel_eq (mth->method_name, op)\n+\t  && !hash_is_key_in_hash (__objc_load_methods, mth->method_name))\n+\t{\n+\t  /* The method was found and wasn't previously executed. */\n+\t  (*mth->method_imp) ((id)class, mth->method_name);\n+\n+\t  /* Add this method into the +load hash table */\n+\t  hash_add (&__objc_load_methods, mth->method_imp, mth->method_imp);\n+\n+\t  DEBUG_PRINTF (\"sending +load in class: %s\\n\", class->name);\n+\n+\t  break;\n+\t}\n+    }\n+}\n+\n+static void\n+__objc_send_load (objc_class_tree *tree, int level)\n+{\n+  static SEL load_sel = 0;\n+  Class class = tree->class;\n+  MethodList_t method_list = class->class_pointer->methods;\n+\n+  if (!load_sel)\n+    load_sel = sel_register_name (\"load\");\n+\n+  __objc_send_message_in_list (method_list, class, load_sel);\n+}\n+\n+static void\n+__objc_destroy_class_tree_node (objc_class_tree *tree, int level)\n+{\n+  objc_free (tree);\n+}\n+\n+/* This is used to check if the relationship between two classes before the\n+   runtime completely installs the classes. */\n+static BOOL\n+class_is_subclass_of_class (Class class, Class superclass)\n+{\n+  for (; class != Nil;)\n+    {\n+      if (class == superclass)\n+\treturn YES;\n+      class = (class->super_class ?\n+\t\t  objc_lookup_class ((char*)class->super_class)\n+\t\t: Nil);\n+    }\n+\n+  return NO;\n+}\n+\n+/* This list contains all the classes in the runtime system for whom their\n+   superclasses are not yet know to the runtime. */\n+static struct objc_list* unresolved_classes = 0;\n+\n+/* Static function used to reference the Object and NXConstantString classes.\n+ */\n+static void\n+__objc_force_linking (void)\n+{\n+  extern void __objc_linking (void);\n+  __objc_linking ();\n+\n+  /* Call the function to avoid compiler warning */\n+  __objc_force_linking ();\n+}\n+\n+/* Run through the statics list, removing modules as soon as all its statics\n+   have been initialized.  */\n+static void\n+objc_init_statics (void)\n+{\n+  struct objc_list **cell = &uninitialized_statics;\n+  struct objc_static_instances **statics_in_module;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  while (*cell)\n+    {\n+      int module_initialized = 1;\n+\n+      for (statics_in_module = (*cell)->head;\n+\t   *statics_in_module; statics_in_module++)\n+\t{\n+\t  struct objc_static_instances *statics = *statics_in_module;\n+\t  Class class = objc_lookup_class (statics->class_name);\n+\n+\t  if (!class)\n+\t    module_initialized = 0;\n+\t  /* Actually, the static's class_pointer will be NULL when we\n+             haven't been here before.  However, the comparison is to be\n+             reminded of taking into account class posing and to think about\n+             possible semantics...  */\n+\t  else if (class != statics->instances[0]->class_pointer)\n+\t    {\n+\t      id *inst;\n+\n+\t      for (inst = &statics->instances[0]; *inst; inst++)\n+\t\t{\n+\t\t  (*inst)->class_pointer = class;\n+\n+\t\t  /* ??? Make sure the object will not be freed.  With\n+                     refcounting, invoke `-retain'.  Without refcounting, do\n+                     nothing and hope that `-free' will never be invoked.  */\n+\n+\t\t  /* ??? Send the object an `-initStatic' or something to\n+                     that effect now or later on?  What are the semantics of\n+                     statically allocated instances, besides the trivial\n+                     NXConstantString, anyway?  */\n+\t\t}\n+\t    }\n+\t}\n+      if (module_initialized)\n+\t{\n+\t  /* Remove this module from the uninitialized list.  */\n+\t  struct objc_list *this = *cell;\n+\t  *cell = this->tail;\n+\t  objc_free(this);\n+\t}\n+      else\n+\tcell = &(*cell)->tail;\n+    }\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+} /* objc_init_statics */\n+\n+/* This function is called by constructor functions generated for each\n+   module compiled.  (_GLOBAL_$I$...) The purpose of this function is to\n+   gather the module pointers so that they may be processed by the\n+   initialization routines as soon as possible */\n+\n+void\n+__objc_exec_class (Module_t module)\n+{\n+  /* Have we processed any constructors previously?  This flag is used to\n+     indicate that some global data structures need to be built.  */\n+  static BOOL previous_constructors = 0;\n+\n+  static struct objc_list* unclaimed_categories = 0;\n+\n+  /* The symbol table (defined in objc-api.h) generated by gcc */\n+  Symtab_t symtab = module->symtab;\n+\n+  /* The statics in this module */\n+  struct objc_static_instances **statics\n+    = symtab->defs[symtab->cls_def_cnt + symtab->cat_def_cnt];\n+\n+  /* Entry used to traverse hash lists */\n+  struct objc_list** cell;\n+\n+  /* The table of selector references for this module */\n+  SEL selectors = symtab->refs; \n+\n+  /* dummy counter */\n+  int i;\n+\n+  DEBUG_PRINTF (\"received module: %s\\n\", module->name);\n+\n+  /* check gcc version */\n+  init_check_module_version(module);\n+\n+  /* On the first call of this routine, initialize some data structures.  */\n+  if (!previous_constructors)\n+    {\n+\t/* Initialize thread-safe system */\n+      __objc_init_thread_system();\n+      __objc_runtime_threads_alive = 1;\n+      __objc_runtime_mutex = objc_mutex_allocate();\n+\n+      __objc_init_selector_tables();\n+      __objc_init_class_tables();\n+      __objc_init_dispatch_tables();\n+      __objc_class_tree_list = list_cons (NULL, __objc_class_tree_list);\n+      __objc_load_methods\n+\t  = hash_new (128, (hash_func_type)hash_ptr, compare_ptrs);\n+      previous_constructors = 1;\n+    }\n+\n+  /* Save the module pointer for later processing. (not currently used) */\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  __objc_module_list = list_cons(module, __objc_module_list);\n+\n+  /* Replace referenced selectors from names to SEL's.  */\n+  if (selectors)\n+    {\n+      for (i = 0; selectors[i].sel_id; ++i)\n+\t{\n+\t  const char *name, *type;\n+\t  name = (char*)selectors[i].sel_id;\n+\t  type = (char*)selectors[i].sel_types;\n+\t  /* Constructors are constant static data so we can safely store\n+\t     pointers to them in the runtime structures. is_const == YES */\n+\t  __sel_register_typed_name (name, type, \n+\t\t\t\t     (struct objc_selector*)&(selectors[i]),\n+\t\t\t\t     YES);\n+\t}\n+    }\n+\n+  /* Parse the classes in the load module and gather selector information.  */\n+  DEBUG_PRINTF (\"gathering selectors from module: %s\\n\", module->name);\n+  for (i = 0; i < symtab->cls_def_cnt; ++i)\n+    {\n+      Class class = (Class) symtab->defs[i];\n+      const char* superclass = (char*)class->super_class;\n+\n+      /* Make sure we have what we think.  */\n+      assert (CLS_ISCLASS(class));\n+      assert (CLS_ISMETA(class->class_pointer));\n+      DEBUG_PRINTF (\"phase 1, processing class: %s\\n\", class->name);\n+\n+      /* Initialize the subclass list to be NULL.\n+\t In some cases it isn't and this crashes the program. */\n+      class->subclass_list = NULL;\n+\n+      /* Store the class in the class table and assign class numbers.  */\n+      __objc_add_class_to_hash (class);\n+\n+      /* Register all of the selectors in the class and meta class.  */\n+      __objc_register_selectors_from_class (class);\n+      __objc_register_selectors_from_class ((Class) class->class_pointer);\n+\n+      /* Install the fake dispatch tables */\n+      __objc_install_premature_dtable(class);\n+      __objc_install_premature_dtable(class->class_pointer);\n+\n+      /* Register the instance methods as class methods, this is\n+\t only done for root classes. */\n+      __objc_register_instance_methods_to_class(class);\n+\n+      if (class->protocols)\n+\t__objc_init_protocols (class->protocols);\n+\n+      /* Check to see if the superclass is known in this point. If it's not\n+\t add the class to the unresolved_classes list. */\n+      if (superclass && !objc_lookup_class (superclass))\n+\tunresolved_classes = list_cons (class, unresolved_classes);\n+   }\n+\n+  /* Process category information from the module.  */\n+  for (i = 0; i < symtab->cat_def_cnt; ++i)\n+    {\n+      Category_t category = symtab->defs[i + symtab->cls_def_cnt];\n+      Class class = objc_lookup_class (category->class_name);\n+      \n+      /* If the class for the category exists then append its methods.  */\n+      if (class)\n+\t{\n+\n+\t  DEBUG_PRINTF (\"processing categories from (module,object): %s, %s\\n\",\n+\t\t\tmodule->name,\n+\t\t\tclass->name);\n+\n+\t  /* Do instance methods.  */\n+\t  if (category->instance_methods)\n+\t    class_add_method_list (class, category->instance_methods);\n+\n+\t  /* Do class methods.  */\n+\t  if (category->class_methods)\n+\t    class_add_method_list ((Class) class->class_pointer, \n+\t\t\t\t   category->class_methods);\n+\n+\t  if (category->protocols)\n+\t    {\n+\t      __objc_init_protocols (category->protocols);\n+\t      __objc_class_add_protocols (class, category->protocols);\n+\t    }\n+\n+          /* Register the instance methods as class methods, this is\n+             only done for root classes. */\n+          __objc_register_instance_methods_to_class(class);\n+\t}\n+      else\n+\t{\n+\t  /* The object to which the category methods belong can't be found.\n+\t     Save the information.  */\n+\t  unclaimed_categories = list_cons(category, unclaimed_categories);\n+\t}\n+    }\n+\n+  if (statics)\n+    uninitialized_statics = list_cons (statics, uninitialized_statics);\n+  if (uninitialized_statics)\n+    objc_init_statics ();\n+\n+  /* Scan the unclaimed category hash.  Attempt to attach any unclaimed\n+     categories to objects.  */\n+  for (cell = &unclaimed_categories;\n+       *cell;\n+       ({ if (*cell) cell = &(*cell)->tail; }))\n+    {\n+      Category_t category = (*cell)->head;\n+      Class class = objc_lookup_class (category->class_name);\n+      \n+      if (class)\n+\t{\n+\t  DEBUG_PRINTF (\"attaching stored categories to object: %s\\n\",\n+\t\t\tclass->name);\n+\t  \n+\t  list_remove_head (cell);\n+\t  \n+\t  if (category->instance_methods)\n+\t    class_add_method_list (class, category->instance_methods);\n+\t  \n+\t  if (category->class_methods)\n+\t    class_add_method_list ((Class) class->class_pointer,\n+\t\t\t\t   category->class_methods);\n+\n+\t  if (category->protocols)\n+\t    {\n+\t      __objc_init_protocols (category->protocols);\n+\t      __objc_class_add_protocols (class, category->protocols);\n+\t    }\n+\n+          /* Register the instance methods as class methods, this is\n+             only done for root classes. */\n+          __objc_register_instance_methods_to_class(class);\n+\t}\n+    }\n+  \n+  if (unclaimed_proto_list && objc_lookup_class (\"Protocol\"))\n+    {\n+      list_mapcar (unclaimed_proto_list,(void(*)(void*))__objc_init_protocols);\n+      list_free (unclaimed_proto_list);\n+      unclaimed_proto_list = 0;\n+    }\n+\n+  objc_send_load ();\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}\n+\n+static void objc_send_load (void)\n+{\n+  if (!__objc_module_list)\n+    return;\n+ \n+  /* Try to find out if all the classes loaded so far also have their\n+     superclasses known to the runtime. We suppose that the objects that are\n+     allocated in the +load method are in general of a class declared in the\n+     same module. */\n+  if (unresolved_classes)\n+    {\n+      Class class = unresolved_classes->head;\n+\n+      while (objc_lookup_class ((char*)class->super_class))\n+\t{\n+\t  list_remove_head (&unresolved_classes);\n+\t  if (unresolved_classes)\n+\t    class = unresolved_classes->head;\n+\t  else\n+\t    break;\n+\t}\n+\n+      /*\n+       * If we still have classes for whom we don't have yet their super\n+       * classes known to the runtime we don't send the +load messages.\n+       */\n+      if (unresolved_classes)\n+\treturn;\n+    }\n+\n+  /* Special check to allow creating and sending messages to constant strings\n+     in +load methods. If these classes are not yet known, even if all the\n+     other classes are known, delay sending of +load. */\n+  if (!objc_lookup_class (\"NXConstantString\") ||\n+      !objc_lookup_class (\"Object\"))\n+    return;\n+\n+  /* Iterate over all modules in the __objc_module_list and call on them the\n+     __objc_create_classes_tree function. This function creates a tree of\n+     classes that resembles the class hierarchy. */\n+  list_mapcar (__objc_module_list, (void(*)(void*))__objc_create_classes_tree);\n+\n+  while (__objc_class_tree_list)\n+    {\n+#ifdef DEBUG\n+      objc_preorder_traverse (__objc_class_tree_list->head,\n+\t\t\t      0, __objc_tree_print);\n+#endif\n+      objc_preorder_traverse (__objc_class_tree_list->head,\n+\t\t\t      0, __objc_send_load);\n+      objc_postorder_traverse (__objc_class_tree_list->head,\n+\t\t\t      0, __objc_destroy_class_tree_node);\n+      list_remove_head (&__objc_class_tree_list);\n+    }\n+\n+  list_mapcar (__objc_module_list, (void(*)(void*))__objc_call_callback);\n+  list_free (__objc_module_list);\n+  __objc_module_list = NULL;\n+}\n+\n+static void\n+__objc_create_classes_tree (Module_t module)\n+{\n+  /* The runtime mutex is locked in this point */\n+\n+  Symtab_t symtab = module->symtab;\n+  int i;\n+\n+  /* Iterate thru classes defined in this module and insert them in the classes\n+     tree hierarchy. */\n+  for (i = 0; i < symtab->cls_def_cnt; i++)\n+    {\n+      Class class = (Class) symtab->defs[i];\n+\n+      objc_tree_insert_class (class);\n+    }\n+}\n+\n+static void\n+__objc_call_callback (Module_t module)\n+{\n+  /* The runtime mutex is locked in this point */\n+\n+  Symtab_t symtab = module->symtab;\n+  int i;\n+\n+  /* Iterate thru classes defined in this module and call the callback for\n+     each one. */\n+  for (i = 0; i < symtab->cls_def_cnt; i++)\n+    {\n+      Class class = (Class) symtab->defs[i];\n+\n+      /* Call the _objc_load_callback for this class. */\n+      if (_objc_load_callback)\n+\t_objc_load_callback(class, 0);\n+    }\n+\n+  /* Call the _objc_load_callback for categories. Don't register the instance\n+     methods as class methods for categories to root classes since they were\n+     already added in the class. */\n+  for (i = 0; i < symtab->cat_def_cnt; i++)\n+    {\n+      Category_t category = symtab->defs[i + symtab->cls_def_cnt];\n+      Class class = objc_lookup_class (category->class_name);\n+      \n+      if (_objc_load_callback)\n+\t_objc_load_callback(class, category);\n+    }\n+}\n+\n+/* Sanity check the version of gcc used to compile `module'*/\n+static void init_check_module_version(Module_t module)\n+{\n+  if ((module->version != OBJC_VERSION) || (module->size != sizeof (Module)))\n+    {\n+      int code;\n+\n+      if(module->version > OBJC_VERSION)\n+\tcode = OBJC_ERR_OBJC_VERSION;\n+      else if (module->version < OBJC_VERSION)\n+\tcode = OBJC_ERR_GCC_VERSION;\n+      else\n+\tcode = OBJC_ERR_MODULE_SIZE;\n+\n+      objc_error(nil, code, \"Module %s version %d doesn't match runtime %d\\n\",\n+\t       module->name, (int)module->version, OBJC_VERSION);\n+    }\n+}\n+\n+static void\n+__objc_init_protocols (struct objc_protocol_list* protos)\n+{\n+  int i;\n+  static Class proto_class = 0;\n+\n+  if (! protos)\n+    return;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  if (!proto_class)\n+    proto_class = objc_lookup_class(\"Protocol\");\n+\n+  if (!proto_class)\n+    {\n+      unclaimed_proto_list = list_cons (protos, unclaimed_proto_list);\n+      objc_mutex_unlock(__objc_runtime_mutex);\n+      return;\n+    }\n+\n+#if 0\n+  assert (protos->next == 0);\t/* only single ones allowed */\n+#endif\n+\n+  for(i = 0; i < protos->count; i++)\n+    {\n+      struct objc_protocol* aProto = protos->list[i];\n+      if (((size_t)aProto->class_pointer) == PROTOCOL_VERSION)\n+\t{\n+\t  /* assign class pointer */\n+\t  aProto->class_pointer = proto_class;\n+\n+\t  /* init super protocols */\n+\t  __objc_init_protocols (aProto->protocol_list);\n+\t}\n+      else if (protos->list[i]->class_pointer != proto_class)\n+\t{\n+\t  objc_error(nil, OBJC_ERR_PROTOCOL_VERSION,\n+\t\t     \"Version %d doesn't match runtime protocol version %d\\n\",\n+\t\t     (int)((char*)protos->list[i]->class_pointer-(char*)0),\n+\t\t     PROTOCOL_VERSION);\n+\t}\n+    }\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}\n+\n+static void __objc_class_add_protocols (Class class,\n+\t\t\t\t\tstruct objc_protocol_list* protos)\n+{\n+  /* Well... */\n+  if (! protos)\n+    return;\n+\n+  /* Add it... */\n+  protos->next = class->protocols;\n+  class->protocols = protos;\n+}"}, {"sha": "a4a6049e816ff0fb22de11d589a6cb1c9dc82595", "filename": "libobjc/libobjc.def", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Flibobjc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Flibobjc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Flibobjc.def?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,161 @@\n+;  GNU Objective C Runtime DLL Export Definitions\n+;  Copyright (C) 1997 Free Software Foundation, Inc.\n+;  Contributed by Scott Christley <scottc@net-community.com>\n+;\n+;  This file is part of GNU CC.\n+;\n+;  GNU CC is free software; you can redistribute it and/or modify it under the\n+;  terms of the GNU General Public License as published by the Free Software\n+;  Foundation; either version 2, or (at your option) any later version.\n+;\n+;  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+;  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+;  details.\n+;\n+;  You should have received a copy of the GNU General Public License along with\n+;  GNU CC; see the file COPYING.  If not, write to the Free Software\n+;  Foundation, 59 Temple Place - Suite 330,\n+;  Boston, MA 02111-1307, USA.\n+\n+LIBRARY libobjc\n+EXPORTS\n+search_for_method_in_list\n+objc_get_uninstalled_dtable\n+hash_is_key_in_hash\n+objc_verror\n+_objc_load_callback\n+objc_malloc\n+objc_atomic_malloc\n+objc_valloc\n+objc_realloc\n+objc_calloc\n+objc_free\n+__objc_init_thread_system\n+objc_mutex_allocate\n+objc_mutex_deallocate\n+objc_mutex_lock\n+objc_mutex_trylock\n+objc_mutex_unlock\n+objc_thread_detach\n+objc_thread_exit\n+objc_thread_get_data\n+objc_thread_get_priority\n+objc_thread_id\n+objc_thread_set_data\n+objc_thread_set_priority\n+objc_thread_yield\n+__objc_class_name_Object\n+__objc_class_name_Protocol\n+__objc_class_name_NXConstantString\n+objc_error\n+__objc_object_alloc\n+__objc_object_copy\n+__objc_object_dispose\n+class_create_instance\n+object_copy\n+object_dispose\n+__objc_init_selector_tables\n+__objc_register_selectors_from_class\n+__sel_register_typed_name\n+sel_get_any_typed_uid\n+sel_get_any_uid\n+sel_get_name\n+sel_get_type\n+sel_get_typed_uid\n+sel_get_uid\n+sel_is_mapped\n+sel_register_name\n+sel_register_typed_name\n+sel_types_match\n+method_get_first_argument\n+method_get_next_argument\n+method_get_nth_argument\n+method_get_number_of_arguments\n+method_get_sizeof_arguments\n+objc_aligned_size\n+objc_alignof_type\n+objc_get_type_qualifiers\n+objc_promoted_size\n+objc_sizeof_type\n+objc_skip_argspec\n+objc_skip_offset\n+objc_skip_type_qualifiers\n+objc_skip_typespec\n+__objc_read_nbyte_uint\n+__objc_read_nbyte_ulong\n+__objc_write_class\n+__objc_write_object\n+__objc_write_selector\n+objc_close_typed_stream\n+objc_end_of_typed_stream\n+objc_flush_typed_stream\n+objc_get_stream_class_version\n+objc_open_typed_stream\n+objc_open_typed_stream_for_file\n+objc_read_array\n+objc_read_char\n+objc_read_int\n+objc_read_long\n+objc_read_object\n+objc_read_selector\n+objc_read_short\n+objc_read_string\n+objc_read_type\n+objc_read_types\n+objc_read_unsigned_char\n+objc_read_unsigned_int\n+objc_read_unsigned_long\n+objc_read_unsigned_short\n+objc_write_array\n+objc_write_char\n+objc_write_int\n+objc_write_long\n+objc_write_object\n+objc_write_object_reference\n+objc_write_root_object\n+objc_write_selector\n+objc_write_short\n+objc_write_string\n+objc_write_string_atomic\n+objc_write_type\n+objc_write_types\n+objc_write_unsigned_char\n+objc_write_unsigned_int\n+objc_write_unsigned_long\n+objc_write_unsigned_short\n+__objc_exec_class\n+__objc_init_dispatch_tables\n+__objc_install_premature_dtable\n+__objc_print_dtable_stats\n+__objc_responds_to\n+__objc_update_dispatch_table_for_class\n+class_add_method_list\n+class_get_class_method\n+class_get_instance_method\n+get_imp\n+nil_method\n+objc_msg_lookup\n+objc_msg_lookup_super\n+objc_msg_sendv\n+__objc_add_class_to_hash\n+__objc_init_class_tables\n+__objc_resolve_class_links\n+class_pose_as\n+objc_get_class\n+objc_get_meta_class\n+objc_lookup_class\n+objc_next_class\n+sarray_at_put\n+sarray_at_put_safe\n+sarray_free\n+sarray_lazy_copy\n+sarray_new\n+sarray_realloc\n+sarray_remove_garbage\n+hash_add\n+hash_delete\n+hash_new\n+hash_next\n+hash_remove\n+hash_value_for_key"}, {"sha": "2d584ab3c1efb95a6396ac1682bc1fe623b0c86b", "filename": "libobjc/libobjc_entry.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Flibobjc_entry.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Flibobjc_entry.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Flibobjc_entry.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,55 @@\n+/* GNU Objective C Runtime DLL Entry\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Contributed by Scott Christley <scottc@net-community.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <windows.h>\n+\n+/*\n+  DLL entry function for Objective-C Runtime library\n+  This function gets called everytime a process/thread attaches to DLL\n+  */\n+WINBOOL WINAPI DllMain(HANDLE hInst, ULONG ul_reason_for_call,\n+        LPVOID lpReserved)\n+{\n+  switch(ul_reason_for_call)\n+    {\n+    case DLL_PROCESS_ATTACH:\n+      break;\n+    case DLL_PROCESS_DETACH:\n+      break;\n+    case DLL_THREAD_ATTACH:\n+      break;\n+    case DLL_THREAD_DETACH:\n+      break;\n+    }\n+  return TRUE;\n+}\n+\n+/*\n+  This section terminates the list of imports under GCC. If you do not\n+  include this then you will have problems when linking with DLLs.\n+  */\n+asm (\".section .idata$3\\n\" \".long 0,0,0,0,0,0,0,0\");"}, {"sha": "8ecca0281106c088afae36198f904ecdaeb93f89", "filename": "libobjc/linking.m", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Flinking.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Flinking.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Flinking.m?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,40 @@\n+/* Force linking of classes required by Objective C runtime.\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Contributed by Ovidiu Predescu (ovidiu@net-community.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <objc/Object.h>\n+#include <objc/NXConstStr.h>\n+\n+/* Generate references to Object and NXConstanstString classes since they are\n+   needed by the runtime system to run correctly. */\n+\n+\n+void __objc_linking (void)\n+{\n+  [Object name];\n+  [NXConstantString name];\n+}\n+"}, {"sha": "3e1b1871e40eaa9569351e1d18af412b7d318423", "filename": "libobjc/makefile.dos", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fmakefile.dos", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fmakefile.dos", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fmakefile.dos?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,56 @@\n+#  GNU Objective C Runtime Makefile for compiling with djgpp\n+#  Copyright (C) 1993, 1994, 1996 Free Software Foundation, Inc.\n+#\n+#  This file is part of GNU CC.\n+#\n+#  GNU CC is free software; you can redistribute it and/or modify it under the\n+#  terms of the GNU General Public License as published by the Free Software\n+#  Foundation; either version 2, or (at your option) any later version.\n+#\n+#  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+#  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+#  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+#  details.\n+#\n+#  You should have received a copy of the GNU General Public License along with\n+#  GNU CC; see the file COPYING.  If not, write to the Free Software\n+#  Foundation, 59 Temple Place - Suite 330,\n+#  Boston, MA 02111-1307, USA. \n+\n+# This Makefile is configured for GnuMAKE\n+\n+GCC_FOR_TARGET=gcc\n+\n+.SUFFIXES: .o .m\n+\n+OPTIMIZE = -O2\n+\n+# Always search these dirs when compiling.\n+SUBDIR_INCLUDES = -I. -I.. -I../config\n+\n+.c.o:\n+\t$(GCC_FOR_TARGET) $(OPTIMIZE) \\\n+\t\t-c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $<\n+\n+.m.o:\n+\t$(GCC_FOR_TARGET) $(OPTIMIZE) -fgnu-runtime \\\n+\t\t-c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $<\n+\n+OBJC_O = hash.o sarray.o class.o sendmsg.o init.o archive.o \\\n+         selector.o objects.o misc.o object.o protocol.o encoding.o thread.o\n+\n+libobjc.a: $(OBJC_O)\n+\t-rm -f libobjc.a\n+\tar rc libobjc.a $(OBJC_O)\n+\tranlib libobjc.a\n+\n+OBJC_H = hash.h objc-list.h sarray.h objc.h \\\n+         objc-api.h \\\n+\t object.h protocol.h mutex.h \\\n+\t typedstream.h thread.h\n+\n+mostlyclean:\n+\t-rm -f *.o libobjc.a xforward fflags\n+clean: mostlyclean\n+distclean: mostlyclean\n+extraclean: mostlyclean"}, {"sha": "7339888dc280dca19e6b5d2c018e6b2169154e85", "filename": "libobjc/misc.c", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fmisc.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,180 @@\n+/* GNU Objective C Runtime Miscellaneous \n+   Copyright (C) 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#define __USE_FIXED_PROTOTYPES__\n+#include <stdlib.h>\n+#include \"runtime.h\"\n+\n+/*\n+** Error handler function\n+** NULL so that default is to just print to stderr\n+*/\n+static objc_error_handler _objc_error_handler = NULL;\n+\n+/* Trigger an objc error */\n+void\n+objc_error(id object, int code, const char* fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start(ap, fmt);\n+  objc_verror(object, code, fmt, ap);\n+  va_end(ap);\n+}\n+\n+/* Trigger an objc error */\n+void\n+objc_verror(id object, int code, const char* fmt, va_list ap)\n+{\n+  BOOL result = NO;\n+\n+  /* Call the error handler if its there\n+     Otherwise print to stderr */\n+  if (_objc_error_handler)\n+    result = (*_objc_error_handler)(object, code, fmt, ap);\n+  else\n+    vfprintf (stderr, fmt, ap);\n+\n+  /* Continue if the error handler says its ok\n+     Otherwise abort the program */\n+  if (result)\n+    return;\n+  else\n+    abort();\n+}\n+\n+/* Set the error handler */\n+objc_error_handler\n+objc_set_error_handler(objc_error_handler func)\n+{\n+  objc_error_handler temp = _objc_error_handler;\n+  _objc_error_handler = func;\n+  return temp;\n+}\n+\n+/*\n+** Standard functions for memory allocation and disposal.\n+** Users should use these functions in their ObjC programs so\n+** that they work properly with garbage collectors as well as\n+** can take advantage of the exception/error handling available.\n+*/\n+\n+void *\n+objc_malloc(size_t size)\n+{\n+  void* res = (void*) (*_objc_malloc)(size);\n+  if(!res)\n+    objc_error(nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n+  return res;\n+}\n+\n+void *\n+objc_atomic_malloc(size_t size)\n+{\n+  void* res = (void*) (*_objc_atomic_malloc)(size);\n+  if(!res)\n+    objc_error(nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n+  return res;\n+}\n+\n+void *\n+objc_valloc(size_t size)\n+{\n+  void* res = (void*) (*_objc_valloc)(size);\n+  if(!res)\n+    objc_error(nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n+  return res;\n+}\n+\n+void *\n+objc_realloc(void *mem, size_t size)\n+{\n+  void* res = (void*) (*_objc_realloc)(mem, size);\n+  if(!res)\n+    objc_error(nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n+  return res;\n+}\n+\n+void *\n+objc_calloc(size_t nelem, size_t size)\n+{\n+  void* res = (void*) (*_objc_calloc)(nelem, size);\n+  if(!res)\n+    objc_error(nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n+  return res;\n+}\n+\n+void\n+objc_free(void *mem)\n+{\n+  (*_objc_free)(mem);\n+}\n+\n+/*\n+** Hook functions for memory allocation and disposal.\n+** This makes it easy to substitute garbage collection systems\n+** such as Boehm's GC by assigning these function pointers\n+** to the GC's allocation routines.  By default these point\n+** to the ANSI standard malloc, realloc, free, etc.\n+**\n+** Users should call the normal objc routines above for\n+** memory allocation and disposal within their programs.\n+*/\n+\n+#if OBJC_WITH_GC\n+#include <gc.h>\n+\n+static void *GC_calloc (size_t nelem, size_t size)\n+{\n+  void* p = GC_malloc (nelem * size);\n+  if (!p)\n+    objc_error (nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted!\\n\");\n+\n+  memset (p, 0, nelem * size);\n+  return p;\n+}\n+\n+static void noFree (void* p) {}\n+\n+void *(*_objc_malloc)(size_t) = GC_malloc;\n+void *(*_objc_atomic_malloc)(size_t) = GC_malloc_atomic;\n+void *(*_objc_valloc)(size_t) = GC_malloc;\n+void *(*_objc_realloc)(void *, size_t) = GC_realloc;\n+void *(*_objc_calloc)(size_t, size_t) = GC_calloc;\n+void (*_objc_free)(void *) = noFree;\n+\n+#else\n+\n+void *(*_objc_malloc)(size_t) = malloc;\n+void *(*_objc_atomic_malloc)(size_t) = malloc;\n+void *(*_objc_valloc)(size_t) = malloc;\n+void *(*_objc_realloc)(void *, size_t) = realloc;\n+void *(*_objc_calloc)(size_t, size_t) = calloc;\n+void (*_objc_free)(void *) = free;\n+\n+\n+#endif"}, {"sha": "1b6212826bdad1b780e2c8128dae924ffcf38231", "filename": "libobjc/nil_method.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fnil_method.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fnil_method.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fnil_method.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,40 @@\n+/* GNU Objective C Runtime nil receiver function\n+   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+/* This is the nil method, the function that is called when the receiver\n+   of a method is nil */\n+\n+#include \"runtime.h\"\n+\n+id\n+nil_method(id receiver, SEL op, ...)\n+{\n+  return receiver;\n+}\n+\n+\n+\n+"}, {"sha": "fe34dafb89568916475cfa63de33d60a11cfa560", "filename": "libobjc/objc-api.h", "status": "added", "additions": 597, "deletions": 0, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fobjc-api.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fobjc-api.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-api.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,597 @@\n+/* GNU Objective-C Runtime API.\n+   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled\n+   with GCC to produce an executable, this does not cause the resulting\n+   executable to be covered by the GNU General Public License.  This\n+   exception does not however invalidate any other reasons why the\n+   executable file might be covered by the GNU General Public License. */\n+\n+#ifndef __objc_api_INCLUDE_GNU\n+#define __objc_api_INCLUDE_GNU\n+\n+#include \"objc/objc.h\"\n+#include \"objc/hash.h\"\n+#include \"objc/thr.h\"\n+#include <stdio.h>\n+#include <stdarg.h>\n+\n+/* For functions which return Method_t */\n+#define METHOD_NULL\t(Method_t)0\n+                                                /* Boolean typedefs */\n+/*\n+** Method descriptor returned by introspective Object methods.\n+** This is really just the first part of the more complete objc_method\n+** structure defined below and used internally by the runtime.\n+*/\n+struct objc_method_description\n+{\n+    SEL name;\t\t\t/* this is a selector, not a string */\n+    char *types;\t\t/* type encoding */\n+};\n+\n+/* Filer types used to describe Ivars and Methods.  */\n+#define _C_ID       '@'\n+#define _C_CLASS    '#'\n+#define _C_SEL      ':'\n+#define _C_CHR      'c'\n+#define _C_UCHR     'C'\n+#define _C_SHT      's'\n+#define _C_USHT     'S'\n+#define _C_INT      'i'\n+#define _C_UINT     'I'\n+#define _C_LNG      'l'\n+#define _C_ULNG     'L'\n+#define _C_LNG_LNG  'q'\n+#define _C_ULNG_LNG 'Q'\n+#define _C_FLT      'f'\n+#define _C_DBL      'd'\n+#define _C_BFLD     'b'\n+#define _C_VOID     'v'\n+#define _C_UNDEF    '?'\n+#define _C_PTR      '^'\n+#define _C_CHARPTR  '*'\n+#define _C_ATOM     '%'\n+#define _C_ARY_B    '['\n+#define _C_ARY_E    ']'\n+#define _C_UNION_B  '('\n+#define _C_UNION_E  ')'\n+#define _C_STRUCT_B '{'\n+#define _C_STRUCT_E '}'\n+\n+\n+/*\n+** Error handling\n+**\n+** Call objc_error() or objc_verror() to record an error; this error\n+** routine will generally exit the program but not necessarily if the\n+** user has installed his own error handler.\n+**\n+** Call objc_set_error_handler to assign your own function for\n+** handling errors.  The function should return YES if it is ok\n+** to continue execution, or return NO or just abort if the\n+** program should be stopped.  The default error handler is just to\n+** print a message on stderr.\n+**\n+** The error handler function should be of type objc_error_handler\n+** The first parameter is an object instance of relevance.\n+** The second parameter is an error code.\n+** The third parameter is a format string in the printf style.\n+** The fourth parameter is a variable list of arguments.\n+*/\n+extern void objc_error(id object, int code, const char* fmt, ...);\n+extern void objc_verror(id object, int code, const char* fmt, va_list ap);\n+typedef BOOL (*objc_error_handler)(id, int code, const char *fmt, va_list ap);\n+objc_error_handler objc_set_error_handler(objc_error_handler func);\n+\n+/*\n+** Error codes\n+** These are used by the runtime library, and your\n+** error handling may use them to determine if the error is\n+** hard or soft thus whether execution can continue or abort.\n+*/\n+#define OBJC_ERR_UNKNOWN 0             /* Generic error */\n+\n+#define OBJC_ERR_OBJC_VERSION 1        /* Incorrect runtime version */\n+#define OBJC_ERR_GCC_VERSION 2         /* Incorrect compiler version */\n+#define OBJC_ERR_MODULE_SIZE 3         /* Bad module size */\n+#define OBJC_ERR_PROTOCOL_VERSION 4    /* Incorrect protocol version */\n+\n+#define OBJC_ERR_MEMORY 10             /* Out of memory */\n+\n+#define OBJC_ERR_RECURSE_ROOT 20       /* Attempt to archive the root\n+\t\t\t\t\t  object more than once. */\n+#define OBJC_ERR_BAD_DATA 21           /* Didn't read expected data */\n+#define OBJC_ERR_BAD_KEY 22            /* Bad key for object */\n+#define OBJC_ERR_BAD_CLASS 23          /* Unknown class */\n+#define OBJC_ERR_BAD_TYPE 24           /* Bad type specification */\n+#define OBJC_ERR_NO_READ 25            /* Cannot read stream */\n+#define OBJC_ERR_NO_WRITE 26           /* Cannot write stream */\n+#define OBJC_ERR_STREAM_VERSION 27     /* Incorrect stream version */\n+#define OBJC_ERR_BAD_OPCODE 28         /* Bad opcode */\n+\n+#define OBJC_ERR_UNIMPLEMENTED 30      /* Method is not implemented */\n+\n+#define OBJC_ERR_BAD_STATE 40          /* Bad thread state */\n+\n+/*\n+** Set this variable nonzero to print a line describing each\n+** message that is sent.  (this is currently disabled)\n+*/\n+extern BOOL objc_trace;\n+\n+\n+/* For every class which happens to have statically allocated instances in\n+   this module, one OBJC_STATIC_INSTANCES is allocated by the compiler.\n+   INSTANCES is NULL terminated and points to all statically allocated\n+   instances of this class.  */\n+struct objc_static_instances\n+{\n+  char *class_name;\n+  id instances[0];\n+};\n+\n+/*\n+** Whereas a Module (defined further down) is the root (typically) of a file,\n+** a Symtab is the root of the class and category definitions within the\n+** module.  \n+** \n+** A Symtab contains a variable length array of pointers to classes and\n+** categories  defined in the module. \n+*/\n+typedef struct objc_symtab {\n+  unsigned long sel_ref_cnt;                     /* Unknown. */\n+  SEL        refs;                              /* Unknown. */\n+  unsigned short cls_def_cnt;                   /* Number of classes compiled\n+                                                  (defined) in the module. */\n+  unsigned short cat_def_cnt;                   /* Number of categories \n+                                                  compiled (defined) in the \n+                                                  module. */\n+\n+  void      *defs[1];                           /* Variable array of pointers.\n+                                                  cls_def_cnt of type Class \n+                                                  followed by cat_def_cnt of\n+                                                  type Category_t, followed\n+\t\t\t\t\t\t  by a NULL terminated array\n+\t\t\t\t\t\t  of objc_static_instances. */\n+} Symtab,   *Symtab_t;\n+\n+\n+/*\n+** The compiler generates one of these structures for each module that\n+** composes the executable (eg main.m).  \n+** \n+** This data structure is the root of the definition tree for the module.  \n+** \n+** A collect program runs between ld stages and creates a ObjC ctor array. \n+** That array holds a pointer to each module structure of the executable. \n+*/\n+typedef struct objc_module {\n+  unsigned long version;                        /* Compiler revision. */\n+  unsigned long size;                           /* sizeof(Module). */\n+  const char* name;                             /* Name of the file where the \n+                                                  module was generated.   The \n+                                                  name includes the path. */\n+\n+  Symtab_t    symtab;                           /* Pointer to the Symtab of\n+                                                  the module.  The Symtab\n+                                                  holds an array of \n+\t\t\t\t\t\t  pointers to \n+                                                  the classes and categories \n+                                                  defined in the module. */\n+} Module, *Module_t;\n+\n+\n+/*\n+** The compiler generates one of these structures for a class that has\n+** instance variables defined in its specification. \n+*/\n+typedef struct objc_ivar* Ivar_t;\n+typedef struct objc_ivar_list {\n+  int   ivar_count;                             /* Number of structures (Ivar) \n+                                                  contained in the list.  One\n+                                                  structure per instance \n+                                                  variable defined in the\n+                                                  class. */\n+  struct objc_ivar {\n+    const char* ivar_name;                      /* Name of the instance\n+                                                  variable as entered in the\n+                                                  class definition. */\n+    const char* ivar_type;                      /* Description of the Ivar's\n+                                                  type.  Useful for \n+                                                  debuggers. */\n+    int        ivar_offset;                    /* Byte offset from the base \n+                                                  address of the instance \n+                                                  structure to the variable. */\n+\n+  } ivar_list[1];                               /* Variable length \n+                                                  structure. */\n+} IvarList, *IvarList_t;\n+\n+\n+/*\n+** The compiler generates one (or more) of these structures for a class that\n+** has methods defined in its specification. \n+** \n+** The implementation of a class can be broken into separate pieces in a file\n+** and categories can break them across modules. To handle this problem is a\n+** singly linked list of methods. \n+*/\n+typedef struct objc_method Method;\n+typedef Method* Method_t;\n+typedef struct objc_method_list {\n+  struct objc_method_list*  method_next;      /* This variable is used to link \n+                                                a method list to another.  It \n+                                                is a singly linked list. */\n+  int            method_count;               /* Number of methods defined in \n+                                                this structure. */\n+  struct objc_method {\n+    SEL         method_name;                  /* This variable is the method's \n+                                                name.  It is a char*. \n+                                                  The unique integer passed to \n+                                                objc_msg_send is a char* too.  \n+                                                It is compared against \n+                                                method_name using strcmp. */\n+    const char* method_types;                 /* Description of the method's\n+                                                parameter list.  Useful for\n+                                                debuggers. */\n+    IMP         method_imp;                   /* Address of the method in the \n+                                                executable. */\n+  } method_list[1];                           /* Variable length \n+                                                structure. */\n+} MethodList, *MethodList_t;\n+\n+struct objc_protocol_list {\n+  struct objc_protocol_list *next;\n+  int count;\n+  Protocol *list[1];\n+};\n+\n+/*\n+** This is used to assure consistent access to the info field of \n+** classes\n+*/\n+#ifndef HOST_BITS_PER_LONG\n+#define HOST_BITS_PER_LONG  (sizeof(long)*8)\n+#endif \n+\n+#define __CLS_INFO(cls) ((cls)->info)\n+#define __CLS_ISINFO(cls, mask) ((__CLS_INFO(cls)&mask)==mask)\n+#define __CLS_SETINFO(cls, mask) (__CLS_INFO(cls) |= mask)\n+\n+/* The structure is of type MetaClass */\n+#define _CLS_META 0x2L\n+#define CLS_ISMETA(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_META))\n+\n+\n+/* The structure is of type Class */\n+#define _CLS_CLASS 0x1L\n+#define CLS_ISCLASS(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_CLASS))\n+\n+/*\n+** The class is initialized within the runtime.  This means that \n+** it has had correct super and sublinks assigned\n+*/\n+#define _CLS_RESOLV 0x8L\n+#define CLS_ISRESOLV(cls) __CLS_ISINFO(cls, _CLS_RESOLV)\n+#define CLS_SETRESOLV(cls) __CLS_SETINFO(cls, _CLS_RESOLV)\n+\n+/*\n+** The class has been send a +initialize message or a such is not \n+** defined for this class\n+*/\n+#define _CLS_INITIALIZED 0x04L\n+#define CLS_ISINITIALIZED(cls) __CLS_ISINFO(cls, _CLS_INITIALIZED)\n+#define CLS_SETINITIALIZED(cls) __CLS_SETINFO(cls, _CLS_INITIALIZED)\n+\n+/*\n+** The class number of this class.  This must be the same for both the \n+** class and its meta class object\n+*/\n+#define CLS_GETNUMBER(cls) (__CLS_INFO(cls) >> (HOST_BITS_PER_LONG/2))\n+#define CLS_SETNUMBER(cls, num) \\\n+  ({ (cls)->info <<= (HOST_BITS_PER_LONG/2); \\\n+     (cls)->info >>= (HOST_BITS_PER_LONG/2); \\\n+     __CLS_SETINFO(cls, (((unsigned long)num) << (HOST_BITS_PER_LONG/2))); })\n+\n+/*\n+** The compiler generates one of these structures for each category.  A class\n+** may have many categories and contain both instance and factory methods.  \n+*/\n+typedef struct objc_category {\n+  const char*   category_name;                /* Name of the category.  Name\n+                                                contained in the () of the\n+                                                category definition. */\n+  const char*   class_name;                   /* Name of the class to which\n+                                                the category belongs. */\n+  MethodList_t  instance_methods;             /* Linked list of instance\n+                                                methods defined in the \n+                                                category. NULL indicates no\n+                                                instance methods defined. */\n+  MethodList_t  class_methods;                /* Linked list of factory \n+                                                methods defined in the\n+                                                category.  NULL indicates no\n+                                                class methods defined. */\n+  struct objc_protocol_list *protocols;\t      /* List of Protocols \n+\t\t\t\t\t         conformed to */\n+} Category, *Category_t;\n+\n+/*\n+** Structure used when a message is send to a class's super class.  The\n+** compiler generates one of these structures and passes it to\n+** objc_msg_super.\n+*/\n+typedef struct objc_super {\n+  id      self;                           /* Id of the object sending\n+                                                the message. */\n+  Class class;                              /* Object's super class. */\n+} Super, *Super_t;\n+\n+IMP objc_msg_lookup_super(Super_t super, SEL sel);\n+\n+retval_t objc_msg_sendv(id, SEL, arglist_t);\n+\n+\n+\n+/*\n+** This is a hook which is called by objc_lookup_class and\n+** objc_get_class if the runtime is not able to find the class.\n+** This may e.g. try to load in the class using dynamic loading.\n+** The function is guaranteed to be passed a non-NULL name string.\n+*/\n+extern Class (*_objc_lookup_class)(const char *name);\n+\n+/*\n+** This is a hook which is called by __objc_exec_class every time a class\n+** or a category is loaded into the runtime.  This may e.g. help a\n+** dynamic loader determine the classes that have been loaded when\n+** an object file is dynamically linked in.\n+*/\n+extern void (*_objc_load_callback)(Class class, Category* category);\n+\n+/*\n+** Hook functions for allocating, copying and disposing of instances\n+*/\n+extern id (*_objc_object_alloc)(Class class);\n+extern id (*_objc_object_copy)(id object);\n+extern id (*_objc_object_dispose)(id object);\n+\n+/*\n+** Standard functions for memory allocation and disposal.\n+** Users should use these functions in their ObjC programs so\n+** that they work properly with garbage collectors as well as\n+** can take advantage of the exception/error handling available.\n+*/\n+void *\n+objc_malloc(size_t size);\n+\n+void *\n+objc_atomic_malloc(size_t size);\n+\n+void *\n+objc_valloc(size_t size);\n+\n+void *\n+objc_realloc(void *mem, size_t size);\n+\n+void *\n+objc_calloc(size_t nelem, size_t size);\n+\n+void\n+objc_free(void *mem);\n+\n+/*\n+** Hook functions for memory allocation and disposal.\n+** This makes it easy to substitute garbage collection systems\n+** such as Boehm's GC by assigning these function pointers\n+** to the GC's allocation routines.  By default these point\n+** to the ANSI standard malloc, realloc, free, etc.\n+**\n+** Users should call the normal objc routines above for\n+** memory allocation and disposal within their programs.\n+*/\n+extern void *(*_objc_malloc)(size_t);\n+extern void *(*_objc_atomic_malloc)(size_t);\n+extern void *(*_objc_valloc)(size_t);\n+extern void *(*_objc_realloc)(void *, size_t);\n+extern void *(*_objc_calloc)(size_t, size_t);\n+extern void (*_objc_free)(void *);\n+\n+Method_t class_get_class_method(MetaClass class, SEL aSel);\n+\n+Method_t class_get_instance_method(Class class, SEL aSel);\n+\n+Class class_pose_as(Class impostor, Class superclass);\n+\n+Class objc_get_class(const char *name);\n+\n+Class objc_lookup_class(const char *name);\n+\n+Class objc_next_class(void **enum_state);\n+\n+const char *sel_get_name(SEL selector);\n+\n+const char *sel_get_type(SEL selector);\n+\n+SEL sel_get_uid(const char *name);\n+\n+SEL sel_get_any_uid(const char *name);\n+\n+SEL sel_get_any_typed_uid(const char *name);\n+\n+SEL sel_get_typed_uid(const char *name, const char*);\n+\n+SEL sel_register_name(const char *name);\n+\n+SEL sel_register_typed_name(const char *name, const char*type);\n+\n+\n+BOOL sel_is_mapped (SEL aSel);\n+\n+extern id class_create_instance(Class class);\n+\n+static inline const char *\n+class_get_class_name(Class class)\n+{\n+  return CLS_ISCLASS(class)?class->name:((class==Nil)?\"Nil\":0);\n+}\n+\n+static inline long\n+class_get_instance_size(Class class)\n+{\n+  return CLS_ISCLASS(class)?class->instance_size:0;\n+}\n+\n+static inline MetaClass\n+class_get_meta_class(Class class)\n+{\n+  return CLS_ISCLASS(class)?class->class_pointer:Nil;\n+}\n+\n+static inline Class\n+class_get_super_class(Class class)\n+{\n+  return CLS_ISCLASS(class)?class->super_class:Nil;\n+}\n+\n+static inline int\n+class_get_version(Class class)\n+{\n+  return CLS_ISCLASS(class)?class->version:-1;\n+}\n+\n+static inline BOOL\n+class_is_class(Class class)\n+{\n+  return CLS_ISCLASS(class);\n+}\n+\n+static inline BOOL\n+class_is_meta_class(Class class)\n+{\n+  return CLS_ISMETA(class);\n+}\n+\n+\n+static inline void\n+class_set_version(Class class, long version)\n+{\n+  if (CLS_ISCLASS(class))\n+    class->version = version;\n+}\n+\n+static inline void *\n+class_get_gc_object_type (Class class)\n+{\n+  return CLS_ISCLASS(class) ? class->gc_object_type : NULL;\n+}\n+\n+/* Mark the instance variable as innaccessible to the garbage collector */\n+extern void class_ivar_set_gcinvisible (Class class,\n+\t\t\t\t\tconst char* ivarname,\n+\t\t\t\t\tBOOL gcInvisible);\n+\n+static inline IMP\n+method_get_imp(Method_t method)\n+{\n+  return (method!=METHOD_NULL)?method->method_imp:(IMP)0;\n+}\n+\n+IMP get_imp (Class class, SEL sel);\n+\n+/* Redefine on NeXTSTEP so as not to conflict with system function */\n+#ifdef __NeXT__\n+#define object_copy\tgnu_object_copy\n+#define object_dispose\tgnu_object_dispose\n+#endif\n+\n+id object_copy(id object);\n+\n+id object_dispose(id object);\n+\n+static inline Class\n+object_get_class(id object)\n+{\n+  return ((object!=nil)\n+\t  ? (CLS_ISCLASS(object->class_pointer)\n+\t     ? object->class_pointer\n+\t     : (CLS_ISMETA(object->class_pointer)\n+\t\t? (Class)object\n+\t\t: Nil))\n+\t  : Nil);\n+}\n+\n+static inline const char *\n+object_get_class_name(id object)\n+{\n+  return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n+                         ?object->class_pointer->name\n+                         :((Class)object)->name)\n+                       :\"Nil\");\n+}\n+\n+static inline MetaClass\n+object_get_meta_class(id object)\n+{\n+  return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n+                         ?object->class_pointer->class_pointer\n+                         :(CLS_ISMETA(object->class_pointer)\n+                           ?object->class_pointer\n+                           :Nil))\n+                       :Nil);\n+}\n+\n+static inline Class\n+object_get_super_class\n+(id object)\n+{\n+  return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n+                         ?object->class_pointer->super_class\n+                         :(CLS_ISMETA(object->class_pointer)\n+                           ?((Class)object)->super_class\n+                           :Nil))\n+                       :Nil);\n+}\n+\n+static inline BOOL\n+object_is_class(id object)\n+{\n+  return CLS_ISCLASS((Class)object);\n+}\n+\n+static inline BOOL\n+object_is_instance(id object)\n+{\n+  return (object!=nil)&&CLS_ISCLASS(object->class_pointer);\n+}\n+\n+static inline BOOL\n+object_is_meta_class(id object)\n+{\n+  return CLS_ISMETA((Class)object);\n+}\n+\n+struct sarray* \n+objc_get_uninstalled_dtable(void);\n+\n+#endif /* not __objc_api_INCLUDE_GNU */\n+\n+\n+"}, {"sha": "19760906238a42a7e341fd495beeb0dcc9448ca7", "filename": "libobjc/objc-list.h", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fobjc-list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fobjc-list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-list.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,147 @@\n+/* Generic single linked list to keep various information \n+   Copyright (C) 1993, 1994, 1996 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#ifndef __GNU_OBJC_LIST_H\n+#define __GNU_OBJC_LIST_H\n+\n+struct objc_list {\n+  void *head;\n+  struct objc_list *tail;\n+};\n+\n+/* Return a cons cell produced from (head . tail) */\n+\n+static inline struct objc_list* \n+list_cons(void* head, struct objc_list* tail)\n+{\n+  struct objc_list* cell;\n+\n+  cell = (struct objc_list*)objc_malloc(sizeof(struct objc_list));\n+  cell->head = head;\n+  cell->tail = tail;\n+  return cell;\n+}\n+\n+/* Return the length of a list, list_length(NULL) returns zero */\n+\n+static inline int\n+list_length(struct objc_list* list)\n+{\n+  int i = 0;\n+  while(list)\n+    {\n+      i += 1;\n+      list = list->tail;\n+    }\n+  return i;\n+}\n+\n+/* Return the Nth element of LIST, where N count from zero.  If N \n+   larger than the list length, NULL is returned  */\n+\n+static inline void*\n+list_nth(int index, struct objc_list* list)\n+{\n+  while(index-- != 0)\n+    {\n+      if(list->tail)\n+\tlist = list->tail;\n+      else\n+\treturn 0;\n+    }\n+  return list->head;\n+}\n+\n+/* Remove the element at the head by replacing it by its successor */\n+\n+static inline void\n+list_remove_head(struct objc_list** list)\n+{\n+  if ((*list)->tail)\n+    {\n+      struct objc_list* tail = (*list)->tail; /* fetch next */\n+      *(*list) = *tail;\t\t/* copy next to list head */\n+      objc_free(tail);\t\t\t/* free next */\n+    }\n+  else\t\t\t\t/* only one element in list */\n+    {\n+      objc_free(*list);\n+      (*list) = 0;\n+    }\n+}\n+\n+\n+/* Remove the element with `car' set to ELEMENT */\n+\n+static inline void\n+list_remove_elem(struct objc_list** list, void* elem)\n+{\n+  while (*list) {\n+    if ((*list)->head == elem)\n+      list_remove_head(list);\n+    list = &((*list)->tail);\n+  }\n+}\n+\n+/* Map FUNCTION over all elements in LIST */\n+\n+static inline void\n+list_mapcar(struct objc_list* list, void(*function)(void*))\n+{\n+  while(list)\n+    {\n+      (*function)(list->head);\n+      list = list->tail;\n+    }\n+}\n+\n+/* Return element that has ELEM as car */\n+\n+static inline struct objc_list**\n+list_find(struct objc_list** list, void* elem)\n+{\n+  while(*list)\n+    {\n+    if ((*list)->head == elem)\n+      return list;\n+    list = &((*list)->tail);\n+    }\n+  return NULL;\n+}\n+\n+/* Free list (backwards recursive) */\n+\n+static void\n+list_free(struct objc_list* list)\n+{\n+  if(list)\n+    {\n+      list_free(list->tail);\n+      objc_free(list);\n+    }\n+}\n+#endif __GNU_OBJC_LIST_H"}, {"sha": "79b2519e5765a223ab267a2d2171869af43f1fd2", "filename": "libobjc/objc.h", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fobjc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fobjc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,158 @@\n+/* Basic data types for Objective C.\n+   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __objc_INCLUDE_GNU\n+#define __objc_INCLUDE_GNU\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stddef.h>\n+\n+/*\n+** Definition of the boolean type.  \n+*/\n+#ifdef __vxworks\n+typedef int BOOL;\n+#else\n+typedef unsigned char  BOOL;\n+#endif\n+#define YES   (BOOL)1\n+#define NO    (BOOL)0\n+\n+/*\n+** Definition of a selector.  Selectors themselves are not unique, but\n+** the sel_id is a unique identifier.\n+*/\n+typedef const struct objc_selector \n+{\n+  void *sel_id;\n+  const char *sel_types;\n+} *SEL;\n+\n+inline static BOOL\n+sel_eq (SEL s1, SEL s2)\n+{\n+  if (s1 == 0 || s2 == 0)\n+    return s1 == s2;\n+  else\n+    return s1->sel_id == s2->sel_id;\n+}\n+\n+\n+/*\n+** ObjC uses this typedef for untyped instances.\n+*/\n+typedef struct objc_object {\n+  struct objc_class*  class_pointer;\n+} *id;\n+\n+/*\n+** Definition of method type.  When retrieving the implementation of a\n+** method, this is type of the pointer returned\n+*/\n+typedef id (*IMP)(id, SEL, ...); \n+\n+/*\n+** More simple types...\n+*/\n+#define nil (id)0                               /* id of Nil instance */\n+#define Nil (Class)0                            /* id of Nil class */\n+typedef char *STR;                              /* String alias */\n+\n+/*\n+** The compiler generates one of these structures for each class.  \n+** \n+** This structure is the definition for classes. \n+** \n+** This structure is generated by the compiler in the executable and used by\n+** the run-time during normal messaging operations.  Therefore some members\n+** change type. The compiler generates \"char* const\" and places a string in\n+** the following member variables:  super_class. \n+*/\n+typedef struct objc_class *MetaClass;\n+typedef struct objc_class *Class;\n+struct objc_class {     \n+  MetaClass           class_pointer;          /* Pointer to the class's\n+                                                meta class. */\n+  struct objc_class*  super_class;            /* Pointer to the super \n+                                                class. NULL for class \n+                                                Object. */\n+  const char*         name;                   /* Name of the class. */\n+  long                version;                /* Unknown. */\n+  unsigned long       info;                   /* Bit mask.  See class masks \n+                                                defined above. */\n+  long                instance_size;          /* Size in bytes of the class.  \n+                                                The sum of the class \n+\t\t\t\t\t\tdefinition and all super \n+\t\t\t\t\t\tclass definitions. */\n+  struct objc_ivar_list* ivars;               /* Pointer to a structure that\n+                                                describes the instance \n+                                                variables in the class\n+                                                definition.  NULL indicates\n+                                                no instance variables.  Does\n+                                                not include super class\n+                                                variables. */\n+  struct objc_method_list*  methods;          /* Linked list of instance\n+                                                methods defined for the \n+                                                class. */\n+  struct sarray *    dtable;                  /* Pointer to instance \n+\t\t\t\t\t         method dispatch table. */  \n+  struct objc_class* subclass_list;           /* Subclasses */\n+  struct objc_class* sibling_class;\n+\n+  struct objc_protocol_list *protocols;\t      /* Protocols conformed to */\n+  void* gc_object_type;\n+};\n+\n+#ifndef __OBJC__\n+typedef struct objc_protocol {\n+  struct objc_class* class_pointer;\n+  char *protocol_name;\n+  struct objc_protocol_list *protocol_list;\n+  struct objc_method_description_list *instance_methods, *class_methods; \n+} Protocol; \n+\n+#else /* __OBJC__ */\n+@class Protocol;\n+#endif \n+\n+typedef void* retval_t;\t\t/* return value */\n+typedef void(*apply_t)(void);\t/* function pointer */\n+typedef union {\n+  char *arg_ptr;\n+  char arg_regs[sizeof (char*)];\n+} *arglist_t;\t\t\t/* argument frame */\n+\n+\n+IMP objc_msg_lookup(id receiver, SEL op);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* not __objc_INCLUDE_GNU */"}, {"sha": "d079c5d4ec78be5dab523d1d93dde2c3a8ff9c37", "filename": "libobjc/objects.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fobjects.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fobjects.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjects.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,105 @@\n+/* GNU Objective C Runtime class related functions\n+   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"../tconfig.h\"         /* include defs of bzero for target */\n+#include \"objc.h\"\n+#include \"runtime.h\"\t\t/* the kitchen sink */\n+\n+#if OBJC_WITH_GC\n+# include <gc.h>\n+#endif\n+\n+id __objc_object_alloc(Class);\n+id __objc_object_dispose(id);\n+id __objc_object_copy(id);\n+\n+id (*_objc_object_alloc)(Class)   = __objc_object_alloc;   /* !T:SINGLE */ \n+id (*_objc_object_dispose)(id)    = __objc_object_dispose; /* !T:SINGLE */\n+id (*_objc_object_copy)(id)       = __objc_object_copy;    /* !T:SINGLE */\n+\n+id\n+class_create_instance(Class class)\n+{\n+  id new = nil;\n+\n+#if OBJC_WITH_GC\n+  if (CLS_ISCLASS(class))\n+    new = (id)GC_malloc_explicitly_typed (class->instance_size,\n+\t\t\t\t\t  class->gc_object_type);\n+#else\n+  if (CLS_ISCLASS(class))\n+    new = (*_objc_object_alloc)(class);\n+#endif\n+\n+  if (new!=nil)\n+    {\n+      memset (new, 0, class->instance_size);\n+      new->class_pointer = class;\n+    }\n+  return new;\n+}\n+\n+id\n+object_copy(id object)\n+{\n+  if ((object!=nil)&&CLS_ISCLASS(object->class_pointer))\n+    return (*_objc_object_copy)(object);\n+  else\n+    return nil;\n+}\n+\n+id\n+object_dispose(id object)\n+{\n+  if ((object!=nil)&&CLS_ISCLASS(object->class_pointer))\n+    {\n+      if (_objc_object_dispose)\n+        (*_objc_object_dispose)(object);\n+      else\n+        objc_free(object);\n+    }\n+  return nil;\n+}\n+\n+id __objc_object_alloc(Class class)\n+{\n+  return (id)objc_malloc(class->instance_size);\n+}\n+\n+id __objc_object_dispose(id object) \n+{\n+  objc_free(object);\n+  return 0;\n+}\n+\n+id __objc_object_copy(id object)\n+{\n+  id copy = class_create_instance(object->class_pointer);\n+  memcpy(copy, object, object->class_pointer->instance_size);\n+  return copy;\n+}\n+\n+"}, {"sha": "b0eae4a222d384642ba0dfc677ef86424d7f4183", "filename": "libobjc/runtime.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fruntime.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,88 @@\n+/* GNU Objective C Runtime internal declarations\n+   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#ifndef __objc_runtime_INCLUDE_GNU\n+#define __objc_runtime_INCLUDE_GNU\n+\n+#include <stdarg.h>\t\t/* for varargs and va_list's */\n+\n+#include <stdio.h>\n+#include <ctype.h>\n+\n+#include <stddef.h>\t\t/* so noone else will get system versions */\n+#include \"assert.h\"\n+\n+#include \"objc/objc.h\"\t\t/* core data types */\n+#include \"objc/objc-api.h\"\t/* runtime api functions */\n+\n+#include \"objc/thr.h\"\t\t/* thread and mutex support */\n+\n+#include \"objc/hash.h\"\t\t/* hash structures */\n+#include \"objc/objc-list.h\"\t/* linear lists */\n+\n+extern void __objc_add_class_to_hash(Class);   /* (objc-class.c) */\n+extern void __objc_init_selector_tables(void); /* (objc-sel.c) */\n+extern void __objc_init_class_tables(void);    /* (objc-class.c) */\n+extern void __objc_init_dispatch_tables(void); /* (objc-dispatch.c) */\n+extern void __objc_install_premature_dtable(Class); /* (objc-dispatch.c) */\n+extern void __objc_resolve_class_links(void);  /* (objc-class.c) */\n+extern void __objc_register_selectors_from_class(Class); /* (objc-sel.c) */\n+extern void __objc_update_dispatch_table_for_class (Class);/* (objc-msg.c) */\n+\n+extern int  __objc_init_thread_system(void);    /* thread.c */\n+extern int  __objc_fini_thread_system(void);    /* thread.c */\n+extern void __objc_print_dtable_stats(void);    /* sendmsg.c */\n+\n+extern void class_add_method_list(Class, MethodList_t);\n+\n+/* Registering instance methods as class methods for root classes */\n+extern void __objc_register_instance_methods_to_class(Class);\n+extern Method_t search_for_method_in_list(MethodList_t list, SEL op);\n+\n+/* True when class links has been resolved */     \n+extern BOOL __objc_class_links_resolved;\n+\n+/* Number of selectors stored in each of the selector  tables */\n+extern int __objc_selector_max_index;\n+\n+/* Mutex locking __objc_selector_max_index and its arrays. */\n+extern objc_mutex_t __objc_runtime_mutex;\n+\n+/* Number of threads which are alive. */\n+extern int __objc_runtime_threads_alive;\n+\n+#ifdef DEBUG\n+#define DEBUG_PRINTF(format, args...) printf (format, ## args)\n+#else\n+#define DEBUG_PRINTF(format, args...)\n+#endif \n+\n+BOOL __objc_responds_to (id object, SEL sel); /* for internal use only! */\n+SEL  __sel_register_typed_name (const char*, const char*, \n+\t\t\t\tstruct objc_selector*, BOOL is_const);\n+\n+#endif /* not __objc_runtime_INCLUDE_GNU */\n+\n+"}, {"sha": "7e40fba750f6b1e80044f48baccf5e2975d8da43", "filename": "libobjc/sarray.c", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fsarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fsarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsarray.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,522 @@\n+/* Sparse Arrays for Objective C dispatch tables\n+   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#include \"objc/sarray.h\"\n+#include \"objc/runtime.h\"\n+#include <stdio.h>\n+#include \"assert.h\"\n+\n+int nbuckets = 0;\t\t\t\t\t/* !T:MUTEX */\n+int nindices = 0;\t\t\t\t\t/* !T:MUTEX */\n+int narrays = 0;\t\t\t\t\t/* !T:MUTEX */\n+int idxsize = 0;\t\t\t\t\t/* !T:MUTEX */\n+\n+static void *\tfirst_free_data = NULL;\t\t\t/* !T:MUTEX */\n+\n+#ifdef OBJC_SPARSE2\n+const char* __objc_sparse2_id = \"2 level sparse indices\";\n+#endif\n+\n+#ifdef OBJC_SPARSE3\n+const char* __objc_sparse3_id = \"3 level sparse indices\";\n+#endif\n+\n+#ifdef __alpha__\n+const void *memcpy (void*, const void*, size_t);\n+#endif\n+\n+/* This function removes any structures left over from free operations\n+   that were not safe in a multi-threaded environment. */\n+void\n+sarray_remove_garbage(void)\n+{\n+  void **vp;\n+  void *np;\n+  \n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  vp = first_free_data;\n+  first_free_data = NULL;\n+\n+  while (vp) {\n+    np = *vp;\n+    objc_free(vp);\n+    vp = np;\n+  }\n+  \n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}\n+\n+/* Free a block of dynamically allocated memory.  If we are in multi-threaded\n+   mode, it is ok to free it.  If not, we add it to the garbage heap to be\n+   freed later. */\n+\n+static void\n+sarray_free_garbage(void *vp)\n+{\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  \n+  if (__objc_runtime_threads_alive == 1) {\n+    objc_free(vp);\n+    if (first_free_data)\n+      sarray_remove_garbage();\n+  }\n+  else {\n+    *(void **)vp = first_free_data;\n+    first_free_data = vp;\n+  }\n+      \n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}\n+\n+/* sarray_at_put : copies data in such a way as to be thread reader safe. */\n+void\n+sarray_at_put(struct sarray* array, sidx index, void* element)\n+{\n+#ifdef OBJC_SPARSE3\n+  struct sindex** the_index;\n+  struct sindex*  new_index;\n+#endif\n+  struct sbucket** the_bucket;\n+  struct sbucket*  new_bucket;\n+#ifdef OBJC_SPARSE3\n+  size_t ioffset;\n+#endif\n+  size_t boffset;\n+  size_t eoffset;\n+#ifdef PRECOMPUTE_SELECTORS\n+  union sofftype xx; \n+  xx.idx = index;\n+#ifdef OBJC_SPARSE3\n+  ioffset = xx.off.ioffset;\n+#endif\n+  boffset = xx.off.boffset;\n+  eoffset = xx.off.eoffset;\n+#else /* not PRECOMPUTE_SELECTORS */\n+#ifdef OBJC_SPARSE3\n+  ioffset = index/INDEX_CAPACITY;\n+  boffset = (index/BUCKET_SIZE)%INDEX_SIZE;\n+  eoffset = index%BUCKET_SIZE;\n+#else\n+  boffset = index/BUCKET_SIZE;\n+  eoffset = index%BUCKET_SIZE;\n+#endif\n+#endif /* not PRECOMPUTE_SELECTORS */\n+\n+  assert(soffset_decode(index) < array->capacity); /* Range check */\n+\n+#ifdef OBJC_SPARSE3\n+  the_index = &(array->indices[ioffset]);\n+  the_bucket = &((*the_index)->buckets[boffset]);\n+#else\n+  the_bucket = &(array->buckets[boffset]);\n+#endif\n+  \n+  if ((*the_bucket)->elems[eoffset] == element)\n+    return;\t\t/* great! we just avoided a lazy copy */\n+\n+#ifdef OBJC_SPARSE3\n+\n+  /* First, perform lazy copy/allocation of index if needed */\n+\n+  if ((*the_index) == array->empty_index) {\n+\n+    /* The index was previously empty, allocate a new */\n+    new_index = (struct sindex*)objc_malloc(sizeof(struct sindex));\n+    memcpy(new_index, array->empty_index, sizeof(struct sindex));\n+    new_index->version.version = array->version.version;\n+    *the_index = new_index;                     /* Prepared for install. */\n+    the_bucket = &((*the_index)->buckets[boffset]);\n+    \n+    nindices += 1;\n+  } else if ((*the_index)->version.version != array->version.version) {\n+\n+    /* This index must be lazy copied */\n+    struct sindex* old_index = *the_index;\n+    new_index = (struct sindex*)objc_malloc(sizeof(struct sindex));\n+    memcpy( new_index, old_index, sizeof(struct sindex));\n+    new_index->version.version = array->version.version;\n+    *the_index = new_index;                     /* Prepared for install. */\n+    the_bucket = &((*the_index)->buckets[boffset]);\n+    \n+    nindices += 1;\n+  }\n+\n+#endif /* OBJC_SPARSE3 */\n+\n+  /* next, perform lazy allocation/copy of the bucket if needed */\n+\n+  if ((*the_bucket) == array->empty_bucket) {\n+\n+    /* The bucket was previously empty (or something like that), */\n+    /* allocate a new.  This is the effect of `lazy' allocation */  \n+    new_bucket = (struct sbucket*)objc_malloc(sizeof(struct sbucket));\n+    memcpy((void *) new_bucket, (const void*)array->empty_bucket, \n+\t   sizeof(struct sbucket));\n+    new_bucket->version.version = array->version.version;\n+    *the_bucket = new_bucket;                   /* Prepared for install. */\n+    \n+    nbuckets += 1;\n+\n+  } else if ((*the_bucket)->version.version != array->version.version) {\n+\n+    /* Perform lazy copy. */\n+    struct sbucket* old_bucket = *the_bucket;\n+    new_bucket = (struct sbucket*)objc_malloc(sizeof(struct sbucket));\n+    memcpy( new_bucket, old_bucket, sizeof(struct sbucket));\n+    new_bucket->version.version = array->version.version;\n+    *the_bucket = new_bucket;                   /* Prepared for install. */\n+    \n+    nbuckets += 1;\n+\n+  }\n+  (*the_bucket)->elems[eoffset] = element;\n+}\n+\n+void\n+sarray_at_put_safe(struct sarray* array, sidx index, void* element)\n+{\n+  if(soffset_decode(index) >= array->capacity)\n+    sarray_realloc(array, soffset_decode(index)+1);\n+  sarray_at_put(array, index, element);\n+}\n+\n+struct sarray* \n+sarray_new (int size, void* default_element)\n+{\n+  struct sarray* arr;\n+#ifdef OBJC_SPARSE3\n+  size_t num_indices = ((size-1)/(INDEX_CAPACITY))+1;\n+  struct sindex ** new_indices;\n+#else /* OBJC_SPARSE2 */\n+  size_t num_indices = ((size-1)/BUCKET_SIZE)+1;\n+  struct sbucket ** new_buckets;\n+#endif\n+  int counter;\n+\n+  assert(size > 0);\n+\n+  /* Allocate core array */\n+  arr = (struct sarray*) objc_malloc(sizeof(struct sarray));\n+  arr->version.version = 0;\n+  \n+  /* Initialize members */\n+#ifdef OBJC_SPARSE3\n+  arr->capacity = num_indices*INDEX_CAPACITY;\n+  new_indices = (struct sindex**) \n+    objc_malloc(sizeof(struct sindex*)*num_indices);\n+\n+  arr->empty_index = (struct sindex*) objc_malloc(sizeof(struct sindex));\n+  arr->empty_index->version.version = 0;\n+  \n+  narrays  += 1;\n+  idxsize  += num_indices;\n+  nindices += 1;\n+\n+#else /* OBJC_SPARSE2 */\n+  arr->capacity = num_indices*BUCKET_SIZE;\n+  new_buckets = (struct sbucket**) \n+    objc_malloc(sizeof(struct sbucket*)*num_indices);\n+  \n+  narrays  += 1;\n+  idxsize  += num_indices;\n+\n+#endif\n+\n+  arr->empty_bucket = (struct sbucket*) objc_malloc(sizeof(struct sbucket));\n+  arr->empty_bucket->version.version = 0;\n+  \n+  nbuckets += 1;\n+\n+  arr->ref_count = 1;\n+  arr->is_copy_of = (struct sarray*)0;\n+  \n+  for (counter=0; counter<BUCKET_SIZE; counter++)\n+    arr->empty_bucket->elems[counter] = default_element;\n+\n+#ifdef OBJC_SPARSE3\n+  for (counter=0; counter<INDEX_SIZE; counter++)\n+    arr->empty_index->buckets[counter] = arr->empty_bucket;\n+\n+  for (counter=0; counter<num_indices; counter++)\n+    new_indices[counter] = arr->empty_index;\n+\n+#else /* OBJC_SPARSE2 */\n+\n+  for (counter=0; counter<num_indices; counter++)\n+    new_buckets[counter] = arr->empty_bucket;\n+\n+#endif\n+  \n+#ifdef OBJC_SPARSE3\n+  arr->indices = new_indices;\n+#else /* OBJC_SPARSE2 */\n+  arr->buckets = new_buckets;\n+#endif\n+  \n+  return arr;\n+}\n+\f\n+\n+/* Reallocate the sparse array to hold `newsize' entries\n+   Note: We really allocate and then free.  We have to do this to ensure that\n+   any concurrent readers notice the update. */\n+\n+void \n+sarray_realloc(struct sarray* array, int newsize)\n+{\n+#ifdef OBJC_SPARSE3\n+  size_t old_max_index = (array->capacity-1)/INDEX_CAPACITY;\n+  size_t new_max_index = ((newsize-1)/INDEX_CAPACITY);\n+  size_t rounded_size = (new_max_index+1)*INDEX_CAPACITY;\n+\n+  struct sindex ** new_indices;\n+  struct sindex ** old_indices;\n+  \n+#else /* OBJC_SPARSE2 */\n+  size_t old_max_index = (array->capacity-1)/BUCKET_SIZE;\n+  size_t new_max_index = ((newsize-1)/BUCKET_SIZE);\n+  size_t rounded_size = (new_max_index+1)*BUCKET_SIZE;\n+\n+  struct sbucket ** new_buckets;\n+  struct sbucket ** old_buckets;\n+  \n+#endif\n+\n+  int counter;\n+\n+  assert(newsize > 0);\n+\n+  /* The size is the same, just ignore the request */\n+  if(rounded_size <= array->capacity)\n+    return;\n+\n+  assert(array->ref_count == 1);\t/* stop if lazy copied... */\n+\n+  /* We are asked to extend the array -- allocate new bucket table, */\n+  /* and insert empty_bucket in newly allocated places. */\n+  if(rounded_size > array->capacity) \n+    {\n+\n+#ifdef OBJC_SPARSE3\n+      new_max_index += 4;\n+      rounded_size = (new_max_index+1)*INDEX_CAPACITY;\n+      \n+#else /* OBJC_SPARSE2 */\n+      new_max_index += 4;\n+      rounded_size = (new_max_index+1)*BUCKET_SIZE;\n+#endif\n+      \n+      /* update capacity */\n+      array->capacity = rounded_size;\n+\n+#ifdef OBJC_SPARSE3\n+      /* alloc to force re-read by any concurrent readers. */\n+      old_indices = array->indices;\n+      new_indices = (struct sindex**)\n+\tobjc_malloc((new_max_index+1)*sizeof(struct sindex*));\n+#else /* OBJC_SPARSE2 */\n+      old_buckets = array->buckets;\n+      new_buckets = (struct sbucket**)\n+\tobjc_malloc((new_max_index+1)*sizeof(struct sbucket*));\n+#endif\n+\n+      /* copy buckets below old_max_index (they are still valid) */\n+      for(counter = 0; counter <= old_max_index; counter++ ) {\n+#ifdef OBJC_SPARSE3\n+\tnew_indices[counter] = old_indices[counter];\n+#else /* OBJC_SPARSE2 */\n+\tnew_buckets[counter] = old_buckets[counter];\n+#endif\n+      }\n+\n+#ifdef OBJC_SPARSE3\n+      /* reset entries above old_max_index to empty_bucket */\n+      for(counter = old_max_index+1; counter <= new_max_index; counter++)\n+\tnew_indices[counter] = array->empty_index;\n+#else /* OBJC_SPARSE2 */\n+      /* reset entries above old_max_index to empty_bucket */\n+      for(counter = old_max_index+1; counter <= new_max_index; counter++)\n+\tnew_buckets[counter] = array->empty_bucket;\n+#endif\n+      \n+#ifdef OBJC_SPARSE3\n+      /* install the new indices */\n+      array->indices = new_indices;\n+#else /* OBJC_SPARSE2 */\n+      array->buckets = new_buckets;\n+#endif\n+\n+#ifdef OBJC_SPARSE3\n+      /* free the old indices */\n+      sarray_free_garbage(old_indices);\n+#else /* OBJC_SPARSE2 */\n+      sarray_free_garbage(old_buckets);\n+#endif\n+      \n+      idxsize += (new_max_index-old_max_index);\n+      return;\n+    }\n+}\n+\f\n+\n+/* Free a sparse array allocated with sarray_new */\n+\n+void \n+sarray_free(struct sarray* array) {\n+\n+#ifdef OBJC_SPARSE3\n+  size_t old_max_index = (array->capacity-1)/INDEX_CAPACITY;\n+  struct sindex ** old_indices;\n+#else\n+  size_t old_max_index = (array->capacity-1)/BUCKET_SIZE;\n+  struct sbucket ** old_buckets;\n+#endif\n+  int counter = 0;\n+\n+  assert(array->ref_count != 0);\t/* Freed multiple times!!! */\n+\n+  if(--(array->ref_count) != 0)\t/* There exists copies of me */\n+    return;\n+\n+#ifdef OBJC_SPARSE3\n+  old_indices = array->indices;\n+#else\n+  old_buckets = array->buckets;\n+#endif\n+  \n+  if((array->is_copy_of) && ((array->is_copy_of->ref_count - 1) == 0))\n+    sarray_free(array->is_copy_of);\n+\n+  /* Free all entries that do not point to empty_bucket */\n+  for(counter = 0; counter <= old_max_index; counter++ ) {\n+#ifdef OBJC_SPARSE3\n+    struct sindex* idx = old_indices[counter];\n+    if((idx != array->empty_index) &&\n+       (idx->version.version == array->version.version)) {\n+      int c2; \n+      for(c2=0; c2<INDEX_SIZE; c2++) {\n+\tstruct sbucket* bkt = idx->buckets[c2];\n+\tif((bkt != array->empty_bucket) &&\n+\t   (bkt->version.version == array->version.version))\n+\t  {\n+\t    sarray_free_garbage(bkt);\n+\t    nbuckets -= 1;\n+\t  }\n+      }\n+      sarray_free_garbage(idx);\n+      nindices -= 1;\n+    }\n+#else /* OBJC_SPARSE2 */\n+    struct sbucket* bkt = array->buckets[counter];\n+    if ((bkt != array->empty_bucket) &&\n+\t(bkt->version.version == array->version.version))\n+      {\n+\tsarray_free_garbage(bkt);\n+\tnbuckets -= 1;\n+      }\n+#endif\n+  }\n+\t\n+#ifdef OBJC_SPARSE3  \n+  /* free empty_index */\n+  if(array->empty_index->version.version == array->version.version) {\n+    sarray_free_garbage(array->empty_index);\n+    nindices -= 1;\n+  }\n+#endif\n+\n+  /* free empty_bucket */\n+  if(array->empty_bucket->version.version == array->version.version) {\n+    sarray_free_garbage(array->empty_bucket);\n+    nbuckets -= 1;\n+  }\n+  idxsize -= (old_max_index+1);\n+  narrays -= 1;\n+\n+#ifdef OBJC_SPARSE3\n+  /* free bucket table */\n+  sarray_free_garbage(array->indices);\n+\n+#else\n+  /* free bucket table */\n+  sarray_free_garbage(array->buckets);\n+\n+#endif\n+  \n+  /* free array */\n+  sarray_free_garbage(array);\n+}\n+\n+/* This is a lazy copy.  Only the core of the structure is actually */\n+/* copied.   */\n+\n+struct sarray* \n+sarray_lazy_copy(struct sarray* oarr)\n+{\n+  struct sarray* arr;\n+\n+#ifdef OBJC_SPARSE3\n+  size_t num_indices = ((oarr->capacity-1)/INDEX_CAPACITY)+1;\n+  struct sindex ** new_indices;\n+#else /* OBJC_SPARSE2 */\n+  size_t num_indices = ((oarr->capacity-1)/BUCKET_SIZE)+1;\n+  struct sbucket ** new_buckets;\n+#endif\n+\n+  /* Allocate core array */\n+  arr = (struct sarray*) objc_malloc(sizeof(struct sarray)); /* !!! */\n+  arr->version.version = oarr->version.version + 1;\n+#ifdef OBJC_SPARSE3\n+  arr->empty_index = oarr->empty_index;\n+#endif\n+  arr->empty_bucket = oarr->empty_bucket;\n+  arr->ref_count = 1;\n+  oarr->ref_count += 1;\n+  arr->is_copy_of = oarr;\n+  arr->capacity = oarr->capacity;\n+  \n+#ifdef OBJC_SPARSE3\n+  /* Copy bucket table */\n+  new_indices = (struct sindex**) \n+    objc_malloc(sizeof(struct sindex*)*num_indices);\n+  memcpy( new_indices,oarr->indices, \n+\tsizeof(struct sindex*)*num_indices);\n+  arr->indices = new_indices;\n+#else \n+  /* Copy bucket table */\n+  new_buckets = (struct sbucket**) \n+    objc_malloc(sizeof(struct sbucket*)*num_indices);\n+  memcpy( new_buckets,oarr->buckets, \n+\tsizeof(struct sbucket*)*num_indices);\n+  arr->buckets = new_buckets;\n+#endif\n+\n+  idxsize += num_indices;\n+  narrays += 1;\n+  \n+  return arr;\n+}"}, {"sha": "74fa38652ba35e086ed8e89a5d0dddf5322ff87e", "filename": "libobjc/sarray.h", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fsarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fsarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsarray.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,237 @@\n+/* Sparse Arrays for Objective C dispatch tables\n+   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __sarray_INCLUDE_GNU\n+#define __sarray_INCLUDE_GNU\n+\n+#define OBJC_SPARSE2\t\t/* 2-level sparse array */\n+/* #define OBJC_SPARSE3 */      /* 3-level sparse array */\n+\n+#ifdef OBJC_SPARSE2\n+extern const char* __objc_sparse2_id;\n+#endif\n+\n+#ifdef OBJC_SPARSE3\n+extern const char* __objc_sparse3_id;\n+#endif\n+\n+#include <stddef.h>\n+\n+#include \"objc/thr.h\"\n+\n+extern int nbuckets;\t\t/* for stats */\n+extern int nindices;\n+extern int narrays;\n+extern int idxsize;\n+\n+#include <assert.h>\n+\n+/* An unsigned integer of same size as a pointer */\n+#define SIZET_BITS (sizeof(size_t)*8)\n+\n+#if defined(__sparc__) || defined(OBJC_SPARSE2)\n+#define PRECOMPUTE_SELECTORS\n+#endif\n+\n+#ifdef OBJC_SPARSE3\n+\n+/* Buckets are 8 words each */\n+#define BUCKET_BITS 3\n+#define BUCKET_SIZE (1<<BUCKET_BITS)\n+#define BUCKET_MASK (BUCKET_SIZE-1)\n+\n+/* Indices are 16 words each */\n+#define INDEX_BITS 4\n+#define INDEX_SIZE (1<<INDEX_BITS)\n+#define INDEX_MASK (INDEX_SIZE-1)\n+\n+#define INDEX_CAPACITY (BUCKET_SIZE*INDEX_SIZE)\n+\n+#else /* OBJC_SPARSE2 */\n+\n+/* Buckets are 32 words each */\n+#define BUCKET_BITS 5\n+#define BUCKET_SIZE (1<<BUCKET_BITS)\n+#define BUCKET_MASK (BUCKET_SIZE-1)\n+\n+#endif /* OBJC_SPARSE2 */\n+\n+typedef size_t sidx;\n+\n+#ifdef PRECOMPUTE_SELECTORS\n+\n+struct soffset {\n+#ifdef OBJC_SPARSE3\n+  unsigned int unused : SIZET_BITS/4;\n+  unsigned int eoffset : SIZET_BITS/4;\n+  unsigned int boffset : SIZET_BITS/4;\n+  unsigned int ioffset : SIZET_BITS/4;\n+#else /* OBJC_SPARSE2 */\n+#ifdef __sparc__\n+  unsigned int boffset : (SIZET_BITS - 2) - BUCKET_BITS;\n+  unsigned int eoffset : BUCKET_BITS;\n+  unsigned int unused  : 2;\n+#else\n+  unsigned int boffset : SIZET_BITS/2;\n+  unsigned int eoffset : SIZET_BITS/2;\n+#endif\n+#endif /* OBJC_SPARSE2 */\n+};\n+\n+union sofftype {\n+  struct soffset off;\n+  sidx idx;\n+};\n+\n+#endif /* not PRECOMPUTE_SELECTORS */\n+\n+union sversion {\n+  int\tversion;\n+  void *next_free;\n+};\n+\n+struct sbucket {\n+  void* elems[BUCKET_SIZE];\t/* elements stored in array */\n+  union sversion\tversion;\t\t/* used for copy-on-write */\n+};\n+\n+#ifdef OBJC_SPARSE3\n+\n+struct sindex {\n+  struct sbucket* buckets[INDEX_SIZE];\n+  union sversion\tversion;\t\t/* used for copy-on-write */\n+};\n+\n+#endif /* OBJC_SPARSE3 */\n+\n+struct sarray {\n+#ifdef OBJC_SPARSE3\n+  struct sindex** indices;\n+  struct sindex* empty_index;\n+#else /* OBJC_SPARSE2 */\n+  struct sbucket** buckets;\n+#endif  /* OBJC_SPARSE2 */\n+  struct sbucket* empty_bucket;\n+  union sversion\tversion;\t\t/* used for copy-on-write */\n+  short ref_count;\n+  struct sarray* is_copy_of;\n+  size_t capacity;\n+};\n+\n+struct sarray* sarray_new(int, void* default_element);\n+void sarray_free(struct sarray*);\n+struct sarray* sarray_lazy_copy(struct sarray*);\n+void sarray_realloc(struct sarray*, int new_size);\n+void sarray_at_put(struct sarray*, sidx index, void* elem);\n+void sarray_at_put_safe(struct sarray*, sidx index, void* elem);\n+\n+struct sarray* sarray_hard_copy(struct sarray*); /* ... like the name? */\n+void sarray_remove_garbage(void);\n+\f\n+\n+#ifdef PRECOMPUTE_SELECTORS\n+/* Transform soffset values to ints and vica verca */\n+static inline unsigned int\n+soffset_decode(sidx index)\n+{\n+  union sofftype x;\n+  x.idx = index;\n+#ifdef OBJC_SPARSE3\n+  return x.off.eoffset\n+    + (x.off.boffset*BUCKET_SIZE)\n+      + (x.off.ioffset*INDEX_CAPACITY);\n+#else /* OBJC_SPARSE2 */\n+  return x.off.eoffset + (x.off.boffset*BUCKET_SIZE);\n+#endif /* OBJC_SPARSE2 */\n+}\n+\n+static inline sidx\n+soffset_encode(size_t offset)\n+{\n+  union sofftype x;\n+  x.off.eoffset = offset%BUCKET_SIZE;\n+#ifdef OBJC_SPARSE3\n+  x.off.boffset = (offset/BUCKET_SIZE)%INDEX_SIZE;\n+  x.off.ioffset = offset/INDEX_CAPACITY;\n+#else /* OBJC_SPARSE2 */\n+  x.off.boffset = offset/BUCKET_SIZE;\n+#endif\n+  return (sidx)x.idx;\n+}\n+\n+#else /* not PRECOMPUTE_SELECTORS */\n+\n+static inline size_t\n+soffset_decode(sidx index)\n+{\n+  return index;\n+}\n+\n+static inline sidx\n+soffset_encode(size_t offset)\n+{\n+  return offset;\n+}\n+#endif /* not PRECOMPUTE_SELECTORS */\n+\n+/* Get element from the Sparse array `array' at offset `index' */\n+\n+static inline void* sarray_get(struct sarray* array, sidx index)\n+{\n+#ifdef PRECOMPUTE_SELECTORS\n+  union sofftype x;\n+  x.idx = index;\n+#ifdef OBJC_SPARSE3\n+  return \n+    array->\n+      indices[x.off.ioffset]->\n+\tbuckets[x.off.boffset]->\n+\t  elems[x.off.eoffset];\n+#else /* OBJC_SPARSE2 */\n+  return array->buckets[x.off.boffset]->elems[x.off.eoffset];\n+#endif /* OBJC_SPARSE2 */\n+#else /* not PRECOMPUTE_SELECTORS */\n+#ifdef OBJC_SPARSE3\n+  return array->\n+    indices[index/INDEX_CAPACITY]->\n+      buckets[(index/BUCKET_SIZE)%INDEX_SIZE]->\n+\telems[index%BUCKET_SIZE];\n+#else /* OBJC_SPARSE2 */\n+  return array->buckets[index/BUCKET_SIZE]->elems[index%BUCKET_SIZE];\n+#endif /* not OBJC_SPARSE3 */\n+#endif /* not PRECOMPUTE_SELECTORS */\n+}\n+\n+static inline void* sarray_get_safe(struct sarray* array, sidx index)\n+{\n+  if(soffset_decode(index) < array->capacity)\n+    return sarray_get(array, index);\n+  else\n+    return (array->empty_bucket->elems[0]);\n+}\n+\n+#endif /* __sarray_INCLUDE_GNU */"}, {"sha": "83c70e4ae0f17579e29c7ed3663069da3b87394a", "filename": "libobjc/selector.c", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fselector.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,458 @@\n+/* GNU Objective C Runtime selector related functions\n+   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"runtime.h\"\n+#include \"objc/sarray.h\"\n+#include \"encoding.h\"\n+\n+/* Initial selector hash table size. Value doesn't matter much */\n+#define SELECTOR_HASH_SIZE 128\n+\n+/* Tables mapping selector names to uid and opposite */\n+static struct sarray* __objc_selector_array = 0; /* uid -> sel  !T:MUTEX */\n+static struct sarray* __objc_selector_names = 0; /* uid -> name !T:MUTEX */\n+static cache_ptr      __objc_selector_hash  = 0; /* name -> uid !T:MUTEX */\n+\n+static void register_selectors_from_list(MethodList_t);\n+\n+/* Number of selectors stored in each of the above tables */\n+int __objc_selector_max_index = 0;              /* !T:MUTEX */\n+\n+void __objc_init_selector_tables()\n+{\n+  __objc_selector_array = sarray_new (SELECTOR_HASH_SIZE, 0);\n+  __objc_selector_names = sarray_new (SELECTOR_HASH_SIZE, 0);\n+  __objc_selector_hash\n+    = hash_new (SELECTOR_HASH_SIZE,\n+\t\t(hash_func_type) hash_string,\n+\t\t(compare_func_type) compare_strings);\n+}  \n+\n+/* This routine is given a class and records all of the methods in its class\n+   structure in the record table.  */\n+void\n+__objc_register_selectors_from_class (Class class)\n+{\n+  MethodList_t method_list;\n+\n+  method_list = class->methods;\n+  while (method_list)\n+    {\n+      register_selectors_from_list (method_list);\n+      method_list = method_list->method_next;\n+    }\n+}\n+\n+\n+/* This routine is given a list of methods and records each of the methods in\n+   the record table.  This is the routine that does the actual recording\n+   work.\n+\n+   This one is only called for Class objects.  For categories,\n+   class_add_method_list is called.\n+   */\n+static void\n+register_selectors_from_list (MethodList_t method_list)\n+{\n+  int i = 0;\n+  while (i < method_list->method_count)\n+    {\n+      Method_t method = &method_list->method_list[i];\n+      method->method_name \n+\t= sel_register_typed_name ((const char*)method->method_name, \n+\t\t\t\t     method->method_types);\n+      i += 1;\n+    }\n+}\n+\n+\n+/* Register instance methods as class methods for root classes */\n+void __objc_register_instance_methods_to_class(Class class)\n+{\n+  MethodList_t method_list;\n+  MethodList_t class_method_list;\n+  int max_methods_no = 16;\n+  MethodList_t new_list;\n+  Method_t curr_method;\n+\n+  /* Only if a root class. */\n+  if(class->super_class)\n+    return;\n+\n+  /* Allocate a method list to hold the new class methods */\n+  new_list = objc_calloc(sizeof(struct objc_method_list)\n+\t\t\t    + sizeof(struct objc_method[max_methods_no]), 1);\n+  method_list = class->methods;\n+  class_method_list = class->class_pointer->methods;\n+  curr_method = &new_list->method_list[0];\n+\n+  /* Iterate through the method lists for the class */\n+  while (method_list)\n+    {\n+      int i;\n+\n+      /* Iterate through the methods from this method list */\n+      for (i = 0; i < method_list->method_count; i++)\n+\t{\n+\t  Method_t mth = &method_list->method_list[i];\n+\t  if (mth->method_name\n+\t      && !search_for_method_in_list (class_method_list,\n+\t\t\t\t\t      mth->method_name))\n+\t    {\n+\t      /* This instance method isn't a class method. \n+\t\t  Add it into the new_list. */\n+\t      *curr_method = *mth;\n+  \n+\t      /* Reallocate the method list if necessary */\n+\t      if(++new_list->method_count == max_methods_no)\n+\t\tnew_list =\n+\t\t  objc_realloc(new_list, sizeof(struct objc_method_list)\n+\t\t\t\t+ sizeof(struct \n+\t\t\t\t\tobjc_method[max_methods_no += 16]));\n+\t      curr_method = &new_list->method_list[new_list->method_count];\n+\t    }\n+\t}\n+\n+      method_list = method_list->method_next;\n+    }\n+\n+  /* If we created any new class methods\n+     then attach the method list to the class */\n+  if (new_list->method_count)\n+    {\n+      new_list =\n+ \tobjc_realloc(new_list, sizeof(struct objc_method_list)\n+\t\t     + sizeof(struct objc_method[new_list->method_count]));\n+      new_list->method_next = class->class_pointer->methods;\n+      class->class_pointer->methods = new_list;\n+    }\n+\n+    __objc_update_dispatch_table_for_class (class->class_pointer);\n+}\n+\n+\n+/* Returns YES iff t1 and t2 have same method types, but we ignore\n+   the argframe layout */\n+BOOL\n+sel_types_match (const char* t1, const char* t2)\n+{\n+  if (!t1 || !t2)\n+    return NO;\n+  while (*t1 && *t2)\n+    {\n+      if (*t1 == '+') t1++;\n+      if (*t2 == '+') t2++;\n+      while (isdigit(*t1)) t1++;\n+      while (isdigit(*t2)) t2++;\n+      /* xxx Remove these next two lines when qualifiers are put in\n+\t all selectors, not just Protocol selectors. */\n+      t1 = objc_skip_type_qualifiers(t1);\n+      t2 = objc_skip_type_qualifiers(t2);\n+      if (!*t1 && !*t2)\n+\treturn YES;\n+      if (*t1 != *t2)\n+\treturn NO;\n+      t1++;\n+      t2++;\n+    }\n+  return NO;\n+}\n+\n+/* return selector representing name */\n+SEL\n+sel_get_typed_uid (const char *name, const char *types)\n+{\n+  struct objc_list *l;\n+  sidx i;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n+  if (i == 0)\n+    {\n+      objc_mutex_unlock(__objc_runtime_mutex);\n+      return 0;\n+    }\n+\n+  for (l = (struct objc_list*)sarray_get_safe (__objc_selector_array, i);\n+       l; l = l->tail)\n+    {\n+      SEL s = (SEL)l->head;\n+      if (types == 0 || s->sel_types == 0)\n+\t{\n+\t  if (s->sel_types == types)\n+\t    {\n+\t      objc_mutex_unlock(__objc_runtime_mutex);\n+\t      return s;\n+\t    }\n+\t}\n+      else if (sel_types_match (s->sel_types, types))\n+\t{\n+\t  objc_mutex_unlock(__objc_runtime_mutex);\n+\t  return s;\n+\t}\n+    }\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+  return 0;\n+}\n+\n+/* Return selector representing name; prefer a selector with non-NULL type */\n+SEL\n+sel_get_any_typed_uid (const char *name)\n+{\n+  struct objc_list *l;\n+  sidx i;\n+  SEL s = NULL;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n+  if (i == 0)\n+    {\n+      objc_mutex_unlock(__objc_runtime_mutex);\n+      return 0;\n+    }\n+\n+  for (l = (struct objc_list*)sarray_get_safe (__objc_selector_array, i);\n+       l; l = l->tail)\n+    {\n+      s = (SEL) l->head;\n+      if (s->sel_types)\n+\t{\n+\t    objc_mutex_unlock(__objc_runtime_mutex);\n+\t    return s;\n+\t}\n+    }\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+  return s;\n+}\n+\n+/* return selector representing name */\n+SEL\n+sel_get_any_uid (const char *name)\n+{\n+  struct objc_list *l;\n+  sidx i;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n+  if (soffset_decode (i) == 0)\n+    {\n+      objc_mutex_unlock(__objc_runtime_mutex);\n+      return 0;\n+    }\n+\n+  l = (struct objc_list*)sarray_get_safe (__objc_selector_array, i);\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n+  if (l == 0)\n+    return 0;\n+\n+  return (SEL)l->head;\n+}\n+\n+/* return selector representing name */\n+SEL\n+sel_get_uid (const char *name)\n+{\n+  return sel_register_typed_name (name, 0);\n+}\n+\n+/* Get name of selector.  If selector is unknown, the empty string \"\" \n+   is returned */ \n+const char*\n+sel_get_name (SEL selector)\n+{\n+  const char *ret;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  if ((soffset_decode((sidx)selector->sel_id) > 0)\n+      && (soffset_decode((sidx)selector->sel_id) <= __objc_selector_max_index))\n+    ret = sarray_get_safe (__objc_selector_names, (sidx) selector->sel_id);\n+  else\n+    ret = 0;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+  return ret;\n+}\n+\n+BOOL\n+sel_is_mapped (SEL selector)\n+{\n+  unsigned int idx = soffset_decode ((sidx)selector->sel_id);\n+  return ((idx > 0) && (idx <= __objc_selector_max_index));\n+}\n+\n+\n+const char*\n+sel_get_type (SEL selector)\n+{\n+  if (selector)\n+    return selector->sel_types;\n+  else\n+    return 0;\n+}\n+\n+/* The uninstalled dispatch table */\n+extern struct sarray* __objc_uninstalled_dtable;\n+\n+/* Store the passed selector name in the selector record and return its\n+   selector value (value returned by sel_get_uid).\n+   Assumes that the calling function has locked down __objc_runtime_mutex. */\n+/* is_const parameter tells us if the name and types parameters\n+   are really constant or not.  If YES then they are constant and\n+   we can just store the pointers.  If NO then we need to copy\n+   name and types because the pointers may disappear later on. */\n+SEL\n+__sel_register_typed_name (const char *name, const char *types, \n+\t\t\t   struct objc_selector *orig, BOOL is_const)\n+{\n+  struct objc_selector* j;\n+  sidx i;\n+  struct objc_list *l;\n+\n+  i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n+  if (soffset_decode (i) != 0)\n+    {\n+      for (l = (struct objc_list*)sarray_get_safe (__objc_selector_array, i);\n+\t   l; l = l->tail)\n+\t{\n+\t  SEL s = (SEL)l->head;\n+\t  if (types == 0 || s->sel_types == 0)\n+\t    {\n+\t      if (s->sel_types == types)\n+\t\t{\n+\t\t  if (orig)\n+\t\t    {\n+\t\t      orig->sel_id = (void*)i;\n+\t\t      return orig;\n+\t\t    }\n+\t\t  else\n+\t\t    return s;\n+\t\t}\n+\t    }\n+\t  else if (!strcmp (s->sel_types, types))\n+\t    {\n+\t      if (orig)\n+\t\t{\n+\t\t  orig->sel_id = (void*)i;\n+\t\t  return orig;\n+\t\t}\n+\t      else\n+\t\treturn s;\n+\t    }\n+\t}\n+      if (orig)\n+\tj = orig;\n+      else\n+\tj = objc_malloc (sizeof (struct objc_selector));\n+\n+      j->sel_id = (void*)i;\n+      /* Can we use the pointer or must copy types?  Don't copy if NULL */\n+      if ((is_const) || (types == 0))\n+\tj->sel_types = (const char*)types;\n+      else {\n+\tj->sel_types = (char *) objc_malloc(strlen(types)+1);\n+\tstrcpy((char *)j->sel_types, types);\n+      }\n+      l = (struct objc_list*)sarray_get_safe (__objc_selector_array, i);\n+    }\n+  else\n+    {\n+      __objc_selector_max_index += 1;\n+      i = soffset_encode(__objc_selector_max_index);\n+      if (orig)\n+\tj = orig;\n+      else\n+\tj = objc_malloc (sizeof (struct objc_selector));\n+\t\n+      j->sel_id = (void*)i;\n+      /* Can we use the pointer or must copy types?  Don't copy if NULL */\n+      if ((is_const) || (types == 0))\n+\tj->sel_types = (const char*)types;\n+      else {\n+\tj->sel_types = (char *) objc_malloc(strlen(types)+1);\n+\tstrcpy((char *)j->sel_types, types);\n+      }\n+      l = 0;\n+    }\n+\n+  DEBUG_PRINTF (\"Record selector %s[%s] as: %ld\\n\", name, types, \n+\t\tsoffset_decode (i));\n+  \n+  {\n+    int is_new = (l == 0);\n+    const char *new_name;\n+\n+    /* Can we use the pointer or must copy name?  Don't copy if NULL */\n+    if ((is_const) || (name == 0))\n+      new_name = name;\n+    else {\n+      new_name = (char *) objc_malloc(strlen(name)+1);\n+      strcpy((char *)new_name, name);\n+    }\n+\n+    l = list_cons ((void*)j, l);\n+    sarray_at_put_safe (__objc_selector_names, i, (void *) new_name);\n+    sarray_at_put_safe (__objc_selector_array, i, (void *) l);\n+    if (is_new)\n+      hash_add (&__objc_selector_hash, (void *) new_name, (void *) i);\n+  }\n+\n+  sarray_realloc(__objc_uninstalled_dtable, __objc_selector_max_index+1);\n+\n+  return (SEL) j;\n+}\n+\n+SEL\n+sel_register_name (const char *name)\n+{\n+  SEL ret;\n+    \n+  objc_mutex_lock(__objc_runtime_mutex);\n+  /* Assume that name is not constant static memory and needs to be\n+     copied before put into a runtime structure.  is_const == NO */\n+  ret = __sel_register_typed_name (name, 0, 0, NO);\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+  \n+  return ret;\n+}\n+\n+SEL\n+sel_register_typed_name (const char *name, const char *type)\n+{\n+  SEL ret;\n+    \n+  objc_mutex_lock(__objc_runtime_mutex);\n+  /* Assume that name and type are not constant static memory and need to\n+     be copied before put into a runtime structure.  is_const == NO */\n+  ret = __sel_register_typed_name (name, type, 0, NO);\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+  \n+  return ret;\n+}\n+"}, {"sha": "17f8b97401367f181c61e51448dd8f05a5638735", "filename": "libobjc/sendmsg.c", "status": "added", "additions": 648, "deletions": 0, "changes": 648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsendmsg.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,648 @@\n+/* GNU Objective C Runtime message lookup \n+   Copyright (C) 1993, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Contributed by Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include \"../tconfig.h\"\n+#include \"runtime.h\"\n+#include \"sarray.h\"\n+#include \"encoding.h\"\n+#include \"runtime-info.h\"\n+\n+/* this is how we hack STRUCT_VALUE to be 1 or 0 */\n+#define gen_rtx(args...) 1\n+#define gen_rtx_MEM(args...) 1\n+#define rtx int\n+\n+#if !defined(STRUCT_VALUE) || STRUCT_VALUE == 0\n+#define INVISIBLE_STRUCT_RETURN 1\n+#else\n+#define INVISIBLE_STRUCT_RETURN 0\n+#endif\n+\n+/* The uninstalled dispatch table */\n+struct sarray* __objc_uninstalled_dtable = 0;   /* !T:MUTEX */\n+\n+/* Send +initialize to class */\n+static void __objc_send_initialize(Class);\n+\n+static void __objc_install_dispatch_table_for_class (Class);\n+\n+/* Forward declare some functions */\n+static void __objc_init_install_dtable(id, SEL);\n+\n+/* Various forwarding functions that are used based upon the\n+   return type for the selector.\n+   __objc_block_forward for structures.\n+   __objc_double_forward for floats/doubles.\n+   __objc_word_forward for pointers or types that fit in registers.\n+   */\n+static double __objc_double_forward(id, SEL, ...);\n+static id __objc_word_forward(id, SEL, ...);\n+typedef struct { id many[8]; } __big;\n+#if INVISIBLE_STRUCT_RETURN \n+static __big \n+#else\n+static id\n+#endif\n+__objc_block_forward(id, SEL, ...);\n+static Method_t search_for_method_in_hierarchy (Class class, SEL sel);\n+Method_t search_for_method_in_list(MethodList_t list, SEL op);\n+id nil_method(id, SEL, ...);\n+\n+/* Given a selector, return the proper forwarding implementation. */\n+__inline__\n+IMP\n+__objc_get_forward_imp (SEL sel)\n+{\n+  const char *t = sel->sel_types;\n+\n+  if (t && (*t == '[' || *t == '(' || *t == '{')\n+#ifdef OBJC_MAX_STRUCT_BY_VALUE\n+    && objc_sizeof_type(t) > OBJC_MAX_STRUCT_BY_VALUE\n+#endif\n+      )\n+    return (IMP)__objc_block_forward;\n+  else if (t && (*t == 'f' || *t == 'd'))\n+    return (IMP)__objc_double_forward;\n+  else\n+    return (IMP)__objc_word_forward;\n+}\n+\n+/* Given a class and selector, return the selector's implementation.  */\n+__inline__\n+IMP\n+get_imp (Class class, SEL sel)\n+{\n+  void* res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n+  if (res == 0)\n+    {\n+      /* Not a valid method */\n+      if(class->dtable == __objc_uninstalled_dtable)\n+\t{\n+\t  /* The dispatch table needs to be installed. */\n+\t  objc_mutex_lock(__objc_runtime_mutex);\n+\t  __objc_install_dispatch_table_for_class (class);\n+\t  objc_mutex_unlock(__objc_runtime_mutex);\n+\t  /* Call ourselves with the installed dispatch table\n+\t     and get the real method */\n+\t  res = get_imp(class, sel);\n+\t}\n+      else\n+\t{\n+\t  /* The dispatch table has been installed so the\n+\t     method just doesn't exist for the class.\n+\t     Return the forwarding implementation. */\n+\t  res = __objc_get_forward_imp(sel);\n+\t}\n+    }\n+  return res;\n+}\n+\n+/* Query if an object can respond to a selector, returns YES if the\n+object implements the selector otherwise NO.  Does not check if the\n+method can be forwarded. */\n+__inline__\n+BOOL\n+__objc_responds_to (id object, SEL sel)\n+{\n+  void* res;\n+\n+  /* Install dispatch table if need be */\n+  if (object->class_pointer->dtable == __objc_uninstalled_dtable)\n+    {\n+      objc_mutex_lock(__objc_runtime_mutex);\n+      __objc_install_dispatch_table_for_class (object->class_pointer);\n+      objc_mutex_unlock(__objc_runtime_mutex);\n+    }\n+\n+  /* Get the method from the dispatch table */\n+  res = sarray_get_safe (object->class_pointer->dtable, (size_t) sel->sel_id);\n+  return (res != 0);\n+}\n+\n+/* This is the lookup function.  All entries in the table are either a \n+   valid method *or* zero.  If zero then either the dispatch table\n+   needs to be installed or it doesn't exist and forwarding is attempted. */\n+__inline__\n+IMP\n+objc_msg_lookup(id receiver, SEL op)\n+{\n+  IMP result;\n+  if(receiver)\n+    {\n+      result = sarray_get_safe (receiver->class_pointer->dtable, \n+\t\t\t\t(sidx)op->sel_id);\n+      if (result == 0)\n+\t{\n+\t  /* Not a valid method */\n+\t  if(receiver->class_pointer->dtable == __objc_uninstalled_dtable)\n+\t    {\n+\t      /* The dispatch table needs to be installed.\n+\t\t This happens on the very first method call to the class. */\n+\t      __objc_init_install_dtable(receiver, op);\n+\n+\t      /* Get real method for this in newly installed dtable */\n+\t      result = get_imp(receiver->class_pointer, op);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The dispatch table has been installed so the\n+\t\t method just doesn't exist for the class.\n+\t\t Attempt to forward the method. */\n+\t      result = __objc_get_forward_imp(op);\n+\t    }\n+\t}\n+      return result;\n+    }\n+  else\n+    return nil_method;\n+}\n+\n+IMP\n+objc_msg_lookup_super (Super_t super, SEL sel)\n+{\n+  if (super->self)\n+    return get_imp (super->class, sel);\n+  else\n+    return nil_method;\n+}\n+\n+int method_get_sizeof_arguments (Method*);\n+\n+retval_t\n+objc_msg_sendv(id object, SEL op, arglist_t arg_frame)\n+{\n+  Method* m = class_get_instance_method(object->class_pointer, op);\n+  const char *type;\n+  *((id*)method_get_first_argument (m, arg_frame, &type)) = object;\n+  *((SEL*)method_get_next_argument (arg_frame, &type)) = op;\n+  return __builtin_apply((apply_t)m->method_imp, \n+\t\t\t arg_frame,\n+\t\t\t method_get_sizeof_arguments (m));\n+}\n+\n+void\n+__objc_init_dispatch_tables()\n+{\n+  __objc_uninstalled_dtable\n+    = sarray_new(200, 0);\n+}\n+\n+/* This function is called by objc_msg_lookup when the\n+   dispatch table needs to be installed; thus it is called once\n+   for each class, namely when the very first message is sent to it. */\n+static void\n+__objc_init_install_dtable(id receiver, SEL op)\n+{\n+  /* This may happen, if the programmer has taken the address of a \n+     method before the dtable was initialized... too bad for him! */\n+  if(receiver->class_pointer->dtable != __objc_uninstalled_dtable)\n+    return;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  if(CLS_ISCLASS(receiver->class_pointer))\n+    {\n+      /* receiver is an ordinary object */\n+      assert(CLS_ISCLASS(receiver->class_pointer));\n+\n+      /* install instance methods table */\n+      __objc_install_dispatch_table_for_class (receiver->class_pointer);\n+\n+      /* call +initialize -- this will in turn install the factory \n+\t dispatch table if not already done :-) */\n+      __objc_send_initialize(receiver->class_pointer);\n+    }\n+  else\n+    {\n+      /* receiver is a class object */\n+      assert(CLS_ISCLASS((Class)receiver));\n+      assert(CLS_ISMETA(receiver->class_pointer));\n+\n+      /* Install real dtable for factory methods */\n+      __objc_install_dispatch_table_for_class (receiver->class_pointer);\n+\n+      __objc_send_initialize((Class)receiver);\n+    }\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}\n+\n+/* Install dummy table for class which causes the first message to\n+   that class (or instances hereof) to be initialized properly */\n+void\n+__objc_install_premature_dtable(Class class)\n+{\n+  assert(__objc_uninstalled_dtable);\n+  class->dtable = __objc_uninstalled_dtable;\n+}   \n+\n+/* Send +initialize to class if not already done */\n+static void\n+__objc_send_initialize(Class class)\n+{\n+  /* This *must* be a class object */\n+  assert(CLS_ISCLASS(class));\n+  assert(!CLS_ISMETA(class));\n+\n+  if (!CLS_ISINITIALIZED(class))\n+    {\n+      CLS_SETINITIALIZED(class);\n+      CLS_SETINITIALIZED(class->class_pointer);\n+\n+      /* Create the garbage collector type memory description */\n+      __objc_generate_gc_type_description (class);\n+\n+      if(class->super_class)\n+\t__objc_send_initialize(class->super_class);\n+\n+      {\n+\tSEL \t     op = sel_register_name (\"initialize\");\n+\tIMP\t     imp = 0;\n+        MethodList_t method_list = class->class_pointer->methods;\n+\n+        while (method_list) {\n+\t  int i;\n+          Method_t method;\n+\n+          for (i = 0; i< method_list->method_count; i++) {\n+\t    method = &(method_list->method_list[i]);\n+            if (method->method_name\n+                && method->method_name->sel_id == op->sel_id) {\n+\t      imp = method->method_imp;\n+              break;\n+            }\n+          }\n+\n+          if (imp)\n+            break;\n+\n+          method_list = method_list->method_next;\n+\n+\t}\n+\tif (imp)\n+\t    (*imp)((id)class, op);\n+\t\t\n+      }\n+    }\n+}\n+\n+/* Walk on the methods list of class and install the methods in the reverse\n+   order of the lists. Since methods added by categories are before the methods\n+   of class in the methods list, this allows categories to substitute methods\n+   declared in class. However if more than one category replaces the same\n+   method nothing is guaranteed about what method will be used.\n+   Assumes that __objc_runtime_mutex is locked down. */\n+static void\n+__objc_install_methods_in_dtable (Class class, MethodList_t method_list)\n+{\n+  int i;\n+\n+  if (!method_list)\n+    return;\n+\n+  if (method_list->method_next)\n+    __objc_install_methods_in_dtable (class, method_list->method_next);\n+\n+  for (i = 0; i < method_list->method_count; i++)\n+    {\n+      Method_t method = &(method_list->method_list[i]);\n+      sarray_at_put_safe (class->dtable,\n+\t\t\t  (sidx) method->method_name->sel_id,\n+\t\t\t  method->method_imp);\n+    }\n+}\n+\n+/* Assumes that __objc_runtime_mutex is locked down. */\n+static void\n+__objc_install_dispatch_table_for_class (Class class)\n+{\n+  Class super;\n+\n+  /* If the class has not yet had its class links resolved, we must \n+     re-compute all class links */\n+  if(!CLS_ISRESOLV(class))\n+    __objc_resolve_class_links();\n+\n+  super = class->super_class;\n+\n+  if (super != 0 && (super->dtable == __objc_uninstalled_dtable))\n+    __objc_install_dispatch_table_for_class (super);\n+\n+  /* Allocate dtable if necessary */\n+  if (super == 0)\n+    {\n+      objc_mutex_lock(__objc_runtime_mutex);\n+      class->dtable = sarray_new (__objc_selector_max_index, 0);\n+      objc_mutex_unlock(__objc_runtime_mutex);\n+    }\n+  else\n+    class->dtable = sarray_lazy_copy (super->dtable);\n+\n+  __objc_install_methods_in_dtable (class, class->methods);\n+}\n+\n+void\n+__objc_update_dispatch_table_for_class (Class class)\n+{\n+  Class next;\n+  struct sarray *arr;\n+\n+  /* not yet installed -- skip it */\n+  if (class->dtable == __objc_uninstalled_dtable) \n+    return;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  arr = class->dtable;\n+  __objc_install_premature_dtable (class); /* someone might require it... */\n+  sarray_free (arr);\t\t\t   /* release memory */\n+\n+  /* could have been lazy... */\n+  __objc_install_dispatch_table_for_class (class); \n+\n+  if (class->subclass_list)\t/* Traverse subclasses */\n+    for (next = class->subclass_list; next; next = next->sibling_class)\n+      __objc_update_dispatch_table_for_class (next);\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}\n+\n+\n+/* This function adds a method list to a class.  This function is\n+   typically called by another function specific to the run-time.  As\n+   such this function does not worry about thread safe issues.\n+\n+   This one is only called for categories. Class objects have their\n+   methods installed right away, and their selectors are made into\n+   SEL's by the function __objc_register_selectors_from_class. */ \n+void\n+class_add_method_list (Class class, MethodList_t list)\n+{\n+  int i;\n+\n+  /* Passing of a linked list is not allowed.  Do multiple calls.  */\n+  assert (!list->method_next);\n+\n+  /* Check for duplicates.  */\n+  for (i = 0; i < list->method_count; ++i)\n+    {\n+      Method_t method = &list->method_list[i];\n+\n+      if (method->method_name)  /* Sometimes these are NULL */\n+\t{\n+\t  /* This is where selector names are transmogrified to SEL's */\n+\t  method->method_name = \n+\t    sel_register_typed_name ((const char*)method->method_name,\n+\t\t\t\t     method->method_types);\n+\t}\n+    }\n+\n+  /* Add the methods to the class's method list.  */\n+  list->method_next = class->methods;\n+  class->methods = list;\n+\n+  /* Update the dispatch table of class */\n+  __objc_update_dispatch_table_for_class (class);\n+}\n+\n+Method_t\n+class_get_instance_method(Class class, SEL op)\n+{\n+  return search_for_method_in_hierarchy(class, op);\n+}\n+\n+Method_t\n+class_get_class_method(MetaClass class, SEL op)\n+{\n+  return search_for_method_in_hierarchy(class, op);\n+}\n+\n+\n+/* Search for a method starting from the current class up its hierarchy.\n+   Return a pointer to the method's method structure if found.  NULL\n+   otherwise. */   \n+\n+static Method_t\n+search_for_method_in_hierarchy (Class cls, SEL sel)\n+{\n+  Method_t method = NULL;\n+  Class class;\n+\n+  if (! sel_is_mapped (sel))\n+    return NULL;\n+\n+  /* Scan the method list of the class.  If the method isn't found in the\n+     list then step to its super class. */\n+  for (class = cls; ((! method) && class); class = class->super_class)\n+    method = search_for_method_in_list (class->methods, sel);\n+\n+  return method;\n+}\n+\n+\n+\n+/* Given a linked list of method and a method's name.  Search for the named\n+   method's method structure.  Return a pointer to the method's method\n+   structure if found.  NULL otherwise. */  \n+Method_t\n+search_for_method_in_list (MethodList_t list, SEL op)\n+{\n+  MethodList_t method_list = list;\n+\n+  if (! sel_is_mapped (op))\n+    return NULL;\n+\n+  /* If not found then we'll search the list.  */\n+  while (method_list)\n+    {\n+      int i;\n+\n+      /* Search the method list.  */\n+      for (i = 0; i < method_list->method_count; ++i)\n+        {\n+          Method_t method = &method_list->method_list[i];\n+\n+          if (method->method_name)\n+            if (method->method_name->sel_id == op->sel_id)\n+              return method;\n+        }\n+\n+      /* The method wasn't found.  Follow the link to the next list of\n+         methods.  */\n+      method_list = method_list->method_next;\n+    }\n+\n+  return NULL;\n+}\n+\n+static retval_t __objc_forward (id object, SEL sel, arglist_t args);\n+\n+/* Forwarding pointers/integers through the normal registers */\n+static id\n+__objc_word_forward (id rcv, SEL op, ...)\n+{\n+  void *args, *res;\n+\n+  args = __builtin_apply_args ();\n+  res = __objc_forward (rcv, op, args);\n+  if (res)\n+    __builtin_return (res);\n+  else\n+    return res;\n+}\n+\n+/* Specific routine for forwarding floats/double because of\n+   architectural differences on some processors.  i386s for\n+   example which uses a floating point stack versus general\n+   registers for floating point numbers.  This forward routine \n+   makes sure that GCC restores the proper return values */\n+static double\n+__objc_double_forward (id rcv, SEL op, ...)\n+{\n+  void *args, *res;\n+\n+  args = __builtin_apply_args ();\n+  res = __objc_forward (rcv, op, args);\n+  __builtin_return (res);\n+}\n+\n+#if INVISIBLE_STRUCT_RETURN\n+static __big\n+#else\n+static id\n+#endif\n+__objc_block_forward (id rcv, SEL op, ...)\n+{\n+  void *args, *res;\n+\n+  args = __builtin_apply_args ();\n+  res = __objc_forward (rcv, op, args);\n+  if (res)\n+    __builtin_return (res);\n+  else\n+#if INVISIBLE_STRUCT_RETURN\n+    return (__big) {{0, 0, 0, 0, 0, 0, 0, 0}};\n+#else\n+    return nil;\n+#endif\n+}\n+\n+\n+/* This function is installed in the dispatch table for all methods which are\n+   not implemented.  Thus, it is called when a selector is not recognized. */\n+static retval_t\n+__objc_forward (id object, SEL sel, arglist_t args)\n+{\n+  IMP imp;\n+  static SEL frwd_sel = 0;                      /* !T:SAFE2 */\n+  SEL err_sel;\n+\n+  /* first try if the object understands forward:: */\n+  if (!frwd_sel)\n+    frwd_sel = sel_get_any_uid(\"forward::\");\n+\n+  if (__objc_responds_to (object, frwd_sel))\n+    {\n+      imp = get_imp(object->class_pointer, frwd_sel);\n+      return (*imp)(object, frwd_sel, sel, args);\n+    }\n+\n+  /* If the object recognizes the doesNotRecognize: method then we're going\n+     to send it. */\n+  err_sel = sel_get_any_uid (\"doesNotRecognize:\");\n+  if (__objc_responds_to (object, err_sel))\n+    {\n+      imp = get_imp (object->class_pointer, err_sel);\n+      return (*imp) (object, err_sel, sel);\n+    }\n+  \n+  /* The object doesn't recognize the method.  Check for responding to\n+     error:.  If it does then sent it. */\n+  {\n+    size_t strlen (const char*);\n+    char msg[256 + strlen ((const char*)sel_get_name (sel))\n+             + strlen ((const char*)object->class_pointer->name)];\n+\n+    sprintf (msg, \"(%s) %s does not recognize %s\",\n+\t     (CLS_ISMETA(object->class_pointer)\n+\t      ? \"class\"\n+\t      : \"instance\" ),\n+             object->class_pointer->name, sel_get_name (sel));\n+\n+    err_sel = sel_get_any_uid (\"error:\");\n+    if (__objc_responds_to (object, err_sel))\n+      {\n+\timp = get_imp (object->class_pointer, err_sel);\n+\treturn (*imp) (object, sel_get_any_uid (\"error:\"), msg);\n+      }\n+\n+    /* The object doesn't respond to doesNotRecognize: or error:;  Therefore,\n+       a default action is taken. */\n+    objc_error (object, OBJC_ERR_UNIMPLEMENTED, \"%s\\n\", msg);\n+\n+    return 0;\n+  }\n+}\n+\n+void\n+__objc_print_dtable_stats()\n+{\n+  int total = 0;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  printf(\"memory usage: (%s)\\n\",\n+#ifdef OBJC_SPARSE2\n+\t \"2-level sparse arrays\"\n+#else\n+\t \"3-level sparse arrays\"\n+#endif\n+\t );\n+\n+  printf(\"arrays: %d = %ld bytes\\n\", narrays, \n+\t (long)narrays*sizeof(struct sarray));\n+  total += narrays*sizeof(struct sarray);\n+  printf(\"buckets: %d = %ld bytes\\n\", nbuckets, \n+\t (long)nbuckets*sizeof(struct sbucket));\n+  total += nbuckets*sizeof(struct sbucket);\n+\n+  printf(\"idxtables: %d = %ld bytes\\n\", idxsize, (long)idxsize*sizeof(void*));\n+  total += idxsize*sizeof(void*);\n+  printf(\"-----------------------------------\\n\");\n+  printf(\"total: %d bytes\\n\", total);\n+  printf(\"===================================\\n\");\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}\n+\n+/* Returns the uninstalled dispatch table indicator.\n+ If a class' dispatch table points to __objc_uninstalled_dtable\n+ then that means it needs its dispatch table to be installed. */\n+__inline__\n+struct sarray* \n+objc_get_uninstalled_dtable()\n+{\n+  return __objc_uninstalled_dtable;\n+}"}, {"sha": "0f7063b7e836116e98f1e31a1fe3fe4188fb2372", "filename": "libobjc/thr-dce.c", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-dce.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,281 @@\n+/* GNU Objective C Runtime Thread Interface\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <pthread.h>\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+\n+/* Key structure for maintaining thread specific storage */\n+static pthread_key_t _objc_thread_storage;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  /* Initialize the thread storage key */\n+  return pthread_keycreate(&_objc_thread_storage, NULL);\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  /* Destroy the thread storage key */\n+  /* Not implemented yet */\n+  /* return pthread_key_delete(&_objc_thread_storage); */\n+  return 0;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  objc_thread_t thread_id;\n+  pthread_t new_thread_handle;\n+\n+  if (pthread_create(&new_thread_handle, pthread_attr_default,\n+\t\t     (void *)func, arg) == 0)\n+    {\n+      /* ??? May not work! (64bit) */\n+      thread_id = *(objc_thread_t *)&new_thread_handle; \n+      pthread_detach(&new_thread_handle);     /* Fully detach thread.     */\n+    }\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  int sys_priority = 0;\n+\n+  switch (priority)\n+    {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+      sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n+      break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+      break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+      break;\n+    }\n+    \n+  /* Change the priority. */\n+  if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n+    return 0;\n+  else\n+    /* Failed */\n+    return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  int sys_priority;\n+    \n+  if ((sys_priority = pthread_getprio(pthread_self())) >= 0) {\n+    if (sys_priority >= PRI_FG_MIN_NP && sys_priority <= PRI_FG_MAX_NP)\n+      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+    if (sys_priority >= PRI_BG_MIN_NP && sys_priority <= PRI_BG_MAX_NP)\n+      return OBJC_THREAD_BACKGROUND_PRIORITY;\n+    return OBJC_THREAD_LOW_PRIORITY;\n+  }\n+\n+  /* Failed */\n+  return -1;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  pthread_yield();\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  /* exit the thread */\n+  pthread_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  pthread_t self = pthread_self();\n+\n+  return (objc_thread_t) pthread_getunique_np (&self);\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  return pthread_setspecific(_objc_thread_storage, value);\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  void *value = NULL;\n+\n+  if ( !(pthread_getspecific(_objc_thread_storage, &value)) )\n+    return value;\n+\n+  return NULL;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if (pthread_mutex_init((pthread_mutex_t *)(&(mutex->backend)), \n+\t\t\t pthread_mutexattr_default))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  if (pthread_mutex_destroy((pthread_mutex_t *)(&(mutex->backend))))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_lock((pthread_mutex_t *)(&(mutex->backend)));\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  if (pthread_mutex_trylock((pthread_mutex_t *)(&(mutex->backend))) != 1)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_unlock((pthread_mutex_t *)(&(mutex->backend)));\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  if (pthread_cond_init((pthread_cond_t *)(&(condition->backend)), NULL))\n+    return -1;\n+  else\n+    return 0;\n+    */\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  return pthread_cond_destroy((pthread_cond_t *)(&(condition->backend)));\n+  */\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  return pthread_cond_wait((pthread_cond_t *)(&(condition->backend)),\n+\t\t\t   (pthread_mutex_t *)(&(mutex->backend)));\n+\t\t\t   */\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  return pthread_cond_broadcast((pthread_cond_t *)(&(condition->backend)));\n+  */\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  return pthread_cond_signal((pthread_cond_t *)(&(condition->backend)));\n+  */\n+}\n+\n+/* End of File */"}, {"sha": "0f7063b7e836116e98f1e31a1fe3fe4188fb2372", "filename": "libobjc/thr-decosf1.c", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-decosf1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-decosf1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-decosf1.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,281 @@\n+/* GNU Objective C Runtime Thread Interface\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <pthread.h>\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+\n+/* Key structure for maintaining thread specific storage */\n+static pthread_key_t _objc_thread_storage;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  /* Initialize the thread storage key */\n+  return pthread_keycreate(&_objc_thread_storage, NULL);\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  /* Destroy the thread storage key */\n+  /* Not implemented yet */\n+  /* return pthread_key_delete(&_objc_thread_storage); */\n+  return 0;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  objc_thread_t thread_id;\n+  pthread_t new_thread_handle;\n+\n+  if (pthread_create(&new_thread_handle, pthread_attr_default,\n+\t\t     (void *)func, arg) == 0)\n+    {\n+      /* ??? May not work! (64bit) */\n+      thread_id = *(objc_thread_t *)&new_thread_handle; \n+      pthread_detach(&new_thread_handle);     /* Fully detach thread.     */\n+    }\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  int sys_priority = 0;\n+\n+  switch (priority)\n+    {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+      sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n+      break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+      break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+      break;\n+    }\n+    \n+  /* Change the priority. */\n+  if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n+    return 0;\n+  else\n+    /* Failed */\n+    return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  int sys_priority;\n+    \n+  if ((sys_priority = pthread_getprio(pthread_self())) >= 0) {\n+    if (sys_priority >= PRI_FG_MIN_NP && sys_priority <= PRI_FG_MAX_NP)\n+      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+    if (sys_priority >= PRI_BG_MIN_NP && sys_priority <= PRI_BG_MAX_NP)\n+      return OBJC_THREAD_BACKGROUND_PRIORITY;\n+    return OBJC_THREAD_LOW_PRIORITY;\n+  }\n+\n+  /* Failed */\n+  return -1;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  pthread_yield();\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  /* exit the thread */\n+  pthread_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  pthread_t self = pthread_self();\n+\n+  return (objc_thread_t) pthread_getunique_np (&self);\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  return pthread_setspecific(_objc_thread_storage, value);\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  void *value = NULL;\n+\n+  if ( !(pthread_getspecific(_objc_thread_storage, &value)) )\n+    return value;\n+\n+  return NULL;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if (pthread_mutex_init((pthread_mutex_t *)(&(mutex->backend)), \n+\t\t\t pthread_mutexattr_default))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  if (pthread_mutex_destroy((pthread_mutex_t *)(&(mutex->backend))))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_lock((pthread_mutex_t *)(&(mutex->backend)));\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  if (pthread_mutex_trylock((pthread_mutex_t *)(&(mutex->backend))) != 1)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_unlock((pthread_mutex_t *)(&(mutex->backend)));\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  if (pthread_cond_init((pthread_cond_t *)(&(condition->backend)), NULL))\n+    return -1;\n+  else\n+    return 0;\n+    */\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  return pthread_cond_destroy((pthread_cond_t *)(&(condition->backend)));\n+  */\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  return pthread_cond_wait((pthread_cond_t *)(&(condition->backend)),\n+\t\t\t   (pthread_mutex_t *)(&(mutex->backend)));\n+\t\t\t   */\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  return pthread_cond_broadcast((pthread_cond_t *)(&(condition->backend)));\n+  */\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  return pthread_cond_signal((pthread_cond_t *)(&(condition->backend)));\n+  */\n+}\n+\n+/* End of File */"}, {"sha": "528a3e3a434d2c48096bcd2f5d3fb3dfc2ecd690", "filename": "libobjc/thr-irix.c", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-irix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-irix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-irix.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,235 @@\n+/* GNU Objective C Runtime Thread Interface - SGI IRIX Implementation\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <sys/sysmp.h>\n+#include <sys/prctl.h>\n+#include <ulocks.h>\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+\n+/* Key structure for maintaining thread specific storage */\n+static void * __objc_shared_arena_handle = NULL;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  /* Name of IRIX arena. */\n+  char arena_name[64];\n+\n+  DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n+\n+  /* Construct a temporary name for arena. */\n+  sprintf(arena_name, \"/usr/tmp/objc_%05u\", (unsigned)getpid());\n+\n+  /* Up to 256 threads.  Arena only for threads. */\n+  usconfig(CONF_INITUSERS, 256);\n+  usconfig(CONF_ARENATYPE, US_SHAREDONLY);\n+\n+  /* Initialize the arena */\n+  if (!(__objc_shared_arena_handle = usinit(arena_name)))\n+    /* Failed */\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  objc_thread_t thread_id;\n+  int sys_id;\n+\n+  if ((sys_id = sproc((void *)func, PR_SALL, arg)) >= 0)\n+    thread_id = (objc_thread_t)sys_id;\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  /* Not implemented yet */\n+  return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  /* Not implemented yet */\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  sginap(0);\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  /* IRIX only has exit. */\n+  exit(__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  /* Threads are processes. */\n+  return (objc_thread_t)get_pid();\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  *((void **)&PRDA->usr_prda) = value;\n+  return 0;\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  return *((void **)&PRDA->usr_prda);\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if (!( (ulock_t)(mutex->backend) = usnewlock(__objc_shared_arena_handle) ))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  usfreelock((ulock_t)(mutex->backend), __objc_shared_arena_handle);\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  if (ussetlock((ulock_t)(mutex->backend)) == 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  if (ustestlock((ulock_t)(mutex->backend)) == 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  usunsetlock((ulock_t)(mutex->backend));\n+  return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* End of File */"}, {"sha": "44af0c1e2869d265a8b70ef5e1f328df49c2d09c", "filename": "libobjc/thr-mach.c", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-mach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-mach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-mach.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,312 @@\n+/* GNU Objective C Runtime Thread Implementation\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+   Modified for Mach threads by Bill Bumgarner <bbum@friday.com>\n+   Condition functions added by Mircea Oancea <mircea@first.elcom.pub.ro>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <mach/mach.h>\n+#include <mach/cthreads.h>\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+\n+/*\n+  Obtain the maximum thread priority that can set for t.  Under the\n+  mach threading model, it is possible for the developer to adjust the\n+  maximum priority downward only-- cannot be raised without superuser\n+  privileges.  Once lowered, it cannot be raised.\n+  */\n+static int __mach_get_max_thread_priority(cthread_t t, int *base)\n+{\n+  thread_t threadP;\n+  kern_return_t error;\n+  struct thread_sched_info info;\n+  unsigned int info_count=THREAD_SCHED_INFO_COUNT;\n+    \n+  if (t == NULL)\n+    return -1;\n+\n+  threadP  = cthread_thread(t); \t/* get thread underlying */\n+\n+  error=thread_info(threadP, THREAD_SCHED_INFO, \n+\t\t    (thread_info_t)&info, &info_count);\n+\n+  if (error != KERN_SUCCESS)\n+    return -1;\n+\n+  if (base != NULL)\n+    *base = info.base_priority;\n+\n+  return info.max_priority;\n+}\n+\t\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  objc_thread_t thread_id;\n+  cthread_t new_thread_handle;\n+\n+  /* create thread */\n+  new_thread_handle = cthread_fork((cthread_fn_t)func, arg);\n+\n+  if(new_thread_handle)\n+    {\n+      /* this is not terribly portable */\n+      thread_id = *(objc_thread_t *)&new_thread_handle; \n+      cthread_detach(new_thread_handle);\n+    }\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  objc_thread_t *t = objc_thread_id();\n+  cthread_t cT = (cthread_t) t; \n+  int maxPriority = __mach_get_max_thread_priority(cT, NULL);\n+  int sys_priority = 0;\n+\n+  if (maxPriority == -1)\n+    return -1;\n+\n+  switch (priority)\n+    {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+      sys_priority = maxPriority;\n+      break;\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+      sys_priority = (maxPriority * 2) / 3;\n+      break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+      sys_priority = maxPriority / 3;\n+      break;\n+    default:\n+      return -1;\n+    }\n+\n+  if (sys_priority == 0)\n+    return -1;\n+\n+  /* Change the priority */\n+  if (cthread_priority(cT, sys_priority, 0) == KERN_SUCCESS)\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  objc_thread_t *t = objc_thread_id();\n+  cthread_t cT = (cthread_t) t; /* see objc_thread_id() */\n+  int basePriority;\n+  int maxPriority;\n+  int sys_priority = 0;\n+\n+  int interactiveT, backgroundT, lowT; /* thresholds */\n+\n+  maxPriority = __mach_get_max_thread_priority(cT, &basePriority);\n+\n+  if(maxPriority == -1)\n+    return -1;\n+\n+  if (basePriority > ( (maxPriority * 2) / 3))\n+    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+\n+  if (basePriority > ( maxPriority / 3))\n+    return OBJC_THREAD_BACKGROUND_PRIORITY;\n+\n+  return OBJC_THREAD_LOW_PRIORITY;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  cthread_yield();\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  /* exit the thread */\n+  cthread_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  cthread_t self = cthread_self();\n+\n+  return *(objc_thread_t *)&self;\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  cthread_set_data(cthread_self(), (any_t) value);\n+  return 0;\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  return (void *) cthread_data(cthread_self());\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  int err = 0;\n+  mutex->backend = objc_malloc(sizeof(struct mutex));\n+\n+  err = mutex_init((mutex_t)(mutex->backend));\n+\n+  if (err != 0)\n+    {\n+      objc_free(mutex->backend);\n+      return -1;\n+    }\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  mutex_clear((mutex_t)(mutex->backend));\n+\n+  objc_free(mutex->backend);\n+  mutex->backend = NULL;\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  mutex_lock((mutex_t)(mutex->backend));\n+  return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  if (mutex_try_lock((mutex_t)(mutex->backend)) == 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  mutex_unlock((mutex_t)(mutex->backend));\n+  return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  condition->backend = objc_malloc(sizeof(struct condition));\n+  condition_init((condition_t)(condition->backend));\n+  return 0;\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  condition_clear((condition_t)(condition->backend));\n+  objc_free(condition->backend);\n+  condition->backend = NULL;\n+  return 0;\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  condition_wait((condition_t)(condition->backend),\n+\t\t (mutex_t)(mutex->backend));\n+  return 0;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  condition_broadcast((condition_t)(condition->backend));\n+  return 0;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  condition_signal((condition_t)(condition->backend));\n+  return 0;\n+}\n+\n+/* End of File */"}, {"sha": "a0d7d436613ef8263a2dccaed98009da25fb76ea", "filename": "libobjc/thr-os2.c", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-os2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-os2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-os2.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,267 @@\n+/* GNU Objective C Runtime Thread Interface - OS/2 emx Implementation\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Thomas Baier (baier@ci.tuwien.ac.at)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+\n+#define INCL_DOSSEMAPHORES\n+#define INCL_DOSPROCESS\n+\n+/*\n+ * conflicts with objc.h:       SEL, BOOL, id\n+ * solution:  prefixing those with _OS2_ before including <os2.h>\n+ */\n+#define SEL _OS2_SEL\n+#define BOOL _OS2_BOOL\n+#define id _OS2_id\n+#include <os2.h>\n+#undef id\n+#undef SEL\n+#undef BOOL\n+\n+#include <stdlib.h>\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  int thread_id = 0;\n+\n+  if ((thread_id = _beginthread (func,NULL,32768,arg)) < 0)\n+    thread_id = 0;\n+  \n+  return (objc_thread_t)thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  ULONG sys_class = 0;\n+  ULONG sys_priority = 0;\n+\n+  /* OBJC_THREAD_INTERACTIVE_PRIORITY -> PRTYC_FOREGROUNDSERVER\n+   * OBJC_THREAD_BACKGROUND_PRIORITY  -> PRTYC_REGULAR\n+   * OBJC_THREAD_LOW_PRIORITY         -> PRTYC_IDLETIME */\n+  \n+  switch (priority) {\n+  case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+    sys_class = PRTYC_REGULAR;\n+    sys_priority = 10;\n+    break;\n+  default:\n+  case OBJC_THREAD_BACKGROUND_PRIORITY:\n+    sys_class = PRTYC_IDLETIME;\n+    sys_priority = 25;\n+    break;\n+  case OBJC_THREAD_LOW_PRIORITY:\n+    sys_class = PRTYC_IDLETIME;\n+    sys_priority = 0;\n+    break;\n+  }\n+\n+  /* Change priority */\n+  if (!DosSetPriority (PRTYS_THREAD,sys_class,sys_priority,*_threadid))\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  PTIB ptib;\n+  PPIB ppib;\n+\n+  /* get information about current thread */\n+  DosGetInfoBlocks (&ptib,&ppib);\n+\n+  switch (ptib->tib_ptib2->tib2_ulpri)\n+    {\n+    case PRTYC_IDLETIME:\n+    case PRTYC_REGULAR:\n+    case PRTYC_TIMECRITICAL:\n+    case PRTYC_FOREGROUNDSERVER:\n+    default:\n+      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+    }\n+\n+  return -1;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  DosSleep (0);\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  /* terminate the thread, NEVER use DosExit () */\n+  _endthread ();\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  return (objc_thread_t) *_threadid;\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  *_threadstore () = value;\n+\n+  return 0;\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  return *_threadstore ();\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if (DosCreateMutexSem (NULL, (HMTX)(&(mutex->backend)),0L,0) > 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  DosCloseMutexSem ((HMTX)(mutex->backend));\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  if (DosRequestMutexSem ((HMTX)(mutex->backend),-1L) != 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  if (DosRequestMutexSem ((HMTX)(mutex->backend),0L) != 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  if (DosReleaseMutexSem((HMTX)(mutex->backend)) != 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* End of File */"}, {"sha": "5b40f711be803108725474a0d8e3e6c76dfb1e71", "filename": "libobjc/thr-posix.c", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-posix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-posix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-posix.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,229 @@\n+/* GNU Objective C Runtime Thread Interface for POSIX compliant threads\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+   Modified for Linux/Pthreads by Kai-Uwe Sattler (kus@iti.cs.uni-magdeburg.de)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+#include <pthread.h>\n+\n+/* Key structure for maintaining thread specific storage */\n+static pthread_key_t _objc_thread_storage;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  /* Initialize the thread storage key */\n+  return pthread_key_create(&_objc_thread_storage, NULL);\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  objc_thread_t thread_id;\n+  pthread_t new_thread_handle;\n+\n+  if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n+      thread_id = *(objc_thread_t *)&new_thread_handle;\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  /* Not implemented yet */\n+  return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  /* Not implemented yet */\n+  return -1;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  sched_yield();\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  /* exit the thread */\n+  pthread_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  pthread_t self = pthread_self();\n+\n+  return *(objc_thread_t *)&self;\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  return pthread_setspecific(_objc_thread_storage, value);\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  return pthread_getspecific(_objc_thread_storage);\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  mutex->backend = objc_malloc(sizeof(pthread_mutex_t));\n+\n+  if (pthread_mutex_init((pthread_mutex_t *)mutex->backend, NULL))\n+    {\n+      objc_free(mutex->backend);\n+      mutex->backend = NULL;\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  if (pthread_mutex_destroy((pthread_mutex_t *)mutex->backend))\n+    return -1;\n+\n+  objc_free(mutex->backend);\n+  mutex->backend = NULL;\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_lock((pthread_mutex_t *)mutex->backend);\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_trylock((pthread_mutex_t *)mutex->backend);\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_unlock((pthread_mutex_t *)mutex->backend);\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  condition->backend = objc_malloc(sizeof(pthread_cond_t));\n+\n+  if (pthread_cond_init((pthread_cond_t *)condition->backend, NULL))\n+    {\n+      objc_free(condition->backend);\n+      condition->backend = NULL;\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  if (pthread_cond_destroy((pthread_cond_t *)condition->backend))\n+    return -1;\n+\n+  objc_free(condition->backend);\n+  condition->backend = NULL;\n+  return 0;\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  return pthread_cond_wait((pthread_cond_t *)condition->backend,\n+\t\t\t   (pthread_mutex_t *)mutex->backend);\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  return pthread_cond_broadcast((pthread_cond_t *)condition->backend);\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  return pthread_cond_signal((pthread_cond_t *)condition->backend);\n+}\n+\n+/* End of File */"}, {"sha": "2efdd15bc54120b69b26216adfec6ba981dc9478", "filename": "libobjc/thr-pthreads.c", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-pthreads.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,218 @@\n+/* GNU Objective C Runtime Thread Implementation for PCThreads under GNU/Linux.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Scott Christley <scottc@net-community.com>\n+   Condition functions added by: Mircea Oancea <mircea@first.elcom.pub.ro>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <pcthread.h>\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+\n+/* Key structure for maintaining thread specific storage */\n+static pthread_key_t _objc_thread_storage;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  /* Initialize the thread storage key */\n+  return pthread_key_create(&_objc_thread_storage, NULL);\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  /* Destroy the thread storage key */\n+  /* Not implemented yet */\n+  /* return pthread_key_delete(&_objc_thread_storage); */\n+  return 0;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  objc_thread_t thread_id;\n+  pthread_t new_thread_handle;\n+\n+  if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n+      thread_id = *(objc_thread_t *)&new_thread_handle;\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  /* Not implemented yet */\n+  return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  /* Not implemented yet */\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  pthread_yield(NULL);\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  /* exit the thread */\n+  pthread_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  pthread_t self = pthread_self();\n+\n+  return *(objc_thread_t *)&self;\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  return pthread_setspecific(_objc_thread_storage, value);\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  void *value = NULL;\n+\n+  if ( !(pthread_getspecific(_objc_thread_storage, &value)) )\n+    return value;\n+\n+  return NULL;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if (pthread_mutex_init((pthread_mutex_t *)(&(mutex->backend)), NULL))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  if (pthread_mutex_destroy((pthread_mutex_t *)(&(mutex->backend))))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_lock((pthread_mutex_t *)(&(mutex->backend)));\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_trylock((pthread_mutex_t *)(&(mutex->backend)));\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_unlock((pthread_mutex_t *)(&(mutex->backend)));\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  if (pthread_cond_init((pthread_cond_t *)(&(condition->backend)), NULL))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  return pthread_cond_destroy((pthread_cond_t *)(&(condition->backend)));\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  return pthread_cond_wait((pthread_cond_t *)(&(condition->backend)),\n+\t\t\t   (pthread_mutex_t *)(&(mutex->backend)));\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  return pthread_cond_broadcast((pthread_cond_t *)(&(condition->backend)));\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  return pthread_cond_signal((pthread_cond_t *)(&(condition->backend)));\n+}\n+\n+/* End of File */"}, {"sha": "b196677c6b696d79e4fe7f98018d7d79bee4c75e", "filename": "libobjc/thr-single.c", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-single.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-single.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-single.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,192 @@\n+/* GNU Objective C Runtime Thread Implementation\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+\n+/* Thread local storage for a single thread */\n+static void *thread_local_storage = NULL;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  /* No thread support available */\n+  return NULL;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  return;\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  /* No thread support available */\n+  /* Should we really exit the program */\n+  /* exit(&__objc_thread_exit_status); */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  /* No thread support, use 1. */\n+  return (objc_thread_t)1;\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  thread_local_storage = value;\n+  return 0;\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  return thread_local_storage;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  /* There can only be one thread, so we always get the lock */\n+  return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  /* There can only be one thread, so we always get the lock */\n+  return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* End of File */"}, {"sha": "90351b43cf6c0f5599b70e4d5966c54be3f741c4", "filename": "libobjc/thr-solaris.c", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-solaris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-solaris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-solaris.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,259 @@\n+/* GNU Objective C Runtime Thread Interface\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+   Conditions added by Mircea Oancea (mircea@first.elcom.pub.ro)\n+      \n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+\n+#include <thread.h>\n+#include <synch.h>\n+#include <errno.h>\n+\n+/* Key structure for maintaining thread specific storage */\n+static thread_key_t     __objc_thread_data_key;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  /* Initialize the thread storage key */\n+  if (thr_keycreate(&__objc_thread_data_key, NULL) == 0)\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  return 0;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  objc_thread_t thread_id;\n+  thread_t new_thread_id = 0;\n+\n+  if (thr_create(NULL, 0, (void *)func, arg,\n+                 THR_DETACHED | THR_NEW_LWP,\n+                 &new_thread_id) == 0)\n+    thread_id = *(objc_thread_t *)&new_thread_id;\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  int sys_priority = 0;\n+\n+  switch (priority)\n+    {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+      sys_priority = 300;\n+      break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+      sys_priority = 200;\n+      break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+      sys_priority = 1000;\n+      break;\n+    }\n+\n+  /* Change priority */\n+  if (thr_setprio(thr_self(), sys_priority) == 0)\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  int sys_priority;\n+                                                   \n+  if (thr_getprio(thr_self(), &sys_priority) == 0)\n+    {\n+      if (sys_priority >= 250)\n+\treturn OBJC_THREAD_INTERACTIVE_PRIORITY;\n+      else if (sys_priority >= 150)\n+\treturn OBJC_THREAD_BACKGROUND_PRIORITY;\n+      return OBJC_THREAD_LOW_PRIORITY;\n+    }\n+\n+  /* Couldn't get priority. */\n+  return -1;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  thr_yield();\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  /* exit the thread */\n+  thr_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  return (objc_thread_t)thr_self();\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  if (thr_setspecific(__objc_thread_data_key, value) == 0)\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  void *value = NULL;\n+\n+  if (thr_getspecific(__objc_thread_data_key, &value) == 0)\n+    return value;\n+\n+  return NULL;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if (mutex_init( (mutex_t *)(&(mutex->backend)), USYNC_THREAD, 0))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  mutex_destroy((mutex_t *)(&(mutex->backend)));\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  if (mutex_lock((mutex_t *)(&(mutex->backend))) != 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  if (mutex_trylock((mutex_t *)(&(mutex->backend))) != 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  if (mutex_unlock((mutex_t *)(&(mutex->backend))) != 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  return cond_init((cond_t *)(&(condition->backend)), USYNC_THREAD, NULL);\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  return cond_destroy((cond_t *)(&(condition->backend)));\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  return cond_wait((cond_t *)(&(condition->backend)),\n+\t\t   (mutex_t *)(&(mutex->backend)));\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  return cond_broadcast((cond_t *)(&(condition->backend)));\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  return cond_signal((cond_t *)(&(condition->backend)));\n+}\n+\n+/* End of File */"}, {"sha": "b196677c6b696d79e4fe7f98018d7d79bee4c75e", "filename": "libobjc/thr-vxworks.c", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-vxworks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-vxworks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-vxworks.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,192 @@\n+/* GNU Objective C Runtime Thread Implementation\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+\n+/* Thread local storage for a single thread */\n+static void *thread_local_storage = NULL;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  /* No thread support available */\n+  return NULL;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  return;\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  /* No thread support available */\n+  /* Should we really exit the program */\n+  /* exit(&__objc_thread_exit_status); */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  /* No thread support, use 1. */\n+  return (objc_thread_t)1;\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  thread_local_storage = value;\n+  return 0;\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  return thread_local_storage;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  /* There can only be one thread, so we always get the lock */\n+  return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  /* There can only be one thread, so we always get the lock */\n+  return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* End of File */"}, {"sha": "8570ffd997ef58bfedfc769b4b1dcaa411c05928", "filename": "libobjc/thr-win32.c", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-win32.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,272 @@\n+/* GNU Objective C Runtime Thread Interface - Win32 Implementation\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+\n+#ifndef __OBJC__\n+#define __OBJC__\n+#endif\n+#include <windows.h>\n+\n+/* Key structure for maintaining thread specific storage */\n+static DWORD\t__objc_data_tls = (DWORD)-1;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  /* Initialize the thread storage key */\n+  if ((__objc_data_tls = TlsAlloc()) != (DWORD)-1)\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  if (__objc_data_tls != (DWORD)-1)\n+    TlsFree(__objc_data_tls);\n+  return 0;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  DWORD\tthread_id = 0;\n+  HANDLE win32_handle;\n+\n+  if (!(win32_handle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func,\n+                                   arg, 0, &thread_id)))\n+    thread_id = 0;\n+  \n+  return (objc_thread_t)thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  int sys_priority = 0;\n+\n+  switch (priority)\n+    {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+      sys_priority = THREAD_PRIORITY_NORMAL;\n+      break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+      sys_priority = THREAD_PRIORITY_BELOW_NORMAL;\n+      break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+      sys_priority = THREAD_PRIORITY_LOWEST;\n+      break;\n+    }\n+\n+  /* Change priority */\n+  if (SetThreadPriority(GetCurrentThread(), sys_priority))\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  int sys_priority;\n+\n+  sys_priority = GetThreadPriority(GetCurrentThread());\n+  \n+  switch (sys_priority)\n+    {\n+    case THREAD_PRIORITY_HIGHEST:\n+    case THREAD_PRIORITY_TIME_CRITICAL:\n+    case THREAD_PRIORITY_ABOVE_NORMAL:\n+    case THREAD_PRIORITY_NORMAL:\n+      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+\n+    default:\n+    case THREAD_PRIORITY_BELOW_NORMAL:\n+      return OBJC_THREAD_BACKGROUND_PRIORITY;\n+    \n+    case THREAD_PRIORITY_IDLE:\n+    case THREAD_PRIORITY_LOWEST:\n+      return OBJC_THREAD_LOW_PRIORITY;\n+    }\n+\n+  /* Couldn't get priority. */\n+  return -1;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  Sleep(0);\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  /* exit the thread */\n+  ExitThread(__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  return (objc_thread_t)GetCurrentThreadId();\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  if (TlsSetValue(__objc_data_tls, value))\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  return TlsGetValue(__objc_data_tls);          /* Return thread data.      */\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if ((mutex->backend = (void *)CreateMutex(NULL, 0, NULL)) == NULL)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  CloseHandle((HANDLE)(mutex->backend));\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  int status;\n+\n+  status = WaitForSingleObject((HANDLE)(mutex->backend), INFINITE);\n+  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  int status;\n+\n+  status = WaitForSingleObject((HANDLE)(mutex->backend), 0);\n+  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  if (ReleaseMutex((HANDLE)(mutex->backend)) == 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* End of File */"}, {"sha": "f1c957aaa15c79a784e7926483d32ce6d25790e6", "filename": "libobjc/thr.c", "status": "added", "additions": 534, "deletions": 0, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr.c?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,534 @@\n+/* GNU Objective C Runtime Thread Interface\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <stdlib.h>\n+#include \"runtime.h\"\n+\n+/* Global exit status. */\n+int __objc_thread_exit_status = 0;\n+\n+/* Flag which lets us know if we ever became multi threaded */\n+int __objc_is_multi_threaded = 0;\n+\n+/* The hook function called when the runtime becomes multi threaded */\n+objc_thread_callback _objc_became_multi_threaded = NULL;\n+\n+/*\n+  Use this to set the hook function that will be called when the \n+  runtime initially becomes multi threaded.\n+  The hook function is only called once, meaning only when the \n+  2nd thread is spawned, not for each and every thread.\n+\n+  It returns the previous hook function or NULL if there is none.\n+\n+  A program outside of the runtime could set this to some function so\n+  it can be informed; for example, the GNUstep Base Library sets it \n+  so it can implement the NSBecomingMultiThreaded notification.\n+  */\n+objc_thread_callback objc_set_thread_callback(objc_thread_callback func)\n+{\n+  objc_thread_callback temp = _objc_became_multi_threaded;\n+  _objc_became_multi_threaded = func;\n+  return temp;\n+}\n+\n+/*\n+  Private functions\n+\n+  These functions are utilized by the frontend, but they are not\n+  considered part of the public interface.\n+  */\n+\n+/*\n+  First function called in a thread, starts everything else.\n+\n+  This function is passed to the backend by objc_thread_detach\n+  as the starting function for a new thread.\n+ */\n+struct __objc_thread_start_state\n+{\n+  SEL selector;\n+  id object;\n+  id argument;\n+};\n+\n+static volatile void\n+__objc_thread_detach_function(struct __objc_thread_start_state *istate)\n+{\n+  /* Valid state? */\n+  if (istate) {\n+    id (*imp)(id,SEL,id);\n+    SEL selector = istate->selector;\n+    id object   = istate->object;\n+    id argument = istate->argument;\n+\n+    /* Don't need anymore so free it */\n+    objc_free(istate);\n+\n+    /* Clear out the thread local storage */\n+    objc_thread_set_data(NULL);\n+\n+    /* Check to see if we just became multi threaded */\n+    if (!__objc_is_multi_threaded)\n+      {\n+\t__objc_is_multi_threaded = 1;\n+\n+\t/* Call the hook function */\n+\tif (_objc_became_multi_threaded != NULL)\n+\t  (*_objc_became_multi_threaded)();\n+      }\n+\n+    /* Call the method */\n+    if ((imp = (id(*)(id, SEL, id))objc_msg_lookup(object, selector)))\n+\t(*imp)(object, selector, argument);\n+    else\n+      objc_error(object, OBJC_ERR_UNIMPLEMENTED,\n+\t\t \"objc_thread_detach called with bad selector.\\n\");\n+  }\n+  else\n+    objc_error(nil, OBJC_ERR_BAD_STATE,\n+\t       \"objc_thread_detach called with NULL state.\\n\");\n+\n+  /* Exit the thread */\n+  objc_thread_exit();\n+}\n+\n+/*\n+  Frontend functions\n+\n+  These functions constitute the public interface to the Objective-C thread\n+  and mutex functionality.\n+  */\n+\n+/* Frontend thread functions */\n+\n+/*\n+  Detach a new thread of execution and return its id.  Returns NULL if fails.\n+  Thread is started by sending message with selector to object.  Message\n+  takes a single argument.\n+  */\n+objc_thread_t\n+objc_thread_detach(SEL selector, id object, id argument)\n+{\n+  struct __objc_thread_start_state *istate;\n+  objc_thread_t        thread_id = NULL;\n+\n+  /* Allocate the state structure */\n+  if (!(istate = (struct __objc_thread_start_state *)\n+\tobjc_malloc(sizeof(*istate))))\n+    return NULL;\n+\n+  /* Initialize the state structure */\n+  istate->selector = selector;\n+  istate->object = object;\n+  istate->argument = argument;\n+\n+  /* lock access */\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  /* Call the backend to spawn the thread */\n+  if ((thread_id = __objc_thread_detach((void *)__objc_thread_detach_function,\n+\t\t\t\t\tistate)) == NULL)\n+    {\n+      /* failed! */\n+      objc_mutex_unlock(__objc_runtime_mutex);\n+      objc_free(istate);\n+      return NULL;\n+    }\n+\n+  /* Increment our thread counter */\n+  __objc_runtime_threads_alive++;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+objc_thread_set_priority(int priority)\n+{\n+  /* Call the backend */\n+  return __objc_thread_set_priority(priority);\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+objc_thread_get_priority(void)\n+{\n+  /* Call the backend */\n+  return __objc_thread_get_priority();\n+}\n+\n+/*\n+  Yield our process time to another thread.  Any BUSY waiting that is done\n+  by a thread should use this function to make sure that other threads can\n+  make progress even on a lazy uniprocessor system.\n+  */\n+void\n+objc_thread_yield(void)\n+{\n+  /* Call the backend */\n+  __objc_thread_yield();\n+}\n+\n+/*\n+  Terminate the current tread.  Doesn't return.\n+  Actually, if it failed returns -1.\n+  */\n+int\n+objc_thread_exit(void)\n+{\n+  /* Decrement our counter of the number of threads alive */\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  __objc_runtime_threads_alive--;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n+  /* Call the backend to terminate the thread */\n+  return __objc_thread_exit();\n+}\n+\n+/*\n+  Returns an integer value which uniquely describes a thread.  Must not be\n+  NULL which is reserved as a marker for \"no thread\".\n+  */\n+objc_thread_t\n+objc_thread_id(void)\n+{\n+  /* Call the backend */\n+  return __objc_thread_id();\n+}\n+\n+/*\n+  Sets the thread's local storage pointer. \n+  Returns 0 if successful or -1 if failed.\n+  */\n+int\n+objc_thread_set_data(void *value)\n+{\n+  /* Call the backend */\n+  return __objc_thread_set_data(value);\n+}\n+\n+/*\n+  Returns the thread's local storage pointer.  Returns NULL on failure.\n+  */\n+void *\n+objc_thread_get_data(void)\n+{\n+  /* Call the backend */\n+  return __objc_thread_get_data();\n+}\n+\n+/* Frontend mutex functions */\n+\n+/*\n+  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n+  allocation failed for any reason.\n+  */\n+objc_mutex_t\n+objc_mutex_allocate(void)\n+{\n+  objc_mutex_t mutex;\n+\n+  /* Allocate the mutex structure */\n+  if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n+    return NULL;\n+\n+  /* Call backend to create the mutex */\n+  if (__objc_mutex_allocate(mutex))\n+    {\n+      /* failed! */\n+      objc_free(mutex);\n+      return NULL;\n+    }\n+\n+  /* Initialize mutex */\n+  mutex->owner = NULL;\n+  mutex->depth = 0;\n+  return mutex;\n+}\n+\n+/*\n+  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n+  insure that no one else is using the lock.  It is legal to deallocate\n+  a lock if we have a lock on it, but illegal to deallocate a lock held\n+  by anyone else.\n+  Returns the number of locks on the thread.  (1 for deallocate).\n+  */\n+int\n+objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  int depth;\n+\n+  /* Valid mutex? */\n+  if (!mutex)\n+    return -1;\n+\n+  /* Acquire lock on mutex */\n+  depth = objc_mutex_lock(mutex);\n+\n+  /* Call backend to destroy mutex */\n+  if (__objc_mutex_deallocate(mutex))\n+    return -1;\n+\n+  /* Free the mutex structure */\n+  objc_free(mutex);\n+\n+  /* Return last depth */\n+  return depth;\n+}\n+\n+/*\n+  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n+  then we increment the lock count.  If another thread has a lock on the \n+  mutex we block and wait for the thread to release the lock.\n+  Returns the lock count on the mutex held by this thread.\n+  */\n+int\n+objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  objc_thread_t thread_id;\n+  int status;\n+\n+  /* Valid mutex? */\n+  if (!mutex)\n+    return -1;\n+\n+  /* If we already own the lock then increment depth */\n+  thread_id = objc_thread_id();\n+  if (mutex->owner == thread_id)\n+    return ++mutex->depth;\n+\n+  /* Call the backend to lock the mutex */\n+  status = __objc_mutex_lock(mutex);\n+\n+  /* Failed? */\n+  if (status)\n+    return status;\n+\n+  /* Successfully locked the thread */\n+  mutex->owner = thread_id;\n+  return mutex->depth = 1;\n+}\n+\n+/*\n+  Try to grab a lock on a mutex.  If this thread already has a lock on\n+  this mutex then we increment the lock count and return it.  If another\n+  thread has a lock on the mutex returns -1.\n+  */\n+int\n+objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  objc_thread_t thread_id;\n+  int status;\n+\n+  /* Valid mutex? */\n+  if (!mutex)\n+    return -1;\n+\n+  /* If we already own the lock then increment depth */ \n+  thread_id = objc_thread_id();\n+  if (mutex->owner == thread_id)\n+    return ++mutex->depth;\n+    \n+  /* Call the backend to try to lock the mutex */\n+  status = __objc_mutex_trylock(mutex);\n+\n+  /* Failed? */\n+  if (status)\n+    return status;\n+\n+  /* Successfully locked the thread */\n+  mutex->owner = thread_id;\n+  return mutex->depth = 1;\n+}\n+\n+/* \n+  Unlocks the mutex by one level.\n+  Decrements the lock count on this mutex by one.\n+  If the lock count reaches zero, release the lock on the mutex.\n+  Returns the lock count on the mutex.\n+  It is an error to attempt to unlock a mutex which this thread \n+  doesn't hold in which case return -1 and the mutex is unaffected.\n+  */\n+int\n+objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  objc_thread_t thread_id;\n+  int status;\n+\n+  /* Valid mutex? */\n+  if (!mutex)\n+    return -1;\n+\n+  /* If another thread owns the lock then abort */\n+  thread_id = objc_thread_id();\n+  if (mutex->owner != thread_id)\n+    return -1;\n+\n+  /* Decrement depth and return */\n+  if (mutex->depth > 1)\n+    return --mutex->depth;\n+\n+  /* Depth down to zero so we are no longer the owner */\n+  mutex->depth = 0;\n+  mutex->owner = NULL;\n+\n+  /* Have the backend unlock the mutex */\n+  status = __objc_mutex_unlock(mutex);\n+\n+  /* Failed? */\n+  if (status)\n+    return status;\n+\n+  return 0;\n+}\n+\n+/* Frontend condition mutex functions */\n+\n+/*\n+  Allocate a condition.  Return the condition pointer if successful or NULL\n+  if the allocation failed for any reason.\n+  */\n+objc_condition_t \n+objc_condition_allocate(void)\n+{\n+  objc_condition_t condition;\n+    \n+  /* Allocate the condition mutex structure */\n+  if (!(condition = \n+\t(objc_condition_t)objc_malloc(sizeof(struct objc_condition))))\n+    return NULL;\n+\n+  /* Call the backend to create the condition mutex */\n+  if (__objc_condition_allocate(condition))\n+    {\n+      /* failed! */\n+      objc_free(condition);\n+      return NULL;\n+    }\n+\n+  /* Success! */\n+  return condition;\n+}\n+\n+/*\n+  Deallocate a condition. Note that this includes an implicit \n+  condition_broadcast to insure that waiting threads have the opportunity\n+  to wake.  It is legal to dealloc a condition only if no other\n+  thread is/will be using it. Here we do NOT check for other threads\n+  waiting but just wake them up.\n+  */\n+int\n+objc_condition_deallocate(objc_condition_t condition)\n+{\n+  /* Broadcast the condition */\n+  if (objc_condition_broadcast(condition))\n+    return -1;\n+\n+  /* Call the backend to destroy */\n+  if (__objc_condition_deallocate(condition))\n+    return -1;\n+\n+  /* Free the condition mutex structure */\n+  objc_free(condition);\n+\n+  return 0;\n+}\n+\n+/*\n+  Wait on the condition unlocking the mutex until objc_condition_signal()\n+  or objc_condition_broadcast() are called for the same condition. The\n+  given mutex *must* have the depth set to 1 so that it can be unlocked\n+  here, so that someone else can lock it and signal/broadcast the condition.\n+  The mutex is used to lock access to the shared data that make up the\n+  \"condition\" predicate.\n+  */\n+int\n+objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  objc_thread_t thread_id;\n+\n+  /* Valid arguments? */\n+  if (!mutex || !condition)\n+    return -1;\n+\n+  /* Make sure we are owner of mutex */\n+  thread_id = objc_thread_id();\n+  if (mutex->owner != thread_id)\n+    return -1;\n+\n+  /* Cannot be locked more than once */\n+  if (mutex->depth > 1)\n+    return -1;\n+\n+  /* Virtually unlock the mutex */\n+  mutex->depth = 0;\n+  mutex->owner = (objc_thread_t)NULL;\n+\n+  /* Call the backend to wait */\n+  __objc_condition_wait(condition, mutex);\n+\n+  /* Make ourselves owner of the mutex */\n+  mutex->owner = thread_id;\n+  mutex->depth = 1;\n+\n+  return 0;\n+}\n+\n+/*\n+  Wake up all threads waiting on this condition. It is recommended that \n+  the called would lock the same mutex as the threads in objc_condition_wait\n+  before changing the \"condition predicate\" and make this call and unlock it\n+  right away after this call.\n+  */\n+int\n+objc_condition_broadcast(objc_condition_t condition)\n+{\n+  /* Valid condition mutex? */\n+  if (!condition)\n+    return -1;\n+\n+  return __objc_condition_broadcast(condition);\n+}\n+\n+/*\n+  Wake up one thread waiting on this condition. It is recommended that \n+  the called would lock the same mutex as the threads in objc_condition_wait\n+  before changing the \"condition predicate\" and make this call and unlock it\n+  right away after this call.\n+  */\n+int\n+objc_condition_signal(objc_condition_t condition)\n+{\n+  /* Valid condition mutex? */\n+  if (!condition)\n+    return -1;\n+\n+  return __objc_condition_signal(condition);\n+}\n+\n+/* End of File */"}, {"sha": "f904733695a8dcae589611a625803f84d86f9e66", "filename": "libobjc/thr.h", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Fthr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,143 @@\n+/* Thread and mutex controls for Objective C.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License along with\n+GNU CC; see the file COPYING.  If not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+\n+#ifndef __thread_INCLUDE_GNU\n+#define __thread_INCLUDE_GNU\n+\n+#include \"objc/objc.h\"\n+\n+/*************************************************************************\n+ *  Universal static variables:\n+ */\n+extern int __objc_thread_exit_status;      /* Global exit status.   */\n+\n+/********\n+ *  Thread safe implementation types and functions.  \n+ */\n+\n+/* Thread priorities */\n+#define OBJC_THREAD_INTERACTIVE_PRIORITY        2\n+#define OBJC_THREAD_BACKGROUND_PRIORITY         1\n+#define OBJC_THREAD_LOW_PRIORITY                0\n+\n+/* A thread */\n+typedef void * objc_thread_t;\n+\n+/* This structure represents a single mutual exclusion lock. */\n+struct objc_mutex\n+{\n+  volatile objc_thread_t owner;     /* Id of thread that owns. */\n+  volatile int depth;               /* # of acquires. */\n+  void * backend;                   /* Specific to backend */\n+};\n+typedef struct objc_mutex *objc_mutex_t;\n+\n+/* This structure represents a single condition mutex */\n+struct objc_condition\n+{\n+  void * backend;                   /* Specific to backend */\n+};\n+typedef struct objc_condition *objc_condition_t;\n+\n+/* Frontend mutex functions */\n+objc_mutex_t objc_mutex_allocate(void);\n+int objc_mutex_deallocate(objc_mutex_t mutex);\n+int objc_mutex_lock(objc_mutex_t mutex);\n+int objc_mutex_unlock(objc_mutex_t mutex);\n+int objc_mutex_trylock(objc_mutex_t mutex);\n+\n+/* Frontend condition mutex functions */\n+objc_condition_t objc_condition_allocate(void);\n+int objc_condition_deallocate(objc_condition_t condition);\n+int objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex);\n+int objc_condition_signal(objc_condition_t condition);\n+int objc_condition_broadcast(objc_condition_t condition);\n+\n+/* Frontend thread functions */\n+objc_thread_t objc_thread_detach(SEL selector, id object, id argument);\n+void objc_thread_yield(void);\n+int objc_thread_exit(void);\n+int objc_thread_set_priority(int priority);\n+int objc_thread_get_priority(void);\n+void * objc_thread_get_data(void);\n+int objc_thread_set_data(void *value);\n+objc_thread_t objc_thread_id(void);\n+\n+/*\n+  Use this to set the hook function that will be called when the \n+  runtime initially becomes multi threaded.\n+  The hook function is only called once, meaning only when the \n+  2nd thread is spawned, not for each and every thread.\n+\n+  It returns the previous hook function or NULL if there is none.\n+\n+  A program outside of the runtime could set this to some function so\n+  it can be informed; for example, the GNUstep Base Library sets it \n+  so it can implement the NSBecomingMultiThreaded notification.\n+  */\n+typedef void (*objc_thread_callback)();\n+objc_thread_callback objc_set_thread_callback(objc_thread_callback func);\n+\n+/* Backend initialization functions */\n+int __objc_init_thread_system(void);\n+int __objc_fini_thread_system(void);\n+\n+/* Backend mutex functions */\n+int __objc_mutex_allocate(objc_mutex_t mutex);\n+int __objc_mutex_deallocate(objc_mutex_t mutex);\n+int __objc_mutex_lock(objc_mutex_t mutex);\n+int __objc_mutex_trylock(objc_mutex_t mutex);\n+int __objc_mutex_unlock(objc_mutex_t mutex);\n+\n+/* Backend condition mutex functions */\n+int __objc_condition_allocate(objc_condition_t condition);\n+int __objc_condition_deallocate(objc_condition_t condition);\n+int __objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex);\n+int __objc_condition_broadcast(objc_condition_t condition);\n+int __objc_condition_signal(objc_condition_t condition);\n+\n+/* Backend thread functions */\n+objc_thread_t __objc_thread_detach(void (*func)(void *arg), void *arg);\n+int __objc_thread_set_priority(int priority);\n+int __objc_thread_get_priority(void);\n+void __objc_thread_yield(void);\n+int __objc_thread_exit(void);\n+objc_thread_t __objc_thread_id(void);\n+int __objc_thread_set_data(void *value);\n+void * __objc_thread_get_data(void);\n+\n+#endif /* not __thread_INCLUDE_GNU */"}, {"sha": "eb4642f344be82a159b59d4d00e0a824b9a02201", "filename": "libobjc/typedstream.h", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Ftypedstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e17b57eb71b79759e59d68883ce797d00488fb/libobjc%2Ftypedstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Ftypedstream.h?ref=88e17b57eb71b79759e59d68883ce797d00488fb", "patch": "@@ -0,0 +1,132 @@\n+/* GNU Objective-C Typed Streams interface.\n+   Copyright (C) 1993, 1995 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled\n+   with GCC to produce an executable, this does not cause the resulting\n+   executable to be covered by the GNU General Public License.  This\n+   exception does not however invalidate any other reasons why the\n+   executable file might be covered by the GNU General Public License. */\n+\n+#ifndef __typedstream_INCLUDE_GNU\n+#define __typedstream_INCLUDE_GNU\n+\n+#include \"objc/objc.h\"\n+#include \"objc/hash.h\"\n+#include <stdio.h>\n+\n+typedef int (*objc_typed_read_func)(void*, char*, int);\n+typedef int (*objc_typed_write_func)(void*, const char*, int);\n+typedef int (*objc_typed_flush_func)(void*);\n+typedef int (*objc_typed_eof_func)(void*);\n+\n+#define OBJC_READONLY   0x01\n+#define OBJC_WRITEONLY  0x02\n+\n+#define OBJC_MANAGED_STREAM  0x01\n+#define OBJC_FILE_STREAM     0x02\n+#define OBJC_MEMORY_STREAM   0x04\n+\n+#define OBJC_TYPED_STREAM_VERSION 0x01\n+\n+typedef struct objc_typed_stream {\n+  void* physical;\n+  cache_ptr object_table;\t/* read/written objects */\n+  cache_ptr stream_table;\t/* other read/written but shared things.. */\n+  cache_ptr class_table;\t/* class version mapping */\n+  cache_ptr object_refs;\t/* forward references */\n+  int mode;\t\t\t/* OBJC_READONLY or OBJC_WRITEONLY */\n+  int type;\t\t\t/* MANAGED, FILE, MEMORY etc bit string */\n+  int version;\t\t\t/* version used when writing */\n+  int writing_root_p;\n+  objc_typed_read_func read;\n+  objc_typed_write_func write;\n+  objc_typed_eof_func eof;\n+  objc_typed_flush_func flush;\n+} TypedStream;\n+\n+/* opcode masks */\n+#define _B_VALUE   0x1fU\n+#define _B_CODE    0xe0U\n+#define _B_SIGN    0x10U\n+#define _B_NUMBER  0x0fU\n+\n+/* standard opcodes */\n+#define _B_INVALID 0x00U\n+#define _B_SINT    0x20U\n+#define _B_NINT    0x40U\n+#define _B_SSTR    0x60U\n+#define _B_NSTR    0x80U\n+#define _B_RCOMM   0xa0U\n+#define _B_UCOMM   0xc0U\n+#define _B_EXT     0xe0U\n+\n+/* eXtension opcodes */\n+#define _BX_OBJECT  0x00U\n+#define _BX_CLASS   0x01U\n+#define _BX_SEL     0x02U\n+#define _BX_OBJREF  0x03U\n+#define _BX_OBJROOT 0x04U\n+#define _BX_EXT     0x1fU\n+\n+/*\n+** Read and write objects as specified by TYPE.  All the `last'\n+** arguments are pointers to the objects to read/write.  \n+*/\n+\n+int objc_write_type (TypedStream* stream, const char* type, const void* data);\n+int objc_read_type (TypedStream* stream, const char* type, void* data);\n+\n+int objc_write_types (TypedStream* stream, const char* type, ...);\n+int objc_read_types (TypedStream* stream, const char* type, ...);\n+\n+int objc_write_object_reference (TypedStream* stream, id object);\n+int objc_write_root_object (TypedStream* stream, id object);\n+\n+long objc_get_stream_class_version (TypedStream* stream, Class class);\n+\n+\n+/*\n+** Convenience functions\n+*/\n+\n+int objc_write_array (TypedStream* stream, const char* type,\n+\t\t      int count, const void* data);\n+int objc_read_array (TypedStream* stream, const char* type,\n+\t\t     int count, void* data);\n+\n+int objc_write_object (TypedStream* stream, id object);\n+int objc_read_object (TypedStream* stream, id* object);\n+\n+\n+\n+/*\n+** Open a typed stream for reading or writing.  MODE may be either of\n+** OBJC_READONLY or OBJC_WRITEONLY.  \n+*/\n+\n+TypedStream* objc_open_typed_stream (FILE* physical, int mode);\n+TypedStream* objc_open_typed_stream_for_file (const char* file_name, int mode);\n+\n+void objc_close_typed_stream (TypedStream* stream);\n+\n+BOOL objc_end_of_typed_stream (TypedStream* stream);\n+void objc_flush_typed_stream (TypedStream* stream);\n+\n+#endif /* not __typedstream_INCLUDE_GNU */"}]}