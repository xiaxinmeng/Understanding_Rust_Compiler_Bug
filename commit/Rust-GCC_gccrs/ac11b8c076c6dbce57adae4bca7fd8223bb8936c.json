{"sha": "ac11b8c076c6dbce57adae4bca7fd8223bb8936c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMxMWI4YzA3NmM2ZGJjZTU3YWRhZTRiY2E3ZmQ4MjIzYmI4OTM2Yw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-06-28T00:01:13Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-06-28T00:01:13Z"}, "message": "vsx.md (UNSPEC_P9_MEMORY): New unspec to support loading and storing byte/half-word values in the vector...\n\n[gcc]\n2016-06-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/vsx.md (UNSPEC_P9_MEMORY): New unspec to support\n\tloading and storing byte/half-word values in the vector registers.\n\t(vsx_sign_extend_hi_<mode>): Enable the generator function.\n\t(p9_lxsi<wd>zx): New insns to load zero-extended bytes and\n\thalf-words on ISA 3.0 to the vector registers.\n\t(p9_stxsi<wd>zx): New insns to store zero-extended bytes and\n\thalf-words on ISA 3.0 from the vector registers.\n\t* config/rs6000/rs6000.md (FP_ISA3): New iterator to optimize\n\tconverting char/half-word items to floating point on ISA 3.0.\n\t(float<QHI:mode><FP_ISA3:mode>2): On ISA 3.0 generate the lxsihzx\n\tand lxsibzx instructions if we are converting an 8-bit or 16-bit\n\titem from memory to floating point.\n\t(float<QHI:mode><FP_ISA3:mode>2_internal): Likewise.\n\t(floatuns<QHI:mode><FP_ISA3:mode>2): Likewise.\n\t(floatuns<QHI:mode><FP_ISA3:mode>2_internal): Likewise.\n\t(fix_trunc<SFDF:mode><QHI:mode>2): On ISA 3.0 generate the stxsihx\n\tand stxsibx instructions to store floating point values converted\n\tto 8 or 16-bit integers.\n\t(fixuns_trunc<mode>si2): Likewise.\n\n[gcc/testsuite]\n2016-06-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/p9-fpcvt-1.c: New test to test ISA 3.0 load\n\tbyte/half-word to vector registers and store byte/half-word from\n\tvector register instructions.\n\t* gcc.target/powerpc/p9-fpcvt-2.c: Likewise.\n\nFrom-SVN: r237806", "tree": {"sha": "b3c57ec34df767be5e78bdc7217001bad31bdeeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3c57ec34df767be5e78bdc7217001bad31bdeeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac11b8c076c6dbce57adae4bca7fd8223bb8936c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac11b8c076c6dbce57adae4bca7fd8223bb8936c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac11b8c076c6dbce57adae4bca7fd8223bb8936c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac11b8c076c6dbce57adae4bca7fd8223bb8936c/comments", "author": null, "committer": null, "parents": [{"sha": "dc448fa03b361f130e7b4554d5e0e5d52e06c891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc448fa03b361f130e7b4554d5e0e5d52e06c891", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc448fa03b361f130e7b4554d5e0e5d52e06c891"}], "stats": {"total": 201, "additions": 200, "deletions": 1}, "files": [{"sha": "9a3907993bad8c09572e25e6d0ec21ac299d8d46", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac11b8c076c6dbce57adae4bca7fd8223bb8936c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac11b8c076c6dbce57adae4bca7fd8223bb8936c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=ac11b8c076c6dbce57adae4bca7fd8223bb8936c", "patch": "@@ -506,6 +506,12 @@\n \t\t\t\t(IF \"TARGET_FLOAT128\")\n \t\t\t\t(TF \"TARGET_LONG_DOUBLE_128\")])\n \n+; Iterator for ISA 3.0 supported floating point types\n+(define_mode_iterator FP_ISA3 [SF\n+\t\t\t       DF\n+\t\t\t       (KF \"FLOAT128_IEEE_P (KFmode)\")\n+\t\t\t       (TF \"FLOAT128_IEEE_P (TFmode)\")])\n+\n ; SF/DF suffix for traditional floating instructions\n (define_mode_attr Ftrad\t\t[(SF \"s\") (DF \"\")])\n \n@@ -5188,6 +5194,107 @@\n   [(set_attr \"length\" \"20\")\n    (set_attr \"type\" \"fp\")])\n \n+;; ISA 3.0 adds instructions lxsi[bh]zx to directly load QImode and HImode to\n+;; vector registers.  At the moment, QI/HImode are not allowed in floating\n+;; point or vector registers, so we use UNSPEC's to use the load byte and\n+;; half-word instructions.\n+\n+(define_expand \"float<QHI:mode><FP_ISA3:mode>2\"\n+  [(parallel [(set (match_operand:FP_ISA3 0 \"vsx_register_operand\")\n+\t\t   (float:FP_ISA3\n+\t\t    (match_operand:QHI 1 \"input_operand\")))\n+\t      (clobber (match_scratch:DI 2))\n+\t      (clobber (match_scratch:DI 3))])]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\"\n+{\n+  if (MEM_P (operands[1]))\n+    operands[1] = rs6000_address_for_fpconvert (operands[1]);\n+})\n+\n+(define_insn_and_split \"*float<QHI:mode><FP_ISA3:mode>2_internal\"\n+  [(set (match_operand:FP_ISA3 0 \"vsx_register_operand\" \"=<Fv>,<Fv>\")\n+\t(float:FP_ISA3\n+\t (match_operand:QHI 1 \"reg_or_indexed_operand\" \"r,Z\")))\n+   (clobber (match_scratch:DI 2 \"=wi,v\"))\n+   (clobber (match_scratch:DI 3 \"=r,X\"))]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\n+   && TARGET_UPPER_REGS_DI\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx result = operands[0];\n+  rtx input = operands[1];\n+  rtx di = operands[2];\n+\n+  if (!MEM_P (input))\n+    {\n+      rtx tmp = operands[3];\n+      emit_insn (gen_extend<QHI:mode>di2 (tmp, input));\n+      emit_move_insn (di, tmp);\n+    }\n+  else\n+    {\n+      machine_mode vmode;\n+      rtx di_vector;\n+\n+      emit_insn (gen_p9_lxsi<QHI:wd>zx (di, input));\n+\n+      if (<MODE>mode == QImode)\n+\tvmode = V16QImode;\n+      else if (<MODE>mode == HImode)\n+\tvmode = V8HImode;\n+      else\n+\tgcc_unreachable ();\n+\n+      di_vector = gen_rtx_REG (vmode, REGNO (di));\n+      emit_insn (gen_vsx_sign_extend_<QHI:mode>_di (di, di_vector));\n+    }\n+\n+  emit_insn (gen_floatdi<FP_ISA3:mode>2 (result, di));\n+  DONE;\n+})\n+\n+(define_expand \"floatuns<QHI:mode><FP_ISA3:mode>2\"\n+  [(parallel [(set (match_operand:FP_ISA3 0 \"vsx_register_operand\" \"\")\n+\t\t   (unsigned_float:FP_ISA3\n+\t\t    (match_operand:QHI 1 \"input_operand\" \"\")))\n+\t      (clobber (match_scratch:DI 2 \"\"))\n+\t      (clobber (match_scratch:DI 3 \"\"))])]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\"\n+{\n+  if (MEM_P (operands[1]))\n+    operands[1] = rs6000_address_for_fpconvert (operands[1]);\n+})\n+\n+(define_insn_and_split \"*floatuns<QHI:mode><FP_ISA3:mode>2_internal\"\n+  [(set (match_operand:FP_ISA3 0 \"vsx_register_operand\" \"=<Fv>,<Fv>\")\n+\t(unsigned_float:FP_ISA3\n+\t (match_operand:QHI 1 \"reg_or_indexed_operand\" \"r,Z\")))\n+   (clobber (match_scratch:DI 2 \"=wi,wi\"))\n+   (clobber (match_scratch:DI 3 \"=r,X\"))]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx result = operands[0];\n+  rtx input = operands[1];\n+  rtx di = operands[2];\n+  rtx tmp = operands[3];\n+\n+  if (!MEM_P (input))\n+    {\n+      emit_insn (gen_zero_extend<QHI:mode>di2 (tmp, input));\n+      emit_move_insn (di, tmp);\n+    }\n+  else\n+    emit_insn (gen_p9_lxsi<QHI:wd>zx (di, input));\n+\n+  emit_insn (gen_floatdi<FP_ISA3:mode>2 (result, di));\n+  DONE;\n+})\n+\n (define_expand \"fix_trunc<mode>si2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n@@ -5296,6 +5403,23 @@\n    xscvdpsxds %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_expand \"fix_trunc<SFDF:mode><QHI:mode>2\"\n+  [(use (match_operand:QHI 0 \"rs6000_nonimmediate_operand\" \"\"))\n+   (use (match_operand:SFDF 1 \"vsx_register_operand\" \"\"))]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx di_tmp = gen_reg_rtx (DImode);\n+\n+  if (MEM_P (op0))\n+    op0 = rs6000_address_for_fpconvert (op0);\n+\n+  emit_insn (gen_fctiwz_<SFDF:mode> (di_tmp, op1));\n+  emit_insn (gen_p9_stxsi<QHI:wd>x (op0, di_tmp));\n+  DONE;\n+})\n+\n (define_expand \"fixuns_trunc<mode>si2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"\")))]\n@@ -5368,6 +5492,23 @@\n    xscvdpuxds %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_expand \"fixuns_trunc<SFDF:mode><QHI:mode>2\"\n+  [(use (match_operand:QHI 0 \"rs6000_nonimmediate_operand\" \"\"))\n+   (use (match_operand:SFDF 1 \"vsx_register_operand\" \"\"))]\n+  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE && TARGET_POWERPC64\"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx di_tmp = gen_reg_rtx (DImode);\n+\n+  if (MEM_P (op0))\n+    op0 = rs6000_address_for_fpconvert (op0);\n+\n+  emit_insn (gen_fctiwuz_<SFDF:mode> (di_tmp, op1));\n+  emit_insn (gen_p9_stxsi<QHI:wd>x (op0, di_tmp));\n+  DONE;\n+})\n+\n ; Here, we use (set (reg) (unspec:DI [(fix:SI ...)] UNSPEC_FCTIWZ))\n ; rather than (set (subreg:SI (reg)) (fix:SI ...))\n ; because the first makes it clear that operand 0 is not live"}, {"sha": "b53655f3bdeb9aa94f64530b4652faef550fb95e", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac11b8c076c6dbce57adae4bca7fd8223bb8936c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac11b8c076c6dbce57adae4bca7fd8223bb8936c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=ac11b8c076c6dbce57adae4bca7fd8223bb8936c", "patch": "@@ -293,6 +293,7 @@\n    UNSPEC_VSX_XVCVDPSXDS\n    UNSPEC_VSX_XVCVDPUXDS\n    UNSPEC_VSX_SIGN_EXTEND\n+   UNSPEC_P9_MEMORY\n   ])\n \n ;; VSX moves\n@@ -2705,7 +2706,7 @@\n   \"vextsb2<wd> %0,%1\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n-(define_insn \"*vsx_sign_extend_hi_<mode>\"\n+(define_insn \"vsx_sign_extend_hi_<mode>\"\n   [(set (match_operand:VSINT_84 0 \"vsx_register_operand\" \"=v\")\n \t(unspec:VSINT_84\n \t [(match_operand:V8HI 1 \"vsx_register_operand\" \"v\")]\n@@ -2721,3 +2722,24 @@\n   \"TARGET_P9_VECTOR\"\n   \"vextsw2d %0,%1\"\n   [(set_attr \"type\" \"vecsimple\")])\n+\n+\f\n+;; ISA 3.0 memory operations\n+(define_insn \"p9_lxsi<wd>zx\"\n+  [(set (match_operand:DI 0 \"vsx_register_operand\" \"=wi\")\n+\t(unspec:DI [(zero_extend:DI\n+\t\t     (match_operand:QHI 1 \"indexed_or_indirect_operand\" \"Z\"))]\n+\t\t   UNSPEC_P9_MEMORY))]\n+  \"TARGET_P9_VECTOR\"\n+  \"lxsi<wd>zx %x0,%y1\"\n+  [(set_attr \"type\" \"fpload\")])\n+\n+(define_insn \"p9_stxsi<wd>x\"\n+  [(set (match_operand:QHI 0 \"reg_or_indexed_operand\" \"=r,Z\")\n+\t(unspec:QHI [(match_operand:DI 1 \"vsx_register_operand\" \"wi,wi\")]\n+\t\t    UNSPEC_P9_MEMORY))]\n+  \"TARGET_P9_VECTOR\"\n+  \"@\n+   mfvsrd %0,%x1\n+   stxsi<wd>x %x1,%y0\"\n+  [(set_attr \"type\" \"mffgpr,fpstore\")])"}, {"sha": "314749207d43447c6a4925219062477f49d0c444", "filename": "gcc/testsuite/gcc.target/powerpc/p9-fpcvt-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac11b8c076c6dbce57adae4bca7fd8223bb8936c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-fpcvt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac11b8c076c6dbce57adae4bca7fd8223bb8936c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-fpcvt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-fpcvt-1.c?ref=ac11b8c076c6dbce57adae4bca7fd8223bb8936c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+void sc (signed char    *p, double x) { *p = x; }\n+void uc (unsigned char  *p, double x) { *p = x; }\n+void ss (signed short   *p, double x) { *p = x; }\n+void us (unsigned short *p, double x) { *p = x; }\n+\n+/* { dg-final { scan-assembler     \"stxsibx\" } } */\n+/* { dg-final { scan-assembler     \"stxsihx\" } } */\n+/* { dg-final { scan-assembler-not \"mfvsrd\"  } } */\n+/* { dg-final { scan-assembler-not \"mfvsrwz\" } } */\n+/* { dg-final { scan-assembler-not \"mtvsrd\"  } } */\n+/* { dg-final { scan-assembler-not \"mtvsrwa\" } } */\n+/* { dg-final { scan-assembler-not \"mtvsrwz\" } } */"}, {"sha": "2d615f8203b30faf8e027d4f5b180588f3d2b0b5", "filename": "gcc/testsuite/gcc.target/powerpc/p9-fpcvt-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac11b8c076c6dbce57adae4bca7fd8223bb8936c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-fpcvt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac11b8c076c6dbce57adae4bca7fd8223bb8936c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-fpcvt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-fpcvt-2.c?ref=ac11b8c076c6dbce57adae4bca7fd8223bb8936c", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+double sc (signed char    *p) { return (double)*p; }\n+double uc (unsigned char  *p) { return (double)*p; }\n+double ss (signed short   *p) { return (double)*p; }\n+double us (unsigned short *p) { return (double)*p; }\n+\n+/* { dg-final { scan-assembler     \"lxsibzx\"  } } */\n+/* { dg-final { scan-assembler     \"lxsihzx\"  } } */\n+/* { dg-final { scan-assembler     \"vextsb2d\" } } */\n+/* { dg-final { scan-assembler     \"vextsh2d\" } } */\n+/* { dg-final { scan-assembler-not \"mfvsrd\"   } } */\n+/* { dg-final { scan-assembler-not \"mfvsrwz\"  } } */\n+/* { dg-final { scan-assembler-not \"mtvsrd\"   } } */\n+/* { dg-final { scan-assembler-not \"mtvsrwa\"  } } */\n+/* { dg-final { scan-assembler-not \"mtvsrwz\"  } } */"}]}