{"sha": "8e6ef852865d824395b89a21b782e52b99349f3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU2ZWY4NTI4NjVkODI0Mzk1Yjg5YTIxYjc4MmU1MmI5OTM0OWYzYw==", "commit": {"author": {"name": "Kirill Yukhin", "email": "kirill.yukhin@intel.com", "date": "2014-10-21T07:58:54Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-10-21T07:58:54Z"}, "message": "Revert r216483.\n\nFrom-SVN: r216502", "tree": {"sha": "33f700c54907a6b1c76c3d4492eea7ff14621731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33f700c54907a6b1c76c3d4492eea7ff14621731"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e6ef852865d824395b89a21b782e52b99349f3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e6ef852865d824395b89a21b782e52b99349f3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e6ef852865d824395b89a21b782e52b99349f3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e6ef852865d824395b89a21b782e52b99349f3c/comments", "author": null, "committer": null, "parents": [{"sha": "11204b2de523611cf7f1135aa5ff1cfb1bb11001", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11204b2de523611cf7f1135aa5ff1cfb1bb11001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11204b2de523611cf7f1135aa5ff1cfb1bb11001"}], "stats": {"total": 116, "additions": 45, "deletions": 71}, "files": [{"sha": "7d2878db8ee60edd3fbb38c778853ceb4d43b5d8", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6ef852865d824395b89a21b782e52b99349f3c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6ef852865d824395b89a21b782e52b99349f3c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=8e6ef852865d824395b89a21b782e52b99349f3c", "patch": "@@ -1,3 +1,7 @@\n+2014-10-21  Kirill Yukhin  <kirill.yukhin@intel.com>\n+\n+\t* cilk.c: Revert previous change.\n+\n 2014-10-20  Igor Zamyatin  <igor.zamyatin@intel.com>\n \n \tPR c/63307"}, {"sha": "20b343214d4fff334e61866360aa1b25946da322", "filename": "gcc/c-family/cilk.c", "status": "modified", "additions": 41, "deletions": 71, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6ef852865d824395b89a21b782e52b99349f3c/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6ef852865d824395b89a21b782e52b99349f3c/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=8e6ef852865d824395b89a21b782e52b99349f3c", "patch": "@@ -35,7 +35,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\" \n #include \"cgraph.h\"\n #include \"diagnostic.h\"\n-#include \"vec.h\"\n #include \"cilk.h\"\n \n enum add_variable_type {\n@@ -333,36 +332,17 @@ create_cilk_helper_decl (struct wrapper_data *wd)\n   return fndecl;\n }\n \n-struct cilk_decls\n-{\n-  tree key;\n-  tree *val;\n-};\n-\n-/* A function used by traversal to fill vector of decls for further work.  */\n+/* A function used by walk tree to find wrapper parms.  */\n \n bool\n-fill_decls_vec (tree const &key0, tree *val0, auto_vec<struct cilk_decls> *v)\n-{\n-  tree t1 = key0;\n-  struct cilk_decls dp;\n-\n-  dp.key = t1;\n-  dp.val = val0;\n-  v->safe_push (dp);\n-  return true;\n-}\n-\n-/* Function that actually creates necessary parm lists.  */\n-\n-static void\n-create_parm_list (struct wrapper_data *wd, tree *val0, tree arg)\n+wrapper_parm_cb (tree const &key0, tree *val0, wrapper_data *wd)\n {\n+  tree arg = key0;\n   tree val = *val0;\n   tree parm;\n \n   if (val == error_mark_node || val == arg)\n-    return;\n+    return true;\n \n   if (TREE_CODE (val) == PAREN_EXPR)\n     {\n@@ -380,7 +360,7 @@ create_parm_list (struct wrapper_data *wd, tree *val0, tree arg)\n \t}\n       else\n \targ = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (arg)), arg);\n-\n+\t\n       val = TREE_OPERAND (val, 0);\n       *val0 = val;\n       gcc_assert (TREE_CODE (val) == INDIRECT_REF);\n@@ -391,46 +371,23 @@ create_parm_list (struct wrapper_data *wd, tree *val0, tree arg)\n     parm = val;\n   TREE_CHAIN (parm) = wd->parms;\n   wd->parms = parm;\n-  wd->argtypes = tree_cons (NULL_TREE, TREE_TYPE (parm), wd->argtypes);\n-  wd->arglist = tree_cons (NULL_TREE, arg, wd->arglist);\n-}\n-\n-/* Sorting decls in a vector.  */\n-\n-static int\n-compare_decls (const void *a, const void *b)\n-{\n-  const struct cilk_decls* t1 = (const struct cilk_decls*) a;\n-  const struct cilk_decls* t2 = (const struct cilk_decls*) b;\n-\n-  if (DECL_UID (t1->key) > DECL_UID (t2->key))\n-    return 1;\n-  else if (DECL_UID (t1->key) < DECL_UID (t2->key))\n-    return -1;\n-  else\n-    return 0;\n+  wd->argtypes = tree_cons (NULL_TREE, TREE_TYPE (parm), wd->argtypes); \n+  wd->arglist = tree_cons (NULL_TREE, arg, wd->arglist); \n+  return true;\n }\n \n /* This function is used to build a wrapper of a certain type.  */\n \n static void\n build_wrapper_type (struct wrapper_data *wd)\n {\n-  unsigned int j;\n-  struct cilk_decls * c;\n-  auto_vec<struct cilk_decls> vd;\n   wd->arglist = NULL_TREE;\n   wd->parms = NULL_TREE;\n   wd->argtypes = void_list_node;\n \n-  wd->decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n+  wd->decl_map->traverse<wrapper_data *, wrapper_parm_cb> (wd);\n   gcc_assert (wd->type != CILK_BLOCK_FOR);\n \n-  vd.qsort (compare_decls);\n-\n-  FOR_EACH_VEC_ELT (vd, j, c)\n-   create_parm_list (wd, c->val, c->key);\n-\n   /* Now build a function.\n      Its return type is void (all side effects are via explicit parameters).\n      Its parameters are WRAPPER_PARMS with type WRAPPER_TYPES.\n@@ -491,19 +448,41 @@ copy_decl_for_cilk (tree decl, copy_body_data *id)\n     }\n }\n \n+/* Copy all local variables.  */\n+\n+bool\n+for_local_cb (tree const &k, tree *vp, copy_body_data *id)\n+{\n+  tree v = *vp;\n+\n+  if (v == error_mark_node)\n+    *vp = copy_decl_no_change (k, id);\n+  return true;\n+}\n+\n+/* Copy all local declarations from a _Cilk_spawned function's body.  */\n+\n+bool\n+wrapper_local_cb (tree const &key, tree *vp, copy_body_data *id)\n+{\n+  tree val = *vp;\n+\n+  if (val == error_mark_node)\n+    *vp = copy_decl_for_cilk (key, id);\n+\n+  return true;\n+}\n+\n /* Alter a tree STMT from OUTER_FN to form the body of INNER_FN.  */\n \n void\n cilk_outline (tree inner_fn, tree *stmt_p, void *w)\n {\n   struct wrapper_data *wd = (struct wrapper_data *) w;\n-  const tree outer_fn = wd->context;\n+  const tree outer_fn = wd->context;\t      \n   const bool nested = (wd->type == CILK_BLOCK_FOR);\n   copy_body_data id;\n   bool throws;\n-  auto_vec<struct cilk_decls> vd;\n-  unsigned int j;\n-  struct cilk_decls * c;\n \n   DECL_STATIC_CHAIN (outer_fn) = 1;\n \n@@ -529,13 +508,11 @@ cilk_outline (tree inner_fn, tree *stmt_p, void *w)\n \n   insert_decl_map (&id, wd->block, DECL_INITIAL (inner_fn));\n \n-  wd->decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n-  vd.qsort (compare_decls);\n   /* We don't want the private variables any more.  */\n-  FOR_EACH_VEC_ELT (vd, j, c)\n-   if (*(c->val) == error_mark_node)\n-     *(c->val) = nested ? copy_decl_no_change (c->key, &id)\n-\t\t\t: copy_decl_for_cilk (c->key, &id);\n+  if (nested)\n+    wd->decl_map->traverse<copy_body_data *, for_local_cb> (&id);\n+  else\n+    wd->decl_map->traverse<copy_body_data *, wrapper_local_cb> (&id);\n \n   walk_tree (stmt_p, copy_tree_body_r, (void *) &id, NULL);\n \n@@ -640,7 +617,7 @@ free_wd (struct wrapper_data *wd)\n */\n \n bool\n-declare_one_free_variable (tree var0, tree *map0)\n+declare_one_free_variable (tree const &var0, tree *map0, wrapper_data &)\n {\n   const_tree var = var0;\n   tree map = *map0;\n@@ -713,9 +690,6 @@ create_cilk_wrapper (tree exp, tree *args_out)\n {\n   struct wrapper_data wd;\n   tree fndecl;\n-  unsigned int j;\n-  struct cilk_decls * c;\n-  auto_vec<struct cilk_decls> vd;\n \n   init_wd (&wd, CILK_BLOCK_SPAWN);\n \n@@ -736,11 +710,7 @@ create_cilk_wrapper (tree exp, tree *args_out)\n     }\n   else\n     extract_free_variables (exp, &wd, ADD_READ);\n-  wd.decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n-  vd.qsort (compare_decls);\n-  FOR_EACH_VEC_ELT (vd, j, c)\n-   declare_one_free_variable (c->key, c->val);\n-\n+  wd.decl_map->traverse<wrapper_data &, declare_one_free_variable> (wd);\n   wd.block = TREE_BLOCK (exp);\n   if (!wd.block)\n     wd.block = DECL_INITIAL (current_function_decl);"}]}