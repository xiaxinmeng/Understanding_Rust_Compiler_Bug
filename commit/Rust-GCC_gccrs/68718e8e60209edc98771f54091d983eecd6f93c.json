{"sha": "68718e8e60209edc98771f54091d983eecd6f93c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg3MThlOGU2MDIwOWVkYzk4NzcxZjU0MDkxZDk4M2VlY2Q2ZjkzYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-14T12:41:55Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-14T12:41:55Z"}, "message": "Support for value ranges in IPA predicates\n\n\n        * ipa-cp.c (ipa_vr_operation_and_type_effects): Move up in file.\n\t(ipa_value_range_from_jfunc): New function.\n\t* ipa-fnsummary.c (evaluate_conditions_for_known_args): Add\n\tknown_value_ranges parameter; use it to evalulate conditions.\n\t(evaluate_properties_for_edge): Compute known value ranges.\n\t(ipa_fn_summary_t::duplicate): Update use of\n\tevaluate_conditions_for_known_args.\n\t(estimate_ipcp_clone_size_and_time): Likewise.\n\t(ipa_merge_fn_summary_after_inlining): Likewise.\n\t* ipa-prop.h (ipa_value_range_from_jfunc): Declare.\n\n        * gcc.dg/ipa/inline-9.c: New testcase.\n\nFrom-SVN: r278220", "tree": {"sha": "70300f4db395bcfd44ad4749a8f9d8354827813e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70300f4db395bcfd44ad4749a8f9d8354827813e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68718e8e60209edc98771f54091d983eecd6f93c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68718e8e60209edc98771f54091d983eecd6f93c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68718e8e60209edc98771f54091d983eecd6f93c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68718e8e60209edc98771f54091d983eecd6f93c/comments", "author": null, "committer": null, "parents": [{"sha": "afeb887562af17ea235fbec650ff6d16c412682a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afeb887562af17ea235fbec650ff6d16c412682a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afeb887562af17ea235fbec650ff6d16c412682a"}], "stats": {"total": 296, "additions": 242, "deletions": 54}, "files": [{"sha": "f35db511057e9087cf1605b08673561596f61158", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68718e8e60209edc98771f54091d983eecd6f93c", "patch": "@@ -1,3 +1,16 @@\n+2019-11-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-cp.c (ipa_vr_operation_and_type_effects): Move up in file.\n+\t(ipa_value_range_from_jfunc): New function.\n+\t* ipa-fnsummary.c (evaluate_conditions_for_known_args): Add\n+\tknown_value_ranges parameter; use it to evalulate conditions.\n+\t(evaluate_properties_for_edge): Compute known value ranges.\n+\t(ipa_fn_summary_t::duplicate): Update use of\n+\tevaluate_conditions_for_known_args.\n+\t(estimate_ipcp_clone_size_and_time): Likewise.\n+\t(ipa_merge_fn_summary_after_inlining): Likewise.\n+\t* ipa-prop.h (ipa_value_range_from_jfunc): Declare.\n+\n 2019-11-14  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-inline.c (want_inline_small_function_p): Use"}, {"sha": "8372dfaa7715f291e29848f621a3b84de53d2131", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 81, "deletions": 16, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=68718e8e60209edc98771f54091d983eecd6f93c", "patch": "@@ -1473,6 +1473,87 @@ ipa_context_from_jfunc (ipa_node_params *info, cgraph_edge *cs, int csidx,\n   return ctx;\n }\n \n+/* Emulate effects of unary OPERATION and/or conversion from SRC_TYPE to\n+   DST_TYPE on value range in SRC_VR and store it to DST_VR.  Return true if\n+   the result is a range or an anti-range.  */\n+\n+static bool\n+ipa_vr_operation_and_type_effects (value_range *dst_vr,\n+\t\t\t\t   value_range *src_vr,\n+\t\t\t\t   enum tree_code operation,\n+\t\t\t\t   tree dst_type, tree src_type)\n+{\n+  range_fold_unary_expr (dst_vr, operation, dst_type, src_vr, src_type);\n+  if (dst_vr->varying_p () || dst_vr->undefined_p ())\n+    return false;\n+  return true;\n+}\n+\n+/* Determine value_range of JFUNC given that INFO describes the caller node or\n+   the one it is inlined to, CS is the call graph edge corresponding to JFUNC\n+   and PARM_TYPE of the parameter.  */\n+\n+value_range\n+ipa_value_range_from_jfunc (ipa_node_params *info, cgraph_edge *cs,\n+\t\t\t    ipa_jump_func *jfunc, tree parm_type)\n+{\n+  value_range vr;\n+  return vr;\n+  if (jfunc->m_vr)\n+    ipa_vr_operation_and_type_effects (&vr,\n+\t\t\t\t       jfunc->m_vr,\n+\t\t\t\t       NOP_EXPR, parm_type,\n+\t\t\t\t       jfunc->m_vr->type ());\n+  if (vr.singleton_p ())\n+    return vr;\n+  if (jfunc->type == IPA_JF_PASS_THROUGH)\n+    {\n+      int idx;\n+      ipcp_transformation *sum\n+\t= ipcp_get_transformation_summary (cs->caller->inlined_to\n+\t\t\t\t\t   ? cs->caller->inlined_to\n+\t\t\t\t\t   : cs->caller);\n+      if (!sum || !sum->m_vr)\n+\treturn vr;\n+\n+      idx = ipa_get_jf_pass_through_formal_id (jfunc);\n+\n+      if (!(*sum->m_vr)[idx].known)\n+\treturn vr;\n+      tree vr_type = ipa_get_type (info, idx);\n+      value_range srcvr (wide_int_to_tree (vr_type, (*sum->m_vr)[idx].min),\n+\t\t\t wide_int_to_tree (vr_type, (*sum->m_vr)[idx].max),\n+\t\t\t (*sum->m_vr)[idx].type);\n+\n+      enum tree_code operation = ipa_get_jf_pass_through_operation (jfunc);\n+\n+      if (TREE_CODE_CLASS (operation) == tcc_unary)\n+\t{\n+\t  value_range res;\n+\n+\t  if (ipa_vr_operation_and_type_effects (&res,\n+\t\t\t\t\t\t &srcvr,\n+\t\t\t\t\t\t operation, parm_type,\n+\t\t\t\t\t\t vr_type))\n+\t    vr.intersect (res);\n+\t}\n+      else\n+\t{\n+\t  value_range op_res, res;\n+\t  tree op = ipa_get_jf_pass_through_operand (jfunc);\n+\t  value_range op_vr (op, op);\n+\n+\t  range_fold_binary_expr (&op_res, operation, vr_type, &srcvr, &op_vr);\n+\t  if (ipa_vr_operation_and_type_effects (&res,\n+\t\t\t\t\t\t &op_res,\n+\t\t\t\t\t\t NOP_EXPR, parm_type,\n+\t\t\t\t\t\t vr_type))\n+\t    vr.intersect (res);\n+\t}\n+    }\n+  return vr;\n+}\n+\n /* See if NODE is a clone with a known aggregate value at a given OFFSET of a\n    parameter with the given INDEX.  */\n \n@@ -2122,22 +2203,6 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n     return dest_lattice->set_to_bottom ();\n }\n \n-/* Emulate effects of unary OPERATION and/or conversion from SRC_TYPE to\n-   DST_TYPE on value range in SRC_VR and store it to DST_VR.  Return true if\n-   the result is a range or an anti-range.  */\n-\n-static bool\n-ipa_vr_operation_and_type_effects (value_range *dst_vr,\n-\t\t\t\t   value_range *src_vr,\n-\t\t\t\t   enum tree_code operation,\n-\t\t\t\t   tree dst_type, tree src_type)\n-{\n-  range_fold_unary_expr (dst_vr, operation, dst_type, src_vr, src_type);\n-  if (dst_vr->varying_p () || dst_vr->undefined_p ())\n-    return false;\n-  return true;\n-}\n-\n /* Propagate value range across jump function JFUNC that is associated with\n    edge CS with param of callee of PARAM_TYPE and update DEST_PLATS\n    accordingly.  */"}, {"sha": "9d8e1a566e30a01d725258c4ceb795fbc2a579f4", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 105, "deletions": 37, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=68718e8e60209edc98771f54091d983eecd6f93c", "patch": "@@ -316,6 +316,7 @@ static void\n evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t\t\t\t    bool inline_p,\n \t\t\t\t    vec<tree> known_vals,\n+\t\t\t\t    vec<value_range> known_value_ranges,\n \t\t\t\t    vec<ipa_agg_value_set> known_aggs,\n \t\t\t\t    clause_t *ret_clause,\n \t\t\t\t    clause_t *ret_nonspec_clause)\n@@ -371,7 +372,9 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t    val = NULL_TREE;\n \t}\n \n-      if (!val)\n+      if (!val\n+\t  && (c->code == predicate::changed\n+\t      || c->code == predicate::is_not_constant))\n \t{\n \t  clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n@@ -383,48 +386,101 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t  continue;\n \t}\n \n-      if (TYPE_SIZE (c->type) != TYPE_SIZE (TREE_TYPE (val)))\n-\t{\n-\t  clause |= 1 << (i + predicate::first_dynamic_condition);\n-\t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n-\t  continue;\n-\t}\n       if (c->code == predicate::is_not_constant)\n \t{\n \t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  continue;\n \t}\n \n-      val = fold_unary (VIEW_CONVERT_EXPR, c->type, val);\n-      for (j = 0; vec_safe_iterate (c->param_ops, j, &op); j++)\n+      if (val && TYPE_SIZE (c->type) == TYPE_SIZE (TREE_TYPE (val)))\n \t{\n-\t  if (!val)\n-\t    break;\n-\t  if (!op->val[0])\n-\t    val = fold_unary (op->code, op->type, val);\n-\t  else if (!op->val[1])\n-\t    val = fold_binary (op->code, op->type,\n-\t\t\t       op->index ? op->val[0] : val,\n-\t\t\t       op->index ? val : op->val[0]);\n-\t  else if (op->index == 0)\n-\t    val = fold_ternary (op->code, op->type,\n-\t\t\t\tval, op->val[0], op->val[1]);\n-\t  else if (op->index == 1)\n-\t    val = fold_ternary (op->code, op->type,\n-\t\t\t\top->val[0], val, op->val[1]);\n-\t  else if (op->index == 2)\n-\t    val = fold_ternary (op->code, op->type,\n-\t\t\t\top->val[0], op->val[1], val);\n-\t  else\n-\t    val = NULL_TREE;\n+\t  if (c->type != TREE_TYPE (val))\n+\t    val = fold_unary (VIEW_CONVERT_EXPR, c->type, val);\n+\t  for (j = 0; vec_safe_iterate (c->param_ops, j, &op); j++)\n+\t    {\n+\t      if (!val)\n+\t\tbreak;\n+\t      if (!op->val[0])\n+\t\tval = fold_unary (op->code, op->type, val);\n+\t      else if (!op->val[1])\n+\t\tval = fold_binary (op->code, op->type,\n+\t\t\t\t   op->index ? op->val[0] : val,\n+\t\t\t\t   op->index ? val : op->val[0]);\n+\t      else if (op->index == 0)\n+\t\tval = fold_ternary (op->code, op->type,\n+\t\t\t\t    val, op->val[0], op->val[1]);\n+\t      else if (op->index == 1)\n+\t\tval = fold_ternary (op->code, op->type,\n+\t\t\t\t    op->val[0], val, op->val[1]);\n+\t      else if (op->index == 2)\n+\t\tval = fold_ternary (op->code, op->type,\n+\t\t\t\t    op->val[0], op->val[1], val);\n+\t      else\n+\t\tval = NULL_TREE;\n+\t    }\n+\n+\t  res = val\n+\t    ? fold_binary_to_constant (c->code, boolean_type_node, val, c->val)\n+\t    : NULL;\n+\n+\t  if (res && integer_zerop (res))\n+\t    continue;\n+\t  if (res && integer_onep (res))\n+\t    {\n+\t      clause |= 1 << (i + predicate::first_dynamic_condition);\n+\t      nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n+\t      continue;\n+\t    }\n \t}\n+      if (c->operand_num < (int) known_value_ranges.length ()\n+\t  && !c->agg_contents\n+\t  && !known_value_ranges[c->operand_num].undefined_p ()\n+\t  && !known_value_ranges[c->operand_num].varying_p ()\n+\t  && TYPE_SIZE (c->type)\n+\t\t == TYPE_SIZE (known_value_ranges[c->operand_num].type ())\n+\t  && (!val || TREE_CODE (val) != INTEGER_CST))\n+\t{\n+\t  value_range vr = known_value_ranges[c->operand_num];\n+\t  if (!useless_type_conversion_p (c->type, vr.type ()))\n+\t    {\n+\t      value_range res;\n+\t      range_fold_unary_expr (&res, NOP_EXPR,\n+\t\t\t\t     c->type, &vr, vr.type ());\n+\t      vr = res;\n+\t    }\n+\t  tree type = c->type;\n \n-      res = val\n-\t? fold_binary_to_constant (c->code, boolean_type_node, val, c->val)\n-\t: NULL;\n+\t  for (j = 0; vec_safe_iterate (c->param_ops, j, &op); j++)\n+\t    {\n+\t      if (vr.varying_p () || vr.undefined_p ())\n+\t\tbreak;\n \n-      if (res && integer_zerop (res))\n-\tcontinue;\n+\t      value_range res;\n+\t      if (!op->val[0])\n+\t        range_fold_unary_expr (&res, op->code, op->type, &vr, type);\n+\t      else if (!op->val[1])\n+\t\t{\n+\t\t  value_range op0 (op->val[0], op->val[0]);\n+\t\t  range_fold_binary_expr (&res, op->code, op->type,\n+\t\t\t\t\t  op->index ? &op0 : &vr,\n+\t\t\t\t\t  op->index ? &vr : &op0);\n+\t\t}\n+\t      else\n+\t\tgcc_unreachable ();\n+\t      type = op->type;\n+\t      vr = res;\n+\t    }\n+\t  if (!vr.varying_p () && !vr.undefined_p ())\n+\t    {\n+\t      value_range res;\n+\t      value_range val_vr (c->val, c->val);\n+\t      range_fold_binary_expr (&res, c->code, boolean_type_node,\n+\t\t\t\t      &vr,\n+\t\t\t\t      &val_vr);\n+\t      if (res.zero_p ())\n+\t\tcontinue;\n+\t    }\n+\t}\n \n       clause |= 1 << (i + predicate::first_dynamic_condition);\n       nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n@@ -449,6 +505,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n   class ipa_fn_summary *info = ipa_fn_summaries->get (callee);\n   vec<tree> known_vals = vNULL;\n+  auto_vec<value_range, 32> known_value_ranges;\n   vec<ipa_agg_value_set> known_aggs = vNULL;\n   class ipa_edge_args *args;\n \n@@ -478,6 +535,8 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \n       if (count && (info->conds || known_vals_ptr))\n \tknown_vals.safe_grow_cleared (count);\n+      if (count && info->conds)\n+\tknown_value_ranges.safe_grow_cleared (count);\n       if (count && (info->conds || known_aggs_ptr))\n \tknown_aggs.safe_grow_cleared (count);\n       if (count && known_contexts_ptr)\n@@ -512,6 +571,10 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\n \t    known_aggs[i] = ipa_agg_value_set_from_jfunc (caller_parms_info,\n \t\t\t\t\t\t\t  caller, &jf->agg);\n+            if (info->conds)\n+              known_value_ranges[i] \n+                = ipa_value_range_from_jfunc (caller_parms_info, e, jf,\n+                                              ipa_get_type (callee_pi, i));\n \t  }\n \telse\n \t  gcc_assert (callee->thunk.thunk_p);\n@@ -534,7 +597,9 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n     }\n \n   evaluate_conditions_for_known_args (callee, inline_p,\n-\t\t\t\t      known_vals, known_aggs, clause_ptr,\n+\t\t\t\t      known_vals,\n+\t\t\t\t      known_value_ranges,\n+\t\t\t\t      known_aggs, clause_ptr,\n \t\t\t\t      nonspec_clause_ptr);\n \n   if (known_vals_ptr)\n@@ -657,6 +722,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       evaluate_conditions_for_known_args (dst, false,\n \t\t\t\t\t  known_vals,\n \t\t\t\t\t  vNULL,\n+\t\t\t\t\t  vNULL,\n \t\t\t\t\t  &possible_truths,\n \t\t\t\t\t  /* We are going to specialize,\n \t\t\t\t\t     so ignore nonspec truths.  */\n@@ -3358,8 +3424,9 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n {\n   clause_t clause, nonspec_clause;\n \n-  evaluate_conditions_for_known_args (node, false, known_vals, known_aggs,\n-\t\t\t\t      &clause, &nonspec_clause);\n+  /* TODO: Also pass known value ranges.  */\n+  evaluate_conditions_for_known_args (node, false, known_vals, vNULL,\n+\t\t\t\t      known_aggs, &clause, &nonspec_clause);\n   ipa_call_context ctx (node, clause, nonspec_clause,\n \t\t        known_vals, known_contexts,\n \t\t        known_aggs, vNULL);\n@@ -3579,7 +3646,8 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n   info->fp_expressions |= callee_info->fp_expressions;\n \n   if (callee_info->conds)\n-    evaluate_properties_for_edge (edge, true, &clause, NULL, NULL, NULL, NULL);\n+    evaluate_properties_for_edge (edge, true, &clause,\n+\t\t\t\t  NULL, NULL, NULL, NULL);\n   if (ipa_node_params_sum && callee_info->conds)\n     {\n       class ipa_edge_args *args = IPA_EDGE_REF (edge);"}, {"sha": "b5e009696b7769acdbfbe52eaa031a81dc9347aa", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=68718e8e60209edc98771f54091d983eecd6f93c", "patch": "@@ -1163,6 +1163,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \n       overall_growth = callee_info->growth;\n \n+#if 1\n       /* Look for inliner wrappers of the form:\n \n \t inline_caller ()\n@@ -1214,6 +1215,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t      overall_growth = caller_growth;\n \t    }\n \t}\n+#endif\n       if (overall_growth > 0)\n         {\n \t  /* Strongly preffer functions with few callers that can be inlined\n@@ -2132,12 +2134,23 @@ inline_small_functions (void)\n \t    fprintf (dump_file, \" Peeling recursion with depth %i\\n\", depth);\n \n \t  gcc_checking_assert (!callee->inlined_to);\n+\n+\t  int old_size = ipa_size_summaries->get (where)->size;\n+\t  sreal old_time = ipa_fn_summaries->get (where)->time;\n+\n \t  inline_call (edge, true, &new_indirect_edges, &overall_size, true);\n \t  add_new_edges_to_heap (&edge_heap, new_indirect_edges);\n \n \t  reset_edge_caches (edge->callee);\n \n-\t  update_callee_keys (&edge_heap, where, updated_nodes);\n+\t  /* If caller's size and time increased we do not need to update\n+\t     all edges becuase badness is not going to decrease.  */\n+\t  if (old_size <= ipa_size_summaries->get (where)->size\n+\t      && old_time <= ipa_fn_summaries->get (where)->time\n+\t      && 0)\n+\t    update_callee_keys (&edge_heap, edge->callee, updated_nodes);\n+\t  else\n+\t    update_callee_keys (&edge_heap, where, updated_nodes);\n \t}\n       where = edge->caller;\n       if (where->inlined_to)"}, {"sha": "9e85ef8aacea0c756d6ba5953772bdc9313b3216", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=68718e8e60209edc98771f54091d983eecd6f93c", "patch": "@@ -1029,6 +1029,8 @@ ipa_polymorphic_call_context ipa_context_from_jfunc (ipa_node_params *,\n \t\t\t\t\t\t     cgraph_edge *,\n \t\t\t\t\t\t     int,\n \t\t\t\t\t\t     ipa_jump_func *);\n+value_range ipa_value_range_from_jfunc (ipa_node_params *, cgraph_edge *,\n+\t\t\t\t\tipa_jump_func *, tree);\n ipa_agg_value_set ipa_agg_value_set_from_jfunc (ipa_node_params *,\n \t\t\t\t\t\tcgraph_node *,\n \t\t\t\t\t\tipa_agg_jump_function *);"}, {"sha": "e0535b32247126341ce321d51c7544a611e9c9d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=68718e8e60209edc98771f54091d983eecd6f93c", "patch": "@@ -1,3 +1,7 @@\n+2019-11-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/ipa/inline-9.c: New testcase.\n+\n 2019-11-14  Martin Liska  <mliska@suse.cz>\n \n \t* c-c++-common/asan/memcmp-1.c: Update expected backtrace."}, {"sha": "4bf751b5c384fa87190686a050824d665df5f519", "filename": "gcc/testsuite/gcc.dg/ipa/inline-9.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68718e8e60209edc98771f54091d983eecd6f93c/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-9.c?ref=68718e8e60209edc98771f54091d983eecd6f93c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-options \"-Os -fdump-ipa-inline\"  } */\n+int foo (void);\n+int test(int a)\n+{\n+ if (a>100)\n+   {\n+     foo();\n+     foo();\n+     foo();\n+     foo();\n+     foo();\n+     foo();\n+     foo();\n+     foo();\n+   }\n+}\n+int\n+main()\n+{\n+  for (int i=0;i<100;i++)\n+    test(i);\n+}\n+/* { dg-final { scan-tree-dump \"Inlined 1 calls\" \"inline\" } } */"}]}