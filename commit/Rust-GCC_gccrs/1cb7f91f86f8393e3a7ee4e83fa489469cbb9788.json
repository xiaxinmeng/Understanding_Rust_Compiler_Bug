{"sha": "1cb7f91f86f8393e3a7ee4e83fa489469cbb9788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNiN2Y5MWY4NmY4MzkzZTNhN2VlNGU4M2ZhNDg5NDY5Y2JiOTc4OA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-04-09T07:35:31Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-04-09T07:35:31Z"}, "message": "bitset_members.cc: New test.\n\n\n2002-04-09  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tlibstdc++/6124\n\t* testsuite/23_containers/bitset_members.cc: New test.\n\t* include/std/std_bitset.h (_Bit_count::_S_bit_count): Move..\n\t(_S_bit_count): Here.\n\t(_First_one::_S_first_one): Move...\n\t(_S_first_one): Here.\n\tFormat.\n\t* src/bitset.cc: Adjust.\n\t* config/linker-map.gnu: Export.\n\nFrom-SVN: r52066", "tree": {"sha": "e31871986f6d2c806ff937ca58c503168d08d9d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e31871986f6d2c806ff937ca58c503168d08d9d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788/comments", "author": null, "committer": null, "parents": [{"sha": "e70ed0d9a562f1c8f99e1a768938c0e36ae4e3c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e70ed0d9a562f1c8f99e1a768938c0e36ae4e3c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e70ed0d9a562f1c8f99e1a768938c0e36ae4e3c8"}], "stats": {"total": 1411, "additions": 762, "deletions": 649}, "files": [{"sha": "48e111125503041522420dd8728114df2bc4966a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1cb7f91f86f8393e3a7ee4e83fa489469cbb9788", "patch": "@@ -1,3 +1,15 @@\n+2002-04-09  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tlibstdc++/6124\n+\t* testsuite/23_containers/bitset_members.cc: New test.\n+\t* include/std/std_bitset.h (_Bit_count::_S_bit_count): Move..\n+\t(_S_bit_count): Here.\n+\t(_First_one::_S_first_one): Move...\n+\t(_S_first_one): Here.\n+\tFormat.\n+\t* src/bitset.cc: Adjust.\n+\t* config/linker-map.gnu: Export.\n+\t\n 2002-04-08  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tlibstdc++/5180"}, {"sha": "851ece555e0603a2595647cb1f71566408c1749a", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=1cb7f91f86f8393e3a7ee4e83fa489469cbb9788", "patch": "@@ -34,7 +34,9 @@ GLIBCPP_3.1 {\n       std::__basic_file*;\n       std::__num_base*;\n       std::__timepunct*;\n-      std::__numeric_limits_base*\n+      std::__numeric_limits_base*;\n+      std::_S_bit_count;\n+      std::_S_first_one\n     };\n \n     # Names not in an 'extern' block are mangled names."}, {"sha": "a8aa319ab9f467e1b6a1d24f7d341d7e31a03fbe", "filename": "libstdc++-v3/include/std/std_bitset.h", "status": "modified", "additions": 729, "deletions": 629, "changes": 1358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h?ref=1cb7f91f86f8393e3a7ee4e83fa489469cbb9788", "patch": "@@ -60,7 +60,6 @@\n // individual bits.  This allows us to specialize _Base_bitset for the\n // important special case where the bitset is only a single word.\n \n-\n #include <cstddef>     // for size_t\n #include <cstring>     // for memset\n #include <string>\n@@ -75,739 +74,840 @@\n \n namespace std\n {\n+  extern unsigned char \t_S_bit_count[256];\n+  extern unsigned char \t_S_first_one[256];\n+\n+  // Base class: general case.\n+  template<size_t _Nw>\n+    struct _Base_bitset \n+    {\n+      typedef unsigned long _WordT;\n+\n+      // 0 is the least significant word.\n+      _WordT \t\t_M_w[_Nw];                \n+      \n+      _Base_bitset() { _M_do_reset(); }\n+      _Base_bitset(unsigned long __val) \n+      {\n+\t_M_do_reset();\n+\t_M_w[0] = __val;\n+      }\n \n-// structure to aid in counting bits\n-template<bool __dummy> \n-struct _Bit_count {\n-  static unsigned char _S_bit_count[256];\n-};\n+      static size_t \n+      _S_whichword(size_t __pos )\n+      { return __pos / _GLIBCPP_BITSET_BITS_PER_WORD; }\n \n-// Mapping from 8 bit unsigned integers to the index of the first one\n-// bit:\n-template<bool __dummy> \n-struct _First_one {\n-  static unsigned char _S_first_one[256];\n-};\n+      static size_t \n+      _S_whichbyte(size_t __pos )\n+      { return (__pos % _GLIBCPP_BITSET_BITS_PER_WORD) / CHAR_BIT; }\n \n-//\n-// Base class: general case.\n-//\n+      static size_t \n+      _S_whichbit(size_t __pos )\n+      { return __pos % _GLIBCPP_BITSET_BITS_PER_WORD; }\n \n-template<size_t _Nw>\n-struct _Base_bitset {\n-  typedef unsigned long _WordT;\n+      static _WordT \n+      _S_maskbit(size_t __pos )\n+      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n \n-  _WordT _M_w[_Nw];                // 0 is the least significant word.\n+      _WordT& \n+      _M_getword(size_t __pos)       \n+      { return _M_w[_S_whichword(__pos)]; }\n \n-  _Base_bitset( void ) { _M_do_reset(); }\n-  _Base_bitset(unsigned long __val) {\n-    _M_do_reset();\n-    _M_w[0] = __val;\n-  }\n+      _WordT  \n+      _M_getword(size_t __pos) const \n+      { return _M_w[_S_whichword(__pos)]; }\n \n-  static size_t _S_whichword( size_t __pos )\n-    { return __pos / _GLIBCPP_BITSET_BITS_PER_WORD; }\n-  static size_t _S_whichbyte( size_t __pos )\n-    { return (__pos % _GLIBCPP_BITSET_BITS_PER_WORD) / CHAR_BIT; }\n-  static size_t _S_whichbit( size_t __pos )\n-    { return __pos % _GLIBCPP_BITSET_BITS_PER_WORD; }\n-  static _WordT _S_maskbit( size_t __pos )\n-    { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n+      _WordT& \n+      _M_hiword() { return _M_w[_Nw - 1]; }\n \n-  _WordT& _M_getword(size_t __pos)       { return _M_w[_S_whichword(__pos)]; }\n-  _WordT  _M_getword(size_t __pos) const { return _M_w[_S_whichword(__pos)]; }\n+      _WordT  \n+      _M_hiword() const { return _M_w[_Nw - 1]; }\n \n-  _WordT& _M_hiword()       { return _M_w[_Nw - 1]; }\n-  _WordT  _M_hiword() const { return _M_w[_Nw - 1]; }\n+      void \n+      _M_do_and(const _Base_bitset<_Nw>& __x) \n+      {\n+\tfor (size_t __i = 0; __i < _Nw; __i++) \n+\t  _M_w[__i] &= __x._M_w[__i];\n+      }\n \n-  void _M_do_and(const _Base_bitset<_Nw>& __x) {\n-    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n-      _M_w[__i] &= __x._M_w[__i];\n-    }\n-  }\n+      void \n+      _M_do_or(const _Base_bitset<_Nw>& __x) \n+      {\n+\tfor (size_t __i = 0; __i < _Nw; __i++) \n+\t  _M_w[__i] |= __x._M_w[__i];\n+      }\n \n-  void _M_do_or(const _Base_bitset<_Nw>& __x) {\n-    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n-      _M_w[__i] |= __x._M_w[__i];\n-    }\n-  }\n+      void \n+      _M_do_xor(const _Base_bitset<_Nw>& __x) \n+      {\n+\tfor (size_t __i = 0; __i < _Nw; __i++)\n+\t  _M_w[__i] ^= __x._M_w[__i];\n+      }\n \n-  void _M_do_xor(const _Base_bitset<_Nw>& __x) {\n-    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n-      _M_w[__i] ^= __x._M_w[__i];\n-    }\n-  }\n+      void \n+      _M_do_left_shift(size_t __shift);\n+\n+      void \n+      _M_do_right_shift(size_t __shift);\n+      \n+      void \n+      _M_do_flip() \n+      {\n+\tfor (size_t __i = 0; __i < _Nw; __i++) \n+\t  _M_w[__i] = ~_M_w[__i];\n+      }\n \n-  void _M_do_left_shift(size_t __shift);\n-  void _M_do_right_shift(size_t __shift);\n+      void \n+      _M_do_set() \n+      {\n+\tfor (size_t __i = 0; __i < _Nw; __i++)\n+\t  _M_w[__i] = ~static_cast<_WordT>(0);\n+      }\n \n-  void _M_do_flip() {\n-    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n-      _M_w[__i] = ~_M_w[__i];\n-    }\n-  }\n+      void \n+      _M_do_reset() { memset(_M_w, 0, _Nw * sizeof(_WordT)); }\n+\n+      bool \n+      _M_is_equal(const _Base_bitset<_Nw>& __x) const \n+      {\n+\tfor (size_t __i = 0; __i < _Nw; ++__i) \n+\t  {\n+\t    if (_M_w[__i] != __x._M_w[__i])\n+\t      return false;\n+\t  }\n+\treturn true;\n+      }\n \n-  void _M_do_set() {\n-    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n-      _M_w[__i] = ~static_cast<_WordT>(0);\n-    }\n-  }\n+      bool \n+      _M_is_any() const \n+      {\n+\tfor (size_t __i = 0; __i < _Nw; __i++) \n+\t  {\n+\t    if (_M_w[__i] != static_cast<_WordT>(0))\n+\t      return true;\n+\t  }\n+\treturn false;\n+      }\n \n-  void _M_do_reset() { memset(_M_w, 0, _Nw * sizeof(_WordT)); }\n+      size_t \n+      _M_do_count() const \n+      {\n+\tsize_t __result = 0;\n+\tconst unsigned char* __byte_ptr = (const unsigned char*)_M_w;\n+\tconst unsigned char* __end_ptr = (const unsigned char*)(_M_w + _Nw);\n+\t\n+\twhile ( __byte_ptr < __end_ptr ) \n+\t  {\n+\t    __result += _S_bit_count[*__byte_ptr];\n+\t    __byte_ptr++;\n+\t  }\n+\treturn __result;\n+      }\n \n-  bool _M_is_equal(const _Base_bitset<_Nw>& __x) const {\n-    for (size_t __i = 0; __i < _Nw; ++__i) {\n-      if (_M_w[__i] != __x._M_w[__i])\n-        return false;\n+      unsigned long \n+      _M_do_to_ulong() const; \n+\n+      // find first \"on\" bit\n+      size_t \n+      _M_do_find_first(size_t __not_found) const;\n+\n+      // find the next \"on\" bit that follows \"prev\"\n+      size_t \n+      _M_do_find_next(size_t __prev, size_t __not_found) const;\n+    };\n+\n+  // Definitions of non-inline functions from _Base_bitset.\n+  template<size_t _Nw>\n+    void \n+    _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) \n+    {\n+      if (__shift != 0) \n+\t{\n+\t  const size_t __wshift = __shift / _GLIBCPP_BITSET_BITS_PER_WORD;\n+\t  const size_t __offset = __shift % _GLIBCPP_BITSET_BITS_PER_WORD;\n+\t  \n+\t  if (__offset == 0)\n+\t    for (size_t __n = _Nw - 1; __n >= __wshift; --__n)\n+\t      _M_w[__n] = _M_w[__n - __wshift];\n+\t  else \n+\t    {\n+\t      const size_t __sub_offset = _GLIBCPP_BITSET_BITS_PER_WORD - __offset;\n+\t      for (size_t __n = _Nw - 1; __n > __wshift; --__n)\n+\t\t_M_w[__n] = (_M_w[__n - __wshift] << __offset) | \n+\t\t  (_M_w[__n - __wshift - 1] >> __sub_offset);\n+\t      _M_w[__wshift] = _M_w[0] << __offset;\n+\t    }\n+\t  \n+\t  fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));\n+\t}\n     }\n-    return true;\n-  }\n-\n-  bool _M_is_any() const {\n-    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n-      if ( _M_w[__i] != static_cast<_WordT>(0) )\n-        return true;\n+  \n+  template<size_t _Nw>\n+    void \n+    _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) \n+    {\n+      if (__shift != 0) \n+\t{\n+\t  const size_t __wshift = __shift / _GLIBCPP_BITSET_BITS_PER_WORD;\n+\t  const size_t __offset = __shift % _GLIBCPP_BITSET_BITS_PER_WORD;\n+\t  const size_t __limit = _Nw - __wshift - 1;\n+\t  \n+\t  if (__offset == 0)\n+\t    for (size_t __n = 0; __n <= __limit; ++__n)\n+\t      _M_w[__n] = _M_w[__n + __wshift];\n+\t  else \n+\t    {\n+\t      const size_t __sub_offset = _GLIBCPP_BITSET_BITS_PER_WORD - __offset;\n+\t      for (size_t __n = 0; __n < __limit; ++__n)\n+\t\t_M_w[__n] = (_M_w[__n + __wshift] >> __offset) |\n+\t\t  (_M_w[__n + __wshift + 1] << __sub_offset);\n+\t      _M_w[__limit] = _M_w[_Nw-1] >> __offset;\n+\t    }\n+\t  \n+\t  fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));\n+\t}\n     }\n-    return false;\n-  }\n \n-  size_t _M_do_count() const {\n-    size_t __result = 0;\n-    const unsigned char* __byte_ptr = (const unsigned char*)_M_w;\n-    const unsigned char* __end_ptr = (const unsigned char*)(_M_w+_Nw);\n-\n-    while ( __byte_ptr < __end_ptr ) {\n-      __result += _Bit_count<true>::_S_bit_count[*__byte_ptr];\n-      __byte_ptr++;\n+  template<size_t _Nw>\n+    unsigned long \n+    _Base_bitset<_Nw>::_M_do_to_ulong() const\n+    {\n+      for (size_t __i = 1; __i < _Nw; ++__i) \n+\tif (_M_w[__i]) \n+\t  __throw_overflow_error(\"bitset\");\n+      return _M_w[0];\n     }\n-    return __result;\n-  }\n-\n-  unsigned long _M_do_to_ulong() const; \n-\n-  // find first \"on\" bit\n-  size_t _M_do_find_first(size_t __not_found) const;\n-\n-  // find the next \"on\" bit that follows \"prev\"\n-  size_t _M_do_find_next(size_t __prev, size_t __not_found) const;\n-};\n \n-//\n-// Definitions of non-inline functions from _Base_bitset.\n-// \n-\n-template<size_t _Nw>\n-void _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) \n-{\n-  if (__shift != 0) {\n-    const size_t __wshift = __shift / _GLIBCPP_BITSET_BITS_PER_WORD;\n-    const size_t __offset = __shift % _GLIBCPP_BITSET_BITS_PER_WORD;\n-\n-    if (__offset == 0)\n-      for (size_t __n = _Nw - 1; __n >= __wshift; --__n)\n-        _M_w[__n] = _M_w[__n - __wshift];\n-\n-    else {\n-      const size_t __sub_offset = _GLIBCPP_BITSET_BITS_PER_WORD - __offset;\n-      for (size_t __n = _Nw - 1; __n > __wshift; --__n)\n-        _M_w[__n] = (_M_w[__n - __wshift] << __offset) | \n-                    (_M_w[__n - __wshift - 1] >> __sub_offset);\n-      _M_w[__wshift] = _M_w[0] << __offset;\n+  template<size_t _Nw>\n+    size_t \n+    _Base_bitset<_Nw>::_M_do_find_first(size_t __not_found) const \n+    {\n+      for (size_t __i = 0; __i < _Nw; __i++ ) \n+\t{\n+\t  _WordT __thisword = _M_w[__i];\n+\t  if ( __thisword != static_cast<_WordT>(0) ) \n+\t    {\n+\t      // find byte within word\n+\t      for (size_t __j = 0; __j < sizeof(_WordT); __j++ ) \n+\t\t{\n+\t\t  unsigned char __this_byte\n+\t\t    = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+\t\t  if (__this_byte)\n+\t\t    return __i*_GLIBCPP_BITSET_BITS_PER_WORD + __j*CHAR_BIT +\n+\t\t      _S_first_one[__this_byte];\n+\n+\t\t  __thisword >>= CHAR_BIT;\n+\t\t}\n+\t    }\n+\t}\n+      // not found, so return an indication of failure.\n+      return __not_found;\n     }\n \n-    fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));\n-  }\n-}\n+  template<size_t _Nw>\n+    size_t\n+    _Base_bitset<_Nw>::_M_do_find_next(size_t __prev, size_t __not_found) const\n+    { \n+      // make bound inclusive\n+      ++__prev;\n+      \n+      // check out of bounds\n+      if ( __prev >= _Nw * _GLIBCPP_BITSET_BITS_PER_WORD )\n+\treturn __not_found;\n+      \n+      // search first word\n+      size_t __i = _S_whichword(__prev);\n+      _WordT __thisword = _M_w[__i];\n+      \n+      // mask off bits below bound\n+      __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n+      \n+      if ( __thisword != static_cast<_WordT>(0) ) \n+\t{\n+\t  // find byte within word\n+\t  // get first byte into place\n+\t  __thisword >>= _S_whichbyte(__prev) * CHAR_BIT;\n+\t  for (size_t __j = _S_whichbyte(__prev); __j < sizeof(_WordT); __j++)\n+\t    {\n+\t      unsigned char __this_byte\n+\t\t= static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+\t      if ( __this_byte )\n+\t\treturn __i*_GLIBCPP_BITSET_BITS_PER_WORD + __j*CHAR_BIT +\n+\t\t  _S_first_one[__this_byte];\n+\t      \n+\t      __thisword >>= CHAR_BIT;\n+\t    }\n+\t}\n+      \n+      // check subsequent words\n+      __i++;\n+      for ( ; __i < _Nw; __i++ ) \n+\t{\n+\t  __thisword = _M_w[__i];\n+\t  if ( __thisword != static_cast<_WordT>(0) ) \n+\t    {\n+\t      // find byte within word\n+\t      for (size_t __j = 0; __j < sizeof(_WordT); __j++ ) \n+\t\t{\n+\t\t  unsigned char __this_byte\n+\t\t    = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+\t\t  if ( __this_byte )\n+\t\t    return __i*_GLIBCPP_BITSET_BITS_PER_WORD + __j*CHAR_BIT +\n+\t\t      _S_first_one[__this_byte];\n+\t\t  \n+\t\t  __thisword >>= CHAR_BIT;\n+\t\t}\n+\t    }\n+\t}\n+      // not found, so return an indication of failure.\n+      return __not_found;\n+    } // end _M_do_find_next\n+  \n \n-template<size_t _Nw>\n-void _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) \n-{\n-  if (__shift != 0) {\n-    const size_t __wshift = __shift / _GLIBCPP_BITSET_BITS_PER_WORD;\n-    const size_t __offset = __shift % _GLIBCPP_BITSET_BITS_PER_WORD;\n-    const size_t __limit = _Nw - __wshift - 1;\n-\n-    if (__offset == 0)\n-      for (size_t __n = 0; __n <= __limit; ++__n)\n-        _M_w[__n] = _M_w[__n + __wshift];\n-\n-    else {\n-      const size_t __sub_offset = _GLIBCPP_BITSET_BITS_PER_WORD - __offset;\n-      for (size_t __n = 0; __n < __limit; ++__n)\n-        _M_w[__n] = (_M_w[__n + __wshift] >> __offset) |\n-                    (_M_w[__n + __wshift + 1] << __sub_offset);\n-      _M_w[__limit] = _M_w[_Nw-1] >> __offset;\n-    }\n+  // Base class: specialization for a single word.\n+  template<> \n+    struct _Base_bitset<1> \n+    {\n+      typedef unsigned long _WordT;\n+      _WordT _M_w;\n \n-    fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));\n-  }\n-}\n+      _Base_bitset( void ) : _M_w(0) {}\n+      _Base_bitset(unsigned long __val) : _M_w(__val) {}\n \n-template<size_t _Nw>\n-unsigned long _Base_bitset<_Nw>::_M_do_to_ulong() const\n-{\n-  for (size_t __i = 1; __i < _Nw; ++__i) \n-    if (_M_w[__i]) \n-      __throw_overflow_error(\"bitset\");\n-  \n-  return _M_w[0];\n-}\n+      static size_t \n+      _S_whichword(size_t __pos )\n+      { return __pos / _GLIBCPP_BITSET_BITS_PER_WORD; }\n \n-template<size_t _Nw>\n-size_t _Base_bitset<_Nw>::_M_do_find_first(size_t __not_found) const \n-{\n-  for ( size_t __i = 0; __i < _Nw; __i++ ) {\n-    _WordT __thisword = _M_w[__i];\n-    if ( __thisword != static_cast<_WordT>(0) ) {\n-      // find byte within word\n-      for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {\n-        unsigned char __this_byte\n-          = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n-        if ( __this_byte )\n-          return __i*_GLIBCPP_BITSET_BITS_PER_WORD + __j*CHAR_BIT +\n-            _First_one<true>::_S_first_one[__this_byte];\n-\n-        __thisword >>= CHAR_BIT;\n-      }\n-    }\n-  }\n-  // not found, so return an indication of failure.\n-  return __not_found;\n-}\n-\n-template<size_t _Nw>\n-size_t\n-_Base_bitset<_Nw>::_M_do_find_next(size_t __prev, size_t __not_found) const\n-{\n-  // make bound inclusive\n-  ++__prev;\n-\n-  // check out of bounds\n-  if ( __prev >= _Nw * _GLIBCPP_BITSET_BITS_PER_WORD )\n-    return __not_found;\n-\n-    // search first word\n-  size_t __i = _S_whichword(__prev);\n-  _WordT __thisword = _M_w[__i];\n-\n-    // mask off bits below bound\n-  __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n-\n-  if ( __thisword != static_cast<_WordT>(0) ) {\n-    // find byte within word\n-    // get first byte into place\n-    __thisword >>= _S_whichbyte(__prev) * CHAR_BIT;\n-    for ( size_t __j = _S_whichbyte(__prev); __j < sizeof(_WordT); __j++ ) {\n-      unsigned char __this_byte\n-        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n-      if ( __this_byte )\n-        return __i*_GLIBCPP_BITSET_BITS_PER_WORD + __j*CHAR_BIT +\n-          _First_one<true>::_S_first_one[__this_byte];\n-\n-      __thisword >>= CHAR_BIT;\n-    }\n-  }\n-\n-  // check subsequent words\n-  __i++;\n-  for ( ; __i < _Nw; __i++ ) {\n-    __thisword = _M_w[__i];\n-    if ( __thisword != static_cast<_WordT>(0) ) {\n-      // find byte within word\n-      for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {\n-        unsigned char __this_byte\n-          = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n-        if ( __this_byte )\n-          return __i*_GLIBCPP_BITSET_BITS_PER_WORD + __j*CHAR_BIT +\n-            _First_one<true>::_S_first_one[__this_byte];\n-\n-        __thisword >>= CHAR_BIT;\n-      }\n-    }\n-  }\n+      static size_t \n+      _S_whichbyte(size_t __pos )\n+      { return (__pos % _GLIBCPP_BITSET_BITS_PER_WORD) / CHAR_BIT; }\n \n-  // not found, so return an indication of failure.\n-  return __not_found;\n-} // end _M_do_find_next\n+      static size_t \n+      _S_whichbit(size_t __pos )\n+      {  return __pos % _GLIBCPP_BITSET_BITS_PER_WORD; }\n \n+      static _WordT \n+      _S_maskbit(size_t __pos )\n+      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n \n-// ------------------------------------------------------------\n+      _WordT& \n+      _M_getword(size_t) { return _M_w; }\n \n-//\n-// Base class: specialization for a single word.\n-//\n+      _WordT  \n+      _M_getword(size_t) const { return _M_w; }\n \n-template<> struct _Base_bitset<1> {\n-  typedef unsigned long _WordT;\n-  _WordT _M_w;\n-\n-  _Base_bitset( void ) : _M_w(0) {}\n-  _Base_bitset(unsigned long __val) : _M_w(__val) {}\n-\n-  static size_t _S_whichword( size_t __pos )\n-    { return __pos / _GLIBCPP_BITSET_BITS_PER_WORD; }\n-  static size_t _S_whichbyte( size_t __pos )\n-    { return (__pos % _GLIBCPP_BITSET_BITS_PER_WORD) / CHAR_BIT; }\n-  static size_t _S_whichbit( size_t __pos )\n-    {  return __pos % _GLIBCPP_BITSET_BITS_PER_WORD; }\n-  static _WordT _S_maskbit( size_t __pos )\n-    { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n-\n-  _WordT& _M_getword(size_t)       { return _M_w; }\n-  _WordT  _M_getword(size_t) const { return _M_w; }\n-\n-  _WordT& _M_hiword()       { return _M_w; }\n-  _WordT  _M_hiword() const { return _M_w; }\n-\n-  void _M_do_and(const _Base_bitset<1>& __x) { _M_w &= __x._M_w; }\n-  void _M_do_or(const _Base_bitset<1>& __x)  { _M_w |= __x._M_w; }\n-  void _M_do_xor(const _Base_bitset<1>& __x) { _M_w ^= __x._M_w; }\n-  void _M_do_left_shift(size_t __shift)     { _M_w <<= __shift; }\n-  void _M_do_right_shift(size_t __shift)    { _M_w >>= __shift; }\n-  void _M_do_flip()                       { _M_w = ~_M_w; }\n-  void _M_do_set()                        { _M_w = ~static_cast<_WordT>(0); }\n-  void _M_do_reset()                      { _M_w = 0; }\n-\n-  bool _M_is_equal(const _Base_bitset<1>& __x) const\n-    { return _M_w == __x._M_w; }\n-  bool _M_is_any() const\n-    { return _M_w != 0; }\n-\n-  size_t _M_do_count() const {\n-    size_t __result = 0;\n-    const unsigned char* __byte_ptr = (const unsigned char*)&_M_w;\n-    const unsigned char* __end_ptr\n-      = ((const unsigned char*)&_M_w)+sizeof(_M_w);\n-    while ( __byte_ptr < __end_ptr ) {\n-      __result += _Bit_count<true>::_S_bit_count[*__byte_ptr];\n-      __byte_ptr++;\n-    }\n-    return __result;\n-  }\n+      _WordT& \n+      _M_hiword() { return _M_w; }\n \n-  unsigned long _M_do_to_ulong() const { return _M_w; }\n+      _WordT  \n+      _M_hiword() const { return _M_w; }\n \n-  size_t _M_do_find_first(size_t __not_found) const;\n+      void \n+      _M_do_and(const _Base_bitset<1>& __x) { _M_w &= __x._M_w; }\n \n-  // find the next \"on\" bit that follows \"prev\"\n-  size_t _M_do_find_next(size_t __prev, size_t __not_found) const; \n+      void \n+      _M_do_or(const _Base_bitset<1>& __x)  { _M_w |= __x._M_w; }\n \n-};\n+      void \n+      _M_do_xor(const _Base_bitset<1>& __x) { _M_w ^= __x._M_w; }\n \n+      void \n+      _M_do_left_shift(size_t __shift) { _M_w <<= __shift; }\n \n-// ------------------------------------------------------------\n-// Helper class to zero out the unused high-order bits in the highest word.\n+      void \n+      _M_do_right_shift(size_t __shift) { _M_w >>= __shift; }\n \n-template <size_t _Extrabits> struct _Sanitize {\n-  static void _M_do_sanitize(unsigned long& __val)\n-    { __val &= ~((~static_cast<unsigned long>(0)) << _Extrabits); }\n-};\n+      void \n+      _M_do_flip() { _M_w = ~_M_w; }\n \n-template<> struct _Sanitize<0> {\n-  static void _M_do_sanitize(unsigned long) {}\n-};\n+      void \n+      _M_do_set() { _M_w = ~static_cast<_WordT>(0); }\n \n+      void \n+      _M_do_reset() { _M_w = 0; }\n \n+      bool \n+      _M_is_equal(const _Base_bitset<1>& __x) const\n+      { return _M_w == __x._M_w; }\n \n-// ------------------------------------------------------------\n-// Class bitset.\n-//   _Nb may be any nonzero number of type size_t.\n+      bool \n+      _M_is_any() const { return _M_w != 0; }\n \n-template<size_t _Nb>\n-class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n-{\n-private:\n-  typedef _Base_bitset<__BITSET_WORDS(_Nb)> _Base;\n-  typedef unsigned long _WordT;\n+      size_t \n+      _M_do_count() const \n+      {\n+\tsize_t __result = 0;\n+\tconst unsigned char* __byte_ptr = (const unsigned char*)&_M_w;\n+\tconst unsigned char* __end_ptr\n+\t  = ((const unsigned char*)&_M_w)+sizeof(_M_w);\n+\twhile ( __byte_ptr < __end_ptr ) \n+\t  {\n+\t    __result += _S_bit_count[*__byte_ptr];\n+\t    __byte_ptr++;\n+\t  }\n+\treturn __result;\n+      }\n \n-private:\n-  void _M_do_sanitize() {\n-    _Sanitize<_Nb%_GLIBCPP_BITSET_BITS_PER_WORD>::_M_do_sanitize(this->_M_hiword());\n-  }\n+      unsigned long \n+      _M_do_to_ulong() const { return _M_w; }\n+\n+      size_t \n+      _M_do_find_first(size_t __not_found) const;\n+\n+      // find the next \"on\" bit that follows \"prev\"\n+      size_t\n+      _M_do_find_next(size_t __prev, size_t __not_found) const; \n+    };\n+\n+  // Helper class to zero out the unused high-order bits in the highest word.\n+  template<size_t _Extrabits> \n+    struct _Sanitize \n+    {\n+      static void _S_do_sanitize(unsigned long& __val)\n+      { __val &= ~((~static_cast<unsigned long>(0)) << _Extrabits); }\n+    };\n+\n+  template<> \n+    struct _Sanitize<0> \n+    { static void _S_do_sanitize(unsigned long) { } };\n+\n+  // Class bitset.\n+  // _Nb may be any nonzero number of type size_t.\n+  template<size_t _Nb>\n+    class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n+  {\n+  private:\n+    typedef _Base_bitset<__BITSET_WORDS(_Nb)> _Base;\n+    typedef unsigned long _WordT;\n+    \n+    void \n+    _M_do_sanitize() \n+    {\n+    _Sanitize<_Nb%_GLIBCPP_BITSET_BITS_PER_WORD>::_S_do_sanitize(this->_M_hiword());\n+    }\n \n-public:\n+  public:\n+    // bit reference:\n+    class reference;\n+    friend class reference;\n+    \n+    class reference \n+    {\n+      friend class bitset;\n+      \n+      _WordT *_M_wp;\n+      size_t _M_bpos;\n+      \n+      // left undefined\n+      reference();\n+      \n+    public:\n+      reference( bitset& __b, size_t __pos ) \n+      {\n+\t_M_wp = &__b._M_getword(__pos);\n+\t_M_bpos = _Base::_S_whichbit(__pos);\n+      }\n \n-  // bit reference:\n-  class reference;\n-  friend class reference;\n+      ~reference() { }\n+\n+      // for b[i] = __x;\n+      reference& \n+      operator=(bool __x) \n+      {\n+\tif ( __x )\n+\t  *_M_wp |= _Base::_S_maskbit(_M_bpos);\n+\telse\n+\t  *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n+\treturn *this;\n+      }\n+      \n+      // for b[i] = b[__j];\n+      reference& \n+      operator=(const reference& __j) \n+      {\n+\tif ( (*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)) )\n+\t  *_M_wp |= _Base::_S_maskbit(_M_bpos);\n+\telse\n+\t  *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n+\treturn *this;\n+      }\n \n-  class reference {\n-    friend class bitset;\n+      // flips the bit\n+      bool \n+      operator~() const\n+      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }\n \n-    _WordT *_M_wp;\n-    size_t _M_bpos;\n+      // for __x = b[i];\n+      operator bool() const\n+      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }\n \n-    // left undefined\n-    reference();\n+      // for b[i].flip();\n+      reference& \n+      flip() \n+      {\n+\t*_M_wp ^= _Base::_S_maskbit(_M_bpos);\n+\treturn *this;\n+      }\n+    };\n+    \n+    // 23.3.5.1 constructors:\n+    bitset() { }\n \n-  public:\n-    reference( bitset& __b, size_t __pos ) {\n-      _M_wp = &__b._M_getword(__pos);\n-      _M_bpos = _Base::_S_whichbit(__pos);\n-    }\n+    bitset(unsigned long __val) : _Base_bitset<__BITSET_WORDS(_Nb)>(__val) \n+    { _M_do_sanitize(); }\n \n-    ~reference() {}\n+    template<class _CharT, class _Traits, class _Alloc>\n+      explicit bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n+\t\t      size_t __pos = 0) : _Base() \n+      {\n+\tif (__pos > __s.size()) \n+\t  __throw_out_of_range(\"bitset\");\n+\t_M_copy_from_string(__s, __pos,\n+\t\t\t    basic_string<_CharT, _Traits, _Alloc>::npos);\n+      }\n \n-    // for b[i] = __x;\n-    reference& operator=(bool __x) {\n-      if ( __x )\n-        *_M_wp |= _Base::_S_maskbit(_M_bpos);\n-      else\n-        *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n+    template<class _CharT, class _Traits, class _Alloc>\n+      bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n+\t     size_t __pos, size_t __n) : _Base() \n+      {\n+\tif (__pos > __s.size()) \n+\t  __throw_out_of_range(\"bitset\");\n+\t_M_copy_from_string(__s, __pos, __n);\n+      }\n \n+    // 23.3.5.2 bitset operations:\n+    bitset<_Nb>& \n+    operator&=(const bitset<_Nb>& __rhs) \n+    {\n+      this->_M_do_and(__rhs);\n       return *this;\n     }\n \n-    // for b[i] = b[__j];\n-    reference& operator=(const reference& __j) {\n-      if ( (*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)) )\n-        *_M_wp |= _Base::_S_maskbit(_M_bpos);\n-      else\n-        *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n-\n+    bitset<_Nb>& \n+    operator|=(const bitset<_Nb>& __rhs) \n+    {\n+      this->_M_do_or(__rhs);\n       return *this;\n     }\n \n-    // flips the bit\n-    bool operator~() const\n-      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }\n-\n-    // for __x = b[i];\n-    operator bool() const\n-      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }\n+    bitset<_Nb>& \n+    operator^=(const bitset<_Nb>& __rhs) \n+    {\n+      this->_M_do_xor(__rhs);\n+      return *this;\n+    }\n \n-    // for b[i].flip();\n-    reference& flip() {\n-      *_M_wp ^= _Base::_S_maskbit(_M_bpos);\n+    bitset<_Nb>& \n+    operator<<=(size_t __pos) \n+    {\n+      this->_M_do_left_shift(__pos);\n+      this->_M_do_sanitize();\n       return *this;\n     }\n-  };\n \n-  // 23.3.5.1 constructors:\n-  bitset() {}\n-  bitset(unsigned long __val) : _Base_bitset<__BITSET_WORDS(_Nb)>(__val) \n-    { _M_do_sanitize(); }\n+    bitset<_Nb>& \n+    operator>>=(size_t __pos) \n+    {\n+      this->_M_do_right_shift(__pos);\n+      this->_M_do_sanitize();\n+      return *this;\n+    }\n \n-  template<class _CharT, class _Traits, class _Alloc>\n-  explicit bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n-                  size_t __pos = 0)\n-    : _Base() \n-  {\n-    if (__pos > __s.size()) \n-      __throw_out_of_range(\"bitset\");\n-    _M_copy_from_string(__s, __pos,\n-                        basic_string<_CharT, _Traits, _Alloc>::npos);\n-  }\n-  template<class _CharT, class _Traits, class _Alloc>\n-  bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n-         size_t __pos,\n-         size_t __n)\n-    : _Base() \n-  {\n-    if (__pos > __s.size()) \n-      __throw_out_of_range(\"bitset\");\n-    _M_copy_from_string(__s, __pos, __n);\n-  }\n-\n-  // 23.3.5.2 bitset operations:\n-  bitset<_Nb>& operator&=(const bitset<_Nb>& __rhs) {\n-    this->_M_do_and(__rhs);\n-    return *this;\n-  }\n-\n-  bitset<_Nb>& operator|=(const bitset<_Nb>& __rhs) {\n-    this->_M_do_or(__rhs);\n-    return *this;\n-  }\n-\n-  bitset<_Nb>& operator^=(const bitset<_Nb>& __rhs) {\n-    this->_M_do_xor(__rhs);\n-    return *this;\n-  }\n-\n-  bitset<_Nb>& operator<<=(size_t __pos) {\n-    this->_M_do_left_shift(__pos);\n-    this->_M_do_sanitize();\n-    return *this;\n-  }\n-\n-  bitset<_Nb>& operator>>=(size_t __pos) {\n-    this->_M_do_right_shift(__pos);\n-    this->_M_do_sanitize();\n-    return *this;\n-  }\n-\n-  //\n-  // Extension:\n-  // Versions of single-bit set, reset, flip, test with no range checking.\n-  //\n-\n-  bitset<_Nb>& _Unchecked_set(size_t __pos) {\n-    this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n-    return *this;\n-  }\n-\n-  bitset<_Nb>& _Unchecked_set(size_t __pos, int __val) {\n-    if (__val)\n+    // Extension:\n+    // Versions of single-bit set, reset, flip, test with no range checking.\n+    bitset<_Nb>& \n+    _Unchecked_set(size_t __pos) \n+    {\n       this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n-    else\n-      this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n-\n-    return *this;\n-  }\n-\n-  bitset<_Nb>& _Unchecked_reset(size_t __pos) {\n-    this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n-    return *this;\n-  }\n-\n-  bitset<_Nb>& _Unchecked_flip(size_t __pos) {\n-    this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);\n-    return *this;\n-  }\n+      return *this;\n+    }\n \n-  bool _Unchecked_test(size_t __pos) const {\n-    return (this->_M_getword(__pos) & _Base::_S_maskbit(__pos))\n-      != static_cast<_WordT>(0);\n-  }\n+    bitset<_Nb>& \n+    _Unchecked_set(size_t __pos, int __val) \n+    {\n+      if (__val)\n+\tthis->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n+      else\n+\tthis->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n+      return *this;\n+    }\n \n-  // Set, reset, and flip.\n+    bitset<_Nb>& \n+    _Unchecked_reset(size_t __pos) \n+    {\n+      this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n+      return *this;\n+    }\n \n-  bitset<_Nb>& set() {\n-    this->_M_do_set();\n-    this->_M_do_sanitize();\n-    return *this;\n-  }\n+    bitset<_Nb>& \n+    _Unchecked_flip(size_t __pos) \n+    {\n+      this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);\n+      return *this;\n+    }\n \n-  bitset<_Nb>& set(size_t __pos, bool __val = true) {\n-    if (__pos >= _Nb)\n-      __throw_out_of_range(\"bitset\");\n+    bool \n+    _Unchecked_test(size_t __pos) const \n+    {\n+      return (this->_M_getword(__pos) & _Base::_S_maskbit(__pos)) \n+\t!= static_cast<_WordT>(0);\n+    }\n \n-    return _Unchecked_set(__pos, __val);\n-  }\n+    // Set, reset, and flip.\n+    bitset<_Nb>& \n+    set() \n+    {\n+      this->_M_do_set();\n+      this->_M_do_sanitize();\n+      return *this;\n+    }\n \n-  bitset<_Nb>& reset() {\n-    this->_M_do_reset();\n-    return *this;\n-  }\n+    bitset<_Nb>& \n+    set(size_t __pos, bool __val = true) \n+    {\n+      if (__pos >= _Nb)\n+\t__throw_out_of_range(\"bitset\");\n+      return _Unchecked_set(__pos, __val);\n+    }\n \n-  bitset<_Nb>& reset(size_t __pos) {\n-    if (__pos >= _Nb)\n-      __throw_out_of_range(\"bitset\");\n+    bitset<_Nb>& \n+    reset() \n+    {\n+      this->_M_do_reset();\n+      return *this;\n+    }\n \n-    return _Unchecked_reset(__pos);\n-  }\n+    bitset<_Nb>& \n+    reset(size_t __pos) \n+    {\n+      if (__pos >= _Nb)\n+\t__throw_out_of_range(\"bitset\");\n+      return _Unchecked_reset(__pos);\n+    }\n \n-  bitset<_Nb>& flip() {\n-    this->_M_do_flip();\n-    this->_M_do_sanitize();\n-    return *this;\n-  }\n+    bitset<_Nb>& \n+    flip() \n+    {\n+      this->_M_do_flip();\n+      this->_M_do_sanitize();\n+      return *this;\n+    }\n \n-  bitset<_Nb>& flip(size_t __pos) {\n-    if (__pos >= _Nb)\n-      __throw_out_of_range(\"bitset\");\n+    bitset<_Nb>& \n+    flip(size_t __pos) \n+    {\n+      if (__pos >= _Nb)\n+\t__throw_out_of_range(\"bitset\");\n+      return _Unchecked_flip(__pos);\n+    }\n \n-    return _Unchecked_flip(__pos);\n-  }\n+    bitset<_Nb> \n+    operator~() const { return bitset<_Nb>(*this).flip(); }\n+\n+    // element access:\n+    //for b[i];\n+    // _GLIBCPP_RESOLVE_LIB_DEFECTS Note that this implementation already\n+    // resolves DR 11 (items 1 and 2), but does not do the range-checking\n+    // required by that DR's resolution.  -pme\n+    reference \n+    operator[](size_t __pos) { return reference(*this,__pos); }\n+\n+    bool \n+    operator[](size_t __pos) const { return _Unchecked_test(__pos); }\n+\n+    unsigned long \n+    to_ulong() const { return this->_M_do_to_ulong(); }\n+\n+    template<class _CharT, class _Traits, class _Alloc>\n+      basic_string<_CharT, _Traits, _Alloc> \n+      to_string() const \n+      {\n+\tbasic_string<_CharT, _Traits, _Alloc> __result;\n+\t_M_copy_to_string(__result);\n+\treturn __result;\n+      }\n \n-  bitset<_Nb> operator~() const { \n-    return bitset<_Nb>(*this).flip();\n-  }\n+    // Helper functions for string operations.\n+    template<class _CharT, class _Traits, class _Alloc>\n+      void \n+      _M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n+                          size_t, size_t);\n \n-  // element access:\n-  //for b[i];\n-  // _GLIBCPP_RESOLVE_LIB_DEFECTS Note that this implementation already\n-  // resolves DR 11 (items 1 and 2), but does not do the range-checking\n-  // required by that DR's resolution.  -pme\n-  reference operator[](size_t __pos) { return reference(*this,__pos); }\n-  bool operator[](size_t __pos) const { return _Unchecked_test(__pos); }\n+    template<class _CharT, class _Traits, class _Alloc>\n+      void \n+      _M_copy_to_string(basic_string<_CharT,_Traits,_Alloc>&) const;\n \n-  unsigned long to_ulong() const { return this->_M_do_to_ulong(); }\n+    size_t \n+    count() const { return this->_M_do_count(); }\n \n-  template <class _CharT, class _Traits, class _Alloc>\n-  basic_string<_CharT, _Traits, _Alloc> to_string() const {\n-    basic_string<_CharT, _Traits, _Alloc> __result;\n-    _M_copy_to_string(__result);\n-    return __result;\n-  }\n+    size_t \n+    size() const { return _Nb; }\n \n-  // Helper functions for string operations.\n-  template<class _CharT, class _Traits, class _Alloc>\n-  void _M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n-                          size_t,\n-                          size_t);\n+    bool \n+    operator==(const bitset<_Nb>& __rhs) const \n+    { return this->_M_is_equal(__rhs); }\n \n-  template<class _CharT, class _Traits, class _Alloc>\n-  void _M_copy_to_string(basic_string<_CharT,_Traits,_Alloc>&) const;\n+    bool \n+    operator!=(const bitset<_Nb>& __rhs) const \n+    { return !this->_M_is_equal(__rhs); }\n \n-  size_t count() const { return this->_M_do_count(); }\n+    bool \n+    test(size_t __pos) const \n+    {\n+      if (__pos >= _Nb)\n+\t__throw_out_of_range(\"bitset\");\n+      return _Unchecked_test(__pos);\n+    }\n \n-  size_t size() const { return _Nb; }\n+    bool \n+    any() const { return this->_M_is_any(); }\n \n-  bool operator==(const bitset<_Nb>& __rhs) const {\n-    return this->_M_is_equal(__rhs);\n-  }\n-  bool operator!=(const bitset<_Nb>& __rhs) const {\n-    return !this->_M_is_equal(__rhs);\n-  }\n+    bool \n+    none() const { return !this->_M_is_any(); }\n \n-  bool test(size_t __pos) const {\n-    if (__pos >= _Nb)\n-      __throw_out_of_range(\"bitset\");\n-\n-    return _Unchecked_test(__pos);\n-  }\n-\n-  bool any() const { return this->_M_is_any(); }\n-  bool none() const { return !this->_M_is_any(); }\n-\n-  bitset<_Nb> operator<<(size_t __pos) const\n+    bitset<_Nb> \n+    operator<<(size_t __pos) const\n     { return bitset<_Nb>(*this) <<= __pos; }\n-  bitset<_Nb> operator>>(size_t __pos) const\n+\n+    bitset<_Nb> \n+    operator>>(size_t __pos) const\n     { return bitset<_Nb>(*this) >>= __pos; }\n \n-  //\n-  // EXTENSIONS: bit-find operations.  These operations are\n-  // experimental, and are subject to change or removal in future\n-  // versions.\n-  // \n+    // EXTENSIONS: bit-find operations.  These operations are\n+    // experimental, and are subject to change or removal in future\n+    // versions.\n \n-  // find the index of the first \"on\" bit\n-  size_t _Find_first() const \n+    // find the index of the first \"on\" bit\n+    size_t \n+    _Find_first() const \n     { return this->_M_do_find_first(_Nb); }\n \n-  // find the index of the next \"on\" bit after prev\n-  size_t _Find_next( size_t __prev ) const \n+    // find the index of the next \"on\" bit after prev\n+    size_t \n+    _Find_next(size_t __prev ) const \n     { return this->_M_do_find_next(__prev, _Nb); }\n+  };\n \n-};\n-\n-//\n-// Definitions of non-inline member functions.\n-//\n-\n-template <size_t _Nb>\n-template<class _CharT, class _Traits, class _Alloc>\n-void bitset<_Nb>\n-  ::_M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n-                        size_t __pos,\n-                        size_t __n)\n-{\n-  reset();\n-  const size_t __nbits = min(_Nb, min(__n, __s.size() - __pos));\n-  for (size_t __i = 0; __i < __nbits; ++__i) {\n-    switch(__s[__pos + __nbits - __i - 1]) {\n-    case '0':\n-      break;\n-    case '1':\n-      set(__i);\n-      break;\n-    default:\n-      __throw_invalid_argument(\"bitset\");\n+  // Definitions of non-inline member functions.\n+  template<size_t _Nb>\n+    template<class _CharT, class _Traits, class _Alloc>\n+    void \n+    bitset<_Nb>::_M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s, size_t __pos, size_t __n)\n+    {  \n+      reset();\n+      const size_t __nbits = min(_Nb, min(__n, __s.size() - __pos));\n+      for (size_t __i = 0; __i < __nbits; ++__i) \n+\t{\n+\t  switch(__s[__pos + __nbits - __i - 1]) \n+\t    {\n+\t    case '0':\n+\t      break;\n+\t    case '1':\n+\t      set(__i);\n+\t      break;\n+\t    default:\n+\t      __throw_invalid_argument(\"bitset\");\n+\t    }\n+\t}\n     }\n-  }\n-}\n-\n-template <size_t _Nb>\n-template <class _CharT, class _Traits, class _Alloc>\n-void bitset<_Nb>\n-  ::_M_copy_to_string(basic_string<_CharT, _Traits, _Alloc>& __s) const\n-{\n-  __s.assign(_Nb, '0');\n-  \n-  for (size_t __i = 0; __i < _Nb; ++__i) \n-    if (_Unchecked_test(__i))\n-      __s[_Nb - 1 - __i] = '1';\n-}\n \n-// ------------------------------------------------------------\n-\n-//\n-// 23.3.5.3 bitset operations:\n-//\n+  template<size_t _Nb>\n+    template<class _CharT, class _Traits, class _Alloc>\n+    void \n+    bitset<_Nb>::_M_copy_to_string(basic_string<_CharT, _Traits, _Alloc>& __s) const\n+    {\n+      __s.assign(_Nb, '0');\n+      for (size_t __i = 0; __i < _Nb; ++__i) \n+\tif (_Unchecked_test(__i))\n+\t  __s[_Nb - 1 - __i] = '1';\n+    }\n \n-template <size_t _Nb>\n-inline bitset<_Nb> operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {\n-  bitset<_Nb> __result(__x);\n-  __result &= __y;\n-  return __result;\n-}\n-\n-\n-template <size_t _Nb>\n-inline bitset<_Nb> operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {\n-  bitset<_Nb> __result(__x);\n-  __result |= __y;\n-  return __result;\n-}\n-\n-template <size_t _Nb>\n-inline bitset<_Nb> operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {\n-  bitset<_Nb> __result(__x);\n-  __result ^= __y;\n-  return __result;\n-}\n-\n-template <class _CharT, class _Traits, size_t _Nb>\n-basic_istream<_CharT, _Traits>&\n-operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)\n-{\n-  typedef typename _Traits::char_type char_type;\n-  basic_string<_CharT, _Traits> __tmp;\n-  __tmp.reserve(_Nb);\n-\n-  // Skip whitespace\n-  typename basic_istream<_CharT, _Traits>::sentry __sentry(__is);\n-  if (__sentry) {\n-    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();\n-    for (size_t __i = 0; __i < _Nb; ++__i) {\n-      static typename _Traits::int_type __eof = _Traits::eof();\n-\n-      typename _Traits::int_type __c1 = __buf->sbumpc();\n-      if (_Traits::eq_int_type(__c1, __eof)) {\n-        __is.setstate(ios_base::eofbit);\n-        break;\n-      }\n-      else {\n-        char_type __c2 = _Traits::to_char_type(__c1);\n-        char_type __c  = __is.narrow(__c2, '*');\n-\n-        if (__c == '0' || __c == '1')\n-          __tmp.push_back(__c);\n-        else if (_Traits::eq_int_type(__buf->sputbackc(__c2), __eof)) {\n-          __is.setstate(ios_base::failbit);\n-          break;\n-        }\n-      }\n+  // 23.3.5.3 bitset operations:\n+  template<size_t _Nb>\n+    inline bitset<_Nb> \n+    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) \n+    {\n+      bitset<_Nb> __result(__x);\n+      __result &= __y;\n+      return __result;\n     }\n \n-    if (__tmp.empty())\n-      __is.setstate(ios_base::failbit);\n-    else\n-      __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);\n-  }\n+  template<size_t _Nb>\n+    inline bitset<_Nb> \n+    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) \n+    {\n+      bitset<_Nb> __result(__x);\n+      __result |= __y;\n+      return __result;\n+    }\n \n-  return __is;\n-}\n+  template <size_t _Nb>\n+    inline bitset<_Nb> \n+    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) \n+    {\n+      bitset<_Nb> __result(__x);\n+      __result ^= __y;\n+      return __result;\n+    }\n \n-template <class _CharT, class _Traits, size_t _Nb>\n-basic_ostream<_CharT, _Traits>&\n-operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Nb>& __x)\n-{\n-  basic_string<_CharT, _Traits> __tmp;\n-  __x._M_copy_to_string(__tmp);\n-  return __os << __tmp;\n-}\n+  template<class _CharT, class _Traits, size_t _Nb>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)\n+    {\n+      typedef typename _Traits::char_type char_type;\n+      basic_string<_CharT, _Traits> __tmp;\n+      __tmp.reserve(_Nb);\n+      \n+      // Skip whitespace\n+      typename basic_istream<_CharT, _Traits>::sentry __sentry(__is);\n+      if (__sentry) \n+\t{\n+\t  basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();\n+\t  for (size_t __i = 0; __i < _Nb; ++__i) \n+\t    {\n+\t      static typename _Traits::int_type __eof = _Traits::eof();\n+\t      \n+\t      typename _Traits::int_type __c1 = __buf->sbumpc();\n+\t      if (_Traits::eq_int_type(__c1, __eof)) \n+\t\t{\n+\t\t  __is.setstate(ios_base::eofbit);\n+\t\t  break;\n+\t\t}\n+\t      else \n+\t\t{\n+\t\t  char_type __c2 = _Traits::to_char_type(__c1);\n+\t\t  char_type __c  = __is.narrow(__c2, '*');\n+\t\t  \n+\t\t  if (__c == '0' || __c == '1')\n+\t\t    __tmp.push_back(__c);\n+\t\t  else if (_Traits::eq_int_type(__buf->sputbackc(__c2), \n+\t\t\t\t\t\t__eof)) \n+\t\t    {\n+\t\t      __is.setstate(ios_base::failbit);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  \n+\t  if (__tmp.empty())\n+\t    __is.setstate(ios_base::failbit);\n+\t  else\n+\t    __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);\n+\t}\n+\n+      return __is;\n+    }\n \n+  template <class _CharT, class _Traits, size_t _Nb>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Nb>& __x)\n+    {\n+      basic_string<_CharT, _Traits> __tmp;\n+      __x._M_copy_to_string(__tmp);\n+      return __os << __tmp;\n+    }\n } // namespace std\n \n #undef __BITSET_WORDS\n \n-#endif /* __GLIBCPP_BITSET */\n-\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n-\n+#endif "}, {"sha": "244f308924fb66987ceae8c91c8632144e88cc56", "filename": "libstdc++-v3/src/bitset.cc", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788/libstdc%2B%2B-v3%2Fsrc%2Fbitset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788/libstdc%2B%2B-v3%2Fsrc%2Fbitset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fbitset.cc?ref=1cb7f91f86f8393e3a7ee4e83fa489469cbb9788", "patch": "@@ -1,6 +1,6 @@\n // Bitset definitions -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation\n+// Copyright (C) 2001, 2002 Free Software Foundation\n //\n // This file is part of GNU CC.\n //\n@@ -59,7 +59,7 @@ std::_Base_bitset<1>::_M_do_find_first(std::size_t __not_found) const\n       unsigned char __this_byte\n         = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n       if ( __this_byte )\n-        return __j*CHAR_BIT + _First_one<true>::_S_first_one[__this_byte];\n+        return __j * CHAR_BIT + _S_first_one[__this_byte];\n \n       __thisword >>= CHAR_BIT;\n     }\n@@ -93,7 +93,7 @@ std::_Base_bitset<1>::_M_do_find_next(std::size_t __prev,\n       unsigned char __this_byte\n         = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n       if ( __this_byte )\n-        return __j*CHAR_BIT + _First_one<true>::_S_first_one[__this_byte];\n+        return __j * CHAR_BIT + _S_first_one[__this_byte];\n \n       __thisword >>= CHAR_BIT;\n     }\n@@ -103,11 +103,10 @@ std::_Base_bitset<1>::_M_do_find_next(std::size_t __prev,\n   return __not_found;\n } // end _M_do_find_next\n \n-// ------------------------------------------------------------\n-// Lookup tables for find and count operations.\n \n-template<bool __dummy>\n-unsigned char std::_Bit_count<__dummy>::_S_bit_count[] = {\n+// Lookup tables for find and count operations.\n+unsigned char std::_S_bit_count[256] = \n+{\n   0, /*   0 */ 1, /*   1 */ 1, /*   2 */ 2, /*   3 */ 1, /*   4 */\n   2, /*   5 */ 2, /*   6 */ 3, /*   7 */ 1, /*   8 */ 2, /*   9 */\n   2, /*  10 */ 3, /*  11 */ 2, /*  12 */ 3, /*  13 */ 3, /*  14 */\n@@ -160,10 +159,10 @@ unsigned char std::_Bit_count<__dummy>::_S_bit_count[] = {\n   6, /* 245 */ 6, /* 246 */ 7, /* 247 */ 5, /* 248 */ 6, /* 249 */\n   6, /* 250 */ 7, /* 251 */ 6, /* 252 */ 7, /* 253 */ 7, /* 254 */\n   8  /* 255 */\n-}; // end _Bit_count\n+}; // end _S_bit_count\n \n-template<bool __dummy>\n-unsigned char std::_First_one<__dummy>::_S_first_one[] = {\n+unsigned char std::_S_first_one[256] = \n+{\n   0, /*   0 */ 0, /*   1 */ 1, /*   2 */ 0, /*   3 */ 2, /*   4 */\n   0, /*   5 */ 1, /*   6 */ 0, /*   7 */ 3, /*   8 */ 0, /*   9 */\n   1, /*  10 */ 0, /*  11 */ 2, /*  12 */ 0, /*  13 */ 1, /*  14 */\n@@ -216,12 +215,5 @@ unsigned char std::_First_one<__dummy>::_S_first_one[] = {\n   0, /* 245 */ 1, /* 246 */ 0, /* 247 */ 3, /* 248 */ 0, /* 249 */\n   1, /* 250 */ 0, /* 251 */ 2, /* 252 */ 0, /* 253 */ 1, /* 254 */\n   0, /* 255 */\n-}; // end _First_one\n-\n-// Explicitly instantiate them.\n-\n-template unsigned char std::_Bit_count<false>::_S_bit_count[];\n-template unsigned char std::_Bit_count<true>::_S_bit_count[];\n+}; // end _S_first_one\n \n-template unsigned char std::_First_one<false>::_S_first_one[];\n-template unsigned char std::_First_one<true>::_S_first_one[];"}, {"sha": "30e0ab6e063e5e7e38f45ac410425ad2e0875bbc", "filename": "libstdc++-v3/testsuite/23_containers/bitset_members.cc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb7f91f86f8393e3a7ee4e83fa489469cbb9788/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset_members.cc?ref=1cb7f91f86f8393e3a7ee4e83fa489469cbb9788", "patch": "@@ -45,9 +45,16 @@ test01(void)\n   VERIFY( test );\n }\n \n+// libstdc++/6124\n+void test02()\n+{\n+  std::bitset<1> bs;\n+  bs.count();\n+}\n+\n int main()\n {\n   test01();\n-\n+  test02();\n   return 0;\n }"}]}