{"sha": "7ea35487a215ccd9a34c46a5a17194c61dbfb9d9", "node_id": "C_kwDOANBUbNoAKDdlYTM1NDg3YTIxNWNjZDlhMzRjNDZhNWExNzE5NGM2MWRiZmI5ZDk", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-23T15:43:01Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-25T09:28:42Z"}, "message": "macros: Allow checking past zeroable matches for follow-set restrictions\n\nWhen trying to figure out if a match can follow another, we must figure\nout whether or not that match is in the follow-set of the other. If that\nmatch is zeroable (i.e a repetition using the * or ? kleene operators),\nthen we must be able to check the match after them: should our current\nmatch not be present, the match after must be part of the follow-set.\nThis commits allows us to performs such checks properly and to \"look\npast\" zeroable matches. This is not done with any lookahead, simply by\nkeeping a list of pointers to possible previous matches and checking all\nof them for ambiguities.", "tree": {"sha": "2466ee1fda8728f68cada39716855edc35b66534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2466ee1fda8728f68cada39716855edc35b66534"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89ad4f21f25a2501bb9bb96338be4a6edb89bbcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ad4f21f25a2501bb9bb96338be4a6edb89bbcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ad4f21f25a2501bb9bb96338be4a6edb89bbcd"}], "stats": {"total": 84, "additions": 65, "deletions": 19}, "files": [{"sha": "1d922836c04ed95d35a01b99ca14ae3b18d9169a", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=7ea35487a215ccd9a34c46a5a17194c61dbfb9d9", "patch": "@@ -291,6 +291,10 @@ class MacroMatchRepetition : public MacroMatch\n   MacroRepOp get_op () const { return op; }\n   const std::unique_ptr<MacroRepSep> &get_sep () const { return sep; }\n   std::vector<std::unique_ptr<MacroMatch> > &get_matches () { return matches; }\n+  const std::vector<std::unique_ptr<MacroMatch> > &get_matches () const\n+  {\n+    return matches;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -366,6 +370,10 @@ class MacroMatcher : public MacroMatch\n \n   DelimType get_delim_type () const { return delim_type; }\n   std::vector<std::unique_ptr<MacroMatch> > &get_matches () { return matches; }\n+  const std::vector<std::unique_ptr<MacroMatch> > &get_matches () const\n+  {\n+    return matches;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather"}, {"sha": "bcf4ecae321ec9939eec661393d182c629fb282e", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=7ea35487a215ccd9a34c46a5a17194c61dbfb9d9", "patch": "@@ -1750,6 +1750,10 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n \n   // parse actual macro matches\n   std::vector<std::unique_ptr<AST::MacroMatch>> matches;\n+  // Set of possible preceding macro matches to make sure follow-set\n+  // restrictions are respected.\n+  // TODO: Consider using std::reference_wrapper instead of raw pointers?\n+  std::vector<const AST::MacroMatch *> last_matches;\n \n   t = lexer.peek_token ();\n   // parse token trees until the initial delimiter token is found again\n@@ -1770,9 +1774,30 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n \n       if (matches.size () > 0)\n \t{\n-\t  auto &last_match = matches.back ();\n-\t  if (!is_match_compatible (*last_match, *match))\n-\t    return AST::MacroMatcher::create_error (match->get_match_locus ());\n+\t  const auto *last_match = matches.back ().get ();\n+\n+\t  // We want to check if we are dealing with a zeroable repetition\n+\t  bool zeroable = false;\n+\t  if (last_match->get_macro_match_type ()\n+\t      == AST::MacroMatch::MacroMatchType::Repetition)\n+\t    {\n+\t      auto repetition\n+\t\t= static_cast<const AST::MacroMatchRepetition *> (last_match);\n+\n+\t      if (repetition->get_op ()\n+\t\t  != AST::MacroMatchRepetition::MacroRepOp::ONE_OR_MORE)\n+\t\tzeroable = true;\n+\t    }\n+\n+\t  if (!zeroable)\n+\t    last_matches.clear ();\n+\n+\t  last_matches.emplace_back (last_match);\n+\n+\t  for (auto last : last_matches)\n+\t    if (!is_match_compatible (*last, *match))\n+\t      return AST::MacroMatcher::create_error (\n+\t\tmatch->get_match_locus ());\n \t}\n \n       matches.push_back (std::move (match));"}, {"sha": "b77100a227de924548d24f208d0516c9a4e27da1", "filename": "gcc/rust/parse/rust-parse.cc", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=7ea35487a215ccd9a34c46a5a17194c61dbfb9d9", "patch": "@@ -105,8 +105,8 @@ contains (std::vector<T> &vec, T elm)\n  */\n \n template <typename T>\n-static T *\n-get_back_ptr (std::vector<std::unique_ptr<T>> &values)\n+static const T *\n+get_back_ptr (const std::vector<std::unique_ptr<T>> &values)\n {\n   if (values.empty ())\n     return nullptr;\n@@ -115,8 +115,8 @@ get_back_ptr (std::vector<std::unique_ptr<T>> &values)\n }\n \n template <typename T>\n-static T *\n-get_front_ptr (std::vector<std::unique_ptr<T>> &values)\n+static const T *\n+get_front_ptr (const std::vector<std::unique_ptr<T>> &values)\n {\n   if (values.empty ())\n     return nullptr;\n@@ -151,8 +151,8 @@ peculiar_fragment_match_compatible_fragment (\n }\n \n static bool\n-peculiar_fragment_match_compatible (AST::MacroMatchFragment &last_match,\n-\t\t\t\t    AST::MacroMatch &match)\n+peculiar_fragment_match_compatible (const AST::MacroMatchFragment &last_match,\n+\t\t\t\t    const AST::MacroMatch &match)\n {\n   static std::unordered_map<AST::MacroFragSpec::Kind, std::vector<TokenId>>\n     follow_set\n@@ -208,7 +208,7 @@ peculiar_fragment_match_compatible (AST::MacroMatchFragment &last_match,\n   switch (match.get_macro_match_type ())\n     {\n       case AST::MacroMatch::Tok: {\n-\tauto tok = static_cast<AST::Token *> (&match);\n+\tauto tok = static_cast<const AST::Token *> (&match);\n \tif (contains (allowed_toks, tok->get_id ()))\n \t  return true;\n \tkind_str = \"token `\"\n@@ -218,15 +218,16 @@ peculiar_fragment_match_compatible (AST::MacroMatchFragment &last_match,\n       }\n       break;\n       case AST::MacroMatch::Repetition: {\n-\tauto repetition = static_cast<AST::MacroMatchRepetition *> (&match);\n+\tauto repetition\n+\t  = static_cast<const AST::MacroMatchRepetition *> (&match);\n \tauto &matches = repetition->get_matches ();\n \tauto first_frag = get_front_ptr (matches);\n \tif (first_frag)\n \t  return peculiar_fragment_match_compatible (last_match, *first_frag);\n \tbreak;\n       }\n       case AST::MacroMatch::Matcher: {\n-\tauto matcher = static_cast<AST::MacroMatcher *> (&match);\n+\tauto matcher = static_cast<const AST::MacroMatcher *> (&match);\n \tauto first_token = matcher->get_delim_type ();\n \tTokenId delim_id;\n \tswitch (first_token)\n@@ -250,7 +251,7 @@ peculiar_fragment_match_compatible (AST::MacroMatchFragment &last_match,\n       }\n       case AST::MacroMatch::Fragment: {\n \tauto last_spec = last_match.get_frag_spec ();\n-\tauto fragment = static_cast<AST::MacroMatchFragment *> (&match);\n+\tauto fragment = static_cast<const AST::MacroMatchFragment *> (&match);\n \tif (last_spec.has_follow_set_fragment_restrictions ())\n \t  return peculiar_fragment_match_compatible_fragment (\n \t    last_spec, fragment->get_frag_spec (), match.get_match_locus ());\n@@ -273,9 +274,10 @@ peculiar_fragment_match_compatible (AST::MacroMatchFragment &last_match,\n }\n \n bool\n-is_match_compatible (AST::MacroMatch &last_match, AST::MacroMatch &match)\n+is_match_compatible (const AST::MacroMatch &last_match,\n+\t\t     const AST::MacroMatch &match)\n {\n-  AST::MacroMatch *new_last = nullptr;\n+  const AST::MacroMatch *new_last = nullptr;\n \n   // We want to \"extract\" the concerning matches. In cases such as matchers and\n   // repetitions, we actually store multiple matchers, but are only concerned\n@@ -290,7 +292,8 @@ is_match_compatible (AST::MacroMatch &last_match, AST::MacroMatch &match)\n       // last match (or its actual last component), and it is a fragment, it\n       // may contain some follow up restrictions.\n       case AST::MacroMatch::Fragment: {\n-\tauto fragment = static_cast<AST::MacroMatchFragment *> (&last_match);\n+\tauto fragment\n+\t  = static_cast<const AST::MacroMatchFragment *> (&last_match);\n \tif (fragment->get_frag_spec ().has_follow_set_restrictions ())\n \t  return peculiar_fragment_match_compatible (*fragment, match);\n \telse\n@@ -300,7 +303,7 @@ is_match_compatible (AST::MacroMatch &last_match, AST::MacroMatch &match)\n \t// A repetition on the left hand side means we want to make sure the\n \t// last match of the repetition is compatible with the new match\n \tauto repetition\n-\t  = static_cast<AST::MacroMatchRepetition *> (&last_match);\n+\t  = static_cast<const AST::MacroMatchRepetition *> (&last_match);\n \tnew_last = get_back_ptr (repetition->get_matches ());\n \t// If there are no matches in the matcher, then it can be followed by\n \t// anything"}, {"sha": "5653293d038adf08d5226da9a37c326baa12ad7e", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=7ea35487a215ccd9a34c46a5a17194c61dbfb9d9", "patch": "@@ -714,8 +714,8 @@ extract_module_path (const AST::AttrVec &inner_attrs,\n  * @return true if the follow-up is valid, false otherwise\n  */\n bool\n-is_match_compatible (AST::MacroMatch &last_match,\n-\t\t     AST::MacroMatch &current_match);\n+is_match_compatible (const AST::MacroMatch &last_match,\n+\t\t     const AST::MacroMatch &current_match);\n } // namespace Rust\n \n // as now template, include implementations of all methods"}, {"sha": "5713d90130aaa1cc79988a9094756ac609d8c2d0", "filename": "gcc/testsuite/rust/compile/macro37.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro37.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro37.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro37.rs?ref=7ea35487a215ccd9a34c46a5a17194c61dbfb9d9", "patch": "@@ -0,0 +1,5 @@\n+macro_rules! invalid_after_zeroable {\n+    ($e:expr $(,)* forbidden) => {{}}; // { dg-error \"token .identifier. is not allowed after .expr. fragment\" }\n+                                       // { dg-error \"required first macro rule\" \"\" { target *-*-* } .-1 }\n+                                       // { dg-error \"failed to parse item in crate\" \"\" { target *-*-* } .-2 }\n+}"}, {"sha": "eb294aec83bb87d0a2020cada58fd3cd0f6b55e4", "filename": "gcc/testsuite/rust/compile/macro38.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro38.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea35487a215ccd9a34c46a5a17194c61dbfb9d9/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro38.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro38.rs?ref=7ea35487a215ccd9a34c46a5a17194c61dbfb9d9", "patch": "@@ -0,0 +1,5 @@\n+macro_rules! invalid_after_zeroable_multi {\n+    ($e:expr $(,)? $(;)* $(=>)? forbidden) => {{}}; // { dg-error \"token .identifier. is not allowed after .expr. fragment\" }\n+                                                    // { dg-error \"required first macro rule\" \"\" { target *-*-* } .-1 }\n+                                                    // { dg-error \"failed to parse item in crate\" \"\" { target *-*-* } .-2 }\n+}"}]}