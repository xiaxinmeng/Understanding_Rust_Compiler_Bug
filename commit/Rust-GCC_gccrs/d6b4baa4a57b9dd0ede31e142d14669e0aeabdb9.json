{"sha": "d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZiNGJhYTRhNTdiOWRkMGVkZTMxZTE0MmQxNDY2OWUwYWVhYmRiOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-12-25T15:17:37Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-12-25T15:17:37Z"}, "message": "alpha-modes.def: Fix comment formatting.\n\n\t* config/alpha/alpha-modes.def: Fix comment formatting.\n\t* config/alpha/alpha.c: Likewise.\n\t* config/alpha/alpha.h: Likewise.\n\t* config/alpha/elf.h: Likewise.\n\t* config/alpha/lib1funcs.asm: Likewise.\n\t* config/alpha/openbsd.h: Likewise.\n\t* config/alpha/vms-cc.c: Likewise.\n\t* config/alpha/vms-crt0-64.c: Likewise.\n\t* config/alpha/vms-crt0.c: Likewise.\n\t* config/alpha/vms-ld.c: Likewise.\n\t* config/alpha/vms-psxcrt0-64.c: Likewise.\n\t* config/alpha/vms-psxcrt0.c: Likewise.\n\t* config/alpha/vms.h: Likewise.\n\t* config/arc/arc.c: Likewise.\n\t* config/arm/aof.h: Likewise.\n\t* config/arm/arm-modes.def: Likewise.\n\t* config/arm/arm.c: Likewise.\n\t* config/arm/arm.h: Likewise.\n\t* config/arm/arm.md: Likewise.\n\t* config/arm/linux-elf.h: Likewise.\n\t* config/arm/vxworks.h: Likewise.\n\t* config/avr/avr.c: Likewise.\n\t* config/avr/avr.h: Likewise.\n\nFrom-SVN: r75019", "tree": {"sha": "5f86c90c00d8ed7e1ddab06edccedfc1ca97b280", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f86c90c00d8ed7e1ddab06edccedfc1ca97b280"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/comments", "author": null, "committer": null, "parents": [{"sha": "3bbc2af6e7386fb076a92ec9a4e902b3524c587b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bbc2af6e7386fb076a92ec9a4e902b3524c587b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bbc2af6e7386fb076a92ec9a4e902b3524c587b"}], "stats": {"total": 228, "additions": 127, "deletions": 101}, "files": [{"sha": "3006e1ef7f43b057c618a5819fe5b83ce899e81a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -1,3 +1,29 @@\n+2003-12-25  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/alpha/alpha-modes.def: Fix comment formatting.\n+\t* config/alpha/alpha.c: Likewise.\n+\t* config/alpha/alpha.h: Likewise.\n+\t* config/alpha/elf.h: Likewise.\n+\t* config/alpha/lib1funcs.asm: Likewise.\n+\t* config/alpha/openbsd.h: Likewise.\n+\t* config/alpha/vms-cc.c: Likewise.\n+\t* config/alpha/vms-crt0-64.c: Likewise.\n+\t* config/alpha/vms-crt0.c: Likewise.\n+\t* config/alpha/vms-ld.c: Likewise.\n+\t* config/alpha/vms-psxcrt0-64.c: Likewise.\n+\t* config/alpha/vms-psxcrt0.c: Likewise.\n+\t* config/alpha/vms.h: Likewise.\n+\t* config/arc/arc.c: Likewise.\n+\t* config/arm/aof.h: Likewise.\n+\t* config/arm/arm-modes.def: Likewise.\n+\t* config/arm/arm.c: Likewise.\n+\t* config/arm/arm.h: Likewise.\n+\t* config/arm/arm.md: Likewise.\n+\t* config/arm/linux-elf.h: Likewise.\n+\t* config/arm/vxworks.h: Likewise.\n+\t* config/avr/avr.c: Likewise.\n+\t* config/avr/avr.h: Likewise.\n+\n 2003-12-24  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/xtensa/elf.h: Fix comment formatting."}, {"sha": "8e9e6984bd25dec882a4cca35697f21c25bd0325", "filename": "gcc/config/alpha/alpha-modes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Falpha-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Falpha-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-modes.def?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -19,5 +19,5 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n /* 128-bit floating point.  This gets reset in alpha_override_options\n-   if VAX float format is in use. */\n+   if VAX float format is in use.  */\n FLOAT_MODE (TF, 16, ieee_quad_format);"}, {"sha": "87408d6f5f7b348e5c69f2356b32c4f6d61193da", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -5125,7 +5125,7 @@ alpha_multipass_dfa_lookahead (void)\n \n struct machine_function GTY(())\n {\n-  /* For unicosmk. */\n+  /* For unicosmk.  */\n   /* List of call information words for calls from this function.  */\n   struct rtx_def *first_ciw;\n   struct rtx_def *last_ciw;\n@@ -5134,7 +5134,7 @@ struct machine_function GTY(())\n   /* List of deferred case vectors.  */\n   struct rtx_def *addr_list;\n \n-  /* For OSF. */\n+  /* For OSF.  */\n   const char *some_ld_name;\n };\n "}, {"sha": "fac277240a3afaca6e90297e82a115ba4b0423f7", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -818,7 +818,7 @@ enum reg_class {\n \n    'U' is a symbolic operand.\n \n-   'W' is a vector zero.   */\n+   'W' is a vector zero.  */\n \n #define EXTRA_CONSTRAINT  alpha_extra_constraint\n "}, {"sha": "34bba3ecb179335db1a882afc3b760b43de62748", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -18,7 +18,7 @@ GNU General Public License for more details.\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.    */\n+Boston, MA 02111-1307, USA.  */\n \n #undef OBJECT_FORMAT_COFF\n #undef EXTENDED_COFF\n@@ -389,7 +389,7 @@ void FN (void)\t\t\t\t\t\\\n /* Provide a STARTFILE_SPEC appropriate for ELF.  Here we add the\n    (even more) magical crtbegin.o file which provides part of the\n    support for getting C++ file-scope static object constructed\n-   before entering `main'.   */\n+   before entering `main'.  */\n \n #undef\tSTARTFILE_SPEC\n #ifdef HAVE_LD_PIE"}, {"sha": "a2abb1f8ae4932d00761730180db8db20e4f75f2", "filename": "gcc/config/alpha/lib1funcs.asm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Flib1funcs.asm?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -307,7 +307,7 @@ $46:\n    conventions.  */\n #if TYPE == UNSIGNED && SIZE == 32\n \t/* This could be avoided by adding some CPP hair to the divide loop.\n-\t   It is probably not worth the added complexity.    */\n+\t   It is probably not worth the added complexity.  */\n \taddl\tRETREG,0,RETREG\n #endif\n "}, {"sha": "b9df2e4255c5b2148835e10fab27743108cb6390", "filename": "gcc/config/alpha/openbsd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fopenbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fopenbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fopenbsd.h?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -72,7 +72,7 @@ Boston, MA 02111-1307, USA.  */\n /* Assembler format: exception region output.  */\n \n /* All configurations that don't use elf must be explicit about not using\n-   dwarf unwind information. */\n+   dwarf unwind information.  */\n #ifdef INCOMING_RETURN_ADDR_RTX\n #undef DWARF2_UNWIND_INFO\n #define DWARF2_UNWIND_INFO 0"}, {"sha": "672a30fe4683e26f232494598549cf35535da539", "filename": "gcc/config/alpha/vms-cc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-cc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-cc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-cc.c?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -49,22 +49,22 @@ static char *default_defines = (char *) \"\";\n static char *defines;\n \n /* Translate a Unix syntax directory specification into VMS syntax.\n-   If indicators of VMS syntax found, return input string. */\n+   If indicators of VMS syntax found, return input string.  */\n static char *to_host_dir_spec (char *);\n \n /* Translate a Unix syntax file specification into VMS syntax.\n-   If indicators of VMS syntax found, return input string. */\n+   If indicators of VMS syntax found, return input string.  */\n static char *to_host_file_spec (char *);\n \n-/* Add a translated arg to the list to be passed to DEC CC */\n+/* Add a translated arg to the list to be passed to DEC CC.  */\n static void addarg (const char *);\n \n /* Preprocess the number of args in P_ARGC and contained in ARGV.\n-   Look for special flags, etc. that must be handled first. */\n+   Look for special flags, etc. that must be handled first.  */\n static void preprocess_args (int *, char **);\n \n /* Process the number of args in P_ARGC and contained in ARGV. Look\n-   for special flags, etc. that must be handled for the VMS compiler. */\n+   for special flags, etc. that must be handled for the VMS compiler.  */\n static void process_args (int *, char **);\n \n /* Action routine called by decc$to_vms */"}, {"sha": "9792f9205a5517835a6751f70ac99d66cb819766", "filename": "gcc/config/alpha/vms-crt0-64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-crt0-64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-crt0-64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-crt0-64.c?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -77,7 +77,7 @@ __main (arg1, arg2, arg3, image_file_desc, arg5, arg6)\n \n #pragma __pointer_size long\n \n-  /* Reallocate argv with 64 bit pointers. */\n+  /* Reallocate argv with 64 bit pointers.  */\n   long_argv = (char **) malloc (sizeof (char *) * (argc + 1));\n \n   for (i = 0; i < argc; i++)"}, {"sha": "88896c63af75b060ea5d5fc70acf450af32e07bc", "filename": "gcc/config/alpha/vms-crt0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-crt0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-crt0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-crt0.c?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -33,7 +33,7 @@ You Lose! This file can only be compiled with DEC C.\n #else\n \n /* This file can only be compiled with DEC C, due to the call to\n-   lib$establish. */\n+   lib$establish.  */\n \n #include <stdlib.h>\n #include <string.h>"}, {"sha": "cb1d4c93faaaeff8a4d1c96242dd3daf8c660bcc", "filename": "gcc/config/alpha/vms-ld.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-ld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-ld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-ld.c?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -44,7 +44,7 @@ static char *vmsdwarf2spec = 0;\n /* File specification for vms-dwarf2eh.o.  */\n static char *vmsdwarf2ehspec = 0;\n \n-/* verbose = 1 if -v passed.   */\n+/* verbose = 1 if -v passed.  */\n static int verbose = 0;\n \n /* save_temps = 1 if -save-temps passed.  */\n@@ -95,26 +95,26 @@ static void addarg (const char *);\n static int is_regular_file (char *);\n \n /* Translate a Unix syntax file specification FILESPEC into VMS syntax.\n-   If indicators of VMS syntax found, return input string. */\n+   If indicators of VMS syntax found, return input string.  */\n static char *to_host_file_spec (char *);\n \n-/* Locate the library named LIB_NAME in the set of paths PATH_VAL. */\n+/* Locate the library named LIB_NAME in the set of paths PATH_VAL.  */\n static char *locate_lib (char *, char *);\n \n /* Given a library name NAME, i.e. foo,  Look for libfoo.lib and then\n    libfoo.a in the set of directories we are allowed to search in.  */\n static const char *expand_lib (char *);\n \n /* Preprocess the number of args P_ARGC in ARGV.\n-   Look for special flags, etc. that must be handled first. */\n+   Look for special flags, etc. that must be handled first.  */\n static void preprocess_args (int *, char **);\n \n /* Preprocess the number of args P_ARGC in ARGV.  Look for\n-   special flags, etc. that must be handled for the VMS linker. */\n+   special flags, etc. that must be handled for the VMS linker.  */\n static void process_args (int *, char **);\n \n /* Action routine called by decc$to_vms. NAME is a file name or\n-   directory name. TYPE is unused. */\n+   directory name. TYPE is unused.  */\n static int translate_unix (char *, int);\n \n int main (int, char **);"}, {"sha": "8ca9e1d07b53d89bea04df80cf62c240de548e77", "filename": "gcc/config/alpha/vms-psxcrt0-64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-psxcrt0-64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-psxcrt0-64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-psxcrt0-64.c?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -79,7 +79,7 @@ __main (arg1, arg2, arg3, image_file_desc, arg5, arg6)\n \n #pragma __pointer_size long\n \n-  /* Reallocate argv with 64 bit pointers. */\n+  /* Reallocate argv with 64 bit pointers.  */\n   long_argv = (char **) malloc (sizeof (char *) * (argc + 1));\n \n   for (i = 0; i < argc; i++)"}, {"sha": "65962ee221962926d84857f75f38701a235b3c2f", "filename": "gcc/config/alpha/vms-psxcrt0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-psxcrt0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms-psxcrt0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-psxcrt0.c?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -33,7 +33,7 @@ You Lose! This file can only be compiled with DEC C.\n #else\n \n /* This file can only be compiled with DEC C, due to the call to\n-   lib$establish. */\n+   lib$establish.  */\n \n #include <stdlib.h>\n #include <string.h>"}, {"sha": "338ed559a32d485f79b42acf36a1b35e47a42ce4", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -422,7 +422,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n }\n \n /* Link with vms-dwarf2.o if -g (except -g0). This causes the\n-   VMS link to pull all the dwarf2 debug sections together. */\n+   VMS link to pull all the dwarf2 debug sections together.  */\n #undef LINK_SPEC\n #define LINK_SPEC \"%{g:-g vms-dwarf2.o%s} %{g0} %{g1:-g1 vms-dwarf2.o%s} \\\n %{g2:-g2 vms-dwarf2.o%s} %{g3:-g3 vms-dwarf2.o%s} %{shared} %{v} %{map}\""}, {"sha": "876bef56828366c2e06dc1c4364f68d8aa6ea8d9", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -1047,7 +1047,7 @@ arc_compute_function_type (tree decl)\n    SIZE is the size needed for local variables.  */\n \n unsigned int\n-arc_compute_frame_size (int size /* # of var. bytes allocated. */)\n+arc_compute_frame_size (int size /* # of var. bytes allocated.  */)\n {\n   int regno;\n   unsigned int total_size, var_size, args_size, pretend_size, extra_size;"}, {"sha": "5a6ab2c0e2c833d20578e98b35ac51ddc0c7b0c1", "filename": "gcc/config/arm/aof.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Faof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Faof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faof.h?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -133,7 +133,7 @@\n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n    give the same symbol without quotes for an alternative entry point.  You\n-   must define both, or neither. */\n+   must define both, or neither.  */\n #define NAME__MAIN \"__gccmain\"\n #define SYMBOL__MAIN __gccmain\n \n@@ -290,7 +290,7 @@ do {\t\t\t\t\t\\\n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\\\n   fprintf ((STREAM), \"\\tDCD\\t|L..%d|\\n\", (VALUE))\n \n-/* A label marking the start of a jump table is a data label. */\n+/* A label marking the start of a jump table is a data label.  */\n #define ASM_OUTPUT_CASE_LABEL(STREAM, PREFIX, NUM, TABLE)\t\\\n   fprintf ((STREAM), \"\\tALIGN\\n|%s..%d|\\n\", (PREFIX), (NUM))\n "}, {"sha": "b85355191418e9e37991565059629381f6ee415f", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -31,7 +31,7 @@ FLOAT_MODE (XF, 12, 0);\n    CC_NOOVmode should be used with SImode integer equalities.\n    CC_Zmode should be used if only the Z flag is set correctly\n    CC_Nmode should be used if only the N (sign) flag is set correctly\n-   CCmode should be used otherwise. */\n+   CCmode should be used otherwise.  */\n \n CC_MODE (CC_NOOV);\n CC_MODE (CC_Z);"}, {"sha": "c8dc0249d61e016605ae5ebb499e57520edbe14d", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -854,7 +854,7 @@ arm_override_options (void)\n       arm_constant_limit = 1;\n \n       /* If optimizing for size, bump the number of instructions that we\n-         are prepared to conditionally execute (even on a StrongARM). */\n+         are prepared to conditionally execute (even on a StrongARM).  */\n       max_insns_skipped = 6;\n     }\n   else\n@@ -867,7 +867,7 @@ arm_override_options (void)\n \n       /* On XScale the longer latency of a load makes it more difficult\n          to achieve a good schedule, so it's faster to synthesize\n-\t constants that can be done in two insns. */\n+\t constants that can be done in two insns.  */\n       if (arm_tune_xscale)\n         arm_constant_limit = 2;\n \n@@ -1061,13 +1061,13 @@ use_return_insn (int iscond, rtx sibling)\n   if (stack_adjust == 4 && !arm_arch5)\n     {\n       /* Validate that r3 is a call-clobbered register (always true in\n-\t the default abi) ... */\n+\t the default abi) ...  */\n       if (!call_used_regs[3])\n \treturn 0;\n \n       /* ... that it isn't being used for a return value (always true\n \t until we implement return-in-regs), or for a tail-call\n-\t argument ... */\n+\t argument ...  */\n       if (sibling)\n \t{\n \t  if (GET_CODE (sibling) != CALL_INSN)\n@@ -2008,7 +2008,7 @@ arm_return_in_memory (tree type)\n   return 1;\n }\n \n-/* Indicate whether or not words of a double are in big-endian order. */\n+/* Indicate whether or not words of a double are in big-endian order.  */\n \n int\n arm_float_words_big_endian (void)\n@@ -3200,7 +3200,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n \tcase AND:\n \tcase XOR:\n \tcase IOR: \n-\t  /* XXX guess. */\n+\t  /* XXX guess.  */\n \t  return 8;\n \n \tcase ADDRESSOF:\n@@ -3213,7 +3213,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n \t\t     ? 4 : 0));\n \n \tcase IF_THEN_ELSE:\n-\t  /* XXX a guess. */\n+\t  /* XXX a guess.  */\n \t  if (GET_CODE (XEXP (x, 1)) == PC || GET_CODE (XEXP (x, 2)) == PC)\n \t    return 14;\n \t  return 2;\n@@ -3396,11 +3396,11 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n \t      unsigned HOST_WIDE_INT masked_const;\n \n \t      /* The cost will be related to two insns.\n-\t\t First a load of the constant (MOV or LDR), then a multiply. */\n+\t\t First a load of the constant (MOV or LDR), then a multiply.  */\n \t      cost = 2;\n \t      if (! const_ok)\n \t\tcost += 1;      /* LDR is probably more expensive because\n-\t\t\t\t   of longer result latency. */\n+\t\t\t\t   of longer result latency.  */\n \t      masked_const = i & 0xffff8000;\n \t      if (masked_const != 0 && masked_const != 0xffff8000)\n \t\t{\n@@ -3533,7 +3533,7 @@ arm_rtx_costs (rtx x, int code, int outer_code, int *total)\n /* All address computations that can be done are free, but rtx cost returns\n    the same for practically all of them.  So we weight the different types\n    of address here in the order (most pref first):\n-   PRE/POST_INC/DEC, SHIFT or NON-INT sum, INT sum, REG, MEM or LABEL. */\n+   PRE/POST_INC/DEC, SHIFT or NON-INT sum, INT sum, REG, MEM or LABEL.  */\n static inline int\n arm_arm_address_cost (rtx x)\n {\n@@ -8027,7 +8027,7 @@ output_ascii_pseudo_op (FILE *stream, const unsigned char *p, int len)\n \tcase '\\\\':\n \t  putc ('\\\\', stream);\n \t  len_so_far++;\n-\t  /* drop through.  */\n+\t  /* Drop through.  */\n \n \tdefault:\n \t  if (c >= ' ' && c <= '~')\n@@ -9848,7 +9848,7 @@ arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       output_addr_const (asm_out_file, x);\n \n       /* Mark symbols as position independent.  We only do this in the\n-\t .text segment, not in the .data segment. */\n+\t .text segment, not in the .data segment.  */\n       if (NEED_GOT_RELOC && flag_pic && making_const_table &&\n \t  (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF))\n \t{\n@@ -10359,7 +10359,7 @@ arm_final_prescan_insn (rtx insn)\n \t        }\n \t      if (!this_insn)\n \t        {\n-\t\t  /* Oh, dear! we ran off the end.. give up */\n+\t\t  /* Oh, dear! we ran off the end.. give up.  */\n \t\t  recog (PATTERN (insn), insn, NULL);\n \t\t  arm_ccfsm_state = 0;\n \t\t  arm_target_insn = NULL;\n@@ -10536,7 +10536,7 @@ arm_debugger_arg_offset (int value, rtx addr)\n      which is the frame pointer\n      a constant integer\n \n-     then... */\n+     then...  */\n   \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n@@ -11864,7 +11864,7 @@ is_called_in_ARM_mode (tree func)\n #endif\n }\n \n-/* The bits which aren't usefully expanded as rtl. */\n+/* The bits which aren't usefully expanded as rtl.  */\n const char *\n thumb_unexpanded_epilogue (void)\n {\n@@ -11949,7 +11949,7 @@ thumb_unexpanded_epilogue (void)\n \n \t  mask &= (2 << regno) - 1;\t/* A noop if regno == 8 */\n \n-\t  /* Pop the values into the low register(s). */\n+\t  /* Pop the values into the low register(s).  */\n \t  thumb_pushpop (asm_out_file, mask, 0);\n \n \t  /* Move the value(s) into the high registers.  */\n@@ -11977,7 +11977,7 @@ thumb_unexpanded_epilogue (void)\n     {\n       /* The stack backtrace structure creation code had to\n \t push R7 in order to get a work register, so we pop\n-\t it now.   */\n+\t it now.  */\n       live_regs_mask |= (1 << LAST_LO_REGNUM);\n     }\n   \n@@ -12332,7 +12332,7 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t the assembler to bypass the ARM code when this function\n \t is called from a Thumb encoded function elsewhere in the\n \t same file.  Hence the definition of STUB_NAME here must\n-\t agree with the definition in gas/config/tc-arm.c  */\n+\t agree with the definition in gas/config/tc-arm.c.  */\n       \n #define STUB_NAME \".real_start_of\"\n       \n@@ -12407,7 +12407,7 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n \t  if (regs_ever_live [LAST_ARG_REGNUM] == 0)\n \t    work_register = LAST_ARG_REGNUM;\n-\t  else\t  /* We must push a register of our own */\n+\t  else\t  /* We must push a register of our own.  */\n \t    live_regs_mask |= (1 << LAST_LO_REGNUM);\n \t}\n "}, {"sha": "9cc35f405a510ca70a183976739056e405c3ae90", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -130,12 +130,12 @@ extern GTY(()) rtx arm_compare_op1;\n /* The label of the current constant pool.  */\n extern rtx pool_vector_label;\n /* Set to 1 when a return insn is output, this means that the epilogue\n-   is not needed. */\n+   is not needed.  */\n extern int return_used_this_function;\n /* Used to produce AOF syntax assembler.  */\n extern GTY(()) rtx aof_pic_label;\n \f\n-/* Just in case configure has failed to define anything. */\n+/* Just in case configure has failed to define anything.  */\n #ifndef TARGET_CPU_DEFAULT\n #define TARGET_CPU_DEFAULT TARGET_CPU_generic\n #endif\n@@ -371,7 +371,7 @@ extern GTY(()) rtx aof_pic_label;\n    function tries to return.  */\n #define ARM_FLAG_ABORT_NORETURN\t(1 << 13)\n \n-/* Nonzero if function prologues should not load the PIC register. */\n+/* Nonzero if function prologues should not load the PIC register.  */\n #define ARM_FLAG_SINGLE_PIC_BASE (1 << 14)\n \n /* Nonzero if all call instructions should be indirect.  */\n@@ -571,7 +571,7 @@ enum prog_mode_type\n   prog_mode32\n };\n \n-/* Recast the program mode class to be the prog_mode attribute */\n+/* Recast the program mode class to be the prog_mode attribute.  */\n #define arm_prog_mode ((enum attr_prog_mode) arm_prgmode)\n \n extern enum prog_mode_type arm_prgmode;\n@@ -920,7 +920,7 @@ extern const char * structure_size_string;\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.\n    The CC is not preserved over function calls on the ARM 6, so it is \n-   easier to assume this for all.  SFP is preserved, since FP is. */\n+   easier to assume this for all.  SFP is preserved, since FP is.  */\n #define CALL_USED_REGISTERS  \\\n {                            \\\n   1,1,1,1,0,0,0,0,\t     \\\n@@ -953,7 +953,7 @@ extern const char * structure_size_string;\n     {\t\t\t\t\t\t\t\t\\\n       /* When optimizing for size, it's better not to use\t\\\n \t the HI regs, because of the overhead of stacking \t\\\n-\t them. */\t\t\t\t\t\t\\\n+\t them.  */\t\t\t\t\t\t\\\n       for (regno = FIRST_HI_REGNUM;\t\t\t\t\\\n \t   regno <= LAST_HI_REGNUM; ++regno)\t\t\t\\\n \tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n@@ -1233,7 +1233,7 @@ enum reg_class\n \n #define N_REG_CLASSES  (int) LIM_REG_CLASSES\n \n-/* Give names of register classes as strings for dump file.   */\n+/* Give names of register classes as strings for dump file.  */\n #define REG_CLASS_NAMES  \\\n {\t\t\t\\\n   \"NO_REGS\",\t\t\\\n@@ -1297,7 +1297,7 @@ enum reg_class\n /* When SMALL_REGISTER_CLASSES is nonzero, the compiler allows\n    registers explicitly used in the rtl to be used as spill registers\n    but prevents the compiler from extending the lifetime of these\n-   registers. */\n+   registers.  */\n #define SMALL_REGISTER_CLASSES   TARGET_THUMB\n \n /* Get reg_class from a letter such as appears in the machine description.\n@@ -1364,7 +1364,7 @@ enum reg_class\n    an offset from a register.  \n    `S' means any symbol that has the SYMBOL_REF_FLAG set or a CONSTANT_POOL\n    address.  This means that the symbol is in the text segment and can be\n-   accessed without using a load. */\n+   accessed without using a load.  */\n \n #define EXTRA_CONSTRAINT_ARM(OP, C)\t\t\t\t\t    \\\n   ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG :    \\\n@@ -1415,7 +1415,7 @@ enum reg_class\n     ? GENERAL_REGS : NO_REGS)\t\t\t\t\t\\\n    : THUMB_SECONDARY_OUTPUT_RELOAD_CLASS (CLASS, MODE, X))\n    \n-/* If we need to load shorts byte-at-a-time, then we need a scratch. */\n+/* If we need to load shorts byte-at-a-time, then we need a scratch.  */\n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n   /* Cannot load constants into Cirrus registers.  */\t\t\\\n   ((TARGET_CIRRUS\t\t\t\t\t\t\\\n@@ -1569,7 +1569,7 @@ enum reg_class\n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.  */\n /* The push insns do not do this rounding implicitly.\n-   So don't define this. */\n+   So don't define this.  */\n /* #define PUSH_ROUNDING(NPUSHED)  ROUND_UP_WORD (NPUSHED) */\n \n /* Define this if the maximum size of all the outgoing args is to be\n@@ -1620,12 +1620,12 @@ enum reg_class\n \n /* How large values are returned */\n /* A C expression which can inhibit the returning of certain function values\n-   in registers, based on the type of value. */\n+   in registers, based on the type of value.  */\n #define RETURN_IN_MEMORY(TYPE) arm_return_in_memory (TYPE)\n \n /* Define DEFAULT_PCC_STRUCT_RETURN to 1 if all structure and union return\n    values must be in memory.  On the ARM, they need only do so if larger\n-   than a word, or if they contain elements offset from zero in the struct. */\n+   than a word, or if they contain elements offset from zero in the struct.  */\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n /* Flags for the call/call_value rtl operations set up by function_arg.  */\n@@ -1659,7 +1659,7 @@ enum reg_class\n #define ARM_FT_INTERRUPT\t(1 << 2) /* Note overlap with FT_ISR and above.  */\n #define ARM_FT_NAKED\t\t(1 << 3) /* No prologue or epilogue.  */\n #define ARM_FT_VOLATILE\t\t(1 << 4) /* Does not return.  */\n-#define ARM_FT_NESTED\t\t(1 << 5) /* Embedded inside another func. */\n+#define ARM_FT_NESTED\t\t(1 << 5) /* Embedded inside another func.  */\n \n /* Some macros to test these flags.  */\n #define ARM_FUNC_TYPE(t)\t(t & ARM_FT_TYPE_MASK)\n@@ -1703,7 +1703,7 @@ typedef struct\n   int iwmmxt_nregs;\n   int named_count;\n   int nargs;\n-  /* One of CALL_NORMAL, CALL_LONG or CALL_SHORT . */\n+  /* One of CALL_NORMAL, CALL_LONG or CALL_SHORT.  */\n   int call_cookie;\n } CUMULATIVE_ARGS;\n \n@@ -2055,7 +2055,7 @@ typedef struct\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c. */\n+   has been allocated, which happens in local-alloc.c.  */\n #define TEST_REGNO(R, TEST, VALUE) \\\n   ((R TEST VALUE) || ((unsigned) reg_renumber[R] TEST VALUE))\n \n@@ -2081,7 +2081,7 @@ typedef struct\n   REGNO_MODE_OK_FOR_BASE_P (REGNO, QImode)\n \n /* Maximum number of registers that can appear in a valid memory address.\n-   Shifts in addresses can't be by a register. */\n+   Shifts in addresses can't be by a register.  */\n #define MAX_REGS_PER_ADDRESS 2\n \n /* Recognize any constant value that is a valid address.  */\n@@ -2289,7 +2289,7 @@ do {\t\t\t\t\t\t\t\\\n /* Define as C expression which evaluates to nonzero if the tablejump\n    instruction expects the table to contain offsets from the address of the\n    table.\n-   Do not define this if the table should contain absolute addresses. */\n+   Do not define this if the table should contain absolute addresses.  */\n /* #define CASE_VECTOR_PC_RELATIVE 1 */\n \n /* signed 'char' is most compatible, but RISC OS wants it unsigned.\n@@ -2334,7 +2334,7 @@ do {\t\t\t\t\t\t\t\\\n /* This is all wrong.  Defining SHIFT_COUNT_TRUNCATED tells combine that\n    code like (X << (Y % 32)) for register X, Y is equivalent to (X << Y).\n    On the arm, Y in a register is used modulo 256 for the shift. Only for\n-   rotates is modulo 32 used. */\n+   rotates is modulo 32 used.  */\n /* #define SHIFT_COUNT_TRUNCATED 1 */\n \n /* All integers have the same format so truncation is easy.  */\n@@ -2402,7 +2402,7 @@ extern int making_const_table;\n   c_register_pragma (0, \"long_calls_off\", arm_pr_long_calls_off);\t\\\n } while (0)\n \n-/* Condition code information. */\n+/* Condition code information.  */\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  */\n \n@@ -2553,8 +2553,8 @@ extern int making_const_table;\n \tHOST_WIDE_INT offset = 0;\t\t\t\t\t\\\n \tif (GET_CODE (base) != REG)\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    /* Ensure that BASE is a register */\t\t\t\\\n-            /* (one of them must be). */\t\t\t\t\\\n+\t    /* Ensure that BASE is a register.  */\t\t\t\\\n+            /* (one of them must be).  */\t\t\t\t\\\n \t    rtx temp = base;\t\t\t\t\t\t\\\n \t    base = index;\t\t\t\t\t\t\\\n \t    index = temp;\t\t\t\t\t\t\\\n@@ -2743,7 +2743,7 @@ extern int making_const_table;\n /* Define this if you have special predicates that know special things\n    about modes.  Genrecog will warn about certain forms of\n    match_operand without a mode; if the operand predicate is listed in\n-   SPECIAL_MODE_PREDICATES, the warning will be suppressed. */\n+   SPECIAL_MODE_PREDICATES, the warning will be suppressed.  */\n #define SPECIAL_MODE_PREDICATES\t\t\t\\\n  \"cc_register\", \"dominant_cc_register\",\n "}, {"sha": "a6d6d2fa7f733c27731930129dba4159cf4bb920", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -3545,7 +3545,7 @@\n \t(sign_extend:HI (match_operand:QI 1 \"memory_operand\"      \"m\")))]\n   \"TARGET_ARM && arm_arch4\"\n   \"*\n-  /* If the address is invalid, this will split the instruction into two. */\n+  /* If the address is invalid, this will split the instruction into two.  */\n   if (bad_signed_byte_operand (operands[1], VOIDmode))\n     return \\\"#\\\";\n   return \\\"ldr%?sb\\\\t%0, %1\\\";\n@@ -3581,7 +3581,7 @@\n \tXEXP (operands[2], 0) = plus_constant (operands[3], low);\n \toperands[1] = plus_constant (XEXP (operands[1], 0), offset - low);\n       }\n-    /* Ensure the sum is in correct canonical form */\n+    /* Ensure the sum is in correct canonical form.  */\n     else if (GET_CODE (operands[1]) == PLUS\n \t     && GET_CODE (XEXP (operands[1], 1)) != CONST_INT\n \t     && !s_register_operand (XEXP (operands[1], 1), VOIDmode))\n@@ -3643,7 +3643,7 @@\n \t(sign_extend:SI (match_operand:QI 1 \"memory_operand\"      \"m\")))]\n   \"TARGET_ARM && arm_arch4\"\n   \"*\n-  /* If the address is invalid, this will split the instruction into two. */\n+  /* If the address is invalid, this will split the instruction into two.  */\n   if (bad_signed_byte_operand (operands[1], VOIDmode))\n     return \\\"#\\\";\n   return \\\"ldr%?sb\\\\t%0, %1\\\";\n@@ -3678,7 +3678,7 @@\n \tXEXP (operands[2], 0) = plus_constant (operands[0], low);\n \toperands[1] = plus_constant (XEXP (operands[1], 0), offset - low);\n       }\n-    /* Ensure the sum is in correct canonical form */\n+    /* Ensure the sum is in correct canonical form.  */\n     else if (GET_CODE (operands[1]) == PLUS\n \t     && GET_CODE (XEXP (operands[1], 1)) != CONST_INT\n \t     && !s_register_operand (XEXP (operands[1], 1), VOIDmode))\n@@ -3918,7 +3918,7 @@\n   \"\n   if (TARGET_ARM)\n     {\n-      /* Everything except mem = const or mem = mem can be done easily */\n+      /* Everything except mem = const or mem = mem can be done easily.  */\n       if (GET_CODE (operands[0]) == MEM)\n         operands[1] = force_reg (SImode, operands[1]);\n       if (GET_CODE (operands[1]) == CONST_INT\n@@ -3932,7 +3932,7 @@\n           DONE;\n         }\n     }\n-  else /* TARGET_THUMB.... */\n+  else /* TARGET_THUMB....  */\n     {\n       if (!no_new_pseudos)\n         {\n@@ -4419,7 +4419,7 @@\n \t       }\n \t   }\n         }\n-      /* Handle loading a large integer during reload */\n+      /* Handle loading a large integer during reload.  */\n       else if (GET_CODE (operands[1]) == CONST_INT\n \t       && !const_ok_for_arm (INTVAL (operands[1]))\n \t       && !const_ok_for_arm (~INTVAL (operands[1])))\n@@ -4463,7 +4463,7 @@\n \t      = replace_equiv_address (operands[1],\n \t\t\t\t       copy_to_reg (XEXP (operands[1], 0)));\n         }\n-      /* Handle loading a large integer during reload */\n+      /* Handle loading a large integer during reload.  */\n       else if (GET_CODE (operands[1]) == CONST_INT\n \t        && !CONST_OK_FOR_THUMB_LETTER (INTVAL (operands[1]), 'I'))\n         {\n@@ -4768,7 +4768,7 @@\n \t       = replace_equiv_address (operands[1],\n \t\t\t\t\tcopy_to_reg (XEXP (operands[1], 0)));\n         }\n-      /* Handle loading a large integer during reload */\n+      /* Handle loading a large integer during reload.  */\n       else if (GET_CODE (operands[1]) == CONST_INT\n \t       && !CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n         {\n@@ -5167,7 +5167,7 @@\n                      (use (match_operand:SI 2 \"\" \"\"))])]\n   \"TARGET_ARM\"\n   \"\n-  /* Support only fixed point registers */\n+  /* Support only fixed point registers.  */\n   if (GET_CODE (operands[2]) != CONST_INT\n       || INTVAL (operands[2]) > 14\n       || INTVAL (operands[2]) < 2\n@@ -7023,7 +7023,7 @@\n       FAIL;\n \n     /* When compiling for SOFT_FLOAT, ensure both arms are in registers. \n-       Otherwise, ensure it is a valid FP add operand */\n+       Otherwise, ensure it is a valid FP add operand.  */\n     if ((!TARGET_HARD_FLOAT)\n         || (!fpa_add_operand (operands[3], SFmode)))\n       operands[3] = force_reg (SFmode, operands[3]);\n@@ -8252,7 +8252,7 @@\n \t  return \\\"bics\\\\t%0, %2, %3, asr #32\\;movcs\\\\t%0, %1\\\";\n \t}\n       /* The only case that falls through to here is when both ops 1 & 2\n-\t are constants */\n+\t are constants.  */\n     }\n \n   if (GET_CODE (operands[5]) == GE\n@@ -8271,7 +8271,7 @@\n \t  return \\\"ands\\\\t%0, %2, %3, asr #32\\;movcc\\\\t%0, %1\\\";\n \t}\n       /* The only case that falls through to here is when both ops 1 & 2\n-\t are constants */\n+\t are constants.  */\n     }\n   if (GET_CODE (operands[4]) == CONST_INT\n       && !const_ok_for_arm (INTVAL (operands[4])))\n@@ -8408,7 +8408,7 @@\n   \"*\n   /* If we have an operation where (op x 0) is the identity operation and\n      the conditional operator is LT or GE and we are comparing against zero and\n-     everything is in registers then we can do this in two instructions */\n+     everything is in registers then we can do this in two instructions.  */\n   if (operands[3] == const0_rtx\n       && GET_CODE (operands[7]) != AND\n       && GET_CODE (operands[5]) == REG"}, {"sha": "c9ac16bdf304c5c3ddf024f02e9561cc3266733d", "filename": "gcc/config/arm/linux-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-elf.h?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -58,7 +58,7 @@\n /* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add\n    the GNU/Linux magical crtbegin.o file (see crtstuff.c) which\n    provides part of the support for getting C++ file-scope static\n-   object constructed before entering `main'. */\n+   object constructed before entering `main'.  */\n    \n #undef  STARTFILE_SPEC\n #define STARTFILE_SPEC \\"}, {"sha": "afe6b7043bea58b6f71af76c33ba147cd12c7b0d", "filename": "gcc/config/arm/vxworks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Farm%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvxworks.h?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -68,7 +68,7 @@ Boston, MA 02111-1307, USA.  */\n #define LIB_SPEC \t\"\"\n \n /* VxWorks uses object files, not loadable images.  make linker just\n-   combine objects. */\n+   combine objects.  */\n #undef  LINK_SPEC\n #define LINK_SPEC \t\"-r\"\n "}, {"sha": "216ec863ba87e813ce7e451d122cf75aa0502599", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -4215,7 +4215,7 @@ adjust_insn_length (rtx insn, int len)\n   return len;\n }\n \n-/* Return nonzero if register REG dead after INSN. */\n+/* Return nonzero if register REG dead after INSN.  */\n \n int\n reg_unused_after (rtx insn, rtx reg)\n@@ -4383,7 +4383,7 @@ avr_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n    generated assembly code more compact (and thus faster to assemble)\n    as well as more readable, especially for targets like the i386\n    (where the only alternative is to output character sequences as\n-   comma separated lists of numbers).   */\n+   comma separated lists of numbers).  */\n \n void\n gas_output_limited_string(FILE *file, const char *str)"}, {"sha": "0d5cd7c145c7ff5c874894994eca42215fd15f8e", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=d6b4baa4a57b9dd0ede31e142d14669e0aeabdb9", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Names to predefine in the preprocessor for this target machine. */\n+/* Names to predefine in the preprocessor for this target machine.  */\n \n #define TARGET_CPU_CPP_BUILTINS()\t\t\\\n   do\t\t\t\t\t\t\\\n@@ -41,7 +41,7 @@ Boston, MA 02111-1307, USA.  */\n     }\t\t\t\t\t\t\\\n   while (0)\n \n-/* This declaration should be present. */\n+/* This declaration should be present.  */\n extern int target_flags;\n \n #define MASK_ALL_DEBUG\t\t0x00000FE0\n@@ -130,10 +130,10 @@ extern int avr_asm_only_p;\n    frame pointer.  If this macro is defined, GCC will turn on the\n    `-fomit-frame-pointer' option whenever `-O' is specified.  */\n \n-/* Define this if most significant byte of a word is the lowest numbered. */\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n #define BITS_BIG_ENDIAN 0\n \n-/* Define this if most significant byte of a word is the lowest numbered. */\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n #define BYTES_BIG_ENDIAN 0\n \n /* Define this if most significant word of a multiword number is the lowest\n@@ -144,7 +144,7 @@ extern int avr_asm_only_p;\n /* This is to get correct SI and DI modes in libgcc2.c (32 and 64 bits).  */\n #define UNITS_PER_WORD 4\n #else\n-/* Width of a word, in units (bytes). */\n+/* Width of a word, in units (bytes).  */\n #define UNITS_PER_WORD 1\n #endif\n \n@@ -157,16 +157,16 @@ extern int avr_asm_only_p;\n    DImode or Dfmode ...  */\n #define MAX_FIXED_MODE_SIZE 32\n \n-/* Allocation boundary (in *bits*) for storing arguments in argument list. */\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY 8\n \n-/* Allocation boundary (in *bits*) for the code of a function. */\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 8\n \n-/* Alignment of field after `int : 0' in a structure. */\n+/* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY 8\n \n-/* No data type wants to be aligned rounder than this. */\n+/* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 8\n \n \n@@ -211,7 +211,7 @@ extern int avr_asm_only_p;\n #define DOUBLE_TYPE_SIZE 32\n /* A C expression for the size in bits of the type `double' on the\n    target machine.  If you don't define this, the default is two\n-   words. */\n+   words.  */\n \n \n #define LONG_DOUBLE_TYPE_SIZE 32\n@@ -366,7 +366,7 @@ extern int avr_asm_only_p;\n    registers must always be saved and the save-multiple-registers\n    instruction supports only sequences of consecutive registers.  On\n    such machines, define `REG_ALLOC_ORDER' to be an initializer that\n-   lists the highest numbered allocatable register first. */\n+   lists the highest numbered allocatable register first.  */\n \n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n /* ORDER_REGS_FOR_LOCAL_ALLOC'\n@@ -1147,7 +1147,7 @@ typedef struct avr_args {\n    contains the name of the function, as a string.  LIBNAME is 0 when\n    an ordinary C function call is being processed.  Thus, each time\n    this macro is called, either LIBNAME or FNTYPE is nonzero, but\n-   never both of them at once.   */\n+   never both of them at once.  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n   (function_arg_advance (&CUM, MODE, TYPE, NAMED))\n@@ -1160,7 +1160,7 @@ typedef struct avr_args {\n \n    This macro need not do anything if the argument in question was\n    passed on the stack.  The compiler knows how to track the amount\n-   of stack space used for arguments without any special help. */\n+   of stack space used for arguments without any special help.  */\n \n #define FUNCTION_ARG_REGNO_P(r) function_arg_regno_p(r)\n /* A C expression that is nonzero if REGNO is the number of a hard"}]}