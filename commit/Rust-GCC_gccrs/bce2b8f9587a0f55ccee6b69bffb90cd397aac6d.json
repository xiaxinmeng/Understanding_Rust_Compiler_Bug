{"sha": "bce2b8f9587a0f55ccee6b69bffb90cd397aac6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNlMmI4Zjk1ODdhMGY1NWNjZWU2YjY5YmZmYjkwY2QzOTdhYWM2ZA==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2016-09-23T09:59:55Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2016-09-23T09:59:55Z"}, "message": "[PATCH 10/17][ARM] Refactor support code for NEON builtins.\n\ngcc/\n2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n\n\t* config/arm/arm-builtins.c (arm_init_neon_builtin): New.\n\t(arm_init_builtins): Move body of a loop to the standalone\n\tfunction arm_init_neon_builtin.\n\t(arm_expand_neon_builtin_1): New.  Update comment.  Function body\n\tmoved from arm_neon_builtin with some white-space fixes.\n\t(arm_expand_neon_builtin): Move code into the standalone function\n\tarm_expand_neon_builtin_1.\n\nFrom-SVN: r240416", "tree": {"sha": "cdc5c562820e0b11df89c52054d9115c8913f8c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdc5c562820e0b11df89c52054d9115c8913f8c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bce2b8f9587a0f55ccee6b69bffb90cd397aac6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce2b8f9587a0f55ccee6b69bffb90cd397aac6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bce2b8f9587a0f55ccee6b69bffb90cd397aac6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce2b8f9587a0f55ccee6b69bffb90cd397aac6d/comments", "author": null, "committer": null, "parents": [{"sha": "55a9b91ba89e744f86bb6445797e8840585f3258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a9b91ba89e744f86bb6445797e8840585f3258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a9b91ba89e744f86bb6445797e8840585f3258"}], "stats": {"total": 302, "additions": 168, "deletions": 134}, "files": [{"sha": "451f0a4ddba8b168e1a20a35972280292b41537b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce2b8f9587a0f55ccee6b69bffb90cd397aac6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce2b8f9587a0f55ccee6b69bffb90cd397aac6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bce2b8f9587a0f55ccee6b69bffb90cd397aac6d", "patch": "@@ -1,3 +1,13 @@\n+2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* config/arm/arm-builtins.c (arm_init_neon_builtin): New.\n+\t(arm_init_builtins): Move body of a loop to the standalone\n+\tfunction arm_init_neon_builtin.\n+\t(arm_expand_neon_builtin_1): New.  Update comment.  Function body\n+\tmoved from arm_neon_builtin with some white-space fixes.\n+\t(arm_expand_neon_builtin): Move code into the standalone function\n+\tarm_expand_neon_builtin_1.\n+\n 2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n \n \t* config/arm/iterators.md (VCVTHI): New."}, {"sha": "5dd81b1c810d141ce3340514c83b750c7abff978", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 158, "deletions": 134, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce2b8f9587a0f55ccee6b69bffb90cd397aac6d/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce2b8f9587a0f55ccee6b69bffb90cd397aac6d/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=bce2b8f9587a0f55ccee6b69bffb90cd397aac6d", "patch": "@@ -543,7 +543,7 @@ enum arm_builtins\n };\n \n #define ARM_BUILTIN_NEON_PATTERN_START \\\n-    (ARM_BUILTIN_MAX - ARRAY_SIZE (neon_builtin_data))\n+  (ARM_BUILTIN_NEON_BASE + 1)\n \n #undef CF\n #undef VAR1\n@@ -895,6 +895,110 @@ arm_init_simd_builtin_scalar_types (void)\n \t\t\t\t\t     \"__builtin_neon_uti\");\n }\n \n+/* Set up a NEON builtin.  */\n+\n+static void\n+arm_init_neon_builtin (unsigned int fcode,\n+\t\t       neon_builtin_datum *d)\n+{\n+  bool print_type_signature_p = false;\n+  char type_signature[SIMD_MAX_BUILTIN_ARGS] = { 0 };\n+  char namebuf[60];\n+  tree ftype = NULL;\n+  tree fndecl = NULL;\n+\n+  d->fcode = fcode;\n+\n+  /* We must track two variables here.  op_num is\n+     the operand number as in the RTL pattern.  This is\n+     required to access the mode (e.g. V4SF mode) of the\n+     argument, from which the base type can be derived.\n+     arg_num is an index in to the qualifiers data, which\n+     gives qualifiers to the type (e.g. const unsigned).\n+     The reason these two variables may differ by one is the\n+     void return type.  While all return types take the 0th entry\n+     in the qualifiers array, there is no operand for them in the\n+     RTL pattern.  */\n+  int op_num = insn_data[d->code].n_operands - 1;\n+  int arg_num = d->qualifiers[0] & qualifier_void\n+    ? op_num + 1\n+    : op_num;\n+  tree return_type = void_type_node, args = void_list_node;\n+  tree eltype;\n+\n+  /* Build a function type directly from the insn_data for this\n+     builtin.  The build_function_type () function takes care of\n+     removing duplicates for us.  */\n+  for (; op_num >= 0; arg_num--, op_num--)\n+    {\n+      machine_mode op_mode = insn_data[d->code].operand[op_num].mode;\n+      enum arm_type_qualifiers qualifiers = d->qualifiers[arg_num];\n+\n+      if (qualifiers & qualifier_unsigned)\n+\t{\n+\t  type_signature[arg_num] = 'u';\n+\t  print_type_signature_p = true;\n+\t}\n+      else if (qualifiers & qualifier_poly)\n+\t{\n+\t  type_signature[arg_num] = 'p';\n+\t  print_type_signature_p = true;\n+\t}\n+      else\n+\ttype_signature[arg_num] = 's';\n+\n+      /* Skip an internal operand for vget_{low, high}.  */\n+      if (qualifiers & qualifier_internal)\n+\tcontinue;\n+\n+      /* Some builtins have different user-facing types\n+\t for certain arguments, encoded in d->mode.  */\n+      if (qualifiers & qualifier_map_mode)\n+\top_mode = d->mode;\n+\n+      /* For pointers, we want a pointer to the basic type\n+\t of the vector.  */\n+      if (qualifiers & qualifier_pointer && VECTOR_MODE_P (op_mode))\n+\top_mode = GET_MODE_INNER (op_mode);\n+\n+      eltype = arm_simd_builtin_type\n+\t(op_mode,\n+\t (qualifiers & qualifier_unsigned) != 0,\n+\t (qualifiers & qualifier_poly) != 0);\n+      gcc_assert (eltype != NULL);\n+\n+      /* Add qualifiers.  */\n+      if (qualifiers & qualifier_const)\n+\teltype = build_qualified_type (eltype, TYPE_QUAL_CONST);\n+\n+      if (qualifiers & qualifier_pointer)\n+\teltype = build_pointer_type (eltype);\n+\n+      /* If we have reached arg_num == 0, we are at a non-void\n+\t return type.  Otherwise, we are still processing\n+\t arguments.  */\n+      if (arg_num == 0)\n+\treturn_type = eltype;\n+      else\n+\targs = tree_cons (NULL_TREE, eltype, args);\n+    }\n+\n+  ftype = build_function_type (return_type, args);\n+\n+  gcc_assert (ftype != NULL);\n+\n+  if (print_type_signature_p)\n+    snprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s_%s\",\n+\t      d->name, type_signature);\n+  else\n+    snprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s\",\n+\t      d->name);\n+\n+  fndecl = add_builtin_function (namebuf, ftype, fcode, BUILT_IN_MD,\n+\t\t\t\t NULL, NULL_TREE);\n+  arm_builtin_decls[fcode] = fndecl;\n+}\n+\n /* Set up all the NEON builtins, even builtins for instructions that are not\n    in the current target ISA to allow the user to compile particular modules\n    with different target specific options that differ from the command line\n@@ -924,103 +1028,8 @@ arm_init_neon_builtins (void)\n \n   for (i = 0; i < ARRAY_SIZE (neon_builtin_data); i++, fcode++)\n     {\n-      bool print_type_signature_p = false;\n-      char type_signature[SIMD_MAX_BUILTIN_ARGS] = { 0 };\n       neon_builtin_datum *d = &neon_builtin_data[i];\n-      char namebuf[60];\n-      tree ftype = NULL;\n-      tree fndecl = NULL;\n-\n-      d->fcode = fcode;\n-\n-      /* We must track two variables here.  op_num is\n-\t the operand number as in the RTL pattern.  This is\n-\t required to access the mode (e.g. V4SF mode) of the\n-\t argument, from which the base type can be derived.\n-\t arg_num is an index in to the qualifiers data, which\n-\t gives qualifiers to the type (e.g. const unsigned).\n-\t The reason these two variables may differ by one is the\n-\t void return type.  While all return types take the 0th entry\n-\t in the qualifiers array, there is no operand for them in the\n-\t RTL pattern.  */\n-      int op_num = insn_data[d->code].n_operands - 1;\n-      int arg_num = d->qualifiers[0] & qualifier_void\n-\t\t      ? op_num + 1\n-\t\t      : op_num;\n-      tree return_type = void_type_node, args = void_list_node;\n-      tree eltype;\n-\n-      /* Build a function type directly from the insn_data for this\n-\t builtin.  The build_function_type () function takes care of\n-\t removing duplicates for us.  */\n-      for (; op_num >= 0; arg_num--, op_num--)\n-\t{\n-\t  machine_mode op_mode = insn_data[d->code].operand[op_num].mode;\n-\t  enum arm_type_qualifiers qualifiers = d->qualifiers[arg_num];\n-\n-\t  if (qualifiers & qualifier_unsigned)\n-\t    {\n-\t      type_signature[arg_num] = 'u';\n-\t      print_type_signature_p = true;\n-\t    }\n-\t  else if (qualifiers & qualifier_poly)\n-\t    {\n-\t      type_signature[arg_num] = 'p';\n-\t      print_type_signature_p = true;\n-\t    }\n-\t  else\n-\t    type_signature[arg_num] = 's';\n-\n-\t  /* Skip an internal operand for vget_{low, high}.  */\n-\t  if (qualifiers & qualifier_internal)\n-\t    continue;\n-\n-\t  /* Some builtins have different user-facing types\n-\t     for certain arguments, encoded in d->mode.  */\n-\t  if (qualifiers & qualifier_map_mode)\n-\t      op_mode = d->mode;\n-\n-\t  /* For pointers, we want a pointer to the basic type\n-\t     of the vector.  */\n-\t  if (qualifiers & qualifier_pointer && VECTOR_MODE_P (op_mode))\n-\t    op_mode = GET_MODE_INNER (op_mode);\n-\n-\t  eltype = arm_simd_builtin_type\n-\t\t     (op_mode,\n-\t\t      (qualifiers & qualifier_unsigned) != 0,\n-\t\t      (qualifiers & qualifier_poly) != 0);\n-\t  gcc_assert (eltype != NULL);\n-\n-\t  /* Add qualifiers.  */\n-\t  if (qualifiers & qualifier_const)\n-\t    eltype = build_qualified_type (eltype, TYPE_QUAL_CONST);\n-\n-\t  if (qualifiers & qualifier_pointer)\n-\t      eltype = build_pointer_type (eltype);\n-\n-\t  /* If we have reached arg_num == 0, we are at a non-void\n-\t     return type.  Otherwise, we are still processing\n-\t     arguments.  */\n-\t  if (arg_num == 0)\n-\t    return_type = eltype;\n-\t  else\n-\t    args = tree_cons (NULL_TREE, eltype, args);\n-\t}\n-\n-      ftype = build_function_type (return_type, args);\n-\n-      gcc_assert (ftype != NULL);\n-\n-      if (print_type_signature_p)\n-\tsnprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s_%s\",\n-\t\t  d->name, type_signature);\n-      else\n-\tsnprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s\",\n-\t\t  d->name);\n-\n-      fndecl = add_builtin_function (namebuf, ftype, fcode, BUILT_IN_MD,\n-\t\t\t\t     NULL, NULL_TREE);\n-      arm_builtin_decls[fcode] = fndecl;\n+      arm_init_neon_builtin (fcode, d);\n     }\n }\n \n@@ -2211,40 +2220,16 @@ arm_expand_neon_args (rtx target, machine_mode map_mode, int fcode,\n   return target;\n }\n \n-/* Expand a Neon builtin, i.e. those registered only if TARGET_NEON holds.\n-   Most of these are \"special\" because they don't have symbolic\n-   constants defined per-instruction or per instruction-variant. Instead, the\n-   required info is looked up in the table neon_builtin_data.  */\n+/* Expand a neon builtin.  This is also used for vfp builtins, which behave in\n+   the same way.  These builtins are \"special\" because they don't have symbolic\n+   constants defined per-instruction or per instruction-variant.  Instead, the\n+   required info is looked up in the NEON_BUILTIN_DATA record that is passed\n+   into the function.  */\n+\n static rtx\n-arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n+arm_expand_neon_builtin_1 (int fcode, tree exp, rtx target,\n+\t\t\t   neon_builtin_datum *d)\n {\n-  /* Check in the context of the function making the call whether the\n-     builtin is supported.  */\n-  if (! TARGET_NEON)\n-    {\n-      fatal_error (input_location,\n-\t\t   \"You must enable NEON instructions (e.g. -mfloat-abi=softfp -mfpu=neon) to use these intrinsics.\");\n-      return const0_rtx;\n-    }\n-\n-  if (fcode == ARM_BUILTIN_NEON_LANE_CHECK)\n-    {\n-      /* Builtin is only to check bounds of the lane passed to some intrinsics\n-\t that are implemented with gcc vector extensions in arm_neon.h.  */\n-\n-      tree nlanes = CALL_EXPR_ARG (exp, 0);\n-      gcc_assert (TREE_CODE (nlanes) == INTEGER_CST);\n-      rtx lane_idx = expand_normal (CALL_EXPR_ARG (exp, 1));\n-      if (CONST_INT_P (lane_idx))\n-\tneon_lane_bounds (lane_idx, 0, TREE_INT_CST_LOW (nlanes), exp);\n-      else\n-\terror (\"%Klane index must be a constant immediate\", exp);\n-      /* Don't generate any RTL.  */\n-      return const0_rtx;\n-    }\n-\n-  neon_builtin_datum *d =\n-\t\t&neon_builtin_data[fcode - ARM_BUILTIN_NEON_PATTERN_START];\n   enum insn_code icode = d->code;\n   builtin_arg args[SIMD_MAX_BUILTIN_ARGS + 1];\n   int num_args = insn_data[d->code].n_operands;\n@@ -2260,8 +2245,8 @@ arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n       /* We have four arrays of data, each indexed in a different fashion.\n \t qualifiers - element 0 always describes the function return type.\n \t operands - element 0 is either the operand for return value (if\n-\t   the function has a non-void return type) or the operand for the\n-\t   first argument.\n+\t the function has a non-void return type) or the operand for the\n+\t first argument.\n \t expr_args - element 0 always holds the first argument.\n \t args - element 0 is always used for the return type.  */\n       int qualifiers_k = k;\n@@ -2283,7 +2268,7 @@ arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n \t  bool op_const_int_p =\n \t    (CONST_INT_P (arg)\n \t     && (*insn_data[icode].operand[operands_k].predicate)\n-\t\t(arg, insn_data[icode].operand[operands_k].mode));\n+\t     (arg, insn_data[icode].operand[operands_k].mode));\n \t  args[k] = op_const_int_p ? NEON_ARG_CONSTANT : NEON_ARG_COPY_TO_REG;\n \t}\n       else if (d->qualifiers[qualifiers_k] & qualifier_pointer)\n@@ -2296,8 +2281,47 @@ arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n   /* The interface to arm_expand_neon_args expects a 0 if\n      the function is void, and a 1 if it is not.  */\n   return arm_expand_neon_args\n-\t  (target, d->mode, fcode, icode, !is_void, exp,\n-\t   &args[1]);\n+    (target, d->mode, fcode, icode, !is_void, exp,\n+     &args[1]);\n+}\n+\n+/* Expand a Neon builtin, i.e. those registered only if TARGET_NEON holds.\n+   Most of these are \"special\" because they don't have symbolic\n+   constants defined per-instruction or per instruction-variant.  Instead, the\n+   required info is looked up in the table neon_builtin_data.  */\n+\n+static rtx\n+arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n+{\n+  if (fcode >= ARM_BUILTIN_NEON_BASE && ! TARGET_NEON)\n+    {\n+      fatal_error (input_location,\n+\t\t   \"You must enable NEON instructions\"\n+\t\t   \" (e.g. -mfloat-abi=softfp -mfpu=neon)\"\n+\t\t   \" to use these intrinsics.\");\n+      return const0_rtx;\n+    }\n+\n+  if (fcode == ARM_BUILTIN_NEON_LANE_CHECK)\n+    {\n+      /* Builtin is only to check bounds of the lane passed to some intrinsics\n+\t that are implemented with gcc vector extensions in arm_neon.h.  */\n+\n+      tree nlanes = CALL_EXPR_ARG (exp, 0);\n+      gcc_assert (TREE_CODE (nlanes) == INTEGER_CST);\n+      rtx lane_idx = expand_normal (CALL_EXPR_ARG (exp, 1));\n+      if (CONST_INT_P (lane_idx))\n+\tneon_lane_bounds (lane_idx, 0, TREE_INT_CST_LOW (nlanes), exp);\n+      else\n+\terror (\"%Klane index must be a constant immediate\", exp);\n+      /* Don't generate any RTL.  */\n+      return const0_rtx;\n+    }\n+\n+  neon_builtin_datum *d\n+    = &neon_builtin_data[fcode - ARM_BUILTIN_NEON_PATTERN_START];\n+\n+  return arm_expand_neon_builtin_1 (fcode, exp, target, d);\n }\n \n /* Expand an expression EXP that calls a built-in function,"}]}