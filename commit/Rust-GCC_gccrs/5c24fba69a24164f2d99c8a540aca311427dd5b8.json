{"sha": "5c24fba69a24164f2d99c8a540aca311427dd5b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMyNGZiYTY5YTI0MTY0ZjJkOTljOGE1NDBhY2EzMTE0MjdkZDViOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-15T00:16:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-15T00:16:21Z"}, "message": "cp-tree.h: Tweak documentation.\n\n\t* cp-tree.h: Tweak documentation.\n\t* class.c (build_vbase_pointer_fields): Layout the fields, too.\n\t(avoid_overlap): Remove.\n\t(get_binfo_offset_as_int): New function.\n\t(dfs_serach_base_offsets): Likewise.\n\t(layout_nonempty_base_or_field): Likewise.\n\t(build_base_field): Layout fields here.  Avoid placing two objects\n\tof the same type at the same address, under the new ABI.\n\t(build_base_fields): Adjust accordingly.\n\t(create_vtable_ptr): Return the new field, but don't attach it to\n\tTYPE_FIELDS.\n\t(remove_base_field): Remove.\n\t(remove_base_fields): Remove.\n\t(layout_basetypes): Adjust accordingly.\n\t(layout_class_type): Call layout_field for each field, rather than\n\tjust making a wholesale call to layout_type.\n\nFrom-SVN: r32549", "tree": {"sha": "6288bbb69c1b4f0a4f7681408177ff4202bab2af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6288bbb69c1b4f0a4f7681408177ff4202bab2af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c24fba69a24164f2d99c8a540aca311427dd5b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c24fba69a24164f2d99c8a540aca311427dd5b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c24fba69a24164f2d99c8a540aca311427dd5b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c24fba69a24164f2d99c8a540aca311427dd5b8/comments", "author": null, "committer": null, "parents": [{"sha": "cc9d4a85d7053b55e8006e4f566f43e181bcd1c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9d4a85d7053b55e8006e4f566f43e181bcd1c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc9d4a85d7053b55e8006e4f566f43e181bcd1c1"}], "stats": {"total": 585, "additions": 339, "deletions": 246}, "files": [{"sha": "99a8d4dc2a705b1e1c9aafa3fde283281a42d7d9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c24fba69a24164f2d99c8a540aca311427dd5b8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c24fba69a24164f2d99c8a540aca311427dd5b8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5c24fba69a24164f2d99c8a540aca311427dd5b8", "patch": "@@ -1,3 +1,22 @@\n+2000-03-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h: Tweak documentation.\n+\t* class.c (build_vbase_pointer_fields): Layout the fields, too.\n+\t(avoid_overlap): Remove.\n+\t(get_binfo_offset_as_int): New function.\n+\t(dfs_serach_base_offsets): Likewise.\n+\t(layout_nonempty_base_or_field): Likewise.\n+\t(build_base_field): Layout fields here.  Avoid placing two objects\n+\tof the same type at the same address, under the new ABI.\n+\t(build_base_fields): Adjust accordingly.\n+\t(create_vtable_ptr): Return the new field, but don't attach it to\n+\tTYPE_FIELDS.\n+\t(remove_base_field): Remove.\n+\t(remove_base_fields): Remove.\n+\t(layout_basetypes): Adjust accordingly.\n+\t(layout_class_type): Call layout_field for each field, rather than\n+\tjust making a wholesale call to layout_type.\n+\n 2000-03-14  Jeff Sturm  <jsturm@sigma6.com>\n \n \t* except.c (expand_throw): Fix typo in _Jv_Sjlj_Throw."}, {"sha": "9a66e1e2d5fe613f6a4d9dd31d47a32bbc361d9f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 320, "deletions": 246, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c24fba69a24164f2d99c8a540aca311427dd5b8/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c24fba69a24164f2d99c8a540aca311427dd5b8/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5c24fba69a24164f2d99c8a540aca311427dd5b8", "patch": "@@ -116,17 +116,17 @@ static void check_bitfield_decl PARAMS ((tree));\n static void check_field_decl PARAMS ((tree, tree, int *, int *, int *, int *));\n static void check_field_decls PARAMS ((tree, tree *, int *, int *, int *, \n \t\t\t\t     int *));\n-static int avoid_overlap PARAMS ((tree, tree, int *));\n-static tree build_base_field PARAMS ((tree, tree, int *, int *, unsigned int *));\n-static tree build_base_fields PARAMS ((tree, int *));\n-static tree build_vbase_pointer_fields PARAMS ((tree, int *));\n+static void build_base_field PARAMS ((record_layout_info, tree, int *,\n+\t\t\t\t      unsigned int *, varray_type *));\n+static varray_type build_base_fields PARAMS ((record_layout_info, int *));\n+static tree build_vbase_pointer_fields PARAMS ((record_layout_info, int *));\n static tree build_vtbl_or_vbase_field PARAMS ((tree, tree, tree, tree, tree,\n \t\t\t\t\t       int *));\n static void check_methods PARAMS ((tree));\n static void remove_zero_width_bit_fields PARAMS ((tree));\n static void check_bases PARAMS ((tree, int *, int *, int *));\n static void check_bases_and_members PARAMS ((tree, int *));\n-static void create_vtable_ptr PARAMS ((tree, int *, int *, tree *, tree *));\n+static tree create_vtable_ptr PARAMS ((tree, int *, int *, tree *, tree *));\n static void layout_class_type PARAMS ((tree, int *, int *, tree *, tree *));\n static void fixup_pending_inline PARAMS ((struct pending_inline *));\n static void fixup_inline_methods PARAMS ((tree));\n@@ -135,8 +135,6 @@ static tree dfs_propagate_binfo_offsets PARAMS ((tree, void *));\n static void propagate_binfo_offsets PARAMS ((tree, tree));\n static void layout_basetypes PARAMS ((tree));\n static void layout_virtual_bases PARAMS ((tree));\n-static void remove_base_field PARAMS ((tree, tree, tree *));\n-static void remove_base_fields PARAMS ((tree));\n static tree dfs_set_offset_for_shared_vbases PARAMS ((tree, void *));\n static tree dfs_set_offset_for_unshared_vbases PARAMS ((tree, void *));\n static tree dfs_build_vbase_offset_vtbl_entries PARAMS ((tree, void *));\n@@ -155,6 +153,9 @@ static int make_new_vtable PARAMS ((tree, tree));\n extern void dump_class_hierarchy PARAMS ((tree, int));\n static tree build_vtable PARAMS ((tree, tree, tree));\n static void initialize_vtable PARAMS ((tree, tree));\n+static void layout_nonempty_base_or_field PARAMS ((record_layout_info,\n+\t\t\t\t\t\t   tree, tree,\n+\t\t\t\t\t\t   varray_type));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -175,12 +176,13 @@ int n_inner_fields_searched = 0;\n    FIELD_DECLS.  */\n \n static tree\n-build_vbase_pointer_fields (rec, empty_p)\n-     tree rec;\n+build_vbase_pointer_fields (rli, empty_p)\n+     record_layout_info rli;\n      int *empty_p;\n {\n   /* Chain to hold all the new FIELD_DECLs which point at virtual\n      base classes.  */\n+  tree rec = rli->t;\n   tree vbase_decls = NULL_TREE;\n   tree binfos = TYPE_BINFO_BASETYPES (rec);\n   int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n@@ -235,6 +237,7 @@ build_vbase_pointer_fields (rec, empty_p)\n \t\t\t\t\t    empty_p);\n \t  BINFO_VPTR_FIELD (base_binfo) = decl;\n \t  TREE_CHAIN (decl) = vbase_decls;\n+\t  layout_field (rli, decl);\n \t  vbase_decls = decl;\n \t  *empty_p = 0;\n \n@@ -4091,72 +4094,171 @@ build_vtbl_or_vbase_field (name, assembler_name, type, class_type, fcontext,\n   return field;\n }\n \n-/* If the empty base field in DECL overlaps with a base of the same type in\n-   NEWDECL, which is either another base field or the first data field of\n-   the class, pad the base just before NEWDECL and return 1.  Otherwise,\n-   return 0.  */\n+/* Return the BINFO_OFFSET for BINFO as a native integer, not an\n+   INTEGER_CST.  */\n \n-static int\n-avoid_overlap (decl, newdecl, empty_p)\n-     tree decl, newdecl;\n-     int *empty_p;\n+static unsigned HOST_WIDE_INT\n+get_binfo_offset_as_int (binfo)\n+     tree binfo;\n {\n-  tree field;\n+  tree offset;\n \n-  if (newdecl == NULL_TREE\n-      || ! types_overlap_p (TREE_TYPE (decl), TREE_TYPE (newdecl)))\n-    return 0;\n+  offset = BINFO_OFFSET (binfo);\n+  my_friendly_assert (TREE_CODE (offset) == INTEGER_CST, 20000313);\n+  my_friendly_assert (TREE_INT_CST_HIGH (offset) == 0, 20000313);\n \n-  for (field = decl; TREE_CHAIN (field) && TREE_CHAIN (field) != newdecl;\n-       field = TREE_CHAIN (field))\n-    ;\n+  return (unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (offset);\n+}\n \n-  DECL_SIZE (field) = bitsize_int (1);\n-  DECL_SIZE_UNIT (field) = 0;\n-  /* The containing class cannot be empty; this field takes up space.  */\n-  *empty_p = 0;\n+/* Record the type of BINFO in the slot in DATA (which is really a\n+   `varray_type *') corresponding to the BINFO_OFFSET.  */\n \n-  return 1;\n+static tree\n+dfs_record_base_offsets (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  varray_type *v;\n+  unsigned HOST_WIDE_INT offset = get_binfo_offset_as_int (binfo);\n+\n+  v = (varray_type *) data;\n+  while (VARRAY_SIZE (*v) <= offset)\n+    VARRAY_GROW (*v, 2 * VARRAY_SIZE (*v));\n+  VARRAY_TREE (*v, offset) = tree_cons (NULL_TREE,\n+\t\t\t\t\tBINFO_TYPE (binfo),\n+\t\t\t\t\tVARRAY_TREE (*v, offset));\n+\n+  return NULL_TREE;\n }\n \n-/* Build a FIELD_DECL for the base given by BINFO in T.  If the new\n-   object is non-empty, clear *EMPTY_P.  Otherwise, set *SAW_EMPTY_P.\n-   *BASE_ALIGN is a running maximum of the alignments of any base\n-   class.  */\n+/* Returns non-NULL if there is already an entry in DATA (which is\n+   really a `varray_type') indicating that an object with the same\n+   type of BINFO is already at the BINFO_OFFSET for BINFO.  */\n \n static tree\n-build_base_field (t, binfo, empty_p, saw_empty_p, base_align)\n-     tree t;\n+dfs_search_base_offsets (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  if (is_empty_class (BINFO_TYPE (binfo)))\n+    {\n+      varray_type v = (varray_type) data;\n+      unsigned HOST_WIDE_INT offset;\n+      tree t;\n+\n+      /* Find the offset for this BINFO.  */\n+      offset = get_binfo_offset_as_int (binfo);\n+      /* If we haven't yet encountered any objects at offsets that\n+\t big, then there's no conflict.  */\n+      if (VARRAY_SIZE (v) <= offset)\n+\treturn NULL_TREE;\n+      /* Otherwise, go through the objects already allocated at this\n+\t offset.  */\n+      for (t = VARRAY_TREE (v, offset); t; t = TREE_CHAIN (t))\n+\tif (same_type_p (TREE_VALUE (t), BINFO_TYPE (binfo)))\n+\t  return binfo;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* DECL is a FIELD_DECL corresponding either to a base subobject of a\n+   non-static data member of the type indicated by RLI.  BINFO is the\n+   binfo corresponding to the base subobject, or, if this is a\n+   non-static data-member, a dummy BINFO for the type of the data\n+   member.  V maps offsets to types already located at those offsets.\n+   This function determines the position of the DECL.  */\n+\n+static void\n+layout_nonempty_base_or_field (rli, decl, binfo, v)\n+     record_layout_info rli;\n+     tree decl;\n+     tree binfo;\n+     varray_type v;\n+{\n+  /* Try to place the field.  It may take more than one try if we have\n+     a hard time placing the field without putting two objects of the\n+     same type at the same address.  */\n+  while (1)\n+    {\n+      tree offset;\n+\n+      /* Layout this field.  */\n+      layout_field (rli, decl);\n+      \n+      /* Now that we know where it wil be placed, update its\n+\t BINFO_OFFSET.  */\n+      offset = size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (decl)),\n+\t\t\t       BITS_PER_UNIT));\n+      propagate_binfo_offsets (binfo, offset);\n+ \n+      /* We have to check to see whether or not there is already\n+\t something of the same type at the offset we're about to use.\n+\t For example:\n+\t \n+\t struct S {};\n+\t struct T : public S { int i; };\n+\t struct U : public S, public T {};\n+\t \n+\t Here, we put S at offset zero in U.  Then, we can't put T at\n+\t offset zero -- its S component would be at the same address\n+\t as the S we already allocated.  So, we have to skip ahead.\n+\t Since all data members, including those whose type is an\n+\t empty class, have non-zero size, any overlap can happen only\n+\t with a direct or indirect base-class -- it can't happen with\n+\t a data member.  */\n+      if (flag_new_abi && dfs_walk (binfo,\n+\t\t\t\t    dfs_search_base_offsets,\n+\t\t\t\t    dfs_skip_vbases,\n+\t\t\t\t    v))\n+\t{\n+\t  /* Undo the propogate_binfo_offsets call.  */\n+\t  offset = convert (sizetype,\n+\t\t\t    size_diffop (size_zero_node, offset));\n+\t  propagate_binfo_offsets (binfo, offset);\n+\n+\t  /* Strip off the size allocated to this field.  That puts us\n+\t     at the first place we could have put the field with\n+\t     proper alignment.  */\n+\t  rli->const_size -= TREE_INT_CST_LOW (DECL_SIZE (decl));\n+\t  /* Bump up by th alignment required for the type, without\n+\t     virtual base classes.  */\n+\t  rli->const_size += CLASSTYPE_ALIGN (BINFO_TYPE (binfo));\n+\t}\n+      else\n+\t/* There was no conflict.  We're done laying out this field.  */\n+\tbreak;\n+    }\n+}\n+\n+/* Build a FIELD_DECL for the base given by BINFO in the class\n+   *indicated by RLI.  If the new object is non-empty, clear *EMPTY_P.\n+   *BASE_ALIGN is a running maximum of the alignments of any base\n+   *class.  */\n+\n+static void\n+build_base_field (rli, binfo, empty_p, base_align, v)\n+     record_layout_info rli;\n      tree binfo;\n      int *empty_p;\n-     int *saw_empty_p;\n      unsigned int *base_align;\n+     varray_type *v;\n {\n   tree basetype = BINFO_TYPE (binfo);\n   tree decl;\n \n   if (TYPE_SIZE (basetype) == 0)\n     /* This error is now reported in xref_tag, thus giving better\n        location information.  */\n-    return NULL_TREE;\n+    return;\n   \n   decl = build_lang_decl (FIELD_DECL, NULL_TREE, basetype);\n   DECL_ARTIFICIAL (decl) = 1;\n-  DECL_FIELD_CONTEXT (decl) = t;\n+  DECL_FIELD_CONTEXT (decl) = rli->t;\n   DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n   DECL_SIZE_UNIT (decl) = CLASSTYPE_SIZE_UNIT (basetype);\n   DECL_ALIGN (decl) = CLASSTYPE_ALIGN (basetype);\n   \n-  if (flag_new_abi && integer_zerop (DECL_SIZE (decl)))\n-    {\n-      *saw_empty_p = 1;\n-      return decl;\n-    }\n-\n-  /* The containing class is non-empty because it has a non-empty base\n-     class.  */\n-  *empty_p = 0;\n-      \n   if (! flag_new_abi)\n     {\n       /* Brain damage for backwards compatibility.  For no good\n@@ -4174,39 +4276,84 @@ build_base_field (t, binfo, empty_p, saw_empty_p, base_align)\n \t\t\t (int) *base_align / BITS_PER_UNIT));\n     }\n \n-  return decl;\n+  if (!integer_zerop (DECL_SIZE (decl)))\n+    {\n+      /* The containing class is non-empty because it has a non-empty\n+\t base class.  */\n+      *empty_p = 0;\n+\n+      /* Try to place the field.  It may take more than one try if we\n+\t have a hard time placing the field without putting two\n+\t objects of the same type at the same address.  */\n+      layout_nonempty_base_or_field (rli, decl, binfo, *v);\n+    }\n+  else\n+    {\n+      /* This code assumes that zero-sized classes have one-byte\n+\t alignment.  There might someday be a system where that's not\n+\t true.  */\n+      my_friendly_assert (DECL_ALIGN (basetype) == BITS_PER_UNIT, \n+\t\t\t  20000314);\n+\n+      /* This is an empty base class.  We first try to put it at\n+\t offset zero.  */\n+      if (dfs_walk (binfo, dfs_search_base_offsets, dfs_skip_vbases, *v))\n+\t{\n+\t  /* That didn't work.  Now, we move forward from the next\n+\t     available spot in the class.  */\n+\t  propagate_binfo_offsets (binfo, size_int (rli->const_size));\n+\t  while (1) \n+\t    {\n+\t      if (!dfs_walk (binfo, dfs_search_base_offsets, \n+\t\t\t     dfs_skip_vbases, *v))\n+\t\t/* We finally found a spot where there's no overlap.  */\n+\t\tbreak;\n+\n+\t      /* There's overlap here, too.  Bump along to the next\n+\t\t spot.  */\n+\t      propagate_binfo_offsets (binfo, size_one_node);\n+\t    }\n+\t}\n+    }\n+\n+  /* Check for inaccessible base classes.  If the same base class\n+     appears more than once in the hierarchy, but isn't virtual, then\n+     it's ambiguous.  */\n+  if (get_base_distance (basetype, rli->t, 0, NULL) == -2)\n+    cp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\tbasetype, rli->t);\n+  \n+  /* Record the offsets of BINFO and its base subobjects.  */\n+  dfs_walk (binfo,\n+\t    dfs_record_base_offsets,\n+\t    dfs_skip_vbases,\n+\t    v);\n }\n \n-/* Returns a list of fields to stand in for the base class subobjects\n-   of REC.  These fields are later removed by layout_basetypes.  */\n+/* Layout all of the non-virtual base classes.  Returns a map from\n+   offsets to types present at those offsets.  */\n \n-static tree\n-build_base_fields (rec, empty_p)\n-     tree rec;\n+static varray_type\n+build_base_fields (rli, empty_p)\n+     record_layout_info rli;\n      int *empty_p;\n {\n   /* Chain to hold all the new FIELD_DECLs which stand in for base class\n      subobjects.  */\n-  tree base_decls = NULL_TREE;\n+  tree rec = rli->t;\n   int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n-  tree decl, nextdecl;\n-  int i, saw_empty = 0;\n+  int i;\n+  varray_type v;\n   unsigned int base_align = 0;\n \n+  /* Create the table mapping offsets to empty base classes.  */\n+  VARRAY_TREE_INIT (v, 32, \"v\");\n+\n   /* Under the new ABI, the primary base class is always allocated\n      first.  */\n   if (flag_new_abi && CLASSTYPE_HAS_PRIMARY_BASE_P (rec))\n-    {\n-      tree primary_base;\n-\n-      primary_base = CLASSTYPE_PRIMARY_BINFO (rec);\n-      base_decls = chainon (build_base_field (rec, \n-\t\t\t\t\t      primary_base,\n-\t\t\t\t\t      empty_p,\n-\t\t\t\t\t      &saw_empty,\n-\t\t\t\t\t      &base_align),\n-\t\t\t    base_decls);\n-    }\n+    build_base_field (rli, CLASSTYPE_PRIMARY_BINFO (rec), \n+\t\t      empty_p, &base_align, &v);\n \n   /* Now allocate the rest of the bases.  */\n   for (i = 0; i < n_baseclasses; ++i)\n@@ -4227,44 +4374,10 @@ build_base_fields (rec, empty_p)\n \t  && !BINFO_PRIMARY_MARKED_P (base_binfo))\n \tcontinue;\n \n-      base_decls = chainon (build_base_field (rec, base_binfo,\n-\t\t\t\t\t      empty_p,\n-\t\t\t\t\t      &saw_empty,\n-\t\t\t\t\t      &base_align),\n-\t\t\t    base_decls);\n+      build_base_field (rli, base_binfo, empty_p, &base_align, &v);\n     }\n \n-  /* Reverse the list of fields so we allocate the bases in the proper\n-     order.  */\n-  base_decls = nreverse (base_decls);\n-\n-  /* In the presence of empty base classes, we run the risk of allocating\n-     two objects of the same class on top of one another.  Avoid that.  */\n-  if (flag_new_abi && saw_empty)\n-    for (decl = base_decls; decl; decl = TREE_CHAIN (decl))\n-      {\n-\tif (integer_zerop (DECL_SIZE (decl)))\n-\t  {\n-\t    /* First step through the following bases until we find\n-\t       an overlap or a non-empty base.  */\n-\t    for (nextdecl = TREE_CHAIN (decl); nextdecl;\n-\t\t nextdecl = TREE_CHAIN (nextdecl))\n-\t      if (avoid_overlap (decl, nextdecl, empty_p)\n-\t\t  || ! integer_zerop (DECL_SIZE (nextdecl)))\n-\t\tgoto nextbase;\n-\n-\t    /* If we're still looking, also check against the first\n-\t       field.  */\n-\t    for (nextdecl = TYPE_FIELDS (rec);\n-\t\t nextdecl && TREE_CODE (nextdecl) != FIELD_DECL;\n-\t\t nextdecl = TREE_CHAIN (nextdecl))\n-\t      /* keep looking */;\n-\t    avoid_overlap (decl, nextdecl, empty_p);\n-\t  }\n-      nextbase:;\n-      }\n-\n-  return base_decls;\n+  return v;\n }\n \n /* Go through the TYPE_METHODS of T issuing any appropriate\n@@ -4438,10 +4551,12 @@ check_bases_and_members (t, empty_p)\n }\n \n /* If T needs a pointer to its virtual function table, set TYPE_VFIELD\n-   accordingly, and, if necessary, add the TYPE_VFIELD to the\n-   TYPE_FIELDS list.  */\n+   accordingly.  If a new vfield was created (because T doesn't have a\n+   primary base class), then the newly created field is returned.  It\n+   is not added to the TYPE_FIELDS list; it is the callers\n+   responsibility to do that.  */\n \n-static void\n+static tree\n create_vtable_ptr (t, empty_p, has_virtual_p, \n \t\t   new_virtuals_p, overridden_virtuals_p)\n      tree t;\n@@ -4496,29 +4611,17 @@ create_vtable_ptr (t, empty_p, has_virtual_p,\n \t\t\t\t     t,\n \t\t\t\t     empty_p);\n \n-      /* Add the new field to the list of fields in this class.  */\n-      if (!flag_new_abi)\n-\t/* In the old ABI, the vtable pointer goes at the end of the\n-\t   class.  */\n-\tTYPE_FIELDS (t) = chainon (TYPE_FIELDS (t), TYPE_VFIELD (t));\n-      else\n-\t{\n-\t  /* But in the new ABI, the vtable pointer is the first thing\n-\t     in the class.  */\n-\t  TYPE_FIELDS (t) = chainon (TYPE_VFIELD (t), TYPE_FIELDS (t));\n-\t  /* If there were any baseclasses, they can't possibly be at\n-\t     offset zero any more, because that's where the vtable\n-\t     pointer is.  So, converting to a base class is going to\n-\t     take work.  */\n-\t  if (CLASSTYPE_N_BASECLASSES (t))\n-\t    TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (t) = 1;\n-\t}\n+      if (flag_new_abi && CLASSTYPE_N_BASECLASSES (t))\n+\t/* If there were any baseclasses, they can't possibly be at\n+\t   offset zero any more, because that's where the vtable\n+\t   pointer is.  So, converting to a base class is going to\n+\t   take work.  */\n+\tTYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (t) = 1;\n \n-      /* We can't yet add this new field to the list of all virtual\n-\t function table pointers in this class.  The\n-\t modify_all_vtables function depends on this not being done.\n-\t So, it is done later, in finish_struct_1.  */\n+      return TYPE_VFIELD (t);\n     }\n+\n+  return NULL_TREE;\n }\n \n /* Fixup the inline function given by INFO now that the class is\n@@ -4613,85 +4716,6 @@ propagate_binfo_offsets (binfo, offset)\n \t    NULL);\n }\n \n-/* Remove *FIELD (which corresponds to the base given by BINFO) from\n-   the field list for T.  */\n-\n-static void\n-remove_base_field (t, binfo, field)\n-     tree t;\n-     tree binfo;\n-     tree *field;\n-{\n-  tree basetype = BINFO_TYPE (binfo);\n-  tree offset;\n-\n-  my_friendly_assert (TREE_TYPE (*field) == basetype, 23897);\n-\n-  if (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n-    cp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\tbasetype, t);\n-\n-  offset\n-    = size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (*field)),\n-\t\t      BITS_PER_UNIT));\n-  propagate_binfo_offsets (binfo, offset);\n-\n-  /* Remove this field.  */\n-  *field = TREE_CHAIN (*field);\n-}\n-\n-/* Remove the FIELD_DECLs created for T's base classes in\n-   build_base_fields.  Simultaneously, update BINFO_OFFSET for all the\n-   bases, except for non-primary virtual baseclasses.  */\n-\n-static void\n-remove_base_fields (t)\n-     tree t;\n-{\n-  int i;\n-  tree *field;\n-\n-  /* Now propagate offset information throughout the lattice.\n-     Simultaneously, remove the temporary FIELD_DECLS we created in\n-     build_base_fields to refer to base types.  */\n-  field = &TYPE_FIELDS (t);\n-  if (TYPE_VFIELD (t) == *field)\n-    {\n-      /* If this class did not have a primary base, we create a\n-\t virtual function table pointer.  It will be the first thing\n-\t in the class, under the new ABI.  Skip it; the base fields\n-\t will follow it.  */\n-      my_friendly_assert (flag_new_abi \n-\t\t\t  && !CLASSTYPE_HAS_PRIMARY_BASE_P (t),\n-\t\t\t  19991218);\n-      field = &TREE_CHAIN (*field);\n-    }\n-\n-  /* Under the new ABI, the primary base is always allocated first.  */\n-  if (flag_new_abi && CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n-    remove_base_field (t, CLASSTYPE_PRIMARY_BINFO (t), field);\n-\n-  /* Now remove the rest of the bases.  */\n-  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); i++)\n-    {\n-      tree binfo;\n-\n-      /* Under the new ABI, we've already removed the primary base\n-\t above.  */\n-      if (flag_new_abi && i == CLASSTYPE_VFIELD_PARENT (t))\n-\tcontinue;\n-\n-      binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n-\n-      /* We treat a primary virtual base class just like an ordinary base\n-\t class.  But, non-primary virtual bases are laid out later.  */\n-      if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n-\tcontinue;\n-\n-      remove_base_field (t, binfo, field);\n-    }\n-}\n-\n /* Called via dfs_walk from layout_virtual bases.  */\n \n static tree\n@@ -4819,17 +4843,15 @@ layout_basetypes (rec)\n {\n   tree vbase_types;\n \n+  if (CLASSTYPE_N_BASECLASSES (rec) == 0)\n+    return;\n+\n #ifdef STRUCTURE_SIZE_BOUNDARY\n   /* Packed structures don't need to have minimum size.  */\n   if (! TYPE_PACKED (rec))\n     TYPE_ALIGN (rec) = MAX (TYPE_ALIGN (rec), STRUCTURE_SIZE_BOUNDARY);\n #endif\n \n-  /* Remove the FIELD_DECLs we created for baseclasses in\n-     build_base_fields.  Simultaneously, update the BINFO_OFFSETs for\n-     everything in the hierarcy except non-primary virtual bases.  */\n-  remove_base_fields (rec);\n-\n   /* Allocate the virtual base classes.  */\n   layout_virtual_bases (rec);\n \n@@ -4861,64 +4883,117 @@ layout_class_type (t, empty_p, has_virtual_p,\n      tree *new_virtuals_p;\n      tree *overridden_virtuals_p;\n {\n-  tree padding = NULL_TREE;\n+  tree non_static_data_members;\n+  tree field;\n+  tree vptr;\n+  record_layout_info rli;\n+  varray_type v;\n+  int i;\n+\n+  /* Keep track of the first non-static data member.  */\n+  non_static_data_members = TYPE_FIELDS (t);\n+\n+  /* Initialize the layout information.  */\n+  rli = new_record_layout_info (t);\n \n   /* If possible, we reuse the virtual function table pointer from one\n      of our base classes.  */\n   determine_primary_base (t, has_virtual_p);\n \n+  /* Create a pointer to our virtual function table.  */\n+  vptr = create_vtable_ptr (t, empty_p, has_virtual_p,\n+\t\t\t    new_virtuals_p, overridden_virtuals_p);\n+\n+  /* Under the new ABI, the vptr is always the first thing in the\n+     class.  */\n+  if (flag_new_abi && vptr)\n+    {\n+      TYPE_FIELDS (t) = chainon (vptr, TYPE_FIELDS (t));\n+      layout_field (rli, vptr);\n+    }\n+\n   /* Add pointers to all of our virtual base-classes.  */\n-  TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (t, empty_p),\n+  TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (rli, empty_p),\n \t\t\t     TYPE_FIELDS (t));\n   /* Build FIELD_DECLs for all of the non-virtual base-types.  */\n-  TYPE_FIELDS (t) = chainon (build_base_fields (t, empty_p), \n-\t\t\t     TYPE_FIELDS (t));\n-\n-  /* Create a pointer to our virtual function table.  */\n-  create_vtable_ptr (t, empty_p, has_virtual_p,\n-\t\t     new_virtuals_p, overridden_virtuals_p);\n+  v = build_base_fields (rli, empty_p);\n \n   /* CLASSTYPE_INLINE_FRIENDS is really TYPE_NONCOPIED_PARTS.  Thus,\n      we have to save this before we start modifying\n      TYPE_NONCOPIED_PARTS.  */\n   fixup_inline_methods (t);\n \n+  /* Layout the non-static data members.  */\n+  for (field = non_static_data_members; \n+       field; \n+       field = TREE_CHAIN (field))\n+    {\n+      tree binfo;\n+\n+      /* We still pass things that aren't non-static data members to\n+\t the back-end, in case it wants to do something with them.  */\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\t{\n+\t  layout_field (rli, field);\n+\t  continue;\n+\t}\n+\n+      /* Create a dummy BINFO corresponding to this field.  */\n+      binfo = make_binfo (size_zero_node, TREE_TYPE (field),\n+\t\t\t  NULL_TREE, NULL_TREE);\n+      unshare_base_binfos (binfo);\n+      layout_nonempty_base_or_field (rli, field, binfo, v);\n+    }\n+\n+  /* Clean up.  */\n+  VARRAY_FREE (v);\n+  \n+  /* It might be the case that we grew the class to allocate a\n+     zero-sized base class.  That won't be reflected in RLI, yet,\n+     because we are willing to overlay multiple bases at the same\n+     offset.  However, now we need to make sure that RLI is big enough\n+     to reflect the entire class.  */\n+  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n+    {\n+      tree base_binfo;\n+      unsigned HOST_WIDE_INT offset;\n+\n+      base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n+      offset = get_binfo_offset_as_int (base_binfo);\n+      if (offset * BITS_PER_UNIT > rli->const_size)\n+\trli->const_size = (offset + 1) * BITS_PER_UNIT;\n+    }\n+\n   /* We make all structures have at least one element, so that they\n-     have non-zero size.  The field that we add here is fake, in the\n-     sense that, for example, we don't want people to be able to\n-     initialize it later.  So, we add it just long enough to let the\n-     back-end lay out the type, and then remove it.  In the new ABI,\n-     the class may be empty even if it has basetypes.  Therefore, we\n-     add the fake field at the end of the fields list; if there are\n-     already FIELD_DECLs on the list, their offsets will not be\n-     disturbed.  */\n+     have non-zero size.  In the new ABI, the class may be empty even\n+     if it has basetypes.  Therefore, we add the fake field after all\n+     the other fields; if there are already FIELD_DECLs on the list,\n+     their offsets will not be disturbed.  */\n   if (*empty_p)\n     {\n+      tree padding;\n+\n       padding = build_lang_decl (FIELD_DECL, NULL_TREE, char_type_node);\n-      TYPE_FIELDS (t) = chainon (TYPE_FIELDS (t), padding);\n+      layout_field (rli, padding);\n       TYPE_NONCOPIED_PARTS (t) \n \t= tree_cons (NULL_TREE, padding, TYPE_NONCOPIED_PARTS (t));\n       TREE_STATIC (TYPE_NONCOPIED_PARTS (t)) = 1;\n     }\n \n+  /* Under the old ABI, the vptr comes at the very end of the \n+     class.   */\n+  if (!flag_new_abi && vptr)\n+    {\n+      layout_field (rli, vptr);\n+      TYPE_FIELDS (t) = chainon (TYPE_FIELDS (t), vptr);\n+    }\n+  \n   /* Let the back-end lay out the type. Note that at this point we\n      have only included non-virtual base-classes; we will lay out the\n      virtual base classes later.  So, the TYPE_SIZE/TYPE_ALIGN after\n      this call are not necessarily correct; they are just the size and\n      alignment when no virtual base clases are used.  */\n-  layout_type (t);\n-\n-  /* If we added an extra field to make this class non-empty, remove\n-     it now.  */\n-  if (*empty_p)\n-    {\n-      tree *declp;\n-\n-      declp = &TYPE_FIELDS (t);\n-      while (*declp != padding)\n-\tdeclp = &TREE_CHAIN (*declp);\n-      *declp = TREE_CHAIN (*declp);\n-    }\n+  finish_record_layout (rli);\n \n   /* Delete all zero-width bit-fields from the list of fields.  Now\n      that the type is laid out they are no longer important.  */\n@@ -4952,10 +5027,9 @@ layout_class_type (t, empty_p, has_virtual_p,\n \n   /* Now fix up any virtual base class types that we left lying\n      around.  We must get these done before we try to lay out the\n-     virtual function table.  */\n-  if (CLASSTYPE_N_BASECLASSES (t))\n-    /* layout_basetypes will remove the base subobject fields.  */\n-    layout_basetypes (t);\n+     virtual function table.  As a side-effect, this will remove the\n+     base subobject fields.  */\n+  layout_basetypes (t);\n }\n      \n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration"}]}