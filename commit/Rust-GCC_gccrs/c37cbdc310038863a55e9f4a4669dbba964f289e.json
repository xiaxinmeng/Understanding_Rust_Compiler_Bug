{"sha": "c37cbdc310038863a55e9f4a4669dbba964f289e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM3Y2JkYzMxMDAzODg2M2E1NWU5ZjRhNDY2OWRiYmE5NjRmMjg5ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-30T14:56:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-30T14:56:45Z"}, "message": "[multiple changes]\n\n2011-08-30  Jose Ruiz  <ruiz@adacore.com>\n\n\t* s-taskin.ads (Common_ATCB): Add field domain which contains the\n\tdispatching domain to which the task belongs.\n\t* s-taskin.adb (Initialize): Create the default system dispatching\n\tdomain and make the environment task part of it.\n\t* s-mudido.ads: Add this new spec for standard Ada 2012 package\n\tAda.Multiprocessors.Dispatching_Domains.\n\t* s-mudido.adb: Add this new body for targets not supporting\n\tdispatching domains.\n\t* s-mudido-affinity.adb: Add this new body for targets supporting\n\tdispatching domains setting the affinity to a CPU set.\n\t* bindgen.adb (Dispatching_Domain_Used, Check_Dispatching_Domains_Used,\n\tGen_Adainit): When package System.Multiprocessors.Dispatching_Domains\n\tis used we call the procedure to signal that when we are about to call\n\tthe main subprogram no new dispatching domain can be created.\n\t(Check_File_In_Partition): Factor out the common functionality used by\n\tCheck_System_Restrictions_Used and Check_Dispatching_Domains_Used.\n\t* s-tassta.adb (Create_Task): Tasks inherit the dispatching domain of\n\ttheir activators.\n\t* s-taprop.ads (Set_Task_Affinity): Add this new procedure to set task\n\taffinities.\n\t* s-taprop-dummy.adb, s-taprop-hpux-dce.adb, s-taprop-irix.adb,\n\ts-taprop-posix.adb, s-taprop-tru64.adb, s-taprop-vms.adb\n\t(Set_Task_Affinity): Dummy null body for these targets not supporting\n\ttask affinities.\n\ts-taprop-linux.adb, s-taprop-mingw.adb, s-taprop-solaris.adb,\n\ts-taprop-vxworks.adb (Create_Task, Enter_Task, Initialize): Handle\n\tdispatching domains and set the affinity of the environment task.\n\t(Set_Task_Affinity): Procedure that uses the underlying CPU set\n\tfunctionality to handle dispatching domains, pragma CPU and Task_Info.\n\ts-winext.ads (SetThreadAffinityMask): Import this function needed to\n\tset CPU masks.\n\t* s-osinte-solaris.ads (psetit_t, pset_create, pset_assign, pset_bind):\n\tImport the functionality to handle CPU set affinities.\n\t* affinity.c: New file.\n\t* s-osinte-vxworks.ads, s-vxwext.ads, s-vxwext-kernel.ads,\n\ts-vxwext-rtp.ads (taskMaskAffinitySet): Add this new spec for setting\n\taffinity masks.\n\t* s-vxwext.adb, s-vxwext-kernel.adb, s-vxwext-rtp.adb \n\t(taskMaskAffinitySet): Body returning an error indicating that task\n\taffinities are not supported.\n\tMakefile.rtl: Indicate that s-mudido is part of libgnarl.\n\t* gcc-interface/Makefile.in (LIBGNAT_TARGET_PAIRS for VxWorks SMP,\n\tSolaris, Windows, and {x86,PowerPC, ia64,x86_64} Linux): Use the\n\ts-mudido-affinity.adb body which supports task affinities.\n\n2011-08-30  Thomas quinot  <quinot@adacore.com>\n\n\t* sem_ch13.adb: Minor reformatting.\n\n2011-08-30  Vincent Celier  <celier@adacore.com>\n\n\t* vms_conv.adb (Process_Argument): When the qualifier\n\t/UNCHECKED_SHARED_LIB_IMPORTS is for GNAT COMPILE, do not put the\n\tcorresponding switch --unchecked-shared-lib-imports after -cargs, as it\n\tis for gnatmake, not for the compiler.\n\n2011-08-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Quantified_Expression): Analyze iterator\n\tspecification and condition only in Semantics_Only mode. Otherwise the\n\tanalysis is done after expression has been rewritten as loop.\n\t* sem_ch5.adb (Analyze_Iterator_Specification): Always generate a\n\ttemporary for the iterator name (the domain of iteration) because it\n\tmay need finalization actions and these must be generated outside of\n\tthe loop.\n\t* sem_res.adb (Resolve_Quantified_Expression): Resolve only in\n\tSemantic_Only mode.\n\t* exp_ch4.adb (Expand_Quantified_Expression): Analyze and resolve once\n\trewritten as loop.\n\t* exp_ch5.adb (Expand_Iterator_Loop): Code clean-up, now that the\n\titerator is always an expression.\n\n2011-08-30  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch4.adb (P_Unparen_Cond_Case_Quant_Expression): New function\n\t(P_Expression_If_OK): New spec checks parens\n\t(P_Expression_Or_Range_Attribute_If_OK): New spec checks parens\n\t* par.adb (P_Expression_If_OK): New spec checks parens\n\t(P_Expression_Or_Range_Attribute_If_OK): New spec checks parens\n\nFrom-SVN: r178321", "tree": {"sha": "b835d16538f8d08c37359d2bcd6b1863c3b2195e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b835d16538f8d08c37359d2bcd6b1863c3b2195e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c37cbdc310038863a55e9f4a4669dbba964f289e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37cbdc310038863a55e9f4a4669dbba964f289e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c37cbdc310038863a55e9f4a4669dbba964f289e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37cbdc310038863a55e9f4a4669dbba964f289e/comments", "author": null, "committer": null, "parents": [{"sha": "f8dd28d62d1d014c1599b1a345d7bab0ede255ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8dd28d62d1d014c1599b1a345d7bab0ede255ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8dd28d62d1d014c1599b1a345d7bab0ede255ab"}], "stats": {"total": 1647, "additions": 1431, "deletions": 216}, "files": [{"sha": "adeb6faf260403e5da06b68db9bd80907a49162a", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -1,5 +1,5 @@\n # Makefile.rtl for GNU Ada Compiler (GNAT).\n-#   Copyright (C) 2003-2010, Free Software Foundation, Inc.\n+#   Copyright (C) 2003-2011, Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -48,6 +48,7 @@ GNATRTL_TASKING_OBJS= \\\n   s-inmaop$(objext) \\\n   s-interr$(objext) \\\n   s-intman$(objext) \\\n+  s-mudido$(objext) \\\n   s-oscons$(objext) \\\n   s-osinte$(objext) \\\n   s-proinf$(objext) \\"}, {"sha": "ffa4e688a04394ceeb6b07cb617047db5799d7e1", "filename": "gcc/ada/affinity.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faffinity.c?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -0,0 +1,63 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             A F F I N I T Y                              *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *            Copyright (C) 2005-2011, Free Software Foundation, Inc.       *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n+ * Boston, MA 02110-1301, USA.                                              *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* VxWorks SMP CPU affinity */\n+\n+#include \"taskLib.h\"\n+#include \"cpuset.h\"\n+\n+extern int __gnat_set_affinity (int tid, unsigned cpu);\n+extern int __gnat_set_affinity_mask (int tid, unsigned mask);\n+\n+int\n+ __gnat_set_affinity (int tid, unsigned cpu)\n+{\n+  cpuset_t cpuset;\n+\n+  CPUSET_ZERO(cpuset);\n+  CPUSET_SET(cpuset, cpu);\n+  return taskCpuAffinitySet (tid, cpuset);\n+}\n+\n+int\n+__gnat_set_affinity_mask (int tid, unsigned mask)\n+{\n+  cpuset_t cpuset;\n+\n+  CPUSET_ZERO(cpuset);\n+\n+  for (index = 0; index < sizeof (unsigned) * 8; index++)\n+    if (mask & (1 << index))\n+      CPUSET_SET(cpuset, index);\n+\n+  return taskCpuAffinitySet (tid, cpuset);\n+}"}, {"sha": "618e9cec18ce54a54a5f68e5bbccef00f1c7e118", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -71,6 +71,13 @@ package body Bindgen is\n    --  to do this unconditionally, since it drags in the System.Restrictions\n    --  unit unconditionally, which is unpleasand, especially for ZFP etc.)\n \n+   Dispatching_Domains_Used : Boolean;\n+   --  Flag indicating whether multiprocessor dispatching domains are used in\n+   --  the closure of the partition. This is set by\n+   --  Check_Dispatching_Domains_Used, and is used to call the routine to\n+   --  disallow the creation of new dispatching domains just before calling\n+   --  the main procedure from the environment task.\n+\n    Lib_Final_Built : Boolean := False;\n    --  Flag indicating whether the finalize_library rountine has been built\n \n@@ -233,10 +240,19 @@ package body Bindgen is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Check_File_In_Partition (File_Name : String; Flag : out Boolean);\n+   --  If the file indicated by File_Name is in the partition the Flag is set\n+   --  to True, False otherwise.\n+\n    procedure Check_System_Restrictions_Used;\n    --  Sets flag System_Restrictions_Used (Set to True if and only if the unit\n    --  System.Restrictions is present in the partition, otherwise False).\n \n+   procedure Check_Dispatching_Domains_Used;\n+   --  Sets flag Dispatching_Domains_Used to True when using the unit\n+   --  System.Multiprocessors.Dispatching_Domains is present in the partition,\n+   --  otherwise set to False.\n+\n    procedure Gen_Adainit;\n    --  Generates the Adainit procedure\n \n@@ -372,19 +388,38 @@ package body Bindgen is\n    --  contents of statement buffer up to Last, and reset Last to 0\n \n    ------------------------------------\n-   -- Check_System_Restrictions_Used --\n+   -- Check_Dispatching_Domains_Used --\n    ------------------------------------\n \n-   procedure Check_System_Restrictions_Used is\n+   procedure Check_Dispatching_Domains_Used is\n+   begin\n+      Check_File_In_Partition (\"s-mudido.ads\", Dispatching_Domains_Used);\n+   end Check_Dispatching_Domains_Used;\n+\n+   -----------------------------\n+   -- Check_File_In_Partition --\n+   -----------------------------\n+\n+   procedure Check_File_In_Partition\n+     (File_Name : String; Flag : out Boolean) is\n    begin\n       for J in Units.First .. Units.Last loop\n-         if Get_Name_String (Units.Table (J).Sfile) = \"s-restri.ads\" then\n-            System_Restrictions_Used := True;\n+         if Get_Name_String (Units.Table (J).Sfile) = File_Name then\n+            Flag := True;\n             return;\n          end if;\n       end loop;\n \n-      System_Restrictions_Used := False;\n+      Flag := False;\n+   end Check_File_In_Partition;\n+\n+   ------------------------------------\n+   -- Check_System_Restrictions_Used --\n+   ------------------------------------\n+\n+   procedure Check_System_Restrictions_Used is\n+   begin\n+      Check_File_In_Partition (\"s-restri.ads\", System_Restrictions_Used);\n    end Check_System_Restrictions_Used;\n \n    ------------------\n@@ -664,6 +699,16 @@ package body Bindgen is\n                  & Get_Main_Unit_Name (Name_Buffer (1 .. Name_Len)) & \"\"\");\");\n          end if;\n \n+         --  When dispatching domains are used then we need to signal it\n+         --  before calling the main procedure.\n+\n+         if Dispatching_Domains_Used then\n+            WBI (\"      procedure Freeze_Dispatching_Domains;\");\n+            WBI (\"      pragma Import\");\n+            WBI (\"        (Ada, Freeze_Dispatching_Domains, \" &\n+                 \"\"\"__gnat_freeze_dispatching_domains\"\");\");\n+         end if;\n+\n          WBI (\"   begin\");\n          WBI (\"      if Is_Elaborated then\");\n          WBI (\"         return;\");\n@@ -900,6 +945,12 @@ package body Bindgen is\n \n       Gen_Elab_Calls;\n \n+      --  From this point, no new dispatching domain can be created.\n+\n+      if Dispatching_Domains_Used then\n+         WBI (\"      Freeze_Dispatching_Domains;\");\n+      end if;\n+\n       --  Case of main program is CIL function or procedure\n \n       if VM_Target = CLI_Target\n@@ -2037,6 +2088,7 @@ package body Bindgen is\n       --  Generate output file in appropriate language\n \n       Check_System_Restrictions_Used;\n+      Check_Dispatching_Domains_Used;\n \n       Gen_Output_File_Ada (Filename);\n    end Gen_Output_File;"}, {"sha": "5e8bf7d0a78e2f1467069a92ca1b96c3c79cd5e9", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -7764,11 +7764,6 @@ package body Exp_Ch4 is\n           Statements       => New_List (Test),\n           End_Label        => Empty));\n \n-      --  The components of the scheme have already been analyzed, and the loop\n-      --  parameter declaration has been processed.\n-\n-      Set_Analyzed (Iteration_Scheme (Last (Actions)));\n-\n       Rewrite (N,\n         Make_Expression_With_Actions (Loc,\n           Expression => New_Occurrence_Of (Tnn, Loc),"}, {"sha": "47af37ff649e36bc8604ff9fb0ab34225f0c93c9", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -2956,14 +2956,17 @@ package body Exp_Ch5 is\n       --  Processing for containers\n \n       else\n-         --  For an iterator of the form \"Of\" then name is some expression,\n-         --  which is transformed into a call to the default iterator.\n+         --  For an \"of\" iterator the name is a container expression, which\n+         --  is transformed into a call to the default iterator.\n \n-         --  For an iterator of the form \"in\" then name is a function call\n-         --  that delivers an iterator.\n+         --  For an iterator of the form \"in\" the name is a function call\n+         --  that delivers an iterator type.\n+\n+         --  In both cases, analysis of the iterator has introduced an object\n+         --  declaration to capture the domain, so that Container is an entity.\n \n          --  The for loop is expanded into a while loop which uses a container\n-         --  specific cursor to examine each element.\n+         --  specific cursor to desgnate each element.\n \n          --    Iter : Iterator_Type := Container.Iterate;\n          --    Cursor : Cursor_type := First (Iter);\n@@ -2997,15 +3000,20 @@ package body Exp_Ch5 is\n             --  The type of the iterator is the return type of the Iterate\n             --  function used. For the \"of\" form this is the default iterator\n             --  for the type, otherwise it is the type of the explicit\n-            --  function used in the loop.\n+            --  function used in the iterator specification. The most common\n+            --  case will be an Iterate function in the container package.\n \n-            Iter_Type := Etype (Name (I_Spec));\n+            --  The primitive operations of the container type may not be\n+            --  use-visible, so we introduce the name of the enclosing package\n+            --  in the declarations below. The Iterator type is declared in a\n+            --  an instance within the container package itself.\n \n-            if Is_Entity_Name (Container) then\n-               Pack := Scope (Etype (Container));\n+            Iter_Type := Etype (Name (I_Spec));\n \n+            if Is_Iterator (Iter_Type) then\n+               Pack := Scope (Scope (Etype (Container)));\n             else\n-               Pack := Scope (Entity (Name (Container)));\n+               Pack := Scope (Etype (Container));\n             end if;\n \n             --  The \"of\" case uses an internally generated cursor whose type\n@@ -3047,8 +3055,6 @@ package body Exp_Ch5 is\n                         Container_Arg := New_Copy_Tree (Container);\n \n                      else\n-                        Pack := Scope (Default_Iter);\n-\n                         Container_Arg :=\n                           Make_Type_Conversion (Loc,\n                             Subtype_Mark =>\n@@ -3195,9 +3201,12 @@ package body Exp_Ch5 is\n                 End_Label  => Empty);\n \n             --  Create the declarations for Iterator and cursor and insert then\n-            --  before the source loop. Generate:\n+            --  before the source loop. Given that the domain of iteration is\n+            --  already an entity, the iterator is just a renaming of that\n+            --  entity. Possible optimization ???\n+            --  Generate:\n \n-            --    I : Iterator_Type := Iterate (Container);\n+            --    I : Iterator_Type renames Container;\n             --    C : Pack.Cursor_Type := Container.[First | Last];\n \n             declare\n@@ -3206,11 +3215,10 @@ package body Exp_Ch5 is\n \n             begin\n                Decl1 :=\n-                 Make_Object_Declaration (Loc,\n+                 Make_Object_Renaming_Declaration (Loc,\n                    Defining_Identifier => Iterator,\n-                   Object_Definition   => New_Occurrence_Of (Iter_Type, Loc),\n-                   Expression          => Relocate_Node (Name (I_Spec)));\n-               Set_Assignment_OK (Decl1);\n+                   Subtype_Mark  => New_Occurrence_Of (Iter_Type, Loc),\n+                   Name          => Relocate_Node (Name (I_Spec)));\n \n                Decl2 :=\n                  Make_Object_Declaration (Loc,\n@@ -3225,8 +3233,7 @@ package body Exp_Ch5 is\n \n                Set_Assignment_OK (Decl2);\n \n-               Insert_Actions (N,\n-                 New_List (Decl1, Decl2));\n+               Insert_Actions (N, New_List (Decl1, Decl2));\n             end;\n \n             --  The Iterator is not modified in the source, but of course will"}, {"sha": "85b4024df8cfe60315fdcb236048d20452893b26", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 73, "deletions": 17, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -91,6 +91,12 @@ package body Ch4 is\n    --  prefix. The current token is known to be an apostrophe and the\n    --  following token is known to be RANGE.\n \n+   function P_Unparen_Cond_Case_Quant_Expression return Node_Id;\n+   --  This function is called with Token pointing to IF, CASE, or FOR, in a\n+   --  context that allows a case, conditional, or quantified expression if\n+   --  it is surrounded by parentheses. If not surrounded by parentheses, the\n+   --  expression is still returned, but an error message is issued.\n+\n    -------------------------\n    -- Bad_Range_Attribute --\n    -------------------------\n@@ -470,8 +476,8 @@ package body Ch4 is\n                end if;\n             end if;\n \n-            --  We come here with an OK attribute scanned, and the\n-            --  corresponding Attribute identifier node stored in Ident_Node.\n+            --  We come here with an OK attribute scanned, and corresponding\n+            --  Attribute identifier node stored in Ident_Node.\n \n             Prefix_Node := Name_Node;\n             Name_Node := New_Node (N_Attribute_Reference, Prev_Token_Ptr);\n@@ -658,7 +664,7 @@ package body Ch4 is\n             Error_Msg\n               (\"expect identifier in parameter association\",\n                 Sloc (Expr_Node));\n-            Scan;  --   past arrow\n+            Scan;  -- past arrow\n \n          elsif not Comma_Present then\n             T_Right_Paren;\n@@ -1640,18 +1646,18 @@ package body Ch4 is\n \n    --  This function is identical to the normal P_Expression, except that it\n    --  also permits the appearance of a case, conditional, or quantified\n-   --  expression without the usual surrounding parentheses.\n+   --  expression if the call immediately follows a left paren, and followed\n+   --  by a right parenthesis. These forms are allowed if these conditions\n+   --  are not met, but an error message will be issued.\n \n    function P_Expression_If_OK return Node_Id is\n    begin\n-      if Token = Tok_Case then\n-         return P_Case_Expression;\n+      --  Case of conditional, case or quantified expression\n \n-      elsif Token = Tok_If then\n-         return P_Conditional_Expression;\n+      if Token = Tok_Case or else Token = Tok_If or else Token = Tok_For then\n+         return P_Unparen_Cond_Case_Quant_Expression;\n \n-      elsif Token = Tok_For then\n-         return P_Quantified_Expression;\n+      --  Normal case, not case/conditional/quantified expression\n \n       else\n          return P_Expression;\n@@ -1749,18 +1755,18 @@ package body Ch4 is\n    end P_Expression_Or_Range_Attribute;\n \n    --  Version that allows a non-parenthesized case, conditional, or quantified\n-   --  expression\n+   --  expression if the call immediately follows a left paren, and followed\n+   --  by a right parenthesis. These forms are allowed if these conditions\n+   --  are not met, but an error message will be issued.\n \n    function P_Expression_Or_Range_Attribute_If_OK return Node_Id is\n    begin\n-      if Token = Tok_Case then\n-         return P_Case_Expression;\n+      --  Case of conditional, case or quantified expression\n \n-      elsif Token = Tok_If then\n-         return P_Conditional_Expression;\n+      if Token = Tok_Case or else Token = Tok_If or else Token = Tok_For then\n+         return P_Unparen_Cond_Case_Quant_Expression;\n \n-      elsif Token = Tok_For then\n-         return P_Quantified_Expression;\n+      --  Normal case, not one of the above expression types\n \n       else\n          return P_Expression_Or_Range_Attribute;\n@@ -3059,4 +3065,54 @@ package body Ch4 is\n       end if;\n    end P_Membership_Test;\n \n+   ------------------------------------------\n+   -- P_Unparen_Cond_Case_Quant_Expression --\n+   ------------------------------------------\n+\n+   function P_Unparen_Cond_Case_Quant_Expression return Node_Id is\n+      Lparen : constant Boolean := Prev_Token = Tok_Left_Paren;\n+      Result : Node_Id;\n+\n+   begin\n+      --  Case expression\n+\n+      if Token = Tok_Case then\n+         Result := P_Case_Expression;\n+\n+         if not (Lparen and then Token = Tok_Right_Paren) then\n+            Error_Msg_N\n+              (\"case expression must be parenthesized!\", Result);\n+         end if;\n+\n+      --  Conditional expression\n+\n+      elsif Token = Tok_If then\n+         Result := P_Conditional_Expression;\n+\n+         if not (Lparen and then Token = Tok_Right_Paren) then\n+            Error_Msg_N\n+              (\"conditional expression must be parenthesized!\", Result);\n+         end if;\n+\n+      --  Quantified expression\n+\n+      elsif Token = Tok_For then\n+         Result := P_Quantified_Expression;\n+\n+         if not (Lparen and then Token = Tok_Right_Paren) then\n+            Error_Msg_N\n+              (\"quantified expression must be parenthesized!\", Result);\n+         end if;\n+\n+      --  No other possibility should exist (caller was supposed to check)\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+\n+      --  Return expression (possibly after having given message)\n+\n+      return Result;\n+   end P_Unparen_Cond_Case_Quant_Expression;\n+\n end Ch4;"}, {"sha": "0dbb7d988a76713b86b5212b59a77f58fde3fe5b", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -691,8 +691,11 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  semicolon or comma, but does not consume this terminating token.\n \n       function P_Expression_If_OK return Node_Id;\n-      --  Scans out an expression in a context where a conditional expression\n-      --  is permitted to appear without surrounding parentheses.\n+      --  Scans out an expression allowing an unparenthesized case expression,\n+      --  conditional expression, or quantified expression to appear without\n+      --  enclosing parentheses. However, if such an expression is not preceded\n+      --  by a left paren, and followed by a right paren, an error message will\n+      --  be output noting that parenthesization is required.\n \n       function P_Expression_No_Right_Paren return Node_Id;\n       --  Scans out an expression in contexts where the expression cannot be\n@@ -702,6 +705,9 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       function P_Expression_Or_Range_Attribute_If_OK return Node_Id;\n       --  Scans out an expression or range attribute where a conditional\n       --  expression is permitted to appear without surrounding parentheses.\n+      --  However, if such an expression is not preceded by a left paren, and\n+      --  followed by a right paren, an error message will be output noting\n+      --  that parenthesization is required.\n \n       function P_Qualified_Expression (Subtype_Mark : Node_Id) return Node_Id;\n       --  This routine scans out a qualified expression when the caller has"}, {"sha": "1c1d865eab7a4cf2dd202a05d6334e1a6dbeb3f0", "filename": "gcc/ada/s-mudido-affinity.adb", "status": "added", "additions": 396, "deletions": 0, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-mudido-affinity.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-mudido-affinity.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mudido-affinity.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -0,0 +1,396 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                SYSTEM.MULTIPROCESSORS.DISPATCHING_DOMAINS                --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Body used on targets where the operating system supports setting task\n+--  affinities.\n+\n+with System.Tasking.Initialization;\n+with System.Task_Primitives.Operations; use System.Task_Primitives.Operations;\n+\n+with Ada.Unchecked_Conversion;\n+\n+package body System.Multiprocessors.Dispatching_Domains is\n+\n+   package ST renames System.Tasking;\n+\n+   ----------------\n+   -- Local data --\n+   ----------------\n+\n+   Dispatching_Domain_Tasks :\n+     array (CPU'First .. Number_Of_CPUs) of Natural := (others => 0);\n+   --  We need to store whether there are tasks allocated to concrete\n+   --  processors in the default system dispatching domain because we need to\n+   --  check it before creating a new dispatching domain.\n+   --  ??? Tasks allocated with pragma CPU are not taken into account here.\n+\n+   Dispatching_Domains_Frozen : Boolean := False;\n+   --  True when the main procedure has been called. Hence, no new dispatching\n+   --  domains can be created when this flag is True.\n+\n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   function Convert_Ids is new\n+     Ada.Unchecked_Conversion (Ada.Task_Identification.Task_Id, ST.Task_Id);\n+\n+   procedure Unchecked_Set_Affinity\n+     (Domain : ST.Dispatching_Domain_Access;\n+      CPU    : CPU_Range;\n+      T      : ST.Task_Id);\n+   --  Internal procedure to move a task to a target domain and CPU. No checks\n+   --  are performed about the validity of the domain and the CPU because they\n+   --  are done by the callers of this procedure (either Assign_Task or\n+   --  Set_CPU).\n+\n+   procedure Freeze_Dispatching_Domains;\n+   pragma Export\n+     (Ada, Freeze_Dispatching_Domains, \"__gnat_freeze_dispatching_domains\");\n+   --  Signal the time when no new dispatching domains can be created. It\n+   --  should be called before the environment task calls the main procedure\n+   --  (and after the elaboration code), so the binder-generated file needs to\n+   --  import and call this procedure.\n+\n+   -----------------\n+   -- Assign_Task --\n+   -----------------\n+\n+   procedure Assign_Task\n+     (Domain : in out Dispatching_Domain;\n+      CPU    : CPU_Range := Not_A_Specific_CPU;\n+      T      : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task)\n+   is\n+      Target : constant ST.Task_Id := Convert_Ids (T);\n+\n+      use type System.Tasking.Dispatching_Domain_Access;\n+\n+   begin\n+      --  The exception Dispatching_Domain_Error is propagated if T is already\n+      --  assigned to a Dispatching_Domain other than\n+      --  System_Dispatching_Domain, or if CPU is not one of the processors of\n+      --  Domain (and is not Not_A_Specific_CPU).\n+\n+      if Target.Common.Domain /= null and then\n+        Dispatching_Domain (Target.Common.Domain) /= System_Dispatching_Domain\n+      then\n+         raise Dispatching_Domain_Error with\n+           \"task already in user-defined dispatching domain\";\n+\n+      elsif CPU /= Not_A_Specific_CPU and then CPU not in Domain'Range then\n+         raise Dispatching_Domain_Error with\n+           \"processor does not belong to dispatching domain\";\n+      end if;\n+\n+      --  Assigning a task to System_Dispatching_Domain that is already\n+      --  assigned to that domain has no effect.\n+\n+      if Domain = System_Dispatching_Domain then\n+         return;\n+\n+      else\n+         --  Set the task affinity once we know it is possible\n+\n+         Unchecked_Set_Affinity\n+           (ST.Dispatching_Domain_Access (Domain), CPU, Target);\n+      end if;\n+   end Assign_Task;\n+\n+   ------------\n+   -- Create --\n+   ------------\n+\n+   function Create (First, Last : CPU) return Dispatching_Domain is\n+      use type System.Tasking.Dispatching_Domain;\n+      use type System.Tasking.Dispatching_Domain_Access;\n+      use type System.Tasking.Task_Id;\n+\n+      Valid_System_Domain : constant Boolean :=\n+        (First > CPU'First and then\n+           not (System_Dispatching_Domain (CPU'First .. First - 1) =\n+                (CPU'First .. First - 1 => False)))\n+          or else\n+        (Last < Number_Of_CPUs and then\n+           not (System_Dispatching_Domain (Last + 1 .. Number_Of_CPUs) =\n+                (Last + 1 .. Number_Of_CPUs => False)));\n+      --  Constant that indicates whether there would exist a non-empty system\n+      --  dispatching domain after the creation of this dispatching domain.\n+\n+      T : ST.Task_Id;\n+\n+      New_Domain : Dispatching_Domain;\n+\n+   begin\n+      --  The range of processors for creating a dispatching domain must\n+      --  comply with the following restrictions:\n+      --    - Non-empty range\n+      --    - Not exceeding the range of available processors\n+      --    - Range from the System_Dispatching_Domain\n+      --    - Range does not contain a processor with a task assigned to it\n+      --    - The allocation cannot leave System_Dispatching_Domain empty\n+      --    - The calling task must be the environment task\n+      --    - The call to Create must take place before the call to the main\n+      --      subprogram\n+\n+      if First > Last then\n+         raise Dispatching_Domain_Error with \"empty dispatching domain\";\n+\n+      elsif Last > Number_Of_CPUs then\n+         raise Dispatching_Domain_Error with\n+           \"CPU range not supported by the target\";\n+\n+      elsif\n+        System_Dispatching_Domain (First .. Last) /= (First .. Last => True)\n+      then\n+         raise Dispatching_Domain_Error with\n+           \"CPU range not currently in System_Dispatching_Domain\";\n+\n+      elsif\n+        Dispatching_Domain_Tasks (First .. Last) /= (First .. Last => 0)\n+      then\n+         raise Dispatching_Domain_Error with \"CPU range has tasks assigned\";\n+\n+      elsif not Valid_System_Domain then\n+         raise Dispatching_Domain_Error with\n+           \"would leave System_Dispatching_Domain empty\";\n+\n+      elsif Self /= Environment_Task then\n+         raise Dispatching_Domain_Error with\n+           \"only the environment task can create dispatching domains\";\n+\n+      elsif Dispatching_Domains_Frozen then\n+         raise Dispatching_Domain_Error with\n+           \"cannot create dispatching domain after call to main program\";\n+      end if;\n+\n+      New_Domain := new ST.Dispatching_Domain'(First .. Last => True);\n+\n+      --  At this point we need to fix the processors belonging to the system\n+      --  domain, and change the affinity of every task that has been created\n+      --  and assigned to the system domain.\n+\n+      ST.Initialization.Defer_Abort (Self);\n+\n+      Lock_RTS;\n+\n+      System_Dispatching_Domain (First .. Last) := (First .. Last => False);\n+\n+      --  Iterate the list of tasks belonging to the default system\n+      --  dispatching domain and set the appropriate affinity.\n+\n+      T := ST.All_Tasks_List;\n+\n+      while T /= null loop\n+         if T.Common.Domain = null or else\n+           T.Common.Domain = ST.System_Domain\n+         then\n+            Set_Task_Affinity (T);\n+         end if;\n+\n+         T := T.Common.All_Tasks_Link;\n+      end loop;\n+\n+      Unlock_RTS;\n+\n+      ST.Initialization.Undefer_Abort (Self);\n+\n+      return New_Domain;\n+   end Create;\n+\n+   -----------------------------\n+   -- Delay_Until_And_Set_CPU --\n+   -----------------------------\n+\n+   procedure Delay_Until_And_Set_CPU\n+     (Delay_Until_Time : Ada.Real_Time.Time; CPU : CPU_Range) is\n+   begin\n+      --  Not supported atomically by the underlying operating systems.\n+      --  Operating systems use to migrate the task immediately after the call\n+      --  to set the affinity.\n+\n+      delay until Delay_Until_Time;\n+      Set_CPU (CPU);\n+   end Delay_Until_And_Set_CPU;\n+\n+   --------------------------------\n+   -- Freeze_Dispatching_Domains --\n+   --------------------------------\n+\n+   procedure Freeze_Dispatching_Domains is\n+   begin\n+      --  Signal the end of the elaboration code\n+\n+      Dispatching_Domains_Frozen := True;\n+   end Freeze_Dispatching_Domains;\n+\n+   -------------\n+   -- Get_CPU --\n+   -------------\n+\n+   function Get_CPU\n+     (T : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task)\n+      return CPU_Range is\n+   begin\n+      return Convert_Ids (T).Common.Base_CPU;\n+   end Get_CPU;\n+\n+   ----------------------------\n+   -- Get_Dispatching_Domain --\n+   ----------------------------\n+\n+   function Get_Dispatching_Domain\n+     (T : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task)\n+      return Dispatching_Domain is\n+   begin\n+      return Dispatching_Domain (Convert_Ids (T).Common.Domain);\n+   end Get_Dispatching_Domain;\n+\n+   -------------------\n+   -- Get_First_CPU --\n+   -------------------\n+\n+   function Get_First_CPU (Domain : Dispatching_Domain) return CPU is\n+   begin\n+      for Proc in Domain'Range loop\n+         if Domain (Proc) then\n+            return Proc;\n+         end if;\n+      end loop;\n+\n+      --  Should never reach the following return\n+\n+      return Domain'First;\n+   end Get_First_CPU;\n+\n+   ------------------\n+   -- Get_Last_CPU --\n+   ------------------\n+\n+   function Get_Last_CPU (Domain : Dispatching_Domain) return CPU is\n+   begin\n+      for Proc in reverse Domain'Range loop\n+         if Domain (Proc) then\n+            return Proc;\n+         end if;\n+      end loop;\n+\n+      --  Should never reach the following return\n+\n+      return Domain'Last;\n+   end Get_Last_CPU;\n+\n+   -------------\n+   -- Set_CPU --\n+   -------------\n+\n+   procedure Set_CPU\n+     (CPU : CPU_Range;\n+      T   : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task)\n+   is\n+      Target : constant ST.Task_Id := Convert_Ids (T);\n+\n+      use type ST.Dispatching_Domain_Access;\n+\n+   begin\n+      --  The exception Dispatching_Domain_Error is propagated if CPU is not\n+      --  one of the processors of the Dispatching_Domain on which T is\n+      --  assigned (and is not Not_A_Specific_CPU).\n+\n+      if CPU /= Not_A_Specific_CPU and then\n+        (CPU not in Target.Common.Domain'Range or else\n+         not Target.Common.Domain (CPU))\n+      then\n+         raise Dispatching_Domain_Error with\n+           \"CPU does not belong to the task's dispatching domain\";\n+      end if;\n+\n+      Unchecked_Set_Affinity (Target.Common.Domain, CPU, Target);\n+   end Set_CPU;\n+\n+   ----------------------------\n+   -- Unchecked_Set_Affinity --\n+   ----------------------------\n+\n+   procedure Unchecked_Set_Affinity\n+     (Domain : ST.Dispatching_Domain_Access;\n+      CPU    : CPU_Range;\n+      T      : ST.Task_Id)\n+   is\n+      Source_CPU : constant CPU_Range := T.Common.Base_CPU;\n+\n+      use type System.Tasking.Dispatching_Domain_Access;\n+\n+   begin\n+      Write_Lock (T);\n+\n+      --  Move to the new domain\n+\n+      T.Common.Domain := Domain;\n+\n+      --  Attach the CPU to the task\n+\n+      T.Common.Base_CPU := CPU;\n+\n+      --  Change the number of tasks attached to a given task in the system\n+      --  domain if needed.\n+\n+      if not Dispatching_Domains_Frozen and then\n+        (Domain = null or else Domain = ST.System_Domain)\n+      then\n+         --  Reduce the number of tasks attached to the CPU from which this\n+         --  task is being moved, if needed.\n+\n+         if Source_CPU /= Not_A_Specific_CPU then\n+            Dispatching_Domain_Tasks (Source_CPU) :=\n+              Dispatching_Domain_Tasks (Source_CPU) - 1;\n+         end if;\n+\n+         --  Increase the number of tasks attached to the CPU to which this\n+         --  task is being moved, if needed.\n+\n+         if CPU /= Not_A_Specific_CPU then\n+            Dispatching_Domain_Tasks (CPU) :=\n+              Dispatching_Domain_Tasks (CPU) + 1;\n+         end if;\n+      end if;\n+\n+      --  Change the actual affinity calling the operating system level\n+\n+      Set_Task_Affinity (T);\n+\n+      Unlock (T);\n+   end Unchecked_Set_Affinity;\n+\n+end System.Multiprocessors.Dispatching_Domains;"}, {"sha": "caba7422b4bda9e47143b341d9b04983487e9776", "filename": "gcc/ada/s-mudido.adb", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-mudido.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-mudido.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mudido.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -0,0 +1,166 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                SYSTEM.MULTIPROCESSORS.DISPATCHING_DOMAINS                --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Body used on unimplemented targets, where the operating system does not\n+--  support setting task affinities.\n+\n+package body System.Multiprocessors.Dispatching_Domains is\n+\n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   procedure Freeze_Dispatching_Domains;\n+   pragma Export\n+     (Ada, Freeze_Dispatching_Domains, \"__gnat_freeze_dispatching_domains\");\n+   --  Signal the time when no new dispatching domains can be created. It\n+   --  should be called before the environment task calls the main procedure\n+   --  (and after the elaboration code), so the binder-generated file needs to\n+   --  import and call this procedure.\n+\n+   -----------------\n+   -- Assign_Task --\n+   -----------------\n+\n+   procedure Assign_Task\n+     (Domain : in out Dispatching_Domain;\n+      CPU    : CPU_Range := Not_A_Specific_CPU;\n+      T      : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task)\n+   is\n+      pragma Unreferenced (Domain, CPU, T);\n+\n+   begin\n+      raise Dispatching_Domain_Error with \"dispatching domains not supported\";\n+   end Assign_Task;\n+\n+   ------------\n+   -- Create --\n+   ------------\n+\n+   function Create (First, Last : CPU) return Dispatching_Domain is\n+      pragma Unreferenced (First, Last);\n+\n+   begin\n+      raise Dispatching_Domain_Error with \"dispatching domains not supported\";\n+      return System_Dispatching_Domain;\n+   end Create;\n+\n+   -----------------------------\n+   -- Delay_Until_And_Set_CPU --\n+   -----------------------------\n+\n+   procedure Delay_Until_And_Set_CPU\n+     (Delay_Until_Time : Ada.Real_Time.Time; CPU : CPU_Range)\n+   is\n+      pragma Unreferenced (Delay_Until_Time, CPU);\n+\n+   begin\n+      raise Dispatching_Domain_Error with \"dispatching domains not supported\";\n+   end Delay_Until_And_Set_CPU;\n+\n+   --------------------------------\n+   -- Freeze_Dispatching_Domains --\n+   --------------------------------\n+\n+   procedure Freeze_Dispatching_Domains is\n+   begin\n+      null;\n+   end Freeze_Dispatching_Domains;\n+\n+   -------------\n+   -- Get_CPU --\n+   -------------\n+\n+   function Get_CPU\n+     (T : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task)\n+      return CPU_Range\n+   is\n+      pragma Unreferenced (T);\n+\n+   begin\n+      return Not_A_Specific_CPU;\n+   end Get_CPU;\n+\n+   ----------------------------\n+   -- Get_Dispatching_Domain --\n+   ----------------------------\n+\n+   function Get_Dispatching_Domain\n+     (T : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task)\n+      return Dispatching_Domain\n+   is\n+      pragma Unreferenced (T);\n+\n+   begin\n+      return System_Dispatching_Domain;\n+   end Get_Dispatching_Domain;\n+\n+   -------------------\n+   -- Get_First_CPU --\n+   -------------------\n+\n+   function Get_First_CPU (Domain : Dispatching_Domain) return CPU is\n+      pragma Unreferenced (Domain);\n+\n+   begin\n+      return CPU'First;\n+   end Get_First_CPU;\n+\n+   ------------------\n+   -- Get_Last_CPU --\n+   ------------------\n+\n+   function Get_Last_CPU (Domain : Dispatching_Domain) return CPU is\n+      pragma Unreferenced (Domain);\n+\n+   begin\n+      return Number_Of_CPUs;\n+   end Get_Last_CPU;\n+\n+   -------------\n+   -- Set_CPU --\n+   -------------\n+\n+   procedure Set_CPU\n+     (CPU : CPU_Range;\n+      T   : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task)\n+   is\n+      pragma Unreferenced (CPU, T);\n+\n+   begin\n+      raise Dispatching_Domain_Error with \"dispatching domains not supported\";\n+   end Set_CPU;\n+\n+end System.Multiprocessors.Dispatching_Domains;"}, {"sha": "62cc01d72c4f63befe21a0c06930a6951035775f", "filename": "gcc/ada/s-mudido.ads", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-mudido.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-mudido.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mudido.ads?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                SYSTEM.MULTIPROCESSORS.DISPATCHING_DOMAINS                --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Real_Time;\n+\n+with Ada.Task_Identification;\n+\n+private with System.Tasking;\n+\n+package System.Multiprocessors.Dispatching_Domains is\n+   --  pragma Preelaborate (Dispatching_Domains);\n+   --  ??? According to AI 167 this unit should be preelaborate, but it cannot\n+   --  be preelaborate because it depends on Ada.Real_Time which is not\n+   --  preelaborate.\n+\n+   Dispatching_Domain_Error : exception;\n+\n+   type Dispatching_Domain (<>) is limited private;\n+\n+   System_Dispatching_Domain : constant Dispatching_Domain;\n+\n+   function Create (First, Last : CPU) return Dispatching_Domain;\n+\n+   function Get_First_CPU (Domain : Dispatching_Domain) return CPU;\n+\n+   function Get_Last_CPU (Domain : Dispatching_Domain) return CPU;\n+\n+   function Get_Dispatching_Domain\n+     (T : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task)\n+      return Dispatching_Domain;\n+\n+   procedure Assign_Task\n+     (Domain : in out Dispatching_Domain;\n+      CPU    : CPU_Range := Not_A_Specific_CPU;\n+      T      : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task);\n+\n+   procedure Set_CPU\n+     (CPU : CPU_Range;\n+      T   : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task);\n+\n+   function Get_CPU\n+     (T : Ada.Task_Identification.Task_Id :=\n+        Ada.Task_Identification.Current_Task)\n+      return CPU_Range;\n+\n+   procedure Delay_Until_And_Set_CPU\n+     (Delay_Until_Time : Ada.Real_Time.Time; CPU : CPU_Range);\n+\n+private\n+   type Dispatching_Domain is new System.Tasking.Dispatching_Domain_Access;\n+\n+   System_Dispatching_Domain : constant Dispatching_Domain :=\n+     Dispatching_Domain (System.Tasking.System_Domain);\n+end System.Multiprocessors.Dispatching_Domains;"}, {"sha": "03a0c4ae47dc8d6ead71360e9d796c1a345d12b9", "filename": "gcc/ada/s-osinte-solaris.ads", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-osinte-solaris.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-osinte-solaris.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-solaris.ads?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -492,6 +492,24 @@ package System.OS_Interface is\n       obind   : processorid_t_ptr) return int;\n    pragma Import (C, processor_bind, \"processor_bind\");\n \n+   type psetid_t is new int;\n+\n+   function pset_create (pset : access psetid_t) return int;\n+   pragma Import (C, pset_create, \"pset_create\");\n+\n+   function pset_assign\n+     (pset    : psetid_t;\n+      proc_id : processorid_t;\n+      opset   : access psetid_t) return int;\n+   pragma Import (C, pset_assign, \"pset_assign\");\n+\n+   function pset_bind\n+     (pset    : psetid_t;\n+      id_type : int;\n+      id      : id_t;\n+      opset   : access psetid_t) return int;\n+   pragma Import (C, pset_bind, \"pset_bind\");\n+\n    procedure pthread_init;\n    --  Dummy procedure to share s-intman.adb with other Solaris targets\n "}, {"sha": "f5013ea6977a44fa29f1e45bd57ad9d0a0e29f74", "filename": "gcc/ada/s-osinte-vxworks.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-osinte-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-osinte-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vxworks.ads?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -7,7 +7,7 @@\n --                                   S p e c                                --\n --                                                                          --\n --            Copyright (C) 1991-1994, Florida State University             --\n---          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,6 +47,7 @@ package System.OS_Interface is\n    pragma Preelaborate;\n \n    subtype int             is Interfaces.C.int;\n+   subtype unsigned        is Interfaces.C.unsigned;\n    subtype short           is Short_Integer;\n    type unsigned_int       is mod 2 ** int'Size;\n    type long               is new Long_Integer;\n@@ -493,6 +494,11 @@ package System.OS_Interface is\n    --  For SMP run-times the affinity to CPU.\n    --  For uniprocessor systems return ERROR status.\n \n+   function taskMaskAffinitySet (tid : t_id; CPU_Set : unsigned) return int\n+     renames System.VxWorks.Ext.taskMaskAffinitySet;\n+   --  For SMP run-times the affinity to CPU_Set.\n+   --  For uniprocessor systems return ERROR status.\n+\n    ---------------------\n    -- Multiprocessors --\n    ---------------------"}, {"sha": "88f4571f61e7939f47e5d410deef5cbe37a1d5fd", "filename": "gcc/ada/s-taprop-dummy.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-dummy.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2009, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2011, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -346,6 +346,15 @@ package body System.Task_Primitives.Operations is\n       null;\n    end Set_Priority;\n \n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+   begin\n+      null;\n+   end Set_Task_Affinity;\n+\n    --------------\n    -- Set_True --\n    --------------"}, {"sha": "ca059c954089e52d237a6d79d770d5b8b51b4236", "filename": "gcc/ada/s-taprop-hpux-dce.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-hpux-dce.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -1241,4 +1241,16 @@ package body System.Task_Primitives.Operations is\n    --  this difference is that sigwait doesn't work when some critical\n    --  signals (SIGABRT, SIGPIPE) are masked.\n \n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      pragma Unreferenced (T);\n+   begin\n+      --  Setting task affinity is not supported by the underlying system\n+\n+      null;\n+   end Set_Task_Affinity;\n+\n end System.Task_Primitives.Operations;"}, {"sha": "9eb766c71455e381b27452891f03c47bc97a9123", "filename": "gcc/ada/s-taprop-irix.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -1342,4 +1342,16 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Initialize;\n \n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      pragma Unreferenced (T);\n+   begin\n+      --  Setting task affinity is not supported by the underlying system\n+\n+      null;\n+   end Set_Task_Affinity;\n+\n end System.Task_Primitives.Operations;"}, {"sha": "7296ca18969af880df3d859a80df2b5a98c2f2e5", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 89, "deletions": 14, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -879,6 +879,27 @@ package body System.Task_Primitives.Operations is\n               CPU_SETSIZE / 8,\n               T.Common.Task_Info.CPU_Affinity'Access);\n          pragma Assert (Result = 0);\n+\n+      --  Handle dispatching domains\n+\n+      elsif T.Common.Domain /= null then\n+         declare\n+            CPU_Set : aliased cpu_set_t := (bits => (others => False));\n+         begin\n+            --  Set the affinity to all the processors belonging to the\n+            --  dispatching domain.\n+\n+            for Proc in T.Common.Domain'Range loop\n+               CPU_Set.bits (Integer (Proc)) := T.Common.Domain (Proc);\n+            end loop;\n+\n+            Result :=\n+              pthread_attr_setaffinity_np\n+                (Attributes'Access,\n+                 CPU_SETSIZE / 8,\n+                 CPU_Set'Access);\n+            pragma Assert (Result = 0);\n+         end;\n       end if;\n \n       --  Since the initial signal mask of a thread is inherited from the\n@@ -1328,24 +1349,78 @@ package body System.Task_Primitives.Operations is\n          Abort_Handler_Installed := True;\n       end if;\n \n-      --  pragma CPU for the environment task\n+      --  pragma CPU and dispatching domains for the environment task\n \n-      if pthread_setaffinity_np'Address /= System.Null_Address\n-        and then Environment_Task.Common.Base_CPU /=\n-                   System.Multiprocessors.Not_A_Specific_CPU\n-      then\n+      Set_Task_Affinity (Environment_Task);\n+   end Initialize;\n+\n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      use type System.Multiprocessors.CPU_Range;\n+\n+   begin\n+      if pthread_setaffinity_np'Address /= System.Null_Address then\n          declare\n-            CPU_Set : aliased cpu_set_t := (bits => (others => False));\n+            CPU_Set : access cpu_set_t := null;\n+\n+            Result  : Interfaces.C.int;\n+\n          begin\n-            CPU_Set.bits (Integer (Environment_Task.Common.Base_CPU)) := True;\n-            Result :=\n-              pthread_setaffinity_np\n-                (Environment_Task.Common.LL.Thread,\n-                 CPU_SETSIZE / 8,\n-                 CPU_Set'Access);\n-            pragma Assert (Result = 0);\n+            --  We look at the specific CPU (Base_CPU) first, then at the\n+            --  Task_Info field, and finally at the assigned dispatching\n+            --  domain, if any.\n+\n+            if T.Common.Base_CPU /= Multiprocessors.Not_A_Specific_CPU then\n+               --  Set the affinity to an unique CPU\n+\n+               CPU_Set := new cpu_set_t'(bits => (others => False));\n+               CPU_Set.bits (Integer (T.Common.Base_CPU)) := True;\n+\n+            --  Handle Task_Info\n+\n+            elsif T.Common.Task_Info /= null\n+              and then T.Common.Task_Info.CPU_Affinity /= Task_Info.Any_CPU\n+            then\n+               CPU_Set := T.Common.Task_Info.CPU_Affinity'Access;\n+\n+            --  Handle dispatching domains\n+\n+            elsif T.Common.Domain /= null and then\n+              (T.Common.Domain /= ST.System_Domain or else\n+               T.Common.Domain.all /= (Multiprocessors.CPU'First ..\n+                                       Multiprocessors.Number_Of_CPUs => True))\n+            then\n+               --  Set the affinity to all the processors belonging to the\n+               --  dispatching domain. To avoid changing CPU affinities when\n+               --  not needed, we set the affinity only when assigning to a\n+               --  domain other than the default one, or when the default one\n+               --  has been modified.\n+\n+               CPU_Set := new cpu_set_t'(bits => (others => False));\n+\n+               for Proc in T.Common.Domain'Range loop\n+                  CPU_Set.bits (Integer (Proc)) := T.Common.Domain (Proc);\n+               end loop;\n+            end if;\n+\n+            --  We set the new affinity if needed. Otherwise, the new task\n+            --  will inherit its creator's CPU affinity mask (according to\n+            --  the documentation of pthread_setaffinity_np), which is\n+            --  consistent with Ada's required semantics.\n+\n+            if CPU_Set /= null then\n+               Result :=\n+                 pthread_setaffinity_np\n+                   (T.Common.LL.Thread,\n+                    CPU_SETSIZE / 8,\n+                    CPU_Set);\n+               pragma Assert (Result = 0);\n+            end if;\n          end;\n       end if;\n-   end Initialize;\n+   end Set_Task_Affinity;\n \n end System.Task_Primitives.Operations;"}, {"sha": "a770a6a458935af43161ce443f25c904c59c5d0f", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 60, "deletions": 32, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -954,21 +954,7 @@ package body System.Task_Primitives.Operations is\n \n       --  Step 4: Handle pragma CPU and Task_Info\n \n-      if T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU then\n-\n-         --  The CPU numbering in pragma CPU starts at 1 while the subprogram\n-         --  to set the affinity starts at 0, therefore we must subtract 1.\n-\n-         Result := SetThreadIdealProcessor\n-           (hTask, ProcessorId (T.Common.Base_CPU) - 1);\n-         pragma Assert (Result = 1);\n-\n-      elsif T.Common.Task_Info /= null then\n-         if T.Common.Task_Info.CPU /= Task_Info.Any_CPU then\n-            Result := SetThreadIdealProcessor (hTask, T.Common.Task_Info.CPU);\n-            pragma Assert (Result = 1);\n-         end if;\n-      end if;\n+      Set_Task_Affinity (T);\n \n       --  Step 5: Now, start it for good\n \n@@ -1074,10 +1060,6 @@ package body System.Task_Primitives.Operations is\n       Discard : BOOL;\n       pragma Unreferenced (Discard);\n \n-      Result : DWORD;\n-\n-      use type System.Multiprocessors.CPU_Range;\n-\n    begin\n       Environment_Task_Id := Environment_Task;\n       OS_Primitives.Initialize;\n@@ -1109,20 +1091,9 @@ package body System.Task_Primitives.Operations is\n \n       Enter_Task (Environment_Task);\n \n-      --  pragma CPU for the environment task\n-\n-      if Environment_Task.Common.Base_CPU /=\n-         System.Multiprocessors.Not_A_Specific_CPU\n-      then\n-         --  The CPU numbering in pragma CPU starts at 1 while the subprogram\n-         --  to set the affinity starts at 0, therefore we must subtract 1.\n+      --  pragma CPU and dispatching domains for the environment task\n \n-         Result :=\n-           SetThreadIdealProcessor\n-             (Environment_Task.Common.LL.Thread,\n-              ProcessorId (Environment_Task.Common.Base_CPU) - 1);\n-         pragma Assert (Result = 1);\n-      end if;\n+      Set_Task_Affinity (Environment_Task);\n    end Initialize;\n \n    ---------------------\n@@ -1377,4 +1348,61 @@ package body System.Task_Primitives.Operations is\n       return False;\n    end Continue_Task;\n \n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      Result : DWORD;\n+\n+      use type System.Multiprocessors.CPU_Range;\n+\n+   begin\n+      --  pragma CPU\n+\n+      if T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU then\n+\n+         --  The CPU numbering in pragma CPU starts at 1 while the subprogram\n+         --  to set the affinity starts at 0, therefore we must substract 1.\n+\n+         Result := SetThreadIdealProcessor\n+           (T.Common.LL.Thread, ProcessorId (T.Common.Base_CPU) - 1);\n+         pragma Assert (Result = 1);\n+\n+      --  Task_Info\n+\n+      elsif T.Common.Task_Info /= null then\n+         if T.Common.Task_Info.CPU /= Task_Info.Any_CPU then\n+            Result :=\n+              SetThreadIdealProcessor\n+                (T.Common.LL.Thread, T.Common.Task_Info.CPU);\n+            pragma Assert (Result = 1);\n+         end if;\n+\n+      --  Dispatching domains\n+\n+      elsif T.Common.Domain /= null and then\n+              (T.Common.Domain /= ST.System_Domain or else\n+               T.Common.Domain.all /= (Multiprocessors.CPU'First ..\n+                                       Multiprocessors.Number_Of_CPUs => True))\n+      then\n+         declare\n+            CPU_Set : DWORD := 0;\n+\n+         begin\n+            for Proc in T.Common.Domain'Range loop\n+               if T.Common.Domain (Proc) then\n+                  --  The thread affinity mask is a bit vector in which each\n+                  --  bit represents a logical processor.\n+\n+                  CPU_Set := CPU_Set + 2 ** (Integer (Proc) - 1);\n+               end if;\n+            end loop;\n+\n+            Result := SetThreadAffinityMask (T.Common.LL.Thread, CPU_Set);\n+            pragma Assert (Result = 1);\n+         end;\n+      end if;\n+   end Set_Task_Affinity;\n+\n end System.Task_Primitives.Operations;"}, {"sha": "b367915d147ffaa5be8c3f4dc5ecfcc21f3c2078", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -1449,4 +1449,16 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Initialize;\n \n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      pragma Unreferenced (T);\n+   begin\n+      --  Setting task affinity is not supported by the underlying system\n+\n+      null;\n+   end Set_Task_Affinity;\n+\n end System.Task_Primitives.Operations;"}, {"sha": "31862fa10bd47782072b1c188e75c54ace45d9ac", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 104, "deletions": 57, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -862,68 +862,12 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Enter_Task (Self_ID : Task_Id) is\n-      Result    : Interfaces.C.int;\n-      Proc      : processorid_t;  --  User processor #\n-      Last_Proc : processorid_t;  --  Last processor #\n-\n-      use System.Task_Info;\n-      use type System.Multiprocessors.CPU_Range;\n-\n    begin\n       Self_ID.Common.LL.Thread := thr_self;\n \n       Self_ID.Common.LL.LWP := lwp_self;\n \n-      --  pragma CPU\n-\n-      if Self_ID.Common.Base_CPU /=\n-         System.Multiprocessors.Not_A_Specific_CPU\n-      then\n-         --  The CPU numbering in pragma CPU starts at 1 while the subprogram\n-         --  to set the affinity starts at 0, therefore we must subtract 1.\n-\n-         Result :=\n-           processor_bind\n-             (P_LWPID, P_MYID, processorid_t (Self_ID.Common.Base_CPU) - 1,\n-              null);\n-         pragma Assert (Result = 0);\n-\n-      --  Task_Info\n-\n-      elsif Self_ID.Common.Task_Info /= null then\n-         if Self_ID.Common.Task_Info.New_LWP\n-           and then Self_ID.Common.Task_Info.CPU /= CPU_UNCHANGED\n-         then\n-            Last_Proc := Num_Procs - 1;\n-\n-            if Self_ID.Common.Task_Info.CPU = ANY_CPU then\n-               Result := 0;\n-               Proc := 0;\n-               while Proc < Last_Proc loop\n-                  Result := p_online (Proc, PR_STATUS);\n-                  exit when Result = PR_ONLINE;\n-                  Proc := Proc + 1;\n-               end loop;\n-\n-               Result := processor_bind (P_LWPID, P_MYID, Proc, null);\n-               pragma Assert (Result = 0);\n-\n-            else\n-               --  Use specified processor\n-\n-               if Self_ID.Common.Task_Info.CPU < 0\n-                 or else Self_ID.Common.Task_Info.CPU > Last_Proc\n-               then\n-                  raise Invalid_CPU_Number;\n-               end if;\n-\n-               Result :=\n-                 processor_bind\n-                   (P_LWPID, P_MYID, Self_ID.Common.Task_Info.CPU, null);\n-               pragma Assert (Result = 0);\n-            end if;\n-         end if;\n-      end if;\n+      Set_Task_Affinity (Self_ID);\n \n       Specific.Set (Self_ID);\n \n@@ -1987,4 +1931,107 @@ package body System.Task_Primitives.Operations is\n       return False;\n    end Continue_Task;\n \n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      Result    : Interfaces.C.int;\n+      Proc      : processorid_t;  --  User processor #\n+      Last_Proc : processorid_t;  --  Last processor #\n+\n+      use System.Task_Info;\n+      use type System.Multiprocessors.CPU_Range;\n+\n+   begin\n+      --  pragma CPU\n+\n+      if T.Common.Base_CPU /=\n+        System.Multiprocessors.Not_A_Specific_CPU\n+      then\n+         --  The CPU numbering in pragma CPU starts at 1 while the subprogram\n+         --  to set the affinity starts at 0, therefore we must substract 1.\n+\n+         Result :=\n+           processor_bind\n+             (P_LWPID, id_t (T.Common.LL.LWP),\n+              processorid_t (T.Common.Base_CPU) - 1, null);\n+         pragma Assert (Result = 0);\n+\n+      --  Task_Info\n+\n+      elsif T.Common.Task_Info /= null then\n+         if T.Common.Task_Info.New_LWP\n+           and then T.Common.Task_Info.CPU /= CPU_UNCHANGED\n+         then\n+            Last_Proc := Num_Procs - 1;\n+\n+            if T.Common.Task_Info.CPU = ANY_CPU then\n+               Result := 0;\n+               Proc := 0;\n+               while Proc < Last_Proc loop\n+                  Result := p_online (Proc, PR_STATUS);\n+                  exit when Result = PR_ONLINE;\n+                  Proc := Proc + 1;\n+               end loop;\n+\n+               Result :=\n+                 processor_bind\n+                   (P_LWPID, id_t (T.Common.LL.LWP), Proc, null);\n+               pragma Assert (Result = 0);\n+\n+            else\n+               --  Use specified processor\n+\n+               if T.Common.Task_Info.CPU < 0\n+                 or else T.Common.Task_Info.CPU > Last_Proc\n+               then\n+                  raise Invalid_CPU_Number;\n+               end if;\n+               Result :=\n+                 processor_bind\n+                   (P_LWPID, id_t (T.Common.LL.LWP),\n+                    T.Common.Task_Info.CPU, null);\n+               pragma Assert (Result = 0);\n+            end if;\n+         end if;\n+\n+      --  Handle dispatching domains\n+\n+      elsif T.Common.Domain /= null and then\n+              (T.Common.Domain /= ST.System_Domain or else\n+               T.Common.Domain.all /= (Multiprocessors.CPU'First ..\n+                                       Multiprocessors.Number_Of_CPUs => True))\n+      then\n+         declare\n+            CPU_Set : aliased psetid_t;\n+\n+            Result : int;\n+\n+         begin\n+            Result := pset_create (CPU_Set'Access);\n+            pragma Assert (Result = 0);\n+\n+            --  Set the affinity to all the processors belonging to the\n+            --  dispatching domain.\n+\n+            for Proc in T.Common.Domain'Range loop\n+               --  The Ada CPU numbering starts at 1 while the subprogram to\n+               --  set the affinity starts at 0, therefore we must substract\n+               --  1.\n+\n+               if T.Common.Domain (Proc) then\n+                  Result :=\n+                    pset_assign (CPU_Set, processorid_t (Proc) - 1, null);\n+                  pragma Assert (Result = 0);\n+               end if;\n+            end loop;\n+\n+            Result :=\n+              pset_bind (CPU_Set, P_LWPID, id_t (T.Common.LL.LWP), null);\n+            pragma Assert (Result = 0);\n+         end;\n+      end if;\n+   end Set_Task_Affinity;\n+\n end System.Task_Primitives.Operations;"}, {"sha": "55c4bd4c06f51d92b53640c06c91f9a00439bda6", "filename": "gcc/ada/s-taprop-tru64.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-tru64.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -1355,4 +1355,15 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Initialize;\n \n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      pragma Unreferenced (T);\n+   begin\n+      --  Setting task affinity is not supported by the underlying system\n+\n+      null;\n+   end Set_Task_Affinity;\n end System.Task_Primitives.Operations;"}, {"sha": "dbb84db4827695458d18e817017a0d9c418e5d5f", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -1254,4 +1254,15 @@ package body System.Task_Primitives.Operations is\n       Enter_Task (Environment_Task);\n    end Initialize;\n \n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      pragma Unreferenced (T);\n+   begin\n+      --  Setting task affinity is not supported by the underlying system\n+\n+      null;\n+   end Set_Task_Affinity;\n end System.Task_Primitives.Operations;"}, {"sha": "b1c88f38388cfc3bbf2574cd20c3ed4873be9e58", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 57, "deletions": 32, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -67,8 +67,10 @@ package body System.Task_Primitives.Operations is\n    use System.Parameters;\n    use type System.VxWorks.Ext.t_id;\n    use type Interfaces.C.int;\n+   use type System.OS_Interface.unsigned;\n \n    subtype int is System.OS_Interface.int;\n+   subtype unsigned is System.OS_Interface.unsigned;\n \n    Relative : constant := 0;\n \n@@ -883,10 +885,6 @@ package body System.Task_Primitives.Operations is\n       Succeeded  : out Boolean)\n    is\n       Adjusted_Stack_Size : size_t;\n-      Result : int := 0;\n-\n-      use System.Task_Info;\n-      use type System.Multiprocessors.CPU_Range;\n \n    begin\n       --  Ask for four extra bytes of stack space so that the ATCB pointer can\n@@ -952,26 +950,9 @@ package body System.Task_Primitives.Operations is\n \n       --  Set processor affinity\n \n-      if T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU then\n-         --  Ada 2012 pragma CPU uses CPU numbers starting from 1, while\n-         --  on VxWorks the first CPU is identified by a 0, so we need to\n-         --  adjust.\n-\n-         Result :=\n-           taskCpuAffinitySet\n-             (T.Common.LL.Thread, int (T.Common.Base_CPU) - 1);\n+      Set_Task_Affinity (T);\n \n-      elsif T.Common.Task_Info /= Unspecified_Task_Info then\n-         Result :=\n-           taskCpuAffinitySet (T.Common.LL.Thread, T.Common.Task_Info);\n-      end if;\n-\n-      if Result = -1 then\n-         taskDelete (T.Common.LL.Thread);\n-         T.Common.LL.Thread := -1;\n-      end if;\n-\n-      if T.Common.LL.Thread = -1 then\n+      if T.Common.LL.Thread <= 0 then\n          Succeeded := False;\n       else\n          Succeeded := True;\n@@ -1371,8 +1352,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Initialize (Environment_Task : Task_Id) is\n       Result : int;\n-\n-      use type System.Multiprocessors.CPU_Range;\n+      pragma Unreferenced (Result);\n \n    begin\n       Environment_Task_Id := Environment_Task;\n@@ -1413,19 +1393,64 @@ package body System.Task_Primitives.Operations is\n \n       --  Set processor affinity\n \n-      if Environment_Task.Common.Base_CPU /=\n-         System.Multiprocessors.Not_A_Specific_CPU\n-      then\n+      Set_Task_Affinity (Environment_Task);\n+   end Initialize;\n+\n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      Result : int := 0;\n+      pragma Unreferenced (Result);\n+\n+      use System.Task_Info;\n+      use type System.Multiprocessors.CPU_Range;\n+\n+   begin\n+      --  pragma CPU\n+\n+      if T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU then\n          --  Ada 2012 pragma CPU uses CPU numbers starting from 1, while\n          --  on VxWorks the first CPU is identified by a 0, so we need to\n          --  adjust.\n \n          Result :=\n            taskCpuAffinitySet\n-             (Environment_Task.Common.LL.Thread,\n-              int (Environment_Task.Common.Base_CPU) - 1);\n-         pragma Assert (Result /= -1);\n+             (T.Common.LL.Thread, int (T.Common.Base_CPU) - 1);\n+\n+      --  Task_Info\n+\n+      elsif T.Common.Task_Info /= Unspecified_Task_Info then\n+         Result :=\n+           taskCpuAffinitySet (T.Common.LL.Thread, T.Common.Task_Info);\n+\n+      --  Handle dispatching domains\n+\n+      elsif T.Common.Domain /= null and then\n+              (T.Common.Domain /= ST.System_Domain or else\n+               T.Common.Domain.all /= (Multiprocessors.CPU'First ..\n+                                       Multiprocessors.Number_Of_CPUs => True))\n+      then\n+         declare\n+            CPU_Set : unsigned := 0;\n+         begin\n+            --  Set the affinity to all the processors belonging to the\n+            --  dispatching domain.\n+\n+            for Proc in T.Common.Domain'Range loop\n+               if T.Common.Domain (Proc) then\n+                  --  The thread affinity mask is a bit vector in which each\n+                  --  bit represents a logical processor.\n+\n+                  CPU_Set := CPU_Set + 2 ** (Integer (Proc) - 1);\n+               end if;\n+            end loop;\n+\n+            Result :=\n+              taskMaskAffinitySet (T.Common.LL.Thread, CPU_Set);\n+         end;\n       end if;\n-   end Initialize;\n+   end Set_Task_Affinity;\n \n end System.Task_Primitives.Operations;"}, {"sha": "e413b126645b8e8452a8596ef4503d15059cda83", "filename": "gcc/ada/s-taprop.ads", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taprop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop.ads?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -543,4 +543,12 @@ package System.Task_Primitives.Operations is\n    --  such functionality. Such functionality is needed by gdb on some targets\n    --  (e.g VxWorks) Return True is the operation is successful\n \n+   -------------------\n+   -- Task affinity --\n+   -------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id);\n+   --  Enforce at the operating system level the task affinity defined in the\n+   --  Ada Task Control Block.\n+\n end System.Task_Primitives.Operations;"}, {"sha": "c79171b23c3b537095ab2830a0d1c3797dc43abc", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -218,6 +218,21 @@ package body System.Tasking is\n       T.Common.Task_Image_Len := Main_Task_Image'Length;\n       T.Common.Task_Image (Main_Task_Image'Range) := Main_Task_Image;\n \n+      --  At program start-up the environment task is allocated to the default\n+      --  system dispatching domain.\n+      --  Make sure that the processors which are not available are not taken\n+      --  into account. Use Number_Of_CPUs to know the exact number of\n+      --  processors in the system at execution time.\n+\n+      System_Domain := new Dispatching_Domain'\n+        (Multiprocessors.CPU'First .. Multiprocessors.Number_Of_CPUs => True);\n+\n+      T.Common.Domain := System_Domain;\n+\n+      --  ??? If we want to handle the interaction between pragma CPU and\n+      --  dispatching domains we would need to signal that this task is being\n+      --  allocated to a processor.\n+\n       --  Only initialize the first element since others are not relevant\n       --  in ravenscar mode. Rest of the initialization is done in Init_RTS.\n "}, {"sha": "743ca586bbd40e5f371af1f804ce3931905a609e", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -374,6 +374,29 @@ package System.Tasking is\n    --  Used to represent protected procedures to be executed when task\n    --  terminates.\n \n+   ------------------------------------\n+   -- Dispatching domain definitions --\n+   ------------------------------------\n+\n+   --  We need to redefine here these types (already defined in\n+   --  System.Multiprocessor.Dispatching_Domains) for avoiding circular\n+   --  dependencies.\n+\n+   type Dispatching_Domain is\n+     array (System.Multiprocessors.CPU range <>) of Boolean;\n+   --  A dispatching domain needs to contain the set of processors belonging\n+   --  to it. This is a processor mask where a True indicates that the\n+   --  processor belongs to the dispatching domain.\n+   --  Do not use the full range of CPU_Range because it would create a very\n+   --  long array. This way we can use the exact range of processors available\n+   --  in the system.\n+\n+   type Dispatching_Domain_Access is access Dispatching_Domain;\n+\n+   System_Domain : Dispatching_Domain_Access;\n+   --  All processors belong to the default system dispatching domain at start\n+   --  up.\n+\n    ------------------------------------\n    -- Task related other definitions --\n    ------------------------------------\n@@ -637,6 +660,16 @@ package System.Tasking is\n       Debug_Events : Debug_Event_Array;\n       --  Word length array of per task debug events, of which 11 kinds are\n       --  currently defined in System.Tasking.Debugging package.\n+\n+      Domain : Dispatching_Domain_Access;\n+      --  Domain is the dispatching domain to which the task belongs. It is\n+      --  only changed via dispatching domains package. This field is made\n+      --  part of the Common_ATCB, even when restricted run-times (namely\n+      --  Ravenscar) do not use it, because this way the field is always\n+      --  available to the underlying layers to set the affinity and we do not\n+      --  need to do different things depending on the situation.\n+      --\n+      --  Protection: Self.L\n    end record;\n \n    ---------------------------------------"}, {"sha": "a071aa113a2e334cc8fddb27722bb3225fb04dbe", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -539,6 +539,10 @@ package body System.Tasking.Stages is\n             else System.Multiprocessors.CPU_Range (CPU));\n       end if;\n \n+      --  ??? If we want to handle the interaction between pragma CPU and\n+      --  dispatching domains we would need to signal that this task is being\n+      --  allocated to a processor.\n+\n       --  Find parent P of new Task, via master level number\n \n       P := Self_ID;\n@@ -638,6 +642,17 @@ package body System.Tasking.Stages is\n          T.Common.Task_Image_Len := Len;\n       end if;\n \n+      --  ??? For the moment the task inherits the dispatching domain of the\n+      --  parent. It will change when support for the Dispatching_Domain\n+      --  aspect will be added, because that will allow setting the domain\n+      --  in the spec of the task.\n+\n+      if T.Common.Activator /= null then\n+         T.Common.Domain := T.Common.Activator.Common.Domain;\n+      else\n+         T.Common.Domain := System.Tasking.System_Domain;\n+      end if;\n+\n       Unlock (Self_ID);\n       Unlock_RTS;\n "}, {"sha": "cd2ac2642667e33ecc06573c9500e6f671a78a17", "filename": "gcc/ada/s-vxwext-kernel.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext-kernel.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext-kernel.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext-kernel.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                   B o d y                                --\n --                                                                          --\n---            Copyright (C) 2008-2009, Free Software Foundation, Inc.       --\n+--            Copyright (C) 2008-2011, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNARL is free software;  you can redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -75,6 +75,16 @@ package body System.VxWorks.Ext is\n       return ERROR;\n    end taskCpuAffinitySet;\n \n+   -------------------------\n+   -- taskMaskAffinitySet --\n+   -------------------------\n+\n+   function taskMaskAffinitySet (tid : t_id; CPU_Set : unsigned) return int is\n+      pragma Unreferenced (tid, CPU_Set);\n+   begin\n+      return ERROR;\n+   end taskMaskAffinitySet;\n+\n    --------------\n    -- taskStop --\n    --------------"}, {"sha": "ff41666fbedf85acc5a7f77563a59dc65770321d", "filename": "gcc/ada/s-vxwext-kernel.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext-kernel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext-kernel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext-kernel.ads?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                   S p e c                                --\n --                                                                          --\n---            Copyright (C) 2008-2010, Free Software Foundation, Inc.       --\n+--            Copyright (C) 2008-2011, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNARL is free software;  you can redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,6 +43,7 @@ package System.VxWorks.Ext is\n \n    type t_id is new Long_Integer;\n    subtype int is Interfaces.C.int;\n+   subtype unsigned is Interfaces.C.unsigned;\n \n    type Interrupt_Handler is access procedure (parameter : System.Address);\n    pragma Convention (C, Interrupt_Handler);\n@@ -101,4 +102,9 @@ package System.VxWorks.Ext is\n    --  For SMP run-times set the CPU affinity.\n    --  For uniprocessor systems return ERROR status.\n \n+   function taskMaskAffinitySet (tid : t_id; CPU_Set : unsigned) return int;\n+   pragma Convention (C, taskMaskAffinitySet);\n+   --  For SMP run-times set the CPU mask affinity.\n+   --  For uniprocessor systems return ERROR status.\n+\n end System.VxWorks.Ext;"}, {"sha": "e5f74062ca28938683b2a38966a312d654b9fbe0", "filename": "gcc/ada/s-vxwext-rtp.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext-rtp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext-rtp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext-rtp.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                   B o d y                                --\n --                                                                          --\n---            Copyright (C) 2008-2010, Free Software Foundation, Inc.       --\n+--            Copyright (C) 2008-2011, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNARL is free software;  you can redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -121,4 +121,14 @@ package body System.VxWorks.Ext is\n       return ERROR;\n    end taskCpuAffinitySet;\n \n+   -------------------------\n+   -- taskMaskAffinitySet --\n+   -------------------------\n+\n+   function taskMaskAffinitySet (tid : t_id; CPU_Set : unsigned) return int is\n+      pragma Unreferenced (tid, CPU_Set);\n+   begin\n+      return ERROR;\n+   end taskMaskAffinitySet;\n+\n end System.VxWorks.Ext;"}, {"sha": "ed734578c0bf3eeb733aa635482d97c3502ec623", "filename": "gcc/ada/s-vxwext-rtp.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext-rtp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext-rtp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext-rtp.ads?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                   S p e c                                --\n --                                                                          --\n---            Copyright (C) 2008-2010, Free Software Foundation, Inc.       --\n+--            Copyright (C) 2008-2011, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNARL is free software;  you can redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,6 +43,7 @@ package System.VxWorks.Ext is\n \n    type t_id is new Long_Integer;\n    subtype int is Interfaces.C.int;\n+   subtype unsigned is Interfaces.C.unsigned;\n \n    type Interrupt_Handler is access procedure (parameter : System.Address);\n    pragma Convention (C, Interrupt_Handler);\n@@ -95,4 +96,9 @@ package System.VxWorks.Ext is\n    --  For SMP run-times set the CPU affinity.\n    --  For uniprocessor systems return ERROR status.\n \n+   function taskMaskAffinitySet (tid : t_id; CPU_Set : unsigned) return int;\n+   pragma Convention (C, taskMaskAffinitySet);\n+   --  For SMP run-times set the CPU mask affinity.\n+   --  For uniprocessor systems return ERROR status.\n+\n end System.VxWorks.Ext;"}, {"sha": "a386af91d0fd8bc095e75376736dcb18416b4e30", "filename": "gcc/ada/s-vxwext.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                   B o d y                                --\n --                                                                          --\n---           Copyright (C) 2009-2010, Free Software Foundation, Inc.        --\n+--           Copyright (C) 2009-2011, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,4 +42,14 @@ package body System.VxWorks.Ext is\n       return ERROR;\n    end taskCpuAffinitySet;\n \n+   -------------------------\n+   -- taskMaskAffinitySet --\n+   -------------------------\n+\n+   function taskMaskAffinitySet (tid : t_id; CPU_Set : unsigned) return int is\n+      pragma Unreferenced (tid, CPU_Set);\n+   begin\n+      return ERROR;\n+   end taskMaskAffinitySet;\n+\n end System.VxWorks.Ext;"}, {"sha": "6e7cd16331a89d9127a0c55b77254c8ca9b09a3b", "filename": "gcc/ada/s-vxwext.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-vxwext.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext.ads?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                   S p e c                                --\n --                                                                          --\n---            Copyright (C) 2008-2010, Free Software Foundation, Inc.       --\n+--            Copyright (C) 2008-2011, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNARL is free software;  you can redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,6 +44,7 @@ package System.VxWorks.Ext is\n    type t_id is new Long_Integer;\n \n    subtype int is Interfaces.C.int;\n+   subtype unsigned is Interfaces.C.unsigned;\n \n    type Interrupt_Handler is access procedure (parameter : System.Address);\n    pragma Convention (C, Interrupt_Handler);\n@@ -96,4 +97,9 @@ package System.VxWorks.Ext is\n    --  For SMP run-times set the CPU affinity.\n    --  For uniprocessor systems return ERROR status.\n \n+   function taskMaskAffinitySet (tid : t_id; CPU_Set : unsigned) return int;\n+   pragma Convention (C, taskMaskAffinitySet);\n+   --  For SMP run-times set the CPU mask affinity.\n+   --  For uniprocessor systems return ERROR status.\n+\n end System.VxWorks.Ext;"}, {"sha": "803a6483ca4bd862eb58ced2849fe9ec7118ce2c", "filename": "gcc/ada/s-winext.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-winext.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fs-winext.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-winext.ads?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2009, Free Software Foundation, Inc.            --\n+--         Copyright (C) 2009-2011, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,6 +53,11 @@ package System.Win32.Ext is\n       dwIdealProcessor : ProcessorId) return DWORD;\n    pragma Import (Stdcall, SetThreadIdealProcessor, \"SetThreadIdealProcessor\");\n \n+   function SetThreadAffinityMask\n+     (hThread              : HANDLE;\n+      dwThreadAffinityMask : DWORD) return DWORD;\n+   pragma Import (Stdcall, SetThreadAffinityMask, \"SetThreadAffinityMask\");\n+\n    --------------\n    -- Com Port --\n    --------------"}, {"sha": "d0351d2cce14b944d70bc3d341f0338a5bc2cabf", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -3904,9 +3904,7 @@ package body Sem_Ch13 is\n             --  This seems dubious, this destroys the source tree in a manner\n             --  not detectable by ASIS ???\n \n-            if Operating_Mode = Check_Semantics\n-              and then ASIS_Mode\n-            then\n+            if Operating_Mode = Check_Semantics and then ASIS_Mode then\n                AtM_Nod :=\n                  Make_Attribute_Definition_Clause (Loc,\n                    Name       => New_Reference_To (Base_Type (Rectype), Loc),"}, {"sha": "6ce88d7506cb6eb561f4066b2459cb1ce1f9b9b4", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -30,7 +30,6 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Util; use Exp_Util;\n-with Expander; use Expander;\n with Fname;    use Fname;\n with Itypes;   use Itypes;\n with Lib;      use Lib;\n@@ -3352,14 +3351,19 @@ package body Sem_Ch4 is\n       Iterator : Node_Id;\n \n    begin\n-      --  Analyze construct with expansion disabled, because it will be\n-      --  rewritten as a loop during expansion.\n+      Set_Etype  (Ent,  Standard_Void_Type);\n+      Set_Scope  (Ent, Current_Scope);\n+      Set_Parent (Ent, N);\n \n-      Expander_Mode_Save_And_Set (False);\n       Check_SPARK_Restriction (\"quantified expression is not allowed\", N);\n \n-      Set_Etype  (Ent,  Standard_Void_Type);\n-      Set_Parent (Ent, N);\n+      --  If expansion is enabled, the condition is analyzed after rewritten\n+      --  as a loop. Otherwise we only need to set the type.\n+\n+      if Operating_Mode /= Check_Semantics then\n+         Set_Etype (N, Standard_Boolean);\n+         return;\n+      end if;\n \n       if Present (Loop_Parameter_Specification (N)) then\n          Iterator :=\n@@ -3390,7 +3394,6 @@ package body Sem_Ch4 is\n       Analyze (Condition (N));\n       End_Scope;\n       Set_Etype (N, Standard_Boolean);\n-      Expander_Mode_Restore;\n    end Analyze_Quantified_Expression;\n \n    -------------------"}, {"sha": "b576ba818d042da5c7e56ebd26494862e7bb1f64", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -2250,15 +2250,11 @@ package body Sem_Ch5 is\n          Analyze (Subt);\n       end if;\n \n-      --  If it is an expression, the name is pre-analyzed in the caller.\n-      --  If it it of a controlled type we need a block for the finalization\n-      --  actions. As for loop bounds that need finalization, we create a\n-      --  declaration and an assignment to trigger these actions.\n-\n-      if Present (Etype (Iter_Name))\n-        and then Is_Controlled (Etype (Iter_Name))\n-        and then not Is_Entity_Name (Iter_Name)\n-      then\n+      --  If the domain of iteration is an expression, create a declaration\n+      --  for it, so that finalization actions are introduced outside of the\n+      --  loop.\n+\n+      if not Is_Entity_Name (Iter_Name) then\n          declare\n             Id : constant Entity_Id := Make_Temporary (Loc, 'R', Iter_Name);\n "}, {"sha": "5e410990ff571a0fedfebc54ebddec42ff098363", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -8085,6 +8085,13 @@ package body Sem_Res is\n    begin\n       if not ALFA_Mode then\n \n+         --  If expansion is enabled, analysis is delayed until the expresssion\n+         --  is rewritten as a loop.\n+\n+         if Operating_Mode /= Check_Semantics then\n+            return;\n+         end if;\n+\n          --  The loop structure is already resolved during its analysis, only\n          --  the resolution of the condition needs to be done. Expansion is\n          --  disabled so that checks and other generated code are inserted in"}, {"sha": "e0e2901475117bf83ffbd0ab4c826175c5cc2821", "filename": "gcc/ada/vms_conv.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fvms_conv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37cbdc310038863a55e9f4a4669dbba964f289e/gcc%2Fada%2Fvms_conv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.adb?ref=c37cbdc310038863a55e9f4a4669dbba964f289e", "patch": "@@ -1799,6 +1799,16 @@ package body VMS_Conv is\n                          (Arg (Arg'First .. SwP),\n                           Command.Switches,\n                           Quiet => False);\n+\n+                     --  Special case for GNAT COMPILE /UNCHECKED...\n+                     --  because the corresponding switch --unchecked... is\n+                     --  for gnatmake, not for the compiler.\n+\n+                     if Cargs and then\n+                       Sw.Name.all = \"/UNCHECKED_SHARED_LIB_IMPORTS\"\n+                     then\n+                        Cargs := False;\n+                     end if;\n                   end if;\n \n                   if Sw /= null then"}]}