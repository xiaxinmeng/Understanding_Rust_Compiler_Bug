{"sha": "ee4af2ed0b7322884ec4ff537564683c3749b813", "node_id": "C_kwDOANBUbNoAKGVlNGFmMmVkMGI3MzIyODg0ZWM0ZmY1Mzc1NjQ2ODNjMzc0OWI4MTM", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-12-22T09:56:47Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-12-22T23:34:27Z"}, "message": "libstdc++: Avoid recursion in __nothrow_wait_cv::wait [PR105730]\n\nThe commit r12-5877-g9e18a25331fa25 removed the incorrect\nnoexcept-specifier from std::condition_variable::wait and gave the new\nsymbol version @@GLIBCXX_3.4.30. It also redefined the original symbol\nstd::condition_variable::wait(unique_lock<mutex>&)@GLIBCXX_3.4.11 as an\nalias for a new symbol, __gnu_cxx::__nothrow_wait_cv::wait, which still\nhas the incorrect noexcept guarantee. That __nothrow_wait_cv::wait is\njust a wrapper around the real condition_variable::wait which adds\nnoexcept and so terminates on a __forced_unwind exception.\n\nThis doesn't work on uclibc, possibly due to a dynamic linker bug. When\n__nothrow_wait_cv::wait calls the condition_variable::wait function it\nbinds to the alias symbol, which means it just calls itself recursively\nuntil the stack overflows.\n\nThis change avoids the possibility of a recursive call by changing the\n__nothrow_wait_cv::wait function so that instead of calling\ncondition_variable::wait it re-implements it. This requires accessing\nthe private _M_cond member of condition_variable, so we need to use the\ntrick of instantiating a template with the member-pointer of the private\nmember.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/105730\n\t* src/c++11/compatibility-condvar.cc (__nothrow_wait_cv::wait):\n\tAccess private data member of base class and call its wait\n\tmember.", "tree": {"sha": "f735e74fcd64757a2e6a282f2014251cf0dbd77f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f735e74fcd64757a2e6a282f2014251cf0dbd77f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee4af2ed0b7322884ec4ff537564683c3749b813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee4af2ed0b7322884ec4ff537564683c3749b813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee4af2ed0b7322884ec4ff537564683c3749b813", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee4af2ed0b7322884ec4ff537564683c3749b813/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f99b94865fa629cc2cc937128a812b6a23038446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f99b94865fa629cc2cc937128a812b6a23038446", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f99b94865fa629cc2cc937128a812b6a23038446"}], "stats": {"total": 22, "additions": 21, "deletions": 1}, "files": [{"sha": "3cef3bc071475a5c1fbc30e55b6ecdb9300b8712", "filename": "libstdc++-v3/src/c++11/compatibility-condvar.cc", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4af2ed0b7322884ec4ff537564683c3749b813/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcompatibility-condvar.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4af2ed0b7322884ec4ff537564683c3749b813/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcompatibility-condvar.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcompatibility-condvar.cc?ref=ee4af2ed0b7322884ec4ff537564683c3749b813", "patch": "@@ -67,6 +67,24 @@ _GLIBCXX_END_NAMESPACE_VERSION\n     && defined(_GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT)\n namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n {\n+namespace\n+{\n+  // Pointer-to-member for private std::condition_variable::_M_cond member.\n+  std::__condvar std::condition_variable::* __base_member;\n+\n+  template<std::__condvar std::condition_variable::*X>\n+    struct cracker\n+    { static std::__condvar std::condition_variable::* value; };\n+\n+  // Initializer for this static member also initializes __base_member.\n+  template<std::__condvar std::condition_variable::*X>\n+    std::__condvar std::condition_variable::*\n+      cracker<X>::value = __base_member = X;\n+\n+  // Explicit instantiation is allowed to access the private member.\n+  template class cracker<&std::condition_variable::_M_cond>;\n+}\n+\n struct __nothrow_wait_cv : std::condition_variable\n {\n   void wait(std::unique_lock<std::mutex>&) noexcept;\n@@ -76,7 +94,9 @@ __attribute__((used))\n void\n __nothrow_wait_cv::wait(std::unique_lock<std::mutex>& lock) noexcept\n {\n-  this->condition_variable::wait(lock);\n+  // In theory this could be simply this->std::condition_variable::wait(lock)\n+  // but with uclibc that binds to the @GLIBCXX_3.4.11 symbol, see PR 105730.\n+  (this->*__base_member).wait(*lock.mutex());\n }\n } // namespace __gnu_cxx\n "}]}