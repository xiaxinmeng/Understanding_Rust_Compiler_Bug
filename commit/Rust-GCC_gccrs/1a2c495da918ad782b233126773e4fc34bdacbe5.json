{"sha": "1a2c495da918ad782b233126773e4fc34bdacbe5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEyYzQ5NWRhOTE4YWQ3ODJiMjMzMTI2NzczZTRmYzM0YmRhY2JlNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T07:46:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T07:46:59Z"}, "message": "re PR ada/23646 (Ada testsuite hangs -- many new failures)\n\nPR ada/23646\n\n\t* s-mastop-tru64.adb, s-mastop-irix.adb, s-mastop-vms.adb\n\t(Enter_Handler, Set_Signal_Machine_State): Removed, no longer used.\n\tRemove reference to System.Exceptions.\n\n\t* s-mastop-x86.adb: Removed, no longer used.\n\n\t* s-traceb-mastop.adb: Adjust calls to Pop_Frame.\n\n\t* a-excach.adb: Minor reformatting.\n\n\t* a-except.ads, a-except.adb: Remove global Warnings (Off) pragma, and\n\tinstead fix new warnings that were hidden by this change.\n\t(AAA, ZZZ): Removed, replaced by...\n\t(Code_Address_For_AAA, Code_Address_For_ZZZ): ... these functions, who\n\tare used instead of constants, to help make Ada.Exception truly\n\tpreelaborate.\n\t(Rcheck_*, Raise_Constraint_Error, Raise_Program_Error,\n\tRaise_Storage_Error): File is now a System.Address, to simplify code.\n\t(Elab code): Removed, no longer used.\n\t(Null_Occurrence): Remove Warnings Off and make this construct\n\tpreelaborate.\n\tRemove code related to front-end zero cost exception handling, since\n\tit is no longer used.\n\tRemove -gnatL/-gnatZ switches.\n\n\t* a-exexda.adb (Append_Info_Exception_Name, Set_Exception_C_Msg):\n\tUpdate use of Except.Msg.\n\n\t* gnat1drv.adb, inline.adb, bindgen.adb, debug.adb, exp_ch11.ads,\n\tfreeze.adb, frontend.adb, lib.adb, exp_ch11.adb: Remove code related\n\tto front-end zero cost exception handling, since it is no longer used.\n\tRemove -gnatL/-gnatZ switches.\n\n\t* lib-writ.ads: Minor reformatting\n\tRemove doc of UX\n\n\t* Makefile.rtl: Remove references to s-except*, s-mastop-x86*\n\n\t* Make-lang.in: Remove references to s-except.ads\n\n\t* s-except.ads: Removed, no longer used.\n\n\t* s-mastop.ads, s-mastop.adb:\n\t(Enter_Handler, Set_Signal_Machine_State): Removed, no longer used.\n\tRemove reference to System.Exceptions.\n\n\t* raise.h, usage.adb, targparm.adb, targparm.ads, switch-m.adb,\n\tswitch-b.adb: Remove code related to front-end zero cost exception\n\thandling, since it is no longer used.\n\tRemove -gnatL/-gnatZ switches.\n\nFrom-SVN: r103848", "tree": {"sha": "c8c4bdeea1597cf43807ca89f524b62979d2208c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8c4bdeea1597cf43807ca89f524b62979d2208c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a2c495da918ad782b233126773e4fc34bdacbe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a2c495da918ad782b233126773e4fc34bdacbe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a2c495da918ad782b233126773e4fc34bdacbe5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a2c495da918ad782b233126773e4fc34bdacbe5/comments", "author": null, "committer": null, "parents": [{"sha": "3b91d88ea1deb4d40b294c12536cbfc9f8137d54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b91d88ea1deb4d40b294c12536cbfc9f8137d54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b91d88ea1deb4d40b294c12536cbfc9f8137d54"}], "stats": {"total": 3305, "additions": 255, "deletions": 3050}, "files": [{"sha": "8b476305152da7f0122724c24c7e77968daec552", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -113,7 +113,7 @@ GNAT1_C_OBJS = ada/b_gnat1.o ada/adadecode.o ada/adaint.o ada/cstreams.o \\\n GNAT_ADA_OBJS = ada/ada.o ada/a-charac.o ada/a-chlat1.o ada/a-except.o \\\n  ada/a-elchha.o ada/a-ioexce.o \\\n  ada/s-memory.o ada/s-carun8.o ada/s-casuti.o ada/s-strcom.o ada/s-purexc.o \\\n- ada/s-htable.o ada/s-traceb.o ada/s-mastop.o ada/s-except.o ada/ali.o \\\n+ ada/s-htable.o ada/s-traceb.o ada/s-mastop.o ada/ali.o \\\n  ada/alloc.o ada/atree.o ada/butil.o ada/casing.o ada/checks.o ada/comperr.o \\\n  ada/csets.o ada/cstand.o ada/debug.o ada/debug_a.o ada/einfo.o ada/elists.o \\\n  ada/errout.o ada/erroutc.o ada/err_vars.o ada/eval_fat.o ada/exp_attr.o \\\n@@ -215,7 +215,6 @@ GNATBIND_OBJS = \\\n  ada/s-casuti.o   \\\n  ada/s-crc32.o    \\\n  ada/s-crtl.o     \\\n- ada/s-except.o   \\\n  ada/s-exctab.o   \\\n  ada/s-htable.o   \\\n  ada/s-imgenu.o   \\\n@@ -1101,7 +1100,7 @@ ada/a-except.o : ada/ada.ads ada/a-except.ads ada/a-except.adb \\\n    ada/a-excach.adb ada/a-exexda.adb ada/a-exexpr.adb ada/a-exextr.adb \\\n    ada/a-elchha.ads ada/a-excpol.adb ada/a-exstat.adb ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/interfac.ads ada/system.ads ada/s-exctab.ads \\\n-   ada/s-except.ads ada/s-mastop.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-mastop.ads ada/s-secsta.ads ada/s-soflin.ads \\\n    ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n    ada/s-traceb.ads ada/s-traent.ads ada/s-traent.adb ada/s-unstyp.ads \\\n    ada/unchconv.ads \n@@ -2606,9 +2605,6 @@ ada/s-crc32.o : ada/interfac.ads ada/system.ads ada/s-crc32.ads \\\n \n ada/s-crtl.o : ada/system.ads ada/s-crtl.ads ada/s-parame.ads \n \n-ada/s-except.o : ada/ada.ads ada/a-except.ads ada/system.ads \\\n-   ada/s-except.ads ada/s-stalib.ads ada/s-traent.ads ada/unchconv.ads \n-\n ada/s-exctab.o : ada/ada.ads ada/a-except.ads ada/a-uncdea.ads \\\n    ada/system.ads ada/s-exctab.ads ada/s-exctab.adb ada/s-htable.ads \\\n    ada/s-htable.adb ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n@@ -2621,7 +2617,7 @@ ada/s-imgenu.o : ada/system.ads ada/s-imgenu.ads ada/s-imgenu.adb \\\n    ada/s-secsta.ads ada/s-stoele.ads ada/s-stoele.adb ada/unchconv.ads \n \n ada/s-mastop.o : ada/ada.ads ada/a-except.ads ada/system.ads \\\n-   ada/s-except.ads ada/s-mastop.ads ada/s-mastop.adb ada/s-stalib.ads \\\n+   ada/s-mastop.ads ada/s-mastop.adb ada/s-stalib.ads \\\n    ada/s-stoele.ads ada/s-stoele.adb ada/s-traent.ads ada/unchconv.ads \n \n ada/s-memory.o : ada/ada.ads ada/a-except.ads ada/system.ads \\\n@@ -2639,7 +2635,7 @@ ada/s-secsta.o : ada/ada.ads ada/a-except.ads ada/system.ads \\\n    ada/s-traent.ads ada/unchconv.ads ada/unchdeal.ads \n \n ada/s-soflin.o : ada/ada.ads ada/a-except.ads ada/system.ads \\\n-   ada/s-except.ads ada/s-mastop.ads ada/s-parame.ads ada/s-secsta.ads \\\n+   ada/s-mastop.ads ada/s-parame.ads ada/s-secsta.ads \\\n    ada/s-soflin.ads ada/s-soflin.adb ada/s-stache.ads ada/s-stalib.ads \\\n    ada/s-stoele.ads ada/s-stoele.adb ada/s-traent.ads ada/unchconv.ads \n "}, {"sha": "aa92689fb11558fbc68fa39d8e4be9f59a35795a", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -375,7 +375,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-crc32$(objext)  \\\n   s-direio$(objext) \\\n   s-errrep$(objext) \\\n-  s-except$(objext) \\\n   s-exctab$(objext) \\\n   s-exnint$(objext) \\\n   s-exnllf$(objext) \\"}, {"sha": "f41131509047fead12890d251822044024bff8cb", "filename": "gcc/ada/a-excach.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fa-excach.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fa-excach.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-excach.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -71,7 +71,6 @@ begin\n          Exclude_Min => Code_Address_For_AAA,\n          Exclude_Max => Code_Address_For_ZZZ,\n          Skip_Frames => 3);\n-\n    end if;\n \n end Call_Chain;"}, {"sha": "a676b91c2ed7d123a3f6762dd0016460f9adfe3b", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 169, "deletions": 194, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -35,14 +35,9 @@ pragma Polling (Off);\n --  We must turn polling off for this unit, because otherwise we get\n --  elaboration circularities with System.Exception_Tables.\n \n-pragma Warnings (Off);\n---  Since several constructs give warnings in 3.14a1, including unreferenced\n---  variables and pragma Unreferenced itself.\n-\n with System;                  use System;\n with System.Standard_Library; use System.Standard_Library;\n with System.Soft_Links;       use System.Soft_Links;\n-with System.Machine_State_Operations; use System.Machine_State_Operations;\n \n package body Ada.Exceptions is\n \n@@ -71,39 +66,30 @@ package body Ada.Exceptions is\n    --  from C clients using the given external name, even though they are not\n    --  technically visible in the Ada sense.\n \n-   procedure AAA;\n-   procedure ZZZ;\n-   --  Mark start and end of procedures in this package\n+   function Code_Address_For_AAA return System.Address;\n+   function Code_Address_For_ZZZ return System.Address;\n+   --  Return start and end of procedures in this package\n    --\n-   --  The AAA and ZZZ procedures are used to provide exclusion bounds in\n+   --  These procedures are used to provide exclusion bounds in\n    --  calls to Call_Chain at exception raise points from this unit. The\n    --  purpose is to arrange for the exception tracebacks not to include\n    --  frames from routines involved in the raise process, as these are\n    --  meaningless from the user's standpoint.\n    --\n    --  For these bounds to be meaningful, we need to ensure that the object\n    --  code for the routines involved in processing a raise is located after\n-   --  the object code for AAA and before the object code for ZZZ. This will\n-   --  indeed be the case as long as the following rules are respected:\n+   --  the object code Code_Address_For_AAA and before the object code\n+   --  Code_Address_For_ZZZ. This will indeed be the case as long as the\n+   --  following rules are respected:\n    --\n    --  1) The bodies of the subprograms involved in processing a raise\n-   --     are located after the body of AAA and before the body of ZZZ.\n+   --     are located after the body of Code_Address_For_AAA and before the\n+   --     body of Code_Address_For_ZZZ.\n    --\n    --  2) No pragma Inline applies to any of these subprograms, as this\n    --     could delay the corresponding assembly output until the end of\n    --     the unit.\n \n-   Code_Address_For_AAA, Code_Address_For_ZZZ : System.Address;\n-   --  Used to represent addresses really inside the code range for AAA and\n-   --  ZZZ, initialized to the address of a label inside the corresponding\n-   --  procedure. This is initialization takes place inside the procedures\n-   --  themselves, which are called as part of the elaboration code.\n-   --\n-   --  We are doing this instead of merely using Proc'Address because on some\n-   --  platforms the latter does not yield the address we want, but the\n-   --  address of a stub or of a descriptor instead. This is the case at least\n-   --  on Alpha-VMS and PA-HPUX.\n-\n    procedure Call_Chain (Excep : EOA);\n    --  Store up to Max_Tracebacks in Excep, corresponding to the current\n    --  call chain.\n@@ -139,9 +125,9 @@ package body Ada.Exceptions is\n \n       procedure Set_Exception_C_Msg\n         (Id   : Exception_Id;\n-         Msg1 : Big_String_Ptr;\n+         Msg1 : System.Address;\n          Line : Integer        := 0;\n-         Msg2 : Big_String_Ptr := null);\n+         Msg2 : System.Address := System.Null_Address);\n       --  This routine is called to setup the exception referenced by the\n       --  Current_Excep field in the TSD to contain the indicated Id value\n       --  and message. Msg1 is a null terminated string which is generated\n@@ -210,7 +196,7 @@ package body Ada.Exceptions is\n       pragma Export\n         (Ada, Tailored_Exception_Information,\n            \"__gnat_tailored_exception_information\");\n-      --  This is currently used by System.Tasking.Stages.\n+      --  This is currently used by System.Tasking.Stages\n \n    end Exception_Data;\n \n@@ -329,61 +315,61 @@ package body Ada.Exceptions is\n \n    procedure Raise_With_Location_And_Msg\n      (E : Exception_Id;\n-      F : Big_String_Ptr;\n+      F : System.Address;\n       L : Integer;\n-      M : Big_String_Ptr := null);\n+      M : System.Address := System.Null_Address);\n    pragma No_Return (Raise_With_Location_And_Msg);\n    --  Raise an exception with given exception id value. A filename and line\n    --  number is associated with the raise and is stored in the exception\n    --  occurrence and in addition a string message M is appended to\n    --  this (if M is not null).\n \n    procedure Raise_Constraint_Error\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer);\n    pragma No_Return (Raise_Constraint_Error);\n    pragma Export\n      (C, Raise_Constraint_Error, \"__gnat_raise_constraint_error\");\n    --  Raise constraint error with file:line information\n \n    procedure Raise_Constraint_Error_Msg\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer;\n-      Msg  : Big_String_Ptr);\n+      Msg  : System.Address);\n    pragma No_Return (Raise_Constraint_Error_Msg);\n    pragma Export\n      (C, Raise_Constraint_Error_Msg, \"__gnat_raise_constraint_error_msg\");\n    --  Raise constraint error with file:line + msg information\n \n    procedure Raise_Program_Error\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer);\n    pragma No_Return (Raise_Program_Error);\n    pragma Export\n      (C, Raise_Program_Error, \"__gnat_raise_program_error\");\n    --  Raise program error with file:line information\n \n    procedure Raise_Program_Error_Msg\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer;\n-      Msg  : Big_String_Ptr);\n+      Msg  : System.Address);\n    pragma No_Return (Raise_Program_Error_Msg);\n    pragma Export\n      (C, Raise_Program_Error_Msg, \"__gnat_raise_program_error_msg\");\n    --  Raise program error with file:line + msg information\n \n    procedure Raise_Storage_Error\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer);\n    pragma No_Return (Raise_Storage_Error);\n    pragma Export\n      (C, Raise_Storage_Error, \"__gnat_raise_storage_error\");\n    --  Raise storage error with file:line information\n \n    procedure Raise_Storage_Error_Msg\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer;\n-      Msg  : Big_String_Ptr);\n+      Msg  : System.Address);\n    pragma No_Return (Raise_Storage_Error_Msg);\n    pragma Export\n      (C, Raise_Storage_Error_Msg, \"__gnat_raise_storage_error_msg\");\n@@ -454,37 +440,37 @@ package body Ada.Exceptions is\n    --  to the codes defined in Types.ads and a-types.h (for example,\n    --  the name Rcheck_05 refers to the Reason whose Pos code is 5).\n \n-   procedure Rcheck_00 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_01 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_02 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_03 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_04 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_05 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_06 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_07 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_08 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_09 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_10 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_11 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_12 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_13 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_14 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_15 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_16 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_17 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_18 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_19 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_20 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_21 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_22 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_23 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_24 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_25 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_26 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_27 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_28 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_29 (File : Big_String_Ptr; Line : Integer);\n-   procedure Rcheck_30 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_00 (File : System.Address; Line : Integer);\n+   procedure Rcheck_01 (File : System.Address; Line : Integer);\n+   procedure Rcheck_02 (File : System.Address; Line : Integer);\n+   procedure Rcheck_03 (File : System.Address; Line : Integer);\n+   procedure Rcheck_04 (File : System.Address; Line : Integer);\n+   procedure Rcheck_05 (File : System.Address; Line : Integer);\n+   procedure Rcheck_06 (File : System.Address; Line : Integer);\n+   procedure Rcheck_07 (File : System.Address; Line : Integer);\n+   procedure Rcheck_08 (File : System.Address; Line : Integer);\n+   procedure Rcheck_09 (File : System.Address; Line : Integer);\n+   procedure Rcheck_10 (File : System.Address; Line : Integer);\n+   procedure Rcheck_11 (File : System.Address; Line : Integer);\n+   procedure Rcheck_12 (File : System.Address; Line : Integer);\n+   procedure Rcheck_13 (File : System.Address; Line : Integer);\n+   procedure Rcheck_14 (File : System.Address; Line : Integer);\n+   procedure Rcheck_15 (File : System.Address; Line : Integer);\n+   procedure Rcheck_16 (File : System.Address; Line : Integer);\n+   procedure Rcheck_17 (File : System.Address; Line : Integer);\n+   procedure Rcheck_18 (File : System.Address; Line : Integer);\n+   procedure Rcheck_19 (File : System.Address; Line : Integer);\n+   procedure Rcheck_20 (File : System.Address; Line : Integer);\n+   procedure Rcheck_21 (File : System.Address; Line : Integer);\n+   procedure Rcheck_22 (File : System.Address; Line : Integer);\n+   procedure Rcheck_23 (File : System.Address; Line : Integer);\n+   procedure Rcheck_24 (File : System.Address; Line : Integer);\n+   procedure Rcheck_25 (File : System.Address; Line : Integer);\n+   procedure Rcheck_26 (File : System.Address; Line : Integer);\n+   procedure Rcheck_27 (File : System.Address; Line : Integer);\n+   procedure Rcheck_28 (File : System.Address; Line : Integer);\n+   procedure Rcheck_29 (File : System.Address; Line : Integer);\n+   procedure Rcheck_30 (File : System.Address; Line : Integer);\n \n    pragma Export (C, Rcheck_00, \"__gnat_rcheck_00\");\n    pragma Export (C, Rcheck_01, \"__gnat_rcheck_01\");\n@@ -611,19 +597,25 @@ package body Ada.Exceptions is\n    --  The actual polling routine is separate, so that it can easily\n    --  be replaced with a target dependent version.\n \n-   ---------\n-   -- AAA --\n-   ---------\n+   --------------------------\n+   -- Code_Address_For_AAA --\n+   --------------------------\n \n-   --  This dummy procedure gives us the start of the PC range for addresses\n+   --  This function gives us the start of the PC range for addresses\n    --  within the exception unit itself. We hope that gigi/gcc keep all the\n    --  procedures in their original order!\n \n-   procedure AAA is\n+   function Code_Address_For_AAA return System.Address is\n    begin\n+      --  We are using a label instead of merely using\n+      --  Code_Address_For_AAA'Address because on some platforms the latter\n+      --  does not yield the address we want, but the address of a stub or of\n+      --  a descriptor instead. This is the case at least on Alpha-VMS and\n+      --  PA-HPUX.\n+\n       <<Start_Of_AAA>>\n-      Code_Address_For_AAA := Start_Of_AAA'Address;\n-   end AAA;\n+      return Start_Of_AAA'Address;\n+   end Code_Address_For_AAA;\n \n    ----------------\n    -- Call_Chain --\n@@ -714,7 +706,7 @@ package body Ada.Exceptions is\n          raise Constraint_Error;\n       end if;\n \n-      return Id.Full_Name.all (1 .. Id.Name_Length - 1);\n+      return To_Ptr (Id.Full_Name) (1 .. Id.Name_Length - 1);\n    end Exception_Name;\n \n    function Exception_Name (X : Exception_Occurrence) return String is\n@@ -793,7 +785,7 @@ package body Ada.Exceptions is\n       --  This is so the debugger can reliably inspect the parameter\n \n       Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n-      Excep       : EOA := Get_Current_Excep.all;\n+      Excep       : constant EOA := Get_Current_Excep.all;\n \n    begin\n       --  WARNING : There should be no exception handler for this body\n@@ -803,43 +795,44 @@ package body Ada.Exceptions is\n       --  we are handling, which would completely break the whole design\n       --  of this procedure.\n \n-      --  Processing varies between zero cost and setjmp/lonjmp processing.\n+      --  Processing varies between zero cost and setjmp/lonjmp processing\n \n       if Zero_Cost_Exceptions /= 0 then\n \n-         --  Use the front-end tables to propagate if we have them, otherwise\n-         --  resort to the GCC back-end alternative. Backtrace computation is\n-         --  performed, if required, by the underlying routine. Notifications\n-         --  for the debugger are also not performed here, because we do not\n-         --  yet know if the exception is handled.\n+         --  Use the GCC back-end to propagate the exception. Backtrace\n+         --  computation is performed, if required, by the underlying routine.\n+         --  Notifications for the debugger are also not performed here,\n+         --  because we do not yet know if the exception is handled.\n \n          Exception_Propagation.Propagate_Exception (From_Signal_Handler);\n \n       else\n-         --  Compute the backtrace for this occurrence if the corresponding\n-         --  binder option has been set. Call_Chain takes care of the reraise\n-         --  case.\n+         --  Compute the backtrace for this occurrence if corresponding binder\n+         --  option has been set. Call_Chain takes care of the reraise case.\n \n          Call_Chain (Excep);\n+\n+         --  Note on above call to Call_Chain:\n+\n          --  We used to only do this if From_Signal_Handler was not set,\n          --  based on the assumption that backtracing from a signal handler\n          --  would not work due to stack layout oddities. However, since\n-         --\n+\n          --   1. The flag is never set in tasking programs (Notify_Exception\n          --      performs regular raise statements), and\n-         --\n+\n          --   2. No problem has shown up in tasking programs around here so\n          --      far, this turned out to be too strong an assumption.\n-         --\n+\n          --  As, in addition, the test was\n-         --\n+\n          --   1. preventing the production of backtraces in non-tasking\n          --      programs, and\n-         --\n+\n          --   2. introducing a behavior inconsistency between\n          --      the tasking and non-tasking cases,\n-         --\n-         --  we have simply removed it.\n+\n+         --  we have simply removed it\n \n          --  If the jump buffer pointer is non-null, transfer control using\n          --  it. Otherwise announce an unhandled exception (note that this\n@@ -872,7 +865,7 @@ package body Ada.Exceptions is\n    ----------------------------\n \n    procedure Raise_Constraint_Error\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer)\n    is\n    begin\n@@ -885,9 +878,9 @@ package body Ada.Exceptions is\n    --------------------------------\n \n    procedure Raise_Constraint_Error_Msg\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer;\n-      Msg  : Big_String_Ptr)\n+      Msg  : System.Address)\n    is\n    begin\n       Raise_With_Location_And_Msg\n@@ -941,7 +934,7 @@ package body Ada.Exceptions is\n \n    procedure Raise_From_Signal_Handler\n      (E : Exception_Id;\n-      M : Big_String_Ptr)\n+      M : System.Address)\n    is\n    begin\n       Exception_Data.Set_Exception_C_Msg (E, M);\n@@ -954,7 +947,7 @@ package body Ada.Exceptions is\n    -------------------------\n \n    procedure Raise_Program_Error\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer)\n    is\n    begin\n@@ -967,9 +960,9 @@ package body Ada.Exceptions is\n    -----------------------------\n \n    procedure Raise_Program_Error_Msg\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer;\n-      Msg  : Big_String_Ptr)\n+      Msg  : System.Address)\n    is\n    begin\n       Raise_With_Location_And_Msg\n@@ -981,7 +974,7 @@ package body Ada.Exceptions is\n    -------------------------\n \n    procedure Raise_Storage_Error\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer)\n    is\n    begin\n@@ -994,9 +987,9 @@ package body Ada.Exceptions is\n    -----------------------------\n \n    procedure Raise_Storage_Error_Msg\n-     (File : Big_String_Ptr;\n+     (File : System.Address;\n       Line : Integer;\n-      Msg  : Big_String_Ptr)\n+      Msg  : System.Address)\n    is\n    begin\n       Raise_With_Location_And_Msg\n@@ -1009,9 +1002,9 @@ package body Ada.Exceptions is\n \n    procedure Raise_With_Location_And_Msg\n      (E : Exception_Id;\n-      F : Big_String_Ptr;\n+      F : System.Address;\n       L : Integer;\n-      M : Big_String_Ptr := null)\n+      M : System.Address := System.Null_Address)\n    is\n    begin\n       Exception_Data.Set_Exception_C_Msg (E, F, L, M);\n@@ -1042,159 +1035,159 @@ package body Ada.Exceptions is\n    -- Calls to Run-Time Check Routines --\n    --------------------------------------\n \n-   procedure Rcheck_00 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_00 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_00'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_00'Address);\n    end Rcheck_00;\n \n-   procedure Rcheck_01 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_01 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_01'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_01'Address);\n    end Rcheck_01;\n \n-   procedure Rcheck_02 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_02 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_02'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_02'Address);\n    end Rcheck_02;\n \n-   procedure Rcheck_03 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_03 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_03'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_03'Address);\n    end Rcheck_03;\n \n-   procedure Rcheck_04 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_04 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_04'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_04'Address);\n    end Rcheck_04;\n \n-   procedure Rcheck_05 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_05 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_05'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_05'Address);\n    end Rcheck_05;\n \n-   procedure Rcheck_06 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_06 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_06'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_06'Address);\n    end Rcheck_06;\n \n-   procedure Rcheck_07 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_07 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_07'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_07'Address);\n    end Rcheck_07;\n \n-   procedure Rcheck_08 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_08 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_08'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_08'Address);\n    end Rcheck_08;\n \n-   procedure Rcheck_09 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_09 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_09'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_09'Address);\n    end Rcheck_09;\n \n-   procedure Rcheck_10 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_10 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_10'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_10'Address);\n    end Rcheck_10;\n \n-   procedure Rcheck_11 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_11 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_11'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_11'Address);\n    end Rcheck_11;\n \n-   procedure Rcheck_12 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_12 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_12'Address));\n+      Raise_Constraint_Error_Msg (File, Line, Rmsg_12'Address);\n    end Rcheck_12;\n \n-   procedure Rcheck_13 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_13 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_13'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_13'Address);\n    end Rcheck_13;\n \n-   procedure Rcheck_14 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_14 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_14'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_14'Address);\n    end Rcheck_14;\n \n-   procedure Rcheck_15 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_15 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_15'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_15'Address);\n    end Rcheck_15;\n \n-   procedure Rcheck_16 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_16 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_16'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_16'Address);\n    end Rcheck_16;\n \n-   procedure Rcheck_17 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_17 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_17'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_17'Address);\n    end Rcheck_17;\n \n-   procedure Rcheck_18 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_18 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_18'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_18'Address);\n    end Rcheck_18;\n \n-   procedure Rcheck_19 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_19 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_19'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_19'Address);\n    end Rcheck_19;\n \n-   procedure Rcheck_20 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_20 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_20'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_20'Address);\n    end Rcheck_20;\n \n-   procedure Rcheck_21 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_21 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_21'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_21'Address);\n    end Rcheck_21;\n \n-   procedure Rcheck_22 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_22 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_22'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_22'Address);\n    end Rcheck_22;\n \n-   procedure Rcheck_23 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_23 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_23'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_23'Address);\n    end Rcheck_23;\n \n-   procedure Rcheck_24 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_24 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_24'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_24'Address);\n    end Rcheck_24;\n \n-   procedure Rcheck_25 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_25 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_25'Address));\n+      Raise_Program_Error_Msg (File, Line, Rmsg_25'Address);\n    end Rcheck_25;\n \n-   procedure Rcheck_26 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_26 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_26'Address));\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_26'Address);\n    end Rcheck_26;\n \n-   procedure Rcheck_27 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_27 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_27'Address));\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_27'Address);\n    end Rcheck_27;\n \n-   procedure Rcheck_28 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_28 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_28'Address));\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_28'Address);\n    end Rcheck_28;\n \n-   procedure Rcheck_29 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_29 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_29'Address));\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_29'Address);\n    end Rcheck_29;\n \n-   procedure Rcheck_30 (File : Big_String_Ptr; Line : Integer) is\n+   procedure Rcheck_30 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_30'Address));\n+      Raise_Storage_Error_Msg (File, Line, Rmsg_30'Address);\n    end Rcheck_30;\n \n    -------------\n@@ -1263,7 +1256,7 @@ package body Ada.Exceptions is\n    end Save_Occurrence;\n \n    function Save_Occurrence (Source : Exception_Occurrence) return EOA is\n-      Target : EOA := new Exception_Occurrence;\n+      Target : constant EOA := new Exception_Occurrence;\n    begin\n       Save_Occurrence (Target.all, Source);\n       return Target;\n@@ -1348,8 +1341,7 @@ package body Ada.Exceptions is\n    begin\n       Exception_Data.Set_Exception_Msg (E, Message);\n \n-      --  DO NOT CALL Abort_Defer.all; !!!!\n-      --  why not??? would be nice to have more comments here\n+      --  Do not call Abort_Defer.all, as specified by the spec\n \n       Raise_Current_Excep (E);\n    end Raise_Exception_No_Defer;\n@@ -1378,35 +1370,18 @@ package body Ada.Exceptions is\n       end loop;\n    end To_Stderr;\n \n-   ---------\n-   -- ZZZ --\n-   ---------\n+   --------------------------\n+   -- Code_Address_For_ZZZ --\n+   --------------------------\n \n-   --  This dummy procedure gives us the end of the PC range for addresses\n+   --  This function gives us the end of the PC range for addresses\n    --  within the exception unit itself. We hope that gigi/gcc keeps all the\n    --  procedures in their original order!\n \n-   procedure ZZZ is\n+   function Code_Address_For_ZZZ return System.Address is\n    begin\n       <<Start_Of_ZZZ>>\n-      Code_Address_For_ZZZ := Start_Of_ZZZ'Address;\n-   end ZZZ;\n-\n-begin\n-   pragma Warnings (Off);\n-   --  Allow calls to non-static subprograms in Ada 2005 mode where this\n-   --  package will be implicitly categorized as Preelaborate. See AI-362 for\n-   --  details. It is safe in the context of the run-time to violate the rules!\n-\n-   --  Allocate the Non-Tasking Machine_State\n-\n-   Set_Machine_State_Addr_NT (System.Address (Allocate_Machine_State));\n-\n-   --  Call the AAA/ZZZ routines to setup the code addresses for the\n-   --  bounds of this unit.\n-\n-   AAA;\n-   ZZZ;\n+      return Start_Of_ZZZ'Address;\n+   end Code_Address_For_ZZZ;\n \n-   pragma Warnings (On);\n end Ada.Exceptions;"}, {"sha": "a93f056544edd3d834d3044193b529af3bfa5151", "filename": "gcc/ada/a-except.ads", "status": "modified", "additions": 31, "deletions": 46, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fa-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fa-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.ads?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -39,24 +39,18 @@ pragma Polling (Off);\n --  We must turn polling off for this unit, because otherwise we get\n --  elaboration circularities with ourself.\n \n-pragma Warnings (Off);\n---  Allow withing of non-Preelaborated units in Ada 2005 mode where this\n---  package will be categorized as Preelaborate. See AI-362 for details.\n---  It is safe in the context of the run-time to violate the rules!\n-\n with System;\n with System.Parameters;\n with System.Standard_Library;\n with System.Traceback_Entries;\n-pragma Warnings (On);\n \n package Ada.Exceptions is\n-pragma Warnings (Off);\n-pragma Preelaborate_05 (Exceptions);\n-pragma Warnings (On);\n---  In accordance with Ada 2005 AI-362. The warnings pragmas are so that we can\n---  compile this using older compiler versions, which will ignore the pragma,\n---  which is fine for the bootstrap.\n+   pragma Warnings (Off);\n+   pragma Preelaborate_05;\n+   pragma Warnings (On);\n+   --  In accordance with Ada 2005 AI-362. The warnings pragmas are so that we\n+   --  can compile this using older compiler versions, which will ignore the\n+   --  pragma, which is fine for the bootstrap.\n \n    type Exception_Id is private;\n    Null_Id : constant Exception_Id;\n@@ -127,10 +121,9 @@ private\n    ------------------\n \n    subtype Code_Loc is System.Address;\n-   --  Code location used in building exception tables and for call\n-   --  addresses when propagating an exception.\n-   --  Values of this type are created by using Label'Address or\n-   --  extracted from machine states using Get_Code_Loc.\n+   --  Code location used in building exception tables and for call addresses\n+   --  when propagating an exception. Values of this type are created by using\n+   --  Label'Address or extracted from machine states using Get_Code_Loc.\n \n    Null_Loc : constant Code_Loc := System.Null_Address;\n    --  Null code location, used to flag outer level frame\n@@ -161,12 +154,12 @@ private\n    --  to be in the visible part, since this is set by the reference manual).\n \n    function Exception_Name_Simple (X : Exception_Occurrence) return String;\n-   --  Like Exception_Name, but returns the simple non-qualified name of\n-   --  the exception. This is used to implement the Exception_Name function\n-   --  in Current_Exceptions (the DEC compatible unit). It is called from\n-   --  the compiler generated code (using Rtsfind, which does not respect\n-   --  the private barrier, so we can place this function in the private\n-   --  part where the compiler can find it, but the spec is unchanged.)\n+   --  Like Exception_Name, but returns the simple non-qualified name of the\n+   --  exception. This is used to implement the Exception_Name function in\n+   --  Current_Exceptions (the DEC compatible unit). It is called from the\n+   --  compiler generated code (using Rtsfind, which does not respect the\n+   --  private barrier, so we can place this function in the private part\n+   --  where the compiler can find it, but the spec is unchanged.)\n \n    procedure Raise_Exception_Always (E : Exception_Id; Message : String := \"\");\n    pragma No_Return (Raise_Exception_Always);\n@@ -179,22 +172,21 @@ private\n \n    procedure Raise_From_Signal_Handler\n      (E : Exception_Id;\n-      M : SSL.Big_String_Ptr);\n+      M : System.Address);\n    pragma Export\n      (Ada, Raise_From_Signal_Handler,\n            \"ada__exceptions__raise_from_signal_handler\");\n    pragma No_Return (Raise_From_Signal_Handler);\n-   --  This routine is used to raise an exception from a signal handler.\n-   --  The signal handler has already stored the machine state (i.e. the\n-   --  state that corresponds to the location at which the signal was\n-   --  raised). E is the Exception_Id specifying what exception is being\n-   --  raised, and M is a pointer to a null-terminated string which is the\n-   --  message to be raised. Note that this routine never returns, so it is\n-   --  permissible to simply jump to this routine, rather than call it. This\n-   --  may be appropriate for systems where the right way to get out of a\n-   --  signal handler is to alter the PC value in the machine state or in\n-   --  some other way ask the operating system to return here rather than\n-   --  to the original location.\n+   --  This routine is used to raise an exception from a signal handler. The\n+   --  signal handler has already stored the machine state (i.e. the state that\n+   --  corresponds to the location at which the signal was raised). E is the\n+   --  Exception_Id specifying what exception is being raised, and M is a\n+   --  pointer to a null-terminated string which is the message to be raised.\n+   --  Note that this routine never returns, so it is permissible to simply\n+   --  jump to this routine, rather than call it. This may be appropriate for\n+   --  systems where the right way to get out of signal handler is to alter the\n+   --  PC value in the machine state or in some other way ask the operating\n+   --  system to return here rather than to the original location.\n \n    procedure Reraise_Occurrence_Always (X : Exception_Occurrence);\n    pragma No_Return (Reraise_Occurrence_Always);\n@@ -207,8 +199,8 @@ private\n    pragma No_Return (Reraise_Occurrence_No_Defer);\n    --  Exactly like Reraise_Occurrence, except that abort is not deferred\n    --  before the call and the parameter X is known not to be the null\n-   --  occurrence. This is used in generated code when it is known\n-   --  that abort is already deferred.\n+   --  occurrence. This is used in generated code when it is known that\n+   --  abort is already deferred.\n \n    -----------------------\n    -- Polling Interface --\n@@ -260,7 +252,7 @@ private\n       Msg : String (1 .. Exception_Msg_Max_Length);\n       --  Characters of message\n \n-      Cleanup_Flag : Boolean;\n+      Cleanup_Flag : Boolean := False;\n       --  The cleanup flag is normally False, it is set True for an exception\n       --  occurrence passed to a cleanup routine, and will still be set True\n       --  when the cleanup routine does a Reraise_Occurrence call using this\n@@ -276,7 +268,7 @@ private\n       --  it is dealing with the reraise case (which is useful to distinguish\n       --  for exception tracing purposes).\n \n-      Pid : Natural;\n+      Pid : Natural := 0;\n       --  Partition_Id for partition raising exception\n \n       Num_Tracebacks : Natural range 0 .. Max_Tracebacks := 0;\n@@ -302,13 +294,8 @@ private\n    pragma Stream_Convert (Exception_Occurrence, String_To_EO, EO_To_String);\n    --  Functions for implementing Exception_Occurrence stream attributes\n \n-   pragma Warnings (Off);\n-   --  Allow non-static constants in Ada 2005 mode where this package will be\n-   --  implicitly categorized as Preelaborate. See AI-362 for details. It is\n-   --  safe in the context of the run-time to violate the rules!\n-\n    Null_Occurrence : constant Exception_Occurrence := (\n-     Id               => Null_Id,\n+     Id               => null,\n      Msg_Length       => 0,\n      Msg              => (others => ' '),\n      Cleanup_Flag     => False,\n@@ -318,6 +305,4 @@ private\n      Tracebacks       => (others => TBE.Null_TB_Entry),\n      Private_Data     => System.Null_Address);\n \n-   pragma Warnings (On);\n-\n end Ada.Exceptions;"}, {"sha": "6049ccd32859b7fde69e5eac91ad27e1c462a827", "filename": "gcc/ada/a-exexda.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fa-exexda.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fa-exexda.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexda.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -476,7 +476,7 @@ package body Exception_Data is\n \n       declare\n          Len  : constant Natural := Exception_Name_Length (Id);\n-         Name : constant String (1 .. Len) := Id.Full_Name (1 .. Len);\n+         Name : constant String (1 .. Len) := To_Ptr (Id.Full_Name) (1 .. Len);\n       begin\n          Append_Info_String (Name, Info, Ptr);\n       end;\n@@ -556,9 +556,9 @@ package body Exception_Data is\n \n    procedure Set_Exception_C_Msg\n      (Id   : Exception_Id;\n-      Msg1 : Big_String_Ptr;\n+      Msg1 : System.Address;\n       Line : Integer        := 0;\n-      Msg2 : Big_String_Ptr := null)\n+      Msg2 : System.Address := System.Null_Address)\n    is\n       Excep  : constant EOA := Get_Current_Excep.all;\n       Val    : Integer := Line;\n@@ -575,11 +575,11 @@ package body Exception_Data is\n       Excep.Msg_Length       := 0;\n       Excep.Cleanup_Flag     := False;\n \n-      while Msg1 (Excep.Msg_Length + 1) /= ASCII.NUL\n+      while To_Ptr (Msg1) (Excep.Msg_Length + 1) /= ASCII.NUL\n         and then Excep.Msg_Length < Exception_Msg_Max_Length\n       loop\n          Excep.Msg_Length := Excep.Msg_Length + 1;\n-         Excep.Msg (Excep.Msg_Length) := Msg1 (Excep.Msg_Length);\n+         Excep.Msg (Excep.Msg_Length) := To_Ptr (Msg1) (Excep.Msg_Length);\n       end loop;\n \n       --  Append line number if present\n@@ -613,18 +613,18 @@ package body Exception_Data is\n \n       --  Append second message if present\n \n-      if Msg2 /= null\n+      if Msg2 /= System.Null_Address\n         and then Excep.Msg_Length + 1 < Exception_Msg_Max_Length\n       then\n          Excep.Msg_Length := Excep.Msg_Length + 1;\n          Excep.Msg (Excep.Msg_Length) := ' ';\n \n          Ptr := 1;\n-         while Msg2 (Ptr) /= ASCII.NUL\n+         while To_Ptr (Msg2) (Ptr) /= ASCII.NUL\n            and then Excep.Msg_Length < Exception_Msg_Max_Length\n          loop\n             Excep.Msg_Length := Excep.Msg_Length + 1;\n-            Excep.Msg (Excep.Msg_Length) := Msg2 (Ptr);\n+            Excep.Msg (Excep.Msg_Length) := To_Ptr (Msg2) (Ptr);\n             Ptr := Ptr + 1;\n          end loop;\n       end if;"}, {"sha": "bdb864fe3ef5aa3209a9e33294867a59c5e5d8cd", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 4, "deletions": 358, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -201,16 +201,6 @@ package body Bindgen is\n    procedure Gen_Elab_Defs_C;\n    --  Generate sequence of definitions for elaboration routines (C code case)\n \n-   procedure Gen_Exception_Table_Ada;\n-   --  Generate binder exception table (Ada code case). This consists of\n-   --  declarations followed by a begin followed by a call. If zero cost\n-   --  exceptions are not active, then only the begin is generated.\n-\n-   procedure Gen_Exception_Table_C;\n-   --  Generate binder exception table (C code case). This has no effect\n-   --  if zero cost exceptions are not active, otherwise it generates a\n-   --  set of declarations followed by a call.\n-\n    procedure Gen_Main_Ada;\n    --  Generate procedure main (Ada code case)\n \n@@ -279,9 +269,6 @@ package body Bindgen is\n    --  Set given character in Statement_Buffer at the Last + 1 position\n    --  and increment Last by one to reflect the stored character.\n \n-   procedure Set_EA_Last;\n-   --  Output the number of elements in array EA\n-\n    procedure Set_Int (N : Int);\n    --  Set given value in decimal in Statement_Buffer with no spaces\n    --  starting at the Last + 1 position, and updating Last past the value.\n@@ -296,7 +283,7 @@ package body Bindgen is\n    --  is generated starting at Last + 1, and Last is updated past it.\n \n    procedure Set_Name_Buffer;\n-   --  Set the value stored in positions 1 .. Name_Len of the Name_Buffer.\n+   --  Set the value stored in positions 1 .. Name_Len of the Name_Buffer\n \n    procedure Set_String (S : String);\n    --  Sets characters of given string in Statement_Buffer, starting at the\n@@ -550,10 +537,7 @@ package body Bindgen is\n          WBI (\"      Handler_Installed : Integer;\");\n          WBI (\"      pragma Import (C, Handler_Installed, \" &\n               \"\"\"__gnat_handler_installed\"\");\");\n-\n-         --  Generate exception table\n-\n-         Gen_Exception_Table_Ada;\n+         WBI (\"   begin\");\n \n          --  Generate the call to Set_Globals\n \n@@ -782,10 +766,8 @@ package body Bindgen is\n \n          --  Code for normal case (standard library not suppressed)\n \n-         Gen_Exception_Table_C;\n-\n          --  Generate call to set the runtime global variables defined in\n-         --  a-init.c. We define the varables in a-init.c, rather than in\n+         --  init.c. We define the varables in init.c, rather than in\n          --  the binder generated file itself to avoid undefined externals\n          --  when the runtime is linked as a shareable image library.\n \n@@ -1228,324 +1210,6 @@ package body Bindgen is\n       WBI (\"   END ELABORATION ORDER */\");\n    end Gen_Elab_Order_C;\n \n-   -----------------------------\n-   -- Gen_Exception_Table_Ada --\n-   -----------------------------\n-\n-   procedure Gen_Exception_Table_Ada is\n-      Num  : Nat;\n-      Last : ALI_Id := No_ALI_Id;\n-\n-   begin\n-      if not Zero_Cost_Exceptions_Specified then\n-         WBI (\"   begin\");\n-         return;\n-      end if;\n-\n-      --  The code we generate looks like\n-\n-      --        procedure SDP_Table_Build\n-      --          (SDP_Addresses   : System.Address;\n-      --           SDP_Count       : Natural;\n-      --           Elab_Addresses  : System.Address;\n-      --           Elab_Addr_Count : Natural);\n-      --        pragma Import (C, SDP_Table_Build, \"__gnat_SDP_Table_Build\");\n-      --\n-      --        ST : aliased constant array (1 .. nnn) of System.Address := (\n-      --               unit_name_1'UET_Address,\n-      --               unit_name_2'UET_Address,\n-      --               ...\n-      --               unit_name_3'UET_Address,\n-      --\n-      --        EA : aliased constant array (1 .. eee) of System.Address := (\n-      --               adainit'Code_Address,\n-      --               adafinal'Code_Address,\n-      --               unit_name'elab[spec|body]'Code_Address,\n-      --               unit_name'elab[spec|body]'Code_Address,\n-      --               unit_name'elab[spec|body]'Code_Address,\n-      --               unit_name'elab[spec|body]'Code_Address);\n-      --\n-      --     begin\n-      --        SDP_Table_Build (ST'Address, nnn, EA'Address, eee);\n-\n-      Num := 0;\n-      for A in ALIs.First .. ALIs.Last loop\n-         if not ALIs.Table (A).SAL_Interface\n-           and then ALIs.Table (A).Unit_Exception_Table\n-         then\n-            Num := Num + 1;\n-            Last := A;\n-         end if;\n-      end loop;\n-\n-      if Num = 0 then\n-\n-         --  Happens with \"gnatmake -a -f -gnatL ...\"\n-\n-         WBI (\" \");\n-         WBI (\"   begin\");\n-         return;\n-      end if;\n-\n-      WBI (\"      procedure SDP_Table_Build\");\n-      WBI (\"        (SDP_Addresses   : System.Address;\");\n-      WBI (\"         SDP_Count       : Natural;\");\n-      WBI (\"         Elab_Addresses  : System.Address;\");\n-      WBI (\"         Elab_Addr_Count : Natural);\");\n-      WBI (\"      \" &\n-           \"pragma Import (C, SDP_Table_Build, \"\"__gnat_SDP_Table_Build\"\");\");\n-\n-      WBI (\" \");\n-      Set_String (\"      ST : aliased constant array (1 .. \");\n-      Set_Int (Num);\n-      Set_String (\") of System.Address := (\");\n-\n-      if Num = 1 then\n-         Set_String (\"1 => \");\n-\n-      else\n-         Write_Statement_Buffer;\n-      end if;\n-\n-      for A in ALIs.First .. ALIs.Last loop\n-         if not ALIs.Table (A).SAL_Interface\n-           and then ALIs.Table (A).Unit_Exception_Table\n-         then\n-            Get_Decoded_Name_String_With_Brackets\n-              (Units.Table (ALIs.Table (A).First_Unit).Uname);\n-            Set_Casing (Mixed_Case);\n-\n-            if Num /= 1 then\n-               Set_String (\"        \");\n-            end if;\n-\n-            Set_String (Name_Buffer (1 .. Name_Len - 2));\n-            Set_String (\"'UET_Address\");\n-\n-            if A = Last then\n-               Set_String (\");\");\n-            else\n-               Set_Char (',');\n-            end if;\n-\n-            Write_Statement_Buffer;\n-         end if;\n-      end loop;\n-\n-      WBI (\" \");\n-      Set_String (\"      EA : aliased constant array (1 .. \");\n-      Set_EA_Last;\n-      Set_String (\") of System.Address := (\");\n-      Write_Statement_Buffer;\n-      Set_String (\"        \" & Ada_Init_Name.all & \"'Code_Address\");\n-\n-      --  If compiling for the JVM, we directly reference Adafinal because\n-      --  we don't import it via Do_Finalize (see Gen_Output_File_Ada).\n-\n-      if not Cumulative_Restrictions.Set (No_Finalization) then\n-         Set_Char (',');\n-         Write_Statement_Buffer;\n-\n-         if Hostparm.Java_VM then\n-            Set_String\n-              (\"        System.Standard_Library.Adafinal'Code_Address\");\n-         else\n-            Set_String\n-              (\"        Do_Finalize'Code_Address\");\n-         end if;\n-      end if;\n-\n-      for E in Elab_Order.First .. Elab_Order.Last loop\n-         Get_Decoded_Name_String_With_Brackets\n-           (Units.Table (Elab_Order.Table (E)).Uname);\n-\n-         if Units.Table (Elab_Order.Table (E)).No_Elab then\n-            null;\n-\n-         else\n-            Set_Char (',');\n-            Write_Statement_Buffer;\n-            Set_String (\"        \");\n-\n-            if Name_Buffer (Name_Len) = 's' then\n-               Name_Buffer (Name_Len - 1 .. Name_Len + 21) :=\n-                                        \"'elab_spec'code_address\";\n-            else\n-               Name_Buffer (Name_Len - 1 .. Name_Len + 21) :=\n-                                        \"'elab_body'code_address\";\n-            end if;\n-\n-            Name_Len := Name_Len + 21;\n-            Set_Casing (Units.Table (Elab_Order.Table (E)).Icasing);\n-            Set_Name_Buffer;\n-         end if;\n-      end loop;\n-\n-      Set_String (\");\");\n-      Write_Statement_Buffer;\n-\n-      WBI (\" \");\n-      WBI (\"   begin\");\n-\n-      Set_String (\"      SDP_Table_Build (ST'Address, \");\n-      Set_Int (Num);\n-      Set_String (\", EA'Address, \");\n-      Set_EA_Last;\n-      Set_String (\");\");\n-      Write_Statement_Buffer;\n-   end Gen_Exception_Table_Ada;\n-\n-   ---------------------------\n-   -- Gen_Exception_Table_C --\n-   ---------------------------\n-\n-   procedure Gen_Exception_Table_C is\n-      Num  : Nat;\n-      Num2 : Nat;\n-\n-   begin\n-      if not Zero_Cost_Exceptions_Specified then\n-         return;\n-      end if;\n-\n-      --  The code we generate looks like\n-\n-      --     extern void *__gnat_unitname1__SDP;\n-      --     extern void *__gnat_unitname2__SDP;\n-      --     ...\n-      --\n-      --     void **st[nnn] = {\n-      --       &__gnat_unitname1__SDP,\n-      --       &__gnat_unitname2__SDP,\n-      --       ...\n-      --       &__gnat_unitnamen__SDP};\n-      --\n-      --     extern void unitname1__elabb ();\n-      --     extern void unitname2__elabb ();\n-      --     ...\n-      --\n-      --     void (*ea[eee]) () = {\n-      --       adainit,\n-      --       adafinal,\n-      --       unitname1___elab[b,s],\n-      --       unitname2___elab[b,s],\n-      --       ...\n-      --       unitnamen___elab[b,s]};\n-      --\n-      --     __gnat_SDP_Table_Build (&st, nnn, &ea, eee);\n-\n-      Num := 0;\n-      for A in ALIs.First .. ALIs.Last loop\n-         if not ALIs.Table (A).SAL_Interface\n-           and then ALIs.Table (A).Unit_Exception_Table\n-         then\n-            Num := Num + 1;\n-\n-            Set_String (\"   extern void *__gnat_\");\n-            Get_Name_String (Units.Table (ALIs.Table (A).First_Unit).Uname);\n-            Set_Unit_Name;\n-            Set_String (\"__SDP\");\n-            Set_Char (';');\n-            Write_Statement_Buffer;\n-         end if;\n-      end loop;\n-\n-      if Num = 0 then\n-\n-         --  Happens with \"gnatmake -a -f -gnatL ...\"\n-\n-         return;\n-      end if;\n-\n-      WBI (\" \");\n-\n-      Set_String (\"   void **st[\");\n-      Set_Int (Num);\n-      Set_String (\"] = {\");\n-      Write_Statement_Buffer;\n-\n-      Num2 := 0;\n-      for A in ALIs.First .. ALIs.Last loop\n-         if not ALIs.Table (A).SAL_Interface\n-           and then ALIs.Table (A).Unit_Exception_Table\n-         then\n-            Num2 := Num2 + 1;\n-\n-            Set_String (\"     &__gnat_\");\n-            Get_Name_String (Units.Table (ALIs.Table (A).First_Unit).Uname);\n-            Set_Unit_Name;\n-            Set_String (\"__SDP\");\n-\n-            if Num = Num2 then\n-               Set_String (\"};\");\n-            else\n-               Set_Char (',');\n-            end if;\n-\n-            Write_Statement_Buffer;\n-         end if;\n-      end loop;\n-\n-      WBI (\"\");\n-      for E in Elab_Order.First .. Elab_Order.Last loop\n-         Get_Name_String (Units.Table (Elab_Order.Table (E)).Uname);\n-\n-         if Units.Table (Elab_Order.Table (E)).No_Elab then\n-            null;\n-\n-         else\n-            Set_String (\"   extern void \");\n-            Set_Unit_Name;\n-            Set_String (\"___elab\");\n-            Set_Char (Name_Buffer (Name_Len)); -- 's' or 'b' for spec/body\n-            Set_String (\" ();\");\n-            Write_Statement_Buffer;\n-         end if;\n-      end loop;\n-\n-      WBI (\"\");\n-      Set_String (\"   void (*ea[\");\n-      Set_EA_Last;\n-      Set_String (\"]) () = {\");\n-      Write_Statement_Buffer;\n-\n-      Set_String (\"     \" & Ada_Init_Name.all);\n-\n-      if not Cumulative_Restrictions.Set (No_Finalization) then\n-         Set_Char (',');\n-         Write_Statement_Buffer;\n-         Set_String (\"     system__standard_library__adafinal\");\n-      end if;\n-\n-      for E in Elab_Order.First .. Elab_Order.Last loop\n-         Get_Name_String (Units.Table (Elab_Order.Table (E)).Uname);\n-\n-         if Units.Table (Elab_Order.Table (E)).No_Elab then\n-            null;\n-\n-         else\n-            Set_Char (',');\n-            Write_Statement_Buffer;\n-            Set_String (\"     \");\n-            Set_Unit_Name;\n-            Set_String (\"___elab\");\n-            Set_Char (Name_Buffer (Name_Len)); -- 's' or 'b' for spec/body\n-         end if;\n-      end loop;\n-\n-      Set_String (\"};\");\n-      Write_Statement_Buffer;\n-\n-      WBI (\" \");\n-\n-      Set_String (\"   __gnat_SDP_Table_Build (&st, \");\n-      Set_Int (Num);\n-      Set_String (\", ea, \");\n-      Set_EA_Last;\n-      Set_String (\");\");\n-      Write_Statement_Buffer;\n-   end Gen_Exception_Table_C;\n-\n    ------------------\n    -- Gen_Main_Ada --\n    ------------------\n@@ -1943,7 +1607,7 @@ package body Bindgen is\n       --  internal file appears.\n \n       procedure Write_Linker_Option;\n-      --  Write binder info linker option.\n+      --  Write binder info linker option\n \n       -------------------------\n       -- Write_Linker_Option --\n@@ -3132,24 +2796,6 @@ package body Bindgen is\n       Statement_Buffer (Last) := C;\n    end Set_Char;\n \n-   -----------------\n-   -- Set_EA_Last --\n-   -----------------\n-\n-   procedure Set_EA_Last is\n-   begin\n-      --  When there is no finalization, only adainit is added\n-\n-      if Cumulative_Restrictions.Set (No_Finalization) then\n-         Set_Int (Num_Elab_Calls + 1);\n-\n-      --  When there is finalization, both adainit and adafinal are added\n-\n-      else\n-         Set_Int (Num_Elab_Calls + 2);\n-      end if;\n-   end Set_EA_Last;\n-\n    -------------\n    -- Set_Int --\n    -------------"}, {"sha": "2fd5b25c673a42e60e78bed8ca29e4b61b25c097", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -89,7 +89,7 @@ package body Debug is\n    --  dU   Enable garbage collection of unreachable entities\n    --  dV   Enable viewing of all symbols in debugger\n    --  dW   Disable warnings on calls for IN OUT parameters\n-   --  dX   Enable Frontend ZCX even when it is not supported\n+   --  dX\n    --  dY   Enable configurable run-time mode\n    --  dZ   Generate listing showing the contents of the dispatch tables\n \n@@ -457,13 +457,6 @@ package body Debug is\n    --       task of transitioning incorrect legacy code, we provide this\n    --       undocumented feature for suppressing these warnings.\n \n-   --  dX   Enable frontend ZCX even when it is not supported. Equivalent to\n-   --       -gnatZ but without verifying that System.Front_End_ZCX_Support\n-   --       is set. This causes the front end to generate suitable tables\n-   --       for ZCX handling even when the runtime cannot handle ZCX. This\n-   --       is used for testing the front end for correct ZCX operation, and\n-   --       in particular is useful for multi-target testing.\n-\n    --  dY   Enable configurable run-time mode, just as though the System file\n    --       had Configurable_Run_Time_Mode set to True. This is useful in\n    --       testing high integrity mode."}, {"sha": "ec6b9589286f06b4d4ec74c89cb24c9b7e81230a", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 1, "deletions": 1155, "changes": 1156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -32,8 +32,6 @@ with Errout;   use Errout;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Util; use Exp_Util;\n with Hostparm; use Hostparm;\n-with Inline;   use Inline;\n-with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -42,7 +40,6 @@ with Rtsfind;  use Rtsfind;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Sem;      use Sem;\n-with Sem_Ch5;  use Sem_Ch5;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n@@ -54,38 +51,9 @@ with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n-with Uname;    use Uname;\n \n package body Exp_Ch11 is\n \n-   SD_List : List_Id;\n-   --  This list gathers the values SDn'Unrestricted_Access used to\n-   --  construct the unit exception table. It is set to Empty_List if\n-   --  there are no subprogram descriptors.\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Expand_Exception_Handler_Tables (HSS : Node_Id);\n-   --  Subsidiary procedure called by Expand_Exception_Handlers if zero\n-   --  cost exception handling is installed for this target. Replaces the\n-   --  exception handler structure with appropriate labeled code and tables\n-   --  that allow the zero cost exception handling circuits to find the\n-   --  correct handler (see unit Ada.Exceptions for details).\n-\n-   procedure Generate_Subprogram_Descriptor\n-     (N     : Node_Id;\n-      Loc   : Source_Ptr;\n-      Spec  : Entity_Id;\n-      Slist : List_Id);\n-   --  Procedure called to generate a subprogram descriptor. N is the\n-   --  subprogram body node or, in the case of an imported subprogram, is\n-   --  Empty, and Spec is the entity of the sunprogram. For details of the\n-   --  required structure, see package System.Exceptions. The generated\n-   --  subprogram descriptor is appended to Slist. Loc provides the\n-   --  source location to be used for the generated descriptor.\n-\n    ---------------------------\n    -- Expand_At_End_Handler --\n    ---------------------------\n@@ -130,7 +98,7 @@ package body Exp_Ch11 is\n \n       --  Don't expand if back end exception handling active\n \n-      if Exception_Mechanism = Back_End_ZCX_Exceptions then\n+      if Exception_Mechanism = Back_End_Exceptions then\n          return;\n       end if;\n \n@@ -172,498 +140,6 @@ package body Exp_Ch11 is\n       end if;\n    end Expand_At_End_Handler;\n \n-   -------------------------------------\n-   -- Expand_Exception_Handler_Tables --\n-   -------------------------------------\n-\n-   --  See Ada.Exceptions specification for full details of the data\n-   --  structures that we need to construct here. As an example of the\n-   --  transformation that is required, given the structure:\n-\n-   --     declare\n-   --        {declarations}\n-   --        ..\n-   --     begin\n-   --        {statements-1}\n-   --        ...\n-   --     exception\n-   --        when a | b =>\n-   --           {statements-2}\n-   --           ...\n-   --        when others =>\n-   --           {statements-3}\n-   --           ...\n-   --     end;\n-\n-   --  We transform this into:\n-\n-   --     declare\n-   --        {declarations}\n-   --        ...\n-   --        L1 : label;\n-   --        L2 : label;\n-   --        L3 : label;\n-   --        L4 : Label;\n-   --        L5 : label;\n-\n-   --     begin\n-   --        <<L1>>\n-   --           {statements-1}\n-   --        <<L2>>\n-\n-   --     exception\n-\n-   --        when a | b =>\n-   --           <<L3>>\n-   --           {statements-2}\n-\n-   --           HR2 : constant Handler_Record := (\n-   --                   Lo      => L1'Address,\n-   --                   Hi      => L2'Address,\n-   --                   Id      => a'Identity,\n-   --                   Handler => L5'Address);\n-\n-   --           HR3 : constant Handler_Record := (\n-   --                   Lo      => L1'Address,\n-   --                   Hi      => L2'Address,\n-   --                   Id      => b'Identity,\n-   --                   Handler => L4'Address);\n-\n-   --        when others =>\n-   --           <<L4>>\n-   --           {statements-3}\n-\n-   --           HR1 : constant Handler_Record := (\n-   --                   Lo      => L1'Address,\n-   --                   Hi      => L2'Address,\n-   --                   Id      => Others_Id,\n-   --                   Handler => L4'Address);\n-   --     end;\n-\n-   --  The exception handlers in the transformed version are marked with the\n-   --  Zero_Cost_Handling flag set, and all gigi does in this case is simply\n-   --  to put the handler code somewhere. It can optionally be put inline\n-   --  between the goto L3 and the label <<L3>> (which is why we generate\n-   --  that goto in the first place).\n-\n-   procedure Expand_Exception_Handler_Tables (HSS : Node_Id) is\n-      Loc     : constant Source_Ptr := Sloc (HSS);\n-      Handlrs : constant List_Id    := Exception_Handlers (HSS);\n-      Stms    : constant List_Id    := Statements (HSS);\n-      Handler : Node_Id;\n-\n-      Hlist : List_Id;\n-      --  This is the list to which handlers are to be appended. It is\n-      --  either the list for the enclosing subprogram, or the enclosing\n-      --  selective accept statement (which will turn into a subprogram\n-      --  during expansion later on).\n-\n-      L1 : constant Entity_Id :=\n-             Make_Defining_Identifier (Loc,\n-               Chars => New_Internal_Name ('L'));\n-\n-      L2 : constant Entity_Id :=\n-             Make_Defining_Identifier (Loc,\n-               Chars => New_Internal_Name ('L'));\n-\n-      Lnn    : Entity_Id;\n-      Choice : Node_Id;\n-      E_Id   : Node_Id;\n-      HR_Ent : Node_Id;\n-      HL_Ref : Node_Id;\n-      Item   : Node_Id;\n-\n-      Subp_Entity : Entity_Id;\n-      --  This is the entity for the subprogram (or library level package)\n-      --  to which the handler record is to be attached for later reference\n-      --  in a subprogram descriptor for this entity.\n-\n-      procedure Append_To_Stms (N : Node_Id);\n-      --  Append given statement to the end of the statements of the\n-      --  handled sequence of statements and analyze it in place.\n-\n-      function Inside_Selective_Accept return Boolean;\n-      --  This function is called if we are inside the scope of an entry\n-      --  or task. It checks if the handler is appearing in the context\n-      --  of a selective accept statement. If so, Hlist is set to\n-      --  temporarily park the handlers in the N_Accept_Alternative.\n-      --  node. They will subsequently be moved to the procedure entity\n-      --  for the procedure built for this alternative. The statements that\n-      --  follow the Accept within the alternative are not inside the Accept\n-      --  for purposes of this test, and handlers that may appear within\n-      --  them belong in the enclosing task procedure.\n-\n-      procedure Set_Hlist;\n-      --  Sets the handler list corresponding to Subp_Entity\n-\n-      --------------------\n-      -- Append_To_Stms --\n-      --------------------\n-\n-      procedure Append_To_Stms (N : Node_Id) is\n-      begin\n-         Insert_After_And_Analyze (Last (Stms), N);\n-         Set_Exception_Junk (N);\n-      end Append_To_Stms;\n-\n-      -----------------------------\n-      -- Inside_Selective_Accept --\n-      -----------------------------\n-\n-      function Inside_Selective_Accept return Boolean is\n-         Parnt : Node_Id;\n-         Curr  : Node_Id := HSS;\n-\n-      begin\n-         Parnt := Parent (HSS);\n-         while Nkind (Parnt) /= N_Compilation_Unit loop\n-            if Nkind (Parnt) = N_Accept_Alternative\n-              and then Curr = Accept_Statement (Parnt)\n-            then\n-               if Present (Accept_Handler_Records (Parnt)) then\n-                  Hlist := Accept_Handler_Records (Parnt);\n-               else\n-                  Hlist := New_List;\n-                  Set_Accept_Handler_Records (Parnt, Hlist);\n-               end if;\n-\n-               return True;\n-            else\n-               Curr  := Parnt;\n-               Parnt := Parent (Parnt);\n-            end if;\n-         end loop;\n-\n-         return False;\n-      end Inside_Selective_Accept;\n-\n-      ---------------\n-      -- Set_Hlist --\n-      ---------------\n-\n-      procedure Set_Hlist is\n-      begin\n-         --  Never try to inline a subprogram with exception handlers\n-\n-         Set_Is_Inlined (Subp_Entity, False);\n-\n-         if Present (Subp_Entity)\n-           and then Present (Handler_Records (Subp_Entity))\n-         then\n-            Hlist := Handler_Records (Subp_Entity);\n-         else\n-            Hlist := New_List;\n-            Set_Handler_Records (Subp_Entity, Hlist);\n-         end if;\n-      end Set_Hlist;\n-\n-   --  Start of processing for Expand_Exception_Handler_Tables\n-\n-   begin\n-      --  Nothing to do if this handler has already been processed\n-\n-      if Zero_Cost_Handling (HSS) then\n-         return;\n-      end if;\n-\n-      Set_Zero_Cost_Handling (HSS);\n-\n-      --  Find the parent subprogram or package scope containing this\n-      --  exception frame. This should always find a real package or\n-      --  subprogram. If it does not it will stop at Standard, but\n-      --  this cannot legitimately occur.\n-\n-      --  We only stop at library level packages, for inner packages\n-      --  we always attach handlers to the containing procedure.\n-\n-      Subp_Entity := Current_Scope;\n-      Scope_Loop : loop\n-\n-         --  Never need tables expanded inside a generic template\n-\n-         if Is_Generic_Unit (Subp_Entity) then\n-            return;\n-\n-         --  Stop if we reached containing subprogram. Go to protected\n-         --  subprogram if there is one defined.\n-\n-         elsif Ekind (Subp_Entity) = E_Function\n-           or else Ekind (Subp_Entity) = E_Procedure\n-         then\n-            if Present (Protected_Body_Subprogram (Subp_Entity)) then\n-               Subp_Entity := Protected_Body_Subprogram (Subp_Entity);\n-            end if;\n-\n-            Set_Hlist;\n-            exit Scope_Loop;\n-\n-         --  Case of within an entry\n-\n-         elsif Is_Entry (Subp_Entity) then\n-\n-            --  Protected entry, use corresponding body subprogram\n-\n-            if Present (Protected_Body_Subprogram (Subp_Entity)) then\n-               Subp_Entity := Protected_Body_Subprogram (Subp_Entity);\n-               Set_Hlist;\n-               exit Scope_Loop;\n-\n-            --  Check if we are within a selective accept alternative\n-\n-            elsif Inside_Selective_Accept then\n-\n-               --  As a side effect, Inside_Selective_Accept set Hlist,\n-               --  in much the same manner as Set_Hlist, except that\n-               --  the list involved was the one for the selective accept.\n-\n-               exit Scope_Loop;\n-            end if;\n-\n-         --  Case of within library level package\n-\n-         elsif Ekind (Subp_Entity) = E_Package\n-           and then Is_Compilation_Unit (Subp_Entity)\n-         then\n-            if Is_Body_Name (Unit_Name (Get_Code_Unit (HSS))) then\n-               Subp_Entity := Body_Entity (Subp_Entity);\n-            end if;\n-\n-            Set_Hlist;\n-            exit Scope_Loop;\n-\n-         --  Task type case\n-\n-         elsif Ekind (Subp_Entity) = E_Task_Type then\n-\n-            --  Check if we are within a selective accept alternative\n-\n-            if Inside_Selective_Accept then\n-\n-               --  As a side effect, Inside_Selective_Accept set Hlist,\n-               --  in much the same manner as Set_Hlist, except that the\n-               --  list involved was the one for the selective accept.\n-\n-               exit Scope_Loop;\n-\n-            --  Stop if we reached task type with task body procedure,\n-            --  use the task body procedure.\n-\n-            elsif Present (Get_Task_Body_Procedure (Subp_Entity)) then\n-               Subp_Entity := Get_Task_Body_Procedure (Subp_Entity);\n-               Set_Hlist;\n-               exit Scope_Loop;\n-            end if;\n-         end if;\n-\n-         --  If we fall through, keep looking\n-\n-         Subp_Entity := Scope (Subp_Entity);\n-      end loop Scope_Loop;\n-\n-      pragma Assert (Subp_Entity /= Standard_Standard);\n-\n-      --  Analyze standard labels\n-\n-      Analyze_Label_Entity (L1);\n-      Analyze_Label_Entity (L2);\n-\n-      Insert_Before_And_Analyze (First (Stms),\n-        Make_Label (Loc,\n-          Identifier => New_Occurrence_Of (L1, Loc)));\n-      Set_Exception_Junk (First (Stms));\n-\n-      Append_To_Stms (\n-        Make_Label (Loc,\n-          Identifier => New_Occurrence_Of (L2, Loc)));\n-\n-      --  Loop through exception handlers\n-\n-      Handler := First_Non_Pragma (Handlrs);\n-      while Present (Handler) loop\n-         Set_Zero_Cost_Handling (Handler);\n-\n-         --  Add label at start of handler, and goto at the end\n-\n-         Lnn :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_Internal_Name ('L'));\n-\n-         Analyze_Label_Entity (Lnn);\n-\n-         Item :=\n-           Make_Label (Loc,\n-             Identifier => New_Occurrence_Of (Lnn, Loc));\n-         Set_Exception_Junk (Item);\n-         Insert_Before_And_Analyze (First (Statements (Handler)), Item);\n-\n-         --  Loop through choices\n-\n-         Choice := First (Exception_Choices (Handler));\n-         while Present (Choice) loop\n-\n-            --  Others (or all others) choice\n-\n-            if Nkind (Choice) = N_Others_Choice then\n-               if All_Others (Choice) then\n-                  E_Id := New_Occurrence_Of (RTE (RE_All_Others_Id), Loc);\n-               else\n-                  E_Id := New_Occurrence_Of (RTE (RE_Others_Id), Loc);\n-               end if;\n-\n-            --  Special case of VMS_Exception. Not clear what we will do\n-            --  eventually here if and when we implement zero cost exceptions\n-            --  on VMS. But at least for now, don't blow up trying to take\n-            --  a garbage code address for such an exception.\n-\n-            elsif Is_VMS_Exception (Entity (Choice)) then\n-               E_Id := New_Occurrence_Of (RTE (RE_Null_Id), Loc);\n-\n-            --  Normal case of specific exception choice\n-\n-            else\n-               E_Id :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix => New_Occurrence_Of (Entity (Choice), Loc),\n-                   Attribute_Name => Name_Identity);\n-            end if;\n-\n-            HR_Ent :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_Internal_Name ('H'));\n-\n-            HL_Ref :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix => New_Occurrence_Of (HR_Ent, Loc),\n-                Attribute_Name => Name_Unrestricted_Access);\n-\n-            --  Now we need to add the entry for the new handler record to\n-            --  the list of handler records for the current subprogram.\n-\n-            --  Normally we end up generating the handler records in exactly\n-            --  the right order. Here right order means innermost first,\n-            --  since the table will be searched sequentially. Since we\n-            --  generally expand from outside to inside, the order is just\n-            --  what we want, and we need to append the new entry to the\n-            --  end of the list.\n-\n-            --  However, there are exceptions, notably in the case where\n-            --  a generic body is inserted later on. See for example the\n-            --  case of ACVC test C37213J, which has the following form:\n-\n-            --    generic package x ... end x;\n-            --    package body x is\n-            --    begin\n-            --       ...\n-            --    exception  (1)\n-            --       ...\n-            --    end x;\n-\n-            --    ...\n-\n-            --    declare\n-            --       package q is new x;\n-            --    begin\n-            --       ...\n-            --    exception (2)\n-            --       ...\n-            --    end;\n-\n-            --  In this case, we will expand exception handler (2) first,\n-            --  since the expansion of (1) is delayed till later when the\n-            --  generic body is inserted. But (1) belongs before (2) in\n-            --  the chain.\n-\n-            --  Note that scopes are not totally ordered, because two\n-            --  scopes can be in parallel blocks, so that it does not\n-            --  matter what order these entries appear in. An ordering\n-            --  relation exists if one scope is inside another, and what\n-            --  we really want is some partial ordering.\n-\n-            --  A simple, not very efficient, but adequate algorithm to\n-            --  achieve this partial ordering is to search the list for\n-            --  the first entry containing the given scope, and put the\n-            --  new entry just before it.\n-\n-            declare\n-               New_Scop : constant Entity_Id := Current_Scope;\n-               Ent      : Node_Id;\n-\n-            begin\n-               Ent := First (Hlist);\n-               loop\n-                  --  If all searched, then we can just put the new\n-                  --  entry at the end of the list (it actually does\n-                  --  not matter where we put it in this case).\n-\n-                  if No (Ent) then\n-                     Append_To (Hlist, HL_Ref);\n-                     exit;\n-\n-                  --  If the current scope is within the scope of the\n-                  --  entry then insert the entry before to retain the\n-                  --  proper order as per above discussion.\n-\n-                  --  Note that for equal entries, we just keep going,\n-                  --  which is fine, the entry will end up at the end\n-                  --  of the list where it belongs.\n-\n-                  elsif Scope_Within\n-                          (New_Scop, Scope (Entity (Prefix (Ent))))\n-                  then\n-                     Insert_Before (Ent, HL_Ref);\n-                     exit;\n-\n-                  --  Otherwise keep looking\n-\n-                  else\n-                     Next (Ent);\n-                  end if;\n-               end loop;\n-            end;\n-\n-            Item :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => HR_Ent,\n-                Constant_Present    => True,\n-                Aliased_Present     => True,\n-                Object_Definition   =>\n-                  New_Occurrence_Of (RTE (RE_Handler_Record), Loc),\n-\n-                Expression          =>\n-                  Make_Aggregate (Loc,\n-                    Expressions => New_List (\n-                      Make_Attribute_Reference (Loc,             -- Lo\n-                        Prefix => New_Occurrence_Of (L1, Loc),\n-                        Attribute_Name => Name_Address),\n-\n-                      Make_Attribute_Reference (Loc,             -- Hi\n-                        Prefix => New_Occurrence_Of (L2, Loc),\n-                        Attribute_Name => Name_Address),\n-\n-                      E_Id,                                      -- Id\n-\n-                      Make_Attribute_Reference (Loc,\n-                        Prefix => New_Occurrence_Of (Lnn, Loc),  -- Handler\n-                        Attribute_Name => Name_Address))));\n-\n-            Set_Handler_List_Entry (Item, HL_Ref);\n-            Set_Exception_Junk (Item);\n-            Insert_After_And_Analyze (Last (Statements (Handler)), Item);\n-            Set_Is_Statically_Allocated (HR_Ent);\n-\n-            --  If this is a late insertion (from body instance) it is being\n-            --  inserted in the component list of an already analyzed aggre-\n-            --  gate, and must be analyzed explicitly.\n-\n-            Analyze_And_Resolve (HL_Ref, RTE (RE_Handler_Record_Ptr));\n-\n-            Next (Choice);\n-         end loop;\n-\n-         Next_Non_Pragma (Handler);\n-      end loop;\n-   end Expand_Exception_Handler_Tables;\n-\n    -------------------------------\n    -- Expand_Exception_Handlers --\n    -------------------------------\n@@ -850,13 +326,6 @@ package body Exp_Ch11 is\n       then\n          Set_Exception_Handlers (HSS, No_List);\n       end if;\n-\n-      --  The last step for expanding exception handlers is to expand the\n-      --  exception tables if zero cost exception handling is active.\n-\n-      if Exception_Mechanism = Front_End_ZCX_Exceptions then\n-         Expand_Exception_Handler_Tables (HSS);\n-      end if;\n    end Expand_Exception_Handlers;\n \n    ------------------------------------\n@@ -1331,574 +800,6 @@ package body Exp_Ch11 is\n       Analyze_And_Resolve (N, RTE (RE_Code_Loc));\n    end Expand_N_Subprogram_Info;\n \n-   ------------------------------------\n-   -- Generate_Subprogram_Descriptor --\n-   ------------------------------------\n-\n-   procedure Generate_Subprogram_Descriptor\n-     (N     : Node_Id;\n-      Loc   : Source_Ptr;\n-      Spec  : Entity_Id;\n-      Slist : List_Id)\n-   is\n-      Code  : Node_Id;\n-      Ent   : Entity_Id;\n-      Decl  : Node_Id;\n-      Dtyp  : Entity_Id;\n-      Numh  : Nat;\n-      Sdes  : Node_Id;\n-      Hrc   : List_Id;\n-\n-   begin\n-      if Exception_Mechanism /= Front_End_ZCX_Exceptions then\n-         return;\n-      end if;\n-\n-      if Restriction_Active (No_Exception_Handlers) then\n-         return;\n-      end if;\n-\n-      --  Suppress descriptor if we are not generating code. This happens\n-      --  in the case of a -gnatc -gnatt compilation where we force generics\n-      --  to be generated, but we still don't want exception tables.\n-\n-      if Operating_Mode /= Generate_Code then\n-         return;\n-      end if;\n-\n-      --  Suppress descriptor if we are in No_Exceptions restrictions mode,\n-      --  since we can never propagate exceptions in any case in this mode.\n-      --  The same consideration applies for No_Exception_Handlers (which\n-      --  is also set in High_Integrity_Mode).\n-\n-      if Restriction_Active (No_Exceptions)\n-        or Restriction_Active (No_Exception_Handlers)\n-      then\n-         return;\n-      end if;\n-\n-      --  Suppress descriptor if we are inside a generic. There are two\n-      --  ways that we can tell that, depending on what is going on. If\n-      --  we are actually inside the processing for a generic right now,\n-      --  then Expander_Active will be reset. If we are outside the\n-      --  generic, then we will see the generic entity.\n-\n-      if not Expander_Active then\n-         return;\n-      end if;\n-\n-      --  Suppress descriptor is subprogram is marked as eliminated, for\n-      --  example if this is a subprogram created to analyze a default\n-      --  expression with potential side effects. Ditto if it is nested\n-      --  within an eliminated subprogram, for example a cleanup action.\n-\n-      declare\n-         Scop : Entity_Id;\n-\n-      begin\n-         Scop := Spec;\n-         while Scop /= Standard_Standard loop\n-            if Is_Generic_Unit (Scop) or else Is_Eliminated (Scop) then\n-               return;\n-            end if;\n-\n-            Scop := Scope (Scop);\n-         end loop;\n-      end;\n-\n-      --  Suppress descriptor for original protected subprogram (we will\n-      --  be called again later to generate the descriptor for the actual\n-      --  protected body subprogram.) This does not apply to barrier\n-      --  functions which are there own protected subprogram.\n-\n-      if Is_Subprogram (Spec)\n-        and then Present (Protected_Body_Subprogram (Spec))\n-        and then Protected_Body_Subprogram (Spec) /= Spec\n-      then\n-         return;\n-      end if;\n-\n-      --  Suppress descriptors for packages unless they have at least one\n-      --  handler. The binder will generate the dummy (no handler) descriptors\n-      --  for elaboration procedures. We can't do it here, because we don't\n-      --  know if an elaboration routine does in fact exist.\n-\n-      --  If there is at least one handler for the package spec or body\n-      --  then most certainly an elaboration routine must exist, so we\n-      --  can safely reference it.\n-\n-      if (Nkind (N) = N_Package_Declaration\n-            or else\n-          Nkind (N) = N_Package_Body)\n-        and then No (Handler_Records (Spec))\n-      then\n-         return;\n-      end if;\n-\n-      --  Suppress all subprogram descriptors for the file System.Exceptions.\n-      --  We similarly suppress subprogram descriptors for Ada.Exceptions.\n-      --  These are all init procs for types which cannot raise exceptions.\n-      --  The reason this is done is that otherwise we get embarassing\n-      --  elaboration dependencies.\n-\n-      Get_Name_String (Unit_File_Name (Current_Sem_Unit));\n-\n-      if Name_Buffer (1 .. 12) = \"s-except.ads\"\n-           or else\n-         Name_Buffer (1 .. 12) = \"a-except.ads\"\n-      then\n-         return;\n-      end if;\n-\n-      --  Similarly, we need to suppress entries for System.Standard_Library,\n-      --  since otherwise we get elaboration circularities. Again, this would\n-      --  better be done with a Suppress_Initialization pragma :-)\n-\n-      if Name_Buffer (1 .. 11) = \"s-stalib.ad\" then\n-         return;\n-      end if;\n-\n-      --  For now, also suppress entries for s-stoele because we have\n-      --  some kind of unexplained error there ???\n-\n-      if Name_Buffer (1 .. 11) = \"s-stoele.ad\" then\n-         return;\n-      end if;\n-\n-      --  And also for g-htable, because it cannot raise exceptions,\n-      --  and generates some kind of elaboration order problem.\n-\n-      if Name_Buffer (1 .. 11) = \"g-htable.ad\" then\n-         return;\n-      end if;\n-\n-      --  Suppress subprogram descriptor if already generated. This happens\n-      --  in the case of late generation from Delay_Subprogram_Descriptors\n-      --  beging set (where there is more than one instantiation in the list)\n-\n-      if Has_Subprogram_Descriptor (Spec) then\n-         return;\n-      else\n-         Set_Has_Subprogram_Descriptor (Spec);\n-      end if;\n-\n-      --  Never generate descriptors for inlined bodies\n-\n-      if Analyzing_Inlined_Bodies then\n-         return;\n-      end if;\n-\n-      --  Here we definitely are going to generate a subprogram descriptor\n-\n-      declare\n-         Hnum : Nat := Homonym_Number (Spec);\n-\n-      begin\n-         if Hnum = 1 then\n-            Hnum := 0;\n-         end if;\n-\n-         Ent :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Chars (Spec), \"SD\", Hnum));\n-      end;\n-\n-      if No (Handler_Records (Spec)) then\n-         Hrc  := Empty_List;\n-         Numh := 0;\n-      else\n-         Hrc  := Handler_Records (Spec);\n-         Numh := List_Length (Hrc);\n-      end if;\n-\n-      New_Scope (Spec);\n-\n-      --  We need a static subtype for the declaration of the subprogram\n-      --  descriptor. For the case of 0-3 handlers we can use one of the\n-      --  predefined subtypes in System.Exceptions. For more handlers,\n-      --  we build our own subtype here.\n-\n-      case Numh is\n-         when 0 =>\n-            Dtyp := RTE (RE_Subprogram_Descriptor_0);\n-\n-         when 1 =>\n-            Dtyp := RTE (RE_Subprogram_Descriptor_1);\n-\n-         when 2 =>\n-            Dtyp := RTE (RE_Subprogram_Descriptor_2);\n-\n-         when 3 =>\n-            Dtyp := RTE (RE_Subprogram_Descriptor_3);\n-\n-         when others =>\n-            Dtyp :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_Internal_Name ('T'));\n-\n-            --  Set the constructed type as global, since we will be\n-            --  referencing the object that is of this type globally\n-\n-            Set_Is_Statically_Allocated (Dtyp);\n-\n-            Decl :=\n-              Make_Subtype_Declaration (Loc,\n-                Defining_Identifier => Dtyp,\n-                Subtype_Indication =>\n-                  Make_Subtype_Indication (Loc,\n-                    Subtype_Mark =>\n-                      New_Occurrence_Of (RTE (RE_Subprogram_Descriptor), Loc),\n-                    Constraint =>\n-                      Make_Index_Or_Discriminant_Constraint (Loc,\n-                        Constraints => New_List (\n-                          Make_Integer_Literal (Loc, Numh)))));\n-\n-            Append (Decl, Slist);\n-\n-            --  We analyze the descriptor for the subprogram and package\n-            --  case, but not for the imported subprogram case (it will\n-            --  be analyzed when the freeze entity actions are analyzed.\n-\n-            if Present (N) then\n-               Analyze (Decl);\n-            end if;\n-\n-            Set_Exception_Junk (Decl);\n-      end case;\n-\n-      --  Prepare the code address entry for the table entry. For the normal\n-      --  case of being within a procedure, this is simply:\n-\n-      --    P'Code_Address\n-\n-      --  where P is the procedure, but for the package case, it is\n-\n-      --    P'Elab_Body'Code_Address\n-      --    P'Elab_Spec'Code_Address\n-\n-      --  for the body and spec respectively. Note that we do our own\n-      --  analysis of these attribute references, because we know in this\n-      --  case that the prefix of ELab_Body/Spec is a visible package,\n-      --  which can be referenced directly instead of using the general\n-      --  case expansion for these attributes.\n-\n-      if Ekind (Spec) = E_Package then\n-         Code :=\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Occurrence_Of (Spec, Loc),\n-             Attribute_Name => Name_Elab_Spec);\n-         Set_Etype (Code, Standard_Void_Type);\n-         Set_Analyzed (Code);\n-\n-      elsif Ekind (Spec) = E_Package_Body then\n-         Code :=\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Occurrence_Of (Spec_Entity (Spec), Loc),\n-             Attribute_Name => Name_Elab_Body);\n-         Set_Etype (Code, Standard_Void_Type);\n-         Set_Analyzed (Code);\n-\n-      else\n-         Code := New_Occurrence_Of (Spec, Loc);\n-      end if;\n-\n-      Code :=\n-        Make_Attribute_Reference (Loc,\n-          Prefix         => Code,\n-          Attribute_Name => Name_Code_Address);\n-\n-      Set_Etype (Code, RTE (RE_Address));\n-      Set_Analyzed (Code);\n-\n-      --  Now we can build the subprogram descriptor\n-\n-      Sdes :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier      => Ent,\n-          Constant_Present         => True,\n-          Aliased_Present          => True,\n-          Object_Definition        => New_Occurrence_Of (Dtyp, Loc),\n-\n-          Expression               =>\n-            Make_Aggregate (Loc,\n-              Expressions => New_List (\n-                Make_Integer_Literal (Loc, Numh),          -- Num_Handlers\n-\n-                Code,                                      -- Code\n-\n---  temp code ???\n-\n---                Make_Subprogram_Info (Loc,                 -- Subprogram_Info\n---                  Identifier =>\n---                    New_Occurrence_Of (Spec, Loc)),\n-\n-                New_Copy_Tree (Code),\n-\n-                Make_Aggregate (Loc,                       -- Handler_Records\n-                  Expressions => Hrc))));\n-\n-      Set_Exception_Junk (Sdes);\n-      Set_Is_Subprogram_Descriptor (Sdes);\n-\n-      Append (Sdes, Slist);\n-\n-      --  We analyze the descriptor for the subprogram and package case,\n-      --  but not for the imported subprogram case (it will be analyzed\n-      --  when the freeze entity actions are analyzed.\n-\n-      if Present (N) then\n-         Analyze (Sdes);\n-      end if;\n-\n-      --  We can now pop the scope used for analyzing the descriptor\n-\n-      Pop_Scope;\n-\n-      --  We need to set the descriptor as statically allocated, since\n-      --  it will be referenced from the unit exception table.\n-\n-      Set_Is_Statically_Allocated (Ent);\n-\n-      --  Append the resulting descriptor to the list. We do this only\n-      --  if we are in the main unit. You might think that we could\n-      --  simply skip generating the descriptors completely if we are\n-      --  not in the main unit, but in fact this is not the case, since\n-      --  we have problems with inconsistent serial numbers for internal\n-      --  names if we do this.\n-\n-      if In_Extended_Main_Code_Unit (Spec) then\n-         Append_To (SD_List,\n-           Make_Attribute_Reference (Loc,\n-             Prefix => New_Occurrence_Of (Ent, Loc),\n-             Attribute_Name => Name_Unrestricted_Access));\n-\n-         Unit_Exception_Table_Present := True;\n-      end if;\n-\n-   end Generate_Subprogram_Descriptor;\n-\n-   ------------------------------------------------------------\n-   -- Generate_Subprogram_Descriptor_For_Imported_Subprogram --\n-   ------------------------------------------------------------\n-\n-   procedure Generate_Subprogram_Descriptor_For_Imported_Subprogram\n-     (Spec  : Entity_Id;\n-      Slist : List_Id)\n-   is\n-   begin\n-      Generate_Subprogram_Descriptor (Empty, Sloc (Spec), Spec, Slist);\n-   end Generate_Subprogram_Descriptor_For_Imported_Subprogram;\n-\n-   ------------------------------------------------\n-   -- Generate_Subprogram_Descriptor_For_Package --\n-   ------------------------------------------------\n-\n-   procedure Generate_Subprogram_Descriptor_For_Package\n-     (N    : Node_Id;\n-      Spec : Entity_Id)\n-   is\n-      Adecl : Node_Id;\n-\n-   begin\n-      --  If N is empty with prior errors, ignore\n-\n-      if Total_Errors_Detected /= 0 and then No (N) then\n-         return;\n-      end if;\n-\n-      --  Do not generate if no exceptions\n-\n-      if Restriction_Active (No_Exception_Handlers) then\n-         return;\n-      end if;\n-\n-      --  Otherwise generate descriptor\n-\n-      Adecl := Aux_Decls_Node (Parent (N));\n-\n-      if No (Actions (Adecl)) then\n-         Set_Actions (Adecl, New_List);\n-      end if;\n-\n-      Generate_Subprogram_Descriptor (N, Sloc (N), Spec, Actions (Adecl));\n-   end Generate_Subprogram_Descriptor_For_Package;\n-\n-   ---------------------------------------------------\n-   -- Generate_Subprogram_Descriptor_For_Subprogram --\n-   ---------------------------------------------------\n-\n-   procedure Generate_Subprogram_Descriptor_For_Subprogram\n-     (N    : Node_Id;\n-      Spec : Entity_Id)\n-   is\n-   begin\n-      --  If we have no subprogram body and prior errors, ignore\n-\n-      if Total_Errors_Detected /= 0 and then No (N) then\n-         return;\n-      end if;\n-\n-      --  Do not generate if no exceptions\n-\n-      if Restriction_Active (No_Exception_Handlers) then\n-         return;\n-      end if;\n-\n-      --  Else generate descriptor\n-\n-      declare\n-         HSS : constant Node_Id := Handled_Statement_Sequence (N);\n-\n-      begin\n-         if No (Exception_Handlers (HSS)) then\n-            Generate_Subprogram_Descriptor\n-              (N, Sloc (N), Spec, Statements (HSS));\n-         else\n-            Generate_Subprogram_Descriptor\n-              (N, Sloc (N),\n-               Spec, Statements (Last (Exception_Handlers (HSS))));\n-         end if;\n-      end;\n-   end Generate_Subprogram_Descriptor_For_Subprogram;\n-\n-   -----------------------------------\n-   -- Generate_Unit_Exception_Table --\n-   -----------------------------------\n-\n-   --  The only remaining thing to generate here is to generate the\n-   --  reference to the subprogram descriptor chain. See Ada.Exceptions\n-   --  for details of required data structures.\n-\n-   procedure Generate_Unit_Exception_Table is\n-      Loc      : constant Source_Ptr := No_Location;\n-      Num      : Nat;\n-      Decl     : Node_Id;\n-      Ent      : Entity_Id;\n-      Next_Ent : Entity_Id;\n-      Stent    : Entity_Id;\n-\n-   begin\n-      --  Nothing to be done if zero length exceptions not active\n-\n-      if Exception_Mechanism /= Front_End_ZCX_Exceptions then\n-         return;\n-      end if;\n-\n-      --  Nothing to do if no exceptions\n-\n-      if Restriction_Active (No_Exception_Handlers) then\n-         return;\n-      end if;\n-\n-      --  Remove any entries from SD_List that correspond to eliminated\n-      --  subprograms.\n-\n-      Ent := First (SD_List);\n-      while Present (Ent) loop\n-         Next_Ent := Next (Ent);\n-         if Is_Eliminated (Scope (Entity (Prefix (Ent)))) then\n-            Remove (Ent); -- After this, there is no Next (Ent) anymore\n-         end if;\n-\n-         Ent := Next_Ent;\n-      end loop;\n-\n-      --  Nothing to do if no unit exception table present.\n-      --  An empty table can result from subprogram elimination,\n-      --  in such a case, eliminate the exception table itself.\n-\n-      if Is_Empty_List (SD_List) then\n-         Unit_Exception_Table_Present := False;\n-         return;\n-      end if;\n-\n-      --  Do not generate table in a generic\n-\n-      if Inside_A_Generic then\n-         return;\n-      end if;\n-\n-      --  Generate the unit exception table\n-\n-      --    subtype Tnn is Subprogram_Descriptors_Record (Num);\n-      --    __gnat_unitname__SDP : aliased constant Tnn :=\n-      --                             Num,\n-      --                             (sub1'unrestricted_access,\n-      --                              sub2'unrestricted_access,\n-      --                              ...\n-      --                              subNum'unrestricted_access));\n-\n-      Num := List_Length (SD_List);\n-\n-      Stent :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_Internal_Name ('T'));\n-\n-      Insert_Library_Level_Action (\n-        Make_Subtype_Declaration (Loc,\n-          Defining_Identifier => Stent,\n-          Subtype_Indication =>\n-            Make_Subtype_Indication (Loc,\n-              Subtype_Mark =>\n-                New_Occurrence_Of\n-                 (RTE (RE_Subprogram_Descriptors_Record), Loc),\n-              Constraint =>\n-                Make_Index_Or_Discriminant_Constraint (Loc,\n-                  Constraints => New_List (\n-                    Make_Integer_Literal (Loc, Num))))));\n-\n-      Set_Is_Statically_Allocated (Stent);\n-\n-      Get_External_Unit_Name_String (Unit_Name (Main_Unit));\n-      Name_Buffer (1 + 7 .. Name_Len + 7) := Name_Buffer (1 .. Name_Len);\n-      Name_Buffer (1 .. 7) := \"__gnat_\";\n-      Name_Len := Name_Len + 7;\n-      Add_Str_To_Name_Buffer (\"__SDP\");\n-\n-      Ent :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => Name_Find);\n-\n-      Get_Name_String (Chars (Ent));\n-      Set_Interface_Name (Ent,\n-        Make_String_Literal (Loc, Strval => String_From_Name_Buffer));\n-\n-      Decl :=\n-        Make_Object_Declaration (Loc,\n-             Defining_Identifier => Ent,\n-             Object_Definition   => New_Occurrence_Of (Stent, Loc),\n-          Constant_Present => True,\n-          Aliased_Present  => True,\n-          Expression =>\n-            Make_Aggregate (Loc,\n-              New_List (\n-                Make_Integer_Literal (Loc, List_Length (SD_List)),\n-\n-              Make_Aggregate (Loc,\n-                Expressions => SD_List))));\n-\n-      Insert_Library_Level_Action (Decl);\n-\n-      Set_Is_Exported             (Ent, True);\n-      Set_Is_Public               (Ent, True);\n-      Set_Is_Statically_Allocated (Ent, True);\n-\n-      Get_Name_String (Chars (Ent));\n-      Set_Interface_Name (Ent,\n-        Make_String_Literal (Loc,\n-          Strval => String_From_Name_Buffer));\n-\n-   end Generate_Unit_Exception_Table;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize is\n-   begin\n-      SD_List := Empty_List;\n-   end Initialize;\n-\n    ----------------------\n    -- Is_Non_Ada_Error --\n    ----------------------\n@@ -1922,59 +823,4 @@ package body Exp_Ch11 is\n       return True;\n    end Is_Non_Ada_Error;\n \n-   ----------------------------\n-   -- Remove_Handler_Entries --\n-   ----------------------------\n-\n-   procedure Remove_Handler_Entries (N : Node_Id) is\n-      function Check_Handler_Entry (N : Node_Id) return Traverse_Result;\n-      --  This function checks one node for a possible reference to a\n-      --  handler entry that must be deleted. it always returns OK.\n-\n-      function Remove_All_Handler_Entries is new\n-        Traverse_Func (Check_Handler_Entry);\n-      --  This defines the traversal operation\n-\n-      Discard : Traverse_Result;\n-      pragma Warnings (Off, Discard);\n-\n-      function Check_Handler_Entry (N : Node_Id) return Traverse_Result is\n-      begin\n-         if Nkind (N) = N_Object_Declaration then\n-\n-            if Present (Handler_List_Entry (N)) then\n-               Remove (Handler_List_Entry (N));\n-               Delete_Tree (Handler_List_Entry (N));\n-               Set_Handler_List_Entry (N, Empty);\n-\n-            elsif Is_Subprogram_Descriptor (N) then\n-               declare\n-                  SDN : Node_Id;\n-\n-               begin\n-                  SDN := First (SD_List);\n-                  while Present (SDN) loop\n-                     if Defining_Identifier (N) = Entity (Prefix (SDN)) then\n-                        Remove (SDN);\n-                        Delete_Tree (SDN);\n-                        exit;\n-                     end if;\n-\n-                     Next (SDN);\n-                  end loop;\n-               end;\n-            end if;\n-         end if;\n-\n-         return OK;\n-      end Check_Handler_Entry;\n-\n-   --  Start of processing for Remove_Handler_Entries\n-\n-   begin\n-      if Exception_Mechanism = Front_End_ZCX_Exceptions then\n-         Discard := Remove_All_Handler_Entries (N);\n-      end if;\n-   end Remove_Handler_Entries;\n-\n end Exp_Ch11;"}, {"sha": "ff8e82cbdcd2bbd81d5a6b8ef8c85f97d6ec2664", "filename": "gcc/ada/exp_ch11.ads", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fexp_ch11.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fexp_ch11.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.ads?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,9 +41,6 @@ package Exp_Ch11 is\n    --  See runtime routine Ada.Exceptions for full details on the format and\n    --  content of these tables.\n \n-   procedure Initialize;\n-   --  Initializes these data structures for a new main unit file\n-\n    procedure Expand_At_End_Handler (HSS : Node_Id; Block : Node_Id);\n    --  Given a handled statement sequence, HSS, for which the At_End_Proc\n    --  field is set, and which currently has no exception handlers, this\n@@ -59,59 +56,9 @@ package Exp_Ch11 is\n    --  is also called to expand the special exception handler built for\n    --  accept bodies (see Exp_Ch9.Build_Accept_Body).\n \n-   procedure Generate_Unit_Exception_Table;\n-   --  Procedure called by main driver to generate unit exception table if\n-   --  zero cost exceptions are enabled. See System.Exceptions for details.\n-\n    function Is_Non_Ada_Error (E : Entity_Id) return Boolean;\n    --  This function is provided for Gigi use. It returns True if operating on\n    --  VMS, and the argument E is the entity for System.Aux_Dec.Non_Ada_Error.\n    --  This is used to generate the special matching code for this exception.\n \n-   procedure Remove_Handler_Entries (N : Node_Id);\n-   --  This procedure is called when optimization circuits determine that\n-   --  an entire subtree can be removed. If the subtree contains handler\n-   --  entries in zero cost exception mode, then such removal can lead to\n-   --  dangling references to non-existent handlers in the handler table.\n-   --  This procedure removes such references.\n-\n-   --------------------------------------\n-   -- Subprogram_Descriptor Generation --\n-   --------------------------------------\n-\n-   --  Subprogram descriptors are required for all subprograms, including\n-   --  explicit subprograms defined in the program, subprograms that are\n-   --  imported via pragma Import, and also for the implicit elaboration\n-   --  subprograms used to elaborate package specs and bodies.\n-\n-   procedure Generate_Subprogram_Descriptor_For_Package\n-     (N    : Node_Id;\n-      Spec : Entity_Id);\n-   --  This is used to create a descriptor for the implicit elaboration\n-   --  procedure for a package spec of body. The compiler only generates\n-   --  such descriptors if the package spec or body contains exception\n-   --  handlers (either explicitly in the case of a body, or from generic\n-   --  package instantiations). N is the node for the package body or\n-   --  spec, and Spec is the package body or package entity respectively.\n-   --  N must be a compilation unit, and the descriptor is placed at\n-   --  the end of the actions for the auxiliary compilation unit node.\n-\n-   procedure Generate_Subprogram_Descriptor_For_Subprogram\n-     (N    : Node_Id;\n-      Spec : Entity_Id);\n-   --  This is used to create a desriptor for a subprogram, both those\n-   --  present in the source, and those implicitly generated by code\n-   --  expansion. N is the subprogram body node, and Spec is the entity\n-   --  for the subprogram. The descriptor is placed at the end of the\n-   --  Last exception handler, or, if there are no handlers, at the end\n-   --  of the statement sequence.\n-\n-   procedure Generate_Subprogram_Descriptor_For_Imported_Subprogram\n-     (Spec  : Entity_Id;\n-      Slist : List_Id);\n-   --  This is used to create a descriptor for an imported subprogram.\n-   --  Such descriptors are needed for propagation of exceptions through\n-   --  such subprograms. The descriptor never references any handlers,\n-   --  and is appended to the given Slist.\n-\n end Exp_Ch11;"}, {"sha": "31f5bb1f34abde16503075e741f42f8fe4260a0a", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -30,7 +30,6 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch7;  use Exp_Ch7;\n-with Exp_Ch11; use Exp_Ch11;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Util; use Exp_Util;\n with Exp_Tss;  use Exp_Tss;\n@@ -3365,9 +3364,6 @@ package body Freeze is\n             if Result = No_List then\n                Result := Empty_List;\n             end if;\n-\n-            Generate_Subprogram_Descriptor_For_Imported_Subprogram\n-              (E, Result);\n          end if;\n       end if;\n "}, {"sha": "51112c578341214c4899c82b379fb1c415add8f1", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,6 @@ with Checks;\n with CStand;\n with Debug;    use Debug;\n with Elists;\n-with Exp_Ch11;\n with Exp_Dbug;\n with Fmap;\n with Fname.UF;\n@@ -80,7 +79,6 @@ begin\n    Lib.Load.Initialize;\n    Sem_Ch8.Initialize;\n    Fname.UF.Initialize;\n-   Exp_Ch11.Initialize;\n    Checks.Initialize;\n \n    --  Create package Standard\n@@ -329,11 +327,6 @@ begin\n             end if;\n \n             Check_Elab_Calls;\n-\n-            --  Build unit exception table. We leave this up to the end to\n-            --  make sure that all the necessary information is at hand.\n-\n-            Exp_Ch11.Generate_Unit_Exception_Table;\n          end if;\n \n          --  List library units if requested"}, {"sha": "32720d5cecc83f824a5a61c27325c1676c222855", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -203,27 +203,7 @@ begin\n \n       if Targparm.ZCX_By_Default_On_Target then\n          if Targparm.GCC_ZCX_Support_On_Target then\n-            Exception_Mechanism := Back_End_ZCX_Exceptions;\n-         else\n-            Exception_Mechanism := Front_End_ZCX_Exceptions;\n-         end if;\n-      end if;\n-\n-      --  We take the command line exception mechanism into account\n-\n-      if Opt.Zero_Cost_Exceptions_Set then\n-         if Opt.Zero_Cost_Exceptions_Val = False then\n-            Exception_Mechanism := Front_End_Setjmp_Longjmp_Exceptions;\n-\n-         elsif Debug_Flag_XX then\n-            Exception_Mechanism := Front_End_ZCX_Exceptions;\n-\n-         elsif Targparm.GCC_ZCX_Support_On_Target then\n-            Exception_Mechanism := Back_End_ZCX_Exceptions;\n-\n-         elsif Targparm.Front_End_ZCX_Support_On_Target then\n-            Exception_Mechanism := Front_End_ZCX_Exceptions;\n-\n+            Exception_Mechanism := Back_End_Exceptions;\n          else\n             Osint.Fail\n               (\"Zero Cost Exceptions not supported on this target\");"}, {"sha": "e5f0bf2086b6a346b00744b7c607570b0e9bebae", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,7 +29,6 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch7;  use Exp_Ch7;\n-with Exp_Ch11; use Exp_Ch11;\n with Exp_Tss;  use Exp_Tss;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n@@ -986,29 +985,6 @@ package body Inline is\n            and then not Is_Generic_Unit (Main_Unit_Entity)\n          then\n             Cleanup_Scopes;\n-\n-            --  Also generate subprogram descriptors that were delayed\n-\n-            for J in Pending_Descriptor.First .. Pending_Descriptor.Last loop\n-               declare\n-                  Ent : constant Entity_Id := Pending_Descriptor.Table (J);\n-\n-               begin\n-                  if Is_Subprogram (Ent) then\n-                     Generate_Subprogram_Descriptor_For_Subprogram\n-                       (Get_Subprogram_Body (Ent), Ent);\n-\n-                  elsif Ekind (Ent) = E_Package then\n-                     Generate_Subprogram_Descriptor_For_Package\n-                       (Parent (Declaration_Node (Ent)), Ent);\n-\n-                  elsif Ekind (Ent) = E_Package_Body then\n-                     Generate_Subprogram_Descriptor_For_Package\n-                       (Declaration_Node (Ent), Ent);\n-                  end if;\n-               end;\n-            end loop;\n-\n          elsif Is_Generic_Unit (Cunit_Entity (Main_Unit)) then\n             End_Generic;\n          end if;"}, {"sha": "38124789187b19c61105e06635743631d4dffe60", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,7 +63,7 @@ package Lib.Writ is\n    --  If the following guidelines are respected, downward compatibility\n    --  problems (old tools reading new ali files) should be minimized:\n \n-   --    The basic key character format must be kept.\n+   --    The basic key character format must be kept\n \n    --    The V line must be the first line, this is checked by ali.adb\n    --    even in Ignore_Errors mode, and is used to verify that the file\n@@ -233,10 +233,6 @@ package Lib.Writ is\n    --         UA  Unreserve_All_Interrupts pragma was processed in one or\n    --             more units in this file\n    --\n-   --         UX  Generated code contains unit exception table pointer\n-   --             (i.e. it uses zero-cost exceptions, and there is at\n-   --             least one subprogram present).\n-   --\n    --         ZX  Units in this file use zero-cost exceptions and have\n    --             generated exception tables. If ZX is not present, the\n    --             longjmp/setjmp exception scheme is in use.\n@@ -390,7 +386,7 @@ package Lib.Writ is\n    --  -- U  Unit Header --\n    --  --------------------\n \n-   --  The lines for each compilation unit have the following form.\n+   --  The lines for each compilation unit have the following form\n \n    --    U unit-name source-name version <<attributes>>\n    --"}, {"sha": "a5d476c34fc632b57d228c4e7105a302457b259b", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,7 +39,6 @@ with Atree;   use Atree;\n with Einfo;   use Einfo;\n with Fname;   use Fname;\n with Namet;   use Namet;\n-with Namet;   use Namet;\n with Output;  use Output;\n with Sinfo;   use Sinfo;\n with Sinput;  use Sinput;\n@@ -827,7 +826,6 @@ package body Lib is\n       Linker_Option_Lines.Init;\n       Load_Stack.Init;\n       Units.Init;\n-      Unit_Exception_Table_Present := False;\n       Compilation_Switches.Init;\n    end Initialize;\n "}, {"sha": "5dd26926279d2a14068f10e373f54eb72d2e4fd0", "filename": "gcc/ada/raise.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fraise.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fraise.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.h?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -31,16 +31,18 @@\n  ****************************************************************************/\n \n \n+/* C counterparts of what System.Standard_Library defines.  */\n+\n typedef unsigned Exception_Code;\n-/* C counterpart of what System.Standard_Library defines.  */\n \n struct Exception_Data\n {\n-  char  Handled_By_Others;\n+  char Not_Handled_By_Others;\n   char Lang;\n   int Name_Length;\n-  char *Full_Name, Htable_Ptr;\n+  char *Full_Name, *Htable_Ptr;\n   Exception_Code Import_Code;\n+  void (*Raise_Hook)(void);\n };\n \n typedef struct Exception_Data *Exception_Id;"}, {"sha": "ea9d8bf33a77455900756ad091c14a426ee89ac1", "filename": "gcc/ada/s-except.ads", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b91d88ea1deb4d40b294c12536cbfc9f8137d54/gcc%2Fada%2Fs-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b91d88ea1deb4d40b294c12536cbfc9f8137d54/gcc%2Fada%2Fs-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-except.ads?ref=3b91d88ea1deb4d40b294c12536cbfc9f8137d54", "patch": "@@ -1,203 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                    S Y S T E M . E X C E P T I O N S                     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains definitions used for zero cost exception handling.\n---  See unit Ada.Exceptions for further details. Note that the reason that\n---  we separate out these definitions is to avoid problems with recursion\n---  in rtsfind. They must be in a unit which does not require any exception\n---  table generation of any kind.\n-\n-with Ada.Exceptions;\n-\n-with System;\n-with System.Standard_Library;\n-\n-with Unchecked_Conversion;\n-\n-package System.Exceptions is\n-\n-   package SSL renames System.Standard_Library;\n-   package AEX renames Ada.Exceptions;\n-\n-   --  The following section defines data structures used for zero cost\n-   --  exception handling if System.Parameters.Zero_Cost_Exceptions is\n-   --  set true (i.e. zero cost exceptions are implemented on this target).\n-\n-   --  The approach is to build tables that describe the PC ranges that\n-   --  are covered by various exception frames. When an exception occurs,\n-   --  these tables are searched to determine the address of the applicable\n-   --  handler for the current exception.\n-\n-   subtype Handler_Loc is System.Address;\n-   --  Code location representing entry address of a handler. Values of\n-   --  this type are created using the N_Handler_Loc node, and then\n-   --  passed to the Enter_Handler procedure to enter a handler.\n-\n-   subtype Code_Loc is System.Address;\n-   --  Code location used in building exception tables and for call\n-   --  addresses when propagating an exception (also traceback table)\n-   --  Values of this type are created by using Label'Address or\n-   --  extracted from machine states using Get_Code_Loc.\n-\n-   --------------------\n-   -- Handler_Record --\n-   --------------------\n-\n-   --  A Handler record is built for each choice for each exception handler\n-   --  in a frame.\n-\n-   function To_Exception_Id is\n-     new Unchecked_Conversion (SSL.Exception_Data_Ptr, AEX.Exception_Id);\n-\n-   Others_Dummy_Exception : aliased SSL.Exception_Data;\n-   Others_Id : constant AEX.Exception_Id :=\n-                 To_Exception_Id (Others_Dummy_Exception'Access);\n-   --  Dummy exception used to signal others exception\n-\n-   All_Others_Dummy_Exception : aliased SSL.Exception_Data;\n-   All_Others_Id : constant AEX.Exception_Id :=\n-                     To_Exception_Id (All_Others_Dummy_Exception'Access);\n-   --  Dummy exception used to signal all others exception (including\n-   --  exceptions not normally handled by others, e.g. Abort_Signal)\n-\n-   type Handler_Record is record\n-      Lo : Code_Loc;\n-      Hi : Code_Loc;\n-      --  Range of PC values of code covered by this handler record. The\n-      --  handler covers all code addresses that are greater than the Lo\n-      --  value, and less than or equal to the Hi value.\n-\n-      Id : AEX.Exception_Id;\n-      --  Id of exception being handled, or one of the above special values\n-\n-      Handler : Handler_Loc;\n-      --  Address of label at start of handler\n-   end record;\n-\n-   type Handler_Record_Ptr is access all Handler_Record;\n-   type Handler_Record_List is array (Natural range <>) of Handler_Record_Ptr;\n-\n-   ---------------------------\n-   -- Subprogram_Descriptor --\n-   ---------------------------\n-\n-   --  A Subprogram_Descriptor is built for each subprogram through which\n-   --  exceptions may propagate, this includes all Ada subprograms,\n-   --  and also all foreign language imported subprograms.\n-\n-   subtype Subprogram_Info_Type is System.Address;\n-   --  This type is used to represent a value that is used to unwind stack\n-   --  frames. It references target dependent data that provides sufficient\n-   --  information (e.g. about the location of the return point, use of a\n-   --  frame pointer, save-over-call registers etc) to unwind the machine\n-   --  state to the caller. For some targets, this is simply a pointer to\n-   --  the entry point of the procedure (and the routine to pop the machine\n-   --  state disassembles the code at the entry point to obtain the required\n-   --  information). On other targets, it is a pointer to data created by the\n-   --  backend or assembler to represent the required information.\n-\n-   No_Info : constant Subprogram_Info_Type := System.Null_Address;\n-   --  This is a special value used to indicate that it is not possible\n-   --  to pop past this frame. This is used at the outer level (e.g. for\n-   --  package elaboration procedures or the main procedure), and for any\n-   --  other foreign language procedure for which propagation is known\n-   --  to be impossible. An exception is considered unhandled if an\n-   --  attempt is made to pop a frame whose Subprogram_Info_Type value\n-   --  is set to No_Info.\n-\n-   type Subprogram_Descriptor (Num_Handlers : Natural) is record\n-      Code : Code_Loc;\n-      --  This is a code location used to determine which procedure we are\n-      --  in. Most usually it is simply the entry address for the procedure.\n-      --  hA given address is considered to be within the procedure referenced\n-      --  by a Subprogram_Descriptor record if this is the descriptor for\n-      --  which the Code value is as large as possible without exceeding\n-      --  the given value.\n-\n-      Subprogram_Info : Subprogram_Info_Type;\n-      --  This is a pointer to a target dependent data item that provides\n-      --  sufficient information for unwinding the stack frame of this\n-      --  procedure. A value of No_Info (zero) means that we are the\n-      --  outer level procedure.\n-\n-      Handler_Records : Handler_Record_List (1 .. Num_Handlers);\n-      --  List of pointers to Handler_Records for this procedure. The array\n-      --  is sorted inside out, i.e. entries for inner frames appear before\n-      --  entries for outer handlers. This ensures that a serial search\n-      --  finds the innermost applicable handler\n-   end record;\n-\n-   subtype Subprogram_Descriptor_0 is Subprogram_Descriptor (0);\n-   subtype Subprogram_Descriptor_1 is Subprogram_Descriptor (1);\n-   subtype Subprogram_Descriptor_2 is Subprogram_Descriptor (2);\n-   subtype Subprogram_Descriptor_3 is Subprogram_Descriptor (3);\n-   --  Predeclare commonly used subtypes for buildingt he tables\n-\n-   type Subprogram_Descriptor_Ptr is access all Subprogram_Descriptor;\n-\n-   type Subprogram_Descriptor_List\n-     is array (Natural range <>) of Subprogram_Descriptor_Ptr;\n-\n-   type Subprogram_Descriptors_Record (Count : Natural) is record\n-      SDesc : Subprogram_Descriptor_List (1 .. Count);\n-   end record;\n-\n-   type Subprogram_Descriptors_Ptr is\n-     access all Subprogram_Descriptors_Record;\n-\n-   --------------------------\n-   -- Unit Exception_Table --\n-   --------------------------\n-\n-   --  If a unit contains at least one subprogram, then a library level\n-   --  declaration of the form:\n-\n-   --    Tnn : aliased constant Subprogram_Descriptors :=\n-   --            (Count => n,\n-   --             SDesc =>\n-   --              (SD1'Unrestricted_Access,\n-   --               SD2'Unrestricted_Access,\n-   --               ...\n-   --               SDn'Unrestricted_Access));\n-   --    pragma Export (Ada, Tnn, \"__gnat_unit_name__SDP\");\n-\n-   --  is generated where the initializing expression is an array aggregate\n-   --  whose elements are pointers to the generated subprogram descriptors\n-   --  for the units.\n-\n-   --  Note: the ALI file contains the designation UX in each unit entry\n-   --  if a unit exception table is generated.\n-\n-   --  The binder generates a list of addresses of pointers to these tables.\n-\n-end System.Exceptions;"}, {"sha": "cda22fa310f9c6cfb8fab8445be37554181908c9", "filename": "gcc/ada/s-mastop-irix.adb", "status": "modified", "additions": 2, "deletions": 82, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-mastop-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-mastop-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mastop-irix.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -44,7 +44,6 @@ with Unchecked_Conversion;\n package body System.Machine_State_Operations is\n \n    use System.Storage_Elements;\n-   use System.Exceptions;\n \n    --  The exc_unwind function in libexc operats on a Sigcontext\n \n@@ -182,66 +181,6 @@ package body System.Machine_State_Operations is\n         (Memory.Alloc (Sigcontext'Max_Size_In_Storage_Elements));\n    end Allocate_Machine_State;\n \n-   -------------------\n-   -- Enter_Handler --\n-   -------------------\n-\n-   procedure Enter_Handler (M : Machine_State; Handler : Handler_Loc) is\n-      pragma Warnings (Off, M);\n-      pragma Warnings (Off, Handler);\n-\n-      LOADI : constant String (1 .. 2) := 'l' & LSC;\n-      --  This is \"lw\" in o32 mode, and \"ld\" in n32/n64 mode\n-\n-      LOADF : constant String (1 .. 4) := 'l' & LSC & \"c1\";\n-      --  This is \"lwc1\" in o32 mode and \"ldc1\" in n32/n64 mode\n-\n-   begin\n-      --  Restore integer registers from machine state. Note that we know\n-      --  that $4 points to M, and $5 points to Handler, since this is\n-      --  the standard calling sequence\n-\n-      Asm (LOADI & \" $16,  16*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $17,  17*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $18,  18*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $19,  19*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $20,  20*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $21,  21*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $22,  22*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $23,  23*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $24,  24*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $25,  25*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $26,  26*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $27,  27*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $28,  28*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $29,  29*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $30,  30*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-      Asm (LOADI & \" $31,  31*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n-\n-      --  Restore floating-point registers from machine state\n-\n-      Asm (LOADF & \" $f16, 16*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f17, 17*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f18, 18*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f19, 19*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f20, 20*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f21, 21*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f22, 22*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f23, 23*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f24, 24*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f25, 25*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f26, 26*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f27, 27*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f28, 28*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f29, 29*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f30, 30*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-      Asm (LOADF & \" $f31, 31*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n-\n-      --  Jump directly to the handler\n-\n-      Asm (\"jr  $5\");\n-   end Enter_Handler;\n-\n    ----------------\n    -- Fetch_Code --\n    ----------------\n@@ -284,12 +223,7 @@ package body System.Machine_State_Operations is\n    -- Pop_Frame --\n    ---------------\n \n-   procedure Pop_Frame\n-     (M    : Machine_State;\n-      Info : Subprogram_Info_Type)\n-   is\n-      pragma Warnings (Off, Info);\n-\n+   procedure Pop_Frame (M : Machine_State) is\n       Scp : constant Sigcontext_Ptr := To_Sigcontext_Ptr (M);\n \n       procedure Exc_Unwind (Scp : Sigcontext_Ptr; Fde : Long_Integer := 0);\n@@ -407,21 +341,7 @@ package body System.Machine_State_Operations is\n       --  This pop operation will properly set the PC value in the machine\n       --  state, so there is no need to save PC in the above code.\n \n-      Pop_Frame (M, Set_Machine_State'Address);\n+      Pop_Frame (M);\n    end Set_Machine_State;\n \n-   ------------------------------\n-   -- Set_Signal_Machine_State --\n-   ------------------------------\n-\n-   procedure Set_Signal_Machine_State\n-     (M       : Machine_State;\n-      Context : System.Address)\n-   is\n-      pragma Warnings (Off, M);\n-      pragma Warnings (Off, Context);\n-   begin\n-      null;\n-   end Set_Signal_Machine_State;\n-\n end System.Machine_State_Operations;"}, {"sha": "1a7b9876924fdcf02ebddf9c0cfd16a4f8bccc76", "filename": "gcc/ada/s-mastop-tru64.adb", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-mastop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-mastop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mastop-tru64.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -39,8 +39,6 @@ with System.Memory;\n \n package body System.Machine_State_Operations is\n \n-   use System.Exceptions;\n-\n    pragma Linker_Options (\"-lexc\");\n    --  Needed for definitions of exc_capture_context and exc_virtual_unwind\n \n@@ -59,18 +57,6 @@ package body System.Machine_State_Operations is\n         (Memory.Alloc (Memory.size_t (c_machine_state_length)));\n    end Allocate_Machine_State;\n \n-   -------------------\n-   -- Enter_Handler --\n-   -------------------\n-\n-   procedure Enter_Handler (M : Machine_State; Handler : Handler_Loc) is\n-      procedure c_enter_handler (M : Machine_State; Handler : Handler_Loc);\n-      pragma Import (C, c_enter_handler, \"__gnat_enter_handler\");\n-\n-   begin\n-      c_enter_handler (M, Handler);\n-   end Enter_Handler;\n-\n    ----------------\n    -- Fetch_Code --\n    ----------------\n@@ -135,12 +121,7 @@ package body System.Machine_State_Operations is\n    -- Pop_Frame --\n    ---------------\n \n-   procedure Pop_Frame\n-     (M    : Machine_State;\n-      Info : Subprogram_Info_Type)\n-   is\n-      pragma Warnings (Off, Info);\n-\n+   procedure Pop_Frame (M : Machine_State) is\n       procedure exc_virtual_unwind (Fcn : System.Address; M : Machine_State);\n       pragma Import (C, exc_virtual_unwind, \"exc_virtual_unwind\");\n \n@@ -178,21 +159,7 @@ package body System.Machine_State_Operations is\n       pragma Import (C, c_capture_context, \"exc_capture_context\");\n    begin\n       c_capture_context (M);\n-      Pop_Frame (M, System.Null_Address);\n+      Pop_Frame (M);\n    end Set_Machine_State;\n \n-   ------------------------------\n-   -- Set_Signal_Machine_State --\n-   ------------------------------\n-\n-   procedure Set_Signal_Machine_State\n-     (M       : Machine_State;\n-      Context : System.Address)\n-   is\n-      pragma Warnings (Off, M);\n-      pragma Warnings (Off, Context);\n-   begin\n-      null;\n-   end Set_Signal_Machine_State;\n-\n end System.Machine_State_Operations;"}, {"sha": "9e8672850079b15f2eb056d499cae09af6aa6652", "filename": "gcc/ada/s-mastop-vms.adb", "status": "modified", "additions": 1, "deletions": 63, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-mastop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-mastop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mastop-vms.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -41,7 +41,6 @@ with Unchecked_Conversion;\n \n package body System.Machine_State_Operations is\n \n-   use System.Exceptions;\n    subtype Cond_Value_Type is Unsigned_Longword;\n \n    --  Record layouts copied from Starlet.\n@@ -148,48 +147,6 @@ package body System.Machine_State_Operations is\n         (Memory.Alloc (Invo_Handle_Type'Max_Size_In_Storage_Elements));\n    end Allocate_Machine_State;\n \n-   -------------------\n-   -- Enter_Handler --\n-   -------------------\n-\n-   procedure Enter_Handler (M : Machine_State; Handler : Handler_Loc) is\n-      procedure Get_Invo_Context (\n-         Result       : out Unsigned_Longword; -- return value\n-         Invo_Handle  : Invo_Handle_Type;\n-         Invo_Context : out Invo_Context_Blk_Type);\n-\n-      pragma Interface (External, Get_Invo_Context);\n-\n-      pragma Import_Valued_Procedure (Get_Invo_Context, \"LIB$GET_INVO_CONTEXT\",\n-         (Unsigned_Longword, Invo_Handle_Type, Invo_Context_Blk_Type),\n-         (Value, Value, Reference));\n-\n-      ICB : Invo_Context_Blk_Type;\n-\n-      procedure Goto_Unwind (\n-         Status      : out Cond_Value_Type; -- return value\n-         Target_Invo : Address := Address_Zero;\n-         Target_PC   : Address := Address_Zero;\n-         New_R0      : Unsigned_Quadword := Unsigned_Quadword'Null_Parameter;\n-         New_R1      : Unsigned_Quadword := Unsigned_Quadword'Null_Parameter);\n-\n-      pragma Interface (External, Goto_Unwind);\n-\n-      pragma Import_Valued_Procedure\n-        (Goto_Unwind, \"SYS$GOTO_UNWIND\",\n-         (Cond_Value_Type, Address, Address,\n-          Unsigned_Quadword, Unsigned_Quadword),\n-         (Value, Reference, Reference,\n-          Reference, Reference));\n-\n-      Status : Cond_Value_Type;\n-\n-   begin\n-      Get_Invo_Context (Status, To_Invo_Handle_Access (M).all, ICB);\n-      Goto_Unwind\n-        (Status, System.Address (To_Invo_Handle_Access (M).all), Handler);\n-   end Enter_Handler;\n-\n    ----------------\n    -- Fetch_Code --\n    ----------------\n@@ -261,12 +218,7 @@ package body System.Machine_State_Operations is\n    -- Pop_Frame --\n    ---------------\n \n-   procedure Pop_Frame\n-     (M    : Machine_State;\n-      Info : Subprogram_Info_Type)\n-   is\n-      pragma Warnings (Off, Info);\n-\n+   procedure Pop_Frame (M : Machine_State) is\n       procedure Get_Prev_Invo_Handle (\n          Result : out Invo_Handle_Type; -- return value\n          ICB    : in  Invo_Handle_Type);\n@@ -321,18 +273,4 @@ package body System.Machine_State_Operations is\n       Pop_Frame (M, System.Null_Address);\n    end Set_Machine_State;\n \n-   ------------------------------\n-   -- Set_Signal_Machine_State --\n-   ------------------------------\n-\n-   procedure Set_Signal_Machine_State\n-     (M       : Machine_State;\n-      Context : System.Address)\n-   is\n-      pragma Warnings (Off, M);\n-      pragma Warnings (Off, Context);\n-   begin\n-      null;\n-   end Set_Signal_Machine_State;\n-\n end System.Machine_State_Operations;"}, {"sha": "9f182292317b57009da7ffc7817eee4e01e2ec33", "filename": "gcc/ada/s-mastop-x86.adb", "status": "removed", "additions": 0, "deletions": 594, "changes": 594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b91d88ea1deb4d40b294c12536cbfc9f8137d54/gcc%2Fada%2Fs-mastop-x86.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b91d88ea1deb4d40b294c12536cbfc9f8137d54/gcc%2Fada%2Fs-mastop-x86.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mastop-x86.adb?ref=3b91d88ea1deb4d40b294c12536cbfc9f8137d54", "patch": "@@ -1,594 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                     SYSTEM.MACHINE_STATE_OPERATIONS                      --\n---                                                                          --\n---                                 B o d y                                  --\n---                            (Version for x86)                             --\n---                                                                          --\n---           Copyright (C) 1999-2004 Ada Core Technologies, Inc.            --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Note: it is very important that this unit not generate any exception\n---  tables of any kind. Otherwise we get a nasty rtsfind recursion problem.\n---  This means no subprograms, including implicitly generated ones.\n-\n-with Unchecked_Conversion;\n-with System.Storage_Elements;\n-with System.Machine_Code; use System.Machine_Code;\n-with System.Memory;\n-\n-package body System.Machine_State_Operations is\n-\n-   function \"+\" (Left, Right : Address) return Address;\n-   pragma Import (Intrinsic, \"+\");\n-   --  Provide addition operation on type Address (this may not be directly\n-   --  available if type System.Address is non-private and the operations on\n-   --  the type are made abstract to hide them from public users of System).\n-\n-   use System.Exceptions;\n-\n-   type Uns8  is mod 2 ** 8;\n-   type Uns32 is mod 2 ** 32;\n-\n-   type Bits5 is mod 2 ** 5;\n-   type Bits6 is mod 2 ** 6;\n-\n-   function To_Address is new Unchecked_Conversion (Uns32, Address);\n-\n-   type Uns32_Ptr is access all Uns32;\n-   function To_Uns32_Ptr is new Unchecked_Conversion (Uns32,   Uns32_Ptr);\n-\n-   --  Note: the type Uns32 has an alignment of 4. However, in some cases\n-   --  values of type Uns32_Ptr will not be aligned (notably in the case\n-   --  where we get the immediate field from an instruction). However this\n-   --  does not matter in practice, since the x86 does not require that\n-   --  operands be aligned.\n-\n-   ----------------------\n-   -- General Approach --\n-   ----------------------\n-\n-   --  For the x86 version of this unit, the Subprogram_Info_Type values\n-   --  are simply the starting code address for the subprogram. Popping\n-   --  of stack frames works by analyzing the code in the prolog, and\n-   --  deriving from this analysis the necessary information for restoring\n-   --  the registers, including the return point.\n-\n-   ---------------------------\n-   -- Description of Prolog --\n-   ---------------------------\n-\n-   --  If a frame pointer is present, the prolog looks like\n-\n-   --     pushl %ebp\n-   --     movl  %esp,%ebp\n-   --     subl  $nnn,%esp     omitted if nnn = 0\n-   --     pushl %edi          omitted if edi not used\n-   --     pushl %esi          omitted if esi not used\n-   --     pushl %ebx          omitted if ebx not used\n-\n-   --  If a frame pointer is not present, the prolog looks like\n-\n-   --     subl  $nnn,%esp     omitted if nnn = 0\n-   --     pushl %ebp          omitted if ebp not used\n-   --     pushl %edi          omitted if edi not used\n-   --     pushl %esi          omitted if esi not used\n-   --     pushl %ebx          omitted if ebx not used\n-\n-   --  Note: any or all of the save over call registers may be used and\n-   --  if so, will be saved using pushl as shown above. The order of the\n-   --  pushl instructions will be as shown above for gcc generated code,\n-   --  but the code in this unit does not assume this.\n-\n-   -------------------------\n-   -- Description of Call --\n-   -------------------------\n-\n-   --  A call looks like:\n-\n-   --     pushl ...           push parameters\n-   --     pushl ...\n-   --     call  ...           perform the call\n-   --     addl  $nnn,%esp     omitted if no parameters\n-\n-   --  Note that we are not absolutely guaranteed that the call is always\n-   --  followed by an addl operation that readjusts %esp for this particular\n-   --  call. There are two reasons for this:\n-\n-   --    1) The addl can be delayed and combined in the case where more than\n-   --       one call appears in sequence. This can be suppressed by using the\n-   --       switch -fno-defer-pop and for Ada code, we automatically use\n-   --       this switch, but we could still be dealing with C code that was\n-   --       compiled without using this switch.\n-\n-   --    2) Scheduling may result in moving the addl instruction away from\n-   --       the call. It is not clear if this actually can happen at the\n-   --       current time, but it is certainly conceptually possible.\n-\n-   --  The addl after the call is important, since we need to be able to\n-   --  restore the proper %esp value when we pop the stack. However, we do\n-   --  not try to compensate for either of the above effects. As noted above,\n-   --  case 1 does not occur for Ada code, and it does not appear in practice\n-   --  that case 2 occurs with any significant frequency (we have never seen\n-   --  an example so far for gcc generated code).\n-\n-   --  Furthermore, it is only in the case of -fomit-frame-pointer that we\n-   --  really get into trouble from not properly restoring %esp. If we have\n-   --  a frame pointer, then the worst that happens is that %esp is slightly\n-   --  more depressed than it should be. This could waste a bit of space on\n-   --  the stack, and even in some cases cause a storage leak on the stack,\n-   --  but it will not affect the functional correctness of the processing.\n-\n-   ----------------------------------------\n-   -- Definitions of Instruction Formats --\n-   ----------------------------------------\n-\n-   type Rcode is (eax, ecx, edx, ebx, esp, ebp, esi, edi);\n-   pragma Warnings (Off, Rcode);\n-   --  Code indicating which register is referenced in an instruction\n-\n-   --  The following define the format of a pushl instruction\n-\n-   Op_pushl : constant Bits5 := 2#01010#;\n-\n-   type Ins_pushl is record\n-      Op  : Bits5 := Op_pushl;\n-      Reg : Rcode;\n-   end record;\n-\n-   for Ins_pushl use record\n-      Op  at 0 range 3 .. 7;\n-      Reg at 0 range 0 .. 2;\n-   end record;\n-\n-   Ins_pushl_ebp : constant Ins_pushl := (Op_pushl, Reg => ebp);\n-\n-   type Ins_pushl_Ptr is access all Ins_pushl;\n-\n-   --  For the movl %esp,%ebp instruction, we only need to know the length\n-   --  because we simply skip past it when we analyze the prolog.\n-\n-   Ins_movl_length : constant := 2;\n-\n-   --  The following define the format of addl/subl esp instructions\n-\n-   Op_Immed : constant Bits6 := 2#100000#;\n-\n-   Op2_addl_Immed : constant Bits5 := 2#11100#;\n-   pragma Unreferenced (Op2_addl_Immed);\n-\n-   Op2_subl_Immed : constant Bits5 := 2#11101#;\n-\n-   type Word_Byte is (Word, Byte);\n-   pragma Unreferenced (Byte);\n-\n-   type Ins_addl_subl_byte is record\n-      Op   : Bits6;           -- Set to Op_Immed\n-      w    : Word_Byte;       -- Word/Byte flag (set to 1 = byte)\n-      s    : Boolean;         -- Sign extension bit (1 = extend)\n-      Op2  : Bits5;           -- Secondary opcode\n-      Reg  : Rcode;           -- Register\n-      Imm8 : Uns8;            -- Immediate operand\n-   end record;\n-\n-   for Ins_addl_subl_byte use record\n-      Op   at 0 range 2 .. 7;\n-      w    at 0 range 1 .. 1;\n-      s    at 0 range 0 .. 0;\n-      Op2  at 1 range 3 .. 7;\n-      Reg  at 1 range 0 .. 2;\n-      Imm8 at 2 range 0 .. 7;\n-   end record;\n-\n-   type Ins_addl_subl_word is record\n-      Op    : Bits6;          -- Set to Op_Immed\n-      w     : Word_Byte;      -- Word/Byte flag (set to 0 = word)\n-      s     : Boolean;        -- Sign extension bit (1 = extend)\n-      Op2   : Bits5;          -- Secondary opcode\n-      Reg   : Rcode;          -- Register\n-      Imm32 : Uns32;          -- Immediate operand\n-   end record;\n-\n-   for Ins_addl_subl_word use record\n-      Op    at 0 range 2 .. 7;\n-      w     at 0 range 1 .. 1;\n-      s     at 0 range 0 .. 0;\n-      Op2   at 1 range 3 .. 7;\n-      Reg   at 1 range 0 .. 2;\n-      Imm32 at 2 range 0 .. 31;\n-   end record;\n-\n-   type Ins_addl_subl_byte_Ptr is access all Ins_addl_subl_byte;\n-   type Ins_addl_subl_word_Ptr is access all Ins_addl_subl_word;\n-\n-   ---------------------\n-   -- Prolog Analysis --\n-   ---------------------\n-\n-   --  The analysis of the prolog answers the following questions:\n-\n-   --    1. Is %ebp used as a frame pointer?\n-   --    2. How far is SP depressed (i.e. what is the stack frame size)\n-   --    3. Which registers are saved in the prolog, and in what order\n-\n-   --  The following data structure stores the answers to these questions\n-\n-   subtype SOC is Rcode range ebx .. edi;\n-   --  Possible save over call registers\n-\n-   SOC_Max : constant := 4;\n-   --  Max number of SOC registers that can be pushed\n-\n-   type SOC_Push_Regs_Type is array (1 .. 4) of Rcode;\n-   --  Used to hold the register codes of pushed SOC registers\n-\n-   type Prolog_Type is record\n-\n-      Frame_Reg : Boolean;\n-      --  This is set to True if %ebp is used as a frame register, and\n-      --  False otherwise (in the False case, %ebp may be saved in the\n-      --  usual manner along with the other SOC registers).\n-\n-      Frame_Length : Uns32;\n-      --  Amount by which ESP is decremented on entry, includes the effects\n-      --  of push's of save over call registers as indicated above, e.g. if\n-      --  the prolog of a routine is:\n-      --\n-      --    pushl %ebp\n-      --    movl %esp,%ebp\n-      --    subl $424,%esp\n-      --    pushl %edi\n-      --    pushl %esi\n-      --    pushl %ebx\n-      --\n-      --  Then the value of Frame_Length would be 436 (424 + 3 * 4). A\n-      --  precise definition is that it is:\n-      --\n-      --    %esp on entry   minus   %esp after last SOC push\n-      --\n-      --  That definition applies both in the frame pointer present and\n-      --  the frame pointer absent cases.\n-\n-      Num_SOC_Push : Integer range 0 .. SOC_Max;\n-      --  Number of save over call registers actually saved by pushl\n-      --  instructions (other than the initial pushl to save the frame\n-      --  pointer if a frame pointer is in use).\n-\n-      SOC_Push_Regs : SOC_Push_Regs_Type;\n-      --  The First Num_SOC_Push entries of this array are used to contain\n-      --  the codes for the SOC registers, in the order in which they were\n-      --  pushed. Note that this array excludes %ebp if it is used as a frame\n-      --  register, since although %ebp is still considered an SOC register\n-      --  in this case, it is saved and restored by a separate mechanism.\n-      --  Also we will never see %esp represented in this list. Again, it is\n-      --  true that %esp is saved over call, but it is restored by a separate\n-      --  mechanism.\n-\n-   end record;\n-\n-   procedure Analyze_Prolog (A : Address; Prolog : out Prolog_Type);\n-   --  Given the address of the start of the prolog for a procedure,\n-   --  analyze the instructions of the prolog, and set Prolog to contain\n-   --  the information obtained from this analysis.\n-\n-   ----------------------------------\n-   -- Machine_State_Representation --\n-   ----------------------------------\n-\n-   --  The type Machine_State is defined in the body of Ada.Exceptions as\n-   --  a Storage_Array of length 1 .. Machine_State_Length. But really it\n-   --  has structure as defined here. We use the structureless declaration\n-   --  in Ada.Exceptions to avoid this unit from being implementation\n-   --  dependent. The actual definition of Machine_State is as follows:\n-\n-   type SOC_Regs_Type is array (SOC) of Uns32;\n-\n-   type MState is record\n-      eip : Uns32;\n-      --  The instruction pointer location (which is the return point\n-      --  value from the next level down in all cases).\n-\n-      Regs : SOC_Regs_Type;\n-      --  Values of the save over call registers\n-   end record;\n-\n-   for MState use record\n-      eip  at 0 range 0 .. 31;\n-      Regs at 4 range 0 .. 5 * 32 - 1;\n-   end record;\n-   --  Note: the routines Enter_Handler, and Set_Machine_State reference\n-   --  the fields in this structure non-symbolically.\n-\n-   type MState_Ptr is access all MState;\n-\n-   function To_MState_Ptr is\n-     new Unchecked_Conversion (Machine_State, MState_Ptr);\n-\n-   ----------------------------\n-   -- Allocate_Machine_State --\n-   ----------------------------\n-\n-   function Allocate_Machine_State return Machine_State is\n-      use System.Storage_Elements;\n-\n-   begin\n-      return Machine_State\n-        (Memory.Alloc (MState'Max_Size_In_Storage_Elements));\n-   end Allocate_Machine_State;\n-\n-   --------------------\n-   -- Analyze_Prolog --\n-   --------------------\n-\n-   procedure Analyze_Prolog (A : Address; Prolog : out Prolog_Type) is\n-      Ptr : Address;\n-      Ppl : Ins_pushl_Ptr;\n-      Pas : Ins_addl_subl_byte_Ptr;\n-\n-      function To_Ins_pushl_Ptr is\n-        new Unchecked_Conversion (Address, Ins_pushl_Ptr);\n-\n-      function To_Ins_addl_subl_byte_Ptr is\n-        new Unchecked_Conversion (Address, Ins_addl_subl_byte_Ptr);\n-\n-      function To_Ins_addl_subl_word_Ptr is\n-        new Unchecked_Conversion (Address, Ins_addl_subl_word_Ptr);\n-\n-   begin\n-      Ptr := A;\n-      Prolog.Frame_Length := 0;\n-\n-      if Ptr = Null_Address then\n-         Prolog.Num_SOC_Push := 0;\n-         Prolog.Frame_Reg := True;\n-         return;\n-      end if;\n-\n-      if To_Ins_pushl_Ptr (Ptr).all = Ins_pushl_ebp then\n-         Ptr := Ptr + 1 + Ins_movl_length;\n-         Prolog.Frame_Reg := True;\n-      else\n-         Prolog.Frame_Reg := False;\n-      end if;\n-\n-      Pas := To_Ins_addl_subl_byte_Ptr (Ptr);\n-\n-      if Pas.Op = Op_Immed\n-        and then Pas.Op2 = Op2_subl_Immed\n-        and then Pas.Reg = esp\n-      then\n-         if Pas.w = Word then\n-            Prolog.Frame_Length := Prolog.Frame_Length +\n-                                     To_Ins_addl_subl_word_Ptr (Ptr).Imm32;\n-            Ptr := Ptr + 6;\n-\n-         else\n-            Prolog.Frame_Length := Prolog.Frame_Length + Uns32 (Pas.Imm8);\n-            Ptr := Ptr + 3;\n-\n-            --  Note: we ignore sign extension, since a sign extended\n-            --  value that was negative would imply a ludicrous frame size.\n-         end if;\n-      end if;\n-\n-      --  Now scan push instructions for SOC registers\n-\n-      Prolog.Num_SOC_Push := 0;\n-\n-      loop\n-         Ppl := To_Ins_pushl_Ptr (Ptr);\n-\n-         if Ppl.Op = Op_pushl and then Ppl.Reg in SOC then\n-            Prolog.Num_SOC_Push := Prolog.Num_SOC_Push + 1;\n-            Prolog.SOC_Push_Regs (Prolog.Num_SOC_Push) := Ppl.Reg;\n-            Prolog.Frame_Length := Prolog.Frame_Length + 4;\n-            Ptr := Ptr + 1;\n-\n-         else\n-            exit;\n-         end if;\n-      end loop;\n-\n-   end Analyze_Prolog;\n-\n-   -------------------\n-   -- Enter_Handler --\n-   -------------------\n-\n-   procedure Enter_Handler (M : Machine_State; Handler : Handler_Loc) is\n-   begin\n-      Asm (\"mov %0,%%edx\", Inputs => Machine_State'Asm_Input (\"r\", M));\n-      Asm (\"mov %0,%%eax\", Inputs => Handler_Loc'Asm_Input (\"r\", Handler));\n-\n-      Asm (\"mov 4(%%edx),%%ebx\");    -- M.Regs (ebx)\n-      Asm (\"mov 12(%%edx),%%ebp\");   -- M.Regs (ebp)\n-      Asm (\"mov 16(%%edx),%%esi\");   -- M.Regs (esi)\n-      Asm (\"mov 20(%%edx),%%edi\");   -- M.Regs (edi)\n-      Asm (\"mov 8(%%edx),%%esp\");    -- M.Regs (esp)\n-      Asm (\"jmp %*%%eax\");\n-   end Enter_Handler;\n-\n-   ----------------\n-   -- Fetch_Code --\n-   ----------------\n-\n-   function Fetch_Code (Loc : Code_Loc) return Code_Loc is\n-   begin\n-      return Loc;\n-   end Fetch_Code;\n-\n-   ------------------------\n-   -- Free_Machine_State --\n-   ------------------------\n-\n-   procedure Free_Machine_State (M : in out Machine_State) is\n-   begin\n-      Memory.Free (Address (M));\n-      M := Machine_State (Null_Address);\n-   end Free_Machine_State;\n-\n-   ------------------\n-   -- Get_Code_Loc --\n-   ------------------\n-\n-   function Get_Code_Loc (M : Machine_State) return Code_Loc is\n-\n-      Asm_Call_Size : constant := 2;\n-      --  Minimum size for a call instruction under ix86. Using the minimum\n-      --  size is safe here as the call point computed from the return point\n-      --  will always be inside the call instruction.\n-\n-      MS : constant MState_Ptr := To_MState_Ptr (M);\n-\n-   begin\n-      if MS.eip = 0 then\n-         return To_Address (MS.eip);\n-      else\n-         --  When doing a call the return address is pushed to the stack.\n-         --  We want to return the call point address, so we subtract\n-         --  Asm_Call_Size from the return address. This value is set\n-         --  to 5 as an asm call takes 5 bytes on x86 architectures.\n-\n-         return To_Address (MS.eip - Asm_Call_Size);\n-      end if;\n-   end Get_Code_Loc;\n-\n-   --------------------------\n-   -- Machine_State_Length --\n-   --------------------------\n-\n-   function Machine_State_Length\n-     return System.Storage_Elements.Storage_Offset\n-   is\n-   begin\n-      return MState'Max_Size_In_Storage_Elements;\n-   end Machine_State_Length;\n-\n-   ---------------\n-   -- Pop_Frame --\n-   ---------------\n-\n-   procedure Pop_Frame\n-     (M    : Machine_State;\n-      Info : Subprogram_Info_Type)\n-   is\n-      MS  : constant MState_Ptr := To_MState_Ptr (M);\n-      PL  : Prolog_Type;\n-\n-      SOC_Ptr : Uns32;\n-      --  Pointer to stack location after last SOC push\n-\n-      Rtn_Ptr : Uns32;\n-      --  Pointer to stack location containing return address\n-\n-   begin\n-      Analyze_Prolog (Info, PL);\n-\n-      --  Case of frame register, use EBP, safer than ESP\n-\n-      if PL.Frame_Reg then\n-         SOC_Ptr := MS.Regs (ebp) - PL.Frame_Length;\n-         Rtn_Ptr := MS.Regs (ebp) + 4;\n-         MS.Regs (ebp) := To_Uns32_Ptr (MS.Regs (ebp)).all;\n-\n-      --  No frame pointer, use ESP, and hope we have it exactly right!\n-\n-      else\n-         SOC_Ptr := MS.Regs (esp);\n-         Rtn_Ptr := SOC_Ptr + PL.Frame_Length;\n-      end if;\n-\n-      --  Get saved values of SOC registers\n-\n-      for J in reverse 1 .. PL.Num_SOC_Push loop\n-         MS.Regs (PL.SOC_Push_Regs (J)) := To_Uns32_Ptr (SOC_Ptr).all;\n-         SOC_Ptr := SOC_Ptr + 4;\n-      end loop;\n-\n-      MS.eip := To_Uns32_Ptr (Rtn_Ptr).all;\n-      MS.Regs (esp) := Rtn_Ptr + 4;\n-   end Pop_Frame;\n-\n-   -----------------------\n-   -- Set_Machine_State --\n-   -----------------------\n-\n-   procedure Set_Machine_State (M : Machine_State) is\n-      N : constant Asm_Output_Operand := No_Output_Operands;\n-\n-   begin\n-      Asm (\"mov %0,%%edx\", N, Machine_State'Asm_Input (\"r\", M));\n-\n-      --  At this stage, we have the following situation (note that we\n-      --  are assuming that the -fomit-frame-pointer switch has not been\n-      --  used in compiling this procedure.\n-\n-      --     (value of M)\n-      --     return point\n-      --     old ebp          <------ current ebp/esp value\n-\n-      --  The values of registers ebx/esi/edi are unchanged from entry\n-      --  so they have the values we want, and %edx points to the parameter\n-      --  value M, so we can store these values directly.\n-\n-      Asm (\"mov %%ebx,4(%%edx)\");    -- M.Regs (ebx)\n-      Asm (\"mov %%esi,16(%%edx)\");   -- M.Regs (esi)\n-      Asm (\"mov %%edi,20(%%edx)\");   -- M.Regs (edi)\n-\n-      --  The desired value of ebp is the old value\n-\n-      Asm (\"mov 0(%%ebp),%%eax\");\n-      Asm (\"mov %%eax,12(%%edx)\");   -- M.Regs (ebp)\n-\n-      --  The return point is the desired eip value\n-\n-      Asm (\"mov 4(%%ebp),%%eax\");\n-      Asm (\"mov %%eax,(%%edx)\");   -- M.eip\n-\n-      --  Finally, the desired %esp value is the value at the point of\n-      --  call to this routine *before* pushing the parameter value.\n-\n-      Asm (\"lea 12(%%ebp),%%eax\");\n-      Asm (\"mov %%eax,8(%%edx)\");   -- M.Regs (esp)\n-   end Set_Machine_State;\n-\n-   ------------------------------\n-   -- Set_Signal_Machine_State --\n-   ------------------------------\n-\n-   procedure Set_Signal_Machine_State\n-     (M       : Machine_State;\n-      Context : System.Address)\n-   is\n-      pragma Warnings (Off, M);\n-      pragma Warnings (Off, Context);\n-\n-   begin\n-      null;\n-   end Set_Signal_Machine_State;\n-\n-end System.Machine_State_Operations;"}, {"sha": "04906e4cd2c3643dc1123b9155690cabd5b61595", "filename": "gcc/ada/s-mastop.adb", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-mastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-mastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mastop.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                             (Dummy version)                              --\n --                                                                          --\n---          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1999-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,8 +41,6 @@ package body System.Machine_State_Operations is\n \n    pragma Warnings (Off);\n \n-   use System.Exceptions;\n-\n    ----------------------------\n    -- Allocate_Machine_State --\n    ----------------------------\n@@ -52,15 +50,6 @@ package body System.Machine_State_Operations is\n       return Machine_State (Null_Address);\n    end Allocate_Machine_State;\n \n-   -------------------\n-   -- Enter_Handler --\n-   -------------------\n-\n-   procedure Enter_Handler (M : Machine_State; Handler : Handler_Loc) is\n-   begin\n-      null;\n-   end Enter_Handler;\n-\n    ----------------\n    -- Fetch_Code --\n    ----------------\n@@ -102,9 +91,7 @@ package body System.Machine_State_Operations is\n    -- Pop_Frame --\n    ---------------\n \n-   procedure Pop_Frame\n-     (M    : Machine_State;\n-      Info : Subprogram_Info_Type) is\n+   procedure Pop_Frame (M : Machine_State) is\n    begin\n       null;\n    end Pop_Frame;\n@@ -118,16 +105,4 @@ package body System.Machine_State_Operations is\n       null;\n    end Set_Machine_State;\n \n-   ------------------------------\n-   -- Set_Signal_Machine_State --\n-   ------------------------------\n-\n-   procedure Set_Signal_Machine_State\n-     (M       : Machine_State;\n-      Context : System.Address)\n-   is\n-   begin\n-      null;\n-   end Set_Signal_Machine_State;\n-\n end System.Machine_State_Operations;"}, {"sha": "95f0da5da8bcec445a0c6b57df9cac0ae7f46a3d", "filename": "gcc/ada/s-mastop.ads", "status": "modified", "additions": 2, "deletions": 67, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-mastop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-mastop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mastop.ads?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1999-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,7 +36,6 @@ pragma Polling (Off);\n --  elaboration circularities with System.Exception_Tables.\n \n with System.Storage_Elements;\n-with System.Exceptions;\n \n package System.Machine_State_Operations is\n \n@@ -79,65 +78,11 @@ package System.Machine_State_Operations is\n    --  outer level, or some other frame for which no information can be\n    --  provided.\n \n-   procedure Pop_Frame\n-     (M    : Machine_State;\n-      Info : System.Exceptions.Subprogram_Info_Type);\n+   procedure Pop_Frame (M : Machine_State);\n    --  This procedure pops the machine state M so that it represents the\n    --  call point, as though the current subprogram had returned. It\n    --  changes only the value referenced by M, and does not affect\n    --  the current stack environment.\n-   --\n-   --  The Info parameter represents information generated by the backend\n-   --  (see description of Subprogram_Info node in sinfo.ads). This\n-   --  information is stored as static data during compilation. The\n-   --  caller then passes this information to Pop_Frame, which will\n-   --  use it to determine what must be changed in the machine state\n-   --  (e.g. which save-over-call registers must be restored, and from\n-   --  where on the stack frame they must be restored).\n-   --\n-   --  A value of No_Info for Info means either that the backend provided\n-   --  no information for current frame, or that the current frame is an\n-   --  other language frame for which no information exists, or that this\n-   --  is an outer level subprogram. In any case, Pop_Frame sets the code\n-   --  location to Null_Address when it pops past such a frame, and this\n-   --  is taken as an indication that the exception is unhandled.\n-\n-   --  Note: at the current time, Info, if present is always a copy of\n-   --  the entry point of the procedure, as found by searching the\n-   --  subprogram table. For the case where a procedure is indeed in\n-   --  the table (either it is an Ada procedure, or a foreign procedure\n-   --  which is registered using pragma Propagate_Exceptions), then the\n-   --  entry point information will indeed be correct. It may well be\n-   --  possible for Pop_Frame to avoid using the Info parameter (for\n-   --  example if it consults auxiliary Dwarf tables to do its job).\n-   --  This is desirable if it can be done, because it means that it\n-   --  will work fine to propagate exceptions through unregistered\n-   --  foreign procedures. What will happen is that the search in the\n-   --  Ada subprogram table will find a junk entry. Even if this junk\n-   --  entry has an exception table, none of them will apply to the\n-   --  current location, so they will be ignored, and then Pop_Frame\n-   --  will be called to pop the frame. The Info parameter for this\n-   --  call will be junk, but if it is not used that does not matter.\n-   --  Note that the address recorded in the traceback table is of\n-   --  the exception location, so the traceback will be correct even\n-   --  in this case.\n-\n-   procedure Enter_Handler\n-     (M       : Machine_State;\n-      Handler : System.Exceptions.Handler_Loc);\n-   --  When Propagate_Handler locates an applicable exception handler, it\n-   --  calls Enter_Handler, passing it two parameters. The first is the\n-   --  machine state that corresponds to what is required for entry to\n-   --  the handler, as computed by repeated Pop_Frame calls to reach the\n-   --  handler to be entered. The second is the code location for the\n-   --  handler itself which is the address of the label at the start of\n-   --  the handler code.\n-   --\n-   --  Note: The machine state M is likely stored on the part of the\n-   --  stack that will be popped by the call, so care must be taken\n-   --  not to pop the stack until the Machine_State is entirely read.\n-   --  The value passed as Handler was obtained from elaboration of\n-   --  an N_Handler_Loc node by the backend.\n \n    function Fetch_Code (Loc : Code_Loc) return Code_Loc;\n    --  Some architectures (notably VMS) use a descriptor to describe\n@@ -150,14 +95,4 @@ package System.Machine_State_Operations is\n    --  This routine sets M from the current machine state. It is called\n    --  when an exception is initially signalled to initialize the state.\n \n-   procedure Set_Signal_Machine_State\n-     (M       : Machine_State;\n-      Context : System.Address);\n-   --  This routine sets M from the machine state that corresponds to the\n-   --  point in the code where a signal was raised. The parameter Context\n-   --  is a pointer to a structure created by the operating system when a\n-   --  signal is raised, and made available to the signal handler. The\n-   --  format of this context block, and the manner in which it is made\n-   --  available to the handler, are implementation dependent.\n-\n end System.Machine_State_Operations;"}, {"sha": "fc337fbef4b7d426e0f52c4d7a8ed6cc057baf64", "filename": "gcc/ada/s-traceb-mastop.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-traceb-mastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fs-traceb-mastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-traceb-mastop.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 1999-2003 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1999-2005 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,8 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This version assumes that System.Machine_State_Operations.Pop_Frame can\n---  work with the Info parameter being null.\n+--  This version uses System.Machine_State_Operations routines\n \n with System.Machine_State_Operations;\n \n@@ -73,7 +72,7 @@ package body System.Traceback is\n          Code := Get_Code_Loc (M);\n          exit when Code = Null_Address or else N_Skips = Skip_Frames;\n \n-         Pop_Frame (M, System.Null_Address);\n+         Pop_Frame (M);\n          N_Skips := N_Skips + 1;\n       end loop;\n \n@@ -90,7 +89,7 @@ package body System.Traceback is\n             Trace (Len) := Code;\n          end if;\n \n-         Pop_Frame (M, System.Null_Address);\n+         Pop_Frame (M);\n       end loop;\n \n       Free_Machine_State (M);"}, {"sha": "de69081a104221c63a78246c3e645887291e2891", "filename": "gcc/ada/switch-b.adb", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fswitch-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fswitch-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -126,14 +126,6 @@ package body Switch.B is\n                end if;\n             end loop;\n \n-            --  Make sure Zero_Cost_Exceptions is set if gnatdX set. This\n-            --  is for backwards compatibility with old versions and usage.\n-\n-            if Debug_Flag_XX then\n-               Zero_Cost_Exceptions_Set := True;\n-               Zero_Cost_Exceptions_Val := True;\n-            end if;\n-\n             return;\n \n          --  Processing for D switch"}, {"sha": "6c5ed1ff4539d08213a795b5f6c52a0fde051e4a", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -585,14 +585,6 @@ package body Switch.M is\n                end if;\n             end loop;\n \n-            --  Make sure Zero_Cost_Exceptions is set if gnatdX set. This\n-            --  is for backwards compatibility with old versions and usage.\n-\n-            if Debug_Flag_XX then\n-               Zero_Cost_Exceptions_Set := True;\n-               Zero_Cost_Exceptions_Val := True;\n-            end if;\n-\n             return;\n \n          --  Processing for e switch"}, {"sha": "0fd9c7fc596d49ebc1097032e3393040920deaab", "filename": "gcc/ada/targparm.adb", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Ftargparm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Ftargparm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -67,10 +67,9 @@ package body Targparm is\n       UAM,  --   Use_Ada_Main_Program_Name\n       VMS,  --   OpenVMS\n       ZCD,  --   ZCX_By_Default\n-      ZCG,  --   GCC_ZCX_Support\n-      ZCF); --   Front_End_ZCX_Support\n+      ZCG); --   GCC_ZCX_Support\n \n-   subtype Targparm_Tags_OK is Targparm_Tags range AAM .. ZCF;\n+   subtype Targparm_Tags_OK is Targparm_Tags range AAM .. ZCG;\n    --  Range excluding obsolete entries\n \n    Targparm_Flags : array (Targparm_Tags) of Boolean := (others => False);\n@@ -106,7 +105,6 @@ package body Targparm is\n    VMS_Str : aliased constant Source_Buffer := \"OpenVMS\";\n    ZCD_Str : aliased constant Source_Buffer := \"ZCX_By_Default\";\n    ZCG_Str : aliased constant Source_Buffer := \"GCC_ZCX_Support\";\n-   ZCF_Str : aliased constant Source_Buffer := \"Front_End_ZCX_Support\";\n \n    --  The following defines a set of pointers to the above strings,\n    --  indexed by the tag values.\n@@ -140,8 +138,7 @@ package body Targparm is\n       UAM_Str'Access,\n       VMS_Str'Access,\n       ZCD_Str'Access,\n-      ZCG_Str'Access,\n-      ZCF_Str'Access);\n+      ZCG_Str'Access);\n \n    -----------------------\n    -- Local Subprograms --\n@@ -571,7 +568,6 @@ package body Targparm is\n                      when VMS => OpenVMS_On_Target                   := Result;\n                      when ZCD => ZCX_By_Default_On_Target            := Result;\n                      when ZCG => GCC_ZCX_Support_On_Target           := Result;\n-                     when ZCF => Front_End_ZCX_Support_On_Target     := Result;\n \n                      goto Line_Loop_Continue;\n                   end case;"}, {"sha": "b29f506be759b457417ee0306a73f942970519e7", "filename": "gcc/ada/targparm.ads", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Ftargparm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Ftargparm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.ads?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -278,50 +278,24 @@ package Targparm is\n \n    --    Controlling the selection of methods\n \n-   --      The Front-End Longjmp/Setjmp approach is always available in\n-   --      all implementations. If it is not the default method, then it\n-   --      may be explicitly specified by the use of -gnatL. Note however\n-   --      that there is a requirement that all Ada units in a partition\n-   --      be compiled with this overriding option if it is not the default.\n-\n-   --      On some, but not all, implementations of GNAT, one of the two\n-   --      ZCX approaches (but not both) is implemented. If this is the\n-   --      case, and ZCX is not the default mechanism, then ZCX handling\n-   --      (front-end or back-end according to the implementation) may be\n-   --      specified by use of the -gnatZ switch. Again, this switch must\n-   --      be used to compile all Ada units in a partition. The use of\n-   --      the -gnatZ switch will cause termination with a fatal error.\n-\n-   --      Finally the debug option -gnatdX can be used to force the\n-   --      compiler to operate in front-end ZCX exception mode and force\n-   --      the front end to generate exception tables. This is only useful\n-   --      for debugging purposes for implementations which do not provide\n-   --      the possibility of front-end ZCX mode. The resulting object file\n-   --      is unusable, but this debug switch may still be useful (e.g. in\n-   --      conjunction with -gnatG) for front-end debugging purposes.\n+   --      On most implementations, back-end zero-cost exceptions are used.\n+   --      Otherwise, Front-End Longjmp/Setjmp approach is used.\n+   --      Note that there is a requirement that all Ada units in a partition\n+   --      be compiled with the same exception model.\n \n    --    Control of Available Methods and Defaults\n \n-   --      The following switches specify which of the two ZCX methods\n-   --      (if any) is available in an implementation, and which method\n-   --      is the default method.\n+   --      The following switches specify whether ZCX is available, and\n+   --      whether it is enabled by default.\n \n    ZCX_By_Default_On_Target : Boolean := False;\n    --  Indicates if zero cost exceptions are active by default. If this\n    --  variable is False, then the only possible exception method is the\n    --  front-end setjmp/longjmp approach, and this is the default. If\n-   --  this variable is True, then one of the following two flags must\n-   --  be True, and represents the method to be used by default.\n+   --  this variable is True, then GCC ZCX is used.\n \n    GCC_ZCX_Support_On_Target  : Boolean := False;\n-   --  Indicates that when ZCX is active, the mechanism to be used is the\n-   --  back-end ZCX exception approach. If this variable is set to True,\n-   --  then Front_End_ZCX_Support_On_Target must be False.\n-\n-   Front_End_ZCX_Support_On_Target : Boolean := False;\n-   --  Indicates that when ZCX is active, the mechanism to be used is the\n-   --  front-end ZCX exception approach. If this variable is set to True,\n-   --  then GCC_ZCX_Support_On_Target must be False.\n+   --  Indicates that the target supports GCC Exceptions.\n \n    ------------------------------------\n    -- Run-Time Library Configuration --\n@@ -367,9 +341,6 @@ package Targparm is\n    --    with the exception of the priority of the environment task, which\n    --    is needed by the Ravenscar run-time.\n    --\n-   --    The generation of exception tables is suppressed for front end\n-   --    ZCX exception handling (since we assume no exception handling).\n-   --\n    --    The calls to __gnat_initialize and __gnat_finalize are omitted\n    --\n    --    All finalization and initialization (controlled types) is omitted"}, {"sha": "39f3b71f5e05230c755ccd3fe66fbe798aaa0ebc", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2c495da918ad782b233126773e4fc34bdacbe5/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=1a2c495da918ad782b233126773e4fc34bdacbe5", "patch": "@@ -220,11 +220,6 @@ begin\n    Write_Switch_Char (\"l\");\n    Write_Line (\"Output full source listing with embedded error messages\");\n \n-   --  Line for -gnatL switch\n-\n-   Write_Switch_Char (\"L\");\n-   Write_Line (\"Use longjmp/setjmp for exception handling\");\n-\n    --  Line for -gnatm switch\n \n    Write_Switch_Char (\"mnnn\");\n@@ -465,11 +460,6 @@ begin\n    Write_Switch_Char (\"z\");\n    Write_Line (\"Distribution stub generation (r/c for receiver/caller stubs)\");\n \n-   --  Line for -gnatZ switch\n-\n-   Write_Switch_Char (\"Z\");\n-   Write_Line (\"Use zero cost exception handling\");\n-\n    --  Line for -gnat83 switch\n \n    Write_Switch_Char (\"83\");"}]}